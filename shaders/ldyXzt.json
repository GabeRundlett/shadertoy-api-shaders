{
    "Shader": {
        "info": {
            "date": "1465986981",
            "description": "Another KIFS Flythrough - see the source",
            "flags": 32,
            "hasliked": 0,
            "id": "ldyXzt",
            "likes": 28,
            "name": "Interacting with Fractals",
            "published": 3,
            "tags": [
                "fractal",
                "raymarch",
                "interactive",
                "kifs"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 1497
        },
        "renderpass": [
            {
                "code": "// \"Interacting with Fractals\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Motivated by Shane's \"KIFS Flythrough\"; see his shader for background info (all\n  the rotating, folding and stretching) and references.\n\n  Control panel appears when colored ring (or a hidden control) clicked; panel fades\n  automatically; use mouse to look around.\n\n  Sliders control size, scaling, iterations and speed (the numbers don't mean much);\n  there are lots of possible extensions\n*/\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nvec4 Loadv4 (int idVar);\n\nconst float pi = 3.14159;\nconst int nItMax = 10;\n\nfloat tCur, dstFar, obSize, sclFac;\nint nIt;\n\nfloat ObjDf (vec3 p)\n{\n  vec3 b;\n  float d, a;\n  d = dstFar + 1.;\n  a = 1. / sclFac;\n  p = abs (2. * fract (0.5 * p) - 1.);\n  for (int j = 0; j < nItMax; j ++) {\n    p.xy = Rot2D (p.xy, 0.75 * pi);\n    p.yz = Rot2D (p.yz, 0.625 * pi);\n    p = abs (p);\n    p.xy = (p.x > p.y) ? p.xy : p.yx;\n    p.xz = (p.x > p.z) ? p.xz : p.zx;\n    p.yz = (p.y > p.z) ? p.yz : p.zy;\n    b = vec3 (1., 0.75, 0.5) * (1. - sclFac);\n    p = p * sclFac + b;\n    if (p.z < 0.5 * b.z) p.z -= b.z;\n    p = abs (p);\n    d = min (d, max (max (p.x, p.y), p.z) * a);\n    a /= sclFac;\n    if (j == nIt - 1) break;\n  }\n  return d - obSize;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e;\n  e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float dMax)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.04;\n  for (int j = 0; j < 20; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.04 * d, h));\n    d += max (0.1, 0.05 * d);\n    if (sh < 0.05 || d > dMax) break;\n  }\n  return 0.2 + 0.8 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, ltPos, ltDir, col, bgCol, fgCol;\n  vec2 canvas, uv, aa, ori, ca, sa;\n  float dstHit, az, el, sh, ltDist, atten, zmFac, pnFac;\n  ltPos = ro;\n  ltPos.yz += 0.3;\n  dstHit = ObjRay (ro, rd);\n  if (dstHit < dstFar) {\n    ro += rd * dstHit;\n    vn = ObjNf (ro);\n    vn = VaryNf (100. * ro, vn, 2. / (1. + 2. * dstHit / dstFar));\n    ltDir = ltPos - ro;\n    ltDist = max (length (ltDir), 0.1);\n    ltDir /= ltDist;\n    sh = ObjSShadow (ro, ltDir, ltDist);\n    atten = 1. / (1. + 0.05 * ltDist * (1. + 0.1 * ltDist));\n    fgCol = HsvToRgb (vec3 (mod (0.1 * tCur + 0.5, 1.), 1., 1.));\n    col = fgCol * (0.2 + 0.8 * atten * sh * max (dot (ltDir, vn), 0.)) +\n       0.7 * atten * sh * pow (max (dot (reflect (ltDir, vn), rd), 0.), 16.);\n  } else col = vec3 (0.);\n  bgCol = HsvToRgb (vec3 (mod (0.1 * tCur, 1.), 0.7, 0.5));\n  col = mix (col, bgCol, clamp (5. * dstHit / dstFar, 0., 1.));\n  return pow (clamp (col, 0., 1.), vec3 (0.6));\n}\n\nvec4 ShowWg (vec2 uv, vec2 canvas, vec4 parmV)\n{\n  vec4 wgBx[4];\n  vec3 col, cc;\n  vec2 ut, ust;\n  float vW[4], asp, s;\n  cc = vec3 (1., 0., 0.);\n  asp = canvas.x / canvas.y;\n  for (int k = 0; k <= 3; k ++)\n     wgBx[k] = vec4 ((0.3 + 0.05 * float (k)) * asp, 0., 0.014 * asp, 0.18);\n  vW[0] = parmV.x;  vW[1] = parmV.y;  vW[2] = parmV.z;  vW[3] = parmV.w;\n  col = vec3 (0.);\n  for (int k = 0; k <= 3; k ++) {\n    ut = 0.5 * uv - wgBx[k].xy;\n    ust = abs (ut) - wgBx[k].zw * vec2 (0.7, 1.);\n    if (max (ust.x, ust.y) < 0.) {\n      if  (min (abs (ust.x), abs (ust.y)) * canvas.y < 2.) col = 0.3 * cc.xxy;\n      else col = (mod (0.5 * ((0.5 * uv.y - wgBx[k].y) / wgBx[k].w - 0.99), 0.1) *\n         canvas.y < 6.) ? 0.3 * cc.xxy : 0.6 * cc.xxy;\n    }\n    ut.y -= (vW[k] - 0.5) * 2. * wgBx[k].w;\n    s = ShowInt (ut - vec2 (0.018, -0.01), 0.02 * vec2 (asp, 1.), 2.,\n       clamp (floor (100. * vW[k]), 0., 99.));\n    if (s > 0.) col = (k < 3) ? cc.yxy : cc;\n    ut = abs (ut) * vec2 (1., 1.5);\n    if (max (abs (ut.x), abs (ut.y)) < 0.025 && max (ut.x, ut.y) > 0.02) col = cc.xxy;\n  }\n  return vec4 (col, step (0.001, length (col)));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat, wgBxC, parmV, c4;\n  vec3 ro, rd, col, cw;\n  vec2 canvas, uv, aa, ori, ca, sa;\n  float el, az, zmFac, pnFac, asp, tCurM, mvTot, cm;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  asp = canvas.x / canvas.y;\n  wgBxC = vec4 (0.45 * asp, -0.4, 0.022, 0.);\n  parmV = Loadv4 (0);\n  obSize = 0.1 * parmV.x;\n  sclFac = 10. * parmV.y;\n  nIt = int (10. * parmV.z);\n  stDat = Loadv4 (1);\n  el = stDat.x;\n  az = stDat.y;\n  tCur = stDat.z;\n  tCurM = stDat.w;\n  stDat = Loadv4 (2);\n  mvTot = stDat.x;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  ro = vec3 (0., 0., 0.6 * mvTot);\n  zmFac = 2.;\n  pnFac = 1.;  \n  aa = atan (uv / zmFac);\n  rd = normalize (vec3 ((1. + pnFac) * sin (aa) / (pnFac + cos (aa)), 1.));\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * rd;\n  rd.xy = Rot2D (rd.xy, 0.61 * mvTot);\n  rd.xz = Rot2D (rd.xz, 0.51 * mvTot);\n  rd.yz = Rot2D (rd.yz, 0.41 * mvTot);\n  dstFar = 40.;\n  col = ShowScene (ro, rd);\n  if (canvas.y < 200. || tCur - tCurM < 5.) {\n    c4 = ShowWg (uv, canvas, parmV);\n    cw = mix (col, c4.rgb, c4.a);\n    cm = (canvas.y < 200.) ? 0.3 : 0.2 + 0.8 * smoothstep (4., 5., tCur - tCurM);\n  } else {\n    cw = HsvToRgb (vec3 (mod (0.1 * tCur + 0.3, 1.), 1., 0.5));\n    cm = 0.3 + 0.7 * step (2., abs (length (0.5 * uv - wgBxC.xy) -\n       wgBxC.z) * canvas.y);\n  }\n  fragColor = vec4 (mix (cw, col, cm), 1.);\n}\n\nfloat DigSeg (vec2 q)\n{\n  return (1. - smoothstep (0.13, 0.17, abs (q.x))) *\n     (1. - smoothstep (0.5, 0.57, abs (q.y)));\n}\n\nfloat ShowDig (vec2 q, int iv)\n{\n  float d;\n  int k, kk;\n  const vec2 vp = vec2 (0.5, 0.5), vm = vec2 (-0.5, 0.5), vo = vec2 (1., 0.);\n  if (iv < 5) {\n    if (iv == -1) k = 8;\n    else if (iv == 0) k = 119;\n    else if (iv == 1) k = 36;\n    else if (iv == 2) k = 93;\n    else if (iv == 3) k = 109;\n    else k = 46;\n  } else {\n    if (iv == 5) k = 107;\n    else if (iv == 6) k = 122;\n    else if (iv == 7) k = 37;\n    else if (iv == 8) k = 127;\n    else k = 47;\n  }\n  q = (q - 0.5) * vec2 (1.8, 2.3);\n  d = 0.;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.yx - vo);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.xy - vp);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.xy - vm);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.yx);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.xy + vm);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.xy + vp);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.yx + vo);\n  return d;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (min (q.x, q.y) >= 0. && max (q.x, q.y) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    nDig = (val > 0.) ? floor (max (log (val) / log (10.), 0.) + 0.001) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (sgn < 0.) {\n      if (idChar == mxChar - nDig - 1.) s = ShowDig (q, -1);\n      else ++ v;\n    }\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i <= 4; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s,\n     Fbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 32.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Interacting with Fractals\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst float pi = 3.14159;\nconst float txRow = 32.;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 wgBx[5], mPtr, mPtrP, stDat, parmV;\n  vec2 iFrag, canvas, ust;\n  float tCur, tCurP, tCurM, vW, asp, el, az, vel, mvTot;\n  int pxId, wgSel, wgReg, kSel;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4) discard;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  wgSel = -1;\n  wgReg = -2;\n  asp = canvas.x / canvas.y;\n  el = -0.1;\n  az = 0.;\n  if (iFrame <= 5) {\n    parmV = vec4 (0.35, 0.5, 0.2, 0.4);\n    mvTot = 0.;\n    mPtrP = mPtr;\n    tCurP = tCur;\n    tCurM = tCur;\n  } else {\n    parmV = Loadv4 (0);\n    vel = parmV.w;\n    stDat = Loadv4 (1);\n    tCurP = stDat.z;\n    tCurM = stDat.w;\n    stDat = Loadv4 (2);\n    mvTot = stDat.x;\n    mvTot += vel * (tCur - tCurP);\n    stDat = Loadv4 (3);\n    mPtrP = vec4 (stDat.xyz, 0.);\n    wgSel = int (stDat.w);\n  }\n  if (mPtr.z > 0.) {\n    for (int k = 0; k <= 3; k ++)\n       wgBx[k] = vec4 ((0.3 + 0.05 * float (k)) * asp, 0., 0.014 * asp, 0.18);\n    wgBx[4] = vec4 (0.45 * asp, -0.4, 0.022, 0.);\n    for (int k = 0; k <= 3; k ++) {\n      ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx[k].xy) - wgBx[k].zw;\n      if (max (ust.x, ust.y) < 0.) wgReg = k;\n    }\n    ust = mPtr.xy * vec2 (asp, 1.) - wgBx[4].xy;\n    if (length (ust) < wgBx[4].z) wgReg = 4;\n    if (mPtrP.z <= 0.) wgSel = wgReg;\n    if (wgSel >= 0) tCurM = tCur;\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n  }\n  if (wgSel < 0) {\n    if (mPtr.z > 0.) {\n      az = 2. * pi * mPtr.x;\n      el = 0.8 * pi * mPtr.y;\n    }\n  } else {\n    if (wgSel < 4) {\n      for (int k = 0; k <= 3; k ++) {\n        if (wgSel == k) {\n          kSel = k;\n          vW = clamp (0.5 + 0.5 * (mPtr.y - wgBx[k].y) / wgBx[k].w, 0., 0.99);\n          break;\n        }\n      }\n      if      (kSel == 0) parmV.x = max (vW, 0.05);\n      else if (kSel == 1) parmV.y = max (vW, 0.1);\n      else if (kSel == 2) parmV.z = clamp (vW, 0.1, 0.8);\n      else if (kSel == 3) parmV.w = vW;\n    }\n  }\n  if      (pxId == 0) stDat = parmV;\n  else if (pxId == 1) stDat = vec4 (el, az, tCur, tCurM);\n  else if (pxId == 2) stDat = vec4 (mvTot, 0., 0., 0.);\n  else if (pxId == 3) stDat = vec4 (mPtr.xyz, float (wgSel));\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}