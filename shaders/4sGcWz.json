{
    "Shader": {
        "info": {
            "date": "1521711398",
            "description": "An abstract tropical fish made with a complex map. Whatever you do, don't STRESS HIM with your mouse. :)",
            "flags": 0,
            "hasliked": 0,
            "id": "4sGcWz",
            "likes": 60,
            "name": "Tropical Fish",
            "published": 3,
            "tags": [
                "2d",
                "voronoi",
                "domain",
                "complex",
                "coloring"
            ],
            "usePreview": 0,
            "username": "rigel",
            "viewed": 9394
        },
        "renderpass": [
            {
                "code": "/**\n\tAuthor: Rigel rui@gil.com\n\tlicence: https://creativecommons.org/licenses/by/4.0/\n\tlink: https://www.shadertoy.com/view/4sGcWz\n\t------------------------------------------------------\n\n\tMy goal with this shader was to learn about the voronoi algorithm.\n\tThe algorithm in itself is pretty straighforward, but the distance\n\tto edges is a bit more tricky.\n\n\tSo I started with this reference article by IQ.\n\thttps://iquilezles.org/articles/voronoilines\n\n\tAnd then searching Shadertoy I stumbled on Shane quest for the perfect \n\tround borders voronoi and his interactions with FabriceNeyret2, DR2 and Tomkh.\n\tIt was quite fun to follow the breadcrumbs and I learned a lot :)\n\n\tShane - https://www.shadertoy.com/view/4dsfDl\n\tDR2 - https://www.shadertoy.com/view/Xsyczh\n\tFabriceNeyret2 - https://www.shadertoy.com/view/4dKSDV\n\tTomkh - https://www.shadertoy.com/view/llG3zy\n\t\n\tThe voronoi algorithm is constant time, because it's based on a grid.\n\tBut that makes the feature points evenly distributed, wich can be kind of\n\tlimitied from an artistic perspective...\n\tI wanted to have a variable point density, so I needed a way to distort the grid.\n\t\n\tLuckly complex functions have this tendency of distorting space around zeros\n\tand poles (infinity), so I decided to try that.\n\n\tThere is a way to visualize complex functions called Domain Coloring \n\thttps://en.wikipedia.org/wiki/Domain_coloring\n\n\tThis shader is nothing more than Domain Coloring taken literaly.\n\tI use the domain as a kind coloring book, and then apply the transform.\n\n\tThe complex function is the Lambert Series https://en.wikipedia.org/wiki/Lambert_series\n\tThat I used in my shader about Domain Coloring https://www.shadertoy.com/view/ltjczK\n\tI already thought at that time, that it looked like a fish, so I only needed to make it so. :)\n*/\n\n// uncomment if you want to see the domain without the transform\n//#define DOMAIN \n\n// uncomment to see the grid, and visualize the distortion\n//#define GRID\n\n\n// a few utility functions\n// smoothstep antialias with fwidth\nfloat ssaa(float v) { return smoothstep(-1.,1.,v/fwidth(v)); }\n// stroke an sdf 'd', with a width 'w', and a fill 'f' \nfloat stroke(float d, float w, bool f) {  return abs(ssaa(abs(d)-w*.5) - float(f)); }\n// fills an sdf 'd', and a fill 'f'. false for the fill means inverse \nfloat fill(float d, bool f) { return abs(ssaa(d) - float(f)); }\n// a signed distance function for a rectangle 's' is size\nfloat sdfRect(vec2 uv, vec2 s) { vec2 auv = abs(uv); return max(auv.x-s.x,auv.y-s.y); }\n// a signed distance function for a circle, 'r' is radius\nfloat sdfCircle(vec2 uv, float r) { return length(uv)-r; }\n// hash function for pseudorandom numbers\nvec2 hash2( vec2 p ) { return fract(sin(vec2(dot(p,vec2(1275.1,3131.7)),dot(p,vec2(269.5,183.3))))*43758.5453); }\n// a cosine palette with domain d between 0-1\nvec3 pal(float d) { return .5 * ( cos(d*6.283*vec3(2.,2.,1.) + vec3(.0,1.4,.4)) + 1. ); }\n// a simple square grid, you can control the scale and the width\nfloat grid(vec2 uv, float scale, float w) { vec2 guv = fract((uv*scale)-.5)-.5; return max(stroke(guv.x,w,true),stroke(guv.y,w,true)); }\n// conversion from cartesian to polar\nvec2 toPolar(vec2 uv) { return vec2(length(uv),atan(uv.y,uv.x)); }\n// conversion from polar to cartesian\nvec2 toCarte(vec2 z) { return z.x*vec2(cos(z.y),sin(z.y)); }\n// complex division in polar form z = vec2(radius,angle)\nvec2 zdiv(vec2 z1, vec2 z2) { return vec2(z1.x/z2.x,z1.y-z2.y); }\n// complex pow in polar form z = vec2(radius,angle)\nvec2 zpow(vec2 z, float n) { return vec2(exp(log(z.x)*n),z.y*n); }\n// complex sub in polar form z = vec2(radius,angle)\nvec2 zsub(vec2 z1, vec2 z2) { return toPolar(toCarte(z1) - toCarte(z2)); }\n\n\n// This is the Lambert series transform\n// https://en.wikipedia.org/wiki/Lambert_series\nvec2 lambert(vec2 uv, float m) {\n    vec2 z = toPolar(uv);\n    vec2 sum = vec2(.0);\n    vec2 offset = vec2(1.+m * cos(iTime*3.),.2*cos(iTime*(2.+m*2.)));\n    for (float i=1.; i<7.; i++)\n        sum += toCarte(zdiv(zpow(z,i),zsub(offset,zpow(z,i))));\n   return sum;\n}\n\n// IQ's smooth minimum function.\n// https://iquilezles.org/articles/smin\nfloat smin(float a, float b, float k) {\n    float h = clamp(.5 + .5*(b - a)/k, 0., 1.);\n    return mix(b, a, h) - k*h*(1. - h);\n}\n\n// Classic voronoi algorithm taken from tomkh\n// https://www.shadertoy.com/view/llG3zy\nvec3 voronoi( in vec2 x, float m) {\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mr;\n\n    float md = 8.0;\n    for( float j=-1.; j<=1.; j++ )\n        for( float i=-1.; i<=1.; i++ ) {\n            vec2 g = vec2(i,j);\n\t    \tvec2 seed = hash2( n + g );\n            seed = .5 + .3 * cos(iTime*m * 6.283 * seed);\n            vec2 r = g + seed - f;\n            float d = dot(r,r);\n            if( d<md ) {\n                md = d;\n                mr = r;\n            }\n    }\n    //----------------------------------\n    // second pass: distance to borders,\n    //----------------------------------\n    md = 8.0;\n    for( float j=-1.; j<=1.; j++ )\n        for( float i=-1.; i<=1.; i++ ) {\n            vec2 g = vec2(i,j);\n\t    \tvec2 seed = hash2( n + g );\n            seed = .5 + .3 * cos(iTime*m * 6.283 * seed);\n\t\t    vec2 r = g + seed - f;\n\n            if( dot(mr-r,mr-r)>.0001 ) { // skip the same cell \n                // smooth minimum for rounded borders\n                // apparently I need the max(,.0) to filter out weird values\n                md = max(smin(md,dot( 0.5*(mr+r), normalize(r-mr) ),.25),.0);\n            }\n        }\n    \n\n    return vec3( mr, sqrt(md));\n}\n\n// The scene\nvec3 TropicalFish(vec2 uv) {\n\n    vec2 z = uv;\n    bool dom = false;\n\n    #ifdef DOMAIN\n        z = uv*15.-vec2(4.,.0); dom = true;\n    #else\n        // transform uv with the complex lambert series\n        z = lambert(uv*4., iMouse.z > 0. ? .4 : .0);\n    #endif\n\n    // the voronoi tesselation is \"pulled back\" by the complex map\n    // this means that we pick a color from the domain after the transform\n    vec3 vvz = voronoi(z, iMouse.w > 0. ? .7 : .2);\n\n    // a few helpers for the domain coloring\n    vec2 zv = floor(z + vvz.xy); // voronoi feature point center\n    float phase = atan(uv.y,uv.x); // phase in untransformed space to apply some masks\n\n    // the scales and back fin\n\tvec3 colorphase = pal(atan(z.y,z.x)/6.283);\n    vec3 c = mix(colorphase*.8,pal(.4+vvz.z*.7)*.7,smoothstep(0.,.2,vvz.z)); // mixin the fins with the ocean\n    c = mix(c,pal(vvz.z+.3)*.8*.5*(sin(vvz.z*6.283*8.)+1.), step(.2,vvz.z) ); // scales in the fin\n    // the center of the back fin\n    c = mix(c,colorphase*(sin(6.5*log(1.+length(zv+vec2(4.,.0)))))*.7,fill(sdfCircle(zv.xy+vec2(4.,.0),7.),false));\n\n    // scales mouth\n    vec3 mouth = mix(pal(.47+z.y*.05)*.8,pal(.5+vvz.z*.15)*.9, step(.4,vvz.z) )*smoothstep(18.,7.,length(z));\n    // kind of cheating here. It is not domain coloring, because the scales in the mouth are the same\n    // that the scales in in the back fin, so I apply the mask in the untransformed space to break the symmetry.\n    c = mix(c,mouth,smoothstep(radians(130.),radians(170.),abs(phase)) ); // phase mask\n    \n    // ocean mask\n    float ocmask = step(sdfRect(zv.xy+vec2(6.,.5),vec2(1.,1.)),.0);\n    c = mix(c,pal(.1+z.x*.05)*.6,ocmask); // ocean\n\n    // dorsal fins\n    vec3 dorsalFin = mix(pal(.47+z.y*.15),pal(.5+vvz.z*.5)*.4,.5*cos(z.y*6.283*4.));\n    float fpm = dom ? 1. : smoothstep(radians(30.),radians(17.),abs(abs(phase)-radians(100.))); // fin phase mask\n    c = mix(c,dorsalFin,fill(sdfRect(zv+vec2(4.5,.5),vec2(.5,.5)),true)*fpm);\n\n    // bubbles mask\n    float bubble = max(stroke(sdfCircle(vvz.xy,.05),.01,true),fill(sdfCircle(vvz.xy+vec2(.01),.02),true));\n    c = mix(c,pal(.8+vvz.z*.2),bubble*ocmask);  // bubles\n\n    // body\n    c = mix(c,pal(.47+z.y*.15),fill(sdfRect(zv.xy+vec2(.5,.5),vec2(.5,.5)),true)); \n    \n    // eye mask\n    float eye = max(fill(sdfCircle(z-vec2(-.33,-.14)+.05*vec2(cos(iTime),sin(iTime*2.)),.05),true),stroke(sdfCircle(z-vec2(-.33,-.14),.17),.03,true));\n    // if you remove this mask you will get a multieye monster ! :)\n    float epm = dom ? 1. : float(abs(phase-radians(150.)) < radians(30.)); // eye phase mask\n    c = mix(c,mix(pal(.8+z.x),vec3(.0),eye),fill(sdfCircle(z-vec2(-.33,-.14),.17),true)*epm); // eye\n\n\t// vignette\n\tc *= exp(-.5*dot(uv,uv));\n\n    #ifdef GRID\n        c = mix(c,vec3(1.),grid(z,1.,.05));\n    #endif\n\n    return c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = ( fragCoord.xy - iResolution.xy * .5) / iResolution.y;\n\n\tfragColor = vec4( TropicalFish(uv), 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}