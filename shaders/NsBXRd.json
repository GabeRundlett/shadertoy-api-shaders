{
    "Shader": {
        "info": {
            "date": "1620763241",
            "description": "A Ray Marching shader. The color brightness corresponds with the number of steps of the ray marcher.",
            "flags": 0,
            "hasliked": 0,
            "id": "NsBXRd",
            "likes": 5,
            "name": "Web Grid",
            "published": 3,
            "tags": [
                "3d",
                "raymarching"
            ],
            "usePreview": 0,
            "username": "R3N",
            "viewed": 334
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 100\n#define MAX_DIST 1000.0\n#define MIN_DIST 0.01\n\n// 2D matrix rotation\nvec2 rot(vec2 p, float a) {\n\treturn (p * mat2(cos(a), -sin(a), sin(a), cos(a)));\n}\n\n// Hexagon SDF by iq\nfloat Hexagon(vec2 p, float r) {\n\tconst vec3 k = vec3(-0.866025404,0.5,0.577350269);\n\tp = abs(p);\n\tp -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n\tp -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n\treturn length(p)*sign(p.y);\n}\n\n// SDFs of the objects in the scene\nfloat Dist(vec3 point) {\n\t// Strand 1\n\tvec2 sqp1 = mod(abs(point.xz), 20.0)-vec2(10, 10);\n\tsqp1 = rot(sqp1, point.y/2.0) + 0.3;\n\tfloat c1 = Hexagon(sqp1, 1.0);\n\t// Strand 2\n\tvec2 sqp2 = mod(abs(point.yz+10.0), 20.0)-vec2(10, 10);\n\tsqp2 = rot(sqp2, point.x/4.0) + 0.3;\n\tfloat c2 = Hexagon(sqp2, 1.0);\n\t// Strand 3\n\tvec2 sqp3 = mod(abs(point.xy+vec2(10,0)), 20.0)-vec2(10, 10);\n\tsqp3 = rot(sqp3, point.z/4.0) + 0.3;\n\tfloat c3 = Hexagon(sqp3, 1.0);\n\treturn min(min(c1,c2),c3);\n}\n\nvec2 RayMarch (vec3 cameraOrigin, vec3 rayDirection) {\n\tfloat minDist = 0.0;\n\tint steps = 0;\n\twhile (steps < MAX_STEPS) {\n\t\tvec3 point = cameraOrigin + rayDirection * minDist;\n\t\tfloat dist = Dist(point);\n\t\tminDist += dist;\n\t\tif (dist < MIN_DIST || abs(minDist) > MAX_DIST) {\n\t\t\tbreak;\n\t\t}\n\t\tsteps++;\n\t}\n\treturn vec2(minDist, steps);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/(iResolution.y);\n\tuv -= vec2(iResolution.x/iResolution.y/2.0, 0.5);\n\tvec3 cameraPosition = vec3(0, 5.0, 0);\n\tcameraPosition.xy = rot(cameraPosition.xy, 0.0);\n\tcameraPosition.z += iTime*10.0;\n\tcameraPosition.x += iTime*4.0;\n\tcameraPosition.y += 10.0;\n\tvec3 ray = normalize(vec3(uv.x,uv.y, 0.5));\n\tray.xz = rot(ray.xz, iTime/5.0);\n\tray.xy = rot(ray.xy, -iTime/5.0);\n\tvec2 march = RayMarch(cameraPosition, ray);\n\tvec3 rayPoint = cameraPosition + march.x * ray;\n\tvec3 col = mix(vec3(0), mix(vec3(0.9, 0.5, 0.6), vec3(0.5, 0.5, 1.0), sin(iTime/10.0)*0.5+0.5),march.y/50.0);\n\t//vec3 col = mix(vec3(0), mix(vec3(0.9, 0.5, 0.6), vec3(0.5, 0.5, 1.0), sin(iTime/10.0)*0.5+0.5),1.-march.y/50.0);\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}