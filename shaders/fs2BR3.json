{
    "Shader": {
        "info": {
            "date": "1646944214",
            "description": "This is a static version, with sampling smoothing.\nFor the averaging I needed another buffer because buffer A is used for the radiosity, and it has a high dynamic range.\nEvery pixel is a light source.\n\n\n\n\n",
            "flags": 32,
            "hasliked": 0,
            "id": "fs2BR3",
            "likes": 31,
            "name": "Screen-space radiosity (static)",
            "published": 3,
            "tags": [
                "3d",
                "screenspace",
                "radiosity"
            ],
            "usePreview": 0,
            "username": "Dave_Hoskins",
            "viewed": 1131
        },
        "renderpass": [
            {
                "code": "// by Dave Hoskins. 2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Static version\n\n// 1. Render an unlit scene from the point of view of each pixel.\n// 2. Use screen buffer to store accumulated light. ðŸŒž\n\n// Every pixel is a light source\n// This is simumlar to light patch rendering where you'd create and store a map of light patches\n\n\n// I amazes me how nicely it works, even though it can't see light from hidden objects.\n\n// I was inspired many years ago by this nice and descriptive article:\n// ( I think it was written before GPU shaders existed)\n// https://justinmeiners.github.io/Hugo-Elias-Radiosity/\n\n\nvoid mainImage( out vec4 colour, in vec2 coord )\n{\n    vec4 col = texelFetch(iChannel0, ivec2(coord), 0);\n    // Probably don't need to clamp, but I was getting a lot of computer crashes, so maybe it was a div by 0 thing.\n    col.w = max(col.w,  1.0);\n    // Divide by a frame count for averaging...\n    col.xyz /= col.w;\n    \n    colour = vec4(sqrt(col.xyz), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// by Dave Hoskins. 2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\n#define UNI(a, b) (a.x) < (b.x) ? a:b\nstruct Box\n{\n    vec3 centre;\n    vec3 size;\n};\n\n// This is the simple room scene of boxes...\n// TRY LIFTING THE ROOF A LITTLE! ðŸ˜€\n// Boxes filled in as above structure\nBox boxes[] = Box[]\n(\n    Box(vec3(0,0,-300), vec3(210,100,10)),\n    Box(vec3(-200,00,0), vec3(10,100,300)),\n    Box(vec3(100,0,300), vec3(100,100,10)),  // Either side of door\n    Box(vec3(-150,0,300), vec3(100,100,10)),\n    Box(vec3(-0,70,300), vec3(100,30,10)), // Lintel\n    Box(vec3(200,-70,0), vec3(10,40,300)),   // Window wall\n    Box(vec3(190.,60,0), vec3(20,40,300)),\n    Box(vec3(200.,0,0), vec3(10,40,120)),\n    Box(vec3(0.,110,0), vec3(200,10,300)),      // Roof\n    Box(vec3(0.,-120,0), vec3(200,20,300)),     // Floor\n    Box(vec3(150.,-50,150), vec3(10,200,10)),   // Pillar.\n    Box(vec3(-150.,-50,150), vec3(10,200,10)),  // Pillar.\n    Box(vec3(150.,-50,-150), vec3(10,200,10)),  // Pillar.\n    Box(vec3(-150.,-50,-150), vec3(10,200,10))  // Pillar.\n\n);\n\n//-----------------------------------------------------------------------------------------------------------------\n// Hash without Sine 2 (WebGL 2)\n// https://www.shadertoy.com/view/XdGfRR\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\nvec3 hash31(uint q)\n{\n\tuvec3 n = q * UI3;\n\tn = (n.x ^ n.y ^ n.z) * UI3;\n\treturn vec3(n) * UIF;\n}\nvec2 hash23(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tuvec2 n = (q.x ^ q.y ^ q.z) * UI2;\n\n\treturn vec2(n) * UIF;\n}\nvec3 hash33(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n//-----------------------------------------------------------------------------------------------------------------\n// https://iquilezles.org/articles/intersectors\nvec4 boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec4(10000.0); // no intersection\n    vec3 norm = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec4( tN, norm);\n}\n\n\n//-----------------------------------------------------------------------------------------------------------------\nvec4 boxWorldIntersection( in vec3 ro, in vec3 rd, vec3 loc, vec3 boxSize) \n{\n    return boxIntersection(ro-loc, rd, boxSize);\n}\n//-----------------------------------------------------------------------------------------------------------------\nvec4 traceScene(vec3 ori, vec3 dir)\n{\n    vec4 a,b;\n\n    a.x = 10000.0;\n    for (int i = 0; i < boxes.length(); i++)\n    {\n        a = UNI(a, boxWorldIntersection(ori, dir, boxes[i].centre, boxes[i].size));\n    }\n    return a;\n}\n//\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// by Dave Hoskins. 2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define VIEW_PROJ_Z 1.25\nmat3 camMat;\nvec3 camPos;\nfloat time;\n//-----------------------------------------------------------------------------------------------------------------\nvec3 texCube(sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec3 x = texture(sam, p.yz).xyz;\n\tvec3 y = texture(sam, p.zx).xyz;\n\tvec3 z = texture(sam, p.xy).xyz;\n\n\treturn (x*abs(n.x) + y*abs(n.y) + z*abs(n.z));\n}\n\n//-----------------------------------------------------------------------------------------------------------------\nmat3 cameraMat( in vec3 ro, in vec3 ta, float roll )\n{\n\tvec3 cw = normalize(ta-ro);\n   \n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    mat3 m;\n    m = mat3( cu, cv, cw );\n    return m;\n}\n\n//-----------------------------------------------------------------------------------------------------------------\nvec2 getScreenspaceLocation(vec3 pos, mat3 cMat, vec3 cPos)\n{\n \n    mat3 inv = transpose(cMat);\n    vec3 cp = inv * (cPos - pos);\n    vec2 sun2d = VIEW_PROJ_Z * cp.xy / cp.z;\n    vec2 asp = vec2(iResolution.y/iResolution.x,1.0);\n    vec2 st = .5+.5*sun2d*asp;\n    return st;\n}\n//-----------------------------------------------------------------------------------------------------------------\n// The open areas are the only light source...\nvec3 getSky(vec3 ray)\n{\n\n    vec3 sunDir = normalize(vec3(30, 25., 20.));\n    \n    vec3 col1 =  texture(iChannel1, ray).xyz * 4.;\n\n    float sun = pow(max(dot(sunDir, ray), 0.0), 1000.0)*6000.0;\n    return col1+sun;\n}\n\n//-----------------------------------------------------------------------------------------------------------------\n#define SAMPLES 50\n\nvec3 getPixelView(vec3 pos, vec3 nor, vec2 uv)\n{\n    vec3 col = vec3(0);    \n\n    for (int i = min(0, iFrame); i < SAMPLES; i++)\n    {\n        // Random hemispherical rays around the surface normal\n\n        vec3 ray  = (hash33(float(i*133)+pos*5.+iTime*5.)-.5);\n        ray = ray * sign(dot(ray, nor));\n        ray = normalize(ray+nor*.1);\n\n        vec4 res = traceScene(pos+nor*.1, ray);\n\n        if (res.x >= 10000.)\n        {\n            col += getSky(ray); \n        }\n        else\n        {\n            vec3 p = pos + ray * res.x;\n            vec2 st = getScreenspaceLocation(p,camMat, camPos);\n            // Add previous results if we can see them!\n            if (st.x >= 0.0 && st.x < 1.0 && st.y >=0.0 && st.y < 1.0)\n            {\n                col += texture(iChannel0, st).xyz * max(dot(ray, nor),0.) ;\n                // each pixel is lit by Lambert's cosine law.\n            }\n        }\n    }\n    return (col / float(SAMPLES)) ;\n}\n\n//-----------------------------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 colour, in vec2 coord )\n{\n    time = iTime;\n    time = 6.5;\n    vec3 col = vec3(0);\n    vec2 uv = (-iResolution.xy + 2.0 * coord ) / iResolution.y;\n    camPos = vec3(-70, 0., sin(-time*.3)*230.0);\n    vec3 camTar = vec3(50, 10, 0);\n\n    camMat = cameraMat(camPos, camTar, 0.0);\n    vec3 ray = normalize( vec3(uv,  VIEW_PROJ_Z)) * camMat;\n   \n    vec4 res = traceScene(camPos, ray);\n    if (res.x >= 10000.)\n    {\n        col = getSky(ray);\n    }\n    else\n    {\n        vec3 pos = camPos + ray * res.x;\n        vec3 diff = texCube(iChannel3, pos*.004, res.yzw).xyz; // Get a diffuse texture\n        diff = diff*.5+.5;\n        \n        col = diff * getPixelView(pos, res.yzw, coord);\n    }\n    colour = vec4(col, 1.);\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 colour, in vec2 coord )\n{\n   vec4 ocol;\n   \n   \n   // Start with black...\n   if (iFrame == 0) \n   {\n       ocol = vec4(0);\n   }else\n   {\n       ocol = texelFetch(iChannel1, ivec2(coord), 0);\n   }\n\n   // Add each frame, including a frame count in w\n   vec4 col = texelFetch(iChannel0, ivec2(coord), 0);\n   // Col can get massive so always clamp it.\n   col = clamp(col, 0.0, 1.0);\n\n   \n   colour = ocol + col;\n   \n   \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}