{
    "Shader": {
        "info": {
            "date": "1538212276",
            "description": "a fast diagonal mirror is doable by\n ;u=mix(u,vec2(-u.y,u.x),step(abs(u.y),abs(u.x)))\n==\n;if(abs(u.y)<abs(u.x))u=vec2(-u.y,u.x)//cross mirror\ncan remove one of the 2 , or both, abs() to remove a mirror, for a T, L  or j shape\nan X or + shape is 2 abs()",
            "flags": 0,
            "hasliked": 0,
            "id": "MtVcWt",
            "likes": 0,
            "name": "fast diagonal mirror  TLjX+",
            "published": 3,
            "tags": [
                "uv",
                "mirror",
                "fold",
                "symmetry",
                "microchip",
                "diagonal"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 582
        },
        "renderpass": [
            {
                "code": "\n/*\nthe whole shape is a single sqrt(), because it is the same single circle\n, mirrored diagonally, stretched, and in a modular-interval\n\nmain feature of this shader is to mirror uv diagonally,twice, via:\n;u=mix(u,u.yx*vec2(-1,1),step(abs(u.y),abs(u.x)))\n//which should be identical to:\n;if(abs(u.y)<abs(u.x))u=u.yx*vec2(-1,1)//dual cross diagonal mirror u\nremoving one of the abs() removes one of the diagonal mirrors?\n\nthe older feature of this shader os to use mStretch() to stretch a circle into a capsule.\n\nthe older feature of this is pModR() == a modulo within an interval, which is inspired by [hg_sdf]\n*/\n\n//for a straight/horizontal central part search for \"mstretch\",the mstretch()function\n\n//repeated intervals\n#define repeats (floor(abs(m.y*8.))+2.)\n//period length m=iMouse,scaled to scrteenspace\n#define period m.x\n\n#define ViewZoom 5.\n\n#define vec1 float\n\nvec2 fra(vec2 u){u/=iResolution.xy;u-=.5;u.x*=iResolution.x/iResolution.y;return u*ViewZoom;}\n\n\n#define pi acos(-1.)\n#define aa (min(iResolution.x,iResolution.y)/ViewZoom)\nconst vec1 tau=6.2831853071795864769252867665590057683943387987502116419\n,eul=2.7182818284590452353602874713526624977572470936999595749;\n//exists as y=exp(1.)???\nconst vec2 phi=sqrt(5.)*.5+vec2(.5,-.5);\nconst vec4 vs=vec4(-1,0,1,phi.x);\n#define fr(a)fract(a)\n#define u5(a)((a)*.5+.5)\n#define u2(a)((a)*2.-1.)\n#define sat(a)clamp(a,0.,1.)\n#define c11(a,b)clamp(a/b,-1.,1.)*b\nvec1 sat2(vec1 a,vec2 m){a=.5*(sign(a)+m.x)*a+m.y;return (sign(2.-a)+1.)*(a-2.)*.5+1.;}//generalization of clamp(a,0.,1.);for m=vec2(1)\n#define dd(a)dot(a,a)\nvec2 perp(vec2 a){return a.yx*vs.xz;}\n//http://mathworld.wolfram.com/dotpProduct.html//http://wiki.secondlife.com/wiki/Geometric#Line_and_Line.2C_intersection_point\nvec1 dotp(vec2 a,vec2 b){return dot(perp(a),b);}\n//==determinant(mat2(a,b)),aka cross2(),for also being the crossproduct()of a mat2.\n\n//worksafe:\nvec1 stp(vec1 a){return u5(sign(a));}//explicit step(a,b),substitutions,for a multi-context namespace\nvec1 stp(vec1 a,vec1 b){return stp(a-b);}vec1 stp(vec2 a){return stp(a.x-a.y);}//substitute step(a,b)to a differential function.\nvec1 circleY(vec2 u){return u.y-sqrt(1.-(u.x*u.x));}//i keep forgetting this one\nconst vec1 tiny=1e-7;//smallest denormalNumber>0_16bit_float is pow(2,-24);make sure that:0.<(tiny*tiny/6.75)<tiny .\nconst vec1 NINF=65536.;//near infinity;should be 1/tiny\n#define if0(a)a=mix(a,tiny,step(abs(a),tiny))\n//if(abs(a)<tiny)a=tiny\nvec1 ifu0b(vec1 u,vec1 a){return a*(1.-sign(u)*sign(u));}//if(u==0.)return a,else return 0.;\nvec1 ifu0b(vec2 u){return ifu0b(u.x,u.y);}\n//https://iquilezles.org/articles/functions\n//aiB()and ai()return \"almost identity\",\"0-skipping identity\",they do return 0 for u==0//ai()is branchless,aiB()is branching?\n//,but this defeats most of their purpose! to make them return something else for u==0\n//,so you MUST add+=ifu0b(u.x,m.y)above for WorkSafe<->rather having a discontinuity near 0,than diving by/0\n//to enfoce no divisions by/0 by smoothly skipping over y=f(u)-0\n//[aifs] is optional constrain to general case;keeps sign of first drivative constant.\n#define aifs m.x=max(m.x,m.y*1.5);vec1 t=u/m.x\n#define aif (2.*(m.y*(t-1.5)+m.x)-u)*t*t+m.y\n//m.x=threshold.x(cubic [aif] only exists within x<abs(m.x));m.y=abs(minimum),never return anything smaller than abs(m.y)\nvec1 aiB(float u,vec2 m){aifs;if(u<m.x)return aif;return u;}\n//special case where m.y is minimal,and m.x becomes u.y for speed.\nvec1 aiB(vec2 u){u.y=max(u.y,tiny);if(u.x<u.y*1.5){float a=u.y;u*=u*u;return a*(u.x/u.y/6.75+1.);}return u.x;}\nvec1 aiB(vec1 u,vec1 a){return aiB(vec2(u,a));}\nvec1 ai(vec1 u,vec2 m){aifs;return u+.5*(aif-u)*(1.-sign(u-m.x));}\n//A special case where m.y is minimal,and m.x becomes u.y for speed.is undefined for a=0.its trivial case AND purpose of this function\nvec1 ai(vec1 u,vec1 a){a=max(a,tiny);vec1 b=u/a;return u+(.5*(u*(b*b/6.75-1.)+a))*(1.-sign(u-a*1.5));}//...therefore a=max(a,tiny)\nvec1 ai(vec2 u){return ai(u.x,u.y);}\nvec1 ai(vec1 u){vec1 b=u/tiny;return u+(.5*(u*(b*b/6.75-1.)+tiny))*(1.-sign(u-tiny*1.5));}\nfloat almostIdentityE(float u,vec2 m){return ai(u,vec2(.1,1.)/NINF);}\n\n//unbranch\nvec1 suv(vec2 a){return a.x+a.y;}vec1 suv(vec3 a){return a.x+a.y+a.z;}vec1 suv(vec4 a){return a.x+a.y+a.z+a.w;}//dot(a,vec4(1))can be faster.\nvec1 sub(vec2 a){return a.x-a.y;}vec1 sub(vec3 a){return a.x-suv(a.yz);}vec1 sub(vec4 a){return a.x-suv(a.yzw);}\nvec2 sub2(vec4 a){return a.xy-a.zw;}//substract in modulo 2\nvec1 mul(vec2 a){return a.x*a.y;}vec1 mul(vec3 a){return a.x*a.y*a.z;}vec1 mul(vec4 a){return a.x*a.y*a.z*a.w;}\nvec1 div(vec2 a){return a.x/a.y;}vec1 div(vec3 a){return a.x/mul(a.yz);}vec1 div(vec4 a){return a.x/mul(a.yzw);}\nvec1 mav(vec2 a){return max(a.x,a.y);}vec1 mav(vec3 a){return max(a.x,mav(a.yz));}vec1 mav(vec4 a){return max(mav(a.xy),mav(a.zw));}\n#define miv(a)-mav(-a)\n#define minx(a,b)mix(b,a,step(a.x,b.x))\n//return vec with smaller .x component\n#define equals(a,b,c)   mix(b,a,step(c,0.)+step(0.,c)-1.)\n//(c==0)?a:b\n#define greater(a,b,c)  mix(a,b,step(c,0.))\n//(c>0)?a:b\n#define less(a,b,c)     mix(a,b,step(0.,c))\n//(c<0)?a:b\n//--mirror symmetry mirror==swap outputs--\n#define unless(a,b,c)   mix(b,a,step(0.,c))\n//(a>=0)?a:b unless   =not less==equal OR greater \n#define ungreater(a,b,c)mix(b,a,step(c,0.))\n//(c<=0)?a:b ungreater=not greater==equal OR less \n#define unequal(a,b,c)  mix(a,b,step(c,0.)+step(0.,c)-1.)\n//(c!=0)?a:b\n\n//polar\n#define r2(a)mat2(cs(a).xyyx*vs.zxzz)\n#define rs(r)mat2(sin(r+vec4(1,0,0,-1)*pi))\n//mirror p at half rotated axis==cheap SINGLE 2d rotation.\n#define cs(a)vec2(cos(a),sin(a))\n#define arg(a)atan(a.y,a.x)\n//atan2()is aka \"arg,phase\"//length()is aka \"rad,amplitude\"\n#define c2p(a)vec2(length(a),arg(a))\n//carthesian to polar\n#define p2c(z)cs(z.x)*z.y\n//polar to cartesian\n#define real(z)z.x*cos(z.y)\n//real and imaginary parts for polar z\n#define imag(z)z.x*sin(z.y)\n\nstruct v11{vec1 a;vec1 b;};\nv11 g11(vec2 a){return v11(a.x,a.y);}\nstruct v22{v11 a;v11 b;};\nv22 g22(vec2 a,vec2 b){return v22(g11(a),g11(b));}\nv22 g22(vec4 a){return v22(g11(a.xy),g11(a.zw));}\n\n#define segment(p,a,b){p-=a;b-=a;return length(p-b*sat(dot(p,b)/dd(b)));}\n//return distance of [u] from segment,from [a] to [b]\n//#define mStretch(c,m)v=mix(v-m,mix(0.,v,step(v,0.)),step(v,m));\n#define mStretch(u,m).5*(sign(u)*m-u)*((sign(abs(u)-m))+1.)\n//stretch   ;centric,most commonly used,therefore atomic\n#define mStretchM(u,m)mStretch((u*2.+m),m)*.5\n//stretch nimus;positive values do not change\n//vec2  mStretchM(vec2  u,vec2  m){m*=.5;u=u+m;return  mStretch(u,m);}\n#define mStretchP(u,m)mStretch((u*2.-m),m)*.5\n//stretch plus ;negative values do not change\n//based on #define analstretching(u,m)mix(u-m,mix(vec2(0.),u,step(u,vec2(0.))),step(u,m))\n \n//interpolating in a straight box is a simple mix(a,b,t),but skewed corners split the interpolation.\n#define lin2(t,a,b,c,d)mix(mix(a,b,t.x),mix(c,d,t.x),t.y)\n//bilinear interpolation,general case with corners [a,b,c,d]\n#define bez2(t,a,b,c)lin2(t.xx,a,b,b,c)\n//return time[t] value of quadratic bezier of 3 CVs[a,b,c],happens to be a special-fold-case of bilin generalization.\n#define lin3(t,a,b,c,d,e,f,g,h)mix(lin2(t.xy,a,b,c,d),lin2(t.xy,e,f,g,h),t.z)\n//trilinear interpolation (general case,usually a special case with more symmetry is used)\n\n//simple ptterns:\n#define grid(u)mav(abs(u2(fr(u))))\n#define ss2t(a)a=abs(u2(a))//triangle wave;\n//inspired by https://www.shadertoy.com/view/4tG3Wh\n#define hfrac vec2 h){h=fract(h)\n#define gthv greaterThan(h,vec2\n#define floatbool2);return float(b.x==b.y);}\nfloat checkerBool(hfrac;return float(h.x>.5==h.y>.5);}\n//checkerBool2()might be faster than checkerBool()//xy are independent\nfloat checkerBool2(hfrac;bvec2 b=gthv(.5)floatbool2\n//checkerBoolT oscillates xy comparators over time.\nfloat checkerBoolT(hfrac;bvec2 b=gthv(cos(iTime)*.45+.5)floatbool2\n//how to transform this to a non-boolean solution with smooth borders?//multiply with a smoothstep?\n//no dummy,you do your step to smoothstep subsititutions!\n\n//fast good monochrome distance field visualization.\n//blue is grid,red and green are distance fields\nvec3 rg(vec3 c,vec2 u){vec1 fsaa=1./min(iResolution.x,iResolution.y);\n return vec3(c.rg=mix(fract(c.rg*4.),smoothstep(fsaa,-fsaa,c.rg),.5+(atan(c.rg))/acos(-1.)),grid(u));}//.b=grid \nvec4 rg(vec4 c,vec2 u){vec1 fsaa=1./min(iResolution.x,iResolution.y);\n return vec4(c.rga=mix(fract(c.rga*4.),smoothstep(fsaa,-fsaa,c.rga),.5+(atan(c.rga))/acos(-1.)),grid(u)).rgab;}//.b=grid ,.a=yellow\nvec2 gLLxX(vec2 a,vec2 b,vec2 c,vec2 d\n           //return intersection from line(a b)and line(c d).\n){d-=c;b-=a,c-=a;float e=dotp(d,b);if0(e)\n ;return a+b*dotp(d,c)/e;}\n                   //second life wiki geometry\n\n#define f32 (3.-2.*f)*f*f;\nvec1 ss(vec2 a,vec1 b){return smoothstep(a.x,a.y,b);}\nvec2 ss(vec2 a,vec2 b){return smoothstep(a.x,a.y,b);}\nvec3 ss(vec2 a,vec3 b){return smoothstep(a.x,a.y,b);}\n\n\nvec2 ff(vec1 a){return vec2(fract(a),floor(a));}\nvec4 ff(vec2 a){return vec4(fract(a),floor(a));}\n\n//hg_sdf\n//for pMix [s] sets period length\nv11 pMod(vec1 u,vec1 s){return g11(ff(u/s+.5)*vec2(s,1));}\n                   //.a            is in-tile fract().b            is tileID floor()\nv22 pMod(vec2 u,vec2 s){return g22((ff(u/s+.5)*vec4(s,1,1)).xzyw);}\n                   //.a.a&&.b.a are in-tile fract().a.b&&.b.a are tileID floor()\nv11 pModr(vec1 p,vec1 s,vec1 n\n          //n==number of repeats (discontinuities),where the smallest discontinuity is at [s]\n){v11 c=pMod(p,s);p=p+.5*s;return v11(mix(mix(c.a,p-s*n,step(n,c.b)),p,step(c.b,0.)),clamp(c.b,0.,n));}\n//for u<0 and u>s*n the space condinues linearily,without repetition,this is different from hg_sdf.\n//it also does not set a start,you must just shift u instead\nv11 pModR(vec1 p,vec1 s,vec1 n){v11 a=pModr(p,s,n);a.a-=s*.5;return a;}\n                   //offset the output for more utility.\n//minor flaw;for s==0.special linear case,it still splits a line in 2 segments.\n\nvec3 whitecross(vec2 u){u=abs(u);u.x=miv(u);return vec3(ss(vec2(1,-1)*3./aa,u.x));}\n\n//good rainbow-gradients ALWAYS center green|white and border purple|black\n#define mad(a,b,c)((a)*(b)+(c))\n#define ab012(a,b)mad(vec3(0,1,2),b,a)\nvec3 rainbow(float a,float b){return u5(cos(2.*pi*ab012(a,b)));}\n                   //sine rainbow with offsets\nvec3 rainbow2(float a,float b){return abs(u2(fract(ab012(a,b))));}\n                   //triangle rainbow with offsets\n//m.x sets saturation==transition by shifting blue|red rang[-.1,.5]\n//m.y sets \"flimmer\",range [-.159 ...159]\n//p is a flimmer-phase that modulates the shorter subwave of red (green)blue;try;p=1.+vec3(-1,0,1)*cos(iTime*.001)\nvec3 rainbow3(vec2 u,vec2 m,vec3 p\n){vec3 c=vec3(1)\n    //;m=vec2(0)//simple case\n ;m.x=c11(-m.x,.5)\n     //good optional bounds,sign negation for utility.\n ;m.y=c11(m.y,.159)\n     //decent optional bounds to stay in visible range\n ;m.y=m.y*pi+.5\n ;m.y=u5(m.y)\n ;c=rainbow(u.x-m.x*.5,fract(m.x*.6))\n     //the .mx/2 ensures that white/green stays centred and purple stys bordered;\n ;c=mix(c*m.y,c,cos(u.x*p*iResolution.x/4.))\n ;vec2 v=u\n ;u.x*=m.y\n ;u.x*=iResolution.y/16.\n ;float g=cos(iTime)\n     //;g=.1//a 3rd domain as time for demoing,whould actually be constant\n//;c=gradVis(c,u,v)\n ;return c;}\n\n#define stretch2(a,b)sign(a)*max(abs(a)-b,0.)\n#define stretch(a,b)stretch2(a-b*.5,b*.5)//stretch space in positive direction so that length(u)returns a capsule\n\n#define roundCore(a)(length(max(a,0.))+mav(min(a,0.)))//rounding deform\n#define box(u,s)roundCore(abs(u)-s)//rounded box size s\n\nfloat chip(vec2 u){\n ;vec2 v=u;\n ;vec2 b=abs(u)-1.\n     //box size 1.\n ;b=vec2(dd(max(b,0.)),b.y=mav(min(b,0.)))\n     //rounded box transform,but not squarerooted\n ;float d=(b.x+b.y*b.y)\n     //roughly equal to squared distance to rounded box?\n ;u=mix(u,vec2(-u.y,u.x),step(abs(u.y),abs(u.x)))\n     //;if(abs(u.y)<abs(u.x))u=vec2(-u.y,u.x)//cross mirror\n//above code is squared distance to rounded box,below code mirrors space so that a dot-distance becomes the distance to 3*4 legs.\n ;float r=3.\n     //range[0..4] work fine. other ranges would need more scaling.\n ;r=floor(r)\n ;v11 a=pModR(u.x+.25*r,.5,r)//;v11 a=pModR(u.x,period,repeats)\n ;u.x=a.a\n ;//u.x=abs(u.x)//saw to pyramid, effect is neglible in most symmetries.\n ;u.y=abs(u.y)\n     //optionally remove liwer and left side legs\n ;u.y-=1.\n     //offset.y of chip legs from vec2(0)\n ;float leglength=.5+cos(iTime)*.2\n ;u.y=stretch(u.y,leglength)\n ;d=sqrt(min(d,dd(u)))\n     //central large dot\n ;return d;}\n\nvoid mainImage(out vec4 O,in vec2 u){\n ;u=fra(u)\n ;vec2 v=u;\n ;vec2 m=fra(iMouse.xy)\n ;vec2 n=fra(iMouse.zw)\n//;m-=.5\n ;m*=.2\n ;m=abs(m)\n ;float d=chip(u)\n ;d=ss(vec2(1,-1)*2./aa,abs(d-m.x)-m.y)\n ;O=vec4(d,d,d,1)\n ;}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}