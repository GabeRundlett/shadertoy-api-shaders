{
    "Shader": {
        "info": {
            "date": "1661510451",
            "description": "use SDF to create soft shadows",
            "flags": 0,
            "hasliked": 0,
            "id": "7tVcWW",
            "likes": 0,
            "name": "Soft Shadow (SDF)",
            "published": 3,
            "tags": [
                "sdf"
            ],
            "usePreview": 0,
            "username": "wcvanvan",
            "viewed": 488
        },
        "renderpass": [
            {
                "code": "precision highp float;\n\n\n#define RAYMARCHING_MAX_STEPS 100\n\n/*\nReturn the min distance between p and the world\n*/\nfloat GetDist(vec3 p){\n    float dist_floor=p.y;\n    vec3 sphere=vec3(0,1,3);\n    float sphere_radius=0.5;\n    float dist_sphere=length(sphere-p)-sphere_radius;\n    return(dist_sphere<dist_floor)?dist_sphere:dist_floor;\n}\n\n/*\nReturn the normal vector at point p\n*/\nvec3 GetNormal(vec3 p){\n    float small_step_value=.01;\n    vec2 small_step=vec2(small_step_value,0.);\n    float dist=GetDist(p);\n    float gradient_x=(GetDist(p+small_step.xyy)-dist);\n    float gradient_y=(GetDist(p+small_step.yxy)-dist);\n    float gradient_z=(GetDist(p+small_step.yyx)-dist);\n    return normalize(vec3(gradient_x,gradient_y,gradient_z));\n}\n\nfloat Shadow(vec3 origin,vec3 direction,float max_dist){\n    float min_dist=.01;\n    float shadow=1.;\n    float k=8.;\n    float marching_distance=0.;\n    for(int i=0;i<RAYMARCHING_MAX_STEPS;i++){\n        float dist=GetDist(origin+marching_distance*direction);\n        shadow=min(shadow,k*dist/marching_distance);\n        marching_distance+=dist;\n        if(marching_distance>max_dist){\n            break;\n        }\n    }\n    return 0.25*(1.0+shadow)*(1.0+shadow)*(2.0-shadow);\n}\n\nvec3 Shading(vec3 p){\n    vec3 light_pos=vec3(5.*sin(iTime),5.,5.*cos(iTime));\n    vec3 light_direction=normalize(light_pos-p);\n    \n    // diffuse\n    vec3 normal=GetNormal(p);\n    float shading_intensity=dot(normal,light_direction);\n    shading_intensity=clamp(shading_intensity,0.,1.);\n    \n    // shadow\n    float max_dist=length(light_pos-p);\n    float shadow=Shadow(p,light_direction,max_dist);\n    \n    return shadow*shading_intensity*vec3(1,1,1);\n}\n\nvec3 RayMarching(vec3 origin,vec3 direction){\n    float max_dist=100.;\n    float min_dist=.01;\n    float marching_distance=0.;\n    \n    vec3 current_pos=origin;\n    \n    for(int i=0;i<RAYMARCHING_MAX_STEPS;i++){\n        float dist=GetDist(current_pos);\n        if(dist<min_dist){\n            break;\n        }\n        current_pos+=direction*dist;\n        marching_distance+=dist;\n        if(marching_distance>max_dist){\n            break;\n        }\n    }\n    return Shading(current_pos);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 camera_pos=vec3(0,1,0);\n    vec3 ray_direction=normalize(vec3(uv.x,uv.y,1));\n    vec3 color=RayMarching(camera_pos,ray_direction);\n    fragColor=vec4(color,1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}