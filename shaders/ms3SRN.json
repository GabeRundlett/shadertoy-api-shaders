{
    "Shader": {
        "info": {
            "date": "1679446814",
            "description": "DemoFest Tokyo 18",
            "flags": 0,
            "hasliked": 0,
            "id": "ms3SRN",
            "likes": 1,
            "name": "Cake Sako",
            "published": 3,
            "tags": [
                "glsldemo"
            ],
            "usePreview": 1,
            "username": "ford442",
            "viewed": 180
        },
        "renderpass": [
            {
                "code": "\nconst float epsilon = 0.001;\nconst float PI = 3.14159265;\nconst int isMove = 1;\n\n\n// util func\n//-------------------------------------------------------------------------------------\nfloat deg2rad(float angle){\n    return angle * PI / 180.0;\n}\n\n//x 0-1\nfloat saturate(float x){\n    return clamp(x,0.0,1.0);\n}\n\nvec3 LinearToGamma( in vec3 value, in float gammaFactor ) {\n    return pow( value, vec3(1.0 / gammaFactor) );\n}\n\nvec3 brightnessContrast(vec3 value, float brightness, float contrast)\n{\n    return (value - 0.5) * contrast + 0.5 + brightness;\n}\n\n//simplex noise\n//-------------------------------------------------------------------------------------\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n  \n//pbr\n//-------------------------------------------------------------------------------------\n\nstruct PBRMaterial{\n    vec3 albedo;\n    vec3 metallic;\n    float roughness;\n    vec3 emission;\n};\n\nstruct GeometricContext {\n  vec3 position;\n  vec3 normal;\n  vec3 viewDir;\n};\n\nstruct IncidentLight {\n  vec3 direction;\n  vec3 color;\n  bool visible;\n};\n\nstruct DirectionalLight {\n  vec3 direction;\n  vec3 color;\n};\n\nstruct PointLight {\n  vec3 position;\n  vec3 color;\n  float visible_distance;\n  float decay;\n};\n\nstruct ReflectedLight {\n  vec3 directDiffuse;\n  vec3 directSpecular;\n  vec3 indirectDiffuse;\n  vec3 indirectSpecular;\n};\n\n//test lighth visible\nbool testLightInRange(const in float lightDistance, const in float cutoffDistance) {\n  return any(bvec2(cutoffDistance == 0.0, lightDistance < cutoffDistance));\n}\n\n//light decay by distanc\nfloat punctualLightIntensityToIrradianceFactor(const in float lightDistance, const in float cutoffDistance, const in float decayExponent) {\n  if (decayExponent > 0.0) {\n    return pow(saturate(-lightDistance / cutoffDistance + 1.0), decayExponent);\n  }\n\n  return 1.0;\n}\n\n//directional light irradiance\nvoid getDirectionalDirectLightIrradiance(const in DirectionalLight directionalLight, out IncidentLight directLight) {\n  directLight.color = directionalLight.color;\n  directLight.direction = directionalLight.direction;\n  directLight.visible = true;\n}\n\n//point light irradiance\nvoid getPointDirectLightIrradiance(const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight directLight) {\n  vec3 L = pointLight.position - geometryPosition;\n  directLight.direction = normalize(L);\n\n  float lightDistance = length(L);\n  if (testLightInRange(lightDistance, pointLight.visible_distance)) {\n    directLight.color = pointLight.color;\n    directLight.color *= punctualLightIntensityToIrradianceFactor(lightDistance, pointLight.visible_distance, pointLight.decay);\n    directLight.visible = true;\n  } else {\n    directLight.color = vec3(0.0);\n    directLight.visible = false;\n  }\n}\n\n//material from colors\nvec3 diffuseColor(vec3 albedo, vec3 metallic){\n    return mix(albedo, vec3(0.0), metallic);\n}\n\nvec3 specularColor(vec3 albedo, vec3 metallic){\n    return mix(vec3(0.04), albedo, metallic);\n}\n\n// Normalized Lambert\nvec3 DiffuseBRDF(vec3 diffuseColor) {\n    return diffuseColor / PI;\n}\n\n\n\nvec3 F_Schlick(vec3 specularColor, vec3 H, vec3 V) {\n    return (specularColor + (1.0 - specularColor) * pow(1.0 - saturate(dot(V,H)), 5.0));\n}\n\nfloat D_GGX(float a, float dotNH) {\n    float a2 = a*a;\n    float dotNH2 = dotNH*dotNH;\n    float d = dotNH2 * (a2 - 1.0) + 1.0;\n    return a2 / (PI * d * d);\n}\n\nfloat G_Smith_Schlick_GGX(float a, float dotNV, float dotNL) {\n    float k = a*a*0.5 + epsilon;\n    float gl = dotNL / (dotNL * (1.0 - k) + k);\n    float gv = dotNV / (dotNV * (1.0 - k) + k);\n    return gl*gv;\n}\n\n// Cook-Torrance\nvec3 SpecularBRDF(const in IncidentLight directLight, const in GeometricContext geometry, vec3 specularColor, float roughnessFactor) {\n\n    vec3 N = geometry.normal;\n    vec3 V = geometry.viewDir;\n    vec3 L = directLight.direction;\n\n    float dotNL = saturate(dot(N,L));\n    float dotNV = saturate(dot(N,V));\n    vec3 H = normalize(L+V);\n    float dotNH = saturate(dot(N,H));\n    float dotVH = saturate(dot(V,H));\n    float dotLV = saturate(dot(L,V));\n    float a = roughnessFactor * roughnessFactor;\n    \n    float D = D_GGX(a, dotNH);\n    float G = G_Smith_Schlick_GGX(a, dotNV, dotNL);\n    vec3 F = F_Schlick(specularColor, V, H);\n\n    return (F*(G*D))/(4.0*dotNL*dotNV+epsilon);\n}\n\n// RenderEquations(RE)\nvoid RE_Direct(const in IncidentLight directLight, const in GeometricContext geometry, const in PBRMaterial material, inout ReflectedLight reflectedLight) {\n\n    float dotNL = saturate(dot(geometry.normal, directLight.direction));\n    vec3 irradiance = dotNL * directLight.color;\n\n    // punctual light\n    irradiance *= PI;\n  \n    vec3 diffuse = diffuseColor(material.albedo, material.metallic);\n    vec3 specular = specularColor(material.albedo, material.metallic);\n\n    reflectedLight.directDiffuse += irradiance * DiffuseBRDF(diffuse);\n//    reflectedLight.directSpecular += specular;\n    reflectedLight.directSpecular += irradiance * SpecularBRDF(directLight, geometry, specular, material.roughness);\n}\n\n//---------------------------\n\nconst int rayLoopCount = 256;\nconst int aoLoopCount = 8;\n\n\n\n\nfloat app_iTime;\n\n\nint materialId = 0;\n\n//transform func\n//-------------------------------------------------------------------------------------\nmat4 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(1, 0, 0, 0),\n        vec4(0, c, -s, 0),\n        vec4(0, s, c, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, 0, s, 0),\n        vec4(0, 1, 0, 0),\n        vec4(-s, 0, c, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\nmat4 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, -s, 0, 0),\n        vec4(s, c, 0, 0),\n        vec4(0, 0, 1, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nvec3 rotate(vec3 pos, vec3 angle){\n    vec3 theta = angle / 180.0 * PI;\n    mat4 m = rotateZ(theta.z)*rotateY(theta.y)*rotateX(theta.x);\n    return (m * vec4(pos, 1.0)).xyz;\n}\n\nvec3 translate(vec3 pos, vec3 to){\n    to.y = -1.0*to.y;\n    return pos + to;\n}\n\nvec3 scale(vec3 pos, vec3 scale){\n    return pos/scale;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n// dist func\n//-------------------------------------------------------------------------------------\n\nfloat dBox(vec3 p, vec3 size){\n    vec3 q = abs(p);\n    return length(max(q - size, 0.0));\n}\n\n\nfloat dSphere(vec3 pos, float size){\n    return length(pos) - size; \n}\n\nvec3 onRep(vec3 p, float interval){\n    return mod(p, interval) - interval * 0.5;\n}\n\nfloat distPlane(in vec3 p, vec4 n){\n    return dot(p, n.xyz) * n.w;\n}\n\n\nfloat dCylinder(vec3 p, vec3 c){\n    p += c;\n    return length(p.xz-c.xy)-c.z;\n}\n\n\nfloat dCappedCylinder( vec3 p, vec2 h ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat dRoundCone( in vec3 p, in float r1, float r2, float h ){\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\n\n// scene\n//-------------------------------------------------------------------------------------\n\nconst int LIGHT_MAX = 4;\nDirectionalLight directionalLights[LIGHT_MAX];\nPointLight pointLights[LIGHT_MAX];\nint numPointLights;\nint numDirectionalLights;\n\nstruct Camera{\n    vec3 position;\n    vec3 target;\n    float fov;\n    float roll;\n    float farClip;\n};\n\nuniform Camera debugCam;\n\nCamera cam;\n\nmat3 setCamLookAt(in Camera c){\n    vec3  cw = normalize(c.target-c.position);\n    vec3  cp = vec3(sin(deg2rad(c.roll)), cos(deg2rad(c.roll)), 0.0);\n    vec3  cu = normalize( cross(cw,cp) );\n    vec3  cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nmat2 rotate2d(float a)\n{\n    return mat2(cos(a), sin(a), -sin(a), cos(a));   \n}\n\nvec2 fold(in vec2 p, in float s)\n{\n    float a = PI / s - atan(p.x, p.y);\n    float n = PI*2.0 / s;\n    a = floor(a / n) * n;\n    p *= rotate2d(a);\n    return p;    \n}\n\n\nvec3 getTunnelMoveDirection(float t){\n    vec3 left = vec3(1.0, 0.0, 0.0);\n    vec3 right = vec3(-1.0, 0.0, 0.0);\n    vec3 front = vec3(0.0, 0.0, 1.0);\n   \n    if(t >= 0. && t<10.){\n        return front;\n    }else if(t>=10. && t<20.){\n        return left;\n    }else if(t>=20. && t<30.){\n        return front;\n    }else if(t>=30. && t<40.){\n        return right;\n    }else{\n        return front;\n    }\n}\n\nvec3 getBirdPos(float t){\n    vec3 left = vec3(-10.0, 0.0, 0.0);\n    vec3 right = vec3(5.0, 0.0, -5.0);\n    vec3 back = vec3(0.0, 0.0, 10.0);\n    vec3 front = vec3(0.0, 0.0, -10.0);\n    \n    if(t >= 0. && t<10.){\n        return back;\n    }else if(t>=10. && t<20.){\n        return left;\n    }else if(t>=20. && t<30.){\n        return front;\n    }else if(t>=30. && t<40.){\n        return right;\n    }else{\n        return back;\n    }\n}\n\n\n\nfloat sceneDist(vec3 pos){\n    float result;\n  \n    float tunnelSize = 10.0;\n    float tunnelRep = 60.0;\n    vec3 tunnelPos = pos;\n    tunnelPos -= tunnelRep/2.0;\n    \n    if(isMove == 1){\n        float speed = tunnelSize*3.0;\n\n        float t = app_iTime;\n        tunnelPos += getTunnelMoveDirection(t)*t*speed;\n    }\n    \n    tunnelPos = onRep(tunnelPos, tunnelRep);\n    \n    float tunnelR = tunnelSize*0.8;\n    float boxCenter = dBox(tunnelPos, vec3(tunnelSize));\n    \n    vec3 cylinderPos = tunnelPos;\n    cylinderPos = cylinderPos + 0.05*(snoise(cylinderPos*2.0)+1.0/2.0);\n    cylinderPos = cylinderPos + 1.65*(snoise(cylinderPos/10.0)+1.0/2.0);\n    float cylinderZ = dCylinder(rotate(cylinderPos, vec3(90.0, 0.0, 0.0)), vec3(tunnelR));\n    float cylinderX = dCylinder(rotate(cylinderPos, vec3(90.0, 0.0, 90.0)), vec3(tunnelR));\n    \n    boxCenter = max(-min(cylinderX, cylinderZ), boxCenter);\n    \n    vec3 boxZPos = rotate(translate(tunnelPos, vec3(0.0, 0.0, 0.0)), vec3(0.0, 0.0, 90.0));\n    boxZPos.yz = fold(boxZPos.yz, 4.0);\n    float boxZ = dBox(translate(boxZPos, vec3(0.0, 0.0, -tunnelSize*2.0)), vec3(tunnelSize));\n    boxZ = max(-min(cylinderX, cylinderZ), boxZ);\n        \n    vec3 tubePos = tunnelPos;\n    \n    tubePos.xy = fold(tubePos.xy, 5.0);\n    float cylinderTube = dCylinder(rotate(translate(tubePos, vec3(0., tunnelR*0.95, 0.)), vec3(90, 0, 0)), vec3(tunnelR*0.03)); \n    float cylinderTubeSub = dCappedCylinder(rotate(translate(tubePos, vec3(0., tunnelR*0.95, -tunnelSize*1.4)), vec3(90, 0, 0)), vec2(tunnelR*0.045, 0.5));\n    cylinderTubeSub = min(cylinderTubeSub, dCappedCylinder(rotate(translate(tubePos, vec3(0., tunnelR*0.95, tunnelSize*1.4)), vec3(90, 0, 0)), vec2(tunnelR*0.045, 0.5)));\n    cylinderTube = min(cylinderTube, cylinderTubeSub);\n    vec3 decoPos = tunnelPos;\n    decoPos.x = onRep(decoPos,3.0).x;\n\n    float decoBox = dBox(rotate(translate(decoPos, vec3(0., -tunnelR+0.15, 0.)), vec3(0, 0, 0)), vec3(tunnelSize/10., 0.15, tunnelSize*0.44)); \n    decoBox = max(-cylinderZ, decoBox);\n    \n    vec3 partitionPos = tunnelPos;\n    partitionPos.xy = fold(partitionPos.xy, 5.0);\n    float partitions = dBox(rotate(translate(partitionPos, vec3(0., tunnelR*0.9, -tunnelSize*2.0)), vec3(90, 0, 0)), vec3(tunnelSize, 0.3, tunnelR*0.15)); \n    \n    float tunnel = min(boxZ, boxCenter);\n    float unit = tunnel;\n    unit = min(unit, cylinderTube);\n    unit = min(unit, decoBox);\n    unit = min(unit, partitions);\n\n    \n    float birdBodyAngle = cos(PI*app_iTime/4.0)*20.0;\n    float birdPosX = snoise(vec3(app_iTime/10.0, 0.3, 0.4)) * 1.0;\n    float birdPosY = sin(PI*app_iTime/6.0) / 3.0;\n    float turniTime = 2.0;\n    vec3 birdCenter =  mix(getBirdPos(app_iTime), getBirdPos(app_iTime+turniTime), fract(app_iTime/turniTime));\n    vec3 birdDir = vec3(0.0, normalize(birdCenter).x*-90.0, 0.0) + vec3(0.0, 180.0, birdBodyAngle);\n    vec3 birdPos = scale(rotate(translate(pos, birdCenter+vec3(birdPosX, birdPosY, 0.0)), birdDir), vec3(0.7));\n    \n   \n    float bird = 0.0;\n    \n    \n    float bird1 = dSphere(scale(translate(birdPos, vec3(0.0, 0.0, 0.0)), vec3(1.0, 0.7, 2.0)), 0.5);\n    float bird2 = dSphere(scale(rotate(translate(birdPos, vec3(0.0, 0.0, 0.5)), vec3(30.0, 0.0, 0.0)), vec3(1.0, 0.8, 2.0)), 0.5);\n    float birdHead = dSphere(scale(rotate(translate(birdPos, vec3(0.0, 0.6, 1.5)), vec3(00.0, 0.0, 0.0)), vec3(1.0, 1.0, 1.5)), 0.3);\n    float birdTail = dRoundCone(rotate(translate(birdPos, vec3(0.0, 0.0, -2.7)), vec3(-90, 0.0, 0.0)), 0.04, 0.2, 1.9);\n    float birdBeak = dRoundCone(rotate(translate(birdPos, vec3(0.0, 0.55, 2.7)), vec3(90, 0.0, 0.0)), 0.01, 0.05, 0.8);\n    vec3 birdEyePos = rotate(translate(birdPos, vec3(0.0, 0.73, 1.8)), vec3(00.0, 0.0, 90.0));\n    birdEyePos.xy = fold(birdEyePos.xy, 2.0);\n    float birdEye =  dSphere((translate(birdEyePos, vec3(0.0, 0.16, 0.0))), 0.06);\n    \n    vec3 birdWingPos = scale(rotate(translate(birdPos, vec3(0.0, 0.25, 0.4)), vec3(0.0, 0.0, 90.0)), vec3(0.5, 1.0, 3.0));\n    float wingAngle = birdWingPos.y > 0.0 ? -1.0 : 1.0;\n    \n    int isWing = sin(app_iTime*PI/2.0) > PI/5.0 ? 1 : 0;\n    wingAngle = isWing == 1 ? (-20.0 + 40.0 * sin(5.*app_iTime*PI))*wingAngle : (-20.0 + 10.0 * sin(app_iTime*PI))*wingAngle;\n    birdWingPos.xy = fold(birdWingPos.xy, 2.0);\n    float birdWing = dRoundCone(rotate(translate(birdWingPos, vec3(0.0, 0.4, 0.0)), vec3(13.0, 0.0, wingAngle)), 0.1, 0.3, 1.7);\n    float birdBody = opSmoothUnion(bird1, bird2, 0.4);\n    bird = opSmoothUnion(birdBody, birdHead, 0.4);\n    bird = opSmoothUnion(bird, birdTail, 0.4);\n    bird = opSmoothUnion(bird, birdBeak, 0.1);\n    bird = opSmoothUnion(bird, birdEye, 0.03);\n    bird = min(bird, birdWing);\n    \n    \n    result = min(unit, bird);\n    \n    \n    if(result >= tunnel)\n        materialId = 1;\n    if(result >= decoBox)\n        materialId = 2;\n    if(result >= cylinderTube)\n        materialId = 3;\n    if(result >= partitions)\n        materialId = 4;\n    if(result >= birdBody-epsilon || result >= birdTail-epsilon)\n        materialId = 5;\n    if(result >= birdWing || result >= birdHead)\n        materialId = 6;\n    if(result >= decoBox)\n        materialId = 7;\n\n\n    return result;\n}\n\nvec3 getNormal(vec3 pos)\n{\n    return normalize(vec3(\n        sceneDist(pos + vec3(epsilon, 0., 0.)) - sceneDist(pos - vec3(epsilon, 0., 0.)),\n        sceneDist(pos + vec3(0., epsilon, 0.)) - sceneDist(pos - vec3(0., epsilon, 0.)),\n        sceneDist(pos + vec3(0., 0., epsilon)) - sceneDist(pos - vec3(0., 0., epsilon))\n    ));\n}\n\n\nfloat genAo(vec3 ro, vec3 rd){\n    float k = 1.0;\n    float occ = 0.0;\n    for(int i=0; i<aoLoopCount; i++){\n        float len = 0.15 + float(i) * 0.15;\n        float dist = sceneDist(rd * len + ro);\n        occ += (len - dist) * k;\n        k *= 0.5;\n    }\n    return saturate(1.0-occ);\n}\n\n\n\n\nvec3 doBackground(){\n    return vec3(0.1);\n}\n\nPBRMaterial doPBRMaterial(int matId, vec3 pos){\n    PBRMaterial mat;\n    mat.albedo = vec3(1.0);\n    //tunnel\n    mat.emission = vec3(1.0);\n    if(matId == 1){\n        mat.albedo = vec3(1.0, 1.0, 1.0);\n        mat.metallic = vec3(1.0);\n        mat.roughness = 0.6;\n        \n    }else if(matId == 2){\n        mat.albedo = vec3(1.0, 1.0, 1.0);\n    }else if(matId == 3){\n        mat.albedo = vec3(1.0, 1.0, 0.25);\n        mat.metallic = vec3(0.0);\n        mat.roughness = 0.1;\n        mat.emission = vec3(2.0);\n    }else if(matId == 4){\n        mat.albedo = vec3(0.7, 0.7, 0.65);\n        mat.metallic = vec3(0.0);\n        mat.roughness = 0.1;\n    }else if(matId == 5){ //bird other\n        mat.albedo = vec3(0.4, 0.8, 1.0);\n        mat.metallic = vec3(0.0);\n        mat.roughness = 0.0;\n\n    }else if(matId == 6){ // bird wing\n        mat.albedo = vec3(0.8, 0.9, 1.0);\n        mat.metallic = vec3(0.0);\n        mat.roughness = 0.0;\n    }else if(matId == 7){ // bird heada\n        mat.albedo = vec3(41.0/255.0, 13.0/255.0, 4.0/255.0);\n        mat.metallic = vec3(0.0);\n        mat.roughness = 0.0;\n    }\n    return mat;\n}\n\n\nvec3 pbr(vec3 surfacePos, vec3 normal, vec3 col, int matId){\n    DirectionalLight directionalLight;\n    directionalLight.direction = vec3(-1.0, 0.3, -0.4);\n    directionalLight.color = vec3(1.0);\n    \n    directionalLights[0] = directionalLight;\n    numDirectionalLights = 1;\n    \n    PointLight pointLight;\n    pointLight.visible_distance = 50.0;\n    pointLight.decay = 4.4;\n    \n    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n    vec3 cameraLookDir = normalize(cam.target-cam.position);\n    for(int i=0; i<LIGHT_MAX; i++){\n        pointLights[i] = pointLight;\n        if(i==0){\n            pointLights[i].position = cameraLookDir*10.0;\n            //pointLights[i].position = cam.target*30.0;\n            pointLights[i].color = lightColor;\n        }\n        if(i==1){\n            pointLights[i].position = cameraLookDir*30.0 + 5.0 * sin(app_iTime*PI);\n            vec3 c = vec3(1.0, 1.0, 1.0);\n            if(app_iTime >=4.5 && app_iTime < 10.0){\n                c = vec3(1.0, 0.3, 0.0);\n            }else if(app_iTime >= 24.5 && app_iTime < 30.0){\n                c = vec3(1.0, 0.3, 1.0);\n            }\n            pointLights[i].color = c;\n        \n        }\n        if(i==2){\n            pointLights[i].position = cam.target*50.0 + 5.0 * cos(app_iTime*PI);\n            vec3 c = vec3(0.0, 1.0, 0.0);\n            if(app_iTime >= 4.5 && app_iTime < 10.0){\n                c = vec3(1.0, 1.0, 1.0);\n            }else if(app_iTime >= 24.5 && app_iTime < 30.0){\n                c = vec3(0.0, 0.3, 1.0);\n            }\n            pointLights[i].color = c;\n        }\n        if(i==3){\n            pointLights[i].position = cam.target*40.0 + 5.0 * sin((app_iTime+PI)*PI);\n\n            vec3 c = vec3(0.0, 0.0, 1.0);\n            if(app_iTime >= 4.5 && app_iTime < 10.0){\n                c = vec3(1.0, 0.3, 0.0);\n            }else if(app_iTime >= 24.5 && app_iTime < 30.0){\n                c = vec3(0.0, 0.5, 1.0);\n            }\n            pointLights[i].color = c;\n        }\n        \n\n    }\n    numPointLights = 4;\n    PBRMaterial material;\n    material = doPBRMaterial(matId , surfacePos);\n\n    \n    ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n    vec3 emissive = vec3(0.0);\n    \n    IncidentLight directLight;\n    \n    GeometricContext geometry;\n    geometry.position = surfacePos;\n    geometry.normal = normal;\n    geometry.viewDir = normalize(cam.position-surfacePos);\n    \n    // point light\n    for (int i=0; i<LIGHT_MAX; ++i) {\n        if (i >= numPointLights) break;\n        getPointDirectLightIrradiance(pointLights[i], geometry.position, directLight);\n        if (directLight.visible) {\n            RE_Direct(directLight, geometry, material, reflectedLight);\n        }\n    }\n    \n\n    \n    // directional light\n    for (int i=0; i<LIGHT_MAX; ++i) {\n        if (i >= numDirectionalLights) break;\n        getDirectionalDirectLightIrradiance(directionalLights[i], directLight);\n        RE_Direct(directLight, geometry, material, reflectedLight);\n    }\n\n\n    vec3 specular = (reflectedLight.directSpecular + reflectedLight.indirectSpecular);\n    vec3 diffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\n    col += specular;\n    col += diffuse;\n    \n\n    return col;\n}\n\nvec3 doColor(vec3 pos, int matId){\n    vec3 col;\n    \n    \n    vec3 normal = getNormal(pos);\n    float depth = distance(pos, cam.position)/cam.farClip;\n\n    vec3 surfacePos = pos + normal * epsilon;\n    float ambient = 0.1;\n    vec3 lightDir = vec3(1.0, 1.0, 0.0);\n\n    col += pbr(surfacePos, normal, col, matId);\n    col += ambient;\n    \n    //ambient occlusion\n    col *= genAo(surfacePos, normal);\n\n    //postprocess\n    col = LinearToGamma(col, 1.1);\n        \n    float luminance = ( 0.298912 * col.r + 0.586611 * col.g + 0.114478 * col.b );\n    \n    return col;\n}\n\nvec3 fog(vec3 origin, float total_d, vec3 fogColor, float intensity){\n    vec3 fog = vec3(1.0-total_d/cam.farClip) * intensity;\n    return origin * fogColor * fog;\n}\n\n\nvec3 trace(vec2 uv){\n    float camShake = (snoise(vec3(0.0, 0.0, sin(fract(iTime/4.5)*PI)))+1.0)-0.5;\n    camShake /= 100.0;\n    cam.position = vec3(cos(app_iTime/10.0*PI)/5.0, sin(app_iTime/5.0*PI)/5.0, cos(app_iTime/10.0*PI)*5.0);\n    cam.position += vec3(camShake, camShake, 0.0);\n\n    cam.fov = 120.0;\n    cam.farClip = 1000.0;\n\n    float turniTime = 1.0;\n    cam.target = mix(getTunnelMoveDirection(app_iTime), getTunnelMoveDirection(app_iTime+turniTime), fract(app_iTime/turniTime));\n//    cam.target = vec3(1.0, 0.0, 0.0);\n    if(isMove == 0) cam = debugCam;\n \n    mat3 ca = setCamLookAt(cam);\n    float fov = deg2rad(cam.fov / 2.0);\n    \n    vec3 ro = cam.position;\n    vec3 rd = normalize(ca * vec3(uv.xy, fov));    \n    vec3 cur = ro;\n    \n    //trace\n    float result;\n    float total_d;\n    int savedMaterialId;\n\n    for (int i = 0; i < rayLoopCount; i++)\n    {\n        result = sceneDist(cur);\n        total_d += result;\n        if (result < epsilon || distance(cur, cam.position) > cam.farClip){\n            savedMaterialId = materialId;\n            \n            break;\n            \n        }\n        cur += rd * result;\n    }\n    \n    if(result >= epsilon){\n        return doBackground();\n    }\n    \n    vec3 col = doColor(cur, savedMaterialId);\n\n    col = brightnessContrast(col, 0.5, 2.6);\n    col = fog(col, total_d, vec3(1.0), 1.0);\n    \n    col *= clamp(vec3(2.0-length(uv)), 0.0, 1.0);\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    app_iTime = fract(iTime/40.0)*40.0;\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    fragColor = vec4(trace(uv), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}