{
    "Shader": {
        "info": {
            "date": "1529776812",
            "description": "3d space with camera\nIllumination using raymarching technique",
            "flags": 0,
            "hasliked": 0,
            "id": "4dVBDW",
            "likes": 4,
            "name": "3d Camera and Raymarching",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "camera",
                "boolean"
            ],
            "usePreview": 0,
            "username": "pedrolb",
            "viewed": 524
        },
        "renderpass": [
            {
                "code": "// CONSTANTS\n//\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n\n// HERE WE DEFINE CAMERA PROPERTIES\n//\nfloat camFOV = 45.0;\nvec3 cameraInitialPos = vec3(0.0, 0.0, -10.0);\nmat3x3 camMatrix = mat3x3(\n    vec3(1.0, 0.0, 0.0), // right vec\n    vec3(0.0, 1.0, 0.0), // up vec\n    vec3(0.0, 0.0, 1.0) // forward vec\n);\n\n\n// TRANSFORM A SCREEN PIXEL IN A VECTOR IN THE WORLD\n//\nvec3 ScreenPointToWorld (vec2 screenPoint) // Don't consider camera position, it needs to be added if needed\n{\n\tvec2 xyWorld = screenPoint - iResolution.xy / 2.0;\n    float zWorld = abs(iResolution.x / 2.0) / tan(radians(camFOV / 2.0));\n    \n    return (camMatrix * normalize(vec3(xyWorld, zWorld)));\n}\n\n// HERE WE DEFINE A FUNCTION THAT RETURNS A THE DISTANCE FROM THE SURFACE...\n//FOR A SIMPLE SPHERE AT THE POSITION [0.0, 0.0, 0.0] AND A RADIUS OF 1.0\n//\nfloat SdSphere(vec3 p)\n{\n\treturn length(p) - 1.0;\n}\nfloat SdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n// OPERATORS\nfloat IntersectSD(float distA, float distB) {\n    return max(distA, distB);\n}\nfloat UnionSD(float distA, float distB) {\n    return min(distA, distB);\n}\nfloat DifferenceSD(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n// COMPUTE ALL THE OBJECTS IN A SINGLE VOLUME\nfloat SceneSD(vec3 p)\n{\n    float sphereVolume = SdSphere(p);\n    \n    mat3x3 rotTorusMatrix = mat3x3(\n    \tvec3(cos(iTime), -sin(iTime), 0.0),\n        vec3(sin(iTime), cos(iTime), 0.0),\n        vec3(0.0, 0.0, 1.0)\n\t);\n    float torusVolume = SdTorus(rotTorusMatrix * p, vec2(1.0, 0.1));\n    \n    mat3x3 rotTorusMatrix2 = mat3x3(\n    \tvec3(1.0, 0.0, 0.0),\n        vec3(0.0, cos(iTime), -sin(iTime)),\n        vec3(0.0, sin(iTime), cos(iTime))\n\t);\n    float torusVolume2 = SdTorus(rotTorusMatrix2 * p, vec2(1.0, 0.1));\n    \n    float stack = DifferenceSD(sphereVolume, torusVolume);\n    return DifferenceSD(stack, torusVolume2);\n}\n\n// RETURNS THE NORMAL OF A GIVEN POINT ON SURFACE USING APROXIMATION\n//\nvec3 EstimatedSphereNormal(vec3 p)\n{\n    return normalize(vec3(\n    \tSceneSD(vec3(p.x + EPSILON, p.y, p.z)) - SceneSD(vec3(p.x - EPSILON, p.y, p.z)),\n        SceneSD(vec3(p.x, p.y + EPSILON, p.z)) - SceneSD(vec3(p.x, p.y - EPSILON, p.z)),\n        SceneSD(vec3(p.x, p.y, p.z  + EPSILON)) - SceneSD(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n// RETURNS THE DISTANCE FROM THE CAMERA OF THE CLOSEST POINT TO THE SURFACE\n//\nfloat RayMarchingClosestPoint(vec3 camPos, vec3 lookDir, float start, float end)\n{\n    float depth = start;\n    for(int i = 0; i < MAX_MARCHING_STEPS; i++)\n    {\n        float distToSurface = SceneSD(camPos + lookDir * depth);\n        if(distToSurface < EPSILON)\n        {\n            return depth;\n        }\n        depth += distToSurface;\n        if(depth >= end)\n        {\n        \treturn end;    \n        }\n    }\n    return end;\n}\n\n\n// CONTRIBUTION FOR EACH LIGHT USING PHONG\n//\nvec3 LightContribution(\n    vec3 diffuseColor, \n    vec3 specularColor, \n    vec3 ambientColor,\n    float glossiness,\n    vec3 normal,\n    vec3 viewDir,\n    vec3 surfacePos,\n    vec3 lightColor,\n    float lightIntensity,\n    vec3 lightPos\n)\n{\n    vec3 N = normal;\n    vec3 V = -viewDir;\n    vec3 L = normalize(lightPos - surfacePos);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = max(0.0, dot(L, N));\n    float dotRV = max(0.0, dot(R, V));\n    float dotVN = max(0.0, dot(V, N));\n    \n    return \n        (lightIntensity * lightColor * \n            (dotLN * diffuseColor\n             + (1.0 - mix(0.1, 1.0, dotVN * dotVN)) * specularColor * pow(dotRV, glossiness)\n             + ambientColor)\n        );\n}\n\n\n// MAIN\n//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Change Camera Position\n    vec3 camCurrentPos = vec3(2.0 * sin(iTime * 0.4), sin(iTime) * 0.1, 2.0 * cos(iTime * 0.4)) + cameraInitialPos;\n    \n    // Normalized pixel coordinates (from -1 to 1)\n    //vec2 uv = 2.0 * (fragCoord - iResolution.xy / 2.0) / iResolution.xy;\n\t//vec2 uv = fragCoord;\n    \n    vec3 viewDir = ScreenPointToWorld(fragCoord);\n    vec3 viewPos = camCurrentPos;    \n    float dist = RayMarchingClosestPoint(viewPos, viewDir, MIN_DIST, MAX_DIST);\n    vec3 surfPos = viewPos + viewDir * dist;\n    vec3 surfNormal = EstimatedSphereNormal(surfPos);\n    \n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.1, 0.18, 0.2, 1.0);\n        fragColor.rgb *= 0.5;\n\t\treturn;\n    }\n\telse\n    {\n        \n        vec3 surfaceColor = vec3(0.7, 0.7, 0.7);\n        float surfaceGlossiness = 30.0;\n        \n        vec3 light1Color = vec3(0.75, 0.9, 1.0);\n        float light1Intensity = 1.0;\n        vec3 light1Pos = vec3(3.0 * cos(iTime), 2.0, 3.0 * sin(iTime));\n        \n        vec3 light2Color = vec3(0.75, 0.9, 1.0);\n        float light2Intensity = 0.5;\n        mat3x3 rotMat = mat3x3(\n            vec3(cos(1.0), -sin(1.0), 0.0),\n            vec3(sin(1.0), cos(1.0), 0.0),\n            vec3(0.0, 0.0, 1.0)\n        );\n        vec3 light2Pos = rotMat * vec3(3.0 * cos(iTime * 0.3), 0.0, 3.0 * sin(iTime * 0.3));\n        \n        // Light1\n        fragColor.rgb += LightContribution(\n            surfaceColor, //vec3 diffuseColor, \n            vec3(1.0), //vec3 specularColor, \n            vec3(0.1, 0.18, 0.2), //vec3 ambientColor,\n            surfaceGlossiness, //float glossiness,\n            surfNormal, //vec3 normal,\n            viewDir, //vec3 viewDir,\n            surfPos, //vec3 surfacePos,\n            light1Color, //vec3 lightColor,\n            light1Intensity, //float lightIntensity,\n            light1Pos //vec3 lightPos\n        );\n        \n        // Light 2\n        fragColor.rgb += LightContribution(\n            surfaceColor, //vec3 diffuseColor, \n            vec3(1.0), //vec3 specularColor, \n            vec3(0.1, 0.18, 0.2) / 2.0, //vec3 ambientColor,\n            surfaceGlossiness, //float glossiness,\n            surfNormal, //vec3 normal,\n            viewDir, //vec3 viewDir,\n            surfPos, //vec3 surfacePos,\n            light2Color, //vec3 lightColor,\n            light2Intensity, //float lightIntensity,\n            light2Pos //vec3 lightPos\n        );\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}