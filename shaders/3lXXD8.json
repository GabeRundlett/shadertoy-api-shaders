{
    "Shader": {
        "info": {
            "date": "1562656912",
            "description": "Click and drag anywhere on the screen to manipulate the camera. This shader draws a 2.5 dimensional surface based on audio input",
            "flags": 36,
            "hasliked": 0,
            "id": "3lXXD8",
            "likes": 8,
            "name": "plastic surface",
            "published": 3,
            "tags": [
                "raytracing",
                "interactive",
                "audio"
            ],
            "usePreview": 0,
            "username": "zzggbb",
            "viewed": 881
        },
        "renderpass": [
            {
                "code": "#define SPECTROGRAM iChannel0\n\n// Use LIGHT_MODEL 0 for greyscale lighting\n// Use LIGHT_MODEL 1 for height based gradient lighting\n// Use LIGHT_MODEL 2 for phong lighting\n#define LIGHT_MODEL 1\n\n// distance from center of surface to eye\n#define EYE_DISTANCE 250.0\n\n// lowering DT will increase quality, but slow down framerate\n#define DT 1.0\n\n// length, height, and width of the surface's bounding box\n#define BOX vec3(200, 50, 200)\n\n// constants for working with surface's bounding box\n#define FLB vec3(-BOX.x/2.0, 0.0, -BOX.z/2.0)\n#define BRT vec3(BOX.x/2.0, BOX.y, BOX.z/2.0)\n#define BOX_X vec3(BOX.x, 0.0, 0.0)\n#define BOX_Y vec3(0.0, BOX.y, 0.0)\n#define BOX_Z vec3(0.0, 0.0, BOX.z)\n\nfloat surface_discrete(vec2 c) {\n    float tex_x = linscale(c.x, BOX.x*.5, -BOX.x*.5, 0.0, iResolution.x - 1.0);\n    float tex_y = linscale(c.y, -BOX.z*.5, BOX.z*.5, 0.0, iResolution.y - 1.0);\n    ivec2 tex_c = ivec2(tex_x, tex_y);\n    return max(texelFetch(SPECTROGRAM, tex_c, 0).a * BOX.y, DT);\n}\n\nvec4 surface_smooth(vec2 c) {\n    // return the vec3 normal, and the height of the surface at c\n    \n    // vertical unit vector\n    vec3 Y = vec3(0.0, 1.0, 0.0);\n    \n    return vec4(Y, surface_discrete(c));\n    \n    //if (floor(c) == ceil(c)) {\n    //\treturn vec4(Y, surface_discrete(c));\n    //}\n    \n    // corner coordinates\n    // at these points the spectrogram has actual values.\n    // for all points OTHER than corner points, we have to interpolate.\n\tvec2 c0 = vec2(floor(c.x), floor(c.y));\n    vec2 c1 = vec2(ceil(c.x), floor(c.y));\n    vec2 c2 = vec2(ceil(c.x), ceil(c.y));\n    vec2 c3 = vec2(floor(c.x), ceil(c.y));\n    \n    // center coordinate\n    vec2 cc = (floor(c) + ceil(c)) * 0.5;\n    \n    // corner points\n    vec3 p0 = vec3(c0.x, surface_discrete(c0), c0.y);\n    vec3 p1 = vec3(c1.x, surface_discrete(c1), c1.y);\n    vec3 p2 = vec3(c2.x, surface_discrete(c2), c2.y);\n    vec3 p3 = vec3(c3.x, surface_discrete(c3), c3.y);\n    \n    // center point\n    vec3 pc = vec3(cc, (p0.y + p1.y + p2.y + p3.y) / 4.0).xzy;\n    \n    bool TR = c.y > (p1.z - p3.z)/(p1.x - p3.x)*(c.x - p3.x) + p3.z;\n    bool TL = c.y > (p0.z - p2.z)/(p0.x - p2.x)*(c.x - p2.x) + p2.z;\n    \n    vec3 normal;\n    \n    if (TR && TL) {\n    \t// top triangle (pc, p2, p3)\n        normal = cross(p2 - pc, p3 - pc);\n    } else if (TR && !TL) {\n    \t// right triangle: (pc, p1, p2)\n        normal = cross(p1 - pc, p2 - pc);\n    } else if (!TR && TL) {\n    \t// left triangle: (pc, p0, p3)\n        normal = cross(p3 - pc, p0 - pc);\n    } else {\n    \t// bottom triangle: (pc, p0, p1)\n        normal = cross(p0 - pc, p1 - pc);\n    }\n    \n    normal = normalize(normal);\n    vec3 p = vec3(c.x, 0.0, c.y);\n    float height = dot(pc - p, normal) / dot(Y, normal);\n    return vec4(normal, height);\n}\n\nvec3 phong(vec3 eye, vec3 p) {\n    // get color of point 'p' from perspective of 'eye' using phong model\n\n    vec3 light_pos = vec3(100.0, 100.0, 0.0);\n    \n    vec3 ambient_color = vec3(1.00, 1.00, 1.00);\n    \n    float Ia = 1.0; // ambient strength\n    float Id = 1.0; // diffuse strength\n    float Is = 1.0; // specular strength\n    float sh = 64.0; // shininess\n    \n    vec3 N = surface_smooth(p.xz).xyz; \t// normal at p\n    vec3 L = normalize(light_pos - p);  // vector from p to light\n    vec3 V = normalize(eye - p);\t\t// vector from p to eye\n\t\n    /*\n    if dot(a,b) = 0, angle between a & b = 90\n    if dot(a,b) < 0, angle between a & b > 90\n    if dot(a,b) > 0, angle between a & b < 90 \n\t*/\n    if (dot(V, N) < 0.0)\n        N = -N;\n    \n    vec3 surface_color = color_gradient(p.y / BOX.y);\n    \n    vec3 R = normalize(reflect(-L, N)); // reflection vector\n    \n    // ambient light contribution\n    vec3 La = Ia * ambient_color;\n    \n    // diffuse light contribution\n    vec3 Ld = Id * surface_color * max(0.0, dot(N, L));\n    \n    // specular light contribution\n    vec3 Ls = Is * surface_color * pow(max(0.0, dot(V, R)), sh);\n        \n    return La/3.0 + Ld/3.0 + Ls/3.0;\n}\n\nvec3 light_model(vec3 eye, vec3 p) {\n\t#if LIGHT_MODEL == 0\n    \treturn vec3(p.y / BOX.y);\n    #elif LIGHT_MODEL == 1\n    \treturn color_gradient(p.y / BOX.y);\n    #else\n    \treturn phong(eye, p);\n    #endif\n}\n\nvec4 line_quad_intersect(vec3 p0, vec3 s1, vec3 s2, vec3 r0, vec3 rd) {\n\t/*\n\tp0: corner of quadrilateral\n\ts1, s2: sides of quadrilateral, origin at p0\n\tr0: origin of line\n\trd: direction of line\n\n\treturn value: \n\t\txyz: point of intersection (only valid if a is 1)\n\t\ta: 1 if intersection, 0 if no intersection\n\t*/\n    \n    // normal to surface of quadrilateral\n    vec3 N = cross(s1, s2);\n    \n\tfloat a = dot(N, rd);\n    float b = dot(N, p0 - r0);\n    \n    if (a == 0.0) {\n        // line and quadrilateral are parallel\n\t\treturn vec4(0);  \n    } else {\n        // line and quadrilateral are not parallel\n        \n        // distance from origin of line to point where line intersects the quadrilateral's plane\n        float t = b / a;\n        \n        // point where line intersects the quadrilateral's plane\n        vec3 p = r0 + t*rd;\n        \n        // scalar projection of p - p0 on s1\n        float q1 = dot(p - p0, normalize(s1));\n        float l1 = length(s1);\n        if (q1 < 0.0 || q1 > l1) \n            return vec4(0); // p is outside of quadrilateral\n        \n        // scalar projection of p - p0 on s2\n        float q2 = dot(p - p0, normalize(s2));\n        float l2 = length(s2);\n        if (q2 < 0.0 || q2 > l2) \n            return vec4(0); // p is outside of quadrilateral\n        \n        return vec4(p, 1);\n    }    \n}\n\nvec2 screen_coord(vec2 xy, vec2 dim) {\n    return (xy - 0.5*dim) / min(dim.x, dim.y);\n}\n\nmat3 lookat(vec3 eye, vec3 at, vec3 up) {\n    vec3 f = normalize(at - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = normalize(cross(s, f));\n    return mat3(s, u, -f);\n}\n\n#define UPDATE_INTERSECTIONS(p0, s1, s2, r0, rd) { \\\n    LQI = line_quad_intersect(p0, s1, s2, r0, rd); \\\n    if (LQI.a == 1.0) { \\\n        if (intersections == 0) p1 = LQI.xyz; \\\n        else p2 = LQI.xyz; \\\n        intersections++; \\\n    } \\\n}\nvec3 render(vec3 eye, vec3 ray) {\n    vec4 LQI;\n    vec3 p1, p2;\n    int intersections = 0;\n    \n    UPDATE_INTERSECTIONS(FLB, BOX_X, BOX_Y, eye, ray); // front\n    UPDATE_INTERSECTIONS(FLB, BOX_Y, BOX_Z, eye, ray); // left\n    UPDATE_INTERSECTIONS(FLB, BOX_X, BOX_Z, eye, ray); // bottom\n    UPDATE_INTERSECTIONS(BRT, -BOX_X, -BOX_Y, eye, ray); // back\n    UPDATE_INTERSECTIONS(BRT, -BOX_Y, -BOX_Z, eye, ray); // right\n    UPDATE_INTERSECTIONS(BRT, -BOX_X, -BOX_Z, eye, ray); // top\n\n    if (intersections == 0)\n        // ray doesn't intersect with the bounding box\n        return BACKGROUND_COLOR;\n    \n    // p_min is the closer intersection between the ray and the box\n    // p_max is the further intersection between the ray and the box\n    vec3 p_min, p_max;\n    if (distance(p1, eye) > distance(p2, eye)) {\n        p_min = p2;\n        p_max = p1;\n    } else {\n    \tp_min = p1;\n        p_max = p2;\n    }\n    \n    float height, height_last, py_last;\n    \n    vec3 dp = DT*ray;\n    bool p_min_below = p_min.y < surface_smooth(p_min.xz).a;\n    \n    for (vec3 p = p_min; distance(p_min, p) < distance(p_min, p_max); p += dp) {\n        height = surface_smooth(p.xz).a;\n        if (p.y > height && p_min_below || p.y < height && !p_min_below) {\n            vec3 surface_point = p - dp + dp * (py_last - height_last)/(height - p.y + py_last - height_last);\n            return light_model(eye, surface_point);\n        }\n        height_last = height;\n        py_last = p.y;\n    }\n    \n    // ray intersects with the bounding box but not the surface\n    return BACKGROUND_COLOR;\n}\n\nvec3 sphere2xyz(float yaw, float pitch) {\n    return vec3(sin(pitch)*cos(yaw), cos(pitch), sin(pitch)*sin(yaw));\n}\n\nfloat osc(float speed, float m, float M) {\n\treturn linscale(sin(speed * iTime), -1.0, 1.0, m, M);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 p = screen_coord(fragCoord.xy, iResolution.xy);\n    float yaw = iMouse.x < 0.01 ? 0.6*iTime  : linscale(iMouse.x, 0., iResolution.x, -PI, PI);\n    float pitch = iMouse.y < 0.01 ? osc(0.3, .55*PI, .35*PI) : linscale(iMouse.y, 0., iResolution.y, 0.0, PI);\n    vec3 eye = EYE_DISTANCE * sphere2xyz(yaw, pitch);\n    vec3 at = vec3(0.0, 0.0, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 ray = lookat(eye, at, up) * normalize(vec3(p, -1.0));\n    vec3 col = render(eye, ray);\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.14159265\n\n#define BACKGROUND_COLOR vec3(0.05)\n\n// Scrolling speed of the spectrogram.\n#define SPECTROGRAM_SPEED 0.005\n\n// Use INTERP 2 for cubic curve interpolation\n// Use INTERP 1 for linear interpolation.\n// Use INTERP 0 for nearest neighbor interpolation.\n#define INTERP 2\n\n// Raise the FFT to this power.\n// Powers greater than 1.0 push down the weaker magnitudes.\n// powers less than 1.0 pull up the weaker magnitudes.\n#define FFT_POW 3.0\n\n// Define our color palette\nvec3 color_gradient(float t) {\n    t *= 0.75;\n\tvec3 a = vec3(0.5);\n    vec3 b = vec3(0.5);\n    vec3 c = vec3(1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    return a + b * cos(2.0*PI*(c*t + d));\n}\n\n// scale from linear range [x1,x2] to linear range [y1,y2]\nfloat linscale(float x, float x1, float x2, float y1, float y2) {\n\treturn (y2-y1)/(x2-x1)*(x-x2) + y2;   \n}\n\n// scale from logarithmic range [x1,x2] to linear range [y1,y2]\nfloat logxscale(float x, float x1, float x2, float y1, float y2) {\n\treturn (y2-y1)/(log2(x2+1.0)-log2(x1+1.0))*(log2(x+1.0)-log2(x2+1.0))+y2;   \n}\n\n// scale from linear range [x1,x2] to logarithmic range [y1,y2]\nfloat logyscale(float x, float x1, float x2, float y1, float y2) {\n    return pow(2.0, log2((y2+1.0)/(y1+1.0))*(x-x2)/(x2-x1) + log2(y2+1.0)) - 1.0;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define AUDIO_IN iChannel0\n#define AUDIO_IN_SIZE iChannelResolution[0].x\n#define SPECTROGRAM iChannel1\n\n/*\n- This module renders the spectrogram to Buffer B. \n- The top display (spectrogram) and middle display (magnitude spectrum)\n  both use Buffer B as their data source. \n- The bottom row of the buffer stores the most recent FFT curve. \n- The other rows are copies of the row beneath them.\n- The FFT colors are stored in the first 3 channels.\n- The y-values are stored as the alpha channel \n*/\n\nfloat cubic_interp(float x, vec4 xs, vec4 ys) {\n    vec4 xs2 = xs*xs;\n    vec4 xs3 = xs*xs2;\n    mat4 A = mat4(xs3, xs2, xs, vec4(1.0));\n    vec4 k = inverse(A) * ys;\n    float x2 = x*x;\n    float x3 = x*x2;\n    return dot(k, vec4(x3, x2, x, 1.0));\n}\n\nfloat fft(float x) {\n    // convert x from uv space [0..1] to fft index [0..511]\n    float fft_x = logyscale(x, 0.0, 1.0, 2.0, AUDIO_IN_SIZE-1.0);\n    \n    // sample before closest previous sample\n    float fft_x0 = floor(fft_x) - 1.0;\n    float fft_y0 = texelFetch(AUDIO_IN, ivec2(fft_x0, 0), 0).x;    \n    \n    // closest previous sample\n    float fft_x1 = floor(fft_x); \n    float fft_y1 = texelFetch(AUDIO_IN, ivec2(fft_x1, 0), 0).x;\n\n    // closest next sample\n    float fft_x2 = ceil(fft_x); \n    float fft_y2 = texelFetch(AUDIO_IN, ivec2(fft_x2, 0), 0).x;\n    \n    // sample after closest next sample\n    float fft_x3 = ceil(fft_x) + 1.0; \n    float fft_y3 = texelFetch(AUDIO_IN, ivec2(fft_x3, 0), 0).x;\n    \n    vec4 fft_xs = vec4(fft_x0, fft_x1, fft_x2, fft_x3);\n    vec4 fft_ys = vec4(fft_y0, fft_y1, fft_y2, fft_y3);\n\n    #if INTERP == 2\n    // cubic interpolation (smooth corners)\n    float fft_y;\n    if (x > 0.5)\n        fft_y = linscale(fft_x, fft_x1, fft_x2, fft_y1, fft_y2);\n    else\n\t\tfft_y = cubic_interp(fft_x, fft_xs, fft_ys);\n    \n    #elif INTERP == 1\n    // linear interpolation (sharp corners)\n    float fft_y = linscale(fft_x, fft_x1, fft_x2, fft_y1, fft_y2);\n    \n    #elif INTERP == 0\n    // nearest neighbor interpolation\n    float fft_y = fft_y1;\n    #endif\n    \n    return pow(fft_y, FFT_POW);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 col;\n    bool freeze = false;\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    if (0.0 <= uv.y && uv.y <= SPECTROGRAM_SPEED && !freeze) {\n        // shading a pixel in the bottom row, so calculate the FFT curve\n        float y = fft(uv.x);\n    \tfragColor = vec4(0.0, 0.0, 0.0, y);\n    } else {\n        // shading a pixel not in the bottom row, so copy from the pixel below us.\n        float y = uv.y - SPECTROGRAM_SPEED;\n        ivec2 p_tex = ivec2(vec2(uv.x, y) * iResolution.xy);\n        fragColor = texelFetch(SPECTROGRAM, p_tex, 0).rgba;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "mic",
                        "id": 32,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/mic.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}