{
    "Shader": {
        "info": {
            "date": "1574603070",
            "description": "some fine weaving pattern with lighting features. Use mouse to control the light.",
            "flags": 32,
            "hasliked": 0,
            "id": "wsyXzV",
            "likes": 3,
            "name": "Weaving Pattern2",
            "published": 3,
            "tags": [
                "normal",
                "pattern",
                "weaving"
            ],
            "usePreview": 0,
            "username": "sirjofri",
            "viewed": 347
        },
        "renderpass": [
            {
                "code": "/*\nfake 3d rendering - actually only 3d lighting\n\nthere are two ways of mouse control:\n\n#define mousecontrol to turn on the total mouse control. You can then use your mouse to manually adjust the light direction.\notherwise the automatic turntable mode is active. Use mouse x to adjust the angle, mouse y to adjust the speed.\n\n*/\n\n//#define mousecontrol\n\nvec3 background(vec2 uv)\n{\n    return vec3(.1, .01, .03);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n#ifndef mousecontrol\n    float maxangle = iMouse.x == 0. ? .75 : iMouse.x/iResolution.x;\n    float speed = iMouse.y == 0. ? 1. : 1.+iMouse.y/iResolution.y;\n#endif\n    \n    float dist = -distance(uv, vec2(.5))*.3;\n    vec2 direction = uv - vec2(.5);\n    vec2 distort = direction * dist;\n    uv += distort;\n\n#ifndef mousecontrol\n    vec3 dir = normalize(vec3(sin(iTime*speed), cos(iTime*speed), maxangle));\n#else\n    vec3 dir = normalize(vec3(-(iMouse.xy/iResolution.xy)+vec2(.5), .5));\n#endif\n    vec3 cola = vec3(1., .7, 0.);\n    vec3 colb = vec3(.7, 1., 0.);\n\n    vec3 c  = texture(iChannel0, uv).rgb; // weaving pattern masks\n    vec3 n  = (texture(iChannel1, uv).rgb -.5)*2.; // normal map\n    float ao = pow(1.-abs(n.r*n.g), 5.)*c.b;\n    \n    float d = (1.5-dir.z)*2.*pow(dot(dir, normalize(n)), 2.);\n    \n    vec3 col = cola*c.r*c.b + colb*c.g*c.b;\n    vec3 final = (1.-mix(.0, 3., c.b)) * background(uv) + col*d*ao;\n    \n    fragColor = vec4(vec3(final), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\nweaving pattern\n\nred : one direction\ngreen : other direction\nblue : height mask\n*/\n\nconst float weaves = 20.; // number of weaves\nconst float whalf = weaves/2.;\nconst float radius = .3; // radius of the movement\nconst float speed = .1; // speed of the movement\nconst float size = 3.; // size of the pattern scale\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y*size;\n    uv += vec2(sin(iTime*speed)*radius, cos(iTime*speed)*radius);\n    \n    float a = sin(uv.x*weaves);\n    float b = sin(uv.y*weaves);\n    \n    float s = smoothstep(.2, .5, abs(sin(uv.x*whalf+uv.y*whalf)));\n    float t = smoothstep(.2, .5, abs(cos(uv.x*whalf-uv.y*whalf)));\n    \n    float c = (a+b+2.)/4.;\n    float d = 1.-c;\n    \n    float e = max(s*c, t*d);\n    \n    float smask = smoothstep(.0, .0, t*d-s*c);\n    float tmask = smoothstep(.0, .0, s*c-t*d);\n    \n    fragColor = vec4(vec3(smask, tmask, e), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\nNormal map generation\n\nuses the height of the weaving pattern to create a normal map.\n*/\n\n// control the normal offset for the edge detection.\n#define d (0.0015)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float c  = texture(iChannel0, uv).b;\n\n    float l  = texture(iChannel0, uv+vec2(-d, 0.)).b;\n    float r  = texture(iChannel0, uv+vec2(+d, 0.)).b;\n    float t  = texture(iChannel0, uv+vec2(0., +d)).b;\n    float b  = texture(iChannel0, uv+vec2(0., -d)).b;\n    \n    float tl = texture(iChannel0, uv+vec2(-d, +d)).b;\n    float tr = texture(iChannel0, uv+vec2(+d, +d)).b;\n    float bl = texture(iChannel0, uv+vec2(-d, -d)).b;\n    float br = texture(iChannel0, uv+vec2(+d, -d)).b;\n    \n    // to right\n    float tor_t = (-1.*tl) + (+0.* t) + (+1.*tr);\n    float tor_m = (-1.* l) + (+0.* c) + (+1.* r);\n    float tor_b = (-1.*bl) + (+0.* b) + (+1.*br);\n    float tor = (tor_t + tor_m + tor_b + 2.)/4.;\n    \n    // to top\n    float tot_t = (+1.*tl) + (+1.* t) + (+1.*tr);\n    float tot_m = (+0.* l) + (+0.* c) + (+0.* r);\n    float tot_b = (-1.*bl) + (-1.* b) + (-1.*br);\n    float tot = (tot_t + tot_m + tot_b + 2.)/4.;\n    \n    // to left\n    float tol_t = (+1.*tl) + (+0.* t) + (-1.*tr);\n    float tol_m = (+1.* l) + (+0.* c) + (-1.* r);\n    float tol_b = (+1.*bl) + (+0.* b) + (-1.*br);\n    float tol = (tol_t + tol_m + tol_b + 2.)/4.;\n    \n    // to bottom\n    float tob_t = (-1.*tl) + (-1.* t) + (-1.*tr);\n    float tob_m = (+0.* l) + (+0.* c) + (+0.* r);\n    float tob_b = (+1.*bl) + (+1.* b) + (+1.*br);\n    float tob = (tob_t + tob_m + tob_b + 2.)/4.;\n    \n    vec3 col = vec3(tor, tot, sqrt(1.-tor*tor+tot*tot));\n    \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}