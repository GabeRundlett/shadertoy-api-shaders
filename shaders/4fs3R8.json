{
    "Shader": {
        "info": {
            "date": "1702737927",
            "description": "truchet 3d - toroidal hexagonal grid - spherical toroidal dodecahedron",
            "flags": 0,
            "hasliked": 0,
            "id": "4fs3R8",
            "likes": 6,
            "name": "truchet hexagonal dodecahedron",
            "published": 3,
            "tags": [
                "3d",
                "sdf",
                "hexagon",
                "truchet",
                "dodecahedron",
                "schwarzchristoffel"
            ],
            "usePreview": 1,
            "username": "cyperus",
            "viewed": 234
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"truchet hexagonal dodecahedron\"\n//\n// created by Colling Patrik (cyperus) in 2023\n//\n//\n// References & Inspiration:\n//\n// - quick guide for shadertoy by FabriceNeyret2\n//   https://shadertoyunofficial.wordpress.com/\n//\n// - \"Schwarz-Christoffel Mapping\" by mla\n//   https://www.shadertoy.com/view/tsfyRj\n//\n// - conformal mapping with confmap.m by Trefethen\n//   https://people.maths.ox.ac.uk/trefethen/lightning.html\n//\n// - signed distance functions & operations by iq\n//   https://iquilezles.org/articles/distfunctions/\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// ray casting bounding shape\nconst float\n    CAM_DIST = 7.,\n    CAM_FLE = 2.,\n    BB_DIST = 3.,\n    RAY_MIN_DIST = 0.1,\n    RAY_MAX_DIST = CAM_DIST+1.1*BB_DIST;   \n\nconst int MAX_MARCHING_STEPS = 600;\nconst float\n    RAY_STEP_FACTOR = 0.0095,\n    RAY_PRECISION = 1.E-1;\n\n// data from sdf\nvec3 mat_to = vec3(0);\nvec3 mat_to_id = vec3(0);\nvec4 mat_tc = vec4(0);\n\nfloat map(in vec3 p) {\n    float rxy = 0., au = 0.0, av = 0.0;\n    vec2 z = vec2(0.);\n    float d = -1.;\n           \n    /// map platonic solid cells to one cell\n    vec3 pn = normalize(p); \n  \n    // projection from n cells to 1 cell.\n    float cell_id = 0., sr = 0.; //sig(sr): sens of rotation, abs(sr) : number edges per face\n    pn = dodeca_cells(pn, cell_id, sr);\n\n    z = pn.xy/(1.-pn.z);\n    z = cDodecaPolyArc2disk(z);\n\n    // r-polygon-distribution\n    vec2 e = vec2(sqrt(2.), 0.5);\n    float en = 1.+( (8.<0.?e.x:e.y)-1. )*smoothstep(1.,5., abs(8.));        \n    float r = length(z); vec2 zn = z/r;\n    z = dist(r, en) * zn;   \n\n    // stereograpic projection    \n    pn = sp(vec3(z,sr));\n\n    // scale radius\n    p = length(p) * pn;\n    \n    p = p.yzx;\n\n    /// torus\n    z = vec2(length(p.zx), p.y);\n    au = atan(p.x, p.z);\n    \n    z = cmul(z,z); z.x -= 6.;\n    av = atan(z.y, z.x);\n    rxy = length(z);\n    \n    vec2 grid_hex_num = 10. * vec2(3.,1.);\n    p = vec3(grid_hex_num.x*au/PI, grid_hex_num.y* 0.5*sqrt(3.)* av/PI, log(rxy)-0.4);\n\n    /// regular hexagonal tiles\n    vec3 rpt_id = vec3(1.); vec3 p_hex;    \n    p.xy = hexgrid2hex(p.xy, rpt_id);    \n    p.xy = inversesc(p.xy, int(6.));\n    mat_to_id = rpt_id;\n\n    // torus,sphere,2spheres       \n    rxy = length(p.xy); au = atan(p.y, p.x);    \n    z = 2.*ccos(PI*vec2(rxy,2.*p.z));\n    z.x += (3. + 2. * sin(2.*PI*iTime/60.));\n            \n    p = vec3(log(length(z))-0.02, 0.5*au/PI, 0.5*atan(z.y,z.x)/PI);\n    \n    vec2 to_uv = p.yz;\n    float to_d = log(length(z)+0.8);\n    mat_to = vec3(to_uv,to_d);   \n\n    /// truchet 3D cube grid\n    vec3 tc_id = vec3(0.); float tc_a = 0.;   \n    p *= vec3(1.,18.,4.); // r,u,v\n    p.yzx = p.xyz;\n    \n    ivec3 l0 = -ivec3(2.,0,9.);\n    ivec3 l1 = ivec3(2.,1.,9.)-ivec3(1.);\n    tc_id = floor(p);\n    tc_id = clamp(tc_id, vec3(l0), vec3(l1));\n    vec3 q = p - tc_id -0.5;\n\n    // truchet 3D cube tiles\n    float rnd = hash21(tc_id.xz);\n    if(rnd<.5) q.x = -q.x;\n    if(fract(rnd*77.57+iTime/6.)>.75) {\n       vec3 q2 =  length(q.xz-.5)<length(q.xz+.5)\n                ? vec3(q.xz-.5,0.)  \n                : vec3(q.xz+.5,1.);\n       d = sdTorus( vec3(q2.x, q.y, q2.y) , vec2(0.5,0.125) );\n    }\n    else {\n       d = opSmoothUnion( sdCylinder( q.zxy, 0.125 ), sdCylinder( q.xzy, 0.125 ), 0.05 );\n    }\n    mat_tc = vec4(q,rnd);  \n   \n    // return\n    return min(d,to_d);\n}\n\n// intersect\nfloat intersect(in vec3 ro, in vec3 rd, in float px) {\n    float res = -1.0;\n    \n    // bb\n    vec2 dis = isphere( ro, rd , abs(BB_DIST));    \n    if( dis.y<0.0 ) return -1.0;\n    dis.x = max( dis.x, RAY_MIN_DIST );\n    dis.y = min( dis.y, RAY_MAX_DIST );\n\n    // raymarch signed distance field    \n\tfloat fh = RAY_STEP_FACTOR;\n    float t = dis.x;\n    for( int i=0; i<MAX_MARCHING_STEPS; i++  ) {\n        vec3 pos = ro + rd*t;\n        float th = RAY_PRECISION * px * t;\n        float h = map( pos);\n        if( t>dis.y || h<th ) break;\n        t += h*fh;\n    }\n    if( t<dis.y ) {\n        res = t;\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 p, in float prec ) {\n    vec2 e = vec2( prec, 0. );\n    return normalize(vec3(\n\t\tmap(p+e.xyy) - map(p-e.xyy),\n\t\tmap(p+e.yxy) - map(p-e.yxy),\n\t\tmap(p+e.yyx) - map(p-e.yyx) )\n    \t);\n}\n\nvec3 transform(in vec3 p, in float time) { \n\tif (iMouse.x > 0.0) {\n        vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\t\tp.yz = crot(p.yz,-PI*m.y);\n\t\tp.zx = crot(p.zx,-PI*m.x);\n\t}\n    //p.yz = crot(p.yz,-1.*PI*(time+10.));\n    //p.zx = crot(p.zx,-2.*PI*(time+15.));\n\treturn p.xyz;\n}\n\n// textures\nfloat grid_uv(in vec2 uv) {\n    // uv grid alpha mask\n    vec2 sw = abs(fract(uv-0.25)-0.5)-0.25;\n    float sdf = min(sw.x,sw.y)*-max(sw.x,sw.y);\n    float pp = fwidth(sdf);\n    return smoothstep(+pp,-pp,sdf);\n}\n            \nvec4 cells(in vec2 uv, in float h) {\n    // sectors, uv-grid\n    vec4 C;\n    C.a = 1.;\n    C.rgb = h2rgb(h);                      // sector  -> hue\n    C.rgb *= (0.5+ 0.5 * grid_uv(uv))*0.7; // uv-grid -> value\n    return C;\n}\n\nvec4 ribbon(in float uv_x, in float time) {\n    float sdf = -(2.*pulsecollision(1.,1./3. * uv_x, time, 1./3.)-1.);\n    float px = fwidth(sdf); float a = smoothstep(px+0.1,-px-0.1,sdf+0.2);    \n    return vec4( h2rgb(sdf -2./6.),a );\n}\n\nvec4 truchet3D(in vec3 p, in float rnd ,in float time) {\n    float sdf = sdBox( p, vec3(0.5*0.9));\n    float px = fwidth(sdf); float a = smoothstep(px,-px,sdf);\n    return mix(vec4(1.), vec4(h2rgb( fract(abs(rnd)*22.93 + time)),1.), a);\n}\n\n// main\nvoid mainImage(out vec4 O, in vec2 fragCoord) {\n    // normalized time\n    float ntime = iTime/360.;\n\n    // anti-aliasing to take a picture\n    vec3 tot = vec3(0.0);\n    #define AA 1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {       \n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 uv = (2.0*(fragCoord+o) - iResolution.xy)/iResolution.y;\n        \n        // camera viewport --> worldspace\n        vec3 ro = vec3(0,0,-CAM_DIST);\n        vec3 rd = vec3(-uv.x,uv.y,CAM_FLE);\n             ro = transform(ro,ntime);\n             rd = normalize(transform(rd,ntime));\n        \n        // distance hit ray surface\n        float px = 2.0/( iResolution.y*CAM_FLE );\n        float t = intersect( ro, rd, px );\n\n        // background\n        vec3 sky_col = vec3(0.);\n        vec4 C = vec4(sky_col,1.);\n        O = C;\n        \n        // object surface\n        if (t >= 0.) {\n            // surface properties\n            vec3 p = ro + rd * t;\n            vec3 n = calcNormal( p, 0.001);\n            \n            // draw textures\n            O = vec4(0);\n\n            if(O.a<1.) {          \n                float hue = (mat_to_id.x + 2.)/4. + (mat_to_id.z )/8.;\n                C = cells(mat_to.xy/2., hue);\n                C.a = mat_to.z>0.5 ? 0.5 : O.a;\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;\n            }\n\n            if(O.a<1.) {\n                C =  mat_to.z<0.5 ? ribbon( 6.*3.* mat_to.x,  6.*ntime) : vec4(0.);\n                C.rgb *= 0.7;\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;\n            }\n\n            if(O.a<1.) {\n                C = truchet3D(mat_tc.xyz, mat_tc.w, ntime);\n                C.a = 0.5; C.rgb *= 0.5;\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;\n            }\n\n            C = O;\n                       \n            // lighting\n            vec3  came_li_o   = transform(vec3(-10.,10.,-10.),ntime); // origine\n            vec3  came_li_dir = normalize(p - came_li_o);             // direction\n            vec3  came_li_col = vec3(1.,1.,.5);                       // color\n            float came_li_shi = 10.;                                  // shininess            \n\n            float cosa = 1.;\n            O.rgb += 0.1 * cosa * C.rgb * sky_col;           // amb\n            cosa = clamp(dot(-came_li_dir, n), 0., 1.);\n            O.rgb += 0.5 * cosa * C.rgb * came_li_col;       // dif       \n            cosa = pow(clamp(dot(reflect(came_li_dir, n), -rd), 0., 1.), came_li_shi);           \n            O.rgb += 0.4 *(cosa>0.? cosa:0.) * came_li_col ; // spec\n            \n            // fog\n            O.rgb = mix(O.rgb, sky_col, 1.0 - exp(-2.5E-3 * pow(t,3.)));    \n        }\n        tot += O.rgb;\n    }\n    tot /= float(AA*AA);\n    \n    // gamma correction\n    O = vec4(rgb2srgb(tot),1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// const\nconst float PI = abs(atan(0.,-1.));\n\n// 1D transformations\nfloat pulsecollision(in float pf, in float x, in float x0, in float pw) {\n    float ntriw_p = abs( fract( pf*(x - x0) )-0.5);\n    float ntriw_n = abs( fract( pf*(x + x0) )-0.5);\n    float pp = smoothstep( 0.5*pw, 0., ntriw_p );\n    float pn = smoothstep( 0.5*pw, 0., ntriw_n );\n    return (pp+pn);\n}\n\nfloat hash21(vec2 p) {\n    return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453);\n}\n\n// complex\nvec2 cmul(vec2 za,vec2 zb) {\n    return za*mat2(zb.x,-zb.y,zb.yx);\n}\n\nvec2 crot(vec2 z,float a) {\n    return cmul(vec2(cos(a),sin(a)),z);\n}\n\nvec2 cinv(vec2 z) {\n    return z*vec2(1,-1)/dot(z,z);\n}\n    \nvec2 cdiv(vec2 z, vec2 w) {\n    return cmul(z,cinv(w));\n}\n    \nvec2 cpow(vec2 z, int n) {\n  float r = length(z);\n  float theta = atan(z.y,z.x);\n  return pow(r,float(n))*normalize(vec2(cos(float(n)*theta),sin(float(n)*theta)));\n}\n  \nvec2 csqr(vec2 z) {\n    return vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y );\n}\n\nvec2 ccos(vec2 z) {\n    vec2 d=vec2(exp(z.y),exp(-z.y));\n\treturn vec2(cos(z.x)*(d.x+d.y)*.5,-sin(z.x)*(d.x-d.y)*.5);\n}\n\nfloat binomial(float a, int n) {\n   float s = 1.0;\n   for (int i = n; i >= 1; i--,a--) {\n     s *= float(a)/float(i);\n   }\n   return s;\n}\n\nvec2 expi(float x) {\n  return vec2(cos(x),sin(x));\n}\n\nfloat gamma(float z) {\n  const float[8] p = float[](\n    676.5203681218851,\n    -1259.1392167224028,\n    771.32342877765313,\n    -176.61502916214059,\n    12.507343278686905,\n    -0.13857109526572012,\n    9.9843695780195716e-6,\n    1.5056327351493116e-7\n  );\n  z -= 1.0;\n  float x = 0.99999999999980993;\n  for (int i = 0; i < 8; i++) {\n    float pval = p[i];\n    x += pval/(z+float(i+1));\n  }\n  float t = z + 8.0 - 0.5;\n  return sqrt(2.0*PI) * pow(t,z+0.5) * exp(-t) * x;\n}\n\n// beta function\nfloat B(float a, float b) {\n  return (gamma(a)*gamma(b))/gamma(a+b);\n}\n\nvec2 inversesc(vec2 z, int K) {\n  float cn[6];\n  for (int n = 1; n <= 5; n++) {\n    cn[n] = binomial(float(n)-1.0+2.0/float(K),n)/float(1+n*K);\n  }\n  float C = B(1.0/float(K),1.0-2.0/float(K))/float(K);\n  z *= C;\n  vec2 h = cpow(z,int(K));\n  float T1 = -cn[1];\n  float T2 = -cn[2]+float(K+1)*pow(cn[1],2.0);\n  float T3 = -cn[3]+float(3*K+2)*(cn[1]*cn[2]-float(K+1)/2.0*pow(cn[1],3.0));\n  float T4 = -cn[4]+float(2*K+1)*(2.0*cn[1]*cn[3]+pow(cn[2],2.0)-float(4*K+3)*\n                                  (pow(cn[1],2.0)*cn[2]-float(K+1)/3.0*pow(cn[1],4.0)));\n  float T5 = -cn[5]+float(5*K+2)*(cn[1]*cn[4]+cn[2]*cn[3]+float(5*K+3)*\n            (-0.5*pow(cn[1],2.0)*cn[3]-0.5*cn[1]*pow(cn[2],2.0)+float(5*K+4)*\n            (pow(cn[1],3.0)*cn[2]/6.0-float(K+1)*pow(cn[1],5.0)/24.0)));\n  vec2 X = vec2(1,0)+h/pow(C,float(K));\n  vec2 w = cmul(z,vec2(1,0) + T1*h + T2*cpow(h,2) + T3*cpow(h,3) + T4*cpow(h,4) + cdiv(T5*cpow(h,5),X));\n  return w;\n}\n\n// map spherical platonic solid pyramidal sectors to one sector located at -z-axis.\nvec2 hexgrid2hex(in vec2 Z, out vec3 U_id) {\n    const float\n        SQRT3 = sqrt(3.),\n        SQRT_3 = 1./SQRT3;\n\tconst mat2\n        M = mat2(SQRT_3,-1.,-SQRT_3,-1.),\n        iM = 0.5*mat2(SQRT3,-SQRT3,-1.,-1.);\n    Z = crot(Z,PI/6.);\n    Z = iM*Z/0.75;\n    vec3 U = vec3(Z.x,-Z.x-Z.y,Z.y);\n    U_id = 2.*floor(U*0.5+0.5);\n    vec3 U_lo = U-U_id;\n    vec3 aU_lo = abs(U_lo);\n    if (aU_lo.x > aU_lo.y && aU_lo.x > aU_lo.z) {\n        U_lo.x = -U_lo.y-U_lo.z;\n        U_id.x = -U_id.y-U_id.z;\n    }\n    if (aU_lo.y > aU_lo.z) {\n        U_lo.y = -U_lo.x-U_lo.z;\n        U_id.y = -U_id.x-U_id.z;\n    }\n    else {\n        U_lo.z = -U_lo.x-U_lo.y;\n        U_id.z = -U_id.x-U_id.y;\n    }\n    Z = U_lo.rb;\n    Z = M*Z*0.75;\n    return crot(Z,-PI/6.);\n}\n\n// regular circular arc triangle -> unitcircle conformal mapping by using a barycentric approximation\nvec2 cDodecaPolyArc2disk(vec2 z) {\n    // https://people.maths.ox.ac.uk/trefethen/lightning.html\n    const int NUM_j = 25; // poles\n    const vec2[] rf = vec2[NUM_j]\n    (vec2(-0.8260, - 0.5637)\n    ,vec2( 0.8091, + 0.5877)\n    ,vec2(-0.3090, - 0.9511)\n    ,vec2(-0.3089, - 0.9511)\n    ,vec2( 0.8089, - 0.5879)\n    ,vec2(-1.0000, + 0.0000)\n    ,vec2(-1.0000, + 0.0001)\n    ,vec2(-0.3090, + 0.9511)\n    ,vec2(-0.3089, + 0.9511)\n    ,vec2( 0.9996, - 0.0294)\n    ,vec2( 0.9103, + 0.4140)\n    ,vec2( 0.2242, + 0.9746)\n    ,vec2( 0.3369, - 0.9415)\n    ,vec2(-0.8576, + 0.5143)\n    ,vec2(-0.4307, - 0.9025)\n    ,vec2(-0.3567, + 0.9342)\n    ,vec2(-0.9988, - 0.0485)\n    ,vec2( 0.7796, + 0.6263)\n    ,vec2( 0.7796, - 0.6263)\n    ,vec2(-0.2828, - 0.9592)\n    ,vec2(-0.3161, + 0.9487)\n    ,vec2(-1.0000, + 0.0075)\n    ,vec2(-0.2187, + 0.9758)\n    ,vec2( 0.8366, - 0.5479)\n    ,vec2( 0.8134, + 0.5817));\n\n    const vec2[] rw = vec2[NUM_j]\n    (vec2(-0.1213, - 0.0   )\n    ,vec2( 0.0028, + 0.0187)\n    ,vec2( 0.0000, - 0.0000)\n    ,vec2(-0.0010, + 0.0008)\n    ,vec2(-0.0017, - 0.0008)\n    ,vec2(-0.0000, - 0.0000)\n    ,vec2(-0.0041, - 0.0007)\n    ,vec2(-0.0000, - 0.0000)\n    ,vec2( 0.0219, - 0.0012)\n    ,vec2(-0.2767, - 0.2629)\n    ,vec2( 0.2548, - 0.3937)\n    ,vec2( 0.4733, + 0.0936)\n    ,vec2(-0.0954, - 0.0232)\n    ,vec2(-0.1703, + 0.0600)\n    ,vec2(-0.0347, - 0.0277)\n    ,vec2(-0.3617, + 0.0048)\n    ,vec2(-0.0493, + 0.0086)\n    ,vec2( 0.1573, + 0.1009)\n    ,vec2(-0.0406, - 0.0040)\n    ,vec2(-0.0118, - 0.0116)\n    ,vec2( 0.0485, + 0.1712)\n    ,vec2(-0.0014, + 0.0204)\n    ,vec2( 0.1498, + 0.3189)\n    ,vec2(-0.0419, - 0.0255)\n    ,vec2( 0.1042, - 0.0471));\n\n    const vec2[] rz = vec2[NUM_j]\n    (vec2(-0.2339, - 0.1614)\n    ,vec2( 0.2737, + 0.1982)\n    ,vec2(-0.1045, - 0.3217)\n    ,vec2(-0.1039, - 0.3216)\n    ,vec2( 0.2731, - 0.1991)\n    ,vec2(-0.3383, + 0.0   )\n    ,vec2(-0.3379, + 0.0006)\n    ,vec2(-0.1045, + 0.3217)\n    ,vec2(-0.1039, + 0.3216)\n    ,vec2( 0.2841, - 0.0069)\n    ,vec2( 0.2810, + 0.1078)\n    ,vec2( 0.0682, + 0.2764)\n    ,vec2( 0.0943, - 0.2680)\n    ,vec2(-0.2418, + 0.1502)\n    ,vec2(-0.1496, - 0.2698)\n    ,vec2(-0.1287, + 0.2944)\n    ,vec2(-0.3202, - 0.0306)\n    ,vec2( 0.2411, + 0.2130)\n    ,vec2( 0.2411, - 0.2130)\n    ,vec2(-0.0808, - 0.3165)\n    ,vec2(-0.1114, + 0.3141)\n    ,vec2(-0.3331, + 0.0088)\n    ,vec2(-0.0510, + 0.3095)\n    ,vec2( 0.2770, - 0.1635)\n    ,vec2( 0.2747, + 0.1886));\n    \n    // polynomial barycentric representation\n    vec2 zn = vec2(0.); vec2 zd = vec2(0.);       \n    for(int j = 0; j<NUM_j; j++)\n    {\n        vec2 zj = cdiv( rw[j], (z-rz[j]));\n        zd += zj; // sum denominator\n        zn += cmul(rf[j], zj); // sum nominator\n    }\n    return cdiv(zn, zd);\n}\n\n// map spherical platonic solid pyramidal-face-cells to one cell located at -z-axis.\nvec3 dodeca_cells(in vec3 p, out float cell_id, out float sr) {\n    const float PI_2 = PI/2.;\n\t//// dodecaeder\n\tconst float gr0 = (1.+sqrt(5.))/2.; const float gr1 = 1./gr0; const float gr2 = gr0-gr1;\n\t// cell-wall-face-normals\n\tbool nx = dot(vec3( 1., 0., 0.),p)>=0.;\n\tbool ny = dot(vec3( 0., 1., 0.),p)>=0.;\n\tbool nz = dot(vec3( 0., 0., 1.),p)>=0.;\n\t//\n\tbool n0A = dot(vec3( gr2,-gr0, gr1),p)>=0.;\n\tbool n0B = dot(vec3( gr1, gr2,-gr0),p)>=0.;\n\tbool n0C = dot(vec3(-gr0, gr1, gr2),p)>=0.;\n\t//\n\tbool n1A = dot(vec3(-gr2,-gr0,-gr1),p)>=0.;\n\tbool n1B = dot(vec3(-gr1, gr2, gr0),p)>=0.;\n\tbool n1C = dot(vec3( gr0, gr1,-gr2),p)>=0.;\n\t//\n\tbool n2A = dot(vec3(-gr2, gr0, gr1),p)>=0.;\n\tbool n2B = dot(vec3(-gr1,-gr2,-gr0),p)>=0.;\n\tbool n2C = dot(vec3( gr0,-gr1, gr2),p)>=0.;\n\t//\n\tbool n3A = dot(vec3( gr2, gr0,-gr1),p)>=0.;\n\tbool n3B = dot(vec3( gr1,-gr2, gr0),p)>=0.;\n\tbool n3C = dot(vec3(-gr0,-gr1,-gr2),p)>=0.;\n\n\t// cells\n    float a = PI_2-atan((sqrt(5.)-1.)/2.);\n    float b = PI/10.; // 18°\n    float a_x = 0.; float a_y = 0.; float a_z = 0.;\n\t// ---------------------------------------------------------------\n\t//Fpxpy\n    if(ny && !n2B && n2C && !n0C && n0B)\t\n\t{\n\t\tcell_id = 0.;\n\t\ta_y = PI_2;\n        a_x = a-PI_2;\n\t\ta_z = b;\n\t}\n\t//Fnxny\n\telse if(!ny && n2B && !n2C && n0C && !n0B)\n\t{\n\t\tcell_id = 1.;\n\t\ta_y = PI_2;\n        a_x = a+PI_2;\n\t\ta_z = b;\n\t}\n\t// ---------------------------------------------------------------\n\t//Fpxny\n\telse if(ny && n1B && !n1C && n3C && !n3B)\n\t{\n\t\tcell_id = 2.;\n\t\ta_y = -PI_2;\n\t\ta_x =  a-PI_2;\n\t\ta_z =  b;\n\t}\n\t//Fnxpy\n\telse if(!ny && !n1B && n1C && !n3C && n3B)\n\t{\n\t\tcell_id = 3.;\n\t\ta_y = -PI_2;\n\t\ta_x =  a+PI_2;\n\t\ta_z =  b;\n\t}\n\t// ---------------------------------------------------------------\n\t//Fpypz\n\telse if(!nz && n3C && !n3A && n0A && !n0C)\n\t{\n\t\tcell_id = 4.;\n\t\ta_y =  0.;\n        a_x =  a;\n\t\ta_z =  b;\n\t}\n\t//Fnynz\n\telse if(nz && !n3C && n3A && !n0A && n0C)\n\t{\n\t\tcell_id = 5.;\n\t\ta_y =  0.; \n\t\ta_x =  a+PI;\n\t\ta_z =  b;\n\t}\n\n\t// ---------------------------------------------------------------\n\t//Fpynz\n\telse if(nz && n2C && !n2A && n1A && !n1C)\n\t{\n\t\tcell_id = 6.;\n\t\ta_y =  0.;\n        a_x = -a+PI;\n\t\ta_z = -b;        \n\t}\n\t//Fnypz\n\telse if(!nz && !n2C && n2A && !n1A && n1C)\n\t{\n\t\tcell_id = 7.;\n\t\ta_y =  0.;\n        a_x = -a;\n\t\ta_z = -b;       \n\t}\n\t// ---------------------------------------------------------------\n\t//Fpzpx\n\telse if(!nx && n1A && !n1B && n0B && !n0A)\n\t{\n\t\tcell_id = 8.;\n\t\ta_y =  a-PI_2;\n\t\ta_x =  0.;\n\t\ta_z =  0.;\n\t}\n\t//Fnznx\n\telse if( nx && !n1A && n1B && !n0B && n0A)\n\t{\n\t\tcell_id = 9.;\n\t\ta_y =  a+PI_2;\n\t\ta_x =  0.;\n\t\ta_z =  0.;\n\t}\n\t// ---------------------------------------------------------------\n\t//Fpznx\n\telse if(nx && n3A && !n3B && n2B && !n2A)\n\t{\n\t\tcell_id = 10.;\n\t\ta_y = -a+PI_2;\n\t\ta_x =  0.;\n\t\ta_z =  b+PI_2;\n\t}\n\t//Fnzpx\n\telse if(!nx && !n3A && n3B && !n2B && n2A )\n\t{\n\t\tcell_id = 11.;\n\t\ta_y = -a+PI_2;\n\t\ta_x =  PI;\n\t\ta_z =  b-PI_2;\n\t}\n\t// ---------------------------------------------------------------\n\t// cell orientation\n\tvec2 ei_y = vec2(cos(a_y),sin(a_y)); p.zx = cmul(p.zx,ei_y); // rotate around y-axis\n\tvec2 ei_x = vec2(cos(a_x),sin(a_x)); p.yz = cmul(p.yz,ei_x); // rotate around x-axis\n\tvec2 ei_z = vec2(cos(a_z),sin(a_z)); p.xy = cmul(p.xy,ei_z); // rotate around z-axis\n\t// non cyclic\n\tsr = 5.;\n    return p;\n}\n\n// distribution\nfloat sig(float x) {\n    return x < 0. ? -1. : +1.;\n}\n\nfloat dist(float x, float e) {\n    // e in [0., +inf]\n    return sign(x)*abs( pow(abs(x), abs(e)) );\n}\n   \nvec2 r_poly_dist(vec2 z, vec2 e, float sh_a) {   \n    /// r-polygon-distribution\n    float r = length(z); z = (r<0.)? vec2(0) : z/r; \n    float d0 = 0.5 *abs(e.y-e.x);\n    float e2 = e.x + d0 + d0 * (2.*smoothstep(-1., 1., -sh_a) - 1.);\n    return dist(r, e2) * z;\n}   \n\n// stereographic projection\nvec3 sp(vec3 zsr){\n    vec2 z = zsr.xy; float sr = zsr.z;\n    // stereopraphic projection (complex plane to unit sphere)\n    float zz = dot(z,z); vec3 pn;\n    if (bool(sig(sr))) {// north pole\n        pn = vec3(2. * z.x,  2. * z.y, -1. + zz);\n        }\n    else { // south pol\n        z = cinv(z);\n        pn = vec3(2. * z.x, -2. * z.y,  1. - zz);\n        }\n    pn /= 1.+zz;\n    return pn;\n}\n\n// bb\nvec2 isphere(in vec3 ro, in vec3 rd, in float r) {\n\tfloat b = dot(ro,rd);\n\tfloat c = dot(ro,ro) - r*r;\n    float h = b*b - c;   \n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return -b + vec2(-h,h);\n}\n\n// sdf\nfloat opIntersection( float d1, float d2 ) {\n    return max(d1,d2); }\n\nfloat opSmoothUnion( in float d1, in float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdSphere( vec3 p, float s ) {\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCylinder( vec3 p, float r ) {\n  return length(p.xz)-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// color\nvec3 h2rgb(float h) {\n    vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n}\n\n// srgb <--> rgb (linear)\nvec3 rgb2srgb(vec3 col) {\n    return pow(col, vec3(1./2.2));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}