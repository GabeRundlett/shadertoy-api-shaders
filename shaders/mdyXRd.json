{
    "Shader": {
        "info": {
            "date": "1681449282",
            "description": "click, hold and move mouse to rotate.",
            "flags": 32,
            "hasliked": 0,
            "id": "mdyXRd",
            "likes": 2,
            "name": "saddinger_projected",
            "published": 3,
            "tags": [
                "fractal",
                "simple"
            ],
            "usePreview": 0,
            "username": "graygoose",
            "viewed": 95
        },
        "renderpass": [
            {
                "code": "// Fork of \"newtons_fract_simple\" by graygoose. https://shadertoy.com/view/sdKBDw\n// 2023-04-14 05:14:18\n\n#define PI 3.14159265359\n#define TAU 6.283185307179586\n#define MAX_ITERS 300.\n#define SPHERE_EPS .00000005\n\nvec3 sphereMapping(vec3 dir) {\n  float t_off = 0.01*cos(iTime*0.15);\n  vec2 uv = vec2(atan(dir.z, dir.x-t_off), asin(dir.y));\n  uv /= TAU;\n  uv += .5;\n  \n  float t = iTime * 0.1;\n  vec2 c = vec2(-cos(t) * cos(t), sin(t) * cos(t));\n\n  vec2 z = vec2(0.0, 0.0);\n  float iter;\n  for (iter=0.; iter < MAX_ITERS; iter++) {\n    vec2 newZ = dot(z, z) + c;\n    if (dot(newZ, newZ) > 4.0) break;\n    z = newZ;\n  }\n\n  float displacement = iter / float(MAX_ITERS);\n  vec3 normal = normalize(dir);\n  vec3 perturbation = displacement * normal;\n  \n  float maxDisplacement = .01 * length(normal);\n  perturbation *= min(0.0, maxDisplacement / length(perturbation));\n  \n  return texture(iChannel0, uv).rgb + perturbation;\n}\n\nvoid mainImage(out vec4 O, in vec2 U) {\n  vec2 z = ( 2.0 * U - iResolution.xy ) / iResolution.y;\n  \n  float t = iTime * 0.5;\n  \n  vec3 rayDir = normalize(vec3(z, -1.0));\n  vec3 rayPos = vec3(0.0, 0.0, 1.25);\n  \n\n  float dist = 0.0;\n  vec3 color = vec3(0.0);\n  for (int i = 0; i < 100; i++) {\n    vec3 pos = rayPos + dist * rayDir;\n    vec3 normal = normalize(pos);\n    float d = length(pos) - 1.0 + 0.2 * length(sphereMapping(normal));    \n    if (d < SPHERE_EPS) {\n      color = sphereMapping(normal);\n    }\n    dist += d;\n    if (dist > 10.0) break;\n  }\n\n  O = vec4(5.*color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// physics constants\n#define K .1\n\n// shadertoy common\n#define R iResolution.xy\n#define UV (U / R)\n#define A(U) texture(iChannel0, UV)\n#define B(U) texture(iChannel1, UV)\n#define C(U) texture(iChannel2, UV)\n#define D(U) texture(iChannel3, UV)\n\n// math\nvec2 wrap(in vec2 p, in vec2 res) {\n    vec2 wrapped = mod(p, res);\n    wrapped += step(wrapped, vec2(0.0)) * res;\n    return wrapped;\n}\n\n\n\nvec4 lap(in sampler2D c, in vec2 p, in vec2 r) {\n    vec4 sum = vec4(0.0);\n\n    sum += texelFetch(c, ivec2(wrap(p + vec2(0, -1), r)), 0);\n    sum += texelFetch(c, ivec2(wrap(p + vec2(-1, 0), r)), 0);\n    sum -= 4.0 * texelFetch(c, ivec2(wrap(p + vec2(0, 0), r)), 0);\n    sum += texelFetch(c, ivec2(wrap(p + vec2(1, 0), r)), 0);\n    sum += texelFetch(c, ivec2(wrap(p + vec2(0, 1), r)), 0);\n\n    return sum;\n}\n\nvec2 sob(in sampler2D tex, in vec2 uv, in vec2 resolution) {\n    mat3 kernelX = mat3(-1, 0, 1, -2, 0, 2, -1, 0, 1);\n    mat3 kernelY = mat3(-1, -2, -1, 0, 0, 0, 1, 2, 1);\n    float stepX = 1.0 / resolution.x;\n    float stepY = 1.0 / resolution.y;\n    mat3 sampleX, sampleY;\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            vec2 offset = vec2(float(i - 1) * stepX, float(j - 1) * stepY);\n            vec2 s = texture(tex, uv + offset).xy;\n            sampleX[i][j] = s.x;\n            sampleY[i][j] = s.y;\n        }\n    }\n    vec2 gradient;\n    gradient.x = dot(sampleX[0], kernelX[0]) + dot(sampleX[1], kernelX[1]) + dot(sampleX[2], kernelX[2]);\n    gradient.y = dot(sampleY[0], kernelY[0]) + dot(sampleY[1], kernelY[1]) + dot(sampleY[2], kernelY[2]);\n    return normalize(gradient);\n}\n#define NROOTS 3\nvec2 roots[NROOTS];\n\n#define SCALE(v, mx, a, b) (a + (v * (b - a) / mx))\nvec2 scale(vec2 mn, vec2 mx, mat2 bounds) {\n    return vec2(SCALE(mn.x, mx.x, bounds[0][0], bounds[0][1]),\n                SCALE(mn.y, mx.y, bounds[1][0], bounds[1][1]));\n}\n\nvec3 hueShift(vec3 color, float hue) {\n    const vec3 k = vec3(0.57735, 0.57735, 0.57735);\n    float cosAngle = cos(hue);\n    return vec3(color * cosAngle + cross(k, color) * sin(hue) + k * dot(k, color) * (1.0 - cosAngle));\n}\n\n    // screen\n\n\n// math\n    //Generic 3x3 filter - vec3(center, edges, diagonals)\n#define GAUSSIAN vec3(.204, .124, .075)\n#define LAPLACIAN vec3(-1., .2, .05)\nvec4 filter3x3(in vec2 pos, in vec3 kernel, in sampler2D channel, in vec2 reso) {\n    vec4 sum = vec4(0.);\n    \n    for(int i=-1; i<=1; i++) {\n        for(int j=-1; j<=1; j++) {\n            float weight = (i==0 && j==0) ? kernel[0] : (abs(i-j) == 1 ? kernel[1] : kernel[2]);\n            \n            sum += weight * texelFetch(channel, ivec2(wrap(pos + vec2(i, j), reso)), 0);\n        }\n    }\n    \n    return sum;\n}\n\n\n    // Sobel\n#define SOBEL_EDGE_COLOR vec4(0.753,0.380,0.796,1.)\nvec4 sobel(in vec2 pos, in sampler2D channel, in vec2 reso) {\n    // \n    mat3 SX = mat3( 1.0,  2.0,  1.0, \n                    0.0,  0.0,  0.0, \n                   -1.0, -2.0, -1.0);\n    mat3 SY = mat3(1.0, 0.0, -1.0, \n                   2.0, 0.0, -2.0, \n                   1.0, 0.0, -1.0);\n\n    vec4 T = texelFetch(channel, ivec2(pos), 0);\n\n    mat3 M = mat3(0.);\n    for(int i=0; i<3; i++) {\n        for(int j=0; j<3; j++) {\n            vec4 A = texelFetch(channel, ivec2(pos + vec2(i-1, j-1)), 0);\n            M[i][j] = length(A);\n        }\n    }\n    \n    float gx = dot(SX[0], M[0]) + dot(SX[1], M[1]) + dot(SX[2], M[2]);\n    float gy = dot(SY[0], M[0]) + dot(SY[1], M[1]) + dot(SY[2], M[2]);\n    \n    \n    // TODO factor into float sobel() and move this to a buffer pass.\n    float g = sqrt(gx*gx + gy*gy);\n    g = smoothstep(0.15, 0.98, g);\n\n    return mix(T, SOBEL_EDGE_COLOR, g);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage(out vec4 Q, in vec2 U) {\n    vec4 wave = texture(iChannel0, U / R.xy);\n    vec2 waveReal = vec2(wave.x, wave.y);\n    vec2 waveImag = vec2(wave.z, wave.w);\n\n    if (iFrame < 1) {\n        wave = vec4(0.);\n        wave.zw = vec2(0.5);\n        wave.xy = vec2(0.5 * cos(0.1 * length(U - 0.5 * R.xy)), 0.5 * sin(0.1 * length(U - 0.5 * R.xy)));\n    }\n\n\n    vec4 L = lap(iChannel0, U, R) - wave;\n\n    vec4 dwave = vec4(\n        (wave.z + L.x),\n        (wave.x + L.y),\n        (wave.y + L.z),\n        (wave.w + L.w)\n     );\n    wave -= K * normalize(dwave);\n\n\n\n    // Normalize wave\n    float mag = length(wave);\n    wave /= mag;\n\n    // Update buffer\n    Q = normalize(wave) * .5;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 C0 = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    vec4 C1 = texelFetch(iChannel1, ivec2(fragCoord.xy), 0);\n    vec4 L0 = filter3x3(fragCoord.xy, LAPLACIAN, iChannel0, iResolution.xy);\n    vec4 G1 = filter3x3(fragCoord.xy, GAUSSIAN, iChannel1, iResolution.xy);\n    vec4 G0 = filter3x3(fragCoord.xy, GAUSSIAN, iChannel0, iResolution.xy);\n\n    fragColor = C0 + G1 * G1;\n    fragColor *= -L0;\n\n    fragColor -= 0.1* .45*(C0+G0) + .34*(G1+C1); \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}