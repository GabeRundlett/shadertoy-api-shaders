{
    "Shader": {
        "info": {
            "date": "1496430115",
            "description": "use mouse for moving light of add point see the define in code",
            "flags": 0,
            "hasliked": 0,
            "id": "4slBDM",
            "likes": 6,
            "name": "Gem Rendering Attempt",
            "published": 3,
            "tags": [
                "rendering",
                "gem",
                "attempt"
            ],
            "usePreview": 0,
            "username": "aiekick",
            "viewed": 572
        },
        "renderpass": [
            {
                "code": "// Created by Stephane Cuillerdier - Aiekick/2017 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\n//#define ADD_POINT_WITH_MOUSE\n#define USE_SIMPLE_POLY_DF\n\n#define count 6\n#define thick 0.18\n#define zoom 1.\n\nint n;\n\n// array of points\nvec2 arr[count + 1]; // count + 1 is for the adding of the mouse point if needed at line 67\n\t\n\nvec4 col;\n\n// from Distance Field from Points Array => https://www.shadertoy.com/view/MsjyWR\n// compute the df from a points array\nfloat computeDf(in vec2 vUV, in vec2 vArr[count + 1], in int vCount, in float vDFThick)\n{\n\tfloat d = 1e3;\n\tfor (int i = 0; i < vCount;  i++)\n\t{\n        // p = current point\n        // lp = last point\n        vec2 p = vArr[i], lp = p, np = p;\n        \n        // circular\n\t\tif (i==0) lp = vArr[vCount-1]; else lp = vArr[i-1];\n\t\t\n        // 2d line df\n        vec2 a = vUV - lp;\n\t\tvec2 b = p - lp;\n\t\tfloat h = clamp(dot(a,b)/dot(b,b),0.,1.);\n\t\tfloat c = length(a-b*h) + vDFThick;\n\t\t\t\n       \t// df min\n\t\td = min(d, c);\n\n        // facultative : display the current point just for the demo\n\t\tcol += .0001/dot(vUV-p,vUV-p);\n\t}\n    \n    return d;\n}\n\n// compute the df\nfloat computeDf(in vec2 p, float side)\n{\n\t//return 0.5 - smoothstep(0.,1.,length(p));\n\tfloat a = atan(p.x,p.y)+3.14159;\n\tfloat b = 6.2831 / side;\n\tfloat d = cos(floor(.5 + a / b)*b - a)*(length(p)+0.);\n\treturn 0.5 - smoothstep(0.,1.,d);\n}\n       \nfloat map(vec3 p)\n{\n\tfloat d;\n#ifdef USE_SIMPLE_POLY_DF\n    d = computeDf(p.xy, float(count));\n#else\n    d = computeDf(p.xy, arr, n, thick);\n    d = 0.5 - smoothstep(0.,1.,d);\n#endif\n    d = smoothstep(0., fwidth(d)*4., d)*d;\n\treturn d;\n}\n\nvec3 nor( vec3 p, float prec )\n{\n    vec2 e = vec2( prec, 0. );\n    vec3 n = vec3(\n\t\tmap(p+e.xyy) - map(p-e.xyy),\n\t\tmap(p+e.yxy) - map(p-e.yxy),\n\t\tmap(p+e.yyx) - map(p-e.yyx) );\n    return normalize(n);\n}\n\nvec3 shade(vec3 ro, vec3 rd, float d, vec3 lp, vec3 lc, float li, vec2 texUV)\n{\n\tvec3 p = ro + rd * d;\n\tvec3 vd = p-lp;\n\tfloat len = length(vd);\n\tvec3 ld = vd/len;\n\tvec3 n = nor(p, 0.01);\n\tvec3 refl = reflect(rd,n);\n\tvec3 refr = refract(rd, n, 0.999);\n\tvec3 tex = texture(iChannel0, (texUV + refr.xy)).rgb;\n\tfloat diff = clamp( dot( n, ld ), 0.0, 1.0 );\n\tfloat fre = pow( clamp( 2. + dot(n,rd),0.0,1.0), 4. );\n\tfloat spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),16.);\n\tfloat sss = sqrt(map(p - n*0.005)/0.03)*0.5;\t\n\treturn clamp(mix((diff * 2. * sss + fre * 0. + spe * 1.2 * sss) * lc * li, tex, 0.3),0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    n = count;\n    \n    // generate a basic polygon arrangement\n    float radius = .5;\n\tfor (int i = 0; i < n;  i++)\n\t{\n\t\tfloat a = float(i) / float (n) * 3.14159 * 2.;\n\t\tarr[i] = radius * vec2(cos(a), sin(a)); \n\t}\n    \n#ifdef ADD_POINT_WITH_MOUSE\n    // if mouse out of the dead zone, add point controled by user\n\tif (iMouse.x > 50.)\n\t{\n\t\tvec2 p = (iMouse.xy *2. - iResolution.xy)/iResolution.y*zoom;\n\t\tarr[n] = p;\n\t\tn ++;\n\t}\n#endif\n    \n\tcol = vec4(0);\n\t\n    vec2 uv = (fragCoord.xy *2. - iResolution.xy)/iResolution.y*zoom;\n\t    \n    vec3 ro = vec3(uv, 5);\n\tvec3 rd = normalize(vec3(0,0,-1));\n\t\n\tfloat d = ro.z - map(uv.xyy);\n\t\n\tvec3 bg = texture(iChannel0, uv + iTime * 0.3).rgb;\n\t\t\n\tif (d < ro.z)\n\t{\t\t\n\t\tvec3 lp = vec3((iMouse.xy *2. - iResolution.xy)/iResolution.y*zoom, ro.z);\n\t\tvec3 lc = vec3(0.45,0.59,0.94);\n\t\tfloat li = 0.63;\n\t\tcol = shade(ro, rd, d, lp, lc, li, uv + iTime * 0.3).rgbb;\n\t\t\n\t\tfragColor = col;\n\t}\n\telse\n\t{\n\t\tfragColor.rgb = bg;\n\t}\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}