{
    "Shader": {
        "info": {
            "date": "1685999611",
            "description": "A 3D auto-VJ in a split circle theme, interacting with music.\n\n - Use with music in iChannel0 -",
            "flags": 64,
            "hasliked": 0,
            "id": "ctKXRm",
            "likes": 2,
            "name": "Radioaktiv",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "music"
            ],
            "usePreview": 1,
            "username": "QuantumSuper",
            "viewed": 225
        },
        "renderpass": [
            {
                "code": "// Radioaktiv 0.4.230605 by QuantumSuper\n// 3d raymarched auto-vj with split ring objects\n// \n// - use with music in iChannel0 -\n\n#define PI 3.14159265359 \n#define aTime 2.133333*iTime\n#define MAX_STEP 70\n#define MAX_DIST 80.\n#define MIN_DIST 0.02\n#define AA 1. \n\nstruct object{\n\tint type; //2: splitRing, redundant in this code\n    vec3 pos; //position\n\tvec4 param; //splitRing(outerRadius, width, depth, gapWidth)\n};\nobject[4] objects; //geometry definitions\nvec4 fft, ffts; //compressed frequency amplitudes\nint hitId; //hit object id\nvec2 myFC;\n\nvoid compressFft(){ //v1.2, compress sound in iChannel0 to simplified amplitude estimations by frequency-range\n    fft = vec4(0), ffts = vec4(0);\n\n\t// Sound (assume sound texture with 44.1kHz in 512 texels, cf. https://www.shadertoy.com/view/Xds3Rr)\n    for (int n=0;n<3;n++) fft.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //bass, 0-517Hz, reduced to 0-258Hz\n    for (int n=6;n<8;n++) ffts.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech I, 517-689Hz\n    for (int n=8;n<14;n+=2) ffts.y  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech II, 689-1206Hz\n    for (int n=14;n<24;n+=4) ffts.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech III, 1206-2067Hz\n    for (int n=24;n<95;n+=10) fft.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //presence, 2067-8183Hz, tenth sample\n    for (int n=95;n<512;n+=100) fft.w  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //brilliance, 8183-44100Hz, tenth2 sample\n    fft.y = dot(ffts.xyz,vec3(1)); //speech I-III, 517-2067Hz\n    ffts.w = dot(fft.xyzw,vec4(1)); //overall loudness\n    fft /= vec4(3,8,8,5); ffts /= vec4(2,3,3,23); //normalize\n\t//for (int n=0;n++<4;) fft[n] *= 1. + .3*pow(fft[n],5.); fft = clamp(fft,.0,1.); //limiter? workaround attempt for VirtualDJ\n}\n\n// 2D Functions\nmat2 rotM2(float a){float c = cos(a), s = sin(a); return mat2(c,s,-s,c);} //2d rotation matrix\n\nfloat sdEquilateralTriangle(vec2 p){ //source: https://iquilezles.org/articles/distfunctions2d/\n    const float k = sqrt(3.);\n    p.x = abs(p.x) - 1.;\n    p.y = p.y + 1./k;\n    if (p.x+k*p.y > 0.) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n    p.x -= clamp( p.x, -2., 0.);\n    return -length(p)*sign(p.y);\n}\n\nfloat sd2dRing( vec2 p, float r, float w){ //ring with width w\n    r = length(p)-r; //=sdCircle\n    return max( r, min(r+w,0.));\n}\n\nfloat opExtrusion( float z, float sdf2d, float h){ //source: https://iquilezles.org/articles/distfunctions/\n    vec2 w = vec2( sdf2d, abs(z) - h);\n  \treturn min( max(w.x,w.y), 0.) + length(max(w,0.));\n}\n\n// 3D Functions\nmat3 rotMZ(float rad){ //rotation about z-axis\n    float c = cos(rad), s = sin(rad);\n    return mat3(c,s,0,-s,c,0,0,0,1);\n}\n\nfloat sdBox( vec3 p, vec3 d){ //source: https://iquilezles.org/articles/distfunctions/\n  p = abs(p) - d;\n  return length(max(p,0.)) + min(max(p.x,max(p.y,p.z)),0.);\n}\n\nfloat sd3dRing( vec3 p, vec3 d){\n    return opExtrusion( p.z, abs(sd2dRing( p.xy, d.x, d.y)), d.z);\n}\n\nfloat sdSplitRing( vec3 p, vec4 d){\n    float base = sd3dRing( p, d.xyz);\n    if (p.y<0.5) p.xy *= rotM2(sign(p.x)*4./3.*PI); //hack to save boxes, only works to some extend\n    float eraser = sdBox( p-vec3(0,d.x,0), d.wxz) - 2.*MIN_DIST;    \n    //DEBreturn min(base,eraser);\n    return max( base, -eraser);    \n}\n\n// Raymarch Functions\nfloat getDistance(vec3 p){\t\n\tfloat myDist, minDist = MAX_DIST; //max minDist\n\t\n\tfor (int n=0; n<objects.length(); n++){ //get the distance to each object\t\n        myDist = (n<3)?\n            sdSplitRing( p*rotMZ(objects[n].pos.z/16.-aTime/8.+.4*fft.x) - objects[n].pos, objects[n].param): //center rings\n            sdSplitRing( p - objects[n].pos, objects[n].param * vec4(1,1,1,1.-fft.w*texture(iChannel0,vec2(fract(.1*p.z-.2),0),0.).x)); //outer ring\n        if (myDist < minDist) minDist = myDist, hitId = n;\n    }\n    \n\treturn minDist;\n}\n\nfloat rayMarch( vec3 rayOrigin, vec3 rayDirection){ //cf. The Art of Code's ray marching tutorial: youtu.be/PGtv-dBi2wE\n\tfloat rayLength = MIN_DIST; \n\tfloat radSphere;\n\t\n\tfor (int n=0; n<MAX_STEP; n++){\n\t\tradSphere = getDistance(rayOrigin+rayLength*rayDirection); //get sphere\n\t\trayLength += radSphere; //march\n\t\tif (rayLength>MAX_DIST || abs(radSphere)<MIN_DIST) break;\n\t}\n\t\n\treturn rayLength;\n}\n\nvec3 guessNormal(vec3 pos){ //estimate the surface normal at pos\n\tvec2 tangent = vec2(.01*MIN_DIST, 0); //sensitive!\n\t\n\tvec3 normal = getDistance(pos) - vec3(\n\t\tgetDistance(pos-tangent.xyy),\n\t\tgetDistance(pos-tangent.yxy), \n\t\tgetDistance(pos-tangent.yyx)\n\t\t);\n\t\t\n\treturn normalize(normal);\n}\n\nfloat calcAO( vec3 pos, vec3 nor){ //see iq: https://www.shadertoy.com/view/lsKcDD\n\tfloat occ = 0.;\n    float sca = 1.;\n    \n    for (int i=0;i<5;i++){\n        float h = .001 + .15*float(i)/4.;\n        float d = getDistance( pos+h*nor);\n        occ += (h-d)*sca;\n        sca *= .95;\n    }\n    \n    return clamp( 1.-1.5*occ, 0., 1.);    \n}\n\nfloat softShadow( vec3 ro, vec3 rd, float mint, float maxt, float w){ //source: https://iquilezles.org/articles/rmshadows/\n    float res = 1.;\n    float t = mint;\n    \n    for (int i=0;i<256 && t<maxt;i++){\n        float h = getDistance(ro + t*rd);\n        res = min( res, h/(w*t));\n        t += clamp( h, .005, .5);\n        if (res<-1. || t>maxt) break;\n    }\n    res = max(res,-1.);\n    \n    return .25*(1.+res)*(1.+res)*(2.-res);\n}\n\nvec3 render( vec3 pos, vec3 dir){\n    // Light initialization\n    vec3 lightPos = vec3(0,0,10);\n    vec3 lightCol = .5*vec3(sin(aTime*1.123),sin(aTime*1.234),sin(aTime*1.345)) + .5 + 0.*step(.9,fft.x);\n    lightCol = abs( cos( .06*iTime + PI/vec3(.5,2.,4.) + ffts.xyz)) + .1*step(.9,fft.x); //color shift \n    \n    // Depth calculation\n    float rayDist = rayMarch(pos,dir); \n    vec3 rayPos = pos+rayDist*dir;   \n    vec3 lightDir = normalize( lightPos-rayPos);    \n    \n    // Light modifications\n    vec3 rgbCol = vec3(ffts.y<=ffts.z,ffts.z<=ffts.x,ffts.x<=ffts.z);\n    float ringRho =  atan(rayPos.y,rayPos.x) - (objects[hitId].pos.z/16.-aTime/8.+fft.x*.4) + PI/2.;\n    lightCol *= .8+.2*texelFetch( iChannel1, ivec2(mod(1000.*(rayPos.xy+rayPos.z+iTime),256.)), 0).x; //simple noise\n    if (hitId<3) lightCol *= (cos(ringRho)>.5)? //target different segments of ring\n            .2+8.*smoothstep(.6,.9,texelFetch( iChannel0, ivec2( 0, 0), 0).x):\n        (sin(ringRho)<0.)? \n            .2+4.*smoothstep(.6,.9,texelFetch( iChannel0, ivec2( 1, 0), 0).x+texelFetch( iChannel0, ivec2( 2, 0), 0).x):\n            .2+2.*smoothstep(.6,.9,texelFetch( iChannel0, ivec2( 3, 0), 0).x+texelFetch( iChannel0, ivec2( 4, 0), 0).x+texelFetch( iChannel0, ivec2( 5, 0), 0).x);\n    if (hitId==3) lightCol *= .08; //dim outer ring\n    if (hitId==3 && length(rayPos.xy)<2.3) lightCol += .5 * rgbCol * pow(texture( iChannel0, vec2(fract(rayPos.z*.1-.2),0), 0.).x,6.); //sound texture light   \n    \n    // Shadows\n    vec3 surfNormal = guessNormal(rayPos);\n    float amp = clamp( dot(lightDir, surfNormal), 0., 1.) * softShadow( rayPos, lightDir, MIN_DIST, MAX_DIST, .5); \n    vec3 col = lightCol * amp;\n    \n    // Light speck\n    vec3  halo = normalize( lightDir-dir );\n    float speck = (.1+.9*pow( clamp( dot(surfNormal,halo),0.,1.), 16.)) * amp * (.04+.96*pow( clamp(1.0+dot(halo,dir),0.,1.), 5.));  \n    col+= lightCol * speck;\n    \n    // Ambient light\n    amp = clamp( .5+.5*surfNormal.y, 0., 1.) * calcAO( rayPos, surfNormal);\n    col += lightCol * amp * (.04+.01*rgbCol);\n        \n    // Fog\n    col *= exp(-1e-4*rayDist*rayDist*rayDist); //simple distance based attenuation\n    \n    // Background\n    if (rayDist>=MAX_DIST) col = .2 * fft.z \n        * abs(cos(.06*iTime + PI/vec3(.5,2.,4.) + ffts.xyz)) //base color shift\n        * clamp(abs(myFC.y/iResolution.y-.7*fft.xyz),0.,1.) //vertical color shift\n        * (2.-3.*length(myFC/iResolution.xy-.5)) //simple vignette\n        * (.3-(texelFetch(iChannel0,ivec2(int(1024.*abs(myFC.x/iResolution.x-.5)),0),0).x - 2.*abs(myFC.y/iResolution.y-.5))); //inverted xy-mirror sound texture\n    \n    // Utility\n    //col = .06*vec3(rayPos); //depth map\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    compressFft(); //initializes fft, ffts\n    myFC = fragCoord;\n    \n    // Camera initialization\n    vec2 uv = (2.*fragCoord-iResolution.xy) / max(iResolution.x, iResolution.y); //long edge -1 to 1\n    vec3 camPos = vec3(.8*cos(aTime/8.),0,0);\n    vec3 camDir = normalize(vec3(uv.x, uv.y, 1)); //static straight\n\t\n\t// Object initializations\n    float ringDist = 16.,\n          ringSpeed = -.3 * (fft.x + aTime);\n    vec4 ringDef = vec4(2.,.8,.3,.4);\n    objects = object[](\n\t\tobject(2, vec3(0,0,ringDist*(0.+fract(ringSpeed))-.2), ringDef), // ring 1\n        object(2, vec3(0,0,ringDist*(1.+fract(ringSpeed))-.2), ringDef), // ring 2\n        object(2, vec3(0,0,ringDist*(2.+fract(ringSpeed))-.2), ringDef), // ring 3\n        object(2, vec3(0,0,1.5-4.5*cos(aTime/8.-ffts.w+1.)), vec4(16.,13.7,6.,1.)) // ring outer 1\n        );\n    \n    // Render\n    vec3 col = vec3(0); \n    for(float m=0.;m<AA;m++) //simple antialiasing (for AA>=2.)\n        for(float n=0.;n<AA;n++)\n            col += render(camPos+vec3(m,n,.0)*length(camPos.xy)/iResolution.x,camDir); //sloppy pixel estimation     \n    col /= AA*AA;\n    \n    // Finalizations\n\tcol = pow(col, vec3(.4545)); //gamma correction\n    fragColor = vec4(col,1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 33544,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/ms-kd/narcisstic-people"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}