{
    "Shader": {
        "info": {
            "date": "1602351449",
            "description": "A shader drawing for inktober 2020 day8.\nMouse is enabled.\n#inktober2020day8",
            "flags": 32,
            "hasliked": 0,
            "id": "WdycRh",
            "likes": 18,
            "name": "[inktober20] A Night of a Tooth.",
            "published": 3,
            "tags": [
                "comic",
                "teeth",
                "inktober2020"
            ],
            "usePreview": 1,
            "username": "iY0Yi",
            "viewed": 549
        },
        "renderpass": [
            {
                "code": "/////////////////////////////////////////////////////////////////////////////////////////////\n//  .--.          _       .-.   .-.          .--.           .-----.          .-. .-.       //\n// : .; :        :_;      : :  .' `.        : .-'           `-. .-'         .' `.: :       //\n// :    :  ,-.,-..-. .--. : `-.`. .'   .--. : `;    .--.      : : .--.  .--.`. .': `-.     //\n// : :: :  : ,. :: :' .; :: .. :: :   ' .; :: :    ' .; ;     : :' .; :' .; :: : : .. : _  //\n// :_;:_;  :_;:_;:_;`._. ;:_;:_;:_;   `.__.':_;    `.__,_;    :_;`.__.'`.__.':_; :_;:_;:_; //\n//                   .-. :                                                                 //\n//                   `._.'                                                                 //\n//                                                                                         //\n//  \"A Night of a Tooth.\" by iY0Yi                                                         //\n//  https://www.shadertoy.com/view/WdycRh                                                  //\n//                                                                                         //\n//  Created by Atsushi Hashimoto 2020                                                      //\n//  License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.    //\n//                                                                                         //\n/////////////////////////////////////////////////////////////////////////////////////////////\n\n// Effect pass\n\n//#define DEBUG_PASSES\n\n// https://www.shadertoy.com/view/3ssSz2\nfloat originalSigmoidContrast(float color, float contrast, float mid)\n{\n    contrast = contrast < 1.0 ? 0.5 + contrast * 0.5 : contrast;\n    float scale_l = 1.0 / mid;\n    float scale_h = 1.0 / (1.0 - mid);\n    float lower = mid * pow(scale_l * color, contrast);\n    float upper = 1.0 - (1.0 - mid) * pow(scale_h - scale_h * color, contrast);\n    return color < mid ? lower : upper;\n}\n\n// Read data from BufA\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 readNormal(vec2 uv)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(uv), 0);\n    return unpack(data.y);\n}\n\nvec3 readAlbedo(vec2 uv)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(uv), 0);\n    return unpack4(data.x).xyz;\n}\n\nfloat readShadow(vec2 uv)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(uv), 0);\n    return unpack4(data.x).w;\n}\n\nfloat readDepth(vec2 uv)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(uv), 0);\n    return data.w;\n}\n\nfloat readDiffuse(vec2 uv)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(uv), 0);\n    vec3 spec_diffuse_ao = unpack(data.z)*.5+.5;\n    return spec_diffuse_ao.y;\n}\n\nfloat readSpecular(vec2 uv)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(uv), 0);\n    vec3 spec_diffuse_ao = unpack(data.z)*.5+.5;\n    return spec_diffuse_ao.x;\n}\n\nfloat readAO(vec2 uv)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(uv), 0);\n    vec3 spec_diffuse_ao = unpack(data.z);\n    return spec_diffuse_ao.z;\n}\n\nvec3 readSharpenNormal(in vec2 fragCoord, float strength)\n{\n    vec3 res =\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1,-1)), 0).x).xyz*2.-1.) *  -1. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0,-1)), 0).x).xyz*2.-1.) *  -1. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1,-1)), 0).x).xyz*2.-1.) *  -1. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1, 0)), 0).x).xyz*2.-1.) *  -1. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0, 0)), 0).x).xyz*2.-1.) *   9. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1, 0)), 0).x).xyz*2.-1.) *  -1. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1, 1)), 0).x).xyz*2.-1.) *  -1. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0, 1)), 0).x).xyz*2.-1.) *  -1. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1, 1)), 0).x).xyz*2.-1.) *  -1.\n    ;\n    return mix((unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(0, 0)), 0).y).xyz), res , strength);\n}\n\nfloat readSharpenSpecular(in vec2 fragCoord, float strength)\n{\n    float res =\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1,-1)), 0).z)*.5+.5).x *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0,-1)), 0).z)*.5+.5).x *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1,-1)), 0).z)*.5+.5).x *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1, 0)), 0).z)*.5+.5).x *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0, 0)), 0).z)*.5+.5).x *   9. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1, 0)), 0).z)*.5+.5).x *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1, 1)), 0).z)*.5+.5).x *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0, 1)), 0).z)*.5+.5).x *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1, 1)), 0).z)*.5+.5).x *  -1.\n    ;\n    return mix((unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(0, 0)), 0).z)*.5+.5).x, res , strength);\n}\n\nfloat readSharpenDiffuse(in vec2 fragCoord, float strength)\n{\n    float res =\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1,-1)), 0).z)*.5+.5).y *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0,-1)), 0).z)*.5+.5).y *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1,-1)), 0).z)*.5+.5).y *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1, 0)), 0).z)*.5+.5).y *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0, 0)), 0).z)*.5+.5).y *   9. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1, 0)), 0).z)*.5+.5).y *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1, 1)), 0).z)*.5+.5).y *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0, 1)), 0).z)*.5+.5).y *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1, 1)), 0).z)*.5+.5).y *  -1.\n    ;\n    return mix((unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(0, 0)), 0).z)*.5+.5).y, res , strength);\n}\n\nfloat readSharpenAO(in vec2 fragCoord, float strength)\n{\n    float res =\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1,-1)), 0).z)*.5+.5).z *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0,-1)), 0).z)*.5+.5).z *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1,-1)), 0).z)*.5+.5).z *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1, 0)), 0).z)*.5+.5).z *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0, 0)), 0).z)*.5+.5).z *   9. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1, 0)), 0).z)*.5+.5).z *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1, 1)), 0).z)*.5+.5).z *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0, 1)), 0).z)*.5+.5).z *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1, 1)), 0).z)*.5+.5).z *  -1.\n    ;\n    return mix((unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(0, 0)), 0).z)*.5+.5).z, res , strength);\n}\n\n\n// NPR effects\n// Maybe, you can better ways for these effects in somewhere else...\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat dithering(float v, vec2 fragCoord)\n{\n    v=pow(v, 4.);\n    vec2 p = fragCoord;\n    p = mod(p.xx + vec2(p.y, -p.y), vec2(.1));\n    float res=0.;\n    vec2 coords = fragCoord;\n\n    float angle = dot(readSharpenNormal(fragCoord, 1.), vec3(0,0,1));\n\n    coords.xy*= mat2(cos(angle*PI+vec4(0,11,33,0)));\n    coords.y *= .75+.25*hash12(p);\n    float rand_ditherVal = fbm(coords*.75, 2);\n    const float paletteDist = 1.15;\n    res=v + (rand_ditherVal - .5) * paletteDist;\n    res=smoothstep(0.1,1.,res);\n    res=saturate(floor(res*6.)/5.);\n\n    return res;\n}\n\nfloat calcEdge(vec3 nlm1, vec3 nlm2)\n{\n    vec2 difN = abs(nlm1.xy - nlm2.xy);\n    return smoothstep(.41, .3, difN.x + difN.y);\n}\nfloat getOutline(vec2 fragCoord)\n{\n    vec2 coord = fragCoord;\n    vec3 offset = vec3(1, -1, 0) * .5;\n    float edge = 1.0;\n    edge *= calcEdge(readNormal(coord+offset.xx), readNormal(coord+offset.yy));\n    edge *= calcEdge(readNormal(coord+offset.xy), readNormal(coord+offset.yx));\n    edge *= calcEdge(readNormal(coord+offset.zy), readNormal(coord+offset.zx));\n    edge *= calcEdge(readNormal(coord+offset.yz), readNormal(coord+offset.xz));\n    return edge;\n}\n\nfloat getShadowEdge( vec2 fragCoord )\n{\n    vec2 coord = fragCoord;\n    float sha = readShadow(coord);\n    sha -= .5;\n    sha = abs(sha);\n    sha = smoothstep(.1,.2,sha);\n    return sha;\n}\n\nfloat getDottedShadow(vec2 fragCoord)\n{\n    vec2 uv = fragCoord;\n    uv *= mat2(cos(.8+vec4(0, 11, 33, 0)));\n    uv = mod(uv*.3, 1.);\n    float res = 0.;\n    float shadow = readShadow(fragCoord);\n    shadow = saturate(1. - shadow*1.+ .01*readAO(fragCoord));\n    res = smoothstep(shadow, shadow+.1, pow(length(uv-.5), 2.));\n    return res;\n}\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nfloat hatching(vec2 fragCoord, float tickness, float angle, float dark, float light, bool centered)\n{\n    vec2 v = fragCoord.xy / iResolution.xy;\n    v.y *= iResolution.y/iResolution.x;\n    vec3 n = readNormal(fragCoord);\n\n    float f = smoothstep(.1, 1., saturate(-n.y)*saturate(-n.x));\n    vec2 Res = iResolution.xy;\n    float na = (1.-n.z)*PI*.0125 + angle;\n    R(v, na);\n    v.y = mod(v.y*Res.y/tickness, 1.*(n.z*.5));\n\n    float shading = readSharpenDiffuse(fragCoord, 2.);\n\n    if(centered)\n    {\n        shading = (shading-.5)*2.;\n        shading = saturate(shading);\n        shading = abs(shading-.5)*2.;\n    }\n    else\n        shading = saturate(shading-.5)*2.;\n\n    shading = shading*.8+.2*readAO(fragCoord);\n    \n    shading = smoothstep(dark, light, pow(shading, 1.8));\n    shading *= 1.35;\n    float face = smoothstep(.5, 1.8, saturate(-n.y)*saturate(-n.x));\n    float line = smoothstep(-.0, shading+.9, 1.-abs(v.y-.5)*2.);\n    line = saturate(line+shading);\n    return line;\n}\n\nfloat getHatching(vec2 fragCoord)\n{\n    if(readDepth(fragCoord)>.9)\n    return 1.;\n\n    float ln = 1.;\n    const float mul = 1.;\n        ln*= pow(hatching(fragCoord, 3.5*mul, -.4, -1.4, 1.4, false), 50.5);\n        ln*= pow(hatching(fragCoord, 3.5*mul, .4, -1.4, 1.4, false), 50.5);\n    return ln;\n}\n\nfloat hatchingSpecular(vec2 fragCoord, float tickness, float angle, float dark, float light, bool centered)\n{\n    vec2 v = fragCoord.xy / iResolution.xy;\n    vec3 n = readNormal(fragCoord);\n    if(length(n)<.1)\n        return -1.;\n    float f = smoothstep(.1, 1., saturate(-n.y)*saturate(-n.x));\n\n    v *= mat2(cos(n.z*PI*.25 + angle + vec4(0, 11, 33, 0)));\n    v.y = mod(v.y*iResolution.y/tickness, 1.);\n    v.y += fbm(fragCoord.yx*.05, 2)*.0005;\n\n    float shading = readSpecular(fragCoord);\n    shading *= readShadow(fragCoord);\n    shading = smoothstep(dark, light, pow(shading, 1.8));\n    if(centered)\n    {\n        shading = (shading-.5)*2.;\n        shading = saturate(shading);\n        shading = abs(shading-.5)*2.;\n    }\n    else\n        shading = saturate(shading-.5)*2.;\n    \n\tshading = originalSigmoidContrast(shading*.98+.03*saturate(fbm(fragCoord*.025, 2)), noise(fragCoord*.02)*noise(fragCoord.yx*.03)*.5, .7);\n    shading = 1.-saturate(shading*.55);\n    float face = smoothstep(.5, 1.8, saturate(-n.y)*saturate(-n.x));\n    float line = smoothstep(-.3, shading+.5, 1.-abs(v.y-.5)*2.);\n    line = saturate(pow(line+shading+face, 5.));\n\n    return line;\n}\n\nfloat getHatchingSpecular(vec2 fragCoord)\n{\n    float ln = 1.;\n        ln*= pow(hatchingSpecular(fragCoord, 3.5, -.4, -1.4, 1.4, false), 50.5);\n        ln*= pow(hatchingSpecular(fragCoord, 3.5, .4, -1.4, 1.4, false), 50.5);\n    return 1.-ln;\n}\n\n// https://www.shadertoy.com/view/MdjBRy\nvec3 saturation( vec3 color, float saturation )\n{\n    vec3 luminance = vec3( 0.3086, 0.6094, 0.0820 );\n    float oneMinusSat = 1.0 - saturation;\n\n    vec3 red = vec3( luminance.x * oneMinusSat );\n    red.r += saturation;\n\n    vec3 green = vec3( luminance.y * oneMinusSat );\n    green.g += saturation;\n\n    vec3 blue = vec3( luminance.z * oneMinusSat );\n    blue.b += saturation;\n\n    return mat3( red, green, blue) * color;\n}\n\nvec3 hue(in vec3 col, in float Shift)\n{\n    vec3 P = vec3(0.55735) * dot(vec3(0.55735), col);\n    vec3 U = col - P;\n    vec3 V = cross(vec3(0.55735), U);    \n    col = U * cos(Shift * 6.2832) + V * sin(Shift * 6.2832) + P;\n    return col;\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n\n    vec3 col = vec3(.8, .77, .7);\n\n    float shading = readDiffuse(fragCoord);\n    shading *= readShadow(fragCoord);\n    shading = shading*.7+.3*readAO(fragCoord);\n    shading = smoothstep(.3, 1., shading);\n\n    float contrast = 8.8;\n    float midpoint = .5;\n    shading = originalSigmoidContrast(shading, contrast, midpoint);\n    shading = saturate(shading);\n\tif(readDepth(fragCoord)>.9)\n        shading = 0.;\n    \n    col+=.05*dithering((smoothstep(.95,1.,shading)), fragCoord);\n    col+=.05*dithering((smoothstep(.97,1.,shading)), fragCoord);\n    col+=.05*dithering((smoothstep(.99,1.,shading)), fragCoord);\n    col*=.65+.25*shading;\n    col+=fbm(fragCoord*.5, 3)*.05;\n    col*= getHatching(fragCoord);\n    \n    col *= getShadowEdge(fragCoord);\n    col *= getDottedShadow(fragCoord);\n    col *= .4 + .6*(readShadow(fragCoord)*.8+.2*readAO(fragCoord));\n\tif(length(col)<.01) col += (1.-getOutline(fragCoord))*.25;\n    else col *= getOutline(fragCoord);\n\n    vec3 albedo = readAlbedo(fragCoord);\n    col*= albedo;\n\n    float spec = readSharpenSpecular(fragCoord, 1.5)*readShadow(fragCoord);\n    if(spec>.01)\n    {\n    \tcol+=dithering(spec, fragCoord);\n    \tcol+=getHatchingSpecular(fragCoord);\n    }\n    col*=.8+.2*pow(1.-smoothstep(.0, 2., readDepth(fragCoord)), 3.);\n\n    col*= dithering(noise(fragCoord*.18+iTime*5.)+noise(fragCoord*.15-iTime*5.)+.8, fragCoord);\n    col+= (1.-dithering((1.-noise(fragCoord*.3+iTime*5.)*noise(fragCoord*.1-iTime*5.))+.8, fragCoord))*.1;\n\n    col *= vec3(.5+.5*smoothstep(.8, .5, readDepth(fragCoord)));\n\n    col = hue(col, s2u(sin(iTime))*.8 + ((distance(readAlbedo(fragCoord),AMB_COL)<.01)?uv.y*.2:length(uv)*.2));\n    uv = (uv*2.-1.);\n    uv.x *= iResolution.x / iResolution.y;\n    col*=dithering(pow(1.4-length(uv)*.5, .2), fragCoord);\n    \n    col = pow(col, vec3(.4545));\n    col+=.05;\n    \n    fragColor = vec4(col, 1.);\n    \n#ifdef DEBUG_PASSES\n    if(iFrame==2)\n    fragColor.xyz = vec3(readDiffuse(fragCoord));\n    if(iFrame==3)\n    fragColor.xyz = vec3(readShadow(fragCoord));\n    if(iFrame==4)\n    fragColor.xyz = vec3(readSharpenSpecular(fragCoord, 1.5));\n    if(iFrame==5)\n    fragColor.xyz = vec3(readDepth(fragCoord));\n    if(iFrame==6)\n    fragColor.xyz = vec3(readAO(fragCoord));\n    if(iFrame==7)\n    fragColor.xyz = readAlbedo(fragCoord);\n    if(iFrame==8)\n    fragColor.xyz = readNormal(fragCoord)*.5+.5;\n    if(iFrame==9)\n    fragColor.xyz = vec3(getOutline(fragCoord));\n    if(iFrame==10)\n    fragColor.xyz = vec3(getShadowEdge(fragCoord));\n    if(iFrame==11)\n    fragColor.xyz = vec3(getDottedShadow(fragCoord));\n    if(iFrame==12)\n    fragColor.xyz = vec3(getHatching(fragCoord));\n    if(iFrame==13)\n    fragColor.xyz = vec3(getHatchingSpecular(fragCoord));\n#endif\n//fragColor.xyz = readNormal(fragCoord)*.5+.5;\n    fragColor.w = 1.;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Common\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define MIN_DIST 0.001\n#define MAX_DIST 10.0\n#define ITERATION 200\n#define MAT_VOID vec3(-1)\n#define AMB_COL vec3(0.25, 0.2, 0.3550)*.5\n#define MAT_TEETH vec3(0.635, 0.700, 0.502)\n#define MAT_FLOOR vec3(0.887, 0.563, 0.4112)\n#define MAT_BLOOD vec3(.6,.255,.35)\n\n\n// General\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define iFrameRate 24\n#define ZERO min(0,iFrame)\n#define PI 3.14159265\n#define HALF_PI 1.5707963267948966\n#define TAU (2.0*PI)\n#define PHI (sqrt(5.0)*0.5 + 0.5)\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n\n\n// Data Paker/Unpacker\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nuint packSnorm3x10(vec3 x) {\n    x = clamp(x,-1., 1.) * 511.;\n    uvec3 sig = uvec3(mix(vec3(0), vec3(1), greaterThanEqual(sign(x),vec3(0))));\n    uvec3 mag = uvec3(abs(x));\n    uvec3 r = sig.xyz << 9 | mag.xyz;\n    return r.x << 22 | r.y << 12 | r.z << 2;\n}\n\nvec3 unpackSnorm3x10(uint x) {\n    uvec3 r = (uvec3(x) >> uvec3(22, 12, 2)) & uvec3(0x3FF);\n    uvec3 sig = r >> 9;\n    uvec3 mag = r & uvec3(0x1FF);\n    vec3 fsig = mix(vec3(-1), vec3(1), greaterThanEqual(sig, uvec3(1)));\n    vec3 fmag = vec3(mag) / 511.;\n    return fsig * fmag;\n}\n\nuint packSnorm4x8(vec4 x) {\n    x = clamp(x,-1.0, 1.0) * 127.0;\n    uvec4 sig = uvec4(mix(vec4(0), vec4(1), greaterThanEqual(sign(x),vec4(0))));\n    uvec4 mag = uvec4(abs(x));\n    uvec4 r = sig << 7 | mag;\n    return r.x << 24 | r.y << 16 | r.z << 8 | r.w;\n}\n\nvec4 unpackSnorm4x8(uint x) {\n    uvec4 r = (uvec4(x) >> uvec4(24, 16, 8, 0)) & uvec4(0xFF);\n    uvec4 sig = r >> 7;\n    uvec4 mag = r & uvec4(0x7F);\n    vec4 fsig = mix(vec4(-1), vec4(1), greaterThanEqual(sig,uvec4(1)));\n    vec4 fmag = vec4(mag) / 127.0;\n    return fsig * fmag;\n}\n#define pack(x) uintBitsToFloat(packSnorm3x10(x))\n#define unpack(x) unpackSnorm3x10(floatBitsToUint(x))\n#define pack4(x) uintBitsToFloat(packSnorm4x8(x))\n#define unpack4(x) unpackSnorm4x8(floatBitsToUint(x))\n\n\n// Random & Noise\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 n, int rep){\n    float sum = 0.0;\n    float amp= 1.0;\n    for (int i = 0; i <rep; i++){\n        sum += noise(n) * amp;\n        n += n*4.0;\n        amp *= 0.25;\n    }\n    return sum;\n}\n\n// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\n\n//  1 out, 1 in...\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//  1 out, 2 in...\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "vec3 ro = vec3(0), rd = vec3(0);\nvec3 camup = vec3(0), col = vec3(0);\nvec3 ldir = normalize(vec3(.8, 1., -.1));\n\n// SDF functions by iq and HG_SDF\n// https://iquilezles.org/articles/distfunctions\n// https://mercury.sexy/hg_sdf/\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// Cheap Rotation by las:\n// http://www.pouet.net/topic.php?which=7931&page=1\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nvec2 rot2(vec2 p,float r){\n    vec2 q = p;\n    R(q, r);\n    return q;\n}\nvec3 rot(vec3 p,vec3 r){\n    R(p.xz, r.y);\n    R(p.yx, r.z);\n    R(p.zy, r.x);\n    return p;\n}\n\nfloat sdPlane(in vec3 p){\n    return p.y;\n}\n\n\nfloat sdEllipsoid(in vec3 p, in vec3 r)\n{\n    return (length(p/r)-1.0)*min(min(r.x,r.y),r.z);\n}\n\n\nfloat fOpUnion(in float a,in float b)\n{\n    return a<b?a:b;\n}\n\n\nvec4 v4OpUnion(in vec4 a,in vec4 b)\n{\n    return a.x<b.x?a:b;\n}\n\n\nfloat fOpUnionSmooth(float a,float b,float r)\n{\n    float h = max(r-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/r;\n}\n\n\nvec4 v4OpUnionSmooth(vec4 a,vec4 b,float r)\n{\n    float h=clamp(0.5+0.5*(b.x-a.x)/r,0.0,1.0);\n    float res = mix(b.x,a.x,h)-r*h*(1.0-h);\n    return vec4(res, mix(b.yzw,a.yzw,h));\n}\n\n\nvec4 v4OpSubstraction(in vec4 a,in vec4 b)\n{\n    float res = max(-a.x, b.x);\n    return (res==-a.x)?vec4(-a.x, a.yzw):b;\n}\n\n\nvec4 v4OpSubstractionSmooth( vec4 a,vec4 b,float r)\n{\n    vec2 u = max(vec2(r + b.x, r + -a.x), vec2(0));\n    float res = min(-r, max(b.x, -a.x))+length(u);\n    vec3 m = mix(b.yzw, a.yzw, clamp(abs(-b.x)+abs(res),0.0,1.0)*clamp(r,0.,1.));\n    return vec4(res, m);\n}\n\n\nfloat pMirror(float x, float k){\n    return sqrt(x * x + k);\n}\n\n\n// Shapes.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nvec4 sdTeeth(vec3 p){\n    float bsd = length(p+vec3(0, -0.25, 0)), bsr=0.25;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n    \n\tvec3 q = p;\n    q.x+=u2s(fbm(q.yz*10., 1))*.015;\n    q.z+=u2s(fbm(q.xy*10., 1))*.015;\n    q.y+=u2s(fbm(q.xz*10., 1))*.015;\n    \n    float mask0 = smoothstep(.01, .05, length(q.xz));\n    float mask1 = smoothstep(.15, .0, length(q.xz));\n    float mask = mask0*mask1;\n    q.y-=smoothstep(.01, 1., fbm(vec2(atan(q.z,q.x), length(q.xz))*2.,1))*.05*mask;\n    q.y+=smoothstep(.2, .0, length(q.xz))*.1;\n\n\tq.z = pMirror(q.z, 0.0025);\n\tq.x = pMirror(q.x, 0.0040);\n\n\tfloat d = sdEllipsoid(rot(q+vec3(-0.1135, -0.4147, -0.1053), vec3(-0.3432, 0.2904, -0.1973)), vec3(0.1037, 0.1000, 0.1086));\n\td = fOpUnionSmooth(sdEllipsoid(rot(q+vec3(-0.1324, -0.0919, -0.1066), vec3(0.0000, 0.0000, 0.1114)), vec3(0.0337, 0.1000, 0.0337)), d, 0.0602);\n\td = fOpUnionSmooth(sdEllipsoid(rot(q+vec3(-0.1058, -0.2846, -0.1094), vec3(0.0000, 0.0000, 0.1352)), vec3(0.0559, 0.0968, 0.0773)), d, 0.0731);\n\treturn vec4(d, MAT_TEETH);\n}\n\nvec4 sdBlood(vec3 p){\n    float bsd = length(p+vec3(0, 0, 0)), bsr=0.25;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n\n    vec3 bp = p;\n    bp.y += .05*pow(length(p.xz)*4.7, 1.5);\n    bp.y += smoothstep(.0, 1., pow( u2s(fbm(p.xz*.2+1. ,1)), .5 )-.5 )*.05;\n    bp.y -= smoothstep(-.1, 1., pow( (fbm(p.xz*20. ,1)), .5 ) )*.05;\n    \n    bp.y = pMirror(bp.y, 0.00025);\n    bp.y += .0025;\n    \n    float d = sdPlane(bp);\n    d = fOpUnionSmooth(sdEllipsoid(p+vec3(0.0, -0.02, 0.0), vec3(0.08, 0.025, 0.08)*2.), d, .1);\n    d = fOpUnionSmooth(sdEllipsoid(p+vec3(0.1, -0.02, 0.1), vec3(0.08, 0.0125, 0.08)*2.), d, .1);\n\td = fOpUnion(sdEllipsoid(p+vec3(-0.2, -0.005, -0.3), vec3(0.08, 0.025, 0.08)*.5), d);\n    d = fOpUnion(sdEllipsoid(p+vec3(0.3, -0.01, -.5), vec3(0.08, 0.035, 0.08)*.35), d);\n    d = fOpUnion(sdEllipsoid(p+vec3(0.17, -0.005, .46), vec3(0.08, 0.035, 0.08)*.25), d);\n    d = fOpUnionSmooth(sdEllipsoid(p+vec3(0., 0., .36), vec3(0.06, 0.06, 0.06)*.05), d, .03);\n    d = fOpUnionSmooth(sdEllipsoid(p+vec3(0., 0., -.27), vec3(0.06, 0.06, 0.06)*.05), d, .03);\n    d = fOpUnionSmooth(sdEllipsoid(p+vec3(0., 0., -.29), vec3(0.06, 0.06, 0.06)*.05), d, .03);\n    \n    \n    d = fOpUnionSmooth(sdEllipsoid(p+vec3(-0.09, -0.246, -.28), vec3(0.06, 0.06, 0.06)*.0015), d, .01); //drop\n    d = fOpUnionSmooth(sdEllipsoid(p+vec3(-0.09, -0.21, -.28), vec3(0.06, 0.06, 0.06)*.38), d, .035); //drop\n    \n    return vec4(d, MAT_BLOOD);\n}\n\nvec4 sdScene(vec3 p)\n{\n    vec4 res = sdBlood(p);\n\tres = v4OpUnion(sdTeeth(rot(p+vec3(-.0, -.19, -.3), vec3(PI*.39, -.5, PI*.45))), res);\n\tif(length(p.xz)<1.)res = v4OpUnion(vec4(sdPlane(p), MAT_FLOOR), res);   \n    return res;//vec4(sdPlane(p), MAT_FLOOR);//res;\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec4 intersect()\n{\n    float d = MIN_DIST;\n    vec3  m = MAT_VOID;\n\n    for (int i = ZERO; i < ITERATION; i++)\n    {\n        vec3 p = ro + d * rd;\n        vec4 res = sdScene(p);\n        res.x*=.5;\n        m = res.yzw;\n        if (abs(res.x) < MIN_DIST)break;\n        d += res.x;\n        if (d >= MAX_DIST) return vec4(MAX_DIST, MAT_VOID);\n    }\n    if(d>MAX_DIST) return vec4(MAX_DIST, MAT_VOID);\n    return vec4(d,m);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 normal(vec3 p)\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdScene(p+0.0005*e).x;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat shadow(vec3 o)\n{\n    float mint=.001;\n    float maxt=5.;\n    float k = 30.;\n    float res = 1.;\n    // for( float t=mint; t < maxt; )\n    float ph = 1e20;\n    float t=mint;\n    for( int i=ZERO; i < 50; i++)\n    {\n        float h = sdScene(o + ldir*t).x;\n        h *= .5;\n        if(abs(h)<MIN_DIST) return 0.;\n\n        res = min( res, k*h/t);\n        \n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y));\n        ph = h;\n        t += h;\n\n        if(t >= maxt) break;\n    }\n    return smoothstep(.5, .51, res);\n}\n\nvec3 randomSphereDir(vec2 rnd)\n{\n    float s = rnd.x*PI*2.;\n    float t = rnd.y*2.-1.;\n    return vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\nvec3 randomHemisphereDir(vec3 dir, float i)\n{\n    vec3 v = randomSphereDir( vec2(hash11(i+1.), hash11(i+2.)) );\n    return v * sign(dot(v, dir));\n}\n\n// \"Hemispherical SDF AO\" by XT95:\n// https://www.shadertoy.com/view/4sdGWN\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff )\n{\n    const int nbIte = 12;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv; //Hemispherical factor (self occlusion correction)\n\n    float ao = 0.0;\n\n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = hash11(float(i))*maxDist;\n        vec3 aord = normalize(n+randomHemisphereDir(n, l )*rad)*l; // mix direction with the normal// for self occlusion problems!\n\n        ao += (l - max(sdScene( p + aord ).x,0.)) / maxDist * falloff;\n    }\n\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\n\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat specular(vec3 p, vec3 n, vec3 ld, float power)\n{\n    vec3 to_eye = normalize(p - ro);\n    vec3 reflect_light = normalize(reflect(ld, n));\n    return pow(max(dot(to_eye, reflect_light), 0.), power);\n}\n\nfloat swTri(float v){\n    return asin(sin(v*PI))*2./PI;\n}\n\nvec2 uv=vec2(0);\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    ab.x*=1.5; // sharpen\n    p = abs(p);\n    p.y+=ab.y*.5; // sharpen\n    if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\nfloat sdType(vec2 p){\n\tfloat d = sdEllipse(rot2(p+vec2(-0.0000, -0.0000), 0.0000), vec2(0.0316, 0.0062));\n\td = min(sdEllipse(rot2(p+vec2(-0.0000, 0.0511), -1.5854), vec2(0.0500, 0.0077)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.0020, 0.1048), 0.0000), vec2(0.0316, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.0743, 0.0020), 0.0000), vec2(0.0316, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.0816, 0.0564), -1.5854), vec2(0.0500, 0.0077)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.0756, 0.1035), 0.0000), vec2(0.0316, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.1626, 0.0597), -1.5854), vec2(0.0500, 0.0077)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.1632, 0.1028), 0.0000), vec2(0.0316, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.1652, 0.0046), 0.0000), vec2(0.0316, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.1227, 0.0504), -0.9931), vec2(0.0494, 0.0071)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.2262, 0.0551), -1.5854), vec2(0.0500, 0.0077)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.2269, 0.1048), 0.0000), vec2(0.0316, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.2243, 0.0040), 0.0000), vec2(0.0316, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.2647, 0.0372), -0.8361-1.5854), vec2(0.0352, 0.0084)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.2853, 0.0066), 0.0000), vec2(0.0316, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.2826, 0.0796), 0.6562-1.5854), vec2(0.0247, 0.0087)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.2966, 0.1048), 0.0000), vec2(0.0316, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.3666, 0.0571), -1.5854), vec2(0.0500, 0.0077)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.3672, 0.1068), 0.0000), vec2(0.0316, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.3646, 0.0060), 0.0000), vec2(0.0479, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.0166, 0.1523), 0.0000), vec2(0.0413, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.0179, 0.2538), 0.0000), vec2(0.0413, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.0634, 0.2038), -1.5854), vec2(0.0343, 0.0074)), d);\n\td = min(sdEllipse(rot2(p+vec2(0.0096, 0.2037), -1.5854), vec2(0.0343, 0.0074)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.3208, 0.0212), -1.5854), vec2(0.0130, 0.0049)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.4149, 0.0179), -1.5854), vec2(0.0130, 0.0049)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.1314, 0.1510), 0.0000), vec2(0.0355, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.1373, 0.2525), 0.0000), vec2(0.0413, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.1098, 0.2023), -1.5854), vec2(0.0343, 0.0074)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.1466, 0.1981), 0.0000), vec2(0.0355, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.1708, 0.1765), -1.5854), vec2(0.0185, 0.0055)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.1828, 0.2296), -1.5854), vec2(0.0210, 0.0055)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.2461, 0.1497), 0.0000), vec2(0.0412, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.2455, 0.2512), 0.0000), vec2(0.0413, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.2179, 0.2010), -1.5854), vec2(0.0595, 0.0074)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.2475, 0.1968), 0.0000), vec2(0.0231, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.2846, 0.1683), -1.5854), vec2(0.0130, 0.0049)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.2860, 0.2432), 0.0000), vec2(0.0066, 0.0099)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.3437, 0.1510), 0.0000), vec2(0.0355, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.3251, 0.2525), 0.0000), vec2(0.0201, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.3221, 0.2023), -1.5854), vec2(0.0343, 0.0074)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.3589, 0.1981), 0.0000), vec2(0.0355, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.3832, 0.1765), -1.5854), vec2(0.0220, 0.0061)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.3951, 0.2296), -1.5854), vec2(0.0330, 0.0074)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.3934, 0.2519), 0.0000), vec2(0.0201, 0.0062)), d);\n\t\n    d = min(sdEllipse(rot2(p+vec2(0.0023, 0.3108), -0.7510-1.5854), vec2(0.0352, 0.0084)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.0170, 0.3650), -0.8361-1.5854), vec2(0.0598, 0.0084)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.0342, 0.3086), -2.1717-1.5854), vec2(0.0352, 0.0084)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.0151, 0.4064), 0.0000), vec2(0.0413, 0.0062)), d);\n\t\n    d = min(sdEllipse(rot2(p+vec2(-0.1614, 0.3165), -0.8465), vec2(0.0413, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.1302, 0.3733), -0.8465), vec2(0.0413, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.1612, 0.3752), -2.2890), vec2(0.0343, 0.0074)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.1236, 0.3259), -2.2690), vec2(0.0343, 0.0074)), d);\n    \n\td = min(sdEllipse(rot2(p+vec2(-0.2321, 0.3136), -0.7510-1.5854), vec2(0.0352, 0.0067)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.2515, 0.3678), -0.6709-1.5854), vec2(0.0598, 0.0084)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.2686, 0.3114), -2.1717-1.5854), vec2(0.0352, 0.0067)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.2496, 0.4092), 0.0000), vec2(0.0413, 0.0062)), d);\n    \n\td = min(sdEllipse(rot2(p+vec2(-0.3870, 0.3221), -0.8465), vec2(0.0413, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.3480, 0.3749), -0.8465), vec2(0.0413, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.3907, 0.3780), -2.2890), vec2(0.0343, 0.0074)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.3531, 0.3286), -2.2690), vec2(0.0343, 0.0074)), d);\n\treturn d;\n}\n\nvec3 ord = vec3(0);\nvec3 nlm = vec3(0);\nfloat first_t = 0.;\nvec3 albedo = vec3(0);\nfloat spec = 0.;\nfloat depth = 0.;\nfloat ao = 1.;\nfloat shdw = 1.;\nfloat diffuse = 0.;\nvoid render()\n{\n    vec4 hit = intersect();\n    vec3 p = ro + hit.x * rd;\n    albedo = hit.yzw;\n\n\n    vec3 n = normal(p);\n\n    vec3 offset = n * .005;\n    float vol = 1.0;\n    shdw=ao=1.;\n\n    vec3 res_col = vec3(1);\n\n    if (hit.x>=MAX_DIST)\n    {\n        nlm = vec3(0);\n        res_col=vec3(0);\n        albedo = AMB_COL;\n        shdw = pow(1.-(rd.y)-.1,2.);\n        spec = 0.;\n        depth = 1.;\n    }\n    else\n    {\n\n        // Camera localized normal\n        vec3 up = camup;\n        vec3 side = cross(rd, up);\n        nlm.x = dot(n+offset,  side);\n        nlm.y = dot(n+offset,  up);\n        nlm.z = dot(n+offset,  -rd);\n\n        float light1 = dot(n+offset,  ldir)*.5+.5; // Half-Lanbert model\n        float light2 = dot(n+offset, -ldir)*.5+.5;\n        shdw = shadow(p+offset);\n        \n        diffuse = light1;\n\n        ao = ambientOcclusion(p+n*0.01, n, .5, 2.);\n        ao += ambientOcclusion(p+n*0.01, n, .01, .2);\n        ao += ambientOcclusion(p+n*0.01, n, 2., 2.);\n        ao += ambientOcclusion(p+n*0.01, n, 5., 2.);\n        ao = smoothstep(0., 4., ao);\n        ao = pow(ao, .2);\n\n        const float thresh = .01;\n        if(distance(albedo, MAT_TEETH) < thresh)\n        {\n            spec = specular(p+offset, n, ldir, 30.);\n            //diffuse = .0;\n            if(p.x<0.)\n            {\n                float type= 1.-step(.05, 1.0 - exp(-8.0*abs(sdType((p.zy*vec2(-1,1)-vec2(-.31,.9)*.3)*3.))));\n                nlm.x+=type;\n                //nlm.y-=type;\n            }\n        }\n        \n        if(distance(albedo, MAT_BLOOD) < thresh)\n        {\n            spec = specular(p+offset, n, ldir, 50.);\n        }\n        \n        \n        if(distance(albedo, MAT_FLOOR) < thresh)\n        {\n            // Floor\n            vec2 uv = vec2(p.z, p.y);\n\n            vec3 q = p;\n\n            uv.x = q.x;\n            uv.y = q.z;\n            uv*=.5;\n\n            int offset = int(uv.x)%2;\n            vec2 ratio = vec2(1,4);\n            float gridGap = 0.001;\n            if(offset==0)uv.y+=ratio.y*.5;\n\n            vec2 id = floor(uv/ratio);\n            uv = mod(uv, ratio)-ratio*.5;\n\n            float d =sdBox(uv, ratio*.5-gridGap);\n            if(noise(uv*vec2(2000,1)*5.*id)<.75)\n                diffuse *= step(.05, 1.0 - exp(-8.0*abs(d)));\n            if(noise(uv*vec2(1500,20))<.75)\n            {\n                uv.y+=fbm(uv*30., 2)*.025;\n                uv *= mat2(cos(noise(uv*vec2(5,1)+id)*PI*.3+vec4(0,11,33,0)));\n                diffuse *= smoothstep(.4, .42, abs(sin(uv.x*40.)));\n                \n                \n            }\n            if(noise(uv*vec2(100,20))<.75)\n            {\n                diffuse+=noise(uv*vec2(2000,1))*.25;\n            }\n            \n        }\n        depth = distance(ro, p)/MAX_DIST;\n    }\n}\n\nvec3 quat_rotate(vec4 quat, vec3 dir)\n{\n    return dir + 2.0 * cross(quat.xyz, cross(quat.xyz, dir) + quat.w * dir);\n}\nvoid camera(vec2 uv)\n{\n    const float pY = .35;\n    const float cL = 1.5;\n    const vec3 forcus = vec3(0,.18,0);\n    const float fov = .33;\n\n    vec3 up = vec3(0,1,0);\n    vec3 pos = vec3(0,pY,0);\n    pos.xz = vec2(.7,-.7)*cL;\n    if(iMouse.z>.5)\n        pos.xz = vec2(sin(iMouse.x/iResolution.x*TAU),cos(iMouse.x/iResolution.x*TAU))*cL;\n    vec3 dir = normalize(forcus-pos);\n    vec3 target = pos-dir;\n    vec3 cw = normalize(target - pos);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n\tcamup = up;\n    mat3 camMat = mat3(cu, cv, cw);\n    rd = normalize(camMat * normalize(vec3(sin(fov) * uv.x, sin(fov) * uv.y, -cos(fov))));\n\n    ro = pos;\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n   // Setup UV...\n    uv = fragCoord.xy / iResolution.xy;\n    float ml = (min(iResolution.x, iResolution.y)==iResolution.x)?1.0:iResolution.y/iResolution.x;\n    uv = (uv*2.-1.)*ml;\n    uv.x *= iResolution.x / iResolution.y;\n\n    camera(uv);\n\n    render();\n    uv.y+=.05;\n    uv.y*=1.3;\n    col.x *= 1.-depth*1.5;\n    vec3 spec_diffuse_ao = vec3(spec, diffuse, ao)*2.-1.;\n    fragColor = vec4(pack4(vec4(albedo, shdw)), pack(nlm), pack(spec_diffuse_ao), depth);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}