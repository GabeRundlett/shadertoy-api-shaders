{
    "Shader": {
        "info": {
            "date": "1627661470",
            "description": "Camera controls are WASD and QE for roll.\nN shoots a beam. R reset accumulation.\n\nStoring a light path and then using it for next event estimation in path tracing,the NEE is importance sampled so that the probability of hitting a light path is maximized.",
            "flags": 48,
            "hasliked": 0,
            "id": "7lBXWW",
            "likes": 17,
            "name": "Fo Reproject cam refract laser",
            "published": 3,
            "tags": [
                "camera",
                "pathtracer",
                "laser",
                "bidirectional"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 522
        },
        "renderpass": [
            {
                "code": "// Fork of \"Volumetric laser tracer\" by michael0884. https://shadertoy.com/view/NtXSR4\n// 2021-07-22 19:27:50\n\nvec3 encodeSRGB(vec3 linearRGB)\n{\n    vec3 a = 12.92 * linearRGB;\n    vec3 b = 1.055 * pow(linearRGB, vec3(1.0 / 2.)) - 0.055;\n    vec3 c = step(vec3(0.0031308), linearRGB);\n    return mix(a, b, c);\n}\n\nvec3 tone(vec3 c)\n{\n    c = XYZtosRGB(c);\n    return tanh(encodeSRGB(c));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 acc = texture(iChannel0, fragCoord/iResolution.xy);\n    fragColor = vec4(tone(0.1*acc.xyz/acc.w), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//controller\n\n//Keyboard constants\nconst int keyLe = 37, keyUp = 38, keyRi = 39, keyDn = 40, keyA = 65, keyB = 66, keyC = 67, keyD = 68, keyE = 69, keyF = 70, keyG = 71, keyH = 72, keyI = 73, keyJ = 74, keyK = 75, keyL = 76, keyM = 77, keyN = 78, keyO = 79, keyP = 80, keyQ = 81, keyR = 82, keyS = 83, keyT = 84, keyU = 85, keyV = 86, keyW = 87, keyX = 88, keyY = 89, keyZ = 90;\n\nbool pressed(int k) \n{\n    return texelFetch(iChannel3, ivec2(k, 0), 0).x > 0.5;\n}\n\nconst float force =25.0;\nconst float mouse_sens = 100.0;\nconst float roll_speed = 0.5;\n\nvoid mainImage( out vec4 o, in vec2 p )\n{\n    p = floor(p);\n    if(p.x > NAddr && p.y > 0.) discard;\n    \n    //get camera data\n    vec3 cp = get(CamP).xyz;\n    vec4 ca = normalize(get(CamA));\n    \n    vec3 pcp = cp;\n    vec4 pca = ca;\n    \n    vec3 ro = get(RayO).xyz;\n    vec3 rd = get(RayD).xyz;\n    \n    float mode = 0.0;\n    if(pressed(keyR)) mode = 1.0;\n    \n    //initialization\n    if(iFrame < 10)\n    {\n        cp = vec3(-1.,1.5,-1);\n        ca = aa2q( normalize(vec3(0,1,0)), -PI*0.6/4.0);\n        mat3 cam = getCam(ca);\n        ca = qq2q(ca, aa2q(cam*vec3(1,0,0), -PI*0.4/4.0)); \n        ro = vec3( -2,.252, 0);\n        rd = normalize(vec3(0.3,0.,-0.002));\n    }\n    vec4 oldca = ca;\n    if(p.x == PrevCamP) o = vec4(cp, 0);\n    if(p.x == PrevCamA) o = ca;\n    \n    mat3 cam = getCam(ca);\n    \n    //get velocities\n    vec3 cv = get(CamV).xyz;\n    vec4 cav = get(CamAV);\n    \n    float dt = 1./60.0;\n    //update position\n    if(pressed(keyW)) cv += force*dt*cam*vec3(0,0,1);\n    if(pressed(keyS)) cv += force*dt*cam*vec3(0,0,-1);\n    if(pressed(keyA)) cv += force*dt*cam*vec3(-1,0,0);\n    if(pressed(keyD)) cv += force*dt*cam*vec3(1,0,0);\n    \n    cp += dt*cv;\n    cv += -cv*tanh(10.0*dt);\n    \n    //update camera orientation\n    vec2 dmouse = dt*mouse_sens*(iMouse.xy - get(PrevMouse).xy)/iResolution.x;\n    \n    if(length(dmouse) < 0.1)\n    {\n        //rotate around y ax\n        ca = qq2q(ca, aa2q(cam*vec3(0,1,0), -dmouse.x)); \n        //rotate around x ax\n        ca = qq2q(ca, aa2q(cam*vec3(1,0,0), dmouse.y));\n    }\n    \n    //roll camera\n    if(pressed(keyQ)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), -roll_speed*dt)); \n    if(pressed(keyE)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), roll_speed*dt)); \n    \n    if(distance(oldca, ca) > 0.001 || length(cv) > 0.01) mode = 1.0;\n    \n    if(pressed(keyN)) \n    {\n        rd = cam*vec3(0,0,1);\n        ro = cp + 0.05*cam*vec3(1,1,0);\n    }\n    \n    if(p.x == CamP) o = vec4(cp, mode);\n    if(p.x == CamA) o = ca;\n    if(p.x == PrevCamP) o = vec4(pcp, mode);\n    if(p.x == PrevCamA) o = pca;\n    if(p.x == CamV) o = vec4(cv, 0.0);\n    if(p.x == CamAV) o = vec4(0.0);\n    if(p.x == PrevMouse) o = vec4(iMouse.xy, 0, 0);\n    if(p.x == RayO) o = vec4(ro, 0);\n    if(p.x == RayD) o = vec4(rd, 0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n#define FOV 1.1\n#define CAM_ANGLE 0.001\n#define MAX_STEPS 90\n#define MIN_DIST 1e-5\n#define MAX_DIST 500.0\n\n//(reused some of @ollj's code, made it more readible)\n\nvec3 light = normalize(vec3(0,1,0));\nconst float light_bright =1.0;\nconst float light_ang = 0.1;\n\n//specific controller buffer Addresses\nconst float CamP = 0.,     //camera position \n            CamA = 1.,     //camera rotation quaternion    \n            CamV = 2.,     //camera velocity\n            CamAV = 3.,    //camera rotation velocity\n            PrevCamP = 4., //previous frame camera position\n            PrevCamA = 5., //previous frame camera rotation quaternion\n            PrevMouse = 6.,//previous mouse pos\n            RayO = 7.,     //previous mouse pos\n            RayD = 8.,     //previous mouse pos\n            NAddr = 9.;    //max address count\n            \n#define get(i) texelFetch(iChannel2,ivec2(i,0),0)\n\nfloat sqr(float x)\n{\n    return x*x;\n}\n\nvec3 reproject(mat3 pcam_mat, vec3 pcam_pos, vec2 iRes, vec3 p)\n{\n    float td = distance(pcam_pos, p);\n    vec3 dir = (p - pcam_pos)/td;\n    vec3 screen = dir*pcam_mat;\n    return vec3(screen.xy*iRes.y/(FOV*screen.z) + 0.5*iRes.xy, td);\n}\n\nfloat iPlane( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n              in vec3 planeNormal, in float planeDist) {\n    float a = dot(rd, planeNormal);\n    float d = -(dot(ro, planeNormal)+planeDist)/a;\n    if (a > 0. || d < distBound.x || d > distBound.y) {\n        return MAX_DIST;\n    } else {\n        normal = planeNormal;\n    \treturn d;\n    }\n}\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n               float sphereRadius ) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - sphereRadius*sphereRadius;\n    float h = b*b - c;\n    if (h < 0.) {\n        return MAX_DIST;\n    } else {\n\t    h = sqrt(h);\n        float d1 = -b-h;\n        float d2 = -b+h;\n        if (d1 >= distBound.x && d1 <= distBound.y) {\n            normal = normalize(ro + rd*d1);\n            return d1;\n        } else if (d2 >= distBound.x && d2 <= distBound.y) { \n            normal = normalize(ro + rd*d2);            \n            return d2;\n        } else {\n            return MAX_DIST;\n        }\n    }\n}\n\nfloat iBox( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal, \n            in vec3 boxSize ) {\n    vec3 m = sign(rd)/max(abs(rd), 1e-8);\n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if (tN > tF || tF <= 0.) {\n        return MAX_DIST;\n    } else {\n        if (tN >= distBound.x && tN <= distBound.y) {\n        \tnormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n            return tN;\n        } else if (tF >= distBound.x && tF <= distBound.y) { \n        \tnormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n            return tF;\n        } else {\n            return MAX_DIST;\n        }\n    }\n}\n\nfloat iCylinder( in vec3 ro, in vec3 rd, \n                in vec3 pa, in vec3 pb, float ra ) // extreme a, extreme b, radius\n{\n    vec3 ba = pb-pa;\n\n    vec3  oc = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoc = dot(ba,oc);\n    \n    float k2 = baba            - bard*bard;\n    float k1 = baba*dot(oc,rd) - baoc*bard;\n    float k0 = baba*dot(oc,oc) - baoc*baoc - ra*ra*baba;\n    \n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return 1e10;\n    h = sqrt(h);\n    float t = (-k1-h)/k2;\n\n    // body\n    float y = baoc + t*bard;\n    if( y>0.0 && y<baba ) return t;\n    \n    // caps\n    t = ( ((y<0.0) ? 0.0 : baba) - baoc)/bard;\n    if( abs(k1+k2*t)<h )\n    {\n        return t;\n    }\n\n    return 1e10;\n}\n\n//ollj quaternionRotation math\n//\n//ANY rotations in 3d are non-commutative!\n//\n//matrix rotations are just bulky, memory wasting\n//EulerRotations almost certainly fail to rotate over the SHORTEST path.\n//EulerRotations almost certainly will gimbalLock and get stuck along one axis\n//QuaternionRotations are superior here.\n//-> we only use EulerRorations for simple input devices (keyboard input)\n//-> we convert to quaternions, buffered as vec4.\n\n//quaternion Identity\nvec4 qid() \n{\n    return vec4(0, 0, 0, 1);\n}\n\n//return quaternion from axis and angle\nvec4 aa2q(vec3 axis, float ang) \n{\n    vec2 g = vec2(sin(ang), cos(ang)) * 0.5;\n    return normalize(vec4(axis * g.x, g.y));\n}\n\n//return AxisAngle of NORMALIZED quaternion input\nvec4 q2aa(vec4 q) \n{\n    return vec4(q.xyz / sqrt(1.0 - q.w * q.w), acos(q.w) * 2.);\n}\n\n//return q2, rotated by q1, order matters (is non commutative) : (aka quaternion multiplication == AxisAngleRotation)\nvec4 qq2q(vec4 q1, vec4 q2) \n{\n    return vec4(q1.xyz * q2.w + q2.xyz * q1.w + cross(q1.xyz, q2.xyz), (q1.w * q2.w) - dot(q1.xyz, q2.xyz));\n}\n\n//extension to qq2q(), scaled by sensitivity [f] (==quaternion ANGULAR equivalent to slerp() )\nvec4 qq2qLerp(vec4 a, vec4 b, float f) \n{\n    float d = dot(a, b), t = acos(abs(d)), o = (1. / sin(t));\n    return normalize(a * sin(t * (1.0 - f)) * o * sign(d) + b * sin(t * f) * o);\n}\n\n//doing qq2q() multiple times, you need to normalize() the quaternion, to fix rounding errors.\n//how often you do this is up to you.\n\n//normalize q (assuming length(q) is already close to 1, we can skip whe sqrt()\nvec4 qn(vec4 q) \n{\n    return q / dot(q,q);\n}\n\n//return quaternion, that is the shortest rotation, between looking to [a before], and looking to [b after] the rotation.\n//http://wiki.secondlife.com/wiki/LlRotBetween\nvec4 qBetween(vec3 a, vec3 b) \n{\n    float v = sqrt(dot(a,a) * dot(a,a));\n\n    if(v == 0.) return qid();\n    \n    v = dot(a, b) / v;\n    vec3 c = a.yzx * b.zxy - a.zxy * b.yzx / v;\n    float d = dot(c,c);\n    \n    if(d != 0.) \n    {\n        float s = (v > - 0.707107) ? 1. + v : d / (1. + sqrt(1. - d));\n        return vec4(c, s) / sqrt(d + s * s);\n    }\n    \n    if(v > 0.) return qid();\n    \n    float m = length(a.xy);\n    \n    return (m != 0.) ? vec4(a.y, - a.x, 0, 0) / m : vec4(1, 0, 0, 0);\n}\n\n//return inverse of quaternion\nvec4 qinv(vec4 q) \n{\n    return vec4(- q.xyz, q.w) / dot(q,q);\n}\n\n//return VECTOR p, rotated by quaterion q;\nvec3 qv2v(vec4 q, vec3 p) \n{\n    return qq2q(q, qq2q(vec4(p, .0), qinv(q))).xyz;\n}\n\n//qv2v()  with swapped inputs\n//return quaterion P (as vector), as if it is rotated by VECTOR p (as if it is a quaternion)\nvec3 vq2v(vec3 p, vec4 q) \n{\n    return qq2q(qinv(q), qq2q(vec4(p, 0.0), q)).xyz;\n}\n\nvec3 vq2v(vec4 a, vec3 b) \n{\n    return qv2v(a, b);\n}\n\n//in case of namespace confuction\nvec3 qv2v(vec3 a, vec4 b) \n{\n    return vq2v(a, b);\n}\n\n//return mat3 of quaternion (rotation matrix without translation)\n//https://www.shadertoy.com/view/WsGfWm\nmat3 q2m(vec4 q) \n{\n    vec3 a = vec3(-1, 1, 1);\n    vec3 u = q.zyz * a, v = q.xyx * a.xxy;\n    mat3 m = mat3(0.5) + mat3(0, u.x,u.y,u.z, 0, v.x,v.y,v.z, 0) * q.w + matrixCompMult(outerProduct(q.xyz, q.xyz), 1. - mat3(1));\n    q *= q; \n    m -= mat3(q.y + q.z, 0, 0, 0, q.x + q.z, 0, 0, 0, q.x + q.y);\n    return m * 2.0;\n}\n\n//return quaternion of orthogonal matrix (with determinant==1., or else quaternionm will not be normalized)\nvec4 m2q(mat3 m) \n{\n#define m2f(a,b) m[a][b]-m[b][a]\n    //http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n    float q = 2. * sqrt(abs(1. + m[0][0] + m[1][1] + m[2][2]));\n    return vec4(vec3(m2f(2, 1), m2f(0, 1), m2f(1, 0)) / q / 4., q);\n#undef m2f\n}\n\nfloat at2e(vec2 a) \n{\n    a *= 2.;\n    return atan(a.x, 1. - a.y);\n}\n\n//return quaternion of Euler[yaw,pitch,roll]     \nvec4 eYPR2q(vec3 o) \n{\n    o *= .5;\n    vec3 s = sin(o);\n    //https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles#Source_code\n    o = cos(o);\n    vec4 a = vec4(s.xz, o.xz);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(-1, 1, -1, 1);\n}\n\nvec4 eYPR2q(vec2 o) \n{\n    o *= .5;\n    vec2 s = sin(o);\n    o = cos(o);\n    vec4 a = vec4(s.x, 0., o.x, 0.);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(- 1, 1, - 1, 1);\n}\n\nmat3 getCam(vec4 q) \n{\n    return q2m(q);\n}\n\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n// https://www.pcg-random.org/\nuvec4 pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    return v;\n}\n\nfloat rand(){ return float(pcg4d(s0).x)/float(0xffffffffu); }\nvec2 rand2(){ return vec2(pcg4d(s0).xy)/float(0xffffffffu); }\nvec3 rand3(){ return vec3(pcg4d(s0).xyz)/float(0xffffffffu); }\nvec4 rand4(){ return vec4(pcg4d(s0))/float(0xffffffffu); }\n\nvec2 nrand2(float sigma, vec2 mean)\n{\n\tvec2 Z = rand2();\n    return mean + sigma * sqrt(-2.0 * log(Z.x)) * \n           vec2(cos(TWO_PI * Z.y),sin(TWO_PI * Z.y));\n}\n\nvec3 nrand3(float sigma, vec3 mean)\n{\n\tvec4 Z = rand4();\n    return mean + sigma * sqrt(-2.0 * log(Z.xxy)) * \n           vec3(cos(TWO_PI * Z.z),sin(TWO_PI * Z.z),cos(TWO_PI * Z.w));\n}\n\n//uniformly spherically distributed\nvec3 udir(vec2 rng)\n{\n    vec2 r = vec2(2.*PI*rng.x, acos(2.*rng.y-1.));\n    vec2 c = cos(r), s = sin(r);\n    return vec3(c.x*s.y, s.x*s.y, c.y);\n}\n\nconst float PI2 = 6.2831853071;\n\nconst float aperture_size = 0.0;\nvec2 aperture()\n{\n    vec2 r = rand2();\n    return vec2(sin(TWO_PI*r.x), cos(TWO_PI*r.x))*sqrt(r.y);\n}\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\nvec3 spectral_zucconi(float w)\n{\n    // w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w - 400.0)/ 300.0);\n\n\tconst vec3 cs = vec3(3.54541723, 2.86670055, 2.29421995);\n\tconst vec3 xs = vec3(0.69548916, 0.49416934, 0.28269708);\n\tconst vec3 ys = vec3(0.02320775, 0.15936245, 0.53520021);\n\n\treturn bump3y (\tcs * (x - xs), ys);\n}\n\nvec3 spectral_bruton (float w)\n{\n\tvec3 c;\n\n\tif (w >= 380. && w < 440.)\n\t\tc = vec3\n\t\t(\n\t\t\t-(w - 440.) / (440. - 380.),\n\t\t\t0.0,\n\t\t\t1.0\n\t\t);\n\telse if (w >= 440. && w < 490.)\n\t\tc = vec3\n\t\t(\n\t\t\t0.0,\n\t\t\t(w - 440.) / (490. - 440.),\n\t\t\t1.0\n\t\t);\n\telse if (w >= 490. && w < 510.)\n\t\tc = vec3\n\t\t(\t0.0,\n\t\t\t1.0,\n\t\t\t-(w - 510.) / (510. - 490.)\n\t\t);\n\telse if (w >= 510. && w < 580.)\n\t\tc = vec3\n\t\t(\n\t\t\t(w - 510.) / (580. - 510.),\n\t\t\t1.0,\n\t\t\t0.0\n\t\t);\n\telse if (w >= 580. && w < 645.)\n\t\tc = vec3\n\t\t(\n\t\t\t1.0,\n\t\t\t-(w - 645.) / (645. - 580.),\n\t\t\t0.0\n\t\t);\n\telse if (w >= 645. && w <= 780.)\n\t\tc = vec3\n\t\t(\t1.0,\n\t\t\t0.0,\n\t\t\t0.0\n\t\t);\n\telse\n\t\tc = vec3\n\t\t(\t0.0,\n\t\t\t0.0,\n\t\t\t0.0\n\t\t);\n\n\treturn saturate(c);\n}\nvec3 spectral_zucconi6 (float w)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w - 400.0)/ 300.0);\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat capIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - r*r*baba;\n    float h = b*b - a*c;\n    if( h>=0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n        float y = baoa + t*bard;\n        // body\n        if( y>0.0 && y<baba ) return t;\n        // caps\n        vec3 oc = (y<=0.0) ? oa : ro - pb;\n        b = dot(rd,oc);\n        c = dot(oc,oc) - r*r;\n        h = b*b - c;\n        if( h>0.0 ) return -b - sqrt(h);\n    }\n    return -1.0;\n}\n\n\n// Spectrum to xyz approx function from Sloan http://jcgt.org/published/0002/02/01/paper.pdf\n// Inputs:  Wavelength in nanometers\nfloat xFit_1931( float wave )\n{\n    float t1 = (wave-442.0)*((wave<442.0)?0.0624:0.0374),\n          t2 = (wave-599.8)*((wave<599.8)?0.0264:0.0323),\n          t3 = (wave-501.1)*((wave<501.1)?0.0490:0.0382);\n    return 0.362*exp(-0.5*t1*t1) + 1.056*exp(-0.5*t2*t2)- 0.065*exp(-0.5*t3*t3);\n}\nfloat yFit_1931( float wave )\n{\n    float t1 = (wave-568.8)*((wave<568.8)?0.0213:0.0247),\n          t2 = (wave-530.9)*((wave<530.9)?0.0613:0.0322);\n    return 0.821*exp(-0.5*t1*t1) + 0.286*exp(-0.5*t2*t2);\n}\nfloat zFit_1931( float wave )\n{\n    float t1 = (wave-437.0)*((wave<437.0)?0.0845:0.0278),\n          t2 = (wave-459.0)*((wave<459.0)?0.0385:0.0725);\n    return 1.217*exp(-0.5*t1*t1) + 0.681*exp(-0.5*t2*t2);\n}\n\n#define xyzFit_1931(w) vec3( xFit_1931(w), yFit_1931(w), zFit_1931(w) ) \n\n// http://www.cie.co.at/technical-work/technical-resources\nvec3 standardObserver1931[] =\n    vec3[] (\n    vec3( 0.001368, 0.000039, 0.006450 ), // 380 nm\n    vec3( 0.002236, 0.000064, 0.010550 ), // 385 nm\n    vec3( 0.004243, 0.000120, 0.020050 ), // 390 nm\n    vec3( 0.007650, 0.000217, 0.036210 ), // 395 nm\n    vec3( 0.014310, 0.000396, 0.067850 ), // 400 nm\n    vec3( 0.023190, 0.000640, 0.110200 ), // 405 nm\n    vec3( 0.043510, 0.001210, 0.207400 ), // 410 nm\n    vec3( 0.077630, 0.002180, 0.371300 ), // 415 nm\n    vec3( 0.134380, 0.004000, 0.645600 ), // 420 nm\n    vec3( 0.214770, 0.007300, 1.039050 ), // 425 nm\n    vec3( 0.283900, 0.011600, 1.385600 ), // 430 nm\n    vec3( 0.328500, 0.016840, 1.622960 ), // 435 nm\n    vec3( 0.348280, 0.023000, 1.747060 ), // 440 nm\n    vec3( 0.348060, 0.029800, 1.782600 ), // 445 nm\n    vec3( 0.336200, 0.038000, 1.772110 ), // 450 nm\n    vec3( 0.318700, 0.048000, 1.744100 ), // 455 nm\n    vec3( 0.290800, 0.060000, 1.669200 ), // 460 nm\n    vec3( 0.251100, 0.073900, 1.528100 ), // 465 nm\n    vec3( 0.195360, 0.090980, 1.287640 ), // 470 nm\n    vec3( 0.142100, 0.112600, 1.041900 ), // 475 nm\n    vec3( 0.095640, 0.139020, 0.812950 ), // 480 nm\n    vec3( 0.057950, 0.169300, 0.616200 ), // 485 nm\n    vec3( 0.032010, 0.208020, 0.465180 ), // 490 nm\n    vec3( 0.014700, 0.258600, 0.353300 ), // 495 nm\n    vec3( 0.004900, 0.323000, 0.272000 ), // 500 nm\n    vec3( 0.002400, 0.407300, 0.212300 ), // 505 nm\n    vec3( 0.009300, 0.503000, 0.158200 ), // 510 nm\n    vec3( 0.029100, 0.608200, 0.111700 ), // 515 nm\n    vec3( 0.063270, 0.710000, 0.078250 ), // 520 nm\n    vec3( 0.109600, 0.793200, 0.057250 ), // 525 nm\n    vec3( 0.165500, 0.862000, 0.042160 ), // 530 nm\n    vec3( 0.225750, 0.914850, 0.029840 ), // 535 nm\n    vec3( 0.290400, 0.954000, 0.020300 ), // 540 nm\n    vec3( 0.359700, 0.980300, 0.013400 ), // 545 nm\n    vec3( 0.433450, 0.994950, 0.008750 ), // 550 nm\n    vec3( 0.512050, 1.000000, 0.005750 ), // 555 nm\n    vec3( 0.594500, 0.995000, 0.003900 ), // 560 nm\n    vec3( 0.678400, 0.978600, 0.002750 ), // 565 nm\n    vec3( 0.762100, 0.952000, 0.002100 ), // 570 nm\n    vec3( 0.842500, 0.915400, 0.001800 ), // 575 nm\n    vec3( 0.916300, 0.870000, 0.001650 ), // 580 nm\n    vec3( 0.978600, 0.816300, 0.001400 ), // 585 nm\n    vec3( 1.026300, 0.757000, 0.001100 ), // 590 nm\n    vec3( 1.056700, 0.694900, 0.001000 ), // 595 nm\n    vec3( 1.062200, 0.631000, 0.000800 ), // 600 nm\n    vec3( 1.045600, 0.566800, 0.000600 ), // 605 nm\n    vec3( 1.002600, 0.503000, 0.000340 ), // 610 nm\n    vec3( 0.938400, 0.441200, 0.000240 ), // 615 nm\n    vec3( 0.854450, 0.381000, 0.000190 ), // 620 nm\n    vec3( 0.751400, 0.321000, 0.000100 ), // 625 nm\n    vec3( 0.642400, 0.265000, 0.000050 ), // 630 nm\n    vec3( 0.541900, 0.217000, 0.000030 ), // 635 nm\n    vec3( 0.447900, 0.175000, 0.000020 ), // 640 nm\n    vec3( 0.360800, 0.138200, 0.000010 ), // 645 nm\n    vec3( 0.283500, 0.107000, 0.000000 ), // 650 nm\n    vec3( 0.218700, 0.081600, 0.000000 ), // 655 nm\n    vec3( 0.164900, 0.061000, 0.000000 ), // 660 nm\n    vec3( 0.121200, 0.044580, 0.000000 ), // 665 nm\n    vec3( 0.087400, 0.032000, 0.000000 ), // 670 nm\n    vec3( 0.063600, 0.023200, 0.000000 ), // 675 nm\n    vec3( 0.046770, 0.017000, 0.000000 ), // 680 nm\n    vec3( 0.032900, 0.011920, 0.000000 ), // 685 nm\n    vec3( 0.022700, 0.008210, 0.000000 ), // 690 nm\n    vec3( 0.015840, 0.005723, 0.000000 ), // 695 nm\n    vec3( 0.011359, 0.004102, 0.000000 ), // 700 nm\n    vec3( 0.008111, 0.002929, 0.000000 ), // 705 nm\n    vec3( 0.005790, 0.002091, 0.000000 ), // 710 nm\n    vec3( 0.004109, 0.001484, 0.000000 ), // 715 nm\n    vec3( 0.002899, 0.001047, 0.000000 ), // 720 nm\n    vec3( 0.002049, 0.000740, 0.000000 ), // 725 nm\n    vec3( 0.001440, 0.000520, 0.000000 ), // 730 nm\n    vec3( 0.001000, 0.000361, 0.000000 ), // 735 nm\n    vec3( 0.000690, 0.000249, 0.000000 ), // 740 nm\n    vec3( 0.000476, 0.000172, 0.000000 ), // 745 nm\n    vec3( 0.000332, 0.000120, 0.000000 ), // 750 nm\n    vec3( 0.000235, 0.000085, 0.000000 ), // 755 nm\n    vec3( 0.000166, 0.000060, 0.000000 ), // 760 nm\n    vec3( 0.000117, 0.000042, 0.000000 ), // 765 nm\n    vec3( 0.000083, 0.000030, 0.000000 ), // 770 nm\n    vec3( 0.000059, 0.000021, 0.000000 ), // 775 nm\n    vec3( 0.000042, 0.000015, 0.000000 )  // 780 nm\n);\nfloat standardObserver1931_w_min = 380.0f;\nfloat standardObserver1931_w_max = 780.0f;\nint standardObserver1931_length = 81;\n\nvec3 WavelengthToXYZLinear( float fWavelength )\n{\n    float fPos = ( fWavelength - standardObserver1931_w_min ) / (standardObserver1931_w_max - standardObserver1931_w_min);\n    float fIndex = fPos * float(standardObserver1931_length);\n    float fFloorIndex = floor(fIndex);\n    float fBlend = clamp( fIndex - fFloorIndex, 0.0, 1.0 );\n    int iIndex0 = int(fFloorIndex);\n    int iIndex1 = iIndex0 + 1;\n    iIndex1 = min( iIndex1, standardObserver1931_length - 1);\n\n    return mix( standardObserver1931[iIndex0], standardObserver1931[iIndex1], fBlend );\n}\n\nvec3 XYZtosRGB( vec3 XYZ )\n{\n    // XYZ to sRGB\n    // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n   mat3 m = mat3 (\n        3.2404542, -1.5371385, -0.4985314,\n\t\t-0.9692660,  1.8760108,  0.0415560,\n \t\t0.0556434, -0.2040259,  1.0572252 );\n    \n    return XYZ * m;\n}\n\nvec3 sRGBtoXYZ( vec3 RGB )\n{\n   // sRGB to XYZ\n   // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n\n   mat3 m = mat3(  \t0.4124564,  0.3575761, 0.1804375,\n \t\t\t\t\t0.2126729,  0.7151522, 0.0721750,\n \t\t\t\t\t0.0193339,  0.1191920, 0.9503041 );\n    \n    \n    return RGB * m;\n}\n\nvec3 WavelengthToXYZ( float f )\n{    \n    //return xyzFit_1931( f ) * mXYZtoSRGB;\n    \n    return WavelengthToXYZLinear( f );\n}\n\n\nstruct Chromaticities\n{\n    vec2 R, G, B, W;\n};\n    \nvec3 CIE_xy_to_xyz( vec2 xy )\n{\n    return vec3( xy, 1.0f - xy.x - xy.y );\n}\n\nvec3 CIE_xyY_to_XYZ( vec3 CIE_xyY )\n{\n    float x = CIE_xyY[0];\n    float y = CIE_xyY[1];\n    float Y = CIE_xyY[2];\n    \n    float X = (Y / y) * x;\n    float Z = (Y / y) * (1.0 - x - y);\n        \n\treturn vec3( X, Y, Z );        \n}\n\nvec3 CIE_XYZ_to_xyY( vec3 CIE_XYZ )\n{\n    float X = CIE_XYZ[0];\n    float Y = CIE_XYZ[1];\n    float Z = CIE_XYZ[2];\n    \n    float N = X + Y + Z;\n    \n    float x = X / N;\n    float y = Y / N;\n    float z = Z / N;\n    \n    return vec3(x,y,Y);\n}\n\nChromaticities Primaries_Rec709 =\nChromaticities(\n        vec2( 0.6400, 0.3300 ),\t// R\n        vec2( 0.3000, 0.6000 ),\t// G\n        vec2( 0.1500, 0.0600 ), \t// B\n        vec2( 0.3127, 0.3290 ) );\t// W\n\nChromaticities Primaries_Rec2020 =\nChromaticities(\n        vec2( 0.708,  0.292 ),\t// R\n        vec2( 0.170,  0.797 ),\t// G\n        vec2( 0.131,  0.046 ),  \t// B\n        vec2( 0.3127, 0.3290 ) );\t// W\n\nChromaticities Primaries_DCI_P3_D65 =\nChromaticities(\n        vec2( 0.680,  0.320 ),\t// R\n        vec2( 0.265,  0.690 ),\t// G\n        vec2( 0.150,  0.060 ),  \t// B\n        vec2( 0.3127, 0.3290 ) );\t// W\n\nmat3 RGBtoXYZ( Chromaticities chroma )\n{\n    // xyz is a projection of XYZ co-ordinates onto to the plane x+y+z = 1\n    // so we can reconstruct 'z' from x and y\n    \n    vec3 R = CIE_xy_to_xyz( chroma.R );\n    vec3 G = CIE_xy_to_xyz( chroma.G );\n    vec3 B = CIE_xy_to_xyz( chroma.B );\n    vec3 W = CIE_xy_to_xyz( chroma.W );\n    \n    // We want vectors in the directions R, G and B to form the basis of\n    // our matrix...\n    \n\tmat3 mPrimaries = mat3 ( R, G, B );\n    \n    // but we want to scale R,G and B so they result in the\n    // direction W when the matrix is multiplied by (1,1,1)\n    \n    vec3 W_XYZ = W / W.y;\n\tvec3 vScale = inverse( mPrimaries ) * W_XYZ;\n    \n    return transpose( mat3( R * vScale.x, G * vScale.y, B * vScale.z ) );\n}\n\nmat3 XYZtoRGB( Chromaticities chroma )\n{\n    return inverse( RGBtoXYZ(chroma) );\n}\n\n// chromatic adaptation\n\n// http://www.brucelindbloom.com/index.html?Eqn_ChromAdapt.html    \n\n// Test viewing condition CIE XYZ tristimulus values of whitepoint.\nvec3 XYZ_w = vec3( 1.09850,\t1.00000,\t0.35585); // Illuminant A\n// Reference viewing condition CIE XYZ tristimulus values of whitepoint.\nvec3 XYZ_wr = vec3(0.95047,\t1.00000,\t1.08883); // D65\n\n\nconst mat3 CA_A_to_D65_VonKries = mat3(\n    0.9394987, -0.2339150,  0.4281177,\n\t-0.0256939,  1.0263828,  0.0051761,\n \t0.0000000,  0.0000000,  3.0598005\n    );\n\n\nconst mat3 CA_A_to_D65_Bradford = mat3(\n    0.8446965, -0.1179225,  0.3948108,\n\t-0.1366303,  1.1041226,  0.1291718,\n \t0.0798489, -0.1348999,  3.1924009\n    );\n\n\nconst mat3 mCAT_VonKries = mat3 ( \n    0.4002400,  0.7076000, -0.0808100,\n\t-0.2263000,  1.1653200,  0.0457000,\n \t0.0000000,  0.0000000,  0.9182200 );\n\nconst mat3 mCAT_02 = mat3( \t0.7328, 0.4296, -0.1624,\n\t\t\t\t\t\t\t-0.7036, 1.6975, 0.0061,\n \t\t\t\t\t\t\t0.0030, 0.0136, 0.9834 );\n\nconst mat3 mCAT_Bradford = mat3 (  0.8951000, 0.2664000, -0.1614000,\n\t\t\t\t\t\t\t\t-0.7502000,  1.7135000,  0.0367000,\n \t\t\t\t\t\t\t\t0.0389000, -0.0685000,  1.0296000 );\n\n\nmat3 GetChromaticAdaptionMatrix()\n{\n    //return inverse(CA_A_to_D65_VonKries);    \n    //return inverse(CA_A_to_D65_Bradford);\n        \n    //return mat3(1,0,0, 0,1,0, 0,0,1); // do nothing\n    \n\t//mat3 M = mCAT_02;\n    //mat3 M = mCAT_Bradford;\n    mat3 M = mCAT_VonKries;\n    //mat3 M = mat3(1,0,0,0,1,0,0,0,1);\n    \n    vec3 w = XYZ_w * M;\n    vec3 wr = XYZ_wr * M;\n    vec3 s = w / wr;\n    \n    mat3 d = mat3( \n        s.x,\t0,\t\t0,  \n        0,\t\ts.y,\t0,\n        0,\t\t0,\t\ts.z );\n        \n    mat3 cat = M * d * inverse(M);\n    return cat;\n}\n\nfloat BlackBody( float t, float w_nm )\n{\n    float h = 6.6e-34; // Planck constant\n    float k = 1.4e-23; // Boltzmann constant\n    float c = 3e8;// Speed of light\n\n    float w = w_nm / 1e9;\n\n    // Planck's law https://en.wikipedia.org/wiki/Planck%27s_law\n    \n    float w5 = w*w*w*w*w;    \n    float o = 2.*h*(c*c) / (w5 * (exp(h*c/(w*k*t)) - 1.0));\n\n    return o;    \n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define SPP 2\n\nfloat ior;\n\nstruct Hit\n{\n    vec3 ro;//ray origin\n    float td;//travelled distance\n    vec3 rh;//ray hit position\n    vec3 rd;//ray direction\n    vec3 no;//normal at the hit position\n    float id;//hit object id\n    //other material stuff\n};\n\nstruct Mat\n{\n    vec3 col; //color\n    vec3 emi; //emission\n    float rgh; //roughness\n};\n\nMat getMaterial(float id)\n{\n    Mat outmat;\n    outmat.col = vec3(1.0);\n    outmat.emi = vec3(0.0);\n    outmat.rgh = 0.3;\n    return outmat;\n}\n\nvec3 opU( vec3 d, float iResult, float mat ) {\n\treturn (iResult < d.y) ? vec3(d.x, iResult, mat) : d;\n}\n\nconst float density = 0.003;\n\nfloat iVolume( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal )\n{\n    float d = -log(rand())/density;\n    \n    if (d < distBound.x || d > distBound.y) \n    {\n        return MAX_DIST;\n    } \n    else \n    {\n    \treturn d;\n    }\n}\n\nHit worldhit(in vec3 ro, in vec3 rd, in vec2 dist) {\n    vec3 normal;\n    vec3 tmp0, tmp1, d = vec3(dist, 0.);\n    \n    \n    \n    d = opU(d, iPlane      (ro,                  rd, d.xy, normal, vec3(0,1,0), 0.), 1.);\n    \n    d = opU(d, iBox        (ro-vec3( 1,.252, -1), rd, d.xy, normal, vec3(.25)), 2.);\n    d = opU(d, iSphere     (ro-vec3( 0,.252, 0), rd, d.xy, normal, .25), 3.);\n    d = opU(d, iSphere     (ro-vec3( 0.6,.252, 0.2), rd, d.xy, normal, .25), 3.);\n    d = opU(d, iSphere     (ro-vec3( -0.5,.252, 0.1), rd, d.xy, normal, .25), 3.);\n    d = opU(d, iVolume     (ro, rd, d.xy, normal), 4.0);\n\n    Hit res;\n    res.ro = ro;\n    res.rh = ro + d.y*rd;\n    res.rd = rd;\n    res.no = normal;\n    res.id = d.z;\n    res.td = d.y;\n    return res;\n}\n\nvoid processHit(Hit res, inout vec3 ro, inout vec3 rd, inout float inside, inout vec3 col, inout vec3 att)\n{\n    Mat m = getMaterial(res.id);\n    \n    col += att*m.emi;\n    att *= m.col;\n    vec3 normal = res.no;\n    if(res.id < 4.0)\n    {\n        if(res.id == 3.0)\n        {\n            ro = res.rh ;\n             \n            vec3 matn = normalize(nrand3(0.005, normal*inside));\n            vec3 newrd = refract(rd, matn, pow(1.0 + 1.2*ior, -inside));\n            if(length(newrd) > 0.5) //not total internal reflection\n            {\n                inside = -inside;\n                rd = newrd;\n            }\n            else\n            {\n                rd =reflect(rd, matn); \n            } \n        }\n        else\n        {\n            //surface scatter\n            rd = reflect(res.rd, normalize(nrand3(m.rgh, normal))); \n            ro = res.rh + inside*res.no*5e-3;\n        }\n      \n    } \n    else\n    {\n        //volume scatter\n        rd = udir(rand2());\n        ro = res.rh;\n    }\n}\n\n\n#define LASER_PATH 7\nint cpath;\nvec3 path[LASER_PATH+1];\n\nfloat getClosestLinePoint(vec3 ro, vec3 rd, vec3 x)\n{\n    return dot(rd, x - ro);\n}\n\nfloat rand(float a, float b)\n{\n    return mix(a, b, rand());\n}\n\n//Importance sample a point on a segment so that the probability of sampling a point on the segment r1 r2\n//is inversely proportional to the square of the distance to point x\nvec3 importanceSampleSegmentPoint(vec3 r1, vec3 r2, vec3 x)\n{\n    vec3 x0 = r1 - x;\n    vec3 rd = normalize(r2 - r1);\n    float l = length(r2 - r1);\n    float a = dot(rd, x0);\n    float x02 = dot(x0, x0);\n    float sq = sqrt(x02 - a*a); \n    float t = sq*tan(rand(atan(a/sq),atan((l + a)/sq))) - a;\n    return r1 + rd*t; //importance sampled point\n}\n\n//get closest point pair for 2 segments\nvoid getClosestPointPair(vec3 r00, vec3 r01, vec3 r10, vec3 r11, out vec3 P1, out vec3 P2)\n{\n  vec3 delta1 = r01 - r00;\n  vec3 delta2 = r11 - r10;\n  vec3 rd1 = normalize(delta1);\n  vec3 rd2 = normalize(delta2);\n  float l1 = length(delta1);\n  float l2 = length(delta2);\n  vec3 delta3 = r00 - r10;\n  float d1d2 = dot(rd1, rd2);\n  float d1de = dot(rd1, delta3);\n  float d2de = dot(rd2, delta3);\n  float deno = 1.0/(1.0 - d1d2*d1d2);\n  float t1 = (d1d2*d2de - d1de)*deno;\n  float t2 = (d2de - d1d2*d1de)*deno;\n  \n  if(t1 < 0.0 || t1 > l1)\n  {\n      t1 = clamp(t1, 0.0, l1);\n      P1 = r00 + t1*rd1;\n      t2 = clamp(getClosestLinePoint(r10, rd2, P1), 0.0, l2);\n      P2 = r10 + t2*rd2;\n      return;\n  }\n  \n  if(t2 < 0.0 || t2 > l2)\n  {\n      t2 = clamp(t2, 0.0, l2);\n      P2 = r10 + t2*rd2;\n      t1 = clamp(getClosestLinePoint(r00, rd1, P2), 0.0, l1);\n      P1 = r00 + t1*rd1;\n      return;\n  }\n  \n   P1 = r00 + t1*rd1;\n   P2 = r10 + t2*rd2;\n}\n\n//choose a laser path segment p0 p1 with probability proportional to the path segment lenght and \n//inverse distance to the camera ray path segment r0 r1\nvoid importanceSamplePath(vec3 r0, vec3 r1, out vec3 p0, out vec3 p1)\n{\n    float score[LASER_PATH];\n    float totalscore = 0.0;\n    vec3 P0, P1;\n    for(int i = 0; i < cpath; i++)\n    {\n        getClosestPointPair(r0,r1,path[i],path[i+1],P0,P1);\n        float s = distance(path[i],path[i+1])/distance(P0,P1);\n        totalscore += s;\n        score[i] = totalscore;\n    }\n    \n    //target score\n    float rscore = rand()*totalscore;\n    \n    for(int i = 0; i < cpath; i++)\n    {\n        if(rscore < score[i]) //found score\n        {\n            p0 = path[i];\n            p1 = path[i+1];\n            return;\n        }\n    }\n}\n\n//next event estimation sample using the light path\nvoid connectPath(Hit res, inout vec3 col, inout vec3 att)\n{\n    //camera ray path\n    vec3 r0 = res.ro;\n    vec3 r1 = res.rh;\n    \n    //get random path\n    vec3 p0, p1;\n    importanceSamplePath(r0,r1,p0,p1);\n    \n    //find 2 closest points on camera segment and light path \n    vec3 s1, s2;\n    getClosestPointPair(p0, p1, r0, r1, s1, s2); \n    \n    vec3 pathp = importanceSampleSegmentPoint(p0, p1, s2);\n    vec3 camp = importanceSampleSegmentPoint(r0, r1, s1);\n    \n    //trace a ray from the camp to pathp\n    vec3 delta = pathp - camp;\n    float td = length(delta);\n    \n    \n    Hit con = worldhit( camp, normalize(delta), vec2(.001, td));\n    \n    if(con.td >= td) col += att/(td+1e-10);\n    //col += att*pathhit(res.ro, res.rd, res.td);\n}\n\nbool getRay(vec2 uv, out vec3 ro, out vec3 rd)\n{\n    mat3 cam = getCam(get(CamA));\n    vec2 apert_cent = -0.*uv; \n    vec2 ap = aperture();  \n    if(!(distance(ap, apert_cent) < 1.0)) return false;  \n    float apd = length(ap);  \n    vec3 daperture = ap.x*cam[0] + ap.y*cam[1]; \n    ro = get(CamP).xyz + aperture_size*daperture;\n    float focus =2.5 + 0.8*pow(apd,5.0);\n    rd = normalize(focus*(cam*vec3(FOV*uv, 1.0)) - aperture_size*daperture);\n    return true;\n}\n\nvec4 render(vec2 fragCoord)\n{\n    fragCoord += nrand2(0.5, vec2(0.));\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n   \n    vec3 ro, rd, normal;\n  \n    // get a random refractive index different per pixel\n    ior = 0.7*(rand() - 0.5);\n    //ior = -0.2;\n    //ior = (fract(gl_FragCoord.y/3.)-.5);\n    //slightly more realistic dispesion law\n    float id=1./(1.0 + ior);\n    // compute index of refraction associated color \n    vec3 scol = WavelengthToXYZLinear(350.0*(ior + 0.5) + 350.0);\n     ior = id;\n     \n    //trace laser   \n    ro = get(RayO).xyz;\n    rd = normalize(get(RayD).xyz + 0.01*udir(rand2()));\n    \n    float inside = 1.0;\n    \n    vec3 col = vec3(0.0);\n    vec3 att = scol;\n    \n    \n    for(cpath = 0; cpath < LASER_PATH - 1; cpath++)\n    {\n        path[cpath] = ro;\n        Hit res = worldhit( ro, rd, vec2(.001, MAX_DIST));\n        if (res.id > 0.) \n        {\n            processHit(res,ro,rd,inside,col,att);\n        }\n        else \n        {\n            ro = res.rh;\n            break;\n        }\n    }\n    path[cpath+1] = ro;\n    \n    if(!getRay(uv, ro, rd)) return vec4(0,0,0,1);\n    \n    col = vec3(0.0);\n    att = scol;\n    inside = 1.0;\n    \n    for(int i = 0; i < 5; i++)\n    {\n        Hit res = worldhit( ro, rd, vec2(.001, MAX_DIST));\n        \n        connectPath(res, col, att);\n        processHit(res,ro,rd,inside,col,att);\n    }\n   \n    return vec4(col, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    rng_initialize(fragCoord, iFrame);\n\n    fragColor = vec4(0.0);\n    for(int i = 0; i < SPP; i++)\n        fragColor += clamp(render(fragCoord),-0.2e3,0.2e3);\n       \n    \n    mat3 prevcam = getCam(get(PrevCamA));\n    vec3 prevcamp = get(PrevCamP).xyz;\n    \n    vec3 ro, rd;\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    getRay(uv, ro, rd);\n    \n    Hit res = worldhit( ro, rd, vec2(.001, MAX_DIST));\n    \n     vec3 cv = get(CamV).xyz;\n    vec3 rep = reproject(prevcam, prevcamp, iResolution.xy, ro + rd*res.td);\n    float reject = 0.975*float(all(lessThan(rep.xy, iResolution.xy)) && all(greaterThan(rep.xy,vec2(0))));\n    reject *= smoothstep(5.0, 0.0, length(cv));\n    fragColor += texture(iChannel0, rep.xy/iResolution.xy)*reject;\n   \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}