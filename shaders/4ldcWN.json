{
    "Shader": {
        "info": {
            "date": "1532695406",
            "description": "the quest to making a distance field indicator smooth and directional, and as general as possible.\nuseful to estimate scattering for a cheesy sun.\n\nthis tries to unify a rainbow, scattering, a gradient indicator, & a bad whiteBalance/atmospheric/blackbody",
            "flags": 0,
            "hasliked": 0,
            "id": "4ldcWN",
            "likes": 8,
            "name": "genral rainbow scatter",
            "published": 3,
            "tags": [
                "scattering",
                "rainbow",
                "generalization"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 571
        },
        "renderpass": [
            {
                "code": "\n\n//the shape is a placeholder for a glyph that has parametric circles/lines/width, as a placeholder for [any letter]\n//it has mirror symmetry to have dynamit width set easily.\n//it is measured twice, to aim for overlapping glyphs with different colors.\n//goal was to deferr the sqrt(), to do less sqrt, but in the end , vectorizing the sqrt is the best i could do.\n//the hart lesson here is that only with offset==0 yo can do min() before sqrt()\n//- i keep trying to delay the sqrt after the min()&max() but it results in [offset boolean algebra], likely unwanted overlapping/unions/intersections.\n\n//error, if 2 glyphs happen to have perfectly overapping segments, they have a [colring-dispute]\n//intersections are almost fine here, the dispute is the a [laplachian discontinuity]\n\n\n//2 lesons here; \n//- the min of an offset root must com eafter the a=abs(sqrt(a))-offset);ot it becomes [offset booean algebra]\n//- - cute but not wanted here.\n//if i want 2 glyphs in the same cell with 2 colors, i must to 2 times; root(vec2()); once for each offset.\n//there is no deferring of roots here, only vectrizing.\n\n#define ViewZoom 1.\n\n#define pi acos(-1.)\n#define sat(x)clamp(x,0.,1.)\n#define dd(a)dot(a,a)\n#define u5(a)((a)*.5+.5)\n#define u2(a)((a)*2.-1.)\n#define ss(a,u)smoothstep(a,-a,u)\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\nv0 suv(v3 a){return dot(v3(1),a);}v0 suv(v2 a){return dot(v2(1),a);}\nv0 suv(v1 a){return a.x+a.y;}//sum of vector\nv0 mav(v1 a){return max(a.y,a.x);}v0 mav(v2 a){return max(a.z,mav(a.xy));}v0 mav(v3 a){return max(mav(a.zw),mav(a.xy));}\n#define miv(a)-mav(-a)\n\n#define fra(u)(u-.5*iResolution.xy)*ViewZoom/iResolution.y\nvec2 fra2(vec2 u){float r=iResolution.x/iResolution.y;u-=.5;u*=ViewZoom;u.x*=r;return u;}//fra2(u)=fra(u*iResolution)\n\n\n\n//modulo with offset, hg_sdf\n//float pMod(float t,float d){return mod(t+d*.5,d)-d*.5;}\n//#define pMod(x,d) (mod(x+d*.5,d)-d*.5)\n\n// https://en.wikipedia.org/wiki/Error_function#Approximation_with_elementary_functions\n//float Erf(float x){float xx=x*x;float xxa=xx*.147;return sqrt(1.-exp(-xx*(xxa+4./pi)/(xxa+1.)))*sign(x);}\n//float ErfI(float x){float a=1./.147,b=2./pi/.147,u=log(1.-x*x),c=u*.5+b;return sqrt(sqrt(c*c-u*a)-c)*sign(x);}\n\n/*\n//float analstretch(float a,float b){b*=.5;return sign(a-b)*max(abs(a-b)-b,0.);} //stretch() is only stretching to positive.\n#define stretch2(a,b)sign(a)*max(abs(a)-b,0.)\n#define stretch(a,b)stretch2(a-b*.5,b*.5)\n\nvec2 glyph2(vec2 u,vec2 m){vec2 c=vec2(0)\n ;c.x=dd(vec2(abs(u.x)-m.x-m.y,stretch(u.y,m.y*3.)))\n ;c.y=dd(vec2(stretch(u.x,m.x),abs(u.y)-m.y))\n ;c.x=miv(c)\n ;u.x=abs(u.x)-m.x//+m.y //thee +m.y makes the mirror symmetry weird\n ;c.y=dd(u)\n ;return c;}\n\nvec2 glyph3(vec2 u,vec2 m){u.y-=m.y*3.-.4;u.x-=m.x*2.-.2;return glyph2(u,m);}//is the same shape as glyph2() but [a semitone higher] and offset for overlap.\nvec3 bilin(vec3 a,vec3 b,vec3 c,vec3 d,vec2 z){return mix(mix(a,b,z.x),mix(c,d,z.x),z.y);}\n\n\nvec3 glyphs(vec2 u,vec2 m\n){m.y=abs(m.y)\n ;vec3 c=vec3(1) \n //;c=glyph(u,m)\n ;vec2 n=m;\n ;n.x=abs(n.x)\n ;vec2 e=glyph2(u,n)\n ;vec2 f=glyph3(u,n)//2 different glyph shapes, but with the same prameters/offsets/radii\n ;vec4 j=vec4(e,f);j.yz=j.zy\n ;j=sqrt(j) //at least we vectorized 4 sqrt's of 2 overlapping glyphs, while maintaining egment colorID\n ;j.zw=abs(j.zw-m.y)\n ;float d1=min(j.x,j.z)\n ;float d2=min(j.y,j.w)//2 distances as if they would be a special case ofthis generalization;\n ;vec2 gt=vec2(sign(d1-d2),sign(min(j.x,j.y)-min(j.z,j.w)))*.5+.5//gt is either (0,0);(0,1);(1,0);or(1,1), fot bilinear mixing.\n ;c.x=min(d1,d2);c=c.xxx\n ;vec2 i=vec2(-1,1)*sign(m.x)*.01\n ;c=smoothstep(i.x,i.y,c)\n ;c*=bilin(vec3(1,0,0),vec3(0,1,0),vec3(0,0,1),vec3(1,1,0),gt)\n ;return c;}\n*/\n\n/*\n//general [Poeter-Duff] \"Compositing Digital Images\" siggraph 1984;\n// https://en.wikipedia.org/wiki/Alpha_compositing\n// https://doc.qt.io/archives/qq/qq17-compositionmodes.html \n//\n//#define pdC(a,b,c,d,m,f)mix(a,b,m.w)*c*d*f+pdCx(a,b,c,d,m)\nvec3 pdC(vec3 a,vec3 b,float c,float d,vec4 m,float f){\n return mix(a,b,m.w)*f*c*d\n  +b*m.z*(1.-c)\n  +a*m.y*(1.-d);}//many contextual simplifications possible.\n#define pdA(c,d,m)suv(m*vec3(c*d,c*(1.-d),d*(1.-c)))\n//#define pdA(c,d,m)m.x*c*d+m.y*c*(1.-d)+m.z*d*(1.-c)\n//\n//xor case is simpler,likely worth making it a subroutine of pdC;\n//#define pdCx(a,b,c,d,m)m.y*a*(1.-d)+m.z*b*(1.-c)\n//vec3 pdCx(vec3 a,vec3 b,float c,float d){return a*d+b*c;}\n//\nvec4 pd(vec4 a,vec4 b,vec4 m,float f){\n vec4 r=vec4(pdC(a.rgb,b.rgb,a.w,b.w,m,f),1);//ceneral case color\n r.w   =pdA(a.w,b.w,m.rgb);//general case alpha is sometimes neglible.\n return r;}\n//return a*a.w+b*b.w*(1.-a.w);//general case reduction shortcut\nvec4 sOver(vec4 a,vec4 b){return pd(a,b,vec4(1,1,1,0),1.);}\nvec4 sAtop(vec4 a,vec4 b){return pd(a,b,vec4(1,0,1,0),1.);}\nvec4 sIn (vec4 a,vec4 b){return pd(a,b,vec4(1,0,0,1),1.);}\nvec4 sXor(vec4 a,vec4 b){return pd(a,b,vec4(0,1,1,1),0.);}\nvec4 sOut(vec4 a,vec4 b){return pd(a,b,vec4(0,0,1,0),0.);}\nvec4 sCut(vec4 a,vec4 b){return pd(a,b,vec4(0,0,1,1),0.);}\n//pow(2,5)address space for 5 functions seems wastefull.\n//there is either a lot of hidden nonsense or hidden symmetry.\n//it appears there is a ot of mirror symmetry to be reduced here!\n//which then reduces it to only 6 special cases.\n// All the permutations that I tested are rather useless.\n// i need to sleep over this.\n//\n//vec4 sTest(vec4 a,vec4 b){return pd(a,b,vec4(1,0,0,0),0.);}\n//screw all the \"destination*\" functions though.,\n//... these are are all identical to \"source*\" with swapped inputs!.\n//last parameter might be a relict,obsolete.\n//as in,last is identical to first ,always?\n//and the first one basically just swaps a and b inputs?\n//no,xor is clearly different from Atop!\n/**/\n\n//i wanted a general hsv2rgb, and got sidetracked into a rainbow that pseudo-scatters and pseudo-diffracts\nvec4 mixColor(vec4 a,vec4 b,float alpha){return vec4(mix(a.rgb,b.rgb,alpha*b.a),.5);}\nfloat Plot(float x,float y){x-=y;return sat(1.-abs(x*.5/length(vec2(dFdx(x),dFdy(x)))));}\nvec4 drawCurve(vec4 a,float y,float x,vec4 b){return mixColor(a,b,Plot(x,y)*b.w);}//sOver()\nvec3 gradVis(vec3 c,vec2 u,vec2 v){vec3 d=c-u.y-.5;float a=.005\n ;c+=smoothstep(a,-a,abs(fract(v.x)-.5))//vertical white line shows interval\n ;c-=smoothstep(a,-a,abs(abs(u.y)-pi/18.75)) //horizontal black lines show visible range[0..1]\n ;c.xyz=drawCurve(vec4(c,1),u.y*2.,d.z,vec4(0,0,1,1)).xyz\n ;c.xyz=drawCurve(vec4(c,1),u.y*2.,d.y,vec4(0,1,0,1)).xyz\n ;c.xyz=drawCurve(vec4(c,1),u.y*2.,d.x,vec4(1,0,0,1)).xyz;return c;}\n\n\n\n//#define u5(a)((a)*.5+.5)\n#define mad(a,b,c) ((a)*(b)+(c))\n#define ab012(a,b) mad(vec3(0,1,2),b,a)\nvec3 rainbow(float a,float b){return u5(cos(2.*pi*ab012(a,b)));} //sine rainbow with offsets has better continuity\nvec3 rainbow2(float a,float b){return abs(u2(fract(ab012(a,b))));} //triangle rainbow with offsets has likely better precision+performance\n//return fully saturated rgb-interpolated-rainbow (nowhere near modeling scattering)\n//parameter [a] is hue, not sure if the period is [0..1] or [0..3] or [0..b]\n//parameter [b] b=1/3==max-saturation-rbg\n//parameter [b] b=0.5==1.5==only purple and green\n//parameter [b] b=2/3==max-saturation-rgb\n//parameter [b] b=0.0==1.0==monochrome.\n//parameter [b] In-betweens may poorly estimate abberation or Blackbody-hue\n//parameter [b] negative values reverse rainbow-direction over [a]\n//negative b likely will reverse the rainbow.\n//https://www.shadertoy.com/view/4ldcWN\n\n#define c11(a,b) clamp(a/b,-1.,1.)*b\n\n//good rainbow-gradients ALWAYS center green|white and border purple|black\n//m.x sets saturation==transition by shifting blue|red rang[-.1,.5]\n//m.y sets \"flimmer\", range [-.159 ... 159]\n//p is a flimmer-phase that modulates the shorter subwave of red (green) blue;try; p=1.+vec3(-1,0,1)*cos(iGlobalTime*.001)\nvec3 rainbow3(vec2 u,vec2 m,vec3 p\n){vec3 c=vec3(1)//;m=vec2(0)//simple case\n ;m.x=c11(-m.x,.5)//good optional bounds, sign negation for utility.\n ;m.y=c11(m.y,.159)//decent optional bounds to stay in visible range\n ;m.y=m.y*pi+.5\n ;m.y=u5(m.y)\n ;c=rainbow(u.x-m.x*.5,fract(m.x*.6))//the .mx/2 ensures that white/green stays centred and purple stys bordered;\n\n ;c=mix(c*m.y,c,cos(u.x*p*iResolution.x/4.))\n ;vec2 v=u\n ;u.x*=m.y\n ;u.x*=iResolution.y/16.\n ;float g=cos(iTime)//;g=.1//a 3rd domain as time for demoing, whould actually be constant\n ;c=gradVis(c,u,v)\n ;return c;}\n\nvoid mainImage(out vec4 O, vec2 u){\n ;u=fra(u)\n ;vec2 m=fra(iMouse.xy)//;vec2 n=fra(iMouse.zw) \n //;O=vec4(glyphs(u,m),1)\n ;vec3 p=vec3(1)\n ;float h=1.;h=cos(iTime*.001)//demo flimmer clear rainbow with change over time\n //;p=1.+vec3(-1,0,1)*h//demo flimmer clear rainbow\n ;vec3 c=rainbow3(u,m,p)\n ;O=vec4(c,1) ;}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}