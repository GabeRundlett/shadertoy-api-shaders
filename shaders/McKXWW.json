{
    "Shader": {
        "info": {
            "date": "1715203425",
            "description": "I thought it might be fun to make a wave simulation. Then I figured, why not try light? So I did a basic hacky implementation, and suddenly I had reflection, refraction, diffraction, total internal reflection, EVERYTHING! \n\nCode has been upgraded since.",
            "flags": 32,
            "hasliked": 0,
            "id": "McKXWW",
            "likes": 15,
            "name": "wave propagation of light",
            "published": 3,
            "tags": [
                "test"
            ],
            "usePreview": 0,
            "username": "01000001",
            "viewed": 236
        },
        "renderpass": [
            {
                "code": "  // This shader supports being run at whatever paint call rate your hardware can handle\n // (Using the unofficial shadertoy plugin btw)\n// The higher the count, the faster it will converge. \n\n\n\nvoid mainImage( out vec4 O, vec2 U ){\n\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    vec2 cuv = (2.*U-r)/r.y;\n    //U = ((cuv*r.y)+r)/2.\n    \n    vec4 t = texture(iChannel0, uv);\n    \n    O = vec4(\n        //(t.x) * 1. + .5\n        sqrt(t.z*3.)\n    );\n    \n    O.x /= (pow(t.w, .2));\n\n\n    if (cuv.x > graphSize){\n        float x = ((graphSize*r.y)+r.x)/2./r.x;\n        t = texture(iChannel0, vec2(x, uv.y));\n        vec4 dt = texture(iChannel0, vec2(x, uv.y + 1./r.y));\n\n        \n        t.z = min(1., t.z*graphMultiplier); dt.z = min(1., dt.z*graphMultiplier);\n        O = vec4(t.z);\n        \n        x = (r.x/r.y-cuv.x)/(graphThickness);\n        x = 1.-smoothstep(0., (.01 +abs(t.z-dt.z)) * sqrt(2.)*200./(graphThickness*r.y), abs(x - t.z));\n        float f = 1.-t.z;\n        O = mix(O, vec4(f*f, f, sqrt(f), 1), x);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Significant thanks to overlii for helping me understand how to implement\n// a simple wave simulation in https://www.shadertoy.com/view/4sd3WB\n\nconst float pi = 3.1415926;\nfloat lensIOR = 6.5;\n\nfloat objectDistance = 1.;\n\nvoid mainImage( out vec4 O, vec2 U ){\n    \n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    vec2 cuv = (2.*U-r)/r.y;\n    vec2 muv = (2.*iMouse.xy-r)/r.y;\n    \n    if (iFrame < 10){\n        O = vec4(0);\n        return;\n    }\n    \n    \n    objectDistance = 40./r.y;\n        \n    O = texture(iChannel0, uv);\n\n    if (\n    #ifndef free_roam\n        length(cuv - \n            vec2(-.8 * r.x/r.y, \n                #if shape==13\n                0.\n                #else\n                #if shape==14\n                0.\n                #else\n                (cuv.y>0.?objectDistance:-objectDistance)\n                #endif\n                #endif\n            )\n        ) < 5./r.y ||\n    #endif\n    #if shape==15\n        length(cuv+vec2(1.3,0)) < .3 ||\n    #endif\n    #if shape==18\n        length(cuv) < 2./r.y ||\n    #endif\n    (length(cuv-muv) < 5./r.y\n    #ifndef free_roam\n        && iMouse.z > 0.\n    #endif\n    )){\n        // Light source - ocsillating wave height\n        O.x = sin(mod(float(iFrame), 1e5)/\n            #if shape==18\n                (exp(iTime*.1)*2.8)\n            #else \n                2.8\n            #endif\n                                             ); // mod is necessary to prevent the simulation from\n        O.z = mix(O.z, abs(O.x), .01);         // exploding after too many frames\n        return;                               \n    } \n    \n    // x : displacement\n    // y : velocity\n\n    float ior = 1.;\n    float squish = .9;\n    float scale = cos(asin(squish));\n    \n    #if shape==12\n        lensIOR = max(1., (cuv.y + 2.));\n    #endif\n    \n    #if shape==13\n        lensIOR = max(1., 1./(1.-.2/length(cuv)));\n    #endif\n\n    ior = mix(ior, lensIOR, 1.-smoothstep(0., 3./r.y,1.\n        \n        #if shape==0\n            -1. + length(cuv*scale + vec2(cuv.x>0.?squish:-squish, 0)) - 1.\n        #endif\n\n        #if shape==1\n            -1. + max(length(cuv) - .9, -length(cuv) + .8)\n        #endif\n\n        #if shape==2\n            -1. + abs(cuv.x) + abs(cuv.y) - 1.\n        #endif\n        \n        #if shape==3\n            -1. + max(abs(cuv.x) - .1, abs(cuv.y) - .9)\n        #endif\n\n        #if shape==4\n            -1. + abs(cuv.x)-cuv.y*.2 - .2\n        #endif\n        \n        #if shape==5\n            -1. + abs(cuv.x) - cos(cuv.y)*.45 + .2\n        #endif\n        \n        #if shape==6\n            -1. + abs(cuv.x) + cos(cuv.y)*.8 - .9\n        #endif\n        \n        #if shape==7\n            -1. + max(-cuv.x, cuv.x - cos(cuv.y*10.)*.05) - .1\n        #endif        \n        \n        #if shape==12\n            -1. + abs(cuv.x) - .8\n        #endif\n        \n        #if shape==13\n            -1.\n        #endif\n        \n        #if shape==15\n            -1. + min(\n                smoothstep(0.,2./r.y, length(cuv-vec2(0,-.3))-.1),\n                smoothstep(0.,2./r.y, length(cuv-vec2(-.2,.5))-.4)\n            )\n        #endif\n        \n        #if shape==17\n            -1. + texture(iChannel1, uv).x\n        #endif\n        \n    ));\n    \n    \n    float v = 0.,d=O.x;\n    for (float i = 0.; i < 4.; i++){\n        v += texture(iChannel0, uv + vec2(sin(i * pi/2.), cos(i * pi/2.))*vec2(1)/r).x - O.x;\n        #ifdef accurate\n        v += .5*(texture(iChannel0, uv + vec2(sin(i * pi/2. + pi/4.), cos(i * pi/2. + pi/4.))*vec2(1)/r).x - O.x);\n        #endif\n        // This second term was not present in overlii's implementation, but it allows waves to\n        // continue to propagate properly along diagonals in refractive media\n        // Thanks to https://www.mathandcode.com/2024/04/21/waveequationint.html\n    }\n    \n    O.x = O.x + O.y + v / ior * // Adjust height based on velocity and neighbours\n    #ifdef accurate\n    .25\n    #else\n    .5\n    #endif\n    ;\n    O.y = O.x - d; // Velocity = last pos - new pos since timestep is constant per frame\n    O.x *= 1.-2./r.x; // Attentuation based on screen size\n    \n    if (false // Blocker\n        \n        #if shape==0\n            || abs(cuv.x) < .05 && abs(cuv.y) > .9\n        #endif\n        \n        #if shape==1\n            || length(cuv) < .8 && abs(cuv.x) < .1\n        #endif\n        \n        #if shape==2\n            || abs(cuv.x) + abs(cuv.y) < .3\n        #endif\n                \n        #if shape==5\n            || abs(cuv.x) < .08 && abs(cuv.y) > .9\n        #endif\n        \n        #if shape==8\n            || abs(cuv.x) + cuv.y*.1 + .07 < .1\n        #endif        \n        \n        #if shape==9\n            || (\n                abs(cuv.x) + cuv.y*.1 + .103 < .1\n                || abs(cuv.x) - cuv.y*.1 + .103 < .1\n            )\n        #endif\n        \n        #if shape==10\n            || (\n                abs(cuv.x) + cuv.y*.1 + .12 < .1\n                || abs(cuv.x) - cuv.y*.1 + .12 < .1\n                || abs(cuv.x) < 2./r.y && abs(cuv.y) < .18\n            )\n\n        #endif\n        \n        #if shape==11\n            || abs(cuv.x) - sin(cuv.y*20.)*.01 < .01\n        #endif\n        \n        #if shape==13\n            || length((cuv-vec2(-1, .2))/vec2(3, 1)) < .05 \n            || length((cuv - vec2(-1,-.2))/vec2(3, 1)) < .05\n            || (abs(cuv.x+1.) < .1 && abs(cuv.y) > .2)\n        #endif\n        \n        #if shape==14\n            || length(cuv / vec2(r.x/r.y, 1)) > .9\n        #endif\n        \n        #if shape==16\n            || texture(iChannel1, uv).x > .5\n        #endif\n        \n        #if shape==18\n            || max(abs(cuv.x), abs(cuv.y)) > .9\n        #endif\n            \n    ) O.x *= reflectivity;\n    \n    if ( // Margin. If you just multiply the wave by zero, the wave reflects off the surface\n        // like a sound wave bouncing off the open end of a tube it's travelling along,\n       // so we multiply it by .9 so it is absorbed instead of reflected. \n      // This margin can be increased with the other settings in Common.\n        U.x < margin \n        || U.x > r.x - margin \n        || U.y < margin \n        || U.y > r.y - margin\n    ) O.x *= .9;\n    \n    O.z = mix(O.z, abs(O.x)\n    #if shape==15\n        *.2\n    #endif\n    , .01); // Kinda like a capacitor connected to a full wave rectifier,\n                                  // This gives the average amplitude of the wave, aka the light we see\n    \n    #ifdef smooth\n        v = O.z/5.;\n        for (float i = 0.; i < 4.; i++){\n            v += texture(iChannel0, uv + vec2(sin(i * pi/2.), cos(i * pi/2.))*vec2(1)/r / ior ).z/5.;\n        }\n        O.z = v;\n    #endif\n    \n    \n    O.w = ior;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define accurate\n//#define free_roam // aka Photo Mode\n//#define smooth\n\n#define shape 5\n// 0 : Circular Lens\n// 1 : Ring\n// 2 : Square\n// 3 : Bar\n// 4 : Prism\n// 5 : Cosine Lens\n// 6 : Cosine Concave Lens\n// 7 : Wavy\n// 8 : Diffraction\n// 9 : Single Slit\n// 10: Double Slit\n// 11: Multi Slit\n// 12: IOR Gradient\n// 13: Black Hole\n// 14: Ellipse\n// 15: Caustics\n// 16: Buffer B Barriers\n// 17: Buffer B Refractive\n// 18: Chlandni Plate\n// 19: None\n\n// Got a cool preset? Lmk in the comments and I might add it here :)\n\n#define reflectivity .1\n// 1. : Invisible\n// .8 : Low reflectivity\n// .5 : Middle\n// .2 : Diffuse-ish\n// .0 : Perfect Reflection\n\n#define graphMultiplier 10.\n#define margin 2.\n\n\n#define graphSize (.8*r.x/r.y)\n#define graphThickness (r.x/r.y - graphSize)",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}