{
    "Shader": {
        "info": {
            "date": "1634422263",
            "description": "This quadtree traversal is simplified from my last commented verion: [url]https://www.shadertoy.com/view/7dVSRh[/url]\nbut then I went ahead and added reflections to it for only cells with scale == 2.\n\nMouse enabled!",
            "flags": 0,
            "hasliked": 0,
            "id": "7sVXzD",
            "likes": 17,
            "name": "QuadTree Traversal [Reflection]",
            "published": 3,
            "tags": [
                "reflection",
                "quadtree",
                "traverslao"
            ],
            "usePreview": 0,
            "username": "Yusef28",
            "viewed": 356
        },
        "renderpass": [
            {
                "code": "#define pi acos(-1.)\n#define eps 3./iResolution.y\n#define MAX_LEVEL 6.\n#define FAR 40.\n#define reflectiveTileNum pow(2.,floor(mod(iTime/2.,MAX_LEVEL-1.)))*2.\n\n\nmat2 rot(float a){\n    float c = cos(a), s = sin(a); return mat2(c,-s,s,c);}\n    \nfloat rnd(vec2 st){\n    return fract(sin(dot(vec2(12.563,19.99),st)*19.)*9439.8);}\n    \nfloat drawPoint(vec2 uv, vec2 p, float r){\n     return 1.-smoothstep(r-eps, r+eps, length(uv - p));\n}\n\nfloat distLine(vec2 p, vec2 A, vec2 B){\n  vec2 AB = B-A;\n  float t =  clamp(dot(AB,p-A)/dot(AB,AB),0.,1.);\n  vec2 P3 = A + (B-A)*t;\n  return length(P3-p);\n}\n\nfloat drawLine(vec2 uv, vec2 A, vec2 B, float r){\n    return smoothstep(r+eps, r-eps, distLine(uv,A,B));\n}\n\n// SHORTER, NEATER, BRANCHLESS, UNIQUE, SINGULAR PURPOSE\n// This map function returns the largest scaling factor for a given posision\n// the inverse of that is the cell size\nfloat map(vec2 p){\n  float s = 0.5, level = 1.; vec2 CP;\n  for(float i = 1.; i < MAX_LEVEL; i++){\n    s *= 2.;\n    CP = abs( fract(p * s) - 0.5 );\n    //if we don't pass the random check, add max to index so we break\n    i += step( rnd(floor(p * s)), 0.5 ) * MAX_LEVEL;\n  }\n  return s;\n}\n\n//SINGULAR // return the minimum distance to an axis in the rd direction\nvec4 calcT(vec2 p, vec2 rd, vec2 delta){\n    float s = map(p);\n    vec2 t;\n    t.x = rd.x < 0. ? ((p.x*s - floor(p.x*s))/s)*delta.x : ((ceil(p.x*s) - p.x*s)/s)*delta.x; \n    t.y = rd.y < 0. ? ((p.y*s - floor(p.y*s))/s)*delta.y : ((ceil(p.y*s) - p.y*s)/s)*delta.y; \n    vec2 n = t.x < t.y ? vec2(1.,0.) * -sign(rd.x) : \n                         vec2(0.,1.) * -sign(rd.y) ;\n    \n    return vec4(min(t.x,t.y), s, n);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n  uv*=2.;\n  \n  //get local uv scale\n  float s = map(uv);\n  vec2 CP = abs( fract(uv * s) - 0.5 );\n  \n  \n  //make scale 0 wherever the localUV would be an edge\n  //s *= (1.-step(0.5 - 0.002 * s, max(CP.x, CP.y)));\n  //set color to inverse of scale, the cell size at each uv\n  float f = sqrt(s)/(MAX_LEVEL);\n  vec3 col = clamp(vec3(f*f*f,f*f,f), 0., 1.);\n  col = mix(col,vec3(0.,0.,0.1)/max(CP.x, CP.y),float(s==reflectiveTileNum));\n  col *= (1.-step(0.5 - eps * s*1., max(CP.x, CP.y)));\n  \n // col /= ;\n  \n  vec2 ro = vec2(0.5), rd = vec2(-1.,0.);\n  rd *= rot(iTime/8.);\n  if(iMouse.z > 0.5) \n      rd = normalize((iMouse.xy*2.-iResolution.xy)*2./iResolution.y - ro);\n  //col = mix(col, vec3(0.,1.,0.), drawLine(uv,ro,ro+rd*8.,0.01));\n  vec2 delta = 1./max(abs(rd), eps);\n  float t = calcT(ro + rd * .01, rd, delta).x;\n  col = mix(col, vec3(0.,1.,0.), 1.-step(0.03,length(uv-ro)));\n  col = mix(col, vec3(0.,1.,0.), drawLine(uv,ro,ro+rd*t,0.01));\n  //ro += rd * t;\n  \n  //the tricky part of this algorithm as I have it is\n  //I collect t, scale and normal in t_s_n\n  //but the scale is for cell of the current position\n  //the normal is for the cell that we will hit\n  //so for each iteration I have to use the normal found in\n  //the previous interation to because that becomes the normal\n  //as we hit it, which allows for calculating the reflected ray\n  //if we need to reflect\n  vec4 t_s_n; vec2 n;\n  for(float i = 0.; i < FAR; i++){\n  \n    //get t,scale and normal all at once\n    t_s_n = calcT(ro+rd*0.01, rd, delta);\n    \n    //if the scale of the current cell the ro is on is 2,\n    //don't advance the ray, just calculate a relfected ray\n    //and a new delta for that ray, \n    //optionally nudge the ro out in the direction of the normal\n    if(t_s_n.y == reflectiveTileNum) { \n        rd = reflect(rd,n); \n        delta = 1./max(abs(rd), eps);\n        //ro += n*0.01;\n        }\n    \n    //if we hit any other cell, we advance the ray to that cell\n    //and draw the line from oldRo to new o\n    else{\n        vec2 oldRo = ro;\n        ro += rd * t_s_n.x*1.001;\n        col = mix(col, vec3(0.,.8,1.), drawLine(uv,oldRo,ro,0.015));\n        }\n        \n    //save the normal we just approached to use in the nect\n    //iteration\n    n = t_s_n.zw;\n    //draw our hit point\n    col = mix(col, vec3(1.,0.,0.), 1.-step(0.03,length(uv-ro)));\n    }\n\n    col = pow(col,vec3(0.7));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}