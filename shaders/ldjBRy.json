{
    "Shader": {
        "info": {
            "date": "1501007344",
            "description": "Shadertoy Island Adventure\nby pellicus and theGiallo (please add the shared shaders :P )\njust for fun a story about this fantastic contest!\n\nMusic on Buf B",
            "flags": 112,
            "hasliked": 0,
            "id": "ldjBRy",
            "likes": 11,
            "name": "[SH17B] Shadertoy Island",
            "published": 3,
            "tags": [
                "game",
                "island",
                "adventure",
                "sh17b"
            ],
            "usePreview": 1,
            "username": "pellicus",
            "viewed": 1516
        },
        "renderpass": [
            {
                "code": "/*\n              Shadertoy Island Adventure\n\n\n     An ironic take on the Shadertoy adventure theme.\n\t\n\tThe story, all names, characters, and incidents portrayed in this production are fictitious.\n\t\tNo real coconuts or palms were harmed in the making of this adveture game.\n\n\n\n\n\tcontrols:\n\t\t- WASD/arrow keys to move\n\t\t- click+mouse to look around\n\t\t- click on an action and an object on the world and/or inventory \n\t\t- items in inventory are hightlighted by a square.\n\t\t- if an action is selected you cannot move, just click on an action to deselect it\n\n\t\t\n\tprologue:\t\n\t\tYou find yourself in a very beautifull Island ( :J )\n\t\tafter a crash of... your... whatever.\n\t\tYou will have to find out the meaning of this Island and \n\t\tthe way to survive on it.\n\t\tBut you are not alone!\n\t\n     You will find the walkthrough at the end of this file.\n\n\n*/\n\n\n\n\n\n#define CAM_POS      vec2( 0,0)\n#define CAM_ROT      vec2( 1,0)\n#define CAM_VEL      vec2( 2,0)\n#define BASE_CAM_ROT vec2( 3,0)\n#define MOUSE        vec2( 4,0)\n#define GUI_STATE    vec2( 5,0)\n#define OBJ_0        vec2( 6,0) // laptop\n#define OBJ_1        vec2( 7,0) // coconut\n#define OBJ_2        vec2( 8,0) // sunscreen\n#define OBJ_3        vec2( 9,0) // ??\n#define OBJ_4        vec2(10,0) // M_Pallin\n#define OBJ_5        vec2(11,0) // boat\n#define OBJ_6        vec2(12,0) // Bafryce\n#define TEXT_AREA    vec2(14,0)\n#define GAME_STATE   vec2(15,0)\n#define SPLASH_STATE vec2(16,0) // x == 0 se in splash, x == 1 se in game\n\nvec4\nload_value( in vec2 uv_code )\n{\n    return texture( iChannel0, (uv_code+0.5)/iChannelResolution[0].xy, -100.0 );\n}\n\n\nvoid mainImage( out vec4 o,  vec2 c )\n{\n  \n    vec4 splashState = load_value( SPLASH_STATE  );\n\tvec2 uv =  c / iResolution.xy;\n    vec4 spl;spl-=spl;\n    \n    if(splashState.x==1.)\n    {\n        \n     if(uv.y < 0.25 && c.y>1. )\n     {\n      \n         \to = texture(iChannel0,c/iChannelResolution[0].xy);\n       \n     }\n    }\n    else\n    {\t//splash\n        vec2 k=c + vec2(cos(iTime),sin(iTime));\n        \n        vec2 j=k/iResolution.xy;\n        \n          spl= texture(iChannel3,(j.y>.10?vec2(.0,.1):j)+vec2(0.,0.015) )*1.1*sin(iTime*2.);\n  \t\t\n         \n      spl+= texture(iChannel3,(j.y<.217?vec2(.0,.1):j) +vec2(0.,.1));\n         \n\t\tc.y+=0.125*iChannelResolution[0].y;\n        if(uv.y>.875)\n            c.y=1.;\n    }    \n         \n    o +=mix( texture(iChannel1,c/iChannelResolution[1].xy) ,spl,spl.a);\n    o += texture(iChannel2,c/iChannelResolution[2].xy);\n\n    \n}\n\n\n/*\n\n     walkthrough:\n\n\t\tLook around,\n\t\tTalk to the guy on the strange towel. Be stubborn!\n\t\tContinue to talk to him and follow his very clear instructions.\n\t\tGet next to the laptop , click on \"Pick Up\" and click on the object on the ground,\n\t\tIf nothing happens try to be closer.\n\t\tIf an action is selected you cannot move, just click on an action to deselect it\n\t\tGet next to the sun screen bottle (the yellow one) and pick it up,\n\t\tAlso pick up a coconut at the base of the palm.\n\t\tThen go near the Guy on the fancy towel and click on Give then on the laptop icon\n\t\tthen on the Guy.\n\t\tDo the same action with the sunscreen bottle.\n\t\tClick on the action Open and then on the coconut icon in your inventory, this will open it.\n\t\tGive the open coconut to the Guy.\n\t\tTalk to the Guy, he will tell you to Open the lapton.\n\t\tGo near the lapton on the table.\n\t\tClick Open then the laptop on the table.\n\t\tTalk to the Guy\n\t\tClick Pull then the laptop on the table (we can't find another better use of the \n\t\taction \"Pull\" , do you agree? :D)\n\t\tTalk to the Guy\n\t\tUse the laptop\n\t\tTalk to the Guy\n\t\tClick Push then the laptop \n\t\tTalk to the Guy\n\t\tTurn around toward the see and  SBAM!\n\t\tLook at what happened! \n\t\tTalk to the new Guy :D\n\t\tIf you could understand him probably you already know him for real :D.\n\t\tIf you don't understand him probably you never joined the ShaderToy 280 characters contests.\n\t\tIf you need to go away... take the boat\n\t\tor... stay on the ShaderToy Island and make it beautifull for real :D it deserves that :D\n\n\t\tthank you for reading this walkthrough :D\n\n\n*/\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Ben Quantock 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//----------------------------------------------------------------------------------------------\n// FP CONTROLS CONFIG\n#define INVERT_Y 0\n\nconst float accel = .2;\nconst float decay = .5; // how much velocity is preserved per frame (proportionally)\n\n#if INVERT_Y\nconst float yMul = 1.0;\n#else\nconst float yMul = -1.0;\n#endif\n// FP CONTROLS CONFIG end\n//----------------------------------------------------------------------------------------------\n// UTILITIES\n\n#define SQRT2 1.4142135623730950488016887242096980785696\n#define PI    3.1415926535897932384626433832795\n#define HPI   1.57079632679489661923132169\n#define QPI   0.785398163397448309615660845819875721\n#define TAU   6.283185307179586476925286766559\nfloat\npow2( float v )\n{\n    if ( v >= 0. )\n    {\n    \treturn float( 1 << int(v) );\n    }\n    return 1. / float( 1 << int(-v) );\n}\n\nfloat\nminv( in vec2 v )\n{\n    return min( v.x, v.y );\n}\n\nfloat\nmaxv( in vec2 v )\n{\n    return max( v.x, v.y );\n}\n\nfloat\nminv( in vec3 v )\n{\n    return min( v.x, min( v.y, v.z ) );\n}\n\nfloat\nmaxv( in vec3 v )\n{\n    return max( v.x, max( v.y, v.z ) );\n}\n\nfloat\nminv( in vec4 v )\n{\n    return min( minv(v.xy), minv( v.zw ) );\n}\n\n#if 0 \n// ray tracing stuff\nfloat rPlane(vec3 o,vec3 d,vec4 pn)\n{\n    float num = pn.w - dot(pn.xyz,o);\n    float denom = dot(pn.xyz,d);\n    float t = num/denom;\n   // if(t>PRECISION_STEP)\n        return t;\n    return 1e999;\n}\n\n\nfloat rSphere(vec3 o, vec3 d, vec3 c, float r)\n{\n    vec3 e= c - o;\n    float a= dot(e, d);\n    float b= r*r - dot(e,e) + a*a;\n    if(b>0.0)\n    {\n        float t = a- sqrt(b);\n       // if(t>PRECISION_STEP)\n            return t;\n    }\n   return 1e999;\n}\n#endif\n\n// UTILITIES end\n//----------------------------------------------------------------------------------------------\n\n// keys are javascript keycode\n/*\nconst int K_A = 65; const int K_B = 66; const int K_C = 67; const int K_D = 68; const int K_E = 69;\nconst int K_F = 70; const int K_G = 71; const int K_H = 72; const int K_I = 73; const int K_J = 74;\nconst int K_K = 75; const int K_L = 76; const int K_M = 77; const int K_N = 78; const int K_O = 79;\nconst int K_P = 80; const int K_Q = 81; const int K_R = 82; const int K_S = 83; const int K_T = 84;\nconst int K_U = 85; const int K_V = 86; const int K_W = 87; const int K_X = 88; const int K_Y = 89;\nconst int K_Z = 90;\nconst int K_0 = 48; const int K_1 = 49; const int K_2 = 50; const int K_3 = 51; const int K_4 = 52;\nconst int K_5 = 53; const int K_6 = 54; const int K_7 = 55; const int K_8 = 56; const int K_9 = 57;\n*/\nconst int K_Space = 32;\nconst int K_F = 70;\nconst int K_A = 65, K_D = 68,K_W = 87,K_S=83;\nconst int K_Left = 37, K_Up = 38,K_Right = 39,K_Down=40;\n\nfloat ReadKeyInternal( int key, bool toggle )\n{\n\treturn textureLod( iChannel0, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ), 0.0 ).x;\n}\n\nfloat Key( int key )\n{\n\treturn ReadKeyInternal(key,false);\n}\n\nfloat KeyDown( int key )\n{\n\treturn ReadKeyInternal(key,true);\n}\n\n\n//----------------------------------------------------------------------------------------------\n// LOAD/STORE\n\n#if 0\n//NOTE(theGiallo): old stuff\n#define storage_system()  vec2 r_inx=vec2(0.0);vec2 w_inx=vec2(0.0);fragColor = vec4(0.0);\n#define var(vr) vec4 vr = texture( iChannel3, (0.5+r_inx) / iChannelResolution[3].xy, -100.0 );r_inx+=vec2(1.,0.);\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nfloat isInside( vec2 p, vec4 c ) { vec2 d = abs(p-0.5-c.xy-c.zw*0.5) - 0.5*c.zw - 0.5; return -max(d.x,d.y); }\n\nvoid storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\nvoid storeValue( in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\n\n#define save(vr) storeValue(w_inx,vr,fragColor, fragCoord);w_inx+=vec2(1.,0.);\n#define tab(arr,inx) loadValue(vec2(inx,arr))\n#define savet(arr,inx,v) storeValue(vec2(inx,arr),v,fragColor, fragCoord)\n#else\n\n#define CAM_POS      vec2( 0,0)\n#define CAM_ROT      vec2( 1,0)\n#define CAM_VEL      vec2( 2,0)\n#define BASE_CAM_ROT vec2( 3,0)\n#define MOUSE        vec2( 4,0)\n#define GUI_STATE    vec2( 5,0)\n#define OBJ_0        vec2( 6,0) // laptop\n#define OBJ_1        vec2( 7,0) // coconut\n#define OBJ_2        vec2( 8,0) // sunscreen\n#define OBJ_3        vec2( 9,0) // ??\n#define OBJ_4        vec2(10,0) // M_Pallin\n#define OBJ_5        vec2(11,0) // boat\n#define OBJ_6        vec2(12,0) // Bafryce\n#define TEXT_AREA    vec2(14,0)\n#define GAME_STATE   vec2(15,0)\n#define SPLASH_STATE vec2(16,0) // x == 0 se in splash, x == 1 se in game\n\n#define OBJ_LAPTOP   OBJ_0\n#define OBJ_COCONUT  OBJ_1\n#define OBJ_SSCREEN  OBJ_2\n//#define OBJ_UNKNOWN  OBJ_3\n#define OBJ_M_PALLIN OBJ_4\n#define OBJ_BOAT     OBJ_5\n#define OBJ_BAFRYCE  OBJ_6\n\n#define GUI_INV_HAS(i) ( 1. == floor( mod( guiState.z / pow2((i)-1.), 2. ) ) )\n#define GUI_INV_SET(i) if ( !GUI_INV_HAS(i) ) { guiState.z += pow2((i)-1.); }\n#define GUI_INV_RM(i) if ( GUI_INV_HAS(i) ) { guiState.z -= pow2((i)-1.); }\n\n#define GUI_CLOSE 1.\n#define GUI_TALK  2.\n#define GUI_PULL  3.\n#define GUI_OPEN  4.\n#define GUI_LOOK  5.\n#define GUI_PUSH  6.\n#define GUI_GIVE  7.\n#define GUI_PICK  8.\n#define GUI_USE   9.\n\n#define OBJ_V_LAPTOP   1.\n#define OBJ_V_COCONUT  2.\n#define OBJ_V_SSCREEN  3.\n#define OBJ_V_3 4.\n#define OBJ_V_M_PALLIN 5.\n#define OBJ_V_BOAT     6.\n#define OBJ_V_BAFRYCE  7.\n\n#define MAX_PICK_DISTANCE 3.\n#define MAX_TALK_DISTANCE 8.\n\n/*\n NOTE(theGiallo):\n GUI_STATE -\n\tguiState.x contiene l'id del bottone della gui selezionato,\n\t           da 1. a 9., con 0. che significa niente di selezionato.\n\tguiState.y contiene l'id dell'oggetto nell'inventario selezionato,\n\t           da 1. a 4., con 0. che significa niente di selezionato.\n\tguiState.z contiene i booleani della presenza degli oggetti nell'inventario,\n\t           con 1. 2. 4. 8. da interagirci con le macro\n\t              GUI_INV_HAS( i )\n\t              GUI_INV_SET( i )\n\t              GUI_INV_RM( i )\n\t           con i da 1. a 4. .\n*/\n\n/*\nNOTE(theGiallo):\nACT_N are: give laptop, give coconut, use/give sscreen\nLAP_N are: open laptop, pull laptop, use laptop, push laptop\n*/\n#define GAME_STATE_CLEAN     0.\n#define GAME_STATE_TALKED_1  1.\n#define GAME_STATE_ACT_1     2.\n#define GAME_STATE_ACT_2     3.\n#define GAME_STATE_ACT_3     4.\n//#define GAME_STATE_ACT_4     5.\n#define GAME_STATE_TALKED_2  5.\n#define GAME_STATE_LAP_1     6.\n#define GAME_STATE_TALKED_3  7.\n#define GAME_STATE_LAP_2     8.\n#define GAME_STATE_TALKED_4  9.\n#define GAME_STATE_LAP_3    10.\n#define GAME_STATE_TALKED_5 11.\n#define GAME_STATE_LAP_4    12.\n#define GAME_STATE_TALKED_6 13.\n\n#define GAME_STATE_LAPTOP_CAN_OPEN GAME_STATE_TALKED_2\n#define GAME_STATE_LAPTOP_CAN_PULL GAME_STATE_TALKED_3\n#define GAME_STATE_LAPTOP_CAN_USE  GAME_STATE_TALKED_4\n#define GAME_STATE_LAPTOP_CAN_PUSH GAME_STATE_TALKED_5\n#define GAME_STATE_BOAT_CAN_USE    GAME_STATE_TALKED_6\n                \n#define TEXT_LOOK_LAPTOP      0.\n#define TEXT_LOOK_COCONUT     1.\n#define TEXT_LOOK_SSCREEN     2.\n#define TEXT_LOOK_3           3.\n#define TEXT_LOOK_M_PALLIN    4.\n#define TEXT_LOOK_BOAT        5.\n#define TEXT_LOOK_BAFRYCE     6.\n#define TEXT_TALK_M_PALLIN_0  7.\n#define TEXT_TALK_M_PALLIN_1  8.\n#define TEXT_TALK_M_PALLIN_2  9.\n#define TEXT_TALK_M_PALLIN_3 10.\n#define TEXT_TALK_M_PALLIN_4 11.\n#define TEXT_TALK_M_PALLIN_5 12.\n#define TEXT_TALK_M_PALLIN_6 13.\n#define TEXT_TALK_M_PALLIN_7 14.\n#define TEXT_TALK_BAFRYCE    15.\n\nvec4\nload_value( in vec2 uv_code )\n{\n    return texture( iChannel3, (uv_code+0.5)/iChannelResolution[3].xy, -100.0 );\n}\n\nfloat\nis_inside( vec2 p, vec2 c )\n{\n    vec2 d = abs( p - 0.5 - c ) - 0.5;\n    return - max( d.x, d.y );\n}\nbool\nis_value( in vec2 frag_coord, in vec2 tx_code )\n{\n    return is_inside( frag_coord, tx_code ) > 0.0;\n}\n#define IS_VALUE(c) is_value( fragCoord, c )\n#define STORE(v,c) if ( IS_VALUE(c) ) { fragColor = v; }\n\n#endif\n\n// LOAD/STORE end\n//----------------------------------------------------------------------------------------------\n// GUI\n\nbool\np_inside_rect( vec2 p, vec2 min, vec2 size )\n{\n    vec2 max = min + size;\n    return p.x > min.x && p.x < max.x && p.y > min.y && p.y < max.y;\n}\n\nbool\nclick_in_rect( vec2 min, vec2 size )\n{\n\treturn p_inside_rect( iMouse.zw, min, size ); \n}\n\n#define GUI_BUTTONS_TOTAL_CHARS_COUNT 72\nconst int uitext[GUI_BUTTONS_TOTAL_CHARS_COUNT] = int[GUI_BUTTONS_TOTAL_CHARS_COUNT]\n//(  32,0x47,0x69,0x76,0x65,32,32,32,0x50,0x69,0x63,0x6b,32,0x55,0x70,32,32,32,0x55,0x73,0x65,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,0x4f,0x70,0x65,0x6e,32,32,32,0x4c,0x6f,0x6f,0x6b,32,0x41,0x74,32,32,32,0x50,0x75,0x73,0x68,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,0x43,0x6c,0x6f,0x73,0x65,32,32,0x54,0x61,0x6c,0x6b,32,0x54,0x6f,32,32,32,0x50,0x75,0x6c,0x6c,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32);\n(\n // 0    1    2    3    4    5    6    7     8    9    10   11   12   13   14   15    16   17   18   19   20   21   22   23 \n    32,0x47,0x69,0x76,0x65,32,32,32, 32,0x50,0x69,0x63,0x6b,32,0x55,0x70, 32,32,32,0x55,0x73,0x65,32,32,\n    32,0x4f,0x70,0x65,0x6e,32,32,32, 32,0x4c,0x6f,0x6f,0x6b,32,0x41,0x74, 32,32,32,0x50,0x75,0x73,0x68,32,\n    32,0x43,0x6c,0x6f,0x73,0x65,32,32, 32,0x54,0x61,0x6c,0x6b,32,0x54,0x6f, 32,32,32,0x50,0x75,0x6c,0x6c,32\n);\n// GUI end\n//----------------------------------------------------------------------------------------------\n// FONT\n\nvec4\nchar( vec2 p, int c )\n{\n    if ( p.x < .0 || p.x > 1. || p.y < 0.|| p.y > 1.) return vec4(0,0,0,1e5);\n    //if (p.x<.25|| p.x>.75 || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5); // strange bug\n    #if 0\n\treturn textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                        dFdx(p/16.),dFdy(p/16.) );\n    #else\n\treturn texture( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ) ); \n    #endif\n  //float l = log2(length(fwidth(p/16.*iResolution.xy)));\n  //return textureLod( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), l);\n                   // manual MIPmap to avoid border artifact. Should be textureLod, but don't available everywhere\n}\nint CAPS=0;\n#define low CAPS=32\n#define caps CAPS=0\n#define C(c) U.x-=.5; O+= char(U,64+CAPS+c)\n\n// FONT end\n//----------------------------------------------------------------------------------------------\n// RAY MARCHING\n\nfloat\nsphere_sd( in float sph_r, in vec3 p )\n{\n    return length( p ) - sph_r;\n}\n\nfloat\naab_sd( in vec3 sides, in vec3 p )\n{\n    sides *= 0.5;\n    p = abs( p );\n    vec3 d = p - sides;\n    return min( maxv( d ), 0.0 ) + length( max(d,0.0) );\n}\n\nfloat\ncapped_cylinder_sd( in vec2 rh, in vec3 p )\n{\n    vec2 d = abs( vec2( length( p.xy ), p.z ) ) - rh;\n    return min( maxv(d), 0.0 ) + length( max(d, 0.0) );\n}\n\n\nvec3\nat_pos( in vec3 pos, in vec3 p )\n{\n    return p-pos;\n}\n\n/*\nmat4\ntr( mat4 m )\n{\n    return mat4(\n       vec4(m[0][0],m[1][0],m[2][0],m[3][0]),\n       vec4(m[0][1],m[1][1],m[2][1],m[3][1]),\n       vec4(m[0][2],m[1][2],m[2][2],m[3][2]),\n       vec4(m[0][3],m[1][3],m[2][3],m[3][3])\n    );\n}\n\nvec3\nrotate( in vec3 r, in vec3 p )\n{\n\tmat4 Rx = mat4(\n\t   vec4( 1.0, 0.0,      0.0,       0.0 ),\n\t   vec4( 0.0, cos(r.x), -sin(r.x), 0.0 ),\n\t   vec4( 0.0, sin(r.x),  cos(r.x), 0.0 ),\n\t   vec4( 0.0, 0.0,      0.0,       0.0 ) );\n\tmat4 Ry = mat4(\n\t   vec4(  cos(r.y), 0.0, sin(r.y), 0.0 ),\n\t   vec4(  0.0,      1.0, 0.0,      0.0 ),\n\t   vec4( -sin(r.y), 0.0, cos(r.y), 0.0 ),\n\t   vec4(  0.0,      0.0, 0.0,      1.0 ) );\n\tmat4 Rz = mat4(\n\t   vec4( cos(r.z), -sin(r.z), 0.0, 0.0 ),\n\t   vec4( sin(r.z),  cos(r.z), 0.0, 0.0 ),\n\t   vec4( 0.0,      0.0,       1.0, 0.0 ),\n\t   vec4( 0.0,      0.0,       0.0, 1.0 ) );\n\tmat4 m = Rx * Ry * Rz;\n\treturn (vec4(p,1.0)*m).xyz;\n}\n*/\nvec3\nrotate_inv( in vec3 r, in vec3 p )\n{\n    r = -r;\n\tmat4 Rx = mat4(\n\t   vec4( 1.0, 0.0,      0.0,       0.0 ),\n\t   vec4( 0.0, cos(r.x), -sin(r.x), 0.0 ),\n\t   vec4( 0.0, sin(r.x),  cos(r.x), 0.0 ),\n\t   vec4( 0.0, 0.0,      0.0,       0.0 ) );\n\tmat4 Ry = mat4(\n\t   vec4(  cos(r.y), 0.0, sin(r.y), 0.0 ),\n\t   vec4(  0.0,      1.0, 0.0,      0.0 ),\n\t   vec4( -sin(r.y), 0.0, cos(r.y), 0.0 ),\n\t   vec4(  0.0,      0.0, 0.0,      1.0 ) );\n\tmat4 Rz = mat4(\n\t   vec4( cos(r.z), -sin(r.z), 0.0, 0.0 ),\n\t   vec4( sin(r.z),  cos(r.z), 0.0, 0.0 ),\n\t   vec4( 0.0,      0.0,       1.0, 0.0 ),\n\t   vec4( 0.0,      0.0,       0.0, 1.0 ) );\n\tmat4 m = Rz * Ry * Rx;\n\treturn (vec4(p,1.0)*m).xyz;\n}\n\nvec3\nat_angle( in vec3 a, in vec3 p )\n{\n    return rotate_inv( a, p );\n}\n\nvec3\ncamera_ray( vec4 camPos, vec4 camRot, vec2 uv )\n{\n    vec3 ret = normalize( vec3( uv, 1 ) );\n    ret.zy = ret.zy*cos(camRot.x) + sin(camRot.x)*vec2(1,-1)*ret.yz;\n    ret.xz = ret.xz*cos(camRot.y) + sin(camRot.y)*vec2(1,-1)*ret.zx;\n    return ret;\n}\n#define CAMERA_RAY() camera_ray( camPos, camRot, (fragCoord.xy-iResolution.xy*vec2(.5,.75*.25))/iResolution.x )\n#define MOUSE_RAY()  camera_ray( camPos, camRot, (   iMouse.zw-iResolution.xy*vec2(.5,.75*.25))/iResolution.x )\n\n\n// RAY MARCHING end\n//----------------------------------------------------------------------------------------------\n\nconst float island_r = 500.;\nconst vec3 island_center = vec3(-island_r+170.,0,-island_r+170.);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 splash_state  = load_value( SPLASH_STATE );\n    #define CAMERA_Y 1.8\n\tfragColor -= fragColor; // NOTE(theGiallo): this initializes to 0 at boot\n    if ( iFrame == 0 || splash_state.x == -1. )\n    {\n        if ( IS_VALUE(OBJ_LAPTOP) )\n    \t{\n            fragColor = vec4( 17, 0, 10, 0 );\n        } else\n        if ( IS_VALUE(OBJ_COCONUT) )\n    \t{\n            fragColor = vec4(0.1, 0.07, 1.5, 0 );\n        } else\n        if ( IS_VALUE(OBJ_SSCREEN) )\n    \t{\n            fragColor = vec4( 14.5, 0, 9.5, 0 );\n        } else\n        if ( IS_VALUE(OBJ_3) )\n    \t{\n            fragColor = vec4( 10000, -100, 100000, 0 );\n        } else\n        if ( IS_VALUE(CAM_ROT) )\n    \t{\n        \tfragColor = vec4( .0425, PI*1.145, 0, 0 ) * TAU;\n        }else\n        if ( IS_VALUE(CAM_POS) )\n    \t{\n        \tfragColor = vec4( 20, CAMERA_Y, 20, 0 );\n        } else\n        if ( IS_VALUE( OBJ_M_PALLIN ) )\n\t\t{\n            fragColor = vec4(10,.2,12,0);\n        } else\n        if ( IS_VALUE( OBJ_BOAT ) )\n        {\n            fragColor = vec4(30,.0,20,1);\n        } else\n        if ( IS_VALUE( OBJ_BAFRYCE ) )\n        {\n            fragColor = vec4(island_center,0) + vec4(0,201.4,0,0);\n        } else\n        if ( IS_VALUE( TEXT_AREA ) )\n        {\n            fragColor = vec4(-1);\n        }\n        return;\n    }\n    \n\n\t//storage_system();\n\tvec2 uv = fragCoord / iResolution.xy;\n    vec2 gui_button_size = iResolution.xy / vec2(6.,12.);\n    vec2 gui_base_inventory = vec2( iResolution.x * .5, 0);\n    vec2 gui_inventory_slot_size = iResolution.xy / vec2( 8., 4.);\n    vec4 guiState   = load_value( GUI_STATE    );\n    vec4 gameState  = load_value( GAME_STATE   );\n    //vec4 splash_state  = load_value( SPLASH_STATE );\n    \n    \n    #if 0\n    /*\n\tif ( IS_VALUE(CAM_ROT) )\n    {\n        fragColor = vec4( .0425, 0, 0, 0 ) * TAU;\n    } else\n    if ( IS_VALUE(CAM_POS) )\n    {\n        fragColor = vec4( 1, 200. + CAMERA_Y, 1, 0 );\n        fragColor.xyz += island_center;\n    } else\n\n    if ( IS_VALUE(SPLASH_STATE) )\n    {\n        fragColor = vec4( 1, 0, 0, 0 );\n        return;\n    } else\n    if ( IS_VALUE(OBJ_COCONUT) )\n    {\n        fragColor.xyz =  load_value( OBJ_M_PALLIN ).xyz + vec3(-0.1,.2,-.1);\n        fragColor.w = 0.;\n        return;\n    } else\n    if ( IS_VALUE( OBJ_LAPTOP ) )\n    {\n        fragColor.xyz = vec3(9.9,0.93,9.9);\n        fragColor.w = 0.0;\n        return;\n    }*/\n    if ( IS_VALUE( OBJ_BAFRYCE ) )\n    {\n                fragColor.xyz = vec3(20,1.5,20);\n        return;\n    }\n    if ( IS_VALUE( OBJ_BOAT ) )\n    {\n                fragColor.w = 0.;\n        return;\n    }\n\n    //else discard;\n      //  return;\n    #endif\n    \n    \n    #if 0\n    // NOTE(theGiallo): setting some objs in inventory for testing\n    GUI_INV_SET( 2. );\n    GUI_INV_SET( 3. );\n    GUI_INV_RM(  3. );\n    GUI_INV_SET( 4. );\n    #endif\n\n    if ( fragCoord.y < 2. )\n    {\n   \n        #if 0\n        var(camPos);\n        var(camRot);\n        var(camVel);\n        var(baseCamRot);\n        var(gameState);\n\t\t#else\n        vec4 camPos      = load_value( CAM_POS      );\n        vec4 camRot      = load_value( CAM_ROT      );\n        vec4 camVel      = load_value( CAM_VEL      );\n        vec4 baseCamRot  = load_value( BASE_CAM_ROT );\n        vec4 old_mouse   = load_value( MOUSE        );\n        vec4 obj_laptop  = load_value( OBJ_LAPTOP   );\n        vec4 obj_coconut = load_value( OBJ_COCONUT  );\n        vec4 obj_sscreen = load_value( OBJ_SSCREEN  );\n        vec4 obj_3       = load_value( OBJ_3        );\n        vec4 obj_mpallin = load_value( OBJ_M_PALLIN );\n        vec4 obj_boat    = load_value( OBJ_BOAT     );\n        vec4 obj_bafryce = load_value( OBJ_BAFRYCE  );\n        vec4 textArea    = load_value( TEXT_AREA    );\n        vec4 game_state  = load_value( GAME_STATE   );\n        #endif\n        \n\n        if ( IS_VALUE( CAM_POS )\n         ||  IS_VALUE( CAM_ROT )\n         ||  IS_VALUE( CAM_VEL )\n         ||  IS_VALUE( BASE_CAM_ROT )\n           )\n        {\n            if ( splash_state.x == 1. )\n            {\n                bool clicked_on_view = iMouse.w > iResolution.y * .25 && guiState.x == 0.;\n\t\t\t\tvec4 oldCamPos=camPos;\n                camPos += camVel;\n                float cd=distance(camPos.xz, island_center.xz);\n                if(cd>island_r+2. || cd<island_r-50. || distance(camPos.xz,vec2(20))>50.)\n                    camPos=oldCamPos;\n                \n                if ( camPos.y < CAMERA_Y ) camPos.y = CAMERA_Y;\n\n                vec2 mouseRot = ( iMouse.yx / iResolution.yx - .5 ) * vec2( .5 * yMul, 1. ); \n                camRot.w = clicked_on_view ? iMouse.z : -1.;\n\n                bool press = camRot.w > .0;\n                bool lastPress = baseCamRot.w > .0;\n                bool click = press && !lastPress;\n                if ( click )\n                {\n                    baseCamRot.xy -= mouseRot * TAU;\n                }\n\n                if ( press )\n                {\n                    camRot.xy = baseCamRot.xy + mouseRot * TAU;\n                    //camRot.x = clamp( baseCamRot.y + camRot.x, 0., HPI) - baseCamRot.y;\n                }\n                else\n                {\n                    //update the base pos\n                    baseCamRot = camRot;\n                }\n\n                baseCamRot.w = camRot.w;\n\n                vec3 forward = vec3(0,0,1)*accel;\n                vec3 right = vec3(1,0,0)*accel;\n\n                vec4 rot = camRot;\n                forward.xz = forward.xz*cos(rot.y) + sin(rot.y)*vec2(1,-1)*forward.zx;\n                right.xz = right.xz*cos(rot.y) + sin(rot.y)*vec2(1,-1)*right.zx;\n\n                if ( guiState.x == 0. )\n                {\n                    camVel.xyz += (Key(K_W)-Key(K_S)) * forward;\n                    camVel.xyz += (Key(K_Up)-Key(K_Down)) * forward;\n                    camVel.xyz += (Key(K_Right)-Key(K_Left)) * right;\n                    \n                    camVel.xyz += (Key(K_D)-Key(K_A)) * right;\n                }\n\n                camVel *= decay; // exponential decay\n\n                camVel.y -= .01;\n\n                //if ( camPos.y <= .0 )\n                //{\n                //    camVel.y = (Key(K_Space) != .0) ? .3 : 0.0;\n                //}\n                }\n            STORE( camPos, CAM_POS );\n            STORE( camRot, CAM_ROT );\n            STORE( camVel, CAM_VEL );\n            STORE( baseCamRot, BASE_CAM_ROT );\n            #if 0\n            save(camPos);\n            save(camRot);\n            save(camVel);\n            save(baseCamRot);\n            save(gameState);\n            #endif\n        } else\n        if ( IS_VALUE( GUI_STATE ) )\n        {\n            if ( splash_state.x == 1.0 )\n            {\n                if ( guiState.x != 0. && guiState.w != 0. )\n                {\n                    if ( guiState.x == GUI_GIVE\n                        && guiState.w == OBJ_V_M_PALLIN\n                        && ( guiState.y == OBJ_V_LAPTOP\n                             || ( guiState.y == OBJ_V_COCONUT\n                                  && game_state.z == 1.  ) )\n                        && ( game_state.x == GAME_STATE_TALKED_1\n                            ||  game_state.x == GAME_STATE_ACT_1\n                            ||  game_state.x == GAME_STATE_ACT_2\n                            ||  game_state.x == GAME_STATE_ACT_3 ) \n\n                        || ( guiState.x == GUI_GIVE\n                            && guiState.w == OBJ_V_M_PALLIN\n                            && guiState.y == OBJ_V_COCONUT\n                            && game_state.z == 1. )\n                       )\n                    {\n                        GUI_INV_RM( guiState.y );\n                    }\n                    // NOTE(theGiallo): after interacting with the 3D world, clear state\n                    guiState.x = guiState.y = guiState.w = 0.;\n                }\n                if ( ( guiState.x == GUI_OPEN && guiState.y == OBJ_V_COCONUT\n                       && guiState.w == 0.0 /*&& game_state.z == 0.0*/ )\n                    \n                    || ( guiState.x == GUI_GIVE && guiState.y == OBJ_V_COCONUT\n                        && guiState.w != 0.0 && game_state.z == 1.0 )\n                    \n                    || ( ( guiState.x == GUI_USE || guiState.x == GUI_GIVE )\n                          && guiState.y == OBJ_V_SSCREEN\n                          && guiState.w != 0.0 )\n                    )\n                {\n                    guiState.x = guiState.y = 0.0;\n                }\n\n                if ( old_mouse.z < .0 && iMouse.z >= 0. )\n                {\n                    if ( all(lessThan(iMouse.zw,gui_button_size * 3. )) )\n                    {\n                        #if 0\n                        for ( float i = 0.; i  < 9.; ++i )\n                        {\n                            vec2 i2 = vec2( mod( i, 3. ), floor( i / 3. ) );\n                            if ( click_in_rect( i2 * gui_button_size, gui_button_size ) )\n                            {\n                                guiState.x = guiState.x == i + 1. ? 0. : i + 1.;\n                            }\n                        }\n                        #else\n                        vec2 i2 = floor( iMouse.zw / gui_button_size );\n                        float i = i2.x + i2.y * 3.;\n                        guiState.x = guiState.x == i + 1. ? 0. : i + 1.;\n                        #endif\n                    } else\n                    if ( click_in_rect( gui_base_inventory, iResolution.xy * vec2(.5,.25) ) )\n                    {\n                        vec2 rm = iMouse.zw - gui_base_inventory;\n                        float i = 1. + floor( rm.x / gui_inventory_slot_size.x );\n                        if ( GUI_INV_HAS( i ) )\n                        {\n                            guiState.y = guiState.y == i ? 0. : i;\n                        }\n                    } else\n                    if ( iMouse.w > iResolution.y * .25\n                      && guiState.x != 0.\n                       )\n                    {\n                        // NOTE(theGiallo): click on 3D world\n                        vec3 ray = MOUSE_RAY();\n                        float t = 0.;\n                        float selected_id = 0.;\n                        for ( int i=0; i !=64; ++i )\n                        {\n                            vec3 p = camPos.xyz + ray * t;\n                            float d[7] = float[7](\n                                sphere_sd( .5, at_pos( obj_laptop.xyz, p ) )  + 1e37 * obj_laptop.w,\n                                sphere_sd( obj_coconut.y > 0.07 ? .07:.2, at_pos( obj_coconut.xyz, p ) ) + 1e37 * obj_coconut.w,\n                                sphere_sd( .3, at_pos( obj_sscreen.xyz, p ) ) + 1e37 * obj_sscreen.w,\n                                sphere_sd( 1., at_pos( obj_3.xyz, p ) )       + 1e37 * obj_3.w,\n\n                                capped_cylinder_sd( vec2(.2,.9),  at_pos( obj_mpallin.xyz,    p ) ),                         // M_PALLIN\n                                capped_cylinder_sd( vec2(4.,1.5), at_angle(vec3(HPI,0,0), at_pos( obj_boat.xyz,   p) ) ) + 1e37 * obj_boat.w, // boat\n                                capped_cylinder_sd( vec2(.3,.9),  at_angle(vec3(HPI,0,0), at_pos( obj_bafryce.xyz,  p) ) )     // bafryce\n                            );\n                            for ( int id = 0; id != 7; ++id )\n                            {\n                                if ( d[id] < 0.01 )\n                                {\n                                    selected_id = float(id) + 1.;\n                                    break;\n                                }\n                            }\n                            if ( selected_id != 0. )\n                            {\n                                if ( guiState.x == GUI_PICK )\n                                {\n                                    if ( t > MAX_PICK_DISTANCE || selected_id > 4. )\n                                    {\n                                        selected_id = 0.;\n                                    } else\n                                    {\n                                        GUI_INV_SET( selected_id );\n                                    }\n                                } else\n                                if ( guiState.x == GUI_TALK && t > MAX_TALK_DISTANCE )\n                                {\n                                    selected_id = 0.;\n                                }\n                                break;\n                            }\n                            t += min( minv( vec4( d[0], d[1], d[2], d[3] ) ), minv(vec3(d[4],d[5],d[6])) );\n                        }\n                        guiState.w = selected_id;\n                    }\n                }\n            }\n            fragColor = guiState;\n        }\n        else\n        if ( IS_VALUE(OBJ_LAPTOP) )\n    \t{\n            fragColor = obj_laptop;\n            if ( guiState.x == GUI_PICK\n              && guiState.w == OBJ_V_LAPTOP\n               )\n            {\n                fragColor.w = 1.;\n            }\n            if ( guiState.x == GUI_GIVE\n              && guiState.w == OBJ_V_M_PALLIN\n              && guiState.y == OBJ_V_LAPTOP\n             && ( game_state.x == GAME_STATE_TALKED_1\n              ||  game_state.x == GAME_STATE_ACT_1\n              ||  game_state.x == GAME_STATE_ACT_2\n              ||  game_state.x == GAME_STATE_ACT_3 ) )\n            {\n        \t\tfragColor.xyz = vec3(9.9,0.83,9.9);\n                fragColor.w = 0.;\n            }\n        } else\n        if ( IS_VALUE(OBJ_COCONUT) )\n    \t{\n            fragColor = obj_coconut;\n            if ( guiState.x == GUI_PICK\n              && guiState.w == OBJ_V_COCONUT\n             && ( game_state.x == GAME_STATE_TALKED_1\n              ||  game_state.x == GAME_STATE_ACT_1\n              ||  game_state.x == GAME_STATE_ACT_2\n              ||  game_state.x == GAME_STATE_ACT_3 ) )\n            {\n                fragColor.w = 1.;\n            }\n            if ( guiState.x == GUI_GIVE\n              && guiState.w == OBJ_V_M_PALLIN\n              && guiState.y == OBJ_V_COCONUT\n              && game_state.z == 1. )\n            {\n        \t\tfragColor.xyz =  obj_mpallin.xyz + vec3(-0.1,.2,-.1);\n                fragColor.w = 0.;\n            }\n        } else\n        if ( IS_VALUE(OBJ_SSCREEN) )\n    \t{\n            fragColor = obj_sscreen;\n            if ( guiState.x == GUI_PICK && guiState.w == OBJ_V_SSCREEN\n             && ( game_state.x == GAME_STATE_TALKED_1\n              ||  game_state.x == GAME_STATE_ACT_1\n              ||  game_state.x == GAME_STATE_ACT_2\n              ||  game_state.x == GAME_STATE_ACT_3 )\n               && game_state.y == 0. )\n            {\n                fragColor.w = 1.;\n            }\n        } else\n        if ( IS_VALUE(OBJ_3) )\n    \t{\n            fragColor = obj_3;\n            if ( guiState.x == GUI_PICK && guiState.w == OBJ_V_3\n             && ( game_state.x == GAME_STATE_TALKED_1\n              ||  game_state.x == GAME_STATE_ACT_1\n              ||  game_state.x == GAME_STATE_ACT_2\n              ||  game_state.x == GAME_STATE_ACT_3 ) )\n            {\n                fragColor.w = 1.;\n            }\n        } else\n        if ( IS_VALUE(OBJ_M_PALLIN) )\n    \t{\n            fragColor = obj_mpallin;\n        } else\n        if ( IS_VALUE(OBJ_BOAT) )\n    \t{\n            fragColor = obj_boat;\n            if ( guiState.x == GUI_PUSH && guiState.w == 1.\n              && gameState.x == GAME_STATE_LAPTOP_CAN_PUSH )\n            {\n                fragColor.w = 0.;\n            }\n        } else\n        if ( IS_VALUE(OBJ_BAFRYCE) )\n    \t{\n            fragColor = obj_bafryce;\n            if ( guiState.x == GUI_PUSH && guiState.w == 1.\n              && gameState.x == GAME_STATE_LAPTOP_CAN_PUSH )\n            {\n                fragColor.xyz = vec3(20,1.5,20);\n            }\n        } else\n        if ( IS_VALUE(TEXT_AREA) )\n    \t{\n            fragColor = textArea;\n            if ( guiState.x == GUI_LOOK && guiState.w > 0. && guiState.w <= 4. )\n            {\n                fragColor.x = guiState.w - 1.;\n            }\n            if ( guiState.x == GUI_LOOK\n              && guiState.w == OBJ_V_M_PALLIN )\n            {\n                fragColor.x = TEXT_LOOK_M_PALLIN;\n            } else\n            if ( guiState.x == GUI_LOOK\n              && guiState.w == OBJ_V_BOAT )\n            {\n                fragColor.x = TEXT_LOOK_BOAT;\n            } else\n            if ( guiState.x == GUI_LOOK\n              && guiState.w == OBJ_V_BAFRYCE )\n            {\n                fragColor.x = TEXT_LOOK_BAFRYCE;\n            } else\n            if ( guiState.x == GUI_TALK\n              && guiState.w == OBJ_V_M_PALLIN )\n            {\n                if ( game_state.x == GAME_STATE_CLEAN )\n                {\n                    fragColor.x = TEXT_TALK_M_PALLIN_0;\n                } else\n                if ( game_state.x == GAME_STATE_TALKED_1 )\n                {\n                    fragColor.x = TEXT_TALK_M_PALLIN_1;\n                } else\n                if ( game_state.x == GAME_STATE_ACT_1\n                  || game_state.x == GAME_STATE_ACT_2 )\n                {\n                    fragColor.x = TEXT_TALK_M_PALLIN_2;\n                } else\n                if ( game_state.x == GAME_STATE_ACT_3\n                  || game_state.x == GAME_STATE_TALKED_2 )\n                {\n                    fragColor.x = TEXT_TALK_M_PALLIN_3;\n                } else\n                if ( game_state.x == GAME_STATE_LAP_1\n                  || game_state.x == GAME_STATE_TALKED_3 )\n                {\n                    fragColor.x = TEXT_TALK_M_PALLIN_4;\n                } else\n                if ( game_state.x == GAME_STATE_LAP_2\n                  || game_state.x == GAME_STATE_TALKED_4 )\n                {\n                    fragColor.x = TEXT_TALK_M_PALLIN_5;\n                } else\n                if ( game_state.x == GAME_STATE_LAP_3\n                  || game_state.x == GAME_STATE_TALKED_5 )\n                {\n                    fragColor.x = TEXT_TALK_M_PALLIN_6;\n                } else\n                if ( game_state.x == GAME_STATE_LAP_4\n                  || game_state.x == GAME_STATE_TALKED_6 )\n                {\n                    fragColor.x = TEXT_TALK_M_PALLIN_7;\n                }\n            } else\n            if ( guiState.x == GUI_TALK\n              && guiState.w == OBJ_V_BAFRYCE )\n            {\n                fragColor.x = TEXT_TALK_BAFRYCE;\n            }\n        } else\n        if ( IS_VALUE(GAME_STATE) )\n    \t{\n            fragColor = game_state;\n            \n            if ( guiState.x == GUI_OPEN\n              && guiState.w == 0.\n              && guiState.y == OBJ_V_COCONUT\n              && game_state.z == 0. )\n            {\n                fragColor.z = 1.;\n            }\n            bool just_opened_laptop = false;\n            if (guiState.x == GUI_OPEN\n              && guiState.w == OBJ_V_LAPTOP\n              && guiState.y == 0.\n              && game_state.w == 0.\n              && game_state.x == GAME_STATE_TALKED_2\n               )\n            {\n                fragColor.w = 1.;\n                just_opened_laptop = true;\n            }\n            if (guiState.x == GUI_CLOSE\n              && guiState.w == OBJ_V_LAPTOP\n              && guiState.y == 0.\n              && game_state.w == 1.\n              && game_state.x == GAME_STATE_TALKED_6\n               )\n            {\n                fragColor.w = 0.;\n            }\n            \n            bool sscreen_just_used = false;\n            if (\n               ( guiState.x == GUI_GIVE || guiState.x == GUI_USE )\n              && guiState.w == OBJ_V_M_PALLIN\n              && guiState.y == OBJ_V_SSCREEN\n              && game_state.y == 0. )\n            {\n                sscreen_just_used = true;\n                fragColor.y = 1.;\n            }\n            \n            if (\n               ( guiState.x == GUI_GIVE\n              && guiState.w == OBJ_V_M_PALLIN\n              && guiState.y == OBJ_V_LAPTOP )\n                \n            || ( guiState.x == GUI_GIVE\n              && guiState.w == OBJ_V_M_PALLIN\n              && guiState.y == OBJ_V_COCONUT\n              && game_state.z == 1. )\n                \n            || sscreen_just_used\n                \n            || ( guiState.x == GUI_TALK\n              && guiState.w == OBJ_V_M_PALLIN\n              && ( game_state.x == GAME_STATE_CLEAN\n                || game_state.x == GAME_STATE_ACT_3\n                || game_state.x == GAME_STATE_LAP_1\n                || game_state.x == GAME_STATE_LAP_2\n                || game_state.x == GAME_STATE_LAP_3\n                || game_state.x == GAME_STATE_LAP_4 ) )\n                \n            || just_opened_laptop\n                \n            || ( guiState.x == GUI_PULL\n              && guiState.w == OBJ_V_LAPTOP\n              && game_state.w == 1.0\n              && game_state.x == GAME_STATE_TALKED_3 )\n                \n            || ( guiState.x == GUI_USE\n              && guiState.w == OBJ_V_LAPTOP\n              && game_state.w == 1.0\n              && game_state.x == GAME_STATE_TALKED_4 )\n                \n            || ( guiState.x == GUI_PUSH\n              && guiState.w == OBJ_V_LAPTOP\n              && game_state.w == 1.0\n              && game_state.x == GAME_STATE_TALKED_5 )\n            )\n            {\n                fragColor.x += 1.;\n            }\n        } else\n        if ( IS_VALUE(SPLASH_STATE) )\n        {\n            fragColor = splash_state;\n            if ( Key(K_Space) != 0. )\n            {\n                fragColor.x = 1.;\n            }\n            if ( game_state.x == GAME_STATE_TALKED_6\n              && guiState.x == GUI_USE\n              && guiState.w == OBJ_V_BOAT )\n            {\n                fragColor.x = -1.;\n            }\n        } else\n        STORE( iMouse, MOUSE )\n    } else\n    if ( uv.x <= .5 && uv.y < .25 )\n    {\n        // vec2 uv = fragCoord/iResolution.xy;\n\t\tvec2 textResolution = vec2(48., 12.);\n        vec2 tex = fract(uv * textResolution);\n        vec2 index2 = uv * textResolution - tex;\n        \n\t\t// int index = int(index2.x + 21. - (textResolution.x + 15.) * index2.y)-int(textResolution.x / 2.);\n        int index = int(index2.x +  (2.-index2.y)*textResolution.x/2.);//-int(textResolution.x / 2.);\n       \tif ( index<0 || index >= GUI_BUTTONS_TOTAL_CHARS_COUNT )\n        {\n              index = 0;\n        }\n        int ch = uitext[index];\n        tex.x = (tex.x - 0.5) * .5 + 0.5;\n        tex = clamp(tex, 0.02, 0.98);\n        int ch_m_16 = ch - 16 * ( ch / 16 );\n        tex += vec2(ch_m_16, 15-ch / 16);\n        tex += 0.01;\n        \n        tex /= 16.;\n        \n       \n        float f = texture( iChannel1, tex).x;        \n  \t\t// f *= step( abs(uv.x+0.014)-0.57, 0.0 );\n\t\t// f *= uv2.y;\n      \t// f *= step( st.y, 0.5 );\n        \n        fragColor += f;\n        \n        #if 0\n        for ( float i = 0.; i  < 9.; ++i )\n        {\n            vec2 i2 = vec2( mod( i, 3. ), floor( i / 3. ) );\n            if ( p_inside_rect( fragCoord, i2 * gui_button_size, gui_button_size )\n               && guiState.x == i + 1.\n               )\n            {\n            \t//fragColor.rg = i2 / 3.;\n                fragColor *= vec4( 1,1,0,1 );\n            }\n        }\n        #else\n        vec2 i2 = floor( fragCoord / gui_button_size );\n        float i = i2.x + i2.y * 3.;\n        if ( guiState.x == i + 1. )\n        {\n            //fragColor.rg = i2 / 3.;\n            fragColor *= vec4( 1,1,0,1 );\n        }\n        #endif\n\n        #if 0\n        if ( guiState.x > 0. )\n        {\n            float i = guiState.x -1.;\n            vec2 i2 = vec2( mod( i, 3. ), floor( i / 3. ) );\n            fragColor.rg = i2 / 3.;\n        }\n        #endif\n        \n        // composit\n\t\t// col = mix( col, vec3(1.0,0.8,0.0), clamp(f,0.0,1.0) );\n        \n    } else\n    if ( uv.x > .5 && uv.y < .25 )\n    {\n        vec2 g = (fragCoord-gui_base_inventory) / gui_inventory_slot_size;\n        vec2 i2 = floor( g );\n        float i = 1. + i2.x + i2.y * 3.;\n\n        if ( all( lessThan( abs( fract(g) - .5 ), vec2(.4) ) )\n           && GUI_INV_HAS( i )\n           )\n        {\n        \tfragColor = vec4(.5);\n        }\n        if ( guiState.y == i )\n        {\n            //fragColor.rg = i2 / 3.;\n            fragColor *= vec4( 1,1,0,1 );\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "struct\nScene_Data\n{\n    vec4 objs[8];\n    vec4 mpallin, boat, bafryce;\n    vec4 gameState,splashState;\n};\n\n Scene_Data scene;\n\n//----------------------------------------------------------------------------------------------\n// UTILITIES\n\n#define SQRT2 1.4142135623730950488016887242096980785696\n#define PI    3.1415926535897932384626433832795\n#define HPI   1.57079632679489661923132169\n#define QPI   0.785398163397448309615660845819875721\n#define TAU   6.283185307179586476925286766559\n\n#define D2R(x) ((x)*0.0174532925)\n#define R2D(x) ((x)*57.295779513)\n\nfloat\npow2( float v )\n{\n    if ( v >= 0. )\n    {\n    \treturn float( 1 << int(v) );\n    }\n    return 1. / float( 1 << int(-v) );\n}\n\nfloat\nminv( in vec2 v )\n{\n    return min( v.x, v.y );\n}\n\nfloat\nmaxv( in vec2 v )\n{\n    return max( v.x, v.y );\n}\n\nfloat\nminv( in vec3 v )\n{\n    return min( v.x, min( v.y, v.z ) );\n}\n\nfloat\nmaxv( in vec3 v )\n{\n    return max( v.x, max( v.y, v.z ) );\n}\n\nfloat\nminv( in vec4 v )\n{\n    return min( minv(v.xy), minv( v.zw ) );\n}\n\nfloat\nmanhattan( vec2 p )\n{\n    p = abs ( p );\n    float ret = p.x + p.y;\n    return ret;\n}\nfloat\nmanhattan( vec2 p0, vec2 p1 )\n{\n    float ret;\n    \n    vec2 d = abs ( p1 - p0 );\n    ret = d.x + d.y;\n    \n    return ret;\n}\nfloat\nmanhattan( in vec3 p )\n{\n    p = abs ( p );\n    float ret = p.x + p.y + p.z;\n    return ret;\n}\nfloat\nsum( in vec2 p )\n{\n    float ret = p.x + p.y;\n    return ret;\n}\nfloat\nsum( in vec3 p )\n{\n    float ret = p.x + p.y + p.z;\n    return ret;\n}\n\n#define length3( v ) ( pow(sum(pow3(v)),1.0/3.0) )\n#define length4( v ) ( pow(sum(pow3(v)),1.0/4.0) )\n#define length6( v ) ( pow(sum(pow3(v)),1.0/6.0) )\n#define length8( v ) ( pow(sum(pow3(v)),1.0/8.0) )\n#define pow2(v) (v*v)\n#define pow3(v) (v*v*v)\n\nfloat\npow4( in float v )\n{\n    v = v*v;\n    v = v*v;\n    return v;\n}\nvec2\npow4( in vec2 v )\n{\n    v = v*v;\n    v = v*v;\n    return v;\n}\nvec3\npow4( in vec3 v )\n{\n    v = v*v;\n    v = v*v;\n    return v;\n}\nfloat\npow6( in float v )\n{\n    float ret = v*v;\n    ret = ret*ret;\n    ret = ret * v;\n    return ret;\n}\nvec2\npow6( in vec2 v )\n{\n    vec2 ret = v*v;\n    ret = ret*ret;\n    ret = ret * v;\n    return ret;\n}\nvec3\npow6( in vec3 v )\n{\n    vec3 ret = v*v;\n    ret = ret*ret;\n    ret = ret * v;\n    return ret;\n}\nvec2\npow8( in vec2 v )\n{\n    v = v*v;\n    v = v*v;\n    v = v*v;\n    return v;\n}\nvec3\npow8( in vec3 v )\n{\n    v = v*v;\n    v = v*v;\n    v = v*v;\n    return v;\n}\n\n// UTILITIES end\n//----------------------------------------------------------------------------------------------\n\n//From  Hamneggs  shader \n// https://www.shadertoy.com/view/4d3GRX\n// we started from that very beatifull shader\n// and we tried to uglify everithing :D... and we did it! :D\n// at the beginning the idea it was to try to make something estetically normal\n// but after a while we decide to go toward the trashy/ugly/z-series games gfx.\n     \n     \n#define ITERATIONS 50\n\n//----------------------------------------------------------------------------------------------\n// LOAD/STORE\n\n#if 0\n//NOTE(theGiallo): old stuff\n#define storage_system()  vec2 r_inx=vec2(0.0);vec2 w_inx=vec2(0.0);fragColor = vec4(0.0);\n#define var(vr) vec4 vr = texture( iChannel3, ((r_inx+=vec2(1.,0.))-vec2(0.5,0.)) / iChannelResolution[3].xy, -100.0 )\n#else\n\n#define CAM_POS      vec2( 0,0)\n#define CAM_ROT      vec2( 1,0)\n#define CAM_VEL      vec2( 2,0)\n#define BASE_CAM_ROT vec2( 3,0)\n#define MOUSE        vec2( 4,0)\n#define GUI_STATE    vec2( 5,0)\n#define OBJ_0        vec2( 6,0) // laptop\n#define OBJ_1        vec2( 7,0) // coconut\n#define OBJ_2        vec2( 8,0) // sunscreen\n#define OBJ_3        vec2( 9,0) // ??\n#define OBJ_4        vec2(10,0) // M_Pallin\n#define OBJ_5        vec2(11,0) // boat\n#define OBJ_6        vec2(12,0) // Bafryce\n#define TEXT_AREA    vec2(14,0)\n#define GAME_STATE   vec2(15,0)\n#define SPLASH_STATE vec2(16,0) // x == 0 se in splash, x == 1 se in game\n\n#define OBJ_LAPTOP   OBJ_0\n#define OBJ_COCONUT  OBJ_1\n#define OBJ_SSCREEN  OBJ_2\n//#define OBJ_UNKNOWN  OBJ_3\n#define OBJ_M_PALLIN OBJ_4\n#define OBJ_BOAT     OBJ_5\n#define OBJ_BAFRYCE  OBJ_6\n\n#define OBJ_V_LAPTOP   1.\n#define OBJ_V_COCONUT  2.\n#define OBJ_V_SSCREEN  3.\n#define OBJ_V_3 4.\n#define OBJ_V_M_PALLIN 5.\n#define OBJ_V_BOAT     6.\n#define OBJ_V_BAFRYCE  7.\n\nvec4\nload_value( in vec2 uv_code )\n{\n    return texture( iChannel3, (uv_code+0.5)/iChannelResolution[3].xy, -100.0 );\n}\n\nfloat\nis_inside( vec2 p, vec2 c )\n{\n    vec2 d = abs( p - 0.5 - c ) - 0.5;\n    return - max( d.x, d.y );\n}\nbool\nis_value( in vec2 frag_coord, in vec2 tx_code )\n{\n    return is_inside( frag_coord, tx_code ) > 0.0;\n}\n#define IS_VALUE(c) is_value( fragCoord, c )\n#endif\n\n// LOAD/STORE end\n// RAY MARCHING\n\n\nfloat\nsphere_sd( in float sph_r, in vec3 p )\n{\n    return length( p ) - sph_r;\n}\n\nfloat\naab_sd( in vec3 sides, in vec3 p )\n{\n    sides *= 0.5;\n    p = abs( p );\n    vec3 d = p - sides;\n    return min( maxv( d ), 0.0 ) + length( max(d,0.0) );\n}\n\nfloat\ncapped_cylinder_sd( in vec2 rh, in vec3 p )\n{\n    vec2 d = abs( vec2( length( p.xy ), p.z ) ) - rh;\n    return min( maxv(d), 0.0 ) + length( max(d, 0.0) );\n}\n\n\n\nfloat\nhalf_space_sd( in vec3 p )\n{\n    return p.z;\n}\nfloat\nhalf_space_y_sd( in vec3 p )\n{\n    return p.y;\n}\n\nfloat\nround_aab_ud( in vec3 sides, in float r, in vec3 p )\n{\n    sides *= 0.5;\n    p = abs( p );\n    vec3 d = p - sides;\n    return length( max(d, 0.0) ) - r;\n}\nfloat\ncline_sd( in vec3 a, in vec3 b, in float r, in vec3 p )\n{\n    vec3 ap = p - a, ab = b - a;\n    float t = clamp( dot(ap,ab)/dot(ab,ab), 0.0, 1.0 );\n    return length( ap - ab * t ) - r;\n}\n\nfloat\nellipsoid_sd( in vec3 r3, in vec3 p )\n{\n    return ( length( p/r3 ) - 1.0 ) * minv(r3);\n}\n\nfloat\nsphere3_sd( in float sph_r, in vec3 p )\n{\n    return length3(abs(p)) - sph_r;\n}\nfloat\nsphere4_sd( in float sph_r, in vec3 p )\n{\n    return length4( p ) - sph_r;\n}\n\n\nfloat\nhalf_cone_pos_sd( in vec2 c, in vec3 p )\n{\n    vec2 c1 = vec2(c.y,-c.x);\n    return dot( c1, vec2(length(p.xy), p.z) );\n}\n\nfloat\ncone_sd( in vec2 c, in vec3 p )\n{\n    p = abs(p);\n    vec2 c1 = vec2(c.y,-c.x);\n    return dot( c1, vec2(length(p.xy), p.z) );\n}\n\n\nvec3\nat_pos( in vec3 pos, in vec3 p )\n{\n    return p-pos;\n}\n\nvec2\nunion_op( in vec2 p0, in vec2 p1 )\n{\n    if ( p0.x < p1.x )\n    {\n        return p0;\n    }\n    return p1;\n}\n\nfloat\nsubtract_opf( in float f0, in float f1 )\n{\n    f0 = -f0;\n    if ( f0 > f1 )\n    {\n        return f0;\n    }\n    return f1;\n}\nfloat\ncapped_cone_as_intersections_sd( in float h, in float r1, in float r2, in vec3 p )\n{\n    float R1z = (r1*h)/(r2-r1);\n    float R2z = R1z + h;\n    p = at_pos(vec3(0.0,0.0,-R1z),p);\n\tvec2 c = vec2(r2/R2z,1.0);\n\treturn\n\tmax( max( -half_space_sd( at_pos(vec3(0.0,0.0,R1z), p) ), half_space_sd( at_pos( vec3(0.0,0.0,R2z), p ) ) ),\n         half_cone_pos_sd( c, p )\n       );\n}\nfloat\ncapped_cylindery_sd( in vec2 rh, in vec3 p )\n{\n    vec2 d = abs( vec2( length( p.xz ), p.y ) ) - rh;\n    return min( maxv(d), 0.0 ) + length( max(d, 0.0) );\n}\nfloat\ncapped_cylinder4_sd( in vec2 rh, in vec3 p )\n{\n    vec2 d = abs( vec2( length( p.xy ), p.z ) ) - rh;\n    return min( maxv(d), 0.0 ) + length4( max(d, 0.0) );\n}\nfloat\ncapped_cylinder8_sd( in vec2 rh, in vec3 p )\n{\n    vec2 d = abs( vec2( length8( p.xy ), p.z ) ) - rh;\n    return min( maxv(d), 0.0 ) + length8( max(d, 0.0) );\n}\n\nfloat\ncapped_cylindermh_sd( in vec2 rh, in vec3 p )\n{\n    vec2 d = abs( vec2( manhattan( p.xy ), p.z ) ) - rh;\n    return min( maxv(d), 0.0 ) + manhattan( max(d, 0.0) );\n}\n\n#define union_opf( a, b ) min(a,b)\n\nvec3\nrotate_inv( in vec3 r, in vec3 p )\n{\n    r = -r;\n\tmat4 Rx = mat4(\n\t   vec4( 1.0, 0.0,      0.0,       0.0 ),\n\t   vec4( 0.0, cos(r.x), -sin(r.x), 0.0 ),\n\t   vec4( 0.0, sin(r.x),  cos(r.x), 0.0 ),\n\t   vec4( 0.0, 0.0,      0.0,       0.0 ) );\n\tmat4 Ry = mat4(\n\t   vec4(  cos(r.y), 0.0, sin(r.y), 0.0 ),\n\t   vec4(  0.0,      1.0, 0.0,      0.0 ),\n\t   vec4( -sin(r.y), 0.0, cos(r.y), 0.0 ),\n\t   vec4(  0.0,      0.0, 0.0,      1.0 ) );\n\tmat4 Rz = mat4(\n\t   vec4( cos(r.z), -sin(r.z), 0.0, 0.0 ),\n\t   vec4( sin(r.z),  cos(r.z), 0.0, 0.0 ),\n\t   vec4( 0.0,      0.0,       1.0, 0.0 ),\n\t   vec4( 0.0,      0.0,       0.0, 1.0 ) );\n\tmat4 m = Rz * Ry * Rx;\n\treturn (vec4(p,1.0)*m).xyz;\n}\n\nvec3\nat_angle( in vec3 a, in vec3 p )\n{\n    return rotate_inv( a, p );\n}\n\n\n\n\nvec3\ncamera_ray( vec4 camPos, vec4 camRot, vec2 uv )\n{\n    vec3 ret = normalize( vec3( uv, 1 ) );\n    ret.zy = ret.zy*cos(camRot.x) + sin(camRot.x)*vec2(1,-1)*ret.yz;\n    ret.xz = ret.xz*cos(camRot.y) + sin(camRot.y)*vec2(1,-1)*ret.zx;\n    return ret;\n}\n#define CAMERA_RAY() camera_ray( camPos, camRot, (fragCoord.xy-iResolution.xy*vec2(.5,.75*.25))/iResolution.x )\n\n\n//--------------------- NEW STUFF\n\n#define OCEAN_AND_SAND 0\n\n// Light and reflection penumbra factors.\n#define PENUMBRA_FACTOR 50.0\n// Oren-Nayar material reflectance coefficient.\n#define MAT_REFLECTANCE 4.0\n// Main marching steps.\n#define V_STEPS 128\n// Reflection marching steps.\n#define R_STEPS 10\n// Shadow marching steps.\n#define S_STEPS 30\n// Maximum successful marching distance.\n#define EPSILON .0025\n// Max ray depth.\n#define MAX_DEPTH 500.0\n\n// How fast do you want time to go?\n#define TIME_WARP .3\n\n// Object constants.\n#define SAND_NOISE_TEX iChannel1\n#define SAND_BUMP_HEIGHT .6\n//#define OCEAN_NOISE_TEX iChannel1\n#define OCEAN_HEIGHT -1.25\n//#define OCEAN_AMPLITUDE .45\n//#define OCEAN_SPEED .35\n//#define WALL_BUMP_HEIGHT 7.5\n//#define WALL_DIFF_TEX iChannel2\n//#define RAND_NOISE_TEX iChannel0\n\n\n// Object IDs for shading.\n\n#define ID_BLACK 100.\n#define ID_LAPTOPSCR 110.\n#define ID_WOOD 120.\n#define  ID_BAF_TW 130.\n#define  ID_MPA_TW 140.\n#define ID_MPAL 150.\n#define ID_PALM 160.\n\n#define ID_BAFRYCE 170.\n#define ID_COCONUT 180.\n\n#define ID_ROCK 200.0\n#define ID_SAND 210.0\n#define ID_OCEAN 220.0\n\n#define ID_SSCREEN 630.\n\n// Environment and color constants.\nconst vec3 UP = vec3(0.0, 1.0, 0.0);\t\t\t\t\t\t// An up vector.\nconst vec3 PLANET_ROT = vec3(0.0,0.0,1.0);\t\t\t\t\t// The axis on which the planet rotates.\nconst vec3 SUN_DIR = vec3(0., 0.995037, 0.0995037);\t\t\t// The starting direction of the sun.\nconst vec3 SKY_COLOR_A = vec3(0.53,0.81,0.92);\t\t\t    // Sky color.\nconst vec3 SKY_COLOR_B = vec3(0.23,0.34,0.85);\t\t\t\t// High angle sky.\nconst vec3 SUN_COLOR_A = vec3(4.0);\t\t\t\t\t\t\t// Noontime sun color.\nconst vec3 SUN_COLOR_B = vec3(2.0, .66, 0.06);\t\t\t\t// Evening sun color.\nconst vec3 GROUND_COLOR = vec3(.6, .5, .32);\t\t\t\t// Average ground color.\nconst vec3 SAND_COLOR = vec3(.4, .35, .22);\t\t\t\t\t// The color of the sand.\nconst vec3 ROCK_COLOR_A = vec3(.4,.3,.15);\t\t\t\t\t// One rock color.\nconst vec3 ROCK_COLOR_B = vec3(.4,.2,.15);\t\t\t\t\t// Another rock color.\n#define NIGHT_BRIGHTNESS .1\n\n// Math constants.\nconst mat2 ROT45 = mat2(-.710, -.710, .710, -.710);\nconst mat2 ROT90 = mat2(0.,1.,-1.,0.);\nconst vec2 RAND_SEED = vec2(12.9898,78.233);\n\n#define PI4 12.56637\n\n\n/*\n\tOlinde Rodrigues' vector rotation formula for rotating a vector <a>\n\taround a vector <b> <t> radians.\n*/\nvec3 rodRot( in vec3 a, in vec3 b, in float t )\n{\n    // Straight from wikipedia.\n\treturn normalize(a*cos(t) + cross(b, a)*sin(t) + b*dot(b,a)*(1.0-cos(t)));\n}\n\n/*\n\tMy goofy redefinition-of-basis-based camera.\n*/\nvoid camera(in vec2 uv, in vec3 cp, in vec3 cd, in vec3 up, in float f, out vec3 ro, out vec3 rd)\n{\n\tro = cp;\n\trd = normalize((cp + cd*f + cross(cd, up)*uv.x + up*uv.y)-ro);\n}\n\n/*\n\tReturns a coefficient for a shutter fade.\n*/\nfloat shutterfade( in float s, in float e, in float t, in float duration )\n{\n    return min( smoothstep(s, s+duration, t), smoothstep(e, e-duration, t) );\n}\n\n\n/*\n\tTakes a vec2 containing a distance and a primitive's ID and returns\n\tthe ID and distance of the nearer primitive, effectively performing\n\ta solid modeling union.\n*/\nvec4 u( in vec4 a, in vec4 b )\n{\n    return mix(a,b,step(b.s,a.s));\n}\n\n/*\n\tThe random function from the first Stack Overflow article that is\n\treturned after googling \"GLSL noise\".\n\tCan we have a conversation about how GLSL defines a noise function\n\tbut no vendors actually implement it?\n*/\nfloat rand( in vec2 co )\n{\n    return fract(sin(dot(co,RAND_SEED)) * 43758.5453);\n}\n\n/*\n\tA 2D texture-sampled noise function. Used when the surface to be\n\tdistorted exists entirely in one plane.\n*/\nfloat n(vec2 p, sampler2D tex)\n{\n    return texture(tex,p).r;\n}\n\n/*\n\tIQ's seminal noise function. I learned that the weird ring artifacts\n\twere due to vflipping it's texture buddy.\n*/\nfloat nIQ( in vec3 x, in sampler2D t )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( t, (uv+0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n/*\n\tA 2D FBM with time dependence.\n*/\nfloat fbm2Dt( in vec2 p, in float t, in sampler2D tex )\n{\n    float r = n(p+t*.1,tex);\n    p*=ROT45;p*=2.0;p+=t*-.24;\n    r += n(p,tex)*.500;\n    p*=ROT45;p*=2.0;p+=t*-.12;\n    #ifdef HQ_RENDERING\n    r += n(p,tex)*.250;\n    #endif\n    return r*1.0075;\n}\n\n/*\n\tA 3 octave FBM that uses IQ's noise.\n*/\nfloat fbm3D( in vec3 p, in sampler2D t )\n{\n    float r = nIQ(p, t)*.5;\n    r += nIQ(p*2.0, t)*.25;\n    r += nIQ(p*4.1, t)*.125;\n    return r * 1.11872;\n}\n\n    \n\n\n// SDSDSDSDSDSDSDSDSDSDSDSDSDSDDSDSDSDSDSDSDSDSDSDSSDSDSDSD\n\nfloat vmax(vec3 v) { return max(max(v.x, v.y), v.z); }\n    \n\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nvec2 rot(vec2 p, float a)\n{\n    vec2 r;\n    float sa = sin(a), ca = cos(a);\n    r.x = p.x*ca - p.y*sa;\n    r.y = p.x*sa + p.y*ca;\n    return r;\n}\nfloat opS(float d1, float d2) { return max(-d1,d2); }\n      \n\nfloat fSphere(vec3 p, float r) { return length(p) - r; }\n\nfloat fPlane(vec3 p, vec3 n, float d) { return dot(p, n) + d; }\n\n\nfloat fCylinder(vec3 p, float r, float height) {\nfloat d = length(p.xz) - r;\nd = max(d, abs(p.y) - height);\nreturn d;\n}\n        \n      \nfloat laptop_open(vec3 p,float ry,float sz)\n{\t//-45.\n    vec3 p0=p-vec3(0.,.1,.0);\n    //p0*=sz;\n    p0.xz=rot(p0.xz, D2R(ry));; \n\tfloat d1 = fBox(p0-vec3(0.55,0.,0.)*sz,vec3(0.6,0.03,0.8)*sz);// if (d1 < d) { d = d1; col = vec4(0.3,0.3,0.3,1.0); id = 1; }\n\tvec3 p1=p0; p1.xy=rot(p1.xy, -1.8);; \n\td1 = min(d1,fBox(p1-vec3(0.6,0.,0.)*sz,vec3(0.6,0.03,0.8)*sz)); //if (d1 < d) { d = d1; col = vec4(0.3,0.3,0.3,1.0); id = 3; }\n\td1 = min(d1,fBox(p1-vec3(0.61,-0.02,0.)*sz,vec3(0.56,0.02,0.75)*sz)); //if (d1 < d) { d = d1; col = vec4(1.,0.4,1.,1.0); id = 4; }\n\treturn d1;\n}\n\nvec4 laptop_openID(vec3 p,float ry,float sz)\n{\t\n   vec3 p0=p-vec3(0.,.1,.0);\n    p0.xz=rot(p0.xz, D2R(ry));; \n    float d1 = fBox(p0-vec3(0.55,0.,0.)*sz,vec3(0.6,0.03,0.8)*sz);// if (d1 < d) { d = d1; col = vec4(0.3,0.3,0.3,1.0); id = 1; }\n\tvec3 p1=p0; p1.xy=rot(p1.xy, -1.8);; \n\td1 = min(d1,fBox(p1-vec3(0.6,0.,0.)*sz,vec3(0.6,0.03,0.8)*sz)); //if (d1 < d) { d = d1; col = vec4(0.3,0.3,0.3,1.0); id = 3; }\n\treturn u(vec4(d1,ID_BLACK,p0.xz), vec4(fBox(p1-vec3(0.61,-0.02,0.)*sz,vec3(0.56,0.02,0.75)*sz),ID_LAPTOPSCR,p1.xz));\n}\n\nfloat coconut(vec3 p0)\n{\n    float g=fSphere(p0,0.07);\n    if ( scene.gameState.z == 0. )\n    {\n        return g;\n    }\n    float l=fSphere(p0-vec3(0.,.05,0.),0.0510);\n   // float s=fPlane(p0-vec3(0.,0.025,0.),vec3(0.,-1.,0.),0.0);\n    float c = opS(l,g);\n    p0-=vec3(-0.0,0.081,0.);\n  p0.yz=rot(p0.yz, D2R(25.));\n //   c =min( c,capped_cylinder_sd(vec2(0.0,0.07),p0)); //if (d1 < d) { d = d1; col = vec4(1.0,1.0,1.0,1.0); id = 8; }\n    c=min(c,fCylinder(p0,0.0051,0.07));\n    //float d1= opS(s,c);\n\n    return c;\n//return d1;\n\n}\nfloat bafryce(vec3 p)\n{\n    vec3 b=scene.bafryce.xyz;\n    p -= b;\n    \n \tvec3 shoulder_l = vec3(.2,.42,0),\n         shoulder_r = shoulder_l;\n    shoulder_r.x *= -1.;\n    vec3 elbow_l = vec3(.36,.06,-.12),\n         elbow_r = vec3(-.35,.04,-.1);\n    vec3 hand_l = vec3(-.1,.12,-.2),\n         hand_r = vec3( .1,.0,-.2);\n    vec3 hip_l = vec3(.1,-.45,0),\n         hip_r = vec3(-.1,-.45,0);\n    vec3 knee_l = vec3( .24,-.9,-.1),\n         knee_r = vec3(-.24,-.9,-.1);\n    vec3 ankle_l = vec3(.23,-1.37,0),\n         ankle_r = vec3(-.23,-1.37,0);\n    float bf =\n    union_opf( \n        union_opf( \n            union_opf( \n                union_opf(\n                   round_aab_ud( vec3(.25,.8,.05), .1, p ),\n                   ellipsoid_sd( vec3(.15,.2,.15), at_angle( vec3(-QPI*.2,0,0), at_pos( vec3(0,.75,-.05), p ) ) )\n                ),\n                union_opf(\n                   cline_sd( shoulder_l, elbow_l, .06, p ),\n                   cline_sd( elbow_l,    hand_l,  .06, p ) )\n            ),\n            union_opf(\n                cline_sd( shoulder_r, elbow_r, .06, p ),\n                cline_sd( elbow_r,    hand_r, .06, p ) )\n        ),\n        union_opf(\n            union_opf(\n                cline_sd( hip_l,  knee_l, .1, p ),\n                cline_sd( knee_l, ankle_l, .09, p )\n            ),\n            union_opf(\n                cline_sd( hip_r,  knee_r, .1, p ),\n                cline_sd( knee_r, ankle_r, .09, p )\n            )\n        )\n    );\n\treturn bf;\n}\nfloat mpallin(vec3 p)\n{\n    vec3 mp=scene.mpallin.xyz;\n    \n    p = p - mp;\n    p.xz = rot(p.xz, PI );\n    \n \tvec3 shoulder_l = vec3(.2,0,.45),\n         shoulder_r = shoulder_l;\n    shoulder_r.x *= -1.;\n    vec3 elbow_l = vec3(.35,.1,.85),\n         elbow_r = vec3(-.3,.05,.1);\n    vec3 hand_l = vec3(.1,.04,.9),\n         hand_r = vec3(.1,.1,.1);\n    vec3 hip_l = vec3(.1,0,-.45),\n         hip_r = vec3(-.1,0,-.45);\n    vec3 knee_l = vec3(.3,.15,-.9),\n         knee_r = vec3(-.27,.05,-.9);\n    vec3 ankle_l = vec3(.32,-.1,-1.35),\n         ankle_r = vec3(-.25,-.1,-1.4);\n    float mpf =\n    union_opf( \n        union_opf( \n            union_opf( \n                union_opf(\n                   round_aab_ud( vec3(.25,.05,.8), .1, p ),\n                   ellipsoid_sd( vec3(.15,.15,.2), at_angle( vec3(-QPI*.5,0,0), at_pos(vec3(0,.15,.75), p ) ) )\n                ),\n                union_opf(\n                   cline_sd( shoulder_l, elbow_l, .06, p ),\n                   cline_sd(  elbow_l, hand_l, .06, p ) )\n            ),\n            union_opf(\n                cline_sd( shoulder_r, elbow_r, .06, p ),\n                cline_sd( elbow_r, hand_r, .06, p ) )\n        ),\n        union_opf(\n            union_opf(\n                cline_sd( hip_l, knee_l, .1, p ),\n                cline_sd( knee_l, ankle_l, .09, p )\n            ),\n            union_opf(\n                cline_sd( hip_r,  knee_r, .1, p ),\n                cline_sd( knee_r, ankle_r, .09, p )\n            )\n        )\n    );\n\treturn mpf;\n}\n\nfloat palm( vec3 p )\n{\n    vec3 hp = vec3(1.15,5.4,1.15);\n    float sp = sphere_sd( 7., at_pos(hp*.5, p ) );\n    float f = 1e37;\n    if ( sp > 0.5 )\n    {\n        return sp;\n    }\n    \n    vec3 b = vec3(0);\n    vec3 dp = vec3(.1,1.2,.1);\n    float r = .2;\n    for ( int i = 0; i != 8; ++i )\n    {\n\t\tf = \n        union_opf(\n\t        f,\n\t        cline_sd( b, b + dp, r, p )\n\t    );\n        b += dp;\n        dp *= vec3(1.1,.8,1.1);\n        r *=.9;\n    }\n    \n    float leaf_d = 0.5;\n    float leaf_r = 7.;\n    int NLEAF = 9;\n    for ( int i = 0; i != NLEAF; ++i )\n    {\n        p = at_pos(hp,p);\n        p.xz = rot(p.xz,TAU/float(NLEAF-1));\n        p = at_pos(-hp,p);\n        f =\n        union_opf(\n          f,\n         max(\n          p.x-hp.x,\n          max(\n            max( -half_space_sd( at_pos(hp+vec3(0.0,0.0,-leaf_d), p ) ),\n                  half_space_sd( at_pos(hp+vec3(0.0,0.0, leaf_d), p ) ) ),\n            subtract_opf(\n                sphere_sd(leaf_r*1.2, at_pos(hp+vec3(0,-leaf_r*1.2-.3,0), p ) ),\n                sphere_sd(leaf_r    , at_pos(hp+vec3(0,-leaf_r       ,0), p ) )\n            )\n          )\n         ) \n        );\n    }\n    return f;\n}\n\nfloat sscreen_bottle( vec3 p )\n{\n    float f = union_opf( cline_sd( vec3(0),vec3(0,.2,0), .025, p ),\n                         round_aab_ud( vec3(.05,.14,.02), .02, at_pos(vec3(0,.07,0),p ) )\n                       );\n    return f;\n}\n\n\n\n// P_Mallin Boat  ================================ \nstruct SceneResult\n{\n\tfloat fDist;\n\tfloat iObjectId;\n    vec3 vUVW;\n};\n    \n        \nvoid Scene_Union( inout SceneResult a, in SceneResult b )\n{\n    if ( b.fDist < a.fDist )\n    {\n        a = b;\n    }\n}\n\n    \nvoid Scene_Subtract( inout SceneResult a, in SceneResult b )\n{\n    if ( a.fDist < -b.fDist )\n    {\n        a.fDist = -b.fDist;\n        a.iObjectId = b.iObjectId;\n        a.vUVW = b.vUVW;\n    }\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat GetBoatHullDistance( vec3 vPos )\n{\n    vec3 vBoatDomain = vPos;\n    vBoatDomain.x = abs(vBoatDomain.x);\n    \n    float boatDist = length( vBoatDomain.xyz - vec3(-3.9,3.2,-0.6)) - 5.5;\n    float boatRearDist = length( vBoatDomain.xyz - vec3(0,2,3.9)) - 6.0;\n\n    boatDist = -min( -boatDist, - boatRearDist);\n    \n    float boatBaseDist = length( vBoatDomain.xyz - vec3(0,4,0)) - 4.4;\n    boatDist = -min( -boatDist, - boatBaseDist);\n    \n    \n    return boatDist;\n}\n\nfloat GetBoatTopDistance( vec3 vPos )\n{\n    return length( vPos - vec3(0,-10,1)) - 10.0-.7;\n}\n\n\nSceneResult GetBoatDistance( vec3 vPos )\n{    \n    vPos*=0.5;\n    vPos.xz=rot(vPos.xz, D2R(-90.));; \n    SceneResult result;\n    result.iObjectId = ID_BLACK;\n    result.vUVW = vPos;\n    \n    result.fDist = GetBoatHullDistance(vPos);\n    \n    SceneResult intResult;\n    intResult.iObjectId = ID_WOOD;\n    intResult.vUVW = vPos;\n\n    float boatInsideDist = GetBoatHullDistance(vPos - vec3(0,.15,0) );\n\n    boatInsideDist = max( boatInsideDist, -udRoundBox( vPos - vec3(0,0.2,-.8), vec3(1.0, .01, 0.2), 0.05) );\n    \n    boatInsideDist = max( boatInsideDist, vPos.z);\n    \n    intResult.fDist = boatInsideDist;\n    \n    Scene_Subtract( result, intResult );\n    \n\n    float boatTopDist = GetBoatTopDistance(vPos);\n\n    result.fDist = -smin(-result.fDist, -boatTopDist, .05 );\n    return result;\n}\n\n      \nfloat little_table(vec3 p)\n{\t\n    vec3 p0=p;\n    p0.y += 0.1;\n    p0.xz=rot(p0.xz, D2R(-45.));\n \n    float d1 = fBox(p0,vec3(0.5,0.5,0.5));\n    float s = min(fBox(p0,vec3(0.45,.45,1.0)), fBox(p0,vec3(1.0,0.45,.45)));\n    \n    return opS(s,d1);\n}\n\n\n\n//-------------\n#define TOWELSZ vec3(1.0,0.03,2.0)\nfloat towel(vec3 p,float ry)\n{\n   vec3 p0=p;\n   p0.xz=rot(p0.xz, D2R(ry));; \n  float d1 = fBox(p0,TOWELSZ);\n\treturn d1;\n}\nvec4 towelID(vec3 p,float ry,float id)\n{\n   vec3 p0=p;\n   p0.xz=rot(p0.xz, D2R(ry));; \n    vec3 sz=TOWELSZ;\n  return vec4( fBox(p0,sz),id, p.xz/vec2(sz.xz));\n}\n\n// $$$$$$$$$$$$$$\n\n\n\n\nconst float island_r = 500.;\nconst vec3 island_center = vec3(-island_r+170.,0,-island_r+170.);\nfloat dist( vec3 p,bool Refl)\n{\n \n    float f = (p.y+1.25);\n   \n    // NOTE(theGiallo): coconuts\n    vec3 scp = vec3(0,.07,1.2), cp = scp;\n    f = min( f, sphere_sd( .07, at_pos(cp,p) ) );\n    cp.xz += vec2(.2,0.13);\n    f = min( f, sphere_sd( .07, at_pos(cp,p) ) );\n    cp.xz += vec2(.02,0.33);\n    f = min( f, sphere_sd( .07, at_pos(cp,p) ) );\n    cp.xz += vec2(-.32,-0.2);\n    f = min( f, sphere_sd( .07, at_pos(cp,p) ) );\n\t    \n    f=min(f,coconut(at_pos(scene.objs[int(OBJ_V_COCONUT)-1].xyz,p)) + 1e37 * scene.objs[int(OBJ_V_COCONUT)-1].w );\n    \n   f= min(f, sscreen_bottle( at_pos( scene.objs[int(OBJ_V_SSCREEN)-1].xyz, p ) ) + 1e37 * scene.objs[int(OBJ_V_SSCREEN)-1].w);                    // boat\n    {\n        vec3 mp = scene.mpallin.xyz;\n    \tfloat dmp = distance(p,mp);\n    \tf = min(f,dmp);\n    \tif ( dmp < 2. )\n    \t{\n\t    \tf=min(f,mpallin(p));\n\t    }\n    }\n    {\n        vec3 b = scene.bafryce.xyz;\n    \tfloat db = distance(p,b);\n    \tf = min(f,db);\n    \tif ( db < 2. )\n    \t{\n    \t\tf=min(f,bafryce(p));\n\t    }\n    }\n    if (  scene.objs[0].w == 0.0 )\n    {\n        vec3 lp = scene.objs[0].xyz;\n    \tfloat dlp = distance(p,lp);\n    \tf = min(f,dlp);\n    \tif ( dlp < 1. )\n    \t{\n    \t\tf=min(f,laptop_open(at_pos(scene.objs[0].xyz,p),.45,0.5));\n\t    }\n    }\n    //f = min( f, capped_cylindery_sd( vec2(island_r,100), at_pos(island_center+vec3(0,-100,0),p) ) );\n    f = min( f, capped_cone_as_intersections_sd( 20., island_r + 100., island_r, at_pos(island_center+vec3(0,-20.,0), p ).xzy ) );\n   // float di=texture(iChannel1,vec2(atan(p.x-island_center.x,p.z-island_center.z),p.y)).x*.5;\n    f = min( f, capped_cone_as_intersections_sd( 200., island_r - 50., 20., at_pos(island_center+vec3(0,0,0), p ).xzy ) );\n    f = min( f, palm(p) );\n    \n    f = min(f, little_table(at_pos(vec3(10.,0.5,10.),p))  );\n  if ( scene.boat.w == 0.0 )\n    {\n        f=min(f, GetBoatDistance(at_pos(scene.boat.xyz,p)).fDist);\n    }\n    \n    f=min(f,towel(at_pos(vec3( 17, 0, 10),p),90.));\n    f=min(f,towel(at_pos(scene.mpallin.xyz-vec3(0.,.15,0.),p),0.));\n    return f;\n}\n\n\nvec4 distID( vec3 p, bool Refl )\n{\n   \n    vec4 r = vec4((p.y+1.25),ID_OCEAN,p.xz * .5 );\n  \n    if (  scene.objs[0].w == 0.0 )\n    {\n        vec3 lp = scene.objs[0].xyz;\n    \tfloat dlp = distance(p,lp);\n    \t//f = min(f,dlp);\n    \tif ( dlp < 1. )\n    \t{\n     \t\tr=u(r,laptop_openID(at_pos(scene.objs[0].xyz,p),.45,0.5));\n\t    }\n    }\n    r = u( r,\n      vec4(\n        capped_cone_as_intersections_sd( 200., island_r - 50., 20., at_pos(island_center, p ).xzy ),\n        ID_ROCK, atan(p.x-island_center.x,p.z-island_center.z),p.y  ) );\n    r=u(r,\n  vec4(capped_cone_as_intersections_sd( 20., island_r + 100., island_r, at_pos(island_center+vec3(0,-20.,0), p ).xzy ),ID_SAND,p.xz));\n   \n   \n    {  \n      vec3 scp = vec3(0,.07,1.2), cp = scp;\n    float f = sphere_sd( .07, at_pos(cp,p)  );\n    cp.xz += vec2(.2,0.13);\n    f = min( f, sphere_sd( .07, at_pos(cp,p) ) );\n    cp.xz += vec2(.02,0.33);\n    f = min( f, sphere_sd( .07, at_pos(cp,p) ) );\n    cp.xz += vec2(-.32,-0.2);\n    f = min( f, sphere_sd( .07, at_pos(cp,p) ) );\n\t    \n    f=min(f,coconut(at_pos(scene.objs[int(OBJ_V_COCONUT)-1].xyz,p)) + 1e37 * scene.objs[int(OBJ_V_COCONUT)-1].w );\n    r=u(r,vec4(f,ID_COCONUT,p.xz));\n    \n    }\n    \n    \n    if ( scene.boat.w == 0.0 )\n    {\n     SceneResult bsr=GetBoatDistance(at_pos(scene.boat.xyz,p));\n    r = u(r, vec4(bsr.fDist,bsr.iObjectId,bsr.vUVW.yz));    \n    }\n    \n    r= u(r, vec4(    little_table(at_pos(vec3(10.,0.5,10.),p)),ID_BLACK,vec2(0))  ); \n    \n    r= u(r, vec4(\n    sscreen_bottle( at_pos( scene.objs[int(OBJ_V_SSCREEN)-1].xyz, p ) )\n        + 1e37 * scene.objs[int(OBJ_V_SSCREEN)-1].w,\n                 ID_SSCREEN, vec2(0)) );\n    \n      r=u(r,towelID(at_pos(vec3( 17, 0, 10),p),90.,ID_BAF_TW) );\n    r=u(r,towelID(at_pos(scene.mpallin.xyz-vec3(0.,.11,0.),p),0.,ID_MPA_TW) );\n    \n      r = u(r,vec4(palm(p),ID_PALM,vec2(0)) );\n    {\n        vec3 mp = scene.mpallin.xyz;\n    \tfloat dmp = distance(p,mp);\n    \n    \tif ( dmp < 2. )\n    \t{\n\t    \tr=u(r,vec4(mpallin(p),ID_MPAL,p.xz));\n\t    }\n    }\n    {\n        vec3 mp = scene.bafryce.xyz;\n    \tfloat dmp = distance(p,mp);\n \n    \tif ( dmp < 2. )\n    \t{\n\t    \tr=u(r,vec4(bafryce(p),ID_BAFRYCE,p.xz));\n\t    }\n    }\n    \n\treturn r;\n}\n\n\n\n\nfloat distInv(vec3 p)\n{\tvec3 pos=vec3(-.75,0,0);\n\tfloat r=min(laptop_open(at_pos(pos+vec3(0,-0.1,0),p),35.,0.20),\n                coconut(at_pos(pos+vec3(.5,0,0),p)));\n\n \tr=min(r,sscreen_bottle(at_pos(pos+vec3(1.0,0,0),p)));  \n    return r;\n}\n\nvec4 distInvID(vec3 p)\n{\tvec3 pos=vec3(-.75,0,0);\n\tvec4 r=u(laptop_openID(at_pos(pos+vec3(0,-0.1,0),p),35.,.20),\n             vec4(coconut(at_pos(pos+vec3(.5,0,0),p)),ID_WOOD,vec2(0)));\n  \n \tr=u(r, vec4(sscreen_bottle(at_pos(pos+vec3(1.0,0,0),p)),ID_BLACK,vec2(0)));  \n    return r;\n}\n\n// SDSDSDSDSDSDSDSDSDSDSDSDSDSDDSDSDSDSDSDSDSDSDSDSSDSDSDSD\n\n/*\n\tReturns the direction of the sun based on the current time.\n*/\nvec3 sunDir()\n{\n    return normalize(vec3(0.3,0.7,0.));//rodRot(SUN_DIR, PLANET_ROT, 60.9*TIME_WARP);\n}\n\n/*\n\tReturns the color of the sun. Just does some janky fading\n\tbetween white at zenith and yellow at asimuth.\n*/\nvec3 sunColor( in vec3 sunDir )\n{\n    return mix(SUN_COLOR_B, SUN_COLOR_A, clamp(dot(sunDir,UP),0.0,1.0));\n}\n/*\n\tReturns the surface normal of the distance field at the given\n\tpoint p.\n*/\nvec3 norm( in vec3 p,bool Refl)\n{\n\treturn normalize(vec3(dist(vec3(p.x+EPSILON,p.y,p.z),Refl),\n\t\t\t\t\t\t  dist(vec3(p.x,p.y+EPSILON,p.z),Refl),\n\t\t\t\t\t\t  dist(vec3(p.x,p.y,p.z+EPSILON),Refl))-dist(p,Refl));\n}\n\n\n/*\n\tThe ray-marching function. Marches a point p along a direction d\n\tuntil it reaches a point within a minimum distance of the distance\n\tfield.\n*/\nvoid march( inout vec3 p, in vec3 d, in vec3 e ,bool Refl)\n{\n\tfloat r = dist(p+d*EPSILON,Refl);\n    vec3 dir = Refl?d:d*.5;\n\tfor(int i = 0; i < V_STEPS; i++)\n\t{\n\t\tif(r < EPSILON || length(p-e) > MAX_DEPTH)\n\t\t\treturn;\n\t\tp += dir*r; // The higher levels of noise in the rock may be skipped\n        \t\t\t  // if the steps are too large.\n//        r = min(dist(p),sceneDist(p,sd));\n  \t    r = dist(p,Refl);\n\t}\n\treturn;\n}\nbool marchInv( inout vec3 p, in vec3 d, in vec3 e)\n{\n\tfloat t = 0.;//distInv(p+d*0.0001);\n    vec3 dir = d;\n\tfor(int i = 0; i < 32; i++)\n\t{\n        float d= distInv(p+dir*t);\n        if( d < 0.01 || t > 10. )\n        {\n            p+=dir*t;\n\t\t\treturn  d < 0.01;\n        }\n\t\tt+=d*.5;        \n\t}\n    return false;\n}\n\n/*\n\tMarch-from-surface-to-light shadowing, with IQ's glancing penumbras.\n*/\nfloat shadow( in vec3 start, in vec3 n, in vec3 ldir, in float p)\n{    \n    // Do some quick \"is the sun even shining on here\" tests.\n    // We wait until the sun is just below the horizon before considering\n    // it gone.\n    if( dot(n,ldir) <= 0.0 || dot(ldir,UP) <= -.25) return 0.0;\n    \n\tfloat t = EPSILON*128.0;\n\tfloat res = 1.0;\n    for ( int i = 0; i < S_STEPS; ++i )\n    {\t//vec3 s=start + ldir * t ;\n    //    float d = min(distR(s),sceneDist(s,sd));\n        float d = dist(start + ldir * t,false);\n        if ( d < EPSILON*.1 )\n            return 0.0;\n\t\t\n\t\tres = min( res, p * d / t );\n        t += d;\n\t\t\n\t\tif ( t > MAX_DEPTH )\n\t\t\tbreak;\n    }\n    return res;\n}\n\n\n/* \n\tOkay this is not my atmospheric scattering solution, and for the\n\tlife of me I can't find the shader that I'm borrowing it from.\n\tIt's an implementation of the method discussed in this paper:\n\thttp://www.cs.utah.edu/~shirley/papers/sunsky/sunsky.pdf\n\n\tThe nice thing is that it's not the usual Scratchapixel solution.\n*/\nfloat saturatedDot( in vec3 a, in vec3 b )\n{\n\treturn max( dot( a, b ), 0.0 );   \n}\nvec3 YxyToXYZ( in vec3 Yxy )\n{\n\tfloat X = Yxy.g * ( Yxy.r / Yxy.b );\n\tfloat Z = ( 1.0 - Yxy.g - Yxy.b ) * ( Yxy.r / Yxy.b );\n\n\treturn vec3(X,Yxy.r,Z);\n}\nvec3 XYZToRGB( in vec3 XYZ )\n{\n\t// CIE/E\n\treturn XYZ * mat3\n\t(\n\t\t 2.3706743, -0.9000405, -0.4706338,\n\t\t-0.5138850,  1.4253036,  0.0885814,\n \t\t 0.0052982, -0.0146949,  1.0093968\n\t);\n}\nvec3 YxyToRGB( in vec3 Yxy )\n{\n\tvec3 XYZ = YxyToXYZ( Yxy );\n\tvec3 RGB = XYZToRGB( XYZ );\n\treturn RGB;\n}\nvoid calculatePerezDistribution( in float t, out vec3 A, out vec3 B, out vec3 C, out vec3 D, out vec3 E )\n{\n\tA = vec3(  0.1787 * t - 1.4630, -0.0193 * t - 0.2592, -0.0167 * t - 0.2608 );\n\tB = vec3( -0.3554 * t + 0.4275, -0.0665 * t + 0.0008, -0.0950 * t + 0.0092 );\n\tC = vec3( -0.0227 * t + 5.3251, -0.0004 * t + 0.2125, -0.0079 * t + 0.2102 );\n\tD = vec3(  0.1206 * t - 2.5771, -0.0641 * t - 0.8989, -0.0441 * t - 1.6537 );\n\tE = vec3( -0.0670 * t + 0.3703, -0.0033 * t + 0.0452, -0.0109 * t + 0.0529 );\n}\nvec3 calculateZenithLuminanceYxy( in float t, in float thetaS )\n{\n\tfloat chi  \t \t= ( 4.0 / 9.0 - t / 120.0 ) * ( PI - 2.0 * thetaS );\n\tfloat Yz   \t \t= ( 4.0453 * t - 4.9710 ) * tan( chi ) - 0.2155 * t + 2.4192;\n\n\tfloat theta2 \t= thetaS * thetaS;\n    float theta3 \t= theta2 * thetaS;\n    float T \t \t= t;\n    float T2 \t \t= t * t;\n\n\tfloat xz =\n      ( 0.00165 * theta3 - 0.00375 * theta2 + 0.00209 * thetaS + 0.0)     * T2 +\n      (-0.02903 * theta3 + 0.06377 * theta2 - 0.03202 * thetaS + 0.00394) * T +\n      ( 0.11693 * theta3 - 0.21196 * theta2 + 0.06052 * thetaS + 0.25886);\n\n    float yz =\n      ( 0.00275 * theta3 - 0.00610 * theta2 + 0.00317 * thetaS + 0.0)     * T2 +\n      (-0.04214 * theta3 + 0.08970 * theta2 - 0.04153 * thetaS + 0.00516) * T +\n      ( 0.15346 * theta3 - 0.26756 * theta2 + 0.06670 * thetaS + 0.26688);\n\n\treturn vec3( Yz, xz, yz );\n}\nvec3 calculatePerezLuminanceYxy( in float theta, in float gamma, in vec3 A, in vec3 B, in vec3 C, in vec3 D, in vec3 E )\n{\n\treturn ( 1.0 + A * exp( B / cos( theta ) ) ) * ( 1.0 + C * exp( D * gamma ) + E * cos( gamma ) * cos( gamma ) );\n}\nvec3 calculateSkyLuminanceRGB( in vec3 s, in vec3 e, in float t )\n{\n\tvec3 A, B, C, D, E;\n\tcalculatePerezDistribution( t, A, B, C, D, E );\n\tfloat thetaS = acos( saturatedDot( s, vec3(0,1,0) ) );\n\tfloat thetaE = acos( saturatedDot( e, vec3(0,1,0) ) );\n\tfloat gammaE = acos( saturatedDot( s, e )\t\t   );\n\tvec3 Yz = calculateZenithLuminanceYxy( t, thetaS );\n\tvec3 fThetaGamma = calculatePerezLuminanceYxy( thetaE, gammaE, A, B, C, D, E );\n\tvec3 fZeroThetaS = calculatePerezLuminanceYxy( 0.0,    thetaS, A, B, C, D, E );\n\tvec3 Yp = Yz * ( fThetaGamma / fZeroThetaS );\n\treturn YxyToRGB( Yp );\n}\n\n\n/*\n\tCombines the sky radiance from the magic above with a specular \n\thighl^H^H^H^H^H^Hsun.\n*/\nvec3 sky( in vec3 d, in vec3 ld )\n{\n    // Get the sky color.\n    vec3 sky = calculateSkyLuminanceRGB(ld, d, 3.0);\n    \n    // How night time is it? This variable will tell you.\n    float night = smoothstep(-0.0, -0.5, clamp(dot(ld, UP),-0.5, -0.0));\n    // Set a general brightness level so we don't just have a white screen,\n    // and artificially darken stuff at night so it looks good.\n    sky *= .040-.035*night;\n    \n    // Create a spot for the sun. This version gives us some nice edges\n    // without having a pow(x,VERY_LARGE_NUMBER) call.\n    float sunspot = smoothstep(.99935, .99965, max(dot(d,ld),0.0));\n    sunspot += smoothstep(.98000, 1.0, max(dot(d,ld),0.0))*.05; // Corona.\n    \n   \t// Mix the sky with the sun.\n    sky = sky*(1.0+sunspot);\n    \n    // Also add in the stars.\n    return sky;\n}\n\n\n/*\n\tIQ's really compact implementation of Oren Nayar reflectance.\n*/\nfloat orenNayar( in vec3 n, in vec3 v, in vec3 ldir )\n{\n    float r2 = pow(MAT_REFLECTANCE, 2.0);\n    float a = 1.0 - 0.5*(r2/(r2+0.57));\n    float b = 0.45*(r2/(r2+0.09));\n\n    float nl = dot(n, ldir);\n    float nv = dot(n, v);\n\n    float ga = dot(v-n*nv,n-n*nl);\n\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));\n}\n\n\n/*\n\tPerforms the full suite of lighting for Oren Nayar-appropriate\n\tsurfaces. Calculates direct (sun), sky, and ambient radiance\n\tcontributions.\n*/\nvec3 light( in vec3 p, in vec3 d, in vec3 e, in vec3 n, in vec3 ld )\n{\n    // Get an ambient occlusion value.\n\n    float amb = 1.0;\n    \n    // Get light colors and radiance for the three lights.\n    // (Or just specral radiance if that's your thing.)\n    vec3 skc = .6*orenNayar(n,-d,UP)*sky(n,ld);\n    vec3 sun = orenNayar(n,-d,ld)*sunColor(ld);\n    vec3 gnd = .2*GROUND_COLOR*max(orenNayar(n,-d,-UP),0.25);\n    \n    // Modulate those by ambient occlussion and shadowing.\n    skc *= amb;\n    gnd *= amb;\n    sun *= shadow(p,n,ld,PENUMBRA_FACTOR);\n    \n    // Return the sum.\n    return skc+gnd+sun; \n}\n//==================================\n\n\n/*\n\tReturns the texture of the sand, and does some basic distance\n\tfiltering.\n*/\nvec3 texSand( in vec3 p, in float l )\n{\n    // Essentially what we're doing is just calculating low contrast\n    // random values whose contrast diminishes with distance.\n    return SAND_COLOR*mix(.75+rand(p.xz)*.25, .85, clamp(l/MAX_DEPTH,0.0,1.0));\n}\n\n/*\n\tShades dry sand. Just takes in an illumination value and texture\n\tand multiplies the two together. Simple.\n*/\nvec3 shadeDrySand( in vec3 i, in vec3 t )\n{\n    return i*t;\n}\n\n/*\n\tNon reflective wet sand is a bit harder, but still simple.\n\tEssentially we're doing per-pixel Phong shading, but the diffuse\n\tterm is .5 of the dry sand result. Oh, and the ambient term is\n\tthe sky above.\n*/\nvec3 shadeWetSand( in vec3 p, in vec3 d, in vec3 e, in vec3 n, in vec3 i, in vec3 ld, in vec3 tex )\n{\n\t// Specular.\n\tvec3 r = reflect(d,n);\n    vec3 spec = sunColor(ld) * max( pow(dot(ld,r),50.0), 0.0);\n    // Diffuse.\n    vec3 diff = shadeDrySand(i,tex)*.5;\n    // Ambient.\n    vec3 ambi = sky(n,ld);\n    return spec+diff+ambi;\n}\n\n/*\n\tConstructs the appearance of non-reflection sand (sand that is \n\talready a reflection.) Since you barely see this sand, we don't\n\tworry about if it's wet or not. (To save cycles.)\n*/\nvec3 shadeSand( in vec3 p, in vec3 i, in float l )\n{\n    // Get the texture of the sand.\n    vec3 tex = texSand(p,l);\n    // Pass it into the the shading function.\n    return shadeDrySand(i,tex);\n}\n\n\n/*\n\tShades the rock. With the illumination color and value pre-computed\n\tthis is a simple task.\n*/\n\n\n\nfloat noise3( vec3 x ) {\n    vec3 p = floor(x),f = fract(x);\n\n    f = f*f*(3.-2.*f);  // or smoothstep     // to make derivative continuous at borders\n\n#define hash3(p)  fract(sin(1e3*dot(p,vec3(1,57,-13.7)))*4375.5453)        // rand\n    \n    return mix( mix(mix( hash3(p+vec3(0,0,0)), hash3(p+vec3(1,0,0)),f.x),       // triilinear interp\n                    mix( hash3(p+vec3(0,1,0)), hash3(p+vec3(1,1,0)),f.x),f.y),\n                mix(mix( hash3(p+vec3(0,0,1)), hash3(p+vec3(1,0,1)),f.x),       \n                    mix( hash3(p+vec3(0,1,1)), hash3(p+vec3(1,1,1)),f.x),f.y), f.z);\n}\n\n#define noise(x) (noise3(x)+noise3(x+11.5)) / 2. // pseudoperlin improvement from foxes idea \n\n\n\n\n\n// water shader\n// Thank you frankbatista\n// from  https://www.shadertoy.com/view/XdffWj\nfloat random(float x) {\n \n    return fract(sin(x) * 10000.);\n          \n}\n\nfloat noisew(vec2 p) {\n\n    return random(p.x + p.y * 50000.);\n            \n}\n\nvec2 sw(vec2 p) { return vec2(floor(p.x), floor(p.y)); }\nvec2 se(vec2 p) { return vec2(ceil(p.x), floor(p.y)); }\nvec2 nw(vec2 p) { return vec2(floor(p.x), ceil(p.y)); }\nvec2 ne(vec2 p) { return vec2(ceil(p.x), ceil(p.y)); }\n\nfloat smoothNoise(vec2 p) {\n\n    vec2 interp = smoothstep(0., 1., fract(p));\n    float s = mix(noisew(sw(p)), noisew(se(p)), interp.x);\n    float n = mix(noisew(nw(p)), noisew(ne(p)), interp.x);\n    return mix(s, n, interp.y);\n        \n}\n\nfloat fractalNoise(vec2 p) {\n\n    float x = 0.;\n    x += smoothNoise(p      );\n    x += smoothNoise(p * 2. ) / 2.;\n    x += smoothNoise(p * 4. ) / 4.;\n    x += smoothNoise(p * 8. ) / 8.;\n    x += smoothNoise(p * 16.) / 16.;\n    x /= 1. + 1./2. + 1./4. + 1./8. + 1./16.;\n    return x;\n            \n}\n\nfloat movingNoise(vec2 p) {\n \n    float x = fractalNoise(p + iTime);\n    float y = fractalNoise(p - iTime);\n    return fractalNoise(p + vec2(x, y));   \n    \n}\n\n// call this for water noise function\nfloat nestedNoise(vec2 p) {\n    \n    float x = movingNoise(p);\n    float y = movingNoise(p + 100.);\n    return movingNoise(p + vec2(x, y));\n    \n}\n\nvec4 water(vec2 uv)\n{\n    \n    float n = nestedNoise(uv * 6.);\n    \n\treturn vec4(mix(vec3(.4, .6, 1.), vec3(.1, .2, 1.), n), 0.5);\n}\n\n\n// water /\n\n\n\n\n\n\n\nvoid shadeScene(inout vec3 o,bool Refl,float id,in vec3 p,float l,in vec3 n,vec2 uv,in vec3 amb,vec3 sun,in vec3 dir)\n{\n\t\t\n    if(id==ID_BLACK) \n    \to= amb*vec3(.3);\n     if(id==ID_WOOD) \n    \to= amb*vec3(.6,.3,.1)*texture(iChannel2,uv*3.).rgb;\n\tif(id==ID_LAPTOPSCR)\n    {\n        if ( scene.gameState.w == 0. )\n        {\n            o-=o;\n        } else\n        {\n        \to= vec3(uv.yx,0.5+0.5*sin(iTime));//*amb*texture(iChannel2,uv*2.).x;\n        }\n    }\n    \n    if ( id == ID_SSCREEN )\n    {\n        o = vec3(1,1,0)*amb;\n    }\n    \n    if(id==ID_BAF_TW)\n    {\n     float n = noise(vec3(uv,.1*iTime)),\n          v = sin(6.28*10.*n);\n  \t  v = smoothstep(0.,1., .7*abs(v)/fwidth(v));\n    n = floor(n*20.)/20.;\n\to = v * (.5+.5*cos(12.*n+vec3(0,2.1,-2.1))) * amb;\n    } else\n    if(id==ID_MPA_TW)\n    {\tvec2 i= floor(uv*60.);\n        o=tan(dot(i,i)*.6+sin(iDate.wwx))*amb;\n    }\n    if(id==ID_MPAL)\n    {\n    \t// scene.gameState.y ==1. => ho la crema\n        \n        vec3 r = reflect(dir,n);\n    \tvec3 specular = pow(max(dot(r,sun),0.0),350.0)*sunColor(sun);\n    \to= (amb+specular*scene.gameState.y)*vec3(.6,.4,.4);\n    }\n    \n     if(id==ID_PALM) \n    \to= amb*vec3(0.2,.6,.2);\n    \n    if(id == ID_OCEAN)\n    {\n     \n        o = water(uv).xyz*amb;\n    }\n    if ( id == ID_BAFRYCE )\n    {\n        o = vec3(1.)*amb;\n    }\n    if(id==ID_COCONUT)\n    {\n    \to= vec3(.54,0.2,.1)*amb;\n    }\n}\n\n\n\n/*\n\tConstructs the appearance of reflective sand.\n*/\n\nvec3 shadeWetSandR( in vec3 p, in vec3 d, in vec3 e, in vec3 n, in vec3 i, in vec3 ld, in vec3 tex )\n{\n    // Get the reflected ray direction.\n    vec3 r = reflect(d,n);\n    \n\n    vec3 reflection = sky(r,ld);\n  //  #endif\n    // Create a standard Phong specular term to spice things up in\n    // the shiny department.\n    vec3 specular = pow(max(dot(r,ld),0.0),350.0)*sunColor(ld);\n    // Get the reflectance of the surface given the angle of incidence.\n    float reflectance = max(length(cross(n,d)),0.0);\n    // Get the diffuse term. (discussed in shadeWetSand().)\n    vec3 diffuse = tex*i*.5;\n    // Return a blend of the reflection and the sand and the specular highlight.\n    return mix(diffuse, reflection, pow(reflectance,128.0))+specular;\n}\n\n/*\n\tConstructs the appearance of first-bounce sand, whether it's wet and reflective\n\tor not.\n*/\nvec3 shadeSandR( in vec3 p, in vec3 d, in vec3 e, in vec3 n, in vec3 i, in vec3 ld, in float l )\n{\n    // Compute the texture of the sand.\n    vec3 tex = texSand(p,l);\n    \n    // Figure out how wet the sand is. This is just some quasi-good value\n    // that is vaguely related to the height of the water, but higher.\n  float wetness = clamp(smoothstep(OCEAN_HEIGHT, 0.075, p.y),\n                          0.0,1.0);\n    \n    // Get the appearance of reflective wet sand.\n    vec3 wet = shadeWetSandR(p,d,e,n,i,ld,tex);\n    // Get the appearance of the dry sand.\n    vec3 dry = shadeDrySand(i,tex);\n\n    // Return a mix of wet and dry sand based on the wetness of the sand.\n  return mix(wet,dry,wetness);\n}\n\n\n/*\n        Here we handle the materials ... \n*/\nvec3 shade( in vec3 p, in vec3 d, in vec3 e )\n{\n    // Get the distance for that gentle blend at the horizon.\n    float l = length(p-e);\n    // Get the sun direction and sky color once, and pass it around.\n    vec3 ld = sunDir();\n    vec3 s = sky(d,ld);\n    \n    // Take care of the appearance of culled stuff--they're sky now.\n    if(l > MAX_DEPTH) return s;\n    \n    // Get the ID of the object we're shading, and make a place\n    // to store the final result.\n    vec4  id = distID(p,false);\n    vec3 result;\n    \n    // Get the normal and create a general Oren Nayar term to be\n    // the shade functions' village bicycle, right next to the\n    // light direction, which is the village Razor scooter.\n    vec3 n = norm(p,false);\n    vec3 i = light(p,d,e,n,ld);\n \n       \n            \n        if(id.t == ID_SAND)\tresult = shadeSandR(p,d,e,n,i,ld,l);\n    else\n        if ( id.t==ID_ROCK )\n        {\n            result = texture(iChannel2,id.zw/vec2(.2,20.)).rgb\n                 * (.5 + .5*texture(iChannel1,id.zw/vec2(2.,100.)).r)*i\n                ;\n        }\n    else\n        result = shadeSandR(p,d,e,n,i,ld,l);\n    shadeScene(result,false,id.t,p,l,n,id.zw,i,ld,d);  \n    // Mix this shaded color with the color of the sky at far distances,\n    // so we don't have that ugly plane() @ MAX_DEPTH edge.\n\treturn mix(s,result,smoothstep(0.0, MAX_DEPTH*.125, clamp(MAX_DEPTH-l,0.0,MAX_DEPTH*.125)));\n}\n\nvec3 shadeInv( in vec3 p, in vec3 d, in vec3 e )\n{\n    // Get the distance for that gentle blend at the horizon.\n    float l = length(p-e);\n    // Get the sun direction and sky color once, and pass it around.\n    vec3 ld = sunDir();\n    vec3 s = sky(d,ld);\n    \n    // Take care of the appearance of culled stuff--they're sky now.\n    if(l > 100.) return s;\n    \n    // Get the ID of the object we're shading, and make a place\n    // to store the final result.\n    vec4  id = distInvID(p);\n    vec3 result;\n    \n    // Get the normal and create a general Oren Nayar term to be\n    // the shade functions' village bicycle, right next to the\n    // light direction, which is the village Razor scooter.\n    vec3 n = norm(p,false);\n    vec3 i = light(p,d,e,n,ld);\n  \n    shadeScene(result,false,id.t,p,l,n,id.zw,i,ld,d);  \n    // Mix this shaded color with the color of the sky at far distances,\n    // so we don't have that ugly plane() @ MAX_DEPTH edge.\n\treturn mix(s,result,smoothstep(0.0, MAX_DEPTH*.125, clamp(MAX_DEPTH-l,0.0,MAX_DEPTH*.125)));\n}\n\n/*\n\tPerforms some quick post-processing. Does gamma correction\n\tand adds a soft vignette just to make whatever you're doing\n\tlook pretty.\n*/\nvec3 postProcess( in vec2 uv, in vec3 c )\n{\n    float vig = 1.0-dot(uv,uv)*.3;\n    return pow(c,vec3(1.0/2.2))*vig;\n}\n\n//----------------------------------------------------------------------------------------------\n\n// RAY MARCHING end\n//----------------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    #if 0\n    storage_system();\n\n    var(camPos);\n    var(camRot)*PI*2.;\n    #else\n    vec4 camPos   = load_value( CAM_POS   );\n    vec4 camRot   = load_value( CAM_ROT   );\n    vec4 guiState = load_value( GUI_STATE );\n    vec4 obj0     = load_value( OBJ_0     );\n    vec4 obj1     = load_value( OBJ_1     );\n    vec4 obj2     = load_value( OBJ_2     );\n    vec4 obj3     = load_value( OBJ_3     );\n    vec4 obj_mpallin = load_value( OBJ_M_PALLIN );\n    vec4 obj_boat    = load_value( OBJ_BOAT     );\n    vec4 obj_bafryce = load_value( OBJ_BAFRYCE  );\n    vec4 game_state  = load_value( GAME_STATE  );\n    vec4 splashState = load_value( SPLASH_STATE  );\n    #endif\n    if(splashState.x==0.)\n    {\tfloat d=200.;\n    \tcamPos=vec4(d,30,d,0);\n    \tcamRot=vec4(0.20,D2R(-135.),0,0);\n    }\n   \n    scene.objs[0] = obj0;\n    scene.objs[1] = obj1;\n    scene.objs[2] = obj2;\n    scene.objs[3] = obj3;\n    scene.mpallin = obj_mpallin;\n    scene.boat    = obj_boat;\n    scene.bafryce = obj_bafryce;\n    scene.gameState = game_state;\n    scene.splashState = splashState;\n    \n    \n    \n    // read camera position & orientation\n\tif(fragCoord.y/iResolution.y < .25)\n    {\n    vec3 p = vec3(0,0.08,-2);\n        \n    vec3 ray=camera_ray(p.xyzx , vec4(0), (fragCoord.xy-iResolution.xy*vec2(.75,.75*.15))/iResolution.x*2. );\n\n    \n    // da qui il ray marcher ..\n\t \t vec2 uv = fragCoord / iResolution.xy - 0.5;\n\t\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio   \n    \tvec3 d=ray,e=p+ray*5.;\n        \n    \t\n        if ( iFrame - 16 * ( iFrame/16 ) <= 1 )\n        {\n        \t//fragColor = marchInv(p,d,e) ? vec4(postProcess(uv,shadeInv(p,d,e)),1.0) : vec4(0.0);\n            fragColor = marchInv(p,d,e) ? vec4(1.0) : vec4(0.0);\n            int m = int(fragCoord.x) + int(fragCoord.y);\n            m = m - 2 * (m / 2);\n            if (  m == 0  || scene.splashState.x == 0. )\n            {\n                fragColor = vec4(0);\n            }\n        } else\n        {\n            discard;\n        }\n    \t\n    \treturn;\n    }\n    if ( iFrame == 0 )\n    {\n        discard;\n    }\n    \n    #if 0\n    // cast a ray from the camera\n    vec2 iRes=iResolution.xy*vec2(.5,.65);\n    vec3 ray = normalize( vec3( (fragCoord.xy-iRes)/iResolution.x, 1 ) );\n    ray.zy = ray.zy*cos(camRot.x) + sin(camRot.x)*vec2(1,-1)*ray.yz;\n    ray.xz = ray.xz*cos(camRot.y) + sin(camRot.y)*vec2(1,-1)*ray.zx;\n    #else\n    vec3 ray = CAMERA_RAY();\n    #endif\n    vec3 p = camPos.xyz;\n    \n    // da qui il ray marcher ..\n\t  vec2 uv = fragCoord / iResolution.xy - 0.5;\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio   \n    vec3 d=ray,e=p+ray*100.;\n     march(p,d,e,false);\n    \n    // Store the final pixel color.\n    //fragColor = postProcess(uv,shade(p,d,e)).rgbb*s;\n    // Eventually the alpha of fragColor may be used.\n    fragColor = vec4(postProcess(uv,shade(p,d,e)),1.0);\n        \n   \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n//----------------------------------------------------------------------------------------------\n// LOAD/STORE\n\n#if 0\n//NOTE(theGiallo): old stuff\n#define storage_system()  vec2 r_inx=vec2(0.0);vec2 w_inx=vec2(0.0);fragColor = vec4(0.0);\n#define var(vr) vec4 vr = texture( iChannel3, ((r_inx+=vec2(1.,0.))-vec2(0.5,0.)) / iChannelResolution[3].xy, -100.0 )\n#else\n\n#define CAM_POS      vec2( 0,0)\n#define CAM_ROT      vec2( 1,0)\n#define CAM_VEL      vec2( 2,0)\n#define BASE_CAM_ROT vec2( 3,0)\n#define MOUSE        vec2( 4,0)\n#define GUI_STATE    vec2( 5,0)\n#define OBJ_0        vec2( 6,0) // laptop\n#define OBJ_1        vec2( 7,0) // coconut\n#define OBJ_2        vec2( 8,0) // sunscreen\n#define OBJ_3        vec2( 9,0) // ??\n#define OBJ_4        vec2(10,0) // M_Pallin\n#define OBJ_5        vec2(11,0) // boat\n#define OBJ_6        vec2(12,0) // Bafryce\n#define TEXT_AREA    vec2(14,0)\n\n#define OBJ_LAPTOP   OBJ_0\n#define OBJ_COCONUT  OBJ_1\n#define OBJ_SSCREEN  OBJ_2\n//#define OBJ_UNKNOWN  OBJ_3\n#define OBJ_M_PALLIN OBJ_4\n#define OBJ_BOAT     OBJ_5\n#define OBJ_BAFRYCE  OBJ_6\n\n#define TEXT_LOOK_LAPTOP      0.\n#define TEXT_LOOK_COCONUT     1.\n#define TEXT_LOOK_SSCREEN     2.\n#define TEXT_LOOK_3           3.\n#define TEXT_LOOK_M_PALLIN    4.\n#define TEXT_LOOK_BOAT        5.\n#define TEXT_LOOK_BAFRYCE     6.\n#define TEXT_TALK_M_PALLIN_0  7.\n#define TEXT_TALK_M_PALLIN_1  8.\n#define TEXT_TALK_M_PALLIN_2  9.\n#define TEXT_TALK_M_PALLIN_3 10.\n#define TEXT_TALK_M_PALLIN_4 11.\n#define TEXT_TALK_M_PALLIN_5 12.\n#define TEXT_TALK_M_PALLIN_6 13.\n#define TEXT_TALK_M_PALLIN_7 14.\n#define TEXT_TALK_BAFRYCE    15.\n\nvec4\nload_value( in vec2 uv_code )\n{\n    return texture( iChannel3, (uv_code+0.5)/iChannelResolution[3].xy, -100.0 );\n}\n\nfloat\nis_inside( vec2 p, vec2 c )\n{\n    vec2 d = abs( p - 0.5 - c ) - 0.5;\n    return - max( d.x, d.y );\n}\nbool\nis_value( in vec2 frag_coord, in vec2 tx_code )\n{\n    return is_inside( frag_coord, tx_code ) > 0.0;\n}\n#define IS_VALUE(c) is_value( fragCoord, c )\n#endif\n\n// LOAD/STORE end\n//----------------------------------------------------------------------------------------------\n\n#define TEXT_CHARS_COUNT 63\n#define TEXTS_COUNT 16 \nconst int texts[TEXTS_COUNT * TEXT_CHARS_COUNT] = int[TEXTS_COUNT * TEXT_CHARS_COUNT]\n(\n // 0    1    2    3    4    5    6    7    8    9    10   11   12   13   14   15   16   17   18   19   20   21   22   23\n // look laptop\n    0x49,0x74,32,0x6c,0x6f,0x6f,0x6b,0x73,32,0x6c,0x69,0x6b,0x65,32,0x74,0x68,\n    0x65,32,0x6c,0x61,0x70,0x74,0x6f,0x70,32,0x6f,0x66,32,0x42,0x61,0x66,0x72,\n    0x79,0x63,0x65,0x2e,32,32,32,32,32,32,32,32,32,32,32,32,\n    32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,\n    \n// look coconut\n    0x41,32,0x63,0x6f,0x63,0x6f,0x6e,0x75,0x74,32,0x6e,0x75,0x74,0x2e,32,0x0a,\n    0x54,0x68,0x65,32,0x63,0x6f,0x63,0x6f,0x6e,0x75,0x74,32,0x6e,0x75,0x74,32,\n    0x69,0x73,32,0x61,32,0x67,0x69,0x61,0x6e,0x74,32,0x6e,0x75,0x74,0x2e,0x2e,\n    0x2e,32,32,32,32,32,32,32,32,32,32,32,32,32,32,\n    \n// look sscreen\n    0x41,32,0x62,0x6f,0x74,0x74,0x6c,0x65,32,0x6f,0x66,32,0x73,0x75,0x6e,0x73,\n    0x63,0x72,0x65,0x65,0x6e,0x2e,32,32,32,32,32,32,32,32,32,32,\n    32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,\n    32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,\n    \n// look 3\n    0x49,0x74,0x27,0x73,32,0x61,32,0x63,0x79,0x61,0x6e,32,0x73,0x70,0x68,0x65,\n    0x72,0x65,32,32,32,32,32,32,32,32,32,32,32,32,32,32,\n    32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,\n    32,32,32,32,32,32,32,32,32,32,32,32,32,32, 32,\n\n// look M Pallin\n    0x49,0x74,32,0x6c,0x6f,0x6f,0x6b,0x73,32,0x6c,0x69,0x6b,0x65,32,0x4d,0x5f,\n    0x50,0x61,0x6c,0x6c,0x69,0x6e,0x21,32,0x41,0x6e,0x64,32,0x69,0x74,32,0x6c,\n    0x6f,0x6f,0x6b,0x73,32,0x6f,0x6e,32,0x76,0x61,0x63,0x61,0x74,0x69,0x6f,0x6e,\n    0x2e,32,32,32,32,32,32,32,32,32,32,32,32,32,32,\n    \n// look boat\n    0x49,0x74,0x27,0x73,32,0x61,32,0x62,0x65,0x61,0x75,0x74,0x69,0x66,0x75,0x6c,\n    32,0x6d,0x6f,0x74,0x6f,0x72,0x62,0x6f,0x61,0x74,0x21,32,32,32,32,32,\n    32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,\n    32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,\n    \n// look bafrice\n    0x49,0x74,32,0x6c,0x6f,0x6f,0x6b,0x73,32,0x6c,0x69,0x6b,0x65,32,0x42,0x61,\n    0x66,0x72,0x79,0x63,0x65,0x21,32,32,32,32,32,32,32,32,32,32,\n    32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,\n    32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,\n\n// talk M Pallin 0\n    0x59,0x65,0x73,0x2c,32,0x49,0x27,0x6d,32,0x4d,0x5f,0x50,0x61,0x6c,0x6c,0x69,\n    0x6e,0x2e,32,0x49,0x27,0x6d,32,0x6f,0x6e,32,0x76,0x61,0x63,0x61,0x74,0x69,\n    0x6f,0x6e,0x2c,32,0x73,0x6f,32,0x64,0x6f,0x6e,0x27,0x74,32,0x62,0x6f,0x74,\n    0x68,0x65,0x72,32,0x6d,0x65,0x2e,32,32,32,32,32,32,32,32,\n\n// talk M Pallin 1\n    0x54,0x6f,32,0x6c,0x65,0x61,0x76,0x65,0x3f,32,0x4f,0x4b,0x2c,32,0x62,0x72,\n    0x69,0x6e,0x67,32,0x6d,0x65,32,0x74,0x68,0x61,0x74,32,0x6c,0x61,0x70,0x74,\n    0x6f,0x70,0x2c,32,0x61,32,0x64,0x72,0x69,0x6e,0x6b,32,0x61,0x6e,0x64,32,\n    0x74,0x68,0x65,32,0x73,0x75,0x6e,0x73,0x63,0x72,0x65,0x65,0x6e,0x2e,32,\n    \n// talk M Pallin 2\n    0x42,0x72,0x69,0x6e,0x67,32,0x6d,0x65,32,0x74,0x68,0x61,0x74,32,0x6c,0x61,\n    0x70,0x74,0x6f,0x70,0x2c,32,0x61,32,0x64,0x72,0x69,0x6e,0x6b,32,0x61,0x6e,\n    0x64,32,0x74,0x68,0x65,32,0x73,0x75,0x6e,0x73,0x63,0x72,0x65,0x65,0x6e,32,\n    0x61,0x6e,0x64,32,0x49,0x27,0x6c,0x6c,32,0x68,0x65,0x6c,0x70,0x2e,32,\n    \n// talk M Pallin 3\n    0x4f,0x70,0x65,0x6e,32,0x74,0x68,0x65,32,0x6c,0x61,0x70,0x74,0x6f,0x70,0x2e,\n    32,0x59,0x6f,0x75,32,0x64,0x6f,0x2c,32,0x49,32,0x72,0x65,0x6c,0x61,0x78,\n    0x2e,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,\n    32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,\n        \n// talk M Pallin 4\n    0x47,0x65,0x74,32,0x74,0x68,0x65,32,0x73,0x6f,0x75,0x72,0x63,0x65,0x73,32,\n    0x66,0x72,0x6f,0x6d,32,0x74,0x68,0x65,32,0x73,0x65,0x72,0x76,0x65,0x72,0x2e,\n    32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,\n    32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,\n    \n// talk M Pallin 5\n    0x57,0x72,0x69,0x74,0x65,32,0x74,0x68,0x65,32,0x63,0x6f,0x64,0x65,32,0x61,\n    0x73,32,0x49,32,0x74,0x65,0x6c,0x6c,32,0x79,0x6f,0x75,0x2e,32,32,32,\n    32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,\n    32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,\n\n// talk M Pallin 6\n    0x4e,0x6f,0x77,32,0x6c,0x65,0x74,0x27,0x73,32,0x67,0x65,0x74,32,0x74,0x68,\n    0x65,32,0x63,0x6f,0x64,0x65,32,0x6f,0x6e,0x6c,0x69,0x6e,0x65,32,0x61,0x6e,\n    0x64,32,0x72,0x75,0x6e,0x6e,0x69,0x6e,0x67,0x21,32,32,32,32,32,32,\n    32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,\n\n// talk M Pallin 7\n    0x57,0x69,0x74,0x68,32,0x74,0x68,0x65,32,0x62,0x6f,0x61,0x74,0x2c,32,0x74,\n    0x61,0x6b,0x65,32,0x74,0x68,0x65,32,0x72,0x69,0x76,0x65,0x72,32,0x6f,0x6e,\n    32,0x74,0x68,0x65,32,0x6f,0x74,0x68,0x65,0x72,32,0x73,0x69,0x64,0x65,32,\n    0x6f,0x66,32,0x74,0x68,0x65,32,0x69,0x73,0x6c,0x61,0x6e,0x64,0x2e,32,\n    \n// talk Bafryce\n    0x31,0x2c,32,0x49,0x6d,32,0x46,0x61,0x62,0x72,0x79,0x63,0x65,0x3b,32,0x75,\n    0x2e,0x73,0x68,0x61,0x64,0x65,0x3e,0x39,0x65,0x33,32,0x69,0x66,32,0x73,0x74,\n    0x75,0x64,0x79,0x28,0x75,0x29,32,0x75,0x2e,0x73,0x68,0x61,0x64,0x65,0x2a,0x3d,\n    0x31,0x65,0x32,0x36,0x3b,32,0x6c,0x73,0x74,0x6e,0x28,0x6d,0x65,0x29,0x3b\n\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor -= fragColor;\n\n    vec4 textArea = load_value( TEXT_AREA );\n    int text_area_id = int(textArea.x);\n    \n    // DEBUG\n  \n\n    int text_area_start = text_area_id * TEXT_CHARS_COUNT;\n    int text_area_end = text_area_start + TEXT_CHARS_COUNT - 1;\n\n    if ( text_area_id >= 0 )\n    {\n    \tvec2 uv = fragCoord / iResolution.xy;\n    \tfragColor -= fragColor;\n    \n    \tvec2 textResolution = vec2(64., 20.);\n        vec2 tex = fract(uv * textResolution);\n        vec2 index2 = uv * textResolution - tex;// + vec2( -1, 0 );\n        index2.y -= float(text_area_start / 63 ); // NOTE(theGiallo): subtract number of rows of previous texts\n        \n\t    int index = int(index2.x +  (textResolution.y-1.-index2.y)*63.);\n     \n        if ( index >= text_area_start\n          && index <= text_area_end )\n        {\n            int ch = texts[index];\n            tex.x = (tex.x - 0.5) * .5 + 0.5;\n            tex = clamp(tex, 0.02, 0.98);\n            int ch_m_16 = ch - 16 * ( ch / 16 );\n            tex += vec2(ch_m_16, 15 - ch / 16);\n            tex += 0.01;\n\n            tex /= 16.;\n\n\n            float f = texture( iChannel1, tex).x;        \n       \n\n            fragColor += f;\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// FabriceNeyret2 Fonts system :D\n\nvec4 char(vec2 p, int c) {\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,0);\n\treturn textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                        dFdx(p/16.),dFdy(p/16.) );\n }\n\n#define C(c) U.x-=.5; O+= char(U,CAPS+c)\nint CAPS=0;\n#define low CAPS=32\n#define caps CAPS=0\n\n// P_Mallin Shadertoy Logo :D\n\n\nfloat TestCurve(vec2 uv)\n{\n\tuv = 1.0 - uv;\n    return 1.0 - dot(uv, uv);\n}\n\nfloat Cross( const in vec2 A, const in vec2 B )\n{\n    return A.x * B.y - A.y * B.x;\n}\n\nvec2 GetUV(const in vec2 A, const in vec2 B, const in vec2 C, const in vec2 P)\n{\n    vec2 vPB = B - P;\n    float f1 = Cross(A-B, vPB);\n    float f2 = Cross(B-C, vPB);\n    float f3 = Cross(C-A, C-P);\n    \n    return vec2(f1, f2) / (f1 + f2 + f3);\n}\n\nfloat InCurve( const in vec2 A, const in vec2 B, const in vec2 C, const in vec2 P )\n{\n    vec2 vCurveUV = GetUV(A, B, C, P);\n    \n    float fResult = -1.0;\n\n\tfResult = max(fResult, (-vCurveUV.x));\n\tfResult = max(fResult, (-vCurveUV.y));\n\tfResult = max(fResult, (vCurveUV.x + vCurveUV.y - 1.0));\n\n\tfloat fCurveResult = TestCurve(vCurveUV);\n\t\t\n\tfResult = max(fResult, fCurveResult);\t\n\t\n    return fResult;\n}\n\nfloat InCurve2( const in vec2 A, const in vec2 B, const in vec2 C, const in vec2 P )\n{\n    vec2 vCurveUV = GetUV(A, B, C, P);\n\t\n    float fResult = -1.0;\n\n\tfResult = max(fResult, (vCurveUV.x + vCurveUV.y - 1.0));\n\t\n\tfloat fCurveResult = -TestCurve(vCurveUV);\n\t\n\tfResult = max(fResult, fCurveResult);\t\n\t\n    return fResult;\n}\n\nfloat InTri( const in vec2 A, const in vec2 B, const in vec2 C, const in vec2 P )\n{\n\t#ifdef CURVES_ONLY\n\treturn 1.0;\n\t#endif\n\t\n    float f1 = Cross(B-A, A-P);\n    float f2 = Cross(C-B, B-P);\n    float f3 = Cross(A-C, C-P);\n\t\n    return (max(max(f1, f2), f3));\n}\n\nfloat InQuad( const in vec2 A, const in vec2 B, const in vec2 C, const in vec2 D, const in vec2 P )\n{\n\t#ifdef CURVES_ONLY\n\treturn 1.0;\n\t#endif\n\t\n    float f1 = Cross(B-A, A-P);\n    float f2 = Cross(C-B, B-P);\n    float f3 = Cross(D-C, C-P);\n    float f4 = Cross(A-D, D-P);\n    \n    return (max(max(max(f1, f2), f3), f4));\n}\n\n\nfloat Glyph0(const in vec2 uv)\n{\n    const vec2  vP0 = vec2 ( 0.112, 0.056 );\n    const vec2  vP1 = vec2 ( 0.136, 0.026 );\n    const vec2  vP2 = vec2 ( 0.108, 0.022 );\n    const vec2  vP3 = vec2 ( 0.083, 0.017 ); \n    const vec2  vP4 = vec2 ( 0.082, 0.036 ); \n    const vec2  vP5 = vec2 ( 0.088, 0.062 ); \n    const vec2  vP6 = vec2 ( 0.115, 0.086 ); \n    const vec2  vP7 = vec2 ( 0.172, 0.147 ); \n    const vec2  vP8 = vec2 ( 0.100, 0.184 ); \n    const vec2  vP9 = vec2 ( 0.034, 0.206 ); \n    const vec2 vP10 = vec2 ( 0.021, 0.160 ); \n    const vec2 vP11 = vec2 ( 0.011, 0.114 ); \n    const vec2 vP12 = vec2 ( 0.052, 0.112 ); \n    const vec2 vP13 = vec2 ( 0.070, 0.108 ); \n    const vec2 vP14 = vec2 ( 0.075, 0.126 );\n    const vec2 vP15 = vec2 ( 0.049, 0.124 );\n    const vec2 vP16 = vec2 ( 0.047, 0.148 );\n    const vec2 vP17 = vec2 ( 0.046, 0.169 );\n    const vec2 vP18 = vec2 ( 0.071, 0.171 );\n    const vec2 vP19 = vec2 ( 0.098, 0.171 ); \n    const vec2 vP20 = vec2 ( 0.097, 0.143 ); \n    const vec2 vP21 = vec2 ( 0.100, 0.118 ); \n    const vec2 vP22 = vec2 ( 0.080, 0.100 ); \n    const vec2 vP23 = vec2 ( 0.055, 0.083 ); \n    const vec2 vP24 = vec2 ( 0.050, 0.052 ); \n    const vec2 vP25 = vec2 ( 0.052, 0.004 ); \n    const vec2 vP26 = vec2 ( 0.107, 0.010 ); \n    const vec2 vP27 = vec2 ( 0.148, 0.011 ); \n    const vec2 vP28 = vec2 ( 0.140, 0.041 ); \n    const vec2 vP29 = vec2 ( 0.139, 0.069 ); \n\n    float fDist = 1.0;\n\n\tfDist = min( fDist, InCurve2(vP6,vP7,vP8, uv) );\n    fDist = min( fDist, InCurve2(vP8,vP9,vP10, uv) );\n\tfDist = min( fDist, InCurve2(vP10,vP11,vP12, uv) );\n    fDist = min( fDist, InCurve2(vP12,vP13,vP14, uv) );\n\tfDist = min( fDist, InCurve(vP14,vP15,vP16, uv) );\n    fDist = min( fDist, InCurve(vP16,vP17,vP18, uv) );\n    fDist = min( fDist, InCurve(vP18,vP19,vP20, uv) );\n    fDist = min( fDist, InCurve(vP20,vP21,vP22, uv) );\n\tfDist = min( fDist, InCurve2(vP22,vP23,vP24, uv) );\n    fDist = min( fDist, InCurve2(vP24,vP25,vP26, uv) );\n    fDist = min( fDist, InCurve2(vP26,vP27,vP28, uv) );\n    fDist = min( fDist, InCurve2(vP28,vP29,vP0, uv) );\n\tfDist = min( fDist, InCurve(vP0,vP1,vP2, uv) );\n\tfDist = min( fDist, InCurve(vP2,vP3,vP4, uv) );\n    fDist = min( fDist, InCurve(vP4,vP5,vP6, uv) );\n\n\n    fDist = min( fDist, InTri(vP0, vP1, vP28, uv) );\n\tfDist = min( fDist, InQuad(vP26, vP1, vP2, vP3, uv) );\n    fDist = min( fDist, InTri(vP3, vP4, vP24, uv) );\n    fDist = min( fDist, InTri(vP4, vP5, vP24, uv) );\n    fDist = min( fDist, InTri(vP24, vP5, vP22, uv) );\n    fDist = min( fDist, InTri(vP5, vP6, vP22, uv) );\n    fDist = min( fDist, InTri(vP22, vP6, vP21, uv) );\n    fDist = min( fDist, InTri(vP6, vP8, vP21, uv) );\n    fDist = min( fDist, InTri(vP21, vP8, vP20, uv) );\n    fDist = min( fDist, InTri(vP20, vP8, vP19, uv) );\n    fDist = min( fDist, InTri(vP19, vP8, vP18, uv) );\n    fDist = min( fDist, InTri(vP18, vP8, vP10, uv) );\n    fDist = min( fDist, InTri(vP10, vP16, vP17, uv) );\n    fDist = min( fDist, InTri(vP10, vP15, vP16, uv) );\n    fDist = min( fDist, InTri(vP10, vP12, vP16, uv) );\n    fDist = min( fDist, InTri(vP12, vP14, vP15, uv) );\n\n    return fDist;\n}\n\nfloat Glyph1(const in vec2 uv, const in vec2 vOffset)\n{\n    vec2 vP0 = vec2 ( 0.171, 0.026 ) + vOffset;\n    vec2 vP1 = vec2 ( 0.204, 0.022 ) + vOffset;\n    const vec2 vP2 = vec2 ( 0.170, 0.185 );\n    const vec2 vP3 = vec2 ( 0.137, 0.185 );\n    \n    return InQuad(vP0, vP1, vP2, vP3, uv);\n}\n\nfloat Glyph3(const in vec2 uv, vec2 vOffset)\n{\n    vec2 vP0 = vec2 ( 0.212, 0.112 ) + vOffset;\n    vec2 vP2 = vec2 ( 0.243, 0.112 ) + vOffset;\n    const vec2  vP4 = vec2 ( 0.234, 0.150 );\n    const vec2  vP5 = vec2 ( 0.230, 0.159 );\n    const vec2  vP6 = vec2 ( 0.243, 0.164 );\n    const vec2  vP7 = vec2 ( 0.257, 0.164 );\n    const vec2  vP8 = vec2 ( 0.261, 0.148 );\n    const vec2 vP10 = vec2 ( 0.265, 0.164 );\n    const vec2 vP11 = vec2 ( 0.256, 0.180 );\n    const vec2 vP12 = vec2 ( 0.239, 0.185 );\n    const vec2 vP13 = vec2 ( 0.194, 0.194 );\n    const vec2 vP14 = vec2 ( 0.203, 0.150 );\n    const vec2 vP16 = vec2 ( 0.212, 0.113 );\n\n    float fDist = 1.0;\n    fDist = min( fDist, InCurve(vP4,vP5,vP6, uv) );\n    fDist = min( fDist, InCurve(vP6,vP7,vP8, uv) );\n    fDist = min( fDist, InCurve2(vP10,vP11,vP12, uv) );\n    fDist = min( fDist, InCurve2(vP12,vP13,vP14, uv) );\n\n    fDist = min( fDist, InQuad(vP0, vP2, vP4, vP14, uv) );\n    fDist = min( fDist, InTri(vP14, vP4, vP5, uv) );\n    fDist = min( fDist, InTri(vP14, vP5, vP12, uv) );\n    fDist = min( fDist, InTri(vP5, vP6, vP12, uv) );\n    fDist = min( fDist, InTri(vP6, vP7, vP12, uv) );\n    fDist = min( fDist, InTri(vP6, vP10, vP12, uv) );\n    fDist = min( fDist, InTri(vP8, vP10, vP7, uv) );\n    \n    return fDist;\n}\n\nfloat Glyph4(const in vec2 uv)\n{\n    vec2 vP = uv - vec2(0.305, 0.125);\n    vP /= 0.065;\n    vP.x *= 1.5;\n    vP.x += vP.y * 0.25;\n    \n    vec2 vP2 = vP;\n\n    vP.y = abs(vP.y);\n    vP.y = pow(vP.y, 1.2);\n    float f= length(vP);\n    \n    vP2.x *= 1.2;\n    float f2 = length(vP2 * 1.5 - vec2(0.6, 0.0));\n        \n    return max(f - 1.0, 1.0 - f2) / 20.0;\n} \n\nfloat Glyph5(const in vec2 uv)\n{\n    const vec2  vP0 = vec2 ( 0.507, 0.138 );\n    const vec2  vP1 = vec2 ( 0.510, 0.065 );\n    const vec2  vP2 = vec2 ( 0.570, 0.066 );\n    const vec2  vP3 = vec2 ( 0.598, 0.066 );\n    const vec2  vP4 = vec2 ( 0.594, 0.092 );\n    const vec2  vP5 = vec2 ( 0.599, 0.131 );\n    const vec2  vP6 = vec2 ( 0.537, 0.137 );\n    const vec2  vP8 = vec2 ( 0.538, 0.125 );\n    const vec2  vP9 = vec2 ( 0.564, 0.129 );\n    const vec2 vP10 = vec2 ( 0.574, 0.100 );\n    const vec2 vP11 = vec2 ( 0.584, 0.085 );\n    const vec2 vP12 = vec2 ( 0.571, 0.079 );\n    const vec2 vP13 = vec2 ( 0.557, 0.081 );\n    const vec2 vP14 = vec2 ( 0.549, 0.103 );\n    const vec2 vP15 = vec2 ( 0.518, 0.166 );\n    const vec2 vP16 = vec2 ( 0.557, 0.166 );\n    const vec2 vP17 = vec2 ( 0.589, 0.163 );\n    const vec2 vP18 = vec2 ( 0.602, 0.137 );\n    const vec2 vP20 = vec2 ( 0.602, 0.152 );\n    const vec2 vP21 = vec2 ( 0.572, 0.194 );\n    const vec2 vP22 = vec2 ( 0.537, 0.185 );\n    const vec2 vP23 = vec2 ( 0.503, 0.189 );\n    \n    float fDist = 1.0;\n    fDist = min( fDist, InCurve2(vP0,vP1,vP2, uv) ); \n    fDist = min( fDist, InCurve2(vP2,vP3,vP4, uv) ); \n    fDist = min( fDist, InCurve2(vP4,vP5,vP6, uv) );\n    fDist = min( fDist, InCurve(vP8,vP9,vP10, uv) ); \n    fDist = min( fDist, InCurve(vP10,vP11,vP12, uv) ); \n    fDist = min( fDist, InCurve(vP12,vP13,vP14, uv) );\n    fDist = min( fDist, InCurve(vP14,vP15,vP16, uv) );\n    fDist = min( fDist, InCurve(vP16,vP17,vP18, uv) ); \n    fDist = min( fDist, InCurve2(vP20,vP21,vP22, uv) ); \n    fDist = min( fDist, InCurve2(vP22,vP23,vP0, uv) );\n\n    fDist = min( fDist, InTri(vP0, vP2, vP13, uv) );\n    fDist = min( fDist, InTri(vP13, vP2, vP12, uv) );\n    fDist = min( fDist, InTri(vP2, vP11, vP12, uv) );\n    fDist = min( fDist, InTri(vP2, vP4, vP11, uv) );\n    fDist = min( fDist, InTri(vP11, vP4, vP10, uv) );\n    fDist = min( fDist, InTri(vP10, vP4, vP9, uv) );\n    fDist = min( fDist, InTri(vP6, vP8, vP9, uv) );\n    fDist = min( fDist, InTri(vP0, vP13, vP14, uv) );\n    fDist = min( fDist, InTri(vP0, vP14, vP15, uv) );\n    fDist = min( fDist, InTri(vP15, vP16, vP22, uv) );\n    fDist = min( fDist, InTri(vP16, vP17, vP22, uv) );\n    fDist = min( fDist, InTri(vP17, vP18, vP20, uv) );\n    \n    return fDist;\n}\n\nfloat Glyph6(const in vec2 uv)\n{\n    const vec2  vP0 = vec2 ( 0.638 , 0.087 ); \n    const vec2  vP1 = vec2 ( 0.648 , 0.073 ); \n    const vec2  vP2 = vec2 ( 0.673 , 0.068 ); \n    const vec2  vP3 = vec2 ( 0.692 , 0.069 ); \n    const vec2  vP4 = vec2 ( 0.687 , 0.086 ); \n    const vec2  vP5 = vec2 ( 0.688 , 0.104 ); \n    const vec2  vP6 = vec2 ( 0.672 , 0.102 ); \n    const vec2  vP7 = vec2 ( 0.659 , 0.099 ); \n    const vec2  vP8 = vec2 ( 0.663 , 0.092 ); \n    const vec2  vP9 = vec2 ( 0.662 , 0.086 ); \n    const vec2 vP10 = vec2 ( 0.655 , 0.086 ); \n    const vec2 vP11 = vec2 ( 0.644 , 0.087 ); \n    const vec2 vP12 = vec2 ( 0.637 , 0.102 ); \n    const vec2 vP13 = vec2 ( 0.638 , 0.094 ); \n\n    float fDist = 1.0;\n    fDist = min( fDist, InCurve2(vP0,vP1,vP2, uv) ); \n    fDist = min( fDist, InCurve2(vP2,vP3,vP4, uv) ); \n    fDist = min( fDist, InCurve2(vP4,vP5,vP6, uv) ); \n    fDist = min( fDist, InCurve2(vP6,vP7,vP8, uv) ); \n    fDist = min( fDist, InCurve(vP8,vP9,vP10, uv) ); \n    fDist = min( fDist, InCurve(vP10,vP11,vP12, uv) );\n\n    fDist = min( fDist, InQuad(vP2, vP4, vP6, vP8, uv) );\n    fDist = min( fDist, InTri(vP9, vP2, vP8, uv) );\n    fDist = min( fDist, InTri(vP10, vP2, vP9, uv) );\n    fDist = min( fDist, InQuad(vP0, vP2, vP10, vP11, uv) );\n    fDist = min( fDist, InTri(vP11, vP12, vP0, uv) );\n    \n    return fDist;\n}\n\nfloat Glyph7(const in vec2 uv)\n{\n    const vec2 vP0 = vec2 ( 0.693 , 0.068 );\n    const vec2 vP1 = vec2 ( 0.748 , 0.069 );\n    const vec2 vP2 = vec2 ( 0.747 , 0.078 );\n    const vec2 vP3 = vec2 ( 0.691 , 0.077 );\n    \n    return InQuad(vP0, vP1, vP2, vP3, uv);\n}\n\n\nfloat Glyph8(const in vec2 uv)\n{ \n    vec2 vP = uv - vec2(0.788, 0.125);\n    vP /= 0.065;\n    vP.x *= 1.4;\n    vP.x += vP.y * 0.25;\n    \n    vec2 vP2 = vP;\n    \n    vP.y = abs(vP.y);\n    vP.y = pow(vP.y, 1.2);\n    float f= length(vP);\n    \n    vP2.x *= 1.5;\n    float f2 = length(vP2 * 1.5 - vec2(0.3, 0.0));\n    \n    \n    return max(f - 1.0, 1.0 - f2) / 20.0;\n}\n\nfloat Glyph11(const in vec2 uv)\n{\n    const vec2  vP0 = vec2 ( 0.921 , 0.070 );\n    const vec2  vP2 = vec2 ( 0.955 , 0.070 );\n    const vec2  vP4 = vec2 ( 0.926 , 0.202 );\n    const vec2  vP5 = vec2 ( 0.926 , 0.240 );\n    const vec2  vP6 = vec2 ( 0.885 , 0.243 );\n    const vec2  vP7 = vec2 ( 0.852 , 0.239 );\n    const vec2  vP8 = vec2 ( 0.859 , 0.219 );\n    const vec2  vP9 = vec2 ( 0.862 , 0.192 );\n    const vec2 vP10 = vec2 ( 0.889 , 0.189 );\n    const vec2 vP12 = vec2 ( 0.928 , 0.178 );\n    const vec2 vP13 = vec2 ( 0.949 , 0.173 );\n    const vec2 vP14 = vec2 ( 0.951 , 0.162 );\n    const vec2 vP15 = vec2 ( 0.960 , 0.150 );\n    const vec2 vP16 = vec2 ( 0.960 , 0.144 );\n    const vec2 vP18 = vec2 ( 0.971 , 0.144 );\n    const vec2 vP19 = vec2 ( 0.968 , 0.157 );\n    const vec2 vP20 = vec2 ( 0.957 , 0.171 );\n    const vec2 vP21 = vec2 ( 0.949 , 0.182 );\n    const vec2 vP22 = vec2 ( 0.922 , 0.189 );\n    const vec2 vP24 = vec2 ( 0.900 , 0.196 );\n    const vec2 vP25 = vec2 ( 0.866 , 0.205 );\n    const vec2 vP26 = vec2 ( 0.871 , 0.217 );\n    const vec2 vP27 = vec2 ( 0.871 , 0.225 );\n    const vec2 vP28 = vec2 ( 0.880 , 0.224 );\n    const vec2 vP29 = vec2 ( 0.889 , 0.218 );\n    const vec2 vP30 = vec2 ( 0.893 , 0.203 );\n\n    float fDist = 1.0;\n    fDist = min( fDist, InCurve2(vP4,vP5,vP6, uv) );\n    fDist = min( fDist, InCurve2(vP6,vP7,vP8, uv) );\n    fDist = min( fDist, InCurve2(vP8,vP9,vP10, uv) );\n    fDist = min( fDist, InCurve(vP12,vP13,vP14, uv) );\n\n    fDist = min( fDist, InCurve(vP14,vP15,vP16, uv) );\n    fDist = min( fDist, InCurve2(vP18,vP19,vP20, uv) );\n    fDist = min( fDist, InCurve2(vP20,vP21,vP22, uv) );\n\n    fDist = min( fDist, InCurve(vP24,vP25,vP26, uv) );\n    fDist = min( fDist, InCurve(vP26,vP27,vP28, uv) );\n    fDist = min( fDist, InCurve(vP28,vP29,vP30, uv) );\n    \n    fDist = min( fDist, InQuad(vP0, vP2, vP4, vP30, uv) );\n\n    fDist = min( fDist, InQuad(vP10, vP12, vP22, vP24, uv) );\n        \n    fDist = min( fDist, InTri(vP30, vP4, vP6, uv) );\n    fDist = min( fDist, InTri(vP30, vP6, vP29, uv) );\n    fDist = min( fDist, InTri(vP28, vP29, vP6, uv) );\n    fDist = min( fDist, InTri(vP28, vP6, vP27, uv) );\n    \n    fDist = min( fDist, InTri(vP8, vP27, vP6, uv) );\n    \n    fDist = min( fDist, InTri(vP8, vP26, vP27, uv) );\n    fDist = min( fDist, InTri(vP8, vP25, vP26, uv) );\n    fDist = min( fDist, InTri(vP25, vP10, vP24, uv) );\n    \n    fDist = min( fDist, InTri(vP12, vP13, vP20, uv) );\n    fDist = min( fDist, InTri(vP12, vP20, vP22, uv) );\n    fDist = min( fDist, InTri(vP13, vP14, vP20, uv) );\n    fDist = min( fDist, InTri(vP15, vP20, vP14, uv) );\n    fDist = min( fDist, InTri(vP15, vP18, vP20, uv) );\n    fDist = min( fDist, InTri(vP15, vP16, vP18, uv) );\n    \n    return fDist;\n}\n\nfloat Shadertoy(in vec2 uv)\n{\n    float fResult = 1.0;\n    \n    fResult = min(fResult, Glyph0(uv)); // S\n\n    vec2 vUVOffset = vec2(0.001, 0.0); // tail of h\n    vec2 vTailOffset = vec2(0.0, 0.0);  \n    float fUVScale = 1.0;\n\n    if(uv.x < 0.3)\n    {\n        if(uv.y < 0.12)\n        {\n            // top of h\n            fUVScale = -1.0;\n            vUVOffset = vec2(0.448, 0.25);  \n            vTailOffset = vec2(0.0, 0.0);   \n        }\n    }\n    else if(uv.x < 0.4)    \n    {\n        // tail of a\n        vUVOffset = vec2(-0.124, 0.0);  \n        vTailOffset = vec2(0.01, -0.04);    \n    }\n    else if(uv.x < 0.6)\n    {\n        // tail of d\n        vUVOffset = vec2(-0.248, 0.0);  \n        vTailOffset = vec2(0.02, -0.1); \n    }\n    else if(uv.x < 0.83)\n    {\n        // stalk of t\n        vUVOffset = vec2(-0.48, 0.0);   \n        vTailOffset = vec2(0.02, -0.1); \n    }\n    else\n    {\n        // start of y\n        vUVOffset = vec2(-0.645, 0.0);  \n        vTailOffset = vec2(0.005, -0.042);  \n    }\n    \n    fResult = min(fResult, Glyph3(uv * fUVScale + vUVOffset, vTailOffset)); // tails h, a, d, t, start of y and top of h\n\n\n    vec2 vUVOffset3 = vec2(0.0, 0.0);   // vertical of h\n    vec2 vTailOffset3 = vec2(0.0, 0.0);\n    \n    if(uv.x > 0.5)\n    {\n        // vertical of r\n        vUVOffset3 = vec2(-0.45, 0.0);  \n        vTailOffset3 = vec2(-0.01, 0.04);   \n    }\n    \n    fResult = min(fResult, Glyph1(uv + vUVOffset3, vTailOffset3)); // vertical of h, r\n\n    vec2 vUVOffset2 = vec2(0.0, 0.0); // curve of a\n    if(uv.x > 0.365)\n    {\n        vUVOffset2 = vec2(-0.125, 0.0); // curve of d\n    }\n\n    fResult = min(fResult, Glyph4(uv + vUVOffset2)); // curve of a, d\n    \n    fResult = min(fResult, Glyph5(uv)); // e\n\n    vec2 vUVOffset4 = vec2(0.001, 0.0); // top of r\n    vec2 vUVScale4 = vec2(1.0, 1.0);        \n    \n    if(uv.x > 0.7)\n    {\n        // o loop\n        vUVOffset4.x = 1.499;\n        vUVOffset4.y = 0.19;\n        \n        vUVScale4.x = -1.0;\n        vUVScale4.y = -1.0;\n    }\n    \n    fResult = min(fResult, Glyph6(uv * vUVScale4 + vUVOffset4)); // top of r and o loop\n\n    fResult = min(fResult, Glyph7(uv)); // cross t    \n    \n    fResult = min(fResult, Glyph8(uv)); // o1\n    \n    fResult = min(fResult, Glyph11(uv)); // y2        \n\n    return fResult; \n}\n\n\n\nvoid mainImage( out vec4 o, in vec2 uv )\n{\n    o -= o;\n   \n  //  if(iFrame > 250 )\n    //\tdiscard;\n    vec2 vUV = (uv.xy) / iResolution.xy;\n\t\t\tvUV.x = ((vUV.x - 0.40) * (iResolution.x / iResolution.y)) + 0.5;    \n\t\t\tvUV.y = .95 - vUV.y;\n    o += step(Shadertoy(vUV), 0.0) * mix(vec4(1,1,0,0),vec4(1,0,0,0),vUV.y*5. -.03);\n    \n   \n    uv /= iResolution.y;    \n    vec2 U;\n    vec4 O;O-=O;\n    U = ( uv - vec2(.60 ,.5024) ) * 16./3.;  caps;//C(30);\n    U.y*=0.8;U.x+=-uv.x * uv.y*sin(uv.x)*1.5;\n    C(0x49);C(0x73);C(0x6c);C(0x61);C(0x6e);C(0x64);//C(0x21);// \"Island\"\n   \t\n    O = O.xxxx;\n\to+= O * mix(vec4(1,1,0,0),vec4(1,0,0,0),1.0-U.y ); \n     \n    U = ( uv - vec2(.130 ,.28+sin(-.1+uv.x*2.)*.051) ) * 16./2.;  caps;//C(30);\n    \n \t// subtitle\n    C(0x54);C(0x68);C(0x65);C(0x20);C(0x5b);C(0x53);C(0x48);C(0x31);C(0x37);C(0x5d);C(0x20);C(0x61);C(0x64);C(0x76);C(0x65);C(0x6e);C(0x74);C(0x75);C(0x72);C(0x65);C(0x73);\n  \n    //  url of P_mallin \"a drift\"\n    float yy=.24;\n//     U = ( uv - vec2(.08 ,yy) ) * 16./1.3;  caps;//C(30);\n //   C(0x4e);C(0x6f);C(0x77);C(0x20);C(0x69);C(0x74);C(0x27);C(0x73);C(0x20);C(0x74);C(0x69);C(0x6d);C(0x65);C(0x20);C(0x74);C(0x6f);C(0x20);C(0x70);C(0x6c);C(0x61);C(0x79);C(0x20);C(0x74);C(0x68);C(0x69);C(0x73);C(0x3a);\n  //  U = ( uv - vec2(.08 ,yy-.1) ) * 16./1.3;  caps;//C(30);\n //   C(0x68);C(0x74);C(0x74);C(0x70);C(0x73);C(0x3a);C(0x2f);C(0x2f);C(0x77);C(0x77);C(0x77);C(0x2e);C(0x73);C(0x68);C(0x61);C(0x64);C(0x65);C(0x72);C(0x74);C(0x6f);C(0x79);C(0x2e);C(0x63);C(0x6f);C(0x6d);C(0x2f);C(0x76);C(0x69);C(0x65);C(0x77);C(0x2f);C(0x6c);C(0x64);C(0x6a);C(0x66);C(0x44);C(0x44);\n   \n    yy-=.1;\n     U = ( uv - vec2(.38 ,yy-.1) ) * 16./1.3;  caps;//C(30);\n   C(0x70);C(0x72);C(0x65);C(0x73);C(0x73);C(0x20);C(0x53);C(0x50);C(0x41);C(0x43);C(0x45);C(0x20);C(0x74);C(0x6f);C(0x20);C(0x63);C(0x6f);C(0x6e);C(0x74);C(0x69);C(0x6e);C(0x75);C(0x65);C(0x2e);\n\tif(uv.y<0.55)\n    {    O = O.xxxx;\n\t\n   \n    \n    o+=O;\n    }\n    \n    \n    \n    o.a = o.x>0.?1.:0.;\n \n \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 11542,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/luekil/monkey-island"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}