{
    "Shader": {
        "info": {
            "date": "1661755001",
            "description": "refraction study",
            "flags": 0,
            "hasliked": 0,
            "id": "7lVyWw",
            "likes": 15,
            "name": "water crystals 1",
            "published": 3,
            "tags": [
                "refraction",
                "ice",
                "queue"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 290
        },
        "renderpass": [
            {
                "code": "#define RES    (iResolution.xy)\n#define MINRES min(RES.x, RES.y)\n\n// todo\n// [x] reduce data copying in and out of ringbuffer.\n//     - this was a loss. array indexing < copies, I guess.\n// [x] try hexagon exact. might boost perf.\n//     - also a loss, of about 20% overall FPS.\n\n// globals\nfloat gT;\nconst float gMinimumRayContribution =   0.007;\nconst uint  gMaxSteps               =  30u;\nconst uint  gMaxRays                =  30u;\nconst float gSurfaceEpsilon         =   0.005;\nconst float gMaxDist                =  40.0;\nconst float gUnderstepFactor        =   0.99;\nconst float gBounceAttenuation      =   0.95;\n\nconst float PI                      = 3.141592653;\n\n\n// utils\nmat2 rot(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\n\n////////////////////////////\n// From Shane \"Neon Lit Hexagons\" - https://www.shadertoy.com/view/MsVfz1\n//////\n// The 2D hexagonal isosuface function: If you were to render a horizontal line and one that\n// slopes at 60 degrees, mirror, then combine them, you'd arrive at the following.\nfloat sdHex(in vec2 p) {\n    p = abs(p);\n    \n    // Below is equivalent to:\n    return max(p.x*.866025404 + p.y*.5, p.y); \n    //return max(dot(p, s*.5), p.x); // Hexagon.\n}\n\n// Note, for raymarching performance, inexact sdHex() seems faster.\n// From IQ - https://iquilezles.org/articles/distfunctions2d\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\n// From IQ - https://iquilezles.org/articles/distfunctions2d\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\nstruct ray2_t {\n    vec2  ro;\n    vec2  rd;\n    float contribution;\n    float side;         // 1 = external  -1 = internal\n};\n\n// ringbuffer of rays\n#define Q_TYPE ray2_t\n#define Q_MAX_ENTRIEs 10u\nQ_IMPLEMENTATION\n\n\n/////////////////////////////////////////////\n\n\n// business\n\nfloat map(in vec2 p) {\n    float d = 1e9;\n    // sdHexagon is exact distance, sdHex isn't,\n    // but sdHex outperforms sdHexagon by about 20% in overall FPS.\n//  d = min(d, sdHexagon((p + vec2(cos(gT), sin(gT))) * rot(gT * -0.87), 0.9));\n    d = min(d, sdHex    ((p + vec2(cos(gT), sin(gT))) * rot(gT * -0.87)) - 0.9);\n    d = min(d, length(p + vec2(cos(gT * 2.81), sin(-gT*2.21))) - 0.9);\n    d = min(d, 3.5 - abs(p.x) - p.y * p.y * 0.05);\n    d = min(d, 2.6 - abs(p.y) + p.x * p.x * 0.05);\n    return d;\n}\n\n// also cribbed from the same Shane shader\nvec2 sceneNormal(in vec2 p) {\n    const vec2 e = vec2(0.001, 0);\n    return normalize(\n        vec2(map(p + e.xy) - map(p - e.xy),\n             map(p + e.yx) - map(p - e.yx)));\n}\n\nfloat marchToIntersection(in ray2_t ray) {    \n    float rayDist = 0.0;\n    for (uint stepNum = 0u; stepNum < gMaxSteps; ++stepNum) {\n        vec2 p = ray.ro + ray.rd * rayDist;\n        float sceneDist = map(p);\n        if (sceneDist * ray.side < gSurfaceEpsilon) {\n            return rayDist;\n        }\n        rayDist += sceneDist * ray.side * gUnderstepFactor;\n    }\n    \n    return 1e9;\n}\n\n\n\n// The raymarching here is slightly different than usual.\n// Each pixel marches the same exact rays throughthe scene as every other pixel,\n// just finally coloring itself based on distance from each ray segment.\n// The inefficiency of this compared to rasterizing leaves me breathless.\n// Perhaps this would be better moved into a buffer.\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n\n    gT = iTime * 0.03 + 103.0;\n\n    float zoom   = 0.3;\n    vec2  p      = vec2(XY - RES/2.0) / MINRES * 2.0 / zoom;\n    float ss_wid = 0.5/MINRES/zoom; // screen-space line width\n    float ss_eps = 2.5/MINRES/zoom; // screen-space epsilon\n    \n    vec2  trg = iMouse.x < 1.0 ? vec2(0.0, sin(gT * 0.2)) : (iMouse.xy - RES/2.0) / MINRES * 2.0 / zoom;\n    \n    vec3 col = vec3(0.0);\n    \n    // add one ray to the queue.\n    ray2_t ray;\n    ray.ro           = vec2(-3.0, 0.0);\n    ray.rd           = normalize(trg - ray.ro);\n    ray.contribution = 1.0;\n    ray.side         = sign(map(ray.ro));\n    QEnqueue(ray);\n    \n    uint rayCount = 0u;\n    // process the queue\n    while (!QIsEmpty()) {\n      ray = QDequeue();\n      \n      // determine distance along ray to end\n      float rl = marchToIntersection(ray);\n      \n      const vec3 rayColor = vec3(0.2, 1.0, 0.8);\n      float d = sdSegment(p, ray.ro, ray.ro + ray.rd * rl) - ss_wid * 5.0 * ray.contribution;\n      col += mix(vec3(0.0), rayColor * ray.contribution, smoothstep(ss_eps, 0.0, d));\n      \n      // only continue if there's room to add two more rays\n      if (QSpaceLeft() < 2u) {\n          continue;\n      }\n      \n      rayCount += 1u;\n      if (rayCount > gMaxRays) {\n          continue;\n      }\n      \n      if (ray.contribution < gMinimumRayContribution) {\n          continue;\n      }\n\n      // prepare child ray/s\n\n      vec2 ro = ray.ro + ray.rd * rl;\n      if (dot(ro, ro) > 20.0 * 20.0) {\n          // out of bounds\n          continue;\n      }\n      \n      const float ior_air     = 1.0003;\n      const float ior_ice     = 1.309;\n      const float ior_water   = 1.333;\n      const float ior_quartz  = 1.46;\n      const float ior_diamond = 2.42;\n\n      float eta = ior_air / ior_ice;\n      vec2 n = sceneNormal(ro);\n      if (ray.side < 0.0) {\n          eta = 1.0 / eta;\n          n = -n;\n      }\n\n      ray2_t childRay;\n      childRay.rd               = refract(ray.rd, n, eta);\n      // if |refract()| is zero, it's total internal.\n      if (dot(childRay.rd, childRay.rd) > gSurfaceEpsilon) {\n          // not total internal\n          childRay.ro           = ro + childRay.rd * gSurfaceEpsilon * 4.0;\n          childRay.contribution = ray.contribution * 0.5 * gBounceAttenuation;\n          childRay.side         = -ray.side;\n          QEnqueue(childRay);\n      }\n      else {\n          // total internal\n          childRay.contribution = ray.contribution * gBounceAttenuation;\n      }\n      \n      childRay.rd           = reflect(ray.rd, n);\n      childRay.ro           = ro + childRay.rd * gSurfaceEpsilon * 2.0;\n      childRay.side         = ray.side;\n      QEnqueue(childRay);\n      \n    }\n    \n    // draw scene\n    vec3 sceneColor = vec3(0.4, 0.2, 0.2);\n    float sd = map(p);\n    col += sceneColor * 0.1        * smoothstep(ss_eps, 0.0,     sd          );\n    col = mix(col, sceneColor * 1.0, smoothstep(ss_eps, 0.0, abs(sd) - ss_wid));\n    \n    // boost darker colors\n    col = pow(col, vec3(1.0/1.7));\n    \n    RGBA = vec4(vec3(col), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\n////////////////////////////////////////////////////\n// #define Q_TYPE and Q_MAX_ENTRIES,\n// then put Q_IMPLEMENMTATION.\n// this is a basic ringbuffer.\n// NO ERROR CHECKING\n#define Q_IMPLEMENTATION                           \\\nconst uint gQCapacity = Q_MAX_ENTRIEs;             \\\nconst uint gQNumSlots = gQCapacity + 1u;           \\\nQ_TYPE gQ[gQNumSlots];                             \\\nuint gQHead = 0u;                                  \\\nuint gQTail = 0u;                                  \\\n                                                   \\\nuint QCount() {                                    \\\n\tif (gQHead >= gQTail) {                        \\\n\t\treturn gQHead - gQTail;                    \\\n\t}                                              \\\n\telse {                                         \\\n\t\treturn gQNumSlots - (gQTail - gQHead);     \\\n\t}                                              \\\n}                                                  \\\n                                                   \\\nuint QSpaceLeft() {                                \\\n\treturn gQCapacity - QCount();                  \\\n}                                                  \\\n                                                   \\\nbool QIsFull() {                                   \\\n\treturn QSpaceLeft() == 0u;                     \\\n}                                                  \\\n                                                   \\\nbool QIsEmpty() {                                  \\\n\treturn QCount() == 0u;                         \\\n}                                                  \\\n                                                   \\\nuint QEnqueueIndex() {                             \\\n\tgQHead = (gQHead + 1u) % gQNumSlots;           \\\n    return gQHead;                                 \\\n}                                                  \\\n                                                   \\\nuint QDequeueIndex() {                             \\\n\tgQTail = (gQTail + 1u) % gQNumSlots;           \\\n    return gQTail;                                 \\\n}                                                  \\\n                                                   \\\nvoid QEnqueue(Q_TYPE item) {                       \\\n\tgQ[QEnqueueIndex()] = item;                    \\\n}                                                  \\\n                                                   \\\nQ_TYPE QDequeue() {                                \\\n\treturn gQ[QDequeueIndex()];                    \\\n}\n////////////////////////////////////////////////////\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}