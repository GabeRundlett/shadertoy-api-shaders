{
    "Shader": {
        "info": {
            "date": "1649633740",
            "description": "aperiodic hexrosa tiling as shown by markus rissanen\nhttps://archive.bridgesmathart.org/2016/bridges2016-209.pdf\nmodified from a p5js sketch I made some years back",
            "flags": 0,
            "hasliked": 0,
            "id": "ftjyR1",
            "likes": 4,
            "name": "hexrosa",
            "published": 3,
            "tags": [
                "tiling",
                "aperiodic",
                "hexrosa"
            ],
            "usePreview": 0,
            "username": "ufffd",
            "viewed": 111
        },
        "renderpass": [
            {
                "code": "// naive implementation of the 'hexrosa' aperiodic tiling\n// see shane's radial tiling truchet for a better implementation:\n//   https://www.shadertoy.com/view/NlcBRs\n\n#define PI 3.141592653589793\nconst int nfold = 7;\nconst float hexH = 1.;\nconst int hexL = 7;\nvec2 center = vec2(0.);\nfloat initR = 0.;\nconst float angle1 = 1. / float(nfold) * PI * 2.;\nconst float angle2 = PI * 0.5 - angle1 / 2.;\nconst float sidelength = hexH / (2. * cos(0.5 * angle1) + 1.);\nconst float hexW = 2. * sidelength * sin(0.5 * angle1);\nconst float offX = hexW / 2.;\nconst float offY = sidelength + ((hexH - sidelength) / 2.);\n\n\nfloat hexSDF(in vec2 position) {\n    position /= vec2(sqrt(3.0), 1.5); // magic numbers\n    position.y -= 0.5;\n    position.x -= fract(floor(position.y) * 0.5);\n    position = abs(fract(position) - 0.5);\n    return abs(1. - max(position.x * tan(angle2) * 1.15 + position.y, position.x / hexW * 1.15)) * sqrt(3.) * 0.5; // magic numbers\n}\n\nfloat drawHex(in vec2 position, in float size) {\n    // position *= vec2(hexH,hexW)/hexH;\n    float sdf = hexSDF(position);\n    if (position.x < -0.5) sdf = 0.;\n    if (position.x > 0.5) sdf = 0.;\n    if (position.y < -0.5) sdf = 0.;\n    if (position.y > 0.5) sdf = 0.;\n    return smoothstep(size-0.002,size+0.002,sdf);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.*fragCoord - iResolution.xy ) / iResolution.y;\n    \n    vec3 color = vec3(0.);\n    float dt = iTime * 0.5;\n    \n    #define LOOP_METHOD 0\n    #define GRID_METHOD 1\n    #define USE_METHOD LOOP_METHOD\n    #if USE_METHOD == LOOP_METHOD    \n    //the hex rosa is made of 2 sets of nfold# of what I call 'branches'. a branch is a single triangular array of 'seeds' drawn as 'hexes' (base hexagons shapes)\n    //this loop doubles the process for each set of branches\n    for(int outset=0;outset<2;outset++){    \n        vec2 ouv = uv;\n        ouv *= Rot(float(outset) * PI / float(nfold));\n        //this loop divides the circle by nfold# and draws that many branches, evenly spaced\n        for (int branch=0;branch<nfold;branch++){\n            vec2 buv = ouv;\n            buv *= Rot(angle1 * float(branch));\n            buv.y -= .08 / float(nfold); // magic numbers\n            buv.y += sidelength * float(outset) * 0.41; // magic numbers\n            //this loop sets and positions the row being drawn in the current branch\n            for (int row=0;row<hexL;row++) { // the hexagonal loop could probably be optimized\n                //this loop sets and positions the individual seed being drawn in the current row\n                for (int col = row * -1; col <= row; col += 2) {\n                    vec2 huv = buv;\n                    float camera_shutter = 0.;\n                    huv += camera_shutter; // shutter\n                    vec2 hexcenter = vec2(float(col)*offX,float(row)*offY) * 0.41;\n                    huv += hexcenter; // magic numbers\n                    huv.y += offY/PI;\n                    float mainhex = drawHex(huv, 0.749); // magic numbers\n                    color += mainhex * 0.8;\n                    vec3 hexcol = 0.1*vec3(outset*4,branch*1,row+col)*drawHex(huv, 0.76); // magic numbers\n                    color -= hexcol;\n                }            \n            }            \n        }\n    }\n    #elif USE_METHOD == GRID_METHOD\n    \n    #endif\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nmat2 Rot(in float a) {\n    return mat2(cos(a),-sin(a),\n                sin(a),cos(a));\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\n\n\n\n// from shane's radial tiling truchet:\n// Unsigned distance to the segment joining \"a\" and \"b\".\nfloat distLine(vec2 p, vec2 a, vec2 b){\n\n    p -= a; b -= a;\n    float h = clamp(dot(p, b)/dot(b, b), 0., 1.);\n    return length(p - b*h);\n}\n\n// Signed distance to a line passing through \"a\" and \"b\".\nfloat distLineS(vec2 p, vec2 a, vec2 b){\n\n   b -= a; \n   return dot(p - a, vec2(-b.y, b.x)/length(b));\n}\nconst vec2 s = vec2(2. + 1.7320508, 1);\n// Hexagonal bound: Not technically a distance function, but it's\n// good enough for this example.\nfloat getHex(vec2 p){\n \n    // Generalized elongated hexagon function, based on the \n    // partitioning rectangle above.\n    //\n    // I did this in a hurry. There'd be better ways to go \n    // about it, but it'll do for now.\n    float x = (s.x - s.y)/2.;//(1. + 1.7320508)/2.;\n    float ln;\n    p = abs(p);\n    ln =  distLineS(p, vec2(-.5, .5), vec2(.5, .5));\n    ln =  max(ln, distLineS(p, vec2(.5, .5), vec2(x, 0)));\n    ln =  max(ln, distLineS(p, vec2(x, 0), vec2(.5, -.5)));\n    return ln;\n    \n    /*    \n    float x = (1. + 1.7320508)/2.;\n    float ln =  distLineS(p, vec2(-.5, -.5), vec2(-x, 0));\n    ln =  max(ln, distLineS(p, vec2(-x, 0), vec2(-.5, .5)));\n    ln =  max(ln, distLineS(p, vec2(-.5, .5), vec2(.5, .5)));\n    ln =  max(ln, distLineS(p, vec2(.5, .5), vec2(x, 0)));\n    ln =  max(ln,distLineS(p, vec2(x, 0), vec2(.5, -.5)));\n    ln =  max(ln, distLineS(p, vec2(.5, -.5), vec2(-.5, -.5)));\n    return ln;\n*/\n}\n\n// Hexagonal grid coordinates. This returns the local coordinates and the cell's center.\n// The process is explained in more detail here:\n//\n// Minimal Hexagon Grid - Shane\n// https://www.shadertoy.com/view/Xljczw\n//\nvec4 getGrid(vec2 p){\n  \n    \n    vec4 ip = floor(vec4(p/s, p/s - .5)) + .5;\n    vec4 q = p.xyxy - vec4(ip.xy, ip.zw + .5)*s.xyxy;\n    //return dot(q.xy, q.xy)<dot(q.zw, q.zw)? vec4(q.xy, ip.xy) : vec4(q.zw, ip.zw + offs);\n    return getHex(q.xy)<getHex(q.zw)? vec4(q.xy, ip.xy) : vec4(q.zw, ip.zw + .5);\n   \n} ",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}