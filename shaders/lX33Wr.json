{
    "Shader": {
        "info": {
            "date": "1716325227",
            "description": "A representation of the HSV/HSB cone in sRGB space.\nStill not sure about the gamma...",
            "flags": 0,
            "hasliked": 0,
            "id": "lX33Wr",
            "likes": 5,
            "name": "HSV Cone",
            "published": 3,
            "tags": [
                "color",
                "cone",
                "hsv",
                "srgb",
                "hsb"
            ],
            "usePreview": 0,
            "username": "jsulpis",
            "viewed": 125
        },
        "renderpass": [
            {
                "code": "#define CAMERA_POSITION vec3(0., 2.4, 3.)\n#define CAMERA_ORIENTATION vec3(0., -0.5, -1.)\n#define CONE_HEIGHT 1.7\n#define CONE_RADIUS 1.\n\n#define LIGHT_1 vec3(3., 2., -5.)\n#define LIGHT_2 vec3(-3., 2., -5.)\n\n#define PI acos(-1.)\n\n// Ray casting\n#define INFINITY 1e10\n\n// anti-aliasing\n#define AA 4\n\n//===============================================//\n//  Generic utilities stolen from smarter people //\n//===============================================//\n\nfloat dot2(vec3 v) {\n  return dot(v, v);\n}\n\n// https://iquilezles.org/articles/intersectors/\n// axis aligned box centered at the origin, with size boxSize\nvec2 boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize) {\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.); // no intersection\n\n    return vec2(tN, tF);\n}\n\n// https://iquilezles.org/articles/intersectors/\n// cone defined by extremes pa and pb, and radious ra and rb\nvec4 coneIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float ra, in float rb ) {\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n    vec3  ob = ro - pb;\n\n    float m0 = dot(ba,ba);\n    float m1 = dot(oa,ba);\n    float m2 = dot(ob,ba);\n    float m3 = dot(rd,ba);\n\n    //caps\n         if( m1<0.0 ) { if( dot2(oa*m3-rd*m1)<(ra*ra*m3*m3) ) return vec4(-m1/m3,-ba*inversesqrt(m0)); }\n    else if( m2>0.0 ) { if( dot2(ob*m3-rd*m2)<(rb*rb*m3*m3) ) return vec4(-m2/m3, ba*inversesqrt(m0)); }\n\n    // body\n    float m4 = dot(rd,oa);\n    float m5 = dot(oa,oa);\n    float rr = ra - rb;\n    float hy = m0 + rr*rr;\n\n    float k2 = m0*m0    - m3*m3*hy;\n    float k1 = m0*m0*m4 - m1*m3*hy + m0*ra*(rr*m3*1.0        );\n    float k0 = m0*m0*m5 - m1*m1*hy + m0*ra*(rr*m1*2.0 - m0*ra);\n\n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return vec4(INFINITY);\n\n    float t = (-k1-sqrt(h))/k2;\n\n    float y = m1 + t*m3;\n    if( y>0.0 && y<m0 ) {\n        return vec4(t, normalize(m0*(m0*(oa+t*rd)+rr*ba*ra)-ba*hy*y));\n    }\n    return vec4(INFINITY);\n}\n\n// https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nmat3 rotateY(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(//\n    vec3(c, 0, s),//\n    vec3(0, 1, 0),//\n    vec3(-s, 0, c)//\n  );\n}\n\n//================//\n//  Project code  //\n//================//\n\nfloat shapeDist(in vec3 ro, in vec3 rd) {\n\tfloat coneDist = coneIntersect(ro, rd, vec3(0., 0., 0.), vec3(0., CONE_HEIGHT, 0.), 0., CONE_RADIUS).x;\n\n\tfloat opening = 4.;\n\tvec2 cubeDist = boxIntersection(\n\t\trotateY(PI/4.) * (ro* vec3(opening, 1., 1.) - vec3(0., 0., .35)),\n\t\trotateY(PI/4.) * (rd* vec3(opening, 1., 1.) - vec3(0., 0., .35)),\n\t\tvec3(CONE_RADIUS, CONE_HEIGHT, CONE_RADIUS)\n\t);\n\n\treturn max(cubeDist.y, coneDist);\n}\n\nvec3 calculateNormal(vec3 rayOrigin, vec3 rayDirection) {\n\tfloat epsilon = 0.001;\n\tfloat dist = shapeDist(rayOrigin, rayDirection);\n\n\tfloat dx = shapeDist(rayOrigin + vec3(epsilon, 0.0, 0.0), rayDirection) - dist;\n\tfloat dy = shapeDist(rayOrigin + vec3(0.0, epsilon, 0.0), rayDirection) - dist;\n\tfloat dz = shapeDist(rayOrigin + vec3(0.0, 0.0, epsilon), rayDirection) - dist;\n\n\treturn normalize(vec3(dx, dy, dz));\n}\n\nvec4 trace(in vec3 ro, in vec3 rd) {\n  float distance = shapeDist(ro, rd);\n\n  if (distance == INFINITY) {\n    return vec4(0.);\n  }\n\n  vec3 p = ro + rd * distance;\n\n  p = rotateY(iTime) * p;\n  vec3 normal = calculateNormal(ro, rd);\n\n  float lighting = min(dot(normalize(LIGHT_1), normal) + 1.5, 1.)\n\t\t\t\t * min(dot(normalize(LIGHT_2), normal) + 1.5, 1.);\n\n  float h = (atan(p.x, p.z) + PI) / (2. * PI);\n  float s = length(vec2(p.x, p.z));\n  float v = (p.y / CONE_HEIGHT) * lighting;\n\n  vec3 color = hsv2rgb(vec3(h, s, v));\n  return vec4(color, 1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 ro = CAMERA_POSITION;\n    vec2 uv = (fragCoord / iResolution.xy - 0.5) * iResolution.xy / iResolution.y;\n    vec4 color = vec4(0.0);\n\n    #if AA>1\n        for( int m=0; m<AA; m++ )\n        for( int n=0; n<AA; n++ ) {\n                uv += (vec2(float(m),float(n)) / float(AA) - 0.5) / iResolution.xy;\n\n                vec3 rd = normalize(vec3(uv, 0.) + CAMERA_ORIENTATION);\n\n                color += trace(ro, rd);\n        }\n        color /= float(AA*AA);\n    #else\n        vec3 rd = normalize(vec3(uv, 0.) + CAMERA_ORIENTATION);\n        color += trace(ro, rd);\n    #endif\n    \n    // Not sure if I should apply this gamma correction, it looks wrong to me\n    //color.rgb = pow(color.rgb, vec3(1.0 / 2.2));\n\n    fragColor = color;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}