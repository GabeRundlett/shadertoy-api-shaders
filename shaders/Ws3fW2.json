{
    "Shader": {
        "info": {
            "date": "1605972909",
            "description": "Previous version https://www.shadertoy.com/view/WstBWB",
            "flags": 32,
            "hasliked": 0,
            "id": "Ws3fW2",
            "likes": 3,
            "name": "Life experiments 3: replication",
            "published": 3,
            "tags": [
                "life"
            ],
            "usePreview": 0,
            "username": "illus0r",
            "viewed": 302
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 FC )\n{\n    vec2 uv=FC/iResolution.xy;\n\tvec4 col = texture(iChannel0,uv);\n    fragColor = col;\n    //fragColor = vec4((noise(uv*9.)*2.-1.),(noise(p*9.+99.)*2.-1.),0.,1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define R 5.\n#define max_speed 1.\n\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\n// Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\nfloat snoise(vec2 v) {\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        0.366025403784439,\n                        -0.577350269189626,\n                        0.024390243902439);\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\nfloat rand(vec2 n) {\n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\nfloat noise(vec2 n) {\n  //https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n\tconst vec2 d = vec2(0.0, 1.0);\n  vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "float rnd(float x) {return fract(54321.987 * sin(987.12345 * x))*2.-1.;}\n\nvoid mainImage( out vec4 fragColor, in vec2 FC )\n{\n    vec2 uv = FC/iResolution.xy;\n    vec3 px = vec3(1./iResolution.xy,.0);\n    vec2 p,v,f=vec2(0.);\n    \n    // spawning cells\n    if(mod(float(iFrame),1000000.)<=1.){\n        fragColor=vec4(0.);// `p` of 0. means empty cell\n        //if(mod(FC.x+.5,16.)==0. && mod(FC.y+.5,16.)==0.){\n        //if(rnd(uv.x*4.1+uv.y*9.01+iTime*.001)*.5+.5<.1){\n        if(abs(length((uv-.5)/iResolution.x*iResolution.xy)-.0000001)<.001){\n            //fragColor=vec4(.5,.5,.5+.0*rnd(uv.x),.5+.0*rnd(uv.y));//.5 to place to the center\n            fragColor=vec4(.5,.5,.5,.5);\n        \treturn;\n        }\n    }\n    \n    if(rnd(uv.x+uv.y+iTime+1.)>.95) return;\n\n    // find guest\n    vec2 guest_ij;\n    bool is_guest_found = false;\n    for(float i=-R;i<=R;i++){\n        for(float j=-R;j<=R;j++){\n            vec2 ij=vec2(i,j);\n            vec2 uv_n = uv+ij*px.xy; // uv of neighbour\n            if(uv_n!=fract(uv_n))continue; // on edge\n            vec4 neighbour=texture(iChannel0,uv_n);\n            if(length(neighbour)==0.)continue; // empty\n\n            p = neighbour.rg-ij; // `ij` because `p` is relative to current pixel\n            v = neighbour.ba*2.-1.;\n            if(p.x+v.x<1. && p.y+v.y<1. && p.x+v.x>=0. && p.y+v.y>=0.){\n            \tis_guest_found = true;\n                guest_ij=vec2(i,j);\n                // set fragColor to represent guest\n                fragColor=vec4(p,v*.5+.5);\n                break;\n            }\n        }\n    }\n    \n    // no guests\n    if(!is_guest_found){\n        vec2 ij=vec2(1.,1.);\n        vec2 uv_n = uv+ij*px.xy; // uv of neighbour\n        vec4 neighbour=texture(iChannel0,uv_n);\n        if(length(neighbour)>0.&&rnd(uv.x+uv.y+iTime)>.85){\n            fragColor = vec4(.5);\n            return;\n        }\n        \n        fragColor = vec4(0.);\n        return;\n    }\n\n    \n    \n    // добавить тех, кто прилетит в пиксель\n    for(float i=guest_ij.x-R;i<=guest_ij.x+R;i++){\n        for(float j=guest_ij.y-R;j<=guest_ij.y+R;j++){\n            vec2 ij=vec2(i,j);\n            vec2 uv_n = uv+ij*px.xy; // uv of neighbour\n            if(uv_n!=fract(uv_n))continue; // on edge\n            vec4 neighbour=texture(iChannel0,uv_n);\n            if(length(neighbour)==0.)continue; // empty\n\n            p = neighbour.rg-ij; // `ij` because `p` is relative to current pixel\n            //v = neighbour.ba*2.-1.;\n            \n            if(abs(i)*abs(j)>0.01) { // if not current cell\n                float dist = distance(fragColor.rg,p);\n                float target_dist = 4.;\n            \tf+=normalize(fragColor.rg-p)/dist*dist;\n            \tf+=normalize(fragColor.rg-p)*(target_dist-dist)*.5;\n            }\n            \n            \n            //if(p.x<1. && p.y<1. && p.x>=0. && p.y>=0.){\n            //    fragColor.rg = p;\n            //    fragColor.ba = v*.5+.5;\n            //    //break;\n            //}\n        }\n    }\n    \n    // косяк в том что я меняю скорость прилетевшей частицы\n    // а силу расчитываю для той, что была в текущем пикселе.\n    // Даже если её там не было.\n    \n    //Правильно так:\n    //Найти любого прилетуна. Если нет такого, стать нулём.\n    //    \n    //Вокруг прилетуна в t1 взять соседей в t1 и посмотреть, \n    //как они сейчас воздействуют на прилетуна.\n    //И юзать эту силу.\n    \n    // Тут прокол: мы сперва нашли прилетуна, а потом посчитали силы\n    // а ведь эти силы могут ему помешать стать прилетуном.\n    // Выход: применять скорость к прилетуну, а потом менять скорость.\n    // тогда он прилетит гарантированно.\n    \n    //    \n    //Или так ещё можно:\n    //Смотреть, куда сместятся текущие соседи с учётом их скоростей.\n    //И силу их силу воздействия на прилетуна в t2.\n    //    \n    //Но во втором варианте у нас могут прилететь новые клетки, \n    //мы не знаем, кто попадёт в клетки соседей в t2\n    //    \n    //Можно попробовать средний вариант без гарантии успеха. Но он простой)\n    //Прилетуна считаем в t2, а соседей в t1. Главное, чтобы прилетун в t1 не\n    //повлиял на прилетуна в t2. Должен ли влиять на него хозяин в t1?\n        \n    // move by old speed\n    \n    \n        \n    if(length(fragColor)>0.){\n        p = fragColor.rg;\n        v = fragColor.ba*2.-1.;\n        p=fract(p+v);\n        v*=.99;\n        v.x+=.2*(snoise(uv*4.));\n        v.y+=.2*(snoise(uv*4.+99.+iTime/2.));\n        v += f/20.;\n        if(length(v)>max_speed) v = max_speed*normalize(v);\n        if(FC.x+v.x<=max_speed*10.) v.x=-abs(v.x);\n        if(FC.x+v.x>=iResolution.x-max_speed*10.) v.x=abs(v.x);\n        if(FC.y+v.y<=max_speed*10.) v.y=-abs(v.y);\n        if(FC.y+v.y>=iResolution.y-max_speed*10.) v.y=abs(v.y);\n        if(length(v)>max_speed) v = max_speed*normalize(v);\n        fragColor.rg = p;\n        fragColor.ba = v*.5+.5;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 FC )\n{\n    vec2 uv=FC/iResolution.xy;\n    vec3 px=vec3(1./iResolution.xy,0);\n    vec4 col = vec4(1.);\n    \n    for(float i=0.;i<1.;i++){\n        for(float j=0.;j<1.;j++){\n            vec2 ij = vec2(i,j);\n            vec4 tex = texture(iChannel0,(floor((FC)/1.)+ij)/iResolution.xy);\n            if(length(tex)>0.)\n\t\t    col -= 2.*tex.a * (1.-vec4(.3, .7, .1, 1.));\n\t\t    //col = max(col,texture(iChannel0,(FC+ij)/iResolution.xy));\n        }\n    }\n    //if(length(col)>0.) fragColor = vec4(1.);\n    fragColor = col;\n    fragColor = min(fragColor,texture(iChannel1,uv));\n    fragColor = mix(fragColor,vec4(1.),.01);\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}