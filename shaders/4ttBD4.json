{
    "Shader": {
        "info": {
            "date": "1539668907",
            "description": "pause time for a rasterization you want, and drag mouse.\n\nexperimenting with utility of \nhttps://www.shadertoy.com/view/Xl3BD4",
            "flags": 0,
            "hasliked": 0,
            "id": "4ttBD4",
            "likes": 7,
            "name": "tartan euclideanRythm chord",
            "published": 3,
            "tags": [
                "dither",
                "weave",
                "quantize",
                "tartan",
                "hairline",
                "starguitar",
                "irrationalstride",
                "euclideanbeats",
                "chromaticscale",
                "cord",
                "euclideanrhythm"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 1144
        },
        "renderpass": [
            {
                "code": "//\"audiovisual\" tag means it uses moudular arithmetic (fourier analysis, roots of unity)\n//, or at least some sort of audio-visualization, if only a blinking lights show\n//,to use the same functions to render audio and video\n//all code is in commons tab\n\n\n//except for the dump-do-merge-and-sort below:\n\n\n//dither, pixelation, tiling, quantum, fold, fibonacci, weave, pmod, tartan, hairline, dotted, notekey, starguitar, chord,arpeggio\n//discarded tags: bokeh (it used to be a bit bokeh-ish and theres some bokeh-context utility)\n//- that is, pixerlation is reciprocal of bokeh.\n//- that is, calculating bokeh within a bayer-matrix context\n//- , not for all pixel, but for a regular interval of pixels, for better performance.\n\n//child : https://www.shadertoy.com/view/tdXfDB\n//three voice harmony minor major chord (old)\n//parent: https://www.shadertoy.com/view/lsffDM \n//parent: https://www.shadertoy.com/view/XtdfDH\n/*\nmaking 2 dots at start and end of a line, set by mouse.\nmaking 3rd dot at half way point.\nfloor the points with flc() to get minor or major chords.\n*/\n/*\nI thought of a rather simple way to represent longer chords/arpeggios,\nascending and descending melodies.\n...\nBlack piano keys ARE Moire ARE aliasing:\nhttps://en.wikipedia.org/wiki/Aliasing\nhttps://en.wikipedia.org/wiki/Moir%C3%A9_pattern\n*/\n/*\na problem suboptimal case i keep running into is\na sequence of notes on a sheet \n...that are pretty much an ascending or descending line.\nof 4 to 8 notes.\ni want a very general case to check \nif(at time [t] note [n] exists in pith [y]) \nfor a linear equation of notes.\nto be checked AFTER applying a floor() tesselation.\nvia pModInterval1() of \nhttp://mercury.sexy/hg_sdf/\nthe same can also floor(pModInterval1()) \nto tell which of every 12 piano keys are black.\n\ndone, also useful for\nhttps://en.wikipedia.org/wiki/Brickwork#Load-bearing_bonds\nand\nhttps://www.shadertoy.com/results?query=tartan\n*/\n#define u5(a) ((a)*.5+.5)\n#define vec1 float\n//circle radius\n#define radius 1.\n//blur of all the lines\n#define hl2 min(iResolution.x,iResolution.y)\n//#define hl2 290.*8.\n//https://www.shadertoy.com/view/4ttBD4 is pixel perfecrt, iff(viewZoom==hl2/floor(i))\n//zooming is just for a debug focus.\n#define viewZoom (hl2/floor(mix(1.,hl2*.1,u5(-cos(iTime)))    ))\n//hl2*mix(9.,99.,(-sin(cos(iTime))))))\n//(mix(1./hl2,hl2,(-sin(cos(iTime)))))\n//#define viewZoom (hl2)\n//#define hl (viewZoom/hl2)\n#define hl (viewZoom/hl2)\n#define fra(u) (u-.5*iResolution.xy)*viewZoom/iResolution.y\n//float ss(vec1 a,vec2 b){return smoothstep(b.x,b.y,a);}\nvec2  ss(vec2 a,vec2 b){return smoothstep(b.x,b.y,a);}\nfloat ss(vec1 a){return ss(a,vec2(1,-1)*hl);}\nvec2  ss(vec2 a){return ss(a,vec2(1,-1)*hl);}\n////ss2t(a) changes a seesaw waves output (range [0..1]) to a triangle wave.\n#define ss2t(a) a=abs(a*2.-1.)\n//floor offset,centred \n#define flc(a) floor(a+.5)\n//return square tesselaion grod for [u]fragmentPos\nfloat grid(vec2 u){u=fract(u);u=ss2t(u);float r=1.-min(u.x,u.y);\n return smoothstep(hl,-hl,abs(r-1.)-hl);}\n//domain-general pmod():\n#define pMOD(d,e) d e(inout d a,d b){d c=floor((a/b)+.5);a=(fract((a/b)+.5)-.5)*b;return c;}\npMOD(vec1,pmod)pMOD(vec2,pmod)pMOD(vec3,pmod)pMOD(vec4,pmod)\n    //repetitive only for less repetitive legacy namespace support.\n//because this shader scales and rounds (translates) one invertal into another (quantized) inverval:\n//it takes an excursion into; Maxwellian dimensional relativism:\n#define dd(a) dot(a,a)\n    //below text errand is about quantization of differential calculus:\n    //we need to understand the concept/implementation of [planckT] planck constants.\n    //sorry its copied from another shader about atmospheric scattering blackbody temperature.\n//step 0, the dotproduct of a vector and itself ==dd(a)==is a length*length of the vector.\n//it doesnt matter much what unit you measure distance|length in, what matters is that:\n//step 1, realize that length(a-b)=length(b-a)=sqrt(dd(a-b))=sqrt(dd(b-a))=distance(a,b)=distance(b,a)\n//step 2, the sqrt((a-b)) implies differential calculus:\n//sorting equations like this evades a bias to [systems of length] ie, metric systrems.\n//how often you divide a length by /second\n//, defines what [time-integral of displacement];[length over time] you are calculating in\n//Drop        =length/second/second/second/second/second/second/second/second\n//Lock        =length/second/second/second/second/second/second/second\n//Pop         =length/second/second/second/second/second/second\n//Crackle     =length/second/second/second/second/second\n//jounce      =length/second/second/second/second\n//jerk        =length/second/second/second\n//acceleration=length/second/second\n//velocity    =length/second\n//Displacement=length                        https://en.wikipedia.org/wiki/Displacement_(vector)\n//Absement    =length*second                 https://en.wikipedia.org/wiki/Absement\n//Absity      =length*second*second    \n//Abseleration=length*second*second*second    \n//Abserk      =length*second*second*second*second    \n//Absounce    =length*second*second*second*second*second     \n//the fun part of this shader is that it easily extends into 4d\n//, so you can scale (and quantize) a displacement, velocity, an accelleration, and a jerk in one vec4()\n//, useful for [automatic differentiation] shaders?\n//length*kilogram is newtonian:\n//newton = kilogram*       length/second/second                  =       kilogram*acceleration\n//joule  = kilogram*length*length/second/second == length*newton =length*kilogram*acceleration\n//... for more see bufferrB of https://www.shadertoy.com/view/3l2GDR\n#define coVelEm 2.99792458e8\n#define lightspeed coVelEm\n//commonly known as \"speed of light\" or \"c\"; in in length/second==velocity\n//a better term would be [Electromagnetic velocity]\n//this is a maximum velocity in a vacuum. Usually a straight direct path is obstructed by mass\n//, cuvring spacetime, deforming a straight and shootrest path into a longer line.\n//Without a maximum velocity, causality over time is nonlinear/discontinuous.\n#define coPlanck 6.62607004e-34\n//smallest EM-observable quantity, smallest physically EM-percievable interval \n//;in joule*second==newton*length*second==length*length*kilogram/second/second == length*kilogram*acceleration\n//==length*kilogram*acceleration\n#define coPlanckR (coPlanck/pi/2.)\n//==1.0545718e-34\n//\"reduced PlanckConstant\" is a common scalar, where EM interferrences are about [fourier butterflies]\n//this involves the issue of [squaring an (epi)circle], within limited resolution of DFT|FFT\n#define coGravity 6.674e-11\n//gravitational constant; in newton/kilogram/kilogram/length/length\n//spacetime curvature over inverse_squared_distance to mass\n//gravity is not a force, but an effect of curving spacetime, poportional to squared mass and inverse squared distance.\n//you can model gravity as if it is a force, but that model will not be relativistic.\n#define coPlanckT sqrt(coPlanckR*coGravity/coVelEm/coVelEm/coVelEm/coVelEm/coVelEm)\n//PlanckTime; smallest EM-ovservavle interval over time\n//;5.3911252e-44 == sqrt(1.0545718e-34*6.674e-11/2.99792458e8/2.99792458e8/2.99792458e8/2.99792458e8/2.99792458e8)\n//minimum time that information takes to traverse length(coPlanck) in coMaVelEm\n//whilst smaller units of time can exist, they are so small their effect on our existence is negligible\n#define planckT .0001    \n//smallest measurable distance to an asymptote\n//smallest measurable angle between 1 non-parallel lines\n//smallest feasible epsilon, regardles of contextual scaling, to evade divisions by 0.\n//an ideall model defines planck==coPlanckT or planck=coPlanck, depending on context of your model\n//, but 32bit float precision is not good enough for this.\n//so we chose to scale our model resolution down significantly, with less addressSpace/precision\n// PlanckLengt/PlanckTime =coMaxSpeed  \n//[u]FragmentPos, [m]=start [n]=end\n    \n//float segment(){ ;r.z=Segment(u,m,n) ;}\n\n//pmod IrrationalStride\n//pmod fraction with epsilon\n#define pmodfe(a,b,e) (fract(((a)/(b))+.5)-.5-(e))*(b)\n//...within floor quantizing\n#define pmodfq(u,n,f,e) floor(pmodfe(floor((u)+.5),(n)/(max(f,1.+(e))-1.),e)+.5)\n//...offset by m\n#define pmodfM(u,n,m,f,e) pmodfq(((u)-(m)),((n)-(m)),f,e)\n//...m is quantized (this is \"tartan basis\", and you check if returned all() any() values are <e.\n#define pmodfm(u,n,m,f,e) pmodfM(u,n,floor((m)+.5),f,e) \n/*\npmodfm() is made as define to be typeIntependent \npmodfm works with vec2,vec3,vec4\n\nunraveling pmodfm() for type Float gets you: (untested, may have typos)\n\nfloat pmodfmFloat(float u,float n,float m,float f,float e){\n m=floor((m)+.5);        //pmodfm() step <-> offset to center of a tile\n u=u-m;n=n-m;            //pmodfM() step <-> offset by M\n float a=floor((u)+.5);              //pmodfq() [a] parameter\n float b=(n)/(max(f,1.+(e))-1.);     //pmodfq() [b] parameter\n a=(fract(((a)/(b))+.5)-.5-(e))*(b); ///pmodfe(a,b,e); (woth 0.5 offset)\n return floor(a+.5);                 //undo offset to center of a tile\n ;}\n\n//the pmodfM() [offset By M] step is the reason, that the inputs are so unintuitive.\n//see commonTab for an alternative, for more intuitive Hairline-inputs.\n*/\n\n//these pmod**2() aliases are just a copy of pmod**() to experiment with\n//, without changing the original pmodfM() and any subroutines.\n//pmod fraction with epsilon\n#define pmodfe2(a,b,e) (fract(((a)/(b))+.5)-.5-(e))*(b)\n//...within floor quantizing\n#define pmodfq2(u,n,f,e) floor(pmodfe2(floor((u)+.5),(n)/(max(f,1.+(e))-1.),e)+.5)\n//...offset by m\n#define pmodfM2(u,n,m,f,e) pmodfq2(((u)-(m)),((n)-(m)),f,e)\n//...m is quantized (this is \"tartan basis\", and you check if returned all() any() values are <e.\n#define pmodfm2(u,n,m,f,e) pmodfM2(u,n,floor((m)+.5),f,e) \n    \n//return distance of [u] to line srgment from [a] to [b]\nfloat segment(vec2 p,vec2 a,vec2 b){p-=a;b-=a;\n a.x=clamp(dot(p,b)/dot(b,b),0.,1.);return length(p-b*a.x);}\nfloat segment(vec1 p,vec1 a,vec1 b){p-=a;b-=a;\n a=clamp(dot(p,b)/dot(b,b),0.,1.);return length(p-b*a);}\n\n\n//this dotlist is not quite right, but the illusion is good enough\n//pretty sure there is a rotating projection that doesnt involve trig.\nfloat dotList(vec2 u,vec2 m,vec2 n//todo, no longer used function. i want to generalize with pmod\n){float s=segment(u,m,n)\n ;vec2 a=abs(m-n)\n ;//if(a.x-a.y<1.)\n ;a=pmodfm2(u,m,n,4.,planckT)\n ;s=sat(4.-s)\n ;return sat(8.-length(a))\n ;return min(sat(8.-length(a)),s)\n ;}\n\n\nvec2 roth(vec2 u,float b){\n ;u=c2p(u)\n ;u.y+=b\n ;u=p2c(u)\n ;return u;}\n \n//input [i] sets number of dots in line segment! (does not loop over i)\n//hacky overly general solution, still need to chose what to specialize this on.\n//set radius to 1 or whatever your zoom factors are.\n//or just floor the dot at the circle centers (without a hole)\nfloat dotListp(vec2 u,vec2 m,vec2 n,float i//todo, no longer used function. i want to generalize with pmod\n){vec2 a=(n-m)\n ;//min of 2 shapes, vars descripte dottedlineparams; linesegment thichmess=torRadius!\n ;float radi=8. //(length(m-n)+1.)\n ;float thickness=radi-6.//-6 is size of a hole insote the dot. must be <radi\n ;float r=-atan(a.y,a.x)     \n ;float s=segment(u,m,n)\n ;s=sat(radi-s)\n ;u=roth(u,r)\n ;m=roth(m,r)\n ;n=roth(n,r)\n ;a=pmodfm2(u,m,n,i,planckT)//[i] sets number of dots in line segment!\n ;//a.x=pmodfm2(length(u-n),length(m-n),length(n-n),4.,planckT)//niced try, very false\n ;a.x=abs(length(abs(vec2(a.x,-u.y+m.y)))-radi+thickness)\n ;a.x=(sat(thickness-a.x))\n ;//return s\n ;//return a.x\n ;return (a.x+s)*.2\n ;return min(a.x,s)\n ;}\n\n//remember this identity for tartan domain folds:\n//;if(min(v.x,v.y)<0.)\n//==\n//;//if(v.x<0.||v.y<0.)\n//==\n//;//if(any(lessThan(v,vec2(0))))\n//above is for lines, below is for dots\n//;if(max(v.x,v.y)<0.)\n\nvec3 TartanPeriodVariating(vec2 u,vec2 m,vec2 n\n){vec3 c=vec3(0)\n ;vec2 v3=pmodfm(u,n,m, 5.,planckT)//rasterized fold\n ;vec2 v5=pmodfm(u,n,m, 7.,planckT)//rasterized fold\n ;vec2 v7=pmodfm(u,n,m,13.,planckT)//rasterized fold\n ;if(any(lessThan(abs(v3),vec2(planckT))))c.xy+=1.//rasterized octave lines\n ;if(all(lessThan(abs(v3),vec2(planckT))))c.xy+=.5//rasterized octave dots \n ;if(any(lessThan(abs(v7),vec2(planckT))))c.zx+=1.//rasterized octave lines \n ;if(all(lessThan(abs(v5),vec2(planckT))))c.yz+=.5//rasterized octave dots \n ;if(any(lessThan(abs(v7),vec2(planckT))))c.zx+=1.//rasterized octave lines  \n ;if(all(lessThan(abs(v5),vec2(planckT))))c.yz+=.5//rasterized octave dots \n ;return c/4.5;}\n\n\nvec3 TartanPeriodConstant(vec2 u,vec2 m,vec2 n\n){vec3 c=vec3(0)\n ;vec2 v=pmodfm(u,n,m,3.,planckT)//rasterized fold\n ;if(all(lessThan(abs(v),vec2(planckT))))c.xy+=.4//rasterized tartan dots\n ;if(any(lessThan(abs(v),vec2(planckT))))c.xy+=.2//rasterized octave lines \n ;//if((v.x+ .5)-(v.y+.5)<planckT)c.z+=.2    //rasterized saw\n ;//if((v.x-.5)*(v.y-.5)<planckT)c.z+=.4     //rasterized checker\n ;//if(sqrt(v.x)*sqrt(v.y)<planckT)c.y+=.4   //rasterized L-shape\n ;//if((v.x)*sqrt(v.y)<planckT)c.xy+=.4       //rasterized horizontal line and quater box\n ;if(abs(v.x)-abs(v.y)<planckT)c.yz+=.4     //diagonal checkerlike\n ;//if(v.y-abs(v.x)<planckT)c.y+=.4          //diagonal abs()-seesaw but with some sign-symmetry-breaking\n ;//c.y=mix(1.,0.,length(u)-dd(v)-planckT*4.)//rasterized dots\n ;u.x=(cos(u.x*pi/4.))-floor(u.y)\n ;c.y=mix(0.25,.0,floor((u.x)-floor(length(v)-planckT)))  //rasterized cosine fourier estimates tri-wave OR halfCircle\n ;c+=grid(u)*.2;//greyscale grid    \n ;return c;}\n\n\nvec3 FibonacciFlooring(vec2 u,vec2 m,vec2 n\n){vec3 c=vec3(0)\n ;//vec4 raster=(sqrt(5.)+vec4(1,2,3,4))*.5  //phi-sequence-should make good noise/dither due to floor!\n ;//but actually, it ends up with a period of 2.\n ;vec4 raster=(sqrt(5.)+vec4(1,2,3,4))/.5 //reciprical phi-sequence just sqaps this, its the [cos to the sin]\n ;//raster=vec3(1)//any interval wiggles the same!\n ;vec2 a=pmodfm(u,n,m,raster.x,planckT)//rasterized fold\n ;vec2 b=pmodfm(u,n,m,raster.y,planckT)//rasterized fold\n ;vec2 d=pmodfm(u,n,m,raster.x,planckT)//rasterized fold\n ;vec2 e=pmodfm(u,n,m,raster.y,planckT)//rasterized fold\n ;if(any(lessThan(abs(a),vec2(planckT))))c.x+=1.\n ;if(any(lessThan(abs(b),vec2(planckT))))c.y+=1.\n ;if(any(lessThan(abs(d),vec2(planckT))))c.z+=1.\n ;if(any(lessThan(abs(e),vec2(planckT))))c.xy+=1.\n ;return c*.5;}\n\nvec3 CircleWithoutSqrt(vec2 u,vec2 m,vec2 n//rasterization to hide low precision of trig-estimates.\n){vec3 c=vec3(0)\n ;vec4 raster=vec4(2)\n ;m.x=m.y;n.x=n.y//debug cheap enforcing squares\n ;m=n-viewZoom/4.\n ;vec2 v=pmodfm(u,n,m,raster.x,planckT)//rasterized fold\n ;v=abs(v)-planckT\n ;c.x=v.x*v.y/(m.x-n.x)+(hl*.5)//squared rounded corners, with frointloaded sqrt\n ;//that is, -sqrt(viewZoom) depends on the screen resolution and can be a global const.\n ;return c;}//okay, the -.5 is twiddly, but there is a\n\nvec3 TartanLowerPlayground(vec2 u,vec2 m,vec2 n\n){vec3 c=vec3(0)\n ;//return CircleWithoutSqrt(u,m,n)\n ;//return FibonacciFlooring(u,m,n)\n ;vec4 raster=vec4(2)//silly static raster.\n ;raster=vec4(3,5,7,3)//m.xyxy-n.xyxy\n ;//m.x=m.y;n.x=n.y//debug cheap enforcing squares, this line was dumb\n ;//m=n-viewZoom/8.//debug cheap enforcing squares, this line was dumb\n ;vec2 a=pmodfm(u,n,m,raster.x,planckT)//rasterized fold\n ;vec2 b=pmodfm(u,n,m,raster.y,planckT)//rasterized fold\n ;vec2 d=pmodfm(u,n,m,raster.z,planckT)//rasterized fold\n ;vec2 v=pmodfm(u,n,m,raster.w,planckT)//rasterized fold\n ;a=abs(a)-planckT\n ;b=abs(b)-planckT\n ;d=abs(d)-planckT\n ;v=abs(v)-planckT\n \n ;//if(v.y/v.x<0.)c.x+=1. \n ;c.x=min(v.x/v.y,v.y/v.x)\n ;//c.y=step(a.x*a.y-13./hl2,0.)//same as below? no there seem minor differences\n ;//c.z=step(v.x*v.y,0.)//same as below? no there seem minor differences\n ;//if((v.x*v.y)<0.)c.x+=1.//same as min(v.x,v.y)-max(v.x,v.y)<0.\n ;//if((b.x-b.y)<0.)c.x+=1.//simpler diagonal squares\n ;//if(max(v.x,v.y)<0.)c.x+=1.\n ;//if(min(v.x,v.y)<0.)c.x+=1. //ALMOST same as below?; c.x=1.-v.x*v.y\n ;//if(v.x<0.||v.y<0.)c.x+=1.                                   //convoluted==min()\n ;//if(any(le/sThan(v,vec2(0))))c.x+=1.//rasterized octave dots //convoluted==min()\n ;return (c);}\n\nvec4 mainImage3(in vec2 U\n){vec3 c=vec3(0)\n ;vec2 u=fra(U)\n ;vec4 mouse=iMouseZwFix(iMouse,true)\n ;vec2 m=fra(mouse.zw);//start of holding mouse\n ;vec2 n=fra(mouse.xy);//current mouse pos held\n ;if(iMouse.z<=0.\n ){n=vec2(.0)\n  ;vec2 rr=viewZoom*vec2(.3,.1)//.x is average radius .y is distance from averate\n  ;n=cs(iTime*.61).yx*(rr.x-rr.y)\n  ;m=cs(iTime    )   *(rr.x+rr.y)\n  //;c.xy+=.2*ss(abs(abs(length(u)-rr.x)-rr.y)-viewZoom*.5/hl2)//yellow circles show path of red dots\n  ;}\n //3 splitscreen contexts test 2 of the above functions, as this is all very experimental.\n ;     if(u.y/viewZoom<-.2)c =TartanLowerPlayground(u,m,n)\n ;else if(u.y/viewZoom< .2)c+=TartanPeriodConstant (u,m,n)\n ;else                     c+=TartanPeriodVariating(u,m,n)\n   ;c+=dotListp(u,m,n,12.)\n ;return vec4(c,1.)\n ;}\n\n\nvoid mainImage(out vec4 o,vec2 u\n){//o=image(u,iMouse.xyzw,iResolution.xy,iTime)//fm synth shader vis\n ;o+=mainImage3(u)\n ;//o*=.5\n ;}\n//vec2 mainSound( in int samp,float t){return sound(t);}\n\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\nthis is a more complex(generalized experimental variant \nof [irrationalStride]\nhttps://www.shadertoy.com/results?query=irrationalStride&sort=newest&filter=\n\nfor an explanation of THIS shader read text below:\n(copied from: https://www.shadertoy.com/view/wdGBDW )\n\nI updated the [stride] shaders to [irrationalStride]\nand added a [stride] epxplanation for them in the commonTab of \nhttps://www.shadertoy.com/view/Xl3BD4\n\nA hairline is a rationalStride, much simpler.\nbut my code also dares to quantize for irrational ratios\n, within a limited PlanckLength.\n\nYou may think of a stride input values\nas the 2 sizes of strided lists. \nNumber of Red and blue cards;\nStrideIntuitive(uv,red,blue,offset)\n\nBut my function has 2 different inputs, \ntripplet( uv,start,end,(fraction) )\n(red==fraction == 3 == constant within the function\n, but could be parametric where\n, in case of a (non rational) remainder\n, RED is always shown, and blue is ommitted/overwritten.\n\nI then generalized this more into:\npmodfM(uv,start,end,fraction,planckPrecision)\nof \nhttps://www.shadertoy.com/view/4ttBD4\npmodfM(...)\nshould work with float, vec2, vec3 , vec4 inputs\n\nyou can use\npmodfM(uv,offset+Red,offset+red+blue,red,planckPrecision)\n\nand for a Jairline, that is\noffset=iTime%iResolution\npmodfM(uv.x,offset+1,offset+iResolution.x,1,0.001)\n\nand the precision is really not needed here\n, because all other inputs are whole numbers. (?)\n\n\n\ntags:\nstarguitar, irrationalstride, arpshepardtone, ditherhairlinequantize, chromaticscalecordtartanweave\n*/\n\n\n/*\nunraveling pmodfm() for type Float gets you: (untested, may have typos)\n\nfloat pmodfmFloat(float u,float n,float m,float f,float e){\n m=floor((m)+.5);        //pmodfm() step <-> offset to center of a tile\n u=u-m;n=n-m;            //pmodfM() step <-> offset by M\n float a=floor((u)+.5);              //pmodfq() [a] parameter is tile-centric [u]\n float b=(n)/(max(f,1.+(e))-1.);     //pmodfq() [b] parameter is modified [e]\n a=(fract(((a)/(b))+.5)-.5-(e))*(b); ///pmodfe(a,b,e); (woth 0.5 offset)\n return floor(a+.5);                 //undo offset to center of a tile\n ;}\n\n//the pmodfM() [offset By M] step is the reason, that the inputs are so unintuitive.\n//see commonTab for an alternative, for more intuitive Hairline-inputs.\n*/\n\n\nvec4 iMouseZwFix(vec4 m,bool NewCoke\n ){if(m.z>0.){ //while mouse down\n    if(m.w>0.)return m;//mouse was clicked in THIS     iFrame \n    else m.w=-m.w      //mosue was clicked in previous iFrame\n    //remember, MouseDrag advances the iFrame Count, even while paused !!\n ;}else{if(!NewCoke||m.w>0.)return m.xyxy; //OPTIONAL onMouseUp (fold or whatever)\n    m.zw=-m.zw;}\n  return m;}\n\n//self  ; F for Folding  :\n//parent; E for emergence: https://www.shadertoy.com/view/4ldfDr\n//previous gen:\n//- parent: https://www.shadertoy.com/view/4ldfDr\n//- parent: https://www.shadertoy.com/view/XttfWn\n//- parent: https://www.shadertoy.com/view/Ml3fDr\n//- parent: https://www.shadertoy.com/view/ldXBzj \n\n//chord, dither, pixelation, tiling, quantum, fold, fibonacci, weave, pmod, tartan, hairline, dotted, notekey, starguitar\n\n\n//[f for folding frames] focusses on defining and displaying sheet music.\n//as i finally got https://www.shadertoy.com/view/Xl3BD4  working nicely, which interval-folds a 4d quantized list\n// so it should be easy to project chords and canons with it onto different hyperplanes of istruments with overtones.\n//but before imlementing that, i need to sort the mess that [E for emergence] has grown into\n//and firstmost, it needs a focus on visuals while the vis shader is getting trickier\n//- must be able to disable dft over time on runtime, between different songs/segments?\n//- must be able to load different melody-display-modes\n//- - this means, toggling between functions over time, that return the image. its doable, i just never tried any such animating.\n//- - - this puts anything dft related all the way up!\n//- - - and all vis-related with it, \n//- - - yeah, this is fine\n//- - - but it calls for a backup, new [version F]:\n//[f for folding frames] should also include:\n//- https://www.shadertoy.com/view/Xl3BD4\n//- https://www.shadertoy.com/view/4t3fDN\n\n//[Beautiful Reality (2) Chain Algorithm]\n\n//for the sake of its TestInstrument4Times() function\n//that is quite efficient in generatinga random melody\n//with fibonacci sequencing\n//, seeded by iDate.zw, with 4x overlap\n//,using fast vectorization.\n\n//currently a messy union of 2 instrument collections, to get roughly one third added to them, named alphabetically\n//its messy, full of dupes, and sorting it is a longer process...\n//while sorting  and comparing, you notice a lot of patterns/aliases\n//and permutations of them are an emergend process.\n\n//i started naming my excustions in toing this wirth FM synthesis alphabetically\n//because i delayed the trickier process of comparing ALL the hulls/gains/amps/windowFunctions...\n//for 2 years, and collected enough examples, top sort their files alphjabetically\n//and i oince again skilled most of my [d]rum instruments...\n//because i needed a a good union of my previous FM collection:\n//so this is now a mess of 2 collections...\n\n\n//___end_  intro, start of UI parameters (change these, without risking to break much)\n//__start_ UI modes\n\n//this is a namespace mess of globals: YAY:\n\n//may want to remove this to get 10* fps. it toggles 2 modes, only one of them dares to do DFT.\n#define showDFT\n//dft iterations are a recource hog, because of bad memory management and no recursion/tree.\n//iterscaDFT sets how many dft iterations you want\n//iterMaxDFT sets a limit. there is a n=min(iterscaDFT,iterMaxDFT*u.x) somewhere\n//and a resource hogging loop over that [n]\n//the dft is easier to read while iterscaDFT*u.x<iterMaxDFT (right side of the red bar)\n//because overtoners then live on other diagonals than the local extrema. \n//but when iterscaDFT iterMaxDFT (left sifde of the bar) the image \"flattens\"\n//ideally iterMaxDFT should share many prime factors of 440.\n#define iterMaxDFT 110.\n//the mouse inoput is funy iff bot hlimits are set to the same, which simplifies intuition\n#define iterscaDFT iterMaxDFT\n//the trick here is that iterscaDFT looks better AND computes faster\n//, once you get used to the diagonals of the overtones.\n//a less diagonal-overtone view still persists as mental anchor on the left half of the red bar\n\n//reverb slows down parsing a lot, and may crash opengl iff there is not enough vRam\n//for all the instruments/sets that have reverb/echo defined.\n#define doReverb true\n\n#define base_a4 440.\n//vibrato for ap() as subroutine of arp()\n#define apVibratoDelay .1\n\n//https://www.shadertoy.com/view/Xtl3DB\n//buzz electric, with doppler erffect\n//for doppler shift\n#define SPEEDOFSOUND 20.\n//for doppler shift\n#define DAMPING 1.\n\n//int globalTranspose=0;\nfloat baseFreq=1.0;\nfloat globalTime=0.0;\nfloat speed=1.2;\nfloat tempo = 0.0;\nfloat tune  = 0.0;\n\nconst float beatLength = 1.0/7.5;\n\n//RES .02 for DrWho intro\n#define RES .02\n\n#define globalTranspose 0\n\n//i keep confusing these 2 labels all the time\n\n//__end__ UI modes\n//_start_ credit licenses\n\n//MdjXWc is by Dmitry Andreev - and'2014\n//License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//__end__ credit licenses\n//__start_ structure\n\n//bijectively linear-project [u] from domain [s1,s2] to range [t1,t2]\n//easily works for 4d vectors, for domaon-stretching portals and window-contexts.\n#define biject(u,s1,s2, t1, t2) mix(t1,t2,(u)/(s2-(s1)))\n//nonlinear bijections are more special, and should be seperated.\n\n//(sorted/sequential) [a] divides a domain with 3 cuts, return b[t]\nfloat bilinT(float t,vec3 a,vec4 b){\n   return  mix(mix(b.w,b.z,step(t,a.z)),mix(b.y,b.x,step(t,a.x)),step(t,a.y));}\n\n#define vec1 float\n#define dd(a) dot(a,a)\n#define u2(a) ((a)*2.-1.)\n#define u5(a) ((a)*.5+.5)\n#define sat(a) clamp(a,0.,1.)\n#define pow2 exp2\n#define TT(d) mod(mod(time,1.0)-d,1.0)\n#define trunc(a) float(int(a))\n#define ma0(a) max(0.,a)\nvec2 fr(float a){return vec2(fract(a),floor(a));}\nfloat su(vec4 a){return a.x+a.y+a.z+a.w;}\nvec2 pan(float p){return vec2(.5-p*.5,.5+p*.5);}\n\nstruct w11{vec1 a;vec1 b;};\nstruct w12{vec1 a;vec2 b;};\nstruct w13{vec1 a;vec3 b;};\nstruct w14{vec1 a;vec4 b;};\n    \n\n//explicit integer modulo\nint imod(int x, int y){return x -(x / y) * y;}\n\nvec3 mx(vec3 a,vec3 b,vec3 c){return mix(a,b,c);}\nvec3 mx(float a,vec3 b,vec3 c){return mix(vec3(a),b,c);}\nvec2 cs(float a){return vec2(cos(a),sin(a));}\nvec1 suv(vec4 a){return dot(vec4(1),a);}vec1 suv(vec3 a){return dot(vec3(1),a);}vec1 suv(vec2 a){return a.x+a.y;}//sum of vector\n\n\n//___end__ structure\n//__start_ hash noise\n\n//hashes and noises (messy namespace function stuff, instrument lib specific, oh well:\nfloat noise1(float t, float seed){return 1.0+sin(t * 0.02 * seed+sin(t * 0.05 * seed)) * 0.25;}\n//zsed for drums, a sin(dot()) noise tends to be more pseudo-fractal.\nfloat rand(vec2 co){return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);}\n// Hash from https://www.shadertoy.com/view/4djSRW\nvec2 hash2(vec2 p\n){p=fract(p * vec2(5.3983, 5.4427))\n ;p+=dot(p.yx,p.xy+ vec2(21.5351, 14.3137))\n ;return fract(p.x*p.y*vec2(95.4337,97.597));}\nfloat rand(float a){return fract(sin(a) * 43758.5453123);}\nfloat noise(float a){return sin(mix(rand(floor(a)),rand(floor(a+1.)),fract(a)));}\nfloat fbm(float a\n){float s=0.\n ;for (float i=1.;i<5.;i++\n ){s+=noise(a)/i\n  ;a*=2.\n  ;}return s;}\nvec2 noise2(float t){return hash2(vec2(t, t * 1.423)) * 2.0-1.0;}\nfloat hash(float x){return fract(sin(x)*265871.1723);}\nfloat noize(float t){return fract(sin(t*3314.9)*342.0);}\nfloat rand21(vec2 co){return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);}\n\n\n// Hash from https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p\n){p=fract(p * vec2(5.3983, 5.4427))\n ;p+=dot(p.yx,p.xy+vec2(21.5351, 14.3137))\n ;return fract(vec2(p.x*p.y*95.4337,p.x*p.y*97.597));}\n/*\n//vec2 noise(float t){return hash22(vec2(t,t*1.423))*2.-1.;}\nvec2 lpnoise(float t, float f\n){vec2 g=fr(t*f)\n ;return mix(noise(g.y/f),noise((g.y+1.)/f),smoothstep(0.,1.,g.x));}*/\n\n\n//https://www.shadertoy.com/view/MdjXWc\nvec2 lpnoise(float t, float fq//FM lp-noise for reverb\n){t*=fq\n ;float f=fract(t)\n ;vec2 r=floor(t-f+vec2(0,1))/fq\n ;f=smoothstep(0.,1.,f)//;f=step(f,0.)//harder and faster\n ;return mix(noise2(r.x),noise2(r.y),f);}\n\n\n\n\n\n//__end___ hash noise\n//_start__ elemenraty fourier epicircles\n\n#define pi acos(-1.)\n#define pi2(a) (2.*pi*(a))\n#define co2p(a) cos(pi2(a))\n#define si2p(a) sin(pi2(a)) \n//exp(i*pi2)=0.; i*i=-1.; should be utilized to define pi2=6.28...\n//above is eulers identity, with pi*2, going \"full rotation\"\n#define tau (pi*2.)\n#define CON tau\n#define TWOPI tau\n#define PI2 tau\n\n//https://www.shadertoy.com/view/llG3Ry\nfloat TAU = acos(-1.)*2.;\nfloat TWOTAU = acos(-1.)*4.;\n\n//note2frequency http://en.wikipedia.org/wiki/MIDI_Tuning_Standard\nfloat midi_freq(int m){return 440.*pow(2.,float(m-69)/12.);}\nfloat wav(float hz, float dB,float time){return 20.*pow(10.,dB/10.)*(pow(sin(pi*hz*time), 2.)-.5);}\n\n\nfloat Sine(float t,float f){return si2p(f*t);}\n\n\nfloat Tri(float t){return u2(abs(fract(t)-.5)*2.);}\nfloat Saw(float t){return -u2(fract(t));}//is time reversed\n//float Tri( float t ){\treturn abs(fract( t ) * 4.0-2.0)-1.0;}\n//float Saw( float t ){\treturn fract( t ) * 2.0-1.0;}\nfloat ssaw(float t){return 4.0*(abs(fract(t+0.75)-0.5)-0.25);}\n\n\n\nfloat Square(float t ){return step(fract(t),.5)*2.-1.;}\nfloat rect(float t){if (fract(t/pi/2.)<.5)return 1.;return 0.;}//this sounds just bad!\n\nfloat saw_wave(float t){return fract(t)-.5;}\nfloat Squ(float t){return u2(step(fract(t),.5));}\nfloat square_wave(float t){return (fract(t)>.5) ? 0.125 : -0.1;}\n\nfloat sinsaw_wave(float t){float x=fract(t);return .5-x*x;}\n\nfloat sin_wave(float t){return sin(t*pi*2.);}\nfloat sine(float t){return sin(t*pi*2.);}\nvec2  sine(vec2 t){return vec2(sine(t.x),sine(t.y));}\nfloat Sin(float t){return sin(t*pi*2.);}\nfloat Cos(float t){return cos(t*radians(360.));}\n\n\n\n//elementary\n// Sine wave\n//#define sine(freq, time) (sin(6.28318531*time*freq))\n// Saw wave\n//#define saw(freq, time) ((time*freq - floor(time*freq)) * 2.0 - 1.0)\n// Square wave\n//#define square(freq, time) (sign(sin(6.28318531*time*freq)))\n// Triangle wave\n//#define tri(freq, time) (1.0 - abs(mod(freq*time, 1.0)-2.0))\n//https://www.shadertoy.com/view/Mt2GDz\n//elementary\nfloat ntof(float n){if(n<12.0)return 0.0;return 440.0 * pow(2.0, (n - 67.0) / 12.0);}\nfloat ssaw2(float t){return 4.0*abs(fract(t)-0.5)-1.0;}\nfloat rnd(float t){return fract(sin(t*341.545234)*1531.2341);}\nfloat srnd(float t){float t2=fract(t);return mix(rnd(floor(t)),rnd(floor(t+1.0)),t2*t2*(3.0-2.0*t2));}\n//https://www.shadertoy.com/view/MlXGDn\n//elementary\nfloat osc_noise(float p){p *= 20000.;float F = floor(p), f = fract(p);\n return mix(hash(F), hash(F+1.), f);}\nfloat osc_sine(float p){return sin(p*tau);}\nfloat osc_saw(float p){return p*2.-1.;}\nfloat osc_square(float p,float x){return -1.+2.*step(x,p);}\nfloat osc_sinefm(float pc, float pm, float b){return sin(pc*tau+b*sin(pm*tau));}\nfloat osc_tri(float p, float x//https://www.shadertoy.com/view/MlfGRM\n){float a=smoothstep(0.,x,p),b=smoothstep(1.,x,p)\n ;return (a*b)*2.-1.;}\n//elementary Basic waveforms with note and octave input\nfloat sn(float t, float note, float octave){\n\treturn sin(t*note*exp2(octave)*pi);}\nfloat saw(float t, float note, float octave){\n\treturn fract(t*note*exp2(octave-1.))-0.5;}\nfloat tri(float t, float note, float octave){\n\treturn (abs(fract(t*note*exp2(octave-1.))-0.5)*2.-0.5)*2.;}\nfloat sqr(float t, float note, float octave){\n\treturn step(fract(t*note*exp2(octave-1.)), 0.5)-0.5;}\n//elementary bitwise square wave //https://www.shadertoy.com/view/4dlyWl\nconst int seq1[] = int[](66,89,125,54,89,66,54,37);\nconst int seq2[] = int[](81,106,125,54,106,81,54,37);\nint g(int i,int x,int t,int o){return((3&x&(i*(((3&i>>16)!=0?seq1[t%8]:seq2[t%8])+51)>>o))<<4);}\n//elementary\n// regular sine\nfloat wave0(float x){return sin(tau*x);}\n// half sine + pause\nfloat wave1(float x){return max(sin(x*tau),0.0);}\n// half sine, double frequency\nfloat wave2(float x){return abs(sin(x*tau));}\n// quarter sine + pause, double frequency\nfloat wave3(float x) {return abs(sin(x*tau))*step(fract(x*2.0),0.5);}\n// sine + pause, double frequency\nfloat wave4(float x){return sin(x*tau*2.0)*step(fract(x),0.5);}\n// half sine + pause, double frequency\nfloat wave5(float x) {return abs(sin(x*tau*2.0))*step(fract(x),0.5);}\n// square wave\nfloat wave6(float x) {return step(fract(x),0.5)*2.0-1.0;}\n// saw wave\nfloat wave7(float x) {return 1.-2.*fract(x);}\n// normalizes arguments so the sum is 1\nvec4 normsum(vec4 p) {return p / (p.x+p.y+p.z+p.w);}\n\n//elementary\nfloat si(float i){return sin(fract(i)* pi*2.); }\n//clamped siene sounds more like a metallic flute if(with overtones)\nfloat csi(float i){return clamp(si(i),-.707,.707); }             \nfloat saw(float i){return fract(i)*2.-1.;}\nfloat sq(float i){return mix(0.,1.,step(fract(i),.5));}\n//(https://www.shadertoy.com/view/4sSSWz)\n//elementary\n#define trunc(a) float(int(a))\nfloat notetrunc(float t){return trunc(sin(0.25*t)*4.+cos(0.375*t)*4.0);}\n//https://www.shadertoy.com/view/4sXSWf\n//elementary\nfloat n2f      (float n){return 55. *pow(2.,(n- 3.)/12.);}\nfloat noteFreq (int n  ){return n2f(float(n+39));}\nfloat noteMIDI (float n){return 440.*pow(2.,(n-69.)/12.);}\nfloat calcHertz(float n){return 440.*pow(2.,(n    )/12.);}\n\n\n\n//ldlSD2 is band limited waves are less hurting, Written by Alan Wolfe\n//http://demofox.org/\n//http://blog.demofox.org/\n//http://blog.demofox.org/2012/06/18/diy-synth-3-sampling-mixing-and-band-limited-wave-forms/\n// the frequency of the tone\n#define TONE_FREQUENCY \t440.+(cos(t*0.61))*u5(-cos(t*3.61))*2.\n//the waveform refreshes every fpsWave-frames, because 60 fps flickers too much oif there is any aperiodic phase shift.\n#define fpsWave 7.\n// how long each tone plays, in seconds\n#define TONE_LENGTH 2.\n// how long to fade in and out each wave form\n#define epsEnv  (TONE_LENGTH*.3)\n// how many harmonics (sine waves) for each bandlimited wave form\n#define NUM_HARMONICS_SQU \t11.\n#define NUM_HARMONICS_SAW \t9.\n#define NUM_HARMONICS_TRI\t3.\n//https://www.shadertoy.com/view/ldlSD2\n//band limited waves are less hurting\n#define iterSawBL(t,i) sin(pi*2.*t*(i+1.))/(i+1.)\n#define iterSquBL2(t,i) sin(pi*2.*t*i)/i\n#define iterSquBL(t,i) iterSquBL2(t,(i*2.+1.))\n#define iterTriBl2(t,h,i) (sin(pi*2.*(t-.25)*h)*(mod(i,2.)*2.-1.)/(h*h))\n#define iterTriBl(t,i)  iterTriBl2(t,(i*2.+1.),i)   \n#define endTriBl 8./pi/pi\n#define endSawBl 2./pi\n#define endSquBl 4./pi*0.9\n// the 0.9 shouldn't be needed, but for some reason the amplitude seems wrong without it...                 \n#define blEnd(a,b,c) {float v=0.;for (float i= 0.; i < a; ++i){v+=b(t,i);}return v*c;}\nfloat SawBL(float t)blEnd(NUM_HARMONICS_SAW,iterSawBL,endSawBl)\nfloat SquBL(float t)blEnd(NUM_HARMONICS_SQU,iterSquBL,endSquBl)\nfloat TriBL(float t)blEnd(NUM_HARMONICS_TRI,iterTriBl,endTriBl)\n\n//__end___ common\n//__start_ hulls\n\n//*exp(-3.0*time);//fadeout over time    \n\n//https://www.shadertoy.com/view/MdjXWc\nfloat remap(float l,float h,float x){return sat((x-l)/(h-l));}\n\n                          \n//Pan11 mono-waveform[a] by[p]; 0==left; .5=center; 1.=right channel\n#define pan01(a,p) mix(vec2(a,0),vec2(0,a),p)\n//Pan11 mono-waveform[a] by[p]; -1==left; 0=center; 1.=right channel\n#define pan11(a,p) pan01(a,u5(p))\n\nfloat drummyHull(float t){return max(0.,(1.-mod(t * 4.0, 1.0)*2.));}\nfloat drumExclusion(float t){return 1.-float(mod(t,16.)>=3.&&mod(t,2.)>=1.);}\n\nfloat ss(float u,vec2 m){return smoothstep(m.x,m.y,u);}\n//smoothstep utility; m.y=0 is a step-function\n//root is at m.x; y=1 intersection at m.x-m.y, negative m.y ascend over u++\nfloat ssimple(float u,vec2 m){return ss(u,vec2(m.x,m.x-m.y));}\n//ssimpleLin is the linear to the parametricallyIdentical ssimple()\nfloat ssimpleLin(float u,vec2 m){return sat((m.x-u)/m.y);}\n//clamped linear interpolation since [s] over distance.y=[a] during time [l] over [t]\n//float decLin(float t, float s, float l, float a//time,start,length,amount\n//){return clamp((t-s)/l,0.,a);}//linear decay //https://www.shadertoy.com/view/Mt2GDz\n//todo i still need that declamp context where i get the identity that\n//has clamo(a,0,b) use clamo(a,0,1) useas its subroutine!\n//sign of [a] and [r] should be the same. then its ss up from 0 il la, and then backk down from a toll e\n//else, its an convoluted single smoothstep for 2 smoothsteps.\nfloat ssAr(float t, float a, float e){return smoothstep(0.,a,t)*smoothstep(e,0.,t-a);}\n//env_ar generalization, but with 3 points,and good chanves for a flat center.\nfloat ssAsr(float t, float s, float a, float e\n){return smoothstep(0.,a,t)*smoothstep(e,0.,t-a-s);}\n//https://www.shadertoy.com/view/MlfGRM\n\n\n//hull\n//smooth abs() ==??\nfloat sAbs1(float x,float k){return sqrt(x*x+k);}\n//nice smin?\nfloat sMin(float a, float b, float k){return(a+b-sAbs1(a-b,k))*.5;}\nfloat sMax(float a, float b, float k){return -sMin(-a,-b,k); }\n//identity of SMOOTH clamp\nfloat sClamp(float x, float a, float b, float k){return sMin(b,sMax(a,x,k),k);}\n//smooth clamped sine instrument\nfloat sndsmoothclampedsin(float time\n){return sClamp(pow(sin(6.2831*440.0*fract(time*.94)),64.),-.25,.55,.04);}\n\n\nvec4 debugEnv(vec2 u,vec2 r,vec4 m){\n ;u=u/r     ;u-=.5;u*=4.;u.x *=r.x /r.y\n ;m=m/r.xyxy;m-=.5;m*=4.;m.xz*=r.xx/r.yy\n ;vec4 c=vec4(0)\n ;c.x=ssimpleLin(u.x,m.xy)\n ;c.y=ssimple   (u.x,m.xy)\n ;c.z=ssAsr     (u.x,m.x,m.y,m.z)\n ;c.xyz-=u.y\n ;c=abs(c)\n ;c=smoothstep(.01,-.01,c-.1)\n ;c.w=1.\n ;return c;}\n\n//__end___ hulls\n//_start__ modulation (fourier hyperslices)\n\n//arp = Arpeggiator, = chord with offset over time, can overlap or not.\n// https://en.wikipedia.org/wiki/Arpeggio   is common for string instruments.\n//https://www.shadertoy.com/view/4ssfzj\n//emulates a whole xm-chip, and xm-sequencer.\n//#define PHI_INC(cnt, val)cnt< 0.0?0.0:exp2(float(val)/12.0)*clamp(cnt, 0.0, 1.0), cnt -= 1.0\n#define PHI_REP(cnt, val)cnt< 0.0?0.0:exp2(float(val)/12.0)*max(cnt, 0.0)\nfloat arpeggio3(float p, int d0, int d1, int d2\n){vec3 j=vec3(d0,d1,d2)\n ;vec2 r=vec2(0)\n ;float o=mod(p,3.),f=floor(p/3.)\n ;for(int i=0;i<4;i++){float e=exp2(j[i]/12.0),v=0.;if(o>=0.){v=e*max(o,0.);o-=1.;}r+=vec2(v,e)\n ;}return r.x+r.y*f;}\n//https://www.shadertoy.com/view/XlBGz3\n\n\n//arp\n//https://www.shadertoy.com/view/XscXzn\n//ap(...int...) is being iterated over by ap(...int[3]...),an arp commonly uses at least 3 iterations.\nfloat ap(float t,int n,float speed,float delay,int noteId//time,overtoneI,speed,delay,IterationNumber\n){n+=globalTranspose\n ;t+=float(noteId)*delay\n ;float f=base_a4*pow(2.,float(n)/12.)*baseFreq*speed\n ;f+=1.+sin(t*20.*speed)/pi*.0005*f*step(0.,t-apVibratoDelay)\n ;vec2 e=max(1.-(t),0.)*f+vec2(0,cos(t*5.0)/pi)//create sqr duty wave on .y\n ;return clamp(e.x-e.y,-1.,1.)*pow(max(0.,1.-(t*baseFreq)),1.5);}\nfloat ap(float t,int n[3],float s,float d//time,overtones,speed,delay\n){float c=0.;for(int i=0;i<3;i++){c+=ap(t,n[i],s,d,i);}return c;}\n#define ARP(d,n)   c+=ap(TT(d),n,1.0/speed,delay) \nfloat arp(float t\n){float c=0.\n ;float speed=4.\n ;float delay=-0.4\n ;float time=mod(t*speed,4.0*speed)\n ;float  g=time/speed\n ;int i[3]\n ;      if(g<1.){i[0]=0;i[1]=3;i[2]=7;ARP(0.0,i)\n ;}else if(g<2.){int a=-2;i[0]=0+a;i[1]=4+a;i[2]=7+a;ARP(0.0,i)\n ;}else if(g<3.){int a=-4;i[0]=0+a;i[1]=4+a;i[2]=7+a;ARP(0.0,i)\n ;}else if(g<4.){int a=-4;i[0]=0+a;i[1]=4+a;i[2]=7+a;ARP(0.0,i)\n ;}return c*.4;}//https://www.shadertoy.com/view/XscXzn\n                          \n\n//deform doppler\nfloat snd(float t){float s=ssaw(50.*t);return sign(s)*pow(abs(s),1.1+sin(t*20.));}\nvec2 rep(vec2 p,vec2 a){return abs(mod(p+a,a*2.)-a);}//doppler subroutine //https://www.shadertoy.com/view/Xtl3DB\nfloat DEL(vec3 z//doppler subroutine //https://www.shadertoy.com/view/Xtl3DB\n){z.xz=rep(z.xz,vec2(7,6))\n ;return length(abs(z)-vec3(2.74,.83,2.74)+vec3(-.82,0,-1));}\nvec3 herert(vec3 fw,vec3 up){fw=normalize(fw);return normalize(cross(fw,normalize(up)));}\nfloat phys(float time, float dist//doppler subroutine //https://www.shadertoy.com/view/Xtl3DB\n){float tim=time-dist/SPEEDOFSOUND\n ;return snd(tim)*exp(-dist*DAMPING);}\nvec2 demoDopper(float t\n){float tim=t*.25\n ;vec3 o=vec3(sin(tim)*(2.+tim),4.5,cos(tim))-4.\n ;vec3 rt=.1*herert(vec3(-4,-.6,-4)-o,vec3(0,1,0))\n ;return vec2(phys(t,DEL(o)),phys(t,DEL(o+rt)));}\n\n\n//__end___ modulation\n//__start_ standalone sequences:\n\n\n\n//boolean filter over [t] for drum sequence\n\nfloat dumbSequence(float t){return floor(fract(t*(sqrt(5.)*.5+.5))*8.);}\nvec4 dumbSequence(vec4 t){return floor(fract(t*(sqrt(5.)*.5+.5))*8.);}\n\nfloat sequenceThemDrWho(float nr//dr who theramin sequence //https://www.shadertoy.com/view/4dSXRm\n){//a tree structure, for benchmarking and testtng purposes, it seems to outperform linear branching.\n ;if (46.0<nr||nr<15.)return -120.//left and right end\n ;if(nr>42.5)return mix(43.,44.,step(nr,43.));\n ;if (nr<33.5){if(nr<23.)return bilinT(nr,vec3(0,1,6)+16.   ,vec4(31,56,55,-120))\n              ;else      return bilinT(nr,vec3(0,1,6)+24.   ,vec4(58,42,43,-120))\n ;}else{       if(nr<39.)return bilinT(nr,vec3(0,1,2.5)+34.5,vec4(43,39,31,34))\n              ;else      return bilinT(nr,vec3(0,1,1.5)+39.5,vec4(42,31,-120,31))\n ;}}//damn i messed up the timing a bit, and fail to fix it.\n\n//__end___ standalone sequences\n//__start_ instruments-shiftable\n\n\n\n//instrument flute/violing/horn (strong overtomes, no keyboard, but dynamic holes or pipe lengths for modulation\nfloat introHorn(int note, float t//https://www.shadertoy.com/view/MljGRd\n){t=t-1.5\n ;if(t<-1.)t=-pow(-t,1.-(t+1.)*0.4)\n     ;else{t+=u5(-sin(t*2.)*.2)+.2;note-=2;}//optionally, broken record coth trig-time.\n ;float baseFreq=pi*2.*noteFreq(note)*t*.5\n ;float[6] ots=float[6](1.,.75,.75,.5,.75,.5)//overtones\n ;float r=.0;for(int i=1;i<=6;i++){r+=sin(baseFreq*float(i))*ots[i];};return r;}\n\n//DrWho sequence+instrument\nfloat DrWho2Tap(float time, float tt, float FM){\n    tt -= mod(tt,RES);\n    float note1 = sequenceThemDrWho(tt);\n    float note2 = sequenceThemDrWho(tt+0.5);\n    if (note1 <0.0)     return 0.0;    \n    float stepper = smoothstep(0.1,0.5,mod(tt,0.5));\n    float note = mix(note1,note2,stepper);    \n    float angle = PI2*n2f(note)*time;\n    return sin(angle+FM*sin(angle*2.033));}\nvec2 DrWhoTheramin(float time, float tt\n){tt=mod(tt,48.)\n ;tt += 1.33\n ;float FM = 0.0\n ;if (tt>=32.)FM = PI2/2.\n ;float sampl\n ;float ta = mod(tt-RES/2.0,RES)-RES/2.\n ;float halfSin = RES/4.0;//4.0/frequency\n ;if (abs(ta)<halfSin\n ){float sample1=DrWho2Tap(time,tt-RES/2.,FM)//oh please be overlapping magic!\n  ;float sample2=DrWho2Tap(time,tt+RES/2.,FM)\n  ;sampl = mix(sample1,sample2,smoothstep(-halfSin,halfSin,ta))\n ;}else sampl=DrWho2Tap(time,tt,FM)\n  ;return vec2(sampl);}////https://www.shadertoy.com/view/4dSXRm\n//instrument\nfloat stringElectric(const in vec2 vFreqTime//https://www.shadertoy.com/view/MdsGzr\n){float f=vFreqTime.x\n ;float t=vFreqTime.y\n ;if(t<0.)return 0.\n ;float x=0.\n ;float a=1.\n ;float h=1.\n ;for(int i=0;i<4;i++ //3 overtones\n ){x+=Sin(f*t*h)*exp2(t*-a)\n  ;x+=Sin(f*(t+0.005)*h*.5)*exp2(t*-a*2.)\n  ;h=h+1.01\n  ;a=a*2.\n  ;}return x;}//return vec2(Instrument(vec2(440.,time)));\n\n\n//instrument PianoLight\nvec2 PianoLight(float de,float time//Instr3() //https://www.shadertoy.com/view/llsSDf\n){float f0=440.0*de*0.001953125\n ;float f=sin(f0*pi*time)*.02;\n ;vec4 abce=vec4(1,2,4,16)*2.\n ;vec4 g=vec4(0,80,40,1)*.001\n ;float a=sin(abce.x*f0*pi*time)\n ;abce=sin(abce*f0*pi*time)*g\n ;return vec2((su(abce)+f)*0.5*exp(-0.6*time)*exp(-1.0*time));}\n//instrument PianoBase\nvec2 PianoBase(float de,float t//Instr1() //https://www.shadertoy.com/view/llsSDf\n){float f0=440.*de*.001953125\n ;vec4 g=vec4(80,40,0,1)*.001\n ;vec4 bcef=vec4(1,2,4,16)*2.\n ;bcef=sin(bcef*f0*pi*t)*g\n ;float a=sin(f0*pi*t)*.02 \n ;return vec2((a+su(bcef))*.5*exp(-t));}\n//instrument Bass\nvec2 Instr2(float de,float t //https://www.shadertoy.com/view/llsSDf\n){float x=pi*t*2.\n ;float f0=de*110.0*0.015625\n ;float a=sin(f0*2.*pi*t)\n ;float c=.2*t+.25*a\n ;float b=sin(a*c*2.*pi)\n ;return vec2(b*.9*exp(-.3*t)\n                  *exp(-.3*t)\n                  *exp(-.1*t));}\n\n\n//instrument organ with soft overtones\nfloat organ(float t,int k){if(k<1||k>=0xC0)return 0.;//null key\n float f=27.5*pow(2.,float(k)/12.),r=0.;t*=f;\n for(int i = 1;i<8;i++){\n  r+=csi(float(i)*t)*pow(.6,float(i));}\n //*pow(.6,float(i)) diminishes amplitude exponentially for each overtone.\n r*=(1.+si(t*10.)/8.);\n return r*5.*inversesqrt(f);}//https://www.shadertoy.com/view/lstXWS\n//instrument harp+bell with echo ,final fantasy 7\n//instrument\nfloat HarpBell(float f, float t//[f]frequency [t]time\n){f*=t\n ;float y=.7*sin(   tau*f)*exp(-.0075*f)\n ;y+=.2*sin(2.*tau*f)*exp(-.0055*f);return y*sat(t/.004);}\nfloat HarpBell2(float f,float t){    \n float p=.2+0.8*max(0.,6.-.01*f);f*=t;\n p*=sin(tau*f)*exp(-f*0.2);\n float y=.70*sin(     tau*f+p)*exp(-.005*f);\n      y+=.20*sin(2.01*tau*f+p)*exp(-.0055*f);\n      y+=.16*sin(4.01*tau*f+p)*exp(-.009*f);\n return y*sat(t/.004);}\n//https://www.shadertoy.com/view/XllXWN\n//instrument snippet\n/*\n{ //soothing harry potter sine\n    //...  //https://www.shadertoy.com/view/lssXWS\n    // calc frequency and time for note\t  \n    float noteFreq = 440.0*pow( 2.0, (n-69.0)/12.0 );\n    float noteTime = 0.18*(t-x);\n    // compute instrument\t\n    float y  = 0.5*sin(6.2831*1.00*noteFreq*noteTime)*exp(-0.0015*1.0*noteFreq*noteTime);\n\t      y += 0.3*sin(6.2831*2.01*noteFreq*noteTime)*exp(-0.0015*2.0*noteFreq*noteTime);\n\t      y += 0.2*sin(6.2831*4.01*noteFreq*noteTime)*exp(-0.0015*4.0*noteFreq*noteTime);\n          y += 0.1*y*y*y;\t  \n          y *= 0.9 + 0.1*cos(40.0*noteTime);\n\t      y *= smoothstep(0.0,0.01,noteTime); \n    // accumulate echo\t  \n    tot += y * vec2(0.5+0.2*h,0.5-0.2*h) * (1.0-sqrt(h)*0.85);\n      ///... tot is an accumulator for echo outside of a loop\n}*/\n\nfloat EnvEps(float m){;float e =1.\n ;     if(m<epsEnv)              e=m/epsEnv\n ;else if(m>(TONE_LENGTH-epsEnv))e=1.-((m-(TONE_LENGTH-epsEnv))/epsEnv)  \n ;return e;}\n////////\nfloat demoBandMix(float t//_ldlSD2\n){float m=mod(t,TONE_LENGTH)\n ;float e =1.\n ;     if(m<epsEnv)              e=m/epsEnv\n ;else if(m>(TONE_LENGTH-epsEnv))e=1.-((m-(TONE_LENGTH-epsEnv))/epsEnv)  \n //above envelope [e] figured out how much to scale the volume to account for envelope\n //on the front and back of each wave form\n ;m=mod(t / TONE_LENGTH, 6.0) // play the apropriate wave form based on time \n ;//m=3.2;\n ;t*=TONE_FREQUENCY\n ;if     (m>5.)return e*SquBL(t) \n ;else if(m>4.)return e*Squ  (t) \n ;else if(m>3.)return e*SawBL   (t) \n ;else if(m>2.)return e*Saw(t) \n ;else if(m>1.)return e*TriBL(t) \n ;else         return e*Tri(t)\n ;}\nvec2 demoBandLimit(float t){return vec2(demoBandMix(t));}\n\n//instrument\nfloat instrumentBanjo( float freq, float time//https://www.shadertoy.com/view/ldXXDj <---\n){freq = 440.0*pow(freq/440.0,1.003) // spread\n ;float ph=1.\n ;ph*=sin(6.2831*freq*time)\n ;ph*=.2+.8*max(0.0,6.0-0.01*freq)\n ;ph*=exp(-time*freq*0.2)\n ;vec3[8]ob;\n  ;ob[0]=vec3(.70,1,.007)\n  ;ob[1]=vec3(.20,2.01,.011)\n  ;ob[2]=vec3(.20,3.01,.015)\n  ;ob[3]=vec3(.16,4.01,.018)\n  ;ob[4]=vec3(.13,5.01,.021)\n  ;ob[5]=vec3(.10,6.01,.027)\n  ;ob[7]=vec3(.09,8.01,.030)\n ;float y=0.\n     ;float ft=freq*time\n ;for(int i=0;i<=7;i++){\n  ;vec3 o=ob[i]\n  //;y+=o.x*sin(o.y*pi*2.*ft+ph)*exp(-.5*o.z*ft)\n ;}\n ;y+=.70*sin(1.00*6.2831*freq*time+ph)*exp(-.5*.007*freq*time)\n ;y+=.20*sin(2.01*6.2831*freq*time+ph)*exp(-.5*.011*freq*time)\n ;y+=.20*sin(3.01*6.2831*freq*time+ph)*exp(-.5*.015*freq*time)\n ;y+=.16*sin(4.01*6.2831*freq*time+ph)*exp(-.5*.018*freq*time)\n ;y+=.13*sin(5.01*6.2831*freq*time+ph)*exp(-.5*.021*freq*time)\n ;y+=.10*sin(6.01*6.2831*freq*time+ph)*exp(-.5*.027*freq*time)\n ;y+=.09*sin(8.01*6.2831*freq*time+ph)*exp(-.5*.030*freq*time)\n ;y+=.07*sin(9.01*6.2831*freq*time+ph)*exp(-.5*.033*freq*time)\n ;y+=.45*y*y*y\n ;y*=1.+1.5*exp(-8.0*time)\n ;y*=sat(time/0.004)\n ;y*=2.5-1.5*sat(log2(freq)/10.)\n ;return y;}//return vec2(instrumentBanjo(440.,time));\n\n\n//dr who bass (sans sequence)\nvec2 DrWhoBass(float time, float tt, float note//bass() //https://www.shadertoy.com/view/4dSXRm\n){if (tt<0.0)return vec2(0.)\n ;float freqTime = 6.2831*time*n2f(note)\n ;return vec2(( sin(freqTime   +sin(freqTime)*7.0*exp(-2.0*tt))\n               +sin(freqTime*2.+cos(freqTime*2.0)*1.0*sin(time*3.14)\n               +sin(freqTime*8.0)*0.25*sin(1.0+time*3.14))*exp(-2.0*tt)\n               +cos(freqTime*4.+cos(freqTime*2.0)*3.0*sin(time*3.14+0.3))*exp(-2.0*tt)\n                )*exp(-1.0*tt) );}\n\n//sine wave with vibrato, nice lead (background).\nfloat sineVib(float time,int note,float speed,float arpVolume\n){note+=globalTranspose\n ;float baseFreq=1.\n ;float globalTime=0.\n ;float freq=base_a4*pow(2.0,float(note)/12.0)*baseFreq\n ;freq*=speed\n ;freq+=freq*step(mod(time,0.1),0.05)*arpVolume\n ;float vibratoDelay=.2//vibrato\n ;freq+=1.0+sin(time*20.0*speed)/pi*0.001*freq*step(0.0,time-vibratoDelay)\n ;float t=1.0-(time*1.0)\n ;t=max(t,0.)\n ;float duty=cos(time*2.0+globalTime*0.5)/pi//sqr duty wave\n ;duty=duty*.2+.8\n ;float f1=fract(t*freq)\n ;float f2=fract(duty+t*freq)\n ;float f=f1-f2\n ;f=clamp(f,-1.,1.)\n ;float t2=time*baseFreq\n ;f*=pow(max(0.,1.-(t2*1.)),1.5)\n ;f+=rand(time)*.2*pow(1.-t2,16.)//hihat\n ;return f;}\n\n\n//instrument testuing range, with  cycling 4x overlap and iDate randomizing sheet-seed over time\n//while somehow the note stays form a past seed. YAY.\n\n vec4 midi_freq(vec4 m){return 440.*pow(vec4(2),(m-69.)/12.);}\n\nfloat datesec(//cire issue is that iDate.w runs into very high numbers very fast\n){float interval =6.61/99.\n ;return iDate.z+floor(fract(iDate.w/interval)*interval)\n ;return 0.;}\n\nfloat TestInstrument4Times(vec4 freq, vec4 time){\n ;float c=0.\n ;for(int i=0;i<5;i++\n ){\n  ;c+=instrumentBanjo(freq[i],time[i])\n  ;};return c;}\nvec2 debugInstrument(float t//4 overlappign neighborhoods to debug an instrument quickly\n){t*=3.14\n ;vec4 f=vec4(0,1,2,3)\n  ;vec4 t4=t+vec4(0,1,2,3)\n ;vec4 r=dumbSequence(((.61+(f+5.))+datesec())*floor((t-f*7.)/4.)*4.)\n ;//yes,datesec() changes every second, and this sequence is still continuous over time\n ;r=mod(r*2.,62.)\n ;if(r.x<13.||r.x>55.)r.x=-999.//rather play inaudibl/silent frequencies than a very wide range.\n ;if(r.y< 7.||r.y>50.)r.y=-999.//this also fives timeslices semi--exclusive instrument-ranges.\n ;if(r.z< 5.||r.z>45.)r.z=-999.\n ;if(r.w< 3.||r.w>40.)r.w=-999.\n ;r=midi_freq(floor(r*2.)+22.)//optionally not a cocaphony \n ;//r=110.*(1.+f)+r*55.-110.//sans harmony\n ;vec2 c=vec2(TestInstrument4Times(r,fract(t4/4.)*4.))\n ;return c*.25;\n ;}\n\n\n//d adds a note of length [a]\n//this way of sequencing is made simple by not defining any end-points\n//which pretty much only works for harp(banjo\n#define D(a) b+=float(a);if(t>b)x=b;\n#define tint 0.144\n\n\nfloat F21(float t){float x=t,b=.0;\n D(36)D(2)D(2)D(20)D(2)D(16)D(6)D(2)D(226)\n ;return t-x;}\nfloat G21(float t){float x=t,b=.0;\n D(36)D(2)D(2)D(20)D(2)D(16)D(6)D(2)D(226)\n ;return t-x;}  \nfloat A21(float t){float x=t,b=.0;\n D(53)D(208)\n ;return t-x;}  \nfloat As21(float t){float x=t,b=.0;\n D(34)D(2)D(2)D(2)D(1)D(7)D(2)D(2)D(2)D(1)D(3)D(8)D(2)D(8)D(2)D(4)D(2)D(2)D(2)D(1)\n D(31)D(2)D(4)D(138)D(46)D(2)\n ;return t-x;}  \nfloat B21(float t){float x=t,b=.0;\n D(42)D(2)D(2)D(14)D(2)D(2)D(1)D(25)D(2)D(16)D(2)D(2)\n ;return t-x;}  \nfloat C31(float t){float x=t,b=.0;\n D(125) \n ;return t-x;}  \nfloat Cs31(float t){float x=t,b=.0;\n D(35)D(6)D(7)D(2)D(3)D(1)D(5)D(7)D(2)D(2)D(1)D(1)D(2)D(3)D(6)D(199)D(2)D(2)D(2)D(1)    \n ;return t-x;}  \nfloat D31(float t){float x=t,b=.0;\n D(120)D(2)D(4)D(132)D(1)D(5)D(42)D(2)\n ;return t-x;}         \nfloat E31(float t){float x=t,b=.0;\n D(0)D(2)D(1)D(2)D(1)D(2)D(1)D(1)D(1)D(1)D(2)D(1)D(2)D(1)D(2)D(1)D(1)D(1)D(1)D(2)\n D(1)D(2)D(1)D(2)D(1)D(3)D(2)D(2)D(2)D(2)D(2)D(1)D(5)D(3)D(5)D(2)D(2)D(12)D(2)D(6)\n D(2)D(2)D(2)D(2)D(2)D(1)D(1)D(2)D(5)D(3)D(2)D(2)D(2)D(3)D(3)D(6)D(1)D(136)D(9)D(2)\n D(2)D(2)D(1)D(17)D(2)D(2)D(2)D(1)D(11)\n ;return t-x;}\nfloat F31(float t){float x=t,b=.0;\n D(41)D(7)D(2)D(15)D(7)D(2)D(27)D(6)D(13)D(2)D(4)D(132)D(1)D(23)D(2)D(2)D(2)D(18)D(4)\n ;return t-x;}  \nfloat G31(float t){float x=t,b=.0;\n D(42)D(2)D(2)D(20)D(2)D(2)D(19)D(11)D(2)D(6)D(2)D(4)D(5)D(5)D(8)D(2)D(2)D(20)D(2)D(16)\n D(6)D(2)D(82)D(4)D(2)D(2)D(2)D(2)D(1)D(12)D(5)D(2)D(2)D(2)D(1)D(7)\n ;return t-x;}  \nfloat A31(float t){float x=t,b=.0;\n  D(47)D(24)D(19)D(2)D(2)D(2)D(2)D(3)D(11)D(37)D(120)D(13)D(2)D(2)D(2)D(18)\n ;return t-x;}  \nfloat As31(float t){float x=t,b=.0;\n  D(95)D(5)D(2)D(12)D(16)D(2)D(2)D(2)D(1)D(7)D(2)D(2)D(2)D(1)D(3)D(8)D(2)D(8)D(2)D(4)\n  D(2)D(2)D(2)D(1)D(31)D(2)D(4)D(2)D(2)D(12)D(1)D(1)D(30)D(2)D(2)D(3)D(12)D(5)D(2)D(2)D(3)\n ;return t-x;}  \nfloat C41(float t){float x=t,b=.0;\n  D(96)D(2)D(40)D(2)D(2)D(14)D(2)D(2)D(1)D(25)D(2)D(16)D(2)D(2)D(24)D(18)D(1)D(1)D(24)D(24)\n ;return t-x;}  \nfloat Cs41(float t){float x=t,b=.0;\n  D(131)D(6)D(7)D(2)D(3)D(1)D(5)D(7)D(2)D(2)D(1)D(1)D(2)D(3)D(6)D(47)D(2)\n ;return t-x;}  \nfloat D41(float t){float x=t,b=.0;\n  D(216)D(2)D(3)\n ;return t-x;}  \nfloat E41(float t){float x=t,b=.0;\n  D(132)D(2)D(2)D(2)D(2)D(2)D(1)D(5)D(3)D(5)D(2)D(2)D(12)D(2)D(6)D(2)D(2)D(2)D(2)D(2)\n  D(1)D(1)D(2)D(5)D(3)D(2)D(2)D(2)D(3)D(3)D(6)D(2)D(2)D(4)D(4)D(2)D(5)D(7)D(5)\n ;return t-x;}  \nfloat F41(float t){float x=t,b=.0;\n  D(137)D(7)D(2)D(15)D(7)D(2)D(27)D(6)D(13)D(2)D(8)\n ;return t-x;}  \nfloat G41(float t){float x=t,b=.0;\n  D(138)D(2)D(2)D(20)D(2)D(2)D(19)D(11)D(2)D(6)D(2)D(4)D(5)D(13)D(2)D(1)D(4)D(3)\n ;return t-x;}  \nfloat A41(float t){float x=t,b=.0;\n  D(143)D(24)D(19)D(2)D(2)D(2)D(2)D(3)D(11)D(24)D(14)D(4)\n ;return t-x;}  \nfloat As41(float t){float x=t,b=.0;\n  D(191)D(5)D(2)D(12)D(24)\n ;return t-x;}  \nfloat C51(float t){float x=t,b=.0;\n  D(192)D(2)D(52)\n ;return t-x;}  //i think i messed up the conversion a tiny bit, but only the highest or lowest pitch?\n\n//banj4h() is a cheesy fix to hide the silence before a first note\n#define banj4h(b) mix(b,vec4(999),step(b,vec4(0)))\n#define banj4(t,u,p,k0,k1,k2,k3) su(smoothstep(.1,-.1,abs(vec4(u.y*4.-.5)-p)+(banj4h(vec4(k0(t),k1(t),k2(t),k3(t)) )-1.)*.1))\n//float banj42(float t,vec2 u,vec4 p){vec4 c=vec4(0)\n// ;return su(smoothstep(.1,-.1,abs(vec4(u.y*4.-.5)-p)\n// +(banj4h(vec4(E31 (t+(u.x)),G31 (t+(u.x)),As31(t+(u.x)),E41 (t+(u.x))) )-1.)*.1));}\n\n\n\n\n\n#define ShowPianoSjheetOf(a,u,t,m)  a(u,t,m)\n\n\n\nfloat pirateLines(vec2 u,float t,vec4 m//paints sheet lines\n){float c=0.,sy=(m.y-.02)*2.\n ;t=t*6.94+35.*(u.x-.5)\n ;c+=banj4(t,vec2(0,u.y),vec4( 0, 1, 2, 3)*sy,F21 ,G21,A21 ,As21)//vec4 is position.y\n ;c+=banj4(t,vec2(0,u.y),vec4( 4, 5, 6, 7)*sy,B21 ,C31,Cs31,D31)//vec4 is position.y\n ;c+=banj4(t,vec2(0,u.y),vec4( 8, 9,10,11)*sy,E31 ,F31,G31 ,A31)//vec4 is position.y\n ;c+=banj4(t,vec2(0,u.y),vec4(12,13,14,15)*sy,As31,C41,Cs41,D41)//vec4 is position.y\n ;c+=banj4(t,vec2(0,u.y),vec4(16,17,18,19)*sy,E41 ,F41,G41 ,A41)//vec4 is position.y\n ;c+=banj4(t,vec2(0,u.y),vec4(20,20,21,21)*sy,As41,As41,C51,C51)*.5//vec4 is position.y\n ;//last one doubled and then halved, cause i am too lazy to define a fun that takes only 2...\n  //oh shit the key-labels are off by one, shit a semitone, but off by one label.\n ;return c;}\n//ShowPianoSjheetOf(pirateLines(u,t,m)\n\n#define instrument instrumentBanjo\nfloat doChannel1(float t\n){float y = 0.;\n ;t/=tint;  \n //y+=instrument(156.,tint*F21( t)); //156. is likely WRONG, i just guessed it after cipying over it.\n y+=instrument(174.,tint*G21( t));   \n y+=instrument(195.,tint*A21( t)); \n y+=instrument(220.,tint*As21(t)); \n y+=instrument(233.,tint*B21( t));\n y+=instrument(246.,tint*C31( t));        \n y+=instrument(261.,tint*Cs31(t));  \n y+=instrument(277.,tint*D31( t));  \n y+=instrument(293.,tint*E31( t));  \n y+=instrument(329.,tint*F31( t));  \n y+=instrument(349.,tint*G31( t));\n y+=instrument(391.,tint*A31( t));\n y+=instrument(440.,tint*As31(t));\n y+=instrument(466.,tint*C41( t));\n y+=instrument(523.,tint*Cs41(t));\n y+=instrument(554.,tint*D41( t));\n y+=instrument(587.,tint*E41( t));\n y+=instrument(659.,tint*F41( t));\n y+=instrument(698.,tint*G41( t));\n y+=instrument(783.,tint*A41( t));\n y+=instrument(880.,tint*As41(t));\n y+=instrument(932.,tint*C51( t));return y;}\n\n\n\n//float 2(float t){float x=t,b=.0;  \n\n// ;return t-x;}   \n\nfloat D02(float t){float x=t,b=.0;  \n D(24)D(6)D(3)\n ;return t-x;}            \nfloat F02(float t){float x=t,b=.0;  \n D(66)D(2)D(1)D(2)D(91)D(2)D(1)D(2)\n ;return t-x;}  \nfloat G02(float t){float x=t,b=.0;  \n D(96)D(2)D(1)D(2)D(91)D(2)D(1)D(2)D(49)D(2)D(1)D(2)D(1)D(2)D(1)D(2)\n ;return t-x;}    \nfloat A02(float t){float x=t,b=.0; \n D(48)D(2)D(1)D(2)D(22)D(2)D(43)D(2)D(1)D(2)D(1)D(2)D(1)D(2)D(13)D(2)D(1)D(2)D(22)D(2)\n D(43)D(2)D(1)D(2)D(13)D(2)D(1)D(2)D(1)D(2)D(1)D(2)D(13)D(2)D(1)D(2)D(1)D(2)D(1)D(2)\n D(37)D(2)D(1)D(2)\n ;return t-x;}   \nfloat as02(float t){float x=t,b=.0;  \n D(42)D(2)D(1)D(2)D(13)D(2)D(1)D(2)D(25)D(2)D(1)D(2)D(13)D(2)D(1)D(2)D(25)D(2)D(1)D(2)\n D(13)D(2)D(1)D(2)D(25)D(2)D(1)D(2)D(13)D(2)D(1)D(2)D(23)                 \n ;return t-x;}                   \nfloat C12(float t){float x=t,b=.0;  \n D(41)D(31)D(2)D(63)D(31)D(2)D(56)D(2)D(2)D(52)D(2)D(1)D(2)                \n ;return t-x;}                   \nfloat D12(float t){float x=t,b=.0; \n D(24)D(6)D(3)D(3)D(2)D(1)D(15)D(2)D(1)D(2)D(19)D(2)D(1)D(2)D(1)D(2)D(1)D(2)D(13)D(2)\n D(1)D(2)D(7)D(2)D(1)D(2)D(13)D(2)D(1)D(15)D(2)D(1)D(2)D(19)D(2)D(1)D(2)D(1)D(2)D(1)\n D(2)D(13)D(2)D(1)D(2)D(7)D(2)D(1)D(2)D(7)D(2)D(46)D(2)D(1)D(2)D(1)D(2)D(1)D(1)D(1)\n D(13)D(2)D(1)D(2)D(1)D(2)D(1)D(1)D(1)D(7)\n ;return t-x;}  \nfloat F12(float t){float x=t,b=.0;  \n D(66)D(2)D(1)D(2)D(91)D(2)D(1)D(2)D(121)D(2)D(1)D(1)D(1)\n ;return t-x;}                   \nfloat G12(float t){float x=t,b=.0;  \n D(96)D(2)D(1)D(2)D(91)D(2)D(1)D(2)D(49)D(2)D(1)D(2)D(1)D(2)D(1)D(2)                 \n ;return t-x;}                   \nfloat A12(float t){float x=t,b=.0;  \n D(48)D(2)D(1)D(2)D(22)D(2)D(43)D(2)D(1)D(2)D(1)D(2)D(1)D(2)D(13)D(2)D(1)D(2)D(22)D(2)\n D(43)D(2)D(1)D(2)D(13)D(2)D(1)D(2)D(1)D(2)D(1)D(2)D(13)D(2)D(1)D(2)D(1)D(2)D(1)D(2)\n D(37)D(2)D(1)D(2)\n ;return t-x;}           \nfloat As12(float t){float x=t,b=.0;  \n  D(42)D(2)D(1)D(2)D(13)D(2)D(1)D(2)D(25)D(2)D(1)D(2)D(13)D(2)D(1)D(2)D(25)D(2)D(1)D(2)\n  D(13)D(2)D(1)D(2)D(25)D(2)D(1)D(2)D(13)D(2)D(1)D(2)D(23)\n ;return t-x;}   \nfloat C22(float t){float x=t,b=.0;  \n D(41)D(31)D(2)D(63)D(31)D(2)D(56)D(2)D(2)D(52)D(2)D(1)D(2)\n ;return t-x;}   \nfloat D22(float t){float x=t,b=.0;  \n  D(36)D(2)D(1)D(15)D(2)D(1)D(2)D(19)D(2)D(1)D(2)D(1)D(2)D(1)D(2)D(13)D(2)D(1)D(2)D(7)\n  D(2)D(1)D(2)D(13)D(2)D(1)D(15)D(2)D(1)D(2)D(19)D(2)D(1)D(2)D(1)D(2)D(1)D(2)D(13)D(2)\n  D(1)D(2)D(7)D(2)D(1)D(2)D(7)D(2)D(46)D(2)D(1)D(2)D(1)D(2)D(1)D(1)D(1)D(13)D(2)D(1)\n  D(2)D(1)D(2)D(1)D(1)D(1)D(7)\n ;return t-x;}   \nfloat F22(float t){float x=t,b=.0;  \n D(288)D(2)D(1)D(1)D(1)\n ;return t-x;}   \n\n/*\n  y += instrument( 36.,tint*D02 (t));  \n  y += instrument( 43.,tint*F02 (t)); \n  y += instrument( 48.,tint*G02 (t)); \n  y += instrument( 55.,tint*A02 (t)); \n\n  y += instrument( 58.,tint*as02(t)); \n  y += instrument( 65.,tint*C12 (t)); \n  y += instrument( 73.,tint*D12 (t)); \n  y += instrument( 87.,tint*F12 (t)); \n\n  y += instrument( 97.,tint*G12 (t));  \n  y += instrument(110.,tint*A12 (t)); \n  y += instrument(116.,tint*As12(t));  \n  y += instrument(130.,tint*C22 (t)); \n\n  y += instrument(146.,tint*D22 (t));\n  y += instrument(174.,tint*F22 (t));\n*/\nfloat pirateLinesB(vec2 u,float t,vec4 m//paints sheet lines\n){float c=0.,sy=(m.y-.02)*2.\n ;t=t*6.94+35.*(u.x-.5)\n ;c+=banj4(t,vec2(0,u.y),vec4( 0, 1, 2, 3)*sy,D02 ,F02,G02 ,A02)//vec4 is position.y\n ;c+=banj4(t,vec2(0,u.y),vec4( 4, 5, 6, 7)*sy,as02,C12,D12 ,F12)//vec4 is position.y\n ;c+=banj4(t,vec2(0,u.y),vec4( 8, 9,10,11)*sy,G12 ,A12,As12,A31)//vec4 is position.y\n ;c+=banj4(t,vec2(0,u.y),vec4(12,13,14,15)*sy,As31,C41,Cs41,C22)//vec4 is position.y\n ;c+=banj4(t,vec2(0,u.y),vec4(20,20,21,21)*sy,D22 ,D22,F22 ,F22)*.5//vec4 is position.y\n ;//last one doubled and then halved, cause i am too lazy to define a fun that takes only 2...\n  //oh shit the key-labels are off by one, shit a semitone, but off by one label.\n ;return c;}\n//ShowPianoSjheetOf(pirateLines(u,t,m)\n\n\nfloat doChannel2( float t\n){float x = 0.0;float y = 0.0;float b = 0.0\n ;//1 timeline per frequency is a bit excessive\n ;//, but makes temporal/sorted sense for performance.\n  t /= tint; \n  y += instrument( 36.,tint*D02 (t));  \n  y += instrument( 43.,tint*F02 (t)); \n  y += instrument( 48.,tint*G02 (t)); \n  y += instrument( 55.,tint*A02 (t)); \n  y += instrument( 58.,tint*as02(t)); \n  y += instrument( 65.,tint*C12 (t)); \n  y += instrument( 73.,tint*D12 (t)); \n  y += instrument( 87.,tint*F12 (t)); \n  y += instrument( 97.,tint*G12 (t));  \n  y += instrument(110.,tint*A12 (t)); \n  y += instrument(116.,tint*As12(t));  \n  y += instrument(130.,tint*C22 (t)); \n  y += instrument(146.,tint*D22 (t));\n  y += instrument(174.,tint*F22 (t));\n ;return y;}   \n\n\n\nvec2 demoSequencePolyphonyPirates(float time\n){time = mod( time, 60.0)\n ;vec2 y = vec2(0)\n ;y += vec2(.7,.3)*doChannel1(time)// main instrument\n ;y += vec2(.3,.7)*doChannel2(time)// secondary instrument\n ;y *= 0.1\n ;return y;}\n\n\n\nvec2 bass(float time, float tt, float note\n ){\n    if (tt<0.0)\n      return vec2(0.0);\n\n    float freqTime = 6.2831*time*n2f(note);\n    \n    return vec2(( sin(     freqTime\n                      +sin(freqTime)*7.0*exp(-2.0*tt)\n                     )+\n                  sin(     freqTime*2.0\n                      +cos(freqTime*2.0)*1.0*sin(time*3.14)\n                      +sin(freqTime*8.0)*0.25*sin(1.0+time*3.14)\n                    )*exp(-2.0*tt)+\n                  cos(     freqTime*4.0\n                      +cos(freqTime*2.0)*3.0*sin(time*3.14+0.3)\n                    )*exp(-2.0*tt)\n                )\n                \n                *exp(-1.0*tt) );\n}\n\nvec2 duhduh(float time, float tt)\n{\n   float bn = 0.0;\n   tt = mod(tt,48.0);\n   if (tt>=16.0)\n      if (tt>=40.0)\n         bn -= 5.0;\n      else\n         if (mod(tt,8.0)>=4.0)\n            bn -= 5.0;\n       \n   tt = mod(tt,8.0);\n   if (tt <4.0)\n     tt = mod(tt,2.0);\n   else\n     tt = mod(tt,4.0);\n   return bass(time,tt-3.0,bn+3.)+\n          bass(time,tt-2.0,bn+3.)+\n          bass(time,tt-1.0,bn+0.)+\n          bass(time,tt-0.0,bn+0.);\n}\n\nvec2 duhduh2(float time, float tt)\n{\n   float bn = 0.0;\n   tt = mod(tt,48.0);\n   if (tt>=16.0)\n      if (tt>=40.0)\n         bn -= 5.0;\n      else\n         if (mod(tt,8.0)>=4.0)\n            bn -= 5.0;\n       \n   int ti = int(mod(tt,8.0)/2.0);\n   tt = mod(tt,2.0);\n   if (ti == 0)\n     return bass(time,tt-0.83,bn+12.0)+\n            bass(time,tt-0.50,bn+12.0)+\n            bass(time,tt-0.17,bn+12.0);\n    \n   if (ti == 3)\n     return bass(time,tt-0.66,bn+15.)+\n            bass(time,tt-0.0,bn+15.);\n    \n   return bass(time,tt-0.66,bn+12.)+\n          bass(time,tt-0.0,bn+12.);\n}\n\n\n\nfloat getSample(float time, float tt, float FM//tt a mod(time(,b) sequenceTap\n){tt-=mod(tt,RES)\n ;float note1=sequenceThemDrWho(tt)\n ;if (note1<0.)return 0.\n ;float n=mix(note1,sequenceThemDrWho(tt+0.5), smoothstep(0.1,0.5,mod(tt,0.5)))\n ;n=PI2*n2f(n)*time\n ;return sin(n+FM*sin(n*2.033));}\n\nvec2 theramin(float time, float tt//tt is a mid(time) seuqence-context\n){tt = mod(tt,48.0)\n ;tt += 1.33\n ;float FM=0.\n ;if(tt>=32.)FM = PI2/2.\n ;float ta = mod(tt-RES/2.0,RES)-RES/2.0\n ;float h=RES/4.0//4.0/frequency;//\"halfsin\"\n ;if (abs(ta)<h)return vec2(mix(getSample(time,tt-RES/2.0,FM)\n                               ,getSample(time,tt+RES/2.0,FM)\n                               ,smoothstep(-h,h,ta)))\n ;return vec2(getSample(time,tt,FM));}\n\nfloat sequenceDrWho1(float t,float tt//only at half volume on the right channel\n){return clamp(duhduh(t,tt    ).x,-.8,.8)*1.3\n        +clamp(duhduh(t,tt-.33).x,-.5,.5)*1.4\n        +clamp(duhduh(t,tt-.66).x,-.3,.3)*2.;}\nfloat sequenceDrWho2(float t,float tt//only at half volume on the left channel\n){return clamp(duhduh2(t,tt    ).x,-.8,.8)*.3\n        +clamp(duhduh2(t,tt-.33).x,-.8,.8)*.2\n        +clamp(duhduh2(t,tt-.66).x,-.8,.8)*.1;}\nvec2 sequenceDrWho3(float t,float tt\n){return theramin(t,tt-0.75)*vec2(0.2,0.4)\n        +theramin(t,tt)*vec2(0.6,0.4)\n        +theramin(t,tt-0.506)*vec2(.4,.2)\n        +theramin(t,tt-1.00)*vec2(.1,.2);}\nvec2 DemoDrWho(float t\n){float tt=t*2.4\n ;vec2 r=vec2(0)\n ;//r+=sequenceDrWho1(t,tt)*vec2(1,.5)\n ;//r+=sequenceDrWho2(t,tt)*vec2(.5,1.)\n ;r+=sequenceDrWho3(t,tt) \n ;return r*.33;}\n\n\n\n\n//electric base guitar, electric shaver\nfloat GuitarElectricBase(float time,int note//https://www.shadertoy.com/view/XscXzn  ???\n){float t=max(1.-time,0.)\n ;float freq=110.*pow(2.,float(note)/12.0)*baseFreq*t//or is it time instead ot t?\n ;vec2 a=freq+vec2(0,u5(cos(time*4.)/pi))//duty sqare-wave\n ;a.x=clamp(a.x-a.y,-1.,1.)*pow(max(0.,1.-(time*2.)),3.)\n ;return a.x;}//https://www.shadertoy.com/view/XscXzn\n\n//bad chord dependency\n//instruments should be outside of chords?\nfloat strings(float t//this sounds just bad, oh it was just 5x too loud, DUH!\n){float c=0.\n ;vec4 h=mix(vec4(24,28,31,35),vec4(23,26,30,33),step(mod(t,8.),4.))//chord varies\n ;for (int i=0;i<5;i++){c+=rect(t*calcHertz(h[i]));}//4 key chord\n ;return c*drummyHull(t);\n ;}                         \n// Instruments from MusicBox2 shader by ztri\nvec2 tb303(vec3 k//https://www.shadertoy.com/view/MslSD2\n){float s = abs(sin(tune*0.7)+1.0)*0.3\n ;float a = pow(1.0-k.y,0.2)\n ;float f = pow(1.0-k.y,2.0)\n ;float osc = sin(k.x*4.40*tune*2.0)\n ;osc = pow(abs(osc),pow(2000.0,s+(f*0.8)))\n ;osc = clamp(osc*1.1,-1.0,1.0)*a\n ;return vec2(osc,osc)*0.3;}\nvec2 pad(vec3 k//https://www.shadertoy.com/view/MslSD2\n){float osc = 0.\n ;osc += smoothstep(0.0,0.4,sin(k.x*4.4*tune*8.0))\n ;osc += smoothstep(0.0,0.4,sin(k.x*4.4*tune*16.1))\n ;osc += smoothstep(0.0,0.4,sin(k.x*4.4*tune*15.9))\n ;osc = clamp(pow(osc,0.1),-1.0,1.0)\n ;osc = osc*smoothstep(1.0,0.0,k.y)\n ;return vec2(pow(osc,abs(sin(tune))),pow(osc,abs(cos(tune))))*.4;}\nvec2 piano(vec3 k//https://www.shadertoy.com/view/MslSD2\n){float osc = 0.0\n ;osc += sin(k.x*4.4*tune*4.0);\n    osc = clamp(pow(abs(osc),20.0),-1.0,1.0);\n    osc = osc*smoothstep(1.8,0.0,k.y);  \n    return vec2(osc*sin(k.z),osc*cos(k.z*2.0))*0.5; }\n//instrument demo\nvec2 debugInstruments(float t//https://www.shadertoy.com/view/XttfWn\n){vec2 c=vec2(0)\n ;c+=strings(t)*.2\n ;return c;}\n\n//__end__ instruments shiftable\n//_start_ sfx\n\n//https://www.shadertoy.com/view/4djSzR\n//lava bubbles = chaos*Hull\nfloat bubbles(float t, float p, float l, float ff//time,period,length\n){float c=floor(t/p)*p//this is NOT mod, but its semi-inverse\n ;t-=c+u5(sin(c*12.))*p*.8//interestring time folding!\n ;return \n //step(-.2,cos(c*199.0*l))//more code for less bubbles, seems like a dumb approach\n sin(ff*(5000.+cos(c*70.)*2000.)*(t+.1)*t)//lots of pingpong lines\n *(smoothstep(.0,.07*l,t)-smoothstep(.1*l,.2*l,t))//and a basic dumb hull\n ;}\nvec2 bubbles2(float t\n){vec3 p=1./(vec3(1,2,3)+.61)\n// ;return vec2(.9*bubbles(t   ,p.x,1.2,1.)\n //            +.1*bubbles(t+1.,p.y,.5,2.)\n  //           +.5*bubbles(t+2.,p.z,.7,1.))*.75;}//hard params here\n ;return vec2(0.9*bubbles(t,2.0,1.2,1.0)\n             +0.1*bubbles(t,0.5,0.5,2.0)\n             +0.2*bubbles(t,0.2,0.2,2.0))*0.75;}\n\n\nfloat fourier(float a){return .25*sin(a)+.25*sin(2.*a+.2)+.5*sin(4.*a+.3);}\nvec2 teslaCoil( float t//https://www.shadertoy.com/view/4lcXDM\n){float m=mod(t,15.)\n ;if (m<3.)return vec2(0)\n ;return vec2(4.*fourier(400.*t)// base wave\n *pow(fbm(20.*noise(40.*t)*t) //amplitude modulation\n ,2.))\n ;}\n\n\n//___end__ sfx\n//__start_ instruments-percussion\n\n//drums:\n//percussion\nfloat drum(float time \n){float freq=100.0*baseFreq\n ;float vol=.4\n ;float depth=4.\n ;float t=1.-(time*4.)\n ;t=max(t,0.)\n ;t=pow(t,depth)\n ;float f=cos(t*freq)/pi\n ;float t2=time*baseFreq\n ;f*=pow(1.0-t2,8.0)\n ;//f=ws(f,2.)\n ;f+=rand(time)*pow(1.0-t2,1464.0)*0.5\n ;return clamp(f*vol,-1.,1.);}//https://www.shadertoy.com/view/XscXzn\n//percussion\n//percussion bad cheap start //https://www.shadertoy.com/view/4l3GD2\nfloat bassDrum(float time//too digital.lacks timbre/echo\n){float f=fract(time)/3.*8.//https://www.shadertoy.com/view/4l3GD2\n ;return sin(time*(440.))*ma0(1.-f*8.)*2.;}\nfloat snereDrum(float t){float f=fract(t+.5);return rand(vec2(t*32.,0))*ma0(1.-f*4.);}\n\n//kick\nvec2 kick(vec3 k//https://www.shadertoy.com/view/MslSD2\n){float a = pow(1.0-k.y,1.0)\n ;float osc = sin(pow(a,5.0)*k.x)\n ;return vec2(smoothstep(-0.9,0.9,osc*pow(a,2.0)));}\n//percussion\nfloat kick(float time //https://www.shadertoy.com/view/MljGRd\n){float sinWave = sin(pow(time*1000.0,0.6));\n   const float fadeInTime = 0.00015;\n    float fadeIn = max(0.0,min(1.0,(time/fadeInTime)));    \n    const float fadeOutTime = 1.0;\n    float fadeOut = max(0.0,min(1.0,((fadeOutTime-time)/fadeOutTime)));\n    return sinWave*fadeIn*fadeOut;}\n\n//Hat\nfloat hiHat(float t){//if (drumExclusion(t)==0.)return 0.;\n ;return drumExclusion(t)*rand(vec2(t*32.,0))*ma0(1.-fract(t)*4.);}//noise\n//percussion\nvec2 hat(vec3 k\n){float n = fract(sin(k.x * tune * 110.082) * 19871.8972)\n ;float a = pow(1.0-k.y,1.0)\n ;float osc = clamp(n,-1.0,1.0)*pow(a,8.0+k.x*0.1)\n ;return vec2(osc*osc,osc)*0.4;}//.x is pianoKey    .y is [TimeSinceStart] .z is period \nfloat hihatClosed(float time //https://www.shadertoy.com/view/MljGRd\n){float sinWaveA = sin(pow(time*8700.0,0.99))\n ;float sinWaveB = sin(pow(time*7200.0,0.99))\n ;float sineFadeIn = max(0.0,min(1.0,(time/0.15)))\n ;float sineFadeOut = max(0.0,min(1.0,(1.0-(time))))\n ;float noiseWave = noise(time)\n ;float noiseFadeOut = max(0.0,min(1.0,(1.0-(time/0.75))))\n ;noiseFadeOut = pow(noiseFadeOut,2.0)\n ;return noiseWave*noiseFadeOut*0.5 + (sinWaveA+sinWaveB)*sineFadeIn*sineFadeOut*0.05\n ;}\n\n//Bell\n//percussion bell are perc, because they have a const dominant resonance.\nvec2 bell(float t,float f){t=fract(t);return vec2(sin(dot(TWOTAU,TAU)*f*t)*exp(-3.0*t) );} \n//percussion bells are perc, because they have a const dominant resonance.\nfloat bx_cos(float a){return clamp(abs(mod(a,8.0)-4.0)-2.0,-1.0,1.0);}\nfloat tx_cos(float a){return abs(mod(a,4.0)-2.0)-1.0;}\n#define Cos tx_cos\nvec2 bellSqua(float t//cosine bell with overtone loop and a tripple canon modulo sequence without harmony.\n){float f=floor(t*2.)//https://www.shadertoy.com/view/lstXR8\n ;float n=dumbSequence(f)+dumbSequence(f*2.61+1.)+dumbSequence(f*3.61+2.)\n ;float o=0.,a=t*660.,r=1.,scale=n//step site for overtone loop.\n ;for(int i=0;i<5;i++//overtones\n ){o+=Cos(a)*r\n  ;a*=scale;r/=scale\n  ;a+=Cos(t*60.)*.01;}\n ;float bt=fract(t*2.);\n ;o*=clamp(bt*100.,0.,0.5)*(1.-bt)\n ;o=clamp(o,-1.0,1.0)\n ;return vec2(o);}    \n//percussion\n//percussion snare\nfloat snare(float time //https://www.shadertoy.com/view/MljGRd\n){float sinWave = sin(pow(time*1000.0,0.7))\n ;float sineFadeIn = max(0.0,min(1.0,(time/0.00015)))\n ;float sineFadeOut = max(0.0,min(1.0,(1.0-(time/0.25))))\n ;float noiseWave = noise(time)\n ;float noiseFadeIn = max(0.0,min(1.0,(time/0.00015)))\n ;float noiseFadeOut = max(0.0,min(1.0,(1.0-(time/0.25))))\n ;return noiseWave*noiseFadeIn*noiseFadeOut*0.75 + sinWave*sineFadeIn*sineFadeOut*0.5;}\n//percussion\n//percussion instrument elemet of //https://www.shadertoy.com/view/XscXzn\nfloat ws(float x,float a){return x*(abs(x)+a)/(x*x+(a-1.)*abs(x)+1.);}\n//percussion Drum Snare (high pitch)\nfloat Bounchy(float x //https://www.shadertoy.com/view/XscXzn\n){float freq=660.*baseFreq\n ;float c=0.\n ;const int  num=11\n ;for(int i=0;i<num;i++\n ){float time=x-float(i)*(.09+float(i)*0.01)\n  ;if(time<0.)continue\n  ;float t=1.-(time*1.)\n  ;t=max(t,0.)\n  ;t=pow(t,2.)\n  ;float f=sin(t*freq)/pi\n  ;f=ws(f,2.9)\n  ;t=time*baseFreq\n  ;f*=pow(max(0.,1.-(t*6.)),4.)\n  ;f=ws(f+rand(time)*.4*pow(1.-t,20.),1.9)\n  ;c+=clamp(f,-1.,1.)*.7/float(1+(i*i*4))\n ;}return c*.35;}\nfloat clap(vec3 k //https://www.shadertoy.com/view/MslSD2\n){float n = fract(sin(tune * 110.082 * k.x) * 19871.8972)\n ;float a = pow(1.0-k.y,1.0)\n ;if (k.x>0.)return (sin(n*a)*a+(sin(a*8.4*k.x)*pow(a,8.0-k.x*0.02)))\n ;return 0.;}\n//percussion\n//percussion-sequence alias to 2 percussion in truments\n#define BD(d)   c+=drum(TT(d));\n#define SN(d)   c+=Bounchy(TT(d));\nfloat drums(float t\n){float c=0.\n ;float n=0.,b=0.,x=0.\n ;float time=mod(t,4.0)\n ;      if(time<1.){BD(.0);SN(.5 );BD(.75)\n ;}else if(time<2.){BD(.0);SN(.5 )\n ;}else if(time<3.){BD(.0);SN(.5 );BD(.75)\n ;}else if(time<4.){BD(.0);SN(.25);SN(.5 );SN(.75)\n ;}return c;}//https://www.shadertoy.com/view/XscXzn     \n//percussion-sequence\nvec2 debugDrums(float t//https://www.shadertoy.com/view/XttfWn\n){vec2 c=vec2(0)\n ;c+=Bounchy(fract(t))\n ;//+=hiHat(t)\n ;//c+=hiHat(t)*.5\n ;//c+=snereDrum(t)*.5\n ;//c+=bassDrum(t)*.5\n ;return c;}\n\n//__end___ instruments-percussion\n//_start__ sequences that inclcude instruments\n\n//- this is BAD style, instead a sequence should be fed to an instrument function!  \n//sequence\n#define TT(d) mod(mod(time,1.0)-d,1.0)\n#define LD(d,n)   c+=sineVib(TT(d),n,1./speed,arpVolume)*step(0.0,time-d)\nfloat lead(float t,float arpVolume\n){float c=0.,speed=.5,time=mod(t*speed,32.0),f=0.\n ;int i=0\n ;if(time>8.0 && time<16.0)time-=8.0\n ;if(time<1.0){LD(0.0,i);LD(0.5,i+2)\n ;}else if(time<2.0){time=fract(time);LD(0.0,i+3);LD(0.125*1.0,i+5);LD(0.125*3.0,i);LD(0.125*5.0,i-2)\n ;}else if(time<3.){time=fract(time);LD(0.0,i);LD(0.5,i+2)\n ;}else if(time<4.){time=fract(time);LD(.0,i+3);LD(.125*1.,i+5);LD(.125*3.,i+10);LD(.125*5.,i+7)\n ;}else if(time<5.0){time=fract(time);LD(0.0,i);LD(0.5,i+2)\n ;}else if(time<6.0){time=fract(time);LD(0.0,i+3);LD(0.125*1.0,i+5);LD(0.125*3.0,i);LD(0.125*5.0,i-2)\n ;}else if(time<7.0){time=fract(time);LD(0.0,i);LD(0.5,i-2)\n ;}else if(time<8.0){time=fract(time);i=-12;LD(0.0,i+7);LD(0.125*1.0,i+10);LD(0.125*2.0,i+5)\n  ;LD(0.125*3.0,i+7)\n ;}return c;}\nvec2 synthWave2(float t){t=mod(t,32.);return vec2(lead(t,.0));}\n//sequence, this crashes opengl, when used with a slow dft and complex arp-ed instruments:\n#define k0 0.\n#define k12 19.2\n#define k1 38.4\n#define k2 76.8\n#define h0 0.\n#define h1 32.7\n#define p0 0.\n// guitar\n#define F10 349. / 4.4\n#define A8s 233. / 4.4\n//#define A8 175. / 8.\n// bass\n#define No\t0.\n#define Eb 155.6 / 4.4\n#define Gg    98. / 4.4\n#define Bb  58.3 / 4.4\n//this is why you wrap sequences in instruments and not instruments in sequences\nfloat bass(float t//sequence with dull instrument\n){t=mod(t,8.)\n ;if(t<2.0)       return rect(t*calcHertz(0.))\n ;if(t<3.5&&3.0<t)return rect(t*calcHertz(0.))//todo frame this!\n ;if(t<4.0)       return rect(t*calcHertz(12.))\n ;if(t<6.0)       return rect(t*calcHertz(11.))\n ;if(t<8.0)       return rect(t*calcHertz(-1.))\n ;return 0.;}\nvec3 p8(float p,mat4 a//this works for pat16 and pat8, instead of many floats, it  now takes a matrix.\n){float t = fract(p/16.)\n ;vec2 i=vec2(1,4)*(floor(t*4.))\n ;return vec3(a[int(i.x)][int(floor(t*16.)-i.y)],fract(t)-1.,p);}//the -1 may actually just be halfspace overlap!\nvec3 pat8(float t,mat4 a\n){vec2 i=vec2(mod(t,4.),0)\n ;return vec3(a[int(step(3.,fract(t/8.)*8.))][int(i.x)],fract(fract(t/8.)*8.),t);}\nvec3 pat8(float t,float p1,float p2,float p3,float p4,float p5,float p6,float p7,float p8\n){t=mod(t,8.)\n ;return pat8(t,mat4(p1,p2,p3,p4,p5,p6,p7,p8,0,0,0,0,0,0,0,0));}\n //;if(t>7.)return vec3(p8,fract(t),t);if(t>6.)return vec3(p7,fract(t),t)\n //;if(t>5.)return vec3(p6,fract(t),t);if(t>4.)return vec3(p5,fract(t),t)\n //;if(t>3.)return vec3(p4,fract(t),t);if(t>2.)return vec3(p3,fract(t),t)\n //;if(t>1.)return vec3(p2,fract(t),t);if(t>0.)return vec3(p1,fract(t),t);return vec3(0.);}\nvec2 Play2(float time\n){vec2 snd = vec2(0.)\n ;tempo = time * 4.6\n ;tune=mod(time, 8.0); // * 1.0\n ;if (tempo < 24.0\n ){snd += 0.25*hat(pat8(tempo,mat4(1.,1.,1.,1.,1.,1.,1.,1.,0,0,0,0,0,0,0,0)))\n  ;//snd +=     clap(pat8(tempo,mat4(k12,k12,k0,k0, k12,k0,k0,k0,0,0,0,0,0,0,0,0)))\n  ;//snd += 0.5*kick(pat8(tempo,mat4(k0,k0,k1,k1, k0,k0,k1,k1,0,0,0,0,0,0,0,0)))\n ;}else if (tempo >= 24.0 && tempo < 28.\n ){//snd += 0.25*hat(pat8(tempo,mat4(h1,h1,h1,h1, h1,h1,h1,h1,0,0,0,0,0,0,0,0)))\n  ;//snd +=     clap(pat8(tempo,mat4(k12,k12,k0,k0, k12,k0,k0,k0,0,0,0,0,0,0,0,0)))\n  ;//snd += 0.5*kick(pat8(tempo,mat4(k0,k0,k1,k1, k0,k0,k1,k1,0,0,0,0,0,0,0,0)))\n ;}else if ((tempo >= 28.0) && (tempo < 32.)\n ){//snd +=     clap(pat8(tempo,mat4(k12,k12,k12,k12, k0,k0,k0,k0,0,0,0,0,0,0,0,0)))\n  //;snd +=     clap(pat8(2.*tempo,mat4(k12,k12,k12,k12, k0,k0,k0,k0,0,0,0,0,0,0,0,0)));\n  //;snd += 0.5*kick(pat8(2.*tempo,mat4(k0,k0,k0,k0, k1,k1,k1,k1,0,0,0,0,0,0,0,0)))\n ;}else{/*\n        snd += 0.25*hat(pat16(tempo, h1,h1,h1,h1, h1,h1,h1,h1, h1,h1,h1,h1, h1,h1,h1,h1));\n\t    snd +=     clap(pat16(tempo, k0,k0,k12,k0, k0,k0,k12,k0, k0,k0,k12,k0, k0,k0,k12,k12));\n        snd += 0.5*kick(pat16(tempo, k1,k1,k0,k0, k1,k1,k0,k0, k1,k1,k0,k1, k0,k1,k0,k0));\n        float mt = mod(tempo, 32.);\n        if (mt < 16.) snd+=tb303(pat16(mt, Eb,No,Eb,Eb, Eb,Eb,Eb,Eb, G,No,G,G, No,G,G,G));\n        else\t\t  snd+=tb303(pat16(mt, Bb,No,Bb,Bb, Bb,Bb,Bb,Bb, G,No,G,G, No,G,G,G));\n        if (tempo>96.)snd+=.5*pad(pat16(tempo, F10,No,A8s,No, F10,No,A8s,No, F10,A8s,No,F10, No,No,A8s,No));\n        /**/\n }return snd * smoothstep(0.0,0.5,time) * smoothstep(60.0,59.0,time);}\n//#define A8 175. / 8.\n#define No\t0.\nvec2 Play(float time\n ){vec2 snd = vec2(0.)\n  ;tempo = time * 4.6\n  ;tune  = mod(time, 8.0); // * 1.0\n  ;snd += 0.5*pad(p8(tempo,mat4(F10,No,A8s,No, F10,No,A8s,No, F10,A8s,No,F10, No,No,A8s,No)/4.4))\n  ;return snd * smoothstep(0.0,0.5,time) * smoothstep(60.0,59.0,time);}\n//\t    snd += 0.5*pad(pat16(tempo, F10,No,A8s,No, F10,No,A8s,No, F10,A8s,No,F10, No,No,A8s,No));\nvec2 DecentBase(float t\n){vec2 c=vec2(0)\n ;return Play2(t)\n ;t=mod(t,16.)\n ;float p = t *5.;//period length\n ;//c+=vec2(clap(pat8(p, 19.,29.,0.,0., 19.,0.,15.,13.)))\n ;//c+=vec2(clap(p8(p,mat4(20,22,0,26,28,30,32,34,0,0,0,0,0,0,0,0))))\n ;//c+pad(p8(p,mat4(349,349,0,349,349,349,32,34,0,0,0,0,0,0,0,0)/4.4))\n ;//c+0.5*pad(pat16(tempo, 349.,0.,233.,0., 349.,0.,233.,0., 349.,233.,0.,349., 0.,0.,233.,0.)/5.);\n ;//c+0.5*pad(p8(tempo, mat4(349.,0.,233.,0., 349.,0.,233.,0., 349.,233.,0.,349., 0.,0.,233.,0.))/5.);\n     //piano(vec3(11,t,5.))\n ;return c;}\n//sequence          \nvec2 synthWave(float t//https://www.shadertoy.com/view/MdjXWc\n){bool do_reverb = mod(t, 8.0) > 4.0\n ;float m = mod(t, 2.0)\n ;vec2 f=cs(t-m)\n ;float f0 =220.*cos(t-m)+880.//FM over time makes it easier to debug timing.\n ;f0+=cos(2.*t)*440.\n     // this cos()  illustrates the reverb in the dft(), as cos() breaks some symmetry ofer time.\n ;vec2 w = vec2(co2p(m * f0) * exp(-m * 2.5))\n #ifdef doReverb\n ;vec2 r=lpnoise(m, 100.)\n        +lpnoise(m, 550.)*.2\n        +lpnoise(m,1050.)*.1*exp(-t*5.)//3 octaves of overtones.\n ;float a=exp(-m*2.)//exponential falloff for reverb\n ;w+=(co2p(m*f0+r*.1)-co2p(m*f0))*a//differential of 2 offset samples. pigmentation-interferrence.\n #endif\n ;w*=1.-exp(-m*800.)//instrument falloff hull\n ;return w;}\n\n\n\n//___end__ sequences that inclcude instruments\n//_start__ dump\n\n\n\n\n\n\n    \n\n\n\n    \n\n\n\n                          \n\n                \n\n                          \nvec2 debugCompositionB(float t//this composition is a nice rythmic backdrop\n){float f=fract(t)\n ;vec2 c=vec2(0)\n ;c+=debugDrums(t)\n ;c+=strings(t)*.2\n ;c+=bubbles2(t*2.)*.2//bubbles are in 3 golden ratio intervals.\n ;c+=bellSqua(t)\n ;c+=bell(t,220.-cos(f-t)*110.)*.2\n ;c+=synthWave(t)*.2\n ;return c\n ;}\n                          \n\n                          \n\n\n\n\n//this is a maess of namespace conflicts \n//...and very different approaches to very similar things.\n//just look at all the ways they define a rotation:\n//which leads to my conclusion:\n//most people have no clue what they are doing,\n//...just by looking at their low efficiency.\n\n\n\n\n//instrument krakenSynth\nfloat krakenSynth(int note, float time, float octave, float sawTweak//earthbound sfx \n){float baseFreq = noteFreq(note)\n ;float sinFreq = baseFreq*pow(2.0,octave+2.0)\n ;float sawFreq = baseFreq*pow(2.0,octave-3.0-sawTweak)\n ;float sinWave = cos(6.2831*time*sinFreq)\n ;float sawWave = 1.0-mod(time*sawFreq,1.0)\n ;sawWave = pow(sawWave,8.0)\n ;return sawWave*sinWave - sawWave; }\n\n//instrument sequence that contains instrument-krakenSynth()\nfloat krakenLead(float songTime\n){float beatNum =songTime/beatLength\n ;float beatStep=mod(floor(beatNum),32.)\n ;if(fract(beatNum)>=.68)return 0.//beat filter\n ;float barStep=floor(beatNum/32.)\n ;float triplet=floor(beatStep/3.)\n ;float withinTriplet = mod(beatStep,3.0)\n ;if (beatStep >= 16.0\n ){triplet = 5.0-floor((beatStep-16.0)/3.0)\n  ;withinTriplet = mod(beatStep-16.0,3.0);}\n ;if (beatStep >= 29.0)withinTriplet++\n ;int curNote=3\n ;if((barStep>0.)&&(mod(barStep,2.0)==0.0)) curNote += 4\n ;float octave = -triplet\n ;if(withinTriplet == 2.)octave++\n ;return krakenSynth(curNote,mod(songTime,beatLength),octave,-triplet)\n ;}\n\n\nfloat bassSynth(int note, float time){    \n    const float noteLength = 0.5;    \n    if (time > noteLength) return 0.0;    \n    float baseFreq = 6.2831*time*noteFreq(note);    \n    float fadeIn = 1.0-pow(1.0-(time/noteLength),32.0);\n    float fadeOut = 1.0-pow(time/noteLength,8.0);\n     return (\n        sin(baseFreq*pow(2.0,-6.0))*1.5 +\n        sin(baseFreq*pow(2.0,-5.0))*0.5 + \n        sin(baseFreq*pow(2.0,-4.0))*0.05\n    )*fadeIn*fadeOut;}\n\nfloat krakenBass(float songTime){    \n    // this redundancy isn't great but whatev\n    float beatNum = songTime/beatLength;\n    float beatStep = mod(floor(beatNum),8.0);//DIFFERENT BAR LENGTH FOR BASSLINE\n    float barStep = mod(floor(beatNum/8.0),4.0);\n    if ( beatStep == 3.0 && barStep < 2.0) return 0.0;\n    if ( beatStep == 6.0 && barStep < 3.0) return 0.0;\n    if ( beatStep == 7.0 && barStep == 3.0) return 0.0;    \n    int bassNote = (mod(floor(beatNum/32.0),2.0) == 0.0) ? 8 : 4 ;    \n    return bassSynth(bassNote, mod(beatNum,1.0));}\n\n\nfloat wailSynth(int note, float time){    \n    const float noteEnd = 32.0;\n    const float noteStart = 4.0;    \n    float noteFrac = max(0.0,min(1.0,(time-noteStart)/(noteEnd-noteStart)));\n    float fadeIn = pow(noteFrac,2.0);\n    float fadeOut = 1.0-(pow(noteFrac,2.0));    \n    float baseFreq = 6.2831*time*noteFreq(note)*0.25;\n    baseFreq += sin(time*4.5)*3.0;    \n    return (\n        sin(baseFreq)+\n        sin(baseFreq*3.0)+\n        sin(baseFreq*4.0)*0.75\n    )*fadeIn*fadeOut*0.5;}\n\nfloat krakenWail(float songTime){    \n    float beatNum = songTime/beatLength;    \n    int wailNote = (mod(floor(beatNum/32.0),2.0) == 0.0) ? 2 : 3;    \n    return wailSynth(wailNote, mod(beatNum,32.0));    }\n\n\n\n\n//hull\nfloat fadeIn(float t,float e){float f=sat(t/e);return f*f;}\nfloat fadeOut(float s,float e,float t){return 1.-fadeIn(t-s,e-s);}//earthbound fadeout\nfloat fadeOut4(float s,float e,float t//earthbound fadeout\n){float f=sat((t-s)/(e-s));return 1.-f*f*f*f;}\n\nfloat hihatOpen(float time\n){float noiseVol\n ;float sineVolA\n ;float sineVolB\n ;if (time < 0.125\n ){noiseVol = 2.0\n  ;sineVolA = 0.1;\n   sineVolB = 0.15;        \n    } else if (time < 1.0) {        \n        noiseVol = 0.6;        \n        sineVolA = 0.1;\n        sineVolB = 0.15;        \n    } else if (time < 2.0) {        \n        noiseVol = max(0.0,min(1.0,(2.0-(time*1.0))));\n        noiseVol = pow(1.0-noiseVol,1.0);\n        noiseVol *= 0.1;        \n        sineVolA = max(0.0,min(1.0,(2.0-(time*0.5))));\n        sineVolA = 1.0-pow(1.0-sineVolA,1.0);\n        sineVolA *= 0.0125;        \n        sineVolB = sineVolA*1.5;        \n    } else return 0.0\n   ;float mi = 0.\n   ;mi += noise(time)*noiseVol\n   ;mi += sin(time*6300.0) * sineVolA\n   ;mi += sin(time*7200.0) * sineVolB\n   ;return mi;}\n\nvec2 EarthBoundBattleIntro(float time,float introEndTime//no idea how there is suddenly a fadein envelope.\n){vec2 mi=vec2(0)\n  ;for(float i=0.; i<3.;i++//3 echos\n  ){float ep=time-i*.03//echo phase\n   ;mi+=((introHorn(-4,ep)*pan(-.6))\n        +(introHorn( 3,ep)*pan(-.2))\n        +(introHorn( 5,ep)*pan( .2))\n        +(introHorn(10,ep)*pan( .6))\n        +(introHorn(14,ep)*.5*pan(.0)))*.2*(1.-(i/3.));}        \n  ;float volEnv = u5(cos(pow(time*0.5,0.8)*pi*2.))\n  ;const float volEnvMin = 0.3\n  ;volEnv = volEnv*(1.0-volEnvMin)+volEnvMin\n  //;float fadeInEnd =  introEndTime+ 0.3\n // ;float fadeIn = max(0.0,min(1.0,(time)/(fadeInEnd)))      \n // ;fadeIn = 1.0-pow(1.0-fadeIn,2.0)\n  ;return mi*volEnv*fadeOut4(introEndTime-.45,introEndTime-.1, time)\n      *fadeIn(time,0.3)\n      ;}\n\n\nvec2 EarthBoundBattle(float time,float introEndTime\n){float songTime=time-introEndTime\n ;float mi=0.\n ;float beatNum = songTime/beatLength\n ;float barStep  = floor(beatNum/32.0)\n ;float beatStep = fract(floor(beatNum)/32.)*32.\n ;if(barStep==0.)mi+=krakenLead(songTime)\n ;else           mi+=krakenLead(songTime)+krakenLead(songTime-0.1)*0.3\n ;if (barStep>0.\n ){if (barStep==1.\n  ){if(beatStep<28.)mi+=kick(fract(beatNum/4.)*4.)*1.5\n   ;else            mi+=kick(fract(beatNum))*1.5\n   ;float snareHatBeat\n   ;float snareHatVol\n   ;if(beatStep<=24.\n   ){snareHatBeat=fract(beatNum/2.)*2.\n    ;if (fract(beatStep/8.)*8.>=4.)snareHatBeat=mod(beatNum+1.,2.)\n    ;snareHatVol=1.\n   ;}else{\n    ;snareHatBeat=mod(beatNum,1.0)\n    ;snareHatVol=1.25+.5*((beatStep-24.)/8.)\n   ;}\n   ;mi += snare(snareHatBeat)*snareHatVol\n   ;mi += hihatClosed(snareHatBeat)*0.5*snareHatVol\n  ;}else\n   {float beatStepHalf=mod(beatStep,16.0)\n   ;if(any(equal(vec4(beatStepHalf),vec4(0,8 ,10,14)))||beatStep==21.)mi+=kick (mod(beatNum,1.))*1.5\n   ;if(any(equal(vec4(beatStepHalf),vec4(4,7 , 9,12)))               )mi+=snare(mod(beatNum,1.))*1.5\n   ;if(any(equal(vec3(beatStepHalf),vec3(3,11,13   )))               )mi+=snare(mod(beatNum,1.))*.5\n   ;float hihatBeatNum = beatNum-2.\n   ;if(fract(floor(beatStep/2.)/8.)*8.<=4.)hihatBeatNum+=2.\n   ;mi+=hihatOpen(fract(hihatBeatNum/4.)*4.)*1.3\n   ;mi+=krakenBass(songTime)*1.15\n   ;mi+=krakenWail(songTime)*1.8//made louder by ollj\n   ;mi+=krakenWail(songTime-0.1)*2.//made louder by ollj\n ;}}\n ;return vec2(mi)*.3*fadeOut(128.,128.+64.,beatNum);}//https://www.shadertoy.com/view/MljGRd\n    \n\n\nvec2 DemoEarthBoundBattle(float time//sequence is quite \"noisy\" ==discontinuous\n){const float introEndTime=4.\n ;time=mod(time,30.)\n ;if (time<0.)return vec2(0)\n ;if (time<introEndTime){return EarthBoundBattleIntro(time,introEndTime)\n ;}else return EarthBoundBattle(time,introEndTime);}\n\n\n\n\n\n\n\n\n\n\n                          \n\n\n//bubble noise  //n += note(C4, m, 0.0, 2.0, time);\nfloat noteBubble(float hz, int type, float s, float d, float t) {\n    float f=0.4;\n    s *= f;\n    d *= f;\n    if(t >= s && t <= s+d) {\n        t -= s;\n        float rt = t;\n\t\tt *= CON;\n    \tif(type == 1) {\n            rt = pow(rt+1.0,10.0);\n            if(rt < 1.0) {\n                rt = 1.0;\n            }\n    \t\treturn (sin(t*hz)/rt);\n        } else if(type == 2) {\n            float n = sin(t*hz);\n            n *= fract(rt*hz);\n            return n;\n        } else if(type == 3) {\n            t += sin(t*5.0)*0.005;\n            float n = sin(t*hz);\n            return n;\n        } else if(type == 4) {\n            t *= rt*4.0+0.5;\n        \tfloat n = sin(t*hz);\n            rt = pow(rt*4.0+0.5,20.0);\n            if(rt < 1.0) {\n                rt = 1.0;\n            }\n            return n/rt;\n        }}}//https://www.shadertoy.com/view/XdScDy\n\n\n\n\n//sfx\nfloat collisBall(float s,float t//start,time;    //https://www.shadertoy.com/view/MtSXR1\n){t-=s;return clamp(sin(t*(0.18-t)*10000.0)*exp(t*-50.)*3.,-.4,.4);}\n//sfx\nfloat explosionSound(float time//https://www.shadertoy.com/view/4l2GzR\n){if (time>=0.5 || time<=0.0)return 0.\n ;float freq = 1000.0 * (1.0-time*2.0)\n ;float freqintegrated = 1000.0 * (-time*time*1.0+time)\n ;float r=noize(float(int(freqintegrated)))\n ;//r+=fract(freqintegrated)>0.5 ? -0.2 : 0.2\n ;return r;}\n\n\n\n\n\n\n//hull adsr(); time, vec4(attack,decay,hold,release), s = sustain amplitude\nfloat adsr(float t, vec4 v, float s//https://www.shadertoy.com/view/ll23RK\n){v.xyw = max(vec3(2.2e-05),v.xyw)\n ;float ta = t/v.x// attack term\n ;float td = max(s, 1.0-(t-v.x)*(1.0-s)/v.y)// decay / sustain amplitude term\n ;float tr = (1.0 - max(0.0,t-(v.x+v.y+v.z))/v.w)// length / release term\n ;return max(0.0, min(ta, tr*td))\n ;}\n\n#define BPM 112.\n//same idea (bitwise square wave?) but with an AR envelope\nfloat seqAR(float t, float gate, float atk, float rel, float ofst\n){float p=((t*pi*BPM/120.)-ofst*TAU-pi*0.5+gate)\n ;float tp = fract(p/pi*.5)\n ;gate = clamp(gate,-1.,1.)//scale envelope, based on the gate length\n ;float scl = (1.-abs(gate))\n ;atk *= scl\n ;rel *= scl\n ;if (tp > 0.5) return smoothstep( gate-atk, gate+atk, cos(p)) //Attack envelope\n ;return smoothstep( gate-rel, gate+rel, cos(p));} //Release envelope\n\n//simple frequency modulation (3->1)\nfloat fmsq(float t, float note, float octave){\n\tfloat fm = sn(t,note,octave-1.)*.0008;\n\tfloat fm2 = sn(t,note,octave+1.)*.0007;\n\tfloat fm3 = sn(t,note,octave+2.)*.00055;\n\treturn sqr(t+fm+fm2+fm3,note,octave);}\n//very fake filtered saw (not used)\nfloat filterSaw(float t, float note, float octave, float cutoff, float q){\n    float saw = fract(t*note*exp2(octave-1.))-0.5;\n    float sn = cos((t*note*exp2(octave)*pi)+pi*0.5);\n    float filt = smoothstep(cutoff-q,cutoff+q,abs(saw)*2.);\n    return mix(saw,sn,filt);}\n//a slightly more complex intrument using the sequencer for harmonic envelopes\n//freq is how often the note is triggered\nfloat additive(float t, float note, float octave, float freq){\n    float x = t*freq;\n    float rz = 0.;\n    float atk = 0.01;\n    float rel = 1.;\n    float h = 1.;\n    float pw = 1.;\n    float dcy = .0;    \n    for(int i=0;i<6;i++)    {\n        rz += sn(t*h, note, octave)*seqAR(x, dcy ,atk, rel, 0.)*pw;\n        dcy += .1;\n        pw  -= .1;\n        h = float(i)+1.001;\n    }\n    rz = saw(rz*0.002,note,octave)*seqAR(x, .0 ,atk, rel, 0.);\n    return rz;}//https://www.shadertoy.com/view/MdfXW2\n\n\n\n//self  : https://www.shadertoy.com/view/4t3fDN\n//parent: https://www.shadertoy.com/view/ldXBzH\n//I like how ldXBzH does sequencing with a note key and some chords of different instruments\n//it had defunct code that clearly hinted at attempting to be a bit like this shader.\n\n//play melody of parent, or own melody\n//#define parentMelody\n\n#define HASHSCALE1 .1031\nfloat hash1(float p\n){vec3 q=fract(vec3(p)*HASHSCALE1)\n ;q+=dot(q,q.yzx+19.19)\n ;return fract((q.x+q.y)*q.z);}\nint rand1To8(float t){return int(hash1(t)*8.);}\n\n//https://www.shadertoy.com/view/ldXBzH\nfloat[] C135 = float[](0.,2.,4.);\n//instrument subroutines\n\n//float n2f      (float n){return 55. *pow(2.,(n- 3.)/12.);}\nvec4 n2f      (vec4 n){return 55. *pow(vec4(2),(n- 3.)/12.);}\nfloat noteKeyA (float n){float[] notes = float[](1046.5,1174.66,1318.51,1396.91,1567.98,1760.,1975.53, 2093.); \n                         return notes[int(n)%8];}//this could use https://www.shadertoy.com/view/Xl3BD4\n\nfloat ix(float o,float idx){return exp2(o)*noteKeyA(idx);}\nfloat ox(float t,float o,float idx){return ix(o,idx)*fract(t/2.)*pi*.8;}\n\n\n//instruments //https://www.shadertoy.com/view/ldXBzH\nfloat note(float k, float o,  float t){return sin(ox(t,o,k));}\nfloat noteSaw(float k, float o, float t){return tan(note(k,o,t));}\nfloat noteSquare(float idx, float o, float t\n){float a=floor(fract(t*2.)*2.+1.)*fract(t*.5)*.1\n ;return 3.*(fract(a*ix(o,idx))-.5);}\n\n#ifdef parentMelody\nfloat melody(float t,float c//https://www.shadertoy.com/view/ldXBzH\n){float note\n ;t=mod(t,64.)< 32. ? mod(t,32.0)-94. : t\n ;float s=floor(2.*hash1(floor(t*2.+241.)))+1.\n ;t*=.25*s\n ;if(s==2.&& hash1(floor(t*4.0+738.))>.7)t*=2.//shorter notes\n ;float r=hash1(floor(t-3280.))\n ;if(r<=.8\n ){if(r>.4)c=floor(mod( 4.*t,8.))\n  ;else    c=floor(mod(-4.*t,8.));}\n ;return c;}\n#else\nfloat melody(float t, float c//https://www.shadertoy.com/view/4t3fDN\n){//float c\n ;t = mod(t,64.)< 32. ? mod(t,32.0)-94. : t\n ;float s = floor(2.0*hash1(floor(t*2.0+241.0)))+1.0\n ;t*=mix(1.,4.,smoothstep(0.,1.,s-2.))\n ;s=hash1(floor(t*4.+738.))\n ;t*=mix(1.,2.,step(s-.7,0.))//smoothstep(.0,1.,s-.7))\n ;//t*=.5*s\n ;float noteRand=hash1(floor(t-3280.0))\n ;if(noteRand<=0.8){\n       t*=4.*mix(1.,-1.,step(.4,noteRand)) \n     ;c=float(mod(t,8.0))\n ;}return c;}\n#endif\n\n\nfloat mi(vec4 a){return min(min(a.x,a.y),min(a.z,a.w));}\n\n\n\n\n  \n\n\n//___end__ dump\n//__start audiovisual\n\n\n/*\n//return silly slow 4 color ramp, famous for fourier transforms.\nvec3 blueRedYellowWhite(float y){vec3 c=mix(vec3(0)//overly precise and slow fragiend function\n        ,vec3(0.2,0.2,0.7),remap(.00,0.25,y));//blue\n c=mix(c,vec3(0.9,0.1,0.0),remap(.25,0.50,y));//red\n c=mix(c,vec3(1.0,1.0,0.3),remap(.50,0.75,y));//yellow\n return mix(c,vec3(1.0,1.0,1.0),remap(.75,1.00,y));}//white\n*/\n\n\n//rgba colorspace matrices\n//rgba colorspace matrices\n#define ab012(a,b)(a+b*vec3(0,1,2))//desaturation.rgb kernel;b scales offset\n//rainbow*()ro from purple to purple for range[0..1],this makes ab012()desaturate into semi-gaussian scattering.\nvec3 rainbowt(float a,float b){return abs(u2(fract(ab012(a,b))));}//triangle rainbow with offsets,desaturates colors for small b\nvec3 rainbowt(float a){return rainbowt(-a,1./3.);}\nvec3 rainbows(float a,float b){return u5(cos(2.*pi*ab012(a,b)));}//sine rainbow with offsets,desaturates colors for small b\nvec3 rainbows(float a){return rainbows(-a,1./3.);}\n#define ToRgb(w) return c.z*mix(vec3(1.),sat(w(-c.x)),c.y);}\nvec3 rainbows(vec3 c){ToRgb(rainbows)//3 tri waves, most blurry  , fast and precise cos-mix (blurriest because it is only linear)\nvec3 rainbowt(vec3 c){ToRgb(rainbowt)//3 cos waves, medium blurry, linear-mix not identical to hsv2rgb ,but close\n//hsv2rgb uses a capped triangle-wave, as such it appears to be the brighttest/sharpest because at any moment only 2/3 colors swap.\n#define hsv2rgb(c) c.z*mix(vec3(1),sat(abs(fract(c.x+vec3(3,2,1)/3.)*6.-3.)-1.),c.y)\n//below is inverse of above, it swivels quite a lot, i think i once made this much smarter!, like in 2008, but code is lost\n#define rgb2hsv2(a,b,c,d,e,f) mx(vec4(a,b),vec4(c,d),st(e,f))\n#define rgb2hsv3(K) rgb2hsv2(a.zy,K.wz,a.yz,K.xy,a.z,a.y)\n#define rgb2hsv4(P) rgb2hsv2(P.xyw,a.x,a.x,P.yzx,P.x,a.x)\n#define rgb2hsv5(D,q) abx(vec2(q.w-q.y,D)/(vec2(6.*D,q.x)+1e-10)+vec2(q.z,0))\n#define rgb2hsv6(q) vec3(rgb2hsv5((q.x-min(q.w,q.y)),q),q.x)\n#define rgb2hsv(a) rgb2hsv6(rgb2hsv4(rgb2hsv3((vec4(0,-1,2,-3)/3.))))//https://www.shadertoy.com/view/MdGfWm\n//common legacy namespaces\n#define hsv2rgbR     rainbowt //3 tri waves, most blurry, fast and precise, considder for mobile\n#define angleToColor rainbows //3 cos waves, medium blurry\n//hsv2rgb() most commonly implies a [capped triangle waveform]\n//vec3 HsvToRgb(vec3 c){vec3 p;p=abs(fract(c.xxx+vec3(3,2,1)/3.)*6.-3.);return c.z*mix(vec3(1),sat(p-1.),c.y);}\n//porter duff alpha compositing:\n//i do not define ut ..., because its a too short namespace to be spent on a define.\nvec4 ut(vec4 a,vec1 b){return a*(1.-b);}//#define ut(a,b) (a*(1.-b))\n//note; colors atop of identical color is a too easy debugging culpit.\n//note,that atop may returns the alpha of a,and not the alpha max(a,b)\nvec4 pdOut(vec4 a,vec4 b){return ut(b,a.w);}\nvec4 pdOver(vec4 a,vec4 b){return ut(b,a.w)+a;}\nvec4 pdAtop(vec4 a,vec4 b){return ut(b,a.w)+a*b.w;}\nvec4 pdXor(vec4 a,vec4 b){return ut(b,a.w)+ut(a,b.w);}\n\n       \nvec4 sound2(float t//return semirandom sequence of 4 notes at once as vec4\n){float i=4.\n ;float l = mod(t,64.)< 32. ? 4. : 32.\n ;float j =float( rand1To8(mod(floor(t*2./i),l)-900.))\n ;float d=floor(melody(t,j)+24.)\n ;float c=floor(fract((2.*t+2.))*2.)\n ;return vec4(j+vec3(4,9,-c*8.-8.),d)///.xyz are a base-chord. .w is a melody\n ;}\nfloat soso(float t//audible mono uses sound2() as input\n){float c=0.\n ;vec4 nn=(floor(sound2(t)))\n ;float j=nn.x\n ;c+=.2*noteSaw(nn.w,2.,t)//sin(6.2831*nn.w*t);\n ;c+=.8*(noteSquare((nn.z+C135[0]),0.,t)*.3\n           +noteSaw((nn.y+C135[1]),1.,t)*.3\n           +noteSaw((nn.x+C135[2]),0.,t)*.15)\n ;return c;}\nvec4 colorNoteJ(vec4 n, float y//https://www.shadertoy.com/view/4t3fDN\n){float a=mi(abs(n-y))    \n ;y*=.02\n ;vec4 b=vec4(a)\n ;vec4 c=vec4(rainbows(y),1.)\n ;//vec4 c=vec4(1.-sat(vec3(y,.5+.5*cos(y*8.),1.-y)),1)//lazy gradient\n ;//return c\n ;return pdOut(b,c)\n ;}//you likely wanted a non-gradient, well that just adds some y=fract(y*s)*v  y=floor(y*z)*w\nvec4 ImageJ(vec2 u,vec4 m,vec2 r,float t//https://www.shadertoy.com/view/4t3fDN\n){u=u.xy/r.xy\n ;vec4 c=sound2(t+u.x-1.0)\n ;c.w=floor(c.w)\n ;return colorNoteJ(c,u.y*60.-20.);}\nvec2 SoundJ(float t){return vec2(soso(t));}//https://www.shadertoy.com/view/4t3fDN          \n\n//we define segments NOT by start and end times, BUT by center and width!\n//because this simplifies inequalities, allowing us to utilize abs() and calculus\n//thish in the long run simplifies many interlolations\n// , contextual framing and boke/CoC/Kerning with overlapping segments!\n//by substituting an inequalit with mix(step())\n//, and substituting step() with smoothstep()\n\nvec2 debugCompositionA(float t//this composition is played first and has high variance.\n){vec2 c=vec2(0);\n ;//c+=strings(t)*.2\n ;//c+=DemoEarthBoundBattle(t)\n ;//c+=DrWhoTheramin(t,t*2.))\n ;//c+=DemoDrWho(t)\n ;//c+=debugInstruments(t)\n ;//c+=demoBandLimit(t)\n ;//c+=debugInstrument(t)\n ;c+=demoSequencePolyphonyPirates(t)\n ;return c;}\n                          \nvec2 soundFrames(float t){\n ;return debugCompositionA(t)\n ;vec2 c=vec2(0)\n ;     if(0.<8.-abs(t-13.))c+=debugCompositionA(t)\n ;else if(0.<8.-abs(t-13.-16.-8.)) c+=synthWave2(t+3.-8.)//8. seds the halfWidth of segment. -13 sets CenterOffset of segment\n //starting point is =13-8=3, and this must be the time offset of all within the segment\n ;else if(0.<14.-abs(t-14.-16.-8.-12.-6.-2.)) c+=demoBandLimit(t)*.5\n //13 is previous segment midpoint, -8 and .4 are halfwidths of 2 segments -2 is a \"nomalsland\" between 2 segments.\n ;else c+=debugCompositionB(t)//background rythmic, profices constant feel to time/tempo, semi-metrum:\n ;return c;}\n                          \nvec2 sound(float t//entry point for mainSound( in int samp,),waveForm and dft()\n){//float f=fract(t)\n //;t+=8.//fast forward\n ;vec2 c=vec2(0)\n ;//c+=debugDrums(t)\n ;//c+=debugInstruments(t)\n ;//c+=drums(t)\n ;//c+=DecentBase(t)//watning subobtimal sequencer and big instruments,takes long to parse!\n ;//return AlienHum(t)//delayed, too complex sequence and way too many octaves in instrument crash it!\n ;//return teslaCoil(t)\n ;c=soundFrames(t)\n ;return c\n ;return vec2(co2p(440.*t)*exp(-3.0*t))// A 440 Hz wave that attenuates quickly overt time\n ;}\n//vec2 mainSound( in int samp,float t){return sound(t);}\n                         \n//to render a waveform, for the sake of performance (in favor of DFT)\n//, audio visualizers are single taps without calculis, no normalized line thickness.\nvec4 VisWaveForm(vec2 u,vec2 m,vec2 r,float t//https://www.shadertoy.com/view/ldlSD2\n){u.y=(u.y*2.-1.)*2.\n ;float zoom=100.\n ;u.x=biject(u.x+(floor(t*fpsWave)*zoom/fpsWave),1.,0.,0.,-1./zoom)\n ;float v = sound(u.x).x\n ;//float dx=fwidth(v);v=abs(v-u.y)/sqrt(1.+dx*dx)//way too many c0 dicsontinuities here to look decent\n ;//this needs multitapping for half devend width differentials.\n ;v=smoothstep(.02,-.02,abs(v-u.y)-.1)//waveform  line thickness\n ;\n ;//c.x=abs(dx-u.y)/sqrt(1.+dx*dx)//euclidean_scale by firct derivative. (bad near very shin extrema)\n ;return vec4(v);}\n\nvec3 gradOllj(float T,vec2 u\n){T=T*1.5-.8\n ;vec3 c=rainbows(((((2.-T)/pi)*pi)-.5)/2.+1./6.,1./6.)\n ;if(u.x<0.)T-=0.34\n ;if(u.x<0.)c=1.-rainbows(((((2.+T)/pi)*pi)-.5)/2.+1./6.)\n ;c=c/max(c.r,max(c.g,c.b))*u5(((c.g)/(c.r+c.b)))//optional norm\n  ;return c;}\n                          \n//various basic gain/amplify/constrast/gamma/rainbow() \n//to show a DFT-image nicer, to ballance contrasts.\n//to highight amplutude with a filter that gets harder near [p]==timeNow/iMouse\n//that filters out weaker frequencies, only greyscaling the strongest.\n//whille further in past/future hue is used to distinguish more amplitude-range\n//this whole function is a woven mess of options: m.xy sets some parameters:\n//all that sets [c] may be mixed and matched, depending on [p]; mix(c1,c2,p)\n//some that set [c] take [p] as parameter, that sets hue by [p]\n//functions are ordered in a way that makes most contextual sense, i hope.\nvec3 oilyDftRainbow(float l,vec2 u,vec4 m//DFTamplitudeAtUV,uv,iMouse //.x is time,.y is frequency.\n){float p=abs(m.x-u.x)\n ;l*=4.\n ;float q=smoothstep(.1,-.1,p*.4)\n ;l/=32. //must have this or the line below\n ;//l/=mix(64.,4.,q)//or global factor dynamic variant!   \n ;//l=.3+.8*(l/mix(64.,2.,1.))//optional  tiny green bias experiment, good for visibility.\n  //above line uses MORE hue, to make an overall brighter image, uses more green/blue as backdrop.\n ;vec3 c=vec3(0)\n ;l=sat((l))\n ;c=mix(gradOllj(l,u)*l,l+hsv2rgb(vec3(l*.6,2./(l+.1),l)),u5(l));//simpler times or oilyUse:\n #define oilyUse rainbow2 //see hsv2rdb functions.\n ;//vec3 c=oilyUse(l*0.61)*u5(l)//simple \n ;//l/=sqrt(l+.1);//optional flatten colors, highlight lower amplitudes\n ;//l/=1.+l//optional enhance\n ;//l=sat(l/(abs(acos(abs(l-.1)))+.2));//OR BAD optional push all towards \"1\"\n ;//l=sqrt(l)//Extra optioal gamma slow\n ;//float a=1.-sqrt(p*1.5);l=mix(l*.1,l-a,a);//parametric illumination\n ;//c=oilyUse(l,-q-.33)*l//simple (only 1 variable parameter to rainbor2()\n ;//c=oilyUse(q*.5,p)*l //(p+1.025)\n ;//c=oilyUse(l,p)*l/(p+1.025)//nice dynamic contrast\n ;//c=oilyUse(l*2.,mix(0.,1.2,p))/(p+1.025)//merged mess \n ;//c=oilyUse((abs(m.x)/l/p))*l*p///interestring reciprocals\n ;//c=oilyUse((u.x-.5),l)//experimental, parameter swap kinda works here\n //super contrast disregards hue,good for colorblindness\n ;c*=1.2//oversaturate\n ;c+=l*.5;//basic highight dark\n ;vec3 c2=c*8./(log(l)+.1);//good extreme contrast  \n ;//c= (2.-m.y)*c+(m.y*8.)*sat(c2)//you likely want to mix the above and not 100% the above!\n ;if(abs(u.x-m.x)<.005)c+=.5;//to debug [b] brighter vertical line at \"now\"\n ;//c=pow(c,vec3(3.))//high gamma helps here\n ;c=sat(c)//oten optional, but with all the exponentials this function has, better be safe!\n ;return c;}\n    \n\n//main Fourier Transform DFT loop, generlized by ollj https://www.shadertoy.com/view/MdjXWc   \n//[r] scales an overlapping modulo [roots of unity].\n//... with a circilar complex-plane \"ovetone echo\". \n//... This is the confusing part about Fourier Transformation.\n//.1  circles trough 3 octaves. \n//.7to.5 makes sense for most tracks.\n//.05 circles trough 5 octaves.\n//.03 circles trough 8 octaves. \nvec2 dft(vec2 u,float r,float n//uv,scaleRoots\n){//r=.1//default, can be set by iMouse.y\n ;//n=256.//defent default\n ;n=min(n,iterMaxDFT)//hard limit to avoid unintended crashes or hangups\n ;vec2 c=cs(pi2(floor(u.y*n*.5)/n)),d=vec2(1,0),f=vec2(0)\n ;for(float i=0.;i<n;i++ //resursion of DFT as accumulating loop\n ){float x=i/n//fractal butterfly scaling context\n  //the +u.x is a time offset, that some dft() loops make more explicit.\n  ;vec2 w=sound(x*r+u.x)//dft() ttaps the same sound() function that mainSound( in int samp,) calls.\n  ;f+=d*(w.x+w.y)*.25*(1.-co2p(x))// Hann window-function\n  ;d=d.xy*c.x+vec2(-1,1)*d.yx*c.y;//fourier Butterfly\n ;}return f;}//length() of f is useful\n//you want to do;\n//vec2 f=dft(u,scaleY)\n//;f.x=.5*length(f)\n//;return sat(sqrt(f.x/1./f.x))\n                          \n\nvec2 c2p(vec2 a){return vec2(length(a),atan(a.y,a.x));}\nvec2 p2c(vec2 a){return cs(a.y)*a.x;}\n        \n                      \n//originally a tuning shader, and i just tauologically feed it with an fm-synth-dft\n//i was hoping that its framign lets me still see something nice\n//even if the dft is VERY few iterations\n//i was not wrong, but it is till not pretty.\n//white = A octaves\n//https://www.shadertoy.com/view/lsscWH\nvec4 spectrometerTuner(vec2 U,vec2 r,vec2 m,float t,float scrollspeedXZoom\n){vec4 O=vec4(0)\n ;//U/=r\n ;float g=mix(16.,8.,step(U.y , 4./5.))\n ;float f=mix(g,4.,step(U.y , 3./5.))\n ;float e=mix(f,2.,step(U.y , 2./5.))\n ;float d=mix(e,1.,step(U.y , 1./5.))\n ;float scale = d\n ;U.y = mod(U.y,1./5.)*5.; \n ;float M = 44100.//=iSampleRate;    \n ;// last FFT value in texture = iSampleRate/4\n #define freq(f) abs( (f)/(M/4.)  -U.x) * r.y * scale\n ;U.x /= scale;\n ;vec2 v=U.yx\n ;m=vec2(m.x*.06,0)\n // ;m=m.yx\n ;v.x*=.5\n ;scrollspeedXZoom*=.4\n ;v.x=floor((U.y+t/scrollspeedXZoom)*iterscaDFT*12.)/(iterscaDFT*12.)//old\n ;v.x+=.8\n ;v.x=(v.x-1.)*scrollspeedXZoom//old\n ;float n=sqrt(abs(m.x-U.y+1.))\n ;vec2 ff=dft(vec2(v.x,v.y/n),m.x*8./sqrt(iterMaxDFT/12.),iterscaDFT*n*12.)\n ;O =vec4(oilyDftRainbow(length(ff),U.yx,m.yxyx),1)\n ;//vec2 ass=dft(vec2(v.x,v.y/n),m.y*8./sqrt(iterMaxDFT),iterscaDFT*n)))\n // ;return O;\n //  vec4(0)//texture(iChannel0,vec2(U.x,.25));//image is spectrum .x is frequencies .y is volume bars.\n //so only small.y matter for IO\n ;if (U.y<0. || U.y>.5) return vec4(0);\n    if (freq(165.)<.5) O.g++;    // E0 guitar\n    if (freq(220.)<.5) O.g++;    // A0\n    if (freq(294.)<.5) O.g++;    // D1\n    if (freq(392.)<.5) O.g++;    // G1\n    if (freq(494.)<.5) O.g++;    // B1\n    if (freq(660.)<.5) O.g++;    // E2\n    if (freq( 588.)<.5) O.b++;   //  D2 flute\n    if (freq(784.)<.5) O.b++;    //  G2 \n    if (freq(1046.)<.5) O.b++;   //  C3\n // if (freq(1150.)<.5) O.b++;   // \n    if (freq(1175.)<.5) O.b++;   //  D3\n    if (U.y<.25) {\n        if (freq( 220.)<1.) O++; \n        if (freq( 440.)<2.) O++; // A1\n        if (freq( 880.)<1.) O++; // A2\n        if (freq(1760.)<.5) O++; // A3\n        if (freq(3520.)<.5) O++; // A4\n        if (freq(7040.)<.5) O++; // A5\n    }return O\n\n/**/;}\n                      \nvec4 imageB(vec2 u,vec4 m,vec2 r,float t//c for [c]implicity\n){if(m.xy==vec2(0))m=r.xyxy*.5\n ;vec2 q=u\n ;u/=r.xy\n ;m/=r.xyxy\n ;//u.y*=8.//optionally zoom out .y to highlight the freeze-group of dft()\n ;vec2 v=u\n ;v.x*=.5\n #ifdef TodoDefineLogarythmicTime\n  //i am not sure how to best make \"logarythmic time\" YET\n  //, so this is a playground to find out what i avtually want to do\n  //the final result will likely be a parametcit CDF in leu of an AMP function.\n  //and its low exponential varian will be a lot like my \"lerpsnake\" function\n  //anything that is a bit like a timeline magnifier:\n  //this one kinda sucks, so itts rather \"undefined\"\n ;v.x=1.-v.x\n ;float z=t\n ;z=(t-v.x)*2.-1.*t\n ;z*=t/sqrt(t);\n ;v.x=v.x*(z+t)\n ;v.x=(z*t*.9)/(v.x)\n #else\n #define scrollspeedXZoom 5.//*u5(m.x)       \n ;v.x=floor((u.x+t/scrollspeedXZoom)*iterscaDFT)/iterscaDFT//old\n ;v.x+=.5\n ;v.x=(v.x-1.)*scrollspeedXZoom//old\n #endif\n ;float b=abs(t-v.x)//a NOW-timeline, that gets wider over time\n ;//float d=t/(v.x+t)+.5\n ;//v.x=biject(v.x*t,-t,t,-1.,1.)\n ;//v.x=v.x/(t)\n ;//attempt to prepresent a lot of spacial information in a single list \n ;//by squashing the future preview to the right. past flashes by, zoomed out\n ;//over time, more past memories cramp on the left, as everything seems to zoom out.\n ;//v.x+=t+.5\n ;//v.x=((1.-m.y)*32.)/v.x+t\n ;//v.x+=t-m.x*4.+2.\n ;float n=sqrt(abs(m.x-u.x+1.))\n #ifndef showDFT\n ;vec2 f=dft(vec2(v.x,v.y/n),m.y*8./sqrt(iterMaxDFT),iterscaDFT*n)\n ;//f*=ThicknesMultiplier<1.\n ;float l=length(f)\n ;b=smoothstep(.1,-.1,b)\n ;vec3 c=oilyDftRainbow(l,u,m)\n //;c.xz+=ShowPianoSjheetOf(pirateLines,u,t,m)\n #else      \n ;vec3 c=vec3(0)\n ;if(mod(q.x+q.y,2.)==1.)//cheap dither to do 2 tracks faster.\n        c.y=     ShowPianoSjheetOf(pirateLinesB,vec2(u.x,u.y+.1),t,m)\n ;else c.xz=vec2(ShowPianoSjheetOf(pirateLines ,     u          ,t,m))\n ;c+=smoothstep(.01,-.01,abs(u.x-m.x))\n ;//https://www.shadertoy.com/view/4tcfWN did not do toowell:\n ;//vec3 c=spectrometerTuner(u,r,m.xy,t,scrollspeedXZoom).xyz\n\n    \n ;float d=sound(t+u.x/44.).x-u.y*6.+1.\n ;d=smoothstep(.01,-.01,abs(d)-.2)\n ;c+=vec3(d,0,0)*.2\n     /**/    \n  #endif\n  ;if(u.y>.9)c=vec3(b)//draw  [b]as grey bat on top\n ;vec3 w=VisWaveForm(u,m.xy,r,t).xyz\n ;c+=w*.5\n //;c=y*.5+hsv2rgb(vec3(y*.49,2./(y+.1),y));//Fourier transform infrared image\n ;return vec4(c, 1.0);}\n\n\n//void mainImage(out vec4 o,vec2 u){o=image(u,iResolution.xy,iTime);}\nvec4 image(vec2 u,vec4 m,vec2 r,float t){\n ;//if(mod(u.x+u.y,2.)==1.)return vec4(0)//vec4(.3,.2,.0,2.)*.5//every 2nd pixels is skipped/black.\n ;//vec2 p=mod(u,2.)\n ;//return debugEnv(u,r,m)\n ;return imageB(u,m,r,t)\n ;}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}