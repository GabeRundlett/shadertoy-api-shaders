{
    "Shader": {
        "info": {
            "date": "1710405312",
            "description": "My rendition of a hämis in the fungal caverns from noita.",
            "flags": 0,
            "hasliked": 0,
            "id": "lfjXDt",
            "likes": 9,
            "name": "hämis",
            "published": 3,
            "tags": [
                "noita",
                "hamis"
            ],
            "usePreview": 1,
            "username": "kaliuresis",
            "viewed": 233
        },
        "renderpass": [
            {
                "code": "#define halfsqrt3 0.86602540\n#define invsqrt3 0.57735026\n#define invsqrt2 0.7071067811865475244\n#define tau 6.28318530\n#define pi 3.14159265358979323846264338327950\n#define golden_ratio 1.6180339887498948482\n\n#define sq(x) ((x)*(x))\n\n#define ZERO (min(iFrame,0))\n#define fZERO (min(iTime,0.0))\n\n//hash functions are my passion\nfloat hash(vec3 p)\n{\n    float a = dot(cos(921894.0*p+0.2318), vec3(1.0));\n    return cos(391278.0*a);\n    \n}\n\nfloat hash(vec2 p)\n{\n    float a = dot(cos(921894.0*p+0.2318), vec2(1.0));\n    return cos(391278.0*a);\n}\n\nvec3 hash3D(vec2 p)\n{\n    vec2 d = cos(921894.0*p+0.2318);\n    float a = dot(d, vec2(1.0,5.0));\n    float b = dot(d, vec2(2.0,11.0));\n    float c = dot(d, vec2(7.0,3.0));\n    return cos(mod(vec3(991278.0*a,792389.0*b,589424.0*c), 2.0*pi)+0.1*iTime);\n}\n\nfloat value_noise(vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    vec3 s = f*f*(3.0-2.0*f);\n    vec2 e = vec2(0.0,1.0);\n    float v = mix(mix(mix(hash(i+e.xxx), hash(i+e.yxx), s.x),\n                      mix(hash(i+e.xyx), hash(i+e.yyx), s.x), s.y),\n                  mix(mix(hash(i+e.xxy), hash(i+e.yxy), s.x),\n                      mix(hash(i+e.xyy), hash(i+e.yyy), s.x), s.y), s.z);\n    return v;\n}\n\nfloat value_noise(vec2 p, vec2 m)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 s = f*f*(3.0-2.0*f);\n    vec2 e = vec2(0.0,1.0);\n    float v = mix(mix(hash(mod(i+e.xx, m)), hash(mod(i+e.yx, m)), s.x),\n                  mix(hash(mod(i+e.xy, m)), hash(mod(i+e.yy, m)), s.x), s.y);\n    return v;\n}\n\nvec3 value_noised(vec2 p, vec2 m)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 s = f*f*(3.0-2.0*f);\n    vec2 e = vec2(0.0,1.0);\n    vec2 ds = f*(1.0-f);\n    float v00 = hash(mod(i+e.xx, m));\n    float v10 = hash(mod(i+e.yx, m));\n    float v01 = hash(mod(i+e.xy, m));\n    float v11 = hash(mod(i+e.yy, m));\n    \n    vec3 v = v00*vec3((1.0-s.x)*(1.0-s.y), -ds.x*(1.0-s.y), -(1.0-s.x)*ds.y)\n            +v10*vec3(s.x*(1.0-s.y), ds.x*(1.0-s.y), -s.x*ds.y)\n            +v01*vec3((1.0-s.x)*s.y, -ds.x*s.y, (1.0-s.x)*ds.y)\n            +v11*vec3(s.x*s.y, ds.x*s.y, s.x*ds.y);\n    \n    return v;\n}\n\nvec2 complexx(vec2 a, vec2 b)\n{\n    return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);\n}\n\nfloat smin(float a, float b, float k, out float t)\n{\n    float h = max(k-abs(a-b),0.0);\n    float m = 0.25*h*h/k;\n    float n = 0.50*  h/k;\n    t = (a<b)?n:1.0-n;\n    return min(a, b) - m;\n}\n\nfloat smax(float a, float b, float k, out float t)\n{\n    float h = max(k-abs(a-b),0.0);\n    float m = 0.25*h*h/k;\n    float n = 0.50*  h/k;\n    t = (a>b)?n:1.0-n;\n    return max(a, b) + m;\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = max(k-abs(a-b),0.0);\n    float m = 0.25*h*h/k;\n    float n = 0.50*  h/k;\n    return min(a,  b) - m;\n}\n\nfloat smax(float a, float b, float k)\n{\n    float h = max(k-abs(a-b),0.0);\n    float m = 0.25*h*h/k;\n    float n = 0.50*  h/k;\n    return max(a,  b) + m;\n}\n\nvec4 sdfmin(vec4 a, vec4 b)\n{\n    return (a.x < b.x) ? a : b;\n}\n\nfloat capsule(vec3 p, vec3 a, vec3 d, float r)\n{\n    vec3 n = normalize(d);\n    float t = dot(p-a, n);\n    t = clamp(t, 0.0, length(d));\n    vec3 c = a+n*t;\n    return length(p-c)-r;\n}\n\nfloat torus(vec3 p, vec3 a, vec3 d, float R, float r)\n{\n    p -= a;\n    vec3 t = R*normalize(p-dot(p,d)*d);\n    return length(p-t)-r;\n}\n\nfloat sphere(vec3 p, vec3 c, float r)\n{\n    return length(p-c)-r;\n}\n\n\nvec3 heightmap(vec2 p, out float m)\n{\n    m = 4.0;\n    vec3 v = vec3(0.0);\n\n    v.x -= 30.0;\n    float s = 3.0;\n    mat2 f = 0.02*mat2(4.0/5.0, -3.0/5.0, 3.0/5.0, 4.0/5.0);\n    for(int i = 0; i < 4; i++)\n    {\n        vec2 phi = 2.0*pi*cos(vec2(510282.3, 58768.8)*float(i));\n        vec2 a = s*cos(vec2(408199.6, 27946.4)*float(i)+0.5);\n        v += vec3(dot(a, cos(f*p+phi)), -a*f*sin(f*p+phi));\n        s *= 0.5;\n        f *= 2.0*mat2(4.0/5.0, -3.0/5.0, 3.0/5.0, 4.0/5.0);\n    }\n    v.x += min(50.0, 0.001*sq(p.x));\n    v.y += 0.001*p.x;\n    \n    /* not worth the performance cost\n    //ground mushrooms\n    vec2 c;\n    c.y = (round(p.y*0.005-0.25)+0.25)*200.0;\n    c.x = 100.0*sin(12394.0*c.y);\n    if(abs(c.x) < 25.0) c.x = (c.x > 0.0 ? 25.0 : -25.0);\n    \n    vec2 r = p-c.xy;\n    float theta = atan(r.y, r.x);\n    float rho = length(r);\n    float smr = min(0.2*rho, 1.0);\n    float mh = (20.0-(smr*smr+max(0.0, rho-5.0))*(1.0+0.05*sin(10.0*theta)));\n    if(mh > 0.0){\n        vec2 n;\n        if(dot(r, r) > sq(5.0)) n = -normalize(r);\n        else n = -0.2*r;\n        n += 0.05*vec2(-r.y, r.x)*cos(10.0*theta);\n        v += vec3(mh, n);\n        m = 8.0;\n    }\n    */\n\n    return v;\n}\n\nvec3 heightmap(vec2 p)\n{\n    float m;\n    return heightmap(p, m);\n}\n\nvec3 camera_pos;\n\nvec3 fungus_heightmap(vec3 p, int freq)\n{\n\n    //p.x += sin(p.z+10.0*iTime);\n    float t = 0.0;\n    vec3 v = vec3(0.0);\n    \n    float s = 5.0;\n    float scale = 0.1;\n    mat2 f = 0.1*mat2(4.0/5.0, -3.0/5.0, 3.0/5.0, 4.0/5.0);\n    for(int i = 0; i < freq; i++)\n    {\n        vec2 q = f*p.xy;\n        vec2 r = 0.1*q+cos(q);\n        float h = s*dot(cos(r), vec2(1.0));\n        v.x += h;\n        v.yz += -f*(s*(0.1+sin(q))*sin(r));\n        //s *= 0.5;        \n        f *= 2.0*mat2(4.0/5.0, -3.0/5.0, 3.0/5.0, 4.0/5.0);\n        scale *= 2.0;\n    }\n    float h = min(20.0, 0.001*sq(p.x))-20.0;\n    v.x += h;\n    v.y += 0.001*p.x;\n    \n    return v;\n}\n\nvec3 hamis_pos;\nfloat jaw_rot;\nfloat jump_prep;\nvec3 hip_pos[3];\nvec3 knee_pos[3];\nvec3 ankle_pos[3];\nvec3 foot_pos[3];\nvec2 body_rot;\nvec2 body_rot_center;\n\nvoid calculate_animation(float time)\n{\n    const float walk_speed = 40.0;\n    const float period = 0.7;\n    const float jump_speed = 100.0;\n    const float jump_duration = 1.0;\n    const float jump_prep_duration = 0.3;\n    const float landing_duration = 1.0;\n    const float avg_jump_period = 5.0;\n    const float avg_speed = mix(walk_speed, jump_speed, jump_duration/avg_jump_period);\n    const float avg_jump_spacing = avg_speed*avg_jump_period;\n    const float g = 250.0;\n    const float jump_velocity = 0.5*jump_duration*g;\n    \n    float jump_number = floor(time/avg_jump_period);\n    float jump_window = avg_jump_period*jump_number;\n    float window_time = time-jump_window;\n    float jump_offset = (avg_jump_period-jump_duration-jump_prep_duration-landing_duration)*(0.4+0.4*cos(48931275.0*jump_number));\n    float last_jump_prep = jump_window+jump_offset;\n    float last_jump_time = last_jump_prep+jump_prep_duration;\n    float jump_time = max(time-last_jump_time, 0.0);\n    float last_land_time = last_jump_time+jump_duration;\n    float land_time = time-last_land_time;\n    \n    vec3 jump_pos = vec3(0.0);\n    jump_pos.y = -avg_jump_spacing*jump_number-walk_speed*(jump_offset+jump_prep_duration);\n    jump_pos.z = heightmap(jump_pos.xy).x;\n\n    jaw_rot = (1.2+0.1*sin(10.0*jump_time))*smoothstep(0.0, 0.5, jump_time)*smoothstep(0.05, -0.05, land_time);\n    //jaw_rot = 0.0;\n    \n    float step_wiggle = sin(2.0*pi*(time+1.0*period/3.0));\n    float body_angle = 0.5*jaw_rot+0.25*jump_prep-0.03*step_wiggle;\n\n    hamis_pos = vec3(0.0);\n    hamis_pos.y = -avg_jump_spacing*jump_number - walk_speed*(max(land_time, 0.0)+min(window_time, jump_offset+jump_prep_duration)) - jump_speed*min(jump_time, jump_duration);\n    hamis_pos.z = heightmap(hamis_pos.xy).x;\n    hamis_pos.z -= 10.0*smoothstep(0.0, jump_prep_duration, time-last_jump_prep)*step(-0.5*jump_prep_duration, -jump_time);\n    float land_profile = exp(-5.0*land_time)*smoothstep(landing_duration, 0.9*landing_duration, land_time);\n    if(land_time > 0.0) {\n        hamis_pos.z -= 0.05*jump_velocity*sin(20.0*land_time)*land_profile;\n    }\n    body_angle += 0.2*land_profile*smoothstep(-0.05, 0.05, land_time);\n\n    if(time > last_jump_time)\n        hamis_pos.z = max(hamis_pos.z, heightmap(jump_pos.xy).x+jump_velocity*jump_time-0.5*g*sq(jump_time)-10.0);\n    hamis_pos.z += 10.0;\n        \n    float jumping = smoothstep(0.5, 0.0, abs(jump_time/jump_duration-0.5));\n    hamis_pos.z += 20.0;\n    hamis_pos.z += 0.5*step_wiggle;\n    \n    body_rot = vec2(cos(body_angle), -sin(body_angle));\n    body_rot_center = vec2(10.0, 3.0);\n    \n    for(int ii = ZERO; ii < 3; ii++)\n    {\n        float i = (float(ii)+0.5)*tau/3.0;\n        float a = 6.0;\n        float b = 10.0;\n        float c = 12.0;\n        vec3 r = vec3(sin(i), -cos(i),0.0);\n        \n        vec3 hip = vec3(0.,0.,-5.0)+8.0*r;\n        //r += vec3(0.,-0.6*sin(phi+i),0.);    \n        r = normalize(r);\n                \n        vec3 foot = 16.0*r;\n        float stepspot = mod(time+float(ii)*period/3.0, period);\n        foot.y += walk_speed*(stepspot-period/3.0-smoothstep(period-period/3.0, period, stepspot)*period);\n        \n        float floor_pos = heightmap(hamis_pos.xy+foot.xy).x-hamis_pos.z;\n        foot.z = floor_pos+2.5;\n        foot.z += smoothstep(0.5*period/3.0, 0.0, abs(stepspot-period+period/6.0))*6.0;\n        if(ii == 1) {\n            //foot.z += 10.0*jumping;\n            //foot.y += 50.0*jumping;\n            foot = mix(foot, jump_pos-hamis_pos+vec3(0.0,0.0,2.5-20.0)+16.0*r, jumping);\n        } else {\n            //foot.z += 30.0*jumping;\n            //foot.y += -10.0*jumping;\n            foot = mix(foot, 16.0*r+vec3(0.0,-10.0,-15.0), smoothstep(32.0, 40.0, -floor_pos));\n        }\n        foot.yz = complexx(foot.yz-body_rot_center, body_rot)+body_rot_center;\n\n        foot -= hip;        \n        if(dot(foot, foot) > sq(a+b+c)) foot = (a+b+c-0.1)*normalize(foot);\n        \n        vec2 f = vec2(length(foot.xy), foot.z); //2d foot pos\n        vec3 dir = foot;\n        dir.z = 0.0;\n        dir = normalize(dir);\n        \n        foot += hip;\n        \n        vec2 e = vec2(-f.y, f.x); //perpendicular direction\n        vec2 t = -0.5*((sq(b)-sq(a+c))/dot(f,f)-1.0)*f; //2d knee pos\n        t += -sign(dot(dir, r))*sqrt(sq(a+c)-dot(t,t))*normalize(e);\n        vec3 thigh = t.x*dir+vec3(0.,0.,t.y);\n        vec3 nthigh = thigh/(a+c);\n        vec3 knee = hip+a*nthigh;\n        vec3 e1 = normalize(foot-knee);\n        float s = ii==1?1.0:-1.0;\n        float s2 = float(ii)-1.0;\n        vec3 e2 = normalize(cross(e1, vec3(1.,-0.6*s2,0.)));\n        float pt = dot(nthigh, e1);\n        vec3 toe = c*(pt*e1+s*sqrt(1.0-sq(pt))*e2);\n        //toe = c*nthigh;\n        vec3 ankle = foot-toe;\n                \n        hip_pos[ii] = hip;\n        knee_pos[ii] = knee;\n        ankle_pos[ii] = ankle;\n        foot_pos[ii] = foot;\n    }\n}\n\n//returns vec4(sdf, texture id, texture coordinates)\nvec4 solid_map(vec3 p)\n{    \n    vec4 m;\n    float d;\n\n    vec3 old_p = p;\n    \n    p -= hamis_pos;\n            \n    vec2 jaw_back = vec2(6.0, 3.0);\n\n    p.yz = complexx(p.yz-body_rot_center, body_rot)+body_rot_center;\n\n    vec3 jp = p;\n    vec2 jr = vec2(cos(jaw_rot), sin(jaw_rot));\n    jp.yz = complexx((jp.yz-jaw_back),jr)+jaw_back;\n    \n    /*\n    jaw_rot *= smoothstep(20.0, -10.0, jp.y-jp.z);\n    \n    jp = p;\n    jr = vec2(cos(jaw_rot), sin(jaw_rot));\n    jp.yz = complexx((jp.yz-jaw_back),jr)+jaw_back;\n    */\n\n    float mf = 0.0;\n    float mf2 = 0.0;\n    \n    //d = capsule(p, h, vec3(0.0, 0.0, 5.0+jaw), 10.0);\n    float toothplane = p.z+2.0-0.02*dot(p.xy, p.xy)+2.0*smoothstep(7.0, 10.0, length(p.xy))*smoothstep(8.0, -10.0, p.y)*cos(20.0*atan(p.y, p.x))-3.0;\n    float jtoothplane = -jp.z+2.0-0.02*dot(jp.xy, jp.xy)-2.0*smoothstep(7.0, 10.0, length(jp.xy))*smoothstep(8.0, -10.0, jp.y)*cos(20.0*atan(jp.y, jp.x))+3.0;\n    //toothplane *= 0.5;\n    //jtoothplane *= 0.5;\n    d = smax(capsule(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 5.0), 10.0), toothplane, 2.15);\n    d = smin(d, smax(capsule(jp, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 5.0), 10.0), jtoothplane, 2.15, mf), 2.1, mf2);    \n    m = vec4(d, 2.0, 0.0, 0.0);\n    //m.g -= mf*mf2;\n\n    //legs\n    d = 1000.0;\n    for(int i = 0; i < 3; i++)\n    {\n        d = smin(d, capsule(p, hip_pos[i], knee_pos[i]-hip_pos[i], 2.5), 0.6);\n        d = smin(d, capsule(p, knee_pos[i], ankle_pos[i]-knee_pos[i], 2.5), 0.6);\n        d = smin(d, capsule(p, ankle_pos[i], foot_pos[i]-ankle_pos[i], 2.5), 0.6);\n    }\n    \n    m.r = smin(m.r, d, 4.0, mf);\n    m.g += mf;\n\n    //eye\n    //c = vec3(0.,0.,0.4*pow(0.5*cos(phi)+0.5, 1.5));\n    d = sphere(p, vec3(4.5,-8.3,3.0), 2.25+0.1*sin(5.0*iTime));\n    d = min(d, sphere(jp, vec3(4.5,-8.3,3.0), 2.25+0.1*sin(5.0*iTime)));\n    d = min(d, sphere(jp, vec3(-3.5,-8.5,7.5), 2.25+0.1*sin(5.0*iTime)));\n    d = min(d, sphere(p, vec3(-3.5,-8.5,-1.5), 2.25+0.1*sin(5.0*iTime)));\n    \n    m.r = smin(m.r, d, 0.5, mf);\n    m.g -= mf;\n    \n    return m;\n}\n\nconst float spore_spacing = 100.0;\nvec3 get_sporepos(float spore_number, out float size, out float wiggle)\n{\n    vec3 c = vec3(0.0, spore_number*spore_spacing, 0.0);\n    c.x = 150.0*cos(75719.67*(spore_number));\n    if(abs(c.x) < 35.0) c.x = c.x <= 0.0 ? 35.0 : -35.0;\n    float h = sin(591829.32*spore_number);\n    float height = 90.0+40.0*h;\n    c.z = heightmap(c.xy).x+height;\n    size = 30.0+10.0*h;\n    wiggle = 0.5*sin(74188.59*spore_number)*sin((120.0/height)*iTime+pi*sin(39158.59*spore_number));\n    return c;\n}\n\n//stuff that does not cast a shadow\nvec4 transparent_map(vec3 p, out float glow_dist)\n{\n    vec4 m = vec4(100000.0, 0.0, 0.0, 0.0);\n    float d = 0.0;\n    //spore pods\n\n    //old_p.x += 0.2*sin(1.*iTime)*(p.z+10.0);\n    \n    glow_dist = 100000.0;\n    \n    float center_spore_number = round(p.y/spore_spacing);\n    for(float spore_number = center_spore_number-1.0+fZERO; spore_number <= center_spore_number+1.5; spore_number++) {\n        //p.y += 0.1*sin(2.0*iTime)*(p.z+10.0);\n        float size;\n        float wiggle;\n        vec3 c = get_sporepos(spore_number, size, wiggle);\n\n        float height = c.z;\n        vec3 r = p-c;\n        r.z += 40.0;\n        r.xz = mat2(cos(wiggle), sin(wiggle), -sin(wiggle), cos(wiggle))*r.xz;\n        r.z -= 40.0;\n        float pointy = smoothstep(20.0, 40.0, size);\n        r.z += 0.25*(length(r.xy)-size)*pointy;\n        d = length(r*vec3(1.0, 1.0, 1.0+1.0*pointy))-size;\n\n        float noise = value_noise(0.05*r+1.0*spore_number);\n        d += 5.0*noise;\n        glow_dist = min(glow_dist, d);\n        \n        //stem\n        \n        //p.y += 0.1*sin(2.0*iTime)*(p.z+10.0);\n        float t;\n        vec3 q = p;//+noise;\n        r = q-c;\n        r.z += 40.0;\n        wiggle *= smoothstep(-45.0, height, p.z);\n        r.xz = mat2(cos(wiggle), sin(wiggle), -sin(wiggle), cos(wiggle))*r.xz;\n        r.z -= 40.0;\n        r.x += 1.0*sin(wiggle+0.1*r.z+sin(69023.73*spore_number));\n        r.y += 1.0*sin(wiggle+0.1*r.z+sin(48723.73*spore_number));\n        r.z -= clamp(-height-45.0, 0.0, r.z);\n        d = smin(d, length(r)-2.5, 10.0, t);\n        \n        if(d < m.r) {\n            m.r = d;\n            m.g = 5.0+t;\n            //m.r *= 0.8;\n            m.z = spore_number;\n        }\n    }\n\n    return m;\n}\n\nvec4 map(vec3 p)\n{\n    vec4 m = solid_map(p);\n    float gd;\n    vec4 tm = transparent_map(p, gd);\n    if(tm.x < m.x) return tm;\n    return m;\n}\n\nvec4 map(vec3 p, out float glow_dist)\n{\n    vec4 m = solid_map(p);\n    vec4 tm = transparent_map(p, glow_dist);\n    if(tm.x < m.x) return tm;\n    return m;\n}\n\nvec3 get_normal(vec3 p)\n{\n    vec3 n = vec3(0.0);\n    for(int i = ZERO; i < 4; i++)\n    {\n        vec3 e = 2.0*invsqrt3*(vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-0.5);\n        n += e*map(p+0.05*e).r;\n    }\n    return normalize(n);\n}\n\nvec3 body_color = vec3(0.32,0.19,0.44);\nvec3 leg_color = vec3(0.18,0.11,0.24);\nvec3 eye_color = vec3(0.78,0.94,0.39);\nvec3 sporepod_outer = vec3(0.169,0.592,0.702);\nvec3 sporepod_color = vec3(0.16,0.46,0.45);\nvec3 sporepod_glow = vec3(0.4,0.95,0.94);\nvec3 fungus_color = vec3(0.953, 0.369, 0.6);\nvec3 mushroom_color1 = vec3(0.506, 0.62, 0.812);\nvec3 mushroom_color2 = vec3(1.0);\n\nvec4 raycast(inout vec3 p, vec3 d, float precission, out float hit_t, out vec3 volumetric)\n{\n    vec3 q = p;\n    vec3 hit_p = p;\n    vec4 m = vec4(0.0);\n    float t = 0.0;\n    hit_t = 10000.0;\n    vec4 hit_m = vec4(0.0);\n    float dt = 0.0;\n    for(int i = ZERO; i < 10; i++) { //move ray out if it starts inside something\n        float glow_dist;\n        m = transparent_map(p, glow_dist);\n        if(m.r >= 0.0) break;\n        t += 10.0;\n        p += 10.0*d;\n    }\n    for(int i = ZERO; i < 256; i++) {\n        float glow_dist;\n        m = map(p, glow_dist);\n        if(m.r > 400.0 && i >= 1 || t > 1000.0) break;\n\n        if(abs(m.r) < precission*t) {\n            hit_m = m;\n            hit_t = t;\n            hit_p = p;\n            break;\n        };\n\n        volumetric += min(0.2*clamp(dt, 0.0, 1.0)/max(glow_dist*glow_dist, 1.0), 0.1)*sporepod_glow;\n        \n        dt = m.r;\n        t += dt;\n        p += d*dt;\n    }\n    \n    \n    p = q;\n    t = 0.0;\n    \n    const float max_height = 60.0;\n    \n    if(p.z > max_height && d.z < 0.0) {\n        float dist = -(p.z-max_height)/d.z;\n        t += dist;\n        p += d*dist;\n    }\n    \n    float stepsize = 0.0;\n    float deltaz = 0.0;\n    float old_deltaz = 0.0;\n    for(int i = ZERO; i < 256; i++) {\n        float hm;\n        vec3 h = heightmap(p.xy, hm);\n        vec3 fh = fungus_heightmap(p, 5);\n        vec3 v = fh;\n        float ft;\n        v.x = smax(0.0, v.x, 1.0, ft);\n        v.yz *= ft;\n        h += v;\n        if(t > hit_t || (p.z > max_height && d.z > 0.0) || t > 1000.0) break;\n        deltaz = p.z-h.x-precission*t;\n        if(deltaz < 0.0) {\n            p += d*(deltaz*stepsize/(old_deltaz-deltaz));\n            if(fh.x > 0.0) {\n                m.g = 7.0;\n            } else {\n                m.g = hm;\n            }\n            m.zw = h.yz;\n            hit_m = m;\n            hit_t = t;\n            hit_p = p;\n            break;\n        }\n        old_deltaz = deltaz;\n        stepsize = max(0.1, 0.1*(p.z-h.x)+10.0*precission*t);\n        if(fh.x >= -1.0) {\n            volumetric += 0.1*stepsize/max(sq(max(p.z-h.x, 0.0)), 1.0)*fungus_color;\n        }\n        t += stepsize;\n        p += d*stepsize;\n    }\n    p = hit_p;\n    \n    return hit_m;    \n}\n\nfloat shadow(inout vec3 p, vec3 d, float precission, float max_dist, float size, out float hit_t)\n{\n    vec3 q = p;\n    float m = 0.0;\n    float pm = 1e20;\n    float t = 0.0;\n    hit_t = 10000.0;\n    vec4 hit_m = vec4(0.0);\n    float sh = 1.0;\n    \n    for(int i = ZERO; i < 64; i++) {\n        m = solid_map(p).x;\n        if(m > 200.0 && i >= 1 || t > max_dist) break;\n        \n        if(m < precission*t) {\n            return 0.0;\n            break;\n        };\n\n        float y = clamp(m*m/(2.0*pm), 0.0, 10.0);\n        float z = sqrt(m*m-y*y);\n        sh = min(sh, z/(size*max(0.0, t-y)));\n        \n        pm = m;\n        \n        t += m;\n        p += d*m;\n    }\n\n    //ground does not cast significant shadows in this scene\n    /*\n    p = q;\n    t = 0.0;\n    float stepsize = 0.0;\n    float deltaz = 0.0;\n    float old_deltaz = 0.0;\n    for(int i = 0; i < 150; i++)\n    {\n        vec3 h = heightmap(p.xy);\n        if(t > hit_t || t > max_dist) break;\n        deltaz = p.z-h.x-precission*t;\n        if(deltaz < 0.0)\n        {\n            sh = 0.0;//p += d*(deltaz*stepsize/(old_deltaz-deltaz));\n            break;\n        }\n        old_deltaz = deltaz;\n        stepsize = 1.0*(p.z-h.x)+precission*t;\n        t += stepsize;\n        p += d*stepsize;\n    }    \n    */\n    return sh;\n}\n\nfloat fungus_lighting(inout vec3 p, vec3 d, float precission, float size, out float hit_t)\n{\n    vec3 q = p;\n    float m = 0.0;\n    float pm = 1e20;\n    float t = 0.0;\n    hit_t = 10000.0;\n    vec4 hit_m = vec4(0.0);\n    float sh = 1.0;\n    \n    for(int i = ZERO; i < 64; i++) {\n        m = solid_map(p).x;\n        if(m > 400.0 && i >= 1 || t > 500.0) break;\n        \n        if(m < precission*t) {\n            return 0.0;\n        };\n        \n        vec3 h = heightmap(p.xy);        \n        vec3 fh = fungus_heightmap(p, 2);\n        if(p.z < h.x+fh.x) {            \n            sh *= smoothstep(-15.0, -10.0, fh.x);\n            break;\n        }\n\n        float y = clamp(m*m/(2.0*pm), 0.0, 10.0);\n        float z = sqrt(m*m-y*y);\n        sh = min(sh, z/(size*max(0.0, t-y)));\n        \n        pm = m;\n        \n        t += m;\n        p += d*m;\n    }\n\n    return sh;\n}\n\nfloat ao(in vec3 p, in vec3 n)\n{\n\tfloat sca = 3., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*0.5/5.;        \n        float d = solid_map(p + n*hr).r;\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);\n}\n\nfloat emap(vec3 d)\n{\n    float x = d.x;\n    float y = d.y;\n    float z = d.z;\n    float xx = x*x;\n    float yy = y*y;\n    float zz = z*z;\n\n    //cubic/spherical harmonics, normalizations are so integral of each term squared over a sphere is 1\n    float v =     \n    /*\n        +0.4886025119029199 * 0.8 * y\n        +0.4886025119029199 * 0.4 * z\n        +0.4886025119029199 * 0.2 * x\n    */\n        +1.0925484305920792 * 0.8 * x*y\n        +1.0925484305920792 * -0.3 * y*z\n        +0.31539156525252005 * -0.7 * (-1.0 + 3.0*zz)\n        +1.0925484305920792 * 0.5 * x*z\n        +0.5462742152960396 * 0.2 * (xx - yy)\n\n        -0.5900435899266435 * 0.4 * y*(-3.0*xx + yy)\n        +2.890611442640554 * -0.8 * x*y*z\n        +0.4570457994644658 * 0.3 * y*(-1.0 + 5.0*zz)\n        +0.3731763325901154 * -0.9 * z*(-3.0 + 5.0*zz)\n        +0.4570457994644658 * -0.3 * x*(-1.0 + 5.0*zz)\n        +1.445305721320277 * -0.1 * (xx - yy)*z\n        +0.5900435899266435 * 0.6 * x*(xx - 3.0*yy)\n        \n        +2.5033429417967046 * -0.3 * x*y*(xx - yy)\n        -1.7701307697799307 * -0.7 * y*(-3.0*xx + yy)*z\n        +0.9461746957575601 * -0.6 * x*y*(-1.0 + 7.0*zz)\n        +0.6690465435572892 * -0.3 * y*z*(-3.0 + 7.0*zz)\n        +0.10578554691520431 * 0.5 * (3.0 - 30.0*zz + 35.0*zz*zz)\n        +0.6690465435572892 * 0.9 * x*z*(-3.0 + 7.0*zz)\n        +0.47308734787878004 * -0.8 * (xx - yy)*(-1.0 + 7.0*zz)\n        +1.7701307697799307 * 0.4 * x*(xx - 3.0*yy)*z\n        +0.6258357354491761 * 0.1 * (xx*xx - 6.0*xx*yy + yy*yy)\n        \n        +0.6563820568401701 * 0.2 * y*(5.0*xx*xx - 10.0*xx*yy + yy*yy)\n        +8.302649259524165 * 0.7 * x*y*(xx - yy)*z\n        -0.4892382994352504 * 0.5 * y*(-3.0*xx + yy)*(-1.0 + 9.0*zz)\n        +4.793536784973324 * -0.9 * x*y*z*(-1.0 + 3.0*zz)\n        +0.45294665119569694 * 0.3 * y*(1.0 - 14.0*zz + 21.0*zz*zz)\n        +0.1169503224534236 * 0.5 * z*(15.0 - 70.0*zz + 63.0*zz*zz)\n        +0.45294665119569694 * -0.2 * x*(1.0 - 14.0*zz + 21.0*zz*zz)\n        +2.396768392486662 * -0.8 * (xx - yy)*z*(-1.0 + 3.0*zz)\n        +0.4892382994352504 * -0.6 * x*(xx - 3.0*yy)*(-1.0 + 9.0*zz)\n        +2.075662314881041 * -0.2 * (xx*xx - 6.0*xx*yy + yy*yy)*z\n        +0.6563820568401701 * -0.5 * x*(xx*xx - 10.0*xx*yy + 5.0*yy*yy)\n        ;\n    return pow(abs(0.4*v), 3.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0*fragCoord/iResolution.y-1.0*iResolution.xy/iResolution.y;\n    \n    calculate_animation(iTime);\n    \n    float fov = 60.0*pi/180.0;\n    float screen_dist = 1.0/tan(0.5*fov);\n    vec3 d = vec3(uv, -screen_dist);\n    d = normalize(d);\n    \n    vec3 q = vec3(120.0*sin(0.25*iTime),-120.0*cos(0.25*iTime),sin(0.5*golden_ratio*iTime)*20.0+30.0);\n    //vec3 q = vec3(240.0*sin(0.5*iTime),-240.0*cos(0.5*iTime),sin(iTime)*20.0+30.0);\n    //vec3 q = vec3(30.0,-30.0,-20.0);\n    //vec3 q = vec3(-100.0,100.0,70.0);\n    //vec3 q = vec3(140.0*sin(0.75*cos(iTime)),-140.0*cos(0.75*cos(iTime)),sin(iTime)*20.0+20.0);\n    //vec3 q = vec3(140.0*sin(10.5*cos(iTime)),-140.0*cos(20.5*cos(iTime)),sin(iTime)*100.0);\n    vec3 p = q + hamis_pos;\n    p.z = smax(p.z, 30.0+heightmap(p.xy).x, 10.0);\n    \n    /*\n    { //keep camera out of spore pods\n        float center_spore_number = round(p.y/spore_spacing);\n        for(float spore_number = center_spore_number-1.0+fZERO; spore_number <= center_spore_number+1.5; spore_number++) {\n            float size, wiggle;\n            vec3 c = get_sporepos(spore_number, size, wiggle);\n            vec2 r = p.xy-c.xy;\n            float dist = length(r);\n            p.xy = mix(p.xy, c.xy+40.0*normalize(r), smoothstep(80.0, 40.0, dist));\n        }\n    }\n    */\n    \n    vec3 p_rel = p-hamis_pos;\n    vec3 zhat = normalize(p_rel);\n    vec3 xhat = normalize(vec3(-p_rel.y, p_rel.x, 0.0));\n    vec3 yhat = cross(zhat, xhat);\n    d = mat3(xhat,yhat,zhat)*d;\n    \n    camera_pos = p;\n    \n    vec4 m = vec4(0.0);\n    vec3 emission = vec3(0.0);\n    \n    vec3 fog_color = vec3(0.05);\n    \n    vec3 color = fog_color;\n\n    float t = 0.0;\n    //raymarch\n    vec3 volumetric = vec3(0.0);\n    p += 20.0*d;\n    m = raycast(p, d, 0.0002, t, volumetric);\n    \n    if(m.r != 0.0)\n    {\n        vec3 lighting = vec3(0.0);\n        float specular_power = 40.0;\n        float specular_weight = 0.5;        \n\n        vec3 n = vec3(0.,0.,1.);\n        vec3 fungal_bias = vec3(0.0, 0.0, -1.0);\n        if(m.g == 4.0) {\n            n = normalize(vec3(-m.zw, 1.0));\n            color.rgb = mix(vec3(0.349, 0.298, 0.184), vec3(0.169, 0.145, 0.153), smoothstep(-2.0, 3.0, sin(0.1*p.x)+sin(0.1*p.y)+sin(p.z)));\n            fungal_bias.x = 2.0*(smoothstep(-10.0, 10.0, p.x)-0.5);\n            //fungal_bias.z = 1.0;\n        } else if(m.g == 7.0) {\n            n = normalize(vec3(-m.zw, 1.0));\n            color = 0.1*fungus_color;\n            emission = 1.5*fungus_color;\n        } else if(m.g == 8.0) {\n            n = normalize(vec3(-m.zw, 1.0));\n            color = mushroom_color1;\n        } else {\n            n = get_normal(p);\n            if(m.g < 2.0) {\n                color = mix(vec3(0.0), body_color, m.g-1.0);\n                emission = (2.0-m.g)*eye_color.rgb;\n            } else if(m.g <= 3.0) {\n                color = mix(body_color, leg_color, clamp(m.g-2.0, 0.0, 1.0));\n            } else if(m.g >= 5.0 && m.g <= 6.0) {\n                float eta = 0.85;\n                color = 0.3*sporepod_color;\n                //emission = sporepod_glow.rgb*(0.9*pow(1.0-abs(dot(n,d)), 2.0)+0.9*pow(abs(dot(n,d)), 20.0))+0.2*sporepod_color.rgb;\n                //emission = sporepod_outer.rgb*(pow(1.0*(1.0-abs(dot(n,d))), 1.0))+0.1*sporepod_color.rgb;\n                emission += (3.5-0.5*m.g)*sporepod_outer.rgb*(pow(clamp(abs(1.4-abs(dot(n,d))), 0.0, 1.05), 8.0))+0.1*sporepod_color.rgb;\n                float size;\n                float wiggle;\n                vec3 c = get_sporepos(m.z, size, wiggle);\n                \n                for(int i = 0; i < 12; i++) {\n                    vec3 r = p-c-0.5*size*hash3D(10.0*m.zw+7.5*float(i));\n                    r.z += 40.0;\n                    r.xz = mat2(cos(wiggle), sin(wiggle), -sin(wiggle), cos(wiggle))*vec2(r.x, r.z);\n                    r.z -= 40.0;                    \n                    emission += sporepod_glow.rgb*clamp(0.5*(1.0+(sq(dot(r, refract(d, n, eta)))-dot(r,r))/sq(3.0+1.0*hash(5.0*m.zw+2.5*float(i)))), 0.0, 1.0);\n                }\n                emission += 0.9*sporepod_glow.rgb*abs(emap(refract(d, n, eta)));\n                emission += 0.9*sporepod_glow.rgb*abs(emap(reflect(d, n)));\n                specular_power = 16.0;\n                specular_weight = 4.0;\n            }\n        }\n        \n        p += 0.15*n; //bias away from surface for shadow check\n        \n        float center_spore_number = round(p.y/spore_spacing);\n        float light_radius = 200.0;\n        float light_size = 15.0;\n        for(float spore_number = center_spore_number-2.0+fZERO; spore_number <= center_spore_number+2.5; spore_number++) {\n            float wiggle;\n            vec3 light_pos = get_sporepos(spore_number, light_size, wiggle);\n            light_pos.xz += 40.0*vec2(sin(wiggle), cos(wiggle)-1.0);\n            light_size *= 0.75;\n            vec3 light_dir = light_pos-p;\n            float dist = length(light_dir);\n            if(dist > light_radius) continue;\n            light_dir /= dist;\n            \n            vec3 q = p;\n            float lt = 0.0;\n            float sh = shadow(q, light_dir, 0.002, dist, 4.0*pi*(1.0-dist/sqrt(light_size*light_size+dist*dist)), lt);\n            float nl = dot(n, light_dir);\n            lighting += 1.5*sh*sporepod_glow.rgb*((clamp(nl, 0.0, 1.0)+specular_weight*pow(abs(nl), specular_power))*smoothstep(light_radius, light_radius-10.0, dist)/max(sq(dist*0.02), 0.5));\n        }\n        \n        if(m.g != 7.0 && m.g != 4.0){\n            vec3 h = heightmap(p.xy);\n            vec3 ref = reflect(d, n);            \n            for(float i = 0.0; i <= 1.0; i+=0.25) {\n                vec3 q = p;\n                float lt = 0.0;\n                vec3 light_dir = normalize(mix(fungal_bias, ref, 1.0*i)+0.2*hash3D(p.xy+10.0*i));\n                float sh = fungus_lighting(q, light_dir, 0.002, 4.0*pi, lt);\n                float fl = 2.0*sh*smoothstep(0.1, 2.0, p.z-h.x);                \n                lighting += fl*fungus_color;\n            }\n        }\n        if(m.g == 4.0) {\n            vec3 ref = reflect(d, n);\n            //lighting += 0.1*(abs(ref.x)+ref.y)*fungus_color;\n            lighting += 0.2*(1.0-n.y*n.y)*fungus_color;\n        }\n        \n        //lighting += clamp(0.1*emap(reflect(d, n)), 0.0, 1.0);\n        //lighting = clamp(lighting, 0.0, 1.0);\n\n        color.rgb *= lighting;\n        color.rgb += emission;\n    }\n    color += volumetric;\n    color.rgb = mix(color.rgb, fog_color, clamp(0.001*t, 0.0, 1.0));\n\n    color = clamp(color, 0., 1.);\n\n    // output to screen\n    fragColor.rgb = color;\n    fragColor.a = 1.0;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}