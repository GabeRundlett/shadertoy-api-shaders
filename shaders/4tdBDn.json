{
    "Shader": {
        "info": {
            "date": "1539377757",
            "description": "Apollonian gasket and fractal from GUIL in VR",
            "flags": 1,
            "hasliked": 0,
            "id": "4tdBDn",
            "likes": 28,
            "name": "VR Gasket",
            "published": 3,
            "tags": [
                "fractals",
                "apollonian",
                "vr"
            ],
            "usePreview": 0,
            "username": "shau",
            "viewed": 1764
        },
        "renderpass": [
            {
                "code": "// Created by SHAU - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n/*\nBased on Apollonian II by IQ and Apollonian structure by Shane\nTurbulance fractal based on Marble by Guil\n*/\n\n#define FAR 20.\n#define EPS 0.001\n#define T iTime * 1.\n#define R iResolution.xy\n#define SD .46\n\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\n//IQ cosine palattes\n//https://iquilezles.org/articles/palettes\nvec3 PT(float t) {return vec3(.5) + vec3(.5) * cos(6.28318 * (vec3(1) * t * 0.1 + vec3(0, .33, .67)));}\n\nvec3 tile(vec3 p) {\n    return abs(mod(p, 2.) - 1.); // - vec3(1.);\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;    \n}\n\nvec2 nearest(vec2 a, vec2 b){ \n    return mix(a, b, step(b.x, a.x));\n}\n\nvec3 map(vec3 p) {\n    \n    float scale = 1.;\n\n    vec3 q = p;\n    for (int i = 0; i < 8; i++) {\n        q = mod(q - 1., 2.) - 1.;\n        q -= sign(q) * (0.05 + sin(T * 0.14) * 0.02);\n        float k = (1.1 + sin(T * 0.1) * -0.1) / dot(q, q);\n        q *= k;\n        scale *= k;\n    }\n\n    float t = (.25 * length(q) / scale);\n    \n    p = tile(p);\n    float b = sdSphere(p - vec3(1), SD);\n    \n    return vec3(nearest(vec2(t, 1.), vec2(b, 2.)), b);\n}\n\n//tetrahedral normal\nvec3 normal(vec3 p) {  \n    vec2 e = vec2(-1., 1.) * EPS;   \n\treturn normalize(e.yxx * map(p + e.yxx).x + e.xxy * map(p + e.xxy).x + \n\t\t\t\t\t e.xyx * map(p + e.xyx).x + e.yyy * map(p + e.yyy).x);   \n}\n\n//IQ - https://iquilezles.org/articles/raymarchingdf\nfloat AO(vec3 p, vec3 n) {\n    float ra = 0., w = 1., d = 0.;\n    for (float i = 1.; i < 5.; i += 1.){\n        d = i / 5.;\n        ra += w * (d - map(p + n * d).x);\n        w *= .5;\n    }\n    return 1. - clamp(ra, 0., 1.);\n}\n\n//fractal from GUIL\n//https://www.shadertoy.com/view/MtX3Ws\nvec2 csqr(vec2 a) {return vec2(a.x * a.x - a.y * a.y, 2.0 * a.x * a.y);}\n\nfloat fractal(vec3 p) {\n\t\n\tfloat res = 0.0;\n\tfloat x = .7;\n    \n    p = tile(p);\n    p.yz *= rot(T * .6);\n    \n    vec3 c = p;\n\t\n    for (int i = 0; i < 10; ++i) {\n        p = x * abs(p) / dot(p, p) - x;\n        p.yz = csqr(p.yz);\n        p = p.zxy;\n        res += exp(-19. * abs(dot(p, c)));   \n\t}\n    return res / 2.;\n}\n\nfloat fractalMarch(vec3 ro, vec3 rd) {\n    \n    float c = 0., t = EPS;\n    \n    for (int i = 0; i < 50; i++) {\n        \n        vec3 p = ro + t * rd;\n        \n        vec3 q = tile(p);\n        float b = sdSphere(q - vec3(1), SD);\n        if (b > EPS) break;\n        \n        float bc = sdSphere(q - vec3(1), .01);\n        bc = 1. / (1. + bc * bc * 20.);\n        \n        float fs = fractal(p); \n        t += 0.02 * exp(-2.0 * fs);\n        \n        c += 0.04 * bc;\n    } \n    \n    return c;\n}\nvec3 render(vec3 ro, vec3 rd) {\n    \n    float mint = FAR;\n    \n    vec3 pc = vec3(0), bg = pc, gc = PT(T), p = pc;\n    vec3 ld = normalize(vec3(3., 4., -1.));\n    \n    //ray marching\n    float t = 0., id = 0.;\n    for (int i = 0; i < 96; i++) {\n        p = ro + rd * t;\n        vec3 ns = map(p);\n        if (ns.x < EPS || t > FAR) {\n            id = ns.y;\n            break;\n        }\n        \n        float lt = 1. / (1. + ns.z * ns.z * 140.);\n        bg += gc * lt * 0.03;\n        \n        t += ns.x;\n    }\n    \n    //*\n    if (id > 0.) {\n        \n        mint = t;\n        \n        vec3 n = normal(p);\n        float ao = AO(p, n);\n        float dif = max(dot(ld, n), 0.05);\n        float spc = pow(max(dot(reflect(-ld, n), -rd), 0.), 32.);\n        float frs = pow(clamp(dot(n, rd) + 1., 0., 1.), 2.);\n        \n        if (id == 1.) {\n            \n            //apollonian\n            pc = vec3(0.1) * dif;\n            pc += vec3(0.1, 0.2, 0.4) * max(n.y, 0.);\n            pc += gc * 0.6 * spc;\n        }\n        \n        if (id == 2.) {\n            \n            //ball\n            pc = gc * dif * 0.4;   \n            pc += gc * fractalMarch(p, rd) * (1. - frs) * .6;\n            pc += vec3(1) * spc; \n            frs = pow(clamp(dot(n, rd) + 1., 0., 1.), 2.) * 64.; \n            pc += gc * frs * 0.04 * dif; \n        }        \n        \n        pc *= ao;\n    }\n    //*/\n    \n    pc += bg;\n    pc *= exp(-0.2 * mint);\n    \n    return pc * 1.6;\n}\n\nvoid camera(vec2 U, inout vec3 ro, inout vec3 rd, inout vec3 la) {\n    \n    vec2 uv = (U - R * .5) / R.y;\n    \n    ro = la - vec3(0, sin(T * 0.2) * 0.3, -3.0); \n    ro.xz *= rot(T * 0.1);\n    \n    vec3 fwd = normalize(la - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x)); \n\n    rd = normalize(fwd + 1.4 * uv.x * rgt + 1.4 * uv.y * cross(fwd, rgt));\n}\n\nvoid mainImage(out vec4 C, vec2 U) {\n\n    vec3 ro, rd, la = vec3(-1, 1, -2);\n    camera(U, ro, rd, la);\n    \n    vec3 pc = render(ro, rd);\n    \n    C = vec4(pc,1.0);\n}\n\nvoid mainVR(out vec4 C, vec2 U, vec3 fro, vec3 frd) {    \n    \n    vec3 ro = fro + vec3(1, 1, T * -0.2); //camera\n    vec3 pc = render(ro, frd);\n\tC = vec4(pc, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}