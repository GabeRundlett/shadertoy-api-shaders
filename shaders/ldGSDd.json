{
    "Shader": {
        "info": {
            "date": "1467360340",
            "description": "A first test, trying to learn about distance fields. Nothing you haven't seen before since I borrowed code from iq and others. Thanks to iq for the great tutorials and examples, and the shadertoy community. Each visit here is inspiring and educational :)",
            "flags": 0,
            "hasliked": 0,
            "id": "ldGSDd",
            "likes": 4,
            "name": "First distance field test",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "distancefield"
            ],
            "usePreview": 0,
            "username": "Jacoby",
            "viewed": 736
        },
        "renderpass": [
            {
                "code": "const float EPS = 0.01;\nconst float FAR = 15.0;\nconst int MAX_STEPS = 128;\n\n// ----------------------------------------------------------------------------\nstruct Ray {\n    vec3 o;\n    vec3 d;\n};\n    \n// ----------------------------------------------------------------------------\nRay create(vec2 uv) {\n   \tvec2 p = (uv.xy / iResolution.xy) - 0.5;\n    p.x *= iResolution.x / iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n    Ray ray;\n    float time = (iTime + 13.0) * 0.25;\n\tfloat an1 = 0.2*time - 6.2831*mo.x;\n\tfloat an2 = clamp( 0.8 + 0.6*sin(2.2+time*0.11) + 1.0*mo.y, 0.3, 1.35 );\n    ray.o = 2.5*normalize(vec3(sin(an2)*cos(an1), cos(an2) - 0.25, sin(an2)*sin(an1)));\n    vec3 ww = normalize(vec3(0.0) - ray.o);\n    vec3 uu = normalize(cross(vec3(0.0, 1.0, 0.0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    ray.d = normalize(p.x*uu + p.y*vv + 2.0*ww);\n    return ray;\n}\n    \n// ----------------------------------------------------------------------------\nfloat sdTorus( vec3 p, vec2 t ) {\n    float c = 2.0;\n\tvec3 q = mod(p, c) - 0.5*c;\n    vec2 r = vec2(length(q.xz)-t.x,q.y);\n    return length(r)-t.y;\n}\n\n// ----------------------------------------------------------------------------\nfloat sdSphere(vec3 p, vec3 o, float r) {\n    float c = 2.0;\n    vec3 q = mod(p, c) - 0.5*c;\n\treturn length(o - q) - r;\n}\n\n// ----------------------------------------------------------------------------\nfloat dPlane(vec3 p, vec3 n, float d) {\n\treturn dot(p, n) - d;\n}\n\n// ----------------------------------------------------------------------------\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// ----------------------------------------------------------------------------\nfloat getDistanceToSurface(vec3 p) {\n    float a = iTime * 0.5 + dot(p, vec3(1.0));\n    float x = cos(a) * 0.25;\n    float y = sin(a) * 0.25;\n    vec3 offset = vec3(0.2)*sin(p.z + p.x + iTime);\n    float sphere = sdSphere(p + offset, vec3(x, y, 0), 0.2);\n    float torus = sdTorus(p + offset, vec2(0.35, 0.10));\n    \n    // There must be a better way to do this...\n    float d = min(sphere, torus);\n\treturn d > 10.0 ? d : smin(sphere, torus, 0.15);\t\t\t\t\n}\n\n// ----------------------------------------------------------------------------\nvec3 getPos(Ray ray, float t) {\n    return ray.o + ray.d * t;\n}\n\n// ----------------------------------------------------------------------------\nfloat rayMarch(Ray ray) {\n\tfloat t = 0.0, d;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        d = getDistanceToSurface(getPos(ray, t));\n        if(d < EPS) break;\n        t += d * 0.5;\n    }\n    return t;\n}\n\n// ----------------------------------------------------------------------------\nvec3 getNormal(vec3 p) {\n\tvec3 eps = vec3(EPS, 0.0, 0.0);\n\tvec3 n = vec3(\n\t    getDistanceToSurface(p+eps.xyy) - getDistanceToSurface(p-eps.xyy),\n\t    getDistanceToSurface(p+eps.yxy) - getDistanceToSurface(p-eps.yxy),\n\t    getDistanceToSurface(p+eps.yyx) - getDistanceToSurface(p-eps.yyx) );\n\treturn normalize(n);\n}\n\n// ----------------------------------------------------------------------------\nvec4 getDiff(vec3 n) {\n    return mix(vec4(0.1), vec4(0.8), n.y + 1.0);\n}\n\n// ----------------------------------------------------------------------------\nvec4 getSpec(samplerCube samp, Ray ray, vec3 n) {\n    vec3 r = reflect(ray.d, n);\n    vec4 spec = texture(samp, r);\n    return 0.1 * pow(spec * 2.0, vec4(5.0));\n}\n\n// ----------------------------------------------------------------------------\nvec4 getTexture(sampler2D samp, vec3 p, vec3 n, float s) {\n\treturn texture(samp, p.yz * s) * abs(n.x) +\n\t\t   texture(samp, p.xz * s) * abs(n.y) +\n\t\t   texture(samp, p.xy * s) * abs(n.z);\n}\n\n// ----------------------------------------------------------------------------\nvec4 getRandomColorFromPosition(sampler2D samp, vec3 p) {\n    vec3 offset = vec3(0.2)*sin(p.z + p.x + iTime);\n    p += offset;\n    vec2 uv = p.xz * (1.0 / 128.0);\n    uv += vec2(floor(p.y+0.5), 0.0) * (1.0 / 16.0);\n    return vec4(normalize(texture(samp, uv).rgb), 1.0);\n}\n\n// ----------------------------------------------------------------------------\nvec4 getAlbedo(sampler2D samp, vec3 p, vec3 n) {\n    vec4 albedo = getTexture(iChannel1, p, n, 1.0).rrrr;\n    return albedo * getRandomColorFromPosition(iChannel2, p);\n}\n\n// ----------------------------------------------------------------------------\nfloat getFres(Ray ray, vec3 n) {\n    return 0.05 + pow(1.0 - max(dot(-n, ray.d), 0.0), 2.0);\n}\n\n// ----------------------------------------------------------------------------\nfloat getAO(vec3 p, vec3 n) {\n\tfloat occ = 0.0;\n    float s = 1.0;\n    for(int i = 0; i < 5; i++) {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos = n * hr + p;\n        float dd = getDistanceToSurface( aopos );\n        occ += -(dd-hr)*s;\n        s *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );    \n}\n\n// ----------------------------------------------------------------------------\nvec4 compositeTerms(vec4 diff, vec4 spec, vec4 albedo, float fres, float ao) {\n    return ao * (diff * albedo + spec * fres);\n}\n\n// ----------------------------------------------------------------------------\nvec4 fadeColor(vec4 a, vec4 b, float t) {\n    return mix(sqrt(a), b, clamp(2.0*t/FAR - 1.0, 0.0, 1.0));\n}\n\n// ----------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor, vec2 uv) {\n\tRay ray = create(uv);\n\tfloat t = rayMarch(ray);\n    \n    fragColor = texture(iChannel0, ray.d);\n    if(t > FAR) {\n        return;\n    }\n    \n    vec3 p = getPos(ray, t);\n    vec3 n = getNormal(p);\n    vec4 diff = getDiff(n);\n\tvec4 spec = getSpec(iChannel0, ray, n);\n    vec4 albedo = getAlbedo(iChannel1, p, n);\n    float fres = getFres(ray, n);\n    float ao = getAO(p, n);\n    vec4 color = compositeTerms(diff, spec, albedo, fres, ao);\n    \n    vec3 light = vec3(1.0f, 1.0f, 0.0f);\n    float lit = max(dot(light, n), 0.0f);\n    \n    fragColor = fadeColor(color, fragColor, t);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}