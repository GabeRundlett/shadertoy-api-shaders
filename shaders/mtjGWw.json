{
    "Shader": {
        "info": {
            "date": "1673422301",
            "description": "faster and seems bug free?\n\nit's wrong and it can't normalize vec3. but i think the case of a common line with vec3(1) is usually much rarer.\n\nAMD Radeon Pro 5500 XT 8 GB 20000 TIMES 840x472\nOLD 17.7 FPS | NEW 33.1 FPS",
            "flags": 0,
            "hasliked": 0,
            "id": "mtjGWw",
            "likes": 10,
            "name": "Cheaper orthonormal basis?",
            "published": 3,
            "tags": [
                "technique",
                "tangent",
                "orthonormal"
            ],
            "usePreview": 0,
            "username": "shaofun",
            "viewed": 426
        },
        "renderpass": [
            {
                "code": "// modified from https://www.shadertoy.com/view/4sSSW3\n\n//#define NEW_WAY\n#define TIMES 20000\n\n#define ITR 80\n#define FAR 10.\n#define time iTime\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nfloat map(vec3 p)\n{\n\tp.x += sin(p.z*5.+sin(p.y*5.))*0.3;\n    return (length(p)-1.)*0.7;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float d = 0.;\n    for( int i=0; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n\t    float res = map(ro+rd*d);\n        h = res;\n    }\n\treturn d;\n}\n\nvec3 normal(const in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.005;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\n#if defined(NEW_WAY)\nvoid TBN(in vec3 N, out vec3 T, out vec3 B) {\n    // it's wrong and it can't normalize vec3. \n    // but i think the case of a common line with vec3(1) is usually much rarer.\n    // from HK-SHAO https://www.shadertoy.com/view/ddSSWy\n    \n    // T = cross(N, normalize(vec3(1))); // slower\n    // T = vec3(-N.z, 0, N.x); // bug\n    // T = cross(N, vec3(1)); // it is ok\n    // T = vec3(N.y-N.z, N.z-N.x, N.x-N.y); // cheaper\n    // B = cross(N, T);\n    \n    // thxs iq and elenzil\n    // from https://graphics.pixar.com/library/OrthonormalB/paper.pdf\n    float s = sign(sign(N.z) + 0.5);\n    float a = -1.0 / (s + N.z);\n    float b = N.x * N.y * a;\n    T = vec3(1.0 + s * N.x * N.x * a, s * b, -s * N.x);\n    B = vec3(b, s + N.y * N.y * a, -N.y);\n}\n\n\n\n#else\n// from https://doi.org/10.1080/2165347X.2012.689606\nvoid TBN(in vec3 N, out vec3 T, out vec3 B) {\n    if (N.z < -0.999999) {\n        T = vec3(0, -1, 0);\n        B = vec3(-1, 0, 0);\n    } else {\n        float a = 1.0 / (1.0 + N.z);\n        float b = -N.x*N.y*a;\n        \n        T = vec3(1.0 - N.x*N.x*a, b, -N.x);\n        B = vec3(b, 1.0 - N.y*N.y*a, -N.y);\n    }\n}\n#endif\n\n\n//from iq (https://www.shadertoy.com/view/4slGz4)\nvec3 dLine(in vec3 ro, in vec3 rd, in vec3 a, in vec3 b)\n{\n\tvec3 ba = b - a;\n\tvec3 oa = ro - a;\n\tfloat oad  = dot( oa,  rd );\n\tfloat dba  = dot( rd, ba );\n\tfloat baba = dot( ba, ba );\n\tfloat oaba = dot( oa, ba );\n\t\n\tvec2 th = vec2( -oad*baba + dba*oaba, oaba - oad*dba ) / (baba - dba*dba);\n\t\n\tth.x = max(th.x, 0.);\n\tth.y = clamp(th.y, 0., 1.);\n\t\n\tvec3 p = a + ba*th.y;\n\tvec3 q = ro + rd*th.x;\n\t\n\treturn vec3( length( p-q ), th );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(0.8,0.1):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n\t//camera\n\tvec3 ro = vec3(0.,0.,4.5);\n    vec3 rd = normalize(vec3(p,-1.5));\n    vec3 rd2 = vec3(0,0.,-1);\n    mat2 mx = mm2(mo.x*6.);\n    mat2 my = mm2(mo.y*6.); \n    ro.xz *= mx;rd.xz *= mx;rd2.xz *= mx;\n    ro.xy *= my;rd.xy *= my;rd2.xy *= my;\n\t\n    vec3 ligt = normalize( vec3(-.5, 0.2, -0.2) );\n    vec3 lcol = vec3(1.00,0.90,0.75);\n    float rdl = clamp(dot(rd,ligt),0.,1.);\n    vec3 col = lcol*pow(rdl,50.) + vec3(0.1,0.2,0.3)*0.5;\n    \n\tfloat rz = march(ro,rd);\n    \n    if ( rz < FAR )\n    {\n        vec3 pos = ro+rz*rd;\n        vec3 nor= normal(pos);\n        float dif = clamp( dot(nor, ligt), 0., 1. );\n        float bac = clamp( dot(nor, -ligt),0., 1.);\n        float spe = pow(clamp(dot(reflect(rd,nor), ligt), 0., 1.),100.);\n        float fre = 0.6*pow( clamp(1. + dot(nor,rd),0.0,1.0), 2.);\n        vec3 brdf = 1.0*vec3(0.10,0.11,0.13);\n        brdf += 2.*bac*vec3(0.15,0.15,0.15);\n        brdf += 1.50*dif*lcol;\n        col = vec3(0.3,0.3,0.3);\n        col = col*brdf + col*spe + fre*col;\n    }\n    \n    \n    vec3 pdir = vec3(0.5773);\n    pdir.xz *= mm2(time*0.3);\n    pdir.zy *= mm2(time*.44);\n    float rz2 = march(pdir*3.,-pdir);\n    vec3 bpos = pdir*3.+rz2*-pdir;\n\t\n    vec3 nor= normal(bpos);\n    vec3 r = vec3(0);vec3 f = vec3(0);\n    \n    for (int i = 0; i < TIMES; i++) {\n        TBN(nor,f,r);\n    }\n    \n    \n    vec3 g = dLine(ro,rd,bpos,bpos+nor);\n    float occ = step(g.y, rz)*0.5+0.5;\n    col = max(col,smoothstep(-2.5,1.,sin(g.z*120.))*occ*vec3(.3,.3,1)*(1.-smoothstep(0.0,.03,g.x)));\n\n    g = dLine(ro,rd,bpos,bpos+f);\n    occ = step(g.y, rz)*0.5+0.5;\n    col = max(col,smoothstep(-2.5,1.,sin(g.z*120.))*occ*vec3(1.,.2,.2)*(1.-smoothstep(0.0,.03,g.x)));\n\n    g = dLine(ro,rd,bpos,bpos+r);\n    occ = step(g.y, rz)*0.5+0.5;\n    col = max(col,smoothstep(-2.5,1.,sin(g.z*120.))*occ*vec3(.2,1,.2)*(1.-smoothstep(0.0,.03,g.x)));\n    \n\tfragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}