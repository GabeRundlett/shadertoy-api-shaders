{
    "Shader": {
        "info": {
            "date": "1585659613",
            "description": "potato",
            "flags": 32,
            "hasliked": 0,
            "id": "tssyW2",
            "likes": 12,
            "name": "Day 103",
            "published": 3,
            "tags": [
                "mograph",
                "motiongraphics"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 399
        },
        "renderpass": [
            {
                "code": "// Fork of \"Day 102\" by jeyko. https://shadertoy.com/view/3dfcW2\n// 2020-03-31 09:25:47\n\n// Fork of \"Day 101\" by jeyko. https://shadertoy.com/view/WslyWS\n// 2020-03-30 07:59:19\n\n// radiual chromab in this buffer\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n\tfragColor = vec4(0);\n    // Radial blur\n    float steps = 16.;\n    float scale = 0.00 + pow(dot(uvn,uvn),1.1)*0.0;\n    float chromAb = pow(length(uv - 0.5),1.5)*4.2;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n        scale *= 0.97;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1.4/iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    fragColor += radial;\n    \n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.);\n    fragColor = max(fragColor, 0.);\n    //fragColor *= 1. - dot(uvn,uvn)*1.   ;\n    fragColor = pow(fragColor, vec4(0.4545 ));\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\nfloat xch(float d, float b){\n\treturn b < 0. ? 1.0 - d : d;\n}\n\n// from https://necessarydisorder.wordpress.com/\nfloat ease(float p, float g) {\n    if(p < 0.){\n        return 0.;\n    } else if(p > 1.){\n    \treturn 1.;\n    } else {\n        if (p < 0.5) \n            return 0.5 * pow(2.*p, g);\n        else\n            return 1. - 0.5 * pow(2.*(1. - p), g);\n    }\n}\n\nfloat ease(float p, float power, float jump, float offs, float end) {\n    float j = p;\n    p *= offs;\n    float r = (1.-cos(pi*p))/2.*jump;\n    r = pow(r, power);\n    r = mix(r, 1., pow(smoothstep(0.,1.,j),end));\n\treturn r;\n}\nfloat smease(float p, float g) {\n    float s = p;\n    for(float i = 0.; i < g; i++){\n    \ts = smoothstep(0.,1.,s);\n    }\n    return s;\n}\n\n\nfloat sdBox(vec2 p, vec2 s){\n\tp = abs(p) - s;\n\treturn max(p.x, p.y);\n}\n\nfloat sdBoxHalf(vec2 p, vec2 s, vec2 dir){\n    vec2 q = p;\n\tp = abs(p) - s;\n\tfloat d = max(p.x, p.y);\n    \n    d = max(d, -dot(q, dir) - 0.0045);\n    \n    return d;\n}\n\n\nconst float speed = 0.65;\nfloat[] scenes = float[3](1.*speed,1.5*speed, 0.6*speed); \n\nfloat S = 0.5;\nvec3 get( vec2 fragCoord  )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;    \n    uv *= 2.;\n    float col = 0.;\n    \n    float d = 10e6;\n    \n    float bA;\n    float bB;\n    float bC;\n    float bD;\n    float bE;\n    \n    float pl;\n    \n    float t = iTime;\n    \n    //t += scenes[0];\n    //t += scenes[1] - 0.0;\n    //t += scenes[2] - 0.1;\n    uv *= rot(pi*0.25);\n    t = mod(t, scenes[0] + scenes[1] /* + scenes[2]*/  );\n    \n    float offsamt = 0.5;\n    float offs = -S*offsamt;\n    float offsB = S*(1. - offsamt);\n    \n    \n    if(t < scenes[0]){\n        //float env = ease(t/scenes[0], 2.);\n        float lsp = 1.5;\n        float env = ease(t/scenes[0]*lsp, 1., 1.24, 0.96, 10.);\n        \n        float mov = env * offs*0.;\n        mat2 r = rot(0.*pi);\n        bE = sdBox(uv, vec2(S));\n        \n        float h = 1.43;\n        uv *= rot(0.25*pi);\n        bA = sdBox( (uv - vec2(S/2.,S/2.)*h)*r , vec2(S*env)*0.7);\n        bB = sdBox((uv + vec2(S/2. ,S/2. )*h)*r, vec2(S*env)*0.7);\n        bC = sdBox((uv - vec2(S/2. ,-S/2. )*h)*r, vec2(S*env)*0.7);\n        bD = sdBox((uv + vec2(S/2. ,-S/2. )*h)*r, vec2(S*env)*0.7);\n        col = xch(col,bE);\n        col = xch(col,bA);\n        col = xch(col,bB);\n        col = xch(col,bC);\n        col = xch(col,bD);\n        \n        \n        uv *= rot(0.25*pi);\n        bE = sdBox(uv, vec2(S)*1.);\n        \n        if(t > scenes[0]/lsp*0.74)\n        \tcol -= step(0.,-bE);\n    \n    } else if(t < scenes[1] + scenes[0]){\n        t -= scenes[0];\n        \n        float lsp = 2.;\n        float env = ease(t/scenes[1]*lsp, 1., 1.04, 0.96, 10.);\n        \n        float envb = ease(t/scenes[1]*lsp*1.45, 6., 1.0, 0.93, 25.)*0.01*S;\n        \n        float mov = env * offs*0.;\n        mat2 r = rot(1.*pi*env);\n        bE = sdBox(uv, vec2(S));\n        \n        float h = 1.43;\n        uv *= rot(0.25*pi);\n        bA = sdBoxHalf( (uv - vec2(S/2. - envb,S/2.- envb)*h)*r , vec2(S)*(0.7 ), vec2(1.));\n        bB = sdBoxHalf((uv + vec2(S/2. - envb,S/2. - envb)*h)*r, vec2(S)*(0.7 ), vec2(-1.));\n        bC = sdBoxHalf((uv - vec2(S/2.- envb ,-S/2.+ envb )*h)*r, vec2(S)*(0.7 ), vec2(0.5,-0.5));\n        bD = sdBoxHalf((uv + vec2(S/2. - envb,-S/2.+ envb  )*h)*r, vec2(S)*(0.7), vec2(-0.5,0.5));\n        \n        \n        col += step(0.,-bA);\n        col += step(0.,-bB);\n        col += step(0.,-bC);\n        col += step(0.,-bD);\n        \n        if(t > scenes[1]/lsp*0.88){\n            t -= scenes[1]/lsp*0.88;\n            uv *= 1. +  ease(t*0.6 + 0.47, 70., 1.0, pi/1.6, 2000000000.)*0.05*mix(1., 0., smoothstep(0.,1.,t*4.));\n        \tuv *= rot(-0.25*pi);\n            col -= col;\n        \tcol += step(0.,-sdBox(uv, vec2(S)));\n        }        \t\n        \n        \n    }  \n    \n    return vec3(col);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;  \n    vec3 col = vec3(0);\n    \n    float aa = 5.;\n    \n    for(float i =0.; i < aa*aa + min(float(iFrame),0.); i++){\n    \tcol += get(fragCoord + vec2(mod(i,aa),floor(i/aa))/aa);\n    }\n    col /= aa*aa;\n    \n    col = clamp(col, 0., 1.);\n    col *= 0.999;\n    col = 1. - col;\n    \n    \n    \n    //col *= max((1. + 1.*cos(iTime*1.+length(uv)*2.+vec3(4,2.5,1.5)))*1., 0.);\n    //col *= max((1.5 + 1.4*cos(iTime+length(uv)*2.+vec3(1,1.5,1.5)))*1., 0.);\n    \n    col *= 1. - pow(smoothstep(0.,1.,dot(uv,uv)*0.9),0.9)*1.;\n    //col = 1. - col;\n    \n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}