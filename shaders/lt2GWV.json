{
    "Shader": {
        "info": {
            "date": "1459571670",
            "description": "Just a quick forward depth of field/motion blur test with Nyan cats. Enjoy!",
            "flags": 0,
            "hasliked": 0,
            "id": "lt2GWV",
            "likes": 21,
            "name": "Nyan Infinity",
            "published": 3,
            "tags": [
                "nyan"
            ],
            "usePreview": 0,
            "username": "NBickford",
            "viewed": 1504
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415926535897\n\nvec3 rotY(vec3 p,float a){\n    float cs=cos(a);\n    float ss=sin(a);\n    return vec3(p.x*cs+p.z*ss,p.y,-p.x*ss+p.z*cs);\n}\n\nvec3 rotZ(vec3 p,float a){\n    float cs=cos(a);\n    float ss=sin(a);\n    return vec3(p.x*cs-p.y*ss,p.x*ss+p.y*cs,p.z);\n}\n\nvec2 rot2(vec2 p, float a){\n    float cs=cos(a);\n    float ss=sin(a);\n    return vec2(p.x*cs-p.y*ss,p.x*ss+p.y*cs);\n}\n\nvec3 gamma(vec3 c, float p){\n    return vec3(pow(c.r,p),pow(c.g,p),pow(c.b,p));\n}\n\nvec3 nyan(vec3 ci, vec3 co, float time, float blurAmount){\n    vec3 col=vec3(0,0,0);\n    float d=20.0;\n    vec3 spec=vec3(0.);\n\n    for(int i=2;i<20;i++){\n        float fi=float(i);\n        //(ci+co*t).z==i =>\n        float t=(fi-ci.z)/co.z;\n        vec3 p=ci+co*t;\n        //golden ratio shifting\n        p+=vec3(2.*0.618*fi+sin(fi),2.*1.618*fi,0.);\n        vec3 pm2=mod(p,2.); //finds intersection with a comic\n        \n        if(pm2.x<0.848 && pm2.y<1.){\n            vec2 nc=vec2(pm2.x/0.848,1.-pm2.y); //individual coordinates\n            nc.x=mod((nc.x+floor(time-p.z*0.1))*40./256.,6.0*40./256.);\n            d=t;\n            \n            //Nyan cat\n            col=gamma(texture(iChannel0,nc).rgb,2.2);\n            //col=vec3(nc.x,nc.y,0.0);\n            //specular reflection yay\n            //reflected ray's direction will be p-ci with z negated\n            float i = floor(p.x)+32.*floor(p.y);\n            vec3 n = normalize(vec3(sin(i+time)*0.1,cos(i)*0.1,1.0));\n            vec3 ray = reflect(p-ci,n);\n            \n            ray = normalize(ray);\n            spec=texture(iChannel1,ray.xyz).rgb;\n            break;\n        }\n    }\n    \n    //fog\n    col=mix(gamma(vec3(0.12,0.3,0.4),2.2),col,exp(-0.2*(abs(d)-2.0)));\n    \n\t//fragColor = vec4(col,1.0);\n    col=mix(col,col*spec,0.3);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //flying rectangles\n    \n\tvec2 uv = (fragCoord.xy-0.5*iResolution.xy) / iResolution.x;\n    //distortion\n    //v*=(1.+pow(dot(uv,uv),2.0));\n    \n    float time=iTime;\n    vec3 tot=vec3(0.);\n    float rot=fragCoord.x+29.*fragCoord.y;\n    \n    float focusScale=0.1;\n    float focusZ=pow(2.0,4.*iMouse.x/iResolution.x);//(1.-iMouse.z)*4.+iMouse.z*iMouse.x/iResolution.x*16.0;\n    \n    float r2=time*0.00; //to add rotation\n    \n    for(int s=0;s<8;s++){\n        vec3 samp=texture(iChannel2,(fragCoord.xy+vec2(21.*float(s),0.))/iChannelResolution[2].x).xyz;\n        vec2 os=samp.xy;\n        os-=vec2(0.5);\n        vec2 v = uv+os.yx/iResolution.x; //pseudo-multisampling!\n        \n        float nt=time+0.005*samp.z; //motion blur! Or not.\n        \n        \n        //between +-pi/4, r=1/cos(th) ...\n        float th=atan(os.y,os.x);\n        //mod round to nearest pi/2 for circularish bokeh\n        th=mod(th+PI/4.,PI/2.)-PI/4.;\n        os*=cos(th);\n        \n        //Correction functions. This produces flat circular bokeh:\n        //float correction=-0.5;\n        //os*=pow(length(os),correction);\n        \n        //This produces bokeh that tapers off nicely at the edges:\n        float radius=length(os);\n        radius*=1.41;\n        os*=(1.-sqrt(1.-radius))/radius;\n        \n\n        \n    \tvec3 ci=vec3(nt,nt,0.0);\n    \tvec3 co=vec3(v.x,v.y,1.);\n        \n        ci=rotY(ci,-0.8-r2);\n    \n        //focus transformations\n        ci+=vec3(os.x,os.y,0.0)*focusScale;\n        ci=rotY(ci,0.8+r2);\n        \n       \t\n        //Let's say c=vec3(os.x,os.y,0.0)*focusScale.\n        //At focusZ, ci+c+(co+c*q)*t=ci+co*t.\n        //In other words, when t=(focusZ-ci.z)/co.z, \n        //c+(c*q)*t=0.\n        //So c*(q*t+1)=0.\n        //So q*t=-1, and so q=-co.z/(focusZ-ci.z)\n        float q=-co.z/(sign(rotY(co,0.8+r2).z)*focusZ-ci.z); //two foci\n        \n        co+=vec3(os.x,os.y,0.0)*focusScale*q;\n        \n    \tco=rotY(co,0.8+r2);\n    \t//planes at z=1,2,3...\n\n    \tvec3 col=nyan(ci,co,nt,focusScale*q);\n        tot+=col;\n    }\n    \n    tot/=8.0;\n    \n    fragColor=vec4(tot,1.0);\n    fragColor.rgb = gamma(fragColor.rgb,0.45);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}