{
    "Shader": {
        "info": {
            "date": "1569687931",
            "description": "My first cubemarching thingy :) Hope you like it!",
            "flags": 0,
            "hasliked": 0,
            "id": "Wd33DB",
            "likes": 5,
            "name": "sphere marching",
            "published": 3,
            "tags": [
                "ray",
                "sphere",
                "marching"
            ],
            "usePreview": 0,
            "username": "Angramme",
            "viewed": 349
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 200\n#define MIN_DIST .01\n#define MAX_DIST 200.\n\n\n\nfloat sdTorus( vec3 p, vec2 t ){\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat GetDist(vec3 p){\n    float plane = p.y + .1;\n    //float sphere = length(vec3(-2., 2., 5) - p) - 1.;\n    //float sphere2 = length(vec3(0., 2.5, 4.5) - p) - .8;\n    //float wut = min(sphere, sphere2);\n    \n    float size = 5.;\n    vec3 id = floor(vec3(p.x, min(p.y, 5.), p.z) / size);\n    \n    vec3 pos = vec3(id*size+size*.5);\n    float wut = distance(pos, p) - 1.;\n    //float wut = sdTorus((p-pos)*vec3(1,1.5,1), vec2(.8));\n    \n    \n \treturn min(plane, wut);   \n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return n/e.x;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd){\n    float d0 = 0.;\n    float minD = MAX_DIST*99.;\n    \n    for(int x = 0; x < MAX_STEPS; x++){\n        vec3 p = ro + rd * d0;\n        float dS = GetDist(p);\n        d0 += dS;\n        if(dS < minD)minD = dS;\n        if(dS < MIN_DIST || d0 > MAX_DIST)break;\n    }\n    \n    return vec2(d0, minD);\n}\n\n\nvec3 GetColor(vec3 p){\n    return p.y > .99 ? \n        (mod(dot(floor(p/5.),vec3(1)), 2.) == 0. ? vec3(1,.2,.2) : vec3(.5,.5,1)) : \n    \t(mod(dot(floor(p.xz*1.),vec2(1)), 2.) == 0. ? vec3(1) : vec3(.8));\n}\n\n\nvec3 GetMaterial(vec3 p, vec3 n){\n    vec3 col = vec3(0);\n    \n    //diffuse\n    vec3[] lights = vec3[](\n        vec3(-5. + iTime*2., 100., 200.),\n        vec3(0. + iTime*2., 10., -1.)\n            );\n    \n    vec3[] light_colors = vec3[](\n        vec3(1., .9, .9) * .5,\n        vec3(.9, .8, .8)\n        \t);\n    \n    for(int i=0; i<lights.length(); i++){\n        vec3 light = lights[i];\n        \n        vec3 lmp = light - p;\n        float ld = length(lmp);\n        vec3 l = lmp / ld;\n    \n    \t//shadow\n    \tfloat pneumbra = .1 + ld * .005;\n        vec2 sd = RayMarch(p + n * (.02+pneumbra), l);\n        float shadow = sd.x < MAX_DIST ? .0 : (sd.y < pneumbra ? sd.y/pneumbra : 1.);\n        \n    \tfloat lum = max(0., dot(n, l));\n        col += lum * light_colors[i] * shadow;\n    }\n    \n    return col * GetColor(p);\n}\n\nvec3 R3(vec3 p){\n    return fract(cross(sin(p*vec3(872234.85, 312348.77137, 44456.82)), vec3(.2179, 1.5215, 2.155411)));  \n}\nfloat R1(vec3 p){\n    return fract(dot(sin(p*vec3(31189.3, 74.5542, 9511.332)), vec3(1.5486, .5915, 3.14851)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    float angle = -iMouse.x*.003 + iTime * .1;\n    float sa = sin(angle);\n    float ca = cos(angle);\n    mat2 yrotm = mat2(ca, -sa, sa, ca);\n    \n    float fov = 1.;\n    vec3 ro = vec3(sin(-angle*1.)*-10. + iTime *2., sin(iTime*.5 + iMouse.y*0.01)*5. + 5.2, cos(-angle*1.)*-20. + 4.);\n    //vec3 ro = vec3(iTime * 2. + 5., 5., 2.);\n    vec3 rd = normalize( vec3(uv.xy * fov, 1) );\n    rd.xz *= yrotm;\n    \n    vec2 rm = RayMarch(ro, rd);\n    if(rm.x > MAX_DIST){\n        //col = vec3(.5,.5,1.);\n    }else{\n        //ambient\n        //col += vec3(.5,.5,1.) * .1;\n        \n        //base\n    \tvec3 p = ro + rd * rm.x;\n        //randomized \"rough\" normal\n    \tvec3 n = normalize(GetNormal(p) + R3(p) * .01 \n                           + vec3(sin(p.x*7.15),1.,sin(p.z*1.37))*.01  );\n        \n    \tcol += GetMaterial(p, n);\n    \n    \t//reflection\n        vec3 r = reflect(rd, n);\n        vec2 rrm = RayMarch(p + n*.02, r);\n        vec3 p2 = rrm.x * r + p;\n        vec3 n2 = GetNormal(p2);\n    \n    \tcol += GetMaterial(p2, n2) * GetColor(p) * mix(.6, .0, dot(-rd, n));\n    }\n    \n    // Output to screen\n    fragColor = vec4(col * .8,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}