{
    "Shader": {
        "info": {
            "date": "1725327714",
            "description": "a.k.a. US road system truchet\n\nInspired by shane/mrange's multi-scale truchets. Thanks fabrice aswell for the permutation code I ripped :D\n\nExplanation in common tab",
            "flags": 0,
            "hasliked": 0,
            "id": "4fSfRd",
            "likes": 14,
            "name": "Random Matching Truchet",
            "published": 3,
            "tags": [
                "truchet",
                "pattern",
                "tiling"
            ],
            "usePreview": 0,
            "username": "SnoopethDuckDuck",
            "viewed": 128
        },
        "renderpass": [
            {
                "code": "#define R iResolution.xy\n#define ss(x) smoothstep(2./R.y, -2./R.y, x)\n\n// from Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// from iq\n// https://www.shadertoy.com/view/3tdSDj\nfloat seg( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// from fabrice\n// https://www.shadertoy.com/view/lXlSzf\nint shuffle0(int x, int h1, int h2) \n{  \n    return (h1 + h2*x*x*x) % 17; // permutation polynomial\n}\n\nint shuffle(int x, int h1, int h2) \n{    \n    int v = shuffle0(x, h1, h2);\n    return v != 16 ? v : shuffle0(16, h1, h2);\n}\n\nvec2 indexToPosition(int i) \n{\n    float h = .125 + .25 * float(i % 4);\n    if (i < 4)  return vec2(0, h) - .5; // Left side\n    if (i < 8)  return vec2(h, 0) - .5; // Bottom side\n    if (i < 12) return vec2(1, h) - .5; // Right side\n    if (i < 16) return vec2(h, 1) - .5; // Top side\n}\n\nfloat getDistance(vec2 u, vec2 id, int a, int b) \n{\n    vec2 p = indexToPosition(a);\n    vec2 q = indexToPosition(b);\n  \n    // Transform p to be left edge (for easy calculation)\n    if (abs(p.y) == .5) u = u.yx, p = p.yx, q = q.yx; \n    if (p.x == .5) u.x = -u.x, p.x = -p.x, q.x = -q.x;\n    \n    const float k = 1./8.;\n\n\n    // Same side : draw semi-circle\n    // ---------\n    if (q.x == -.5) \n    {\n        // Circle centre and radius\n        vec2 m = (p+q)/2.;\n        float r = abs(p.y-q.y)/2.;\n\n        // Draw semi circle (half of circle is outside cell)\n        return abs(length(u - m) - r);\n\n        // Random horizontal offset for circle centre\n        //float x = floor(3. * hash12(id-.021)) * k;\n        //return abs(seg(u, m, m + vec2(x,0)) - r);\n    }\n\n\n    // Opposite sides : draw line or S shape\n    // --------------\n    if (q.x == .5) \n    {     \n        // Return line if p and q are same height\n        if (p.y == q.y) return seg(u, p, q);\n    \n        // Transform p to be above q\n        if (p.y < q.y) u.y = -u.y, p.y = -p.y, q.y = -q.y;       \n        \n        // Random horizontal offset for S shape (-3k, ..., 3k)\n        float x = (floor(7. * hash12(id-.1)) - 3.) * k; \n        \n        // line: p -> p corner\n        float d =  seg(u, p, p + vec2(.5-k-x, 0));\n        \n        // line: q -> q corner\n        d = min(d, seg(u, q, q - vec2(.5-k+x, 0))); \n\n        // Offset p and q for easier calculation\n        p.x -= x;\n        q.x -= x;\n\n        // line: p corner -> q corner\n        d = min(d, seg(u, p + vec2(.5, -k), q - vec2(.5, -k)));\n        \n        // arc: p corner\n        if (u.x > p.x + (.5-k) && u.y > p.y - k)      \n            d = min(d, abs(length(u - (p + vec2(.5-k, -k))) - k));\n            \n        // arc: q corner\n        else if (u.x < q.x - (.5-k) && u.y < q.y + k) \n            d = min(d, abs(length(u - (q - vec2(.5-k, -k))) - k));\n      \n        return d;\n    }\n\n\n    // Corner sides : draw L shape\n    // ------------\n    \n    // Transform q to be on bottom side\n    if (q.y == .5) u.y = -u.y, p.y = -p.y, q.y = -q.y;\n    \n    // Corner point\n    vec2 m = vec2(q.x, p.y);\n    \n    // Corner radius (largest possible)\n    float r = max(k, min(q.x, p.y));\n    \n    // line: p -> corner\n    float d =  seg(u, m - vec2(r,0), p);\n    \n    // line: q -> corner\n    d = min(d, seg(u, m - vec2(0,r), q));\n    \n    // Offset r for easier calculation\n    m -= r;\n    \n    // arc: corner\n    if (u.x > m.x && u.y > m.y)\n        d = min(d, abs(length(u - m) - r));\n        \n    return d;\n} \n \nvoid drawLayer(inout vec4 o, vec2 u, vec2 idOffset) \n{\n    // Grid stuff\n    vec2 f = fract(u) - .5;\n    vec2 id = floor(u) + idOffset;\n    \n    // Hashes for random permutation\n    int h1 = int(16. * hash12(id));\n    int h2 = int(16. * hash12(id - .37)) + 1; \n     \n    for (int i; i < 8; i++) \n    {    \n        int a = shuffle(i, h1, h2);\n        int b = shuffle(i + 8, h1, h2);\n        float d = getDistance(f, id, a, b);\n        \n        o = mix(o, vec4(0), ss(d - .05));   \n        o = mix(o, vec4(1), ss(d - .03));\n    }\n    \n    if (iMouse.z > 0.)\n        o = mix(vec4(1,0,0,0), o, ss(max(abs(f.x),abs(f.y))-.49)); \n}\n \nvoid mainImage( out vec4 o, vec2 u )\n{\n    u = 2.5*(u-.5*R)/R.y - vec2(.1, .035) * iTime;\n    o = vec4(0);\n    \n    drawLayer(o, u, vec2(0));\n    //drawLayer(o, u+vec2(0,.125), vec2(.73,.32));\n    //drawLayer(o, u+vec2(.125,0), vec2(.44,.39));\n    //drawLayer(o, u+.125, vec2(.8,.3));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// How it work??\n// -------------\n\n// o Start with grid of square cells\n\n// o Each cell has 4 points evenly spaced on each side \n//   with an id corresponding to each point \n//   left   : 0,1,2,3 : (-.5,-.375), (-.5,-.125), (-.5,.125), (-.5,.375)\n//   bottom : 4,5,6,7\n//   right  : 8,9,10,11\n//   top    : 12,13,14,15\n\n// ------\n// |    |  <--- a square!\n// |    |\n// ------\n\n// o Pick a random permutation for the id's in each cell\n//   e.g. 0,1,2,3,4,5,6,7, 8,9,10,11,12,13,14,15\n//    --> 3,4,0,1,2,6,10, 13,12,11,14,15,5,7,9,8\n\n// o Match the ith and (i+8)th id's together for i = 0, ..., 7\n//   e.g. (3,13), (4,12), (0,11), ...\n\n// o Draw a squiggle for each pair of id's\n//   (map each id to it's point then draw the squiggle between\n//    the 2 points)\n\n// o There are 3 squiggle cases:\n//   x Both points share a side         (draw semi-circle)\n//   x The points are on opposite sides (draw line or S shape)\n//   x The points are on touching sides (draw L shape corner)\n\n// o 8 squiggles are drawn in some order in each cell",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}