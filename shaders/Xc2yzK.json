{
    "Shader": {
        "info": {
            "date": "1722611300",
            "description": "https://claude.ai/chat/06a4f065-49b0-4ff9-97a3-85e6665ea524\nSubscribe to Pro for 5x more usage with Claude 3.5 Sonnet.",
            "flags": 0,
            "hasliked": 0,
            "id": "Xc2yzK",
            "likes": 1,
            "name": "GLSLPLAYLIST CLAUDE 3.5 SONNET",
            "published": 3,
            "tags": [
                "claude",
                "ai"
            ],
            "usePreview": 0,
            "username": "Sergeindamix",
            "viewed": 76
        },
        "renderpass": [
            {
                "code": "// Funci贸n para rotar un punto alrededor del eje Y\nmat3 rotateY(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        c, 0, -s,\n        0, 1, 0,\n        s, 0, c\n    );\n}\n\n// Funci贸n para rotar un punto alrededor del eje X\nmat3 rotateX(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        1, 0, 0,\n        0, c, -s,\n        0, s, c\n    );\n}\n\nfloat rotationSpeed = 6.28318; // 2 * PI para una rotaci贸n completa\nfloat waitTime = 60.0; // 60 segundos de espera\n\n\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float totalCycleTime = rotationSpeed + waitTime;\n    float cycleTime = mod(iTime, totalCycleTime * 4.0); // 4 rotaciones completas para cubrir todos los canales\n    float currentCycle = floor(cycleTime / totalCycleTime);\n    float localCycleTime = mod(cycleTime, totalCycleTime);\n    float rotation = min(localCycleTime, rotationSpeed);\n\n    // Efecto glitch\n    float glitchIntensity = smoothstep(0.0, rotationSpeed, rotation) * (1.0 - smoothstep(rotationSpeed * 0.9, rotationSpeed, rotation));\n    vec2 glitchOffset = vec2(\n        random(vec2(uv.y, iTime)) * 2.0 - 1.0,\n        random(vec2(uv.x, iTime)) * 2.0 - 1.0\n    ) * 0.02 * glitchIntensity;\n\n    uv += glitchOffset;\n\n    // Time varying pixel color\n    vec3 color = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    // Background effect\n    vec2 center = vec2(0.5);\n    float d = distance(uv, center);\n    vec3 bgColor = mix(vec3(0.1, 0.0, 0.2), vec3(0.0, 0.1, 0.2), d);\n    color = bgColor;\n\n    // Grid effect\n    vec2 grid = fract(uv * 20.0 + sin(iTime * 0.1) * 0.5);\n    float gridLine = step(0.95, max(grid.x, grid.y));\n    color += vec3(0.0, 1.0, 1.0) * gridLine * 0.2;\n\n    // Cube video player area\n    if(uv.x < 0.7 && uv.y > 0.1) {\n        vec2 videoUV = (uv - vec2(0.0, 0.1)) / vec2(0.7, 0.9);\n        vec3 ro = vec3(0.0, 0.0, -2.0);\n        vec3 rd = normalize(vec3(videoUV * 2.0 - 1.0, 1.0));\n\n        // Rotate the cube (not the ray)\n        float rotationSpeed = 6.28318; // 2 * PI para una rotaci贸n completa\n        float waitTime = 60.0; // 60 segundos de espera\n\n        float cycleTime = mod(iTime, rotationSpeed + waitTime);\n        float rotation = min(cycleTime, rotationSpeed);\n\n        mat3 rotationMatrix = rotateY(rotation) * rotateX(rotation * 0.7);\n        // Cube properties\n        float cubeSize = 0.8;\n        vec3 cubeMin = -vec3(cubeSize);\n        vec3 cubeMax = vec3(cubeSize);\n\n        // Transform ray origin and direction\n        ro = rotationMatrix * ro;\n        rd = rotationMatrix * rd;\n\n        // Ray-cube intersection\n        vec3 m = 1.0 / rd;\n        vec3 n = m * ro;\n        vec3 k = abs(m) * cubeSize;\n        vec3 t1 = -n - k;\n        vec3 t2 = -n + k;\n        float tN = max(max(t1.x, t1.y), t1.z);\n        float tF = min(min(t2.x, t2.y), t2.z);\n\n        if(tN < tF && tF > 0.0) {\n            vec3 pos = ro + rd * tN;\n            vec3 absPos = abs(pos);\n            vec2 faceUV;\n\n            // Determine which face of the cube we're on\n            if(absPos.x > absPos.y && absPos.x > absPos.z) {\n                faceUV = pos.yz / cubeSize * 0.5 + 0.5;\n                faceUV.x = pos.x > 0.0 ? faceUV.x : 1.0 - faceUV.x;\n            } else if(absPos.y > absPos.z) {\n                faceUV = pos.xz / cubeSize * 0.5 + 0.5;\n                faceUV.y = pos.y > 0.0 ? faceUV.y : 1.0 - faceUV.y;\n            } else {\n                faceUV = pos.xy / cubeSize * 0.5 + 0.5;\n                faceUV.x = pos.z > 0.0 ? 1.0 - faceUV.x : faceUV.x;\n            }\n\n            // Correct aspect ratio\n            vec2 aspectCorrectedUV = faceUV;\n            float videoAspect = uv.x;\n            float containerAspect = 0.7 / 0.9;\n            if (videoAspect > containerAspect) {\n                float scale = containerAspect / videoAspect;\n                aspectCorrectedUV.y = (aspectCorrectedUV.y - 0.5) * scale + 0.5;\n            } else {\n                float scale = videoAspect / containerAspect;\n                aspectCorrectedUV.x = (aspectCorrectedUV.x - 0.5) / scale + 0.5;\n            }\n\n            // Sample video texture\n            if(aspectCorrectedUV.x >= 0.0 && aspectCorrectedUV.x <= 1.0 &&\n               aspectCorrectedUV.y >= 0.0 && aspectCorrectedUV.y <= 1.0) {\n                vec4 videoColor;\n                if (currentCycle == 0.0) {\n                    videoColor = texture(iChannel0, aspectCorrectedUV);\n                } else if (currentCycle == 1.0) {\n                    videoColor = texture(iChannel1, aspectCorrectedUV);\n                } else if (currentCycle == 2.0) {\n                    videoColor = texture(iChannel2, aspectCorrectedUV);\n                } else {\n                    videoColor = texture(iChannel3, aspectCorrectedUV);\n                }\n                color = mix(color, videoColor.rgb, videoColor.a);\n            } else {\n                // Add a border effect for cube edges\n                color = mix(color, vec3(0.0, 1.0, 1.0), 0.5);\n            }\n        }\n    }\n\n    // Header\n    if(uv.y < 0.1) {\n        color = mix(color, vec3(0.0, 0.5, 0.5), 0.8);\n        // Add text effect for \"CyberPlayer 3000\"\n        if(uv.x > 0.05 && uv.x < 0.35 && uv.y > 0.03 && uv.y < 0.07) {\n            //color = neon(vec3(0.0, 1.0, 1.0), 1.5);\n        }\n    }\n\n    \n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "video",
                        "id": 11,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv"
                    },
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 12,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm"
                    },
                    {
                        "channel": 2,
                        "ctype": "video",
                        "id": 29,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv"
                    },
                    {
                        "channel": 1,
                        "ctype": "video",
                        "id": 36,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}