{
    "Shader": {
        "info": {
            "date": "1547256092",
            "description": "just trying some stuff out with materials",
            "flags": 0,
            "hasliked": 0,
            "id": "wdsGzs",
            "likes": 3,
            "name": "rectotoroid",
            "published": 3,
            "tags": [
                "raycast",
                "sdf",
                "shape"
            ],
            "usePreview": 0,
            "username": "mds2",
            "viewed": 420
        },
        "renderpass": [
            {
                "code": "#define MAX_DIST 4.0\n\nconst float inv_subsurface_thick = 150.0; // make it bigger to make a smaller subsurface\n\nconst float tor_rad = 0.5;\nvec2 box_size = vec2(0.0175, 0.065);\n\n#if 1 // change to 0 to make it silly-putty\nconst float round_size = 0.01;\n\nconst vec3 refl_color = vec3(1.0); // vec3(1.0, 0.6, 0.3); // \nconst vec3 diff_color = vec3(0.2, 1.0, 0.8); // vec3(0.8, 0.2, 0.2); // \nconst vec3 subsurf_color = vec3(0.8, 0.6, 0.4);\nconst float specular_intense = 0.5;\n#else\n\nconst float round_size = 0.1;\n\nconst vec3 refl_color = vec3(1.0); // vec3(1.0, 0.6, 0.3); // \nconst vec3 diff_color = vec3(0.8, 0.7, 0.6); // vec3(0.2, 1.0, 0.8); // vec3(0.8, 0.2, 0.2); // \nconst vec3 subsurf_color = vec3(1.0, 0.5, 0.4); // vec3(0.8, 0.6, 0.4);\nconst float specular_intense = 0.5;\n#endif\n\nvec3 light_dir = vec3(0.8, 0.6, 0.0);\nvec3 cut_dir_1 = vec3(0.0, 0.0, 1.0);\nvec3 cut_dir_2 = vec3(0.0, 0.0, 1.0);\n\nmat3 twist;\n\nfloat s_min(in float x, in float y, in float s) {\n\n    float bridge =\n        clamp(abs(x-y)/s, 0.0, 1.0);\n    return min(x,y) - 0.25 * s * (bridge - 1.0) * (bridge - 1.0);\n}\n\nfloat s_max(in float x, in float y, in float s) {\n    float bridge =\n        clamp(abs(x-y)/s, 0.0, 1.0);\n    return max(x,y) + 0.25 * s * (bridge - 1.0) * (bridge - 1.0);\n}\n\n\nfloat sdf_ring(in vec3 pt) {\n    vec2 tor_coord = abs(vec2(length(pt.xz) - tor_rad, pt.y));\n    tor_coord = max(vec2(0.0), tor_coord - box_size);\n    return length(tor_coord) - round_size;\n}\n\nfloat sdf(in vec3 pt) {\n    float cut_sdf_1 = s_min(dot(pt, cut_dir_1),round_size + pt.x, round_size);\n    float cut_sdf_2 = s_min(dot(pt, cut_dir_2), round_size -pt.x, round_size);\n    float cut_sdf = max(cut_sdf_1, cut_sdf_2);\n    float s = sdf_ring(pt);\n    return s_max(s, cut_sdf, round_size);\n}\n\nvec3 sdf_grad(in vec3 pt) {\n    const float h = 0.001;\n    const float h_inv = 1000.0;\n    float f = sdf(pt);\n    return h_inv * vec3(sdf(pt + vec3(h, 0.0, 0.0)) - f,\n                        sdf(pt + vec3(0.0, h, 0.0)) - f,\n                        sdf(pt + vec3(0.0, 0.0, h)) - f);\n}\n\nvec3 norm_perturb(in vec3 pt) {\n    const float rad_2_unit = 1.0 / (2.0 * 3.141592654);\n    float ang1 = atan(pt.x, pt.z) * rad_2_unit;\n    vec2 about = vec2(length(pt.xz) - tor_rad, pt.y);\n    float ang2 = atan(about.y, about.x) * rad_2_unit;\n    const float scale = 3.0;\n    vec3 bmp = texture(iChannel2, mod(scale * vec2(ang1 * tor_rad / box_size.y, ang2), vec2(1.0))).rgb - \n        vec3(0.5);\n    return 0.1 * bmp;\n}\n\nvec3 zero_norm_perturb(in vec3 pt) {\n    return vec3(0.0);\n}\n\nvec3 grid_norm_perturb(in vec3 pt) {\n    vec2 uv1 = mod(3.0 * pt.xy, vec2(1.0));\n    vec2 uv2 = mod(3.0 * pt.yz, vec2(1.0));\n    vec2 uv3 = mod(3.0 * pt.zx, vec2(1.0));\n    return texture(iChannel2, uv1).rgb - vec3(0.5) +\n        texture(iChannel2, uv2).rgb - vec3(0.5) +\n        texture(iChannel2, uv3).rgb - vec3(0.5);\n}\n\nfloat ray_cast(in vec3 o, in vec3 dir) {\n    float accum = 0.0;\n    float val = sdf(o);\n    vec3 pt = o;\n    for (int i = 0; i < 128; ++i) {\n        accum += 0.5 * val;\n        pt = o + accum * dir;\n        val = sdf(pt);\n        if (accum > MAX_DIST || val < 1.0e-3) {\n            return accum;\n        }\n    }\n    return MAX_DIST + 1.0;\n}\n\nfloat cast_out(in vec3 o, in vec3 dir) {\n    float accum = 0.0;\n    float val = sdf(o);\n    vec3 pt = o;\n    for (int i = 0; i < 128; ++i) {\n        accum += max(0.95 * abs(val), 5.0e-4);\n        pt = o + accum * dir;\n        val = sdf(pt);\n        if (accum > 1.0e-3 && val > -1.0e-3) {\n            return accum;\n        }\n    }\n    return MAX_DIST + 1.0;\n}\n\nvec4 color_at(in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy)/iResolution.y;\n    \n    vec3 dir = normalize(vec3(uv, -2.0));\n    vec3 orig = vec3(0.0, 0.0, 1.0);\n    \n    float theta = 0.3;\n    vec2 angles = cos(theta + vec2(0.0, 0.5 * 3.141592654));\n    mat3 tilt = mat3(1.0, 0.0, 0.0,\n                     0.0, angles.x, angles.y,\n                     0.0, -angles.y, angles.x);\n    orig = twist * tilt * orig;\n    dir = twist * tilt * dir;\n\n    float dist = ray_cast(orig, dir);\n    \n    vec3 col = vec3(1.0 / dist);\n\n    if (dist < MAX_DIST) {\n        vec3 pt = orig + dir * dist;\n\t\tvec3 n = normalize(sdf_grad(pt));\n        n = normalize(n + norm_perturb(pt));\n        vec3 bounce = normalize(reflect(dir, n));\n        float refl_bright = 0.2 * smoothstep(0.0, 1.0, dot(bounce, light_dir));\n        float diff_bright = 0.05 +\n            0.75 * smoothstep(0.1, 1.0, dot(n, light_dir)) + 0.25;\n        float dist_out = cast_out(pt + 1.0e-2 * dir, light_dir) +\n            0.0 * dot(light_dir, norm_perturb(pt));\n        col = specular_intense * refl_bright * refl_color + diff_bright * 0.6 * diff_color;\n        col += 0.5 * (1.0 / max(2.0, 2.0 + inv_subsurface_thick * dist_out)) * subsurf_color;\n        \n    } else {\n        col = vec3(0.0);\n    }\n    \n    // Output to screen\n\treturn vec4(col, 1.0);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float theta = 0.5 + iMouse.x / iResolution.x;\n    theta *= 2.0 * 3.141592654;\n    float ct = cos(theta);\n    float st = sin(theta);\n    \n    twist = mat3(ct, 0.0, st,\n                 0.0, 1.0, 0.0,\n                 -st, 0.0, ct);\n    \n\n    float push_pull = 3.141592654 * (1.0 - iMouse.y / iResolution.y);\n    cut_dir_1.xz = sin(push_pull + vec2(0.5 * 3.141592654, 0.0));\n    push_pull = -push_pull;\n    cut_dir_2.xz = -sin(push_pull + vec2(0.5 * 3.141592654, 0.0));\n    vec4 col_out = 0.25 * color_at(fragCoord);\n    const float scatter_scale = 0.8;\n    col_out += 0.25 * color_at(fragCoord + scatter_scale * vec2(0.6, 0.8));\n    col_out += 0.25 * color_at(fragCoord + scatter_scale * vec2(-1.0, 0.0));\n    col_out += 0.25 * color_at(fragCoord + scatter_scale * vec2(0.0, -1.0));\n    fragColor = col_out;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}