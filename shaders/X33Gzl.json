{
    "Shader": {
        "info": {
            "date": "1716872271",
            "description": "cross eyed 3D ray marching fractal\ninstructions at top of source code.",
            "flags": 48,
            "hasliked": 0,
            "id": "X33Gzl",
            "likes": 2,
            "name": "cycle13",
            "published": 3,
            "tags": [
                "raymarching",
                "3dfractal"
            ],
            "usePreview": 0,
            "username": "kosalos",
            "viewed": 68
        },
        "renderpass": [
            {
                "code": "/*\nPress Up/Dn arrow keys to select widget focus.\nPress  Lt/Rt arrow keys to alter widget value.\nDrag mouse on X axis to alter focused widget value.\n\nAccelerated changes while holding down arrow keys or moving the mouse:\nHold down <A> for change Amount * 0.1 \nHold down <Z> for change Amount * 10. \nHold down <A><Z> for change Amount * 50. \n\nPress <Spc> to reset.\n\nCross-eyed 3D (enable with \"data.stereo = true\" in initializedNonStoredData() )\nSlightly cross your eyes so that there is a third image in the middle.\nRelax your gaze, and concentrate only on that middle image, which is in 3D.\n\nbased on https://www.shadertoy.com/view/4sdXDl\n*/\n\nstruct Dataset {\n    // DE() params\n\tvec4  c,d;\n    \n\tint maxsteps;\n    vec3 target;    \n    bool inversion;\n    vec3 invpos;\n    float invradius;\n    float invangle;    \n    \n    vec3 camera;\n    float epsilon;\n    float ambient,contrast,vibrant,dim;\n    float fogDistance,fogAmount,fogColor; // distance = 0.0 -> disable effect\n    \n    vec3 lightColor;\n    vec3 lightPosition;\n    vec3 lightParam; // diffuse, specular, ambient\n\n    vec4 orbitTrap;\n    float Ostrength; // 0.0 -> disable orbit trapping\n    float Ocycle;\n    float OXwt,OXcr; // weight, color code\n    float OYwt,OYcr;\n    float OZwt,OZcr;\n    float OWwt,OWcr;\n    vec3  Ocenter;   // origin offset\n    \n    bool stereo;\n    float parallax;  // adjust for best stereo effect 0 ... 0.2\n\n    // calculated params \n    vec3 direction;\n    vec3 normal;\n    vec3 position;\n    vec3 color;\n    float depth;\n    int iter;\n    \n    int focus,row,displayCount;\n    vec3 viewVector,sideVector,topVector;\n};\n\n// --------------------------------------------------------\n\nvoid Bulb(inout vec4 z, in vec4 c,inout Dataset data) {  // mandelBulb by twinbee\n float r = length(z.xyz);\n float zo = asin(z.z / r) * data.c.x + data.c.y;\n float zi = atan(z.y, z.x) * data.c.z;\n z = pow(r, data.c.w-1.0) * vec4(r*vec3(cos(zo)*vec2(cos(zi),sin(zi)),sin(zo)),z.w * data.c.w)+c; \n}\n\n\nfloat DE(vec3 p,inout Dataset data) {\nvec4 c = vec4(p,1.0),z = c;\n\n\tdata.orbitTrap = vec4(10000.);\n\n  for(int i=0;i<100;i++) {\n\t\tif(i > int(data.d.y)) break;\n\t\tBulb(z,c,data);\n\t}\n\t\n  float r0 = length(z.xyz)/z.w;\n\n  for(int i=0;i<100;i++) {\n\t\tif(i > data.maxsteps) break;\n\t\t\n\t\tz.xyz = abs(z.xyz+1.0)-1.0; \n// \t\tz *= data.d.x/clamp(dot(z.xyz,z.xyz),0.25,1.0);\n \t\tz *= data.d.x/clamp(dot(z.xyz,z.xyz),data.d.z,data.d.w);\n\t\t\n\t\tif(i < 2) {\n\t\t\tvec3 ot = z.xyz - data.Ocenter;\n\t\t\tdata.orbitTrap = min(data.orbitTrap, vec4(abs(ot), dot(ot,ot)));\n\t\t}\n\t}\n\n\tfloat r = length(z.yz);\n  return 0.5 * max((r-1.0) / z.w,-r0);\n}\n\n// --------------------------------------------------------\n// distance estimation function wrapped by spherical inversion code.\n\nfloat DE_plusSpherical(vec3 pos,inout Dataset data) {\n    if(data.inversion) {\n        pos = pos - data.invpos;\n        float r = length(pos);\n        float r2 = r*r;\n\t\tfloat radius2 = data.invradius * data.invradius;\n        pos = (radius2 / r2) * pos + data.invpos;\n        \n        float an = atan(pos.y,pos.x) + data.invangle;\n        float ra = length(pos.xy);\n        pos.x = cos(an) * ra;\n        pos.y = sin(an) * ra;\n\t\t\t\t\n        float de = DE(pos,data);\n        return r2 * de / (radius2 + r * de);\n    }\n    \n    return DE(pos,data);\n}\n\n// --------------------------------------------------------\n\nvec3 generateColor(float weight,float x) {\n\tif(weight == 0.0) return vec3(0.0);\n\n\tx = cos(x);\n\t//x=abs(sin(x)); // limits colors\n\n    // bezier, you can rearange the functions for different color combos but this one is best\n\tfloat r = (1.0-x)*(1.0-x);\n\tfloat g = x*x;\n\tfloat b = 2.0*(1.0-x)*x;\n\treturn vec3(r,g,b);\n}\n\nvec3 orbitTrapCycle(float cycle,vec3 c, float s) {\n    float ss = s * cycle;\n    return vec3(0.5) + 0.5 * vec3( cos(ss + c.x), cos(ss + c.y), cos(ss + c.z));\n}\n\nvec3 getOrbitColor(inout Dataset data) {\n    vec3 orbitColor;\n    \n    if (data.Ocycle > 0.0) {\n        orbitColor =\n        orbitTrapCycle(data.Ocycle,generateColor(data.OXwt,data.OXcr), data.orbitTrap.x) * data.OXwt * data.orbitTrap.x +\n        orbitTrapCycle(data.Ocycle,generateColor(data.OYwt,data.OYcr), data.orbitTrap.y) * data.OYwt * data.orbitTrap.y +\n        orbitTrapCycle(data.Ocycle,generateColor(data.OZwt,data.OZcr), data.orbitTrap.z) * data.OZwt * data.orbitTrap.z +\n        orbitTrapCycle(data.Ocycle,generateColor(data.OWwt,data.OWcr), data.orbitTrap.w) * data.OWwt * data.orbitTrap.w;\n    } else {\n        orbitColor =\n        \tgenerateColor(data.OXwt,data.OXcr) * data.OXwt * data.orbitTrap.x +\n        \tgenerateColor(data.OYwt,data.OYcr) * data.OYwt * data.orbitTrap.y +\n        \tgenerateColor(data.OZwt,data.OZcr) * data.OZwt * data.orbitTrap.z +\n        \tgenerateColor(data.OWwt,data.OWcr) * data.OWwt * data.orbitTrap.w;\n    }\n    \n    return orbitColor;\n}\n\nvec3 phong_contrib(inout Dataset data) { \n\tvec3 L = normalize(data.lightPosition - data.position);\n\tfloat dotLN = dot(L, data.normal);\n\tif (dotLN < 0.0)\n\t\treturn vec3(0, 0, 0);\n\t\t\n\tfloat t1 = data.lightParam.x * dotLN;\n\n\tvec3 V = normalize(data.camera - data.position);\n\tvec3 R = normalize(reflect(-L, data.normal));\n\tfloat dotRV = dot(R, V);\n\n\tif (dotRV < 0.0)\n\t\treturn vec3(data.lightColor * t1);\n\n\tfloat t2 = data.lightParam.y * pow(abs(dotRV), data.lightParam.z);\n\tdata.color += data.lightColor * (t1 + t2);\n}\n\n\nvoid applyColoring(inout Dataset data) { \n    data.color = vec3(data.ambient) + vec3(1.0 - (data.normal * data.vibrant + sqrt(float(data.iter) * data.dim)));\n    data.color = vec3(0.5) + (data.color - vec3(0.5)) * data.contrast;\n    \n    if(length(data.lightColor) > 0.0) \n\t\tphong_contrib(data);\n        \n        \n    if(data.Ostrength > 0.0) {\n        vec3 oColor = getOrbitColor(data);\n        data.color = mix(data.color, oColor, data.Ostrength);\n    }\n}\n\n// --------------------------------------------------------\n// normal vector for 3D coordinate determined by comparing values of neighboring positions\n\nvoid calcNormal(inout Dataset data) {\n    float ex = data.epsilon;\n    float ey = -ex;\n    vec3 pos = data.position;\n    \n    vec3 t1 = vec3( pos[0] + ex, pos[1] + ey, pos[2] + ey); float a1 = DE(t1,data);\n    vec3 t2 = vec3( pos[0] + ey, pos[1] + ey, pos[2] + ex); float a2 = DE(t2,data);\n    vec3 t3 = vec3( pos[0] + ey, pos[1] + ex, pos[2] + ey); float a3 = DE(t3,data);\n    vec3 t4 = vec3( pos[0] + ex, pos[1] + ex, pos[2] + ex); float a4 = DE(t4,data);\n\n    data.normal = normalize(vec3(\n        ex * a1 + ey * a2 + ey * a3 + ex * a4,\n        ey * a1 + ey * a2 + ex * a3 + ex * a4,\n        ey * a1 + ex * a2 + ey * a3 + ex * a4 ));\n}\n\n// --------------------------------------------------------\n\nvoid setDirection(vec2 fragCoord,inout Dataset data) {\n    // cross eyed stereo ------------------------------------\n    vec2 srcP = fragCoord;        // copy of pixel coordinate; x is altered for stereo\n    float xsize = iResolution.x;  // copy of window size; x is altered for stereo\n    \n    if(data.stereo) {\n        vec3 soffset = data.sideVector * data.parallax;\n\t\txsize *= 0.5;             // window x size adjusted for 2 views side by side\n        if(srcP.x >= xsize) {     // right side of stereo pair?\n\t\t\tsrcP.x -= xsize;      // base 0  X coordinate\n\t\t\tdata.camera -= soffset;// adjust for right side parallax\n\t\t}\n\t\telse {\n\t\t\tdata.camera += soffset;// adjust for left side parallax\n\t\t}\n    }\n    \n    vec2 vPos = (srcP - iResolution.xy * 0.5)/iResolution.y;\n    data.direction = normalize(data.viewVector + vPos.x * data.sideVector + vPos.y * data.topVector);\n}\n\n// --------------------------------------------------------\nconst float MIN_DIST = 0.001;\nconst float MAX_DIST = 30.0;\n\nvoid rayMarch(inout Dataset data) {\n\tvec3 position = data.camera;\n\tfloat distance;\n\tdata.iter = 0;\n\tdata.depth = MIN_DIST;\n\t\n\tfor(int i = 0;i < 100;++i) {\n\t\tdistance = DE_plusSpherical(position,data);\n        if(abs(distance) < MIN_DIST || data.depth > MAX_DIST) break;\n        data.iter += 1;\n\t\t\n        data.depth += distance;\n        position = data.camera + data.direction * data.depth;\n  }\n}\n\n// --------------------------------------------------------\nmakeStr1f(pshape)     _S _h _a _p _e _COL __ _dec(i, 4) _end\nmakeStr1f(pcx)        _C _x _COL __ _dec(i, 4) _end\nmakeStr1f(pcy)        _C _y _COL __ _dec(i, 4) _end\nmakeStr1f(pcz)        _C _z _COL __ _dec(i, 4) _end\nmakeStr1f(pcw)        _C _w _COL __ _dec(i, 4) _end\nmakeStr1f(pdx)        _D _x _COL __ _dec(i, 4) _end\nmakeStr1f(pdy)        _D _y _COL __ _dec(i, 4) _end\nmakeStr1f(pdz)        _D _z _COL __ _dec(i, 4) _end\nmakeStr1f(pdw)        _D _w _COL __ _dec(i, 4) _end\nmakeStr1f(pInvposx)   _I _n _v _P _o _s _X _COL __ _dec(i, 4) _end\nmakeStr1f(pInvposy)   _I _n _v _P _o _s _Y _COL __ _dec(i, 4) _end\nmakeStr1f(pInvposz)   _I _n _v _P _o _s _Z _COL __ _dec(i, 4) _end\nmakeStr1f(pInvRadius) _I _n _v _R _a _d _i _u _s _COL __ _dec(i, 4) _end\nmakeStr1f(pInvAngle)  _I _n _v _A _n _g _l _e _COL __ _dec(i, 4) _end\nmakeStr1f(pCamerax)   _C _a _m _e _r _a _X _COL __ _dec(i, 4) _end\nmakeStr1f(pCameray)   _C _a _m _e _r _a _Y _COL __ _dec(i, 4) _end\nmakeStr1f(pCameraz)   _C _a _m _e _r _a _Z _COL __ _dec(i, 4) _end\nmakeStr1f(pTargetx)   _T _a _r _g _e _t _X _COL __ _dec(i, 4) _end\nmakeStr1f(pTargety)   _T _a _r _g _e _t _Y _COL __ _dec(i, 4) _end\nmakeStr1f(pTargetz)   _T _a _r _g _e _t _Z _COL __ _dec(i, 4) _end\n\nvec3 rowColor(inout Dataset data) {\n if(data.row == data.focus) return vec3(0.,1.,0.);\n return vec3(0.8);\n}\n\nvoid displayData(inout Dataset data,inout vec4 fragColor, in vec2 fragCoord) {\n    if(fragCoord.x > iResolution.x * 0.33) return; // no printing in that region\n\n    vec2 uv = fragCoord / iResolution.y;\n    vec3 col = vec3(0);    \n\n    const float font_size = 17.0; // Font Size (higher values = smaller font)\n    uv *= font_size;        // Scale font with font_size\n    uv.y -= font_size - 1.; // Start drawing from the top   \n\n    for(data.row = 0; data.row < 22; ++data.row) {\n       if(data.row >= data.focus-1 && data.row <= data.focus+1) {\n            if(data.row ==  0) col += rowColor(data) * pcx(uv, data.c.x);\n            if(data.row ==  1) col += rowColor(data) * pcy(uv, data.c.y);\n            if(data.row ==  2) col += rowColor(data) * pcz(uv, data.c.z);\n            if(data.row ==  3) col += rowColor(data) * pcw(uv, data.c.w);\n            if(data.row ==  4) col += rowColor(data) * pdx(uv, data.d.x);\n            if(data.row ==  5) col += rowColor(data) * pdy(uv, data.d.y);\n            if(data.row ==  6) col += rowColor(data) * pdz(uv, data.d.z);\n            if(data.row ==  7) col += rowColor(data) * pdw(uv, data.d.w);\n            if(data.row ==  8) col += rowColor(data) * pInvposx(uv, data.invpos.x);\n            if(data.row ==  9) col += rowColor(data) * pInvposy(uv, data.invpos.y);\n            if(data.row == 10) col += rowColor(data) * pInvposz(uv, data.invpos.z);\n            if(data.row == 11) col += rowColor(data) * pInvRadius(uv, data.invradius);\n            if(data.row == 12) col += rowColor(data) * pInvAngle(uv, data.invangle);\n            if(data.row == 13) col += rowColor(data) * pCamerax(uv, data.camera.x);\n            if(data.row == 14) col += rowColor(data) * pCameray(uv, data.camera.y);\n            if(data.row == 15) col += rowColor(data) * pCameraz(uv, data.camera.z);\n            if(data.row == 16) col += rowColor(data) * pTargetx(uv, data.target.x);\n            if(data.row == 17) col += rowColor(data) * pTargety(uv, data.target.y);\n            if(data.row == 18) col += rowColor(data) * pTargetz(uv, data.target.z);\n        }\n        \n        uv.y += 0.8;  \n    }\n    \n    if(length(col) > 0.)\n    fragColor.xyz = col;\n}   \n\n// animation routines ----------------------------------------\n\nvoid cycleValue(inout float value, float vmin,float vmax, float speed) {\n    float ratio = 0.5 + 0.5 * cos(iTime * speed);  // 0 ... 1\n    value = vmin + (vmax - vmin) * ratio;\n}\n\nvoid cycleValue2(inout float value, float baseValue, float deviation, float speed) {\n    float ratio = 1.0 + cos(iTime * speed);  // 0 ... 2\n    value = baseValue-deviation + deviation * ratio;\n}\n\nvoid cycleValue3(inout float value, float baseValue, float amount, float speed) {\n    float ratio = 1.0 + cos(iTime * speed);  // 0 ... 2\n    float deviation = baseValue * amount * 0.5;    \n    value = baseValue-deviation + deviation * ratio;\n}\n\nvoid cycleValue3Vec3(inout vec3 value, vec3 baseValue, float amount, float speed) {\n    for(int i=0;i<3;++i)\n        cycleValue3(value[i],baseValue[i],amount,speed);\n}\n\nvoid moveCamera(inout Dataset data) {\n    const float amt = 5.;\n    cycleValue2(data.camera.x,0.0,amt, 0.35);\n    cycleValue2(data.camera.y,0.0,amt, 0.45);\n    cycleValue2(data.camera.z,0.0,amt, 0.55);\n}\n\nvoid moveTarget(inout Dataset data) {\n    cycleValue2(data.target.x,0.0,1.0, 0.3);\n    cycleValue2(data.target.y,0.0,1.0, 0.4);\n    cycleValue2(data.target.z,0.0,1.0, 0.5);\n}\n    \nvoid alterLight(inout Dataset data) {\n   cycleValue3(data.lightColor.x,2.5,2.0,0.3);\n   cycleValue3(data.lightColor.y,2.5,2.0,0.4);\n   cycleValue3(data.lightColor.z,2.5,2.0,0.5);\n   \n   cycleValue(data.lightPosition.x,-2.0,2.0,0.3);\n   cycleValue(data.lightPosition.y,-2.0,2.0,0.35);\n   cycleValue(data.lightPosition.z,-2.0,2.0,0.4);\n   \n   cycleValue2(data.lightParam.x,0.15,0.02,0.2); // diffuse\n   cycleValue2(data.lightParam.y,0.15,0.02,0.3); // specular\n   cycleValue2(data.lightParam.z,0.15,0.02,0.4); // ambient\n}\n\nvoid alterOrbitColors(inout Dataset data) {\n    const float weight = 0.6;\n    cycleValue(data.OXwt,-weight,weight,0.02); // weights\n    cycleValue(data.OYwt,-weight,weight,0.03);\n    cycleValue(data.OZwt,-weight,weight,0.05);\n //   cycleValue(data.OWwt,-weight,weight,0.07);\n\n    const float color = 2.0;\n    cycleValue(data.OXcr,-color,color,0.01);  // color code\n    cycleValue(data.OYcr,-color,color,0.02);\n    cycleValue(data.OZcr,-color,color,0.03);\n    cycleValue(data.OWcr,-color,color,0.05);\n    \n    cycleValue(data.Ocenter.x,-1.,1.0,0.3);\n    cycleValue(data.Ocenter.y,-1.,1.0,0.5);\n    cycleValue(data.Ocenter.z,-1.,1.0,0.7);\n}\n\nvoid animateSpecifiedVariables(inout Dataset data) {\n    const float amt = 0.3;\n    cycleValue2(data.c.x,data.c.x, amt,0.03);\n    cycleValue2(data.c.y,data.c.y, amt,0.04);\n    cycleValue2(data.c.z,data.c.z, amt,0.05);\n    cycleValue2(data.c.w,data.c.w, amt,0.06);\n    \n    cycleValue2(data.d.x,data.d.x, amt,0.035);\n    cycleValue2(data.d.y,data.d.y, amt,0.045);\n    cycleValue2(data.d.z,data.d.z, amt,0.055);\n    cycleValue2(data.d.w,data.d.w, amt,0.065);\n\n    alterOrbitColors(data);\n    alterLight(data); \n\n  //  moveCamera(data);\n     moveTarget(data);\n\n/*\n    alterLight(data); \n    moveTarget(data);\n\n    cycleValue3(data.Ocycle,OcycleDefault,1.2,0.1);\n    alterOrbitColors(data);\n\n    cycleValue3(data.Ostrength,OstrengthDefault,1.2,0.1);\n*/\n}\n\n// --------------------------------------------------------\n\nvoid readStoredData(inout Dataset data) {\n    vec3 sd = fetchData(iChannel0, FOCUS_ADDR).xyz;\n    data.focus = int(sd.x);\n    data.displayCount = int(sd.y);\n    \n    sd = fetchData(iChannel0, P0_ADDR).xyz;\n    data.c.x = sd.x;\n    data.c.y = sd.y;   \n    data.c.z = sd.z;\n    sd = fetchData(iChannel0, P1_ADDR).xyz;\n    data.c.w = sd.x;\n    data.d.x = sd.y;\n    data.d.y = sd.z;\n    sd = fetchData(iChannel0, P2_ADDR).xyz;\n    data.d.z = sd.x;\n    data.d.w = sd.y;\n    data.invpos.x = sd.z;\n    sd = fetchData(iChannel0, P3_ADDR).xyz;\n    data.invpos.y = sd.x;\n    data.invpos.z = sd.y;\n    data.invradius = sd.z;    \n    sd = fetchData(iChannel0, P4_ADDR).xyz;\n    data.invangle = sd.x;\n    data.camera.x = sd.y;\n    data.camera.y = sd.z;\n    sd = fetchData(iChannel0, P5_ADDR).xyz;\n    data.camera.z = sd.x;\n    data.target.x = sd.y;\n    data.target.y = sd.z;\n    sd = fetchData(iChannel0, P6_ADDR).xyz;\n    data.target.z = sd.x;\n    \n    data.viewVector = fetchData(iChannel0, VV_1).xyz;\n    data.sideVector = fetchData(iChannel0, VV_2).xyz;\n    data.topVector = fetchData(iChannel0, VV_3).xyz;\n}\n\nvoid initializedNonStoredData(inout Dataset data) {\n    data.maxsteps = 5;\n    data.orbitTrap = vec4(10000.);\n    data.epsilon = 0.00001; // deviation when calculating normal\n    \n    data.ambient = 0.56;\n    data.contrast = 0.7;\n    data.vibrant = 0.0999;\n    data.dim = 0.035;\n\tdata.color = vec3(0,0,0); \n\n    data.fogDistance = 0.0 ; // set to 0.0 to disable fog\n    data.fogAmount = 0.02;\n    data.fogColor = 0.5;\n    \n    data.lightColor = vec3(0.5,0.5,0.5); // set to 0.0 to disable light #1\n    data.lightPosition = vec3(9.0,17.0,-20.0);\n    data.lightParam = vec3(0.1,0.3,10.13);\n    \n    data.Ostrength = 0.063; //OstrengthDefault;\n    data.Ocycle = 0.0; // OcycleDefault;\n    data.OXwt = OXwtDefault;\n    data.OXcr = OXcrDefault;\n    data.OYwt = OYwtDefault;\n    data.OYcr = OYcrDefault;\n    data.OZwt = OZwtDefault;\n    data.OZcr = OZcrDefault;\n    data.OWwt = OWwtDefault;\n    data.OWcr = OWcrDefault;\n    data.Ocenter = OcenterDefault;\n    \n    data.inversion = true; \n    \n    data.stereo = false;\n    data.parallax = 0.01; // use smaller values when viewing closeup objects\n}\n\n// --------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Dataset data;\n    readStoredData(data);\n    initializedNonStoredData(data);\n    animateSpecifiedVariables(data);\n\n    setDirection(fragCoord,data);\n\trayMarch(data);\n    \n\tif(data.depth < MAX_DIST) {  \n        data.position = data.camera + data.direction * data.depth;\n        calcNormal(data);\n\t\tapplyColoring(data);\n    }\n\n    if(data.fogDistance != 0.0) {\n        float f = data.depth - data.fogDistance;\n        if(f > 0.0) {\n            f = min(1.0,f * data.fogAmount);\n            data.color = mix(data.color, vec3(0.2 + f * data.fogColor),f);\n        }\n    }\n\n    fragColor = vec4(data.color,1.0);\n    \n    if(data.displayCount > 0) \n        displayData(data,fragColor,fragCoord);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const vec4  cDefault = vec4(0.0538,-1.9459,-0.9764,-0.3450);\nconst vec4  dDefault = vec4(1.5791,3.2993,-1.2991,1.1080);\nconst vec3  cameraDefault = vec3(-1.2764,-3.3,-1.5275); \nconst vec3  targetDefault = vec3(-0.3720156, 0.6879515, 0.6231588); \n\nconst vec3  invposDefault = vec3(0.081,0.2915,0.7482);\nconst float invradiusDefault = 1.3589;\nconst float invangleDefault = 0.9706;\n\nconst float OstrengthDefault = 0.0;\nconst float OcycleDefault = 0.0;\nconst float OXwtDefault = 2.0736677;\nconst float OXcrDefault = -3.9815997;\nconst float OYwtDefault = 2.03396538;\nconst float OYcrDefault = 1.71172849;\nconst float OZwtDefault = -2.74972636;\nconst float OZcrDefault = -0.55577678;\nconst float OWwtDefault = 0.0; \nconst float OWcrDefault = -4.24845531;\nconst vec3  OcenterDefault = vec3(-0.5); \n\n// ========================================================================\n\nstruct ParamData {\n    float start,vmin,vmax,delta;\n};\n\nconst ParamData[] pData = ParamData[]( // 21 entries\n    // p0 ---------------\n    ParamData(cDefault.x, -5.0, 5.0, 0.01), // c\n    ParamData(cDefault.y, -5.0, 5.0, 0.01),\n    ParamData(cDefault.z, -5.0, 5.0, 0.01),\n    // p1 ---------------\n    ParamData(cDefault.w, -5.0, 5.0, 0.01),\n    ParamData(dDefault.x, -5.0, 5.0, 0.01), // d\n    ParamData(dDefault.y, 0.0, 8.0, 1.), \n    // p2 ---------------\n    ParamData(dDefault.z, -5.0, 5.0, 0.01),\n    ParamData(dDefault.w, -5.0, 5.0, 0.01),\n    ParamData(invposDefault.x, -15., 15., 0.01), // invpos\n    // p3 ---------------\n    ParamData(invposDefault.y, -15., 15., 0.01),\n    ParamData(invposDefault.z, -15., 15., 0.01),\n    ParamData(invradiusDefault, 0.01, 10., 0.01),// invradius\n    // p4 ---------------\n    ParamData(invangleDefault, -5., 5., 0.001),  // invangle\n    ParamData(cameraDefault.x, -20., 20., 0.01), // camera \n    ParamData(cameraDefault.y, -20., 20., 0.01),\n    // p5 ---------------\n    ParamData(cameraDefault.z, -20., 20., 0.01),\n    ParamData(targetDefault.x, -20., 20., 0.01), // target\n    ParamData(targetDefault.y, -20., 20., 0.01),\n    // p6 ---------------    \n    ParamData(targetDefault.z, -20., 20., 0.01)\n    // unused\n    // unused\n);\n\nconst ivec2 FOCUS_ADDR = ivec2(1, 0);\nconst ivec2 P0_ADDR = ivec2(2, 0);\nconst ivec2 P1_ADDR = ivec2(3, 0);\nconst ivec2 P2_ADDR = ivec2(4, 0);\nconst ivec2 P3_ADDR = ivec2(5, 0);\nconst ivec2 P4_ADDR = ivec2(6, 0);\nconst ivec2 P5_ADDR = ivec2(7, 0); \nconst ivec2 P6_ADDR = ivec2(8, 0); \nconst ivec2 VV_1 = ivec2(9, 0);   // view vectors\nconst ivec2 VV_2 = ivec2(10, 0);\nconst ivec2 VV_3 = ivec2(11, 0);\n\n#define fetchData(buf, addr) texelFetch(buf, addr, 0)\n#define storeDataAddr(buf_pos, addr) ivec2(buf_pos) == addr\n#define storeData(buf_pos, addr,data) if(ivec2(buf_pos) == addr) fragColor = data\n\n// ========================================================================\n// EasyText: https://www.shadertoy.com/view/dsGXDt\n\n// Set to the iChannel containing the alphabet texture\n#define FONT_TEXTURE iChannel3\n\n// Horizontal character spacing (default: 0.5)\n#define CHAR_SPACING 0.44\n\n/// STRING CREATION ///\n\n// Create a basic string\n#define makeStr(func_name) float func_name(vec2 u) { _print \n\n// Create a string with an int parameter\n#define makeStr1i(func_name) float func_name(vec2 u, int i) { _print\n\n// Create a string with a float parameter\n#define makeStr1f(func_name) float func_name(vec2 u, float i) { _print\n\n// Create a string with two floats parameter\n#define makeStr2f(func_name) float func_name(vec2 u, float i, float j) { _print\n\n// ... Or create your own strings with any parameters\n#define makeStrXX(func_name) float func_name(vec2 u, ...) { _print\n\n// Terminate a string\n#define _end    ); return d; }\n\n// Dynamic uppercase character\n// i: [0-25]\n#define _ch(i)  _ 65+int(i)\n\n// Dynamic digit\n// i: [0-9]\n#define _dig(i) _ 48+int(i)\n\n// Floating point debug\n// x:   value to print\n// dec: number of decimal places to print\n#define _dec(x, dec) ); d += _decimal(FONT_TEXTURE, u, x, dec); (0\n\n// Space\n#define __    ); u.x -= CHAR_SPACING; (0\n\n#define _EXC  _ 33 // \" ! \"\n#define _DBQ  _ 34 // \" \" \"\n#define _NUM  _ 35 // \" # \"\n#define _DOL  _ 36 // \" $ \"\n#define _PER  _ 37 // \" % \"\n#define _AMP  _ 38 // \" & \"\n#define _QUOT _ 39 // \" ' \"\n#define _LPR  _ 40 // \" ( \"\n#define _RPR  _ 41 // \" ) \"\n#define _MUL  _ 42 // \" * \"\n#define _ADD  _ 43 // \" + \"\n#define _COM  _ 44 // \" , \"\n#define _SUB  _ 45 // \" - \"\n#define _DOT  _ 46 // \" . \"\n#define _DIV  _ 47 // \" / \"\n#define _COL  _ 58 // \" : \"\n#define _SEM  _ 59 // \" ; \"\n#define _LES  _ 60 // \" < \"\n#define _EQU  _ 61 // \" = \"\n#define _GRE  _ 62 // \" > \"\n#define _QUE  _ 63 // \" ? \"\n#define _AT   _ 64 // \" @ \"\n#define _LBR  _ 91 // \" [ \"\n#define _ANTI _ 92 // \" \\ \"\n#define _RBR  _ 93 // \" ] \"\n#define _UND  _ 95 // \" _ \"\n\n// Uppercase letters (65-90)\n#define _A _ 65\n#define _B _ 66\n#define _C _ 67\n#define _D _ 68\n#define _E _ 69\n#define _F _ 70\n#define _G _ 71\n#define _H _ 72\n#define _I _ 73\n#define _J _ 74\n#define _K _ 75\n#define _L _ 76\n#define _M _ 77\n#define _N _ 78\n#define _O _ 79\n#define _P _ 80\n#define _Q _ 81\n#define _R _ 82\n#define _S _ 83\n#define _T _ 84\n#define _U _ 85\n#define _V _ 86\n#define _W _ 87\n#define _X _ 88\n#define _Y _ 89\n#define _Z _ 90\n\n// Lowercase letters (97-122)\n#define _a _ 97\n#define _b _ 98\n#define _c _ 99\n#define _d _ 100\n#define _e _ 101\n#define _f _ 102\n#define _g _ 103\n#define _h _ 104\n#define _i _ 105\n#define _j _ 106\n#define _k _ 107\n#define _l _ 108\n#define _m _ 109\n#define _n _ 110\n#define _o _ 111\n#define _p _ 112\n#define _q _ 113\n#define _r _ 114\n#define _s _ 115\n#define _t _ 116\n#define _u _ 117\n#define _v _ 118\n#define _w _ 119\n#define _x _ 120\n#define _y _ 121\n#define _z _ 122\n\n// Digits (48-57)\n#define _0 _ 48\n#define _1 _ 49\n#define _2 _ 50\n#define _3 _ 51\n#define _4 _ 52\n#define _5 _ 53\n#define _6 _ 54\n#define _7 _ 55\n#define _8 _ 56\n#define _9 _ 57\n\n\n/// Internal functions ///\n\n// Start\n#define _print  float d = 0.; (u.x += CHAR_SPACING\n\n// Update\n#define _       ); u.x -= CHAR_SPACING; d += _char(FONT_TEXTURE, u,\n\n// Print character\nfloat _char(sampler2D s, vec2 u, int id) {\n    vec2 p = vec2(id%16, 15. - floor(float(id)/16.));\n         p = (u + p) / 16.;\n         u = step(abs(u-.5), vec2(.5));\n    return texture(s, p).x * u.x * u.y;\n}\n\n// Floating point debug\nfloat _decimal(sampler2D FONT_TEXTURE, inout vec2 u, float n, int decimals) {\n    float d = 0., N = 1.; // d is the final color, N the number of digits before the decimal\n\n    if (n < 0.) {  // If the number is negative\n        n *= -1.;  // Make it positive\n        (0 _SUB ); // Print a minus sign\n    }\n    \n    // Calculate the number of digits before the decimal point\n    for (float x = n; x >= 10.; x /= 10.) N++;\n\n    // Print the digits before the decimal point\n    for (float i = 0.; i < N; i++) {        \n        float magnitude = pow(10., N-i-1.);\n        float leftDigit = floor(n / magnitude);\n        n -= leftDigit * magnitude;\n        \n        (0 _dig(leftDigit) );\n    }\n\n    (0 _DOT ); // Print a dot\n    \n    // Print the digits after the decimal point\n    for (int i = 0; i < decimals; i++) {\n        float firstDecimal = floor((n - floor(n)) * 10.);\n        n *= 10.;\n        \n        (0 _dig(firstDecimal) );\n    }\n    \n    return d;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// keyboard: https://www.shadertoy.com/view/lsXGzf\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst ivec2[] storeAddr = ivec2[]( P0_ADDR,P1_ADDR,P2_ADDR,P3_ADDR,P4_ADDR,P5_ADDR,P6_ADDR );\n\n// --------------------------------------------------------\n\nvoid initializeStorage(inout vec4 fragColor,vec2 fragCoord) {\n    if (storeDataAddr(fragCoord, FOCUS_ADDR)) fragColor.xyz = vec3(0.);\n    if (storeDataAddr(fragCoord, P0_ADDR)) fragColor.xyz = vec3(pData[ 0].start,pData[ 1].start,pData[ 2].start);\n    if (storeDataAddr(fragCoord, P1_ADDR)) fragColor.xyz = vec3(pData[ 3].start,pData[ 4].start,pData[ 5].start);\n    if (storeDataAddr(fragCoord, P2_ADDR)) fragColor.xyz = vec3(pData[ 6].start,pData[ 7].start,pData[ 8].start);\n    if (storeDataAddr(fragCoord, P3_ADDR)) fragColor.xyz = vec3(pData[ 9].start,pData[10].start,pData[11].start);\n    if (storeDataAddr(fragCoord, P4_ADDR)) fragColor.xyz = vec3(pData[12].start,pData[13].start,pData[14].start);\n    if (storeDataAddr(fragCoord, P5_ADDR)) fragColor.xyz = vec3(pData[15].start,pData[16].start,pData[17].start);\n    if (storeDataAddr(fragCoord, P6_ADDR)) fragColor.xyz = vec3(pData[18].start,0.,0.);\n}\n\n// --------------------------------------------------------\n// determine these values as seldom as possible to save work for image shader\n\nvoid updateViewVectors(inout vec4 fragColor,vec2 fragCoord) {\n    if (storeDataAddr(fragCoord, VV_1) || storeDataAddr(fragCoord, VV_2) || storeDataAddr(fragCoord, VV_3)) {\n        vec3 camera,target;        \n        camera.x  = fetchData(iChannel0, P4_ADDR).z;\n        camera.yz = fetchData(iChannel0, P5_ADDR).xy;\n        target.x = fetchData(iChannel0, P5_ADDR).z;\n        target.yz = fetchData(iChannel0, P6_ADDR).xy;\n\n        vec3 viewVector = normalize(target - camera);\n        vec3 sideVector = vec3(0.0, 1.0, 0.0);\n        sideVector = cross(sideVector,viewVector);\n        sideVector = normalize(sideVector);\n        vec3 topVector = viewVector;\n        topVector = cross(topVector,sideVector);\n        \n        if(storeDataAddr(fragCoord, VV_1)) fragColor = vec4(viewVector,1.);\n        if(storeDataAddr(fragCoord, VV_2)) fragColor = vec4(sideVector,1.);\n        if(storeDataAddr(fragCoord, VV_3)) fragColor = vec4(topVector,1.);\n    }\n}\n\n// --------------------------------------------------------\n\nbool keyClick(int ascii) {\n\treturn (texture(iChannel1,vec2((.5+float(ascii))/256.,0.25)).x > 0.);\n}\n\nbool getKeyState(int keyCode){\n    return bool(texelFetch(iChannel1, ivec2(keyCode,0), 0).x != 0.);\n}\nbool getKeyClick(int keyCode){\n    return bool(texelFetch(iChannel1, ivec2(keyCode,1), 0).x != 0.);\n}\n\nvoid acceleratedValue(inout float value) {\n    bool aKey = getKeyState(65);\n    bool zKey = getKeyState(90);\n    \n    if(aKey && zKey) value *= 50.; else\n    if(aKey) value *= 0.1; else\n    if(zKey) value *= 10.0;    \n}\n\n// --------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if(fragCoord.x > 20.0 || fragCoord.y > 1.0) return; // skip unused storage locations\n    \n    if(iFrame < 10 || keyClick(32)) {  // reset settings on coldstart or <Spc> keypress\n        initializeStorage(fragColor, fragCoord);\n        return; \n    }\n           \n    updateViewVectors(fragColor, fragCoord);\n           \n    bool resetDisplayCount = false;\n    int focus = int(fetchData(iChannel0, FOCUS_ADDR).x);\n    int focusIndex = focus / 3;  // vec3 index\n    int focusField = focus % 3;  // x,y,z field within\n\n    // always fetch current values so 'non changes' don't stomp on them \n    for(int i=0;i<7;++i)\n        if (storeDataAddr(fragCoord, storeAddr[i])) \n            fragColor = fetchData(iChannel0, storeAddr[i]);\n    \n    // lt/rt arrow alters focused variable ---------------\n    if (storeDataAddr(fragCoord, storeAddr[focusIndex])) {\n        fragColor = fetchData(iChannel0, storeAddr[focusIndex]); // current value\n        float changeAmount = 0.0;\n        \n        if(getKeyState(KEY_LEFT))  changeAmount = -pData[focus].delta; else\n        if(getKeyState(KEY_RIGHT)) changeAmount = +pData[focus].delta;\n                \n        // mouse -------------------------------\n        if(iMouse.z > 0.0) {\n            vec2 mouseEffect = (iMouse.xy - iMouse.zw) * 0.01;\n            changeAmount = mouseEffect.x * pData[focus].delta;\n        }\n        \n        if(changeAmount != 0.) {\n            acceleratedValue(changeAmount);\n            fragColor[focusField] = clamp(fragColor[focusField] + changeAmount,pData[focus].vmin,pData[focus].vmax);\n        }\n    }   \n    \n    if(getKeyState(KEY_LEFT) || getKeyState(KEY_RIGHT) || iMouse.z > 0.0) resetDisplayCount = true;\n    \n    // alter focus.  update displayCount--------------------------\n    if (storeDataAddr(fragCoord, FOCUS_ADDR)) {\n        fragColor = fetchData(iChannel0, FOCUS_ADDR);\n        \n        bool kym = getKeyClick(KEY_UP);\n        bool kyp = getKeyClick(KEY_DOWN);\n        \n        if(iFrame % 3 == 0) { // slow down auto repeat of up/dn arrows\n            kym = getKeyState(KEY_UP);\n            kyp = getKeyState(KEY_DOWN);\n        }\n        \n        float focusChange = 0.;\n        if(kym) focusChange = -1.; else\n        if(kyp) focusChange = +1.;\n\n        if(focusChange != 0.) {\n            fragColor.x += focusChange;\n\n            const float maxIndex = 18.0;\n            if(fragColor.x < 0.0) fragColor.x = maxIndex;\n            if(fragColor.x > maxIndex) fragColor.x = 0.0;\n\n            resetDisplayCount = true; \n        }\n        \n        if(resetDisplayCount) fragColor.y = iFrameRate; else\n        if(--fragColor.y < 0.0) fragColor.y = 0.0;  // so widget display times out \n    }   \n      \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}