{
    "Shader": {
        "info": {
            "date": "1504429754",
            "description": "Green and slightly gooey (mouse enabled)",
            "flags": 32,
            "hasliked": 0,
            "id": "llsyDn",
            "likes": 4,
            "name": "Quick Slime",
            "published": 3,
            "tags": [
                "reflection",
                "fluid",
                "dynamics"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 769
        },
        "renderpass": [
            {
                "code": "// \"Quick Slime\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nvec2 Rot2D (vec2 q, float a);\nvec4 Loadv4 (int idVar);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\n\nconst int nDisk = 48;\n\nvec3 ltDir;\nvec2 qDisk[nDisk], wallSpc, obsSpc;\nfloat dstFar, layerThk;\nint idObj;\nconst float pi = 3.14159;\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  d = wallSpc.y + p.y;\n  if (d < dMin) { dMin = d;  idObj = 1; }\n  d = wallSpc.y - p.y;\n  if (d < dMin) { dMin = d;  idObj = 2; }\n  d = wallSpc.x - abs (p.x);\n  if (d < dMin) { dMin = d;  idObj = 3; }\n  q = p;\n  q.x = mod (q.x, 2. * obsSpc.x) - obsSpc.x;\n  q.y -= - wallSpc.y;\n  q.z = mod (q.z + obsSpc.y, 2. * obsSpc.y) - obsSpc.y;\n  d = PrCapsDf (q.xzy, 0.5, 0.5);\n  if (d < dMin) { dMin = d;  idObj = 4; }\n  q = p;\n  q.x = abs (q.x) - wallSpc.x - 0.1;\n  q.y -= 0.5 * wallSpc.y;\n  q.z = mod (q.z, 2. * obsSpc.y) - obsSpc.y;\n  d = PrCapsDf (q.xzy, 0.3, 0.4);\n  if (d < dMin) { dMin = d;  idObj = 5; }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 300; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat SlimeDf (vec3 p)\n{\n  float dMin, d;\n  dMin = dstFar;\n  for (int n = 0; n < nDisk; n ++) {\n    dMin = max (SmoothMin (length (p.xz - qDisk[n]) - 0.55, dMin, 1.5),\n       abs (p.y + wallSpc.y - layerThk) - layerThk);\n  }\n  dMin = SmoothMax (dMin, abs (p.y + wallSpc.y - layerThk) - layerThk, 0.1);\n  return dMin;\n}\n\nfloat SlimeRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  if (rd.y < 0.) {\n    dHit = - (ro.y + wallSpc.y - layerThk - 0.1) / rd.y;\n    for (int j = 0; j < 100; j ++) {\n      d = SlimeDf (ro + dHit * rd);\n      dHit += d;\n      if (d < 0.001 || dHit > dstFar) break;\n    }\n  } else dHit = dstFar;\n  return dHit;\n}\n\nvec3 SlimeNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (SlimeDf (p + e.xxx), SlimeDf (p + e.xyy),\n     SlimeDf (p + e.yxy), SlimeDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\n#define SQRT3 1.7320508\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./SQRT3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (SQRT3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec3 HexGrid (vec2 p)\n{\n  vec2 q;\n  p -= HexToPix (PixToHex (p));\n  q = abs (p);\n  return vec3 (p, (SQRT3/2.) - q.x + 0.5 * min (q.x - SQRT3 * q.y, 0.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn, vns, roo, qh;\n  float dstObj, dstSlime, spec, reflAtn, s;\n  bool hitSlime;\n  roo = ro;\n  reflAtn = 1.;\n  hitSlime = false;\n  for (int nr = 0; nr < 4; nr ++) {\n    dstObj = ObjRay (ro, rd);\n    dstSlime = SlimeRay (ro, rd);\n    if (dstSlime < min (dstObj, dstFar)) {\n      dstObj = dstSlime;\n      hitSlime = true;\n      idObj = 6;\n    }\n    if (dstObj < dstFar) {\n      ro += rd * dstObj;\n      vn = (idObj == 6) ? SlimeNf (ro) : ObjNf (ro);\n      if (idObj == 6) vns = vn;\n      if (idObj == 2 || idObj == 3)\n         s = abs (mod (ro.z + obsSpc.y, 2. * obsSpc.y) - obsSpc.y) - (obsSpc.y - 0.5);\n      if (idObj == 2 && s < 0. && abs (ro.x) < wallSpc.x - 0.5 ||\n         idObj == 3 && s < 0. && abs (ro.y) < wallSpc.y - 0.5 ||\n         idObj == 4 && ro.y > - wallSpc.y + 0.1 || idObj == 6) {\n        rd = reflect (rd, vn);\n        ro += 0.01 * rd;\n        reflAtn *= 0.9 * reflAtn;\n      } else break;\n    } else break;\n  }\n  if (dstObj < dstFar) {\n    vn = ObjNf (ro);\n    if (idObj == 1) {\n      qh = HexGrid (2. * ro.zx);\n      col = vec3 (0.5, 0.3, 0.1) * (0.7 + 0.3 * smoothstep (0.03, 0.06, qh.z)) *\n         (1. - 0.1 * Noisefv2 (150. * ro.xz));\n      s = max (length (qh.xy) - 0.5, 0.);\n      vn = vec3 (0., Rot2D (vec2 (1., 0.), 4. * s * s));\n      vn.zx = vn.z * vec2 (qh.x, - qh.y) / length (qh.xy);\n      spec = 0.2;\n    } else if (idObj == 2 || idObj == 3) {\n      s = (idObj == 2) ? ro.x : ro.y;\n      col = vec3 (0.8, 0.8, 1.) * (1. - 0.4 * Fbm2 (100. * vec2 (ro.z, s)));\n      spec = 0.1;\n    } else if (idObj == 4) {\n      col = vec3 (0.2, 0.1, 0.);\n      spec = 0.4;\n    } else if (idObj == 5) {\n      col = vec3 (1., 0.9, 0.7) * (0.1 + 0.9 * abs (vn.x)) *\n         (1. - smoothstep (0.5, 0.8, length (ro - roo) / dstFar));\n    }\n    if (idObj != 5) col = col * (0.3 + 0.7 * max (dot (vn, ltDir), 0.)) +\n         spec * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n      col = mix (col * reflAtn, vec3 (0.06, 0.06, 0.),\n         smoothstep (0.6, 1., length (ro - roo) / dstFar));\n  } else col = vec3 (0.06, 0.06, 0.);\n  if (hitSlime) col = mix (col, vec3 (0., 0.8, 0.) * (0.5 + 0.5 * max (dot (vns, ltDir), 0.)), 0.4);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec4 stDat;\n  vec3 rd, ro, u, vd;\n  vec2 canvas, uv, rLead, rCent;\n  float tCur, f, az, el;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  dstFar = 400.;\n  stDat = Loadv4 (1);\n  rCent = stDat.xy;\n  rLead = stDat.zw;\n  stDat = Loadv4 (2);\n  wallSpc = stDat.xy;\n  obsSpc = stDat.zw;\n  for (int n = 0; n < nDisk; n ++) qDisk[n] = Loadv4 (4 + n).xy;\n  ro = vec3 (rCent.x + 0.3 * sin (0.2 * tCur), 0., rCent.y);\n  vd = vec3 (rCent.x, 0., rCent.y);\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 0.4 * pi * mPtr.x;\n    el += 0.4 * pi * mPtr.y;\n  }\n  if (mod (0.015 * tCur, 1.) < 0.5) {\n    ro.z += 10.;\n    vd.z += 6.;\n  } else {\n    ro.z -= 13.;\n    vd.z -= 9.;\n    el *= -1.;\n  }\n  vd = normalize (vd - ro);\n  vd.yz = Rot2D (vd.yz, el);\n  vd.zx = Rot2D (vd.zx, az);\n  u = - vd.y * vd;\n  f = 1. / sqrt (1. - vd.y * vd.y);\n  vuMat = mat3 (f * vec3 (vd.z, 0., - vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd);\n  rd = vuMat * normalize (vec3 (uv, 1.2));\n  layerThk = 0.05;\n  ltDir = normalize (vec3 (0.25, 1., 0.5));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Quick Slime\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nDisk = 48;\n\nvec2 wallSpc, obsSpc;\nfloat tCur;\nconst float txRow = 128.;\nconst float pi = 3.14159;\n\nvoid Step (int mId, vec2 rLead, vec2 vCent, out vec4 p)\n{\n  vec2 r, rn, vn, dr, f, v, u;\n  float fOvlap, fAttr, fLead, vDamp, fricN, rSep, dt;\n  fOvlap = 500.;\n  fAttr = 0.005;\n  fricN = 3.;\n  vDamp = 0.2;\n  fLead = 0.5;\n  dt = 0.02;\n  p = Loadv4 (4 + mId);\n  r = p.xy;\n  v = p.zw;\n  f = vec2 (0.);\n  for (int n = 0; n < nDisk; n ++) {\n    if (n != mId) {\n      p = Loadv4 (4 + n);\n      rn = p.xy;\n      vn = p.zw;\n      dr = r - rn;\n      rSep = length (dr);\n      f -= fAttr * dr;\n      if (rSep < 1.) f += (fOvlap * (1. / rSep - 1.) -\n         fricN * (dot ((v - vn), dr)/ (rSep * rSep))) * dr;\n    }\n  }\n  dr.x = wallSpc.x - abs (r.x);\n  rSep = abs (dr.x);\n  if (rSep < 1.) f.x -= (fOvlap * (1. / rSep - 1.) -\n     fricN * v.x / rSep) * rSep * sign (r.x);\n  u = r / (2. * obsSpc);\n  dr = r - 2. * obsSpc * vec2 ((floor (u.x) + 0.5), floor (u.y + 0.5)); \n  rSep = length (dr);\n  if (rSep < 1.) f += (fOvlap * (1. / rSep - 1.) -\n     fricN * (dot (v, dr)/ (rSep * rSep))) * dr;\n  f += fLead * (rLead - r) + vDamp * (vCent - v) - vDamp * v;\n  v += dt * f;\n  r += dt * v;\n  p = vec4 (r, v);\n}\n\nvoid Init (int mId, out vec4 p)\n{\n  vec3 e;\n  vec2 r, v;\n  float a;\n  int nbEdge;\n  nbEdge = 2;\n  r.y = float (mId / nbEdge);\n  r.x = float (mId) - float (nbEdge) * r.y;\n  r = 0.98 * (r - 0.5 * float (nbEdge - 1));\n  v = vec2 (0.);\n  p = vec4 (r, v);\n  a = mod (tCur, 1.) + float (mId) / float (nDisk);\n  e = normalize (vec3 (Hashff (mod (a, 1.)),\n     Hashff (mod (a + 0.2, 1.)), Hashff (mod (a + 0.4, 1.))));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat, p;\n  vec2 iFrag, rLead, rCent, vCent;\n  float nStep;\n  int mId, pxId;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= nDisk + 4) discard;\n  tCur = iTime;\n  if (pxId >= 4) mId = pxId - 4;\n  else mId = -1;\n  nStep = 0.;\n  if (iFrame <= 5) {\n    nStep = 0.;\n    wallSpc = vec2 (6., 4.);\n    obsSpc = vec2 (1.8, 4.);\n    rCent = vec2 (0.);\n    rLead = rCent + vec2 (0., 1.);\n    if (mId >= 0) Init (mId, p);\n  } else {\n    stDat = Loadv4 (0);\n    nStep = stDat.x;\n    ++ nStep;\n    stDat = Loadv4 (2);\n    wallSpc = stDat.xy;\n    obsSpc = stDat.zw;\n    vCent = vec2 (0., 2.);\n    rCent = vec2 (0., 0.02 * nStep * vCent.y);\n    rLead = rCent + 0.3 * wallSpc.x * vec2 (sin (0.007 * nStep), 1.);\n    if (mId >= 0) Step (mId, rLead, vCent, p);\n  }\n  if (pxId == 0) stDat = vec4 (nStep, 0., 0., 0.);\n  else if (pxId == 1) stDat = vec4 (rCent, rLead);\n  else if (pxId == 2) stDat = vec4 (wallSpc, obsSpc);\n  Savev4 (pxId, ((pxId >= 4) ? p : stDat), fragColor, fragCoord);\n}\n\nfloat Hashff (float p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (p) * cHashM);\n}\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}