{
    "Shader": {
        "info": {
            "date": "1720202475",
            "description": "layer count depends on the ray-surface angle\n",
            "flags": 0,
            "hasliked": 0,
            "id": "M3ySRK",
            "likes": 18,
            "name": "Parallax Occlusion Mapping X",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "parallax",
                "map",
                "heightmap",
                "bump",
                "occlusion",
                "mapping",
                "height",
                "depth",
                "pom"
            ],
            "usePreview": 0,
            "username": "beans_please",
            "viewed": 351
        },
        "renderpass": [
            {
                "code": "vec3 render(vec2 coord, vec2 render_res, in Camera cam, float time)\n{\n    vec2 uv01 = screen_to_uv01(coord, render_res.xy);\n    Ray r = Camera_gen_ray(cam, uv01);\n    \n    Hit h;\n    trace_ray(r, time, h, iChannel1);\n    \n    if (!h.hit)\n    {\n        return env(r.dir);\n    }\n    \n    // base color\n    vec3 base_col = 1.25 * pow(texture(iChannel0, h.uv).rgb, vec3(2.2));\n    \n    // lambert diffuse\n    float dl = dot(h.n, SUN_DIR);\n    vec3 col = max(0., dl) * base_col;\n    \n    // fake GI\n    vec3 gi = .3 * pow(base_col, vec3(2)) + vec3(0, .005, .01);\n    col += remap01(dl, -1., 0.) * gi;\n    \n    return col;\n}\n\n// ASC CDL color grading\n// https://en.wikipedia.org/wiki/ASC_CDL\nvec3 asc_cdl(vec3 col, vec3 slope, vec3 offset, vec3 power)\n{\n    return pow(max(col, 0.) * slope + offset, power);\n}\n\nvec3 view_transform(vec3 col)\n{\n    // avoid any negative values before using power functions\n    col = max(col, 0.);\n\n    // color grading\n    col = asc_cdl(\n        col,\n        1.1 * vec3(1, .903, .94),\n        vec3(0, 0, .007),\n        1.05 * vec3(1, .95, 1)\n    );\n    \n    // flim\n    const float exposure = 0.;\n    col = flim_transform(col, exposure, false);\n\n    // OETF (Linear BT.709 I-D65 to sRGB 2.2)\n    col = pow(col, vec3(1. / 2.2));\n    col = clamp(col, 0., 1.);\n\n    return col;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    ivec2 icoord = ivec2(frag_coord);\n\n    // camera\n    Camera cam;\n    cam.sensor_height = .035;\n    cam.sensor_width = cam.sensor_height * (iResolution.x / iResolution.y);\n    cam.focal_length = .021;\n    cam.pos = vec3(0, -1.4, .4 + .2 * cos(TAU * .4 * iTime));\n    Camera_look_at(cam, vec3(0, 0, -.15), vec3(0, 0, 1));\n    \n    // scene time\n    float time = transform_time(iTime);\n\n    // render with jittering\n    vec3 col = vec3(0);\n    const int n_samples = 8;\n    for (int i = 0; i < n_samples; i++)\n    {\n        vec2 offs = halton_2d(i + 1);\n        col += render(\n            frag_coord + offs,\n            iResolution.xy,\n            cam,\n            time\n        );\n    }\n    col /= float(n_samples);\n    \n    // view transform\n    col = view_transform(col);\n\n    // output\n    frag_col = vec4(col, 1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*___________ math & integer utils ____________*/\n\nconst float PI = 3.141592653589793238462643383;\nconst float TAU = 6.283185307179586476925286767;\nconst float PI_OVER_2 = 1.570796326794896619231321692;\nconst float INV_PI = .318309886183790671537767527;\nconst float INV_TAU = .159154943091895335768883763;\n\n#define FUNC_WRAP(T) \\\nT wrap(T v, float start, float end) \\\n{ \\\n    return start + mod(v - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T v, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start \\\n        + ((out_end - out_start) / (inp_end - inp_start)) * (v - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp( \\\n    T v, \\\n    float inp_start, \\\n    float inp_end, \\\n    float out_start, \\\n    float out_end \\\n) \\\n{ \\\n    T t = clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\n#define FUNC_REMAP01(T) \\\nT remap01(T v, float inp_start, float inp_end) \\\n{ \\\n    return clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n}\n\n#define FUNC_LENGTH_SQ(T) \\\nfloat length_sq(T v) \\\n{ \\\n    return dot(v, v); \\\n}\n\n#define FUNC_DIST_SQ(T) \\\nfloat dist_sq(T a, T b) \\\n{ \\\n    a -= b; \\\n    return dot(a, a); \\\n}\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\nFUNC_REMAP01(float)\nFUNC_REMAP01(vec2)\nFUNC_REMAP01(vec3)\nFUNC_REMAP01(vec4)\n\nFUNC_LENGTH_SQ(vec2)\nFUNC_LENGTH_SQ(vec3)\nFUNC_LENGTH_SQ(vec4)\n\nFUNC_DIST_SQ(vec2)\nFUNC_DIST_SQ(vec3)\nFUNC_DIST_SQ(vec4)\n\nfloat chebyshev_dist(vec2 a, vec2 b)\n{\n    return max(abs(a.x - b.x), abs(a.y - b.y));\n}\n\nfloat chebyshev_dist(vec3 a, vec3 b)\n{\n    return max(\n        max(abs(a.x - b.x), abs(a.y - b.y)),\n        abs(a.z - b.z)\n    );\n}\n\nfloat chebyshev_dist(vec4 a, vec4 b)\n{\n    return max(\n        max(\n            max(abs(a.x - b.x), abs(a.y - b.y)),\n            abs(a.z - b.z)\n        ),\n        abs(a.w - b.w)\n    );\n}\n\n#define idiv_ceil(a, b) ((a + b - 1) / b)\n\nint iabs(int v)\n{\n    if (v < 0)\n    {\n        return -v;\n    }\n    return v;\n}\n\nint imin(int a, int b)\n{\n    if (a < b)\n    {\n        return a;\n    }\n    return b;\n}\n\nint imax(int a, int b)\n{\n    if (a > b)\n    {\n        return a;\n    }\n    return b;\n}\n\nint iclamp(int v, int start, int end)\n{\n    if (v < start)\n    {\n        v = start;\n    }\n    if (v > end)\n    {\n        v = end;\n    }\n    return v;\n}\n\nfloat min_component(vec2 v)\n{\n    return min(v.x, v.y);\n}\n\nfloat min_component(vec3 v)\n{\n    return min(min(v.x, v.y), v.z);\n}\n\nfloat min_component(vec4 v)\n{\n    return min(min(min(v.x, v.y), v.z), v.w);\n}\n\nfloat max_component(vec2 v)\n{\n    return max(v.x, v.y);\n}\n\nfloat max_component(vec3 v)\n{\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat max_component(vec4 v)\n{\n    return max(max(max(v.x, v.y), v.z), v.w);\n}\n\nint min_component(ivec2 v)\n{\n    return imin(v.x, v.y);\n}\n\nint min_component(ivec3 v)\n{\n    return imin(imin(v.x, v.y), v.z);\n}\n\nint min_component(ivec4 v)\n{\n    return imin(imin(imin(v.x, v.y), v.z), v.w);\n}\n\nint max_component(ivec2 v)\n{\n    return imax(v.x, v.y);\n}\n\nint max_component(ivec3 v)\n{\n    return imax(imax(v.x, v.y), v.z);\n}\n\nint max_component(ivec4 v)\n{\n    return imax(imax(imax(v.x, v.y), v.z), v.w);\n}\n\nfloat bilinear(\n    float val_bl,\n    float val_tl,\n    float val_tr,\n    float val_br,\n    vec2 offs\n)\n{\n    return mix(\n        mix(val_bl, val_br, offs.x),\n        mix(val_tl, val_tr, offs.x),\n        offs.y\n    );\n}\n\n// credits to AHSEN (https://www.shadertoy.com/user/01000001)\n// https://www.desmos.com/calculator/5d6ph151vi interactive :D\nfloat cubic_interp(float a, float b, float c, float d, float t)\n{\n    float one = t - 1.;\n    float two = t - 2.;\n    float three = t - 3.;\n    return (\n        (-one * two * three * a)\n        + (t * one * two * d)\n        + (3. * t * two * three * b)\n        - (3. * t * one * three * c)\n    ) / 6.;\n}\n\nfloat dist_along_line(vec2 p, vec2 line_start, vec2 line_end)\n{\n    vec2 dir = line_end - line_start;\n    \n    // normalize\n    float len_sqr = dot(dir, dir);\n    if (len_sqr < .0001)\n        return 1e9;\n    dir /= sqrt(len_sqr);\n    \n    return dot(\n        dir,\n        p - line_start\n    );\n}\n\nfloat relative_dist_along_line(vec2 p, vec2 line_start, vec2 line_end)\n{\n    vec2 dir = line_end - line_start;\n    return dot(\n        dir,\n        p - line_start\n    );\n}\n\n// |a| * |b| * sin(theta)\nfloat cross2d(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n// references for barycentric coordinates\n// https://www.desmos.com/calculator/8g8xjejuox\n// https://www.shadertoy.com/view/mdjBWK\n\nvec3 cartesian_to_barycentric(\n    vec2 p,\n    vec2 v0,\n    vec2 v1,\n    vec2 v2,\n    bool clamp_,\n    out bool p_is_outside\n)\n{\n    vec3 b = vec3(\n        cross2d(v1 - p, v2 - p),\n        cross2d(v2 - p, v0 - p),\n        cross2d(v0 - p, v1 - p)\n    ) / cross2d(v1 - v0, v2 - v0);\n    p_is_outside = min(min(b.x, b.y), b.z) < 0.;\n    if (clamp_)\n    {\n        b = max(b, 0.);\n        b /= (b.x + b.y + b.z);\n    }\n    return b;\n}\n\nvec3 cartesian_to_barycentric(\n    vec3 p,\n    vec3 v0,\n    vec3 v1,\n    vec3 v2,\n    bool clamp_,\n    out bool p_is_outside\n)\n{\n    vec3 b = vec3(\n        length(cross(v1 - p, v2 - p)),\n        length(cross(v2 - p, v0 - p)),\n        length(cross(v0 - p, v1 - p))\n    ) / length(cross(v1 - v0, v2 - v0));\n    p_is_outside = min(min(b.x, b.y), b.z) < 0.;\n    if (clamp_)\n    {\n        b = max(b, 0.);\n        b /= (b.x + b.y + b.z);\n    }\n    return b;\n}\n\nfloat barycentric_interpolate(vec3 b, float v0, float v1, float v2)\n{\n    return dot(b, vec3(v0, v1, v2));\n}\n\nvec2 barycentric_interpolate(vec3 b, vec2 v0, vec2 v1, vec2 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nvec3 barycentric_interpolate(vec3 b, vec3 v0, vec3 v1, vec3 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nvec4 barycentric_interpolate(vec3 b, vec4 v0, vec4 v1, vec4 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nfloat barycentric_interpolate(vec2 b, float v0, float v1, float v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec2 barycentric_interpolate(vec2 b, vec2 v0, vec2 v1, vec2 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec3 barycentric_interpolate(vec2 b, vec3 v0, vec3 v1, vec3 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec4 barycentric_interpolate(vec2 b, vec4 v0, vec4 v1, vec4 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\n// angle from 0 to TAU\nfloat get_angle(vec2 p)\n{\n    float a = atan(p.y, p.x);\n    if (a < 0.)\n    {\n        return a + TAU;\n    }\n    return a;\n}\n\nmat2 rotate_2d(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(\n        c, s,\n        -s, c\n    );\n}\n\nvec2 perpendicular(vec2 v)\n{\n    return vec2(-v.y, v.x);\n}\n\n// s.x=theta\n// s.y=phi\n// (there's no r)\nvec3 spherical_to_cartesian(vec2 s)\n{\n    float sin_theta = sin(s.x);\n    return vec3(\n        sin_theta * cos(s.y),\n        sin_theta * sin(s.y),\n        cos(s.x)\n    );\n}\n\n// s.x=r\n// s.y=theta\n// s.z=phi\nvec3 spherical_to_cartesian(vec3 s)\n{\n    float sin_theta = sin(s.y);\n    return s.x * vec3(\n        sin_theta * cos(s.z),\n        sin_theta * sin(s.z),\n        cos(s.y)\n    );\n}\n\nvec2 screen_to_uv01(vec2 coord, vec2 res)\n{\n    return coord / res;\n}\n\nvec2 screen_to_uv_horizontal(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / res.x;\n}\n\nvec2 screen_to_uv_vertical(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / res.y;\n}\n\nvec2 screen_to_uv_fit(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / min_component(res);\n}\n\nvec2 screen_to_uv_fill(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / max_component(res);\n}\n\n// * idx starts at 1\nfloat halton(int base, int idx)\n{\n    float result = 0.;\n    float digit_weight = 1.;\n    while (idx > 0)\n    {\n        digit_weight /= float(base);\n        result += float(idx % base) * digit_weight;\n        idx /= base;\n    }\n    return result;\n}\n\n// * idx starts at 1\nvec2 halton_2d(int idx)\n{\n    return vec2(halton(2, idx), halton(3, idx));\n}\n\n// * idx starts at 1\nvec3 halton_3d(int idx)\n{\n    return vec3(halton(2, idx), halton(3, idx), halton(5, idx));\n}\n\n// * idx starts at 1\nvec4 halton_4d(int idx)\n{\n    return vec4(\n        halton(2, idx),\n        halton(3, idx),\n        halton(5, idx),\n        halton(7, idx)\n    );\n}\n\n// for some reason we can't use intBitsToFloat() or floatBitsToInt() to store\n// integers below this value in a buffer.\nconst int BUFFER_MIN_INTEGER = 8388608;\n\n// * x must not be higher than 4,286,578,688 (see BUFFER_MIN_INTEGER above)\n// * for your sanity, don't use negative values\nfloat encode_int_for_buffer(int v)\n{\n    return intBitsToFloat(v + BUFFER_MIN_INTEGER);\n}\n\nint decode_int_from_buffer(float v)\n{\n    return floatBitsToInt(v) - BUFFER_MIN_INTEGER;\n}\n\n// pack two 16-bit integers in a single 32-bit integer\n// * both arguments should be in the 0-65535 range\n// * a must be less than 65279 (see the functions above)\nint pack_i16(int a, int b)\n{\n    return (a << 16) | b;\n}\n\n// unpack two 16-bit integers from a single 32-bit integer\nvoid unpack_i16(int v, out int a, out int b)\n{\n    a = (v >> 16) & 65535;\n    b = v & 65535;\n}\n\n// unpack the first 16-bit integer from a 32-bit integer\nint unpack_i16_a(int v)\n{\n    return (v >> 16) & 65535;\n}\n\n// unpack the second 16-bit integer from a 32-bit integer\nint unpack_i16_b(int v)\n{\n    return v & 65535;\n}\n\nbool icoord_in_bounds(ivec2 icoord, ivec2 ires)\n{\n    return\n        icoord.x >= 0 &&\n        icoord.y >= 0 &&\n        icoord.x < ires.x &&\n        icoord.y < ires.y;\n}\n\nbool icoord_in_bounds(ivec3 icoord, ivec3 ires)\n{\n    return\n        icoord.x >= 0 &&\n        icoord.y >= 0 &&\n        icoord.z >= 0 &&\n        icoord.x < ires.x &&\n        icoord.y < ires.y &&\n        icoord.z < ires.z;\n}\n\nint icoord_to_idx(ivec2 icoord, ivec2 ires)\n{\n    return icoord.x + (icoord.y * ires.x);\n}\n\nint icoord_to_idx(ivec3 icoord, ivec3 ires)\n{\n    return icoord.x + (icoord.y * ires.x) + (icoord.z * ires.x * ires.y);\n}\n\nivec2 idx_to_icoord(int idx, ivec2 ires)\n{\n    return ivec2(idx % ires.x, idx / ires.x);\n}\n\nivec3 idx_to_icoord(int idx, ivec3 ires)\n{\n    return ivec3(\n        idx % ires.x,\n        (idx % (ires.x * ires.y)) / ires.x,\n        idx / (ires.x * ires.y)\n    );\n}\n\n// https://www.desmos.com/calculator/kfe07basy9\n\nint compress_float_to_int_linear(float f, float min_f, float max_f, int max_i)\n{\n    return int(floor(\n        float(max_i) * remap01(f, min_f, max_f)\n    ));\n}\n\nfloat decompress_float_from_int_linear(\n    int i,\n    int max_i,\n    float min_f,\n    float max_f\n)\n{\n    return remap_clamp(\n        float(i) / float(max_i),\n        0., 1.,\n        min_f, max_f\n    );\n}\n\nint compress_float_to_int_log(\n    float f,\n    float log2_zero_offset,\n    float max_log2_f,\n    int max_i\n)\n{\n    f = max(0., f);\n    f += pow(2., log2_zero_offset);\n    return int(floor(\n        float(max_i) * remap01(log2(f), log2_zero_offset, max_log2_f)\n    ));\n}\n\nfloat decompress_float_from_int_log(\n    int i,\n    int max_i,\n    float log2_zero_offset,\n    float max_log2_f\n)\n{\n    return pow(2., remap_clamp(\n        float(i) / float(max_i),\n        0., 1.,\n        log2_zero_offset, max_log2_f\n    )) - pow(2., log2_zero_offset);\n}\n\n\n\n/*_______ pseudo-random number generator ______*/\n// source: https://www.shadertoy.com/view/WdSSRt\n// (heavily modified)\n\n/* usage example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // use the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\n// random uint from 0 to 2^32-1\nuint randomui()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 2654435771u, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return result;\n}\n\n// random int from 0 to 2^31-1\nint randomi()\n{\n    return int(randomui() % 0x7FFFFFFFu);\n}\n\n// random float from 0 to 1\nfloat random()\n{\n    return float(randomui()) / float(0xffffffffu);\n}\n\n// generate two normally distributed random numbers using the\n// Box-Muller transform\n// https://www.baeldung.com/cs/uniform-to-normal-distribution\nvec2 random_gauss()\n{\n    float u1 = random();\n    float u2 = random() * TAU;\n    float temp = sqrt(-2. * log(u1));\n    return temp * vec2(cos(u2), sin(u2));\n    \n    // unoptimized version\n    //float u1 = random();\n    //float u2 = random();\n    //return vec2(cos(TAU * u2), sin(TAU * u2)) * sqrt(-2. * log(u1));\n}\n\nvec2 random_on_circle()\n{\n    vec2 v = vec2(1);\n    float lensqr;\n\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec3 random_on_sphere()\n{\n    vec3 v = vec3(1);\n    float lensqr;\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec2 random_in_circle()\n{\n    vec2 v = vec2(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\nvec3 random_in_sphere()\n{\n    vec3 v = vec3(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\nvec3 random_on_hemisphere(vec3 normal)\n{\n    vec3 v = random_on_sphere();\n    return v * sign(dot(v, normal));\n}\n\nvec3 random_in_hemisphere(vec3 normal)\n{\n    vec3 v = random_in_sphere();\n    return v * sign(dot(v, normal));\n}\n\n// initialize with uvec2\nvoid prng_init(uvec2 seed)\n{\n    seed += uvec2(1317, 944573125);\n    seed *= 464973573u;\n    prng_state[0] = seed.x;\n    prng_state[1] = seed.y;\n    randomi();\n}\n\n// initialize with uint\nvoid prng_init(uint seed)\n{\n    prng_init(uvec2(seed, 1));\n}\n\n// initialize with vec3\nvoid prng_init(vec3 seed)\n{\n    seed += 3.49276101561702;\n    seed.xy *= (seed.z + 10.258);\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    randomui();\n}\n\n// initialize with vec2\nvoid prng_init(vec2 seed)\n{\n    prng_init(vec3(seed, 1));\n}\n\n// initialize with float\nvoid prng_init(float seed)\n{\n    prng_init(vec3(seed, 1, 1));\n}\n\n\n\n/*___________________ scene ___________________*/\n\nconst vec3 SUN_DIR = normalize(vec3(.13, .2, .13));\n\nfloat transform_time(float t)\n{\n    return t;\n}\n\n// sample the environment color\nvec3 env(vec3 dir)\n{\n    float vertical_angle = degrees(acos(.9999 * dir.z));\n    vec3 col = mix(\n        vec3(.2, .5, .8),\n        vec3(.05, .2, .5),\n        smoothstep(90., 30., vertical_angle)\n    );\n    col = mix(\n        col,\n        vec3(.05, .04, .02),\n        float(vertical_angle > 90.)\n    );\n    return col;\n}\n\nconst float POM_MAX_HEIGHT = .3;\nconst float POM_MIN_LAYERS = 20.;\nconst float POM_MAX_LAYERS = 80.;\nconst float POM_EPS_NORMAL = .001;\nconst bool POM_CUT_EDGES = false;\n\nfloat pom_heightmap01(vec2 uv, in sampler2D tex)\n{\n    return pow(texture(tex, uv).r, 2.2);\n}\n\n\n\n/*________________ ray tracing ________________*/\n\nstruct Ray\n{\n    vec3 orig;\n    vec3 dir; // must be normalized\n};\n\nstruct OrthonormalBasis\n{\n    vec3 right;\n    vec3 forward;\n    vec3 up;\n};\n\n// * all three arguments must be normalized and perpendicular to each other\nOrthonormalBasis OrthonormalBasis_new(vec3 right, vec3 forward, vec3 up)\n{\n    OrthonormalBasis onb;\n    onb.right = right;\n    onb.forward = forward;\n    onb.up = up;\n    return onb;\n}\n\n// * forward must be normalized\nOrthonormalBasis OrthonormalBasis_from_forward_and_world_up(\n    vec3 forward,\n    vec3 world_up\n)\n{\n    OrthonormalBasis onb;\n    onb.forward = forward;\n    onb.right = normalize(cross(onb.forward, world_up));\n    onb.up = cross(onb.right, onb.forward);\n    return onb;\n}\n\nvec3 OrthonormalBasis_localize(in OrthonormalBasis self, vec3 p)\n{\n    return vec3(\n        dot(p, self.right),\n        dot(p, self.forward),\n        dot(p, self.up)\n    );\n}\n\nvec3 OrthonormalBasis_delocalize(in OrthonormalBasis self, vec3 p)\n{\n    return (p.x * self.right) + (p.y * self.forward) + (p.z * self.up);\n}\n\n// basic perspective camera\nstruct Camera\n{\n    vec3 pos;\n    float sensor_width;\n    float sensor_height;\n    float focal_length;\n\n    OrthonormalBasis _onb;\n};\n\n// FOV and focal length formula\n// https://www.desmos.com/calculator/5smpkhn02l\n\n// Camera: adjust focal length based on horizontal FOV and sensor width\nvoid Camera_set_fov_horizontal(inout Camera self, float fov)\n{\n    self.focal_length = .5 * self.sensor_width / tan(.5 * fov);\n}\n\n// Camera: calculate the horizontal FOV\nfloat Camera_get_fov_horizontal(in Camera self)\n{\n    return 2. * atan(.5 * self.sensor_width / self.focal_length);\n}\n\n// Camera: adjust focal length based on vertical FOV and sensor height\nvoid Camera_set_fov_vertical(inout Camera self, float fov)\n{\n    self.focal_length = .5 * self.sensor_height / tan(.5 * fov);\n}\n\n// Camera: calculate the vertical FOV\nfloat Camera_get_fov_vertical(in Camera self)\n{\n    return 2. * atan(.5 * self.sensor_height / self.focal_length);\n}\n\n// Camera: adjust focal length based on diagonal FOV and sensor size\nvoid Camera_set_fov_diagonal(inout Camera self, float fov)\n{\n    float sensor_size = length(vec2(self.sensor_width, self.sensor_height));\n    self.focal_length = .5 * sensor_size / tan(.5 * fov);\n}\n\n// Camera: calculate the diagonal FOV\nfloat Camera_get_fov_diagonal(in Camera self)\n{\n    float sensor_size = length(vec2(self.sensor_width, self.sensor_height));\n    return 2. * atan(.5 * sensor_size / self.focal_length);\n}\n\n// Camera: look at a point\nvoid Camera_look_at(inout Camera self, vec3 target, vec3 world_up)\n{\n    self._onb = OrthonormalBasis_from_forward_and_world_up(\n        normalize(target - self.pos),\n        world_up\n    );\n}\n\n// Camera: look along a direction\n// * dir must be normalized\nvoid Camera_look_along(inout Camera self, vec3 dir, vec3 world_up)\n{\n    self._onb = OrthonormalBasis_from_forward_and_world_up(\n        dir,\n        world_up\n    );\n}\n\n// Camera: generate a camera ray for given UV coordinates\nRay Camera_gen_ray(in Camera self, vec2 uv01)\n{\n    Ray r;\n    r.orig = self.pos + OrthonormalBasis_delocalize(self._onb, vec3(\n        (uv01.x - .5) * self.sensor_width,\n        self.focal_length,\n        (uv01.y - .5) * self.sensor_height\n    ));\n    r.dir = normalize(r.orig - self.pos);\n    return r;\n}\n\n// Camera: retrieve UV coordinates from a point in space\n// * returns vec2(-1e9) on failure\nvec2 Camera_retrieve_uv01_from_point(in Camera self, vec3 p)\n{\n    // project into camera space\n    vec3 world_space = p - self.pos;\n    vec3 cam_space = OrthonormalBasis_localize(self._onb, world_space);\n\n    // p is not in front of the sensor\n    if (cam_space.y < self.focal_length - .00001)\n    {\n        return vec2(-1e9);\n    }\n\n    // linearly normalize p so that it falls on the focal plane\n    cam_space /= cam_space.y;\n    cam_space *= self.focal_length;\n\n    // extract the UV coordinates\n    return (cam_space.xz / vec2(self.sensor_width, self.sensor_height)) + .5;\n}\n\n// Camera: retrieve UV coordinates from a direction towards the sky (used when\n// no object is hit)\n// * returns vec2(-1e9) on failure\nvec2 Camera_retrieve_uv01_from_dir(in Camera self, vec3 dir)\n{\n    // project into camera space\n    vec3 p = dir;\n    vec3 cam_space = OrthonormalBasis_localize(self._onb, p);\n\n    // p is not in front of the sensor\n    if (cam_space.y < .00001)\n    {\n        return vec2(-1e9);\n    }\n\n    // linearly normalize p so that it falls on the focal plane\n    cam_space /= cam_space.y;\n    cam_space *= self.focal_length;\n\n    // extract the UV coordinates\n    return (cam_space.xz / vec2(self.sensor_width, self.sensor_height)) + .5;\n}\n\n// Camera: generate a defocused camera ray for given UV coordinates\nRay Camera_gen_ray_defocused(\n    in Camera self,\n    vec2 uv01,\n    float focus_dist,\n    float jitter\n)\n{\n    // generate normal ray without normalizing the direction\n    Ray r;\n    vec3 r_dir_unnormalized = OrthonormalBasis_delocalize(self._onb, vec3(\n        (uv01.x - .5) * self.sensor_width,\n        self.focal_length,\n        (uv01.y - .5) * self.sensor_height\n    ));\n    r.orig = self.pos + r_dir_unnormalized;\n    \n    // point on the focus plane\n    vec3 fp = r.orig + focus_dist * (r_dir_unnormalized / self.focal_length);\n    \n    // randomly offset the ray origin\n    vec2 offs = jitter * random_in_circle();\n    r.orig += OrthonormalBasis_delocalize(self._onb, vec3(\n        offs.x,\n        0.,\n        offs.y\n    ));\n    \n    // look at the point on the focus plane\n    r.dir = normalize(fp - r.orig);\n    \n    return r;\n}\n\nstruct Hit\n{\n    Ray r; // ray that produced this hit\n    bool hit; // did we hit something?\n    vec3 p; // hit position\n    float t; // hit distance\n    vec3 n; // normal\n    vec2 uv;\n};\n\n// front face is counterclockwise\nstruct Triangle\n{\n    vec3 v0;\n    vec3 v1;\n    vec3 v2;\n};\n\n// front face is counterclockwise\nstruct Quad\n{\n    vec3 orig;\n    vec3 u;\n    vec3 v;\n};\n\nvec3 triangle_normal(in Triangle tri)\n{\n    return normalize(cross(tri.v1 - tri.v0, tri.v2 - tri.v0));\n}\n\nvec3 quad_normal(in Quad q)\n{\n    return normalize(cross(q.u, q.v));\n}\n\n// https://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm\nvoid ray_triangle(\n    in Triangle tri,\n    in Ray r,\n    out Hit h\n)\n{\n    h.r = r;\n    h.hit = false;\n\n    const float eps = .0001;\n\n    vec3 edge1 = tri.v1 - tri.v0;\n    vec3 edge2 = tri.v2 - tri.v0;\n    vec3 ray_cross_e2 = cross(r.dir, edge2);\n    float det = dot(edge1, ray_cross_e2);\n\n    if (abs(det) < eps)\n    {\n        // ray is parallel to the triangle\n        return;\n    }\n\n    float inv_det = 1. / det;\n    vec3 s = r.orig - tri.v0;\n    float u = inv_det * dot(s, ray_cross_e2);\n\n    if (u < 0. || u > 1.)\n    {\n        return;\n    }\n\n    vec3 s_cross_e1 = cross(s, edge1);\n    float v = inv_det * dot(r.dir, s_cross_e1);\n\n    if (v < 0. || u + v > 1.)\n    {\n        return;\n    }\n\n    // at this stage we can compute t to find out where the intersection point\n    // is on the line\n    h.t = inv_det * dot(edge2, s_cross_e1);\n\n    // this means that there is a line intersection but not a ray intersection\n    if (h.t < 0.)\n    {\n        return;\n    }\n    \n    h.hit = true;\n    h.p = r.orig + (h.t * r.dir);\n    h.n = normalize(cross(edge1, edge2));\n    h.uv = vec2(u, v);\n}\n\nvoid ray_quad(\n    in Quad q,\n    in Ray r,\n    out Hit h\n)\n{\n    Triangle tri;\n    tri.v0 = q.orig;\n    tri.v1 = q.orig + q.u;\n    tri.v2 = q.orig + q.u + q.v;\n    ray_triangle(tri, r, h);\n    if (h.hit)\n    {\n        h.uv = vec2(h.uv.x + h.uv.y, h.uv.y);\n        return;\n    }\n\n    tri.v0 = q.orig;\n    tri.v1 = q.orig + q.u + q.v;\n    tri.v2 = q.orig + q.v;\n    ray_triangle(tri, r, h);\n    if (h.hit)\n    {\n        h.uv = vec2(h.uv.x, h.uv.x + h.uv.y);\n    }\n}\n\nvoid trace_ray(\n    in Ray r,\n    float time,\n    inout Hit h,\n    in sampler2D tex\n)\n{\n    Quad q;\n    q.orig = vec3(-1, -1, 0);\n    q.u = vec3(2, 0, 0);\n    q.v = vec3(0, 2, 0);\n    \n    ray_quad(q, r, h);\n    \n    if (!h.hit)\n    {\n        return;\n    }\n    \n    // parallax occlusion mapping\n    \n    float cos_view_angle = abs(dot(h.n, r.dir));\n    \n    float n_layers = mix(\n        POM_MAX_LAYERS,\n        POM_MIN_LAYERS,\n        cos_view_angle\n    );\n    float layer_depth = 1. / n_layers;\n    float curr_layer_depth = 0.;\n    \n    vec3 step_ray = -r.dir * POM_MAX_HEIGHT * layer_depth;\n    vec2 delta_uv = vec2(\n        dot(step_ray, q.u) / length_sq(q.u),\n        dot(step_ray, q.v) / length_sq(q.v)\n    ) / dot(h.n, r.dir);\n\n    vec2 uv = h.uv;\n    float curr_depth = 1. - pom_heightmap01(uv, tex);\n    \n    // loop until we're below the surface\n    // * don't loop if we're looking direcly from above\n    if (cos_view_angle < .9999)\n    {\n        while (curr_layer_depth < curr_depth)\n        {\n            curr_layer_depth += layer_depth;\n            uv += delta_uv;\n            curr_depth = 1. - pom_heightmap01(uv, tex);\n            \n            h.t += POM_MAX_HEIGHT / n_layers;\n        }\n    }\n    \n    // update hit position\n    h.p = r.orig + h.t * r.dir;\n    \n    // apply occlusion (blend with the previous value)\n    vec2 prev_uv = uv - delta_uv;\n    float after_depth = curr_depth - curr_layer_depth;\n    float before_depth =\n        (1. - pom_heightmap01(prev_uv, tex))\n        - (curr_layer_depth - layer_depth);\n    float mix_fac = after_depth / (after_depth - before_depth);\n    uv = mix(uv, prev_uv, mix_fac);\n    \n    // if UV is out of range, then we haven't hit the surface\n    if (POM_CUT_EDGES && max(abs(uv.x - .5), abs(uv.y - .5)) > .5)\n    {\n        h.hit = false;\n        return;\n    }\n    \n    // otherwise, we update the hit info\n    h.uv = uv;\n    \n    // and calculate the normal\n    float height = pom_heightmap01(uv, tex);\n    vec2 gradient = POM_MAX_HEIGHT * (\n        vec2(\n            pom_heightmap01(uv + vec2(POM_EPS_NORMAL, 0), tex),\n            pom_heightmap01(uv + vec2(0, POM_EPS_NORMAL), tex)\n        ) - height\n    ) / POM_EPS_NORMAL;\n    h.n = normalize(\n        -gradient.x * normalize(q.u)\n        + -gradient.y * normalize(q.v)\n        + h.n\n    );\n}\n\n\n\n/*-----------------------------------------------\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  Linear BT.709 I-D65 / sRGB 2.2 (depends on arguments)\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n-----------------------------------------------*/\n\n// parameters\n\nconst float flim_pre_exposure = 4.3;\nconst vec3 flim_pre_formation_filter = vec3(1.);\nconst float flim_pre_formation_filter_strength = 0.;\n\nconst float flim_extended_gamut_red_scale = 1.05;\nconst float flim_extended_gamut_green_scale = 1.12;\nconst float flim_extended_gamut_blue_scale = 1.045;\nconst float flim_extended_gamut_red_rot = .5;\nconst float flim_extended_gamut_green_rot = 2.;\nconst float flim_extended_gamut_blue_rot = .1;\nconst float flim_extended_gamut_red_mul = 1.;\nconst float flim_extended_gamut_green_mul = 1.;\nconst float flim_extended_gamut_blue_mul = 1.;\n\nconst float flim_sigmoid_log2_min = -10.;\nconst float flim_sigmoid_log2_max = 22.;\nconst float flim_sigmoid_toe_x = .44;\nconst float flim_sigmoid_toe_y = .28;\nconst float flim_sigmoid_shoulder_x = .591;\nconst float flim_sigmoid_shoulder_y = .779;\n\nconst float flim_negative_film_exposure = 6.;\nconst float flim_negative_film_density = 5.;\n\nconst vec3 flim_print_backlight = vec3(1);\nconst float flim_print_film_exposure = 6.;\nconst float flim_print_film_density = 27.5;\n\nconst float flim_black_point = -1.; // -1 = auto\nconst vec3 flim_post_formation_filter = vec3(1);\nconst float flim_post_formation_filter_strength = 0.;\nconst float flim_midtone_saturation = 1.02;\n\n// color space conversions\n// the matrices below represent data in row-major, but GLSL matrices are in\n// column-major, so we need to multiply a vec3 by a matrix rather than\n// multiplying a matrix by a vec3.\n\nconst mat3 mat_bt2020_to_xyz = mat3(\n     0.6369580483,  0.1446169036,  0.1688809752,\n     0.2627002120,  0.6779980715,  0.0593017165,\n     0.0000000000,  0.0280726930,  1.0609850577\n);\n\nconst mat3 mat_xyz_to_bt2020 = mat3(\n     1.7166511880, -0.3556707838, -0.2533662814,\n    -0.6666843518,  1.6164812366,  0.0157685458,\n     0.0176398574, -0.0427706133,  0.9421031212\n);\n\nconst mat3 mat_bt709_to_xyz = mat3(\n     0.4123907993,  0.3575843394,  0.1804807884,\n     0.2126390059,  0.7151686788,  0.0721923154,\n     0.0193308187,  0.1191947798,  0.9505321522\n);\n\nconst mat3 mat_xyz_to_bt709 = mat3(\n     3.2409699419, -1.5373831776, -0.4986107603,\n    -0.9692436363,  1.8759675015,  0.0415550574,\n     0.0556300797, -0.2039769589,  1.0569715142\n);\n\nconst mat3 mat_dcip3_to_xyz = mat3(\n     0.4451698156,  0.2771344092,  0.1722826698,\n     0.2094916779,  0.7215952542,  0.0689130679,\n     0.0000000000,  0.0470605601,  0.9073553944\n);\n\nconst mat3 mat_xyz_to_dcip3 = mat3(\n     2.7253940305, -1.0180030062, -0.4401631952,\n    -0.7951680258,  1.6897320548,  0.0226471906,\n     0.0412418914, -0.0876390192,  1.1009293786\n);\n\nvec3 oetf_pow(vec3 col, float power)\n{\n    return pow(col, vec3(1. / power));\n}\n\nvec3 eotf_pow(vec3 col, float power)\n{\n    return pow(col, vec3(power));\n}\n\n// flim's utility functions\n\nfloat flim_wrap(float v, float start, float end)\n{\n    return start + mod(v - start, end - start);\n}\n\nfloat flim_remap(\n    float v,\n    float inp_start,\n    float inp_end,\n    float out_start,\n    float out_end\n)\n{\n    return out_start\n        + ((out_end - out_start) / (inp_end - inp_start)) * (v - inp_start);\n}\n\nfloat flim_remap_clamp(\n    float v,\n    float inp_start,\n    float inp_end,\n    float out_start,\n    float out_end\n)\n{\n    float t = clamp((v - inp_start) / (inp_end - inp_start), 0., 1.);\n    return out_start + t * (out_end - out_start);\n}\n\nfloat flim_remap01(\n    float v,\n    float inp_start,\n    float inp_end\n)\n{\n    return clamp((v - inp_start) / (inp_end - inp_start), 0., 1.);\n}\n\nvec3 flim_blender_rgb_to_hsv(vec3 rgb)\n{\n    float cmax, cmin, h, s, v, cdelta;\n    vec3 c;\n\n    cmax = max(rgb[0], max(rgb[1], rgb[2]));\n    cmin = min(rgb[0], min(rgb[1], rgb[2]));\n    cdelta = cmax - cmin;\n\n    v = cmax;\n    if (cmax != 0.)\n    {\n        s = cdelta / cmax;\n    }\n    else\n    {\n        s = 0.;\n        h = 0.;\n    }\n\n    if (s == 0.)\n    {\n        h = 0.;\n    }\n    else\n    {\n        c = (vec3(cmax) - rgb.xyz) / cdelta;\n\n        if (rgb.x == cmax)\n        {\n            h = c[2] - c[1];\n        }\n        else if (rgb.y == cmax)\n        {\n            h = 2. + c[0] - c[2];\n        }\n        else\n        {\n            h = 4. + c[1] - c[0];\n        }\n\n        h /= 6.;\n\n        if (h < 0.)\n        {\n            h += 1.;\n        }\n    }\n\n    return vec3(h, s, v);\n}\n\nvec3 flim_blender_hsv_to_rgb(vec3 hsv)\n{\n    float f, p, q, t, h, s, v;\n    vec3 rgb;\n\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n\n    if (s == 0.)\n    {\n        rgb = vec3(v, v, v);\n    }\n    else\n    {\n        if (h == 1.)\n        {\n            h = 0.;\n        }\n\n        h *= 6.;\n        int i = int(floor(h));\n        f = h - float(i);\n        rgb = vec3(f, f, f);\n        p = v * (1. - s);\n        q = v * (1. - (s * f));\n        t = v * (1. - (s * (1. - f)));\n\n        if (i == 0)\n        {\n            rgb = vec3(v, t, p);\n        }\n        else if (i == 1)\n        {\n            rgb = vec3(q, v, p);\n        }\n        else if (i == 2)\n        {\n            rgb = vec3(p, v, t);\n        }\n        else if (i == 3)\n        {\n            rgb = vec3(p, q, v);\n        }\n        else if (i == 4)\n        {\n            rgb = vec3(t, p, v);\n        }\n        else\n        {\n            rgb = vec3(v, p, q);\n        }\n    }\n\n    return rgb;\n}\n\nvec3 flim_blender_hue_sat(vec3 col, float hue, float sat, float value)\n{\n    vec3 hsv = flim_blender_rgb_to_hsv(col);\n\n    hsv[0] = fract(hsv[0] + hue + .5);\n    hsv[1] = clamp(hsv[1] * sat, 0., 1.);\n    hsv[2] = hsv[2] * value;\n\n    return flim_blender_hsv_to_rgb(hsv);\n}\n\nfloat flim_rgb_avg(vec3 col)\n{\n    return (col.x + col.y + col.z) / 3.;\n}\n\nfloat flim_rgb_sum(vec3 col)\n{\n    return col.x + col.y + col.z;\n}\n\nfloat flim_rgb_max(vec3 col)\n{\n    return max(max(col.x, col.y), col.z);\n}\n\nfloat flim_rgb_min(vec3 col)\n{\n    return min(min(col.x, col.y), col.z);\n}\n\nvec3 flim_rgb_uniform_offset(vec3 col, float black_point, float white_point)\n{\n    float mono = flim_rgb_avg(col);\n    float mono2 = flim_remap01(\n        mono, black_point / 1000.,\n        1. - (white_point / 1000.)\n    );\n    return col * (mono2 / mono);\n}\n\nvec3 flim_rgb_sweep(float hue)\n{\n    hue = flim_wrap(hue * 360., 0., 360.);\n\n    vec3 col = vec3(1, 0, 0);\n    col = mix(col, vec3(1, 1, 0), flim_remap01(hue, 0., 60.));\n    col = mix(col, vec3(0, 1, 0), flim_remap01(hue, 60., 120.));\n    col = mix(col, vec3(0, 1, 1), flim_remap01(hue, 120., 180.));\n    col = mix(col, vec3(0, 0, 1), flim_remap01(hue, 180., 240.));\n    col = mix(col, vec3(1, 0, 1), flim_remap01(hue, 240., 300.));\n    col = mix(col, vec3(1, 0, 0), flim_remap01(hue, 300., 360.));\n    \n    return col;\n}\n\nvec3 flim_rgb_exposure_sweep_test(vec2 uv0to1)\n{\n    float hue = 1. - uv0to1.y;\n    float exposure = flim_remap(uv0to1.x, 0., 1., -5., 10.);\n    return flim_rgb_sweep(hue) * pow(2., exposure);\n}\n\n// https://www.desmos.com/calculator/khkztixyeu\nfloat flim_super_sigmoid(\n    float v,\n    float toe_x,\n    float toe_y,\n    float shoulder_x,\n    float shoulder_y\n)\n{\n    // clip\n    v = clamp(v, 0., 1.);\n    toe_x = clamp(toe_x, 0., 1.);\n    toe_y = clamp(toe_y, 0., 1.);\n    shoulder_x = clamp(shoulder_x, 0., 1.);\n    shoulder_y = clamp(shoulder_y, 0., 1.);\n\n    // calculate straight line slope\n    float slope = (shoulder_y - toe_y) / (shoulder_x - toe_x);\n\n    // toe\n    if (v < toe_x)\n    {\n        float toe_pow = slope * toe_x / toe_y;\n        return toe_y * pow(v / toe_x, toe_pow);\n    }\n\n    // straight line\n    if (v < shoulder_x)\n    {\n        float intercept = toe_y - (slope * toe_x);\n        return slope * v + intercept;\n    }\n\n    // shoulder\n    float shoulder_pow =\n        -slope / (\n            ((shoulder_x - 1.) / pow(1. - shoulder_x, 2.))\n            * (1. - shoulder_y)\n        );\n    return\n        (1. - pow(1. - (v - shoulder_x) / (1. - shoulder_x), shoulder_pow))\n        * (1. - shoulder_y)\n        + shoulder_y;\n}\n\nfloat flim_dye_mix_factor(float mono, float max_density)\n{\n    // log2 and map range\n    float offset = pow(2., flim_sigmoid_log2_min);\n    float fac = flim_remap01(\n        log2(mono + offset),\n        flim_sigmoid_log2_min,\n        flim_sigmoid_log2_max\n    );\n\n    // calculate amount of exposure from 0 to 1\n    fac = flim_super_sigmoid(\n        fac,\n        flim_sigmoid_toe_x,\n        flim_sigmoid_toe_y,\n        flim_sigmoid_shoulder_x,\n        flim_sigmoid_shoulder_y\n    );\n\n    // calculate dye density\n    fac *= max_density;\n\n    // mix factor\n    fac = pow(2., -fac);\n\n    // clip and return\n    return clamp(fac, 0., 1.);\n}\n\nvec3 flim_rgb_color_layer(\n    vec3 col,\n    vec3 sensitivity_tone,\n    vec3 dye_tone,\n    float max_density\n)\n{\n    // normalize\n    vec3 sensitivity_tone_norm =\n        sensitivity_tone / flim_rgb_sum(sensitivity_tone);\n    vec3 dye_tone_norm = dye_tone / flim_rgb_max(dye_tone);\n\n    // dye mix factor\n    float mono = dot(col, sensitivity_tone_norm);\n    float mix_fac = flim_dye_mix_factor(mono, max_density);\n\n    // dye mixing\n    return mix(dye_tone_norm, vec3(1), mix_fac);\n}\n\nvec3 flim_rgb_develop(vec3 col, float exposure, float max_density)\n{\n    // exposure\n    col *= pow(2., exposure);\n\n    // blue-sensitive layer\n    vec3 result = flim_rgb_color_layer(\n        col,\n        vec3(0, 0, 1),\n        vec3(1, 1, 0),\n        max_density\n    );\n\n    // green-sensitive layer\n    result *= flim_rgb_color_layer(\n        col,\n        vec3(0, 1, 0),\n        vec3(1, 0, 1),\n        max_density\n    );\n\n    // red-sensitive layer\n    result *= flim_rgb_color_layer(\n        col,\n        vec3(1, 0, 0),\n        vec3(0, 1, 1),\n        max_density\n    );\n\n    return result;\n}\n\nvec3 flim_gamut_extension_mat_row(\n    float primary_hue,\n    float scale,\n    float rotate,\n    float mul\n)\n{\n    vec3 result = flim_blender_hsv_to_rgb(vec3(\n        flim_wrap(primary_hue + (rotate / 360.), 0., 1.),\n        1. / scale,\n        1.\n    ));\n    result /= flim_rgb_sum(result);\n    result *= mul;\n    return result;\n}\n\nmat3 flim_gamut_extension_mat(\n    float red_scale,\n    float green_scale,\n    float blue_scale,\n    float red_rot,\n    float green_rot,\n    float blue_rot,\n    float red_mul,\n    float green_mul,\n    float blue_mul\n)\n{\n    mat3 m;\n    m[0] = flim_gamut_extension_mat_row(\n        0.,\n        red_scale,\n        red_rot,\n        red_mul\n    );\n    m[1] = flim_gamut_extension_mat_row(\n        1. / 3.,\n        green_scale,\n        green_rot,\n        green_mul\n    );\n    m[2] = flim_gamut_extension_mat_row(\n        2. / 3.,\n        blue_scale,\n        blue_rot,\n        blue_mul\n    );\n    return m;\n}\n\nvec3 negative_and_print(vec3 col, vec3 backlight_ext)\n{\n    // develop negative\n    col = flim_rgb_develop(\n        col,\n        flim_negative_film_exposure,\n        flim_negative_film_density\n    );\n\n    // backlight\n    col *= backlight_ext;\n\n    // develop print\n    col = flim_rgb_develop(\n        col,\n        flim_print_film_exposure,\n        flim_print_film_density\n    );\n\n    return col;\n}\n\n// the flim transform\n\nvec3 flim_transform(vec3 col, float exposure, bool convert_to_srgb)\n{\n    // eliminate negative values\n    col = max(col, 0.);\n\n    // pre-Exposure\n    col *= pow(2., flim_pre_exposure + exposure);\n\n    // clip very large values for float precision issues\n    col = min(col, 5000.);\n\n    // gamut extension matrix (Linear BT.709)\n    mat3 extend_mat = flim_gamut_extension_mat(\n        flim_extended_gamut_red_scale,\n        flim_extended_gamut_green_scale,\n        flim_extended_gamut_blue_scale,\n        flim_extended_gamut_red_rot,\n        flim_extended_gamut_green_rot,\n        flim_extended_gamut_blue_rot,\n        flim_extended_gamut_red_mul,\n        flim_extended_gamut_green_mul,\n        flim_extended_gamut_blue_mul\n    );\n    mat3 extend_mat_inv = inverse(extend_mat);\n\n    // backlight in the extended gamut\n    vec3 backlight_ext = flim_print_backlight * extend_mat;\n\n    // upper limit in the print (highlight cap)\n    const float big = 10000000.;\n    vec3 white_cap = negative_and_print(vec3(big, big, big), backlight_ext);\n\n    // pre-formation filter\n    col = mix(\n        col,\n        col * flim_pre_formation_filter,\n        flim_pre_formation_filter_strength\n    );\n\n    // convert to the extended gamut\n    col *= extend_mat;\n\n    // negative & print\n    col = negative_and_print(col, backlight_ext);\n\n    // convert from the extended gamut\n    col *= extend_mat_inv;\n\n    // eliminate negative values\n    col = max(col, 0.);\n\n    // white cap\n    col /= white_cap;\n\n    // black cap (-1 = auto)\n    if (flim_black_point == -1.)\n    {\n        vec3 black_cap = negative_and_print(vec3(0.), backlight_ext);\n        black_cap /= white_cap;\n        col = flim_rgb_uniform_offset(\n            col,\n            flim_rgb_avg(black_cap) * 1000.,\n            0.\n        );\n    }\n    else\n    {\n        col = flim_rgb_uniform_offset(col, flim_black_point, 0.);\n    }\n\n    // post-formation filter\n    col = mix(\n        col,\n        col * flim_post_formation_filter,\n        flim_post_formation_filter_strength\n    );\n\n    // clip\n    col = clamp(col, 0., 1.);\n\n    // midtone saturation\n    float mono = flim_rgb_avg(col);\n    float mix_fac =\n        (mono < .5)\n        ? flim_remap01(mono, .05, .5)\n        : flim_remap01(mono, .95, .5);\n    col = mix(\n        col,\n        flim_blender_hue_sat(col, .5, flim_midtone_saturation, 1.),\n        mix_fac\n    );\n\n    // clip\n    col = clamp(col, 0., 1.);\n\n    // OETF\n    if (convert_to_srgb)\n    {\n        col = oetf_pow(col, 2.2);\n    }\n\n    return col;\n}\n\n/*____________________ end ____________________*/\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}