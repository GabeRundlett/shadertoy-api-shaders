{
    "Shader": {
        "info": {
            "date": "1577354288",
            "description": "raymatching test",
            "flags": 0,
            "hasliked": 0,
            "id": "wtd3zs",
            "likes": 1,
            "name": "Ray-Matching: ray-direction Test",
            "published": 3,
            "tags": [
                "raymatching"
            ],
            "usePreview": 0,
            "username": "changjiu",
            "viewed": 353
        },
        "renderpass": [
            {
                "code": "\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nvec3 rayDir;\n \nvec3 cameraPosition = vec3(0.0, 0.0, 5.0);\nvec3 cameraDir = vec3(0.0, 0.0, -1.0);\nvec3 cameraUp = vec3(0.0, 1.0, 0.0);\n\nmat4 getPerspectiveProjectMatrix(float fovy, float aspect, float near, float far){\n    mat4 projectMatrix;\n    \n\tfloat rd, s, ct;\n\n\n  \tfovy = 3.1415926 * fovy / 180.0 / 2.0;\n  \ts = sin(fovy);\n\n\n  \trd = 1.0 / (far - near);\n  \tct = cos(fovy) / s;\n\n\n      projectMatrix[0][0]  = ct / aspect;\n      projectMatrix[0][1]  = 0.0;\n      projectMatrix[0][2]  = 0.0;\n      projectMatrix[0][3]  = 0.0;\n\n      projectMatrix[1][0]  = 0.0;\n      projectMatrix[1][1]  = ct;\n      projectMatrix[1][2]  = 0.0;\n      projectMatrix[1][3]  = 0.0;\n\n      projectMatrix[2][0]  = 0.0;\n      projectMatrix[2][1]  = 0.0;\n      projectMatrix[2][2]  = -(far + near) * rd;\n      projectMatrix[2][3]  = -1.0;\n\n      projectMatrix[3][0]  = 0.0;\n      projectMatrix[3][1]  = 0.0;\n      projectMatrix[3][2]  = -2.0 * near * far * rd;\n      projectMatrix[3][3]  = 0.0;\n\n      return projectMatrix;\n\n}\n\nmat4 matTranslate(mat4 e, float x, float y, float z) {\n    \n  e[3][0] += e[0][0] * x + e[1][0] * y + e[2][0] * z;\n  e[3][1] += e[0][1] * x + e[1][1] * y + e[2][1] * z;\n  e[3][2] += e[0][2] * x + e[1][2] * y + e[2][2] * z;\n  e[3][3] += e[0][3] * x + e[1][3] * y + e[2][3] * z;\n    \n  return e;\n}\n\nmat4 getViewMatrix(float eyeX, float eyeY, float eyeZ, float centerX, float centerY, float centerZ, float upX, float upY, float upZ){\n    mat4 viewMatrix;\n    \n\tfloat fx, fy, fz, rlf, sx, sy, sz, rls, ux, uy, uz;\n\n\n  \t  fx = centerX - eyeX;\n      fy = centerY - eyeY;\n      fz = centerZ - eyeZ;\n\n      // Normalize f.\n      rlf = 1.0 / sqrt(fx*fx + fy*fy + fz*fz);\n      fx *= rlf;\n      fy *= rlf;\n      fz *= rlf;\n\n      // Calculate cross product of f and up.\n      sx = fy * upZ - fz * upY;\n      sy = fz * upX - fx * upZ;\n      sz = fx * upY - fy * upX;\n\n      // Normalize s.\n      rls = 1.0 / sqrt(sx*sx + sy*sy + sz*sz);\n      sx *= rls;\n      sy *= rls;\n      sz *= rls;\n\n      // Calculate cross product of s and f.\n      ux = sy * fz - sz * fy;\n      uy = sz * fx - sx * fz;\n      uz = sx * fy - sy * fx;\n\n\n      viewMatrix[0][0]  = sx;\n      viewMatrix[0][1]  = ux;\n      viewMatrix[0][2]  = -fx;\n      viewMatrix[0][3]  = 0.0;\n\n      viewMatrix[1][0]  = sy;\n      viewMatrix[1][1]  = uy;\n      viewMatrix[1][2]  = -fy;\n      viewMatrix[1][3]  = 0.0;\n\n      viewMatrix[2][0]  = sz;\n      viewMatrix[2][1]  = uz;\n      viewMatrix[2][2]  = -fz;\n      viewMatrix[2][3]  = 0.0;\n\n      viewMatrix[3][0]  = 0.0;\n      viewMatrix[3][1]  = 0.0;\n      viewMatrix[3][2]  = 0.0;\n      viewMatrix[3][3]  = 1.0;\n    \n      viewMatrix = matTranslate(viewMatrix, -eyeX, -eyeY, -eyeZ);\n\n      return viewMatrix;\n\n}\n\n\nmat4 arrayToM4(float e[16]){\n    mat4 m4;\n    \n    m4[0][0]=e[0] ;\nm4[0][1]=e[1] ;\nm4[0][2]=e[2] ;\nm4[0][3]=e[3] ;\nm4[1][0]=e[4] ;\nm4[1][1]=e[5] ;\nm4[1][2]=e[6] ;\nm4[1][3]=e[7] ;\nm4[2][0]=e[8] ;\nm4[2][1]=e[9] ;\n m4[2][2]=e[10];\n m4[2][3]=e[11];\n m4[3][0]=e[12];\n m4[3][1]=e[13];\n m4[3][2]=e[14];\n m4[3][3]=e[15];\n    \n\treturn m4;\n}\n\nvec3 getCameraPosition(){\n\tvec3 cameraPosition;\n    cameraPosition.x = sin(iTime)*10.0;\n    cameraPosition.y = sin(iTime+0.5)*5.+5.;\n    cameraPosition.z = cos(iTime)*10.0;\n\treturn cameraPosition;\n}\n\nvec3 unproject(vec3 pointScreen){\n    \n    cameraPosition = getCameraPosition();\n\n    mat4 viewMatrix = getViewMatrix(cameraPosition.x, cameraPosition.y, cameraPosition.z, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);\n\n    mat4 projectMatrix  = getPerspectiveProjectMatrix(45.0, iResolution.x/iResolution.y, 1.0, 100.0);\n    \n    mat4 vpMatrix = projectMatrix * viewMatrix;\n    \n    mat4 VPmatrixInverse = inverse(vpMatrix);\n    \n\tvec4 pointV4 = VPmatrixInverse*vec4(pointScreen,1);\n\n    return pointV4.xyz/pointV4.w;\n}\n\nvec3 getPointV3ByFragCoord(vec2 coord){\n    \n    vec3 pointScreen = vec3(coord.x, coord.y, 0.5);\n\tvec3 pointV3 = unproject(pointScreen);\n\n    return pointV3;\n}\n\nvec3 getRayDirByCoord(vec2 coord){\n\tvec3 pointV3 = getPointV3ByFragCoord(coord);\n    vec3 ray = pointV3 - cameraPosition;\n    return normalize(ray);\n}\n\nfloat sphereSDF(vec3 samplePoint) {\n    vec3 position = vec3(2,0,2);\n    vec3 position2 = samplePoint - position;\n    return length(position2) - 1.0;\n}\n\nfloat cubeSDF(vec3 p) {\n    vec3 position = vec3(-2,0,-2);\n    vec3 position2 = p - position;\n    \n    vec3 d = abs(position2) - vec3(1.0, 1.0, 1.0);\n\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\nfloat planeSDF(vec3 p) {\n    vec3 position = vec3(0,-2,0);\n    vec3 position2 = p - position;\n    \n    vec3 d = abs(position2) - vec3(5.0, 0.1, 5.0);\n\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\nfloat sceneSDF(vec3 samplePoint) {\n    float minDis1 = cubeSDF(samplePoint);\n    float minDis2 = sphereSDF(samplePoint);\n    float minDis3 = planeSDF(samplePoint);\n    return min(min(minDis1, minDis2),minDis3);\n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n            \nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(10.0,5.0,3.0);\n    vec3 light1Intensity = vec3(1., 1., 1.);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 cood = vec2(( fragCoord.x / iResolution.x ) * 2. - 1., ( fragCoord.y / iResolution.y ) * 2. - 1.);\n    rayDir = getRayDirByCoord(cood);\n    \n    float dist = shortestDistanceToSurface(cameraPosition, rayDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        fragColor = vec4(0.1, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    vec3 p = cameraPosition + dist * rayDir;\n    \n    vec3 K_a = vec3(0.1, 0.1, 0.1);\n    vec3 K_d = vec3(0.3, 0.3, 0.3);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 1.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, cameraPosition);\n    \n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}