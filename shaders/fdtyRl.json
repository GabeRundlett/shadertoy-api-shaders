{
    "Shader": {
        "info": {
            "date": "1653925532",
            "description": "WORK IN PROGRESS -- An simple animation to accompany a music track I made.",
            "flags": 0,
            "hasliked": 0,
            "id": "fdtyRl",
            "likes": 2,
            "name": "BLOSSOMS TO BLOOM Animation",
            "published": 3,
            "tags": [
                "sunset",
                "animation"
            ],
            "usePreview": 0,
            "username": "NEAR_DREAM_UNITY",
            "viewed": 237
        },
        "renderpass": [
            {
                "code": "/* Logo:\n\n                NEAR DREAM UNITY\n\n          fascination and joy, with you\n*/\n\n\n#define  AASS           3.//was 5\n#define  NOISE_FADE     0.25\n#define  PULSE          cos(iTime * 0.5)\n#define  NDULOGO_FADE   (0.02 * (1. - PULSE))\n#define  NDULOGO_ZOOM   (0.7 - 0.2 * PULSE)\n#define  SCENE_ZOOM     (0.9 + 0.1 * PULSE)\n\n#define  SSET_UPWARD    0.3\n#define  SSET_HEIGHT    0.1\n#define  SSET_C_SKY     (vec3(0.38, 0.30, 0.48) * 0.8)\n#define  SSET_C_CYAN    vec3(0., 0.7, 0.7)\n#define  SSET_CYAN_R    1.8\n#define  SSET_CYAN_Q    1.6\n#define  SSET_C_RED     vec3(2., -0.35, -0.5)\n#define  SSET_RED_R     0.85\n#define  SSET_RED_Q     1.8\n#define  SSET_C_GOLD    vec3(0., 0.35, 0.1)\n#define  SSET_GOLD_R    0.45\n#define  SSET_GOLD_Q    1.2\n#define  SSET_C_SUN     1.5\n#define  SSET_SUN_R     0.15\n#define  SSET_SUN_Q     2.8\n#define  SSET_YDARK     0.15\n\n#define  SSET_C_GROUND  vec3(0.2, 0.3, 0.2)\n\n#define  SSET_C_BDNG    vec3(0.8, 0.6, 0.4)\n#define  SSET_C_WINDOW  vec3(0., 0.8, 0.6)\n\n\n\nvec4  Building  (vec2 p, vec2 corner1, vec2 corner2, ivec2 windows) {\n    vec2 bp = (p - corner1) / (corner2 - corner1);\n    if (bp.x >= 0. && bp.y >= 0. && bp.x <= 1. && bp.y <= 1.) {\n        ivec2 wslots = windows * 2 + ivec2(1, 2);\n        ivec2 wloc = ivec2(floor(bp * vec2(wslots)));\n        vec3 c = ((wloc.x & 1) == 1 && (wloc.y & 1) == 0 && wloc.y != 0) ? SSET_C_WINDOW : SSET_C_BDNG;\n        return vec4(c, 1.);\n    } else return vec4(0.);\n}\n\n\nvec3  Sky  (vec2 sun_p) {\n    float d = length(sun_p);\n    // Add on radial gradients from the outside in:\n    vec3 c = SSET_C_SKY;  // Ambient sky colour.\n    #define ADDRADGRAD(C, R, Q) \\\n        c += C * pow(1. - min(1., d * (1. / R)), Q)\n    ADDRADGRAD(SSET_C_CYAN,  SSET_CYAN_R,  SSET_CYAN_Q);\n    ADDRADGRAD(SSET_C_RED,   SSET_RED_R,   SSET_RED_Q);\n    ADDRADGRAD(SSET_C_GOLD,  SSET_GOLD_R,  SSET_GOLD_Q);\n    ADDRADGRAD(SSET_C_SUN,   SSET_SUN_R,   SSET_SUN_Q);\n    c -= sun_p.y * SSET_YDARK;\n    return c;\n}\n\n\nvec3  Ground  (vec2 sun_p) {\n    return SSET_C_GROUND\n        + 0.1\n        - pow(-sun_p.y, 1.5) * 0.4\n        - dot(sun_p, sun_p) * 0.05;\n}\n\n\nvec3  SunsetScene  (vec2 p) {\n    p.y += SSET_UPWARD;  // Shift view upwards.\n    vec2 sun_p = p - vec2(0., SSET_HEIGHT);\n    vec3 c = (p.y > 0.) ? Sky(sun_p) : Ground(sun_p);\n    \n    #define BUILD(N, X1, X2, Y1, Y2, WX, WY) \\\n        vec4 bN_c = Building(p, vec2(X1, Y1), vec2(X2, Y2), ivec2(WX, WY)); \\\n        if (bN_c.w != 0.) c = bN_c.xyz\n    //BUILD(1, -1.2, -0.4, -0.1, 0.2, 3, 3);\n    \n    return c;\n}\n\n\nbool  OneSquare  (vec2 moved, float size) {\n    float hlt = 17. / 32.;\n    return (\n        moved.x >= -hlt           &&\n        moved.y >= -hlt           &&\n        moved.x <= size + hlt     &&\n        moved.y <= size + hlt     && (\n            moved.x < hlt         ||\n            moved.y < hlt         ||\n            moved.x > size - hlt  ||\n            moved.y > size - hlt  ));\n}\n\n\nbool  NDULogo  (vec2 p) {\n    vec2 zoom = p * 17.;\n    vec2 tilt = vec2(zoom.x * 15. - zoom.y * 8., zoom.y * 17.) / 15.;\n    return (\n        OneSquare(tilt - vec2(0.,    -8.),   8.)  ||\n        OneSquare(tilt - vec2(-4.,   -12.),  4.)  ||\n        OneSquare(tilt - vec2(8.,    0.),    4.)  ||\n        OneSquare(tilt - vec2(8.,    -12.),  4.)  ||\n        OneSquare(tilt - vec2(0.,    8.),    4.)  ||\n        OneSquare(tilt - vec2(-12.,  -4.),   4.)  ||\n        OneSquare(tilt - vec2(-12.,  8.),    4.)  ||\n        OneSquare(tilt - vec2(-8.,   0.),    8.)  );\n}\n\n\nvec3  Composition  (vec2 p) {\n    vec3 c = vec3(0.);\n    c += SunsetScene(p * SCENE_ZOOM);\n    c += NDULogo(p * NDULOGO_ZOOM) ? NDULOGO_FADE : 0.;\n    return c;\n}\n\n\nvoid  mainImage  (out vec4 fragColor, vec2 fragCoord) {\n\n    #define AASS_RECIP (1. / AASS)\n    #define AASS_SQ (AASS * AASS)\n    vec3 accum = vec3(0.);\n    float resmin = min(iResolution.x, iResolution.y);\n    for (float aax = 0.5; aax < AASS; ++aax)\n    for (float aay = 0.5; aay < AASS; ++aay) {\n        vec2 aacoord = fragCoord + vec2(aax, aay) * AASS_RECIP - 0.5;\n        accum += Composition((aacoord * 2. - iResolution.xy) / resmin);\n    }\n    accum /= AASS_SQ;\n\n    float noise_p =\n        9.87654321 * fragCoord.x +\n        8.79546213 * fragCoord.y +\n        7913.84625 * fract(iTime * 0.123456789);\n    float noise_q =\n        6.93582471 * fragCoord.x +\n        5.26841397 * fragCoord.y +\n        4175.28639 * fract(iTime * 0.321654987);\n    float noise_v = fract(sin(noise_p) * 1024.) - fract(sin(noise_q) * 1024.);\n    vec3 noise_c = sin(noise_v * vec3(123456., 456789., 789123.));\n    accum += noise_c * NOISE_FADE;\n\n    fragColor = vec4(accum, 1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}