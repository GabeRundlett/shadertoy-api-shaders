{
    "Shader": {
        "info": {
            "date": "1548654100",
            "description": "explosion",
            "flags": 0,
            "hasliked": 0,
            "id": "tdj3Wz",
            "likes": 4,
            "name": "raymarched explosion",
            "published": 3,
            "tags": [
                "raymarching",
                "explosion"
            ],
            "usePreview": 0,
            "username": "iliazeus",
            "viewed": 593
        },
        "renderpass": [
            {
                "code": "float noise(vec3 p)\n{\n    return texture(iChannel0, p).x;\n}\n\nfloat brownian(vec3 p)\n{\n    float f = 0.0;\n    f += 0.5000*noise(p); p = p*2.32;\n    f += 0.2500*noise(p); p = p*3.03;\n    f += 0.1250*noise(p); p = p*2.61;\n    f += 0.0625*noise(p);\n    return f/0.9375;\n}\n\nfloat df(vec3 p)\n{\n    float r = 6.0 * abs(sin(0.5 * iTime));\n    float sphere = length(p) - r;\n    float disp = 5.0 * brownian(p/10.0);\n    return sphere + disp;\n}\n\nvec3 df_normal(vec3 p)\n{\n    const float EPS = 0.001;\n    vec3 result;\n    float d = df(p);\n    result.x = df(p + vec3(EPS, 0.0, 0.0)) - d;\n    result.y = df(p + vec3(0.0, EPS, 0.0)) - d;\n    result.z = df(p + vec3(0.0, 0.0, EPS)) - d;\n    return normalize(result);\n}\n\nvec3 march(vec3 origin, vec3 dir)\n{\n    const int ITER = 50;\n    vec3 p = origin;\n    vec3 d = normalize(dir);\n    for (int i = 0; i < ITER; i++) {\n        p = p + df(p) * d;\n    }\n    return p;\n}\n\nvec3 origin()\n{\n    return vec3(0.0, 0.0, -15.0);\n}\n\nvec3 fragment_dir(vec2 fragCoord)\n{\n    float aspect = iResolution.x / iResolution.y;\n    return vec3((2.0 * fragCoord / iResolution.yy) - vec2(aspect, 1.0), 5.0);\n}\n\nvec3 explosion_gradient(float x)\n{\n    const vec3 WHITE = vec3(1.0, 1.0, 1.0);\n    const vec3 WHITE_TO_ORANGE = vec3(0.0, -0.4, -1.0);\n    const vec3 ORANGE_TO_RED = vec3(0.0, -0.6, 0.0);\n    const vec3 RED_TO_DARKGRAY = vec3(-0.8, 0.2, 0.2);\n    const vec3 DARKGRAY_TO_GRAY = vec3(0.2, 0.2, 0.2);\n    \n    float w = 1.0;\n    float wo = smoothstep(0.0, 0.8, x);\n    float or = smoothstep(1.0, 1.8, x);\n    float rd = smoothstep(2.0, 2.8, x);\n    float dg = smoothstep(3.0, 3.8, x);\n    \n    return w*WHITE + wo*WHITE_TO_ORANGE + or*ORANGE_TO_RED + rd*RED_TO_DARKGRAY + dg*DARKGRAY_TO_GRAY;\n}\n\nvec4 skybox_color(vec3 p)\n{\n    return vec4(0.7, 0.8, 0.9, 1.0);\n}\n\nvec4 color(vec3 p)\n{\n    const vec3 LIGHT_DIR = normalize(vec3(-1.0, -1.0, 1.0));\n    vec3 n = df_normal(p);\n    if (length(p) > 100.0) return skybox_color(p);\n    //float light = 0.7 * max(dot(-LIGHT_DIR, n), 0.0) + 0.3;\n    return vec4(/* light * */ explosion_gradient(length(p)), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = color(march(origin(), fragment_dir(fragCoord)));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}