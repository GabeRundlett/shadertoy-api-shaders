{
    "Shader": {
        "info": {
            "date": "1635524071",
            "description": "cone tests",
            "flags": 0,
            "hasliked": 0,
            "id": "NsVXWd",
            "likes": 3,
            "name": "conetests",
            "published": 3,
            "tags": [
                "cone"
            ],
            "usePreview": 0,
            "username": "Del",
            "viewed": 217
        },
        "renderpass": [
            {
                "code": "// capped cone / capped pyramid testing\n\n\n//https://iquilezles.org/articles/distfunctions#\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n//float sdCappedConeTest( vec3 p, float h, float r1, float r2 )\n//{\n//  vec2 q = abs(p).xz-vec2(0.125);\n//  q = vec2(length(max(q,0.0)) + min(max(q.x,q.y),0.0),p.y);\n//  vec2 k1 = vec2(r2,h);\n//  vec2 k2 = vec2(r2-r1,2.0*h);\n//  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n//  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n//  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n//  return s*sqrt( min(dot2(ca),dot2(cb)) );\n//}\n\n\n\n\n\n// truncated pyramid - https://www.shadertoy.com/view/NsKSDc\nfloat sdCappedPyramid(vec3 position, float h, float r1, float r2 )\n{\n    float s1 = abs(position.y) - h;\n    // bottom\n    vec3 position1 = position;\n    position1.y -= -h;\n    position1 = abs(position1) - vec3(r1, 0.0, r1);\n    vec3 intersection1 = max(position1, 0.0);\n    float d1 = dot(intersection1, intersection1);\n    // top\n    vec3 position2 = position;\n    position2.y -= h;\n    position2 = abs(position2) - vec3(r2, 0.0, r2);\n    vec3 intersection2 = max(position2, 0.0);\n    float d2 = dot(intersection2, intersection2);\n    \n    position.x = abs(position.x);\n    position.z = abs(position.z);\n\n    vec3 p1 = vec3(r1, -h, 0.0);\n    vec3 p2 = vec3(r1, -h, r1);\n    vec3 p3 = vec3(0.0, -h, r1);\n    vec3 p4 = vec3(r2, h, 0.0);\n    vec3 p5 = vec3(r2, h, r2);\n    vec3 p6 = vec3(0.0, h, r2);\n    vec3 end = p5 - p2;\n    vec3 position3 = position - p2;\n  \n    // side\n    vec3 normal1 = cross(p1 - p2, end);\n    float s2 = dot(position3, normal1);\n    float d3;\n    if (dot(cross(normal1, p2 - p1), position - p2) < 0.0 && \n        dot(cross(normal1, p2 - p1), position - p5) > 0.0 &&\n        dot(cross(normal1, p5 - p2), position - p2) < 0.0) { \n        d3 = s2 * s2 / dot(normal1, normal1);\n    } else {\n        vec3 intersection = position3 - end * clamp(dot(position3, end) / dot(end, end), 0.0, 1.0);\n        d3 = dot(intersection, intersection);\n    }\n \n    // front/back\n    vec3 normal2 = cross(end, p3 - p2);\n    float s3 = dot(position3, normal2);\n    float d4;\n    if (dot(cross(normal2, p6 - p5), position - p2) < 0.0 &&\n        dot(cross(normal2, p6 - p5), position - p5) > 0.0 && \n        dot(cross(normal2, p2 - p5), position - p5) < 0.0) { \n        d4 = s3 * s3 / dot(normal2, normal2);\n    } else {\n        vec3 intersection = position3 - end * clamp(dot(position3, end) / dot(end, end), 0.0, 1.0);\n        d4 = dot(intersection, intersection);\n    }\n    return sqrt(min(min(min(d1, d2), d3), d4)) * sign(max(max(s1, s2), s3));\n}\n\nmat3 lookAtMatrix(vec3 from, vec3 to) {\n    vec3 forward = normalize(to - from);\n    vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = cross(right, forward);\n    return mat3(right, up, forward);\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\nfloat sdf(in vec3 position)\n{ \n\n    position.xz*=rot(fract(iTime*0.1)*6.28);\n\n    float m = sin(iTime*2.2)*0.3;\n\n    \n    float r1 = 0.7-m;\n    float r2 = 0.7+m;\n    float halfHeight = 0.75;\n    float d1 = sdCappedPyramid(position-vec3(1.5,0.0,0.0), halfHeight, r1, r2);\n    float d2 = sdCappedCone(position+vec3(1.5,0.0,0.0), halfHeight, r1, r2);\n    \n    return min(d1,d2);\n}\n\nvec3 normal(vec3 position) {\n    float epsilon = 0.001;\n    vec3 gradient = vec3(\n        sdf(position + vec3(epsilon, 0, 0)) - sdf(position + vec3(-epsilon, 0, 0)),\n        sdf(position + vec3(0, epsilon, 0)) - sdf(position + vec3(0, -epsilon, 0)),\n        sdf(position + vec3(0, 0, epsilon)) - sdf(position + vec3(0, 0, -epsilon))\n    );\n    return normalize(gradient);\n}\n\n\n//https://www.shadertoy.com/view/ttGfz1\nfloat lighting(vec3 normal)\n{\n    //fake image based lighting (\"outdoor lighting\")\n    return length(sin(normal*2.)*.5+.5)/sqrt(3.)*smoothstep(-1.,1.,normal.z);\n}\n\n\nfloat raycast(vec3 rayOrigin, vec3 rayDirection) {\n    int stepCount = 128;\n    float maximumDistance = 15.0;\n    float t = 0.0;\n    for (int i = 0; i < stepCount; i++) {\n        if (t > maximumDistance) {\n            break;\n        }\n        vec3 currentPosition = rayOrigin + rayDirection * t;\n        float d = sdf(currentPosition);\n        if (d < 0.0001) {\n            return t;\n        }\n        t += d;\n    }\n    return 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t//float angle = 0.5 * (iTime - 10.0);\n    float angle = 0.0;\n\tvec3 rayOrigin = 1.2 * vec3(3.0 * cos(angle), 1.5, 3.0 * sin(angle));\n    vec3 targetPosition = vec3(0.0);\n    mat3 cameraTransform = lookAtMatrix(rayOrigin, targetPosition);\n    vec3 result = vec3(0.0);\n    ivec2 sampleCount = ivec2(1.0, 1.0);\n    for (int y = 0; y < sampleCount.y; y++) {\n        for (int x = 0; x < sampleCount.x; x++) {\n            vec2 uv = fragCoord + (vec2(float(x), float(y)) / vec2(sampleCount) - 0.5);\n            uv = uv / iResolution.xy;\n            uv = (uv * 2.0) - 1.0;\n            uv.x *= iResolution.x / iResolution.y;\n            vec3 rayDirection = normalize(vec3(uv, 1.5));\n            rayDirection = cameraTransform * rayDirection;\n            float t = raycast(rayOrigin, rayDirection);\n            vec3 color = vec3(0.0);\n            if (t > 0.0) {\n                vec3 position = rayOrigin + rayDirection * t;\n                vec3 n = normal(position);\n                float ll = lighting(n);\n                color = vec3(0.9,0.9,0.5)*ll;\n\n                \n                if (iMouse.z>0.5)\n                {\n                    fragColor = vec4(n, 1.0);\n                    return;\n                }\n                \n            }\n            // gamma        \n            color = sqrt(color);\n            result += color;\n        }\n    }\n    result /= float(sampleCount.x * sampleCount.y);\n\tfragColor = vec4(result, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}