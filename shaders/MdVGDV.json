{
    "Shader": {
        "info": {
            "date": "1456588730",
            "description": "Quite simple one, just for practicing<br/>Simpler and normalized version of 3b (Disney's diffuse)<br/><br/>3b: <a href=\"https://www.shadertoy.com/view/lsGGR3\" class=\"regular\" target=\"_blank\">https://www.shadertoy.com/view/lsGGR3</a>",
            "flags": 0,
            "hasliked": 0,
            "id": "MdVGDV",
            "likes": 0,
            "name": "Ray Marching Practice 3c",
            "published": 3,
            "tags": [
                "3d",
                "raymarching"
            ],
            "usePreview": 0,
            "username": "Takoa",
            "viewed": 425
        },
        "renderpass": [
            {
                "code": "// Spheres with simpler Disney's diffuse\n// \n// http://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf\n//\n// The diffuse is normalized according to the Frostbite course notes.\n//\n// http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr_v2.pdf\n\n#define PI 3.1415926\n#define INV_PI 0.31830988\n#define INV_GAMMA 0.45454545\n\n#define EPSILON 0.0001\n\nvec3 sphereColor = vec3(0.3, 0.9, 0.6);\n\nvec3 cameraPosition = vec3(0.0, 0.0, 2.0);\nvec3 cameraUp = vec3(0.0, 1.0, 0.0);\nvec3 cameraLookingAt = vec3(0.0, 0.0, -100.0);\n\nfloat roughness = 0.3;\n\nfloat getDistanceToSphere(vec3 rayPosition, vec3 spherePosition, float radius)\n{\n    return length(spherePosition - rayPosition) - radius;\n}\n\nfloat getDistance(vec3 position)\n{\n    return min(\n        getDistanceToSphere(position, vec3(-0.5, 0.0, 0.0), 1.0),\n        getDistanceToSphere(position, vec3(0.5, 0.0, 0.0), 1.0));\n}\n\nvec3 getNormal(vec3 p)\n{\n    return normalize(vec3(\n          getDistance(p + vec3(EPSILON, 0.0, 0.0)) - getDistance(p - vec3(EPSILON, 0.0, 0.0)),\n          getDistance(p + vec3(0.0, EPSILON, 0.0)) - getDistance(p - vec3(0.0, EPSILON, 0.0)),\n          getDistance(p + vec3(0.0, 0.0, EPSILON)) - getDistance(p - vec3(0.0, 0.0, EPSILON))\n        ));\n}\n\nvec3 getRayDirection(vec2 screenPosition, vec3 origin, vec3 lookingAt, vec3 up, float fov)\n{\n    vec3 d = normalize(lookingAt - origin);\n    vec3 rayRight = normalize(cross(d, up));\n    \n    return normalize(screenPosition.x * rayRight + screenPosition.y * up + 1.0 / tan(radians(fov / 2.0)) * d);\n}\n\nfloat rayMarch(inout vec3 p, vec3 rayDirection)\n{\n    float d;\n    \n    for (int i = 0; i < 128; i++)\n    {\n        d = getDistance(p);\n        p += d * rayDirection;\n    }\n    \n    return d;\n}\n\nvec3 pow3(vec3 color, float g)\n{\n    return vec3(pow(color.x, g), pow(color.y, g), pow(color.z, g));\n}\n\nfloat getSchlicksApproximation(float f)\n{\n    float g = clamp(1.0 - f, 0.0, 1.0);\n    float g2 = g * g;\n    \n    return g2 * g2 * g;\n}\n\nvec3 getDisneysReflectance(\n    vec3 normal,\n    vec3 lightDirection,\n    vec3 viewDirection,\n    vec3 baseColor,\n    float roughness)\n{\n    float cosL = dot(normal, lightDirection);\n    \n    if (cosL < 0.0)\n        return vec3(0.0);\n    \n    float cosV = dot(normal, viewDirection);\n    float cosD = dot(lightDirection, normalize(lightDirection + viewDirection));\n    float fl = getSchlicksApproximation(cosL);\n    float fv = getSchlicksApproximation(cosV);\n    float fD90M1 = mix(-1.0, -0.5, roughness) + 2.0 * cosD * cosD * roughness;\n    float fD = (1.0 + fD90M1 * fl) * (1.0 + fD90M1 * fv) * mix(1.0, 0.66225165, roughness);\n    \n    return baseColor * INV_PI * fD * cosL;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 position = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 lightPosition = vec3(10.0 * cos(iTime), 10.0, 10.0 * sin(iTime));\n    vec3 rayDirection = getRayDirection(position, cameraPosition, cameraLookingAt, cameraUp, 90.0);\n    vec3 p = cameraPosition;\n    float d = rayMarch(p, rayDirection);\n    \n    if (d < EPSILON)\n    {\n        vec3 normal = getNormal(p);\n        vec3 lightDirection = normalize(lightPosition - p);\n        vec3 diffuse = getDisneysReflectance(\n            normal,\n            lightDirection,\n            -rayDirection,\n            sphereColor,\n            roughness\n\t\t);\n        \n        fragColor = vec4(pow3(diffuse, INV_GAMMA), 1.0);\n    }\n    else\n    {\n        fragColor = vec4(0.2, 0.2, 0.2, 1.0);\n    }\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}