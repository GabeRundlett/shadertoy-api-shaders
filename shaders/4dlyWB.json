{
    "Shader": {
        "info": {
            "date": "1489678261",
            "description": "The surface isn't shaded so I can do anti-aliasing with cone-tracing effectively. I needed a scene to showcase the anti-aliasing, got that and sort of went with it.",
            "flags": 1,
            "hasliked": 0,
            "id": "4dlyWB",
            "likes": 32,
            "name": "Type 1 Remnants",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "fractal",
                "raymarch",
                "space",
                "alien",
                "city",
                "ruin"
            ],
            "usePreview": 0,
            "username": "Klems",
            "viewed": 1988
        },
        "renderpass": [
            {
                "code": "\n#define PI 3.14159265359\n#define SQ 0.70710678118\n\n#define FOV (PI*0.5)\n#define FOG_COLOR vec3(0.5, 0.3, 0.2)\n#define RAY_STEPS 200\n#define FRACTAL_SCALE 1.5\n#define FRACTAL_LEVELS 7\n\n// how fast the path is going on y\n#define TIME_SCALE 0.6\n\n// skybox super sampling\n#define BACKGROUND_SS 16\n\n// fraction of the frame period where the shutter is open\n#define MOTION_BLUR 0.5\n// use the current framerate instead of 60 Hz\n//#define MOTION_BLUR_ADAPTATIVE\n\nvec3 camPos = vec3(0);\nvec3 camPath( float y ) {\n    return vec3(sin(y*0.424)*0.27, y, 0.03 + (sin(y*0.323)*0.5+0.5)*1.3);\n}\n\nfloat hash11(float p) {\n    #define HASHSCALE1 .1031\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3){\n    #define HASHSCALE3 vec3(.1031, .1030, .0973)\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nmat2 rot( in float a ) {\n    vec2 v = sin(vec2(PI*0.5, 0) + a);\n    return mat2(v, -v.y, v.x);\n}\n\nfloat sdBox( in vec3 p, in vec3 b ) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// like abs but with a rounded corner instead // UNUSED\n/*float smoothAbs(float x, float radius) {\n    float ab = abs(x);\n    if ( ab > SQ*radius ) {\n        return ab;\n    }\n    float xCirc = x/radius;\n    return 2.0*SQ*radius - sqrt(1.0 - xCirc*xCirc)*radius;\n}*/\n\n// stairs abs\nfloat stairsAbs( in float x, in float radius, in float wide) {\n    float ab = abs(x);\n    float v = abs(fract((x)/wide)*2.0-1.0)*0.5*wide + radius;\n    return max(ab, v);\n}\n\n// transform a and b into 1D space, use a 1D function to shape the union\nfloat smin( in float a, in float b, in float r ) {\n    vec2 uv = vec2(a, b)*0.5;\n    float x = uv.x - uv.y;\n    //float f = abs(x); // = min(a, b)\n    //float f = smoothAbs(x, r);\n    float f = stairsAbs(x, r, 0.01);\n    return uv.x + uv.y - f;\n}\n\nfloat smax( in float a, in float b, in float r ) {\n    vec2 uv = vec2(a, b)*0.5;\n    float x = uv.x - uv.y;\n    //float f = abs(x); // min(a, b)\n    //float f = smoothAbs(x, r);\n    float f = stairsAbs(x, r, 0.01);\n    return uv.x + uv.y + f;\n}\n\n// trace functions are used for the background only\n\nbool intSphere( in vec4 sp, in vec3 ro, in vec3 rd, out float t ) {\n    vec3  d = ro - sp.xyz;\n    float b = dot(rd,d);\n    float c = dot(d,d) - sp.w*sp.w;\n    float tt = b*b-c;\n    if ( tt > 0.0 ) {\n        t = -b-sqrt(tt);\n        return true;\n    }\n    return false;\n}\n\nbool intPlane( in vec4 pl, in vec3 ro, in vec3 rd, out float t ) {\n    float tt = -(dot(pl.xyz,ro)+pl.w)/dot(pl.xyz,rd);\n    if (tt > 0.0) {\n        t = tt;\n        return true;\n    }\n    return false;\n}\n\n// space background\nvec3 getSpace( in vec3 dir ) {\n    \n    vec3 normal = vec3(0);\n    vec3 color = vec3(0);\n    vec3 from = vec3(0, -2.5, 0);\n    \n    float toSphere = 0.0;\n    bool sphere = intSphere( vec4(0, 0, 0, 1), from, dir, toSphere);\n    if (sphere) {\n        // gas giant\n        normal = from + dir*toSphere;\n        color = vec3(0.8, 0.9, 1.0);\n        color *= max(0.0, dot(normal, normalize(vec3(-8, -4, 3))));\n    }\n    \n    const vec3 planeDir = normalize(vec3(28, 3, -8));\n    float toPlane = 0.0;\n    bool plane = intPlane( vec4(planeDir, 0), from, dir, toPlane);\n    \n    if ( plane && (toPlane < toSphere || !sphere) ) {\n        // rings\n        vec3 onPlane = from + dir*toPlane;\n\t\tonPlane -= planeDir*dot(onPlane, planeDir);\n        float len = length(onPlane);\n        vec3 ringColor = mix( vec3(0.5, 0.4, 0.3), vec3(0.8), sin(len*10.0)*0.5+0.5);\n        float alpha = smoothstep(2.5, 2.0, len);\n        alpha *= smoothstep(1.1, 1.5, len);\n        color = mix(color, ringColor, alpha);\n    }\n    \n    return color;\n\n}\n\n// space background with buildings on top\nvec3 background( in vec3 dir) {\n    vec2 uv = vec2(atan(dir.x, dir.y) / PI * 14.0, dir.z*7.0);\n    vec2 center = vec2(floor(uv.x)+0.5, 0);\n    float height = hash11(center.x)*3.0;\n    float build = smoothstep(0.0, 0.05, sdBox(vec3(uv-center, 0), vec3(0.41, 0.06+height, 1)));\n    vec2 windows = abs(fract(uv-center + vec2(0, height)));\n    vec2 inGrid = abs(fract((uv-center - vec2(0, height))*6.15)-0.5)*2.0;\n    float grid = min(inGrid.x, inGrid.y);\n    vec3 colorBuild = mix(vec3(0), vec3(0.1, 0.07, 0.05), smoothstep(0.8, 0.1, grid));\n    return mix(colorBuild, getSpace(dir), build);\n}\n\nfloat de( in vec3 p, in float totdist, inout vec3 color ) {\n\n    // derive the camera path\n    vec3 path1 = camPath(p.y);\n    vec3 path2 = camPath(p.y+0.01);\n    vec3 deriv = (path2 - path1) / 0.01;\n    \n    // extrude a box along the camera path\n    vec3 inTunnel = vec3(p.xz - camPath(p.y).xz, p.y);\n    inTunnel /= length(deriv);\n    inTunnel.x = mod(inTunnel.x+FRACTAL_SCALE*0.25, FRACTAL_SCALE*0.5) - FRACTAL_SCALE*0.25;\n    vec3 inTunnelHigh = inTunnel;\n    inTunnelHigh.y = min(0.0, inTunnelHigh.y);\n    \n    float box = sdBox(vec3(inTunnel.xy, 0), vec3(0.1, 0.2, 1));\n    float boxHigh = sdBox(vec3(inTunnelHigh.xy, 0), vec3(0.1, 0.2, 1));\n    float moreBox = sdBox(vec3(inTunnel.xy, 0)-vec3(0, 0.2, 0), vec3(0.05, 0.05, 1));\n    box = smin(box, moreBox, 0.01);\n    \n    // add a skydome\n    float d = 10.0 - length(p-camPos);\n    if (p.z < d) {\n        d = p.z;\n        color = vec3(0.8, 0.9, 1.0);\n    }\n\n    // keep scale and rotation\n    float scale = 1.0;\n    float rotation = p.y;\n    \n    for (int i = 0 ; i < FRACTAL_LEVELS ; i++) {\n        // scale and rotate\n        float s = FRACTAL_SCALE;\n\t\tp.xy = 1.0 - abs(s*fract(p.xy-0.5)-s*0.5);\n        p.z *= s;\n        p.xy *= rot(PI * 0.538 + rotation*0.2);\n        \n\t\tscale *= s;\n        \n        if (i < 1) continue;\n        \n        float height = -log(float(i+1)*0.01);\n        float base = 0.25+log(float(i+1))*0.2;\n        float size = 2.0;\n        float dist = sdBox(p, vec3(vec2(base), height));\n        dist /= scale;\n        // extrude the tunnel\n        float extrude = box;\n        if (i < 2) extrude = boxHigh;\n        dist = smax(dist, -extrude, 0.01);\n        \n        // do different things on the roof\n        float roofy = smoothstep(height-0.1, height, p.z);\n        // do coloring\n        vec3 levColor = mix(vec3(0.39, 0.33, 0.3), vec3(0.9, 0.3, 0.1), float(i-1)/float(FRACTAL_LEVELS-2));\n        // add tiles on the roof\n        vec3 roofWaves = vec3(sin(p.y*50.0)*0.2*roofy, 0, 0);\n        vec3 roofFreq = vec3(vec2(1.0 + roofy), 1);\n        vec3 inGrid = abs(fract(p*10.3*roofFreq+roofWaves)-0.5)*2.0;\n        float grid = min(min(inGrid.x, inGrid.y), inGrid.z);\n        grid = smoothstep(0.8-roofy*0.3, 0.1, grid);\n        grid = mix(grid, 1.0-grid, roofy);\n        // distance based filtering\n        grid = mix(grid, 0.5, clamp(totdist/iResolution.x*170.0, 0.0, 1.0));\n        levColor = mix(vec3(0), levColor, grid);\n        // add a rim on top of the building\n        levColor = mix(levColor, vec3(0), smoothstep(0.07, 0.01, abs(p.z - height + 0.05)));\n        levColor = mix(levColor, vec3(0.01), smoothstep(0.0, 0.01, abs(dist)));\n        // difference from last \n        color = mix(color, levColor, smoothstep(-0.08, +0.08, d-dist));\n        \n        d = smin(d, dist, 0.01);\n    }\n    \n    return d;\n    \n}\n\n// iq's analytical fog\nvec3 applyFog( in vec3 rgb, in float dist, in vec3 rayOri, in vec3 rayDir ) {\n    const float c = 0.7;\n    const float b = 2.0;\n    float fogAmount = c * exp(-rayOri.z*b) * (1.0-exp( -dist*rayDir.z*b ))/rayDir.z;\n    return mix( rgb, FOG_COLOR, clamp(fogAmount, 0.0, 1.0) );\n}\n\n// get the direction from uv\nvec3 getDir( in vec2 fragCoord, in vec3 lookAt ) {\n    // user input\n    vec2 mouse=(iMouse.xy / iResolution.xy - 0.5) * 0.5;\n    mouse *= step(1.0, iMouse.z);\n    \n    // look at\n    vec3 forward = normalize(lookAt-camPos);\n    vec3 right = normalize(cross(vec3(0, 0, 1), forward));\n    vec3 top = cross(forward, right);\n\n    // create direction\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n\tuv.y *= iResolution.y / iResolution.x;\n    float forwardScale = 1.0 / tan(FOV*0.5);\n    vec3 dir = forward*forwardScale + right*uv.x + top*uv.y;\n    dir = normalize(dir);\n    dir.yz *= rot(mouse.y*-6.0+0.1);\n    dir.xy *= rot(-mouse.x*6.0 + sin(iTime*0.05)*0.1);\n    \n    return dir;\n}\n\n// accumulate opacity along this cone\nvec3 getColor( in vec2 fragCoord, in vec3 dir, in float theta ) {\n    \n    vec3 rnd = hash33(vec3(fragCoord, iFrame));\n    \n    // super-sample the background\n    vec3 backcolor = vec3(0);\n    for (int i = 0 ; i < BACKGROUND_SS ; i++) {\n        vec3 rndSamp = hash33(vec3(fragCoord, iFrame*BACKGROUND_SS+i));\n        vec3 dirTan = normalize(cross(dir, vec3(0, 1, PI)));\n        vec3 dirCoTan = cross(dir, dirTan);\n        float rot = 2.0*PI*rndSamp.x;\n        float the = acos(1.0 - rndSamp.y*(1.0 - cos(theta)));\n        float sinThe = sin(the);\n        vec3 backDir = dirTan*sinThe*cos(rot) + dirCoTan*sinThe*sin(rot) + dir*cos(the);\n        backcolor += background(backDir);\n    }\n    backcolor /= float(BACKGROUND_SS);\n    \n    // sine of the pixel angle\n    float sinPix = sin(theta);\n    // accumulate color front to back\n    vec4 acc = vec4(0, 0, 0, 1);\n    \n    float totdist = 0.0;\n    vec3 dummy = vec3(0);\n    totdist += rnd.z*de(camPos, 0.0, dummy);\n    \n\tfor (int i = 0 ; i < RAY_STEPS ; i++) {\n\t\tvec3 p = camPos + totdist * dir;\n        vec3 color = backcolor;\n        float dist = de(p, totdist, color);\n        \n        color = applyFog(color, totdist+dist, camPos, dir);\n        \n        // cone trace the surface\n        float prox = dist / (totdist*sinPix);\n        float alpha = clamp(prox * -0.5 + 0.5, 0.0, 1.0);\n        \n        if (alpha > 0.01) {\n            // accumulate color\n            acc.rgb += acc.a * (alpha*color.rgb);\n            acc.a *= (1.0 - alpha);\n        }\n        \n        // hit a surface, stop\n        if (acc.a < 0.01) {\n            break;\n        }\n        \n        // continue forward\n        totdist += max(abs(dist*0.85), 0.001);\n\t}\n    \n    vec3 result = vec3(0);\n    \n    // add background\n    result = acc.a*FOG_COLOR + acc.rgb;\n    // dithering\n    result += rnd * 0.02 - 0.01;\n    // gamma correction\n    result = pow( result, vec3(1.0/2.2) );\n    \n    return result;\n    \n}\n\n// normal entry point\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec3 rnd = hash33(vec3(fragCoord, -iFrame));\n    \n    // pseudo motion blur\n    float pos = iTime*TIME_SCALE;\n    float period = 1.0 / 60.0;\n    #ifdef MOTION_BLUR_ADAPTATIVE\n    period = iTimeDelta;\n    #endif\n    pos -= rnd.x * period * TIME_SCALE * MOTION_BLUR;\n    // position of the camera\n    camPos = camPath(pos);\n    // look at\n    vec3 lookAt = camPath(pos+0.01);\n    \n    // set dir and get the pixel angle\n    vec3 dir = getDir(fragCoord + rnd.xy - 0.5, lookAt);\n    float alpha = (iResolution.x*0.5) / tan(FOV*0.5);\n    vec2 angleTo = atan((fragCoord.xy - iResolution.xy*0.5) / alpha);\n    float pixelAngle = length(vec2(dFdx(angleTo.x), dFdy(angleTo.y)));\n    \n    // get color\n    vec3 color = getColor(fragCoord, dir, pixelAngle);\n    fragColor = vec4(color, 1);\n\n}\n\n// vr entry point\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir ) {\n    \n    fragRayDir.xyz = fragRayDir.xzy * vec3(1, -1, 1);\n    fragRayOri.xyz = fragRayOri.xzy * vec3(1, -1, 1);\n    \n    vec3 rnd = hash33(vec3(fragCoord, iFrame*2+1));\n    \n    // pseudo motion blur\n    float pos = iTime*TIME_SCALE;\n    float period = 1.0 / 60.0;\n    #ifdef MOTION_BLUR_ADAPTATIVE\n    period = iTimeDelta;\n    #endif\n    pos -= rnd.x * period * TIME_SCALE * MOTION_BLUR;\n    \n    // position of the camera\n    camPos = camPath(pos);\n    camPos += fragRayOri*0.07;\n    // look at\n    vec3 lookAt = camPath(pos+0.01);\n    \n    // set dir and get the pixel angle\n    vec3 dir = fragRayDir;\n    float alpha = (iResolution.x*0.5) / tan(FOV*0.5);\n    vec2 angleTo = atan((fragCoord.xy - iResolution.xy*0.5) / alpha);\n    float pixelAngle = length(vec2(dFdx(angleTo.x), dFdy(angleTo.y)));\n    \n    // get color\n    vec3 color = getColor(fragCoord, dir, pixelAngle*2.0);\n    fragColor = vec4(color, 1);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}