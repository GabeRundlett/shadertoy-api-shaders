{
    "Shader": {
        "info": {
            "date": "1584224697",
            "description": "Going mad and storing 8 particle id's in 1 texel based on the distance to the texel. Pilot wave particles the 3D remaster. \nBouncing droplet experiment - the game.",
            "flags": 48,
            "hasliked": 0,
            "id": "WsXyzN",
            "likes": 22,
            "name": "Pilot wave system 3D",
            "published": 3,
            "tags": [
                "particles"
            ],
            "usePreview": 1,
            "username": "michael0884",
            "viewed": 788
        },
        "renderpass": [
            {
                "code": "// Fork of \"Pilot wave system II\" by michael0884. https://shadertoy.com/view/3sXyz4\n// 2020-03-14 20:40:40\n\n// Fork of \"Quadruple voronoi diagram\" by michael0884. https://shadertoy.com/view/tdscRr\n// 2020-03-14 14:30:34\n\n#define FOV 1.5\n#define R 140.\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat particleDistance(int id, vec2 p)\n{\n    return distance(getParticle(id).xy, p);\n}\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n#define freq 15.\nfloat DE(vec3 pos)\n{\n    pos.xy += size*0.5;\n    float de = 1e10;\n    ivec2 p = ivec2(pos.xy);\n    get(p);\n   \tfloat y = 0.;\n   \n    for(int i = 0; i < CN; i++)\n    {\n        vec4 p0 = getParticle(ids[i]); \n        float d = distance(pos.xy, p0.xy);\n        \n        float ph = 6.*hash11(float(ids[i]));\n        float osc = (0.5+0.5*sin(freq*iTime+ph));\n        y += -2.*sin(-freq*iTime-ph)*sin(d)/(k*d+1.);\n        \n        de = min(de, sdSphere(pos - vec3(p0.xy, 4.*prad*osc+4.5), 0.5*prad));\n    }\n    de = min(de, 0.8*sdBox(pos - vec3(size, 4.*y)*0.5, vec3(size*0.5, 3.)));\n    return de;\n}\n\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 K = vec3(1,-1,0);\n\treturn  (K.xyyx*DE(p + K.xyy*dx) +\n\t\t\t K.yyxx*DE(p + K.yyx*dx) +\n\t\t\t K.yxyx*DE(p + K.yxy*dx) +\n\t\t\t K.xxxx*DE(p + K.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n#define M 128.\n#define min_d 0.5\nvec4 ray_march(vec3 p, vec3 r)\n{\n    float d;\n    for(float i = 0.; i < M; i++)\n    {\n        d = DE(p); \n        p += r*d;\n        if(d < min_d || d > size.x) break;\n    }\n    return vec4(p, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates \n    vec2 pos = (fragCoord - iResolution.xy*0.5)/max(iResolution.x,iResolution.y);\n    \n    vec2 uv = iMouse.xy/iResolution.xy;\n    vec2 angles = vec2(uv.x*2., 0.3*uv.y - 0.3)*PI;\n    \n    vec3 camera_z = vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n    vec3 camera_x = normalize(vec3(cos(angles.x+PI*0.5), sin(angles.x+PI*0.5),0.)); \n    vec3 camera_y = -normalize(cross(camera_x,camera_z));\n    \n    //tracking particle\n    vec4 fp = getParticle(0);\n    \n    vec3 ray = normalize(camera_z + FOV*(pos.x*camera_x + pos.y*camera_y));\n    vec3 cam_pos = vec3(fp.xy-size.xy*0.5, 0.) - R*vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n    \n    vec4 sphere = vec4(0.,0.,0., 1.);\n    \n    vec4 X = ray_march(cam_pos, ray);\n  \n    if(X.w < min_d)\n    {\n    \tvec4 N0 = calcNormal(X.xyz, 0.6);\n   \t\tvec3 n = normalize(N0.xyz);\n        vec3 rd = reflect(ray, n);\n        vec3 rfd = refract(ray, n, 1.15);\n        vec3 col = texture(iChannel2,  rd.yzx).xyz;\n        vec3 col1 = texture(iChannel2,  rfd.yzx).xyz;\n        float K = 1. - pow(max(dot(n,rd),0.), 3.);\n        fragColor.xyz = col*K + 0.6*col1*(1.-K);\n    }\n    else\n    {    \n        //background\n        fragColor = texture(iChannel2,  ray.yzx);\n    }\n \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//particle buffer\n//particle buffer\n\n//Keyboard constants\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\n\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\n//force scalar\nfloat F(float d)\n{\n    d /= 2.*prad;\n    return -ff*sin(d)/(k*d);\n}\n\n//force vector\nvec2 Fv(vec2 p0, vec2 p1)\n{\n    if(!all(equal(p0,p1)))\n   \t return normalize(p1-p0)*F(distance(p1,p0));\n    else\n     return vec2(0.);\n}\n\n//get particle from array\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    if(p.x < N.x && p.y < N.y)\n    {\n        pos = floor(pos);\n        //this pixel value\n        U = texel(ch1, pos);\n   \t\t\n        int id = xy2i(p);\n        //neighbors\n   \t\tget(ivec2(U.xy));\n      \n        vec2 F = vec2(0.,0.);\n        \n        vec4 p0 = getParticle(ids[0]);\n        for(int i = 1; i < CN; i++)\n        {\n            vec4 pi = getParticle(ids[i]);\n        \tF += Fv(U.xy, pi.xy);    \n        }\n        \n        if(isKeyPressed(KEY_SPACE)) F *= 3.;\n        \n        if(id == 0)\n        {\n            //keyboard controls lol\n            vec2 uv = iMouse.xy/iResolution.xy;\n            vec2 angles = vec2(uv.x*2., 0.3*uv.y - 0.3)*PI;\n\n            vec3 camera_z = vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n            vec3 camera_x = normalize(vec3(cos(angles.x+PI*0.5), sin(angles.x+PI*0.5),0.)); \n            vec3 camera_y = -normalize(cross(camera_x,camera_z));\n            vec2 dF = vec2(0.);\n       \t\t\n       \t\tif(isKeyPressed(KEY_A)) dF -= normalize(camera_x.xy);\n            if(isKeyPressed(KEY_D)) dF += normalize(camera_x.xy);\n            if(isKeyPressed(KEY_W)) dF += normalize(camera_y.xy);\n            if(isKeyPressed(KEY_S)) dF -= normalize(camera_y.xy);\n            F += 15.*dF;\n        }\n        \n        U.zw += dt*F;\n        U.zw *= 1. - 0.004*dt*length(U.zw); //cooling\n        U.xy += U.zw*dt;\n        \n        //border conditions\n        if(size.x - U.x < 2.) U.z = -abs(U.z);\n        if(U.x < 2.) U.z = abs(U.z);\n        if(size.y - U.y < 2.) U.w = -abs(U.w);\n        if(U.y < 2.) U.w = abs(U.w);\n \n        //this pixel value\n        if(iFrame<3)\n        {\n            U.xy = size*hash22(pos+395.)+1.;\n\t\t\tU.zw = 2.*(hash22(3.14159*pos) - 0.5);\n        }\n    }\n    else discard;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//definitions\n#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n#define N ivec2(8,8)\n#define dt 0.1\n#define prad 4.\n#define k 0.3\n#define ff 4.\n\nint tot_n = N.x*N.y;\n\n//hash functions\n//https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p) - 0.5;\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//a rainbow colormap from Matlab\nfloat interpolate(float val, float y0, float x0, float y1, float x1) \n{\n    return (val-x0)*(y1-y0)/(x1-x0) + y0;\n}\n\nfloat base(float val) \n{\n    if ( val <= -0.75 ) return 0.0;\n    else if ( val <= -0.25 ) return interpolate( val, 0.0, -0.75, 1.0, -0.25 );\n    else if ( val <= 0.25 ) return 1.0;\n    else if ( val <= 0.75 ) return interpolate( val, 1.0, 0.25, 0.0, 0.75 );\n    else return 0.0;\n}\n\nvec3 jet_colormap(float v)\n{\n    return vec3(base(v - 0.5),base(v),base(v + 0.5));\n}\n\nvec3 jet_range(float v, float a, float b)\n{\n    return jet_colormap(2.*clamp((v-a)/(b-a),0.,1.) - 1.);\n}\n\nuniform sampler2D fake;\n\n//closest particle ids\n#define CN 8\nint ids[CN];\n//particle distances\nfloat ds[CN];\n\nivec2 one2two(int a)\n{\n    return ivec2(a%tot_n, a/tot_n);\n}\n\nint two2one(ivec2 a)\n{\n    return a.x + tot_n*a.y;\n}\n\nvoid toarr(inout int b[CN], ivec2 a, int i)\n{\n    b[i] = a.x;\n    b[i+1] = a.y;\n}\n\nvoid init()\n{\n    for(int i = 0; i<CN; i++)\n    {\n        ids[i] = -1;\n        ds[i] = 1e10;\n    }\n}\n\nvoid getA(inout int b[CN], ivec2 p)\n{ \n    ivec4 a = floatBitsToInt(texel(fake, p/2));\n    toarr(b, one2two(a.x), 0);\n    toarr(b, one2two(a.y), 2);\n    toarr(b, one2two(a.z), 4);\n    toarr(b, one2two(a.w), 6);\n}\n\nvoid get(ivec2 p)\n{\n    getA(ids, p);\n}\n\nvec4 save()\n{\n    ivec4 v = ivec4(two2one(ivec2(ids[0],ids[1])),\n                    two2one(ivec2(ids[2],ids[3])),\n                    two2one(ivec2(ids[4],ids[5])),\n                    two2one(ivec2(ids[6],ids[7])));\n    return intBitsToFloat(v);\n}\n\nivec2 i2xy(int id)\n{\n    return ivec2(id%N.x, id/N.x);\n}\n\nint xy2i(ivec2 p)\n{\n    return p.x + p.y*N.x;\n}\n\nvoid swap(inout int x, inout int y)\n{\n    int b = x;\n    x = y;\n    y = b;\n}\n\nvoid swap(inout float x, inout float y)\n{\n    float b = x;\n    x = y;\n    y = b;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "vec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat particleDistance(int id, vec2 p)\n{\n    return distance(getParticle(id).xy, p);\n}\n\nvoid insert(int id, float d, int i)\n{\n    //shift all by 1\n    for(int j = CN-1; j > i; j--)\n    {\n        ids[j] = ids[j-1];\n        ds[j] = ds[j-1];\n    }\n    \n    //insert\n    ids[i] = id; \n    ds[i] = d;\n}\n\nvoid sort(int utemp, ivec2 p)\n{\n    vec2 pos = vec2(p)+1.;\n    float dtemp = particleDistance(utemp, pos);  \n    //sorting\n    for(int i = 0; i < CN; i++)\n    {\n        if(ids[i] == utemp) return;\n        \n        if(ids[i] < 0 || ds[i] >= dtemp)\n        {\n            insert(utemp, dtemp, i);\n            return;\n        }\n    }\n}\n\nvoid upd(ivec2 p, ivec2 dx)\n{\n    int t[CN];\n    getA(t, max(p + dx, ivec2(0,0)));\n    \n\tfor(int i = 0; i < CN; i++)\n    {\n   \t\tif(t[i]>=0)\n        \tsort(t[i], p);\n    }\n}\n\nvoid randupd(ivec2 p )\n{\n    for(int i = 0; i < 6; i++)\n    {\n        //go through the entire array sudorandomly\n        sort(((iFrame + p.x + p.y*int(iResolution.x))^(1<<i))%tot_n, p);\n    }\n}\n\nvoid updrad(ivec2 p, int R)\n{\n    int r = 1<<R;\n    upd(p, ivec2(r, 0));\n    upd(p, ivec2(-r, 0));\n    upd(p, ivec2(0, r));\n    upd(p, ivec2(0, -r));\n}\n\nvoid update(ivec2 p)\n{\n    randupd(p);\n    upd(p, ivec2(0));\n    updrad(p, 0);\n    updrad(p, 2);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    pos *= 2.;\n    if(pos.x < iResolution.x && pos.y < iResolution.y) //8x voronoi particle tracking but in 2x lower res\n    {\n        ivec2 p = 2*ivec2(pos/2.);\n\n        init();\n\n        update(p);\n\n        U = save();\n    } else discard;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}