{
    "Shader": {
        "info": {
            "date": "1615742994",
            "description": " Unlocking the 'Power Stone' from Guardians of the Galaxy.",
            "flags": 0,
            "hasliked": 0,
            "id": "fdf3Wn",
            "likes": 25,
            "name": "Power Stone (4K)",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "movie",
                "cineshader",
                "gotg"
            ],
            "usePreview": 0,
            "username": "dean_the_coder",
            "viewed": 9842
        },
        "renderpass": [
            {
                "code": "// 'Power Stone (4K)' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/fdf3Wn (YouTube: https://youtu.be/jP95Nqi_Qxw)\n//\n// Unlocking the 'Power Stone' from Guardians of the Galaxy.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// Blackle, Ivan Dianov, and a bunch of others for sharing\n// their knowledge!\n\n#define Z0 min(iTime, 0.)\n#define sat(x) clamp(x, 0., 1.)\n#define S(x) smoothstep(0., 1., x)\n\nfloat g = 0., T;\n\n// #define AA\t// Enable this line if your GPU can take it!\n\nstruct Hit {\n\tfloat d;\n\tint id;\n};\n\n#define minH(a) if (a.d < h.d) h = a\n\nmat2 rot(float a) {\n\tvec2 cs = cos(vec2(a, a - 1.5705));\n\treturn mat2(cs, -cs.y, cs.x);\n}\n\nvec2 polar(vec2 p, float n)\n{\n\tfloat t = 3.141 / n,\n\t\t  a = mod(atan(p.y, p.x) + t, 2. * t) - t;\n\treturn length(p) * vec2(cos(a), sin(a));\n}\n\nfloat bx(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat cap(vec3 p, float h, float r) {\n\tp.x -= clamp(p.x, 0., h);\n\treturn length(p) - r;\n}\n\nfloat sdOcta(vec3 p, float s) {\n  p = abs(p);\n  return (p.x + p.y + p.z - s) * .577;\n}\n\nfloat claws(vec3 p) {\n\tp.yz = polar(p.yz, 3.);\n\n\tp.x = abs(p.x) - .9;\n\tp.y -= 1.;\n\tp.xy *= rot(-.5);\n\tfloat d = max(cap(p, 1.2, .12 * S(p.x + .5)), abs(p.z) - .06);\n\n\tp.xy *= rot(-2.725);\n\tp.x += .1;\n\tp.y -= .05;\n\treturn min(d, max(cap(p, .9, .1 * (1.1 - S(p.x - .2))), abs(p.z) - .04));\n}\n\nHit map(vec3 p) {\n\tp.y -= 2.;\n\n\t// Ground.\n\tHit h = Hit(abs(p.y + 2.), 1);\n\n\tvec3 op = p;\n\n\t// Shell rotations.\n\tfloat t = (5. - clamp(T - 3., 0., 5.)) * 1.25664;\n\tp.yz *= rot((sin(t) + sin(2. * t)) * sign(p.x) * 1.4);\n\tt = max(0., T - 8.);\n\tfloat anim = sat((t - 1.) / 8.);\n\tvec2 shellOpen = S(vec2(anim * 4., anim * 4.5 - 3.)) * .7, // Outer, inner.\n\t\t f = p.x - shellOpen * sign(p.x),\n\t\t gaps = -abs(p.x) - .01 + shellOpen;\n\tp.x = p.x < 0. ? min(0., f.x) : max(0., f.x);\n\n\t// Claws.\n\tfloat x = abs(p.x) - .6,\n\t\t  d = max(dot(vec2(1.5, .6), vec2(length(p.yz), -x)), -x);\n\td = max(d, max(length(p.yz) - .5, 1.2 - abs(p.x)));\n\tminH(Hit(min(d, claws(p)), 3));\n\n\t// Outer shell halves.\n\tfloat s = length(p) - 1.;\n\td = max(min(\n\t\t\t   // Gyroid pattern.\n\t\t\t   length(vec2(s, dot(sin(p * 26.), cos(p.zxy * 26.)) * .03)) - .02,\n\t\t\t   // Shell.\n\t\t\t   abs(s + .08) - .05), gaps.x);\n\n\t// Inner shell halves.\n\tp.x = op.x < 0. ? min(0., f.y) : max(0., f.y);\n\n\tfloat i = mod(floor(atan(-p.y, p.z) * 3.183 + 10.) + 2., 20.),\n\t\t  temp = sat(anim * 4. - 2.) * 20.;\n\tfloat d2 = max(\n\t\tabs(length(p) - .65) - .05, // Shell.\n\t\tgaps.y // Split into two halves.\n\t\t+ .01 + .13 * step(i, temp) * min(temp - i, 1.));\n\n\t// Cut away shell slots.\n\tp.yz = polar(p.yz, 20.);\n\tp.y -= .64;\n\td = min(d, max(d2, -bx(p, vec3(.15, .08, .025))));\n\n\t// Stone.\n\tp = op;\n\tp.yz *= rot(t * .1);\n\tmat2 r = rot(2.5);\n\td2 = 1e7;\n\tfor (i = Z0; i < 4.; i++) {\n\t\tp -= .02;\n\t\tp.xy *= rot(3.7 + i);\n\t\tp.yz *= r;\n\t\td2 = min(d2, sdOcta(p, .3) - .005);\n\t}\n\n\tg += .00008 / (.001 + d2 * d2); // Glow - Stone.\n\tminH(Hit(d2, 4));\n\n\t// Glow - Flux.\n\tp = op;\n\tp.x = abs(p.x);\n\tp.y += cos(p.x + t) * .05;\n\td2 = length(p.yz) - .01;\n\tg += .0005 / (.001 + d2 * d2);\n\n\tminH(Hit(min(d, d2), 2));\n\treturn h;\n}\n\nvec3 N(vec3 p, float t) {\n\tfloat h = t * .4;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h).d;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat shadow(vec3 p, vec3 ld) {\n\t// Thanks iq.\n\tfloat s = 1., t = .1, i, h;\n\tfor (i = Z0; i < 15.; i++)\n\t{\n\t\th = map(t * ld + p).d;\n\t\ts = min(s, 15. * h / t);\n\t\tt += h;\n\t\tif (s < .001 || t > 10.) break;\n\t}\n\n\treturn sat(s);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) { return map(h * n + p).d / h; }\n\nvec3 vig(vec3 c, vec2 fc) {\n\tvec2 q = fc.xy / iResolution.xy;\n\tc *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn c;\n}\n\nfloat fog(vec3 v) { return exp(dot(v, v) * -.002); }\n\nvec3 lights(vec3 p, vec3 rd, float d, Hit h) {\n\tvec3 ld = normalize(vec3(6, 35, -10) - p),\n\t\t n = N(p, d), c;\n\tfloat gg = g, sp = 1.;\n\n\tif (h.id == 2)\n\t\tc = vec3(.2), sp = 3.;\n\telse if (h.id == 1)\n\t\tc = vec3(.03);\n\telse if (h.id == 3)\n\t\tc = vec3(.6);\n\telse c = vec3(.18, .02, .34);\n\n\tfloat ao = mix(ao(p, n, .2), ao(p, n, 2.), .7),\n\n\t// Primary light.\n\tl1 = sat(.1 + .9 * dot(ld, n))\n\t\t * (.3 + .7 * shadow(p, ld)) // ...with shadow.\n\t\t * (.3 + .7 * ao), // ...and _some_ AO.\n\n\t// Secondary(/bounce) light.\n\tl2 = sat(.1 + .9 * dot(ld * vec3(-1, 1, -1), n))\n\n\t// Specular.\n\t\t + pow(sat(dot(rd, reflect(ld, n))), 10.) * sp,\n\n\t// Fresnel\n\tfre = smoothstep(.7, 1., 1. + dot(rd, n)) * .5;\n\n\t// Combine into final color.\n\tg = gg;\n\treturn mix((l1 * vec3(.43, .29, .52) +\n\t\t\t\tl2 * ao * vec3(2.11, 1.69, 1.48)) * c,\n\t\t\t   vec3(.05),\n\t\t\t   fre);\n}\n\nvec4 march(inout vec3 p, vec3 rd, float s, float mx) {\n\tfloat d = .01, i;\n\tg = 0.;\n\tHit h;\n\tfor (i = Z0; i < s; i++) {\n\t\th = map(p);\n\n\t\tif (abs(h.d) < .0015)\n\t\t\tbreak;\n\n\t\td += h.d;\n\t\tif (d > mx)\n\t\t\treturn vec4(0);\n\n\t\tp += h.d * rd; // No hit, so keep marching.\n\t}\n\n\tfloat pulse = mix(1., .3, (sin(T) * .5 + .5) * smoothstep(13., 15., T));\n\treturn vec4(pow(g, pulse) * vec3(.73, .5, .88) + lights(p, rd, d, h), h.id);\n}\n\nvec3 scene(vec3 ro, vec3 rd) {\n\tvec3 p = ro;\n\tvec4 col = march(p, rd, 100., 50.);\n\tcol.rgb *= fog(p - ro);\n\n\tif (col.w > 1.) {\n\t\trd = reflect(rd, N(p, length(p - ro)));\n\t\tp += rd * .01;\n\t\tcol += mix(.2, .3, col.w - 2.)\n\t\t\t   * march(p, rd, 50., 10.)\n\t\t\t   * fog(ro - p);\n\t}\n\n\treturn max(vec3(0), col.rgb);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc)\n{\n\tT = mod(iTime, 30.);\n\n\t// Camera.\n\tvec2 uv = (fc - .5 * iResolution.xy) / iResolution.y;\n\tvec3 lookAt = vec3(0, 2, 0),\n         ro = mix(vec3(1, 2, -4), vec3(0, 3.5, -3), S(T / 4.)),\n         f = normalize(lookAt - ro),\n         r = normalize(cross(vec3(0, 1, 0), f)),\n         rd = normalize(f + r * uv.x + cross(f, r) * uv.y),\n         col = scene(ro, rd);\n\n#ifdef AA\n\tif (fwidth(col.r) > .03) {\n\t\tfor (float dx = Z0; dx <= 1.; dx++)\n\t\t\tfor (float dy = Z0; dy <= 1.; dy++) {\n                vec2 luv = uv + (vec2(dx, dy) - .5) / iResolution.xy;\n\t\t\t\tcol += scene(ro, normalize(f + r * luv.x + cross(f, r) * luv.y));\n            }\n\t\tcol /= 5.;\n\t}\n#endif\n\n\t// Output to screen.\n\tfragColor = vec4(vig(pow(col, vec3(.45)) * sat(iTime), fc), 1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}