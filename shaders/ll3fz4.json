{
    "Shader": {
        "info": {
            "date": "1538758234",
            "description": "...things you people wouldn't believe. Attack ships on fire off the shoulder of Orion. I watched c-beams glitter in the dark near the TannhÃ¤user Gate. All those moments will be lost in time, like tears in rain.\n\nReplicant outpost.\nThis time... no hope.",
            "flags": 96,
            "hasliked": 0,
            "id": "ll3fz4",
            "likes": 117,
            "name": "I've seen...",
            "published": 3,
            "tags": [
                "raytracing",
                "grid",
                "voxel",
                "planet",
                "stars",
                "city",
                "replicant"
            ],
            "usePreview": 1,
            "username": "ocb",
            "viewed": 8586
        },
        "renderpass": [
            {
                "code": "// Author: ocb\n// Title: I've seen... \n\n/***********************************************************************\nEvolution based on Hope shader:  https://www.shadertoy.com/view/MllfDX\nStill playing around with grids, (intersecting - overlaping...) to manage\nlots of objects in order to generate all kind of cities.\nThree intersecting grids generate variable size voxels which contains\ncylinder (pipe), or sphere (little dome) or squared building.\nOne overlaping grid to generate big dome.\n\nUsing Shane's functions (the famous \"Old nVidia tutorial) to create the decrepit\nsurface of the building.\n\nUse mouse to look around\n\nSorry for thr unreadable code.\n************************************************************************/\n\n#define PI 3.141592653589793\n#define PIdiv2 1.57079632679489\n#define TwoPI 6.283185307179586\n#define INFINI 1000000.\n#define MAXSTEP 127\n#define TOP_SURFACE 2.81\n\n/*************  GRID ****************************************************/\n#define A .13\n#define B .41\n#define C .47\n\n#define G2 .02\n#define GS .003\n\n/*************  Object **************************************************/\n#define GND 0\n#define SKY 1\n#define CYL 2\n#define SPH 3\n#define SIDE 4\n#define SPHBIS 5\n\n#define DUST vec3(1.,.9,.7)\n\n\n\n#define moonCtr vec3(.10644925908247,.266123147706175,.958043331742229)\n#define moonShad vec3(-0.435448415412873,0.224265278324226,0.87183126948543)\n#define moonRefl vec3(0.524134547566281, 0.21940212059613, 0.822888622794975)\n\n#define starLight vec3(0.814613079962557,0.203653269990639,-0.543075386641705)\n\nint hitObj = SKY;\nfloat hitScale = 1.;\nbool WINDOW = false;\nbool SIDEWIN = false;\n\nfloat Hsh(in float v) { \t\t\t\t\t\t\n    return fract(sin(v) * 437585.);\n}\n\n\nfloat Hsh2(in vec2 st) { \t\t\t\t\t\t\n    return fract(sin(dot(st,vec2(12.9898,8.233))) * 43758.5453123);\n}\n\n\nfloat sphereImpact(in vec3 pos, in vec3 ray, in vec3 O, in float R, inout vec3 norm ){\n    float d=0., t = INFINI;\n    vec3 a = O - pos;\n    float b = dot(a, ray);\n    \n    if (b >= 0.){\t// check if object in frontside first (not behind screen)\n        float c = dot(a,a) - R*R;\n    \td = b*b - c;\n    \tif (d >= 0.){\n        \tfloat sd = sqrt(d);\n            t = b - sd;\n            norm = normalize(pos + t*ray - O);\n        }\n    }\n    \n    return t;\n}\n\nfloat cylinderImpact(in vec2 pos,in vec2 ray, in vec2 O, in float R, inout vec2 norm){\n    float t=INFINI;\n    vec2 d = pos - O;\n    float a = dot(ray,ray);\n    float b = dot(d, ray);\n    float c = dot(d,d) - R*R;\n    float discr = b*b - a*c;\n    if (discr >= 0.){\n        t = (-b - sqrt(discr))/a;\n        if (t < 0.001) t = (-b + sqrt(discr))/a;\n        if (t < 0.001) t=INFINI;\n\n        norm = normalize(pos + t*ray - O);\n    }\n\treturn t;\n}\n\n\nvec4 voxInfo(in vec2 xz){\n\tvec2 dtp = fract(xz*A)/A;\n    vec2 dtq = fract((xz)*B)/B;\n    vec2 dtr = fract((xz)*C)/C;\n    vec2 dm1 = min(min(dtp,dtq),dtr);\n    \n    dtp = 1./A-dtp;\n    dtq = 1./B-dtq;\n    dtr = 1./C-dtr;\n    vec2 dm2 = min(min(dtp,dtq),dtr);\n\n    vec2 size = dm1+dm2;\n    vec2 ctr = xz+.5*(dm2-dm1);\n    \n    return vec4(ctr,size);\n    \n}\n\nvec4 voxInfoBis(in vec2 xz){\n    vec2 size = vec2(1./G2);\n    vec2 ctr = (floor(xz*G2)+.5)*size;\n    return vec4(ctr,size);\n    \n}\n\nvec4 getNextPlan(in vec2 xz, in vec2 v){\n    vec2 s = sign(v);\n    vec2 d = step(0.,s);\n\tvec2 dtp = (d-fract(xz*A))/A/v;\n    vec2 dtq = (d-fract((xz)*B))/B/v;\n    vec2 dtr = (d-fract((xz)*C))/C/v;\n\n    vec2 dmin = min(min(dtp,dtq),dtr);\n    float tmin = min(dmin.x, dmin.y);\n    \n    s *= -step(dmin,vec2(tmin));\n    \n    return vec4(s.x,0.,s.y,tmin);\n}\n\nvec4 getNextPlanBis(in vec2 xz, in vec2 v){\n    vec2 s = sign(v);\n    vec2 d = step(0.,s);\n\tvec2 dtp = (d-fract(xz*G2))/G2/v;\n    \n    float tmin = min(dtp.x, dtp.y);\n    \n    s *= -step(tmin,vec2(tmin));\n    \n    return vec4(s.x,0.,s.y,tmin);\n}\n\n\nfloat gndFactor(in vec2 p)\t\t// use for cam anti-collision\n{\n\tvec2 f = 1.5-3.*abs(fract(p.xy*G2)-.5);\n    f=smoothstep(.9,1.8,f);\n    return 1.5*(f.x+f.y);   \n}\n\nfloat map(in vec2 xz)\n{   \n    vec2 p = floor(xz*A)/A;\n    vec2 q = floor((xz)*B)/B;\n    vec2 r = floor((xz)*C)/C;\n    \n    vec2 f = 1.5-abs(fract(p*G2)-.5)-abs(fract(q*G2)-.5)-abs(fract(r*G2)-.5);\n    f=smoothstep(.9,1.8,f);\n    float c = 1.5*(f.x+f.y);\n    \n    float Hp = c*Hsh2(p), Hq = c*Hsh2(q), Hr = c*Hsh2(r);\n    float Pp = step(.6,Hp), Pq = step(.6,Hq), Pr = step(.5,Hr);\n    \n    float tex = 1.*Hp*Pp + .5*Hq*Pq +.3*Hr*Pr;\t  \n    hitScale = Pp + 2.5*Pq + 5.*Pr;\n    \n    return tex;\n}\n\n\nvec4 trace(in vec3 pos, in vec3 ray, inout vec4 flam)\n{\n    float dh = 0.;\n    float t = 0.;\n    \n    if(pos.y > TOP_SURFACE){\t// navigating directly to the top surface (perfos)\n        if(ray.y >= 0.) return vec4(vec3(0.),INFINI);\n\t\tt = (TOP_SURFACE - pos.y)/ray.y + 0.00001;\n    }\n    \n    vec4 wall = vec4(0.);\t// wall.xyz is the normal of the wall. wall.w is the t parameter.\n    \n    for(int i = 0;i<MAXSTEP;i++){\t// entering the voxel run\n        \n        vec3 p = pos+t*ray;\n        if(p.y > TOP_SURFACE) break;\t// when \"looking\" up, you may fly out before hiting\n        \t\t\t\t\t\t\t\t// break immediately (perfos)\n        float h = map(p.xz);\n        float dh = p.y - h;\n        if(dh<.0) return vec4(wall.xyz,t-.00002);\t// you are suddenly below the floor?\n        \t\t\t\t\t\t\t\t\t\t\t// you hit the previous wall\n        \n        wall = getNextPlan(p.xz,ray.xz);\t// find the next wall\n        \n        float th = dh/(-ray.y);\t\t\t// find the floor\n        th += step(th,0.)*INFINI;\n        \n        vec4 vox = voxInfo(p.xz);\t\t// get voxel info: center and size\n        float H = Hsh2(floor(100.*vox.xy));\n        \n        vec3 normsph = vec3(0.);\t\t// Little dome\n        float ts = INFINI;\n        if(H<=.6 && t<150.){\n        \tts = sphereImpact(p, ray, vec3(vox.x,h-.5,vox.y), H*min(vox.z,vox.w), normsph );\n        }\n           \n        vec3 normcyl = vec3(0.);\t\t// Pipe\n        float tc = INFINI;\n        if(H<=.1 && t<100.){\n            vec2 c = vox.xy+ (4.*H-.4)*vox.zw;\n            float r = .025*min(vox.z,vox.w);\n            float top = 5.*H*TOP_SURFACE;\n            tc = cylinderImpact(p.xz, ray.xz, c, r, normcyl.xz );\n            tc += step(top,p.y+tc*ray.y)*INFINI;\n            \n            float Hc = (H-.15)*20.;\n        \tfloat ti = iTime*.4;\n            \t\t\t\t\t\t\t// Flam calculation\n        \tif(H>=.05 && Hsh(.0001*(vox.x+vox.y)*floor(Hc+ti))>.9){\n                float fti = fract(Hc+ti);\n                vec2 len = c-pos.xz;\n                float h = length(len)*ray.y/length(ray.xz)+pos.y;\n                float dh = h - top;\n                float d = abs(ray.z*len.x - ray.x*len.y);\n                float mvt = 1.+cos(5.*dh);\n                flam.rgb += min(1.,min(1.,min(vox.z,vox.w))*.2*mvt*(r+dh)/d-.1)\n                       *step(0.,dh)\n                       *((.8-abs(fti-.5))/(dh+.2) -.3 )\n                       *texture(iChannel3,vec2(.2*h-.5*ti+Hc,d*(1.+fti)*dh*mvt+Hc)).rgb;\n                flam*=flam*(2.-fti);\n                flam.w = t;\n            }\n        }\n            \n\n        float tt = min(min(ts,th),tc);\n        tt = min(wall.w,tt);\t\t\t// keep the min between floor and wall distance\n        if(tt==th) return vec4(0.,1.,0.,t+tt);\t// if first hit = floor return hit info (floor)\n        else if(tt==ts){hitObj = SPH; return vec4(normsph,t+tt);}\n        else if(tt==tc){hitObj = CYL; return vec4(normcyl,t+tt);}\n        else tt = wall.w;\t\t// else keep the local t parameter to the next wall\n        \n        t+= tt+.00001;\t\t\t// update global t and do again\n        if(t>250.) break;\t\t// not necessary to go too far (perfos)\n    }\n    \n    \n    return vec4(0.,0.,0.,INFINI);\n}\n\nvec4 traceBis(in vec3 pos, in vec3 ray)\n{\n    float dh = 0.;\n    float t = 0.;\n    \n    if(pos.y > TOP_SURFACE){\t// navigating directly to the top surface (perfos)\n        if(ray.y >= 0.) return vec4(vec3(0.),INFINI);\n\t\tt = (TOP_SURFACE - pos.y)/ray.y + 0.00001;\n    }\n    \n    vec4 wall = vec4(0.);\t// wall.xyz is the normal of the wall. wall.w is the t parameter.\n    \n    for(int i = 0;i<MAXSTEP;i++){\t// entering the voxel run\n        \n        vec3 p = pos+t*ray;\n        if(p.y > TOP_SURFACE) break;\t// when \"looking\" up, you may fly out before hiting\n        \t\t\t\t\t\t\t\t// break immediately (perfos)\n        \n        wall = getNextPlanBis(p.xz,ray.xz);\t// find the next wall\n                \n        vec4 vox = voxInfoBis(p.xz);\n        vec3 normsph;\n        float radius = 25.;//.5*min(vox.z,vox.w);\n        float tt = sphereImpact(p, ray, vec3(vox.x,TOP_SURFACE-radius-1.,vox.y), radius , normsph );\n        \n        if(tt<INFINI) return vec4(normsph,t+tt);\n        else tt = wall.w;\t\t// else keep the local t parameter to the next wall\n        \n        t+= tt+.00001;\t\t\t// update global t and do again\n        if(t>250.) break;\t\t// not necessary to go too far (perfos)\n    }\n    \n    \n    return vec4(0.,0.,0.,INFINI);\n}\n\n\nfloat mapGnd(in vec3 p){return .5*texture(iChannel3, GS*p.xz).r +.2*texture(iChannel3, 2.*GS*p.xz).r;}\n\nvec4 traceGround(in vec3 pos, in vec3 ray)\n{\n\tif(ray.y>0.) return vec4(0.,0.,0.,INFINI);\n\n    float t = (mapGnd(pos) - pos.y)/ray.y;\n        \n    for(int i = 0;i<MAXSTEP;i++){\t\n        \n        vec3 p = pos+t*ray;\n        float dh = p.y-mapGnd(p);\n        \n        if(abs(dh) < .003){\n\t\t\tvec2 e = vec2(-.2,.2);   \n\t\t\tvec3 norm = normalize(e.yxx*mapGnd(p + e.yxx) + e.xxy*mapGnd(p + e.xxy) + \n\t\t\t\t\t         e.xyx*mapGnd(p + e.xyx) + e.yyy*mapGnd(p + e.yyy) );   \n            \n            return vec4(norm,t);\n        }\n        \n        t += dh;\n        \n        if(t>250.) break;\n    }\n    \n    return vec4(0.,0.,0.,INFINI);\n}\n\n\nvec4 boxImpact( in vec3 pos, in vec3 ray, in vec3 ctr, in vec3 dim) \n{\n    vec3 m = 1.0/ray;\n    vec3 n = m*(ctr-pos);\n    vec3 k = abs(m)*dim;\n\t\n    vec3 t1 = n - k;\n    vec3 t2 = n + k;\n\n\tfloat tmax = max( max( t1.x, t1.y ), t1.z );\n\tfloat tmin = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tmax > tmin || tmin < 0.0) return vec4(vec3(0.),INFINI);\n\n    vec3 norm = -sign(ray)*step(t2, vec3(tmin));\n    return vec4(norm, tmin);\n}\n\n\nbool checkWindow(in vec3 ctr){\n    float hash = Hsh2(ctr.xz+ctr.yy);\n    float a = step(.4,hash)*step(mod(ctr.y,10.),0.);\n    float b = step(.7,hash)*step(mod(ctr.y-1.,10.),0.);\n    return bool(a+b);\n}\n\nvec4 traceWindow(in vec3 pos, in vec3 ray, in float t, in vec3 norm){\n    float d, sh, sv;\n    if(hitObj == SPHBIS){d=.03; sh=2.5; sv=1.;}\n    else if(hitObj == SPH){d=.03; sh=.5; sv=.75;}\n    else if(hitObj == CYL){d=.01; sh=.1; sv= 1.;}\n    else {d=.1; sh=1.; sv=1.;}\n    \n    vec3 p = pos + t*ray;\n    vec4 info = vec4(norm,t);\n\n    vec3 boxDim = vec3(sh*.25,sv*.025,sh*.25);\n\tvec3 boxCtr;\n    \n    for(int i=0; i<5; i++){\n    \tboxCtr = vec3(floor(p.x*2./sh),floor(p.y*20./sv),floor(p.z*2./sh));\n        if(checkWindow(boxCtr)){\n            SIDEWIN = true;\n            float tf = t + d/dot(ray,-norm);\n            info = boxImpact(pos, ray, (boxCtr+.5)*vec3(sh*.5,sv*.05,sh*.5), boxDim);\n            if(tf < info.w){\n                WINDOW = true;\n                info = vec4(norm,tf);\n                break;\n            } \n            p = pos + (info.w+.001)*ray;\n        }\n        else break;\n    }\n    return info;\n}\n\nvec3 starGlow(in vec3 ray, in float a){\n    vec3 col = vec3(.001/(1.0001-a));\n    return col;\n}\n\nvec3 moonGlow(in vec3 ray, in float a){\n    float dl = dot(moonRefl,ray);\n    float moon = smoothstep(.9,.93,a);\n    float shad = 1.-smoothstep(.7,.9,dot(moonShad, ray));\n    float refl = .001/(1.0013-dl);\n\tfloat clouds = .5*texture(iChannel3,ray.xy).r+.3*texture(iChannel3,3.*ray.xy).r;\n    vec3 col = .8*(vec3(.5,.3,.0)+clouds*vec3(.3,.4,.1))*moon+vec3(1.,1.,.7)*refl;\n    col += vec3(.3,.5,.8)*smoothstep(.89,.90,a)*(1.-smoothstep(.89,.99,a))*(dl-.9)*15.;\n\tcol *= shad;\n    col -= vec3(.1,.3,.6)*(1.-moon*shad);\n    col = clamp(col,0.,1.);\n    return col;\n}\n\nvec3 stars(in vec3 ray){\n    vec3 col = vec3(0.);\n    float az = atan(.5*ray.z,-.5*ray.x)/PIdiv2;\n    vec2 a = vec2(az,ray.y);\n    \n    float gr = -.5+a.x+a.y;\n    float milky = 1.-smoothstep(0.,1.2,abs(gr));\n\tfloat nebu = 1.-smoothstep(0.,.7,abs(gr));\n\n    vec3 tex = texture(iChannel3,a+.3).rgb;\n    vec3 tex2 = texture(iChannel3,a*.1).rgb;\n\tvec3 tex3 = texture(iChannel3,a*5.).rgb;\n\tfloat dark = 1.-smoothstep(0.,.3*tex.r,abs(gr));\n    \n    vec2 dty =a*12.;\n    col += step(.85,Hsh2(floor(dty)))*(tex+vec3(.0,.1,.1))*max(0.,(.01/length(fract(dty)-.5)-.05));\n    \n    dty =a*30.;\n    col += step(.8,Hsh2(floor(dty)))*tex*max(0.,(.01/length(fract(dty)-.5)-.05))*milky;\n    \n    dty =a*1000.;\n    col += max(0.,Hsh2(floor(dty))-.9)*3.*tex3*milky;\n    \n    col += (.075+.7*smoothstep(.1,1.,(tex+vec3(.15,0.,0.))*.3))*nebu;\n    col += .5*smoothstep(0.,1.,(tex2+vec3(0.,.2,.2))*.2)*milky;\n\tcol -= .15*(tex3 * dark);\n    \n    return col;\n}\n\nvec3 fewStars(in vec3 ray){\n\tvec3 col = vec3(0.);\n    float az = atan(.5*ray.z,-.5*ray.x)/PIdiv2;\n    vec2 a = vec2(az,ray.y);\n    \n    vec3 tex = texture(iChannel3,a+.3).rgb;\n    vec2 dty =a*14.;\n    col += step(.85,Hsh2(floor(dty)))*(tex+vec3(.0,.1,.1))*max(0.,(.01/length(fract(dty)-.5)-.05));\n\n    return col;\n}\n\nbool shadTrace(in vec3 pos, in vec3 v){\n\tfloat dh = 0.;\n    float t = 0.;\n    vec4 wall = vec4(0.);\n    \n    for(int i = 0;i<10;i++){       \n        vec3 p = pos + t*v;\n        if(p.y > TOP_SURFACE) break;\n        \n        float h = map(p.xz);\n        float dh = p.y - h;\n        if(dh<.0) return true;\n        \n        vec4 vox = voxInfo(p.xz);\n        float H = Hsh2(floor(100.*vox.xy));\n        vec3 normsph;\n        float ts = sphereImpact(p, v, vec3(vox.x,h-.5,vox.y), step(H,.6)*H*min(vox.z,vox.w), normsph );\n        if(ts<INFINI) return true;\n        \n        vec3 normcyl = vec3(0.);\n        float tc = cylinderImpact(p.xz, v.xz, vec2(vox.x,vox.y)+ (4.*H-.4)*vox.zw, .025*min(vox.z,vox.w), normcyl.xz );\n        tc += step(step(H,.2)*2.5*H*TOP_SURFACE,p.y+tc*v.y)*INFINI;\n        if(tc<INFINI) return true;\n        \n        wall = getNextPlan(p.xz,v.xz);       \n        t+= wall.w + .0001 ;\n    }   \n    return false;   \n}\n\nbool shadTraceBis(in vec3 pos, in vec3 v){\n\tfloat dh = 0.;\n    float t = 0.;\n    vec4 wall = vec4(0.);\n    \n    for(int i = 0;i<10;i++){       \n        vec3 p = pos + t*v;\n        if(p.y > TOP_SURFACE) break;\n        \n        vec4 vox = voxInfoBis(p.xz);\n        vec3 normsph;\n        float radius = 25.;\n        float ts = sphereImpact(p, v, vec3(vox.x,TOP_SURFACE-radius-1.,vox.y), radius , normsph );\n        if(ts<INFINI) return true;\n        \n        wall = getNextPlanBis(p.xz,v.xz);       \n        t+= wall.w + .0001 ;\n    }   \n    return false;   \n}\n\nfloat shadow(in vec3 p){\n    p += .00001*starLight;\n    if(shadTrace(p,starLight)) return .1;\n    if(shadTraceBis(p,starLight)) return .1;\n    return 1.;\n}\n\nvec3 winGlow(in vec2 uv){\n    uv.x *= .2;\n    uv.y *= .5;\n    vec2 k1 = (uv-.05*sin(uv*10.))*10.,\n         k2 = (uv-.02*sin(uv*25.))*25.,\n         k3 = (uv-.01*sin(uv*50.))*50.;\n    \n    \n    vec2 p = floor(k1)/10.,\n         q = floor(k2)/25.,\n    \t s = floor(k3)/50.;\n    \n    vec2 bp = abs(fract(k1)-.5)\n    \t\t+ abs(fract(k2)-.5)\n    \t\t+ abs(fract(k3)-.5);\n    bp /= 1.5;\n    bp*=bp*bp;\n    \n    vec3 tex = texture(iChannel2,p).rgb\n    \t\t + texture(iChannel2,q).rgb\n    \t\t + texture(iChannel2,s).rgb;\n    \n    tex += .5*(bp.x+bp.y);\n    tex *= smoothstep(1.,2.8,tex.r);\n    \n\treturn tex;\n}\n\n\nfloat metalPlate(in vec2 st){\n    float coef = 0.;\n    \n    vec2 p = floor(st);\n    float hp = Hsh2(p*0.543234); hp *= step(.2,abs(hp-.5));\n    vec2 fp = fract(st)-.5;\n    vec2 sfp = smoothstep(.475,.5,abs(fp));\n    \n    st *= vec2(.5,1.);\n    vec2 q = floor(st*4.-.25);\n    float hq = Hsh2(q*0.890976); hq *= step(.35,abs(hq-.5));\n    vec2 fq = fract(st*4.-.25)-.5;\n    vec2 sfq = smoothstep(.45,.5,abs(fq));\n\t\n    st *= vec2(5.,.1);\n    vec2 r = floor(st*8.-.25);\n    float hr = Hsh2(r*0.123456); hr *= step(.47,abs(hr-.5));\n    vec2 fr = fract(st*8.-.25)-.5;\n    vec2 sfr = smoothstep(.4,.5,abs(fr));\n    \n    float h = max(max(hp,hq),hr);\n    if(bool(h)){\n        vec2 plate =    step(h,hp)*sfp*sign(fp)\n                      + step(h,hq)*sfq*sign(fq) \n                      + step(h,hr)*sfr*sign(fr);\n        \n        coef += .2*h+.8;\n        coef += .5*min(1.,plate.x+plate.y);\n    }\n    else coef = 1.;\n    \n    return coef;\n}\n\n\nfloat flare(in vec3 ref, in vec3 ctr){\n    float c = 0.;\n    vec3 \n\ts = normalize(ref);\n    float sc = dot(s,-starLight);\n    c += .6*smoothstep(.9995,1.,sc);\n    \n    s = normalize(ref+.9*ctr);\n    sc = dot(s,-starLight);\n    c += .7*smoothstep(.99,1.,sc);\n    \n    s = normalize(ref-.7*ctr);\n    sc = dot(s,-starLight);\n    c += .2*smoothstep(.7,1.,sc);\n    \n    return c;\n}\n\nvec3 lensflare3D(in vec3 ray, in vec3 ctr)\n{\n    vec3 red = vec3(1.,.6,.3);\n    vec3 green = vec3(.6,1.,.6);\n    vec3 blue = vec3(.6,.3,.6);\n\tvec3 col = vec3(0.);\n    vec3 ref = reflect(ray,ctr);\n\n    col += red*flare(ref,ctr);\n    col += green*flare(ref-.07*ctr,ctr);\n    col += blue*flare(ref-.14*ctr,ctr);\n    \n    ref = reflect(ctr,ray);\n    col += red*flare(ref,ctr);\n    col += green*flare(ref+.07*ctr,ctr);\n    col += blue*flare(ref+.14*ctr,ctr);\n    \n    float d = dot(ctr,starLight);\n\treturn .4*col*max(0.,d*d*d*d*d);\n}\n\nvec3 lava(in vec2 p){\n\tfloat tex = abs(texture(iChannel3,p*.05).r-.5+.3*sin(iTime*.2));\n    vec3 lav = vec3(0.);\n    lav.r += .5*(1.-smoothstep(.0,.2,tex));\n    lav.rg += (1.-smoothstep(.0,.02,tex));\n\treturn lav;\n}\n\nvec3 getCamPos(in vec3 camTarget){\n    float \trau = 15.,\n            alpha = iMouse.x/iResolution.x*4.*PI,\n            theta = (iMouse.y+.001)/iResolution.y*PI+(PI/2.0001);\t// +0.001 to avoid black horizontal line\n    \t\t\n            // to start shader\n    \t\tif (iMouse.x < 2.){\n                float ts = smoothstep(18.,22.,iTime)*(iTime-20.);\n                alpha = iTime*.04;\n                theta = .3*(1.-cos(iTime*.1));\n            }\n    return rau*vec3(-cos(theta)*sin(alpha),sin(theta),cos(theta)*cos(alpha))+camTarget;\n}\n\nvec3 getRay(in vec2 st, in vec3 pos, in vec3 camTarget){\n    float \tfocal = 1.;\n    vec3 ww = normalize( camTarget - pos);\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0)) ) ;\n    vec3 vv = cross(uu,ww);\n\t// create view ray\n\treturn normalize( st.x*uu + st.y*vv + focal*ww );\n}\n\n// 2 functions from Shane\n// the famous \"Old Nvidia tutorial\"!\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001);\n    n /= (n.x + n.y + n.z );      \n\tvec3 tx = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;   \n    return tx*tx;\n}\n\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf, in float t, in vec3 ray){   \n    //const vec2 e = vec2(0.001, 0);    \n    vec2 e = vec2(.2*t/iResolution.x/dot(-ray,n),0.);    // AA purpose\n    //vec2 e = vec2(.5*t/iResolution.x,0.);\n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; \n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);                      \n    return normalize( n + g*bf );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 st = ( fragCoord.xy\n               // here below, shifting a little even coordinates (H and V).\n               // Do not really manage aliasing, but reduce strongly flickering due to aliasing\n               // Far from a good job, but it is absolutly costless!!\n               // comment the line below to compare\n               -.5*vec2(mod(fragCoord.y,2.),mod(fragCoord.x,2.))\n               - .5*iResolution.xy ) / iResolution.y; \n    \n    // camera def\n    vec3 camTarget = vec3(100.*sin(iTime*.01),1.,-60.*sin(iTime*.015));\n    \n    vec3 pos = getCamPos(camTarget);\n    \n    pos.y = max(pos.y,1.5*gndFactor(pos.xz)+1.001);\t// Cam anti-collision\n    \n    vec3 ray = getRay(st, pos,camTarget);\n    \n    float moonArea = dot(ray,moonCtr);\n    float starArea = dot(ray,starLight);\n    bool starside = bool(step(0.,starArea));\n    bool moonside = bool(step(0.,moonArea));\n\t\n    vec3 color = vec3(.0);\n    vec4 flamInfo = vec4(0.);\n    float t = INFINI;\n    vec3 norm = vec3(0.);\n\n    vec4 info = trace(pos, ray, flamInfo);\n    float sc = hitScale;\n    t = info.w;\n    norm = info.xyz;\n    \n    info = traceBis(pos, ray);\n    if(info.w < t){\n        t=info.w;\n        norm = info.xyz;\n        hitObj = SPHBIS;\n \t\tif(flamInfo.w > t) flamInfo.rgb = vec3(0.);\n    }\n    \n    info = traceGround(pos,ray);\n    if(info.w < t){\n        t=info.w;\n        norm = info.xyz;\n        hitObj = GND;\n    }\n    \n    float shadow = shadow(pos+t*ray);\n    \n    if(t==INFINI){\n        float moonMask = 1.-smoothstep(.925,.93,moonArea);\n        float starMask = 1.-smoothstep(.4,.9,starArea);\n        if(starside) color += .7*starGlow(ray,starArea);\n        if(moonside) color += moonGlow(ray,moonArea);\n        \n        color += fewStars(ray)*moonMask*starMask;\n        color += stars(ray)*moonMask*starMask;\n        color *= min(1.,abs(10.*ray.y*ray.y));\n        color += .006/(ray.y*ray.y+.015)*DUST;\n    }\n    else{\n        if(norm.y < .99 && hitObj != GND) {\n            info = traceWindow(pos ,ray, t, norm);\n            if(bool(info.w)) {\n                norm = info.xyz;\n                t = info.w;\n            }\n        }\n        \n        vec3 p = pos + t*ray;\n\n        if(hitObj == SPH){\n            if(WINDOW){\n                vec2 d = p.xz - voxInfo(p.xz).xy;\n                vec3 window = winGlow(vec2(.5*atan(d.x,d.y),.8*length(d)));\n                vec3 refl = reflect(ray,norm);\n                color += smoothstep(.95,1.,dot(starLight,refl))*norm.z*step(1.,shadow);\n                color += window*min(1., 30./t);\n        \t}\t\n            else{\n                vec2 ang;\n                if(SIDEWIN) ang = p.xz;\n                else ang = vec2(atan(norm.x,norm.z), atan(norm.y,length(norm.xz)));\n                color += texture(iChannel0,ang).rgb;\n                color *= metalPlate(4.*ang);\n                color += .015*vec3(.5*sc,abs(sc-4.),8.-sc) * min(1.,10./t);\n                norm = texBump( iChannel3,.2*norm, norm, .005, t, ray);\n                color *= max(dot(norm, starLight),.0);\n                if(SIDEWIN) color += vec3(.1,.05,.0);\n                else color *= shadow;\n            }\n        }\n        else if(hitObj == CYL){\n            if(WINDOW){\n                vec3 window = winGlow(2.*p.zy);\n                vec3 refl = reflect(ray,norm);\n                color += smoothstep(.95,1.,dot(starLight,refl))*norm.z*step(1.,shadow);\n                color += window*min(1., 30./t);\n        \t}\t\n            else{\n                vec2 ang;\n                if(SIDEWIN) ang = p.xz;\n                else ang = vec2(atan(norm.x,norm.z), 2.*p.y);\n                color += texture(iChannel0,ang).rgb;\n                color *= metalPlate(2.*ang);\n                color += .015*vec3(.5*sc,abs(sc-4.),8.-sc) * min(1.,10./t);\n                color *= max(dot(norm, starLight),.0);\n                if(SIDEWIN) color += vec3(.1,.05,.0);\n                else color *= shadow;\n            }\n        }\n        else if(hitObj == SPHBIS){\n            if(WINDOW){\n                vec2 d = p.xz - voxInfoBis(p.xz).xy;\n                vec3 window = .5*winGlow(vec2(3.*atan(d.x,d.y),.25*length(d)));\n                vec3 refl = reflect(ray,norm);\n                color += smoothstep(.95,1.,dot(starLight,refl))*norm.z*step(1.,shadow);\n                color += window*min(1., 30./t);\n        \t}\t\n            else{\n                vec2 ang;\n                if(SIDEWIN) ang = .5*p.xz;\n                else ang = vec2(atan(norm.x,norm.z), atan(norm.y,length(norm.xz)));\n                color += texture(iChannel0,ang).rgb;\n                color *= metalPlate(4.*ang);\n                sc =1.;\n                color += .015*vec3(.5*sc,abs(sc-4.),8.-sc) * min(1.,10./t);\n                norm = texBump( iChannel3,2.*norm, norm, .002, t, ray);\n                color *= max(dot(norm, starLight),.0);\n                if(SIDEWIN) color += vec3(.1,.05,.0);\n                else color *= shadow;\n\n            }\n        }    \n        else if(hitObj == GND){\n            vec3 dirt = texture(iChannel3,GS*p.xz).rgb;\n            color = 1.5*p.y*dirt*dirt;\n            \n            color *= max(0.,dot(norm, -starLight));\n            color *= shadow;\n            \n            vec2 e = t/iResolution.x/ray.y*ray.xz;\t\t// 2 lines for AA purpose\n            vec3 lavaCol = (lava(p.xz)+lava(p.xz+e)+lava(p.xz-e))/3.;\n            \n\t\t\tcolor += .8*lavaCol*(1.-smoothstep(.0,.1,dirt.r));\n        }\n        else{\n            if(p.y <.01) color = vec3(0.);\n            else{\n                if(WINDOW){\n                    vec3 window = winGlow( (p.xy+p.z)*norm.z + (p.zy+p.x)*norm.x);\n                    vec3 refl = reflect(ray,norm);\n                    color += smoothstep(.95,1.,dot(starLight,refl))*norm.z*step(1.,shadow);\n                    color += window*min(1., 30./t);\n                }\n                else{\n                    vec2 side = .5*vec2(p.x,-p.z)*norm.y + .5*vec2(-p.x,-p.y)*norm.z + .5*vec2(p.y,-p.z)*norm.x;\n                    color += texture(iChannel0,side).rgb;\n                    \n                    vec2 e = vec2(2.*t/iResolution.x/dot(-ray,norm),0.);\t\t// 2 lines for AA purpose\n                    float mp =  ( metalPlate(4.*side)\n                        \t    + metalPlate(4.*side+e)\n                        \t\t+ metalPlate(4.*side-e)\n                        \t\t+ metalPlate(4.*side+e.yx)\n                        \t\t+ metalPlate(4.*side-e.yx)) /5.;\n                    \n                    color *= mp;\n                    color += .015*vec3(.5*sc,abs(sc-4.),8.-sc) * min(1.,10./t);\n\t\t\t\t\t\n                    norm = texBump( iChannel3, .2*p, norm, .003, t, ray);\n\n                    color *= clamp(dot(norm, starLight)+.2,.3,1.);\n                    if(SIDEWIN) color += vec3(.1,.05,.0);\n                    else color *= shadow;\n\n                    vec3 refl = reflect(ray,norm);\n                    color += .3*smoothstep(.9,1.,dot(starLight,refl))*norm.z*step(1.,shadow);;\n                    color = clamp(color,0.,1.);\n                }\n            }\n        }\n        color *= min(1., 20./t); \n        color += min(.003*t,.35)*DUST;\n    }\n    \n    color += flamInfo.rgb*flamInfo.rgb;\n\n    if(starside)\n    \t//if(!shadTrace(pos,starLight))\n    \t\tcolor += lensflare3D(ray, getRay(vec2(0.), pos,camTarget));\n    \n\tfragColor = vec4(1.5*color,1.);\n}\n    \n    ",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 16295,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/analogsweden/the-escape-moment-lost?in=jack-pittorino/sets/blade-runner-1"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}