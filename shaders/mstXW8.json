{
    "Shader": {
        "info": {
            "date": "1679735832",
            "description": "Orbit trapped Julia fractal. Click and drag.",
            "flags": 0,
            "hasliked": 0,
            "id": "mstXW8",
            "likes": 2,
            "name": "Orbit trapped Julia set",
            "published": 3,
            "tags": [
                "juliafractalorbittrap"
            ],
            "usePreview": 0,
            "username": "stla",
            "viewed": 173
        },
        "renderpass": [
            {
                "code": "    float PI = 3.14159265358979323846;\n\n    // map function: x -> map(x, a, b, c, d) sends (a,b) to (b,c)\n    float lerp(float t, float a, float b){\n      return a + t*(b-a);\n    }\n    float norm(float t, float a, float b){\n      return (t-a)/(b-a);\n    }\n    float map(float t, float e1, float s1, float e2, float s2){\n      return lerp(norm(t, e1, s1), e2, s2);\n    }\n\n    // convert hsv coordinates to rgb coordinates\n    vec3 hsv2rgb(vec3 c){\n      vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n      vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n      return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n    }\n\n    // complex product\n    vec2 product(vec2 a, vec2 b){\n      return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n    }\n\n    // trapping function\n    float trap(vec2 z, float alpha) {\n      z = product(vec2(cos(alpha), sin(alpha)), product(z, product(z, z)));\n      return min(abs(z.x), abs(z.y)) / 0.0025;\n    }\n    \n    // trapped Julia\n    vec2 julia(vec2 z, vec2 zc, float alpha) {\n      for(int i = 0; i < 100; i += 1) {\n        z = product(z, z) + zc;\n        if((length(z) > 100.0) || (i >= 2 && trap(z, alpha) < 1.0)) {\n          return z;\n        }\n      }\n      return z;\n    }\n\n    // convert z to hsv coordinates\n    vec3 pair2hsv(vec2 z, float alpha){\n      float h = (atan(z.y, z.x) + PI) / 2.0 / PI;\n      float fz = 2.0 * trap(z, alpha);\n      float s = min(1.0, fz);\n      float v = max(0.0, min(1.0, 2.0 - fz));\n      return vec3(h, s, v);\n    }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n      float alpha = (1.0 + cos(0.1*iTime)) * PI;\n      float mx = map(iMouse.x, 0.0, iResolution.x, -1.5, 1.5); \n      float my = map(iMouse.y, 0.0, iResolution.y, -1.5, 1.5);\n      vec2 zc = vec2(mx, my); // Julia point\n      float r = iResolution.x / iResolution.y * 1.0;\n      float x = map(fragCoord.x, 0.0, iResolution.x, -1.5*r, 1.5*r); \n      float y = map(fragCoord.y, 0.0, iResolution.y, -1.5, 1.5);\n      vec2 z = julia(vec2(x, y), zc, alpha);\n      fragColor = vec4(hsv2rgb(pair2hsv(z, alpha)), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}