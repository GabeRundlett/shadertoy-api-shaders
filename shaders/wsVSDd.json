{
    "Shader": {
        "info": {
            "date": "1575417421",
            "description": "because volumetrics are fun\n\nclick and move your mouse to change the view angle",
            "flags": 32,
            "hasliked": 0,
            "id": "wsVSDd",
            "likes": 66,
            "name": "Volumetric path tracing",
            "published": 3,
            "tags": [
                "fractal",
                "volume",
                "cloud",
                "mandelbulb",
                "volumetric",
                "pathtracing",
                "tracing",
                "path"
            ],
            "usePreview": 1,
            "username": "loicvdb",
            "viewed": 2288
        },
        "renderpass": [
            {
                "code": "vec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 bloom(float scale, float threshold, vec2 fragCoord){\n    float logScale = log2(scale)+1.0;\n    \n    vec3 bloom = vec3(0);\n    for(int y = -1; y <= 1; y++)\n        for(int x = -1; x <= 1; x++)\n            bloom += textureLod(iChannel0, (fragCoord+vec2(x, y) * scale)/iResolution.xy, logScale).rgb;\n    \n    return max(bloom/9.0 - vec3(threshold), vec3(0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    \n    vec3 bloomSum = bloom(.25 * iResolution.y, .4, fragCoord) * .3\n        \t\t  + bloom(.1 * iResolution.y, .7, fragCoord) * .3;\n    \n    fragColor = vec4(ACESFilm(col + bloomSum), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define Pi 3.14159265359\n\n#define VolumePrecision .3\n#define SceneRadius 1.2\n#define ShadowRaysPerStep .2\n#define MaxSteps 100\n#define MaxAbso .8\n#define MaxShadowAbso .6\n\nvec3 CamPos = vec3(0, 0, -2.5);\nvec3 CamRot = vec3(.7, -2.4, .0);\nfloat CamFocalLength = 3.2;\nfloat CamFocalDistance = 2.3;\nfloat CamAperture = .02;\n\nvec3 LightColor = vec3(1.7);\nvec3 LightDir = normalize(vec3(-1, -.2, 0));\n\nfloat Power = 8.0;\nfloat PhiShift = 0.0;\nfloat ThetaShift = 0.0;\n\nfloat Density = 200.0;\n\nfloat StepSize;\n\nvec3 VolumeColor = vec3(.9, .9, .95);\n\nvec2 seed;\n\nfloat rand(vec2 n) {\n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat randomFloat(){\n  seed += vec2(1.153535, -1.1231354);\n  return rand(seed);\n}\n\nmat3 rotationMatrix(vec3 rotEuler){\n    float c = cos(rotEuler.x), s = sin(rotEuler.x);\n    mat3 rx = mat3(1, 0, 0, 0, c, -s, 0, s, c);\n    c = cos(rotEuler.y), s = sin(rotEuler.y);\n    mat3 ry = mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n    c = cos(rotEuler.z), s = sin(rotEuler.z);\n    mat3 rz = mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n    \n    return rz * rx * ry;\n}\n\nfloat maxV(vec3 v){\n    return v.x > v.y ? v.x > v.z ? v.x : v.z : v.y > v.z ? v.y : v.z;\n}\n\nvec3 backgroundColor(vec3 dir){\n    vec3 col = texture(iChannel1, dir).rgb;\n    return col*col + col;\n}\n\nvec3 randomDir(){\n    return vec3(1, 0, 0) * rotationMatrix(vec3(randomFloat()*2.0*Pi, 0, randomFloat()*2.0*Pi));\n}\n\nfloat distanceEstimation(vec3 pos) {\n    \n    pos.y = -pos.y;\n    \n    float r = length(pos);\n    vec3 z = pos;\n    vec3 c = pos;\n\tfloat dr = 1.0, theta, phi;\n\tfor (int i = 0; i < 6; i++) {\n\t\tr = length(z);\n\t\tif (r>SceneRadius) break;\n\t\ttheta = acos(z.y/r);\n\t\tphi = atan(z.z,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\ttheta *= Power + ThetaShift;\n\t\tphi *= Power + PhiShift;\n\t\tz = pow(r,Power)*vec3(sin(theta)*cos(phi), cos(theta), sin(phi)*sin(theta)) + c;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\nvec3 directLight(vec3 pos){\n    \n    vec3 absorption = vec3(1.0);\n    \n    for(int i = 0; i < MaxSteps; i++){\n        float dist = distanceEstimation(pos);\n        pos -= LightDir * max(dist, StepSize);\n        if(dist < StepSize) {\n            float abStep = StepSize * randomFloat();\n            pos -= LightDir * (abStep-StepSize);\n            if(dist < 0.0){\n                float absorbance = exp(-Density*abStep);\n                absorption *= absorbance;\n                if(maxV(absorption) < 1.0-MaxShadowAbso) break;\n            }\n        }\n        \n        if(length(pos) > SceneRadius) break;\n    }\n    return LightColor * max((absorption+MaxShadowAbso-1.0) / MaxShadowAbso, vec3(0));\n}\n\nvec3 pathTrace(vec3 rayPos, vec3 rayDir){\n    \n   \trayPos += rayDir * max(length(rayPos)-SceneRadius, 0.0);\n    \n    vec3 outColor = vec3(0.0);\n    vec3 absorption = vec3(1.0);\n    \n    for(int i = 0; i < MaxSteps; i++){\n        float dist = distanceEstimation(rayPos);\n        rayPos += rayDir * max(dist, StepSize);\n        if(dist < StepSize && length(rayPos) < SceneRadius) {\n            float abStep = StepSize * randomFloat();\n            rayPos += rayDir * (abStep-StepSize);\n            if(dist < 0.0){\n                \n                float absorbance = exp(-Density*abStep);\n                float transmittance = 1.0-absorbance;\n                \n                //surface glow for a nice additional effect\n                //if(dist > -.0001) outColor += absorption * vec3(.2, .2, .2);\n                \n                if(randomFloat() < ShadowRaysPerStep) outColor += 1.0/ShadowRaysPerStep * absorption * transmittance * VolumeColor * directLight(rayPos);\n                if(maxV(absorption) < 1.0-MaxAbso) break;\n                if(randomFloat() > absorbance) {\n                    rayDir = randomDir();\n                    absorption *= VolumeColor;\n                }\n            }\n        }\n        \n        if(length(rayPos) > SceneRadius && dot(rayDir, rayPos) > 0.0)\n            return outColor + backgroundColor(rayDir) * absorption;\n    }\n    \n    return outColor;\n}\n\n//n-blade aperture\nvec2 sampleAperture(int nbBlades, float rotation){\n    \n    float alpha = 2.0*Pi / float(nbBlades);\n    float side = sin(alpha/2.0);\n    \n    int blade = int(randomFloat() * float(nbBlades));\n    \n    vec2 tri = vec2(randomFloat(), -randomFloat());\n    if(tri.x+tri.y > 0.0) tri = vec2(tri.x-1.0, -1.0-tri.y);\n    tri.x *= side;\n    tri.y *= sqrt(1.0-side*side);\n    \n    float angle = rotation + float(blade)/float(nbBlades) * 2.0 * Pi;\n    \n    return vec2(tri.x * cos(angle) + tri.y * sin(angle),\n                tri.y * cos(angle) - tri.x * sin(angle));\n}\n\n//used to store values in the unused alpha channel of the buffer\nvoid setVector(int index, vec4 v, vec2 fragCoord, inout vec4 fragColor){\n    fragCoord -= vec2(.5);\n    if(fragCoord.y == float(index)){\n        if(fragCoord.x == 0.0) fragColor.a = v.x;\n        if(fragCoord.x == 1.0) fragColor.a = v.y;\n        if(fragCoord.x == 2.0) fragColor.a = v.z;\n        if(fragCoord.x == 3.0) fragColor.a = v.a;\n    }\n}\n\nvec4 getVector(int index){\n    return vec4(texelFetch(iChannel0, ivec2(0, index), 0).a,\n                texelFetch(iChannel0, ivec2(1, index), 0).a,\n                texelFetch(iChannel0, ivec2(2, index), 0).a,\n                texelFetch(iChannel0, ivec2(3, index), 0).a\n               );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    StepSize = min(1.0/(VolumePrecision*Density), SceneRadius/2.0);\n    \n    vec2 uv = (fragCoord+vec2(randomFloat(), randomFloat())-iResolution.xy/2.0) / iResolution.y;\n    \n    seed = fragCoord/iResolution.xy * 1000.0 + log(vec2(iFrame));\n    \n    float samples = texelFetch(iChannel0, ivec2(0, 0), 0).a;\n    if(iFrame > 0) CamRot = getVector(1).xyz;\n    vec4 prevMouse = getVector(2);\n    \n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    bool mouseDragged = iMouse.z >= 0.0 && prevMouse.z >= 0.0 && iMouse != prevMouse;\n    \n    if(mouseDragged) CamRot.yx += (prevMouse.xy-iMouse.xy)/iResolution.y * 2.0;\n    \n    if(iFrame == 0 || mouseDragged){\n        fragColor = vec4(0.0);\n        samples = 0.0;\n    }\n    \n    setVector(1, vec4(CamRot, 0), fragCoord, fragColor);\n    setVector(2, iMouse, fragCoord, fragColor);\n    if(fragCoord-vec2(.5) == vec2(0)) fragColor.a = samples+1.0;\n    \n    vec3 focalPoint = vec3(uv * CamFocalDistance / CamFocalLength, CamFocalDistance);\n    vec3 aperture = CamAperture * vec3(sampleAperture(6, 0.0), 0.0);\n    vec3 rayDir = normalize(focalPoint-aperture);\n    \n    mat3 CamMatrix = rotationMatrix(CamRot);\n\n    CamPos *= CamMatrix;\n    rayDir *= CamMatrix;\n    aperture *= CamMatrix;\n    \n    fragColor.rgb = mix(fragColor.rgb,pathTrace(vec3(0, .8, 0) + CamPos+aperture,rayDir),1.0/(samples+1.0));\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}