{
    "Shader": {
        "info": {
            "date": "1543947063",
            "description": "A first attempt of 3d modeling.",
            "flags": 64,
            "hasliked": 0,
            "id": "XtKBzc",
            "likes": 19,
            "name": "Car and Night",
            "published": 3,
            "tags": [
                "raymarching",
                "modeling",
                "road",
                "car",
                "concept"
            ],
            "usePreview": 0,
            "username": "josemorval",
            "viewed": 1089
        },
        "renderpass": [
            {
                "code": "\n\nvec2 scene(vec3 p){\n    vec2 res = vec2(100.0,0.);\n    float shape;\n    vec3 q;\n    \n    \n    float angle = 0.005*sin(20.*iTime+20.)+\n        \t\t  0.2*sin(1.*iTime+0.5)+\n                  0.3*sin(0.5*iTime);\n    \t\t\t  0.5*sin(-0.25*iTime);\n    \n    \n    \n    q = p +vec3(0.,-1.,-2.);\n    q.yx = mat2(cos(angle),sin(angle),-sin(angle),cos(angle))*q.yx;\n    \n    shape = smin(10.,sdTorus(q.yzx+vec3(0.,0.,0.),vec2(2.,0.2)),0.);\n    \n    \n    shape = smin(shape, sdCappedCylinder(q+vec3(0.,-0.12,0.),vec2(0.15,2.)),0.2);\n    shape = smin(shape, sdCappedCylinder(q+vec3(0.,0.12,0.),vec2(0.15,2.)),0.2);\n    \n    shape = smin(shape, sdCappedCylinder(q.yzx+vec3(1.,0.,0.),vec2(0.15,1.)),0.2);\n    shape = smin(shape, sdSphere(q*vec3(1.,1.,2.)+vec3(0.,0.5,0.),0.5),1.);\n    \n    shape += 0.005*sin(60.*q.x)*sin(60.*q.y)*sin(60.*q.z);\n    //Adorno\n    shape =min(shape, sdCappedCylinder(q.zxy+vec3(-0.27,0.,0.3),vec2(0.3,0.075))-0.03);\n    \n    if(shape<res.x) res = vec2(shape,3.);\n    \n    //Panel velocimetro\n    q = p+vec3(0.,-1.,-1.);\n   \tshape = sdCappedCylinder(q.zyx+vec3(0.,0.5,0.),vec2(2.5,0.5+1.));\n    shape = smax(shape,-sdCappedCylinder(q.zyx+vec3(0.,10.,0.),vec2(10.,1.+1.)),0.1);\n    shape = smax(shape,-sdSphere(q+vec3(3.8,0.6,0.),2.),0.05);\n    shape = smax(shape,-sdSphere(q+vec3(-3.8,0.6,0.),2.),0.05);\n    \n    shape = abs(shape)-0.1;\n    shape = max(q.z-0.,shape);\n    \n    \n    shape = max(shape,-sdBox(q+vec3(0.,-1.,1.3),vec3(0.3,0.5,0.1))+0.05);\n    shape = max(shape,-sdCappedCylinder(q.zyx+vec3(1.3,-0.8,1.1),vec2(0.6,0.1))+0.05);\n    shape = max(shape,-sdCappedCylinder(q.zyx+vec3(1.3,-0.8,-1.1),vec2(0.6,0.1))+0.05);\n    \n    shape = min(shape,sdCappedCylinder(q.zyx+vec3(1.5,-0.8,-1.1),vec2(0.075,0.1)));\n    shape = min(shape,sdCappedCylinder(q.zyx+vec3(1.5,-0.8,1.1),vec2(0.075,0.1)));\n\t\n    \n    if(shape<res.x) res = vec2(shape,3.);\n    \n\n    float indexx = step(0.,q.x);\n    q.x = sign(q.x)*(abs(q.x)-1.1);\n    \n    q.yz += vec2(-0.8,1.4);\n    angle = (-0.5-0.5*indexx)+(0.01+0.03*indexx)*sin(10.*iTime+2.*indexx);\n    \n    q.xy = mat2(cos(angle),sin(angle),-sin(angle),cos(angle))*q.xy;\n   \tshape = sdBox(q+vec3(-0.3,0.,0.),vec3(0.3,(0.02-0.02*q.x)*vec2(1.,1.)));\n    \n    if(shape<res.x) res = vec2(shape,5);\n        \n    return res;\n}\n\nvec2 raycast(vec3 p, vec3 d){\n \n    vec2 res = vec2(0.,-1.);\n    \n    float tmin = 0.1;\n    float tmax = 30.;\n    const int steps = 64;\n    \n    res.x = tmin;\n    \n    for(int i=0;i<steps;i++){\n        \n        vec2 f = scene(p+res.x*d);\n        if(f.x<0.0001*res.x || res.x>tmax) break;\n        res.x+=f.x;\n        res.y=f.y;\n    }\n    \n    if(res.x>tmax) res.y=-1.;\n    return res;\n    \n}\n\n\nvec3 calcNormal(vec3 p)\n{\n\t\n    float ep = 0.01;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize(e.xyy*scene(p+e.xyy*ep).x + \n\t\t\t\t\t e.yyx*scene(p+e.yyx*ep).x + \n\t\t\t\t\t e.yxy*scene(p+e.yxy*ep).x + \n\t\t\t\t\t e.xxx*scene(p+e.xxx*ep).x );\n    \n}\n\nfloat calcAO(vec3 pos,vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<4; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = scene( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.99;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\nvec3 color(vec3 p, vec3 d, vec2 res){\n    \n    vec3 lightdir1 = vec3(10.,1.,30.*(mod(0.5*iTime,1.)-0.5));\n    lightdir1 = normalize(lightdir1);\n    \n    vec3 lightdir2 = vec3(-10.,1,30.*(mod(0.5*iTime+0.5,1.)-0.5));\n    lightdir2 = normalize(lightdir2);\n             \n\tvec3 c = vec3(0.);\n    \n    p+=res.x*d;\n    \n    vec3 n = calcNormal(p);\n    float shadow1 = raycast(p+0.001*lightdir1,lightdir1).y>1.?0.:1.;\n   \tfloat shadow2 = raycast(p+0.001*lightdir2,lightdir2).y>1.?0.:1.;\n  \n    if(res.y>0.){\n        \n        if(res.y<4.){\n\t\t\t  \n            float r = clamp(dot(normalize(vec3(0.,3.,0.)-p),n),0.,1.);\n           \tc = 1.5*r*calcAO(p,n)*vec3(0.1,0.1,0.2)+\n                0.3*r*vec3(0.1,0.1,0.5)*min(shadow1,shadow2);\n\n            vec2 q = p.xy+vec2(0.,-1.8);\n            q.x = abs(q.x)-1.1;\n            float angle = atan(q.y,q.x);\n            angle =smoothstep(0.6,1.,sin(20.*(angle+0.1)));\n            angle *= (1.-step(0.,abs(length(q)-0.55)-0.05))*(1.-step(-0.25,p.z));\n            c+= angle*vec3(0.8,0.8,1.)*step(0.,abs(atan(q.y,q.x)+3.14159/2.)-0.5);\n            \n            angle = atan(q.y,q.x);\n            angle =smoothstep(0.8,1.,sin(40.*(angle+0.2)));\n            angle *= (1.-step(0.,abs(length(q)-0.55)-0.025))*(1.-step(-0.25,p.z));\n            c+= angle*vec3(0.8,0.8,1.)*step(0.,abs(atan(q.y,q.x)+3.14159/2.)-0.5);\n            \n            \n            c+= 0.1*vec3(1.,0.5,1.)*(1.-smoothstep(0.,1.,length(q)))*(1.-step(-0.25,p.z));\n            float mask = (1.-step(-0.25,p.z))*(1.-smoothstep(0.,0.2,abs(p.y-2.)-0.5))*(1.-smoothstep(0.,0.2,abs(p.x)-0.3));\n           \t\n           \tc+=0.2*mix(vec3(1.,0.2,0.),2.*vec3(1.,0.2,0.),mask)*mask;\n            \n            c+= (1.-0.1*fract(sin(12.*iTime)))*vec3(1.,0.2,0.)*(1.-smoothstep(0.,1.2,p.z))*step(-0.5,p.z)*(1.-smoothstep(0.,0.6,abs(p.x)))*(1.-smoothstep(0.,0.2,abs(p.y-1.)));\n        \n            c+=(0.1-0.05*sin(iTime))*vec3(1.,0.5,0.25)*smoothstep(0.,1.,dot(n,lightdir1))*shadow1;\n            c+=(0.1-0.05*sin(iTime))*vec3(0.,0.5,1.)*smoothstep(0.,1.,dot(n,lightdir2))*shadow2;\n              \n        }else if(res.y<6.){\n         \t \n            c = vec3(1.,0.3,0.3);\n            \n        }\n\n    }\n\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv;\n    p-=0.5;\n    p.x*=iResolution.x/iResolution.y;\n    \n    //-------Camera setup-----------//\n    \n    float angle = 3.1415/2.+0.25*sin(0.3*iTime)-0.3;\n    vec3 po = vec3(cos(angle),4.+1.*sin(0.7*iTime),sin(angle));\n    po.xz*=11.+0.3*sin(0.8*iTime);\n    vec3 ta = vec3(0.,1.5+0.,0.);\n    \n    vec3 dir = normalize(ta-po);\n    vec3 up = vec3(0.,1.,0.);\n    vec3 right = cross(dir,up);\n    up = cross(right,dir);\n    \n    vec3 pos = po + p.x*right + p.y*up;\n    \n    float fov = 2.;\n    dir = normalize(pos-(po-fov*dir));\n    \n    //-------------------------------//\n    \n    vec2 res = raycast(pos,dir);\n    vec3 col = color(pos,dir,res);\n    \n\n    fragColor = vec4(col,1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 16930,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/tstvs/rain-on-car"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//From awesome iq's articles and shaders\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.yz),p.x)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere(vec3 p,float r )\n{\n    return length(p) - r;\n}\n\nfloat sdEllipsoid(vec3 p,vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat sdEllipsoid(vec2 p,vec2 r )\n{\n    return (length( p/r ) - 1.0) * min(r.x,r.y);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nvec2 udSegment( vec3 p, vec3 a, vec3 b )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nvec3 getClosest( vec2 b0, vec2 b1, vec2 b2 ) \n{\n    float a =     det(b0,b2);\n    float b = 2.0*det(b1,b0);\n    float d = 2.0*det(b2,b1);\n    float f = b*d - a*a;\n    vec2  d21 = b2-b1;\n    vec2  d10 = b1-b0;\n    vec2  d20 = b2-b0;\n    vec2  gf = 2.0*(b*d21+d*d10+a*d20); gf = vec2(gf.y,-gf.x);\n    vec2  pp = -f*gf/dot(gf,gf);\n    vec2  d0p = b0-pp;\n    float ap = det(d0p,d20);\n    float bp = 2.0*det(d10,d0p);\n    float t = clamp( (ap+bp)/(2.0*a+b+d), 0.0 ,1.0 );\n    return vec3( mix(mix(b0,b1,t), mix(b1,b2,t),t), t );\n}\n\nvec4 sdBezier( vec3 a, vec3 b, vec3 c, vec3 p )\n{\n\tvec3 w = normalize( cross( c-b, a-b ) );\n\tvec3 u = normalize( c-b );\n\tvec3 v =          ( cross( w, u ) );\n\n\tvec2 a2 = vec2( dot(a-b,u), dot(a-b,v) );\n\tvec2 b2 = vec2( 0.0 );\n\tvec2 c2 = vec2( dot(c-b,u), dot(c-b,v) );\n\tvec3 p3 = vec3( dot(p-b,u), dot(p-b,v), dot(p-b,w) );\n\n\tvec3 cp = getClosest( a2-p3.xy, b2-p3.xy, c2-p3.xy );\n\n\treturn vec4( sqrt(dot(cp.xy,cp.xy)+p3.z*p3.z), cp.z, length(cp.xy), p3.z );\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 smin( vec2 a, vec2 b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b.x-a.x)/k, 0.0, 1.0 );\n\treturn vec2( mix( b.x, a.x, h ) - k*h*(1.0-h), mix( b.y, a.y, h ) );\n}\nvec4 smin( vec4 a, vec4 b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b.x-a.x)/k, 0.0, 1.0 );\n\treturn vec4( mix( b.x, a.x, h ) - k*h*(1.0-h), mix( b.yzw, a.yzw, h ) );\n}\n\nfloat smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\nvec3 smax( vec3 a, vec3 b, float k )\n{\n\tvec3 h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\nvec2 opUnion(vec2 a, vec2 b){\n    if(a.x<b.x){\n    \treturn a;   \n    }else{\n     \treturn b;   \n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}