{
    "Shader": {
        "info": {
            "date": "1706082743",
            "description": "Anyone got tips for fixing fwidth along the edges? I've tried capping it and also @iq's ray differentials technique although I wasn't sure how to use it properly for this.",
            "flags": 0,
            "hasliked": 0,
            "id": "XfSXzD",
            "likes": 14,
            "name": "Radius of Convergence",
            "published": 3,
            "tags": [
                "math",
                "graph",
                "equation",
                "convergence",
                "visual",
                "radius",
                "taylorseries"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 184
        },
        "renderpass": [
            {
                "code": "// Cool graphic from https://en.wikipedia.org/wiki/Radius_of_convergence\n\nfloat map(in vec3 p) {\n    // Re(1/(1+(x+zi)^2))\n    vec3 grad;\n    float a = 1.0 + p.x * p.x - p.z * p.z;\n    float b = 2.0 * p.x * p.z;\n    grad.x = 4.0 * (b * p.z + a * p.x) * p.y - 2.0 * p.x;\n    grad.y = a * a + b * b;\n    grad.z = 4.0 * (b * p.x - a * p.z) * p.y + 2.0 * p.z;\n    return (grad.y * p.y - a) / length(grad);\n}\n\nvec3 getNormal(in vec3 p, in float d0) {\n    vec2 eps = vec2(0.001, 0.0);\n    return normalize(vec3(\n        map(p + eps.xyy),\n        map(p + eps.yxy),\n        map(p + eps.yyx)\n    ) - d0);\n}\n\nfloat realTaylor(in float x) {\n    x *= x;\n    return 1.0 - (1.0 - (1.0 - (1.0 - x) * x) * x) * x;\n}\n\nfloat imagTaylor(in float x) {\n    x *= x;\n    return 1.0 + (1.0 + (1.0 + (1.0 + x) * x) * x) * x;\n}\n\n#define paint(sdf, unit, color) fragColor.rgb = mix(fragColor.rgb, color.rgb, smoothstep(unit, 0.0, sdf) * color.a)\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0);\n\n    vec3 ro = vec3(-3.0, 2.0, 3.0);\n    float rot = 0.25 * iTime;\n    float co = cos(rot), si = sin(rot);\n    ro.xz *= mat2(co, si, -si, co);\n\n    vec3 fd = normalize(vec3(0.0, 0.5, 0.0) - ro);\n    vec3 rt = normalize(vec3(-fd.z, 0.0, fd.x));\n    vec3 up = cross(rt, fd);\n    vec3 rd = mat3(rt, up, fd) * normalize(vec3(uv, 1.0));\n\n    // Raymarch surface\n    float t = 0.0;\n    vec3 p; float d;\n    bool hit = false;\n    for (int i = 0; i < 300; i++) {\n        p = ro + rd * t;\n        d = map(p);\n        if (abs(d) < 0.001) { hit = true; break; }\n        if (t > 25.0) break;\n        t += d;\n    }\n\n    if (hit) {\n        // Draw surface\n        vec3 nor = getNormal(p, d);\n        vec2 z = vec2(1.0 + p.x * p.x - p.z * p.z, 2.0 * p.x * p.z);\n        vec2 w = vec2(z.x, -z.y) / dot(z, z); // 1/(1+(x+zi)^2)\n        float u = 0.5 + 0.5 * tanh(length(w));\n        fragColor.rgb = vec3(1.0, mix(1.0, 0.3, u), 0.0);\n\n        // Draw grid lines\n        float sp = 0.5, hsp = 0.5 * sp;\n        vec4 gcol = vec4(vec3(0.0), 0.5);\n        paint(abs(mod(p.x + hsp, sp) - hsp), 1.5 * fwidth(p.x), gcol);\n        paint(abs(mod(p.y + hsp, sp) - hsp), 1.5 * fwidth(p.y), gcol);\n        paint(abs(mod(p.z + hsp, sp) - hsp), 1.5 * fwidth(p.z), gcol);\n    }\n\n    // Draw radius of convergence\n    float tRingPlane = (0.5 - ro.y) / rd.y;\n    vec3 pRingPlane = ro + rd * tRingPlane;\n    float ring = length(pRingPlane.xz) - 1.0;\n    float fwRing = fwidth(ring);\n    if (tRingPlane > 0.0 && tRingPlane - 0.05 < t) {\n        paint(abs(ring), 1.5 * fwRing, vec4(1.0));\n    }\n\n    // Draw taylor series along real axis\n    float tRealPlane = -ro.z / rd.z;\n    vec3 pRealPlane = ro + rd * tRealPlane;\n    float dRealTaylor = pRealPlane.y - realTaylor(pRealPlane.x);\n    float fwRealTaylor = fwidth(dRealTaylor);\n    if (tRealPlane > 0.0 && tRealPlane - 0.05 < t) {\n        paint(abs(dRealTaylor), 1.5 * fwRealTaylor, vec4(0.0, 0.0, 1.0, 1.0));\n    }\n\n    // Draw taylor series along imaginary axis\n    float tImagPlane = -ro.x / rd.x;\n    vec3 pImagPlane = ro + rd * tImagPlane;\n    float dImagTaylor = pImagPlane.y - imagTaylor(pImagPlane.z);\n    float fwImagTaylor = fwidth(dImagTaylor);\n    if (tImagPlane > 0.0 && tImagPlane - 0.05 < t) {\n        paint(abs(dImagTaylor), 1.5 * fwImagTaylor, vec4(0.0, 0.0, 1.0, 1.0));\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}