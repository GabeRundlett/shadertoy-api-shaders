{
    "Shader": {
        "info": {
            "date": "1676825824",
            "description": "Test of sea  transparency",
            "flags": 0,
            "hasliked": 0,
            "id": "ctjXDt",
            "likes": 9,
            "name": "Mediterran reef and waves",
            "published": 3,
            "tags": [
                "wave",
                "sea",
                "reef"
            ],
            "usePreview": 0,
            "username": "guil",
            "viewed": 209
        },
        "renderpass": [
            {
                "code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S.Guillitte \n\n#define time -iTime\n\n                                 \nmat2 m2 = mat2(0.8,  0.6, -0.6,  0.8);\n\n\n\n\n//reef/waves combined field\nvec3 map(in vec3 p) {\n\t\n\tfloat s=2.,e,f,o;\n    vec3 q=p,r=p;\n    vec3 n = vec3(0);\n\tvec2 l = vec2(2.);\n\tfor(e=f=p.y;s<1e2;s*=1.3)\n            p.xz*=m2,\n            n.xy*=m2,\n            q=p*s+n,\n            r=p*s+n,\n            r.x+=iTime*2.,\n            e+=.35*abs(dot(sin(r.xz*.1)/s,.8*l)),\n            f+=.2+.3*(dot(sin(q.xz*.5)/s,l)),\n            n-=cos(q);\n\te+=1.4;\n    return vec3(min(e,f),f,e);\n}\n\nvec3 normalRocks(in vec3 p)\n{\n\tconst vec2 e = vec2(0.004, 0.0);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy).y - map(p - e.xyy).y,\n        .008,\n\t\tmap(p + e.yyx).y - map(p - e.yyx).y\n\t\t));\n}\n\nvec3 normalSea(in vec3 p)\n{\n\tconst vec2 e = vec2(0.005, 0.0);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy).z - map(p - e.xyy).z,\n        .008,\n\t\tmap(p + e.yyx).z - map(p - e.yyx).z\n\t\t));\n}\n\n\nvec3 sky(in vec2 p)\n{\t\n    vec3 q =vec3(p.x,1.,p.y);\n    return sin(vec3(1.7,1.5,1)- 2.-map(q*11.).y*.25);\n}\n\nvec3 march(in vec3 ro, in vec3 rd)\n{\n\tconst float maxd = 45.0;\n\tconst float precis = 0.001;\n    float h = 0.0;\n    float t = 0.0;\n    float dt = .2;\n\tfloat res = -1.0;\n    for(int i = 0; i < 128; i++)\n    {\n        if(h < precis*t || t > maxd) break;\n\t    h = map(ro + rd * t).x;\n        t += h*dt;\n        dt *= 1.015;\n    }\n    if(t < maxd) res = t;\n    return vec3(res,map(ro + rd * t).yz);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 col = vec3(0.);\n   \tvec3 rd = normalize(vec3(p, -2.));\n\tvec3 ro = vec3(0.0, .5, -2.+.2*time);\n    vec3 li = normalize(vec3(-4., 4., -2.));   \n    \n    vec3 v = march(ro, rd);\n    float t = v.x;\n    float dh = v.z-v.y;\n    if(t > 0.)\n    {\n        \n        vec3 pos = ro + t * rd;       \n        float k=map(pos).z*1.+1.3;       \n        vec3 nor = normalRocks(pos);\n        float r = max(dot(nor, li),0.1)/2.;\n        col =vec3(r*k*k, r*k, r*.8)+.5*exp(-50.*dh*dh);\n        if(dh<0.0){\n        \tvec3 nor = normalSea(pos+dh*rd);\n        \tnor = reflect(rd, nor);\n            col +=vec3(0.9,.2,.05)*dh*.7;\n        \tcol += pow(max(dot(li, nor), 0.0), 5.0)*vec3(.7);\n        \tcol +=.3* sky(nor.xz);\n            \n        }\n\t    col = .1+col;\n        \n\t}\n    else //sky\n        col = sky(rd.xz*(.2+rd.y));\n    \n   \tfragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}