{
    "Shader": {
        "info": {
            "date": "1639151957",
            "description": "Shader inspired by 'Innerspace (1989)' staring Dennis Quaid and Meg Ryan.",
            "flags": 1,
            "hasliked": 0,
            "id": "sltXW4",
            "likes": 35,
            "name": "Innerspace",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "blood",
                "movie",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "dean_the_coder",
            "viewed": 5000
        },
        "renderpass": [
            {
                "code": "// 'Innserspace' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/sltXW4 (YouTube: https://youtu.be/TonMoR0KI_E)\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// Another 80s film I grew up loving, so I thought it would be a\n// good challenge to make a shader from it.\n//\n// Things to note:\n//   - I only add three blood cells into the tunnel, and use\n//     domain repetition to clone them for (nearly) free.\n//   - Lots of axis symmetry in the 'pod' to reduce complexity.\n//   - As only the cockpit glass is transparent, it is rendered\n//     separately (using ray/sphere intersection).\n//   - Re-using my handy 'honk' function (Blame evvvvil for the name)\n//     for the robot arm. Very handy for chaining together capsules\n//     which move relative to each other.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// totetmatt, Blackle, Dave Hoskins, byt3_m3chanic, tater,\n// and a bunch of others for sharing their time and knowledge!\n//\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define Z0\tmin(iTime, 0.)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S(a, b, c)\tsmoothstep(a, b, c)\n#define S01(a)\tS(0., 1., a)\n#define minH(a, b, c)\t{ float h_ = a; if (h_ < h.d) h = Hit(h_, b, c); }\n\nfloat t, fade,\n      g = 0.,\n      arm = 0.;\nstruct Hit {\n\tfloat d;\n\tint id;\n\tvec3 p;\n};\n\n// Thnx Dave_Hoskins - https://www.shadertoy.com/view/4djSRW\nfloat h31(vec3 p3) {\n\tp3 = fract(p3 * .1031);\n\tp3 += dot(p3, p3.yzx + 3.3456);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\nfloat h21(vec2 p) { return h31(p.xyx); }\n\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\n\t// Thanks Shane - https://www.shadertoy.com/view/lstGRB\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = sat(.5 + .5 * (b - a) / k);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat min2(vec2 v) { return min(v.x, v.y); }\n\nfloat max2(vec2 v) { return max(v.x, v.y); }\n\nfloat max3(vec3 v) { return max(v.x, max(v.y, v.z)); }\n\nfloat remap(float f, float in1, float in2) { return sat((f - in1) / (in2 - in1)); }\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvec3 rep(vec3 p) { return mod(p + 10., 20.) - 10.; }\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max3(q), 0.);\n}\n\nfloat cyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(length(p.zy), p.x)) - hr;\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat cap(vec3 p, float h, float r) {\n\tp.x -= clamp(p.x, 0., h);\n\treturn length(p) - r;\n}\n\nfloat tor(vec3 p) {\n\treturn length(vec2(length(p.xz) - 1., p.y)) - .4;\n}\n\nfloat honk(inout vec3 p, vec2 r) {\n\tfloat d = cap(p, r.x, r.y);\n\tp.x -= r.x;\n\treturn d;\n}\n\nvec3 rayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t     r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nHit pod(vec3 p, float sha) {\n\tvec3 tp,\n\t     op = p;\n\tfloat f,\n\t      d = cap(p, .5, 1.);\n\n\t// Rear box.\n\tf = min(d, max(box(p, vec3(2, .32, .32)) - .7, abs(p.x - .9) - .6));\n\td = mix(d, f, .7);\n\n\t// Rear slope cut.\n\tf = max(d, p.x + p.y * .5 - 1.4);\n\td = mix(d, f, .5);\n\n\t// Sphere straps.\n\tf = max2(S(.06, .04, abs(abs(p.xz) - vec2(0.0, p.y * .16 + .28))));\n\td -= f * .02;\n\n\t// Front glass.\n\tp.y -= .64;\n\tf = box(p, vec3(1, .18, p.y * .16 + .26));\n\td = max(d, -f);\n\n\t// Side glass.\n\tp.xy += vec2(.35, -.08);\n\tf = max(box(p, vec3(.22, .12, 2)), p.y - sin(p.x + 1.58) * 1.96 + 1.9 - p.x * .4);\n\td = max(d, -f);\n\tp = op;\n\n\t// Square base.\n\tp.xy += vec2(-.21, .2);\n\tf = max(box(p, vec3(1.15, .85, .58)) - .15, abs(p.y) - .2);\n\td = mix(d, min(max(d, -p.y), f), .8);\n\tp = op;\n\tHit h = Hit(d, 3, p);\n\n\t// Top turbines.\n\tp.z = abs(p.z) - .75;\n\tp.xy -= vec2(.7, 1);\n\tf = cyl(p, vec2(.02 * S(.24, .2, abs(p.x)) + .2, .5));\n\ttp = p;\n\tp.x = abs(p.x) - .74;\n\tf = min(max(f, .28 - length(p)), cap(p + vec3(.94, 0, 0), .62, .08));\n\tminH(f, 4, tp);\n\tp = op;\n\n\t// Lights.\n\tp.y -= .73 - .47 * step(p.x, 0.);\n\tp.xz = abs(p.xz - vec2(.14, 0)) - vec2(1.25, .2);\n\tf = cap(p - vec3(2, 0, 0), .5, p.x * .4 + .2);\n\tg += .002 / (.2 + f * f * f * f) * S(-1., -3., op.x);\n\tf = max(length(p + vec3(.43, 0, 0)) - .46, -p.x);\n\tg += .003 / (.003 + f * f * 1e2);\n\tf = min(max(length(p) - .18, p.x), f);\n\td = min(d, f);\n\tp = op;\n\n\t// Skids.\n\tp.z = abs(p.z);\n\tp -= vec3(.29, -.45, .8);\n\tf = box(p, vec3(1, .03, .08));\n\tp.x++;\n\tp.xy *= mat2(.70721, -.707, .707, .70721);\n\tp.x += .047;\n\tf = min(f, box(p, vec3(.06, .03, .08)));\n\td = min(d, f);\n\tp = op;\n\n\t// Rear canisters.\n\tp.z = abs(p.z);\n\tp -= vec3(1.38, .16, .45);\n\tmat2 r = mat2(.95534, .29552, -.29552, .95534);\n\tp.yz *= r;\n\tp.xy *= r;\n\td = min(d, cap(p.yxz, .4, .1));\n\tp = op;\n\n\t// Arm.\n\tp += vec3(1.08, .23, .3);\n\tp.xz *= rot(-4.71225 + S(0., .5, arm) * 1.3);\n\tf = min(honk(p, vec2(.6, .03)), cap(p.yxz, .06, .04));\n\tp.y -= .06;\n\tr = mat2(-1, 0, 0, -1);\n\tp.xz *= r;\n\tp.xy *= rot(S01(arm) * 2.);\n\tf = min(min(f, honk(p, vec2(.6, .03))), cap(p.yxz, .06, .04));\n\tp.y -= .06;\n\tp.xz *= r;\n\tp.xy *= rot(S(.7, 1., arm) * 2.);\n\tf = min(f, honk(p, vec2(.1, .01)));\n\tminH(min(d, f), 3, p);\n\tif (t * sha * step(t, 36.) > 25.5) {\n\t\tp.xy *= rot(sin(t * .55) * .5);\n\t\tp.x -= .02;\n\t\td = honk(p, vec2(2, .01));\n\t\tg += 2e-4 * (sin(p.x * 10. - t * 5.) * .5 + 1.) / (1e-5 + d * d);\n\t\tminH(d, 7, p);\n\t}\n\n\treturn h;\n}\n\nfloat tube(vec3 p) {\n\tfloat d = abs(26.5 - pow(abs(sin(p.x * .16)), 14.) - length(p.yz)) - .5;\n\tif (t > 41.) {\n\t\tp.y++;\n\t\td = smin(d, 2. - length(p.xy) + dot(sin(vec2(5, 10) * atan(p.x, p.y)), vec2(.1, .05)), -.4);\n\t}\n\n\treturn d;\n}\n\nfloat cell(vec3 p, float rnd) {\n\tp.xy -= vec2(15. * t - 7. * cos(t * 2.), 1);\n\tfloat i = h31(floor((p - 10.) / 20.) + vec3(rnd, rnd, -rnd));\n\tp = rep(p);\n\tmat2 m = rot(10. * i + t * rnd * sin(i * 10.));\n\tp.yz *= m;\n\tp.xy *= -m;\n\treturn smin(tor(p), cyl(p.yxz, vec2(1, .1)), .4);\n}\n\nfloat cells(vec3 p) { return min(min(cell(p, 1.), cell(p + vec3(5), 2.)), cell(p + vec3(12), 3.)); }\n\nvec3 podP = vec3(0),\n     podR = vec3(0);\nvec3 lp() {\n\tvec3 p = vec3(3, 0, 0);\n\tp.xz *= rot(-podR.y);\n\treturn podP - p;\n}\n\nHit map(vec3 p, float sha) {\n\tHit h2,\n\t    h = Hit(tube(p), 5, p);\n\tvec3 op = p;\n\tminH(cells(p), 6, p);\n\tp = op - podP;\n\tp.yz *= rot(podR.x);\n\tp.xz *= rot(podR.y);\n\th2 = pod(p, sha);\n\tif (h2.d < h.d) return h2;\n\treturn h;\n}\n\nvec3 N(vec3 p, float t) {\n\tfloat h = t * .4;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h, 1.).d;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat shadow(vec3 p, vec3 lp) {\n\tfloat d,\n\t      s = 1.,\n\t      t = .1,\n\t      mxt = length(p - lp);\n\tvec3 ld = normalize(lp - p);\n\tfor (float i = Z0; i < 30.; i++) {\n\t\td = map(t * ld + p, 0.).d;\n\t\ts = min(s, 15. * d / t);\n\t\tt += max(.01, d);\n\t\tif (mxt - t < .5 || s < .001 || t > 45.) break;\n\t}\n\n\treturn S01(s);\n}\n\nfloat aof(vec3 p, vec3 n, float h) { return sat(map(h * n + p, 0.).d / h); }\n\nfloat fog(float d) { return exp(d * d * -.001); }\n\nvoid dtc(vec2 p, inout vec3 c) {\n\tif (abs(p.x) > .6 || abs(p.y) > .5) return;\n\tfloat dc,\n\t      f = step(min2(abs(p - vec2(0, .2))), .08) * step(p.y, .3) * step(abs(p.x), .4);\n\tif (f > 0.) {\n\t\tc = vec3(8);\n\t\treturn;\n\t}\n\n\tdc = step(.5, p.x);\n\tp.x = abs(p.x) - .46;\n\tf = dot(p, p);\n\tdc += step(f, .25) * step(.16, f);\n\tif (dc > 0.) c = vec3(3);\n}\n\nvec3 lights(vec3 p, vec3 rd, vec3 n, Hit h) {\n\tvec3 c,\n\t     l = lp(),\n\t     ld = normalize(l - p),\n\t     noise = vec3(n31(h.p * .3), n31(h.p.zxy * 3.3), n31(h.p.zxy * 60.)) - .5;\n\tvec2 spe = vec2(10, 1);\n\tif (h.id <= 4) {\n\t\tc = vec3(.34, .3, .32);\n\t\tc *= 1. + dot(noise, vec3(1, .5, .15));\n\t\tn = normalize(n + dot(noise, vec3(.11, .13, .036)));\n\t\tspe.y = 8.;\n\t\tif (h.id == 4) {\n\t\t\tfloat l = length(h.p.yz),\n\t\t\t      v = step(l, .13) * step(.06, l) * sat(1. + sin(t * -80. + 18. * atan(h.p.y, h.p.z)));\n\t\t\tc = mix(c, vec3(.005), v * .6);\n\t\t\tif (h.p.z > 0.) dtc(h.p.xy * vec2(sign(p.x), 1) * 4.5, c);\n\t\t\tn = normalize(n + v * .2);\n\t\t}\n\t}\n\telse if (h.id == 6) {\n\t\tc = vec3(.2, 0, 0);\n\t\tn = normalize(n + noise.z * .25);\n\t}\n\telse if (h.id == 5) {\n\t\tc = vec3(.1, 0, 0);\n\t\tc.r *= 1. - S(.4, 0., abs(dot(sin(p * .16), cos(p.zxy * .07)))) * .5;\n\t\tc *= 1. + dot(noise.xy, vec2(1, .2)) + sat(noise.z) * .7;\n\t}\n\telse c = vec3(1);\n\n\tfloat ao = mix(aof(p, n, .2), aof(p, n, 2.), .7),\n          sha = shadow(p, l),\n\tl1 = sat(.1 + .9 * dot(ld, n))\n         * (0.3 + 0.7 * sha)\n         * (0.3 + 0.7 * ao),\n\tl2 = sat(.1 + .9 * dot(ld * vec3(-1, 0, -1), n)) * 0.025\n\t     + pow(sat(dot(rd, reflect(ld, n))), spe.x) * spe.y * sat(sha + 0.5),\n\tfre = 1.0 - S(.7, 1., 1. + dot(rd, n));\n\n\treturn mix(vec3(0.005, 0, 0), (l1 + l2 * ao) * c * vec3(1, .7, .7), fre);\n}\n\nvec3 scene(vec3 p, vec3 rd) {\n\tvec3 n, col, wp = p;\n\tfloat i, gg, sum,\n\t      d = 0.;\n\tHit h;\n\tfor (i = Z0; i < 90.; i++) {\n\t\th = map(p, 1.);\n\t\tif (abs(h.d) < .0015 || d > 70.) break;\n\t\td += h.d;\n\t\tp += h.d * rd;\n\t}\n\n\tgg = g;\n\tn = N(p, d);\n\tcol = mix(vec3(.0025, .5e-4, .5e-4), gg * vec3(2, .91, .7) + lights(p, rd, n, h), fog(d));\n\n\t// March the window.\n\t{\n\t\tfloat b = 2. * dot(rd, wp - podP),\n\t\t      dis = b * b - 4. * dot(rd, rd) * (dot(podP, podP) + dot(wp, wp) - 2. * dot(podP, wp) - .99);\n\t\tif (dis > 0.) {\n\t\t\tfloat sd = (-b - sqrt(dis)) * 0.5;\n\t\t\tif (sd < d && sd > 0.0) {\n\t\t\t\tp = wp + sd * rd;\n\t\t\t\tif (p.y > podP.y + .4) {\n\t\t\t\t\tn = normalize(podP - p);\n\t\t\t\t\tcol += vec3(1, .7, .7) * (.02 + pow(sat(dot(rd, reflect(normalize(lp() - p), n))), 3.5));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Particles.\n\tsum = 0.;\n\tfor (float dist = 1.; dist < d; dist += 5.) {\n\t\tvec3 vp = wp + rd * dist;\n\t\tvp.yz -= t * .1;\n\t\tsum += 1. - S(0., mix(.15, .02, remap(dist, 1., 20.)), length(fract(vp - wp) - .5));\n\t}\n\tcol += sum * vec3(.03, .003, .003);\n    \n    // Light cone.\n    {\n        vec3 podD = vec3(-1, 0, 0);\n        podD.xz *= rot(-podR.y);\n        vec3 H = podP + vec3(0, 0.3, 0) + podD * 0.4,\n             C = podP + podD * 6.,\n             h = C - H,\n             hCap = normalize(h),\n             w = wp - H;\n        float rdc = dot(rd, hCap), wc = dot(w, hCap),\n              m = 2.25 / dot(h, h),\n              a = dot(rd, rd) - m * rdc * rdc - rdc * rdc,\n              b = 2. * (dot(rd, w) - m * rdc * wc - rdc * wc),\n              c = dot(w, w) - m * wc * wc - wc * wc;\n\n        float f = b * b - 4. * a * c;\n        if (f > 0.0) {\n            float t1 = (-b + sqrt(f)) / (2. * a), t2 = (-b - sqrt(f)) / (2. * a);\n            if (max(t1, t2) < d) {\n                vec3 L1 = wp + t1 * rd, L2 = wp + t2 * rd;\n                float l1 = dot(L1 - H, hCap);\n                float l2 = dot(L2 - H, hCap);\n                if ((0.0 <= l1 && l1 < length(h)) || (0.0 <= l2 && l2 < length(h)))\n                    col += length(L1 - L2) * 0.004 * S(5., 0., min(l1, l2)) * S(8.3, 10., t);\n            }\n        }\n    }\n    \n\treturn col;\n}\n\nfloat addFade(float a) { return min(1., abs(t - a)); }\n\n#define rgba(col)\tvec4(pow(max(vec3(0), col), vec3(.45)) * fade, 0)\n\nvec3 cam(inout vec3 at) {\n\tt = mod(iTime, 55.);\n\tfade = addFade(0.) * addFade(21.) * addFade(41.) * addFade(55.);\n\n\t// Stage 1a - Pod travels towards viewer.\n\tpodP = mix(vec3(-70, 1, 3), vec3(0, -1, 3), S(0., 12., t));\n\tpodR = vec3(sin(t) * .2, 3.141, 0);\n\tfloat f = remap(t, 0., 7.);\n\tvec3 ro = mix(vec3(-20, 0, 0), vec3(-3, 0, 6), f);\n\tat = mix(vec3(-20, 0, 10), podP, remap(t, 0., 7.));\n\n\t// Stage 1b - Pod rotate to wall, extend arm.\n\tpodR = mix(podR, vec3(0, 4.7, 0), S(10., 15., t));\n\tarm = S(14., 18., t);\n\tpodP = mix(podP, vec3(0, -1, 8), S(16., 21., t));\n\n\t// Stage 2 - Pod cutting wall.\n\tfloat drift = .3;\n\tif (t > 21.) {\n\t\tdrift *= 1. - remap(t, 22., 25.) * .8;\n\t\tpodP.yz += vec2(-.6, mix(8., 14.4, S(20., 25., t)));\n\t\tat = podP;\n\t\tf = S(20., 25., t);\n\t\tro += 5. + vec3(5. * f, -3.2 * f, 11.2) - vec3(4.1, 2.35, -1.8) * S(27., 33., t);\n\t\tarm *= S(40.5, 37.5, t);\n\t\tpodP.z += S(38., 41., t);\n\n\t\t// Stage 3 - Entering hole.\n\t\tif (t > 41.) {\n\t\t\tdrift = .3;\n\t\t\tro = vec3(-1.921875, 15. - 10. * S(41., 44., t), 15);\n\t\t\tf = S(48., 53., t);\n\t\t\tpodR.y -= f;\n\t\t\tpodP.xz += vec2(f, S(43., 55., t) * 13.);\n\t\t}\n\t}\n\n\t// Pod drift.\n\tpodP += vec3(sin(t), sin(t * 1.1), cos(t)) * drift;\n\treturn ro;\n}\n\nvoid mainVR(out vec4 fragColor, vec2 fc, vec3 ro, vec3 rd) {\n\trd.xz *= mat2(1, 0, 0, -1);\n\tvec3 dummy;\n\tfragColor = rgba(scene(cam(dummy), rd));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tvec2 R = iResolution.xy,\n         uv = (fc - .5 * R.xy) / R.y,\n\t     v = fc.xy / R.xy;\n\tvec3 at,\n\t     ro = cam(at),\n\t     col = scene(ro, rayDir(ro, at, uv));\n\tcol *= .5 + .5 * pow(16. * v.x * v.y * (1. - v.x) * (1. - v.y), .4);\n\tcol -= h21(fc * .3) * .001;\n\tfragColor = rgba(col);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}