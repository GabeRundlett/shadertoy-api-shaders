{
    "Shader": {
        "info": {
            "date": "1496886860",
            "description": "fuck yeah i KNEW it would be possible, but i failed to substitute correctly to get to this WAY too long.\nwell, this ray marcher does only 4 iterations to reach the surface!\n\nartifacts are DivBy0 cases, should be easy to catch",
            "flags": 0,
            "hasliked": 0,
            "id": "4sfBzj",
            "likes": 5,
            "name": "Lipschitz Owned in 4 iterations!",
            "published": 3,
            "tags": [
                "lipschitzismybitchshitz"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 610
        },
        "renderpass": [
            {
                "code": "//dad: https://www.shadertoy.com/view/4dVGzw\n//but with swiveled parameters:\n//parent has .xyz as Dfdx() Dfdx() Dfdz(), via automatic differentiation\n//this   has .yzw as Dfdx() Dfdx() Dfdz(), via automatic differentiation\n\n//brother: https://www.shadertoy.com/view/XlV3Dy\n//This has a simpler set (no goursat surface)\n//...and instead has derivative arithmetic fields of hg_sdf\n//where hg_sdf dunction return the distance to point [p]\n//THIS returns distance as .x \n//... and 3 first derivatives for 3 domains as .yzw\n//...for the input point [p]\n\n//brother: https://www.shadertoy.com/view/MsXBRB  \n//as this is a process.\n\n// Arithmetic set for automatic differentiation, \n// derivative arithmetic [DA] for\n// https://en.wikipedia.org/wiki/Smoothness\n// of shapes that lack C0-continuity but have C1-continuity.\n// based on    : https://www.shadertoy.com/view/4dVGzw\n// inspired by : https://www.shadertoy.com/view/Mdl3Ws \n//\n//explained at http://blog.demofox.org/2014/12/30/dual-numbers-automatic-differentiation/\n//wiki         https://en.m.wikipedia.org/wiki/Automatic_differentiation\n//summary:     https://www.reddit.com/r/math/comments/68st6p/the_wikipedia_article_on_automatic/\n\n//namespace: All common arithmetic namespaces get a \"*d\" suffix added\n//...that means \"also calculate dirst derivatives for all the domains\",\n//and that increases type float to vec4, and vec3 to mat4 for inOut.\n\n//derivative arithmetic is very useful for fluid dynamics.\n\n//todo, clean up namespaces, find aliases.\n\n//todo, merge with;\n//    https://www.shadertoy.com/view/XdffzB\n//which allows for less domains than 3 domains, \n//...using the same namespaces.\n\n//todo, merge with hg_sdf, full set\n//to have hg_sdf with first derivatives, in 2 or 3 domains.\n//done:\n//fSphere\n//fBox\n//fBoxCheap\n\n\n\n//optionally show superprim\n#define SuperPrim\n\n//if(surfce is convex) rush lets you hit the surface VERY quickly ?\n#define rush\n//rush mode is a bit buggy though.\n\n#ifdef rush\n #define IterRm 4\n//max raymarch iterations|steps\n#else \n #define IterRm 64\n#endif\n\n\n#define IterSh 24\n//softshadow iterations\n\n//the below constant gets overwritten, \n//and htis is wha THIS is all about, it gets overwritten by the right thing!\n//that is == 1./length(dot(raydirection,gradientAtP));\n//==1./length(dot(s.d.yzw,i))\n#define ReciprocalAbsLipschitz .99\n//if(lipschitzConstant>1., distance is overestimated.\n//mzltiplying by ReciprocalAbsLipschitz is a \n//... lazy fix for that is scaling stepDistance*=ReciprocalAbsLipschitz\n//higher precision with a smaller ReciprocalAbsLipschitz AND epsilon=0.\n//meaning, a surface will NEVER really be reached.\n//maybe todo: eps=log(eps*b)*a\n\n//Using f'(x)= f(d)/dx notation for derivates:\n//https://en.wikipedia.org/wiki/Derivative#Notation\n\n//this defines common operations but on a (pseudo) dual number (i,j), defined as:\n//[j] stays \"underived\"\n//[i] calculates the gradient as byproduct\n//[i] becomes Operation(i,FirstDerivateOf(Operation(i,j))\n//[i] is always precise and this way usually calculates faster than using central differences,\n//mostly because a lot of operations have a lot of values cancel each other out, allowing \"shortcuts\".\n//especially canceling out a lot of domainVectors at once, which is nice for vectorHardware.\n//\n//\"pseudo\" dual because [i] has 3 dimensions, and [j] has 1 dimension that modifies on all dimensions of [i], \n//because graphic cards are good with domain operators on vectors.\n//we define dual number (where one part calculates with derivative of the other part and itself)\n//as type vec4(vec3,float)\n//and the 3 dimensions|domains are resolved with [struct DAVec3{}] and [da_domain()]:\nstruct DAVec3{vec4 x;vec4 y;vec4 z;};\nstruct DAVec2{vec3 x;vec3 y;};\nDAVec3 da_domain(vec3 p){return DAVec3(\n vec4(p.x,1.,0.,0.),\n vec4(p.y,0.,1.,0.),\n vec4(p.z,0.,0.,1.));}\nDAVec2 da_domain(vec2 p){return DAVec2(\n vec3(p.x,1.,0.),\n vec3(p.y,0.,1.));}\n//this lets you derive over 3 dimensions at once OR seperately, using very self-similar dual-function variants:\n#define dacon(a) vec4(a,0.,0.,0.)\n#define i1 in float\n#define i4 in vec4\n#define i3 in vec3\nvec4 constd(i1 a){return dacon(a);}\n//as proof of concept, remember the derivates of sin|cos:\n//sin => cos => -sin => -cos => sin =>...\nvec4 sind(i4 a){return vec4(sin(a.x), a.yzw*cos(a.x));}\nvec4 cosd(i4 a){return vec4(cos(a.x),-a.yzw*sin(a.x));}\n//eulers number, exponential functions and natural log:\nvec4 expd(i4 a){float w=exp(a.w);return vec4(a.xyz*w,w);}//exp(a)==pow(e,a)\nvec4 logd(i4 a){return vec4(a.xyz/a.w,log(a.w));}\n\n//#define siq safeinv(q),q);}\nfloat safeinv(i1 a){return (a==0.)?a:1./a;}//reciprocal,1/x but 1./0.=1.; sometimes makes more sense than divBy0!\nvec4 absd (i4 a){return vec4(abs(a.x),a.yzw*sign(a.x));}\nvec4 pow2d(i4 a){return vec4(a.x*a.x,2.*a.x*a.yzw);}\nvec4 sqrtd(i4 a){float q=sqrt(a.x);\n return vec4(q,.5*a.yzw*safeinv(q));}\n\n//derivatives of functions with 2 variables are trickier:\n//because only .w determines breanching of min()|max() (in the nature of dual numbers, only one matters here)\n//optionally, a float parameter can be given as vec4(0,0,0,f):\nvec4 mind(i4 a,i4 b){return(a.x<=b.x)?a:b;}\nvec4 mind(i4 a,i1 b){return(a.x<=b  )?a:constd(b);}\nvec4 mind(i1 a,i4 b){return(a  < b.x)?constd(a):b;}\nvec4 maxd(i4 a,i4 b){return(a.x>=b.x)?a:b;}\nvec4 maxd(i4 a,i1 b){return(a.x>=b  )?a:constd(b);}\nvec4 maxd(i1 a,i4 b){return(a  > b.x)?constd(a):b;}\nmat4 maxd(mat4 a,vec3 p){return mat4(maxd(a[0],p.x),\n                                      maxd(a[1],p.y),\n                                      maxd(a[2],p.z),0,0,0,0);}\nmat4 mind(mat4 a,vec3 p){return mat4(mind(a[0],p.x),\n                                      mind(a[1],p.y),\n                                      mind(a[2],p.z),0,0,0,0);}\nmat4 maxd(mat4 a,float p){return maxd(a,vec3(p));}\nmat4 mind(mat4 a,float p){return mind(a,vec3(p));}\nvec4 maxd(i4 a,i4 b,i4 c){return maxd(maxd(a,b),c);}\nvec4 maxd(mat4 a){return maxd(a[0],a[1],a[2]);}\n//I assume the more general logic here is that all these functions with 2 parameters do:\n/*vec4 r;\n  r.w  = operationOn(a.w,b.w);\n  r.xyz= operationOn(a.xyz , vec3(firstDerivateOf(r.w))); //firstDerivateOf(r.w)==[tricky part]==(3d graphs tangents)\n  return r;*/\n//f(a,b)=mod(a,b) => f'(a,b)=1. , (still disontinuous, not defined for whole multiples of b).\nvec4 modd(i4 a,i4 b){return vec4(mod(a.x,b.x),mod(a.yzw,1.));}\nvec4 modd(i4 a,i1 b){return vec4(mod(a.x,b  ),mod(a.yzw,1.));}\nvec4 modd(i1 a,i4 b){return vec4(mod(a  ,b.x),0,0,0        );}//here \"a.xyz\"==vec3(0)\n//and usually a lot cancels out in substraction/division...\nvec4 subd(i4 a,i4 b){return a-b;}\nvec4 subd(i4 a,i1 b){return vec4(a.x-b  , a.yzw);}\nvec4 subd(i1 a,i4 b){return vec4(a  -b.x,-b.yzw);}\nvec4 addd(i4 a,i4 b){return a+b;}\nvec4 addd(i4 a,i1 b){return subd(a,-b);}//addition as invrse substraction\nvec4 addd(i1 a,i4 b){return subd(a,-b);}\n             \nvec4 muld(i4 a,i4 b){return vec4(a.x*b.x,a.yzw*b.w+a.x*b.yzw);}\nvec4 muld(i4 a,i1 b){return a*b;}\nvec4 muld(i1 a,i4 b){return a*b;}\nvec4 divd(i4 a,i4 b){return vec4(a.x/b.x,(a.yzw*b.x-a.x*b.yzw)/(b.x*b.x));}\nvec4 divd(i4 a,i1 b){return a/b;}\nvec4 divd(i1 a,i4 b){return vec4(a/b.x,(-a*b.yzw)/(b.x*b.x));} \n             \n//some operations cancel out a bit more, to (nearly) tautological|identical identities:\n//<- wooha, a recursive meta-tautology!\n//vec4 da_fract(i4 a){return a;}//derivative of fract(a)=a => tautological.\nvec4 floord(i4 a){return dacon(a.x);}\nvec4 floord(i1 a){return dacon(a);}\n//#define mod(a,b) (a-b*floor(a/b))\n//da_mod.xyz==a.xyz-b.xyz*0==a.xyz\n\n//f(a,b)=dot(g(a),h(b)) => f'(x)              =dot(g'(a)',h(b))+dot(g(a),hÂ´(b))\n//                      => d/dx(dot(g(a),h(b))=dot(ga/gx ,h   )+dot(g   ,ha/hx); //similar to \"product rule for scalars\"\n//g(a)=c\n//h(b)=d\n//f(a,b)=dot(c,d) => f'(x)=dot(c',d)+dot(c,d');\n// c and d are type type vec3;\n//f'(x)=dot(0,d)+dot(c,0) == 0+0; ???\n\n\n//todo: derivative of dot() appears tricky: this #define should do:\n//#define dotDer(a,b) min(f(abs(a)),abs(b))*sign(a)*sign(b)\n//vec4 da_dot(i4 a,i4 b){return vec4(a.xyz*dotDer(a,b),dot(a.w,b.w));}           \n//vec4 da_dot(i4 a,i1 b){return vec4(a.xyz*dotDer(a,b),dot(a.w,b  ));}  \n//vec4 da_dot(i1 a,i4 b){return da_dot(b,a);}//is commutative\n             \n//and it gets trickier with functions that take 3 parameters:\nvec4 da_length(i4 x,i4 y){float q=length(vec2(x.x,y.x));\n return vec4(q,(x.yzw*x.x+y.yzw*y.x)*safeinv(q));}\nvec4 da_length(i4 x,i4 y,i4 z){float q=length(vec3(x.x,y.x,z.x));\n return vec4(q,(x.yzw*x.x+y.yzw*y.x+z.yzw*z.x)*safeinv(q));}\nvec4 da_length(mat4 u){return da_length(u[0],u[1],u[2]);}//3*3domain\nvec4 da_length2(mat4 u){return da_length(u[0],u[1]);}//2*3domain\n//the utility of a length() function is clear.\n\n//the utility of da_*().xyz is trickier, just search below to see  what it is ued for:\n\n\n//using the above, we define distance functions that automatically calculate their derivatives\n//this makes surfaces that are C1-discontinuous, like staircases, \n//at least have their (continuous) first rerivate calculated, which is useful for raymarching (?)\n//distance to unit sphere.\nvec4 sdSphere(DAVec3 p){vec4 q=da_length(p.x,p.y,p.z);return subd(q,1.);;}\n//return distance to infinite line segment\nvec4 sdRay(DAVec3 p){\n float ass=p.x.w;\n p.x.w=mix(0.,p.x.w,step(p.x.w,0.));\n vec4 q=da_length(p.x,p.y,p.z);\n q=subd(q,1.);\n return q;}\n\nvec4 subdabsd(vec4 p,float s){return subd(absd(p),s);}\nmat4 subdabsd(DAVec3 p,vec3 s){\n return mat4(subdabsd(p.x,s.x),\n             subdabsd(p.y,s.y),\n             subdabsd(p.z,s.z),0,0,0,0);}\n\n/*\nfloat fBoxCheap(vec3 p,vec3 b){\n vec3 q=abs(p);q=q-p;//mirror clamp\n return max(max(q.x,q.y),q.z);}\n*///hg_sdf\n//return distance to box size (s)\nvec4 sdBoxCheap(DAVec3 p,vec3 s){\n //vec3 s=vec3(1.5,.5,1.5);\n vec4 x,y,z,d,e,f,q,a,b,c;\n x=vec4(0);y=vec4(0);z=vec4(0);d=vec4(0);\n e=vec4(0);f=vec4(0);q=vec4(0);\n a=vec4(0);b=vec4(0);c=vec4(0);\n mat4 u=subdabsd(p,s);//mirror clamp\n return maxd(u);}\n/*\nfloat fBox(vec3 p,vec3 s){\nvec3 d=abs(p)-s;//mirror clamp\nfloat a=length(max(d,0.));//rounded corners\nvec3 q=min(d,0.);//clamp\nfloat b=max(max(q.x,q.y),q.z);//keep largest of 3\nreturn a+b;}//add\n*///hg_sdf\nvec4 sdBox(DAVec3 p){\n vec3 s=vec3(1.5,.5,1.5);\n mat4 d=subdabsd(p,s);//mirror clamp\n vec4 a=da_length(maxd(d,0.));//rounded corners\n mat4 q=mind(d,0.);//clamp\n vec4 b=maxd(q);//keep largest of 3\n return addd(a,b);}//add\n             \n//a more readable version of the above, like, seriously WTF MAN!\n//how about one operation per line man, keep it BASIC!\nvec4 sdSuperprim(DAVec3 p, i4 s,vec2 r) {\n //vec2 r=vec2(.2,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n vec4 dx,dy,dz,d,e,f,q,a,b,c;\n dx=vec4(0);dy=vec4(0);dz=vec4(0);d=vec4(0);\n e=vec4(0);f=vec4(0);q=vec4(0);\n a=vec4(0);b=vec4(0);c=vec4(0);\n dx=absd(p.x);\n dx=subd(dx,s.x);\n dy=absd(p.y);\n dy=subd(dy,s.y);\n dz=absd(p.z);\n dz=subd(dz,s.z);\n \n d=addd(dx,r.x);\n d=maxd(d,0.);\n e=addd(dy,r.x);\n e=maxd(e,0.);\n q=da_length(d,e);\n f=maxd(dx,dy);\n f=mind(-r.x,f);\n \n q=addd(q,f);\n q=addd(q,s.w);\n q=absd(q);\n q=subd(q,s.w);\n ///return...\n a=addd(q ,r.y);\n a=maxd(a,0.);    \n b=addd(dz,r.y);\n b=maxd(b,0.);\n a=da_length(a,b);\n c=mind(-r.y,maxd(q,dz));\n c=addd(a,c);\n return c;\n}\n\n// example parameters\n#define SHAPE_COUNT 10.0\nvoid getfactor (int i, out vec4 s,out vec2 r) {\n    //i = 8;\n    if (i == 0) { // cube\n        s = vec4(1.0);\n        r = vec2(0.0);\n    } else if (i == 1) { // corridor\n        s = vec4(vec3(1.0),0.25);\n        r = vec2(0.0);\n    } else if (i == 2) { // pipe\n        s = vec4(vec3(1.0),0.25);\n        r = vec2(1.0,0.0);\n    } else if (i == 3) { // cylinder\n        s = vec4(1.0);\n        r = vec2(1.0,0.0);\n\t} else if (i == 4) { // pill\n        s = vec4(1.0,1.0,2.0,1.0);\n        r = vec2(1.0);\n    } else if (i == 5) { // sphere\n        s = vec4(1.0);\n        r = vec2(1.0);\n    } else if (i == 6) { // pellet\n        s = vec4(1.0,1.0,0.25,1.0);\n        r = vec2(1.0,0.25);\n    } else if (i == 7) { // torus\n        s = vec4(1.0,1.0,0.25,0.25);\n        r = vec2(1.0,0.25);\n    } else if (i == 8) { // sausage mouth\n        s = vec4(2.0,0.5,0.25,0.25);\n        r = vec2(0.5,0.25);\n    } else if (i == 9) { // beveled O\n        s = vec4(0.7,1.0,1.0,0.25);\n        r = vec2(0.125);\n\t}\n}\n\n//set camera position & target\nvoid setCam(out vec3 o,out vec3 i,i1 t,i1 m){\n o=vec3(4.*sin(t),m*9.-2.,4.*cos(t));i=vec3(0);}\n\nstruct DAMValue{vec4 d;float m;};\nDAMValue min2(DAMValue a, DAMValue b){if(a.d.x>b.d.x)return b;return a;}\nDAMValue plane(DAVec3 p){return DAMValue(addd(p.y,1.),1.);}\n//DAMValue add_plane(DAVec3 p,DAMValue m){return min2(plane(p),m);}\n\n#define ss01(a) smoothstep(0.,1.,a) \n#define imsc(a) int(mod(a,SHAPE_COUNT))\n//return distance to surface of DistanceField\nDAMValue df(DAVec3 p){vec4 r;\n#ifndef SuperPrim\n //r=sdGoursat(p);\n r=sdBox(p);\n //r=da_max(-sdTangle(p),sdSphere(p));\n //r=sdGoursat(p)*.7+sdSphere(p)*.3;\n //r=mix(sdGoursat(p),sdSphere(p),sin(iTime*.61)*.5+.5);\n#else\n float t=iTime,u=ss01(ss01(fract(t)));\n vec4 a,b;vec2 c,d;\n getfactor(imsc(t   ),a,c);\n getfactor(imsc(t+1.),b,d);\n DAVec3 q=DAVec3(p.y,p.z,p.x);\n if(iMouse.z>.5){\n  vec2 m=iMouse.xy/iResolution.xy;\n  r=sdSuperprim(q,vec4(vec3(1.0),mix(a.x,b.x,u)),m);\n }else\n  r=sdSuperprim(q,mix(a,b,u),mix(c,d,u));\n#endif\n //return DAMValue(r,0.);\n return min2(plane(p),DAMValue(r,0.));}\n\n//return distance & materialID\nvec2 dm(i3 p){DAMValue d=df(da_domain(p));\n return vec2(d.d.x,d.m);}\n//return material at p with normal n\nvec4 material(i3 p,i3 n ){vec4 d=df(da_domain(vec3(p.x,0.,p.z))).d;\n return mix(vec4(n*.5+.5,.1)\n           ,vec4(d.yzw*.5 +.5,.0)*abs(mod(d.x,.1)/.1-.5)\n           ,clamp(dm(p).y,0.,1.));}\n\n//return soft shadow\nfloat shadow(i3 o,i3 i){\n const float a=32.;//shadow hardnes\n float r=1.,h =1.,t=.0005;//t=(self)intersection avoidance distance\n for(int j=0;j<IterSh;j++){\n  h=dm(o+i*t).x;\n  r=min(r,h*a/t);\n  t+=clamp(h,.02,2.);}//limit max and min stepping distances\n return clamp(r,0.,1.);}\n\n//return p, modified by light , shadow, envMap...\nvec3 light(i3 p,i3 n,i3 i,i1 d,i4 m){\n vec3 l=normalize(vec3(1.,.7,.9));//light direction\n float o=max(0.,dot(n,l)),\n c=max(0.,dot(n,normalize(l-i))),\n s;if(c>.01)s=shadow(p+.01*n,l); \n const vec3 LigCol=vec3(1.);//light color\n vec3 r=m.rgb*(LigCol+o*vec3(.8,.7,.6)*s*3.+vec3(.2,.3,.3));  \n r+=s*c*pow(o,40.);//specular\n //r+=m.w*texture(iChannel0, reflect(i,n)).rgb;//envmap\n r*=exp(-.01*d*d);//fog  \n return r;}\n\n//return distance along ray (raymarch till surface)\nfloat rm(i3 o,i3 i){\n const float m=20.;//distance.Max\n float e=.0,h=e,t=0.;//intersection.precission\n for(int j=0;j<IterRm;j++){\n  if(h<e)break;if(t>m)return -1.;\n          //wait a moment, do i not have the lipschitz for the point\n     //or at least 3 for 3 domains of the point\n     //by using [DA]?\n     //i mean, i could really insert this here, right?\n     //and substitute ReciprocalAbsLipschitz with \"1/da_length(dm(o+i*t).yzw)\"\n  //i am pretty sure that i am missing a dotproduct here\n  //the gradient must be dorproducted onto the ray direction?\n  DAMValue s=df(da_domain(o+i*t));\n  float r=ReciprocalAbsLipschitz;\n  #ifndef rush\n  r=1./max(1.,length(dot(s.d.yzw,i)));//overwriting with a VERY LOCAL lipschitz constant\n     //its not a good estimate, but it is a LOT better?\n  #else\n  r=1./   (   length(dot(s.d.yzw,i)));//overwriting with a VERY LOCAL lipschitz constant\n  \n  #endif\n  h=s.d.x*r;t+=h;}return t;}\n\n//return surface normal\nvec3 getN(in vec3 p){DAMValue d=df(da_domain(p));\n return d.d.yzw;}\n//.xyz store the first derivatives on the 3 domains, \n//this is equivalent to the gradient at p\n//if (p is near a surface) the gradient is a surface normal\n//d.d.* addresses a vec4. where *.xyz==gradient\n//d.m.* addresses a material\n             \n//return camera matrix\nmat3 calcLookAtMatrix(in vec3 o,in vec3 i,in float r ){\n vec3 w=normalize(i-o);vec3 u=normalize(cross(w,vec3(sin(r),cos(r),0.)) );\n return mat3(u,normalize(cross(u,w)),w);}\n\n//return color corrected r\nvec3 ff_filmic_gamma3(vec3 r){vec3 x=max(vec3(0),r-.004);\n return (x*(x*6.2+.5))/(x*(x*6.2+1.7)+.06);}\n\nvoid mainImage( out vec4 r,in vec2 fragCoord ){\n vec2 p=(-iResolution.xy+2.*fragCoord.xy)/iResolution.y,\n m=iMouse.xy/iResolution.xy;  //mouse\n vec3 o,i;\n setCam(o,i,iTime,m.y+.2);//camMovement\n const float roll=0.,lens=2.;//camRoll,CamLensLength\n vec3 d=normalize(calcLookAtMatrix(o,i,roll)*vec3(p.xy,lens));//ray.direction\n vec3 c=vec3(0);\n float t=rm(o,d);//Distance.raymarched\n if(t>-.5){\n  vec3 p=o+t*d,n=getN(p); //position & normal\n  vec4 m=material(p,n);   //material\n  c=light(p,n,d,t,m);}    //light\n c=ff_filmic_gamma3(c*.6);//gamma\n //c=pow( clamp(col,0.0,1.0), vec3(0.4545) );\n r=vec4(c,1.);}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}