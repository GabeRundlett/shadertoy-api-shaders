{
    "Shader": {
        "info": {
            "date": "1556823509",
            "description": "Inspired by animations by [url=https://twitter.com/beesandbombs]beesandbombs[/url].",
            "flags": 0,
            "hasliked": 0,
            "id": "wllGzS",
            "likes": 31,
            "name": "Sphere Swirls",
            "published": 3,
            "tags": [
                "raymarching",
                "lighting",
                "abstract",
                "animation"
            ],
            "usePreview": 0,
            "username": "TekF",
            "viewed": 842
        },
        "renderpass": [
            {
                "code": "// Sphere Swirls\n// by Hazel Quantock 2019\n// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. http://creativecommons.org/licenses/by-nc-sa/4.0/\n\n// reduce this to improve frame rate in windowed mode (0 disables anti-aliasing)\n#define AA_QUALITY 2\n\n// allow a little bleed between pixels - I think this looks more photographic, but blurrier\n#define AA_ROUND false\n#define AA_ROUND_RADIUS 0.7071\n\n\nfloat Torus( vec3 position, float majorRadius, float minorRadius )\n{\n    float majorCircle = length(position.xy) - majorRadius;\n    vec2 crossSection = vec2( position.z, majorCircle );\n    return length( crossSection ) - minorRadius;\n}\n\n\nfloat SDF( vec3 pos )\n{\n    float thickness = .02;\n    const int n = 50;\n    float f = 1e20;\n    for ( int i=0; i < n; i++ ) // can make this faster by using pos.z as an index, but then need to have bounds on adjacent rings\n    {\n        float fi = (float(i)+.5)/float(n);\n        float a = 6.283*(fi*.5-.25);\n        float h = sin(a);\n        float r = cos(a);\n        \n        float sliceAngle = -iTime*1.618 + (fi-.5)*6.283*(1.8*cos(iTime*.6) + 49.*smoothstep(.5,1.,-cos(iTime*.1)));\n        vec2 slice = vec2(cos(sliceAngle),sin(sliceAngle));\n        \n        f = min( f,\n                max(\n                    Torus( pos-vec3(0,0,h), r, thickness),\n                    dot(pos.xy,slice) // plane\n                )\n            );\n        \n        // add sphere end caps\n        vec3 end = vec3( slice.y*r, -slice.x*r, h );\n        f = min( f, length(pos - end) - thickness );\n        end.xy = -end.xy;\n        f = min( f, length(pos - end) - thickness );\n    }\n    \n    return f;\n}\n\n\nconst float epsilon = .0004;\nfloat Trace( vec3 rayStart, vec3 rayDirection, float near, float far )\n{\n    float t = near;\n    \n    float h = 0.;\n    float lasth = 0.;\n    float bestt = 0.;\n    float bestDist = 1e30;\n    float sdf = 0.;\n    for ( int i=0; i < 200; i++ )\n    {\n        lasth = h;\n        sdf = SDF( rayDirection*t+rayStart );\n        h = sdf + epsilon*.5;\n\t\tt += h;\n        if ( t > far ) return 1e10;\n        if ( sdf < bestDist ) { bestt = t; bestDist = sdf; } // not sure if all these conditionals will compile well, could flip to use step and mix\n        if ( h < epsilon ) break;\n    }\n\n    if ( sdf == bestDist )\n    {\n        // improve precision\n\t\tfloat lastt = t-epsilon;\n\t\tfloat lastsdf = SDF( rayDirection*lastt+rayStart );\n\t\tfloat sdf = SDF( rayDirection*t+rayStart );\n       \tt = mix( lastt, t, (0.-lastsdf)/(sdf-lastsdf) );\n    }\n    else if ( t < bestt*2. )\n    {\n        // use the closest sample we had, to avoid sampling back-sides and things\n        t = bestt;\n\t\t// this can add a fringe, but maybe better than the alternative\n    }\n    \n    return t;\n}\n\n\nvec3 GetNormal( vec3 p )\n{\n    vec2 d = vec2(-1,1)*epsilon;\n    return normalize(\n        \tSDF(p+d.xxx)*d.xxx +\n        \tSDF(p+d.yyx)*d.yyx +\n        \tSDF(p+d.yxy)*d.yxy +\n        \tSDF(p+d.xyy)*d.xyy\n        );\n}\n\n\nvec3 HDRtoLDR( vec3 col )\n{\n\tconst float whiteSoftness = 0.15; // this mostly affects the diffuse light - rewind to recompute it!\n    \n    // soft clamp to white (oh this is so good)\n    float w2 = whiteSoftness*whiteSoftness;\n    col += w2;\n    col = (1.-col)*.5;\n    col = 1. - (sqrt(col*col+w2) + col);\n    \n    col = clamp( col, 0., 1. );\n\n    // linear to sRGB (approx)\n    //col = pow( col, vec3(1./2.2) ); // moved to after anti-aliasing\n\n    return col;\n}\n\n\nvoid mainImage2( out vec4 fragColour, in vec2 fragCoord )\n{\n    vec3 ray = vec3((fragCoord-iResolution.xy*.5)/iResolution.y,2.3);\n    \n    vec3 camPos = vec3(4,0,-3);\n    \n    float time2 = iTime*.2;\n    vec2 rot = vec2(0);\n    \n    // wandering camera\n    rot += sin(vec2(1,-.618)*(time2-sin(time2))*.5)*vec2(.5,.2);\n    \n//    if ( max(iMouse.x,iMouse.y) > .0 ) // use last mouse position (unless 0,0 => never clicked)\n    if ( iMouse.z > .0 ) // snap back when mouse released\n    {\n        rot = (iMouse.xy/iResolution.xy-.5);\n    }\n    rot *= vec2(1,.5)*6.283185;\n    camPos.xz = camPos.xz*cos(rot.x) + sin(rot.x)*vec2(1,-1)*camPos.zx;\n    float l = length(camPos.xz);\n    camPos.xz *= cos(rot.y) + sin(rot.y)*camPos.y/l;\n    camPos.y = camPos.y*cos(rot.y) - sin(rot.y)*l;\n    \n    vec3 camK = normalize(vec3(0)-camPos);\n    vec3 camI = normalize(cross(vec3(0,1,0),camK));\n    vec3 camJ = cross(camK,camI);\n    \n    ray = ray.x*camI + ray.y*camJ + ray.z*camK;\n    ray = normalize(ray);\n    \n    // jump ahead because we know the object is inside a 1+thickness sphere\n    float near = (length(camPos)-1.1);\n    float far = (length(camPos)+1.1);\n    \n\tfloat t = Trace( camPos, ray, near, far );\n    \n    vec3 pos = camPos+t*ray;\n    \n    if ( t >= far )\n    {\n        // background\n        \n        // make it consistent with ambient light direction\n        fragColour.rgb = (vec3(.5,.6,.8)-.25) * smoothstep(-.3,.3,dot(ray,normalize(vec3(-4,-3.5,3)))) + .25;\n    }\n    else\n    {        \n        vec3 normal = GetNormal(pos);\n\n        // ambient light\n\t\t// this looks pretty nice, it implies a studio where the camera is on the dark side\n        fragColour.rgb = (dot(normal,normalize(vec3(-4,-3.5,3)))*.5+.5)*(vec3(.5,.6,.8)-.25);\n        fragColour.rgb += vec3(.25);\n        \n        // some rough AO\n        float aoDist = .1;\n        fragColour.rgb *= smoothstep(-aoDist*2.,.0,SDF(pos+normal*aoDist)-aoDist);\n        \n        vec3 lightDir = normalize(vec3(-2,3,-1));\n        vec3 lightCol = vec3(1);\n\n        float shadowT = Trace( pos, lightDir, .001, 2. );\n        if ( shadowT >= 2. )\n        {\n            fragColour.rgb += max(0.,dot(normal,lightDir))*lightCol;\n        }\n    }\n\n    fragColour.rgb = HDRtoLDR(fragColour.rgb);\n    fragColour.a = 1.;\n}\n\n\n// Anti-aliasing\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n#if ( AA_QUALITY == 0 )\n    mainImage2( fragColour, fragCoord );\n#else\n    int numSamples = max( 1, int((1920.*1080.*float(AA_QUALITY)*.15) / (iResolution.x*iResolution.y)) );\n\n    vec4 colSum = vec4(0);\n    for ( int i=0; i < numSamples; i++ )\n    {\n        uvec2 quasi2 = uvec2(0xC13FA9A9u,0x91E10DA5u);\n        uint seed = uint(i);\n        //seed += uint(iFrame*numSamples); // randomize per frame - causes shimmering\n        //seed += uint(fragCoord.x)*quasi2.x+uint(fragCoord.y)*quasi2.y; // randomize per pixel - this looks bad at low sample counts (and at high counts it's less important)\n        vec2 jitter = vec2( quasi2 * seed ) / exp2(32.);\n\n        if ( AA_ROUND )\n        {\n            // circle of confusion slightly bigger than a pixel - should look more photographic\n            jitter.x *= 6.283185;\n            jitter = AA_ROUND_RADIUS*(1.-jitter.y*jitter.y)*vec2(cos(jitter.x),sin(jitter.x));\n        }\n        else\n        {\n            jitter -= .5;\n        }\n        \n        vec4 col;\n        mainImage2( col, fragCoord + jitter );\n        colSum += col;\n    }\n   \n    fragColour = colSum/float(numSamples);\n#endif\n    fragColour.rgb = pow( fragColour.rgb, vec3(1./2.2) );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}