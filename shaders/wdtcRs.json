{
    "Shader": {
        "info": {
            "date": "1601572378",
            "description": "This is a simple shader illustrating the possibility of adapting noise models to the cyclostationary context. It uses a spatially-varying and periodic PSD (the PSD of the polyphase components) for each sample of the output, and keeps the random phase.",
            "flags": 0,
            "hasliked": 0,
            "id": "wdtcRs",
            "likes": 0,
            "name": "Cyclostationary noise",
            "published": 3,
            "tags": [
                "noise"
            ],
            "usePreview": 0,
            "username": "cycloEG2020",
            "viewed": 242
        },
        "renderpass": [
            {
                "code": "//=================================================================\n//= Cyclostationary noise - paper 1152 - For Eurographics 2021\n//=================================================================\n//= Based on the shadertoys of Arthur Cavalier (LRPN, phasor) and Fabrice Neyret (Gabor noise).\n//- Shaders : https://www.shadertoy.com/view/WscGD8\n//-           https://www.shadertoy.com/view/WsSSWG\n//=================================================================\n\n//The spectrum model is based on manipulating the frequency, orientation and range\n//of a bi-lobe spectrum according to the spatial coordinates with a period.\n//The viewer is invited to play with the definitions of F (range of frequencies) \n//and O (range of orientations) from line 188 to 202\n//in order to modify the spatially-varying spectrum used.\n\n//--------------------------------------------------------------------------------------------------------\n//-- User Parameters -------------------------------------------------------------------------------------  \n#define MOUSE_CONTROL\n#define TIMER_OFFSET\nconst int   LRPN_COSINES     = 3;\nconst float LRPN_RESOLUTION  = 5.0;\nconst float LRPN_SLOPE_SCALE = 0.1;\nconst uint  LRPN_GLOBAL_SEED = 0u;\n\nfloat \t\tGABOR_SIZE   = 0.07;\nfloat\t\tGABOR_NB_KERNELS = 300.; //lower if running on a low-end PC\n\n//--------------------------------------------------------------------------------------------------------\n//-- Constants -------------------------------------------------------------------------------------------  \nconst float m_pi_2 \t\t= 1.5707963267;         \nconst float m_pi   \t\t= 3.1415926535;          \nconst float m_2_pi \t\t= 6.2831853071;\nconst float m_isqrt2 \t= 0.7071067811865;\n\n\n//--------------------------------------------------------------------------------------------------------\n//-- Pseudo Random Number Generation ---------------------------------------------------------------------  \n// From Texton Noise Source Code provided by Arthur Leclaire et al. \n// https://www.idpoisson.fr/galerne/texton_noise/index.html\n// Sourced ::\n/* \n * From http://www.reedbeta.com/blog/2013/01/12/quick-and-easy-gpu-random-numbers-in-d3d11/\n * Same strategy as in Gabor noise by example\n * Apply hashtable to create cellseed\n * Use a linear congruential generator as fast PRNG\n */\n\nuint  wang_hash(uint seed)                                          {seed=(seed^61u)^(seed>>16u);seed*=9u;seed=seed^(seed>>4u);seed*=668265261u;seed=seed^(seed>>15u);return(seed);}\nuint  cell_seed(const in ivec2 c, const in uint offset)             {const uint period=1024u;uint s=((uint(c.y)%period)*period+(uint(c.x)%period))*period+offset; if(s==0u){s = 1u;}return(s);}\nuint  myrand(inout uint p)                                          {p^=(p<<13u);p^=(p>>17u);p^=(p<<5u);return p;}\nfloat myrand_uniform_0_1(inout uint p)                              {return float(myrand(p))/float(4294967295u);}\nfloat myrand_uniform_m_M(inout uint p, in float mi, in float ma)    {return mi + (myrand_uniform_0_1(p) * (ma - mi));}\nbool keyToggle(int ascii) \n{\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\n}\n\n//--------------------------------------------------------------------------------------------------------\n//-- Normal Mapping Function -----------------------------------------------------------------------------  \nvec3 normal_map_from_slope(float dx, float dy) // using partial derivatives\n{\n    float norm = length(vec3(dx,dy,1.0));\n    float nx = -dx / norm; \n    float ny = -dy / norm; \n    float nz = 1.0 / norm; \n    return 0.5 + 0.5 * vec3(nx,ny,nz);\n}\n\n//--------------------------------------------------------------------------------------------------------\n//-- Gaussian Window Function ----------------------------------------------------------------------------  \nfloat gaussian(in vec2 st, in float c, in vec2 mu, in mat2 sig)\n{\n    vec2 p = st-mu;\n    float body = -0.5*dot(p,inverse(sig)*p);\n    return c*exp(body);\n}\n\n//--------------------------------------------------------------------------------------------------------\n//-- Profile Functions ----------------------------------------------------------------------------------- \n//-- From Thibault Tricard source : https://www.shadertoy.com/view/wlsXWf\nfloat PWM(float x, float r) {return mod(x,m_2_pi)> m_2_pi *r ? 1.0 : 0.0;}\nfloat wave_square(float x)  {return PWM(x,0.5);}\nfloat wave_saw(float x)     {return mod(x,m_2_pi)/(m_2_pi);}\nfloat wave_sine(float x)    {return 0.5+0.5*sin(x);}\n\n\n\n//--------------------------------------------------------------------------------------------------------\n//-- Local Random Phase Noise ----------------------------------------------------------------------------\nvec4 local_random_phasor_noise(\n        in vec2  texcoords,\n        in float resolution,\n        in int   cosines,\n        in vec2  range_frequency,\n        in vec2  range_orientation\n    )\n{\n    vec2  scaled_coords = texcoords * resolution;\n    vec2  cell_coords   = fract(scaled_coords);\n    vec2  cell_index    = floor(scaled_coords);\n    \n    ivec2 cell_ID;\n    uint  prng, seed;\n    \n    vec4  lrpn   = vec4(0.);\n    float weight = 1. / float(cosines);\n    mat2  sigma  = mat2( (1.2*1.2)/m_2_pi );\n\n    for (int m=-1; m<=+1; m++)\n    for (int n=-1; n<=+1; n++)\n    {\n        cell_ID.x = int(cell_index.x) + m;\n        cell_ID.y = int(cell_index.y) + n;\n        seed = cell_seed(cell_ID,LRPN_GLOBAL_SEED);\n        prng = wang_hash(seed);\n\n        vec2 xy = cell_coords - vec2(m,n) - vec2(0.5);\n        float d = dot(xy,xy);\n        \n        vec2  sum_of_cosines    = vec2(0.); \n        float sum_of_partial_x  = 0.; \n        float sum_of_partial_y  = 0.; \n        for(int k=0; k<cosines; k++)\n        {\n            float fr = myrand_uniform_m_M(prng,range_frequency.x,range_frequency.y) * resolution;   // Scaled Frequency \n            float or = myrand_uniform_m_M(prng,range_orientation.x,range_orientation.y);            // Orientation\n            float ph = m_pi*(myrand_uniform_0_1(prng)*2.-1.);                                       // Phase\n            float ff = m_2_pi * dot(xy, fr * vec2(cos(or),sin(or)) );                               // Oriented Frequency\n            vec2  sc = vec2( cos(ff+ph), sin(ff+ph) ); \n\n            sum_of_cosines   += sc;\n            sum_of_partial_x += -m_2_pi * fr * cos(or) * sc.y;\n            sum_of_partial_y += -m_2_pi * fr * sin(or) * sc.y; \n        }\n\n        lrpn += gaussian(xy, 1., vec2(0.0), sigma) * weight * vec4(sum_of_cosines, sum_of_partial_x, sum_of_partial_y);\n    }\n    return vec4(lrpn); // vec3(Cosines, Sines, Partial X, Partial Y); \n}\n\n//--------------------------------------------------------------------------------------------------------\n//-- Utils -----------------------------------------------------------------------------------------------\nfloat looped_smooth_stairs(float t, float ratio, float nof_values)\n{\n    t*= nof_values;\n    return mix(floor(mod(t/ratio, nof_values)), floor(mod((t+1.)/ratio, nof_values)), smoothstep(0.0, 1.0, fract(t)));\n}\n\nfloat gauss(float x,float s) {\n    return exp(-.5*(x*x)/(s*s)); \n}\nfloat gauss(vec2 v,float s) { return gauss(v.x,s)*gauss(v.y,s); }\n\n\nfloat rndi(float i, float j) {\n    return fract(1e5*sin(i+3.*j+0.567));\n}\n\n\n// --- complex Gabor ------------------------------\nvec2 Gabor(vec2 pos, float freq, float a) {\n    float t = (keyToggle(64+20))? 0. : iTime; // 'T'\n    float g = gauss(pos, GABOR_SIZE);\n    if (g < 1e-3) return vec2(0.);\n    vec2 dir = m_isqrt2*(cos(a)*vec2(1.,1.)+ sin(a)*vec2(-1.,1.));\n    float phi = freq*dot(pos,dir) * 2.* m_pi + 10.*t;\n\n    return g*vec2(cos(phi),sin(phi)); // NB: only the real part is used, classically\n}\n\n// --- complex Gabor noise = kernel * point distrib\nvec2 GaborNoise(vec2 uv, vec2 F, vec2 O) {\n    const uint seed = uint(0);\n    uint prng = wang_hash(seed);\n    vec2 f=vec2(0.);\n\tfor (float i=0.; i<GABOR_NB_KERNELS; i++) { \n\t\tvec2 pos = vec2(1.8*rndi(i,0.),-1.+rndi(i,1.)*2.);\n        float a = myrand_uniform_m_M(prng, O.x, O.y);\n        float F = myrand_uniform_m_M(prng, F.x, F.y);\n\t\tf += Gabor(uv-pos, F, a);\n\t}\n\treturn f *sqrt(200./GABOR_NB_KERNELS); // /6.;\n}\n\n//--------------------------------------------------------------------------------------------------------\n//-- Main ------------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixcoords = fragCoord.xy / iResolution.xy;\n    vec2 texcoords = (2.*fragCoord.xy-iResolution.xy) / iResolution.y;\n    vec2 mouse = clamp(iMouse.xy / iResolution.xy, 0., 1.);\n    \n    //===========================================\n\n    //Definition of a spatially-varying amplitude - teaser\n    vec2  F = vec2(0.5,0.6);        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//~ Frequecy range [fmin;fmax]\n    vec2  O = vec2(0. + texcoords.x * m_pi * 1.66 , m_pi/6. + texcoords.x * 1.66* m_pi);   \t\t\t//~ Orientation range [omin;omax]\n    \n    //Definition of a spatially-varying amplitude - sup mat. (1)\n    //vec2  F = vec2(0.5,0.6);\n    //vec2  O = vec2(0. + m_pi * 1.66 , 1.66* m_pi + cos(16.*texcoords.y));\n    \n    //Definition of a spatially-varying amplitude - sup mat. (2)\n    //vec2  F = vec2(0.5,0.6);\n    //vec2  O = vec2(0. + texcoords.x * m_pi * 1.66 , texcoords.x * 1.66* m_pi + (m_pi/4.)*cos(5.*texcoords.y));\n    \n    //===========================================\n    \n    float R = LRPN_RESOLUTION;      \t\t\t\t\t\t\t\t\t\t//~ Grid resolution\n    int   K = LRPN_COSINES;         \t\t\t\t\t\t\t\t\t\t//~ Number of cosines\n\n#ifdef TIMER_OFFSET\n    texcoords += vec2(0.1*iTime);\n#endif\n\n    vec4  lrpn = local_random_phasor_noise(texcoords,R,K,F,O);\n    float Sc = lrpn.x;\n    float Ss = lrpn.y;\n    float Dx = lrpn.z * LRPN_SLOPE_SCALE;\n    float Dy = lrpn.w * LRPN_SLOPE_SCALE;\n\n    float Phi = atan(Ss,Sc);\n\n\tif(pixcoords.x < 0.66)\n    {\n      \tif(pixcoords.x < 0.33)\n        \tfragColor.rgb = vec3(0.5+0.5*Sc);\n        else\n        {\n          \tfloat Weight = looped_smooth_stairs(iTime,4.,3.);\n        \tfloat Phasor = wave_sine(Phi);\n                        //+ max(1.-abs(Weight-1.),0.) * wave_saw(Phi) //different phasor noise profiles\n                        //+ max(1.-abs(Weight-2.),0.) * wave_square(Phi);\n        \tfragColor.rgb = vec3( Phasor );\n        }\n    }\n    else\n    {\n        texcoords -= vec2(0.1*iTime);\n        vec2 f  = .5 * GaborNoise(texcoords, F*25., O - m_pi/4.); //sqrt((O.y-O.x)*(O.y-O.x)\n    \n    \t// --- Normalize and display Gabor noise\n    \tfragColor = vec4(.5+.5*f.x);  \n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}