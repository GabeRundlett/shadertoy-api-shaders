{
    "Shader": {
        "info": {
            "date": "1507385581",
            "description": "A disk in 3d turns into a quadratic 2d shape under perspective projection (usually an ellipse but not necessarily).\nKnowing the value and gradient of the quadratic function allows us to render nicely antialiased 3d disks.  Camera controls via mouse.",
            "flags": 48,
            "hasliked": 0,
            "id": "XtfyWs",
            "likes": 12,
            "name": "Disk - Perspective Projection",
            "published": 3,
            "tags": [
                "antialiasing",
                "projection",
                "perspective",
                "disk",
                "transform"
            ],
            "usePreview": 0,
            "username": "TinyTexel",
            "viewed": 1393
        },
        "renderpass": [
            {
                "code": "// CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n\n/*\nA disk in 3d turns into a quadratic 2d shape under perspective projection (usually an ellipse but not necessarily).\nKnowing the value and gradient of the quadratic function allows us to render nicely antialiased 3d disks.\nKnowing the number of pixel covered by the projection can also help in that regard.\nAssuming the projected shape is an ellipse, we can calculate an upper bound for the pixel count (shown at bottom left of the screen)\nfrom the screen space area of the disk.\nOverall, the disk case is/appears to be quite a bit more tricky to handle compared to one for spheres \n( as described by iq: https://iquilezles.org/articles/sphereproj | https://www.shadertoy.com/view/XdBGzd ).\n\nCamera controls via mouse + shift key.\n\nEDIT: After some practical testing I realized that the area estimate of the projected disk becomes numerical unstable\nat acute viewing angles. The approximation implemented in ProjDiskApproxArea works well enough for small ellipses (plotted in gray).\n\nEDIT2: Maybe the short axis's direction coincides with that of the projected normal. \nIf so, there might be a more elegant and numerically stable approach for calculating the exact projected area...\n*/\n\n///////////////////////////////////////////////////////////////////////////\n//=======================================================================//\n\n#define Frame float(iFrame)\n#define Time iTime\n#define PixelCount iResolution.xy\n#define OUT\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n\nconst float Pi = 3.14159265359;\nconst float Pi2  = Pi * 2.0;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec3 Pow2(vec3 x) {return x*x;}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat GammaEncode(float x) {return pow(x, 1.0 / 2.2);}\nvec2 GammaEncode(vec2 x) {return pow(x, vec2(1.0 / 2.2));}\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\nvec4 GammaEncode(vec4 x) {return pow(x, vec4(1.0 / 2.2));}\n\n#define If(cond, tru, fls) mix(fls, tru, cond)\n\nvec2 dFdxy(float v) {return vec2(dFdx(v), dFdy(v));}\nfloat Linearize(float v) {return v * rsqrt(SqrLen(dFdxy(v)));}\n\n\n// \"Number Printing\"          | reformatted by iq (I assume)\n// by P_Malin                 | https://www.shadertoy.com/view/4sf3RN\n// used under CC BY-NC-SA 3.0 | https://creativecommons.org/licenses/by-nc-sa/3.0/ \n\nfloat SampleDigit(const in float n, const in vec2 vUV)\n{\t\t\n\tif(vUV.x  < 0.0) return 0.0;\n\tif(vUV.y  < 0.0) return 0.0;\n\tif(vUV.x >= 1.0) return 0.0;\n\tif(vUV.y >= 1.0) return 0.0;\n\t\n\tfloat data = 0.0;\n\t\n\t     if(n < 0.5) data = 7.0 + 5.0*16.0 + 5.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 1.5) data = 2.0 + 2.0*16.0 + 2.0*256.0 + 2.0*4096.0 + 2.0*65536.0;\n\telse if(n < 2.5) data = 7.0 + 1.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 3.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 4.5) data = 4.0 + 7.0*16.0 + 5.0*256.0 + 1.0*4096.0 + 1.0*65536.0;\n\telse if(n < 5.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 6.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 7.5) data = 4.0 + 4.0*16.0 + 4.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 8.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 9.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\t\n\tvec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n\tfloat fIndex = vPixel.x + (vPixel.y * 4.0);\n\t\n\treturn mod(floor(data / exp2(fIndex)), 2.0);\n}\n\nfloat PrintInt(const in vec2 uv, const in float value )\n{\n\tfloat res = 0.0;\n\tfloat maxDigits = 1.0+ceil(log2(value)/log2(10.0));\n\tfloat digitID = floor(uv.x);\n\tif( digitID>0.0 && digitID<maxDigits )\n\t{\n        float digitVa = mod( floor( value/pow(10.0,maxDigits-1.0-digitID) ), 10.0 );\n        res = SampleDigit( digitVa, vec2(fract(uv.x), uv.y) );\n\t}\n\n\treturn res;\t\n}\n//=======================================================================//\n///////////////////////////////////////////////////////////////////////////\n\n\n/*\nfloat Intersect_Ray_Disk(\nvec3 rp, vec3 rd,\nvec3 dp, vec3 dn, float drr,\nout float t)\n{\n    t = dot(rp - dp, dn) / -dot(rd, dn) ;\n    \n    if(t < 0.0) return 1.0;\n    \n    vec3 ip = rp + rd * t;\n    \n    return SqrLen(ip - dp) - drr;\n}\n*/\n\n/*\nProjSphereArea - returns the screen space area of the projection of a sphere (assuming its an ellipse)\n\nIN:\n\trdz- z component of the unnormalized ray direction in camera space\n\tp  - center position of the sphere in camera space\n\trr - squared radius of the sphere\n\n\"Sphere - projection\" code used under\nThe MIT License\nCopyright Â© 2014 Inigo Quilez\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\nfloat ProjSphereArea(float rdz, vec3 p, float rr)\n{\n\tfloat zz = p.z * p.z;\t\n\tfloat ll = dot(p, p);\n\t\n\t//return Pi * rdz*rdz * rr * sqrt(abs((rr - ll) / (zz - rr))) / (zz - rr);\n    return Pi * rdz*rdz * rr * rsqrt(abs(Pow3(rr - zz) / (rr - ll)));\n}\n        \n/*\nProjDiskApproxArea - returns the approx screen space area of the projection of a disk (assuming its an ellipse)\n\nIN:\n\trdz- z component of the unnormalized ray direction in camera space\n\tp  - center position of the disk in camera space\n\tn  - normalized normal of the disk in camera space\n\trr - squared radius of the disk\n\n*/\nfloat ProjDiskApproxArea(float rdz, vec3 p, vec3 n, float rr)\n{\n    float NdV = abs(dot(normalize(p), n));\n    \n    return ProjSphereArea(rdz, p, rr) * NdV;\n}\n\n/*\nIsPlaneBehind - returns true if ray intersects plane in negative direction\n\nIN:\n\trd - un/normalized ray direction\n\tp  - position on the plane realitve to the camera position\n\tn  - normalized normal of the plane\n*/\nbool IsPlaneBehind(vec3 rd, vec3 p, vec3 n) { return dot(rd, n) * dot(p, n) < 0.0; }\n\n\n/*\nProjDisk - returns the value and gradient for the screen space projection of a 3d disk\n\nIN:\n\trd - unnormalized ray direction in camera space\n\tp  - center position of the disk in camera space\n\tn  - normalized normal of the disk in camera space\n\trr - squared radius of the disk\n\nRETURNS: vec4(gradient, 0, value) \n*/\nvec4 ProjDisk(vec3 rd, vec3 p, vec3 n, float rr)\n{   \n    vec3 np0 = n * p.xyz;\n    vec3 np1 = n * p.yzx;\n    vec3 np2 = n * p.zxy;  \n\n    mat3x3 k_mat = mat3x3(vec3( np0.y + np0.z,  np2.x        ,  np1.x        ),\n\t\t\t\t\t\t  vec3(-np2.y        ,  np1.y        , -np0.x - np0.z),\n\t\t\t\t\t\t  vec3(-np1.z        , -np0.x - np0.y,  np2.z        ));    \n    \n    vec3 u =     k_mat * rd;\n    vec3 k = u * k_mat;\n    \n    \n    float nrd = dot(n, rd);\n    \n    float nrd_rr = nrd * rr;\n\n    \n    float v = dot(u, u) - nrd * nrd_rr; \n    vec3  g =    (k     - n   * nrd_rr) * 2.0;   \n    \n    return vec4(g.xy, 0.0, v);\n}\n\n/*\nProjDisk - calculates the value and gradient (+ more if ellipse) for the screen space projection of a 3d disk\n\nIN:\n\trd - unnormalized ray direction in camera space\n\tp  - center position of the disk in camera space\n\tn  - normalized normal of the disk in camera space\n\trr - squared radius of the disk\n\nOUT:\n\tval\t   - value of the quadratic function\n\tgrad   - gradient of the quadratic function\n\n\tif ellipse:\n\tcenter - screen space position of the center of the ellipse\n\taxis   - normalized screen space direction of the major axis (minor axis is perpendicular)\n\taxesL  - half length of both axes vec2(major, minor)\n\tA\t   - area\n\nRETURNS: true if projected shape is an ellipse \n*/\nbool ProjDisk(vec3 rd, vec3 p, vec3 n, float rr, \n               out float val, out vec3 grad, out vec2 center, out vec2 axis, out vec2 axesL, out float A)\n{       \n    vec3 np0 = n * p.xyz;\n    vec3 np1 = n * p.yzx;\n    vec3 np2 = n * p.zxy;   \n    \n    mat3x3 k_mat = mat3x3(vec3( np0.y + np0.z,  np2.x        ,  np1.x        ),\n\t\t\t\t\t\t  vec3(-np2.y        ,  np1.y        , -np0.x - np0.z),\n\t\t\t\t\t\t  vec3(-np1.z        , -np0.x - np0.y,  np2.z        ));    \n    \n    \n    vec3 c0 = vec3(dot(k_mat[0], k_mat[0]),\n                   dot(k_mat[1], k_mat[1]),\n                   dot(k_mat[2], k_mat[2])) - n     * n     * rr;\n\n    vec3 c1 = vec3(dot(k_mat[1], k_mat[0]),\n                   dot(k_mat[2], k_mat[0]),\n                   dot(k_mat[1], k_mat[2])) - n.xxy * n.yzz * rr;\n     \n    \n    val = dot(c0, rd     * rd    ) + \n          dot(c1, rd.xxy * rd.yzz) * 2.0;\n    \n    \n    mat3x3 g_mat = mat3x3(vec3(c0.x, c1.x, c1.y),\n\t\t\t\t\t\t  vec3(c1.x, c0.y, c1.z),\n\t\t\t\t\t\t  vec3(c1.y, c1.z, c0.z)); \n    \n    //grad = rd * g_mat * 2.0; \n    grad = vec3(dot(rd, g_mat[0]) * 2.0, \n                dot(rd, g_mat[1]) * 2.0, 0.0);\n    \n    \n    // assuming an ellipse from here on:\n    // http://mathworld.wolfram.com/Ellipse.html\n\n    float J = c0.x*c0.y - c1.x*c1.x;  \n    \n    #if 1\n    if(J <= 1.e-8) return false;// not an ellipse\n    #endif\n    \n    center = rd.z * (c1.xx * c1.zy - c0.yx * c1.yz) / J;\n\n    {\n        #if 1\n\t\t\n        float n = c0.x - c0.y;\n        float m = 2.0 * c1.x / n;\n        float cosAng = rsqrt(1.0 + Pow2(m));\n\n        axis.x = sqrt(cosAng * 0.5 + 0.5);\n        axis.y = sqrt(cosAng *-0.5 + 0.5) * (m < 0.0 ? -1.0 : 1.0);\n\t\t\n        if(n == 0.0) axis = vec2(0.0, 1.0);\n\n        #elif 0\n\n        float ang = atan(2.0 * c1.x / (c0.x - c0.y)) * 0.5;\n        axis = vec2(cos(ang), sin(ang));\n\n        #endif\n\n        if(c0.y < c0.x) axis = vec2(-axis.y, axis.x);\n    }\n    \n    {    \n        float a = c0.x;\n        float b = c1.x;\n        float c = c0.y;\n        float d = c1.y;// * rd.z;\n        float f = c1.z;// * rd.z;\n        float g = c0.z;// * rd.z*rd.z;\n        \n        #if 1\n        \n        float t0 = (a*f*f + c*d*d + g*b*b - 2.0*b*d*f - a*c*g) * rd.z*rd.z;\n        float t1 = a*c - b*b;\n        float t2 = sqrt(Pow2(a - c) + 4.0*b*b);\n        float t3 = a + c;\n        \n        float t10 = t1 / t0 * 0.5;\n        \n        axesL.x = rsqrt(t10 * (-t2 + t3));\n        axesL.y = rsqrt(t10 * ( t2 + t3));\n        \n        if(t0 <= 1.e-8) axesL = vec2(0.0);\n        \n        A = Pi * axesL.x*axesL.y;\n        \n        #elif 1\n        \n        float t0 = (a*f*f + c*d*d + g*b*b - 2.0*b*d*f - a*c*g) * rd.z*rd.z;\n        float t1 = a*c - b*b;\n        \n        A = Pi * t0 * rsqrt(t1*t1*t1); \n        \n        #endif      \n    }\n    \n    return true;\n}\n\n\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n    vec3 col = vec3(0.0);\n    \n    //vec2 uv = uv0.xy - 0.5;\n\t//vec2 tex = uv0.xy / PixelCount; \n    \n    vec4 mouseAccu = texelFetch(iChannel0, ivec2(1, 0), 0); \n\n    vec2 ang = vec2(Pi * 0.0, -Pi * 0.25*0.);\n    ang += mouseAccu.xy * 0.008;\n    \n    float fov = Pi * 0.6;\n    \n    mat3x3 cam_mat;\n    float focalLen;\n    {\n        float sinPhi   = sin(ang.x);\n        float cosPhi   = cos(ang.x);\n        float sinTheta = sin(ang.y);\n        float cosTheta = cos(ang.y);    \n\n        vec3 front = vec3(cosPhi * cosTheta, \n                                   sinTheta, \n                          sinPhi * cosTheta);\n\n        vec3 right = vec3(-sinPhi, 0.0, cosPhi);\n        vec3 up    = cross(right, front);\n\n        focalLen = PixelCount.x * 0.5 * tan(Pi05 - fov * 0.5);\n        \n        cam_mat = mat3x3(right, up, front);\n    }\n    \n    vec3 cpos = -cam_mat[2] * (exp2(2.0 + mouseAccu.w * 0.03));\n  \n    vec2 uv2 = uv0 - PixelCount.xy * 0.5;\n    \n    // unnormalized ray direction in camera space:\n  \tvec3 rdir0 = vec3(uv2, focalLen);\n    \n    // scaling to keep computations numerically sane (maps rdir0.x to (-1..1))\n    // requires multiplications by rdir0S further down the road\n    float rdir0S = 0.5 * PixelCount.x;\n    rdir0 /= rdir0S;\n    \n    // normalized ray direction in world space:\n    vec3 rdir = normalize(cam_mat * rdir0);\n    \n\n    // disk normal and position\n    #if 1\n    vec3 dn = normalize(vec3(1.0, 1.0, 1.));\n    vec3 dp = vec3(-1., 0., 1.);\n    float drr0 = 1.1;\n    float drr1 = 0.75;\n    #else\n    vec3 dn = normalize(vec3(.0, 1.0, 0.));\n    vec3 dp = vec3(0.0);\n    float drr0 = 1.1;\n    float drr1 = 0.8;  \n    #endif\n\n    // disk p and n in camera space\n    vec3 dp_c = (dp - cpos) * cam_mat;\n    vec3 dn_c = dn * cam_mat;\n\n    float val;\n    vec3 grad;\n    vec2 center = vec2(-2.0); \n    vec2 axis = vec2(1.0, 0.0); \n    vec2 axesL = vec2(0.0);\n    float A = 0.0;\n\n    bool elli = ProjDisk(rdir0, dp_c, dn_c, drr0, \n                         OUT val, grad, center, axis, axesL, A);\n \n    #if 0\n    // counting masked pixels in Mathematica: Count[Flatten@ImageData@(Import[\"download.png\"]), 0.]\n    outCol = vec4(val <= 0.0 ? 0.0 : 1.0, 1.0, 1.0, 1.0); return;\n\t#endif\n    \n    //col = vec3(grad.xy, 0.);//*clamp01(-sdf2)*4.0;\n    //col = vec3(dFdxy(val)*PixelCount.x, 0.);\n    //col = vec3(val);\n    //outCol = vec4(GammaEncode(clamp01(col)), 1.0); return;\n    \n    col = vec3(0.0);\n    \n    #if 1\n    col = texture(iChannel1, rdir).rgb;\n    col *= col;\n    #endif\n    \n    float cDist = length(rdir0.xy - center);\n    \n    #if 1\n    col = mix(col, vec3(0., 1., 0.), 1.0 - clamp01(abs(Linearize(cDist - axesL.x))-0.5));\n    #endif\n    \n    // deviding the func value by the length of its gradient gives us a decent sdf approx near zero:\n    // https://iquilezles.org/articles/distance\n    float circleMask = clamp01(-val * rsqrt(dot(grad.xy, grad.xy)) * rdir0S);\n    \n    float circleMask2 = 0.0;\n    #if 1\n    {\n        // Since we are only changing the radius for the inner disk, using the larger function again \n        // would allow the compiler to throw out a bunch of redundant calculations. \n        // But for demonstration purposes lets use the more compact one:\n\t\tvec4 r = ProjDisk(rdir0, dp_c, dn_c, drr1);\n        \n        circleMask2 = clamp01(r.w * rsqrt(dot(r.xy, r.xy)) * rdir0S);\n    }\n    #endif\n    \n    vec3 diskCol = vec3(1.0);\n    \n    #if 1\n    vec3 R = reflect(rdir, dn);\n    \n    diskCol = mix(Pow2(texture(iChannel1, R).rgb), \n                       texture(iChannel2, R).rgb , circleMask2);\n    \n    float NdV = dot(dn, rdir);\n    \n    vec3 f01 = NdV > 0.0 ? vec3(1.0, 0.5, 0.0) : vec3(0.0, 0.5, 1.0);\n    vec3 f02 = NdV <=0.0 ? vec3(1.0, 0.5, 0.0) : vec3(0.0, 0.5, 1.0);\n    \n    vec3 f0 = mix(f01, f02, circleMask2);\n    \n    diskCol *= mix(f0, vec3(1.0), pow(1.0 - abs(NdV), 5.0)); \n    #endif\n    \n    col = mix(col, diskCol, circleMask);\n    \n    #if 1\n    float o0 = dot(rdir0.xy - center, vec2( axis.x, axis.y));\n    float o1 = dot(rdir0.xy - center, vec2(-axis.y, axis.x));\n    \n    col = mix(col, vec3(0., 0., 1.), (1.0 - clamp01(-0.5+abs(Linearize(o0)))) * (1.0 - clamp01(Linearize(abs(o1) - axesL.y))));\n    col = mix(col, vec3(0., 1., 1.), (1.0 - clamp01(-0.5+abs(Linearize(o1)))) * (1.0 - clamp01(Linearize(abs(o0) - axesL.x))));\n    \n    col = mix(col, vec3(1., 0., 1.), 1.0 - clamp01((Linearize(cDist) - 2.0)));\n\n\tcol = mix(col, vec3(1., 0., 0.), 1.0 - clamp01(-0.5+abs(Linearize(cDist - axesL.y))));\n    #endif\n    \n\n    A *= rdir0S*rdir0S;// now we have an upper bound to the pixel count\n\n    col += vec3(PrintInt(uv0*0.0625, A));\n    \n    \n    float A2 = ProjDiskApproxArea(rdir0.z, dp_c, dn_c, drr0);\n\n\tA2 *= rdir0S*rdir0S;\n\n    col += vec3(PrintInt((uv0-vec2(0.0, 32.0))*0.0625, A2)) * 0.5;\n\n        \n    #if 0\n    {\n\t// this version just approx projects a semi-axis of the disk to the screen and calcs the area of a circle scaled by N dot V:\n    // only works well around the center of the screen\n    float d = dot(dp - cpos, cam_mat[2]);\n    float area2 = Pi * drr0 * Pow2(rdir0.z / d);\n    area2 *= NdV;   \n    area2 *= rdir0S*rdir0S;\n    \n    col += vec3(PrintInt((uv0-vec2(0.0, 64.0))*0.0625, area2)) * 0.25;\n    }\n\t#endif        \n    \n    \n    \n\toutCol = vec4(GammaEncode(clamp01(col)), 1.0);\n}\n\n\n\n/*\nfloat ProjDiskImplicit(vec3 rp, vec3 rd, float rr)\n{\n    return Pow2(rp.y - (rp.x * rd.y) / rd.x) + Pow2(rp.z - (rp.x * rd.z) / rd.x) - rr;\n}\n\nvec3 ProjDiskImplicit_Gradient(vec3 rp, vec3 rd)\n{\n    float rdx_rcp = 1.0 / rd.x;\n    \n    vec2 yz = 2.0 * rp.xx * (rp.xx * rd.yz * rdx_rcp - rp.yz) * rdx_rcp;\n    \n    return vec3((-rd.y * yz.x - rd.z * yz.y) * rdx_rcp, yz);\n}\n\nfloat ProjDiskImplicit2(vec3 rp, vec3 rd, float rr)\n{\n    return Pow2(rp.y * rd.x - rp.x * rd.y) + Pow2(rp.z * rd.x - rp.x * rd.z) - rr * Pow2(rd.x);\n}\n\nvec3 ProjDiskImplicit2_Gradient(vec3 rp, vec3 rd, float rr)\n{\n    vec2 t = (rd.yz * rp.xx) - (rd.xx * rp.yz);\n    \n    return 2.0 * vec3(-(rr * rd.x) - (rp.y * t.x) - (rp.z * t.y), rp.xx * t);\n}\n\n    #if 0\n    vec3 oy, oz;\n    OrthonormalBasisRH(dn, OUT oz, oy);\n    mat3 mat = mat3(dn, oy, oz);\n\n    vec3 cpos2 = (cpos - dp) * mat;\n    vec3 rdir2 = rdir0 * mat;\n    \n    sdf = ProjDiskImplicit2(cpos2, rdir2, 1.0);\n    grad = mat * ProjDiskImplicit2_Gradient((cpos - dp) * mat, rdir0 * mat, 1.0);\n    \n    \n    vec2 grad2 = vec2(dot(grad, cRight2), dot(grad, cUp2)); \n    #endif\n\nvec4 ProjDiskImplicit2(vec3 rd, vec3 p, vec3 n, float rr)\n{   \n    vec3 np0 = n * p.xyz;\n    vec3 np1 = n * p.yzx;\n    vec3 np2 = n * p.zxy;\n    \n    vec3 np0Sqr = np0 * np0;\n    vec3 np1Sqr = np1 * np1;\n    vec3 np2Sqr = np2 * np2;\n    \n    float rdxSqrC = np0Sqr.y + 2.0*np0.y*np0.z + np0Sqr.z + np1Sqr.x + np2Sqr.x;\n    float rdySqrC = np0Sqr.x + 2.0*np0.x*np0.z + np0Sqr.z + np1Sqr.y + np2Sqr.y;\n    float rdzSqrC = np0Sqr.x + 2.0*np0.x*np0.y + np0Sqr.y + np1Sqr.z + np2Sqr.z;\n    \n    float rdyzC = 2.0 * (-np0.x*np1.y - np0.y*np1.y + np1.z*np2.y - np0.x*np2.z - np0.z*np2.z);\n    float rdxyC = 2.0 * (-np0.x*np1.x - np0.z*np1.x + np1.y*np2.x - np0.y*np2.y - np0.z*np2.y);\n    float rdxzC = 2.0 * (-np0.y*np1.z - np0.z*np1.z + np1.x*np2.z - np0.x*np2.x - np0.y*np2.x);\n    \n    rdxSqrC -= n.x*n.x * rr;\n    rdySqrC -= n.y*n.y * rr;\n    rdzSqrC -= n.z*n.z * rr;\n    \n    rdyzC -= 2.0 * n.y*n.z * rr;\n    rdxyC -= 2.0 * n.x*n.y * rr;\n    rdxzC -= 2.0 * n.x*n.z * rr;\n    \n       \n    float v = dot(vec3(rdxSqrC, rdySqrC, rdzSqrC), rd * rd) + \n              dot(vec3(  rdyzC,   rdxyC,   rdxzC), vec3(rd.y*rd.z, rd.x*rd.y, rd.x*rd.z));\n    \n    mat3x3 g_mat = mat3x3(vec3(2.0*rdxSqrC,       rdxyC,       rdxzC),\n\t\t\t\t\t\t  vec3(      rdxyC, 2.0*rdySqrC,       rdyzC),\n\t\t\t\t\t\t  vec3(      rdxzC,       rdyzC, 2.0*rdzSqrC)); \n    \n    vec3 g = rd * g_mat;      \n    \n    //g2 = 2.0 * vec3(rdxSqrC, rdySqrC, rdzSqrC);\n    \n    return vec4(g, v);\n}\n\nvec4 ProjDiskImplicit3(vec3 rd, vec3 p, vec3 n, float rr)\n{\n    float nrd = dot(n, rd);\n    \n    vec3 np0 = n * p.xyz;\n    vec3 np1 = n * p.yzx;\n    vec3 np2 = n * p.zxy;\n    \n    vec3 u;\n    #if 0\n    u.x = n.y*p.y*rd.x - n.y*p.x*rd.y - n.z*p.x*rd.z + n.z*p.z*rd.x;\n    u.y = n.x*p.z*rd.x + n.y*p.z*rd.y - n.y*p.y*rd.z - n.x*p.x*rd.z;\n    u.z = n.x*p.y*rd.x - n.x*p.x*rd.y + n.z*p.y*rd.z - n.z*p.z*rd.y;\n    #else\n    u.x = dot(vec4(np0.y, -np2.y, -np1.z,  np0.z), rd.xyzx);\n    u.y = dot(vec4(np2.x,  np1.y, -np0.y, -np0.x), rd.xyzz);\n    u.z = dot(vec4(np1.x, -np0.x,  np2.z, -np0.z), rd.xyzy);\n    #endif\n    \n    float v = dot(u, u) - rr * Pow2(nrd);\n    \n    \n    vec3 g;\n    \n    #if 0\n    g.x = dot(vec3( (n.y*p.y + n.z*p.z),  (n.x*p.z), (n.x*p.y)), u);\n    g.y = dot(vec3(-(n.y*p.x), (n.y*p.z), (-n.x*p.x - n.z*p.z)), u);\n    g.z = dot(vec3(-(n.z*p.x), (-n.x*p.x - n.y*p.y), (n.z*p.y)), u);\n    #else\n\tg.x = dot(vec3( np0.y  +np0.z,  np2.x,  np1.x), u);\n    g.y = dot(vec3(-np2.y,  np1.y, -np0.x  -np0.z), u);\n    g.z = dot(vec3(-np1.z, -np0.x  -np0.y,  np2.z), u);\n    #endif    \n    \n    return vec4(2.0 * (g - n * (rr * nrd)), v);\n}\n*/\n    \n    ",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nvoid mainImage( out vec4 col, in vec2 uv0 )\n{  \n    col = vec4(0.0);\n    \n    vec2 uv = uv0 - 0.5;\n    \n    \n    vec4 iMouseLast     = texelFetch(iChannel0, ivec2(0, 0), 0);\n    vec4 iMouseAccuLast = texelFetch(iChannel0, ivec2(1, 0), 0);\n\n    bool shift = texelFetch(iChannel1, ivec2(16, 0), 0).x != 0.0;\n    \n    vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n    \n    bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n    vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n    vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n    \n    vec2 iMouseAccu1 = iMouseAccuLast.xy + mouseDelta2;\n    vec2 iMouseAccu2 = iMouseAccuLast.zw + mouseDelta3;\n    \n    if(uv.x == 0.0 && uv.y == 0.0) col = iMouse;  \n    if(uv.x == 1.0 && uv.y == 0.0) col = vec4(iMouseAccu1, iMouseAccu2);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}