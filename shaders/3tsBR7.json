{
    "Shader": {
        "info": {
            "date": "1596403709",
            "description": "Using small number of radial shapes and stochastic position offsets to simulate volumetric lighting effect. Biggest drawback to this technique is that shadow casting is not possible. ",
            "flags": 0,
            "hasliked": 0,
            "id": "3tsBR7",
            "likes": 25,
            "name": "Flashlight Chase",
            "published": 3,
            "tags": [
                "fast",
                "light",
                "cheap",
                "dither",
                "volumetric",
                "cone",
                "hack",
                "bluenoise",
                "performant"
            ],
            "usePreview": 0,
            "username": "granito",
            "viewed": 842
        },
        "renderpass": [
            {
                "code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float T = iTime + 2.5; \n    vec2 uv = fragCoord/iResolution.xy;\n    float bnoise;\n    \n    if (dithering == true)\n    { bnoise = fract( texture( iChannel0, fragCoord/1024.).x + T ); } //animated bluenoise pattern}\n    else\n    { bnoise = 0.5; }\n    \n    //3d camera\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n\tvec3 rd = normalize( vec3(p,-2.0) );\n    vec3 ro = vec3(0.0, 0.0, 5.0 );\n    \n    //running animation\n    float runtransition = smoothstep( 0., 1., sin(T*0.3));\n    float runadvancement = -cos(T*0.3) *1.2;\n    float runpos = abs(sin(T * 9.0)) * runtransition * 0.25;\n    float runrot = sin(T * 9.0 * 2. + 0.5) * runtransition * runtransition * 0.15 - 0.6;\n    float sway = cos(T * 9.0 + 0.5) * runtransition * runtransition * runtransition * 0.1;\n    \n    //flashlight setup\n    vec3 conepos = vec3(-0.3, runpos, runadvancement * 2.0 + 1.0);\n    vec3 conedirection;\n    conedirection = mix( normalize( vec3(sin(T),cos(T*0.6),-cos(T*0.3)+0.4) + vec3(cos(T*2.6),sin(T*2.2),-sin(T*2.3))*0.6 ), vec3(0., runrot, 0.), vec3(runtransition) );\n    float conelength = 2.0;\n    float coneangle = 1.1;\n    \n    //draw eyes\n    float eyes = draweye(ro, rd, conepos + vec3(0.25,0.75,-0.5) ) + draweye(ro, rd, conepos + vec3(0.4,0.75,-0.5) ) ;\n    eyes *= round(fract(T*0.45)+0.4);\n    \n    //add sway motion\n    conepos += mix( vec3(0.), vec3(sway, 0., 0.), vec3(runtransition) );\n    conedirection += vec3(sway, 0., 0.);\n    \n    //draw flashlight/volume light\n    float source = drawsource(ro, rd, conepos);\n    float cone = drawcone(ro, rd, conepos, conedirection, conelength, coneangle, bnoise);\n\n    //composite/color\n    fragColor = vec4(aces( vec3(source + cone) * vec3(0.7,0.9,1.) + vec3(eyes) * vec3(1.,0.,0.)   ) ,1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nint iterations = 8;\nbool dithering = true;\n\n\nfloat saturate (float x) { return clamp(x, 0., 1.); }\n\nvec3 aces(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nfloat distline(vec3 ro, vec3 rd, vec3 p) {\n\treturn length(cross(p-ro, rd));\n}\n\nfloat draweye (vec3 ro, vec3 rd, vec3 cp)\n{\n    float shape = 1. - saturate(distline(ro, rd, cp) * 125.  );\n    return shape * 10.;\n}\n\nfloat drawsource (vec3 ro, vec3 rd, vec3 cp)\n{\n    float shape = 1. - saturate(distline(ro, rd, cp) * 25.  );\n    return (pow(shape,8.) * 40. + shape) * 2.;\n}\n\nfloat drawcone (vec3 ro, vec3 rd, vec3 cp, vec3 cd, float cl, float ca, float dither)\n{\n    float radialshapes;\n    float increment = 1. / float(iterations);\n    float spacing = cl * increment;\n    \n    for(int x = 0; x < iterations - 1; x++) //radialshapes\n    {\n        float iter = max( float(x) + (dither * 2. - 1.0) * 1.0, 0.001); // add dithering (hide iteration)\n        float localpos = iter * spacing; //distance along forward vector of cone\n        vec3 spos = localpos * cd + cp;\n        float ssize = ( max((2. * localpos), iter) / tan(ca) ) ; // isosceles base length\n    \tfloat shape = 1. - saturate( distline(ro, rd, spos) / ssize );\n        shape *= shape;\n        shape *= (1. / iter) * (1. / iter);\n        radialshapes += shape;\n    }\n    return radialshapes;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}