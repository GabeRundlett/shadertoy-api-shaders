{
    "Shader": {
        "info": {
            "date": "1457616278",
            "description": "A daytime version of my \"Cheap Cloud Flythrough\" example.",
            "flags": 0,
            "hasliked": 0,
            "id": "MscXRH",
            "likes": 101,
            "name": "Combustible Clouds",
            "published": 3,
            "tags": [
                "noise",
                "cloud",
                "volumetric",
                "sinusoidal",
                "flythrough"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 6432
        },
        "renderpass": [
            {
                "code": "/*\n\n\tCombustible Clouds\n\t------------------\n\t\n\tThis is just a daytime version of my cheap cloud flythrough example. I'm not sure why\n\tthe clouds exist in a combustible atmosphere, or if that's even possible... but it's \n\tjust a cheap hack, so isn't meant to be taken seriously. :)\n\n\tObviously, the object of the exercise was speed, rather than quality, so it should run\n\tpretty well on even the slowest of machines. With that said, the quality is pretty good,\n\tall things considered.\n\t\n\tBased on:\n\t\n\tCloudy Spikeball - Duke\n    https://www.shadertoy.com/view/MljXDw\n    // Port from a demo by Las - Worth watching.\n    // http://www.pouet.net/topic.php?which=7920&page=29&x=14&y=9\n\n*/\n\n// Hash function. This particular one probably doesn't disperse things quite \n// as nicely as some of the others around, but it's compact, and seems to work.\n//\nvec3 hash33(vec3 p){ \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\n\n// IQ's texture lookup noise... in obfuscated form. There's less writing, so\n// that makes it faster. That's how optimization works, right? :) Seriously,\n// though, refer to IQ's original for the proper function.\n// \n// By the way, you could replace this with the non-textured version, and the\n// shader should run at almost the same efficiency.\nfloat n3D( in vec3 p ){\n    \n    vec3 i = floor(p); p -= i; p *= p*(3. - 2.*p);\n\tp.xy = texture(iChannel0, (p.xy + i.xy + vec2(37, 17)*i.z + .5)/256., -100.).yx;\n\treturn mix(p.x, p.y, p.z);\n}\n\n/*\n// Textureless 3D Value Noise:\n//\n// This is a rewrite of IQ's original. It's self contained, which makes it much\n// easier to copy and paste. I've also tried my best to minimize the amount of \n// operations to lessen the work the GPU has to do, but I think there's room for\n// improvement. I have no idea whether it's faster or not. It could be slower,\n// for all I know, but it doesn't really matter, because in its current state, \n// it's still no match for IQ's texture-based, smooth 3D value noise.\n//\n// By the way, a few people have managed to reduce the original down to this state, \n// but I haven't come across any who have taken it further. If you know of any, I'd\n// love to hear about it.\n//\n// I've tried to come up with some clever way to improve the randomization line\n// (h = mix(fract...), but so far, nothing's come to mind.\nfloat n3D(vec3 p){\n    \n    // Just some random figures, analogous to stride. You can change this, if you want.\n\tconst vec3 s = vec3(7, 157, 113);\n\t\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    \n    // Setting up the stride vector for randomization and interpolation, kind of. \n    // All kinds of shortcuts are taken here. Refer to IQ's original formula.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; // Cell's fractional component.\n\t\n    // A bit of cubic smoothing, to give the noise that rounded look.\n    p = p*p*(3. - 2.*p);\n    \n    // Smoother version of the above. Weirdly, the extra calculations can sometimes\n    // create a surface that's easier to hone in on, and can actually speed things up.\n    // Having said that, I'm sticking with the simpler version above.\n\t//p = p*p*p*(p*(p * 6. - 15.) + 10.);\n    \n    // Even smoother, but this would have to be slower, surely?\n\t//vec3 p3 = p*p*p; p = ( 7. + ( p3 - 7. ) * p ) * p3;\t\n\t\n    // Cosinusoidal smoothing. OK, but I prefer other methods.\n    //p = .5 - .5*cos(p*3.14159);\n    \n    // Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\n    // then interpolating along X. There are countless ways to randomize, but this is\n    // the way most are familar with: fract(sin(x)*largeNumber).\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\t\n    // Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    // Interpolating along Z, and returning the 3D noise value.\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n}\n\n*/\n\n// Basic low quality noise consisting of three layers of rotated, mutated \n// trigonometric functions. Needs work, but sufficient for this example.\nfloat trigNoise3D(in vec3 p){\n\n    \n    float res = 0., sum = 0.;\n    \n    // IQ's cheap, texture-lookup noise function. Very efficient, but still \n    // a little too processor intensive for multiple layer usage in a largish \n    // \"for loop\" setup. Therefore, just one layer is being used here.\n    float n = n3D(p*8. + iTime*2.);\n\n\n    // Two sinusoidal layers. I'm pretty sure you could get rid of one of \n    // the swizzles (I have a feeling the GPU doesn't like them as much), \n    // which I'll try to do later.\n    \n    vec3 t = sin(p.yzx*3.14159265 + cos(p.zxy*3.14159265+1.57/2.))*0.5 + 0.5;\n    p = p*1.5 + (t - 1.5); //  + iTime*0.1\n    res += (dot(t, vec3(0.333)));\n\n    t = sin(p.yzx*3.14159265 + cos(p.zxy*3.14159265+1.57/2.))*0.5 + 0.5;\n    res += (dot(t, vec3(0.333)))*0.7071;    \n\t \n\treturn ((res/1.7071))*0.85 + n*0.15;\n}\n\n// Distance function.\nfloat map(vec3 p) {\n\n    return trigNoise3D(p*.5);\n    \n    // Three layers of noise, for comparison.\n    //p += iTime;\n    //return n3D(p*.75)*.57 + n3D(p*1.875)*.28 + n3D(p*4.6875)*.15;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\n    // Unit direction ray vector: Note the absence of a divide term. I came across\n    // this via a comment Shadertoy user \"coyote\" made. I'm pretty easy to please,\n    // but I thought it was pretty cool.\n    vec3 rd = normalize(vec3(fragCoord - iResolution.xy*.5, iResolution.y*.75)); \n\n    // Ray origin. Moving along the Z-axis.\n    vec3 ro = vec3(0, 0, iTime*4.);\n\n    // Cheap camera rotation.\n    //\n    // 2D rotation matrix. Note the absence of a cos variable. It's there, but in disguise.\n    // This one came courtesy of Shadertoy user, \"Fabrice Neyret.\"\n    vec2 a = sin(vec2(1.5707963, 0) + iTime*0.1875); \n    mat2 rM = mat2(a, -a.y, a.x);\n    \n    rd.xy = rd.xy*rM; // Apparently, \"rd.xy *= rM\" doesn't work on some setups. Crazy.\n    a = sin(vec2(1.5707963, 0) + cos(iTime*0.1875*.7)*.7);\n    rM = mat2(a, -a.y, a.x); \n    rd.xz = rd.xz*rM;\n\n    // Placing a light in front of the viewer and up a little. You could just make the \n    // light directional and be done with it, but giving it some point-like qualities \n    // makes it a little more interesting. You could also rotate it in sync with the \n    // camera, like a light beam from a flying vehicle.\n    vec3 lp = vec3(0, 1, 6);\n    //lp.xz = lp.xz*rM;\n    lp += ro;\n    \n    \n\n    // The ray is effectively marching through discontinuous slices of noise, so at certain\n    // angles, you can see the separation. A bit of randomization can mask that, to a degree.\n    // At the end of the day, it's not a perfect process. Note, the ray is deliberately left \n    // unnormalized... if that's a word.\n    //\n    // Randomizing the direction.\n    //rd = (rd + (hash33(rd.zyx)*0.004-0.002)); \n    // Randomizing the length also. \n    //rd *= (1. + fract(sin(dot(vec3(7, 157, 113), rd.zyx))*43758.5453)*0.04-0.02);  \n    \n    //rd = rd*.5 + normalize(rd)*.5;    \n    \n    // Some more randomization, to be used for color based jittering inside the loop.\n    vec3 rnd = hash33(rd + 311.);\n\n    // Local density, total density, and weighting factor.\n    float lDe = 0., td = 0., w = 0.;\n\n    // Closest surface distance, and total ray distance travelled.\n    float d = 1., t = dot(rnd, vec3(.08));\n\n    // Distance threshold. Higher numbers give thicker clouds, but fill up the screen too much.    \n    const float h = .5;\n\n\n    // Initializing the scene color to black, and declaring the surface position vector.\n    vec3 col = vec3(0), sp;\n\n\n\n    // Particle surface normal.\n    //\n    // Here's my hacky reasoning. I'd imagine you're going to hit the particle front on, so the normal\n    // would just be the opposite of the unit direction ray. However particles are particles, so there'd\n    // be some randomness attached... Yeah, I'm not buying it either. :)\n    vec3 sn = normalize(hash33(rd.yxz)*.03-rd);\n\n    // Raymarching loop.\n    for (int i=0; i<64; i++) {\n\n        // Loop break conditions. Seems to work, but let me\n        // know if I've overlooked something.\n        if((td>1.) || d<.001*t || t>80.)break;\n\n\n        sp = ro + rd*t; // Current ray position.\n        d = map(sp); // Closest distance to the surface... particle.\n\n        // If we get within a certain distance, \"h,\" of the surface, accumulate some surface values.\n        // The \"step\" function is a branchless way to do an if statement, in case you're wondering.\n        //\n        // Values further away have less influence on the total. When you accumulate layers, you'll\n        // usually need some kind of weighting algorithm based on some identifying factor - in this\n        // case, it's distance. This is one of many ways to do it. In fact, you'll see variations on \n        // the following lines all over the place.\n        //\n        lDe = (h - d) * step(d, h); \n        w = (1. - td) * lDe;   \n\n        // Use the weighting factor to accumulate density. How you do this is up to you. \n        td += w*w*8. + 1./60.; //w*w*5. + 1./50.;\n        //td += w*.4 + 1./45.; // Looks cleaner, but a little washed out.\n\n\n        // Point light calculations.\n        vec3 ld = lp-sp; // Direction vector from the surface to the light position.\n        float lDist = max(length(ld), 0.001); // Distance from the surface to the light.\n        ld/=lDist; // Normalizing the directional light vector.\n\n        // Using the light distance to perform some falloff.\n        float atten = 1./(1. + lDist*0.1 + lDist*lDist*.03);\n\n        // Ok, these don't entirely correlate with tracing through transparent particles,\n        // but they add a little anglular based highlighting in order to fake proper lighting...\n        // if that makes any sense. I wouldn't be surprised if the specular term isn't needed,\n        // or could be taken outside the loop.\n        float diff = max(dot(sn, ld ), 0.);\n        float spec = pow(max(dot( reflect(-ld, sn), -rd ), 0.), 4.);\n\n\n        // Accumulating the color. Note that I'm only adding a scalar value, in this case,\n        // but you can add color combinations.\n        col += w*(1.+ diff*.5 + spec*.5)*atten;\n        // Optional extra: Color-based jittering. Roughens up the grey clouds that hit the camera lens.\n        col += (fract(rnd*289. + t*41.) - .5)*.02;;\n\n        // Try this instead, to see what it looks like without the fake contrasting. Obviously,\n        // much faster.\n        //col += w*atten*1.25;\n\n\n        // Enforce minimum stepsize. This is probably the most important part of the procedure.\n        // It reminds me a little of the soft shadows routine.\n        t +=  max(d*.5, .02); //\n        // t += 0.2; // t += d*0.5;// These also work, but don't seem as efficient.\n\n    }\n    \n    col = max(col, 0.);\n\n    \n    // Adding a bit of a firey tinge to the cloud value.\n    col = mix(pow(vec3(1.3, 1, 1)*col, vec3(1, 2, 10)), col, dot(cos(rd*6. +sin(rd.yzx*6.)), vec3(.333))*.2+.8);\n \n    // Using the light position to produce a blueish sky and sun. Pretty standard.\n    vec3 sky = vec3(.6, .8, 1.)*min((1.5+rd.y*.5)/2., 1.); \t\n    sky = mix(vec3(1, 1, .9), vec3(.31, .42, .53), rd.y*0.5 + 0.5);\n    \n    float sun = clamp(dot(normalize(lp-ro), rd), 0.0, 1.0);\n   \n    // Combining the clouds, sky and sun to produce the final color.\n    sky += vec3(1, .3, .05)*pow(sun, 5.)*.25; \n    sky += vec3(1, .4, .05)*pow(sun, 16.)*.35; \t\n    col = mix(col, sky, smoothstep(0., 25., t));\n \tcol += vec3(1, .6, .05)*pow(sun, 16.)*.25; \t\n \n    // Done.\n    fragColor = vec4(sqrt(min(col, 1.)), 1.0);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}