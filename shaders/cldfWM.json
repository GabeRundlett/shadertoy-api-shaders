{
    "Shader": {
        "info": {
            "date": "1701302861",
            "description": "Taking a closer look at the quality of SDF with the Subtract and Intersect CSG operations.\nThe shape is formed by Intersecting two half-planes and then Subtracting a circle.\nFollowing up on discussion in https://www.shadertoy.com/view/dldfW8 .",
            "flags": 0,
            "hasliked": 0,
            "id": "cldfWM",
            "likes": 10,
            "name": "SDF quality w Bounds operators",
            "published": 3,
            "tags": [
                "sdf",
                "intersection",
                "subtraction",
                "continuity"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 202
        },
        "renderpass": [
            {
                "code": "/*\n\nFollowing up on discussion in https://www.shadertoy.com/view/dldfW8 .\n\n*/\n\nfloat zoom = 1.0;  // smaller = zoomed in\n\nfloat map(in vec2 p) {\n\n    float circleRad     = 100.0;\n    vec2  circleCen     = vec2(-(circleRad + 1.0), 0.0);\n    \n    float sdHalfPlane1  = p.x;\n    float sdHalfPlane2  = p.y;\n    float sdCircle      = length(p - circleCen) - circleRad;\n    \n    float sdIntersected = max(sdHalfPlane1 ,  sdHalfPlane2);\n    float sdSubtracted  = max(sdIntersected, -sdCircle);\n    \n    return sdSubtracted;\n}\n\nvoid drawCircle(inout vec3 rgb, in vec2 p, in vec2 c, float r) {\n    float d = length(p - c) - r;\n    float f = abs(d) - zoom;\n    vec3  q = vec3(0.8, 1.0, 0.0);\n    // interior\n    rgb = mix(rgb, q, 0.1 * smoothstep(1.0, 0.0, d));\n    // edge\n    rgb = mix(rgb, q,       smoothstep(1.0, 0.0, f));\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    vec2  p = XY        - iResolution.xy / 2.0;\n    vec2  m = iMouse.xy - iResolution.xy / 2.0;\n    if (length(iMouse.xy) < 100.0) {\n        m.x = cos(iTime * 0.3);\n        m.y = sin(iTime * 0.3);\n        m *= iResolution.xy * 0.4;\n    }\n    \n    p *= zoom;\n    m *= zoom;\n    \n    float d = map(p);\n    \n    vec3 c    = vec3(1e9, 0.0, 1e9);\n    vec3 cIn  = vec3(0.3, 0.5, 0.8);\n    vec3 cOut = vec3(0.7, 0.4, 0.2);\n    vec3 cBrd = vec3(1.0);\n    \n    // there's probably a cleaner way to get contour lines\n    // of sort-of-constant width w/r/t zoom,\n    // but I don't think I'm invalidating the SDF here.\n    \n    bool wideBands = bool((int(iTime) / 5) % 2);\n    \n    float distanceScaleForBands = 0.6;\n    float f                     = mix(0.6, 1.0, 1.0 - zoom);\n   \n    if (wideBands) {\n        distanceScaleForBands = 0.05;\n        f                     = -1.0;\n    }\n    \n    float sinD = sin(d * distanceScaleForBands - iTime * 3.0);\n    \n    // inside the SDF\n    c = mix(c, cIn , smoothstep( 0.0, zoom, -d));\n    \n    // outside the SDF\n    c = mix(c, cOut, smoothstep( 0.0, zoom,  d));\n    \n    // isolines\n    c *= 0.5 + 0.5 * smoothstep( f, 1.0, sinD);\n    \n    // boundary of the SDF\n    c = mix(c, cBrd, smoothstep( zoom, 0.0,  abs(d) - zoom));\n    \n    // draw the distance at the mouse point,\n    drawCircle(c, p, m, abs(map(m)));\n    drawCircle(c, p, m, 2.0 * zoom);\n    \n    RGBA.rgb = c;\n    RGBA.a   = 1.0;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}