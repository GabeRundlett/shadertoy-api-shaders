{
    "Shader": {
        "info": {
            "date": "1438695279",
            "description": "That's for those who don't like [url=https://www.shadertoy.com/view/XllXRf]ros√©[/url] (but who like [url=https://www.shadertoy.com/view/ltfXDM]diamonds[/url]?) ;).",
            "flags": 0,
            "hasliked": 0,
            "id": "llsXzf",
            "likes": 14,
            "name": "A cup of champagne",
            "published": 3,
            "tags": [
                "raymarching",
                "transparency"
            ],
            "usePreview": 0,
            "username": "Nrx",
            "viewed": 1052
        },
        "renderpass": [
            {
                "code": "// Rendering parameters\n#define RAY_LENGTH_MAX\t\t20.0\n#define RAY_BOUNCE_MAX\t\t10\n#define RAY_STEP_MAX\t\t80\n#define LIGHT\t\t\t\tvec3 (1.0, 1.0, -1.0)\n#define AMBIENT\t\t\t\t0.2\n#define SPECULAR_POWER\t\t3.0\n#define SPECULAR_INTENSITY\t0.5\n#define DEFORMATION\t\t\t2.2\n\n// Rendering options (for those who have a slow GPU)\n#define PROPAGATION\n#define DISPERSION\n\n// Macros used to handle color channels\n#ifdef DISPERSION\n\t#define COLOR float\n\t#define CHANNEL(x) dot (x, channel)\n#else\n\t#define COLOR vec3\n\t#define CHANNEL(x) x\n#endif\n\n// Math constants\n#define DELTA\t0.001\n#define PI\t\t3.14159265359\n\n// Smooth minimum\nfloat smin (in float a, in float b, in float k) {\n\tfloat h = clamp (0.5 + 0.5 * (a - b) / k, 0.0, 1.0);\n\treturn mix (a, b, h) - k * h * (1.0 - h);\n}\n\n// Materials\nstruct Material {\n\tvec3 color;\n\tfloat behavior; // from -1.0 (fully reflective) to 1.0 (fully transparent)\n\tvec3 refractIndex; // not used if behavior < 0.0\n};\nMaterial getMaterial (in int materialIndex) {\n\tMaterial material;\n\tif (materialIndex == 0) { // Glass\n\t\tmaterial = Material (vec3 (0.8, 0.8, 0.8), 0.9, vec3 (1.50, 1.55, 1.60));\n\t} else if (materialIndex == 1) { // Champagne\n\t\tmaterial = Material (vec3 (1.0, 1.0, 0.0), 0.8, vec3 (1.50, 1.55, 1.60));\n    } else { // materialIndex == 2 // Table\n\t\tmaterial = Material (vec3 (0.5, 0.5, 1.0), -0.5, vec3 (2.0, 2.1, 2.2));\n\t}\n\treturn material;\n}\n\n// Distance to the glass\nfloat getDistanceGlass (in vec3 p, in float d, in float dxz) {\n\td = max (max (d - 1.45, 1.4 - d) / DEFORMATION, p.y - 0.4);\n\td = min (d, max (dxz - 0.5, p.y + 2.5));\n\td = smin (d, max (dxz - 0.08, p.y + 1.4), 0.1);\n\treturn max (d, -p.y - 2.55);\n}\n\n// Distance to the champagne\nfloat getDistanceChampagne (in vec3 p, in float d) {\n\td = max ((d - 1.4) / DEFORMATION, p.y + p.x * 0.1 * cos (iTime * 2.0));\n\treturn max (d, 0.015 - length (mod (p - vec3 (0.0, iTime, 0.0), 0.4) - 0.2));\n}\n\n// Distance to the table\nfloat getDistanceTable (in vec3 p, in float dxz) {\n\treturn max (max (dxz - 1.6, p.y + 2.55), -p.y - 3.2);\n}\n\n// Distance to a given material\nfloat getDistanceMaterial (in vec3 p, in int materialIndex) {\n\tfloat materialDist;\n\tif (materialIndex == 0) {\n\t\tmaterialDist = getDistanceGlass (p, length (p * vec3 (DEFORMATION, 1.0, DEFORMATION)), length (p.xz));\n\t} else if (materialIndex == 1) {\n\t\tmaterialDist = getDistanceChampagne (p, length (p * vec3 (DEFORMATION, 1.0, DEFORMATION)));\n    } else { // materialIndex == 2\n\t\tmaterialDist = getDistanceTable (p, length (p.xz));\n\t}\n\treturn materialDist;\n}\n\n// Distance to the scene\n#define MATERIAL_PROCESS(MATERIAL) if (materialDist < 0.0) materialTo = MATERIAL; sceneDist = min (sceneDist, materialFrom != MATERIAL ? materialDist : -materialDist);\nfloat getDistanceScene (in vec3 p, in int materialFrom, out int materialTo) {\n\tfloat d = length (p * vec3 (DEFORMATION, 1.0, DEFORMATION));\n\tfloat dxz = length (p.xz);\n\n\t// Air\n\tmaterialTo = -1;\n\tfloat sceneDist = RAY_LENGTH_MAX;\n\n\t// Champagne\n\tfloat materialDist = getDistanceChampagne (p, d);\n\tMATERIAL_PROCESS (1)\n\n\t// Glass\n\tmaterialDist = getDistanceGlass (p, d, dxz);\n\tMATERIAL_PROCESS (0)\n\n\t// Table\n\tmaterialDist = getDistanceTable (p, dxz);\n\tMATERIAL_PROCESS (2)\n\n\t// Return the distance\n\treturn sceneDist;\n}\n\n// Normal at a given point\nvec3 getNormal (in vec3 p, in int materialIndex) {\n\tconst vec2 h = vec2 (DELTA, -DELTA);\n\treturn normalize (\n\t\th.xxx * getDistanceMaterial (p + h.xxx, materialIndex) +\n\t\th.xyy * getDistanceMaterial (p + h.xyy, materialIndex) +\n\t\th.yxy * getDistanceMaterial (p + h.yxy, materialIndex) +\n\t\th.yyx * getDistanceMaterial (p + h.yyx, materialIndex)\n\t);\n}\n\n// Cast a ray for a given color channel (and its corresponding refraction index)\nvec3 lightDirection = normalize (LIGHT);\nCOLOR raycast (in vec3 origin, in vec3 direction, in vec4 normal, in int materialTo, in COLOR color, in vec3 channel) {\n\n\t// Check the behavior of the material\n\tMaterial material = getMaterial (materialTo);\n\tfloat alpha = abs (material.behavior);\n\tcolor *= 1.0 - alpha;\n\n\t// The ray continues...\n\tint materialFrom = -1;\n\tfloat refractIndexFrom = 1.0;\n\tfor (int rayBounce = 1; rayBounce < RAY_BOUNCE_MAX; ++rayBounce) {\n\n\t\t// Interface with the material\n\t\tfloat refractIndexTo;\n\t\tvec3 refraction;\n\t\tif (materialTo == -1) {\n\t\t\trefractIndexTo = 1.0;\n\t\t\trefraction = refract (direction, normal.xyz, refractIndexFrom);\n\t\t} else {\n\t\t\trefractIndexTo = dot (material.refractIndex, channel);\n\t\t\trefraction = material.behavior < 0.0 ? vec3 (0.0) : refract (direction, normal.xyz, refractIndexFrom / refractIndexTo);\n\t\t}\n\t\tif (dot (refraction, refraction) < DELTA) {\n\t\t\tdirection = reflect (direction, normal.xyz);\n\t\t\torigin += direction * DELTA * 2.0;\n\t\t} else {\n\t\t\tdirection = refraction;\n\t\t\tmaterialFrom = materialTo;\n\t\t\trefractIndexFrom = refractIndexTo;\n\t\t}\n\n\t\t// Ray marching\n\t\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\t\tfloat dist = max (getDistanceScene (origin, materialFrom, materialTo), DELTA);\n\t\t\tnormal.w += dist;\n\t\t\tif (materialFrom != materialTo || normal.w > RAY_LENGTH_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\torigin += direction * dist;\n\t\t}\n\n\t\t// Check whether we hit something\n\t\tif (materialFrom == materialTo) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// Get the normal\n\t\tif (materialTo == -1) {\n\t\t\tnormal.xyz = -getNormal (origin, materialFrom);\n\t\t} else {\n\t\t\tnormal.xyz = getNormal (origin, materialTo);\n\n\t\t\t// Basic lighting\n\t\t\tmaterial = getMaterial (materialTo);\n\t\t\tfloat relfectionDiffuse = max (0.0, dot (normal.xyz, lightDirection));\n\t\t\tfloat relfectionSpecular = pow (max (0.0, dot (reflect (direction, normal.xyz), lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\t\tCOLOR localColor = (AMBIENT + relfectionDiffuse) * CHANNEL (material.color) + relfectionSpecular;\n\t\t\tfloat localAlpha = abs (material.behavior);\n\t\t\tcolor += localColor * (1.0 - localAlpha) * alpha;\n\t\t\talpha *= localAlpha;\n\t\t}\n\t}\n\n\t// Get the background color\n\tCOLOR backColor = CHANNEL (texture (iChannel0, direction).rgb);\n\n\t// Return the intensity of this color channel\n\treturn color + backColor * alpha;\n}\n\n// Main function\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Define the ray corresponding to this fragment\n\tvec2 frag = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 direction = normalize (vec3 (frag, 4.0));\n\n\t// Set the camera\n\tvec3 origin = 5.0 * vec3 (cos (iTime * 0.1), 0.2 + 0.8 * sin (iTime * 0.2), sin (iTime * 0.1));\n\tvec3 forward = -origin;\n\tvec3 up = vec3 (sin (iTime * 0.3), 2.0, 0.0);\n\tmat3 rotation;\n\trotation [2] = normalize (forward);\n\trotation [0] = normalize (cross (up, forward));\n\trotation [1] = cross (rotation [2], rotation [0]);\n\tdirection = rotation * direction;\n\torigin.y -= 1.0;\n\n\t// Cast the initial ray\n\tvec4 normal = vec4 (0.0);\n\tint materialTo = -1;\n\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\tfloat dist = max (getDistanceScene (origin, -1, materialTo), DELTA);\n\t\tnormal.w += dist;\n\t\tif (materialTo != -1 || normal.w > RAY_LENGTH_MAX) {\n\t\t\tbreak;\n\t\t}\n\t\torigin += direction * dist;\n\t}\n\n\t// Check whether we hit something\n\tif (materialTo == -1) {\n\t\tfragColor.rgb = texture (iChannel0, direction).rgb;\n\t} else {\n\n\t\t// Get the normal\n\t\tnormal.xyz = getNormal (origin, materialTo);\n\n\t\t// Basic lighting\n\t\tfloat relfectionDiffuse = max (0.0, dot (normal.xyz, lightDirection));\n\t\tfloat relfectionSpecular = pow (max (0.0, dot (reflect (direction, normal.xyz), lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\tfragColor.rgb = (AMBIENT + relfectionDiffuse) * getMaterial (materialTo).color + relfectionSpecular;\n\n\t\t// The ray continues...\n\t\t#ifdef PROPAGATION\n\t\t\t#ifdef DISPERSION\n\t\t\t\tfragColor.r = raycast (origin, direction, normal, materialTo, fragColor.r, vec3 (1.0, 0.0, 0.0));\n\t\t\t\tfragColor.g = raycast (origin, direction, normal, materialTo, fragColor.g, vec3 (0.0, 1.0, 0.0));\n\t\t\t\tfragColor.b = raycast (origin, direction, normal, materialTo, fragColor.b, vec3 (0.0, 0.0, 1.0));\n\t\t\t#else\n\t\t\t\tfragColor.rgb = raycast (origin, direction, normal, materialTo, fragColor.rgb, vec3 (1.0 / 3.0));\n\t\t\t#endif\n\t\t#endif\n\t}\n\n\t// Set the alpha channel\n\tfragColor.a = 1.0;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}