{
    "Shader": {
        "info": {
            "date": "1602239652",
            "description": "Paper plane flyover (based on \"Voronoi Towers\"); mouseable",
            "flags": 0,
            "hasliked": 0,
            "id": "WdKcz1",
            "likes": 11,
            "name": "Gliders Over Voropolis",
            "published": 3,
            "tags": [
                "voronoi",
                "plane",
                "city",
                "flight"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 439
        },
        "renderpass": [
            {
                "code": "// \"Gliders Over Voropolis\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0  // (=0/1) optional antialiasing (recommended if not fullscreen)\n\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nvoid HexVorInit ();\nvec4 HexVor (vec2 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Fbm2 (vec2 p);\n\nmat3 flyerMat[3], flMat;\nvec3 flyerPos[3], flPos, trkF, trkA, sunDir, qHit;\nfloat tCur, dstFar, dstBld, hBase, vorScl;\nint idObj;\nconst float pi = 3.1415927, sqrt3 = 1.732051;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat FlyerDf (vec3 p)\n{\n  vec3 q, qq;\n  float dMin, d, a;\n  dMin = dstFar;\n  for (int k = VAR_ZERO; k < 3; k ++) {\n    q = flyerMat[k] * (p - flyerPos[k]);\n    q.x = abs (q.x);\n    a = 0.22 * pi;\n    q.z += 0.25;\n    qq = q;\n    qq.xy = Rot2D (vec2 (abs (qq.x), qq.y), - a);\n    qq.xz = Rot2D (vec2 (qq.x, qq.z - 1.1), -0.012 * pi);\n    qq.xy = Rot2D (vec2 (abs (qq.x), qq.y), a);\n    d = abs (max (max (abs (qq.y) - 0.002, 0.), max (dot (q.xz, sin (0.15 * pi +\n       vec2 (0.5 * pi, 0.))) - 0.5, - q.z - 0.5))) - 0.002;\n    DMINQ (1 + k);\n  }\n  return dMin;\n}\n\nfloat FlyerRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = FlyerDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 FlyerNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = FlyerDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat BldDf (vec3 p)\n{\n  vec4 vc;\n  float h;\n  vc = HexVor (vorScl * p.xz);\n  h = 0.5 * (floor (16. * vc.w) + 2.) + 0.04 * dstBld *\n     smoothstep (0.8, 1., dstBld / dstFar);\n  return min (0.2 * SmoothMax (0.75 - vc.x, p.y - h, 0.03), p.y + hBase);\n}\n\nfloat BldRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  if (rd.y < 0.) {\n    dHit = - (ro.y - 9.) / rd.y;\n    for (int j = VAR_ZERO; j < 320; j ++) {\n      dstBld = dHit;\n      d = BldDf (ro + dHit * rd);\n      dHit += d;\n      if (d < 0.001 || dHit > dstFar) break;\n    }\n  } else dHit = dstFar;\n  return dHit;\n}\n\nvec3 BldNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = BldDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float sd, f;\n  rd.y = abs (rd.y);\n  sd = max (dot (rd, sunDir), 0.);\n  ro.x += 0.5 * tCur;\n  f = Fbm2 (0.05 * (rd.xz * (50. - ro.y) / (rd.y + 0.0001) + ro.xz));\n  col = vec3 (0.1, 0.3, 0.5) + 0.3 * pow (1. - max (rd.y, 0.), 4.);\n  col += vec3 (1., 1., 0.9) * (0.3 * pow (sd, 32.) + 0.2 * pow (sd, 512.));\n  return mix (col, vec3 (0.9), clamp ((f - 0.2) * rd.y + 0.3, 0., 1.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 vc;\n  vec3 col, vn;\n  float dstBld, dstFlyer, c, hw;\n  HexVorInit ();\n  vorScl = 0.3;\n  hBase = 5.;\n  dstBld = BldRay (ro, rd);\n  dstFlyer = FlyerRay (ro, rd);\n  if (min (dstFlyer, dstBld) < dstFar) {\n    if (dstFlyer < dstBld) {\n      ro += dstFlyer * rd;\n      col = (idObj == 1) ? vec3 (1., 0., 0.) : ((idObj == 2) ? vec3 (0., 1., 0.) :\n         vec3 (0., 0., 1.));\n      col = mix (col, vec3 (1., 1., 0.), smoothstep (0.02, 0.03,\n         abs (abs (qHit.x - 0.3) - 0.05)) * (1. - smoothstep (0.95, 0.97, qHit.z)));\n      vn = FlyerNf (ro);\n      col = col * (0.3 + 0.1 * max (- dot (vn, sunDir), 0.) +\n         0.7 * max (dot (vn, sunDir), 0.)) +\n         0.2 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n    } else {\n      ro += dstBld * rd;\n      vc = HexVor (vorScl * ro.xz);\n      vn = BldNf (ro);\n      hw = mod (ro.y + 0.5, 1.) - 0.5;\n      if (abs (hw) < 0.18 && vn.y < 0.01) col = 0.7 * SkyCol (ro, reflect (rd, vn));\n      else {\n        c = 0.1 * floor (73. * mod (vc.w, 1.) + 0.5);\n        col = HsvToRgb (vec3 (0.1 + 0.8 * c, 0.3 + 0.5 * mod (25. * c, 1.), 1.));\n        if (ro.y > 0.1 - hBase) col *= (0.5 + 0.3 * mod (37. * c, 1.)) *\n           ((vn.y > 0.99) ? 1.2 : (1. - 0.5 * step (abs (hw), 0.25) * sign (hw)));\n        else col = mix (col, vec3 (1.) * (0.1 +\n           0.9 * step (abs (vc.x - 0.04), 0.02)), step (vc.x, 0.4));\n        col = col * (0.2 + 0.8 * max (0., max (dot (vn, sunDir), 0.))) +\n           0.05 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n      }\n      col *= 1. + 0.6 * min (ro.y / hBase, 0.);\n      col = mix (col, 0.8 * SkyCol (ro, rd), smoothstep (0.4, 0.95, dstBld / dstFar));\n    }\n  } else col = SkyCol (ro, rd);\n  return clamp (col, 0., 1.);\n}\n\nvec3 TrkPath (float t)\n{\n  return vec3 (dot (trkA, sin (trkF * t)), 12., t);\n}\n\nvec3 TrkVel (float t)\n{\n  return vec3 (dot (trkF * trkA, cos (trkF * t)), 0., 1.);\n}\n\nvec3 TrkAcc (float t)\n{\n  return vec3 (dot (trkF * trkF * trkA, - sin (trkF * t)), 0., 0.);\n}\n\nvec3 GlareCol (vec3 rd, vec3 sd, vec2 uv)\n{\n  vec3 col;\n  vec2 e;\n  e = vec2 (1., 0.);\n  if (sd.z > 0.) col = 0.05 * pow (abs (sd.z), 4.) *\n     (4. * e.xyy * max (dot (normalize (rd + vec3 (0., 0.3, 0.)), sunDir), 0.) +\n      e.xxy * SmoothBump (0.03, 0.05, 0.01, length (uv - 0.7 * sd.xy)) +\n      e.yxx * SmoothBump (0.2, 0.23, 0.02, length (uv - 0.5 * sd.xy)) +\n      e.xyx * SmoothBump (0.6, 0.65, 0.03, length (uv - 0.3 * sd.xy)));\n  else col = vec3 (0.);\n  return col;\n}\n\nvoid FlyerPM (float t, int isOb)\n{\n  vec3 vel, va, flVd;\n  vec2 cs;\n  float oRl;\n  flPos = TrkPath (t);\n  vel = TrkVel (t);\n  va = cross (TrkAcc (t), vel) / length (vel);\n  flVd = normalize (vel);\n  oRl = ((isOb > 0) ? 10. : 20.) * length (va) * sign (va.y);\n  cs = sin (oRl + vec2 (0.5 * pi, 0.));\n  flMat = mat3 (cs.x, - cs.y, 0., cs.y, cs.x, 0., 0., 0., 1.) *\n     mat3 (flVd.z, 0., flVd.x, 0., 1., 0., - flVd.x, 0., flVd.z);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd, col, gCol;\n  vec2 canvas, uv;\n  float az, el, zmFac, flyVel, vDir, sr, t;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.17 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.45 * pi * mPtr.y;\n  }\n  tCur += 50.;\n  trkA = 0.2 * vec3 (1.9, 2.9, 4.3);\n  trkF = vec3 (0.23, 0.17, 0.13);\n  flyVel = 3.;\n  vDir = sign (0.5 * pi - abs (az));\n  for (int k = VAR_ZERO; k < 3; k ++) {\n    t = flyVel * tCur + vDir * (3. + 5. * float (k));\n    FlyerPM (t, 0);\n    flyerMat[k] = flMat;\n    flyerPos[k] = flPos;\n    flyerPos[k].y += 0.8 * (2. * SmoothBump (0.25, 0.75, 0.25, mod (0.05 * t, 1.)) - 1.) - 1.;\n  }\n  t = flyVel * tCur;\n  FlyerPM (t, 1);\n  ro = flPos;\n  vuMat = StdVuMat (el, az);\n  zmFac = 2.;\n  dstFar = 200.;\n  sunDir = normalize (vec3 (sin (0.02 * pi * tCur), 0.2, cos (0.02 * pi * tCur)));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    rd = vuMat * (rd * flMat);\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  col += GlareCol (rd, flMat * sunDir * vuMat, uv);\n  fragColor = vec4 (col, 1.);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec2 gVec[7], hVec[7];\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nvec4 HexVor (vec2 p)\n{\n  vec4 sd, udm;\n  vec2 ip, fp, d, u;\n  float amp, a;\n  amp = 0.5;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  udm = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    a = 2. * pi * (u.y - 0.5);\n    d = hVec[k] + amp * (0.4 + 0.6 * u.x) * vec2 (cos (a), sin (a)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) {\n      sd = sd.wxyw;\n      udm = vec4 (d, u);\n    } else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return vec4 (SmoothMin (sd.y, sd.z, 0.05) - sd.x, udm.xy, Hashfv2 (udm.zw));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}