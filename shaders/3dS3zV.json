{
    "Shader": {
        "info": {
            "date": "1568186296",
            "description": "A raymarched sphere deformed by a Chladni velocity field",
            "flags": 0,
            "hasliked": 0,
            "id": "3dS3zV",
            "likes": 14,
            "name": "svfwarp",
            "published": 3,
            "tags": [
                "warping",
                "raycaster",
                "chladni",
                "velocityfield",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "386dx25",
            "viewed": 7539
        },
        "renderpass": [
            {
                "code": "#define PROFILE 0\n\n//#define DO_ROT\n//#define DO_LOGROT\n\n#define ISO 0.4\n\n#if PROFILE==0\n  #define STEP 0.01\n  #define EULER 5\n#else\n  #define STEP 0.1\n  #define EULER 3\n#endif\n\n// -- Chladni plasma\nconst float pi = 3.1415926535897932384;\n\n// Knot numbers\nvec2 mn = vec2(5.0,3.0); \n\n#if 0\nfloat chladni( vec2 mn, vec2 uv )\n{\n\treturn cos(mn.x*pi*uv.x)*cos(mn.y*pi*uv.y);\n}\n\nfloat density( vec3 p )\n{\n  vec2 uv = p.xy;    \n    \n  // Superposition coefficients\n  float alpha = iTime;\n  mat2 R = mat2( cos(alpha), sin(alpha), -sin(alpha), cos(alpha) );\n  vec2 c = R * vec2(1.0,-1.0);\t\n\n  // Superposition of eigenmodes\n  float u = c.x*chladni(mn.xy,uv) + c.y*chladni(mn.yx,uv); // chladni(p.zx,uv);\n  //u += 0.5*chladni(sqrt(mn.xy*mn.yx),R*p.zy);\n    \n  return 100.0*u;\n}\n\nvec3 warp( vec3 p )\n{\n  mat3 d = mat3(0.0001);\n  return vec3(\n        density(p-d[0]) - density(p+d[0]),\n        density(p-d[1]) - density(p+d[1]),\n        density(p-d[2]) - density(p+d[2])\n    );\n}\n#else\nfloat fun( vec2 uv, vec2 mn, vec2 c )\n{\n  return c.x*cos(pi*mn.x*uv.x)*cos(pi*mn.y*uv.y)\n       + c.y*cos(pi*mn.y*uv.x)*cos(pi*mn.x*uv.y);\n}\n\nvec2 dfun( vec2 uv, vec2 mn, vec2 c )\n{\n  // scaling not correct\n  return vec2( -c.x*sin(pi*mn.x*uv.x)*cos(pi*mn.y*uv.y)\n               -c.y*sin(pi*mn.y*uv.x)*cos(pi*mn.x*uv.y),\n               -c.x*cos(pi*mn.x*uv.x)*sin(pi*mn.y*uv.y)\n               -c.y*cos(pi*mn.y*uv.x)*sin(pi*mn.x*uv.y) );\n}\n\nvec3 warp( vec3 p )\n{\n  vec2 uv = p.xy;   \n    \n  // Superposition coefficients\n  float alpha = iTime;\n  mat2 R = mat2( cos(alpha), sin(alpha), -sin(alpha), cos(alpha) );\n  vec2 c = R * vec2(1.0,-1.0);\t\n\n  return 0.3* vec3(dfun(uv,mn,c),0);\n}\n#endif\n\n// --- Stationary velocity field(s)\nvec3 svf( vec3 x )\n{\n  vec3 svf0, svf1;\n  \n  // Warp field\n  svf0 = warp(x);\n\n#ifndef DO_LOGROT\n  svf1 = vec3(0);\n#else\n  // Log affine transformation (evaluated off-line)\n  // Central rotation around x\n  vec3 center = vec3(0.0);\n    float w = 1.0-smoothstep( 0.1, 2.0, length(x-center) );\n  float lambda0 = -5.0+10.0*iMouse.x/iResolution.x;\n  float logt = lambda0;\n  mat4 L = transpose(mat4( // matrices are given column-major\n             0.0,       0.0,      0.0,      0.0,\n             0.0,       0.0,     logt,      0.0,\n             0.0,     -logt,      0.0,      0.0,\n             0.0,       0.0,      0.0,      0.0  ));\n  vec3 v = (L*vec4(x-center,1.0)).xyz - L[3].xyz;\n  svf1 = w*(-v);\n#endif  \n  return svf0 + svf1;\n}\n\n// Compute vectorfield exponential via Euler-step algorithm \nvec3 integrate( vec3 x0, float sign_, int steps )\n{\n  vec3 x = x0;\n  float h = 1.0 / float(steps);   // stepsize\n  for( int k=0; k < steps; k++ )  // Euler steps\n  {\n    x = x + h * sign_ * svf( x );\n  }\n  return (x-x0);\n}\n\nmat3 rodrigues( vec3 r, float theta )\n{\n  float s = sin(theta);\n  float c = cos(theta);\n  float t = 1.0-c;\n  return mat3(\n    t*r.x*r.x + c,     t*r.x*r.y - s*r.z, t*r.x*r.y + s*r.y,\n    t*r.x*r.y + s*r.z, t*r.y*r.y + c,     t*r.y*r.z - s*r.x,\n    t*r.x*r.z - s*r.y, t*r.x*r.y + s*r.x, t*r.z*r.z + c\n  );\n}\n\nvec3 trafo( vec3 p )\n{  \n  p += integrate(p, -1.0, EULER);\n#ifndef DO_ROT\n  return p;\n#else\n  mat3 Rx = rodrigues(normalize(vec3(1.0,0.0,0.0)),3.14*iTime*0.1);\n  mat3 Ry = rodrigues(normalize(vec3(0.0,1.0,0.0)),3.14*iTime*0.1);\n  return Rx*Ry*p;\n#endif\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdOctahedron( in vec3 p, in float s)\n{\n    p = abs(p);\n    return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat field( vec3 p )\n{\n  p = trafo( p );\n\n  return dot(p,p);\n  //return max(max(abs(p.x),abs(p.y)),abs(p.z));\n  //return p.x*p.x + p.z*p.z;\n\n  //return sdTorus( p, vec2(0.2,0.1) );\n  //return sdOctahedron( p, 0.2 );\n  //return sdRoundBox( p, vec3(0.3), 0.01 );\n}\n\nvec3 grad( vec3 p )\n{\n  mat3 d = mat3(0.01);\n  return vec3(\n      field(p-d[0]) - field(p+d[0]),\n      field(p-d[1]) - field(p+d[1]),\n      field(p-d[2]) - field(p+d[2])\n  );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if 0\n  if( mod(fragCoord.x,2.0)<=1.0 )\n  {\n      fragColor = vec4(0);\n      return;\n  }\n#endif\n    \n  // normalized pixel coordinate\n  vec2 npc = 2.0*fragCoord/iResolution.xy - vec2(1.0,1.0);\n  npc.y /= iResolution.x / iResolution.y;\n  \n#ifdef IS_CINESHADER\n  npc *= 0.6;\n#endif\n    \n  vec3 bg = .5*vec3(.6,.5,1) * (1.0-npc.y*npc.y) * mod(fragCoord.y,2.0);\n  \n  if( sqrt(npc.x*npc.x + npc.y*npc.y) > 0.5 )\n  {\n    fragColor = vec4(bg,0);\n    return;\n  }\n\n#if 0 //MOUSE    \n  mn = 7.0 * iMouse.xy / iResolution.xy; \n#else\n  float s=iTime*0.1;\n  mn = 3.0*vec2(sin(1.3*s+.3)+1.0,cos(s)+1.0)+2.0*vec2(cos(s*.1+.7)+1.0);\n#endif\n    \n  vec3 p0 = vec3(npc,-1.0);\n  vec3 eye = vec3(0.0,0.0,-2.0);    \n  vec3 dir = normalize(p0 - eye);\n  \n  vec4 dst = vec4(bg,0.);\n  \n  float ds=STEP;    \n  for( float s=0.0; s < 2.0; s+=ds )\n  {\n    vec3 p = p0 + s*dir;\n    float val = field(p);\n    \n    // isosurface\n    if( val < ISO )\n    {\n        vec3 rd = vec3(.6,.5,1);\n        vec3 rs = vec3(1,1,0);\n        \n        vec3 l = normalize(vec3(0.5,-0.5,1.0));\n        vec3 n = normalize(grad(p));\n        vec3 h = normalize(0.5*(l+dir));        \n        dst = vec4(rd*max(0.0,dot(n,l))+rs*(pow(dot(h,n),42.0)),1.0-s);\n        break;\n    }\n  }\n\n  fragColor = dst;\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"svfwarp\",\n\t\"description\": \"A raymarched sphere deformed by a Chladni velocity field\",\n\t\"model\": \"person\"\n}\n*/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}