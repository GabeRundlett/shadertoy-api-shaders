{
    "Shader": {
        "info": {
            "date": "1599054175",
            "description": "ray marching volumetric data can suffer aliasing, especially if the transfer function ( i.e. LUT(dens) ) introduce high frequency. Here: explore isovalue.\nPreintegrated segment shading fix it (left).cf [url]https://tinyurl.com/y3ef86ao[/url]",
            "flags": 1,
            "hasliked": 0,
            "id": "3lBfDm",
            "likes": 15,
            "name": "volume isovalue: fixing aliasing",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "raymarching",
                "antialiasing",
                "volumetric",
                "lod",
                "vr",
                "preintegration"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 511
        },
        "renderpass": [
            {
                "code": "// variant of https://shadertoy.com/view/WtBfDm\n// variant of https://shadertoy.com/view/3tjfWD\n\n// inspired from \"Clouds\" by iq. https://shadertoy.com/view/XslGRr\n// ( no sky, no LOD, use cubic noise texture ).\n\n// - Introduce transfer function ( i.e. LUT(dens) ) to shape the look (much like doctors do for scan data)\n// - Rely on preintegrated density on segment.\n//     inspired by preintegrated segment rendering ( see http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.10.3079&rep=rep1&type=pdf )\n//     NB: they store a small texture(_dens,dens), but here I do it analytically.\n\n#define noise(x) ( 2.* textureLod(iChannel0,(x)/32.,0.).x -1. )\n#define SQR(x)   ( (x)*(x) )\n#define CUB(x)   ( (x)*(x)*(x) )\n\nfloat map(vec3 p )\n{\n\tvec3 q = p - vec3(0,.1,1);\n\tfloat f = 0., s=.5;\n    for (int i=0; i< 5; i++ , s/= 2. )\n        f += s* noise( q ), q *= 2.;\n\n\treturn max(1.+ .5*p.y +3.*f, 0.);\n}\n\nfloat thick = 1./1000.;\n  #define LUT(d) max( 1.-SQR(d-.5)/thick, 0. ) // transfer function\n\n                                              // integral of transfer function\n  #define intLUT(d0,d1) ( abs(d1-d0)<1e-3 ? 0. : ( I(C(d1)) - I(C(d0)) ) / (d1-d0) ) \n  #define C(d) clamp( d, .5-sqrt(thick), .5+sqrt(thick) )\n  #define I(d) ( d - CUB(d-.5)/3./thick )\nvec2 coord;\n\nfloat LUTs( float _d, float d ) { // apply either the simple or integrated transfer function\n    return coord.x > 0. \n             ?  LUT(d)        // right: just apply transfert function\n             :  intLUT(_d,d); // left: preintegrated transfert function\n}\n\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec3(0,23,21)  ) )\n\nvec4 raymarch( vec3 ro, vec3 rd, vec3 bgcol, ivec2 px )\n{\n\tvec4 sum = vec4(0);\n\tfloat  t = 0., //.05*texelFetch( iChannel0, px&255, 0 ).x; // jitter ray start\n          dt = 0.,\n         den = 0., _den, lut, dv;\n    for(int i=0; i<150; i++) \n    {\n        vec3 pos = ro + t*rd;\n        if( pos.y < -3. || pos.y > 3. || sum.a > .99 ) break;\n        _den = den; den = map(pos);  // raw density\n        if( abs(pos.x) > .5 )        // cut a slice \n        {\n            dv = -.6+sin(2.*iTime);  // explore isovalues\n            lut = LUTs( _den+dv, den+dv ); // shaped through transfer function\n            if (lut>.01)             // not empty space\n            { \n                vec3  col = mix(hue(.1*pos.z) , vec3(1), .8);\n                col = mix( col , bgcol, 1.-exp(-.003*t*t) ); // fog\n                sum += (1.-sum.a) * vec4(col,1)* (lut* dt*10.); // blend. Original was improperly just den*.4;\n            }  }\n        t += dt = max(.05,.02*t);     // stepping\n    }\n\n    return sqrt(1.-sum);              // black on white + sRGB\n}\n\nmat3 setCamera( vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro),\n\t     cp = vec3(sin(cr), cos(cr),0),\n\t     cu = normalize( cross(cw,cp) ),\n\t     cv = cross(cu,cw);\n    return mat3( cu, cv, cw );\n}\n\n#define render(ro,rd,px) raymarch( ro, rd, vec3(0), px ) // render volume\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy,\n         p = ( 2.*U - R ) / R.y,\n         m = 2.* iMouse.xy / R.xy;\n    coord = p;\n    \n    // camera\n    vec3 ro = 4.*normalize(vec3(sin(3.*m.x), .4*m.y, cos(3.*m.x))),\n\t     ta = vec3(0, -1, 0);\n    mat3 ca = setCamera( ro, ta, 0. );\n    // ray\n    vec3 rd = ca * normalize( vec3(p,1.5) );\n    \n    O = render( ro, rd, ivec2(U-.5) );\n    if (floor(U.x)==floor(R.x/2.)) O = vec4(1,0,0,1);\n}\n\n#define mainVR(O,U,C,D) O = render( C, D, ivec2(U-.5) )",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "volume",
                        "id": 40,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}