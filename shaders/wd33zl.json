{
    "Shader": {
        "info": {
            "date": "1569348330",
            "description": "Too much lens flare? I don't know what you're talking about.\n\nClick to move the camera and change the focus",
            "flags": 32,
            "hasliked": 0,
            "id": "wd33zl",
            "likes": 85,
            "name": "Morning glare",
            "published": 3,
            "tags": [
                "fractal",
                "refraction",
                "mandelbulb",
                "dof",
                "glass",
                "bloom",
                "depthoffield",
                "lensflare",
                "glare"
            ],
            "usePreview": 0,
            "username": "loicvdb",
            "viewed": 2011
        },
        "renderpass": [
            {
                "code": "//lens flares\n\nfloat lodFlares;\n\nvec3 ghostFlare(vec2 uv, float scale){\n    uv /= scale;\n    float threshold = .75;\n    return vec3(max(texture(iChannel0, uv*0.95+.5, lodFlares).r - threshold, 0.0),\n                max(texture(iChannel0, uv*1.00+.5, lodFlares).g - threshold, 0.0),\n                max(texture(iChannel0, uv*1.05+.5, lodFlares).b - threshold, 0.0));\n}\n\nvec3 haloFlare(vec2 uv, float scale){\n    float weight = 1.0-smoothstep(0.0, .05, abs(.5-length(uv)));\n    uv -= scale*normalize(uv);\n    float threshold = .6;\n    return weight * max(texture(iChannel0, vec2(.5) + uv*1.00, lodFlares).rgb - threshold, vec3(0));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    lodFlares = log2(iResolution.y*.15);\n    float lodLargeBloom = log2(iResolution.y*.15);\n    float lodSmallBloom = log2(iResolution.y*.05);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n    \n    vec3 bloom = max(texture(iChannel0, uv, lodLargeBloom).rgb - .3, vec3(0.0))*.65\n               + max(texture(iChannel0, uv, lodSmallBloom).rgb - .6, vec3(0.0))*.3;\n    \n    uv -= .5;\n    vec2 radialUV = vec2(atan(uv.x, uv.y), 0.5);\n    float flareStrength = texture(iChannel1, radialUV).r * texture(iChannel1, uv).r;\n    \n    float l = length(uv);\n    vec3 flareTint = 4.0*flareStrength * (vec3(sin(l*20.0), cos(l*10.0+2.0), sin(l*15.0))*.3+.5);\n    \n    vec3 lensFlare = flareTint * (ghostFlare(uv, -.75) + haloFlare(uv, -.5));\n    \n    fragColor.rgb += lensFlare + bloom;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define Epsilon .002\n#define RenderDistance 3.0\n#define IoR 1.5\n#define GlassColor vec3(1.0, .9, .6)\n\nfloat Power = 8.0;\n\nvec3 CamPos = vec3(0, .9, -2.5);\nvec3 CamRot = vec3(.15, .1, .0);\nfloat CamFocalLength = 2.0;\n\n\nfloat distanceEstimation(vec3 pos) {\n    float r = length(pos);\n    if(r > 1.5) return r-1.2;\n    vec3 z = pos;\n\tfloat dr = 1.0, theta, phi;\n\tfor (int i = 0; i < 100; i++) {\n\t\tr = length(z);\n\t\tif (r>1.5) break;\n\t\ttheta = acos(z.y/r);\n\t\tphi = atan(z.z,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\ttheta *= Power;\n\t\tphi *= Power;\n\t\tz = pow(r,Power)*vec3(sin(theta)*cos(phi), cos(theta), sin(phi)*sin(theta)) + pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\nvec3 normalEstimation(vec3 pos){\n   \n  vec3 xDir = vec3(Epsilon, 0.0, 0.0);\n  vec3 yDir = vec3(0.0, Epsilon, 0.0);\n  vec3 zDir = vec3(0.0, 0.0, Epsilon);\n\n  float normalX = distanceEstimation(pos + xDir)\n                - distanceEstimation(pos - xDir);\n  float normalY = distanceEstimation(pos + yDir)\n                - distanceEstimation(pos - yDir);\n  float normalZ = distanceEstimation(pos + zDir)\n                - distanceEstimation(pos - zDir);\n\n  return normalize(vec3(normalX, normalY, normalZ));\n}\n\nvec3 background(vec3 dir){\n    if(dot(dir, normalize(vec3(-.5, .2, 1)))>.995) return vec3(5.0);\n    return texture(iChannel0, dir).rgb*1.5;\n}\n\nfloat fresnel(vec3 dir, vec3 normal) {\n  float cosi = dot(dir, normal);\n  float etai = 1.0, etat = IoR;\n  if (cosi > 0.0) {\n    float tmp = etai;\n    etai = etat;\n    etat = tmp;\n  }\n  float sint = etai / etat * sqrt(max(0.0, 1.0 - cosi * cosi));\n  if (sint >= 1.0) return 1.0;\n  float cost = sqrt(max(0.0, 1.0 - sint * sint));\n  cosi = abs(cosi);\n  float sqrtRs = ((etat * cosi) - (etai * cost)) / ((etat * cosi) + (etai * cost));\n  float sqrtRp = ((etai * cosi) - (etat * cost)) / ((etai * cosi) + (etat * cost));\n  return (sqrtRs * sqrtRs + sqrtRp * sqrtRp) / 2.0;\n}\n\nbool hit(inout vec3 pos, in vec3 dir, out vec3 normal){\n    for(int i = 0; i < 500; i++){\n        float dist = distanceEstimation(pos);\n        if(dist < Epsilon) break;\n        if(dist > RenderDistance) return false;\n        pos += dist*dir;\n    }\n    for(int i = 0; i < 4; i++){\n        float dist = distanceEstimation(pos)-Epsilon;\n        pos += dist*dir;\n    }\n    normal = normalEstimation(pos);\n    return true;\n}\n\nvec3 reflectCol(vec3 dir, vec3 normal){\n\treturn background(reflect(dir, normal));\n}\n\nvec3 refractCol(vec3 dir, vec3 normal){\n    return GlassColor * vec3(background(refract(dir, normal, 0.90/IoR)).r,\n                             background(refract(dir, normal, 1.00/IoR)).g,\n                             background(refract(dir, normal, 1.10/IoR)).b);\n}\n\nvec3 glassCol(vec3 dir, vec3 normal){\n    float fres = fresnel(dir, normal);\n    return (1.0-fres)*refractCol(dir, normal) + fres*reflectCol(dir, normal);\n}\n\nvec4 colorAndDepth(vec3 pos, vec3 dir){\n    vec3 normal;\n    if(hit(pos, dir, normal)){\n        return vec4(max(glassCol(dir, normal), vec3(0)), length(pos-CamPos));\n    }\n   \treturn vec4(background(dir), RenderDistance);\n}\n\nmat3 rotationMatrix(vec3 rotEuler){\n    float c = cos(rotEuler.x), s = sin(rotEuler.x);\n    mat3 rx = mat3(1, 0, 0, 0, c, -s, 0, s, c);\n    c = cos(rotEuler.y), s = sin(rotEuler.y);\n    mat3 ry = mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n    c = cos(rotEuler.z), s = sin(rotEuler.z);\n    mat3 rz = mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n    \n    return rz * rx * ry;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    float time = iTime;\n    \n    vec2 uv = (fragCoord-iResolution.xy/2.0) / iResolution.y;\n    \n    CamRot.y += time/2.0;\n    CamPos *= rotationMatrix(vec3(0, time/2.0, 0));\n    \n    if( iMouse.z > 0.0 )\n        CamRot.y += (.5-iMouse.x/iResolution.x)*.75;\n    \n    vec3 rayDir = normalize(vec3(uv, CamFocalLength)) * rotationMatrix(CamRot);\n    \n    fragColor = colorAndDepth(CamPos, rayDir);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define GoldenAngle 2.39996323\n\n#define Aperture .06\n#define DoFClamping .3\n//change the sample count to 256 or more if you see some dots in the DoF\n#define DoFSamples 128\n\nfloat FocalDistance = 2.0;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    float time = iTime;\n    \n    \n    if( iMouse.z > 0.0 )\n        FocalDistance *= 1.0 + (iMouse.y/iResolution.y-.5)*.65;\n    else\n        FocalDistance *= 1.0 + sin(pow(abs(sin(time/4.0)), 70.0) * 6.0) *.25;\n    \n    vec3 col = vec3(0);\n    float samples = 0.0, r, phi, dr, influence;\n    vec2 d;\n    vec4 p;\n    for(int i = 0; i < DoFSamples; i++){\n        r = sqrt(float(i) / float(DoFSamples))*DoFClamping;\n        phi = GoldenAngle * float(i);\n        d = r * vec2(cos(phi), sin(phi));\n        p = texture(iChannel0, (fragCoord + d*iResolution.y*Aperture)/iResolution.xy);\n        dr = min(atan(abs(p.a-FocalDistance), p.a), DoFClamping);\n        influence = clamp((dr - length(d))*iResolution.y*Aperture + .5, 0.0, 1.0) / (dr*dr+.001);\n        col += influence * p.rgb;\n        samples += influence;\n    }\n    col /= samples;\n    \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}