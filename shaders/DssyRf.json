{
    "Shader": {
        "info": {
            "date": "1687117788",
            "description": "Spatial Distortions",
            "flags": 0,
            "hasliked": 0,
            "id": "DssyRf",
            "likes": 7,
            "name": "Tapestry 5",
            "published": 3,
            "tags": [
                "ifs"
            ],
            "usePreview": 0,
            "username": "iterati",
            "viewed": 272
        },
        "renderpass": [
            {
                "code": "float morphStar( in vec2 p, in float r, in float f )\n{\n    float rtn = 0.;\n    float y = sinT(f, 1.);\n    //float y = mod(f, 1.);\n    int n = ((int(f) % 4) + 1) * 4;\n    \n    return (sdCircle(p, r) * (1. - y)) + (sdStar(p, r, n, float(n)) * y);\n}\n\nfloat sheen( in float d, in float x, in float g )\n{\n    return pow(x / abs(d), g);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.x;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    vec3 col = vec3(0.);\n    float d = 0.;\n    \n    // shape morph, sides + radius\n    float f;\n    float g = iTime / 2.5;\n    float h;\n    float z = 0. * PI;\n    g = modf(g, h); // g = frac(0 -> 1), h = whole(0 -> inf)\n    int c = int(h) % 4;\n    int e = int(h / 4.) % 2;\n    float r = ampT(iTime, 30., 4., 3.) * 0.4 + 0.3;\n\n    if (c == 0) {\n      f = (h * 0.25) + (0.5 * g);\n      //r = sin(g * 0.5) * 0.2 + 0.5;\n      z = float(e) * 0.25 * PI;\n    } else if (c == 1) {\n      f = (h + 3.) * 0.25 + (0.5 * g) + 0.5;\n      //r = sin(g * 0.5 + 0.5) * 0.2 + 0.5;\n      z = float(e) * 0.25 * PI;\n    } else if (c == 2) {\n      f = (h + 2.) * 0.25;\n      z = (g * 0.125 * PI) + (float(e) * 0.25 * PI);\n    } else {\n      f = (h + 1.) * 0.25;\n      z = (g * 0.125 * PI) + (0.125 * PI) + (float(e) * 0.25 * PI);\n    }\n\n    //float r = sinT(iTime, 10.) * 0.3 + 0.2;\n    \n    //float x = 1.5;\n\n    //uv = rotate(uv, z);\n\n    d = morphStar(rotate(uv, -z), r, f) * exp(-length(uv0) * sinT(iTime, 5.) * 2.);\n    d = sheen(d, 0.0025, 1.5);\n    col = palette((length(uv0) + sin(iTime)) / 2.0);\n    finalColor += col * d;\n    \n    for (float i = 0.0; i < 4.0; i++) {\n        float zz = (int(i) % 2 == 0) ? z : -z;\n        float rot = ((i + 1.) * PI * 0.25) + -zz;\n        uv = rotate(uv, rot);\n        float x = sinT(iTime, 30.) * exp(length(uv) * (i + 1.)) + 0.5;\n        uv = fract(uv * x * (i + 1.)) - 0.5;\n        d = morphStar(uv, r, f);\n        d = sheen(d, (0.0025 * (4. - i)), 1.);\n        col = palette((length(uv0) + sin(iTime) + i + 1.) / 2.0);\n        finalColor += col * d;\n    }\n\n    fragColor = vec4(finalColor, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.1415926538\n\nvec3 palette( in float t)\n{\n    vec3 a = vec3(0.6); //vec3(0.5);\n    vec3 b = vec3(0.4, 0.3, 0.35); //vec3(0.5);\n    vec3 c = vec3(2.0); //vec3(1.);\n    vec3 d = vec3(0.85, 0.55, 0.25); //vec3(0.0, 0.333, 0.667); //vec3(3.477, 6.066, 1.898);\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat sinT( in float t, in float l )\n{\n    return (sin(((t * 2. * PI) / l) + (0.5 * PI)) * 0.5) + 0.5;\n}\n\nfloat sawT( in float t, in float l )\n{\n    return abs((mod(t / l, 1.) - 0.5) * 2.0);\n}\n\nfloat ampT( in float t, float l, float a, float b)\n{\n    return abs(cos((t / l) * a * 2. * PI) * cos((t / l) * b * 2. * PI) * 0.5 - 0.5);\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    p = abs(p);\n    float h = clamp( ndot(b-2.0*p,b)/dot(b,b), -1.0, 1.0 );\n    float d = length( p-0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( p.x*b.y + p.y*b.x - b.x*b.y );\n}\n\nfloat sdEquilateralTriangle( in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdPentagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);    \n    return length(p)*sign(p.y);\n}\n\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdOctogon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.9238795325, 0.3826834323, 0.4142135623 );\n    p = abs(p);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdHexagram( in vec2 p, in float r )\n{\n    const vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\n    p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdStar(in vec2 p, in float r, in int n, in float m)\n{\n    // next 4 lines can be precomputed for a given shape\n    float an = PI/float(n);\n    float en = PI/m;  // m is between 2 and n\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) for regular polygon\n\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\nfloat sdCross( in vec2 p, in vec2 b, float r ) \n{\n    p = abs(p); p = (p.y>p.x) ? p.yx : p.xy;\n    vec2  q = p - b;\n    float k = max(q.y,q.x);\n    vec2  w = (k>0.0) ? q : vec2(b.y-p.x,-k);\n    return sign(k)*length(max(w,0.0)) + r;\n}\n\nfloat sdBlobbyCross( in vec2 pos, float he )\n{\n    pos = abs(pos);\n    pos = vec2(abs(pos.x-pos.y),1.0-pos.x-pos.y)/sqrt(2.0);\n\n    float p = (he-pos.y-0.25/he)/(6.0*he);\n    float q = pos.x/(he*he*16.0);\n    float h = q*q - p*p*p;\n    \n    float x;\n    if( h>0.0 ) { float r = sqrt(h); x = pow(q+r,1.0/3.0)-pow(abs(q-r),1.0/3.0)*sign(r-q); }\n    else        { float r = sqrt(p); x = 2.0*r*cos(acos(q/(p*r))/3.0); }\n    x = min(x,sqrt(2.0)/2.0);\n    \n    vec2 z = vec2(x,he*(1.0-2.0*x*x)) - pos;\n    return length(z) * sign(z.y);\n}\n\nfloat sdRoundedX( in vec2 p, in float w, in float r )\n{\n    p = abs(p);\n    return length(p-min(p.x+p.y,w)*0.5) - r;\n}\n\nfloat sdMoon(vec2 p, float d, float ra, float rb )\n{\n    p.y = abs(p.y);\n    float a = (ra*ra - rb*rb + d*d)/(2.0*d);\n    float b = sqrt(max(ra*ra-a*a,0.0));\n    if( d*(p.x*b-p.y*a) > d*d*max(b-p.y,0.0) )\n          return length(p-vec2(a,b));\n    return max( (length(p          )-ra),\n               -(length(p-vec2(d,0))-rb));\n}\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nint _N = 2;\n#define mainImage mainImage0(out vec4 O, vec2 U);        \\\nvoid mainImage(out vec4 O, vec2 U) {                     \\\n    vec4 o; O = vec4(0);                                 \\\n    for (int k=0; k < _N*_N; k++ )                       \\\n      { mainImage0(o,U+vec2(k%_N-_N/2,k/_N-_N/2)/float(_N)); O += o; }  \\\n    O /= float(_N*_N);                                   \\\n    O = pow( O, vec4(1./2.2) );        /* to sRGB */     \\\n} \\\nvoid mainImage0",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}