{
    "Shader": {
        "info": {
            "date": "1594534389",
            "description": "Soft Shadow With Noise",
            "flags": 0,
            "hasliked": 0,
            "id": "3ljcWw",
            "likes": 0,
            "name": "NoiseShadow",
            "published": 3,
            "tags": [
                "3d"
            ],
            "usePreview": 0,
            "username": "solacefy",
            "viewed": 217
        },
        "renderpass": [
            {
                "code": "// IQ's SDF\n//https://iquilezles.org/\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\nmat2 Rot(float a)\n{\n\tfloat s =sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat N21(vec2 p)\n{\n\tp = fract(p*vec2(233.34,851.73));\n    p+= dot(p,p+23.45);\n    return fract(p.x*p.y);\n}\n\nvec2 N22(vec2 p)\n{\n\tfloat n = N21(p);\n    return vec2(n,N21(p+n));\n}\n\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdBoundingBox( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdMagicCubesRows(vec3 p, vec3 b, float r)\n{\n\tvec3 h = p;\n    float offset = 0.49;\n    vec3 q1 = abs(p + vec3(0.,0., 0.)) - b;\n    vec3 q2 = abs(p + vec3(0.,-offset, 0.)) - b;\n    vec3 q3 = abs(p + vec3(0.,-2.*offset, 0.)) - b;\n    return min(min(length(max(q1,0.0)) + min(max(q1.x,max(q1.y,q1.z)),0.0) - r\n        ,length(max(q2,0.0)) + min(max(q2.x,max(q2.y,q2.z)),0.0) - r), length(max(q3,0.0)) + min(max(q3.x,max(q3.y,q3.z)),0.0) - r);\n\n}\n\nfloat sdMagicCubes3Rows(vec3 p, vec3 b, float r)\n{\n\tvec3 h = p;\n    float offset = 0.49;\n    float c1 = sdMagicCubesRows(p + vec3(-offset,0.,0.), b, r);\n    float c2 = sdMagicCubesRows(p + vec3(-0.,0.,0.),b,r);\n    float c3 = sdMagicCubesRows(p + vec3(-offset *2.,0.,0.),b,r);\n    return min(c1,min(c2,c3));\n}\n\nfloat sdMagicCubes(vec3 p, vec3 b, float r)\n{\n    vec3 h = p;\n    float offset = .49;\n    float c1 = sdMagicCubes3Rows(p + vec3(0.,0.,-offset), b,r);\n    float c2 = sdMagicCubes3Rows(p + vec3(0.,0.,-offset*2.), b,r);\n    float c3 = sdMagicCubes3Rows(p + vec3(0.,0.,-0.), b,r);\n    return min(c1,min(c2,c3));\n    \n}\n\nfloat sdCubes(vec3 p, vec3 b, float r, vec3 offset, vec3 rowoff)\n{\n\tvec3 q1 = (abs(p + rowoff) - b) ;\n    vec3 q2 = abs(p - offset + rowoff) - b;\n    vec3 q3 = abs(p - offset*2. + rowoff) - b;\n    \n    //vec3 q = q1+q2+q3;\n    //q1.xz *= Rot(iTime);\n    return min(min(length(max(q1,0.0)) + min(max(q1.x,max(q1.y,q1.z)),0.0) - r,\n               length(max(q2,0.0)) + min(max(q2.x,max(q2.y,q2.z)),0.0) - r),\n             length(max(q3,0.0)) + min(max(q3.x,max(q3.y,q3.z)),0.0) - r);\n    //return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat map(in vec3 pos)\n{\n    vec3 posr = pos;\n    posr.xz *= Rot(iTime);\n    vec3 posrX = pos;\n    posrX.yx *= Rot(iTime);\n    \n    float rt = 0.;\n    float t = clamp(fract(iTime),0.5,1.);\n\tfloat d1 = length(pos) - 0.25;\n    \n    float d2= pos.y - (-0.25);\n    \n    vec3 h = pos;\n    \n    h.xz = (mat2(3,4,-4,3)/5.0)*h.xz;\n    h.yz = (mat2(3,4,-4,3)/5.0)*h.yz;\n    \n    posrX.xz = (mat2(3,4,-4,3)/5.0)*posrX.xz;\n    posrX.yz = (mat2(3,4,-4,3)/5.0)*posrX.yz;\n    \n    \n    float d3 = sdTorus((posrX - vec3(-0,.5,0.6)).xzy * vec3(1.,1.,1.) + vec3(0.,0.,rt), vec2(.99, .082));\n    \n    float d4 = sdBoundingBox((pos - vec3(0.,0.8,0.)).xzy, vec3(1) ,.045);\n    \n    float d5 = sdRoundBox(pos, vec3(.2,.2,.2), .05);\n    \n    //float posr = pos;\n \n    float d6 = sdCubes(posr, vec3(.2,.2,.2), .05, vec3(0,.49,0), vec3(0.,0.,0.5));\n    float d7 = sdCubes(posr, vec3(.2,.2,.2), .05, vec3(0,.49,0), vec3(0.,0.,-0.5));\n\tfloat d8 = sdCubes(posr, vec3(.2,.2,.2), .05, vec3(0,.49,0), vec3(0.,0.,0.));\n    \n    float dm = sdMagicCubes(posr, vec3(.2,.2,.2), .05);\n    \n    \n    float dc = min(min(d6,d7),d8);\n    \n  \n    \n   \n    \n    //return smin(min(d2,dc),d3, .03);\n  \t//return smin(dc,d3, .03);\n\treturn smin( smin(dm, d3,.03),d2, .03);\n}\n\nfloat calcOcclusion(in vec3 pos, in vec3 nor, float time)\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for(int i = 0; i<5; i++)\n    {\n    \tfloat h = 0.01 + 0.11 * float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = map(opos);\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp(1.0 - 2.0 * occ, 0.0, 1.0);\n\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec2 e = vec2(0.0001, 0.);\n\treturn normalize(vec3(map(pos+e.xyy) - map(pos-e.xyy),\n                         map(pos+e.yxy) - map(pos-e.yxy),\n                         map(pos+e.yyx) - map(pos-e.yyx)));\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float time )\n{\n    float res = 1.0;\n\n    float tmax = 12.0;\n    \n    float k = 10.0;\n    \n    float t = 0.02;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.05, 0.40 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat castRay(in vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    for(int i=0; i<100; i++)\n    {\n        vec3 pos = ro + t*rd;\n\n        float h = map(pos);\n        if(h<0.001)\n        {\n        \tbreak;\n        }\n        t+= h;\n        if(t>20.0) break;       \t         \n    }\n    if(t>20.0) t = -1.0;\n    return t;\n}\n\n\n#define AA 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    vec3 col = vec3(0.46,0.4,0.42);\n    for(int m=0; m<AA;m++)\n    for(int n=0; n<AA; n++)\n    {\n    \tvec2 off = -.5 + vec2(float(m),float(n))/ float(AA);\n        \n        vec2 p = (2.0*(fragCoord+off) - iResolution.xy)/iResolution.y;\n\n        //float an = 0.1 * iTime;\n        float an = 10.0 * iMouse.x/iResolution.x;\n        //oat anz = 10.0 * iMouse.y/iResolution.y;\n        vec3 ro =  2.5 * vec3(1.0*sin(an),.2, 1.0*cos(an));\n        vec3 ta = vec3(0.0,0.0,0.0);\n\n        vec3 ww = normalize(ta-ro);\n        vec3 uu = normalize(cross(ww, vec3(0,1,0)));\n        vec3 vv = normalize(cross(uu,ww));\n\n\n        vec3 rd = normalize(p.x*uu + p.y*vv + 1.1*ww);\n\n        //vec3 col = vec3(0.18,0.1,0.2) - .5 * rd.y;\n        \n        float noise = smoothstep(-0.05 , .99 , N21(p));\n        col *= max(vec3(noise), col*1.85);\n\n        float t = castRay(ro,rd);\n\n\n        if(t>0.0)\n        {\n            float time= iTime;\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            vec3 mate = vec3(0.18);\n            vec3 sun_lig = normalize(vec3(0.6,0.35,0.5));\n            float occ = calcOcclusion( pos, nor, time )* .8;\n            vec3 sun_dir = normalize(vec3(0.8,0.4,0.8));\n            float sun_dif = clamp(dot(nor,sun_dir), 0.0,1.0);\n            //float sun_sha = step(castRay(pos+nor*0.001, sun_dir), 0.0);\n            //soft one\n\n\n            float sun_sha = calcSoftshadow( pos, sun_lig, time );\n\n            float sky_dif = clamp(.5 + .5 * dot(nor, vec3(0.,1.,0.)), 0.0,1.0);\n            float bou_dif = clamp(.5 + .5 * dot(nor, vec3(0.,-1.,0.)), 0.0,1.0);\n            //col = mate*vec3(7.0,4.5,3.0) * sun_dif*sun_sha;\n\n            //Use black and white\n            col = vec3(1.5,1.5,1.5) * vec3(0.5,.5,.5) * sun_dif*sun_sha*occ;\n            //col += vec3(1.0,1.0,1.0)*vec3(0.1,0.0,0.0) * sky_dif;        \n            //col += vec3(1.0,1.0,1.0)*vec3(0.,0.0,0.0) * bou_dif;\n            col += mate*vec3(0.5,0.8,0.9) * sky_dif;        \n            col += mate*vec3(0.7,0.3,0.2) * bou_dif;\n\n            float noise = smoothstep(-0.05 , .99 , N21(pos.xy));\n            \n\n            col *= max(vec3(noise), col*1.85);\n            \n            //col = vec3(1.);\n            \n           \n        }\n        \n        \n        col = pow(col, vec3(0.4545));\n        tot += col;\n    }\n    \n    tot /= float(AA*AA);\n    // Output to screen\n    fragColor = vec4(tot,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}