{
    "Shader": {
        "info": {
            "date": "1611249653",
            "description": "dorked to add mouse controls and to take a dive into fibonacciSphere-recursion\n\nhttps://www.shadertoy.com/view/XlcfRs[/url]. Make AA 1 in line 7 if it renders too slow for you",
            "flags": 0,
            "hasliked": 0,
            "id": "3lVczG",
            "likes": 4,
            "name": "Fork Planet Fal ollj 571",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "fractal",
                "distancefield",
                "sdf"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 419
        },
        "renderpass": [
            {
                "code": "//parent        (iq): https://www.shadertoy.com/view/lltBWB\n//grandparent (Klem): https://www.shadertoy.com/view/XlcfRs\n//\n//grandparent==Romanesco Broccoli\n\n//parent Youtube: https://www.youtube.com/watch?v=q1OBrqtl7Yo\n\n//fastCompile has more loops (less unrolling) and less branches\n#define fastCompile\n\n\n//Created by inigo quilez - iq/2018\n//License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//Pretty much a modification to Klems' shader (https://www.shadertoy.com/view/XlcfRs)\n\n\n#define INTERACTIVE\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2//Change AA to 1 if it renders too slow for you\n#endif\n\n\n#define PI acos(-1.)\n#define PHI 1.61803398875\n\n\n#define iR iResolution\n#define ZERO (min(iFrame,0))\n\n#define sat(a) clamp(a,0.,1.)\n#define ss(a,b,c) smoothstep(a,b,c)\n#define ss0( b,c) ss (0.,b,c)\n#define ss01(  c) ss0(  1.,c)\n\n\nfloat pd(vec2 F,vec2 G){return dot(F,G.yx*vec2(-1,1));}\nvec2 cs(float a){return vec2(cos(a),sin(a));}\nfloat mu(vec2 a){return a.x*a.y;}\n\nmat3 makeBase(vec3 w\n){float k=inversesqrt(1.0-w.y*w.y)\n ;return mat3(vec3(-w.z,0.0,w.x)*k\n ,vec3(-w.x*w.y,1.0-w.y*w.y,-w.y*w.z)*k\n ,w);}\n\n//https://iquilezles.org/articles/intersectors\nvec2 sphIntersect(in vec3 ro,vec3 rd,float rad\n){float b=dot(ro,rd)\n ;float c=dot(ro,ro)-rad*rad\n ;float h=b*b-c\n ;if(h<0.0)return vec2(-1.0)\n ;h=sqrt(h)\n ;return vec2(-b-h,-b+h);}\n\n//https://iquilezles.org/articles/distfunctions\nfloat sdCapsule(vec3 p,float b,float r\n){return length(p-vec3(0,0,b)*sat(p.z/b))-r;}//*(0.2+1.6*h);\n\n//modified Keinert et al's inverse Spherical Fibonacci Mapping\nvec4 inverseSF(vec3 p,float n\n){vec2 q=vec2(p)\n ;float phi=min(atan(q.y,q.x),PI)\n ;float k=max(floor(log(n*PI*sqrt(5.0)*(1.-p.z*p.z))/log(PHI+1.)),2.0)\n ;float Fk=pow(PHI,k)/sqrt(5.0)\n ;vec2 F=vec2(round(Fk),round(Fk*PHI))\n ;vec2 G=PI*(fract((F+1.0)*PHI)-(PHI-1.0))\n ;vec2 c=floor(mat2(F.y,-F.x,G.y,-G.x)/pd(F,G)\n               *.5*vec2(phi,n*p.z-n+1.0))\n ;float f=0.\n ;vec4 r=vec4(0)\n ;for(int i=0;i<4;i++\n ){float d=dot(F,vec2(i&1,i>>1)+c),t=1.-(2.*d+1.)/n  \n  ;vec3 q=vec3(cs(2.*PI*fract(d*PHI))*sqrt(1.-t*t),t)\n  ;t=dot(p,q);if(t>f){f=t;r=vec4(q,d);}}\n ;return r;}\n\n//return color.xyz,TileiD\nvec4 ground(vec3 p,float lp,inout float dmin,float TileCount\n){p/=lp\n ;float hh=max(3.,floor(TileCount*700.))//ugly below 3\n ;vec4 fibo=inverseSF(p,hh)\n ;hh=1.-ss(.05,.1,length(fibo.xyz-p))\n ;dmin-=.07*hh\n ;return vec4(.5,1,1,10)*.1*hh*(1.+.5*sin(fibo.w*111.1));}\n\n//https://www.shadertoy.com/view/XlcfRs\nvec4 romanesco(vec3 p,float s,vec3 fp,inout float dmin,bool doColor,vec4 color,float tileCount\n){float iTree=3.\n ;for(float i=0.;i<iTree;i++ //recursive fibbonacciSphere\n ){float h=i/(iTree-1.)\n  ;float fsi=max(3.,floor(tileCount*65.+75.*i/(iTree-1.)))//ugly below 3\n  ;vec4 f=inverseSF(normalize(p),fsi)\n  ;p-=f.xyz\n  ;p=p*makeBase(f.xyz)\n  ;float scale=6.6+2.0*sin(111.0*f.w)\n  ;p*=scale\n  ;p.xy*=1.2\n  ;p.z-=3.-length(p.xy)*.6*sin(f.w*212.1)\n  ;s*=scale\n  #ifdef INTERACTIVE\n  ;int j=int(i)\n  ;float d=sdCapsule(p+vec3(0,0,6),6.*fp[j],mix(-40.,.42*fp[j],ss0(.1,fp[j])))\n  #else\n  ;float d=sdCapsule(p,-6.,.42)\n  #endif\n  ;d/=s\n  ;if(d<dmin\n  ){if(doColor\n   ){color.w*=ss0(5./s,dmin-d)\n    ;if(i==0.//tree stem\n    ){color.xyz=vec3(0.425,0.36,0.1)*1.1//fall\n     ;//color.xyz=vec3(0.4,0.8,0.1);//summer\n     ;//color.xyz=vec3(0.4,0.4,0.8);//winter\n     ;}\n    ;color.zyx+=.3*(1.-sqrt(h))*sin(f.w*1111.+vec3(0,1,2))\n    ;color.xyz=max(color.xyz,0.);}\n   ;dmin=d\n  ;}else color.w*=.4*(.1+.9*ss0(1./s,d-dmin))\n ;}return color;}\n\nfloat map(vec3 p,out vec4 color,bool doColor\n){float lp=length(p)\n ;float dmin=lp-1.0;\n ;float s=1.0\n ;float tileCount=iMouse.y/iResolution.y\n ;color=ground(p,lp,dmin,tileCount)\n #ifdef INTERACTIVE\n ;//float tt=mod(iTime,5.0)\n ;float tt=4.0*iMouse.x/iR.x\n ;vec3 fp=ss01(tt-vec3(0,1,2))\n #endif\n ;color=romanesco(p,s,fp,dmin,doColor,color,tileCount)\n ;return dmin;}\n\n//https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 pos,float ep\n){vec4 kk\n #ifdef fastCompile\n ;//prevent the compiler from inlining map() 4 times\n ;vec3 n=vec3(0)\n ;for(int i=ZERO;i<4;i++\n ){vec3 e=0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0)\n  ;n+=e*map(pos+e*ep,kk,false);}\n ;return normalize(n);}\n #else\n ;vec2 e=vec2(1.0,-1.0)*0.5773\n ;return normalize(e.xyy*map(pos+e.xyy*ep,kk,false)\n +e.yyx*map(pos+e.yyx*ep,kk,false)\n +e.yxy*map(pos+e.yxy*ep,kk,false)\n +e.xxx*map(pos+e.xxx*ep,kk,false)) ;}\n #endif \n\n//https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow(vec3 ro,vec3 rd,float tmin,float tmax,float k\n){vec2 bound=sphIntersect(ro,rd,2.1)\n ;tmin=max(tmin,bound.x)\n ;tmax=min(tmax,bound.y)\n ;float res=1.\n ;float t=tmin\n ;for(int i=0;i<50;i++\n ){vec4 kk\n  ;float h=map(ro+rd*t,kk,false)\n  ;res=min(res,k*h/t)\n  ;t+=clamp(h,.02,.2)\n  ;if(res<0.005 || t>tmax) break;}\n ;return sat(res);}\n\nfloat raycast(in vec3 ro,vec3 rd,float tmin,float tmax\n){vec4 kk\n ;float t=tmin\n ;for(int i=0;i<512;i++\n ){vec3 p=ro+t*rd\n  ;float h=map(p,kk,false)\n  ;if(abs(h)<(0.15*t/iR.x))break\n  ;t+=h*0.5\n  ;if(t>tmax) return -1.0;}\n ;//if(t>tmax) t=-1.0\n ;return t;}\n\nvec3 spe(vec4 mate,vec3 nor,vec3 pos,vec3 rd,vec3 col//specular\n){vec3 lig=normalize(vec3(1,0,.7))\n    ;float dif=sat(.5+.5*dot(nor,lig))\n    ;float sha=calcSoftshadow(pos+.0001*nor,lig,0.0001,2.,6.)\n    ;col+=mate.xyz*dif*vec3(1.8,0.6,0.5)*1.1*vec3(sha,sha*0.3+0.7*sha*sha,sha*sha)\n    ;vec3 hal=normalize(lig-rd)\n    ;float spe=sat(dot(nor,hal))\n    ;float fre=sat(dot(-rd,lig))\n    ;fre=0.2+0.8*pow(fre,5.)\n    ;spe*=spe\n    ;spe*=spe\n    ;spe*=spe\n    ;return col+1.0*(0.25+0.75*mate.x)*spe*dif*sha*fre;}\n\nvec3 amb(vec4 mate,vec3 nor//ambient\n){vec3 lig=normalize(vec3(-1,0,0))\n ;float dif=sat(0.5+0.5*dot(nor,lig))\n ;return mate.rgb*dif*vec3(1.2,0.9,0.6)*0.2*mate.w;}\n\nvec3 dif(vec4 mate,vec3 nor,vec3 upp\n){float dif=sat(0.3+0.7*dot(nor,upp))\n #if 0\n ;dif*=0.05+0.95*calcSoftshadow(pos+0.0001*nor,upp,0.0001,1.,1.)\n ;return mate.xyz*dif*5.0*vec3(0.1,0.1,0.3)*mate.w;}\n #else\n ;return mate.xyz*dif*3.0*vec3(0.1,0.1,0.3)*mate.w*(0.2+0.8*mate.w);}\n #endif\n\nvec3 fre(vec4 mate,vec3 nor,vec3 col,vec3 rd\n){float fre=sat(1.0+dot(rd,nor))\n ;return .3*vec3(1.,.3,.2)*mate.xyz*mate.xyz*fre*fre*mate.w;}\n\nvec3 gam(vec3 col\n){return 2.*pow(col,vec3(.7,.85,1))*(.7+0.3*smoothstep(0.0,25.0,abs(iTime-31.)));}\n\nvoid mainImage(out vec4 fragColor,vec2 u\n){float an=(iTime-10.0)*0.05\n ;vec3 ro=vec3(4.5*sin(an),0.0,4.5*cos(an))\n ;mat3 ca=makeBase(normalize(-ro))//cameraMatrix from RayDirection\n ;vec3 tot=vec3(0)\n #if AA>1\n ;for(int m=ZERO;m<AA;m++)for(int n=ZERO;n<AA;n++\n ){vec2 p=vec2(float(m),float(n))/float(AA) - 0.5\n #else \n ;vec2 p=0.\n #endif\n ;p=(-iR.xy+2.*(u+p))/iR.y\n ;vec3 rd=ca*normalize(vec3(p.xy,2.2))\n ;vec3 col=vec3(0.1,0.14,0.18)+0.1*rd.y\n ;vec2 bound=sphIntersect(ro,rd,2.1)//boundingVolume\n ;if(bound.x>0.\n ){float t=raycast(ro,rd,bound.x,bound.y)\n  ;if(t>0.\n  ){vec3 ro=ro+t*rd\n   ;vec3 nor=calcNormal(ro,0.01)\n   ;vec4 mate\n   ;map(ro,mate,true)\n   ;col=vec3(0)\n   ;col+=spe(mate,nor,ro,rd,col)\n   ;col+=amb(mate,nor)\n   ;col+=dif(mate,nor,normalize(ro))\n   ;col+=fre(mate,nor,col,rd)\n   ;col=gam(col)\n   ;}}\n ;col=pow(col,vec3(0.4545));//gamma\n ;tot+=col\n #if AA>1\n ;}tot/=float(AA*AA)\n #endif\n ;vec2 q=u/iR.xy\n ;tot*=pow(16.0*mu(q)*mu(1.-q),.2)\n ;fragColor=vec4(tot,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//https://www.shadertoy.com/view/lttfW2  \n//https://www.shadertoy.com/view/3dffDS\n//https://www.shadertoy.com/view/3llGWS\n//have better animation but worse colors\n\n//https://www.shadertoy.com/view/wtKyRG\n//NOT interpolate with neighboors\n//, but does smin() with a spheremapped displacementMap.\n\n//just some other inverseSF() funtions\n\n//=================================================================================================\n// https://dokumen.tips/documents/spherical-fibonacci-mapping-fibonacci-mapping-benjamin-keinert-1matthias-innmann.html\n//=================================================================================================\nconst float PI  = 3.14159265359;\nconst float PHI = 1.61803398875;\n\n\n\nvec2 inverseSFBasic(vec3 p, float n//https://www.shadertoy.com/view/lllXz4\n){float m = 1.0 - 1.0/n\n ;float phi = min(atan(p.y, p.x), PI), cosTheta = p.z;\n    \n    float k  = max(2.0, floor( log(n * PI * sqrt(5.0) * (1.0 - cosTheta*cosTheta))/ log(PHI+1.0)));\n    float Fk = pow(PHI, k)/sqrt(5.0);\n    vec2  F  = vec2( round(Fk), round(Fk * PHI) ); // k, k+1\n\n    vec2 ka = 2.0*F/n;\n    vec2 kb = 2.0*PI*( fract((F+1.0)*PHI) - (PHI-1.0) );    \n    \n    mat2 iB = mat2( ka.y, -ka.x, \n                    kb.y, -kb.x ) / (ka.y*kb.x - ka.x*kb.y);\n    \n    vec2 c = floor( iB * vec2(phi, cosTheta - m));\n    float d = 8.0;\n    float j = 0.0;\n    for( int s=0; s<4; s++ ) \n    {\n        vec2 uv = vec2( float(s-2*(s/2)), float(s/2) );\n        \n        float i = dot(F, uv + c); // all quantities are ingeters (can take a round() for extra safety)\n        \n        float phi = 2.0*PI*fract(i*PHI);\n        float cosTheta = m - 2.0*i/n;\n        float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n        \n        vec3 q = vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, cosTheta );\n        float squaredDistance = dot(q-p, q-p);\n        if (squaredDistance < d) \n        {\n            d = squaredDistance;\n            j = i;\n        }\n    }\n    return vec2( j, sqrt(d) );\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}