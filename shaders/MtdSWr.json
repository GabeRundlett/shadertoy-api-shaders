{
    "Shader": {
        "info": {
            "date": "1479139821",
            "description": "Tried to recreate mr. div's cubic_tunnel animgif for Codevember 2016\n[url]http://mrdiv.tumblr.com/post/90669206322/cubictunnel[/url]\n\nDidn't have enough experience and time to properly mimic the materials, though.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "MtdSWr",
            "likes": 34,
            "name": "Cubic Tunnel",
            "published": 3,
            "tags": [
                "raymarching",
                "tunnel",
                "codevember",
                "mrdiv"
            ],
            "usePreview": 0,
            "username": "xorxor",
            "viewed": 1386
        },
        "renderpass": [
            {
                "code": "// Created by XORXOR, 2016\n// Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)\n// https://www.shadertoy.com/view/4ldXR4\n//\n// Tried to recreate mr. div's cubic_tunnel animgif\n// http://mrdiv.tumblr.com/post/90669206322/cubictunnel\n//\n// Related:\n// Plasma cube by patu (cube edges)\n// https://www.shadertoy.com/view/4d3SRN\n//\n// Cave Entrance by Shane (bump mapping)\n// https://www.shadertoy.com/view/ltjXzd\n\n//#define ANTIALIAS\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs( p ) - b;\n    return min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nfloat map( vec3 p )\n{\n    p.z = mod( p.z, 8.0 );\n\n    float d = sdBox( p - vec3( 0.0, 1.0, 1.0 ), vec3( 1.5, 0.5, 0.5 ) );\n    d = min( d, sdBox( p - vec3( 1.0, 0.0, 1.0 ), vec3( 0.5 ) ) );\n    d = min( d, sdBox( p - vec3( -1.0, 1.0, 3.0 ), vec3( 0.5, 0.5, 1.5 ) ) );\n    d = min( d, sdBox( p - vec3( -1.0, 0.0, 5.0 ), vec3( 0.5, 1.5, 0.5 ) ) );\n    d = min( d, sdBox( p - vec3( 0.0, -1.0, 5.0 ), vec3( 0.5 ) ) );\n    d = min( d, sdBox( p - vec3( 1.0, -1.0, 6.5 ), vec3( 0.5, 0.5, 2.0 ) ) );\n    d = min( d, sdBox( p - vec3( 1.0, -1.0, 0.5 ), vec3( 0.5, 0.5, 1.0 ) ) );\n    return d;\n}\n\nfloat trace( vec3 ro, vec3 rd, float kTMax )\n{\n    const float kTMin = 0.01;\n    const float kEps = 0.001;\n\n    float t = kTMin;\n    float res;\n    for ( int i = 0; i < 64; i++ )\n    {\n        vec3 pos = ro + rd * t;\n        res = map( pos );\n        if ( ( res < kEps ) || ( t > kTMax ) )\n        {\n            break;\n        }\n        t += res;\n    }\n\n    if ( t < kTMax )\n    {\n        return t;\n    }\n    else\n    {\n        return -1.0;\n    }\n}\n\nfloat traceRefl( vec3 ro, vec3 rd, float kTMax )\n{\n    const float kTMin = 0.01;\n    const float kEps = 0.001;\n\n    float t = kTMin;\n    float res;\n    for ( int i = 0; i < 100; i++ )\n    {\n        vec3 pos = ro + rd * t;\n        res = map( pos );\n        if ( ( res < kEps ) || ( t > kTMax ) )\n        {\n            break;\n        }\n        t += res * clamp( 0.1 * float( i + 1 ) * 0.1, 0.0, 1.0 );\n    }\n\n    if ( t < kTMax )\n    {\n        return t;\n    }\n    else\n    {\n        return -1.0;\n    }\n}\n\nmat3 calcCamera( vec3 eye, vec3 target )\n{\n    vec3 cw = normalize( target - eye );\n    vec3 cu = cross( cw, vec3( 0, 1, 0 ) );\n    vec3 cv = cross( cu, cw );\n    return mat3( cu, cv, cw );\n}\n\nfloat edge2d( vec2 coord )\n{\n    const float edge = 0.95;\n    vec2 ec = smoothstep( edge, 1.0, coord );\n    ec += 1.0 - smoothstep( -1.0, -edge, coord );\n    return dot( ec, vec2( 1.0 ) );\n}\n\nfloat edge( vec3 coord )\n{\n    vec3 c = 1.0 - 2.0 * fract( ( coord + 0.5 ) );\n    float x = edge2d( c.xy );\n    float y = edge2d( c.yz );\n    float z = edge2d( c.xz );\n    return 1.0 - x * y * z;\n}\n\nvec3 calcNormal( vec3 p )\n{\n    const vec2 e = vec2( 0.005, 0 );\n    float dp = map( p );\n    return normalize( vec3( dp - map( p - e.xyy ),\n                            dp - map( p - e.yxy ),\n                            dp - map( p - e.yyx ) ) );\n}\n\nfloat calcShadow( vec3 ro, vec3 rd, float mint, float maxt )\n{\n    float t = mint;\n    float res = 1.0;\n    for ( int i = 0; i < 10; i++ )\n    {\n        float h = map( ro + rd * t );\n        res = min( res, 1.5 * h / t );\n        t += h;\n        if ( ( h < 0.001 ) || ( t > maxt ) )\n        {\n            break;\n        }\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcAo( vec3 pos, vec3 n )\n{\n    float sca = 2.0;\n    float occ = 0.0;\n    for( int i = 0; i < 5; i++ )\n    {\n\n        float hr = 0.01 + float( i ) * 0.5 / 4.0;\n        float dd = map( n * hr + pos );\n        occ += ( hr - dd ) * sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );\n}\n\n// Bump mapping from Shane:\n// https://www.shadertoy.com/view/ltjXzd\n\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n )\n{\n    n = max( ( abs( n ) - 0.2 ) * 7.0 , 0.001 );\n    n /= ( n.x + n.y + n.z );\n\n    return 1.0 - ( texture( tex, p.yz ) * n.x +\n                   texture( tex, p.zx ) * n.y +\n                   texture( tex, p.xy ) * n.z ).xyz;\n}\n\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor)\n{\n    const float eps = 0.01;\n    vec3 grad = vec3( tex3D( tex, vec3( p.x - eps, p.y, p.z ), nor ).x,\n                      tex3D( tex, vec3( p.x, p.y - eps, p.z ), nor ).x,\n                      tex3D( tex, vec3( p.x, p.y, p.z - eps ), nor ).x );\n\n    grad = ( grad - tex3D( tex,  p , nor ).x ) / eps;\n\n    grad -= nor * dot( nor, grad );\n\n    return normalize( nor + grad * bumpfactor );\n}\n\nvec3 color( vec3 pos, vec3 nor, vec3 ro, vec3 rd )\n{\n    vec3 col = vec3( 0.36, 0.15, 0.06 );\n\n    if ( dot( rd, rd ) > 0.001 )\n    {\n        nor = doBumpMap( iChannel0, pos, nor, 0.003 );\n\n        vec3 ref = reflect( rd, nor );\n        vec3 ldir = normalize( vec3( -2.0, 2.5, 4.0 ) );\n        float dif = max( dot( nor, ldir ), 0.0 );\n        float spe = pow( clamp( dot( ref, ldir ), 0.0, 1.0 ), 6.0 );\n\n        col += 0.2 * dif;\n        col += spe;\n    }\n\n    float ao = calcAo( pos, nor );\n    col *= ( 0.3 +  ao );\n\n    col *= edge( pos );\n    float d = abs( pos.z - ro.z );\n    col = mix( 1.0 - col, col, clamp( d / 10.0, 0.0, 1.0 ) );\n\n    col += pow( 0.3 * max( abs( pos.x ), abs( pos.y ) ), 2.0 );;\n    return col;\n}\n\nvec3 render( vec3 ro, vec3 rd )\n{\n    float t = trace( ro, rd, 40.0 );\n    vec3 col = vec3( 1.0 );\n    if ( t > 0.0 )\n    {\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal( pos );\n\n        vec3 ref = reflect( rd, nor );\n        col = color( pos, nor, ro, rd );\n\n        float tRef = traceRefl( pos, ref, 10.0 );\n\n        if ( tRef > 0.0 )\n        {\n            vec3 refPos = pos + tRef * ref;\n            vec3 refNor = calcNormal( refPos );\n\n            col += 0.1 * color( refPos, refNor, vec3( 0.0 ), vec3( 0.0 ) );\n        }\n        col = mix( col, vec3( 1.0 ), smoothstep( 0.0, 30.0, t ) );\n    }\n    return col;\n}\n\nmat2 rot2( float a )\n{\n    float c = cos( a );\n    float s = sin( a );\n    return mat2( c, -s, s, c );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = vec2( 0.0 );\n    if ( iMouse.z > 0.5 )\n    {\n        mo = 2.0 * iMouse.xy / iResolution.xy - 1.0;\n        mo *= 3.14159 * 0.1;\n    }\n\n    float time = iTime * 6.0;\n    vec3 eye = vec3( 0.0, 0.0, 0.0 - time );\n    vec3 target = vec3( 0.0, 0.0, -20.0 );\n    target.xz *= rot2( mo.x );\n    target.yz *= rot2( mo.y );\n    target.z -= time;\n    mat3 cam = calcCamera( eye, target );\n\n    vec3 col = vec3( 0.0 ) ;\n#ifdef ANTIALIAS\n    for ( int i = 0; i < 4; i++ )\n    {\n        vec2 off = vec2( mod( float( i ), 2.0 ), mod( float( i / 2 ), 2.0 ) ) / 2.0;\n#else\n        vec2 off = vec2( 0.0 );\n#endif\n        vec2 uv = ( fragCoord.xy + off - 0.5 * iResolution.xy ) / iResolution.y;\n        vec3 rd = cam * normalize( vec3( uv, 2.0 ) );\n\n        col += render( eye, rd );\n#ifdef ANTIALIAS\n    }\n    col *= 1.0 / 4.0;\n#endif\n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}