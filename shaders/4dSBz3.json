{
    "Shader": {
        "info": {
            "date": "1501424191",
            "description": "Please have a look at the [url=https://www.shadertoy.com/view/4dSfRc]tutorial[/url].",
            "flags": 0,
            "hasliked": 0,
            "id": "4dSBz3",
            "likes": 38,
            "name": "Super simple raymarching example",
            "published": 3,
            "tags": [
                "raymarching",
                "example",
                "simple",
                "distance",
                "fields",
                "sh17c"
            ],
            "usePreview": 0,
            "username": "reinder",
            "viewed": 4430
        },
        "renderpass": [
            {
                "code": "// Super simple raymarching example. Created by Reinder Nijhoff 2017\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n// @reindernijhoff\n// \n// https://www.shadertoy.com/view/4dSBz3\n//\n// This is the shader used as example in my ray march tutorial: https://www.shadertoy.com/view/4dSfRc\n//\n// Created for the Shadertoy Competition 2017 \n//\n\n//\n// Distance field function for the scene. It combines\n// the seperate distance field functions of three spheres\n// and a plane using the min-operator.\n//\nfloat map(vec3 p) {\n    float d = distance(p, vec3(-1, 0, -5)) - 1.;     // sphere at (-1,0,5) with radius 1\n    d = min(d, distance(p, vec3(2, 0, -3)) - 1.);    // second sphere\n    d = min(d, distance(p, vec3(-2, 0, -2)) - 1.);   // and another\n    d = min(d, p.y + 1.);                            // horizontal plane at y = -1\n    return d;\n}\n\n//\n// Calculate the normal by taking the central differences on the distance field.\n//\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n        e.xyy * map(p + e.xyy) +\n        e.yyx * map(p + e.yyx) +\n        e.yxy * map(p + e.yxy) +\n        e.xxx * map(p + e.xxx));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 ro = vec3(0, 0, 1);                           // ray origin\n\n    vec2 q = (fragCoord.xy - .5 * iResolution.xy ) / iResolution.y;\n    vec3 rd = normalize(vec3(q, 0.) - ro);             // ray direction for fragCoord.xy\n\n    // March the distance field until a surface is hit.\n    float h, t = 1.;\n    for (int i = 0; i < 256; i++) {\n        h = map(ro + rd * t);\n        t += h;\n        if (h < 0.01) break;\n    }\n\n    if (h < 0.01) {\n        vec3 p = ro + rd * t;\n        vec3 normal = calcNormal(p);\n        vec3 light = vec3(0, 2, 0);\n        \n        // Calculate diffuse lighting by taking the dot product of \n        // the light direction (light-p) and the normal.\n        float dif = clamp(dot(normal, normalize(light - p)), 0., 1.);\n\t\t\n        // Multiply by light intensity (5) and divide by the square\n        // of the distance to the light.\n        dif *= 5. / dot(light - p, light - p);\n        \n        \n        fragColor = vec4(vec3(pow(dif, 0.4545)), 1);     // Gamma correction\n    } else {\n        fragColor = vec4(0, 0, 0, 1);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}