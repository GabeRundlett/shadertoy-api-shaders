{
    "Shader": {
        "info": {
            "date": "1612904324",
            "description": "weedato",
            "flags": 32,
            "hasliked": 0,
            "id": "3tcfRS",
            "likes": 30,
            "name": "Day 420",
            "published": 3,
            "tags": [
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 914
        },
        "renderpass": [
            {
                "code": "\n// modern gpus can't handle my weed, it's so strong! \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord -= 0.5*iResolution.xy;\n    //fragCoord *= 0.99;\n    fragCoord += 0.5*iResolution.xy;\n    \n    float n1d = texelFetch(iChannel1,ivec2(mod(fragCoord + vec2(float(iFrame),0.),256.)),0).x;\n    vec3 n  = texelFetch(iChannel1,ivec2(mod(fragCoord  + n1d*200. ,256.)),0).xyz;\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    fragColor.xyz =texture(iChannel0,fragCoord/iResolution.xy).xyz;\n    \n    \n    fragColor.xyz = pow(fragColor.xyz, vec3(1.1,1.2,1.));\n    \n    //fragColor.xyz = 1. - fragColor.xyz;\n    \n    //fragColor.xyz *= 1. - dot(uv,uv)*0.8;\n    fragColor.xyz = pow(fragColor.xyz, vec3(0.4545 + n*0.05));\n    \n    \n    \n    //fragColor = texture(iChannel2,fragCoord/iResolution.xy);\n    \n    fragColor.xyz += smoothstep(1.,0.,length(fragColor))*n*0.04;\n    \n    fragColor.xyz -= smoothstep(0.,1.,length(fragColor))*n*0.05;\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\nmat3 getOrthogonalBasis(vec3 dir){\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n    return mat3(right,up,dir);\n}\n\nfloat cyclicNoise(vec3 p){\n    \n    //p.yz *= rot(1.4);\n    \n    float n = 0.;\n    float amp = 1.;\n    float gain = 0.5;\n    float lac = 1.1 ;\n    \n    vec3 seed = normalize(vec3(3,-1,2));\n    mat3 rotm = getOrthogonalBasis(seed);\n\n    for(float i = 0.; i < 5.; i++){\n        p -= cos(p.zxy*1.5*gain*2. + iTime + i)*0.1;\n        n += (dot(sin(p), cos(p.zxy)))*amp;\n    \n        amp *= gain;\n        p *= lac*rotm;\n\n    }\n    return n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec2 oouv = uv;\n    \n    \n    \n    //vec3 col = vec3(0.7,0.9,0.9)*0.2;\n    vec3 col = vec3(0.4,0.5,0.1)*0.1;\n        \n    \n    float n = cyclicNoise(vec3(uv*5.,iTime*0.5 + 4.));\n    \n    n = cyclicNoise(vec3(uv*10. + n*1.15,iTime));\n        \n    float nb = cyclicNoise(vec3(uv*5.,iTime));\n    \n    float vn = valueNoise(iTime*0.25,5.);\n    float vnb = valueNoiseStepped(iTime/2. + n*0.*pow(vn,0.5) + 5.,2.,4.);\n    float vnc = valueNoiseStepped(iTime/2.,4.,4.);\n    \n    \n    float dfuv = fwidth(length(uv));\n    \n    vec2 p = uv;\n        \n    \n    for(float j = 0.; j < 712.; j++){\n        vec2 r = r12(j);\n        float rb = r11(j);\n        vec2 p = uv;\n        \n        \n        \n        float t = iTime + r11(j)*40.;\n        \n        float sp = 1. + r.y*4.;\n        \n        sp *= 7.4;\n        p.x += (r.x*2.2 - 1.)*iResolution.x/iResolution.y*0.5;\n        \n        p.y -= mod(t/sp,1.95) - 1.;\n        \n        \n        p.xy *= rot(iTime*(r.y*1. - 0.5)*0.5 + r.y*20.);\n        \n        //float d = length(p) - 0.01;\n        float sc = 0.16 + 0.4*rb;\n        vec4 leaf = texture(iChannel1,p/sc);\n        float d = leaf.w*sc;         \n        \n        col = mix(col, col*0.4 + col*col*col*0.6, smoothstep(0.03,0.,d));\n        \n        vec3 c = vec3(0.4,0.5,0.1);\n        \n        c += vec3(0.1,0.,0.)*sin(j);\n        float bl = (sin(j*20. + r.y));\n        c += vec3(0.,0.1,-0.15*0.)*bl;\n        \n        c += vec3(0.,0.,0.05)*abs(sin(r.y*40.));\n        float shad = leaf.y*mix(0.3,1.,smoothstep(0.,0.3,dot(p,p) - leaf.z*0.1));\n        c.x += shad*0.45*leaf.z;\n        \n        \n        float ungr = abs(sin(r.x*20.));\n        c.g += 0.6*ungr*shad*leaf.z;\n        \n        c.b -= shad*0.2*leaf.z*sin(r.y*20.)*(1. - ungr);\n        \n        //c *= smoothstep(1.,0.5,sp*0.04);\n        \n        c *= smoothstep(-0.5,1.,j/700.);\n        col = mix(col, c, smoothstep(0.004,0.,d + 0.002));\n  \n        \n    }\n     \n    \n     \n    if(iMouse.z > 0.)\n        col =  1. - col;\n        \n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float sc = 0. + valueNoise(iTime*14.,2.)*0. ;\n    \n    fragColor.x =texture(iChannel0,(fragCoord + sc*vec2(0,8))/iResolution.xy).x;\n    \n    fragColor.y =texture(iChannel0,(fragCoord + sc*vec2(0,-1))/iResolution.xy).y;\n    \n    fragColor.z =texture(iChannel0,(fragCoord + sc*vec2(0,-4))/iResolution.xy).z;\n    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pmod(p,d) mod(p - (d)*0., (d)) - 0.5*(d)\n\n#define pal(a,b,c,d,e) (a + (b)*sin((c)*(d) + (e))\n\nfloat r11(float i){ return fract(sin(i*25.126)*125.6);}\n\nvec2 r12(float i){float r=r11(i + 4.);  return vec2(r,r11(i + r + 0.5));}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n#define dmin(a,b,c) (max(a.x,-b) < b ? a : vec2(b,c))",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "float sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n    float d = 10e5;\n    float side = -1.;\n    float iters = 4.;\n    for(float i = 0.; i < iters; i++){\n        \n        vec2 p = uv;\n        \n        if(i != 0.)\n            p.x = abs(p.x);\n            \n        p*=rot(3.6*i/iters);\n        p.y += 0.07;\n        vec2 op = p;\n        float liters = 14.;\n        \n        float offssc = 0.4;\n        \n        if(i == 3.){\n            liters = 10.; offssc *= 0.8;\n            }\n        float dLeaf = 10e5;\n        float lside = 1.;\n        for(float j = 0.; j < liters; j++){\n            float lidx = j/liters;\n            p.y -= offssc/liters;\n            //p.x += 0.03*smoothstep(0.1,1.,i/iters)*smoothstep(0.6,1.4,j/iters);\n            p *= rot(-(0.15 + sin(iTime + j*0.1)*0.1)*smoothstep(0.,0.5,i/iters)*smoothstep(0.1,0.4,j/liters));\n            \n            float newlside = mix(-1.,1.,smoothstep(0.004,0.,-p.x - 0.0));\n            \n            float sa = 0.02 - lidx*0.001;\n            float sb = 0.005;\n            float h = 0.02 + smoothstep(1.,0.3,lidx)*0.04;\n            h *= mix(0.1,1.,smoothstep(0.,0.4,lidx));\n            //h *= mix(1.,0.01,smoothstep(0.6,1.,lidx));\n            \n            \n            vec2 q = p;\n        \n            q.x = abs(q.x);\n            \n        \n            q = q*rot(1.1);\n            float currLeaf = sdUnevenCapsule( q, sa, sb, h);\n            dLeaf = min(dLeaf,currLeaf);\n            \n            lside = mix(lside,newlside, smoothstep(0.001,0.,currLeaf));\n            \n        }\n        d = min(d,dLeaf);\n        \n        //float newlside \n        side = mix(side,lside,smoothstep(0.003,0.,dLeaf - 0.004));\n    }\n\n    uv *= rot(radians(90.)*2.);\n    \n    uv *= rot(smoothstep(0.1,0.35,uv.y)*-0.2);\n    float dholder = sdUnevenCapsule( uv, 0.005, 0.003 + smoothstep(0.2,0.3,uv.y)*0.01, 0.28);\n    //dholder = max(dholder,uv.y - 0.27);\n    \n    d = min(d, dholder);\n    \n    \n    \n    d = mix(d,10.,smoothstep(0.001,0.,-length(uv) + 0.5));\n    \n    fragColor.w = d;\n    fragColor.y = side;\n    fragColor.z = texture(iChannel1,vec2(mod(fragCoord*0.3/iResolution.xy,256.)),0.).x;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}