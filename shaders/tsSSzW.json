{
    "Shader": {
        "info": {
            "date": "1553040040",
            "description": "A modelling & composition exercise for shadertoy with sphere-tracing.\nThis is an almost static scene, so you can hit pause if it's too slow.\nYou can use the mouse to explore several angles of the scene.",
            "flags": 0,
            "hasliked": 0,
            "id": "tsSSzW",
            "likes": 23,
            "name": "Explore",
            "published": 3,
            "tags": [
                "raymarch",
                "alien",
                "model"
            ],
            "usePreview": 0,
            "username": "lsdlive",
            "viewed": 917
        },
        "renderpass": [
            {
                "code": "/*\n@lsdlive\nCC-BY-NC-SA\n\nExplore.\n\nA modelling & composition exercise for shadertoy with sphere-tracing.\nThis is an almost static scene, so you can hit pause if it's too slow.\nYou can use the mouse to explore several angles of the scene.\nI also made a simpler shader for the humanoid model here:\nhttps://www.shadertoy.com/view/ws2SRR\n\n\nGeometries are generated with sphere-tracing algorithms:\nhttp://www.michaelwalczyk.com/blog/2017/5/25/ray-marching\nhttps://iquilezles.org/articles/distfunctions\nhttp://mercury.sexy/hg_sdf/\n\n\nIridescence shading inspired by:\nhttps://twitter.com/minionsart/status/932660640178737163\nhttps://sdm.scad.edu/faculty/mkesson/vsfx419/wip/best/winter11/megan_stifter/iridescence.html\n\nSky background from xt95:\nhttps://www.shadertoy.com/view/4dXSzn\n\nMore about generation of the gradient:\nhttps://iquilezles.org/articles/palettes\n\nMore about noise:\nhttps://thebookofshaders.com/11/\n\nMore about triplanar mapping:\nhttps://catlikecoding.com/unity/tutorials/advanced-rendering/triplanar-mapping/\n\nMore about bump mapping via heighmap or texture:\nhttps://squircleart.github.io/shading/normal-map-generation.html\nhttps://www.shadertoy.com/view/4ss3W7\n\nSome notation:\np: position (usually in world space)\nn: normal\nrd: ray direction (eye or view vector)\nldir: light direction\n\n*/\n\n\n/** Parameters **/\n// put this to 1 if it's too slow\n// put this to 3 to increase quality image\n#define ANTIALIAS 1\n\n\n#define PI 3.14159\n#define TAU 6.28318\n\n#define MAT_PLANE 1\n#define MAT_ALIEN 2\n#define MAT_SHIP 3\n\nint id = 0; // mat id\n\nconst float dist_to = 6.; // distance from camera to the scene\n\nvec3 ldir = normalize(vec3(1.2, .6, -1));\n\nconst float fre_exponent = 5.;\nconst float spe_exponent = 32.;\n\nconst float iri_factor = .7;\nconst float spe_factor = .4;\nconst float dif_factor = .2;\nconst float cub_factor = .09;\nconst float fre_factor = .7;\n\nconst float bump_factor = .008;\nconst float blend_exponent = 32.;\n\n\nconst float gamma = 2.2;\n\n\n/** Libs **/\nvec3 pal(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n\treturn a + b * cos(TAU * (c * t + d));\n}\n\nmat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n// Grad noise https://www.shadertoy.com/view/XdXGW8\nvec2 hash(vec2 uv) {\n\tconst vec2 k = vec2(.3183099, .3678794);\n\tuv = uv * k + k.yx;\n\treturn -1. + 2. * fract(16. * k * fract(uv.x * uv.y *(uv.x + uv.y)));\n}\n\nfloat noise2D(vec2 p) {\n\tvec2 i = floor(p);\n\tvec2 f = fract(p);\n\n\tvec2 u = f * f*(3.0 - 2.0*f);\n\n\treturn mix(mix(dot(hash(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0)),\n\t\tdot(hash(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0)), u.x),\n\t\tmix(dot(hash(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0)),\n\t\t\tdot(hash(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0)), u.x), u.y);\n}\n\nvoid amod(inout vec2 p, float c) {\n\tfloat m = TAU / c;\n\tfloat a = mod(atan(p.y, p.x) - m * .5, m) - m * .5;\n\tp = vec2(cos(a), sin(a)) * length(p);\n}\n\nfloat box(vec3 p, vec3 b) {\n\tb = abs(p) - b;\n\treturn min(max(b.x, max(b.y, b.z)), 0.) + length(max(b, 0.));\n}\n\nfloat sphere(vec3 p, float d) {\n\treturn length(p) - d;\n}\n\n// LJ's short formula\nfloat octahedron(vec3 p, float d) {\n\treturn dot(p, normalize(sign(p))) - d;\n}\n\nvec2 line(vec3 pos, vec3 a, vec3 b) {\n\tvec3 pa = pos - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn vec2(length(pa - h * ba), h);\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(0.5 + 0.5*(b - a) / k, 0.0, 1.0);\n\treturn mix(b, a, h) - k * h*(1.0 - h);\n}\n\nfloat smax(float a, float b, float k) {\n\tfloat h = clamp(0.5 + 0.5*(b - a) / k, 0.0, 1.0);\n\treturn mix(a, b, h) + k * h*(1.0 - h);\n}\n\n\n// http://mercury.sexy/hg_sdf/\nfloat stmin(float a, float b, float k, float n) {\n\tfloat st = k / n;\n\tfloat u = b - k;\n\treturn min(min(a, b), .5 * (u + a + abs(mod(u - a + st, 2. * st) - st)));\n}\n\n\nfloat upper(vec3 p, float obj_id) {\n\tvec3 q = p;\n\n\tp.y -= .4;\n\n\t// body\n\tvec3 torso1_sz = vec3(.28, .31, .28);\n\n\tp.y -= .5;\n\tfloat d = box(p, torso1_sz) - .15;\n\n\t// head\n\tp = q;\n\tp.y -= 1.5;\n\tvec3 head_sz = vec3(.25, .4, .25);\n\n\td = smin(d, box(p, head_sz * .2), .1);\n\td = stmin(d, sphere(p, .42), .6, 14.);\n\n\tp = q;\n\n\t// arm\n\tvec3 arm1_a = vec3(.7, .8, cos(iTime + .5 + obj_id * 1.3) * .05);\n\tvec3 arm1_b = vec3(.7, .05, 0);\n\tfloat arm1_sz = .15;\n\n\tfloat arm1 = line(p, arm1_a, arm1_b).x - arm1_sz;\n\td = smin(d, sphere(p - arm1_a, arm1_sz), .5);\n\td = smin(d, arm1, .3);\n\n\tvec3 arm2_a = arm1_b;\n\tvec3 arm2_b = vec3(.7, -.8, .4 + cos(2. * iTime + obj_id * 2.3) * .09);\n\tfloat arm2_sz = .12;\n\n\tfloat arm2 = line(p, arm2_a, arm2_b).x - arm2_sz - p.y*.04;\n\td = smin(d, arm2, .15);\n\n\treturn smax(d, -length(p.zy - arm2_a.zy) + .08, .08);\n}\n\nfloat bottom(vec3 p, float obj_id) {\n\n\t// hip\n\tvec3 hip_sz = vec3(.2, .22, .2);\n\tfloat d = box(p, hip_sz) - .15;\n\n\t// leg\n\tvec3 leg1_a = vec3(.4, -.3, 0);\n\tvec3 leg1_b = vec3(.4 + cos(2. * iTime + obj_id * .3) * .01, -1.2, .2);\n\tfloat leg1_sz = .2;\n\n\tfloat leg1 = line(p, leg1_a, leg1_b).x - leg1_sz;\n\td = stmin(d, leg1, .15, 4.);\n\n\tvec3 leg2_a = leg1_b;\n\tvec3 leg2_b = vec3(.4, -2.8, 0);\n\tfloat leg2_sz = .17;\n\n\tfloat leg2 = line(p, leg2_a, leg2_b).x - leg2_sz - p.y*.02;\n\n\td = smin(d, leg2, .27);\n\td = smax(d, -length(p.xy - leg2_a.xy) + .1, .14);\n\treturn d;\n}\n\nfloat heart(vec3 p, float obj_id) {\n\tp.xz *= r2d(iTime + obj_id * .2);\n\treturn octahedron(p, .1);\n}\n\nfloat alien(vec3 p, float obj_id) {\n\n\tp.zy *= r2d(-.1);\n\tp.y -= .4;\n\tp.x = abs(p.x);\n\n\t// Main body\n\tfloat d = min(upper(p, obj_id), bottom(p, obj_id));\n\n\t// Medium hole & heart\n\tp.y -= .3;\n\td = smax(d, -length(p.xy) + .25, .3);\n\td = min(d, heart(p, obj_id));\n\n\t// Head holes\n\tp.y -= 1.2;\n\tif (obj_id == 0.) {\n\t\td = smax(d, -length(p.xy) + .2, .4);\n\t}\n\telse {\n\t\td = smax(d, -length(p.xy) + .05, .1);\n        p.xy -= vec2(.15, -.2);\n\t\td = smax(d, -length(p.xy) + .05, .1);\n\t}\n\n\treturn d;\n}\n\n\nfloat de(vec3 p) {\n\n\n\t/*float ship = min(\n\tbox(p-vec3(-5, 15, -40), vec3(10, 1, 5)),\n\tbox(p-vec3(-5, 15, -40), vec3(5, 2.5, 10))\n\t);*/\n\n\t// alien structure\n\tfloat ship = sphere(p - vec3(-5, 15, -40), 5.);\n\tvec3 q = p;\n\n\tq -= vec3(-5, 15, -40);\n\tamod(q.xz, 9.);\n\tq.xy += vec2(-8, 3);\n\tq.x += q.y*q.y*.02;\n\tship = smin(ship, length(q.xz) - .5 + q.y* .07 + sin(q.y)*.1, .6);\n\n\n\t// Three aliens\n\tp.xz += .4;\n\tfloat aliens = alien(p, 0.);\n\n\tp.xz += 1.5;\n\tp.xz *= r2d(-.2);\n\taliens = min(aliens, alien(p, 1.));\n\n\tp.x -= 3.5;\n\taliens = min(aliens, alien(p, 1.));\n\n\t// Ground\n\tfloat plane = p.y + 2.55 - p.x*p.x*.008 + noise2D(p.xz) * .1;\n\n\tfloat d;\n\tif (plane < aliens) {\n\t\tid = MAT_PLANE;\n\t\td = plane;\n\t}\n\telse {\n\t\tid = MAT_ALIEN;\n\t\td = aliens;\n\t}\n\n\tif (ship < d) {\n\t\tid = MAT_SHIP;\n\t\td = ship;\n\t}\n\n\treturn d;\n\n}\n\n// suggested from tdhooper in the comment. Thanks!\n// improve compilation time & overall fps.\nconst int NORMAL_STEPS = 6;\nvec3 normal(vec3 pos) {\n\tvec3 eps = vec3(.0001, 0, 0);\n\tvec3 nor = vec3(0);\n\tfloat invert = 1.;\n\tfor (int i = 0; i < NORMAL_STEPS; i++) {\n\t\tnor += de(pos + eps * invert) * eps * invert;\n\t\teps = eps.zxy;\n\t\tinvert *= -1.;\n\t}\n\treturn normalize(nor);\n}\n\nvec3 tex2D(vec2 uv) {\n\tvec3 col = texture(iChannel1, uv).rgb;\n\treturn pow(col, vec3(gamma));\n}\n\nvec3 cubemap(vec3 rd) {\n\tvec3 col = texture(iChannel0, rd).rgb;\n\treturn pow(col, vec3(gamma));\n}\n\n\n// Tri-planar bump-mapping\n// From shane: https://www.shadertoy.com/view/MlXSWX\n// Tri-Planar blending function. Based on an old Nvidia tutorial\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(vec3 p, vec3 n) {\n\tvec3 weight = pow(abs(n), vec3(blend_exponent));\n\t//vec3 weight = max((abs(n) - .2) * 7., .001); // shane's factors\n\tweight /= (weight.x + weight.y + weight.z);\n\n\treturn\n\t\ttex2D(p.yz) * weight.x +\n\t\ttex2D(p.zx) * weight.y +\n\t\ttex2D(p.xy) * weight.z;\n}\n\n#define luma(c) (c.r * .299 + c.g * .587 + c.b * .114)\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\n// convert texture to greyscale, then compute difference to get edge\nvec3 do_bumpmap(vec3 p, vec3 n, float bumpfactor) {\n\tconst float eps = .001;\n\tfloat ref = luma(tex3D(p, n));\n\tvec3 grad = vec3(\n\t\tluma(tex3D(vec3(p.x - eps, p.y, p.z), n)) - ref,\n\t\tluma(tex3D(vec3(p.x, p.y - eps, p.z), n)) - ref,\n\t\tluma(tex3D(vec3(p.x, p.y, p.z - eps), n)) - ref) / eps;\n\n\tgrad -= n * dot(n, grad);\n\treturn normalize(n + grad * bumpfactor);\n}\n\n// iq implementation\nfloat softshadow(in vec3 ro, in vec3 rd, float mint, float k)\n{\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfloat h = 1.0;\n\tfor (int i = 0; i < 100; i++)\n\t{\n\t\th = de(ro + rd * t);\n\t\tres = min(res, k*h / t);\n\t\tt += clamp(h, .005, .1);\n\t}\n\treturn clamp(res, 0., 1.);\n}\n\n// iq implementation\nfloat calculate_aO(vec3 p, vec3 n) {\n\tconst float AO_SAMPLES = 5.;\n\tfloat r = 0., w = 1., d;\n\n\tfor (float i = 1.; i < AO_SAMPLES + 1.1; i++) {\n\t\td = i / AO_SAMPLES;\n\t\tr += w * (d - de(p + n * d));\n\t\tw *= .5;\n\t}\n\n\treturn 1. - clamp(r, 0., 1.);\n}\n\n// from xt95\nvec3 sky(vec3 dir) {\n\tvec3 col = mix(vec3(40., 34., 30.), vec3(18., 28., 44.), min(abs(dir.y)*2. + .5, 1.)) / 255.*.5;\n\tcol *= (1. + vec3(1., .7, .3) / sqrt(length(dir - ldir))*4.); //sun\n\treturn col;\n}\n\nvec3 shading(vec3 p, vec3 rd, vec3 n) {\n\tvec3 h = normalize(ldir - rd); // half vector\n\n\tint mat_id = id;// copy mat id (id is a global variable afected by various computation)\n\n\tfloat sha = softshadow(p, ldir, .02, 64.);\n\tfloat ao = calculate_aO(p, n);\n\tvec3 skybg = sky(reflect(rd, n));\n\n\tn = do_bumpmap(p, n, bump_factor);\n\n\tfloat dotNL = max(0., dot(n, ldir));\n\tfloat dotNV = max(0., dot(n, -rd));\n\tfloat dotNH = max(0., dot(n, h));\n\n\tvec3 albedo = tex3D(p, n);\n\tvec3 cubemap = cubemap(reflect(rd, n));\n\n\tfloat fre = pow(1. - dotNV, fre_exponent);\n\tfloat spe = pow(dotNH, spe_exponent);\n\n\tvec3 col;\n\tif (mat_id == MAT_ALIEN) {\n\n\t\t// green sand\n\t\t/*vec3 iri = pal(dotNV,\n\t\tvec3(.2),\n\t\tvec3(.3),\n\t\tvec3(.7),\n\t\tvec3(.6, .3, .2)\n\t\t);\n\n\t\t// blue - purple\n\t\tiri = pal(dotNV ,\n\t\tvec3(.4),\n\t\tvec3(.5),\n\t\tvec3(.6),\n\t\tvec3(.9, .1, .5)\n\t\t);*/\n\n\t\tvec3 iri = pal(dotNV,\n\t\t\tvec3(.4),\n\t\t\tvec3(.8),\n\t\t\tvec3(.5, .6, .6),\n\t\t\tvec3(.9, .1, .14)\n\t\t);\n\n\t\tcol = iri * iri_factor + spe * spe_factor + dotNL * dif_factor;\n\t\tcol = mix(skybg, col, dotNL*.5 + .5);\n\t}\n\tif (mat_id == MAT_PLANE) {\n\t\tcol = vec3(.2, .1, .0);\n\t\tcol += albedo * .1;\n\n\t\tcol *= sha;\n\t}\n\n\tcol *= ao;\n\n\tcol += cubemap * cub_factor;\n\n\tif (mat_id == MAT_PLANE)\n\t\tcol += fre * fre_factor;\n\n\tcol += skybg * .4;\n\n\treturn clamp(col, 0., 1.);\n}\n\nvec3 camera(vec3 ro, vec2 uv, vec3 ta) {\n\tvec3 fwd = normalize(ta - ro);\n\tvec3 left = normalize(cross(vec3(0, 1, 0), fwd));\n\tvec3 up = normalize(cross(fwd, left));\n\treturn normalize(fwd + uv.x*left + up * uv.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\tfloat time = 4. + sin(iTime) * .1;//iTime;\n\n\tvec3 ray_ori;\n\tif (iMouse.z > 0.) {\n\t\tfloat xm = (-iMouse.x*10. / iResolution.x);\n\t\tfloat ym = (-iMouse.y*10. / iResolution.x);\n\t\tray_ori = vec3(dist_to * cos(xm), cos(ym) * 5., dist_to * sin(xm));\n\t}\n\telse {\n\t\tray_ori = vec3(dist_to * cos(time * .5), 0., dist_to * sin(time * .5));\n\t}\n\n\tvec3 tcol = vec3(0);\n\tvec3 target = vec3(0);\n\n#if ANTIALIAS > 1\n\tfor (int j = 0; j < ANTIALIAS; j++) {\n\t\tfor (int i = 0; i < ANTIALIAS; i++) {\n\t\t\tvec2 off = vec2(float(i), float(j)) / float(ANTIALIAS);\n\n\t\t\tvec2 uv = (fragCoord.xy + off) / iResolution.xy - .5;\n#else\n\tvec2 uv = fragCoord.xy / iResolution.xy - .5;\n#endif\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tvec3 ray_dir = camera(ray_ori, uv, target);\n\tvec3 pos;\n\n\tfloat tdist = 0.; // total distance from the ray origin to the point\n\tfloat tmax = 60.; // max distance\n\t\t\t\t\t  // Sphere-tracing\n\tfor (float i = 0.; i < 1.; i += .01) {// 100 iterations\n\t\tpos = ray_ori + ray_dir * tdist;\n\t\tfloat dist = de(pos); // signed distance field\n\t\tif (dist < .001 || tdist > tmax)\n\t\t\tbreak;\n\t\ttdist += dist;\n\t}\n\n\tvec3 col = vec3(0);\n\tvec3 background = sky(ray_dir);\n\tif (tdist <= tmax) {\n\t\tvec3 nor = normal(pos);\n\t\tcol = shading(pos, ray_dir, nor);\n\t}\n\telse {\n\t\tcol = background;\n\t}\n\n\t// fog\n\tcol = mix(col, background, 1. - exp(-.001*tdist*tdist));\n\n\ttcol += col;\n#if ANTIALIAS > 1\n\t\t}\n\t} // antialias\n\ttcol /= float(ANTIALIAS * ANTIALIAS);\n#endif\n\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\t// sandstorm - multiple layers of screenspace noise\n\ttcol -= texture(iChannel2, (q - vec2(iTime, .1*cos(iTime*2.)))*.1).rgb * .03;\n\ttcol -= texture(iChannel2, (q - vec2(.5, .2) + vec2(iTime*.5, .1*cos(iTime*1.)))*.1).rgb * .02;\n\ttcol -= texture(iChannel2, (q - vec2(.9, .1) - vec2(iTime*2., .1*cos(iTime*1.5)).xx)*.1).rgb * .02;\n\n\t// gamma\n\ttcol = pow(tcol, vec3(1. / gamma));\n\n\t// vignetting (from iq)\n\ttcol *= .5 + 0.5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .25);\n\n\tfragColor = vec4(tcol, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}