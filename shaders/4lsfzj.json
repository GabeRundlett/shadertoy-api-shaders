{
    "Shader": {
        "info": {
            "date": "1512512915",
            "description": "The cubic surface of Alfred Clebsch, with its 27 lines.\n\nMouse changes R3 orientation.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "4lsfzj",
            "likes": 10,
            "name": "Clebsch Cubic",
            "published": 3,
            "tags": [
                "raytrace",
                "algebraic",
                "clebsch"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 787
        },
        "renderpass": [
            {
                "code": "const float PI =  3.141592654;\nconst float TWOPI = 2.0 * PI;\nconst float PHI = 1.618033989;\nconst vec4 I = vec4(1,1,1,1);\nconst vec3 AXIS = vec3(1,1,1); // axis for rotation\nconst int NLINES = 27;\nvec4 lines[NLINES*2];\nint colors[NLINES];\n\n// Lighting params\nvec3 light;\nfloat ambient;\nfloat diffuse;\n\n// Quaternion multiplication as a matrix.\n// w coordinate is real element of quaternion\n// This gives a Clifford translation in R4\nmat4 qmat(vec4 q) {\n  float x = q.x, y = q.y, z = q.z, t = q.w;\n  return mat4( t,-z, y, x, \n               z, t,-x, y,\n              -y, x, t, z,\n              -x,-y,-z, t );\n}\n\nint quadratic(float A, float B, float C, out vec3 x) {\n   float D = B*B - 4.0*A*C;\n   if (D < 0.0) return 0;\n   D = sqrt(D);\n   if (B < 0.0) D = -D;\n   x[0] = (-B-D)/(2.0*A);\n   x[1] = C/(A*x[0]);\n   return 2;\n}\n\n// Numerical Recipes algorithm for solving cubic equation\nint cubic0(float a, float b, float c, float d, out vec3 x) {\n  if (a == 0.0) return quadratic(b,c,d,x);\n  //if (d == 0.0) return quadratic(a,b,c,x); // Need 0 too.\n  float tmp = a; a = b/tmp; b = c/tmp; c = d/tmp;\n  // solve x^3 + ax^2 + bx + c = 0\n  float Q = (a*a-3.0*b)/9.0;\n  float R = (2.0*a*a*a - 9.0*a*b + 27.0*c)/54.0;\n  float R2 = R*R, Q3 = Q*Q*Q;\n  if (R2 < Q3) {\n    float X = clamp(R/sqrt(Q3),-1.0,1.0);\n    float theta = acos(X);\n    float S = sqrt(Q); // Q must be positive since 0 <= R2 < Q3\n    x[0] = -2.0*S*cos(theta/3.0) - a/3.0;\n    x[1] = -2.0*S*cos((theta+2.0*PI)/3.0) - a/3.0;\n    x[2] = -2.0*S*cos((theta+4.0*PI)/3.0) - a/3.0;\n    return 3;\n  } else {\n    float A = -sign(R)*pow(abs(R)+sqrt(R2-Q3),0.3333);\n    float B = A == 0.0 ? 0.0 : Q/A;\n    x[0] = (A+B) - a/3.0;\n    return 1;\n  }\n}\n\nint cubic(float A, float B, float C, float D, out vec3 x) {\n  int nroots;\n  // Some ill-conditioned coeffs can cause problems\n  // The worst is fixed by solving for reciprocal\n  if (abs(A) > abs(D)) {\n    nroots = cubic0(A,B,C,D,x);\n  } else {\n    nroots = cubic0(D,C,B,A,x);\n    for (int i = 0; i < 3; i++) {\n      x[i] = 1.0/x[i];\n    }\n  }\n  return nroots;\n}\n\n// Initialize array of lines & colors\n// I could probably do this procedurally or just use\n// a static array for GLSL 3.0\nvoid initlines() {\n  lines[0] =  vec4(1,-1,0,0); lines[1] =  vec4(0,0,1,0);\n  lines[2] =  vec4(1,-1,0,0); lines[3] =  vec4(0,0,0,1);\n  lines[4] =  vec4(1,0,-1,0); lines[5] =  vec4(0,1,0,0);\n  lines[6] =  vec4(1,0,-1,0); lines[7] =  vec4(0,0,0,1);\n  lines[8] =  vec4(1,0,0,-1); lines[9] =  vec4(0,1,0,0);\n  lines[10] = vec4(1,0,0,-1); lines[11] = vec4(0,0,1,0);\n\n  lines[12] = vec4(0,1,-1,0); lines[13] = vec4(1,0,0,0);\n  lines[14] = vec4(0,1,-1,0); lines[15] = vec4(0,0,0,1);\n  lines[16] = vec4(0,1,0,-1); lines[17] = vec4(1,0,0,0);\n  lines[18] = vec4(0,1,0,-1); lines[19] = vec4(0,0,1,0);\n  lines[20] = vec4(0,0,1,-1); lines[21] = vec4(1,0,0,0);\n  lines[22] = vec4(0,0,1,-1); lines[23] = vec4(0,1,0,0);\n\n  lines[24] = vec4(1,-1,0,0); lines[25] = vec4(0,0,1,-1);\n  lines[26] = vec4(1,0,-1,0); lines[27] = vec4(0,1,0,-1);\n  lines[28] = vec4(1,0,0,-1); lines[29] = vec4(0,1,-1,0);\n\n  lines[30] = vec4(1,PHI,-1,0); lines[31] = vec4(PHI,1,0,-1);\n  lines[32] = vec4(1,PHI,0,-1); lines[33] = vec4(PHI,1,-1,0);\n  lines[34] = vec4(1,0,PHI,-1); lines[35] = vec4(PHI,-1,1,0);\n  lines[36] = vec4(1,-1,PHI,0); lines[37] = vec4(PHI,0,1,-1);\n  lines[38] = vec4(1,-1,0,PHI); lines[39] = vec4(PHI,0,-1,1);\n  lines[40] = vec4(1,0,-1,PHI); lines[41] = vec4(PHI,-1,0,1);\n\n  lines[42] = vec4(-1,1,PHI,0); lines[43] = vec4(0,PHI,1,-1);\n  lines[44] = vec4(0,1,PHI,-1); lines[45] = vec4(-1,PHI,1,0);\n  lines[48] = vec4(-1,1,0,PHI); lines[49] = vec4(0,PHI,-1,1);\n  lines[46] = vec4(0,1,-1,PHI); lines[47] = vec4(-1,PHI,0,1);\n  lines[50] = vec4(-1,0,1,PHI); lines[51] = vec4(0,-1,PHI,1);\n  lines[52] = vec4(0,-1,1,PHI); lines[53] = vec4(-1,0,PHI,1);\n\n  colors[0] = colors[5] = colors[9] = 5;\n  colors[1] = colors[3] = colors[7] = 2;\n  colors[2] = colors[4] = colors[11] = 7;\n  colors[6] = colors[8] = colors[10] = 4;\n  colors[12] = colors[13] = colors[14] = 6;\n  // This colouring shows a \"double six\" for 12 lines.\n  colors[15] = colors[17] = colors[19] = colors[21] = colors[23] = colors[25] = 1;\n  colors[16] = colors[18] = colors[20] = colors[22] = colors[24] = colors[26] = 3;\n}\n\nvec4 getColor(int i) {\n  if (i == 0) return vec4(0.5,0.5,1,1);\n  if (i == 1) return vec4(1,0,0,1);\n  if (i == 2) return vec4(1,1,0,1);\n  if (i == 3) return vec4(0,0,1,1);\n  if (i == 4) return vec4(0,1,0,1);\n  if (i == 5) return vec4(0,1,1,1);\n  if (i == 6) return vec4(1,0,1,1);\n  if (i == 7) return vec4(0.5,0.5,0.1,1);\n  return vec4(0,0,0,1);\n}\n\n// p is in world coordinates\nfloat eval(vec4 p,mat4 m) {\n  p = m*p;\n  float pI = dot(p,I);\n  return dot(p*p,p) - pI*pI*pI;\n}\n\n// Equation is: pp.p - (p.I)^3 = 0\n// A = rr.r - (r.I)^3\n// B = 3(rr.p -(p.I)(r.I)^2)\n// C = 3(pp.r -(p.I)^2(r.I))\n// D = pp.p - (p.I)^3\nfloat surface(vec4 p0, vec4 r0) {\n  vec4 p = p0;\n  vec4 r = r0;\n  float pI = dot(p,I);\n  float rI = dot(r,I);\n\n  // Possibly this is a better way.\n  float A = dot(r*r - rI*rI*I, r);\n  float B = 3.0*dot(r*r - rI*rI*I, p);\n  float C = 3.0*dot(p*p - pI*pI*I, r);\n  float D = dot(p*p - pI*pI*I, p);\n\n  vec3 x;\n  int nroots = cubic(A,B,C,D,x);\n  float t0 = 1e8;\n  for (int i = 0; i < 3; i++) {\n    if (i == nroots) break;\n    if (0.0 < x[i] && x[i] < t0) {\n      t0 = x[i];\n    }\n  }\n  return t0;\n}\n    \n// Find the (squared) distance to the line in R3 but\n// using homogeneous coordinates.\nfloat tryline(vec4 q, vec4 p, vec4 r) {\n  // |r.w| < |p.w| and if both are small we have a\n  // line at infinity so we can ignore it\n  if (abs(p.w) < 1e-2) return 1e8;\n   r = p.w*r - r.w*p; // r.w = 0\n   q = p.w*q-p;\n   float qr = dot(q,r);\n   float d2 = (dot(q,q) - (qr*qr/dot(r,r)))/(p.w*p.w);\n   return d2;\n}\n\nvec4 solve(vec4 p, vec4 r) {\n  vec3 normal = vec3(1,0,0);\n  float theta = iTime*0.1;\n  // M rotates surface in R4\n  vec3 a = normalize(AXIS);\n  mat4 M = qmat(vec4(sin(theta)*a,cos(theta)));\n  mat4 Minv = qmat(vec4(-sin(theta)*a,cos(theta)));\n  initlines();\n\n  const float u = 0.025;\n  const float u2 = u*u;\n  int colorindex = -1; // Selected color\n  float t = surface(M*p,M*r);\n  if (t < 1e8) {\n    // Compute normal by finding gradient\n    vec4 q = p+t*r;\n    float x0 = eval(q,M);\n    vec2 eps = vec2(1e-2,0);\n    normal = vec3 (eval(q+eps.xyyy,M)-x0,\n                   eval(q+eps.yxyy,M)-x0,\n                   eval(q+eps.yyxy,M)-x0);\n    normal = normalize(normal);\n    colorindex = 0;\n\n    // Now find the nearest line\n    float d = u2;\n    for (int i = 0; i < NLINES; i++) {\n      vec4 p4 = Minv*lines[2*i];\n      vec4 r4 = Minv*lines[2*i+1];\n      if (abs(p4.w) < abs(r4.w)) {\n        vec4 t = p4; p4 = r4; r4 = t;\n      }\n      float d0 = tryline(q,p4,r4);\n      if (d0 < d){\n        d = d0;\n        colorindex = colors[i];\n      }\n    }\n  }\n  if (colorindex == -1) return vec4(0,0,0,1);\n  if (dot(r.xyz,normal) > 0.0) {\n    normal = -normal; // Face forwards\n  }\n  vec4 baseColor = getColor(colorindex);\n  vec3 color;\n  color = baseColor.xyz*(ambient+(1.0-ambient)*dot(light,normal));\n  float specular = pow(max(0.0,dot(reflect(light,normal),r.xyz)),4.0);\n  color += 0.7*specular*vec3(1.0,1.0,1.0);\n  return vec4(sqrt(color),1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  light = normalize(vec3(0.0,1.0,-1.0));\n  ambient = 0.6;\n  diffuse = 1.0-ambient;\n\n  vec2 uv = 2.0*fragCoord.xy/iResolution.xy - 1.0;\n  vec3 p = vec3(0.0, 0.0, 6.0);\n  vec3 r = normalize(vec3(iResolution.x/iResolution.y * uv.x, uv.y, -3.0));\n  // Rotate camera according to mouse position\n  float xrot = 0.0; // About x-axis\n  float yrot = 0.0; // About y-axis\n  if (iMouse.x > 0.0) {\n    yrot = TWOPI*(iMouse.x-0.5*iResolution.x)/iResolution.x;\n    xrot = TWOPI*(iMouse.y-0.5*iResolution.y)/iResolution.y;\n  }\n  mat3 mx = mat3(1,0,0,\n                 0,cos(xrot),-sin(xrot),\n                 0,sin(xrot),cos(xrot));\n  mat3 my = mat3(cos(yrot),0,-sin(yrot),\n                 0,1,0,\n                 sin(yrot),0,cos(yrot));\n  mat3 m = mx*my;\n  light *= m;\n  p *= m;\n  r *= m;\n  fragColor = solve(vec4(p,1),vec4(r,0));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}