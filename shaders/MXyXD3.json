{
    "Shader": {
        "info": {
            "date": "1720591648",
            "description": "Population simulation",
            "flags": 48,
            "hasliked": 0,
            "id": "MXyXD3",
            "likes": 7,
            "name": "Boids_withUI",
            "published": 3,
            "tags": [
                "animalbehavior"
            ],
            "usePreview": 0,
            "username": "kosalos",
            "viewed": 104
        },
        "renderpass": [
            {
                "code": "/* =================================================\n   Use mouse to move three yellow obstacles.\n   \n   <E>,<R>  set Target Speed\n   <Q>,<W>  set Target Weight \n   <A>,<S>  set Boid Weight \n   <Z>,<X>  set Obstacle Weight \n   ================================================= */\n\nvec4 bluesky(vec2 uv) {\n    float factor = 0.0001;\n    float tt = iTime * 0.005;\n    vec2 p1;\n    vec4 d,c = vec4(0.,0.,0.,1.); \n\n    for(int i=0;i<2;++i) {\n        p1 = uv * factor;\n        p1.x += tt;\n\n        factor += 0.0001;\n        tt += .1;\n\n        d = texture(iChannel1, p1); \n        c.xyz += (vec3(0.5) + (d.xyz - vec3(0.5)) * 2.) * 0.7;\n   }\n   \n   c.xyz = vec3(1.) - c.xyz;\n   return c;\n}\n\nfloat ptLineDistance(vec2 pt,vec2 lineP1,vec2 lineP2) {\n    vec2 ab = lineP2-lineP1;\n    vec2 be = pt-lineP2;     \n    if(dot(ab,be) > 0.) return length(be);\n\n    vec2 ae = pt-lineP1;\n    if(dot(ab,ae) < 0.) return length(ae); \n    return abs(ab.x * ae.y - ab.y * ae.x) / length(ab);\n}\n\nvoid drawLine(vec2 p1,vec2 p2, float width, vec3 color,inout vec4 fragColor,vec2 fragCoord) {\n       \n    float d = ptLineDistance(fragCoord,p1,p2);\n    \n    if(d < 160.) fragColor.xyz += 1./(d * 0.3); // glow\n\n    if(d < width) {\n        float d2 = ptLineDistance(fragCoord - vec2(-width * 0.5,width * 0.5),p1,p2);\n        fragColor.xyz = color - vec3(d2 / (width * 2.5));\n    }\n //   if(abs(d - width)< 1.) fragColor.xyz = vec3(0.);\n}\n\n// ---------------------------------------------------\n\nvoid mainImage(out vec4 color, in vec2 coord) {\n    vec4 background = bluesky(coord);\n    color = background;\n    getSettings(iChannel0);\n\n    // obstacles ----------------\n    vec2 ob[3];\n    ob[0] = obstacle1;\n    ob[1] = obstacle2;\n    ob[2] = obstacle3;\n    for(int i=0;i<3;++i) {\n        float dist = length(coord - ob[i]);\n        if(dist < obstacleStayAwayDistance) color += background * 2.;\n        if(dist < OBSTACLE_SIZE) color = vec4(1.,1.,0.,1.);\n        if(abs(dist - OBSTACLE_SIZE) < 2.) color = vec4(0.);\n    }\n\n    // boids ----------------\n    for (int i = 0; i < NUM_BOIDS; ++i) {\n        vec2 p1 = data[BOIDBASE + i].xy;\n        float dist = length(coord - p1);\n        \n        if(dist < BOID_SIZE) {  \n            vec2 vel = data[BOIDBASE + i].zw;\n            float angle = atan(vel.y,vel.x);\n            float len = pow(length(vel),4.);\n            \n            vec2 p2 = p1 + vec2(cos(angle) * len,sin(angle) * len);\n            drawLine(p2,p1,6.,vec3(0.,1.,0.),color,coord);\n        }\n    }\n\n    // target ------------------\n    float dist = length(coord - target);\n    if(dist < TARGET_SIZE) color = vec4(1.,0.,0.,1.);\n    if(abs(dist-TARGET_SIZE) < 2.) color = vec4(0.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 48,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void initializeSettings(inout vec4 fragColor,vec2 fragCoord) {\n    targetAngle = 0.;\n    targetSpeed = 0.01;\n    targetWeight = 10.;\n    neighborWeight = 20.;\n    obstacleWeight = 100.;\n    obstacle1 = vec2(iResolution.x * 0.5,iResolution.y * 0.75);\n    obstacle2 = vec2(iResolution.x * 0.25,iResolution.y * 0.25);\n    obstacle3 = vec2(iResolution.x * 0.75,iResolution.y * 0.25);\n    \n    for(int i=0;i<NUM_BOIDS;++i) {\n        data[BOIDBASE + i].xy = iResolution.xy * vec2(0.3,0.5) + vec2(20. * float(i),0.); // position\n        data[BOIDBASE + i].zw = vec2(0.);  // velocity\n    }\n    \n    saveSettings(fragColor,fragCoord);\n}\n\n// ----------------------------------------------------------\n\nvec2 vectorAngleWeight(vec2 v1,vec2 v2,float weight) {\n    float angle = atan(v2.y - v1.y, v2.x - v1.x);\n    return vec2(cos(angle) * weight, sin(angle) * weight);\n}\n\nvoid updateBoid(int index) {\n    vec2 pos = data[BOIDBASE + index].xy;   // current position, velocity\n    vec2 vel = data[BOIDBASE + index].zw; \n\n    // move toward target\n    vec2 newPos = pos + vectorAngleWeight(pos,target,targetWeight);\n\n    // move away from obstacles\n    vec2 ob[3];\n    ob[0] = obstacle1;\n    ob[1] = obstacle2;\n    ob[2] = obstacle3;\n    \n    for(int i=0;i<3;++i) {\n        float dist = length(ob[i] - pos);\n        \n        if (dist < obstacleStayAwayDistance) {\n            float ratio = max(log(dist * 5.),1.);\n            newPos += vectorAngleWeight(pos, ob[i], -obstacleWeight / ratio);\n        }\n    }\n\n    // move away from other boids\n    for (int i = 0; i < NUM_BOIDS; ++i) {\n        if (i == index) continue;\n        float dist = length(pos - data[BOIDBASE + i].xy);\n        \n        if (dist < boidStayAwayDistance) {\n            float ratio = max(log(dist * 5.),1.);\n            newPos += vectorAngleWeight(pos, data[BOIDBASE + i].xy, -neighborWeight / ratio);\n        }\n    }\n\n    // newVel = new dx,dy\n    vec2 newVel = newPos - pos;\n\n    // smooth dx,dy changes\n    newVel.x = (vel.x * 25. + newVel.x) / 26.0;\n    newVel.y = (vel.y * 25. + newVel.y) / 26.0;\n\n    // save updated values\n    data[BOIDBASE + index].xy = pos + newVel;\n    data[BOIDBASE + index].zw = newVel;\n}\n\n// ----------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if(iFrame < 2) {\n        initializeSettings(fragColor, fragCoord);\n        return;\n    }\n    \n    if(fragCoord.y > 1.0) return;  // no data here\n\n    getSettings(iChannel0);\n    userInterface(iChannel3);\n    \n    // -----------------------------------\n    targetAngle -= targetSpeed;\n    if(targetAngle < 0.) targetAngle += PI2;\n    target = iResolution.xy * 0.5 + \n        vec2(cos(targetAngle) * iResolution.x * 0.3,sin(targetAngle) * iResolution.y * 0.3);\n    // -----------------------------------\n    if(iMouse.z > 0.) { // dragging\n        float d1 = length(obstacle1 - iMouse.xy);\n        float d2 = length(obstacle2 - iMouse.xy);\n        float d3 = length(obstacle3 - iMouse.xy);\n        if(d1 < 60. && d1 < d2 && d1 < d3) obstacle1 = iMouse.xy; else\n        if(d2 < 60. && d2 < d1 && d2 < d3) obstacle2 = iMouse.xy; else\n        if(d3 < 60. && d3 < d1 && d3 < d2) obstacle3 = iMouse.xy;\n    }\n    // -----------------------------------\n    for (int i = 0; i < NUM_BOIDS; ++i) \n        updateBoid(i);\n\n    saveSettings(fragColor,fragCoord); \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const int NUM_BOIDS = 50;\nconst int NUM_OBSTACLES = 3;\nconst float PI2 = (3.141592654 * 2.0);\n\nconst float BOID_SIZE = 20.;\nconst float TARGET_SIZE = 12.;\nconst float OBSTACLE_SIZE = 16.;\nconst float minTargetSpeed = 0.001;\nconst float maxTargetSpeed = 0.02;\nconst float minTargetWeight = 1.;\nconst float maxTargetWeight = 200.;\nconst float minNeighborWeight = 1.;\nconst float maxNeighborWeight = 500.;\nconst float minObstacleWeight = 10.;\nconst float maxObstacleWeight = 2500.;\nconst float boidStayAwayDistance = 50.;\nconst float obstacleStayAwayDistance = 200.;\n\n#define target           data[0].xy   // position\n#define targetAngle      data[0].z\n#define targetSpeed      data[0].w\n#define targetWeight     data[1].x\n#define neighborWeight   data[1].y\n#define obstacleWeight   data[1].z\n#define obstacle1        data[2].xy   // position\n#define obstacle2        data[2].zw\n#define obstacle3        data[3].xy\n#define BOIDBASE 4       // each boid 1 pixel: xy position, zw velocity\n\nconst int ADDR_COUNT = 4 + NUM_BOIDS;\nvec4[ADDR_COUNT] data;\n\n// ------------------------------------------------\n\nvoid getSettings(sampler2D channel) { \n    for(int i=0;i<ADDR_COUNT;++i) \n        data[i] = texelFetch(channel, ivec2(i,0),0);\n}\n\nvoid saveSettings(inout vec4 fragColor,vec2 fragCoord) { \n    if(fragCoord.y < 1.) {\n        int x = int(fragCoord.x);\n        if(x < ADDR_COUNT)\n            fragColor = data[x];\n    }\n}\n// ----------------------------------------------------------\n\nbool keyClick(int ascii,sampler2D channel) {\n\treturn (texture(channel,vec2((.5+float(ascii))/256.,0.25)).x > 0.);\n}\n\nbool getKeyState(int keyCode,sampler2D channel) {\n    return bool(texelFetch(channel, ivec2(keyCode,0), 0).x != 0.);\n}\n\nbool getKeyClick(int keyCode,sampler2D channel) {\n    return bool(texelFetch(channel, ivec2(keyCode,1), 0).x != 0.);\n}\n\nvoid userInterface(sampler2D channel) {    \n    if(getKeyState(81,channel)) targetWeight = clamp(targetWeight - 0.2,minTargetWeight,maxTargetWeight); // Q\n    if(getKeyState(87,channel)) targetWeight = clamp(targetWeight + 0.2,minTargetWeight,maxTargetWeight); // W\n    if(getKeyState(69,channel)) targetSpeed = clamp(targetSpeed - 0.001,minTargetSpeed,maxTargetSpeed); // E\n    if(getKeyState(82,channel)) targetSpeed = clamp(targetSpeed + 0.001,minTargetSpeed,maxTargetSpeed); // R\n    if(getKeyState(65,channel)) neighborWeight = clamp(neighborWeight - 5.,minNeighborWeight,maxNeighborWeight); // A\n    if(getKeyState(83,channel)) neighborWeight = clamp(neighborWeight + 5.,minNeighborWeight,maxNeighborWeight); // S\n    if(getKeyState(90,channel)) obstacleWeight = clamp(obstacleWeight - 1.,minObstacleWeight,maxObstacleWeight); // Z\n    if(getKeyState(88,channel)) obstacleWeight = clamp(obstacleWeight + 1.,minObstacleWeight,maxObstacleWeight); // X\n}\n\n// ========================================================================\n// https://www.shadertoy.com/view/MtfGWM\n\nfloat previousRnd = 0.;\n\nfloat rnd(vec2 c) { return fract(sin(dot(vec2(1.317,19.753),c))*413.7972); } // 0...1\n\nfloat rndStart(vec2 coord, float t) {  // 0...1\n\tpreviousRnd += rnd(coord.xy + vec2(t * 217.0));\n    return previousRnd;\n}\n\nfloat random(float vmin, float vmax, vec2 coord, float t) {\n    return vmin + (vmax-vmin) * rndStart(coord,t) / 1.;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}