{
    "Shader": {
        "info": {
            "date": "1596572278",
            "description": "raymarching1",
            "flags": 0,
            "hasliked": 0,
            "id": "ttXfWH",
            "likes": 3,
            "name": "raymarching1_",
            "published": 3,
            "tags": [
                "raymarching1"
            ],
            "usePreview": 0,
            "username": "pohy",
            "viewed": 216
        },
        "renderpass": [
            {
                "code": "/*\n * Progressing with learning ray marching techniques.\n * I recommend to listen to Confidence of Equals by Isaac Chambers\n * https://jumpsuitrecords.bandcamp.com/track/confidence-of-equals\n * Some pretty smooth jams in that EP\n */\n\n#define MAX_ITER 100\n#define MAX_DIST 20.\n#define EPSILON 0.001\n\n#define PI 3.14159\n\nfloat posSin(float x) {\n    return sin(x) * .5 + .5;\n}\nfloat posCos(float x) {\n    return cos(x) * .5 + .5;\n}\n\nfloat sMin(float d1, float d2, float k) {\n    float h = clamp(.5 + .5 * (d2 -d1) / k, 0., 1.);\n    return mix(d2, d1, h) - k * h * (1. - h);\n}\n\nfloat sdPlane(vec3 p, vec3 n, float h) {\n    return dot(p, n) + h;\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nvec2 mapMat(vec3 p) {\n    float t = PI * 3. + iTime * .1;\n    // Plane\n    float d = p.y - (-.25) * sin(p.x - p.z * p.y) * .3;\n    \n    float mat = -1.;\n    \n    // Spheres\n    for (float i = 0.; i < 40.; i++) {\n        float a = i + t;\n        a += 1. + i + t * .2 * i;\n        float r = .25 + i * posSin(i + t * 8.) * .005;\n        float h = 1. + i * .1;\n        float off = .3 + posSin(t * 4.);\n        vec3 c = vec3(cos(a) * off, h, sin(a) * off);\n        float d1 = sdSphere(p - c, r);//length(p - c) - .25;\n        if (d1 < d) {\n            mat = mod(i, 2.);\n        }\n        d = sMin(d1, d, .2 * posSin(t));\n    }\n    \n    return vec2(d, mat);\n}\n\nfloat map(vec3 p) {\n    return mapMat(p).x;\n}\n\nvec3 normal(vec3 pos) {\n    vec2 eps = vec2(0., EPSILON);\n    vec3 normal = normalize(vec3(\n        map(pos + eps.yxx) - map(pos - eps.yxx),\n        map(pos + eps.xyx) - map(pos - eps.xyx),\n        map(pos + eps.xxy) - map(pos - eps.xxy)\n    ));\n    return normal;\n}\n\nvec2 castRayMat(vec3 ro, vec3 rd) {\n    float td = 0.;\n    float mat;\n    for (int i = 0; i < MAX_ITER; i++) {\n        vec3 pos = ro + td * rd;\n        vec2 h = mapMat(pos);\n        mat = h.y;\n        if (h.x < EPSILON) break;\n        td += h.x;\n        if (td > MAX_DIST) break;\n    }\n    if (td > MAX_DIST ) td = -1.;\n    return vec2(td, mat);\n}\n\nfloat castRay(vec3 ro, vec3 rd) {\n    return castRayMat(ro, rd).x;\n}\n\nvec3 scenePixelColor(vec3 ro, vec3 rd) {\n    vec3 col = vec3(.3, .75, 1.) - .7 * rd.y;\n    col = mix(col, vec3(.7, .75, .8), exp(-10. * rd.y));\n    \n    vec2 ray = castRayMat(ro, rd);\n    float td = ray.x;\n    \n    float t = PI + iTime * .1;\n    \n    if (td > EPSILON) {\n\t\tvec3 pos = ro + td * rd;\n        vec3 n = normal(pos);\n        \n        vec3 mate;\n        if (ray.y < -.5) {\n            mate = vec3(.2);\n        } else if (ray.y < .5) {\n            mate = vec3(.1, .3, .9);\n        \t//mate = vec3(.4, .1, mod(ray.y, 4.));\n        } else if (ray.y < 1.5) {\n        \tmate = vec3(.9, .3, .1);\n        }\n        \n        vec3 sunPos = normalize(vec3(.8 * sin(t) * 2., .4 - posSin(t) * .25, .2 + cos(t)));\n        \n        float sunDiff = clamp(dot(n, sunPos), .0, 1.);\n        float sunSha = step(castRay(pos + n * EPSILON, sunPos), .0);\n        float skyDiff = clamp(.5 + .5 * dot(n, vec3(0, 1, 0)), 0., 1.);\n        float bouDiff = clamp(.5 + .5 * dot(n, vec3(0, -1, 0)), 0., 1.);\n        \n        col = mate * vec3(7, 4.5, 3) * sunDiff * sunSha;\n        col += mate * vec3(.5, .8, .9) * skyDiff;\n        col += mate * vec3(.7, .3, .2) * bouDiff;\n    }\n    \n    col = pow(col, vec3(0.4545));\n    //col += ray.y;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    float t = PI * 1.25 + iTime * .29;\n    //t = PI * .25;\n    \n    float a = t;//mouse.x * 10.;\n    float r = 8.;//4. + posSin(t) * 2.;//2. + mouse.y * 10.;\n    float h = 2.;//.5 + posSin(t) * 2.;\n    \n    vec3 ro0 = vec3(0., .1, .001);\n    //ro0 = vec3(r * sin(a), h, .001 + r * cos(a));\n    vec3 ro1 = vec3(0, 2.5, 10.);\n    vec3 ro = mix(ro0, ro1, posSin(t));\n    \n    // Camera\n    vec3 la0 = vec3(0., 8., 0.);\n    vec3 la1 = vec3(0, 2.25, 0);\n    vec3 la = mix(la0, la1, posSin(t));\n    vec3 cf = normalize(la - ro);\n    vec3 cr = normalize(cross(cf, vec3(0, 1, 0)));\n    vec3 cu = normalize(cross(cr, cf));\n    \n    vec3 rd = normalize(uv.x * cr + uv.y * cu + 1.5 * cf);\n\n    vec3 col = scenePixelColor(ro, rd);\n\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}