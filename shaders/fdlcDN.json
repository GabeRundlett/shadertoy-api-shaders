{
    "Shader": {
        "info": {
            "date": "1642108059",
            "description": "i wanted to try it out\nit was a pain but it works :D",
            "flags": 0,
            "hasliked": 0,
            "id": "fdlcDN",
            "likes": 2,
            "name": "three dimensions test",
            "published": 3,
            "tags": [
                "3d",
                "points"
            ],
            "usePreview": 0,
            "username": "tungster24",
            "viewed": 203
        },
        "renderpass": [
            {
                "code": "#define scale 1\n#define rad radians\n\nstruct point {\nfloat x;\nfloat y;\nfloat z;\n};\n\nstruct camera {\n//camera position\nfloat x;\nfloat y;\nfloat z;\n//camera angles\nfloat tx;\nfloat ty;\nfloat tz;\n//camera projection plane location\nfloat ex;\nfloat ey;\nfloat ez;\n};\n\n//projection function\nvec2 projection(in point p,in camera cam) {\n    float x = p.x-cam.x;\n    float y = p.y-cam.y;\n    float z = p.z-cam.z;\n    \n    float dx = cos(cam.ty)*(sin(cam.tz)*y+cos(cam.tz)*x)-sin(cam.ty)*z;\n    \n    float dy = sin(cam.tx)*( \n    cos(cam.ty)*z+\n    sin(cam.ty)*\n        (\n        sin(cam.tz)*y+cos(cam.tz)*x\n        )\n    \n    )+cos(cam.tx)* (cos(cam.tz)*y-sin(cam.tz)*x)\n    ;\n    float dz = cos(cam.tx)*( \n    cos(cam.ty)*z+\n    sin(cam.ty)*\n        (\n        sin(cam.tz)*y+cos(cam.tz)*x\n        )\n    )-sin(cam.tx)* (cos(cam.tz)*y-sin(cam.tz)*x)\n    ;\n    \n    return vec2(\n    (cam.ez/dz)*dx+cam.ex,\n    (cam.ez/dz)*dy+cam.ey\n    );\n}\n\n//distance between two points because it's useful\nfloat dist(in vec2 p,in vec2 d) {\n    float difx = p.x-d.x;\n    float dify = p.y-d.y;\n    if (sqrt(difx*difx+dify*dify) < 0.01)return 1.0;else return 0.0;\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 m = iMouse.xy/iResolution.xy+vec2(0.0,0.0);\n    if (length(iMouse.xy) < 50.0) m = vec2(0.5);\n    //define modified time\n    float t = cos(iTime)/5.0;\n    //define camera\n    camera cam;\n    cam.x = 0.5;cam.y=t;cam.z= -3.0;\n    cam.tx = rad(m.y-0.5)*120.0;cam.ty = rad(-m.x+0.5)*120.0; cam.tz = 0.0;\n    cam.ex = 0.0;cam.ey = 0.0;cam.ez = 1.0;\n    //define points\n    point a[8] = point[8](\n    point(0.0,0.0,0.0),\n    point(0.0,0.0,1.1),\n    point(0.0,1.1,0.0),\n    point(0.0,1.1,1.1),\n    point(1.1,0.0,0.0),\n    point(1.1,0.0,1.1),\n    point(1.1,1.1,0.0),\n    point(1.1,1.1,1.1)\n    );\n    //light constant for glow\n    float light = 0.0;\n    \n    //normalised screen coords\n    vec2 p = fragCoord.xy/iResolution.yy*float(scale)-float(scale)/2.0*iResolution.xy/iResolution.yy;\n    \n    for(int i = 0;i<8;i++) {\n    light += dist(p,projection(a[i],cam))*20.0;\n    }\n    fragColor = vec4(vec3(light),0.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}