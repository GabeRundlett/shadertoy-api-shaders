{
    "Shader": {
        "info": {
            "date": "1556829836",
            "description": "Cloud lit by both a directional light and a point light inside the cloud. Rendered using multiple importance sampling. Runs with interactive performance thanks to cosine noise. Read my paper here: https://bit.ly/2DJGBxX",
            "flags": 32,
            "hasliked": 0,
            "id": "tsSGzV",
            "likes": 49,
            "name": "MIS Cloud using Cosine Noise",
            "published": 3,
            "tags": [
                "volumetric",
                "transmittance",
                "rendering"
            ],
            "usePreview": 1,
            "username": "bmartin",
            "viewed": 2470
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoordv )\n{\n    \n    vec4 color = texture(iChannel0,fragCoordv/iResolution.xy);\n\n\n        // Exposure tone mapping\n    color = vec4(1.0) - exp(-color * 1.0);\n    // Gamma correction\n    color = pow(color, vec4(1.0 / 2.2));\n\n    fragColor = color;\n} \n \n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// CONSTANTS\n\n#define PI 3.1416\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n\n// CONFIG\n\n#define MEDIUM_QUALITY\n\n#ifdef LOW_QUALITY\n\t#define traceAcc 0.008\n\t#define iter 4\n\t#define octaves 6\n\t#define boundAcc 0.05\n#endif\n#ifdef MEDIUM_QUALITY\n\t#define traceAcc 0.005\n\t#define iter 6\n\t#define octaves 8\n\t#define boundAcc 0.02\n#endif\n#ifdef HIGH_QUALITY\n\t#define traceAcc 0.001\n\t#define iter 8\n\t#define octaves 10\n\t#define boundAcc 0.01\n#endif\n\n// VALUE NOISE\n\n//Hash functions by David Hoskins\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nvec3 randSeed = vec3(0.);\nfloat rand(){\n    randSeed.y+=1.4675;\n\treturn hash13(randSeed);\n}\n\n\n//Gradient noise by IQ\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash13(p+vec3(0,0,0)), \n                        hash13(p+vec3(1,0,0)),f.x),\n                   mix( hash13(p+vec3(0,1,0)), \n                        hash13(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash13(p+vec3(0,0,1)), \n                        hash13(p+vec3(1,0,1)),f.x),\n                   mix( hash13(p+vec3(0,1,1)), \n                        hash13(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat fbm(vec3 pos){\n    vec3 q = 8.0*pos;\n    float f;\n    f  = 0.5000*noise( q ); q = m*q*2.01;\n    f += 0.2500*noise( q ); q = m*q*2.02;\n    f += 0.1250*noise( q ); q = m*q*2.03;\n    f += 0.0625*noise( q ); q = m*q*2.01;\n    f += 0.0312*noise( q ); q = m*q*2.02;\n    f += 0.0156*noise( q ); q = m*q*2.03;\n   #ifdef HIGH_QUALITY\n    f += 0.0078*noise( q ); q = m*q*2.01;\n   #endif\n    return f;\n}\n\n// SIGNED DISTANCE FIELD\n\n//Ellipsoid sdf by IQ\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat map(vec3 p){\n    return sdEllipsoid(p,vec3(1.6,1,1.2)) + fbm(p*0.2) - 0.65;\n}\n\nfloat getIntersection(vec3 ro, vec3 rd, float t, float sig){\n\tfloat h;\n    for (int i=0; i<256; i++){\n    \th = map(ro+rd*t)*sig;\n        if (h<traceAcc || t>10.) break;\n        t += h/2.;\n    }\n    return t;\n}\n\n// COSINE NOISE\n\n#define offset 60.\n\nfloat octaveWeight[10] = float[](1., 2.0, 3.0, 2.6,2.3,1.2,0.9,0.7,0.5,0.4);\n\nmat3 transforms[9] = mat3[]( \ntranspose(mat3(-2.601,0.651,-6.378,\n-2.923,4.877,1.975,\n1.835,-3.061,-3.238)),\ntranspose(mat3(-3.182,-1.907,5.481,\n4.579,2.744,-0.931,\n3.048,2.762,4.895)),\ntranspose(mat3(-3.741,-3.391,-1.217,\n4.528,-4.996,1.858,\n-2.641,2.914,-4.255)),\ntranspose(mat3(-4.887,0.240,0.076,\n1.072,-0.053,-5.999,\n-0.231,-4.701,2.833)),\ntranspose(mat3(0.287,5.849,-3.242,\n2.221,4.697,2.205,\n-2.320,-4.905,-4.170)),\ntranspose(mat3(2.073,-0.981,4.492,\n-5.610,2.654,-0.683,\n-1.848,5.165,4.576)),\ntranspose(mat3(1.869,-5.222,-2.136,\n-6.100,-2.183,0.920,\n2.573,0.921,-4.592)),\ntranspose(mat3(3.790,0.949,4.227,\n-6.505,-1.630,-1.848,\n1.218,-4.862,1.208)),\ntranspose(mat3(-0.994,3.966,-4.867,\n-4.995,2.994,3.224,\n4.010,-2.403,-2.813)));\t\n\nmat3 rot = mat3( -0.5879431, -0.4649327,  0.6619370,\n  -0.3151081, -0.6220310, -0.7167875,\n   0.7450032, -0.6300120,  0.2192148 )*1.635;\n\n#define ZERO min(0,iFrame)\n\nfloat evalInt(vec3 ro, vec3 rd, float t){\n    vec3 p = ro+rd*t+vec3(100);\n    float c = 0.;\n\tfor (int i = ZERO; i<iter; i++){\n        vec3 transformedRd = transforms[i]*rd;\n        vec3 transformedP = transforms[i]*p;\n        for (int o = ZERO; o<octaves; o++){\n    \t\tc += dot(sin(transformedP)*clamp(1./transformedRd,-100.,100.),vec3(1))*octaveWeight[o];\n            transformedP *= rot;\n            transformedRd *= rot;\n        }\n    }\n    return (c + t*offset)/30.;\n}\n\nfloat getDensity(vec3 ro, vec3 rd, float t){\n    vec3 p = ro+rd*t+vec3(100);\n    float c = 0.;\n\tfor (int i = ZERO; i<iter; i++){\n        vec3 transformedP = transforms[i]*p;\n        for (int o = ZERO; o<octaves; o++){\n    \t\tc += dot(cos(transformedP),vec3(1))*octaveWeight[o];\n            transformedP *= rot;\n        }\n    }\n    return max((c + offset)/30.,0.);\n}\n\n// TRANSMITTANCE\n\nfloat transmittanceBetween(vec3 p1, vec3 p2){\n    vec3 rd = normalize(p2-p1);\n    float maxt = min(distance(p1,p2),9.);\n    \n    \n    vec2 bounds = vec2(getIntersection(p1,rd,boundAcc,-1.));\n    float densityIntegral = evalInt(p1,rd,min(bounds.x,maxt) )-evalInt(p1,rd,0.);\n    \n    while (bounds.y < maxt){\n    \tbounds.x = getIntersection(p1,rd,bounds.y+boundAcc,1.);\n        bounds.y = getIntersection(p1,rd,bounds.x+boundAcc,-1.);\n        \n        \n        densityIntegral += evalInt(p1,rd,min(bounds.y,maxt)) - evalInt(p1,rd,min(bounds.x,maxt));\n    }\n    \n    return max(0.,densityIntegral);\n}\n\nfloat transmittanceBetween(vec3 ro, vec3 rd, vec2 bounds){\n    return evalInt(ro,rd,bounds.y) - evalInt(ro,rd,bounds.x);\n}\n\n\n#define absorbtion vec3(1,1,1)*0.7\n#define scattering vec3(1.1,1,0.9)*2.\n#define schlickK 0.2\n\n// EQUI-ANGULAR SAMPLE\n\nfloat getEqaPdf(vec3 ro, vec3 rd, float t, float c){\n    vec3 lo = vec3(0);\n    float delta = dot(lo - ro, rd);\n    float D = length(ro + delta*rd - lo);\n    float thetaA = atan(0.0 - delta, D);\n    float thetaB = PI/2.;\n    t -= delta;\n    float pdf = D/((thetaB - thetaA)*(D*D + t*t))*c;\n    return pdf;\n}\n\n// DISTANCE SAMPLE\n\nfloat searchDistance(float targetDensityIntegral, vec2 distanceBound, vec3 ro, vec3 rd){\n    float distanceAverage;\n    for (int i=0; i<256; i++){\n    \tdistanceAverage = dot(distanceBound, vec2(0.5));\n        float integralAtAverage = evalInt(ro, rd, distanceAverage);\n        if (integralAtAverage > targetDensityIntegral)\n            distanceBound.y = distanceAverage; else distanceBound.x = distanceAverage;\n        if (abs(integralAtAverage-targetDensityIntegral)<traceAcc) break;\n    }\n    return distanceAverage;\n}\n\nfloat getDisPdf(float density, float densityIntegral, float disCoeff){\n    float c = 2.*dot(absorbtion+scattering,vec3(0.3333));\n    return exp(-1.* densityIntegral * c) * density * disCoeff;\n}\n\n// MAIN SAMPLING FUNCTION\n\nbool getSamples(vec3 ro, vec3 rd, out float ratio,\n        out float disDistance, out float disDensityIntegral, out float disCoeff,\n        out float eqaDistance, out float eqaDensityIntegral, out float eqaCoeff){\n   \n    float c = 2.*dot(absorbtion+scattering,vec3(0.3333));\n    \n    //equi-angular\n    vec3 lo = vec3(0);\n    float delta = dot(lo - ro, rd);\n    float D = length(ro + delta*rd - lo);\n    float thetaA = atan(0.0 - delta, D);\n    float thetaB = PI/2.;\n    \n    //find coefficients\n    vec2 bounds = vec2(0);\n    \n    float eqaCdfSum = 0.;\n    float densitySum = 0.;\n    \n    int steps = 0;\n    while (bounds.x < 10.){\n        steps++;\n        \n    \tbounds.x = getIntersection(ro,rd,bounds.y+boundAcc,1.);\n        bounds.y = getIntersection(ro,rd,bounds.x+boundAcc,-1.);\n        if (bounds.y-bounds.x < 2.*boundAcc) continue;\n        \n        //t = D*tan(mix(thetaA, thetaB, u))+delta;\n        //(1-u)A + uB = A - uA + uB = u(B-A) + A\n        //atan((t-delta)/D) = u(B-A) + A  \n        eqaCdfSum += \n            (atan((bounds.y-delta)/D) - thetaA)/(thetaB - thetaA) - \n            (atan((bounds.x-delta)/D) - thetaA)/(thetaB - thetaA);\n        densitySum += transmittanceBetween(ro, rd, bounds);\n    }\n    if (steps == 1) return false;\n    \n    eqaCoeff = 1./eqaCdfSum;\n    disCoeff = c/(1.-exp(-1.*densitySum*c));\n    ratio = 1.-exp(-1.*densitySum*c);\n    \n    // calculate sample targets\n    float u = rand();\n    disDensityIntegral = log(u/(disCoeff/-c)+1.)/-c;\n    \n    float targetEqaCdf = rand();\n    \n    // Find bounds to search between\n    bounds = vec2(0);\n    \n    densitySum = 0.;\n    float densitySumLast = 0.;\n    eqaCdfSum = 0.;\n    float eqaCdfSumLast = 0.;\n    float eqaTempSum, eqaTempBound;\n    vec2 disTempBounds;\n    float disTempTarget;\n    bool lookingDis = true;\n    bool lookingEqa = true;\n    \n    while (bounds.x < 10.){\n    \tbounds.x = getIntersection(ro,rd,bounds.y+boundAcc,1.);\n        bounds.y = getIntersection(ro,rd,bounds.x+boundAcc,-1.);\n        if (bounds.y-bounds.x < 2.*boundAcc) continue;\n        \n        //eqa\n        eqaCdfSumLast = eqaCdfSum;\n        float eqaLower = (atan((bounds.x-delta)/D) - thetaA)/(thetaB - thetaA)*eqaCoeff;\n        eqaCdfSum += \n            (atan((bounds.y-delta)/D) - thetaA)/(thetaB - thetaA)*eqaCoeff - \n            eqaLower;\n            \n        if (targetEqaCdf >= eqaCdfSumLast && targetEqaCdf < eqaCdfSum){\n            eqaDistance = D*tan(mix(thetaA, thetaB, (\n                (targetEqaCdf-eqaCdfSumLast)+eqaLower\n            )/eqaCoeff))+delta;\n            eqaTempBound = bounds.x;\n            eqaTempSum = densitySum;\n        }\n        \n        //dis\n        densitySumLast = densitySum;\n        float densityLower = evalInt(ro,rd,bounds.x);\n        densitySum += evalInt(ro,rd,bounds.y) - densityLower;\n        if (disDensityIntegral >= densitySumLast && disDensityIntegral < densitySum){\n            disTempBounds = bounds;\n            disTempTarget = (disDensityIntegral - densitySumLast)+densityLower;\n        }\n        \n    }\n    \n    eqaDensityIntegral = eqaTempSum+transmittanceBetween(ro, rd, vec2(eqaTempBound,eqaDistance));\n    disDistance = searchDistance(disTempTarget, disTempBounds, ro, rd);\n    return true;\n}\n\n// MULTIPLE IMPORTANCE SAMPLING\n\nvec3 getSample(vec3 ro, vec3 rd, float t, float densityIntegral, float density, bool type){\n    \n    vec3 p = ro+rd*t;\n    vec3 rdL, color;\n    vec3 light = vec3(0);\n    float maxLt, lightDensityIntegral;\n    if (type){\n        rdL = normalize(light-p);\n        maxLt = distance(light,p);\n        lightDensityIntegral = transmittanceBetween(p, light);\n        color = vec3(0,1,1)*10.;\n    }else{\n        rdL = normalize(vec3(-1));\n        maxLt = 1.;\n        lightDensityIntegral = 0.5+transmittanceBetween(p, p-rdL*10.);\n        color = vec3(1,1,1)*130.;\n    }\n    \n    //lightDensityIntegral = 1.;\n    \n    float schlickSquare = 1. - schlickK*dot(rd,rdL);\n\tfloat schlickMie = (1. - schlickK*schlickK)/(4.*PI*schlickSquare*schlickSquare);\n    \n    return schlickMie * scattering * density * exp(-1.* densityIntegral *(absorbtion+scattering))\n            *exp(-1.* lightDensityIntegral *(absorbtion+scattering))/maxLt/maxLt*color;\n}\n\nvec3 render(vec3 ro, vec3 rd){\n    float disDistance, disDensityIntegral, disDensity, disCoeff;\n    float eqaDistance, eqaDensityIntegral, eqaDensity, eqaCoeff;\n    float ratio;\n    bool hit = getSamples(\n        ro, rd, ratio,\n        disDistance, disDensityIntegral, disCoeff,\n        eqaDistance, eqaDensityIntegral, eqaCoeff);\n    if (!hit) return vec3(0);\n    disDensity = getDensity(ro, rd, disDistance);\n    eqaDensity = getDensity(ro, rd, disDistance);\n    \n    vec3 eqaSample = getSample(ro, rd, eqaDistance, eqaDensityIntegral, eqaDensity, true);\n    vec3 disSample = getSample(ro, rd, disDistance, disDensityIntegral, disDensity, false);\n    \n    //balance heuristic\n    vec3 MIS = eqaSample/(\n        getEqaPdf(ro, rd, eqaDistance, eqaCoeff)+\n        getDisPdf(eqaDensity, eqaDensityIntegral, disCoeff)\n    ) + disSample*ratio/(\n        getEqaPdf(ro, rd, disDistance, eqaCoeff)+\n        getDisPdf(disDensity, disDensityIntegral, disCoeff)\n    );\n    \n    return MIS;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoordv )\n{\n    vec2 fragCoord = fragCoordv+hash33(vec3(fragCoordv,iTime)).xy;\n    randSeed = vec3(iTime,fragCoordv);\n    // towards -Z\n    vec3 ro = vec3(0,0,1);\n    vec2 q = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    vec3 rd = normalize(vec3(q,0)-ro);\n    \n    vec2 m = iMouse.xy/iResolution.xy - .5;\n    float a = m.x*PI*2.;\n    float b = m.y*PI;\n    if (iMouse.xy==vec2(0)) {b = -0.2; a = 0.2;}\n    vec3 camera = vec3(cos(b)*sin(a),sin(b),cos(b)*cos(a));\n    //Z vector\n    vec3 up = normalize(cross(cross(camera,vec3(0,1,0)),camera));\n    //Y vector\n    vec3 x = normalize(cross(up,camera));\n    mat3 view = mat3(x,up,camera);\n    \n    ro = camera*4.;\n    \n    rd = view*rd;\n    \n    \n    \n    \n    vec4 new = vec4(render(ro,rd),1);\n    \n    if (iMouse.z > 0.) {\n    \tfragColor = new;\n        return;\n    }\n    \n    vec4 old = texture(iChannel0,fragCoordv/iResolution.xy);\n    old.rgb *= (old.a/(old.a+1.));\n    new.rgb /= old.a+1.;\n    fragColor = old+new;\n} \n \n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}