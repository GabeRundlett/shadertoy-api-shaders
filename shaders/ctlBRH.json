{
    "Shader": {
        "info": {
            "date": "1692611962",
            "description": "Aquatic version of \"Boidies 2\"",
            "flags": 32,
            "hasliked": 0,
            "id": "ctlBRH",
            "likes": 21,
            "name": "U-Boids",
            "published": 3,
            "tags": [
                "dynamics",
                "fish",
                "swarm",
                "boid",
                "collective"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 299
        },
        "renderpass": [
            {
                "code": "// \"U-Boids\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n  Pseudofish behaving like boids. The red uboid is the leader; those of the other\n  two colors try to follow the leader and also prefer to group with those of the\n  same color. The leader flies a fixed path which sometimes takes it through the\n  square hoop. Uboids are confined to a cubic box.\n\n  The two sliders control zoom and the various interaction parameters (all lumped\n  together for simplicity, red is strongest, and parameter change is initially\n  automatic). Click on the left ring to select the view (tracking, fixed, or attached -\n  behind / ahead of / looking back on - the red leader); the right ring selects\n  number of uboids; mouseable.\n\n  Explore...\n*/\n\n#define VAR_ZERO min (nFrame, 0)\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nmat3 QtToRMat (vec4 q);\nvec4 Loadv4 (int idVar);\n\nvec3 qHit, qnHit, ltDir;\nfloat dstFar, tCur, regSz, bdRad, bdLen, wnRad, wnThk, hoopSz, hoopThk, hoopHt, vuMode;\nint nFrame, idObj, nBoid, idBoid;\nconst float pi = 3.1415927;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nvec4 VCylHit (vec3 ro, vec3 rd, float rad, float len)\n{\n  vec3 s;\n  float dMin, d, a, b, w, srdx;\n  dMin = dstFar;\n  a = dot (rd.yz, rd.yz);\n  b = dot (rd.yz, ro.yz);\n  w = b * b - a * (dot (ro.yz, ro.yz) - rad * rad);\n  if (w > 0.) {\n    srdx = sign (rd.x);\n    s.x = len;\n    if (a > 0.) {\n      d = - b - sqrt (w);\n      if (d > 0.) {\n        d /= a;\n        s = ro + d * rd;\n      }\n    }\n    if (abs (s.x) < len) {\n      dMin = d;\n      qnHit = vec3 (0., s.yz);\n    } else if (srdx * ro.x < - len) {\n      d = - (srdx * ro.x + len) / abs (rd.x);\n      if (d > 0.) {\n        s = ro + d * rd;\n        if (length (s.yz) < rad) {\n          dMin = d;\n          qnHit = vec3 (0., 0., - srdx);\n        }\n      }\n    }\n  }\n  return vec4 (s, dMin);\n}\n\nvec4 CapsHit (vec3 ro, vec3 rd, float rad, float len)\n{\n  vec3 s, sMin;\n  float dMin, d, a, b, w, drz;\n  dMin = dstFar;\n  a = dot (rd.xy, rd.xy);\n  b = dot (rd.xy, ro.xy);\n  w = b * b - a * (dot (ro.xy, ro.xy) - rad * rad);\n  if (w > 0. && a > 0.) {\n    d = - b - sqrt (w);\n    d /= a;\n    s = ro + d * rd;\n    if (d > 0. && abs (s.z) < len) {\n      dMin = d;\n      sMin = s;\n      qnHit = vec3 (s.xy, 0.);\n    } else {\n      drz = - len * sign (s.z);\n      ro.z += drz;\n      b = dot (rd, ro);\n      w = b * b - (dot (ro, ro) - rad * rad);\n      if (w > 0.) {\n        d = - b - sqrt (w);\n        if (d > 0.) {\n          s = ro + d * rd;\n          dMin = d;\n          sMin = s;\n          sMin.z -= drz;\n          qnHit = s;\n        }\n      }\n    }\n  }\n  return vec4 (sMin, dMin);\n}\n\nfloat BoidHit (vec3 ro, vec3 rd)\n{\n  mat3 bMat;\n  vec4 ds;\n  vec3 rom, rdm, qHitM, qnHitM;\n  float dMin;\n  dMin = dstFar;\n  for (int n = VAR_ZERO; n < nBoid; n ++) {\n    bMat = QtToRMat (Loadv4 (3 * n + 4 + 2));\n    rom = bMat * (ro - Loadv4 (3 * n + 4).xyz);\n    rdm = bMat * rd;\n    ds = CapsHit (rom, rdm, bdRad, bdLen);\n    if (ds.w < dMin) {\n      dMin = ds.w;\n      idBoid = n;\n      qHitM = ds.xyz;\n      qnHitM = qnHit;\n    }\n    rom.z += 2. * bdLen;\n    ds = VCylHit (rom, rdm, wnRad, wnThk);\n    if (ds.w < dMin) {\n      dMin = ds.w;\n      idBoid = n;\n      qHitM = ds.xyz;\n      qHitM.z -= 2. * bdLen;\n      qnHitM = qnHit;\n    }\n  }\n  qHit = qHitM;\n  qnHit = normalize (qnHitM) * QtToRMat (Loadv4 (3 * idBoid + 4 + 2));\n  return dMin;\n}\n\nvec4 BoidCol ()\n{\n  vec3 col;\n  float s;\n  if (idBoid == 0) col = vec3 (1., 0.2, 0.2);\n  else col = ((Loadv4 (3 * idBoid + 4).w == 0.) ? vec3 (1., 1., 0.2) : vec3 (0.2, 1., 1.));\n  col *= 0.9 + 0.1 * smoothstep (- bdLen, bdLen, qHit.z);\n  s = length (qHit.yz - vec2 (0.5 * bdLen, bdLen + 0.35 * bdRad));\n  if (s < 0.2 * bdRad) col = (s < 0.1 * bdRad) ? vec3 (1.) : vec3 (0.2, 0.8, 0.2);\n  if (length (qHit - vec3 (0., -0.2 * bdRad, bdRad + bdLen)) < 0.6 * bdRad)\n     col = vec3 (1.) * (1. - 0.9 * step (abs (qHit.y + 0.2 * bdRad), 0.05 * bdRad) *\n        SmoothBump (0.2, 0.8, 0.05, mod (8. * abs (qHit.x / bdRad), 1.)));\n  if (length (qHit.yz + vec2 (0., 2. * bdLen)) > 0.7 * wnRad) {\n    s = 0.25 + atan (qHit.z + 2. * bdLen, - qHit.y) / (2. * pi);\n    if (abs (s) < 0.15) col = mix (vec3 (0., 1., 0.), col, SmoothBump (0.15, 0.85, 0.05, mod (32. * s, 1.)));\n  }\n  return vec4 (col, 0.2);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec4 sLen;\n  vec3 q;\n  float dMin, d, rc;\n  dMin = dstFar;\n  rc = 0.2;\n  q = p;\n  q.y -= hoopHt;\n  d = min (PrRoundBoxDf (vec3 (abs (q.x) - hoopSz, q.yz), hoopThk + vec3 (0., hoopSz, 0.) - rc, rc),\n           PrRoundBoxDf(vec3 (q.xz, abs (q.y) - hoopSz).xzy, hoopThk + vec3 (hoopSz, 0., 0.) - rc, rc));\n  DMIN (1);\n  q = p;\n  sLen = vec4 (vec3 (regSz), 0.);\n  q = abs (q);\n  d = min (min (\n     PrRoundBoxDf (q - sLen.wyz, sLen.xww + rc, rc),\n     PrRoundBoxDf (q - sLen.xwz, sLen.wyw + rc, rc)),\n     PrRoundBoxDf (q - sLen.xyw, sLen.wwz + rc, rc));\n  DMIN (2);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 80; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat TurbLt (vec3 p, vec3 n, float t)\n{\n  vec4 b;\n  vec2 q, qq;\n  float c, tt;\n  q = 2. * pi * mod (vec2 (dot (p.yzx, n), dot (p.zxy, n)), 1.) - 256.;\n  t += 11.;\n  c = 0.;\n  qq = q;\n  for (int j = 1; j <= 7; j ++) {\n    tt = t * (1. + 1. / float (j));\n    b = sin (tt + vec4 (- qq + vec2 (0.5 * pi, 0.), qq + vec2 (0., 0.5 * pi)));\n    qq = q + tt + b.xy + b.wz;\n    c += 1. / length (q / sin (qq + vec2 (0., 0.5 * pi)));\n  }\n  return clamp (pow (abs (1.25 - abs (0.167 + 40. * c)), 8.), 0., 1.);\n}\n\nfloat WatShd (vec3 rd)\n{\n  vec2 p;\n  float t, h;\n  if (rd.y == 0.) rd.y = 0.0001;;\n  p = 20. * rd.xz / rd.y;\n  t = tCur * 2.;\n  h = sin (2. * p.x + 0.77 * t + sin (0.73 * p.y - t)) + sin (0.81 * p.y - 0.89 * t +\n     sin (0.33 * p.x + 0.34 * t)) + 0.5 * (sin (1.43 * p.x - t) + sin (0.63 * p.y + t));\n  h *= 0.04 * smoothstep (0.5, 1., rd.y);\n  return h;\n}\n\nvec3 BgCol (vec3 rd)\n{\n  float t, gd, b;\n  t = tCur * 4.;\n  b = dot (vec2 (atan (rd.x, rd.z), 0.5 * pi - acos (rd.y)), vec2 (2., sin (rd.x)));\n  gd = clamp (sin (5. * b + t), 0., 1.) * clamp (sin (3.5 * b - t), 0., 1.) +\n     clamp (sin (21. * b - t), 0., 1.) * clamp (sin (17. * b + t), 0., 1.);\n  return mix (vec3 (0., 0.5, 0.8), vec3 (0.25, 0.4, 1.), 0.5 + 0.5 * rd.y) *\n     (0.24 + 0.44 * (rd.y + 1.) * (rd.y + 1.)) * (1. + gd * 0.05);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstBoid, dstObj;\n  dstBoid = BoidHit (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  if (min (dstObj, dstBoid) < dstFar) {\n    if (dstBoid < dstObj) {\n      ro += dstBoid * rd;\n      col4 = BoidCol ();\n      vn = qnHit;\n    } else {\n      ro += dstObj * rd;\n      if (idObj == 1) {\n        col4 = vec4 (0.4, 0.7, 0.5, 0.);\n      } else if (idObj == 2) {\n        col4 = vec4 (0.5, 0.5, 0.6, 0.);\n      }\n      vn = ObjNf (ro);\n    }\n    col = col4.rgb * (0.2 + 0.2 * max (- dot (vn, ltDir), 0.) + 0.8 * max (dot (vn, ltDir), 0.)) +\n       col4.a * pow (max (dot (reflect (ltDir, vn), rd), 0.), 32.);\n    if (idObj == 1) col += 0.1 * TurbLt (0.5 * ro, abs (vn), 0.5 * tCur) *\n       smoothstep (-0.3, -0.1, vn.y);\n  } else col = BgCol (rd) + WatShd (rd);\n  return clamp (col, 0., 1.);\n}\n\nvec3 ShowWg (vec2 uv, vec2 canvas, vec3 col, vec4 parmV)\n{\n  vec4 wgBx[4];\n  vec3 cg;\n  vec2 ut, c;\n  float asp, w;\n  asp = canvas.x / canvas.y;\n  wgBx[0] = vec4 (0.43 * asp, -0.2, 0.02, 0.);\n  wgBx[1] = vec4 (0.48 * asp, -0.2, 0.02, 0.);\n  wgBx[2] = vec4 (0.43 * asp, 0.05, 0.01 * asp, 0.15);\n  wgBx[3] = vec4 (0.48 * asp, 0.05, 0.01 * asp, 0.15);\n  c = vec2 (1., 0.);\n  for (int k = 0; k <= 1; k ++) {\n    col = mix (((parmV[k] == 0.) ? c.yxy : (parmV[k] == 1.) ? c.xxy : c.xyy), col,\n       smoothstep (1.2, 2.2, abs (length (0.5 * uv - wgBx[k].xy) - wgBx[k].z) * canvas.y));\n  }\n  for (int k = 2; k <= 3; k ++) {\n    ut = 0.5 * uv - wgBx[k].xy;\n    w = Maxv2 (abs (ut) - wgBx[k].zw);\n    if (abs (w) * canvas.y < 1. || w < 0. && mod (0.5 * ((0.5 * uv.y - wgBx[k].y) / wgBx[k].w - 0.99), 0.1) *\n       canvas.y < 6.) col = vec3 (0.7);\n    cg = (k == 2) ? c.xyx : ((parmV[k] > 0.7) ? c.xyy : ((parmV[k] > 0.3) ? c.xxy : c.yxy));\n    col = mix (cg, col, smoothstep (1.5, 3.5, abs (length (ut - vec2 (0., (parmV[k] - 0.5) *\n       2. * wgBx[k].w)) - 0.7 * wgBx[k].z) * canvas.y));\n  }\n  return col;\n}\n\n#define N_WIN  4\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat, flMat;\n  vec4 stDat, mPtr;\n  vec3 rd, ro, vd, rLd, vLd, col, rOff;\n  vec2 canvas, uv, mMid[N_WIN], ut[N_WIN], mSize, msw;\n  float tCur, el, az, asp, zmFac, zmVar, flVar, szMode, vuId, vuIdO, regId;\n  int wgSel;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  asp = canvas.x / canvas.y;\n  mSize = (1./5.) * vec2 (asp, 1.);\n  mMid[0] = (1. / mSize.y - 1.) * mSize;\n  mMid[1] = mMid[0] * vec2 (1., -1.);\n  mMid[2] = mMid[0] * vec2 (-1., -1.);\n  mMid[3] = mMid[0] * vec2 (-1., 1.);\n  for (int k = 0; k < N_WIN; k ++) ut[k] = abs (uv - mMid[k]) - mSize;\n  stDat = Loadv4 (0);\n  vuMode = stDat.y;\n  nBoid = int (stDat.z);\n  regSz = stDat.w;\n  stDat = Loadv4 (1);\n  hoopSz = stDat.x;\n  hoopThk = stDat.y;\n  hoopHt = stDat.z;\n  stDat = Loadv4 (2);\n  flVar = stDat.x;\n  zmVar = stDat.y;\n  szMode = stDat.z;\n  stDat = Loadv4 (3);\n  mPtr = vec4 (stDat.xyz, 0.);\n  wgSel = int (stDat.w);\n  rLd = Loadv4 (0 + 4).xyz;\n  bdRad = 0.15;\n  bdLen = 0.1;\n  wnRad = 0.25;\n  wnThk = 0.005;\n  az = 0.;\n  el = 0.;\n  regId = -1.;\n  if (wgSel < 0 && mPtr.z > 0.) {\n    for (int k = 0; k < N_WIN; k ++) {\n      msw = 2. * mPtr.xy - mMid[k] / vec2 (asp, 1.);\n      if (Maxv2 (abs (msw)) < mSize.y) {\n        regId = 1. + float (k);\n        msw /= 2. * mSize.y;\n        break;\n      }\n    }\n    if (regId == -1.) msw = mPtr.xy;\n  }\n  vuId = 0.;\n  for (int k = 0; k < N_WIN; k ++) {\n    if (Maxv2 (ut[k]) < 0.) {\n      uv = (uv - mMid[k]) / mSize.y;\n      vuId = float (k + 1);\n      break;\n    }\n  }\n  vuIdO = vuId;\n  if (regId > 0. && (vuId == 0. || vuId == regId)) vuId = regId - vuId;\n  if (wgSel < 0) {\n    if (mPtr.z > 0. && (vuId == 0. || vuId == regId)) {\n      az += 2. * pi * msw.x;\n      el += pi * msw.y;\n    }\n  }\n  vuMode = mod (vuMode + vuId, 5.);\n  if (vuMode == 0.) {\n    ro = vec3 (0., 0., - 4. * regSz);\n    vd = normalize (rLd - ro);\n    zmFac = 3. + 15. * zmVar;\n    az = clamp (0.25 * az, -0.2 * pi, 0.2 * pi);\n    el = clamp (0.25 * el, -0.2 * pi, 0.2 * pi);\n    az += 0.5 * pi + atan (- vd.z, vd.x);\n    el += asin (vd.y);\n  } else if (vuMode == 1.) {\n    ro = vec3 (0., 0., - 4. * regSz);\n    zmFac = 2.5 + 6. * zmVar;\n    el = clamp (el, -0.25 * pi, 0.25 * pi);\n  } else if (vuMode >= 2.) {\n    az = clamp (az, - pi, pi);\n    el = clamp (el, -0.3 * pi, 0.3 * pi);\n    zmFac = 0.5 + 4.5 * zmVar;\n  }\n  vuMat = StdVuMat (el, az);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  if (vuMode == 1.) {\n    ro = vuMat * ro;\n  } else if (vuMode >= 2.) {\n    flMat = QtToRMat (Loadv4 (2 + 4));\n    rOff = (vuMode == 3.) ? vec3 (0., 2.5 * bdRad, 0.) : ((vuMode == 2.) ?\n       vec3 (0., 2. * bdRad, -15. * bdLen) : vec3 (0., 2. * bdRad, 15. * bdLen));\n    ro = rLd + rOff * flMat;\n    if (vuMode == 4.) rd.z *= -1.;\n    rd = rd * flMat;\n  }\n  dstFar = 8. * regSz;\n  ltDir = normalize (vec3 (1., 1., -1.));\n  col = ShowScene (ro, rd);\n  if (vuIdO == 0.) col = ShowWg (uv, canvas, col, vec4 (vuMode, szMode, zmVar, flVar));\n  if (mPtr.z > 0. && wgSel < 0 && vuIdO == 0. && Maxv2 (abs (uv)) < 0.03 &&\n     Minv2 (abs (uv)) < 0.003) col = vec3 (0.8, 0.8, 0.1);\n  for (int k = 0; k < N_WIN; k ++) {\n    if (Maxv2 (ut[k]) < 0. && Minv2 (abs (ut[k])) * canvas.y < 2.)\n       col = vec3 (0.8, 0.8, 0.2);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 QtToRMat (vec4 q)\n{\n  mat3 m;\n  vec3 a1, a2;\n  a1 = q.yzx * q.zxy;\n  a2 = q.w * q.xyz;\n  a1 += a2;\n  a2 = a1 - 2. * a2;\n  m[1][2] = a1.x;  m[2][1] = a2.x;\n  m[2][0] = a1.y;  m[0][2] = a2.y;\n  m[0][1] = a1.z;  m[1][0] = a2.z;\n  q.xyz = q.xyz * q.xyz + q.w * q.w - 0.5;\n  m[0][0] = q.x;  m[1][1] = q.y;  m[2][2] = q.z;\n  return 2. * m;\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"U-Boids\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\n#define VAR_ZERO min (nFrame, 0)\n\nvec4 RMatToQt (mat3 m);\nfloat Maxv2 (vec2 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nBoidMx = 1024;\nvec3 rLd, vLd, aLd;\nfloat vFly, regSz, fSep, rFlok, fFlok, fAln, fLead, rAttr, fDamp, nStep, dt,\n   hoopSz, hoopThk, hoopHt;\nint nFrame, nBoid;\nconst float pi = 3.1415927;\nconst float txRow = 128.;\n\nvoid Step (int mId, out vec3 r, out vec3 v, out vec3 a, out float grp)\n{\n  vec4 p;\n  vec3 dr, rSum, vSum;\n  float nNeb, rLen, vMag, rMarg;\n  p = Loadv4 (3 * mId + 4);\n  r = p.xyz;\n  grp = p.w;\n  v = Loadv4 (3 * mId + 4 + 1).xyz;\n  a = vec3 (0.);\n  if (nStep > 0.) {\n    vSum = vec3 (0.);\n    rSum = vec3 (0.);\n    nNeb = 0.;\n    for (int n = VAR_ZERO; n < nBoid; n ++) {\n      if (n != mId) {\n        p = Loadv4 (3 * n + 4);\n        dr = r - p.xyz;\n        rLen = length (dr);\n        if (rLen < 1.) a += fSep * (1. / rLen - 1.) * dr;\n        if (rLen < rFlok && grp == p.w) {\n          rSum += p.xyz;\n          vSum += Loadv4 (3 * n + 4 + 1).xyz;\n          ++ nNeb;\n        }\n      }\n    }\n    if (nNeb > 0.) a -= fFlok * (r - rSum / nNeb) + fAln * (v - vSum / nNeb);\n    dr = r - rLd;\n    rLen = length (dr);\n    if (rLen < rAttr) {\n      a += ((1. - 2. * smoothstep (2., 3., rLen)) * fLead / max (rLen * rLen, 0.001)) * dr;\n    }\n    rMarg = 1.;\n    dr = r;\n    dr.xy -= vec2 ((hoopSz - hoopThk) * sign (r.x), hoopHt);\n    dr = max (abs (dr) - vec3 (hoopThk, hoopSz, hoopThk), 0.) * sign (dr);\n    rLen = length (dr);\n    if (rLen < hoopThk + rMarg) a += fSep * ((hoopThk + rMarg) / rLen - 1.) * dr;\n    dr = r;\n    dr.y -= hoopHt + (hoopSz - hoopThk) * sign (r.y);\n    dr = max (abs (dr) - vec3 (hoopSz, hoopThk, hoopThk), 0.) * sign (dr);\n    rLen = length (dr);\n    if (rLen < hoopThk + rMarg) a += fSep * ((hoopThk + rMarg) / rLen - 1.) * dr;\n    a += 0.05 * (vFly - length (v)) * normalize (v);\n    dr = (regSz - 0.3) * sign (r) - r;\n    a -= step (abs (dr), vec3 (1.)) * 10. * fSep * (1. / abs (dr) - 1.) * dr;\n    a -= fDamp * v;\n    v += dt * a;\n    r += dt * v;\n  }\n}\n\nvec3 TrackPos (float t)\n{\n  vec3 r;\n  float tt = mod (t, 1.);\n  r.xz = 0.35 * regSz * ((mod (t, 2.) < 1.) ? vec2 (- cos (2. * pi * tt) + 1., sin (2. * pi * tt)) :\n     vec2 (cos (2. * pi * tt) - 1., sin (2. * pi * tt)));\n  r.y = hoopHt + (hoopSz + 7. * hoopThk) * ((mod (floor (t / 2. - 0.25), 4.) > 1.) ?\n     SmoothBump (0.3, 0.7, 0.15, tt) : 1.);\n  return r;\n}\n\nvoid Init (int mId, out vec3 r, out vec3 v, out vec3 a, out float grp)\n{\n  float mIdf, w;\n  mIdf = float (mId) + 0.1;\n  w = floor (pow (float (nBoid), 1./3.) + 0.999);\n  r = 2.5 * vec3 (mod (mIdf, w), mod (floor (mIdf / w), w), floor (mIdf / (w * w))) -\n     vec3 (1.25 * w, 1.25 * w, regSz - 1.25 * w);\n  v = vFly * (2. * normalize (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3),\n     Hashff (mIdf + 0.6)) - 0.5) + 1.);\n  a = vec3 (0.);\n  grp = floor (2. * Hashff (mIdf));\n}\n\nvoid SetLead (out vec3 r, out vec3 v, out vec3 a)\n{\n  vec3 rf, rb;\n  float s, ds;\n  s = 5.5 * vFly * max (nStep, 0.) * dt / (2. * pi * regSz);\n  ds = 0.1;\n  r = TrackPos (s);\n  rf = TrackPos (s + ds);\n  rb = TrackPos (s - ds);\n  v = (rf - rb) / (2. * ds);\n  a = (rf - 2. * r + rb) / (ds * ds);\n}\n\nvec4 EvalOri (int mId, vec3 v, vec3 a)\n{\n  vec3 va, ort, ca, sa;\n  float el, az, rl;\n  v = normalize (v);\n  va = cross (a, v);\n  el = -0.7 * asin (v.y);\n  az = atan (v.z, v.x) - 0.5 * pi;\n  rl = 0.001 * length (va) * sign (va.y);\n  ort = vec3 (el, az, rl);\n  ca = cos (ort);\n  sa = sin (ort);\n  return RMatToQt (mat3 (ca.z, - sa.z, 0., sa.z, ca.z, 0., 0., 0., 1.) *\n     mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n     mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, wgBx[4], stDat, p;\n  vec3 r, v, a;\n  vec2 iFrag, canvas, ust;\n  float tCur, grp, vuMode, szMode, asp, zmVar, flVar, autoVar;\n  int mId, pxId, wgSel, wgReg, kp;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 3 * nBoidMx + 4) discard;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  mId = (pxId >= 4) ? (pxId - 4) / 3 : -1;\n  vFly = 1.2;\n  hoopSz = 4.;\n  hoopThk = 1.;\n  hoopHt = -2.;\n  fSep = 10.;\n  rFlok = 6.;\n  fDamp = 1e-4;\n  dt = 0.05;\n  wgReg = -2;\n  if (nFrame <= 1) {\n    mPtrP = mPtr;\n    wgSel = -1;\n    szMode = 1.;\n    doInit = true;\n  } else {\n    doInit = false;\n    stDat = Loadv4 (0);\n    nStep = stDat.x;\n    vuMode = stDat.y;\n    nBoid = int (stDat.z);\n    regSz = stDat.w;\n    stDat = Loadv4 (1);\n    autoVar = stDat.w;\n    stDat = Loadv4 (2);\n    flVar = stDat.x;\n    zmVar = stDat.y;\n    szMode = stDat.z;\n    stDat = Loadv4 (3);\n    mPtrP = vec4 (stDat.xyz, 0.);\n    wgSel = int (stDat.w);\n  }\n  asp = canvas.x / canvas.y;\n  if (mPtr.z > 0.) {\n    wgBx[0] = vec4 (0.43 * asp, -0.2, 0.02, 0.);\n    wgBx[1] = vec4 (0.48 * asp, -0.2, 0.02, 0.);\n    wgBx[2] = vec4 (0.43 * asp, 0.05, 0.01 * asp, 0.15);\n    wgBx[3] = vec4 (0.48 * asp, 0.05, 0.01 * asp, 0.15);\n    ust = mPtr.xy * vec2 (asp, 1.);\n    if (length (ust - wgBx[0].xy) < wgBx[0].z) wgReg = 0;\n    if (length (ust - wgBx[1].xy) < wgBx[1].z) wgReg = 1;\n    if (Maxv2 (abs (ust - wgBx[2].xy) - wgBx[2].zw) < 0.) wgReg = 2;\n    if (Maxv2 (abs (ust - wgBx[3].xy) - wgBx[3].zw) < 0.) wgReg = 3;\n    if (mPtrP.z <= 0.) wgSel = wgReg;\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n  }\n  if (wgSel <= 1) {\n    if (mPtrP.z <= 0.) {\n      if (wgSel == 0) {\n        vuMode = mod (++ vuMode, 5.);\n        zmVar = 0.2;\n      } else if (wgSel == 1) {\n        szMode = mod (++ szMode, 3.);\n        doInit = true;\n        zmVar = 0.2;\n      }\n    }\n  } else if (wgSel == 2) {\n    zmVar = clamp (0.5 + 0.5 * (mPtr.y - wgBx[2].y) / wgBx[2].w, 0., 1.);\n  } else if (wgSel == 3) {\n    flVar = clamp (0.5 + 0.5 * (mPtr.y - wgBx[3].y) / wgBx[3].w, 0., 1.);\n    autoVar = 0.;\n  }\n  if (doInit) {\n    nBoid = (szMode == 0.) ?  nBoidMx / 4 : ((szMode == 1.) ? nBoidMx / 2 : nBoidMx);\n    regSz = 40. * pow (float (nBoid) / float (nBoidMx), 1./3.);\n    nStep = -50.;\n    vuMode = 0.;\n    zmVar = 0.2;\n    flVar = 0.2;\n    autoVar = 1.;\n  } else {\n    ++ nStep;\n    if (autoVar > 0.) flVar = 0.2 + 0.8 * SmoothBump (0.1, 0.9, 0.1,\n       fract (0.1 * vFly * max (nStep, 0.) * dt / (2. * regSz)));\n  }\n  fLead = mix (1., 10., flVar);\n  rAttr = mix (3., 12., flVar);\n  fAln = mix (0., 0.04, flVar);\n  fFlok = mix (0., 0.04, flVar);\n  if (mId < nBoid) {\n    if (mId >= 0) SetLead (rLd, vLd, aLd);\n    if (mId > 0) {\n      if (doInit) Init (mId, r, v, a, grp);\n      else Step (mId, r, v, a, grp);\n    }\n  }\n  if (mId == 0) {\n    r = rLd;\n    v = vLd;\n    a = aLd;\n    grp = 2.;\n  }\n  if (mId < 0) {\n    if      (pxId == 0) stDat = vec4 (nStep, vuMode, float (nBoid), regSz);\n    else if (pxId == 1) stDat = vec4 (hoopSz, hoopThk, hoopHt, autoVar);\n    else if (pxId == 2) stDat = vec4 (flVar, zmVar, szMode, 0.);\n    else if (pxId == 3) stDat = vec4 (mPtr.xyz, float (wgSel));\n  } else if (mId < nBoid) {\n    kp = 4 + 3 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (r, grp);\n    else if (pxId == kp + 1) stDat = vec4 (v, 0.);\n    else if (pxId == kp + 2) stDat = EvalOri (mId, v, a);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// \"U-Boids\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\n#define VAR_ZERO min (nFrame, 0)\n\nvec4 RMatToQt (mat3 m);\nfloat Maxv2 (vec2 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nBoidMx = 1024;\nvec3 rLd, vLd, aLd;\nfloat vFly, regSz, fSep, rFlok, fFlok, fAln, fLead, rAttr, fDamp, nStep, dt,\n   hoopSz, hoopThk, hoopHt;\nint nFrame, nBoid;\nconst float pi = 3.1415927;\nconst float txRow = 128.;\n\nvoid Step (int mId, out vec3 r, out vec3 v, out vec3 a, out float grp)\n{\n  vec4 p;\n  vec3 dr, rSum, vSum;\n  float nNeb, rLen, vMag, rMarg;\n  p = Loadv4 (3 * mId + 4);\n  r = p.xyz;\n  grp = p.w;\n  v = Loadv4 (3 * mId + 4 + 1).xyz;\n  a = vec3 (0.);\n  if (nStep > 0.) {\n    vSum = vec3 (0.);\n    rSum = vec3 (0.);\n    nNeb = 0.;\n    for (int n = VAR_ZERO; n < nBoid; n ++) {\n      if (n != mId) {\n        p = Loadv4 (3 * n + 4);\n        dr = r - p.xyz;\n        rLen = length (dr);\n        if (rLen < 1.) a += fSep * (1. / rLen - 1.) * dr;\n        if (rLen < rFlok && grp == p.w) {\n          rSum += p.xyz;\n          vSum += Loadv4 (3 * n + 4 + 1).xyz;\n          ++ nNeb;\n        }\n      }\n    }\n    if (nNeb > 0.) a -= fFlok * (r - rSum / nNeb) + fAln * (v - vSum / nNeb);\n    dr = r - rLd;\n    rLen = length (dr);\n    if (rLen < rAttr) {\n      a += ((1. - 2. * smoothstep (2., 3., rLen)) * fLead / max (rLen * rLen, 0.001)) * dr;\n    }\n    rMarg = 1.;\n    dr = r;\n    dr.xy -= vec2 ((hoopSz - hoopThk) * sign (r.x), hoopHt);\n    dr = max (abs (dr) - vec3 (hoopThk, hoopSz, hoopThk), 0.) * sign (dr);\n    rLen = length (dr);\n    if (rLen < hoopThk + rMarg) a += fSep * ((hoopThk + rMarg) / rLen - 1.) * dr;\n    dr = r;\n    dr.y -= hoopHt + (hoopSz - hoopThk) * sign (r.y);\n    dr = max (abs (dr) - vec3 (hoopSz, hoopThk, hoopThk), 0.) * sign (dr);\n    rLen = length (dr);\n    if (rLen < hoopThk + rMarg) a += fSep * ((hoopThk + rMarg) / rLen - 1.) * dr;\n    a += 0.05 * (vFly - length (v)) * normalize (v);\n    dr = (regSz - 0.3) * sign (r) - r;\n    a -= step (abs (dr), vec3 (1.)) * 10. * fSep * (1. / abs (dr) - 1.) * dr;\n    a -= fDamp * v;\n    v += dt * a;\n    r += dt * v;\n  }\n}\n\nvec3 TrackPos (float t)\n{\n  vec3 r;\n  float tt = mod (t, 1.);\n  r.xz = 0.35 * regSz * ((mod (t, 2.) < 1.) ? vec2 (- cos (2. * pi * tt) + 1., sin (2. * pi * tt)) :\n     vec2 (cos (2. * pi * tt) - 1., sin (2. * pi * tt)));\n  r.y = hoopHt + (hoopSz + 7. * hoopThk) * ((mod (floor (t / 2. - 0.25), 4.) > 1.) ?\n     SmoothBump (0.3, 0.7, 0.15, tt) : 1.);\n  return r;\n}\n\nvoid Init (int mId, out vec3 r, out vec3 v, out vec3 a, out float grp)\n{\n  float mIdf, w;\n  mIdf = float (mId) + 0.1;\n  w = floor (pow (float (nBoid), 1./3.) + 0.999);\n  r = 2.5 * vec3 (mod (mIdf, w), mod (floor (mIdf / w), w), floor (mIdf / (w * w))) -\n     vec3 (1.25 * w, 1.25 * w, regSz - 1.25 * w);\n  v = vFly * (2. * normalize (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3),\n     Hashff (mIdf + 0.6)) - 0.5) + 1.);\n  a = vec3 (0.);\n  grp = floor (2. * Hashff (mIdf));\n}\n\nvoid SetLead (out vec3 r, out vec3 v, out vec3 a)\n{\n  vec3 rf, rb;\n  float s, ds;\n  s = 5.5 * vFly * max (nStep, 0.) * dt / (2. * pi * regSz);\n  ds = 0.1;\n  r = TrackPos (s);\n  rf = TrackPos (s + ds);\n  rb = TrackPos (s - ds);\n  v = (rf - rb) / (2. * ds);\n  a = (rf - 2. * r + rb) / (ds * ds);\n}\n\nvec4 EvalOri (int mId, vec3 v, vec3 a)\n{\n  vec3 va, ort, ca, sa;\n  float el, az, rl;\n  v = normalize (v);\n  va = cross (a, v);\n  el = -0.7 * asin (v.y);\n  az = atan (v.z, v.x) - 0.5 * pi;\n  rl = 0.001 * length (va) * sign (va.y);\n  ort = vec3 (el, az, rl);\n  ca = cos (ort);\n  sa = sin (ort);\n  return RMatToQt (mat3 (ca.z, - sa.z, 0., sa.z, ca.z, 0., 0., 0., 1.) *\n     mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n     mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, wgBx[4], stDat, p;\n  vec3 r, v, a;\n  vec2 iFrag, canvas, ust;\n  float tCur, grp, vuMode, szMode, asp, zmVar, flVar, autoVar;\n  int mId, pxId, wgSel, wgReg, kp;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 3 * nBoidMx + 4) discard;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  mId = (pxId >= 4) ? (pxId - 4) / 3 : -1;\n  vFly = 1.2;\n  hoopSz = 4.;\n  hoopThk = 1.;\n  hoopHt = -2.;\n  fSep = 10.;\n  rFlok = 6.;\n  fDamp = 1e-4;\n  dt = 0.05;\n  wgReg = -2;\n  if (nFrame <= 1) {\n    mPtrP = mPtr;\n    wgSel = -1;\n    szMode = 1.;\n    doInit = true;\n  } else {\n    doInit = false;\n    stDat = Loadv4 (0);\n    nStep = stDat.x;\n    vuMode = stDat.y;\n    nBoid = int (stDat.z);\n    regSz = stDat.w;\n    stDat = Loadv4 (1);\n    autoVar = stDat.w;\n    stDat = Loadv4 (2);\n    flVar = stDat.x;\n    zmVar = stDat.y;\n    szMode = stDat.z;\n    stDat = Loadv4 (3);\n    mPtrP = vec4 (stDat.xyz, 0.);\n    wgSel = int (stDat.w);\n  }\n  asp = canvas.x / canvas.y;\n  if (mPtr.z > 0.) {\n    wgBx[0] = vec4 (0.43 * asp, -0.2, 0.02, 0.);\n    wgBx[1] = vec4 (0.48 * asp, -0.2, 0.02, 0.);\n    wgBx[2] = vec4 (0.43 * asp, 0.05, 0.01 * asp, 0.15);\n    wgBx[3] = vec4 (0.48 * asp, 0.05, 0.01 * asp, 0.15);\n    ust = mPtr.xy * vec2 (asp, 1.);\n    if (length (ust - wgBx[0].xy) < wgBx[0].z) wgReg = 0;\n    if (length (ust - wgBx[1].xy) < wgBx[1].z) wgReg = 1;\n    if (Maxv2 (abs (ust - wgBx[2].xy) - wgBx[2].zw) < 0.) wgReg = 2;\n    if (Maxv2 (abs (ust - wgBx[3].xy) - wgBx[3].zw) < 0.) wgReg = 3;\n    if (mPtrP.z <= 0.) wgSel = wgReg;\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n  }\n  if (wgSel <= 1) {\n    if (mPtrP.z <= 0.) {\n      if (wgSel == 0) {\n        vuMode = mod (++ vuMode, 5.);\n        zmVar = 0.2;\n      } else if (wgSel == 1) {\n        szMode = mod (++ szMode, 3.);\n        doInit = true;\n        zmVar = 0.2;\n      }\n    }\n  } else if (wgSel == 2) {\n    zmVar = clamp (0.5 + 0.5 * (mPtr.y - wgBx[2].y) / wgBx[2].w, 0., 1.);\n  } else if (wgSel == 3) {\n    flVar = clamp (0.5 + 0.5 * (mPtr.y - wgBx[3].y) / wgBx[3].w, 0., 1.);\n    autoVar = 0.;\n  }\n  if (doInit) {\n    nBoid = (szMode == 0.) ?  nBoidMx / 4 : ((szMode == 1.) ? nBoidMx / 2 : nBoidMx);\n    regSz = 40. * pow (float (nBoid) / float (nBoidMx), 1./3.);\n    nStep = -50.;\n    vuMode = 0.;\n    zmVar = 0.2;\n    flVar = 0.2;\n    autoVar = 1.;\n  } else {\n    ++ nStep;\n    if (autoVar > 0.) flVar = 0.2 + 0.8 * SmoothBump (0.1, 0.9, 0.1,\n       fract (0.1 * vFly * max (nStep, 0.) * dt / (2. * regSz)));\n  }\n  fLead = mix (1., 10., flVar);\n  rAttr = mix (3., 12., flVar);\n  fAln = mix (0., 0.04, flVar);\n  fFlok = mix (0., 0.04, flVar);\n  if (mId < nBoid) {\n    if (mId >= 0) SetLead (rLd, vLd, aLd);\n    if (mId > 0) {\n      if (doInit) Init (mId, r, v, a, grp);\n      else Step (mId, r, v, a, grp);\n    }\n  }\n  if (mId == 0) {\n    r = rLd;\n    v = vLd;\n    a = aLd;\n    grp = 2.;\n  }\n  if (mId < 0) {\n    if      (pxId == 0) stDat = vec4 (nStep, vuMode, float (nBoid), regSz);\n    else if (pxId == 1) stDat = vec4 (hoopSz, hoopThk, hoopHt, autoVar);\n    else if (pxId == 2) stDat = vec4 (flVar, zmVar, szMode, 0.);\n    else if (pxId == 3) stDat = vec4 (mPtr.xyz, float (wgSel));\n  } else if (mId < nBoid) {\n    kp = 4 + 3 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (r, grp);\n    else if (pxId == kp + 1) stDat = vec4 (v, 0.);\n    else if (pxId == kp + 2) stDat = EvalOri (mId, v, a);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}