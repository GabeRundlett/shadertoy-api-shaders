{
    "Shader": {
        "info": {
            "date": "1633835793",
            "description": "Based on the simplex grid introduced here: https://thebookofshaders.com/11/\nThe math is slightly better explained here: https://www.youtube.com/watch?v=dz6fg-Z0JKk&ab_channel=WannesMalfait\nand barryCentric Coordinates are used for the inner triangles",
            "flags": 0,
            "hasliked": 0,
            "id": "7d3SDS",
            "likes": 6,
            "name": "Simplex Skew Experiment",
            "published": 3,
            "tags": [
                "grid",
                "simplex",
                "skew"
            ],
            "usePreview": 0,
            "username": "Yusef28",
            "viewed": 470
        },
        "renderpass": [
            {
                "code": "\n\nvec2 baryCentric(vec2 A, vec2 B, vec2 C, vec2 P){\n    \n    //no needto normalize because equalateral triangles\n    vec2 AB = B-A;\n    vec2 BC = C-B;\n    vec2 CA = A-C;\n    \n    float areaA = length(cross(vec3(AB,0.),vec3(P-A,0.)));\n    float areaB = length(cross(vec3(BC,0.),vec3(P-B,0.)));\n    float areaC = length(cross(vec3(CA,0.),vec3(P-C,0.)));\n    \n    float ret = 0.;\n    \n    \n    float abSplit = abs(areaA-areaB);\n    float bcSplit = abs(areaC-areaB);\n    float caSplit = abs(areaA-areaC);\n    float thick = 0.03;\n    \n    \n    if(areaA < areaB && areaA < areaC) return vec2(1.,\n                                        smoothstep(thick,thick+0.01,caSplit) *\n                                        smoothstep(thick,thick+0.01,abSplit) );\n    if(areaB < areaA && areaB < areaC) return vec2(2.,\n                                        smoothstep(thick,thick+0.01,bcSplit) *\n                                        smoothstep(thick,thick+0.01,abSplit) );\n    \n    if(areaC < areaA && areaC < areaB) return vec2(3.,\n                                        smoothstep(thick,thick+0.01,caSplit) *\n                                        smoothstep(thick,thick+0.01,bcSplit) );\n    \n    \n    \n    \n    \n    //float linesAB = ret != 1. ? smoothstep(0.1,0.2,abSplit)\n       //                       : 0.;\n                 //(smoothstep(0.03,0.08, bcSplit)) *\n                 //(smoothstep(0.03,0.08, caSplit)) ;\n                 \n    //return linesAB;// * (smoothstep(0.03,0.08, bcSplit));\n    //if( abSplit < 0.05 && ret != 3.) return 4.;\n    //if( cbSplit < 0.05 && ret != 1.) return 4.;\n    //if( acSplit < 0.05 && ret != 2.) return 4.;\n\n}\nfloat badHash(vec2 x){\n    return fract(sin(dot(vec2(23.,72.),x)*134.)*43143.);\n}\nmat2 skew = mat2(1.1547, 0., 1.1547/2., 1.);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    uv.x += iTime/4.;\n    uv *= skew;\n  \n    uv *= 6.;\n    \n    float f = 1.-smoothstep(0.47,0.49, abs(fract(uv.x)-0.5) );\n    float g = 1.-smoothstep(0.47,0.49, abs(fract(uv.y)-0.5) );\n    float h = smoothstep(0.02,0.025,abs(fract(uv.y)-fract(uv.x)) );\n    \n    vec2 ff = fract(uv);\n    vec2 id = floor(uv);\n    \n    float side = sign(ff.x-ff.y);\n    float ii = badHash(id + side);\n    \n    \n    vec2 tri = side < 0. ? baryCentric(vec2(0.),vec2(1.),vec2(0.,1.),ff)\n                          : baryCentric(vec2(0.),vec2(1.,0.),vec2(1.,1.),ff);\n    ff = ff*2.-1.;\n    //float ac = abs(length(abs(ff*mat2(0.707,-0.707,0.707,0.707))-0.7)-0.1);\n    //ac = smoothstep(0.05,0.1,ac);\n    // Time varying pixel color\n    vec3 col = vec3( ii - 0.1*(length(ff-vec2(side*0.35,-side*0.35))-0.05) );\n    \n    \n    //col *= ac;\n    if(side < 0.){\n        col = mix(col, vec3(.3,0.1,0.7), step(.5,tri.x));\n        col = mix(col, vec3(.4,0.7,.9), step(1.5,tri.x));\n        col = mix(col, vec3(0.5,0.6,.3), step(2.5,tri.x));\n        col *= tri.y;//= mix(col, vec3(0.), tri);\n        }\n        \n    if(side > 0.){\n        col = mix(col, vec3(.1,0.,0.).xzy, step(.5,tri.x));\n        col = mix(col, vec3(.4,0.,.1).xzy, step(1.5,tri.x));\n        col = mix(col, vec3(0.8,0.,.3).xzy, step(2.5,tri.x));\n        col *= tri.y;//= mix(col, vec3(0.), tri);\n        }\n      col *=g*f*h; \n      col *= 1.2;\n    //col *= ac;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}