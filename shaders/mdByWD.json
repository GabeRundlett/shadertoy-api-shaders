{
    "Shader": {
        "info": {
            "date": "1687785902",
            "description": "Hexes\nTry sides = 12 or 3",
            "flags": 0,
            "hasliked": 0,
            "id": "mdByWD",
            "likes": 3,
            "name": "Tapestry 7",
            "published": 3,
            "tags": [
                "ifs"
            ],
            "usePreview": 0,
            "username": "iterati",
            "viewed": 163
        },
        "renderpass": [
            {
                "code": "float sheen( in float d, in float x )\n{\n    return 1. - step(x, abs(d));\n}\n\nvec4 getHex(vec2 p)\n{\n    vec2 s = vec2(1, ROOT_3);\n    vec4 hC = floor(vec4(p, p - vec2(.5, 1))/s.xyxy) + .5;\n    vec4 h = vec4(p - hC.xy*s, p - (hC.zw + .5)*s);\n    return dot(h.xy, h.xy) < dot(h.zw, h.zw) \n        ? vec4(h.xy, hC.xy) \n        : vec4(h.zw, hC.zw + .5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv0 = (fragCoord * 2.0 - iResolution.xy) / (iResolution.y * 0.5);\n    vec2 uv = uv0;\n    vec3 finalColor = vec3(0.0);\n    float d = 0.;\n    int sides = 6;\n    vec3 col = vec3(0.); \n    vec2 h0 = getHex(0.5 * uv).xy;\n    vec2 h = h0;\n\n    float r = sinT(iTime, 21.) * .8 + 0.2;\n    float n = sawT(iTime, 15.) * (float(sides) - 1.) + 1.;\n    float s = sinT(iTime, 45.) * 0.4 + 0.2;\n    float color = sinT(iTime, 60.);\n\n    float x = sinT(iTime, 36.) * 0.2 + 0.8;\n    const float iterations = 5.;\n    for (float i = 0.0; i < iterations; i++) {\n        float xx = x + ((sinT(iTime, 15.) - 0.5) * 0.5 * ((i + 1.) / iterations) * exp(length(uv0 * s)));\n        h = getHex(xx * ROOT_3 * h * ROT).xy;\n        d = sdStar(h, r / ROOT_3, sides, n);\n        d = sheen(d, 0.0025 * (i + 1.) * ROOT_3 / xx);\n        float cc = (1. - sawT(iTime, 29.)) * 5. * (i / iterations);\n        col = palette(mod(cc + color + (length(uv0 * 0.1) * (1. - sinT(iTime, 7.))), 1.));\n        col *= d;\n        if (col.r > 1.) {\n            col.g += 0.5 * (col.r - 1.);\n            col.b += 0.5 * (col.r - 1.);\n            col.r -= 1.;\n        }\n        if (col.g > 1.) {\n            col.r += 0.5 * (col.g - 1.);\n            col.b += 0.5 * (col.g - 1.);\n            col.g -= 1.;\n        }\n        if (col.b > 1.) {\n            col.r += 0.5 * (col.b - 1.);\n            col.g += 0.5 * (col.b - 1.);\n            col.b -= 1.;\n        }\n        finalColor += col;\n    }\n\n    fragColor = vec4(finalColor, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.1415926538\n#define ROOT_3 1.7320508\nconst mat2 ROT = mat2(cos(PI / 6.), sin(PI / 6.), -sin(PI / 6.), cos(PI / 6.));\n\n\nvec3 palette( in float t)\n{\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.333, 0.667);\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat sinT( in float t, in float l )\n{\n    return (sin(((t * 2. * PI) / l) + (0.5 * PI)) * 0.5) + 0.5;\n}\n\nfloat sawT( in float t, float l )\n{\n    return abs((mod(t / l, 1.) - 0.5) * 2.0);\n}\n\nfloat ampT( in float t, float l, float a, float b)\n{\n    return abs(cos((t / l) * a * 2. * PI) * cos((t / l) * b * 2. * PI) * 0.5 - 0.5);\n}\n\nfloat sdStar(in vec2 p, in float r, in int n, in float m)\n{\n    // next 4 lines can be precomputed for a given shape\n    float an = PI/float(n);\n    float en = PI/m;  // m is between 2 and n\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) for regular polygon\n\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nint _N = 2;\n#define mainImage mainImage0(out vec4 O, vec2 U);        \\\nvoid mainImage(out vec4 O, vec2 U) {                     \\\n    vec4 o; O = vec4(0);                                 \\\n    for (int k=0; k < _N*_N; k++ )                       \\\n      { mainImage0(o,U+vec2(k%_N-_N/2,k/_N-_N/2)/float(_N)); O += o; }  \\\n    O /= float(_N*_N);                                   \\\n    O = pow( O, vec4(1./2.2) );        /* to sRGB */     \\\n} \\\nvoid mainImage0",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}