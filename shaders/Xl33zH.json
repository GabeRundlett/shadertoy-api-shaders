{
    "Shader": {
        "info": {
            "date": "1467839167",
            "description": "My first Attempt to combine distance functions with a noise volume.",
            "flags": 0,
            "hasliked": 0,
            "id": "Xl33zH",
            "likes": 81,
            "name": "Cloud Box",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "raymarch",
                "clouds",
                "volumetric"
            ],
            "usePreview": 1,
            "username": "FTL",
            "viewed": 3017
        },
        "renderpass": [
            {
                "code": "\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Noise functions by iq: https://www.shadertoy.com/view/4sfGzS\n//#define USE_PROCEDURAL \n// Comment out the above line to use a faster LUT for noise and dithering\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n\n#ifdef USE_PROCEDURAL\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nfloat dither(in vec2 pixel)\n{\n   return .05*noise( vec3(1000.*pixel.xy/iChannelResolution[0].x,0.) ); \n}\n#else\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv+0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\nfloat dither(in vec2 pixel)\n{\n    return 0.05*texture( iChannel0, pixel.xy/iChannelResolution[0].x ).x;\n}\n#endif\n\n// Cloud noise by iq: https://www.shadertoy.com/view/XslGRr\n// takes a input position + and offset vector and returns a density amount\n// derived by summing multiple layers of noise at varying strengths and scales\nfloat cloudNoise(float scale,in vec3 p, in vec3 dir)\n{\n\tvec3 q = p + dir; \n    float f;\n\tf  = 0.50000*noise( q ); q = q*scale*2.02 + dir;\n    f += 0.25000*noise( q ); q = q*2.03 + dir;\n    f += 0.12500*noise( q ); q = q*2.01 + dir;\n    f += 0.06250*noise( q ); q = q*2.02 + dir;\n    f += 0.03125*noise( q );\n    return f;\n}\n\n// distance functions from  https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\n\nfloat map( vec3 p )\n{\n\tfloat f = cloudNoise(2.,p,-vec3(0.0,0.25,.125)*iTime);\n\tfloat den = sdBox(p,vec3(1.));\n//    float den = sdTorus(p,vec2(1.2,.35)); //uncomment to use a torus instead\n    den = smoothstep(-0.1,.25,den);\n\tden = -den-(sin(iTime*.3)+1.)*.3;\n\treturn clamp( den +1.5* f, 0.0, 1.0 );\n}\n\nvec3 raymarch( in vec3 ro, in vec3 rd, in vec2 pixel )\n{\n\tvec4 sum = vec4( 0.0 );\n\n\tfloat t=dither(pixel);\n\t\n\tfor( int i=0; i<100; i++ )\n\t{\n\t\tif( sum.a > 0.99 ) break;\n\t\t\n\t\tvec3 pos = ro + t*rd;\n        float d= map( pos );\n\t\tvec4 col = vec4(mix( vec3(1.0,1.0,1.23), vec3(0.1,0.0,0.10), d ),1.);\n\n\t\tcol *= d*3.;\n\n\t\tsum +=  col*(1.0 - sum.a);\t\n\n\t\tt += 0.05;\n\t}\n\n\treturn clamp( sum.xyz, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/ iResolution.y;\n\t\n    vec2 mo = iMouse.xy / iResolution.xy;\n  float rot =3.0*mo.x+iTime*.2;\n\t\n    // camera\n\tvec3 ro = 4.0*normalize(vec3(cos(rot), .5+(mo.y), sin(rot)));\n\tvec3 ta = vec3(0.0);\n\t\n\t\n\t// build ray\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\t\n    // raymarch\t\n\tvec3 col = raymarch( ro, rd, fragCoord );\n\n\n    fragColor = vec4( col, 1.0 );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}