{
    "Shader": {
        "info": {
            "date": "1484261811",
            "description": "Version of https://www.shadertoy.com/view/4tVGWR using Bayer16 Dither pattern from https://www.shadertoy.com/view/4tGGWW , Also attempted to reduce temporal ghosting this time. ** Hold left mouse button to see single frame quality. ** Suggestions welcome!",
            "flags": 32,
            "hasliked": 0,
            "id": "XlVSWh",
            "likes": 32,
            "name": "Temporal Resolve Pathtracer 2",
            "published": 3,
            "tags": [
                "pathtracer",
                "dithering",
                "temporal"
            ],
            "usePreview": 0,
            "username": "granito",
            "viewed": 1837
        },
        "renderpass": [
            {
                "code": "lowp vec3 ACESFilm( vec3 x )\n{\n    x *= 0.6; \n    lowp float a = 2.51;\n    lowp float b = 0.03;\n    lowp float c = 2.43;\n    lowp float d = 0.59;\n    lowp float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);\n}\n\nfloat grayscale(vec3 image) {\n    return dot(image, vec3(0.3, 0.59, 0.11));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tlowp vec2 uv = fragCoord.xy / iResolution.xy;\n\n    lowp vec3 result = texture(iChannel0,uv).rgb;    \n    lowp vec3 aframe = texture(iChannel1,uv).rgb;\n    \n    if (iMouse.z > 0.5) result = aframe;\n\n    result = ACESFilm(result);\n\n\tfragColor = vec4(result,1.);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Hacked by Lucas Granito 2016 https://www.shadertoy.com/view/XlVSWh\n\n// Simple path tracer. Created by Reinder Nijhoff 2014\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/4tl3z4\n//\n\n#define SPEED 1.0\n#define eps 0.1\n#define EYEPATHLENGTH 5\n#define SAMPLES 10\n#define FULLBOX\n#define LIGHTCOLOR vec3(16.86, 10.76, 8.2)*100.\n#define WHITECOLOR vec3(.7295, .7355, .729)*0.7\n\nfloat seed;\n\nlowp float hash1() {\n    return fract(sin(seed += 0.1)*43758.5453123);\n}\n\nlowp vec2 hash2() {\n    return fract(sin(vec2(seed+=0.1,seed+=0.1))*vec2(43758.5453123,22578.1459123));\n}\n\nlowp vec3 hash3() {\n    return fract(sin(vec3(seed+=0.1,seed+=0.1,seed+=0.1))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\nfloat B2( vec2 _P ) {\n//    return ((_P.y << 1) + _P.x + 1) & 3;    <= This would fare much better than modulos and floors :(\n    return mod( 2.0*_P.y + _P.x + 1.0, 4.0 );\n}\n\n// Generates the 16x16 matrix\nfloat B16( vec2 _P ) {\n    vec2    P1 = mod( _P, 2.0 );                    // (P >> 0) & 1\n    vec2    P2 = floor( 0.5 * mod( _P, 4.0 ) );        // (P >> 1) & 1\n    vec2    P4 = floor( 0.25 * mod( _P, 8.0 ) );    // (P >> 2) & 1\n    vec2    P8 = floor( 0.125 * mod( _P, 16.0 ) );    // (P >> 3) & 1\n    return 4.0*(4.0*(4.0*B2(P1) + B2(P2)) + B2(P4)) + B2(P8);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//-----------------------------------------------------\n// Intersection functions (by iq)\n//-----------------------------------------------------\n\nlowp vec3 nSphere( in vec3 pos, in vec4 sph ) {\n    return (pos-sph.xyz)/sph.w;\n}\n\nlowp float iSphere( in vec3 ro, in vec3 rd, in vec4 sph ) {\n    lowp vec3 oc = ro - sph.xyz;\n    lowp float b = dot(oc, rd);\n    lowp float c = dot(oc, oc) - sph.w * sph.w;\n    lowp float h = b * b - c;\n    if (h < 0.0) return -1.0;\n\n\tlowp float s = sqrt(h);\n\tlowp float t1 = -b - s;\n\tlowp float t2 = -b + s;\n\t\n\treturn t1 < 0.0 ? t2 : t1;\n}\n\nvec3 nPlane( in vec3 ro, in vec4 obj ) {\n    return obj.xyz;\n}\n\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 pla ) {\n    return (-pla.w - dot(pla.xyz,ro)) / dot( pla.xyz, rd );\n}\n\n//-----------------------------------------------------\n// scene\n//-----------------------------------------------------\n\nvec3 cosWeightedRandomHemisphereDirection( const vec3 n ) {\n  \tlowp vec2 r = hash2();\n    \n\tlowp vec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );\n\tlowp vec3  vv = cross( uu, n );\n\t\n\tlowp float ra = sqrt(r.y);\n\tlowp float rx = ra*cos(6.2831*r.x); \n\tlowp float ry = ra*sin(6.2831*r.x);\n\tlowp float rz = sqrt( 1.0-r.y );\n\tlowp vec3  rr = vec3( rx*uu + ry*vv + rz*n );\n    \n    return normalize( rr );\n}\n\nvec3 randomSphereDirection() {\n    lowp vec2 r = hash2()*6.2831;\n\tlowp vec3 dr=vec3(sin(r.x)*vec2(sin(r.y),cos(r.y)),cos(r.x));\n\treturn dr;\n}\n\nvec3 randomHemisphereDirection( const vec3 n ) {\n\tlowp vec3 dr = randomSphereDirection();\n\treturn dot(dr,n) * dr;\n}\n\n//-----------------------------------------------------\n// light\n//-----------------------------------------------------\n\nlowp vec4 lightSphere;\n\nvoid initLightSphere( float time ) {\n\tlightSphere = vec4( 3.0+2.*sin(time),2.8+2.*sin(time*0.9),3.0+4.*cos(time*0.7), .1 );\n}\n\nlowp vec3 sampleLight( const in vec3 ro ) {\n    lowp vec3 n = randomSphereDirection() * lightSphere.w;\n    return lightSphere.xyz + n;\n}\n\n//-----------------------------------------------------\n// scene\n//-----------------------------------------------------\n\n#define bounce (pow( abs( sin( iTime * 1.5 *SPEED ) * 2.), 0.5) * 1.5 + 0.5)\n#define bounce2 (pow( abs( sin( iTime * 2.  *SPEED ) * 2.), 0.5) + 0.5)\n\nlowp vec2 intersect( in vec3 ro, in vec3 rd, inout vec3 normal ) {\n\tlowp vec2 res = vec2( 1e20, -1.0 );\n    lowp float t;\n\t\n\tt = iPlane( ro, rd, vec4( 0.0, 1.0, 0.0,0.0 ) ); if( t>eps && t<res.x ) { res = vec2( t, 1. ); normal = vec3( 0., 1., 0.); }\n\tt = iPlane( ro, rd, vec4( 0.0, 0.0,-1.0,8.0 ) ); if( t>eps && t<res.x ) { res = vec2( t, 1. ); normal = vec3( 0., 0.,-1.); }\n    t = iPlane( ro, rd, vec4( 1.0, 0.0, 0.0,0.0 ) ); if( t>eps && t<res.x ) { res = vec2( t, 2. ); normal = vec3( 1., 0., 0.); }\n#ifdef FULLBOX\n    t = iPlane( ro, rd, vec4( 0.0,-1.0, 0.0,5.49) ); if( t>eps && t<res.x ) { res = vec2( t, 1. ); normal = vec3( 0., -1., 0.); }\n    t = iPlane( ro, rd, vec4(-1.0, 0.0, 0.0,5.59) ); if( t>eps && t<res.x ) { res = vec2( t, 3. ); normal = vec3(-1., 0., 0.); }\n#endif\n\n\tt = iSphere( ro, rd, vec4( 1.5,0.5 + bounce, 2.7, 1.0) ); if( t>eps && t<res.x ) { res = vec2( t, 1. ); normal = nSphere( ro+t*rd, vec4( 1.5,0.5 + bounce, 2.7,1.0) ); }\n    t = iSphere( ro, rd, vec4( 4.0,0.5 + bounce2, 4.0, 1.0) ); if( t>eps && t<res.x ) { res = vec2( t, 5. ); normal = nSphere( ro+t*rd, vec4( 4.0,0.5 + bounce2, 4.0,1.0) ); }\n    t = iSphere( ro, rd, lightSphere ); if( t>eps && t<res.x ) { res = vec2( t, 0.0 );  normal = nSphere( ro+t*rd, lightSphere ); }\n\t\t\t\t\t  \n    return res;\t\t\t\t\t  \n}\n\nbool intersectShadow( in vec3 ro, in vec3 rd, in float dist ) {\n    lowp float t;\n\t\n\tt = iSphere( ro, rd, vec4( 1.5,0.5 + bounce, 2.7,1.0) );  if( t>eps && t<dist ) { return true; }\n    t = iSphere( ro, rd, vec4( 4.0,0.5 + bounce2, 4.0,1.0) );  if( t>eps && t<dist ) { return true; }\n\n    return false; // optimisation: planes don't cast shadows in this scene\n}\n\n//-----------------------------------------------------\n// materials\n//-----------------------------------------------------\n\nlowp vec3 matColor( const in float mat ) {\n\tlowp vec3 nor = vec3(1., 1., 1.);\n\t\n\tif( mat<3.5 ) nor = hsv2rgb(vec3(iTime * 0.025,0.8,0.6));\n    if( mat<2.5 ) nor = hsv2rgb(vec3(iTime * 0.015 + 0.3,0.9,0.6));\n\tif( mat<1.5 ) nor = WHITECOLOR;\n\tif( mat<0.5 ) nor = LIGHTCOLOR;\n\t\t\t\t\t  \n    return nor;\t\t\t\t\t  \n}\n\nbool matIsSpecular( const in float mat ) {\n    return mat > 4.5;\n}\n\nbool matIsLight( const in float mat ) {\n    return mat < 0.5;\n}\n\n//-----------------------------------------------------\n// brdf\n//-----------------------------------------------------\n\nlowp vec3 getBRDFRay( in vec3 n, const in vec3 rd, const in float m, inout bool specularBounce ) {\n    specularBounce = false;\n    \n    lowp vec3 r = cosWeightedRandomHemisphereDirection( n );\n    if(  !matIsSpecular( m ) ) {\n        return r;\n    } else {\n        specularBounce = true;\n        \n        lowp float n1, n2, ndotr = dot(rd,n);\n        \n        if( ndotr > 0. ) {\n            n1 = 1.0; \n            n2 = 1.5;\n            n = -n;\n        } else {\n            n1 = 1.5;\n            n2 = 1.0; \n        }\n\n        lowp float r0 = (n1-n2)/(n1+n2); r0 *= r0;\n\n\t\tlowp float fresnel = r0 + (1.-r0) * pow(1.0-abs(ndotr),2.);\n        \n        lowp vec3 ref;\n        \n        ref = reflect( rd, n );\n        \n        return normalize( ref + 0.1 * hash1() * r );\n\t}\n}\n\n//-----------------------------------------------------\n// eyepath\n//-----------------------------------------------------\n\nlowp vec3 traceEyePath( in vec3 ro, in vec3 rd, const in bool directLightSampling ) {\n    lowp vec3 tcol = vec3(0.);\n    lowp vec3 fcol  = vec3(1.);\n    \n    bool specularBounce = true;\n    \n    for( int j=0; j<EYEPATHLENGTH; ++j ) {\n        lowp vec3 normal;\n        \n        lowp vec2 res = intersect( ro, rd, normal );\n        if( res.y < -0.5 ) {\n            return tcol;\n        }\n        \n        if( matIsLight( res.y ) ) {\n            if( directLightSampling ) {\n            \tif( specularBounce ) tcol += fcol*LIGHTCOLOR;\n            } else {\n                tcol += fcol*LIGHTCOLOR;\n            }\n\n            return tcol;\n        }\n        \n        ro = ro + res.x * rd;\n        \n        rd = getBRDFRay( normal, rd, res.y, specularBounce );        \n        \n        fcol *= matColor( res.y );\n\n        lowp vec3 ld = sampleLight( ro ) - ro;\n        \n        if( directLightSampling ) {\n\t\t\tlowp vec3 nld = normalize(ld);\n            if( !specularBounce && j < EYEPATHLENGTH-1 && !intersectShadow( ro, nld, length(ld)) ) {\n\n                lowp float cos_a_max = sqrt(1. - clamp(lightSphere.w * lightSphere.w / dot(lightSphere.xyz-ro, lightSphere.xyz-ro), 0., 1.));\n                lowp float weight = 2. * (1. - cos_a_max);\n\n                tcol += (fcol * LIGHTCOLOR) * (weight * clamp(dot( nld, normal ), 0., 1.));\n            }\n        }\n    }    \n    return tcol;\n}\n\n//-----------------------------------------------------\n// main\n//-----------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    \n    lowp float splitCoord = (iMouse.x == 0.0) ? iResolution.x/2. + iResolution.x*cos(iTime*.5) : iMouse.x;\n    bool directLightSampling = true;\n    \n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n\n    lowp vec2 p = -1.0 + 2.0 * (fragCoord.xy) / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y; \n\n    seed = B16(fragCoord.xy ); // jitter dither pattern offset\n    seed = seed * 3.43121412313 + fract(1.12345314312*iTime);\n    \n    lowp vec3 ro = vec3(2.78, 2.73, -8.00);\n    lowp vec3 ta = vec3(2.78, 2.73,  0.00);\n    lowp vec3 ww = normalize( ta - ro );\n    lowp vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    lowp vec3 vv = normalize( cross(uu,ww));\n\n    //-----------------------------------------------------\n    // render\n    //-----------------------------------------------------\n\n    lowp vec3 col = vec3(0.0);\n    lowp vec3 tot = vec3(0.0);\n    lowp vec3 uvw = vec3(0.0);\n    \n    for( int a=0; a<SAMPLES; a++ ) {\n\n        lowp vec2 rpof;\n\n\t    lowp vec3 rd = normalize( (p.x+rpof.x)*uu + (p.y+rpof.y)*vv + 3.0*ww );\n        \n        lowp vec3 rof = ro;\n\n        initLightSphere( iTime * SPEED * 2.0);        \n\n        col = traceEyePath( rof, rd, directLightSampling );\n\n        tot += col;\n        \n        seed = mod( seed*1.1234567893490423, 13. );\n    }\n    \n    tot /= float(SAMPLES);\n    \n\ttot = pow( tot, vec3(0.45) );\n\n    fragColor = vec4( tot, 1.0 );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Temporal sampling\n\nfloat grayscale(vec3 image) {\n    return dot(image, vec3(0.3, 0.59, 0.11));\n}\n\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  lowp vec2 uv = fragCoord.xy / iResolution.xy;\n\n    \n  lowp vec3 imageacc = max( texture(iChannel1,uv).rgb , vec3(0.0));\n  lowp vec3 image = max( texture(iChannel0,uv).rgb , vec3(0.0));  \n\n    //declare stuff\n    const int mSize = 9;\n    const int kSize = (mSize-1)/2 ;\n    float kernel[mSize];\n    vec3 imageblurred = vec3(0.0);\n\n    //create the 1-D kernel\n    float sigma = 1.5;\n    float Z = 0.0;\n    for (int j = 0; j <= kSize; ++j)\n    {\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n\n    //get the normalization factor (as the gaussian has been clamped)\n    for (int j = 0; j < mSize; ++j)\n    {\n        Z += kernel[j];\n    }\n\n    //read out the texels\n    for (int i=-kSize; i <= kSize; ++i)\n    {\n        for (int j=-kSize; j <= kSize; ++j)\n        {\n            imageblurred += kernel[kSize+j]*kernel[kSize+i]*texture(iChannel0, (fragCoord.xy+vec2(float(i),float(j))) / iResolution.xy).rgb;\n\n        }\n    }   \n    \n    imageblurred = imageblurred / (Z*Z);  \n    \n    image = min(image, imageblurred); // reduce fireflies    \n\n    if (iMouse.z < 0.5) \n    {\n        // attempt to reduce ghosting\n        lowp float weight = grayscale( pow( clamp( abs(imageacc - image) * 0.3 , 0., 1.), vec3(0.5)));\n        imageacc = mix(imageacc, image, clamp(weight + 0.1, 0., 1.));\n    } else { \n\n        imageacc = image;\n    }\n    \n    fragColor = vec4(imageacc,1.0);\n\n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}