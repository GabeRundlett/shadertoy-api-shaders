{
    "Shader": {
        "info": {
            "date": "1692382183",
            "description": "Same code as Inigo Quilez's cylinder, but added comments. Original comment:\nIntersection of a ray and a generic (oriented in any direction) capped cylinder. See capsule here: [url]https://www.shadertoy.com/view/Xt3SzX[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "ml2cWc",
            "likes": 2,
            "name": "(fork) Cylinder - With Comments",
            "published": 3,
            "tags": [
                "3d",
                "raycasting"
            ],
            "usePreview": 0,
            "username": "MattOstgard",
            "viewed": 147
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright Â© 2016 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Intersection of a ray and a capped cylinder oriented in an arbitrary direction\n//\n// List of ray-surface intersectors at https://www.shadertoy.com/playlist/l3dXRf\n//\n// and https://iquilezles.org/articles/intersectors\n//\n// Other cylinder functions:\n//   Cylinder intersection: https://www.shadertoy.com/view/4lcSRn\n//   Cylinder bounding box: https://www.shadertoy.com/view/MtcXRf\n//   Cylinder distance:     https://www.shadertoy.com/view/wdXGDr\n\n\n// Intersection of a ray and a capped cylinder oriented in an arbitrary direction.\n//\n// Arguments:\n//     - ro: The origin of the ray being cast.\n//     - rd: The direction of the ray being cast.\n//     - pa: One endpoint of the cylinder's axis.\n//     - pb: The other endpoint of the cylinder's axis.\n//     - ra: Cylinder's radius.\n//\n// Returns vec4:\n//     - x: -1 if no hit, otherwise the distance from the ray to the hit point.\n//     - yzw: Hit surface's normal.\nvec4 iCylinder( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, float ra ) \n{\n    // Vector from point A to point B, defining the cylinder's main axis\n    vec3  ba = pb - pa;\n    // Vector from ray origin (ro) to point A on the cylinder\n    vec3  oc = ro - pa;\n    \n    // Dot product of ba with itself, representing the squared length of the cylinder's axis\n    float baba = dot(ba,ba);\n    // Dot product of ba with ray direction (rd), representing alignment of ray with cylinder's axis\n    float bard = dot(ba,rd);\n    // Dot product of ba with oc, representing alignment of the cylinder's axis with the vector to the ray origin\n    float baoc = dot(ba,oc);\n    \n    // Quadratic coefficients for solving ray-cylinder intersection\n    float k2 = baba            - bard*bard;\n    float k1 = baba*dot(oc,rd) - baoc*bard;\n    float k0 = baba*dot(oc,oc) - baoc*baoc - ra*ra*baba;\n    \n    /*\n    // In case you really need to handle parallel raycasts.\n    if( k2==0.0 )\n    {\n        // Handle the case where the ray is parallel to the cylinder's axis.\n\n        // If this special case is detected (i.e., k2 == 0.0), calculate intersections with the two endpoints of the\n        // cylinder and verify that the intersection is within the cylinder's radius. If so, it returns the intersection\n        // point and surface normal information. If not, it returns -1.0, indicating no intersection.\n        \n        // Parameters for intersection with the two endpoints of the cylinder.\n        float ta = -dot(ro-pa,ba)/bard;\n        float tb = ta + baba/bard;\n        \n        // Determining the intersection point based on ray direction.\n        vec4 pt = (bard>0.0) ? vec4(pa,-ta) : vec4(pb,tb);\n        \n        // Calculating the offset from the intersection point to determine if the intersection is within the cylinder's radius.\n        vec3 q = ro + rd*abs(pt.w) - pt.xyz;\n        if( dot(q,q)>ra*ra ) return vec4(-1.0);\n        \n        // Returning the intersection point and surface normal information.\n        return vec4( abs(pt.w), sign(pt.w)*ba/sqrt(baba) );\n    }\n    */\n    \n    // Discriminant of the quadratic equation; determines whether there is an intersection.\n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return vec4(-1.0); // No intersection.\n    h = sqrt(h);\n    float t = (-k1-h)/k2; // The \"t\" value where the intersection occurs.\n    \n    // Checking intersection with the body of the cylinder.\n    float y = baoc + t*bard;\n    if( y>0.0 && y<baba ) return vec4( t, (oc+t*rd - ba*y/baba)/ra );\n    \n    // Checking intersection with the end caps of the cylinder.\n    t = ( ((y<0.0) ? 0.0 : baba) - baoc)/bard;\n    if( abs(k1+k2*t)<h ) return vec4( t, ba*sign(y)/sqrt(baba) );\n    \n    return vec4(-1.0); // No intersection.\n}\n\n\n// Get the normal of a cylinder's body from a point on the surface.\n//\n// Arguments:\n//     - p: Point on the cylinder body.\n//     - 'a' and 'b': Points along the axis of the cylinder, defining its direction.\n//     - 'ra': The radius of the cylinder.\n//\n// Returns the cylinder body's normal.\n//\nvec3 nCylinder( in vec3 p, in vec3 a, in vec3 b, in float ra )\n{\n    // 'pa' is the vector from point 'a' to the point 'p' where we want to find the normal.\n    vec3  pa = p - a;\n\n    // 'ba' is the vector from point 'a' to point 'b', defining the direction of the cylinder's axis.\n    vec3  ba = b - a;\n\n    // 'baba' is the squared length of vector 'ba', used to normalize 'ba'.\n    float baba = dot(ba,ba);\n\n    // 'paba' is the projection of 'pa' onto 'ba', giving us the portion of 'pa' that is parallel to the cylinder's axis.\n    float paba = dot(pa,ba);\n\n    // Subtracting the projected vector (ba * paba / baba) from 'pa' gives us the vector perpendicular to the axis, \n    // pointing towards the surface of the cylinder from 'p'. Dividing by 'ra' scales it to the normal direction.\n    return (pa - ba*paba/baba)/ra;\n}\n\n\n// Same as above, but specialized to the Y axis.\n//\n// Arguments:\n//     - ro: The origin of the ray being cast.\n//     - rd: The direction of the ray being cast.\n//     - he: Cylinder's height.\n//     - ra: Cylinder's radius.\n//\n// Returns vec4:\n//     - x: -1 if no hit, otherwise the distance from the ray to the hit point.\n//     - yzw: Hit surface's normal.\n//\nvec4 iCylinderVertical( in vec3 ro, in vec3 rd, float he, float ra )\n{\n    // Quadratic coefficients for ray-cylinder intersection with a vertical axis.\n    float k2 = 1.0        - rd.y*rd.y;\n    float k1 = dot(ro,rd) - ro.y*rd.y;\n    float k0 = dot(ro,ro) - ro.y*ro.y - ra*ra;\n\n    // Discriminant of the quadratic equation; determines whether there is an intersection.\n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return vec4(-1.0); // No intersection.\n    h = sqrt(h);\n    float t = (-k1-h)/k2;\n\n    // Checking intersection with the body of the cylinder.\n    float y = ro.y + t*rd.y;\n    if( y>-he && y<he ) return vec4( t, (ro + t*rd - vec3(0.0,y,0.0))/ra );\n\n    // Checking intersection with the end caps of the cylinder.\n    t = ( ((y<0.0)?-he:he) - ro.y)/rd.y;\n    if( abs(k1+k2*t)<h ) return vec4( t, vec3(0.0,sign(y),0.0) );\n\n    return vec4(-1.0); // No intersection\n}\n\n// Generate a pattern (grid-like) based on the given UV coordinates.\nvec3 pattern( in vec2 uv )\n{\n    vec3 col = vec3(0.6);\n    col += 0.4*smoothstep(-0.01,0.01,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Define camera rotation and position.\n    float an = 0.5*iTime;\n    vec3 ro = vec3( 1.0*cos(an), 0.4, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    \n    // Create camera's orthonormal basis (u,v,w).\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    vec3 tot = vec3(0.0);\n\n    // Anti-aliasing loop (if AA > 1).\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // Subpixel sampling.\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n        // Create view ray.\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // Define cylinder.\n        const vec3  capA = vec3(-0.3,-0.1,-0.1);\n        const vec3  capB = vec3(0.3,0.1,0.4);\n        const float capR = 0.2;\n\n        // Initialize background color.\n        vec3 col = vec3(0.08)*(1.0-0.3*length(p)) + 0.02*rd.y;\n\n        // Cylinder-ray intersection.\n        vec4 tnor = iCylinder( ro, rd, capA, capB, capR );\n        if( tnor.x>0.0 )\n        {\n            // Compute shading, texture, and lighting if intersection occurred.\n\n            // SHADING\n            // Calculating the position and normal at the intersection.\n            float t = tnor.x;\n            vec3  pos = ro + t*rd;\n            vec3  nor = tnor.yzw;\n\n            // LIGHTING\n            // Define the light direction and halfway vector.\n            vec3  lig = normalize(vec3(0.7,0.6,0.3));\n            vec3  hal = normalize(-rd+lig);\n\n            // Calculate the diffuse and ambient components using dot products.\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 ); // Diffuse lighting\n            float amb = clamp( 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0)), 0.0, 1.0 ); // Ambient lighting\n            float occ = 0.5 + 0.5*nor.y; // Occlusion factor, contributes to ambient shading\n\n            // TEXTURING\n            // Coordinate transformation for texture mapping on the cylinder.\n            vec3 w = normalize(capB-capA);\n            vec3 u = normalize(cross(w,vec3(0,0,1)));\n            vec3 v = normalize(cross(u,w) );\n            vec3 q = (pos-capA)*mat3(u,v,w);\n            col = pattern( vec2(12.0,64.0)*vec2(atan(q.y,q.x),q.z) ); // Apply texture pattern.\n\n            // Combine shading, texturing, and lighting\n            col *= vec3(0.2,0.3,0.4)*amb*occ + vec3(1.0,0.9,0.7)*dif; // Apply ambient and diffuse components.\n            col += 0.4*pow(clamp(dot(hal,nor),0.0,1.0),12.0)*dif; // Apply specular reflection.\n        }\n        col = sqrt( col );\n\n        // Accumulate color.\n        tot += col;\n    #if AA>1\n    }\n    // Average color for anti-aliasing.\n    tot /= float(AA*AA);\n    #endif\n\n    // Add dithering to remove banding in the background.\n    tot += fract(sin(fragCoord.x*vec3(13,1,11)+fragCoord.y*vec3(1,7,5))*158.391832)/255.0;\n\n    // Output final color.\n    fragColor = vec4( tot, 1.0 );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}