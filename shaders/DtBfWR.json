{
    "Shader": {
        "info": {
            "date": "1694024110",
            "description": "All year long I'm going to just focus on truchet tiles and the likes!\n\ninspired by : https://twitter.com/BlockRoni/status/1688260517767315457\n",
            "flags": 0,
            "hasliked": 0,
            "id": "DtBfWR",
            "likes": 21,
            "name": "Year of Truchets #053",
            "published": 3,
            "tags": [
                "truchet",
                "multiscale",
                "quadtree",
                "recreation"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 212
        },
        "renderpass": [
            {
                "code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #053\n    09/06/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n    see all https://www.shadertoy.com/user/byt3_m3chanic/sort=newest\n    \n*/\n\n#define R          iResolution\n#define M          iMouse\n#define T          iTime\n#define PI         3.14159265359\n#define PI2        6.28318530718\n\n// @Shane 2/2 hash.\nvec2 hash22(vec2 p) { float n = sin(dot(p,vec2(57,27)));return fract(vec2(272144,32768)*n);}\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\n//@iq hsv2rgb palettes & box\nvec3 hsv(vec3 c) {\n    vec3 rgb = clamp( abs(mod(c.x*6.+vec3(0,4,2),6.)-3.)-1.,0.,1.);\n    return c.z * mix( vec3(1),rgb,c.y);\n}\nfloat box( vec2 p, vec2 b){ vec2 d = abs(p)-b; return length(max(d,0.)) + min(max(d.x,d.y),0.);}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n\n    vec3 C = vec3(.095);\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    \n    uv +=T*vec2(.08,.05);\n    uv*= R.x<1300.? 2.25 : 3.5;\n    \n    vec2 vuv = uv;\n    \n    // threshold values\n    const vec2 rndX[4]=vec2[4]( vec2(.5, .45), vec2(.5, .25), vec2(.5, .75), vec2(.5, 1));\n\n    // distance field values.\n    vec4 d=vec4(1e5), s=vec4(1e5), b=vec4(1e5);\n    // hash values\n    vec4 hd=vec4(1e5), hs=vec4(1e5), hb=vec4(1e5);\n    float level=1.;\n         \n    // Main loop and neighbor checking from @Shane's shader.\n    // https://www.shadertoy.com/view/4t3BW4\n        \n    for(int k=0; k<4; k++){\n        vec2 id = floor(vuv*level);\n        float frnd = hash22(id).x;\n        for(int j=-1; j<=1; j++){\n            for(int i=-1; i<=1; i++){\n            \n                // neighboring cell ID.\n                vec2 neighbors = vec2(i,j);\n                vec2 home = id+neighbors;\n                vec2 rnd = hash22(home);\n                \n                // neighboring cell hash values.\n                vec2 rnd2 = hash22(floor(home/2.));\n                vec2 rnd4 = hash22(floor(home/4.));\n                vec2 rnd8 = hash22(floor(home/8.));\n\n                // If the previous large tile has been rendered, continue.\n                if(k==1 && rnd2.y<rndX[0].y) continue;\n                // If any of the two previous larger tiles have been rendered, continue.\n                if(k==2 && (rnd2.y<rndX[1].y || rnd4.y<rndX[0].y)) continue;\n                // If any of the three previous larger tiles have been rendered, continue.\n                if(k==3 && (rnd2.y<rndX[2].y || rnd4.y<rndX[1].y  || rnd8.y<rndX[0].y )) continue;\n\n                // threshold\n                if(rnd.y<rndX[k].y) {\n     \n                    vec2 p = vuv -(id+.5+neighbors)/level;\n                    if(rnd.x<rndX[k].x) p.x = -p.x;\n  \n                    float bx = (.43-(level*.015))/level;\n                    float square = box(p,vec2(bx))-(.075/level);\n\n                    float tk = k<3?.1/level:.075/level;\n                    float hf = .50/level;\n                    float qf = .25/level;\n                    float mf = .05/level;\n                    \n                    vec2 pv = length(p-vec2(hf,-hf))<length(p+vec2(hf,-hf))? p-vec2(hf,-hf):p+vec2(hf,-hf);\n   \n                    float cd = abs(length(pv)-hf)-tk;\n                    if(rnd.x>.8) cd = min(length(p.x)-tk,length(p.y)-tk);\n                    \n                    float bd = length(abs(p)-hf)-qf;\n                    \n                    float fk = float(k);\n                    float trnd = fract(fk+rnd.x*43.72);\n                    \n                    if(trnd>.7) cd=abs(cd)-mf;\n                    if(trnd<.15) cd=abs(abs(cd)-mf)-(.025/level);\n                    \n                    cd = max(square,cd);\n                    bd = max(square,bd);\n                    \n                    s[k] = min(s[k], square);\n                    d[k] = min(d[k], cd);\n                    b[k] = min(b[k], bd);\n                    \n                    hd[k] = fract((trnd*53.1)+rnd.x+frnd);\n                    hs[k] = fract((rnd2.y+trnd+rnd.x+frnd)*47.3);\n                    hb[k] = fract(rnd2.x*19.7+rnd.x+frnd);\n                }\n            }\n        }    \n        \n        level*=2.;\n    }\n    \n    float px = fwidth(vuv.x);\n    float ft = .4+T*.1;\n    \n    for(int k=0; k<4; k++){\n        C = mix(C,C*.5,smoothstep(.01+px,-px,s[k]-.0005));\n        \n        vec3 ca = hsv(vec3((ft+hs[k])*.15,1.,.5));\n        vec3 cb = hsv(vec3((ft+hd[k])*.35,1.,.6));\n        vec3 cc = hsv(vec3((ft+hb[k])*.25,1.,.3));\n\n        C = mix(C,ca,smoothstep(px,-px,s[k]));\n        if(k<3) C = mix(C,cc,smoothstep(px,-px,b[k]));\n        C = mix(C,cb,smoothstep(px,-px,d[k]));\n        \n        C = mix(C,vec3(.05),smoothstep(px,-px,abs(s[k])-.0025));\n    }\n\n    // Output to screen\n    C = pow(C,vec3(.4545));\n    O = vec4(C,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}