{
    "Shader": {
        "info": {
            "date": "1672345099",
            "description": "2D Non-Euclidean Particles with Almost-Newtonian Physics.\nIf the sim is unstable, increase the DAMPING in the Buffer A shader.\n\nInteraction: \n- Hold LMB to attract particles to the mouse.\n- Hold Left Shift to increase DAMPING and decrease G.",
            "flags": 48,
            "hasliked": 0,
            "id": "DllGzX",
            "likes": 16,
            "name": "The N-Body Problem",
            "published": 3,
            "tags": [
                "2d",
                "particles",
                "physics",
                "nbody"
            ],
            "usePreview": 0,
            "username": "Yetman",
            "viewed": 426
        },
        "renderpass": [
            {
                "code": "#define PARTICLE_MAX_SIZE 10.0\n#define PARTICLE_MIN_SIZE 2.0\n#define VORONOI_EXP 4.0\n#define VORONOI_AMOUNT 0.08\n#define BG_COLOR vec3(0.01, 0.00, 0.02)\n\n// Source: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float particle_size_base = max(iResolution.x, iResolution.y) / 640.0;\n\n    vec3 color = vec3(0.0);\n    vec3 voronoi_num = vec3(0.0);\n    float voronoi_den = 0.0;\n    \n    for(int idx = 0; idx < PARTICLE_COUNT; idx++){\n        vec2 position = decode(texelFetch(iChannel0, ivec2(idx, T_POS), 0)) * iResolution.xy;\n        vec2 delta = abs(position-fragCoord);\n        delta = min(delta, iResolution.xy - delta);\n        float d_sqr = dot(delta, delta);\n        \n        vec4 color_size = texelFetch(iChannel0, ivec2(idx, T_COL), 0);\n        float radius = mix(PARTICLE_MIN_SIZE, PARTICLE_MAX_SIZE, color_size.w) * particle_size_base;\n        float intensity = smoothstep(radius * radius, 0.0, d_sqr);\n        color += color_size.rgb * intensity;\n        \n        float voronoi_factor = 1.0 / max(0.01, pow(d_sqr / (particle_size_base * particle_size_base), VORONOI_EXP));\n        voronoi_num += color_size.rgb * voronoi_factor;\n        voronoi_den += voronoi_factor;\n    }\n    vec3 voronoi = voronoi_num / voronoi_den;\n    color += voronoi * VORONOI_AMOUNT + BG_COLOR;\n\n    // Output to screen\n    fragColor = vec4(ACESFilm(color), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define G 0.001\n#define MOUSE_G 0.05\n#define DAMPING 0.05\n#define INITIAL_VEL 0.2\n#define MAX_VEL 1.0\n#define COLOR_TINT vec3(1.0, 0.5, 0.25)\n\n// G and Damping applied when Left-Shift is pressed.\n#define SHIFT_G 0.00001\n#define SHIFT_DAMPING 0.5\n\nvec2 to_v(vec2 v) { return MAX_VEL * (2.0 * v - 1.0); }\nvec2 from_v(vec2 v) { return (v * (1.0 / MAX_VEL) + 1.0) * 0.5; }\n\nvec4 noise(int p){\n    int w = int(iChannelResolution[1].x);\n    return texelFetch(iChannel1, ivec2(p%w, p/w), 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n        \n    int type = int(fragCoord.y), index = int(fragCoord.x);\n    \n    float delta_time = min(1.0/30.0, iTimeDelta);\n    int rand_offset = int(iDate.w)%1024;\n    \n    bool ini = texelFetch(iChannel0, ivec2(T_INI, 0), 0).a == 0.0;\n    \n    \n    if(index < PARTICLE_COUNT){\n        if(type == T_INI){\n            fragColor = noise(0);\n        }\n        else if(type == T_POS) {\n        \n            // Initialization Frame\n            if(ini){\n                vec2 p = decode(noise(index + rand_offset));\n                p = mix(sqrt(p), p*p, p);\n                fragColor = encode(p);\n            } \n            // Update Frame\n            else {\n                vec2 p = decode(texelFetch(iChannel0, ivec2(index, T_POS), 0));\n                vec2 v = to_v(decode(texelFetch(iChannel0, ivec2(index, T_VEL), 0)));\n                p += v * delta_time;\n                p = fract(p);\n                fragColor = encode(p);\n            }\n        } \n        \n        else if(type == T_VEL) {\n        \n            // Initialization Frame\n            if(ini){\n                vec2 v = INITIAL_VEL * (2.0 * decode(noise(index + rand_offset + PARTICLE_COUNT)) - 1.0);\n                fragColor = encode(from_v(v));\n            } \n            // Update Frame\n            else {\n                bool shift_pressed = KEY(SHIFT_ASCII, IS_PRESSED);\n                float g = mix(G, SHIFT_G, shift_pressed);\n                float damping = mix(DAMPING, SHIFT_DAMPING, shift_pressed);\n                \n                vec2 p = decode(texelFetch(iChannel0, ivec2(index, T_POS), 0));\n                vec2 v = to_v(decode(texelFetch(iChannel0, ivec2(index, T_VEL), 0)));\n                \n                vec2 a = vec2(0);\n                for(int other = 0; other < PARTICLE_COUNT; other++){\n                    if(other == index) continue;\n                    vec2 p_other = decode(texelFetch(iChannel0, ivec2(other, T_POS), 0));\n                    vec2 dir = p_other - p;\n                    dir = mix(dir, sign(dir)*(abs(dir)-1.0), step(vec2(0.5), abs(dir)));\n                    a += dir / max(0.0001, dot(dir, dir));\n                }\n                a *= g;\n                \n                if(iMouse.z > 0.0 && iMouse.w < 0.0){\n                    vec2 dir = iMouse.xy / iResolution.xy - p;\n                    dir = mix(dir, sign(dir)*(abs(dir)-1.0), step(vec2(0.5), abs(dir)));\n                    a += MOUSE_G * dir / max(0.0001, dot(dir, dir));\n                }\n                \n                v = exp(-delta_time * damping) * v + a * delta_time;\n                fragColor = encode(from_v(v));\n            }\n        }\n        \n        else if(type == T_COL) {\n        \n            // Initialization Frame\n            if(ini){\n                vec4 color_size = 0.01 + noise(index + rand_offset + 2 * PARTICLE_COUNT);\n                vec3 color = color_size.rgb;\n                color *= COLOR_TINT / dot(color, vec3(1.0/3.0));\n                fragColor = vec4(color, color_size.a);\n            }\n            // Update Frame (Nothing to update)\n            else {\n                fragColor = texelFetch(iChannel0, ivec2(index, T_COL), 0);\n            }\n        }\n        \n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define PARTICLE_COUNT 128\n\nvec2 decode(vec4 e) { return e.xy + e.zw * (1.0 / 256.0); }\nvec4 encode(vec2 d) { \n    d *= 256.0;\n    vec2 zw = fract(d);\n    return vec4(floor(d) * (1.0 / 256.0), zw);\n}\n\n#define T_INI 0\n#define T_POS 1\n#define T_VEL 2\n#define T_COL 3\n\n#define SHIFT_ASCII 16\n#define CTRL_ASCII 17\n#define SPACE_ASCII 32\n#define IS_PRESSED 0\n#define JUST_PRESSED 1\n\n#define KEY(ascii, event) (texelFetch(iChannel3, ivec2(ascii, event), 0).x != 0.0)",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}