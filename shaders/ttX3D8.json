{
    "Shader": {
        "info": {
            "date": "1556189954",
            "description": "Mouse.xyzw == vec4(b,c,d,a) = of (d*x³+c*x²+b*x+a) \nAD calculates 3 derivatives\n\nwith each derivative, the graph-color red-shifts ;)\n blue     f(x)=0th derivative\n green   f'(x)=1th derivative\n yellow  f''(x)=2th derivative\n purple  f'''(x)=3th derivative",
            "flags": 0,
            "hasliked": 0,
            "id": "ttX3D8",
            "likes": 1,
            "name": "AD32 (dx³+cx²+bx+a)dx³ PowerRule",
            "published": 3,
            "tags": [
                "filter",
                "gradient",
                "vibrato",
                "ad",
                "phase",
                "automaticdifferentiation",
                "chainrule",
                "productrule",
                "curvaturejerk",
                "curvajerk",
                "drunkfluttershy"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 623
        },
        "renderpass": [
            {
                "code": "//rotate view by 90deg;\n//#define UprightVideoCalculus\n//rotate view over time;\n//#define CalculusLikeARecord\n\n/*\na derivative of a function is the differential of a function\nf'(x)=f (x)dx\n\nf1(x)=f0(x)dx\nf2(x)=f1(x)dx\nf3(x)=f2(x)dx\n\ngreen  line is close to 0,where the blue   line has a hill or valley\nyellow line is close to 0,where the green  line has a hill or valley\npurple line is close to 0,where the yellow line has a hill or valley\nf1(x)==0, where f0(x) has a local maximum or local minimum at [x]\n\n\nthe above holds true where abs is a lowest-level function\nthe above is no longer true where abs() is a higher level function\n\nwith each derivative, the graph-color red-shifts ;)\n violet f0(x)=0th derivative :eg: value per coin of money over time  (focus on a point where this is >0 (,but also decreases))\n blue   f1(x)=1th derivative :eg: inflation/deflation (change of value of money over time) (fosus on a point whree this is <0)\n green  f2(x)=2th derivative :eg: rate at which the purchasing power of money decreases/increases  (acceleration of inflation == moneyValue)\n orange f3(x)=3th derivative :eg: \"the rate of increase of inflation is decreasing\" - Richard Nixxon == \"[orange line && blue line && green line] <0, violet line is barely >0 \"\n\nthis exemplifies the little utility that a 3rd derivative has \n, while without context of lower derivatives\n//the 3rd derivative is usefull to smoothen the line of the 2nd derivative.\n\nhttps://en.wikipedia.org/wiki/Third_derivative\n     jerk == rate at which acceleration changes\ncurvajerk == rate at which curvature    changes\n\n*/\n\n//AD,filter,phase,vibrato,gradient,curvaturejerk,curvajerk,chainrule,productrule,automaticdifferentiation,drunkfluttershy\n\n//child  AD33    : https://www.shadertoy.com/view/WtlGW8\n//self   AD32    : https://www.shadertoy.com/view/ttX3D8  (power Rule)\n//parent AD31    : https://www.shadertoy.com/view/3lf3W8  (di() seems to be working fine )\n//parent AD30    : https://www.shadertoy.com/view/tlsGWn  (many fixes ant attempt at di(a/b) )\n//parent AD29    : https://www.shadertoy.com/view/3llGDr  (abs()exp()log())\n//parent AD28    : https://www.shadertoy.com/view/Wts3Wr  (cos())\n//parent AD27    : https://www.shadertoy.com/view/Wll3z7  (only sin() 3rd derivative)\n//parent dx³ base: https://www.shadertoy.com/view/WllGz7  (mostly empty canvas concept)\n//parent AD26    : https://www.shadertoy.com/view/MsffRs  (more complete set, ony 1 derivative)\n//parent AD25    : https://www.shadertoy.com/view/XdXfRl  (more complete set, ony 1 derivative)\n//parent fm-phase: https://www.shadertoy.com/view/tslSR8  (the phase-culpit of fm-synthesis)\n//parent         : all (analytic) [filter]     shaders ,where you can get: https://www.integral-calculator.com/\n//parent         : all (analytic) [softshadow] shaders ???\n//\n//twitter images: https://twitter.com/ollj/status/1121112037000609792\n//twitter odler : https://twitter.com/ollj/status/1120622111767371777\n\n\n/*\nThis shader dares to implement/debug\na [derivatuve arithmetic] set for [automatic differentiation]\nbut it calculates not just one differential as one byproduct\n, but also the 2nd and 3rd derivative as 3 byproducts total\n3 derivatives make sense\n, because trigonometry functions have a loop of 4 or 2 differntials:\n\n//f    (x)=+sin(x)\n//f'   (x)=+cos(x)\n//f''  (x)=-sin(x)\n//f''' (x)=-cos(x)\n//f''''(x)=+sin(x)==f(x)\n\ncore plan here is to use\nhttps://www.integral-calculator.com\nto get ANTI-derivatives as far as needed and possible/practical\nand then get a series of derivatives with [automatic differentiation]\n, from a high enough ANTI-derivative to:\n- use 1 antiderivative for frequency-modulation (analytic phase)\n- use 2 or 3 anditerivatives for a good filter function\n- calculate fast/analytical derivatives is useful for [advanced spheretracking]\n- - think about what you could estimate from a fast+analytic curvature of a distancefield.\n- - this can extend into something like [drunk fluttershy marching]\n  , but it may not just move along the NORMAL/GRADIRNT\n  ,also use [radiusOf/Principal /gaussian curvature] and CURVAJERK\n\nThis uses a lot of structure and monadic #define shorthands\nfrom the CommonTab\n, that construct a [derivative arithmetic] set \n  of [automatic differentiation].\nso just read the commonTab before reading further below:\n*/\n\n#define viewZoom 16.\n#define aA min(r.x,r.y)\n#define Aa (viewZoom/aA)\n#define fra(u)(u-.5*r.xy)*viewZoom/r.y \n\n#define ssaa(a) smoothstep(Aa,-Aa,a)\n\nvec4 dtB(float t,vec4 m){ \n ;return dtpB(t,m)\n ;d0000 x =D0000(vec4(t,1,0,0))//dt\n ;d0000 n=D0000(vec4(0,0,0,0))//to quickly multiply by 0\n ;d0000 C=D0000(vec4(3.,0,0,0))//to quickly multiply by another constant\n ;d0000 my=D0000(vec4(m.x,0,0,0))\n ;d0000 mx=D0000(vec4(m.y,0,0,0))\n ;d0000 mz=D0000(vec4(m.z,0,0,0))\n ;d0000 mw=D0000(vec4(m.w,0,0,0))\n ;d0000 a=n\n ;d0000 b=n\n ;d0000 c=mx\n ;d0000 d=my\n ;return V3(x);}\n\nvec4 dtA(float t,vec4 m){ \n ;return dtpA(t,m)\n ;d0000 x =D0000(vec4(t,1,0,0))//dt\n ;d0000 n=D0000(vec4(0,0,0,0))//to quickly multiply by 0\n ;d0000 C=D0000(vec4(3.,0,0,0))//to quickly multiply by another constant\n ;d0000 my=D0000(vec4(m.x,0,0,0))\n ;d0000 mx=D0000(vec4(m.y,0,0,0))\n ;d0000 mz=D0000(vec4(m.z,0,0,0))\n ;d0000 mw=D0000(vec4(m.w,0,0,0))\n ;d0000 a=n\n ;d0000 b=n\n ;d0000 c=mx\n ;d0000 d=my\n ;//b=mu(b,x)\n ;c=po(x,C)//floating point exponents are extra tricky to debug?\n ;//d=mu(d,po(D0000(vec4(3,0,0,0)),x))\n ;x=c//ad(ad(a,b),ad(c,d))\n ;return V3(x);}\n\n\n//memos:\n//ex(ln(C))=C  //this just debugs ln() AND ex()\n//for where any of them may not be the inverse of the other.\n//C=ex(ln(C)) // if(log(0.)==0.) ex(ln(C))=abs(C)\n//;C=ln(ex(C)) // if(log(0.)==0.) ex(ln(C))=C\n//;C=ex(ln(C)) // if(log(0.)==0.) ex(ln(C))=abs(C)\n\n\n//visualizaing demo:\nvec4 show(float t,vec2 u,vec3 r,vec4 m\n){\n ;t=u.x\n ;//t*=2.     \n ;vec4 c=vec4(0)\n ;c=dtA(t,m)//test for show   //pass\n ;//normalizing a 2d gradient is rarely pretty\n ;//;c.xyz=abs(c.xyz-u.y)/(sqrt(1.+c.yzw*c.yzw))-thick.xyz;\n ;//still lacks precision when the next abs(derivative) is small.\n ;//float thick=.4\n ;vec4 thick=vec4(1.9,1.6,1.3,1)*Aa*mix(1.,4.,sin(iTime)*.5+.5) //line thickness (normalized by 1 derivative)\n ;vec3 e=sqrt(1.+pow(vec3(thick.yz,c.zw),vec3(1./8.)))//this seems very false\n ;e=vec3(1)\n ;c.xyz=abs(u.y-c.xyz)*e/(sqrt(1.+c.yzw*c.yzw))-thick.xyz;\n  //no analytical 4th derivative, so c.w one sucks a bit\n ;float W=fwidth(u.y-c.w)\n ;//c.w=abs(c.w-u.y)*(sqrt(1.-dFdx(c.w)))/W-thick.w*32.//this is not pretty\n\n ;c.w=mix(\n      smoothstep(Aa*32.,-Aa*32.,(abs(c.w-u.y)*(sqrt(1.-dFdx(c.w)))/W)-thick.w*thick.w*64.)\n     ,smoothstep(Aa,-Aa,abs(c.w-u.y)/(sqrt(1.+W))-thick.w)\n     ,.9)\n ;//i could easiyl get a great c.w by 4tapping it. but i dont want to?\n     \n ;c.xyz=smoothstep(Aa,-Aa,c.xyz)\n ;//rainbow color and alpha-compositing\n ;c*=.9//more transparent\n ;vec4 o=sqrt(7./vec4(3,5,7,13))*.5+.5\n ;o=-.125-.5*vec4(.03,.05,.15,.1)*cos(o*u.x*36.*viewZoom/iResolution.x)\n ;v3 violet =v3(hsv2rgb_cosine15(o.x+.8,1.,2.),c.x)//v3(.5,0 ,1,c.x);\n ;v3 blue   =v3(hsv2rgb_cosine15(o.y+.5,1.,2.),c.y)//v3(0 ,.5,1,c.y);\n ;v3 yellow =v3(hsv2rgb_cosine15(o.z+.2,1.,2.),c.z)//v3(0 ,1 ,0,c.z);\n ;v3 orange =v3(hsv2rgb_cosine15(o.w+.0,1.,2.),c.w)//v3(1 ,.5,0,c.w);\n ;return aOverB(aOverB(violet,blue),aOverB(yellow,orange));\n ;}\n//grid canvas for scale\nfloat grid(vec2 u,vec3 r\n){u=abs(u)\n ;u.x=min(u.x,u.y)-Aa*.02\n ;u.x=ssaa(u.x)\n ;return u.x;}\nfloat canvas(vec2 u,vec3 r\n){return mix(grid(u,r),grid(fract(u-.5)-.5,r),.2);}\n//damn, grid and gamma correction do not cooperate well\n//, i need my tartan weave really?\n\nfloat showMouse(vec2 u,vec3 r,vec4 m//return distance to 2 mousePositions\n){m.xy-=u\n ;m.zw-=u\n ;u=sqrt(vec2(dd(m.xy),dd(m.zw)))     \n ;u=abs(abs(abs(u)-Aa*9.)-Aa*vec2(7,5))-Aa\n ;u=vec2(min(u.x,u.y),max(u.x,u.y))\n ;u.xy/=u.yx\n ;u=ssaa(u)\n ;u.x=mix(u.x,u.y,.2)\n ;return u.x;}\n\n//to maximize a leastCommonMultiple of mulriple periods, a\n//[[Primal quadratic field] (matrix)] is a matrix/vector\n//of (unique) quadraticFields\n//, that are only defined by primes, without coprimes between them\n//, or that are only defined by coprimes, without any shared coprime-factors\nvec4 pqfm(float t){return cos(t*sqrt(vec4(3,5,7,13)+2.)*.5+.5);}\n//this is used within evolution\n//to a point where multiple species (with overlapping biomes)\n//use different primes within their reporiductive-cycles\n//so that rarely ever 2 competing species need much food at the same time.\n//and that prey reproduces more likely while prey does not reproduce.\n//yourAge-AgeOfYourSibbling is likely a prime \n//or a quadraticField of primes.\n//and each species uses exclusice primes.\n\nvoid mainImage( out vec4 o, in vec2 u\n){vec4 m=iMouseZwFix(iMouse,true)\n ;vec3 r=iResolution\n ;//u.x-=(m.z-iResolution.x*.5)//*2. //mouse.x scrolls\n ;u=fra(u)\n ;if(m.z<=0.)m=iResolution.xyxy*(-pqfm(.1*iTime)*.25+.5)\n ;m.xy=fra(m.xy);m.zw=fra(m.zw)        ;\n ;//u/=(1.-iResolution.y/m.w)//mouse.w zooms\n ;float iT=iTime-4.\n ;//m.zw=fra(m.zw)\n #ifdef UprightVideoCalculus\n ;u.xy=u.yx*vec2(-1,1)//quater rotation\n ;m.xy=m.yx*vec2(-1,1)//quater rotation\n ;m.zw=m.zw*vec2(-1,1)//quater rotation\n #endif\n #ifdef CalculusLikeARecord   \n ;mat2 R=r2(iTime*.01) //rotae by radians\n ;u.xy*=R\n ;m.xy*=R\n ;m.zw*=R\n #endif\n ;vec4 c=vec4(0)\n ;c=aOverB(show(iTime,u,r,m),vec4(sat(canvas(u/2.,r)*9.)))\n ;c=aOverB(c,vec4(vec3(showMouse(u,r,m)),1.))\n ;o =vec4(sat(c.xyz*1.1),1)\n ;o.xyz=pow(o.xyz,vec3(2.2))\n ;//o.xyz=vec3(showMouse(u,r,m))\n ;}\n\n/*\nmemos to self: \n- verb is \"differentiation\", there is no \"c\" glyph in this (except in its french variant)\n- - Babbage planned a [differencial engine] and this the \"c\" is a bad habbit in AD ever since.\n- [radius of curvature] != [gaussian curvature] //2nd derivative\n- - i assume this only gets worse for 3rd derivatives.\n- reciprocal rule may simplify some things:\n- - https://en.wikipedia.org/wiki/Reciprocal_rule\n/**/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec4 iMouseZwFix(vec4 m,bool NewCoke\n ){if(m.z>0.){ //while mouse down\n    if(m.w>0.)return m;//mouse was clicked in THIS     iFrame \n    else m.w=-m.w      //mosue was clicked in previous iFrame\n    //remember, MouseDrag advances the iFrame Count, even while paused !!\n ;}else{if(!NewCoke||m.w>0.)return m.xyxy; //OPTIONAL onMouseUp (fold or whatever)\n    m.zw=-m.zw;}\n  return m;}\n\n#if (__VERSION__ <300)\n  //glES300 reserves more namespace than previous versions\n  //this also reserves these namespaces in older versions\n  //so you do not unintentionally use cross() in gles100\n  #define cross(a,b) 1.\n  #define inverse(a) 1.\n#endif\n\n//indexing starts at 0\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n\n#define dd(a) dot(a,a)\n#define sat(a) clamp(a,0.,1.)\n\nvec3 hsv2rgb_cosine15(float h,float s,float v){\n vec3 hue=.5+.5*cos((3.*h+vec3(0,2,1))*radians(120.0));\n return v*mix(vec3(1),clamp(hue,0.,1.),s);}\n\n//https://en.wikipedia.org/wiki/Alpha_compositing\n//includes sat() and premultiply:\nv3 aOverB(v3 a,v3 b){a=sat(a);b=sat(b)\n ;a.xyz*=a.w;b.xyz*=b.w;return vec4(a+b*(1.-a));}\n //vec2 aOverB(vec2 a,vec2 b){a.x*=a.y;b.x  *=b.y;return vec2(a+b*(1.-a));}\n //not sure if correct, but looks useful.\n\n// AD31_start\n/*\n3rd derivative [Automatic differentiation]\nuses [chain rule] and [product rule]\n, to calculate the derivative of an operation-list opA(opB(x)) as a byproduct\nto up to a 3rd derivative; f'''(x)\n\nso far only defined for y=sin(x) and y=cos(x)\nfirst steps are slow, because debugging a 3rd derivative is non-instant\nwhile there is plenty of space for silly typos and copyPaste errors\nmore complete DA-sets (only 1st derivative) are [DA25],[DA24],[DA23]...\n/**/\n\n//define more [monadic function namespace]\n//to completely replace infix-notation\nv0 ne(v0 a){return -1.*(a);}\nv0 ab(v0 a){return abs(a);}//sign(a)=a/ab(a) \nv0 si(v0 a){return sin(a);}\nv0 co(v0 a){return cos(a);}\nv0 ex(v0 a){return exp(a);} \nv0 e2(v0 a){return exp2(a);} \nv0 ln(v0 a){return log(abs(a));} //semi-worksafe\nv0 l2(v0 a){return log2(abs(a));}//semi-worksafe\nv0 mu(v0 a,v0 b){return a*b;}\nv0 di(v0 a,v0 b){return a/b;}\nv0 su(v0 a,v0 b){return a-b;}\nv0 ad(v0 a,v0 b){return a+b;}\n\nmat2 r2(float a){return mat2(co(a),si(a),-si(a),co(a));}\n\n/*\ndefine a structure that implies automatic differentiation:\n-type: [d**  ] <- implies automatic differentiation with at least 1 derivative\n-type: [d*** ] <- implies automatic differentiation with at least 2 derivatives\n-type: [d****] <- implies automatic differentiation with at least 3 derivatives\n*=[0,1,2,3] == number of domains (indexing starts at 0)\nby feeding a different type to the same [monadic function namespace]\n.a accululates 0th derivative\n.b accumulates 1th derivative\n.c accumulates 2th derivative\n.d accumulates 3th derivative\nbut not just over one tomain, but easily up to 3d. (and a bit into 4d)\n*/\n#define ST struct\nST d00{v0 a;v0 b;};ST d000{v0 a;v0 b;v0 c;};ST d0000{v0 a;v0 b;v0 c;v0 d;};\nST d11{v1 a;v1 b;};ST d111{v1 a;v1 b;v1 c;};ST d1111{v1 a;v1 b;v1 c;v0 d;};\nST d22{v2 a;v2 b;};ST d222{v2 a;v2 b;v2 c;};ST d2222{v2 a;v2 b;v2 c;v0 d;};\nST d33{v3 a;v3 b;};ST d333{v3 a;v3 b;v3 c;};ST d3333{v3 a;v3 b;v3 c;v0 d;};\n//restore funtionality (eg: swiveling) by explicit typecast:\nd0000 D0000(v3    a){return d0000(a.x,a.y,a.z,a.w);}\nv3       V3(d0000 a){return    v3(a.a,a.b,a.c,a.d);}\n//v3 D1bcd(d0000 a){return v3(1.,a.b,a.c,a.d);}//for a minifying concept\n\n\n/*\nmemo:\nhttps://en.wikipedia.org/wiki/Differentiation_rules\n\n  product rule (is subroutine of others of higher derivatives than 1st derivative)\n  (f()*g())dx = f'()*g()+f()*g'()\n  (a.a*b.a)dx = a.b *b.a+a.a*b.b\n  (a.b*b.b)dx = a.c *b.b+a.b*b.c\n  (a.c*b.c)dx = a.d *b.c+a.c*b.d\n\n  quotientRule\n  (f()/g())dx = (f'()*g()-f()*g'())/(g()*g())\n  (a.a/b.a)dx = ( a.b*b.a-a.a*b.b )/(b.a*b.a)\n\n  chain rule:\n  (f(g(x)))dx = f'(g())*g'()\n  (f(b.a ))dx = f'(b.a)*b.b\n*/\n\n//[automatic differentiation] uo to 3rd derivative of o(a())\n//see siD() for the o()-values of trigonometry derivatives of sin() cos()\nd0000 AD(d0000 a,vec4 o){float O=a.c*o.x\n ;return D0000(o.xyyy*vec4(1.,a.b,a.c,a.d)\n +vec4(0,0,a.b*vec2(o.z*a.b,-(2.*O+(a.b*a.b*o.y+O)))));}\n//above so far is only useful for sin() or cos()\n\n//sin() and cos() derivatives are 4-cyclic, cos() is offset by 1:\nvec4 siD(float a){return vec4(+si(a),+co(a),-si(a),-co(a));}\nd0000 si(d0000 a){return AD(a,siD(a.a)     );}//sin()dxdxdx\nd0000 co(d0000 a){return AD(a,siD(a.a).yzwx);}//cos()dxdxdx\n\n//2nd derivative seems to be fine\nd0000 ab(d0000 a){return d0000(ab(a.a),sign(a.a)*a.b,sign(a.a)*a.c,sign(a.a)*a.d);}\n//2nd derivative is certainly false for ln()\n\n//ex() seems to be fine\nd0000 ex(d0000 a){return d0000(ex(a.a)\n,ex(a.a)*a.b\n,ex(a.a)*a.b*a.b+ex(a.a)*a.c//productRule\n//above implies  https://en.wikipedia.org/wiki/Triple_product_rule\n,ex(a.a)*a.b*a.b*a.b+  ex(a.a)*a.c*a.b +  ex(a.a)*a.c*a.b\n+ex(a.a)*a.b*a.c+ex(a.a)*a.d);}\n//exp2() is not THAT simple here.\n\n//ln() 2nd and 3rd derivative imply quotientRule\n//i hope i did this corretcly. last time i did this 15 years ago.\nd0000 ln(d0000 a){return d0000(\n ln(a.a)\n,a.b/a.a\n,(a.c*a.a-a.b*a.b)/(a.a*a.a)\n,((a.a*a.d-a.b*a.c)*(a.a*a.a)-2.*(a.c*a.a-a.b*a.b)*(a.b*a.a))\n /(a.a*a.a*a.a*a.a)//the dividend may still contain a faster growing a.b or a.c or a.d ?\n);}//ln() overlaps a lot with di() the a are only off by 1.\n //ln() is a special case of di()\n\n//substraction is trivial, because [differentiation == integration]\nd0000 su(d0000 a,d0000 b){return D0000((V3(a)-V3(b)));}\nd0000 ad(d0000 a,d0000 b){return D0000((V3(a)+V3(b)));}\n\nd0000 mu(d0000 a,d0000 b){return d0000(\n a.a*b.a        //1 product rule  to 1th derivative\n,a.a*b.b+a.b*b.a//2 product rules to 2th derivative\n,a.b*b.b+a.a*b.c\n+a.c*b.a+a.b*b.b//4 product rules to 3th derivative\n,a.c*b.b+a.b*b.c\n+a.b*b.c+a.a*b.d\n+a.d*b.a+a.c*b.b\n+a.c*b.b+a.b*b.c);}    \n\n//this looks promising, after 4 failures.\n//3rd quotientRule is a bit excessive\nd0000 di(d0000 a,d0000 b){return d0000(\n  a.a/b.a\n,(a.b*b.a-a.a*b.b)/(b.a*b.a)//first derivative is [simple quotient rule]\n //2nd derivatibve is the quotient rule of THE ABOVE 1st derivative\n,//2nd derivative is perfeect match with 3rd of ln() so thats a good sign!\n((a.c*b.a+a.b*b.b-a.b*b.b-a.a*b.c)*(b.a*b.a)\n    -2.*(a.b*b.a-a.a*b.b)*(b.a*b.b))\n    /(b.a*b.a*b.a*b.a) \n,//3rd derivatibve is the quotient rule of THE ABOVE 2nd derivative\n //3rd derivative looks fine, has all the right signs and limits\n //and it nicely normalites the 2nd derivative line\n //its still not crunched and very commented, for debugging.\n\n((\n//derived dividend ((all whitespace is a püroductRule\n((a.d*b.a+a.c*b.b+a.c*b.b+a.b*b.c-a.c*b.b-a.b*b.c-a.b*b.c-a.a*b.d)*(b.a*b.a         )\n+(a.c*b.a        +a.b*b.b        -a.b*b.b        -a.a*b.c        )*(b.b*b.a*b.a*b.b))\n+(-2.*(a.c*b.a+a.b*b.b-a.b*b.b-a.a*b.c)*(b.a*b.b        )\n     +(a.b*b.a        -a.a*b.b        )*(b.b*b.b+b.a*b.c)))\n*(b.a*b.a*b.a*b.a)//times pure divisor\n//minus pure dividend\n-((a.c*b.a+a.b*b.b-a.b*b.b-a.a*b.c)*(b.a*b.a)\n    -2.*(a.b*b.a-a.a*b.b)*(b.a*b.b))\n *4.*(b.b*b.a*b.a*b.a)//times derived divisor\n)/(b.a*b.a*b.a*b.a*b.a*b.a*b.a*b.a)//divided by pure squared divisor\n//return 4 ddifferential accumulators: 0th to 3th derivative.\n);}\n\n/*  /3rd derivative of a.a/b.a  , bacjkup:\n((\n//derived dividend\n((a.d*b.a+a.c*b.b+a.c*b.b+a.b*b.c-a.c*b.b-a.b*b.c-a.b*b.c-a.a*b.d)*(b.a*b.a         )\n+(a.c*b.a        +a.b*b.b        -a.b*b.b        -a.a*b.c        )*(b.b*b.a*b.a*b.b))\n+(-2.*(a.c*b.a+a.b*b.b-a.b*b.b-a.a*b.c)*(b.a*b.b        )\n     +(a.b*b.a        -a.a*b.b        )*(b.b*b.b+b.a*b.c))\n)\n//times pure divisor\n*(b.a*b.a*b.a*b.a)\n//minus pure dividend\n-((a.c*b.a+a.b*b.b-a.b*b.b-a.a*b.c)*(b.a*b.a)\n    -2.*(a.b*b.a-a.a*b.b)*(b.a*b.b))\n//times derived divisor\n *2.*(b.b*b.a*b.a*b.a)\n//divided by pure seuared divisor\n)/((b.a*b.a*b.a*b.a*b.a*b.a*b.a*b.a) )\n/**/\n\nd0000 po(d0000 a,d0000 b){return d0000(\n pow(a.a,b.a)                 //0th apply power rule\n,pow(a.a,b.a-1.)*b.a          //1th apply power rule within product rule\n,pow(a.a,b.a-2.)*(b.a*b.a-b.a)//2th  //(b.a-1.)*b.a==(b.a*b.a-b.a)\n+pow(a.a,b.a-1.)*b.b          //2th\n,pow(a.a,b.a-3.)*(b.a-2.)*(b.a*b.a-b.a)\n+pow(a.a,b.a-2.)*(b.b*b.a+b.a*b.b-b.b)\n+pow(a.a,b.a-2.)*(b.a-1.)*b.b \n+pow(a.a,b.a-1.)*b.c\n\n    \n    /*\n    //nope 3rd below is false:\n\n,pow(a.a,b.a-3.)*(b.a-2.)*(b.a*b.a-b.a)//3th (b.a*b.a-b.a)\n+pow(a.a,b.a-2.)*(b.b*b.a+b.a*b.b-b.b) //3th (b.a*b.a-b.a)dx\n+pow(a.a,b.a-2.)         *(b.a*b.a-b.a)//3th (b.a*b.a-b.a)\n+pow(a.a,b.a-1.)*b.c                   //3th\n*/\n);}\n\n\n/**/\n\n\n/*                                     \nquestions on how to get to the above function; \nd0000 si(d0000 a){}\nare hopefully answered with the parent shader;\nparent AD26    : https://www.shadertoy.com/view/MsffRs  (more complete set, ony 1 derivative)\nand with the images of:\ntwitter odler : https://twitter.com/ollj/status/1120622111767371777\n\n\ntodo: \n- maybe get some use of   \n- - https://en.wikipedia.org/wiki/Fa%C3%A0_di_Bruno%27s_formula\n- - perductRule for high n in pow(dx,n) where ever the productRule applies. \n- think about utility of:\n- - https://en.wikipedia.org/wiki/General_Leibniz_rule\n- - its basically a generalized mu()\n/**/\n\n\n//---start dreidelDebugger:\n//  https://en.wikipedia.org/wiki/Teetotum\n//  https://en.wikipedia.org/wiki/Paprika_(2006_film)\n//We do 3rd derivatives,lets use a [Paprika/Inception] metaphors:\n//A [dreidelDebugger] is the difference of 2 different functions with the same input:\n//dreidelDebugger=functionA(x)-functionB(x)=0\n//, that should always be ==0 \n//for all relevant [x] inputs (within range limits)\n//we may change one of the 2 function subroutines\n// and accidentally introduce an inequality\n//to be caught, by adding the dreidel to anything at any moment\n//, we debug many subroutine-change-effects \n//without even thinking about it\n\n//modulo arithmetic and floating point precision \n//easily breaks many dreidelDebuggers\n\n//dreidelDebugger: dual-trigonometry-basis \nvec4 sisi(float t){return vec4(\nsin(sin(t)),cos(t)*cos(sin(t)),\n-cos(t)*cos(t)*sin(sin(t))-sin(t)*cos(sin(t)),\n-cos(sin(t))*cos(t)*cos(t)*cos(t)//3rd\n+sin(sin(t))*3.*cos(t)*sin(t)\n-cos(sin(t))*cos(t));}\nvec4 sico(float t){return vec4(\nsin(cos(t)),-sin(t)*cos(cos(t)),\n-sin(t)*sin(t)*sin(cos(t))-cos(t)*cos(cos(t)),\n+cos(cos(t))*sin(t)*sin(t)*sin(t)//3rd\n-sin(cos(t))*3.*cos(t)*sin(t)\n+cos(cos(t))*sin(t));}\nvec4 cosi(float t){return vec4(\ncos(sin(t)),-cos(t)*sin(sin(t)),\nsin(t)*sin(sin(t))-cos(t)*cos(t)*cos(sin(t)),\n+sin(sin(t))*cos(t)*cos(t)*cos(t)//3rd\n+cos(sin(t))*3.*cos(t)*sin(t) \n+sin(sin(t))*cos(t));}\nvec4 coco(float t){return vec4(\ncos(cos(t)),sin(t)*sin(cos(t)),\ncos(t)*sin(cos(t))-sin(t)*sin(t)*cos(cos(t)),\n-sin(cos(t))*sin(t)*sin(t)*sin(t)//3rd\n-cos(cos(t))*3.*cos(t)*sin(t)  \n-sin(cos(t))*sin(t));}\n//above are explicit 3 derivatives below is the same, wit AD\n//above and below should be the same\n//and i am not testing 3x permutations the same way.\n//example code for automatic differentiation of repeated cos()\nvec4 dsisi(float t){d0000 C=D0000(vec4(t,1,0,0))//initial chainRuleSetup\n ;C=si(C);C=si(C);return V3(C);}\nvec4 dsico(float t){d0000 C=D0000(vec4(t,1,0,0))//initial chainRuleSetup\n ;C=co(C);C=si(C);return V3(C);}\nvec4 dcosi(float t){d0000 C=D0000(vec4(t,1,0,0))//initial chainRuleSetup\n ;C=si(C);C=co(C);return V3(C);}\nvec4 dcoco(float t){d0000 C=D0000(vec4(t,1,0,0))//initial chainRuleSetup\n ;C=co(C);C=co(C);return V3(C);}\n\n//dreidelDebugger powerRule (basic\n//degubbing non-float-exponents is hard as fuck, \n//so, we just do a few small integer exponents.\n//and we sure do not debug pow(x,n)dx³, because, while possible\n//, that just succums to all sorts of precision issues.\nvec4 dtpA(float t,vec4 m){\n ;d0000 x=D0000(vec4(t,1,0,0))//dt\n ;d0000 my=D0000(vec4(m.x,0,0,0))\n ;d0000 mx=D0000(vec4(m.y,0,0,0))\n ;d0000 mz=D0000(vec4(m.z,0,0,0))\n ;d0000 mw=D0000(vec4(m.w,0,0,0))\n ;d0000 a=mw\n ;d0000 b=mx\n ;d0000 c=my\n ;d0000 d=mz\n ;b=mu(b,x)\n ;c=mu(c,mu(x,x))\n ;d=mu(mu(d,x),mu(x,x))\n ;x=ad(ad(a,b),ad(c,d))\n ;return V3(x);}\nvec4 dtpB(float t,vec4 m){ \n ;d0000 x=D0000(vec4(t,1,0,0))//dt\n ;d0000 my=D0000(vec4(m.x,0,0,0))\n ;d0000 mx=D0000(vec4(m.y,0,0,0))\n ;d0000 mz=D0000(vec4(m.z,0,0,0))\n ;d0000 mw=D0000(vec4(m.w,0,0,0))\n ;d0000 a=mw\n ;d0000 b=mx\n ;d0000 c=my\n ;d0000 d=mz\n ;b=mu(b,x)\n ;c=mu(c,po(x,D0000(vec4(2,0,0,0))))\n ;d=mu(d,po(x,D0000(vec4(3,0,0,0))))\n ;x=ad(ad(a,b),ad(c,d))\n ;return V3(x);}\n\nvec4 dreidels(float t,vec2 u,vec3 r,vec4 m\n){vec4 c=vec4(0)\n ;c+=dcoco(t)-coco(t)//pass\n ;c+=dsisi(t)-sisi(t)//pass\n ;c+=dcosi(t)-cosi(t)//pass\n ;c+=dsico(t)-sico(t)//pass\n ;c+=dtpA(t,m)-dtpB(t,m)//pass\n //above lines should EACH add +=vec4(0)\n //, as both functions are identical.\n ;return c;}\n\n//memo; always check 2nd derivative in both directions\n//always check for commutative AND distributive property!\n//these are too easily asserted wrongly to be true, when they are false.\n\n//--- end___ dreidelDebugger\n\n\n// AD31___end\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}