{
    "Shader": {
        "info": {
            "date": "1630939829",
            "description": "check out Slowtember by megaelod on IG\nhttps://www.instagram.com/p/CSCRu85jWe0/",
            "flags": 0,
            "hasliked": 0,
            "id": "fsG3zR",
            "likes": 25,
            "name": "Slowtember 04-06: Shop",
            "published": 3,
            "tags": [
                "slowtember"
            ],
            "usePreview": 0,
            "username": "klemek",
            "viewed": 326
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\n#define PI 3.1415927\n#define E .002\n\nfloat n(float c) {\n    return min(1., max(.0, c));\n}\n\nfloat estep(float threshold, float x, float e) {\n    return smoothstep(threshold + e, threshold - e, x);\n}\n\nfloat h(vec2 uv, float y0, float height, float e) {\n    return estep(y0 - height * .5, uv.y, -e) * estep(y0 + height * .5, uv.y, e);\n}\n\nfloat v(vec2 uv, float x0, float width, float e) {\n    return estep(x0 - width * .5, uv.x, -e) * estep(x0 + width * .5, uv.x, e);\n}\n\nvec3 n3(vec3 c) {\n    return min(vec3(1), max(vec3(0), c));\n}\n\nvec3 mask(vec3 c0, vec3 c1, float m) {\n    return n3(c0 * (1.0 - m) + c1 * m);\n}\n\nfloat rand(float seed) {\n    if (seed < .0)\n        seed *= -1.;\n    float v = pow(seed, 6.0 / 7.0);\n    v *= sin(v) + 1.;\n    return v - floor(v);\n}\n\nvec3 col(float x) {\n    return vec3(\n        .5 * (sin(x * 2. * PI) + 1.),\n        .5 * (sin(x * 2. * PI + 2. * PI / 3.) + 1.),\n        .5 * (sin(x * 2. * PI - 2. * PI / 3.) + 1.)\n    );\n}\n\nvec2 rot(vec2 uv, float angle) {\n    return vec2(\n        cos(angle * 2. * PI) * uv.x - sin(angle * 2. * PI) * uv.y,\n        sin(angle * 2. * PI) * uv.x + cos(angle * 2. * PI) * uv.y\n    );\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nfloat circle(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    return estep(min(size.x, size.y) * .5, length(uv), e * 2.);\n}\n\nfloat rect(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    return \n        estep(size.x * .5, uv.x, e) *\n        estep(-size.x * .5, uv.x, -e) *\n        estep(size.y * .5, uv.y, e) *\n        estep(-size.y * .5, uv.y, -e);\n}\n\nfloat tri(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    uv += vec2(0, size.y * .5);\n    return\n        estep(-size.x * .5, uv.x - uv.y * size.x * .5 / size.y, -e * 2.) *\n        estep(-size.x * .5, - uv.x - uv.y * size.x * .5 / size.y, -e * 2.) *\n        estep(.0, uv.y, -e);\n}\n\nfloat ell(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    float t;\n    float c;\n    vec2 p;\n    if (size.x >= size.y) {\n        t = size.x;\n        c = pow(pow(size.x * .5, 2.) - pow(size.y * .5, 2.), .5);\n        p = vec2(c, .0);\n    } else {\n        t = size.y;\n        c = pow(pow(size.y * .5, 2.) - pow(size.x * .5, 2.), .5);\n        p = vec2(.0, c);\n    }\n    return estep(t, length(uv - p) + length(uv + p), e * 4.);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nfloat circleh(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    return n(\n        circle(uv, vec2(.0), size, .0, .0, e) - \n        circle(uv, vec2(.0), size - vec2(r), .0, .0, e)\n    );\n}\n\nfloat recth(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    return n(\n        rect(uv, vec2(.0), size, .0, .0, e) - \n        rect(uv, vec2(.0), size - vec2(r), .0, .0, e)\n    );\n}\n\n// WIP\nfloat trih(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    return n(\n        tri(uv, vec2(.0), size, .0, .0, e) - \n        tri(uv, vec2(.0, -r * .2), size - vec2(r * pow(2., .5)), .0, .0, e)\n    );\n}\n\nfloat ellh(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    return n(\n        ell(uv, vec2(.0), size, .0, .0, e) - \n        ell(uv, vec2(.0), size - vec2(r), .0, .0, e)\n    );\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nfloat line(vec2 uv, vec2 p1, vec2 p2, float size, float e) {\n    vec2 diff = p2 - p1;\n\n    float angle = atan(diff.y, diff.x) / (2. * PI);\n    return n(\n        circle(uv, p1, vec2(size), .0, .0, e) +\n        circle(uv, p2, vec2(size), .0, .0, e) +\n        rect(uv, (p1 + p2) * .5, vec2(length(diff), size), .0, -angle, e)\n    );\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nfloat rectr(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    vec2 isize = size - vec2(r);\n    vec2 v1 = isize * .5;\n    vec2 v2 = v1 * vec2(-1, 1);\n    return n(\n        circle(uv, + v1, vec2(r), .0, .0, e) +\n        circle(uv, - v1, vec2(r), .0, .0, e) +\n        circle(uv, + v2, vec2(r), .0, .0, e) +\n        circle(uv, - v2, vec2(r), .0, .0, e) +\n        rect(uv, vec2(.0), vec2(size.x, isize.y), .0, .0, e) + \n        rect(uv, vec2(.0), vec2(isize.x, size.y), .0, .0, e)\n    );\n}\n\nfloat rectr2(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    return n(\n        rectr(uv, vec2(.0), size, r, .0, E) +\n        rect(uv, vec2(.0, - size.y * .5 + r * .5), vec2(size.x, r), .0, .0, E)\n    );\n}\n\nfloat trir(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    vec2 isize = size - vec2(r);\n    vec2 v1 = isize * .5;\n    vec2 v2 = v1 * vec2(-1, 1);\n    vec2 v3 = (v1 + v2) * .5;\n    return n(\n        line(uv, -v1, v3, r, e) +\n        line(uv, -v1, -v2, r, e) +\n        line(uv, v3, -v2, r, e) +\n        tri(uv, vec2(.0), size - vec2(r), .0, .0, e)\n    );\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nfloat rectrh(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    return n(\n        rectr(uv, vec2(.0), size, r, .0, e) -\n        rectr(uv, vec2(.0), size - vec2(r), r, .0, e)\n    );\n}\n\n// WIP\nfloat trirh(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    return n(\n        trir(uv, vec2(.0), size, r, .0, e) -\n        trir(uv, vec2(.0, -r * .2), size - vec2(r), r, .0, e)\n    );\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\n#define BG_PLANK_W .6\n#define BG_PLANK_H .15\n#define PLANK_LIGHT vec3(.48, .36, .23)\n#define PLANK_DARK vec3(.28, .20, .14)\n\n#define CORK vec3(.66, .44, .23)\n\nfloat plank_text(vec2 uv, vec2 size, float plank_seed, float range) {\n    if (rand(plank_seed++) > .5)\n        uv.x = (size.x - uv.x);\n        return h(\n                uv + vec2(.0, sin(uv.x * (15. + 15. * rand(plank_seed++))) * .002),\n                size.y * (.05 + .9 * rand(plank_seed++)),\n                cos(uv.x * (10. + range * (rand(plank_seed++) - .5))) * .01\n                , E);\n}\n\nfloat plank_dark(vec2 uv, vec2 size, float plank_seed) {\n    float m = .0;\n    \n    m += plank_text(uv, size, plank_seed++, 3.);\n    m += plank_text(uv, size, plank_seed++, 3.);\n    \n    m += v(uv, -.005, .02, E);\n    m += h(uv, -.005, .02, E);\n    m += v(uv, size.x + .005, .02, E);\n    m += h(uv, size.y + .005, .02, E);\n    \n    return n(m);\n}\n\nvec3 plank(vec3 c, vec2 uv, vec2 center, vec2 size, float plank_seed, float color_shift) {\n    uv += size * .5 - center;\n    \n    vec3 c0 = PLANK_LIGHT - rand(plank_seed++) * .02 + color_shift;\n    vec3 c1 = PLANK_DARK;\n    \n    float pmask = rect(uv, size * .5, size, .0, .0, E);\n    float pmask2 = rect(uv, size * .5, size - .005, .0, .0, E);\n    \n    c = mask(c, c0, pmask2);\n    \n    for(int i = 0; i < 50; i++)\n        c = mask(c, c1, pmask2 * rand(plank_seed++) * .2 * plank_text(uv, size, plank_seed++, 20.));\n    \n    plank_seed++;\n    \n    c = mask(c, c0 * 1.3, pmask2 * .5 * plank_dark(uv + vec2(.005), size, plank_seed));\n    c = mask(c, c0 * 1.3, pmask2 * .5 * plank_dark(uv + vec2(-.005), size, plank_seed));\n    c = mask(c, c1, pmask * plank_dark(uv, size, plank_seed));\n\n    return c;\n}\n\nvec3 background(vec2 uv0) {\n    vec2 size = vec2(BG_PLANK_W, BG_PLANK_H);\n\n    uv0.x += mod(uv0.y, 2. * size.y) < size.y ? size.x * .5 : .0;\n    vec2 uv = vec2(mod(uv0.x, size.x), mod(uv0.y, size.y));\n    \n    float plank_seed = floor(uv0.x / size.x) * 938. + floor(uv0.y / size.y) * 324. + 100.;\n\n    return plank(PLANK_DARK, uv, size * .5, size, plank_seed, .0);\n}\n\nfloat writing(vec2 uv, vec2 center, vec2 size, float ampl, float angle, float seed, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    return  h(\n        vec2(uv.x, uv.y + sin((uv.x + rand(seed++)) * 123.) * sin((uv.x + rand(seed++)) * 256.) * sin((uv.x + rand(seed++)) * 89.) * sin((uv.x + rand(seed++)) * 111.) * ampl), \n        .0, size.y * .25, E) * rect(uv, vec2((rand(seed++) - .5) * size.x * .1, (rand(seed++) - .5) * size.y * .5), vec2(size.x * .9 - rand(seed++) * size.x * .6, size.y), .0, .0, e);\n}\n\nvec3 shelf(vec3 c, vec2 uv, float seed) {\n    float shadow = n(\n        rect(uv, vec2(.03, -.18), vec2(.35, .1), .0, .0, E) +\n        tri(uv, vec2(.175, -.115), vec2(.06, .03), .0, .0, E) +\n        tri(uv, vec2(-.16, -.20), vec2(.06, .03), .0, .75, E)\n    );\n\n    c = mask(c, vec3(.0), .3 * shadow);\n    \n    float label_x = (rand(seed++) - .5) * .2;\n    \n    float shadow2 = n (\n        rect(uv + vec2(-.02, .02), vec2(label_x, -.08), vec2(.10, .05) ,.0, .0, E) +\n        tri(uv + vec2(-.02, .02), vec2(label_x + .05, -.08), vec2(.02, .045) ,.0, .0, E)\n    );\n    \n    c = mask(c, vec3(.0), .3 * shadow2);\n    \n    c = mask(c, vec3(.9, .9, .85), n(\n        rect(uv, vec2(label_x, -.08), vec2(.10, .05) ,.0, .0, E) +\n        tri(uv, vec2(label_x - .05, -.08), vec2(.02, .045) ,.0, .0, E)\n    ));\n    c = mask(c, vec3(.9, .9, .85) * .9, tri(uv, vec2(label_x + .05, -.08), vec2(.02, .045) ,.0, .0, E));\n\n    float price = 1. + floor(rand(seed++) * 4.);\n    \n    float x;\n    \n    for(float i = 0.; i < price; i++) {\n        x = label_x - .015 - (i - price * .5) * .021 + (uv.y + .08) * .10;\n        c = mask(c, vec3(.2), v(uv, x + sin(uv.y * 600.) * .008, .005, E) * rect(uv, vec2(label_x, -.08), vec2(.10, .02) ,.0, .0, E));\n        c = mask(c, vec3(.2), v(uv, x, .003, E) * rect(uv, vec2(label_x, -.08), vec2(.10, .025) ,.0, .0, E));\n    }\n\n    c = plank(c, uv, vec2(.0, -.15), vec2(.35, .1), seed, -.04);\n    \n    return c;\n}\n\nvec3 potion(vec3 c, vec2 uv, float seed) {\n\n    float bg, outside, shadow, liquid_mask;\n    \n    float form = rand(seed++);\n    \n    vec2 label_pos = vec2((rand(seed++) - .5) * .02, -.01 + (rand(seed++) - .5) * .02);\n    \n    if(form < .333) {\n        bg = ell(uv, vec2(.0, -.01), vec2(.2, .18), .0, .0, E);\n        outside = n(\n            ellh(uv, vec2(.0, -.01), vec2(.2, .18), .03, .0, E) +\n            ellh(uv, vec2(.01, -.03), vec2(.2, .18), .03, .0, E) *\n            rect(uv, vec2(-.05, .04), vec2(.03, .08), .0, .0, E * 5.) * .7\n        );\n        \n        shadow = ell(uv + vec2(-.03, .03), vec2(.0, -.01), vec2(.2, .18), .0, .0, E);\n        \n        liquid_mask = ell(uv, vec2(.0, -.01), vec2(.2, .18), .0, .0, E);\n    } else if(form < .66) {\n        bg = rect(uv, vec2(.0, -.01), vec2(.15, .18), .0, .0, E);\n        outside = n(\n            recth(uv, vec2(.0, -.01), vec2(.15, .18), .03, .0, E) +\n            recth(uv, vec2(.02, -.03), vec2(.15, .18), .03, .0, E) *\n            rect(uv, vec2(-.05, .04), vec2(.03, .08), .0, .0, E * 5.) * .7\n        );\n        \n        shadow = rect(uv + vec2(-.03, .03), vec2(.0, -.01), vec2(.15, .18), .0, .0, E);\n        \n        liquid_mask = rect(uv, vec2(.0, -.01), vec2(.15, .18), .0, .0, E);\n    } else {\n        bg = n (\n            tri(uv, vec2(.0, .01), vec2(.23, .23), .0, .0, E) -\n            rect(uv, vec2(.0, .15), vec2(.1, .1), .0, .0, E)\n        );\n        outside = n(\n            trih(uv, vec2(.0, .01), vec2(.23, .23), .04, .0, E) +\n            trih(uv, vec2(.01, -.02), vec2(.23, .23), .03, .0, E) *\n            rect(uv, vec2(-.03, .0), vec2(.03, .08), .0, .0, E * 5.) * .7\n        );\n        \n        shadow = tri(uv + vec2(-.03, .03), vec2(.0, .01), vec2(.23, .23), .0, .0, E);\n        \n        liquid_mask = tri(uv, vec2(.0, .01), vec2(.23, .23), .0, .0, E);\n        \n        label_pos += vec2(.0, -.03);\n    }       \n\n    bg = n(bg + rect(uv, vec2(.0, .10), vec2(.06, .07), .03, .0, E));\n\n    outside = n(\n        outside +\n        recth(uv, vec2(.0, .10), vec2(.06, .07), .03, .0, E) -\n        rect(uv, vec2(.0, .10), vec2(.03, .08), .0, .0, E) * 2.\n    );\n    \n    float cork = n (\n        tri(uv, vec2(.0, .105), vec2(.05, .1), .0, .5, E) -\n        rect(uv, vec2(.0, .08), vec2(.033, .06), .0, .0, E)\n    );\n    \n    shadow = n (\n        shadow +\n        rect(uv + vec2(-.03, .03), vec2(.0, .10), vec2(.06, .07), .03, .0, E) +\n        tri(uv + vec2(-.03, .03), vec2(.0, .105), vec2(.05, .1), .0, .5, E)\n    );\n    \n    float liquid_h = .1 + rand(seed++) * .2;\n    \n    float liquid = n (\n        liquid_mask * h(uv, -.1 + liquid_h * .5 * .5, liquid_h * .5, E)\n        - outside\n    );\n    \n    c = mask(c, vec3(.0), .3 * shadow);\n    \n    c = mask(c, mask(col(rand(seed++)), col(rand(seed++ + 20.)), (uv.y + .18 - liquid_h * .5) * 13.), liquid);\n    c = mask(c, CORK + .05 * rand(seed++), cork);\n    c = mask(c, vec3(1.), .3 * bg);\n    c = mask(c, vec3(1.), .7 * outside);\n    \n    float label_angle = (rand(seed++) - .5) * .05;\n    float label_width = .07 + rand(seed++) * .04;\n    \n    c = mask(c, vec3(.9, .9, .8 + rand(seed++) * .1), rect(uv, label_pos, vec2(label_width, .04), .0, label_angle, E));\n    \n    c = mask(c, vec3(.2 + (rand(seed++) - .5) * .1), writing(uv, label_pos, vec2(label_width, .04), .01, label_angle, seed++, E));\n    \n    c = shelf(c, uv, seed++);\n    \n    return c;\n}\n\nvec3 image(vec2 uv0, float t) {\n    vec3 c = vec3(.0);\n    \n    vec2 uv = uv0 - vec2(t * .1);\n    \n    c = background(uv);\n\n    float seed = floor(uv.x * 2.) * 493. + floor(uv.y * 2.) * 482.;\n    \n    c = potion(c, mod(uv, .5) - .25, seed);\n    \n    return c;\n}\n\nvec3 colorShiftImage(vec2 uv, float t0, float t1, float size) {\n    if (size < .00001)\n        return image(uv, t0);\n\n    vec3 c1 = image(uv + vec2(size * sin(t1), size * cos(t1)), t0);\n    vec3 c2 = image(uv + vec2(size * sin(t1 + 2.), size * cos(t1 + 2.)), t0);\n    vec3 c3 = image(uv + vec2(size * sin(t1 + 4.), size * cos(t1 + 4.)), t0);\n    return vec3(c1.x, c2.y, c3.z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy / iResolution.xy - 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 c = colorShiftImage(uv, iTime, iTime * 5., .0);\n    \n    fragColor = vec4(c,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}