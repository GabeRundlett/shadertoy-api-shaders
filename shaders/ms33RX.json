{
    "Shader": {
        "info": {
            "date": "1677702145",
            "description": "Mediterran reef and waves with volumetric clouds.\nSome code borrowings from IQ clouds.\nUse mouse X to change camera angle.",
            "flags": 32,
            "hasliked": 0,
            "id": "ms33RX",
            "likes": 9,
            "name": "Mediterran reef and waves 2",
            "published": 3,
            "tags": [
                "sea",
                "clouds"
            ],
            "usePreview": 0,
            "username": "guil",
            "viewed": 291
        },
        "renderpass": [
            {
                "code": "\n#define time -iTime\n             \n\n//reef/waves combined field\nvec3 map(in vec3 p) {\n\t\n\tfloat s=2.,e,f,o;\n    vec3 q=p,r=p;\n    vec3 n = vec3(0);\n\tvec2 l = vec2(2.);\n\tfor(e=f=p.y;s<5e1;s*=1.3)\n            p.xz*=m2,\n            n.xy*=m2,\n            q=p*s+n,\n            r=p*s+n,\n            r.x+=iTime*.5*s,\n            e+=.35*abs(dot(sin(r.xz*.1)/s,.8*l)),\n            f+=.2+.2*(dot(sin(q.xz*.5)/s,l)),\n            n-=cos(q);\n\te+=1.3;\n    return vec3(min(e,f),f,e);\n}\n\nvec3 normalRocks(in vec3 p)\n{\n\tconst vec2 e = vec2(0.004, 0.0);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy).y - map(p - e.xyy).y,\n        .008,\n\t\tmap(p + e.yyx).y - map(p - e.yyx).y\n\t\t));\n}\n\nvec3 normalSea(in vec3 p)\n{\n\tconst vec2 e = vec2(0.005, 0.0);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy).z - map(p - e.xyy).z,\n        .008,\n\t\tmap(p + e.yyx).z - map(p - e.yyx).z\n\t\t));\n}\n\n\nvec3 sky(vec2 uv)\n{\t\n       \n    uv = .5+.5*uv;   \n    return texture( iChannel0, uv,0.).rgb;\n    \n}\n\nvec3 march(in vec3 ro, in vec3 rd)\n{\n\tconst float maxd = 50.0;\n\tconst float precis = 0.001;\n    float h = 0.0;\n    float t = 0.0;\n    float dt = .2;\n\tfloat res = -1.0;\n    for(int i = 0; i < 128; i++)\n    {\n        if(h < precis*t || t > maxd) break;\n\t    h = map(ro + rd * t).x;\n        t += h*dt;\n        dt *= 1.015;\n    }\n    if(t < maxd) res = t;\n    return vec3(res,map(ro + rd * t).yz);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    \n\tvec3 col = vec3(0.);   \t\n    vec3 li = sundir;\n    vec2 uv = fragCoord/iResolution.xy -.5;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n   \n\n    float zoom=1.;   \n    vec3 ro=1.*vec3(sin(3.*m.x),0.*m.y+2.,cos(3.*m.x));\n    vec3 rd=normalize(vec3(uv.xy,zoom));\n    vec3 target=vec3(0,2.,0);\n\n    vec3 w=normalize(target-ro);\n    vec3 u=normalize(cross(w,vec3(0,1,0)));\n    vec3 v=normalize(cross(w,-u));\n\n    rd=mat3(u,v,w)*rd;\n    \n    \n    vec3 a = march(ro, rd);\n    float t = a.x;\n    float dh = a.z-a.y;\n    if(t > 0.)\n    {\n        \n        vec3 pos = ro + t * rd;       \n        float k=map(pos).z*1.+1.3;       \n        vec3 nor = normalRocks(pos);\n        float r = max(dot(nor, li),0.1)/2.5;\n        col =r*vec3(k*k, k, .8)+.1*exp(-50.*dh*dh)+.05;\n        if(dh<0.01){\n        \tvec3 nor = normalSea(pos+dh*rd);\n        \tnor = reflect(rd, nor);\n            col +=vec3(0.9,.2,.05)*dh*.5;\n        \tcol += pow(max(dot(li, nor), 0.0), 5.0)*vec3(.7);\n            uv.y*=-1.;\n        \tcol +=.3* sky(uv);\n            \n        }\n\t    col = .1+col;\n        \n\t}\n    else //sky\n        col = sky(uv);\n    \n   \tfragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const vec3 sundir = normalize( vec3(-1.,.5,-1.) );\nconst vec3 suncol = vec3(1.,.8,.5);\n\nmat2 m2 = mat2(0.8,  0.6, -0.6,  0.8);\n\n\nmat2 r2D(float a)\n{\n\tfloat si = sin(a);\n\tfloat co = cos(a);\n\treturn mat2(si, co, -co, si);\n}\n\nfloat fbm(vec2 p)//ground\n{\n    float s=.3;\n    mat2 m = r2D(1.);\n    vec2 r= vec2(0.);\n    for(int i=0;i<7;i++)r+=sin(p), p=m*(p*s+.2*r+.1),s*=1.6;\n    return r.x+r.y;\n}\n\nfloat fbm1(vec2 p)//grass\n{\n    float s=2.;\n    mat2 m = r2D(1.);\n    vec2 r= vec2(0.);\n    for(int i=0;i<8;i++)r+=(sin(p.yx+.5))/s, p=m*p*s+cos(r.yx*s), s*=1.02;\n    return (r.x+r.y)/s;\n}\n\n\nfloat fbm2(vec3 p, float t)//clouds\n{\n    float s=1., r= 3.9;\n    p*=.5;\n    p.xz *=.4;\n    //mat2 m = r2D(1.);\n    vec3 n = vec3(1);\n    for(int i=0;i<8;i++)\n        p.xy *= m2,\n        p.xz *= m2,        \n        n+=.8*cos(p+.05*t), \n        r+=(dot(sin(p.zxy*s+n)/s,vec3(1.))),\n        s*=1.4;\n    \n    return r*.7;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\nconst float sc =1.;\nconst float low = 7.;\nconst float high = 12.;\nconst float rt = 6e3;\n\nfloat f(vec3 p)\n{\n    p *= sc;    \n    p.y += rt;\n    p.y = length(p)-rt;\n    p.z +=.2*iTime;\n    float d =fbm2(p,iTime)/sc;\n    return d+exp(5.*(low-p.y))+exp(p.y-high)+exp(-.4+.5*sin(.01*p.x+1.)*cos(.03*p.z-.2));\n}\n\nvec2 raymarch( vec3 ro, vec3 rd)\n{\n    int st = 64;\n    if(rd.y<-0.1)return vec2(0.); \n    float t=low/(.05+rd.y),h=(high-low)/(.1+rd.y)/float(st),d=0.,c=1.,dd,k=3.,e,a=0.;\n    vec3 p;\n    for(int i=0;i<st;++i)\n    {\n        p=ro+rd*t;\n        d=f(p); \n        e=1.-exp(-d*d);\n        c*=e;\n        t+=k*h*e;\n        a+=(f(p+sundir)-d*.5)*(1.-e)*c;\n        if(t>400.)return vec2(0.); \n    }\n    \n    return vec2(a*.2,(1.-c)*.8);\n}\n\nvec4 render( in vec3 ro, in vec3 rd )//modified from IQ clouds\n{\n    // background sky         \n    float sun = clamp( dot(sundir,rd), 0.0, 1.0 );    \n    vec3 col = vec3(0.6,0.6,0.78) - rd.y*0.5*vec3(1.0,0.4,.05) ;    \n    col += 0.4*suncol*pow( sun, 8.0 ); \n    col *=.9;\n    // clouds        \n    vec2 res = raymarch( ro, rd);\n    float k = res.x, c=res.y;\n    if(c>.0)\n       col *= 1.-.1*c,\n       col += (.2+3.5*k)*c*suncol,\n       col += vec3(0.2,0.08,0.04)*pow( sun, 3.0 )*c;    \n    return vec4( col, 1.0 );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy -.5;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n   \n\n    float zoom=1.;   \n    vec3 ro=1.*vec3(sin(3.*m.x),0.*m.y+2.,cos(3.*m.x));\n    vec3 rd=normalize(vec3(uv.xy,zoom));\n    vec3 target=vec3(0,2.,0);\n\n    vec3 w=normalize(target-ro);\n    vec3 u=normalize(cross(w,vec3(0,1,0)));\n    vec3 v=normalize(cross(w,-u));\n\n    rd=mat3(u,v,w)*rd;\n    \n    fragColor = render( ro, rd );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}