{
    "Shader": {
        "info": {
            "date": "1581447189",
            "description": "Direction = angular quantity -> hard to interpolate or filter.\nWIP visu experiments about unwrapped-diffusion ( better use accelerator: cf plugin )\n- clear/dark = extrema (vanish as surf becomes minimal)\n- white = flat zones ( |dÂ²f|=0)\n- checker = wrapli\n",
            "flags": 48,
            "hasliked": 0,
            "id": "tt3Szf",
            "likes": 4,
            "name": "filtering vector field -analysis",
            "published": 3,
            "tags": [
                "hue",
                "interpolation",
                "phasor",
                "chrominance"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 513
        },
        "renderpass": [
            {
                "code": "// Forked from https://shadertoy.com/view/Wl3SDM\n\n//#define T(d) texelFetch(iChannel0, ivec2(d+u), 0 ).x\n#define T(d) fract( texture(iChannel0,U+d/R).x - v + .5 )-.5 + v\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 U = u/R, d = vec2(1,0);\n    vec4 BG = vec4(0);\n    \n    float eps=1e-3, eps2 = 1e-11, t,c,\n        v = texture(iChannel0,U).x; //T() ;\n    // --- draw hue\n    O = hue( v ); \n    // --- draw differential geometry curves\n    vec2  B = vec2( T(d)+T(-d), T(d.yx)+T(-d.yx) ) /2. - v,\n          D = vec2( T(d)-T(-d), T(d.yx)-T(-d.yx) ) /2.;\n    float C = ( T(d)+T(-d)+T(d.yx)+T(-d.yx)+T(d.xx)+T(-d.xx)+T(vec2(1,-1))+T(vec2(-1,1)))/8. - v;\n    c = B.x*B.y; t = D.x*D.y;\n  //O *= length(B); return;\n    O = .5*O;\n  //if (abs(C) < 1e-6) O = vec4(1,0,0,0); // all !\n  //if (abs(C) > 1e-6) O = vec4(sign(C),-sign(C),0,0);\n  vec2 z = floor(u/4.); float chk = mod(z.x+z.y,2.); // for checkers\n  bvec2 bD = lessThan(abs(D),vec2(1e-3)); // 1st derivative ~0\n\nif (bD.x||bD.y) // some 1st derivatives are ~0\n//if (abs(t*t) < 1e-6) \n      O = vec4( \n           bD.x && B.x> eps || bD.y && B.y> eps, // valley: red\n           bD.x && B.x<-eps || bD.y && B.y<-eps, // ridge: green\n           //chk,0); \n           bD.x && bD.y ? chk  // 2 tangents = 0: blue checker\n          : 0.,0);             // black: inflexions ?\n  //if (abs(B.x+B.y) < 1e-6 ) O++; // white: minimal surface (all ! )\n#if 1\n    O +=  c > eps2 ? .3*sign(B.x)   // positive / negative curvature\n        : abs(c)<eps2 ? .5 : 0. ;   // white: flat areas (possibly with a gradient)\n      //: min(B.x*B.x,B.y*B.y) < eps2 ? 1. : 0. ;\n      //: max(B.x*B.x,B.y*B.y) < eps2 ? 1. : 0. ;\n      //: abs(dot(B,B))/2.     < eps2 ? 1. : 0. ;\n#endif\n    \n    // --- wrap zone\n    if (abs(v) < 3./R.y) O = vec4(chk); // white checker\n \n    // --- vector field\n  //v += .3*iTime; in the case of phasor noise, phase is just up to a constant\n    float scale = R.y/8.;\n    vec2 n = vec2(cos(6.283*v),sin(6.283*v)),\n         p = fract(scale*U)*2.-1.; // p = local centered coords in cells\n    float l = length(n), f,\n          x = (n.x*p.y-n.y*p.x) / l,\n          w = dot(n,p) / l;         // option: arrow points to vector dir\n    f  = smoothstep(scale*3./R.y, 0., abs(x)+.1*w ); // display vector line\n    f *= smoothstep(scale*3./R.y, 0., abs(w)- l ); // optional: show vector length\n    O += .5*f;\n    \n    if keyToggle(32) {\n      //O = vec4( .5+ texture(iChannel0,U).x );                        // B&W\n      //O = vec4( .5+.5* sin(50.*texture(iChannel0,U).x ));            // isovals\n        O = vec4( .5+.5* sin(300.*U.x+6.283*texture(iChannel0,U).x )); // phasor\n     // O *=      .5+.5* sin(300.*U.x+6.283*texture(iChannel0,U).x );  // phasor (color)\n     // vec2 V = U-.5*R/R.y; O = vec4( .5+.5* sin(200.*atan(V.y,V.x)*length(V) +6.283*texture(iChannel0,U).x )); // phasor\n        BG = vec4(0,1,0,1);\n    }\n    \n    //if (int(u) == int(R)/2  ) O = BG;\n    //if (int(u) == int(R*.83)) O = BG; \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//#define T(d)        texture(iChannel0,U+d/R)\n  #define T(d) fract( texture(iChannel0,U+d/R) - T + .5 )-.5 + T\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U /= R;\n    \n    //O = texture(iChannel0,U,1.);    // linear diffusion\n    \n#if 0\n    vec2 d = vec2(1,0);               // --- unwrapped diffusion (cross pattern)\n    vec4 T  = texture(iChannel0,U),   // first unwrap the neighborhood\n         T1 = T( d),                  // to never filter cross-wrap.\n         T2 = T(-d),\n         T3 = T( d.yx),\n         T4 = T(-d.yx);\n    O = ( T1+T2+T3+T4 ) / 4.;\n#else\n    O-=O; int N = 5;                  // --- unwrapped diffusion (NxN filter)\n    vec4 T  = texture(iChannel0,U);   // first unwrap the neighborhood\n    for (int k=0; k < N*N; k++)       // to never filter cross-wrap.\n        O += T(vec2( k%N -N/2, k/N -N/2 ));\n  //O = fract( O - T + .5 )-.5 + T;\n    O /= float(N*N);\n  //O = fract( O - T + .5 )-.5 + T;\n#endif\n    \n  //O = .5 + sign(O-.5)*sqrt(2.*abs(O-.5));\n  //O = .5*sin(6.263*O);\n    \n    if (iChannelResolution[2].x < 10.) { O-=O; return; } // wait texture\n    if (iFrame < 1 || texelFetch(iChannel0,ivec2(0),0)==vec4(0) ) { // --- init state\n        float  k = 1.; // try 3 or 8 :-p\n        // k = U.x<.5 ? .5+8.*(.5-U.x) : U.x-.5<.33 ? 1. : 3.;\n        \n      //O.x = 3.*rgb2hls(texture(iChannel1,U)).x; return; // hue from true image\n      //T = texture(iChannel2,U,0.); O.x = T.a > .9 ? T.x : .3*T.x; return; // isolated random dots      \n      //O.x = abs(U.y-.5)>.25 ? U.x : 2.*U.x; return; // 1 vs 2 rainbow -> bipole\n      //U -= .5; O.x = 20.*length(U); return;         // concentric, no pole\n      //U -= .5; O.x = 4.5*atan(U.x,-U.y); return;    // radial, 1 pole + bad cycling\n\n      //vec2 V = texture(iChannel2,U+.0,5.).xy - .5;     // dir field from rand texture\n      //vec2 V = textureLod(iChannel2,U+.0,2.5).xy - .5;     // dir field from rand texture\n        vec2 V = textureLod(iChannel2,U+.0,2.).xy - .5;     // dir field from rand texture\n      //k = 8.*U.x;\n        //if (U.x<.5) { O.x = k*8.*V.x; return; }       // left: no pole\n      //if (U.x<.5) { O.x = 9.*U.x;  if (U.y>.5) O.x += .5;return; }  // left: gradiant + PI-jump\n      //V *= sin(20.*U.x);                            // strip modulation\n        \n        O.x = atan(V.y,V.x);                          // dir = norm rand texture\n      //O.x = atan(dFdy(V.x),dFdx(V.x));              // gradients of rand texture.x\n      //O.x = atan(dFdx(V.x),-dFdy(V.x));             // isolines of rand texture.x\n        \n        O.x *= k/6.2816;                              // hue on [0,1]\n        return;\n    }\n    \n#if 0 // sources\n    if (length(U-.5) < .05 ) O.x = 1.;\n    if (length(U-vec2(.8,.3)) < .05 ) O.x = 1.;\n    if (length(U-.8) < .05 ) O.x = .5;\n    if (length(U-.3) < .05 ) O.x = .7;\n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define R iResolution.xy\n\n#define keyToggle(a)  ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\nvec4 rgb2hls(vec4 C) {\n    float r =C.r, g=C.g, b=C.b,\n        M = max(r,max(g,b)),\n        m = min(r,min(g,b)),\n        l = (M + m) / 2.,\n        d =  M - m;\n\n    if (M == m) return vec4(0,l,0,0);\n    \n    C.y = l;\n    C.z = .5* d / min(l, 1.-l);\n    C.x =  r > max(g,b) ? (g - b) / d + (g < b ? 6. : 0.)\n         : g > b        ? (b - r) / d + 2.\n         :                (r - g) / d + 4.;\n    C.x /= 6.;\n    return C;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}