{
    "Shader": {
        "info": {
            "date": "1459352123",
            "description": "More train experiments (see the source)",
            "flags": 32,
            "hasliked": 0,
            "id": "4dtXW4",
            "likes": 8,
            "name": "Complex Tunnels",
            "published": 3,
            "tags": [
                "tunnel",
                "lighting",
                "train",
                "interactivity"
            ],
            "usePreview": 1,
            "username": "dr2",
            "viewed": 821
        },
        "renderpass": [
            {
                "code": "// \"Complex Tunnels\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Shader tunnels come in various forms. Some are based on 2D imagery\n  designed to give apparent depth. Others use 3D imagery, but the\n  horizontal (and sometimes vertical) coordinates are shifted with depth\n  to mimic effects such as turns. Such methods reduce computation but\n  are limited in what they can do. Here the tunnels are really 3D, and\n  to show what is going on the tunnel walls are partly open. Thomas the\n  engine (3 or 5 of them) travels around the entire track. Speed and view can\n  be controlled; the mouse helps looking around (in some views), and the\n  engine being followed changes.\n*/\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s,\n     Fbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrOBox2Df (vec2 p, vec2 b)\n{\n  return length (max (abs (p) - b, 0.));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst float txRow = 64.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\n// Set = 1 in BOTH shaders for more fun. WARNING: browser crashes reported\n#define LONG_TRACK 0\n//#define LONG_TRACK 1\n\n#if LONG_TRACK\n#define N_ENG 5\n#else\n#define N_ENG 3\n#endif\n\n// Debugging: Set = 0 (here only) to disable tunnel rendering\n#define SHOW_TUN 1\n//#define SHOW_TUN 0\n\nvec4 pCar[N_ENG], pVu;\nvec3 qHit, ltExDir, bgCol;\nvec2 rlSize, tunSize;\nfloat dstFar, tCur, szFac, trMov, rgHSize, trkWid, wallThk, bWid, bLen,\n   dH, dR, dV, dT;\nint idObj, idObjGrp, riding;\n\nconst int idEng = 1, idCabin = 2, idCoal = 3, idBase = 4, idBand = 5, idAxle = 6,\n   idRoof = 7, idWheel = 8, idSpoke = 9, idCrod = 10, idFunl = 11, idFunt = 12,\n   idStripe = 13, idFLamp = 14, idBLamp = 15, idCpl = 16, idGrnd = 21,\n   idRail = 22, idVrt = 23, idHrz = 24, idTun = 25, idLight = 26;\nconst int dirNS = 0, dirEW = 1, dirSW = 2, dirNW = 3, dirSE = 4, dirNE = 5,\n   dirX = 6;\n\nvoid SimpSeg (vec3 q, int indx)\n{\n  vec3 qq;\n  if (indx == dirEW) q.xz = q.zx;\n  else if (indx == dirNW) q.z *= -1.;\n  else if (indx == dirSE) q.x *= -1.;\n  else if (indx == dirNE) q.xz *= -1.;\n  qq = q;  qq.y -= tunSize.y - 0.5 * rlSize.y;\n  if (indx <= dirEW) {\n    q.x = abs (q.x);\n  } else {\n    q.xz += 0.5;  q.x = abs (length (q.xz) - 0.5);\n  }\n  q.xy -= vec2 (trkWid, rlSize.y);\n  dR = PrOBox2Df (q.xy, rlSize);\n#if SHOW_TUN\n  q.xy -= vec2 (- trkWid, - rlSize.y + tunSize.y);\n  dT = max (PrBox2Df (q.xy, tunSize + vec2 (0.5 * wallThk)),\n     - PrBox2Df (q.xy, tunSize - vec2 (0.5 * wallThk)));\n  dT = max (dT, - (abs (q.y) - 0.6 * tunSize.y));\n  if (indx <= dirEW) {\n    q.x -= tunSize.x;\n    q.z = abs (q.z) - 0.5;\n    dV = PrCylDf (q.xzy, bWid, tunSize.y);\n    q.xy -= vec2 (- tunSize.x, tunSize.y - 0.5 * bWid);\n    dH = PrCylDf (q.yzx, bWid, bLen);\n  } else {\n    q = qq;\n    q.xz = q.zx;  q.x = abs (q.x) - tunSize.x;  q.z = q.z + 0.5;\n    dV = PrCylDf (q.xzy, bWid, tunSize.y);\n    q.xy -= vec2 (- tunSize.x, tunSize.y - 0.5 * bWid);\n    dH = PrCylDf (q.yzx, bWid, bLen);\n    q = qq;  q.x = abs (q.x) - tunSize.x;  q.z = q.z + 0.5;\n    dV = min (dV, PrCylDf (q.xzy, bWid, tunSize.y));\n    q.xy -= vec2 (- tunSize.x, tunSize.y - 0.5 * bWid);\n    dH = min (dH, PrCylDf (q.yzx, bWid, bLen));\n  }\n#endif\n}\n\nvoid CrossSeg (vec3 q, int indx)\n{\n  vec3 qq;\n  qq = q;\n  q = qq;  q.y -= rlSize.y;  qq = q;\n  q.x = abs (q.x) - trkWid;  q.z += 0.5;\n  dR = PrOBox2Df (q.xy, rlSize);\n  q = qq;  q.xz = q.zx;  q.z += 0.5;  q.x = abs (q.x) - trkWid;\n  dR = min (dR, PrOBox2Df (q.xy, rlSize));\n  q = qq;  q.xz = abs (q.xz) - trkWid + 1.75 * rlSize.x;\n  dR = max (dR, - min (PrBox2Df (q.xz, vec2 (trkWid, 0.75 * rlSize.x)),\n     PrBox2Df (q.zx, vec2 (trkWid, 0.75 * rlSize.x))));\n#if SHOW_TUN\n  q = qq;\n  q.y -= tunSize.y - rlSize.y;\n  dT = max (PrBox2Df (q.xy, tunSize + vec2 (0.5 * wallThk)),\n      - PrBox2Df (q.xy, tunSize - vec2 (0.5 * wallThk)));\n  q.xz = q.zx;\n  dT = min (dT, max (PrBox2Df (q.xy, tunSize + vec2 (0.5 * wallThk)),\n      - PrBox2Df (q.xy, tunSize - vec2 (0.5 * wallThk))));\n  dT = max (dT, - PrBoxDf (q, vec3 (tunSize.x + 1.1 * wallThk,\n     tunSize.y - 0.5 * wallThk, tunSize.x + 1.1 * wallThk)));\n  dT = max (dT, - (abs (q.y) - 0.6 * tunSize.y));\n  qq.y -= tunSize.y - rlSize.y;\n  q = qq;  q.xz = abs (q.xz) - tunSize.x - wallThk;\n  dV = PrCylDf (q.xzy, bWid, tunSize.y);\n  q = qq;  q.xz = abs (q.xz) - vec2 (tunSize.x, 0.5);\n  dV = min (dV, PrCylDf (q.xzy, bWid, tunSize.y));\n  q = qq;  q.xz = q.zx;  q.xz = abs (q.xz) - vec2 (tunSize.x, 0.5);\n  dV = min (dV, PrCylDf (q.xzy, bWid, tunSize.y));\n  qq.y -= tunSize.y - 0.5 * bWid;\n  q = qq;  q.x = abs (q.x) - 0.5;\n  dH = PrCylDf (q.yxz, bWid, bLen);\n  q = qq;  q.xz = q.zx;  q.x = abs (q.x) - 0.5;\n  dH = min (dH, PrCylDf (q.yxz, bWid, bLen));\n  q = qq;  q.xz = Rot2D (q.xz, 0.25 * pi);\n  dH = min (dH, min (PrCylDf (q.yzx, bWid, 1.42 * bLen),\n     PrCylDf (q.yxz, bWid, 1.42 * bLen)));\n#endif\n}\n\nint GetIx (int isq)\n{\n  int indx;\n  indx = -1;\n#if LONG_TRACK\n  if (isq == 1 || isq == 2 || isq == 3 || isq == 4 || isq == 13 ||\n     isq == 16 || isq == 19 || isq == 22 || isq == 31 || isq == 34) indx = dirEW;\n  else if (isq == 6 || isq == 11 || isq == 24 || isq == 26 || isq == 27 ||\n     isq == 29) indx = dirNS;\n  else if (isq == 12 || isq == 30 || isq == 33) indx = dirSE;\n  else if (isq == 17 || isq == 32 || isq == 35) indx = dirSW;\n  else if (isq == 0 || isq == 15 || isq == 18) indx = dirNE;\n  else if (isq == 5 || isq == 14 || isq == 23) indx = dirNW;\n  else if (isq == 20 || isq == 21) indx = dirX;\n#else\n  if (isq == 6 || isq == 8 || isq == 20 || isq == 23 || isq == 26 ||\n     isq == 29) indx = dirNS;\n  else if (isq == 1 || isq == 13 || isq == 15 || isq == 16 || isq == 33 ||\n     isq == 34) indx = dirEW;\n  else if (isq == 35) indx = dirSW;\n  else if (isq == 2 || isq == 17) indx = dirNW;\n  else if (isq == 12 || isq == 32) indx = dirSE;\n  else if (isq == 0) indx = dirNE;\n  else if (isq == 14) indx = dirX;\n#endif\n  return indx;\n}\n\nfloat TrackDf (vec3 p)\n{\n  vec3 q, qh;\n  vec2 ip;\n  float dMin, d, dUsq, sqWid;\n  int indx, isq;\n  bLen = tunSize.x + bWid;\n  dMin = dstFar;\n  ip = floor (p.xz);\n  q = p;  q.xz = fract (q.xz) - vec2 (0.5);\n  isq = int (2. * rgHSize * mod (ip.y + rgHSize, 2. * rgHSize) +\n     mod (ip.x + rgHSize, 2. * rgHSize));\n  indx = GetIx (isq);\n  d = dstFar;\n  if (indx >= 0 && indx <= dirX) {\n    qh = q;\n    q.y -= 0.5 * rlSize.y;\n    if (indx < dirX) SimpSeg (q, indx);\n    else CrossSeg (q, indx);\n    sqWid = 0.4999;\n    dUsq = max (PrOBox2Df (p.xz, vec2 (2. * sqWid * rgHSize)),\n       PrBox2Df (q.xz, vec2 (sqWid)));\n    dR = max (dR, dUsq);\n    if (dR < dMin) { dMin = dR;  idObj = idRail; }\n#if SHOW_TUN\n    dT = max (dT, dUsq);\n    if (dT < dMin) { dMin = dT;  idObj = idTun; }\n    dV = max (dV, dUsq);\n    if (dV < dMin) { dMin = dV;  idObj = idVrt; }\n    dH = max (dH, dUsq);\n    if (dH < dMin) { dMin = dH;  idObj = idHrz; }\n    q = qh;  q.y -= 2. * tunSize.y - bWid;\n    d = max (PrCylDf (q.xzy, 1.1 * bWid, 0.6 * bWid), dUsq);\n    if (d < dMin) { dMin = d;  idObj = idLight; }\n#endif\n  }\n  return dMin;\n}\n\nfloat TrackRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 srd, dda, h;\n  float dHit, d;\n  srd = - sign (rd.xz);\n  dda = - srd / (rd.xz + 0.0001);\n  dHit = max (0., PrBox2Df (ro.xz, vec2 (rgHSize)));\n  for (int j = 0; j < 160; j ++) {\n    p = ro + dHit * rd;\n    h = fract (dda * fract (srd * p.xz));\n    d = TrackDf (p);\n    dHit += min (d, 0.001 + max (0., min (h.x, h.y)));\n    if (d < 0.0001 || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d > 0.0001) dHit = dstFar;\n  return dHit;\n}\n\nfloat EngDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, aw, a, sx, wRad, tw;\n  wRad = 0.8;\n  tw = 214. * szFac * trkWid;\n  q = p;\n  q -= vec3 (0., -0.2, 0.5);\n  d = max (PrCapsDf (q, 1., 2.), - (q.z + 1.7));\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + idEng; }\n  q = p;  q.z = abs (q.z - 0.85);  q -= vec3 (0., -0.2, 1.8);\n  d = PrCylDf (q, 1.05, 0.05);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + idBand; }\n  q = p;  q -= vec3 (0., -1.3, -0.25);\n  d = PrBoxDf (q, vec3 (1., 0.1, 3.2));\n  q = p;  q -= vec3 (0., -1.4, 3.);\n  d = min (d, PrBoxDf (q, vec3 (1.1, 0.2, 0.07)));\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + idBase; }\n  q.x = abs (q.x);  q -= vec3 (0.6, 0., 0.1);\n  d = PrCylDf (q, 0.2, 0.1);\n  q = p;  q -= vec3 (0., -2.4, -1.75);\n  d = min (d, max (PrCylDf (q, 4., 0.65), - (q.y - 3.75)));\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + idRoof; }\n  q = p;  q -= vec3 (0., 0.01, -1.75);\n  d = max (max (PrBoxDf (q, vec3 (1., 1.4, 0.6)),\n     - PrBoxDf (q - vec3 (0., 0., -0.2), vec3 (0.95, 1.3, 0.65))),\n     - PrBoxDf (q - vec3 (0., 0.7, 0.), vec3 (1.1, 0.4, 0.5)));\n  q.x = abs (q.x);  q -= vec3 (0.4, 1., 0.4);\n  d = max (d, - PrBoxDf (q, vec3 (0.35, 0.15, 0.3)));\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + idCabin;  qHit = q; }\n  q = p;  q -= vec3 (0., -0.5, -3.15);\n  d = PrBoxDf (q, vec3 (1., 0.7, 0.3));\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + idCoal;  qHit = q; }\n  q = p;  q -= vec3 (0., -1.4, -3.5);\n  d = PrCylDf (q.xzy, 0.4, 0.03);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + idCpl; }\n  q = p;  q.xz = abs (q.xz);  q -= vec3 (tw - 0.12, -1.4, 1.1);\n  d = PrCylDf (q.zyx, wRad, 0.1);\n  aw = - trMov / (szFac * wRad);\n  if (d < dMin) {\n    d = min (max (min (d, PrCylDf (q.zyx - vec3 (0.,0., -0.07), wRad + 0.05, 0.03)),\n       - PrCylDf (q.zyx, wRad - 0.1, 0.12)), PrCylDf (q.zyx, 0.15, 0.10));\n    if (d < dMin) { dMin = d;  idObj = idObjGrp + idWheel; }\n    q = p;  q.x = abs (q.x);  q -= vec3 (tw - 0.17, -1.4, 1.1 * sign (q.z));\n    q.yz = q.yz * cos (aw) + q.zy * sin (aw) * vec2 (-1., 1.);  \n    a = floor ((atan (q.y, q.z) + pi) * 8. / (2. * pi) + 0.5) / 8.;\n    q.yz = q.yz * cos (2. * pi * a) + q.zy * sin (2. * pi * a) * vec2 (-1., 1.);\n    q.z += 0.5 * wRad;\n    d = PrCylDf (q, 0.05, 0.5 * wRad);\n    if (d < dMin) { dMin = d;  idObj = idObjGrp + idSpoke; }\n  }\n  q = p;  sx = sign (q.x);  q.x = abs (q.x);\n  q -= vec3 (tw + 0.08, -1.4, 0.);\n  aw -= 0.5 * pi * sx; \n  q.yz -= 0.3 * vec2 (cos (aw), - sin (aw));\n  d = PrCylDf (q, 0.04, 1.2);\n  q.z = abs (q.z);  q -= vec3 (-0.1, 0., 1.1);\n  d = min (d, PrCylDf (q.zyx, 0.06, 0.15));\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + idCrod; }\n  q = p;  q.z = abs (q.z);  q -= vec3 (0., -1.4, 1.1);\n  d = PrCylDf (q.zyx, 0.1, tw - 0.1);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + idAxle; }\n  q = p;  q -= vec3 (0., 1.1, 2.15);  d = PrCylDf (q.xzy, 0.3, 0.5);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + idFunl; }\n  q = p;  q -= vec3 (0., 1.5, 2.15);\n  d = max (PrCylDf (q.xzy, 0.4, 0.15), - PrCylDf (q.xzy, 0.3, 0.2));\n  q = p;  q -= vec3 (0., 0.8, 0.55);\n  d = min (d, PrCapsDf (q.xzy, 0.3, 0.2));\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + idFunt; }\n  q = p;  q.x = abs (q.x);  q -= vec3 (1., -0.2, 0.85);\n  d = PrBoxDf (q, vec3 (0.05, 0.1, 1.8));\n  q = p;  q.x = abs (q.x);  q -= vec3 (1., -0.2, -1.75);\n  d = min (d, PrBoxDf (q, vec3 (0.05, 0.1, 0.6)));\n  q = p;  q.x = abs (q.x);  q -= vec3 (1., -0.2, -3.15);\n  d = min (d, PrBoxDf (q, vec3 (0.05, 0.1, 0.3)));\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + idStripe; }\n  q = p;  q -= vec3 (0., -0.2, 3.5);\n  d = PrCylDf (q, 0.2, 0.1);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + idFLamp; }\n  q = p;  q.x = abs (q.x) - 0.4;  q -= vec3 (0., -0.7, -3.5);\n  d = PrCylDf (q, 0.15, 0.1);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + idBLamp; }\n  return dMin;\n}\n\nfloat SceneDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, db;\n  dMin = dstFar;\n  db = PrOBox2Df (p.xz, vec2 (0.999 * rgHSize));\n  d = max (abs (p.y + 0.001) - 0.001, db);\n  if (d < dMin) { dMin = d;  idObj = idGrnd; }\n  dMin /= szFac;\n  for (int k = 0; k < N_ENG; k ++) {\n    q = p;\n    q -= pCar[k].xyz;\n    q /= szFac;\n    d = PrCylDf (q.xzy, 4., 2.2);\n    if (d < dMin) {\n      q.xz = Rot2D (q.xz, pCar[k].w);\n      idObjGrp = (k + 1) * 256;\n      dMin = EngDf (q, dMin);\n    }\n }\n  dMin *= szFac;\n  return dMin;\n}\n\nfloat SceneRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = SceneDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin;\n  dMin = dstFar;\n  dMin = min (dMin, TrackDf (p));\n  dMin = min (dMin, SceneDf (p));\n  return dMin;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = 0.0001 * vec3 (1., -1., 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec4 EngCol (vec3 vn)\n{\n  vec4 objCol;\n  int ig, id;\n  const vec4 cCol = vec4 (1., 0., 0., 1.);\n  vec4 cR = cCol.xyyw, cY = cCol.xxyw, cG = cCol.yxyw, cB = cCol.yyxw,\n     cCy = cCol.yxxw;\n  vec4 cC[3];\n  ig = idObj / 256;  id = idObj - 256 * ig;\n  if      (ig == 1) { cC[0] = cG;   cC[1] = cY;   cC[2] = cB;  }\n  else if (ig == 2) { cC[0] = cY;   cC[1] = cB;   cC[2] = cR;  }\n  else if (ig == 3) { cC[0] = cR;   cC[1] = cCy;  cC[2] = cG;  }\n  else if (ig == 4) { cC[0] = cB;   cC[1] = cR;   cC[2] = cCy; }\n  else if (ig == 5) { cC[0] = cCy;  cC[1] = cG;   cC[2] = cY;  }\n  if (id == idEng || id == idCabin || id == idCoal) objCol = cC[0];\n  else if (id == idBase || id == idAxle)\n     objCol = vec4 (0.3, 0.2, 0.2, 0.6);\n  else if (id == idRoof || id == idCpl || id == idFunl && vn.y <= 0.9)\n     objCol = cC[1];\n  else if (id == idFunl && vn.y > 0.9) objCol = vec4 (0.03, 0.03, 0.03, 0.1);\n  else if (id == idWheel || id == idSpoke) objCol = vec4 (0.6, 0.7, 0.7, 1.);\n  else if (id == idCrod) objCol = cY;\n  else if (id == idStripe || id == idFunt || id == idBand) objCol = cC[2];\n  else if (id == idFLamp) objCol = (mod (tCur + 0.667 * float (ig), 2.) < 1.) ?\n     vec4 (1., 1., 1., -1.) : vec4 (0.6, 0.6, 0.6, -1.);\n  else if (id == idBLamp) objCol = vec4 (1., 0.6, 0., -1.);\n  return objCol;\n}\n\nvec4 TrackCol (vec3 ro, vec3 vn)\n{\n  vec4 objCol;\n  if (idObj == idGrnd) objCol = vec4 (bgCol, 0.);\n  else if (idObj == idRail) objCol = vec4 (0.7, 0.7, 0.7, 0.8);\n  else if (idObj == idVrt) objCol = vec4 (0.5, 0.3, 0., -2.);\n  else if (idObj == idHrz) objCol = vec4 (0.5, 0.3, 0., -2.);\n  else if (idObj == idLight) objCol = vec4 (1., 1., 0.7, -1.);\n  else if (idObj == idTun) {\n    if (vn.y > 0.99) objCol = vec4 (mix (vec3 (0.25, 0.25, 0.27),\n       vec3 (0.32, 0.32, 0.34), smoothstep (0.6, 0.9, Fbm2 (100. * ro.xz))), -2.);\n    else objCol = vec4 (0.4, 0.4, 0.45, -2.);\n  }\n  return objCol;\n}\n\nfloat ObjShDf (vec3 p)\n{\n  float dMin;\n  dMin = dstFar;\n  dMin = min (dMin, SceneDf (p));\n  return dMin;\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = 0; j < 5; j ++) {\n    h = ObjShDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 1., 20. * h / d));\n    d += min (0.05, 3. * h);\n    if (h < 0.001) break;\n  }\n  return sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 objCol;\n  vec3 qHitT, col, vn, ltPos, ltDir, bmDir, vBm;\n  float dstHit, d, sh, att, fs, fa, ltBm;\n  int idObjT;\n  dstHit = dstFar;\n  d = TrackRay (ro, rd);\n  if (d < dstHit) dstHit = d;\n  idObjT = idObj;\n  qHitT = qHit;\n  d = SceneRay (ro, rd);\n  if (d < dstHit) dstHit = d;\n  else {\n    idObj = idObjT;\n    qHit = qHitT;\n  }\n  if (dstHit < dstFar) {\n    ro += rd * dstHit;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    if (idObj < 256) objCol = TrackCol (ro, vn);\n    else objCol = EngCol (vn);\n    if (objCol.a == -2.) {\n      objCol.a = 0.1;\n      if (idObj == idTun) {\n        if (vn.y > 0.99) { fs = 50.;  fa = 2.; }\n        else { fs = 20.;  fa = 3.;}\n      } else if (idObj == idVrt || idObj == idHrz) {\n        fs = 100.;  fa = 0.5;\n      }\n      vn = VaryNf (fs * ro, vn, fa);\n    }\n    col = objCol.rgb;\n#if SHOW_TUN\n    if (objCol.a >= 0. && idObj != idGrnd) {\n      ltPos.xz = floor (ro.xz) + vec2 (0.5);\n      ltPos.y = 0.4;\n      ltDir = normalize (ltPos - ro);\n      att = 0.2 + 0.8 * smoothstep (0.3, 0.8, pow (abs (ltDir.y), 4.));\n      sh = (riding > 0) ? (0.7 + 0.3 * ObjSShadow (ro, vec3 (0., 1., 0.))) : 1.;\n      bmDir = vec3 (0., 0., -1.);\n      bmDir.xz = Rot2D (bmDir.xz, pVu.w);\n      vBm = pVu.xyz - ro;\n      ltBm = (riding > 0) ?\n         0.4 * smoothstep (0.8, 1., dot (normalize (vBm), bmDir)) *\n         (0.1 + 0.9 * (max (dot (vn, bmDir), 0.))) / dot (vBm, vBm) : 0.;\n      col = col * (0.2 + ltBm + 0.7 * sh * att * max (max (dot (vn, ltDir), 0.),\n         0.5 * max (dot (vn, vec3 (0., 1., 0.)), 0.))) +\n         objCol.a * sh * att * pow (max (0., dot (ltDir, reflect (rd, vn))), 64.);\n    } else if (idObj == idLight) col *= (0.9 - 0.05 * vn.y);\n    if (riding == 0 && idObj != idGrnd) col *= 0.9 +\n        0.4 * max (dot (vn, ltExDir), 0.);\n#else\n    col = col * (0.3 + 0.7 * max (dot (vn, ltExDir), 0.))+\n       objCol.a * pow (max (0., dot (ltExDir, reflect (rd, vn))), 64.);\n#endif\n  } else col = bgCol;\n  return clamp (col, 0., 1.);\n}\n\nvec3 ShowWg (vec2 uv, vec2 canvas, vec3 col, float fvVar, int riding)\n{\n  vec4 wgBx[2];\n  vec2 ust;\n  float asp;\n  asp = canvas.x / canvas.y;\n  wgBx[0] = vec4 (0.47 * asp, -0.1, 0.012 * asp, 0.15);\n  wgBx[1] = vec4 (0.47 * asp, -0.4, 0.022, 0.);\n  ust = abs (0.5 * uv - wgBx[0].xy) - wgBx[0].zw;\n  if (abs (max (ust.x, ust.y)) * canvas.y < 1.) col = vec3 (0.8);\n  ust = 0.5 * uv - wgBx[0].xy;\n  ust.y -= (fvVar - 0.5) * 2. * wgBx[0].w;\n  if (abs (length (ust) - 0.8 * wgBx[0].z) * canvas.y < 2.)\n     col = (fvVar * canvas.y > 5.) ? vec3 (0.1, 1., 0.1) : vec3 (1., 0.1, 0.1);\n  if (abs (length (0.5 * uv - wgBx[1].xy) - wgBx[1].z) * canvas.y < 1.5)\n     col = (riding > 0) ? vec3 (0.7, 0.7, 0.) : vec3 (0., 0., 1.);\n  return col;\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., sa.y, 0., 1., 0., - sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, sa.x, 0., - sa.x, ca.x);\n}\n\nvoid TrSetup ()\n{\n  vec4 stDat;\n  rgHSize = 3.;\n  szFac = 0.07;\n  trkWid = 0.095;\n  tunSize = vec2 (3. * trkWid, 0.25);\n  rlSize = vec2 (0.005, 0.01);\n  wallThk = 0.01;\n  bWid = 3. * wallThk;\n  bLen = tunSize.x + bWid;\n  stDat = Loadv4 (N_ENG + 1);\n  trMov = stDat.x;\n  for (int k = 0; k < N_ENG; k ++) {\n    stDat = Loadv4 (k);\n    pCar[k].xzw = stDat.xzw;\n    pCar[k].y = 3. * rlSize.y + 0.15;\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat, pc;\n  mat3 vuMat;\n  vec3 ro, rd, col, u, vd;\n  vec2 canvas, uv, uvs;\n  float el, az, zmFac, f, t, trVar;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uvs = uv;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dstFar = 30.;\n  TrSetup ();\n  stDat = Loadv4 (N_ENG + 2);\n  riding = int (stDat.x);\n  el = stDat.y;\n  az = stDat.z;\n  trVar = stDat.w;\n  if (riding > 0) {\n    stDat = Loadv4 (N_ENG);\n    pVu = stDat;\n    pVu.y = 3. * rlSize.y + 0.15;\n    ro = pVu.xyz;\n    vuMat = StdVuMat (clamp (0.3 * el, -0.1 * pi, 0.1 * pi), az + pVu.w);\n    zmFac = 1.7;\n#if SHOW_TUN\n  } else if (length (uvs) < 1.5 * SmoothBump (0.2, 0.7, 0.02,\n     mod (0.02 * tCur, 1.))) {\n#else\n  } else if (true) {\n#endif\n    vuMat = StdVuMat (clamp (el + 0.1 * pi, 0.01 * pi, 0.45 * pi),\n       az + 0.01 * pi * tCur);\n    ro = vuMat * vec3 (0., 0., -15.);\n    zmFac = 8.;\n  } else {\n    t = floor (mod (0.07 * trMov, float (N_ENG)));\n    if (t == 0.)      pc = pCar[0];\n    else if (t == 1.) pc = pCar[1];\n    else if (t == 2.) pc = pCar[2];\n#if N_ENG == 5\n    else if (t == 3.) pc = pCar[3];\n    else if (t == 4.) pc = pCar[4];\n#endif\n    ro = vec3 (0., 0.3, -5.);\n    vd = normalize (pc.xyz - ro);\n    u = - vd.y * vd;\n    f = 1. / sqrt (1. - vd.y * vd.y);\n    vuMat = mat3 (f * vec3 (vd.z, 0., - vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd);\n    zmFac = 6.;\n  }\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  ltExDir = normalize (vec3 (1., 3., -1.));\n  bgCol = (riding > 0) ? vec3 (0.01, 0.01, 0.05) : vec3 (0.05, 0.05, 0.1);\n  col = ShowScene (ro, rd);\n  col = ShowWg (uv, canvas, col, trVar, riding);\n  fragColor = vec4 (col, 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Complex Tunnels\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float pi = 3.14159;\n\nconst float txRow = 64.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n\n// Set = 1 in BOTH shaders for more fun. WARNING: browser crashes reported\n#define LONG_TRACK 0\n//#define LONG_TRACK 1\n\n#if LONG_TRACK\n#define N_ENG 5\n#define TRK_LEN 24\n#else\n#define N_ENG 3\n#define TRK_LEN 12\n#endif\n\nvec4 pCar[N_ENG];\nvec3 drP;\nvec2 rP;\nfloat ti[TRK_LEN + 1], tCur, tCyc, rgHSize, tC, aP;\n\n#define SLIN(k,d) ti[k + 1] = ti[k] + d\n#define SCRV(k) ti[k + 1] = ti[k] + tC\n\nvoid TrSetup ()\n{\n  tC = 0.25 * pi;\n  ti[0] = 0.;\n#if LONG_TRACK\n  SCRV(0);  SLIN(1, 4.);  SCRV(2);  SLIN(3, 1.);  SCRV(4);  SLIN(5, 1.);  SCRV(6);\n  SLIN(7, 2.);  SCRV(8);  SLIN(9, 1.);  SCRV(10);  SLIN(11, 1.);  SCRV(12);\n  SLIN(13, 4.);  SCRV(14);  SLIN(15, 1.);  SCRV(16);  SLIN(17, 1.);  SCRV(18);\n  SLIN(19, 2.);  SCRV(20);  SLIN(21, 1.);  SCRV(22);  SLIN(23, 1.);\n#else\n  SCRV(0);   SLIN(1, 1.);  SCRV(2);  SLIN(3, 4.);  SCRV(4);  SLIN(5, 2.);\n  SCRV(6);  SLIN(7, 2.);  SCRV(8);  SLIN(9, 4.);  SCRV(10);  SLIN(11, 1.);\n#endif\n  tCyc = ti[TRK_LEN];\n  rgHSize = 3.;\n}\n\n#if LONG_TRACK\n\nvoid TPath1 (float t)\n{\n  if (t < ti[6]) {\n    if (t < ti[1]) {\n      rP = vec2 (0., 0.);  drP = vec3 (1., 1., 0.5 * tC + 0.25 * (t - ti[0]));\n    } else if (t < ti[2]) {\n      rP = vec2 (1., 0.5);  drP.x = (t - ti[1]);\n    } else if (t < ti[3]) {\n      rP = vec2 (5., 0.);  drP = vec3 (0., 1., 0.75 * tC + 0.25 * (t - ti[2]));\n    } else if (t < ti[4]) {\n      rP = vec2 (5.5, 1.);  drP.y = (t - ti[3]);\n    } else if (t < ti[5]) {\n      rP = vec2 (5., 2.);  drP.z = 0. * tC + 0.25 * (t - ti[4]);\n    } else {\n      rP = vec2 (5., 2.5);  drP.x = - (t - ti[5]);\n    }\n  } else {\n    if (t < ti[7]) {\n      rP = vec2 (4., 2.);  drP = vec3 (0., 1., 0.75 * tC - 0.25 * (t - ti[6]));\n    } else if (t < ti[8]) {\n      rP = vec2 (3.5, 3.);  drP.y = (t - ti[7]);\n    } else if (t < ti[9]) {\n      rP = vec2 (3., 5.);  drP = vec3 (1., 0., 0.5 * tC - 0.25 * (t - ti[8]));\n    } else if (t < ti[10]) {\n      rP = vec2 (4., 5.5);  drP.x = (t - ti[9]);\n    } else if (t < ti[11]) {\n      rP = vec2 (5., 5.);  drP.z = 0.25 * tC - 0.25 * (t - ti[10]);\n    } else {\n      rP = vec2 (5.5, 5.);  drP.y = - (t - ti[11]);\n    }\n  }\n}\n\nvoid TPath2 (float t)\n{\n  if (t < ti[18]) {\n    if (t < ti[13]) {\n      rP = vec2 (5., 3.);  drP = vec3 (0., 1., 0. * tC - 0.25 * (t - ti[12]));\n    } else if (t < ti[14]) {\n      rP = vec2 (5., 3.5);  drP.x = - (t - ti[13]);\n    } else if (t < ti[15]) {\n      rP = vec2 (0., 3.);  drP = vec3 (1., 1., 0.75 * tC - 0.25 * (t - ti[14]));\n    } else if (t < ti[16]) {\n      rP = vec2 (0.5, 4.);  drP.y = (t - ti[15]);\n    } else if (t < ti[17]) {\n      rP = vec2 (0., 5.);  drP = vec3 (1., 0., 0.5 * tC - 0.25 * (t - ti[16]));\n    } else {\n      rP = vec2 (1., 5.5);  drP.x = (t - ti[17]);\n    }\n  } else {\n    if (t < ti[19]) {\n      rP = vec2 (2., 5.);  drP.z = 0.25 * tC - 0.25 * (t - ti[18]);\n    } else if (t < ti[20]) {\n      rP = vec2 (2.5, 5.);  drP.y = - (t - ti[19]);\n    } else if (t < ti[21]) {\n      rP = vec2 (2., 2.);  drP = vec3 (0., 1., 0. * tC - 0.25 * (t - ti[20]));\n    } else if (t < ti[22]) {\n      rP = vec2 (2., 2.5);  drP.x = - (t - ti[21]);\n    } else if (t < ti[23]) {\n      rP = vec2 (0., 2.);  drP = vec3 (1., 0., 0.25 * tC + 0.25 * (t - ti[22]));\n    } else {\n      rP = vec2 (0.5, 2.);  drP.y = - (t - ti[23]);\n    }\n  }\n}\n\nvec2 TrackPath (float t)\n{\n  t = mod (t, tCyc);\n  drP = vec3 (0., 0., 99.);\n  if (t < ti[12]) TPath1 (t);\n  else TPath2 (t);\n  if (drP.z != 99.) {\n    drP.z *= 2. * pi / tC;\n    rP += 0.5 * vec2 (cos (drP.z), sin (drP.z));\n  }\n  rP += drP.xy - rgHSize;\n  return rP;\n}\n\n#else\n\nvec2 TrackPath (float t)\n{\n  t = mod (t, tCyc);\n  drP = vec3 (0., 0., 99.);\n  if (t < ti[1]) {\n    rP = vec2 (0., 0.);  drP = vec3 (1., 1., 0.5 * tC + 0.25 * (t - ti[0]));\n  } else if (t < ti[2]) {\n    rP = vec2 (1., 0.5);  drP.x = (t - ti[1]);\n  } else if (t < ti[3]) {\n    rP = vec2 (2., 0.);  drP = vec3 (0., 1., 0.75 * tC + 0.25 * (t - ti[2]));\n  } else if (t < ti[4]) {\n    rP = vec2 (2.5, 1.);  drP.y = (t - ti[3]);\n  } else if (t < ti[5]) {\n    rP = vec2 (2., 5.);  drP = vec3 (1., 0., 0.5 * tC - 0.25 * (t - ti[4]));\n  } else if (t < ti[6]) {\n    rP = vec2 (3., 5.5);  drP.x = (t - ti[5]);\n  } else if (t < ti[7]) {\n    rP = vec2 (5., 5.);  drP = vec3 (0., 0., 0.25 * tC - 0.25 * (t - ti[6]));\n  } else if (t < ti[8]) {\n    rP = vec2 (5.5, 5.);  drP.y = - (t - ti[7]);\n  } else if (t < ti[9]) {\n    rP = vec2 (5., 2.);  drP = vec3 (0., 1., 0. * tC - 0.25 * (t - ti[8]));\n  } else if (t < ti[10]) {\n    rP = vec2 (5., 2.5);  drP.x = - (t - ti[9]);\n  } else if (t < ti[11]) {\n    rP = vec2 (0., 2.);  drP = vec3 (1., 0., 0.25 * tC + 0.25 * (t - ti[10]));\n  } else if (t < ti[12]) {\n    rP = vec2 (0.5, 2.);  drP.y = - (t - ti[11]);\n  }\n  if (drP.z != 99.) {\n    drP.z *= 2. * pi / tC;\n    rP += 0.5 * vec2 (cos (drP.z), sin (drP.z));\n  }\n  rP += drP.xy - rgHSize;\n  return rP;\n}\n\n#endif\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 wgBx[2], pCar[5], pVu, stDat, mPtr, mPtrP;\n  vec2 iFrag, canvas, ust, vo;\n  float el, az, asp, tCurP, trVar, trSpd, trMov, t;\n  int pxId, wgSel, wgReg, riding;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= N_ENG + 4) discard;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  riding = 1;\n  trMov = 0.;\n  trVar = 0.3;\n  el = 0.;\n  az = 0.;\n  wgSel = -1;\n  wgReg = -2;\n  if (iFrame <= 5) {\n    mPtrP = mPtr;\n  } else {\n    stDat = Loadv4 (N_ENG + 1);\n    trMov = stDat.x;\n    trSpd = stDat.y;\n    tCurP = stDat.z;\n    stDat = Loadv4 (N_ENG + 2);\n    riding = int (stDat.x);\n    el = stDat.y;\n    az = stDat.z;\n    trVar = stDat.w;\n    stDat = Loadv4 (N_ENG + 3);\n    mPtrP = vec4 (stDat.xyz, 0.);\n    wgSel = int (stDat.w);\n  }\n  asp = canvas.x / canvas.y;\n  if (mPtr.z > 0.) {\n    wgBx[0] = vec4 (0.47 * asp, -0.1, 0.012 * asp, 0.15);\n    wgBx[1] = vec4 (0.47 * asp, -0.4, 0.022, 0.);\n    ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx[0].xy) - wgBx[0].zw;\n    if (max (ust.x, ust.y) < 0.) wgReg = 0;\n    if (length (mPtr.xy * vec2 (asp, 1.) - wgBx[1].xy) < wgBx[1].z) wgReg = 1;\n    if (mPtrP.z <= 0.) wgSel = wgReg;\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n  }\n  if (wgSel < 0) {\n    if (mPtr.z > 0.) {\n      az = - 2. * pi * mPtr.x;\n      el = - pi * mPtr.y;\n    }\n  } else {\n    if (wgSel == 0) {\n      trVar = clamp (0.5 + 0.5 * (mPtr.y - wgBx[0].y) / wgBx[0].w, 0., 1.);\n    } else if (wgSel == 1) {\n      if (mPtrP.z <= 0.) {\n        riding = 1 - riding;\n        el = 0.;\n        az = 0.;\n      }\n    }\n  }\n  trSpd = 1. * trVar;\n  if (trSpd < 0.01) trSpd = 0.;\n  TrSetup ();\n  trMov += trSpd * (tCur - tCurP);\n  for (int k = 0; k < N_ENG; k ++) {\n    t = trMov - float (k) * tCyc / float (N_ENG);\n    pCar[k].xz = TrackPath (t);\n    pCar[k].y = 0.;\n    vo = TrackPath (t + 0.01) - pCar[k].xz;\n    pCar[k].w = atan (vo.x, vo.y);\n  }\n  if (riding > 0) {\n    t = floor (mod (0.07 * trMov, float (N_ENG)));\n#if LONG_TRACK\n    t += 0.17;\n#else\n    t += 0.27;\n#endif\n    t = trMov - t * tCyc / float (N_ENG);\n    pVu.xz = TrackPath (t);\n    pVu.y = 0.;\n    vo = TrackPath (t + 0.01) - pVu.xz;\n    pVu.w = - atan (vo.x, vo.y);\n  } else pVu = vec4 (0.);\n  tCurP = tCur;\n  for (int k = 0; k < N_ENG; k ++) {\n    if (pxId == k) stDat = pCar[k];\n  }\n  if (pxId == N_ENG) stDat = pVu;\n  else if (pxId == N_ENG + 1) stDat = vec4 (trMov, trSpd, tCurP, 0.);\n  else if (pxId == N_ENG + 2) stDat = vec4 (float (riding), el, az, trVar);\n  else if (pxId == N_ENG + 3) stDat = vec4 (mPtr.xyz, float (wgSel));\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}