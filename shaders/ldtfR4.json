{
    "Shader": {
        "info": {
            "date": "1524341139",
            "description": "wood material inspired from [url] https://www.youtube.com/watch?v=Fa7UlnP-3lQ [/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "ldtfR4",
            "likes": 8,
            "name": "wood material",
            "published": 3,
            "tags": [
                "wood",
                "pattern",
                "mz"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 748
        },
        "renderpass": [
            {
                "code": "// === wood material  ================================\n// horizontal variant: https://www.shadertoy.com/view/MddBD8\n\n// 3 others different looks @ shadertoy:\n//    https://www.shadertoy.com/view/XsG3Dc\n//    https://www.shadertoy.com/view/lsSyDw\n//    https://www.shadertoy.com/view/XlB3R3\n\nfloat  SCALE = 2.,           // zoom factor\n    \n       warp_A = .05,         // global displacement amplitude and scale\n       warp_S = 1.,\n    \n      noise_A = 6.;          // large fluctuations hosting veins\nvec2  noise_S = vec2(4.,.2);\nfloat veins_S = 7.,          // veins ( subdividing the fluctuations )\n    \n     fibers_A = 3.,          // short fibers ( dents in knot veins )\n     fibers_S = 200.,\n    \n       knot_A = .6,          // knots strength\n       knot_N = 2.;          //       amount\nvec2   knot_S = vec2(3.,.5), //       scales\n       knot_shape = vec2(.3,.7); //   shape (range in Perlin landscape )\n\n\n\n// std int hash, inspired from https://www.shadertoy.com/view/XlXcW4\nvec3 hash3i( uvec3 x )              // integer param\n{\n#   define scramble  x = ( (x>>8U) ^ x.yzx ) * 1103515245U // GLIB-C const\n    scramble; scramble; scramble; \n    return vec3(x) / float(0xffffffffU);\n}\nvec3 hash3f(vec3 x) {              // float[0,1] param\n    return hash3i(uvec3( x * float(0xffffffffU) ) );\n}\n#define hash(v) hash3i(uvec3(v+float(0x0000ffffU),11)).x // why ?\n//#define hash(x)  fract(sin(dot(x,vec2(1,17.53))) * 43758.5453123)\n\nfloat grad(float r, vec2 p) {\n      int h = int(r*256.) & 15;\n      float u = h<8 ? p.x : p.y,                 // 12 gradient directions\n            v = h<4 ? p.y : h==12||h==14 ? p.x : 0.; // p.z;\n      return ((h&1) == 0 ? u : -u) + ((h&2) == 0 ? v : -v);\n}\n\n#define G(v) grad(hash(I+v),p-v)\n#define fade(t)  t * t * t * (t * (t * 6. - 15.) + 10.) // super-smoothstep\n\nfloat Inoise2(vec2 p) {\n    vec2 I = floor(p); p -= I;    \n    vec2 f = fade(p);\n    \n    return mix( mix( G(vec2(0,0)),G(vec2(1,0)), f.x),\n                mix( G(vec2(0,1)),G(vec2(1,1)), f.x), f.y );\n}  \n\n//#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\nfloat fbm2(vec2 p) {\n    float v = 0.,  a = .5;\n    //mat2 R = rot(.37); // should no longer be necessary\n\n    for (int i = 0; i < 3; i++, p*=2.,a/=2.) \n        //p *= R,\n        v += a * Inoise2(p);\n        //v += a *a*2.* Inoise2(p); // trying to get derivatives respect the scale profile\n\n    return v;\n}\n\n// --- version returning vec2\n#define G2(v) vec2( grad(hash(I+v),p-v), grad(hash(I+v+117.),p-v))\nvec2 Inoise22(vec2 p) {\n    vec2 I = floor(p); p -= I;    \n    vec2 f = fade(p);\n    \n    return mix( mix( G2(vec2(0,0)),G2(vec2(1,0)), f.x),\n                mix( G2(vec2(0,1)),G2(vec2(1,1)), f.x), f.y );\n}  \n\nvec2 fbm22(vec2 p) {\n    vec2 v = vec2(0); float  a = .5;\n    //mat2 R = rot(.37);\n\n    for (int i = 0; i < 3; i++, p*=2.,a/=2.) \n        //p *= R,\n        v += a * Inoise22(p);\n\n    return v;\n}\n\n// --- \n\nfloat bosoNoise1(float x) {\n    float i = floor(x), f = fract(x);\n    f = f*f*(3.-2.*f);\n    return -1.+2.*mix( hash3i(uvec3(i,17,1)),hash3i(uvec3(i+1.,17,1)), f).x;\n}\n\nfloat smoothfract(float x, float s) {\n    x = fract(x);\n    return  x < s    ? smoothstep(s,-s, x)\n          : x < 1.-s ? smoothstep(s,1.-s, x)\n                     : smoothstep(1.+s,1.-s, x);\n}\n\n// ------------------------\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    U *= SCALE / R.y;\n    U.y -= .3*iTime;                                       // for demo\n    vec2 U0 = U;\n    O -= O;\n    U.x += warp_A * fbm2(warp_S*U) / warp_S;               // warp\n    U.y += fibers_A * bosoNoise1(fibers_S*U.x) / fibers_S; // fluctu for fibers\n    float v = noise_A * fbm2(noise_S*U) / noise_S.x,       // noise\n          n = 0.;                                          // knots\n#define knot(seed) smoothstep( knot_shape.x, knot_shape.y, \\\n                               abs(Inoise2(knot_S*U+seed)) ) \n    for (float i=0.; i<knot_N; i++) \n        n += knot(100.*hash3i(uvec3(i,23,2)).xy);\n    //  n = knot(0.) + knot(17.1) + kot(51.6) + knot(vec2(-23,31));\n    v += knot_A * n;\n    v = smoothfract(veins_S*v,.1);                         // fibers\n    \n  //O += v;\n  // --- demo mode\n  //O = mix( vec4(.4,.15,0,1), vec4(1,.9,.8,1) ,  v );     // colors for demo\n  //O = mix( vec4( .5,.1,.1,1),vec4(.75,.4,.2,1), v );\n  //O = mix( .0+vec4( .5,.1,.1,1), 3.5*vec4(.75,.4,.2,1), v);\n    O = mix( .2+vec4( .5,.1,.1,1), 3.5*vec4(.75,.4,.2,1), pow(v,.8));\n  //O = mix( vec4( .4,.1,.1,1), vec4(1.0,.65,.3,1), pow(v,.5)); // jt variant\n    \n    if ( mod(U0.x,.7) <.03 ) O -= O;                       // planks borders\n    if ( mod(U0.y+.5*floor(U0.x/.7),3.) <.03 ) O -= O;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}