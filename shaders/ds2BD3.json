{
    "Shader": {
        "info": {
            "date": "1690229669",
            "description": "The colors and the lighting are specifically done to camera.\nIt started nice and organized and then I went onto a rabbit hole of hacks to make it look as I wanted to so don't take any of this as a reference.\nxD",
            "flags": 32,
            "hasliked": 0,
            "id": "ds2BD3",
            "likes": 27,
            "name": "UnchainedEnergy",
            "published": 3,
            "tags": [
                "unchainedenergy",
                "euskalencounter"
            ],
            "usePreview": 0,
            "username": "NoxWings",
            "viewed": 392
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 color0 = texture(iChannel0, uv);\n    vec4 color1 = texture(iChannel1, uv);\n    \n    fragColor = ACESFilm(color0 + color1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#ifndef __COMMON_BASIC_GLSL__\n#define __COMMON_BASIC_GLSL__\n\n#define S(x, y, z) smoothstep(x, y, z)\n#define A(v1,v2,t1,t2) mix(v1,v2,S(t1,t2,iTime))\n\nconst float PI = 3.14159;\nconst float HALF_PI = PI * 0.5;\nconst float TAU = PI * 2.0;\nconst float DEG2RAD = TAU/360.0;\n\nfloat invLerp(float a, float b, float x) {\n    x = clamp(x, a, b);\n    return (x - a) / (b - a);\n}\n\nmat3 lookAtMatrix(in vec3 lookAtDirection) {\n\tvec3 ww = normalize(lookAtDirection);\n    vec3 uu = cross(ww, vec3(0.0, 1.0, 0.0));\n    vec3 vv = cross(uu, ww);\n    return mat3(uu, vv, -ww);\n}\n\nstruct Camera {\n    vec3 position;\n\tvec3 direction;\n};\n\nCamera createOrbitCamera(vec2 uv, vec2 mouse, vec2 resolution, float fov, vec3 target, float height, float distanceToTarget, float iTime)\n{\n    vec2 r = mouse / resolution * vec2(3.0 * PI, 0.5 * PI);\n    float halfFov = fov * 0.5;\n    float zoom = cos(halfFov) / sin(halfFov);\n\n    vec3 position = target + vec3(sin(r.x), 0.0, cos(r.x)) * distanceToTarget + vec3(0, height, 0);\n    vec3 direction = normalize(vec3(uv, -zoom));\n    direction = lookAtMatrix(target - position) * direction;\n\n    return Camera(position, direction);\n}\n\nmat2 rot2d(float a) {\n    float ca = cos(a), sa = sin(a);\n    return mat2(ca, sa, -sa, ca);\n}\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 100000.5453);\n}\n\nfloat hash12(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * .1031);\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\n#endif // __COMMON_BASIC_GLSL__\n#ifndef __COMMON_COLORS_GLSL__\n#define __COMMON_COLORS_GLSL__\n\nvec4 linearTosRGB(vec4 linearRGB)\n{\n    bvec4 cutoff = lessThan(linearRGB, vec4(0.0031308));\n    vec4 higher = vec4(1.055)*pow(linearRGB, vec4(1.0/2.4)) - vec4(0.055);\n    vec4 lower = linearRGB * vec4(12.92);\n\n    return mix(higher, lower, cutoff);\n}\n\nvec4 sRGBToLinear(vec4 sRGB)\n{\n    bvec4 cutoff = lessThan(sRGB, vec4(0.04045));\n    vec4 higher = pow((sRGB + vec4(0.055))/vec4(1.055), vec4(2.4));\n    vec4 lower = sRGB/vec4(12.92);\n\n    return mix(higher, lower, cutoff);\n}\n\nvec4 ACESFilm(vec4 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), vec4(0), vec4(1));\n}\n\n#endif // __COMMON_COLORS_GLSL__\n#ifndef __COMMON_DIST_FUNCTIONS_GLSL__\n#define __COMMON_DIST_FUNCTIONS_GLSL__\n\nfloat sdPlane(vec3 p, float height) {\n    return p.y - height;\n}\n\nfloat sdSphere(vec3 p, float s) {\n  return length(p)-s;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdPrism(vec3 p, float tall, vec2 topSize, vec2 botSize) {\n    vec3 top = vec3(topSize.x, tall, topSize.y);\n    vec3 bot = vec3(botSize.x, tall, botSize.y);\n\n    float q = (p.y+tall)*.5/tall;\n    vec3 shape = mix(bot, top, q);\n\n    return sdBox(p, shape);\n}\n\nfloat sdLink( vec3 p, float le, float r1, float r2 ) {\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\n#endif // __COMMON_DIST_FUNCTIONS_GLSL__\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.0*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.0;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.0)) c = abs(c);\n\treturn c;\n}\n\nstruct Hit {\n    int id;\n    float dist; // means distance from ray to hit (<= surfHit usually)\n};\n\nstruct TraceResult {\n    Hit hit;\n    float dist; // means distance from ro to closest point to hit\n    vec3 ro;\n    vec3 rd;\n};\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat smax(float a, float b, float k) {\n\tfloat h = max(k-abs(a-b),0.0);\n\treturn max(a, b) + h*h*0.25/k;\n}\n\nHit hmin(Hit a, Hit b) { if (a.dist < b.dist) return a; return b; }\nHit hmax(Hit a, Hit b) { if (a.dist < b.dist) return b; return a; }\nHit hsmin(in Hit a, in Hit b, in float k) {\n    Hit h = hmin(a, b);\n    h.dist = smin(a.dist, b.dist, k);\n    return h;\n}\nHit hsmax(in Hit a, in Hit b, in float k) {\n    Hit h = hmax(a, b);\n    h.dist = smin(a.dist, b.dist, k);\n    return h;\n}\nHit hnegate(Hit a) { return Hit(a.id, -a.dist); }\nHit opUnion(Hit a, Hit b) { return hmin(a, b); }\nHit opSubtraction(Hit a, Hit b) { return hmax(hnegate(a), b); }\nHit opIntersection(Hit a, Hit b) { return hmax(a, b); }\n\nstruct DirectionalLight {\n    vec3 direction;\n    vec3 color;\n};\n\nstruct Material {\n    vec3 albedo;\n    float metallic;\n    float roughness;\n    vec3 emissive;\n    float ao;\n};\n\nstruct Surface {\n    int materialId;\n    float dist;\n    vec3 position;\n    vec3 normal;\n    float ao;\n    vec3 view;\n};\n\n// -----------------------------------------------------------------------------\n// PBR Implementation\n// - Lambert or Burley diffuse\n// - Schlick Fresnel\n// - GGX NDF\n// - Smith-GGX height-correlated visibility function\n\n// Sources\n//\n// https://learnopengl.com/PBR/Lighting\n// https://google.github.io/filament/Filament.html\n// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#appendix-b-brdf-implementation\n\nvec3 F_Schlick_full(float HoV, vec3 f0, vec3 f90) {\n    return f0 + (f90 - f0) * pow(1.0 - HoV, 5.0);\n}\n\nvec3 F_Schlick(float HoV, vec3 f0) {\n    return F_Schlick_full(HoV, f0, vec3(1.0));\n}\n\nfloat Diff_Lambert() {\n    return 1.0 / PI;\n}\n\nvec3 Diff_Burley(float NoV, float NoL, float LoH, float roughness) {\n    float f90 = 0.5 + 2.0 * roughness * LoH * LoH;\n    vec3 lightScatter = F_Schlick_full(NoL, vec3(1.0), vec3(f90));\n    vec3 viewScatter = F_Schlick_full(NoV, vec3(1.0), vec3(f90));\n    return lightScatter * viewScatter * (1.0 / PI);\n}\n\nfloat D_GGX(float NoH, float a) {\n    float a2 = a * a;\n    float f = (NoH * a2 - NoH) * NoH + 1.0;\n    return a2 / (PI * f * f);\n}\n\nfloat V_SmithGGXCorrelated(float NoV, float NoL, float a) {\n    float a2 = a * a;\n    float NoV2 = NoV*NoV;\n    float NoL2 = NoL*NoL;\n    float GGL = NoL * sqrt(NoV2 * (1.0 - a2) + a2);\n    float GGV = NoV * sqrt(NoL2 * (1.0 - a2) + a2);\n\treturn 0.5 / (GGL + GGV);\n}\n\nfloat GGX_Smith_Approx_Visibility(float NoV, float NoL, float a) {\n    return 1.0 / (2.0 * mix(2.0*NoL*NoV, NoL+NoV, a));\n}\n\n\nvec3 BRDF(DirectionalLight l, Surface surf, Material mat, float shadow) {\n    vec3 V = -surf.view;\n    vec3 N = surf.normal;\n    vec3 L = l.direction;\n    vec3 H = normalize(V + L);\n\n    float NoV = max(dot(N, V), 0.0);\n    float NoL = max(dot(N, L), 0.0);\n    float NoH = max(dot(N, H), 0.0);\n    float HoV = max(dot(H, V), 0.0);\n\n    vec3  albedo     = mat.albedo;\n    float roughness  = mat.roughness;\n    float a          = roughness * roughness;\n    float metallic   = mat.metallic;\n    float dielectric = 1.0 - metallic;\n\n    // Constants\n    vec3 dielectricSpecular = vec3(0.04);\n    vec3 black = vec3(0);\n\n    // Frenel term\n    vec3 F0 = mix(dielectricSpecular, albedo, metallic);\n    vec3 F  = F_Schlick(HoV, F0);\n\n    // Normal distribution\n    float D = D_GGX(NoH, a);\n\n    // Visibility term\n    //     should be equivalent to G / (4.0 * NoL * NoV)\n    //     but it doesn't look the same as https://www.shadertoy.com/view/tdKXR3\n    float Vis = V_SmithGGXCorrelated(NoV, NoL, a);\n\n    // Specular BRDF Cook Torrance\n    vec3 specular = F * (Vis * D);\n\n    // Lambert Diffuse\n    //     Should we scale by (1.0 - F) ?? gltf and learnopengl have it but filament doesn't\n    //     Also what about lambert 1/PI ?? https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/\n    //     PI might not be used in IBL only?\n    vec3 kD = vec3(1.0) - F;\n    vec3 c = mix(albedo * (1.0-dielectricSpecular), black, metallic);\n    vec3 diffuse = kD * (c / PI);\n    // vec3 diffuse = (1.0 - F) * diffuseColor * Diff_Burley(NoV, NoL, NoH, a);\n\n    // Final Color\n    vec3 emissive = mat.emissive;\n    vec3 directLight = l.color * NoL * (diffuse + specular);\n\n    //return vec3(Vis)*NoL;\n    return emissive + directLight * shadow;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n// ***********************************************************************\n// *************************** SCENE *************************************\n// ***********************************************************************\n\n\nfloat straigthChain(vec3 p, float l) {\n    const float le = 0.15, r1 = 0.2, r2 = 0.07;\n    vec3 a = p;\n    vec3 b = p;\n\n    if (p.y > -.5 && p.y < l) {\n        a.y = fract(a.y)-0.5;\n        b.y = fract(b.y+.5)-0.5;\n    }\n\n    return min(\n        sdLink(a.xyz, le, r1, r2),\n        sdLink(b.zyx, le, r1, r2)\n    );\n}\n\nfloat circularChain(vec3 p, float radius, float repetitions) {\\\n    const float le = 0.15, r1 = 0.2, r2 = 0.065;\n    float arc = 360.0 / repetitions * DEG2RAD;\n\n    vec3 q = p;\n    pModPolar(q.xz, repetitions);\n    q -= vec3(radius, 0, 0);\n    q.yz = rot2d(90.0 * DEG2RAD) * q.yz;\n\n    float link1 = sdLink(q, le, r1, r2);\n\n    vec3 q2 = p;\n    q2.xz = rot2d(arc * 0.5) * q2.xz;\n    pModPolar(q2.xz, repetitions);\n    q2 -= vec3(radius, 0, 0);\n    // alternate link rotation\n    q2.xz = rot2d(90.0 * DEG2RAD) * q2.xz;\n    q2.xy = rot2d(90.0 * DEG2RAD) * q2.xy;\n    float link2 = sdLink(q2, le, r1, r2);\n\n    return min(link1, link2);\n}\n\nvoid r2d(inout vec2 axis, float angle) {\n    axis = rot2d(angle) * axis;\n}\n\nHit map(vec3 p) {\n    //Hit floorPlane = Hit(0, sdPlane(p, -20.5));\n    Hit ball = Hit(1, sdSphere(p - vec3(0,1.0,0), 0.75));\n\n    float linkRadius = 2.0;\n    float linkRepetitions = 12.0;\n    float selfRotationSpeed = 1.5;\n\n    vec3 q = p;\n    q -= vec3(0, 1, 0);\n\n    vec3 q1 = q;\n    r2d(q1.yz, iTime + 1.*TAU/3.);\n    r2d(q1.xz, iTime * selfRotationSpeed * 2.0);\n    Hit chainLink = Hit(2, circularChain(q1, linkRadius, 12.0));\n\n    vec3 q2 = q;\n    r2d(q2.xy, iTime + 2.*TAU/3.);\n    r2d(q2.xz, iTime * selfRotationSpeed * 1.5);\n    chainLink = hmin(chainLink, Hit(2, circularChain(q2, linkRadius * 1.4, 16.0)));\n\n    vec3 q3 = q;\n    r2d(q3.yz, iTime + TAU);\n    r2d(q3.xz, iTime * selfRotationSpeed * 1.0);\n    chainLink = hmin(chainLink, Hit(2, circularChain(q3, linkRadius * 1.7, 21.0)));\n\n    //Hit result = hmin(floorPlane, chainLink);\n    Hit result = chainLink;\n    result = hmin(result, ball);\n    return result;\n}\n\n// ***********************************************************************\n// *************************** END SCENE *********************************\n// ***********************************************************************\n\nvec3 mapNormal(vec3 p, float surfHit) {\n    vec2 e = vec2(surfHit, 0);\n    float d = map(p).dist;\n\n    return normalize(vec3(\n        d - map(p - e.xyy).dist,\n        d - map(p - e.yxy).dist,\n        d - map(p - e.yyx).dist\n    ));\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor ) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ ) {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).dist;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// Fast raymarching\nTraceResult trace(vec3 ro, vec3 rd, float surfHit, float maxDistance, int maxSteps) {\n    float d = 0.0;\n    for (int i = 0; i < maxSteps && d <= maxDistance; i++) {\n        vec3 p = ro + rd * d;\n        Hit h = map(p);\n        if (h.dist <= surfHit)\n            return TraceResult(h, d, ro, rd);\n        d += h.dist;\n    }\n    return TraceResult(Hit(-1, maxDistance), d, ro, rd);\n}\n\n// Raymarching\n// Regular sphere tracing but returning the closest hit\nTraceResult traceClosest(vec3 ro, vec3 rd, float surfHit, float maxDistance, int maxSteps) {\n    float d = 0.0;\n    Hit closest = Hit(-1, maxDistance);\n    for (int i=0; i < maxSteps && d <= maxDistance; i++){\n        vec3 p = ro + rd * d;\n        Hit h = map(p);\n        if (h.dist < closest.dist)\n            closest = h;\n        if (h.dist <= surfHit)\n            return TraceResult(h, d, ro, rd);\n        d += h.dist;\n    }\n    return TraceResult(closest, d, ro, rd);\n}\n\n// Traces soft shadows\nfloat traceShadow(vec3 ro, vec3 rd, float hardness, float surfHit, float farPlane, int maxSteps) {\n    float d = surfHit;\n    float k = hardness;\n    float res = 1.0;\n\n    for (int i=0; i < maxSteps && d <= farPlane; i++) {\n        vec3 p = ro + rd * d;\n        float stepDistance = map(p).dist;\n        if (stepDistance < surfHit) return 0.0;\n        res = min(res, k * stepDistance / d);\n        d += stepDistance;\n    }\n\n    return clamp(res, 0.0, 1.0);\n}\n\n\nSurface getSurf(TraceResult tr) {\n    vec3 position = tr.ro + tr.rd * tr.dist;\n    vec3 normal = mapNormal(position, 0.01);\n    vec3 view = tr.rd;\n    float ao = calcAO(position, normal);\n\n    return Surface(\n        tr.hit.id,  // material id\n        tr.dist,    // distance\n        position,\n        normal,\n        ao,\n        view\n    );\n}\n\nMaterial matFromSurface(Surface s) {\n    Material m;\n    m.albedo    = vec3(0.0);\n    m.metallic  = 0.0;\n    m.roughness = 1.0;\n    m.emissive  = vec3(0.0);\n    m.ao = s.ao;\n\n    if (s.materialId == 0) { // Floor\n        m.albedo    = vec3(0.2, 0.2, 0.2);\n        m.roughness = 0.0;\n    } else if (s.materialId == 1) { // Ball\n        m.albedo = vec3(0.2);\n        m.roughness = 0.6;\n        m.emissive = vec3(15000,15000,20000);\n    } else if (s.materialId == 2) { // Chains\n        m.albedo = vec3(.05);\n        m.roughness = 0.2;\n        m.metallic = 1.0;\n        // m.emissive = vec3(0);\n    } else { // Error\n        m.emissive = vec3(1, 0, 1);\n    }\n\n    return m;\n}\n\nstruct RenderInfo {\n    vec3 color;\n    float dist;\n};\n\n\nvec3 fakeReflectionIBL(Surface s, Material m) {\n    vec3 reflection = reflect(s.view, s.normal);\n\n    vec3 roughRef = sRGBToLinear(texture(iChannel0, reflection)).rgb;\n    vec3 glossyRef = sRGBToLinear(texture(iChannel1, reflection)).rgb;\n    \n    float a = m.roughness * m.roughness;\n    vec3 ref = mix(glossyRef, roughRef, a);\n    \n    return mix(vec3(0), ref, m.metallic);\n}\n\nRenderInfo render(Camera cam) {\n    DirectionalLight sun = DirectionalLight(\n        normalize(vec3(1,1,1)),\n        vec3(10, 10, 10)\n    );\n    vec3 ambientLight = vec3(1);\n\n    int primarySteps = 256;\n    float farPlane = 20.0;\n    float surfHit = 0.01;\n\n    TraceResult traceRes = trace(cam.position, cam.direction, surfHit, farPlane, primarySteps);\n    Surface surface = getSurf(traceRes);\n        \n    if (surface.materialId == -1) {\n        return RenderInfo(\n            texture(iChannel0, surface.view).rgb,\n            farPlane\n        );\n    }\n    \n    Material material = matFromSurface(surface);\n\n    vec3 shadowOrigin = surface.position + surface.normal * surfHit * 2.0;\n    int shadowSteps = 32;\n    float shadow = traceShadow(shadowOrigin, sun.direction, 28.0, surfHit, farPlane, shadowSteps);\n\n    vec3 brdfColor = max(vec3(0.0), BRDF(sun, surface, material, shadow));\n    vec3 ambientColor = ambientLight * material.albedo;\n\n    vec3 finalColor = brdfColor + ambientColor * surface.ao + fakeReflectionIBL(surface, material);\n\n    return RenderInfo(\n        finalColor,\n        traceRes.dist\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 fakeScreen = uv * 2.0 - 1.0;\n    fakeScreen.x *= iResolution.x / iResolution.y;\n\n    Camera cam = createOrbitCamera(\n        fakeScreen,\n        iMouse.xy + iTime * 100.0,\n        iResolution.xy,\n        60.0 * DEG2RAD,\n        vec3(0,1.0,0),  // target,\n        2.0,            // height,\n        7.0,            // distanceToTarget,\n        iTime\n    );\n\n    RenderInfo renderOut = render(cam);\n    fragColor = vec4(renderOut.color, renderOut.dist);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Fake volumetrics\n\nconst float INTENSITY = 1.0;\nconst float RANDOMIZE = 1.0;\n\nvec4 sampleTex(vec2 uv) {\n    vec4 color = texture(iChannel0, uv);\n    float maxAllowed = 20000.0;\n    if (length(color.rgb) < maxAllowed) {\n        color = vec4(0.0);\n    } else {\n        color = pow(color, vec4(1.0));\n        color *= INTENSITY / maxAllowed;\n    }\n    return color;\n}\n\nvec3 shaft(vec2 uv, int steps) {\n    vec2 centerPos = vec2(0.5, 0.5);\n    uv -= centerPos;\n    float invSamples = 1.0 / float(steps);\n    \n    vec3 result = vec3(0.0);\n    float scale = 0.0;\n    \n    for( int i = 1; i < steps; i++ ) {\n        scale = (float(i) + rand(uv) * RANDOMIZE)*invSamples;\n        result += sampleTex(uv * scale + centerPos).rgb;\n    }\n    \n    return result * invSamples;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = shaft(uv, 32);\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}