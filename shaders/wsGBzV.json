{
    "Shader": {
        "info": {
            "date": "1607882190",
            "description": "Inspired by the displacement maps generated by JSplacement https://windmillart.net/?p=jsplacement",
            "flags": 32,
            "hasliked": 0,
            "id": "wsGBzV",
            "likes": 55,
            "name": "JSplacement-style greebles",
            "published": 3,
            "tags": [
                "displacementmap",
                "greebles"
            ],
            "usePreview": 0,
            "username": "TekF",
            "viewed": 1527
        },
        "renderpass": [
            {
                "code": "#if (0)\n// map the greebles through a curve, with a little animation\nfloat CurveProfile( float index )\n{\n    // custom curve shape with a round bit, a sloped bit, and a flat bit\n\treturn max(.75*sin(index*6.283185),min(1.,(fract(index)-.7)*7.));\n}\n\nfloat FoldHeight( float height, vec2 uv )\n{\n\tfloat shiftPeriod = 1.;\n    float staticPeriod = 1.5;\n    float t = iTime/(staticPeriod+shiftPeriod);\n\n\tvec2 rand0 = hash2( coord2( int(t) ) );\n\tvec2 rand1 = hash2( coord2( int(t)+1 ) );\n\tvec2 rand = mix( rand0, rand1, clamp(fract(t)*(staticPeriod+shiftPeriod)/shiftPeriod,0.,1.) ); // when shifting, morph from rand0 to rand1\n\n\treturn CurveProfile( height*(1.+2.*rand.x) - rand.x*1. + rand.y*.0 + uv.y*1. ); // this is much simpler than how I did it in Blender, but I think it will work\n}\n#else\nfloat FoldHeight( float height, vec2 uv )\n{\n\treturn height; // just show the greeble texture\n}\n#endif\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n\tfloat zoom = 1.5;\n\tvec3 rayDirection = normalize( vec3( (fragCoord-iResolution.xy*.5)/iResolution.y, zoom ) );\n    vec3 cameraTarget = vec3(1,0,1.5)*iTime + vec3(0,-1,0);\n    vec3 cameraPosition = vec3(0,8,-12);\n    float a = iTime/5.;\n    cameraPosition.xz = cameraPosition.xz*cos(a) + cameraPosition.zx*sin(a)*vec2(1,-1);\n    cameraPosition += cameraTarget;\n    \n    vec3 cameraForward = normalize( cameraTarget - cameraPosition );\n    vec3 upAxis = vec3(0,1,0);\n    vec3 cameraRight = normalize( cross( upAxis, cameraForward ) );\n    vec3 cameraUp = cross( cameraForward, cameraRight );\n    \n    // rotate ray to camera orientation\n    rayDirection = rayDirection.x*cameraRight + rayDirection.y*cameraUp + rayDirection.z*cameraForward;\n    \n    vec3 planeNormal = vec3(0,1,0);\n    float planeOffset = 0.; // from world origin, in direction of plane normal\n\n    // precompute some things\n    float rayDotPlaneNormal = dot(rayDirection,planeNormal);\n    float invRayDotPlaneNormal = 1. / rayDotPlaneNormal;\n    float cameraDotPlaneNormal = dot(cameraPosition,planeNormal);\n    float distanceToPlaneAlongNormal = planeOffset - cameraDotPlaneNormal; // note this is negative, so maybe shouldn't be called \"distance\"\n\n\tvec2 invTextureScale = .04*vec2(1.,iResolution.x/iResolution.y); // correct the aspect ratio\n\n\t// only support viewing the plane from in-front (even though it has depth it will break down when viewed edge-on)\n    if ( rayDotPlaneNormal >= 0. || cameraDotPlaneNormal < planeOffset )\n    {\n    \tfragColour = vec4(1);\n        return;\n    }\n\n    // draw the displacement map as a series of slices through the texture, not a solid object\n    float displacementHeight = 2.;\n    int numSlices = 256;\n    float sliceStep = displacementHeight / float(numSlices);\n    \n    vec2 textureCoordinate = vec2(0);\n    float sliceProportion = 0.;\n    float distanceToIntersection = 0.;\n    float height = 0.;\n    for ( int slice = 0; slice < numSlices; slice++ )\n    {\n    \tsliceProportion = float(slice)/float(numSlices); // how far we are through the full stack of slices, in [0,1)\n    \n    \t// how far along the ray do we have to travel to hit the plane\n    \tdistanceToIntersection = distanceToPlaneAlongNormal * invRayDotPlaneNormal;\n        \n        vec3 intersectionPosition = cameraPosition + rayDirection*distanceToIntersection;\n        \n        textureCoordinate = intersectionPosition.xz*invTextureScale;\n        \n        // on firefox on my home PC it works without this, but I guess repeat texture mode doesn't working with frame buffers reliably\n\t\ttextureCoordinate = fract(textureCoordinate);\n        \n\t\t// point sample - might be better to have 2 versions of the texture with different filter modes rather than all this maths\n        //fragColour = texelFetch(iChannel0,ivec2(textureCoordinate*iResolution.xy)%ivec2(iResolution.xy),0);\n        fragColour = texture(iChannel1,textureCoordinate);\n        height = FoldHeight(fragColour.a,textureCoordinate);\n        \n        // stop marching once we sample something at or above the march height\n        if ( 1.-height < sliceProportion ) break;\n        \n        distanceToPlaneAlongNormal -= sliceStep; // subtract because distance is negative, easy to explain with a diagram\n    }\n    \n    // sorry for the cryptic maths here\n    vec2 d = vec2(1,0)/iResolution.xy;\n    vec3 normal = cross(\n    \t\t\t\tvec3(0,\n    \t\t\t\t(\n                    \tFoldHeight( texture(iChannel0,textureCoordinate+d.yx).a, textureCoordinate+d.yx )\n    \t\t\t\t\t-FoldHeight( texture(iChannel0,textureCoordinate-d.yx).a, textureCoordinate-d.yx )\n                     ) * displacementHeight\n                    ,d.x / invTextureScale.x)\n                    ,\n    \t\t\t\tvec3(d.x / invTextureScale.x,\n                    (\n                        FoldHeight( texture(iChannel0,textureCoordinate+d.xy).a, textureCoordinate+d.xy )\n                        -FoldHeight( texture(iChannel0,textureCoordinate-d.xy).a, textureCoordinate-d.xy )\n                     ) * displacementHeight\n                    ,0)\n                   );\n// can get better normals for walls with less bevel if use Channel1 and smaller d, but that will break on smooth curves\n\n\tnormal = normalize(normal);\n\n\tvec3 reflectDirection = reflect(rayDirection,normal);\n    vec3 reflectionColour = texture(iChannel2,reflectDirection).rgb;\n    vec3 reflectionBlurred = textureLod(iChannel2,reflectDirection,3.).rgb;\n    \n    // darken reflections below the horizon so it looks like the plane's reflecting itself\n    reflectionColour *= mix( vec3(.3), reflectionColour, smoothstep(.0,.1,reflectDirection.y) );\n    reflectionBlurred *= mix( vec3(.3), reflectionColour, smoothstep(.0,.1,reflectDirection.y) );\n    \n    // fake - desaturate metallic reflections\n    reflectionBlurred = mix( reflectionBlurred.ggg, reflectionBlurred, .1 );\n    \n    \n    float metallicity = step(.7,fract(fragColour.a*11.));\n\n\t// lighting\n    vec3 lighting = vec3(.1,.2,.3) + vec3(2.5,2.2,2)*1.5 * max(0.,dot(normal,normalize(vec3(2,1,3))));\n    fragColour.rgb *= mix( lighting, reflectionBlurred, metallicity );\n    \n    // reflection\n    float fresnel = .02+.98*pow(min(1.+dot(rayDirection,normal),1.),5.);\n    fragColour.rgb = mix( fragColour.rgb, reflectionColour, fresnel );\n\n\t// darken deeper parts\n    fragColour = mix( fragColour, vec4(0), sliceProportion ); \n    \n    // atmospheric fog\n    fragColour = mix( vec4(1.), fragColour, exp2( -distanceToIntersection * vec4(.1,.125,.2,1)/20. ) );\n    \n    // stretch contrast\n    fragColour = clamp(fragColour*1.-.04,0.,1.);\n\n//\tfragColour.rgb = .5+.5*normal/(abs(normal)+.1);//\n    fragColour.rgb = pow(fragColour.rgb,vec3(1./2.2));\n\n/*\n// debug greeble buffer\n    fragColour = texelFetch( iChannel0, ivec2(fragCoord + iTime*vec2(80,30))%ivec2(iResolution.xy), 0 );\n//    fragColour = step(vec4(abs(fract(iTime*.1)*2.-1.)),fragColour);\n*/\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// set this to 1 to stop the pattern refreshing periodically\n#define BUILD_ONLY_ONCE 0\n\n\n// Draw a JSplacement style pattern to use as a displacement map\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n\tfragColour = texelFetch( iChannel0, ivec2(fragCoord), 0 );\n    \n#if (BUILD_ONLY_ONCE)\n\t// generate only first time\n\tif ( iFrame == 0 ) fragColour = vec4(.5);\n\tif ( iFrame > 256 ) return;\n#else\n\t// generate repeatedly\n\tif ( iFrame%1024 == 0 ) fragColour = vec4(.5);\n    if ( iFrame%1024 > 256 ) return;\n#endif\n    \n    // draw a shape\n    vec4 rand = hash4(coord2(ivec2(iFrame,1)));\n    vec4 rand2 = hash4(coord2(ivec2(iFrame,2)));\n    vec4 rand3 = hash4(coord2(ivec2(iFrame,3)));\n    \n    vec2 pos = iResolution.xy*rand.xy;\n\tfloat scale = exp2((rand.z-.5)*1.);\n    \n\tscale *= 640./iResolution.x;\n    \n\tfragCoord -= pos;\n    fragCoord *= scale;\n    \n    int rotFlip = int(floor(rand.w*8.))%8;\n    if ( (rotFlip&1) != 0 ) fragCoord.x = -fragCoord.x;\n    if ( (rotFlip&2) != 0 ) fragCoord.y = -fragCoord.y;\n    if ( (rotFlip&4) != 0 ) fragCoord.xy = fragCoord.yx;\n\n    \n    // draw blit with a wrap, to make a tileable texture\n    fragCoord = mod(fragCoord+iResolution.xy*.5,iResolution.xy)-iResolution.xy*.5;\n    \n\t// choose blit type\n    int blitType = int(floor(rand.x*255.999));\n    \n    // rectangle with missing corner\n//    if ( abs(fragCoord.x) < 30. && abs(fragCoord.y) < 20. && fragCoord.x+fragCoord.y < 30. )\n    \n    bool blit = abs(fragCoord.x) < 30.;\n    blit = blit && abs(fragCoord.y) < 20.;\n    if ( (blitType&1) != 0 ) blit = blit && fragCoord.x+fragCoord.y < 30.;\n    if ( (blitType&10) == 10 ) blit = blit && mod(fragCoord.x,8.) < 3.5;\n    if ( (blitType&12) == 12 ) blit = blit && mod(fragCoord.y,8.) < 2.5;\n    if ( (blitType&16) != 0 ) blit = blit && abs(fragCoord.x) > 3.;\n    if ( (blitType&32) != 0 ) blit = blit && abs(fragCoord.y) > 3.;\n    if ( (blitType&64) != 0 ) blit = blit && abs(fragCoord.x-20.) > 2.;\n    if ( (blitType&(128+16)) == 128 ) blit = blit && max(abs(fragCoord.x+10.),abs(fragCoord.y)) > 15.;\n\n\tif ( blit )\n    {\n    \t// can store any colour I want here, or generate it from height like jsplacement does\n    \t//fragColour = rand3;\n        float height = rand2.y;\n        fragColour.a = height;\n        \n        // colour lookup\n        // just use a slice of a texture! - meh\n        //fragColour.rgb = texture( iChannel1, vec2(height,.7) ).rgb;\n        vec3 clut[] = vec3[](vec3(0),vec3(.04),vec3(.08),vec3(.12),vec3(.16),vec3(.2),vec3(.5,.2,0),vec3(.5),vec3(.5),vec3(0,.1,.4),vec3(1),vec3(0,.3,.7));\n        fragColour.rgb = clut[min(int(floor(rand.z*12.)),11)];\n\n/*        float f = height*11.;//can't remember how to do this: float(length(clut)-1);\n        int idx = int(floor(f));\n        fragColour.rgb = mix( clut[idx], clut[idx+1], f-float(idx) );*/\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// random hash from here: https://www.shadertoy.com/view/4dVBzz\n#define M1 1597334677U     //1719413*929\n#define M2 3812015801U     //140473*2467*11\n#define M3 3299493293U     //467549*7057\n\n#define F0 (1.0/float(0xffffffffU))\n\n#define hash(n) n*(n^(n>>15))\n\n#define coord1(p) (uint(p)*M1)\n#define coord2(p) (uvec2(p).x*M1^uvec2(p).y*M2)\n#define coord3(p) (uvec3(p).x*M1^uvec3(p).y*M2^uvec3(p).z*M3)\n\nfloat hash1(uint n){return float(hash(n))*F0;}\nvec2 hash2(uint n){return vec2(hash(n)*uvec2(0x1U,0x3fffU))*F0;}\nvec3 hash3(uint n){return vec3(hash(n)*uvec3(0x1U,0x1ffU,0x3ffffU))*F0;}\nvec4 hash4(uint n){return vec4(hash(n)*uvec4(0x1U,0x7fU,0x3fffU,0x1fffffU))*F0;}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}