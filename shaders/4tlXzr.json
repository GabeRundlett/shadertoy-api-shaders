{
    "Shader": {
        "info": {
            "date": "1436219155",
            "description": "Navigating on the surface of the moon.\nRemake of [url=https://www.shadertoy.com/view/4slGRf]\"Moon Surface\"[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "4tlXzr",
            "likes": 11,
            "name": "Moon Surface II",
            "published": 3,
            "tags": [
                "raymarching",
                "terrain",
                "moon"
            ],
            "usePreview": 0,
            "username": "4rknova",
            "viewed": 1267
        },
        "renderpass": [
            {
                "code": "// by Nikos Papadopoulos, 4rknova / 2015\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define EPS\t\t.001\n#define PI\t\t3.14159265359\n#define RADIAN\t180. / PI\n#define SPEED\t25.\n\nfloat hash(in float n) { return fract(sin(n)*43758.5453123); }\n\nfloat hash(vec2 p)\n{\n    return fract(sin(dot(p,vec2(127.1,311.7))) * 43758.5453123);\n}\n\nfloat noise(vec2 p)\n{\n    vec2 i = floor(p), f = fract(p); \n\tf *= f*(3.-2.*f);\n    \n    vec2 c = vec2(0,1);\n    \n    return mix(mix(hash(i + c.xx), \n                   hash(i + c.yx), f.x),\n               mix(hash(i + c.xy), \n                   hash(i + c.yy), f.x), f.y);\n}\n\nfloat fbm(in vec2 p)\n{\n\treturn\t.5000 * noise(p)\n\t\t   +.2500 * noise(p * 2.)\n\t\t   +.1250 * noise(p * 4.)\n\t\t   +.0625 * noise(p * 8.);\n}\n\nfloat dst(vec3 p)\n{\n\treturn dot(vec3(p.x, p.y\n                    + 0.45 * fbm(p.zx) \n                    + 2.55 * noise(.1 * p.xz) \n                    + 0.83 * noise(.4 * p.xz)\n                    + 3.33 * noise(.001 * p.xz)\n                    + 3.59 * noise(.0005 * (p.xz + 132.453)) \n                    , p.z),  vec3(0.,1.,0.));\t\n}\n\nvec3 nrm(vec3 p, float d)\n{\n\treturn normalize(\n\t\t\tvec3(dst(vec3(p.x + EPS, p.y, p.z)),\n    \t\t\t dst(vec3(p.x, p.y + EPS, p.z)),\n    \t\t\t dst(vec3(p.x, p.y, p.z + EPS))) - d);\n}\n\nbool rmarch(vec3 ro, vec3 rd, out vec3 p, out vec3 n)\n{\n\tp = ro;\n\tvec3 pos = p;\n\tfloat d = 1.;\n\n\tfor (int i = 0; i < 64; i++) {\n\t\td = dst(pos);\n\n\t\tif (d < EPS) {\n\t\t\tp = pos;\n\t\t\tbreak;\n\t\t}\n\t\tpos += d * rd;\n\t}\n\t\n\tn = nrm(p, d);\n\treturn d < EPS;\n}\n\nvec4 render(vec2 uv)\n{\n    float t = iTime;\n    \n    vec2 uvn = (uv) * vec2(iResolution.x / iResolution.y, 1.);\n\t\n    float vel = SPEED * t;\n    \n\tvec3 cu = vec3(2. * noise(vec2(.3 * t)) - 1.,1., 1. * fbm(vec2(.8 * t)));\n\tvec3 cp = vec3(0, 3.1 + noise(vec2(t)) * 3.1, vel);\n\tvec3 ct = vec3(1.5 * sin(t), \n\t\t\t\t   -2. + cos(t) + fbm(cp.xz) * .4, 13. + vel);\n\t\t\n\tvec3 ro = cp,\n\t\t rd = normalize(vec3(uvn, 1. / tan(60. * RADIAN)));\n\t\n\tvec3 cd = ct - cp,\n\t\t rz = normalize(cd),\n\t\t rx = normalize(cross(rz, cu)),\n\t\t ry = normalize(cross(rx, rz));\n\n\trd = normalize(mat3(rx, ry, rz) * rd);\n    \n\n\tvec3 sp, sn;\n\tvec3 col = (rmarch(ro, rd, sp, sn) ?\n\t\t  vec3(.6) * dot(sn, normalize(vec3(cp.x, cp.y + .5, cp.z) - sp))\n\t\t: vec3(0.));\n\t\n\treturn vec4(col, length(ro-sp));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n        \n    if (abs(EPS + uv.y) >= .7) { \n\t\tfragColor = vec4(0,0,0,1);\n        return;\n\t}\n\t\n    vec4 res = render(uv);\n    \n    vec3 col = res.xyz;\n    \n    col *= 1.75 * smoothstep(length(uv) * .35, .75, .4);\n    float noise = hash((hash(uv.x) + uv.y) * iTime) * .15;\n\tcol += noise;\n\tcol *= smoothstep(EPS, 3.5, iTime);\n\n    fragColor = vec4(col, 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}