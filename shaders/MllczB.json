{
    "Shader": {
        "info": {
            "date": "1505392882",
            "description": "crossing planes indicate outer and inner near and far depths of scaled cube within frustum. Inner boundaries show 100% occlusion. The segments between outer and inner planes enclose a part of the surface.",
            "flags": 0,
            "hasliked": 0,
            "id": "MllczB",
            "likes": 11,
            "name": "Box Frustum Tracing",
            "published": 3,
            "tags": [
                "intersection",
                "box",
                "frustum"
            ],
            "usePreview": 0,
            "username": "paniq",
            "viewed": 1211
        },
        "renderpass": [
            {
                "code": "// Box Frustum Tracing\n// using 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n\n// for a description of the algorithm applied to ellipsoids see\n// https://gist.github.com/paniq/6c7a465b841dc2c87294c61108370389\n\n// note that this version is very verbose and purposefully lacks \n// any form of optimization for the sake of education.\n\nconst vec3 cube_init_center = vec3(0.0, 0.0, 3.0);\nconst vec2 min_frustum_half_size = vec2(1.77778,1.0)/30.0;\nconst vec2 max_frustum_half_size = vec2(1.77778,1.0)/6.0;\n\nconst int bound_none = 0;\nconst int bound_ray = 1;\nconst int bound_volume = 2;\nconst int bound_plane = 3;\n\nvec2 frustum_center;\nvec2 frustum_half_size;\nvec3 cube_center;\nvec3 cube_scale;\nvec4 cube_rotation;\nvec2 frustum_corners[4];\nvec3 frustum_ray_dirs[4];\nvec3 frustum_planes[4];\n// these are all in model space\nvec3 ms_frustum_apex;\nvec3 ms_frustum_ray_dirs[4];\nvec4 ms_frustum_planes[4];\nvec3 cube_corners[8];\nvec2 cube_ray_hits[4]; // these are scalars along the ray direction\nvec3 cube_edge_near[4];\nvec3 cube_edge_far[4];\nbvec2 cube_has_edge[4];\nbool cube_has_corner[8];\nvec2 outer_bound;\nvec2 inner_bound;\nivec2 outer_bound_type;\nivec2 inner_bound_type;\n\n// check only the horizontal frustum planes\nfloat dFrustumH(vec3 p) {\n    return max(\n        dot(p, frustum_planes[0]),\n        dot(p, frustum_planes[2]));    \n}\n\n// check only the vertical frustum planes\nfloat dFrustumV(vec3 p) {\n    return max(\n        dot(p, frustum_planes[1]),\n        dot(p, frustum_planes[3]));    \n}\n\nfloat dFrustum(vec3 p) {\n    return max(\n        dFrustumH(p),\n        dFrustumV(p));\n}\n\n// versor (unit quaternion) from axis and angle\nvec4 versor(vec3 axis, float angle) {\n    float a = angle * 0.5;\n    return vec4(axis * sin(a), cos(a));\n}\n\n// invert rotation\nvec4 conjugate(vec4 q) {    \n    return vec4(-q.xyz, q.w);\n}\n\n// rotate point by versor\n// q (t) * V * q (t) ^-1\nvec3 rotate(vec4 q, vec3 p) {\n    vec3 t = cross(q.xyz,p) * 2.0;\n    return p + q.w * t + cross(q.xyz, t);    \n}\n\nvec4 normalize_plane(vec4 pl) {\n    return pl / length(pl.xyz);\n}\n\n// transform vector in view space to model space\nvec3 modelspace_dir(vec3 v) {\n    return rotate(conjugate(cube_rotation), v) / cube_scale;\n}\n// transform vector in model space to view space\nvec3 viewspace_dir(vec3 v) {\n    return rotate(cube_rotation, v * cube_scale);\n}\n// transform point in view space to model space\nvec3 modelspace(vec3 p) {\n    return modelspace_dir(p - cube_center);\n}\n// transform point in model space to view space\nvec3 viewspace(vec3 p) {    \n    return viewspace_dir(p) + cube_center;\n}\n\n// from https://www.shadertoy.com/view/4s23DR\n// cube() by Simon Green\nvec2 intersect_unit_cube(vec3 org, vec3 dir)\n{\n\t// compute intersection of ray with all six bbox planes\n\tvec3 invR = -1.0/dir;\n\tvec3 tbot = invR * (org + 1.0);\n\tvec3 ttop = invR * (org - 1.0);\n\t\n\t// re-order intersections to find smallest and largest on each axis\n\tvec3 tmin = min (ttop, tbot);\n\tvec3 tmax = max (ttop, tbot);\n\t\n\t// find the largest tmin and the smallest tmax\n\tvec2 t0 = max(tmin.xx, tmin.yz);\n\tfloat near = max(t0.x, t0.y);\n\tt0 = min(tmax.xx, tmax.yz);\n\tfloat far = min(t0.x, t0.y);\n\n\t// check for hit\n    if (near < far && far > 0.0) {\n        return vec2(near, far);\n    } else {\n        return vec2(-1.0/0.0);\n    }\n}\nvec2 intersect_unit_cube(vec3 org, vec3 dir, out vec3 near_normal, out vec3 far_normal)\n{\n\t// compute intersection of ray with all six bbox planes\n\tvec3 invR = -1.0/dir;\n\tvec3 tbot = invR * (org + 1.0);\n\tvec3 ttop = invR * (org - 1.0);\n\t\n\t// re-order intersections to find smallest and largest on each axis\n\tvec3 tmin = min (ttop, tbot);\n\tvec3 tmax = max (ttop, tbot);\n\t\n\t// find the largest tmin and the smallest tmax\n\tvec2 t0 = max(tmin.xx, tmin.yz);\n\tfloat near = max(t0.x, t0.y);\n\tt0 = min(tmax.xx, tmax.yz);\n\tfloat far = min(t0.x, t0.y);\n\n\t// check for hit\n    if (near < far && far > 0.0) {\n        near_normal = -sign(dir) * step(tmin.yzx, tmin.xyz) * step(tmin.zxy, tmin.xyz);\n        far_normal = -sign(dir) * step(tmax.xyz, tmax.yzx) * step(tmax.xyz, tmax.zxy);        \n        return vec2(near, far);\n    } else {\n        return vec2(-1.0/0.0);\n    }\n}\n\n\nfloat intersect_plane_line(vec4 plane, vec3 ro, vec3 rd) {    \n    vec3 p0 = -dot(vec4(ro,1.0), plane)*plane.xyz;\n    return dot(p0, plane.xyz) / dot(rd, plane.xyz);\n}\n\nvoid intersect_plane_edge(int mc, vec4 plane, vec3 ro, vec3 rd, inout vec3 edge_near, inout vec3 edge_far, inout bvec2 has_edge) {\n    float d = intersect_plane_line(plane, ro, rd);\n    if (abs(d) < 1.0) {\n        vec3 p = viewspace(ro + rd * d);\n        float d;\n        if (mc == 0) {\n            d = dFrustumV(p);\n        } else {\n            d = dFrustumH(p);\n        }\n        if (d <= 0.0) {\n            if (!has_edge[0] || (p.z < edge_near.z)) {\n                edge_near = p;\n                has_edge[0] = true;\n            }\n            if (!has_edge[1] || (p.z > edge_far.z)) {\n                edge_far = p;\n                has_edge[1] = true;\n            }\n        }\n    }\n}\n\nvec2 lissajous(float t, float a, float b) {\n    return vec2(sin(a*t), sin(b*t));\n}\n\nvoid compute_bounds() {\n    outer_bound_type = ivec2(bound_none);\n    inner_bound_type = ivec2(bound_none);\n    outer_bound = vec2(1.0/0.0,-1.0/0.0);\n    inner_bound = vec2(-1.0/0.0,1.0/0.0);\n    \n    // check corners\n    for (int i = 0; i < 8; ++i) {\n        vec3 p = cube_corners[i];\n        if (cube_has_corner[i] && (p.z < outer_bound[0])) {\n        \touter_bound[0] = p.z;\n\t        outer_bound_type[0] = bound_volume;\n        }\n    }\n    // check edges\n    for (int i = 0; i < 4; ++i) {\n        if (cube_has_edge[i][0]\n            && (cube_edge_near[i].z < outer_bound[0])) {\n            outer_bound[0] = cube_edge_near[i].z;\n            outer_bound_type[0] = bound_plane;\n        }\n    }\n    // check faces\n    for (int i = 0; i < 4; ++i) {\n        if (cube_ray_hits[i].x >= 0.0) {\n            vec3 p = frustum_ray_dirs[i] * cube_ray_hits[i].x;\n            if (p.z < outer_bound[0]) {\n                outer_bound[0] = p.z;\n                outer_bound_type[0] = bound_ray;\n            }\n        }\n    }\n    // don't need to continue if we couldn't find a nearest depth\n    if (outer_bound_type[0] == bound_none) return;\n    \n    // check corners\n    for (int i = 0; i < 8; ++i) {\n        vec3 p = cube_corners[i];\n        if (cube_has_corner[i] && (p.z > outer_bound[1])) {\n        \touter_bound[1] = p.z;\n\t        outer_bound_type[1] = bound_volume;\n        }\n    }\n    // check edges\n    for (int i = 0; i < 4; ++i) {\n        if (cube_has_edge[i][1]\n            && (cube_edge_far[i].z > outer_bound[1])) {\n            outer_bound[1] = cube_edge_far[i].z;\n            outer_bound_type[1] = bound_plane;\n        }\n    }\n    // check faces\n    for (int i = 0; i < 4; ++i) {\n        if (cube_ray_hits[i].y >= 0.0) {\n            vec3 p = frustum_ray_dirs[i] * cube_ray_hits[i].y;\n            if (p.z > outer_bound[1]) {\n                outer_bound[1] = p.z;\n                outer_bound_type[1] = bound_ray;\n            }\n        }\n    }\n    \n    // we have an interior interval if all four corners\n    // hit the sphere\n    \n    int hits = 0;\n    for (int i = 0; i < 4; ++i) {\n        if (cube_ray_hits[i].x >= 0.0) {\n            hits++;\n        }    \n    }\n    \n    if (hits == 4) {\n        for (int i = 0; i < 4; ++i) {\n            if (cube_ray_hits[i].x >= 0.0) {\n                vec3 p0 = frustum_ray_dirs[i] * cube_ray_hits[i].x;\n                vec3 p1 = frustum_ray_dirs[i] * cube_ray_hits[i].y;\n                if (p0.z > inner_bound[0]) {\n                    inner_bound[0] = p0.z;\n                    inner_bound_type[0] = bound_ray;                \n                }\n                if (p1.z < inner_bound[1]) {\n                    inner_bound[1] = p1.z;\n                    inner_bound_type[1] = bound_ray;\n                }\n            }\n        }\n    }\n    \n    // if the interval is negative, we can't use it\n    if (inner_bound[1] < inner_bound[0]) {\n        inner_bound_type[0] = bound_none;\n    }    \n}\n\nvec4 plane_from_triangle(vec3 p0, vec3 d0, vec3 d1) {\n    vec3 n = normalize(cross(d0, d1));\n    return vec4(n, -dot(n, p0));\n}\n\nvoid setup_globals(float t) {\n    // move the frustum around\n    frustum_center = lissajous(t*0.07, 2.0, 1.0)*0.1;\n    // vary the frustum aperture\n    frustum_half_size = mix(\n        min_frustum_half_size,\n\t\tmax_frustum_half_size,\n        cos(t*0.13)*0.5+0.5);\n    \n    // move our cube around a bit\n    vec2 cube_offset = lissajous(t*0.2, 5.0, 4.0)*0.3;\n    cube_center = cube_init_center + vec3(cube_offset, 0.0);\n    cube_scale = vec3(\n        mix(0.2,1.0,cos(t*0.35)*0.5+0.5),\n        mix(0.2,1.0,cos(t*0.292)*0.5+0.5),\n        1.0);\n    cube_rotation = versor(normalize(vec3(1.0)), t*0.2);\n    \n    vec3 cd = vec3(1.0,-1.0,0.0);\n    cube_corners[0] = viewspace(vec3(cd.yyy));\n    cube_corners[1] = viewspace(vec3(cd.yyx));\n    cube_corners[2] = viewspace(vec3(cd.yxy));\n    cube_corners[3] = viewspace(vec3(cd.yxx));\n    cube_corners[4] = viewspace(vec3(cd.xyy));\n    cube_corners[5] = viewspace(vec3(cd.xyx));\n    cube_corners[6] = viewspace(vec3(cd.xxy));\n    cube_corners[7] = viewspace(vec3(cd.xxx));\n    \n    vec3 frustum_extents = vec3(frustum_half_size,-frustum_half_size.x);\n    frustum_corners[0] = frustum_center + frustum_extents.xy;\n    frustum_corners[1] = frustum_center + frustum_extents.zy;\n    frustum_corners[2] = frustum_center - frustum_extents.xy;\n    frustum_corners[3] = frustum_center - frustum_extents.zy;\n\n    ms_frustum_apex = modelspace(vec3(0.0));\n    \n    for (int i = 0; i < 4; ++i) {\n        frustum_ray_dirs[i] = normalize(vec3(frustum_corners[i],1.0));\n        ms_frustum_ray_dirs[i] = modelspace_dir(frustum_ray_dirs[i]);\n    }\n    \n    for (int i = 0; i < 4; ++i) {\n\t\tcube_ray_hits[i] = intersect_unit_cube(ms_frustum_apex, ms_frustum_ray_dirs[i]);\n    }\n    \n    frustum_planes[0] = normalize(cross(frustum_ray_dirs[1],frustum_ray_dirs[0]));\n    frustum_planes[1] = normalize(cross(frustum_ray_dirs[2],frustum_ray_dirs[1]));\n    frustum_planes[2] = normalize(cross(frustum_ray_dirs[3],frustum_ray_dirs[2]));\n    frustum_planes[3] = normalize(cross(frustum_ray_dirs[0],frustum_ray_dirs[3]));\n    \n    ms_frustum_planes[0] = plane_from_triangle(ms_frustum_apex,ms_frustum_ray_dirs[1],ms_frustum_ray_dirs[0]);\n    ms_frustum_planes[1] = plane_from_triangle(ms_frustum_apex,ms_frustum_ray_dirs[2],ms_frustum_ray_dirs[1]);\n    ms_frustum_planes[2] = plane_from_triangle(ms_frustum_apex,ms_frustum_ray_dirs[3],ms_frustum_ray_dirs[2]);\n    ms_frustum_planes[3] = plane_from_triangle(ms_frustum_apex,ms_frustum_ray_dirs[0],ms_frustum_ray_dirs[3]);\n    \n    for (int i = 0; i < 8; ++i) {\n        cube_has_corner[i] = (dFrustum(cube_corners[i]) <= 0.0);\n    }    \n    \n    for (int i = 0; i < 4; ++i) {\n        vec4 pl = ms_frustum_planes[i];\n        int mc = 0;\n        if ((i == 1)||(i == 3))\n            mc = 1;\n        cube_edge_near[i] = vec3(1.0/0.0);\n        cube_edge_far[i] = vec3(-1.0/0.0);\n        cube_has_edge[i] = bvec2(false);\n        intersect_plane_edge(mc, pl, cd.xxz, cd.zzx, cube_edge_near[i], cube_edge_far[i], cube_has_edge[i]);\n        intersect_plane_edge(mc, pl, cd.yxz, cd.zzx, cube_edge_near[i], cube_edge_far[i], cube_has_edge[i]);\n        intersect_plane_edge(mc, pl, cd.yyz, cd.zzx, cube_edge_near[i], cube_edge_far[i], cube_has_edge[i]);\n        intersect_plane_edge(mc, pl, cd.xyz, cd.zzx, cube_edge_near[i], cube_edge_far[i], cube_has_edge[i]);\n\n        intersect_plane_edge(mc, pl, cd.xzx, cd.zxz, cube_edge_near[i], cube_edge_far[i], cube_has_edge[i]);\n        intersect_plane_edge(mc, pl, cd.yzx, cd.zxz, cube_edge_near[i], cube_edge_far[i], cube_has_edge[i]);\n        intersect_plane_edge(mc, pl, cd.yzy, cd.zxz, cube_edge_near[i], cube_edge_far[i], cube_has_edge[i]);\n        intersect_plane_edge(mc, pl, cd.xzy, cd.zxz, cube_edge_near[i], cube_edge_far[i], cube_has_edge[i]);\n\n        intersect_plane_edge(mc, pl, cd.zxx, cd.xzz, cube_edge_near[i], cube_edge_far[i], cube_has_edge[i]);\n        intersect_plane_edge(mc, pl, cd.zyx, cd.xzz, cube_edge_near[i], cube_edge_far[i], cube_has_edge[i]);\n        intersect_plane_edge(mc, pl, cd.zyy, cd.xzz, cube_edge_near[i], cube_edge_far[i], cube_has_edge[i]);\n        intersect_plane_edge(mc, pl, cd.zxy, cd.xzz, cube_edge_near[i], cube_edge_far[i], cube_has_edge[i]);        \n    }\n    \n\tcompute_bounds();    \n   \n}\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the new source with the old one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n};\n\nfloat AA;\nfloat AAINV;\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n#define save(name) Context name = _save();\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\nconst float max_frustum_depth = 5.0;\nconst vec3 light_dir = normalize(vec3(-1.0, -1.0, 1.0));\nconst vec3 backlight_dir = normalize(vec3(0.8, 1.0, -1.0));\n\n\n// from https://www.shadertoy.com/view/4sjXW1\nvec3 tex(in vec2 p)\n{\n    float frq =50.3;\n    p += 0.405;\n    return vec3(1.)*smoothstep(.9, 1.05, max(sin((p.x)*frq),sin((p.y)*frq)));\n}\n\nfloat checkers(vec3 p) {\n    vec3 q = floor(p);\n    return mod(q.x + q.y + q.z, 2.0);\n}\n\nvoid paint_cube(vec3 ro, vec3 rd) {\n    vec3 ms_ro = modelspace(ro);\n    vec3 ms_rd = modelspace_dir(rd);\n    vec3 near_normal, far_normal;\n    vec2 range = intersect_unit_cube(ms_ro, ms_rd, near_normal, far_normal);\n    if (range.x > 0.0) {\n        add_field(-1.0);\n        vec3 dist = rd * range.x;\n        float df = dFrustum(ro + dist);\n        vec3 far_dist = rd * range.y;\n        float far_df = dFrustum(ro + far_dist);\n        vec3 ms_p_near = ms_ro + ms_rd * range.x;\n        vec3 ms_p_far = ms_ro + ms_rd * range.y;\n        vec3 normal;\n        vec3 ms_p;\n        bool backface = false;\n        if ((df < 0.0)||(far_df > 0.0)) {\n            normal = near_normal;\n            ms_p = ms_p_near;\n        } else {\n            ms_p = ms_p_far;\n            backface = true;\n            dist = far_dist;\n            df = far_df;\n            normal = far_normal;\n        }\n        vec3 color = vec3(0.0, 0.05, 0.1);\n        float lit = max(dot(normal, light_dir), 0.0);\n        float backlit = max(dot(normal, backlight_dir), 0.0);\n        color += lit * vec3(1.0,0.9,0.8);\n        color += backlit * vec3(1.0);\n        color *= vec3(mix(0.5,1.0,checkers(ms_p * 2.01)));\n        if (df < 0.0) {\n            if (backface) {\n                color *= vec3(0.7,0.9,1.0);\n            }                \n        }\n        color = pow(color, vec3(0.5));\n        color = mix(color, vec3(1.0), float(df > 0.0)*0.8);\n        color = mix(vec3(0.0), color, clamp((abs(df)-AAINV*1.5)*AA,-1.0,1.0)*0.5+0.5);\n        set_source_rgb(color);\n\t    fill();\n\t    new_path();\n    }\n}\n\nvoid paint_cube_zx() {\n    vec2 pt = get_origin();\t\n    paint_cube(\n        vec3(-pt[1], 2.0, pt[0]),\n        vec3(0.0, -1.0, 0.0));    \n}\n\nvoid paint_cube_zy() {\n    vec2 pt = get_origin();\t\n    paint_cube(\n        vec3(2.0, pt[1], pt[0]),\n        vec3(-1.0, 0.0, 0.0));    \n}\n\nvoid paint_cube_xy() {\n    vec2 pt = get_origin();\t\n    paint_cube(\n        vec3(pt[0], pt[1], -2.0),\n        vec3(0.0, 0.0, 1.0));\n}\n\nvoid paint_frustum_edges(vec2 pt[4]) {\n    for (int i = 0; i < 4; ++i) {\n\t\tmove_to(0.0, 0.0);\n\t\tline_to(pt[i]);\n    }\n    move_to(pt[0]);\n    for (int i = 1; i < 4; ++i) {\n\t\tline_to(pt[i]);\n    }    \n    close_path();\n}\n\nvoid paint_frustum_zx() {\n\tvec2 pts[4];\n    for (int i = 0; i < 4; ++i) {\n        vec3 corner = vec3(frustum_corners[i],1.0) * max_frustum_depth;\n        pts[i] = vec2(corner[2],-corner[0]);\n\t}\n    paint_frustum_edges(pts);\n}\nvoid paint_frustum_zy() {\n\tvec2 pts[4];\n    for (int i = 0; i < 4; ++i) {\n        vec3 corner = vec3(frustum_corners[i],1.0) * max_frustum_depth;\n        pts[i] = vec2(corner[2],corner[1]);\n\t}\n    paint_frustum_edges(pts);\n}\nvoid paint_frustum_xy() {\n\tvec2 pts[4];\n    for (int i = 0; i < 4; ++i) {\n        vec3 corner = vec3(frustum_corners[i],1.0) * max_frustum_depth;\n        pts[i] = vec2(corner[0],corner[1]);\n\t}\n    paint_frustum_edges(pts);\n}\n\nvec3 bound_color(int bound) {\n    if (bound == bound_volume) {\n        return vec3(1.0,0.0,0.5);\n    } else if (bound == bound_plane) {\n        return vec3(0.0,0.5,1.0);\n    } else if (bound == bound_ray) {\n        return vec3(1.0,0.5,0.0);\n    } else {\n        return vec3(0.0);\n    }\n}\n\nvoid paint() {\n    float t = iTime;\n    setup_globals(t);    \n        \n    float rdot = AAINV*8.0;\n\n    scale(0.4);\n\t\n    save(topview);\n    translate(-1.0,0.9);\n    save(topviewctx);\n    paint_cube_zx();\n    if (outer_bound_type[0] != bound_none) {\n        if (inner_bound_type[0] != bound_none) {\n            vec3 p0 = vec3(frustum_corners[1],1.0) * inner_bound[0];\n            vec3 p1 = vec3(frustum_corners[0],1.0) * inner_bound[0];\n            vec3 p2 = vec3(frustum_corners[0],1.0) * inner_bound[1];\n            vec3 p3 = vec3(frustum_corners[1],1.0) * inner_bound[1];\n            set_source_rgba(1.0,0.5,0.0,0.3);\n            move_to(p0.z, -p0.x);\n            line_to(p1.z, -p1.x);\n            line_to(p2.z, -p2.x);\n            line_to(p3.z, -p3.x);\n            close_path();\n            set_line_width(0.2);\n            fill();\n        }        \n        vec3 p0 = vec3(frustum_corners[1],1.0) * outer_bound[0];\n        vec3 p1 = vec3(frustum_corners[0],1.0) * outer_bound[0];\n        vec3 p2 = vec3(frustum_corners[0],1.0) * outer_bound[1];\n        vec3 p3 = vec3(frustum_corners[1],1.0) * outer_bound[1];\n        set_line_width_px(1.0);\n        set_source_rgb(bound_color(outer_bound_type[0]));\n\t\tmove_to(p0.z, -p0.x); \n        line_to(p1.z, -p1.x);\n\t\tstroke();\n        set_source_rgb(bound_color(outer_bound_type[1]));\n\t\tmove_to(p2.z, -p2.x); \n        line_to(p3.z, -p3.x);\n\t\tstroke();        \n    }\n    set_source_rgb(vec3(0.0));\n    set_line_width_px(1.0);\n    paint_frustum_zx();\n    stroke();\n    set_source_rgb(0.0,0.5,1.0);\n    for (int i = 0; i < 4; ++i) {\n        if (i == 2) continue;\n        if (cube_has_edge[i][0]) {\n            circle(cube_edge_near[i].z, -cube_edge_near[i].x, rdot);\n        }\n        if (cube_has_edge[i][1]) {\n            circle(cube_edge_far[i].z, -cube_edge_far[i].x, rdot);\n        }\n    }\n    fill();                    \n    set_source_rgb(1.0,0.0,0.5);\n    for (int i = 0; i < 8; ++i) {\n        if (cube_has_corner[i]) {\n\t    \tcircle(cube_corners[i].z, -cube_corners[i].x, rdot);\n        }\n    }\n    fill();                  \n    restore(topview);\n\t\n    save(sideview);\n    translate(-1.0,-1.6);\n    save(sideviewctx);\n    paint_cube_zy();\n    if (outer_bound_type[0] != bound_none) {\n        if (inner_bound_type[0] != bound_none) {\n            vec3 p0 = vec3(frustum_corners[0],1.0) * inner_bound[0];\n            vec3 p1 = vec3(frustum_corners[3],1.0) * inner_bound[0];\n            vec3 p2 = vec3(frustum_corners[3],1.0) * inner_bound[1];\n            vec3 p3 = vec3(frustum_corners[0],1.0) * inner_bound[1];\n            set_source_rgba(1.0,0.5,0.0,0.3);\n            move_to(p0.zy);\n            line_to(p1.zy);\n            line_to(p2.zy);\n            line_to(p3.zy);\n            close_path();\n            set_line_width(0.2);\n            fill();\n        }                \n        vec3 p0 = vec3(frustum_corners[0],1.0) * outer_bound[0];\n        vec3 p1 = vec3(frustum_corners[3],1.0) * outer_bound[0];\n        vec3 p2 = vec3(frustum_corners[3],1.0) * outer_bound[1];\n        vec3 p3 = vec3(frustum_corners[0],1.0) * outer_bound[1];\n        set_line_width_px(1.0);\n        set_source_rgb(bound_color(outer_bound_type[0]));\n\t\tmove_to(p0.zy); \n        line_to(p1.zy);\n\t\tstroke();\n        set_source_rgb(bound_color(outer_bound_type[1]));\n\t\tmove_to(p2.zy); \n        line_to(p3.zy);\n\t\tstroke();        \n    }    \n    set_source_rgb(vec3(0.0));\n    set_line_width_px(1.0);\n    paint_frustum_zy();\n    stroke();\n    set_source_rgb(0.0,0.5,1.0);\n    for (int i = 0; i < 4; ++i) {\n        if (cube_has_edge[i][0]) {\n            circle(cube_edge_near[i].z, cube_edge_near[i].y, rdot);\n        }\n        if (cube_has_edge[i][1]) {\n            circle(cube_edge_far[i].z, cube_edge_far[i].y, rdot);\n        }\n    }\n    fill();\n    set_source_rgb(1.0,0.0,0.5);\n    for (int i = 0; i < 8; ++i) {\n        if (cube_has_corner[i]) {\n\t    \tcircle(cube_corners[i].z, cube_corners[i].y, rdot);\n        }\n    }    \n    fill();    \n    restore(sideview);\n    \n\tsave(backview);\n    translate(-2.5,-0.4);\n    save(backviewctx);\n    paint_cube_xy();\n    if (outer_bound_type[0] != bound_none) {\n        {\n            vec3 p0 = vec3(frustum_corners[0],1.0) * outer_bound[1];\n            vec3 p1 = vec3(frustum_corners[1],1.0) * outer_bound[1];\n            vec3 p2 = vec3(frustum_corners[2],1.0) * outer_bound[1];\n            vec3 p3 = vec3(frustum_corners[3],1.0) * outer_bound[1];\n            set_source_rgba(vec4(bound_color(outer_bound_type[1]),0.3));\n            move_to(p0.xy);\n            line_to(p1.xy);\n            line_to(p2.xy);\n            line_to(p3.xy);\n            close_path();\n            set_line_width_px(1.0);\n            stroke();\n        }        \n        if (inner_bound_type[0] != bound_none) {\n            vec3 p0 = vec3(frustum_corners[0],1.0) * inner_bound[1];\n            vec3 p1 = vec3(frustum_corners[1],1.0) * inner_bound[1];\n            vec3 p2 = vec3(frustum_corners[2],1.0) * inner_bound[1];\n            vec3 p3 = vec3(frustum_corners[3],1.0) * inner_bound[1];\n            set_source_rgba(vec4(bound_color(inner_bound_type[1]),0.3));\n            move_to(p0.xy);\n            line_to(p1.xy);\n            line_to(p2.xy);\n            line_to(p3.xy);\n            close_path();\n            set_line_width_px(1.0);\n            stroke();            \n        }\n        {\n            vec3 p0 = vec3(frustum_corners[0],1.0) * outer_bound[0];\n            vec3 p1 = vec3(frustum_corners[1],1.0) * outer_bound[0];\n            vec3 p2 = vec3(frustum_corners[2],1.0) * outer_bound[0];\n            vec3 p3 = vec3(frustum_corners[3],1.0) * outer_bound[0];\n            set_source_rgb(bound_color(outer_bound_type[0]));\n            move_to(p0.xy);\n            line_to(p1.xy);\n            line_to(p2.xy);\n            line_to(p3.xy);\n            close_path();\n            set_line_width_px(1.0);\n            stroke();\n        }\n        if (inner_bound_type[0] != bound_none) {\n            vec3 p0 = vec3(frustum_corners[0],1.0) * inner_bound[0];\n            vec3 p1 = vec3(frustum_corners[1],1.0) * inner_bound[0];\n            vec3 p2 = vec3(frustum_corners[2],1.0) * inner_bound[0];\n            vec3 p3 = vec3(frustum_corners[3],1.0) * inner_bound[0];\n            set_source_rgb(bound_color(inner_bound_type[1]));\n            move_to(p0.xy);\n            line_to(p1.xy);\n            line_to(p2.xy);\n            line_to(p3.xy);\n            close_path();\n            set_line_width_px(1.0);\n            stroke();            \n        }        \n    }\n    set_source_rgb(vec3(0.0));\n    set_line_width_px(1.0);\n    paint_frustum_xy();\n    stroke();\n    set_source_rgb(1.0,0.0,0.5);\n    for (int i = 0; i < 8; ++i) {\n        if (cube_has_corner[i]) {\n\t    \tcircle(cube_corners[i].x, cube_corners[i].y, rdot);\n        }\n    }    \n    fill();    \n    restore(backview);\n\n    for (int i = 0; i < 4; ++i) {\n        vec2 dists = cube_ray_hits[i];\n        restore(backviewctx);\n        set_source_rgb(0.0,0.5,1.0);\n        if (cube_has_edge[i][0]) {            \n            circle(cube_edge_near[i].x, cube_edge_near[i].y, rdot);\n        }\n        if (cube_has_edge[i][1]) {\n            circle(cube_edge_far[i].x, cube_edge_far[i].y, rdot);\n        }        \n        fill();                    \n        if (dists.x > 0.0) {\n\t        vec3 enter = frustum_ray_dirs[i] * dists.x;\n            vec3 leave = frustum_ray_dirs[i] * dists.y;\n\t\t    restore(backviewctx);\n            set_source_rgb(1.0,0.5,0.0);\n            circle(enter.x, enter.y, rdot);\n            circle(leave.x, leave.y, rdot);\n            fill();\n            if (i < 2) {\n\t\t\t    restore(topviewctx);\n                set_source_rgb(1.0,0.5,0.0);\n                circle(enter.z, -enter.x, rdot);\n                circle(leave.z, -leave.x, rdot);\n                fill();\n            }\n            if ((i == 0)||(i == 3)) {\n\t\t\t    restore(sideviewctx);\n                set_source_rgb(1.0,0.5,0.0);\n                circle(enter.z, enter.y, rdot);\n                circle(leave.z, leave.y, rdot);\n                fill();                \n            }\n        }\n    }\n    \n    \n}\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord) {\n    uv = fragCoord.xy / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(_color, 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));        \n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = vec2( ab.x*co, ab.y*si );\n\t\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(abs(f_x) / length(df_x));\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t aspect = vec2(iResolution.x / iResolution.y, 1.0);\n\t ScreenH = min(iResolution.x,iResolution.y);\n\t AA = ScreenH*0.4;\n\t AAINV = 1.0 / AA;\n\n    init(fragCoord);\n\n    paint();\n\n    blit(fragColor);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}