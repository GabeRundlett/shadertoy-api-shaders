{
    "Shader": {
        "info": {
            "date": "1523257799",
            "description": "Shiny telephone ",
            "flags": 32,
            "hasliked": 0,
            "id": "ldVyDG",
            "likes": 18,
            "name": "Telephone",
            "published": 3,
            "tags": [
                "raymarching",
                "telephone"
            ],
            "usePreview": 0,
            "username": "jvb",
            "viewed": 360
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = vec4(texture(iChannel0,uv));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// telefone by jvb\n// Apple logo by zachernuk https://www.shadertoy.com/view/ltX3Dr      \n\n\nvec3 rotatey(in vec3 p, float ang) { return vec3(p.x*cos(ang)-p.z*sin(ang),p.y,p.x*sin(ang)+p.z*cos(ang)); }\nvec3 rotatex(in vec3 p, float ang) { return vec3(p.x, p.y*cos(ang)-p.z*sin(ang),p.y*sin(ang)+p.z*cos(ang)); }\nvec3 rotatez(in vec3 p, float ang) { return vec3(p.x*cos(ang)-p.y*sin(ang),p.x*sin(ang)+p.y*cos(ang),p.z); }\n\nvec2 sph(in vec3 p, float r, float o) { return vec2(length(p)-r, o); }\nvec2 rbox(in vec3 p, in vec3 b, float r, float o) { return vec2(length(max(abs(p)-b,0.0))-r, o); }\nvec2 sdbox( vec3 p, vec3 b, float o ) { vec3 d = abs(p) - b; return vec2(min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)), o); }\nvec2 plane(in vec3 p, in vec3 n, float d, float o) { return vec2(dot(p,n)-d, o); }\n\nvec2 min2(in vec2 o1, in vec2 o2) { if (o1.x < o2.x) return o1; else return o2; }\nvec2 max2(in vec2 o1, in vec2 o2) { if (o1.x > o2.x) return o1; else return o2; }\nvec2 inv2 = vec2(-1.0, 1.0); \n\t\nbool rbox2d2(in vec2 p, in vec2 b, in float r) { \n\tfloat t = 0.002; \n\tvec3 col = vec3(1); \n\tb -= vec2(r,r); \n\tfloat d = length(max(abs(p),b)-b)-r; \n\tif (abs(d) < t)\n\t\treturn true; \n\treturn false;  \n}\nbool rbox2df(in vec2 p, in vec2 b, in float r) { \n\tfloat t = 0.01; \n\tvec3 col = vec3(1); \n\tb -= vec2(r,r); \n\tfloat d = length(max(abs(p),b)-b)-r; \n\tif (d < t)\n\t\treturn true; \n\treturn false;  \n}\n\nvec3 rbox2d(in vec2 p, in vec2 b, in float r) \n{\n\tvec3 col = vec3(0); \n\tfloat t = 0.0225;  // thickness\n\tfloat d = length(max(abs(p),b)-b)-r*1.0; \n\tif (abs(d) < t)\n\t\tcol = vec3(1); \n\treturn col; \n}\n\nvec3 box2d(in vec2 p, in vec2 b)\n{\n\tvec3 col = vec3(0); \n\tif (abs(p.x) < b.x && abs(p.y) < b.y)\n\t\tcol = vec3(1); \n\treturn col; \n}\n\nvec3 d0(in vec2 p) { vec3 col = vec3(0); col += rbox2d(p-vec2(-0.0,+0.0),vec2(0.2,0.3), 0.1); return col; }\nvec3 d1(in vec2 p) { vec3 col = vec3(0); col += rbox2d(p-vec2(0.0,+0.0),vec2(0.0,0.4), 0.0); return col; }\nvec3 d2(in vec2 p) { vec3 col = vec3(0); p.x *= -1.0; if (p.x < 0.0 && p.y > -0.1) col += max(col, rbox2d(p-vec2(+0.0,+0.2),vec2(0.2,0.1), 0.1)); p.x *= -1.0; if (p.x < 0.0 && p.y > 0.25) col += max(col, rbox2d(p-vec2(+0.0,+0.2),vec2(0.2,0.1), 0.1)); p *= vec2(1.0,-1.0); if (p.x < 0.0 && p.y > -0.1) col += max(col, rbox2d(p-vec2(+0.0,+0.2),vec2(0.2,0.1), 0.1)); p.x *= -1.0; if (p.x < 0.0 && p.y > 0.25) col += max(col, rbox2d(p-vec2(+0.0,+0.2),vec2(0.2,0.1), 0.1)); return col;}\nvec3 d3(in vec2 p) { vec3 col = vec3(0); p.y = abs(p.y); if (p.x < 0.0 && p.y > 0.3) col += rbox2d(p-vec2(0.0,+0.0),vec2(0.2,0.3), 0.1); if (p.x > 0.0 && p.y > -0.0) col += rbox2d(p-vec2(0.0,+0.2),vec2(0.2,0.1), 0.1); return col;}\nvec3 d4(in vec2 p) { vec3 col = vec3(0); if (p.x < -0.2 && p.y < 0.1) {col += rbox2d(p-vec2(+0.0,+0.2),vec2(0.2,0.1), 0.1); } col += rbox2d(p-vec2(+0.05,+0.0),vec2(0.25,0.0), 0.0); col += rbox2d(p-vec2(+0.3,+0.0),vec2(0.0,0.4), 0.0); col += rbox2d(p-vec2(-0.3,+0.25),vec2(0.0,0.15), 0.0); return col; }\nvec3 d5(in vec2 p) { vec2 op = p; vec3 col = vec3(0); if (p.x < 0.0 && p.y > -0.1) col += max(col, rbox2d(p-vec2(+0.0,+0.2),vec2(0.2,0.1), 0.1)); p.x *= -1.0; if (p.x < 0.0 && p.y > 0.25) col += max(col, rbox2d(p-vec2(+0.0,+0.2),vec2(0.2,0.1), 0.1)); p *= vec2(1.0,-1.0); if (p.x < 0.0 && p.y > -0.1) col += max(col, rbox2d(p-vec2(+0.0,+0.2),vec2(0.2,0.1), 0.1)); p.x *= -1.0; if (p.x < 0.0 && p.y > 0.25) col += max(col, rbox2d(p-vec2(+0.0,+0.2),vec2(0.2,0.1), 0.1)); return col;}\nvec3 d6(in vec2 p) { vec3 col = vec3(0); if (p.x < +0.2) col += rbox2d(p-vec2(+0.2,+0.2),vec2(0.4,0.1), 0.1); col += rbox2d(p-vec2(+0.0,-0.2),vec2(0.2,0.1), 0.1); return col;}\nvec3 d7(in vec2 p) { vec3 col = vec3(0); if ( p.y > 0.3) col += rbox2d(p-vec2(-0.0,+0.0),vec2(0.2,0.3), 0.1); col += rbox2d(p-vec2(+0.3,-0.05),vec2(0.0,0.35), 0.0); return col;}\nvec3 d8(in vec2 p) { vec3 col = vec3(0); col += rbox2d(p-vec2(+0.0,+0.2),vec2(0.2,0.1), 0.1); col += rbox2d(p-vec2(+0.0,-0.2),vec2(0.2,0.1), 0.1); return col; }\nvec3 d9(in vec2 p) { vec3 col = vec3(0); p *= vec2(-1.0,-1.0); if (p.x < +0.2) col += rbox2d(p-vec2(+0.2,+0.2),vec2(0.4,0.1), 0.1); col += rbox2d(p-vec2(+0.0,-0.2),vec2(0.2,0.1), 0.1); col += rbox2d(p-vec2(+0.1,+0.4),vec2(0.2,0.0), 0.0); return col;}\n\nfloat ls(vec2 p1, vec2 p2, vec2 p3) { return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y); }\nbool PointInTriangle (vec2 pt, vec2 v1, vec2 v2, vec2 v3) { bool b1, b2, b3; b1 = ls(pt, v1, v2) < 0.0;b2 = ls(pt, v2, v3) < 0.0; b3 = ls(pt, v3, v1) < 0.0; return ((b1 == b2) && (b2 == b3)); }\n\n\n\nvec2 scene(in vec3 p)\n{\n\tvec3 op = p; \n\tvec2 d = vec2(1000.0, -1.0); \n\t\n\td = min2(d, vec2(-1,1)*sdbox(p, vec3(8,6,64),1.0));\n\tp -= vec3(0,0,-16); \n\tp = rotatey(p,iTime*0.2+0.0*p.x*sin(iTime)); \n\tp = rotatex(p,iTime*0.3); \n\tp = rotatez(p,iTime*0.4); \n\n\tvec2 d2 = vec2(1,1)*rbox(p, vec3(2.0,00.25,4),1.0,0.0); \n\td2 = max2(d2, vec2(1,1)*sdbox(p, vec3(3.5,0.25,6),0.0)); \n\td2 = max2(d2, vec2(-1,1)*sph(p-vec3(0,1.1,4), 1.0, 0.0)); \n\td2 = max2(d2, vec2(-1,1)*sph(vec3(0,1,1)*(p-vec3(0,0.4,3.2)), 0.16, 0.0)); \n\td2 = max2(d2, vec2(-1,1)*sph(vec3(0,1,1)*(p-vec3(0,0.4,-4.5)), 0.16, 0.0)); \n\td = min2(d,d2) ;\n\n\n\treturn d; \n}\n\nvec3 get_normal(in vec3 p)\n{\n\tvec3 eps = vec3(0.001, 0, 0); \n\tfloat nx = scene(p + eps.xyy).x - scene(p - eps.xyy).x; \n\tfloat ny = scene(p + eps.yxy).x - scene(p - eps.yxy).x; \n\tfloat nz = scene(p + eps.yyx).x - scene(p - eps.yyx).x; \n\treturn normalize(vec3(nx,ny,nz)); \n}\n\nfloat draw_digit(in vec2 p, float d) \n{\n\tif (d == 0.0) if (d0(p.xy).x > 0.0) return 1.0; \n\tif (d == 1.0) if (d1(p.xy).x > 0.0) return 1.0; \n\tif (d == 2.0) if (d2(p.xy).x > 0.0) return 1.0; \n\tif (d == 3.0) if (d3(p.xy).x > 0.0) return 1.0; \n\tif (d == 4.0) if (d4(p.xy).x > 0.0) return 1.0; \n\tif (d == 5.0) if (d5(p.xy).x > 0.0) return 1.0; \n\tif (d == 6.0) if (d6(p.xy).x > 0.0) return 1.0; \n\tif (d == 7.0) if (d7(p.xy).x > 0.0) return 1.0; \n\tif (d == 8.0) if (d8(p.xy).x > 0.0) return 1.0; \n\tif (d == 9.0) if (d9(p.xy).x > 0.0) return 1.0; \n\treturn 0.0; \n}\nvec3 get_tex(in vec3 p) \n{\n\n\tvec3 op = p; \n\tvec3 col2 = vec3(0.5); \n\tvec3 col3 = vec3(0.75); \n\n\t\t\n\tif (p.y > 6.5) return vec3(2.0); \n\n\tvec3 c1 = vec3(1,1,1)*clamp(1.0/(1.0+2.5*abs(p.y+6.0)),-1.0,1.0);\n\tc1 += clamp(1.0/(1.0+2.5*abs(p.y-6.0)),-1.0,1.0);\n\n\treturn c1+0.1*sin(-2.0+0.4*p.z); \n}\n\n\n// Apple logo by zachernuk https://www.shadertoy.com/view/ltX3Dr      \nfloat addCircle(in vec2 uv, in vec2 p,float r,float a,float b) {\n\n    float t = 0.;\n\t vec2 rel = uv-mix(p,vec2(0.25,0.4), t);\n        float r1 = r;//mix(r, 0.2, t);\n    if(length(rel)<r1) {\n      \n        float angle = atan(rel.y,rel.x);\n        if(angle>3.141*0.95) { \n       //     angle-=2.*3.141;\n        }\n        if(angle>a && angle<b) {\n\t\t\treturn 1.;\n        } else {\n      //   outColor.g+=0.015;   \n        }\n    }\n    \n\treturn 0.;\n}\n\n\n\nbool isInApple(in vec2 uv) {\n    \n    float location = \n    addCircle(uv, vec2(0.234, 0.285), 0.067, -3.4,3.2)+\n    -2.75*addCircle(uv, vec2(0.222, 0.135), 0.099, -3.4,3.2)+\n    addCircle(uv, vec2(0.000, 0.399), 0.591, 0.15,0.76)+\n    addCircle(uv, vec2(0.075, 0.385), 0.195, -4.0,5.4)+\n    addCircle(uv, vec2(0.117, 0.424), 0.252, -3.5,-2.3)+\n    addCircle(uv, vec2(0.364, 0.385), 0.190, -3.4,3.2)+\n    addCircle(uv, vec2(0.452, 0.399), 0.588, 2.38,3.1)-\n\n    //bite\n  2.*addCircle(uv, vec2(0.630, 0.432), 0.189, -3.4,3.25)+ \n        \n    addCircle(uv, vec2(0.091, 0.720), 0.106, -3.4,3.2)+\n    addCircle(uv, vec2(0.220, 0.663), 0.169, -3.4,3.2)-\n   4.* addCircle(uv, vec2(0.223, 0.963), 0.17, -3.4,3.2)+\n        \n        \n    addCircle(uv, vec2(0.360, 0.720), 0.109, -3.4,3.2 ) +\n\n        \n     //leaf\n\n        9.* min(\n    addCircle(uv, vec2(0.193, 0.000), 0.180, -3.4,3.2),\n    addCircle(uv, vec2(0.388, 0.168), 0.180, -3.4,3.2));\n    \n    return location>=1.;\n}\n\n\nvec3 get_screen(in vec3 p)\n{\n    \n\tp -= vec3(0,0,-16); \n\tp = rotatey(p,iTime*0.2+0.0*p.x*sin(iTime)); \n\tp = rotatex(p,iTime*0.3); \n\tp = rotatez(p,iTime*0.4); \n    \n    //if (p.y > 0.0 && abs(p.x) < 1.0 && abs(p.z) < 1.0) \n//        return vec3(1);\n    \n   \tvec3 col = vec3(0);\n    if (p.y > 0.0) {\n        float dig1 = floor(mod(iTime, 10.0)); \n        float dig2 = floor(mod(iTime/10.0, 10.0)); \n    \tcol += vec3(1,1,1)*draw_digit(vec2(1,-1)*(p.xz-vec2(-0.5,-0.5)), dig2); \n    \tcol += vec3(1,1,1)*draw_digit(vec2(1,-1)*(p.xz-vec2(0.5,-0.5)), dig1); \n\t    if (abs(length(p.xz-vec2(0,-0.5)) -1.5) < 0.01) col += vec3(1,1,1);\n    }\n    else {\n        if (isInApple(vec2(-0.75,0.75)*(p.xz-vec2(+0.25,-3.0)))) {\n         \tcol = vec3(0.25);   \n        }\n    }\n    return col; \n}\n\n// ambient occlusion approximation\n// multiply with color\nfloat ambientOcclusion(vec3 p, vec3 n, float time)\n{\n    const int steps = 3;\n    const float delta = 0.5;\n\n    float a = 0.0;\n    float weight = 1.0;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta; \n        a += weight*(d - scene(p + n*d).x);\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\nfloat random(vec3 scale, float seed) { \n\treturn fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed); \n} \n\nvec3 cosineWeightedDirection(float seed, vec3 normal) {\n\tfloat u = random(vec3(12.9898, 78.233, 151.7182), seed); \n\tfloat v = random(vec3(63.7264, 10.873, 623.6736), seed); \n\tfloat r = sqrt(u); \n\tfloat angle = 6.283185307179586 * v; \n\tvec3 sdir, tdir; \n\tif (abs(normal.x)<.5) { \n\t\tsdir = cross(normal, vec3(1,0,0)); \n\t} else { \n\t\tsdir = cross(normal, vec3(0,1,0)); \n\t} \n\ttdir = cross(normal, sdir); \n\treturn r*cos(angle)*sdir + r*sin(angle)*tdir + sqrt(1.-u)*normal; \n} \n\nvec3 uniformlyRandomDirection(float seed) { \n\tfloat u = random(vec3(12.9898, 78.233, 151.7182), seed); \n\tfloat v = random(vec3(63.7264, 10.873, 623.6736), seed); \n\tfloat z = 1.0 - 2.0 * u; float r = sqrt(1.0 - z * z); \n\tfloat angle = 6.283185307179586 * v; \n\treturn vec3(r * cos(angle), r * sin(angle), z); \n} \n\nvec3 uniformlyRandomVector(float seed) { \n\treturn uniformlyRandomDirection(seed) * sqrt(random(vec3(36.7539, 50.3658, 306.2759), seed)); \n} \nvec3 mr(in vec3 ro, in vec3 rd, float time)\n{\n\tvec3 colorMask = vec3(1.0); \n\tvec3 color = vec3(0.0);  \n\t\n\tif (true) {\n\t\tvec3 pos = ro; \n\t\tfloat dist = 0.0; \n\t\tvec2 d; \n\t\t\n\t\tfor (int i = 0; i < 64; i++) {\n\t\t\td = scene(pos); \n\t\t\tpos += rd*d.x;\n\t\t\tdist += d.x; \n\t\t\t//pos += uniformlyRandomVector(time+float(i))*0.01; \n\t\t\t\n\t\t\n\t\t}\n\t\tif (dist < 1000.0 && abs(d.x) < 0.5 ) {\n\t\t\tfloat o = d.y;  \n\t\t\tvec3 n = get_normal(pos); \n\t\t\tfloat fres = clamp(dot(n,-rd), 0.0, 1.0); \n\t\t\tvec3 tex = get_tex(pos); \n\t\t\tvec3 surfaceColor = vec3(0); \n\t\t\tif (o == 0.0) {\n\t\t\t\t//surfaceColor = vec3(1,1,1); \n\t\t\t\t\t\t\n\t\t\t\tsurfaceColor = 0.5*tex*mix(vec3(1,1,1)*1.0,vec3(1,1,1)*0.2, fres); \n\t\t\t}\n\t\t\telse if (o == 1.0) {\n\t\t\t\tsurfaceColor = 1.0*tex*mix(vec3(1,1,1)*1.0,vec3(1,1,1)*0.6, fres); \n\t\t\t}\n\t\t\telse if (o == 2.0) {\n\t\t\t\tsurfaceColor =1.0* mix(vec3(1,1,0),vec3(1,1,0)*1.0, fres); \t\t\t\t\t\t\n\t\t\t}\n\n\t\t\tfloat shade = 1.0; //ambientOcclusion(pos+0.01*n, n, time); \n\t\t\tcolorMask *= surfaceColor; \n\t\t\tcolor += 1.0*colorMask*(0.25*surfaceColor*shade); //*clamp(dist*0.25, 0.0, 2.5); \n\t\t}\t\n\t\t\n\t\n\t\t\n\t}\t\n\t\n\t\n\treturn color; \n}\n\n\nvec3 rm(in vec3 ro, in vec3 rd, float time)\n{\n\tvec3 colorMask = vec3(1.0); \n\tvec3 color = vec3(0.0);  \n\t\n\tif (true) {\n\t\tvec3 pos = ro; \n\t\tfloat dist = 0.0; \n\t\tvec2 d; \n\t\t\n\t\tfor (int i = 0; i < 128; i++) {\n\t\t\td = scene(pos); \n\t\t\tpos += rd*d.x;\n\t\t\tdist += d.x; \n\t\t}\n\t\tif (dist < 1000.0 && abs(d.x) < 100.5) {\n\t\t\tfloat o = d.y;  \n\t\t\tvec3 n = get_normal(pos); \n\t\t\tvec3 l = normalize(vec3(0,1,0)); \n\t\t\tvec3 lightpos = vec3(0,0,+40); \n\t\t\t//float diff = clamp(dot(n,l), 0.0, 1.0); \n\t\t\tfloat fres = clamp(dot(n,-rd), 0.0, 1.0); \n\t\t\tvec3 tex = get_tex(pos); \n\t\t\tvec3 surfaceColor = vec3(0); \n\t\t\tif (o == 0.0) {\n                //tex = get_screen(pos);\n                #define MULTISAMPLE_TEX 1\n\t\t\t\t#if MULTISAMPLE_TEX \n\t\t\t\ttex = vec3(0);\n\t\t\t\t\tfor (int i = 0; i < 16; i++) {\n\t\t\t\t\t\tfloat AA = 0.01; \n\t\t\t\t\t\ttex += get_screen(pos + AA*uniformlyRandomVector(float(time)+float(i))); \n\t\t\t\t\t}\n\t\t\t\t\ttex /= 16.0;\n\t\t\t\t#else\n\t\t\t\t\ttex = get_screen(pos); \n\t\t\t\t#endif\n                \n\t\t\t\t//surfaceColor = 0.0*vec3(1,1,1); \n\t\t\t\tvec3 refl= 1.75*mr(pos+n*0.01, reflect(rd,normalize(n)), time); \n\t\t\t\tsurfaceColor = 2.0*refl*mix(vec3(1,1,1)*2.0,vec3(1,1,1)*0.2, fres); \n                surfaceColor += tex;\n\t\t\t\t\t\t\n\t\t\t}\n\t\t\telse if (o == 1.0) {\n\t\t\t\tsurfaceColor = tex*mix(vec3(1,1,1)*1.0,vec3(1,1,1)*1.0, fres); \n\t\t\t}\n\t\t\telse if (o == 2.0) {\n\t\t\t\tsurfaceColor =1.0* mix(vec3(1,1,1)*1.0,vec3(1,1,1)*1.0, fres)*(0.75+0.25*sin(2.3+0.25*pos.z)); \t\t\t\t\t\t\n\t\t\t}\n\t\t\t//surfaceColor *= clamp(dist*0.25, 0.0, 1.0);\n\t\t\t//vec3 surfaceColor = vec3(1.0)*0.5; \n\t\t\t#define PTAO 1\n\t\t\t#if PTAO\n\t\t\tfloat shade = ambientOcclusion(pos+0.01*n, n, time)*0.5+0.5; \n\t\t\t#else\n\t\t\tfloat shade = 1.0;\n\t\t\t#endif\n\t\t\tcolorMask *= surfaceColor; \n\t\t\tcolor += 1.0*colorMask*(0.25*surfaceColor*shade)*clamp(dist*0.25, 0.0, 2.5); \t\t\t\n\t\t}\t\n\t\telse {\n\t\t\tcolor = vec3(0); \t\n\t\t}\n\t\t\n\t}\n\n\treturn color; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = 2.0*( fragCoord.xy / iResolution.xy )-1.0;\n\tp.x *= iResolution.x/iResolution.y; // inb4 fabrice**\n\n\t\n\tvec3 campos = vec3(sin(iTime)*10.0,1,0); \n\tvec3 camtar = vec3(0,1,1); \n\tvec3 camup = vec3(0,1,0);\n\t\n\tvec3 camdir = normalize(camtar-campos);\n\tvec3 cu = normalize(cross(camdir, camup)); \n\tvec3 cv = normalize(cross(cu, camdir)); \n\t\n\tvec3 color = vec3(0.0); \n\t\n\t#define ANTIALIASING 0\n\t#if ANTIALIASING\n\tp += uniformlyRandomVector(iTime).xy*0.0025; \n\t#endif\n\t\n\tvec3 ro = vec3(0,0,-3.0);\n\tvec3 rd = normalize(vec3(p.x,p.y,-2.0)); \n\n\t\n\t// barrel distortion\n\t#if 1\n\trd = normalize(vec3(rd.xy, sqrt(max(rd.z*rd.z - dot(rd.xy, rd.xy)*0.2, 0.))));\n    \trd.z *= -1.0;\n\t#endif\n\n\n\tfloat aa = 0.01; \n\tfloat ta = 0.0; \n\tcolor += rm(ro, rd, iTime); \n\n\t\n\tcolor = pow(color, vec3(1.0/2.3))*1.0; \n\t#define COLOR_GRAIN 1\n\t#if COLOR_GRAIN\n\tcolor += uniformlyRandomVector(iTime)*0.1; \n\t#endif\n\tcolor = mix(color, texture(iChannel0,fragCoord.xy/iResolution.xy).xyz, 0.5);\n\tfragColor = vec4(color, 1.0); \n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}