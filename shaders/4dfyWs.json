{
    "Shader": {
        "info": {
            "date": "1490216998",
            "description": "Prevent texture tilling in case of using alpha clip materials",
            "flags": 0,
            "hasliked": 0,
            "id": "4dfyWs",
            "likes": 0,
            "name": "Prevent texture rep(cliping)",
            "published": 3,
            "tags": [
                "texture",
                "repetition",
                "alpha",
                "tilling",
                "clip"
            ],
            "usePreview": 0,
            "username": "Zabidon",
            "viewed": 525
        },
        "renderpass": [
            {
                "code": "// Noise function is taken from here (https://www.shadertoy.com/view/4djSRW)\n\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define LAYERS 4.0\n#define WIDTH 3.0\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n\nvec3 random(vec2 tuv, float offset) {\n    return hash32(floor(tuv) + offset);\n}\n\n// License: Do What The F**k You Want To But It's Not My Fault Public License v1 (WTFNMFPL-1.0)\n// Created by Osipov Kirill --- zabidon\n\nvec2 get_random_mapping(vec2 uv, float width, float rand) {\n    vec2 tile_uv = mod(uv, width);\n    vec3 tile_params = random(uv / width, rand);\n\n    float tile_angle = tile_params.z * 2.0 * 3.1415;\n    float sin_a = sin(tile_angle);\n    float cos_a = cos(tile_angle);\n\n    // center to origin\n    tile_uv -= vec2(0.5);\n\tfloat boarder_offset = max(\n        \tabs(0.5 * cos_a - 0.5 * sin_a),\n        \tabs(0.5 * cos_a + 0.5 * sin_a)\n    \t) - 0.5;\n    \n    // don't allow sample to be out of tile\n    tile_uv -= vec2(boarder_offset) + tile_params.xy * (width - 1.0 - 2.0 * boarder_offset);\n    \n    // apply random rotation\n    mat2 m = mat2(cos_a, -sin_a, sin_a, cos_a);\n    tile_uv = m * tile_uv;\n   \n    // move center back\n    tile_uv += vec2(0.5);\n    \n    return tile_uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 cuv = fragCoord.xy / iResolution.xy * (23.0 * sin(iTime / 5.) + 25.0);\n\n    vec4 accum_color = vec4(0.0);\n    for (float i = 0.0; i < LAYERS; i++) {\n        vec2 uv = get_random_mapping(cuv + i * (100.0 +  WIDTH / LAYERS), WIDTH, 0.0);\n    \n        vec4 c = clamp(uv, 0.0, 1.0) != uv\n                ? vec4(0.1,0.2,0.1, 1.0)\n                : texture(iChannel0, uv);\n        // get Van Damme: c.g - max( c.r, c.b ) > 0.05\n        \n        accum_color = c.g - max( c.r, c.b ) > 0.05 ? accum_color: c;\n    }\n\n\tfragColor = accum_color;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 36,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}