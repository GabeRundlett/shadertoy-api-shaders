{
    "Shader": {
        "info": {
            "date": "1668004723",
            "description": "Attempt at making a global illumination scene with pathtracing and indirect light only.\nMove the camera with the mouse!",
            "flags": 32,
            "hasliked": 0,
            "id": "dsSGRV",
            "likes": 17,
            "name": "Pathtracing Global illumination",
            "published": 3,
            "tags": [
                "ray",
                "gi",
                "lighting",
                "marching",
                "tracing",
                "indirect",
                "path",
                "emission",
                "emissive"
            ],
            "usePreview": 0,
            "username": "kishimisu",
            "viewed": 811
        },
        "renderpass": [
            {
                "code": "/* Second attempt at pathtracing, this time there is \n   no direct light at all, instead I set an emissive \n   property to specific objects that will allow to \n   light up the scene with indirect bounces only.\n   \n   This makes the raymarch faster as there's is no need\n   to march any light to calculate its shadow, but it\n   converges way slower. (this scene is still ok as \n   there are a lot of emissive objects)\n   \n   Setting the number of BOUNCES to 1 show that there is\n   no lighting except for the emissive objects surface.\n   \n   You can reset the samples by moving the camera around\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;\n    float t = texelFetch(iChannel0, ivec2(0.5), 0).r;\n    \n    col /= 1. + float(iFrame) - t;\n    col = pow(col, vec3(0.45));\n    \n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define BOUNCES 3\n\n#define MAX_ITER 250\n#define EPS 0.001\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define hash(p) fract(sin(p)*43758.5453)\n\nfloat sdBox(vec3 p, vec3 s) {\n  vec3 q = abs(p) - s;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0)-.0;\n}\n\nvec3 cosineDirection(float seed, vec3 nor) {\n    vec3 tc = vec3( 1.0+nor.z-nor.xy*nor.xy, -nor.x*nor.y)/(1.0+nor.z);\n    vec3 uu = vec3( tc.x, tc.z, -nor.x );\n    vec3 vv = vec3( tc.z, tc.y, -nor.y );\n    float u = hash( 78.233 + seed);\n    float v = hash( 10.873 + seed);\n    float a = 6.283185 * v;\n    return sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;\n}\n\nvec4 map(vec3 p, inout float em) {\n    vec3 p0 = p;\n\n    p.z = abs(p.z) - 5.;\n    float ground = p.y + 1.;\n    ground = min(ground, abs(p0.z + 5.7));\n   \n    vec3 pp = p + vec3(2.,0.,0.);\n    pp.x = mod(pp.x+2., 4.)-2.;\n    ground = min(ground, sdBox(pp, vec3(1.,1e5,1.)));\n    \n    vec3 ppp = p;\n    ppp.x = mod(ppp.x-2., 4.)-2.;\n    float box = sdBox(ppp - vec3(0., 9.*step(mod(p0.x/4.-.5, 6.), 3.),0.), vec3(1.));\n    \n    float spheres = length(p + vec3(-4.,0.,3.)) - 1.;\n    box = min(box, spheres);\n    \n    if (box < ground) {\n        em = 1.;\n        vec3 col = (sin(vec3(.02,.04,.06)*p*10.)+1.);\n        return vec4(col,box);\n    } \n    \n    em = 0.;\n    return vec4(1.,1.,1.,ground);\n}\n\nvec3 raymarch(vec3 ro, vec3 rd, inout vec3 col, inout float em) {\n    float t = 0.;\n    for (int i = 0; i < MAX_ITER; i++) {\n        vec3 p = ro + t*rd;\n        vec4 d = map(p, em);\n        \n        t += d.a;\n        if (d.a < EPS*t) {\n            col = d.rgb;\n            return p;\n        }\n        if (t > 250.) break;\n    }\n    col = vec3(-1.);\n    return vec3(0.);\n}\n\nvec3 normal(vec3 p) {\n    float em;\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0001;\n    return normalize(e.xyy*map(p + e.xyy, em).a + e.yyx*map(p + e.yyx, em).a + \n\t\t\t\t\t e.yxy*map(p + e.yxy, em).a + e.xxx*map(p + e.xxx, em).a);\n}\n\nvec3 render(vec3 ro, vec3 rd, float seed) {\n    vec3 colMask = vec3(1.0);\n    vec3 col     = vec3(0.0);\n    \n    for (int i = 0; i < BOUNCES; i++) {\n        vec3 hitCol;\n        float em = 0.;\n        vec3 p = raymarch(ro, rd, hitCol, em) - rd * .01;\n        \n        if (hitCol == vec3(-1.)) {\n            if (i == 0) return vec3(rd.y+.2)*.0;\n            break;\n        }\n        \n        vec3 n = normal(p);\n        float cseed = seed + 76.2 + 73.1*float(i) + 17.7*iTime;\n        \n        ro = p;\n        rd = cosineDirection(cseed, n);\n        \n        colMask *= hitCol;\n        col     += colMask * em;// * exp(-length(p*.01));\n    }\n    \n    return col;\n}\n\nvoid initRayOriginAndDirection(vec2 uv, inout vec3 ro, inout vec3 rd) {\n    vec2 m = iMouse.z == 0. ? vec2(0.1, 0.5) : iMouse.xy/iResolution.xy*2.-1.;  \n    ro = vec3(0., 6.5, 5.+abs(m.x)*15.); \n    ro.yz *= rot(m.y*.7);\n    ro.zx *= rot(m.x*2.-1.57);\n        \n    vec3 f = normalize(vec3(0.,1.,0.)-ro), r = normalize(cross(vec3(0,1,0), f));\n    rd = normalize(f + uv.x*r + uv.y*cross(f, r));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 ro, rd, color = texelFetch( iChannel0, ivec2(fragCoord), 0 ).xyz;\n    if (iMouse.z > 0. || iFrame == 0) color *= 0.;\n    \n    float seed = hash(dot(fragCoord, vec2(12.9898, 78.233)) + 1113.1*iTime); \n    vec2 of = vec2(hash(seed+13.271), hash(seed+63.216))-0.5;\n    vec2 uv = (2.*(fragCoord+of) - iResolution.xy)/iResolution.y;\n    \n    initRayOriginAndDirection(uv, ro, rd);\n    \n    color += render(ro, rd, seed);\n    \n    if (fragCoord == vec2(0.5, 0.5) && (iMouse.z > 0. || iFrame == 0)) color = vec3(float(iFrame));\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}