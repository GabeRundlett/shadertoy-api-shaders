{
    "Shader": {
        "info": {
            "date": "1510543077",
            "description": "Vers. 19-11-2017: Meteors! (pyBlob's), moonglow (returned), new moon (test), animated moon - \"day/night\". Work in progress (experiments). Original work & suggestions by Martijn Steinrucken aka BigWIngs. Thanks! https://www.shadertoy.com/view/4s33zf",
            "flags": 64,
            "hasliked": 0,
            "id": "ltSyWt",
            "likes": 24,
            "name": "Over the Moon+ [BigWings+]",
            "published": 3,
            "tags": [
                "2d",
                "tree",
                "stars",
                "moon",
                "night",
                "mask",
                "extraction"
            ],
            "usePreview": 0,
            "username": "twenkid",
            "viewed": 1774
        },
        "renderpass": [
            {
                "code": "/* Original work:\n 1. \"Over the Moon\" by Martijn Steinrucken aka BigWings - 2015\n  License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n 2. The meteor code from \"2D fractal trees\" by pyBlob: (the meteor routines) https://www.shadertoy.com/view/Mt33Dn\n \n 3.  +Todor Arnaudov's (Twenkid/Tosh) additions and integration. \n\n 4. Music: https://soundcloud.com/jrhodespianist/clair-de-lune-debussy\n \n [ Warning: Work in progress! Experiments and dirty code are present! ]\n\n// Version history:\n//\n// 13-11-2017: Added rotation of the Moon and corrected the glowing routine,\n//             so that it does not light up the landscape when the moon is under the horizon.\n//\n// 14-11-2017: Masked the moon out from the stars, varied the gradient of the light,\n//             optimized glowing after BigWIngs'suggestions.\n//\n//             However it appeared that the glow is correct even *without* masking,\n//             thus moonGlow was turned off.\n// \n// Work needed: [FIXED] There's a \"light leakage\" below horizon, perhaps due to\n//              \"black/0\" values of the landscape and trees contours.\n//\n//       Ideas: Drawing it inverted, starting from 1.0 and subtracting, or just quitting\n//             after any non-zero operation/marking a flag - a simple hit-check.\n\n   15-11-2017:  The light leakage was fixed: \n                vec4 mask = mix(col, trees, trees.a)*(1.-trees.a);\n                col = max(mask, trees);\n\n   16-11-2017: #define NEWMOON - experimental with noise textures, changed starsMasked (using .a).\n               Looks bad in full screen. A better and smoother crater generation is needed.\n               This one seems out of the style of the trees and the landscape.\n\n   19-11-2017: Returned the Bingwing's moonglow (fixed a bug in the masking in the moonglow function )\n               Meteors were added! (pyBlob routines)\n               Have been working on mapping of NickWest's craters to a sphere (moon). That shader is still a draft, though.\n               Strange bugs/black borders, noise on my main Windows machine, while on an older Linux computer it runs correctly,\n               both with Intel integrated GPUs. Something related to the noise generation routines/the fract-float-... implementations, I guess.\n\n   18-12-2017: Added Debussy's \"Claire de Lune\" as a soundtrack. Moon slowed down in order to sync it. /5. slowTrees = 0.6\n               \n// Future work: \n//\n// 1. [DONE] (credit: pyBlob): A falling star. Probably drawn in the moonglow routine in order\n//    to use the mask and the position of the moon, in order to synchronize it\n//    when the moon is below the horizon and then draw the meteor in the darkest part of the sky.\n//\n// 2. Trees swinging\n//\n// 3. Leafs and/or cones flying/rolling.\n//\n// 4. Day cycle - Moon sets, then Sun dawns, the sky turns blue, \n//    then the colors of the trees and the landscape get natural - brown, green.\n//\n// 5. Winter - snow falls and covers the trees and the landscape.\n//\n*/\n\n#define PI 3.1415\n#define S(x,y,z) smoothstep(x,y,z)\n#define B(x,y,z,b) S(x, x+b, z)*S(y+b, y, z)\n#define saturate(x) clamp(x,0.,1.)\n\n#define MOD3 vec3(.1031,.11369,.13787)\n\n#define MOONPOS vec2(1.3, .8)\n\n//twenkid\n\n#define NEWMOON 1  //Experimental with noise textures - one higher resolution and one lower\n#undef NEWMOON\n\n\nfloat slowTrees=0.66; //18-12-2017 - for more appropriate tempo (Claire de Lune) - in moonglow, mainImage *t\n\n/*\n NickWests' craters.  https://www.shadertoy.com/view/ldtXWf\n To be drawn over the moon later: \n*/\n\n/*\n//#define animSpeed 0.05 //not needed\n\n//-----------------------------------------------------------------------------\n// Crater in -1.0 to 1.0 space\nfloat crater(in vec2 pos) {\n    float len = length(pos);\n    float pi = 3.1415926535;\n    float x = clamp(pow(len, 4.0) * 8.0, pi*0.5, pi*2.5);\n    float t = clamp(len, 0.0, 1.0);\n    return sin(-x) + 0.5 - 0.5 * cos(t * pi);\n}\n\n//-----------------------------------------------------------------------------\nvec2 pseudoRand(in vec2 uv) {\n    // from http://gamedev.stackexchange.com/questions/32681/random-number-hlsl\n    float noiseX = (fract(sin(dot(uv, vec2(12.9898,78.233)      )) * 43758.5453));\n    float noiseY = (fract(sin(dot(uv, vec2(12.9898,78.233) * 2.0)) * 43758.5453));\n    return vec2(noiseX, noiseY);}\n\n//-----------------------------------------------------------------------------\nfloat repeatingCraters(in vec2 pos, in float repeat, in float scaleWeight) {\n    vec2 pos01 = fract(pos * vec2(repeat));\n    vec2 index = (pos * vec2(repeat) - pos01) / repeat;\n    vec2 scale = pseudoRand(index);\n    float craterY = crater(vec2(2.0) * (pos01 - vec2(0.5)));\n    return mix(1.0, pow(0.5*(scale.x + scale.y), 4.0), scaleWeight) * craterY; \n}\n\n//-----------------------------------------------------------------------------\nfloat getY(in vec2 pos) {    \n    float y = 0.5;\n    for(int i=0;i<int(20);++i) {\n        float f01 = float(i) / float(15); //float(99.0);\n        //float magnitude = pow(f01, 2.3);\n          float magnitude = f01*f01; // 2.3);\n        vec2 offs = pseudoRand(vec2(float(i+2), pow(float(i+7), 3.1)));\n        float repeat = 0.5 / (magnitude + 0.0001);\n\n        y += magnitude * repeatingCraters(pos+offs, repeat, 1.0);\n    }\n    \n\treturn y;\n}\n\n//-----------------------------------------------------------------------------\nvec4 drawCraters( in vec2 pos ) {\n//\tvec2 pos = (fragCoord.xy - iResolution.xy*0.5) / vec2(iResolution.y);\n    pos += vec2(1.0); // avoid negative coords\n\n    vec2 offs = vec2(0.001, -0.001);\n    \n    //After certain tenths of seconds - glitches in the image\n    \n   // pos.x += fract(iTime)*10. * animSpeed;\n   // pos.y -= fract(iTime)*10.0 * animSpeed * 0.25;\n\n\n     pos.x +=  0.; //fract(iTime)*10. * animSpeed;\n    pos.y -= 0.0 ;//fract(iTime)*10.0 * animSpeed * 0.25;\n    \n    float y = getY(pos);\n    float y1 = getY(pos - offs);\n    //float y2 = getY(pos + offs);\n\n    vec3 normal = normalize(vec3(0.01, y-y1, 0.01));\n\n    float d = 0.5 + 0.5 * dot(normal, normalize(vec3(2.0, 1.0, 2.0)));\n    \n    float shadeScale = 1.0;\n\n    float c = y * 0.02 - 0.5 + d * 1.3;\n\n    // color ramp\n    vec3 rgb = vec3(mix(mix(vec3(0.0,0.0,0.0), vec3(0.8,0.6,0.4), c), vec3(1.0,0.95,0.90), c));\n    \n    return vec4(rgb,1.0);\n}\n*/\n\n\n\n// pyBlob's meteor showers\n//https://www.shadertoy.com/view/Mt33Dn\n\n#define round2(x, f) (floor((x)/(f) + 0.5) * (f))\n\nfloat random(float p)\n{\n    return fract(52.043*sin(p*205.429));\n}\nfloat random2(float p)\n{\n    return random(p)*2.0-1.0;\n}\n\nvec3 meteor(vec2 uv, float gtime, float delay)\n{\n    float seed = round2(gtime, delay);\n    \n    float startTime = (delay - 1.5) * random(seed);\n    float time = max(0.0, min(1.0, gtime-seed - startTime));\n    \n    vec2 start = vec2(\n        random2(seed),\n        0.7 + 0.3 * random(seed+0.1)\n    );\n    \n    vec2 end = start * 0.5;\n    \n    uv = uv - mix(start, end, time);\n    \n    end = normalize(end - start);\n    uv = uv * mat2(end.x, end.y, -end.y, end.x);\n    uv.x *= 0.1;\n    \n    float alpha = 16.0 * pow(time, 2.0) * pow(time - 1.0, 2.0);\n    return vec3(max(0.0, alpha - iResolution.y * length(uv)));\n}\n\nvec3 meteorstorm(vec2 uv)\n{\n    return\n        meteor(uv, iTime, 9.5837/1.4) +\n        meteor(uv, iTime + 15.3, 15.459/1.5) +\n        meteor(uv, iTime + 125.0, 31.2/1.3);\n}\n\n//End of pyBlob's meteor code\n\n//BigWings'\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p) {\n    // From Dave Hoskins\n\tvec3 p3  = fract(vec3(p) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//  1 out, 2 in...\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat remap(float a, float b, float c, float d, float t) {\n\treturn ((t-a) / (b-a)) * (d-c) + c;\n}\n\nfloat within(float a, float b, float t) {\t\n    return (t-a) / (b-a); \n    \n}\n\n\n\nfloat Band(float t,float start, float end, float blur){\n    float step1 = smoothstep(start - blur, start + blur, t);\n    float step2 = smoothstep(end + blur, end - blur, t);\n    return step1 * step2;\n}\n\nfloat Rect2(vec2 uv, float width, float height, float blur, float size){\n    uv /= size;\n    float band1 = Band(uv.x, -width, width, blur);\n    float band2 = Band(uv.y, -height, height, blur);\n    return band1 * band2 ;\n}\n\nfloat Rect(vec2 uv, float left, float right, float bottom, float top, float blur, float size){\n    uv /= size;\n    float band1 = Band(uv.x, left, right, blur);\n    float band2 = Band(uv.y, bottom, top, blur);\n    return band1 * band2 ;\n}\n\n\nfloat skewbox(vec2 uv, vec3 top, vec3 bottom, float blur) {\n\tfloat y = within(top.z, bottom.z, uv.y);\n    float left = mix(top.x, bottom.x, y);\n    float right = mix(top.y, bottom.y, y);\n    \n    float horizontal = B(left, right, uv.x, blur);\n    float vertical = B(bottom.z, top.z, uv.y, blur);\n    return horizontal*vertical;\n}\n\nvec4 pine(vec2 uv, vec2 p, float s, float focus) {\n\tuv.x -= .5;\n    float c = skewbox(uv, vec3(.0, .0, 1.), vec3(-.14, .14, .65), focus);\n    c += skewbox(uv, vec3(-.10, .10, .65), vec3(-.18, .18, .43), focus);\n    c += skewbox(uv, vec3(-.13, .13, .43), vec3(-.22, .22, .2), focus);\n    c += skewbox(uv, vec3(-.04, .04, .2), vec3(-.04, .04, -.1), focus);    \n        \n    vec4 col = vec4(1.,1.,1.,0.);\n    col.a = c;\n   \n    float shadow = skewbox(uv.yx, vec3(.6, .65, .13), vec3(.65, .65, -.1), focus);\n    shadow += skewbox(uv.yx, vec3(.43, .43, .13), vec3(.36, .43, -.2), focus);\n    shadow += skewbox(uv.yx, vec3(.15, .2, .08), vec3(.17, .2, -.08), focus);\n    \n    col.rgb = mix(col.rgb, col.rgb*.8, shadow);\n    \n    return col;\n}\n\nfloat getheight(float x) {\n    return sin(x) + sin(x*2.234+.123)*.5 + sin(x*4.45+2.2345)*.25;\n}\n\nvec4 landscape(vec2 uv, float d, float p, float f, float a, float y, float seed, float focus) {\n\tuv *= d;\n    float x = uv.x*PI*f+p;\n    float c = getheight(x)*a+y;\n    \n    float b = floor(x*5.)/5.+.1;\n    float h =  getheight(b)*a+y;\n    \n    float e = fwidth(uv.y);\n    \n    vec4 col = vec4(S(c+e, c-e, uv.y));\n    //col.rgb *= mix(0.9, 1., abs(uv.y-c)*20.);\n    \n    x *= 5.;\n    float id = floor(x);\n    float n = hash11(id+seed);\n    \n    x = fract(x);\n    \n    y = (uv.y - h)*mix(5., 3., n)*3.5;\n    float treeHeight = (.07/d) * mix(1.3, .5, n);\n    y = within(h, h+treeHeight, uv.y);\n    x += (n-.5)*.6;\n    vec4 pineCol = pine(vec2(x, y/d), vec2(0.), 1., focus);\n    //col += pineCol;\n    col.rgb = mix(col.rgb, pineCol.rgb, pineCol.a);\n    col.a = max(col.a, pineCol.a);   \n    \n    \n    return saturate(col);\n}\n\nvec4 gradient(vec2 uv) {\n    \n\tfloat c = 1.-length(MOONPOS-uv)/1.4;\n    \n    vec4 col = vec4(c);\n    \n    return col;\n}\n\n/*\nfloat circMask(vec2 uv, vec2 pos, float radius) {\n\tfloat dist = length(uv-pos);    \n    return S(radius+blur, radius-blur, dist);\n}\n*/\n\nfloat circ(vec2 uv, vec2 pos, float radius, float blur) {\n\tfloat dist = length(uv-pos) + hash11(pos.x)*0.02;\n    return S(radius+blur, radius-blur, dist);\n}\n\nvec4 moon(vec2 uv) {\n   \n    float focus = 0.001; //default moon\n    \n    #ifdef NEWMOON\n    focus = 0.005; //set more blur due to to the contrast from the noise\n    #endif\n    \n    float c = circ(uv, MOONPOS, .07, focus);\n    //float c = circ(uv, MOONPOS, .07, .001); //default\n   \t\n    \n    #ifndef NEWMOON\n    c *= 1.-circ(uv, MOONPOS+vec2(.03), .07, .001)*0.95; //.95 --> original moon; <... -- darker \n    c = saturate(c);\n    #endif\n    \n    \n    vec4 col = vec4(c);\n    //col.rgb *=.8; //original\n    float moonMult = 0.8; \n    #ifdef NEWMOON\n    moonMult -= (texture(iChannel0, uv).x + texture(iChannel1, uv).x); //*max(0.5,abs(sin(iTime)))*4.0;\n    #endif\n    col.rgb *= moonMult;\n    //float b = clamp(col.b*1.1, 1.0, 1.0);\n    //col.b = b;\n   // col.b*=1.3; col.g*=0.8; col.r*=0.7;\n    \n    //col.rgb *=.8 - (texture(iChannel0, uv).x + texture(iChannel1, uv).x); //original\n    //float craters = min(0.4, texture(iChannel0, uv).x + texture(iChannel1, uv).x);// hash11(iTime)/20.0;\n   // float craters = (texture(iChannel0, uv).x + texture(iChannel1, uv).x)*(circ(uv, MOONPOS, .07, .001);\n   // craters = clamp(craters, 0., 0.5);\n    //col.rgb-=craters;\n    \n    return col;\n      \n}\n\n\n//Todor added uvBasic and the extraction of the glow from the landscape and the trees.\n//Without these modification, the landscape would glow.\nvec4 moonglow(vec2 uv, float foreground, vec2 uvBasic, vec2 guv) {\n    \n   \tfloat c = circ(uv, MOONPOS, .1, .2);\n    \n    vec4 col = vec4(c);\n    col.rgb *=.2;\n    \n    \n    // \"Mask extraction\" - could be in a function.\n    // This is a copy of a segment from mainImage,\n    // which \"redraws the landscape and the trees\n    // in order to check if the glow is under the horizon.\n    \n    float dist = .10;\n    float height = -.01;\n    float amplitude = .02;\n    \n    dist = 1.;\n    height = .55;\n    float t = iTime*.05;\n    t*=slowTrees;  //18-12-2017\n    \n   // uvBasic = uv;\n    /*\n    vec4 trees = vec4(0.);\n    for(float i=0.; i<10.; i++) {    \n    \tvec4 layer = landscape(uvBasic, dist, t+i, 3., amplitude, height, i, .01);\n    \tlayer.rgb *= mix(vec3(.1, .1, .2), vec3(.3)+gradient(uvBasic).x, 1.-i/10.);\n        trees.rgb = mix(trees.rgb, layer.rgb, layer.a);\n        trees. a = max(trees.a, layer.a);\n        \n        dist -= .1;\n        height -= .06;\n    }\n    //If the pixel is not hitting the trees and the landscape, it would be black.\n    //Then, add the glow. Else - ignore this component.\n     vec4 mask = mix(col, trees, trees.a)*(1.-trees.a);\n    col= max(mask, trees.rgba);\n   // col*= trees.r <= 0.0 ? 1.0 : 0.; \n*/\n    \n    float horizon = 0.25;\n    float birghtness = 1.0 + horizon - uvBasic.y; \n    \n    vec4 trees = vec4(0.);\n    for(float i=0.; i<10.; i++) {    \n    \tvec4 layer = landscape(uvBasic, dist, t+i, 3., amplitude, height, i, .01); //1\n        //vec4 layer = landscape(uv, dist, t+i, 3., amplitude, height, i, .00); //1\n    \t       //layer.rgb *= mix(vec3(.1, .1, .2), vec3(.3)+gradient(uv).x, 1.-i/10.); //2 - black mask of the trees and landscape           \n        \n        //no gradient here\n       //// layer.rgb *= mix(vec3(.1, .1, .2), vec3(.1)+clamp(gradient(uv).x*birghtness, 0.0, 1.5)*2., 1.-i/10.);\n        \n              layer.rgb *= mix(vec3(.1, .1, .2), vec3(.1), 1.-i/10.);\n        \n        //layer.rgb *= mix(vec3(.1, .1, .2), vec3(.3), 1.-i/10.);  //the leakage is not due to the gradient?\n        \n                 //trees.rgb = mix(trees.rgb, layer.rgb, layer.a);\n                 //trees.rgb = mix(trees.rgb, layer.rgb, layer.a); //3 white trees, landscape with contours        \n        trees = mix(trees, layer, layer.a); //trees.rgba  = mix(trees.rgba, layer.rgba, layer.a);\n                 // trees.a = max(trees.a, layer.a);  ////BigWIngs optimization        \n        \n        dist -= .1;\n        height -= .06;\n    }\n    \n        vec4 mask = mix(col, trees, trees.a)*(1.-trees.a);\n   \n    \n    guv.y-=0.2;\n    vec3 m = meteorstorm(guv); //\n    m*=(1.-trees.a);\n    mask.rgb+=m;\n    \n    \n      return mask; //OK\n    //if (col.r > abs(sin(iTime/5.))) //trees.a >0.5)\n    //if (col.r > 0.5 && trees.r < 0.01 && trees.a  > 0.005) col = trees;//trees.a >0.5)\n    //else\n    //col = mix(col, trees, trees.a)*(1.-trees.a); //mask\n    \n    /* Sun :) ...\n\n    float maskline = Rect(uv, 0.87, 0.93-abs(cos(iTime*5.))/20., .65*uv.x + 0.05, 0.66*uv.x + 0.05, 0.005, 1.); //window\n    maskline *= max(0., pow(distance(uv, vec2(0.87,0.65-abs(cos(iTime*5.))/20.)),1.1))*60.;\n    mix(c, maskline, 1.0); //trees.a);\n    col.rgb = vec3(c);\n    vec4 mask = mix(col, trees, trees.a)*(1.-trees.a);\n    */\n    \n    //col = mix(col, trees, trees.a)*mask; //(1.-trees.a);\n    \n    \n      //White rectangle!\n    float maxdistance = 0.06; //distance(vec2(0.87, 0.65+0.25), vec2(0.87, 0.66+0.25)); //distance(uv, vec2(0.87,0.65);\n    //float maskline = Rect(uv-0.5, 0.2, 0.4, -.3, 0.3, 0.01, 1.); //window\n    //float maskline = Rect(uv, 0.87, 0.93+abs(cos(iTime*5.))/20., 0.65*uv.x + 0.05, 0.66*uv.x + 0.05, 0.005, 1.); //window\n    \n    /*\nfloat maskline = Rect(uv, 0.87, 0.93-abs(cos(iTime*5.))/20., 0.65*uv.x + 0.05, 0.66*uv.x + 0.05, 0.005, 1.); //window\n    maskline *= max(0., pow(maxdistance-distance(uv, vec2(0.87,0.65-abs(cos(iTime*5.))/20.)),1.2))*60.; //.*cos(distance(uv, vec2(0.87,0.65))); //smoothstep(18., 20.20.;\n*/\n    \n    /*\n    float maskline = Rect(uv, 0.87, 0.93-abs(cos(iTime*5.))/20., .65*uv.x + 0.05, 0.66*uv.x + 0.05, 0.005, 1.); //window\n    maskline *= max(0., pow(distance(uv, vec2(0.87,0.65-abs(cos(iTime*5.))/20.)),1.1))*60.; //.*cos(distance(uv, vec2(0.87,0.65))); //smoothstep(18., 20.20.;\n    //maskline *=mask.r;    \n    \n    col = vec4(1.);//maskline; //col*maskline;\n    */\n    \n    return col;\n}\n\n\n//Todor added uvBasic and the extraction of the glow from the landscape and the trees.\n//Without these modification, the landscape would glow.\nvec4 moonglowBasic(vec2 uv, float foreground) {\n    \n   \tfloat c = circ(uv, MOONPOS, .1, .2);\n    \n    vec4 col = vec4(c);\n    col.rgb *=.2;\n    \n/*    \n    // \"Mask extraction\" - could be in a function.\n    // This is a copy of a segment from mainImage,\n    // which \"redraws the landscape and the trees\n    // in order to check if the glow is under the horizon.\n    \n    float dist = .10;\n    float height = -.01;\n    float amplitude = .02;\n    \n    dist = 1.;\n    height = .55;\n    float t = iTime*.05;\n    \n    vec4 trees = vec4(0.);\n    for(float i=0.; i<10.; i++) {    \n    \tvec4 layer = landscape(uvBasic, dist, t+i, 3., amplitude, height, i, .01);\n    \tlayer.rgb *= mix(vec3(.1, .1, .2), vec3(.3)+gradient(uvBasic).x, 1.-i/10.);\n        trees.rgb = mix(trees.rgb, layer.rgb, layer.a);\n        trees. a = max(trees.a, layer.a);\n        \n        dist -= .1;\n        height -= .06;\n    }\n    //If the pixel is not hitting the trees and the landscape, it would be black.\n    //Then, add the glow. Else - ignore this component.\n    col*= trees.r < 0.0 ? 1.0 : 0.; \n*/    \n     col*= col.r == 0.0001 ? 1.0 : 0.; \n    \n    return col;\n}\n\n\nfloat stars(vec2 uv, float t) {\n    t*=3.;\n    \n    float n1 = hash12(uv*10000.);\n    float n2 = hash12(uv*11234.);\n    float alpha1 = pow(n1, 20.);\n    float alpha2 = pow(n2, 20.);\n    \n    float twinkle = sin((uv.x-t+cos(uv.y*20.+t))*10.);\n    twinkle *= cos((uv.y*.234-t*3.24+sin(uv.x*12.3+t*.243))*7.34);\n    twinkle = (twinkle + 1.)/2.;\n    \n    \n    return alpha1 * alpha2 * twinkle;\n    \n   // float c = moon(uv, MOONPOS, .1, .2);\n   // return c > 0.0 ? 0.0 : alpha1 * alpha2 * twinkle;    \n    \n}\n\n\nfloat starsMasked(vec2 uv, float t, vec2 moonUV) {\n    t*=3.;\n    \n    float n1 = hash12(uv*10000.);\n    float n2 = hash12(uv*11234.);\n    float alpha1 = pow(n1, 20.);\n    float alpha2 = pow(n2, 20.);\n    \n    float twinkle = sin((uv.x-t+cos(uv.y*20.+t))*10.);\n    twinkle *= cos((uv.y*.234-t*3.24+sin(uv.x*12.3+t*.243))*7.34);\n    twinkle = (twinkle + 1.)/2.;\n    \n    //return alpha1 * alpha2 * twinkle;\n           \n    vec4 m = moon(moonUV);\n    return m.a > 0.0 ? 0.0 : (alpha1 * alpha2 * twinkle);    //was m.r, but now has black also - 16.11\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float t = iTime*.05;\n   \n     \n    vec2 bgUV = uv*vec2(iResolution.x/iResolution.y, 1.);\n    vec2 uvBasic = uv;//bgUV; //The original value - for the glow extraction\n    vec2 guv = (fragCoord.xy - vec2(iResolution.x*0.5, 0.0)) / iResolution.y; //pyBlob's coordinates\n    \n    // Adjusting the position of the moon and its trajectory. \n    bgUV.y+=0.43;    \n    bgUV.x+=PI*sin((iTime/6.+3090.)/1.76)/5.;      //iTime/6... - slow down to Sync it with the \"Claire de Lune\" piece\n    bgUV.y+=(PI/1.12)*cos((iTime/6.+3090.)/1.76)/5.;\n    bgUV.x+=0.5;\n    \n    //vec4 col = vec4(0.); //gradient(bgUV)*.8;  //higher contrast, black\n    vec4 col = gradient(bgUV)*.8;  //higher contrast, black\n    col += moon(bgUV); //, bgUVBasic);\n    //col += moonLeakage2(bgUV, bgUVBasic); //no\n   \n   // col += stars(uv, t);\n    col += starsMasked(uv, t, bgUV);\n    \n    float dist = .10;\n    float height = -.01;\n    float amplitude = .02;\n    \n    dist = 1.;\n    height = .55;\n      \n    float horizon = 0.25;\n    float birghtness = 1.0 + horizon - bgUV.y; //BingWings's suggestion to darken when the moon is below horizon,\n                                               //however implemented with a gradual change.\n   \n    vec4 trees = vec4(0.);\n    for(float i=0.; i<10.; i++) {    \n    \tvec4 layer = landscape(uv, dist, t*slowTrees+i, 3., amplitude, height, i, .01); //1\n        //vec4 layer = landscape(uv, dist, t+i, 3., amplitude, height, i, .00); //1\n    \t       //layer.rgb *= mix(vec3(.1, .1, .2), vec3(.3)+gradient(uv).x, 1.-i/10.); //2 - black mask of the trees and landscape           \n        \n        layer.rgb *= mix(vec3(.1, .1, .2), vec3(.1)+clamp(gradient(uv).x*birghtness, 0.0, 1.5)*2., 1.-i/10.);\n        \n        //layer.rgb *= mix(vec3(.1, .1, .2), vec3(.3), 1.-i/10.);  //the leakage is not due to the gradient?\n        \n                 //trees.rgb = mix(trees.rgb, layer.rgb, layer.a);\n                 //trees.rgb = mix(trees.rgb, layer.rgb, layer.a); //3 white trees, landscape with contours        \n        trees = mix(trees, layer, layer.a); //trees.rgba  = mix(trees.rgba, layer.rgba, layer.a);\n                 // trees.a = max(trees.a, layer.a);  ////BigWIngs optimization        \n        \n        dist -= .1;\n        height -= .06;\n    }\n    \n    //if (col.r > abs(sin(iTime/5.))) //trees.a >0.5)\n    //if (col.r > 0.5 && trees.r < 0.01 && trees.a  > 0.005) col = trees;//trees.a >0.5)\n    //else\n    //col = mix(col, trees, trees.a)*(1.-trees.a); //mask\n    vec4 mask = mix(col, trees, trees.a)*(1.-trees.a);\n    col = max(mask, trees); //trees, trees.a)*(1.-trees.a);\n    \n    //col += moonglow(bgUV, 1., uvBasic)*(1.-trees.a); //*(1.-trees.a); \n    col += moonglow(bgUV, 1., uvBasic, guv)*(1.-trees.a); //*(1.-trees.a);  //+meteors\n    \n    \n    \n    //col += moonglowBasic(bgUV, 1.); //*(1.-trees.a); \n    \n    \n/* Black circle\n    vec4 maskmoon = moon(bgUV);\n    if (maskmoon.r < 0.001)\n    col = mix(col, trees, trees.a);\n    else col = trees;\n*/    \n   // col += moonglow(bgUV, 1., bgUVBasic); //Twenkid's first simple solution \n   // col += moonglowBasic(bgUVBasic, 1.)*(1.-trees.a); //BigWIngs's optimization - however the glow appears without callung glow?\n    \n    //col = moonglowLeakage(bgUV, 1., bgUVBasic);//*(1.-trees.a); //Attempts to remove white leakage\n    \n    col = saturate(col);\n    \n    \n    vec4 foreground = landscape(uv, .02, t*slowTrees, 3., .0, -0.04, 1., .1);\n    foreground.rgb *= vec3(.1, .1, .2)*.5;\n            \n    col = mix(col, foreground, foreground.a);\n    \n   \n    fragColor = vec4(col);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "musicstream",
                        "id": 23772,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/claude-debussy/clair-de-lune"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}