{
    "Shader": {
        "info": {
            "date": "1564569493",
            "description": "water in world",
            "flags": 0,
            "hasliked": 0,
            "id": "WtlSWB",
            "likes": 18,
            "name": "world sea",
            "published": 3,
            "tags": [
                "water"
            ],
            "usePreview": 0,
            "username": "owlwisp",
            "viewed": 985
        },
        "renderpass": [
            {
                "code": "//外部传入参数\n//海水深度(0~1.)\nfloat water_deep =\t0.8;\n\n//海水颜色退化比值 （0.01～1.）可以根据四季变化传入不同值来改变海水颜色，越靠近1.越黄\nfloat coast2water_fadedepth =0.8;\n\n// 调整大波浪大小的因素  数值越小则波浪越小  主要是浪间距\nfloat large_wavesize        = 2.5;  \n//调整波浪大小主要是波浪 的深浅  越小越浅\nfloat large_waveheight      = 0.40; \n//波浪里小波浪的大小\nfloat small_wavesize        =0.5;   \n//地面颜色\n vec3 ground_color =vec3(0.7, .55, .4);\n\n//平台适配代码\n#define kTime\t\t\t\t\t\t\tiTime\n#define kUv\t\t\t\t\t\t\t\tfragCoord.xy / iResolution.xy\n#define kIChannel0\t\t\t\t\tiChannel0\n#define kIChannel1\t\t\t\t\tiChannel1\n#define kIChannel2\t\t\t\t\tiChannel2\n#define kPackage(x,y)\t\t\t\t(x * y)\n\n#define kWater_level\t\t\t\tkPackage(water_deep,2.)\n#define kWater_fadedepth\t\tkPackage(coast2water_fadedepth,0.5)\n\n\n//固定参数值\n//对波浪进行分面， 面数越小 波浪越大， 面数越大消耗性能越高  最好大于7  7以下效果比较差\n#define kWaveIteration\t\t\t\t7\n\n//高亮光 和柔和光\nfloat water_softlight_fact  = 15.;  // range [1..200] (should be << smaller than glossy-fact)\nfloat water_glossylight_fact= 180.; // range [1..200]\n\n//运行的全局参数\nvec3 light;\n\nfloat small_waveheight      = .6;  // change to adjust the small random waves\n\nfloat particle_amount       = 70.;\nvec3 watercolor             = vec3(0.43, 0.60, 0.66); // 'transparent' low-water color (RGB)\nvec3 watercolor2            = vec3(0.06, 0.07, 0.11); // deep-water color (RGB, should be darker than the low-water color)\nvec3 water_specularcolor    = vec3(1.3, 1.3, 0.9);    // specular Color (RGB) of the water-highlights\n\n\n\nfloat noise(vec2 p)\n{\n  return texture(kIChannel0,p*vec2(1./256.)).x;\n}\n\n//获取高度\nfloat height_map( vec2 p )\n{\n  float f = 0.15 + texture(kIChannel2, p*0.6, 0.0).r*2.;\n  return clamp(f, 0., 10.);\n}\n\n//获取地面颜色值  并通过通道1进行颜色加强\nvec3 terrain_map( vec2 p )\n{\n   \n  \treturn ground_color+texture(kIChannel1, p*2.).rgb*.5; // test-terrain is simply 'sandstone'\n}\n\nconst mat2 m = mat2( 0.72, -1.60,  1.60,  0.72 );\n\nfloat water_map( vec2 p, float height )\n{\n  vec2 p2 = p*large_wavesize;\n  vec2 shift1 = 0.001*vec2( kTime*160.0*2.0, kTime*120.0*2.0 );\n  vec2 shift2 = 0.001*vec2( kTime*190.0*2.0, -kTime*130.0*2.0 );\n\n  // coarse crossing 'ocean' waves...\n  float f = 0.6*noise( p );\n\t\n    f += 0.2500*noise(  p *m );\n    f += 0.1666*noise( p*m*m );\n  float wave = sin(p2.x*0.622+p2.y*0.622+shift2.x*4.269)*large_waveheight*f*height*height ;\n\n  p *= small_wavesize;\n  f = 0.;\n  float amp = 1.0, s = .5;\n   //对波浪进行分面  \n  for (int i=0; i<kWaveIteration; i++)\n  { \n      p = m*p*.947; f -= amp*abs(sin((noise( p+shift1*s )-.5)*2.)); amp = amp*.59; s*=-1.329;\n  }\n \n  return wave+f*small_waveheight;\n}\n\n\n\nfloat test_shadow( vec2 xy, float height)\n{\n    vec3 r0 = vec3(xy, height);\n    vec3 rd = normalize( light - r0 );\n    \n    float hit = 1.0;\n    float t   = 0.001;\n    for (int j=1; j<5; j++)\n    {\n        vec3 p = r0 + t*rd;\n        float h = height_map( p.xy );\n        float height_diff = p.z - h;\n        if (height_diff<0.0)\n        {\n            return 0.0;\n        }\n        t += 0.01+height_diff*.02;\n        hit = min(hit, 2.*height_diff/t); // soft shaddow   \n    }\n    return hit;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col;\n    //模拟光照， 太阳的位置  x, y 为太阳位置 z 为高度\n    light = vec3(0.5, 0.4,3.5); \n     \n    //vec3(-0., sin(iTime*0.5)*.5 + .35, 2.8); \n\tvec2 uv = kUv;\n\t//海水和陆地显示的比例\n\tfloat deepwater_fadedepth   = .5 + kWater_fadedepth;\n    //限制传入数据water_deep 为0～1. 否则这里需要做clam 操作\n    float waveheight = kWater_level;\n\n    \n    float height = height_map( uv );\n    \n\n\tfloat level = 10.;\n    vec2 dif = vec2(.0, .01);\n    vec2 pos = uv*15. + vec2(kTime*.01);\n    float h1 = water_map(pos-dif,waveheight);\n    float h2 = water_map(pos+dif,waveheight);\n    float h3 = water_map(pos-dif.yx,waveheight);\n    float h4 = water_map(pos+dif.yx,waveheight);\n    vec3 normwater = normalize(vec3(h3-h4, h1-h2, .125)); // norm-vector of the 'bumpy' water-plane\n\n\n    float coastfade = clamp((level-height)/kWater_fadedepth, 0., 1.);\n    float coastfade2= clamp((level-height)/deepwater_fadedepth, 0., 1.);\n    float intensity = col.r*.2126+col.g*.7152+col.b*.0722;\n    watercolor = mix(watercolor*intensity, watercolor2, smoothstep(0., 1., coastfade2));\n\n    vec3 r0 = vec3(uv, kWater_level);\n    vec3 rd = normalize( light - r0 ); // ray-direction to the light from water-position\n    float grad     = dot(normwater, rd); // dot-product of norm-vector and light-direction\n    float specular = pow(grad, water_softlight_fact);  // used for soft highlights                          \n    float specular2= pow(grad, water_glossylight_fact); // used for glossy highlights\n    float gradpos  = dot(vec3(0., 0., 1.), rd);\n    float specular1= smoothstep(0., 1., pow(gradpos, 5.));  // used for diffusity (some darker corona around light's specular reflections...)                          \n    float watershade  = test_shadow( uv, level );\n\n    watercolor *= 2.2+watershade;\n    watercolor += (.2+.8*watershade) * (.5+specular) * .05;\n    watercolor /= (1.+specular1*.15);\n    watercolor += watershade*specular2*water_specularcolor * 0.41;\n\n    watercolor += watershade*coastfade*(1.-coastfade2)*(vec3(.5, .6, .7));\n\n    col = mix(col, watercolor, coastfade);\n\n\tfragColor = vec4(col , 1.0);\n}\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}