{
    "Shader": {
        "info": {
            "date": "1483637381",
            "description": "Quadratic Julia sets rendered with a buffer feedback technique equivalent to reverse iteration. Nothing too special, and I'm pretty sure I've seen it done before. The real reason I made this was to play around with rational powers - see my other shader.",
            "flags": 32,
            "hasliked": 0,
            "id": "MtKXRw",
            "likes": 5,
            "name": "Julia set - reverse iteration",
            "published": 3,
            "tags": [
                "fractal",
                "julia"
            ],
            "usePreview": 0,
            "username": "kev7774",
            "viewed": 783
        },
        "renderpass": [
            {
                "code": "/********\nSee Buf A shader for parameters.\n********/\n\nfloat zoom = 0.0; // Zoom in on the result - 0 is no zoom, 1 is 2x zoom, 2 is 4x, etc. Zooming blurs the result.\n \n\n\n   \n\n\nvec3 hsv2rgb(vec3);\n\nvec2 coord;\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 c = fragCoord / iResolution.xy;\n    c = (c-vec2(.5))*2.;\n\tvec2 pos = (c / exp2(zoom)+vec2(1.0))/2.0;\n\tvec4 tex = texture(iChannel0, pos);\n\tvec3 col = tex.xyz;\n\tfragColor = vec4(col,1.0);\n\n}\n\n\n\n\nvec3 hsv2rgb(vec3 hsv)\n{\n    float h, s, v, r, g, b, j, p, q, t;\n    int i;\n    vec3 color;\n    \n    h = hsv.x;\n    s = hsv.y;\n    v = hsv.z;\n    \n    if (h == 1.0) {\n        h = 0.0;\n    }\n    \n    if (v == 0.0) {\n        // No brightness so return black\n        color = vec3(0.0);\n        \n    } else if (s == 0.0) {\n        // No saturation so return grey\n        color = vec3(v);\n        \n    } else {\n        // RGB color\n        h *= 6.0;\n        i = int(floor(h));\n        j = h - float(i);\n        p = v * (1.0 - s);\n        q = v * (1.0 - (s * j));\n        t = v * (1.0 - (s * (1.0 - j)));\n        \n        if (i == 0) {\n            r = v;\n            g = t;\n            b = p;\n        } else if (i == 1) {\n            r = q;\n            g = v;\n            b = p;\n        } else if (i == 2) {\n            r = p;\n            g = v;\n            b = t;\n        } else if (i == 3) {\n            r = p;\n            g = q;\n            b = v;\n        } else if (i == 4) {\n            r = t;\n            g = p;\n            b = v;\n        } else if (i == 5) {\n            r = v;\n            g = p;\n            b = q;\n        }\n        color = vec3(r, g, b);\n    }\n    \n    return color;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//If you see flickering or other instability, turn down sharpness.\n\n    bool soft = false; //Softens result by only darkening towards the center of image (avoids sharp cutoff at image edge)\n    float lightness = .98; //Factor to multiply image by after each iteration\n    float sharpness = .25; //Sharpening factor for resampling - improves detail\n  \n\tfloat SCALE = 1.3;\n\n\n\n\n bool multiply = false; // Multiply image samples together - darker image. Default setting averages samples instead.\n    bool quintic = true; // If true power = 5/2, if false power = 3/2\n    int iters = 15; // Number of iterations. \nvec2 complexMul(vec2 a, vec2 b) {\n\treturn vec2( a.x*b.x -  a.y*b.y,a.x*b.y + a.y * b.x);\n}\n\nvec2 complexSqrt(vec2 z){\n\tfloat r = length(z);\n \treturn sqrt(r) * (z+vec2(r,0.)) / length(z+vec2(r,0.));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec2 C;\n    \n    if(iMouse.z > 0.0) C = ((iMouse.xy / iResolution.xy) - 0.5) * 4.0;\n    \telse C =  vec2(-0.72728, -0.27272);\n    \n    vec2 pixelSize = vec2(1.) / iResolution.xy;\n    \n\tvec2 pos = fragCoord.xy/iResolution.xy;\n\tpos.x =( (pos.x*2.-1.)  * (pixelSize.y/pixelSize.x))*.5+.5;\n    vec2 initpos = pos;\n\tvec2 z  = pos*SCALE*2.0- vec2(SCALE);\n    if(iFrame < 2){\n        fragColor = vec4( vec3(min(1., length(pos*4.-2.))), 1.0   );\n        return ;\n    }\n\tvec2 z2 = complexMul(z,z);\n\tz = z2;\n\tvec3 final = multiply ? vec3(1.) : vec3(0.);\n    \n\t{\n        vec2 newz = z +C;\n        pos = (newz+vec2(SCALE))/SCALE/2.;\n        pos.x = ((pos.x*2.-1.) * (pixelSize.x/pixelSize.y))*.5+.5;\n        if (pos.x < 0. || pos.y < 0. || pos.x > 1. || pos.y > 1.){\n            fragColor = vec4(1.);\n            return;\n        }\n        vec3 sam = texture(iChannel0,pos).xyz;\n        vec3 n = texture( iChannel0,pos+pixelSize*vec2(0.,1.)).xyz;\n        vec3 e = texture( iChannel0,pos+pixelSize*vec2(1.,0.)).xyz;\n        vec3 s = texture( iChannel0,pos+pixelSize*vec2(0.,-1.)).xyz;\n        vec3 w = texture( iChannel0,pos+pixelSize*vec2(-1.,0.)).xyz;\n        if(multiply) {\n            final *= sam * (1.+sharpness) - sharpness * .25 * (n+e+s+w);\n        }else{\n            final += sam * (1.+sharpness) - sharpness * .25 * (n+e+s+w);\n        }\n\t}\n\t\n\t\n\t\n    fragColor.a = 1.0;\n\tfragColor.xyz = \n\t\tmultiply ?\n\t\t\t final  * ( soft ? mix( lightness,max(1.,lightness), min(1., length((initpos*SCALE*2.-SCALE)))) : 1.* lightness)\n\t\t:\n\t\t\t final  * ( soft ? mix(1.*lightness,1., min(1., length((initpos*SCALE*2.-SCALE)))) : 1.* lightness);\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}