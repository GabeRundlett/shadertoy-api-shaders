{
    "Shader": {
        "info": {
            "date": "1475947859",
            "description": "Part 08: Basic chiptuning\nIntro to democoding using ShaderToy\nBy cxw/Incline - Demosplash 2016\nMusic: Moon theme from DuckTales, by Hiroshige Tonomura.  Transcribed by Manuel Gutierrez Rojas.",
            "flags": 8,
            "hasliked": 0,
            "id": "MtKGR3",
            "likes": 5,
            "name": "demosplash2016-cxw-08",
            "published": 3,
            "tags": [
                "tutorial",
                "chiptune",
                "demoparty"
            ],
            "usePreview": 0,
            "username": "cxw",
            "viewed": 688
        },
        "renderpass": [
            {
                "code": "//08-gfx.frag: Visuals\nprecision highp int;precision highp float;\n\n// Parameters for your demo.  These should match 08-msx!!\n\n// Song parameters\n#define BPS (1.8333333333333333333333333333333)//(1.5)\n    // beats per sec = BPM/60 (110 bpm) (90 bpm)\n#define SPB (0.54545454545454545454545454545455)//(0.66666666666666666666666666666667)\n    // sec per beat, precomputed\n#define BPP (128.0)\n    // beats per pattern\n\n#define FLASH_DURATION_BPCT (0.25)\n    // How long the flash is, in percentage of a beat\n#define FLASH_SKEW_BPCT (0.25)\n    // Where in the beat the flash happens.  Tweak to sync.\n    // NOTE: Use Firefox rather than Chrome --- sync seems iffy on Chrome.\n\n#define MUSIC_START_TIME (1.0)\n    // how long to wait before starting the music\n\n// Computed parameters //////////////////////////////////////////////////\n#define PATTERN_DURATION_SEC (SPB * BPP)\n    // = SPP = S/B * B/P\n\n// Routines /////////////////////////////////////////////////////////////\n\nvec3 hsv2rgb(vec3 c) {\n    // All inputs range from 0 to 1.  By hughsk, from\n    // https://github.com/hughsk/glsl-hsv2rgb/blob/master/index.glsl .\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n} //hsv2rgb\n\n// mainImage() //////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixel_coord_01 = fragCoord.xy / iResolution.xy;\n\n    float music_t = iTime-MUSIC_START_TIME;\n    float sat;\n    if(music_t < 0.0) {     // Fade in from white while waiting\n        sat = smoothstep(-MUSIC_START_TIME, 0.0, music_t);\n\n    } else {                // Sync to the music\n        music_t = mod(music_t, PATTERN_DURATION_SEC); //within one pattern\n\n        float beat_in_pattern = mod(music_t*BPS, BPP);\n            // including fraction\n        float time_in_beat = mod(music_t, SPB);\n\n        float is_even_beat = step(1.0, mod(beat_in_pattern, 2.0));\n            // Flash on beats 2 and 4 of each measure.\n\n        float sat_in_beat = (1.0 - step(FLASH_SKEW_BPCT, time_in_beat));\n            // full saturation before FLASH_SKEW_BPCT\n        sat_in_beat +=\n            smoothstep(FLASH_SKEW_BPCT, FLASH_DURATION_BPCT + FLASH_SKEW_BPCT,\n                        time_in_beat);\n            // Sat drops to 0 at FLASH_SKEW_BPCT, then recovers over\n            // FLASH_DURATION_BPCT.\n\n        sat = mix(1.0, sat_in_beat, is_even_beat);\n            // Full sat (1.0) if it's not an even beat; computed sat if it is.\n            //TODO full sat for the first second\n    } //endif music_t<0.0 else\n\n    fragColor = vec4(     // A nice color stripe pattern\n        hsv2rgb(vec3(pixel_coord_01.x+pixel_coord_01.y+music_t, sat, 1.0)),\n        1.0);                                        //         ^^^\n} //mainImage\n\n// vi: set ts=4 sts=4 sw=4 et ai: //\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//08-msx.frag: Music\nprecision highp int;precision highp float;\n\n// Parameters for your demo.  These should match 08-gfx!!\n\n// Song parameters\n#define BPS (1.8333333333333333333333333333333)//(1.5)\n    // beats per sec = BPM/60 (110 bpm) (90 bpm)\n#define SPB (0.54545454545454545454545454545455)//(0.66666666666666666666666666666667)\n    // sec per beat, precomputed\n#define BPP (128.0)\n    // beats per pattern\n\n#define MUSIC_START_TIME (1.0)\n    // how long to wait before starting the music\n\n// Computed parameters //////////////////////////////////////////////////\n#define PATTERN_DURATION_SEC (SPB * BPP)\n    // = SPP = S/B * B/P\n\n// Constants ////////////////////////////////////////////////////////////\n#define PI (3.1415926535897932384626433832795028841971)\n    // from memory :)\n#define TWO_PI (6.283185307179586)\n#define ONE_OVER_TWO_PI (0.15915494309644431437107064141535)\n    // not from memory :) :)\n#define HALF_PI (1.5707963267948966192313216916398)\n#define ONE_OVER_HALF_PI (0.63661977236758134307553505349006)\n\n// Kick drum ////////////////////////////////////////////////////////////\n\n#define KICK_ATTACK (0.008)  //ms\n#define KICK_DSR (0.1)     //decay, sustain, release\n\nfloat do_kick(in float beat_in_pattern, in float time_in_beat)\n{\n    float local_time;   // time since note-on\n\n    float is_even_beat = step(1.0, mod(beat_in_pattern, 2.0));\n    local_time = mix(0.0, time_in_beat, is_even_beat);\n        // time stuck at 0 during odd beats (*B*); runs during beats 2 and 4\n        // of each measure.\n\n    float kick_envelope = smoothstep(0.0,KICK_ATTACK,local_time);   //attack\n    kick_envelope *= (1.0-smoothstep(KICK_ATTACK,KICK_ATTACK+KICK_DSR, //DSR\n                                            local_time));\n\n    float kick_sample = sin(80.0*TWO_PI*local_time);    // The basic waveform\n        // Using sin() => t=0 means no sound. (*B*)\n    kick_sample *= kick_envelope;                       // Apply the envelope\n\n    return kick_sample;\n} //do_kick\n\n// Melody (square?) /////////////////////////////////////////////////////\n\n#define MELODY_RAMP_TIME_SEC (0.05)\n    // Attack/release time\n\n// BEGIN material from gen-music.py\n// --- VVV cutbegin ---\n// Tuning\n#define F_REST (0.0)\n    // for consistency\n#define P_REST (0.0)\n#define F_C4 (277.180)\n#define P_C4 (0.00360776390792986491)\n#define F_D4 (311.130)\n#define P_D4 (0.00321409057307234930)\n#define F_E4 (349.230)\n#define P_E4 (0.00286344243048993483)\n#define F_F4 (369.990)\n#define P_F4 (0.00270277575069596473)\n#define F_G4 (415.300)\n#define P_G4 (0.00240789790512882258)\n#define F_A4 (466.160)\n#define P_A4 (0.00214518620216234751)\n#define F_B4 (493.880)\n#define P_B4 (0.00202478334818174477)\n#define F_C5 (554.370)\n#define P_C5 (0.00180384941465086502)\n#define F_D5 (622.250)\n#define P_D5 (0.00160707111289674562)\n#define F_E5 (698.460)\n#define P_E5 (0.00143172121524496741)\n#define F_F5 (739.990)\n#define P_F5 (0.00135136961310287971)\n#define F_G5 (830.610)\n#define P_G5 (0.00120393445780811697)\n#define F_A5 (932.330)\n#define P_A5 (0.00107258159664496474)\n#define F_B5 (987.770)\n#define P_B5 (0.00101238142482561731)\n#define F_C6 (1108.730)\n#define P_C6 (0.00090193284208057870)\n#define F_D6 (1244.510)\n#define P_D6 (0.00080352909980634948)\n\n// Score\nvec4 get_song_data(in float beat_in_pattern)\n{\n    //DuckTales Moon theme.\n    //Music by Hiroshige Tonomura.  Transcribed by Manuel Gutierrez Rojas.\n    //tweaked by cxw.\n    vec4 retval; //(frequency, period (1/freq), startbeat, endbeat)\n        // frequency < 1.0 => no sound\n    retval = vec4(0.0);     // by default, no sound\n    retval = mix(retval, vec4(F_REST, P_REST, 0.000, 2.000), step(0.000, beat_in_pattern));\n    retval = mix(retval, vec4(F_A4, P_A4, 2.000, 2.500), step(2.000, beat_in_pattern));\n    retval = mix(retval, vec4(F_B4, P_B4, 2.500, 3.000), step(2.500, beat_in_pattern));\n    retval = mix(retval, vec4(F_C5, P_C5, 3.000, 4.000), step(3.000, beat_in_pattern));\n    retval = mix(retval, vec4(F_C5, P_C5, 4.000, 5.000), step(4.000, beat_in_pattern));\n    retval = mix(retval, vec4(F_F5, P_F5, 5.000, 6.000), step(5.000, beat_in_pattern));\n    retval = mix(retval, vec4(F_E5, P_E5, 6.000, 7.000), step(6.000, beat_in_pattern));\n    retval = mix(retval, vec4(F_F5, P_F5, 7.000, 8.000), step(7.000, beat_in_pattern));\n    retval = mix(retval, vec4(F_G5, P_G5, 8.000, 9.000), step(8.000, beat_in_pattern));\n    retval = mix(retval, vec4(F_A5, P_A5, 9.000, 9.500), step(9.000, beat_in_pattern));\n    retval = mix(retval, vec4(F_F5, P_F5, 9.500, 15.000), step(9.500, beat_in_pattern));\n    retval = mix(retval, vec4(F_E5, P_E5, 15.000, 15.500), step(15.000, beat_in_pattern));\n    retval = mix(retval, vec4(F_F5, P_F5, 15.500, 16.000), step(15.500, beat_in_pattern));\n    retval = mix(retval, vec4(F_C6, P_C6, 16.000, 17.500), step(16.000, beat_in_pattern));\n    retval = mix(retval, vec4(F_F5, P_F5, 17.500, 18.000), step(17.500, beat_in_pattern));\n    retval = mix(retval, vec4(F_F5, P_F5, 18.000, 23.000), step(18.000, beat_in_pattern));\n    retval = mix(retval, vec4(F_C5, P_C5, 23.000, 23.500), step(23.000, beat_in_pattern));\n    retval = mix(retval, vec4(F_F5, P_F5, 23.500, 24.000), step(23.500, beat_in_pattern));\n    retval = mix(retval, vec4(F_F5, P_F5, 24.000, 26.000), step(24.000, beat_in_pattern));\n    retval = mix(retval, vec4(F_REST, P_REST, 26.000, 26.500), step(26.000, beat_in_pattern));\n    retval = mix(retval, vec4(F_G5, P_G5, 26.500, 27.000), step(26.500, beat_in_pattern));\n    retval = mix(retval, vec4(F_F5, P_F5, 27.000, 27.500), step(27.000, beat_in_pattern));\n    retval = mix(retval, vec4(F_E5, P_E5, 27.500, 32.000), step(27.500, beat_in_pattern));\n    retval = mix(retval, vec4(F_A4, P_A4, 32.000, 34.000), step(32.000, beat_in_pattern));\n    retval = mix(retval, vec4(F_REST, P_REST, 34.000, 34.500), step(34.000, beat_in_pattern));\n    retval = mix(retval, vec4(F_G4, P_G4, 34.500, 35.000), step(34.500, beat_in_pattern));\n    retval = mix(retval, vec4(F_F4, P_F4, 35.000, 35.500), step(35.000, beat_in_pattern));\n    retval = mix(retval, vec4(F_C5, P_C5, 35.500, 37.000), step(35.500, beat_in_pattern));\n    retval = mix(retval, vec4(F_REST, P_REST, 37.000, 38.000), step(37.000, beat_in_pattern));\n    retval = mix(retval, vec4(F_F5, P_F5, 38.000, 39.000), step(38.000, beat_in_pattern));\n    retval = mix(retval, vec4(F_G5, P_G5, 39.000, 40.000), step(39.000, beat_in_pattern));\n    retval = mix(retval, vec4(F_B5, P_B5, 40.000, 41.500), step(40.000, beat_in_pattern));\n    retval = mix(retval, vec4(F_A5, P_A5, 41.500, 42.000), step(41.500, beat_in_pattern));\n    retval = mix(retval, vec4(F_A5, P_A5, 42.000, 46.000), step(42.000, beat_in_pattern));\n    retval = mix(retval, vec4(F_C6, P_C6, 46.000, 47.000), step(46.000, beat_in_pattern));\n    retval = mix(retval, vec4(F_B5, P_B5, 47.000, 48.000), step(47.000, beat_in_pattern));\n    retval = mix(retval, vec4(F_A5, P_A5, 48.000, 48.500), step(48.000, beat_in_pattern));\n    retval = mix(retval, vec4(F_B5, P_B5, 48.500, 49.000), step(48.500, beat_in_pattern));\n    retval = mix(retval, vec4(F_A5, P_A5, 49.000, 49.500), step(49.000, beat_in_pattern));\n    retval = mix(retval, vec4(F_F5, P_F5, 49.500, 50.500), step(49.500, beat_in_pattern));\n    retval = mix(retval, vec4(F_C5, P_C5, 50.500, 52.500), step(50.500, beat_in_pattern));\n    retval = mix(retval, vec4(F_G5, P_G5, 52.500, 53.000), step(52.500, beat_in_pattern));\n    retval = mix(retval, vec4(F_F5, P_F5, 53.000, 53.500), step(53.000, beat_in_pattern));\n    retval = mix(retval, vec4(F_E5, P_E5, 53.500, 54.000), step(53.500, beat_in_pattern));\n    retval = mix(retval, vec4(F_D5, P_D5, 54.000, 54.500), step(54.000, beat_in_pattern));\n    retval = mix(retval, vec4(F_E5, P_E5, 54.500, 55.000), step(54.500, beat_in_pattern));\n    retval = mix(retval, vec4(F_C5, P_C5, 55.000, 55.500), step(55.000, beat_in_pattern));\n    retval = mix(retval, vec4(F_REST, P_REST, 55.500, 56.000), step(55.500, beat_in_pattern));\n    retval = mix(retval, vec4(F_F5, P_F5, 56.000, 57.300), step(56.000, beat_in_pattern));\n    retval = mix(retval, vec4(F_F5, P_F5, 57.300, 58.600), step(57.300, beat_in_pattern));\n    retval = mix(retval, vec4(F_F5, P_F5, 58.600, 59.600), step(58.600, beat_in_pattern));\n    retval = mix(retval, vec4(F_REST, P_REST, 59.600, 59.600), step(59.600, beat_in_pattern));\n    return retval;\n}\n// --- ^^^ cutend ---\n// END   material from gen-music.py\n\nfloat do_tri(in float time, in float freq_hz, in float period_sec)\n{ // additively synthesize something vaguely like an NES triangle\n    float phase_rad = mod(time, period_sec) * TWO_PI * freq_hz;\n    float phase_within_quadrant = mod(phase_rad, HALF_PI);\n    float phase_at_quadrant_start = phase_rad - phase_within_quadrant;\n    float ramp_start = sin(phase_at_quadrant_start);\n    float ramp_end = sin(phase_at_quadrant_start + HALF_PI);\n\n    float pct = phase_within_quadrant * ONE_OVER_HALF_PI;\n    float retval = mix(ramp_start, ramp_end, pct);\n\n    retval += 0.2*cos(TWO_PI * freq_hz * time);             // sag/rise\n    //retval += 0.05*sin(32.0 * TWO_PI * freq_hz * time);   // steps\n        // Sounds less harsh on my machine without this.\n\n    retval *= 0.9;      //leave a bit of room\n    retval += 0.006;    //DC balance (sort of)\n\n    return retval;\n} //do_tri\n\nfloat do_melody(in float beat_in_pattern, in float time)\n{ //time is the global time\n\n    // Get the current note (which may be a rest)\n    vec4 note = get_song_data(beat_in_pattern);\n\n    // Unpack the note\n    float freq_hz = note[0];\n    if(freq_hz<1.0) return 0.0;     //early bail on rests\n\n    float period_sec = note[1];\n    float start_beat = note[2]; // should be <= beat_in_pattern\n    float end_beat = note[3];   // note covers [start_beat, end_beat)\n    float time_in_note = max(0.0, time - (start_beat * SPB));\n        // Note: \"max: no overloaded function found\" means you used\n        // integer 0 instead of float 0.0\n\n    //Make the sound\n    float wave = do_tri(time, freq_hz, period_sec);\n\n    // Envelope - smooth transition at beginning and end of note.\n\n    //attack\n    float envelope = smoothstep(0.0, MELODY_RAMP_TIME_SEC, time_in_note);\n\n    // release\n    float end_time = end_beat * SPB;\n    envelope *= (1.0 - smoothstep(end_time - MELODY_RAMP_TIME_SEC,\n                                    end_time, time_in_note));\n\n    return wave * envelope;\n} //do_melody\n\n// mainSound( in int samp,) //////////////////////////////////////////////////////////\n\nvec2 mainSound( in int samp, float time )\n{\n    float t = time;\n    if(t < MUSIC_START_TIME) { return vec2(0.0); }\n    t -= MUSIC_START_TIME;\n        //because I had better luck not starting right at t=0.\n    float music_t = mod(t, PATTERN_DURATION_SEC); //within one pattern\n\n    float beat_in_pattern = mod(music_t*BPS, BPP);\n\n    float time_in_beat = mod(music_t, SPB);\n    float kick = do_kick(beat_in_pattern, time_in_beat);    //mono\n\n    float melody = do_melody(beat_in_pattern, music_t);     //mono\n\n    return vec2(kick, 0.5*melody);        //make it stereo.\n\n} //mainSound\n\n// vi: set ts=4 sts=4 sw=4 et ai: //\n\n",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 38
                    }
                ],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}