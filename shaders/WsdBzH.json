{
    "Shader": {
        "info": {
            "date": "1604370129",
            "description": "parents:\n-[url=https://www.shadertoy.com/view/llKyWc]fourier transform canvas[/url]\n-[url=https://www.shadertoy.com/view/Ws3BzH]Costas Arrays to weighted noise[/url] \nCostas Array noise has VERY unique derivatives, and no near-0-frequency.",
            "flags": 32,
            "hasliked": 0,
            "id": "WsdBzH",
            "likes": 6,
            "name": "Costas6 fouriering",
            "published": 3,
            "tags": [
                "noise",
                "fft",
                "fft",
                "gradient",
                "dither",
                "derivative",
                "fourier",
                "distribution",
                "dft",
                "laplachian",
                "costasarray",
                "patternfree",
                "uniquederivative"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 502
        },
        "renderpass": [
            {
                "code": "\n\n\n\n/*\n\n\n\nvoid mainImage(out vec4 O, vec2 u\n){//O=getCostasOfFloat(u);\n ;//u*=4.\n ;u/=1.5\n ;float g=(sqrt(5.)*.5+.5)\n ;float speed=.00003*iTime\n ;vec2 s= (vec2(cos(speed),sin(speed*g))*.5+.5)*10000000. \n     //i am pleased that this noise still has a strong pattern to make scrolling easily noticable.\n     //thile its color palette cycles.\n ;ivec2 scroll=ivec2(s);\n ;//u.x+=u.y*(sqrt(5.)*.5+.5) //optionally skew diagonal banding by goldenRatio (sucks)\n ;//u.x+=u.y*u.y*g\n ;O=CostasNoise(ivec2(u)+scroll,iFrame);\n }\n/**/\n\n\n//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n//The noise/signal type can be changed in the Common tab\n//and the code for the signal generation is in Buffer A\n\n/*\n\tTools to help design 2D functions. Here used for noise design, but can be \n\tused for SDFs, Hashes, Image filters or any function that takes 2D input.\n\n\tThe display is as follow:\n\t\tTop left: Averaged distribution of the signal in the [0..1] range with\n\t\t\t\t  reference bars at 1/4, 1/2 and 3/4\n\n\t\tBottom left: Preview of the signal itself, coordinates are slowly moving by\n\t\t\t\t\t default, can be turned off in the Common tab\n\n\t\tTop right: First and second derivatives of a slice of the signal, to see\n\t\t\t\t   at a glance the continuity of the signal, uses horizontal (X aligned)\n\t\t\t\t   slices by default, can be switched to diagonal slices in the common tab\n\n\t\tBottom right: 2D discrete fourier transform of the input, useful to see the\n\t\t\t\t\t  signal's frequency distribution and potential anisotropy\n\n\n\t\tTo increase the size/resolution of the DFT, increase the globalSize to shrink the \n\t\tfeature size to help get a better picture over the signal's main frequqncy range\n\n\n\t\tAn interesting note regarding the noise distributions: For noises/signals with\n\t\ttoo narrow a distribution a simple smoothstep (or a more complex filter) can\n\t\tbe used as a primitive form of \"gain compression\" to flatten the distribution.\n\t\tEspecially useful when building FBM noise from narrow distributed noises \n\t\t(such as gradient noise) so that the end result isn't in a very short value range.\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n#ifdef SHOW_FOURIER\n    if (q.x > 0.5)\n    {\n        vec2 dft = textureLod(iChannel1, q-vec2(0.5,0.0), 0.).xy;\n        float amp = length(dft) / SIZE; \n        col = vec3(amp);\n    }\t\n    else\n#endif\n    {\n        col = textureLod(iChannel0, q, 0.).rgb;\n        //col = length(col)*vec3(0.577);\n    }\n    \n    //Distribution plot\n    float tot = 0.;\n    if (fragCoord.y> SIZE && fragCoord.x < SIZE)\n    {\n        const float bands = 60.;\n        float bt = floor(fragCoord.x*bands/SIZE);\n        float pt = (floor((fragCoord.x)*bands/SIZE)+0.5)/bands;\n        const float width = 6.;\n        for (float j = 0.; j<=width; j++)\n        for (float i = 0.; i<SIZE; i++)\n        {\n            float v = texelFetch(iChannel0, ivec2(bt+j, i + 0.5), 0).x;\n            if (abs(v-pt) < .5/bands)\n            \ttot += 1.;\n        }\n        tot /= SIZE*width;\n        col.rgb = vec3(smoothstep(0.00,1.,tot*SIZE-fragCoord.y + SIZE + 1.))*vec3(.4,.4,.5);\n        col.rgb += vec3(smoothstep(1.,0.,abs(tot*SIZE-fragCoord.y + SIZE + 0.5)))*vec3(.8,.8,.8);\n        if(fragCoord.y < (SIZE+50.))\n        {\n        \tcol.rgb = max(col.rgb, vec3(0.9,0.6,0.1)*vec3(smoothstep(1.4,0.,abs(fragCoord.x - SIZE/2.))));\n        \tcol.rgb = max(col.rgb, vec3(0.55,0.5,0.4)*vec3(smoothstep(1.4,0.,abs(abs(fragCoord.x - SIZE/2.)-SIZE/4.))));\n        }\n    }\n    \n    //First and second derivatives plot\n    if (fragCoord.y> SIZE && fragCoord.x > SIZE)\n    {\n        col = vec3(1);\n#ifndef DIAGONAL_DERIVATIVES \n        //Horizontal derivatives\n        float t0 = texelFetch(iChannel0, ivec2(fragCoord.x - SIZE, SIZE),0).x;\n        float t1 = texelFetch(iChannel0, ivec2(fragCoord.x-1. - SIZE, SIZE),0).x;\n        float t2 = texelFetch(iChannel0, ivec2(fragCoord.x+1. - SIZE, SIZE),0).x;\n#else\n        //Diagonal derivative\n        float t0 = texelFetch(iChannel0, ivec2(fragCoord.x - SIZE, SIZE+1.),0).x;\n        float t1 = texelFetch(iChannel0, ivec2(fragCoord.x-1. - SIZE, SIZE),0).x;\n        float t2 = texelFetch(iChannel0, ivec2(fragCoord.x+1. - SIZE, SIZE+2.),0).x;\n#endif\n        float dr = (t0 - t1)*iResolution.x*0.00025/globalScale;\n        float dr2 = (t1 + t2 - t0*2.)*iResolution.x*0.001/globalScale;\n    \n        col.rgb = smoothstep(1.5,.0, abs(dr*SIZE-fragCoord.y + SIZE + 35.))*vec3(1.0,0.7,0.3);\n        col.rgb += smoothstep(1.5,.0, abs(dr2*SIZE-fragCoord.y + SIZE + 10.))*vec3(0.5,0.7,1);\n    \n    }\n    \n    col *= smoothstep(0.,1.7,abs(fragCoord.y-SIZE+1.));\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\nselection of some costasArrays\npersonally i only care for diagonal-mirror-SYMMETRICAL costasArrays, because these compress a lot better.\n\nall* symmetrical costas arrays of order 3 are:\nint[3](1,3,2);\nall* symmetrical costas arrays of order 5 are: (all length 5 ones are banding, one hjust hides it thebest)\n//;int c[]=int[5](3,5,1,4,2);//LEAST NOTICEABLE diagonal banding (also in reverse)    \n//int c[]=int[5](5,2,4,3,1);//diagonal banding (also in reverse)   \nall* symmetrical costas arrays of order 7 are:\n//;int c[]=int[7](3,7,1,4,6,5,2);//diagonal great (reversed to kill banding)\n//;int c[]=int[7](1,2,7,4,6,5,3);//diagonal meh mixer   \n//;int c[]=int[7](1,7,3,4,6,5,2);//diagonal bad zigzag\n//;int c[]=int[7](2,1,6,4,7,3,5);//diagonal good (minor band)  \n//;int c[]=int[7](3,6,1,7,5,2,4);//diagomnal great (minor band)\n//;int c[]=int[7](2,1,5,7,3,6,4);//diagonal meh (minor band)\n//;int c[]=int[7](1,2,7,5,4,6,3);//diagonal bad onedirectional  \n//;int c[]=int[7](4,7,3,1,6,5,2);//diagonal minor band  (reversed to kill banding)\n//;int c[]=int[7](5,7,4,3,1,6,2);//2,6,1,3,4,7,5);//diagonal bad (even after reversing)\n//;int c[]=int[7](5,3,7,4,6,2,1);//1,2,6,4,7,3,5);//diagonal horrible band (even after reversing)\nall!! symmetrical costas arrays of order 11 are:\n//;int c[]=int[11](1,10,4,3,8,11,9,5,7,2,6);//diagonal great    \n//;int c[]=int[11](1,7,11,6,8,4,2,5,10,9,3);//diagonal great rainy\n//;int c[]=int[11](3,10,1,9,6,5,7,11,4,2,8);//diagonal good (jitters)\n//;int c[]=int[11](1,6,8,9,4,10,3,7,5,2,11);//diagonal bad\n//;int c[]=int[11](1,7,5,8,10,4,9,6,2,3,11);//diagonal horrible band\n\n//all symmetrical costas arrays of size 13 are:\n//;int c[]=int[13](1,10,3,9,6,5,7,12,4,2,13,8,11);//diagonal good\n    \n//all symmetrical costas arrays of size 17 are:     \n;int c[]=int[17](2,1,15,7,5,11,4,16,13,17,6,14,9,12,3,8,10);//diagonal great\n//;int c[]=int[17](1,7,15,11,8,10,2,5,17,6,4,13,12,16,3,14,9);//diagonal good rain\n//;int c[]=int[17](1,12,14,15,6,16,11,4,7,3,9,13,2,10,8,5,17);//diagonal bad\n//;int c[]=int[17](1,11,15,7,12,13,16,6,3,5,14,10,8,2,9,4,17);//diagonal horrible band\n//;int c[]=int[17](2,6,3,13,14,1,9,5,11,4,7,16,10,8,15,17,12);//diagonal horrible band\n\n//0 symmetrical costas arrays of size 19, only 2 in total\n//;int c[]=int[19](1,12,16,18,19,10,15,8,14,17,9,5,3,2,11,6,13,7,4);//meh\n//;int c[]=int[19](1,13,12,18,11,15,17,7,10,5,14,19,16,8,6,2,9,3,4);//bad\n\n//all!! symmetrical costas arrays of size 23 are:\n//;int c[]=int[23](1,15,10,4,5,12,21,23,11,3,9,6,14,13,2,19,22,18,16,20,7,17,8);//diagonal meh\n//;int c[]=int[23](5,3,2,20,1,12,9,19,7,15,21,6,22,17,10,23,14,18,8,4,11,13,16);//diagonal bad\n//;int c[]=int[23](1,16,13,11,17,8,19,22,12,7,21,15,20,5,9,18,14,2,10,3,4,6,23);//diagonal horrible    \n//;int c[]=int[23](2,9,14,4,10,12,16,17,1,21,8,18,7,19,22,13,11,6,3,20,5,23,15);//diagonal horrible    \n\nall!! symmetrical costas arrays of order 29 are:\n//;int c[]=int[29](3,11,1,10,25,19,14,16,20,4,2,15,27,7,12,8,29,18,6,9,26,23,22,28,5,21,13,24,17);//diagonal great\n//;int c[]=int[29](7,20,28,8,25,15,1,4,23,27,22,14,16,12,6,13,18,17,26,2,29,11,9,24,5,19,10,3,21);//diagonal okay\n//;int c[]=int[29](1,17,22,13,19,23,24,27,11,8,25,15,28,7,18,6,26,12,21,3,5,20,16,14,9,2,10,4,29);//diagonal bad\n//;int c[]=int[29](2,1,8,12,25,15,18,3,13,22,17,4,9,28,6,29,11,7,21,27,19,10,26,24,5,23,20,14,16);//diagonal bad\n//;int c[]=int[29](6,26,23,28,5,8,27,1,16,14,7,18,4,21,12,20,2,15,3,9,10,24,19,29,25,17,11,13,22);//diagonal horrible (vetically linear)\n\nall!! costas arrays of order 31 are: (only one asymmetrical one)\n;int c[]=int[31](1,28,20,27,17,18,21,30,26,14,9,25,11,31,29,23,5,13,6,16,15,12,3,7,19,24,8,22,2,4,10);//\n \nall KNOWN symmetrical costas arrays of order 37 are:\n//;int c[]=int[37](19,21,35,31,28,11,36,18,33,22,6,37,17,20,29,23,13,8,1,14,2,10,16,27,34,26,24,5,15,32,4,30,9,25,3,7,12);//diagonal meh (reverse is banded)\n//;int c[]=int[37](14,9,32,29,22,16,33,20,2,15,27,18,21,1,10,6,36,12,37,8,13,5,26,24,34,23,11,30,4,28,35,3,7,25,31,17,19);//diagonal bad (reverse is banded)\n\n\nall* symmetrical costas arrays of order 2 are: (skipped, too small)\n,1,2\nall* symmetrical costas arrays of order 4 are: (skipped, non prime)\n,1,2,4,3\nall* symmetrical costas arrays of order 6 are: (skipped, non prime)\n,1,4,5,3,2,6\n,1,5,3,6,2,4\n,1,6,3,5,4,2\n,1,6,4,3,5,2\n,2,4,5,1,6,3\nall* symmetrical costas arrays of order 8 are: (skipped, non prime)\n,1,5,8,4,2,7,6,3);\n,1,7,3,8,6,5,2,4);\n,1,7,4,3,5,8,2,6);\n,3,5,1,8,2,7,6,4);\nall* symmetrical costas arrays of order 9 are: (skipped, non prime)\n,1,4,6,2,9,3,8,7,5);\n,2,1,5,8,3,9,7,4,6);\nall* symmetrical costas arrays of order 10 are: (skipped, non prime)\n,1,7,4,9,3,5,8,6,2,10\n,2,1,9,4,5,8,10,6,3,7\n,2,6,8,1,9,5,3,4,10,7\n,2,8,9,4,1,3,7,5,10,6\n,3,9,1,4,5,10,8,7,2,6\n,3,9,7,8,4,1,6,10,2,5,\nall* symmetrical costas arrays of order 12 are: (skipped, non prime)\n,1,2,8,12,7,9,5,3,6,11,10,4\n,1,2,11,5,4,9,12,10,6,8,3,7\n1,4,11,2,10,7,6,8,12,5,3,9\n3,6,1,12,10,2,7,9,8,5,11,4\nall* symmetrical costasArrays of order 16 are  (skipped, non prime)\n1,13,3,16,14,8,10,6,15,7,12,11,2,5,9,4\n3,12,1,4,10,6,14,9,8,5,15,2,16,7,11,13\n3,13,4,15,12,6,10,2,7,8,11,1,14,16,9,5\n6,14,10,7,9,1,4,16,5,3,12,11,15,2,13,8\nall* symmetrical costasArrays of order 27 are (skipped, non prime)\n1,25,19,5,4,12,10,16,26,7,18,6,23,27,24,8,21,11,3,22,17,20,13,15,2,9,14\n3,9,1,8,13,15,19,4,2,20,11,25,5,17,6,27,14,24,7,10,26,23,22,18,12,21,16\n3,24,10,26,20,15,13,23,14,1,8,4,22,19,21,2,5,25,9,17,6,7,11,16,27,12,18\n4,17,21,9,11,16,25,12,1,7,26,22,14,15,13,20,23,3,24,6,18,8,2,27,10,5,19\n6,10,23,13,16,1,11,20,15,2,7,26,4,27,9,5,19,25,17,8,24,22,3,21,18,12,14\n6,16,20,12,14,7,1,25,8,17,18,26,11,23,10,24,15,13,3,19,22,27,5,2,9,4,21\n6,23,14,8,21,1,26,4,22,20,12,11,16,3,17,13,15,24,27,10,5,9,2,18,25,7,19\n\n\n    \n\n\n[*]== there are more than these BUT these extra costas-arrays are just a few SPECIFIC diagonal offsets \n(aslong the mirror axis) of the ones that are listed.\nand theres always the 4 axisAligned mirrors of g-symmetry.\n\nsome symmetrical costasArrays f order 30 are: (skipped, non prime)\n,1,23,14,12,18,26,30,20,25,11,10,4,16,3,21,13,22,5,19,8,15,17,2,28,9,6,29,24,27,7\n,11,22,5,13,23,10,2,26,29,15,19,20,14,4,6,21,18,27,1,30,25,7,3,9,16,28,17,8,24,12\n,12,24,20,17,2,9,29,3,16,4,28,18,19,27,22,6,10,1,30,8,14,25,11,5,15,7,21,23,26,13\n,13,26,2,21,29,4,9,11,15,27,12,8,17,18,7,22,1,30,20,23,6,24,19,16,10,3,25,5,28,14\n\na symmetrical costas array of order 35 is: (skipped, non prime)\n,1,12,7,27,32,30,3,24,31,17,19,2,16,29,20,13,10,35,11,15,23,33,21,8,26,25,4,34,14,6,9,5,22,28,18\n,\na symmetrical costas array of order 65 is: (skipped, non prime)\n,1,29,46,16,24,37,17,22,12,63,55,9,15,42,13,4,7,26,44,56,50,8,49,5,40,18,32,34,2,54,51,27,65,28,53,57,6,39,38,25,48,14,59,19,62,3,58,41,23,21,31,61,35,30,11,20,36,47,43,64,52,45,10,60,33\n\na symmetrical costas array of order 99 is: (skipped, non prime)\n1,33,94,11,21,59,40,85,39,44,4,75,88,36,73,56,60,45,67,61,5,24,55,22,87,30,92,64,37,26,49,51,2,79,38,14,29,35,9,7,97,63,89,10,18,70,62,76,31,99,32,78,65,74,23,16,96,71,6,17,20,47,42,28,53,95,19,69,68,46,58,86,15,54,12,48,82,52,34,91,98,77,93,90,8,72,25,13,43,84,80,27,83,3,66,57,41,81,50\n\t33\t94\t11\t21\t59\t40\t85\t39\t44\t4\t75\t88\t36\t73\t56\t60\t45\t67\t61\t5\t24\t55\t22\t87\t30\t92\t64\t37\t26\t49\t51\t2\t79\t38\t14\t29\t35\t9\t7\t97\t63\t89\t10\t18\t70\t62\t76\t31\t99\t32\t78\t65\t74\t23\t16\t96\t71\t6\t17\t20\t47\t42\t28\t53\t95\t19\t69\t68\t46\t58\t86\t15\t54\t12\t48\t82\t52\t34\t91\t98\t77\t93\t90\t8\t72\t25\t13\t43\t84\t80\t27\t83\t3\t66\t57\t41\t81\t50\n\n/**/\n\n/*\n\n//for compatibility with old opengl versions \n//(and to make arrays forksafe)\n//define shitty array struct\n//, with get()set()wrappers and constant array length code.\n//maxlen 27 ceashes too many tested environments (this first version is a bit shitty, too)\n#define maxLen 26\nstruct arr{int a[maxLen];int len;};\nvoid setN(inout arr u,int n,int s){n=clamp(n,1,maxLen);u.len=max(u.len,n);u.a[n-1]=s;}\nint  getN(arr u,int n){return u.a[clamp(n-1,0,u.len-1)];}//worksafing clamp()is faster than mod()\narr  newA(){arr r; r.len=1; r.a[0]=0;return r;}\n\n\n//modify setArray()to set the size of the array \n//AND the height of its pixels (last parameter)\n//theres only 1 pixel per column (later ones overwrite earlier ones)\n//any 2 pixels in the same line will be marked in white\n//where this is found ONCE (is not a CostasArray in that case)\narr setArray(){ //this could be read from a vertex buffer.\n ;arr a=newA()\n ;setN(a,1,1)\n ;setN(a,2,3)\n ;setN(a,3,4)\n ;setN(a,4,2)\n ;setN(a,5,5)\n\n//slow checker if an \n//struct arr{int a[maxLen];int len;}; \n//is a costasArray: https://www.shadertoy.com/view/tdjXWh\n//return array type[arr] as list of differentials of [a] with indexDistance [d]=[0<d<a.len]\narr strideDiff(arr a,int d\n){arr r=newA()\n ;for(int i=1;i<maxLen;i++\n ){setN(r,i,getN(a,i)-getN(a,i+d))\n  ;if (i+d>=a.len)break;}\n ;return r;}\n//getDupeEntry;\n//return pointers to the first 2 found duplicate entries in [a], comparing from a[0] till a[l].\n//if (there are no duplicate entry in [a] till entry a[l] )return ivec2(-1,-1)\nivec2 getDupeEntryS(ivec2 r,arr a,int i,int j\n){for(i=1;i<j;i++){if(getN(a,i)==getN(a,j))return ivec2(i,j);}\n ;return r;}\nivec2 getDupeEntry(arr a\n){ivec2 r=ivec2(-1,-1)//default state of [no dupes found]\n ;for(int i=0;i<maxLen-1;i++\n ){if(i==a.len)return r\n  ;r=getDupeEntryS(r,a,i,a.len-i)\n ;}return r;}\n//return if [a] is a [costas array] of order [a.len]\nivec3 isCostas(arr a\n){for(int i=1;i<=a.len;i++\n ){ivec2 dupes=getDupeEntry(strideDiff(a,i))\n  ;if(dupes.x!=-1)return ivec3(dupes,i);//return 2 indexes of found duplicate differential and dx\n  ;}\n ;return ivec3(-1,-1,-1);}//case of no dupes AND all in bounds == is costas Array\n\n/**/\n\n//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n//Type 1 = Orbit noise (https://www.shadertoy.com/view/4t3yDn)\n//Type 2 = Bicubic noise (https://www.shadertoy.com/view/XlVcWV)\n//Type 3 = Value noise\n//Type 4 = Gradient noise (from iq : https://www.shadertoy.com/view/XdXGW8)\n//Type 5 = Simplex noise (modified from iq's to use normalized gradients as per the original paper)\n//Type 6 = FBM (base noise can be defined in buffer A)\n#define NOISE_TYPE 1\n\n//#define SCROLL_COORDS\n#define DIAGONAL_DERIVATIVES\n#define SHOW_FOURIER\n#define SIZE (floor(iResolution.y/2.5)*2.)\n\nconst float globalScale = 1.;\n\n\n//See: https://www.shadertoy.com/view/Xt3cDn\nuint baseHash(uvec2 p)\n{\n    uint h32 = p.y + 374761393U + p.x*3266489917U;\n    h32 = 2246822519U*(h32^(h32 >> 15));\n    h32 = 3266489917U*(h32^(h32 >> 13));\n    return h32^(h32 >> 16);\n}\n\nfloat hash12(vec2 x)\n{\n    uint n = baseHash(uvec2(ivec2(x)));\n    return float(n)*(1.0/float(0xffffffffU));\n}\n\nvec2 hash22(vec2 x)\n{\n    uint n = baseHash(uvec2(ivec2(x)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec4 hash42(vec2 x)\n{\n    uint n = baseHash(uvec2(ivec2(x)));\n    uint n2 = n*48271U;\n    uvec4 rz = uvec4(n, n*16807U, n*n*48271U, n*n*69621U);\n    return vec4(rz & uvec4(0x7fffffffU))/float(0x7fffffff);\n}\n\n\n//the idea, cycle multiple pallettes of multiple tiled costas arrays, each of them a prime in size.\n//and then do a weighted mix\n//the result should be a weightable noise/dither, with very large period (depending on LUT sizes)\n\n//this can come close to a VERY large animarteable 2d bluenoise, that is generated on runtime, and hashable.\n\n//currently in experimental stage.\n//the diagonal banding is a bit diasssapointing.\n//this is due to, where ever mod(x,n)=mod(y,n) for quite similar N\n//gets the same inputs for small tiles (which are stronger in blue noise)\n    \n//lets just try larger primes&tiles\n//and hope that prime-gaps being less repetitie will remove the banding.\n\n//   self: https://www.shadertoy.com/view/Ws3BzH\n//parent0: https://www.shadertoy.com/view/tstBRr\n//parent1: https://www.shadertoy.com/view/Wsdfzr\n//parent2: https://www.shadertoy.com/view/tdjfzR\n\n//added NAIVE detection of both diagonal mirrorings\n\n//todo, with this i am very close to ANIMATED blue noise\n\n\n/*\nmixed prime base animated bluenoise\nthe idea is, to have a number, where each digit has a different base\n, and each base is a prime\n, and the 0th digit has the largest prime (like 13) \n, and the Nth digit has the smallest prime == 3\nthis way, small primes auromatically have an exponential effect\non the generated cumulative number\n(this may not be worth its calculation though, but i will solve for it once)\n\neach prime is a tiled layer, animated with a different offset, over time, set by \na pqfm, primal quadratic field matrix.\nso that 2 space domains, and 1 dtime domain, bith have period as long as possible.\n\ni also have a bias for costasArrays (of prime-size), that are \n- diagonally mirror symmetric\n- animate NICELY, when tiled and pallette shifted.\n\n\nlist of primes \n(stop at the number, where either\n, i find no good enough costasArray, or take to loong to find one)\n2,    //will skip this, cause its costasArray is too similar to [3]\n3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, \n43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,\n101\t103\t107\t109\t113\t127\t131\t137\t139\t149\t151\t157\t163\t167\t173\n\t179\t181\t191\t193\t197\t199\t211\t223\t227\t229\t233\t239\t241\t251\t257\t263\t269\t271\t277\t281\n\t283\t293\t307\t311\t313\t317\t331\t337\t347\t349\t353\t359\t367\t373\t379\t383\t389\t397\t401\t409\n\t419\t421\t431\t433\t439\t443\t449\t457\t461\t463\t467\t479\t487\t491\t499\n*/\n\n#define arrLen 7\n    \n\n/*\n\n5,3\n\nthe base (count of numbers) is the product of all larger primes\nand the smallest prime multiplies that amount by itself\n\nlets take the bases 3,5,7\n\nand its value       131 \none   threes means we counted ober 5*7 one   times, so the sum is +=1*5*7\nthree fives  means we counted over   7 three times, so the sum is +=3*  7\none   sevens                                      , so the sum is +=1\n->  5*7+3*7+1 == (5+3)*7+1 = 8*7+1=57\n, now, this is silly, while bases are very small, lets go bigger\n, also remember, a base os a mod(), base 10 never reaches 10, cause it includes 0\n\nlets do a 7 primes digit, with the bases\n  13,17,19,23,29,31,37\n0\n+ 12*17*19*23*29*31*37\n+    16*19*23*29*31*37\n+       18*23*29*31*37\n+          22*29*31*37\n+             28*31*37\n+                30*37\n+                   36\n=3212440750  (within 32 bit AND it is 74% of its max value 4294967295\n//this was not used in the end, cause its jsut WAAAY to exponential.\n//i just used type float weighting.\n\n*/\n/*\n//this seems broken, or jsut way too exponential\nint mixedPrimeBase(int[arrLen] a //[a] stores a number in bases [b] (different base foreach digit)\n){int b[arrLen]=int[arrLen](37,31,29,23,19,17,13);\n ;int c=1,r=0;//CumilativeBaseFactor , accumulatorToReturn\n ;for(int i=0;i<arrLen;i++){;r+=(a[i]-1)*c;c*=b[i];}return r;}\n/**/\n\n/*\ntheres another approach to this, with more prime bases, but each base is only binary.\nsee [boolean but jittery]\nthis may actually be much more memory efficient and cooler in animation\nits largest value would be \"111111111111111...\" as the sum of many primes. (no multiplication in here)\nbut that would have 32 or 64 (or more) primes.\nwe just chose arbitiary large primes (not necessarily many small ones)\nas long as the sum of all primes (sum < (pow(2,32)-1)) we will be fine.\n\n*/\n\n//todo, 2d fourier transform\n\n    //sources:\n    //http://jameskbeard.com/jameskbeard/Files.html#CostasArrays\n    //in above link, scroll down to \"Orders 201 through 300\" or \"Orders 476 through 500\"\n    //\n    //https://ieee-dataport.org/open-access/costas-arrays-and-enumeration-order-1030\n    //in above link, login is needed\n\n/*\n\ncostas arrays are pattern free==aperiodic\n3d costas arrays are impractival (too large LUT)\nbut a self recursed 2d costas array is still semi-aperiodic\n, great for dithering (in theory)\nsome of them still compress nicely due to meta-patterns between 2 of em\n\n\ncostas array [mode==0] is pattern free \nin short, it is an extension to the \"place the most exclusive queens on a checkerboard\"\n- BUT where even ALL XY-differentials between any 2 tokens must be unique (on a torus repetition)\nThis is (in theory) ideal for dithering\n(or as a basis for a music scmapler, that just has to add local arbitiary (strided) repetitions)\n\nThe [mode==1] greyscaling gradient is BASIC (and too much of a pattern)\n\nIt can easily be more distorted\n, by applying a second greyscaling-recursionpass [mode==2] of a costas array \n\nIf that is the same CostasArray over itself, it is only SEMI-pattern-free\n, even that but likely still good enough.\n\nTo turn this into (any amount of) (pattern free) BLUE (noise)\n,simply mix(a,b,0.75) 2 of these, where the scale.xy of one of CostasArray [a] \nis an interger multiple of the scale of the scale.xy of CostasArray [b]\n(and make sure, that both costas arrays are also costas-arrays over a tiled neighborhood)\n\nalso see [worlds ugliest music]==  https://www.youtube.com/watch?v=RENk9PK06AQ\n*/\n\n#define animatePaletteSpeed .9\n\n#define mode int(5.*iMouse.y/iResolution.y)\n//#define mode 4\n\n//mode 2 shows costas array as boolean dots\n//mode 1 shows it as linear fade gradient\n//mode 9 suffles the gradeitn by the same costas array\n//- this looks fine for most costas arrays, though its only semi-pattern.free\n//I assume mode 2 fails on SIMPLE costas3() costas arrays (that compress more than a LUT)\n//it sure looked nicer on my LUT arrays.\n//mode 4 cycles trhough all modes\n\n#define period 3\n\n//place multiple smaller tiles (important to expose some pattern)\n#define MultiTile 5.\n\n//scale by period\n#define zoom (min(iResolution.x,iResolution.y)/float(period-1))\n//pixel perfect, but only in preview\n//#define zoom 1.\n\n/*  //mathematical construction of a costas array list quickly hits limits of 32bit int\n    //therefore this segment is quite limited in its utility, and therefore commented out\n\n#define base1 2\n//the  (pase,period) pairs -> (3,5) (3,7) (5,7) make costas arrays\n//the  (pase,period) pairs (2,11) (2,13) (2,29) look a lot like they make costas arrays\n//(5,9) (7 11)\n//the function below fails for too large [#] values\n//it breaks for period>=37 (overflow or low float precision?)\n\n//way too high exponents in this one.\nint poi(int a,int b){//integer pow(a,b) as loop is slow but more precise\n ;//b=abs(b) //imply b>-1\n ;int r=a;for(int i=0;i<b;i++){r*=a;}return r;}\nint costas3(int x,int b\n){//return int(round(pow(float(b),float(x)+1.)))%int(period)//round() is essential on type float\n ;return poi(int(b),int(x))%period //type int has larger range, but type int exp() is silly\n ;}\n\n//return entry [a] of CostasArray list\n//return entry a of array (is a heightmap-like wrapper function)\n/**/\n\n\nint ae(int a){    \nint c[]=int[3](1,3,2);\n//;int c[]=int[5](3,5,1,4,2);//LEAST NOTICEABLE diagonal banding (also in reverse)   \n//int c[]=int[5](5,2,4,3,1);//diagonal banding (also in reverse)   \n//;int c[]=int[7](3,7,1,4,6,5,2);//diagonal great (reversed to kill banding)    \n//;int c[]=int[11](1,10,4,3,8,11,9,5,7,2,6);//diagonal great    \n//;int c[]=int[13](1,10,3,9,6,5,7,12,4,2,13,8,11);//diagonal good\n//;int c[]=int[17](2,1,15,7,5,11,4,16,13,17,6,14,9,12,3,8,10);//diagonal great\n//all costas arrays of size 19 are (no diagonal symmetry at all):\n//;int c[]=int[19](1,12,16,18,19,10,15,8,14,17,9,5,3,2,11,6,13,7,4);//meh\n//;int c[]=int[19](1,13,12,18,11,15,17,7,10,5,14,19,16,8,6,2,9,3,4);//bad\n//;int c[]=int[23](1,15,10,4,5,12,21,23,11,3,9,6,14,13,2,19,22,18,16,20,7,17,8);//diagonal meh\n//;int c[]=int[29](3,11,1,10,25,19,14,16,20,4,2,15,27,7,12,8,29,18,6,9,26,23,22,28,5,21,13,24,17);//----great and sdiagonal\n//;int c[]=int[31](1,28,20,27,17,18,21,30,26,14,9,25,11,31,29,23,5,13,6,16,15,12,3,7,19,24,8,22,2,4,10);//\n//;int c[]=int[37](19,21,35,31,28,11,36,18,33,22,6,37,17,20,29,23,13,8,1,14,2,10,16,27,34,26,24,5,15,32,4,30,9,25,3,7,12);\n/**/\n;return c[(       a  )%period]\n;//return c[(period-a-1)%period]//reverse\n;}    //i admit, its quite the LUT\n    //but give it a try, because it should be VERY aperiodic, in theory, great for dithering\n    //\n    //sources:\n    //http://jameskbeard.com/jameskbeard/Files.html#CostasArrays\n    //in above link, scroll down to \"Orders 201 through 300\" or \"Orders 476 through 500\"\n    //\n    //https://ieee-dataport.org/open-access/costas-arrays-and-enumeration-order-1030\n    //in above link, login is needed\n\nint gpo(int a){int b[arrLen]=int[7](37,31,29,23,19,17,13);return b[a];}\n\nint getCostasOf(int a,int p){//return costas at Position of Array#\n if(a<4){\n  if(a<2){\n   if(a==0){int c[]=int[37](19,21,35,31,28,11,36,18,33,22,6,37,17,20,29,23,13,8,1,14,2,10,16,27,34,26,24,5,15,32,4,30,9,25,3,7,12);return c[p%37]\n     ;}else{int c[]=int[31](1,28,20,27,17,18,21,30,26,14,9,25,11,31,29,23,5,13,6,16,15,12,3,7,19,24,8,22,2,4,10);return c[p%31];}\n     }else{\n   if(a==2){int c[]=int[29](3,11,1,10,25,19,14,16,20,4,2,15,27,7,12,8,29,18,6,9,26,23,22,28,5,21,13,24,17);return c[p%29]\n     ;}else{int c[]=int[23](1,15,10,4,5,12,21,23,11,3,9,6,14,13,2,19,22,18,16,20,7,17,8);;return c[p%23];}\n}}else{\n   if(a==4){int c[]=int[19](1,12,16,18,19,10,15,8,14,17,9,5,3,2,11,6,13,7,4);return c[p%19];}\n   if(a==5){int c[]=int[17](2,1,15,7,5,11,4,16,13,17,6,14,9,12,3,8,10);;return c[p%17];}\n           {int c[]=int[13](1,10,3,9,6,5,7,12,4,2,13,8,11);;return c[p%13];}}}\n\nint Cs(ivec2 u,int a,int iFrame){\n ;int r=0\n ;int per=gpo(a)\n ;u=u%per //tile to positive infinity\n ;//if(max(u.x,u.y)>per-1)return 0; //only show one tile\n ;int c=getCostasOf(a,per-u.y)//-1??\n ;//if(c+1==u.x)return per;return 0;//monochrome (makes nice starfields)\n ;r=c-u.x\n ;if(r<0)r+=per\n ;r=getCostasOf(a,per-r)  //we reverse the second pass, (habbitually, there may be a better approach)\n ;//r+=getCostasOf(a,per)//optional for a better match with simpler mode \n ;//r=r%per;\n ;r+=(iFrame/4)%per\n ;r=r%per;\n ;return r;}\n\nvec4 CostasNoise(ivec2 u,int iFrame){\n ;u/=2\n /*\n ;int[arrLen] m=int[arrLen](0,0,0,0,0,0,0);\n ;m[0]=Cs(u,0);\n ;m[1]=Cs(u,1);\n ;m[2]=Cs(u,2);\n ;m[3]=Cs(u,3);\n ;m[4]=Cs(u,4);\n ;m[5]=Cs(u,5);\n ;m[6]=Cs(u,6);\n ;float a=float(mixedPrimeBase(m))/float(3212440750)//first attempt failed*/\n     //VERY exponential weights seem silly mow, but the precison would be neat.\n     \n \n ;float r=0.;\n    \n    \n //;float f[]=float[7](0.,1.,0.,0.,0.,0.,0.)//singleton\n    \n //;float f[]=float[7](1.,1.,1.,1.,1.,1.,1.)//flat (strong banding)\n //;float f[]=float[7](4.,3.,2.,1.,2.,3.,4.)//valley\n //;float f[]=float[7](1.,2.,4.,8.,16.,32.,64.)//blue (most banding?)\n //;float f[]=float[7](1.,2.,3.,4.,3.,2.,1.)//windowed \n ;float f[]=float[7](64.,32.,16.,8.,4.,2.,1.)//anti-blue /least banding)\n     //dissappointingly, even small prime tiles as small as 19*19 salready have too stron giagonal banding\n     //so i guess, i just need larger tiles and larger primes.\n     //i take a bet that it is a bad idea to repeat prime-gaps (espoecially short ones), which may result in the banding\n ;r+=float(Cs(u,0,iFrame))/float(gpo(0))*f[0];\n ;r+=float(Cs(u,1,iFrame))/float(gpo(1))*f[1];\n ;r+=float(Cs(u,2,iFrame))/float(gpo(2))*f[2];\n ;r+=float(Cs(u,3,iFrame))/float(gpo(3))*f[3];\n ;r+=float(Cs(u,4,iFrame))/float(gpo(4))*f[4];\n ;r+=float(Cs(u,5,iFrame))/float(gpo(5))*f[5];\n ;r+=float(Cs(u,6,iFrame))/float(gpo(6))*f[6];\n ;float a=r/(f[0]+f[1]+f[2]+f[3]+f[4]+f[5]+f[6])\n ;return vec4(a,a,a,1);\n}\n\nfloat wrap(vec2 u,int iFrame,float iTime){//O=getCostasOfFloat(u);\n ;//u*=2.2\n ;u/=2.5\n ;float g=(sqrt(5.)*.5+.5)\n ;float speed=.00003*iTime\n ;vec2 s= (vec2(cos(speed),sin(speed*g))*.5+.5)*10000000. \n     //i am pleased that this noise still has a strong pattern to make scrolling easily noticable.\n     //thile its color palette cycles.\n ;ivec2 scroll=ivec2(0);\n ;//ivec2 scroll=ivec2(s);\n ;//u.x+=u.y*(sqrt(5.)*.5+.5) //optionally skew diagonal banding by goldenRatio (sucks)\n ;//u.x+=u.y*u.y*g\n ;return CostasNoise(ivec2(u)+scroll,iFrame).x;}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n\n//modified (simplified) nuttall filter for orbit noise\n//see: https://www.shadertoy.com/view/XtVcWc\nfloat nuttall(float x, float w)\n{\n    const float pi = 3.14159265358979;\n    if (abs(x) > w)\n        return 0.;\n    //Standard Nuttall\n    //return 0.355768 - 0.487396*cos(pi*x/w + pi) + 0.144232*cos(2.*pi*x/w) - 0.012604*cos(3.*pi*x/w + pi*3.);\n    return 0.365 - (0.5)*cos(pi*x/w + pi) + (0.135)*cos(2.*pi*x/w);\n}\n\nfloat orbitNoise(vec2 p)\n{\n    //return wrap(p,iFrame,iTime);\n    //return fract(p.x-p.y);\n    \n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n    float rz = 0.;\n    float orbitRadius = .75;\n\n    //16 taps\n    for (int j = -1; j <= 2; j++)\n    for (int i = -1; i <= 2; i++)\n    {\n        vec2 dp = vec2(j,i);\n        vec4 rn = hash42(dp + ip) - 0.5;\n        vec2 op = fp - dp + rn.zw*orbitRadius;\n        rz += nuttall(length(op),1.85)*dot(rn.xy*1.7, op);\n    }\n    return rz*0.5+0.5;\n    //return smoothstep(-1.0, 1.0,rz);\n    /**/\n}\n\nvec4 powX(float x) {float x2 = x*x; return vec4(x2*x, x2, x, 1.0); }\nvec4 MNParamsA(float B, float C){ return vec4(12. - 9.*B - 6.*C, -18. + 12.*B + 6.*C, 0.0, 6. -2.*B)/6.; }\nvec4 MNParamsB(float B, float C){ return vec4(-B -6.*C, 6.*B + 30.*C, -12.*B - 48.*C, 8.*B + 24.*C)/6.; }\n\nfloat eval(float c0, float c1, float c2, float c3, float x) \n{    \n    const float B = .8;\n    const float C = 0.25;\n    vec4 pA = MNParamsA(B, C);\n    vec4 pB = MNParamsB(B, C);\n    \n    return c0*dot(pB, powX(x + 1.0)) + c1*dot(pA, powX(x)) +\n           c2*dot(pA, powX(1.0 - x)) + c3*dot(pB, powX(2.0 - x));\n}\n\nfloat bicubicNoise(in vec2 p)\n{\n    vec2 fp = fract(p);\n    vec2 ip = floor(p);\n    \n    float s99 = hash12(ip+vec2(-1,-1)), s19 = hash12(ip+vec2(1,-1));\n    float s00 = hash12(ip+vec2(0,0)),   s20 = hash12(ip+vec2(2,0));\n    float s91 = hash12(ip+vec2(-1, 1)), s11 = hash12(ip+vec2(1, 1));\n    float s02 = hash12(ip+vec2(0,2)),   s22 = hash12(ip+vec2(2,2));\n    float s09 = hash12(ip+vec2(0,-1)),  s29 = hash12(ip+vec2(2,-1));\n    float s90 = hash12(ip+vec2(-1,0)),  s10 = hash12(ip+vec2(1,0));\n    float s01 = hash12(ip+vec2(0,1)),   s21 = hash12(ip+vec2(2,1));\n    float s92 = hash12(ip+vec2(-1,2)),  s12 = hash12(ip+vec2(1,2));\n    \n    float rz =  eval(eval(s99, s09, s19, s29, fp.x), eval(s90, s00, s10, s20, fp.x),\n                eval(s91, s01, s11, s21, fp.x), eval(s92, s02, s12, s22, fp.x), fp.y);\n    \n    //return rz;\n    return smoothstep(0.0,1.,rz);\n}\n\nfloat valueNoise(vec2 p)\n{\n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n\tvec2 ramp = fp*fp*(3.0-2.0*fp);\n\n    float rz= mix( mix( hash12(ip + vec2(0.0,0.0)), hash12(ip + vec2(1.0,0.0)), ramp.x),\n                   mix( hash12(ip + vec2(0.0,1.0)), hash12(ip + vec2(1.0,1.0)), ramp.x), ramp.y);\n    \n    return rz;\n}\n\nvec2 hashz( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\t//return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n    return normalize(-1.0 + 2.0*fract(sin(p)*43758.5453123) + 1e-7);\n}\n\n//from iq: https://www.shadertoy.com/view/Msf3WH\nfloat simplex( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hashz(i+0.0)), dot(b,hashz(i+o)), dot(c,hashz(i+1.0)));\n\n    return dot( n, vec3(80.0) )*0.5+0.5;\n\t\n}\n\nvec2 hashg(vec2 x) { return hash22(x)*2.0-1.0;}\n\n//From iq: https://www.shadertoy.com/view/XdXGW8\nfloat gradientNoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    float rz =  mix( mix( dot( hashg( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hashg( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hashg( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hashg( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n    \n    //return rz*0.75+0.5;\n    return smoothstep(-.9,.9,rz);\n}\n\nfloat fbm(vec2 p)\n{\n    float rz = 0.;\n    float amp = 1.95;\n    for (int i = 0; i < 7; i++)\n    {\n        rz += orbitNoise(p*1.)/amp;\n        //rz += bicubicNoise(p*1.3)/amp;\n        //rz += gradientNoise(p*.6)/amp;\n        //rz += valueNoise(p)/amp;\n        //rz += simplex(p*.35)/amp;\n        amp *= 2.;\n        p *= 2.06;\n    }\n    //return rz;\n    return smoothstep(0.,1.,rz); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef SHOW_FOURIER\n    if(fragCoord.x > SIZE)\n    {\n        fragColor = vec4(0);\n        return;\n    }\n#endif\n    vec2 p = fragCoord/iResolution.xy;\n    vec2 q = p;\n\tp.x *= iResolution.x/iResolution.y;\n    \n#ifdef SCROLL_COORDS\n    p += vec2(1,1.5)*iTime*0.03;\n#endif\n    \n    if (fragCoord.y > SIZE)        p*=0.75;\n    \n    vec3 col = vec3(0);\n    \n   // p *= globalScale;\n    \n    col= vec3(wrap(p*iResolution.y*2.5,iFrame,iTime));\n    /*\n    \n#if (NOISE_TYPE == 1)\n    col = orbitNoise(p*40.)*vec3(1);\n#elif (NOISE_TYPE == 2)\n    col = bicubicNoise(p*55.)*vec3(1);\n#elif (NOISE_TYPE == 3)\n    col = valueNoise(p*40.)*vec3(1);\n#elif (NOISE_TYPE == 4)\n    col = gradientNoise(p*25.)*vec3(1);\n#elif (NOISE_TYPE == 5)\n    col = simplex(p*14.)*vec3(1);\n#elif (NOISE_TYPE == 6)\n    col = fbm(p*20.)*vec3(1);\n#endif\n    */\n    //if (col.x >= 1. || col.x <= 0.) col = vec3(1,0,0); //Range check\n    col = clamp(col, 0.,1.);\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n//Horizontal + Vertical Discrete Fourier Transform of the input \n//adapted from FabriceNeyret2's https://www.shadertoy.com/view/XtScWt\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b)); } \n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord )\n{\n   \tfragColor = vec4(0);\n    \n#ifdef SHOW_FOURIER\n    if(fragCoord.x > SIZE || fragCoord.y > SIZE) return;\n    \n    for(float i = 0.; i < SIZE; i++)  \n\t{\n\t\tvec2 xn = texelFetch(iChannel0, ivec2(i, fragCoord.y), 0).rr;\n        vec2 yn = texelFetch(iChannel1, ivec2(fragCoord.x, i), 0).ba;\n\t\tvec2 ang = - 6.2831853 * (fragCoord-.5 -SIZE/2.) * i/SIZE;\n\t\tfragColor.zw += cmul(xn, ang.x);\n\t\tfragColor.xy += cmul(yn, ang.y);\n    }\n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}