{
    "Shader": {
        "info": {
            "date": "1636295818",
            "description": "Using cheap 2D layering techniques to produce a faux extruded grid consisting of rotating gears.",
            "flags": 0,
            "hasliked": 0,
            "id": "ftdGRB",
            "likes": 51,
            "name": "Rotating Gear Grid",
            "published": 3,
            "tags": [
                "2d",
                "grid",
                "gear",
                "cog",
                "layer",
                "faux"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 766
        },
        "renderpass": [
            {
                "code": "/*\n\n    Rotating Gear Grid\n    ------------------    \n    \n    Using cheap 2D layering techniques to produce a faux extruded grid \n    consisting of rotating gears. No raymarching was harmed during the\n    making of this example, as they say. :)\n    \n    I love rotating cog patterns. The basic 2D grid versions are pretty\n    easy to code up, and there are heaps of examples on Shadertoy. Here, \n    I've provided the square and hexagon arrangements -- Both are pretty \n    common.\n\n    Just in case it isn't obvious, the point of this is to cheap out with \n    a few layers in order to give the impression that it's a 3D scene, \n    which it does, providing you don't look into it too much. While we're \n    at it, the code works fine, but I wouldn't pay too much attention to \n    that either. :) By the way, there are a various options below for \n    anyone interested in trying out different looks.\n    \n    A raymarched version is simple enough to produce, and I intend to put \n    one of those up later.    \n\n    Due to the layout, it'd be possible to combine this with a moving \n    Truchet pattern to make something interesting, but I'll leave that as \n    an exercise. :)\n    \n    \n    \n    Similar examples:\n    \n    // Fabrice has examples of almost everything on here. :)\n    gear field - hexagonal tiling 7 - FabriceNeyret2\n    https://www.shadertoy.com/view/lsKSRt\n    \n\n*/\n\n\n// Hexagon grid arrangement.\n#define HEXAGON\n\n// Color scheme: Evening: 0, Sepia: 1, Pink: 2, Dawn: 3, Green: 4.\n#define COLOR 0\n\n// Texture the scene.\n#define TEXTURE\n\n// Use a second style of cog.\n//#define COG2\n\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n// Hacky global angular position for the cog... I'll tidy this later.\nvec2 gA;\n\n\nfloat cogs(vec2 p, vec2 ip) {\n    \n    // Time: You could just have a simple linear time value, but I thought it'd\n    // be interesting the sinusoidally reverse direction. Hence the following.\n    float tm = iTime/8.;\n    float ftm = floor(tm); // Integer time.\n    float frtm = tm - ftm; // Fractional time.\n    float tDir = mod(ftm, 2.)*2. - 1.; // Reversing direction every second.\n    tm = tDir*(sin(frtm*3.14159)*.5 + .5)*6.2831*2.; // Reversed sinusoidal motion.\n    \n    // Cog radius. \n    float rad = .44;\n    float cir = length(p); // Circle.\n    // Cog distance field.\n    float d = cir - rad;\n    \n    // Reversing the direction on alternate cogs in the grid. How you do it is \n    // up to you... I hacked the hexagon one for sure. I'm pretty sure Fabrice \n    // would have done it in a more elegant way, so I'd refer to his example.\n    #ifdef HEXAGON\n    float dir = mod(ip.x + mod(ip.y*2., 3.), 2.)==0.? -1. : 1.;\n    #else\n    float dir = mod(ip.x + ip.y, 2.)==0.? -1. : 1.;\n    #endif\n  \n    // Adding the teeth via polar coordinates.\n    vec2 q = p; \n    float aNum = 12.; // Teeth number.\n    // Time based movement.\n    q *= rot2(tm*dir - 3.14159/aNum/2.);\n    gA = q; // Hacky global angular position.\n   \n    float a = atan(q.y, q.x);\n    float ia = floor(a/6.2831*aNum);\n    \n    #if 0\n    // A cheap, but effective way to produce teeth using AntoineC's formula, here:\n    // Planetary gears - https://www.shadertoy.com/view/MsGczV\n    // It's a really elegant example, by the way, but I'm using a more expensive \n    // method below. Anyway, the option to use it is here, if you're curious.\n    float teeth = .125/(1.1 + exp(3.*cos(dir*tm - aNum*a)));\n    d = (d - teeth)/1.25;\n    #else\n    \n    a = (ia + .5)/aNum;\n    q *= rot2(-a*6.2831);\n    q.x -= rad;\n\n    // Outer teeth.\n    float teeth = mix(max(abs(q.x) - .12, abs(q.y) - .05), length(q.xy*vec2(.7, 1)) - .12, .35);\n    d = min(d, teeth); // Applying the teeth to the cog object.\n    #endif\n    \n    \n \n  \n    #ifdef COG2\n    // Use a solid center with a thin central ring taken\n    // out for the second cog style.\n    d = max(d, -(abs(cir - .34) - .005));\n    #else\n    // For the other style, chop out some holes to give it\n    // a more cartoonish look.\n    \n    // Six polar dispersed holes.\n    aNum = 6.;\n    vec2 q2 = p;\n    q2 *= rot2(tm*dir - 3.14159/aNum/4.);\n    a = atan(q2.y, q2.x);\n    ia = floor(a/6.2831*aNum);\n    a = (ia + .5)/aNum;\n    q2 *= rot2(-a*6.2831);\n    q2.x -= rad;\n    \n    // The small holes.\n    float innerCir = length(q2 - vec2(-.15, 0)) - .065;\n    //float innerCir = max(abs(cir - .285) - .045, -(abs(q2.y) - .07));\n    d = max(d, -innerCir); // Cutting them out.\n    #endif\n    \n    \n    // Cutting out the central hole.\n    d = max(d, -(cir - .14)); \n \n    \n    return d; // Return the cog distance.\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Aspect correct pixel coordinates.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Scene rotation.\n    float tm = mod(iTime/8., 2.);\n    \n    // Lens warping.\n    uv *= sqrt(max(1. - (.5 - dot(uv, uv))*.25, 0.));\n    \n    // Pixel rotation, which equates to a 2D camera rotation.\n    uv *= rot2(-sin(tm*3.14159)*2./8.);\n    \n    // Global zoom scale and smoothing factor.\n    float scl = 4.5;//4.5 + sin(tm*3.14159)*.5;\n    float sf = scl/iResolution.y;\n    \n    // The scaling is slightly different for hexagon grids and square ones.\n    #ifdef HEXAGON\n    vec2 sc = vec2(.8660254, 1);\n    #else\n    vec2 sc = vec2(1);\n    #endif\n    \n    // Scaling and translation.\n    vec2 p = uv*scl - vec2(-sc.x/2., 0) - vec2(sin(tm*3.14159)*sc.x*2., 0);\n    \n    \n    // Distance values for various samples:\n    // Distance, highlight, shadow and extrusion.\n    float d = 1e5, dHi = 1e5, dSh = 1e5, dEx = 1e5;\n    \n    // Saved cog ID.\n    vec2 id;\n    \n    // Light direction.\n    vec2 lgtDir = normalize(vec2(-2, -1));\n    \n    // Fake unit direction ray.\n    vec3 rd = normalize(vec3(uv, 1));\n    \n    // Saved cog position and angular position.\n    vec2 svP, svA;\n    \n    // Background pattern rivot values. This has been hacked in.\n    float bgPat = 1e5, bgPat2 = 1e5;\n    \n    // The cell shapes exceed the cell boundaries, which means covering all \n    // surrounding cells that the shape covers. In this case, there are 4.\n    // By the way, you could get away with two taps, if you really wanted to.\n    // However, the square grid 3D version would require all four.\n    for(int i = 0; i<=1; i++){\n        for(int j = 0; j<=1; j++){\n          \n            // Local cell coordinates and cell ID.\n            vec2 cntr = vec2(i, j) - .5;\n            vec2 q = p;\n            vec2 iq = floor(q/sc - cntr); \n            #ifdef HEXAGON\n            if(mod((iq.x), 2.)<.001) {\n               q.y += sc.y/2.;\n               iq = floor(q/sc - cntr); \n            }\n            #endif\n            q -= (iq + .5)*sc; \n            \n            // Extruded \"q\" position. This is a hacky estimate, but it's\n            // enough to fool the eyes, provided you don't look too hard. :)\n            vec2 qEx = q + rd.xy*.2/(1. + length(uv)*1.5);\n            \n            \n            // Producing distance fields for the rivots and highlights\n            // on the hexagon arrangement... I've hacked it in the middle\n            // of the loop out of sheer laziness, but you could produce\n            // this outside.\n            #ifdef HEXAGON\n            vec2 miq = mod(iq, vec2(2, 3));\n            if((miq.x + miq.y)==0. || (miq.x*miq.y)==1.){\n           \n                vec2 rdd = lgtDir*.01;\n                float hx = length(qEx);\n                float hx2 = length(qEx - rdd);\n                bgPat = min(bgPat, (hx - .1));\n                bgPat2 = min(bgPat2, (hx2 - .1));\n                 \n                // After rendering producing the rivot field,\n                // skip the cog field construction.\n                continue;\n            }\n            #endif\n\n           \n            // Some distance field samples.\n            //\n            // // Top layer.\n            float cg = cogs(q, iq); \n            // Store the closest distance.\n            if(cg<d) { d = cg; id = iq; svP = q; svA = gA; }\n            // Extruded.\n            dEx = min(dEx, cogs(qEx, iq));\n            // Shadow.\n            dSh = min(dSh, cogs(qEx - lgtDir*.135, iq));\n            // Highlight.\n            dHi = min(dHi, cogs(q - lgtDir*.01, iq));            \n             \n            \n         }\n    }\n    \n    \n    // Random number based on the cog ID.\n    float rnd =  hash21(id);\n    \n    // Lit background.\n    vec3 bg = mix(vec3(.6), vec3(.4), clamp(dot(rd.xy, lgtDir), 0., 1.));\n\n    // Changing the background color, depending on the palette.\n    #if COLOR == 0\n    bg *= vec3(.7, .85, 1);\n    #elif COLOR == 1\n    bg *= vec3(.77, .64, .5);\n    bg *= vec3(1.2, 1, .8);\n    #elif COLOR == 2\n    bg *= vec3(.45, .5, .55);\n    #elif COLOR == 3\n    bg *= vec3(1, .85, .7);\n    #endif\n\n\n    #ifdef TEXTURE\n    // Background texture.\n    // The textured plane is technically at the extruded \"p\" position.\n    vec2 pEx = p + rd.xy*.2/(1. + length(uv)*1.5);\n    vec3 tx = texture(iChannel0, (pEx + 2.)/4.).xyz; tx *= tx;\n    tx = smoothstep(-.05, .5, tx);\n    tx = min(tx*2., 1.5);\n\n    // Cog texture.\n    #ifdef COG2\n    // If using the second cog style, keep the center texture coordinates\n    // static and let the outer coordinates rotate.\n    svA = mix(svP, svA, smoothstep(0., sf, abs(length(svP) - .24) - .07));\n    #endif\n    //\n    vec3 tx2 = texture(iChannel0, svA/4. + rnd/4.).xyz; tx2 *= tx2;\n    tx2 = smoothstep(-.05, .5, tx2);\n    tx2 = min(tx2*2., 1.5);\n    \n    #else\n    // When not texturing, set the value to one.\n    vec3 tx = vec3(1);\n    vec3 tx2 = vec3(1);\n    #endif\n    \n    // If applicable, apply the texture to the background.\n    bg *= tx;\n\n    \n    // Initiate the scene color to the background.\n    vec3 col = bg;\n    \n    // Apply the circle rivots to the backgournd.\n    float b = max(bgPat2 - bgPat, 0.)/.01;\n    col = mix(col, bg*1.5, (1. - smoothstep(0., sf*24., bgPat))*.25);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., bgPat))*.5);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, bgPat));\n    col = mix(col, bg/2.*(1. + b) + b*.25*2., 1. - smoothstep(0., sf, bgPat + .025));\n    col = mix(col, bg/2.*(1. + b) + b*.25, 1. - smoothstep(0., sf, bgPat + .025 + .025));\n    //col += col*b*vec3(1, 2, 4)*.2;\n\n\n    // Use the randomly generated cog ID and IQ's cosine palette formula\n    // to produce a cog color.\n    vec3 oCol = .5 + .45*cos(6.2831*rnd/8. + vec3(0, 1, 2));\n\n\n    // Color alternating cogs different colors or shades.\n    #ifdef HEXAGON\n    if(mod(id.x + mod(id.y*2., 3.), 2.)==0.){\n    #else\n    if(mod(id.x + id.y, 2.)<.001){\n    #endif\n\n        oCol = mix(oCol, oCol.zyx, .6);\n        #if COLOR == 3\n        oCol = oCol.zyx;\n        #endif\n    } \n    #if COLOR == 4\n    else {\n        oCol = mix(oCol, oCol.yxz, .75);\n        //oCol = mix(oCol, oCol.yxz, dot(sin(p/1.5 + cos(p/.75)*1.57), vec2(.25)) +.5);\n    }\n    #endif\n\n\n\n    #if COLOR == 1\n    if(mod(id.x + mod(id.y*2., 3.), 2.)==0.)\n        oCol = vec3(.55, .5, .44)*dot(oCol, vec3(.299, .587, .114));\n    else oCol = vec3(.9, .8, .7)*mix(oCol, oCol.zyx, .25);\n    oCol *= vec3(1.15, 1, .85);\n    #elif COLOR == 2\n    oCol = (mix(oCol.xzy, vec3(1, .15, .3), .5)*1.5);\n    //if(mod(id.x + 1., 4.)<=1.) oCol = oCol.zyx;\n    //if(hash21(id + .21)<.5) oCol = oCol.zyx;\n    oCol = mix(oCol, oCol.zyx, dot(sin(p/1.5 + cos(p/.75)*1.57), vec2(.35)) +.5);\n    #ifdef HEXAGON\n    if(mod(id.x + mod(id.y*2., 3.), 2.)==0.){\n    #else\n    if(mod(id.x + id.y, 2.)<.001){\n    #endif\n        oCol = vec3(.4)*dot(oCol, vec3(.299, .587, .114));\n        oCol *= vec3(.9, 1, 1.1);\n    }\n    #endif\n\n    // Apply the second texture value to the cog color.\n    oCol *= tx2;\n\n\n    // Rendering.\n\n\n    // Sample differnces for highlights.\n    float sh = max(dHi - d, 0.)/.01;\n    float sh2 = max(d - dHi, 0.)/.01;\n\n    // Rotated top face highlight.\n    //vec2 svQ = -rot2(atan(lgtDir.x, lgtDir.y))*svP;\n    //float sh3 = mix(0., 1., smoothstep(0., .25, svQ.x));\n\n\n    // Render the layers in order.\n    //\n    // Extruded AO, extruded edge and extruded layer itself.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*12., dEx - .02))*.5);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, dEx - .02))*.95); \n    col = mix(col, oCol/2. + sh*.25, (1. - smoothstep(0., sf, dEx + .005))); // oCol/2.\n\n    // Laying the shadow down over the background and extruded section.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dSh - .015))*.5);\n\n\n    // Top layer edge, edge highlight and colored center.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, d))*.95);\n    col = mix(col, oCol + sh*.5, (1. - smoothstep(0., sf, d + .025))*.95);\n    //\n    #ifdef COG2\n    // For the second cog style, brighten the outside and darkent the center.\n    oCol = mix(oCol*1.3, oCol/1.4, (1. - smoothstep(0., sf, abs(length(svP) - .24) - .07)));\n    #endif\n    col = mix(col, oCol + sh*.25, 1. - smoothstep(0., sf, d + .025+.025));\n\n\n    // Debug grayscale value.\n    //col = vec3(1)*dot(col, vec3(.299, .587, .114));\n\n    // Vignette. \n    col *= max(1.1 - length(uv)*.25, 0.);\n\n\n    // Rought gamma correction before presenting to the screen.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}