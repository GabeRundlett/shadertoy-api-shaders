{
    "Shader": {
        "info": {
            "date": "1534728001",
            "description": "Messy code. WIP",
            "flags": 0,
            "hasliked": 0,
            "id": "lttyWs",
            "likes": 9,
            "name": "Distance Goo",
            "published": 3,
            "tags": [
                "voronoi"
            ],
            "usePreview": 0,
            "username": "momoro",
            "viewed": 620
        },
        "renderpass": [
            {
                "code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nmat2 rotate(float angle) {\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle)\n    );\n}\n\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                    vec2(12.9898, 78.233)))*\n        \t\t\t\t 43758.5453123);\n}\n\nfloat random1 (float f) {\n    return random(vec2(f, -0.128));\n}\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk:\nfloat smin(float a, float b, float k){\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\nfloat noise(float s) {\t\n    float i = floor(s);\n    float f = fract(s);\n    float n = mix(random(vec2(i, 0.)), \n                  random(vec2(i+1., 0.)), \n                  smoothstep(0.0, 1., f)); \n   \n    return n;\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat map(float value, float inMin, float inMax, float outMin, float outMax) {\n\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n\n} \n\n\n\nvec2 map(vec2 value, vec2 inMin, vec2 inMax, vec2 outMin, vec2 outMax) {\n\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n\n}\n\n\n\nvec3 map(vec3 value, vec3 inMin, vec3 inMax, vec3 outMin, vec3 outMax) {\n\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n\n}\n\n\n\nvec4 map(vec4 value, vec4 inMin, vec4 inMax, vec4 outMin, vec4 outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\n\n\n\nvec4 blend(vec4 bg, vec4 fg) {\n    vec4 c = vec4(0.);\n    c.a = 1.0 - (1.0 - fg.a) * (1.0 - bg.a);\n    if(c.a < .00000) return c;\n    \n    c.r = fg.r * fg.a / c.a + bg.r * bg.a * (1.0 - fg.a) / c.a;\n    c.g = fg.g * fg.a / c.a + bg.g * bg.a * (1.0 - fg.a) / c.a;\n    c.b = fg.b * fg.a / c.a + bg.b * bg.a * (1.0 - fg.a) / c.a;\n    \n    return c;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec4 color;\n\n    for(float i=0.; i<3.; i++) {\n        vec2 st = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n       //st = rotate(i * 0.024) * st;\n        \n\n       // st *=6.456 * i/-0.528;\n//        st *= i * 30.;\n      //  st *= 4. + (i/11.);\n        st *= 3.5;\n        st += vec2(-0.170,-0.240);\n\n        // Tile\n        vec2 i_st = floor(st);\n        vec2 f_st = fract(st);\n\n        float m_dist = 1.; // min distance\n\n        for(int j=-2; j<=2; j++) {\n            for(int i=-2; i<=2; i++) {\n\n                // Neighbor place in the grid\n                vec2 neighbor = vec2(float(i), float(j));\n\n                // Random position from current + neighbor place in the grid\n                vec2 offset = random2(i_st + neighbor);\n\n                // Animate the offset\n                offset = 0.5 + 0.5 * sin(iTime + 6.2831 * offset );\n\n                // Position of the cell\n                vec2 pos = neighbor + offset - f_st;\n\n                // Cell distance\n                float dist = length(pos);\n\n                // Metaball\n                m_dist = smin(m_dist, dist, 1.344);            \n            }\n        }\n\n\n        float f = m_dist;\n        f *= 5.;\n        float steps = 3.;\n                f = ceil(f *steps) / steps;\n\n        vec2 cst = st;\n        cst = rotate(iTime/10.) * cst;\n        cst *= sin(iTime/2.);\n        float h = map(m_dist, 0., 1., 0.068, -0.316);\n      //  float h;\n\n     //   h += (cst.x + 0.376)/10. * (cst.y/10. - 1.280) * 1.264;\n\n        //h = -2.224 * i/1.680 * cos(st.x/25. * u_time) * length(st*-0.016);\n      //  h = 1.;\n        float s = map(f, 0., 1., 1., 0.752);\n        float v = map(f, 0., 0.696, 0.280, 0.824);\n\n        color += vec4(hsv2rgb(vec3(h, s, v)), 0.184);\n     //   color *= \tfwidth(f) * 100.;\n\n        //color *= 2.896;\n\n        vec2 uv= st;\n        f = 0.;\n        uv.x *= noise(iTime - 20.);\n        uv.y *= noise(iTime);\n        f = 1.0 - length(uv);\n\n        vec2 uv2 = st;\n        uv2 += 0.476;\n        uv2*=0.378;\n        float q = map(1.0 - length(uv2), -0.496, 1., -0.552, 1.072);\n        q += 3.744;\n        \n\n\n       //color *= abs(vec4(f)) * 1.276 ;\n       // color *= q * 0.760;\n    }\n    \n\tvec2 st = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\tfloat f =  length(st);\n    f = smoothstep(0.352, 0.332, f);\n    //color = vec3(f);\n //  color *= f;\n    color *= 1.704;\n  //  color = fwidth(color) * 100.;\n    fragColor = color;\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}