{
    "Shader": {
        "info": {
            "date": "1669963274",
            "description": "Another wave function collapse shader. This one takes a few minutes to converge completely, but I think it's interesting to watch!\n\n*mouse drag up/left: zoom out*\n*mouse drag down/right: re-center and zoom in*\n*shift+mouse drag: pan* \n*space to reset*",
            "flags": 48,
            "hasliked": 0,
            "id": "mdBSRW",
            "likes": 25,
            "name": "Circuit Board WFC",
            "published": 3,
            "tags": [
                "wfc",
                "wavefunctioncollapse"
            ],
            "usePreview": 0,
            "username": "fenix",
            "viewed": 498
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Another in what looks like it might be a series using \"simple tiled model\" wave\n//  function collapse, because these are fun to play with.\n//\n//      https://github.com/mxgmn/WaveFunctionCollapse\n//\n//  My other WFC shaders:\n//\n//      Simple Wave Function Collapse     https://shadertoy.com/view/DdfSzj\n//      Roguelike Dungeon WFC             https://shadertoy.com/view/ddSXzW\n//\n//  This one converges quite a lot slower, mainly because it takes a while to \"figure\n//  out\" that the chips have to be rectangular. It's also inspired directly by one of \n//  the original WFC patterns:\n//\n//    https://raw.githubusercontent.com/mxgmn/WaveFunctionCollapse/master/images/circuit-1.png\n//\n//  The entire buffer is simulated, so you're only looking at 1/64th of the buffer when\n//  the shader boots, chosen so that the 8x8 tile pixels are 1:1 with screen pixels. Click\n//  and drag the mouse up/left to zoom out.\n//\n//  The tiles are defined in the Common tab, and are designed to be easy to change. Forks\n//  of this shader are welcome if you draw your own tiles and make something intereting\n//  and new out of it. But please post a comment here so I don't miss it!\n//\n//  The rendering was probably harder to get working than the simulation, because I\n//  wanted to be able to zoom out and watch the simulation from farther away. My first\n//  attempt had horrible aliasing artifacts so I had to add this box clipping system.\n//\n//  I'm curious if the mouse camera controls are effective or not for other people. Once\n//  you get used to it, it's handy for zooming in on specific details, I think.\n//\n//  Buffer A computes the wave function collapse\n//  Buffer B handles camera controls\n//\n// ---------------------------------------------------------------------------------------\n\n// compute the overlapping area between two axis aligned boxes\nfloat boxClip(vec4 a, vec4 b)\n{\n    vec4 i = vec4(max(a.xy, b.xy), min(a.zw, b.zw));\n    vec2 e = i.zw - i.xy;\n    return any(lessThanEqual(e, vec2(0))) ? 0. : e.x * e.y;\n}\n\n// rotate a pixel index\nivec2 rotIdx(ivec2 v, int r)\n{\n    if (r == 0) return ivec2(v.x, 7 - v.y);\n    if (r == 1) return v.yx;\n    if (r == 2) return ivec2(7 - v.x, v.y);\n    if (r == 3) return 7 - v.yx;\n}\n\n#define GET_SUBTILE(T, U) ((TILES[T].image[U.y] >> ((7 - U.x) * 3)) % 8u)\n\n// compute the color contribution of a single tile, clipped to the screen pixel\nvec3 tileClip(int type, int rot, vec4 clipBox)\n{\n    vec3 sum = vec3(0);\n    for (ivec2 v = ivec2(0); v.x < 8; ++v.x)\n    for (v.y = 0; v.y < 8; ++v.y)\n    {\n        uint value = GET_SUBTILE(type, rotIdx(v, rot));\n        sum += subtileColor(value, ((v.x + v.y) & 1) == 0) * boxClip(clipBox, vec4(vec2(v) / 8., (vec2(v) + 1.) / 8.));\n    }\n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fxState state = fxGetState();\n\n    fragCoord -= .5 * iResolution.xy;\n    fragCoord *= state.zoom;\n    fragCoord += state.center * iResolution.y;\n    fragCoord += .5 * iResolution.xy;\n    \n    // compute the tile address and coordinates within the tile for the lower left and upper right corners of the pixel\n    vec2 llc = fragCoord - .5 * state.zoom;\n    ivec2 llt = ivec2(llc);\n    llc = fract(llc);\n    vec2 urc = fragCoord + .5 * state.zoom;\n    ivec2 urt = ivec2(urc);\n    urc = fract(urc);\n    \n    vec3 sum = vec3(0);\n    \n    // loop over all the tiles, clipping as we go\n    for (ivec2 tile = llt; tile.x <= urt.x; ++tile.x)\n    for (tile.y = llt.y; tile.y <= urt.y; ++tile.y)\n    {\n        if (all(greaterThan(tile, ivec2(0))) && all(lessThan(tile, ivec2(iResolution.xy))))\n        {\n            vec4 v = texelFetch(iChannel0, tile, 0);\n            int type = int(v.x);\n            int rot = int(v.y);\n\n            vec4 clipBox = vec4(0, 0, 1, 1);\n\n            // clip one or more sides if necessary\n            if (tile.x == llt.x) clipBox.x = llc.x;\n            if (tile.y == llt.y) clipBox.y = llc.y;\n            if (tile.x == urt.x) clipBox.z = urc.x;\n            if (tile.y == urt.y) clipBox.w = urc.y;\n\n            sum += tileClip(type, rot, clipBox);\n        }\n    }\n    \n    fragColor = sqrt(vec4(sum / (state.zoom * state.zoom), 1));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nvec3 subtileColor(uint value, bool parity)\n{\n    if (value == 0u) return vec3(0);\n    if (value == 1u) return vec3(0,.1,0);\n    if (value == 2u) return vec3(.3,.8,.3);\n    if (value == 3u) return vec3(.05);\n    if (value == 4u) return vec3(.5);\n    if (value == 5u) return parity ? vec3(.5,.1,.1) : vec3(.3,.1,.1);\n    if (value == 6u) return vec3(0,0,.5);\n    if (value == 7u) return parity ? vec3(.1,.1,.5) : vec3(.1,.1,.3);\n    return vec3(1,0,1);\n}\n\nstruct Tile\n{\n    mat3 shape; // defines how this tile matches to neighbors\n    float prob; // lower numbers will cause this tile to be chosen less often\n    uint image[8]; // 8-color octal array defining how to render the tile, referencing the above colors\n};\n\nconst Tile T_EMPTY =\n    Tile(mat3(0, 0, 0,\n              0, 0, 0,\n              0, 0, 0),\n         0.,\n         uint[](0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u));\n         \nconst Tile T_BOARD =\n    Tile(mat3(1, 1, 1,\n              1, 1, 1,\n              1, 1, 1),\n         .9,\n         uint[](011111111u,\n                011111111u,\n                011111111u,\n                011111111u,\n                011111111u,\n                011111111u,\n                011111111u,\n                011111111u));\n                \nconst Tile T_CHIP =\n    Tile(mat3(3, 3, 3,\n              3, 3, 3,\n              3, 3, 3),\n         .7,\n         uint[](033333333u,\n                033333333u,\n                033333333u,\n                033333333u,\n                033333333u,\n                033333333u,\n                033333333u,\n                033333333u));\n                \nconst Tile T_NODE =\n    Tile(mat3(1, 1, 1,\n              1, 1, 2,\n              1, 1, 1),\n         0.1,\n         uint[](011111111u,\n                011144111u,\n                011444411u,\n                014444442u,\n                014444442u,\n                011444411u,\n                011144111u,\n                011111111u));\n                \nconst Tile T_WIRE =\n    Tile(mat3(1, 1, 1,\n              4, 4, 4,\n              1, 1, 1),\n         0.5,\n         uint[](011111111u,\n                011111111u,\n                044444444u,\n                044444444u,\n                044444444u,\n                044444444u,\n                011111111u,\n                011111111u));\n                \nconst Tile T_EDGE =\n    Tile(mat3(3, 1, 1,\n              3, 2, 2,\n              3, 1, 1),\n         1.,\n         uint[](033111111u,\n                033111111u,\n                033411111u,\n                033444422u,\n                033444422u,\n                033411111u,\n                033111111u,\n                033111111u));\n                \nconst Tile T_CORNER =\n    Tile(mat3(3, 1, 1,\n              1, 1, 1,\n              1, 1, 1),\n         .5,\n         uint[](033111111u,\n                033111111u,\n                011111111u,\n                011111111u,\n                011111111u,\n                011111111u,\n                011111111u,\n                011111111u));\n                \nconst Tile T_TRACE =\n    Tile(mat3(1, 1, 1,\n              2, 2, 2,\n              1, 1, 1),\n         0.1,\n         uint[](011111111u,\n                011111111u,\n                011111111u,\n                022222222u,\n                022222222u,\n                011111111u,\n                011111111u,\n                011111111u));\n                \nconst Tile T_CROSS =\n    Tile(mat3(1, 4, 1,\n              2, 4, 2,\n              1, 4, 1),\n         0.7,\n         uint[](011444411u,\n                011444411u,\n                011444411u,\n                022444422u,\n                022444422u,\n                011444411u,\n                011444411u,\n                011444411u));\n                \nconst Tile T_JUNCT =\n    Tile(mat3(1, 4, 1,\n              1, 4, 1,\n              1, 2, 1),\n         0.7,\n         uint[](011444411u,\n                011444411u,\n                011444411u,\n                011444411u,\n                011444411u,\n                011144111u,\n                011144111u,\n                011122111u));\n                \nconst Tile T_T =\n    Tile(mat3(1, 2, 1,\n              2, 2, 2,\n              1, 1, 1),\n         0.5,\n         uint[](011122111u,\n                011122111u,\n                011122111u,\n                022222222u,\n                022222222u,\n                011111111u,\n                011111111u,\n                011111111u));\n                \nconst Tile T_ACROSS =\n    Tile(mat3(1, 2, 1,\n              1, 2, 2,\n              1, 1, 1),\n         .3,\n         uint[](011122111u,\n                011112211u,\n                011111221u,\n                011111122u,\n                011111112u,\n                011111111u,\n                011111111u,\n                011111111u));\n                \nconst Tile T_2ACROSS =\n    Tile(mat3(1, 2, 1,\n              2, 1, 2,\n              1, 2, 1),\n         .3,\n         uint[](011122111u,\n                011112211u,\n                011111221u,\n                021111122u,\n                022111112u,\n                012211111u,\n                011221111u,\n                011122111u));\n                \nconst Tile T_INODE =\n    Tile(mat3(1, 1, 1,\n              2, 1, 2,\n              1, 1, 1),\n         0.01,\n         uint[](011111111u,\n                011144111u,\n                011444411u,\n                024444442u,\n                024444442u,\n                011444411u,\n                011144111u,\n                011111111u));\n                \nconst int NUM_TILES = 14;\n\nconst Tile[NUM_TILES] TILES =\n    Tile[](\n        T_EMPTY,\n        T_BOARD,\n        T_CHIP,\n        T_NODE,\n        T_WIRE,\n        T_EDGE,\n        T_CORNER,\n        T_TRACE,\n        T_CROSS,\n        T_JUNCT,\n        T_T,\n        T_ACROSS,\n        T_2ACROSS,\n        T_INODE\n    );\n\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n\nstruct fxState\n{\n    float resolution;\n    float zoom;\n    float oldZoom;\n    vec2 center;\n    vec2 oldCenter;\n    bool attract;\n};\n\nfxState fxGetStateInternal(sampler2D sampler)\n{\n    vec4 data0 = texelFetch(sampler, ivec2(0), 0);\n    vec4 data1 = texelFetch(sampler, ivec2(1, 0), 0);\n    fxState state;\n    state.resolution = data0.x;\n    state.zoom = data0.y;\n    state.oldZoom = data0.z;\n    state.attract = data0.w != 0.;\n    state.center = data1.xy;\n    state.oldCenter = data1.zw;\n    return state;\n}\n\n#define fxGetState() fxGetStateInternal(iChannel1)\n\nvec4 fxPutState(fxState state, ivec2 ifc)\n{\n    if (ifc == ivec2(0))\n    {\n        return vec4(state.resolution, state.zoom, state.oldZoom, state.attract ? 1. : 0.);\n    }\n    \n    return vec4(state.center, state.oldCenter);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// The room where it happens.\n// ---------------------------------------------------------------------------------------\n\nint g_NumValidTiles;\nconst int MAX_VALID_TILES = NUM_TILES * 4;\nint g_ValidTiles[MAX_VALID_TILES];\nint g_ValidTileRs[MAX_VALID_TILES];\n\n#define R1(m) mat3(m[0][2], m[1][2], m[2][2], m[0][1], m[1][1], m[2][1], m[0][0], m[1][0], m[2][0])\n\n// rotate a shape matrix r times to the right\nmat3 rotShape(mat3 s, int r)\n{\n    while (r < 0) r += 4;\n    r = r % 4;\n    if (r == 1) s = R1(s);\n    else if (r == 2) s = R1(R1(s));\n    else if (r == 3) s = R1(R1(R1(s)));\n    \n    return s;\n}\n\nbool tilesMatch(mat3 a, mat3 b) { return a[0][0] == b[2][0] && a[0][1] == b[2][1] && a[0][2] == b[2][2]; }\n\n// find the full array of tiles that could be compatible with a particular tile already placed\nvoid findValidTiles(vec4 n, int r)\n{\n    mat3 nShape = rotShape(TILES[int(n.x)].shape, int(n.y) + r);\n    \n    for (int i = 0; i < NUM_TILES; ++i)\n    {\n        mat3 myShape = TILES[i].shape;\n        for (int d = 0; d < 4; ++d)\n        {\n            if (tilesMatch(rotShape(myShape, d), nShape))\n            {\n                g_ValidTiles[g_NumValidTiles] = i;\n                g_ValidTileRs[g_NumValidTiles] = (d + 4 - r) % 4;\n                g_NumValidTiles++;\n            }\n        }\n    }\n}\n\n// remove any tiles from the array that do not match the particular tile already placed\nvoid removeInvalidTiles(vec4 n, int r)\n{\n    mat3 nShape = rotShape(TILES[int(n.x)].shape, int(n.y) + r);\n\n    for (int i = 0; i < g_NumValidTiles; ++i)\n    {\n        mat3 myShape = rotShape(TILES[g_ValidTiles[i]].shape, g_ValidTileRs[i] + r);\n        if (!tilesMatch(myShape, nShape))\n        {\n            g_ValidTiles[i] = g_ValidTiles[g_NumValidTiles - 1];\n            g_ValidTileRs[i] = g_ValidTileRs[g_NumValidTiles - 1];\n            g_NumValidTiles--;\n            i--;\n        }        \n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fxState state = fxGetState();\n    ivec2 ifc = ivec2(fragCoord);\n    if (iFrame == 0 || state.resolution < 0.)\n    {\n        // reset\n        fragColor = vec4(0);\n        \n        // seed one pixel in the middle of the field\n        if (ifc == ivec2(iResolution.xy * vec2(.5, .925))) fragColor = vec4(1, 0, 0, 0);\n        \n        return;\n    }\n    \n    fragColor = texelFetch(iChannel0, ifc, 0);\n\n    // update in an alternating checkerboard pattern, so no tile is updating on the same tick as any neighbor\n    if (((ifc.x + ifc.y) & 1) == (iFrame & 1)) return;\n\n    vec3 h = hash3(uvec3(fragCoord, iFrame));\n    vec4 ns[4] = vec4[]( texelFetch(iChannel0, ifc + ivec2(0, 1), 0),\n                         texelFetch(iChannel0, ifc + ivec2(1, 0), 0),\n                         texelFetch(iChannel0, ifc + ivec2(0, -1), 0),\n                         texelFetch(iChannel0, ifc + ivec2(-1, 0), 0) );\n\n    // reset when requested by neighbor that can't find a solution\n    if (ns[0].z > 0. || ns[1].z > 0. || ns[2].z > 0. || ns[3].z > 0. || fragColor.z > 0.)\n    {\n        if (h.x > .5)\n        {\n            fragColor.x = 0.;\n            fragColor.y = 0.;\n            fragColor.z = max(0., max(max(max(max(fragColor.z, ns[0].z), ns[1].z), ns[2].z), ns[3].z) - 1.);\n        }\n        return;\n    }\n    \n    // empty cells with no neighbors have a chance to spontaneously collapse\n    if (fragColor.x == 0. && ns[0].x == 0. && ns[1].x == 0. && ns[2].x == 0. && ns[3].x == 0.)\n    {\n        if (h.x < 1e-6)\n        {\n            fragColor.x = floor(h.y * float(NUM_TILES));\n            fragColor.y = floor(h.y * 4.);\n            fragColor.z = 0.;\n        }\n        return;\n    }\n    \n    if (fragColor.x == 0.)\n    {\n        // we're empty but one of our neighbors is not, look for a value for ourselves\n        g_NumValidTiles = 0;\n        bool noSolution = false;\n        for (int d = 0; d < 4; ++d)\n        {\n            if (ns[d].x != 0.)\n            {\n                if (g_NumValidTiles == 0)\n                {\n                    // whichever direction is first non-empty will find all its valid tiles\n                    findValidTiles(ns[d], d);\n                }\n                else\n                {\n                    // every other direction then gets a chance to remove invalid options\n                    removeInvalidTiles(ns[d], d);\n                    if (noSolution = g_NumValidTiles == 0) break;\n                }\n            }\n        }\n\n        if (noSolution)\n        {\n            // if we're stuck, ask our neighbors to revert\n            fragColor.z = fragColor.z + 1.1;\n        }\n        else if (g_NumValidTiles > 0)\n        {\n            vec3 h = hash3(uvec3(fragCoord, iFrame));\n            int choice = int(h.y * float(g_NumValidTiles));\n            \n            // last chance rejection by probability, just try again next frame\n            if (h.z < TILES[g_ValidTiles[choice]].prob)\n            {\n                // install the chosen valid tile\n                fragColor.x = float(g_ValidTiles[choice]);\n                fragColor.y = float(g_ValidTileRs[choice]);\n            }\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Just for handling persistent state: camera position and zoom level.\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifc = ivec2(fragCoord);\n    if (ifc != ivec2(0) && ifc != ivec2(1, 0)) { discard; }\n    \n    fxState state = fxGetState();\n    if (iFrame == 0 || keyClick(KEY_SPACE) || iResolution.x * iResolution.y != abs(state.resolution))\n    {\n        state.resolution = -iResolution.x * iResolution.y;\n        state.zoom = 1./8.;\n        state.oldZoom = 1./8.;\n        state.center = vec2(0);\n        state.oldCenter = vec2(0);\n        state.attract = true;\n    }\n    else\n    {\n        state.resolution = abs(state.resolution);\n        \n        if (iMouse.z > 0. && iMouse.w < 0.)\n        {\n            state.attract = false;\n            if (keyDown(KEY_SHIFT))\n            {\n                vec2 delta = state.zoom * (iMouse.zw * vec2(1, -1) - iMouse.xy) / iResolution.y;\n                state.center = state.oldCenter + delta;\n            }\n            else\n            {\n                float mouseZoom = (iMouse.y + iMouse.w + iMouse.z - iMouse.x) / iResolution.y;\n                state.zoom = state.oldZoom * pow(2., 4. * mouseZoom);\n                if (mouseZoom < 0.)\n                {\n                    vec2 mouseCenter = (vec2(iMouse.z, -iMouse.w) - .5 * iResolution.xy) / iResolution.y;\n                    mouseCenter *= state.oldZoom;\n                    mouseCenter += state.oldCenter;\n                    state.center = mix(state.oldCenter, mouseCenter, min(1.,-5.*mouseZoom));\n                }\n            }\n        }\n        else\n        {\n            state.oldZoom = state.zoom;\n            state.oldCenter = state.center;\n        }\n        \n        if (state.attract)\n        {\n            state.center = .42*vec2(sin(iTime*.02), cos(iTime*.02));\n        }\n    }\n    \n    fragColor = fxPutState(state, ifc);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}