{
    "Shader": {
        "info": {
            "date": "1569729809",
            "description": "Well this is my first post in ShaderToy and also working with shaders.\nThis code was originally wrote in Visual Studio and my OpenGL setup. I like the result so i decided to post it here.\nHope someone like it!! Feel free to modify it whatever you want",
            "flags": 0,
            "hasliked": 0,
            "id": "3sKGz1",
            "likes": 6,
            "name": "Psychodelic_Caleidoscope ",
            "published": 3,
            "tags": [
                "2d",
                "caleidoscope",
                "2dcaleidoscope"
            ],
            "usePreview": 0,
            "username": "sirArthurDayne",
            "viewed": 508
        },
        "renderpass": [
            {
                "code": "\n#define PI 3.141592\n#define TAU (2.0*PI)\n\n\nvec2 ConvertToPolar(vec2 rectCoord)\n{\n    //vectors becomes: magnitude, angle\n    return vec2(length(rectCoord), atan(rectCoord.y, rectCoord.x));\n}\n\nvec2 ConvertToRect(vec2 polarCoord)\n{\n    return vec2(polarCoord.x * cos(polarCoord.y), polarCoord.x * sin(polarCoord.y));\n}\n\nvec3 ColorTransition(vec3 colorA, vec3 colorB)\n{\n    float pct = abs(sin(iTime))/2.0;\n\n    return vec3(mix (colorA, colorB, pct));\n}\n\n\nvec2 pMod2(inout vec2 p, vec2 size) \n{\n    vec2 c = floor((p + size * 0.5) / size);\n    p = mod(p + size * 0.5, size) - size * 0.5;\n    return c;\n}\n\n\nfloat DistanceCircle(float radius, vec2 origin)\n{\n    return length(origin) - radius;\n}\n\nfloat DistanceRoundedBox(float radius, vec2 origin)\n{\n    /*the more pow increment the less rounded the box is*/\n    origin = origin * origin;\n    origin = origin * origin;\n    float d8 = dot(origin, origin);\n    return pow(d8, 1.0 / 8.0) - radius;\n}\n\nfloat DistanceBox(vec2 size, vec2 origin)\n{\n    origin = abs(origin);\n    float dx = 2.0*origin.x - size.x;\n    float dy = 2.0*origin.y - size.y;\n    return max(dx, dy);\n}\n\nfloat DrawMotionOne(vec2 position)\n{\n    position = abs(position);\n    vec2 p_position = ConvertToPolar(position);\n    p_position.y += position.x * sin(iTime);//rotation\n    p_position.x *= 1.0 + position.y;//mod radius\n    position = ConvertToRect(p_position);\n    float distanceThree = DistanceBox(vec2(0.5, 0.5), position + vec2(0.0));\n    return distanceThree;\n}\n\nfloat DrawCaleidoscopeSimple(vec2 position, float times)\n{\n    vec2 p_pos = ConvertToPolar(position);\n    p_pos.y = mod(p_pos.y, TAU / times);\n    p_pos.y += iTime;\n    position = ConvertToRect(p_pos);\n    pMod2(position, vec2(0.5));\n    float d1 = DistanceCircle(0.2, position);\n    float d2 = DistanceBox(vec2(0.2), position - vec2(0.1));\n    return min(d1, d2);\n}\n\nfloat DrawCaleidoscopeEffect(vec2 position, float times, vec2 size)\n{\n    vec2 p_pos = ConvertToPolar(position);\n    float beta = TAU / times;\n    float np = p_pos.y / beta;\n    p_pos.y = mod(p_pos.y, beta);\n    float m2 = mod(np, 2.0);\n    if (m2 > 1.0)\n    {\n        p_pos.y = beta - p_pos.y;\n    }\n    p_pos.y += iTime;\n    position = ConvertToRect(p_pos);\n\n    //make repeating patron\n    pMod2(position, size);\n\n    float d1 = DistanceCircle(0.1, position);\n    float d2 = DistanceBox(vec2(0.1), position - vec2(0.1));\n    return min(d1, d2);\n}\n//post processing methods\nvoid Rotation(inout vec2 position, float angle)\n{\n    position = vec2(position.x * cos(angle) + position.y * sin(angle), \n        -position.x * sin(angle) + position.y * cos(angle));\n}\n\nvec3 ChangeSaturation(vec3 color, vec2 position)\n{\n    Rotation(position, iTime);\n    color = clamp(color, 0.0, 1.0);\n    return pow(color, vec3(length(position)));//more saturate at borders\n    \n    //return pow(color, vec3(1.0 /length(position)));//more saturate at center\n    //saturate roullete\n    //return pow(color, vec3(abs(position.x)/ length(position), abs(position.y)/ length(position),length(position)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec3 crimson =  vec3(0.7, 0.02, 0.23);\n    vec3 elecgreen = vec3(0.04, 1.0, 0.16);\n    vec3 outputColor = vec3(0.0);\n\n    //setup scaling and origin pos\n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    //uv.y *= iResolution.x / iResolution.y;\n    \n\n    \n    vec2 offset = uv;\n    Rotation(offset, iTime);\n\n    float distance = DrawCaleidoscopeEffect(uv-offset, 25.0, vec2(0.5));\n    float md = mod(distance, 0.1);\n    float nd = abs(distance / 0.1) ;\n\n    if (abs(distance) < 0.1)\n    {\n        outputColor = ColorTransition(crimson, elecgreen);\n    }\n    \n    if (abs(md) < 0.01)\n    {\n        outputColor = (distance < 0.0) ? crimson / nd : elecgreen / nd;\n    }\n    \n    //apply postProccessing before outputing \n    \n    fragColor = vec4(ChangeSaturation(outputColor, uv), 1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}