{
    "Shader": {
        "info": {
            "date": "1513633557",
            "description": "trying to figure out sound \nI stole the ocean from https://www.shadertoy.com/view/Ms2SD1\n\nand brownian noise from some other place can't remember \n\n////\n\n\n...",
            "flags": 8,
            "hasliked": 0,
            "id": "llffDf",
            "likes": 6,
            "name": "pink noise ocean ",
            "published": 3,
            "tags": [
                "soundocean"
            ],
            "usePreview": 0,
            "username": "reedjones",
            "viewed": 886
        },
        "renderpass": [
            {
                "code": "\n//ocean based from https://www.shadertoy.com/view/Ms2SD1\n\n/*\n * \"Seascape\" by Alexander Alekseev aka TDM - 2014\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: tdmaav@gmail.com\n */\n\nconst int NUM_STEPS = 4;\nconst float PI\t \t= 3.141592;\nconst float EPSILON\t= 1e-3;\n#define EPSILON_NRM (0.1 / iResolution.x)\n\n// sea\nconst int ITER_GEOMETRY = 3;\nconst int ITER_FRAGMENT = 5;\nconst float SEA_HEIGHT = 0.6;\nconst float SEA_CHOPPY = 2.0;\nconst float SEA_SPEED = 0.3;\nconst float SEA_FREQ = 0.12; //.15\nconst vec3 SEA_BASE = vec3(0.9,0.1,0.22);\nconst vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6);\n#define SEA_TIME (1.0 + iTime * SEA_SPEED)\nconst mat2 octave_m = mat2(4.6,1.2,-1.2,1.6);\n\n// math\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) {\n    return pow(dot(n,l) * 0.4 + 0.6,p);\n}\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (PI * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n// sky\nvec3 getSkyColor(vec3 e) {\n    // I want black sky :)\n    e.y = max(e.y,0.0);\n    //return vec3(pow(1.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4);\n    return vec3(0, 0, 0); \n}\n\n// sea\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nfloat map(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nfloat map_detailed(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \n    float fresnel = clamp(1.0 - dot(n,-eye), 0.0, 1.0);\n    fresnel = pow(fresnel,3.0) * 0.65;\n        \n    vec3 reflected = getSkyColor(reflect(eye,n));    \n    vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \n    \n    vec3 color = mix(refracted,reflected,fresnel);\n    \n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\n    \n    color += vec3(specular(n,l,eye,60.0));\n    \n    return color;\n}\n\n// tracing\nvec3 getNormal(vec3 p, float eps) {\n    vec3 n;\n    n.y = map_detailed(p);    \n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\n    n.y = eps;\n    return normalize(n);\n}\n\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \n    float tm = 0.0;\n    float tx = 1000.0;    \n    float hx = map(ori + dir * tx);\n    if(hx > 0.0) return tx;   \n    float hm = map(ori + dir * tm);    \n    float tmid = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++) {\n        tmid = mix(tm,tx, hm/(hm-hx));                   \n        p = ori + dir * tmid;                   \n    \tfloat hmid = map(p);\n\t\tif(hmid < 0.0) {\n        \ttx = tmid;\n            hx = hmid;\n        } else {\n            tm = tmid;\n            hm = hmid;\n        }\n    }\n    return tmid;\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;    \n    float time = iTime * 0.3 + iMouse.x*0.01;\n        \n    // ray\n    vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.3,time);    \n    vec3 ori = vec3(0.0,3.5,time*5.0);\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); dir.z += length(uv) * 0.15;\n    dir = normalize(dir) * fromEuler(ang);\n    \n    // tracing\n    vec3 p;\n    heightMapTracing(ori,dir,p);\n    vec3 dist = p - ori;\n    vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);\n    vec3 light = normalize(vec3(0.0,1.0,0.8)); \n             \n    // color\n    vec3 color = mix(\n        getSkyColor(dir),\n        getSeaColor(p,n,light,dir,dist),\n    \tpow(smoothstep(0.0,-0.05,dir.y),0.3));\n        \n    // post\n\tfragColor = vec4(pow(color,vec3(0.75)), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nvec2 add = vec2(1.0, 0.0);\n#define MOD2 vec2(.16632,.17369)\n#define MOD3 vec3(.16532,.17369,.15787)\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in ...\nfloat hash11(float p)\n{\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y)-.5;\n}\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\t//p  = fract(p * MOD3);\n    vec3 p3 = fract(vec3(p) * MOD3);\n    p3 += dot(p3.xyz, p3.yzx + 19.19);\n   return fract(vec2(p3.x * p3.y, p3.z*p3.x))-.5;\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3.zxy, p3.yxz+19.19);\n    return fract(vec2(p3.x * p3.y, p3.z*p3.x))-.5;\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 Noise21(float x)\n{\n    float p = floor(x);\n    float f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return  mix( hash21(p), hash21(p + 1.0), f)-.5;\n    \n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nfloat Noise11(float x)\n{\n    float p = floor(x);\n    float f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return mix( hash11(p), hash11(p + 1.0), f);\n\n}\n\nvec2 Noise1(vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    vec2 res = mix(mix( hash22(p),          hash22(p + add.xy),f.x),\n                   mix( hash22(p + add.yx), hash22(p + add.xx),f.x),f.y);\n    return res;\n}\n// Fractal Brownian Motion...\nvec2 FBM22(vec2 x)\n{\n    vec2 r = vec2(0.0);\n    \n    float a = .7;\n    \n    for (int i = 0; i < 8; i++)\n    {\n        r += Noise1(x) * a;\n        a *= .5;\n        x*=2.0;\n        x+=10.;\n    }\n     \n    return r;\n}\n\n\nvec2 mainSound( in int samp, float time )\n    \n{\n  \n    vec2 audio = vec2(.0);\n    vec2 n1 = FBM22( \n        vec2(\n         time*520., time*530.) * \n        (Noise21(time*.2+9.)*.2+1.)) * \n        (Noise21(time*.5)+1.);\n    \n    vec2 synth =  vec2( \n        sin(6.2831 * 440.0 * time) *\n        exp(-1.0 * time) );\n    \n    //vec2 synth2 vec2(  );\n       \n    \n    audio += n1; \n    audio += synth; \n    //audio += synth2; \n     \n   // return audio; \n    \n    return clamp(\n        audio, -1.0, 1.0) * \n        smoothstep(0.0, 3.1, time) * \n        smoothstep(180.0, 170.0, time);\n    \n\n}\n\n\n/**\n\naudio += (n1+n2)/2.0;\n\n\n\n*/",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}