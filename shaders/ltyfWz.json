{
    "Shader": {
        "info": {
            "date": "1542207734",
            "description": "Simple noise shader\n\nImplemented XXHash32 for optional high-quality RNG",
            "flags": 0,
            "hasliked": 0,
            "id": "ltyfWz",
            "likes": 5,
            "name": "S1 - Perlin Noise",
            "published": 3,
            "tags": [
                "noise"
            ],
            "usePreview": 0,
            "username": "AshenFlowersFalling",
            "viewed": 548
        },
        "renderpass": [
            {
                "code": "/*\n\tSimple 2D/3D Perlin Noise shader.\n\n\tControls:\n\n\t\tLMB down, drag left/right = change persistence\n\t\tLMB down, drag up/down = change lacunarity \n\n\n\tRange of a single octave of Perlin Noise of dimension N is equal to (sqrt(N) / 2).\n\n\tThis is because the maximum appears at position (1/2, 1/2, ..., 1/2) when the direction\n\tvectors at each lattice point are pointing towards this position, i.e. have directions of\n\t(+/- 1/sqrt(N), +/- 1/sqrt(N), ..., +/- 1/sqrt(N)). This results in a value of N/(2*sqrt(N))\n\t= sqrt(N)/2 for each lattice point, of which there are 2^N, each with an interpolation \n\tweight of 2^(-N), which cancels out the previous term.\n\n\t\n\tTODO: \trender to framebuffer tex and rescale histogram to [0, 1] to better visualise e.g. Multifractal\n\n\tTODO: \tVLNoise3\n\t\t\tHetero_Terrain\n\t\t\tHybridMultifractal\n\t\t\tRidgedMultifractal\n            \n    TODO:   irregular noise in 3D\n    \n    TODO:   Beta function for arbitrary order interpolation\n\n    TODO:   Toroidal wrapping noise\n    \n    TODO:   Use extra parameter for irregular zeros, not a naive offset\n    \n    TODO:   irregular zeros noise should use rotated lattice to help eliminate directional artifacts\n    \n    TODO:   calculate proper min/max range for irregular zeros noise\n*/\n\n\n/*\n\tType 0 - Classic Perlin\n\tType 1 - Turbulence\n\tType 2 - Inverted Turbulence\n\tType 3 - Worley\n\tType 4 - Multifractal (NB: this function tends to the value 1/2 VERY fast as octaves increase)\n\t5 - heteroterrain\n\t6 - hybridmulti\n\t7 - ridgedmulti\n*/\n\n#define G_VISUALISE_ZEROS           0       // 0 for normal render, 1 to visualise zeros with lattice points marked\n\n#define G_NOISE_TYPE\t\t\t\t1\n\n#define G_USE_NORMALISED_VORONOI\t0\t\t// 0 for classic Voronoi, 1 to use vectors picked on an N-dimensional sphere\n\n#define G_IS_NOISE_3D\t\t\t\t1\t\t// 0 for 2D noise, 1 for 3D\n\n#define G_IRREGULAR_ZEROS\t\t\t0\t\t// 0 for classic perlin with zeros at lattice points (depending on lacunarity), 1 for noise without deterministic zeros\n\n#define G_INTERPOLANT_C_ORDER\t\t2\t\t// 0 for linear, 1 for degree-3, 2 for degree-5\n\n#define G_INITIAL_SCALE\t\t\t\t16.0\t// linear scale of noise at octave zero\n\n#define G_OCTAVES\t\t\t\t\t8\t\t// total Perlin octaves, NB: artifacts at > ~16 on a GTX 1060\n\n#if G_INTERPOLANT_C_ORDER == 0\n#define PolyLerp\tPolyC0\n#define PolyLerpD\tPolyC0D\n\n#elif G_INTERPOLANT_C_ORDER == 1\n#define PolyLerp\tPolyC1\n#define PolyLerpD\tPolyC1D\n\n#else \n#define PolyLerp\tPolyC2\n#define PolyLerpD   PolyC2D\n#endif\n\n#if G_NOISE_TYPE == 1\n#define NoiseFunc2D Turbulence2D\n#define NoiseFunc3D Turbulence3D\n#elif G_NOISE_TYPE == 2\n#define NoiseFunc2D -Turbulence2D\n#define NoiseFunc3D -Turbulence3D\n#elif G_NOISE_TYPE == 3\n#define NoiseFunc2D Worley2D\n#define NoiseFunc3D Worley3D\n#elif G_NOISE_TYPE == 4\n#define NoiseFunc2D Multi2D\n#define NoiseFunc3D Multi3D\n#else\n#define NoiseFunc2D Perlin2D\n#define NoiseFunc3D Perlin3D\n#endif\n\nconst vec2 lattice_coords_2d[4] = vec2[4]\n(\n    vec2(0.0, 0.0), \n    vec2(1.0, 0.0),\n    vec2(0.0, 1.0), \n    vec2(1.0, 1.0)\n);\nconst vec3 lattice_coords_3d[8] = vec3[8]\n(\n    vec3(0.0, 0.0, 0.0), \n    vec3(1.0, 0.0, 0.0), \n    vec3(0.0, 1.0, 0.0), \n    vec3(1.0, 1.0, 0.0), \n    vec3(0.0, 0.0, 1.0), \n    vec3(1.0, 0.0, 1.0), \n    vec3(0.0, 1.0, 1.0), \n    vec3(1.0, 1.0, 1.0)\n);\n\nfloat Factorial(float x)\n{\n    float r = 1.0;\n    for(int i = 1; i <= int(x); i++)\n        r *= float(i);\n        \n    return r;\n}\nfloat Factorial(int x)\n{\n    float r = 1.0;\n    for(int i = 1; i <= x; i++)\n        r *= float(i);\n        \n    return r;\n}\n\n// TODO: make more efficient\nfloat BinomialC(float n, float k)\n{\n    // assume k <= n, k > 0\n    return Factorial(n) / (Factorial(k) * Factorial(n - k));\n}\n\n// TODO: make more efficient\nfloat BinomialC(int n, int k)\n{\n    // assume k <= n, k > 0\n    return Factorial(n) / (Factorial(k) * Factorial(n - k));\n}\n\n// Generalised order-n smoothstep\nfloat LerpFunction(int order, float t)\n{\n    t = clamp(t, 0.0, 1.0); // removes artifacts\n    float result = 0.0f;\n    int m = order;\n    for(int i = m; i <= 2*m - 1; i++)\n    {\n        result += BinomialC(2*m - 1, i) * pow(t, float(i)) * pow((1.0f - t), float(2*m - 1 - i));\n    }\n    return result;\n}\n\n/*\n// Returns binomial coefficient without explicit use of factorials,\n// which can't be used with negative integers\nfloat pascalTriangle(int a, int b) {\n  float result = 1.0; \n  for (int i = 0; i < b; ++i)\n    result *= float(a - i) / float(i + 1);\n  return result;\n}\n\nfloat LerpFunction(int N, float x) {\n\n  float result = 0.0;\n  for (int n = 0; n <= N; ++n)\n    result += pascalTriangle(-N - 1, n) *\n              pascalTriangle(2 * N + 1, N - n) *\n              pow(x, float(N + n + 1));\n  return result;\n}\n*/\n\n\n// Generate a 2D vector from a (2+1)D position\nvec2 RandVec2DFrom2DUnit(vec2 uv, float seed)\n{\n    float r = random(vec3(uv, seed))*3.141592653*2.0;\n    return vec2(sin(r), cos(r));\n}\n// Generate a 3D vector from a (3+1)D position\nvec3 RandVec3DFrom3DUnit(vec3 uvw, float seed)\n{\n    // http://mathworld.wolfram.com/SpherePointPicking.html\n    \n    float theta = random(vec5(float[5](uvw.x, uvw.y, uvw.z, seed, 0.0)))*3.141592653*2.0;\n    float u = random(vec5(float[5](uvw.x, uvw.y, uvw.z, seed, 1.0)))*2.0 - 1.0;\n    \n    return vec3(sqrt(1.0 - u*u)*sin(theta), sqrt(1.0 - u*u)*cos(theta), u);\n}\n\n// Generate a 2D vector from a (2+1)D position\nvec2 RandVec2DFrom2D(vec2 uv, float seed)\n{\n    float r0 = random(vec4(uv, seed, 0.0));\n    float r1 = random(vec4(uv, seed, 1.0));\n    return vec2(r0, r1);\n}\n// Generate a 3D vector from a (3+1)D position\nvec3 RandVec3DFrom3D(vec3 uvw, float seed)\n{\n    float r0 = random(vec5(float[5](uvw.x, uvw.y, uvw.z, seed, 0.0)));\n    float r1 = random(vec5(float[5](uvw.x, uvw.y, uvw.z, seed, 1.0)));\n    float r2 = random(vec5(float[5](uvw.x, uvw.y, uvw.z, seed, 2.0)));\n    return vec3(r0, r1, r2);\n}\n\n// C0 interpolant\nfloat PolyC0(float t)\n{\n    return LerpFunction(1, t);\n    //return t;\n}\n// C1 interpolant\nfloat PolyC1(float t)\n{\n    return LerpFunction(2, t);\n    //return t*t*(3.0 - 2.0*t);\n}\n// C2 interpolant\nfloat PolyC2(float t)\n{\n    return LerpFunction(3, t);\n    //return t*t*t*(6.0*t*t - 15.0*t + 10.0);\n}\n// C0 interpolant derivative\nfloat PolyC0D(float t)\n{\n    return 1.0;\n}\n// C1 interpolant derivative\nfloat PolyC1D(float t)\n{\n    return t*(6.0 - 6.0*t);\n}\n// C2 interpolant derivative\nfloat PolyC2D(float t)\n{\n    return t*t*(30.0*t*t - 60.0*t + 30.0);\n}\n\nvec2 PolyC0(vec2 t) {return vec2(PolyC0(t.x), PolyC0(t.y));}\nvec2 PolyC1(vec2 t) {return vec2(PolyC1(t.x), PolyC1(t.y));}\nvec2 PolyC2(vec2 t) {return vec2(PolyC2(t.x), PolyC2(t.y));}\nvec3 PolyC0(vec3 t) {return vec3(PolyC0(t.x), PolyC0(t.y), PolyC0(t.z));}\nvec3 PolyC1(vec3 t) {return vec3(PolyC1(t.x), PolyC1(t.y), PolyC1(t.z));}\nvec3 PolyC2(vec3 t) {return vec3(PolyC2(t.x), PolyC2(t.y), PolyC2(t.z));}\nvec2 PolyC0D(vec2 t) {return vec2(PolyC0D(t.x), PolyC0D(t.y));}\nvec2 PolyC1D(vec2 t) {return vec2(PolyC1D(t.x), PolyC1D(t.y));}\nvec2 PolyC2D(vec2 t) {return vec2(PolyC2D(t.x), PolyC2D(t.y));}\n\n// Interpolation between 4 scalars\nfloat Mix2D(vec2 uv, float p00, float p10, float p01, float p11)\n{\n    p00 = mix(p00, p10, uv.x);\n    p10 = mix(p01, p11, uv.x);\n    return mix(p00, p10, uv.y);\n}\n// Interpolation between 8 scalars\nfloat Mix3D(vec3 uvw, float p000, float p100, float p010, float p110, float p001, float p101, float p011, float p111)\n{\n    p000 = Mix2D(uvw.xy, p000, p100, p010, p110);\n    p001 = Mix2D(uvw.xy, p001, p101, p011, p111);\n    return mix(p000, p001, uvw.z);\n}\nvec3 Voronoi2DOctave(vec2 uv_int, vec2 uv_fract, float octave);\nfloat Perlin2DOctave(vec2 uv_int, vec2 uv_fract, float octave)\n{\n    vec4 grad;\n    \n    // Get direction vectors and gradients at 4 lattice points\n    for (int i = 0; i < 4; i++)\n    {\n        vec2 dir = RandVec2DFrom2DUnit(uv_int + lattice_coords_2d[i], octave);\n        grad[i] = dot(uv_fract - lattice_coords_2d[i], dir);\n    }\n    \n    // Convert the inter-lattice position to interpolation weights\n    uv_fract = PolyLerp(uv_fract);\n    \n    // Interpolate between 4 gradients\n    \n    return Mix2D(uv_fract, grad[0], grad[1], grad[2], grad[3]);\n    \n    // radial weight function\n    vec4 lfact;\n    vec4 ldist;\n    \n    for (int i = 0; i < 4; i++)\n    {\n    \tvec2 dir = uv_fract - lattice_coords_2d[i];\n        ldist[i] = sqrt(dot(dir, dir));\n    }\n    \n    lfact = cos(clamp(ldist, -1.0, 1.0) * 3.141592653 * 0.5);\n    lfact *= lfact;\n    \n    return dot(grad, lfact);\n}\n\nvec2 Perlin2DOctaveDeriv(vec2 uv_int, vec2 uv_fract, float octave)\n{\n    float grad[4];\n    vec2 S[4];\n    float c[4];\n    vec2 dir[4];\n\n    // Get direction vectors and gradients at 4 lattice points\n    for (int i = 0; i < 4; i++)\n        dir[i] = RandVec2DFrom2DUnit(uv_int + lattice_coords_2d[i], octave);\n    \n    S[0] = dir[0];\n    S[1] = dir[1] - dir[0];\n    S[2] = dir[2] - dir[0];\n    S[3] = (dir[3] - dir[2]) - (dir[1] - dir[0]);\n    \n    c[0] = 0.0;\n    c[1] = -dir[1].x;\n    c[2] = -dir[2].y;\n    c[3] = (dir[2].y - dir[3].x) + (dir[1].x - dir[3].y);\n    \n    // Convert the inter-lattice position to interpolation weights\n    \n    vec2 l = PolyLerp(uv_fract);\n    vec2 lD = PolyLerpD(uv_fract);\n    float u = uv_fract.x;\n    float v = uv_fract.y;\n    \n    // df/dx, df/dy\n    \n    float dx = \n        S[0].x + \n        (lD.x*u + l.x)*S[1].x + \n        lD.x * v * S[1].y +\n        l.y * S[2].x +\n        (lD.x * u + l.x) * l.y * S[3].x +\n        lD.x * l.y * v * S[3].y +\n        lD.x * c[1] +\n        lD.x * l.y * c[3];\n\n    float dy = \n        S[0].y + \n        l.x * S[1].y + \n        lD.y * u * S[2].x +\n        (lD.y * v + l.y) * S[2].y +\n        l.x * lD.y * u * S[3].x +\n        (lD.y * v + l.y) * l.x * S[3].y +\n        lD.y * c[2] +\n        lD.y * l.x * c[3];\n    \n    return vec2(dx, dy);\n}\n\n\nfloat Perlin3DOctave(vec3 uv_int, vec3 uv_fract, float octave)\n{\n    float grad[8];\n\n    // Get direction vectors and gradients at 8 lattice points\n    for (int i = 0; i < 8; i++)\n    {\n        vec3 dir = RandVec3DFrom3DUnit(uv_int + lattice_coords_3d[i], octave);\n        grad[i] = dot(uv_fract - lattice_coords_3d[i], dir);\n    }\n    \n    // Convert the inter-lattice position to interpolation weights\n    uv_fract = PolyLerp(uv_fract);\n    \n    // Interpolate between 8 gradients\n    return Mix3D(uv_fract, grad[0], grad[1], grad[2], grad[3], grad[4], grad[5], grad[6], grad[7]);\n}\n\n// Limit of 1 + r + r^2 + ... + r^(n-1)\nfloat GeometricLimit(float r, float n)\n{\n\treturn (1.0 - pow(r, n)) / (1.0 - r);\n}\n\nfloat Perlin2D(vec2 uv, int octaves, float persistence, float lacunarity)\n{\n\tint i;\n    float sum = 0.0;\n    // Maximum possible value is the geometric sum of persistence\n    float scale = GeometricLimit(persistence, float(octaves));\n    \n    for (i = 0; i < octaves; i++)\n    {\n        // Scale uv's by lacunarity^i\n        vec2 uvn = uv * pow(lacunarity, float(i));\n        \n        // Add noise to sum, scaled by persistence^i\n        sum += pow(persistence, float(i)) * Perlin2DOctave(floor(uvn), uvn - floor(uvn), float(i));\n    }\n    \n    // Range of a single octave of 2D Perlin Noise is [-1/sqrt(2), 1/sqrt(2)], scale to [-1,1]\n    sum *= sqrt(2.0);\n    \n    return (sum / scale);\n}\n\nfloat Perlin3D(vec3 uvw, int octaves, float persistence, float lacunarity)\n{\n\tint i;\n    float sum = 0.0;\n    // Maximum possible value is the geometric sum of persistence\n    float scale = GeometricLimit(persistence, float(octaves));\n    \n    for (i = 0; i < octaves; i++)\n    {\n        // Scale uv's by lacunarity^i\n        vec3 uvwn = uvw * pow(lacunarity, float(i));\n        \n        // Add noise to sum, scaled by persistence^i\n        sum += pow(persistence, float(i)) * Perlin3DOctave(floor(uvwn), uvwn - floor(uvwn), float(i));\n    }\n    \n    // Range of a single octave of 3D Perlin Noise is [-sqrt(3)/2, sqrt(3)/2], scale to [-1,1]\n    sum *= 2.0 / sqrt(3.0);\n    \n    return (sum / scale);\n}\n\nvec2 Perlin2DDeriv(vec2 uv, int octaves, float persistence, float lacunarity)\n{\n\tint i;\n    vec2 sum = vec2(0.0);\n    // Maximum possible value is the geometric sum of persistence\n    float scale = GeometricLimit(persistence, float(octaves));\n    \n    for (i = 0; i < octaves; i++)\n    {\n        // Scale uv's by lacunarity^i\n        vec2 uvn = uv * pow(lacunarity, float(i));\n        \n        // Add noise to sum, scaled by persistence^i\n        sum += pow(persistence, float(i)) * Perlin2DOctaveDeriv(floor(uvn), uvn - floor(uvn), float(i));\n    }\n    \n    // Range of a single octave of 2D Perlin Noise is [-1/sqrt(2), 1/sqrt(2)], scale to [-1,1]\n    sum *= sqrt(2.0);\n    \n    return (sum / scale);\n}\n\nfloat Turbulence2D(vec2 uv, int octaves, float persistence, float lacunarity)\n{\n\tint i;\n    float sum = 0.0;\n    float scale = GeometricLimit(persistence, float(octaves));\n    \n    for (i = 0; i < octaves; i++)\n    {\n        vec2 uvn = uv * pow(lacunarity, float(i));\n        \n        // Same as classic Perlin, but using the absolute value of the noise octave\n        sum += abs(pow(persistence, float(i)) * Perlin2DOctave(floor(uvn), uvn - floor(uvn), float(i)));\n    }\n    \n    sum *= sqrt(2.0);\n\n    // Turbulence is in range [0, x], scale to [-1, 1]\n    return (sum / scale) * 2.0 - 1.0;\n}\n\nfloat Turbulence3D(vec3 uvw, int octaves, float persistence, float lacunarity)\n{\n\tint i;\n    float sum = 0.0;\n    float scale = GeometricLimit(persistence, float(octaves));\n    \n    for (i = 0; i < octaves; i++)\n    {\n        vec3 uvwn = uvw * pow(lacunarity, float(i));\n        \n        // Same as classic Perlin, but using the absolute value of the noise octave\n        sum += abs(pow(persistence, float(i)) * Perlin3DOctave(floor(uvwn), uvwn - floor(uvwn), float(i)));\n    }\n    \n    sum *= 2.0 / sqrt(3.0);\n    \n    // Turbulence is in range [0, x], scale to [-1, 1]\n    return (sum / scale) * 2.0 - 1.0;\n}\n\nvec3 Voronoi2DOctave(vec2 uv_int, vec2 uv_fract, float octave)\n{\n    float mindist = 9999.0;\n    vec2 minpos;\n    vec2 uv = uv_int + uv_fract;\n\n    // NB: actual shape of area is (integer) circular: contains 21 rather than 25 cells\n    // TODO: there's a cleverer way to do this that only requires checking 12-16 cells\n    for (int y = -2; y <= 3; y++)\n        for (int x = -2; x <= 3; x++)\n        {\n            // lower-left lattice point\n            vec2 ll_pos = uv_int + vec2(float(x), float(y));\n            // lattice point \"real\" position\n#if G_USE_NORMALISED_VORONOI == 0                \n            vec2 offset = RandVec2DFrom2D(ll_pos, octave);\n#else\n            vec2 offset = RandVec2DFrom2DUnit(ll_pos, octave);\n#endif\n            // square of distance from lattice point to render position\n            float d = dot(ll_pos + offset - uv , ll_pos + offset - uv);\n            \n            if (d < mindist)\n            {\n                mindist = d;\n                minpos = ll_pos;\n            }\n        }\n    \n\t// Return the (normalized) square of the distance, as well as which lattice \n    // point it corresponds to.\n    // In 2D, the maximum possible distance to a lattice point is sqrt(2).\n    return vec3(mindist * 0.5, minpos);\n}\nvec4 Voronoi3DOctave(vec3 uvw_int, vec3 uvw_fract, float octave)\n{\n    float mindist = 9999.0;\n    vec3 minpos;\n    vec3 uvw = uvw_int + uvw_fract;\n\n    // TODO: this range is an over-estimate, check actual range\n    for (int z = -3; z <= 3; z++)\n        for (int y = -3; y <= 3; y++)\n        \tfor (int x = -3; x <= 3; x++)\n            {\n                // lower-left lattice point\n                vec3 ll_pos = uvw_int + vec3(float(x), float(y), float(z));\n                // lattice point \"real\" position\n#if G_USE_NORMALISED_VORONOI == 0                \n                vec3 offset = RandVec3DFrom3D(ll_pos, octave);\n#else\n                vec3 offset = RandVec3DFrom3DUnit(ll_pos, octave);\n#endif\n                // square of distance from lattice point to render position\n                float d = dot(ll_pos + offset - uvw , ll_pos + offset - uvw);\n\n                if (d < mindist)\n                {\n                    mindist = d;\n                    minpos = ll_pos;\n                }\n            }\n    \n\t// Return the (normalized) square of the distance, as well as which lattice \n    // point it corresponds to.\n    // In 3D, the maximum possible distance to a lattice point is sqrt(2).\n    return vec4(mindist / 3.0, minpos);\n}\n\nfloat Worley2D(vec2 uv, int octaves, float persistence, float lacunarity)\n{\n\tint i;\n    float sum = 0.0;\n    float scale = GeometricLimit(persistence, float(octaves));\n    \n    for (i = 0; i < octaves; i++)\n    {\n        vec2 uvn = uv * pow(lacunarity, float(i));\n        \n        sum += pow(persistence, float(i)) * Voronoi2DOctave(floor(uvn), uvn - floor(uvn), float(i)).x;\n    }\n    \n    // Voronoi is in range [0, x], scale to [-1, 1]\n    return (sum / scale) * 2.0 - 1.0;\n}\n\nfloat Worley3D(vec3 uvw, int octaves, float persistence, float lacunarity)\n{\n\tint i;\n    float sum = 0.0;\n    float scale = GeometricLimit(persistence, float(octaves));\n    \n    for (i = 0; i < octaves; i++)\n    {\n        vec3 uvwn = uvw * pow(lacunarity, float(i));\n        \n        sum += pow(persistence, float(i)) * Voronoi3DOctave(floor(uvwn), uvwn - floor(uvwn), float(i)).x;\n    }\n    \n    // Voronoi is in range [0, x], scale to [-1, 1]\n    return (sum / scale) * 2.0 - 1.0;\n}\n\nfloat Multi2D(vec2 uv, int octaves, float persistence, float lacunarity)\n{\n\tint i;\n    float sum = 1.0;\n    \n    for (i = 0; i < octaves; i++)\n    {\n        vec2 uvn = uv * pow(lacunarity, float(i));\n        sum *= 1.0 - pow(persistence, float(i)) * abs(Perlin2DOctave(floor(uvn), uvn - floor(uvn), float(i)));\n    }\n\n    return sum * 2.0 - 1.0;\n}\n\nfloat Multi3D(vec3 uvw, int octaves, float persistence, float lacunarity)\n{\n\tint i;\n    float sum = 1.0;\n    \n    for (i = 0; i < octaves; i++)\n    {\n        vec3 uvwn = uvw * pow(lacunarity, float(i));\n        sum *= 1.0 - pow(persistence, float(i)) * abs(Perlin3DOctave(floor(uvwn), uvwn - floor(uvwn), float(i)));\n        //sum *= 1.0 - pow(persistence, pow(lacunarity, float(i))) * abs(Perlin3DOctave(floor(uvwn), uvwn - floor(uvwn), float(i)));\n    }\n    \n    return sum * 2.0 - 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n    float result;\n    float persistence = 0.01 + (iMouse.x / iResolution.x) * 0.99;\n    float lacunarity = 1.0 + iMouse.y / iResolution.y;\n    \n    result = NoiseFunc2D(uv*G_INITIAL_SCALE, G_OCTAVES, persistence, lacunarity);\n    result = (result + 1.0) * 0.5;\n    \n    fragColor = vec4(result);\n\n#if G_IS_NOISE_3D == 0\n    \n    result = NoiseFunc2D(uv*G_INITIAL_SCALE, G_OCTAVES, persistence, lacunarity);\n    \n#if G_IRREGULAR_ZEROS != 0\n    result += NoiseFunc2D(uv*G_INITIAL_SCALE + vec2(0.5) + vec2(47.0, 37.0), G_OCTAVES, persistence, lacunarity);\n    \n    result /= sqrt(2.0);\n#endif\n    \n#else    \n    \n    result = NoiseFunc3D(vec3(uv*G_INITIAL_SCALE, sin(iTime)*2.0), G_OCTAVES, persistence, lacunarity);\n\n#endif\n \n    // Noise has range [-1, 1], scale to [0, 1] for render\n    result = (result + 1.0) * 0.5;\n    \n    fragColor = vec4(result);\n    \n#if G_VISUALISE_ZEROS != 0\n    if (uv.x < 0.5)\n    {\n        vec2 deriv;\n        vec2 sderiv;\n        vec2 uvderiv = vec2(dFdx(uv*G_INITIAL_SCALE).x, dFdy(uv*G_INITIAL_SCALE).y);\n        float csign;\n        vec2 lsign;\n        vec2 rsign;\n        \n        deriv = vec2(dFdx(result), dFdy(result));\n        sderiv = deriv*uvderiv;\n        \n        if (result < 0.5)\n            csign = -1.0;\n        if (result >= 0.5)\n            csign = 1.0;\n            \n        lsign = vec2((result - deriv.x - 0.5) < 0.0 ? -1.0 : 1.0, (result - deriv.y - 0.5 < 0.0) ? -1.0 : 1.0);\n        rsign = vec2((result + deriv.x - 0.5) < 0.0 ? -1.0 : 1.0, (result + deriv.y - 0.5 < 0.0) ? -1.0 : 1.0);\n        \n        if ((csign != lsign.x) || (csign != lsign.y) || (csign != rsign.x) || (csign != rsign.y))\n            fragColor = vec4(1.0, 0.0, 0.0, 0.0);\n        \n        \n        vec2 pos = mod(uv*G_INITIAL_SCALE + uvderiv, vec2(1.0));\n        \n        if ((pos.x <= 4.0*uvderiv.x) && (pos.y <= 4.0*uvderiv.y))\n            fragColor = vec4(0.0, 0.0, 1.0, 0.0);\n        \n    }\n#endif\n    // testing stuff\n    if (1== 0)\n    {\n    \tvec2 res = Perlin2DOctaveDeriv(floor(uv*G_INITIAL_SCALE), uv*G_INITIAL_SCALE - floor(uv*G_INITIAL_SCALE), 0.0);\n        res = Perlin2DDeriv(uv*G_INITIAL_SCALE, G_OCTAVES, persistence, lacunarity);\n\n        vec3 tang = vec3(1.0, res.x, 0.0);\n        vec3 bitang = vec3(0.0, res.y, 1.0);\n        vec3 norm = normalize(cross(-tang, bitang));\n        \n        res = normalize(res);\n    \tfragColor = vec4(res.xy * sqrt(2.0)*0.5 + 0.5, 0.0, 0.0);    \n        fragColor = vec4(res.xy*0.5 + 0.5, 0.0, 0.0);    \n        \n        fragColor = vec4(norm.xzy*0.5 + 0.5, 0.0);    \n        \n        float res2 = Perlin2DOctave(floor(uv*G_INITIAL_SCALE), uv*G_INITIAL_SCALE - floor(uv*G_INITIAL_SCALE), 0.0);\n       // fragColor = vec4(res2 * sqrt(2.0)*0.5 + 0.5);    \n    }\n     //fragColor = vec4(random(uv));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\nUncomment \"#define HQ_HASH\" to use high quality hashing function, adapted from XXHash:\n\nhttps://github.com/Cyan4973/xxHash\n\n\n\nComment out \"#define HQ_HASH\" for low quality hash function originally from:\n\nhttps://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n\n*/\n\n#define HQ_HASH\n\n/*\n\nUncomment \"#define HQ_FLOAT_RNG\" to use high precision float generation, uses every representable value between [0, 1), including subnormals\ncalls hash function up to 5 times, average number of calls is 2\n\nComment out \"#define HQ_FLOAT_RNG\" to use low precision float generation, using [1, 2) - 1 trick\n\n*/\n\n#define HQ_FLOAT_RNG\n\nstruct vec5\n{\n\tfloat v[5];\n};\nstruct uvec5\n{\n\tuint v[5];\n};\n\nuvec5 touvec5(uvec4 x) { uvec5 x5;    x5.v[0] = x.x;    x5.v[1] = x.y;    x5.v[2] = x.z;    x5.v[3] = x.w;    x5.v[4] = uint(0);    return x5;}\nuvec5 touvec5(uvec3 x) { uvec5 x5;    x5.v[0] = x.x;    x5.v[1] = x.y;    x5.v[2] = x.z;    x5.v[3] = uint(0);x5.v[4] = uint(0);    return x5;}\nuvec5 touvec5(uvec2 x) { uvec5 x5;    x5.v[0] = x.x;    x5.v[1] = x.y;    x5.v[2] = uint(0);x5.v[3] = uint(0);x5.v[4] = uint(0);    return x5;}\nuvec5 touvec5(uint  x) { uvec5 x5;    x5.v[0] = x;      x5.v[1] = uint(0);x5.v[2] = uint(0);x5.v[3] = uint(0);x5.v[4] = uint(0);    return x5;}\n\n\n#ifndef HQ_HASH    // Use low quality hash\n\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\nuint hash( uvec5 v ) { return hash( v.v[0] ^ hash(v.v[1]) ^ hash(v.v[2]) ^ hash(v.v[3]) ^ hash(v.v[4])); }\n\nuint hash(uvec5 v, uint seed) { return hash( v.v[0] ^ hash(v.v[1]) ^ hash(v.v[2]) ^ hash(v.v[3]) ^ hash(v.v[4]) ^ hash(seed)); }\nuint hash(uvec4 v, uint seed) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ^ hash(seed)); }\nuint hash(uvec3 v, uint seed) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(seed) ); }\nuint hash(uvec2 v, uint seed) { return hash( v.x ^ hash(v.y) ^ hash(seed)             ); }\nuint hash(uint v, uint seed)  { return hash( v ^ hash(seed)                         ); }\n\n#else    // Use high quality hash\n\n#define PRIME32_1\t2654435761U\n#define PRIME32_2\t2246822519U\n#define PRIME32_3\t3266489917U\n#define PRIME32_4\t668265263U\n#define PRIME32_5\t374761393U\n\nuint rotl32(uint x, int shift)\n{\n\treturn (x << shift) | (x >> (32 - shift));\n}\nvoid XXH32_InitV(inout uint v[4], uint seed)\n{\n    v[0] = seed + PRIME32_1 + PRIME32_2;\n    v[1] = seed + PRIME32_2;\n    v[2] = seed + uint(0);\n    v[3] = seed - PRIME32_1;\n}\nvoid XXH32_Inner(const uint p[4], inout uint v[4])\n{\n    v[0] += p[0] * PRIME32_2;\n    v[0] = rotl32(v[0], 13);\n    v[0] *= PRIME32_1;\n\n    v[1] += p[1] * PRIME32_2;\n    v[1] = rotl32(v[1], 13);\n    v[1] *= PRIME32_1;\n\n    v[2] += p[2] * PRIME32_2;\n    v[2] = rotl32(v[2], 13);\n    v[2] *= PRIME32_1;\n\n    v[3] += p[3] * PRIME32_2;\n    v[3] = rotl32(v[3], 13);\n    v[3] *= PRIME32_1;\n}\n\nuint XXHash32_32(uint input_s[8])\n{\n    uint h32;\n\tuint v[4];\n\n\tXXH32_InitV(v, uint(0));\n\n\tXXH32_Inner(uint[4](input_s[0], input_s[1], input_s[2], input_s[3]), v);\n    XXH32_Inner(uint[4](input_s[4], input_s[5], input_s[6], input_s[7]), v);\n\n    h32 = rotl32(v[0], 1) + rotl32(v[1], 7) + rotl32(v[2], 12) + rotl32(v[3], 18);\n\n    h32 += uint(32);\n\n    h32 ^= h32 >> 15;\n    h32 *= PRIME32_2;\n    h32 ^= h32 >> 13;\n    h32 *= PRIME32_3;\n    h32 ^= h32 >> 16;\n\n    return h32;\n}\n\nuint hash(uvec5 x, uint seed) \n{\n    uint inputs[8] = uint[8](x.v[0], x.v[1], x.v[2], x.v[3], x.v[4], uint(0), uint(0), uint(seed));\n    \n    return XXHash32_32(inputs);\n}\nuint hash(uvec4 x, uint seed) { return hash(touvec5(x), seed);}\nuint hash(uvec3 x, uint seed) { return hash(touvec5(x), seed);}\nuint hash(uvec2 x, uint seed) { return hash(touvec5(x), seed);}\nuint hash(uint x, uint seed)  { return hash(touvec5(x), seed);}\nuint hash(uvec5 x) \n{\n    uint inputs[8] = uint[8](x.v[0], x.v[1], x.v[2], x.v[3], x.v[4], uint(0), uint(0), uint(0));\n    \n    return XXHash32_32(inputs);\n}\nuint hash(uvec4 x) { return hash(touvec5(x));}\nuint hash(uvec3 x) { return hash(touvec5(x));}\nuint hash(uvec2 x) { return hash(touvec5(x));}\nuint hash(uint x)  { return hash(touvec5(x));}\n\n\n#endif\n\n#ifndef HQ_FLOAT_RNG // Use low precision float generation\n\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\nfloat random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec5  v ) \n{ \n    return floatConstruct(\n        hash(\n            uvec5(uint[5](\n                floatBitsToUint(v.v[0]),\n                floatBitsToUint(v.v[1]),\n                floatBitsToUint(v.v[2]),\n                floatBitsToUint(v.v[3]),\n                floatBitsToUint(v.v[4])\n                ))\n            )\n        );\n}\n#else\n\nuint lzcnt(uint x)\n{\n    x |= x >> 1;\n    x |= x >> 2;\n    x |= x >> 4;\n    x |= x >> 8;\n    x |= x >> 16;\n    \n    uint c;\n    \n    x = x - ((x >> 1) & uint(0x55555555));                    \n    x = (x & uint(0x33333333)) + ((x >> 2) & uint(0x33333333));\n    c = ((x + (x >> 4) & uint(0xF0F0F0F)) * uint(0x1010101)) >> 24;\n\n    return uint(32) - c;\n}\n\nfloat floatrandhq(uvec5 x) \n{\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint mantissabits = uint(23);\n    const uint exponentbits = uint(8);\n    const uint hashbits     = uint(32);\n    const uint hashbitslg2  = uint(5);\n    uint current;\n    uint cnt;\n    uint pw2;    \n    // ceil((2^(ebits - 1) - 2) / 2^hashbits)\n    uint maxrec = (uint(1 << (exponentbits - uint(1))) - uint(2) + hashbits - uint(1)) >> hashbitslg2;\n    uint m;\n    uint i;\n    \n    current = hash(x, uint(0));\n    cnt = lzcnt(current);\n    pw2 = cnt;\n\n    for (i = uint(1); (i < maxrec) && (cnt == hashbits); i++)\n    {\n        current = hash(x,i +  uint(1));\n        cnt = lzcnt(current);\n        pw2 += cnt;\n    }\n    \n    // if less than 23 bits left, we need to generate a new hash to fill the mantissa\n    if ((int(hashbits) - int(cnt) - 1) < int(mantissabits))\n        current = hash(x, i +  uint(1));\n    \n    if (pw2 < uint(1 << (exponentbits - uint(1))) - uint(2))\n        m = (uint(1 << (exponentbits - uint(1))) - uint(2) - pw2) << mantissabits;\n    else // subnormal\n        m = uint(0);\n        \n    m |= ieeeMantissa & current;\n    \n\n    return uintBitsToFloat( m );\n}\n\nfloat random( float x ) { return floatrandhq(touvec5(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatrandhq(touvec5(floatBitsToUint(v))); }\nfloat random( vec3  v ) { return floatrandhq(touvec5(floatBitsToUint(v))); }\nfloat random( vec4  v ) { return floatrandhq(touvec5(floatBitsToUint(v))); }\nfloat random( vec5  v ) \n{ \n    return floatrandhq(\n            uvec5(uint[5](\n                floatBitsToUint(v.v[0]),\n                floatBitsToUint(v.v[1]),\n                floatBitsToUint(v.v[2]),\n                floatBitsToUint(v.v[3]),\n                floatBitsToUint(v.v[4])\n                ))\n        );\n}\n\n#endif\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}