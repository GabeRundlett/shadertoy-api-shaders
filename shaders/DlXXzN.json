{
    "Shader": {
        "info": {
            "date": "1674350269",
            "description": "A (rather) cheap planet on a starry sky",
            "flags": 0,
            "hasliked": 0,
            "id": "DlXXzN",
            "likes": 6,
            "name": "Planet in starry sky",
            "published": 3,
            "tags": [
                "planet",
                "starfield"
            ],
            "usePreview": 0,
            "username": "ManuManu",
            "viewed": 254
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265359\n\nmat2 Rot(float angle) {\n    float s=sin(angle);\n    float c=cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nfloat hash21( vec2 p )\n{\n    p = fract( p*vec2( 789.123, 456.987));\n    p += dot( p, p + vec2(12.34));\n    return fract( p.x*p.y);\n}\n\nfloat circle( vec2 pos, vec2 center, float radius, float width, float smooth_width)\n{\n    float l = length(pos-center);\n\n    float low_val = width*.5 - smooth_width;\n    float high_val = width*.5;\n    float tore = smoothstep( high_val, low_val, abs( l - radius));\n    return tore;\n}\n\nfloat dirty_circle( vec2 pos, vec2 center, float radius, float width, float smooth_width)\n{\n    float rand_val = hash21(pos);\n    pos = pos + vec2( rand_val, fract(rand_val * 11.)) * 0.01;\n    return circle (pos, center, radius, width, smooth_width);\n}\nvec3 planet_text( vec2 uv )\n{\n    float nb_circles = 5.;\n    float val = 0.;\n\n    //vec3 col = vec3(1.,.5,.5)*.28; // Redish planet\n    //vec3 col = vec3(0.1,.3,.6)*.28;  // bluesish planet\n    vec3 col = vec3(.2,.6,.4)*.28;   // greenish planet\n    \n    for( float i = 0.001; i < nb_circles; i+= 1.)\n    {\n        float rand_val = hash21( vec2(i, i*.123));\n        float rand_val1 = fract( rand_val * 13.);\n        float rand_val2 = fract( rand_val * 53.);\n        float rand_val3 = fract( rand_val * 111.);\n        vec2 center = vec2( rand_val -.5, rand_val1 -.5);\n        center.x *= 1.7;\n        float radius = .3- ( rand_val2 -.5) * 0.3;\n        float width = .2- ( rand_val3 -.5) * 0.05;\n        float tore = dirty_circle( uv, center, radius, width, 0.1);\n        //float tore = circle( uv, center, radius, width, 0.1);\n        \n        val = max(tore, val );\n    }\n    nb_circles = 40.;\n    for( float i = 0.00001; i < nb_circles; i+= 1.)\n    {\n        float rand_val = hash21( vec2(i*.321, i*.456));\n        float rand_val1 = fract( rand_val * 13.);\n        float rand_val2 = fract( rand_val * 53.);\n        float rand_val3 = fract( rand_val * 111.);\n        vec2 center = vec2( rand_val -.5, rand_val1 -.5);\n        center.x *= 1.7;\n        center.y *= 2.1;\n        float radius = .1- ( rand_val2 -.5) * 0.1;\n        float width = .1- ( rand_val3 -.5) * 0.2;\n        float tore = dirty_circle( uv, center, radius, width, 0.1);\n        //float tore = circle( uv, center, radius, width, 0.1);\n        \n        val = max(tore, val );\n    }\n    \n    return vec3(val)+col;\n}\n\nvec3 planet( vec2 uv, vec3 local_y, vec3 local_z )\n{\n    vec3 local_x = cross( local_y, local_z);\n\n\n    float dist_from_center = length(uv);\n    float dist_from_circle_plane = sqrt( 1. - dist_from_center * dist_from_center );\n    \n    \n    vec3 pos_on_sphere = vec3( uv.x, uv.y, dist_from_circle_plane);\n    vec2 proj_on_equator_plane = vec2( dot( pos_on_sphere, local_x), dot( pos_on_sphere, local_z) );\n    float long_angle = atan( proj_on_equator_plane.y, proj_on_equator_plane.x );\n    \n    vec3 proj_eq_plane = dot( pos_on_sphere, local_x) * local_x + dot( pos_on_sphere, local_z) * local_z;\n    float lat_angle= atan( dot( pos_on_sphere, local_y), dot( pos_on_sphere, proj_eq_plane ) );\n    \n    vec2 text_uv = vec2( (long_angle+PI)/(2.*PI), ( lat_angle + PI/2.)/PI);\n    text_uv = 2.*text_uv -1.;\n    \n    vec3 col = vec3(0.);\n    \n    const float nb_div = 6.;\n    float inc = 2. * PI / nb_div;\n    for ( float i = 0.;  i < 2.*PI; i+= inc)\n    {\n        float moved_ux = fract( (text_uv.x + i)*.5 + .5 ) *2. - 1.;\n        vec2 cur_uv= vec2(moved_ux, text_uv.y);\n        col += planet_text( cur_uv );\n    }\n    \n    const float nb_div2 = 3.;\n    inc = 2. * PI / nb_div2;\n    float wind = .02*iTime + sin(iTime*.1) * .09;\n    for ( float i = 0.;  i < 2.*PI; i+= inc)\n    {\n        float moved_ux = fract( (0.456 + text_uv.x + i + wind*i)*.5 + .5 ) *2. - 1.;\n        vec2 cur_uv= vec2(moved_ux, text_uv.y);\n        col += planet_text( cur_uv );\n    }\n    return col/(nb_div + nb_div2) ;\n}\n\nvec3 add_planet( vec2 uv )\n{\n    vec3 col = vec3(0.2);\n    \n    // quasi up vect :\n    //vec3 axis = vec3 ( sin(iTime) * 0.3, 1.0, cos(iTime*2.));\n    vec3 axis = vec3 ( 0.3, 1.0, 0.);\n    axis = normalize(axis);\n    \n    vec3 right_vect = vec3(1.,0.,0.);\n    float rotation_speed = 0.35;\n    float angle = mod( iTime * rotation_speed, 2.*PI);\n    //float angle = 0.;\n    right_vect = vec3(cos(angle),0.,sin(angle));\n    \n    \n    vec3 dir = normalize( cross( right_vect, axis ));\n    \n    col = planet(uv, axis, dir);\n    return col;\n}\n\n\nfloat star(vec2 uv, float flare)\n{\n    float d = length(uv);\n    float col = 0.;\n    //col = .001/d/d;\n    col = .01/d;\n    \n    col += max(0., 1.-abs(uv.x * uv.y) * 2000.) * flare;\n    uv = Rot(3.14/4.) * uv;\n    col += max(0.,1.-abs(uv.x * uv.y) * 2000.) * .4 * flare;\n    \n    col *= smoothstep(.5, .3, d);\n    return col;\n}\n\nvec3 starfield( vec2 uv, float flare, vec3 color1, vec3 color2 )\n{\n    vec2 gv = fract(uv)-.5;\n    vec2 n = floor(uv);\n    float flare_effect = flare*1./5.;\n            \n    vec3 col = vec3(0.);\n    for( int i = -1; i<=1; i++)\n        for( int j = -1; j<=1; j++)\n        {\n            vec2 offset = vec2( i,j );\n            float rand_val = hash21(n+offset);\n            float flare_rand = flare * ( fract( rand_val * 789.) *.5 +.5);\n            float starcol = star(gv - offset  + vec2(rand_val-.5, fract(rand_val*10.) -.5), flare_rand);\n            \n            // flickering :\n            float freq  = (fract(rand_val * 100.) + 3.) / 2.;\n            float phase = fract(rand_val * 1000.)*15.;\n            float power = fract(rand_val * 55.) * (1.-flare_effect) + flare_effect;\n            float sin_amplitude = ( 1.-power);\n            \n            starcol *= abs(sin( iTime *freq +phase ))* sin_amplitude + power + sin_amplitude/2.;\n            float colRand = fract( rand_val * 123456.);\n            col += starcol * mix(color1, color2, colRand) * fract(rand_val*111.);\n        }\n    \n    //if (gv.x > .48 ||gv.y > .48) col.r = 1.;\n    return col;\n}\n\nvec3 starry_sky( vec2 uv )\n{\n    vec3 col = vec3(0.,0.,0.1);\n\n    uv *= 12.;\n    col += starfield(uv, .1, vec3(.97,.95,.77), vec3(.97,.77,.22));\n    uv /= 2.;\n    uv = Rot(.5) * uv;\n    col += starfield(uv, .1, vec3(.65,.32,.60), vec3(.18,.50,.63));\n    uv /= 2.;\n    uv = Rot(1.) * uv;\n    col += starfield(uv, .4, vec3(.34,.09,.39), vec3(.18,.43,.52));\n    uv /= 2.;\n    uv += vec2(5.,10.);\n    uv = Rot(6.2) * uv;\n    col += starfield(uv, .4, vec3(.18,.43,.52), vec3(.08,.40,.51));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = starry_sky(uv);\n    uv *= 2.;\n    \n    const float planet_factor = .6;\n    if ( length(uv) < planet_factor )\n    {\n        col = add_planet(uv / planet_factor);\n    }   \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}