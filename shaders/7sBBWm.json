{
    "Shader": {
        "info": {
            "date": "1646406613",
            "description": "A 4d Menger Sponge, rotating in the xw plane.\nDrag the mouse to move around, Y axis is zoom, X axis is pan.\n\n",
            "flags": 0,
            "hasliked": 0,
            "id": "7sBBWm",
            "likes": 2,
            "name": "4d Menger Sponge",
            "published": 3,
            "tags": [
                "raymarching",
                "raymarch",
                "menger",
                "sponge"
            ],
            "usePreview": 1,
            "username": "lwswl",
            "viewed": 456
        },
        "renderpass": [
            {
                "code": "\n/**\n *  4D sponge\n *  \n *\n *\n**/\n\n#if HW_PERFORMANCE==1\n//uncomment this if you have a decent GPU. It improves the sponge s lot.\n//#define AA\n#endif\n//the max steps\n#define MAX_STEPS 65536\n//only used for computing normals\n#define near 0.000001\n#define far 100.\n#define COLOR_SPEED 0.1\n//this number defines the number of subdivisions in the menger cube when computed for light. When not computing lights, the number of subdivions is infinite, and is only not sampled when epsilon has been reached, which is set dynamically based on the distance of the ray to the cube after the first epsilon(for the non-menger) has been reached, and the screen resolution.\n#define MENGER_LIGHT_DENSITY 4.0\n#define lerp(a, b, k,) (a*(1.0-k)+b*k)\nvec3 hue(float t){\n    vec3 h=vec3(1,0,0);\n    if (t<0.333){\n        h.r=(0.333-t)*3.;\n        h.g=(t)*3.;\n        h.b=0.;\n        return h;\n    }\n    else if(t<0.667){\n        h.g=(0.667-t)*3.;\n        h.b=(t-0.333)*3.;\n        h.r=0.;\n    }\n    else{\n        h.b=(1.-t)*3.;\n        h.r=(t-0.667)*3.;\n        h.g=0.;\n    }\n    return h;\n}\nfloat cubeSDF(vec3 p,float f){\n    vec3 v = abs(p) - f;\n    return length(max(v,0.0)) + min(max(v.x,max(v.y,v.z)),0.0);\n    \n}\nfloat ScubeSDF(vec4 p,float f){\n    vec4 v = abs(p) - vec4(f);\n    return length(max(v,0.0)) + min(max(v.x,max(v.y,max(v.z,v.w))),0.0);\n    \n}\nfloat SmengerSDF(vec4 p, float limit){\n    float r=1.;\n    float II=0.;\n    vec4 o=vec4(0);\n    float d=0.0;\n    \n    float f;\n    \n    if(II==0.)d=ScubeSDF(p+o,r);\n    if (d>r)return d;//1.414213562=sqrt(2)\n    //equilateral triangle, sqrt(2^2-1^2)=sqrt(3)\n    //pyramid thing sqrt(sqrt(2^2-1^2)-1^2)=sqrt(2)\n    //whatin4d sqrt(sqrt(sqrt(2^2-1^2)-1^2)-1^2)=1?\n    \n    vec4 no=vec4(0);\n    \n    r/=3.;\n    while (d<r&&(II<limit||limit==0.)){\n        \n        d=far;\n        float r2=2.*r;\n        f=ScubeSDF(p+o+vec4(r2,r2,r2,0),r);if(f<d){d=f;no=o+vec4(r2,r2,r2,0);}\n        f=ScubeSDF(p+o+vec4(r2,r2,0,r2),r);if(f<d){d=f;no=o+vec4(r2,r2,0,r2);}\n        f=ScubeSDF(p+o+vec4(r2,0,r2,r2),r);if(f<d){d=f;no=o+vec4(r2,0,r2,r2);}\n        f=ScubeSDF(p+o+vec4(0,r2,r2,r2),r);if(f<d){d=f;no=o+vec4(0,r2,r2,r2);}\n\n        f=ScubeSDF(p+o+vec4(-r2,r2,r2,0),r);if(f<d){d=f;no=o+vec4(-r2,r2,r2,0);}\n        f=ScubeSDF(p+o+vec4(r2,-r2,r2,0),r);if(f<d){d=f;no=o+vec4(r2,-r2,r2,0);}\n        f=ScubeSDF(p+o+vec4(r2,r2,-r2,0),r);if(f<d){d=f;no=o+vec4(r2,r2,-r2,0);}\n        f=ScubeSDF(p+o+vec4(-r2,-r2,r2,0),r);if(f<d){d=f;no=o+vec4(-r2,-r2,r2,0);}\n        f=ScubeSDF(p+o+vec4(-r2,r2,-r2,0),r);if(f<d){d=f;no=o+vec4(-r2,r2,-r2,0);}\n        f=ScubeSDF(p+o+vec4(r2,-r2,-r2,0),r);if(f<d){d=f;no=o+vec4(r2,-r2,-r2,0);}\n        f=ScubeSDF(p+o+vec4(-r2,-r2,-r2,0),r);if(f<d){d=f;no=o+vec4(-r2,-r2,-r2,0);}\n        \n        f=ScubeSDF(p+o+vec4(-r2,r2,0,r2),r);if(f<d){d=f;no=o+vec4(-r2,r2,0,r2);}\n        f=ScubeSDF(p+o+vec4(r2,-r2,0,r2),r);if(f<d){d=f;no=o+vec4(r2,-r2,0,r2);}\n        f=ScubeSDF(p+o+vec4(r2,r2,0,-r2),r);if(f<d){d=f;no=o+vec4(r2,r2,0,-r2);}\n        f=ScubeSDF(p+o+vec4(-r2,-r2,0,r2),r);if(f<d){d=f;no=o+vec4(-r2,-r2,0,r2);}\n        f=ScubeSDF(p+o+vec4(-r2,r2,0,-r2),r);if(f<d){d=f;no=o+vec4(-r2,r2,0,-r2);}\n        f=ScubeSDF(p+o+vec4(r2,-r2,0,-r2),r);if(f<d){d=f;no=o+vec4(r2,-r2,0,-r2);}\n        f=ScubeSDF(p+o+vec4(-r2,-r2,0,-r2),r);if(f<d){d=f;no=o+vec4(-r2,-r2,0,-r2);}\n        \n        f=ScubeSDF(p+o+vec4(-r2,0,r2,r2),r);if(f<d){d=f;no=o+vec4(-r2,0,r2,r2);}\n        f=ScubeSDF(p+o+vec4(r2,0,-r2,r2),r);if(f<d){d=f;no=o+vec4(r2,0,-r2,r2);}\n        f=ScubeSDF(p+o+vec4(r2,0,r2,-r2),r);if(f<d){d=f;no=o+vec4(r2,0,r2,-r2);}\n        f=ScubeSDF(p+o+vec4(-r2,0,-r2,r2),r);if(f<d){d=f;no=o+vec4(-r2,0,-r2,r2);}\n        f=ScubeSDF(p+o+vec4(-r2,0,r2,-r2),r);if(f<d){d=f;no=o+vec4(-r2,0,r2,-r2);}\n        f=ScubeSDF(p+o+vec4(r2,0,-r2,-r2),r);if(f<d){d=f;no=o+vec4(r2,0,-r2,-r2);}\n        f=ScubeSDF(p+o+vec4(-r2,0,-r2,-r2),r);if(f<d){d=f;no=o+vec4(-r2,0,-r2,-r2);}\n        \n        f=ScubeSDF(p+o+vec4(0,-r2,r2,r2),r);if(f<d){d=f;no=o+vec4(0,-r2,r2,r2);}\n        f=ScubeSDF(p+o+vec4(0,r2,-r2,r2),r);if(f<d){d=f;no=o+vec4(0,r2,-r2,r2);}\n        f=ScubeSDF(p+o+vec4(0,r2,r2,-r2),r);if(f<d){d=f;no=o+vec4(0,r2,r2,-r2);}\n        f=ScubeSDF(p+o+vec4(0,-r2,-r2,r2),r);if(f<d){d=f;no=o+vec4(0,-r2,-r2,r2);}\n        f=ScubeSDF(p+o+vec4(0,-r2,r2,-r2),r);if(f<d){d=f;no=o+vec4(0,-r2,r2,-r2);}\n        f=ScubeSDF(p+o+vec4(0,r2,-r2,-r2),r);if(f<d){d=f;no=o+vec4(0,r2,-r2,-r2);}\n        f=ScubeSDF(p+o+vec4(0,-r2,-r2,-r2),r);if(f<d){d=f;no=o+vec4(0,-r2,-r2,-r2);}\n        \n        f=ScubeSDF(p+o+vec4(r2,r2,r2,r2),r);if(f<d){d=f;no=o+vec4(r2,r2,r2,r2);}\n        f=ScubeSDF(p+o+vec4(r2,r2,r2,-r2),r);if(f<d){d=f;no=o+vec4(r2,r2,r2,-r2);}\n        f=ScubeSDF(p+o+vec4(r2,r2,-r2,r2),r);if(f<d){d=f;no=o+vec4(r2,r2,-r2,r2);}\n        f=ScubeSDF(p+o+vec4(r2,r2,-r2,-r2),r);if(f<d){d=f;no=o+vec4(r2,r2,-r2,-r2);}\n        f=ScubeSDF(p+o+vec4(r2,-r2,r2,r2),r);if(f<d){d=f;no=o+vec4(r2,-r2,r2,r2);}\n        f=ScubeSDF(p+o+vec4(r2,-r2,r2,-r2),r);if(f<d){d=f;no=o+vec4(r2,-r2,r2,-r2);}\n        f=ScubeSDF(p+o+vec4(r2,-r2,-r2,r2),r);if(f<d){d=f;no=o+vec4(r2,-r2,-r2,r2);}\n        f=ScubeSDF(p+o+vec4(r2,-r2,-r2,-r2),r);if(f<d){d=f;no=o+vec4(r2,-r2,-r2,-r2);}\n        f=ScubeSDF(p+o+vec4(-r2,r2,r2,r2),r);if(f<d){d=f;no=o+vec4(-r2,r2,r2,r2);}\n        f=ScubeSDF(p+o+vec4(-r2,r2,r2,-r2),r);if(f<d){d=f;no=o+vec4(-r2,r2,r2,-r2);}\n        f=ScubeSDF(p+o+vec4(-r2,r2,-r2,r2),r);if(f<d){d=f;no=o+vec4(-r2,r2,-r2,r2);}\n        f=ScubeSDF(p+o+vec4(-r2,r2,-r2,-r2),r);if(f<d){d=f;no=o+vec4(-r2,r2,-r2,-r2);}\n        f=ScubeSDF(p+o+vec4(-r2,-r2,r2,r2),r);if(f<d){d=f;no=o+vec4(-r2,-r2,r2,r2);}\n        f=ScubeSDF(p+o+vec4(-r2,-r2,r2,-r2),r);if(f<d){d=f;no=o+vec4(-r2,-r2,r2,-r2);}\n        f=ScubeSDF(p+o+vec4(-r2,-r2,-r2,r2),r);if(f<d){d=f;no=o+vec4(-r2,-r2,-r2,r2);}\n        f=ScubeSDF(p+o+vec4(-r2,-r2,-r2,-r2),r);if(f<d){d=f;no=o+vec4(-r2,-r2,-r2,-r2);}\n        //48 Scubes given thats its all binary operations, more or less, this should be done in a loop.\n        \n        \n        \n        if(limit!=0.)II++;\n        o=no;\n        r/=3.;\n        \n        \n    }\n   \n    return d;     \n}\nfloat mengerSDF(vec3 p, float limit){\n    float r=1.;\n    float II=0.;\n    vec3 o=vec3(0);\n    float d=0.0;\n    \n    float f;\n    \n    if(II==0.)d=cubeSDF(p+o,r);\n    if (d>r*1.414213562)return d;//1.414213562=sqrt(2)\n    vec3 no=vec3(0);\n    \n    r/=3.;\n    while (d<r*1.414213562&&(II<limit||limit==0.)){\n        \n        d=far;\n        f=cubeSDF(p+o+vec3(2.*r,2.*r,0),r);if(f<d){d=f;no=o+vec3(2.*r,2.*r,0);}\n        f=cubeSDF(p+o+vec3(2.*r,0,2.*r),r);if(f<d){d=f;no=o+vec3(2.*r,0,2.*r);}\n        f=cubeSDF(p+o+vec3(0,2.*r,2.*r),r);if(f<d){d=f;no=o+vec3(0,2.*r,2.*r);}\n        f=cubeSDF(p+o+vec3(2.*r,2.*r,2.*r),r);if(f<d){d=f;no=o+vec3(2.*r,2.*r,2.*r);}\n        f=cubeSDF(p+o+vec3(2.*-r,2.*r,0),r);if(f<d){d=f;no=o+vec3(2.*-r,2.*r,0);}\n        f=cubeSDF(p+o+vec3(2.*r,2.*-r,0),r);if(f<d){d=f;no=o+vec3(2.*r,2.*-r,0);}\n        f=cubeSDF(p+o+vec3(2.*-r,2.*-r,0),r);if(f<d){d=f;no=o+vec3(2.*-r,2.*-r,0);}\n        f=cubeSDF(p+o+vec3(2.*-r,0,2.*r),r);if(f<d){d=f;no=o+vec3(2.*-r,0,2.*r);}\n        f=cubeSDF(p+o+vec3(2.*r,0,2.*-r),r);if(f<d){d=f;no=o+vec3(2.*r,0,2.*-r);}\n        f=cubeSDF(p+o+vec3(2.*-r,0,2.*-r),r);if(f<d){d=f;no=o+vec3(2.*-r,0,2.*-r);}\n        f=cubeSDF(p+o+vec3(0,2.*-r,2.*r),r);if(f<d){d=f;no=o+vec3(0,2.*-r,2.*r);}\n        f=cubeSDF(p+o+vec3(0,2.*r,2.*-r),r);if(f<d){d=f;no=o+vec3(0,2.*r,2.*-r);}\n        f=cubeSDF(p+o+vec3(0,2.*-r,2.*-r),r);if(f<d){d=f;no=o+vec3(0,2.*-r,2.*-r);}\n        f=cubeSDF(p+o+vec3(2.*-r,2.*r,2.*r),r);if(f<d){d=f;no=o+vec3(2.*-r,2.*r,2.*r);}\n        f=cubeSDF(p+o+vec3(2.*r,2.*-r,2.*r),r);if(f<d){d=f;no=o+vec3(2.*r,2.*-r,2.*r);}\n        f=cubeSDF(p+o+vec3(2.*r,2.*r,2.*-r),r);if(f<d){d=f;no=o+vec3(2.*r,2.*r,2.*-r);}\n        f=cubeSDF(p+o+vec3(2.*-r,2.*r,2.*-r),r);if(f<d){d=f;no=o+vec3(2.*-r,2.*r,2.*-r);}\n        f=cubeSDF(p+o+vec3(2.*r,2.*-r,2.*-r),r);if(f<d){d=f;no=o+vec3(2.*r,2.*-r,2.*-r);}\n        f=cubeSDF(p+o+vec3(2.*-r,2.*-r,2.*r),r);if(f<d){d=f;no=o+vec3(2.*-r,2.*-r,2.*r);}\n        f=cubeSDF(p+o+vec3(2.*-r,2.*-r,2.*-r),r);if(f<d){d=f;no=o+vec3(2.*-r,2.*-r,2.*-r);}\n        if(limit!=0.)II++;\n        o=no;\n        r/=3.;\n        \n        \n    }\n    if(II>limit){\n        return cubeSDF(p+o,r);\n    }\n    return d;\n    \n    \n    \n     \n}\nvec4 noise(vec3 p){\n    float f=sin(p.z*0.3)+sin(p.x*0.3)+sin(p.x)+sin(p.y)+sin(p.z)+sin(p.x+p.z)+sin(p.y+p.x)+sin(p.z+p.y);\n    f*=0.5;\n    vec3 d=normalize(vec3(\n        0.3*cos(p.x*0.3)+cos(p.x)+cos(p.x+p.z)+cos(p.x+p.y),\n        cos(p.y)+cos(p.x+p.y)+cos(p.y+p.z),\n        0.3*sin(p.z*0.3)+cos(p.z)+cos(p.x+p.z)+cos(p.y+p.z)\n        \n        ));//no coefficient, as it is normalized\n    return vec4(f,d);\n}\n\n\nconst mat3 m3=mat3(-0.5, 0.9, 0.5,\n                0.4, -0.5, 0.4,\n                0.5, 0.9, -0.5);\n\nvec4 fbm( in vec3 x, int octaves )\n{\n    float f = 2.0; \n    float s = 0.5;  \n    float a = 0.0;\n    float b = 0.5;\n    vec3  d = vec3(0.0);\n    mat3  m = mat3(1.0,0.0,0.0,\n    0.0,1.0,0.0,\n    0.0,0.0,1.0);\n    for( int i=0; i < octaves; i++ )\n    {\n        vec4 n = noise(x);\n        a += b*n.x;          // accumulate values\n        d += b*m*n.yzw;      // accumulate derivatives\n        b *= s;\n        x = f*m3*x;\n        m = f*m3*m;\n    }\n    return vec4( a, d );\n}\nbool PLANE=false;\nfloat bounce(float t){\n    t=fract(t);\n    return (1.-t)*(1.-t)+t*t;\n}//returns values in range 0, 1\nfloat sinl(float t){\n    if(fract(t*0.5)>0.5)return bounce(t);\n    else return -bounce(t);\n\n}\nfloat planeSDF( vec3 p, vec3 n,float d){\n  return dot(p,n)+d;\n}\nvec3 PLANE_NORMAL=vec3(0);\nfloat sceneSDF(vec3 p, float limit){\n    vec4 p4=vec4(p,-1);\n    //p4.w=sinl(iTime*0.02);\n    float r=iTime*0.1;\n    p4*=mat4(cos(r),0,0,sin(r),\n             0,1,          0,0,\n             0,0,          1,0,\n             -sin(r),0,0,cos(r));\n    \n    return SmengerSDF(p4,limit);\n}\nfloat getEplison(float dist,float R){\n    return clamp(10.*pow(dist*0.1,1.1)*R,0.00000001,0.1);\n}\nvec2 rayMarch(vec3 o, vec3 d, float start, float end, int max_steps, bool for_lights){\n    float R=1.0/length(iResolution.xy);\n    float depth = start;\n    float fd= 0.0005;\n    float limit=0.0;\n    bool a_bool=false;\n    if(for_lights)limit=MENGER_LIGHT_DENSITY;\n    for (int i = 0; i < max_steps; i++) {\n        \n        float dist = sceneSDF(o + depth * d, limit);\n        if(!a_bool&&dist<0.0005){\n            fd=getEplison(depth+dist,R);\n            a_bool=true;\n            //fd=0.0001;\n            //if(!for_lights)limit=round(2./dist.x);\n        }\n        else if (dist < fd){\n            //if(dist.y>0.9)\n            return vec2(depth,fd);\n        }\n        depth += dist;\n        if (depth >= end)return vec2(end,fd);\n    }\n    return vec2(end,fd);\n}\n\n\nvec3 normal(vec3 p, float n){\n    float gg=sceneSDF(vec3(p)-n*0.333,0.);\n    return normalize(vec3(gg-sceneSDF(vec3(p.x-n,p.yz),0.),\n                     gg-sceneSDF(vec3(p.x,p.y-n,p.z),0.),\n                     gg-sceneSDF(vec3(p.xy,p.z-n),0.)\n                    ));\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = sceneSDF(ro + rd*t, MENGER_LIGHT_DENSITY);\n        if( h<mint*0.1 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n        \n    }\n    return res;\n}\nfloat light_func(vec3 p, vec3 light, bool shadows){\n    float len=dot(light-p,light-p);\n    float f=1.0/len;\n    //f.rgb=N;\n    if(shadows){\n        float y=rayMarch(p,normalize(light-p),0.01,100.,128,true).x;\n        if(y<len)return 0.;\n    }\n    if(f<0.)return 0.;\n    return f;\n}\nfloat dist_light_func(vec3 p, vec3 normal, vec3 light,bool shadows, float t){\n    light.xyz=normalize(light);\n    float len=dot(normal,light);\n    float f=len;\n    if(PLANE)f+=10.*pow(len,15.);\n    //f.rgb=N;\n    if(shadows){\n        float k=4.;\n        if(PLANE)k=64.;\n        f*=softShadow(p,light.xyz, t,far,k);\n    }\n    if(f<0.)return 0.;\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor.rgb=vec3(0);\n    //this gives it time\n    if(iTime>0.1){\n        vec2 mouse=iMouse.xy/iResolution.xy;\n        if(iMouse.x>0.)mouse-=0.5;\n        vec3 col=hue(mod(iTime*COLOR_SPEED,1.0))*0.07;\n        \n        float dist=sin(iTime*0.1)*0.1+10.-mouse.y*16.;\n        vec3 o=vec3(sin(mouse.x*6.+1.+iTime*0.1)*dist,0,cos(mouse.x*6.+1.+iTime*0.1)*dist);\n\n        vec2 uv = (fragCoord/iResolution.xy-0.5)*normalize(iResolution.xy);\n\n\n        vec3 d=normalize(vec3(uv,-1.1));\n        vec3 f=lerp(vec3(0.1,0.2,0.3),vec3(0.64,0.8,0.9),fragCoord.y/iResolution.y);\n        vec3 UP=vec3(0,1,0);\n        vec3 T = normalize(-o);\n        vec3 A = cross(UP,T);\n        UP=cross(T,A);\n        mat3 cm=mat3(A,UP,-T);\n        d*=cm;\n        d=normalize(d);\n        vec2 t=rayMarch(o,d,0.0018,far,MAX_STEPS, false);\n        if (t.x<far){\n            vec3 p=o+d*t.x;\n            vec3 N;\n            vec3 albedo=vec3(0.4); \n            float clt=clamp(t.y,0.01,0.1);\n#ifdef AA\n            for(int i=0;i<4;i++){\n                uv = ((fragCoord+vec2(i/2,i%2)*0.25-0.25)/iResolution.xy-0.5)*normalize(iResolution.xy);\n                f=vec3(0.3,0.35,0.4);\n                d=normalize(vec3(uv,1.1));\n                d*=cm;                        \n#endif       \n                N=normal(o+d*t.x,t.y);\n                f.rgb*=albedo*0.1*vec3(dot(N,vec3(0,1,-1)));\n                f.rgb+=albedo*dist_light_func(p,N,vec3(0.5,0.5,0.5),true,clt)*vec3(0.9,0.8,0.6);\n                f.rgb+=albedo*light_func(p,vec3(0.0,0.0,0.0),true)*col*1.;\n                //f.rgb=N*0.5+0.5;\n                \n#ifdef AA         \n                fragColor.rgb+=f;\n            }\n            fragColor.rgb+=fragColor.rgb*0.25;\n#endif\n\n        }\n#ifdef AA        \n        else{\n            fragColor.rgb=f;\n        }  \n#else \n        fragColor.rgb=f;\n#endif\n\n\n     \n        \n\n\n        fragColor.rgb=sqrt(fragColor.rgb);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}