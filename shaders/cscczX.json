{
    "Shader": {
        "info": {
            "date": "1696131922",
            "description": "Click to erase, shift to invert\n\nTracking now keeps track of 4 particles using ID.\n\nscale = 5 is completely stable, but 1 is actually viable for simulation. 1 on previous version was absolutely terrible. Pls help improve :)",
            "flags": 48,
            "hasliked": 0,
            "id": "cscczX",
            "likes": 25,
            "name": "Slime Molds 3.0",
            "published": 3,
            "tags": [
                "simulation",
                "particles",
                "slime",
                "life",
                "automaton",
                "voronoitracking"
            ],
            "usePreview": 0,
            "username": "01000001",
            "viewed": 604
        },
        "renderpass": [
            {
                "code": "// Buffer A : Particle control\n// Buffer B : Voronoi Tracking\n// Buffer C : Rendering\n// Buffer D : Post processing\n\n// See Buffer A to play around with particle configurations\n// I've included a few fun presets to try :D\n\n// You may wanna use the shadertoy unofficial plugin\n// to speed it up by increasing drawcalls\n// For interactivity though, realtime is nice\n\n\n\nvoid mainImage( out vec4 O, vec2 U ){\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    \n    #ifdef display_voronoi\n        O = uv.x>.5?\n            texture(iChannel2, uv):\n            texture(iChannel1, uv).xyzw/r.x/r.y;\n    #else \n        O = texture(iChannel2, uv);\n        \n        //*    \n        O = vec4(\n            O.x*O.x, \n            O.x, \n            sqrt(O.x), \n        1.);//*/\n\n    #endif\n}\n\n// Next up: Ant simulation!\n// And then turbulent particles ðŸ‘€\n// ^ I wanna recreate this render I made in Blender\n// https://cdn.discordapp.com/attachments/1134975470526537879/1156789266739900456/still_particles.png\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Particle Buffer\n\n\n#define PRESET 3\n// 0 : Boring\n// 1 : Squiggly\n// 2 : High Velocity\n// 3 : Dendrites\n// 4 : Stable\n// 5 : Bipolar                          // I asked friends to help me find the word that means a system that\n                                        // will converge to a stable state, but explode at tiny perturbations\n                                        // and this is the suggestion I received. It works Â¯\\_(ãƒ„)_/Â¯\n// 6 : Angular\n// 7 : Cellular\n// 8 : Lattice\n\n// Alright that's enough. Have fun exploring :)\n\n\n#if PRESET == 0\n// Less than one gets funky\nconst float searchRange = 1.;\nconst float searchAngle = .4;\nconst float turnAngle = .02;\n#endif\n\n#if PRESET == 1\nconst float searchRange = 1.;\nconst float searchAngle = pi/3.;\nconst float turnAngle = .02;\n#endif\n\n#if PRESET == 2\nconst float searchRange = 5.;\nconst float searchAngle = .1;\nconst float turnAngle = .05;\n#endif\n\n#if PRESET == 3\nconst float searchRange = 5.;\nconst float searchAngle = .1;\nconst float turnAngle = .2;\n#endif\n\n#if PRESET == 4\nconst float searchRange = 1.;\nconst float searchAngle = 1.;\nconst float turnAngle = .2;\n#endif\n\n#if PRESET == 5\nconst float searchRange = 2.;\nconst float searchAngle = 2.*pi/3.;\nconst float turnAngle = 2.*pi/3.;\n#endif\n\n#if PRESET == 6\nconst float searchRange = 2.;\nconst float searchAngle = pi/2.;\nconst float turnAngle = pi/2.;\n#endif\n\n#if PRESET == 7\nconst float searchRange = 1.;\nconst float searchAngle = 0.01;\nconst float turnAngle = pi/7.;\n#endif\n\n#if PRESET == 8\nconst float searchRange = 50.;\nconst float searchAngle = .01;\nconst float turnAngle = .01;\n#endif\n\n\nconst float randomization = 5e-3;\n// Without this they'll converge to a stable state and then never do anything fun again :(\n\n\n\n\n\n\nvoid mainImage( out vec4 O, vec2 U ){\n\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    \n    float aspect = r.x/r.y;\n    \n    // if (uv.x * scale > 1. || uv.y * scale > 1.) return;\n    // Prevent simulation of particles out of bounds\n    // If we allow it then can resize at runtime\n    \n    \n    if (iFrame < 30){\n    \n        uvec3 a = uvec3(U, iDate.w);\n        O.xy = (circleSample(a))*.25 * vec2(1, aspect) + .5;\n        O.zw = normalize(hash(a).xy*2.-1.) * rot(pi/2.7);\n        return;\n        \n    }\n\n    O = texture(iChannel0, uv);\n\n    vec2 pos = O.xy;        \n    vec2 vel = O.zw;\n\n    const int rayCount = 3;\n    float rays[rayCount];\n\n    float x = 20.;\n\n    for (int ray = 0; ray < rayCount; ray++){\n        vec2 rayDir = vel * rot(-searchAngle+float(ray)*searchAngle);\n\n        x = texture(iChannel2, pos + rayDir*scale/r.x*searchRange).x;\n\n        rays[ray] = x;\n    }\n\n    vec3 h = hash(uvec3(U, iDate.w*1000.));\n    if (h.x < randomization){ // Crazy tiny amount of divergents.\n                     // That's all it takes to break up regularity with millions of particles :) \n        vel *= rot(h.y);\n    } else {\n        if (rays[0] > rays[2]){\n            // Left\n            vel *= rot(-turnAngle);\n        } else if (rays[2] > rays[0]) {\n            // Right\n            vel *= rot( turnAngle);\n        } else {\n            // Centre\n\n            //vel *= rot(h.y);\n        }\n    }\n\n    pos += vel * scale/r.x * 2e-2 * searchRange * vec2(1, aspect);\n\n    pos = mod(pos, 1.);\n\n    O = vec4(pos, vel);\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Voronoi buffer\n\n\nvoid mainImage( out vec4 O, vec2 U ){\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    \n    if (iFrame < 10){\n        O = vec4(0);\n        return;\n    }\n    \n    \n    O = texture(iChannel1, uv);\n    \n    vec2 myParticles[4];\n    vec4 particleDists;\n    \n    for (int i = 4; i-->0;){\n        myParticles[i] = texture(iChannel0, decrypt(O[i], r)/scale).xy;\n        particleDists[i] = length(myParticles[i] - uv);\n    }\n    \n    \n    for (int i = 10; i-->0;){\n\n        for (int j = 4; j-->0;){\n        \n            vec3 a = hash(uvec3(U, iFrame - i + j*8))*2.-1.;\n            vec3 b = hash(uvec3(U, iFrame * i - j  ))*2.-1.;\n            vec3 c = hash(uvec3(U, iFrame + i - j*8))*2.-1.;\n        \n            vec2 samp = decrypt(\n                texture(iChannel1,\n                    mod(myParticles[j]\n                        + (a.xy + vec2(a.z, b.x) + b.yz + c.xy) / (r.x/scale) \n                        // Gaussian-ish sampling\n                        // we can use two vec3s to get three vec2s \n                        // and then another one for good measure\n                    ,1.) // Mod loops around overflow coordinates\n                )[i%5]\n            ,r);\n\n            vec2 newParticle = texture(iChannel0, samp/scale).xy;\n\n            push(O, samp, r, particleDists[j], length(newParticle-uv));\n            // Stores four particle IDs in the floats\n        }\n    }\n    \n    \n    for (int i = 0; i < 2; i++){\n        vec2 samp = hash(uvec3(U, iFrame * i)).xy;\n        \n        vec2 newParticle = texture(iChannel0, samp/scale).xy;\n\n        push(O, samp, r, particleDists[0], length(newParticle-uv));\n        // Completely random samples may not seem too critical, \n        // but they significantly improve the stability of the simulation\n    }\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n     // I am become pixel, creator of shaders\n    // - 01000001 2023\n\nconst float pi = 3.14159;\nconst float scale = 3.;\n// Try big number to see what's going on. 3 is about the minimum that works semi coherently.\n// Any improvements to accurately render an even larger quanitity of particles would be appreciated :D\n// I have a few ideas but I'd love to learn about the community's knowledge\n\n\n// #define debug\n// Render particles directly, no visual processing\n\n// #define display_voronoi\n// Show the voronoi buffer\n\n// #define blur\n// Blur the trails\n\nconst uint k = 1103515245U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n//hash by IQ https://www.shadertoy.com/view/XlXcW4\nvec2 circleSample(uvec3 x){\n    vec2 v,z;\n    for(int i = 0;v=hash(x+uint(v*1e9)).xy, z=v*2.-1., i++<9 && length(z) > 1.;);\n    return z;\n}\n\nmat2 rot( float rad ){\n    return mat2(\n        cos(rad), sin(rad),\n        -sin(rad), cos(rad)\n    );\n}\n\n\n/*\nvec2 decrypt(float d, vec2 r){\n    uint i = floatBitsToUint(d);\n    uvec2 ir = uvec2(r);\n\n    return vec2(\n        i%ir.x,\n        float(i-i%ir.x)/r.x\n    )/r;\n}\n\nfloat encrypt(vec2 uv, vec2 r){\n    uvec2 iuv = uvec2(uv*r);\n    uvec2 ir = uvec2(r);\n\n    return uintBitsToFloat(\n        iuv.x + iuv.y*ir.x\n    );\n}\n\n// This is better. BUT IT DOESN'T WORK WITH BUFFERS\n\n/*/\n\n\nvec2 decrypt(float d, vec2 r){\n    return vec2(mod(d, r.x), floor(d/r.x))/r;\n}\n\nfloat encrypt(vec2 uv, vec2 r){\n    return uv.x*r.x + floor(uv.y*r.y)*r.x;\n}\n\n\n//*/\n\nvoid push(inout vec4 O, vec2 uv, vec2 res, float me, float new){\n    ivec2 iuv = ivec2(floor(uv*res));\n    ivec2 ires = ivec2(floor(res));\n    \n    float e = encrypt(uv, res);\n    if (new < me && e != O.x && e != O.y && e != O.z && e != O.w){\n        O.w = O.z; O.z = O.y; O.y = O.x;\n        O.x = e;\n    }\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Render Buffer\n\n\nvoid mainImage( out vec4 O, vec2 U ){\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    \n    float aspect = r.x/r.y;\n    \n    O = vec4(0);\n    \n    float minD = 2.;\n    float x = 0.;\n    for (int i = 0; i<2; i++){\n    \n        for (int j = 4; j-->0;){\n            vec2 samp = decrypt(\n                texture(iChannel1, \n                    uv + (circleSample(uvec3(U, iFrame * i << j)) / (r.x / scale))\n                )[j]\n            ,r)/scale;\n\n            x = length(\n                (texture(iChannel0, samp).xy - uv) * vec2(1, 1./aspect)\n            );\n\n            if (x < minD){\n                minD = x;\n            }\n        }\n    }\n    \n    #ifdef debug\n    #else\n        O = texture(iChannel2, uv\n            #ifdef blur\n            + (vec2(1.)/r)*rot(float(iFrame) * pi/2.)\n            #endif\n        );\n        O *= .96;\n    #endif\n    O += smoothstep(scale/r.x * .25, 0., minD);\n        \n    \n    if (iMouse.z > 0.){\n        if (texelFetch(iChannel3, ivec2(16, 0), 0).x > .0){\n            O.x += max(0., 1.-length((iMouse.xy - U)/r/scale * vec2(1, 1./aspect)) * 500.);\n        } else {\n            O *= min(1., length((iMouse.xy - U)/r/scale * vec2(1, 1./aspect)) * 200.);   \n        }\n    }\n        \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Post Processing\n\n\nvoid mainImage( out vec4 O, vec2 U ){\n\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    \n    #ifdef debug\n        O = texture(iChannel2, uv);\n    #else\n        O = texture(iChannel3, uv);\n        O *= .95;\n        O += texture(iChannel2, uv)*1e-2;\n    #endif\n    \n    // Because of SIMD, vector as opposed to operating on only O.x\n    // should be the same speed right? I hope? Pls lmk in comments :)\n    \n    /*\n    float sum = 0.;\n    for (float i = 0.; i<8.; i++){\n        sum += texelFetch(iChannel2, ivec2(U) + ivec2(sin(i*pi/4.), cos(i*pi/4.)), 0).x;\n    }\n    O += sum*1e-3;\n    //*/\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}