{
    "Shader": {
        "info": {
            "date": "1496698256",
            "description": "mouse does stuff.\nis just like \nhttps://www.shadertoy.com/view/4dVGzw (paniq)\nhttps://www.shadertoy.com/view/XlV3Dy (ollj)\nwith a simpler BASIC set at line 185...",
            "flags": 0,
            "hasliked": 0,
            "id": "MsXBRB",
            "likes": 13,
            "name": "022 simple Derivative Arithmetic",
            "published": 3,
            "tags": [
                "numbers",
                "derivative",
                "dual",
                "paniq",
                "arithmetic",
                "continuous",
                "automatic",
                "differential",
                "derivate",
                "goursat",
                "continuity",
                "superprim"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 684
        },
        "renderpass": [
            {
                "code": "//simpler set than its parent: https://www.shadertoy.com/view/XlV3Dy\n\n// arithmetic set for automatic differentiation, \n// derivative arithmetic [DA] for\n// https://en.wikipedia.org/wiki/Smoothness\n// of shapes that (otherwise) lack C1-continuity.\n// based on    : https://www.shadertoy.com/view/4dVGzw\n// inspired by : https://www.shadertoy.com/view/Mdl3Ws \n//\n//explained at http://blog.demofox.org/2014/12/30/dual-numbers-automatic-differentiation/\n//wiki         https://en.m.wikipedia.org/wiki/Automatic_differentiation\n//summary:     https://www.reddit.com/r/math/comments/68st6p/the_wikipedia_article_on_automatic/\n\n#define Goursat\n//disabled in this one\n\n/*\nmouse does stuff.\ncleaned and starting to undertand how to use:\nsubstraction of distances is in line 235 ish\n, mixing 2 shapes by sin(time)*.5+.5\n*/\n\n#define IterRm 64\n//max raymarch iterations|steps\n//using [DA], it still looks decent with much less iterations. try <6\n//this is where [DA]-raymarching can have higher performance \n//than non-DA-raymarching\n\n#define IterSh 24\n//softshadow iterations\n\n#define ReciprocalLipschitz .99\n//if(lipschitzConstant>1., distance is overestimated.\n//... lazy fix for that is scaling stepDistance*=ReciprocalLipschitz\n//I noticed better quality with a smaller stepfactor AND epsilon=0.\n//meaning, a surface will NEVER really be reached.\n//maybe todo: eps=log(eps*b)*a\n\n//Using f'(x)= f(d)/dx notation for derivates:\n//https://en.wikipedia.org/wiki/Derivative#Notation\n\n//this defines common operations but on a (pseudo) dual number (i,j), defined as:\n//[j] stays \"underived\"\n//[i] calculates the gradient as byproduct\n//[i] becomes Operation(i,FirstDerivateOf(Operation(i,j))\n//[i] is always precise and this way usually calculates faster than using central differences,\n//mostly because a lot of operations have a lot of values cancel each other out, allowing \"shortcuts\".\n//especially canceling out a lot of domainVectors at once, which is nice for vectorHardware.\n//\n//\"pseudo\" dual because [i] has 3 dimensions, and [j] has 1 dimension that modifies on all dimensions of [i], \n//because graphic cards are good with domain operators on vectors.\n//we define your dual number (where one part calculates with derivative of the other part and itself)\n//as type vec4(vec3,float)\n//and the 3 dimensions|domains are resolved with [struct DAVec3{}] and [da_domain()]:\nstruct DAVec3{vec4 x;vec4 y;vec4 z;};\nDAVec3 da_domain(vec3 p){return DAVec3(\n vec4(1.,0.,0.,p.x),\n vec4(0.,1.,0.,p.y),\n vec4(0.,0.,1.,p.z));}\n//this lets you derive over 3 dimensions at once OR seperately, using very self-similar dual-function variants:\n#define dacon(a) vec4(0.,0.,0.,a)\n#define i1 in float\n#define i4 in vec4\n#define i3 in vec3\nvec4 da_const(i1 a){return dacon(a);}\n//as proof of concept, remember the derivates of sin|cos:\n//sin => cos => -sin => -cos => sin =>...\nvec4 da_sin(i4 a){return vec4( a.xyz*cos(a.w),sin(a.w));}\nvec4 da_cos(i4 a){return vec4(-a.xyz*sin(a.w),cos(a.w));}\n//eulers number, exponential functions and natural log:\nvec4 da_exp(i4 a){float w=exp(a.w);return vec4(a.xyz*w,w);}//exp(a)==pow(e,a)\nvec4 da_log(i4 a){return vec4(a.xyz/a.w,log(a.w));}\n\n#define siq safeinv(q),q);}\nfloat safeinv(i1 a){return (a==0.)?a:1./a;}//reciprocal,1/x but 1./0.=1.; sometimes makes more sense than divBy0!\nvec4 da_abs (i4 a){return vec4(a.xyz*sign(a.w),abs(a.w));}\nvec4 da_pow2(i4 a){return vec4(2.*a.w*a.xyz, a.w*a.w);}\nvec4 da_sqrt(i4 a){float q=sqrt(a.w);\n return vec4(.5*a.xyz*siq\n\n//derivatives of functions with 2 variables are trickier:\n//because only .w determines breanching of min()|max() (in the nature of dual numbers, only one matters here)\n//optionally, a float parameter can be given as vec4(0,0,0,f):\nvec4 da_min(i4 a,i4 b){return(a.w<=b.w)?a:b;}\nvec4 da_min(i4 a,i1 b){return(a.w<=b  )?a:da_const(b);}\nvec4 da_min(i1 a,i4 b){return(a  < b.w)?da_const(a):b;}\nvec4 da_max(i4 a,i4 b){return(a.w>=b.w)?a:b;}\nvec4 da_max(i4 a,i1 b){return(a.w>=b  )?a:da_const(b);}\nvec4 da_max(i1 a,i4 b){return(a  > b.w)?da_const(a):b;}\n#define da_max3(a,b,c) da_max(da_max(a,b),c)\n//I assume the more general logic here is that all these functions with 2 parameters do:\n/*vec4 r;\n  r.w  = operationOn(a.w,b.w);\n  r.xyz= operationOn(a.xyz , vec3(firstDerivateOf(r.w))); //firstDerivateOf(r.w)==[tricky part]==(3d graphs tangents)\n  return r;*/\n//f(a,b)=mod(a,b) => f'(a,b)=1. , (still disontinuous, not defined for whole multiples of b).\nvec4 da_mod(i4 a,i4 b){return vec4(mod(a.xyz,1.),mod(a.w,b.w));}\nvec4 da_mod(i4 a,i1 b){return vec4(mod(a.xyz,1.),mod(a.w,b  ));}\nvec4 da_mod(i1 a,i4 b){return vec4(0,0,0        ,mod(a  ,b.w));}//here \"a.xyz\"==vec3(0)\n//and usually a lot cancels out in substraction/division...\nvec4 da_sub(i4 a,i4 b){return a-b;}\nvec4 da_sub(i4 a,i1 b){return vec4( a.xyz,a.w-b  );}\nvec4 da_sub(i1 a,i4 b){return vec4(-b.xyz,a  -b.w);}\nvec4 da_add(i4 a,i4 b){return a+b;}\nvec4 da_add(i4 a,i1 b){return da_sub(a,-b);}//addition as invrse substraction\nvec4 da_add(i1 a,i4 b){return da_sub(a,-b);}\n             \nvec4 da_mul(i4 a,i4 b){return vec4(a.xyz*b.w+a.w*b.xyz, a.w*b.w);}\nvec4 da_mul(i4 a,i1 b){return a*b;}\nvec4 da_mul(i1 a,i4 b){return a*b;}\nvec4 da_div(i4 a,i4 b){return vec4((a.xyz*b.w-a.w*b.xyz)/(b.w*b.w), a.w/b.w);}\nvec4 da_div(i4 a,i1 b){return a/b;}\nvec4 da_div(i1 a,i4 b){return vec4((-a*b.xyz)/(b.w*b.w), a/b.w);} \n             \n//some operations cancel out a bit more, to (nearly) tautological|identical identities:\n//<- wooha, a recursive meta-tautology!\n//vec4 da_fract(i4 a){return a;}//derivative of fract(a)=a => tautological.\nvec4 da_floor(i4 a){return dacon(a);}\nvec4 da_floor(i1 a){return dacon(a);}\n//#define mod(a,b) (a-b*floor(a/b))\n//da_mod.xyz==a.xyz-b.xyz*0==a.xyz\n\n//f(a,b)=dot(g(a),h(b)) => f'(x)              =dot(g'(a)',h(b))+dot(g(a),hÂ´(b))\n//                      => d/dx(dot(g(a),h(b))=dot(ga/gx ,h   )+dot(g   ,ha/hx); //similar to \"product rule for scalars\"\n//g(a)=c\n//h(b)=d\n//f(a,b)=dot(c,d) => f'(x)=dot(c',d)+dot(c,d');\n// c and d are type type vec3;\n//f'(x)=dot(0,d)+dot(c,0) == 0+0; ???\n            \n\n//todo: derivative of dot() appears tricky: this #define should do:\n//#define dotDer(a,b) min(f(abs(a)),abs(b))*sign(a)*sign(b)\n//vec4 da_dot(i4 a,i4 b){return vec4(a.xyz*dotDer(a,b),dot(a.w,b.w));}           \n//vec4 da_dot(i4 a,i1 b){return vec4(a.xyz*dotDer(a,b),dot(a.w,b  ));}  \n//vec4 da_dot(i1 a,i4 b){return da_dot(b,a);}//is commutative\n             \n//and it gets trickier with functions that take 3 parameters:\nvec4 da_length(i4 x,i4 y){float q=length(vec2(x.w,y.w));\n return vec4((x.xyz*x.w+y.xyz*y.w)*siq\nvec4 da_length(i4 x,i4 y,i4 z){float q=length(vec3(x.w,y.w,z.w));\n return vec4((x.xyz*x.w+y.xyz*y.w+z.xyz*z.w)*siq\n//the utility of a length() function is clear.\n\n//the utility of da_*().xyz is trickier, just search below to see  what it is ued for:\n\n\n//using the above, we define distance functions that automatically calculate their derivatives\n//this makes surfaces that are C1-discontinuous, like staircases, \n//at least have their (continuous) first rerivate calculated, which is useful for raymarching (?)\nvec4 sdSphere(DAVec3 p){\n p.x*=.8;p.x-=.5*sin(1.61*iTime);\n p.y*=.8;\n p.z*=.8;p.z-=.5*cos(1.61*iTime);\n vec4 q=da_length(p.x,p.y,p.z);\n q=da_sub(q,1.);\n return q;}\n\nvec4 sdRay(DAVec3 p){//infinite line segment\n float ass=p.x.w;\n p.x.w=mix(0.,p.x.w,step(p.x.w,0.));\n vec4 q=da_length(p.x,p.y,p.z);\n q=da_sub(q,1.);\n return q;}\n\n/*\nfloat fBox(vec3 p,vec3 b){\n\n vec3 q;\n vec3 q=min(d,0.);\n\n vec3 a=length(max(d,0.));\n vec3 c=max(max(q.x,q.y),q.z);\n return a+c;\n}\n*/\n  \n/*\nfloat fBoxCheap(vec3 p,vec3 b){\n vec3 q=abs(p);q=q-p;\n return max(max(q.x,q.y),q.z);}//hg_saf\n*/\nvec4 sdBoxCheap(DAVec3 p){\n //vec2 r=vec2(.0,.0);\n vec3 s=vec3(1.5,.5,1.5);\n vec4 x,y,z,d,e,f,q,a,b,c;\n x=vec4(0);y=vec4(0);z=vec4(0);d=vec4(0);\n e=vec4(0);f=vec4(0);q=vec4(0);\n a=vec4(0);b=vec4(0);c=vec4(0);\n x=da_abs(p.x);x=da_sub(x,s.x);\n y=da_abs(p.y);y=da_sub(y,s.y);\n z=da_abs(p.z);z=da_sub(z,s.z); //thichnessess\n c=da_max3(x,y,z);\n return c;}\n/*\nfloat fBox(vec3 p,vec3 s){\nvec3 d=abs(p)-s;\nfloat a=length(max(d,0.));\nvec3 q=min(d,0.);\nfloat b=max(max(q.x,q.y),q.z);\nreturn a+b;}//hg_sdf\n*/\nvec4 sdBox(DAVec3 p){\n //vec2 r=vec2(.0,.0);\n vec3 s=vec3(1.5,.5,1.5);\n vec4 x,y,z,d,e,f,q,a,b,c;\n x=vec4(0);y=vec4(0);z=vec4(0);d=vec4(0);\n e=vec4(0);f=vec4(0);q=vec4(0);\n a=vec4(0);b=vec4(0);c=vec4(0);\n x=da_abs(p.x);x=da_sub(x,s.x);\n y=da_abs(p.y);y=da_sub(y,s.y);\n z=da_abs(p.z);z=da_sub(z,s.z);\n //thichnessess\n vec4 qx=da_min(x,0.);\n vec4 qy=da_min(y,0.);\n vec4 qz=da_min(z,0.);\n b=da_max3(qx,qy,qz);\n x=da_max(x,0.);\n y=da_max(y,0.);\n z=da_max(z,0.);\n a=da_length(x,y,z);\n c=da_add(a,b);\n return c;}\n             \n             \n//a more readable version of the above, like, seriously WTF MAN!\n//how about one operation per line man, keep it BASIC!\nvec4 sdSuperprim(DAVec3 p, i4 s,vec2 r) {\n //vec2 r=vec2(.2,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n vec4 dx,dy,dz,d,e,f,q,a,b,c;\n dx=vec4(0);dy=vec4(0);dz=vec4(0);d=vec4(0);\n e=vec4(0);f=vec4(0);q=vec4(0);\n a=vec4(0);b=vec4(0);c=vec4(0);\n dx=da_abs(p.x);\n dx=da_sub(dx,s.x);\n dy=da_abs(p.y);\n dy=da_sub(dy,s.y);\n dz=da_abs(p.z);\n dz=da_sub(dz,s.z);\n \n d=da_add(dx,r.x);\n d=da_max(d,0.);\n e=da_add(dy,r.x);\n e=da_max(e,0.);\n q=da_length(d,e);\n f=da_max(dx,dy);\n f=da_min(-r.x,f);\n \n q=da_add(q,f);\n q=da_add(q,s.w);\n q=da_abs(q);\n q=da_sub(q,s.w);\n ///return...\n a=da_add(q ,r.y);\n a=da_max(a,0.);    \n b=da_add(dz,r.y);\n b=da_max(b,0.);\n a=da_length(a,b);\n c=da_min(-r.y,da_max(q,dz));\n c=da_add(a,c);\n return c;\n}\n\n// example parameters\n#define SHAPE_COUNT 10.0\nvoid getfactor (int i, out vec4 s,out vec2 r) {\n    //i = 8;\n    if (i == 0) { // cube\n        s = vec4(1.0);\n        r = vec2(0.0);\n    } else if (i == 1) { // corridor\n        s = vec4(vec3(1.0),0.25);\n        r = vec2(0.0);\n    } else if (i == 2) { // pipe\n        s = vec4(vec3(1.0),0.25);\n        r = vec2(1.0,0.0);\n    } else if (i == 3) { // cylinder\n        s = vec4(1.0);\n        r = vec2(1.0,0.0);\n\t} else if (i == 4) { // pill\n        s = vec4(1.0,1.0,2.0,1.0);\n        r = vec2(1.0);\n    } else if (i == 5) { // sphere\n        s = vec4(1.0);\n        r = vec2(1.0);\n    } else if (i == 6) { // pellet\n        s = vec4(1.0,1.0,0.25,1.0);\n        r = vec2(1.0,0.25);\n    } else if (i == 7) { // torus\n        s = vec4(1.0,1.0,0.25,0.25);\n        r = vec2(1.0,0.25);\n    } else if (i == 8) { // sausage mouth\n        s = vec4(2.0,0.5,0.25,0.25);\n        r = vec2(0.5,0.25);\n    } else if (i == 9) { // beveled O\n        s = vec4(0.7,1.0,1.0,0.25);\n        r = vec2(0.125);\n\t}\n}\n\n//set camera position & target\nvoid setCam(out vec3 o,out vec3 i,i1 t,i1 m){\n o=vec3(4.*sin(t),m*9.-2.,4.*cos(t));i=vec3(0);}\n\nstruct DAMValue{vec4 d;float m;};\nDAMValue min2(DAMValue a, DAMValue b){if(a.d.w>b.d.w)return b;return a;}\nDAMValue plane(DAVec3 p){return DAMValue(da_add(p.y,1.),1.);}\n//DAMValue add_plane(DAVec3 p,DAMValue m){return min2(plane(p),m);}\n\n#define ss01(a) smoothstep(0.,1.,a) \n#define imsc(a) int(mod(a,SHAPE_COUNT))\n//return distance to surface of DistanceField\nDAMValue df(DAVec3 p){vec4 r;\n#ifdef Goursat\n //r=sdGoursat(p);\n r=sdBox(p);\n //r=da_max(-sdTangle(p),sdSphere(p));\n //r=sdGoursat(p)*.7+sdSphere(p)*.3;\n //r=mix(sdGoursat(p),sdSphere(p),sin(iTime*.61)*.5+.5);\n#else\n float t=iTime,u=ss01(ss01(fract(t)));\n vec4 a,b;vec2 c,d;\n getfactor(imsc(t   ),a,c);\n getfactor(imsc(t+1.),b,d);\n DAVec3 q=DAVec3(p.z,p.y,p.x);\n if(iMouse.z>.5){\n  vec2 m=iMouse.xy/iResolution.xy;\n  r=sdSuperprim(q,vec4(vec3(1.0),mix(a.w,b.w,u)),m);\n }else\n  r=sdSuperprim(q,mix(a,b,u),mix(c,d,u));\n#endif\n return min2(plane(p),DAMValue(r,0.));}\n\n//return distance & materialID\nvec2 dm(i3 p){DAMValue d=df(da_domain(p));\n return vec2(d.d.w,d.m);}\n//return material at p with normal n\nvec4 material(i3 p,i3 n ){vec4 d=df(da_domain(vec3(p.x,0.,p.z))).d;\n return mix(vec4(n*.5+.5,.1)\n           ,vec4(d.xyz*.5 +.5,.0)*abs(mod(d.w,.1)/.1-.5)\n           ,clamp(dm(p).y,0.,1.));}\n\n//return soft shadow\nfloat shadow(i3 o,i3 i){\n const float a=32.;//shadow hardnes\n float r=1.,h =1.,t=.0005;//t=(self)intersection avoidance distance\n for(int j=0;j<IterSh;j++){\n  h=dm(o+i*t).x;\n  r=min(r,h*a/t);\n  t+=clamp(h,.02,2.);}//limit max and min stepping distances\n return clamp(r,0.,1.);}\n\n//return p, modified by light , shadow, envMap...\nvec3 light(i3 p,i3 n,i3 i,i1 d,i4 m){\n vec3 l=normalize(vec3(1.,.7,.9));//light direction\n float o=max(0.,dot(n,l)),\n c=max(0.,dot(n,normalize(l-i))),\n s;if(c>.01)s=shadow(p+.01*n,l); \n const vec3 LigCol=vec3(1.);//light color\n vec3 r=m.rgb*(LigCol+o*vec3(.8,.7,.6)*s*3.+vec3(.2,.3,.3));  \n r+=s*c*pow(o,40.);//specular\n //r+=m.w*texture(iChannel0, reflect(i,n)).rgb;//envmap\n r*=exp(-.01*d*d);//fog  \n return r;}\n\n//return distance along ray (raymarch till surface)\nfloat rm(i3 o,i3 i){\n const float m=20.;//distance.Max\n float e=.0,h=e,t=0.;//intersection.precission\n for(int j=0;j<IterRm;j++){\n  if(h<e)break;if(t>m)return -1.;\n     //wait a moment, do i not have the lipschitz for the point\n     //or at least 3 for 3 domains of the point\n     //by using [DA]?\n     //i mean, i could really insert this here, right?\n     //and substitute ReciprocalLipschitz with 1/da_length()\n  h=dm(o+i*t).x*ReciprocalLipschitz;t+=h;}return t;}\n\n//return surface normal\nvec3 getN(in vec3 p){DAMValue d=df(da_domain(p));\n return d.d.xyz;}\n//.xyz store the first derivatives on the 3 domains, \n//this is equivalent to the gradient at p\n//if (p is near a surface) the gradient is a surface normal\n//d.d.* addresses a vec4. where *.xyz==gradient\n//d.m.* addresses a material\n             \n//return camera matrix\nmat3 calcLookAtMatrix(in vec3 o,in vec3 i,in float r ){\n vec3 w=normalize(i-o);vec3 u=normalize(cross(w,vec3(sin(r),cos(r),0.)) );\n return mat3(u,normalize(cross(u,w)),w);}\n\n//return color corrected r\nvec3 ff_filmic_gamma3(vec3 r){vec3 x=max(vec3(0),r-.004);\n return (x*(x*6.2+.5))/(x*(x*6.2+1.7)+.06);}\n\nvoid mainImage( out vec4 r,in vec2 fragCoord ){\n vec2 p=(-iResolution.xy+2.*fragCoord.xy)/iResolution.y,\n m=iMouse.xy/iResolution.xy;  //mouse\n vec3 o,i;\n setCam(o,i,iTime,m.y+.2);//camMovement\n const float roll=0.,lens=2.;//camRoll,CamLensLength\n vec3 d=normalize(calcLookAtMatrix(o,i,roll)*vec3(p.xy,lens));//ray.direction\n vec3 c=vec3(0);\n float t=rm(o,d);//Distance.raymarched\n if(t>-.5){\n  vec3 p=o+t*d,n=getN(p); //position & normal\n  vec4 m=material(p,n);   //material\n  c=light(p,n,d,t,m);}    //light\n c=ff_filmic_gamma3(c*.6);//gamma\n //c=pow( clamp(col,0.0,1.0), vec3(0.4545) );\n r=vec4(c,1.);}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}