{
    "Shader": {
        "info": {
            "date": "1609550726",
            "description": "The radially symmetrical brick wall low pass filter.\nIt's power spectrum is an Airy Disk: https://en.wikipedia.org/wiki/Airy_disk\n\nThe kernel radius scales with the horizontal mouse position.\n",
            "flags": 32,
            "hasliked": 0,
            "id": "wldcR2",
            "likes": 7,
            "name": "Radially Symmetrical LP Filter",
            "published": 3,
            "tags": [
                "filter",
                "lowpass"
            ],
            "usePreview": 0,
            "username": "TinyTexel",
            "viewed": 492
        },
        "renderpass": [
            {
                "code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\n    The radially symmetrical brick wall low pass filter.\n    It's spectral power spectrum is an Airy Disk: https://en.wikipedia.org/wiki/Airy_disk\n    \n    The kernel radius scales with the horizontal mouse position.\n    \n    See BufferA for the kernel.\n*/\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{\n    vec2 tc = uv0/iResolution.xy;\n    \n    vec3 col = vec3(0.0);\n    \n    if (tc.x > 0.5)\n    {\n        // spectrum 2d plot\n        float dc = length(textureLod(iChannel1, (vec2(SIZE*0.5+0.5)/iResolution.xy), 0.).xy);\n        vec2 dft = texelFetch(iChannel1, ivec2(uv0-0.5-vec2(SIZE,0.0)), 0).xy;\n        \n        float amp = length(dft); \n        \n        float s = 0.9;\n        amp *= s;\n        dc *= s;\n        \n        col = vec3(amp);\n\n        if(amp <= exp2(-13.0)) col = vec3(1.0, 0.0, 0.0)*0.25;\n        if(amp <= exp2(-16.0)) col = vec3(1.0, 0.5, 0.0)*0.25;\n        \n        //if(amp <= dc) col = vec3(1.0, 0.0, 1.0);\n    }\t\n    else\n    {\n        // kernel 2d plot\n        float n = textureLod(iChannel0, tc, 0.).r;\n        n *= 32.0;\n        //n= n*0.5+0.5;\n        col = vec3(abs(n));\n        if(n < 0.0) col *= vec3(1.0, 0., 0.0);\n        \n        col = pow(col, vec3(1.0/2.2));\n    }\n    \n    // kernel 1d plot\n    if (uv0.y > SIZE && uv0.x < SIZE)\n    {\n        vec2 tc = (uv0 - vec2(0.0, SIZE)) / (iResolution.xy - SIZE);\n        \n        float v = 0.0;\n        \n        float f = texelFetch(iChannel0, ivec2(vec2(tc.x*SIZE, SIZE*0.5)), 0).r;\n        \n        f *= 1.;\n        \n        //f = sqrt(abs(f*2.0)) * sign(f);\n        //f = (1.0 - exp2(-abs(f)*2.0))*sign(f);\n        \n        col = vec3(0.0);\n        \n        // antialias plot (lazy brute force)\n        float count = 8.0;\n        for(float i = -count; i <= count; ++i)\n        {\n            float h = (tc.y + (i/count*1.) / (iResolution.y - SIZE)) * 2.0 - 1.0;\n            h += 0.25;\n\n            v = f < h ? 0.0 : 1.0;\n\n            col +=  mix(vec3(v), mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.02, 0.1), v), bvec3(h <= 0.0));\n        }\n        col /= count*2.0+1.0;\n        \n        col = pow(col, vec3(1.0/2.2));\n        \n    }\n    \n    // spectrum 1d plot\n    if (uv0.y > SIZE && uv0.x > SIZE)\n    {\n        vec2 tc = (uv0 - SIZE) / (iResolution.xy - SIZE);\n        \n        float v = 0.0;\n        \n        float f = length(texelFetch(iChannel1, ivec2(vec2(SIZE*0.5 + (tc.x-0.5)*SIZE, SIZE*0.5+ (tc.x-0.5)*SIZE)), 0).xy);// diagonal cross section\n        //float f = length(texelFetch(iChannel1, ivec2(vec2(SIZE*0.5 + (tc.x-0.5)*SIZE, SIZE*0.5)), 0).xy);// horizontal cross section\n        \n        f *= 0.75;\n        \n        //v = f < tc.y ? 0.0 : 1.0;\n        v = smoothstep(0.0, 1.0, (f - tc.y) * (iResolution.y - SIZE) * 0.5);\n        \n        col = vec3(v) * vec3(0.25, 1.0, 0.75);\n    }\n\n    outCol = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\n    The radially symmetrical brick wall low pass filter.\n    It's power spectrum is an Airy Disk: https://en.wikipedia.org/wiki/Airy_disk\n*/\n\nfloat LP(float x) { return x == 0.0 ? Pi * 0.25 : BesselJ1(x * Pi) / x * 0.5; }\n\nfloat LP_HalfLaplacian(float x)\n{\n    float xx = x*x;\n    return xx == 0.0 ? Pi/6.0 : (BesselJ1(x * Pi) * (2.0 * x - StruveH0(x * Pi)) + BesselJ0(x * Pi) * StruveH1(x * Pi)) / (4.0 * xx);\n}\n\nfloat Sinc(float x) { return x == 0.0 ? 1.0 : sin(x * Pi) / (x * Pi); }\n\n\nfloat Map(uvec2 uv)\n{\n    vec2 tc = vec2(uv);\n    \n    float signal = 0.0;\n    \n    float count = .0;// count of aliases in spatial domain (>0 reduces artifacts resulting from kernel truncation)\n    for(float i = -count; i <= count; ++i)\n    for(float j = -count; j <= count; ++j)\n    {\n        vec2 off = vec2(i, j) * SIZE;\n        vec2 tc2 = tc.xy+off-SIZE*0.5;\n        float l = length(tc2);\n\n        l *= mix(1.0/64.0, 1.0, Pow2(1.0-(iMouse.x/iResolution.x)));\n\n       #if 1\n        signal += LP(l);\n       #elif 1\n        signal += LP_HalfLaplacian(l);\n       #elif 1\n        signal += Sinc(l);// nope\n       #endif\n    }\n    \n    return signal;\n}\n\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{\n    if(uv0.x > SIZE || uv0.y > SIZE)\n    {\n        discard;\n        return;\n    }\n    \n    \n    uvec2 uv = uvec2(uv0 - 0.5);\n    \n    float v = Map(uv);\n    \n    outCol = vec4(v, 0.0, 0.0, 1.0);\n    \n    return;\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Horizontal + Vertical Discrete Fourier Transform of the input \n//adapted from FabriceNeyret2's https://www.shadertoy.com/view/XtScWt\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b)); } \n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord )\n{\n   \tfragColor = vec4(0);\n    \n    vec2 uv = fragCoord.xy - 0.5;\n    \n    if(fragCoord.x >= SIZE || fragCoord.y >= SIZE) {fragColor = vec4(20.0); return;}\n    \n    for(float i = 0.; i < SIZE; i++)  \n\t{\n\t\tvec2 xn = texelFetch(iChannel0, ivec2(i, uv.y), 0).rg;\n        vec2 yn = texelFetch(iChannel1, ivec2(uv.x, i), 0).ba;\n\t\tvec2 ang = - 6.2831853 * (uv -SIZE/2.) * i/SIZE;\n\t\tfragColor.zw += cmul(xn, ang.x);\n\t\tfragColor.xy += cmul(yn, ang.y);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n  #define SIZE (floor(iResolution.y/2.25)*2.)\n\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\n\nvec2 cossin(float x) { return vec2(cos(x), sin(x)); }\n\nvec2 cmul(vec2 c0, vec2 c1)\n{\n\treturn vec2(c0.x * c1.x - c0.y * c1.y, \n\t\t        c0.y * c1.x + c0.x * c1.y);\n}\n\n\nuint  asuint2(float x) { return x == 0.0 ? 0u : floatBitsToUint(x); }\nuvec2 asuint2(vec2 x) { return uvec2(asuint2(x.x ), asuint2(x.y)); }\nuvec3 asuint2(vec3 x) { return uvec3(asuint2(x.xy), asuint2(x.z)); }\nuvec4 asuint2(vec4 x) { return uvec4(asuint2(x.xy), asuint2(x.zw)); }\n\nfloat Float01(uint x) { return float(    x ) * (1.0 / 4294967296.0); }\nfloat Float11(uint x) { return float(int(x)) * (1.0 / 2147483648.0); }\n\nvec2 Float01(uvec2 x) { return vec2(      x ) * (1.0 / 4294967296.0); }\nvec2 Float11(uvec2 x) { return vec2(ivec2(x)) * (1.0 / 2147483648.0); }\n\nvec3 Float01(uvec3 x) { return vec3(      x ) * (1.0 / 4294967296.0); }\nvec3 Float11(uvec3 x) { return vec3(ivec3(x)) * (1.0 / 2147483648.0); }\n\nvec4 Float01(uvec4 x) { return vec4(      x ) * (1.0 / 4294967296.0); }\nvec4 Float11(uvec4 x) { return vec4(ivec4(x)) * (1.0 / 2147483648.0); }\n\nconst uint rPhi1  = 2654435761u;\n\nconst uint rPhi2a = 3242174893u;\nconst uint rPhi2b = 2447445397u;\n\nconst uint rPhi3a = 3518319149u;\nconst uint rPhi3b = 2882110339u;\nconst uint rPhi3c = 2360945581u;\n\nconst uint rPhi4a = 3679390609u;\nconst uint rPhi4b = 3152041517u;\nconst uint rPhi4c = 2700274807u;\nconst uint rPhi4d = 2313257579u;\n\nconst uvec2 rPhi2 = uvec2(rPhi2a, rPhi2b);\nconst uvec3 rPhi3 = uvec3(rPhi3a, rPhi3b, rPhi3c);\nconst uvec4 rPhi4 = uvec4(rPhi4a, rPhi4b, rPhi4c, rPhi4d);\n\nuint  Roberts(uint  off, uint n) { return off + rPhi1 * n; }\nuvec2 Roberts(uvec2 off, uint n) { return off + rPhi2 * n; }\nuvec3 Roberts(uvec3 off, uint n) { return off + rPhi3 * n; }\nuvec4 Roberts(uvec4 off, uint n) { return off + rPhi4 * n; }\n\n\n\n// https://www.shadertoy.com/view/Wt3czM | Bessel J0/J1 + Struve H0/H1\n\n// https://link.springer.com/article/10.1007/s40314-020-01238-z\nfloat BesselJ0(float x)\n{\n    float xx = x * x;\n    float lamb = 0.865;\n    float q    = 0.7172491568;\n    float p0   = 0.6312725339;\n    float ps0  = 0.4308049446;\n    float p1   = 0.3500347951;\n    float ps1  = 0.4678202347;\n    float p2   =-0.06207747907;\n    float ps2  = 0.04253832927;\n\n    float lamb4 = (lamb * lamb) * (lamb * lamb);\n    float t0 = sqrt(1.0 + lamb4 * xx);\n    float t1 = sqrt(t0);\n    \n    return xx == 0.0 ? 1.0 : 1.0/(t1 * (1.0 + q * xx)) * ((p0 + p1*xx + p2*t0) * cos(x) + ((ps0 + ps1*xx) * t0 + ps2*xx) * (sin(x)/x));\n}\n\n// https://www.sciencedirect.com/science/article/pii/S2211379718300111\nfloat BesselJ1(float x)\n{\n    float xx = x * x;\n\n    return (sqrt(1.0 + 0.12138 * xx) * (46.68634 + 5.82514 * xx) * sin(x) - x * (17.83632 + 2.02948 * xx) * cos(x)) /\n           ((57.70003 + 17.49211 * xx) * pow(1.0 + 0.12138 * xx, 3.0/4.0) );\n}\n\n// https://research.tue.nl/nl/publications/efficient-approximation-of-the-struve-functions-hn-occurring-in-the-calculation-of-sound-radiation-quantaties(c68b8858-9c9d-4ff2-bf39-e888bb638527).html\nfloat StruveH0(float x)\n{\n    float xx = x * x;\n\n    return BesselJ1(x) + 1.134817700  * (1.0 - cos(x))/x - \n                         1.0943193181 * (sin(x) - x * cos(x))/xx - \n                         0.5752390840 * (x * 0.8830472903 - sin(x * 0.8830472903))/xx;\n}\n\n// https://research.tue.nl/nl/publications/efficient-approximation-of-the-struve-functions-hn-occurring-in-the-calculation-of-sound-radiation-quantaties(c68b8858-9c9d-4ff2-bf39-e888bb638527).html\nfloat StruveH1(float x)\n{\n    const float pi = 3.14159265359;\n\n    float xx = x * x;\n\n    return 2.0/pi - BesselJ0(x) + 0.0404983827 * sin(x)/x + \n                                  1.0943193181 * (1.0 - cos(x))/xx - \n                                  0.5752390840 * (1.0 - cos(x * 0.8830472903))/xx;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}