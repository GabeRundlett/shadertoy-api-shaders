{
    "Shader": {
        "info": {
            "date": "1639311667",
            "description": "1st place of Tokyo Demo Fest 2021 Graphics Compo",
            "flags": 32,
            "hasliked": 0,
            "id": "7t3Gz7",
            "likes": 43,
            "name": "[TDF2021]Toy Duck",
            "published": 3,
            "tags": [
                "duck",
                "cloth",
                "tdf",
                "fabric"
            ],
            "usePreview": 1,
            "username": "EvilRyu",
            "viewed": 637
        },
        "renderpass": [
            {
                "code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// 4kb executable for Tokyo Demo Fest 2021 Graphics Compo\n\n\n// This FXAA pass brings some fluffy effect on the fabric part of the final image\n#define REDUCE_MUL (1. / 8.)\n#define REDUCE_MIN (1. / 128.)\n#define INTENSITY 3.1\n\nfloat rgb2luma(vec4 col)\n{\n\treturn col.y *(.587 / .299) + col.x;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord / iResolution.xy;\n\tvec2 eps = 2. / iResolution.xy;\n\n\tfloat topLeft   = rgb2luma(texture(iChannel0, uv + vec2(-eps.x, eps.y)));\n\tfloat topRight  = rgb2luma(texture(iChannel0, uv + eps.xy));\n\tfloat downLeft  = rgb2luma(texture(iChannel0, uv - eps.xy));\n\tfloat downRight = rgb2luma(texture(iChannel0, uv + vec2(eps.x, -eps.y)));\n\tfloat center    = rgb2luma(texture(iChannel0, uv));\n\n\tvec2 dir        = vec2((topLeft + topRight) - (downLeft + downRight),\n\t\t                  (downLeft + topLeft) - (downRight + topRight));\n\tfloat dirReduce = max((downLeft + downRight + topLeft + topRight) * REDUCE_MUL * 0.25, REDUCE_MIN);\n\tfloat dirMin    = 1. / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n\tdir             = min(vec2(INTENSITY), max(-vec2(INTENSITY), dir * dirMin)) * eps.xy;\n\n\tvec4 colA       = (texture(iChannel0, uv - .166667 * dir) + texture(iChannel0, uv + .166667 *dir)) *.5;\n\tvec4 colB       = colA *.5 + .25 * (texture(iChannel0, uv - .5 * dir) + texture(iChannel0, uv + .5 * dir));\n\tfloat LumB = rgb2luma(colB);\n\n\tif (LumB < min(center, min(min(downLeft, downRight), min(topLeft, topRight))) ||\n\t\tLumB > max(center, max(max(downLeft, downRight), max(topLeft, topRight))))\n\t\tfragColor = colA;\n\telse\n\t\tfragColor = colB;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define MAT_HEAD 0.\n#define MAT_BODY 1.\n#define MAT_SCARF 2.\n#define MAT_BEAK 3.\n#define MAT_BALL 4.\n#define MAT_CARPET 5.\n#define MAT_TORUS 6.\n\n#define PI 3.1415926535\n\nvoid rot2d(inout vec2 p, float t)\n{\n    float ct = cos(t), st = sin(t);\n    vec2 q = p;\n    p.x = ct * q.x + st * q.y;\n    p.y = -st * q.x + ct * q.y;\n}\n\nvec2 hash22(vec2 p)\n{\n    p = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n    return fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\n\n// iq: https://www.shadertoy.com/view/XdXBRH\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    vec2 u = f * f * (3. - 2. * f);\n    vec2 du = 6. * f * (1. - f);\n\n    vec2 ga = hash22(i + vec2(0));\n    vec2 gb = hash22(i + vec2(1, 0));\n    vec2 gc = hash22(i + vec2(0, 1));\n    vec2 gd = hash22(i + vec2(1));\n\n    float va = dot(ga, f - vec2(0));\n    float vb = dot(gb, f - vec2(1, 0));\n    float vc = dot(gc, f - vec2(0, 1));\n    float vd = dot(gd, f - vec2(1));\n\n    return vec3(va + u.x * (vb - va) + u.y * (vc - va) + u.x * u.y * (va - vb - vc + vd),  // value\n                ga + u.x * (gb - ga) + u.y * (gc - ga) + u.x * u.y * (ga - gb - gc + gd) + // derivatives\n                    du * (u.yx * (va - vb - vc + vd) + vec2(vb, vc) - va));\n}\n\nvec2 fibers(vec2 p)\n{\n    vec3 f = noised(p) + noised(p* vec2(2.6, 1.3)) * vec3(.64, .3, .3);\n    return f.yz;\n}\n\n// it's not very useful eventually\nvec3 cloth(vec2 p)\n{\n    float c = (2. * smoothstep(-1., 1., sin(p.x * 100.)) - 1.) * (2. * smoothstep(-1., 1., sin(p.y * 100.)) - 1.);\n    c = smoothstep(-.2, .2, c);\n    return normalize(vec3(mix(fibers(p * vec2(4., 300.)), fibers(p * vec2(300., 4.)), c), 1));\n}\n\nfloat noise(vec3 p)\n{\n    const vec3 s = vec3(7, 157, 113);\n    vec3 ip = floor(p);\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p -= ip;\n    p = p * p * (3. - 2. * p);\n    h = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\nfloat fbm(vec3 p)\n{\n    mat3 m = mat3(.0, .8, .6, -.8, .36, -.48, -.6, -.48, .64);\n    float f = 0., s = .5;\n    for (int i = 0; i < 4; ++i)\n    {\n        f += s * noise(p);\n        p = m * p * 2.01;\n        s *= .5;\n    }\n\n    return f;\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(.5 + .5 * (b - a) / k, .0, 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nvec2 opU(vec2 obj0, vec2 obj1)\n{\n    return obj0.x < obj1.x ? obj0 : obj1;\n}\n\nvec2 opSU(vec2 obj0, vec2 obj1, float s)\n{\n    return vec2(smin(obj0.x, obj1.x, s), obj0.x < obj1.x ? obj0.y : obj1.y);\n}\n\nfloat opOnion(float sdf, float thickness)\n{\n    return abs(sdf) - thickness;\n}\n\nfloat capsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\nfloat cylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat ellipsoid(vec3 p, vec3 r)\n{\n    float k0 = length(p / r);\n    return k0 * (k0 - 1.) / length(p / (r * r));\n}\n\n// This is the star pattern on duck's body\n// It's also used as displacement map for some fabric\nfloat starInner(vec2 f)\n{\n    rot2d(f, 1.6);\n    f = fract(f) * 2. - 1.;\n    float a = PI / 5.;\n    f.x = abs(f.x);\n    vec2 v = vec2(cos(a), sin(a));\n    for (int i = 0; i < 3; i++)\n        f -= 2. * min(0., dot(f, v)) * v, v = normalize(vec2(v.x - 1., v.y));\n\n    return abs(f.y - f.x * .9) - .4;\n}\n\nfloat star(vec3 p, float s)\n{\n    return starInner(vec2(atan(p.z, p.x), p.y * 3.) * s);\n}\n\nfloat box(vec2 p, vec2 b)\n{\n    vec2 d = abs(p) - b;\n    return smoothstep(0., .01, length(max(d, 0.0)) + min(max(d.x, d.y), .0));\n}\n\nfloat sph(vec2 p, float r)\n{\n    return p.x > 0. ? smoothstep(0., .01, length(p) - r) : 0.;\n}\n\n// T D F text\nfloat text(vec2 uv)\n{\n    uv*=.5;\n    rot2d(uv,.3);\n    uv += vec2(2.2, -1.5);\n    uv -= vec2(sin(uv.y) * .5, sin(uv.x) * .1);\n    float d =\n        min(box(uv, vec2(.4, .1)), min(box(uv + vec2(0, .5), vec2(.1, .4)), box(uv - vec2(.7, -.4), vec2(.1, .5))));\n    d = min(d, smoothstep(0., .01, sph(uv - vec2(.8, -.4), .5)) + abs(1. - sph(uv - vec2(.8, -.4), .3)) * 1.);\n    d = min(d, min(box(uv - vec2(1.6, -.4), vec2(.1, .5)), box(uv - vec2(1.95, 0), vec2(.25, .1))));\n    return min(d, box(uv - vec2(1.85, -.4), vec2(.15, .1)));\n}\n\n#define S(p,r) step(length(p)-r,.001)\n// Siggraph logo, TDF is held as a co-located event of SIGGRAPH ASIA\nfloat siggraph(vec2 p)\n{\n    p*=mat2(1,.7,-.7,1);\n    p-=vec2(3,-1);\n    float d=S(p,1.)*(1.-S(p*vec2(.49,1.),.55));\n    vec2 a=vec2(.41,1.1), b=vec2(.44,1.1), c=vec2(.0,.15), e=vec2(.1,.08);\n    d+=S(p*a-c,.4);\n    d*=1.-S(p*b*1.15-e, .42);\n    float k=S(p*a+c,.4) * (1.-S(p*b*1.15+e, .42));\n    \n    return 1.-max(k,d);\n}\n\nvec2 duck(vec3 p)\n{\n    vec3 p0 = p;\n\n    vec2 head =\n        vec2(capsule(p, vec3(0, 1. + sin(p.x) * .1, 0), vec3(0, .4, .1), .4 + sin(p.y * 10. - 4.) * .01), MAT_HEAD);\n    vec2 body = vec2(capsule(p - vec3(0, -.2, .13), vec3(0, .4, 0), vec3(0, -.5, 0), .37 + sin(p.y) * .02), MAT_BODY);\n\n    vec2 beak = vec2(\n        capsule((p - vec3(0, .1, -.5)) * vec3(1, 1.2, 1), vec3(0, .0, 0), vec3(0, .4, .3), .12 - sin(p.z) * .1) / 1.2,\n        MAT_BEAK);\n\n    rot2d(p0.xz, -.5);\n    p0 -= vec3(.1, 1.5, -.05);\n    p0.x = abs(p0.x) - .08;\n    rot2d(p0.xy, -.4);\n    rot2d(p0.yz, .5);\n    p0.z -= .1 * sin(p0.y * 8. - 1.);\n    p0.x = abs(p0.x) + .64;\n    vec2 hair = vec2(cylinder(p0.xzy, vec2(.68, .001)), MAT_HEAD);\n\n    p0 = p;\n    p0.x = abs(p0.x) - .45;\n    rot2d(p0.xz, -.4);\n\n    rot2d(p0.xy, -.3);\n    p0.y += .2;\n    vec2 wing = vec2(ellipsoid(p0, vec3(.3, .16, .04)), MAT_BEAK);\n\n    p0 = p;\n    rot2d(p0.yz, -.2);\n    float t = .01 * sin(p.x * 20.) + .07 * sin(p.x);\n    vec2 scarf =\n        vec2(cylinder(p0 - vec3(0, .15, .16),\n                      vec2(.38 + .005 * sin(p0.y * 50. - sin(p0.z) * 10. + .1 * sin(p0.x * 500. + p0.y * 500.)),\n                           .1 + t + .01 * sin(p0.y * 20. - 1.))),\n             MAT_SCARF);\n\n    scarf.x += .005 * smoothstep(.01, .0, abs(opOnion(p0.y -.035 + t, .0))) - .03;\n    scarf.x += .001 * smoothstep(.05, 0., star(p, iResolution.x / 55.));\n\n    p0 = p;\n    rot2d(p0.xy, .1);\n    p0 = vec3(abs(p0.x - .07) - .15, p0.y - .67, p0.z + .3);\n    vec2 eyes = vec2(cylinder(p0.xzy * vec3(.8, 1, 1), vec2(.04)), MAT_HEAD);\n\n    p0 = vec3(abs(p.x) - .25, p.y - .58, p.z + .3);\n    vec2 cheek = vec2(cylinder(p0.xzy * vec3(.8, 1, 1), vec2(.05, .1)), MAT_HEAD);\n\n    float l = (.003 - .0015 * sin(p.y * 300.));\n    head.x += l * smoothstep(.01, .0, abs(opOnion(p.x+.003*sin(p0.y*20.), .0)));\n    p0 = p;\n    rot2d(p0.yz, -0.2);\n    head.x += l * smoothstep(.01, .0, abs(opOnion(p0.z - .1, .0)));\n    head.x += .002 * smoothstep(.01, .0, abs(opOnion(eyes.x, .0)));\n    head.x += .002 * smoothstep(.0, .005, abs(opOnion(cheek.x, .0)));\n    head.x -= .005 * smoothstep(-.0, .07, abs(opOnion(scarf.x, .0)));\n    head.x += .0007 * smoothstep(.05, 0., star(p, iResolution.x / 95.));\n    \n    rot2d(p.yz, -.9);\n    beak.x += (.002 - .0015 * sin(p.z * 500.)) * smoothstep(.01, .0, abs(opOnion(p.y - .45, 0.)));\n\n    vec2 res = opSU(head, body, .05);\n    res = opSU(res, beak, .02);\n    res = opU(res, hair);\n    res = opSU(res, wing,.01);\n    res = opU(res, scarf);\n\n    return res;\n}\nvec2 polarRep(vec2 p, float n)\n{\n    n = PI * .5 / n;\n    float a = atan(p.y, p.x), r = length(p);\n    a = mod(a + n / 2., n) - n / 2.;\n    p = r * vec2(cos(a), sin(a));\n    return .5 * (p + p - vec2(1, 0));\n}\n\nfloat torus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n// the dots on the carpet, TDF logo\nfloat tdf(vec2 p)\n{\n    float t = 10., r = .05;\n    p *= 1.5;\n    rot2d(p, -.7);\n    p = p - vec2(1,.8);\n    for (int i = 6; i > 0; --i)\n    {\n        for (int j = 0; j < i; ++j)\n        {\n            t = min(t, smoothstep(.0, .05, length(p) - r));\n            p.y += 5. * r;\n        }\n        p.x -= 2.5 * r;\n        p.y -= 5. * float(i) * r - 2.5 * r;\n    }\n\n    return 1. - t;\n}\n\nfloat shadowRay = 0.;\nvec2 map(vec3 p)\n{\n    vec3 q = p + vec3(1.3, .45, .2);\n    vec2 ssph = vec2(1e10, 0);\n    q.y = abs(q.y);\n    for (int i = 0; i < 4; ++i)\n    {\n        vec2 qq = polarRep(q.xz, 3. - float(i * i) * .3);\n        ssph = opU(ssph, vec2(length(vec3(qq.x + float(i * i) * .05, q.y, qq.y)) - .07, MAT_BALL));\n        if (i == 2)\n            q.y -= .1;\n        else\n            q.y -= .2;\n    }\n    vec2 sph = vec2(length(p + vec3(1.3, .45, .2)) - .5, MAT_BALL);\n    \n    vec2 flr = vec2(p.y + 1.02 + .003 * smoothstep(.2, 0., starInner(p.xz * iResolution.x / 55.)) +\n                        .4 * sin((p.x + 10.) * (p.z + 7.) * .2) * smoothstep(0., 6., length(vec2(p.x + .6, p.z))),\n                    MAT_CARPET);\n    float k = .003 * smoothstep(.0, .005, abs(opOnion(pow(abs(sin(p.x * 10.)), 10.), .0)));\n    flr.x -= k;\n    vec2 back = vec2(abs(p.z - 2.5 - 0.2 * p.y - 0.1 * sin(p.x * p.y * 1. - 2.) * (1. - smoothstep(0., 10., length(vec2(p.x + .6, p.y))))),\n                     MAT_CARPET);\n    back.x += .003 * smoothstep(.05,.0, starInner(p.xy * iResolution.x / 55.)) + k;\n\n    flr = opSU(flr, back, .5);\n    flr.x -= .01 * tdf(p.xz);\n    flr.x -= .01 * text(p.xy);\n    flr.x -= .01 * siggraph(p.xy);\n\n    q = p + vec3(.5, .875, 1.);\n    k=.02 * sin(q.x * 15.);\n    vec2 to = vec2(torus(q, vec2(.4 + k + .01 * sin(q.z * 20.), .09 + .01 * sin(q.x * 10.))), MAT_TORUS);\n\n    vec2 edge =\n        vec2(torus(q*vec3(1,1.5,1), vec2(.55 + k + .01 * sin(q.z * 20.) - .1 * shadowRay, 1e-3)), MAT_TORUS);\n\n    to = opSU(to, edge, .11);\n    to.x += (.002 - .0015 * sin(atan(q.z,q.x) * 200.)) * smoothstep(.01, .0, abs(opOnion(edge.x - .03, 0.)));\n    to.x += .0001 * smoothstep(.05, 0., star(q, iResolution.x / 55.)) + .002*sin(atan(q.z,q.x)*20.);\n    to.x -= .001 * smoothstep(.1, .8, fbm(q * 300.));\n\n\n    vec2 res = opU(sph, flr);\n    res = opSU(res, ssph, .04);\n    res = opU(res, duck(p));\n\n    res = opU(res, to);\n\n    return res;\n}\n\nfloat shadow(vec3 ro, vec3 rd, float k)\n{\n    float res = 1., t = .01, h;\n    shadowRay = 1.;\n    for (int i = 0; i < 96; i++)\n    {\n        h = map(ro + rd * t).x;\n        res = min(res, k * h / t);\n        t += clamp(h, .005, .1);\n        if (res < .002 || t > 50.)\n            break;\n    }\n    shadowRay = 0.;\n    return max(res, .0);\n}\n\nfloat getAO(vec3 p, vec3 n)\n{\n    float occ = .0, sca = 1., h, d;\n    for (int i = 0; i < 5 && occ < .35; i++, sca*=.95)\n    {\n        h = 1e-5 + .1 * float(i) / 4.;\n        d = map(p + h * n).x;\n        occ += (h - d) * sca;\n    }\n\n    return clamp(1. - 3. * occ, .1, 1.) * (.5 + .5 * n.y);\n}\n\nfloat sss(vec3 p, vec3 n, float d, float i) \n{ \n    float o,v; \n    for(o=0.;i>0.;i--) \n        o+=(i*d+map(p+n*i*d).x)/exp2(i); \n    return o; \n}\n\nvec2 intersect(vec3 ro, vec3 rd)\n{\n    float t = .1;\n\n    vec2 res = vec2(1e10, 0);\n\n    for (int i = 0; i < 256; ++i)\n    {\n        if (res.x < .005 * t || t > 100.)\n            break;\n\n        res = map(ro + t * rd);\n        t += res.x * .5;\n    }\n\n    return vec2(t, res.y);\n}\n\nvec3 getNormal(vec3 p, float t)\n{\n    vec3 n = vec3(0);\n    for (int i = 0; i < 4; i++)\n    {\n        vec3 e = .5773 * (2. * vec3((((i + 3) >> 1) & 1), ((i >> 1) & 1), (i & 1)) - 1.);\n        n += e * map(p + .001 * e * t).x;\n    }\n    return normalize(n);\n}\n\nvec3 SHIrradiance(vec3 n)\n{\n    return (vec3(.11959, .09155, .09027) * (n.x * n.x - n.y * n.y) + vec3(-.13644, -.10004, -.1046) * n.z * n.z +\n            vec3(.50681, .37237, .35038) + vec3(.27551, .21303, .22091) * n.x * n.y +\n            vec3(-.07177, -.05691, -.05647) * n.x * n.z + vec3(-.04908, -.04005, -.03579) * n.y * n.z +\n            vec3(.36545, .27871, .28709) * n.x + vec3(.22691, .17525, .17384) * n.y +\n            vec3(-.11745, -.09585, -.08932) * n.z);\n}\n\nvec3 bump_mapping(vec3 p, vec3 n, float weight)\n{\n    vec3 g = cloth(p.xy) * abs(n.z) + cloth(p.xz) * abs(n.y) + cloth(p.yz) * abs(n.x);\n    g = (g - n * dot(g, n));\n    return normalize(n + g * weight);\n}\n\n\nstruct Material\n{\n    vec3 baseCol, specularCol;\n    float roughness;\n};\n\nfloat specularBRDF(float roughness, vec3 n, vec3 v, vec3 l)\n{\n    vec3 h = normalize(v + l);\n    float NoV = abs(dot(n, v)) + .1;\n    float NoL = clamp(dot(n, l), 0., 1.);\n    float NoH = clamp(dot(n, h), 0., 1.);\n    float D = (2. + 1. / roughness) * pow(max(1. - NoH * NoH, .0078125), 1. / roughness * .5) / (2. * PI);\n    return D / (4. * (NoL + NoV - NoL * NoV));\n}\n\nvec3 carpetCol = vec3(0.322,0.078,0.078);\n\nMaterial getMaterial(float id, vec3 n, vec3 v, vec3 l, vec3 p, out vec3 n2, float t)\n{\n    Material mate;\n    float s;\n    n2=n;\n    if (id == MAT_CARPET)\n    {\n        s = smoothstep(.1, .8, fbm(p * 100.));\n        n2 = bump_mapping(p * 50., n, mix(.1, .3, s));\n        mate.baseCol = mix(carpetCol, vec3(.490,.212,.212), s);\n        mate.baseCol = mix(mate.baseCol, vec3(.463,.278,.278), smoothstep(.2,.0,abs(sin(p.x * 10.))));\n        mate.baseCol = mix(mate.baseCol, vec3(.592,.169,.169), smoothstep(.2,.0,abs(sin(p.x * 20.-1.))));\n        mate.baseCol = mix(mate.baseCol, vec3(0), tdf(p.xz));\n        mate.baseCol = mix(vec3(1), mate.baseCol, text(p.xy));       \n        mate.baseCol = mix(vec3(1), mate.baseCol, siggraph(p.xy));\n\n        mate.roughness = .7;\n        mate.specularCol = vec3(0.604,0.455,0.455);\n    }\n    else if(id >= MAT_HEAD && id <= MAT_SCARF)\n    {\n        mate.baseCol = mix(vec3(1), vec3(.3, 0, 0), smoothstep(.05, .0, star(p, 2.)));\n        mate.roughness = .6;\n        mate.specularCol = vec3(1);\n        n2 = bump_mapping(p * 50., n, .2);\n\n        if (id == MAT_HEAD)\n        {\n            mate.baseCol = mix(vec3(1), vec3(.8), smoothstep(.05, .0, star(p, iResolution.x / 95.)));\n\n            float scale = 2.;\n            if (p.z < 0.)\n            {\n                vec2 q = p.xy;\n                rot2d(q, .1);\n                q = vec2(abs(q.x - .07) - .15, q.y - .68);\n                mate.baseCol *= pow(smoothstep(.009, .01, length(q * vec2(.8, 1.)) - .03 + sin(q.y * 50.) * .005), 10.);\n\n                q = vec2(abs(p.x) - .25, p.y - 0.58);\n                float k = 1. - smoothstep(0., .001, length(q * vec2(.8, 1.)) - .05);\n                mate.baseCol = mix(mate.baseCol, vec3(.6, 0., 0.), k);\n                scale = mix(2., 100., k);\n            }\n        }\n        else if (id == MAT_SCARF)\n        {\n            mate.baseCol = vec3(.38, .02, .02);\n            mate.specularCol = vec3(1, .64, .64);\n        }        \n    }\n    else if (id == MAT_BEAK)\n    {\n        s = smoothstep(.4, .8, fbm(p * 4.));\n        n2 = bump_mapping(p * 50., n, mix(.2, .5, s));\n        mate.baseCol = mix(vec3(.561, .353, 0), vec3(1, .8, 0), s);\n        mate.roughness = .2;\n        mate.specularCol = vec3(.82, .655, 0);\n    }\n    else if (id == MAT_TORUS)\n    { \n        s = smoothstep(.1, .8, fbm(p * 300.));\n                \n        mate.baseCol = mix(vec3(.016,.082,.145), vec3(.004,.027,.055), s);\n        mate.specularCol = vec3(.208,.329,.431);\n        n2 = bump_mapping(p*50., n, .2);\n        mate.roughness = .5;\n    }\n\n    return mate;\n}\n\nvec3 scene(vec3 ro, vec3 rd, vec2 payload)\n{\n    float t = payload.x, mId = payload.y, sha,ao,k;\n\n    vec3 pos,n,n2,Ld1,Lc,Lp1,L1,drt,bac,bac2,sky,L2,indi,env,brdf,sca=vec3(0);\n\n    pos = ro + t * rd;\n    n2 = n = getNormal(pos, t);\n\n    Lp1 = vec3(1, 2, -1);\n    L1 = normalize(Lp1 - pos);\n    Ld1 = normalize(Lp1 - vec3(.3, 0, 0));\n    Lc = vec3(.973, .902, .749) * smoothstep(.75, .85, dot(L1, Ld1));\n\n    Material mate = getMaterial(mId, n, -rd, L1, pos, n2, t);\n    sha = shadow(pos + .001 * n2, L1, 10.);\n    ao = getAO(pos + .0001 * n2, n2);\n    drt = max(0., dot(n2, L1)) * 5. * Lc;\n    bac = max(0., dot(n2, -L1)) * 1.5 * Lc * carpetCol * smoothstep(.3, -.5, pos.y);\n    bac2 = max(0., -n2.y) * 2. * Lc * carpetCol * smoothstep(.5, .0, pos.y);\n    sky = max(0., n2.y) * vec3(.627, .906, .973);\n    \n    L2 = vec3(-1.4, -.45, -.2)-pos;\n    k=length(L2);\n    indi = max(0., dot(n2,L2/k))*vec3(.549,.2,.012) * exp(-k);\n    \n    env = 2. * SHIrradiance(n2) * exp(-length(rd.xy));\n    \n    brdf = mate.baseCol / PI + specularBRDF(mate.roughness, n, -rd, L1) * mate.specularCol;\n\n   \n    if(mId == MAT_BALL)\n    {\n        sca=sss(pos,-n,.6,20.)*vec3(.925,.612,.318)*2.;\n        sca*=sca;\n        float spe=pow(max(0.,dot(rd,reflect(Ld1,n))), 24.);\n        float fre=clamp(1.-dot(n,-rd),0.,1.);\n        brdf=vec3(.549,.200,.012)/PI+spe*.5*fre;\n        indi = vec3(0);\n    }\n\n    return (drt * sha + (sca + bac + bac2 + sky + env + indi) * ao) * brdf * .2;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 p=(2.*uv-1.)*iResolution.xy/iResolution.y;\n    \n    vec3 ro = vec3(0, .1, -3.8), ta = vec3(-.6, .1, 1), l,r,u,rd,col=vec3(0);\n    float time = iTime;\n\n    vec2 m = vec2(0.5);\n\n    if (iMouse.z > .0)\n    {\n        m = iMouse.xy / iResolution.xy;\n        float an = 2.0 + 0.3 * time - 12.0 * (m.x - 0.5);\n        ro = vec3(abs(ro.z) * sin(an), 0.2, abs(ro.z) * cos(an));\n    }\n\n    l = normalize(ta - ro);\n    r = normalize(cross(vec3(0, 1, 0), l));\n    u = normalize(cross(l, r));\n\n    rd = normalize(mat3(r, u, l) * vec3(p.xy, 2));\n\n    vec2 res = intersect(ro, rd);\n\n    float t = res.x;\n\n    if (t < 100.)\n    {\n        col = scene(ro, rd, res);\n    }\n  \n    col = pow(col*vec3(2.8,2.79,2.78),vec3(.585));\n    col = (col*(2.51*col+.03))/(col*(2.43*col+.59)+.14);\n    col *= .5 + .5 * pow(16. * uv.x * uv.y * (1. - uv.x) * (1. - uv.y), .15);\n    fragColor.xyz = col;\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}