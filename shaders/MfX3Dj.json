{
    "Shader": {
        "info": {
            "date": "1703529051",
            "description": "Trying out some stuff",
            "flags": 0,
            "hasliked": 0,
            "id": "MfX3Dj",
            "likes": 2,
            "name": "Trees and sky",
            "published": 3,
            "tags": [
                "sdf"
            ],
            "usePreview": 0,
            "username": "OfficeBatman",
            "viewed": 159
        },
        "renderpass": [
            {
                "code": "float bush(vec2 p) {\n    float k = 0.5;\n    float d = circle(p, .5);\n    // Add noise\n    d += mapRange(fbm(vec3(p, 0.)), 0., 1., -k, k * 0.2);\n    return d;\n}\n\nfloat tree(vec2 p) {\n    float k = 0.03;\n    float d = triangle(p, vec2(-.2, 0.), vec2(.2, 0.), vec2(0., .8));\n    d = min(d, triangle(p, vec2(-.25, -.5), vec2(.25, -.5), vec2(0., .2)));\n    // Add rounding\n    d -= .08;\n    // This allows the fbm noise in the next line to cut through the tree\n    d = max(d, -.08);\n    // Add noise\n    d += mapRange(fbm(vec3(p * 4., 0.)), 0., 1., -k, k);\n    d += mapRange(fbm(vec3(p * 4., 0.)), 0., 1., -.3, .2);\n    return sign(d) * pow(abs(d), .9);\n}\n\nfloat grassBlade(vec2 p, float k) {\n    p.x += 1.;\n    p *= rotate(-p.y * .28 * k);\n    p.x -= 1.;\n    return triangle(p, vec2(0), vec2(.1, 1.), vec2(.3, 0.));\n}\n\nfloat grass(vec2 p) {\n    float d = grassBlade(p, 1.);\n    d = min(d, grassBlade(p * vec2(-1., 1.) + vec2(.5, 0.), .3));\n    d = min(d, grassBlade(p * vec2(-1., 1.) + vec2(.7, 0.), .6));\n    return d;\n}\n\nfloat scene(vec2 p) {\n    float d = bush(p * .8 + vec2(1.4, 1.));\n    d = min(d, bush(2. * p + vec2(-2.8, 1.8)));\n    d = min(d, tree(p * rotate(-.2) + vec2(-.2, .6)));\n    d = min(d, grass(2. * (p + vec2(1.1, 1.)) * rotate(.4)));\n    return d;\n}\n\nconst vec3 sunColor = vec3(247, 197, 104) / 255.;\n\nvec4 bandColor(vec2 p) {\n    if (p.y < -.8) {\n        return vec4(232, 154, 81, 255) / 255.;\n    }\n    if (p.y < -.61) {\n        return vec4(232, 172, 81, 205) / 255.;\n    }\n    if (p.y < -.43) {\n        return vec4(247, 209, 84, 150) / 255.;\n    }\n    if (p.y < -.26) {\n        return vec4(247, 209, 84, 100) / 255.;\n    }\n    if (p.y < .1) {\n        return vec4(247, 209, 84, 30) / 255.;\n    }\n    return vec4(0);\n}\n\nvec3 skyColor(vec2 p) {\n    const vec3 bottom = vec3(74, 176, 207) / 255.;\n    const vec3 top = vec3(154, 222, 252) / 255.;\n    vec3 col = mapRange(p.y, -1., 1., bottom, top);\n    // Add bands\n    col = mix(col, bandColor(p).rgb, bandColor(p).a);\n    // Add pink gradient\n    vec3 pink = vec3(245, 161, 127) / 255.;\n    float t = pow(1.5 - abs(p.y + .25), 1.1);\n    t *= .38;\n    col = mix(col, pink, t);\n    return col;\n}\n\nvec3 color(vec2 p) {\n    float d = scene(p);\n    if (d <= 0.) {\n        vec3 col = vec3(58, 99, 90) / 255.;\n        d = abs(d);\n        // Shadow gradient\n        col *= mapRange(p.y, -1., 1., .2, 1.);\n        // Rim lighting\n        col += sunColor * mapRange(d*d, 0., .004, 2., 0.);\n        // Mix with background\n        float t = pow(mapRange(d*d, 0., .004, 1., 0.), 2.9);  \n        col = mix(col, skyColor(p), t);\n        return col;\n    }\n    return skyColor(p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = UV_SCALED;\n    vec3 col = color(uv);\n    \n    // Antialias\n    for (int i = -1; i < 2; i++) for (int j = -1; j < 2; j++) {\n       vec2 offset = vec2(i, j) * .001;\n       col += color(uv + offset);\n    }\n    col *= .1;\n    \n    fragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n#define IZERO (min(0, int(iTime)))\n#define FZERO (min(0., iTime))\n#define INF 1./FZERO\n\nfloat min_(float x1) {\n    return x1;\n}\n\nfloat min_(float x1, float x2) {\n    return min(x1, x2);\n}\n\nfloat min_(float x1, float x2, float x3) {\n    return min_(x1, min(x2, x3));\n}\n\nfloat min_(float x1, float x2, float x3, float x4) {\n    return min_(x1, x2, min(x3, x4));\n}\n\nfloat max_(float a) {\n    return a;\n}\n\nfloat max_(float a, float b) {\n    return max(a, b);\n}\n\nfloat max_(float a, float b, float c) {\n    return max(max(a, b), c);\n}\n\n#define CLAMP01(X) clamp((X), 0., 1.)\n\n// Vectors\n#define RIGHT vec3(1., 0., 0.)\n#define UP vec3(0., 1., 0.)\n#define FORWARD vec3(0., 0., 1.)\n#define ZERO vec3(0)\n\n// polynomial smooth min\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat mapRange(float x, float min1, float max1, float min2, float max2) {\n    return (clamp(x, min1, max1) - min1) * ((max2 - min2) / (max1 - min1)) + min2;\n}\n\nvec2 mapRange(float x, float min1, float max1, vec2 min2, vec2 max2) {\n    return mix(min2, max2, mapRange(x, min1, max1, 0., 1.));\n}\n\nvec3 mapRange(float x, float min1, float max1, vec3 min2, vec3 max2) {\n    return mix(min2, max2, mapRange(x, min1, max1, 0., 1.));\n}\n\n#define OP_SCALE(SDF, P, S) \\\n    SDF((P) / (S)) * (S)\n    \nmat2 rotate(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nmat3 rotateX(float a) {\n    return mat3(\n        1., 0., 0.,\n        0., cos(a), -sin(a),\n        0., sin(a), cos(a)\n    );\n}\nmat3 rotateY(float a) {\n    return mat3(\n        cos(a), 0., -sin(a),\n        0., 1., 0.,\n        sin(a), 0., cos(a)\n    );\n}\nmat3 rotateZ(float a) {\n    return mat3(\n        cos(a), -sin(a), 0.,\n        sin(a), cos(a), 0.,\n        0., 0., 1.\n    );\n}\n\n// Noise functions\n\nfloat hash2d(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat noise(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\t\n\tvec3 u = f*f*(3.0-2.0*f);\n    \n    vec2 ii = i.xy + i.z * vec2(5.0);\n    float a = hash2d( ii + vec2(0.0,0.0) );\n\tfloat b = hash2d( ii + vec2(1.0,0.0) );    \n    float c = hash2d( ii + vec2(0.0,1.0) );\n\tfloat d = hash2d( ii + vec2(1.0,1.0) ); \n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    \n    ii += vec2(5.0);\n    a = hash2d( ii + vec2(0.0,0.0) );\n\tb = hash2d( ii + vec2(1.0,0.0) );    \n    c = hash2d( ii + vec2(0.0,1.0) );\n\td = hash2d( ii + vec2(1.0,1.0) );\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n        \n    return max(mix(v1,v2,u.z),0.0);\n}\n\nfloat fbm(vec3 x)\n{\n    float r = 0.0;\n    float w = 1.0, s = 1.0;\n    for (int i=0; i<7; i++)\n    {\n        w *= 0.5;\n        s *= 2.0;\n        r += w * noise(s * x);\n    }\n    return r;\n}\n\n// Sdf\n\n#define TOUCHING(SDF, POS) (abs(SDF((POS))) < E_SURF)\n#define INSIDE(SDF, POS) (SDF((POS)) < E_SURF)\n\nfloat sphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat sphere(vec3 p) {\n    return sphere(p, 1.);\n}\n\nfloat box(vec3 p, vec3 b, float r) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat box(vec3 p, vec3 b) {\n    return box(p, b, 0.);\n}\n\nfloat box(vec3 p) {\n    return box(p, vec3(1));\n}\n\nfloat capsule(vec3 p, float r, float height) {\n    return length(p - (UP * clamp(p.y, r, height - r))) - r;\n}\n\nfloat plane(vec3 p) {\n\treturn p.y;\n}\n\nfloat cone(vec3 p, vec2 c, float h) {\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\nfloat roundCone(vec3 p, vec3 a, vec3 b, float r1, float r2) {\n  // sampling independent computations (only depend on shape)\n  vec3  ba = b - a;\n  float l2 = dot(ba,ba);\n  float rr = r1 - r2;\n  float a2 = l2 - rr*rr;\n  float il2 = 1.0/l2;\n    \n  // sampling dependant computations\n  vec3 pa = p - a;\n  float y = dot(pa,ba);\n  float z = y - l2;\n  float x2 = dot(pa*l2 - ba*y, pa*l2 - ba*y);\n  float y2 = y*y*l2;\n  float z2 = z*z*l2;\n\n  // single square root!\n  float k = sign(rr)*rr*rr*x2;\n  if( sign(z)*a2*z2>k ) return  sqrt(x2 + z2)        *il2 - r2;\n  if( sign(y)*a2*y2<k ) return  sqrt(x2 + y2)        *il2 - r1;\n                        return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat triangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat circle(vec2 p, float r) {\n    return length(p) - r;\n}\n\n\n#define NORMAL_SAMPLE_R 0.01\n#define DEFINE_GET_NORMAL(scene) \\\n    vec3 getNormal(vec3 p) \\\n    { \\\n        return normalize(vec3( \\\n            scene(vec3(p.x + NORMAL_SAMPLE_R, p.y, p.z)) - scene(vec3(p.x - NORMAL_SAMPLE_R, p.y, p.z)), \\\n            scene(vec3(p.x, p.y + NORMAL_SAMPLE_R, p.z)) - scene(vec3(p.x, p.y - NORMAL_SAMPLE_R, p.z)), \\\n            scene(vec3(p.x, p.y, p.z + NORMAL_SAMPLE_R)) - scene(vec3(p.x, p.y, p.z - NORMAL_SAMPLE_R)) \\\n        )); \\\n    }\n\n// Main\n#define SCREEN_TO_SCALED(X) ((2. * (X) - iResolution.xy) / iResolution.yy)\n#define UV_SCALED SCREEN_TO_SCALED(fragCoord.xy)\n#define MOUSE_SCALED SCREEN_TO_SCALED(iMouse.xy)\n\n// parameters should be normalized\nmat3 camera(vec3 forward, vec3 globalUp) {\n    vec3 right = cross(forward, globalUp);\n    vec3 up = cross(right, forward);\n    return mat3(right, up, forward);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}