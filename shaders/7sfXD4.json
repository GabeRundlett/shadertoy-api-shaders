{
    "Shader": {
        "info": {
            "date": "1618640618",
            "description": "Attempting to implement rotation, but am only able to rotate the xy pixel coordinates not the sphere itself. \n\nTrying to get better at this. Would appreciate comments and such suggesting how I might go about that.",
            "flags": 0,
            "hasliked": 0,
            "id": "7sfXD4",
            "likes": 2,
            "name": "RotatingSphere",
            "published": 3,
            "tags": [
                "sdf",
                "distortion",
                "sphere",
                "raymarcher",
                "rotation"
            ],
            "usePreview": 0,
            "username": "nialred",
            "viewed": 195
        },
        "renderpass": [
            {
                "code": "/*\n\nI DID NOT DO THIS ALONE:\n========================\n\nReferences:\nhttp://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\nhttps://michaelwalczyk.com/blog-ray-marching.html\nhttps://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-generating-camera-rays/generating-camera-rays\nhttps://www.shadertoy.com/view/4sdSDN\n\n*/\n\nconst int MAX_MARCHING_STEPS = 32; // Max steps you are willing to search for a \"hit\"\nconst float MAX_DIST = 1000.0; // Max distance to search for a \"hit\"\nconst float MIN_DIST = 0.0; // Where to start the march \nconst float EPSILON = 0.001; // How close you need to be to be considered a hit\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n};\n\n// I don't know where I should define this cause I don't know how this scales\n// once you introduce multiple shapes and whatnot, so I just made it global\nSphere sphere = Sphere(vec3(0.0, 0.0, 12.0), 3.0);\n\nvec3 ray_direction(float fieldOfView, vec2 size, vec2 uv) \n{ \n    float z = 1.0 / tan(radians(fieldOfView) / 2.0); // Distance to image plane\n    return normalize(vec3(uv, z));\n}\n\nfloat sphere_sdf(vec3 point)\n{\n    return length(point - sphere.center) - sphere.radius; // Return distance from sphere\n}\n\nfloat distort_surface(float freq, vec3 point)\n{\n    return sin(freq * point.x) * sin(freq * point.y) * sin(freq * point.z);\n}\n\nvoid rotate_2d(float freq, inout vec2 p)\n{\n    float c = cos(10.0*freq);\n    float s = sin(10.0*freq);\n    p = vec2((p.x*c) - (p.y*s), (p.x*s) + (p.y*c));\n}\n\nfloat map_world(vec3 point)\n{   \n    float displacement = distort_surface(cos(iTime/5.0)+200000000000000000000000000000000000.5, point); //500000000000.5\n    \n    float dist = sphere_sdf(point); // Distance from sphere \n    return dist + displacement;\n}\n\nfloat shortest_distance_to_surface(vec3 eye_pos, vec3 march_dir, float start, float end)\n{\n    float depth = start; // Starting point for ray march (0.0)\n    float dist = 0.0;    // Initalize distance from sphere variable\n    int i = 0;           \n    \n    while (i < MAX_MARCHING_STEPS)\n    {\n        dist = map_world(eye_pos + (depth * march_dir)); // Distance to sphere (distorted)\n        \n        if (dist < EPSILON) // If at the surface, return the depth from image plane\n        {\n            return depth;\n        }\n        \n        depth += dist;\n        \n        if (depth >= end) // If at the max marching distance, return the max value\n        {\n            return end;\n        }\n        \n        i += 1;\n     }\n     \n     return end;\n}\n\nvec3 estimate_normal(vec3 point)\n{   \n    vec3 step = vec3(EPSILON, 0.0, 0.0);\n    \n    float gradient_x = map_world(point + step) - map_world(point - step);\n    float gradient_y = map_world(point + step.yxz) - map_world(point - step.yxz);\n    float gradient_z = map_world(point + step.yzx) - map_world(point - step.yzx);\n    \n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n    \n    return normalize(normal);\n}\n\nfloat diffuse(vec3 current_pos, vec3 light_pos, vec3 normal)\n{\n    vec3 light_dir = normalize(light_pos - current_pos);\n    float intensity = max(0.0, dot(normal, light_dir));\n    return intensity;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    sphere.center = vec3(0.4*sin(iTime/5.0), 0.4*cos(iTime/5.0), 8.0 + sin(iTime/5.0));\n    \n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord/iResolution.xy) * 2.0 - 1.0;\n    float aspect_ratio = iResolution.x/iResolution.y;\n    uv.x = uv.x * aspect_ratio; // Account for image aspect ratio\n    \n    // Define camera position\n    vec3 cam_pos = vec3(0.0, 0.0, 0.0);\n    \n    // Define ray as vector from camera position to pixel position\n    rotate_2d(iTime/20.0, uv);\n    Ray ray = Ray(cam_pos, ray_direction(30.0, iResolution.xy, uv));\n      \n    // Define light position as a 3D vector\n    vec3 light_pos = vec3(0.0, 10.0, 0.0);\n    \n    // Find distance to surface\n    float dist = shortest_distance_to_surface(ray.origin, ray.direction, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) // If sphere doesn't exist at this pixel draw bg\n    {\n        // Eventually want to have the background be a cubic room \n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n    \n    else // If sphere does exist at this pixel, draw color accordingly using basic lighting\n    {\n        vec3 point = ray.origin + dist*ray.direction;\n        vec3 normal = estimate_normal(point);\n        float intensity = diffuse(point, light_pos, normal);\n        normal = vec3(1.0, 0.9, 1.0) * intensity;\n        fragColor = vec4(normal, 1.0);\n    }\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}