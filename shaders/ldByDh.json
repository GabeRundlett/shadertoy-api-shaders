{
    "Shader": {
        "info": {
            "date": "1542862992",
            "description": "This is \"Organix\", a procedural graphics I made in 2008, which was my 2nd ever raymarched SDF procedural drawing and which won the Function demoparty in Budapest [url]http://www.pouet.net/prod.php?which=51757[/url]",
            "flags": 32,
            "hasliked": 0,
            "id": "ldByDh",
            "likes": 53,
            "name": "Organix (made in 2008)",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "raymarching",
                "distancefield",
                "sdf"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 4425
        },
        "renderpass": [
            {
                "code": "// Copyright Inigo Quilez, 2018 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\n// This is \"Organix\", a procedural graphics I made in 2008, which was my 2nd ever\n// raymarched SDF bsaed image (I was still investigating and learning the technique).\n//\n// I just copy pasted the code here from the original C version, and adapted it\n// a bit to be more GLSL friendly. But I kept the variable names and all the\n// original structure and ugliness from 2008.\n//\n// Link to the original piece: https://www.pouet.net/prod.php?which=51757\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord / iResolution.xy;\n    float fra = clamp( 4.0*abs(uv.x-0.5)-1.1, 0.0, 1.0 );\n\n    vec3 col = vec3(0.0);\n    for( int m=-4; m<4; m++ )\n    for( int n=-4; n<4; n++ )\n    {\n        col += texture(iChannel0, uv + fra*vec2(m,n)/720.0).xyz;\n    }\n    col /= 81.0;\n\n\tfragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define ZERO (min(iFrame,0))\n\nint ihash( in int n )\n{\n\tn=(n<<13)^n;\n    return (n*(n*n*15731+789221)+1376312589) & 0x7fffffff;\n}\n\nfloat fhash( in int n )\n{\n\treturn float(ihash(n));\n}\n\nfloat noise2f( in vec2 p )\n{\n\tivec2 ip = ivec2(floor(p));\n    vec2  fp = fract(p);\n\tvec2 u = fp*fp*(3.0-2.0*fp);\n\n    int n = ip.x + ip.y*113;\n\n\tfloat res = mix(mix(fhash(n+(0+113*0)),\n                        fhash(n+(1+113*0)),u.x),\n                    mix(fhash(n+(0+113*1)),\n                        fhash(n+(1+113*1)),u.x),u.y);\n\n    return 1.0 - res*(1.0/1073741824.0);\n}\n\nfloat noise3f( in vec3 p )\n{\n\tivec3 ip = ivec3(floor(p));\n    vec3  fp = fract(p);\n\tvec3 u = fp*fp*(3.0-2.0*fp);\n\n    int n = ip.x + ip.y*57 + ip.z*113;\n\n\tfloat res = mix(mix(mix(fhash(n+(0+57*0+113*0)),\n                            fhash(n+(1+57*0+113*0)),u.x),\n                        mix(fhash(n+(0+57*1+113*0)),\n                            fhash(n+(1+57*1+113*0)),u.x),u.y),\n                    mix(mix(fhash(n+(0+57*0+113*1)),\n                            fhash(n+(1+57*0+113*1)),u.x),\n                        mix(fhash(n+(0+57*1+113*1)),\n                            fhash(n+(1+57*1+113*1)),u.x),u.y),u.z);\n\n    return 1.0 - res*(1.0/1073741824.0);\n}\n\nfloat fbm( in vec3 p )\n{\n    float f = 0.0;\n    float s = 0.5;\n    for( int i=ZERO; i<4; i++ )\n    {\n        f += s*noise3f(p);\n        p *= 2.0;\n        s *= 0.5;\n    }\n    return f;\n}\n\nvec2 celular( in vec3 p )\n{\n\tivec3 ip = ivec3(floor(p));\n\tvec3 f = fract(p); \n\n    vec2 dmin = vec2( 1.0, 1.0 );\n\n\tfor( int k=ZERO-1; k<=1; k++ )\n\tfor( int j=ZERO-1; j<=1; j++ )\n\tfor( int i=ZERO-1; i<=1; i++ )\n\t{\n\t\tint nn = (ip.x+i) + 57*(ip.y+j) + 113*(ip.z+k);\n        vec3 ra = vec3( fhash(nn     ),\n                        fhash(nn+1217),\n                        fhash(nn+2513) )/2147483647.0;\n\n        vec3 di = ra + vec3( float(i), float(j), float(k) ) - f;\n        float d2 = dot(di,di);\n\n        if( d2<dmin.x )\n        {\n            dmin.y = dmin.x;\n            dmin.x = d2;\n        }\n        else if( d2<dmin.y )\n        {\n            dmin.y = d2;\n        }\n\t}\n    return sqrt(dmin)*0.25;\n}\n\nfloat map( in vec3 pos, out vec4 suvw )\n{\n    float dis;\n\n\tfloat mindist = pos.y;\n\n\tsuvw = vec4(0.0,1.0,0.0,0.0);\n\n    //-----------------------------\n\t// rocas\n    if( pos.y<0.5 )\n    {\n    \tmindist -= 0.262 + 0.03*smoothstep( 0.0, 0.5, fbm(vec3(24.0*pos.x+7.7,2.0*pos.y,24.0*pos.z)) );\n    }\n\n    float chdis = 100.0;\n\n    float px = pos.x + 0.10*noise3f( 3.0*pos + vec3(0.00, 0.0, 0.0) );\n    float py = pos.y + 0.10*noise3f( 3.0*pos + vec3(0.70, 2.3, 0.5) );\n    float pz = pos.z + 0.10*noise3f( 3.0*pos + vec3(1.10, 7.6, 7.2) );\n\n    //-----------------------------\n\t// champi\n    if( pos.y<0.40 )\n\t{\n        float ischampi = noise2f( 2.0*pos.xz+vec2(0.0,7.6) );\n        if( ischampi > 0.0 )\n        {\n            float fx = mod( px+128.0, 0.15 ) - 0.075; \n            float fz = mod( pz+128.0, 0.15 ) - 0.075;\n\n            chdis = sqrt( fx*fx + fz*fz );\n\n            if( chdis<0.10 )\n            {\n                float cpy = py - (0.22 + 0.10*ischampi);\n                float gy = cpy*100.0;\n                if( gy<1.0 )\n                {\n                    gy = 1.0 - gy;\n                    float r = 0.07 + 6.0*gy*exp2(-3.0*gy);\n\n                    float ang = atan(fx,fz);\n                    float ani = 0.5+0.5*sin(11.0*ang);\n                    float gyb = clamp(0.15*gy,0.0,1.0);\n                    gyb = pow( gyb, 16.0 );\n\n                    r += 0.15*gyb;\n                    r += 0.20*ani*r;\n\n                    float ath = 0.5 + 0.05*sin(3.0*ang);\n                    float by = ((gy-3.0)*ath);\n                    if( by>0.0 && by<1.0 )\n                    {\n                        by = by*by;\n                        by = by*by;\n                        r += by*0.08*ani;\n                    }\n                    float sgy = clamp(gy*0.50-1.10,0.0,1.0);\n                    r += 0.06*sin(gy*12.0)*sgy*(1.0-sgy);\n\n                    r *= 0.0269775390625;\n\n                    dis = chdis - r;\n                    if( dis<mindist)\n                    {\n                        mindist = dis;\n                        suvw.x = 1.0;\n                        suvw.z = gy;\n                        suvw.w = ang;\n                    }\n                }\n            }\n        }\n\t}\n\n    //-----------------------------\n\t// arboles\n    {\n        px += 1.10*noise3f( 0.21*pos + vec3(0.00, 0.00, 0.00) );\n        py += 1.10*noise3f( 0.21*pos + vec3(0.70, 2.30, 0.50) );\n        pz += 1.10*noise3f( 0.21*pos + vec3(1.10, 7.60, 7.20) );\n\n        float fx = mod( px+128.0, 1.0 ) - 0.5;\n        float fz = mod( pz+128.0, 1.0 ) - 0.5;\n        float ra = 0.05/py;\n        dis = fx*fx + fz*fz - ra*ra;\n\n        if( dis<mindist )\n        {\n            float noao = smoothstep(0.5,0.6,pos.y);\n            suvw.y = clamp(chdis*15.0,0.0,1.0)*(1.0-noao) + noao;\n            mindist = dis;\n            suvw.x = 4.0;\n        }\n    }\n    \n    //-----------------------------\n\t// piedras voladoras\n\t{\n        vec3 ff = mod( vec3(px,py,pz)+vec3(128.0), 0.7 ) - 0.5;\n        dis = dot(ff,ff);\n        if( dis<(mindist+0.10)*(mindist+0.10))\n        {\n            suvw[0] = 3.0;\n            mindist = sqrt(dis)-0.10;\n            suvw[1] = 1.0;\n        }\n\t}\n\n    //-----------------------------\n\t// tubos!\n    if( pos.y>0.40 && pos.y<0.60 )\n\t{\n        float fx = mod( 2.0*px+128.0, 1.0 );\n        float fy = 2.0*pos.y;\n        float id = floor(2.0*px);\n        float cx = 0.25 + 0.25*noise3f( vec3(id*16.0,pos.z*2.0,2.0) );\n        float cy = 1.00 + 0.16*noise3f( vec3(pos.z*6.0,id*2.0,0.0) );\n        float wi = 0.05 + 0.01*noise3f( vec3(pos.z*48.0,id*16.0,0.0) );\n        dis = (fy-cy)*(fy-cy) + (fx-cx)*(fx-cx);\n        if( dis<(mindist+wi)*(mindist+wi) )\n        {\n            suvw.x = 2.0;\n            mindist = sqrt(dis)-wi;\n            suvw.y = 1.0;\n        }\n\t}\n\n    return mindist;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.0002;\n    vec4 kk;\n    vec3 nor;\n#if 0\n\tnor.x = map( vec3(pos.x+eps, pos.y, pos.z), kk ) - map( vec3(pos.x-eps, pos.y, pos.z), kk );\n\tnor.y = map( vec3(pos.x, pos.y+eps, pos.z), kk ) - map( vec3(pos.x, pos.y-eps, pos.z), kk );\n\tnor.z = map( vec3(pos.x, pos.y, pos.z+eps), kk ) - map( vec3(pos.x, pos.y, pos.z-eps), kk );\n#else\n    nor = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        nor += e*map(pos+eps*e, kk);\n    }\n#endif    \n\treturn normalize( nor );\n}\n\n\nfloat cast_ray( in vec3 ro, in vec3 rd, in float to, in float tMax, out vec4 suvw )\n{\n\tsuvw = vec4(0.0);\n\n\tfloat t = to;\n    for( int i=ZERO; i<512; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n\t\tfloat h = map( pos, suvw );\n        if( abs(h)<(0.0005*t) || t>tMax) break;\n        t += h*0.4;\n\t}\n    return t;\n}\n\nfloat bolasBump( in vec3 p )\n{\n    vec2 res = celular( vec3(32.0*p.x, 128.0*p.y, 32.0*p.z) );\n\treturn 1.0-2.0*res.x;\n}\n\nvec3 addbumpbolas( in vec3 xnor, float bumpa, in vec3 p )\n{\n#if 0\n    float kes = 0.0005;\n    float kk = bolasBump( p );\n    xnor.x += bumpa*(bolasBump( p+vec3(kes, 0.0, 0.0) )-kk);\n    xnor.y += bumpa*(bolasBump( p+vec3(0.0, kes, 0.0) )-kk);\n    xnor.z += bumpa*(bolasBump( p+vec3(0.0, 0.0, kes) )-kk);\n    return normalize(xnor);\n#else\n    // klems' trick to prevent the DX compiler from inlining the bump function\n    vec4 n = vec4(0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec4 s = vec4(p, 0);\n        s[i] += 0.0005;\n        n[i] = bolasBump(s.xyz);\n    }\n    return normalize(xnor + bumpa*(n.xyz-n.w));\n#endif    \n}\n\nfloat champyBump( in vec3 p )\n{\n\tfloat f = fbm( 256.0*p );\n\treturn f*f;\n}\n\nvec3 addbumpchampy( in vec3 xnor, float bumpa, in vec3 p )\n{\n#if 0\n    float kes = 0.0005;\n    float kk = champyBump( p );\n    xnor.x += bumpa*(champyBump( p+vec3(kes, 0.0, 0.0 ) )-kk);\n    xnor.y += bumpa*(champyBump( p+vec3(0.0, kes, 0.0 ) )-kk);\n    xnor.z += bumpa*(champyBump( p+vec3(0.0, 0.0, kes ) )-kk);\n    return normalize(xnor);\n#else\n    // klems' trick to prevent the DX compiler from inlining the bump function\n    vec4 n = vec4(0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec4 s = vec4(p, 0);\n        s[i] += 0.0005;\n        n[i] = champyBump(s.xyz);\n    }\n    return normalize(xnor + bumpa*(n.xyz-n.w));\n#endif    \n}\n\nvec3 shade( in vec3 pos, in vec3 nor,\n\t\t\tin vec3 ro,  in vec3 rd,\n\t\t\tfloat matID, float dis, in vec3 uvw )\n{\n\tvec3 xnor = nor;\n    vec3 rgb = vec3(0.0);\n\n\t// materials\n\tfloat fakeao = 1.0;\n\n    // piedras suelo\n    if( matID<0.5 )\n    {\n\t\tvec2 res = celular( vec3(96.0*pos[0], 12.0*pos[1], 96.0*pos[2]) );\n\t\tfloat ce = 5.0*(res[1]-res[0]);\n        rgb = vec3( sqrt(ce) );\n\t\tfloat fb = fbm( 8.0*pos );\n        vec3 cosa2 = vec3( 0.60, 0.50, 0.40 );\n        rgb = mix( rgb, cosa2, 0.5 + 0.5*fb );\n\n        rgb *= 0.21 + 0.14*fbm( 256.0*pos );\n\n\t\txnor = addbumpchampy( xnor, -3.0*4.0, pos );\n    }\n    // champis\n    else if( matID<1.5 )\n    {\n        float fb = fbm( 8.0*pos );\n\t\n\t\tvec2 res = celular( vec3(768.0*pos.x, 12.0*pos.y, 768.0*pos.z) );\n\t\tfloat am = 1.0-smoothstep(0.02,0.15,res.x);\n\t\tfloat cc = smoothstep(-0.75,-0.10,nor.y);\n\t\tam *= cc;\n\t\tam = 1.0-am;\n\n\n        vec3 arriba = mix( vec3( 0.50, 0.50, 0.50 ), vec3( 0.34, 0.26, 0.18 ), am );\n\n\t\tcc = 1.0-smoothstep(0.40,1.20,uvw.y);\n\n\t\trgb = vec3(0.45,0.40,0.30);\n\n\t\trgb *= 1.0 + 0.75*fbm(192.0*pos);\n\n\t\txnor = addbumpchampy( xnor, 2.0*clamp(1.75-0.40*uvw[1],0.0,1.0), vec3(0.25*uvw.z, 1.0*pos.y, 0.0) );\n\n\t\trgb = mix( rgb, arriba, cc );\n\t\tfloat spe = clamp(-dot(rd,xnor ),0.0,1.0);\n\t\tspe = 1.0 - spe;\n\t\tspe = spe*spe;\n\t\trgb += vec3(spe*0.50);\n\n\t\tfakeao = 1.0-clamp((uvw.y-5.25)*0.75,0.0,1.0);\n\t\t\n\t\tfakeao *= 1.0 - 0.25*(1.0-sin(11.0*uvw.z))*smoothstep(3.0,4.5,uvw.y);\n\t\tfloat ath = 0.5 + 0.05*sin(3.0*uvw.z);\n\t\tfloat by = (uvw.y-3.0)*ath;\n\t\tif( by>1.0 ) \n\t\tfakeao *= 0.20 + 0.80*clamp((by-1.0)*4.0,0.0,1.0);\n    }\n    // ramas\n    else if( matID<2.5 )\n    {\n\t\tvec2 res = celular( vec3(96.0*pos.x,256.0*pos.y, 96.0*pos.z) );\n\t\tfloat ce = 0.20 + 52.0*res.y*res.y*res.y;\n\n        rgb = vec3(0.80, 0.75, 0.65 ) * ce;\n\n\t\tfloat spe = clamp( 1.0+dot( rd, nor ), 0.0, 1.0 );\n\t\trgb += vec3(0.30, 0.15, 0.10) * spe;\n\n        xnor = addbumpchampy( xnor, -0.80*-3.0, vec3(1.0*pos.x, 1.0*pos.y, 0.5*pos.z) );\n        xnor = addbumpchampy( xnor,  0.60*-3.0, pos*0.5 );\n\n        rgb += vec3(0.07, 0.15,0.00) * (1.0-res.x*4.0);\n        rgb += vec3(0.25, 0.22,0.19);\n\n\t\t// verdin\n        float fb = smoothstep(-0.20,0.20, 0.30+fbm( vec3(158.0*pos.x, 158.0*pos.y, 1.0*pos.z) ));\n\t\tfloat var = 0.40*noise3f( vec3(4.0*pos.xy,64.0*pos.z));\n\t\tfb *= smoothstep(-0.10,0.10,xnor.y+var);\n\t\trgb *= vec3(1.0-0.70*fb,1.0-0.60*fb,1.0-0.70*fb);\n\t}   \n    // aliens\n    else if( matID<3.5 )\n    {\n\t\tfloat ks = 0.25;\n\t\tfloat ce = 0.00;\n\t\tfloat ss = 0.50;\n\t\tfor( int i=ZERO; i<8; i++ )\n\t\t{\n\t\t    vec2 res = celular( 74.0*pos*ks );\n\t\t    ce+=ss*res.x;\n\t\t    ss*=0.60;\n\t\t    ks*=2.0;\n\t\t}\n\t\tce = clamp(3.5*ce-0.30, 0.0, 1.0);\n        \n        rgb = vec3(0.20, 0.10, 0.0 ) + vec3(0.80*ce);\n\n\t\txnor = addbumpbolas( xnor, -6.0, pos );\n        \n        float fb = 0.15*clamp( fbm( 8.0*pos ), 0.0, 1.0 );\n\t\trgb.x -= fb;\n\t\trgb.z -= fb;\n\n        fb = fbm( vec3(128.0*pos.x, 4.0*pos.y, 128.0*pos.z) );\n\t\trgb *= 0.75+0.25*fb;\n\n        float ni = smoothstep( -0.10, 0.20, nor.y );\n\n        rgb = mix( rgb, vec3(0.09, 0.05, 0.04), ni );\n\n        // fres\n\t\tfloat spe = clamp( -dot( rd, xnor ), 0.0, 1.0 );\n\t\tspe = 1.0 - spe;\n\t\trgb += vec3(spe*spe*0.78);\n    }   \n    // suelo y arboles\n    else if( matID<4.5)\n    {\n        vec2 res = celular( vec3(96.0*pos.x, 12.0*pos.y, 96.0*pos.z) );\n\t\tfloat ce = 20.0*(res.y-res.x);\n        rgb = vec3(0.50, 0.45, 0.40 ) * sqrt(ce);\n\n        rgb = mix( rgb, vec3(0.60, 0.50, 0.40), 0.5 + 0.5*fbm( 8.0*pos ) );\n        rgb *= (0.60 + 0.40*fbm( 256.0*pos ));\n\n\t\tce = fbm( vec3(1024.0*pos.x, 512.0*pos.y, 1024.0*pos.z) );\n        float ni = smoothstep( 0.0, 0.30, nor.y );\n\t\tvec3 verde2 = vec3( 0.06, 0.05, 0.04 );\n        vec3 verde1 = vec3( 0.10, 0.09, 0.04 );\n        vec3 verde = mix( verde1, verde2, ce );\n\n\t\tce = fbm( vec3(1024.0*pos.x+123.789, 512.0*pos.y+71.71, 1024.0*pos.z) );\n\t\tfloat ce2 = smoothstep(-0.05,0.0, fbm( vec3(32.0*pos.x+123.789, 32.0*pos.y+71.71, 32.0*pos.z)) );\n        rgb = mix( rgb, verde, ce2*ni*smoothstep(-0.10,0.0,ce) );\n\n\t\trgb *= 0.60;\n\t\tfloat spe = clamp(-dot(rd,xnor),0.0,1.0);\n\t\tspe = 1.0-spe;\n\t\tspe = spe*spe;\n\t\tspe *= 0.20;\n\n\t    //--------------\n\n\t    float ks = tan(0.75*pos.z);\n\t    float kkHier = 0.5 + 0.5*fbm( vec3(4096.0*pos.x, 128.0*pos.y, 4096.0*pos.z*ks) );\n\t    float hh = 0.75*clamp(-rd.y,0.0,1.0);\n\t    kkHier = smoothstep( hh, 1.0, kkHier );\n\n        vec3 cesped = vec3(0.10,0.05,0.00);\n        cesped += vec3(0.22,0.24,0.25)*(0.5 + 0.5*fbm(64.0*pos));\n\t\tcesped += vec3(0.05,0.08,0.10)*(0.5 + 0.5*fbm(vec3(1024.0*pos.x,1024.0*pos.y,1024.0*pos.z)));\n\t\tcesped *= kkHier;\n\t\tcesped *= vec3(1.10,1.20,1.00);\n\n\t    float ce3 = smoothstep(-0.20,-0.10, fbm(32.0*pos+vec3(0.0,11.71,0.0)) );\n\t    rgb = mix( rgb, cesped, ce3*ni );\n\n        rgb += vec3(spe*(1.0-ni) );\n    }\n\telse\n\t{\n\t\trgb = vec3( 0.0 );\n\t}\n\n\tfloat  ao = xnor.y*0.5 + 0.5;\n    ao +=  0.25*(1.0 - 1.0/(1.0+pos.y));\n\tao += xnor.x*0.20;\n\tao *= (uvw.x*0.90+0.10);\n\tao *= fakeao;\n\n    vec3 lig = vec3( 0.80, 0.50, 0.10 );\n\n\tfloat ffs = smoothstep( -0.10, 0.10, fbm( vec3(32.0*pos.x,32.0*pos.z,1.70) ) );\n\tffs *= clamp( 4.0*dot(xnor,lig), 0.0, 1.0 );\n\tffs *= clamp( 4.0*dis-0.10, 0.0, 1.0  );\n\n    vec3 aoc = vec3( 0.67, 0.71, 0.75 );\n\n    aoc = aoc * ao;\n    aoc += vec3(1.30, 1.25, 1.20) * ffs*ao;\n\t\n    // lighting\n    rgb *= aoc;\n\n    // fog\n\trgb *= 1.0/(1.0+0.85*dis);\n\trgb += vec3(0.0496, 0.0528, 0.0544) * dis;\n\n    // sun\n\tfloat sun = clamp(dot(rd,lig),0.0,1.0);\n\tsun = sun*sun;\n\tsun = sun*sun;\n\tfloat tsun = sun*0.08;\n\tsun = sun*sun;\n\tsun = sun*sun;\n\ttsun += sun*0.70;\n    rgb += vec3(1.30, 1.20, 1.0) * tsun;\n\n    return rgb;\n}\n\nvec3 colorCorrect( vec3 rgb, in vec2 xy )\n{\n\trgb *= max( 4.0-(rgb.x+rgb.y+rgb.z), 1.0 );\n\t\n    rgb = clamp( rgb-0.1, 0.0, 1.0 );\n\n    // vigneting\n\trgb *= 0.75 + xy.x*(1.0-xy.x);\n    \n    return rgb;\n}\n\nvec3 calcpixel( in vec2 px )\n{\n    vec2 sxy = -1.0 + 2.0*px;\n\n    vec2 xy = sxy*vec2(1.75,1.0);\n\tfloat r2 = xy.x*xy.x*0.32 + xy.y*xy.y;\n    vec2 dxy = xy*(7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\n\n\tvec3 rayDir = vec3( dxy.x*0.98 - dxy.y*0.17,\n                        dxy.x*0.17 + dxy.y*0.98 + 0.60,\n                        1.0 );\n\n\trayDir = normalize( rayDir );\n\n    vec3 rayPos = vec3( 0.35+0.02*sin(6.2831*iTime/20.0), 0.30, 0.00 );\n\n\n    vec3 rgb = vec3(0.0);\n    \n    // ray march scene\n    vec4 suvw;\n    float t = cast_ray( rayPos, rayDir, 0.01, 15.0, suvw );\n    if( t>15.0 ) { suvw.x = 512.0; }\n\n    vec3 pos = rayPos + t*rayDir;\n    vec3 nor = calcNormal( pos );\n        \n    // shade\n    rgb = shade( pos, nor, rayPos, rayDir, suvw.x, t, suvw.yzw );\n  \n    // color correct\n    rgb = colorCorrect( rgb, 0.5+0.5*sxy );\n\n    return rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord / iResolution.xy;\n    vec3 col = calcpixel( uv );\n\tfragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord / iResolution.xy;\n    vec3 src = texture(iChannel0,uv).xyz;\n    \n    const int SunNumS = 100;\n    const float SunINumS = (1.0/float(SunNumS));\n    \n    vec2  di = (vec2(0.95,0.72) - uv) * SunINumS;\n    float ef = exp2( -3.0*length(di) );\n    float e = 0.0351857 * SunINumS;\n\n    vec3 col = vec3(0.0);\n    for( int k=0; k<SunNumS; k++ )\n    {\n        vec3 kk = texture(iChannel0,uv).xyz;\n        float gg = kk.x+kk.y+kk.z;\n        gg = gg*gg;\n        gg = gg*gg;\n        col += kk*e*gg;\n        e *= ef;\n        uv += di;\n    }\n    \n    col = col*col*(1.0-src) + src;\n\n\tfragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}