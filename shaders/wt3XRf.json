{
    "Shader": {
        "info": {
            "date": "1655929715",
            "description": "Custom raymarching engine",
            "flags": 0,
            "hasliked": 0,
            "id": "wt3XRf",
            "likes": 6,
            "name": "Moshed Geometry",
            "published": 3,
            "tags": [
                "raymarcher"
            ],
            "usePreview": 0,
            "username": "BradyInstead",
            "viewed": 247
        },
        "renderpass": [
            {
                "code": "\n#define NUM_COLORS 2\n\nfloat sdSphere( vec3 p, float s )\n{\n    p.y += sin(iTime*4.)/20. +.08;\n  return length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), -1.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdOcta( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat model(vec3 p)\n{\n    //vec2 mouse = iMouse.xy/iResolution.xy * 1.;\n    vec2 mouse = vec2(cos(iTime*.1), sin(iTime*.1)) * .5 + .5;\n    float time = iTime + mouse.x*1.5;\n    \n    p *= 1.;\n    \n    // movement\n    p.x += sin(time*8.0)/30.;\n  \tp.z += cos(time*8.0)/30.;\n    p.y += sin(time*4.0)/10. - .1;\n    \n    float octaWidth = .5 + mouse.x*.25;\n    float octa = sdOcta(p + vec3(octaWidth*sin(time), 0., octaWidth*cos(time)), .25);\n    octa = opSmoothUnion(octa, sdOcta(p + vec3(octaWidth*sin(time + 3.14), 0., octaWidth*cos(time + 3.14)), .25), cos(time*8.)*.1 + .5);\n    octa = opSmoothUnion(octa, sdOcta(p + vec3(octaWidth*cos(time), 0., octaWidth*sin(time + 3.14)), .25), cos(time*8.)*.1 + .5);\n    octa = opSmoothUnion(octa, sdOcta(p + vec3(octaWidth*cos(time + 3.14), 0., octaWidth*sin(time)), .25), cos(time*8.)*.1 + .5);\n    \n    \n    float shiftAmount = 15. - mouse.y*10.;\n    \n    p.x += sin(p.x*30. + time)/shiftAmount;\n    p.z += cos(p.z*30. + time)/shiftAmount;\n    \n    p.x = abs(p.x);\n    p.z = abs(p.z);\n    p.y = abs(p.y);\n    \n    // sizing\n    p*= .7;\n    \n    float torus = sdTorus (p + vec3(0., 0., 0.), vec2(0.25,0.05));\n    float sphere = sdSphere(p, .2);\n    \n    float dist = opSmoothUnion(torus, sphere, .1 + cos(time*8.0)*.05);\n    dist = opSmoothUnion(dist, octa, mouse.x*.4);\n    return dist * .9;\n}\n\nfloat raymarch(in vec3 ro, in vec3 rd)\n{\n    float dist = 0.;\n    for(int i = 0; i < 90; i++)\n    {\n\t\tfloat m = model(ro+rd*dist);\n        dist += m;\n        \n        if(m < .01) return dist;\n        else if(dist > 20.) break;\n    }\n    return -1.;\n}\n\nvec3 normal(vec3 pos)\n{\n    vec3 eps = vec3(.01, -.01, 0.);\n    \n    return normalize(vec3(\n        model(pos + eps.xzz) - model(pos + eps.yzz),\n        model(pos + eps.zxz) - model(pos + eps.zyz),\n        model(pos + eps.zzx) - model(pos + eps.zzy)));\n}\n\nfloat shadow(in vec3 pos, in vec3 ld)\n{\n    float spread = 3.;\n    float res = 1.0;\n\tfor(float t = .2; t < .4;)\n    {\n        float dist = model(pos+ld*t);\n        if(dist<.001) return 0.;\n        res = min(res, spread*dist/t);\n        t += dist;\n    }\n    return res;\n}\n\nvec3 getColor(int r)\n{\n    switch(r)\n    {\n        case 0:\n        \treturn vec3(86., 48., 107.) \t/256.;\n        case 1:\n        \treturn vec3(98., 67., 198.) \t/256.;\n        case 2:\n        \treturn vec3(102., 165., 250.)\t/256.;\n        case 3:\n        \treturn vec3(186., 250., 236.)\t/256.;\n    }\n    \n    return vec3(0.);\n}\n\nvec3 shade(vec3 pos, vec3 nor, vec3 rd, float dist)\n{\n    if(dist < 0.) return vec3(0., 1., 0.);\n    \n    vec3 lp = vec3(sin(iTime*2.0)*2.0, 4.0, cos(iTime*2.0)*2.0);\n    vec3 ld = normalize(lp-pos);\n    \n    float dif = max(dot(nor,ld),0.);\n    float sha = 0.;\n    if(dif > .01) sha = shadow(pos, ld);\n    vec3 lin = vec3(dif*sha);\n    \n    float sharp = .25;\n    float inten = 1.0;\n    vec3 ref = 2.0 * dot(ld, nor)*nor-ld;\n    lin += pow(max(0., dot(-rd, ref)), sharp) * vec3(inten) * sha;\n    \n    vec3 col = lin;\n    col *= exp(-.01*dist*dist);\n    \n    // toon\n    col *= vec3(NUM_COLORS);\n    float colFract = abs(sin(fract(col.r) * 3.14 * 1.5));\n    col = floor(col);\n    \n    \n    // pallete\n    //col = getColor(int(col.r));\n    col = mix(getColor(int(col.r-1.)), getColor(int(col.r)), colFract);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    p.x = abs(p.x) - .1;\n    p *= .7;\n    \n    int pix = int(fragCoord.x + fragCoord.y);\n    float dither = float(pix%2)*.6;\n    \n    vec3 ro = vec3(1. + dither, 1. + dither, 1. + dither); \n    vec3 ta = vec3(0.);\t\t\t\t\n    \n    vec3 w = normalize (ta-ro);\n    vec3 u = normalize (cross (w, vec3(0., 1., 0.)));\n    vec3 v = normalize (cross (u, w));\n    mat3 mat = mat3(u, v, w);\n    vec3 rd = normalize (mat*vec3(p.xy,.5 + sin(iTime)*.1));\n    \n    float dist = raymarch(ro, rd);\n    vec3 pos = ro+rd*dist;\n    vec3 nor = normal(pos);\n    \n    vec3 col = shade(pos, nor, rd, dist);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}