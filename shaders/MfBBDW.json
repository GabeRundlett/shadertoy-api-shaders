{
    "Shader": {
        "info": {
            "date": "1724916752",
            "description": "originals  https://glslsandbox.com/e#75723.0  https://glslsandbox.com/e#75613.1",
            "flags": 0,
            "hasliked": 0,
            "id": "MfBBDW",
            "likes": 1,
            "name": "lines color",
            "published": 3,
            "tags": [
                "lines",
                "color"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 82
        },
        "renderpass": [
            {
                "code": "\n#define THICKNESS 0.2\n#define LENGTH 0.07\nuniform float time;\nuniform vec2 resolution;\n#define time iTime\n#define resolution iResolution.xy\nfloat hseed(float t,float ct,float seed)\n{\n\tfloat cn = floor(t/ct);\n\tfloat poff= 0.3+0.7*fract(0.4+5.2147*cn);\n\tfloat s = step(0.25,fract(cn*0.5));\n\tfloat y = resolution.y*fract((mod(cn,943.7)+2.2)*(1.1+mod(cn,676.7))*(0.27+seed*22.773));\n\tfloat x = resolution.x*mix(-0.3,1.3,(t/ct-cn)/(poff)*(1.0-2.0*s)+s);\n\tfloat col = max(0.0,1.0-THICKNESS*abs(gl_FragCoord.y-y));\n\treturn col * 150.0/(150.0+LENGTH*(gl_FragCoord.x-x)*(gl_FragCoord.x-x));\n}\n\nfloat vseed(float t,float ct,float seed)\n{\n\tfloat cn = floor(t/ct);\n\tfloat poff= 0.3+0.7*fract(0.4+7.42787*cn);\n\tfloat s = step(0.25,fract(cn*0.5));\n\tfloat x = resolution.x*fract((mod(cn,912.7)+1.22)*(2.11+mod(cn,674.7))*(0.21+seed*13.773));\n\tfloat y = resolution.y*mix(-0.5,1.5,(t/ct-cn)/(poff)*(1.0-2.0*s)+s);\n\tfloat col = max(0.0,1.0-THICKNESS*abs(gl_FragCoord.x-x));\n\treturn col * 150.0/(50.0+LENGTH*(gl_FragCoord.y-y)*(gl_FragCoord.y-y));\n}\n\n\n#define round(x) (floor((x) + 0.53))\n\n// --------[ Original ShaderToy begins here ]---------- //\n// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan, slerpy, wwrighter \n// BigWings, FabriceNeyret and Blackle for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  \n// https://twitter.com/CookieDemoparty\n\n\n// Still exploring repetition trick presenting by Blackle on Perfect Pistons <3 \n// https://youtu.be/I8fmkLK1OKg\n// https://www.shadertoy.com/view/WtXcWB\n\n\n#define PI acos(0.)\n#define TAU (2.*PI)\n\n#define rot(z) mat2(cos(z),sin(z),-sin(z),cos(z))\n#define pal(c,t) (vec3(.4)+vec3(.4)*cos(TAU*(c*t+vec3(1.5,0.,2.8))))\n\n#define dt(sp,off) fract((iTime*.0)*sp)\n#define anim(sp, off) easeInOutExpo(abs(-1.+2.*dt(sp,off)))\n#define swi(sp,off) floor(sin(dt(sp,off)*TAU)+1.)\n\n\nfloat easeInOutExpo(float x)\n{\n    return x == 0.\n      ? 0.\n      : x == 1.\n      ? 1.\n      : x < 0.5 ? exp2(20. * x - 10.) / 2.\n      : (2. - exp2(-20. * x + 10.)) / 2.;\n}\n\nfloat box (vec3 p , vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\n\nfloat sdHexPrism (vec3 p, vec2 h)\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 9.57735);\n  p = abs(p);\n  p *= abs(p*p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.01)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec2 edge (vec2 p)\n{\n    vec2 p2=abs(p);\n    return (p2.x>p2.y) ? vec2((p.x<0.) ? -1. : 1., 0.) : vec2(0., (p.y<0.) ? -1. : 1.);\n}\n\nfloat id;\nfloat SDF (vec3 p)\n{\n    p.yz *= rot(-atan(1./sqrt(2.)));\n    if (swi(0.15,.0)<0.5) p.xz *= rot(PI/4.);\n\n    vec2 center = round(p.xz);\n    vec2 neighbour = center+edge(p.xz-center);\n    \n    vec2 pol = vec2(atan(center.y,center.x),length(center));\n    id = (abs(pol.x)/PI);\n    p.y += anim(0.3,sin(pol.x-pol.y));\n    float me = sdHexPrism(p.xzy-vec3(center, 0.),vec2(.42,1.))-0.02;\n    float ne = box(p-vec3(neighbour.x, 0., neighbour.y), vec3(.46,3.5,0.46));\n    \n    return min(me,ne);\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.001,0.);\n    return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n}\n\nfloat AO (float eps, vec3 p, vec3 n)\n{return SDF(p+eps*n)/eps;}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n  float col = 0.0;\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n  vec3 ro = vec3(uv*4.,-30.),rd=normalize(vec3(0.,0.02,1.)),p=ro,\n    col2=vec3(0.), l=normalize(vec3(-1.,2.,-3.));   \n    bool hit=false;\n    \n    for(float i=0.; i<100.; i++)\n    {\n        float d = SDF(p);\n        if (d<0.00001)\n        {hit=true;break;}\n        p += d*rd;\n    }\n\n    if (hit)\n    {\n        vec3 n = getnorm(p);\n        float light = max(dot(n,l),0.1), ao=AO(1.1,p,n)+AO(0.15,p,n)+AO(0.45,p,n);\n        col2 = pal(id,vec3(1.))*light*ao/2.;\n    }\n\tfor(float i=0.0;i<140.0;i++)\n\t{\n\t\t\n\t\tcol = max(col,hseed(time,10.0+i*0.078,1.0+i/1.0));\n\t\tcol = max(col,vseed(time,(10.0+i*0.78)*resolution.x/resolution.y,12.0+i/100.0));\t\t\n\t}\n\t\n\tfragColor = vec4( col,col,col*2., 1.0 );\n    \n\tfragColor.xyz *= vec3( col2)*mod(fragColor.y,2.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}