{
    "Shader": {
        "info": {
            "date": "1533476403",
            "description": "Only strange creatures left on this land, but all with human parts :)",
            "flags": 0,
            "hasliked": 0,
            "id": "4tdcWn",
            "likes": 56,
            "name": "[SH18]ForgottenLand",
            "published": 3,
            "tags": [
                "eye",
                "spider",
                "hand",
                "hand",
                "human",
                "sh18",
                "breast"
            ],
            "usePreview": 1,
            "username": "EvilRyu",
            "viewed": 2731
        },
        "renderpass": [
            {
                "code": "// Created by EvilRyu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// 2018 shadertoy competition entry.\n//\n// 75 seconds for the whole animation\n// \n\n#define PI 3.1415926535\n\n\nfloat hash11(float a)\n{\n    return fract(sin(a)*10403.9);\n}\n\n\nfloat hash21(vec2 uv)\n{\n    float f=uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\n\n\nvec2 hash22(vec2 uv)\n{\n    float f=uv.x + uv.y * 37.0;\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\n\n\nvec2 hash12(float f)\n{\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\n\n\nfloat hash31(vec3 p)\n{ \n    return fract(sin(dot(p, vec3(127.1, 311.7, 74.7)))*43758.5453); \n}\n\n\nfloat noise(vec2 x)\n{\n    vec2 p=floor(x);\n    vec2 f=fract(x);\n    f=f*f*(3.0-2.0*f);\n    float n=p.x + p.y*57.0;\n    return mix(mix(hash11(n+0.0), hash11(n+1.0),f.x),\n               mix(hash11(n+57.0), hash11(n+58.0),f.x),f.y);\n}\nconst mat2 m=mat2(0.8,0.6,-0.6,0.8);\n\n\nfloat fbm(vec2 p)\n{\n    float f=0.0;\n    f+=0.50000*noise(p); p=m*p*2.02;\n    f+=0.25000*noise(p); p=m*p*2.03;\n    f+=0.12500*noise(p); p=m*p*2.01;\n    f+=0.06250*noise(p); p=m*p*2.04;\n    f+=0.03125*noise(p);\n    return f/0.984375;\n}\n\n\nfloat smin(float a, float b, float k)\n{\n    float h=clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\n\nfloat smax(float a, float b, float k)\n{\n    return smin(a, b, -k);\n}\n\n\nvec3 rot_x(vec3 p, float t)\n{\n    float co=cos(t);\n    float si=sin(t);\n    p.yz=mat2(co,-si,si,co)*p.yz;\n    return p;\n}\n\nvec3 rot_y(vec3 p, float t)\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.xz = mat2(co,-si,si,co)*p.xz;\n    return p;\n}\n\nvec3 rot_z(vec3 p, float t)\n{\n    float co=cos(t);\n    float si=sin(t);\n    p.xy=mat2(co,-si,si,co)*p.xy;\n    return p;\n}\n\n\nfloat mixp(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(3.0-2.0*a));\n}\n\n\nfloat sphere(vec3 p,float r)\n{\n    return length(p)-r;\n}\n\n\nfloat ellipsoid(vec3 p, vec3 c, vec3 r)\n{\n    p-=c;\n    float d=length(p/r)-.5;\n    return d*min(r.x,min(r.y,r.z));\n}\n\n\nfloat box(vec3 p, vec3 r)\n{\n  vec3 d=abs(p) - r;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n\nfloat rbox(vec3 p, vec3 b, float r)\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n\nvec2 line2(vec3 a, vec3 b, vec3 p, float ll)\n{\n    vec3 pa=p-a;\n    vec3 ba=b-a;\n    float h=clamp(dot(pa,ba)*ll, 0.0, 1.0);\n    \n    return vec2(length(pa-ba*h), h);\n}\n\n\nvec2 line(vec3 pos, in vec3 a, in vec3 b)\n{\n    vec3 pa=pos-a;\n    vec3 ba=b-a;\n   \n    float h=clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    \n    return vec2(length(pa-h*ba), h);\n}\n\n\nvec3 solve(vec3 p, float l1, float l2, vec3 dir)\n{\n    vec3 q=p*(0.5 + 0.5*(l1*l1-l2*l2)/dot(p,p));\n    \n    float s=l1*l1 - dot(q,q);\n    s=max(s, 0.0);\n    q += sqrt(s)*normalize(cross(p,dir));\n    \n    return q;\n\n}\n\n\nvec3 solve(vec3 a, vec3 b, float l1, float l2, vec3 dir)\n{\n    return a + solve(b-a, l1, l2, dir);\n}\n\n\nvec4 texcube(sampler2D sam, vec3 p, vec3 n)\n{\n    vec4 p1=texture(sam, p.xy);\n    vec4 p2=texture(sam, p.xz);\n    vec4 p3=texture(sam, p.yz);\n    return p1*abs(n.z)+p2*abs(n.y)+p3*abs(n.x);\n}\n\n\nfloat bump(vec3 p, vec3 n)\n{\n    return dot(texcube(iChannel0, 0.25*p, n).xyz, vec3(0.299, 0.587, 0.114)); \n}\n\n\nvec3 bump_mapping(vec3 p, vec3 n, float weight)\n{\n    vec2 e=vec2(2./iResolution.y, 0); \n    vec3 g=vec3(bump(p-e.xyy, n)-bump(p+e.xyy, n),\n                bump(p-e.yxy, n)-bump(p+e.yxy, n),\n                bump(p-e.yyx, n)-bump(p+e.yyx, n))/(e.x*2.);  \n    g=(g-n*dot(g,n));\n    return normalize(n+g*weight);\n}\n\nstruct Spider\n{\n    vec3 pos;\n    vec3 forward;\n    vec3 knees[6];\n    vec3 feet[6];\n};\n\n    \nSpider spider;\n\n#define MAT_AB 0.0\n#define MAT_LEGS 1.0\n#define MAT_BODY 2.0\n#define MAT_EYES 3.0\n#define MAT_SPIDER_EYEHOLE 4.\n#define MAT_OTHERS 5.0\n\n#define BREATH (0.08*sin(4.*iTime))\n#define BREATH_FREQ 4.0\n#define SPIDER_EYEPOS vec3(0.,2.75,0.45)\n\nvec3 get_spider_coord(vec3 p)\n{\n    vec3 u=vec3(1.0,0.0,0.0);\n    vec3 v=normalize(cross(spider.forward,u));\n\n    return vec3(p.x, dot(v,p), dot(spider.forward,p));\n}\n\n// from spider coord\nvec3 get_world_coord(vec3 p)\n{\n    vec3 u=vec3(1.,0.,0.);\n    vec3 v=normalize(cross(spider.forward,u));\n    vec3 f=spider.forward;\n    return vec3(u*p.x+v*p.y+f*p.z);\n}\n\nvec2 body(vec3 q)\n{    \n    float matid=MAT_BODY;\n    // body\n    float d0=rbox(q+vec3(0.,-1.3,-0.4),vec3(0.02+0.3*sin(q.y-.2),0.8,0.02+0.1*sin(q.y*1.5-1.2)),0.1);\n    \n    // breast\n    vec3 q1=rot_x(q,0.6);\n    q1.x=abs(q1.x)-.3;\n    q1.y+=0.06*sin(BREATH_FREQ*iTime-2.);\n    float d1=ellipsoid(q1,vec3(0.,1.8,-0.4),vec3(.4,.3,.5));\n    if(d1<d0)matid=MAT_BODY;\n    d0=smin(d0,d1,0.3);\n    \n    // neck\n    d1=line(q,vec3(0.,2.1,0.4),vec3(0.,2.4,0.4)).x-.1;\n    if(d1<d0)matid=MAT_BODY;\n    d0=smin(d0,d1,0.2);\n    \n    // head\n    d1=ellipsoid(q,vec3(0.,2.7,.4),vec3(0.4,0.55,0.4));\n    if(d1<d0)matid=MAT_BODY;\n    d0=smin(d0,d1,0.05);\n    \n    // abs\n    q1=q+vec3(0.,-.75,-.55);\n    q1.xy=vec2(abs(q1.x)-0.1,abs(q1.y)-0.19);\n    d1=ellipsoid(q1, vec3(0.), vec3(0.05,0.08,0.07));\n    if(d1<d0)matid=MAT_LEGS;\n    d0=smin(d0,d1,0.2);\n  \n\n    // arms\n    q1=vec3(abs(q.x)-.4,q.y+0.02*sin(BREATH_FREQ*iTime-1.),q.z);\n    vec2 hh=line(q1,vec3(0.,2.1,0.4), vec3(.7,1.5,0.));\n    d1=hh.x-mix(0.14,0.02,hh.y) + 0.05*sin(6.2831*hh.y);\n    if(d1<d0)matid=MAT_BODY;\n    d0=smin(d0, d1, 0.15);\n    \n    hh=line(q1,vec3(.7,1.5,0.), vec3(1.5,1.,0.9));\n    d1=hh.x-mix(0.06,0.02,hh.y) + 0.01*cos(2.0*6.2831*hh.y);\n    if(d1<d0)matid=MAT_LEGS;\n    d0=smin(d0, d1,0.1);\n    \n    q1=vec3(abs(q.x)-.02,abs(q.y-2.7)-.1,q.z);\n    hh=line(q1,vec3(0.,0.,0.3), vec3(0.5,.3,-.5));\n    d1=hh.x-mix(0.06,0.02,hh.y) + 0.01*cos(2.0*6.2831*hh.y);\n    if(d1<d0)matid=MAT_BODY;\n    d0=smin(d0, d1,0.3);\n    \n    // nipples\n    /*q1=q;q1.x=abs(q1.x)-0.42;q1.yz+=0.04*sin(2.*iTime-2.);\n    float d11=sphere(q1-vec3(0.,1.65,0.84),0.04);\n    if(d11<d0){d0=d11;matid=MAT_LEGS;}*/\n    return vec2(d0,matid);\n}\n\nfloat legs(in vec3 p, in vec3 mvv, in vec3 muu)\n{\n    float d0=100.;\n    for(int i=0; i<min(0,iFrame)+6; i++)\n    {\n        float s=-sign(float(i)-2.5);\n        float h=mod(float(i), 3.0)/3.0;\n        \n        vec3 bas=spider.pos - 0.8*mvv*(1.0-h) + muu*s*0.8*(1.-h) + spider.forward*.8*(h-0.33) ;\n\n        vec3 n1=spider.knees[i];\n        vec2 hh=line2(bas, n1, p, 1./(2.5*2.5));\n        d0=smin(d0, hh.x-mix(0.15,0.1,hh.y) + 0.05*sin(6.2831*hh.y), 0.1);\n        hh=line2(n1, spider.feet[i], p, 1./((2.+(1.-h))*(2.+(1.-h))));\n        d0=smin(d0, hh.x-mix(0.08,0.02,hh.y) + 0.01*cos(2.0*6.2831*hh.y),0.1);\n    }\n    return d0;\n}\n\nvec2 dspider(in vec3 p)\n{\n    p*=0.14;\n    vec3 q=p - spider.pos;\n    \n    if(dot(q,q)>72.0) return vec2(32.0);\n    \n    vec3 muu=vec3(1.0,0.0,0.0);\n    vec3 mvv=normalize(cross(spider.forward,muu));\n    q=vec3(q.x, dot(mvv,q), dot(spider.forward,q));    \n    q.y+=BREATH;    \n    float matid=MAT_LEGS;\n       \n    float d0=100.;\n    \n    d0=legs(p,mvv,muu);\n    \n    // ab\n    vec3 q1=rot_x(q,-0.7);\n    float d1=ellipsoid(q1, vec3(0.), vec3(1.5,1.5,2.));\n    if(d1<d0)matid=MAT_AB;\n    d0=smin(d0,d1,0.2);\n    //ab\n    float ab=(0.5 + 0.5*cos(4.0*pow(0.5-0.5*q.z,2.0)))*(0.5+0.5*q.z);\n    d1=ellipsoid(q, vec3(0.,-0.6,-1.6),vec3(2.3,2.3,4.))- 0.1*ab;\n    d1+=0.03*sin(10.*q.z);    \n    if(d1<d0)matid=MAT_AB;\n    d0=smin(d0,d1,0.2);\n    \n    vec2 res=body(q);\n    if(res.x<d0)matid=res.y;\n    d0=smin(d0,res.x,0.2);\n    \n    // eyes\n    d1=ellipsoid(q,vec3(0.,2.84,0.65),vec3(0.19,0.55,0.3));\n    if(-d1>d0){d0=-d1;matid=MAT_SPIDER_EYEHOLE;}\n    \n    d1=sphere(q-SPIDER_EYEPOS, 0.15);\n    if(d1<d0){d0=d1;matid=MAT_EYES;}\n\n    return vec2(d0/.14, matid);\n}\n\n\n#define MAT_HAND 0.\n#define MAT_LAND 1.\n#define MAT_EYE 2.\n#define MAT_EYEHOLE 3.\n\n\n#define EYEPOS vec3(0.3,3.4,0.2)\nfloat eyeball(vec3 p)\n{\n    float d0=sphere(p-EYEPOS, 1.);\n    return d0;\n}\n\n\nvec2 hand(vec3 p)\n{\n    float matid=MAT_HAND;\n    // palm\n    float d0=rbox(p-vec3(0.,0.,0.1), vec3(0.6,1.5,0.05), 1.); //line(p, vec3(0.0,0.,0.0), vec3(0.0,1.0,0.0)).x-1.;\n    vec3 q=rot_z(p,-0.1);\n    float d1=rbox(q-vec3(0.,3.,0.), vec3(1.+.5*sin(12.+.55*p.y),1.7,0.01), .8+.15*sin(p.y));\n    d0=smin(d0,d1,2.);\n    \n    // thumb\n    vec2 hh=line(p,vec3(-1.5,1.,0.0), .85*vec3(-4.,3.,1.));\n    d1=hh.x-.9+0.35*sin(hh.y);\n    d0=smin(d0,d1,.7);\n    hh=line(p,vec3(-3.5,2.6,0.9),vec3(-3.,3.4,1.8));\n    d1=hh.x-.6+.2*sin(hh.y);\n    d0=smin(d0,d1,.1);\n    \n    // center\n    d1=sphere(p-vec3(0.4,3.3,2.5),1.7);\n    d0=smax(d0,-d1,.7);\n    \n    // fingers\n    hh=line(p,vec3(-1.3,4.8,-0.2),.74*vec3(-2.8,8.,-1.));\n    d1=hh.x-.7+.3*sin(hh.y);\n    d0=smin(d0,d1,.3);\n    hh=line(p-vec3(0.4,-0.6,0.6),vec3(-2.4,6.2,-1.4),.96*vec3(-2.7,7.6,-.8));\n    d1=hh.x-.5+.1*sin(hh.y);\n    d0=smin(d0,d1,.1);\n    hh=line(p,vec3(-2.2,6.8,0.),.95*vec3(-2.2,7.4,0.6));\n    d1=hh.x-.4+.05*sin(hh.y);\n    d0=smin(d0,d1,.1);\n    \n    hh=line(p,vec3(-0.1,4.8,-0.2),.85*vec3(-0.3,8.,-1.));\n    d1=hh.x-.66+.2*sin(hh.y);\n    d0=smin(d0,d1,.3);\n    hh=line(p,vec3(-0.3,6.9,-1.),.98*vec3(-0.3,7.9,0.25));\n    d1=hh.x-.5+.1*sin(hh.y);\n    d0=smin(d0,d1,.1);\n    hh=line(p,vec3(-0.3,7.6,0.4),.97*vec3(-0.3,7.7,1.));\n    d1=hh.x-.4+.05*sin(hh.y);\n    d0=smin(d0,d1,.1);\n    \n    hh=line(p,vec3(1.,4.8,-0.2),.84*vec3(1.5,8.,-1.));\n    d1=hh.x-.6+.2*sin(hh.y);\n    d0=smin(d0,d1,.3);\n    hh=line(p,vec3(1.25,6.5,-0.9),.93*vec3(1.5,7.9,0.25));\n    d1=hh.x-.48+.1*sin(hh.y);\n    d0=smin(d0,d1,.1);\n    hh=line(p,vec3(1.4,7.3,0.1),vec3(1.3,7.,.9));\n    d1=hh.x-.4+.05*sin(hh.y);\n    d0=smin(d0,d1,.1);\n    \n    hh=line(p,vec3(2.2,4.8,-0.2),.7*vec3(3.8,8.,-1.));\n    d1=hh.x-.5+.1*sin(hh.y);\n    d0=smin(d0,d1,.25);\n    hh=line(p,vec3(2.73,5.6,-.8),.98*vec3(3.,6.4,0.));\n    d1=hh.x-.45+.1*sin(hh.y);\n    d0=smin(d0,d1,.1);\n    hh=line(p,vec3(2.88,6.3,0.1),.97*vec3(2.8,6.4,.6));\n    d1=hh.x-.4+.05*sin(hh.y);\n    d0=smin(d0,d1,.1);\n    \n    \n    // eye\n    d1=ellipsoid(p,vec3(0.3,3.6,1.2),vec3(3.6,1.2+cos(p.x-.3),2.2));//sphere(q1, 0.055);\n    if(-d1>d0){matid=MAT_EYEHOLE;} \n    d0=smax(d0,-d1,0.2);\n    d1=eyeball(p);\n    if(d1<d0){d0=d1;matid=MAT_EYE;}\n    \n   /* q=p-vec3(-0.26,7.9,1.);\n    d1=box(q,vec3(.25,.05-0.03*sin(q.x*10.-8.2),.3-0.05*sin(q.x*10.-8.2)));\n    d0=min(d0,d1);*/\n    return vec2(d0,matid);\n    \n}\n\n\nvec2 dead_land(vec3 p)\n{    \n    vec2 res=hand(p);\n    float d0=res.x+.05*texture(iChannel0,p.xy*.05).x;\n    float matid=res.y;\n    \n    float bump=textureLod(iChannel1,p.xz/16.+p.xy/80.,0.0).x;\n    float d1=p.y+4.-bump+1.9*cos(p.x*0.15+1.8+cos(p.z*0.15));\n    if(d1<d0){d0=d1;matid=MAT_LAND;}\n    d0=smin(d0,p.y+4.-0.15*bump, 0.5);\n    \n    \n    return vec2(d0,matid);\n}\n\nfloat map(vec3 p)\n{\n    float d=hand(p).x;\n    d=min(d,dspider(p).x);\n    return d;  \n}\n\nvec3 get_spider_normal(vec3 p)\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*dspider(p+0.001*e).x;\n    }\n    return normalize(n);\n}\n\nvec3 get_dead_land_normal(vec3 p)\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*dead_land(p+0.001*e).x;\n    }\n    return normalize(n);\n}\n\n\n\n// marciot's \"The Mandel Grim\"  \n// https://www.shadertoy.com/view/4tGXWd\nvec3 get_eye_material(vec2 uv, bool bloody, float iris)\n{   \n    float r=uv.y/iris;\n    float a=uv.x*PI*2.0;\n    vec2 p=vec2(r*cos(a), r*sin(a));\n    vec3 col=vec3(1.);\n\n    if(r<.7) \n    {\n        col=vec3(0.9, 0.4, 0.2)*.5;\n\n        float f=fbm(5.0*p);\n        col=mix(col, vec3(0.9,0.8,0.3)*0.2, f);\n        col=mix(col, vec3(0.9,0.5,0.2), 1.0-smoothstep(0.2,0.6,r));\n\n        a += 0.05*fbm(20.0*p);\n        f=smoothstep(0.3, 1.0, fbm(vec2(6.2*r, 20.0*a)));\n        col=mix(col, vec3(0.), f);\n\n        f=smoothstep(0.4, 0.9, fbm(vec2(10.0*r, 15.0*a)));\n        col *= 1.0 - 0.5*f;\n\n        f=smoothstep(0.6, 0.8, r);\n        col *= 1.0 - 0.5*f;\n\n        f=smoothstep(0.2, 0.25, r);\n        col *= f;\n\n        f=smoothstep(0.75, 0.8, r);\n        col=mix(col, vec3(1.0), f);\n    }\n    \n    if(r>.67 && bloody)\n    {\n        a+=0.15*fbm(10.0*p);\n        float f=smoothstep(0.25, .8, fbm(vec2(0.9*r, 20.0*a)));\n        col-=vec3(.0,1.0,1.0)*f;\n    }\n\n    return col;\n}\n\nvec4 get_spider_material(vec3 p, vec3 n)\n{\n    vec2 res=dspider(p);\n    vec3 material=vec3(1.0);\n    p*=0.14;\n    vec3 q=get_spider_coord(p-spider.pos);\n\n    if(res.y<MAT_LEGS)\n    {\n        float t=mod(q.z, 0.7); \n        material= vec3(0.01)+vec3(.3, 0.01, 0.01)*\n                    pow(smoothstep(0.0, 0.1, t) * smoothstep(0.285, .28, t), 40.0);\n       \n        clamp(material, 0.0, 1.0);\n    }\n    else if(res.y<MAT_BODY)\n    {\n        material=vec3(0.01);\n    }\n    else if(res.y<MAT_EYES)\n    {\n        q.y+=BREATH;        \n        material=mix(vec3(0.01), vec3(1.55,.7333,.6)*.75,\n                     smoothstep(1.,1.75,q.y));\n    }\n    else if(res.y<MAT_SPIDER_EYEHOLE)\n    {\n        float t=mod(q.z, 0.508);\n\n        vec3 p0=q-SPIDER_EYEPOS;\n        p0.y+=BREATH;\n        vec2 uv=vec2(atan(p0.y,p0.x)/(2.*PI), \n                    acos(p0.z/length(p0))/PI);\n        material=get_eye_material(uv, false, 0.4);\n        \n    }\n    else\n    {\n        material=texture(iChannel0, q.xy).xyz;    \n        \n    }\n    return vec4(material,res.y);\n}\n\n\nvec4 get_dead_land_material(vec3 p, vec3 n)\n{\n    vec2 res=dead_land(p);\n    vec3 material=vec3(0.);\n    if(res.y<MAT_LAND)\n    {\n        material=vec3(1.55,.7333,.6)*.75;\n    }\n    else if(res.y<MAT_EYE)\n    {\n        material=texture(iChannel0, p.xz*0.1).xyz;\n    }\n    else if(res.y<MAT_EYEHOLE)\n    {\n    \tp=rot_y(p,0.2*(floor(sin(iTime*2.+sin(iTime)+17.))*2.+1.));\n        \n        vec3 p0=p-EYEPOS;\n        vec2 uv=vec2(atan(p0.y,p0.x)/(2.*PI), \n                    acos(p0.z/length(p0))/PI);\n        material=get_eye_material(uv, true, .2);\n    }\n    else\n    {\n        material=texture(iChannel0, p.xy).xyz;\n        material-=vec3(0.,.24,.2);\n        material=clamp(material,0.,1.);\n    }\n    return vec4(material, res.y);\n}\n\nfloat shadow(vec3 ro, vec3 rd)\n{\n    float res=1.0;\n    float t=0.02;\n    float h;\n    \n    for (int i=0; i < min(0,iFrame)+8; i++)\n    {\n        h=map(ro + rd*t);\n        res=min(6.0*h / t, res);\n        t += h;\n    }\n    return max(res, 0.0);\n}\n\nfloat get_ao(vec3 p, vec3 n)\n{\n    float r=0.0, w=1.0, d;\n    for(float i=1.; i<float(min(0,iFrame))+5.0+1.1; i++)\n    {\n        d=i/5.0;\n        r += w*(d - dead_land(p + n*d).x);\n        w *= 0.5;\n    }\n    return 1.0-clamp(r,0.0,1.0);\n}\n\nconst vec3 moon_dir=normalize(vec3(-0.1,0.05,0.4));\n\n\nvec3 lighting_spider(vec3 ro, vec3 rd, vec3 pos, vec3 nor)\n{\n    vec3 l0dir=moon_dir;\n    vec3 l0col=vec3(1.);\n    vec4 ma=get_spider_material(pos, nor);\n    \n    if(ma.w<MAT_BODY)\n    \tnor=bump_mapping(pos, nor, 0.03);\n    \n    float diff=4.0*max(0.,dot(l0dir,nor));\n    float back=0.5*max(0.,dot(-l0dir,nor));\n    float sky=max(0.,dot(vec3(0,1,0),nor));\n    float boun=0.5*max(0.,dot(vec3(0,-1,0),nor));\n    float spec=max(0.0, pow(clamp(dot(l0dir, reflect(rd, nor)), 0.0, 1.0), 64.0));\n    \n    vec3 col=((l0col*diff+l0col*back)+\n              3.*vec3(0.0,0.05,0.1)*sky+\n              3.*vec3(0.0,0.05,0.1)*boun)+vec3(1.)*spec;\n\n    col*=ma.xyz*0.2;\n    \n    col+=(ma.w<MAT_BODY?1.0:0.)*spec;\n    return col;\n}\n\n\nfloat density_hand(vec3 p, float ms, vec3 n) \n{\n    return hand(p+n*ms).x/ms;\n}\n\n\nvec3 lighting_dead_land(vec3 ro, vec3 rd, vec3 pos, vec3 nor)\n{\n    vec3 l0dir=moon_dir;\n    vec3 l0col=vec3(1.);\n    \n    vec4 ma=get_dead_land_material(pos, nor);\n    //nor=bump_mapping(pos, nor, 0.03);\n    \n    float shad=shadow(pos+0.1*nor,l0dir);\n    float ao=get_ao(pos,nor);\n    float diff=4.0*max(0.,dot(l0dir,nor));\n    float back=0.2*max(0.,dot(-l0dir,nor));\n    float sky=max(0.,dot(vec3(0,1,0),nor));\n    float boun=0.5*max(0.,dot(vec3(0,-1,0),nor));\n    float spec=max(0.0, pow(clamp(dot(l0dir, reflect(rd, nor)), 0.0, 1.0), 16.0));\n    float sca=1.-density_hand(pos,1.,nor);\n\n    \n    vec3 col=((l0col*diff+l0col*back)*shad*ao*ao+\n              3.*vec3(0.0,0.05,0.1)*sky+\n              3.*vec3(0.0,0.05,0.1)*boun);\n    if(ma.w<MAT_EYEHOLE)\n        col+=spec;\n    if(ma.w<MAT_LAND)\n        col+=.7*vec3(0.3,0.1,0.1)*sca;\n    col*=ma.xyz;\n    col*=0.2;\n\n    return col;\n}\n\n\nvec4 scene_spider(vec3 ro, vec3 rd)\n{    \n    float t=0.1;\n    for(int i=0;i<min(0,iFrame)+128;++i)    \n    {\n        float d=dspider(ro+rd*t).x;\n        if(d<0.005||t>100.0)\n            break;\n        \n        t+=d;\n    }\n        \n    \n    vec3 col=vec3(1.);\n    if(t<100.)\n    {\n        vec3 pos=ro+t*rd;\n        vec3 nor=get_spider_normal(pos);\n        col=lighting_spider(ro,rd,pos,nor);\n    }\n    return vec4(col,t);\n}\n\n\nvec4 scene_dead_land(vec3 ro, vec3 rd)\n{\n    float t=0.1;\n    for(int i=0;i<min(0,iFrame)+128;++i)    \n    {\n        float d=dead_land(ro+rd*t).x;\n        if(d<0.005||t>100.0)\n            break;\n        \n        t+=d;\n    }\n            \n    vec3 col=vec3(0.);\n\n    \n    if(t<100.)\n    {\n        vec3 pos=ro+t*rd;\n        vec3 nor=get_dead_land_normal(pos);\n        col=lighting_dead_land(ro,rd,pos,nor);\n    }\n    col=mix(col,vec3(0.0,0.05,0.1)*.7, 1.0-exp(-0.00025*t*t));\n    \n    return vec4(col,t);\n}\n\n\nfloat terrain(vec2 p) \n{\n    float w=0.;\n    float s=1.;\n    p.x*=20.;\n    w+=sin(p.x*.3521)*4.;\n    for (int i=0; i<min(0,iFrame)+5; i++) \n    {\n        p.x*=1.53562;\n        p.x+=7.56248;\n        w+=sin(p.x)*s;      \n        s*=.5;\n    }\n    w=w*.5+.5;\n    return step(0.,p.y-w*.02+.07);\n}\n\nvec3 render_terrian(vec3 ro, vec3 rd, vec3 col)\n{\n    col=mix(col,vec3(0.0,0.05,0.1)*0.7, 1.-terrain(rd.xy));\n    return col;\n}\n\n// Shane's \"3D cellular tiling\"\n// https://www.shadertoy.com/view/ld3Szs\nfloat tri3(in vec3 p)\n{\n    p=cos(p*2.+(cos(p.yzx)+1.+iTime*4.)*1.57);\n    return dot(p, vec3(0.1666))+0.5;\n}\n\nfloat triangle_noise(vec3 p)\n{\n    const mat3 m=mat3(0.25, -0.866, 0.433, \n                        0.9665, 0.25, -0.2455127, \n                        -0.058, 0.433, 0.899519)*1.5;\n  \n    float res=0.;\n\n    float t=tri3(p*PI);\n    p+=(t-iTime*0.25);\n    p=m*p;\n    res+=t;\n    \n    t=tri3(p*PI); \n    p+=(t-iTime*0.25)*0.7071;\n    p=m*p;\n    res+=t*0.7071;\n\n    t=tri3(p*PI);\n    res+=t*0.5;\n     \n    return res/2.2071;\n}\n\n\nfloat get_mist(in vec3 ro, in vec3 rd, in vec3 lp, in float t){\n\n    float mist=0.;\n    ro+=rd*t/8.;\n    \n    for (int i=0; i<min(0,iFrame)+4; i++)\n    {\n        mist+=triangle_noise(ro/4.)*(1.-float(i)*.2);\n        ro+=rd*t/4.;\n    }\n    return clamp(mist/2.+hash31(ro)*0.1-0.05, 0., 1.);\n}\n\nvec3 render_sky(vec3 ro, vec3 rd)\n{\n    vec3 sky=vec3(0.0,0.05,0.1);\n   \n    vec3 clouds=vec3(0.0);\n    float s=.3;\n    for (int i=0; i < min(0,iFrame)+3; ++i) \n    {\n        clouds+=smoothstep(0.5,0.2,fbm(s*rd.xz/(rd.y+2./iResolution.x)+s*iTime*0.5));\n        s *= 1.5;\n    }\n    \n    vec3 col=sky + .35*clouds*max(0.0, rd.y);\n    vec3 moon_col=pow(vec3(0.659,0.765,0.878),vec3(1.2));\n    col+=moon_col*smoothstep(0.3,0.36,pow(max(dot(moon_dir, rd), 0.0), 32.0));\n    vec2 moon_pos=rd.xy/rd.z - moon_dir.xy/moon_dir.z;\n    col=mix(col, moon_col*fbm(10.*moon_pos-2.), max(0.,rd.z)*smoothstep(0.37, 0.1, length(moon_pos)));\n    \n    return col;\n}\n\nvec3 tonemap(vec3 x) \n{\n    const float a=2.51;\n    const float b=0.03;\n    const float c=2.43;\n    const float d=0.59;\n    const float e=0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\n// time slot of each scene\n#define SCENE_1 5.  // moon\n#define SCENE_2 10. // mist\n#define SCENE_3 33. // spider passes\n#define SCENE_4 45. // eye of the hand\n#define SCENE_5 65. // spider alone\n\nvoid get_camera(out vec3 ro, out vec3 ta)\n{\n    // center: x_rot=-1.5, y_rot=0.01;\n    float x_rot=-1.3, y_rot=0.01;\n    \n    if(iTime<SCENE_3 || iTime>SCENE_5)\n    {\n        x_rot=-1.3, y_rot=0.05;\n        ro=vec3(0.,4.,0.)+vec3(cos(y_rot)*cos(x_rot),sin(y_rot),cos(y_rot)*sin(x_rot))*20.35;\n        ta=vec3(0.0,1.,0.);\n    }\n    else if(iTime<SCENE_4)\n    {\n        x_rot=-1.3+2.8*smoothstep(SCENE_3, SCENE_3+5., iTime), y_rot=0.05;\n        ro=vec3(0.,4.0,-1.5*smoothstep(SCENE_3, SCENE_4, iTime))+vec3(cos(y_rot)*cos(x_rot),sin(y_rot),cos(y_rot)*sin(x_rot))*20.35;\n        ta=vec3(0.0,1.,0.);\n    }\n    else if(iTime<SCENE_5)\n    {\n        x_rot=1.4;y_rot=0.3;\n        ro=spider.pos+vec3(10.,25.,40.);//+vec3(cos(y_rot)*cos(x_rot),sin(y_rot),cos(y_rot)*sin(x_rot))*45.;\n        ta=spider.pos+vec3(-10.,15.,0.);\n    }\n    \n    // shake\n    ro+=0.04*sin(2.0*iTime*vec3(1.1,1.2,1.3)+vec3(3.0,0.0,1.0));\n    ta+=0.04*sin(2.0*iTime*vec3(1.7,1.5,1.6)+vec3(1.0,2.0,1.0));\n    \n}\n\nvec3 spider_path(vec3 offset, float time)\n{\n    return offset+vec3(0., 0., .4*time);\n}\n\n\n// iq's \"Insect\" : https://www.shadertoy.com/view/Mss3zM\nvoid move_legs(vec3 offset, float time)\n{\n    for(int i=0; i<min(0,iFrame)+6; i++)\n    {\n        // side\n        float s=-sign(float(i)-2.5);\n        // pair\n        float h=mod(float(i), 3.0)/3.0;\n\n        float z=.5*time + 4.*h + 0.25*s;\n        float iz=floor(z);\n        float fz=fract(z);\n        float az=clamp((fz-0.66)/0.34,0.0,1.0);\n\n        vec3 fo=offset+vec3(s*2.5, 0.7*az*(1.0-az)-2.,\n                              (iz+az+(h-0.4)*6.0)*.8);\n        spider.feet[i]=fo;\n\n        vec3 ba=spider.pos-0.8*vec3(0.,1.,0.)*(1.0-h)+vec3(1.0,0.0,0.0)*s*0.8*(1.0-h)+spider.forward*.8*(h-0.33) ;\n\n        spider.knees[i]=solve(ba, fo, 2.5, 2.+(1.-h), s*vec3(0.0,0.0,-1.));\n    }\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 q=fragCoord/iResolution.xy;\n    vec2 p=q*2.-1.;\n    p.x*=iResolution.x/iResolution.y;\n   \n    if (abs(p.y)>.88) {\n        fragColor=vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n   \n    vec3 offset=vec3(-1.8,1.5,-20.);\n    \n    if(iTime<SCENE_2 || iTime>SCENE_5)\n    {\n        spider.pos=offset;\n        spider.forward=vec3(0.,0.,1.);\n    }\n    else if(iTime<SCENE_3)\n    {\n        float atime=30.+2.*(iTime-SCENE_2);\n        spider.pos=spider_path(offset,atime);\n        spider.forward=normalize(spider_path(offset,atime+2.)-spider.pos);\n        move_legs(offset, atime);\n    }\n    else if(iTime<SCENE_4)\n    {\n        spider.pos=offset;\n        spider.forward=vec3(0.,0.,1.);\n    }\n    else\n    {\n        float atime=30.+2.*(iTime-SCENE_4);\n        spider.pos=spider_path(offset,atime);\n        spider.forward=normalize(spider_path(offset,atime+2.)-spider.pos);\n        move_legs(offset, atime);\n    }\n    \n\n    vec3 ro=vec3(0.,1.,3.);\n    vec3 ta=vec3(0.);\n    \n    // debugging camera\n    //float x_rot=-iMouse.x/iResolution.x*PI*2.0;\n    //float y_rot=iMouse.y/iResolution.y*3.14*0.5 + PI/2.0;\n    //ro=spider.pos+vec3(0.,20.,0.)+vec3(cos(y_rot)*cos(x_rot),sin(y_rot),cos(y_rot)*sin(x_rot))*10.35;\n    //ta=spider.pos+vec3(0.,20.,0.);\n    //ro=vec3(0.,3.0,0.)+vec3(cos(y_rot)*cos(x_rot),sin(y_rot),cos(y_rot)*sin(x_rot))*20.35;\n    //ta=vec3(0.0,1.,0.);\n    \n    \n    get_camera(ro,ta);\n    \n    vec3 f=normalize(ta-ro);\n    vec3 r=normalize(cross(f,vec3(0.,1.,0.)));\n    vec3 u=normalize(cross(r,f));\n    vec3 rd=normalize(r*p.x+u*p.y+f*2.3);\n    \n    vec3 sky=vec3(0.0,0.05,0.1)*1.4;\n    vec3 col=render_sky(ro,rd);\n    col=render_terrian(ro,rd,col);\n    \n    vec4 res0=scene_dead_land(ro,rd);\n    \n    vec4 res1=vec4(0,0,0,100);\n   \n    if((iTime>SCENE_2 && iTime<SCENE_4) ||\n      (iTime>SCENE_4 && iTime<SCENE_5))\n    {\n        res1=scene_spider(ro,rd);\n    }\n    \n    vec4 res=res0;\n    if(res1.w<res0.w)\n        res=res1;\n    \n    float t=res.w;\n\n    if(t<100.)\n    {\n        col=res.xyz;\n    }\n\n    \n    float mist=get_mist(ro, rd, moon_dir, t);\n    if(iTime<SCENE_5)\n    {\n        col=mix(col, vec3(0.8,0.8,1.)*mix(1., .75, mist)*(rd.y*.25+.5),\n                min(pow(t, 1.5*smoothstep(0.,10.,iTime))*.15/100., 1.));\n    }\n    else\n    {\n        col=mix(col, vec3(0.8,0.8,1.)*mix(1., .75, mist)*(rd.y*.25+.5),\n                min(pow(t, 1.5-smoothstep(0.,20.,iTime-SCENE_5))*.15/100., 1.));\n    }\n    \n    col=tonemap(col);\n    col=pow(clamp(col,0.0,1.0),vec3(0.45));\n    col*=0.5+0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n   \n    fragColor=vec4(col,1.0);\n    \n    fragColor.xyz=mix(fragColor.xyz, vec3(0.), smoothstep(3.,0., iTime));\n    \n    if(iTime>SCENE_3)\n    {\n        fragColor.xyz=mix(fragColor.xyz, vec3(0.), smoothstep(3.,0., iTime-SCENE_3));\n    }\n    if(iTime>SCENE_4)\n    {\n        fragColor.xyz=mix(fragColor.xyz, vec3(0.), smoothstep(3.,0., iTime-SCENE_4));\n    }\n    if(iTime>SCENE_5)\n    {\n        fragColor.xyz=mix(fragColor.xyz, vec3(0.), smoothstep(4.,0., iTime-SCENE_5));\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}