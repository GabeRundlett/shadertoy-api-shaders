{
    "Shader": {
        "info": {
            "date": "1585579410",
            "description": "Wireframe Octahedron, with start of the Sierpinski triangulation. Practice for the main exercise, which is doing this one dimension up. Written in 'tutorial' style to help me understand what is going on (and I hope others find this useful). Mouse rotates.",
            "flags": 0,
            "hasliked": 0,
            "id": "wdfyDj",
            "likes": 11,
            "name": "Sierpinski Octahedron Tutorial",
            "published": 3,
            "tags": [
                "tutorial",
                "sierpinski",
                "octahedron"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 422
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Sierpinski Octahedron Tutorial\n//\n// Matthew Arcus, 2020.\n//\n// Draw a wire frame octahedron, with the first couple of layers of the\n// Sierpinski triangulation applied to the sides. In itself, this isn't\n// all that exciting, but it leads on nicely to the next step, which\n// is to move up a dimension.\n//\n// I've tried to make this something of a tutorial with more explanation\n// of what is going on than usual and I've used a lot of forward\n// declarations so the code can be read somewhat top down. I hope some\n// people find that useful. I haven't gone into much detail about\n// lighting etc. as we aren't doing anything very clever here and the\n// basic stuff is well covered elsewhere.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// First we must declare some global variables - we don't want to\n// overuse these, but they are useful for setting global configuration\n// etc. One useful purpose is for simple runtime checks - it's hard\n// knowing what is going on in a shader, so some way of reporting\n// conditions to the user is very handy.\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n//#define assert(x) // Uncomment this to remove assertions\n\n// Various configurables - their meaning will become clear later.\n//#define SPHERICAL // Uncomment to project to sphere\nvec3 light = vec3(0,2,1); // Position of light\nfloat eradius = 0.03; // Radius of an edge\nfloat pradius = 0.06; // Radius of a vertex sphere\nfloat eyedist = 2.5; // Eye is at (0,0,eyedist);\nfloat PI = 3.1415927; // A useful constant - don't need more figures than this\nint level = 2; // How many Sierpinski subdivisions <= 2 to do.\n\n// Raymarching configuration.\nint maxsteps = 50;\nfloat precis = 1e-2; \n\nbool dorotate = true;\n\nvec3 screencolor(vec2 z);\n\n// The main function called by Shadertoy.\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n  // mainImage just sets fragColor to the rgba value for the given\n  // screen coordinate. In fact, Shadertoy always sets the w or a\n  // coordinate of the colour to 1, so we will do most of our work\n  // with vec3 colours.\n\n  // It's useful for the shader to mainly work with \"normalized\"\n  // dimensions rather than actual pixel dimensions - a common\n  // convention is to normalize to [-1,1] vertically and [-a,a]\n  // horizontally, where a is the screen aspect ratio (so horizontal\n  // and vertical scales are the same). I tend to call this 'z' as we\n  // often want to treat it as a complex number, but some might prefer\n  // 'uv', or 'p'.\n\n  vec2 z = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n  // The maincolor function declared earlier actually does the work.\n  vec3 col = screencolor(z);\n\n  // Check nothing has gone wrong.\n  if (alert) col.r = 1.0;\n\n  // Set the final fragment colour.\n  fragColor = vec4(col,1);\n}\n\nvec3 raycolor(vec3 q, vec3 r);\nvec3 transformframe(vec3);\n\nvec3 screencolor(vec2 z) {\n  // z is a normalized screen coordinate, return the colour for that\n  // coordinate.\n\n  // We are doing a 3d scene, so we need to set things up with a\n  // camera and a \"projection screen\". There are various ways of doing\n  // this, for this shader where the main interest is around the\n  // origin, this simple setup will do - imagine a device with a \n  // rectangular grid as in Albrecht DÃ¼rer's woodcut:\n  // https://www.metmuseum.org/art/collection/search/366555 - the grid\n  // is at a fixed position from the eye, and the whole device can be\n  // moved around as a unit to view the scene from different\n  // positions (for example, by rotating under mouse control).\n\n  // The initial location of the virtual eye or camera.\n  vec3 eye = vec3(0,0,eyedist);\n\n  // The direction of a ray from the eye to a point on the virtual\n  // screen - the screen goes from -1 to +1 vertically, so we have a\n  // vertical viewing angle of 2*atan(0.5) = 53 degrees.\n    vec3 ray = vec3(z,-2);\n\n  // Now we follow that ray into the scene and see what generates the\n  // light that comes down that ray in the opposite direction.\n\n  // First, apply a transformation to both eye and ray to allow viewing the\n  // scene from different directions. Also transform the light, so the\n  // effect will be that we are rotating the scene before us.\n  eye = transformframe(eye);\n  ray = transformframe(ray);\n  light = transformframe(light);\n  \n  // Calculations are easier if the ray has unit length. Do this after\n  // rotating as sin and cos can introduce small inaccuracies.\n  ray = normalize(ray);\n\n  // Now raycolor will follow the ray from eye and return the colour\n  // to display for that ray.\n  vec3 col = raycolor(eye,ray);\n  col = pow(col,vec3(0.4545)); // Gamma correction - see elsewhere\n  return col;\n}\n\nfloat getdistance(vec3 q, vec3 r, out int type);\nvec3 getnormal(vec3 p);\n\nvec3 getbasecolor(int type) {\n  assert(type >= 0);\n  if (type == 0) return vec3(0.75,1,0.75);\n  if (type == 1) return vec3(0.2);\n  return vec3(1,0,1);\n}\n\nvec3 getbackground(vec3 r) {\n  //return r; // Colourful fun\n  return vec3(0,0,0.1); // The more sober option.\n}\n\nvec3 raycolor(vec3 q, vec3 r) {\n  // The scene is represented by a surface, We follow the ray and find\n  // if it intersects the surface - if so, apply some simple lighting\n  // to the colour at the intersection point. 'type' is set to an\n  // integer indicating what has been hit.\n  int type = -1;\n  float t = getdistance(q,r,type);\n\n  // getdistance returns -ve for no intersection, so return background\n  // colour for that direction.\n  if (t < 0.0) return getbackground(r);\n\n  // Get the surface point that has been hit,\n  vec3 p = q+t*r;\n\n  // and the normal at that point.\n  vec3 normal = getnormal(p);\n\n  // Apply lighting. This is a basic \"Lambertian\" model.\n  vec3 lightdir = normalize(light-p);\n  vec3 color = getbasecolor(type);\n  float ambient = 0.3;\n  float diffuse = 0.7*clamp(dot(normal,lightdir),0.0,1.0);\n  color *= ambient+ diffuse;\n  return color;\n}\n\n// We have got to raymarching at last. Much has been written\n// elsewhere on how this works, which I won't repeat here, the general\n// idea is that de(p) gives an estimate of the minimum distance to\n// the surface, so we can safely move that far along the ray without\n// hitting the surface, and then repeat the procedure. Our scene is\n// just spheres and cylinders, with nothing fancy going on so\n// something very simple will do here.\n\n// Note that the DE function also returns the type of object hit\n// (basically, what colour it should be) - for a complex DE function\n// it might be more efficient to have separate functions, one that\n// just returns the distance, and one that just returns the type that\n// can be called separately at the end to determine the colour (we\n// could write it as a single function though, used in two places and\n// rely on the code optimizer to inline and remove any useless\n// calculations from each use).\n\nfloat de(vec3 p, out int type); // The distance estimator\n\nfloat getdistance(vec3 q, vec3 r, out int type) {\n  // Octahedron is mostly radius <= 1 and eyedist is distance of eye from\n  // origin, so this should cover the entire scene.\n  float maxdist = eyedist + 2.0;\n  float t = 0.0;\n  for (int i = 0; i < maxsteps; i++) {\n    //assert(i < 20); // Assertions are useful for seeing what's going on.\n    vec3 p = q+t*r;\n    float d = de(p,type);\n    if (abs(d) < precis) return t; // Close enough to the surface.\n    t += d;\n    if (t > maxdist) break;\n  }\n  return -1.0;\n}\n\nfloat segment(vec3 p, vec3 q, vec3 r);\nfloat dist(vec3 p, vec3 q);\n\n// The de function for our octahedron. The octahedron, with vertices\n// at (1,0,0),(-1,0,0),(0,1,0),(0,-1,0),(0,0,1),(0,0,-1) has mirror\n// symmetries in the 3 planes, x=0, y=0, z=0, so de(p) = de(abs(p))\n// and setting p = abs(p) in fact maps all faces of the octahedron to\n// the one at (1,0,0),(0,1,0),(0,0,1) (or, maps p to p' where the\n// distance from p to the octahedron is the same as the distance from\n// p' to that single face).\n//\n// Additionally, there are symmetries in the diagonal planes x=y,\n// etc. so de(p) = de(p.yxz), ie. we can swap any pairs of\n// coordinates, so we can map p -> p1 with p1.x >= p1.y >= p1.z and\n// the effect of this is to map the entire triangular face into a\n// small right angled triangle at (0,0,0),(1,0,0) and 0.5*(1,1,0),\n// (the 'fundamental region' for the set of symmetries).\n//\n// Note that points on the face all have coordinates (a,b,c) with\n// a+b+c = 1 and 0 <= a,b,c <= 1. (In fact, the actual coordinates of\n// the points in the face are the same as their barycentric or\n// trilinear coordinates, making calculations very easy).\n\n// So, to actually draw something: we have a triangle ABC, though we\n// are mainly working in a small sector around A. From the triangle\n// ABC, the only vertex in the sector is A, the only line is AB, so if\n// we draw just these, we see a complete octahedron, the rest is\n// filled in by our mirror symmetries.\n\n// For the Sierpinski construction, we want to draw the inner\n// triangle, which goes between the midpoints of the sides. Again,\n// because we are working in a small sector around A, we just need to\n// draw the midpoint of AB and part of the line from there to the\n// midpoint of BC, or, as in the code, set A1,B1,C1 to be the vertices\n// of the new \"corner triangle\" around A, so A1 = A, B1 = midpoint of\n// AB, C1 = midpoint of AC, and then we just need to draw point B1 and\n// the line from B1 to C1.\n//\n// Finally, we want to draw the centre triangle of that smaller corner\n// triangle, so find the midpoints of its sides (AB1 etc.) and draw\n// lines between them - again, we just need points AB1 and BC1 and\n// the lines from AB1 to CA1 and from AB1 to BC1. It's easy to see\n// what is needed by commenting out the 'p = abs(p)' line so just one\n// triangular face is displayed (and drawing a picture on a piece of\n// paper always helps).\n\nfloat de(vec3 p, out int type) {\n  p = abs(p); // Map to single face - skip this to see single face.\n  // Sort the coordinates to map to fundamental region.\n  if (p.x < p.y) p.xy = p.yx;\n  if (p.y < p.z) p.yz = p.zy;\n  if (p.x < p.y) p.xy = p.yx;\n  // Check we are sorted.\n  assert(p.x >= p.y);\n  assert(p.y >= p.z);\n  // 3 corners of the original triangle.\n  vec3 A = vec3(1,0,0);\n  vec3 B = vec3(0,1,0);\n  vec3 C = vec3(0,0,1);\n  // The 3 corners of the smaller corner triangle.\n  vec3 A1 = A;\n  vec3 B1 = 0.5*(A+B);\n  vec3 C1 = 0.5*(A+C);\n  // Midpoints of the sides of the smaller triangle.\n  vec3 AB1 = 0.5*(A1+B1);\n  vec3 BC1 = 0.5*(B1+C1);\n  vec3 CA1 = 0.5*(C1+A1);\n\n  // Some points are outside our fundamental region, but\n  // the line segments are going in the right direction.\n  float d = 1e8, d0 = d;\n  for(;;) {\n    d = min(d,segment(p,A,B)-eradius);\n    if (level == 0) break;\n    d = min(d,segment(p,B1,C1)-eradius);\n    if (level == 1) break;\n    d = min(d,segment(p,AB1,CA1)-eradius);\n    d = min(d,segment(p,AB1,BC1)-eradius);\n    break;\n  }\n  if (d < d0) type = 0; d0 = d;\n\n  for(;;) {\n    d = min(d,dist(p,A)-pradius);\n    if (level == 0) break;\n    d = min(d,dist(p,B1)-pradius);\n    if (level == 1) break;\n    d = min(d,dist(p,AB1)-pradius);\n    d = min(d,dist(p,BC1)-pradius);\n    break;\n  }\n  if (d < d0) type = 1; d0 = d;\n\n  return d;\n}\n\n// We need to define just how to measure distances to the scene.\n#if defined SPHERICAL\n// Project the scene points (ie. q and r here) onto the unit sphere\n// before measuring distances.\nfloat dist(vec3 p, vec3 q) {\n  return distance(p,normalize(q));\n}\n\n// For segment, also project p onto sphere, then find the closest\n// point to the segment on the sphere, and take the Euclidean distance\n// to that point.\nfloat segment(vec3 p, vec3 q, vec3 r) {\n  vec3 p1 = normalize(p);\n  q = normalize(q);\n  r = normalize(r);\n  // Map p to the plane defined by q and r:\n  // p = aq + br + x, where q.x = r.x = 0 so:\n  // p.q = aq.q + br.q and:\n  // p.r = aq.r + br.r\n  // Solve by inverting a 2x2 matrix.\n  mat2 m = inverse(mat2(dot(q,q),dot(q,r),dot(q,r),dot(r,r)));\n  vec2 ab = m*vec2(dot(p1,q),dot(p1,r));\n  ab = max(ab,0.0);\n  // p1 is in plane of q,r, on hypersphere\n  p1 = normalize(ab[0]*q + ab[1]*r);\n  // And return the distance to the closest point.\n  return distance(p,p1);\n}\n#else\n// The usual Euclidean distances:\nfloat dist(vec3 p, vec3 q) {\n  return distance(p,q);\n}\n\n// Find the distance from p to the segment between q and r.\nfloat segment(vec3 p, vec3 q, vec3 r) {\n  // Rebase to origin at q  \n  p -= q; r -= q;\n  // t*r is orthogonal projection of p onto qr.\n  float t = clamp(dot(p,r)/dot(r,r), 0.0, 1.0);\n  return distance(p,t*r);\n}\n#endif\n\n// Finish off with some fairly standard utility functions.\n\n// Get the normal of the surface at point p.\nfloat de(vec3 p) { int type; return de(p,type); }\nvec3 getnormal(vec3 p) {\n  float eps = 0.001;\n  vec2 e = vec2(eps,0);\n  return normalize(vec3(de(p + e.xyy) - de(p - e.xyy),\n                        de(p + e.yxy) - de(p - e.yxy),\n                        de(p + e.yyx) - de(p - e.yyx)));\n}\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\n// Rotate according to mouse position\nvec3 transformframe(vec3 p) {\n  if (iMouse.x > 0.0) {\n    // Full range of rotation across the screen.\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  // autorotation\n  if (dorotate) {\n    p.yz = rotate(p.yz,-iTime*0.125);\n    p.zx = rotate(p.zx,iTime*0.1);\n  }\n  return p;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}