{
    "Shader": {
        "info": {
            "date": "1558718760",
            "description": "a fork of [url=https://www.shadertoy.com/view/wt23z1]Traced Columns[/url]\nThis is faster.",
            "flags": 0,
            "hasliked": 0,
            "id": "wtB3RD",
            "likes": 9,
            "name": "Traced Columns - Hamneggs fork",
            "published": 3,
            "tags": [
                "raytracing",
                "ray",
                "tracing",
                "interior",
                "columns",
                "towers",
                "boxes"
            ],
            "usePreview": 0,
            "username": "abje",
            "viewed": 662
        },
        "renderpass": [
            {
                "code": "\n/*\nhttps://shadertoy.com/view/wt23z1\nthe original is a shader by hamneggs and looks identical,\nbut i only modified the tunnel and tunnelshadow function so it is faster\n*/\n\n// Fork of \"Traced Columns\" by Hamneggs. https://shadertoy.com/view/wt23z1\n// 2019-05-23 18:02:02\n\n/**\n * This just traces through a field of cubes that make a box, plus two\n * extra cubes plus lightsources.\n */\n\n\n\n#define ENABLE_SHADOWS /* Compute intensive */\n#define ENABLE_NORMAL_MAPPING\n#define ENABLE_SPECULAR\n\n#define MAT_REFLECTANCE 3.0\n#define BRIGHTNESS 10.0\n#define ID_NONE 0.0\n#define ID_TUNNEL 1.0\n#define ID_LIGHT1 2.0\n#define ID_LIGHT2 4.0\n#define LIGHT1_COLOR vec3(.8,.05,.667)\n#define LIGHT2_COLOR vec3(.05,.05,2.0)\n\n/*\n\tCreates and orientates ray origin and direction vectors based on a\n\tcamera position and direction, with direction and position encoded as\n\tthe camera's basis coordinates.\n*/\nvoid camera(in vec2 uv, in vec3 cp, in vec3 cd, in float f, out vec3 ro, out vec3 rd)\n{\n\tro = cp;\n\trd = normalize((cp + cd*f + cross(cd, vec3(0,1,0))*uv.x + vec3(0,1,0)*uv.y)-ro);\n}\n\n/**\n * Minimum of two 2D vectors.\n */\nvec2 min2( in vec2 a, in vec2 b )\n{\n    if (a.x < b.x) return a;\n    else return b;\n}\n\n/**\n * Minimum of two 3D vectors.\n */\nvec3 min4( in vec3 a, in vec3 b )\n{\n    if (a.x < b.x) return a;\n    else return b;\n}\n\n/**\n * Minimum of two 4D vectors.\n */\nvec4 min4( in vec4 a, in vec4 b )\n{\n    if (a.x < b.x) return a;\n    else return b;\n}\n\n/**\n * Takes the minimum of two intersections.\n */\nvoid minInt(in float distA,  in vec3 normA,  in vec2 uvA,\n            in float distB,  in vec3 normB,  in vec2 uvB,\n            out float distM, out vec3 normM, out vec2 uvM)\n{\n    if ( distA < distB ) { distM = distA; normM = normA; uvM = uvA; }\n    else                 { distM = distB; normM = normB; uvM = uvB; }\n}\n\n/**\n * That random function off of SF.\n */\nfloat rand( in vec2 co )\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\n/**\n * 3D version.\n */\nfloat rand3( in vec3 co )\n{\n    return fract(sin(dot(co ,vec3(12.9898,78.233,-53.1234))) * 43758.5453);\n}\n\n/**\n * Sorta the usual FBM, but without using a noise texture and adding\n * high frequency noise at the end.\n */\nfloat fbm( in vec2 x )\n{\n    float r = texture(iChannel0, x     ).x*.5;\n    r += texture(iChannel0, x*2.0 ).x*.25;\n    r += texture(iChannel0, x*4.0 ).x*.125;\n    r += texture(iChannel0, x*8.0 ).x*.0625;\n    r += rand(x)*.0325;\n    return r;\n}\n    \n\n/**\n * Reference function for light positions.\n */\nvec3 lightpos1() { return vec3(sin(iTime*.5)*3., cos(iTime), 2.+sin(iTime)); }\nvec3 lightpos2() { return vec3(sin(iTime)*3.0, -cos(iTime*.5)*.5, 0); }\n\n/**\n * A kinda sorta smoothsquare function.\n */\nfloat smoothSquare(in float x) { return smoothstep(.3, .7, pow(sin(x),2.)); }\n\n/**\n * IQ Really nailed this one.\n */\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\n/**\n * IQ's sphere intersection.\n */\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h < 0.0 ) return vec2(99999.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n/**\n * IQ's Box intersection.\n */\nfloat iBox( in vec3 row, in vec3 rdw, in mat4 txx, in mat4 txi, in vec3 rad, out vec3 oN, out vec2 oU ) \n{\t\t\t\t \n    // convert from world to box space\n    vec3 rd = (txx*vec4(rdw,0.0)).xyz;\n    vec3 ro = (txx*vec4(row,1.0)).xyz;\n\n\n    // ray-box intersection in box space\n    vec3 m = 1.0/rd;\n    vec3 s = vec3((rd.x<0.0)?1.0:-1.0,\n                  (rd.y<0.0)?1.0:-1.0,\n                  (rd.z<0.0)?1.0:-1.0);\n    vec3 t1 = m*(-ro + s*rad);\n    vec3 t2 = m*(-ro - s*rad);\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF<0.0) return 99999.0;\n\n    // compute normal (in world space), face and UV\n    if( t1.x>t1.y && t1.x>t1.z ) { oN=txi[0].xyz*s.x; oU=ro.yz+rd.yz*t1.x; }\n    else if( t1.y>t1.z   )       { oN=txi[1].xyz*s.y; oU=ro.zx+rd.zx*t1.y; }\n    else                         { oN=txi[2].xyz*s.z; oU=ro.xy+rd.xy*t1.z; }\n\n    return tN; // maybe min(tN,tF)?\n}\n\n\n/**\n * A simplified version.\n */\n#ifdef ENABLE_SHADOWS\nfloat iBoxSimple( in vec3 row, in vec3 rdw, in mat4 txx, in vec3 rad ) \n{\t\t\t\t \n    vec3 rd = (txx*vec4(rdw,0.0)).xyz;\n    vec3 ro = (txx*vec4(row,1.0)).xyz;\n\n    vec3 m = 1.0/rd;\n    vec3 s = vec3((rd.x<0.0)?1.0:-1.0,\n                  (rd.y<0.0)?1.0:-1.0,\n                  (rd.z<0.0)?1.0:-1.0);\n    vec3 t1 = m*(-ro + s*rad);\n    vec3 t2 = m*(-ro - s*rad);\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF<0.0) return 99999.0;\n\n    return tN;\n}\n#endif // ENABLE_SHADOWS\n\n/**\n * Takes a ray, walks it forward, and see if it intersects\n * any columns near it.\n */\nvoid tunnel( in vec3 ro, in vec3 rd, out float d, out vec3 n, out vec2 uv )\n{\n    uv = vec2(0);\n    \n    d = 0.0;\n    float d2 = 9999.0;\n    vec3 fp = floor(ro);\n    vec3 lp = ro-fp;\n    vec3 ird = 1.0/abs(rd);\n    vec3 srd = sign(rd);\n    \n    vec3 lens = abs(step(0.0,rd)-lp)*ird;\n    \n    for (int i = 0; i < 20; i++) {\n        \n        //towers pointing in negative x,y,z direction (the ceiling and two walls)\n        vec3 a = vec3( 0.5*smoothSquare(.25*iTime + 3.14*rand(fp.yz+1.0))+3.5,\n                       0.5*smoothSquare(.25*iTime + 3.14*rand(fp.xz+1.0))+2.5,\n                       0.5*smoothSquare(.25*iTime + 3.14*rand(fp.xy+1.0))+3.5);\n        \n        //towers pointing in positive x,y,z direction (the floor and two walls)\n        vec3 b = vec3(-0.5*smoothSquare(.25*iTime + 3.14*rand(fp.yz+1.0))-3.5,\n                      -0.5*smoothSquare(.25*iTime + 3.14*rand(fp.xz+1.0))-2.5,\n                      -0.5*smoothSquare(.25*iTime + 3.14*rand(fp.xy+1.0))-3.5);\n        \n        // center of opposing towers\n        vec3 e = (a+b)*0.5;\n        // gap between opposing towers\n        vec3 c = e-b;\n        \n        // position in each direction relative to\n        // the tower centers\n        vec3 p = (ro+rd*d)-e;\n        \n        // the intersection distance to each tower\n        // not from the sides, just the top\n        // clamped to 0\n        vec3 f = (c-srd*p)*ird*step(abs(p),vec3(c));\n        \n        //mask finds the smallest number in f\n        vec3 mask2;\n        if (f.x < min(f.y,f.z)) {\n        \tmask2 = vec3(1,0,0);\n        } else if (f.y < f.z) {\n            mask2 = vec3(0,1,0);\n        } else {\n            mask2 = vec3(0,0,1);\n        }\n        \n        // dot(mask2,f) is the same as min(min(f.x,f.y),f.z)\n        float d2 = dot(mask2,f);\n        \n        // since d2 is clamped to 0,\n        // if it is 0 you hit a tower from the side\n        // the normal is already set\n        // exit the loop\n        if (d2 == 0.0) {\n            break;\n        }\n        \n        d2 += d;\n        \n        // finds the closest voxel the ray intersects\n        vec3 mask;\n        if (lens.x < min(lens.y,lens.z)) {\n        \tmask = vec3(1,0,0);\n        } else if (lens.y < lens.z) {\n            mask = vec3(0,1,0);\n        } else {\n            mask = vec3(0,0,1);\n        }\n        \n        // dot(mask, lens) is the same as min(min(f.x,f.y),f.z)\n        d = dot(mask,lens);\n        \n        // if the distance to the closest tower is less than\n        // that to the next voxel, set the normal to the direction\n        // the tower is facing, and exit the loop\n        if (d2 < d) {\n            d = d2;\n            n = mask2*srd;\n            break;\n        }\n        \n        n = mask*srd;\n        \n        fp += n;\n        \n        lens += mask*ird;\n    }\n    \n    // the normal is flipped,\n    // so i flip it back\n    n = -n;\n    vec3 p = ro+rd*d;\n    \n    uv = vec2(dot(n.yzx,p),dot(n.zxy,p));\n    \n    // Now it's time to get the two feature cubes in the middle.\n    \n    vec3 n_f1, n_f2; // Surface normals.\n    vec2 uv_f1, uv_f2; // Texcoords.\n    \n    // Translation matrices.\n    mat4 t_f1 = translate(-.6,-.6,-.6); mat4 t_f1i = inverse(t_f1);\n    mat4 t_f2 = translate( .6, .6, .6); mat4 t_f2i = inverse(t_f2);\n    \n    // Check for intersection.\n    float dist_f1 = iBox(ro, rd, t_f1, t_f1i, vec3(.5), n_f1, uv_f1);\n    float dist_f2 = iBox(ro, rd, t_f2, t_f2i, vec3(.5), n_f2, uv_f2);\n    \n    // Factor them into the equation.\n    minInt( d, n, uv, dist_f1, n_f1, uv_f1, d, n, uv );\n    minInt( d, n, uv, dist_f2, n_f2, uv_f2, d, n, uv );\n    \n    // Perturb the surface normal.\n    #ifdef ENABLE_NORMAL_MAPPING\n    p = ro+d*rd;\n    vec2 texCoord = uv+rand3(floor(p)); \n    vec3 diff = vec3(fbm(texCoord), fbm(texCoord+12348.3), 0);\n    diff = 2.0*diff - 1.0;\n    diff *= .125;\n    vec3 an = abs(n);\n    if( an.x > .5 ) \t n = normalize(n+diff.zxy*sign(n.x));\n    else if( an.y > .5 ) n = normalize(n+diff.xzy*sign(n.y));\n    else\t\t\t\t n = normalize(n+diff.xyz*sign(n.z));\n    #endif // ENABLE_NORMAL_MAPPING\n}\n\n/**\n * Traces a ray through the field. This trace function includes\n * two spheres for the light soruces.\n */\nvoid trace( in vec3 ro, in vec3 rd, out float id, out float dist, out vec3 n, out vec2 uv)\n{\n    tunnel(ro, rd, dist, n, uv);\n    float si1 = iSphere(ro, rd, lightpos1(), .05).x;\n    float si2 = iSphere(ro, rd, lightpos2(), .05).x;\n   \t\n    vec2 minElement = vec2(9999999.0, ID_NONE);\n    minElement = min2(minElement, vec2(dist, ID_TUNNEL));\n    minElement = min2(minElement, vec2(si1,  ID_LIGHT1));\n    minElement = min2(minElement, vec2(si2,  ID_LIGHT2));\n   \tdist = minElement.x;\n    id = minElement.y;\n            \n}\n\n/**\n * Marches a ray forward through a simplified geometry field, since\n * we don't need the UV or normal vector of where the shadow ray\n * collides.\n */\n#ifdef ENABLE_SHADOWS\nvoid tunnelShadow( in vec3 ro, in vec3 rd, out float d )\n{\n    \n    d = 0.0;\n    float d2 = 9999.0;\n    vec3 fp = floor(ro);\n    vec3 lp = ro-fp;\n    vec3 ird = 1.0/abs(rd);\n    vec3 srd = sign(rd);\n    \n    vec3 lens = abs(step(0.0,rd)-lp)*ird;\n    \n    for (int i = 0; i < 20; i++) {\n        \n        //towers pointing in negative x,y,z direction (the ceiling and two walls)\n        vec3 a = vec3( 0.5*smoothSquare(.25*iTime + 3.14*rand(fp.yz+1.0))+3.5,\n                       0.5*smoothSquare(.25*iTime + 3.14*rand(fp.xz+1.0))+2.5,\n                       0.5*smoothSquare(.25*iTime + 3.14*rand(fp.xy+1.0))+3.5);\n        \n        //towers pointing in positive x,y,z direction (the floor and two walls)\n        vec3 b = vec3(-0.5*smoothSquare(.25*iTime + 3.14*rand(fp.yz+1.0))-3.5,\n                      -0.5*smoothSquare(.25*iTime + 3.14*rand(fp.xz+1.0))-2.5,\n                      -0.5*smoothSquare(.25*iTime + 3.14*rand(fp.xy+1.0))-3.5);\n        \n        // center of opposing towers\n        vec3 e = (a+b)*0.5;\n        // gap between opposing towers\n        vec3 c = e-b;\n        \n        // position in each direction relative to\n        // the tower centers\n        vec3 p = (ro+rd*d)-e;\n        \n        // the intersection distance to each tower\n        // not from the sides, just the top.\n        // clamped to 0\n        vec3 f = (c-srd*p)*ird*step(abs(p),vec3(c));\n        \n        //mask finds the smallest number in f\n        vec3 mask2;\n        if (f.x < min(f.y,f.z)) {\n        \tmask2 = vec3(1,0,0);\n        } else if (f.y < f.z) {\n            mask2 = vec3(0,1,0);\n        } else {\n            mask2 = vec3(0,0,1);\n        }\n        \n        // dot(mask2,f) is the same as min(min(f.x,f.y),f.z)\n        float d2 = dot(mask2,f);\n        \n        // since d2 is clamped to 0,\n        // if it is 0 you hit a tower from the side\n        // so you just exit the loop\n        if (d2 == 0.0) {\n            break;\n        }\n        d2 += d;\n        \n        // finds the closest voxel the ray intersects\n        vec3 mask;\n        if (lens.x < min(lens.y,lens.z)) {\n        \tmask = vec3(1,0,0);\n        } else if (lens.y < lens.z) {\n            mask = vec3(0,1,0);\n        } else {\n            mask = vec3(0,0,1);\n        }\n        \n        // dot(mask, lens) is the same as min(min(f.x,f.y),f.z)\n        d = dot(mask,lens);\n        \n        // if the distance to the closest tower is less than\n        // that to the next voxel, exit the loop\n        if (d2 < d) {\n            d = d2;\n            break;\n        }\n        \n        fp += mask*srd;\n        \n        lens += mask*ird;\n    }\n    \n    mat4 t_f1 = translate(-.6,-.6,-.6);\n    mat4 t_f2 = translate( .6, .6, .6);\n    \n    float dist_f1 = iBoxSimple(ro, rd, t_f1, vec3(.5));\n    float dist_f2 = iBoxSimple(ro, rd, t_f2, vec3(.5));\n    \n    d = min(d, dist_f1);\n    d = min(d, dist_f2);\n}\n#endif // ENABLE_SHADOWS\n\n/**\n * Traces a shadow ray through the distance field.\n */\n#ifdef ENABLE_SHADOWS\nvoid traceShadow( in vec3 ro, in vec3 rd, out float dist)\n{\n    tunnelShadow(ro, rd, dist);\n}\n#endif // ENABLE_SHADOWS\n\n/*\n\tOren-Nayar reflectance modeling. I use this everywhere. Just looks good.\n*/\nfloat orenNayar( in vec3 n, in vec3 v, in vec3 ldir )\n{\n    float r2 = pow(MAT_REFLECTANCE, 2.0);\n    float a = 1.0 - 0.5*(r2/(r2+0.57));\n    float b = 0.45*(r2/(r2+0.09));\n\n    float nl = dot(n, ldir);\n    float nv = dot(n, v);\n\n    float ga = dot(v-n*nv,n-n*nl);\n\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));\n}\n\n/**\n * Models a point light.\n */\nvec3 pointLight( in vec3 p, in vec3 n, in vec3 lp, in vec3 rd, in vec3 texel, in vec3 lc )\n{\n    \n    vec3 ld = lp-p; \t\t\t\t\t\t\t\t// Direction of light.\n    float dist = length(ld); \t\t\t\t\t\t// Distance to the light.\n    ld = normalize(ld); \t\t\t\t\t\t\t// Normalize for correct trig.\n    float base = orenNayar(n, rd, ld)*BRIGHTNESS; \t// Base lighting coefficient.\n    float falloff = clamp(1.0/(dist*dist),0.0,1.0); // Quadratic coefficient.\n    \n    // Specular.\n    #ifdef ENABLE_SPECULAR\n    vec3 reflection = normalize(reflect(rd,n));\n    float specular = clamp(pow(clamp(dot(ld, reflection),0.0,1.0),25.0),0.0,1.0);\n    #else\n    float specular = 0.0;\n    #endif // ENABLE_SPECULAR\n    \n    // Optionally do shadows.\n    #ifdef ENABLE_SHADOWS\n    float shadowDist;\n    traceShadow(p+ld*.01, ld, shadowDist);\n    float shadow = smoothstep(dist*.99, dist*1.01,shadowDist);\n    #else\n    float shadow = 1.0;\n    #endif // ENABLE_SHADOWS\n    \n    return lc*specular*shadow + base*falloff*shadow*lc*texel + lc*.0125;\n}\n\n/**\n * Lights the entire scene by tracing both point lights.\n */\nvec3 lightScene( in vec3 p, in vec3 n, in vec3 rd, in vec3 texel )\n{\n    \n    return clamp( pointLight(p, n, lightpos1(), rd, texel, LIGHT1_COLOR) +\n              \t  pointLight(p, n, lightpos2(), rd, texel, LIGHT2_COLOR),\n              \t  vec3(0),vec3(1) );\n}\n\n/**\n * Takes it a step further by coloring based on object ID.\n */\nvec3 shade( in vec3 p, in vec3 n, in vec3 rd, in float dist, in float id )\n{\n    if(id == ID_NONE) return vec3(0);\n    else if(id == ID_TUNNEL) return vec3( lightScene(p+rd*dist, n, rd, vec3(1)) );\n    else if(id == ID_LIGHT1) return LIGHT1_COLOR*BRIGHTNESS*2.0;\n    else if(id == ID_LIGHT2) return LIGHT2_COLOR*BRIGHTNESS*2.0;\n    else return vec3(0);\n}\n\n/**\n * Some quick tonemapping and vignetting.\n */\nvec4 postProcess( in vec3 c, in vec2 uv )\n{\n    float vig = 1.0-dot(uv,uv)*.6;\n    c = pow(clamp(c, 0., 1.), vec3(.4545));\n    return vec4(c*vig,1);\n}\n\n/**\n * Entrypoint.\n */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n    \n    // Set up the camera.\n    \n    // Position.\n    vec3 cp =  vec3(3.0*cos(iTime*.5), sin(iTime*.25), 3.0*sin(iTime*.25));\n    \n    // Direction.\n    vec3 cd = normalize(vec3(-cos(iTime*.5), .5*cos(iTime*.25), -sin(iTime*.25)));\n    \n    // Places to store results.\n    vec3 p, d;\n    \n    // Create the view ray.\n    camera(uv, cp, cd, .667, p, d);\n    \n    // Do the traces.\n    float id; float dist; vec3 n; vec2 texCoord;\n    trace(p, d, id, dist, n, texCoord);\n    \n    // Shade the point.\n    vec3 c = shade(p, n, d, dist, id);\n    \n    \n    \n    // Based on the results of that trace, we shade accordingly.\n    fragColor = postProcess(c, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}