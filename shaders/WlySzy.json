{
    "Shader": {
        "info": {
            "date": "1583006228",
            "description": " volumetric shader following from SebH's improved integration shader, see code for references.",
            "flags": 0,
            "hasliked": 0,
            "id": "WlySzy",
            "likes": 9,
            "name": "Volumetric Cubes",
            "published": 3,
            "tags": [
                "raymarching",
                "volumetric",
                "sebhsebh"
            ],
            "usePreview": 0,
            "username": "aethelwhat",
            "viewed": 433
        },
        "renderpass": [
            {
                "code": "/* \n  raymarching volumes by integration of light sources \n  wrt transmission through the scene, over total distance marched.\n \n  features multiple light sources, volumetric shadows\n  there are no hard surfaces in this scene, but I'll add those in \n  my next shader.\n  \n  What is so interesting about the Volumetric Rendering Equation\n  is that it is essentially a generalization of the rendering equation.\n  a high density cube should be similar to a hard surface cube with a \n  good subsurface scatter approximation.\n  \n  references \n  'Volumetric Integration' by SebH - https://www.shadertoy.com/view/XlBSRz\n  http://www.frostbite.com/2015/08/physically-based-unified-volumetric-rendering-in-frostbite/\n  https://graphics.pixar.com/library/ProductionVolumeRendering/paper.pdf\n */\n\nfloat sdfSphere(vec3 p, float radius){\n    return length(p) - radius;\n}\n\nfloat sdfBoxGrid( vec3 p, vec3 b ) // I removed the positive portion\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0);\n}\n\n// I would like to include hard surfaces in the future which requires a \n// lot of changes:\n// probably a preliminary trace to get the final hit that does not integrate,\n// and then separately integrate over that distance so the integrating\n// ray march distance is not perturbed by tracing close to a surface\n// which I saw when testing this with a fractal sdf.\n// also each light evaluation will check shadows of solids\nfloat map(vec3 p)\n{\n    float minD = 0.05; // restrict max step for better scattering evaluation\n\treturn minD;\n}\n\nvec3 evaluateLight(in vec3 lpos, in vec3 pos)\n{\n    vec3 lightPos = lpos;\n    vec3 L = lightPos-pos;\n    vec3 val = 1.0/dot(L,L) * vec3(1.);\n    return val;\n}\n\n// the map to volumes is actually quite expensive \n// since each march needs to check volumetric shadows\nvoid getParticipatingMedia(out float sigmaS, out float sigmaE, out vec3 mediaColor, in vec3 p, out float dist)\n{\n    float heightFog = -0.6;\n    heightFog = 0.8*clamp((heightFog-p.y)*1.0, 0.0, 1.0);\n    \n    float cubeDensity = pow(1.5, 2.+ p.x );\n    p.xy = mod(p.xy+1.5, vec2(3.))-1.5; // repetition\n    dist = -sdfBoxGrid(p, vec3(1.));\n    dist += heightFog;\n    float boxVol = clamp(dist * cubeDensity, 0., 1.);\n    \n    const float constantFog = 0.0;\n    mediaColor = mix(vec3(1.), vec3(1.,0.,0.), sin(iTime));\n    mediaColor = mix(mediaColor, vec3(0.9,1.1,.8), clamp(heightFog,0.,.1)*10.);\n    \n    sigmaS = constantFog + heightFog*10. + boxVol;\n   \n    float sigmaA = 0.;\n    /* //to showcase absorption vs scattering, with colored absorption which as I understand is more correct.\n    float sigmaAFactor = 0.;\n    if(p.y > .0)\n        sigmaAFactor = 1.;\n    sigmaA = 0.1* sigmaAFactor;\n    mediaColor = mix(vec3(1.), mediaColor, clamp(sigmaAFactor,0.,1.));\n    */\n    \n    sigmaE = max(0.000000001, sigmaA + sigmaS); // to avoid division by zero extinction - sebH\n}\n\nfloat phaseFunction()\n{\n    return 1.0/(4.0*3.14);\n}\n\nfloat volumetricShadow(in vec3 from, in vec3 to)\n{\n    const float numStep = 16.0; // quality control. Bump to avoid shadow alisaing\n    float shadow = 1.0;\n    float sigmaS = 0.0;\n    float sigmaE = 0.0;\n    vec3 ro = from;\n    vec3 rd = to - from;\n    float dd = length(rd) / numStep;\n    for(float s=0.5; s<(numStep-0.1); s+=1.0)// start at 0.5 to sample at center of integral part\n    {\n        vec3 p = ro + rd*(s/(numStep));\n        vec3 mediaColor = vec3(1.);\n        float dist = 0.;\n        getParticipatingMedia(sigmaS, sigmaE, mediaColor, p, dist);\n        shadow *= exp(-sigmaE * dd);\n    }\n    return shadow;\n}\n\nvec3 lightContrib(vec3 p){\n    const int NUM_LIGHTS = 3;\n    vec3 lightPositions[NUM_LIGHTS];\n    lightPositions[0] = vec3(3.5* sin(iTime), 1.5*cos(iTime)+ 2.5, 1.);\n    lightPositions[1] = lightPositions[0] * vec3(-1., 1.7, 1.);\n    lightPositions[2] = vec3(-1.5 * cos(iTime*.5), 0., sin(iTime*.5)*3.);\n    vec3 lightColors[NUM_LIGHTS];\n    lightColors[0] = 100.0*vec3( 1.0, 0.9, .5);\n    lightColors[1] = 20.*vec3(0.2, 0.5, 1.);\n    lightColors[2] = 20.*vec3(1., 1.1, 1.1);\n    vec3 col = vec3(0.);\n    // only checking shadow for the first light source for since it is the biggest\n    // which is visually pleasing but improper for the integral\n    // since evaluating a light source implies checking its shadow (but I'm skipping for the smaller lights)\n    // doing all lights will kill performance\n    col += lightColors[0]*evaluateLight(lightPositions[0], p)*volumetricShadow(p,lightPositions[0]);\n    col += lightColors[1]*evaluateLight(lightPositions[1], p);\n    col += lightColors[2]*evaluateLight(lightPositions[2], p);\n    \n    return col;\n}\n\nvoid trace(vec3 ro, vec3 rd, inout vec3 finalPos, inout vec3 normal, inout vec3 albedo, inout vec4 scatTrans)\n{\n\tconst int numIter = 200;\n\t\n    float sigmaS = 0.0;\n    float sigmaE = 0.0;\n    \n    // Initialize volumetric scattering integration (to view)\n    float transmittance = 1.0;\n    vec3 scatteredLight = vec3(0.0, 0.0, 0.0);\n    \n\tfloat t = 0.01; // hack: always have a first step of 1 unit to go further\n\tfloat material = 0.0;\n\tvec3 p = vec3(0.0, 0.0, 0.0);\n    float dd = 0.0;\n\tfor(int i=0; i<numIter; ++i)\n\t{\n\t\tvec3 p = ro + t*rd;\n        vec3 mediaColor = vec3(1.);\n        float dist = 0.;\n    \tgetParticipatingMedia(sigmaS, sigmaE, mediaColor, p, dist);\n        \n        // following is SebH's improved integration \n        // I've added an absorption color to the media\n        \n        // See slide 28 at http://www.frostbite.com/2015/08/physically-based-unified-volumetric-rendering-in-frostbite/\n        vec3 S = lightContrib(p) * sigmaS * phaseFunction();// incoming light\n        vec3 Sint = (S - S * exp(-sigmaE * dd)) / sigmaE; // integrate along the current step segment\n        scatteredLight += transmittance * Sint * mediaColor; // accumulate and also take into account the transmittance from previous steps\n        // Evaluate transmittance to view independentely\n        transmittance *= exp(-sigmaE * dd);\n        \n        dd = map(p);\n\n\t\tt += dd;\n\t}\n\t\n    finalPos = ro + t*rd;\n    \n    scatTrans = vec4(scatteredLight, transmittance);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    float move = 0.;\n    if(iMouse.z > 0.)\n    \tmove = -.521 + sin(iMouse.x/iResolution.x);\n\t// Camera\n\tvec3 ro = vec3(0., 3.8, -7.); // camera and ray origin\n\tvec3 look = ro + vec3(move, -.1 , .5);  // lookat coordinates.\n    float FOV = 3.14159/3.;\n    vec3 forward = normalize(look-ro);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n\n\tvec3 finalPos = ro;\n\tvec3 albedo = vec3( 0.0, 0.0, 0.0 );\n\tvec3 normal = vec3( 0.0, 0.0, 0.0 );\n    vec4 scattered = vec4( 0.0, 0.0, 0.0, 0.0 );\n    trace(ro, rd, finalPos, normal, albedo, scattered);\n       \n    // this isn's entirely correct but I wanted a background. \n    // background * transmittance + scattered light\n    vec3 color = .25* mix(vec3(0.5,0.3,0.6),vec3(0.8,0.5,0.4),smoothstep(-1.5, .3, rd.y)) * scattered.w + scattered.rgb;\n    \n\tcolor = pow(color, vec3(1./2.2));\n    \n    //debug: transmission\n    //color = vec3(1.) * scattered.w; \n\n    \n\tfragColor = vec4(color, 1.0);\n}\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}