{
    "Shader": {
        "info": {
            "date": "1696493687",
            "description": "realtime GI test",
            "flags": 32,
            "hasliked": 0,
            "id": "mddcRB",
            "likes": 1,
            "name": "RTGI",
            "published": 3,
            "tags": [
                "rtgi"
            ],
            "usePreview": 0,
            "username": "sirjofri",
            "viewed": 82
        },
        "renderpass": [
            {
                "code": "// postprocess\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 color = texture(iChannel0, uv).rgba;\n    vec3 lm = texture(iChannel1, uv).rgb;\n    \n    // place mouse in top half to show lightmap\n    vec2 m = iMouse.xy/iResolution.xy;\n    if (m.y > .5)\n        color = vec4(lm, 1.);\n\n    fragColor = vec4(color);\n}\n\n/* text for converting mesh data from blender */\n/*\n\nimport bpy\nimport struct\n\ntid = 0\narrname = \"triangles\"\n\ndef f2h(f):\n    return hex(struct.unpack('=I', struct.pack('=f', f))[0])\n\ndef v2s(vector):\n    v1 = f2h(vector[0])\n    v2 = f2h(vector[1])\n    v3 = f2h(vector[2])\n    return [v1, v2, v3]\n\ndef u2s(vector):\n    v1 = f2h(vector[0])\n    v2 = f2h(vector[1])\n    return [v1, v2]\n\ndef validlm(vector):\n    if (vector[0] > 0 and vector[0] < 1 and vector[1] > 0 and vector[1] < 1):\n        return \"valid\"\n    else:\n        return \"invalid\"\n\nmylist = []\n\nfor obj in bpy.context.selected_objects:\n    data = obj.data\n    for triangle in data.polygons:\n        uvid1 = -1\n        uvid2 = -1\n        uvid3 = -1\n        for vert_idx, loop_idx in zip(triangle.vertices, triangle.loop_indices):\n            if vert_idx == triangle.vertices[0]:\n                uvid1 = loop_idx\n            if vert_idx == triangle.vertices[1]:\n                uvid2 = loop_idx\n            if vert_idx == triangle.vertices[2]:\n                uvid3 = loop_idx\n        if uvid1 < 0 or uvid2 < 0 or uvid3 < 0:\n            print(\"error: invalid uvid\")\n        v1 = data.vertices[triangle.vertices[0]].co\n        v2 = data.vertices[triangle.vertices[1]].co\n        v3 = data.vertices[triangle.vertices[2]].co\n        n1 = data.vertex_normals[triangle.vertices[0]].vector\n        n2 = data.vertex_normals[triangle.vertices[1]].vector\n        n3 = data.vertex_normals[triangle.vertices[2]].vector\n        u1 = data.uv_layers[0].data[uvid1].uv\n        #u1[0] = 1-u1[0]\n        u2 = data.uv_layers[0].data[uvid2].uv\n        #u2[0] = 1-u2[0]\n        u3 = data.uv_layers[0].data[uvid3].uv\n        #u3[0] = 1-u3[0]\n        l1 = data.uv_layers[1].data[uvid1].uv\n        l1[0] = 1-l1[0]\n        l2 = data.uv_layers[1].data[uvid2].uv\n        l2[0] = 1-l2[0]\n        l3 = data.uv_layers[1].data[uvid3].uv\n        l3[0] = 1-l3[0]\n        m = triangle.material_index\n        n = triangle.normal\n        print(f\"   - new triangle -\")\n        print(f\"PointA = vec3({v1[0]}, {v1[1]}, {v1[2]});\")\n        print(f\"PointB = vec3({v2[0]}, {v2[1]}, {v2[2]});\")\n        print(f\"PointC = vec3({v3[0]}, {v3[1]}, {v3[2]});\")\n#        print(f\"NormalA = vec3({n1[0]}, {n1[1]}, {n1[2]});\")\n#        print(f\"NormalB = vec3({n2[0]}, {n2[1]}, {n2[2]});\")\n#        print(f\"NormalC = vec3({n3[0]}, {n2[1]}, {n3[2]});\")\n        print(f\"NormalA = vec3({n[0]}, {n[1]}, {n[2]});\")\n        print(f\"Material = {m};\")\n        print(f\"UVA = vec2({u1[0]}, {u1[1]});\")\n        print(f\"UVB = vec2({u2[0]}, {u2[1]});\")\n        print(f\"UVC = vec2({u3[0]}, {u3[1]});\")\n        print(f\"LUVA = vec2({l1[0]}, {l1[1]}); // {validlm(l1)}\")\n        print(f\"LUVB = vec2({l2[0]}, {l2[1]}); // {validlm(l2)}\")\n        print(f\"LUVC = vec2({l3[0]}, {l3[1]}); // {validlm(l3)}\")\n        mylist.extend(v2s(v1))\n        mylist.extend(v2s(v2))\n        mylist.extend(v2s(v3))\n        mylist.extend(v2s(n)) # take face normal\n        mylist.extend(v2s(n))\n        mylist.extend(v2s(n))\n        mylist.append(hex(m))\n        mylist.extend(u2s(u1))\n        mylist.extend(u2s(u2))\n        mylist.extend(u2s(u3))\n        mylist.extend(u2s(l1))\n        mylist.extend(u2s(l2))\n        mylist.extend(u2s(l3))\n\ntry:\n    mytext = bpy.data.texts[\"triangle_data\"]\nexcept:\n    bpy.data.texts.new(\"triangle_data\")\n    mytext = bpy.data.texts[\"triangle_data\"]\n\nmytext.clear()\nmytext.write(f\"{'u,'.join(mylist)}u\")\n\n*/",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// generate lightmap using pathtracing\n\n#define MAXLIGHT .3\n#define MAXBOUNCES 2\n\n//#define LIGHTINGONLY\n\nvec3 shader0(vec2 uv) {\n#ifdef LIGHTINGONLY\n    return vec3(.7);\n#else\n    return texture(iChannel1, uv*2.).rgb;\n#endif\n}\n\nvec3 shader1(vec2 uv) {\n#ifdef LIGHTINGONLY\n    return vec3(.7);\n#else\n    return texture(iChannel2, uv).rgb;\n#endif\n}\n\nvec3 shader2(vec2 uv) {\n#ifdef LIGHTINGONLY\n    return vec3(.7);\n#else\n    return texture(iChannel3, uv*.5).rgb;\n#endif\n}\n\nvec3 shadecol(int triangle, vec3 bary)\n{\n    Triangle t = unpackTriangle(triangle);\n    vec2 uv = t.UVA*bary.x + t.UVB*bary.y + t.UVC*bary.z;\n    if (t.MaterialID == 0) return shader0(uv);\n    if (t.MaterialID == 1) return shader1(uv);\n    if (t.MaterialID == 2) return shader2(uv);\n    return vec3(1., 0., 1.);\n}\n\nvec3 tuv2wp(Triangle t, vec3 bary)\n{\n    return t.PointA*bary.x + t.PointB*bary.y + t.PointC*bary.z;\n}\n\nHitPoint trace(vec3 wp, vec3 wn, vec3 raydir, int triangle)\n{\n    HitPoint ret;\n    ret.triangle = -1;\n    ret.bary = vec3(-1.);\n    ret.dist = -1.;\n    \n    int hit = -1;\n    float hitdist = -1.;\n    vec3 hitbary = vec3(0.);\n    for (int j = 0; j < triangleLength(); j++) {\n        if (j == triangle) continue;\n        Triangle t = unpackTriangle(j);\n        vec3 center = (((t.PointB - t.PointA)/2. + t.PointA) - t.PointC)/2. + t.PointC;\n        vec3 normal = normalize((t.NormalA + t.NormalB + t.NormalC) * 0.5); // average normal of triangle\n\n        // check if we hit plane\n        float denom = dot(normal, raydir);\n        if (!(abs(denom) > 0.0001f)) continue;\n\n        float testt = dot((center - wp), normal) / denom;\n        if (testt < 0.) continue;\n\n        // if not inside triangle, continue\n        vec3 b = bary3d(t.PointA, t.PointB, t.PointC, wp + testt*raydir);\n        if (!baryinside(b))\n            continue;\n\n        if (hit >= 0) {\n            if (hitdist < testt)\n                continue;\n            hit = j;\n            hitdist = testt;\n            hitbary = b;\n        } else {\n            hit = j;\n            hitdist = testt; // distance from wp. hitpos = wp + hitdist*raydir\n            hitbary = b;\n        }\n    }\n    \n    if (hit < 0)\n        return ret;\n    \n    ret.triangle = hit;\n    ret.bary = hitbary;\n    ret.dist = hitdist;\n    return ret;\n}\n\nvec4 tracerow(vec3 wp, vec3 wn, vec3 raydir, int triangle)\n{\n    vec3 color = vec3(.8, .9, 1.);\n    float totaldist = -1.;\n    vec3 rd = raydir;\n    for (int i = 0; i < MAXBOUNCES; i++) {\n        HitPoint h = trace(wp, wn, rd, triangle);\n        if (h.triangle < 0) {\n            //color *= vec3(1.); //vec3(1., 0., 1.); // sky\n            totaldist += 50.;\n            break;\n        }\n        color *= shadecol(h.triangle, h.bary); // * clamp(MAXLIGHT - h.dist, 0., 1.); // needs lighting model from distance\n        totaldist += h.dist;\n        wp = wp + rd*h.dist;\n        triangle = h.triangle;\n        wn = hit2n(h);\n        rd = reflect(rd, wn);\n    }\n    \n    return vec4(color, totaldist);\n    \n    // todo: trace in loop\n    HitPoint h = trace(wp, wn, raydir, triangle);\n    if (h.triangle < 0)\n        return vec4(-1.);\n    \n    return vec4(shadecol(h.triangle, h.bary), h.dist);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    buildscene();\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    vec3 thissample = col; // default to nop\n    for (int i = 0; i < triangleLength(); i++) {\n        Triangle t = unpackTriangle(i);\n        \n        float m = edge(t.LUVC, t.LUVB, uv);\n        float n = edge(t.LUVA, t.LUVC, uv);\n        float o = edge(t.LUVB, t.LUVA, uv);\n        bool inside = m > 0. && n > 0. && o > 0.;\n        if (!inside)\n            continue;\n        \n        float area = edge(t.LUVB, t.LUVA, t.LUVC);\n        vec3 bary = vec3(\n            m/area, n/area, o/area\n        );\n        \n        vec3 wp = tuv2wp(t, bary);\n        vec3 wn = t.NormalA*bary.x + t.NormalB*bary.y + t.NormalC*bary.z;\n        \n        vec3 matcol = shadecol(i, bary);\n        thissample = matcol;\n        \n        vec3 raydir = normalize(vrand(iTime + fract(wp.x+wp.y+wp.z)));\n        if (dot(raydir, wn) < 0.)\n            raydir *= -1.;\n        \n        vec4 result = tracerow(wp, wn, raydir, i);\n        \n        if (result.a < 0.)\n            continue;\n        \n        thissample = result.rgb * matcol;\n    }\n    \n    float m = clamp(pow(clamp((5.-iTime)/5., 0., 1.), 2.), 0.005, 1.);\n    fragColor = vec4(mix(col, thissample, m), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "struct Triangle {\n    vec3 PointA;     // 0\n    vec3 PointB;     // 3\n    vec3 PointC;     // 6\n    vec3 NormalA;    // 9\n    vec3 NormalB;    // 12\n    vec3 NormalC;    // 15\n    int MaterialID;  // 18\n    vec2 UVA;        // 19\n    vec2 UVB;        // 21\n    vec2 UVC;        // 23\n    vec2 LUVA;       // 25\n    vec2 LUVB;       // 27\n    vec2 LUVC;       // 29\n};                   // 31\n\nTriangle SceneTriangles[6];\n\n// prepare for data serialization\nconst uint data[] = uint[](\n0xbef03518u,0xbdcf1af0u,0x3e4cccd0u,0xbf1d8bc3u,0x3d108918u,0x0u,0xbef03518u,0xbdcf1af0u,0x0u,0xbf2e9baau,0xbf3b3610u,0x0u,0xbf2e9baau,0xbf3b3610u,0x0u,0xbf2e9baau,0xbf3b3610u,0x0u,0x1u,0x372c0000u,0x40400000u,0x3f800056u,0x40000001u,0x3f800056u,0x40400000u,0x3de359c8u,0x3e63a870u,0x38d1c000u,0x3eaa9d8fu,0x38d1c000u,0x3e63a870u,0xbf1d8bc3u,0x3d108918u,0x3e4cccd0u,0xbef53fa6u,0x3e39e720u,0x0u,0xbf1d8bc3u,0x3d108918u,0x0u,0xbf3b360du,0x3f2e9badu,0x0u,0xbf3b360du,0x3f2e9badu,0x0u,0xbf3b360du,0x3f2e9badu,0x0u,0x1u,0x3f800056u,0x3f800000u,0x372e0000u,0x0u,0x3f800056u,0x34000000u,0x3de359c8u,0x3de3c2a7u,0x38d1c000u,0x3e637402u,0x38d1c000u,0x3de3c2a7u,0xbef53fa6u,0x3e39e720u,0x3e4cccd0u,0xbeaa5d39u,0x3d38dd88u,0x0u,0xbef53fa6u,0x3e39e720u,0x0u,0x3f2e9babu,0x3f3b360eu,0x0u,0x3f2e9babu,0x3f3b360eu,0x0u,0x3f2e9babu,0x3f3b360eu,0x0u,0x1u,0x372c0000u,0x40000000u,0x3f800056u,0x3f800000u,0x3f800056u,0x40000000u,0x3f7ff972u,0x3f6394c7u,0x3f6394c7u,0x3f7ff972u,0x3f6394c7u,0x3f6394c7u,0xbeaa5d39u,0x3d38dd88u,0x3e4cccd0u,0xbef03518u,0xbdcf1af0u,0x0u,0xbeaa5d39u,0x3d38dd88u,0x0u,0x3f3b360eu,0xbf2e9babu,0x0u,0x3f3b360eu,0xbf2e9babu,0x0u,0x3f3b360eu,0xbf2e9babu,0x0u,0x2u,0x3f800057u,0x3f800000u,0x4000002cu,0x0u,0x4000002cu,0x3f800000u,0x3de359c8u,0x38d1b717u,0x38d1c000u,0x3de359cbu,0x38d1c000u,0x38d1b717u,0xbf1d8bc3u,0x3d108918u,0x3e4cccd0u,0xbeaa5d39u,0x3d38dd88u,0x3e4cccd0u,0xbef53fa6u,0x3e39e720u,0x3e4cccd0u,0x0u,0x0u,0x3f800000u,0x0u,0x0u,0x3f800000u,0x0u,0x0u,0x3f800000u,0x0u,0x4000002bu,0x3f800001u,0x3f800056u,0x40000001u,0x3f800057u,0x3f800001u,0x3f6387abu,0x3f6394c7u,0x3f472300u,0x3f7ff972u,0x3f472300u,0x3f6394c7u,0x3f800000u,0xbf800000u,0x0u,0xbf800000u,0x3f800000u,0x0u,0xbf800000u,0xbf800000u,0x0u,0x80000000u,0x0u,0x3f800000u,0x80000000u,0x0u,0x3f800000u,0x80000000u,0x0u,0x3f800000u,0x0u,0x3f800000u,0x0u,0x0u,0x3f800000u,0x0u,0x0u,0x3f7ff972u,0x38d1b717u,0x3de3c2a8u,0x3f6387abu,0x3de3c2a8u,0x38d1b717u,0xbef03518u,0xbdcf1af0u,0x3e4cccd0u,0xbf1d8bc3u,0x3d108918u,0x3e4cccd0u,0xbf1d8bc3u,0x3d108918u,0x0u,0xbf2e9baau,0xbf3b3610u,0x0u,0xbf2e9baau,0xbf3b3610u,0x0u,0xbf2e9baau,0xbf3b3610u,0x0u,0x1u,0x372c0000u,0x40400000u,0x372c0000u,0x40000001u,0x3f800056u,0x40000001u,0x3de359c8u,0x3e63a870u,0x3de359c8u,0x3eaa9d8fu,0x38d1c000u,0x3eaa9d8fu,0xbf1d8bc3u,0x3d108918u,0x3e4cccd0u,0xbef53fa6u,0x3e39e720u,0x3e4cccd0u,0xbef53fa6u,0x3e39e720u,0x0u,0xbf3b360du,0x3f2e9badu,0x0u,0xbf3b360du,0x3f2e9badu,0x0u,0xbf3b360du,0x3f2e9badu,0x0u,0x1u,0x3f800056u,0x3f800000u,0x372c0000u,0x3f800000u,0x372e0000u,0x0u,0x3de359c8u,0x3de3c2a7u,0x3de359c8u,0x3e637402u,0x38d1c000u,0x3e637402u,0xbef53fa6u,0x3e39e720u,0x3e4cccd0u,0xbeaa5d39u,0x3d38dd88u,0x3e4cccd0u,0xbeaa5d39u,0x3d38dd88u,0x0u,0x3f2e9babu,0x3f3b360eu,0x80000000u,0x3f2e9babu,0x3f3b360eu,0x80000000u,0x3f2e9babu,0x3f3b360eu,0x80000000u,0x1u,0x372c0000u,0x40000000u,0x372c0000u,0x3f800000u,0x3f800056u,0x3f800000u,0x3f7ff972u,0x3f6394c7u,0x3f7ff972u,0x3f7ff972u,0x3f6394c7u,0x3f7ff972u,0xbeaa5d39u,0x3d38dd88u,0x3e4cccd0u,0xbef03518u,0xbdcf1af0u,0x3e4cccd0u,0xbef03518u,0xbdcf1af0u,0x0u,0x3f3b360eu,0xbf2e9babu,0x0u,0x3f3b360eu,0xbf2e9babu,0x0u,0x3f3b360eu,0xbf2e9babu,0x0u,0x2u,0x3f800057u,0x3f800000u,0x3f800057u,0x0u,0x4000002cu,0x0u,0x3de359c8u,0x38d1b717u,0x3de359c8u,0x3de359cbu,0x38d1c000u,0x3de359cbu,0xbf1d8bc3u,0x3d108918u,0x3e4cccd0u,0xbef03518u,0xbdcf1af0u,0x3e4cccd0u,0xbeaa5d39u,0x3d38dd88u,0x3e4cccd0u,0x0u,0x0u,0x3f800000u,0x0u,0x0u,0x3f800000u,0x0u,0x0u,0x3f800000u,0x0u,0x4000002bu,0x3f800001u,0x4000002bu,0x40000001u,0x3f800056u,0x40000001u,0x3f6387abu,0x3f6394c7u,0x3f6387abu,0x3f7ff972u,0x3f472300u,0x3f7ff972u,0x3f800000u,0xbf800000u,0x0u,0x3f800000u,0x3f800000u,0x0u,0xbf800000u,0x3f800000u,0x0u,0x80000000u,0x0u,0x3f800000u,0x80000000u,0x0u,0x3f800000u,0x80000000u,0x0u,0x3f800000u,0x0u,0x3f800000u,0x0u,0x3f800000u,0x3f800000u,0x0u,0x3f800000u,0x3f7ff972u,0x38d1b717u,0x3f7ff972u,0x3f6387abu,0x3de3c2a8u,0x3f6387abu\n);\n\nTriangle unpackTriangle(int id)\n{\n    //return SceneTriangles[id];\n    Triangle t;\n    int offset = 31;\n    int i = id*offset;\n    \n    t.PointA  = vec3(uintBitsToFloat(data[i   ]), uintBitsToFloat(data[i+ 1]), uintBitsToFloat(data[i+ 2]));\n    t.PointB  = vec3(uintBitsToFloat(data[i+ 3]), uintBitsToFloat(data[i+ 4]), uintBitsToFloat(data[i+ 5]));\n    t.PointC  = vec3(uintBitsToFloat(data[i+ 6]), uintBitsToFloat(data[i+ 7]), uintBitsToFloat(data[i+ 8]));\n    t.NormalA = vec3(uintBitsToFloat(data[i+ 9]), uintBitsToFloat(data[i+10]), uintBitsToFloat(data[i+11]));\n    t.NormalB = vec3(uintBitsToFloat(data[i+12]), uintBitsToFloat(data[i+13]), uintBitsToFloat(data[i+14]));\n    t.NormalC = vec3(uintBitsToFloat(data[i+15]), uintBitsToFloat(data[i+16]), uintBitsToFloat(data[i+17]));\n    t.MaterialID = int(data[i+18]);\n    t.UVA  = vec2(uintBitsToFloat(data[i+19]), uintBitsToFloat(data[i+20]));\n    t.UVB  = vec2(uintBitsToFloat(data[i+21]), uintBitsToFloat(data[i+22]));\n    t.UVC  = vec2(uintBitsToFloat(data[i+23]), uintBitsToFloat(data[i+24]));\n    t.LUVA = vec2(uintBitsToFloat(data[i+25]), uintBitsToFloat(data[i+26]));\n    t.LUVB = vec2(uintBitsToFloat(data[i+27]), uintBitsToFloat(data[i+28]));\n    t.LUVC = vec2(uintBitsToFloat(data[i+29]), uintBitsToFloat(data[i+30]));\n    \n    return t;\n}\n\nint triangleLength()\n{\n    //return SceneTriangles.length();\n    return data.length() / 31;\n}\n\nstruct HitPoint {\n    int triangle;\n    vec3 bary;\n    float dist;\n};\n\nvec3 hit2n(HitPoint h)\n{\n    Triangle t = unpackTriangle(h.triangle);\n    return normalize(t.NormalA*h.bary.x + t.NormalB*h.bary.y + t.NormalC*h.bary.z);\n}\n\nvec3 hit2w(HitPoint h)\n{\n    Triangle t = unpackTriangle(h.triangle);\n    return t.PointA*h.bary.x + t.PointB*h.bary.y + t.PointC*h.bary.z;\n}\n\n\nfloat rand(float x)\n{\n    return fract(sin(x) * 43758.5453);\n}\n\nfloat frand(float x)\n{\n    return rand(x) * 2. - 1.;\n}\n\nvec3 vrand(float x)\n{\n    return vec3(frand(fract(x)), frand(fract(x+0.1)), frand(fract(x+0.2)));\n}\n\n\nfloat edge(vec2 v0, vec2 v1, vec2 p) {\n    return (p.x-v0.x)*(v1.y-v0.y)-(p.y-v0.y)*(v1.x-v0.x);\n}\n\n// from https://math.stackexchange.com/questions/544946/determine-if-projection-of-3d-point-onto-plane-is-within-a-triangle/544947\nvec3 bary3d(vec3 A, vec3 B, vec3 C, vec3 P)\n{\n    vec3 u = B - A;\n    vec3 v = C - A;\n    vec3 n = cross(u, v);\n    vec3 w = P - A;\n    \n    float a = dot(n, n);\n    \n    float gamma = dot(cross(u, w), n) / a;\n    float beta  = dot(cross(w, v), n) / a;\n    float alpha = 1. - gamma - beta;\n    return vec3(alpha, beta, gamma);\n}\n\nbool baryinside(vec3 b)\n{\n    return b.x >= 0. && b.x <= 1.\n        && b.y >= 0. && b.y <= 1.\n        && b.z >= 0. && b.z <= 1.;\n}\n\nvoid calclightmap(int tid, float scale, vec2 offset)\n{\n    Triangle t = SceneTriangles[tid];\n    SceneTriangles[tid].LUVA = t.UVA*scale + offset;\n    SceneTriangles[tid].LUVB = t.UVB*scale + offset;\n    SceneTriangles[tid].LUVC = t.UVC*scale + offset;\n}\n\nvoid addplane(int tid, vec3 v1, vec3 v2, vec3 v3, vec3 v4, float scale, vec2 offset, int mat)\n{\n    vec3 t1n = normalize(cross(v2-v1, v3-v1));\n    vec3 t2n = normalize(cross(v3-v1, v4-v1));\n    SceneTriangles[tid] = Triangle(\n        v1,\n        v2,\n        v3,\n        t1n,\n        t1n,\n        t1n,\n        mat,\n        vec2(0., 0.),\n        vec2(1., 0.),\n        vec2(1., 1.),\n        vec2(0.),\n        vec2(0.),\n        vec2(0.)\n    );\n    SceneTriangles[tid+1] = Triangle(\n        v1,\n        v3,\n        v4,\n        t2n,\n        t2n,\n        t2n,\n        mat,\n        vec2(0., 0.),\n        vec2(1., 1.),\n        vec2(0., 1.),\n        vec2(0.),\n        vec2(0.),\n        vec2(0.)\n    );\n    calclightmap(tid, scale, offset);\n    calclightmap(tid+1, scale, offset);\n}\n\nvoid addbox(int tid, vec3 p, vec3 q, float scale, vec2 offset, int mat)\n{\n    vec3 v1, v2, v3, v4;\n    \n    // x-\n    v1 = p;\n    v2 = vec3(q.x, p.y, p.z);\n    v3 = vec3(q.x, p.y, q.z);\n    v4 = vec3(p.x, p.y, q.z);\n    addplane(tid, v1, v2, v3, v4, scale/2., offset, mat);\n    \n    // y-\n    v1 = vec3(p.x, q.y, p.z);\n    v2 = p;\n    v3 = vec3(p.x, p.y, q.z);\n    v4 = vec3(p.x, q.y, q.z);\n    addplane(tid+2, v1, v2, v3, v4, scale/2., offset+offset*vec2(scale/2., 0.), mat);\n}\n\nvoid buildscene()\n{\n    addplane(0, vec3(0.), vec3(1., 0., 0.), vec3(1., 1., 0.), vec3(0., 1., 0.), 0.5, vec2(0.), 1);\n    addplane(2, vec3(.5, .4, 0.), vec3(.7, .4, 0.), vec3(.7, .4, .2), vec3(.5, .4, .2), .25, vec2(.5, 0.), 2);\n    addplane(4, vec3(.5, .6, 0.), vec3(.5, .4, 0.), vec3(.5, .4, .2), vec3(.5, .6, .2), .25, vec2(.75, 0.), 3);\n    \n    //addbox(4, vec3(.5, .7, 0.), vec3(.7, .9, .2), .1, vec2(0., .5), 2);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// raytrace and composite final colors\n\nvec3 rotation = vec3(0.);\nvec3 rotate(vec3 p)\n{\n    mat3 yaw = mat3(\n        cos(rotation.x), -sin(rotation.x), 0.,\n        sin(rotation.x),  cos(rotation.x), 0.,\n        0.      ,  0.      , 1.\n    );\n    mat3 pitch = mat3(\n        1.,       0.,        0.,\n        0., cos(rotation.y), -sin(rotation.y),\n        0., sin(rotation.y),  cos(rotation.y)\n    );\n    mat3 roll = mat3(\n         cos(rotation.z), 0., sin(rotation.z),\n               0., 1.,       0.,\n        -sin(rotation.z), 0., cos(rotation.z)\n    );\n    \n    p *= roll;\n    p *= pitch;\n    p *= yaw;\n    return normalize(p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 ouv = uv;\n\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec3 lm = texture(iChannel0, uv).rgb;\n    \n    uv -= 0.5;\n    uv.y *= iResolution.y/iResolution.x;\n    \n    float ts = iTime*.3;\n    \n    vec3 ro = vec3(sin(ts)*.2-.7, -2.2, 1.3);\n    rotation = vec3(-0.3-cos(ts)*.1, -.6, 0.);\n    vec2 randr = vec2(frand(float(iFrame+3)), frand(float(iFrame+5)))/iResolution.xy/3.;\n    vec3 rd = rotate(normalize(vec3(uv.x+randr.x, 1., uv.y+randr.y)));\n    \n    bool validfragment = false;\n    \n    vec3 color = vec3(0.);\n    \n    buildscene();\n    \n    int hit = -1;\n    float hitdist;\n    vec3 hitbary;\n    for (int i = 0; i < triangleLength(); i++) {\n        Triangle t = unpackTriangle(i);\n        \n        vec3 center = (((t.PointB - t.PointA)/2. + t.PointA) - t.PointC)/2. + t.PointC;\n        vec3 normal = normalize((t.NormalA + t.NormalB + t.NormalC) * 0.5); // average normal of triangle\n        \n        // check if we hit plane\n        float denom = dot(normal, rd);\n        if (!(abs(denom) > 0.0001f)) continue;\n        \n        float testt = dot((center - ro), normal) / denom;\n        if (testt < 0.) continue;\n        \n        vec3 b = bary3d(t.PointA, t.PointB, t.PointC, ro + testt*rd);\n        if (!baryinside(b))\n            continue;\n        \n        if (hit >= 0) {\n            if (hitdist < testt)\n                continue;\n            hit = i;\n            hitdist = testt;\n            hitbary = b;\n        } else {\n            hit = i;\n            hitdist = testt; // distance from wp. hitpos = wp + hitdist*raydir\n            hitbary = b;\n        }\n    }\n    \n    if (hit < 0)\n        color = vec3(0.);\n    else {\n        Triangle t = unpackTriangle(hit);\n        vec3 hitpos = ro + hitdist*rd;\n        vec2 luv = t.LUVA*hitbary.x + t.LUVB*hitbary.y + t.LUVC*hitbary.z;\n        color = texture(iChannel0, luv).rgb;\n    }\n\n    fragColor = mix(texture(iChannel1, ouv), vec4(color, hitdist), 0.4);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "vec3 pow3(vec3 p, float e)\n{\n    return vec3(pow(p.x, e), pow(p.y, e), pow(p.z, e));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 color = pow3(texture(iChannel0, uv).rgb, 1.5);\n\n    fragColor = vec4(color, 1.0);\n    //fragColor = vec4(vec3(fract(texture(iChannel0, uv).a)), 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}