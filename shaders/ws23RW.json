{
    "Shader": {
        "info": {
            "date": "1548343561",
            "description": "learning raymarch distance field, add soft shadow and reflection",
            "flags": 0,
            "hasliked": 0,
            "id": "ws23RW",
            "likes": 2,
            "name": "reflect cube and sphere",
            "published": 3,
            "tags": [
                "reflection",
                "raymarch",
                "cube",
                "sphere"
            ],
            "usePreview": 0,
            "username": "w450468524",
            "viewed": 557
        },
        "renderpass": [
            {
                "code": "const int MAX_STEP_SIZE = 100;\nconst float THRESHOLD = 0.01;\n\nconst vec3 SUN_COLOR = vec3(1.0, 1.0, 1.0);\nconst vec3 AMBIENT_COLOR = vec3(0.5, 0.5, 0.5);\nconst float epsilon = 0.01;\n\n\nvec3 getRay(vec2 screenCoord, vec3 eyePos, vec3 right, vec3 up, vec3 front, float dist)\n{\n    float uScreenWidthInv = 1.0 / iResolution.x;\n    float uScreenHeightInv = 1.0 / iResolution.y;\n    float uAspectRatio = iResolution.x / iResolution.y;\n    return normalize((2.0 * screenCoord.x * uScreenWidthInv - 1.0) * uAspectRatio * right + (2.0 * screenCoord.y * uScreenHeightInv - 1.0) * up + front * dist);\n}\n\nvec4 sphereDf(vec3 pos, float radius)\n{\n\n    return vec4( 0.5, 0.7, 0.1 ,length(pos) - radius);\n}\n\nvec4 planeDf(vec3 pos, vec4 n)\n{\n    return vec4(0.7, 0.7, 0.7, dot(pos, n.xyz) - n.w);\n}\n\nvec3 rotateDir(vec3 dir, vec3 angle)\n{\n    mat3 xMat = mat3(\n        1.0, 0, 0,\n        0, cos(angle.x), -sin(angle.x),\n        0, sin(angle.x), cos(angle.x)\n    );\n\n    mat3 yMat = mat3(\n        cos(angle.y), 0, sin(angle.y),\n        0, 1.0, 0,\n        -sin(angle.y), 0, cos(angle.y)\n    );\n    mat3 zMat = mat3(\n        cos(angle.z), -sin(angle.z), 0,\n        sin(angle.z), cos(angle.z), 0,\n        0, 0, 1.0\n    );\n    return zMat * yMat * xMat* dir;\n}\n\nvec4 boxDf(vec3 p, vec3 dims)\n{\n    vec3 d = abs(p) - dims;\n    return vec4(0.2, 0.4, 0.8, length(max(d, 0.0)) + min(max(max(d.x, d.y), d.z), 0.0));\n}\n\n#define GEO_COUNT 4\nvec4 df(vec3 p)\n{\n    vec4 planeNormal = vec4(normalize(vec3(0, 1, 0)), 0.0);\n    vec3 tShpere = -vec3(1.5, 1.0, -3.0);\n    vec3 tBox = -vec3(-1.5, 1.0, -3.0);\n\n    vec4 d[GEO_COUNT];\n    d[0] = sphereDf(p + tShpere, 1.0);\n    d[1] = planeDf(p, planeNormal);\n    d[2] = boxDf(rotateDir(p + tBox, vec3(0, radians(-mod(iTime * 20.0, 360.0)), 0)), vec3(1.0, 1.0, 1.0));\n    d[3] = sphereDf(p + tBox - vec3(0.0, 3.0, -2.0), 1.0);\n\n    vec4 minDis = d[0];\n\n    for (int i = 1; i < GEO_COUNT; i++)\n    {\n        if (d[i].w < minDis.w)\n            minDis = d[i];\n    }\n    return minDis;\n}\n\nvec3 calcNormal( vec3 p ) // for function f(p)\n{\n    const float h = 0.0001; // or some other value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*df( p + k.xyy*h ).w + \n                     k.yyx*df( p + k.yyx*h ).w + \n                     k.yxy*df( p + k.yxy*h ).w + \n                     k.xxx*df( p + k.xxx*h ).w );\n}\n\nvec3 normal1(vec3 p)\n{\n    vec2 delta = vec2(epsilon, 0);\n    return normalize(vec3(\n        df(p + delta.xyy).w - df(p - delta.xyy).w,\n        df(p + delta.yxy).w - df(p - delta.yxy).w,\n        df(p + delta.yyx).w - df(p - delta.yyx).w\n    ));\n}\n\n// use minDist and maxDist as for terminate condition\nfloat shadow(vec3 pos, vec3 lightDir, float k)\n{\n    float res = 1.0;\n    vec3 p = pos + lightDir * 0.1;\n    for (int i = 0; i < 100; i++)\n    {\n        float dist = df(p).w;\n\n        if (dist < 0.01)\n        {\n            return 0.0;\n        }\n        p = p + lightDir * dist;\n\n        res = min(res, dist * k / length(p - pos));\n    }\n\n    return res;\n}\n\n#define MIN_DIST 0.1\n#define MAX_DIST 10.0\nfloat shadowImprove(vec3 pos, vec3 lightDir, float k)\n{\n    float res = 1.0;\n    float dist = MIN_DIST;\n    for (int i = 0; i < MAX_STEP_SIZE; i++)\n    {\n        vec3 p = pos + lightDir*dist;\n        float d = df(p).w;\n        if (d < 0.01)\n            return 0.0;\n\n        res = min(res, d * k / dist);\n        dist += d;\n\n        if (dist > MAX_DIST)\n            break;\n    }\n\n    return res;\n}\n\n#define PI 3.1415926535897\n#define PI_INV 0.31830988618379067153776752674503\n\nvec3 shading(vec3 curPos, vec3 ray, vec3 ambientColor, vec3 SUN_DIR, vec3 normal)\n{\n    float shadowFactor = shadowImprove(curPos, SUN_DIR, 15.0);\n    if(ambientColor != vec3(0.7))\n    \tshadowFactor = clamp(shadowFactor + 0.9, 0.0, 1.0);\n\n    float diffuseRatio = clamp(dot(SUN_DIR, normal), 0.0, 1.0);\n    float specularRatio = pow(clamp(dot(normalize(-ray + SUN_DIR), normal), 0.0, 1.0), 5.0) * diffuseRatio * 0.51725356504865984124887223096067/*(8 + 5)/(8 * PI)*/;\n\n    vec3 diffColor = diffuseRatio * ambientColor  * shadowFactor * PI_INV;\n    vec3 specularColor = specularRatio * SUN_COLOR * shadowFactor;\n\n    return vec3(ambientColor * 0.2 + diffColor + specularColor);\n}\n\nmat4 rayMarch(vec3 eyePos, vec3 ray, vec3 SUN_DIR)\n{\n    vec3 fragColor = vec3(0.0);\n    vec3 normal;\n    vec3 curPos = eyePos + ray * 0.1;\n    vec4 dist;\n    for (int i = 0; i < MAX_STEP_SIZE; i++)\n    {\n        dist = df(curPos);\n        curPos = ray * dist.w + curPos;\n\n        if(curPos.z < -10.0)\n            break;\n\n        if (dist.w < THRESHOLD )\n        {\n            normal = calcNormal(curPos);\n            fragColor = shading(curPos, ray, dist.xyz, SUN_DIR, normal);\n            break;\n        }\n    }\n\n    // color, hit pos, normal, material color\n    return mat4(vec4(fragColor, 0.0), vec4(curPos, 0.0), vec4(normal, 0.0), dist);\n}\n\n#define REFLECT_COUNT 4\nvoid mainImage( out vec4 outFragColor, in vec2 fragCoord )\n{\n    // eye in up look down\n    // vec3 eyePos = vec3(0.0, 3.0, -3.0);\n    // vec3 up = vec3(0.0, 0.0, -1.0);\n    // vec3 front = vec3(0.0, -1.0, 0.0);\n\n    // eye in back look front\n    vec3 eyePos = vec3(0.0, 3.0, 3.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 front = normalize(vec3(0.0, -1.0, -2.5));\n\n    vec3 right = normalize(cross(front, up));\n    up = normalize(cross(right, front));\n\n    vec3 ray = getRay(fragCoord.xy, eyePos, right, up, front, 1.5);\n    float rad = radians(mod(iTime * 50.0, 360.0));\n    vec3 SUN_DIR = normalize(vec3(sin(rad), 0.5, cos(rad)));\n\n    vec4 fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    vec3 normal;\n    vec3 pos = eyePos;\n\n    mat4 res = rayMarch(pos, ray, SUN_DIR);\n    fragColor.xyz = res[0].xyz;\n    for (int i = 0; i < REFLECT_COUNT; i++)\n    {\n        // calc reflect\n        // ray has endded don't reflect\n        if (res[0].xyz == vec3(0.0, 0.0, 0.0))\n        {\n            fragColor.xyz = mix(fragColor.xyz, res[0].xyz, 0.1);\n            break;\n        }\n\n        // floor don't relfect\n        if(res[3].xyz == vec3(0.7, 0.7, 0.7))\n            break;\n\n        ray = normalize(reflect(ray, res[2].xyz));\n        pos = res[1].xyz;\n        res = rayMarch(pos, ray, SUN_DIR);\n        fragColor.xyz = mix(fragColor.xyz, res[0].xyz, 0.2);\n    }\n\n    outFragColor = fragColor;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}