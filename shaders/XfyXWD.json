{
    "Shader": {
        "info": {
            "date": "1715160953",
            "description": "Minimalist assembly instructions for \"Wind Walker Mechanics\"",
            "flags": 0,
            "hasliked": 0,
            "id": "XfyXWD",
            "likes": 14,
            "name": "Windwalker Build",
            "published": 3,
            "tags": [
                "strandbeest",
                "instructions"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 180
        },
        "renderpass": [
            {
                "code": "// \"Windwalker Build\" by dr2 - 2024\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n  Minimalist assembly instructions for \"Wind Walker Mechanics\" (mlSfWR).\n  Mouse overrides autopaging, orientation (scene or book).\n  For monochrome images latest additions are shown in red.\n\n  No. 10 in \"Album\" series\n    \"Distance Field Guide\"       (WdcGWf)\n    \"Engine Album\"               (WsyGRK)\n    \"Chateaux..\"                 (Wtd3Df)\n    \"Live Assembly Instructions\" (WlcSD2)\n    \"Nautilus: The Book\"         (3lVSWw)\n    \"Book of Chopped Surfaces\"   (tdlcD7)\n    \"Sand Album\"                 (3slBRf)\n    \"Machinery Build\"            (NtVcWz)\n    \"Build the Palace\"           (7tKfRV)\n*/\n\n#define AA    0  // (= 0/1) optional antialiasing\n\n#define VAR_ZERO min (nFrame, 0)\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrCaps2Df (vec2 p, float r, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nmat3 StdVuMat (float el, float az);\nfloat ShowIntPZ (vec2 q, vec2 cBox, float mxChar, float val);\nfloat Fbm2 (vec2 p);\n\nvec3 ltDirEx, ltDir, pgSize;\nvec3 qHit, lBase;\nfloat dstFar, tCur, msAz, msEl, dstFarEx, tpBook, phsTurn, idPage, wlkSpd, wlkScl, vAxHt, chnEl;\nint nFrame, idObj, cState;\nbool isBw;\nconst int nPage = 14;\nconst int idBas = 1, idStruc = 2, idAx = 3, idWhl = 4, idLnkT = 5, idLnk = 6, idAxS = 7,\n   idSprk = 8, idPin = 9, idPlt = 10, idVane = 11;\nconst float s_a = 38.0, s_b = 41.5, s_c = 39.3, s_d = 40.1, s_e = 55.8, s_f = 39.4,\n   s_g = 36.7, s_h = 65.7, s_i = 49.0, s_j = 50.0, s_k = 61.9, s_l = 7.8, s_m = 15.0;\nconst float pi = 3.1415927;\n\n#define ACOSR(x, y, z) acos (((x) * (x) + (y) * (y) - (z) * (z)) / (2. * (x) * (y)))\n#define ATANV(v) atan ((v).y, (v).x)\n#define CosSin(x) (sin ((x) + vec2 (0.5 * pi, 0.)))\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nstruct Leg {\n  vec2 v[8], cs[10], cswAng;\n  float wAng;\n};\nstruct Walker {\n  Leg leg[2];\n  vec2 csVane;\n  float szFac;\n};\nWalker wlk;\n\nvoid ObjState ()\n{ //  (Leg from the Strandbeest: see https://en.wikipedia.org/wiki/Jansen's_linkage)\n  float a[10], aa, g, s, t;\n  wlk.szFac = wlkScl;\n  t = (tCur + 50.) * wlkScl / wlk.szFac;\n  wlk.leg[0].wAng = - wlkSpd * t;\n  wlk.leg[1].wAng = wlk.leg[0].wAng + pi;\n  for (int k = VAR_ZERO; k < 2; k ++) {\n    wlk.leg[k].v[0] = vec2 (0., 0.);\n    wlk.leg[k].v[1] = wlk.leg[k].v[0] + vec2 (s_a, s_l);\n    wlk.leg[k].v[2] = wlk.leg[k].v[1] + Rot2D (vec2 (s_m, 0.), wlk.leg[k].wAng);\n    aa = ATANV (wlk.leg[k].v[2] - wlk.leg[k].v[0]);\n    s = length (wlk.leg[k].v[2] - wlk.leg[k].v[0]);\n    a[0] = aa + ACOSR (s, s_b, s_j);\n    wlk.leg[k].v[3] = wlk.leg[k].v[0] + Rot2D (vec2 (s_b, 0.), a[0]);\n    a[1] = aa - ACOSR (s, s_c, s_k);\n    wlk.leg[k].v[4] = wlk.leg[k].v[0] + Rot2D (vec2 (s_c, 0.), a[1]);\n    a[2] = ACOSR (s_b, s_d, s_e) + a[0];\n    wlk.leg[k].v[5] = wlk.leg[k].v[0] + Rot2D (vec2 (s_d, 0.), a[2]);\n    s = length (wlk.leg[k].v[5] - wlk.leg[k].v[4]);\n    g = ACOSR (s, s_c, s_d) + ACOSR (s, s_g, s_f) + pi + a[1];\n    wlk.leg[k].v[6] = wlk.leg[k].v[4] + Rot2D (vec2 (s_g, 0.), g);\n    wlk.leg[k].v[7] = wlk.leg[k].v[4] + Rot2D (vec2 (s_i, 0.), g + ACOSR (s_g, s_i, s_h));\n    a[3] = ACOSR (s_d, s_e, s_b) + a[2] - pi;\n    a[4] = ATANV (wlk.leg[k].v[4] - wlk.leg[k].v[6]);\n    a[5] = ATANV (wlk.leg[k].v[5] - wlk.leg[k].v[6]);\n    a[6] = ATANV (wlk.leg[k].v[7] - wlk.leg[k].v[6]);\n    a[7] = ATANV (wlk.leg[k].v[7] - wlk.leg[k].v[4]);\n    a[8] = ATANV (wlk.leg[k].v[3] - wlk.leg[k].v[2]);\n    a[9] = ATANV (wlk.leg[k].v[4] - wlk.leg[k].v[2]);\n    for (int m = VAR_ZERO; m < 10; m ++) wlk.leg[k].cs[m] = CosSin (- a[m]);\n    wlk.leg[k].cswAng = CosSin (- wlk.leg[k].wAng);\n  }\n  wlk.csVane = CosSin ((wlkSpd != 0.) ? 4. * t : 0.);\n  chnEl = atan (vAxHt - s_l, - lBase.x);\n}\n\nvoid LinkDf (vec3 p, vec2 v, vec2 cs, float l, int id, inout float dMin)\n{\n  vec3 q;\n  float d;\n  q = p;\n  q.xy = Rot2Cs (q.xy - v, cs);\n  d = max (PrCaps2Df (q.yx - vec2 (0., 0.5 * l), 2., 0.5 * l), abs (q.z) - 0.5);\n  DMINQ (id);\n}\n\nfloat ChainDf (vec3 p, float aRot, float wgFac, float dMin)\n{\n  vec3 q, sp;\n  float d, wlRad, cRad, cLen, nTh, nSp, wlThk, lnkLen, lnkWid, lnkThk, wlGap, bx, by, ds, aa, rs;\n  wlRad = 1.;\n  cRad = 0.04;\n  nTh = 32.;\n  nSp = 6.;\n  wlThk = 0.05;\n  lnkLen = 2. * pi * wlRad / nTh;\n  lnkWid = 1.4 * cRad;\n  lnkThk = 0.15 * wlThk;\n  wlGap = wgFac * lnkLen;\n  cLen = 1.9 * wlThk;\n  sp.xz = sign (p.xz);\n  bx = wlGap - abs (p.x);\n  q = p;\n  q.xz = Rot2D (vec2 (abs (q.x) - wlGap, q.z), aRot * sp.x);\n  rs = length (q.xz);\n  aa = (rs > 0.) ? atan (q.z, - q.x) / (2. * pi) : 0.;\n  d = min (max (abs (rs - 0.96 * wlRad) - 0.09 * wlRad, abs (q.y) - wlThk),\n     max (rs - 0.25 * wlRad, abs (q.y) - 1.5 * wlThk));\n  d = min (d, max (PrBox2Df (vec2 (dot (q.xz, sin (2. * pi * floor (nSp * aa + 0.5) / nSp +\n     vec2 (0., 0.5 * pi))), q.y), vec2 (0.05, wlThk)), rs - wlRad));\n  q.xz = Rot2D (q.xz, 2. * pi * floor (nTh * aa + 0.5) / nTh);\n  d = SmoothMax (d, - PrCaps2Df (vec2 (q.z, q.x + wlRad + 0.1), 0.045, 0.08), 0.01);\n  DMIN (idSprk);\n  if (cState >= 9) {\n    q.x += wlRad;\n    d = max (PrCylDf (q.xzy, cRad, cLen), bx);\n    DMIN (idPin);\n    q = p;\n    q.xz -= vec2 (aRot * wlRad, wlRad) * sp.z;\n    q.x = mod (q.x + 0.5 * lnkLen, lnkLen) - 0.5 * lnkLen;\n    d = max (PrCylDf (q.xzy, cRad, cLen), - bx);\n    DMIN (idPin);\n    for (int k = VAR_ZERO; k < 2; k ++) {\n      by = (1.3 + 0.3 * float (k)) * wlThk;\n      ds = 0.5 + float (k);\n      q = p;\n      q.xz -= vec2 (aRot * wlRad + ds * lnkLen, wlRad) * sp.z;\n      q.x = mod (q.x + lnkLen, 2. * lnkLen) - lnkLen;\n      d = max (SmoothMax (PrCaps2Df (q.zx, lnkWid, 0.5 * lnkLen), abs (abs (q.y) - by) - lnkThk, 0.002), - bx);\n      DMIN (idPlt);\n      q = p;\n      q.x = abs (q.x) - wlGap;\n      q.xz = Rot2D (q.xz, (aRot + ds * 2. * pi / nTh) * sp.x);\n      q.xz = Rot2D (q.xz, 2. * pi * floor (0.5 * nTh * atan (q.z, - q.x) / (2. * pi) + 0.5) / (0.5 * nTh));\n      q.x += wlRad;\n      d = max (SmoothMax (PrCaps2Df (q.xz, lnkWid, 0.5 * lnkLen), abs (abs (q.y) - by) - lnkThk, 0.002), bx);\n      DMIN (idPlt);\n    }\n  }\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{ // (Based on \"Wind Walker\")\n  vec3 q, ps;\n  float dMin, d, sx, chnSzFac;\n  int kx, kz;\n  dMin = dstFar / wlk.szFac;\n  p /= wlk.szFac;\n  p.y -= lBase.y;\n  p.xz = Rot2Cs (p.xz, CosSin (0.25 * pi));\n  if (cState >= 1) {\n    q = p;\n    q.x -= 20.;\n    d = max (PrCaps2Df (vec2 (q.y, q.x - 5.), 2.5, lBase.x + 40.), abs (q.z) - lBase.z + 7.);\n    d = max (d, - PrBox2Df (vec2 (abs (q.x + 20. - s_a) - lBase.x, q.z), vec2 (17., 11.)));\n    d = max (d, 3. - length (vec2 (q.y + 5., abs (q.z) - 8.)));\n    DMINQ (idBas);\n  }\n  if (cState >= 2) {\n    q = p;\n    q.xy -= vec2 (s_a, s_l - 1.5);\n    d = max (PrCaps2Df (q.xy, 4.5, 2.), abs (q.z) - lBase.z + 7.);\n    DMIN (idStruc);\n    q.x = abs (q.x) - lBase.x;\n    d = max (PrCaps2Df (q.xy, 4.5, 2.), abs (abs (q.z) - 0.55 * lBase.z) - 0.25 * lBase.z);\n    DMIN (idStruc);\n    q = p;\n    q.z = abs (abs (q.z) - 27.5);\n    q -= vec3 (s_a, 32., 24.);\n    d = max (PrCaps2Df (q.xy, 4., 28.), abs (q.z) - 1.5);\n    DMIN (idStruc);\n  }\n  if (cState >= 3) {\n    q = p;\n    q.x = abs (q.x) - lBase.x;\n    d = PrCylDf (q, 1.5, lBase.z + 2.);\n    DMIN (idAx);\n    q = p;\n    q.xy -= vec2 (s_a, s_l);\n    q.x = abs (q.x) - lBase.x;\n    d = PrCylDf (q, 1.5, lBase.z - 2.);\n    DMIN (idAx);\n    q = p;\n    q.xy -= vec2 (s_a, vAxHt);\n    d = PrCylDf (q, 2.5, lBase.z - 5.);\n    DMIN (idAx);\n  }\n  for (int k = VAR_ZERO; k < 4; k ++) {\n    kx = k / 2;\n    kz = k - 2 * kx;\n    sx = sign (float (kx) - 0.5);\n    ps = p;\n    ps.z *= (sign (float (kz) - 0.5)) * sx;\n    ps.xz += vec2 (lBase.x * sx, lBase.z);\n    if (cState >= 4) {\n      q = ps;\n      q.z -= 4.;\n      q.xy = Rot2Cs (q.xy - wlk.leg[kz].v[1], wlk.leg[kz].cswAng);\n      d = PrCylAnDf (q, s_m, 2., 1.);\n      q.xy = (abs (q.x) > abs (q.y)) ? q.xy : q.yx;\n      d = min (d, max (PrBox2Df (q.xy, vec2 (s_m, 1.8)), abs (q.z) - 0.8));\n      DMIN (idWhl);\n    }\n    if (cState >= 5) {\n      LinkDf (ps, wlk.leg[kz].v[0], wlk.leg[kz].cs[0], s_b, idLnkT, dMin);\n      LinkDf (ps, wlk.leg[kz].v[0], wlk.leg[kz].cs[2], s_d, idLnkT, dMin);\n      LinkDf (ps, wlk.leg[kz].v[5], wlk.leg[kz].cs[3], s_e, idLnkT, dMin);\n      LinkDf (ps, wlk.leg[kz].v[6], wlk.leg[kz].cs[4], s_g, idLnkT, dMin);\n      LinkDf (ps, wlk.leg[kz].v[6], wlk.leg[kz].cs[6], s_h, idLnkT, dMin);\n      LinkDf (ps, wlk.leg[kz].v[4], wlk.leg[kz].cs[7], s_i, idLnkT, dMin);\n    }\n    ps.z -= 1.4;\n    if (cState >= 6) {\n      LinkDf (ps, wlk.leg[kz].v[0], wlk.leg[kz].cs[1], s_c, idLnk, dMin);\n      LinkDf (ps, wlk.leg[kz].v[6], wlk.leg[kz].cs[5], s_f, idLnk, dMin);\n      LinkDf (ps, wlk.leg[kz].v[2], wlk.leg[kz].cs[8], s_j, idLnk, dMin);\n    }\n    ps.z += 2.8;\n    if (cState >= 6) {\n      LinkDf (ps, wlk.leg[kz].v[2], wlk.leg[kz].cs[9], s_k, idLnk, dMin);\n    }\n    if (cState >= 7) {\n      for (int j = VAR_ZERO + 2; j <= 7; j ++) {\n        q = ps - vec3 (wlk.leg[kz].v[j], 0.2);\n        d = PrCylDf (q, ((j < 7) ? 1.5 : 2.5), ((j == 2) ? 5. : 3.));\n        DMIN (idAxS);\n      }\n    }\n  }\n  chnSzFac = 12.76;\n  if (cState >= 8) {\n    q = p;\n    q.z = abs (q.z);\n    q -= vec3 (s_a, s_l, 8.);\n    dMin = chnSzFac * ChainDf (vec3 (q.xy, - q.z).xzy / chnSzFac, - wlk.leg[0].wAng,\n       24., dMin / chnSzFac);\n    q = p;\n    q.xy -= vec2 (s_a - 0.5 * lBase.x, 0.5 * (vAxHt + s_l));\n    dMin = chnSzFac * ChainDf (vec3 (Rot2D (q.xy, chnEl), - q.z).xzy / chnSzFac,\n       - wlk.leg[0].wAng - chnEl, 16., dMin / chnSzFac);\n  }\n  if (cState >= 10) {\n    q = p;\n    q.xy = Rot2Cs (q.xy - vec2 (s_a, vAxHt), wlk.csVane);\n    d = max (abs (length (q.xy - vec2 (18., 10.)) - 20.) - 0.2, q.y);\n    q.xy = Rot2Cs (q.xy, CosSin (2. * pi / 3.));\n    d = min (d, max (abs (length (q.xy - vec2 (18., 10.)) - 20.) - 0.2, q.y));\n    q.xy = Rot2Cs (q.xy, CosSin (2. * pi / 3.));\n    d = min (d, max (abs (length (q.xy - vec2 (18., 10.)) - 20.) - 0.2, q.y));\n    q.z = abs (q.z) - 27.5;\n    d = max (d, abs (q.z) - 21.);\n    DMINQ (idVane);\n  }\n  return wlk.szFac * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = 1e-3 * vec2 (1., -1.);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 ObjCol ()\n{\n  vec4 col4;\n  if (idObj == idBas) {\n    col4 = vec4 (0.7, 0.8, 0.7, 0.05) * (0.9 +\n       0.1 * smoothstep (0.1, 0.13, fract (8. * abs (qHit.z) / 50. + 0.5)));\n  } else if (idObj == idStruc) {\n    col4 = vec4 (0.8, 0.9, 0.8, 0.05);\n  } else if (idObj == idAx) {\n    col4 = vec4 (0.8, 0.7, 0.2, 0.1);\n  } else if (idObj == idWhl) {\n    col4 = vec4 (0.8, 0.6, 0.1, 0.1);\n  } else if (idObj == idLnkT) {\n    col4 = vec4 (0.85, 0.85, 0.9, 0.1) * (0.8 + 0.2 * smoothstep (0.18, 0.22, abs (qHit.y)));\n  } else if (idObj == idLnk) {\n    col4 = vec4 (0.95, 0.95, 1., 0.1) * (0.8 + 0.2 * smoothstep (0.18, 0.22,\n       abs (abs (qHit.y) - 0.8)));\n  } else if (idObj == idAxS) {\n    col4 = vec4 (0.8, 0.7, 0.2, 0.1);\n  } else if (idObj == idSprk) {\n    col4 = vec4 (0.8, 0.6, 0.1, 0.1);\n  } else if (idObj == idPin) {\n    col4 = vec4 (0.65, 0.7, 0.8, 0.1);\n  } else if (idObj == idPlt) {\n    col4 = vec4 (0.8, 0.8, 0.9, 0.1);\n  } else if (idObj == idVane) {\n    col4 = vec4 (0.4, 0.8, 0.9, 0.) * (0.3 + 0.7 * smoothstep (0.25, 0.3, abs (abs (qHit.z) - 12.)));\n  }\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 vn, col;\n  float dstObj;\n  bool isNu;\n  isBw = (cState <= 12);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = ObjCol ();\n    if (isBw) {\n      isNu = false;\n      if (cState <= 5) {\n        if      (cState == 1) isNu = (idObj == idBas);\n        else if (cState == 2) isNu = (idObj == idStruc);\n        else if (cState == 3) isNu = (idObj == idAx);\n        else if (cState == 4) isNu = (idObj == idWhl);\n        else if (cState == 5) isNu = (idObj == idLnkT);\n      } else {\n        if      (cState == 6) isNu = (idObj == idLnk);\n        else if (cState == 7) isNu = (idObj == idAxS);\n        else if (cState == 8) isNu = (idObj == idSprk);\n        else if (cState == 9) isNu = (idObj == idPin || idObj == idPlt);\n        else if (cState == 10) isNu = (idObj == idVane);\n      }\n      col = vec3 (1., 0.98, 0.96) * pow (Maxv3 (col4.rgb), 0.8);\n      if (isNu) col.gb *= 0.3;\n      col *= 0.4 + 0.6 * max (dot (vn, ltDir), 0.);\n    } else {\n      col = col4.rgb * (0.2 + 0.2 * max (- dot (vn, ltDir), 0.) + 0.8 * max (dot (vn, ltDir), 0.)) +\n         col4.a * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n    }\n  } else col = isBw ? vec3 (0.8) : vec3 (0.1, 0.1, 0.15);\n  return clamp (col, 0., 1.);\n}\n\nvoid ExMain  (out vec3 fCol, in vec2 fCoord)\n{\n  mat3 vuMat;\n  vec3 ro, rd;\n  float el, az, zmFac;\n  if (idPage > 0.) cState = int (idPage);\n  else cState = 11;\n  wlkScl = 0.03;\n  lBase = vec3 (60., 86., 60.);\n  vAxHt = 60.;\n  wlkSpd = (cState >= 12 || idPage == 0.) ? 1.5 : 0.;\n  ObjState ();\n  az = 0.1 * pi;\n  el = -0.1 * pi;\n  if (idPage > 0.) {\n    az += (msAz > -999.) ? msAz : 0.;\n    el += (msEl > -999.) ? msEl : 0.;\n  }\n  if (idPage == 11.) az += 0.05 * tCur;\n  el = clamp (el, -0.3 * pi, -0.01 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vec3 (0., 2.2, -25.);\n  ro = vuMat * ro;\n  zmFac = 5.5;\n  dstFar = 100.;\n  rd = vuMat * normalize (vec3 (fCoord, zmFac));\n  ltDir = vuMat * normalize (vec3 (-1., 1., -1.));\n  fCol = ShowScene (ro, rd);\n}\n\nfloat ExObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, rRad, hRad, hOff, np, bc, thFac, nRing, y, w;\n  dMin = dstFarEx;\n  rRad = 0.45;\n  hRad = 0.1;\n  nRing = 4.;\n  hOff = 0.15;\n  thFac = 2.2;\n  np = float (nPage - 1);\n  q = p;\n  w = pgSize.z / nRing;\n  bc = mod (q.z + mod (nRing, 2.) * w, 2. * w) - w;\n  for (int k = VAR_ZERO; k < nPage; k ++) {\n    q = p;\n    q.y -= 0.5 * np * thFac * pgSize.y;\n    y = q.y + np * thFac * pgSize.y * phsTurn;\n    if (k == 0) q.xy = Rot2D (vec2 (q.x, y), -2. * pi * phsTurn);\n    else q.y -= thFac * pgSize.y * (phsTurn - float (k));\n    d = hRad - length (vec2 (q.x - rRad, bc));\n    q.x -= pgSize.x - hOff + rRad;\n    d = max (PrRoundBoxDf (q, pgSize - pgSize.y, pgSize.y), d);\n    DMINQ (k + 1);\n  }\n  q = p;\n  d = abs (q.z) - pgSize.z;\n  q.z = bc;\n  d = max (PrTorusDf (q, 0.5 * hRad, rRad + 0.3 * hRad), d);\n  DMINQ (nPage + 1);\n  return dMin;\n}\n\nfloat ExObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ExObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFarEx) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ExObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = 1e-3 * vec2 (1., -1.);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ExObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ExShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, c, vn;\n  vec2 s, w, wo, w1, w2;\n  float dstObj, npCyc, tpCyc, tpWait, nDotL, t, ss, d;\n  bool isImg;\n  pgSize = vec3 (2.7, 0.011, 2.);\n  tpCyc = 3.;\n  tpWait = 4.;\n  t = (tpBook < 0.) ? (- tpBook * float (nPage - 1) * (tpCyc + tpWait)) :\n     mod (tpBook - tpWait, float (nPage) * (tpCyc + tpWait));\n  npCyc = mod (floor (t / (tpCyc + tpWait)), float (nPage));\n  phsTurn = min (fract (t / (tpCyc + tpWait)) * (tpCyc + tpWait) / tpCyc, 1.);\n  isImg = false;\n  dstObj = ExObjRay (ro, rd);\n  if (dstObj < dstFarEx) {\n    ro += dstObj * rd;\n    vn = ExObjNf (ro);\n    nDotL = max (dot (vn, ltDirEx), 0.);\n    if (idObj <= nPage) {\n      idPage = mod ((float (idObj - 1) + npCyc), float (nPage));\n      c = vec3 (0.8, 0.8, 0.85) * (0.85 + 0.15 * Fbm2 (8. * qHit.xz));\n      col4 = vec4 (c, 0.2);\n      col = vec3 (0.8);\n      s = pgSize.xz - abs (qHit.xz);\n      if (qHit.y > 0.) {\n        w = qHit.xz / pgSize.z;\n        wo = w;\n        ss = Minv2 (s);\n        if (ss > 0.3) {\n          isImg = true;\n          if (idPage == 0.) {\n            w1 = w + vec2 (0.5, 0.2);\n            w2 = w - vec2 (0.5, 0.2);\n            w = mix (w1 * vec2 (-1., 1.), w2, step (length (w2), length (w1)));\n            d = length (w) - 0.5;\n            w = mix (2. * w, w, step (0., d));\n          } else if (idPage == 9.) {\n            d = length (w + vec2 (0.3, 0.)) - 0.8;\n            w = mix (0.7 * (w + vec2 (0.3, 0.) + vec2 (0.35, 0.1)), w, step (0., d));\n          } else if (idPage == 7.) {\n            d = length (w + vec2 (-0.45, 0.1)) - 0.7;\n            w = mix (0.7 * (w + vec2 (-0.45, 0.1) + vec2 (0.3, -0.37)), w, step (0., d));\n          }\n          if (idPage > 0. || idPage == 0. && d < 0.) ExMain (col, w);\n          if (idPage == 0. || idPage == 7. || idPage == 9.) col = mix (vec3 (0.3, 0.3, 0.4), col,\n             smoothstep (0., 0.003, abs (d) - 0.004));\n          if (idPage > 0.) {\n            col = mix (col, 1. - col, ShowIntPZ (wo - vec2 (1.15, -0.8),\n               vec2 (0.1, 0.06), 2., float (idPage)));\n          } else if (fract (tCur) < 0.9) {\n            w = wo - vec2 (0.9, -0.7);\n            d = min (length (max (abs (w) - vec2 (0.1, 0.002), 0.)),\n               length (max (abs (Rot2D (vec2 (w.x - 0.1, abs (w.y)), 0.2 * pi)) -\n               vec2 (0.1, 0.002), 0.)));\n            col = mix (vec3 (0.3, 0.9, 0.3), col, smoothstep (0., 0.01, length (d)));\n          }\n        } else if (ss > 0.27) {\n          col4 = vec4 (0.6 * c, 0.2);\n        }\n      }\n    } else if (idObj == nPage + 1) {\n      col4 = vec4 (0.95, 0.95, 0.8, 0.2);\n      nDotL *= nDotL;\n    }\n    if (! isImg) col = col4.rgb * (0.2 + 0.8 * nDotL) +\n       col4.a * pow (max (0., dot (ltDirEx, reflect (rd, vn))), 32.);\n  } else {\n    col = vec3 (1., 1., 0.9) * (0.5 + 0.2 * rd.y);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tpBook = max (1.3 * tCur - 0.3, 0.);\n  az = 0.;\n  el = -0.5 * pi;\n  msAz = -999.;\n  msEl = -999.;\n  if (mPtr.z > 0.) {\n    if (abs (mPtr.y) > 0.42) {\n      tpBook = - clamp (1.05 * mPtr.x + 0.45, 0., 1.);\n    } else if (abs (mPtr.x - 0.04) > 0.42) {\n      el += pi * mPtr.y * smoothstep (0.1, 0.15, abs (mPtr.y));\n    } else if (abs (mPtr.x - 0.04) < 0.33 && abs (mPtr.y) < 0.42) {\n      msAz = pi * clamp (3. * (mPtr.x - 0.04), -1., 1.);\n      msEl = pi * mPtr.y;\n    }\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vec3 (2.7, 0., -20.);\n  zmFac = 9.;\n  dstFarEx = 40.;\n  ltDirEx = normalize (vec3 (1.));\n  ro = vuMat * ro;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif\n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ExShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat PrCaps2Df (vec2 p, float r, float h)\n{\n  return length (p - vec2 (0., clamp (p.y, - h, h))) - r;\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat DigSeg (vec2 q)\n{\n  return (1. - smoothstep (0.13, 0.17, abs (q.x))) *\n     (1. - smoothstep (0.5, 0.57, abs (q.y)));\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  float d;\n  int k, kk;\n  const vec2 vp = vec2 (0.5, 0.5), vm = vec2 (-0.5, 0.5), vo = vec2 (1., 0.);\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.8, 2.3);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowIntPZ (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (min (q.x, q.y) >= 0. && max (q.x, q.y) < 1.) {\n    q.x *= mxChar;\n    nDig = mxChar;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    val = max (val, 0.);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}