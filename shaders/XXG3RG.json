{
    "Shader": {
        "info": {
            "date": "1717767944",
            "description": "Probably my most visually appealing shader to date.\nRuns at a consistent 144 frames per second on PC with RTX 4060.\nA couple utilities borrowed from @Poisson (https://www.shadertoy.com/user/Poisson)",
            "flags": 32,
            "hasliked": 0,
            "id": "XXG3RG",
            "likes": 24,
            "name": "Montecarlo Raytracing V2.0",
            "published": 3,
            "tags": [
                "3d",
                "raytracing",
                "raytrace",
                "pathtrace",
                "reflect",
                "refract",
                "pbr"
            ],
            "usePreview": 1,
            "username": "FifthStateOfMatter",
            "viewed": 404
        },
        "renderpass": [
            {
                "code": "vec3 ACES(vec3 x) {\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.1;\n    float d = 0.7;\n    float e = 0.12;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    // Concise recursion system borrowed from Poisson (starts in main in buffer A)\n    vec4 col = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    col.rgb /= col.a;\n    col.rgb = ACES(col.rgb);\n    fragColor = vec4(pow(col.rgb, vec3(1.0/2.2)), 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "struct material {\n    vec3 col;\n    float emission;\n    float smoothness;\n    float specularProb;\n    float refractIndex;\n    float opacity;\n};\n\n// Poisson's hash (https://www.shadertoy.com/view/dssXRj)\nfloat seed;\nvec2 hash22(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nfloat hash1() {\n    return fract(sin(seed += 0.1) * 4568.7564);\n}\n\nvec2 hash2() {\n    return vec2(hash1(), hash1());\n}\n\nvec3 hash3() {\n    return vec3(hash1(), hash1(), hash1());\n}\n\nvec2 randomDir2D() {\n    vec2 curr;\n    while(true) {\n        curr = hash2() * 2.0 - 1.0;\n        if(length(curr) < 1.0){\n            return curr;\n        }\n    }\n}\n\nvec3 randomDir() {\n    vec3 d;\n    while(true) {\n        d = hash3() * 2.0 - 1.0;\n        if(length(d) <= 1.0) return normalize(d);\n    }\n}\n\nvec3 rotate2D(vec3 p, vec2 t){\n    float stx = sin(t.x);\n    float ctx = cos(t.x);\n    float sty = sin(t.y);\n    float cty = cos(t.y);\n    mat3 xRotation;\n    xRotation[0] = vec3(1, 0, 0);\n    xRotation[1] = vec3(0, ctx, -stx);\n    xRotation[2] = vec3(0, stx, ctx);\n    \n    mat3 yRotation;\n    yRotation[0] = vec3(cty, 0, -sty);\n    yRotation[1] = vec3(0, 1, 0);\n    yRotation[2] = vec3(sty, 0, cty);\n    return p*xRotation*yRotation;\n}\n\nvoid raytraceSphere(vec3 o, vec3 d, inout bool h, vec4 s, inout float t, inout vec3 n, in material inMat, inout material outMat) {\n    vec3 oc = o - s.xyz;\n    float a = dot(d, d);\n    float b = 2.0 * dot(oc, d);\n    float c = dot(oc, oc) - s.w * s.w;\n    float disc = b * b - 4.0 * a * c;\n    float currT = (-b - sqrt(disc))/(2.0 * a);\n    if (disc > 0.0 && currT >= 0.0 && currT < t) {\n        t = currT;\n        h = true;\n        n = normalize((o + d * t) - s.xyz);\n        outMat = inMat;\n    }\n}\n\nfloat raytraceScene(vec3 o, vec3 d, out bool h, out vec3 n, out material mat) {\n    h = false;\n    n = vec3(0);\n    float t = 1000000.0;\n    //raytraceSphere(o, d, h, vec4(1, -0.25, 0, 0.25), t, n, material(vec3(0, 0, 1), 0.5, 1.0, 1.0, 1.52, 10.0), mat);\n    //raytraceSphere(o, d, h, vec4(0, 0, 0, 0.5), t, n, material(vec3(0, 1, 0), 0.5, 0.6, 1.0, 1.52, 10.0), mat);\n    //raytraceSphere(o, d, h, vec4(-1, -0.175, 0, 0.325), t, n, material(vec3(1, 0, 0), 0.5, 1.0, 1.0, 1.52, 10.0), mat);\n    raytraceSphere(o, d, h, vec4(0, -10000.25, 0, 10000), t, n, material(vec3(1), 0.5, 1.0, 0.1, 0.0, 0.0), mat);\n    \n    for (int i = -2; i <= 2; ++i) {\n        raytraceSphere(o, d, h, vec4(-2, 0, i, 0.25), t, n, material(vec3(0.2, float(i + 2) / 4.0, 0.5), 0.5, 0.0, 0.0, 0.0, 0.0), mat);\n        raytraceSphere(o, d, h, vec4(-1, 0, i, 0.25), t, n, material(vec3(0.4, float(i + 2) / 4.0, 0.5), 0.5, 0.8, 0.05, 0.0, 0.0), mat);\n        raytraceSphere(o, d, h, vec4(0, 0, i, 0.25), t, n, material(vec3(0.6, float(i + 2) / 4.0, 0.5), 0.5, 1.0, 0.02, 0.0, 0.0), mat);\n        raytraceSphere(o, d, h, vec4(1, 0, i, 0.25), t, n, material(vec3(0.8, float(i + 2) / 4.0, 0.5), 0.5, 1.0, 0.5, 0.0, 0.0), mat);\n        raytraceSphere(o, d, h, vec4(2, 0, i, 0.25), t, n, material(vec3(1, float(i + 2) / 4.0, 0.5), 0.5, 1.0, 1.0, 1.52, 10.0), mat);\n    }\n    \n    return t;\n}\n\n// Raytracing in One Weekend (https://raytracing.github.io/books/RayTracingInOneWeekend.html)\nfloat schlick(float cosTheta, float refractRatio) {\n    float r = (1.0 - refractRatio) / (1.0 + refractRatio);\n    r = r * r;\n    return r + (1.0 - r) * pow((1.0 - cosTheta), 5.0);\n}\n\nvec3 pathtrace(vec3 o, vec3 d) {\n    vec3 col = vec3(1);\n    float t;\n    vec3 n;\n    material mat;\n    bool h = false;\n    \n    for (int i = 0; i < 12; ++i) {\n        h = false;\n        t = raytraceScene(o, d, h, n, mat);\n        if (!h) {\n            col *= pow(textureLod(iChannel1, o + d * 1600.0 + vec3(0, -50, 0), 0.0).rgb, vec3(4)) * 8.0;\n            break;\n        } else {\n            float isSpecular = mat.specularProb > hash1() ? 1.0 : 0.0;\n            \n            vec3 diffuseD = normalize(randomDir() + n);\n            vec3 reflectD = normalize(reflect(d, n));\n            \n            float cosTheta = min(dot(-d, n), 1.0);\n            float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n            float refractRatio = dot(d, n) >= 0.0 ? mat.refractIndex : 1.0 / mat.refractIndex;\n            \n            o = o + d * t + n * sign(dot(d, n)) * 0.01;\n            \n            if (mat.refractIndex > 1.0 && schlick(cosTheta, refractRatio) <= hash1() && refractRatio * sinTheta <= 1.0) {\n                float inside = sign(dot(d, n));\n                d = mix(randomDir(), refract(d, -n * inside, refractRatio), mat.smoothness * isSpecular);\n                if (inside < 0.0) {\n                    col *= mat.col * mat.emission;\n                }\n            } else {\n                d = mix(diffuseD, reflectD, mat.smoothness * isSpecular);\n\n                col *= mix(mat.col * mat.emission, vec3(1), isSpecular);\n            }\n        }\n        if (mat.emission > 1.0) break;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    seed = iTime + dot(sin(fragCoord), vec2(443.712, 983.234));\n    seed += hash1() * 434.251;\n    \n    vec2 uv = ((fragCoord + hash2() - 0.5) - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 o = rotate2D(vec3(0, 0, -7), vec2(radians(20.0), radians(40.0)));\n    vec3 d = rotate2D(normalize(vec3(uv, 1.75)), vec2(radians(20.0), radians(40.0)));\n    vec3 focalPoint = o + d * 7.0;\n    \n    o += rotate2D(vec3(randomDir2D(), 0), vec2(radians(20.0), radians(40.0))) * 0.1;\n    vec3 shiftedDir = normalize(focalPoint - o);\n    \n    vec3 col = pathtrace(o, shiftedDir);\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if(iMouse.z > 0.0){\n        data *= 0.0;\n    }\n    data += vec4(col, 1);\n    \n    fragColor = data;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}