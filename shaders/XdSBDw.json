{
    "Shader": {
        "info": {
            "date": "1500991056",
            "description": "Adventure!! :)\nIt's really fun to paint the cheap blood all over the place.",
            "flags": 32,
            "hasliked": 0,
            "id": "XdSBDw",
            "likes": 48,
            "name": "[SH17B]Back To School",
            "published": 3,
            "tags": [
                "tunnel",
                "blood",
                "room",
                "corridor"
            ],
            "usePreview": 1,
            "username": "EvilRyu",
            "viewed": 2517
        },
        "renderpass": [
            {
                "code": "//post\n\nvec3 tonemap(vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord / iResolution.xy;\n    \n    vec3 col = texture(iChannel0, q).xyz;\n   \n    col=tonemap(col);\n    col = pow(col, vec3(0.45));    \n    col = clamp(col*0.5+0.5*col*col*1.3,0.0,1.0);\n    col=pow(col,vec3(1.1,1.,1.0));\n    col*=pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1);\n   \n    fragColor.xyz = col.xyz;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by EvilRyu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// In a corridor of 30m long.\n// This is a prelude for an adventure when you find something happened after your summer holiday.\n\n#define PI 3.1415926535898\n\nfloat box(vec3 p, vec3 b)\n{\n  \tvec3 d = abs(p) - b;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat infi_box(vec3 p, vec2 b)\n{\n    vec2 d = abs(p.xy) - b;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat triprism(vec3 p, vec2 h)\n{\n    vec3 q = abs(p);\n    return max(q.z - h.y, max(q.x * 0.866025 + p.y * 0.5, -p.y) - h.x * 0.5);\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat cylinder(vec3 p, vec2 h)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat segment(vec3 p,  vec3 a, vec3 b, float r1, float r2)\n{\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r1 + r2*h;\n}\n\n\nfloat rbox(vec3 p, vec3 b, float r)\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n\nfloat pillars(vec3 p)\n{\n    p.z = mod(p.z, 10.) - 5.;\n    float d0 = box(vec3(abs(p.x) - 2.7,\n                       p.y+1., p.z),\n                  vec3(0.5, 6.5, .15));\n    float d1 = box(vec3(abs(p.x) - 2.7,\n                       p.y-1.4, p.z),\n                  vec3(0.55, 0.06, .25));\n    \n    return min(d0,d1);\n}\n\nfloat fire_ext(vec3 p)\n{\n    p.z = mod(p.z + 15., 24.)-12.;\n    p.y -= 0.5;\n    float xoffset = -2.88;\n    float d0 = cylinder(p+vec3(xoffset,1.,0.), vec2(0.13,.3));\n    float d1 = cylinder(p+vec3(xoffset,.65,0.), vec2(0.07, 0.1));\n    float d2 = box(p+vec3(xoffset+0.05,0.55,0.), vec3(0.1,0.01,0.1));\n    float d = d0;\n    d = smin(d, d1, .1);\n    d = min(d, d2);\n    return d;\n}\n\n#define CLOCK_RADIUS 0.25\n#define CLOCK_OFFSET vec3(2.6, 1., 0.)\nfloat clock(vec3 p)\n{\n    p.z = mod(p.z + 16., 20.)-10.;\n    p-=CLOCK_OFFSET;\n    p.yz=p.zy;\n    float d0 = cylinder(p, vec2(CLOCK_RADIUS,.02));\n    float d1 = box(p-vec3(0.5, 0.0, 0.0), vec3(0.2, 0.02, 0.1));\n    \n    return min(d0, d1);\n}\n\nfloat doors(vec3 p)\n{\n    p.z = mod(p.z + 11., 10.) - 5.;\n    p.x = abs(p.x) - 3.;\n    float d0 = box(p+vec3(0.,1.2,0.), vec3(0.15, 1.6, 0.4));\n    //float d1 = box(p+vec3(0.,1.2,0.), vec3(0.2, 1., 0.2));\n    return d0;\n}\n\nfloat shelf(vec3 p)\n{\n    p.x+=2.2;\n    p.z = mod(p.z+8., 12.) - 6.;\n\n    float d0 = box(vec3(abs(p.x)-0.5, p.y+2.5, abs(p.z)-0.75), \n                   vec3(0.015, 1.3, 0.015));\n    float d1 = 100.;\n    if(p.y>=-2.7&&p.y<=-1.)\n    \td1 = box(vec3(p.x,mod(p.y+2.2,.6)-.3,p.z), \n                   vec3(0.51,0.01,0.75));\n    return min(d0, d1);\n}\n\nvec2 rotate2(vec2 p, float a)\n{\n\tfloat si = sin(a);\n\tfloat co = cos(a);\n\treturn mat2(co, si, -si, co) * p;\n}\n\nvoid ry(inout vec3 p, float a){  \n \tfloat c,s;vec3 q=p;  \n  \tc = cos(a); s = sin(a);  \n  \tp.x = c * q.x + s * q.z;  \n  \tp.z = -s * q.x + c * q.z; \n} \n\nfloat student_sit(vec3 p)\n{\n    p.x -= 2.9;\n    p.y += 1.7;\n    p.z += -1.4;\n    p.z=mod(p.z, 16.)-8.;\n    p.xz=p.zx;\n\n    vec2 q = rotate2(p.xy, -0.8);\n    float head = sphere(vec3(q.x+0.2, (q.y-0.04)*0.8,p.z+0.2), 0.13);\n    float neck = cylinder(vec3(q.x+0.25, q.y+0.2, p.z), vec2(0.04,0.1));\n    float body = rbox(vec3(p.x, p.y+0.8, p.z), \n                      vec3(0.19, 0.4, 0.09), 0.03);\n    \n    float legs = segment(vec3(abs(p.x)-0.15, p.y+1.2,p.z),\n                         vec3(0.0, 0.0, 0.),\n                         vec3(0.0, 0.,-1.4),\n                         0.1, 0.05);\n    \n    float arms = segment(vec3(abs(p.x)-0.32, p.y+.45,p.z),\n                         vec3(-0.06, 0.0, -0.),\n                         vec3(0.05, -0.9,-0.2),\n                         0.055, 0.01);\n    \n    float feet = segment(vec3(abs(p.x)-0.15, p.y+1.2, p.z),\n                         vec3(0.00, 0., -1.4),\n                         vec3(0.03, 0.2, -1.41),\n                         0.05,0.0);\n    float d = head;\n    float mid = 8.;\n    \n    d = min(d, body);\n    d = smin(d, neck, 0.2);\n    d = smin(d, legs, 0.15);\n    d = smin(d, arms, 0.04);\n    d = smin(d, feet, 0.1);\n    return d;\n}\n\nvec2 students(vec3 p)\n{\n    vec3 pos = p;\n    p.x += 1.0;\n    p.y -= 1.0;\n    p.z += 4.;\n    vec2 q = rotate2(p.xy, -0.8);\n    float head = sphere(vec3(q.x+0.2, (q.y-0.04)*0.8,p.z), 0.13);\n    float neck = cylinder(vec3(q.x+0.25, q.y+0.2, p.z), vec2(0.03,0.1));\n    float body = rbox(vec3(p.x, p.y+0.8, p.z), \n                      vec3(0.19, 0.4, 0.1), 0.03);\n    \n    float legs = segment(vec3(abs(p.x)-0.15, p.y+1.,p.z),\n                         vec3(0.0, 0.0, 0.),\n                         vec3(0.0, -1.4,0.),\n                         0.1, 0.05);\n    \n    float arms = segment(vec3(abs(p.x)-0.32, p.y+.45,p.z),\n                         vec3(-0.06, 0.0, -0.1),\n                         vec3(0.05, -0.93,-0.1),\n                         0.055, 0.01);\n    \n    float feet = segment(vec3(abs(p.x)-0.15, p.y+1., p.z),\n                         vec3(0.0, -1.4, 0.),\n                         vec3(0.06, -1.43, -0.2),\n                         0.05,0.0);\n \n    float rope = cylinder(vec3(p.z, p.y-1.4, p.x), vec2(0.001, 2.));\n    float rope1 = cylinder(vec3(p.z,p.y+0.3,p.x+0.1), vec2(0.1,0.01));\n            \n   \tfloat classmates = student_sit(pos);\n    float d = head;\n    float mid = 8.;\n    \n    d = min(d,body);\n    d = smin(d, neck, 0.1);\n    d = smin(d, legs, 0.15);\n    d = smin(d, arms, 0.04);\n    d = smin(d, feet, 0.1);\n    d = min(d, classmates);\n    if(d > rope){d = rope; mid = 6.;}\n    if(d > rope1){d = rope1; mid = 6.;}\n    \n    \n    return vec2(d,mid);\n}\n\nvec2 desk(vec3 p)\n{\n    p.xz = rotate2(p.xz, 0.6);\n\n    p.z += 4.3;\n    p.x -= 1.7;\n       \n    float d0 = box(vec3(abs(p.x)-0.1, p.y+2.3, abs(p.z)-0.65), \n                   vec3(0.01, 0.6, 0.01));\n    float d1 = box(vec3(p.x-0.1, p.y+1.7, p.z),\n                   vec3(0.6, 0.01, 0.7));\n    float d2 = box(vec3(p.x-0.1, p.y+2.9, abs(p.z)-0.65),\n                   vec3(0.4, 0.01, 0.01));\n    float d3 = box(vec3(p.x-0.2, p.y+1.9, p.z),\n                   vec3(0.45, 0.01, 0.7));\n\tvec2 res = vec2(d0, 7.);\n    if(res.x > d1){res=vec2(d1, 6.);}\n    if(res.x > d2){res=vec2(d2, 7.);}\n    if(res.x > d3){res=vec2(d3, 6.);}\n\n    return res;\n}\n\nvec3 map(vec3 p)\n{\n    float mid = 0.;\n    float d0 = 3.0 - max(abs(p.x), abs(p.y));\n    float d1 =30. - p.z;\n    \n    float d2 = infi_box(vec3(abs(p.x) - 2.94,\n                             p.y - 1.4,\n                             p.z),\n                        vec2(0.05, 0.06));\n    float d3 = infi_box(vec3(abs(p.x) - 3.,\n                             p.y + 2.8,\n                             p.z),\n                        vec2(0.03, 0.06));\n    \n    float d4 = box(vec3(p.x, p.y, p.z) - vec3(0., 3., floor((p.z+5.)/10.)*10.), \n                   vec3(0.8, 0.25, 1.0));\n    \n    float d5 = infi_box(vec3(mod(p.x, 1.8)-0.9, p.y-3., p.z), \n                        vec2(0.02,0.04));\n    \n    float d6 = infi_box(vec3(mod(p.z, 2.)-1., p.y-3., p.x), \n                        vec2(0.02,0.04));\n    \n    float d7 = pillars(p);\n    \n    float d8 = fire_ext(p);\n    \n    float d9 = clock(p);\n    \n    float d10 = doors(p);\n    \n    float d11 = shelf(p);\n    \n    vec2 d12 = students(p);\n    \n    vec2 d13 = desk(p);\n\t\n    float d14 = box(p + vec3(1.7,-3.,4.0), vec3(0.8,.25,1.));\n\n    float d = 1e10;\n    if(d > d0){d = d0; mid = d0==3.0-abs(p.y)&&p.y<0.?3.0 : 0.;}\n    if(d > d1){d = d1; mid = 0.;}\n    if(d > d2){d = d2; mid = 0.;}\n    if(d > d3){d = d3; mid = 1.;}\n    if(d < -d4){d = -d4; mid = 2.;}\n    if(d > d5){d = d5; mid = 0.;}\n    if(d > d6){d = d6; mid = 0.;}\n    if(d > d7){d = d7; mid = 0.;}\n    if(d > d8){d = d8; mid = 4.;}\n    if(d > d9){d = d9; mid = 5.;}\n    if(d < -d10){d = -d10; mid = 6.;}\n    if(d > d11){d = d11; mid = 7.0;}    \n    if(d > d13.x){d = d13.x; mid = d13.y;}\n    if(d < -d14){d = -d14; mid = 9.;}\n    if(d > d12.x){d = d12.x; mid = d12.y;}\n\n    return vec3(d, mid, 0.);\n}\n\nvec3 get_normal(vec3 p) {\n    const vec2 e = vec2(0.002, 0);\n    return normalize(vec3(map(p + e.xyy).x-map(p - e.xyy).x, \n                          map(p + e.yxy).x-map(p - e.yxy).x,    \n                          map(p + e.yyx).x-map(p - e.yyx).x));\n}\n\nvec3 intersect(vec3 ro, vec3 rd)\n{\n    vec3 res;\n    float t = 0.01;\n    for(int i = 0; i < 124; ++i)\n    {\n        vec3 p = ro + rd * t;\n        res = map(p);\n        if(res.x < 0.005 * t || res.x > 20.)\n            break;\n        t += res.x;\n    }\n    \n    if(res.x > 20.) t = -1.;\n    return vec3(t, res.y, res.z);\n}\n\nvec4 texcube(sampler2D sam, vec3 p, vec3 n)\n{\n    vec4 p1=texture(sam, p.xy);\n    vec4 p2=texture(sam, p.xz);\n    vec4 p3=texture(sam, p.yz);\n    return p1*abs(n.z)+p2*abs(n.y)+p3*abs(n.x);\n}\n\nfloat bump(vec3 p, vec3 n)\n{\n    return dot(texcube(iChannel0, 0.25*p, n).xyz, vec3(0.299, 0.587, 0.114)); \n}\n\nvec3 bump_mapping(vec3 p, vec3 n, float weight)\n{\n    vec2 e = vec2(2./iResolution.y, 0); \n    vec3 g=vec3(bump(p-e.xyy, n)-bump(p+e.xyy, n),\n                bump(p-e.yxy, n)-bump(p+e.yxy, n),\n                bump(p-e.yyx, n)-bump(p+e.yyx, n))/(e.x*2.);  \n    g=(g-n*dot(g,n));\n    return normalize(n+g*weight);\n}\n\nfloat get_ao(vec3 p, vec3 n)\n{\n    float r = 0.0, w = 1.0, d;\n    for(float i=1.; i<5.0+1.1; i++)\n    {\n        d = i/5.0;\n        r += w*(d - map(p + n*d).x);\n        w *= 0.5;\n    }\n    return 1.0-clamp(r,0.0,1.0);\n}\n\nfloat direct_light(vec3 p, vec3 lpos, vec3 n, float radius)\n{\n    vec3 ldir = (lpos - p);\n    float r = length(ldir);\n    ldir /= r;\n    float res = 1.;\n    res *= max(0., dot(ldir,  n))/r;\n    return (3.4-p.y)/3.4*res * (1. - smoothstep(0., radius, r));\n}\n\n\nfloat refl;\n\nvec3 lighting(vec3 ro, vec3 rd, vec3 p, vec3 n, float mid, float dist)\n{\n    vec3 l0_pos = vec3(0., 2.4, floor((p.z+5.)/10.)*10.);\n    vec3 l0_dir = normalize(l0_pos - p);\n    vec3 l0_col = vec3(1.);\n    \n    vec3 mc = vec3(1., 1.02, 0.92);\n\n    refl = 0.; \n    \n    \n    if(mid > 8.)\n    {\n        mc = vec3(0.2);\n    }\n    else if(mid > 7.)\n    {\n        mc = vec3(.996, .945, .882)*.2;\n    }\n    else if(mid > 6.)\n    {\n        mc = vec3(1.,1.,1.1)*1.1;\n        mc.yz -= pow(texcube(iChannel3, p.yxz*.8, n).x,3.5)*3.5;\n        mc = max(vec3(0.),mc);\n    }\n   \telse if(mid > 5.)\n    {\n        mc = texture(iChannel2, p.yz).xyz;\n    }\n    else if(mid > 4.)\n    {\n        vec2 q = p.xy-CLOCK_OFFSET.xy;\n        float cd = length(q);\n        if(cd < CLOCK_RADIUS-.04)\n        {\n            cd = smoothstep(CLOCK_RADIUS-0.1, CLOCK_RADIUS-.05, cd) -\n                 smoothstep(CLOCK_RADIUS-.05,CLOCK_RADIUS-0.03,cd);\n            if(q.x>-0.03&&q.y>-0.03)\n            {\n            \tfloat minute = (smoothstep(-.02, .02, q.x+.01)-\n                \t            smoothstep(0.02, 0.04, q.x+.01));\n            \tfloat hour = (smoothstep(-.02, .02, q.y+.01)-\n                \t            smoothstep(0.02, 0.04, q.y+.01));\n            \tcd = max(cd, minute);\n            \tcd = max(cd, hour);\n            }\n            cd = 1.-cd;\n\n            mc = vec3(cd);\n        }\n        else mc = vec3(0.1);\n    }\n    else if(mid > 3.)\n    {\n        mc = vec3(0.9, 0.0, 0.);\n        if(abs(p.y+0.4)<0.1)\n            mc = vec3(1.);\n    }\n    else if(mid > 2.)\n    {\n        mc = texture(iChannel1, p.xz*.1).xyz * 0.5;\n        refl = 1.;\n    }\n    else if(mid > 1.)\n    {\n        mc = vec3(20.0);\n    }\n    else if(mid > 0.)\n    {\n        mc = vec3(0.3, 0.9, 1.) * 0.4;\n        \n    }\n    else \n    {\n       \tif(p.y<2.9)\n        {\n            n=bump_mapping(p, n, 0.2/(1.+dist*0.4));\n        }\n        \n        if(p.y>0.5 && (abs(abs(p.y)-2.2)<0.67))\n        \tmc=vec3(0.3, 0.9, 1.) * 0.5;\n        \n    }\n    \n    if(p.y < 0.5 && abs(p.x)>2.2 && (abs(abs(p.y)-3.)<0.18))\n    {\n        mc=vec3(0.3, 0.9, 1.) * 0.2;\n        refl = 0.8;\n    }\n    \n    // bloody\n    { \n        vec3 q = p;\n        if(q.x<0.&&q.y>-2.9)\n           q.z += 1.;\n        \n        mc.yz -= pow(texcube(iChannel3, q.xyz*.08, n).x,3.5)*3.5;\n        mc = max(vec3(0.),mc);\n        \n    }\n   \n  \n    float occ = get_ao(p, n);\n    float dif = 8.*direct_light(p, l0_pos, n, 8.3);\n    float bac = max(0., dot(-l0_dir, n));\n    float bce = clamp(n.y * 0.8 + 0.2, 0.0, 1.0);\n    float spe = max(0.0, pow(clamp(dot(-rd, reflect(-l0_dir, n)), 0.0, 1.0), 20.0));\n\n    float env = 1.;\n    \n    vec3 lin = vec3(0.);\n    \n    lin += 4. * dif * occ ;\n    lin += 0.5 * bac * vec3(1.) * occ;\n    lin += 1.0 * bce * vec3(1.) * occ;\n    lin += 1.0 * env * occ;\n    lin += 2.0* spe * vec3(1.);\n    lin = lin * 0.2 * mc * (.5+.5*occ);\n    return lin;\n}\n\n\nvec3 calc_reflection(vec3 ro, vec3 prev_rd, vec3 n, vec2 screen)\n{         \n    vec3 rd = reflect(prev_rd, n);\n    ro += 0.1 * n;\n\n    \n    vec3 res;\n    float t = 0.01;\n    for(int i = 0; i < 32; ++i)\n    {\n        vec3 p = ro + rd * t;\n        res = map(p);\n        if(res.x < 0.005 * t || res.x > 20.)\n            break;\n        t += res.x;\n    }\n    \n    if(res.x > 20.) t = -1.;\n    res = vec3(t, res.y, res.z);\n    \n    vec3 col = vec3(0.);\n    if(res.x > -.5)\n    {\n        vec3 pos = ro + res.x * rd;\n        n = get_normal(pos);\n        col = lighting(ro, rd, pos, n, res.y, res.x);\n    }\n    return col;\n}\n    \nvoid camera(inout vec3 ro, inout vec3 rd, in vec2 p)\n{\n    float v = 2.;\n    float fov = 1.3;\n    \n    vec3 look_at;\n    float yoffset=sin(iTime*2.)*0.02;\n    \n    if(iTime < 7.)\n    {\n   \t\tlook_at = vec3(0., 0., v);\n    \tro = look_at + vec3(0., -1.3, -23.+iTime*0.1);     \n    }\n    else if(iTime < 15.)\n    {\n        look_at = vec3(0., 0., v);\n    \tro = look_at + vec3(0., -1.3, -13.+iTime*0.1);\n    }\n    else\n    {\n        look_at = vec3(5., 0., v);\n\n        ro = look_at + vec3(-6., -1.3+yoffset, -12.);\n\n    }\n      \n    vec3 f = normalize(look_at - ro);\n    vec3 r = normalize(cross(vec3(0., 1., 0.), f));\n    vec3 u = cross(f, r);\n    \n    rd = normalize(p.x * r + p.y * u + fov * f);\n}\n\t\t\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 q = fragCoord / iResolution.xy;\n    vec2 p = 2. * q - 1.;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 ro, rd;\n\tcamera(ro, rd, p); \n    \n    vec3 res = intersect(ro, rd);\n    \n    vec3 col = vec3(0.);\n    \n    if(res.x > -0.5)\n    {\n        vec3 pos = ro + res.x * rd;\n        vec3 n = get_normal(pos);\n\n        col = lighting(ro, rd, pos, n, res.y, res.x);\n        if(refl > 0.)\n        {\n            float f = .04 + (1.-.04)*pow(1.-max(dot(n,-rd),0.),5.);\n            col += f*refl*calc_reflection(pos, rd, n, fragCoord);\n            //col += 0.2*refl*calc_reflection(pos, rd, n, fragCoord);\n             // bloody\n    \t\t{ \n        \t\tcol.yz -= pow(texcube(iChannel3, pos.xyz*.08, n).x,4.5)*4.5;\n        \t\tcol = max(vec3(0.),col);\n        \n    \t\t}\n        }\n        col=mix(col, 0.15*vec3(0.4,0.75,1.0), 1.0-exp(-0.0015*res.x*res.x) );\n\n    }\n    \n    fragColor.xyz = col;\n    fragColor.xyz = mix(fragColor.xyz, vec3(0.), smoothstep(1.,0., iTime));\n    if(iTime > 6.)\n    {\n        //fragColor.xyz = mix(fragColor.xyz, vec3(0.), smoothstep(0.,1., iTime-6.));\n        fragColor.xyz = mix(fragColor.xyz, vec3(0.), smoothstep(1.,0., iTime-7.));\n\n    }\n    if(iTime > 14.)\n    {\n        fragColor.xyz = mix(fragColor.xyz, vec3(0.), smoothstep(1.,0., iTime-15.));\n\n    }\n\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}