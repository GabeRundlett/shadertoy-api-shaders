{
    "Shader": {
        "info": {
            "date": "1667415701",
            "description": "my second test with volumetric raymarching! move the view with the mouse",
            "flags": 0,
            "hasliked": 0,
            "id": "cdjGzw",
            "likes": 46,
            "name": "Dreaming in the Clouds",
            "published": 3,
            "tags": [
                "volume",
                "fbm",
                "light",
                "fog",
                "smoke"
            ],
            "usePreview": 1,
            "username": "kishimisu",
            "viewed": 1464
        },
        "renderpass": [
            {
                "code": "/* Testing my recent volumetric raymarcher on more complex \n   and dynamic scenes.\n   I think the lighting (especially the sky) could be improved.   \n*/\n#define MAX_ITER 300.\n#define MAX_DIST 25.\n#define ABSORPTION 10.\n\n#define hash33(p) fract(sin( (p) * mat3( 127.1,311.7,74.7 , 269.5,183.3,246.1 , 113.5,271.9,124.6) ) * 43758.5453123)\n\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\n// noise and fbm are from https://www.shadertoy.com/view/XtS3DD\nfloat noise(in vec3 p) {\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n\tfp = fp*fp*(3.0-2.0*fp);\n\tvec2 tap = (ip.xy+vec2(37.0,17.0)*ip.z) + fp.xy;\n\tvec2 rz = textureLod(iChannel0, (tap+0.5)/256.0, 0.0).yx;\n\treturn mix(rz.x, rz.y, fp.z);\n}\n\nfloat fbm(in vec3 x) {\n    x += vec3(iTime*.015, iTime*.035, 0.);\n    \n    float rz = 0.;\n    float a = .35;\n    for (int i = 0; i<4; i++) {\n        rz += noise(x)*a;\n        a*=.35;\n        x*= 4.;\n    }\n    return rz - .25;\n}\n\n\n// signed distance to volume\nfloat vol(vec3 p) {\n    p.z += iTime*.8;\n    float r = fbm(p) + max(0., p.y) - .1 - .08*smoothstep(1.,0.,length(p.xy));\n    return p.y - r*((cos(iTime*.146+1.)*.5+.5)*.1+.9) - (sin(iTime*.2)*.5+.5)*abs(p.x)*.1;\n}\n\n// get light visibility at point\nfloat sampleLight(vec3 ro, vec3 lightPos, float att) {  \n    float t = 0., visibility = 1., stepSize = 0.005*2.;\n    vec3 rd = normalize(ro-lightPos);\n    float dstLight = length(ro-lightPos);\n    \n    // directional light if att < 0., else point light\n    float attenuation = att < 0. ? 1. : smoothstep(0., 1., att / pow(dstLight, 2.0));\n    \n    for (int i = 0; i < 9; i++) {\n        vec3 p = ro + t*rd;\n        float d = vol(p);\n        t += max(stepSize, d) + hash33(p).x*.002;\n        if (d < 0.) visibility *= exp(-stepSize*ABSORPTION);\n        if (t > dstLight) break;\n    }\n    \n    return visibility * attenuation;\n}\n\nvoid initCamera(vec2 fragCoord, inout vec3 ro, inout vec3 rd) {\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    vec2 m = iMouse.z == 0. ? vec2(.5) : iMouse.xy/iResolution.xy;\n    \n    ro = vec3(0., 0.25, 0.);                                   // camera position\n    float mx = (sin(-(iTime-3.)*.2)*.5)*.8 - (m.x*2.-1.)*.5 + 1.54; // camera x rotation\n    float my = (m.y-.5)*.5;                                    // camera y rotation\n    \n    vec3 f = normalize(vec3(cos(mx), my, sin(mx))),\n         r = normalize(cross(vec3(0,1,0), f)),\n         u = cross(f,r),\n         c = ro+f,\n         i = c + uv.x*r + uv.y*u;    \n    rd = normalize(i-ro); // camera direction\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 ro, rd;\n    \n    initCamera(fragCoord, ro, rd);\n    \n    float visibility = 1.;\n    vec3 vColor = vec3(0.), color = vec3(.14,0.08,.12)*.85;\n    \n    float t = 0., eps = 0.0005;\n    float inside = vol(ro) < 0. ? 1. : 0.;\n            \n    for (float i = 0.; i < MAX_ITER; i++) {\n        vec3 p = ro + t*rd;\n        \n        float dvol = vol(p);\n        float d = abs(dvol) + 0.001*t;\n        t += d;\n                \n        bool isInsideVolume = mod(inside, 2.) > .5;\n        \n        if (!isInsideVolume) { \n            if (dvol < eps) { \n                inside++; t += eps*10.; // enter volume\n            }\n        } else {    \n            if (dvol > -eps) {  \n                inside++; t += eps*10.; // exit volume\n            } else {\n                // sample density & light\n                float prev = visibility;\n                visibility *= exp(-d*ABSORPTION);\n                \n                vec3 absorption = vec3(prev - visibility);\n                \n                absorption *= mix(color, vec3(1.), exp(-t*.05));\n                vColor += absorption * sampleLight(p, -vec3(0., 4., 0.), 10.) * vec3(1.2,.6,.3)*.75;\n                vColor += absorption * sampleLight(p, -vec3(0., 1e6, 0.), -1.) * (vec3(1.3, 1.,.8)*.5 + 0.5*fbm(p));\n                        \n                if (visibility <= .01 || dot(vColor, vColor) >= 3.) break;    \n            }\n        }\n        \n        if (t > MAX_DIST) { i = 0.; break; }\n    }\n        \n    color = vColor + color * visibility;\n        \n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}