{
    "Shader": {
        "info": {
            "date": "1575320934",
            "description": "Noise looks kinda cool actually",
            "flags": 32,
            "hasliked": 0,
            "id": "tsGSDt",
            "likes": 20,
            "name": "One strange little cloud :)",
            "published": 3,
            "tags": [
                "raymarching",
                "fractal",
                "cloud",
                "mandelbulb",
                "volumetric",
                "pathtracing"
            ],
            "usePreview": 1,
            "username": "loicvdb",
            "viewed": 765
        },
        "renderpass": [
            {
                "code": "vec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec4 col = texture(iChannel0, fragCoord/iResolution.xy);\n    vec3 bloom = vec3(0);\n    for(int y = -1; y <= 1; y++)\n        for(int x = -1; x <= 1; x++)\n            bloom += textureLod(iChannel0, (fragCoord+vec2(x, y) * 32.0)/iResolution.xy, 7.0).rgb / col.a;\n    \n    bloom = max(bloom/9.0 - vec3(.5), vec3(0)) * .25;\n    col /= col.a;\n    fragColor = vec4(ACESFilm(col.rgb + bloom), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define StepSize 0.03\n#define ShadowStepSize 0.2\n#define Pi 3.14159265359\n#define ShadowRaysPerStep .25\n\nvec3 CamPos = vec3(0, 0, -2.5);\nvec3 CamRot = vec3(.0, .0, .0);\nfloat CamFocalLength = 1.0;\nfloat CamFocalDistance = 1.6;\nfloat CamAperture = .075;\n\nvec3 LightColor = vec3(.5, .5, .7) * 20.0;\nvec3 LightDir = normalize(vec3(-1, -3, 1));\n\nfloat Power = 5.0;\nfloat PhiShift = 0.0;\nfloat ThetaShift = 0.0;\n\nfloat Density = 10.0;\n\nvec3 VolumeColor = vec3(.3);\n\n\nvec2 seed;\n\nfloat rand(vec2 n) {\n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat randomFloat(){\n  seed += vec2(1.153535, -1.1231354);\n  return rand(seed);\n}\n\nmat3 rotationMatrix(vec3 rotEuler){\n    float c = cos(rotEuler.x), s = sin(rotEuler.x);\n    mat3 rx = mat3(1, 0, 0, 0, c, -s, 0, s, c);\n    c = cos(rotEuler.y), s = sin(rotEuler.y);\n    mat3 ry = mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n    c = cos(rotEuler.z), s = sin(rotEuler.z);\n    mat3 rz = mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n    \n    return rz * rx * ry;\n}\n\nfloat maxV(vec3 v){\n    return v.x > v.y ? v.x > v.z ? v.x : v.z : v.y > v.z ? v.y : v.z;\n}\n\n\nfloat distanceEstimation(vec3 pos) {\n    if(length(pos) > 1.5) return length(pos) - 1.2;\n    vec3 z = pos;\n    float dr = 1.0, r = 0.0, theta, phi;\n    for (int i = 0; i < 6; i++) {\n        r = length(z);\n        if (r>1.5) break;\n        dr =  pow( r, Power-1.0)*Power*dr + 1.0;\n        theta = acos(z.y/r) * Power + ThetaShift;\n        phi = atan(z.z,z.x) * Power + PhiShift;\n        float sinTheta = sin(theta);\n        z = pow(r,Power) * vec3(sinTheta*cos(phi), sinTheta*sin(phi), cos(theta)) + pos;\n    }\n    return 0.5*log(r)*r/dr;\n}\n\nvec3 directLight(vec3 pos){\n    \n    vec3 absorption = vec3(1.0);\n    \n    for(int i = 0; i < 7; i++){\n        float dist = distanceEstimation(pos);\n        pos -= LightDir * max(dist, ShadowStepSize);\n        if(dist < ShadowStepSize) {\n            float abStep = ShadowStepSize * randomFloat();\n            pos -= LightDir * (abStep-ShadowStepSize);\n            if(dist < 0.0){\n                absorption *= exp(-Density*abStep);\n                if(maxV(absorption) < .1) break;\n            }\n        }\n        \n        if(length(pos) > 1.5) break;\n    }\n    return LightColor * absorption;\n}\n\nvec3 backgroundColor(vec3 dir){\n    return texture(iChannel1, dir).rgb * 1.25;\n}\n\nvec3 randomDir(){\n    return vec3(1, 0, 0) * rotationMatrix(vec3(randomFloat()*2.0*Pi, 0, randomFloat()*2.0*Pi));\n}\n\nvec3 pathTrace(vec3 rayPos, vec3 rayDir){\n    \n   \trayPos += rayDir * max(length(rayPos)-1.5, 0.0);\n    \n    vec3 outColor = vec3(0.0);\n    vec3 absorption = vec3(1.0);\n    \n    for(int i = 0; i < 150; i++){\n        float dist = distanceEstimation(rayPos);\n        rayPos += rayDir * max(dist, StepSize);\n        if(dist < StepSize && length(rayPos) < 1.5) {\n            float abStep = StepSize * randomFloat();\n            rayPos += rayDir * (abStep-StepSize);\n            if(dist < 0.0){\n                \n                float absorbance = exp(-Density*abStep);\n                float transmittance = 1.0-absorbance;\n                \n                if(dist > -.0005) outColor += absorption * vec3(.5, .1, .2);\n                \n                if(randomFloat() < ShadowRaysPerStep) outColor += 1.0/ShadowRaysPerStep * absorption * VolumeColor * transmittance * directLight(rayPos);\n                if(maxV(absorption) < .05) break;\n                if(randomFloat() > absorbance) {\n                    rayDir = randomDir();\n                    absorption *= VolumeColor;\n                }\n            }\n        }\n        \n        if(length(rayPos) > 1.5 && dot(rayDir, rayPos) > 0.0)\n            return outColor + backgroundColor(rayDir) * absorption;\n    }\n    \n    return outColor;\n}\n\nvec2 rotate(vec2 v, float angle){\n    return vec2(v.x * cos(angle) + v.y * sin(angle),\n                v.y * cos(angle) - v.x * sin(angle));\n}\n\nvec2 sampleAperture(int nbBlades, float rotation){\n    float alpha = 2.0*Pi / float(nbBlades);\n    float side = sin(alpha/2.0);\n    \n    int blade = int(randomFloat() * float(nbBlades));\n    \n    vec2 tri = vec2(randomFloat(), -randomFloat());\n    if(tri.x+tri.y > 0.0) tri = vec2(tri.x-1.0, -1.0-tri.y);\n    tri.x *= side;\n    tri.y *= sqrt(1.0-side*side);\n    \n    return rotate(tri, rotation + float(blade)/float(nbBlades) * 2.0 * Pi);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = (fragCoord+vec2(randomFloat(), randomFloat())-iResolution.xy/2.0) / iResolution.y;\n    \n    seed = fragCoord/iResolution.xy * 1000.0 + log(vec2(iFrame));\n    \n    float time = .015*float(iFrame);\n    \n    \n    PhiShift -= time;\n    ThetaShift -= time;\n    Power *= sin(time*.1);\n    \n    CamRot.z = .5*sin(time*.3);\n    CamRot.y += time*.2;\n    CamPos *= rotationMatrix(vec3(0, time*.2, 0));\n    \n    \n    fragColor = texture(iChannel0, fragCoord/iResolution.xy)*.9;\n    \n    vec3 focalPoint = vec3(uv * CamFocalDistance / CamFocalLength, CamFocalDistance);\n    vec3 aperture = CamAperture * vec3(sampleAperture(6, 0.0), 0.0);\n\n    vec3 rayDir = normalize(focalPoint-aperture);\n    \n    mat3 CamMatrix = rotationMatrix(CamRot);\n\n    rayDir *= CamMatrix;\n    fragColor += vec4(pathTrace(CamPos + aperture*CamMatrix, rayDir), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}