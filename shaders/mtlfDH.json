{
    "Shader": {
        "info": {
            "date": "1692898000",
            "description": "Found this nice truchet pattern (see link), but just felt it could use some spin and movement to explore it. All credits to XT95!\n\nPress mouse button to zoom.\n\nUse fullscreen!",
            "flags": 0,
            "hasliked": 0,
            "id": "mtlfDH",
            "likes": 24,
            "name": "Mondrian Truchet explored",
            "published": 3,
            "tags": [
                "2d",
                "truchet",
                "pattern",
                "mondrian",
                "samuel",
                "monnier"
            ],
            "usePreview": 1,
            "username": "misol101",
            "viewed": 498
        },
        "renderpass": [
            {
                "code": "// Movement and zoom added by misol101.\n\n// ---------------------------------------------------------------------------------------\n//\tCreated by anatole duprat - XT95/2017\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Truchet variation with Mondrian color style \n//  Idea by Samuel Monnier : http://algorithmic-worlds.net\n//\n//  Looks better in fullscreen !\n//\n// ---------------------------------------------------------------------------------------\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n\n// we need 3 cells to do this effect\nconst vec2 dir[3] = vec2[]( vec2(0.,0.), vec2(1.,0.), vec2(0.,1.)); \n\n// color palette\nconst vec3 palette[7] = vec3[]( vec3(.8,0.,0.), vec3(0.,.4,1.), vec3(1.,1.,1.),\n        \t\t\t\t\t  vec3(1.,.8,0.), vec3(1.,.9,.9), vec3(.7,.8,1.),\n        \t\t\t\t\t  vec3(1.,.9,.8) );\n\n\nvoid Mondrian( vec2 uv, float res, inout vec4 col, inout int currentPalette )\n{\n    uv *= res;\n\tfloat lw = max(0.001*res,0.02); // line width\n    \n    \n    // cell tiling\n    vec2 iuv = floor(uv);\n    vec2 fuv = fract(uv);\n\n\t// random number for each cell\n    vec2 v[3];\n    for(int i=0; i<3; i++)\n        v[i] = (texture(iChannel0, (iuv+dir[i])/256.).rg)*(1.-exp(-iTime));\n    \n    \n    // draw segments in the four directions\n    float l = 1.;\n    l = min(l, abs(fuv.y-v[0].y) + step( max(v[2].x,v[0].x)+lw, fuv.x ) );\n    l = min(l, abs(fuv.y-v[1].y) + step( fuv.x+lw, min(v[2].x,v[0].x) ) );\n    l = min(l, abs(fuv.x-v[0].x) + step( max(v[1].y, v[0].y), fuv.y ) );\n    l = min(l, abs(fuv.x-v[2].x) + step( fuv.y, min(v[1].y,v[0].y) ) );\n    \n    \n    // get random color if we are in the box of the four segments\n    if( step( fuv.x, max(v[2].x,v[0].x) ) * step( min(v[2].x,v[0].x), fuv.x ) *\n        step( fuv.y, max(v[1].y,v[0].y) ) * step( min(v[1].y,v[0].y), fuv.y )  > .1 )\n    {\n        \n        currentPalette = int( mod(v[0].y*42.+float(currentPalette), 7.) );\n        col.rgb = palette[currentPalette];\n    }\n    \n    // line are done in a separate channel to simplify the blending\n    col.a *= step(lw, l);\n}\n\n\n// classic hash function for jittering\nvec2 hash2( float n ) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const int nbSample = 3;\n    vec3 c = vec3(0.);\n    \n    \n    for(int s=0; s<nbSample; s++)\n    {\n    \tvec2 uv = (-iResolution.xy + 2.0*(fragCoord+(hash2( float(s) )-0.5)))/ iResolution.y;\n\n        uv*=rot(-iTime/4.);\n\n    \tint currentPalette = 2;\n    \tvec4 col = vec4(1.);\n        for(int i=0; i<4; i++)\n        {\n            vec2 p = (uv+vec2(iTime/87.,0.)) + vec2(3.,0.)*((iTime/8.));\n            if (iMouse.z > 0.) {\n                p = (uv+vec2(iTime/87.,0.)) + vec2((4.-float(i))*0.6,0.) + vec2(1.,0.)*((iTime/194.));\n                p *= sin(iTime/2.)*0.4 + 0.685; \n            }\n            float res = float(i*i)*2.+1.;\n       \t\tMondrian(p, res, col, currentPalette);\n        }\n\n\t\tc += col.rgb*col.a;\n    }\n    \n    c /= float(nbSample);\n\tfragColor = vec4(c, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}