{
    "Shader": {
        "info": {
            "date": "1639698849",
            "description": "A trip around brittle hollow from Outer Wilds",
            "flags": 32,
            "hasliked": 0,
            "id": "NsyXWt",
            "likes": 12,
            "name": "Brittle Hollow",
            "published": 3,
            "tags": [
                "fractal",
                "voronoi",
                "noise",
                "raymarch",
                "rays",
                "space",
                "geometry",
                "modulus",
                "recursion",
                "buffer",
                "planets",
                "detail",
                "resolution",
                "outerwilds"
            ],
            "usePreview": 0,
            "username": "Remming_Senegal",
            "viewed": 414
        },
        "renderpass": [
            {
                "code": "/*\n    Behold! Brittle Hollow from OuterWilds!\n    I'm a huge fan of this game, and this project gave me a good reason to make it myself\n    Lots of customized shaders going on to try and mimic the game.\n    There's probably ALOT I could cut down on for performance, so get ready for that in multiple updates!\n*/\n\n/*\n    Post-Processing buffer\n    This is where bloom and other graphical effects will happen\n*/\nfloat sdCircle(vec2 p, float s) {\n    \n    return length(p)-s;\n}\n\n// Check out https://www.desmos.com/calculator/eie9tao79e\nfloat warpSpace(float x, float scale, float slope) {\n    // delta changes where the center is\n    vec2 delta = vec2(0.0);\n    \n    float u = scale*(x-delta.x);\n    float v = sign(u);\n    v /= abs((u * u) - slope);\n    v += u;\n    v /= scale;\n    v += delta.y;\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    // -----------------------------------------------\n    //\n    //     Coordinate Spaces that we might use\n    //\n    // -----------------------------------------------\n    float aspect = iResolution.x/iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 center_uv = ((uv * 2.0 - 1.0)/2.0); //(0,0) is in the center of the screen\n    vec2 square_uv = center_uv; \n    square_uv.x *= aspect; // (0,0) and aspect ratio applied\n    \n    // ----------------------------------\n    //\n    //     The Rest of The Image\n    //\n    // ----------------------------------\n    \n    vec4 image = texture(iChannel0,uv);\n    vec3 bufferA = image.rgb;\n    float bufferA_depth = image.a;\n    \n    vec3 finalcolor = bufferA;\n    \n    // ---------------------------------\n    //\n    //         The Black Hole\n    //\n    // ---------------------------------\n    \n    // ---------------------------\n    // STEP 1) Make a blackhole prop\n    // ---------------------------\n    float bh_dist = sdCircle(square_uv,-0.3);\n    \n    // ---------------------------\n    // STEP 2) Make a blackhole UV shader\n    // --------------------------- \n    \n    // Blackhole color\n    vec3 bh_color = vec3(0.0);\n    \n    // The actual circle that makes the blackhole\n    float bh_circle = 1.0 - smoothstep(0.4,0.403,bh_dist);\n    \n    // The shader is the \"uv\" times the color\n    vec3 blackhole = bh_color*bh_circle;\n    \n    // The range of influence for the warping shader\n    float bh_influence = 1.0 - smoothstep(0.6,0.7,bh_dist);\n\n    // --------------------------------------------------------\n    // STEP 3) Warp the space\n    // If it's in the skybox or this far away, render the blackhole\n    // --------------------------------------------------------\n    #define BLACKHOLEWARP\n    \n    #ifdef BLACKHOLEWARP\n    if(bufferA_depth <= 1.0 || bufferA_depth > 15.0) {\n        \n        // This math here exists to add a circular warp on a uv with no aspect ratio applied to it\n        float l = length(center_uv);\n        float sc = length(normalize(center_uv) * vec2(aspect,1.0)) * 9.3;\n        \n        float warp = warpSpace(l,sc,1.4);\n        vec2 warpuv = warp * normalize(center_uv);\n        warpuv += 0.5; // set center to (0,0)\n        \n        // The warp shader.\n        // Ya it's post-process\n        vec3 warpcol = texture(iChannel0,warpuv).rgb;\n        \n        // Add the warp effect\n        finalcolor = mix(finalcolor,warpcol,bh_influence);\n        // Add the blackhole prop\n        finalcolor = mix(finalcolor,blackhole,bh_circle);\n    }\n    #endif\n    \n    // ---------------------------------------------------------\n    // Add a fade to white after all the rocks have fallen\n    // --------------------------------------------------------\n    \n    // Despite me already defining time in buffer A, \n    // my BEST GUESS is that I have to do it again because time's value will only exist\n    // within the SCOPE of buffer A?\n    \n    time = mod(iTime,MAX_LOOP); \n    if(time >= MAX_LOOP*0.9) {\n        \n        float fadeout = time-(MAX_LOOP*0.9);\n        \n        finalcolor += vec3(fadeout);\n    }\n    if(time <= MAX_LOOP*0.1 && iTime > MAX_LOOP) { // iTime > MAX_LOOP is so it doesn't do it the first time\n        float fadein = 1.0 - (time);\n        finalcolor += vec3(max(fadein,0.0));\n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(finalcolor,1.0);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n    Functions that I find myself reusing in every project I do\n    Not much of this is actually used, but it gives me a file I can just copy and paste everywhere\n    Any shader-specific stuff will most likely be in the image buffer\n    This is probably a file that you'll see grow more and more as I use it in more projects\n    Everything in here found is what should be unchanged from shader to shader.\n*/\n\n/*---------------------------------------------------------------------------------\n\n    All purpose variables that can be used anywhere 3D, 2D, raymarching, functions, and more!\n    \n-----------------------------------------------------------------------------------*/\nfloat time = 0.0; //eventually set to iTime. Easiest way to get around the lack of an timer in common\n#define FOV 90.0\n#define PI 3.14159265359\n#define MAX_LOOP 50.0\n//#define DEBUG\n\n/*\n    First section all about transformations\n*/\n\nmat3 RotationX(float rotation) {\n    mat3 rotateX = mat3(\n        1.0, 0.0, 0.0,\n\t\t0.0, cos(rotation), -sin(rotation),\n\t\t0.0, sin(rotation), cos(rotation)\n    );\n\n    return rotateX;\n}\n\nmat3 RotationY(float rotation) {\n    mat3 rotateY = mat3(\n        cos(rotation), 0.0, sin(rotation),\n\t\t0.0, 1.0, 0.0, \n\t\t-sin(rotation), 0.0, cos(rotation)\n    );\n\n    return rotateY;\n}\n\nmat3 RotationZ(float rotation) {\n    mat3 rotateZ = mat3(\n        cos(rotation), -sin(rotation), 0.0,\n\t\tsin(rotation), cos(rotation), 0.0,\n\t\t0.0, 0.0, 1.0\n    );\n\n    return rotateZ;\n}\n\n// scale would just be *= vec3(scales)\n// and translate would just be += vec3(translation)\n// so no functions for that just yet\n\n\n/*\n    Applies transformations as we see fit\n    It's in a function like this because we call this twice\n        -Transform the ray that the scene uses\n        -Transform the UV that the tetxure shader uses\n    THIS IS A VERY IMPORTANT FUNCTION! DO NOT LOOSE IT!\n*/\n\n//this is so sad why isn't iTime already declared :(\nvoid Transform(inout vec3 p) {\n    p *= RotationY(0.5*time);\n}\n\n// Transform function that returns a value instead of editing the parameter\nvec3 TransformReturn(vec3 p) {\n    vec3 temp = p;\n    Transform(temp);\n    return temp;\n}\n\n/*\n    Signed Distance functions and their operations\n    Basically the core of the scene.\n*/\n\nstruct sdf {\n    float dist; // nothing to see here just the distance\n    int ID; // ID which we can then use to apply a corresponding shader to\n    mat3 transform; // Specific transformation that the SDF around it\n};\n\n// Signed primitives\nfloat sdSphere(vec3 p, float s) {\n    \n    return length(p)-s;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    \n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat sdPlane(vec3 p, vec3 n, float h)\n{\n    // n must be normalized\n    return dot(p,n) + h;\n}\n\n// c is the angles of the cone\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\n//operations\nvec3 sdInfinite(vec3 sd, float c) {\n    return mod(sd+0.5*c,c)-0.5*c;\n}\n\nvec3 sdRepeat(vec3 sd, float c, vec3 d) {\n    vec3 q = sd-c*clamp(round(sd/c),-d,d);\n    return q;\n}\n\nvec3 sdReflectX(vec3 p)\n{\n    float q;\n    q = abs(p.x);\n    return vec3(q,p.yz);\n}\n\nvec3 sdReflectXZ(vec3 p) {\n\tvec2 q;\n    q = abs(p.xz);\n    return vec3(q.x,p.y,q.y);\n}\n\nfloat smoothEdges( in float d, in float h ) {\n    return d - h;\n}\n\n// All from https://iquilezles.org/articles/distfunctions\n// Me prentending that I didn't just copy and paste this from IQs site\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n/*\n    Structures and functions that we can use to set up the 3D scene\n    The most complicated step in this part is adding SDFs\n    Not only does it apply some sort of union, it also has to keep track of IDs\n    The IDs are responsible for saying which shader should be applied to a given shape.\n    \n    TODO: \n        -Figure out how to merge the colors of two objects in a union\n        -Correct UVs for individual objects\n*/\n\nstruct Ray {\n    vec3 ori;\n    vec3 dir;\n};\n\nstruct Light {\n    Ray point;\n    vec3 color;\n    float strength;\n};\n\n// keeps me from having to write the same inputs again and again\nstruct ShaderInput {\n    vec3 normal; // normals of scene\n    vec3 cameraNormal; //normals of the scene relative to the camera. Its just the normals but transformed\n    Ray rendered; // the scene after all the raymarching has been done\n    Ray camera; // viewport\n    vec3 uv; // UVs of each SDF\n    float depth; // depth buffer\n};\n\n// The ID of the obj that the ray hits\n#define SKY -1\nint ID = SKY;\n\n//-------------------------------------------------------------------------------------------------\n// Shader IDs\n//-------------------------------------------------------------------------------------------------\n#define CRACKS 0\n#define ICE 1\n#define BLACKHOLE 2\n#define ICICLES 3\n#define INSIDE 4\n\n// The whole scene in just one float. Yep\nfloat globalsd;\nbool ignoreID = false; // HORRIBLE way to program this, but saves me time\n\nvoid addSDF(sdf obj) {\n    globalsd = min(globalsd, obj.dist);\n    if(globalsd == obj.dist && !ignoreID) {\n        ID = obj.ID;\n    }\n}\n\nvoid subtractSDF(sdf obj) {\n\n    globalsd = max(globalsd, -obj.dist);\n    if(globalsd == obj.dist && !ignoreID) {\n        ID = obj.ID;\n    }\n}\n\n// -------------------------------------------------\n// Noise functions\n// ---------------------------------------------\nvec3 hash(vec3 x, sampler2D channel) {\n    return textureLod( channel, (x.xy+vec2(3.0,1.0)*x.z+0.5)/256.0, 0.0).xyz;\n}\n\nvec3 hash2( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(p)*43758.5453123);\n}\n\n// return value noise (in x) and its derivatives (in yzw)\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash2( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash2( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash2( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash2( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash2( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash2( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash2( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash2( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nmat3 noisemat = mat3(\n            1.2, 0.5, 1.6,\n            -1.6, 1.2, 0.5,\n            -0.5, -1.6, 1.2\n        );\n        \n// ----------------------------\n// Misc mathematical functions\n// ----------------------------\n\n// Forces a discontinuity in x\nfloat cut(float x, float n) {\n    return round(x*n)/n;\n}\n\nvec3 cut(vec3 p, float n) {\n    vec3 ret;\n    ret.x = cut(p.x,n);\n    ret.y = cut(p.y,n);\n    ret.z = cut(p.z,n);\n    return ret;\n}\n\n//Doesn't start a timer until a given amount of time later\nfloat forceWait(float t, float offset) {\n    return max(t,offset)-offset;\n}\n\n// -------------------------------------------------------------\n//\n// Texture functions\n// Everything here generally applies to 2d maps or textures\n//\n// -------------------------------------------------------------\nfloat average(vec3 p) {\n    return (p.x+p.y+p.z)/3.0;\n}\n\nfloat average(vec4 p) {\n    return average(p.xyz);\n}\n\nvec3 normalTexture(sampler2D image, vec2 uv, float ep) {\n    float d0 = average(texture(image, uv));\n    \n    float dX = average(texture(image, uv - vec2(ep,0.0) ));\n    float dY = average(texture(image, uv - vec2(0.0,ep) ));\n    \n    vec3 n = vec3(d0-dX,d0-dY,0.0);\n    \n    return normalize(n);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//#define EASYWAYOUT\n#define GAS\n\nvec3 saturate(vec3 rgb, float sat) {\n    vec3 gray = vec3((rgb.r + rgb.g + rgb.b)/3.0);\n    \n    return mix(gray,rgb,sat);\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    #ifdef EASYWAYOUT \n        vec3 col = hash2(rayDir).xxx;\n        col *= 50.0;\n        col -= 49.3; \n    #else\n        vec3 col = vec3(noise(80.0*rayDir));\n        col *= 50.0;\n        col -= 13.0; // This will change overtime to mimic the supernovas across outerwilds\n        vec3 starColor = hash2(cut(rayDir,8.0));\n        starColor = saturate(starColor,0.2);  \n        col *= starColor;\n    #endif\n    col = clamp(col,0.0,1.0);\n\n    // Adds thsi nice ambient gas around the cubemap.\n    // Kind of unessecary but it looks nice\n    #ifdef GAS\n        float gasnoise = noise(rayDir*vec3(1.0,0.5,1.0));\n        vec3 gas = gasnoise * vec3(1.0,0.0,1.0);\n    \n        col += gas;\n    #endif\n    \n    // --------------------------------------------------------------------------------------\n    // This is the sun!\n    // Skip all the intensive distance functions and just make a disc somewhere in the sky\n    // --------------------------------------------------------------------------------------\n    vec3 sunPos = vec3(rayDir.xy,sign(rayDir.z)-1.0);\n    \n    // bloom\n    vec3 glow1 = (1.0-sdSphere(sunPos,0.00001)) * vec3(1.0);\n    vec3 glow2 = smoothstep(0.5,1.0,glow1) * vec3(1.0);\n    vec3 glow3 = smoothstep(0.5,1.0,glow2) * vec3(1.0);\n    \n    vec3 sunBase = smoothstep(0.99,1.0,glow1) * vec3(1.0,1.0,0.0); //Color will change over time\n    \n    vec3 sun = sunBase + glow1 + glow2 + glow3;\n    \n    sun = clamp(sun,0.0,1.0);\n    \n    col += sun;\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            },
            {
                "code": "/*\n    3D Render buffer\n    This is where the brittle hollow and all the textures are generated\n*/\n\n//#define FREE_CAMERA\n\nvec3 hash( vec3 x ) {\n\treturn hash(x,iChannel0);\n}\n\nvoid voronoi3D( in vec3 p, out vec3 coord, out float distToBorder, out float color)\n{\n    vec3 n = floor(p);\n    vec3 f = fract(p);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n    distToBorder = 5.0;\n    for( float x=-1.0; x<=1.0; x++ )\n    for( float y=-1.0; y<=1.0; y++ )\n    for( float z=-1.0; z<=1.0; z++ )\n    {\n        vec3 g = vec3(x,y,z);\n\t\tvec3 o = hash( n + g );\n        vec3 r = g + o - f;\n        float d = length(r);\n\n        if(d<distToBorder)\n        {\n            distToBorder = d;\n            coord = r;\n            color = o.x;\n        } \n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    distToBorder = 8.0;\n    for( float x=-1.0; x<=1.0; x++ )\n    for( float y=-1.0; y<=1.0; y++ )\n    for( float z=-1.0; z<=1.0; z++ )\n    {\n        vec3 g = vec3(x,y,z);\n\t\tvec3 o = hash( n + g );\n        vec3 r = g + o - f;\n        vec3 normal = coord - r;\n       \n        if( dot(normal,normal)>0.0001 ) {\n            float j = dot( 0.5*(coord+r), normalize(r-coord));\n            distToBorder = min( distToBorder, j );\n        }\n    }\n    coord += p;\n}\n\n// returns position\nfloat gravity(float time,float startpoint) {\n    //const float grav = -9.81;\n    const float grav = -2.5; // gravitational constant in m/s/s\n    return startpoint + (grav/2.0)*time*time;\n}\n\n//-------------------------------------------------------------------------------------------------\n// Generate Scene\n// This is where all the object math happens.\n// This giant block comment exists so I don't miss this function when scrolling around the project\n//-------------------------------------------------------------------------------------------------\n\nconst float upperBound = 10.0;\n//const float g = 1./length(vec2(1.,upperBound)); // <- equation used to get g\n// The magic number lags the raymarcher. Why? I have no idea.\nconst float g = 0.099503719021;\nfloat generateScene(vec3 ray) {\n\n    // Transform around the origin\n    Transform(ray);\n    \n    // ---------------------------------------\n    // Place objects in scene\n    // ---------------------------------------\n    \n    // ----------------------\n    // The Planet Surface\n    // ----------------------\n        sdf Planet;\n        Planet.dist = sdSphere(ray,5.0);\n           \n        // First Voronoi Pass. Gives it it's iconic \"cracked\" texture\n        // Normalizing the 3D coordinates gets rid of magnitude, only direction.\n        // This gives us these REALLY nice rays that shoot out from the origin to use as circular coordinates\n        vec3 coord_Pass1;\n        float distToBorder_Pass1;\n        float color_Pass1;\n        voronoi3D(normalize(ray)*5.0,coord_Pass1,distToBorder_Pass1,color_Pass1);\n        \n        //Mess with the cell heights to give them some more variety\n        color_Pass1 *= 0.5;\n        \n        // ----------------------------------------\n        // Simulating Falling Debris:\n        // --------------------------------------\n        // \n        // 1) which rocks fall when is determined by a random number when we input the voronoi cell coord\n        // 2) If the rockStartTime is equal to iTime, start falling\n        // 3) the cell height (color_Pass1) decreases parabolically with the equation x = xo + vt + a/2 t^2. See gravity() for more\n        // \n        // 4) After the time hits a certain value ( probably 5 + decayTime), the process is reversed.\n        //\n        // \n        // -----------------------------------------\n        float decayTime = MAX_LOOP; // seconds that it'll take to fully decimate\n        \n        float randID = hash(coord_Pass1).x;\n        randID *= decayTime;\n        randID = cut(randID,5.0); // Forces some discontinuities so it falls in waves\n        \n        float cellHeight = gravity(forceWait(time,randID),color_Pass1);\n        float maxCellHeight = gravity(forceWait(time,decayTime),color_Pass1);\n        \n        // -----------------------------------------------------------\n        // The Distance calculation\n        // h is height\n        // f is distance to border\n        // if h and f are positive, it means that the closest point away is a corner\n        // if h is negative (inside the cell), f is the closest point away\n        // if f is negative (above the cell) , h is the closest point away\n        // -----------------------------------------------------------\n        float h = Planet.dist - cellHeight;\n        float f = 0.01-distToBorder_Pass1;\n        \n        // Clamp everything to an outermost-sphere\n        // Keeps us from getting raymarch errors from discontinuities in height\n        \n        // these numbers decide the framerate of the whole shader\n        h = max( min( h, 0.05 ), Planet.dist-maxCellHeight-0.2);\n        f = max(f,h);\n\n        float width = 0.4; //width of cell\n    \n        float hI = cellHeight - width;\n        float fI = -distToBorder_Pass1;\n        \n        hI = Planet.dist - hI;\n        fI = max(fI,hI);\n        \n        Planet.dist = max(f,-fI);\n        \n        // Changes the shader ID depending on hI, the height of the inside part of the planet\n        if(hI > 0.01) {\n            Planet.ID = CRACKS;        \n        } else {\n            Planet.ID = INSIDE;        \n        }\n        \n    // ----------------------    \n    // The Ice Caps\n    // ----------------------\n        sdf IceCaps;\n        IceCaps.dist = sdSphere(ray*vec3(1.4,0.95,1.4),5.7);\n        //float cutout = sdSphere(ray*vec3(1.0,1.3,1.0),5.6);\n        float cutout = sdBox(ray,vec3(5.0,3.6,5.0));\n        IceCaps.dist = max(IceCaps.dist,-cutout);\n        \n        // adds noise to snow\n        {\n            vec3 noiseray = ray;\n            for(int i = 0; i < 2; i++) {\n                IceCaps.dist -= noise(0.4*noiseray);\n                noiseray *= noisemat;\n            }\n        }\n        //iceCaps.dist *= g;\n        IceCaps.ID = ICE;\n        \n    // ----------------------    \n    // The Icicles\n    // Very cone + noise based\n    // ----------------------\n        sdf Icicles;\n        float cones;\n        #define MAX_ICICLES 6\n\n        {\n            float cr = 0.4;\n            float cones_top = 99999999.0; // random high number\n            float cones_bottom = 99999999.0;\n            \n            for(int i = 0; i < MAX_ICICLES; i++) {\n                float deg = (float(i) / float(MAX_ICICLES))*2.0*PI;\n                deg *= 2.0;\n                if(i >= (MAX_ICICLES / 2)) cr = 0.2; else cr = 0.4;\n            \n                float ct = sdCone(\n                    ( RotationX(cr*cos(deg)) * RotationZ(cr*sin(deg)) * ray ) + vec3(0.0,1.0,0.0),\n                    vec2(0.04,0.2), \n                    3.8\n                    );\n                cones_top = min(cones_top,ct);\n                \n                float cb = sdCone(\n                    ( RotationX(cr*cos(deg)) * RotationZ(cr*sin(deg)) * (vec3(1.0,-1.0,1.0) * ray) )  + vec3(0.0,1.0,0.0), \n                    vec2(0.04,0.2),\n                    3.8\n                    );  \n                cones_bottom = min(cones_bottom,cb);\n            }\n\n            cones = min(cones_top,cones_bottom); \n        }\n        \n        cones -= 0.5*noise(ray);\n        cones -= 0.1*noise(4.0*ray);\n        \n        Icicles.dist = cones;\n        Icicles.ID = ICICLES;      \n        \n    // ---------------------------------\n    // Adds them together into the scene\n    // ---------------------------------\n    globalsd = 1.0;\n    addSDF(Planet);\n    addSDF(IceCaps);\n    addSDF(Icicles);\n   \n    return globalsd;\n}\n\n// ----------------------------------------------------------------------\n// RayMarching scene\n// TODO: Find optimal numbers for MAX_STEPS, MAX_DISTANCE, and EPSILON\n// ----------------------------------------------------------------------\n\n#define MAX_STEPS 600\n#define MAX_DISTANCE 20.0\n#define EPSILON 0.001\nfloat rayMarch(Ray o) {\n    vec3 ray;\n    float sd,d;\n  \t\n    for(int i = 0; i < MAX_STEPS; i++) {\n        ray = o.ori + (o.dir * d);\n        sd = generateScene(ray);\n        \n        if(sd < EPSILON) {\n            return d;\n        }\n        //Not having this somewhere makes these strange blobs around the objects\n        ID = SKY;\n        \n        d += sd;\n        if(d > MAX_DISTANCE) break;\n    }\n}\n\n// Gets the depth buffer\nfloat depthBuffer(Ray o) {\n    ignoreID = true;\n    vec3 ray;\n    float sd,d;\n  \t\n    for(int i = 0; i < MAX_STEPS; i++) {\n        ray = o.ori + (o.dir * d);\n        sd = generateScene(ray);\n        \n        if(sd < EPSILON) {\n            //ignoreID = false;\n            return d;\n        }\n        \n        d += sd;\n        if(d > MAX_DISTANCE) {\n            //ignoreID = false;\n            break;\n        }  \n    }\n}\n\n#define NORMAL_EPSILON 0.01\nvec3 Normal(vec3 p) {\n    float d0 = generateScene(p);\n    \n    float dX = generateScene(p - vec3(NORMAL_EPSILON,0.0,0.0));\n    float dY = generateScene(p - vec3(0.0,NORMAL_EPSILON,0.0));\n    float dZ = generateScene(p - vec3(0.0,0.0,NORMAL_EPSILON));\n    \n    vec3 r = vec3(d0-dX,d0-dY,d0-dZ);\n    \n    return normalize(r);\n}\n\nvec3 pointLighting(ShaderInput s, Light l, vec3 color) {\n\n    vec3 pointLight = color * dot(l.point.dir,s.normal);\n    \n    // this commented set can take care of shadows, but it's kind of broken and I want to replace it with soft shadows\n    /*Ray o;\n    o.ori = s.rendered.ori + vec3(0.4)*l.point.dir;\n    o.dir = l.point.dir;\n    \n    float lightRay = depthBuffer(o);\n    \n    if(lightRay > 1.0) {\n        pointLight = vec3(0.0);\n    }*/\n    \n    return pointLight;\n}\n\n// Specular lighting from a point in space\nvec3 specularLighting(ShaderInput s, Light l, float specular_power) {\n    vec3 ldir = l.point.dir;\n\n    vec3 h = normalize(s.camera.dir-(ldir));\n    float spec = dot(h,-s.normal);\n    spec = pow(spec,specular_power);\n    \n    if(isnan(spec)) spec = 0.0; //Becomes NAN when facing away form the light.\n    spec = clamp(spec,0.0,1.0);\n    \n    return vec3(spec);\n}\n\n// This manages to somehow, sample a texture? What the fuck?\nvec3 phongLighting(ShaderInput s, Light l, vec3 color, float specular_power) {\n    vec3 phong = pointLighting(s, l, color) + specularLighting(s, l, specular_power);\n    return (color + phong) / 2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = mod(iTime,MAX_LOOP);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = (uv * 2.0 - 1.0)/2.0;\n    \n    // Applying aspect ratio\n    float aspect = iResolution.x/iResolution.y;\n    uv.x *= aspect;\n    \n    // Setting up 3D space\n    vec3 xyz = normalize(vec3(uv,1.0));\n    float fovrange = tan(radians(FOV*.5));\n    xyz *= fovrange;\n    \n    // Setting up camera\n    Ray camera;\n\n    vec2 mouse = -8.0 * vec2(iMouse.xy/iResolution.xy);\n    \n    #ifdef FREE_CAMERA\n        float radius = 15.0;\n        camera.ori = vec3(0.0,radius*sin(mouse.y),-radius*cos(mouse.y)) * RotationY(mouse.x);\n        camera.dir = vec3(mouse.y,mouse.x,0.0);\n    #else\n        float radius = 15.0;\n        float speed = 0.1*iTime + PI/2.0;\n        camera.ori = vec3(0.0,0.0,-radius) * RotationY(speed);\n        camera.dir = vec3(0.0,speed,0.0);\n    #endif\n    \n    // Transforming 3D space to camera space\n    xyz *= RotationX(camera.dir.x) * RotationY(camera.dir.y) * RotationZ(camera.dir.z);\n    \n    // Setting up the raymarch\n    Ray viewport;\n    viewport.ori = camera.ori;\n    viewport.dir = xyz;\n    \n    // Applying raymarch\n    Ray rendered;\n    float depth = rayMarch(viewport);\n    rendered.dir = viewport.dir * depth;\n    rendered.ori = viewport.ori + rendered.dir; //rendered.ori is the new scene data\n    \n    // Correct UV coords to transform with the image\n    vec3 textuv = rendered.ori;\n    Transform(textuv);\n    \n    // Get normals of image\n    vec3 normals = Normal(rendered.ori);\n    \n    // A Set of inputs that most shaders will use. Keeps be from writing the same parameters repeatedly\n    ShaderInput si;\n    si.normal = normals;\n    si.cameraNormal = TransformReturn(normals);\n    si.rendered = rendered;\n    si.camera = viewport;\n    si.uv = textuv * 0.25; // scales the uv down\n    si.depth = depth;\n    \n    // Creating some universal variables that will be used later\n    Light light1;\n    light1.color = vec3(1.0);\n    light1.strength = 1.0;\n    light1.point.ori = vec3(0.0,0.0,6.0);\n    \n    //#define LIGHTDIRNOTWORKING // Light should face sun, but doesn't???\n    #ifndef LIGHTDIRNOTWORKING\n        light1.point.dir = normalize(light1.point.ori - si.rendered.ori);\n    #else\n        light1.point.dir = vec3(0.0,0.0,1.0);\n        light1.point.dir *= RotationY(-iTime); //Am i \"undoing\" a transformation somewhere?\n    #endif\n    \n    // -------------------------------------------------------------------------\n    // ID correlates to the shader that we'll use for a given shape in the scene\n    // Adding {} maintains scope, allowing me to reuse variable names\n    // -------------------------------------------------------------------------\n    vec3 finalcolor;\n    if(si.depth < 1.0) ID = SKY; // Sets out of bounds depth to the sky\n    switch(ID) {\n        case CRACKS:\n            {\n            vec3 colx = texture(iChannel1,(si.uv.zy)).rgb;\n            vec3 coly = texture(iChannel1,(si.uv.xz)).rgb;\n            vec3 colz = texture(iChannel1,(si.uv.xy)).rgb;\n        \n            vec3 blend = abs(si.cameraNormal);\n            blend /= dot(blend,vec3(1.0));\n            \n            vec3 surfaceColor = vec3(1.23,1.0,1.45);\n            vec3 rockySurface = (colx * blend.x + coly * blend.y + colz * blend.z);\n            vec3 surface = surfaceColor * rockySurface;\n            \n            finalcolor = phongLighting(si, light1, surface, 50.0);\n            }\n        break;\n        case ICE:\n            {\n            vec3 surfaceIceCaps = vec3(0.9,0.9,1.0);\n            finalcolor = phongLighting(si, light1, surfaceIceCaps, 0.0);\n            }\n        break;\n        case ICICLES:\n            {\n            vec3 icecolor = vec3(0.7,0.7,1.0);\n            si.normal = cut(si.normal,1.4);\n            finalcolor = phongLighting(si, light1, icecolor, 50.0) + (icecolor / 2.0);\n            }\n        break;\n        case INSIDE:\n            {\n            // The texture\n            vec3 colx = texture(iChannel3,(si.uv.zy)).rgb;\n            vec3 coly = texture(iChannel3,(si.uv.xz)).rgb;\n            vec3 colz = texture(iChannel3,(si.uv.xy)).rgb;\n            \n            // The normal of the texture\n            vec3 ncolx = normalTexture(iChannel3,(si.uv.zy),0.03);\n            vec3 ncoly = normalTexture(iChannel3,(si.uv.xz),0.03);\n            vec3 ncolz = normalTexture(iChannel3,(si.uv.xy),0.03);\n        \n            vec3 blend = abs(si.cameraNormal);\n            blend /= dot(blend,vec3(1.0));\n            \n            vec3 surfaceColor = vec3(1.23,1.0,1.45);\n            vec3 chipSurface = (colx * blend.x + coly * blend.y + colz * blend.z);\n            vec3 surface = surfaceColor * chipSurface;\n            \n            // changes the normal of the underside so there's more detail on the underbelly\n            si.normal += 0.7*(ncolx * blend.x + ncoly * blend.y + ncolz * blend.z);\n            \n            finalcolor = phongLighting(si, light1, surface, 50.0);\n            }\n        break;\n        case SKY:\n            {\n            finalcolor = texture(iChannel2,si.camera.dir).rgb;\n            }\n        break;\n    }\n    \n    // Output to screen \n    // set the alpha channel as the depth buffer\n    fragColor = vec4(finalcolor,si.depth);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// This generates the texture for the underside of the planet\n\n// I got this from https://www.shadertoy.com/view/XtXBzN. Thanks to marian42!\n\nconst float triangleScale = 0.816497161855865; // ratio of edge length and height\nconst float period = 30.0;\n\n// good old randomizer\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 getTriangleCoords(vec2 uv) {\n    uv.y /= triangleScale;\n    vec2 triangleCoords = floor(uv);\n    triangleCoords.x *= 2.0;\n    float mody = floor(mod(triangleCoords.y, 2.0));\n    vec2 local = vec2(fract(uv.x + mody * 0.5) - 0.5, fract(uv.y));\n    \n    // Turns square segments into triangular segments\n    if (local.y > abs(local.x) * 2.0) {\n        triangleCoords.x += local.x < 0.0 ? 1.0 : -1.0;\n    }\n    if (local.x >= 0.0 && mody == 0.0) {\n        triangleCoords.x += 2.0;\n    }\n    \n    return triangleCoords;\n}\n\nfloat getColor(vec2 uv) {\n    vec2 triangle = getTriangleCoords(uv);\n     \n    float angle = floor(6.0 * rand(triangle + 0.1)) / 3.0 * PI;\n    vec2 direction = vec2(sin(angle), cos(angle));\n    float projected = dot(direction, uv);    \n    \n    return rand(triangle);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= 40.0;\n    float value = getColor(uv);\n    \n    vec3 col = vec3(1.0,0.5,0.26);\n    \n    col *= value;\n    col += 0.1;\n    \n\tfragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}