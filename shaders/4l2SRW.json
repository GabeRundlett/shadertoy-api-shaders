{
    "Shader": {
        "info": {
            "date": "1441989062",
            "description": "Sorry it's so horrifically unoptimised (the Halton sequence eval).",
            "flags": 0,
            "hasliked": 0,
            "id": "4l2SRW",
            "likes": 17,
            "name": "Radial dyadic series",
            "published": 3,
            "tags": [
                "radial",
                "symmetry"
            ],
            "usePreview": 0,
            "username": "lycium",
            "viewed": 770
        },
        "renderpass": [
            {
                "code": "//const int num_samples = 2 * 3; // 6\n//const int num_samples = 2*2 * 3*3; // 36\nconst int num_samples = 2*2*2 * 3*3*3; // 8*27 = 160+56 = 216\n\n\nfloat FoldedRadicalInverse(int n, int base)\n{\n\tfloat inv_base = 1.0 / float(base);\n\tfloat inv_base_i = inv_base;\n\tfloat val = 0.0;\n\tint offset = 0;\n\n\tfor (int i = 0; i < 8; ++i)\n\t{\n\t\tint div = (n + offset) / base;\n\t\tint digit = (n + offset) - div * base;\n\t\tval += float(digit) * inv_base_i;\n\t\tinv_base_i *= inv_base;\n\t\tn /= base;\n\t\toffset++;\n\t}\n\n\treturn val;\n}\n\n// simplified impl due to fabrice neyret <3\nfloat imageFunc(vec2 p, float t)\n{\n\tfloat pi = 3.141592653589793238,\n      offset = sin(t) * 16.,\n          r2 = dot(p, p) * 16.,\n\t    freq = exp2( 1. + floor(r2 * 11.)),\n           a = mod(atan(p.y, p.x) / pi * freq + offset, 2.);\n    \n\treturn (r2 < 1.) ? step(1., a) : 0.;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    const float pixel_r = 1.165;//002412;\n    const float pixel_norm = 1.0 / (3.1415926535897932384626433832795 * pixel_r * pixel_r);\n\tfloat s = 0.0;\n    float w_sum = 0.0;\n\tfor (int i = 0; i < num_samples; ++i)\n\t{\n        float time_aa = (float(i) + 0.5) / float(num_samples) * 0.03333 * 1.0;\n\n        float a = FoldedRadicalInverse(i, 2) * 6.283185307179586476925286766559;\n        float r = sqrt(FoldedRadicalInverse(i, 3)) * pixel_r;\n\t\tvec2 pixel_aa = vec2(cos(a), sin(a)) * r;\n        float pixel_w = max(0.0, pixel_r - r);\n\n\t\tvec2 uv = (fragCoord + pixel_aa - iResolution.xy * 0.5) / (iResolution.x * 1.0);\n\n\t\tfloat t = iTime + time_aa;\n\n\t\ts += imageFunc(uv, t) * pixel_w;\n        w_sum += pixel_w;\n\t}\n\ts *= (1.0 / w_sum); //pixel_norm;// / float(num_samples);\n\ts = pow(s, 1.0 / 2.2);\n\n\tfragColor = vec4(s, s, s, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}