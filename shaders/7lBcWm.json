{
    "Shader": {
        "info": {
            "date": "1649775245",
            "description": "Pushing floats to do more spiral thingies.",
            "flags": 40,
            "hasliked": 0,
            "id": "7lBcWm",
            "likes": 13,
            "name": "Stitched Stars",
            "published": 3,
            "tags": [
                "eulerspirals"
            ],
            "usePreview": 0,
            "username": "eiffie",
            "viewed": 323
        },
        "renderpass": [
            {
                "code": "//stitched stars by eiffie, using emulated doubles still had some drift\n//so I carefully (ok hamfistedly) reduced most of the math using mods\n//to stop precision loss with floats. It has to calculate 7500^3 + a fraction.\n//Of course each point of the star is the same so I could have just done 1/5\n//and rotate 2pi/5 but then where is the challenge?\nvoid mainImage(out vec4 O, in vec2 U){\n  O=sqrt(texture(iChannel0,U/iResolution.xy)*2.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//1498 unique stars made of 7500 stitches, well 4/5ths of 1498 anyway\n#define DIV 1499.\n//50 stitches per frame\n#define PTS 50.\n#define R iResolution\n\nconst float pi2=6.283185;\nfloat rand(vec2 U){return fract(sin(dot(U,vec2(113.,117.)))*412.143);}\nvec4 shad(vec2 U){U/=R.xy;vec2 su=sin(U*5.);return vec4(.8)+vec4(.4,.2,.1,0.)*sin((U.x+U.y*1.6)*5.+pi2*su.x*su.y);}\nvec4 BG(vec2 U){//background texture\n  vec4 c=vec4(0.01,.03,.06,.0)*(sin(mod(U.x,pi2))*sin(mod(U.y,pi2))+1.)*(0.5+0.5*rand(U));\n  return c*shad(U);\n}\nfloat tube(vec2 pa, vec2 ba){return length(pa-ba*clamp(dot(pa,ba)/dot(ba,ba),.25,.75));}\nvec3 cmap(float a){return abs(vec3(sin(a),sin(a+1.),sin(a+1.7)));}\nvoid mainImage(out vec4 O, in vec2 U){\n  vec2 u=floor(U);\n  bool bLogic=(u.y<1. && u.x<3.);u=U;//3 state pixels\n  float iF=max(0.,float(iFrame)-1.);//setup figure, start step\n  float steps=ceil(DIV*5./PTS)*PTS,start=iF*PTS,fig=1.+floor(start/steps);\n  start=mod(start,steps);\n  //L0,L1 mnx,mxx,mny,mxy for centering and scaling, 2 xyxy last positions\n  vec4 L0=texture(iChannel0,vec2(.5)/R.xy);//load logic\n  vec4 L1=texture(iChannel0,vec2(1.5,.5)/R.xy);\n  vec4 L2=texture(iChannel0,vec2(2.5,.5)/R.xy);\n  if(iF==0.){//first frame\n    O=BG(U);L0=vec4(-23,23,-23,23);L1=vec4(0);L2=vec4(0.,R.y*.2,0.,0.);\n  }else if(start==0.){//new figure\n    float s=-.5*R.y/(L1.w-L1.z);\n    L2=vec4((L1.y+L1.x)*s,(L1.w+L1.z)*s,0.,0.);L0=L1;L1=vec4(0);\n    O=((U.x>R.x/2.)&&(mod(fig,5.)!=1.)?texture(iChannel0,U/R.xy-vec2(.5,0.)):BG(U));\n  }else O=texture(iChannel0,U/R.xy);\n  if(mod(fig,5.)>.5){if(U.x>R.x/2.)return;U-=R.xy*vec2(.25,.5);}\n  else U=(U-R.xy*.5)*1.5;\n  float scl=.45*R.x/(L0.w-L0.z),a,b,b2;//scale the star to the screen\n  vec2 oL=L2.xy;//previous point for line drawing\n  for(float i=start;i<start+PTS;i+=1.){//formula: 2*pi*fig/DIV*(i*i*i+i/5)\n    a=mod(i,DIV);  //since this is an angle multiple of 2pi\n    a=mod(mod(i,DIV)*a,DIV);//you can use mod by the divisor to toss big values early\n    a=mod(mod(i,DIV)*a,DIV);b2=a;//save for offscreen calc of next fig center, extents\n    a=mod(fig*a,DIV);b=mod(fig*i,DIV*5.);\n    b=pi2*fract((a+b*.2)/DIV);//now a+b (i*i*i+i/5) are not so far apart\n    //b=pi2*fig*i/DIV*(i*i+.2);//uncomment to see how quickly floats break\n    //b=pi2*fract(i*fract(fig*fract((i*i+.2)/DIV)));//still way off!\n    L2.xy+=vec2(cos(b),sin(b))*scl;//now I want to integrate this sum but so far\n    float d=tube(U-L2.xy,oL-L2.xy);//I can only get a spiral\n    if(!bLogic)O.rgb=max(O.rgb*smoothstep(0.,2.5,d),cmap(pi2*i/DIV)*smoothstep(1.,0.,d)*shad(u).rgb);\n    oL=L2.xy;//save last point\n    if(bLogic){//next fig run offscreen to capture the center and extents\n      b=mod((fig+1.)*i,DIV*5.);\n      a=mod((fig+1.)*b2,DIV);\n      a=pi2*fract((a+b*.2)/DIV);\n      L2.zw+=vec2(cos(a),sin(a));\n      L1.xz=min(L1.xz,L2.zw);\n      L1.yw=max(L1.yw,L2.zw);\n    }\n  }\n  if(bLogic){if(u.x==0.5)O=L0;else if(u.x==1.5)O=L1;else if(u.x==2.5)O=L2;}//save logic\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define bps 4.\n#define pi 3.14159\nint N[16]=int[16](0,5,4,7,7,2,4,0,7,5,4,2,7,5,4,0);\nfloat scale(float note){//throws out dissonant tones \n float n2=mod(note,12.);\n if((n2==1.)||(n2==3.)||(n2==6.)||(n2==8.)||(n2==11.))note=-100.;\n return note;\n}\n// note number to frequency  from https://www.shadertoy.com/view/ldfSW2 \nfloat ntof(int n0){\n float n=scale(float(n0));\n return (n>0.)?440.0 * pow(2.0, (float(n) - 67.0) / 12.0):0.0;\n}\nvec2 rot(vec2 v, float a) {return cos(a)*v+sin(a)*vec2(v.y,-v.x);}\nvec2 I(int n, float t, vec3 p, vec4 e, vec4 d){\n  float bt=t,t2,t3,t4,f=ntof(n);\n  if(f==0.)return vec2(0);\n  t-=t*d.y*sin((d.w*pi+t)*pi*d.z);t3=t*d.x;\n  t2=fract(t*p.y*f);t4=fract(t3*p.y*f);\n  t=fract(t*f);t3=fract(t3*f);\n  float amp=abs(1.+cos(bt*e.z*pi)*e.w)*exp(-bt*e.y)*(1.0-exp(-bt*e.x))*min(1.,100.-bt*100.);\n  return amp*rot(vec2(sin(pow(t,p.x)*pi*2.+pi*2.*p.z*sin(pow(t2,p.x)*pi*2.)),\n    sin(pow(t3,p.x)*pi*2.+pi*2.*p.z*sin(pow(t4,p.x)*pi*2.))),float(n)+bt*pi*2.);\n}\nint pat(float bt){return int(bt)%(mod(bt,32.)<16.?8:16);}\nvec2 mainSound(int samp, float time){\n  float tim=time*bps;if(tim>128. && tim<256.)tim=tim-128.;\n  float bt=floor(tim),t=fract(tim);t+=0.01*sin(pi*pow(t,15.));\n  int n64=N[pat(bt/64.)]-(mod(bt/128.,2.)<1.?0:7);\n  int n8=n64+N[pat(bt/8.)],n1=n8+N[pat(bt)],n2=n8+N[pat(bt/2.)];\n  float fo=pow(1.-t,20.0);\n  vec2 v=I(n1+48,t,vec3(1.-fo*.5,1.5,fo),vec4(10.,1.0,6.,t*.8),vec4(1.014,0.005,1.,.5))*.5;\n  t=fract(tim/2.);\n  fo=pow(1.-t,20.0);\n  v+=I(n2+48,t,vec3(1.-fo*.5,1.5,fo),vec4(10.,1.,12.,t*.8),vec4(1.014,0.005,1.,.5));\n  v+=I(n2+54,t,vec3(1.-fo*.5,1.5,fo),vec4(10.,3.,18.1,t*.8),vec4(1.008,0.0051,1.,.5));\n  t=fract(tim/8.);\n  fo=pow(1.-t,20.0);\n  v+=I(n8+48,t,vec3(1.-fo*.5,.5,fo),vec4(10.,1.0,24.,t*.4),vec4(1.004,0.005,1.,.5));\n  v+=.5*I(n8+63,t,vec3(1.-fo*.5,.5,fo),vec4(10.,1.0,24.,t*.8),vec4(1.014,0.005,1.,.5));\n  return v*.05;\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}