{
    "Shader": {
        "info": {
            "date": "1455468124",
            "description": "a modification of verminator's SDF stuff to use a color wheel for the plane.",
            "flags": 1,
            "hasliked": 0,
            "id": "MsV3RV",
            "likes": 14,
            "name": "Signed distance field blobbies 2",
            "published": 3,
            "tags": [
                "raymarching",
                "sdf"
            ],
            "usePreview": 0,
            "username": "jherico",
            "viewed": 1137
        },
        "renderpass": [
            {
                "code": "const int renderDepth = 400;\nconst bool showRenderDepth = false;\n\nconst vec3 background = vec3(0.2, 0.2, 0.8);\nconst vec3 white = vec3(0.8, 0.8, 0.8);\nconst vec3 black = vec3(0, 0, 0);\nconst vec3 red = vec3(0.8, 0.2, 0.2);\nconst vec3 green = vec3(0.2, 0.8, 0.2);\nconst vec3 lightPos = vec3(0, 10, 10);\n\nconst float a = 1.0;\nconst float b = 3.0;\nvec3 forces[3];\n\n\nvec3 getRayDir(vec3 camDir, vec2 fragCoord) {\n  vec3 yAxis = vec3(0, 1, 0);\n  vec3 xAxis = normalize(cross(camDir, yAxis));\n  vec2 q = fragCoord / iResolution.xy;\n  vec2 p = 2.0 * q - 1.0;\n  p.x *= iResolution.x / iResolution.y;\n  return normalize(p.x * xAxis + p.y * yAxis + 5.0 * camDir);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)) - 0.1;\n}\n\nfloat sdPlane(vec3 p, vec4 n) {\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat getMetaball(vec3 p, vec3 v) {\n  float r = length(p - v);\n  if (r < b / 3.0) {\n    return a * (1.0 - 3.0 * r * r / b * b);\n  } else if (r < b) {\n    return (3.0 * a / 2.0) * (1.0 - r / b) * (1.0 - r / b);\n  } else {\n    return 0.0;\n  }\n}\n\nfloat sdImplicitSurface(vec3 p) {\n  float mb = 0.0;\n  float minDist = 10000.0;\n  for (int i = 0; i < 3; i++) {\n    mb += getMetaball(p, forces[i]);\n    minDist = min(minDist, length(p - forces[i]));\n  }\n  if (minDist > b) {\n    return max (minDist - b, b - 1.2679529);\n  } else if (mb == 0.0) {\n    return b - 1.2679529;  // 1.2679529 is the x-intercept of the metaball expression - 0.5.\n  } else {\n    return b - sqrt(6.0 * mb) - 1.2679529;\n  }\n}\n\nfloat getSdf(vec3 p) {\n  float f = sdImplicitSurface(p);\n  for (int i = 0; i < 6; i++) {\n    float t = float(i) + iTime;\n    f = min(f, sdBox(\n        p - vec3(\n            3.0 + 3.0 * cos(t * 3.141592 / 3.0), \n            0, \n            3.0 * sin(t * 3.141592 / 3.0)),\n        vec3(0.5)));\n  }\n  return f;\n}\n\nfloat getSdfWithPlane(vec3 p) {\n  return min(getSdf(p), sdPlane(p, vec4(0,1,0,1)));\n}\n\nfloat diffuse(vec3 point,vec3 normal) {\n  return clamp(dot(normal, normalize(lightPos - point)), 0.0, 1.0);\n}\n\nfloat getShadow(vec3 pt) {\n  vec3 lightDir = normalize(lightPos - pt);\n  float kd = 1.0;\n  int step = 0;\n  float t = 0.1;\n\n  for (int step = 0; step < renderDepth; step++) {\n    float d = getSdf(pt + t * lightDir);\n    if (d < 0.001) {\n      kd = 0.0;\n    } else {\n      kd = min(kd, 16.0 * d / t);\n    }\n    t += d;\n    if (t > length(lightPos - pt) || step >= renderDepth || kd < 0.001) {\n      break;\n    }\n  }\n  return kd;\n}\n\nvec3 getGradient(vec3 pt) {\n  return vec3(\n    getSdfWithPlane(vec3(pt.x + 0.0001, pt.y, pt.z)) - getSdfWithPlane(vec3(pt.x - 0.0001, pt.y, pt.z)),\n    getSdfWithPlane(vec3(pt.x, pt.y + 0.0001, pt.z)) - getSdfWithPlane(vec3(pt.x, pt.y - 0.0001, pt.z)),\n    getSdfWithPlane(vec3(pt.x, pt.y, pt.z + 0.0001)) - getSdfWithPlane(vec3(pt.x, pt.y, pt.z - 0.0001)));\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 colorWheel(float angle) {\n    return hsv2rgb(vec3(angle, 1.0, 0.8));\n}\n            \nvec3 getDistanceColor(vec3 pt) {\n  return colorWheel(getSdf(pt) / 2.0);\n}\n\nvec3 illuminate(vec3 pt) {\n  vec3 color = (abs(pt.y + 1.0) < 0.001) ? getDistanceColor(pt) : white;\n  vec3 gradient = getGradient(pt);\n  float diff = diffuse(pt.xyz, normalize(gradient));\n  return (0.25 + diff * getShadow(pt))  * color;\n}\n\nvec3 raymarch(vec3 rayorig, vec3 raydir) {\n  vec3 pos = rayorig;\n  float d = getSdfWithPlane(pos);\n  int work = 0;\n\n  for (int step = 0; step < renderDepth; step++) {\n    work++;\n    pos = pos + raydir * d;\n    d = getSdfWithPlane(pos);\n    if (abs(d) < 0.001) {\n      break;\n    }\n  }\n\n  return showRenderDepth\n    ? vec3(float(work) / float(renderDepth))\n    : (abs(d) < 0.001) \n      ? illuminate(pos)\n      : background;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  forces[0] = vec3(-3, 0, 0);\n  forces[1] = vec3(3.0 * sin(iTime), 4.0 * abs(cos(iTime)), 0.0);\n  forces[2] = vec3(3, 0, 0);\n\n  vec3 camPos = 20.0 * vec3(cos(iTime / 10.0), 0.5, sin(iTime / 10.0));\n  vec3 camDir = normalize(-camPos);\n  fragColor = vec4(raymarch(camPos, getRayDir(camDir, fragCoord)), 1.0);\n}\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOrigin, in vec3 rayDirection ) {\n  forces[0] = vec3(-3, 0, 0);\n  forces[1] = vec3(3.0 * sin(iTime), 4.0 * abs(cos(iTime)), 0.0);\n  forces[2] = vec3(3, 0, 0);\n  fragColor = vec4(raymarch(rayOrigin * 10.0 + vec3(0.0, 3.0, 6.0), rayDirection), 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}