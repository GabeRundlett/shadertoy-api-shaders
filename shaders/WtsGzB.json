{
    "Shader": {
        "info": {
            "date": "1571749923",
            "description": "Procedurally generated alien voxel landscape, based on iq's voxel rendering. Uses Brian Sharpe's fast Value3D noise algorithm.\n\nWEBSITE: bradyinstead.com\nTWITTER: twitter.com/BradyInstead\nINSTA: instagram.com/bradyinstead/",
            "flags": 0,
            "hasliked": 0,
            "id": "WtsGzB",
            "likes": 75,
            "name": "Alien Voxel Landscape",
            "published": 3,
            "tags": [
                "voxel"
            ],
            "usePreview": 0,
            "username": "BradyInstead",
            "viewed": 4692
        },
        "renderpass": [
            {
                "code": "//------------------------------------------------------------------------\n// Alien Voxel Landscape\n// by @BradyInstead\n//------------------------------------------------------------------------\n\n// based on https://iquilezles.org/articles/voxellines\n\n//------------------------------------------------------------------------\n// Camera\n//------------------------------------------------------------------------\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time)\n{\n    float zoom = 50.;\n    vec3 initPos = vec3(zoom);\n\tcamPos = initPos;\n    camPos.z += iTime*16.; // movement\n    camTar = camPos-initPos;\n}\n\n\n//------------------------------------------------------------------------\n// Background \n//------------------------------------------------------------------------\n\nvec3 doBackground( void )\n{\n    return vec3( 0.);\n}\n\n\n//------------------------------------------------------------------------\n// Shaping \n//------------------------------------------------------------------------\n\n// p = positions\n// h = dimensions of elongation\nvec4 opElongate( in vec3 p, in vec3 h )\n{\n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n\treturn mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n\n//------------------------------------------------------------------------\n// Modelling \n//------------------------------------------------------------------------\n\nfloat noise( vec3 P )\n{\n    //  https://github.com/BrianSharpe/Wombat/blob/master/Value3D.glsl\n\n    // establish our grid cell and unit position\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n    vec3 Pf_min1 = Pf - 1.0;\n\n    // clamp the domain\n    Pi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\n    vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\n\n    // calculate the hash\n    vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\n    Pt *= Pt;\n    Pt = Pt.xzxz * Pt.yyww;\n    vec2 hash_mod = vec2( 1.0 / ( 635.298681 + vec2( Pi.z, Pi_inc1.z ) * 48.500388 ) );\n    vec4 hash_lowz = fract( Pt * hash_mod.xxxx );\n    vec4 hash_highz = fract( Pt * hash_mod.yyyy );\n\n    //\tblend the results and return\n    vec3 blend = Pf * Pf * Pf * (Pf * (Pf * 6.0 - 15.0) + 10.0);\n    vec4 res0 = mix( hash_lowz, hash_highz, blend.z );\n    vec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n    return dot( res0, blend2.zxzx * blend2.wwyy );\n}\n\nfloat mapTerrain( vec3 p )\n{\n    p*=.35;\n    p.y /= 2.;\n\treturn noise(p);\n}\n\nfloat map(in vec3 p)\n{\n\tfloat terrain = mapTerrain( p ) + 0.12*p.y;\n\treturn step( terrain, 0.95 );\n}\n\n\n//------------------------------------------------------------------------\n// Material\n//------------------------------------------------------------------------\n\nvec3 doMaterial( vec3 pos, vec3 vos )\n{\n    float h = vos.y/8.;\n    \n    vec3 primary = vec3(.9, .1, .2) ;\n    vec3 secondary = vec3(.1, .5, 1.);\n    \n    return mix(primary, secondary, h)*h;\n}\n\nvec3 saturation(vec3 rgb, float adjustment)\n{\n    // Algorithm from Chapter 16 of OpenGL Shading Language\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    vec3 intensity = vec3(dot(rgb, W));\n    return mix(intensity, rgb, adjustment);\n}\n\nfloat maxcomp( in vec4 v )\n{\n    return max( max(v.x,v.y), max(v.z,v.w) );\n}\n\nfloat isEdge( in vec2 uv, vec4 va, vec4 vb, vec4 vc, vec4 vd )\n{\n    vec2 st = 1.0 - uv;\n\n    // edges\n    vec4 wb = smoothstep( 0.7, 0.99, vec4(uv.x,\n                                           st.x,\n                                           uv.y,\n                                           st.y) ) * ( 1.0 - va + va*vc );\n    // corners\n    vec4 wc = smoothstep( 0.7, 0.99, vec4(uv.x*uv.y,\n                                           st.x*uv.y,\n                                           st.x*st.y,\n                                           uv.x*st.y) ) * ( 1.0 - vb + vd*vb );\n    return 1.0 - maxcomp( max(wb,wc) );\n}\n\nfloat calcOcc( in vec2 uv, vec4 va, vec4 vb, vec4 vc, vec4 vd )\n{\n    vec2 st = 1.0 - uv;\n\n    // edges\n    vec4 wa = vec4( uv.x, st.x, uv.y, st.y ) * vc;\n\n    // corners\n    vec4 wb = vec4(uv.x*uv.y,\n                   st.x*uv.y,\n                   st.x*st.y,\n                   uv.x*st.y)*vd*(1.0-vc.xzyw)*(1.0-vc.zywx);\n    \n    return wa.x + wa.y + wa.z + wa.w +\n           wb.x + wb.y + wb.z + wb.w;\n}\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal , vec3 vos, vec3 dir)\n{\n    vec3 uvw = pos - vos;\n    \n    vec3 v1  = vos + nor + dir.yzx;\n\tvec3 v2  = vos + nor - dir.yzx;\n\tvec3 v3  = vos + nor + dir.zxy;\n\tvec3 v4  = vos + nor - dir.zxy;\n\tvec3 v5  = vos + nor + dir.yzx + dir.zxy;\n    vec3 v6  = vos + nor - dir.yzx + dir.zxy;\n\tvec3 v7  = vos + nor - dir.yzx - dir.zxy;\n\tvec3 v8  = vos + nor + dir.yzx - dir.zxy;\n\tvec3 v9  = vos + dir.yzx;\n\tvec3 v10 = vos - dir.yzx;\n\tvec3 v11 = vos + dir.zxy;\n\tvec3 v12 = vos - dir.zxy;\n \tvec3 v13 = vos + dir.yzx + dir.zxy; \n\tvec3 v14 = vos - dir.yzx + dir.zxy;\n\tvec3 v15 = vos - dir.yzx - dir.zxy;\n\tvec3 v16 = vos + dir.yzx - dir.zxy;\n\n\tvec4 vc = vec4( map(v1),  map(v2),  map(v3),  map(v4)  );\n\tvec4 vd = vec4( map(v5),  map(v6),  map(v7),  map(v8)  );\n\tvec4 va = vec4( map(v9),  map(v10), map(v11), map(v12) );\n\tvec4 vb = vec4( map(v13), map(v14), map(v15), map(v16) );\n\t\t\n\tvec2 uv = vec2( dot(dir.yzx, uvw), dot(dir.zxy, uvw) );\n    \n    // ambient occlusion\n    float occ = 1.0;\n    occ = calcOcc( uv, va, vb, vc, vd );\n    float ocAm = 3.0;\n    occ = 1.0 - occ/ocAm;\n    occ = pow(occ, 5.);\n    \n    // fake lighting\n    vec3 norC = abs(nor);\n    float sum = min(1.0, norC.g + norC.r*.35 + norC.b*.2 + .05);\n    vec3 col = mal*sum*isEdge(uv, va, vb, vc, vd);\n    \n    col = mix(col.rgb*occ, vec3(col.rg*occ, col.b), .2);\n    \n    return col;\n}\n\n\n//------------------------------------------------------------------------\n// Raymarching\n//------------------------------------------------------------------------\n\nfloat calcIntersection( in vec3 ro, in vec3 rd, out vec3 oVos, out vec3 oDir, out int mat )\n{\n\tvec3 pos = floor(ro);\n\tvec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd);\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\n\t\n\tfloat res = -1.0;\n\tvec3 mm = vec3(0.0);\n\tfor( int i=0; i<200; i++ ) \n\t{\n\t\tif( map(pos)>0.5 ) { res=1.0; break; }\n\t\tmm = step(dis.xyz, dis.yzx) * step(dis.xyz, dis.zxy);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n\n\tvec3 nor = -mm*rs;\n\tvec3 vos = pos;\n\t\n    // intersect the cube\t\n\tvec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\n\tfloat t = max ( mini.x, max ( mini.y, mini.z ) );\n\t\n\toDir = mm;\n\toVos = vos;\n\n\treturn t*res;\n}\n\nvec3 getColor(int r)\n{\n    switch(r)\n    {\n        // METAL\n        case 0:\n        \treturn vec3(86., 48., 107.) \t/256.;\n        case 1:\n        \treturn vec3(98., 67., 198.) \t/256.;\n        case 2:\n        \treturn vec3(102., 165., 250.)\t/256.;\n        case 3:\n        \treturn vec3(186., 250., 236.)\t/256.;\n        \n        // LAVA\n        /*\n        case 0:\n        \treturn vec3(45., 19., 44.) \t/256.;\n        case 1:\n        \treturn vec3(128., 19., 54.) \t/256.;\n        case 2:\n        \treturn vec3(199., 44., 65.)\t/256.;\n        case 3:\n        \treturn vec3(238., 69., 64.)\t/256.;*/\n        \n        /*\n        // CHROME\n        case 0:\n        \treturn vec3(80., 38., 167.) \t/256.;\n        case 1:\n        \treturn vec3(141., 68., 139.) \t/256.;\n        case 2:\n        \treturn vec3(204., 106., 135.)\t/256.;\n        case 3:\n        \treturn vec3(236., 205., 143.)\t/256.;*/\n    }\n    \n    return vec3(0.);\n}\n\n//------------------------------------------------------------------------\n// Main\n//------------------------------------------------------------------------\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    p.x /= 1.25;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime);\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( vec3(p.xy,1.0) ); // lens length\n    rd.y -= 1.0;\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n\t// raymarch\n    vec3 vos, dir;\n    int mat;\n    float t = calcIntersection( ro, rd, vos, dir, mat );\n    if( t>0.0 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = -dir*sign(rd);\n\n        // materials\n        vec3 mal = doMaterial( pos, vos );\n\n        col = doLighting( pos, nor, rd, t, mal, vos, dir);\n\t}\n\n    \n    col *= 1.5;\n    col -= .03;\n    \n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.5) );\n    \n    // saturation\n\t//col = saturation(col, 2.0);   \n    //col *= exp(-.01*t*t);\n    \n    // toon\n    col *= vec3(6.);\n    float colFract = abs(sin(fract(col.r) * 3.14 * 1.0));\n    col = floor(col);\n    \n    \n    // pallete\n    col = mix(getColor(int(col.r-1.)), getColor(int(col.r)), colFract);\n    \n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}