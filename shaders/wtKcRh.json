{
    "Shader": {
        "info": {
            "date": "1610936703",
            "description": "fullscreen recommended.",
            "flags": 40,
            "hasliked": 0,
            "id": "wtKcRh",
            "likes": 13,
            "name": "[â™ª]Tetrascape",
            "published": 3,
            "tags": [
                "raymarching",
                "music"
            ],
            "usePreview": 0,
            "username": "Catzpaw",
            "viewed": 538
        },
        "renderpass": [
            {
                "code": "//---Tetrascape\n// by Catzpaw 2021\n\n//Image:color\n\nvec3 hsv(float h,float s,float v){\n    return ((clamp(abs(fract(h+vec3(0.,.666,.333))*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;\n}\nvec3 tx1(vec3 rd,float b){\n    float a=bit(rd*5e2),r=pow(fract(a+floor(b)*1e-2),10.);\n    return hsv(iTime*.1+a*75.,step(.8,r)*.5,step(.1,r)*.25+step(.7,r)*.75);\n}\nvec3 bg(vec3 rd,float pr,float b){\n    float e=pr;\n    vec3 c=tx1(rd,b);rd.xz*=rot(e);c+=tx1(rd,b);\n    rd.yz*=rot(e);c+=tx1(rd,b);rd.xz*=rot(-e);c+=tx1(rd,b);\n    return c*.25;\n}\nvec3 vol(vec3 ro,vec3 rd,float d){\n    float t=0.,v=0.;\n    vec3 c=vec3(0);\n    float it=d==1.?140.:d*80.;\n    for(float i=0.;i<it;i+=20.){\n        v=bit(ro+rd*i);\n        c+=hsv(length(ro)+i*.133,.8,v);\n    }\n    return c*.2;\n}\nvec3 depth(vec2 p,float h,float d){\n    return d==1.?vec3(.3):hsv(h,.3,1.-d);\n}\nconst uint[32] mseq=uint[](\n    0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00300000u,0x03003000u,    \n    0x33333333u,0x33333333u,0x33333333u,0x00003333u,0x00003333u,0x00000000u,0x00000000u,0x20303333u,\n    0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22322222u,0x03223222u,    \n    0x33333333u,0x30303333u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x11110000u);\nint getmode(float b){\n    int p=int(b)-2,n=p>>3,s=(p&7)*4;\n    return b<2.?1:n>31?0:int((mseq[n]>>s)&15u);\n}\nvoid mainImage(out vec4 col,in vec2 fc){\n    vec2 uv=fc/iResolution.xy,xy=(fc-.5*iResolution.xy)/iResolution.y,u=vec2(0,1)*rot(-iTime*.5);\n    vec4 d=texture(iChannel0,uv);\n    float pr=1./(ZOOM*iResolution.x),t=(iTime+ADJUST)*SPEED,b=(iTime+ADJUST)*BPM/60.;\n    int mode=getmode(b);\n    vec3 c=vec3(0),ro=getro(vec3(90),t),rd=getrd(normalize(vec3(xy,ZOOM)),t),p;\n    c=mode!=1?c:bg(rd,pr,b)*.5;\n    c=mode!=2?c:vol(ro,rd,d.a);\n    c=mode!=3?c:depth(xy,d.r,d.a);\n    c=mode!=0?c:mix(hsv(d.r,1.,d.b)+d.g,bg(rd,pr,b),d.a*.5)+hsv(d.r,.8,d.g*4.);\n    col=vec4(c,1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//---Tetrascape\n// by Catzpaw 2021\n\n//Buffer A:raymarching\n\n#define ITER 280\n#define NEAR 0.2\n#define FAR 160.\n\nfloat map(vec3 p,float beat){\n    float b=pow(fract(bit(p)*(7.+floor(beat*.5)*2.33e-3)),30.),v=.5-abs(b-.5);\n    return v<.44?1.1:length(fract(p)-.5)-v*(.6+clamp(abs(sin(beat*pi)*2.),0.,1.)*.35);\n}\nfloat trace(vec3 ro,vec3 rd,float pr,out vec3 p){\n    float beat=(iTime+ADJUST)*BPM/60.,t=NEAR;\n    for(int i=ZERO;i<ITER;i++){float d=map(p=ro+rd*t,beat);\n        if(abs(d)<pr||t>FAR)break;t+=(step(d,.5)*d+d)*(.5+t*.25/FAR);}\n    return min(t,FAR);\n}\nvoid mainImage(out vec4 col,in vec2 fc){\n    vec2 uv=(fc-.5*iResolution.xy)/iResolution.y;\n    float pr=6./(ZOOM*iResolution.y),t=(iTime+ADJUST)*SPEED;\n    vec3 ro=getro(vec3(90),t),rd=getrd(normalize(vec3(uv,ZOOM)),t),p;\n    float d=trace(ro,rd,pr,p);\n    vec3 n=normalize(fract(p)-.5);rd.yz*=rot(-.0);\n    float h=bit(p)+bit(p*80.)*.6,v=1.3-d/FAR,l=dot(rd,n)+1.,s=pow(clamp(dot(-rd,n),0.,1.),16.);\n    col=d>=FAR?vec4(0,0,0,1):vec4(h,v*s,v*l,d/FAR);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//---Tetrascape\n// by Catzpaw 2021\n\n//Common:settings & snippets\n\n#define BPM 135.0\n#define SPEED 0.15\n\n#define ADJUST 0.0\n\n#define ZOOM .7\n#define ZERO min(0,iFrame)\nconst float pi=acos(-1.);\nconst float r7=sqrt(7.);\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,s,-s,c);}\nfloat bit(vec3 p){ivec3 i=ivec3(p);return fract(float(i.x^i.y^i.z)*r7);}\nvec3 getro(vec3 ro,float t){ro.xz*=rot(t*.43);ro.xy*=rot(t*.32);ro.yz*=rot(t*.21);return ro;}\nvec3 getrd(vec3 rd,float t){rd.xz*=rot(t*.10);rd.xy*=rot(t*.14);rd.yz*=rot(t*.13);return rd;}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//---Tetrascape\n// by Catzpaw 2021\n\n//Sound:scale sequencer 3\n\n//--- Scale Sequencer 3 by Catzpaw 2020\n//https://www.shadertoy.com/view/ts3fDN\n\n//================================================================================\n// SETUP\n//--------------------------------------------------------------------------------\nconst float base =440.;\t//master tuning (Hz)\nconst float bpm  =BPM;\t//beats per minute\nconst float steps=240.;\t//steps per measure (default:240steps)\nconst float start=2.;   //start count (beats)\nconst float fade =10.;  //fade out time (default:10sec)\nconst float sec  =180.; //performance time (includes fade out time and start count)\n\nconst float gateSeed=303.; //random seed for gate generator;\nconst float noteSeed=278.; //random seed for note generator;\n\n//SCALE\nint key=2; //0:C 1:C+ 2:D 3:D+ 4:E 5:F 6:F+ ... 11:B\nconst uint[4] scl=uint[](0xca875320u,0xcb975420u,0xcb875320u,0xcb975320u); //minor,major,harmonic,melodic\n\n//================================================================================\n// SEQUENCE DATA\n//--------------------------------------------------------------------------------\n//CHORD SEQUENCE (version 3)\nconst int chordlen=64;const uint chordseq[chordlen]=uint[](\n\t0x01u,0x01u,0x01u,0x01u,0x01u,0x01u,0x01u,0x01u,0x01u,0x01u,0x01u,0x01u,0x01u,0x01u,0x01u,0x01u,\n\t0x00000001u,0x0c000102u,0x000000c3u,0x0c00c344u,0x00000045u,0x00000044u,0x000000c3u,0x00000002u,\n\t0x00000001u,0x0c000102u,0x000000c3u,0x0c00c344u,0x00000045u,0x00000044u,0x000000c3u,0x00000002u,\n\t0x00000001u,0x0c000102u,0x000000c3u,0x0c00c344u,0x00000045u,0x00000044u,0x000000c3u,0x00000002u,\n\t0x00000001u,0x0c000102u,0x000000c3u,0x0c00c344u,0x00000045u,0x00000044u,0x000000c3u,0x00000002u,\n\t0x01u,0x01u,0x01u,0x01u,0x01u,0x01u,0x01u,0x01u,0x01u,0x01u,0x01u,0x01u,0x01u,0x01u,0x01u,0x01u);\n\n//PATTERN (version 3)\nconst uint[32] pat=uint[](\n    0x0f000000u,0x00000000u,0x08008001u,0x070af101u,  //00-03 mute(melo),mute(perc),chord,chord\n    0x36605713u,0x46746589u,0x56183614u,0x360e1510u,  //04-07 melody\n    0x45043102u,0x47476291u,0x54973175u,0x36390710u,  //08-0B melody\n    0x00u,0x00u,0x00u,0x00u,0x00u,0x00u,0x00u,0x00u,  //0C-13 \n    0x70080868u,0x70086865u,0x18164656u,0x18164656u,  //14-17 accompaniment,bass\n    0x3238e232u,0x3138e132u,0x61382132u,0x9d1ce136u,  //18-1B sd+hh\n    0x01010101u,0x01c10181u,0x11c14581u,0x55d10591u); //1C-1F bd+fx\n\n//PATTERN SEQUENCE (version 3)\nconst int len1=64;const uint[len1] seq1=uint[]( //snare+hihat 18 19 1a 1b\n    0x00000001u,0x00000001u,0x00000001u,0x08001019u,0x00000018u,0x00000018u,0x00000019u,0x0000001bu,\n    0x00000018u,0x00000018u,0x00000018u,0x08018019u,0x08018001u,0x00000001u,0x08018001u,0x0800101bu,\n    0x00000001u,0x00000001u,0x00000001u,0x00000001u,0x00000001u,0x00000001u,0x00000001u,0x00000001u,\n    0x00000001u,0x00000001u,0x00000001u,0x00000001u,0x00000001u,0x00000001u,0x00000001u,0x0000001bu,    \n    0x00000018u,0x0000001au,0x00000018u,0x08018019u,0x00000018u,0x0000001au,0x00000019u,0x0000001bu,\n    0x00000018u,0x0000001au,0x00000018u,0x08018019u,0x00000018u,0x0000001au,0x00000019u,0x0000001bu,    \n    0x00000018u,0x00000018u,0x00000018u,0x08018019u,0x00000018u,0x00000018u,0x00000019u,0x0000001bu,\n    0x00000018u,0x00000018u,0x00000018u,0x08018019u,0x00000018u,0x00000018u,0x00000019u,0x0000001bu);\n\nconst int len2=64;const uint[len2] seq2=uint[]( //bassdrum+conga 1c 1d 1e 1f\n    0x00000001u,0x00000001u,0x0000001cu,0x1c01c01fu,0x0000001cu,0x0000001cu,0x0000001cu,0x0801c01fu,\n    0x0000001cu,0x0000001cu,0x0000001cu,0x0801c01du,0x0000001cu,0x0000001cu,0x00000001u,0x1c00101fu,\n    0x0101c001u,0x00000001u,0x00000001u,0x0800101du,0x0101c001u,0x00000001u,0x0101c001u,0x1c00101fu,\n    0x0000001cu,0x0000001cu,0x0000001cu,0x0801c01du,0x0000001cu,0x0000001cu,0x0000001cu,0x1c01c01fu,\n    0x0000001du,0x0000001eu,0x0000001du,0x0801d01fu,0x0000001du,0x0000001du,0x0000001eu,0x0801f01fu,\n    0x0000001du,0x0000001eu,0x0000001du,0x0801d01fu,0x0000001du,0x0000001du,0x0000001eu,0x1801f01fu,\n    0x0000001cu,0x0000001cu,0x0000001cu,0x0801c01du,0x0000001cu,0x0000001cu,0x0000001cu,0x0801c01fu,\n    0x0000001cu,0x0000001cu,0x0000001cu,0x0801c01du,0x0000001cu,0x0000001cu,0x0000001cu,0x0801c01fu);\n\nconst int len3=64;const uint[len3] seq3=uint[]( //bass 616\n    0x00000600u,0x00000600u,0x00000600u,0x00000600u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,\n    0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,\n    0x00000600u,0x00000600u,0x00000600u,0x0c000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,\n    0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,\n    0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,\n    0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,\n    0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,\n    0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u);\n\nconst int len4=64;const uint[len4] seq4=uint[]( //chord 003 002\n    0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,\n    0x04000003u,0x00000000u,0x08000003u,0x00000000u,0x06000003u,0x0c000003u,0x00000000u,0x00000000u,\n    0x00000003u,0x00000003u,0x00000003u,0x00000003u,0x00000003u,0x00000003u,0x00000003u,0x00000003u,\n    0x00000003u,0x00000003u,0x00000003u,0x00000003u,0x00000003u,0x00000003u,0x00000003u,0x00000003u,\n    0x00000002u,0x00000002u,0x00000002u,0x00000002u,0x00000002u,0x00000002u,0x00000002u,0x00000002u,\n    0x00000002u,0x00000002u,0x00000002u,0x00000002u,0x00000002u,0x00000002u,0x00000002u,0x00000002u,\n    0x00000002u,0x00000002u,0x00000002u,0x00000002u,0x00000003u,0x04000003u,0x08000003u,0x0c000003u,\n    0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u);\n\nconst int len5=64;const uint[len5] seq5=uint[]( //accompaniment 814\n    0x00000814u,0x00000814u,0x00000814u,0x00000814u,0x00000814u,0x00000814u,0x00000814u,0x00000814u,\n    0x00000814u,0x00000814u,0x00000814u,0x00000814u,0x00000814u,0x04000814u,0x08000814u,0x0c000814u,\n    0x00000800u,0x00000800u,0x00000800u,0x00000800u,0x00000800u,0x00000800u,0x00000800u,0x00000800u,\n    0x00000800u,0x00000800u,0x00000800u,0x00000800u,0x00000800u,0x00000800u,0x00000800u,0x00000800u,\n    0x00000814u,0x00000814u,0x00000814u,0x00000814u,0x00000814u,0x00000814u,0x00000814u,0x00000814u,\n    0x00000814u,0x00000814u,0x00000814u,0x00000814u,0x00000814u,0x00000814u,0x00000814u,0x00000814u,\n    0x00000814u,0x00000814u,0x00000814u,0x00000814u,0x00000814u,0x00000814u,0x00000814u,0x00000814u,\n    0x00000814u,0x00000814u,0x00000814u,0x00000814u,0x00000814u,0x00000814u,0x00000814u,0x00000814u);\n\nconst int len6=64;const uint[len6] seq6=uint[]( //melody 004-00b\n    0x00u,0x00u,0x00u,0x00u,0x00u,0x00u,0x00u,0x00u,0x00u,0x00u,0x00u,0x00u,0x00u,0x00u,0x00u,0x00u,\n    0x04u,0x05u,0x06u,0x07u,0x08u,0x09u,0x0au,0x0bu,0x04u,0x05u,0x06u,0x07u,0x08u,0x09u,0x0au,0x0bu,\n    0x04u,0x05u,0x06u,0x07u,0x08u,0x09u,0x0au,0x0bu,0x04u,0x05u,0x06u,0x07u,0x08u,0x09u,0x0au,0x0bu,\n    0x08000004u,0x08000005u,0x08000006u,0x08000007u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,\n    0x00u,0x00u,0x00u,0x00u,0x00u,0x00u,0x00u,0x00u);\n\n\n//================================================================================\n// INSTRUMENTS & EFFECTS\n//--------------------------------------------------------------------------------\n//AMP\n//  vec3 p( drive, pressure, volume)\nvec2 amp(vec2 i,vec3 p){return clamp(sign(i)*pow(abs(i*p.x)*.01,vec2(1./p.y))*100.,-1.,1.)*p.z;}\n\n//FREQUENCY FROM MIDI NOTE NUMBER\nconst float i12=1./12.;\nfloat freq(float n){return pow(2.,(n-69.)*i12)*base;}\n\n//ENVELOPE\nfloat env_d(float x,float d){return max(0.,1.-x/max(d,1e-4));}\n\n//NES SOUND GENERATORS(without DPCM)\nfloat osc_duty(float x,float d){return fract(x)<d?1.:-1.;}\n//float osc_tri4(float x){return abs(floor(fract(x)*15.9999)/7.5-1.);}\nconst float nc=1789772.5;const float[16] nt=float[](\n    nc/2.,nc/4.,nc/8.,nc/16.,nc/32.,nc/48.,nc/64.,nc/80.,nc/101.,\n    nc/127.,nc/190.,nc/254.,nc/381.,nc/508.,nc/1017.,nc/2034.);\nfloat osc_nesnoise(float x,int i){return fract(sin(floor(x*nt[i])*179.2)*204.8);}\n\n//WAVETABLE OSC(namco C30/N163)\nconst int wtsamples=24;\nconst float wtlen=float(wtsamples);\nconst uint[wtsamples] wt=uint[](\n    0x000bb8bau,0x100de7fdu,0x203efdefu,0x303ff7dfu,0x4020efedu,0x5020b7dau,0x6a60af97u,0x7a6f9735u,\n    0x8a0e9d04u,0x9a0d9734u,0xaa3b9a75u,0xba398786u,0x45c67879u,0x55c4658au,0x65f268cbu,0x75f162fbu,\n    0x859068cau,0x959f5068u,0xafdf4825u,0xbfdf1012u,0xcfc00820u,0xdfc10210u,0xeff21802u,0xfff44745u);\nconst float i15=1./15.;\nfloat osc_c30(float x,int i){return(float((wt[int(mod(x*wtlen,wtlen))]>>(i*4))&15u)*i15-.5);}\n\n//CHIPTUNE INSTRUMENTS (freq,time)\nconst float detune =.0025;\nvec2 dutybass(float f,float x){return vec2(osc_duty(f*(.5+detune),.5),osc_duty(f*(.5-detune),.5))*env_d(x,.5);}\nvec2 c30chord(float f,float x){return vec2(osc_c30(f*(1.-detune),7),osc_c30(f*(1.+detune),7));}\nvec2 c30bell(float f,float x){return vec2(osc_c30(f*(1.-detune),1),osc_c30(f*(1.+detune),1))*env_d(x,.6);}\n\n//CHIPTUNE PERCUSSION (time)\n//float nessd(float x){return osc_nesnoise(x,11)*env_d(x,.25);}\nfloat neshh(float x,float d){return osc_nesnoise(x,0)*env_d(x,d);}\nfloat nesbd(float x){return osc_duty(3./(x*.5+.1),.5)*env_d(x,.1);}\n\n//LPF\n#define LPFI 96\n#define LPF(fn) float b=0.,o=0.;c+=1e-10;n=freq(n);for(int i=0;i<LPFI;i++){float f=n*(x+float(i)/iSampleRate);b+=c*((fn)+q*(b-o)/(1.-c)-o);o+=c*(b-o);}return o;\n\n//SAW WITH LPF (note,time,cutoff,lpq)\nfloat lpfsaw(float n,float x,float c,float q){LPF(mod(f,2.)-1.)}\n\n//C30 WITH LPF (note,time,cutoff,lpq,sound)\nfloat lpfc30(float n,float x,float c,float q,int s){LPF(osc_c30(f,s))}\n\n//Tetrascape instruments\nfloat fx1(float x){return (osc_c30(293.*x,7)+osc_c30(440.*x,7))*env_d(x,.12);}\nfloat fx2(float x){return osc_duty(3e2*x*(1.+x*3.),.5)*env_d(x,.07);}\nfloat sd(float x){return osc_nesnoise(x,11)*env_d(x,.25)+osc_duty(6./(x*.5+.1),.5)*.3*env_d(x,.05);}\n\n\n//================================================================================\n// SEQUENCER\n//--------------------------------------------------------------------------------\n//BIT OPERATION\nint imod(int x,int y){return int(x-y*(x/y));}\nint get12(uint b,int l){return int(b>>l*4)&4095;}\nint get8(uint b,int l){return int(b>>l*4)&255;}\nint get4(uint b,int l){return int(b>>l*4)&15;}\nint get2(uint b,int l){return int(b>>l*2)&3;}\nint get3(int b,int p){return int(b>>p)&7;}\n\n//GET NOTE FROM SCALE\nint degree=0;uint scale=0u;\t//internal use\nint scaleNote(int y){int n=y>6?12:0;return y<-50?-99:key+int((scale>>((y+56)%7)*4)&15u)+n;}\n\n//GET PATTERN FROM SEQUENCE\nfloat mp=0.; //note length multiplier(from speed)\nint   to=0;  //top note for auto inversion\nuint  pt=0u; //pattern now playing\nint   st=0;  //step now playing\nconst vec4 spd=vec4(16.,32.,4.,8.);\nvoid getPattern(float t,uint sq){\n    bool di=int(mod(t*bpm*16./steps,16.))<get4(sq,6);\n    to=di?get4(sq,5):get4(sq,2);\n    pt=di?pat[get8(sq,3)]:pat[get8(sq,0)];\n    mp=spd[di?get2(sq,15):get2(sq,14)];\n    st=int(mod(t*bpm*mp/steps,16.));\n}\n\n//GET CHORD SEQUENCE\nuint scop(uint sc,int p,int op){p*=4;int n=int(sc&(15u<<p));sc^=uint(n);n>>=p;n+=op;n=n<0?n+12:n;return sc|uint((n&15)<<p);}\nuint scset(uint sc,int p,int b){p*=4;int n=int(sc&(15u<<p));sc^=uint(n);return sc|uint(b<<p);}\nivec4 seven=ivec4(7,1,5,6);\nvoid scaleChord(float t,float l,uint p){\n    int st=int(mod(t*bpm*4./steps,4.)),d=get2(p,15),sc=st<d?0:get2(p,14),ch=st<d?get8(p,4):get8(p,2);\n    d+=get2(p,13);ch=st<d?ch:get8(p,0);sc=st<d?sc:get2(p,12);scale=scl[sc];\n    degree=get3(ch,0);degree-=degree>0?1:0;\n    int c35=get3(ch,3);\n    scale=scop(scale,(degree+2)&7,(c35&2)>0?(c35&1)*2-1:0);\n    scale=scop(scale,(degree+4)&7,(c35&4)>0?(c35&1)*2-1:0);\n    int c7=(seven[get2(uint(ch),3)]+degree)%7;\n    scale=scset(scale,(degree+6)&7,int(scl[sc]>>c7*4)&15);\n}\n\n//GET NOTE FROM PATTERN\nint notegen(int s,int s1,int s2){\n    return fract(sin(float(s+s1)+float(s1*20)*gateSeed)*50.)<(float(get4(pt,6))*.0625)?-99:\n        imod(int(abs(sin(float(s+s1+s*s2)*noteSeed)*float(s2))),get4(pt,7)+1);\n}\nvec2 getNote(float t,float l){\n    int s1=get12(pt,3),s2=get12(pt,0),n=notegen(st,s1,s2);float x=mod(t,l/mp);\n    if((st>=1)&&(n<-50)){n=notegen(st-1,s1,s2);x+=l/mp;}\n    n+=n<-50?0:degree+7;n-=n>16-to?7:0;\n    return (n<-50)?vec2(x,-99):vec2(x,scaleNote(n));\n}\nfloat getChord(int n){\n    n+=degree+7;n-=n>16-to?7:0;\n    return float(scaleNote(n));\n}\nvec2 getNoteByChord(float t,float l){\n    int s1=get12(pt,3),s2=get12(pt,0),n=notegen(st,s1,s2);n-=n&1;float x=mod(t,l/mp);\n    if((st>=1)&&(n<-50)){n=notegen(st-1,s1,s2);x+=l/mp;n-=n&1;}\n    n+=n<-50?0:degree+7;n-=n>16-to?7:0;\n    return (n<-50)?vec2(x,-99):vec2(x,scaleNote(n));\n}\nvec2 getGate(float t,float l){\n    int n=get2(pt,st);float x=mod(t,l/mp);\n    if((st>=1)&&(n==0)){n=get2(pt,st-1);x+=l/mp;}\n    return vec2(x,n);\n}\n\n//================================================================================\n// RENDERER\n//--------------------------------------------------------------------------------\n//TRACK 1 snaredrum,closehh,openhh\nvec2 track1(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq1[imod(s,len1)]);\n    vec2 n=getGate(t,l);\n    o+=(n.y==1.)?sd(n.x)*vec2(.48,.62):vec2(0);\n    o+=(n.y==2.)?neshh(n.x,.08)*vec2(.15,.24):vec2(0);\n    o+=(n.y==3.)?neshh(n.x,.2)*vec2(.15,.24):vec2(0);\n    return o;\n}\n//TRACK 2 bassdrum,fx1,fx2\nvec2 track2(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq2[imod(s,len2)]);\n    vec2 n=getGate(t,l);\n    o+=(n.y==1.)?nesbd(n.x)*vec2(.4,.55):vec2(0);\n    o+=(n.y==2.)?fx1(n.x)*vec2(.45,.65):vec2(0);\n    o+=(n.y==3.)?fx2(n.x)*vec2(.35,.15):vec2(0);\n    return o;\n}\n//TRACK 3 bass\nvec2 track3(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq3[imod(s,len3)]);\n    vec2 n=getNoteByChord(t,l);\n    o+=(n.y>-50.)?dutybass(freq(n.y+36.)*n.x,n.x)*vec2(.28,.31):vec2(0);\n    o+=(n.y>-50.)?lpfsaw(n.y+36.,n.x,sin(t*bpm*3.142/480.)*.3+.34,.9)*vec2(.2)*env_d(n.x,.6)*vec2(.88,.98):vec2(0);\n    return o;\n}\n//TRACK 4 chord\nvec2 track4(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq4[imod(s,len4)]);\n    vec2 n=getNote(t,l);\n    o+=(n.y>-50.)?c30chord(freq(n.y+36.03)*n.x,n.x)*.25:vec2(0);\n    o+=(n.y>-50.)?c30chord(freq(getChord(2)+48.02)*n.x,n.x)*vec2(.30,.20):vec2(0);\n    o+=(n.y>-50.)?c30chord(freq(getChord(4)+36.01)*n.x,n.x)*vec2(.31,.19):vec2(0);\n    o+=(n.y>-50.)?c30chord(freq(getChord(6)+48.01)*n.x,n.x)*vec2(.32,.18):vec2(0);\n    return o;\n}\n//TRACK 5 accompaniment\nvec2 track5(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq5[imod(s,len5)]);\n    vec2 n=getNoteByChord(t,l);\n    o+=(n.y>-50.)?c30bell(freq(n.y+72.)*n.x,n.x)*vec2(.30,.35):vec2(0);\n    return o;\n}\n//TRACK 6 melody\nvec2 track6(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq6[imod(s,len6)]);\n    vec2 n=getNoteByChord(t,l);\n    o+=(n.y>-50.)?lpfc30(n.y+48.03,n.x,sin(t*bpm*3.142/180.)*.3+.4,.9,3)*vec2(.40,.50):vec2(0);\n    return o;\n}\nvoid render(float t,float l,inout vec2 o,bool e){\n    int s=int(t/l); //sequence number now playing\n    scaleChord(t,l,chordseq[imod(s,chordlen)]); //set scale & chord\n    o+=e?track1(t,l,s):track1(t,l,s)*.7; //TRACK 1 snaredrum,closehh,openhh\n    o+=e?track2(t,l,s):track2(t,l,s)*.5; //TRACK 2 bassdrum,fx1,fx2\n    o+=  track3(t,l,s);                  //TRACK 3 bass\n    o+=  track4(t,l,s);                  //TRACK 4 chord\n    o+=e?track5(t,l,s):track5(t,l,s)*.8; //TRACK 5 accompaniment\n    o+=  track6(t,l,s);                  //TRACK 6 melody\n}\n\n//================================================================================\n// MASTER\n//--------------------------------------------------------------------------------\n#define MASTER_DRIVE    0.35\n#define MASTER_PRESSURE 1.05\n#define DELAY_REPEAT    13\n#define DELAY_WET       0.50\n#define DELAY_FEEDBACK  0.88\n#define DELAY_TIME      0.153\n#define DELAY_STEREO    0.11\nvec2 mainSound(in int Samp,float time){\n    float l=steps/bpm,vol=1.,d=DELAY_WET,r=DELAY_TIME;\n    vec2 o=vec2(0);\n    if(time>sec-fade){vol=(sec-min(time,sec))/fade;}\n    time-=start*60./bpm;\n    if(time<0.)return o;\n    render(time,l,o,true);\n    float ff=0.,p=0.;\n    for(int i=0;i<DELAY_REPEAT;i++){\n        time-=r;\n        if(time<0.)continue;\n        vec2 a=vec2(0);\n        render(time,l,a,false);\n        d*=DELAY_FEEDBACK;\n        o+=a*d*vec2(1.+p*ff,1.-p*ff);\n        ff=ff<0.?1.:-1.;\n        p+=DELAY_STEREO;\n    }\n    return amp(o,vec3(MASTER_DRIVE,MASTER_PRESSURE,vol));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}