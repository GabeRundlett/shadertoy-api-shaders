{
    "Shader": {
        "info": {
            "date": "1586517237",
            "description": "For lug00ber",
            "flags": 32,
            "hasliked": 0,
            "id": "3dScD1",
            "likes": 19,
            "name": "Hypercube VJ",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "BoyC",
            "viewed": 939
        },
        "renderpass": [
            {
                "code": "vec4 blurY( out vec4 fragColor, in vec2 fragCoord )\n{\n    float BlurWeights[31] = float[31](\n   0.000001,\t0.000003,\n        0.000012,\t0.000048,\t0.000169,\t0.000538,\t0.001532,\t0.003906,\t0.00892,\t0.018246,\t0.033431,\n        0.054865,\t0.080656,\t0.106209,\t0.125279\t,0.132368,\t0.125279,\t0.106209\t,0.080656,\t0.054865,\t0.033431,\n        0.018246,\t0.00892,\t0.003906,\t0.001532,\t0.000538,\t0.000169,\t0.000048,\t0.000012,\t0.000003,\t0.000001\n);\n    \n    vec2 uv=fragCoord.xy/iResolution.xy;\n    vec4 color = vec4(0.0);\n    \n    float kernelSize = 31.0;\n    int counter=0;\n    float blurSize = 3.0;\n\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n\n    for (int x=0; x<int(kernelSize); x++)\n        {\n            vec4 col = texture(iChannel0, uv + vec2(0.0, float(x)-kernelSize/2.0)*blurSize/iResolution.xy) * BlurWeights[int(x)];\n    \t\tfloat l = dot(luma,col.xyz);\n\t\t    //if (l>0.9)\n            {\n            \tcolor+=col;\n                counter++;\n            }\n        }\n        \n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 blurred = blurY(fragColor, fragCoord);\n    \n    vec2 uv=fragCoord.xy/iResolution.xy;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n\n    vec4 col = texture(iChannel1,uv);\n    \n    float threshold = 0.6;\n    float intensity = 2.0;\n    vec4 bloom = (blurred-vec4(threshold))*intensity+vec4(threshold);\n    bloom = clamp(bloom,vec4(0.0),vec4(1.0)) * 0.5;\n    \n\tfragColor = bloom + col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float vmax(vec3 v)\n{\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat fBox2(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\nfloat fBox(vec3 p, vec3 b) \n{\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat sdf(vec3 pos)\n{\n    return fBox(pos, vec3(1.0,1.0,1.0));\n}\n\nfloat edgeSize = 0.1;\n\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\nvec3 pMod3(inout vec3 p, vec3 size) \n{\n\tvec3 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\n\nfloat sdf2(vec3 pos)\n{\n    pMod3(pos,vec3(2.0));\n    \n    return min(min(fBox2(pos.xy, vec2(edgeSize)),fBox2(pos.xz, vec2(edgeSize))),fBox2(pos.yz, vec2(edgeSize)));\n}\n\nvec2 pModMirror2(inout vec2 p, vec2 size) {\n\tvec2 halfsize = size*0.5;\n\tvec2 c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\tp *= mod(c,vec2(2))*2.0 - vec2(1);\n\treturn c;\n}\n\nvec4 iqColor(vec3 a, vec3 b, vec3 c, vec3 d, float t)\n{\n    return vec4( a + b * cos( 2.0 *3.14152965 * (c*t+d) ), 1);\n}\n\nvec4 discoStrip( float x )\n{\n    float patternLength = 30.0;\n    float timePos = mod(iTime,patternLength);\n    \n    float pattern = mod((iTime / patternLength),6.0);\n    \n    float c = clamp(sin(iTime*4.0 + x)*5.0,0.0,1.0);\n    vec4 color = vec4(c*0.7,c*0.5,c,1);\n    \n    if (pattern>=1.0)\n        color = iqColor(vec3(0.5),vec3(0.5),vec3(1.0),vec3(0.00, 0.33, 0.67) + vec3(x)/5.0, iTime) * vec4(1.3,0.8,0.2,1.0);;\n    if (pattern>=2.0)\n        color = iqColor(vec3(0.5),vec3(0.5),vec3(1.0, 1.0, 0.5),vec3(0.80, 0.90, 0.30) + vec3(x)/6.0, iTime);\n    if (pattern>=3.0)\n        color = vec4(sin(iTime*5.0 + x)*0.5+0.5,cos(iTime*5.0 + x)*0.7+0.3,cos(iTime*7.0 + x)*0.3+0.5,1);\n    if (pattern>=4.0)\n        color = iqColor(vec3(0.5),vec3(0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) + vec3(x)/3.0*1.5, iTime) * vec4(0.3,0.8,1.5,1.0);\n    if (pattern>=5.0)\n        color = iqColor(vec3(0.5),vec3(0.5),vec3(1.0, 1.0, 0.5),vec3(0.80, 0.90, 0.30) + vec3(x)/6.0, iTime) * vec4(0.7,1.5,0.3,1.0);/**/\n    \n    float fade = clamp(-(abs(timePos-patternLength/2.0)-patternLength/2.0)-0.5,0.0,1.0);\n        \n    return color*fade;\n}\n\nvec4 dotPattern( vec2 d )\n{   \n    d-=vec2(11.0);\n    \n    d=mod(d,40.0);\n    if (d.x>=20.0) d.x=39.0-d.x;\n    if (d.y>=20.0) d.y=39.0-d.y;\n    \n    if (d.x-0.0 == 0.0 )\n        return discoStrip( d.y );\n    if (d.x-19.0 == 0.0 )\n        return discoStrip( d.y );\n    \n    if (d.y-0.0 == 0.0 )\n        return discoStrip( d.x );\n    if (d.y-19.0 == 0.0 )\n        return discoStrip( d.x );\n    \n    return vec4(0.0);\n}\n\nvec4 discoPattern( vec2 pos )\n{    \n    pos+=vec2(edgeSize*0.5);\n    vec2 idx = pMod2(pos,vec2(edgeSize*1.0));\n    float l = length(pos)*3.0;\n    \n    vec4 dotColor = clamp(dotPattern(idx),vec4(0.0),vec4(1.0));\n    \n    return l<edgeSize ? dotColor : vec4(0);\n}\n\nvec4 disco(vec3 pos, vec3 dir)\n{\n\tvec3 n=normalize(vec3(sdf2(pos+vec3(0.01,0,0))-sdf2(pos+vec3(-0.01,0,0)),\n\t\t\t\t\t\t  sdf2(pos+vec3(0,0.01,0))-sdf2(pos+vec3(0,-0.01,0)),\n\t\t\t\t\t\t  sdf2(pos+vec3(0,0,0.01))-sdf2(pos+vec3(0,0,-0.01))));\n\n    n=abs(n);\n    \n    vec4 c = vec4(0);\n    if (n.x > n.y && n.x > n.z)\n        c=discoPattern(pos.yz);\n    if (n.y > n.x && n.y > n.z)\n        c=discoPattern(pos.xz);\n    if (n.z > n.y && n.z > n.x)\n        c=discoPattern(pos.xy);\n    \n    return c;\n}\n\nvec4 magicCube( vec3 pos, vec3 dir )\n{\n  vec3 oPos = pos;\n\n  float dist = sdf2(pos+1.0);\n  if (dist<0.000001)\n  \treturn vec4(0);\n  \n  for (int x=0; x<100; x++)\n  {\n      dist = sdf2(pos+1.0);\n\n      float distFade = max(0.0, 1.0-length(pos-oPos)*0.05 );\n      \n      if (distFade==0.0)\n          break;\n      \n      if (dist<0.00001)\n      {\n          return mix(disco(pos, dir),vec4(1.0),1.0-distFade);\n      }\n      pos += dir * abs(dist);       \n  }\n    \n  return vec4(1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time=iTime/3.0;//+43.63/3.0;\n\n    // cam that goes in the cube\n    /*float rotationTime = sin(time/5.35886)*3.14152965;\n    float y = 1.0*sin(time + sin(time/5.0)*3.14152965);\n    vec3 Pos=vec3(2.0*sin(rotationTime), y, 2.0*cos(rotationTime))*(1.3+sin(time)*( sin(time/7.86463) * 0.5 + 0.5 ) );/**/\n    \n    // cam that doesn't go in the cube\n    float rotationTime = sin(time/5.35886)*3.14152965;\n    float y = 1.0*sin(time + sin(time/5.0)*3.14152965);\n    vec3 Pos=vec3(2.0*sin(rotationTime), y, 2.0*cos(rotationTime))*(2.0+sin(time)*( sin(time/7.86463) * 0.1 + 0.1 ) );\n    \n    vec3 camPos = Pos;\n\tvec3 CamDir=normalize(-Pos);\n\tvec3 CamRight=normalize(cross(CamDir,vec3(0,1,0)));\n\tvec3 CamUp=normalize(cross(CamRight,CamDir));\t\n\tmat3 cam=transpose(mat3(CamRight,CamUp,CamDir));\n\n\t//ray calculation\t\n    float distroPower = clamp((sin(time/2.1373)-0.95)*20.0,0.0,1.0);\n\tvec2 uv=2.0*fragCoord.xy/iResolution.xy-1.0;// + 0.01*vec2(sin((fragCoord.x+iTime)*10000.0),sin((fragCoord.x+iTime*2.0)*10000.0)) * distroPower;\n\tfloat aspect=iResolution.x/iResolution.y;\n\t\n\tvec3 Dir=normalize(vec3(uv*vec2(aspect,1.0),2.0))*cam;\n    \n    float dist = 10000.0f;\n\n    for (int x=0; x<100; x++)\n    {\n        dist = sdf(Pos);\n        if (dist<=0.01)\n        {\n            break;\n        }\n        Pos += Dir * abs(dist);        \n    }\n    \n    if (dist<=0.01)\n    {\n        float camDist = length(camPos);\n        fragColor = magicCube(Pos,Dir);\n    }\n    else\n    {\n        float vignette = clamp(1.0 - pow(length( (fragCoord.xy/iResolution.xy - 0.5) * 2.0 ),5.0),0.0,1.0);\n    \tfragColor = (discoStrip(Dir.x*5.0) + discoStrip(Dir.y*5.0) + discoStrip(Dir.z*5.0))/3.0*0.5 * vignette*0.7;// vec4(Dir*0.5+0.5,1.0);/**/\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// FXAA code from: http://www.geeks3d.com/20110405/fxaa-fast-approximate-anti-aliasing-demo-glsl-opengl-test-radeon-geforce/3/\n\n#define FXAA_SPAN_MAX 8.0\n#define FXAA_REDUCE_MUL   (1.0/FXAA_SPAN_MAX)\n#define FXAA_REDUCE_MIN   (1.0/128.0)\n#define FXAA_SUBPIX_SHIFT (1.0/32.0)\n\nvec3 FxaaPixelShader( vec4 uv, sampler2D tex, vec2 rcpFrame) {\n    \n    vec3 rgbNW = textureLod(tex, uv.zw, 0.0).xyz;\n    vec3 rgbNE = textureLod(tex, uv.zw + vec2(1,0)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbSW = textureLod(tex, uv.zw + vec2(0,1)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbSE = textureLod(tex, uv.zw + vec2(1,1)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbM  = textureLod(tex, uv.xy, 0.0).xyz;\n\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max(\n        (lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),\n        FXAA_REDUCE_MIN);\n    float rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);\n    \n    dir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),\n          max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n          dir * rcpDirMin)) * rcpFrame.xy;\n\n    vec3 rgbA = (1.0/2.0) * (\n        textureLod(tex, uv.xy + dir * (1.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(tex, uv.xy + dir * (2.0/3.0 - 0.5), 0.0).xyz);\n    vec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (\n        textureLod(tex, uv.xy + dir * (0.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(tex, uv.xy + dir * (3.0/3.0 - 0.5), 0.0).xyz);\n    \n    float lumaB = dot(rgbB, luma);\n\n    if((lumaB < lumaMin) || (lumaB > lumaMax)) return rgbA;\n    \n    return rgbB; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 rcpFrame = 1./iResolution.xy;\n  \tvec2 uv2 = fragCoord.xy / iResolution.xy;\n        \n   \tvec4 uv = vec4( uv2, uv2 - (rcpFrame * (0.5 + FXAA_SUBPIX_SHIFT)));\n    fragColor = vec4( FxaaPixelShader( uv, iChannel0, 1./iResolution.xy ), 1.0);\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float BlurWeights[31] = float[31](\n   0.000001,\t0.000003,\n        0.000012,\t0.000048,\t0.000169,\t0.000538,\t0.001532,\t0.003906,\t0.00892,\t0.018246,\t0.033431,\n        0.054865,\t0.080656,\t0.106209,\t0.125279\t,0.132368,\t0.125279,\t0.106209\t,0.080656,\t0.054865,\t0.033431,\n        0.018246,\t0.00892,\t0.003906,\t0.001532,\t0.000538,\t0.000169,\t0.000048,\t0.000012,\t0.000003,\t0.000001\n);\n    \n    vec2 uv=fragCoord.xy/iResolution.xy;\n    vec4 color = vec4(0.0);\n    \n    float kernelSize = 31.0;\n    int counter=0;\n    float blurSize = 3.0;\n\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n\n    for (int x=0; x<int(kernelSize); x++)\n        {\n            vec4 col = texture(iChannel0, uv + vec2(float(x)-kernelSize/2.0,0.0)*blurSize/iResolution.xy) * BlurWeights[int(x)];\n    \t\tfloat l = dot(luma,col.xyz);\n\t\t    //if (l>0.9)\n            {\n            \tcolor+=col;\n                counter++;\n            }\n        }\n        \n\tfragColor = color*1.0;//+texture(iChannel0, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}