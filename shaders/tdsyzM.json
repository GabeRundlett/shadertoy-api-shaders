{
    "Shader": {
        "info": {
            "date": "1584466037",
            "description": "Clebsch (and other) cubics, this one uses an SDF based on the implicit equation. It seems to go well with the foggy look from [url]https://www.shadertoy.com/view/tdlcRN[/url]\n\nSee also: [url]https://www.shadertoy.com/view/llKfDc[/url].",
            "flags": 48,
            "hasliked": 0,
            "id": "tdsyzM",
            "likes": 10,
            "name": "Clebsch & Cayley Cubics with SDF",
            "published": 3,
            "tags": [
                "sdf",
                "cubic",
                "clebsch",
                "cayley"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 355
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Clebsch & other Cubics, raymarched using the implicit equation as SDF,\n// adjusted by the analytic gradient.\n//\n// Matthew Arcus, 2020.\n//\n// <mouse>: rotate\n// <up>/<down>: move in/out\n// <left>/<right>: fog distance\n// <page up>/<page down>: select Clebsch, Caley or morphing Cubic.\n// f: fog\n// l: light transform\n// r: autorotation\n//\n// A projective transform as in https://www.shadertoy.com/view/llKfDc would\n// be nice, but doesn't interact nicely with the SDF approach.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.14159;\nconst int maxsteps = 100;\nconst float precis = 0.001;\nconst float AA = 2.0;\n\nfloat maxdist = 10.0;\nbool dorotate = true; // Autorotate\n\nbool check = false;\nvoid assert(bool b) {\n  if (!b) check = true;\n}\n\nfloat K = 1.0;\n// Cubic implicit equation, adjusted for gradient.\nfloat getdist(vec3 p) {\n   // x^3+y^3+z^3-K*w^3 = t^3 where w = 1, t = x+y+z+w\n   float t = dot(p,vec3(1))+1.0;\n   float ds = 2.0*length(p*p-t*t); // length of gradient\n  return (dot(p*p,p)+K-t*t*t)/ds;\n}\n\n// Gradient as a separate function.\nvec3 cgrad(vec3 p) {\n  float t = dot(p,vec3(1))+1.0;\n  return 2.0*(p*p-t*t);\n}\n\nfloat rosign;   // sign of implict equation at ray origin\nfloat march(vec3 ro, vec3 rd) {\n  float t = 0.1;\n  for(int i = 0; i < maxsteps; i++) {\n    //assert(i < 50);\n    vec3 p = ro + t*rd;\n    float d = rosign*getdist(p);\n    // Longer distance estimates are inaccurate,\n    // so clamp to avoid overstepping.\n    d = min(d,0.5);\n    t += d;\n    if (t < 0.0 || t > maxdist || abs(d) < t*precis) break;\n  }\n  return t;\n}\n\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,-theta);\n    p.zx = rotate(p.zx,phi);\n  }\n  if (dorotate) {\n    p.yz = rotate(p.yz,iTime * 0.125);\n    p.zx = rotate(p.zx,iTime * 0.1);\n  }\n  return p;\n}\n\nvec3 hsv2rgb(float h, float s, float v) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return v * mix( vec3(1.0), rgb, s);\n}\n\nint mymod(int n, int m) {\n  // glsl % undefined for -ve arguments\n  if (n < 0) return m-1-(-n-1)%m;\n  else return n%m;\n}\n\nconst int CHAR_A = 65;\nconst int CHAR_F = 70;\nconst int CHAR_L = 76;\nconst int CHAR_R = 82;\nconst int CHAR_T = 84;\nconst int CHAR_X = 88;\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\nvec4 store(int i,int j) {\n  return texelFetch(iChannel1, ivec2(i,j),0);\n}\n\nint keycount(int key) {\n  return int(store(0,key).x);\n}\n\nbool key(int code) {\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\n// Perpendicular distance to line given by origin and direction\nfloat line(vec3 p, vec3 origin, vec3 dir) {\n  p -= origin;\n  float t = dot(p,dir);\n  return distance(p,t*dir);\n}\n\n#if 1\n// Calculate the parameters for the last 12 lines.\n// I can't find my notes about how all this works.\nfloat beval(float a, float A, float B, float z, float w) {\n  return -0.5*(2.0*a*a*z + A + B)/(w*w - a*a);\n}\n\nfloat feval(float a, float A, float B, float z, float w) {\n  float b = beval(a,A,B,z,w);\n  float t = 2.0*(b*b*(-a + w) + a*z*z) + A - B;\n  return t;\n}\n\nvec2 lineparams(float z, float w) {\n  float A = (K*8.0 + z*z*z + w*w*w - 1.0)/3.0;\n  float B =  z*z*w-z*w*w;\n  float eps = 1e-2;\n  float x0 = abs(w) + eps, f0 = feval(x0,A,B,z,w);\n  float x1 = x0 + eps, f1 = feval(x1,A,B,z,w);\n  // Start from abs(w) search for a bracketing interval\n  while (f1 < 0.0) {\n    float t = 2.0*x1 - x0;\n    x0 = x1; f0 = f1;\n    x1 = t; f1 = feval(x1,A,B,z,w);\n  }\n  // And apply bisection.\n  // Secant method doesn't help much here.\n  for (int i = 0; i < 10; i++) {\n    float x2 = (x0+x1)/2.0;\n    float f2 = feval(x2,A,B,z,w);\n    if (f2 < 0.0) {\n      x0 = x2; f0 = f2;\n    } else {\n      x1 = x2; f1 = f2;\n    }\n  }\n  float a = (x0+x1)/2.0;\n  return vec2(a,beval(a,A,B,z,w));\n}\n\n// Find the squared distance to the line in R3 but using\n// P4 coordinates.\nvoid tryline(vec4 p, vec4 q, vec4 r, int color,\n             inout float d2best) {\n  // Rotate lines in P4 so they project to correct\n  // position in R3 before calculating distance.\n#if 0\n  // These cases don't arise without a projective transform\n  if (abs(q.w) < abs(r.w)) {\n    vec4 t = q; q = r; r = t;\n  }\n  if (abs(q.w) < 1e-2) return;\n#endif\n   r = q.w*r - r.w*q; // r.w = 0\n   p = q.w*p-q;\n   float pr = dot(p,r);\n   float d2 = (dot(p,p) - (pr*pr/dot(r,r)))/(q.w*q.w);\n   if (d2 < d2best) {\n      d2best = d2;\n   }\n}\n\nfloat linedist(vec3 p) {\n#define tryline(x0,y0,z0,w0,x1,y1,z1,w1,c) \\\n  tryline(vec4(p,1),vec4(x0,y0,z0,w0),vec4(x1,y1,z1,w1),c,d2)\n  // It's tempting to put the lines in an array, but this\n  // performs badly on my laptop, perhaps a shortage of registers.\n  float d2 = 1e8;\n  if (false) {\n    // All at infinity\n    tryline(1,0,0,0, 0,1,-1,0, 3);\n    tryline(0,1,0,0, 1,0,-1,0, 3);\n    tryline(0,0,1,0, 1,-1,0,0, 3);\n  }\n  if (K >= 0.25) {\n    float A = 3.0, B = 3.0, C = 1.0-K;\n    float z0 = (-B - sqrt(B*B-4.0*A*C))/(2.0*A);\n    float z1 = (-B + sqrt(B*B-4.0*A*C))/(2.0*A);\n    if (true) {\n      tryline(0,0,z0,1, 1,-1,0,0, 4);\n      tryline(0,z0,0,1, 1,0,-1,0, 5);\n      tryline(z0,0,0,1, 0,1,-1,0, 6);\n      tryline(0,0,z1,1, 1,-1,0,0, 4);\n      tryline(0,z1,0,1, 1,0,-1,0, 5);\n      tryline(z1,0,0,1, 0,1,-1,0, 6);\n      tryline(z0,z1,0,1, 0,0,1,0, 4);\n      tryline(z0,0,z1,1, 0,1,0,0, 5);\n      tryline(0,z0,z1,1, 1,0,0,0, 6);\n      tryline(z1,z0,0,1, 0,0,1,0, 4);\n      tryline(z1,0,z0,1, 0,1,0,0, 5);\n      tryline(0,z1,z0,1, 1,0,0,0, 6);\n    }\n    if (K == 0.25) return sqrt(d2);\n    vec2 t = lineparams(z0,z1);\n    float a = t[0], b = t[1];\n    tryline(a,-a,z0,1, b,z1,-b,1, 1);\n    tryline(a,z0,-a,1, b,-b,z1,1, 2);\n    tryline(-a,z0, a,1, z1,-b, b,1, 1);\n    tryline(-a,a,z0,1, z1, b,-b,1, 2);\n    tryline(z0, a,-a,1, -b, b,z1,1, 1);\n    tryline(z0,-a, a,1, -b,z1, b,1, 2);\n        \n    tryline(-b,z0,b,1, -a,a,z1,1, 1);\n    tryline(-b,b,z0,1, -a,z1,a,1, 2);\n    tryline(b,-b,z0,1, z1, -a,a,1, 1);\n    tryline(b,z0, -b,1, z1,a, -a,1, 2);\n    tryline(z0,b, -b,1, a,z1, -a,1, 1);\n    tryline(z0, -b,b,1, a, -a,z1,1, 2);\n  }\n#undef tryline\n  return sqrt(d2);\n}\n#else\nfloat linedist(vec3 p) {\n  float d = 1e8;\n  // 24 lines - 3 of the 27 are at infinity in this projection.\n  // Maybe should use Plucker coordinates for this?\n  d = min(d,line(p,vec3(0,0,0),vec3(0.70711,-0.70711,0)));\n  d = min(d,line(p,vec3(0,0,0),vec3(0.70711,0,-0.70711)));\n  d = min(d,line(p,vec3(-1,-0,-0),vec3(0,1,0)));\n  d = min(d,line(p,vec3(-1,-0,-0),vec3(0,0,1)));\n  d = min(d,line(p,vec3(0,0,0),vec3(0,0.70711,-0.70711)));\n  d = min(d,line(p,vec3(-0,-1,-0),vec3(1,0,0)));\n  d = min(d,line(p,vec3(-0,-1,-0),vec3(0,0,1)));\n  d = min(d,line(p,vec3(-0,-0,-1),vec3(1,0,0)));\n  d = min(d,line(p,vec3(-0,-0,-1),vec3(0,1,0)));\n  d = min(d,line(p,vec3(-0,-0,-1),vec3(0.70711,-0.70711,0)));\n  d = min(d,line(p,vec3(-0,-1,-0),vec3(0.70711,0,-0.70711)));\n  d = min(d,line(p,vec3(-1,-0,-0),vec3(0,0.70711,-0.70711)));\n  d = min(d,line(p,vec3(-1.618,-1,-0),vec3(0.46534,0.75294,-0.46534)));\n  d = min(d,line(p,vec3(-1,-1.618,-0),vec3(0.75294,0.46534,-0.46534)));\n  d = min(d,line(p,vec3(-1,-0,-1.618),vec3(0.75294,-0.46534,0.46534)));\n  d = min(d,line(p,vec3(-1.618,-0,-1),vec3(0.46534,-0.46534,0.75294)));\n  d = min(d,line(p,vec3(0.61803,-0.61803,0),vec3(0.64794,0.40045,-0.64794)));\n  d = min(d,line(p,vec3(0.61803,0,-0.61803),vec3(0.64794,-0.64794,0.40045)));\n  d = min(d,line(p,vec3(-0,-1.618,-1),vec3(-0.46534,0.46534,0.75294)));\n  d = min(d,line(p,vec3(-0,-1,-1.618),vec3(-0.46534,0.75294,0.46534)));\n  d = min(d,line(p,vec3(0,0.61803,-0.61803),vec3(-0.64794,0.64794,0.40045)));\n  d = min(d,line(p,vec3(-0.61803,0.61803,0),vec3(0.40045,0.64794,-0.64794)));\n  d = min(d,line(p,vec3(-0.61803,0,0.61803),vec3(0.40045,-0.64794,0.64794)));\n  d = min(d,line(p,vec3(0,-0.61803,0.61803),vec3(-0.64794,0.40045,0.64794)));\n  return d;\n}\n#endif\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  dorotate = !key(CHAR_R);\n  maxdist = 10.0*(exp(0.1*float(keycount(KEY_RIGHT)-keycount(KEY_LEFT))));\n  vec3 ro = vec3(0,0,4);\n  ro.z += 0.25*float(keycount(KEY_DOWN)-keycount(KEY_UP));\n  ro = transform(ro);\n  vec3 light = vec3(1,2,3);\n  // Leaving the light fixed (untransformed) produces more\n  // dramatic lighting.\n  if (key(CHAR_L)) light = transform(light);\n  light = normalize(light);\n  rosign = sign(getdist(ro));\n  vec3 aacol = vec3(0);\n  int type = mymod(keycount(KEY_PAGE_DOWN)-keycount(KEY_PAGE_UP),3);\n  if (type == 0) K = 1.0;\n  else  if (type == 1) K = 0.25;\n  else if (type == 2) K = 1.0-sin(0.2*iTime);\n  for (float i = 0.0; i < AA; i++) {\n    for (float j = 0.0; j < AA; j++) {\n      vec2 uv = (2.0*(fragCoord+vec2(i,j)/AA)-iResolution.xy)/iResolution.y;\n      vec3 rd = vec3(uv,-2);\n      rd = transform(rd);\n      rd = normalize(rd);\n      float t = march(ro, rd);\n      vec3 basecol = hsv2rgb(0.1+0.01*iTime,1.0,1.0); //vec3(1,0.5,0);\n      vec3 col = mix(vec3(1),basecol,0.75);\n      if (t >= 0.0 && t < maxdist) {\n        vec3 p = ro+t*rd;\n        vec3 n = normalize(cgrad(p));\n        if (dot(n,rd) > 0.0) n = -n;\n        float diffuse = mix(1.0,dot(n,light),0.5);\n        float d = linedist(p);\n        float intensity = 0.5+0.5*smoothstep(0.006,0.008,d);\n        vec3 c = diffuse*intensity*basecol;\n        float fog = key(CHAR_F) ? 0.0 : t/maxdist;\n        col = mix(c,col,fog);\n      }\n      aacol += col;\n    }\n  }\n  aacol = pow(aacol/(AA*AA),vec3(0.4545));\t// gamma correction\n  //assert(!isnan(dot(aacol,aacol)));\n  fragColor = vec4(aacol,1);\n  if (check) fragColor.r = 1.0;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define keystate(k,n) ( texelFetch(iChannel0,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n#if __VERSION__ < 300\n    t = vec4(0);\n#else   \n    int i = int(uv.x);\n    int j = int(uv.y);\n    if ( iFrame == 0) {\n      t = vec4(0);\n    } else {\n      t = texelFetch(iChannel1,ivec2(i,j),0); // Get current state   \n    }  \n    if (i == 0) {\n        float w1 = keystate(j,2).x;\n        if (w1 != t.w) {\n            t.w = w1;\n            t.x++;\n        }\n    }     \n        \n#endif           \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}