{
    "Shader": {
        "info": {
            "date": "1614826057",
            "description": "Another clock. :3",
            "flags": 0,
            "hasliked": 0,
            "id": "3tyfRt",
            "likes": 7,
            "name": "Small Clock",
            "published": 3,
            "tags": [
                "lens",
                "zoom",
                "clock"
            ],
            "usePreview": 0,
            "username": "foxic",
            "viewed": 297
        },
        "renderpass": [
            {
                "code": "#define hand_length 0.84\n\nfloat char(vec2 p, int C) {\n    if (p.x<0.|| p.x>1. || p.y<0.|| p.y>1.) return 1.;\n    return (textureGrad( iChannel0, p/16. + fract( vec2(C, 15-C/16) / 16. ) , \n                       dFdx(p/16.),dFdy(p/16.) ).a-0.5)*0.25;\n}\n\nfloat tick_curve( float time1, float time2, float sec )\n{\n    return mix( floor(time1), floor(time2), clamp( fract(sec)*5., 0., 1. ) );\n    return time1;\n}\n\nfloat pInt(vec2 p, float num ) {\n    float v = 1.;\n    bool is_double = num >= 10.;\n    float offset = 0.25*float(is_double);\n    \n    for (float i = float(is_double); i>=0.; i--)\n        num /= 10.,\n        v = min(char(p - vec2(offset-=.5,-.5), 48+ int(fract(num)*10.) ), v );\n       \n    return v;\n}\n\nfloat sdCircle( vec2 p, float r ){\n    return length(p) - r;\n}\n\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-h*ba)-0.002625;\n}\n\nvec2 lens_uv(vec2 uv,float size, vec2 pos ) {\n    float radius=size;\n    float depth=radius/2.;\n    \n\tfloat ax = ((uv.x - pos.x) * (uv.x - pos.x)) / (0.2*0.2) + ((uv.y - pos.y) * (uv.y - pos.y)) / (0.2/ (  iResolution.x / iResolution.y )) ;\n\tfloat dx = 0.0 + (-depth/radius)*ax + (depth/(radius*radius))*ax*ax;\n    float f =  (ax + dx );\n\tif (ax > radius) f = ax;\n    \n    return pos + (uv-pos)*f/ax;\n}\n\nfloat clock_hand_black(vec2 p,float size,float angle ) {\n    float d = 1.;\n    \n    // Center\n    vec2 pos = vec2(sin(angle),cos(angle));\n    d = min( abs(sdCircle( p-(pos*hand_length), size ))-0.002625, d );\n    d = min( udSegment( p, vec2(0.), pos*(hand_length-size) ), d );\n    \n    float lens_mask = sdCircle( p-(pos*hand_length), size )+0.02;\n    float lens = (sdCircle( p-(pos*(hand_length-0.02)+vec2(0.,0.05)), 0. )*0.025)+0.006;\n    vec2 magnifierArea = lens_uv( p, size, pos );\n    lens *= (texture( iChannel1, magnifierArea ).r*0.3)+1.;\n    d = min(max(0.017-lens, lens_mask), d);\n    \n    \n    return d;\n}\nfloat clock_hand_black_line(vec2 p, float size , float angle ) {\n    float d = 1.;\n    \n    // Center\n    vec2 pos = vec2(sin(angle),cos(angle));\n    d = min( udSegment( p, vec2(0.), pos*hand_length*size ), d );\n    \n    \n    return d;\n}\n\nfloat clock_hands( vec2 p, float time ) {\n    float d = 1.;\n    \n\tfloat secs  = mod( tick_curve(time,        time+1.,         time),   60.0 );\n\tfloat mins  = mod( tick_curve(time/60.0,  (time+1.)/60.0,   time),   60.0 );\n\tfloat hors  = mod( tick_curve(time/3600.0,(time+1.)/3600.0, time),   12.0 );\n    \n    d = min( clock_hand_black_line( p, 0.7,  (secs/60.)*6.28318), d );\n    \n    d = min( clock_hand_black(      p, 0.110, (hors/12.)*6.28318), d );\n    d = min( clock_hand_black(      p, 0.075, (mins/60.)*6.28318), d );\n    \n    \n    \n    // hand Center\n    d = max( -sdCircle( p, .06 ), d );\n    \n    float lens_light = max( abs(sdCircle( p, .04 ))*0.5, (sdCircle( p-vec2(0.,0.05), .03 )*0.2)-0.0001 );\n    vec2 magnifierArea = lens_uv( p, 0.4, vec2(0.) );\n    lens_light *= (texture( iChannel1, magnifierArea ).r*0.8)+1.;\n    d = min( 0.01-min(-sdCircle( p, .07 ), lens_light), d);\n    \n    return d;\n}\n\n\nfloat clock_face( vec2 p, vec2 l, float time ) {\n    float d = 1.;\n    \n    // NUMBERS\n    for (float i = 1.; i<=12.; i+=1.){\n        d = min( (pInt( ((l*1.19)-vec2(sin(i*0.523598),cos(i*0.523598)))*14., i)*0.5)+0.005, d );\n    }\n    \n    // BORDER\n    d = min( -sdCircle( p, .99 ), d );\n    d = min( abs(sdCircle( p, .96 ))-0.002625, d );\n    \n    \n    float hands = clock_hands( p, time );\n    hands = min( (clock_hands( p+vec2(0.0,0.02), time )+0.03)*0.2, hands );\n    \n    d = min(hands,d);\n    \n    d = max( min( sdCircle( p, .99 ), -sdCircle( p+vec2(0.,0.1), .99)*0.05 ), d);\n    \n    return d;\n}\n\nvec2 clock_hand_uv(vec2 uv,float size,float angle ) {\n    vec2 pos = vec2(sin(angle),cos(angle))*hand_length;\n    return lens_uv( uv,size, pos );\n}\nvec2 clock_hands_uv( vec2 p, float time ) {\n    \n\tfloat secs  = mod( tick_curve(time,        time+1.,         time),   60.0 );\n\tfloat mins  = mod( tick_curve(time/60.0,  (time+1.)/60.0,   time),   60.0 );\n\tfloat hors  = mod( tick_curve(time/3600.0,(time+1.)/3600.0, time),   12.0 );\n    \n    p = clock_hand_uv(p, 0.075, (mins/60.)*6.28318);\n    p = clock_hand_uv(p, 0.110, (hors/12.)*6.28318);\n    return p;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = ((2.0*fragCoord-iResolution.xy)/iResolution.y);\n    \n    float time = iDate.w;\n    vec2 l = clock_hands_uv( p, time );\n    \n    \n    float px = 2.0/iResolution.y;\n    float d = 1.;\n    \n    d = min( clock_face( p, l, time ), d );\n\n    // Output to screen\n    d = smoothstep( 0.0, 0.01, d );\n    vec3 col = mix( vec3(0.13,0.137,0.137), vec3(0.941,0.9647,0.941), clamp(d, 0., 1.));\n    fragColor = vec4(vec3(col),1.0);\n    //fragColor = vec4((l-p)*50.,0.0,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 2,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}