{
    "Shader": {
        "info": {
            "date": "1417027955",
            "description": "Left - BSDF sampling\nRight - Light sampling\nCenter - Combination those strategies using [b][url=https://graphics.stanford.edu/courses/cs348b-03/papers/veach-chapter9.pdf]MIS[/url][/b](E. Veach, and L. Guibas)\n",
            "flags": 0,
            "hasliked": 0,
            "id": "4sSXWt",
            "likes": 130,
            "name": "Direct Light using MIS",
            "published": 3,
            "tags": [
                "mis",
                "rendering",
                "realtime",
                "directlight",
                "unbiased"
            ],
            "usePreview": 1,
            "username": "koiava",
            "viewed": 11009
        },
        "renderpass": [
            {
                "code": "//Implementation of Multiple Importance Sampling technique(E.Veach 1995)\n//example shows MIS for direct light calculation\n//Idea behind technique is that every monte-carlo sampling technique has \n//variance and this variance comes from low probability of success.\n//So if you have 2 or more unbiased monte-carlo sampling techniques \n//which gives you different response on same situation you can predict \n//which of those responses contains more variance and weight them\n//correspondingly to decrease overal variance and stay unbiased.\n#define PIXEL_SAMPLES 2\n#define LIGHT_SAMPLES 2\n#define BSDF_SAMPLES 2\n#define FRAME_TIME 0.05\t//for motion blur\n#define IMPORTANCE_SAMPLE_LIGHTS\n#define SHADOWS\n\n//light sampling technique *******************\n#define IMPORTANCE_SAMPLE_LIGHT_SOURCE\n//#define SAMPLE_LIGHT_AREA\n#define SAMPLE_LIGHT_SOLIDANGLE\n//********************************************\n\n#define SHOW_PLANES\n#define SHOW_TEXT\n\n#define GAMMA 2.2\nconst vec3 backgroundColor = vec3( 0.2 );\n\n//used macros and constants\n#define HALF_PI \t\t\t1.5707963\n#define PI \t\t\t\t\t3.1415926\n#define TWO_PI \t\t\t\t6.2831852\n#define FOUR_PI \t\t\t12.566370\n#define INV_PI \t\t\t\t0.3183099\n#define INV_TWO_PI \t\t\t0.1591549\n#define INV_FOUR_PI \t\t0.0795775\n#define EPSILON \t\t\t0.0001\n#define IN_RANGE(x,a,b)\t\t(((x) > (a)) && ((x) < (b)))\n#define EQUAL_FLT(a,b,eps)\t(abs(a-(b))<eps)\n#define IS_ZERO(a) \t\t\tEQUAL_FLT(a,0.0,EPSILON)\n//********************************************\n\n#ifdef SHOW_TEXT\nstruct Disk {\n    vec2 position_;\n    float radius_innder_;\n    float radius_outter_;\n    float angle_begin_;\n    float angle_end_;\n};\n    \nstruct Box {\n    vec2 position_;\n    vec2 dimensions_;\t//positive\n};\n\nbool pointInBox( vec2 p, Box box ) {\n    if( IN_RANGE( p.x, box.position_.x, box.position_.x + box.dimensions_.x ) &&\n      \tIN_RANGE( p.y, box.position_.y, box.position_.y + box.dimensions_.y ) )\n        return true;\n    \n    return false;\n}\n\nbool pointInDisk( vec2 p, Disk disk ) {\n    Box bbox = Box(disk.position_ - vec2(disk.radius_outter_)*1.01, vec2(disk.radius_outter_)*2.01 );\n    \n    //primitive level culling\n    if( !pointInBox( p, bbox ) )\n        return false;\n    \n    vec2 v = p - disk.position_;\n    \n    float rho;\n    rho = sqrt( v.x*v.x + v.y*v.y );\n    \n    if( !IN_RANGE( rho, disk.radius_innder_, disk.radius_outter_ ) )\n        return false;\n    \n\tfloat theta = atan( v.y, v.x );\n    theta += PI;\n    \n    if( !IN_RANGE( theta, disk.angle_begin_, disk.angle_end_ ) )\n        return false;\n    \n    return true;\n}\n\nvec2 fontDim = vec2(5.0,5.0);\n\nbool is_point_on_B( vec2 p ) {\n    if( pointInBox( p, Box( vec2( 0.0, 0.0 ), vec2( 1.0, 5.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 1.0, 0.0 ), vec2( 0.5, 1.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 1.0, 2.0 ), vec2( 0.5, 1.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 1.0, 4.0 ), vec2( 0.5, 1.0 ) ) ) \t\t\t\t\t||\n       \tpointInDisk( p, Disk( vec2( 1.5, 1.5 ), 0.5, 1.5, HALF_PI, PI+HALF_PI ) ) \t||\n      \tpointInDisk( p, Disk( vec2( 1.5, 3.5 ), 0.5, 1.5, HALF_PI, PI+HALF_PI ) ) )\n        return true;\n    return false;\n}\n\nbool is_point_on_R( vec2 p ) {\n    if( pointInBox( p, Box( vec2( 0.0, 0.0 ), vec2( 1.0, 5.0 ) ) ) \t\t\t\t||\n       \tpointInBox( p, Box( vec2( 1.0, 2.0 ), vec2( 0.5, 1.0 ) ) ) \t\t\t\t||\n       \tpointInBox( p, Box( vec2( 1.0, 4.0 ), vec2( 0.5, 1.0 ) ) ) \t\t\t\t||\n       \tpointInBox( p, Box( vec2( 2.0, 0.0 ), vec2( 1.0, 1.5 ) ) ) \t\t\t\t||\n       \tpointInDisk( p, Disk( vec2( 1.5, 1.5 ), 0.5, 1.5, PI, PI+HALF_PI ) ) \t||\n      \tpointInDisk( p, Disk( vec2( 1.5, 3.5 ), 0.5, 1.5, HALF_PI, PI+HALF_PI ) ) )\n        return true;\n    return false;\n}\n\nbool is_point_on_D( vec2 p ) {\n    if( pointInBox( p, Box( vec2( 0.0, 0.0 ), vec2( 1.0, 5.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 1.0, 0.0 ), vec2( 0.5, 1.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 2.0, 1.5 ), vec2( 1.0, 2.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 1.0, 4.0 ), vec2( 0.5, 1.0 ) ) ) \t\t\t\t\t||\n       \tpointInDisk( p, Disk( vec2( 1.5, 1.5 ), 0.5, 1.5, HALF_PI, PI ) ) \t||\n      \tpointInDisk( p, Disk( vec2( 1.5, 3.5 ), 0.5, 1.5, PI, PI+HALF_PI ) ) )\n        return true;\n    return false;\n}\n\nbool is_point_on_F( vec2 p ) {\n    if( pointInBox( p, Box( vec2( 0.0, 0.0 ), vec2( 1.0, 5.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 1.0, 2.0 ), vec2( 1.5, 1.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 1.0, 4.0 ), vec2( 2.0, 1.0 ) ) ) )\n        return true;\n    return false;\n}\n\nbool is_point_on_I( vec2 p ) {\n    if( pointInBox( p, Box( vec2( 0.0, 0.0 ), vec2( 1.0, 5.0 ) ) ) )\n        return true;\n    return false;\n}\n\nbool is_point_on_M( vec2 p ) {\n    if( pointInBox( p, Box( vec2( 0.0, 0.0 ), vec2( 1.0, 5.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 4.0, 0.0 ), vec2( 1.0, 5.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 2.0, 2.0 ), vec2( 1.0, 3.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 1.0, 4.0 ), vec2( 3.0, 1.0 ) ) ) )\n        return true;\n    return false;\n}\n\nbool is_point_on_S( vec2 p ) {\n    if( pointInBox( p, Box( vec2( 0.0, 0.0 ), vec2( 1.5, 1.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 1.5, 4.0 ), vec2( 1.5, 1.0 ) ) ) \t\t\t\t\t||\n       \tpointInDisk( p, Disk( vec2( 1.5, 1.5 ), 0.5, 1.5, HALF_PI, HALF_PI+PI ) ) \t||\n       \tpointInDisk( p, Disk( vec2( 1.5, 3.5 ), 0.5, 1.5, HALF_PI+PI, TWO_PI ) ) \t||\n      \tpointInDisk( p, Disk( vec2( 1.5, 3.5 ), 0.5, 1.5, 0.0, HALF_PI ) ) )\n        return true;\n    return false;\n}\n\nbool is_point_on_L( vec2 p ) {\n    if( pointInBox( p, Box( vec2( 0.0, 0.0 ), vec2( 1.0, 5.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 0.0, 0.0 ), vec2( 3.0, 1.0 ) ) ) )\n        return true;\n    return false;\n}\n\nbool is_point_on_G( vec2 p ) {\n    if( pointInBox( p, Box( vec2( 0.0, 1.5 ), vec2( 1.0, 2.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 2.0, 3.0 ), vec2( 1.0, 0.5 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 1.5, 0.0 ), vec2( 1.5, 2.0 ) ) ) \t\t\t\t\t||\n       \tpointInDisk( p, Disk( vec2( 1.5, 1.5 ), 0.5, 1.5, 0.0, HALF_PI ) ) \t||\n      \tpointInDisk( p, Disk( vec2( 1.5, 3.5 ), 0.5, 1.5, PI, TWO_PI ) ) )\n        return true;\n    return false;\n}\n\nbool is_point_on_H( vec2 p ) {\n    if( pointInBox( p, Box( vec2( 0.0, 0.0 ), vec2( 1.0, 5.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 2.0, 0.0 ), vec2( 1.0, 5.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 1.0, 2.0 ), vec2( 1.0, 1.0 ) ) ) )\n        return true;\n    return false;\n}\n\nbool is_point_on_T( vec2 p ) {\n    if( pointInBox( p, Box( vec2( 1.0, 0.0 ), vec2( 1.0, 5.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 0.0, 4.0 ), vec2( 3.0, 1.0 ) ) ) )\n        return true;\n    return false;\n}\n\nbool is_point_on_BRDF( vec2 p ) {\n    //Object level culling\n    Box bbox = Box( vec2(0.0), vec2(16.0,5.0) );\n    if( !pointInBox( p, bbox ) )\n        return false;\n    \n    vec2 offsetVec = vec2( 0.0 );\n    \n    if( is_point_on_B( p ) ||\n      \tis_point_on_R( p - (offsetVec += vec2(4.0,0.0)) ) ||\n      \tis_point_on_D( p - (offsetVec += vec2(4.0,0.0)) ) ||\n      \tis_point_on_F( p - (offsetVec += vec2(4.0,0.0)) ) ) {\n        return true;\n    }\n    \n    return false;\n}\n\nbool is_point_on_MIS( vec2 p ) {\n    //Object level culling\n    Box bbox = Box( vec2(0.0), vec2(12.0,5.0) );\n    if( !pointInBox( p, bbox ) )\n        return false;\n    \n    vec2 v = vec2(fontDim.x + 1.0,0.0);\n    vec2 offsetVec = vec2( 0.0 );\n    \n    if( is_point_on_M( p ) ||\n      \tis_point_on_I( p - (offsetVec += vec2(6.0,0.0)) ) ||\n      \tis_point_on_S( p - (offsetVec += vec2(2.0,0.0)) )) {\n        return true;\n    }\n    \n    return false;\n}\n\nbool is_point_on_LIGHT( vec2 p ) {\n    //Object level culling\n    Box bbox = Box( vec2(0.0), vec2(20.0,5.0) );\n    if( !pointInBox( p, bbox ) )\n        return false;\n    \n    vec2 offsetVec = vec2( 0.0 );\n    \n    if( is_point_on_L( p ) ||\n      \tis_point_on_I( p - (offsetVec += vec2(4.0,0.0)) ) ||\n      \tis_point_on_G( p - (offsetVec += vec2(2.0,0.0)) ) ||\n      \tis_point_on_H( p - (offsetVec += vec2(4.0,0.0)) ) ||\n      \tis_point_on_T( p - (offsetVec += vec2(4.0,0.0)) )) {\n        return true;\n    }\n    \n    return false;\n}\n\n#endif\n\n\n#define MATERIAL_COUNT \t\t8\n#define BSDF_COUNT \t\t\t3\n#define BSDF_R_DIFFUSE \t\t0\n#define BSDF_R_GLOSSY \t\t1\n#define BSDF_R_LIGHT \t\t2\n\n//***********************************\n//sampling types\n#define SAMPLING_LIGHT\t\t\t\t0\n#define SAMPLING_BSDF\t\t\t\t1\n#define SAMPLING_LIGHT_AND_BSDF_MIS\t2\n#define SAMPLING_NONE\t\t\t\t3\nint samplingTechnique;\nfloat split1;\nfloat split2;\n\nvoid initSamplingTechnique(float p) {\n    float k = iMouse.x/iResolution.x;\n    if(iMouse.z<0.0 || iMouse.x==0.0) {\n      \tsplit1 = 0.0;\n        split2 = iResolution.x;  \n    } else {\n        split1 = iMouse.x*k;\n        split2 = iMouse.x + (iResolution.x-iMouse.x)*k;\n    }\n    \n    if(p < split1-1.0) {\n        samplingTechnique = SAMPLING_BSDF;\n    } else if((p > split1+1.0) && (p < split2-1.0)) {\n        samplingTechnique = SAMPLING_LIGHT_AND_BSDF_MIS;\n    } else if(p > split2+1.0){\n        samplingTechnique = SAMPLING_LIGHT;\n    } else {\n        samplingTechnique = SAMPLING_NONE;\n    }\n}\n//***********************************\n\n#define LIGHT_COUNT (4)\n#define LIGHT_COUNT_INV (0.25)\n#define WALL_COUNT \t(2)\n\n//MIS heuristics *****************************\n#define MIS_HEURISTIC_BALANCE\n//#define MIS_HEURISTIC_POWER\n\nfloat misWeightPower( in float a, in float b ) {\n    float a2 = a*a;\n    float b2 = b*b;\n    float a2b2 = a2 + b2;\n    return a2 / a2b2;\n}\nfloat misWeightBalance( in float a, in float b ) {\n    float ab = a + b;\n    \n    return a / ab;\n}\nfloat misWeight( in float pdfA, in float pdfB ) {\n#ifdef MIS_HEURISTIC_POWER\n    return misWeightPower(pdfA,pdfB);\n#else\n    return misWeightBalance(pdfA,pdfB);\n#endif\n}\n//********************************************\n            \n// random number generator **********\n// taken from iq :)\nfloat seed;\t//seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n//***********************************\n\n// Color corversion code from: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n//************************************************************************************\n\n\n//////////////////////////////////////////////////////////////////////////\n// Converting PDF from Solid angle to Area\nfloat PdfWtoA( float aPdfW, float aDist2, float aCosThere ){\n    if( aDist2 < EPSILON )\n        return 0.0;\n    return aPdfW * abs(aCosThere) / aDist2;\n}\n\n// Converting PDF between from Area to Solid angle\nfloat PdfAtoW( float aPdfA, float aDist2, float aCosThere ){\n    float absCosTheta = abs(aCosThere);\n    if( absCosTheta < EPSILON )\n        return 0.0;\n    \n    return aPdfA * aDist2 / absCosTheta;\n}\n//////////////////////////////////////////////////////////////////////////\n\n// Data structures ****************** \nstruct Sphere { vec3 pos; float radius; float radiusSq; float area; };\nstruct LightSamplingRecord { vec3 w; float d; float pdf; };\nstruct Plane { vec4 abcd; };\nstruct Range { float min_; float max_; };\nstruct Material { vec3 color; float roughness_; int bsdf_; };\nstruct RaySurfaceHit { vec3 N; vec3 E; int mtl_id; int obj_id; float dist; };\nstruct Ray { vec3 origin; vec3 dir; };\nstruct Camera { mat3 rotate; vec3 pos; float fovV; };\n//***********************************\n    \n// ************ SCENE ***************\nPlane walls[WALL_COUNT];\nSphere lights[LIGHT_COUNT];\n\n#ifdef SHOW_PLANES\n#define PLANE_COUNT (3)\nPlane planes[PLANE_COUNT];\nRange planeZRanges[PLANE_COUNT];\nfloat planeHalfWidth = 2.3;\n#endif\n//***********************************\n\n// ************************  INTERSECTION FUNCTIONS **************************\nbool raySphereIntersection( Ray ray, in Sphere sph, out float t ) {\n    t = -1.0;\n\tvec3  ce = ray.origin - sph.pos;\n\tfloat b = dot( ray.dir, ce );\n\tfloat c = dot( ce, ce ) - sph.radiusSq;\n\tfloat h = b*b - c;\n    if( h > 0.0 ) {\n\t\tt = -b - sqrt(h);\n\t}\n\t\n\treturn ( t > 0.0 );\n}\n\nbool rayPlaneIntersection( Ray ray, Plane plane, out float t ){\n    float dotVN = dot( ray.dir, plane.abcd.xyz );\n   \n    if ( abs( dotVN ) < EPSILON ) {\n        return false;\n    }\n    \n\tt = -(dot( ray.origin, plane.abcd.xyz ) + plane.abcd.w)/dotVN;\n    \n    return ( t > 0.0 );\n}\n// ***************************************************************************\n\nvoid updateScene(float t) {\n    //init lights\n    t *= 4.0;\n\n    float moveSize = 0.7;\n    float a = 0.0;\n    float speed = 2.0;\n    float val;\n    \n    //1\n    val = a+t*speed;    \n    lights[0].pos = vec3( -2.0, 1.4, -5.0 ) + vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(0)*LIGHT_COUNT_INV);\n    a += 0.4;\n    \n    //2\n    val = a+t*speed;    \n    lights[1].pos = vec3( -1.1, 1.4, -5.0 ) + vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(1)*LIGHT_COUNT_INV);\n    a += 0.4;\n    \n    //3\n    val = a+t*speed;    \n    lights[2].pos = vec3( 0.0, 1.4, -5.0 ) + vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(2)*LIGHT_COUNT_INV);\n    a += 0.4;\n    \n    //4\n    val = a+t*speed;    \n    lights[3].pos = vec3( 1.6, 1.4, -5.0 ) + vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(3)*LIGHT_COUNT_INV);\n    a += 0.4;\n}\n\nvoid initScene() {\n    //init lights\n    lights[0] = Sphere( vec3( -2.0, 1.4, -5.0 ), 0.05, 0.0025, 0.0314159 );\n\tlights[1] = Sphere( vec3( -1.1, 1.4, -5.0 ), 0.2, 0.04, 0.5026548 );\n\tlights[2] = Sphere( vec3( 0.0, 1.4, -5.0 ), 0.4, 0.16, 2.0106193 );\n\tlights[3] = Sphere( vec3( 1.6, 1.4, -5.0 ), 0.8, 0.64, 8.0424770 );\n    \n    float moveSize = 0.7;\n    float a = 0.0;\n    float speed = 2.0;\n    float val;\n    \n    //1\n    val = a+iTime*speed;    \n    lights[0].pos += vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(0)*LIGHT_COUNT_INV);\n    a += 0.4;\n    \n    //2\n    val = a+iTime*speed;    \n    lights[1].pos += vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(1)*LIGHT_COUNT_INV);\n    a += 0.4;\n    \n    //3\n    val = a+iTime*speed;    \n    lights[2].pos += vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(2)*LIGHT_COUNT_INV);\n    a += 0.4;\n    \n    //4\n    val = a+iTime*speed;    \n    lights[3].pos += vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(3)*LIGHT_COUNT_INV);\n    a += 0.4;\n    \n    //init walls\n    walls[0].abcd = vec4( normalize(vec3(0.0, 1.0, -EPSILON)), 1.0 );\n    //walls[0].abcd = vec4( 0.0, 1.0, 0.0, 1.0 );\n    walls[1].abcd = vec4( 0.0, 0.0, 1.0, 6.2 );\n    \n#ifdef SHOW_PLANES\n    //init planes\n    vec3 planeNormal = normalize( vec3( 0.0, 1.0, 1.2 ) );\n    planes[0].abcd = vec4( planeNormal, 3.8 );\n    planeZRanges[0].min_ = -5.8;\n    planeZRanges[0].max_ = -5.0;\n    \n    planeNormal = normalize( vec3( 0.0, 1.0, 0.7 ) );\n    planes[1].abcd = vec4( planeNormal, 2.8 );\n    planeZRanges[1].min_ = -4.8;\n    planeZRanges[1].max_ = -4.0;\n    \n    planeNormal = normalize( vec3( 0.0, 1.0, 0.3 ) );\n    planes[2].abcd = vec4( planeNormal, 1.8 );\n    planeZRanges[2].min_ = -3.8;\n    planeZRanges[2].max_ = -3.0;\n#endif\n}\n\n#define GET_LIGHT_SPHERE_CONST(i) lights[i]\n\n\nMaterial materialLibrary[MATERIAL_COUNT];\n\n#define INIT_MTL(i,bsdf,phongExp,colorVal) materialLibrary[i].bsdf_=bsdf; materialLibrary[i].roughness_=phongExp; materialLibrary[i].color=colorVal;\nvoid initMaterialLibrary()\n{\n    vec3 white = vec3( 1.0, 1.0, 1.0 );\n    vec3 gray = vec3( 0.8, 0.8, 0.8 );\n    \n    //walls\n    INIT_MTL( 0, BSDF_R_DIFFUSE, 0.0, white );\n\t\n    //planes\n    INIT_MTL( 1, BSDF_R_GLOSSY, 4096.0, gray );\n    INIT_MTL( 2, BSDF_R_GLOSSY, 128.0, gray );\n    INIT_MTL( 3, BSDF_R_GLOSSY, 32.0, gray );\n    \n    //lights\n    float totalIntencity = 6.0;\n    float min_x = lights[0].pos.x;\n    float max_x = lights[3].pos.x;\n    float x_range = max_x - min_x;\n    float h1 = ((lights[0].pos.x-min_x)/x_range)*0.6;\n    float h2 = ((lights[1].pos.x-min_x)/x_range)*0.6;\n    float h3 = ((lights[2].pos.x-min_x)/x_range)*0.6;\n    float h4 = ((lights[3].pos.x-min_x)/x_range)*0.6;\n    float s = 0.7;\n    float v1 = 1.0/(FOUR_PI*lights[0].radiusSq);\n    float v2 = 1.0/(FOUR_PI*lights[1].radiusSq);\n    float v3 = 1.0/(FOUR_PI*lights[2].radiusSq);\n    float v4 = 1.0/(FOUR_PI*lights[3].radiusSq);\n    \n    INIT_MTL( 4, BSDF_R_LIGHT, 0.0, hsv2rgb( vec3( h1, s, v1 ) )*totalIntencity );\n    INIT_MTL( 5, BSDF_R_LIGHT, 0.0, hsv2rgb( vec3( h2, s, v2 ) )*totalIntencity );\n    INIT_MTL( 6, BSDF_R_LIGHT, 0.0, hsv2rgb( vec3( h3, s, v3 ) )*totalIntencity );\n    INIT_MTL( 7, BSDF_R_LIGHT, 0.0, hsv2rgb( vec3( h4, s, v4 ) )*totalIntencity );\n}\n\nMaterial getMaterialFromLibrary( int index ){\n#if __VERSION__ >= 300\n    return materialLibrary[index];\n#else\n    if(index == 0) return materialLibrary[0];\n    if(index == 1) return materialLibrary[1];\n    if(index == 2) return materialLibrary[2];\n    if(index == 3) return materialLibrary[3];\n    if(index == 4) return materialLibrary[4];\n    if(index == 5) return materialLibrary[5];\n    if(index == 6) return materialLibrary[6];\n    return materialLibrary[7];\n#endif\n}\n\nvoid getLightInfo( in int index, out Sphere sphere, out vec3 intensity ) {\n#if __VERSION__ >= 300\n    sphere = lights[index];\n#else\n    if(index == 0) { sphere = lights[0]; } else\n    if(index == 1) { sphere = lights[1]; } else\n    if(index == 2) { sphere = lights[2]; } else\n    \t\t\t   { sphere = lights[3]; }\n#endif\n    intensity = getMaterialFromLibrary(4+index).color;\n}\n\n// Geometry functions ***********************************************************\nvec2 uniformPointWithinCircle( in float radius, in float Xi1, in float Xi2 ) {\n    float r = radius*sqrt(Xi1);\n    float theta = Xi2*TWO_PI;\n\treturn vec2( r*cos(theta), r*sin(theta) );\n}\n\nvec3 uniformDirectionWithinCone( in vec3 d, in float phi, in float sina, in float cosa ) {    \n\tvec3 w = normalize(d);\n    vec3 u = normalize(cross(w.yzx, w));\n    vec3 v = cross(w, u);\n\treturn (u*cos(phi) + v*sin(phi)) * sina + w * cosa;\n}\n\nvoid basis(in vec3 n, out vec3 b1, out vec3 b2) {\n    float sign_ = sign(n.z);\n\tfloat a = -1.0 / (sign_ + n.z);\n\tfloat b = n.x * n.y * a;\n\tb1 = vec3(1.0 + sign_ * n.x * n.x * a, sign_ * b, -sign_ * n.x);\n\tb2 = vec3(b, sign_ + n.y * n.y * a, -n.y);\n}\n\nvec3 localToWorld( in vec3 localDir, in vec3 normal ) {\n    vec3 a,b;\n    basis( normal, a, b );\n\treturn localDir.x*a + localDir.y*b + localDir.z*normal;\n}\n\nvec3 sphericalToCartesian( in float rho, in float phi, in float theta ) {\n    float sinTheta = sin(theta);\n    return vec3( sinTheta*cos(phi), sinTheta*sin(phi), cos(theta) )*rho;\n}\n\nvec3 sampleHemisphereCosWeighted( in vec3 n, in float Xi1, in float Xi2 ) {\n    float theta = acos(sqrt(1.0-Xi1));\n    float phi = TWO_PI * Xi2;\n\n    return localToWorld( sphericalToCartesian( 1.0, phi, theta ), n );\n}\n\nvec3 randomDirection( in float Xi1, in float Xi2 ) {\n    float theta = acos(1.0 - 2.0*Xi1);\n    float phi = TWO_PI * Xi2;\n    \n    return sphericalToCartesian( 1.0, phi, theta );\n}\n//*****************************************************************************\n\n\n// BSDF functions *************************************************************\nfloat evaluateBlinn( in  vec3 N, in vec3 E, in vec3 L, in float roughness ) {\n    vec3 H = normalize(E + L);\n    float cosTheta = dot(N,H);\n    return (roughness + 2.0) / (8.0 * PI) * pow(cosTheta, roughness);\n}\n\nfloat pdfBlinn(in vec3 N, in vec3 E, in vec3 L, in float roughness ) {\n    vec3 H = normalize(E + L);\n    float cosTheta = dot(N,H);\n\tfloat normalizationFactor = (roughness + 1.0) / TWO_PI;\n    return pow( cosTheta, roughness ) * normalizationFactor / (4.0 * dot(E, H));\n}\n\nvec3 sampleBlinn( in vec3 N, in vec3 E, in float roughness, in float r1, in float r2, out float pdf ) {\n    float cosTheta = pow( r1, 1.0/( roughness ) );\n    float phi = r2*TWO_PI;\n    float theta = acos( cosTheta );\n    vec3 H = localToWorld( sphericalToCartesian( 1.0, phi, theta ), N );\n    float dotNH = dot(H,N);\n    vec3 L = reflect( E*(-1.0), H );\n    \n    pdf = pdfBlinn(N, E, L, roughness );\n    \n    return L;\n}\n\nfloat evaluateLambertian( in vec3 N, in vec3 L ) {\n    return INV_PI;\n}\n\nfloat pdfLambertian( in vec3 N, in vec3 L ) {\n    return max(.0, dot( N, L )) * INV_PI;\n}\n\nvec3 sampleLambertian( in vec3 N, in float r1, in float r2, out float pdf ){\n    vec3 L = sampleHemisphereCosWeighted( N, r1, r2 );\n    pdf = pdfLambertian(N, L);\n    return L;\n}\n//*****************************************************************************\n\n///////////////////////////////////////////////////////////////////////\nvoid initCamera( in vec3 pos, in vec3 frontDir, in vec3 upDir, in float fovV, out Camera dst ) {\n\tvec3 back = normalize( -frontDir );\n\tvec3 right = normalize( cross( upDir, back ) );\n\tvec3 up = cross( back, right );\n    dst.rotate[0] = right;\n    dst.rotate[1] = up;\n    dst.rotate[2] = back;\n    dst.fovV = fovV;\n    dst.pos = pos;\n}\n\nRay genRay( in Camera camera, in vec2 pixel ) {\n\tvec2 iPlaneSize=2.*tan(0.5*camera.fovV)*vec2(iResolution.x/iResolution.y,1.);\n\tvec2 ixy=(pixel/iResolution.xy - 0.5)*iPlaneSize;\n    \n    Ray ray;\n    ray.origin = camera.pos;\n\tray.dir = camera.rotate*normalize(vec3(ixy.x,ixy.y,-1.0));\n\n\treturn ray;\n}\n\n\nbool raySceneIntersection( \tin Ray ray,\n                          \tin float distMin,\n                          \tout RaySurfaceHit hit ) {\n    hit.obj_id = -1;\n    hit.dist = 1000.0;\n    hit.E = ray.dir*(-1.0);\n    \n    //check lights\n    for( int i1=0; i1<LIGHT_COUNT; i1++ ){\n        float dist;\n        if( raySphereIntersection( ray, lights[i1], dist ) && (dist>distMin) && ( dist < hit.dist ) ) {\n            hit.dist = dist;\n          \tvec3 hitpos = ray.origin + ray.dir*hit.dist;\n    \t\thit.N = (hitpos - lights[i1].pos)*(1.0/lights[i1].radius);\n    \t\thit.mtl_id = 4 + i1;\n            hit.obj_id = i1;\n        }\n    }\n    \n    //check walls\n    for( int i=0; i<WALL_COUNT; i++ ){\n        float dist;\n        if( rayPlaneIntersection( ray, walls[i], dist ) && (dist>distMin) && (dist < hit.dist ) ){\n            hit.dist = dist;\n//            hit.pos = ray.origin + ray.dir*hit.dist;\n    \t\thit.N = walls[i].abcd.xyz;\n    \t\thit.mtl_id = 0;\n            hit.obj_id = LIGHT_COUNT + i;\n        }\n    }\n    \n#ifdef SHOW_PLANES\n    //check planes\n    for( int i=0; i<PLANE_COUNT; i++ ){\n        float dist;\n        if( rayPlaneIntersection( ray, planes[i], dist ) && (dist>distMin) && (dist < hit.dist ) ){\n            vec3 hitPos = ray.origin + ray.dir*dist;\n            if( (hitPos.z < planeZRanges[i].max_ ) && (hitPos.z > planeZRanges[i].min_) && (hitPos.x < planeHalfWidth ) && (hitPos.x > -planeHalfWidth ) ) {\n                hit.dist = dist;\n//                hit.pos = hitPos;\n                hit.N = planes[i].abcd.xyz;\n                hit.mtl_id = 1+i;\n                hit.obj_id = LIGHT_COUNT + WALL_COUNT + i;\n            }        \n        }\n    }\n#endif\n    \n    return ( hit.obj_id != -1 );\n}\n\nvoid sampleSphericalLight( in vec3 x, in Sphere sphere, float Xi1, float Xi2, out LightSamplingRecord sampleRec ) {\n#ifdef SAMPLE_LIGHT_AREA\n    vec3 n = randomDirection( Xi1, Xi2 );\n    vec3 p = sphere.pos + n*sphere.radius;\n    float pdfA = 1.0/sphere.area;\n    \n    vec3 Wi = p - x;\n    \n    float d2 = dot(Wi,Wi);\n    sampleRec.d = sqrt(d2);\n    sampleRec.w = Wi/sampleRec.d; \n    float cosTheta = max( 0.0, dot(n, -sampleRec.w) );\n    sampleRec.pdf = PdfAtoW( pdfA, d2, cosTheta );\n#else\n    vec3 w = sphere.pos - x;\t//direction to light center\n\tfloat dc_2 = dot(w, w);\t\t//squared distance to light center\n    float dc = sqrt(dc_2);\t\t//distance to light center\n    \n    if( dc_2 > sphere.radiusSq ) {\n    \tfloat sin_theta_max_2 = sphere.radiusSq / dc_2;\n\t\tfloat cos_theta_max = sqrt( 1.0 - clamp( sin_theta_max_2, 0.0, 1.0 ) );\n    \tfloat cos_theta = mix( cos_theta_max, 1.0, Xi1 );\n        float sin_theta_2 = 1.0 - cos_theta*cos_theta;\n    \tfloat sin_theta = sqrt(sin_theta_2);\n        sampleRec.w = uniformDirectionWithinCone( w, TWO_PI*Xi2, sin_theta, cos_theta );\n    \tsampleRec.pdf = 1.0/( TWO_PI * (1.0 - cos_theta_max) );\n        \n        //Calculate intersection distance\n\t\t//http://ompf2.com/viewtopic.php?f=3&t=1914\n        sampleRec.d = dc*cos_theta - sqrt(sphere.radiusSq - dc_2*sin_theta_2);\n    } else {\n        sampleRec.w = randomDirection( Xi1, Xi2 );\n        sampleRec.pdf = 1.0/FOUR_PI;\n    \traySphereIntersection( Ray(x,sampleRec.w), sphere, sampleRec.d );\n    }\n#endif\n}\n\nfloat sphericalLightSamplingPdf( in vec3 x, in vec3 wi, float d, in vec3 n1, in Sphere sphere ) {\n#ifdef SAMPLE_LIGHT_SOLIDANGLE\n    float solidangle;\n    vec3 w = sphere.pos - x;\t//direction to light center\n\tfloat dc_2 = dot(w, w);\t\t//squared distance to light center\n    float dc = sqrt(dc_2);\t\t//distance to light center\n    \n    if( dc_2 > sphere.radiusSq ) {\n    \tfloat sin_theta_max_2 = clamp( sphere.radiusSq / dc_2, 0.0, 1.0);\n\t\tfloat cos_theta_max = sqrt( 1.0 - sin_theta_max_2 );\n    \tsolidangle = TWO_PI * (1.0 - cos_theta_max);\n    } else { \n    \tsolidangle = FOUR_PI;\n    }\n    \n    return 1.0/solidangle;\n#else\n    float lightPdfA = 1.0/sphere.area;\n    float cosTheta1 = max( 0.0, dot( n1, -wi ) );\n    return PdfAtoW( lightPdfA, d*d, cosTheta1 );\n#endif\n}\n\nfloat lightChoosingPdf(in vec3 x, in int lightId) {\n#ifdef IMPORTANCE_SAMPLE_LIGHT_SOURCE\n    float cdf[LIGHT_COUNT];\n    \n    for(int i=0; i<LIGHT_COUNT; i++) {\n        float len = length(lights[i].pos - x);\n        cdf[i] = 1.0 / (len * len);\n    }\n    \n    for(int i=1; i<LIGHT_COUNT; i++) {\n        cdf[i] += cdf[i - 1];\n    }\n    \n    for(int i=0; i<LIGHT_COUNT; i++) {\n        cdf[i] /= cdf[LIGHT_COUNT-1];\n    }\n    \n    return cdf[lightId] - (lightId==0? 0.0 : cdf[lightId-1]);\n#else\n   \treturn 1.0/float(LIGHT_COUNT);\n#endif\n}  \t\n\nint chooseOneLight(in vec3 x, in float Xi, out float pdf) {\n#ifdef IMPORTANCE_SAMPLE_LIGHT_SOURCE\n    float cdf[LIGHT_COUNT];\n    \n    for(int i=0; i<LIGHT_COUNT; i++) {\n        float len = length(lights[i].pos - x);\n        cdf[i] = 1.0 / (len * len);\n    }\n    \n    for(int i=1; i<LIGHT_COUNT; i++) {\n        cdf[i] += cdf[i - 1];\n    }\n    \n    for(int i=0; i<LIGHT_COUNT; i++) {\n        cdf[i] /= cdf[LIGHT_COUNT-1];\n    }\n    \n    int id = 0;\n    for(int i=0; i<LIGHT_COUNT; i++) {\n        if(Xi < cdf[i]) {\n        \tid = i;\n            pdf = cdf[i] - (i==0? 0.0 : cdf[i-1]);\n            break;\n        }\n    }\n    \n    return id;\n#else\n   \tpdf = 1.0/float(LIGHT_COUNT);\n    return int(Xi*float(LIGHT_COUNT));\n#endif\n}\n\nvec3 sampleBSDF( in vec3 x, in RaySurfaceHit hit, in Material mtl, in bool useMIS ) {\n    vec3 Lo = vec3( 0.0 );\n    float bsdfSamplingPdf = 1.0/float(BSDF_SAMPLES);\n    vec3 n = hit.N * vec3((dot(hit.E, hit.N) < 0.0) ? -1.0 : 1.0);\n    \n    for( int i=0; i<BSDF_SAMPLES; i++ ) {\n        //Generate direction proportional to bsdf\n        vec3 bsdfDir;\n        float bsdfPdfW;\n        float Xi1 = rnd();\n        float Xi2 = rnd();\n        float strataSize = 1.0 / float(BSDF_SAMPLES);\n        Xi2 = strataSize * (float(i) + Xi2);\n        float brdf;\n        \n        if( mtl.bsdf_ == BSDF_R_GLOSSY ) {\n            bsdfDir = sampleBlinn( n, hit.E, mtl.roughness_, Xi1, Xi2, bsdfPdfW );\n            brdf = evaluateBlinn( n, hit.E, bsdfDir, mtl.roughness_ );\n        } else {\n            bsdfDir = sampleLambertian( n, Xi1, Xi2, bsdfPdfW );\n            brdf = evaluateLambertian( n, bsdfDir );\n        }\n        \n        float dotNWi = dot( bsdfDir, n );\n\n        //Continue if sampled direction is under surface\n        if( (dotNWi > 0.0) && (bsdfPdfW > EPSILON) ){\n            //calculate light visibility\n            RaySurfaceHit newHit;\n            if( raySceneIntersection( Ray( x, bsdfDir ), EPSILON, newHit ) && (newHit.obj_id < LIGHT_COUNT) ) {\n                //Get hit light Info\n                vec3 Li;\n                Sphere lightSphere;\n                getLightInfo( newHit.obj_id, lightSphere, Li );\n\n                //Read light info\n                float weight = 1.0;\n\t\t\t\tfloat lightPdfW;\n                if ( useMIS ) {\n                    lightPdfW = sphericalLightSamplingPdf( x, bsdfDir, newHit.dist, newHit.N, lightSphere );\n                    lightPdfW *= lightChoosingPdf(x, newHit.obj_id);\n                    weight = misWeight( bsdfPdfW, lightPdfW );\n                }\n\n                Lo += brdf*dotNWi*(Li/bsdfPdfW)*weight;\n            }\n        }\n    }\n\n    return Lo*bsdfSamplingPdf;\n}     \n\nvec3 sampleLight( \tin vec3 x, in RaySurfaceHit hit, in Material mtl, in bool useMIS ) {\n    vec3 Lo = vec3( 0.0 );\t//outgoing radiance\n    float lightSamplingPdf = 1.0/float(LIGHT_SAMPLES);\n   \n    for( int i=0; i<LIGHT_SAMPLES; i++ ) {\n        //select light uniformly\n        float Xi = rnd();\n        float strataSize = 1.0 / float(LIGHT_SAMPLES);\n        Xi = strataSize * (float(i) + Xi);\n        float lightPickPdf;\n        int lightId = chooseOneLight(x, Xi, lightPickPdf);\n\n        //Read light info\n        vec3 Li;\t\t\t\t//incomming radiance\n        Sphere lightSphere;\n        getLightInfo( lightId, lightSphere, Li );\n        \n        float Xi1 = rnd();\n        float Xi2 = rnd();\n        LightSamplingRecord sampleRec;\n        sampleSphericalLight( x, lightSphere, Xi1, Xi2, sampleRec );\n        \n        float lightPdfW = lightPickPdf*sampleRec.pdf;\n        vec3 Wi = sampleRec.w;\n        \n        float dotNWi = dot(Wi,hit.N);\n\n        if ( (dotNWi > 0.0) && (lightPdfW > EPSILON) ) {\n            Ray shadowRay = Ray( x, Wi );\n            RaySurfaceHit newHit;\n            bool visible = true;\n#ifdef SHADOWS\n            visible = ( raySceneIntersection( shadowRay, EPSILON, newHit ) && EQUAL_FLT(newHit.dist,sampleRec.d,EPSILON) );\n#endif\n            if(visible) {\n                float brdf;\n    \t\t\tfloat brdfPdfW;\t\t\t//pdf of choosing Wi with 'bsdf sampling' technique\n                \n                if( mtl.bsdf_ == BSDF_R_GLOSSY ) {\n                    brdf = evaluateBlinn( hit.N, hit.E, Wi, mtl.roughness_ );\n                    brdfPdfW = pdfBlinn(hit.N, hit.E, Wi, mtl.roughness_ );\t//sampling Pdf matches brdf\n                } else {\n                    brdf = evaluateLambertian( hit.N, Wi );\n                    brdfPdfW = pdfLambertian( hit.N, Wi );\t//sampling Pdf matches brdf\n                }\n\n                float weight = 1.0;\n                if( useMIS ) {\n                    weight = misWeight( lightPdfW, brdfPdfW );\n                }\n                \n                Lo += ( Li * brdf * weight * dotNWi ) / lightPdfW;\n            }\n        }\n    }\n    \n    return Lo*lightSamplingPdf;\n}\n\nvec3 Radiance( in Ray ray ) {\n    RaySurfaceHit hit;\n    if( raySceneIntersection( ray, 0.0, hit ) ) {\n    \tMaterial mtl = getMaterialFromLibrary( hit.mtl_id );\n\n        vec3 f, Le;\n\n        if( mtl.bsdf_ == BSDF_R_LIGHT ) {\n            Le = mtl.color;\n            f = vec3( 1.0, 1.0, 1.0 );\n        } else {\n            Le = vec3( 0.0 );\n            f = mtl.color;\n        }\n        \n        vec3 hitPos = ray.origin + ray.dir*hit.dist;\n            \n        vec3 directLight = vec3(0.0);\n        if( samplingTechnique == SAMPLING_LIGHT ) {\n            directLight += sampleLight( hitPos, hit, mtl, false );\n        } else if( samplingTechnique == SAMPLING_BSDF ) {\n            directLight += sampleBSDF( hitPos, hit, mtl, false );\n        } else {\n            directLight += sampleBSDF( hitPos, hit, mtl, true );\n            directLight += sampleLight( hitPos, hit, mtl, true );\n        }\n\n        return Le + f * directLight;\n    }\n\n    return backgroundColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = /*iTime +*/ iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    \n\tfloat sinTime = sin(iTime*0.2);\n    \n    Camera camera;\n    initScene();\n    initMaterialLibrary();\n    \n    vec2 splitterPos = iMouse.xy;\n    if ( splitterPos.x == 0.0 && splitterPos.y == 0.0 ) {\n        splitterPos = iResolution.xy*0.5;\n    }\n    initSamplingTechnique((iMouse.x==0.0)?iResolution.x*0.5:fragCoord.x);\n    \n    if(samplingTechnique == SAMPLING_NONE) {\n        fragColor = vec4( 1.0 );\n        return;\n    }\n\t\n    Ray ray;\n\tvec3 accumulatedColor = vec3( 0.0 );\n\tfor(int si=0; si<PIXEL_SAMPLES; ++si ){\n        //stratified sampling for t\n        float tprev = iTime;\n        float tnext = iTime+FRAME_TIME;\n        float tStrata = 1.0/float(PIXEL_SAMPLES);\n        float tnorm = tStrata*(float(si)+rnd());\n        float t = mix(tprev,tnext,tnorm);\n        \n        //for object motion blur\n        updateScene(t);\n        \n        //update camera for camera motion blur\n        vec3 cameraPos = vec3( 0.0, 1.0 + sin(t*0.45), 3.0 + sin(t*0.4)*3.0 );\n    \tvec3 cameraTarget = vec3( sin(t*0.4)*0.3, 0.0, -5.0 );\n    \tinitCamera( cameraPos, cameraTarget - cameraPos, vec3( 0.0, 1.0, 0.0 ), radians(45.0), camera );\n        \n        vec2 subPixelCoord = vec2(rnd(), rnd());\n        vec2 screenCoord = fragCoord.xy + subPixelCoord;\n        ray = genRay( camera, screenCoord );\n        \n        accumulatedColor += Radiance( ray );\n        \n#ifdef SHOW_TEXT\n        float fontScale = 3.2;\n        vec2 offset_brdf = vec2( 2.0*fontScale, 0.0 )*fontScale;\n        vec2 offset_mis = vec2( 1.5*fontScale, 0.0 )*fontScale;\n        vec2 offset_light = vec2( 2.0*fontScale, 0.0 )*fontScale;\n\n        if( is_point_on_BRDF( (screenCoord.xy - vec2(split1*0.5,iResolution.y*0.03) + offset_brdf )*(1.0/fontScale) ) ) {\n            float val = clamp(split1/iResolution.x, 0.0, 0.9 );\n            accumulatedColor += vec3( val ); \n        }\n        \n        if( is_point_on_MIS( (screenCoord.xy - vec2((split1+split2)*0.5,iResolution.y*0.03) + offset_mis )*(1.0/fontScale) ) ) {\n            float val = clamp((split2-split1)/(0.6*iResolution.x), 0.0, 0.9 );\n            accumulatedColor += vec3( val );\n        }\n        \n        if( is_point_on_LIGHT( (screenCoord.xy - vec2((split2+iResolution.x)*0.5,iResolution.y*0.03) + offset_light )*(1.0/fontScale) )) {\n            float val = clamp((iResolution.x-split2)/iResolution.x, 0.0, 0.9 );\n            accumulatedColor += vec3( val );\n        }\n#endif\n\t}\n\t\n\t//devide to sample count\n\taccumulatedColor = accumulatedColor*(1.0/float(PIXEL_SAMPLES));\n\t\n\t//gamma correction\n    accumulatedColor = pow( accumulatedColor, vec3( 1.0 / GAMMA ) );\n    \n\tfragColor = vec4( accumulatedColor,1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}