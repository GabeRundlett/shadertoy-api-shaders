{
    "Shader": {
        "info": {
            "date": "1621432328",
            "description": "i practiced writing raymarching and diffuse/specular lighting. \nI dont know why i needed to do the mod in line 55 instead of the scene(), but this way it works.",
            "flags": 0,
            "hasliked": 0,
            "id": "ftl3Rn",
            "likes": 4,
            "name": "specular Ray-Marching",
            "published": 3,
            "tags": [
                "raymarching",
                "specular"
            ],
            "usePreview": 0,
            "username": "vjbob0",
            "viewed": 410
        },
        "renderpass": [
            {
                "code": "#define pi (acos(-1.))\n\nvec2 rotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat tick(float t)\n{\n    t = smoothstep(0.,1.,t);\n    t = smoothstep(0.,1.,t);\n    t = smoothstep(0.,1.,t);\n    return t;\n}\n\nfloat noise(float a)\n{\n    return fract(sin(a*12.4312)*432.432423);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat scene(vec3 p)\n{\n    float fmode = (noise(floor(iTime/2.))*4.);\n    int mode = int(fmode);\n    float t = tick(fract(iTime/2.));\n    \n    \n    \n    \n    if (mode == 0)\n    p.xz = rotate(p.xz, t * pi /2.);\n    \n    if (mode == 1)\n    p.xz = rotate(p.xz, t * pi /-2.);\n    \n    if (mode == 2)\n    p.yx = rotate(p.yx, t * pi /-2.);\n    \n    if (mode == 3)\n    {\n        p.yx = rotate(p.yx, t * pi /2.);\n        p.xz = rotate(p.xz, t * pi /-2.);\n    }\n\n\n    return opSmoothSubtraction(sdOctahedron(p, 1.4),max(sdRoundBox(p, vec3(.8,.8,.8),.1),length(p)-1.2), .03);\n}\n\nvec3 getNormal(vec3 p)\n{\n\t//Sampling around the point\n\tvec2 o = vec2(0.01, 0.0);\n\tfloat d = scene(p);\n\tvec3 n = d - vec3(\n\t\t\t\t\tscene(p-o.xyy),\n\t\t\t\t\tscene(p-o.yxy),\n\t\t\t\t\tscene(p-o.yyx));\n\treturn normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n    \n    vec3 cam = vec3(0., 0, -3.);\n    vec3 dir = normalize(vec3(uv, 1));\n    vec3 lightPos = vec3(3., 3., -8.);\n    vec3 lightPos2 = vec3(-2, -3, -4.);\n    \n    float fmode = (noise(floor(iTime/2.))*5.);\n    int mode = int(fmode);\n    float tick = tick(fract(iTime/2.));\n    \n    \n    \n    \n    if (mode == 0)\n        cam.z += tick*20.;\n    \n    if (mode == 1)\n    {\n        cam.yx = rotate(cam.yx, tick*pi/2.);\n        dir.yx = rotate(dir.yx, tick*pi/2.);\n        lightPos.yx = rotate(lightPos.yx, tick*pi/2.);\n        lightPos2.yx = rotate(lightPos2.yx, tick*pi/2.);\n    }\n    if (mode == 2)\n    {\n        cam.xz = rotate(cam.xz, tick*pi/2.);\n        dir.xz = rotate(dir.xz, tick*pi/2.);\n        lightPos.xz = rotate(lightPos.xz, tick*pi/2.);\n        lightPos2.xz = rotate(lightPos2.xz, tick*pi/2.);\n    }\n    \n    if (mode == 3)\n    {\n        cam.xz = rotate(cam.xz, tick*pi/-2.);\n        dir.xz = rotate(dir.xz, tick*pi/-2.);\n        lightPos.xz = rotate(lightPos.xz, tick*pi/-2.);\n        lightPos2.xz = rotate(lightPos2.xz, tick*pi/-2.);\n    }\n    if (mode == 4)\n        cam.z += tick*-20.;\n    \n    \n    \n    float t = 0.;\n    float k = 0.;\n    int i;\n    vec3 p;\n    for(i; i<100; i++)\n    {\n        p = cam + dir * t;\n        p = mod(p, 4.)-2.;\n        k = scene(p);\n        t += k;\n        if(k < 0.001) break;\n    }\n    \n    vec3 h = cam + dir * t;\n    h = mod(h, 4.)-2.;\n    vec3 n = getNormal(h);\n    \n    //diffuse light\n    vec3 light = normalize(lightPos - h);\n    vec3 diffuse_color = vec3(0.784, 0.086, 0.792)*.7;\n    diffuse_color = dot(h, light) * diffuse_color;\n    \n    float shininess = 30.0;\n    float specular_intensity = pow(max(dot(n, light), 0.0), shininess);\n    vec3 specular_color = vec3( 0.941, 0.662, 0.498); // red\n    specular_color = specular_intensity * specular_color;\n    \n    vec3 light2 = normalize(lightPos2 - h);\n    vec3 diffuse_color2 = vec3(0.086, 0.749, 0.792);\n    diffuse_color2 = dot(h, light2) * diffuse_color2;\n    \n    float shininess2 = 100.0;\n    float specular_intensity2 = pow(max(dot(n, light2), 0.0), shininess2);\n    vec3 specular_color2 = vec3(0.133, 0.788, 0.737); // red\n    specular_color2 = specular_intensity2 * specular_color2;\n    \n    float fog = 1. - (float(i)/100.);\n\n    \n    fragColor.rgb = ((diffuse_color + specular_color) + (diffuse_color2 + specular_color2)/2.) * fog;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}