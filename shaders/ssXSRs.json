{
    "Shader": {
        "info": {
            "date": "1619041476",
            "description": "abstract futuristic structure in black and white",
            "flags": 40,
            "hasliked": 0,
            "id": "ssXSRs",
            "likes": 12,
            "name": "already there",
            "published": 3,
            "tags": [
                "raymarch",
                "sound",
                "fm",
                "pathtracer",
                "scifi",
                "synth",
                "warmandclose",
                "detuned",
                "futurism"
            ],
            "usePreview": 0,
            "username": "nabr",
            "viewed": 460
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 c = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if(abs(fragCoord.x*2.-iResolution.x)/iResolution.y<1.3)\n    fragColor = vec4(3.2*(c.xyz/c.w)+.05, 1);//contrast,brightness\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// hash and seed demofox>website>pathtracing-tutorial\nuint wang_hash(inout uint seed){seed=uint(seed^uint(61))^uint(seed>>uint(16));seed*=uint(9);seed=seed^(seed>>4);seed*=uint(0x27d4eb2d);seed=seed^(seed>>15);return seed;}\nfloat hashf(inout uint state){return float(wang_hash(state))/4294967296.;}\n//smoothUnion and sdBox by iq>website\nfloat sU( float d1, float d2, float k ){float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );return mix( d2, d1, h ) - k*h*(1.0-h); }\nfloat sdBox(vec3 p, vec3 s) {p = abs(p) - s;return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);}\n#define dmin(a,b)((a.x<b.x)?a:b)\nvec2 f(vec3 p) \n{   \n    float c = 2.5;\n    //room\n    float rm = sdBox(vec3(p.x, p.y-.4, p.z), vec3(3, 1.5, 5.));\n    rm = abs(rm);\n    //door\n    float lt = sdBox(vec3(p.x, p.y+.15, p.z+4.95), vec3(.25, .5, .15));\n    float ppz = (p.z +1.2);\n    //circular lights\n    vec3 vslt = vec3(.8 * .5 - mod( max(0., cos(.2*p.z) + atan(p.y, p.x) ), .8),  length(p.xy) - 1.25,\n    ppz - c * clamp(round(ppz / c), -1., 1.5) );\n    vslt = abs(vslt) - vec3(.01, .01, 1.);\n    float slt = length(max(vec3(0), vslt)) + min(max(vslt.x, max(vslt.y, vslt.z)), 0.) -0.01;\n    //tubelights\n    float lz = p.z - c * clamp(round(p.z / c), -1., 1.);\n    float rr = length(vec2(min(-(length(vec2(p.x, p.y)) - 1.25), max(-1., p.y + .75)), lz)) - .05;\n    //frame \n    float fr = sdBox(vec3(lz,length(vec2(max(1., abs(p.x)),min(p.y - .45, -max(0.5, abs(p.y + .1) - .4)))) - 1.6, lz),vec3(.1, .05, 1));\n    //connections\n    float hlt = sdBox(vec3(2.*.5-mod(max(0.,atan(p.y, p.x) * 7.639), 2.),lz, length(vec2(p.x, p.y)) - 1.4), vec3(.1, .05, .3));\n    //path\n    float wlk = sdBox(vec3(p.x,p.y+.7,p.z), vec3(.35, .05, 3.8));\n    \n    return dmin(dmin(vec2(min(sU(fr, hlt, .1), rm), 11), dmin(vec2(rr, 7),vec2(min(slt, lt), 5))), vec2(wlk, 13));;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    if(iFrame > 0)fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec3 col = vec3(1e-6);\n    vec2 R = iResolution.xy,  h = vec2(0);\n    uint seed = (uint(fragCoord.x) * 1973u + uint(fragCoord.y) * 9277u + uint(iFrame) * 2669u) | 1u;\n    vec2 jjt = vec2(cos(R.y*hashf(seed)),sin(R.y*hashf(seed))),st =((fragCoord+jjt)*2.-R)/R.y;\n    vec3 ro = vec3(0,0,4.9),rd = normalize(vec3(st,-1.7));\n    vec3 memi = vec3(0), hput = vec3(.974);\n    if(abs(st.x)<1.3)\n    for(int b = 1; b < 6 + min(iFrame, 0); b++) \n    {\n        float t = 0.;\n        for(int i = 0; i < 80; i++) \n        {\n            h = f(ro + t * rd );\n            if(abs(h.x) < t *.001 || t > 10.)break;\n            t += h.x;\n        }\n       ro += t * rd;\n       //lights  - backward tracing from an artistically thought light source\n       vec3 ld = (h.y!=13.&&h.y!=7.)?(vec3(0, 3, .5 ) - ro):(vec3(0, 1., -5. ) + ro);\n       ld = normalize(ld);\n       //http://lolengine.net/blog/2013/09/21/picking-orthogonal-vector-combing-coconuts\n       vec3 u = ((ld.x > ld.z ) ? vec3(-ld.y, ld.x, 0.) : vec3(0., -ld.z, ld.y)), v = cross(ld, u);\n       float phi = hashf(seed) * 6.283185, th = hashf(seed) * 2. - 1.,sth = sin(th);\n       rd =  normalize(u * cos(phi) * sth + v * sin(phi) * sth + ld * cos(th));\n       //dim the tube lights\n       if(h.y==5.){hput = vec3(.9);memi=vec3(.3);}\n       if(h.y==7.){hput = vec3(.1);memi=vec3(.1);}\n       col += memi * hput;\n    }\n    //reinhard gamma\n    col= col/(1.+col); \n    fragColor += vec4(pow(col,vec3(0.4545)),1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define _f(x) fract(x)\n\nfloat f(float tm, float rt, int ch )\n{\n    float f = 0., ff = 0., ft1 = _f(.5 * tm);\n    \n    f = sin(4186.01 * rt) * exp(-3.588 * ft1);\n    f *= min(1., 1378.125 * ft1) * max(0., 1. - ft1);\n    ff = f;\n    if (ch == 0)\n        ff *= cos(tm + 220.00 * exp(-0.01 * pow(1. - ft1, 12.))); // tremolo\n          // fuzzy\n          //the hairiness in all of this much more subtle with higher floating point res. \n          //such as desktop opengl compute shader, readpixels from 32 bit floating point texture\n    float fu = .8*sin(tm); // cos(tm) nummericly correct i just like the sin sound more \n    \n    //based on one pole filter push the lows then duck the  heights\n    return sin(sin(fu + f * 3.141594) + .1) / (1.725 - cos(10. * ff));\n}\nvec2 mainSound(int samp, float time)\n{\n    vec2 y = vec2(1e-6), b = y;\n    float Fs = (1. / iSampleRate);\n    float t0 = float( samp ) * Fs, x = 1., a = t0, t1 = t0,\n          dtn = .3*cos(6.*a)+sin(3.*a);\n    int it = 5;\n    for(int i=0;i<it;i++)\n    {\n        if(time>12.&&1.< time/11.)\n        {\n        float bft =t1;\n        vec2 bt = vec2(4.,3.);\n        if(time>43.)bt+=1.;\n        if(time>25.){\n            bft = ((mod(t1, bt.x)  < bt.y) ? t1: 2. * t1 );\n            }\n        float u = .25 * bft *vec3(1.5, 1.25, .5)[ abs(i + int( bft )) %3];\n        b += vec2( f( 3.+ t1 , u, 1  ), f(4.+t1,  u, 1 ) );\n        dtn *= .2;\n        }\n        float mx = i == 0 ? .5 : 1.;\n        y += vec2(f(.1*a+21., mx * t0  + 1.57, 0), f(.1*a+11., mx * t0  + 3.1, 0));\n        x +=  .5 - Fs * dtn;\n        a += t0;\n        t0 = abs(.5 * t0 * ( .5  - x));\n        t1 = abs(t1 * ( 1. - x));\n    }\n    return vec2( 1./float(2*it) ) * (b+y);\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}