{
    "Shader": {
        "info": {
            "date": "1518581527",
            "description": "Happy Valentine's Day, 2018, to my wife and daughters.",
            "flags": 64,
            "hasliked": 0,
            "id": "XdcyW8",
            "likes": 21,
            "name": "I love you all",
            "published": 3,
            "tags": [
                "distanceestimation",
                "heart"
            ],
            "usePreview": 0,
            "username": "huttarl",
            "viewed": 9620
        },
        "renderpass": [
            {
                "code": "// Distance estimation: thanks to https://iquilezles.org/articles/distance\n\n/* Tweaks to try:\n - fill in the hearts (where heart(p) < 0)  With what texture?\n*/\n\n// My daughter requested stripes.\n// #define STRIPES 1\n// #define SOLID_HEARTS 1\n\n// heart(p) = 0 is a heart-shaped curve.\n\n#define EQUATION 2\n\n#if EQUATION == 1\n\n// See https://math.stackexchange.com/a/438161\n// This one has burrs/discontinuities on the sides.\nfloat heart(vec2 p) {\n    float k = dot(p, p) - 1.;\n    return k * k * k - p.x * p.x * p.y * p.y * p.y;\n}\n\n// Gradient of heart function, analytical version, thanks to IQ.\nvec2 grad(vec2 p) {\n    float k = dot(p, p) - 1.;\n    return p * (6.0 * k * k - p.yx * p.yx * p.y * vec2(2.0, 3.0));\n}\n\n#else\n\n// Heart curve suggested by IQ, improved by Dave_Hoskins.\nfloat heart(vec2 p) {\n    // Center it more, vertically:\n    p.y += .6;\n    // This offset reduces artifacts on the center vertical axis.\n    const float offset = .3;\n    // (x^2+(1.2*y-sqrt(abs(x)))^2âˆ’1)\n    float k = 1.2 * p.y - sqrt(abs(p.x) + offset);\n    return p.x * p.x + k * k - 1.;\n}\n\n// Gradient of heart function.\n// TODO: make it analytic.\n// For now, use central differences method.\nvec2 grad(vec2 p) {\n    vec2 h = vec2(0.01, 0.0);\n    return vec2(heart(p + h.xy) - heart(p - h.xy),\n                heart(p + h.yx) - heart(p - h.yx)) / (2.0 * h.x);\n}\n\n#endif\n\n// Return 0-1 scalar based on abs distance from heart line.\nfloat color(vec2 p, float vol) {\n    float v = heart(p);\n#ifdef SOLID_HEARTS\n    if (v < 0.) return 0.;\n#endif\n    vec2  g = grad(p);\n    float de = abs(v) / length(g);\n    // Thickness: vary with volume\n    float eps = (15. + vol * 3.)/iResolution.x;\n    return smoothstep(1.0 * eps, 2.0 * eps, de);\n}\n\n// from https://github.com/hughsk/glsl-hsv2rgb/blob/master/index.glsl\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nconst float pi = 3.14159;\n\nvec3 heart1(vec2 p, int i, float vol) {\n    vec2 offset = vec2(0.);\n    float scale = .7;\n    float a;\n    vec3 hue;\n    \n    switch (i) {\n        case 0:\n            hue = vec3(1., .3, .3); \n            a = pi * 0. - iTime * .3; \n            offset = vec2(cos(a), sin(a)) * .03;\n            break;\n        case 1:\n            hue = vec3(.6, .6, 1.); \n            a = pi * 1. - iTime * .3; \n            offset = vec2(cos(a), sin(a)) * .03;\n            break;\n        default:\n            hue = hsv2rgb(vec3(float(i) / 5. + iTime * .2, .4, .9));\n            a = pi * (float(i) - 2.) * (2. / 5.) + iTime * .3; \n            offset = vec2(cos(a), sin(a)) * .2;\n            scale = .3 + (float(i) * .05);\n    }\n\n    vec2 q = (p + offset) / (scale * (1.0 + vol * .3) * .8);\n    float brightness = 1. - color(q * 10., vol);\n    return brightness * hue;\n}\n\nconst int nLevels = 32;\n\n// Adapted from https://www.shadertoy.com/view/4tjBRz\n// TO DO: would like to use buffers to make the effects of volume\n// ease in and out, instead of sudden spikes.\nfloat soundVolume() {\n    float total = 0.0, maxVol = 0.0;\n    for( int i = 0; i < nLevels; i++ )\n    {\n        float v = texelFetch(iChannel0, ivec2((i*256)/nLevels, 1), 0).x-0.5;\n        maxVol = max(maxVol, v*v);\n        total += v*v;\n    }\n    // Split the difference between average and max.\n    float vol = (total / float(nLevels) + maxVol) * 0.5;\n    // Attempt to smooth out the maximum.\n    return pow(vol, 0.1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.xx;\n    \n    float vol = soundVolume();\n    \n    vec3 col = vec3(0.);\n    for (int i = 0; i < 7; i++) {\n        col += heart1(uv, i, vol);\n    }\n\n#ifdef STRIPES\n    float y = floor(mod(uv.y, .2) * 5. * 3.) / 3.;\n    vec3 background = vec3(1., y, y);\n#else\n    vec3 background = mix(vec3(.1), vec3(1., 0., 0.), vol * .2);\n#endif\n    \n    fragColor = vec4(col + background, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 13555,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/rockcreekfellowship/oh-the-deep-deep-love-of-jesus"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}