{
    "Shader": {
        "info": {
            "date": "1719943062",
            "description": "original on shadertoy",
            "flags": 0,
            "hasliked": 0,
            "id": "M3GSWD",
            "likes": 2,
            "name": "SDF exprement ",
            "published": 3,
            "tags": [
                "sdf"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 100
        },
        "renderpass": [
            {
                "code": "float sdCircle(vec2 circlePos, vec2 pos, float radius) {\n   \n    return length(circlePos - pos) - radius;\n  \n}\n\n#define PI (3.14159265)\n#define TAU (2.*PI)\n\nfloat xTime;\nvoid IniTime() {\n    xTime = min( iTime, float(iFrame) / 10. ); // slow time on slower hardware\n}\n#define iTime xTime\n\n\n#define max3(V) max((V).x,max((V).y,(V).z))\n#define min3(V) min((V).x,min((V).y,(V).z))\n#define add3(V) ((V).x+(V).y+(V).z)\n\n#define MIN3(a,b,c) min(min(a,b),c)\n#define MIN4(a,b,c,d) min(min(a,b),min(c,d))\n#define MIN5(a,b,c,d,e) min(min(a,b),min(c,min(d,e)))\n\n#define MAX3(a,b,c) max(max(a,b),c)\n#define MAX4(A,B,C,D) max(max(A,B),max(C,D))\n#define MAX6(A,B,C,D,E,F) max(max(max(A,B),max(C,D)),max(E,F))\n\n\n#define OSC(L,H,T) ( ( sin(T) + 1. ) / 2. * ( (H) - (L) ) + (L) )\n\n#define MARGIN .1\n\n#define ROTT(V,T) vec2( (V).x*cos(T) + (V).y*sin(T), (V).y*cos(T) - (V).x*sin(T) )\n\n#define ROTATE \\\n    rot *= iTime*1.5; \\\n    /*p.xz = ROTT((p.xz),rot.z);*/ \\\n    p.xy = ROTT((p.xy),rot.x); \\\n    p.yz = ROTT((p.yz),rot.y); \\\n    \n//#define ROTATE   // no rotation\n\n\n// originally iq sdf of orthogonal box at 0 https://www.shadertoy.com/view/Xds3zN\nfloat SkewedBoxSDF(vec3 p,vec3 orig,vec3 box,vec3 rot)\n{\n    p -= orig;\n    ROTATE\n    p.x -= .5*p.y; // mess it up a ittle\n    vec3 d = abs(p) - box; // everything is symmetrical so just 3 sides need examination\n    return min(max3(d),.0) + length(max(d,.0));\n}\n\n// originally https://www.shadertoy.com/view/MtV3Dy but I simplified it\nfloat tetrahedron(vec3 p,float d) {\n    float sd1 = -p.x + p.y + p.z;\n    float sd2 =  p.x - p.y + p.z;\n    float sd3 =  p.x + p.y - p.z;\n    float sd4 = -p.x - p.y - p.z;\n    return (MAX4(sd1,sd2,sd3,sd4) - d)/sqrt(3.);\n}\n\n\nfloat TetrahedronSDF(vec3 p,vec3 orig,float d,vec3 rot) {\n    p -= orig;\n    //p.yx *= 1.+p.z/5.;\n    ROTATE\n    return tetrahedron(p,d);\n}\n\n\nfloat OctahedronSDF(vec3 p,vec3 orig,float d,vec3 rot) {\n    p -= orig;\n    float q = length(p) - d / 3.;\n    if ( q < 1. ) return q;\n    ROTATE\n    //The octahedron is the intersection of two dual tetrahedra.  \n    float a = tetrahedron(p,d);\n    float b = tetrahedron(-p,d);\n    return max(a,b);\n}\n\n// also originally https://www.shadertoy.com/view/MtV3Dy \n//Golden mean and inverse -  for the icosohedron and dodecadron\n#define PHI 1.6180339887\n#define INV_PHI 0.6180339887\n\nfloat DodecahedronSDF(vec3 p,float d,vec3 orig,vec3 rot) {\n    p -= orig;\n    float q = length(p) - d;\n    if (q > 2.) return q-1.; // if a bit outside, indicate outside\n \n    if ( q < OSC(d/4.,-.2,iTime) ) // amount of outside\n       return q+d/3.; // sphere size\n\n    ROTATE\n    \n    vec3 v = normalize(vec3(0.0,1.0,PHI));\n    vec3 w = normalize(vec3(0.0,1.0,-PHI));\n    \n    p = abs(p);\n    \n    // v.x=w.x=0;  v.y=w.y=.525731;  w.z=-v.z=.85065074\n    \n    //float d1x = 0.; //p.x*v.x - d*v.x*v.x;\n    float d1y = p.y*v.y - d*v.y*v.y;\n    float d1z = p.z*v.z - d*v.z*v.z;\n    float d1 = d1y + d1z; // dot(p-d*v,v);  \n\n    //float d2x = 0.; //p.x*v.x - d*v.x*v.x;\n    float d2y = p.y*w.y - d*w.y*w.y;\n    float d2z = p.z*w.z - d*w.z*w.z;\n    float d2 =  d2y + d2z; // dot(p-d*w,w);\n    \n    float d3x = p.x*v.z - d*v.z*v.z;\n    //float d3y = 0.; // p.y*v.x - d*v.x*v.x;\n    float d3z = p.z*v.y - d*v.y*v.y;\n    float d3 =  d3x + d3z; // dot(p-d*v.zxy,v.zxy);\n  \n    float d4 = dot(p-d*v.yzx,v.yzx);\n    float d5 = dot(p-d*w.zxy,w.zxy);\n    float d6 = dot(p-d*w.yzx,w.yzx);\n    float ds = MAX6(d1,d2,d3,d4,d5,d6);\n    return ds;\n} \n\nfloat SpherexSDF(vec3 p,vec3 orig,float siz) {\n    p.x -= 10. / p.y; // distort\n    return distance(p,orig) - siz;\n}\n\nfloat TetrahedronSDF(vec3 p,vec3 orig,float siz,vec3 dist,vec3 rot) {\n    p -= orig;\n    ROTATE\n    p = abs(p);\n    p *= dist; // distort\n    return sqrt( add3(p) ) - sqrt(siz); // stumbled on this one\n}\n\nfloat SpikeySDF(vec3 p,vec3 orig,float siz,vec3 spikes,vec3 rot) {\n    p -= orig;\n    // enclosing sphere for quick elimination of intersection:\n    float j = length(p) - siz*4.; // sdf for enclosing sphere\n    if (j > .2) return j-.1; // if a bit outside sphere, indicate outside of sphere\n    ROTATE\n    p = abs(p);\n    return sqrt(\n      pow( p.x, spikes.x ) + \n      pow( p.y, spikes.y ) + \n      pow( p.z, spikes.z ) \n    ) - siz/3.;\n}\n\n\nfloat CubexSDF(vec3 p,vec3 org,float siz,vec3 dist,vec3 rot){\n    p -= org;\n    float lim=.35;\n    float amt=.16;\n    // enclosing box for quick elimination of intersection:\n    float j = max3(abs(p)) - siz/amt; // sdf for enclosing box\n    if (j > .2) return j+.1; // if a bit outside box, indicate outside of box\n    ROTATE\n    p = abs(p);\n    \n    vec3 q = p;\n    q.x *= max(lim,1.-(p.y+p.z)*amt);\n    q.y *= max(lim,1.-(p.x+p.z)*amt);\n    q.z *= max(lim,1.-(p.y+p.x)*amt);\n    return max3(q) - siz;\n}\n\nfloat SDF(vec3 p,vec3 orig,vec3 siz,vec3 rot) { \nvec4 q;\n  p.xy*=mat2(cos(iTime),sin(iTime),-sin(iTime), cos(iTime));\n  q.xwz = p.xxy;\n    float lim=.35;\n    float amt=.16;\n  q.x *= max(lim,1.-(p.y+p.z)*amt);\n  q.zw*=mat2(cos(iTime),sin(iTime),-sin(iTime), cos(iTime));\n   \n \n    p += siz; \n    return length(p+q.x*q.z)-1.;\n}\n\n\n\nvec2 Dist(vec3 pt) {\n    vec2 hit = vec2(100,0);\n    float tmp, clr = 0.;\n#define T(SDF) if ( (tmp = SDF) < hit.x ) hit = vec2(tmp,clr); clr += 1.;\n \n     T(SDF(pt,vec3(-1.,2.,3.),vec3(-1.),vec3(-1.0,-2.5,-5.5)));\n     \n T(TetrahedronSDF(pt,vec3(2.2+10.*cos(iTime),2.2+10.*sin(iTime),2.2+10.*sin(iTime)),5.,vec3(.9,.7,OSC(.3,1.,0.)),vec3(.6,.7,.5)));\n   T(CubexSDF(pt,vec3(2.2-10.*cos(iTime),2.2-10.*sin(iTime),0),1.,vec3(2.8),vec3(2.75)));\n     \n    return hit;\n}\n\nvec4 March(vec3 beg,vec3 dir) { // return intersection point and object of ray\n    float dist = 0.;\n    vec3 pos;\n    for ( int stps = 0; stps < 300; ++stps ) {\n        pos = beg + dir * dist;\n        vec2 obj = Dist( pos );\n        dist += obj.x;\n        if ( dist > 200. ) return vec4( pos, 91. );\n        if ( obj.x < .001 ) return vec4( pos, obj.y );\n    }\n    return vec4( pos, 90. );\n}\n\nvec3 Normal(vec3 pt) {\n    float delta = .001; // large delta gives rounded corners\n    vec3 norm = Dist(pt).x - vec3(\n        Dist(pt-vec3(delta, 0., 0.)).x, \n        Dist(pt-vec3( 0.,delta, 0.)).x, \n        Dist(pt-vec3( 0., 0.,delta)).x );\n    return normalize( norm );\n}\n\nfloat sqrN(float i,int n)\n{\n  while ( n-- > 0 ) i *= i;\n  return i;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy) / iResolution.y;\n     IniTime(); // slow down on slow hardware\n     vec4 O=fragColor;\n     vec2 U = fragCoord;\n    vec2 R = iResolution.xy;\n    vec2 uv2 = (U+U-R) / min(R.x,R.y);  // -1 ... +1\n    uv2 /= 5.;\n    vec3 cam = vec3( 0, 0, -50.);\n    vec3 camdir = normalize( vec3( uv2, 1. ) );\nvec2 o_trn = (fragCoord.xy-iResolution.xy*.5)/iResolution.yy;\n        \n    float n_its = 12.;\n    \n    float n_tau = 6.2831;\n    vec4 o_col_min = vec4(0.);\n    vec4 o_col = vec4(0.);\n\n    for(float n_it_nor = .0; n_it_nor<1.;n_it_nor+=(1./n_its)){\n\n        float n_radius = (sin(n_it_nor*n_tau+iTime)*.5+.5)*.8;\n        float n = length(o_trn*(1./n_radius));\n        n = clamp(abs(n-.5)*2., 0., 1.);\n        float n_exponent = n_its;\n        n = pow(1.-n, n_exponent);\n\n        o_col += vec4(n)*vec4(n_it_nor, 1.-n_it_nor, fract(.5+n_it_nor), 1.);\n        \n    }\n    fragColor = o_col;\n    vec4 hit = March( cam, camdir );\n\n    vec3 Light = vec3( 0, 10, -10 );\n    vec3 dir = normalize( Light - hit.xyz );\n\n    vec3 norm = Normal(hit.xyz);\n    float difu = dot( norm, dir );\n    difu = 0.5 + .7*difu;\n    \n    #define color4(X) ( 0.15 + .3 * cos( vec4(1,1,23,10) + (X) ) )\n    \n    O = sqrt( color4(hit.w*2.1) );\n    O *= difu + sqrN(difu,10);\n    \n \n    float flag = -1.0;\n    \n    for( int i=0; i<20; i++) {\n       \n\t\tfloat pha =      sin(float(i)*546.13+1.0)*0.5 + 0.5;\n\t\tfloat siz = pow( sin(float(i)*651.74+5.0)*0.5 + 0.5, 4.0 );\n\t\tfloat pox =      sin(float(i)*321.55+4.1) * iResolution.x / iResolution.y;\n\n\n\t\tfloat rad = 0.1 + 0.5*siz;\n\t\tvec2  cirPos = vec2( pox, -1.0-rad + (2.0+2.0*rad)*mod(pha+0.1*iTime*(0.2+0.8*siz),1.0));\n        flag = flag * (step(0.,sdCircle(cirPos, uv, rad))*2. - 1.);\n        \n        \n\t}\n\n   \n\n    vec3 color = O.xyz;\n\tfragColor = vec4(color+o_col.xyz,1.0);\n    \n    \n    \n     \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}