{
    "Shader": {
        "info": {
            "date": "1614671607",
            "description": "License CC0: The Pulse\nCreated for my team at work, Pulse",
            "flags": 0,
            "hasliked": 0,
            "id": "ttGBRV",
            "likes": 9,
            "name": "The Pulse (FBM)",
            "published": 3,
            "tags": [
                "2d",
                "fbm"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 323
        },
        "renderpass": [
            {
                "code": "// License CC0: The Pulse\n//  Created for my team at work, Pulse\n\n// Uncomment below for a somewhat unsettling effect:\n// #define MONKAS\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define L2(x)       dot(x, x)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define SCA(a)      vec2(sin(a), cos(a))\n#define TTIME       (TAU*TIME)\n#define PSIN(x)     (0.5+0.5*sin(x))\n\nconst vec2 sca0  = SCA(0.0);\nconst mat2 rots1 = ROT(-PI/6.0-PI/2.0);\nconst mat2 rots2 = ROT(PI);\n\n// Approximate cosine from shadertoy but I can't find where I found it originally :(\nfloat dfcos(float x) {\n  return sqrt(x*x+1.0)*0.8-1.8;\n}\n\nfloat dfcos(vec2 p, float freq) {\n  float x = p.x;\n  float y = p.y;\n  x *= freq;\n    \n  float x1 = abs(mod(x+PI,TAU)-PI);\n  float x2 = abs(mod(x   ,TAU)-PI);\n    \n  float a = 0.18*freq;\n    \n  x1 /= max( y*a+1.0-a,1.0);\n  x2 /= max(-y*a+1.0-a,1.0);\n  return (mix(-dfcos(x2)-1.0,dfcos(x1)+1.0,clamp(y*0.5+0.5,0.0,1.0)))/max(freq*0.8,1.0)+max(abs(y)-1.0,0.0)*sign(y);\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// IQ's polynomial min\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat pabs(float a, float k) {\n  return pmax(a, -a, k);\n}\n\nfloat heart(vec2 p) {\n#ifdef MONKAS\n  p.x *= mix(1.0, 0.95, pow(PSIN(TTIME+2.5*p.y), 7.0));\n#endif  \n  // Late night maths\n  p.x = pabs(p.x, 0.075);\n  const float r  = 0.275;\n  const float l  = length(vec2(0.5-r, 1.0-r));\n  const float b  = atan((0.5-r)/(1.0-r));\n  const float c  = asin(r/l);\n  const float ll = l*cos(c);\n  const float a  = b + c;\n  const vec2 n   = vec2(cos(a), -sin(a));\n  const vec2 nn  = vec2(n.y, -n.x);\n  const vec2 off = vec2(0.5-r, 0.5-r);\n  const vec2 bot = vec2(0.0, -0.5);\n  const vec2 top = bot + -nn*ll;\n  const vec2 mid = vec2(0.0, 0.5-r-(0.5-r)/tan(a));\n  const float m1 = -dot(bot, n);\n  const float m2 = -dot(bot, nn);\n  const float m3 = -dot(top, nn);\n  const float m4 = -dot(mid, n);\n  vec2 rp = p;\n  rp -= n*min(0.0, dot(rp, n)+m4)*2.0;\n  float dc = length(p-off) - r;\n  float dl = dot(rp, n) + m1; \n  float dp = length(p - bot);\n  float d = 0.0;\n  d = (dot(p, nn) + m3) > 0.0 ? dl : dc;\n  d = (dot(p, nn) + m2) > 0.0 ? dp : d;\n  return d;\n}\n\nvec2 mod2_1(inout vec2 p) {\n  vec2 n = floor(p + 0.5);\n  p = fract(p+0.5)-0.5;\n  return n;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// IQ's box\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// IQ's horseshoe\nfloat horseshoe(vec2 p, vec2 c, float r, vec2 w) {\n  p.x = abs(p.x);\n  float l = length(p);\n  p = mat2(-c.x, c.y, c.y, c.x)*p;\n  p = vec2((p.y>0.0)?p.x:l*sign(-c.x),(p.x>0.0)?p.y:l);\n  p = vec2(p.x,abs(p.y-r))-w;\n  return length(max(p,0.0)) + min(0.0,max(p.x,p.y));\n}\n\nfloat letterp(vec2 p) {\n  float b = box(p - vec2(-0.45, -0.25), vec2(0.1, 0.75));\n  float c = max(circle(p, 0.5), -circle(p, 0.3));\n  return min(b, c);\n}\n\nfloat letteru(vec2 p) {\n  return horseshoe(p - vec2(0.0, 0.125), sca0, 0.5, vec2(0.375, 0.1));\n}\n\nfloat letterl(vec2 p) {\n  return box(p, vec2(0.125, 0.5));\n}\n\nfloat letters(vec2 p) {\n  p *= rots1;\n  float u = horseshoe(p - vec2(-0.25*3.0/4.0, -0.125/2.0), sca0, 0.375, vec2(0.2, 0.1)) - 0.0;\n  p *= rots2;\n  float l = horseshoe(p - vec2(-0.25*3.0/4.0, -0.125/2.0), sca0, 0.375, vec2(0.2, 0.1));\n  return min(u,l);\n}\n\nfloat lettere(vec2 p) {\n  return min(box(p, vec2(0.4, 0.1)), max(circle(p, 0.5), -circle(p, 0.3)));\n}\n\nfloat pulse(vec2 p) {\n  vec2 pp = p;\n  p.x += 1.95;\n  const float oi = -3.00;\n  const float om = -1.65;\n  const float op = +0.10;\n  const float ou = +1.25;\n  const float ol = +2.10;\n  const float os = +2.80;\n  const float oe = +3.85;\n  float dp = letterp(p - vec2(op, 0.0));\n  float du = letteru(p - vec2(ou, 0.0));\n  float dl = letterl(p - vec2(ol, 0.0));\n  float ds = letters(p - vec2(os, 0.0));\n  float de = lettere(p - vec2(oe, 0.0));\n  float oo = 0.1;\n\n  const float ss = 0.25;\n  float dw = dfcos(vec2(0.5*TIME, 0.0)+pp/ss, 0.5)*ss;\n  dw = abs(dw)-0.05;\n  dw = abs(dw)-0.025;\n\n  float d = 1E6;\n  d = min(d, dp);\n  d = min(d, du);\n  d = min(d, dl);\n  d = min(d, ds);\n  d = min(d, de);\n  d = pmax(d, -dw, 0.025);\n  \n  return d;\n}\n\nfloat height_(vec2 p) {  \n  p *= 0.25;\n  vec2 p0 = p;\n  vec2 n0 = mod2_1(p0);\n  vec2 p1 = p*vec2(1.0, -1.0)+vec2(0.5, 0.66);\n  vec2 n1 = mod2_1(p1);\n  const float ss = 0.66;\n  float d0 = heart(p0/ss)*ss;\n  float d1 = heart(p1/ss)*ss;\n  float d = min(d0, d1);\n  return tanh_approx(smoothstep(0.0, -0.1,d)*exp(8.0*-d));\n}\n\n\nfloat height(vec2 p) {\n  const mat2 rot1 = ROT(1.0);\n  float tm = 123.0+TTIME/240.0;\n  p += 5.0*vec2(cos(tm), sin(tm*sqrt(0.5)));\n  const float aa = -0.45;\n  const mat2  pp = (1.0/aa)*rot1;\n  float h = 0.0;\n  float a = 1.0;\n  float d = 0.0;\n  for (int i = 0; i < 4; ++i) {\n    h += a*height_(p);\n    d += a;\n    a *= aa;\n    p *= pp;\n  }  \n  const float hf = -0.125;\n  return hf*(h/d)+hf;\n}\n\nvec3 normal(vec2 p) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = height(p + e.xy) - height(p - e.xy);\n  n.y = 2.0*e.x;\n  n.z = height(p + e.yx) - height(p - e.yx);\n  \n  return normalize(n);\n}\n\nvec3 color(vec2 p) {\n  vec2 ppp = p;\n  const float s = 1.0;\n  const vec3 lp1 = vec3(1.0, 1.25, 1.0)*vec3(s, 1.0, s);\n  const vec3 lp2 = vec3(-1.0, 1.25, 1.0)*vec3(s, 1.0, s);\n\n  float aa = 2.0/RESOLUTION.y;\n\n  float h = height(p);\n  vec3  n = normal(p);\n\n  vec3 ro = vec3(0.0, -10.0, 0.0);\n  vec3 pp = vec3(p.x, 0.0, p.y);\n\n  vec3 po = vec3(p.x, h, p.y);\n  vec3 rd = normalize(ro - po);\n\n  vec3 ld1 = normalize(lp1 - po);\n  vec3 ld2 = normalize(lp2 - po);\n  \n  float diff1 = max(dot(n, ld1), 0.0);\n  float diff2 = max(dot(n, ld2), 0.0);\n\n  vec3  rn    = n;\n  vec3  ref   = reflect(rd, rn);\n  float ref1  = max(dot(ref, ld1), 0.0);\n  float ref2  = max(dot(ref, ld2), 0.0);\n\n  vec3 lcol1 = vec3(1.5, 1.5, 2.0).xzy;\n  vec3 lcol2 = vec3(2.0, 1.5, 1.15).zyx;\n  vec3 lpow1 = 0.15*lcol1/L2(ld1);\n  vec3 lpow2 = 0.25*lcol2/L2(ld2);\n  vec3 dm = vec3(1.0)*tanh_approx(-h*10.0+0.125);\n  vec3 col = vec3(0.0);\n  col += dm*pow(diff1, 4.0)*lpow1;\n  col += dm*pow(diff2, 4.0)*lpow2;\n  vec3 rm = vec3(1.0)*mix(0.25, 1.0, tanh_approx(-h*1000.0));\n  col += rm*pow(ref1, 20.0)*lcol1;\n  col += rm*pow(ref2, 20.0)*lcol2;\n\n  const float zp = 0.6;\n  float di = pulse(ppp/zp)*zp;\n  di -= 0.005;\n\n  col += -lcol2.zxy*0.125*(exp(-5.0*max(di, 0.0)));\n  col = col.zxy;\n \n  col = mix(col, vec3(1.0), smoothstep(-aa, aa, -di));\n  di = abs(di-0.025);\n  di = abs(di-0.0125);\n  col += 1.*lcol2.zxy*(exp(-20.0*max(di+0., 0.0)))*pow(PSIN(-0.8+p.x-p.y-TTIME/12.0), 10.0);\n\n  return col;\n}\n\n// Post processing I found somewhere on shadertoy years ago\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/vec3(2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = color(p);  \n  col = clamp(col, 0.0, 1.0);\n  col *= smoothstep(0.0, 4.0, TIME);\n  col = postProcess(col, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}