{
    "Shader": {
        "info": {
            "date": "1635609742",
            "description": "Edited from rory618's https://www.shadertoy.com/view/4tdXR8. The idea is to use a limiting shape to create different cymatics.\n\nMouse X change view, Mouse Y change frequency. R resets, W turns off the generation of new waves, E removes restriction.\n",
            "flags": 48,
            "hasliked": 0,
            "id": "Nlt3zn",
            "likes": 2,
            "name": "WaveTable RayMarch LookingGlass",
            "published": 3,
            "tags": [
                "wave"
            ],
            "usePreview": 0,
            "username": "PsyPhi",
            "viewed": 263
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\n\n//Wave Pattern\nfloat Wave(vec2 uv, vec2 res)\n{\n    vec2 w = texture(iChannel0, uv / res).xy;\n\tvec4 col = vec4(w.x,-w.x,w.y*w.y*2.,1.);\n   // col = mix(col,texture(iChannel1, uv / res),1.-iMouse.x/iResolution.x);\n    //fragColor = texture(iChannel1, fragCoord.xy / iResolution.xy); //view BW\n    //fragColor = texture(iChannel2, fragCoord.xy / iResolution.xy); //view boarder\n    \n    float height = col.r-col.g;\n    \n    return height;\n}\n\n\n\n// Distance calculations\n\nfloat GetDist(vec3 p)// function for calculating distance. This is where the atual objects are coded\n{\n    \n vec2 size = iResolution.xy*vec2(0.0065,0.010);\n    \n float planeDist = p.z-0.5; // this genirates the floor plane. it is calculated by seeing how high the ray is from the ground.\n planeDist += Wave(p.xy+(size/2.),size)*0.75;\n \n float shapeMix = planeDist;   \n\n    \n    return shapeMix;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n \tfloat dO=0.0; // dO is the distance to the origin\n    \n    for(int i=0; i<MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd*dO; //current ray postion. Move in the direction of the ray (rd), by the distance the object is from the origin (dO or camera)\n        float ds = GetDist(p); //calculates distance the currenmt ray position is from the object\n        dO += ds;\t\t\t//moves the current ray position by the distance it is from the object\n        if(dO>MAX_DIST || ds<SURF_DIST) break; // has the ray position moved past the max distance, or gotten close enough to the object to stop?\n        \n    }\n    \n    return dO;\n        \n}\n\nvec3 GetNormal(vec3 p)\n{\n \tfloat d = GetDist(p);\n    vec2 e = vec2( 0.1,0);\n    \n    vec3 n = d - vec3        //this moves 0.1 in eash direction from the point and takes a distance sample used to calculate the slope of the surface\n        (\n            GetDist(p-e.xyy),\n            GetDist(p-e.yxy),\n            GetDist(p-e.yyx)\n        );\n        \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p)\n{\n \tvec3 lightPos = vec3(1,0,-10); //postion of the light source\n    //lightPos.xy += vec2(sin(iTime), cos(iTime))*2.;//move light over time\n \tvec3 l = normalize(lightPos-p); //at direction is the surface from the light source\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l),0.,1.); //diffrence in angle between the normal and light vectors. clamps to 0 and 1 to prevent neg numbers\n    \n    //Shadows\n    float d = RayMarch(p+n*SURF_DIST*2., l);    //raymarch from the point towards the light. the n*SURF_DIST moves it just far enough away from the surface so that it does not stop the march due to already being at a surface.\n    if(d<length(lightPos-p))\t//Does the ray hit an object before hiting the light?\n    \t{\n            dif *= 1.;\t\t\t//If so make the point 10 times darker. Not true right now 0.1 would be 10 times.\n        }\n    \n    return dif;\n    \n}\n\nmat3 lookAt(in vec3 eye, in vec3 tar, in float r){\n    vec3 cw = normalize(tar - eye);// camera w\n    vec3 cp = vec3(sin(r), cos(r), 0.);// camera up\n    vec3 cu = normalize(cross(cw, cp));// camera u\n    vec3 cv = normalize(cross(cu, cw));// camera v\n    return mat3(cu, cv, cw);\n}\n\n\n\nvoid render( out vec4 fragColor, in vec2 fragCoord, in vec3 _ro, in vec3 _rd )\n{\n\n //vec4 color = Wave(fragCoord.xy, iResolution.xy);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    //Camera\n    vec3 ro = vec3(0,0,-20); //Ray origin. Edit this to change the camera position.\n    vec3 rd = normalize(vec3(uv.x, uv.y-0.0, 1)); //Ray direction. Normalize function returns the direction with a lenth of 1. edit this to change the direction the camera is facing\n\n    vec3 tar = vec3(0.);// eye target\n    \n    \n    \n    ro = _ro;\n    rd = _rd;\n    \n       // float f = iMouse.x/iResolution.x;\n   float f = 1.; //switches from Orth to perspective\n    \n    rd = lookAt(ro, tar, 0.)*normalize(vec3(uv, 1.0));// ray direction\n    vec3 rd_orth = lookAt(ro, tar, 0.)*normalize(vec3(0., 0., 1.0));// ray direction via orthographic projection\n    rd = mix(rd, rd_orth, f);\n\n    //float orthRectSize = 2.0 + 3.0*iMouse.y/iResolution.y;\n    float orthRectSize = 5.0;\n    vec3 ro_orth = ro + vec3(uv * orthRectSize, 0.);// ray origin \n    ro = mix(ro, ro_orth, f);\n    \n\n    float d = RayMarch(ro,rd);\n    \n    vec3 p = ro + rd * d; //location that the raymarch function determined is the surface\n    \n    float dif = GetLight(p);// dif mean defused light\n    \n//    dif /=6.0;  //brings the distance value into the visable range?? used for testing REMOVE\n\tcol = vec3(dif);\n\n    fragColor = vec4(col,1.0);\n    }\n\n#define QAA\t2                                     \n\nconst float\tsideAngle       = radians(1.0);\nconst float\thorizontalAngle = radians(5.0);\nconst float\tcameraSize      = 4.5;\nconst float\taspectRatio     = 0.75;\nconst float quiltColumns\t= 8.0;\nconst float quiltRows\t\t= 6.0;\nconst float nearClip        = 8.0; \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2\tcoord = fragCoord * vec2(quiltColumns,quiltRows) / iResolution.xy;\n\tvec2\tfract = fract(coord);\n\tvec2\tfloor = floor(coord);\n\tfloat\timageId = floor.x + floor.y * quiltColumns;\n\tfloat\tvalueId = imageId / (quiltColumns * quiltRows - 1.);\n\tfloat\tdist = (cameraSize / 2.) / tan(horizontalAngle / 2.);\n\tfloat\tminCam = -(cameraSize / 2.) - tan(sideAngle / 2.) * dist;\n\t\n\tvec3\tcamPos = mix(vec3(minCam,0,dist),vec3(-minCam,0,dist),valueId);\n\tvec3\tscreenPos = vec3((fract.x-0.5)*cameraSize,(fract.y-0.5)*cameraSize / aspectRatio,0);\n\t\n\t//vec4\tcolor = vec4( vec3(valueId), 1 );\n\t\n\tvec4\tcolor;\n\tvec3 \tdirRay = normalize(screenPos-camPos);\n    dirRay.z = -dirRay.z;\n\trender( color, fract * iResolution.xy, screenPos - nearClip * dirRay, dirRay );\n\n    fragColor = color;\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel1,fragCoord/iResolution.xy);\n    fragColor += .05;\n    fragColor /= (1.01+5.*abs(texture(iChannel0,fragCoord/iResolution.xy).y));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const float KEY_R  = 82.5/256.0;\nconst float KEY_W  = 87.5/256.0;\nconst float KEY_E  = 69.5/256.0;\n\nbool keyIsDown( float key ) {\n    return texture( iChannel1, vec2(key,0.25) ).x > .5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        \n    vec2 l = texture(iChannel0, (fragCoord-vec2(2.5,0))/iResolution.xy).xy;\n    vec2 r = texture(iChannel0, (fragCoord+vec2(2.5,0))/iResolution.xy).xy;\n    vec2 u = texture(iChannel0, (fragCoord-vec2(0,2.5))/iResolution.xy).xy;\n    vec2 d = texture(iChannel0, (fragCoord+vec2(0,2.5))/iResolution.xy).xy;\n    vec2 ur = texture(iChannel0, (fragCoord-vec2(2.5, 2.5))/iResolution.xy).xy;\n    vec2 ul = texture(iChannel0, (fragCoord-vec2(-2.5, 2.5))/iResolution.xy).xy;\n    vec2 dr = texture(iChannel0, (fragCoord-vec2(2.5, -2.5))/iResolution.xy).xy;\n    vec2 dl = texture(iChannel0, (fragCoord-vec2(-2.5, -2.5))/iResolution.xy).xy;\n    \n    vec2 t = texture(iChannel0, fragCoord/iResolution.xy).xy; //Contains last frame\n        \n    t = mix(t,(l+r+u+d)/4.,.01); // mixes lastframe with the 4 px around it.\n    t = mix(t,(ur+ul+dr+dl)/4.,.0075); // mixes lastframe with the 4 px around it.\n        \n\tfloat DL = l.x-t.x;  //diffrences left with the last frame?\n\tfloat DR = r.x-t.x;\n\tfloat DU = u.x-t.x;\n\tfloat DD = d.x-t.x;\n    float DUR = ur.x-t.x;\n    float DUL = ul.x-t.x;\n    float DDR = dr.x-t.x;\n    float DDL = dl.x-t.x;\n    \n    t.y += (DL+DR+DU+DD+DUR+DUL+DDR+DDL)/8.; //adds the diffrenced frames?\n    t.x += t.y;\n    //t.y *= .999;\t\t\t//reduces frame for FB loop\n    \n   // float f = iMouse.y/40.;\t\t//Gets mouse y for frequency\n    float f = 1.;\n    if(iResolution.y < 285.)\n        f = 10.;\n\n    \n    if (keyIsDown(KEY_W) == false) //Adds in new wave      \n    \tt = mix(t, vec2(sin(iTime*f), cos(iTime*f)), .5*exp(-.2*length(fragCoord-iResolution.xy/2.)));\n\n    \n    vec2 border = vec2(0,0);\n    \n    if (keyIsDown(KEY_E))\n        border = texture(iChannel2, fragCoord/iResolution.xy).xy; //adds in the custom border shape\n\n    \n    if(fragCoord.x<1. || fragCoord.y<1. || fragCoord.x>iResolution.x-1. || fragCoord.y>iResolution.y-1. || border.x == 1.0 )\n        t*=0.;\n\n    \n    if ( keyIsDown(KEY_R))\n        t *= 0.;\n\n    \n    \n    fragColor = vec4(t.x,t.y,0,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tfloat circle = step(0.25,distance(vec2(0.5),fragCoord/iResolution.xy));\n    fragColor = vec4(circle,circle,circle,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}