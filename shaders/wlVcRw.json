{
    "Shader": {
        "info": {
            "date": "1610721944",
            "description": "first time playing with raymarching :) ",
            "flags": 0,
            "hasliked": 0,
            "id": "wlVcRw",
            "likes": 6,
            "name": "Payday Joyman",
            "published": 3,
            "tags": [
                "raymarching",
                "specular",
                "character",
                "memoji"
            ],
            "usePreview": 0,
            "username": "luckyballa",
            "viewed": 254
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 25\n#define MAX_DIST 25.\n#define SURF_DIST .008\n\nfloat g_time;\n\nfloat sdSphere( vec3 p, float s ) { return length(p)-s; }\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h ) {\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n} \n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb) {\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat smax( float a, float b, float k ) {\n    k *= 1.4;\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*h/(6.0*k*k);\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\nvec2 rot(vec2 p, in float an ) {\n    float cc = cos(an);\n    float ss = sin(an);\n    return mat2(cc,-ss,ss,cc)*p;\n}\n\nfloat displacement(vec3 p) { return sin(60.*p.x)*sin(60.0*p.y)*sin(60.*p.z); }\n\nfloat sdCone( in vec3 p, in vec2 c ) {\n  vec2 q = vec2( length(p.xz), p.y );\n\n  vec2 a = q - c*clamp( (q.x*c.x+q.y*c.y)/dot(c,c), 0.0, 1.0 );\n  vec2 b = q - c*vec2( clamp( q.x/c.x, 0.0, 1.0 ), 1.0 );\n  \n  float s = -sign( c.y );\n  vec2 d = min( vec2( dot( a, a ), s*(q.x*c.y-q.y*c.x) ),\n\t\t\t    vec2( dot( b, b ), s*(q.y-c.y)  ));\n  return -sqrt(d.x)*sign(d.y);\n}\n\n\nvec2 getDist(vec3 p) {\n\n    float matId;\n    p.y -= 0.2;\n    vec3 orig =  vec3(0, 1, 6.4);\n    \n    //HEAD\n\tvec3 headPos = p-orig;\n    vec3 direction =  normalize(headPos);\n    headPos.x -= (p.y - 1.1) * 0.35 * direction.x;\n    headPos.x += pow(abs(sin((p.y + 2.) * 8.)) * 0.1, 1.2 + p.y) * normalize(headPos).x;  \n\n    float head = length(headPos) -1. + p.y * 0.5;\n    \n    //HAIR\n    vec3 hairPos = p-orig;\n    float hair = sdRoundedCylinder(hairPos, 0.24, 0.15, 0.27);\n    hair += displacement(hairPos) * .005;\n    \n    if (hair < head) {\n       head = smin(hair, head, 0.01);\n        matId = 0.;\n    } else {\n        matId = 2.;\n    }\n      \n    //EYES\n    vec3 eyePos = headPos + vec3(0.05 * direction.x, 0.25, .5);\n    vec3 eyeOff = vec3(0.19, 0., 0.);\n    eyePos.x = abs(eyePos.x);\n\n    float eye = length(eyePos -eyeOff) -0.12;\n    if (-eye > head) { head += eye; }\n    head = min(eye + 0.01, head);    \n    \n    vec3 eyeBrowPos = vec3( rot( vec2(eyePos.x * 1.2 - eyeOff.x * 1.3 , eyePos.y -0.17) , 1.5),  eyePos.z+0.1);\n    eyeBrowPos.x -= (1. - pow(abs(sin(g_time)), 0.4)) * 0.03;\n    eyeBrowPos.x += sin(eyeBrowPos.y * 20. - 1.) * .012;\n    float eyeBrow = sdRoundedCylinder(eyeBrowPos, 0.005, 0.04, 0.11);\n    \n    if (eyeBrow < head) {\n        head = smin(eyeBrow, head, 0.1);\n        matId = 0.;\n    }\n    \n    //GLASSES\n    eyePos.z += 0.2;\n    eyeOff.x += 0.02;\n    float glass = sdBox(eyePos-eyeOff, vec3(0.15, 0.07 , 0.02));\n    eyeOff.x += 0.24;\n    eyeOff.z += 0.2;\n    float glassb = sdRoundedCylinder(vec3(rot((eyePos-eyeOff).xz, -.4), eyePos.y), 0.005, 0.02, 0.2);    \n\n    eyePos.x *= 2.;\n    eyePos.y *= 1.8;\n    eyePos.z *= 0.9;\n    eyePos.z -= 0.2;\n    float glassC = sdCappedTorus( vec3(eyePos.x, rot((eyePos+eyeOff).yz, -1.5)), vec2(0.2, 0.), 0.15, 0.02);\n\n    if (glassC < head) {\n        head = min(glassC, head);\n        matId = 6.;\n    }\n    if (glassb < head) {\n        head = min(glassb, head);\n        matId = 6.;\n    }\n    \n    if (glass < head) {\n        head = min(glass, head);\n        matId = 1.;\n    }\n     \n    //NOSE\n    vec3 nosePos = p-orig;\n    nosePos.z += 0.7;\n    nosePos.y += 0.15;\n    nosePos.yz = rot(nosePos.yz,-0.3);\n    float h = smoothstep(0.,0.3,-nosePos.y );\n    float nose = 1.;\n    nosePos.x = sqrt(nosePos.x*nosePos.x + 0.001);\n    nose = smin( nose, sdSphere(nosePos-vec3(0.04, -0.3, 0.037),0.03 ), 0.1);\n    nose = smin( nose, sdSphere(nosePos*vec3(1.05,0.95,1.)-vec3(.0, -0.155, 0.05),0.02), 0.19);\n    head = smin(head,nose,0.05-0.04*h);\n    if (nose - 0.001 < head) {\n        matId = 2.;\n    }\n    \n    //EARS\n    vec3 earsPos = p-orig;\n    earsPos.x = abs(earsPos.x);\n    earsPos.y += 0.35;\n    earsPos.y *= 0.7;\n    earsPos.z += 0.1;\n    earsPos.x -= 0.41;\n    float ear = sdSphere(earsPos,0.08); \n    if (ear < head) {\n        head = smin(head,ear,0.02);\n        matId = 2.;\n    }\n\n    //MOUTH\n    float mT = 0.88 - pow(abs(g_time) / 1.2, 1.8);\n    vec3 mPos = p - vec3(orig.x + 0.7 * direction.x * mT, orig.y-.6, orig.z -0.55);\n    mPos.y -= pow(abs(sin(abs(p.x))), 1.9 + mT * 0.3);\n   \tfloat mouth = length(mPos) - 0.05;\n    mPos.x = orig.x + 0.69 * direction.x  * (1.55 - mT);\n    mPos.z *= 1.8;\n    mPos.z -= 0.064;\n    mPos.y -= 0.015;\n    mPos.y *= 0.95;\n    float outMouth = length(mPos) - 0.05;\n    if (-mouth - 0.008 > head ) {\n        matId = 3.;\n        head = smin(-mouth, head, 0.2);\n    }\n    \n    head = smin(head, outMouth, 0.03);  \n    outMouth = length(vec3(mPos.x, mPos.y - 0.01 ,  mPos.z))  - 0.05;\n    if (outMouth - 0.022 < head){ matId = 4.; }\n    \n    //DOLLAR\n    vec3 dollaInitialPos = headPos + vec3(1.66, -0.52, 1.6) - vec3(.5*sin(g_time),0., 1.*cos(g_time));\n    vec3 dollaPos = dollaInitialPos;\n    dollaPos.x *= 0.85 - p.y * 0.01;\n    dollaPos.xy *= 2.5;\n    dollaPos.y *= 1.1;\n    dollaPos.z += sin(iTime + dollaPos.y * 5.) * 0.05;\n    dollaPos.xy = rot( dollaPos.xy, 0.9);\n    dollaPos.x = dollaPos.y > 0. ? -dollaPos.x + 0.36 : dollaPos.x;\n    float dollaA = sdCappedTorus(dollaPos, vec2(sin(iTime-.3), cos(iTime-.3)), 0.22, 0.025);\n   \n    dollaPos.xy = dollaInitialPos.xy - vec2(0.02, 0.06);\n    dollaPos.xy *= 2.;\n    dollaPos.xy = rot( dollaPos.xy, -.2);\n    dollaPos.x -= 0.05;\n    dollaPos.x = abs(dollaPos.x);\n    dollaPos.x -= 0.05;\n    float dollaB = sdRoundedCylinder(dollaPos, 0.01, 0.02, 0.49 * abs(cos(iTime / 2. - 1.) ));    \n\n\n   if (dollaA < head) {\n       head = min(dollaA, head);\n       matId = 5.;\n    } \n    if (dollaB < head) {\n        head = smin(dollaB, head, 0.075);\n        matId = 5.;\n    }\n    \n    return vec2(head, matId);\n}\n\n\nvec2 rayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float matId = -1.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        vec2 res = getDist(p);\n        float dS = res.x;\n        dO += dS;\n        matId = res.y;\n        \n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return vec2(dO, matId);\n}\n\nvec3 getNormal(vec3 p) {\n\tfloat d = getDist(p).x;\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy).x,\n        getDist(p-e.yxy).x,\n        getDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nfloat light(vec3 p, vec3 n) {\n    vec3 lightPos = vec3(0.5, 1.5, 4.);\n    vec3 l = normalize(lightPos-p);\n    float dif = clamp(dot(n, l), 0., 1.);     \n    return dif*1.5;\n}\n\nfloat slight(vec3 p, vec3 ro, vec3 n) {\n    vec3 lightPos = vec3(g_time * 4., 2., 4.);\n    vec3 l = normalize(lightPos-p);\n    \n    float lDist = max(length(l), 0.001);\n    float atten = 1./(1.0 + lDist*lDist*0.5);\t\n    vec3 reflection = reflect(-l, n);\n    float spec = pow(max( dot(reflection, -normalize(ro)), 0.), 9.); \n        \n    return spec*3. *atten;;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mo = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.0);\n    \n    float iTime = iTime * 4.;\n    vec2 m = vec2(0.5);\n    g_time = sin(-0.25 + 0.31416*iTime) - 6.2831*(m.x-0.5);\n\n\tvec3 ro = vec3(.5*sin(g_time),1., 1.*cos(g_time));\n    vec3 rd = normalize(vec3(uv.x, uv.y , 2.));\n\n    vec2 d = rayMarch(ro, rd);\n    vec3 p = ro + rd * d.x;\n    vec3 n = getNormal(p);\n    float dif = light(p, n) / 2.7;\n    float spec = slight(p, ro, n);\n    vec3 bc = vec3(0.85, 0.72, 0.56);\n\n    col = dif * vec3(0.85, 0.35, 0.2);\n    \n    if (d.y == 0.) { // HAIR\n          col = dif * vec3(0.12, 0.10, 0.101); \n    } else  if (d.y == 1.) { // GLASSES\n          col = min((spec+spec/1.5+dif) * vec3(0.84, 0.2, 0.15), 1.); \n    } else  if (d.y == 2.) { // SKIN\n        col = dif * vec3(0.85, 0.35, 0.2);\n    } else if (d.y == 3.) { // MOUTH IN\n          col = dif * vec3(1., 0.5, 0.4) * 0.9;\n    } else if (d.y == 4.) { // MOUTH\n              col = dif * vec3(0.9, 0.3, 0.2) / 1.3;\n    } else if (d.y == 5.) { // DOLLA\n              col = max(pow(spec+dif+dif, 1.2), 0.3) * vec3(0.1, 0.8, 0.4) / 2.;\n    } else if (d.y == 6.) { // GLASSES BASE\n              col = (spec+spec/2.+dif) * vec3(0.9, 0.7, 0.15);\n    } else if (d.y == 7.) { // PARTS\n            col =  vec3(0.32, 0.22, 0.12) * 0.6;// - dif/2.*bc;\n    }\n    \n    col = pow(col, vec3(.6));\n    col +=  0.1 * vec3(.25, 0.36, 0.7);\n    col *= 1.5;\n    \n    fragColor = vec4( max(vec3( col), 0.12),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}