{
    "Shader": {
        "info": {
            "date": "1556036318",
            "description": "A shadertoy port of my 4k Executable Graphics entry at Revision 2019. Placed 7th out of 18 entries.\nUse the mouse to turn the camera and reveal the trick.\n\nDownload the original executable version here: [url]http://www.pouet.net/prod.php?which=81059[/url]",
            "flags": 32,
            "hasliked": 0,
            "id": "ttXGWr",
            "likes": 83,
            "name": "Penrose Pathtraced",
            "published": 3,
            "tags": [
                "revision",
                "impossible",
                "penrosetriangle"
            ],
            "usePreview": 0,
            "username": "yx",
            "viewed": 2802
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n\tvec2 uv=gl_FragCoord.xy/iResolution.xy;\n    vec4 tex=texture(iChannel0,uv);\n    \n    // divide by sample-count and multiply by exposure\n\tvec3 color=tex.rgb*1.2/tex.a;\n    \n    // vignette to lighten the corners\n\tuv-=.5;\n\tcolor += dot(uv,uv)*.5;\n    \n    // gamma correction and a slight blue color grading\n\tcolor=pow(color, .45*vec3(1.2,1.1,1));\n    \n\tfragColor.rgb=color;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define pi (acos(-1.))\n\nvec2 rotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    p=abs(p)-b;\n    return max(max(p.x,p.y),p.z);\n}\n\nvec2 hash2( const float n ) {\n\treturn fract(sin(vec2(n,n+1.))*vec2(43758.5453123));\n}\n\n// hacky parameter to control the size\nfloat T=4.;\n\n// distance function\nfloat scene(vec3 p)\n{\n    float d = 1e9;\n    \n    float fl=p.y+T+1.;\n    \n    // left beam\n    d=min(d,sdBox(p+vec3(0,T,0),vec3(T,0,0)+1.));\n    \n    // vertical beam\n\td=min(d,sdBox(p-vec3(T,0,0),vec3(0,T-2.,0)+1.));\n    \n    // the magic seam that moves over time so it's not in one place\n    float plane = p.x+p.z-(T-2.)+fract(iTime)*(T*2.-6.);\n    \n    // back beam\n    d=min(d, max(plane-1., sdBox(p+vec3(T,T,-T+1.),vec3(1.,1.,T))));\n    \n    // top beam\n    d=min(d, max(-plane, sdBox(p-vec3(T,T,1.-T),vec3(1.,1.,T))));\n    \n    // intersect with a field of smaller boxes\n    p=mod(p+vec3(1,1,1),2.)-1.;\n    d = max(d,sdBox(p,vec3(.8)));\n    \n    d=min(d,fl);\n    \n    return d;\n}\n\n// ray bouncing function \"borrowed\" from I can't remember where\nvec2 rv2;\nvec3 B( vec3 i, vec3 n ) {\n\tvec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );\n\tvec3  vv = cross( uu, n );\n\t\n\tfloat ra = sqrt(rv2.y);\n\tfloat rx = ra*cos(6.2831*rv2.x); \n\tfloat ry = ra*sin(6.2831*rv2.x);\n\tfloat rz = sqrt( 1.0-rv2.y );\n\tvec3  rr = vec3( rx*uu + ry*vv + rz*n );\n\n    return normalize( rr );\n}\n\nvec3 trace(vec3 cam, vec3 dir)\n{\n    vec3 accum = vec3(1);\n    for(int bounce=0;bounce<4;++bounce)\n    {\n        // near-clip plane, can't remember why I did this\n        float t=(bounce==0)?5.:0.;\n        float k;\n        for(int i=0;i<100;++i)\n        {\n            k = scene(cam+dir*t);\n            t += k;\n            if (abs(k) < .001)\n                break;\n        }\n\n        // if we hit something\n        if(abs(k)<.001)\n        {\n\t\t\tvec3 h = cam+dir*t;\n\t\t\tvec2 o = vec2(.001, 0);\n\t\t\tvec3 n = normalize(vec3(\n\t\t\t\tscene(h+o.xyy)-scene(h-o.xyy),\n\t\t\t\tscene(h+o.yxy)-scene(h-o.yxy),\n\t\t\t\tscene(h+o.yyx)-scene(h-o.yyx)\n\t\t\t));\n\n            // bounce the ray in a random direction\n\t\t\tcam = h+n*.02;\n            dir = B(gl_FragCoord.xyz/iResolution.xyz,n);\n            accum /= pi;\n\n            h.xz+=vec2(-1,1);\n            \n            // depth-of-field hack by jittering the floor UVs\n            h.xz+= (rv2-.5) * max(0.,abs(h.x-h.z)-5.) * .01;\n\n            // grid lines\n            float gridscale=2.;\n            vec3 a = 1.-step(.49,abs(fract(h*gridscale)-.5));\n            float f=min(a.z,a.x);\n            \n            // checkerboard\n            gridscale=.25;\n\t\t\th.xz++;\n            f*=.8-step(.0,(fract(h.x*gridscale)-.5)*(fract(h.z*gridscale)-.5))*.3;\n            \n            if(h.y<-T-.99)\n            \taccum *= f;\n        }\n    }\n    \n    vec3 lightdir = vec3(0,1,0);\n    return accum * max(0.,dot(dir,lightdir)) * 3.;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    // grab the previous color so we can iteratively render.\n    // in the actual executable I just rendered additively to a single framebuffer instead\n   \tfragColor = texture(iChannel0,fragCoord/iResolution.xy);\n    \n    vec2 uv = fragCoord.xy/iResolution.xy-.5;\n\n    // random function borrowed from I can't remember where\n    float seed = iTime+(uv.x+iResolution.x*uv.y)*1.51269341231;\n\trv2 = hash2( 24.4316544311+iTime+seed );\n    \n    // jitter camera for antialiasing\n    uv += (rv2-.5)/iResolution.xy;\n    \n    // correct UVs for aspect ratio\n    uv.x*=iResolution.x/iResolution.y;\n\n    // make an orthographic camera\n\tvec3 cam = vec3(uv*15.,-20.);\n    cam.y-=5./3.;\n    cam.x+=.75;\n    vec3 dir = vec3(0,0,1);\n\n    // spin it to an isometric angle\n    cam.yz = rotate(cam.yz, atan(1.,sqrt(2.)));\n    dir.yz = rotate(dir.yz, atan(1.,sqrt(2.)));\n    \n    // debug camera rotation\n    if (iMouse.z > 0.) {\n        float a = .5-(iMouse.y/iResolution.y);\n    \tcam.yz = rotate(cam.yz, a);\n    \tdir.yz = rotate(dir.yz, a);\n    }\n\n    // spin it to an isometric angle\n    cam.xz = rotate(cam.xz, pi/4.);\n    dir.xz = rotate(dir.xz, pi/4.);\n    \n    // debug camera rotation\n    if (iMouse.z > 0.) {\n        float a = 1.-2.*(iMouse.x/iResolution.x);\n    \tcam.xz = rotate(cam.xz, a);\n    \tdir.xz = rotate(dir.xz, a);\n    }\n    \n    // compute the pixel color, with some vignette I'd forgotten I put there\n\tvec4 pixel = vec4(trace(cam,dir)*(1.-dot(uv,uv)*.5),1);\n    \n    // reset buffer if we're clicking\n    if (iMouse.z > 0.) fragColor *= 0.;\n\n    // accumulate the pixel\n    fragColor += pixel;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}