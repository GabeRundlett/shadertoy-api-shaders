{
    "Shader": {
        "info": {
            "date": "1510463650",
            "description": "What it looks like when a complex function has a critical point (a zero of its derivative) or a pole of different orders. Here the critical point or pole is placed at (0.5, 0.5), in the middle of the square, and animates between orders +3 and âˆ’3.",
            "flags": 0,
            "hasliked": 0,
            "id": "MljcWc",
            "likes": 11,
            "name": "Complex critical points & poles",
            "published": 3,
            "tags": [
                "procedural",
                "2d",
                "math",
                "complex",
                "diagram"
            ],
            "usePreview": 0,
            "username": "Reedbeta",
            "viewed": 624
        },
        "renderpass": [
            {
                "code": "vec2 ortho(vec2 v)\n{\n    return vec2(v.y, -v.x);\n}\n\nvoid stroke(float dist, vec3 color, inout vec3 fragColor, float thickness, float aa)\n{\n    float alpha = smoothstep(0.5 * (thickness + aa), 0.5 * (thickness - aa), abs(dist));\n    fragColor = mix(fragColor, color, alpha);\n}\n\nvoid fill(float dist, vec3 color, inout vec3 fragColor, float aa)\n{\n    float alpha = smoothstep(0.5*aa, -0.5*aa, dist);\n    fragColor = mix(fragColor, color, alpha);\n}\n\nvoid renderGrid(vec2 pos, out vec3 fragColor)\n{\n    vec3 background = vec3(1.0);\n    vec3 axes = vec3(0.4);\n    vec3 lines = vec3(0.7);\n    vec3 sublines = vec3(0.95);\n    float subdiv = 10.0;\n\n    float thickness = 0.003;\n    float aa = length(fwidth(pos));\n\n    fragColor = background;\n\n    vec2 toSubGrid = pos - round(pos*subdiv)/subdiv;\n    stroke(min(abs(toSubGrid.x), abs(toSubGrid.y)), sublines, fragColor, thickness, aa);\n\n    vec2 toGrid = pos - round(pos);\n    stroke(min(abs(toGrid.x), abs(toGrid.y)), lines, fragColor, thickness, aa);\n\n    stroke(min(abs(pos.x), abs(pos.y)), axes, fragColor, thickness, aa);\n}\n\nfloat distLineSeg(vec2 a, vec2 b, vec2 pos)\n{\n    float proj = dot(pos - a, b - a) / dot(b - a, b - a);\n    vec2 posNearest = mix(a, b, clamp(proj, 0.0, 1.0));\n    return length(pos - posNearest);\n}\n\nvoid renderLineSeg(vec2 a, vec2 b, vec3 color, float thickness, vec2 pos, inout vec3 fragColor)\n{\n    stroke(distLineSeg(a, b, pos), color, fragColor, thickness, length(fwidth(pos)));\n}\n\nfloat sdistLine(vec2 a, vec2 b, vec2 pos)\n{\n    return dot(pos - a, normalize(ortho(b - a)));\n}\n\nfloat sdistTri(vec2 a, vec2 b, vec2 c, vec2 pos)\n{\n    return max( sdistLine(a, b, pos),\n            max(sdistLine(b, c, pos),\n                sdistLine(c, a, pos)));\n}\n\nfloat sdistQuadConvex(vec2 a, vec2 b, vec2 c, vec2 d, vec2 pos)\n{\n    return max(  sdistLine(a, b, pos),\n            max( sdistLine(b, c, pos),\n             max(sdistLine(c, d, pos),\n                 sdistLine(d, a, pos))));\n}\n\nvoid renderUnitSquare(vec2 pos, inout vec3 fragColor)\n{\n    float dist = sdistQuadConvex(vec2(0, 0),\n                                 vec2(1, 0),\n                                 vec2(1, 1),\n                                 vec2(0, 1), pos);\n    stroke(dist, vec3(0, 0, 1), fragColor, 0.007, length(fwidth(pos)));\n}\n\nvoid renderAxes(vec2 origin, vec2 pos, inout vec3 fragColor)\n{\n    float len = 0.1;\n    float thickness = 0.0075;\n    float aa = length(fwidth(pos));\n\n    float xshaft = sdistQuadConvex(origin + vec2(0.5*thickness),\n                                   origin - vec2(0.5*thickness),\n                                   origin + vec2(len, -0.5*thickness),\n                                   origin + vec2(len, 0.5*thickness), pos);\n    float xhead = sdistTri(origin + vec2(len, -2.0*thickness),\n                           origin + vec2(len + 6.0*thickness, 0),\n                           origin + vec2(len, 2.0*thickness), pos);\n\n    fill(min(xshaft, xhead), vec3(1, 0, 0), fragColor, aa);\n\n    float yshaft = sdistQuadConvex(origin - vec2(0.5*thickness),\n                                   origin + vec2(0.5*thickness),\n                                   origin + vec2(0.5*thickness, len),\n                                   origin + vec2(-0.5*thickness, len), pos);\n    float yhead = sdistTri(origin + vec2(2.0*thickness, len),\n                           origin + vec2(0, len + 6.0*thickness),\n                           origin + vec2(-2.0*thickness, len), pos);\n\n    fill(min(yshaft, yhead), vec3(0, 0.75, 0), fragColor, aa);\n\n}\n\nvec2 cmul(vec2 a, vec2 b)\n{\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\nvec2 cdiv(vec2 a, vec2 b)\n{\n    return cmul(a, vec2(b.x, -b.y)) / dot(b, b);\n}\n\nvec2 csqr(vec2 z)\n{\n    return cmul(z, z);\n}\n\nvec2 ccube(vec2 z)\n{\n    return cmul(cmul(z, z), z);\n}\n\nvec2 cexp(vec2 z)\n{\n    return exp(z.x) * vec2(cos(z.y), sin(z.y));\n}\n\nvec2 clog(vec2 z)\n{\n    return vec2(log(length(z)), atan(z.y, z.x));\n}\n\nvec2 cpow(vec2 z, float p)\n{\n    return cexp(clog(z) * p);\n}\n\nvec2 cexpi(float theta)\n{\n    return vec2(cos(theta), sin(theta));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float aspect = iResolution.x / iResolution.y;\n\tvec2 pos = (fragCoord / iResolution.y) * 1.5 - vec2((1.5*aspect - 1.0)/2.0, 0.25);\n\n    // animate p from -3 to +3 in steps. negative = pole, positive = critical point.\n    float phase = mod(iTime / 3.0, 12.0);\n    int phase_i = int(phase);\n    int phase_i_next = (phase_i + 1) % 12;\n    float phase_f = fract(phase);\n    float pcur = float((phase_i <= 6) ? 3 - abs(phase_i - 3) : -4 + abs(phase_i - 9));\n    float pnext = float((phase_i_next <= 6) ? 3 - abs(phase_i_next - 3) : -4 + abs(phase_i_next - 9));\n    float p = mix(pcur, pnext, smoothstep(0.6, 1.0, phase_f));\n\n    // a function that has a critical point of order p at (0.5, 0.5),\n    // and equals the identity to first order around the origin\n    pos = cmul(vec2(0.5) / (p + 1.0),\n               vec2(1,0) - cpow(vec2(1,0) - cdiv(pos, vec2(0.5)), p + 1.0));\n\n    // render the grid and stuff\n    fragColor.a = 1.0;\n\trenderGrid(pos, fragColor.rgb);\n    renderUnitSquare(pos, fragColor.rgb);\n    renderAxes(vec2(0), pos, fragColor.rgb);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}