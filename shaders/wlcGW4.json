{
    "Shader": {
        "info": {
            "date": "1576315201",
            "description": "A simple pathtracer I wrote...\nApologies for the poorly written code, I wrote this on my phone and ported it here.",
            "flags": 32,
            "hasliked": 0,
            "id": "wlcGW4",
            "likes": 5,
            "name": "Simple Multipass Pathtracer",
            "published": 3,
            "tags": [
                "3d",
                "raytracing",
                "pathtracing"
            ],
            "usePreview": 0,
            "username": "space928",
            "viewed": 515
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0,uv).rgb;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//uniform float time;\n//uniform vec2 resolution;\n//uniform sampler2D PerlinNoise;\n//uniform sampler2D Mountain;\n//uniform int frame;\n//uniform sampler2D backbuffer;\n//uniform sampler2D noisec;\n//uniform samplerCube Sky2;\n\nfloat EPSILON = 0.005;\nint BOUNCES = 3;\nint MARCHSTEPS = 128;\nfloat MAX_DIST = 32.0;\nvec3 pos = vec3(0.0, 0.0, -3.8);\nvec3 posTime = vec3(0.0, .0, 0.0);\nvec3 lightDir = vec3(0.2, 0.8, -0.6);\nfloat lightStrength = 3.;\n\n//float seed = 0.;\n\nfloat hash(inout float seed)\n{\n  return fract(sin(seed++)*1484279.43123);\n}\n\nvec3 rvec(inout float seed)\n{\n  return vec3(hash(seed),hash(seed),hash(seed))*2.-1.;\n}\n\nvec3 cosineDir(inout float seed, vec3 nor)\n{\n  vec2 uv = vec2(hash(seed),hash(seed));\n  //uv = smoothstep (0.4,.6,uv);\n\n  //stolen from the web\n  float a = 6.2831853*uv.y;\n  uv.x = uv.x *2.-1.;\n  return normalize(nor + vec3(sqrt(1.-uv.x*uv.x)*vec2(cos(a),sin(a)),uv.x));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n    vec3 q = vec3(p.x, fract(p.y) * 2.0 - 1.0, p.z);\n\n    return length(max(abs(q)-b,0.0))-r;\n}\n\nfloat sphere(vec3 p)\n{\n    vec3 q = fract(p/2.) * 2.0 - 1.0;\n     q = vec3(q.x,p.y,q.z);\n\n    return length(q) - 0.3;\n}\n\nfloat sphere(vec3 p, vec3 o, float r)\n{\n  return length (p-o)-r;\n}\n\nfloat plane(vec3 p, float h)\n{\n  return p.y-h;\n}\n\nvec3 rot(vec3 p)\n{\n  p *= mat3(cos(iTime), 0., sin(iTime),\n            0., 1., 0.,\n            -sin(iTime), 0., cos(iTime));\n  return p;\n}\n\nfloat map(vec3 p)\n{\n  //p = rot(p);\n\n  float d = udRoundBox(p + vec3(-1., .0, 1.), vec3(.2, 1., .2), 0.05);\n  d = min(d, udRoundBox(p + vec3(-1., .0, -1.), vec3(.2, 1., .2), 0.05));\n  d = min(d, udRoundBox(p + vec3(1., .0, -1.), vec3(.2, 1., .2), 0.05));\n  d = min(d, udRoundBox(p + vec3(1., .0, 1.), vec3(.2, 1., .2), 0.05));\n\n  d = min(d, udRoundBox(p + vec3(-1., .0, .0), vec3(.2, .2, 1.), 0.05));\n  d = min(d, udRoundBox(p + vec3(1., 0., .0), vec3(.2, .2, 1.), 0.05));\n  d = min(d, udRoundBox(p + vec3(0., 0., -1.), vec3(1., .2, 0.2), 0.05));\n  d = min(d, udRoundBox(p + vec3(0., 0., 1.), vec3(1., .2, 0.2), 0.05));\n\n  d = min(d, sphere(p));\n  d = min(d, plane(p,-.2));\n\n  //d = min(d, sphere (p, vec3(0.), 1.9));\n\n  return d;\n}\n\nfloat trace(vec3 o, vec3 r) {\n    float t = 0.0;\n\n    for( int i=0;i<MARCHSTEPS;i++ ) {\n        vec3 p = o + r * t;\n\n        float d = map(p);\n\n        if(d < 0.)\n          return t + d;\n\n        t += d;\n    }\n    return t;\n}\n\nvec3 estimateNormal(vec3 p)\n{\n  return normalize(vec3( map(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),\n     map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\n     map(vec3(p.x, p.y, p.z + EPSILON)) - map(vec3(p.x, p.y, p.z - EPSILON)) ));\n}\n\nvec3 hsv2rgb( in vec3 c )\n{\n      vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n      return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat brdf(vec3 n, vec3 l)\n{\n  return clamp(-dot(n, l),0.5,1.);\n}\n\nvec3 sampleBounce(vec3 o, vec3 r, out vec3 n)\n{\n  vec3 t = vec3(trace(o, r));\n    //t *= vec3(1.0, 0.6, 0.4);\n     n = estimateNormal(o+r* t);\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float seed = iTime*10000.+uv.x*3256.5357+uv.y*26456.7557;\n\n    vec3 ocol = texture(iChannel0, fragCoord.xy / iResolution.xy).rgb;\n\n    vec3 r = normalize(vec3(uv+.75*rvec(seed).xy/iResolution.xy, 1.0));\n    vec3 o = pos + (iTime*posTime);\n    vec3 weight = vec3(1.);\n    vec3 acc = vec3(0.);\n    vec3 nrm;\n\n    vec3 p1;\n\n    for(int b = 0; b<= BOUNCES; b++)\n    {\n        //vec3 nrm;\n        vec3 p = sampleBounce(o,r, nrm);\n        //vec3 fog = 1.0 / (1.0 + t * t * 0.1);\n        //fog *= dot((lightDir), nrm);//rot(nrm));\n        if(length(p)>MAX_DIST)\n        {\n            acc = weight * texture(iChannel1, r).xyz* lightStrength;\n\n            if(b==0)\n                acc = texture(iChannel2, uv*.5+.5).rgb;\n\n            /*if(b==1)\nacc = vec3(1.,0.,0.);\nif(b==2)\nacc = vec3(0.,1.,0.);\nif(b==3)\nacc = vec3(0.,0.,1.);*/\n            break;\n        }\n\n        if(b==BOUNCES)\n            acc = vec3(0.,0.,.1);\n\n        //o = p;\n        r = reflect(r,nrm);// + .025*rvec(seed);//normalize(texture2D(noisec,p.xz+time).rgb*2.-1.);\n        r = mix(r,cosineDir(seed, nrm),.05);\n        //r = normalize(r.xyz*vec3(1.,-1.,1.));\n        //o += -r*5.;\n        weight *= brdf(nrm, r);\n    }\n\n    vec3 col = acc;\n    //col= p1/10.;\n\n    float fframe = float(iFrame+1);//float(iFrame)*0.+1.;\n    fragColor = vec4(mix(ocol,col,1./fframe),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}