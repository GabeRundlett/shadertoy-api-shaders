{
    "Shader": {
        "info": {
            "date": "1504446861",
            "description": "Lit up hexagons",
            "flags": 0,
            "hasliked": 0,
            "id": "MlXyDr",
            "likes": 3,
            "name": "Trippy Hex lights",
            "published": 3,
            "tags": [
                "lights",
                "hexagons"
            ],
            "usePreview": 0,
            "username": "TheGrego",
            "viewed": 359
        },
        "renderpass": [
            {
                "code": "// Created by greg kepler\n// Credit to \n// - iq for the hexagon, hash1, and noise functions [https://www.shadertoy.com/view/Xd2GR3]\n// - easing from https://github.com/glslify/glsl-easings \n\nvec4 hexagon( vec2 p ) \n{\n\tvec2 q = vec2( p.x*2.0*0.5773503, p.y + p.x*0.5773503 );\n\t\n\tvec2 pi = floor(q);\n\tvec2 pf = fract(q);\n\n\tfloat v = mod(pi.x + pi.y, 3.0);\n\n\tfloat ca = step(1.0,v);\n\tfloat cb = step(2.0,v);\n\tvec2  ma = step(pf.xy,pf.yx);\n\t\n    // distance to borders\n\tfloat e = dot( ma, 1.0-pf.yx + ca*(pf.x+pf.y-1.0) + cb*(pf.yx-2.0*pf.xy) );\n\n\t// distance to center\t\n\tp = vec2( q.x + floor(0.5+p.y/1.5), 4.0*p.y/3.0 )*0.5 + 0.5;\n\tfloat f = length( (fract(p) - 0.5)*vec2(1.0,0.85) );\t\t\n\t\n\treturn vec4( pi + ca - cb*ma, e, f );\n}\n\nfloat hash1( vec2  p ) { float n = dot(p,vec2(127.1,311.7) ); return fract(sin(n)*43758.5453); }\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat qinticInOut(float t) {\n  return t < 0.5\n    ? +16.0 * pow(t, 5.0)\n    : -0.5 * pow(2.0 * t - 2.0, 5.0) + 1.0;\n}\n\nvec2 rotate(vec2 p, float a ){\n    mat2 r = mat2( cos(a), -sin(a),\n                sin(a), cos(a) );\n    return r * p;\n}\n\nvec3 hsv2rgb(vec3 c) {\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat remap(float a, float b, float c, float d, float t) {\n\treturn ((t-a)/(b-a))*(d-c)+c;\n}\n\nfloat flower(vec2 pos, vec2 center, vec4 h, float time, float duration, float radiusFactor){\n\t\n    float radius = mod(time, duration) / duration;\n    float a = 1.0 - pow((abs(radius - 0.5)/ 0.5), 4.0);\n    radius = qinticInOut(clamp(radius / 0.5, 0.0, 1.0)) * radiusFactor;\n    \n    float dist = distance(center.xy,  pos.xy ) + h.w;\n    float blast = smoothstep(radius, radius - 0.5, dist);\n    blast *= smoothstep(radius, radius - 0.5, dist);\n    blast *= a;\n    return blast;\n}\n\n// \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 pos = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    \n    // rotate, move, and scale\n    pos = rotate(pos, (iTime * 0.25) );\n    pos.x *= sin(iTime + pos.x * 2.0);\n    pos = rotate(pos, sin(iTime + length(uv) * 2.0) * 0.5 );\n    \n    // simple rotate\n    //pos = rotate(pos, (iTime * 0.1) );\n    \n\n    // multiply position for repetition\n    vec2 hexPos = 7.0 * pos;\n    //vec4 h = hexagon(hexPos);\t\t\t\t\t\t\t// static position\n    vec4 h = hexagon(hexPos + vec2(0.2*iTime, 0.0));\t// move position offset\n\t\n    // noise values\n    float n1 = noise( vec3( 0.3*h.xy + iTime * 0.1, 0.5) );\n    float n2 = noise( vec3(-0.1*h.xy + iTime * n1 * 0.005, 0.5 ) );\n    \n    vec3 hexCol = vec3( n1 + n2 );\n    \n    // border thickness\n    float b = 0.01 + (remap(-1.0, 1.0, -0.25, 0.25, sin(iTime * 1.0)) * length(pos) * 5.0);\n    hexCol *= smoothstep( b, b + 0.15, h.z ); \t\t\t// border\n    //hexCol *= 2.0 + 0.15*sin(30.0*h.z);\t  \t\t\t// inner stripes\n    hexCol *= 2.0 + hexagon(hexPos * 6.0).z * 0.5;\t  \t// inner hex\n    hexCol *= 2.0 + h.z;\n    \n    // pick a pos\n    vec2 blastPos = vec2(0.0, 0.0);\n    vec3 flowerColor = vec3(0.0);\n    float count = 5.0;\n    float delta = 1.0 / count;\n    float duration = 10.0;\n\t\n    // cascade the colors\n    for(int i = 0; i < int(count); i++){\n        float fI = float(i);\n        float radius = 5.0 + (fI*0.5);\n        vec3 baseColor = hsv2rgb(vec3(mod(fI * delta, 1.0), 1.0, 1.0));\n       // vec3 baseColor = hsv2rgb(vec3(mod(iTime * 0.1 + fI * delta * 0.1, 1.0), 1.0, 1.0));\n        vec3 c = vec3(flower(hexPos, blastPos, h, iTime + fI * (duration/count), duration, radius )) * baseColor;\n        c *= delta;\n        flowerColor += c;\n        \n    }\n    \n    vec3 col = flowerColor * hexCol;\n\tfragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}