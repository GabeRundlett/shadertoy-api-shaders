{
    "Shader": {
        "info": {
            "date": "1637346498",
            "description": "Sources of learning from Inigo Quilez's videos and articles, The Book of Shaders, and the Art of Code YouTube channel.\n\nView it on Khan Academy (very different):\nhttps://www.khanacademy.org/computer-programming/infinity-unknown/5378626088386560",
            "flags": 0,
            "hasliked": 0,
            "id": "NsKXR3",
            "likes": 6,
            "name": "The Infinity Unknown",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "prishainabox",
            "viewed": 334
        },
        "renderpass": [
            {
                "code": "const float EPSILON = 0.001;\nconst float MAX_DIST = 70.0;\n\n//*******************************************************//\n\n// Light struct\nstruct Light {\n    vec3 clr;\n    vec3 dir;\n    float shadowSoftness;\n};\n\n// Material structure\nstruct Material {\n    vec3 clr;\n    float amb;\n    float dif;\n    float spec;\n    float shininess;\n    vec3 ref;\n    float id;\n};\n\n// function to return default material\nMaterial defaultMaterial() {\n    Material mat;\n    mat.amb = 0.1;\n    mat.clr = vec3(0.05);\n    mat.dif = 1.0;\n    mat.spec = 1.0;\n    mat.shininess = 10.0;\n    mat.ref = vec3(0.0);\n    mat.id = -1.0;\n    return mat;\n}\n\n//*******************************************************//\n\n// clamp value from 0 to 1\nfloat uclamp(float val) {\n    return clamp(val, 0.0, 1.0);\n}\n\n//*******************************************************//\n\n// random value from 0 to 1\n// https://thebookofshaders.com/10/\nfloat random(in vec2 v) {\n    return fract(15465.1327854 * sin(dot(v, vec2(173.93422, 102.5165))));\n}\n\n//*******************************************************//\n\n// https://iquilezles.org/articles/smin\n\n// smooth min\nfloat smoothmin(in float a, in float b, in float k) {\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// smooth max\nfloat smoothmax( float a, float b, float k ) {\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n// Smooth min for distance and color\n// returns rgb and d in vec4\nvec4 smoothmin(in float a, in float b, in vec3 clr1, in vec3 clr2, in float k) {\n\n   float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n   \n   // distance\n   float d = mix(b, a, h) - k*h*(1.0-h);\n   // color\n   vec3 c = mix(clr2, clr1, smoothstep(0.0, 1.0, h));\n   \n   return vec4(c, d);\n   \n}\n\n//*******************************************************//\n\n// SDFs\n\n// SDF box\n// https://www.youtube.com/watch?v=62-pRVZuS5c\nfloat sdBox(vec3 pt, vec3 b) {\n\tvec3 q = abs(pt) - b;\n\treturn length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n//*******************************************************//\n\n\n// MAIN SDF\n\nfloat sdf(in vec3 pt, out Material mat) {\n\n    // defaults\n    mat = defaultMaterial();\n    \n    // distance to closest object\n    float res;\n    \n    // sand\n    vec3 sandClr;\n    float sand;\n    {\n    \n        // sand clr\n        sandClr = vec3(0.13, 0.13, 0.08) * 0.8;\n        sandClr.rg += random(pt.xz*10.9)*0.05;\n        sand = pt.y + 2.35;\n       \n        // mountain range\n        float h = 2.4 + 0.35*texture(iChannel1, pt.xz*0.02).r + 0.6*texture(iChannel0, pt.xz*0.05).r*smoothstep(-20.0, -19.9, pt.z); \n        sand -= h*smoothstep(0.0, 20.0, abs(pt.x-10.0))*(0.9*sin(pt.z*0.45)+0.9)*smoothstep(15.0, 30.0, length(pt));\n        \n        // plane distortion by texture -> \"sand\"\n        sand += (0.1*texture(iChannel1, pt.xz*0.1).r + 0.05*texture(iChannel1, pt.xz*0.2).r);\n        \n    }\n    \n    // path\n    vec3 pathClr;\n    float path;\n    {\n    \n        // path clr\n        pathClr = vec3(0.17, 0.16, 0.09) * 0.5;\n        pathClr.rgb += texture(iChannel0, pt.zx*0.25).r * 0.2;\n   \n        // path shape -> distort x by z value of pt\n        path = sdBox(\n            pt - vec3(sin(pt.z) + 10.0*smoothstep(3.0, -20.0, pt.z) - 0.3, -2.35, 0), \n            vec3(2.7, 0.2, 40.0)\n        );\n        // distort by texture (bricks)\n        path -= pathClr.r * (0.2 * smoothstep(-4.0, 3.0, pt.z) + 0.15);\n        \n        // add noise to path clr\n        pathClr.rgb += texture(iChannel1, pt.zx*0.03).r * 0.05;\n       \n    }\n\n    // blend distance and clr (sand and path)\n    vec4 blend = smoothmin(sand, path, sandClr, pathClr, 0.75);\n    res = blend.w;\n\n    // material\n    mat.clr = blend.rgb;\n    mat.id = 0.0;\n    mat.shininess = 10.0;\n    mat.spec = 0.2;\n\n    return res;\n    \n}\n\n//*******************************************************//\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 pt) {\n    vec2 h = vec2(EPSILON, 0);\n    Material m;\n    // central difference sdf(pt + EPSILON) - sdf(pt - EPSILON)    \n    return normalize(vec3(\n       sdf(pt + h.xyy, m) - sdf(pt - h.xyy, m),\n       sdf(pt + h.yxy, m) - sdf(pt - h.yxy, m),\n       sdf(pt + h.yyx, m) - sdf(pt - h.yyx, m)\n    ));\n}\n\n//*******************************************************//\n\nfloat castRay(in vec3 ro, in vec3 rd, out Material mat) {\n\n    // total distance traveled\n    float td = 0.0;\n    \n    for (int i = 0; i < 256; i++) {\n        float h = sdf(ro + td*rd, mat);\n        // if distance is really close, break\n        if (abs(h) < (0.0001*td)) break;\n        // add to total distance\n        td += h;\n        // if too far, break\n        if (td >= MAX_DIST) {\n            mat.id = -1.0;\n            mat.ref = vec3(0.0);\n            break;\n        }\n    }\n    \n    return td;\n    \n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat softShadow(in vec3 ro, in vec3 rd, in float k) {\n\n    float res = 1.0; // result\n    float td = 0.05; // total distance traveled\n    \n    for (int i = 0; i < 256 && td < MAX_DIST; i++) {\n        Material m;\n        float d = sdf(ro + td*rd, m);\n        if (d < 0.001) {\n            // intersection, so return shadow\n            return 0.0;\n        }\n        res = min(res, k*d/td);\n        td += d;\n    }\n    \n    // if no intersection -> shadow 0.0 to light 1.0\n    return res;\n    \n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcc(in vec3 pt, in vec3 nor) {\n\n    float occ = 0.0;\n    float scl = 1.0;\n    \n    Material m; // placeholder\n    \n    for (int i = 0; i < 4; i++) {\n        float h = 0.01 + 0.11 * 0.25 * float(i);\n        float d = sdf(pt + h * nor, m);\n        occ += (h-d)*scl;\n        scl *= 0.95;\n    }\n    \n    return uclamp(1.0 - 2.0 * occ);\n    \n}\n\n//*******************************************************//\n\n// https://iquilezles.org/articles/fog\nvec3 applyFog(in vec3 rd, in float d, in vec3 clr, in vec3 sunClr, in vec3 sunDir, in vec3 skyClr) {\n    \n    // mix sun clr with sky clr to get fog clr\n    vec3 fogClr = mix( skyClr, sunClr, pow(max(dot(rd, sunDir), 0.0), 15.0) );\n    \n    // mix pixel clr with fog clr\n    return mix(clr, fogClr, 1.0 - exp(-0.0025 * d * d)); // fog\n    \n}\n\nvec3 calcLighting(in vec3 pt, in vec3 rd, in vec3 nor, in Light light, in Material mat) {\n    \n    // diffuse\n    float dif = uclamp(dot(nor, light.dir)) * mat.dif;\n    \n    // shadow\n    float shadow = softShadow(pt, light.dir, light.shadowSoftness);\n    \n    // specular\n    vec3 ref = reflect(light.dir, nor);\n    float spec = pow(uclamp(dot(rd, ref)), mat.shininess) * mat.spec;\n\n    // return dif * clr * shadow * spec + dif * clr * shadow; \n    return light.clr * shadow * dif * (spec + 1.0);\n    \n}\n\nvec3 calcClr(in vec2 uv, in vec3 ro, in vec3 rd, in float d, in vec3 nor, in Material mat) {\n\n    // from camera to point in scene\n    vec3 pt = ro + rd * d;\n\n    // SKY CLR\n    vec3 skyClr = vec3(1.2, 0.65, 0.8);\n    skyClr -= 0.9*smoothstep(0.5, 2.0, uv.y);\n    \n    // KEY LIGHT\n    Light sun;\n    sun.clr = vec3(1.1, 0.9, 0.5) * 4.0;\n    sun.dir = normalize(vec3(0.8, 0.2, -0.4));\n    sun.shadowSoftness = 20.0;\n    \n    // background color\n    vec3 shine = sun.clr * 0.15 * pow(max(dot(sun.dir, rd), 0.0), 13.0);\n    \n    // return background if too far (id is -1.0)\n    if (mat.id == -1.0) {\n    \n        // stars\n        float scl = 45.0;\n        vec2 fid = fract(uv * scl); // fractional component\n        vec2 id = floor(uv * scl); // integer component\n        vec3 starClr;\n        float circle = smoothstep(0.2*smoothstep(scl*0.3, scl, id.y)*random(id), 0.0, length(fid-vec2(0.5)));\n        float n = smoothstep(0.0, scl*0.9, id.y) * texture(iChannel1, uv*0.5).r;\n        starClr += random(id) + id.y*0.001 > 0.95 ? circle*n : 0.0;\n        // add star clr to sky clr\n        skyClr += 0.7*starClr;\n        \n        // return sky\n        return skyClr + shine;\n        \n    }\n    \n    // material id is not -1.0, so we hit an obj\n    vec3 clr = mat.clr;\n    \n    // CALCULATE COLOR\n    float occ = calcOcc(pt, nor); // ambient occlusion\n    vec3 light = vec3(mat.amb); // ambient\n    light += calcLighting(pt, rd, nor, sun, mat) * occ; // sun\n    light += uclamp(dot(nor, vec3(0,  1, 0))) * skyClr * occ; // sky diffuse\n    clr *= light;\n    \n    // apply fod\n    clr = applyFog(rd, d, clr, sun.clr * 0.17, sun.dir, skyClr);\n    \n    return clr + shine;\n\n}\n\n//*******************************************************//\n\nvec3 render(in vec2 uv, in vec3 ro, in vec3 rd) {\n    \n    // material and clr\n    Material mat;\n    vec3 clr = vec3(0);\n\n    // get distance to point\n    float d = castRay(ro, rd, mat);\n    // surface normal\n    vec3 nor = calcNormal(ro + rd*d);\n    \n    // calculate the color of the pixel\n    clr = calcClr(uv, ro, rd, d, nor, mat);\n    \n    // gamma correction\n    clr = pow(clr, vec3(1.0 / 2.2)); \n    \n    return clr;\n    \n}\n\n//*******************************************************//\n\n// https://www.youtube.com/watch?v=Cfe5UQ-1L9Q\n// https://learnopengl.com/Getting-started/Camera\nvec3 setCamera(in vec2 uv, in vec3 ro, in vec3 target) {\n\n    vec3 forward = normalize(target - ro);\n    vec3 right = normalize(cross(forward, vec3(0, 1, 0)));\n    vec3 up = normalize(cross(right, forward));\n    \n    // ray direction\n    vec3 rd = normalize(uv.x * right + uv.y * up + 1.2 * forward);\n    \n    return rd;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // resolution\n    vec2 res = iResolution.xy;\n    \n    // Normalized pixel coordinates\n    vec2 uv = (2.0*fragCoord - res) / min(res.x, res.y);\n    \n    // target\n    vec3 target = vec3(0, -0.5, 0);\n    // ray origin\n    vec3 ro = vec3(0.0, 0.2, 8.0);\n    \n    // set camera\n    vec3 rd = setCamera(uv, ro, target);\n    \n    // calculate color based on distance, etc\n    vec3 clr = render(uv, ro, rd);\n\n    // Output to screen\n    fragColor = vec4(clr, 1.0);\n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}