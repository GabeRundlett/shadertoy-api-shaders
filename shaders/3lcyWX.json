{
    "Shader": {
        "info": {
            "date": "1609971406",
            "description": "Probably my best SDF model yet! I am planning on using it in a game or something else related.",
            "flags": 0,
            "hasliked": 0,
            "id": "3lcyWX",
            "likes": 5,
            "name": "Airplane - Modelling Exercise",
            "published": 3,
            "tags": [
                "sdf",
                "exercise",
                "modelling",
                "airplane"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 182
        },
        "renderpass": [
            {
                "code": "/*\nProbably my best SDF model yet!\nIf you have suggestions on how to improve the propeller SDF I would really like to\nknow. In case you are wondering it is a squashed Bernoulli lemniscate.\n\nThe MIT License\nCopyright Â© 2020 Elijah Bevers\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and\nassociated documentation files (the \"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the\nfollowing conditions: The above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY\nKIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\nPARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR\nANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n// Distance functions and SDF operators are from Inigo Quilez's distance functions article (https://iquilezles.org/articles/distfunctions):\nfloat opExtrusion(in vec3 p, in float d, in float h) {\n    // d is the distance to the 2D shape using the x and y components of p\n    vec2 w = vec2(d, abs(p.z) - h);\n    return min(max(w.x, w.y), 0.0) + length(max(w, 0.0));\n}\n\nvec3 opTwist(in vec3 p, in float t) {\n    float c = cos(t * p.y);\n    float s = sin(t * p.y);\n    mat2 m = mat2(c, -s, s, c);\n    return vec3(m * p.xz, p.y);\n}\n\nfloat sdBox2D(in vec2 p, in vec2 b) {\n    vec2 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0);\n}\n\nfloat sdTrapezoid(in vec2 p, in float r1, in float r2, in float he) {\n    vec2 k1 = vec2(r2, he);\n    vec2 k2 = vec2(r2 - r1, 2.0 * he);\n\n\tp.x = abs(p.x);\n    vec2 ca = vec2(max(0.0, p.x - ((p.y < 0.0) ? r1 : r2)), abs(p.y) - he);\n    vec2 cb = p - k1 + k2 * clamp(dot(k1 - p, k2) / dot(k2, k2), 0.0, 1.0);\n    \n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    \n    return s * sqrt(min(dot(ca, ca), dot(cb, cb)));\n}\n\nfloat sdBox(in vec3 p, in vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdCylinder(in vec3 p, in float h, in float r) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat BernoulliDE(in vec2 p, in vec2 scale) {\n    vec2 ps = p / scale;\n\n    float l = ps.x - 1.0;\n    float r = ps.x + 1.0;\n    float ys = ps.y * ps.y;\n\n    float bernoulli = sqrt(l * l + ys) * sqrt(r * r + ys) - 1.0;\n\n    vec2 pSqrS = p / (scale * scale);\n    float sInvX = 1.0 / scale.x;\n    float ls = pSqrS.x - sInvX;\n    float rs = pSqrS.x + sInvX;\n\n    float psSqrY = ps.y * ps.y;\n    float ld = sqrt(l * l + psSqrY);\n    float rd = sqrt(r * r + psSqrY);\n\n    float pdx = (ls * rd) / ld + (rs * ld) / rd;\n    float pdy = (rd / ld + ld / rd) * pSqrS.y;\n    float bernoulliGrad = sqrt(pdx * pdx + pdy * pdy);\n\n    return bernoulli / bernoulliGrad;\n}\n\nfloat mapScene(in vec3 p) {\n    float airplane = sdBox(p, vec3(0.4, 0.4, 2.8)) - 0.146;\n    airplane += smoothstep(-4.0, 10.0, p.z);\n\n    vec3 wp = p;\n    wp.yz *= mat2(0.99801615628, 0.06295833376, -0.06295833376, 0.99801615628);\n\n    float wing = sdTrapezoid(p.xz + vec2(0.0, 1.4), 2.85, 2.7, 0.3) - 0.25;\n    airplane = min(airplane, opExtrusion(wp.xzy - vec3(0.0, 0.0, 0.212), wing, 0.052) - 0.1);\n\n    vec3 tp = p - vec3(0.0, 0.0, 2.5);\n    float tail = sdTrapezoid(tp.xz, 0.85, 1.0, 0.475) - 0.1;\n    airplane = min(airplane, opExtrusion(tp.xzy, tail, 0.05) - 0.1);\n\n    tp.yz -= vec2(1.0, 0.25 * tp.y - 0.025);\n    tail = sdBox2D(tp.zy, vec2(0.3, 0.75)) - 0.1;\n    tail = 0.82 * tail + tp.y * 0.164;\n    airplane = min(airplane, opExtrusion(tp.zyx, tail, 0.05) - 0.1);\n\n    vec3 pp = p + vec3(0.0, 0.0, 3.0);\n\n    float r = iTime * 5.0;\n    float c = cos(r), s = sin(r);\n    pp.xy *= mat2(c, s, -s, c);\n\n    airplane = min(airplane, sdCylinder(pp.xzy, 0.05, 0.2));\n\n    float prop;\n    if (abs(pp.x) > 1.5 || abs(pp.y) > 1.05 || abs(pp.z) > 0.25) {\n        prop = sdBox(pp, vec3(1.4, 0.95, 0.2));\n    }\n\n    else {\n        pp = opTwist(pp, 0.4).xzy;\n        prop = opExtrusion(pp, BernoulliDE(pp.xy, vec2(1.0, 0.5)), 0.02) - 0.02;\n        prop *= 0.9;\n    }\n\n    airplane = min(airplane, prop);\n\n    vec3 sp = vec3(abs(wp.x) - 0.51, p.yz + vec2(1.0, 2.5));\n    sp.xy *= mat2(0.98877107793, 0.14943813247, -0.14943813247, 0.98877107793);\n\n    float struts = sdTrapezoid(sp.zy, 0.1, 0.2, 0.55) - 0.05;\n    airplane = min(airplane, opExtrusion(sp.yzx, struts, 0.03) - 0.025);\n\n    wp = sp + vec3(0.0, 0.5, 0.0);\n    float wheels = sdCylinder(wp.yxz, 0.1, 0.24) - 0.05;\n    airplane = min(airplane, wheels);\n\n    return airplane;\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapScene(p + vec3(0.001, 0.0, 0.0)) - mapScene(p - vec3(0.001, 0.0, 0.0)),\n                          mapScene(p + vec3(0.0, 0.001, 0.0)) - mapScene(p - vec3(0.0, 0.001, 0.0)),\n                          mapScene(p + vec3(0.0, 0.0, 0.001)) - mapScene(p - vec3(0.0, 0.0, 0.001))));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 10.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float c1 = cos(iTime), s1 = sin(iTime);\n    float c2 = cos(0.25), s2 = sin(0.25);\n\n    float t = 0.0;\n    for (float iters=0.0; iters < 150.0; iters++) {\n        vec3 p = ro + rd * t;\n\n        p.y += 0.5;\n        p.xz *= mat2(c1, -s1, s1, c1);\n        p.yz *= mat2(c2, s2, -s2, c2);\n\n        float d = mapScene(p / 1.5) * 1.5;\n        if (d < 0.001) {\n            vec3 n = getNormal(p / 1.5) * 1.2;\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n\n            n.yz *= mat2(c2, -s2, s2, c2);\n            n.xz *= mat2(c1, s1, -s1, c1);\n\n            fragColor.rg += max(0.2, dot(n, l));\n            break;\n        }\n\n        if (t > 50.0) {\n            break;\n        }\n\n        t += d;\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}