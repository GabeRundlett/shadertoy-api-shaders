{
    "Shader": {
        "info": {
            "date": "1501590116",
            "description": "Simple flocking / schooling simulation.\nEntry for round #3 of the Shadertoy competition 2017\n\nSpace or Left / Right to navigate\nUp / Down to Increase / Decrease Boid count",
            "flags": 112,
            "hasliked": 0,
            "id": "Md2fzV",
            "likes": 71,
            "name": "[SH17C] Schooling",
            "published": 3,
            "tags": [
                "fish",
                "birds",
                "flock",
                "boids",
                "sh17c",
                "schooling"
            ],
            "usePreview": 1,
            "username": "P_Malin",
            "viewed": 2844
        },
        "renderpass": [
            {
                "code": "// [SH17C] Schooling\n// @P_Malin\n// Entry for round #3 of the Shadertoy competition 2017\n\n// References:\n\n// \"Flocks, Herds, and Schools: A Distributed Behavioral Model\"\n// Craig Reynolds\n// http://www.cs.toronto.edu/~dt/siggraph97-course/cwr87/\n\n// \"Steering Behaviors For Autonomous Characters\"\n// Craig Reynolds\n// http://www.red3d.com/cwr/steer/gdc99/\n\n\n// The code for the boid update is in \"Buf B\"\n\n\n// Image shader\n\n// Image composision\n// UI composition\n// Text composition\n\n#define iChannelUI iChannel0\n#define iChannelRender iChannel1\n#define iChannelFont iChannel3\n\n// ---------------------- 8< --------------------- 8< --------------------------\n\n///////////////////////////\n// UI Data\n///////////////////////////\n\nfloat UI_GetFloat( int iData )\n{\n    return texelFetch( iChannelUI, ivec2(iData,0), 0 ).x;\n}\n\nbool UI_GetBool( int iData )\n{\n    return UI_GetFloat( iData ) > 0.5;\n}\n\nvec3 UI_GetColor( int iData )\n{\n    return texelFetch( iChannelUI, ivec2(iData,0), 0 ).rgb;\n}\n\n\nvoid UI_Compose( vec2 fragCoord, inout vec3 vColor, out int windowId, out vec2 vWindowCoord )\n{\n    vec4 vUISample = texelFetch( iChannelUI, ivec2(fragCoord), 0 );\n    \n    if ( fragCoord.y < 2.0 )\n    {\n        // Hide data\n        vUISample = vec4(1.0, 1.0, 1.0, 1.0);\n    }\n    \n    vColor.rgb = vColor.rgb * (1.0f - vUISample.w) + vUISample.rgb;\n    \n    windowId = -1;\n    vWindowCoord = vec2(0);\n    \n    if ( vUISample.a < 0.0 )\n    {\n        vWindowCoord = vUISample.rg;\n        windowId = int(round(vUISample.b));\n    }\n}\n\n///////////////////////////\n// UI Data Definitions\n///////////////////////////\n\n// ---------------------- 8< --------------------- 8< --------------------------\n\nconst int\n     DATA_UICONTEXT\t\t\t\t\t\t= 0\n\t,DATA_WINDOW_CONTROLS   \t\t\t= 2\n    ,DATA_PAGE_NO\t\t\t\t\t\t= 4\n    ,DATA_FADE\t\t\t\t\t\t\t= 5\n\t,DATA_SEPARATION\t\t\t\t\t= 6\n\t,DATA_COHESION\t\t\t\t\t\t= 7\n\t,DATA_ALIGNMENT\t\t\t\t\t\t= 8\n    ,DATA_COUNT\t\t\t\t\t\t\t= 9\n    ,DATA_WALLS \t\t\t\t\t\t= 10\n    ;    \n\n// ---------------------- 8< --------------------- 8< --------------------------\n\n\n\n///////////////////////////\n// Font Printing\n///////////////////////////\nstruct TextLine\n{\n    int firstChar;\n    int charCount;\n};\n\nstruct TextPage\n{\n    int firstLine;\n    int lineCount;\n};\n\nstruct TextPages\n{\n    TextPage pages[18];\n    TextLine lines[81];\n    uint characters[539];\n};\nconst TextPages textPages = TextPages (\n   TextPage[18](\n       TextPage( 0, 1 ),\n       TextPage( 1, 2 ),\n       TextPage( 3, 1 ),\n       TextPage( 4, 10 ),\n       TextPage( 14, 1 ),\n       TextPage( 15, 5 ),\n       TextPage( 20, 1 ),\n       TextPage( 21, 11 ),\n       TextPage( 32, 1 ),\n       TextPage( 33, 7 ),\n       TextPage( 40, 1 ),\n       TextPage( 41, 8 ),\n       TextPage( 49, 1 ),\n       TextPage( 50, 13 ),\n       TextPage( 63, 1 ),\n       TextPage( 64, 11 ),\n       TextPage( 75, 0 ),\n       TextPage( 75, 6 )\n   ),\n   TextLine[81](\n       TextLine( 0, 17 ), // \"[SH17C] Schooling\"\n       TextLine( 17, 0 ), // \"\"\n       TextLine( 17, 23 ), // \"Press Space to continue\"\n       TextLine( 40, 17 ), // \"[SH17C] Schooling\"\n       TextLine( 57, 0 ), // \"\"\n       TextLine( 57, 57 ), // \"This shadertoy illustrates a simplified implementation of\"\n       TextLine( 114, 33 ), // \"the 1987 paper by Craig Reynolds.\"\n       TextLine( 147, 0 ), // \"\"\n       TextLine( 147, 59 ), // \"\"Flocks, herds and schools: A distributed behavioral model\"\"\n       TextLine( 206, 0 ), // \"\"\n       TextLine( 206, 50 ), // \"I always found this work fascinating in many ways.\"\n       TextLine( 256, 57 ), // \"To me this is the embodiment of a complex system, showing\"\n       TextLine( 313, 54 ), // \"how a set of agents with simple rules can give rise to\"\n       TextLine( 367, 26 ), // \"complex emergent behavior.\"\n       TextLine( 393, 5 ), // \"Boids\"\n       TextLine( 398, 0 ), // \"\"\n       TextLine( 398, 51 ), // \"We model a number of \"Boids\". Each boid just stores\"\n       TextLine( 449, 57 ), // \"a position and velocity. These are updated each frame. A \"\n       TextLine( 506, 61 ), // \"simple set of steering rules that modify the velocities gives\"\n       TextLine( 567, 39 ), // \"rise to the lifelike flocking behavior.\"\n       TextLine( 606, 14 ), // \"Flocking Rules\"\n       TextLine( 620, 0 ), // \"\"\n       TextLine( 620, 28 ), // \"We update each boid in turn.\"\n       TextLine( 648, 57 ), // \"Three steering rules produce the basic flocking behavior:\"\n       TextLine( 705, 0 ), // \"\"\n       TextLine( 705, 13 ), // \" - Separation\"\n       TextLine( 718, 11 ), // \" - Cohesion\"\n       TextLine( 729, 12 ), // \" - Alignment\"\n       TextLine( 741, 0 ), // \"\"\n       TextLine( 741, 34 ), // \"We weight each rule to control its\"\n       TextLine( 775, 35 ), // \"influence. Each of these rules only\"\n       TextLine( 810, 27 ), // \"considers nearby neighbors.\"\n       TextLine( 837, 10 ), // \"Separation\"\n       TextLine( 847, 0 ), // \"\"\n       TextLine( 847, 46 ), // \"The separation rule keeps flockmates apart. We\"\n       TextLine( 893, 48 ), // \"apply a force to the boid we are updating in the\"\n       TextLine( 941, 48 ), // \"direction pointing away from each local neighbor\"\n       TextLine( 989, 0 ), // \"\"\n       TextLine( 989, 36 ), // \"The strength of the separation force\"\n       TextLine( 1025, 34 ), // \"increases as the boids get closer.\"\n       TextLine( 1059, 8 ), // \"Cohesion\"\n       TextLine( 1067, 0 ), // \"\"\n       TextLine( 1067, 52 ), // \"The cohesion rule keeps the flock together, stopping\"\n       TextLine( 1119, 24 ), // \"boids wandering too far.\"\n       TextLine( 1143, 0 ), // \"\"\n       TextLine( 1143, 30 ), // \"The average position of nearby\"\n       TextLine( 1173, 30 ), // \"flockmates is calculated and a\"\n       TextLine( 1203, 33 ), // \"steering force is applied towards\"\n       TextLine( 1236, 14 ), // \"this location.\"\n       TextLine( 1250, 9 ), // \"Alignment\"\n       TextLine( 1259, 0 ), // \"\"\n       TextLine( 1259, 53 ), // \"The alignment rule keeps the flock moving in the same\"\n       TextLine( 1312, 10 ), // \"direction.\"\n       TextLine( 1322, 0 ), // \"\"\n       TextLine( 1322, 32 ), // \"The average velocity (or forward\"\n       TextLine( 1354, 31 ), // \"direction) of flockmates in the\"\n       TextLine( 1385, 34 ), // \"nearby neighborhood is calculated.\"\n       TextLine( 1419, 31 ), // \"This is the \"ideal\" or \"target\"\"\n       TextLine( 1450, 36 ), // \"velocity for this steering behavior.\"\n       TextLine( 1486, 33 ), // \"By subtracting the current boid's\"\n       TextLine( 1519, 35 ), // \"velocity from this target velocity,\"\n       TextLine( 1554, 29 ), // \"we get the alignment steering\"\n       TextLine( 1583, 15 ), // \"force to apply.\"\n       TextLine( 1598, 8 ), // \"Flocking\"\n       TextLine( 1606, 0 ), // \"\"\n       TextLine( 1606, 47 ), // \"These three simple rules give rise to the basic\"\n       TextLine( 1653, 47 ), // \"flocking behavior. With this model, there is no\"\n       TextLine( 1700, 44 ), // \"leader and each boid is just considering its\"\n       TextLine( 1744, 45 ), // \"local neighbors and yet we see flocks forming\"\n       TextLine( 1789, 45 ), // \"And we start to see emergent behavior such as\"\n       TextLine( 1834, 29 ), // \"flocks splitting and merging.\"\n       TextLine( 1863, 0 ), // \"\"\n       TextLine( 1863, 51 ), // \"By adding additional rules such as random wandering\"\n       TextLine( 1914, 47 ), // \"and collision avoidance we see more interesting\"\n       TextLine( 1961, 17 ), // \"behaviors emerge.\"\n       TextLine( 1978, 45 ), // \"The links to the original papers can be found\"\n       TextLine( 2023, 26 ), // \"In the \"Image\" shader tab.\"\n       TextLine( 2049, 46 ), // \"The boid simulation code is in the \"Buf B\" tab\"\n       TextLine( 2095, 0 ), // \"\"\n       TextLine( 2095, 38 ), // \"Use the sliders to experiment with the\"\n       TextLine( 2133, 23 ) // \"influence of each rule.\"\n\n   ),\n   uint[539](0x3148535bu, 0x205d4337u, 0x6f686353u, 0x6e696c6fu, 0x65725067u, 0x53207373u, 0x65636170u, 0x206f7420u, 0x746e6f63u, 0x65756e69u, 0x3148535bu, 0x205d4337u, 0x6f686353u, 0x6e696c6fu, 0x69685467u, 0x68732073u, 0x72656461u, 0x20796f74u, 0x756c6c69u, 0x61727473u, 0x20736574u, 0x69732061u, 0x696c706du, 0x64656966u, 0x706d6920u, 0x656d656cu, 0x7461746eu, 0x206e6f69u, 0x6874666fu, 0x39312065u, 0x70203738u, 0x72657061u, 0x20796220u, 0x69617243u, 0x65522067u, 0x6c6f6e79u, 0x222e7364u, 0x636f6c46u, 0x202c736bu, 0x64726568u, 0x6e612073u, 0x63732064u, 0x6c6f6f68u, 0x41203a73u, 0x73696420u, 0x62697274u, 0x64657475u, 0x68656220u, 0x6f697661u, 0x206c6172u, 0x65646f6du, 0x2049226cu, 0x61776c61u, 0x66207379u, 0x646e756fu, 0x69687420u, 0x6f772073u, 0x66206b72u, 0x69637361u, 0x6974616eu, 0x6920676eu, 0x616d206eu, 0x7720796eu, 0x2e737961u, 0x6d206f54u, 0x68742065u, 0x69207369u, 0x68742073u, 0x6d652065u, 0x69646f62u, 0x746e656du, 0x20666f20u, 0x6f632061u, 0x656c706du, 0x79732078u, 0x6d657473u, 0x6873202cu, 0x6e69776fu, 0x776f6867u, 0x73206120u, 0x6f207465u, 0x67612066u, 0x73746e65u, 0x74697720u, 0x69732068u, 0x656c706du, 0x6c757220u, 0x63207365u, 0x67206e61u, 0x20657669u, 0x65736972u, 0x636f7420u, 0x6c706d6fu, 0x65207865u, 0x6772656du, 0x20746e65u, 0x61686562u, 0x726f6976u, 0x696f422eu, 0x65577364u, 0x646f6d20u, 0x61206c65u, 0x6d756e20u, 0x20726562u, 0x2220666fu, 0x64696f42u, 0x202e2273u, 0x68636145u, 0x696f6220u, 0x756a2064u, 0x73207473u, 0x65726f74u, 0x70206173u, 0x7469736fu, 0x206e6f69u, 0x20646e61u, 0x6f6c6576u, 0x79746963u, 0x6854202eu, 0x20657365u, 0x20657261u, 0x61647075u, 0x20646574u, 0x68636165u, 0x61726620u, 0x202e656du, 0x69732041u, 0x656c706du, 0x74657320u, 0x20666f20u, 0x65657473u, 0x676e6972u, 0x6c757220u, 0x74207365u, 0x20746168u, 0x69646f6du, 0x74207966u, 0x76206568u, 0x636f6c65u, 0x65697469u, 0x69672073u, 0x72736576u, 0x20657369u, 0x74206f74u, 0x6c206568u, 0x6c656669u, 0x20656b69u, 0x636f6c66u, 0x676e696bu, 0x68656220u, 0x6f697661u, 0x6c462e72u, 0x696b636fu, 0x5220676eu, 0x73656c75u, 0x75206557u, 0x74616470u, 0x61652065u, 0x62206863u, 0x2064696fu, 0x74206e69u, 0x2e6e7275u, 0x65726854u, 0x74732065u, 0x69726565u, 0x7220676eu, 0x73656c75u, 0x6f727020u, 0x65637564u, 0x65687420u, 0x73616220u, 0x66206369u, 0x6b636f6cu, 0x20676e69u, 0x61686562u, 0x726f6976u, 0x202d203au, 0x61706553u, 0x69746172u, 0x2d206e6fu, 0x686f4320u, 0x6f697365u, 0x202d206eu, 0x67696c41u, 0x6e656d6eu, 0x20655774u, 0x67696577u, 0x65207468u, 0x20686361u, 0x656c7572u, 0x206f7420u, 0x746e6f63u, 0x206c6f72u, 0x69737469u, 0x756c666eu, 0x65636e65u, 0x6145202eu, 0x6f206863u, 0x68742066u, 0x20657365u, 0x656c7572u, 0x6e6f2073u, 0x6f63796cu, 0x6469736eu, 0x20737265u, 0x7261656eu, 0x6e207962u, 0x68676965u, 0x73726f62u, 0x7065532eu, 0x74617261u, 0x546e6f69u, 0x73206568u, 0x72617065u, 0x6f697461u, 0x7572206eu, 0x6b20656cu, 0x73706565u, 0x6f6c6620u, 0x616d6b63u, 0x20736574u, 0x72617061u, 0x57202e74u, 0x70706165u, 0x6120796cu, 0x726f6620u, 0x74206563u, 0x6874206fu, 0x6f622065u, 0x77206469u, 0x72612065u, 0x70752065u, 0x69746164u, 0x6920676eu, 0x6874206eu, 0x72696465u, 0x69746365u, 0x70206e6fu, 0x746e696fu, 0x20676e69u, 0x79617761u, 0x6f726620u, 0x6165206du, 0x6c206863u, 0x6c61636fu, 0x69656e20u, 0x6f626867u, 0x65685472u, 0x72747320u, 0x74676e65u, 0x666f2068u, 0x65687420u, 0x70657320u, 0x74617261u, 0x206e6f69u, 0x63726f66u, 0x636e6965u, 0x73616572u, 0x61207365u, 0x68742073u, 0x6f622065u, 0x20736469u, 0x20746567u, 0x736f6c63u, 0x432e7265u, 0x7365686fu, 0x546e6f69u, 0x63206568u, 0x7365686fu, 0x206e6f69u, 0x656c7572u, 0x65656b20u, 0x74207370u, 0x66206568u, 0x6b636f6cu, 0x676f7420u, 0x65687465u, 0x73202c72u, 0x70706f74u, 0x62676e69u, 0x7364696fu, 0x6e617720u, 0x69726564u, 0x7420676eu, 0x66206f6fu, 0x542e7261u, 0x61206568u, 0x61726576u, 0x70206567u, 0x7469736fu, 0x206e6f69u, 0x6e20666fu, 0x62726165u, 0x6f6c6679u, 0x616d6b63u, 0x20736574u, 0x63207369u, 0x75636c61u, 0x6574616cu, 0x6e612064u, 0x73612064u, 0x72656574u, 0x20676e69u, 0x63726f66u, 0x73692065u, 0x70706120u, 0x6465696cu, 0x776f7420u, 0x73647261u, 0x73696874u, 0x636f6c20u, 0x6f697461u, 0x6c412e6eu, 0x6d6e6769u, 0x54746e65u, 0x61206568u, 0x6e67696cu, 0x746e656du, 0x6c757220u, 0x656b2065u, 0x20737065u, 0x20656874u, 0x636f6c66u, 0x6f6d206bu, 0x676e6976u, 0x206e6920u, 0x20656874u, 0x656d6173u, 0x65726964u, 0x6f697463u, 0x68542e6eu, 0x76612065u, 0x67617265u, 0x65762065u, 0x69636f6cu, 0x28207974u, 0x6620726fu, 0x6177726fu, 0x69646472u, 0x74636572u, 0x296e6f69u, 0x20666f20u, 0x636f6c66u, 0x74616d6bu, 0x69207365u, 0x6874206eu, 0x61656e65u, 0x20796272u, 0x6769656eu, 0x726f6268u, 0x646f6f68u, 0x20736920u, 0x636c6163u, 0x74616c75u, 0x542e6465u, 0x20736968u, 0x74207369u, 0x22206568u, 0x61656469u, 0x6f20226cu, 0x74222072u, 0x65677261u, 0x65762274u, 0x69636f6cu, 0x66207974u, 0x7420726fu, 0x20736968u, 0x65657473u, 0x676e6972u, 0x68656220u, 0x6f697661u, 0x79422e72u, 0x62757320u, 0x63617274u, 0x676e6974u, 0x65687420u, 0x72756320u, 0x746e6572u, 0x696f6220u, 0x76732764u, 0x636f6c65u, 0x20797469u, 0x6d6f7266u, 0x69687420u, 0x61742073u, 0x74656772u, 0x6c657620u, 0x7469636fu, 0x65772c79u, 0x74656720u, 0x65687420u, 0x696c6120u, 0x656d6e67u, 0x7320746eu, 0x72656574u, 0x66676e69u, 0x6563726fu, 0x206f7420u, 0x6c707061u, 0x6c462e79u, 0x696b636fu, 0x6854676eu, 0x20657365u, 0x65726874u, 0x69732065u, 0x656c706du, 0x6c757220u, 0x67207365u, 0x20657669u, 0x65736972u, 0x206f7420u, 0x20656874u, 0x69736162u, 0x6f6c6663u, 0x6e696b63u, 0x65622067u, 0x69766168u, 0x202e726fu, 0x68746957u, 0x69687420u, 0x6f6d2073u, 0x2c6c6564u, 0x65687420u, 0x69206572u, 0x6f6e2073u, 0x6461656cu, 0x61207265u, 0x6520646eu, 0x20686361u, 0x64696f62u, 0x20736920u, 0x7473756au, 0x6e6f6320u, 0x65646973u, 0x676e6972u, 0x73746920u, 0x61636f6cu, 0x656e206cu, 0x62686769u, 0x2073726fu, 0x20646e61u, 0x20746579u, 0x73206577u, 0x66206565u, 0x6b636f6cu, 0x6f662073u, 0x6e696d72u, 0x646e4167u, 0x20657720u, 0x72617473u, 0x6f742074u, 0x65657320u, 0x656d6520u, 0x6e656772u, 0x65622074u, 0x69766168u, 0x7320726fu, 0x20686375u, 0x6c667361u, 0x736b636fu, 0x6c707320u, 0x69747469u, 0x6120676eu, 0x6d20646eu, 0x69677265u, 0x422e676eu, 0x64612079u, 0x676e6964u, 0x64646120u, 0x6f697469u, 0x206c616eu, 0x656c7572u, 0x75732073u, 0x61206863u, 0x61722073u, 0x6d6f646eu, 0x6e617720u, 0x69726564u, 0x6e61676eu, 0x6f632064u, 0x73696c6cu, 0x206e6f69u, 0x696f7661u, 0x636e6164u, 0x65772065u, 0x65657320u, 0x726f6d20u, 0x6e692065u, 0x65726574u, 0x6e697473u, 0x68656267u, 0x6f697661u, 0x65207372u, 0x6772656du, 0x68542e65u, 0x696c2065u, 0x20736b6eu, 0x74206f74u, 0x6f206568u, 0x69676972u, 0x206c616eu, 0x65706170u, 0x63207372u, 0x62206e61u, 0x6f662065u, 0x49646e75u, 0x6874206eu, 0x49222065u, 0x6567616du, 0x68732022u, 0x72656461u, 0x62617420u, 0x6568542eu, 0x696f6220u, 0x69732064u, 0x616c756du, 0x6e6f6974u, 0x646f6320u, 0x73692065u, 0x206e6920u, 0x20656874u, 0x66754222u, 0x20224220u, 0x55626174u, 0x74206573u, 0x73206568u, 0x6564696cu, 0x74207372u, 0x7865206fu, 0x69726570u, 0x746e656du, 0x74697720u, 0x68742068u, 0x666e6965u, 0x6e65756cu, 0x6f206563u, 0x61652066u, 0x72206863u, 0x2e656c75u)\n);\n\n\n\n\n///////////////////////////\n// Font Printing\n///////////////////////////\n\nvoid PrintChar( inout vec2 vOutCharUV, vec2 vUV, uint uChar )\n{\n    if ( any( lessThan( vUV, vec2(0) ) ) ) return;\n    if ( any( greaterThanEqual( vUV, vec2(1) ) ) ) return;\n        \n    uint uCharX = uChar % 16u;\n    uint uCharY = uChar / 16u;\n    \n    vec2 vCharPos = vec2(uCharX, uCharY) / 16.0;\n    vec2 vCharSize = vec2(1,1) / 16.0;\n    \n    vec2 vInset = vec2( 0.25, 0.0 );\n    \n    if ( uChar == 87u || uChar == 119u )\n        vInset.x -= 0.05; // thinner 'W'\n    \n    vCharPos += vCharSize * vInset;\n    \n    vCharSize *= 1.0 - vInset * 2.0;\n    \n    vOutCharUV = vUV * vCharSize + vCharPos;    \n}\n\nvoid PrintPage( inout vec2 vCharUV, vec2 vFontUV, int pageNo )\n{\n    int lineCharPos = int(floor(vFontUV.x));\n    int pageLine = int(floor(vFontUV.y));\n    \n    TextPage currPage = textPages.pages[pageNo];\n    \n\tif ( pageLine < 0 || pageLine >= currPage.lineCount )\n        return;\n    \n    TextLine currLine = textPages.lines[currPage.firstLine + pageLine];\n    \n\tif ( lineCharPos < 0 || lineCharPos >= currLine.charCount )\n        return;\n    \n    int charIndex = currLine.firstChar + lineCharPos;\n    \n    int charPos = charIndex / 4 ;\n    int charShift = 8 * (charIndex %4);\n    \n    uint char = ( textPages.characters[ charPos ] >> charShift ) % 256u;\n    \n    PrintChar( vCharUV, fract(vFontUV), char );\n}\n\nfloat DrawText( vec2 fragCoord, int pageNo )\n{\n    vec2 vFontUV = fragCoord / iResolution.xy;\n    vFontUV.y = 1.0 - vFontUV.y;\n    vFontUV *= 15.0;\n    vFontUV.x *= 3.0;\n    \n    vFontUV -= vec2(2.0, 1.0);\n    \n    vec2 vCharUV = vec2(0);\n    \n    int headingPage = pageNo * 2;\n    int bodyPage = headingPage + 1;\n        \n    if ( pageNo < 9 )\n    {\n        PrintPage( vCharUV, vFontUV, headingPage );\n        vFontUV *= 1.5;\n        vFontUV.y -= 1.0;\n        if ( pageNo == 8 )\n        {\n        \tvFontUV.x -= 8.0;\n        \tvFontUV.y -= 13.0;\n        }\n        \n        PrintPage( vCharUV, vFontUV, bodyPage );        \n    }\n\n    float fFont = textureLod( iChannelFont, vCharUV, 0.0 ).w;\n\t\n\treturn fFont;\n}\n\n\nconst ivec2 GRID_SIZE = ivec2( 100 );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 vResult = vec3(0.0);\n      \n    vResult = texelFetch( iChannelRender, ivec2(fragCoord), 0 ).rgb;\n\n\tint windowId;\n    vec2 vWindowCoord;\n    UI_Compose( fragCoord, vResult, windowId, vWindowCoord );\n\n    float fFont = DrawText( fragCoord, int( UI_GetFloat(DATA_PAGE_NO)) );\n\n    float fOutline = clamp ( (0.56 - fFont) * 20.0, 0.0, 1.0 );\n    float fMain = clamp ( (0.52 - fFont) * 20.0, 0.0, 1.0 );\n    \n    vResult = mix( vResult, vec3(0), fOutline );\n    vResult = mix( vResult, vec3(1,1,1), fMain );\n    \n\tfragColor = vec4(vResult,1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "musicstream",
                        "id": 11571,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/filipnikolaevic/jean-michel-jarre-oxygen-8-magnetik-rmx"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// This pass is just the window system and UI code for the sliders\n// It also controls page turning\n\n// Super Shader GUI\n// https://www.shadertoy.com/view/Xs2cR1\n// Shadertoy UI framework - @P_Malin\n\n// Todo: \n// * window stacking order?\n\n#define iChannelUI \t\t\tiChannel0\n#define iChannelKeyboard \tiChannel1\n#define iChannelFont \t\tiChannel2\n\n#define SHADOW_TEST\n\n///////////////////////////\n// Data Storage\n///////////////////////////\n\nvec4 LoadVec4( sampler2D sampler, in ivec2 vAddr )\n{\n    return texelFetch( sampler, vAddr, 0 );\n}\n\nvec3 LoadVec3( sampler2D sampler, in ivec2 vAddr )\n{\n    return LoadVec4( sampler, vAddr ).xyz;\n}\n\nbool AtAddress( ivec2 p, ivec2 c ) { return all( equal( p, c ) ); }\n\nvoid StoreVec4( in ivec2 vAddr, in vec4 vValue, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in ivec2 vAddr, in vec3 vValue, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n///////////////////////////\n// Rect\n///////////////////////////\n\nstruct Rect\n{\n    vec2 vPos;\n    vec2 vSize;\n};      \n\nbool Inside( vec2 vPos, vec2 vMin, vec2 vMax )\n{\n    return all( greaterThanEqual( vPos, vMin ) ) && all( lessThan( vPos, vMax ) );\n}\n\nbool Outside( vec2 vPos, vec2 vMin, vec2 vMax )\n{\n    return any( lessThan( vPos, vMin ) ) || any( greaterThanEqual( vPos, vMax ) );\n}\n\nbool Inside( vec2 vPos, Rect rect )\n{\n    return Inside( vPos, rect.vPos, rect.vPos + rect.vSize );\n}\n    \nbool Outside( vec2 vPos, Rect rect )\n{\n    return Outside( vPos, rect.vPos, rect.vPos + rect.vSize );\n}\n\nvoid RectExpand( inout Rect region, vec2 vPadding )\n{\n    // Padding\n    region.vPos -= vPadding;\n    region.vSize += vPadding * 2.0;        \n}\n\nvoid RectShrink( inout Rect region, vec2 vPadding )\n{\n    RectExpand( region, -vPadding);\n}\n\n///////////////////////////\n// Keyboard\n///////////////////////////\n\n// Keyboard constants definition\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\nconst int KEY_COMMA = 188;\nconst int KEY_PER   = 190;\n\nbool KeyIsPressed(int key)\n{\n\treturn texelFetch( iChannelKeyboard, ivec2(key, 0), 0 ).x > 0.0;\n}\n\nbool KeyIsPressedDebounced(int key)\n{\n\treturn texelFetch( iChannelKeyboard, ivec2(key, 1), 0 ).x > 0.0;\n}\n\nbool KeyIsToggled(int key)\n{\n\treturn texelFetch( iChannelKeyboard, ivec2(key, 2), 0 ).x > 0.0;\n}\n\n///////////////////////////\n// Font\n///////////////////////////\n\n// Font printing based on https://www.shadertoy.com/view/ldfcDr\n\n#define AUTO_FONT_SPACING\n//#define HANDLE_EOL\n//#define HANDLE_PRINT_STYLES\n\n// Font characters\nconst uint\n   \t// HTML Entity Names\n    \n    _SP = 0x20u,\t\t// ' '\n    _EXCL = 0x21u, \t\t// '!' \n    _QUOT = 0x22u, \t\t// '\"'\n    _NUM = 0x23u,  \t\t// '#'\n    _DOLLAR = 0x24u, \t// '$'\n    _PERCNT = 0x25u, \t// '%'\n    _AMP = 0x26u, \t\t// '&'\n    _APOS = 0x27u,\t\t// '''    \n    _LPAR = 0x28u, \t\t// '('\n    _RPAR= 0x29u, \t\t// ')'\n    _AST = 0x2Au,\t\t// '*'\n    _PLUS = 0x2Bu,\t\t// '+'\n    _COMMA = 0x2Cu,\t\t// ','    \n    _MINUS = 0x2Du,\t\t// '-'\n    _PERIOD = 0x2Eu,\t// '.'\n    _SOL = 0x2Fu,\t\t// '/' \n\n    _0 = 0x30u, _1 = 0x31u, _2 = 0x32u, _3 = 0x33u, _4 = 0x34u, \n    _5 = 0x35u, _6 = 0x36u, _7 = 0x37u, _8 = 0x38u, _9 = 0x39u, \n\n    _COLON = 0x3Au,\t\t// ':' \n    _SEMI = 0x3Bu,\t\t// ';' \n    _LT = 0x3Cu,\t\t// '<' \n    _EQUALS = 0x3Du,\t// '=' \n    _GT = 0x3Eu,\t\t// '>' \n    _QUEST = 0x3Fu,\t\t// '?' \n    _COMAT = 0x40u,\t\t// '@' \n    \n    _A = 0x41u, _B = 0x42u, _C = 0x43u, _D = 0x44u, _E = 0x45u, \n    _F = 0x46u, _G = 0x47u, _H = 0x48u, _I = 0x49u, _J = 0x4Au,\n    _K = 0x4Bu, _L = 0x4Cu, _M = 0x4Du, _N = 0x4Eu, _O = 0x4Fu,\n    _P = 0x50u, _Q = 0x51u, _R = 0x52u, _S = 0x53u, _T = 0x54u,\n    _U = 0x55u, _V = 0x56u, _W = 0x57u, _X = 0x58u, _Y = 0x59u,\n    _Z = 0x5Au,\n\n    _LSQB = 0x5Bu,\t\t// '[' \n    _BSOL = 0x5Cu,\t\t// '\\'\n    _RSQB = 0x5Du,\t\t// ']' \n    _CIRC = 0x5Eu,\t\t// '^' \n    _LOWBAR = 0x5Fu,\t// '_' \n    _GRAVE = 0x60u,\t\t// '`' \n    \n    _a = 0x61u, _b = 0x62u, _c = 0x63u, _d = 0x64u, _e = 0x65u,\n    _f = 0x66u, _g = 0x67u, _h = 0x68u, _i = 0x69u, _j = 0x6Au,\n    _k = 0x6Bu, _l = 0x6Cu, _m = 0x6Du, _n = 0x6Eu, _o = 0x6Fu,\n    _p = 0x70u, _q = 0x71u, _r = 0x72u, _s = 0x73u, _t = 0x74u,\n    _u = 0x75u, _v = 0x76u, _w = 0x77u, _x = 0x78u, _y = 0x79u,\n    _z = 0x7Au\n\n\t,_LCUB = 0x7Bu\t\t// '{'\n    ,_VERBAR = 0x7Cu\t// '|'\n    ,_RCUB = 0x7Du\t\t// '}'\n    ,_TILDE = 0x7Eu\t\t// '~'\n    \n#ifdef HANDLE_EOL       \n    ,_EOL = 0x1000u \t// End of Line - Carriage Return & Line Feed    \n#endif    \n#ifdef HANDLE_PRINT_STYLES    \n    ,_BOLDON = 0x1001u\t// Special\n    ,_BOLDOFF = 0x1002u\t// Special\n    ,_ITALON = 0x1003u\t// Special\n    ,_ITALOFF = 0x1004u\t// Special    \n#endif    \n;\n\n\nvec4 SampleCharacterTex( uint iChar, vec2 vCharUV )\n{\n    uvec2 iChPos = uvec2( iChar % 16u, iChar / 16u );\n    vec2 vUV = (vec2(iChPos) + vCharUV) / 16.0f;\n    return textureLod( iChannelFont, vUV, 0.0 );\n}\n    \nvec4 SampleCharacter( uint iChar, vec2 vCharUV )\n{\n    uvec2 iChPos = uvec2( iChar % 16u, iChar / 16u );\n    vec2 vClampedCharUV = clamp(vCharUV, vec2(0.01), vec2(0.99));\n    vec2 vUV = (vec2(iChPos) + vClampedCharUV) / 16.0f;\n\n    vec4 vSample;\n    \n    float l = length( (vClampedCharUV - vCharUV) );\n\n    // Skip texture sample when not in character boundary\n    // Ok unless we have big font weight\n    if ( l > 0.01f )\n    {\n        vSample.rgb = vec3(0);\n\t\tvSample.w = 2000000.0; \n    }\n    else\n    {\n\t\tvSample = textureLod( iChannelFont, vUV, 0.0 );    \n        vSample.gb = vSample.gb * 2.0f - 1.0f;\n        vSample.a -= 0.5f + 1.0/256.0;    \n    }\n        \n    return vSample;\n}\n\n\nstruct CharExtents\n{\n    float left;\n    float width;\n};\n    \n// Auto font spacing adapted from Klems shader: https://www.shadertoy.com/view/MsfyDN\nfloat CharVerticalPos(uint iChar, vec2 vUV) \n{\n    vec4 vSample = SampleCharacterTex(iChar, vUV);\n    float dist = vSample.a - (127.0/255.0);\n    dist *= vSample.g * 2.0 - 1.0;\n    return vUV.x - dist;\n}\n\nCharExtents GetCharExtents( uint iChar )\n{\n    CharExtents result;\n\n    result.left = CharVerticalPos( iChar, vec2(0.02, 0.5) );\n    float right = CharVerticalPos( iChar, vec2(0.98, 0.5) );\n    result.width = right - result.left;\n    \n    if ( iChar == _SP )\n    {\n        result.left = 0.3f;\n        result.width = 0.4f;\n    }\n    return result;\n}\n\nstruct PrintState\n{\n    vec2 vPixelPos;\n    \n    vec2 vLayoutStart;\n    // print position\n    vec2 vCursorPos;\n    vec2 vPixelSize;\n\n#ifdef HANDLE_EOL\n    bool EOL;\n#endif\n\n    // result\n    float fDistance;\n};    \n\nvoid MoveTo( inout PrintState state, vec2 vPos )\n{\n    state.vLayoutStart = vPos;\n    state.vCursorPos = vPos;\n#ifdef HANDLE_EOL\n    state.EOL = false;\n#endif\n}\n\nvoid ClearPrintResult( inout PrintState state )\n{\n    state.fDistance = 1000000.0;   \n}\n\nPrintState PrintState_InitCanvas( vec2 vCoords, vec2 vPixelSize )\n{\n    PrintState state;\n    state.vPixelPos = vCoords;\n    state.vPixelSize = vPixelSize;\n    \n    MoveTo( state, vec2(0) );\n\n    ClearPrintResult( state );\n    \n    return state;\n}\n\nstruct LayoutStyle\n{\n    vec2 vSize;\n    float fLineGap;\n    float fAdvancement;\n#ifdef HANDLE_PRINT_STYLES    \n    bool bItalic;\n    bool bBold;  \n#endif    \n};\n    \nLayoutStyle LayoutStyle_Default()\n{\n    LayoutStyle style;\n    style.vSize = vec2(24.0f, 32.0f);    \n    style.fLineGap = 0.1f;\n    style.fAdvancement = 0.1f;\n#ifdef HANDLE_PRINT_STYLES    \n    style.bItalic = false;\n    style.bBold = false;       \n#endif    \n    return style;\n}\n\nstruct RenderStyle\n{\n    vec3 vFontColor;\n    float fFontWeight;   \n};\n\nRenderStyle RenderStyle_Default( vec3 vFontColor )\n{\n    RenderStyle style;\n    style.vFontColor = vFontColor;\n    style.fFontWeight = 0.0f;  \n    return style;\n}\n\nconst float g_fFontDescent = 0.15f;\nconst float g_fFontAscent = 0.65f;\n\nvoid PrintEndCurrentLine( inout PrintState state, const LayoutStyle style )\n{\n    // Apply CR\n    state.vCursorPos.x = state.vLayoutStart.x;\n    \n    // advance Y position to bottom of descender based on current font size.\n\tstate.vCursorPos.y += style.vSize.y * g_fFontDescent;    \n}\n\nvoid PrintBeginNextLine( inout PrintState state, const LayoutStyle style )\n{\n    // move Y position to baseline based on current font size\n\tstate.vCursorPos.y += style.vSize.y * (g_fFontAscent + style.fLineGap);\n}\n\n#ifdef HANDLE_EOL\nvoid PrintEOL( inout PrintState state, const LayoutStyle style )\n{\n    if ( state.EOL )\n    {\n        PrintBeginNextLine( state, style );\n    }\n    PrintEndCurrentLine( state, style );\n    state.EOL = true;\n}\n#endif\n\nvoid PrintCh( inout PrintState state, inout LayoutStyle style, const uint iChar )\n{\n#ifdef HANDLE_EOL\n    if ( iChar == _EOL )\n    {\n        PrintEOL( state, style );\n        return;\n    }\n    else\n#endif\n#ifdef HANDLE_PRINT_STYLES            \n    if ( iChar == _BOLDON )\n    {\n        style.bBold = true;\n        return;\n    }\n    else\n    if ( iChar == _BOLDOFF )\n    {\n        style.bBold = false;\n        return;\n    }\n    else\n    if ( iChar == _ITALON )\n    {\n        style.bItalic = true;\n        return;\n    }\n    else\n    if ( iChar == _ITALOFF )\n    {\n        style.bItalic = false;\n        return;\n    }\n#endif\n    \n#ifdef HANDLE_EOL\n    if ( state.EOL )\n    {\n        PrintBeginNextLine( state, style );\n\t\tstate.EOL = false;\n    }\n#endif\n    \n    vec2 vUV = ((state.vPixelPos - state.vCursorPos) / style.vSize);\n\n    /*if ( (vUV.y > -0.1) && (vUV.y < 0.1) && (abs(vUV.x) < 0.02 || abs(vUV.x - CharWidth(iChar)) < 0.02) )\n    {\n        state.fDistance = -10.0;\n    }*/\n    \n\tCharExtents extents = GetCharExtents( iChar );    \n    vUV.y += 0.8f; // Move baseline\n    vUV.x += extents.left - style.fAdvancement;\n    \n#ifdef HANDLE_PRINT_STYLES    \n    if ( style.bItalic )\n    {\n    \tvUV.x += (1.0 - vUV.y) * -0.4f;\n    }\n#endif\n    \n    vec3 v = SampleCharacter( iChar, vUV ).agb;\n\n#ifdef HANDLE_PRINT_STYLES    \n    if ( style.bBold )\n    {\n    \tv.x -= 0.025f;\n    }\n#endif    \n    \n    if ( v.x < state.fDistance )\n    {\n        state.fDistance = v.x;       \n    }\n    \n    state.vCursorPos.x += style.vSize.x * (extents.width + style.fAdvancement);\n}\n\n\nRect GetFontRect( PrintState state, LayoutStyle style, bool initialLineOffset )\n{\n    Rect rect;\n    \n    rect.vPos = state.vLayoutStart;\n    if ( initialLineOffset )\n    {\n    \trect.vPos.y += style.vSize.y * (style.fLineGap + g_fFontAscent);\n    }\n\trect.vPos.y -= style.vSize.y * (g_fFontAscent);\n    rect.vSize.x = state.vCursorPos.x - state.vLayoutStart.x;\n    rect.vSize.y = style.vSize.y * ( g_fFontAscent + g_fFontDescent );\n    \n    return rect;\n}\n\nfloat GetFontBlend( PrintState state, LayoutStyle style, float size )\n{\n    float fFeatherDist = 1.0f * length(state.vPixelSize / style.vSize);    \n    float f = clamp( (size-state.fDistance + fFeatherDist * 0.5f) / fFeatherDist, 0.0, 1.0);\n    return f;\n}\n\nvoid RenderFont( PrintState state, LayoutStyle style, RenderStyle renderStyle, inout vec3 color )\n{   \n    float f = GetFontBlend( state, style, renderStyle.fFontWeight );\n\n    vec3 vCol = renderStyle.vFontColor;\n    \n    color.rgb = mix( color.rgb, vCol, f);    \n}\n\n// Font print helpers\n\n#define NO_UNROLL(X) (X + min(0,iFrame))\n#define NO_UNROLLU(X) (X + uint(min(0,iFrame)))\n\n#define ARRAY_PRINT( STATE, STYLE, CHAR_ARRAY ) { for (int i=0; i< NO_UNROLL( CHAR_ARRAY.length() ); i++) PrintCh( STATE, STYLE, CHAR_ARRAY[i] ); }\n\nvoid Print( inout PrintState state, LayoutStyle style, uint value )\n{\n\tuint place = 1000000000u;\n\n    bool leadingZeros = true;\n    while( place > NO_UNROLLU( 0u ) )\n    {\n        uint digit = (value / place) % 10u;\n        if ( place == 1u || digit != 0u )\n        {\n            leadingZeros = false;\n        }\n        \n        if (!leadingZeros)\n        {\n            PrintCh( state, style, _0 + digit );\n        }\n        place = place / 10u;\n    }    \n}\n\nvoid Print( inout PrintState state, LayoutStyle style, int value )\n{\n    if ( value < 0 )\n    {\n        PrintCh( state, style, _MINUS );\n        value = -value;\n    }\n\n    Print ( state, style, uint(value) );    \n}\n\nvoid Print( inout PrintState state, LayoutStyle style, float value, int decimalPlaces )\n{\n    if ( value < 0.0f )\n    {\n        PrintCh( state, style, _MINUS );\n    }\n    value = abs(value);\n    \n    int placeIndex = 10;\n    \n    bool leadingZeros = true;\n    while( placeIndex >= NO_UNROLL( -decimalPlaces ) )\n    {\n        float place = pow(10.0f, float(placeIndex) );\n        float digitValue = floor( value / place );\n        value -= digitValue * place;\n        \n        \n        uint digit = min( uint( digitValue ), 9u );\n        \n        if ( placeIndex == -1 )\n        {\n            PrintCh( state, style, _PERIOD );\n        }\n        \n        if ( placeIndex == 0 || digit != 0u )\n        {\n            leadingZeros = false;\n        }        \n        \n        if ( !leadingZeros )\n        {\n        \tPrintCh( state, style, _0 + digit );\n        }\n                \n        placeIndex--;\n    }\n}\n\n\n\n///////////////////////////////////////////\n// General 2d Drawing\n///////////////////////////////////////////\n\nvoid DrawRect( vec2 vCanvasPos, Rect rect, vec4 vColor, inout vec4 vOutColor )\n{\n\tif ( Inside( vCanvasPos, rect ) )\n    {\n        vOutColor = vColor;\n    }\n}\n\nvoid DrawLine( vec2 vCanvasPos, vec2 vA, vec2 vB, float fThickness, vec4 vColor, inout vec4 vOutColor )\n{\n    vec2 vDir = vB - vA;\n    float l = length( vDir );\n    vDir = normalize( vDir );\n\n    vec2 vOffset = vCanvasPos - vA;\n    float fDot = dot( vOffset, vDir );\n    float fT = clamp( fDot, 0.0, l );\n\n    vec2 vClosest = vA + vDir * fT;\n    float fDist = length(vClosest - vCanvasPos) - fThickness;\n\n    if ( fDist < 0.0 )\n    {\n        vOutColor = vColor;\n    }    \n}\n\nvoid DrawBorder( vec2 vCanvasPos, Rect rect, inout vec4 vOutColor )\n{    \n    vec2 vThickness = vec2(1.0);\n    \n\tif ( Inside( vCanvasPos, rect ) )\n    {\n        if ( any( lessThanEqual( vCanvasPos, rect.vPos + vThickness) ) )\n        {\n            vOutColor.rgb = vec3(0.85);\n        }\n        else\n        if ( any( greaterThan( vCanvasPos, rect.vPos + rect.vSize - vThickness) ) )\n        {\n            vOutColor.rgb = vec3(0.0);\n        }\n        else\n        if ( any( lessThanEqual( vCanvasPos, rect.vPos + vThickness * 2.0) ) )\n        {\n            vOutColor.rgb = vec3(1.0);\n        }\n        else\n        if ( any( greaterThan( vCanvasPos, rect.vPos + rect.vSize - vThickness * 2.0) ) )\n        {\n            vOutColor.rgb = vec3(0.4);\n        }\n    }\n}\n\nvoid DrawBorderIndent( vec2 vCanvasPos, Rect rect, inout vec4 vOutColor )\n{    \n    vec2 vThickness = vec2(1.0);\n    \n\tif ( Inside( vCanvasPos, rect ) )\n    {        \n        if ( any( lessThanEqual( vCanvasPos, rect.vPos + vThickness) ) )\n        {\n            vOutColor.rgb = vec3(0.0);\n        }\n        else\n        if ( any( greaterThan( vCanvasPos, rect.vPos + rect.vSize - vThickness) ) )\n        {\n            vOutColor.rgb = vec3(0.85);\n        }\n        else\n        if ( any( lessThanEqual( vCanvasPos, rect.vPos + vThickness * 2.0) ) )\n        {\n            vOutColor.rgb = vec3(0.4);\n        }\n        else\n        if ( any( greaterThan( vCanvasPos, rect.vPos + rect.vSize - vThickness * 2.0) ) )\n        {\n            vOutColor.rgb = vec3(1.0);\n        }\n    }\n}\n    \nstruct UIDrawContext\n{        \n    vec2 vCanvasSize;\n    \n    // position and size of unclipped viewport on the screen\n    Rect viewport;\n    \n    // visible region of viewport on the screen\n    Rect clip;\n    \n    // canvas co-ordinates at top-left corner of viewport\n    vec2 vOffset;\n};\n\nvec2 UIDrawContext_ScreenPosToCanvasPos( UIDrawContext drawContext, vec2 vScreenPos )\n{\n    vec2 vViewPos = vScreenPos - drawContext.viewport.vPos;\n    return vViewPos + drawContext.vOffset;\n}\n\nvec2 UIDrawContext_CanvasPosToScreenPos( UIDrawContext drawContext, vec2 vCanvasPos )\n{\n    return vCanvasPos - drawContext.vOffset + drawContext.viewport.vPos;\n}\n\nbool UIDrawContext_ScreenPosInView( UIDrawContext drawContext, vec2 vScreenPos )\n{\n    return Inside( vScreenPos, drawContext.clip );\n}\n\nbool UIDrawContext_ScreenPosInCanvasRect( UIDrawContext drawContext, vec2 vScreenPos, Rect canvasRect )\n{\n\tvec2 vCanvasPos = UIDrawContext_ScreenPosToCanvasPos( drawContext, vScreenPos );    \n    return Inside( vCanvasPos, canvasRect );\n}\n\nUIDrawContext UIDrawContext_SetupFromRect( Rect rect )\n{\n    UIDrawContext drawContext;\n    drawContext.viewport = rect;\n    drawContext.vOffset = vec2(0);\n    drawContext.vCanvasSize = rect.vSize;\n\treturn drawContext;\n}\n\n\nUIDrawContext UIDrawContext_TransformChild( UIDrawContext parentContext, UIDrawContext childContext )\n{\n    UIDrawContext result;\n    \n    // The child canvas size is unmodified\n    result.vCanvasSize = childContext.vCanvasSize;\n\n    // Child viewport positions are in the parent's canvas\n    // Transform them to screen co-ordinates    \n    result.viewport.vPos = UIDrawContext_CanvasPosToScreenPos( parentContext, childContext.viewport.vPos );\n    vec2 vMax = childContext.viewport.vPos + childContext.viewport.vSize;\n    vec2 vScreenMax = UIDrawContext_CanvasPosToScreenPos( parentContext, vMax );\n    result.viewport.vSize = vScreenMax - result.viewport.vPos;\n    result.vOffset = childContext.vOffset;\n    \n    // Now clip the view so that it is within the parent view\n    vec2 vViewMin = max( result.viewport.vPos, parentContext.clip.vPos );\n    vec2 vViewMax = min( result.viewport.vPos + result.viewport.vSize, parentContext.clip.vPos + parentContext.clip.vSize );\n\n    // Clip view to current canvas\n    vec2 vCanvasViewMin = result.viewport.vPos - result.vOffset;\n    vec2 vCanvasViewMax = vCanvasViewMin + result.vCanvasSize;\n    \n    vViewMin = max( vViewMin, vCanvasViewMin );\n\tvViewMax = min( vViewMax, vCanvasViewMax );\n    \n    result.clip = Rect( vViewMin, vViewMax - vViewMin );\n    \n    return result;\n}\n\nfloat \tUIStyle_TitleBarHeight();\nvec2 \tUIStyle_WindowBorderSize();\nvec2 \tUIStyle_WindowContentPadding();\nvec2 \tUIStyle_ControlSpacing();\nvec2 \tUIStyle_FontPadding();\nvec2 \tUIStyle_CheckboxSize();\nvec2 \tUIStyle_SliderSize();\nvec3 \tUIStyle_ColorPickerSize();\nfloat \tUIStyle_ScrollBarSize();\nvec4    UIStyle_WindowBackgroundColor();\nfloat   UIStyle_WindowTransparency();\n\nstruct UILayout\n{\n    float fTabPosition;\n    vec2 vCursor;\n    Rect controlRect;\n    \n    // Bounds of controls in current stack\n    vec2 vControlMax;\n    vec2 vControlMin;\n};\n    \nUILayout UILayout_Reset()\n{\n    UILayout uiLayout;\n    \n    uiLayout.fTabPosition = 0.0;\n    uiLayout.vCursor = vec2(0);\n    uiLayout.controlRect = Rect( vec2(0), vec2(0) );\n    uiLayout.vControlMax = vec2(0);\n    uiLayout.vControlMin = vec2(0);\n    \n    return uiLayout;\n}\n\nRect UILayout_GetStackedControlRect( inout UILayout uiLayout, vec2 vSize )\n{\n    return Rect( uiLayout.vCursor, vSize );\n}\n\nvoid UILayout_SetControlRect( inout UILayout uiLayout, Rect rect )\n{\n    uiLayout.controlRect = rect;\n    \n    uiLayout.vControlMax = max( uiLayout.vControlMax, rect.vPos + rect.vSize );\n    uiLayout.vControlMin = max( uiLayout.vControlMin, rect.vPos );    \n}\n\nRect UILayout_StackControlRect( inout UILayout uiLayout, vec2 vSize )\n{\n    Rect rect = UILayout_GetStackedControlRect( uiLayout, vSize );\n    UILayout_SetControlRect( uiLayout, rect );\n    return rect;\n}\n\nvoid UILayout_SetX( inout UILayout uiLayout, float xPos )\n{\n    uiLayout.vCursor.x = xPos;\n    uiLayout.vControlMax.x = uiLayout.vCursor.x;\n    uiLayout.vControlMin.x = uiLayout.vCursor.x;\n}\n\nvoid UILayout_StackRight( inout UILayout uiLayout )\n{\n    UILayout_SetX( uiLayout, uiLayout.vControlMax.x + UIStyle_ControlSpacing().x );\n}\n\nvoid UILayout_StackDown( inout UILayout uiLayout )\n{\n    uiLayout.vCursor.x = uiLayout.fTabPosition;\n    uiLayout.vCursor.y = uiLayout.vControlMax.y + UIStyle_ControlSpacing().y;    \n    uiLayout.vControlMax.x = uiLayout.vCursor.x;\n    uiLayout.vControlMin.x = uiLayout.vCursor.x;\n    uiLayout.vControlMax.y = uiLayout.vCursor.y;\n    uiLayout.vControlMin.y = uiLayout.vCursor.y;\n}\n\n#define IDC_NONE            -1\n\nstruct UIContext\n{\n    vec2 vPixelPos;\n    \n    vec2 vMousePos;\n    bool bMouseDown;\n    bool bMouseWasDown;\n    bool bHandledClick;\n    \n    ivec2 vFragCoord;\n    vec4 vOutColor;\n    float fBlendRemaining;\n\n    vec4 vOutData;\n    \n    int iActiveControl;\n    vec2 vActivePos;\n\n    UIDrawContext drawContext;\n    bool bPixelInView; // derived from drawContext\n    vec2 vPixelCanvasPos; // derived from drawContext\n    bool bMouseInView; // derived from drawContext\n    vec2 vMouseCanvasPos; // derived from drawContext\n\n    vec4 vWindowOutColor; // Output for current window draw pass\n#ifdef SHADOW_TEST\n    float fShadow;\n    float fOutShadow;\n#endif    \n};\n\nvoid UI_SetDrawContext( inout UIContext uiContext, UIDrawContext drawContext )\n{\n    uiContext.drawContext = drawContext;\n    \n    uiContext.vPixelCanvasPos = UIDrawContext_ScreenPosToCanvasPos( drawContext, uiContext.vPixelPos );\n    uiContext.bPixelInView = UIDrawContext_ScreenPosInView( drawContext, uiContext.vPixelPos );\n\n    uiContext.vMouseCanvasPos = UIDrawContext_ScreenPosToCanvasPos( drawContext, uiContext.vMousePos );\n    uiContext.bMouseInView = UIDrawContext_ScreenPosInView( drawContext, uiContext.vMousePos );\n}    \n\nUIContext UI_GetContext( vec2 fragCoord, int iData )\n{\n    UIContext uiContext;\n    \n    uiContext.vPixelPos = fragCoord;\n    uiContext.vPixelPos.y = iResolution.y - uiContext.vPixelPos.y;\n    uiContext.vMousePos = iMouse.xy;\n    uiContext.vMousePos.y = iResolution.y - uiContext.vMousePos.y;\n    uiContext.bMouseDown = iMouse.z > 0.0;       \n    \n    vec4 vData0 = LoadVec4( iChannelUI, ivec2(iData,0) );\n    \n    uiContext.bMouseWasDown = (vData0.x > 0.0);\n    \n    uiContext.vFragCoord = ivec2(fragCoord);\n    uiContext.vOutColor = vec4(0.0);\n#ifdef SHADOW_TEST    \n    uiContext.fShadow = 1.0;\n    uiContext.fOutShadow = 1.0f;\n#endif    \n    uiContext.fBlendRemaining = 1.0;\n    \n    uiContext.vOutData = vec4(0.0);\n    if ( int(uiContext.vFragCoord.y) < 2 )\n    {\n        // Initialize data with previous value\n\t    uiContext.vOutData = texelFetch( iChannelUI, uiContext.vFragCoord, 0 );     \n    }\n    uiContext.bHandledClick = false;\n    \n    uiContext.iActiveControl = int(vData0.y);\n    uiContext.vActivePos = vec2(vData0.zw);\n        \n    \n    UIDrawContext rootContext;\n    \n    rootContext.vCanvasSize = iResolution.xy;\n    rootContext.vOffset = vec2(0);\n    rootContext.viewport = Rect( vec2(0), vec2(iResolution.xy) );\n    rootContext.clip = rootContext.viewport;\n\n    UI_SetDrawContext( uiContext, rootContext );\n    \n    uiContext.vWindowOutColor = vec4(0);\n    \n    if ( iFrame == 0 )\n    {\n        uiContext.bMouseWasDown = false;\n        uiContext.iActiveControl = IDC_NONE;\n    }\n    \n    return uiContext;\n}///\n\nvoid UI_StoreContext( inout UIContext uiContext, int iData )\n{\n    vec4 vData0 = vec4( uiContext.bMouseDown ? 1.0 : 0.0, float(uiContext.iActiveControl), uiContext.vActivePos.x, uiContext.vActivePos.y );\n    StoreVec4( ivec2(iData,0), vData0, uiContext.vOutData, ivec2(uiContext.vFragCoord) );\n}\n\nvec4 UI_GetFinalColor( UIContext uiContext )\n{\n    if ( int(uiContext.vFragCoord.y) < 2 )\n    {\n        return uiContext.vOutData;\n    }\n    \n    if ( uiContext.vOutColor.a >= 0.0 )\n    {\n        // Apply premultiplied alpha.\n        uiContext.vOutColor.rgb *= uiContext.vOutColor.a;\n  \n#ifdef SHADOW_TEST\n        // Shadow composite for premultiplied alpha.\n        // Don't even ask how this works - I'm not sure I know\n        uiContext.vOutColor.rgb *= uiContext.fOutShadow;\n        uiContext.vOutColor.a = 1.0 - ((1.0 - uiContext.vOutColor.a) * uiContext.fOutShadow);\n#endif \t\n    }\n    else\n    {\n#ifdef SHADOW_TEST\n        uiContext.vOutColor.a = -1.0 -uiContext.fOutShadow;\n#else\n        uiContext.vOutColor.a = -2.0;\n#endif \n    }\n    \n    return uiContext.vOutColor;\n}\n\nvoid UI_ComposeWindowLayer( inout UIContext uiContext, float fTransparency, Rect windowRect )\n{\n#ifdef SHADOW_TEST   \n  \tif ( !uiContext.bPixelInView )\n    {\n        return;\n    }\n\n#if 0\n    // cull window?\n    Rect boundsRect = windowRect;\n    RectExpand( boundsRect, vec2( 16.0 ) );\n    if ( !Inside( uiContext.vPixelPos, boundsRect ) )\n    {\n        return;\n    }\n#endif\n    \n    // We need to compose in the parent drawContext for this to work...\n    float fPrevShadow = uiContext.fShadow;\n    \n    vec2 vShadowOffset = vec2( 5.0, 8.0 );\n    float fShadowInner = 3.0;\n\tfloat fShadowOuter = 12.0;\n    \n    Rect shadowRect = windowRect;\n    RectShrink( shadowRect, vec2( fShadowInner ) );\n    \n    vec2 vShadowTestPos = uiContext.vPixelPos - vShadowOffset;\n    vec2 vWindowClosest = clamp( vShadowTestPos, shadowRect.vPos, shadowRect.vPos + shadowRect.vSize );\n\n    float fWindowDist = length( vWindowClosest - vShadowTestPos );\n    \n    float fCurrentShadow = clamp( (fWindowDist) / (fShadowOuter + fShadowInner), 0.0, 1.0 );\n    fCurrentShadow = sqrt( fCurrentShadow );\n    float fShadowTransparency = 0.5;\n\tuiContext.fShadow *= fCurrentShadow * (1.0 - fShadowTransparency) + fShadowTransparency; \n#endif    \n\n  \tif ( !Inside( uiContext.vPixelPos, windowRect ) )\n    {\n        return;\n    }\n\n    float fBlend = uiContext.fBlendRemaining * (1.0f - fTransparency);\n\n#ifdef SHADOW_TEST\n    uiContext.fOutShadow *= fPrevShadow * (fBlend) + (1.0 - fBlend);\n#endif\n    \n    // never blend under \"ID\" window\n    if ( uiContext.vOutColor.a < 0.0 )\n    {\n        return;\n    }\n    \n    if ( uiContext.vWindowOutColor.a < 0.0 )\n    {\n        if ( uiContext.fBlendRemaining == 1.0f )\n        {\n            // Ouput ID without blending\n            uiContext.vOutColor = uiContext.vWindowOutColor;\n            uiContext.fBlendRemaining = 0.0f;\n            return;\n        }\n        else\n        {\n            // blending id under existing color - blend in grey instead of ID\n            uiContext.vWindowOutColor = vec4(0.75, 0.75, 0.75, 1.0);\n        }\n    }\n\n    uiContext.vOutColor += uiContext.vWindowOutColor * fBlend;\n    \n    uiContext.fBlendRemaining *= fTransparency;\n}\n\n///////////////////////////\n// UI Data\n///////////////////////////\n\n#define DIRTY_DATA_MAGIC\t\t\t123.456\n\n// from HSV and HSL by iq - https://www.shadertoy.com/view/lsS3Wc\nconst float eps = 0.0000001;\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 rgb2hsv( in vec3 c)\n{\n    vec4 k = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);\n    vec4 p = mix(vec4(c.zy, k.wz), vec4(c.yz, k.xy), (c.z<c.y) ? 1.0 : 0.0);\n    vec4 q = mix(vec4(p.xyw, c.x), vec4(c.x, p.yzx), (p.x<c.x) ? 1.0 : 0.0);\n    float d = q.x - min(q.w, q.y);\n    return vec3(abs(q.z + (q.w - q.y) / (6.0*d+eps)), d / (q.x+eps), q.x);\n}\n\nstruct UIData_Bool\n{\n    bool bValue;\n};\n    \nUIData_Bool UI_GetDataBool( int iData, bool bDefault )  \n{\n    UIData_Bool dataBool;\n        \n\tvec4 vData0 = LoadVec4( iChannelUI, ivec2(iData,0) );\n    \n    if ( iFrame == 0 )\n    {\n        dataBool.bValue = bDefault;\n    }\n    else\n    {\n        dataBool.bValue =  vData0.x > 0.5;\n    }\n    \n    return dataBool;\n}\n\nvoid UI_StoreDataBool( inout UIContext uiContext, UIData_Bool dataBool, int iData )\n{\n    vec4 vData0 = vec4(0);\n    vData0.x = dataBool.bValue ? 1.0 : 0.0;\n    StoreVec4( ivec2(iData,0), vData0, uiContext.vOutData, ivec2(uiContext.vFragCoord) );            \n}\n\n\nstruct UIData_Value\n{\n    float fValue;\n    float fRangeMin;\n    float fRangeMax;\n};\n\nUIData_Value UI_GetDataValue( int iData, float fDefaultValue, float fRangeMin, float fRangeMax )  \n{\n    UIData_Value dataValue;\n    \n    vec4 vData0 = LoadVec4( iChannelUI, ivec2(iData,0) );\n    \n    if ( iFrame == 0 )\n    {\n        dataValue.fValue = fDefaultValue;\n    }\n    else\n    {\n        dataValue.fValue = vData0.x;\n    }\n    \n    dataValue.fRangeMin = fRangeMin;\n    dataValue.fRangeMax = fRangeMax;\n    \n    return dataValue;\n}\n\nvoid UI_StoreDataValue( inout UIContext uiContext, UIData_Value dataValue, int iData )\n{\n    vec4 vData0 = vec4(0);\n    vData0.x = dataValue.fValue;\n    StoreVec4( ivec2(iData,0), vData0, uiContext.vOutData, ivec2(uiContext.vFragCoord) );            \n}\n\nstruct UIData_Color\n{    \n    vec3 vHSV;\n};\n\nUIData_Color UI_GetDataColor( int iData, vec3 cDefaultRGB )  \n{\n    UIData_Color dataColor;\n    \n    vec4 vData1 = LoadVec4( iChannelUI, ivec2(iData,1) );\n    \n    if ( iFrame == 0 )\n    {\n        dataColor.vHSV = rgb2hsv( cDefaultRGB );\n    }\n    else\n    {\n        dataColor.vHSV = vData1.rgb;\n    }\n    \n    return dataColor;\n}\n\nvoid UI_StoreDataColor( inout UIContext uiContext, UIData_Color dataColor, int iData )\n{\n    vec4 vData0 = vec4(0);\n    vData0.rgb = hsv2rgb( dataColor.vHSV );\n        \n    StoreVec4( ivec2(iData,0), vData0, uiContext.vOutData, ivec2(uiContext.vFragCoord) );            \n\n    vec4 vData1 = vec4(0);\n    vData1.rgb = dataColor.vHSV;\n        \n    StoreVec4( ivec2(iData,1), vData1, uiContext.vOutData, ivec2(uiContext.vFragCoord) );            \n}\n\nPrintState UI_PrintState_Init( inout UIContext uiContext, LayoutStyle style, vec2 vPosition )\n{\n    vec2 vCanvasPos = uiContext.vPixelCanvasPos;\n    \n    PrintState state = PrintState_InitCanvas( vCanvasPos, vec2(1.0) );\n    MoveTo( state, vPosition + UIStyle_FontPadding() );\n\tPrintBeginNextLine(state, style);\n\n\treturn state;\n}\n\nRect UI_GetFontRect( PrintState state, LayoutStyle style )\n{\n    Rect rect;\n    rect = GetFontRect( state, style, true );\n    vec2 vExpand = UIStyle_FontPadding();\n    vExpand.y += style.vSize.y * style.fLineGap;\n    RectExpand( rect, vExpand );\n\treturn rect;\n}\n\nvoid UI_RenderFont( inout UIContext uiContext, PrintState state, LayoutStyle style, RenderStyle renderStyle )\n{\n    if( uiContext.bPixelInView )\n    {\n        RenderFont( state, style, renderStyle, uiContext.vWindowOutColor.rgb );\n    }\n}\n\nvoid UILayout_SetControlRectFromText( inout UILayout uiLayout, PrintState state, LayoutStyle style )\n{\n    UILayout_SetControlRect( uiLayout, UI_GetFontRect( state, style ) );\n}\n\nstruct UIPanelState\n{\n    UIDrawContext parentDrawContext;\n\tvec4 vParentWindowColor;\n};\n    \nvoid UI_PanelBegin( inout UIContext uiContext, inout UIPanelState panelState )\n{\n    panelState.parentDrawContext = uiContext.drawContext;\n    panelState.vParentWindowColor = uiContext.vWindowOutColor;\n}\n\nvoid UI_PanelEnd( inout UIContext uiContext, inout UIPanelState panelState )\n{\n    if ( !uiContext.bPixelInView )\n    {\n        // Restore parent window color if outside view\n\t    uiContext.vWindowOutColor = panelState.vParentWindowColor;    \n    }\n\n    UI_SetDrawContext( uiContext, panelState.parentDrawContext );\n}\n\n#define FLAG_SET(X,F) (( X & F ) != 0u)\n    \nconst uint\tWINDOW_CONTROL_FLAG_CLOSE_BOX \t\t= 1u,\n\t\t\tWINDOW_CONTROL_FLAG_MINIMIZE_BOX\t= 2u,\n\t\t\tWINDOW_CONTROL_FLAG_RESIZE_WIDGET \t= 4u,\n\t\t\tWINDOW_CONTROL_FLAG_TITLE_BAR \t\t= 8u;\n    \nstruct UIWindowDesc\n{\n    Rect initialRect;\n    bool bStartMinimized;\n    bool bStartClosed;\n    \n    uint uControlFlags;    \n    vec2 vMaxSize;\n};\n\n\nstruct UIWindowState\n{\n    UIPanelState panelState;\n\n    Rect rect;\n    bool bMinimized;\n    bool bClosed;\n    \n    uint uControlFlags;    \n    vec2 vMaxSize;\n    int iControlId;\n\n    Rect drawRect;\n};\n\n\nUIWindowState UI_GetWindowState( UIContext uiContext, int iControlId, int iData, UIWindowDesc desc )\n{\n    UIWindowState window;    \n    \n    vec4 vData0 = LoadVec4( iChannelUI, ivec2(iData,0) );\n        \n    window.rect = Rect( vData0.xy, vData0.zw );\n    \n    vec4 vData1 = LoadVec4( iChannelUI, ivec2(iData,1) );\n    \n    window.bClosed = desc.bStartClosed;\n    window.bMinimized = (vData1.x > 0.0);    \n    \n    // Clamp window position so title bar is always on canvas\n\tvec2 vSafeMin = vec2(24.0);        \n\tvec2 vSafeMax = vec2(32.0);        \n    vec2 vPosMin = vec2( -window.rect.vSize.x + vSafeMin.x, -vSafeMin.y);//vec2( -window.rect.vSize.x, 0.0) + 24.0, -24.0 );\n    vec2 vPosMax = uiContext.drawContext.vCanvasSize - vSafeMax;\n    window.rect.vPos = clamp( window.rect.vPos, vPosMin, vPosMax );\n    \n    if ( iFrame == 0 || vData1.y != DIRTY_DATA_MAGIC)\n    {\n        window.rect = desc.initialRect;\n        window.bMinimized = desc.bStartMinimized;\n    }       \n    \n    window.uControlFlags = desc.uControlFlags;\n    window.vMaxSize = desc.vMaxSize;\n    \n    window.iControlId = iControlId;\n        \n    return window;\n}\n\nvoid UI_StoreWindowState( inout UIContext uiContext, UIWindowState window, int iData )\n{    \n    vec4 vData0;\n    vData0.xy = window.rect.vPos;\n    vData0.zw = window.rect.vSize;\n    \n    StoreVec4( ivec2(iData,0), vData0, uiContext.vOutData, ivec2(uiContext.vFragCoord) );        \n\n    vec4 vData1;\n    \n    vData1.x = window.bMinimized ? 1.0f : 0.0f;\n    vData1.y = DIRTY_DATA_MAGIC;\n    vData1.zw = vec2(0);\n\n    StoreVec4( ivec2(iData,1), vData1, uiContext.vOutData, ivec2(uiContext.vFragCoord) );        \n}\n\nvoid UI_WriteCanvasPos( inout UIContext uiContext, int iControlId )        \n{\n\tif (!uiContext.bPixelInView)\n        return;\n    Rect rect = Rect( vec2(0), uiContext.drawContext.vCanvasSize );\n    DrawRect( uiContext.vPixelCanvasPos, rect, vec4(uiContext.vPixelCanvasPos, float(iControlId), -1.0 ), uiContext.vWindowOutColor );\n}    \n\nvoid UI_WriteCanvasUV( inout UIContext uiContext, int iControlId )        \n{\n\tif (!uiContext.bPixelInView)\n        return;\n    Rect rect = Rect( vec2(0), uiContext.drawContext.vCanvasSize );\n    DrawRect( uiContext.vPixelCanvasPos, rect, vec4(uiContext.vPixelCanvasPos / uiContext.drawContext.vCanvasSize, float(iControlId), -1.0 ), uiContext.vWindowOutColor );\n}\n\nvoid UI_DrawButton( inout UIContext uiContext, bool bActive, bool bMouseOver, Rect buttonRect )\n{\n\tif (!uiContext.bPixelInView)\n        return;\n    \n    if ( bActive && bMouseOver )\n    {\n    \tDrawBorderIndent( uiContext.vPixelCanvasPos, buttonRect, uiContext.vWindowOutColor );\n    }\n    else\n    {\n    \tDrawBorder( uiContext.vPixelCanvasPos, buttonRect, uiContext.vWindowOutColor );\n    }\n}\n\nbool UI_ProcessButton( inout UIContext uiContext, int iControlId, Rect buttonRect )\n{    \n    bool bMouseOver = Inside( uiContext.vMouseCanvasPos, buttonRect ) && uiContext.bMouseInView;\n    \n    bool bButtonPressed = false;\n    \n    if ( uiContext.iActiveControl == IDC_NONE )\n    {\n        if ( uiContext.bMouseDown && (!uiContext.bMouseWasDown) && bMouseOver && !uiContext.bHandledClick )\n        {\n            uiContext.iActiveControl = iControlId;\n            uiContext.bHandledClick = true;\n        }\n    }\n    else\n    if ( uiContext.iActiveControl == iControlId )\n    {\n        if ( !uiContext.bMouseDown )\n        {\n            uiContext.iActiveControl = IDC_NONE;\n            if ( bMouseOver )\n            {\n                bButtonPressed = true;\n            }\n        }\n    }\n\n    bool bActive = (uiContext.iActiveControl == iControlId);\n    \n    UI_DrawButton( uiContext, bActive, bMouseOver, buttonRect );    \n        \n    return bButtonPressed;\n}\n\nvoid UI_DrawCheckbox( inout UIContext uiContext, bool bActive, bool bMouseOver, bool bChecked, Rect checkBoxRect )\n{\n\tif (!uiContext.bPixelInView || Outside( uiContext.vPixelCanvasPos, checkBoxRect ))\n        return;\n    \n    uiContext.vWindowOutColor = vec4(1.0);\n    \n    if ( bActive && bMouseOver )\n    {\n        uiContext.vWindowOutColor = vec4(0.85,0.85,0.85,1.0);\n    }\n\n    DrawBorderIndent( uiContext.vPixelCanvasPos, checkBoxRect, uiContext.vWindowOutColor );\n\n    Rect smallerRect = checkBoxRect;\n    RectShrink( smallerRect, vec2(6.0));\n\n    if ( bChecked )\n    {\n        vec4 vCheckColor = vec4(0.0, 0.0, 0.0, 1.0);\n        DrawLine( uiContext.vPixelCanvasPos, smallerRect.vPos+ smallerRect.vSize * vec2(0.0, 0.75), smallerRect.vPos+ smallerRect.vSize * vec2(0.25, 1.0), 2.0f, vCheckColor, uiContext.vWindowOutColor );\n        DrawLine( uiContext.vPixelCanvasPos, smallerRect.vPos+ smallerRect.vSize * vec2(0.25, 1.0), smallerRect.vPos+ smallerRect.vSize * vec2(1.0, 0.25), 2.0f, vCheckColor, uiContext.vWindowOutColor );\n    }\n}\n\nvoid UI_ProcessCheckbox( inout UIContext uiContext, int iControlId, inout UIData_Bool data, Rect checkBoxRect )\n{    \n    bool bMouseOver = Inside( uiContext.vMouseCanvasPos, checkBoxRect ) && uiContext.bMouseInView;\n    \n    if ( uiContext.iActiveControl == IDC_NONE )\n    {\n        if ( uiContext.bMouseDown && (!uiContext.bMouseWasDown) && bMouseOver && !uiContext.bHandledClick )\n        {\n            uiContext.iActiveControl = iControlId;\n            uiContext.bHandledClick = true;\n        }\n    }\n    else\n    if ( uiContext.iActiveControl == iControlId )\n    {\n        if ( !uiContext.bMouseDown )\n        {\n            uiContext.iActiveControl = IDC_NONE;\n            if ( bMouseOver )\n            {\n                data.bValue = !data.bValue;\n            }\n        }\n    }\n    \n    bool bActive = (uiContext.iActiveControl == iControlId);\n    \n    UI_DrawCheckbox( uiContext, bActive, bMouseOver, data.bValue, checkBoxRect );    \n}\n\nvoid UI_DrawSliderX( inout UIContext uiContext, bool bActive, bool bMouseOver, float fPosition, Rect sliderRect, float fHandleSize, bool scrollbarStyle )\n{\n\tif (!uiContext.bPixelInView || Outside( uiContext.vPixelCanvasPos, sliderRect ))\n        return;\n    \n    Rect horizLineRect;\n    \n    horizLineRect = sliderRect;\n    if (!scrollbarStyle)\n    {\n\t    float fMid = sliderRect.vPos.y + sliderRect.vSize.y * 0.5;\n    \thorizLineRect.vPos.y = fMid - 2.0;\n    \thorizLineRect.vSize.y = 4.0;\n    }\n\n    DrawBorderIndent( uiContext.vPixelCanvasPos, horizLineRect, uiContext.vWindowOutColor );\n\n    float fSlideMin = sliderRect.vPos.x + fHandleSize * 0.5f;\n    float fSlideMax = sliderRect.vPos.x + sliderRect.vSize.x - fHandleSize * 0.5f;\n\n    float fDistSlider = (fSlideMin + (fSlideMax-fSlideMin) * fPosition);\n\n    Rect handleRect;\n\n    handleRect = sliderRect;\n    handleRect.vPos.x = fDistSlider - fHandleSize * 0.5f;\n    handleRect.vSize.x = fHandleSize;\n\n    vec4 handleColor = vec4(0.75, 0.75, 0.75, 1.0);\n    if ( bActive )\n    {\n        handleColor.rgb += 0.1;\n    }\n\n    DrawRect( uiContext.vPixelCanvasPos, handleRect, handleColor, uiContext.vWindowOutColor );\n    DrawBorder( uiContext.vPixelCanvasPos, handleRect, uiContext.vWindowOutColor );\n}\n\nvoid UI_DrawSliderY( inout UIContext uiContext, bool bActive, bool bMouseOver, float fPosition, Rect sliderRect, float fHandleSize, bool scrollbarStyle )\n{\n\tif (!uiContext.bPixelInView || Outside( uiContext.vPixelCanvasPos, sliderRect ))\n        return;\n    \n    Rect horizLineRect;\n    \n    horizLineRect = sliderRect;\n    if (!scrollbarStyle)\n    {\n\t    float fMid = sliderRect.vPos.x + sliderRect.vSize.x * 0.5;\n    \thorizLineRect.vPos.x = fMid - 2.0;\n    \thorizLineRect.vSize.x = 4.0;\n    }\n\n    DrawBorderIndent( uiContext.vPixelCanvasPos, horizLineRect, uiContext.vWindowOutColor );\n\n    float fSlideMin = sliderRect.vPos.y + fHandleSize * 0.5f;\n    float fSlideMax = sliderRect.vPos.y + sliderRect.vSize.y - fHandleSize * 0.5f;\n\n    float fDistSlider = (fSlideMin + (fSlideMax-fSlideMin) * fPosition);\n\n    Rect handleRect;\n\n    handleRect = sliderRect;\n    handleRect.vPos.y = fDistSlider - fHandleSize * 0.5f;\n    handleRect.vSize.y = fHandleSize;\n\n    vec4 handleColor = vec4(0.75, 0.75, 0.75, 1.0);\n    if ( bActive )\n    {\n        handleColor.rgb += 0.1;\n    }\n\n    DrawRect( uiContext.vPixelCanvasPos, handleRect, handleColor, uiContext.vWindowOutColor );\n    DrawBorder( uiContext.vPixelCanvasPos, handleRect, uiContext.vWindowOutColor );\n}\n\nvoid UI_ProcessSlider( inout UIContext uiContext, int iControlId, inout UIData_Value data, Rect sliderRect )\n{    \n    float fHandleSize = 8.0;\n    \n    bool bMouseOver = Inside( uiContext.vMouseCanvasPos, sliderRect ) && uiContext.bMouseInView;\n    \n    if ( uiContext.iActiveControl == IDC_NONE )\n    {\n        if ( uiContext.bMouseDown && (!uiContext.bMouseWasDown) && bMouseOver && !uiContext.bHandledClick )\n        {\n            uiContext.iActiveControl = iControlId;\n            uiContext.bHandledClick = true;\n        }\n    }\n    else\n    if ( uiContext.iActiveControl == iControlId )\n    {\n        float fSlidePosMin = sliderRect.vPos.x + fHandleSize * 0.5f;\n        float fSlidePosMax = sliderRect.vPos.x + sliderRect.vSize.x - fHandleSize * 0.5f;\n        float fPosition = (uiContext.vMouseCanvasPos.x - fSlidePosMin) / (fSlidePosMax - fSlidePosMin);\n        fPosition = clamp( fPosition, 0.0f, 1.0f );\n        data.fValue = data.fRangeMin + fPosition * (data.fRangeMax - data.fRangeMin);\n        if ( !uiContext.bMouseDown )\n        {\n            uiContext.iActiveControl = IDC_NONE;\n        }\n    }\n        \n    bool bActive = (uiContext.iActiveControl == iControlId);\n    float fPosition = (data.fValue - data.fRangeMin) / (data.fRangeMax - data.fRangeMin);\n    \n    UI_DrawSliderX( uiContext, bActive, bMouseOver, fPosition, sliderRect, fHandleSize, false );    \n}\n\nvoid UI_ProcessScrollbarX( inout UIContext uiContext, int iControlId, inout UIData_Value data, Rect sliderRect, float fHandleSize )\n{    \n    bool bMouseOver = Inside( uiContext.vMouseCanvasPos, sliderRect ) && uiContext.bMouseInView;\n        \n    if ( uiContext.iActiveControl == IDC_NONE )\n    {\n        if ( uiContext.bMouseDown && (!uiContext.bMouseWasDown) && bMouseOver && !uiContext.bHandledClick )\n        {\n            uiContext.iActiveControl = iControlId;\n            uiContext.bHandledClick = true;\n        }\n    }\n    else\n    if ( uiContext.iActiveControl == iControlId )\n    {\n        float fSlidePosMin = sliderRect.vPos.x + fHandleSize * 0.5f;\n        float fSlidePosMax = sliderRect.vPos.x + sliderRect.vSize.x - fHandleSize * 0.5f;\n        float fPosition = (uiContext.vMouseCanvasPos.x - fSlidePosMin) / (fSlidePosMax - fSlidePosMin);\n        fPosition = clamp( fPosition, 0.0f, 1.0f );\n        data.fValue = data.fRangeMin + fPosition * (data.fRangeMax - data.fRangeMin);\n        if ( !uiContext.bMouseDown )\n        {\n            uiContext.iActiveControl = IDC_NONE;\n        }\n    }\n        \n    bool bActive = (uiContext.iActiveControl == iControlId);\n    float fPosition = (data.fValue - data.fRangeMin) / (data.fRangeMax - data.fRangeMin);\n    \n    UI_DrawSliderX( uiContext, bActive, bMouseOver, fPosition, sliderRect, fHandleSize, true );    \n}\n\nvoid UI_ProcessScrollbarY( inout UIContext uiContext, int iControlId, inout UIData_Value data, Rect sliderRect, float fHandleSize )\n{    \n    bool bMouseOver = Inside( uiContext.vMouseCanvasPos, sliderRect ) && uiContext.bMouseInView;\n    \n    if ( uiContext.iActiveControl == IDC_NONE )\n    {\n        if ( uiContext.bMouseDown && (!uiContext.bMouseWasDown) && bMouseOver && !uiContext.bHandledClick )\n        {\n            uiContext.iActiveControl = iControlId;\n            uiContext.bHandledClick = true;\n        }\n    }\n    else\n    if ( uiContext.iActiveControl == iControlId )\n    {\n        float fSlidePosMin = sliderRect.vPos.y + fHandleSize * 0.5f;\n        float fSlidePosMax = sliderRect.vPos.y + sliderRect.vSize.y - fHandleSize * 0.5f;\n        float fPosition = (uiContext.vMouseCanvasPos.y - fSlidePosMin) / (fSlidePosMax - fSlidePosMin);\n        fPosition = clamp( fPosition, 0.0f, 1.0f );\n        data.fValue = data.fRangeMin + fPosition * (data.fRangeMax - data.fRangeMin);\n        if ( !uiContext.bMouseDown )\n        {\n            uiContext.iActiveControl = IDC_NONE;\n        }\n    }\n        \n    bool bActive = (uiContext.iActiveControl == iControlId);\n    float fPosition = (data.fValue - data.fRangeMin) / (data.fRangeMax - data.fRangeMin);\n    \n    UI_DrawSliderY( uiContext, bActive, bMouseOver, fPosition, sliderRect, fHandleSize, true );    \n}\n\nvoid UI_DrawColorPickerSV( inout UIContext uiContext, bool bActive, vec3 vHSV, Rect pickerRect )\n{\n\tif (!uiContext.bPixelInView || Outside( uiContext.vPixelCanvasPos, pickerRect ))\n        return;\n    \n    vec2 vCurrPixelPos = (uiContext.vPixelCanvasPos - pickerRect.vPos) / pickerRect.vSize;\n    vCurrPixelPos.y = 1.0f - vCurrPixelPos.y;\n    vec3 vHSVCurr = vHSV;\n    vHSVCurr.yz = vCurrPixelPos;\n\n    uiContext.vWindowOutColor = vec4( hsv2rgb( vHSVCurr ), 1.0 );\n    \n    vec2 vSelectedPos = vHSV.yz;\n    vSelectedPos.y = 1.0f - vSelectedPos.y;\n    vSelectedPos = vSelectedPos * pickerRect.vSize + pickerRect.vPos;\n        \n    float l = length( vSelectedPos - uiContext.vPixelCanvasPos );\n    float d = l - 3.0;\n    d = min(d, 5.0 - l);\n    if ( bActive )\n    {\n        float d2 = l - 5.0;\n    \td2 = min(d2, 7.0 - l);\n\t    d = max(d, d2);\n    }\n    \n    float fBlend = clamp(d, 0.0, 1.0);\n    \n    uiContext.vWindowOutColor.rgb = mix(uiContext.vWindowOutColor.rgb, vec3(1.0) - uiContext.vWindowOutColor.rgb, fBlend);\n}\n\nvoid UI_ProcessColorPickerSV( inout UIContext uiContext, int iControlId, inout UIData_Color data, Rect pickerRect )\n{\n    bool bMouseOver = Inside( uiContext.vMouseCanvasPos, pickerRect ) && uiContext.bMouseInView;\n    \n    vec3 vHSV = data.vHSV;\n    \n    if ( uiContext.iActiveControl == IDC_NONE )\n    {\n        if ( uiContext.bMouseDown && (!uiContext.bMouseWasDown) && bMouseOver && !uiContext.bHandledClick )\n        {\n            uiContext.iActiveControl = iControlId;\n            uiContext.bHandledClick = true;\n        }\n    }\n    else\n    if ( uiContext.iActiveControl == iControlId )\n    {\n        vec2 vPos = (uiContext.vMouseCanvasPos - pickerRect.vPos) / pickerRect.vSize;\n        vPos = clamp( vPos, vec2(0), vec2(1) );\n        \n        vHSV.yz = vPos;\n        vHSV.z = 1.0f - vHSV.z;\n        \n        if ( !uiContext.bMouseDown )\n        {\n            uiContext.iActiveControl = IDC_NONE;\n        }\n    }\n    \n    data.vHSV = vHSV;\n    \n    bool bActive = (uiContext.iActiveControl == iControlId);\n    \n    UI_DrawColorPickerSV( uiContext, bActive, vHSV, pickerRect );    \n}\n\nvoid UI_DrawColorPickerH( inout UIContext uiContext, bool bActive, vec3 vHSV, Rect pickerRect )\n{\n\tif (!uiContext.bPixelInView || Outside( uiContext.vPixelCanvasPos, pickerRect ))\n        return;\n    \n    vec2 vCurrPixelPos = (uiContext.vPixelCanvasPos - pickerRect.vPos) / pickerRect.vSize;\n    vec3 vHSVCurr = vHSV;\n    vHSVCurr.x = vCurrPixelPos.y;\n    vHSVCurr.yz = vec2(1.0, 1.0);\n    \n    float fSelectedPos = vHSV.x * pickerRect.vSize.y + pickerRect.vPos.y;\n\n\tuiContext.vWindowOutColor = vec4( hsv2rgb( vHSVCurr ), 1.0 );\n        \n    float l = length( fSelectedPos - uiContext.vPixelCanvasPos.y );\n    float d = l - 1.0;\n    d = min(d, 5.0 - l);\n    if ( bActive )\n    {\n        float d2 = l - 4.0;\n    \td2 = min(d2, 6.0 - l);\n\t    d = max(d, d2);\n    }\n    \n    float fBlend = clamp(d, 0.0, 1.0);\n    \n    uiContext.vWindowOutColor.rgb = mix(uiContext.vWindowOutColor.rgb, vec3(0.5), fBlend);    \n}\n\nvoid UI_ProcessColorPickerH( inout UIContext uiContext, int iControlId, inout UIData_Color data, Rect pickerRect )\n{\n    bool bMouseOver = Inside( uiContext.vMouseCanvasPos, pickerRect ) && uiContext.bMouseInView;\n    \n    vec3 vHSV = data.vHSV;\n    \n    if ( uiContext.iActiveControl == IDC_NONE )\n    {\n        if ( uiContext.bMouseDown && (!uiContext.bMouseWasDown) && bMouseOver && !uiContext.bHandledClick )\n        {\n            uiContext.iActiveControl = iControlId;\n            uiContext.bHandledClick = true;\n        }\n    }\n    else\n    if ( uiContext.iActiveControl == iControlId )\n    {\n        float fPos = (uiContext.vMouseCanvasPos.y - pickerRect.vPos.y) / pickerRect.vSize.y;\n        fPos = clamp( fPos, 0.0f, 1.0f );\n        \n        vHSV.x = fPos;\n        \n        if ( !uiContext.bMouseDown )\n        {\n            uiContext.iActiveControl = IDC_NONE;\n        }\n    }\n    \n    data.vHSV = vHSV;\n    \n    bool bActive = (uiContext.iActiveControl == iControlId);\n    \n    UI_DrawColorPickerH( uiContext, bActive, vHSV, pickerRect );\n}\n\nbool UI_DrawWindowCloseBox( inout UIContext uiContext, Rect closeBoxRect )\n{\n\tif (!uiContext.bPixelInView || !Inside( uiContext.vPixelCanvasPos, closeBoxRect ))\n        return false;\n    \n    vec2 vCrossPos = closeBoxRect.vPos + closeBoxRect.vSize * 0.5;        \n    vec2 vCrossSize = closeBoxRect.vSize * 0.5 * 0.4;\n    vec4 crossColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec2 vCrossSizeFlip = vCrossSize * vec2(1.0, -1.0);\n    \n    DrawLine( uiContext.vPixelCanvasPos, vCrossPos - vCrossSize, vCrossPos + vCrossSize, 2.0f, crossColor, uiContext.vWindowOutColor );\n    DrawLine( uiContext.vPixelCanvasPos, vCrossPos - vCrossSizeFlip, vCrossPos + vCrossSizeFlip, 2.0f, crossColor, uiContext.vWindowOutColor );\n    \n    return true;\n}\n\nbool UI_ProcessWindowCloseBox( inout UIContext uiContext, inout UIWindowState window, int iControlId, Rect closeBoxRect )\n{\n    bool bPressed = UI_ProcessButton( uiContext, iControlId, closeBoxRect );\n    \n    if ( bPressed )\n    {\n \t\twindow.bClosed = true;\n    }\n\n    bool bActive = (uiContext.iActiveControl == iControlId);\n    \n    return UI_DrawWindowCloseBox( uiContext, closeBoxRect );\n}\n    \nbool UI_DrawWindowMinimizeWidget( inout UIContext uiContext, bool bMinimized, Rect minimizeBoxRect )\n{\n\tif (!uiContext.bPixelInView || !Inside( uiContext.vPixelCanvasPos, minimizeBoxRect ))\n        return false;\n    \n    vec2 vArrowPos = minimizeBoxRect.vPos + minimizeBoxRect.vSize * 0.5;        \n    vec2 vArrowSize = minimizeBoxRect.vSize * 0.25;\n    vec4 arrowColor = vec4(0.0, 0.0, 0.0, 1.0);\n    if ( !bMinimized )\n    {\n        DrawLine( uiContext.vPixelCanvasPos, vArrowPos + vec2(-1.0, -0.5) * vArrowSize, vArrowPos + vec2(0.0, 0.5) * vArrowSize, 2.0f, arrowColor, uiContext.vWindowOutColor );\n        DrawLine( uiContext.vPixelCanvasPos, vArrowPos + vec2( 1.0, -0.5) * vArrowSize, vArrowPos + vec2(0.0, 0.5) * vArrowSize, 2.0f, arrowColor, uiContext.vWindowOutColor );\n    }\n    else\n    {\n        DrawLine( uiContext.vPixelCanvasPos, vArrowPos + vec2( 0.5, 0.0 )* vArrowSize, vArrowPos + vec2(-0.5, -1.0) * vArrowSize, 2.0f, arrowColor, uiContext.vWindowOutColor );\n        DrawLine( uiContext.vPixelCanvasPos, vArrowPos + vec2( 0.5, 0.0 )* vArrowSize, vArrowPos + vec2(-0.5,  1.0) * vArrowSize, 2.0f, arrowColor, uiContext.vWindowOutColor );\n    }    \n    \n    return true;\n}\n\nbool UI_ProcessWindowMinimizeWidget( inout UIContext uiContext, inout UIWindowState window, int iControlId, Rect minimizeBoxRect )\n{    \n    bool bPressed = UI_ProcessButton( uiContext, iControlId, minimizeBoxRect );\n    \n    if ( bPressed )\n    {\n \t\twindow.bMinimized = !window.bMinimized;        \n    }\n\n    bool bActive = (uiContext.iActiveControl == iControlId);\n    \n    return UI_DrawWindowMinimizeWidget( uiContext, window.bMinimized, minimizeBoxRect );\n}\n\nvoid UI_ProcessScrollbarPanelBegin( inout UIContext uiContext, inout UIPanelState scrollbarState, int iControlId, int iData, Rect scrollbarPanelRect, vec2 vScrollbarCanvasSize )\n{\n    float styleSize = UIStyle_ScrollBarSize();\n    \n\tbool bScrollbarHorizontal = (scrollbarPanelRect.vSize.x < vScrollbarCanvasSize.x);\n    if ( bScrollbarHorizontal )\n    {        \n        scrollbarPanelRect.vSize.y -= styleSize;\n    }\n\n    bool bScrollbarVertical = (scrollbarPanelRect.vSize.y < vScrollbarCanvasSize.y);\n    if ( bScrollbarVertical )\n    {\n        scrollbarPanelRect.vSize.x -= styleSize;\n    }\n\n    // Adding a vertical scrollbar may mean we now need a horizontal one\n    if ( !bScrollbarHorizontal )\n    {\n        bScrollbarHorizontal = (scrollbarPanelRect.vSize.x < vScrollbarCanvasSize.x);\n        if ( bScrollbarHorizontal )\n        {        \n            scrollbarPanelRect.vSize.y -= styleSize;\n        }\n    }\n    \n    // Todo : Force enable or disable ?\n\n\tvec4 vData0 = LoadVec4( iChannelUI, ivec2(iData,0) );   \n        \n    UIData_Value scrollValueX;\n    scrollValueX.fRangeMin = 0.0;\n    scrollValueX.fRangeMax = max(0.0, vScrollbarCanvasSize.x - scrollbarPanelRect.vSize.x);\n        \n    UIData_Value scrollValueY;\n    scrollValueY.fRangeMin = 0.0;\n    scrollValueY.fRangeMax = max(0.0, vScrollbarCanvasSize.y - scrollbarPanelRect.vSize.y);\n    \n    if ( iFrame == 0 || vData0.z != DIRTY_DATA_MAGIC )\n    {\n        scrollValueX.fValue = 0.0;\n        scrollValueY.fValue = 0.0;\n    }\n    else\n    {\n        scrollValueX.fValue = vData0.x;\n        scrollValueY.fValue = vData0.y;\n    }    \n    \n    scrollValueX.fValue = clamp( scrollValueX.fValue, scrollValueX.fRangeMin, scrollValueX.fRangeMax );\n    scrollValueY.fValue = clamp( scrollValueY.fValue, scrollValueY.fRangeMin, scrollValueY.fRangeMax );\n    \n    if ( bScrollbarHorizontal )\n    {\n        Rect scrollbarRect;\n        scrollbarRect.vPos = scrollbarPanelRect.vPos;\n        scrollbarRect.vPos.y += scrollbarPanelRect.vSize.y;\n        scrollbarRect.vSize.x = scrollbarPanelRect.vSize.x;\n        scrollbarRect.vSize.y = styleSize;\n        \n        float fHandleSize = scrollbarRect.vSize.x * (scrollbarPanelRect.vSize.x / vScrollbarCanvasSize.x);\n\n        if ( uiContext.bPixelInView ) \n        {\n\t        DrawRect( uiContext.vPixelCanvasPos, scrollbarRect, vec4(0.6, 0.6, 0.6, 1.0), uiContext.vWindowOutColor );\n        }        \n        UI_ProcessScrollbarX( uiContext, iControlId, scrollValueX, scrollbarRect, fHandleSize );\n    }\n        \n    if ( bScrollbarVertical )\n    {        \n        Rect scrollbarRect;\n        scrollbarRect.vPos = scrollbarPanelRect.vPos;\n        scrollbarRect.vPos.x += scrollbarPanelRect.vSize.x;\n        scrollbarRect.vSize.x = styleSize;\n        scrollbarRect.vSize.y = scrollbarPanelRect.vSize.y;\n        \n        float fHandleSize = scrollbarRect.vSize.y * (scrollbarPanelRect.vSize.y / vScrollbarCanvasSize.y);\n        \n        if ( uiContext.bPixelInView ) \n        {\n\t        DrawRect( uiContext.vPixelCanvasPos, scrollbarRect, vec4(0.6, 0.6, 0.6, 1.0), uiContext.vWindowOutColor );\n        }\n        \n        UI_ProcessScrollbarY( uiContext, iControlId + 1000, scrollValueY, scrollbarRect, fHandleSize );\n    }\n    \n    if ( bScrollbarHorizontal && bScrollbarVertical ) \n    {\n        Rect cornerRect;\n        cornerRect.vPos = scrollbarPanelRect.vPos;\n        cornerRect.vPos += scrollbarPanelRect.vSize;\n        cornerRect.vSize = vec2(styleSize);\n        \n        if ( uiContext.bPixelInView ) \n        {\n            DrawRect( uiContext.vPixelCanvasPos, cornerRect, vec4(0.7, 0.7, 0.7, 1.0), uiContext.vWindowOutColor );\n        \tDrawBorderIndent( uiContext.vPixelCanvasPos, cornerRect, uiContext.vWindowOutColor );\n        }\n    }\n\n    UI_PanelBegin( uiContext, scrollbarState );    \n    \n    vData0.x = scrollValueX.fValue;\n    vData0.y = scrollValueY.fValue;\n    vData0.z = DIRTY_DATA_MAGIC;\n    StoreVec4( ivec2(iData,0), vData0, uiContext.vOutData, ivec2(uiContext.vFragCoord) );    \n        \n            \n    UIDrawContext scrollbarPanelContextDesc = UIDrawContext_SetupFromRect( scrollbarPanelRect );\n    scrollbarPanelContextDesc.vCanvasSize = vScrollbarCanvasSize;\n    scrollbarPanelContextDesc.vOffset = vec2(scrollValueX.fValue, scrollValueY.fValue);\n\n    UIDrawContext scrollbarPanelContext = UIDrawContext_TransformChild( scrollbarState.parentDrawContext, scrollbarPanelContextDesc );\n    UI_SetDrawContext( uiContext, scrollbarPanelContext );\n}\n\nvoid UI_ProcessScrollbarPanelEnd( inout UIContext uiContext, inout UIPanelState scrollbarState )\n{\n    UI_PanelEnd( uiContext, scrollbarState );    \n}\n\n\nvoid UIStyle_GetFontStyleTitle( inout LayoutStyle style, inout RenderStyle renderStyle );\nvoid PrintWindowTitle( inout PrintState state, LayoutStyle style, int controlId );\n\nvec2 UI_WindowGetTitleBarSize( UIContext uiContext, inout UIWindowState window )\n{\n    return vec2(window.drawRect.vSize.x - UIStyle_WindowBorderSize().x * 2.0, UIStyle_TitleBarHeight() );\n}\n\nvoid UI_DrawWindowTitleBar( inout UIContext uiContext, bool bActive, Rect titleBarRect, inout UIWindowState window )\n{   \n\tif (!uiContext.bPixelInView || Outside( uiContext.vPixelCanvasPos, titleBarRect ))\n        return;\n    \n    vec4 colorA = vec4(0.0, 0.0, 0.5, 1.0);\n    vec4 colorB = vec4(0.03, 0.5, 0.8, 1.0);\n    if ( bActive )\n    {\n        colorA.rgb += 0.1;\n        colorB.rgb += 0.1;\n    }\n\n    float t = (uiContext.vPixelCanvasPos.x - titleBarRect.vPos.x) / 512.0;\n    t = clamp( t, 0.0f, 1.0f );\n    uiContext.vWindowOutColor = mix( colorA, colorB, t );\n    \n    {\n        LayoutStyle style;\n        RenderStyle renderStyle;\n        UIStyle_GetFontStyleTitle( style, renderStyle );\n\n        vec2 vTextOrigin = vec2(0);\n        if ( FLAG_SET(window.uControlFlags, WINDOW_CONTROL_FLAG_MINIMIZE_BOX) )\n        {\n        \tvTextOrigin.x += titleBarRect.vSize.y;\n        }\n        \n        PrintState state = UI_PrintState_Init( uiContext, style, vTextOrigin );    \n        PrintWindowTitle( state, style, window.iControlId );    \n        RenderFont( state, style, renderStyle, uiContext.vWindowOutColor.rgb );\n    }\n}\n\nbool UI_ProcessWindowTitleBar( inout UIContext uiContext, inout UIWindowState window )\n{\n    int iWindowTitleBarControlId = window.iControlId;\n    int iWindowMinimizeControlId = window.iControlId + 1000;\n    int iWindowCloseControlId = window.iControlId + 3000;\n    Rect titleBarRect = Rect( vec2(0.0), UI_WindowGetTitleBarSize( uiContext, window ) );\n    \n    bool bRenderedWidget = false;\n    if ( FLAG_SET(window.uControlFlags, WINDOW_CONTROL_FLAG_MINIMIZE_BOX) )\n    {\n        Rect minimizeBoxRect = Rect( vec2(0.0), vec2(titleBarRect.vSize.y) );\n        RectShrink( minimizeBoxRect, vec2(4.0) );\n        \n    \tbRenderedWidget = UI_ProcessWindowMinimizeWidget( uiContext, window, iWindowMinimizeControlId, minimizeBoxRect );\n    }\n\n    if ( FLAG_SET(window.uControlFlags, WINDOW_CONTROL_FLAG_CLOSE_BOX) )\n    {\n        Rect closeBoxRect = Rect( vec2(0.0), vec2(titleBarRect.vSize.y) ); \n        closeBoxRect.vPos.x = titleBarRect.vSize.x - closeBoxRect.vSize.x;\n        RectShrink( closeBoxRect, vec2(4.0) );\n        \n        if( UI_ProcessWindowCloseBox( uiContext, window, iWindowCloseControlId, closeBoxRect ) )\n        {\n            bRenderedWidget = true;\n        }\n    }\n            \n    bool bMouseOver = Inside( uiContext.vMouseCanvasPos, titleBarRect ) && uiContext.bMouseInView;\n        \n    if ( uiContext.iActiveControl == IDC_NONE )\n    {\n        if ( uiContext.bMouseDown && (!uiContext.bMouseWasDown) && bMouseOver && !uiContext.bHandledClick )\n        {\n            uiContext.iActiveControl = iWindowTitleBarControlId;\n            uiContext.vActivePos = window.rect.vPos - uiContext.vMousePos;\n            uiContext.bHandledClick = true;\n        }\n    }\n    else\n    if ( uiContext.iActiveControl == iWindowTitleBarControlId )\n    {\n        if ( !uiContext.bMouseDown )\n        {\n            uiContext.iActiveControl = IDC_NONE;\n        }\n    }    \n    \n    bool bActive = (uiContext.iActiveControl == iWindowTitleBarControlId);\n    \n    if ( bActive )\n    {\n        window.rect.vPos = uiContext.vMousePos + uiContext.vActivePos;\n    }   \n    \n    if (!bRenderedWidget)\n    {\n    \tUI_DrawWindowTitleBar( uiContext, bActive, titleBarRect, window );\n    }\n    \n    return Inside( uiContext.vPixelCanvasPos, titleBarRect );\n}\n\nbool ScreenPosInResizeWidget( inout UIContext uiContext, vec2 vCorner, float fControlSize, vec2 vTestPos )\n{\n    vec2 vTestCanvasPos = UIDrawContext_ScreenPosToCanvasPos( uiContext.drawContext, vTestPos );\n    vec2 vOffset = vTestCanvasPos - vCorner + vec2( fControlSize, 0.0 );\n    bool bInCorner = (vOffset.x + vOffset.y) > 0.0;\n    \n    return bInCorner;\n}\n\nvoid UI_ProcessWindowResizeWidget( inout UIContext uiContext, inout UIWindowState window, int iControlId )\n{\n    vec2 vCorner = uiContext.drawContext.vCanvasSize;\n    float fControlSize = 24.0;\n    \n    bool bMouseOver = ScreenPosInResizeWidget( uiContext, vCorner, fControlSize, uiContext.vMousePos )\n        && uiContext.bMouseInView;\n        \n    if ( uiContext.iActiveControl == IDC_NONE )\n    {\n        if ( uiContext.bMouseDown && (!uiContext.bMouseWasDown) && bMouseOver && !uiContext.bHandledClick)\n        {\n            uiContext.iActiveControl = iControlId;\n            \n            uiContext.vActivePos = window.rect.vSize - uiContext.vMousePos;\n            \n            uiContext.bHandledClick = true;\n        }\n    }\n    else\n    if ( uiContext.iActiveControl == iControlId )\n    {\n        if ( !uiContext.bMouseDown )\n        {\n            uiContext.iActiveControl = IDC_NONE;\n        }\n    }\n        \n    bool bActive = (uiContext.iActiveControl == iControlId);        \n    \n    if ( bActive )\n    {\n        window.rect.vSize = uiContext.vMousePos + uiContext.vActivePos;\n        vec2 vMinWindowSize = vec2( 96.0, 64.0 );\n        window.rect.vSize = max( vMinWindowSize, window.rect.vSize );\n        window.rect.vSize = min( window.vMaxSize, window.rect.vSize );\n    }\n    \n    \n    if ( uiContext.bPixelInView &&\n        ScreenPosInResizeWidget( uiContext, vCorner, fControlSize, uiContext.vPixelPos ) )\n    {\n        vec4 vColor = vec4(0.6, 0.6, 0.6, 1.0);\n        \n        if( bActive )\n        {\n            vColor = vec4(0.8, 0.8, 0.8, 1.0);\n        }\n        uiContext.vWindowOutColor = vColor;\n    }    \n}\n\nvec2 UI_GetWindowSizeForContent( vec2 vContentSize )\n{\n    return vContentSize \n        + vec2( 0.0, UIStyle_TitleBarHeight() )\n    \t+ UIStyle_WindowBorderSize() * 2.0\n    \t+ UIStyle_WindowContentPadding() * 2.0;\n}\n\nUIWindowState UI_ProcessWindowCommonBegin( inout UIContext uiContext, int iControlId, int iData, UIWindowDesc desc )\n{   \n    UIWindowState window = UI_GetWindowState( uiContext, iControlId, iData, desc );\n    \n    if ( window.bClosed )\n    {\n        return window;\n    }\n    \n    UI_PanelBegin( uiContext, window.panelState );\n    \n    uiContext.vWindowOutColor.rgba = UIStyle_WindowBackgroundColor();\n    \n    window.drawRect = window.rect;\n    \n    Rect contextRect = window.drawRect;    \n    RectShrink( contextRect, UIStyle_WindowBorderSize() );\n    \n    vec2 vTitleBarSize = UI_WindowGetTitleBarSize( uiContext, window );\n    if ( window.bMinimized )\n    {\n\t    window.drawRect.vSize.y = vTitleBarSize.y + UIStyle_WindowBorderSize().y * 2.0;\n    }\n    \n    // Get window main panel view\n    Rect panelRect = contextRect;\n    \n    panelRect.vPos.y += vTitleBarSize.y;\n    panelRect.vSize.y -= vTitleBarSize.y;\n    \n    if ( window.bMinimized )\n    {\n        panelRect.vSize.y = 0.0;\n    }           \n    \n    \n    UIDrawContext panelDesc = UIDrawContext_SetupFromRect( panelRect );\n    UIDrawContext panelContext = UIDrawContext_TransformChild( window.panelState.parentDrawContext, panelDesc );\n    UI_SetDrawContext( uiContext, panelContext );\n    \n    if ( FLAG_SET(window.uControlFlags, WINDOW_CONTROL_FLAG_RESIZE_WIDGET) )\n    {\n        int iWindowResizeControlId = window.iControlId + 2000; // hack        \n    \tUI_ProcessWindowResizeWidget( uiContext, window, iWindowResizeControlId );\n    }\n            \n    // Get window content panel view\n    UIDrawContext contentPanelDesc;\n    contentPanelDesc.viewport = Rect( vec2(0.0), uiContext.drawContext.viewport.vSize );\n    RectShrink( contentPanelDesc.viewport, UIStyle_WindowContentPadding() );\n    contentPanelDesc.vOffset = vec2(0);\n    contentPanelDesc.vCanvasSize = contentPanelDesc.viewport.vSize;\n\n    UI_SetDrawContext( uiContext, UIDrawContext_TransformChild( panelContext, contentPanelDesc ) ); \n    \n    return window;\n}\n\nvoid UI_ProcessWindowCommonEnd( inout UIContext uiContext, inout UIWindowState window, int iData )\n{    \n    bool bPixelInPanel = uiContext.bPixelInView;\n    \n    Rect contextRect = window.drawRect;    \n    RectShrink( contextRect, UIStyle_WindowBorderSize() );\n    \n    UIDrawContext windowContextDesc = UIDrawContext_SetupFromRect( contextRect );\n    UIDrawContext windowContext = UIDrawContext_TransformChild( window.panelState.parentDrawContext, windowContextDesc );\n\tUI_SetDrawContext( uiContext, windowContext );\n    \n    bool inTitleBar = false;\n    if (  FLAG_SET(window.uControlFlags, WINDOW_CONTROL_FLAG_TITLE_BAR)  )\n    {\n    \tinTitleBar = UI_ProcessWindowTitleBar( uiContext, window );\n    }\n    \n    UIDrawContext windowBackgroundContextDesc = UIDrawContext_SetupFromRect( window.drawRect );\n    UIDrawContext windowBackgroundContext = UIDrawContext_TransformChild( window.panelState.parentDrawContext, windowBackgroundContextDesc );    \n\n    UI_SetDrawContext( uiContext, windowBackgroundContext );\n    if ( !bPixelInPanel && !inTitleBar )\n    {\n        Rect rect = Rect( vec2(0), window.drawRect.vSize );\n\t    DrawBorder( uiContext.vPixelCanvasPos, rect, uiContext.vWindowOutColor );                    \n    }    \n    \n    if ( uiContext.bMouseDown && uiContext.bMouseInView && !uiContext.bHandledClick )\n    {\n        uiContext.bHandledClick = true;\n    }\n    \n    Rect windowRect = uiContext.drawContext.clip;\n\n    UI_PanelEnd( uiContext, window.panelState );\n    UI_ComposeWindowLayer( uiContext, UIStyle_WindowTransparency(), windowRect );\n    \n    UI_StoreWindowState( uiContext, window, iData );    \n}\n\n////////////////////////////////////////////////////////////////////////\n// Client Code Below Here\n////////////////////////////////////////////////////////////////////////\n\nfloat \tUIStyle_TitleBarHeight() \t\t{ return 24.0; }\nvec2 \tUIStyle_WindowBorderSize() \t\t{ return vec2(4.0); }\nvec2 \tUIStyle_WindowContentPadding() \t{ return vec2(16.0, 8.0); }\nvec2 \tUIStyle_ControlSpacing() \t\t{ return  vec2(4.0); }\nvec2 \tUIStyle_FontPadding() \t\t\t{ return vec2(6.0, 2.0); }\nvec2 \tUIStyle_CheckboxSize() \t\t\t{ return vec2(16.0); }\nvec2 \tUIStyle_SliderSize()\t\t\t{ return vec2(192.0, 24.0f); }\nvec3 \tUIStyle_ColorPickerSize()\t\t{ return vec3(192.0, 192.0, 32.0); }\nfloat \tUIStyle_ScrollBarSize() \t\t{ return 24.0; }\nvec4    UIStyle_WindowBackgroundColor() { return vec4( 0.75, 0.75, 0.75, 1.0 ); }\nfloat   UIStyle_WindowTransparency() \t{ return 0.025f; }\n\nvoid UIStyle_GetFontStyleWindowText( inout LayoutStyle style, inout RenderStyle renderStyle )\n{\n    style = LayoutStyle_Default();\n    style.vSize *= 0.75;\n\trenderStyle = RenderStyle_Default( vec3(0.0) );\n}\n\nvoid UIStyle_GetFontStyleTitle( inout LayoutStyle style, inout RenderStyle renderStyle )\n{\n    style = LayoutStyle_Default();\n    style.vSize *= 0.75;\n\trenderStyle = RenderStyle_Default( vec3(1.0) );\n}\n\nconst int\n     DATA_UICONTEXT\t\t\t\t\t\t= 0\n\t,DATA_WINDOW_CONTROLS   \t\t\t= 2\n    ,DATA_PAGE_NO\t\t\t\t\t\t= 4\n    ,DATA_FADE\t\t\t\t\t\t\t= 5\n\t,DATA_SEPARATION\t\t\t\t\t= 6\n\t,DATA_COHESION\t\t\t\t\t\t= 7\n\t,DATA_ALIGNMENT\t\t\t\t\t\t= 8\n    ,DATA_COUNT\t\t\t\t\t\t\t= 9\n    ,DATA_WALLS \t\t\t\t\t\t= 10\n    ;\n    \nconst int\n\t IDC_WINDOW_CONTROLS      \t\t\t= 0\n\t,IDC_SLIDER_SEPARATION \t\t\t   \t= 3\n\t,IDC_SLIDER_COHESION\t\t\t\t= 4\n\t,IDC_SLIDER_ALIGNMENT\t\t\t\t= 5\n    ,IDC_SLIDER_COUNT \t\t\t\t\t= 6\n    ,IDC_BUTTON_NEXT_PAGE\t\t\t\t= 7\n    ,IDC_CHECKBOX_WALLS \t\t\t\t= 8\n    ;\n\n\nvoid PrintWindowTitle( inout PrintState state, LayoutStyle style, int controlId )\n{\n    if ( controlId == IDC_WINDOW_CONTROLS )\n    {\n        uint strA[] = uint[] ( _C, _o, _n, _t, _r, _o, _l, _s );\n        ARRAY_PRINT(state, style, strA);\n    }\n}\n\nstruct UIData\n{\n    UIData_Value pageNo;\n    UIData_Value fade;\n\n    UIData_Value separation;\n    UIData_Value cohesion;\n    UIData_Value alignment;\n\n    UIData_Bool walls;\n    \n    UIData_Value count;\n};    \n\n    \nUIData UI_GetControlData()\n{\n    UIData data;\n    \n    data.pageNo = UI_GetDataValue( DATA_PAGE_NO, 0.0, 0.0, 5.0 );\n    data.fade = UI_GetDataValue( DATA_FADE, 1.0, 0.0, 1.0 );\n    \n    data.separation = UI_GetDataValue( DATA_SEPARATION, 0.5, 0.0, 1.0 );\n    data.cohesion = UI_GetDataValue( DATA_COHESION, 0.5, 0.0, 1.0 );\n    data.alignment = UI_GetDataValue( DATA_ALIGNMENT, 0.5, 0.0, 1.0 );\n\n    data.walls = UI_GetDataBool( DATA_WALLS, true );\n    \n    data.count = UI_GetDataValue( DATA_COUNT, 20.0, 0.0, 400.0 );\n    \n    return data;\n}\n\n\nvoid UI_StoreControlData( inout UIContext uiContext, UIData data )\n{\n    UI_StoreDataValue( uiContext, data.pageNo, DATA_PAGE_NO );\n    UI_StoreDataValue( uiContext, data.fade, DATA_FADE );\n    \n    UI_StoreDataValue( uiContext, data.separation, DATA_SEPARATION );\n    UI_StoreDataValue( uiContext, data.cohesion, DATA_COHESION );\n    UI_StoreDataValue( uiContext, data.alignment, DATA_ALIGNMENT );\n\n    UI_StoreDataBool( uiContext, data.walls, DATA_WALLS );\n    \n    UI_StoreDataValue( uiContext, data.count, DATA_COUNT );\n}\n\n\nvoid UI_ProcessWindowMain( inout UIContext uiContext, inout UIData uiData, int iControlId, int iData )\n{\n    UIWindowDesc desc;\n    \n    desc.initialRect = Rect( vec2(16, 16), vec2(390, 200) );\n    desc.bStartMinimized = false;\n    desc.bStartClosed = false;\n    desc.uControlFlags = WINDOW_CONTROL_FLAG_TITLE_BAR | WINDOW_CONTROL_FLAG_MINIMIZE_BOX | WINDOW_CONTROL_FLAG_RESIZE_WIDGET;    \n    desc.vMaxSize = vec2(390, 200);    \n\n    \n    UIWindowState window = UI_ProcessWindowCommonBegin( uiContext, iControlId, iData, desc );\n    \n    if ( !window.bMinimized )\n    {\n        // Controls...\n\n        {        \n            float tabX = 108.0f;\n            //Scroll Panel Controls...\n            UILayout uiLayout = UILayout_Reset();\n\n            LayoutStyle style;\n            RenderStyle renderStyle;             \n            UIStyle_GetFontStyleWindowText( style, renderStyle );       \n\n\n            {\n                PrintState state = UI_PrintState_Init( uiContext, style, uiLayout.vCursor );        \n                uint strA[] = uint[] ( _S, _e, _p, _a, _r, _a, _t, _i, _o, _n, _COLON );\n                ARRAY_PRINT(state, style, strA);\n                UI_RenderFont( uiContext, state, style, renderStyle );\n                UILayout_SetControlRectFromText( uiLayout, state, style );\n            }\n            //UILayout_StackRight( uiLayout );\n            UILayout_SetX( uiLayout, tabX );\n            \n            UILayout_StackControlRect( uiLayout, UIStyle_SliderSize() );                \n            UI_ProcessSlider( uiContext, IDC_SLIDER_SEPARATION, uiData.separation, uiLayout.controlRect );\n            UILayout_StackRight( uiLayout );\n\n            {\n                PrintState state = UI_PrintState_Init( uiContext, style, uiLayout.vCursor );        \n                Print(state, style, uiData.separation.fValue, 2 );\n\n                UI_RenderFont( uiContext, state, style, renderStyle );\n\n                UILayout_SetControlRectFromText( uiLayout, state, style );\n            }\n\n            UILayout_StackDown( uiLayout );    \n\n            {\n                PrintState state = UI_PrintState_Init( uiContext, style, uiLayout.vCursor );        \n                uint strA[] = uint[] ( _C, _o, _h, _e, _s, _i, _o, _n, _COLON );\n                ARRAY_PRINT(state, style, strA);\n                UI_RenderFont( uiContext, state, style, renderStyle );\n                UILayout_SetControlRectFromText( uiLayout, state, style );\n            }\n            UILayout_SetX( uiLayout, tabX );\n            //UILayout_StackRight( uiLayout );\n            \n            UILayout_StackControlRect( uiLayout, UIStyle_SliderSize() );                \n            UI_ProcessSlider( uiContext, IDC_SLIDER_COHESION, uiData.cohesion, uiLayout.controlRect );\n            UILayout_StackRight( uiLayout );\n\n            {\n                PrintState state = UI_PrintState_Init( uiContext, style, uiLayout.vCursor );        \n\n                Print(state, style, uiData.cohesion.fValue, 2 );\n\n                UI_RenderFont( uiContext, state, style, renderStyle );\n\n                UILayout_SetControlRectFromText( uiLayout, state, style );\n            }\n            \n            UILayout_StackDown( uiLayout );  \n\n            {\n                PrintState state = UI_PrintState_Init( uiContext, style, uiLayout.vCursor );        \n                uint strA[] = uint[] ( _A, _l, _i, _g, _n, _m, _e, _n, _t, _COLON );\n                ARRAY_PRINT(state, style, strA);\n                UI_RenderFont( uiContext, state, style, renderStyle );\n                UILayout_SetControlRectFromText( uiLayout, state, style );\n            }\n            UILayout_SetX( uiLayout, tabX );\n            //UILayout_StackRight( uiLayout );\n            \n            UILayout_StackControlRect( uiLayout, UIStyle_SliderSize() );                \n            UI_ProcessSlider( uiContext, IDC_SLIDER_ALIGNMENT, uiData.alignment, uiLayout.controlRect );\n            UILayout_StackRight( uiLayout );\n\n            {\n                PrintState state = UI_PrintState_Init( uiContext, style, uiLayout.vCursor );        \n\n                Print(state, style, uiData.alignment.fValue, 2 );\n\n                UI_RenderFont( uiContext, state, style, renderStyle );\n\n                UILayout_SetControlRectFromText( uiLayout, state, style );\n            }\n\n            UILayout_StackDown( uiLayout );  \n\n            {\n                PrintState state = UI_PrintState_Init( uiContext, style, uiLayout.vCursor );        \n                uint strA[] = uint[] ( _C, _o, _u, _n, _t, _COLON );\n                ARRAY_PRINT(state, style, strA);\n                UI_RenderFont( uiContext, state, style, renderStyle );\n                UILayout_SetControlRectFromText( uiLayout, state, style );\n            }\n            UILayout_SetX( uiLayout, tabX );\n            //UILayout_StackRight( uiLayout );\n            \n            UILayout_StackControlRect( uiLayout, UIStyle_SliderSize() );                \n            UI_ProcessSlider( uiContext, IDC_SLIDER_COUNT, uiData.count, uiLayout.controlRect );\n            UILayout_StackRight( uiLayout );\n\n            {\n                PrintState state = UI_PrintState_Init( uiContext, style, uiLayout.vCursor );        \n\n                Print(state, style, uiData.count.fValue, 0 );\n\n                UI_RenderFont( uiContext, state, style, renderStyle );\n\n                UILayout_SetControlRectFromText( uiLayout, state, style );\n            }\n\n            UILayout_StackDown( uiLayout );  \n\n            {\n                PrintState state = UI_PrintState_Init( uiContext, style, uiLayout.vCursor );        \n                uint strA[] = uint[] ( _W, _a, _l, _l, _s, _COLON );\n                ARRAY_PRINT(state, style, strA);\n                UI_RenderFont( uiContext, state, style, renderStyle );\n                UILayout_SetControlRectFromText( uiLayout, state, style );\n            }\n            UILayout_SetX( uiLayout, tabX );\n            \n            UILayout_StackControlRect( uiLayout, UIStyle_CheckboxSize() );                \n            UI_ProcessCheckbox( uiContext, IDC_CHECKBOX_WALLS, uiData.walls, uiLayout.controlRect );         \n\n            UILayout_StackDown( uiLayout );  \n                        \n            #if 0\n            // Debug state\n            {\n                PrintState state = UI_PrintState_Init( uiContext, style, uiLayout.vCursor );\n                uint strA[] = uint[] ( _C, _t, _r, _l, _COLON );\n                ARRAY_PRINT(state, style, strA);\n\n                Print(state, style, uiContext.iActiveControl );\n                UI_RenderFont( uiContext, state, style, renderStyle );\n\n                UILayout_SetControlRectFromText( uiLayout, state, style );            \n            }\n            #endif\n        }        \n    }    \n    \n    UI_ProcessWindowCommonEnd( uiContext, window, iData );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    UIContext uiContext = UI_GetContext( fragCoord, DATA_UICONTEXT );\n        \n    UIData uiData = UI_GetControlData();\n    \n    // Content...\n    \n    if ( uiData.pageNo.fValue == 8.0 || uiData.pageNo.fValue == 9.0 )\n    {\n    \tUI_ProcessWindowMain( uiContext, uiData, IDC_WINDOW_CONTROLS, DATA_WINDOW_CONTROLS );\n    }\n    \n    // Desktop Controls...\n    {\n        LayoutStyle style;\n        RenderStyle renderStyle;             \n        UIStyle_GetFontStyleWindowText( style, renderStyle );       \n     \n        UILayout uiLayout = UILayout_Reset();\n                \n        /*{\n            PrintState state = UI_PrintState_Init( uiContext, style, uiLayout.vCursor );        \n            uint strA[] = uint[] ( _C, _o, _u, _n, _t, _COLON );\n            ARRAY_PRINT(state, style, strA);\n            UILayout_SetControlRectFromText( uiLayout, state, style );\n            UI_RenderFont( uiContext, state, style, renderStyle );\n        }*/\n        \n\t\tUILayout_StackControlRect( uiLayout, vec2(20,20) );                \n                       \n        bool nextPageButtonPressed = UI_ProcessButton( uiContext, IDC_BUTTON_NEXT_PAGE, uiLayout.controlRect ); // Get button position from prev control\n    }\n    \n    UI_ComposeWindowLayer( uiContext, 0.0f, uiContext.drawContext.clip );\n\n    uiData.fade.fValue -= 0.01;\n    if ( uiData.fade.fValue < 0.0 )\n    {\n        uiData.fade.fValue = 0.0;\n    }\n    \n    if ( KeyIsPressedDebounced( KEY_SPACE ) || KeyIsPressedDebounced( KEY_RIGHT ))\n    {\n        uiData.fade.fValue = 1.0;\n        uiData.pageNo.fValue += 1.0;\n    }\n\n    if ( KeyIsPressedDebounced( KEY_LEFT ))\n    {\n        uiData.fade.fValue = 0.0;\n        uiData.pageNo.fValue -= 1.0;\n    }\n    \n    uiData.pageNo.fValue = clamp( uiData.pageNo.fValue, 0.0, 10.0 );\n\n    if ( KeyIsPressedDebounced( KEY_UP ) )\n    {\n        uiData.count.fValue += 1.0;\n    }\n\n    if ( KeyIsPressedDebounced( KEY_DOWN ) )\n    {\n        uiData.count.fValue -= 1.0;\n    }\n    \n    uiData.count.fValue = clamp( uiData.count.fValue, uiData.count.fRangeMin, uiData.count.fRangeMax );\n    \n    UI_StoreControlData( uiContext, uiData );\n    \n    UI_StoreContext( uiContext, DATA_UICONTEXT );\n    \n    fragColor = UI_GetFinalColor( uiContext );    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Boids Simulation\n\n\n#define iChannelUI iChannel0\n#define iChannelSim iChannel1\n\n\n// ---------------------- 8< --------------------- 8< --------------------------\n\n///////////////////////////\n// UI Data\n///////////////////////////\n\nfloat UI_GetFloat( int iData )\n{\n    return texelFetch( iChannelUI, ivec2(iData,0), 0 ).x;\n}\n\nbool UI_GetBool( int iData )\n{\n    return UI_GetFloat( iData ) > 0.5;\n}\n\nvec3 UI_GetColor( int iData )\n{\n    return texelFetch( iChannelUI, ivec2(iData,0), 0 ).rgb;\n}\n\n\nvoid UI_Compose( vec2 fragCoord, inout vec3 vColor, out int windowId, out vec2 vWindowCoord )\n{\n    vec4 vUISample = texelFetch( iChannelUI, ivec2(fragCoord), 0 );\n    \n    if ( fragCoord.y < 2.0 )\n    {\n        // Hide data\n        vUISample = vec4(1.0, 1.0, 1.0, 1.0);\n    }\n    \n    vColor.rgb = vColor.rgb * (1.0f - vUISample.w) + vUISample.rgb;\n    \n    windowId = -1;\n    vWindowCoord = vec2(0);\n    \n    if ( vUISample.a < 0.0 )\n    {\n        vWindowCoord = vUISample.rg;\n        windowId = int(round(vUISample.b));\n    }\n}\n\n///////////////////////////\n// UI Data Definitions\n///////////////////////////\n\n// ---------------------- 8< --------------------- 8< --------------------------\n\nconst int\n     DATA_UICONTEXT\t\t\t\t\t\t= 0\n\t,DATA_WINDOW_CONTROLS   \t\t\t= 2\n    ,DATA_PAGE_NO\t\t\t\t\t\t= 4\n    ,DATA_FADE\t\t\t\t\t\t\t= 5\n\t,DATA_SEPARATION\t\t\t\t\t= 6\n\t,DATA_COHESION\t\t\t\t\t\t= 7\n\t,DATA_ALIGNMENT\t\t\t\t\t\t= 8\n    ,DATA_COUNT\t\t\t\t\t\t\t= 9\n    ,DATA_WALLS \t\t\t\t\t\t= 10\n    ;    \n\n// ---------------------- 8< --------------------- 8< --------------------------\n\n\n\n\n\n\n///////////////////////////\n// Common Code\n///////////////////////////\n\n// -------------- 8< -------------- 8< -------------- 8< -------------- 8< -------------- 8< --------------\n\n///////////////////////////\n// Data Storage\n///////////////////////////\n\nvec4 LoadVec4( sampler2D sampler, in ivec2 vAddr )\n{\n    return texelFetch( sampler, vAddr, 0 );\n}\n\nvec3 LoadVec3( sampler2D sampler, in ivec2 vAddr )\n{\n    return LoadVec4( sampler, vAddr ).xyz;\n}\n\nbool AtAddress( ivec2 p, ivec2 c ) { return all( equal( p, c ) ); }\n\nvoid StoreVec4( in ivec2 vAddr, in vec4 vValue, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in ivec2 vAddr, in vec3 vValue, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n///////////////////////////\n// Hash generation\n///////////////////////////\n\n// From Hash without Sine - by Dave Hoskins: https://www.shadertoy.com/view/4djSRW\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n// -------------- 8< -------------- 8< -------------- 8< -------------- 8< -------------- 8< --------------\n\nconst int MAX_BOID_COUNT = 400;\nconst vec3 WORLD_SIZE = vec3( 10 );\n\nfloat Scene_Distance( vec3 vPos )\n{\n    float fDist = 1000.0;\n    \n    float fInset = 0.3;\n    \n    // walls\n    fDist = min( fDist, vPos.x - fInset );\n    fDist = min( fDist, WORLD_SIZE.x - fInset - vPos.x );\n    fDist = min( fDist, vPos.z - fInset );\n    fDist = min( fDist, WORLD_SIZE.z - fInset - vPos.z );\n    \n    {\n        vec3 vRockPos = vec3(4, 0, 2);    \n        float fRockSize = 1.0;\n        float fRockDist = length( vPos - vRockPos ) - fRockSize;\n        fDist = min( fDist, fRockDist );\n    }\n\n    {\n        vec3 vRockPos = vec3(8, 0, 4);    \n        float fRockSize = 0.4;\n        float fRockDist = length( vPos - vRockPos ) - fRockSize;\n        fDist = min( fDist, fRockDist );\n    }\n\n    {\n        vec3 vRockPos = vec3(3, 0, 6);    \n        float fRockSize = 1.5;\n        float fRockDist = length( vPos - vRockPos ) - fRockSize;\n        fDist = min( fDist, fRockDist );\n    }\n    \n    return fDist + sin(vPos.x * 3.0) * 0.1 + sin(vPos.z * 3.0) * 0.1;\n}\n\nvec3 Scene_Normal( vec3 vPos )\n{\n    const float fDelta = 0.0001;\n    vec2 e = vec2( -1, 1 );\n    \n    vec3 vNormal = \n        Scene_Distance( e.yxx * fDelta + vPos ) * e.yxx + \n        Scene_Distance( e.xxy * fDelta + vPos ) * e.xxy + \n        Scene_Distance( e.xyx * fDelta + vPos ) * e.xyx + \n        Scene_Distance( e.yyy * fDelta + vPos ) * e.yyy;\n    \n    return normalize( vNormal );\n}  \n\nstruct Boid\n{\n    vec3 vPos;\n    vec3 vVel;\n    \n    vec3 vCohesionCentre; \t// only used for visualization\n    vec3 vSeparationSteer;\t// only used for visualization\n    vec3 vAlignmentDir; \t// only used for visualization\n};\n    \n\nBoid LoadBoid( int index )\n{\n    Boid boid;\n    boid.vPos = LoadVec3( iChannelSim, ivec2(index, 0) );    \n    boid.vVel = LoadVec3( iChannelSim, ivec2(index, 1) );    \n    boid.vCohesionCentre = LoadVec3( iChannelSim, ivec2(index, 2) );    \n    boid.vSeparationSteer = LoadVec3( iChannelSim, ivec2(index, 3) );    \n    boid.vAlignmentDir = LoadVec3( iChannelSim, ivec2(index, 4) );    \n    \n    return boid;\n}\n\nvoid StoreBoid( int index, Boid boid, inout vec4 fragColor, ivec2 fragCoord )\n{\n    StoreVec3( ivec2( index, 0), boid.vPos, fragColor, fragCoord );\n    StoreVec3( ivec2( index, 1), boid.vVel, fragColor, fragCoord );\n    StoreVec3( ivec2( index, 2), boid.vCohesionCentre, fragColor, fragCoord );\n    StoreVec3( ivec2( index, 3), boid.vSeparationSteer, fragColor, fragCoord );\n    StoreVec3( ivec2( index, 4), boid.vAlignmentDir, fragColor, fragCoord );\n}\n\nvoid ClampMagnitude( inout vec3 v, float fMinMag, float fMaxMag )\n{\n    float fMagnitude = clamp( length( v ), fMinMag, fMaxMag );\n    v = normalize( v ) * fMagnitude;\n}\n\nvoid ResetBoid( int index, inout Boid thisBoid )\n{\n    vec3 vHash = hash31( float( index ) );\n    thisBoid.vPos = vHash * 10.0;\n    thisBoid.vPos.y = 0.0;        \n    thisBoid.vVel = ( hash31( float( index + 123 ) ) * 2.0 - 1.0 ) * 0.1;\n    thisBoid.vVel.y = 0.0;\n}\n\nvoid UpdateBoid( int index, inout Boid thisBoid )\n{        \n    vec3 vSeparationSteering = vec3(0);\n    vec3 vCohesionSteering = vec3(0);\n    vec3 vAlignmentSteering = vec3(0);\n    vec3 vRandomSteering = vec3(0);\n    vec3 vCollisionAvoidSteering = vec3(0);\n\n    \n    float fSeparationDist = 0.75;\n    float fCohesionDist = 0.75;\n    float fAlignmentDist = 0.75;\n    float fCollisionAvoidDist = 1.0;\n    \n    float fCohesionWeight = 0.01 * UI_GetFloat( DATA_COHESION );\n    float fSeparationWeight = 0.0002 * UI_GetFloat( DATA_SEPARATION );\n    float fAlignmentWeight = 0.1 * UI_GetFloat( DATA_ALIGNMENT );\n    float fRandomWalkWeight = 0.002;\n    float fCollisionAvoidWeight = 0.001;\n\n\tfloat fMaxSteer = 0.01;    \n\n    float fMinSpeed = 0.03;\n    float fMaxSpeed = 0.1;\n    \n    bool bRestrictTo2d = true;\n    \n    thisBoid.vCohesionCentre = vec3(0);\n    float fCohesionCount = 0.0;\n    \n    thisBoid.vAlignmentDir = vec3(0);\n    float fAlignmentCount = 0.0;\n    \n    float boidCount = UI_GetFloat( DATA_COUNT );\n    for ( int iOtherIndex = 0; iOtherIndex < MAX_BOID_COUNT; iOtherIndex++ )\n    {\n        if ( iOtherIndex >= int(boidCount) )\n        {\n            break;\n        }\n     \n        // Don't consider ourself as neighbor\n        if ( index == iOtherIndex )\n        {\n            continue;        \n        }\n        \n        Boid otherBoid = LoadBoid( iOtherIndex );\n        \n        vec3 vToOther = otherBoid.vPos - thisBoid.vPos;\n        \n        // wrap world co-ordinates\n        vToOther = mod( vToOther + WORLD_SIZE * .5, WORLD_SIZE) - WORLD_SIZE * .5;        \n        vec3 vOtherPos = thisBoid.vPos + vToOther;\n        \n        float fDistToOther = length( vToOther );\n        vec3 vDirToOther = normalize(vToOther);\n                \n        if ( fDistToOther < fSeparationDist )\n        {\n            float fSeparationStrength = 1.0 / (fDistToOther * fDistToOther);\n            vSeparationSteering += -vDirToOther * fSeparationStrength;\n        }\n\n        if ( fDistToOther < fCohesionDist )\n        {\n            thisBoid.vCohesionCentre += vOtherPos;\n            fCohesionCount++;\n        }\n        \n        if ( fDistToOther < fAlignmentDist )\n        {\n            thisBoid.vAlignmentDir += otherBoid.vVel;\n            fAlignmentCount++;\n        }\n    }\n\n    if ( fCohesionCount > 0.0 )\n    {\n    \tthisBoid.vCohesionCentre = thisBoid.vCohesionCentre / fCohesionCount;\n    \tvCohesionSteering += thisBoid.vCohesionCentre - thisBoid.vPos;    \n    }\n\n    if ( fAlignmentCount > 0.0 )\n    {\n    \tthisBoid.vAlignmentDir = thisBoid.vAlignmentDir / fAlignmentCount;\n    \tvAlignmentSteering += thisBoid.vAlignmentDir - thisBoid.vVel; \n    }\n\n\tvRandomSteering = ( hash31( float( index ) + iTime ) * 2.0 - 1.0 );\n    \n    if ( UI_GetBool(DATA_WALLS) && UI_GetFloat(DATA_PAGE_NO) >= 8.0 )\n    {    \n        float fSceneDistance = Scene_Distance( thisBoid.vPos );\n        if ( fSceneDistance < fCollisionAvoidDist )\n        {\n            vec3 vNormal = Scene_Normal( thisBoid.vPos ); \n            float fDist = fSceneDistance/ fCollisionAvoidDist;\n            fDist = max( fDist, 0.01);\n            vCollisionAvoidSteering += vNormal / ( fDist );\n        }\n    }\n    \n    vec3 vSteer = vec3( 0 );\n    vSteer += vCohesionSteering * fCohesionWeight;\n    vSteer += vSeparationSteering * fSeparationWeight;\n    vSteer += vAlignmentSteering * fAlignmentWeight;\n    vSteer += vRandomSteering * fRandomWalkWeight;\n    vSteer += vCollisionAvoidSteering * fCollisionAvoidWeight;\n\n    thisBoid.vSeparationSteer = vSeparationSteering;\n    \n    if ( bRestrictTo2d )\n    {\n\t\tvSteer.y = 0.0;\n    }\n    \n    ClampMagnitude( vSteer, 0.0, 0.01 );\n    \n    thisBoid.vVel += vSteer;\n    \n    if ( bRestrictTo2d )\n    {\n\t\tthisBoid.vVel.y = 0.0;\n    }\n\n    ClampMagnitude( thisBoid.vVel, fMinSpeed, fMaxSpeed );\n        \n    // Move\n    \n    thisBoid.vPos += thisBoid.vVel;\n    if ( bRestrictTo2d )\n    {\n\t\tthisBoid.vPos.y = 0.0;\n    }\n    \n    thisBoid.vPos = mod(  thisBoid.vPos, WORLD_SIZE );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n    \n    if ( fragCoord.y > 5.0 )\n    {\n        discard;\n        return;\n    }    \n    \n    int index = int(fragCoord.x);\n    \n    Boid thisBoid = LoadBoid( index );\n    \n    if ( iFrame == 0 )\n    {\n        ResetBoid( index, thisBoid );\n    }\n    else\n    {\t\n    \tUpdateBoid( index, thisBoid );\n    }\n    \n    fragColor = vec4(0);    \n    \n    StoreBoid( index, thisBoid, fragColor, ivec2(fragCoord) );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Grid insertion\n// Add boids to grid to speed up rendering\n\n\n#define iChannelUI iChannel0\n#define iChannelSim iChannel1\n\n// ---------------------- 8< --------------------- 8< --------------------------\n\n///////////////////////////\n// UI Data\n///////////////////////////\n\nfloat UI_GetFloat( int iData )\n{\n    return texelFetch( iChannelUI, ivec2(iData,0), 0 ).x;\n}\n\nbool UI_GetBool( int iData )\n{\n    return UI_GetFloat( iData ) > 0.5;\n}\n\nvec3 UI_GetColor( int iData )\n{\n    return texelFetch( iChannelUI, ivec2(iData,0), 0 ).rgb;\n}\n\n\nvoid UI_Compose( vec2 fragCoord, inout vec3 vColor, out int windowId, out vec2 vWindowCoord )\n{\n    vec4 vUISample = texelFetch( iChannelUI, ivec2(fragCoord), 0 );\n    \n    if ( fragCoord.y < 2.0 )\n    {\n        // Hide data\n        vUISample = vec4(1.0, 1.0, 1.0, 1.0);\n    }\n    \n    vColor.rgb = vColor.rgb * (1.0f - vUISample.w) + vUISample.rgb;\n    \n    windowId = -1;\n    vWindowCoord = vec2(0);\n    \n    if ( vUISample.a < 0.0 )\n    {\n        vWindowCoord = vUISample.rg;\n        windowId = int(round(vUISample.b));\n    }\n}\n\n///////////////////////////\n// UI Data Definitions\n///////////////////////////\n\n// ---------------------- 8< --------------------- 8< --------------------------\n\nconst int\n     DATA_UICONTEXT\t\t\t\t\t\t= 0\n\t,DATA_WINDOW_CONTROLS   \t\t\t= 2\n    ,DATA_PAGE_NO\t\t\t\t\t\t= 4\n    ,DATA_FADE\t\t\t\t\t\t\t= 5\n\t,DATA_SEPARATION\t\t\t\t\t= 6\n\t,DATA_COHESION\t\t\t\t\t\t= 7\n\t,DATA_ALIGNMENT\t\t\t\t\t\t= 8\n    ,DATA_COUNT\t\t\t\t\t\t\t= 9\n    ,DATA_WALLS \t\t\t\t\t\t= 10\n    ;    \n\n// ---------------------- 8< --------------------- 8< --------------------------\n\n\n\n\n\n\n///////////////////////////\n// Common Code\n///////////////////////////\n\n// -------------- 8< -------------- 8< -------------- 8< -------------- 8< -------------- 8< --------------\n\n///////////////////////////\n// Data Storage\n///////////////////////////\n\nvec4 LoadVec4( sampler2D sampler, in ivec2 vAddr )\n{\n    return texelFetch( sampler, vAddr, 0 );\n}\n\nvec3 LoadVec3( sampler2D sampler, in ivec2 vAddr )\n{\n    return LoadVec4( sampler, vAddr ).xyz;\n}\n\nbool AtAddress( ivec2 p, ivec2 c ) { return all( equal( p, c ) ); }\n\nvoid StoreVec4( in ivec2 vAddr, in vec4 vValue, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in ivec2 vAddr, in vec3 vValue, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n///////////////////////////\n// Hash generation\n///////////////////////////\n\n// From Hash without Sine - by Dave Hoskins: https://www.shadertoy.com/view/4djSRW\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n// -------------- 8< -------------- 8< -------------- 8< -------------- 8< -------------- 8< --------------\n\nconst int MAX_BOID_COUNT = 400;\nconst vec3 WORLD_SIZE = vec3( 10 );\nconst ivec2 GRID_SIZE = ivec2( 100 );\n\nfloat Scene_Distance( vec3 vPos )\n{\n    float fDist = 1000.0;\n    \n    float fInset = 0.3;\n    \n    // walls\n    fDist = min( fDist, vPos.x - fInset );\n    fDist = min( fDist, WORLD_SIZE.x - fInset - vPos.x );\n    fDist = min( fDist, vPos.z - fInset );\n    fDist = min( fDist, WORLD_SIZE.z - fInset - vPos.z );\n    \n    {\n        vec3 vRockPos = vec3(4, 0, 2);    \n        float fRockSize = 1.0;\n        float fRockDist = length( vPos - vRockPos ) - fRockSize;\n        fDist = min( fDist, fRockDist );\n    }\n\n    {\n        vec3 vRockPos = vec3(8, 0, 4);    \n        float fRockSize = 0.4;\n        float fRockDist = length( vPos - vRockPos ) - fRockSize;\n        fDist = min( fDist, fRockDist );\n    }\n\n    {\n        vec3 vRockPos = vec3(3, 0, 6);    \n        float fRockSize = 1.5;\n        float fRockDist = length( vPos - vRockPos ) - fRockSize;\n        fDist = min( fDist, fRockDist );\n    }\n    \n    return fDist + sin(vPos.x * 3.0) * 0.1 + sin(vPos.z * 3.0) * 0.1;\n}\n\nvec3 Scene_Normal( vec3 vPos )\n{\n    const float fDelta = 0.0001;\n    vec2 e = vec2( -1, 1 );\n    \n    vec3 vNormal = \n        Scene_Distance( e.yxx * fDelta + vPos ) * e.yxx + \n        Scene_Distance( e.xxy * fDelta + vPos ) * e.xxy + \n        Scene_Distance( e.xyx * fDelta + vPos ) * e.xyx + \n        Scene_Distance( e.yyy * fDelta + vPos ) * e.yyy;\n    \n    return normalize( vNormal );\n}  \n\nstruct Boid\n{\n    vec3 vPos;\n    vec3 vVel;\n    \n    vec3 vCohesionCentre; \t// only used for visualization\n    vec3 vSeparationSteer;\t// only used for visualization\n    vec3 vAlignmentDir; \t// only used for visualization\n};\n    \n\nBoid LoadBoid( int index )\n{\n    Boid boid;\n    boid.vPos = LoadVec3( iChannelSim, ivec2(index, 0) );    \n    boid.vVel = LoadVec3( iChannelSim, ivec2(index, 1) );    \n    boid.vCohesionCentre = LoadVec3( iChannelSim, ivec2(index, 2) );    \n    boid.vSeparationSteer = LoadVec3( iChannelSim, ivec2(index, 3) );    \n    boid.vAlignmentDir = LoadVec3( iChannelSim, ivec2(index, 4) );    \n    \n    return boid;\n}\n\nvoid StoreBoid( int index, Boid boid, inout vec4 fragColor, ivec2 fragCoord )\n{\n    StoreVec3( ivec2( index, 0), boid.vPos, fragColor, fragCoord );\n    StoreVec3( ivec2( index, 1), boid.vVel, fragColor, fragCoord );\n    StoreVec3( ivec2( index, 2), boid.vCohesionCentre, fragColor, fragCoord );\n    StoreVec3( ivec2( index, 3), boid.vSeparationSteer, fragColor, fragCoord );\n    StoreVec3( ivec2( index, 4), boid.vAlignmentDir, fragColor, fragCoord );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iFragIndex = ivec2(fragCoord);\n    ivec2 iGridPos = iFragIndex;\n    \n    if ( any( greaterThanEqual( iGridPos, GRID_SIZE ) ) )\n    {\n        discard;\n        return;\n    }\n\n    // get centre of grid cell\n    vec2 cellCentre = ((vec2(iGridPos) + 0.5) / vec2(GRID_SIZE)) * WORLD_SIZE.xz;\n    \n    vec2 vCellSize = WORLD_SIZE.xz / vec2(GRID_SIZE);\n    float cellSize = sqrt(dot(vCellSize,vCellSize)) + 0.1;\n    \n    const int MAX_BOIDS_PER_CELL = 4;\n    int cellBoids[MAX_BOIDS_PER_CELL];\n    \n    cellBoids[0] = -1;\n    cellBoids[1] = -1;\n    cellBoids[2] = -1;\n    cellBoids[3] = -1;\n    \n    int cellBoidCount = 0;\n    \n    float boidCount = UI_GetFloat( DATA_COUNT );\n    \n    for ( int index = 0; index < MAX_BOID_COUNT; index++ )\n    {\n        if ( index >= int(boidCount) )\n        {\n            break;\n        }\n        \n        if( cellBoidCount >= MAX_BOIDS_PER_CELL )\n        {\n            break;\n        }\n        \n        Boid currBoid = LoadBoid( index );\n\n        vec2 vOffset = currBoid.vPos.xz - cellCentre;\n        vOffset += WORLD_SIZE.xz / 2.0;\n        vOffset = mod(vOffset, WORLD_SIZE.xz);\n        vOffset -= WORLD_SIZE.xz / 2.0;\n        \n        float dist = length( vOffset );\n        if ( dist < cellSize )\n        {\n            cellBoids[cellBoidCount] = index;\n            cellBoidCount++;\n        }\n        \n    }    \n    \n    fragColor = vec4( cellBoids[0], cellBoids[1], cellBoids[2], cellBoids[3] );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Scene Rendering & Diagrams\n\n\n#define iChannelUI iChannel0\n#define iChannelSim iChannel1\n#define iChannelGrid iChannel2\n\n\n// ---------------------- 8< --------------------- 8< --------------------------\n\n///////////////////////////\n// UI Data\n///////////////////////////\n\nfloat UI_GetFloat( int iData )\n{\n    return texelFetch( iChannelUI, ivec2(iData,0), 0 ).x;\n}\n\nbool UI_GetBool( int iData )\n{\n    return UI_GetFloat( iData ) > 0.5;\n}\n\nvec3 UI_GetColor( int iData )\n{\n    return texelFetch( iChannelUI, ivec2(iData,0), 0 ).rgb;\n}\n\n\nvoid UI_Compose( vec2 fragCoord, inout vec3 vColor, out int windowId, out vec2 vWindowCoord )\n{\n    vec4 vUISample = texelFetch( iChannelUI, ivec2(fragCoord), 0 );\n    \n    if ( fragCoord.y < 2.0 )\n    {\n        // Hide data\n        vUISample = vec4(1.0, 1.0, 1.0, 1.0);\n    }\n    \n    vColor.rgb = vColor.rgb * (1.0f - vUISample.w) + vUISample.rgb;\n    \n    windowId = -1;\n    vWindowCoord = vec2(0);\n    \n    if ( vUISample.a < 0.0 )\n    {\n        vWindowCoord = vUISample.rg;\n        windowId = int(round(vUISample.b));\n    }\n}\n\n///////////////////////////\n// UI Data Definitions\n///////////////////////////\n\n// ---------------------- 8< --------------------- 8< --------------------------\n\nconst int\n     DATA_UICONTEXT\t\t\t\t\t\t= 0\n\t,DATA_WINDOW_CONTROLS   \t\t\t= 2\n    ,DATA_PAGE_NO\t\t\t\t\t\t= 4\n    ,DATA_FADE\t\t\t\t\t\t\t= 5\n\t,DATA_SEPARATION\t\t\t\t\t= 6\n\t,DATA_COHESION\t\t\t\t\t\t= 7\n\t,DATA_ALIGNMENT\t\t\t\t\t\t= 8\n    ,DATA_COUNT\t\t\t\t\t\t\t= 9\n    ,DATA_WALLS \t\t\t\t\t\t= 10\n    ;    \n\n// ---------------------- 8< --------------------- 8< --------------------------\n\n\n\n\n\n\n///////////////////////////\n// Common Code\n///////////////////////////\n\n// -------------- 8< -------------- 8< -------------- 8< -------------- 8< -------------- 8< --------------\n\n///////////////////////////\n// Data Storage\n///////////////////////////\n\nvec4 LoadVec4( sampler2D sampler, in ivec2 vAddr )\n{\n    return texelFetch( sampler, vAddr, 0 );\n}\n\nvec3 LoadVec3( sampler2D sampler, in ivec2 vAddr )\n{\n    return LoadVec4( sampler, vAddr ).xyz;\n}\n\nbool AtAddress( ivec2 p, ivec2 c ) { return all( equal( p, c ) ); }\n\nvoid StoreVec4( in ivec2 vAddr, in vec4 vValue, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in ivec2 vAddr, in vec3 vValue, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n\n// -------------- 8< -------------- 8< -------------- 8< -------------- 8< -------------- 8< --------------\n\nconst int MAX_BOID_COUNT = 400;\nconst vec3 WORLD_SIZE = vec3( 10 );\nconst ivec2 GRID_SIZE = ivec2( 100 );\n\n\nfloat Scene_Distance( vec3 vPos )\n{\n    float fDist = 1000.0;\n    \n    float fInset = 0.3;\n    \n    // walls\n    fDist = min( fDist, vPos.x - fInset );\n    fDist = min( fDist, WORLD_SIZE.x - fInset - vPos.x );\n    fDist = min( fDist, vPos.z - fInset );\n    fDist = min( fDist, WORLD_SIZE.z - fInset - vPos.z );\n    \n    {\n        vec3 vRockPos = vec3(4, 0, 2);    \n        float fRockSize = 1.0;\n        float fRockDist = length( vPos - vRockPos ) - fRockSize;\n        fDist = min( fDist, fRockDist );\n    }\n\n    {\n        vec3 vRockPos = vec3(8, 0, 4);    \n        float fRockSize = 0.4;\n        float fRockDist = length( vPos - vRockPos ) - fRockSize;\n        fDist = min( fDist, fRockDist );\n    }\n\n    {\n        vec3 vRockPos = vec3(3, 0, 6);    \n        float fRockSize = 1.5;\n        float fRockDist = length( vPos - vRockPos ) - fRockSize;\n        fDist = min( fDist, fRockDist );\n    }\n    \n    return fDist + sin(vPos.x * 3.0) * 0.1 + sin(vPos.z * 3.0) * 0.1;\n}\n\nstruct Boid\n{\n    vec3 vPos;\n    vec3 vVel;\n    \n    vec3 vCohesionCentre; \t// just used for visualization\n    vec3 vSeparationSteer;\t// just used for visualization\n    vec3 vAlignmentDir; \t// just used for visualization\n};\n    \n\nBoid LoadBoid( int index )\n{\n    Boid boid;\n    boid.vPos = LoadVec3( iChannelSim, ivec2(index, 0) );    \n    boid.vVel = LoadVec3( iChannelSim, ivec2(index, 1) );    \n    boid.vCohesionCentre = LoadVec3( iChannelSim, ivec2(index, 2) );    \n    boid.vSeparationSteer = LoadVec3( iChannelSim, ivec2(index, 3) );    \n    boid.vAlignmentDir = LoadVec3( iChannelSim, ivec2(index, 4) );    \n    \n    return boid;\n}\n\nvoid StoreBoid( int index, Boid boid, inout vec4 fragColor, ivec2 fragCoord )\n{\n    StoreVec3( ivec2( index, 0), boid.vPos, fragColor, fragCoord );\n    StoreVec3( ivec2( index, 1), boid.vVel, fragColor, fragCoord );\n    StoreVec3( ivec2( index, 2), boid.vCohesionCentre, fragColor, fragCoord );\n    StoreVec3( ivec2( index, 3), boid.vSeparationSteer, fragColor, fragCoord );\n    StoreVec3( ivec2( index, 4), boid.vAlignmentDir, fragColor, fragCoord );\n}\n\nfloat DrawCircle( vec2 vPos, vec2 vOrigin, float fRadius, float fThickness )\n{    \n    float fCircleDist = length( vOrigin - vPos ) - fRadius;\n    float fCircle = clamp( 1.0 - abs(fCircleDist) / fThickness, 0.0, 1.0 );    \n    return fCircle;\n}\n\nfloat DrawLine( vec2 vPos, vec2 vA, vec2 vB, float fThickness )\n{    \n    vec2 vOffset = vPos- vA;\n    vec2 vAB = vB - vA;\n    vec2 vDir = normalize( vAB );\n    float fLength = length( vAB );\n    \n    float fProj = clamp( dot( vOffset, vDir ) / fLength, 0.0, 1.0 );\n    \n    vec2 vClosest = vA + vDir * fProj * fLength;\n    \n    float fLine = clamp( 1.0 - length( vClosest - vPos ) / fThickness, 0.0, 1.0 );\n    return fLine;\n}\n\nfloat DrawArrowhead( vec2 vPos, vec2 vStart, vec2 vDir, float fSize, float fThickness )\n{    \n    vDir = normalize( vDir );    \n    vec2 vPerp = vec2( vDir.y, -vDir.x );\n    \n    vec2 vEndA = vStart + vDir * fSize + vPerp * fSize * .5;\n    vec2 vEndB = vStart + vDir * fSize - vPerp * fSize * .5;\n    \n    float fArrow = DrawLine( vPos, vStart, vEndA, fThickness );\n    fArrow = max( fArrow, DrawLine( vPos, vStart, vEndB, fThickness ) );\n    \n    return fArrow;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    vec2 vScreenUV = fragCoord.xy / iResolution.xy;\n    \n    vec3 vResult = mix( vec3(0.5, 0.6, 0.9), vec3(0.25, 0.3, 0.9), vScreenUV.y );\n\n    vec2 vUV  = vScreenUV;\n    vUV -= 0.5;\n    vUV.x *= iResolution.x / iResolution.y;\n    vUV = vUV;\n    \n    float fZoom = 1.0;\n    vec3 vTarget = WORLD_SIZE * 0.5;\n\n    bool bDrawCohesionForce = false;\n    bool bDrawSeaparationForce = false;\n    bool bDrawAlignmentForce = false;\n    \n    bool bDrawCollision = false;\n    \n    float fCircleRadius = 0.0;\n    \n    float fade = UI_GetFloat(DATA_FADE);\n    \n    int pageNo = int( UI_GetFloat(DATA_PAGE_NO) );\n    int targetBoidIndex = -1;\n    \n    float fTargetFactor = 0.0;\n    \n    if ( pageNo == 2 )\n    {\n        fTargetFactor = 1.0f;//(1.0 - fade);\n        targetBoidIndex = 0;\n    }\n    if ( pageNo == 3 )\n    {\n        fTargetFactor = 1.0f;//(1.0 - fade);\n        targetBoidIndex = 0;\n        \n        fCircleRadius = 0.75;\n    }\n    if ( pageNo == 4 )\n    {\n        bDrawSeaparationForce = true;\n        fTargetFactor = 1.0;\n        targetBoidIndex = 0;\n    }\n    if ( pageNo == 5 )\n    {\n        fTargetFactor = 1.0f;//(1.0 - fade);\n        bDrawCohesionForce = true;\n        targetBoidIndex = 0;\n    }\n    if ( pageNo == 6 )\n    {\n        bDrawAlignmentForce = true;\n        fTargetFactor = 1.0;\n        targetBoidIndex = 0;\n    }\n    if ( pageNo == 7 )\n    {\n        fTargetFactor = 0.0;\n    }\n\n    if ( pageNo >= 8 )\n    {\n        bDrawCollision = UI_GetBool(DATA_WALLS);\n    }\n    \n    Boid targetBoid = LoadBoid( targetBoidIndex );\n    if ( fTargetFactor > 0.0 )\n    {\n        float fTargetFactor2 = smoothstep( 0.0, 1.0, fTargetFactor * 4.0 );\n        vec3 vTarget2 = targetBoid.vPos;\n        vTarget2.x -= 1.0;\n        vTarget2.z += 0.4;\n    \tvTarget = mix( vTarget, vTarget2, fTargetFactor2 );\n        fZoom = 1.0 + smoothstep( 0.0, 1.0, fTargetFactor ) * 3.0;\n    }\n\n    \n    float fLineThickness = 10.0 / fZoom / iResolution.y;\n    float fArrowSize = 0.05;\n        \n    vec3 vPos = vec3( vUV.x, 0.0, vUV.y ) * WORLD_SIZE;\n    \n    vPos /= fZoom;\n    \n    vPos += vTarget;\n    vPos.y = 0.0f;\n        \n    if ( bDrawCollision )\n    {\n    \tfloat fDist = Scene_Distance( vPos );\n        \n        if ( fDist < 0.0 )\n        {\n            float fBlend = smoothstep( 0.0, 1.0, -fDist );\n            vResult = mix( vec3(0.4, 0.3, 0.1), vec3(0.2, 0.0, 0.0), fBlend );\n        }           \n    }\n    \n    \n    vec3 vCircleOrigin = targetBoid.vPos;\n    \n    vec3 vLineTarget = vec3(0);\n    \n    if ( bDrawCohesionForce )\n    {\n    \tvLineTarget = targetBoid.vCohesionCentre;\n        fCircleRadius = 0.75;\n    }\n    \n    if ( bDrawSeaparationForce )\n    {\n    \tvLineTarget = targetBoid.vPos;\n        fCircleRadius = 0.75;\n    }\n    \n    if ( bDrawAlignmentForce )\n    {\n    \tvLineTarget = targetBoid.vPos;\n        fCircleRadius = 0.75;\n    }\n    \n\tvLineTarget = mod( vLineTarget - vTarget + WORLD_SIZE * 0.5, WORLD_SIZE ) + vTarget - WORLD_SIZE * 0.5;\n    \n    vec3 vForceColor = vec3(.5,0,0);\n    \n    float boidCount = UI_GetFloat( DATA_COUNT );\n    \n    ivec2 vGridCell = ivec2( vec2(GRID_SIZE) * mod(vPos.xz, WORLD_SIZE.xz) / WORLD_SIZE.xz );\n    vec4 cellBoids = texelFetch( iChannelGrid, vGridCell, 0 );\n    \n\n    float fTargetCircleDist = length( vPos.xz - vCircleOrigin.xz );\n    float fTextureFactor = clamp( 1.0 - ( fTargetCircleDist - 0.75 ), 0.0, 1.0);\n        \n    if ( fTargetFactor == 0.0 )\n        fTextureFactor = 1.0;\n    vResult *= 1.0 - textureLod( iChannel3, vPos.xz / 10.0, 0.0 ).xyz * 0.15 * fTextureFactor;\n        \n    \n    if ( bDrawCohesionForce || bDrawSeaparationForce || bDrawAlignmentForce )\n    {\n        // only do complex per-boid rendering near circle\n        if ( fTargetCircleDist < (fCircleRadius + 0.2) )\n        {\n            for ( int index = 0; index < MAX_BOID_COUNT; index++ )\n            {\n                if ( index >= int(boidCount) )\n                {\n                    break;\n                }\n\n\n                Boid currBoid = LoadBoid( index );\n\n                // Wrap world\n                currBoid.vPos = mod( currBoid.vPos - vTarget + WORLD_SIZE * 0.5, WORLD_SIZE ) + vTarget - WORLD_SIZE * 0.5;\n\n                currBoid.vPos.y = 0.0f;\n                currBoid.vVel.y = 0.0f;\n\n                vec3 vDir = normalize( currBoid.vVel );\n\n                vec3 vBoidWorldOffset = vPos - currBoid.vPos;\n\n                float fDistToBoid = length( vBoidWorldOffset );\n\n                float fDot = dot( vBoidWorldOffset, vDir );\n\n                vec3 vClosest = currBoid.vPos + fDot * vDir;\n\n                float fClosestDist = length( vClosest - vPos );\n                float fCurrDist = fClosestDist * 0.5 / abs(fDot-0.1);\n                fCurrDist = max( fCurrDist, fDistToBoid );\n\n                float fCircleDist = length( vCircleOrigin - currBoid.vPos );\n                bool inCircle = fCircleDist < fCircleRadius;\n\n                if ( bDrawCohesionForce || bDrawSeaparationForce )\n                {\n                    if ( inCircle )\n                    {\n                        if ( index != targetBoidIndex )\n                        {\n                            float fLine = DrawLine( vPos.xz, vLineTarget.xz, currBoid.vPos.xz, fLineThickness);\n                            vResult = mix( vResult, vec3(0.3, 0.3, 0.3), fLine );\n                        }\n                    }\n                }\n\n                if ( bDrawAlignmentForce )\n                {\n                    if ( inCircle )\n                    {\n                        if ( index != targetBoidIndex )\n                        {\n                            vec3 vArrowStart = currBoid.vPos;\n                            vec3 vArrowEnd = vArrowStart + currBoid.vVel * 5.0;\n                            vec3 vDir = vArrowEnd - vArrowStart;\n\n                            float fArrow = DrawLine( vPos.xz, vArrowStart.xz, vArrowEnd.xz, fLineThickness);\n                            fArrow = max( fArrow, DrawArrowhead( vPos.xz, vArrowEnd.xz, -vDir.xz, fArrowSize, fLineThickness ) );\n                            vResult = mix( vResult, vec3(0.0, 0.0, 1.0), fArrow );\n                        }\n                    }\n                }\n\n\n            }\n        }\n    }\n\n    for ( int cellBoidIndex=0; cellBoidIndex < 4; cellBoidIndex++ )\n    {\n        int index = int(cellBoids[cellBoidIndex]);\n        if ( index < 0 )\n            continue;\n        \n        Boid currBoid = LoadBoid( index );\n\n        // Wrap world\n        currBoid.vPos = mod( currBoid.vPos - vTarget + WORLD_SIZE * 0.5, WORLD_SIZE ) + vTarget - WORLD_SIZE * 0.5;\n        \n        currBoid.vPos.y = 0.0f;\n        currBoid.vVel.y = 0.0f;\n        \n        vec3 vDir = normalize( currBoid.vVel );\n        \n        vec3 vBoidWorldOffset = vPos - currBoid.vPos;\n        \n        float fDistToBoid = length( vBoidWorldOffset );\n\n        float fDot = dot( vBoidWorldOffset, vDir );\n\n        vec3 vClosest = currBoid.vPos + fDot * vDir;\n\n        float fClosestDist = length( vClosest - vPos );\n        float fCurrDist = fClosestDist * 0.5 / abs(fDot-0.1);\n        fCurrDist = max( fCurrDist, fDistToBoid );\n\n        float fCircleDist = length( vCircleOrigin - currBoid.vPos );\n        bool inCircle = fCircleDist < fCircleRadius;\n\n        if ( fCurrDist < 0.1 )\n        {\n            if ( index == targetBoidIndex )\n            {\n                vResult = vec3(0.1, 0.4, 0.0);\n            }\n            else\n            if ( inCircle )\n            {\n                vResult = vec3(0.1, 0.1, 0.6);                                    \n            }\n            else\n            {\n                vResult = vec3(0.2, 0.2, 0.2);                    \n            }\n        }            \n    }\n\n    if ( fCircleRadius > 0.0 )\n    {\n\t\tfloat fCircle = DrawCircle( vPos.xz, vCircleOrigin.xz, fCircleRadius, fLineThickness );    \n    \tvResult = mix( vResult, vec3(0.5, 0.2, 0.0), fCircle );\n    }\n        \n    if ( bDrawCohesionForce )\n    {\n        float fLine = DrawLine( vPos.xz, vLineTarget.xz, targetBoid.vPos.xz, fLineThickness);\n        vResult = mix( vResult, vForceColor, fLine );\n\n        vec3 vArrowPos = vLineTarget;\n        vec3 vDir = targetBoid.vPos - vLineTarget;\n        float fArrow = DrawArrowhead( vPos.xz, vArrowPos.xz, vDir.xz, fArrowSize, fLineThickness );\n        vResult = mix( vResult, vForceColor, fArrow );\n\t}\n    \n                \n    if ( bDrawSeaparationForce )\n    {\n        vec3 vDir = targetBoid.vSeparationSteer;\n\n        vec3 vArrowStart = targetBoid.vPos;\n        vec3 vArrowEnd = vArrowStart + vDir * 0.02;\n\n        float fArrow = DrawLine( vPos.xz, vArrowStart.xz, vArrowEnd.xz, fLineThickness);\n        fArrow = max( fArrow, DrawArrowhead( vPos.xz, vArrowEnd.xz, -vDir.xz, fArrowSize, fLineThickness ) );\n        vResult = mix( vResult, vForceColor, fArrow );\n    }\n    \n    if ( bDrawAlignmentForce )\n    {\n        {\n            vec3 vArrowStart = targetBoid.vPos;\n            vec3 vArrowEnd = vArrowStart + targetBoid.vVel * 5.0;\n            vec3 vDir = vArrowEnd - vArrowStart;\n\n            float fArrow = DrawLine( vPos.xz, vArrowStart.xz, vArrowEnd.xz, fLineThickness);\n            fArrow = max( fArrow, DrawArrowhead( vPos.xz, vArrowEnd.xz, -vDir.xz, fArrowSize, fLineThickness ) );\n            vResult = mix( vResult, vec3(0.0, 0.8, 0.0), fArrow );        \n        }\n\n        {\n            vec3 vArrowStart = targetBoid.vPos;\n            vec3 vArrowEnd = vArrowStart + targetBoid.vAlignmentDir * 5.0;\n            vec3 vDir = vArrowEnd - vArrowStart;\n\n            float fArrow = DrawLine( vPos.xz, vArrowStart.xz, vArrowEnd.xz, fLineThickness);\n            fArrow = max( fArrow, DrawArrowhead( vPos.xz, vArrowEnd.xz, -vDir.xz, fArrowSize, fLineThickness ) );\n            vResult = mix( vResult, vec3(0.0, 0.0, 1.0), fArrow );        \n        }\n        \n        {\n            vec3 vArrowStart = targetBoid.vPos;\n            vec3 vArrowEnd = vArrowStart + (targetBoid.vAlignmentDir - targetBoid.vVel) * 20.0;\n            vec3 vDir = vArrowEnd - vArrowStart;\n\n            float fArrow = DrawLine( vPos.xz, vArrowStart.xz, vArrowEnd.xz, fLineThickness);\n            fArrow = max( fArrow, DrawArrowhead( vPos.xz, vArrowEnd.xz, -vDir.xz, fArrowSize, fLineThickness ) );\n            vResult = mix( vResult, vForceColor, fArrow );        \n        }        \n    }    \n        \n    fragColor = vec4( vResult, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}