{
    "Shader": {
        "info": {
            "date": "1505935688",
            "description": "Some more clouds. Pretty slow.",
            "flags": 0,
            "hasliked": 0,
            "id": "MtXcRl",
            "likes": 6,
            "name": "AlexM Cloud Test 2",
            "published": 3,
            "tags": [
                "clouds"
            ],
            "usePreview": 0,
            "username": "AlexM",
            "viewed": 848
        },
        "renderpass": [
            {
                "code": "// Trying some more clouds. These are really expensive.\n// Some artifacts when entering the cloud volume - samples on the horizon become \n// slightly darker than they are supposed to be. Also some banding when inside the volume.\n// I am guessing it could be improved by taking variable number of samples or \n//something like that. Will take a look again once I have more free time. \n// I am also going to add some explanation about what I am doing later... so that\n// I don't forget myself. \n#define PI 3.141592653589793 \n\nconst float MAXT = 180.0f;\nconst float FOGHEIGHT = 0.40; // background fog height. \nconst float FOGFADEHEIGHT = 0.60; // background fog fade height - fades background fog into actual sky.\nconst vec3  FOGCOLOR = vec3(1, 0.878, 0.721);\nconst float FOGDENSITY = 0.0080; \nconst float FOGPOWER = 3.5;\n\nconst vec3  SUNDIRECTION = normalize(vec3(0.0, -1.00, -1.0)); //direction of the sunlight\nconst vec3  SUNCOLOR =vec3(0.949, 0.741, 0.470); // sun color? \nconst vec3  SKYCOLOR = vec3(1, 0.760, 0.521);\n\n// colors for scene objects...\nconst vec3 TILE1_COLOR  = vec3(0.6);\nconst vec3 TILE2_COLOR  = vec3(0.8);\n\nconst vec3 CLOUD_AMBIENT_COLOR = vec3(1.0, 0.833, 0.856); \n\n// number of cloud samples. When sampling light, less samples are used, and that \n// number is just numsteps*light_multiplier. \nconst float CLOUDTRACE_NUMSTEPS = 40.0; \nconst float CLOUDTRACE_LIGHT_MULTIPLIER = 0.25; \n\nconst float CLOUD_EXTINCTION = 1.20;\nconst float CLOUD_SCATTERING = 0.17;\n\n// cloud low and high planes. LO < HI.\nconst float CLOUD_Y_LO = -6.0;\nconst float CLOUD_Y_HI =  0.0;\n\nstruct TraceResult {\n    bool  hit;\n    float rayt;\n};\n\n// transformation funcs\nmat3 rotateY(float n) {\n    float a = cos(n);\n    float b = sin(n);\n    return mat3( a, 0.0, b, 0.0, 1.0, 0.0, -b, 0.0, a );\n}\n\nmat3 rotateX(float n) {\n    float a = cos(n);\n    float b = sin(n);\n    return mat3( 1.0, 0.0, 0.0, 0.0, a, -b, 0.0, b, a );\n}\n\nmat3 rotateZ(float n) {\n    float a = cos(n);\n    float b = sin(n);\n    return mat3(a, -b, 0.0, b, a, 0.0, 0.0, 0.0, 1.0);\n}\n\nfloat random(in vec3 st) { \n    return fract(sin(dot(st,vec3(12.9898,78.233,19.124)))*43758.5453);\n}\n\nfloat noise(in vec3 st) {\n    vec3 i = floor(st);\n    vec3 x = fract(st);\n    vec3 u = x*x*(3.0-2.0*x);\n\n    float a = random(i);\n    float b = random(i + vec3(1.0, 0.0, 0.0));\n    float c = random(i + vec3(0.0, 1.0, 0.0));\n    float d = random(i + vec3(1.0, 1.0, 0.0));\n    float e = random(i + vec3(0.0, 0.0, 1.0));\n    float f = random(i + vec3(1.0, 0.0, 1.0));\n    float g = random(i + vec3(0.0, 1.0, 1.0));\n    float h = random(i + vec3(1.0, 1.0, 1.0));\n    float fa = mix(a, b, u.x);\n    float fb = mix(c, d, u.x);\n    float fc = mix(e, f, u.x);\n    float fd = mix(g, h, u.x);\n    float fe = mix(fa, fb, u.y);\n    float ff = mix(fc, fd, u.y);\n    float fg = mix(fe, ff, u.z);\n    float ret = clamp(2.0*fg-1.0, -1.0, 1.0);\n    return (ret < 0.0) ? 0.0: ret;\n}\n\n\nfloat fbm(vec3 p) {\n    float f = 0.0;\n    float a = 0.5;\n    f += a*noise(p); p*=1.25; a *= 0.5;\n    f += a*noise(p); p*=2.00; a *= 0.5;\n    f += a*noise(p); p*=5.50; a *= 0.5;\n    f += a*noise(p); \n    return f;\n}\n\n// cloud density func\nfloat getCloudDensity(vec3 p) {\n    float f = fbm(p*0.05+iTime*0.075);\n    float a = (p.y >= CLOUD_Y_LO && p.y <= CLOUD_Y_HI) ? 1.0: 0.0;\n    return a*f;\n}\n\n\n// horizonal plane intersection test. \nfloat hPlaneIntersection(vec3 ro, vec3 rd, float y) {\n    vec3 n = vec3(0.0, 1.0, 0.0);\n    vec3 p0 = vec3(0.0, y, 0.0);\n\n    float denom = dot(rd, n); \n    if (denom == 0.0) return -1.0; // parallel to the plane \n    float num = dot(p0-ro, n);\n    return num/denom;\n}\n\nfloat sdPlane(vec3 p, vec4 n) { return dot(p, n.xyz) - n.w; }\n\n// map TODO maybe something nicer... performance permitting.\nfloat map(vec3 p) {\n    float pl = sdPlane(p, vec4(0.0, 1.0, 0.0, -20.0));\n    return pl;\n}\n\nTraceResult trace(vec3 ro, vec3 rd) {\n    TraceResult traceResult = TraceResult(false, 0.0);\n    float t = 0.02; float tmax = MAXT; \n\n    for (; t < MAXT; ) {\n        vec3 rp = ro + rd * t;\n        bool hitFogVolumeTemp = false;\n        float mapTrace = map(rp);\n        if (mapTrace<0.01) {\n            traceResult.hit = true;\n            break;\n        }\n\n        t += mapTrace; \n    }\n\n    traceResult.rayt = t;\n    return traceResult;\n}\n\nvoid cloudCalcLight(vec3 ro, vec3 rd, float tmax, float numsamples, inout vec3 lightAmb, inout vec3 lightSun) {\n    float stepsize = tmax/numsamples;\n    float eps = 0.0005;\n    float transmittance = 1.0;\n\n    for (float j = eps; j <= tmax; j += stepsize) {\n        vec3 rp = ro+j*rd;\n        float density = getCloudDensity(rp);\n        if (density > 0.0) {\n            float extinctionCoeff = CLOUD_EXTINCTION * density;\n            transmittance *= exp(-extinctionCoeff*stepsize);\n            lightAmb += transmittance * CLOUD_AMBIENT_COLOR; \n            lightSun += transmittance * SUNCOLOR;\n        }\n    }\n}\n\nvec4 traceCloud3(vec3 ro, vec3 rd, vec3 ld, float tmin, float tmax, float numsamples) {\n    vec3  Le = vec3(0.0); // light quantity \n    float transmittance = 1.0; // initial tranmittance\n    float sunphase = 3.0/4.0*(dot(rd,ld)*dot(rd,ld)+0.5);\n    float ambphase = 0.4;\n\n    float stepsize = (tmax-tmin) / numsamples;\n    for (float i = tmin+0.02; i <= tmax; i+=stepsize) {\n        vec3 rp = ro+i*rd;\n        float density =  getCloudDensity(rp); \n        if (density > 0.0) {\n            float extinctionCoeff = CLOUD_EXTINCTION * density;\n            float scatteringCoeff = CLOUD_SCATTERING * density;\n            transmittance = transmittance * exp(-extinctionCoeff*stepsize);\n\n            // for now we assume that sunlight comes from above and not below...\n            // tmin for calcLight is always 0, can ignore it... :P\n            float hi = hPlaneIntersection(rp, ld, CLOUD_Y_HI);\n            vec3 lightSunIn = vec3(0.0); \n            vec3 lightAmbIn = vec3(0.0);\n            cloudCalcLight(rp+ld*hi, -ld, hi, ceil(numsamples*CLOUDTRACE_LIGHT_MULTIPLIER), lightAmbIn, lightSunIn);\n\n            vec3 scattering = scatteringCoeff * (sunphase*lightSunIn + ambphase*lightAmbIn);\n            Le += transmittance * scattering * stepsize;\n        }\n    }\n\n    return vec4(Le, transmittance);\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 eps = vec2(0.001,0.0);\n    float x = map(p+eps.xyy)-map(p-eps.xyy);\n    float y = map(p+eps.yxy)-map(p-eps.yxy);\n    float z = map(p+eps.yyx)-map(p-eps.yyx);\n    return normalize(vec3(x,y,z));\n}\n\n//Shadow function. I have no idea what I am doing but it looks okay. \nfloat traceShadow(vec3 ro, vec3 rd) {\n    float numsteps = 15.0;\n    float stepsize = 2.0;\n    float d = 0.0;\n    for (float i = 0.0; i < numsteps *stepsize; i+=stepsize) {\n        d += clamp(getCloudDensity(ro+i*rd),0.0,1.0) * 0.5;\n    }\n    return 1.0-clamp(d, 0.0,1.0);\n}\n\nfloat phongDiffuseFactor(vec3 l, vec3 n) {\n    return max(0.0, dot(l,n));\n}\n\nfloat phongSpecularFactor(vec3 l, vec3 n, vec3 v, float k) {\n    vec3 r = normalize(reflect(l, n));\n    return pow(max(0.0, dot(r, v)), k);\n}\n\nfloat fog(float dist, float d, float p) {\n    return  1.0 - 1.0/exp(pow(dist*d, p));\n}\n\nvec3 sky(vec3 ro, vec3 rd) {\n    vec3 color = SKYCOLOR; \n    float d = dot(-SUNDIRECTION, rd); // sun??\n    if (d > 0.0)          \n        color = mix(color, vec3(1.0), pow(d, 150.0));\n    if (rd.y < FOGFADEHEIGHT)     \n        color = mix(FOGCOLOR, color, (rd.y-FOGHEIGHT)/(FOGFADEHEIGHT-FOGHEIGHT));\n    if (rd.y < FOGHEIGHT) \n        color = FOGCOLOR;\n    return clamp(color, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord.xy / iResolution.xy;\n    float finv = tan(90.0 * 0.5 * PI / 180.0);\n    float aspect = iResolution.x / iResolution.y;\n    st.x = st.x * aspect;\n    st = (st - vec2(aspect * 0.5, 0.5)) * finv;\n\n    vec3 ro = vec3(iMouse.x*0.05, -18.0+iMouse.y*0.075, 0.0);\n    vec3 rd = normalize(vec3(st, 1.0));\n    rd=rotateX(0.1)*rd;\n    rd=rotateY(-0.7)*rd;\n    rd = normalize(rd);\n\n    vec3 color = sky(ro, rd);\n\n    float t = MAXT;\n    TraceResult traceResult = trace(ro, rd);\n    vec3 rp = ro;\n\n\n    if (traceResult.hit) {\n        t = traceResult.rayt;\n        rp = ro+traceResult.rayt*rd;\n        vec3 n = calcNormal(rp);\n        vec3 tiles = (sin(rp.z) + sin(rp.x) <= 0.0) ? TILE1_COLOR : TILE2_COLOR;\n        vec3 sp = rp + 0.1*n;\n        float ph = phongDiffuseFactor(-SUNDIRECTION, n) \n                 + phongSpecularFactor(-SUNDIRECTION, n, rd, 10.0);\n        color = 0.2+SUNCOLOR*ph*traceShadow(sp, -SUNDIRECTION);\n        color = tiles * color;\n\n        float fg = fog(t, FOGDENSITY, FOGPOWER);\n        color = mix(color, FOGCOLOR, fg);\n    }\n\n    float lo = hPlaneIntersection(ro, rd, CLOUD_Y_LO);\n    float hi = hPlaneIntersection(ro, rd, CLOUD_Y_HI);\n\n    // volumes boundary...\n    float near = min(lo,hi); near = (near >= 0.0) ? near : 0.0;\n    float far  = max(lo,hi);  far = (far >= MAXT*1.5) ? MAXT * 1.0: far;\n\n    if (far > 0.0 && near < MAXT*1.5 && far < MAXT*1.5) {\n        float numsamples = CLOUDTRACE_NUMSTEPS; \n        vec4 cloudTrace = traceCloud3(ro, rd, -SUNDIRECTION, near, far, numsamples);\n        color = cloudTrace.xyz + cloudTrace.w * color;\n        float fg = fog(near, FOGDENSITY, FOGPOWER);\n        color = mix(color, FOGCOLOR, fg);\n    }\n\n    \n    color = clamp(color, 0.0, 1.0);\n    fragColor = vec4(color, 1.0); \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}