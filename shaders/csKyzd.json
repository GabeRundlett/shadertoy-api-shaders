{
    "Shader": {
        "info": {
            "date": "1697377096",
            "description": "Sparse subdivided voxel cell raymarch traversal. ",
            "flags": 0,
            "hasliked": 0,
            "id": "csKyzd",
            "likes": 93,
            "name": "Subdivided Voxel Raymarching",
            "published": 3,
            "tags": [
                "raymarch",
                "voxel",
                "menger",
                "cell",
                "sierpinski",
                "traversal",
                "sparse"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 1313
        },
        "renderpass": [
            {
                "code": "/*\n\n\tSubdivided Voxel Raymarching\n\t----------------------------\n    \n    I don't think I've posted a tunnel flythrough for a while, so here's \n    something that I've had sitting in my account in one form or another\n    for ages. I'd describe the aesthetic here as weird but interesting. :)\n    This particular scene style is not commonly seen because it relies on \n    a raymarching trick that's not often used. I'm not sure what it's \n    officially called, but Shadertoy user Nimitz called it sparse cell \n    raymarching in one of his examples, so that's as good a term as any. :)    \n\n\tTraversing sparse voxels inside a raymarching loop is not a new idea,\n    but it's one that's seldomly used, which surprises me since it opens\n    up so many possibilities. Basically, you can render a voxelized scene\n    with virtually all of the benefits of raymarching, and without putting\n    too much pressure on the GPU.\n    \n    The rendering speed is not too bad, all things considered, but I'll try \n    to tweak it more later to cater to those with slower machines. Anyway, \n    I have a few of these that I plan to post at some stage.\n    \n    \n\n\n\tOther examples: \n    \n\n    // Really stylish.\n    Sparse grid marching - nimitz\n    https://www.shadertoy.com/view/XlfGDs\n    \n\t// A cell be cell traversal with raymarching inside each cell.\n    // Amazing to think that this is over ten years old.\n    Cubescape - iq\n\thttps://www.shadertoy.com/view/Msl3Rr \n    \n    // A rectangular prism example that should be easier to understand.\n    Cell-By-Cell Raymarching - Shane\n    https://www.shadertoy.com/view/DdBfzt\n \n\n*/\n\n// Scene: There are four surfaces to voxelize... or quasi-voxelize. I quickly\n// put some simple ones in there, but you could code up any surface you can\n// dream up... that doesn't fry the GPU. :)\n//\n// Tunnel: 0, Noisy Tunnel: 1, Blobby Surface: 2, Warped double planes: 3.\n#define SCENE 1\n\n\n#define PI 3.14159265\n#define FAR 60.\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n\n// Object ID: Either the back plane, extruded object or beacons.\nint objID;\n\n\n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21(vec2 f){\n\n    // Depending on your machine, this should be faster than\n    // the block below it.\n    return texture(iChannel2, vec3(f*vec2(.2483, .3437), .5)).x;\n    /* \n    uvec2 p = floatBitsToUint(f);\n    p = 1664525U*(p>>1U^p.yx);\n    return float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU);\n    */\n}\n\n// IQ's \"uint\" based uvec3 to float hash.\nfloat hash31(vec3 f){\n\n    \n    //return texture(iChannel1, f.xy*vec2(.2483, .1437) + f.z*vec2(.4865, .5467)).x;\n    // Volume noise texture.\n    return texture(iChannel2, f*vec3(.2483, .4237, .4865)).x;\n    /* \n    uvec3 p = floatBitsToUint(f);\n    p = 1103515245U*((p >> 2U)^(p.yzx>>1U)^p.zxy);\n    uint h32 = 1103515245U*(((p.x)^(p.y>>3U))^(p.z>>6U));\n\n    uint n = h32^(h32 >> 16);\n    return float(n & uint(0x7fffffffU))/float(0x7fffffff);\n    */ \n}\n\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n\n// Tri-Planar blending function: Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D tex, in vec3 p, in vec3 n){    \n    \n    // Abosolute normal with a bit of tightning.\n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.zy).xyz;\n    vec3 ty = texture(tex, p.xz).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture \n    // sample, represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like\n    // that. :) Once the final color value is gamma corrected, you should see correct \n    // looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n;\n}\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, \n// and amplitudes.\nvec2 path(in float z){ \n    \n   \n    //return vec2(0); // Straight.\n    float a = sin(z*.11);\n    float b = cos(z*.14);\n    return vec2((a*4. -b*1.5), (b*1.7 + a*1.5)); \n    //return vec2(a*4. -b*1.5, 0.); // Just X.\n    //return vec2(0, b*1.7 + a*1.5); // Just Y.\n}\n\n \n\n \n/*\n// Compact, self-contained version of IQ's 3D value noise function.\nfloat n3D(vec3 p){\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(mod(h, 6.2831))*43758.5453), \n            fract(sin(mod(h + s.x, 6.2831))*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n*/\n\n// Texture volume based 3D noise.\nfloat n3D(vec3 p){\n\t\n    return texture(iChannel2, p/32.).x; // Range: [0, 1].\n}\n\n\n// IQ's 3D signed box formula.\nfloat sBoxS(vec3 p, vec3 b, float sf){\n\n  p = abs(p) - b + sf;\n  return min(max(p.x, max(p.y, p.z)), 0.) + length(max(p, 0.)) - sf;\n}\n\n// IQ's 2D signed box formula with some added rounding.\nfloat sBoxS(vec2 p, vec2 b, float sf){\n\n  p = abs(p) - b + sf;\n  return min(max(p.x, p.y), 0.) + length(max(p, 0.)) - sf;\n}\n\n\n// Global cell boundary distance variables.\nvec3 gDir; // Cell traversing direction.\nvec3 gRd; // Ray direction.\nfloat gCD; // Cell boundary distance.\n// Box dimension and local XY coordinates.\nvec3 gSc; \nvec2 gP;\n\n\n// Scene: There are four surfaces to voxelize... or quasi-voxelize. I quickly\n// put some simple ones in there, but you could code up any surface you can\n// dream up... that doesn't fry the GPU. :)\n//\nfloat getFunc(vec3 p){\n\n    #if SCENE == 0\n    \n    // Standard perturbed tunnel function. It looks better without\n    // subdivision turned on.\n\n    // Offset the tunnel about the XY plane as we traverse Z.\n    p.xy -= path(p.z);\n    \n    \n    // Standard tunnel. Comment out the above first.\n    float n = 3.5 - length(p.xy*vec2(1, .7));\n\n    // Square tunnel. Almost redundant in a voxel renderer. :)\n    //float n = 3. - max(abs(p.x), abs(p.y)); \n\n    // Tunnel with a floor.\n    return min(p.y + 3., n); //n = min(-abs(p.y) + 3., n);\n\n    #elif SCENE == 1\n \n    // Simple noisy tunnel.\n    \n    float d = n3D(p/5.) - .55;//(.4 + sin(iTime/8.)*.125);\n\n    p.xy -= path(p.z);\n\n    float t = 2.5 - length(p.xy);\n    //float t2 = 1. - length(p.xy - vec2(0, 2)); // Tunnel for light, above \"t.\"\n\n\n    return smax(t, d, .5); \n    \n    #elif SCENE == 2 \n\n    // Blobby transcendental surface... Not really suited to this\n    // setup... Needs tweaking.\n    \n    p.xy -= path(p.z);\n\n    p /= 4.;\n\n    p = (cos(p*.315*2. + sin(p.zxy*.875*2.)));\n\n    float n = dot(p, p);\n\n    p = sin(p*3. + cos(p.yzx*3.));\n\n    n -= .9 + p.x*p.y*p.z*.35;\n\n    return n; \n    \n    #else \n    \n    // Warped double plane.\n    \n    p.xy -= path(p.z); // Move the scene around a sinusoidal path.\n    p.xy = rot2(p.z/8.)*p.xy; // Twist it about XY with respect to distance.\n    \n    //float n = dot(sin(p*1. + sin(p.yzx*.5 + iTime)), vec3(.25)); // Timelapse effect.\n    float n = dot(sin(p*1. + sin(p.yzx*.5)), vec3(.25)); // Sinusoidal layer.\n     \n    return 2. - abs(p.y) + n; // Warped double planes, \"abs(p.y),\" plus surface layers.\n    \n    #endif\n     \n}\n\n// Global storage for the cell distance and ID.\nvec4 gVal;\n\n\n// The code here is a little fiddly, but if you ignore the individual logic, \n// you can see that we're partitioning space into repeat cells -- as is often \n// done -- then rendering (or not rendering, hence the sparse attribute) an \n// object inside each cell. The only difference between this example and a \n// regular one is a few lines at the end which involve raytracing from the \n// current point in each cell to the cell walls. That's it.\n//\nfloat map(vec3 q){\n    \n    \n    // Subdividing space into cells, resulting in\n    // the local coordinates and cell ID.\n    //\n    vec3 sc = vec3(1.36); // Scale.\n    vec3 p = q; // Global coordinates.\n    vec3 ip = (floor(p/sc) + .5)*sc; // Cell ID.\n    int split = 0; // No division.\n    if(hash31(ip + .03)<.35){ \n       sc /= 2.;\n       ip = (floor(p/sc) + .5)*sc; // New cell ID, if needed.\n       split = 1; // The cell has been divided.\n    } \n    p -= ip;  // Local coordinates.\n    \n    \n    // Plugging the cell's central coordinate ID into a 3D distance\n    // function.\n    float fn = getFunc(ip);\n    \n    // No object hit ID... Probably not necessary.\n    objID = 0;\n    \n    \n    // Voxel object and frameword distance.\n    float vox = 1e5, frame = 1e5;\n    \n   \n    // If we're below the 3D function threshold, render an object\n    // inside the cell space.\n    if(fn<0.){ \n    \n        // Render a slightly round cube that takes up the cell.\n        float minSc = min(min(sc.x, sc.y), sc.z);\n        vox = sBoxS(p, sc/2. - .0*minSc, .05*minSc);\n        float oVox = vox;\n\n        float hw = minSc/3.; // Hole dimension.\n \n        float xRnd = hash31(ip + .011) - .6;\n        //float yRnd = hash31(ip + .022) - .6;\n        float zRnd = hash31(ip + .033) - .6;\n        \n        float divF = 3.;\n        vec3 q = mod(p + sc/divF/2., sc/divF) - sc/2./divF;\n        \n        // Bore out random Sierpinski-style holes from the XY cube face.\n        if(zRnd<0.){ \n        \n            // Large hole.\n            float hXY = sBoxS(p.xy, mix(sc.xy, vec2(minSc), .5)/2., 0.);\n            vox = smax(vox, -hXY - hw, .05*minSc);\n            \n            // Smaller holes.\n            if(hash31(ip + .41)<.5){\n                float hXY2 = sBoxS(q.xy, vec2(minSc)/2./divF, 0.);\n                vox = smax(vox, -hXY2 - hw/divF, .05*minSc/divF);\n            }\n             \n        }\n        \n        // Bore out random Sierpinski-style holes from the YZ cube face.\n        if(xRnd<0.){\n        \n            // Large hole.\n            float hYZ = sBoxS(p.yz, mix(sc.yz, vec2(minSc), .5)/2., 0.);\n            vox = smax(vox, -hYZ - hw, .05*minSc);\n            \n            // Smaller holes.\n            if(hash31(ip + .43)<.5){\n                float hYZ2 = sBoxS(q.yz, vec2(minSc)/2./divF, 0.);\n                vox = smax(vox, -hYZ2 - hw/divF, .05*minSc/divF);\n            }\n             \n        }\n        \n        // XY cube face.\n        //if(yRnd<0.){\n        \n            //float hXZ = sBoxS(p.xz, sc.xz/2., 0.);\n            //vox = smax(vox, -hXZ - hw, .05*minSc);\n \n            //float hXZ2 = sBoxS(q.xz, sc.xy/2./divF, 0.);\n            //vox = smax(vox, -hXZ2 - hw/divF, .05*minSc/divF);\n            \n        //}\n        \n   \n        // Frame lattice of sorts. Only calculate the frame lattice when\n        // no cell subdivision has occurred. That's a design choice, not\n        // a necessity.\n        if(split==0){\n        \n            // Face selection.\n            vec3 dir = abs(p); \n            dir = step(dir.yzx, dir.xyz)*step(dir.zxy, dir.xyz)*sign(p); \n            int splitN = hash31(ip + dir*sc + .03)<.333? 1 : 0;\n\n            float fnN = getFunc(ip + dir*sc);\n\n            float wF = .1; // Width factor.\n            \n\n            frame = sBoxS(p, sc/2.*wF*1.5, minSc*.025);\n            //frame = length(p) - minSc/2.*wF*2.;\n\n            // Replace some of the silver boxes.\n            float met = hash31(floor(ip/3.) + .3) - .5;\n            if(met<0. && hash31(floor(ip) + .22)<.65) vox = 1e5;\n\n            if(fnN<0.){ // - dir*sc/2.\n\n\n                vec3 lSc = minSc/2.*wF + abs(dir)*minSc;//*(1. - wF)*2.;\n                frame = min(frame, sBoxS(p, lSc, .025*minSc));\n\n                //vox = length(p - dir*sc/4.) - minSc/8.;\n\n            } \n            \n            // The edge evaluation isn't really meant to be performed with\n            // a split lattice, so there's some untidy open edges. This hack \n            // cleans them up a bit.\n            frame = max(frame, oVox);\n     \n            \n             \n        \n        }  \n        \n         // Object ID.\n        objID = vox<frame? 1 : 2;\n   \n        \n    \n    }\n \n    // Storing the cell distance and cell ID for later usage.\n    gVal = vec4(vox, ip);\n    \n    \n    // Current position to the forward facing cubic cell wall \n    // plane intersection distances.\n    vec3 rC = (gDir*sc - vec3(p))/gRd;\n    \n    // Minimum of all distances, plus not allowing negative distances, which\n    // stops the ray from tracing backwards... I'm not entirely sure it's\n    // necessary here, but it stops artifacts from appearing with other \n    // non-rectangular grids.\n    gCD = max(min(min(rC.x, rC.y), rC.z), 0.) + .0015;\n \n    \n    // Return the minimum overall scene distance.\n    return min(vox, frame); \n\n    \n}\n\n/*\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. \n// I tried to make it as concise as possible. Whether that translates to speed, or not, \n// I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset \n    // greyscale texture values.    \n    mat3 m = mat3(tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), \n                  tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n*/\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float d, t = 0.; //hash31(ro + rd)*.15\n    \n    //vec2 dt = vec2(1e5, 0); // IQ's clever desparkling trick.\n    \n    // Set the global ray direction varibles -- Used to calculate\n    // the cell boundary distance inside the \"map\" function.\n    gDir = step(0., rd) - .5; // Equivalent to: sign(rd)*.5;\n    gRd = rd; \n    \n     \n    const int iMax = 128;\n    for (int i = min(iFrame, 0); i<iMax; i++){ \n    \n        d = map(ro + rd*t);       \n        //dt = d<dt.x? vec2(d, dt.x) : dt; // Shuffle things along.\n        \n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, \n        // as \"t\" increases. It's a cheap trick that works in most situations.\n        if(abs(d)<.001 || t>FAR) break; \n        \n        //t += i<32? d*.75 : d; \n        t += min(d*.9, gCD); \n    }\n    \n    // If we've run through the entire loop and hit the far boundary, \n    // check to see that we haven't clipped an edge point along the way. \n    // Obvious... to IQ, but it never occurred to me. :)\n    //if(i>=iMax - 1) t = dt.y;\n\n    return min(t, FAR);\n}\n\n\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\t\n    const vec2 e = vec2(.001, 0);\n    \n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), \n    //                      map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with \n// limited iterations is impossible... However, I'd be very grateful if someone could \n// prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not always affordable. :)\n    const int maxIterationsShad = 48; \n    \n    ro += n*.0015; // Coincides with the hit condition in the \"trace\" function.\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), .0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n    \n    // Set the global ray direction varibles -- Used to calculate\n    // the cell boundary distance inside the \"map\" function.\n    gDir = sign(rd)*.5;\n    gRd = rd;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. \n    // Obviously, the lowest number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n       \n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), \n        // dist += clamp(h, .01, stepDist), etc.\n        t += clamp(min(d*.9, gCD), .02, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Shadow.\n    return max(shade, 0.); \n}\n\n\n// A slight variation on a function from Nimitz's hash collection, here: \n// Quality hashes collection WebGL2 - https://www.shadertoy.com/view/Xt3cDn\nvec2 hash23(vec3 f){\n\n    uvec3 p = floatBitsToUint(f);\n    p = 1103515245U*((p >> 2U)^(p.yzx>>1U)^p.zxy);\n    uint h32 = 1103515245U*(((p.x)^(p.y>>3U))^(p.z>>6U));\n\n    uint n = h32^(h32>>16);\n\n    uvec2 rz = uvec2(n, n*48271U);\n    // Standard uvec2 to vec2 conversion with wrapping and normalizing.\n    return vec2((rz>>1)&uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\n \n// A nice random hemispherical routine taken out of one of IQ's examples.\n// The routine itself was written by Fizzer.\nvec3 cosDir(in vec3 p, in vec3 n){\n\n    vec2 rnd = hash23(p);\n    float u = rnd.x;\n    float v = rnd.y;\n    \n    // Method 1 and 2 first generate a frame of reference to use with an arbitrary\n    // distribution, cosine in this case. Method 3 (invented by fizzer) specializes \n    // the whole math to the cosine distribution and simplfies the result to a more \n    // compact version that does not depend on a full frame of reference.\n\n    // Method by fizzer: http://www.amietia.com/lambertnotangent.html\n    float a = 6.2831853*v;\n    u = 2.*u - 1.;\n    return normalize(n + vec3(sqrt(1. - u*u)*vec2(cos(a), sin(a)), u));\n    \n}\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n    \n\n\tfloat sca = 3., occ = 0.;\n    for(int i = 0; i<12; i++){\n    \n        float hr = (float(i) + 1.)*.35/12.; \n        //float fi = float(i + 1);\n        //vec3 rnd = vec3(hash31(p + fi), hash31(p + fi + .1), hash31(p + fi + .3)) - .5;\n        //vec3 rn = normalize(n + rnd*.15);\n        vec3 rn = cosDir(p + n*hr, n); // Random half hemisphere vector.\n        float d = map(p + rn*hr);\n        \n        occ = occ + max(hr - d, 0.)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);    \n    \n}\n \n///////////////////////////\n\n\n// Microfaceted normal distribution function.\nfloat D_GGX(float NoH, float roughness) {\n    float alpha = pow(roughness, 4.);\n    float b = (NoH*NoH*(alpha - 1.) + 1.);\n    return alpha/(3.14159265*b*b);\n}\n\n// Surface geometry function.\nfloat G1_GGX_Schlick(float NoV, float roughness) {\n    //float r = roughness; // original\n    float r = .5 + .5*roughness; // Disney remapping.\n    float k = (r*r)/2.;\n    float denom = NoV*(1. - k) + k;\n    return max(NoV, .001)/denom;\n}\n\nfloat G_Smith(float NoV, float NoL, float roughness) {\n    float g1_l = G1_GGX_Schlick(NoL, roughness);\n    float g1_v = G1_GGX_Schlick(NoV, roughness);\n    return g1_l*g1_v;\n}\n\n// Bidirectional Reflectance Distribution Function (BRDF). \n//\n// If you want a quick crash course in BRDF, see the following:\n// Microfacet BRDF: Theory and Implementation of Basic PBR Materials\n// https://www.youtube.com/watch?v=gya7x9H3mV0&t=730s\n//\nvec3 BRDF(vec3 col, vec3 n, vec3 l, vec3 v, \n          float type, float rough, float fresRef){\n     \n  vec3 h = normalize(v + l); // Half vector.\n\n  // Standard BRDF dot product calculations.\n  float nv = clamp(dot(n, v), 0., 1.);\n  float nl = clamp(dot(n, l), 0., 1.);\n  float nh = clamp(dot(n, h), 0., 1.);\n  float vh = clamp(dot(v, h), 0., 1.);  \n\n  \n  // Specular microfacet (Cook- Torrance) BRDF.\n  //\n  // F0 for dielectics in range [0., .16] \n  // Default FO is (.16 * .5^2) = .04\n  // Common Fresnel values, F(0), or F0 here.\n  // Water: .02, Plastic: .05, Glass: .08, Diamond: .17\n  // Copper: vec3(.95, .64, .54), Aluminium: vec3(.91, .92, .92), Gold: vec3(1, .71, .29),\n  // Silver: vec3(.95, .93, .88), Iron: vec3(.56, .57, .58).\n  vec3 f0 = vec3(.16*(fresRef*fresRef)); \n  // For metals, the base color is used for F0.\n  f0 = mix(f0, col, type);\n  vec3 F = f0 + (1. - f0)*pow(1. - vh, 5.);  // Fresnel-Schlick reflected light term.\n  // Microfacet distribution... Most dominant term.\n  float D = D_GGX(nh, rough); \n  // Geometry self shadowing term.\n  float G = G_Smith(nv, nl, rough); \n  // Combining the terms above.\n  vec3 spec = F*D*G/(4.*max(nv, .001));\n  \n  \n  // Diffuse calculations.\n  vec3 diff = vec3(nl);\n  diff *= 1. - F; // If not specular, use as diffuse (optional).\n  diff *= (1. - type); // No diffuse for metals.\n\n  \n  // Combining diffuse and specular.\n  // You could specify a specular color, multiply it by the base\n  // color, or multiply by a constant. It's up to you.\n  return (col*diff + spec*3.14159265);\n  \n}\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n\t// Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 camPos = vec3(0, 0, iTime*5.); // Camera position, doubling as the ray origin.\n    vec3 lookAt = camPos + vec3(0, 0, .25);  // \"Look At\" position.\n \n    // Light positioning. \n \tvec3 lightPos = camPos + vec3(0, .5, 6);// Put it in front of the camera.\n\n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and two light vectors down the tunnel. The \"path\" \n    // function is synchronized with the distance function.\n\tlookAt.xy += path(lookAt.z);\n\tcamPos.xy += path(camPos.z);\n\tlightPos.xy += path(lightPos.z);\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = PI/3.; // FOV - Field of view.\n    vec3 forward = normalize(lookAt - camPos);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(uv.x*right + uv.y*up + forward/FOV);\n    // Fisheye lens.\n    //rd = normalize(vec3(rd.xy, rd.z - dot(rd.xy, rd.xy)*.2));    \n    \n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    // Naturally, it's synchronized with the path in some kind of way.\n\trd.xy = rot2( path(lookAt.z).x/24.)*rd.xy;\n    \n\n    // Scene distance.\n\tfloat t = trace(camPos, rd);\n    \n    // Object ID: Back plane (0), or the metaballs (1).\n    int svObjID = objID;\n    \n    // Saving some 3D cell values. In this case, distance and ID.\n    vec4 svVal = gVal;\n    \n    \n    // Background fog color.\n    vec3 fog = mix(vec3(.32, .28, .16)*3., vec3(.32, .12, .08)*2., -rd.y*.5 + .5);\n    //vec3 fog = vec3(0);\n\t\n    // Initialize the scene color.\n    vec3 sceneCol = fog;\n    \n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t<FAR && svObjID>0){\n\t\n   \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = camPos + rd*t;\n        \n        // Voxel normal.\n        vec3 sn = getNormal(sp, t);\n        \n        // Sometimes, it's necessary to save a copy of the unbumped normal.\n        //vec3 snNoBump = sn;\n        \n        // I try to avoid it, but it's possible to do a texture bump and a function-based\n        // bump in succession. It's also possible to roll them into one, but I wanted\n        // the separation... Can't remember why, but it's more readable anyway.\n        //\n        // Texture scale factor.\n        const float tSize0 = 1./3.;\n        // Texture-based bump mapping.\n\t    //sn = doBumpMap(iChannel0, sp*tSize0, sn, .003);\n\n        // Function based bump mapping. Comment it out to see the under layer. It's pretty\n        // comparable to regular beveled Voronoi... Close enough, anyway.\n        //sn = doBumpMap(sp, sn, .1);\n        \n       \n\t    // Ambient occlusion.\n\t    float ao = calcAO(sp, sn) ;//calculateAO(sp, sn);//*.75 + .25;\n\n        \n    \t// Light direction vectors.\n\t    vec3 ld = lightPos - sp;\n\n        // Distance from respective lights to the surface point.\n\t    float lDist = max(length(ld), .0001);\n    \t\n    \t// Normalize the light direction vectors.\n\t    ld /= lDist;\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*lDist*.05); // + distlpsp*distlpsp*0.025\n    \t\n        // Ambient light.\n        // I wanted to use a little more than a constant for ambient light, but \n        // without having to resort to sophisticated methods, then I remembered \n        // Blackle's example, here:\n        // Quick Lighting Tech - blackle\n        // https://www.shadertoy.com/view/ttGfz1\n        //float ambience = pow(length(sin(sn*2.)*.45 + .5)/sqrt(3.), 2.)*.75; // Studio.\n        float ambience = length(sin(sn*2.)*.5 + .5)/sqrt(3.)*\n                         smoothstep(-1., 1., sn.y)*.5; // Outdoor.\n \n    \t\n    \t// Diffuse lighting.\n\t    float diff = max(dot(sn, ld), 0.);\n   \t\n    \t// Specular lighting.\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.);\n\n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow( clamp(dot(sn, rd) + 1., .0, 1.), 1.);\n        \n        // Obtaining the texel color. \n        vec3 ref = reflect(sn, rd);\n\n        // Object texturing.\n        \n        // Coloring.\n        float rnd = hash31(svVal.yzw);\n\t    vec3 texCol = .5 + .45*cos(6.2831*rnd/3. + vec3(0, 1, 2) + .5);\n        \n        texCol = vec3(1)*dot(texCol, vec3(.299, .587, .114));\n        \n        // Metallic box threshold.\n        float met = hash31(floor(svVal.yzw/3.) + .3) - .5;\n        // Metallic coloring for some boxes and the frame.\n        if(met<0. || svObjID==2) texCol = vec3(.2);\n        //if(svObjID==2) texCol *= vec3(1, .8, .6)*1.2;\n \n        // Multiplying objects by respective texture colors.\n        if(met<0. || svObjID==2) texCol *= tex3D(iChannel1, sp/4., sn)*4.;\n\t    else texCol *= .1 + tex3D(iChannel0, sp*tSize0, sn)*4.;\n        \n         \n        // Shadows.\n        float shad = softShadow(sp, lightPos, sn, 8.);\n        \n        \n        float rnd2 = hash31(svVal.yzw + .2);\n        float matType = 0.; // Dielectric.\n        float roughness = min(dot(texCol, vec3(.299, .587, .114))*.5, 1.);\n        float reflectance = hash31(svVal.yzw)*.75;\n        // Metallic properties for some boxes and the framework.\n        if(met<0. || svObjID==2) { \n            texCol = texCol*2.*vec3(1, .8, .5); \n            matType = 1.; reflectance = .5; // Metallic.\n            roughness = min(roughness*5., 1.);\n        }\n\n        \n        // Requires \"St Peter's Basillica\" cube map loaded into \"iChannel3\".\n        // Specular reflection.\n        vec3 hv = normalize(-rd + ld); // Half vector.\n        vec3 refTx = texture(iChannel3, ref, 1.).xyz; refTx *= refTx; // Cube map.\n        float spRef = pow(max(dot(hv, sn), 0.), 8.); // Specular reflection.\n        //spRef = mix(spRef/4., spRef, 1. - smoothstep(0., .01, d + .05));   \n        float rf = 8.;//(svObjID == 1)? 8. : 1.;\n        texCol += texCol*spRef*dot(refTx, vec3(.299, .587, .114))*rf;\n\n\n        \n        // Cook-Torrance based lighting.\n        vec3 ct = BRDF(texCol, sn, ld, -rd, matType, roughness, reflectance);\n        \n        // Combining the ambient and microfaceted terms to form the final color:\n        // None of it is technically correct, but it does the job. Note the hacky \n        // ambient shadow term. Shadows on the microfaceted metal doesn't look \n        // right without it... If an expert out there knows of simple ways to \n        // improve this, feel free to let me know. :)\n        sceneCol = (texCol*ambience*(shad*.5 + .5) + ct*(shad));\n\n\n\t    // Shading.\n        sceneCol *= atten*ao;\n        \n        // \"XT95\" did such a good job with the AO, that it's worth a look on its own. :)\n        //sceneCol = vec3(ao); \n\n\t   \n\t\n\t}\n       \n    // Blend in a bit of fog for atmospheric effect.    \n    sceneCol = mix(sceneCol, fog, smoothstep(.2, .99, t/FAR)); // exp(-.002*t*t), etc.\n\n    // Clamp and present the badly gamma corrected pixel to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneCol, 0., 1.)), 1.0);\n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}