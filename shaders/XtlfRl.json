{
    "Shader": {
        "info": {
            "date": "1512917849",
            "description": "britney is wax in my hands ;-) ...best viewed in fullscreen!\nmouse left/right - change strength of the effect.\nmouse up/down - change type of effect\nalso see on [url]https://shaderoo.org[/url]",
            "flags": 48,
            "hasliked": 0,
            "id": "XtlfRl",
            "likes": 66,
            "name": "melting wax britney",
            "published": 3,
            "tags": [
                "effect",
                "postprocess",
                "melting",
                "wax"
            ],
            "usePreview": 0,
            "username": "flockaroo",
            "viewed": 2101
        },
        "renderpass": [
            {
                "code": "// created by florian berger (flockaroo) - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// melting wax\n\n// mouse left/right - change strength of the effect.\n// mouse up/down - change type of effect (up=diffusion, down=fluid)\n//\n// also see on shaderoo.org [https://www.shaderoo.org/?shader=6BTyk8]\n//\n// the image is distorted by simple diffusion and/or fluid algorithm \n// (just as in 'spilled' - https://www.shadertoy.com/view/MsGSRd)\n// a frame history is built up to be able to fade the strength of the distortion\n// (go back in history to a more distorted frame)\n// without mouse interaction its always fading modes and strength in time\n\n// apply bumpyness and waxy lighting\n\nfloat getVal(vec2 uv)\n{\n    return length(texture(iChannel0,uv).xyz);\n}\n    \nvec2 getGrad(vec2 uv,float delta)\n{\n    vec2 d=vec2(delta,0);\n    return vec2(\n        getVal(uv+d.xy)-getVal(uv-d.xy),\n        getVal(uv+d.yx)-getVal(uv-d.yx)\n    )/delta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 n = vec3(getGrad(uv,2./iResolution.y),150.0);\n    //n *= n;\n    n=normalize(n);\n    fragColor=vec4(n,1);\n    vec3 light = normalize(vec3(1,1,2));\n    float diff=clamp(dot(n,light),0.5,1.0);\n    float spec=clamp(dot(reflect(light,n),vec3(0,0,-1)),0.0,1.0);\n    spec=pow(spec,20.0);\n\tfragColor = mix(texture(iChannel0,uv),vec4(1),spec/(diff+spec));\n    fragColor.w = 1.;\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// melting wax\n\n// storing history of video in X/Y grid in this texture\n// by dividing up the fb into Xnum*Ynum frames\n// and render en effect on every frame\n// in green-screen regions the effect will be applied continuously\n// in other regions it will accumulate only between two concecutive frames of the history\n\n#define Xnum 4\n#define Ynum 4\n\n#define N(v) (v.yx*vec2(1,-1))\n\n#define RotNum 5\n//#define SUPPORT_EVEN_ROTNUM\n\n#define Res  vec2(textureSize(iChannel0,0))\n#define Res1 vec2(textureSize(iChannel1,0))\n\n#define keyTex iChannel3\n#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 m = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 getRand(vec2 coord)\n{\n    return texture(iChannel1,coord.xy/Res1.xy);\n}\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nvec4 getCol(vec2 coord)\n{\n    return texture(iChannel0,coord/Res.xy);\n}\n\nfloat getVal(vec2 coord)\n{\n    vec4 c = getCol(coord);\n\treturn dot(c.xyz,vec3(.3333));\n\treturn dot(c.xyz,c.xyz);\n\treturn length(getCol(coord));\n}\n\nvec2 getGrad(vec2 coord, float eps)\n{\n    vec2 d = vec2(eps,0);\n\treturn vec2(getVal(coord+d.xy)-getVal(coord-d.xy),\n                getVal(coord+d.yx)-getVal(coord-d.yx))/eps;\n}\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(texture(iChannel0,fract((pos+p)/Res.xy)).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = m*p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvoid effectFlow(inout vec4 fragColor, vec2 pos)\n{\n    float rnd = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).x*1.;\n    \n    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));\n    vec2 v=vec2(0);\n    float bbMax=0.7*Res.y; bbMax*=bbMax;\n    for(int l=0;l<3;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n#ifdef SUPPORT_EVEN_ROTNUM\n            v+=p.yx*getRot(pos+p,-mh*b);\n#else\n            // this is faster but works only for odd RotNum\n            v+=p.yx*getRot(pos+p,b);\n#endif\n            p = m*p;\n        }\n        b*=2.0;\n    }\n    \n    fragColor=getCol(pos+v*vec2(-1,1)*4.);\n}\n\nvoid effectSmear(inout vec4 col, vec2 coord)\n{\n    vec2 g=getGrad(coord,.5);\n    col=getCol(coord+g.yx*vec2(1,-1)*.7);\n}\n\nvoid effectDiff(inout vec4 col, vec2 coord)\n{\n    vec2 g=getGrad(coord,.5);\n    col=getCol(coord+g.xy*1.5*iResolution.x/600.);\n}\n\nvoid effect(inout vec4 col, vec2 coord)\n{\n    vec4 col1,col2,col3;\n    effectFlow(col1,coord);   // fluid effect\n    effectSmear(col2,coord);  // normal to gradient diffusion effect (smearing out a little)\n    effectDiff(col3,coord);   // gradient diffusion effect\n    //col2=col;\n    //float effType=.2;\n    //float effType=.5-.5*sin(iTime*.5);\n    float effType=smoothstep(.0,.2,-sin(iTime*.3-.3));\n    if(iMouse.y>1.) effType=iMouse.y/iResolution.y;\n    col=mix(col1,col3,effType);\n    col=mix(col,col2,.3);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*vec2(Xnum,Ynum);\n    \n    // uv of next frame i history\n    vec2 uv2 = vec2(mod(uv.x-1.+float(Xnum),float(Xnum)),\n                    uv.y-(((uv.x-1.)<0.)?1.:0.))/vec2(Xnum,Ynum);\n    \n    vec4 c1,c2;\n    effect(c1,uv2*iResolution.xy);  // effect on history frame\n\teffect(c2,fragCoord);           // effect on every frame\n    \n    // copy a new frame on beginning of history (lower left edge)\n    if(fragCoord.x<iResolution.x/float(Xnum) && fragCoord.y<iResolution.y/float(Ynum))\n    {\n\t    vec4 col=texture(iChannel2,uv);\n    \tfloat bgfact = dot(col.xyz,vec3(-1,2,-1));\n        vec4 bg=vec4(1,.95,.75,1);\n        bg=texture(iChannel1,fragCoord/iResolution.xy*.2).xyzw*.3+bg*.0;\n\t\tc1 = mix(col,bg,bgfact); // some bg color instead of green\n\t\tc1.w = bgfact; // store green-ness in .w\n    }\n\n    // mix together depending on green-ness\n\tfragColor=mix(c1,c2,smoothstep(.4,.5,c1.w));\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "video",
                        "id": 12,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// melting wax\n\n// take (interpolate) certain history-frame\n\n#define Xnum 4\n#define Ynum 4\n\nfloat getVal(vec2 uv)\n{\n    return length(texture(iChannel0,uv).xyz);\n}\n    \nvec2 getGrad(vec2 uv,float delta)\n{\n    vec2 d=vec2(delta,0);\n    return vec2(\n        getVal(uv+d.xy)-getVal(uv-d.xy),\n        getVal(uv+d.yx)-getVal(uv-d.yx)\n    )/delta;\n}\n\nvec2 getFrameUV(vec2 uv, float frameDelay)\n{\n    vec2 uv2 = uv+vec2(mod(frameDelay,float(Xnum)),floor(frameDelay/float(Xnum)));\n    uv2/=vec2(Xnum,Ynum);\n    return uv2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    float strength=clamp(iResolution.x/1900.,0.,.99);\n    //float strength=clamp(.7+.3*cos(iTime*.5),0.,.99);\n    if(iMouse.x>=2.) strength=iMouse.x/iResolution.x;\n    float frameDelay = strength*float(Xnum*Ynum-1);\n\tfragColor = mix(\n        texture(iChannel0,getFrameUV(uv,floor(frameDelay))),\n        texture(iChannel0,getFrameUV(uv,ceil(frameDelay))),\n                fract(frameDelay)\n               );\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}