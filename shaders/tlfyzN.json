{
    "Shader": {
        "info": {
            "date": "1591545248",
            "description": "first attempt for a mouse hover effect on card",
            "flags": 0,
            "hasliked": 0,
            "id": "tlfyzN",
            "likes": 3,
            "name": "Hover Glow",
            "published": 3,
            "tags": [
                "mouse",
                "light",
                "glow",
                "card",
                "hover"
            ],
            "usePreview": 0,
            "username": "Paltoquet",
            "viewed": 414
        },
        "renderpass": [
            {
                "code": "\n// Author:\n// Title:\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\n#define PI 3.142\n#define ANIMATION_DURATION 120.0\n#define ANIMATION_SPEED 2.000\n#define BLUR_RADIUS 12\n\nfloat random (float theta) {\n    float period = 230.000;\n    return fract(sin(dot(theta, period * period))* 2.856);\n}\n\nfloat getCurrentTime() {\n    float coef = mod(iTime * ANIMATION_SPEED, ANIMATION_DURATION);\n    coef = coef / ANIMATION_DURATION;\n    coef = max(0.0, coef);\n    return coef;\n}\n\nfloat getAngle(vec2 pos) {\n    float coef = getCurrentTime();\n    float theta = atan(pos.y, pos.x);\n    theta = theta + coef * 2.0 * PI;\n    return theta;\n}\n\nfloat period(float theta, float nbCroissant) {\n    float period = 2.0 * PI;\n\tperiod = period * nbCroissant;\n    return sin(theta * period);\n}\n\nfloat square(vec2 position, vec2 dim) {\n    if(abs(position.x) < dim.x && abs(position.y) < dim.y) {\n        return 1.0;\n    } \n    return 0.0;\n}\n\nfloat rect(vec2 p, vec2 size) {  \n  vec2 d = abs(p) - size;\n  return min(max(d.x, d.y), 0.0) + length(max(d,0.0));\n}\n\nfloat sphere(vec2 position, vec2 center, float radius) {\n    float dist = length(position - center);\n    if(length(position - center) <= radius) {\n        return dist;\n    } \n    return 0.0;\n}\n\nfloat circle(vec2 position, float radius, float width){\n    float dist = abs(length(position) - radius);\n    if(dist < width) {\n        return width;\n    }\n    return 0.0;\n}\n\nfloat easingIn(float val) {\n    return pow(val, 3.0);\n}\n\nfloat easingOut(float val) {\n    return 1.0 - pow(1.0 - val, 5.0);\n}\n\nfloat generateSphere(vec2 position, float theta, float time) {\n    vec2 centers[8];\n    float radius[8];\n    centers[6] = vec2(0.150,-0.730);\n    centers[1] = vec2(0.320,0.630);\n    centers[2] = vec2(-0.660,0.440);\n    centers[3] = vec2(-0.590,-0.450);\n\tcenters[4] = vec2(-0.630,-0.430);    \n\tcenters[5] = vec2(-0.740,0.260);   \n    centers[6] = vec2(0.150,-0.730);\n    centers[7] = vec2(0.590,0.050);\n    \n    radius[0] = 0.028;\n    radius[1] = 0.037;\n    radius[2] = 0.049;\n\tradius[3] = 0.032;\n    radius[4] = 0.024;\n    radius[5] = 0.042;\n    radius[6] = 0.062;\n    radius[7] = 0.080;\n    \n    float result = 0.0;\n    float current = (theta + PI); //[0 - 360]\n    current = mod(current + PI / 2.0, 2.0 * PI);  //offset to put the beguining at the top\n    current = current / (2.0 * PI); //ratio for animation\n    \n    float a = time * 2.0 * PI;\n    float s = sin(a);\n\tfloat c = cos(a);\n    mat2 m = mat2(c, -s, s, c);\n    \n    time = 1.0;\n    for(int i = 0; i < 8; i++){\n        vec2 center = centers[i];\n        center = m * center;\n        float radius = radius[i];\n        //center = mix(vec2(0), center, time);\n        //radius = mix(0.001, radius, time);\n        result = max(result, sphere(position, center, radius));\n    }\n    return result;\n}\n\nfloat generateCroissant(vec2 position, float nbCroissant, float theta, float time) {\n    float current = (theta + PI); //[0 - 360]\n    current = mod(current + PI / 2.0, 2.0 * PI);  //offset to put the beguining at the top\n    current = current / (2.0 * PI); //ratio for animation\n\n    float currentCroissant = floor(current * nbCroissant);\n    float amplitude = random(currentCroissant) * 0.9;\n    \n    float range = period(current, nbCroissant);\n    float dist = length(position);\n    range = range * amplitude;\n    dist = dist < range ? range : 0.0;\n    return dist;\n} \n\nvec4 getColor(vec2 pos, float theta, float time){\n    float nbCroissant = 140.0;\n    //nbCroissant = mix(0.0, 200.0, currentTime);\n    \n    //float theta = atan(pos.y, pos.x);\n    float current = (theta + PI); //[0 - 360]\n    current = mod(current + PI / 2.0, 2.0 * PI);  //offset to put the beguining at the top\n    current = current / (2.0 * PI); //ratio for animation\n    \n    vec4 firstRedColor = vec4(0.995,0.454,0.192,1.000);\n    vec4 firstYellowColor = vec4(0.179,0.179,0.995,1.000);\n    vec4 firstColor = mix(firstYellowColor, firstRedColor, easingIn(1.0 - abs((current - 0.5)) * 1.0));\n    vec4 secondColor = vec4(0.995,0.924,0.362,1.000);\n    vec4 backGroundColor = vec4(0.001,0.000,0.005,1.000);\n    \n    float circleRadius = mix(0.0, 0.065, time);\n    float circleWidth = mix(0.01, 0.065, time);\n    \n    float dist = generateCroissant(pos, nbCroissant, theta, time);\n    dist = max(dist, generateCroissant(pos, nbCroissant / 5.0, theta, time)); // play with thoose\n    dist = max(dist, generateCroissant(pos, nbCroissant * 1.8, theta, time)); // play with thoose\n    dist = max(dist, generateSphere(pos, theta, time));\n    //dist = max(dist, easingIn(circle(pos, circleRadius, circleWidth)));\n    vec4 color = dist != 0.0 ? mix(firstColor, secondColor, easingIn(dist)) : backGroundColor;\n    \n    float width = 0.428;\n    float glowRadius = 0.240;\n    float rectBorder = max(rect(pos, vec2(width)), 0.0);\n    if(rectBorder >= 0.0 && rectBorder < glowRadius) {\n        float range = 1.0 - glowRadius;\n        float easing = 1.0 - rectBorder;\n        float coef = 1.0 / glowRadius;\n        rectBorder = (easing - range) * coef;\n        color = mix(color, secondColor, easingIn(rectBorder));\n    }\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = fragCoord/iResolution.xy;\n    st = st * vec2(2.0) - vec2(1.0);\n    vec2 pixelOffset = vec2(1.0) / iResolution.xy;\n\tint blurRadius = 5;\n    \n    float time = getCurrentTime();\n    vec4 color = getColor(st, getAngle(st), time);//;vec4(0.0, 0.0, 0.0, 1.0);\n    \n    for(int i = -1 * BLUR_RADIUS; i < BLUR_RADIUS; i++) {\n        for(int j = -1 * BLUR_RADIUS; j < BLUR_RADIUS; j++) {\n            vec2 offset = vec2(i, j) * pixelOffset;\n            vec2 pos = st + offset;\n            float angle = getAngle(pos);\n            color += getColor(st + offset, angle, time);\n        }\n    }\n    \n    color = color / vec4(BLUR_RADIUS * BLUR_RADIUS);\n    fragColor = color;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}