{
    "Shader": {
        "info": {
            "date": "1506435695",
            "description": "cf Sig'97 Fake Fur rendering [url]http://www.danbgoldman.com/misc/fakefur/fakefur.pdf[/url]\nTYPE: hair combing along:  1: normals 2: parallels 3: meridians\nmouse controls light. (0,0) for demo.\ntry 100% backlight or 100% frontlight",
            "flags": 0,
            "hasliked": 0,
            "id": "4tfczl",
            "likes": 9,
            "name": "microscopic hair layer on sphere",
            "published": 3,
            "tags": [
                "raytracing",
                "hair",
                "fur",
                "brdf",
                "anisotropic",
                "velvet",
                "fuzz",
                "codimension",
                "peach",
                "fibers",
                "vellus"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 1042
        },
        "renderpass": [
            {
                "code": "// A layer of hair on surface cause 2 noticable things:\n// - Strange specular curves on surface (if very dense + highly combed: head, satin... )\n// - Silhouette enhancing (even if very undense and uncombed: peach fuzz + everywhere in nature )\n//\n// some old refs:\n//   Sig'97 Goldman \"Fake Fur rendering\" http://www.danbgoldman.com/misc/fakefur/fakefur.pdf\n//   Sig'89 Kajiya &al \"Rendering Fur with Three Dimensional Texture\" http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.127.5564&rep=rep1&type=pdf\n//   Sig'94 Banks \"Illumination In Diverse Codimensions\" http://www.cs.virginia.edu/~mjh7v/bib/Banks94.pdf\n//   JMVA'03 Koenderink &al \"The secret of velvety skin\" https://pdfs.semanticscholar.org/be5e/bb0a91b5e48650c98b7ed172e4b3fc9b2113.pdf\n// more recent on peach fuzz / Vellus Facial Hair :\n//   Sig17 poster http://www.chloelegendre.com/PeachFuzz_Siggraph2017_AuthorVersion.pdf\n//   Disney's Moana: https://twitter.com/mmalex/status/898214762307362821\n//   http://s2017.siggraph.org/talks/sessions/hair-it\n\nint TYPE = 3;      // hair combing along:   1: normals 2: parallels 3: meridians\nfloat thick = .03; // hair layer thickness\n#define INTEG 1    // 1: integration on thick hair layer 0: infinitesimal\n\n#define crossN(a,b) normalize(cross(a,b))\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O -= O;\n\tvec2 R = iResolution.xy, \n         M = iMouse.xy; \n    if (length(M/R)<.01) {                        // mouse near (0,0) : autodemo mode\n        float t = iTime -3.6; \n        M = (.5+.25*vec2(sin(t),cos(1.7*t)) ) * R;\n        TYPE = 1 + ( int(t/3.) % 5 );\n    }\n#define  scale(U)  2.* ( 2.*(U) - R ) / R.y\n    U =  scale(U);\n    float d = length(U), d0=d,l;                  // d0 = sphere + thick hair layer\n    if (d > 1.+thick) return;                     // now we are on hit point on sphere\n    if (d > 1.) U/=d, d=1.;                       // on thick hair silhouette\n    \n    vec3 E = vec3(0,0,-1.),                       // Eye, Normal and Light directions\n         P = vec3( U, - sqrt(1.-d*d)), N = P,\n         L = vec3( scale(M), 0); l = 1.-dot(L,L);\n    if (l<0.) L /= pow(dot(L,L),2.);              // if light on back side\n    L.z = -sign(l) * sqrt(1.-dot(L,L));\n  //N = normalize(N+.1*sin(100.*P));              // bump (surface+hairs. Hair alone: see T)\n    \n                                                  // --- classical surface shading\n    float mask = smoothstep(0.,-4./R.y, d0-1.-thick), // sphere antialiased mask\n          shad = dot(N,L), \n          diff = clamp(shad,0.,1.);\n    vec4  Cs = (.3 + .8*diff) * vec4(1,0,0,0);    // surface ambiant + diffuse\n\n                                                  // --- hair layer\n    vec3 A = normalize(vec3(0,1,-.5)), T;         // control of fiber axis (cf green spot) \n    float s = dot(A,N), phi = asin(s),            // sphere param (to display blue fibers)\n          theta = asin(dot(normalize(vec3(0,1,0)-A.y*A),normalize(N-s*A)));\n\n#if INTEG                                         // integration on thick hair layer\n if (d0>1.) U *= d0;\n float r = max(1.,d0), n=0.; \n for (; r <= 1.+thick; r += 1./d/R.y, n++ ) {     // sample shells\n    N = vec3( U/r, -sqrt(max(0.,1.-d0*d0/r/r)) ); // normal at pixel U on shell r\n#endif    \n\n\tif (TYPE==1)\n        T = N;//, shad=1.;                        // hairs along normal \n    else {\n        T = crossN(N,A);                          // hairs along parallels\n        if (TYPE==3)\n           T = cross(N,T);                        // hairs along meridians\n    }\n      \n  //T = normalize(T+.1*sin(4e4*P));               // bump hairs\n    \n#define cosA(a,b) dot(a,b)\n#define sinA(a,b) length(cross(a,b)) // = | a-(a.b)b |    // Kajiya89 model:\n    float hd = sinA(T,L),                                 //   diff\n          hs = -cosA(T,L)*cosA(T,E) + sinA(T,L)*sinA(T,E);//   spec NB: to me, - is required\n    hs = pow (max(hs,0.), 1000.);\n                                                          // Goldman97 extension :\n    float  k = dot( crossN(T,L), crossN(T,E) ),           //   directionality \n          fd = (1.+k)/2. * 1. + (1.-k)/2. * 1.,           //   reflect vs transmit\n          dens = .1,                                      //   hair density * hair surface\n          kd = .3, ks = 4.,                               //   hair diff & spec coef *I\n#define opa(D) 1. - exp(-dens* sinA(D,T) / abs(cosA(D,N)) )\n          aE = opa(E), aL = opa(L);                       //   opacity function\n    \n    vec4 Ch = fd*( kd*hd + ks*hs)                         //   hair shading\n             * vec4(1) * smoothstep(-.1,.1,shad);         //   * surface/hair shadowing\n      \n    O += mix( Cs*(1.-aL), Ch*(1.-.5*aL),  aE);    // hair and surface compositing\n#if INTEG\n }\n O /= n;\n#endif\n                                                  // --- additional elements\n    \n    O = mix(O,vec4(0,1,0,0),smoothstep(.7,.5,length(A-P)/.1)); // fiber control pole (green dot )\n\n    if (d0 < 1.) O.b +=                           // draw fibers \n        TYPE==1 ? .6 * cos(50.*theta)*cos(50.*phi)//   along N\n      : TYPE==2 ? .3 * cos(50.*phi)               //   along parallels\n      :           .3 * cos(50.*theta);            //   along meridians\n\n    O.rg += smoothstep(.7,.5,length(L-P)/.1);     // light (yellow dot)\n    O.r  += smoothstep(.7,.5,length(-L-P)/.1);    // anti-light (red dot)\n    O = clamp(O,0.,1.) * mask;                    // sphere antialiasing\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}