{
    "Shader": {
        "info": {
            "date": "1699578511",
            "description": "Nyancats jumping over truchet-ways on an spherical  icosahedron.",
            "flags": 0,
            "hasliked": 0,
            "id": "mtcyDS",
            "likes": 7,
            "name": "nyancats icosahedron jump",
            "published": 3,
            "tags": [
                "3d",
                "sdf",
                "truchet",
                "nyancat",
                "icosahedron",
                "sphericalprojection"
            ],
            "usePreview": 0,
            "username": "cyperus",
            "viewed": 209
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"Nyancats Icosahedron Jump\"\n//\n// created by Colling Patrik (cyperus) in 2023\n//\n//  Code from:\n//   by byt3_m3chanic\n//   - \"Year of Truchets\" #058 https://www.shadertoy.com/view/msVfzR\n//\n//  References:\n//   - https://people.maths.ox.ac.uk/trefethen/lightning.html\n// \n////////////////////////////////////////////////////////////////////////////////\n\n// ray casting bounding shape\nconst float CAM_DIST = 7.;\nconst float CAM_FLE = 1.3;\nconst float BB_DIST = 4.;\nconst float RAY_MIN_DIST = 0.5;\nconst float RAY_MAX_DIST = CAM_DIST+1.1*BB_DIST;\n\nconst int   MAX_MARCHING_STEPS = 300;\nfloat RAY_STEP_FACTOR3 = 0.5;\nconst float RAY_PRECISION = 0.0001;\n\n// shape transformation parameters\n// icosahedron\nconst int PS_f = 20;\nconst int PS_e_f = 3;\nconst float PS_a0 = 12.;\n\n// fog\nconst bool  FOG_ON = true;\nconst float FOG_DENSITY = 2.5E-3;\n\n// data from sdf\nvec4 mat = vec4(0);\n\nfloat map(in vec3 p) {\n    \n    //// sdf's\n    float rxy = 0., au = 0.0, av = 0.0;\n    float cell_id = 0., sr = 0.; //sens of rotation, sig(sr): rotation direction, abs(sr) : number edges\n    vec2 z = vec2(0.);\n           \n    //// map platonic solid cells to one cell\n    vec3 pn = normalize(p);\n    \n    // icosahedron\n    // projection from n cells to 1 cell. \n    pn = icosa_cells(pn, cell_id, sr);\n    \n    // invers stereographic projection\n    z = pn.xy/(1.-pn.z);\n    z = cIcosaPolyArc2disk(z);\n    \n    // set parameters\n    vec2 e = vec2(1.8, 0.18);\n\n    /// r-polygon-distribution\n    float en = 1.+( (PS_a0<0.?e.x:e.y)-1. )*smoothstep(1.,5., abs(PS_a0));        \n    float r = length(z); vec2 zn = z/r;\n    z = dist(r, en) * zn;     \n\n    /// stereograpic projection    \n    pn = sp(vec3(z,sr));\n\n    /// scale radius\n    p = length(p) * pn;\n    ////fractal level 0: Torus\n    // 3D-space: cartesian3D => cylinder3D transformation\n    au = atan(p.y, p.x);\n    rxy = length(p.xy);\n    // 2D-space: complex plane := radial plane in cylinderc3d coordinates  \n    z = vec2(rxy, p.z);\n    \n    // 2Djulia :realaxis-translation, fraction == 2 => (torus,sphere,2spheres) \n    z = cmul(z,z); z.x -= PS_a0;\n    \n    // distance estimation shape\n    float d = log(length(z));\n    \n    // torus complex plane, torus angle_u, platonic solid cell_id\n    mat.xy = z; mat.z = au, mat.w = cell_id;\n    return d;\n}\n\nfloat intersect(in vec3 ro, in vec3 rd, in float px) {\n    float res = -1.0; // init no intersection\n    \n    // bounding shape BB\n    vec2 dis = isphere( ro, rd , abs(BB_DIST));\n    \n    if( dis.y<0.0 ) return -1.0; // check BB behind came\n\n    dis.x = max( dis.x, RAY_MIN_DIST ); // check min ray length\n    dis.y = min( dis.y, RAY_MAX_DIST ); // check max ray length\n\n    // raymarch signed distance field    \n\tfloat fh = RAY_STEP_FACTOR3;\n    float t = dis.x; // ray starts at boundingbox\n    for( int i=0; i<MAX_MARCHING_STEPS; i++  ) // max steps\n    { \n        vec3 pos = ro + rd*t;\n        float th = RAY_PRECISION * px * t; //th = 0.0001; // minimal bound surface hit\n        float h = map( pos);\n        if( t>dis.y || h<th ) break; // ray outside BB or hit.\n        t += h*fh; // distance\n    }\n    if( t<dis.y ) // ray inside BB\n    {\n        res = t;\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 p, in float prec ) {\n    vec2 e = vec2( prec, 0. );\n    return normalize(vec3(\n\t\tmap(p+e.xyy) - map(p-e.xyy),\n\t\tmap(p+e.yxy) - map(p-e.yxy),\n\t\tmap(p+e.yyx) - map(p-e.yyx) )\n    \t);\n}\n\nvec3 transform(in vec3 p, in float time) {\n\t// camera transformation\n\tif (iMouse.x > 0.0)\n\t{\n        vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\t\tp.yz = crot(p.yz,-PI*m.y);\n\t\tp.zx = crot(p.zx,-PI*m.x);\n\t}\n    p.yz = crot(p.yz,-PI*0.002*time-0.3);\n    p.zx = crot(p.zx,-PI*0.001*time-0.3);\n\treturn p.xyz;\n}\n\n// textures\nfloat grid_uv(in vec2 uv) {\n    // uv grid alpha mask\n    const float sig = 1.; // switch pattern sig in {-1.,+1.}\n    vec2 sw = abs(fract(uv-0.25)-0.5)-0.25;\n    float sdf = sig*min(sw.x,sw.y)*-max(sw.x,sw.y);\n    float pp = fwidth(sdf);\n    return smoothstep(+pp,-pp,sdf);\n}\n            \nvec4 cells(in vec2 uv, in float ps_id ,in int ps_f) {\n    // sectors, uv-grid\n    vec4 C;\n    float sdf = abs(abs(uv.y)-.05)-.05; float px = fwidth(sdf);\n\n    C.a = 1.-smoothstep(px+.01,-px,sdf);\n    C.rgb = h2rgb(ps_id/float(ps_f));      // sector -> col\n    C.rgb *= (0.5+ 0.5 * grid_uv(uv))*0.7; // uv-grid -> value\n    return C;\n}\n\nvec4 ribbon(in float uv_x, in float time) {\n    float sdf = -(2.*pulsecollision(1.,1./3. * uv_x, time, 2./6.)-1.);\n    float px = fwidth(sdf);\n    return vec4( h2rgb(sdf -2./6.)\n               , smoothstep(px+0.1,-px-0.1,sdf+0.2) );\n}\n\nvec4 nyancat(vec2 z, float scale, vec2 ju, float time) {   \n    z.x = fract(z.x-time/scale);        // run, input z.x in [0., 1.], periodic & cyclic in x-direction (0)\n    z.y = fract(z.y);                   // periodic in y-direction (comment in out)\n    z *= scale;\n    z.y -= ju.x*abs(cos(PI*ju.y*time)); // jump, amplitude, frequency\n    vec4 C = vec4(0.);\n    if ((.05<z.x&&z.x<.9)&&(0.<z.y&&z.y<.65)) { // BB rectangle\n        C = texture(iChannel1, vec2(40./256.*(z.x+floor(6.*fract(ju.y*time))),z.y+.2));\n        C.rgb = srgb2rgb(C.rgb);\n    }\n    return C;\n}\n\nvec4 truchet(in vec2 uv, float time) {\n    // fork: https://www.shadertoy.com/view/msVfzR by byt3_m3chanic   \n    // coords\n    vec2 dv = fract(uv)-.5,\n         id = floor(uv);\n    \n    // random\n    float rnd = hash21(id);\n    \n    // colors\n    vec4 O; vec4 C;\n    float sdf; float px;\n    \n    // signed distance functions\n    if(rnd<.5) dv.x = -dv.x;\n    \n    vec2  gx = length(dv-.5)<length(dv+.5)\n             ? vec2(dv-.5)\n             : vec2(dv+.5);  \n    \n    float cx = (fract(rnd*77.57+time)>.75)\n             ? min(abs(dv.x),abs(dv.y))\n             : length(gx)-.5;\n    \n    // tiles\n    sdf = abs(cx);  px = fwidth(sdf);\n    C.a = smoothstep(px,-px,sdf-.12);\n    C.rgb = h2rgb(\n                time\n                -uv.x*.075\n                +fract(rnd*147.32+(time*.05))*.35\n                )*.5;\n    O = C;\n    \n    // boder lines\n    sdf = abs(abs(cx)-.12); px = fwidth(sdf);\n    C.a = smoothstep(px+.02,-px,sdf-.02);\n    O = mix(O,vec4(1.), C.a);\n    return O;\n}\n\n//\nvoid mainImage(out vec4 O, in vec2 fragCoord) {\n    // slider mapping\n    RAY_STEP_FACTOR3 = (0.5-0.0001)* pow(RAY_STEP_FACTOR3, 3.) + 0.0001;\n    \n    // anti-aliasing to take a picture\n    vec3 tot = vec3(0.0);\n    #define AA 1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {       \n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 uv = (2.0*(fragCoord+o) - iResolution.xy)/iResolution.y;\n        \n        // camera viewport --> worldspace\n        vec3 ro = vec3(0,0,-CAM_DIST);\n        vec3 rd = vec3(-uv.x,uv.y,CAM_FLE);\n             ro = transform(ro,iTime);\n             rd = normalize(transform(rd,iTime));\n        \n        // ray\n        float px = 2.0/( iResolution.y*CAM_FLE );\n        float t = intersect( ro, rd, px ); // distance hit ray surface\n\n        // color\n        // drawing layers\n        // sdf = ... ; px = fwidth(d);\n        // C.a = smoothstep(px+.035,-px,sdf-.125);\n        // C.rgb = ... ;\n        //   near -> far : if(O.a<1.) { O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;}\n        //   far -> near :  O = mix( O, vec4( C.rgb, 1), C.a );\n        vec3 col_sun = vec3(1.,1.,0.8);\n        vec3 col_sky = 0.5 * vec3(0.7,0.7,1.);\n\n        // background\n        vec4 C = vec4(col_sky,1.);\n        O = C;\n        \n        // object surface\n        if (t >= 0.) {\n            // surface properties\n            vec3 p = ro + rd * t;\n            vec3 n = calcNormal( p, 0.001);\n            \n            // platonic solid sector id\n            float ps_id = mat.w;\n            \n            // uv-coords\n            vec2 mat_uv = 0.5*vec2(mat.z, atan(mat.y,mat.x))/PI;\n            vec2 mat_ny = mat_uv;\n            \n            mat_uv.xy *= vec2(3.*6.,4.); // uv-grid\n            \n            mat_ny += vec2(0.,1./3.);    // nyancat\n            mat_ny *= vec2(6.,1.);\n            \n            // draw texture layers from back to front\n            O = vec4(vec3(0.1,0.1,1.)*0.7,1.);\n            \n            C = cells(mat_uv, ps_id, PS_f);\n            O = mix(O, vec4(C.rgb, 1.), C.a);            \n            \n            C = truchet(mat_uv, 0.05*iTime);\n            O = mix(O, vec4(C.rgb, 1.), C.a);\n            \n            C = nyancat(mat_ny.xy, 3., vec2(0.1,1.), 0.3*iTime); \n            O = mix(O, vec4(C.rgb, 1.), C.a);\n            \n            C = ribbon(mat_uv.x, 0.0125*iTime);\n            O = mix(O, vec4(C.rgb, 1.), C.a);\n\n            // lighting\n            vec3  came_li_o         = transform(vec3(-10.,10.,-10.),iTime); // origine\n            vec3  came_li_dir       = normalize(p - came_li_o);             // direction\n            vec3  came_li_col       = vec3(1.,1.,.5);                       // color\n            float came_li_spec_shi  = 10.;                                  // shininess          \n\n            O.rgb += O.rgb * 0.1 * col_sky;\n            O.rgb += O.rgb * 0.5 * came_li_col * clamp(dot(-came_li_dir, n), 0., 1.);\n            \n            float cosa = pow(clamp(dot(reflect(came_li_dir, n), -rd), 0., 1.), came_li_spec_shi);           \n            vec3 spec_col = vec3(0.);          \n            if (cosa > 0.) {\n              spec_col = came_li_col * cosa;    \n            }\n            O.rgb += 0.4 * spec_col;\n            \n            // fresnel\n            O.rgb += pow(clamp(1. - dot(n, -rd), 0., 1.), 5.) * 0.4 * col_sky;\n            \n            // fog\n            if(FOG_ON)\n                O.rgb = mix(O.rgb, col_sky, 1.0 - exp(-FOG_DENSITY * pow(t,3.)));    \n        }\n        tot += O.rgb;\n    }\n    tot /= float(AA*AA);\n    \n    // gamma correction\n    O = vec4(rgb2srgb(tot),1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// References:\n//   https://people.maths.ox.ac.uk/trefethen/lightning.html\n//   https://iquilezles.org/\n\n// const\nconst float PI = abs(atan(0.,-1.));\n\n/// 1D transformations\nfloat pulsecollision(in float pf, in float x, in float x0, in float pw) {\n    /*\n    x  : periodic in [0,1]\n    x0 : offset\n    pw : pulse width in [0,1]\n    pf : pulse frequency \n    */\n    float ntriw_p = abs( fract( pf*(x - x0) )-0.5); // x_normalized triangle wave function moving in +x_direction\n    float ntriw_n = abs( fract( pf*(x + x0) )-0.5); // x_normalized triangle wave function moving in -x_direction\n    float pp = smoothstep( 0.5*pw, 0., ntriw_p );   // pulse moves in +x_direction\n    float pn = smoothstep( 0.5*pw, 0., ntriw_n );   // pulse moves in -x_direction\n    return (pp+pn); // in[0.,2.]\n    //return (pp+pn)-(pp*pn);// in [0.,1.]\n}\n\nfloat hash21(vec2 p) {\n    return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453);\n}\n\n/// 2D transformations\n/// complex\nvec2 cmul(vec2 za,vec2 zb){\n    return za*mat2(zb.x,-zb.y,zb.yx);}\n\nvec2 crot(vec2 z,float a){\n    return cmul(vec2(cos(a),sin(a)),z);}\n\nvec2 cinv(vec2 z){\n    return z*vec2(1,-1)/dot(z,z);}\n    \nvec2 cdiv(vec2 z, vec2 w){\n    return cmul(z,cinv(w));}\n\n// polynomial barycentric approximation\nvec2 cIcosaPolyArc2disk(vec2 z){\n    const int NUM_j = 18; // poles\n    const vec2[] rf = vec2[NUM_j]\n    (vec2(-1.0000,  0.0081)\n    ,vec2( 0.9973, -0.0741)\n    ,vec2( 0.5000,  0.8660)\n    ,vec2( 0.5000,  0.8660)\n    ,vec2( 0.5000, -0.8660)\n    ,vec2( 0.5000, -0.8660)\n    ,vec2(-0.5628, -0.8266)\n    ,vec2( 0.7134,  0.7008)\n    ,vec2(-0.6770,  0.7360)\n    ,vec2( 0.5660, -0.8244)\n    ,vec2( 0.4380, -0.8990)\n    ,vec2( 0.4776,  0.8786)\n    ,vec2(-1.0000,  0.0000)\n    ,vec2(-1.0000, -0.0000)\n    ,vec2(-0.9975, -0.0702)\n    ,vec2( 0.5013,  0.8653)\n    ,vec2( 0.4987, -0.8668)\n    ,vec2(-1.0000, -0.0015));\n\n    const vec2[] rw = vec2[NUM_j] \n    (vec2( 0.1913, -0.0   )\n    ,vec2( 0.0675, -0.5245)\n    ,vec2( 0.0000,  0.0000)\n    ,vec2(-0.0217,  0.0173)\n    ,vec2( 0.0000,  0.0000)\n    ,vec2( 0.0227, -0.0136)\n    ,vec2(-0.1778,  0.1022)\n    ,vec2( 0.4571, -0.0498)\n    ,vec2( 0.1298,  0.1710)\n    ,vec2(-0.1199, -0.3334)\n    ,vec2(-0.1620,  0.2846)\n    ,vec2(-0.1091,  0.1608)\n    ,vec2(-0.0000,  0.0000)\n    ,vec2( 0.0220,  0.0049)\n    ,vec2(-0.2238,  0.0539)\n    ,vec2( 0.1257,  0.0310)\n    ,vec2(-0.1355, -0.0377)\n    ,vec2(-0.0667,  0.1333));\n\n    const vec2[] rz = vec2[NUM_j]\n    (vec2(-0.3057,  0.0242)\n    ,vec2( 0.1872, -0.0101)\n    ,vec2( 0.1691,  0.2929)\n    ,vec2( 0.1692,  0.2924)\n    ,vec2( 0.1691, -0.2929)\n    ,vec2( 0.1686, -0.2927)\n    ,vec2(-0.1024, -0.1571)\n    ,vec2( 0.1839,  0.1273)\n    ,vec2(-0.1198,  0.1468)\n    ,vec2( 0.1795, -0.1922)\n    ,vec2( 0.0805, -0.2533)\n    ,vec2( 0.1099,  0.2669)\n    ,vec2(-0.3383,  0.0   )\n    ,vec2(-0.3378, -0.0004)\n    ,vec2(-0.2597, -0.0569)\n    ,vec2( 0.1715,  0.2728)\n    ,vec2( 0.1505, -0.2850)\n    ,vec2(-0.3221, -0.0121));\n    \n    // polynomial barycentric representation\n    vec2 zn = vec2(0.); vec2 zd = vec2(0.);       \n    for(int j = 0; j<NUM_j; j++)\n    {\n        vec2 zj = cdiv( rw[j], (z-rz[j]));\n        zd += zj; // sum denominator\n        zn += cmul(rf[j], zj); // sum nominator\n    }\n    return cdiv(zn, zd);\n}\n\n/// 3D transformations\nmat3 rot3(in vec3 v, in float a) {// rotation from axis angle \n float c = cos(a);\n float s = sin(a);\t\n return mat3\n (c + (1.0 - c) * v.x * v.x,               (1.0 - c) * v.x * v.y - s * v.z,     (1.0 - c) * v.x * v.z + s * v.y,\n      (1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y,               (1.0 - c) * v.y * v.z - s * v.x,\n      (1.0 - c) * v.x * v.z - s * v.y,     (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z);\n}\n\n// map spherical platonic solid pyramidal-face-cells to one cell located at -z-axis.\nvec3 icosa_cells(in vec3 p, out float cell_id, out float sr){\n\t// icosahedron\n\tconst float phi = (0.5+sqrt(1.25));\n\t// cell-wall-face-normals defined by 2 edge points and the origine.\n\t//----------------------------------------\n    bool ZpYp_ZpYn = dot(vec3( 1., 0., 0.) ,p)>=0.; // yz-rectangle edge\n    \n\tbool XpZp_ZpYp = dot( cross(vec3(+phi,0,+1),vec3(0,+1,+phi)) ,p)>=0.;\n\tbool XpZp_ZpYn = dot( cross(vec3(+phi,0,+1),vec3(0,-1,+phi)) ,p)>=0.;\n    \n\tbool XnZp_ZpYp = dot( cross(vec3(-phi,0,+1),vec3(0,+1,+phi)) ,p)>=0.;\n    bool XnZp_ZpYn = dot( cross(vec3(-phi,0,+1),vec3(0,-1,+phi)) ,p)>=0.;\n    //----------------------------------------\n    bool XpZp_XpZn = dot(vec3( 0., 1., 0.) ,p)>=0.; // zy-rectangle edge\n    \n\tbool YpXp_XpZp = dot( cross(vec3(+1,+phi,0),vec3(+phi,0,+1)) ,p)>=0.;\n\tbool YpXp_XpZn = dot( cross(vec3(+1,+phi,0),vec3(+phi,0,-1)) ,p)>=0.;\n    \n\tbool YnXp_XpZp = dot( cross(vec3(+1,-phi,0),vec3(+phi,0,+1)) ,p)>=0.;\n    bool YnXp_XpZn = dot( cross(vec3(+1,-phi,0),vec3(+phi,0,-1)) ,p)>=0.;\n\t//----------------------------------------\n\tbool YpXp_YpXn = dot(vec3( 0., 0., 1.) ,p)>=0.; // xy-rectangle edge\n    \n\tbool ZpYp_YpXp = dot( cross(vec3(0,+1,+phi),vec3(+1,+phi,0)) ,p)>=0.;\n\tbool ZpYp_YpXn = dot( cross(vec3(0,+1,+phi),vec3(-1,+phi,0)) ,p)>=0.;\n    \n\tbool ZnYp_YpXp = dot( cross(vec3(0,+1,-phi),vec3(+1,+phi,0)) ,p)>=0.;\n    bool ZnYp_YpXn = dot( cross(vec3(0,+1,-phi),vec3(-1,+phi,0)) ,p)>=0.;\n\t//----------------------------------------   \n    \n\t// cells\n    //const float a = atan(1.5-sqrt(1.25)); // angle face center -> edge center\n    const float a = atan(0.5*(3.-sqrt(5.)));\n    vec2 ei_yy = vec2(cos(a),sin(a));\n    const float b = PI/3.; // 60°\n    vec2 ei_zz = vec2(cos(b),sin(b));\n    float a_x = 0.; float a_y = 0.; float a_z = 0.;\n\t// ---------------------------------------------------------------\n    if     ( ZpYp_ZpYn && !XpZp_ZpYn   &&  XpZp_ZpYp) { cell_id = 0.;\n        //p.xyz = p.xyz;\n        #if 0\n        a_y = -a+PI;\n        #else\n        p.zx = -p.zx;\n        a_y = -a;\n        #endif\n\t}\n\telse if(!ZpYp_ZpYn &&  XpZp_ZpYn   && !XpZp_ZpYp) { cell_id = 1.; /*opposite side*/\t\n        //p.xyz = p.xyz;\n\t\ta_y = -a;\n\t}\n\t//\n\telse if(!ZpYp_ZpYn &&  XnZp_ZpYn   && !XnZp_ZpYp) { cell_id = 2.;\n        //p.xyz = p.xyz;\n\t\ta_y = +a-PI;\n\t\ta_z = +b;\n\t}\n\telse if( ZpYp_ZpYn && !XnZp_ZpYn   &&  XnZp_ZpYp) { cell_id = 3.; /*opposite side*/\n        //p.xyz = p.xyz;\n\t\ta_y = +a;\n\t\ta_z = -b;\n\t}\n\t// ---------------------------------------------------------------\n    else if( YpXp_YpXn && !ZpYp_YpXn   &&  ZpYp_YpXp) { cell_id = 4.;\n        p.xyz = p.zxy;\n        a_y = -a+PI;\n    }\n    else if(!YpXp_YpXn &&  ZpYp_YpXn   && !ZpYp_YpXp) { cell_id = 5.; /*opposite side*/\n        p.xyz = p.zxy;\n\t\ta_y = -a;\n    }\n    //\n    else if(!YpXp_YpXn && !ZnYp_YpXp   &&  ZnYp_YpXn) { cell_id = 6.;\n        p.xyz = p.zxy;\n\t\ta_y = +a-PI;\n\t\ta_z = +b;        \n    }\n    else if( YpXp_YpXn &&  ZnYp_YpXp   && !ZnYp_YpXn) { cell_id = 7.; /*opposite side*/\n        p.xyz = p.zxy;\n\t\ta_y = +a;\n\t\ta_z = -b;\n    }\n\t// ---------------------------------------------------------------\n    else if( XpZp_XpZn && !YpXp_XpZn   &&  YpXp_XpZp) { cell_id = 8.;\n        p.xyz = p.yzx;\n        a_y = -a+PI;\n    }\n    else if(!XpZp_XpZn &&  YpXp_XpZn   && !YpXp_XpZp) { cell_id = 9.; /*opposite side*/\n        p.xyz = p.yzx;\n\t\ta_y = -a;\n    }\n    //\n    else if(!XpZp_XpZn && !YnXp_XpZp   &&  YnXp_XpZn) { cell_id = 10.;\n        p.xyz = p.yzx;\n\t\ta_y = +a-PI;\n\t\ta_z = +b;\n    }\n    else if( XpZp_XpZn &&  YnXp_XpZp   && !YnXp_XpZn) { cell_id = 11.; /*opposite side*/\n        p.xyz = p.yzx;\n\t\ta_y = +a;\n\t\ta_z = -b;\n    }\n\t// ---------------------------------------------------------------    \n    else if(!XpZp_ZpYp && !YpXp_XpZp   && !ZpYp_YpXp) { cell_id = 12.;\n        //p.xy = p.xy;\n        mat3 m3 = rot3(normalize(vec3(phi,0.,1.)), 2.*PI/5.); p = p*m3;\n        a_y = -a+PI;\n    }\n    else if( XpZp_ZpYp &&  YpXp_XpZp   &&  ZpYp_YpXp) { cell_id = 13.; /*opposite side*/\n        //p.xy = p.xy;\n        mat3 m3 = rot3(normalize(vec3(phi,0.,1.)), 2.*PI/5.); p = p*m3;\n\t\ta_y = -a;\n    } \n    // ---------------------------------------------------------------\n    else if( XnZp_ZpYp &&  ZpYp_YpXn   &&  (YnXp_XpZn)) { cell_id = 14.;\n        p.xy = -p.xy;\n        mat3 m3 = rot3(normalize(vec3(phi,0.,1.)), -2.*PI/5.); p = p*m3;\n        a_y = -a+PI;\n    }\n    else if(!XnZp_ZpYp && !ZpYp_YpXn   && !(YnXp_XpZn)) { cell_id = 15.; /*opposite side*/\n        p.xy = -p.xy;\n        mat3 m3 = rot3(normalize(vec3(phi,0.,1.)), -2.*PI/5.); p = p*m3;\n\t\ta_y = -a;\n    }\n    // ---------------------------------------------------------------\n    else if(!XnZp_ZpYn && !(ZnYp_YpXp) && !(YpXp_XpZn)) { cell_id = 16.;\n        p.xy = -p.xy;\n        mat3 m3 = rot3(normalize(vec3(phi,0.,1.)), 2.*PI/5.); p = p*m3;\n        a_y = -a+PI;\n    }\n    else if( XnZp_ZpYn &&  (ZnYp_YpXp) &&  (YpXp_XpZn)) { cell_id = 17.; /*opposite side*/\n        p.xy = -p.xy;\n        mat3 m3 = rot3(normalize(vec3(phi,0.,1.)), 2.*PI/5.); p = p*m3;\n\t\ta_y = -a;\n    }\n    // ---------------------------------------------------------------\n    else if( XpZp_ZpYn &&  (ZnYp_YpXn) &&  YnXp_XpZp) { cell_id = 18.;\n        //p.xy = p.xy;\n        mat3 m3 = rot3(normalize(vec3(phi,0.,1.)), -2.*PI/5.); p = p*m3;\n        a_y = -a+PI;\n    }\n    else if(!XpZp_ZpYn && !(ZnYp_YpXn) && !YnXp_XpZp) { cell_id = 19.; /*opposite side*/\n        //p.xy = p.xy;\n        mat3 m3 = rot3(normalize(vec3(phi,0.,1.)), -2.*PI/5.); p = p*m3;\n\t\ta_y = -a;\n    }\n    // --------------------------------------------------------------- \n\t// cell orientation\n\tvec2 ei_y = vec2(cos(a_y),sin(a_y)); p.zx = cmul(p.zx,ei_y); // rotate around y-axis\n\tvec2 ei_x = vec2(cos(a_x),sin(a_x)); p.yz = cmul(p.yz,ei_x); // rotate around x-axis\n\tvec2 ei_z = vec2(cos(a_z),sin(a_z)); p.xy = cmul(p.xy,ei_z); // rotate around z-axis\n\t// non cyclic\n\tsr = 3.;  \n    return p;\n}\n\n// stereographic projection \nfloat sig(float x) {\n    return x < 0. ? -1. : +1.; \n    }\n\nfloat dist(float x, float e) {\n    // e in [0., +inf]\n    return sign(x)*abs( pow(sign(x)*x, abs(e)) );\n    //return sign(x)*abs( pow(abs(x), abs(e)) );\n    }\n   \nvec2 r_poly_dist(vec2 z, vec2 e, float sh_a)\n{   \n    /// r-polygon-distribution\n    float r = length(z); z = z/r; // TEST: (ERROR) division by zero\n    float d0 = 0.5 *abs(e.y-e.x);\n    float e2 = e.x + d0 + d0 * (2.*smoothstep(-1., 1., -sh_a) - 1.);\n    //    float e2 = e.x + d0 * 2. * smoothstep(-1., 1., -sh_a);\n    return dist(r, e2) * z;\n}\n\nvec3 sp(vec3 zsr)\n{\n    vec2 z = zsr.xy; float sr = zsr.z;\n    // stereopraphic projection (complex plane to unit sphere)\n    float zz = dot(z,z); vec3 pn;\n    if (bool(sig(sr))) {// north pole\n        pn = vec3(2. * z.x,  2. * z.y, -1. + zz);\n        }\n    else { // south pol\n        z = cinv(z);\n        pn = vec3(2. * z.x, -2. * z.y,  1. - zz);\n        }\n    pn /= 1.+zz;\n    return pn;\n}\n\nvec3 spb(vec3 zsr)\n{\n    vec2 z = zsr.xy; float sr = zsr.z;\n    // inverse stereograpic projection\n    float k = 2./(1.+dot(z,z)); vec3 pn;\n    if (bool(sig(sr))) {// north pole\n        pn = vec3(k*z, k-1.); }\n    else { // south pol\n        z = cinv(z);\n        pn = vec3(k*z, -(k-1.)); }\n    return pn;\n}\n\n// bb\nvec2 isphere(in vec3 ro, in vec3 rd, in float r) {\n    // https://iquilezles.org/\n\tfloat b = dot(ro,rd);\n\tfloat c = dot(ro,ro) - r*r;\n    float h = b*b - c;   \n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return -b + vec2(-h,h);\n}\n\nvec3 h2rgb(float h){\n    vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return rgb*rgb*(3.0-2.0*rgb); /* cubic smoothing */\n}\n\nvec3 hsv2rgb(float h, float s, float v){     \n    return v * mix( vec3(1.0), h2rgb(h), s); /* hue, saturation, value */\n}\n\n// srgb <--> rgb (linear)\nvec3 srgb2rgb(vec3 col) {\n    return pow(col, vec3(2.2));\n}\n\nvec3 rgb2srgb(vec3 col) {\n    return pow(col, vec3(1./2.2));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}