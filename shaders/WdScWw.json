{
    "Shader": {
        "info": {
            "date": "1591467802",
            "description": "fast made compofiller for Revision 2020\nSorry, had just an hour to come up with this mess. But thatÂ´s what compofillers are about :)\nHi las.\nSigning off, the compo saving crew",
            "flags": 32,
            "hasliked": 0,
            "id": "WdScWw",
            "likes": 15,
            "name": "flitzekacke",
            "published": 3,
            "tags": [
                "4k",
                "demoscene",
                "volumetric"
            ],
            "usePreview": 1,
            "username": "Virgill",
            "viewed": 507
        },
        "renderpass": [
            {
                "code": "//Madtracer ftw\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 uv = (fragCoord.xy/iResolution.xy);\n    fragColor = texture(iChannel0, uv);\n}\n\n//-------------------------------------------------------------------------------------------\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\n\nvoid dmin(inout vec3 d, float x, float y, float z)\n{\n\tif( x < d.x ) d = vec3(x, y, z);\n}\n\n// 3D noise function (IQ)\nfloat noise(vec3 p)\n{\n\tvec3 ip=floor(p);\n\tp-=ip;\n\tvec3 s=vec3(7, 157, 113);\n\tvec4 h=vec4(0, s.yz, s.y+s.z)+dot(ip, s);\n\tp=p*p*(3.-2.*p);\n\th=mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\n\th.xy=mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat hash11(float seed)\n{\n    return fract(sin(seed)*43758.5453 );\n}\n\n// method by fizzer\nvec3 hashHs(vec3 n, float seed)\n{\n    float u = hash11( 78.233 + seed);\n    float v = hash11( 10.873 + seed);\n    float a = 6.2831853 * v;\n    u = 2.0*u - 1.0;\n    return normalize( n + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );\n}\n// smooth minimum function (iq)\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// signed distance capsule function\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// 2d box\nfloat box(vec2 p)\n{\n\tp=abs(p); return max(p.x, p.y);\n}\n\n\n// rotation\nvoid pR(inout vec2 p, float a)\n{\n\tp = cos(a)*p+sin(a)*vec2(p.y, -p.x);\n}\n\n\n//***************************************************************************************************\n// MAP\n//***************************************************************************************************\n\nfloat pattern(vec2 p)\n{\n    p.x += 5.;\n    p.y *= 2.;\n    p = floor(p*2.);\n    p.y += floor(iTime*2.)*17.;\n    p = floor(p);\n    return (sin(p.y*p.y) > 0.8) ? 2. : .99;\n}\n\n\n\n\n\nvec3 map(vec3 p)\n{\n\tvec3 d = vec3(1, 0, 0);\n    float floornoise = .8*noise(3.*p+0.2*iTime)+0.1*noise(15.*p+0.1*iTime); // noise for the floor\n\n    \n    if (iTime<=10.)\n    {\n    \n    dmin(d, 2.8+p.y, .55, 0.); \t\t\t// floor\n    dmin(d, 0.8-p.y, pattern(p.xz+p.zx),0.); // ceil\n\tdmin(d, sdCapsule(p,vec3( -15,0,1),vec3( 15,0,1),.8+1.6*floornoise),.1+floornoise,0.); // glowing capsule\n\t}    \n\n\n    if (iTime>10.&&iTime<=20.)\n    {\n    \n    dmin(d, 2.8+p.y, .05, 0.); \t\t\t// floor\n    dmin(d, 0.8-p.y, pattern(p.xz),0.); // ceil\n    float sd = length(p+vec3(0, 0, 2))-.5;\n\tfloat sd2=mod(sd,.5);\n    dmin(d, sd2, .1, 0.); \t\t\t\t// sphere\n    dmin(d, sd, .1, 0.); \t\t\t\t// sphere\n\t}    \n\n\n    if (iTime>20.&&iTime<=30.)\n    {    \n    dmin(d, 0.6*sin(6.*p.x+1.6*iTime)+p.y, .05, 0.); \t\t\t// floor\n    dmin(d, 0.8-p.y, pattern(p.xz),0.); // ceil\n\t} \n\n\n    if (iTime>30.)  \n    {\n    vec3 q = p - 0.9*iTime*vec3(0, 1, 0);\n\n\n\tpR(q.yz, 1.);\n\n\n\tfloat cd = length(p.xz-vec2(0, -3)), sd = length(p+vec3(0, 0, 2))-.5;\n\tdmin(d, 0.6+0.01*sin(8.*p.z+iTime)*sin(6.*p.x+1.6*iTime)+p.y, .05, 0.); \t\t\t// floor\n\tdmin(d, 1.5-abs(p.x), .99, 0.); \t\t// sides\n\tdmin(d, 0.8-p.y, pattern(p.xz),0.); // ceil\n\tdmin(d, sd, .1, 0.); \t\t\t\t// sphere\n\n\n\tq = abs(p);\n\tq.x -= 1.5;\n\tq.y -= 0.4;\n\n\n\tq = abs(p-round(p-.5)-.5);\n\tdmin(d, max(max(\n\t\tmin(min(box(q.xy), box(q.xz)), box(q.yz))-.05,\n\t\tmin(.6-abs(p.x+p.z), .45-abs(p.y))\n\t), 1.8-cd), .1, .5); \t\t\t\t// lattice\n    }\n    \n\n\treturn d;\n}\n\nvec3 normal(vec3 p)\n{\n\tvec2 e = vec2(0, .0001);\n\treturn normalize(map(p).x-vec3(map(p - e.yxx).x, map(p - e.xyx).x, map(p - e.xxy).x));\n}\n\n\n\n\n//***************************************************************************************************\n// main\n//***************************************************************************************************\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n    //scene = 5;\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\t// borders :(\n\tif( uv.y>.2 && uv.y<.8)\n\t{\n\t\tfloat seed = sin(fragCoord.x + fragCoord.y)*sin(fragCoord.x - fragCoord.y)+fract(iTime), t1 = 0., t2 = 0., t3=0.;\n\n\n\t\t// camera\n\t\tvec3 ro1 = vec3(0, 0, -5.), rd1 = normalize(vec3((2.*fragCoord.xy-iResolution.xy)/iResolution.x, 1));\n\t\t// rotate scene\n\t\tpR(rd1.xz,-.05*sin(.17*iTime));\n\t\tpR(rd1.yz, .02*sin(.19*iTime));\n\n//***************************************************************************************************\n// Cast ray\n//***************************************************************************************************        \n       \n\t\tvec3 scol = vec3(0);\t\t\t\t\t\t\t\t\t\t// clear color accumulator \n\n\t\tvec3 m1=vec3(0), m2, m3, ro2,ro3,rd2,rd3, nor2, nor3, roold=ro1, rdold=rd1;\n\t\tfor( int i = 0; i < 140; i++ )\n\t\t{\n\t\t\tseed+=0.1;\n\t\t\tro1=mix(roold, hashHs(ro1, seed), .002);\t\t\t\t// antialiasing\n\t\t\tif (fract(0.2*iTime)>0.8)rd1=mix(rdold,hashHs(rdold,seed),0.02*(t1-2.4));\t\t\t// dof (strength*(focus-t1))\n            m1 = map(ro1+rd1*t1);\n\t\t\tt1+=.25*(m1.z!=0. ? abs(m1.x) : m1.x);\n\t\t\t\n            // bounce 1:\n\t\t\tro2 = ro1 + rd1*t1;\n\t\t\tnor2 = normal(ro2); \t\n            seed+=0.1;\n\t\t\trd2 = mix(reflect(rd1,nor2),hashHs(nor2,seed),m1.y);\t// reflect depending on material\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tm2 = map(ro2+ rd2*t2); \n\t\t\tt2+=.25*(m2.z!=0. ? abs(m2.x) : m2.x);\n            \n            // bounce 2:\n            ro3 = ro2 + rd2*t2;\n\t\t\tnor3 = normal(ro3); \t\n            seed+=0.1;\n\t\t\trd3 = mix(reflect(rd2,nor3),hashHs(nor3,seed),m2.y);\t// reflect depending on material\t\n            m3 = map(ro3+rd3*t3); \n\t\t\tt3+=.25*(m3.z!=0. ? abs(m3.x) : m3.x);            //\n\n\n\t\t\t// changed for intensity of emitting materials\n\t\t\tscol += vec3(1.+m1.z, 1., 1.-m1.z)*step(1., m1.y)*(m1.y-1.) \n                  + vec3(1.+m2.z, 1., 1.-m2.z)*step(1., m2.y)*(m2.y-1.)\n            \t  + vec3(1.+m3.z, 1., 1.-m3.z)*step(1., m3.y)*(m3.y-1.);\n\t\t}\n\n\n\t\t//fragColor =vec4(scol*0.02,0); //without blur\n\t\tfragColor =clamp(vec4(.005*scol+texture(iChannel0, uv).xyz, 0.)*.8, 0., 1.); // with blur\n\t}\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}