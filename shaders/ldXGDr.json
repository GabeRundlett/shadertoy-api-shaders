{
    "Shader": {
        "info": {
            "date": "1367327090",
            "description": "An optical illusion to make a regular grid appear distorted. Click to remove the spots.",
            "flags": 0,
            "hasliked": 0,
            "id": "ldXGDr",
            "likes": 60,
            "name": "Flatland",
            "published": 3,
            "tags": [
                "2d",
                "illusion"
            ],
            "usePreview": 0,
            "username": "P_Malin",
            "viewed": 5726
        },
        "renderpass": [
            {
                "code": "\n#define ENABLE_SPOTS\n\n//#define ENABLE_MONOCHROME\n#define ENABLE_SHADING\n\n//#define USE_TEXTURES\n//#define SIMPLE_HEIGHT\n\n#define MOUSE_BUTTON_REMOVES_SPOTS\n\nfloat fTileSize = 24.0;\n\n#ifndef ENABLE_MONOCHROME\nfloat kContrast = 0.5;\n#else\nfloat kContrast = 1.0;\n#endif\n\n// old settings\n//float fBlobOffset = 0.35;\n//float fBlobSize = 0.1;\n\nfloat fBlobOffset = 0.3;\nfloat fBlobSize = 0.13;\n\n\nfloat hash( const in float f )\n{\n\treturn fract( sin(f * 4001.0) * 101.0 );\n}\n\nfloat smoothnoise(in vec2 o) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat a = hash(n+  0.0);\n\tfloat b = hash(n+  1.0);\n\tfloat c = hash(n+ 57.0);\n\tfloat d = hash(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\t\n\treturn mix(mix( a, b, t.x ), mix(c, d, t.x), t.y);\n}\n\nfloat GetHeight( const in vec2 vUV )\n{\t\n    #ifdef USE_TEXTURES    \n    return texture( iChannel0, vUV * 0.01).r;\n\t#endif    \n    \n\t#ifdef SIMPLE_HEIGHT\n\treturn clamp(1.0 - length((vUV) * 0.15), 0.0, 1.0);\n\t#else\t\n\tvec2 p = vUV * 0.1;\n\n\tfloat m = 0.5;\n\tfloat h = 0.0;\n\th += m * smoothnoise(p); p *= 2.0; m *= 0.5;\n\th += m * smoothnoise(p); p *= 2.0; m *= 0.5;\n\th += m * smoothnoise(p); p *= 2.0; m *= 0.5;\n\th += m * smoothnoise(p);\n\t\t\n\treturn h;\n\t#endif\t\n}\n\nvec3 GetColour( const in vec2 vPos )\n{    \n\tvec2 vTilePos = floor(vPos);\n\tvec2 vTileFrac = fract(vPos);\n    \n\tfloat h = GetHeight(vPos);\n\tfloat fDelta = 0.1;\n\tfloat dx = GetHeight(vPos + vec2(fDelta, 0.0)) - GetHeight(vPos - vec2(fDelta, 0.0));\n\tfloat dy = GetHeight(vPos + vec2(0.0, fDelta)) - GetHeight(vPos - vec2(0.0, fDelta));\n\tdx = dx / fDelta;\n\tdy = dy / fDelta;\t\n\t\n\tfloat tdx = GetHeight(vTilePos + vec2(1.0, 0.0)) - GetHeight(vTilePos - vec2(1.0, 0.0));\n\tfloat tdy = GetHeight(vTilePos + vec2(0.0, 1.0)) - GetHeight(vTilePos - vec2(0.0, 1.0));\n\t\t\n\tvec2 vDelta = vec2(tdx, tdy);\n\t\t\n\t// co-ords to put the corner blobs for this tile in -1 to 1 range\n\tvec2 o1 = vec2(0.0);\n\tvec2 o2 = vec2(0.0);\n\n\t// There will be a simpler way to do this but I'm too lazy to figure out what it is...\n\tfloat fAngle = atan(vDelta.x, vDelta.y);\n\tfloat fSegment = (fAngle / (3.141592 * 2.0)) * 16.0;\n\t\n\tfSegment = mod(fSegment + 32.0, 16.0);\n\t\n\tif(fSegment < 1.0)\n\t{\n\t\to1 = vec2(1.0, -1.0);\n\t\to2 = vec2(-1.0, -1.0);\n\t}\n\telse if(fSegment < 3.0)\n\t{\n\t\to1 = vec2( 1.0,-1.0);\n\t\to2 = vec2(-1.0, 1.0);\n\t}\n\telse if(fSegment < 5.0)\n\t{\n\t\to1 = vec2(-1.0,-1.0);\n\t\to2 = vec2(-1.0, 1.0);\n\t}\n\telse if(fSegment < 7.0)\n\t{\n\t\to1 = vec2(-1.0,-1.0);\n\t\to2 = vec2(1.0,  1.0);\n\t}\n\telse if(fSegment < 9.0)\n\t{\n\t\to1 = vec2(1.0,  1.0);\n\t\to2 = vec2(-1.0, 1.0);\n\t}\n\telse if(fSegment < 11.0)\n\t{\n\t\to1 = vec2(1.0, -1.0);\n\t\to2 = vec2(-1.0, 1.0);\n\t}\n\telse if(fSegment < 13.0)\n\t{\n\t\to1 = vec2( 1.0,  1.0);\n\t\to2 = vec2( 1.0, -1.0);\n\t}\n\telse if(fSegment < 15.0)\n\t{\n\t\to1 = vec2(-1.0,-1.0);\n\t\to2 = vec2(1.0,  1.0);\n\t}\n\telse\n\t{\n\t\to1 = vec2(1.0, -1.0);\n\t\to2 = vec2(-1.0, -1.0);\n\t}\t\n\t\t\t\n\tfloat fEffect = 0.0;\n\n\t#ifdef ENABLE_SPOTS\n\t\n\t#ifdef MOUSE_BUTTON_REMOVES_SPOTS\n\tif(iMouse.z <= 0.0)\n\t#endif\n\t{\n\t\tif( length(vDelta) > 0.025 )\n\t\t{\n\t\t\tif( (abs(vTileFrac.x - 0.5 + o1.x * fBlobOffset) < fBlobSize) &&\n\t\t\t\t(abs(vTileFrac.y - 0.5 + o1.y * fBlobOffset) < fBlobSize)  )\n\t\t\t\tfEffect = 1.0;\n\t\t\t\n\t\t\tif( (abs(vTileFrac.x - 0.5 + o2.x * fBlobOffset) < fBlobSize) &&\n\t\t\t\t(abs(vTileFrac.y - 0.5 + o2.y * fBlobOffset) < fBlobSize)  )\n\t\t\t\tfEffect = 1.0;\n\t\t}\n\t}\n\t#endif\n\t\n\tfloat fInverse = mod(vTilePos.x + vTilePos.y, 2.0);\n\tif(fInverse > 0.5)\n\t{\n\t\tfEffect = 1.0 - fEffect;\n\t}\n\n\t// Terrain colours\t\n\tvec3 vBase =  vec3(0.01, 0.2, 0.6);\n\tvBase = mix( vBase, vec3(0.01, 0.5, 0.1), smoothstep(0.19, 0.2, h) );\n\tvBase = mix( vBase, vec3(0.5, 0.3, 0.1), smoothstep(0.4, 0.5, h) );\n\tvBase = mix( vBase, vec3(1.0, 1.0, 1.0), smoothstep(0.7, 0.8, h) );\n\n\t#ifdef ENABLE_MONOCHROME\n\tvBase = vec3(1.0);\n\t#endif\n\n    #ifdef USE_TEXTURES\n    vBase = texture( iChannel1, vPos * 0.01).rgb;\n    #endif\n    \n\tvec3 n = normalize(vec3(dx, dy, 0.1));\n\tvec3 l = normalize(vec3(1.0, -0.5, 1.0));\n\n\t#ifdef ENABLE_SHADING\n\tfloat fShade = clamp( dot(n,l), 0.0, 1.0);\n\tvBase = mix(0.3, 1.0, fShade) * vBase;\n\t#endif\n\t\t\n\treturn mix( vBase*(1.0 - kContrast), vBase, fEffect);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vPos = fragCoord.xy;\n\n\tvec2 vOffset = vec2(0.0);\n\n\tvOffset.x += floor(cos(iTime * 0.15234) * 500.0);\n\tvOffset.y += floor(sin(iTime * 0.17312) * 500.0);\t\t\n\n\tvOffset.x -= iMouse.x * 4.0;\n\tvOffset.y -= iMouse.y * 4.0;\n\t\t\n\tvPos += vOffset;\n\t\t\n\tvec3 vColour = GetColour(vPos / fTileSize);\n\t\n\tvColour =sqrt(vColour);\n\tfragColor = vec4(vColour,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 48,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}