{
    "Shader": {
        "info": {
            "date": "1467882251",
            "description": "First test with raymarching. Rays attracted by gravity. Weird (:",
            "flags": 32,
            "hasliked": 0,
            "id": "llc3R8",
            "likes": 10,
            "name": "Raymarch BlackHole Experiment 1 ",
            "published": 3,
            "tags": [
                "raymarch",
                "wormhole",
                "gravity"
            ],
            "usePreview": 1,
            "username": "tehsauce",
            "viewed": 1734
        },
        "renderpass": [
            {
                "code": "//\t\t ^\n//\t\t |\n//       |\n//  Click tab \"Buf A\"\n//  to see code\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n   float bRad = 1.0/float(iResolution.y);\n   vec2 uv    = fragCoord.xy / iResolution.xy;\n    \n    \n// Reduce sparkles    \n#if 1 \n    \n    if (length(texture(iChannel0, uv).rgb) > 0.95 && \n   \t\tlength(texture(iChannel0, vec2(uv.x+bRad, uv.y)).rgb) < 0.85 &&\n   \t\tlength(texture(iChannel0, vec2(uv.x-bRad, uv.y)).rgb) < 0.85 &&\n    \tlength(texture(iChannel0, vec2(uv.x, uv.y+bRad)).rgb) < 0.85 &&\n        length(texture(iChannel0, vec2(uv.x, uv.y-bRad)).rgb) < 0.85) \n    {\n        fragColor = vec4(0.08,0.08,0.08,1.0);\n    } else { \n        fragColor = texture(iChannel0, uv);\n    }\n    \n    \n    //Blur\n    /*\n    bRad = 1.0/iResolution.x;\n    fragColor =  0.25*fragColor + \n        \t\t 0.125*texture(iChannel0, vec2(uv.x+bRad, uv.y)) +\n        \t\t 0.125*texture(iChannel0, vec2(uv.x-bRad, uv.y)) +\n        \t\t 0.125*texture(iChannel0, vec2(uv.x, uv.y+bRad)) +\n                 0.125*texture(iChannel0, vec2(uv.x, uv.y-bRad)) +\n        \t\t0.0625*texture(iChannel0, vec2(uv.x+bRad, uv.y-bRad)) +\n        \t\t0.0625*texture(iChannel0, vec2(uv.x-bRad, uv.y+bRad)) +\n                0.0625*texture(iChannel0, vec2(uv.x+bRad, uv.y+bRad)) +\n     \t\t\t0.0625*texture(iChannel0, vec2(uv.x-bRad, uv.y-bRad));\n   */\n\n\n#else\n    fragColor = texture(iChannel0, uv);\n#endif\n\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nstruct Ray {\n  vec3 origin;\n  vec3 direction;\n};\n    \n\nstruct Sphere {\n    vec3 position;\n    float radius;\n};\n   /* \nstruct BoundingBox {\n\tvec3 min;\n    vec3 max;\n};\n   */\nstruct Plane {\n\tvec3 normal;\n    float offset;\n  //  BoundingBox bound;\n};\n    \nstruct FarLight {\n\tvec3 direction;\n    vec4 color;\n};        \n\nstruct PointLight {\n\tvec3 position;\n    vec4 color;\n};\n    \n//PointLight pLight = PointLight(vec3(sin(iTime)*2.4,10.0,cos(2.0*iTime)*4.0), vec4(0.5,0.6,0.3,1.0));\n\n\nconst vec4 ambient = vec4(0.1,0.05,0.07,1.0);\nconst vec4 planeColor = vec4( 0.64, 0.68, 0.55, 1.0);\nconst vec4 sphereColor = vec4( 0.84, 0.93, 0.07, 1.0);\n    \nPlane p1 = Plane(vec3(0.0,1.0,0.0), 1.5/*, BoundingBox(vec3(-3.0,-3.0,2.0), vec3(3.0,3.0,9.0))*/);\n\n\nvec3 repeat( vec3 v ) {\n    return vec3(mod(v.x,4.0)-2.0, v.y, mod(v.z,10.0));   \n}\n \n    \nfloat distFromSphere(Sphere s, vec3 p) {\n \treturn distance(repeat(p),s.position)-s.radius;  \n}\n\nfloat distFromPlane(Plane plane, vec3 p) {\n\treturn dot(plane.normal, p) + plane.offset;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    FarLight sun = FarLight(normalize(vec3(sin(iTime),0.4,cos(0.43*iTime))), vec4(1.0,0.8,0.75,1.0));\n\n    Sphere sphere1 = Sphere(vec3(0.0,cos(iTime),8.0+0.5*sin(iTime)),1.5);\n    \n    vec3 mass = vec3(5.0*sin(0.6*iTime), 2.5, 15.0+5.5*iTime+4.0*cos(0.2*iTime));\n\n\n    vec2 uv    = fragCoord.xy / iResolution.xy - vec2(0.5);\n         uv.x *= iResolution.x / iResolution.y;\n    \n    int pHits = 0;\n    int sHits = 0;\n    vec4 color =  vec4(0.0,0.0,0.0,1.0);\n    vec3 reflectDirection;\n    \n    Ray ray = Ray(vec3(0.0,3.0/*+cos(iTime)*/,5.5*iTime), normalize(vec3(uv.x,uv.y/*-0.3*(1.0+cos(iTime))*/,1.0)));\n    \n    for (int bounce = 0; bounce<5; ++bounce) {\n\n        for (int i=0; i<86; ++i) {\n            float distS = distFromSphere(sphere1, ray.origin);\n            float distP = distFromPlane(p1, ray.origin);\n            \n            if (distS < 0.005) {\n                sHits++;\n\t\t\t\tvec3 norm = normalize(sphere1.position - repeat(ray.origin));\n                ray.direction = reflect(ray.direction, norm);\n                ray.origin += ray.direction * 0.08;\n                break;\n            }\n            \n            if (distP < 0.005) {\n\t\t\t\tpHits++;\n                ray.direction = reflect(ray.direction, p1.normal);\n                ray.origin += ray.direction * 0.08;\n                break;\t\n            }\n            \n\n            vec3 difference = ray.origin - mass;\n\t\t\tfloat mDist = length(difference);\n            float minDist =  min(min(distS, distP),mDist);\n            if (mDist > 600.0) break;\n            float force = 0.02*((sin(0.23*iTime)+1.0)) / (mDist*mDist);\n            ray.direction = normalize(ray.direction - minDist * force * difference);\n            ray.origin += ray.direction * minDist * 0.2;\n\n        }\n    } \n    \n//    vec3 dirToLight = normalize(pLight.position-ray.origin);\n    if (pHits + sHits > 0) {\n        float ph = float(pHits); \n        float sh = float(sHits);\n    \tfloat angle = dot(sun.direction, ray.direction);\n    \t//specular\n    \tcolor += pow(max(angle, 0.0), 180.0) * vec4(0.8);\n    \tcolor += (max(angle, 0.0) * sun.color * pow(planeColor, vec4(ph)) * pow(sphereColor, vec4(sh))) / pow(ph+sh,1.0);\n    \tcolor += ambient;\n    //\tcolor = dot(sun.direction, norm) * sun.color;\n    }\n    \n    \n    fragColor = color;\n \n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}