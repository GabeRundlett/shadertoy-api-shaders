{
    "Shader": {
        "info": {
            "date": "1628616911",
            "description": "Simple scene. I hope it does not look too bad.",
            "flags": 0,
            "hasliked": 0,
            "id": "Nt2Szm",
            "likes": 17,
            "name": "Bright cubes",
            "published": 3,
            "tags": [
                "3d",
                "voxels",
                "art"
            ],
            "usePreview": 0,
            "username": "morimea",
            "viewed": 632
        },
        "renderpass": [
            {
                "code": "\n// Created by Danil (2021+) https://cohost.org/arugl\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// self https://www.shadertoy.com/view/Nt2Szm\n\n\n#define AA 2\n\n// does not speedup compiling but slowdown performance, comp time 2 sec without this\n//#define iZero min(iFrame,0)\n\n#define iZero 0\n\n#define PI 3.141592653589793\n#define TAU (2.*PI)\nmat2 MD(float a){float s = sin( a );float c = cos( a );return mat2(vec2(c, -s), vec2(s, c));}\n\nconst vec3 white=vec3(0xf1,0xe8,0xf2)/float(0xff);\nconst vec3 blue=vec3(0x0a,0x1f,0x73)/float(0xff);\n\nconst vec2 voxbox = vec2(6.5,9.5);\nconst float voxmax_h = 1.918;\nconst vec3 voxposl = vec3(0.,-3.5,-8.5);\n\n\n// --------Common moved to have al in one shader\n\nfloat fresnel(vec3 d, vec3 n)\n{\n    float a = clamp(1.0-dot(n,-d), 0.0, 1.0);\n    return clamp(exp((5.0*a)-5.0), 0.0, 1.0);\n}\n\n// ANGLE bug https://bugs.chromium.org/p/chromium/issues/detail?id=1238461\n// ANGLE compile time slowdown 20x times because of single call of (0.5 * t * t * t) below\n\nfloat easeInOutCubic(float t) {\n    if ((t *= 2.0) < 1.0) {\n        //return 0.5 * t * t * t; // uncomment for bug\n        return 0.5 * pow(abs(t),3.); //fix\n    } else {\n        return 0.5 * ((t -= 2.0) * t * t + 2.0);\n    }\n}\n\nuint uhash(uint x) {\n    x = ((x >> uint(16)) ^ x) * uint(73244475);\n    x = ((x >> uint(16)) ^ x) * uint(73244475);\n    x = (x >> uint(16)) ^ x;\n    return x;\n}\n\nfloat rand_from_seed(inout uint seed) {\n    int k;\n    int s = int(seed);\n    if (s == 0)\n    s = 305420679;\n    k = s / 127773;\n    s = 16807 * (s - k * 127773) - 2836 * k;\n    if (s < 0)\n        s += 2147483647;\n    seed = uint(s);\n    return float(seed % uint(65536)) / 65535.0;\n}\n\nfloat hash11(float v){\n    uint hs = uhash(floatBitsToUint(v * 12.9898));\n    return rand_from_seed(hs);\n}\n\nfloat hash21(vec2 v){\n    uint hs = uhash(floatBitsToUint(v.y + v.x * 12.9898));\n    return rand_from_seed(hs);\n}\n\nfloat hash31(vec3 v){\n    uint hs = uhash(floatBitsToUint(v.y + v.x * 12.9898 + v.z * 25.831));\n    return rand_from_seed(hs);\n}\n\nvec3 hash33(vec3 v){\n    uint hs = uhash(floatBitsToUint(v.y + v.x * 12.9898 + v.z * 25.831));\n    float a = rand_from_seed(hs);\n    float b = rand_from_seed(hs);\n    float c = rand_from_seed(hs);\n    return vec3(a,b,c);\n}\n\nfloat get_rand(vec2 pos,vec2 box){\n    float tps = hash21(pos);\n    tps = tps*0.1+0.9*smoothstep(0.2,.9,tps);\n    tps *= min((abs(pos.x-box.x-3.)/box.x)*((pos.y+3.)/(box.y*2.)),1.);\n    return 0.05+0.95*tps;\n}\n\n\n// https://www.shadertoy.com/view/XsX3zB\nvec3 random3(vec3 c) {\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;r.z = fract(512.0*j);j *= .125;r.x = fract(512.0*j);j *= .125;r.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t vec4 w, d;\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t w = max(0.6 - w, 0.0);\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t return dot(d, vec4(52.0));\n}\n\nconst mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);\nconst mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);\nconst mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);\n\nfloat simplex3d_fractal(vec3 m) {\n    return   0.5333333*simplex3d(m*rot1)\n\t\t\t+0.2666667*simplex3d(2.0*m*rot2)\n\t\t\t+0.1333333*simplex3d(4.0*m*rot3)\n\t\t\t+0.0666667*simplex3d(8.0*m);\n}\n\n#define MAX_DIST 1000.\n#define MIN_DIST .001\n\n// ffix float precision fix, cy height shift animation, stimer shift timer 0-1\n// ffix also used in reflections to control voxel size to remove white borders on glow reflections\nbool VoxelsIntersect(int steps, vec2 box, float max_h, float ffix, in vec3 ro, in vec3 rd,\n                        out vec3 normal , out float tnew, out vec2 idx, inout float cy, float stimer) {\n    vec2 pos = floor(ro.xz);\n    \n    vec3 rdi = 1./rd;\n\n    vec3 rda = abs(rdi);\n    vec3 rds = sign(rd);\n    vec2 dis = (pos - ro.xz + .5 + rds.xz*.5) * rdi.xz;\n    \n    vec3 roi = rdi*(ro-vec3(.5,0.,.5));\n\n    vec2 mm = vec2(0.0);\n    for( int i=0; i<steps; i++ ) {    \n        float tps = get_rand(pos, box);\n        float tm=1.;\n        if (any(greaterThan(pos,box*2.))||any(lessThan(pos,vec2(1.))))tm=0.;\n        cy = mix(-(tm*max_h*tps-1.)+max_h*2.-2.,tm*max_h*tps-1.,stimer);\n        vec3 n = roi - rdi * vec3(pos.x, cy, pos.y);\n        vec3 k = rda*vec3(.5, -0.00099+tm*max_h*tps, .5);\n\n        vec3 t1 = -n - k;\n        vec3 t2 = -n + k;\n\n        float tN = max( max( t1.x, t1.y ), t1.z )-ffix;\n        float tF = min( min( t2.x, t2.y ), t2.z );\n\n        if ( tN < tF && tN>MIN_DIST && tN<MAX_DIST ) {\n            normal = -rds*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n            tnew = tN;\n            idx = pos;\n            return true;\n        }\n\n    mm = step( dis.xy, dis.yx ); \n    dis += mm*rda.xz;\n    pos += mm*rds.xz;\n    }\n\n    return false;\n}\n\n\n// using iq's intersectors: https://iquilezles.org/articles/intersectors\n\nbool SphereIntersectInv(vec3 SpPos, float SpRad, vec3 ro, vec3 rd, out float t, out vec3 norm) {\n    ro -= SpPos;\n\n    float A = dot(rd, rd);\n    float B = 2.0*dot(ro, rd);\n    float C = dot(ro, ro)-SpRad*SpRad;\n    float D = B*B-4.0*A*C;\n    t=-1.;\n    norm=vec3(0.,1.,0.);\n    if (D < 0.0) return false;\n\n    D = sqrt(D);\n    A *= 2.0;\n    float t1 = (-B+D)/A;\n    float t2 = (-B-D)/A;\n    if (t1 < 0.0) t1 = t2;\n    if (t2 < 0.0) t2 = t1;\n    t1 = max(t1, t2);\n    //t1 = min(t1, t2);\n    if (t1 < 0.0) return false;\n    norm = ro+t1*rd;\n    t = t1;\n    norm = normalize(norm);\n    return true;\n}\n// --- Common end\n\n\nvec2 lUV(vec3 p) {\n    float x = dot(p, vec3(-1,0.,0.));\n    float y = dot(p, vec3(0.,1.,0.));\n    float td = dot(p, vec3(0.,0.,1.));\n    td += 0.0001 * (1.0 - abs(sign(td)));\n    float d = -1. / td;\n    float u = d * x + 0.5;\n    float v = d * y + 0.5;\n    return vec2(u, v);\n}\n\nvec3 color_spiral(vec3 p, float d) {\n    p.z+=-1.;\n    vec2 uv=((lUV(p))-0.5)*.75;\n    uv *=MD(-0.5/max(length(uv),0.0001));\n    float td=(1.-smoothstep(-2.0,-.815,p.z))*(smoothstep(-2.,-1.95,p.z))*(1.-smoothstep(-1.5,2.35,length(uv)));\n    float c = d / max(abs(5.0/uv.x),0.0001);\n    return clamp(.85-c,0.,1.)*((blue+vec3(0.4,0.8,1.5)))*td;\n}\n\nvec3 blurred_background(vec3 rd)\n{\n    return vec3(0.7, 0.8, 1.6)*max((rd.y*0.49 + 0.51),0.001)*0.8+color_spiral(-rd,10.)*1.5;\n}\n\nvec3 background_sky(vec3 rd)\n{\n    return vec3(0.7, 0.8, 1.4)*max((rd.y*0.6 + 0.3),0.001)+color_spiral(-rd,15.)*2.;\n}\n\n\n#define OBJ_SKY 0\n#define OBJ_FLOOR 1\n#define OBJ_REFLOOR 2\n#define OBJ_BOX 3\n#define OBJ_BALL 4\n\nstruct HitInfo {\n    float t;\n    vec3 norm;\n    vec4 color;\n    int obj_type;\n    vec2 exdata;\n};\n\nstruct Ray\n{\n    vec3 pos;\n    vec3 dir;\n};\n\nfloat atimer=1.; //global timer 0-1\n\nconst vec3 anim_camera[]=vec3[](\n    vec3(-1.,5.,-3.),vec3(2.,3.5,-1.5),\n    vec3(3.,3.05,11.5),vec3(0.5,4.5,18.5),vec3(6.5,3.5,19.5),\n    vec3(6.5,5.15,20.5),vec3(0.5,4.5,10.5),vec3(0.5,4.5,-2.5),\n    vec3(-2.5,8.5,-2.5)\n);\n\nconst float timers[]=float[](\n    4.0,6.0,11.,\n    16.,21.,26.,\n    31.,36.5,40.,\n    42.\n);\n\nvec3 camera_anim(float gt){\n    vec3 dx[3];\n    for(int a=0;a<3+iZero;a++){\n        float timer=mod(gt+1.25*float(a-1),timers[timers.length()-1]);\n        timer+=timers[0];\n        dx[a]=anim_camera[0];\n        for(int i=1;i<anim_camera.length()+iZero;i++){\n            float t=smoothstep(timers[i-1],timers[i],timer);\n            dx[a]=mix(dx[a],anim_camera[i],t);\n        }\n        float t=smoothstep(timers[timers.length()-1],timers[timers.length()-1]+timers[0],timer);\n        dx[a]=mix(dx[a],anim_camera[0],t);\n    }\n    float timer=mod(gt,timers[timers.length()-1]);\n    timer+=timers[0];\n    atimer=1.-smoothstep(timers[4]+4.,timers[4]+6.5,timer);\n    atimer=max(atimer,smoothstep(timers[8]+0.,timers[9]+1.5,timer));\n    return mix(dx[1],mix(dx[0],dx[2],0.5),0.5);\n}\n\nvec2 get_look(float gt){\n    float timer=mod(gt,timers[timers.length()-1]);\n    timer=smoothstep(0.,timers[timers.length()-1],timer);\n    float et=easeInOutCubic(timer);\n    float ot=((1.-smoothstep(0.,0.5,timer))-1.5*smoothstep(0.5,0.6,timer)*(1.-smoothstep(0.75,0.9,timer)))+smoothstep(0.9,1.,timer);\n    timer=(timer*(1.-et))-0.5;\n    return vec2(0.2-3.*sin((0.5+timer)*PI),-0.25*sin(0.5*ot*PI));\n}\n\nRay SetCamera(vec2 uv, vec3 ro, vec2 m)\n{\n    if(iMouse.z>0.)\n        m+=(iMouse.xy/iResolution.y-0.5*iResolution.xy/iResolution.y)*2.5;\n    m.y = -m.y;\n    float fov=70.;\n    float aspect = iResolution.x / iResolution.y;\n    float screenSize = (1.0 / (tan(((180.-fov)* (3.1415926 / 180.0)) / 2.0)));\n    vec3 rd = normalize(vec3(uv*screenSize, 1./aspect));\n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n\n    rd = (rotY * rotX) * rd;\n    return Ray(ro,rd);\n}\n\nbool boxAABB(in vec3 dims, vec3 ro, vec3 rd) {\n    vec3 n = ro / rd;\n    vec3 k = dims / abs(rd);\n    vec3 t1 = -k - n, t2 = k - n;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    return tN < tF && tF > 0.0;\n}\n\nvoid VoxelsIntersectMin_ref(vec2 box, float max_h , vec3 posl,vec3 ro, vec3 rd,\n                            inout HitInfo hit, float rfnl, float sky_pow, float col_pow, inout float refc) {\n    float tnew;\n    vec2 idx;\n    vec3 normnew;\n    float cy;\n    \n    if(VoxelsIntersect(6, box, max_h, -0.001, ro, rd, normnew, tnew, idx, cy, atimer)){\n        bool in_box=(idx.x<=box.x*2.)&&(idx.y<=box.y*2.);\n        in_box=in_box&&all(greaterThan(idx,vec2(0.)));\n        float fnl = fresnel(rd,normnew);\n        if(in_box){\n            float alb = hash21(idx+1.);\n            float trnd = get_rand(idx+20., box*0.7);\n            float emi = step(0.65,trnd-0.75*trnd*hash21(idx+5.));\n            alb*=0.25;\n            alb *= rfnl * (1.-fnl) \n                * (.8 + .2 * dot(normnew, vec3(-.25916,.8639,-.4319)));\n            \n            emi *= col_pow;\n            vec3 tuv = fract(ro+tnew*rd) * 2.0 - 1.0;\n            float vig=max(tuv.x*tuv.x, tuv.z*tuv.z)*0.5;\n            vec3 tc = white+blue;\n            tc=mix(tc,tc*.65,vig);\n            vec3 col=max(alb*white,emi*1.175*tc);\n            hit.color.rgb += col;\n            hit.color.a += emi*0.25;\n            refc*=0.12;\n        }\n        else {\n            vec3 bg=clamp(vec3(.5,.8,1)*0.+1.*blurred_background(rd),0.,1.);\n            hit.color.rgb  += sky_pow*clamp(bg * (rfnl*(5.-2.5*rd.y)),vec3(0.),bg);\n        }\n    }\n    else {\n        vec3 bg=clamp(vec3(.5,.8,1)*0.+1.*blurred_background(rd),0.,1.);\n        hit.color.rgb += sky_pow*clamp(bg * (rfnl*(5.-2.5*rd.y)),vec3(0.),bg);\n    }\n}\n\nvoid VoxelsIntersectMin(vec2 box, float max_h , vec3 posl,vec3 ro, vec3 rd,\n                        inout bool result, inout HitInfo hit, vec3 sky) {\n    float tnew;\n    vec2 idx;\n    vec3 normnew;\n    \n    posl.xz+=1.;\n    ro+=posl;\n    \n    if(!boxAABB(vec3(box.x,max_h,box.y), ro+vec3(-1.,-max_h+1.,-1.), rd))return;\n    ro.xz+=box;\n    float vros = length(ro.xz-(box+1.));\n    if(VoxelsIntersect(min(int(vros*1.5)+18,40), box, max_h, 0.0001, ro, rd, normnew, tnew, idx, hit.exdata.y, atimer)){\n        bool in_box=(idx.x<=box.x*2.)&&(idx.y<=box.y*2.);\n        in_box=in_box&&all(greaterThan(idx,vec2(0.)));\n        if (in_box&&(tnew>0.)) {\n            float tmx = 0.;\n            if((hit.obj_type==OBJ_BALL)&&(tnew>hit.t))tmx=clamp(dot(hit.color.rgb,vec3(1.))*0.25,0.,1.);\n            hit.color = vec4(0.,0.,0.,0.);\n            float fnl = fresnel(rd,normnew);\n            \n            float alb = hash21(idx+1.);\n            float trnd = get_rand(idx+20., box*0.7);\n            float emi = step(0.65,trnd-0.75*trnd*hash21(idx+5.));\n            vec3 col = vec3(0.);\n            alb*=0.1*alb;\n\n            alb *= (1.-fnl) \n                * (.8 + .2 * dot(normnew, vec3(-.25916,.8639,-.4319)));\n            \n            vec3 tuv = fract(ro+tnew*rd) * 2.0 - 1.0;\n            float vig=max(tuv.x*tuv.x, tuv.z*tuv.z)*0.5;\n            vec3 tc = white+blue;\n            tc=mix(tc,tc*.85,vig);\n            col=max(alb*white,emi*2.35*(tc));\n            vec3 skyo = background_sky(rd);\n            hit.color.rgb += mix(col,skyo,fnl*fnl);\n            hit.color.a += emi;\n\n            hit.obj_type = OBJ_FLOOR;\n            result = true;\n            hit.t = tnew;\n            hit.norm = normnew;\n            \n            float vrds = length(tnew * rd.xz);\n            if((emi<0.5)&&(fnl > .001)){\n                hit.obj_type = OBJ_REFLOOR;\n                hit.norm = normnew;\n                hit.exdata.x = fnl;\n            }\n            \n            hit.color.rgb = mix(hit.color.rgb,sky,smoothstep(24.,27.5,vrds));\n            hit.color.rgb = mix(hit.color.rgb,sky,tmx);\n        }\n    }\n}\n\n\nfloat glow_sphere(vec3 rd, vec3 n){\n    float a = pow(0.7122 + max(dot(n, reflect(rd,n)),0.), 10.85);\n    float b = pow(0.7122 + max(1.-dot(n, reflect(rd,n)),0.), 3.85);\n    \n    return clamp(min(a,b),0.,10.);\n}\n\nvoid SphereIntersectMin(vec3 SpPos, float SpRad, vec3 ro, vec3 rd, inout bool result, inout HitInfo hit, bool refl, bool sph2, float ot) {\n    float tnew;\n    vec3 normnew;\n    if (SphereIntersectInv(SpPos, SpRad, ro, rd, tnew, normnew)) {\n        if(!refl){\n        if (tnew < hit.t||sph2&&(tnew < ot)) \n        {\n            hit.t = min(tnew,hit.t);\n            hit.norm = normnew;\n            if(sph2){\n                vec3 spotLightOrigin \t= (SpPos - vec3(0.,0.,1.)*22.9);\n                vec3 Ln = normalize(spotLightOrigin-(ro+rd*tnew));\n                hit.color.rgb += color_spiral(Ln,20.)*4.;\n            }\n            else\n            hit.color.rgb += glow_sphere(rd,-normnew)*(sqrt(blue))*3.;\n            hit.obj_type = OBJ_BALL;\n            result = true;\n        }\n        }else{\n            if(sph2)\n            {\n                vec3 spotLightOrigin \t= (SpPos - vec3(0.,0.,1.)*19.9);\n                vec3 Ln = normalize(spotLightOrigin-(ro+rd*tnew));\n                hit.color.a += color_spiral(Ln,10.).b*.85;\n            }\n            else\n            hit.color.a = glow_sphere(rd,-normnew);\n            hit.obj_type = OBJ_BALL;\n            result = true;\n        }\n    }\n}\n\n\nHitInfo render(Ray r, inout vec3 sky)\n{\n    HitInfo hit;\n    hit.t = MAX_DIST;\n    hit.obj_type = OBJ_SKY;\n    hit.color = vec4(sky,0.);\n    hit.norm = vec3(0.,1.,0.);\n    hit.exdata = vec2(0.);\n    \n    vec4 col = vec4(0.);\n\n    vec3 ro = r.pos; vec3 rd = r.dir;\n    \n    bool result = false;\n    float angle=0.;\n\n    vec3 spherex=vec3(0.,8.15,8.5+voxbox.y+15.);\n    vec3 spherex2=vec3(0.,8.15,8.5+voxbox.y+15.-22.25);\n    \n    rd += 0.0001 * (1.0 - abs(sign(rd)));\n    \n    float ot=hit.t;\n    SphereIntersectMin(spherex, 13.5, ro, rd, result, hit, false, false,0.);\n    SphereIntersectMin(spherex2, 23.5, ro, rd, result, hit, false, true,ot);\n    sky=hit.color.rgb;\n    \n    VoxelsIntersectMin(voxbox, voxmax_h , voxposl,ro, rd, result, hit, sky);\n    \n    return hit;\n}\n\n// reflections\nHitInfo render_refl(Ray r, HitInfo hit, float fbmx, inout vec3 sky)\n{\n    vec3 skyo = background_sky(r.dir);\n    \n    if(hit.obj_type == OBJ_REFLOOR){\n        vec3 ro = r.pos;\n        ro = ro+r.dir*hit.t;\n        float vrds = length(hit.t * r.dir.xz);\n        fbmx*=1.-smoothstep(10.,14.5,vrds);\n        float gfnl = fresnel((r.dir),hit.norm);\n        fbmx*=max(1.-gfnl*2.,0.);\n        vec3 ord = reflect(r.dir-(.0295*fbmx*hit.norm), hit.norm);\n        vec3 rd = reflect(r.dir-(.295*fbmx*hit.norm), hit.norm);\n        rd += 0.0001 * (1.0 - abs(sign(rd)));\n        \n        bool result = false;\n        float angle=0.1;\n\n        vec3 spherex=vec3(0.,10.15,8.5+voxbox.y+15.);\n        vec3 spherex2=vec3(0.,10.15-2.,8.5+voxbox.y+15.-22.25);\n        float oemi=hit.color.a;\n        float ot=hit.t;\n        SphereIntersectMin(spherex, 13.5, ro, rd, result, hit, true, false,0.);\n        SphereIntersectMin(spherex2, 23.5, ro, ord, result, hit, true, true,ot);\n        float refc=0.;\n        float fnl = 0.; \n        if(hit.obj_type == OBJ_BALL){\n            fnl=1.;refc=hit.color.a;hit.color.a=oemi;\n        }\n        ro+=voxposl;ro.xz+=voxbox+1.;\n\n        rd = reflect(r.dir+(.695*fbmx*hit.norm), hit.norm);\n        rd += 0.0001 * (1.0 - abs(sign(rd)));\n        \n        VoxelsIntersectMin_ref(voxbox, voxmax_h , voxposl+1.,ro, rd, hit, hit.exdata.x, 01.5, 01.+0.25*fbmx,refc);\n        hit.color.rgb = 0.985*hit.color.rgb+0.015*hit.color.rgb*fbmx;\n        \n        fnl = max(fresnel(rd,hit.norm),fnl);\n        hit.color.rgb = mix(hit.color.rgb,skyo,1.-sqrt(fnl))+refc*(sqrt(blue))*3.;\n        \n        hit.color.rgb = mix(hit.color.rgb,sky,smoothstep(24.,27.5,vrds));\n    }\n    return hit;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec3 ret_col = vec3(0.0);\n    float emi = 0.;\n    vec3 tro = camera_anim(iTime);\n    vec2 m=get_look(iTime);\n#if AA>1\n    const int ta=AA*AA;\n#else\n    const int ta = 1;\n#endif\n\n    HitInfo hit[ta];\n    Ray cam[ta];\n    vec3 sky[ta];\n{\n#if AA>1\n    for( int mx=0; mx<AA+iZero; mx++ )\n    for( int nx=0; nx<AA+iZero; nx++ )\n    {\n    vec2 o = vec2(float(mx),float(nx)) / float(AA) - 0.5;\n    vec2 uv = (fragCoord+o)/iResolution.xy * 2.0 - 1.0;\n#else\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n#endif\n    uv.y *= iResolution.y/iResolution.x;\n#if AA>1\n    int idx=mx*AA+nx;\n#else\n    int idx=0;\n#endif\n    cam[idx] = SetCamera(uv,tro,m);\n    sky[idx] = background_sky(cam[idx].dir);\n    hit[idx] = render(cam[idx],sky[idx]);\n#if AA>1\n    }\n#endif\n}\n\n    vec3 ro = cam[0].pos;\n    ro+=voxposl;ro.xz+=voxbox+1.;ro = ro+cam[0].dir*hit[0].t;\n    float fbmx = (simplex3d_fractal(5.*(ro-vec3(0.,hit[0].exdata.y,0.))+vec3(0.,.5,1.)*iTime));\n{\n#if AA>1\n    for( int mx=0; mx<AA+iZero; mx++ )\n    for( int nx=0; nx<AA+iZero; nx++ )\n    {\n#endif\n#if AA>1\n    int idx=mx*AA+nx;\n#else\n    int idx=0;\n#endif\n    hit[idx] = render_refl(cam[idx],hit[idx],fbmx,sky[idx]);\n#if AA>1\n    }\n#endif\n}\n\n{\n#if AA>1\n    for( int mx=0; mx<AA+iZero; mx++ )\n    for( int nx=0; nx<AA+iZero; nx++ )\n    {\n#endif\n#if AA>1\n    int idx=mx*AA+nx;\n#else\n    int idx=0;\n#endif\n    ret_col += hit[idx].color.rgb;\n    emi += hit[idx].color.a;\n#if AA>1\n    }\n    ret_col /= float(AA*AA);\n    emi /= float(AA*AA);\n#endif\n}\n    \n\n    vec3 glow = vec3(0.7, 0.8, 1.6)*max((cam[0].dir.y*0.49 + 0.51),0.001)*0.8;\n    ret_col += glow*glow*glow / 4.0;\n\n    ret_col *= 0.425;\n    ret_col = clamp(ret_col,0.,1.);\n    ret_col = sqrt(ret_col);\n    \n    vec2 vig = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    ret_col = mix(ret_col, ret_col*ret_col, dot(vig, vig)*0.5);\n    ret_col = mix(ret_col, ret_col*ret_col, 0.5);\n    \n    ret_col = clamp(ret_col,0.,1.);\n    ret_col = pow(ret_col, vec3(01.4545));\n    \n    ret_col=mix(ret_col,ret_col.bgr,atimer);\n    fragColor = vec4(ret_col,clamp(emi,0.,1.));\n    fragColor.a=1.; //bloom not used\n}\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}