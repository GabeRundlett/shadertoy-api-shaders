{
    "Shader": {
        "info": {
            "date": "1719241405",
            "description": "Here is my first go at implementing the classic raytracing room, but with the back wall being purple and a blue ball instead of the classic white ball.",
            "flags": 32,
            "hasliked": 0,
            "id": "lXtXzB",
            "likes": 1,
            "name": "Classic Raytracing Room V1",
            "published": 3,
            "tags": [
                "raytracing",
                "intersection",
                "ao",
                "occlusion",
                "reflectance",
                "reflectivity",
                "buffers",
                "unitsphere"
            ],
            "usePreview": 0,
            "username": "spenceryonce",
            "viewed": 91
        },
        "renderpass": [
            {
                "code": "vec3 randomInsideUnitSphere(vec3 rayDir, vec3 rayPos, float extraSeed) {\n    return vec3(rand01(iTime * (rayDir.x + rayPos.x + 0.357) * extraSeed),\n                rand01(iTime * (rayDir.y + rayPos.y + 16.35647) * extraSeed),\n                rand01(iTime * (rayDir.z + rayPos.z + 425.357) * extraSeed));\n}\n\nvec4 calculateFinalColor(vec3 cameraPos, vec3 cameraRayDir, float AAIndex) {\n    vec3 finalColor = vec3(0.0);\n    float absorbMul = 1.0;\n    vec3 rayStartPos = cameraPos;\n    vec3 rayDir = cameraRayDir;\n\n    for (int i = 0; i < MAX_REFLECTIONS; i++) {\n        HitData h = AllObjectsRayTest(rayStartPos + rayDir * 0.0001, rayDir);\n\n        if (h.rayLength >= 10000.0) {\n            vec3 skyColor = vec3(0.7686, 0.8588, 0.898);\n            finalColor = skyColor * absorbMul;\n            break;\n        }\n\n        vec3 viewDir = normalize(rayStartPos - (rayStartPos + rayDir * h.rayLength));\n        finalColor += absorbMul * phongIllumination(rayStartPos + rayDir * h.rayLength, h.normal, viewDir, h.color);\n\n        absorbMul *= 0.2;\n\n        rayStartPos = rayStartPos + rayDir * h.rayLength;\n        float roughness = 0.05 + iMouse.x / iResolution.x;\n        //float roughness = 0.02;\n        rayDir = normalize(reflect(rayDir, h.normal) + randomInsideUnitSphere(rayDir, rayStartPos, AAIndex) * roughness);\n    }\n\n    return vec4(finalColor, 1.0);\n}\n\nvoid mainImage(out vec4 O, vec2 fc) {\n    setupScene();\n\n    vec2 uv = (2.0 * fc.xy - iResolution.xy) / iResolution.y;\n\n    vec3 cameraPos = vec3(0.0, 0.0, 4.0);\n    vec3 cameraFocusPoint = vec3(0, 0.0, 0);\n    vec3 cameraDir = normalize(cameraFocusPoint - cameraPos);\n\n    float fov = 0.9;\n    vec3 rayDir = normalize(cameraDir + vec3(uv, 0) * fov);\n\n    vec4 finalColor = vec4(0);\n    for (int i = 1; i <= AVERAGECOUNT; i++) {\n        finalColor += calculateFinalColor(cameraPos, rayDir, float(i));\n    }\n    finalColor = finalColor / float(AVERAGECOUNT);\n    finalColor.rgb = pow(finalColor.rgb, vec3(1.0 / 2.2));\n\n    vec4 prevColor = texture(iChannel0, gl_FragCoord.xy / iResolution.xy);\n    finalColor.rgb = mix(prevColor.rgb, finalColor.rgb, 0.1);\n\n    O = vec4(finalColor.rgb, 1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec3 randomInsideUnitSphere(vec3 rayDir, vec3 rayPos, float extraSeed) {\n    return vec3(rand01(iTime * (rayDir.x + rayPos.x + 0.357) * extraSeed),\n                rand01(iTime * (rayDir.y + rayPos.y + 16.35647) * extraSeed),\n                rand01(iTime * (rayDir.z + rayPos.z + 425.357) * extraSeed));\n}\n\nvec4 calculateFinalColor(vec3 cameraPos, vec3 cameraRayDir, float AAIndex) {\n    vec3 finalColor = vec3(0.0);\n    float absorbMul = 1.0;\n    vec3 rayStartPos = cameraPos;\n    vec3 rayDir = cameraRayDir;\n\n    for (int i = 0; i < MAX_REFLECTIONS; i++) {\n        HitData h = AllObjectsRayTest(rayStartPos + rayDir * 0.0001, rayDir);\n\n        if (h.rayLength >= 10000.0) {\n            vec3 skyColor = vec3(0.7686, 0.8588, 0.898);\n            finalColor = skyColor * absorbMul;\n            break;\n        }\n\n        vec3 viewDir = normalize(rayStartPos - (rayStartPos + rayDir * h.rayLength));\n        finalColor += absorbMul * phongIllumination(rayStartPos + rayDir * h.rayLength, h.normal, viewDir, h.color);\n\n        absorbMul *= 0.2;\n\n        rayStartPos = rayStartPos + rayDir * h.rayLength;\n        float roughness = 0.05 + iMouse.x / iResolution.x;\n        //float roughness = 0.02;\n        rayDir = normalize(reflect(rayDir, h.normal) + randomInsideUnitSphere(rayDir, rayStartPos, AAIndex) * roughness);\n    }\n\n    return vec4(finalColor, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    setupScene();\n\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    vec3 cameraPos = vec3(0.0, 0.0, 4.0);\n    vec3 cameraFocusPoint = vec3(0, 0.0, 0);\n    vec3 cameraDir = normalize(cameraFocusPoint - cameraPos);\n\n    float fov = 0.9;\n    vec3 rayDir = normalize(cameraDir + vec3(uv, 0) * fov);\n\n    vec4 finalColor = vec4(0);\n    for (int i = 1; i <= AVERAGECOUNT; i++) {\n        finalColor += calculateFinalColor(cameraPos, rayDir, float(i));\n    }\n    finalColor = finalColor / float(AVERAGECOUNT);\n    finalColor.rgb = pow(finalColor.rgb, vec3(1.0 / 2.2));\n\n    fragColor = vec4(finalColor.rgb, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define EPSILON 0.001\n#define MAX_REFLECTIONS 8\n#define AO_SAMPLES 16\n#define AO_RADIUS 1.0\n#define AVERAGECOUNT 4\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n};\n\nstruct Box {\n    vec3 min;\n    vec3 max;\n    vec3 color;\n};\n\nstruct Light {\n    vec3 position;\n    vec3 color;\n};\n\nstruct HitData {\n    float rayLength;\n    vec3 normal;\n    vec3 color;\n};\n\nSphere spheres[1];\nBox walls[5];\nLight lights[3];\n\nvoid setupScene() {\n    // Bouncing ball\n    spheres[0] = Sphere(vec3(0.0, 0.0, 0.0), 1.0);\n    \n    // Walls, ceiling, and floor\n    walls[0] = Box(vec3(-5.0, -5.0, -5.0), vec3(5.0, -4.0, 5.0), vec3(0.902, 0.8824, 0.9098)); // Floor\n    walls[1] = Box(vec3(-5.0, 4.0, -4.0), vec3(5.0, 5.0, 5.0), vec3(0.8314, 0.7725, 0.9137)); // Ceiling\n    walls[2] = Box(vec3(-5.0, -5.0, -5.0), vec3(5.0, 5.0, -4.0), vec3(0.5529, 0.1137, 0.7294)); // Back wall\n    walls[3] = Box(vec3(-5.0, -4.0, -5.0), vec3(-4.0, 4.0, 5.0), vec3(1.0, 0.0, 0.0)); // Left wall (Red)\n    walls[4] = Box(vec3(4.0, -4.0, -5.0), vec3(5.0, 4.0, 5.0), vec3(0.0549, 0.3176, 0.0549)); // Right wall (Green)\n    \n    // Lights\n    lights[0] = Light(vec3(4.0, 2.0, 2.0), vec3(0.8549, 0.9098, 0.7216));\n    lights[1] = Light(vec3(-4.0, -2.0, -1.0), vec3(0.7882, 0.8902, 0.7451));\n    lights[2] = Light(vec3(2.0, -3.0, -5.0), vec3(0.9176, 0.8667, 0.3922));\n}\n\nfloat raySphereIntersect(vec3 r0, vec3 rd, vec3 s0, float sr) {\n    float a = dot(rd, rd);\n    vec3 s0_r0 = r0 - s0;\n    float b = 2.0 * dot(rd, s0_r0);\n    float c = dot(s0_r0, s0_r0) - (sr * sr);\n    if (b * b - 4.0 * a * c < 0.0) {\n        return -1.0;\n    }\n    return (-b - sqrt((b * b) - 4.0 * a * c)) / (2.0 * a);\n}\n\nbool intersectBox(vec3 r0, vec3 rd, Box box, out float t, out vec3 hitPoint, out vec3 normal) {\n    vec3 invDir = 1.0 / rd;\n    vec3 tMin = (box.min - r0) * invDir;\n    vec3 tMax = (box.max - r0) * invDir;\n\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n\n    if (tNear > 0.0 && tNear < tFar) {\n        t = tNear;\n        hitPoint = r0 + t * rd;\n\n        if (tNear == tMin.x) normal = vec3(-sign(rd.x), 0.0, 0.0);\n        else if (tNear == tMax.x) normal = vec3(sign(rd.x), 0.0, 0.0);\n        else if (tNear == tMin.y) normal = vec3(0.0, -sign(rd.y), 0.0);\n        else if (tNear == tMax.y) normal = vec3(0.0, sign(rd.y), 0.0);\n        else if (tNear == tMin.z) normal = vec3(0.0, 0.0, -sign(rd.z));\n        else if (tNear == tMax.z) normal = vec3(0.0, 0.0, sign(rd.z));\n        \n        return true;\n    }\n    return false;\n}\n\nHitData AllObjectsRayTest(vec3 rayPos, vec3 rayDir) {\n    HitData hitData;\n    hitData.rayLength = 9999.0;\n\n    // Check for sphere intersection\n    for (int i = 0; i < 1; i++) {\n        vec3 sphereCenter = spheres[i].center;\n        float sphereRadius = spheres[i].radius;\n\n        float resultRayLength = raySphereIntersect(rayPos, rayDir, sphereCenter, sphereRadius);\n        if (resultRayLength < hitData.rayLength && resultRayLength > 0.001) {\n            hitData.rayLength = resultRayLength;\n            vec3 hitPos = rayPos + rayDir * resultRayLength;\n            hitData.normal = normalize(hitPos - sphereCenter);\n            hitData.color = vec3(0.1412, 0.5647, 0.8667); // Sphere color\n        }\n    }\n\n    // Check for box intersection\n    for (int i = 0; i < 5; i++) {\n        float t;\n        vec3 hitPoint, normal;\n        if (intersectBox(rayPos, rayDir, walls[i], t, hitPoint, normal) && t < hitData.rayLength) {\n            hitData.rayLength = t;\n            hitData.normal = normal;\n            hitData.color = walls[i].color; // Box color\n        }\n    }\n\n    return hitData;\n}\n\nfloat rand01(float seed) {\n    return fract(sin(seed) * 43758.5453123);\n}\n\nvec3 phongIllumination(vec3 point, vec3 normal, vec3 viewDir, vec3 materialColor) {\n    vec3 result = vec3(0.0);\n    for (int i = 0; i < 3; i++) {\n        vec3 lightDir = normalize(lights[i].position - point);\n        vec3 reflectDir = reflect(-lightDir, normal);\n\n        float diff = max(dot(normal, lightDir), 0.0);\n        vec3 diffuse = diff * materialColor * lights[i].color;\n\n        float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\n        vec3 specular = spec * lights[i].color;\n\n        result += diffuse + specular;\n    }\n    vec3 ambient = 0.9 * materialColor;\n    result += ambient;\n    return result;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}