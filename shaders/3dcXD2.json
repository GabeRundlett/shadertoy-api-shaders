{
    "Shader": {
        "info": {
            "date": "1572870059",
            "description": "just some jumping sphere...\ninspired by latitude in https://www.shadertoy.com/view/4dcBRN",
            "flags": 0,
            "hasliked": 0,
            "id": "3dcXD2",
            "likes": 9,
            "name": "jumping sphere",
            "published": 3,
            "tags": [
                "domainrepetitionraymarching"
            ],
            "usePreview": 0,
            "username": "talon",
            "viewed": 417
        },
        "renderpass": [
            {
                "code": "float CellSize = 6.0;\nfloat HalfCellSize = 3.0;\n\nconst int RayMarchingStep = 50;\nconst float epsilon = 0.01;\n\nfloat noise(vec2 p ){\n    return fract(sin(p.x*125.+p.y*412.)*5341.);\n}\n\nfloat dist2Sphere(vec3 p ){\n    vec2 id = vec2(floor(p.x/6.0),floor(p.z/6.0));\n    vec3 spherePos = vec3(id.x * CellSize + HalfCellSize ,noise(vec2(id.x+23.4,id.y+37.2))*14.*sin(iTime+length(id)) ,id.y * CellSize + HalfCellSize );\n    \n    float pulse = 0.4 + sin(iTime+id.x*52.+id.y*41.);\n    float radius = 1.2 + pulse;\n    return length( p - spherePos ) - radius ;\n}\n\nfloat dist2Plane(vec3 p ){\n    float height = -10.;\n    return p.y - height;\n}\n\nfloat raymarching(vec3 ro ,vec3 rd ){\n    float depth = 0.0;\n    rd = normalize(rd);\n    for(int i=0;i<RayMarchingStep;i++){\n        float dist = dist2Sphere(ro + depth * rd );\n        dist = min(dist ,dist2Plane(ro + depth * rd ));\n\n        if(dist < epsilon)\n            break;\n        depth = depth + min(dist,2.0);\n    }\n    return depth;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 ro = vec3(-2.0 + 100.*sin(iTime*0.2) ,14.0 ,-2.0 + 100.*cos(iTime*0.1));\n    vec3 lookAt = vec3(8.0,0.0,8.0);\n    \n    float zoom = 0.5;\n    \n    vec3 front = normalize(lookAt - ro);\n    vec3 right = cross(vec3(0.0,1.0,0.0),front);\n    vec3 up = cross(front ,right );\n    \n    vec3 rd = normalize(front * zoom + right * uv.x + up * uv.y) ;\n    \n    float dist = raymarching(ro ,rd );\n    \n    vec3 color = vec3(dist / 80. * vec3(0.0,0.75,0.85));\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}