{
    "Shader": {
        "info": {
            "date": "1712595669",
            "description": "Copy of visual look from [url]https://mastodon.gamedev.place/@daniFMdev/112223202797686927[/url]",
            "flags": 32,
            "hasliked": 0,
            "id": "McGGz1",
            "likes": 36,
            "name": "Too much repetition",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "radial",
                "space",
                "repetition",
                "spacestation"
            ],
            "usePreview": 0,
            "username": "morimea",
            "viewed": 482
        },
        "renderpass": [
            {
                "code": "\n// Created by Danil (2022+) https://github.com/danilw\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n\n// using https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// https://iquilezles.org/articles/normalsSDF\n// https://iquilezles.org/articles/rmshadows\n// using http://mercury.sexy/hg_sdf/\n// using sdf repetition fix from https://www.shadertoy.com/view/WtXcWB\n// using VXAA from https://www.shadertoy.com/view/WdGBDw\n\n\n// copy of visual look from \n// https://mastodon.gamedev.place/@daniFMdev/112223202797686927\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 col = texture(iChannel3, fragCoord.xy/iResolution.xy).rgb;\n    float a = 1.-smoothstep(0.,0.01,dot(col.rgb,vec3(1.)));\n    col=1./0.975*(col.rgb-0.025);\n    col = clamp(col,0.0,1.);\n    \n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    float c = sl(uv*2.5,0.017,0.2,0.2,iTime); \n    c+= sl((0.69*vec2(uv.x+uv.y,-uv.y+uv.x)+31.433)*5.5,0.017,0.15,0.1,iTime);\n    \n    fragColor = vec4(col+c*a,1.);\n\n    \n}\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\n#define PI 3.14159265\n\n#define FIX_FRACT_HASH 1000.\n\nfloat hash12(vec2 p)\n{\np = sign(p)*(floor(abs(p))+floor(fract(abs(p))*FIX_FRACT_HASH)/FIX_FRACT_HASH);\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\np = sign(p)*(floor(abs(p))+floor(fract(abs(p))*FIX_FRACT_HASH)/FIX_FRACT_HASH);\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat sl(vec2 p, float sz, float gr, float x, float t){\n    vec2 ip = 3.33+floor(p/gr)*11.31;\n    float br = 0.;\n    //sz=min(gr*.12,gr*0.2);br = 0.5+sin(3.*t*(0.25+0.75*hash12(ip*23.13)))*0.5;\n    float b = hash12(ip*100.13);\n    float a = b*0.3*sz*hash12(ip*33.13);\n    return (1.-smoothstep(a,a+sz*0.15+sz*0.55*b,0.5*sz*br+length(mod(p,gr)-gr*0.5+0.5*(gr-sz)*(1.-2.*hash22(ip*120.33+0.33)))))*step(hash12(ip*1.13),x);\n}\n\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n\n// http://mercury.sexy/hg_sdf/\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n\n// first object gets a v-shaped engraving where it intersect the second\nfloat fOpEngrave(float a, float b, float r) {\n\treturn max(a, (a + r - abs(b))*sqrt(0.5));\n}\n\n// first object gets a capenter-style groove cut out\nfloat fOpGroove(float a, float b, float ra, float rb) {\n\treturn max(a, min(a + ra, rb - abs(b)));\n}\n\n// first object gets a capenter-style tongue attached\nfloat fOpTongue(float a, float b, float ra, float rb) {\n\treturn min(a, max(a - ra, abs(b) - rb));\n}\n\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nfloat fOpPipe(float a, float b, float r) {\n\treturn length(vec2(a, b)) - r;\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r + a,r + b), vec2(0));\n\treturn min(-r, max (a, b)) + length(u);\n}\n\nfloat fOpIntersectionChamfer(float a, float b, float r) {\n\treturn max(max(a, b), (a + r + b)*sqrt(0.5));\n}\n\n// Difference can be built from Intersection or Union:\nfloat fOpDifferenceChamfer (float a, float b, float r) {\n\treturn fOpIntersectionChamfer(a, -b, r);\n}\n\nfloat fOpUnionChamfer(float a, float b, float r) {\n\treturn min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\nfloat fOpDifferenceRound (float a, float b, float r) {\n\treturn fOpIntersectionRound(a, -b, r);\n}\n\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Created by Danil (2022+) https://github.com/danilw\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n\n// using https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// https://iquilezles.org/articles/normalsSDF\n// https://iquilezles.org/articles/rmshadows\n// using http://mercury.sexy/hg_sdf/\n// using sdf repetition fix from https://www.shadertoy.com/view/WtXcWB\n// using VXAA from https://www.shadertoy.com/view/WdGBDw\n\n\n// copy of visual look from \n// https://mastodon.gamedev.place/@daniFMdev/112223202797686927\n\n\n// angle loop fix\n#define ANGLE_loop (min(iFrame,0))\n//#define ANGLE_loop 0\n\n#define MIN_DIST 0.000001\n#define MAX_DIST 100.\n\n#define MAX_MARCHING_STEPS 512\n#define epsilon_step 0.0001\n\n#define MAX_SHADOW_STEPS 64\n\n#define MD(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n\nconst float obj_SKY_id = -1.;\nconst float obj_1_id = 1.;\nconst float obj_2_id = 2.;\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 p)\n{\n    vec2 res = vec2( MAX_DIST, obj_SKY_id);\n    p.yx*=MD(-iTime*0.015-1.6);\n    {\n        const float rb = 1.75;\n        const float rbh = 1.7;\n        const float rbo = 1.85;\n        float td = sdCappedCylinder(p.xzy, rbh, rb );\n        td = min(td, sdCappedCylinder(p.xzy, rbo, 1.2 ));\n\n        td = fOpIntersectionRound(td, -sdCappedCylinder(p.xzy, 2., 0.8 ), 0.025);\n        td = min(td, max(sdCappedCylinder(p.xzy, rbo-0.05, 1. ), -sdCappedCylinder(p.xzy, 2., 0.77 )));\n        td = fOpGroove(td, sdCappedCylinder(p.xzy, 2., 1. ), 0.035, 0.15);\n\n        float ttd = fOpIntersectionRound(sdCappedCylinder(p.xzy, rbh+0.05, rb-0.15 ),\n        -sdCappedCylinder(p.xzy, 2., rb-0.25 ),0.15)-0.05;\n\n        td = fOpUnionRound(td, ttd, 0.25);\n\n        td = max(td,min(sdCappedCylinder(p.xzy, rbh+0.105, rb ),sdCappedCylinder(p.xzy, 2., 1.4 )));\n        \n        td = min(td,sdCappedCylinder(p.xzy+vec3(0.,0.,1.4),rbo+0.15,0.0045));\n        td = min(td,sdCappedCylinder(p.xzy+vec3(-sign(p.x)*1.3,0.,0.2),rbo+0.2,0.0035));\n        td = min(td,sdCappedCylinder(p.xzy+vec3(0.8,0.,-sign(p.y)*0.4),rbo+0.25,0.0045));\n        \n        res = opU( res, vec2(td, obj_1_id ) );\n    }\n    {\n        float idp = pModPolar(p.xy, 125.);\n        float idl = pModInterval1(p.z, 0.163, -10., 10.);\n        float th = 0.015+0.135*hash12(vec2(idp,idl)*234.);\n\n        // repetition sdf fix from https://www.shadertoy.com/view/WtXcWB\n        float td = sdBox(p+vec3(-1.75-th,0.,0.0), vec3(th,0.032,0.032));\n        float tdn = sdBox(p+vec3(-1.75-0.15,-sign(p.y)*0.163*0.5*1.25,0.0), vec3(0.15,0.032,0.032));\n        float tdk = sdBox(p+vec3(-1.75-0.15,0.0,-sign(p.z)*0.163*0.5*2.), vec3(0.15,0.032,0.032));\n        td=min(td,(abs(idl)<9.5)?min(tdn,tdk):min(td,tdn));\n        res = opU( res, vec2(td, obj_2_id ) );\n    }\n\n    \n    return res;\n}\n\nvec2 raycast( in vec3 ro, in vec3 rd){\n    vec2 res = vec2( MAX_DIST, obj_SKY_id);\n\n    float tmin = MIN_DIST;\n    float tmax = MAX_DIST;\n    float t = tmin;\n    for( int i=ANGLE_loop; i<MAX_MARCHING_STEPS && t<tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t);\n        if( abs(h.x)<(epsilon_step*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax)\n{\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ANGLE_loop; i<MAX_SHADOW_STEPS; i++ )\n    {\n\t\tvec2 th = map( ro + rd*t );\n        float h = th.x; float m = float(th.y==obj_1_id);\n        float s = clamp((20.0+100.*m)*h/t,0.0,1.0);\n        res = min( res, s );\n        t += (1.-0.4*m)*clamp( h, 0.01, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 n = vec3(0.0);\n    for( int i=ANGLE_loop; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n    }\n    return normalize(n);   \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ANGLE_loop; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nvec2 toPolar(vec2 v)\n{\n    v.y+=0.0001*(1.-abs(sign(v.y)));\n    return vec2(atan(v.y, v.x)/3.14159265, length(v));\n}\n\nfloat boxmap(in vec3 p, in vec3 n, in float tsc)\n{\n    p.yx*=MD(-iTime*0.015+0.6);\n\tfloat x = 0.;\n\tfloat y = 0.;\n    float z = 0.;\n    if(abs(n.z)<0.75){x=hash12(floor((vec2(toPolar(p.yx).x*(1.+2.*step(0.4,length(p.xy))),p.z))*tsc*64.*0.5)*64.);y=x;}\n\telse z = hash12( floor(toPolar(p.xy)*tsc*64.)*64.);\n    vec3 m = pow( abs(n), vec3(8.) );\n\treturn (x*m.x + y*m.y + z*m.z) / (m.x + m.y + m.z);\n}\n\nvec4 render( in vec3 ro, in vec3 rd)\n{ \n    // sky\n    vec3 col = vec3(0.);\n    float a = 0.;\n    vec2 res = raycast(ro, rd);\n    float t = res.x;\n\tfloat m = res.y;\n    \n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormal( pos );\n\n    float mat_s = 0.;\n    if(m==obj_1_id){\n        vec3 tno=abs(nor);\n        mat_s = boxmap(pos*.15, nor, .75 );\n        float om = mat_s;\n        mat_s+= boxmap(pos*.25, nor, 1. );\n        mat_s*= boxmap(pos*.35, nor, 1.5 );\n        mat_s+= om*boxmap(pos*.47, nor, 3. );\n        mat_s = smoothstep(.25,1.+1.5*step(abs(nor.z)+step(0.85,length(pos.yx)),0.15),(mat_s*mat_s));\n    \n    }\n    \n    mat_s=(mat_s*2.-1.)*.25-0.15;\n    vec2 tp = mod(pos.xy,0.1);\n    \n\n    if( m>obj_SKY_id )\n    {\n        vec3 ref = reflect( rd, nor );    \n        col = (obj_1_id==m)?vec3(0.3):vec3(0.21);\n        a=1.;\n        float occ = calcAO( pos, nor );\n\t\tvec3 lin = vec3(0.0);\n\n        {\n            const vec3 lightDir = normalize(vec3(0.5, 1.4, -0.85));\n            vec3  hal = normalize( lightDir-rd );\n            float dif = clamp( dot( nor, lightDir ), 0.0, 1.0 );\n            occ = occ*mix(mat_s+.5,1.,0.9*(1.-dif));\n\n        \tdif *= calcSoftshadow( pos, lightDir, 0.02, 20.5 );\n\n            vec3 sunColor = vec3(lightDir.y);\n            lin += col*2.20*dif*sunColor*(0.05+0.95*1./max(0.41,mat_s+0.5));\n        }\n        \n        {\n            float tmat_s=1.-(mat_s+0.5);\n            if(m==obj_1_id)\n            {\n                float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n                dif *= occ;\n            \n                lin += col*0.60*dif*(mix(vec3(0.75),vec3(0.),tmat_s)+0.25);\n            }\n        }\n        \n        col = lin;\n        \n    }\n\n\treturn vec4(col,a);\n}\n\nvoid SetCamera(vec2 uv, out vec3 ro, out vec3 rd)\n{\n    ro = vec3(-6.08, 5.4, -9.25);\n    vec2 m = vec2(0.637, -0.463);\n    m.y = -m.y;\n    float fov=20.;\n    float aspect = iResolution.x / iResolution.y;\n    float screenSize = (1.0 / (tan(((180.-fov)* (3.1415926 / 180.0)) / 2.0)));\n    rd = vec3(uv*screenSize, 1./aspect);\n\n    rd = normalize(rd);\n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    rd = (rotY * rotX) * rd;\n}\n//-------------------------\n\n\nvec3 ACESFilm(vec3 x){\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\nvec3 srgb_encode (vec3 v) {\n  return mix(12.92*v,1.055*pow(v,vec3(.41666))-.055,step(.0031308,v));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nfragCoord.xy += (iFrame % 2 == 0) ? vec2(0.5, 0.5) : vec2(0.0, 0.0);\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    \n    vec3 ro; vec3 rd;\n    SetCamera(uv, ro, rd);\t\n    vec4 color = render( ro, rd );\n    \n    color.rgb = ACESFilm(color.rgb);\n    color.rgb = srgb_encode(color.rgb);\n    \n    color.rgb = clamp(color.rgb,0.,1.);\n    fragColor = vec4(color.rgb*0.975+0.025*color.a, 1.0 );\n}\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\n\n    Copyright 2020 UAA Software\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and\n    associated documentation files (the \"Software\"), to deal in the Software without restriction,\n    including without limitation the rights to use, copy, modify, merge, publish, distribute,\n    sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all copies or substantial\n    portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT\n    NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES\n    OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#define VXAA_TEXTURE_CURRENT iChannel0\n#define VXAA_TEXTURE_PREV iChannel1\n\n#define VXAA_TEMPORALEDGE_THRES 0.08\n#define VXAA_TEMPORALEDGE_TIME_MIN 0.0000001\n#define VXAA_TEMPORALEDGE_TIME_MAX 1.5\n#define VXAA_SPATIAL_FLICKER_TIME 2.75\n\n#define VXAA_W 0\n#define VXAA_E 1\n#define VXAA_N 2\n#define VXAA_S 3\n#define VXAA_NW 0\n#define VXAA_NE 1\n#define VXAA_SW 2\n#define VXAA_SE 3\n\nfloat saturate( float x )\n{\n    return clamp( x, 0.0, 1.0 );\n}\n\nvec4 pow3( vec4 x, float y )\n{\n    return vec4( pow( x.x, y ), pow( x.y, y ), pow( x.z, y ), x.w );\n}\n\nfloat VXAALuma( vec3 c )\n{\n    return dot( c, vec3( 0.2126, 0.7152, 0.0722 ) );\n}\n\nfloat VXAALumaDiff( vec3 x, vec3 y )\n{\n    float l1 = dot( x, vec3( 0.2126, 0.7152, 0.0722 ) );\n    float l2 = dot( y, vec3( 0.2126, 0.7152, 0.0722 ) );\n    return abs( l1 - l2 );\n}\n\nvec3 VXAAClampHistory( vec3 history, vec4 currN[4] )\n{\n    vec3 cmin = min( min( currN[0].rgb, currN[1].rgb ), min( currN[2].rgb, currN[3].rgb ) );\n    vec3 cmax = max( min( currN[0].rgb, currN[1].rgb ), max( currN[2].rgb, currN[3].rgb ) );\n    return vec3(\n        clamp( history.r, cmin.r, cmax.r ),\n        clamp( history.g, cmin.g, cmax.g ),\n        clamp( history.b, cmin.b, cmax.b )\n    );\n}\n\nvec2 VXAADifferentialBlendWeight( vec4 n[4] )\n{\n    float diffWE = VXAALumaDiff( n[ VXAA_W ].rgb, n[ VXAA_E ].rgb );\n    float diffNS = VXAALumaDiff( n[ VXAA_N ].rgb, n[ VXAA_S ].rgb );\n    return diffWE < diffNS ? vec2( 0.5, 0.0 ) : vec2( 0.0, 0.5 );\n}\n\nvec4 VXAADifferentialBlend( vec4 n[4], vec2 w )\n{\n    vec4 c = vec4( 0.0 );\n    c += ( n[ VXAA_W ] + n[ VXAA_E ] ) * w.x;\n    c += ( n[ VXAA_N ] + n[ VXAA_S ] ) * w.y;\n    return c;\n}\n\nvoid VXAAUpsampleT4x( out vec4 vtex[4], vec4 current, vec4 history, vec4 currN[4], vec4 histN[4] )\n{\n    vec4 n1[4], n2[4];\n    \n    n1[VXAA_W] = currN[VXAA_W];\n    n1[VXAA_E] = current;\n    n1[VXAA_N] = history;\n    n1[VXAA_S] = histN[VXAA_S];\n    \n    n2[VXAA_W] = history;\n    n2[VXAA_E] = histN[VXAA_E];\n    n2[VXAA_N] = currN[VXAA_N];\n    n2[VXAA_S] = current;\n    \n    \n    vec4 weights = vec4( VXAADifferentialBlendWeight( n1 ), VXAADifferentialBlendWeight( n2 ) );\n    vtex[VXAA_NW] = history;\n    vtex[VXAA_NE] = VXAADifferentialBlend( n2, weights.zw );\n    vtex[VXAA_SW] = VXAADifferentialBlend( n1, weights.xy );\n    vtex[VXAA_SE] = current;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Sample scene and neighbourhood.\n    \n    vec4 current = clamp( vec4( texture( VXAA_TEXTURE_CURRENT, uv ).rgb, 1.0 ), vec4( 0.0f ), vec4( 1.0f ) );\n    vec4 history = clamp( vec4( texture( VXAA_TEXTURE_PREV, uv ).rgb, 1.0 ), vec4( 0.0f ), vec4( 1.0f ) );\n    current.a = VXAALuma( current.rgb ); history.a = VXAALuma( history.rgb );\n    \n    vec4 currN[4];\n    currN[VXAA_W] = clamp( texture( VXAA_TEXTURE_CURRENT, uv + vec2( -1.0f,  0.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    currN[VXAA_E] = clamp( texture( VXAA_TEXTURE_CURRENT, uv + vec2(  1.0f,  0.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    currN[VXAA_N] = clamp( texture( VXAA_TEXTURE_CURRENT, uv + vec2(  0.0f, -1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    currN[VXAA_S] = clamp( texture( VXAA_TEXTURE_CURRENT, uv + vec2(  0.0f, -1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    currN[VXAA_W].a = VXAALuma( currN[ VXAA_W ].rgb );\n    currN[VXAA_E].a = VXAALuma( currN[ VXAA_E ].rgb );\n    currN[VXAA_N].a = VXAALuma( currN[ VXAA_N ].rgb );\n    currN[VXAA_S].a = VXAALuma( currN[ VXAA_S ].rgb );\n    \n    vec4 histN[4];\n    histN[VXAA_W] = clamp( texture( VXAA_TEXTURE_PREV, uv + vec2( -1.0f,  0.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    histN[VXAA_E] = clamp( texture( VXAA_TEXTURE_PREV, uv + vec2(  1.0f,  0.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    histN[VXAA_N] = clamp( texture( VXAA_TEXTURE_PREV, uv + vec2(  0.0f, -1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    histN[VXAA_S] = clamp( texture( VXAA_TEXTURE_PREV, uv + vec2(  0.0f, -1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    histN[VXAA_W].a = VXAALuma( histN[ VXAA_W ].rgb );\n    histN[VXAA_E].a = VXAALuma( histN[ VXAA_E ].rgb );\n    histN[VXAA_N].a = VXAALuma( histN[ VXAA_N ].rgb );\n    histN[VXAA_S].a = VXAALuma( histN[ VXAA_S ].rgb );\n    history.rgb = VXAAClampHistory( history.rgb, currN );\n   \n    \n    // Temporal checkerboard upsample pass.\n    vec4 vtex[4];\n    VXAAUpsampleT4x( vtex, current, history, currN, histN );\n    \n    // Average all samples.\n    fragColor = ( vtex[VXAA_NW] + vtex[VXAA_NE] + vtex[VXAA_SW] + vtex[VXAA_SE] ) * 0.25f;\n    //if( iMouse.x > fragCoord.x ) fragColor = current;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\n\n    Copyright 2020 UAA Software\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and\n    associated documentation files (the \"Software\"), to deal in the Software without restriction,\n    including without limitation the rights to use, copy, modify, merge, publish, distribute,\n    sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all copies or substantial\n    portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT\n    NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES\n    OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#define VXAA_TEXTURE_CURRENT iChannel1\n#define VXAA_TEXTURE_PREV iChannel2\n\n#define VXAA_TEMPORALEDGE_THRES 0.05\n#define VXAA_TEMPORALEDGE_TIME_MIN 0.0000001\n#define VXAA_TEMPORALEDGE_TIME_MAX 1.15\n#define VXAA_SPATIAL_FLICKER_TIME 2.35\n#define VXAA_MORPHOLOGICAL_STRENGTH 0.42\n#define VXAA_MORPHOLOGICAL_SHARPEN 0.13\n\n#define VXAA_W 0\n#define VXAA_E 1\n#define VXAA_N 2\n#define VXAA_S 3\n#define VXAA_NW 0\n#define VXAA_NE 1\n#define VXAA_SW 2\n#define VXAA_SE 3\n\nfloat saturate( float x )\n{\n    return clamp( x, 0.0, 1.0 );\n}\n\nvec4 pow3( vec4 x, float y )\n{\n    return vec4( pow( x.x, y ), pow( x.y, y ), pow( x.z, y ), x.w );\n}\n\nfloat VXAALuma( vec3 c )\n{\n    return dot( c, vec3( 0.2126, 0.7152, 0.0722 ) );\n}\n\nfloat VXAALumaDiff( vec3 x, vec3 y )\n{\n    float l1 = dot( x, vec3( 0.2126, 0.7152, 0.0722 ) );\n    float l2 = dot( y, vec3( 0.2126, 0.7152, 0.0722 ) );\n    return abs( l1 - l2 );\n}\n\nfloat VXAATemporalContrast( float currentLuma, float historyLuma )\n{\n    float x = saturate( abs( historyLuma - currentLuma ) - VXAA_TEMPORALEDGE_THRES );\n    float x2 = x * x, x3 = x2 * x;\n    return saturate( 3.082671957671837 * x - 3.9384920634917364 * x2 + 1.8518518518516354 * x3 );\n}\n\nfloat VXAAMorphStrengthShaper( float x )\n{\n    return 1.3 * x - 0.3 * x * x;\n}\n\nfloat VXAASpatialContrast( vec2 spatialLumaMinMax )\n{\n    float spatialContrast = spatialLumaMinMax.y - spatialLumaMinMax.x;\n    return mix( 0.0f, 1.0f, spatialContrast );\n}\n\nfloat VXAATemporalFilterAlpha( float fpsRcp, float convergenceTime )\n{\n    return exp( -fpsRcp / convergenceTime );\n}\n\nvec3 VXAAClampHistory( vec3 history, vec4 currN[4] )\n{\n    vec3 cmin = min( min( currN[0].rgb, currN[1].rgb ), min( currN[2].rgb, currN[3].rgb ) );\n    vec3 cmax = max( min( currN[0].rgb, currN[1].rgb ), max( currN[2].rgb, currN[3].rgb ) );\n    return vec3(\n        clamp( history.r, cmin.r, cmax.r ),\n        clamp( history.g, cmin.g, cmax.g ),\n        clamp( history.b, cmin.b, cmax.b )\n    );\n}\n\nvec4 VXAASharpen( vec4 history, vec4 histN[4] )\n{\n    vec4 nh = histN[VXAA_NW] + histN[VXAA_NE] + histN[VXAA_SW] + histN[VXAA_SE];\n    return mix( history, history * 5.0f - nh, VXAA_MORPHOLOGICAL_SHARPEN );\n}\n\nvec4 VXAAMorphological( vec2 uv, vec4 current, vec4 currN[4], float strength )\n{\n    if ( strength < 0.1f ) return current;\n    float lumaNW = currN[VXAA_NW].a, lumaNE = currN[VXAA_NE].a,\n        lumaSW = currN[VXAA_SW].a, lumaSE = currN[VXAA_SE].a;\n    lumaNE += 0.0025;\n    float lumaMin = min( current.a, min( min( lumaNW, lumaNE ), min( lumaSW, lumaSE ) ) );\n    float lumaMax = max( current.a, max( max( lumaNW, lumaNE ), max( lumaSW, lumaSE ) ) );\n    \n    vec2 dir;\n    dir.x = ( lumaSW - lumaNE ) + ( lumaSE - lumaNW );\n    dir.y = ( lumaSW - lumaNE ) - ( lumaSE - lumaNW );\n    vec2 dirN = normalize( dir );\n    \n    vec4 n1 = texture( VXAA_TEXTURE_CURRENT, uv - dirN * strength / iResolution.xy );\n    vec4 p1 = texture( VXAA_TEXTURE_CURRENT, uv + dirN * strength / iResolution.xy );\n    return ( n1 + p1 ) * 0.5;\n}\n\nvec4 VXAAFilmic( vec2 uv, vec4 current, vec4 history, vec4 currN[4], vec4 histN[4] )\n{\n    // Temporal contrast weight.\n    float temporalContrastWeight = VXAATemporalContrast( current.a, history.a );\n\n    // Spatial contrast weight.\n    vec2 spatialLumaMinMaxC = vec2(\n        min( min( currN[0].a, currN[1].a ), min( currN[2].a, currN[3].a ) ),\n        max( max( currN[0].a, currN[1].a ), max( currN[2].a, currN[3].a ) )\n    );\n    vec2 spatialLumaMinMaxH = vec2(\n        min( min( histN[0].a, histN[1].a ), min( histN[2].a, histN[3].a ) ),\n        max( max( histN[0].a, histN[1].a ), max( histN[2].a, histN[3].a ) )\n    );\n    float spatialContrastWeightC = VXAASpatialContrast( spatialLumaMinMaxC );\n    float spatialContrastWeightH = VXAASpatialContrast( spatialLumaMinMaxH );\n    float spatialContrastWeight = abs( spatialContrastWeightC - spatialContrastWeightH );\n    \n    // Evaluate convergence time from weights.\n    float convergenceTime = mix( VXAA_TEMPORALEDGE_TIME_MIN, VXAA_TEMPORALEDGE_TIME_MAX, temporalContrastWeight );\n    convergenceTime = mix( convergenceTime, VXAA_SPATIAL_FLICKER_TIME, spatialContrastWeight );\n    float alpha = VXAATemporalFilterAlpha( iTimeDelta, convergenceTime );\n    \n    // Apply morpholigical AA filter and sharpen.\n    float strength = VXAAMorphStrengthShaper( spatialContrastWeightC * 4.0 ) * VXAA_MORPHOLOGICAL_STRENGTH;\n    current = VXAAMorphological( uv, current, currN, strength );\n    current = VXAASharpen( current, currN );\n    \n    // Clamp history to neighbourhood, and apply filmic blend.\n    history.rgb = VXAAClampHistory( history.rgb, currN );\n    current = mix( current, history, alpha );\n    return current;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Sample scene and neighbourhood.\n    \n    vec4 current = clamp( vec4( texture( VXAA_TEXTURE_CURRENT, uv ).rgb, 1.0 ), vec4( 0.0f ), vec4( 1.0f ) );\n    vec4 history = clamp( vec4( texture( VXAA_TEXTURE_PREV, uv ).rgb, 1.0 ), vec4( 0.0f ), vec4( 1.0f ) );\n    current.a = VXAALuma( current.rgb ); history.a = VXAALuma( history.rgb );\n    \n    vec4 currN[4];\n    currN[VXAA_NW] = clamp( texture( VXAA_TEXTURE_CURRENT, uv + 0.6f * vec2( -1.0f,  1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    currN[VXAA_NE] = clamp( texture( VXAA_TEXTURE_CURRENT, uv + 0.6f * vec2(  1.0f,  1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    currN[VXAA_SW] = clamp( texture( VXAA_TEXTURE_CURRENT, uv + 0.6f * vec2( -1.0f, -1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    currN[VXAA_SE] = clamp( texture( VXAA_TEXTURE_CURRENT, uv + 0.6f * vec2(  1.0f, -1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    currN[VXAA_NW].a = VXAALuma( currN[VXAA_NW].rgb );\n    currN[VXAA_NE].a = VXAALuma( currN[VXAA_NE].rgb );\n    currN[VXAA_SW].a = VXAALuma( currN[VXAA_SW].rgb );\n    currN[VXAA_SE].a = VXAALuma( currN[VXAA_SE].rgb );\n    \n    vec4 histN[4];\n    histN[VXAA_NW] = clamp( texture( VXAA_TEXTURE_PREV, uv + 0.6f * vec2( -1.0f,  1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    histN[VXAA_NE] = clamp( texture( VXAA_TEXTURE_PREV, uv + 0.6f * vec2(  1.0f,  1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    histN[VXAA_SW] = clamp( texture( VXAA_TEXTURE_PREV, uv + 0.6f * vec2( -1.0f, -1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    histN[VXAA_SE] = clamp( texture( VXAA_TEXTURE_PREV, uv + 0.6f * vec2(  1.0f, -1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    histN[VXAA_NW].a = VXAALuma( histN[VXAA_NW].rgb );\n    histN[VXAA_NE].a = VXAALuma( histN[VXAA_NE].rgb );\n    histN[VXAA_SW].a = VXAALuma( histN[VXAA_SW].rgb );\n    histN[VXAA_SE].a = VXAALuma( histN[VXAA_SE].rgb );\n    \n    \n    // Filmic pass.    \n    fragColor = VXAAFilmic( uv, current, history, currN, histN );\n    //if( iMouse.x > fragCoord.x ) fragColor = current;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/**\n* Creative Commons CC0 1.0 Universal (CC-0)\n*\n* A basic TAA implementation based on the variance clipping technique by Marco Salvi (Nvidia).\n*\n*/\n\n#define TEXTURE_CURRENT iChannel2\n#define TEXTURE_PREV iChannel3\n\nconst ivec2 offsets[8u] = ivec2[]\n(\n    ivec2(-1,-1), ivec2(-1, 1), \n\tivec2(1, -1), ivec2(1, 1), \n\tivec2(1, 0),  ivec2(0, -1), \n\tivec2(0, 1),  ivec2(-1, 0)\n);\n\nconst float gaussian[8u] = float[]\n(\n    .0625, .0625,\n    .0625, .0625,\n    .125,  .125,\n    .125,  .125\n);\n\nvec3 RGBToYCoCg(vec3 RGB)\n{\n    float Y = dot(RGB, vec3(1, 2,  1))  * .25;\n    float Co= dot(RGB, vec3(2, 0, -2))  * .25 + (.5 * 256./255.);\n    float Cg= dot(RGB, vec3(-1, 2, -1)) * .25 + (.5 * 256./255.);\n    return vec3(Y, Co, Cg) * (1. / (1. + Y)); // tonemap\n}\n\nvec3 YCoCgToRGB(vec3 YCoCg)\n{\n    YCoCg *= 1. / (1. - YCoCg.x); // tonemap\n\tfloat Y= YCoCg.x;\n\tfloat Co= YCoCg.y - (.5 * 256. / 255.);\n\tfloat Cg= YCoCg.z - (.5 * 256. / 255.);\n\tfloat R= Y + Co - Cg;\n\tfloat G= Y + Cg;\n\tfloat B= Y - Co - Cg;\n\treturn vec3(R, G, B);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 currentBuffer = RGBToYCoCg(textureLod(TEXTURE_CURRENT, uv, 0.).rgb);\n    vec3 historyBuffer = RGBToYCoCg(textureLod(TEXTURE_PREV, uv, 0.).rgb);\n\n    vec3 mean = currentBuffer;\n    vec3 variance = currentBuffer * currentBuffer;\n    vec3 filtered = currentBuffer * .25;\n    \n    // Marco Salvi's Implementation (by Chris Wyman)\n    for(int i = 0; i < 8; i++)\n    {\n        vec3 neighborTexel = RGBToYCoCg(texelFetch(TEXTURE_CURRENT, ivec2(fragCoord.xy) + offsets[i], 0).rgb);\n        mean += neighborTexel;\n        variance += neighborTexel * neighborTexel;\n        filtered += neighborTexel * gaussian[i];\n    }\n    \n    mean /= 9.;\n    variance /= 9.;\n    const float stDevMultiplier = 1.5;\n\tvec3 sigma = sqrt(abs(variance - mean * mean));\n\tvec3 colorMin = min(filtered, mean - stDevMultiplier * sigma);\n\tvec3 colorMax = max(filtered, mean + stDevMultiplier * sigma);\n    \n    historyBuffer = clamp(historyBuffer, colorMin, colorMax);\n    \n    vec3 outColor = mix(historyBuffer, filtered, .05);\n\n\tfragColor = vec4(YCoCgToRGB(outColor), 1.);\n    \n    fragColor = clamp(fragColor,0.,1.);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}