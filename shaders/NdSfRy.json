{
    "Shader": {
        "info": {
            "date": "1646497402",
            "description": "Been a while since I wrote a raytracer. This is sorta a refresher for me.\n\nI saw https://www.shadertoy.com/view/tlcXWX and wanted to play with lighting and shadows again.\n\n",
            "flags": 0,
            "hasliked": 0,
            "id": "NdSfRy",
            "likes": 6,
            "name": "Fire Gyroid",
            "published": 3,
            "tags": [
                "shadows",
                "gyroids"
            ],
            "usePreview": 0,
            "username": "JuliaPoo",
            "viewed": 402
        },
        "renderpass": [
            {
                "code": "#define EP .001\n#define SCENE_END 20.\n#define TRACE_MAX_STEPS 200\n\n#define PI 3.1415\n#define sTime iTime*.07\n\n#define SCENE_ID_DEFAULT 0\n#define SCENE_ID_OBJECT 1\n#define SCENE_ID_GROUND 2\n#define SCENE_ID_LIGHT 3\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Camera {\n    vec3 pos;\n    vec3 lookat;\n    float zoom;\n    float fov;\n};\n\nstruct LightBase {\n    vec3 colour;\n};\n\nstruct LightDirectional {\n    vec3 direction;\n    vec3 colour;\n};\n\nstruct LightPoint {\n    vec3 position;\n    vec3 colour;\n};\n\nLightBase clightBase = LightBase(.7*vec3(1.000,0.510,0.302));\n\nLightDirectional clightDirectional = \\\n    LightDirectional(normalize(vec3(1.)), .3*vec3(1., .2, .1));\n    \nLightPoint clightPoint = \\\n    LightPoint(vec3(0.), .9*vec3(1.8,1.2,1.));\n\nfloat cheap_cos(in float x)\n{\n    float a = mod(x,2.)-1.;\n    float b = sign(mod(x,4.)-2.);\n    a = 1.5*a - .5*a*a*a;\n    return a * b;\n}\n\nmat2 rot(in float a) {\n    float c = cheap_cos(a);\n    float s = sign(2.-mod(a,4.)) * sqrt(1.-c*c);\n    return mat2(c, -s, s, c);\n}\n\nfloat Primitive_sdGyroid(in vec3 p, in float scale, in float thickness)\n{\n    p /= scale;\n    float gyroid = dot(sin(p), cos(p.yzx));\n    return .7*scale*(abs(gyroid) - thickness);\n}\n\nfloat Primitive_sdSphere(in vec3 p, in float radius)\n{\n    return length(p) - radius;\n}\n\nfloat Primitive_sdBox(in vec3 p, in vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat Primitive_smoothUnion(in float d1, in float d2, in float k)\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat Primitive_smoothIntersect(in float d1, in float d2, in float k)\n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n    \nfloat Primitive_smoothSubtract(in float d1, in float d2, in float k)\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat Object_sdBall(in vec3 p)\n{\n    float ball = Primitive_sdSphere(p, 1.);\n    float gyroid = Primitive_sdGyroid(p, .2, .3);\n    ball = Primitive_smoothIntersect(ball, gyroid, .05);\n    ball = Primitive_smoothSubtract(Primitive_sdSphere(p, .9), ball, .05);\n    return ball;\n}\n\nfloat Scene_sdf_Object(in vec3 p)\n{\n    // Optimization\n    float dp = length(p);\n    if (dp > 1.1) {return dp - 1.;}\n    \n    float sc; vec3 _p = p;\n\n    _p.yz *= rot(sTime); _p.zx *= rot(sTime);\n    float ball = Object_sdBall(_p);\n    \n    sc = .8;\n    _p = p; \n    _p.yz *= rot(-sTime*.7 + .5); _p.zx *= rot(sTime);\n    ball = min(ball, sc*Object_sdBall(_p/sc));\n    return ball;\n}\n\nfloat Scene_sdf_Ground(in vec3 p)\n{\n    // Optimization\n    float dp = p.y;\n    if (dp > 1.2) {return dp + 1.;}\n    \n    float ground = p.y + 1.1;\n    float l = length(p.xz);\n    ground += cheap_cos(l*5. - sTime*4.) * .1*smoothstep(0.,2.,l);\n    return ground;\n}\n\nfloat Scene_sdf_Light(in vec3 p)\n{\n    p -= clightPoint.position;\n    return Primitive_sdSphere(p, .1);\n}\n\nfloat Scene_sdf(in vec3 p)\n{\n    float object = Scene_sdf_Object(p);\n    float ground = Scene_sdf_Ground(p);\n    float light = Scene_sdf_Light(p);\n    \n    float sdf = min(object, ground);\n    sdf = min(sdf, light);\n    return sdf;\n}\n\nvec3 Scene_normal(in vec3 p) {\n\tconst vec2 e = vec2(EP, 0);\n\treturn normalize(vec3(Scene_sdf(p + e.xyy)-Scene_sdf(p - e.xyy), \n                          Scene_sdf(p + e.yxy)-Scene_sdf(p - e.yxy),\t\n                          Scene_sdf(p + e.yyx)-Scene_sdf(p - e.yyx)));\n}\n\nfloat _Scene_sdf(in vec3 p, inout float d_light_min, inout float d_object_min)\n{\n    float object = Scene_sdf_Object(p);\n    float ground = Scene_sdf_Ground(p);\n    float light = Scene_sdf_Light(p);\n    \n    d_light_min = min(d_light_min, light);\n    d_object_min = min(d_object_min, object);\n    \n    float sdf = min(object, ground);\n    sdf = min(sdf, light);\n    return sdf;\n}\n\nfloat Ray_trace(inout Ray ray, out float d_light_min, out float d_object_min, out int surface_id)\n{\n    vec3 p = ray.origin;\n    vec3 d = ray.direction;\n    float dist = 0.;\n    d_light_min = SCENE_END;\n    d_object_min = SCENE_END;\n    \n    for (int i = 0; i < TRACE_MAX_STEPS; ++i) {\n        vec3 _p = p + dist*d;\n        float _d = _Scene_sdf(_p, d_light_min, d_object_min);\n        dist += _d;\n        if (_d < EP) break;\n        if (dist > SCENE_END) break;\n    }\n    ray.origin = p + dist*d;\n    \n    surface_id = SCENE_ID_DEFAULT;\n    if (Scene_sdf_Object(ray.origin) < EP) surface_id = SCENE_ID_OBJECT;\n    else if (Scene_sdf_Ground(ray.origin) < EP) surface_id = SCENE_ID_GROUND;\n    else if (Scene_sdf_Light(ray.origin) < EP) surface_id = SCENE_ID_LIGHT;\n    \n    return dist;\n}\n\nvec3 LightBase_computeLighting(in LightBase light)\n{\n    return light.colour;\n}\n\nvec3 LightDirectional_computeLighting(in LightDirectional light, in vec3 normal)\n{\n    float weight = dot(normal, light.direction);\n    return light.colour * clamp(weight, 0., 1.);\n}\n\nvec3 LightPoint_computeLighting(in LightPoint light, in vec3 position, in vec3 normal)\n{\n    float weight = dot(normal, normalize(light.position - position));\n    return light.colour * clamp(weight, 0., 1.);\n}\n\nvec3 LightPoint_computeShadow(in LightPoint light, in vec3 position, in vec3 normal)\n{\n    vec3 v = light.position - position;\n    vec3 rd = normalize(v);\n    float d_light_min, d_object_min;\n    int surface_id;\n    Ray ray = Ray(position + rd*3.*EP/dot(rd, normal), rd);\n    float dist = Ray_trace(ray, d_light_min, d_object_min, surface_id);\n    \n    // Compute soft shadows uwu\n    float w = 3. * pow(length(v) / SCENE_END, 2.);\n    float w2 = smoothstep(0., w, d_object_min);\n    return vec3(w2);\n}\n\nvec3 LightPoint_computeBleed(in LightPoint light, in vec3 position, in vec3 direction, in vec3 normal) \n{\n    float x = -dot(normal, light.position - position);\n        \n    // Compute cheap bleed\n    float w1 = .8;\n    float w2 = .7;\n    float bleed = w1 - clamp(x+(1.-w1), 0., 1.);\n    vec3 col = w2 * bleed * light.colour;\n\n    // Compute cheap subscattering\n    w1 = 1.;\n    w2 = 4.;\n    bleed = w1 - clamp(x+(1.-w1), .7, 1.);\n    col += w2 * bleed*bleed*bleed * vec3(1.,.1,.3);\n\n    // Compute glare\n    w1 = 1.;\n    w2 = 10.;\n    bleed = w1 - clamp(x+(1.-w1), 0., 1.);\n    bleed *= 1.-smoothstep(0.,1.,\n        length(\n            dot(direction, light.position - position)*direction + position-light.position\n        )\n    );\n    col += w2 * bleed*bleed*bleed * clightPoint.colour;\n    \n    return col;\n}\n\nvec3 Ray_lighting(in Ray ray)\n{\n    float t = sTime*2.;\n    clightPoint.position = vec3(0.) + \\\n        .2*vec3(cheap_cos(t*10.), cheap_cos(t*13.+5.), cheap_cos(t*17.+2.)) + \\\n        .02*vec3(cheap_cos(t*50.), cheap_cos(t*57.+5.), cheap_cos(t*47.+2.));\n    \n    float d_light_min, d_object_min;\n    int surface_id;\n    float d = Ray_trace(ray, d_light_min, d_object_min, surface_id);\n    \n    vec3 col = vec3(0);\n    \n    if (surface_id == SCENE_ID_LIGHT) {\n        col = clightPoint.colour;\n        return col;\n    }\n    else {\n    \n        vec3 normal = Scene_normal(ray.origin);\n    \n        col += LightPoint_computeLighting(clightPoint, ray.origin, normal);\n        col *= LightPoint_computeShadow(clightPoint, ray.origin, normal);\n        \n        col += LightBase_computeLighting(clightBase);\n        col += LightDirectional_computeLighting(clightDirectional, normal);\n        \n        col += LightPoint_computeBleed(clightPoint, ray.origin, ray.direction, normal); \n    }\n    \n    // Compute cheap distance fog\n    float fog = 1. - smoothstep(1., 4., d);\n    col *= fog*fog;\n    col = clamp(col, 0., 1.);\n    \n    // Compute cheap light fog\n    fog = clamp(.03/(d_light_min+.01), 0.,1.);\n    col += fog * clightPoint.colour;\n    \n    return col;\n}\n\nvoid Camera_init(inout Camera cam) \n{\n    cam.pos = vec3(0,0,-3.);\n    cam.lookat = vec3(0);\n    cam.zoom = 1.;\n    cam.fov = 1.;\n}\n\nvoid Camera_mouse(inout Camera cam)\n{\n    vec2 m = (iMouse.xy / iResolution.xy -.5 )*2.;\n    cam.pos.xz *= rot(m.x);\n    cam.pos.zy *= rot(m.y);\n    cam.pos.y = max(cam.pos.y, -1.);\n}\n\nRay Camera_projectRay(in Camera cam, in vec2 uv)\n{\n    vec3 front = normalize(cam.lookat - cam.pos);\n    vec3 screen_origin = cam.pos + front * cam.zoom;\n    vec3 vert = vec3(0,1.,0);\n    vec3 up = normalize(vert-front*dot(vert, front));\n    vec3 right = cross(front, up);\n    \n    uv *= cam.fov;\n    vec3 ro = screen_origin + uv.x * right + uv.y * up;\n    vec3 rd = normalize(ro - cam.pos);\n    return Ray(ro, rd);\n}\n\nvoid Image_postProcessing(inout vec3 col)\n{\n    // Contrast!\n    col *= col;\n    // Cinematic\n    col += 2.*vec3(.01,.05,.07);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    Camera cam; Camera_init(cam);\n    Camera_mouse(cam);\n    Ray ray = Camera_projectRay(cam, uv);\n    \n    vec3 col = Ray_lighting(ray);\n    Image_postProcessing(col);\n    \n    fragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}