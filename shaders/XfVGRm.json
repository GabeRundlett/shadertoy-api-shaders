{
    "Shader": {
        "info": {
            "date": "1712574088",
            "description": "Use the mouse...\nIt doesn't work. It is difficult to maintain distances from a deformed edge. Does anyone know how to do it? I thought the 2d distances and gradients from Inigo Quilez might be helpful, but I don't know how.",
            "flags": 0,
            "hasliked": 0,
            "id": "XfVGRm",
            "likes": 2,
            "name": "Distances to the edge.",
            "published": 3,
            "tags": [
                "voronoi"
            ],
            "usePreview": 0,
            "username": "Umbre",
            "viewed": 104
        },
        "renderpass": [
            {
                "code": "vec3 sdgCircle( in vec2 p, in float r ) \n{\n    float d = length(p);\n    return vec3( d-r, p/d );\n}\n\nvec3 sdgBox( in vec2 p, in vec2 b )\n{\n    vec2 w = abs(p)-b;\n    vec2 s = vec2(p.x<0.0?-1:1,p.y<0.0?-1:1);\n    float g = max(w.x,w.y);\n    vec2  q = max(w,0.0);\n    float l = length(q);\n    return vec3(   (g>0.0)?l  :g,\n                s*((g>0.0)?q/l:((w.x>w.y)?vec2(1,0):vec2(0,1))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy * 2.0 - 1.0;\n    m.x *= iResolution.x/iResolution.y;\n\n    //construction objet1\n    vec2 param1 = vec2(0.26,0.34);\n    vec2 point1 = vec2(-0.19,0.1221);\n    float size1 = -sdgBox(vec2(0.),param1).x;\n    vec3 grad1 = sdgBox(uv-point1,param1);\n    float distCenter1 = distance(uv,point1);\n    \n    float influence1;\n    if (grad1<0.)\n    {\n        influence1 = 0;\n    }\n    else\n    {\n        influence1 = abs(grad1.x)/(abs(grad1.x) + distCenter1);\n    }\n    \n    //construction objet2\n    float param2 = 0.65;\n    vec2 point2 = m;\n    float size2 = -sdgCircle(vec2(0.),param2).x;\n    vec3 grad2 = sdgCircle(uv-point2,param2);\n    float distCenter2 = distance(uv,point2);\n    float influence1;\n    \n    if (grad2<0.)\n    {\n        influence2 = 0;\n    }\n    else\n    {\n        influence2 = abs(grad2.x)/(abs(grad2.x) + distCenter2);\n    }\n    // on trie les objets dans l'ordre d'influence\n    vec2 p1, p2;\n    float s1, s2;\n    vec3 g1, g2;\n    float i1, i2;\n    if(influence1 > influence2)\n    {\n        p1 = point1;\n        s1 = size1;\n        g1 = grad1;\n        i1 = influence1;\n        \n        p2 = point2;\n        s2 = size2; \n        g2 = grad2;\n        i2 = influence2;\n        \n    }\n    else\n    {\n        p2 = point1;\n        s2 = size1;\n        g2 = grad1;\n        i2 = influence1;\n        \n        p1 = point2;\n        s1 = size2; \n        g1 = grad2;\n        i1 = influence2;\n    }\n    \n    //???? \n    vec3 col = vec3(i1);\n\n    //coulors :\n    col = cos(30.*clamp(col,0.,1.));\n    if(p1==point1)\n    {\n        col*= vec3(0.8,0.2,0.2);\n    }\n    else\n    {\n        col*= vec3(0.2,0.8,0.8);\n    }\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}