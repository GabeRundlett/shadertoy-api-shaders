{
    "Shader": {
        "info": {
            "date": "1429846790",
            "description": "Anti Aliasing on left, no antialiasing on right.",
            "flags": 0,
            "hasliked": 0,
            "id": "MtB3RG",
            "likes": 7,
            "name": "FlipTri AntiAliasing",
            "published": 3,
            "tags": [
                "antialiasing",
                "flipquad"
            ],
            "usePreview": 0,
            "username": "demofox",
            "viewed": 2032
        },
        "renderpass": [
            {
                "code": "/*\n  Written by Alan Wolfe\n  http://demofox.org/\n  http://blog.demofox.org/\n\n\nFliptri anti aliasing works by using 3 samples per pixel in the following configuration (which shows 4 pixels):\n\n        B           B\n  +-----*-----+-----*-----+\n  |           |           |\n  |           |           |\n  |           |           |\n C*           |           *C\n  |           |           |\n  |           |           |\n  |           |A          |\n  +-----------*-----------+\n  |           |           |\n  |           |           |\n  |           |           |\n C*           |           *C\n  |           |           |\n  |           |           |\n  |           |           |\n  +-----*-----+-----*-----+\n        B           B\n\nA has a weight of 0.2, B,C have a weight of 0.4 each.\n\nA is shared by 4 pixels, B and C are shared by 2 pixels each.\n\nThis makes it so that you can render 1.25 samples per pixel, but get 3x SSAA.\n\nIn shadertoy you can't render to texture (yet), so i actually do all 3 samples, but\nthis has the same visual result as if the samples were actually shared.\n\nMore info here: http://blog.demofox.org/2015/04/23/flipquad-fliptri-antialiasing/\n\n*/\n\n\n#define MINSCALE 1.0\n#define MAXSCALE 8.0\n#define TIMEMULTIPLIER 0.5\n\n\n#define DRAW_CIRCLE(_x,_y,_radius,_color) if (length(pos-vec2(_x,_y)) < _radius) return _color;\n\n#define DRAW_RECT(_x,_y,_w,_h,_color) if ((abs(pos.x-(_x)) < _w/2.0)&&(abs(pos.y-(_y)) < _h/2.0)) return _color;\n\n#define DRAW_OBB(_x,_y,_w,_h,_r,_color) {vec2 rel = vec2(pos.x-(_x), pos.y-(_y)); rel = vec2(cos(_r)*rel.x-sin(_r)*rel.y,sin(_r)*rel.x+cos(_r)*rel.y); if ((abs(rel.x) < _w/2.0)&&(abs(rel.y-_y) < _h/2.0)) return _color;}\n\nvec3 GetPixelColor(vec2 pos)\n{\n    // thin white grill\n    DRAW_RECT(-0.0,0.50,1.0,0.005,vec3(1,1,1));\n    DRAW_RECT(-0.0,0.52,1.0,0.005,vec3(1,1,1));\n    DRAW_RECT(-0.0,0.54,1.0,0.005,vec3(1,1,1));\n    DRAW_RECT(-0.0,0.56,1.0,0.005,vec3(1,1,1));\n    DRAW_RECT(-0.0,0.58,1.0,0.005,vec3(1,1,1));\n    DRAW_RECT(-0.0,0.60,1.0,0.005,vec3(1,1,1));\n    \n    // textured circles\n    DRAW_CIRCLE(-0.7, 0.7,0.25,texture(iChannel0, pos).xyz);\n    DRAW_CIRCLE(-0.7,-0.7,0.25,texture(iChannel1, pos).xyz);\n    DRAW_CIRCLE( 0.7,-0.7,0.25,texture(iChannel2, pos).xyz);\n    DRAW_CIRCLE( 0.7, 0.7,0.25,texture(iChannel3, pos).xyz);\n    \n    // spinning red and blue box\n    DRAW_OBB(-0.5, 0.0, 0.3, 0.1,  iTime, vec3(1.0, 0.0, 0.0));\n    DRAW_OBB(-0.5, 0.0, 0.1, 0.3, -iTime, vec3(0.0, 0.0, 1.0));\n    \n    // concentric spiral boxes\n    DRAW_OBB( 0.5, 0.0, 0.1, 0.1, 0.4, vec3(0.0));\n    DRAW_OBB( 0.5, 0.0, 0.2, 0.2, 0.3, vec3(1.0));\n    DRAW_OBB( 0.5, 0.0, 0.3, 0.3, 0.2, vec3(0.0));\n    DRAW_OBB( 0.5, 0.0, 0.4, 0.4, 0.1, vec3(1.0));\n    DRAW_OBB( 0.5, 0.0, 0.5, 0.5, 0.0, vec3(0.0));\n       \n    // untextured circles\n    DRAW_CIRCLE(0.0,0.0,0.1,vec3(0.9,0.1,0.9));\n    DRAW_CIRCLE(0.0,0.0,1.0,vec3(0.1,0.9,0.1));\n    \n    // grid background\n    float gridColor = mod(floor(pos.x*20.0),2.0) == mod(floor(pos.y*20.0),2.0) ? 0.8 : 0.0;  \n    return vec3(gridColor);\n}\n\nvec2 PixelToWorld (in vec2 coord, in vec2 resolution, in float g_arcorrection, in float g_scale, in vec2 cameraOffset)\n{\n    vec2 ret = ((coord / resolution) - vec2(0.5,0.5*g_arcorrection)) * g_scale;\n    ret *= vec2(g_arcorrection, -1.0);\n    return ret + cameraOffset;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t       \n    // camera wander: sin(time) controls magnitude, time controls angle\n    float cameraAngle = iTime * 0.32;\n    float cameraMag = sin(iTime*0.89) * 0.25 +1.0;\n\n    vec2 cameraOffset = vec2(cameraMag * cos(cameraAngle), cameraMag * sin(cameraAngle));\n\n    // aspect ratio correction\n    vec2 resolution = vec2 (iResolution.x / 2.0, iResolution.x);\n    float g_arcorrection = resolution.x / resolution.y;\n\n    // image zoom, defined by time\n    float g_scale = (sin(iTime * TIMEMULTIPLIER + 1.57) * 0.5 + 0.5) * (MAXSCALE - MINSCALE) + MINSCALE;    \n    \n\tvec3 pixelColor;\n    \n    // draw middle line\n    if (abs(fragCoord.x - resolution.x) < 2.0)\n    {\n        pixelColor = vec3(1.0,1.0,1.0);\n    }\n    // right side = no AA\n\telse if( fragCoord.x > resolution.x)\n\t{\n        fragCoord.x -= resolution.x;\n        pixelColor = GetPixelColor(PixelToWorld(fragCoord.xy, resolution, g_arcorrection, g_scale, cameraOffset));\n\t}\n\t// left side = AA\n\telse\n    {\n        bool xOdd = (floor(mod(fragCoord.x,2.0)) == 1.0);\n        bool yOdd = (floor(mod(fragCoord.y,2.0)) == 1.0);\n               \n        vec2 a = vec2(xOdd ? -0.5 : 0.5, yOdd ? -0.5  : 0.5 );\n        vec2 b = vec2(0.0, yOdd ? 0.5 : -0.5);\n        vec2 c = vec2(xOdd ? 0.5 : -0.5, 0.0 );\n        \n        pixelColor  = GetPixelColor(PixelToWorld(fragCoord.xy + a, resolution, g_arcorrection, g_scale, cameraOffset)) * 0.2;\n        pixelColor += GetPixelColor(PixelToWorld(fragCoord.xy + b, resolution, g_arcorrection, g_scale, cameraOffset)) * 0.4;\n        pixelColor += GetPixelColor(PixelToWorld(fragCoord.xy + c, resolution, g_arcorrection, g_scale, cameraOffset)) * 0.4;\n\t}\t\t\n\n    // write pixel\n\tfragColor = vec4(pixelColor, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    }
                ],
                "name": "",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}