{
    "Shader": {
        "info": {
            "date": "1690119133",
            "description": "Pixel packed states to reach max size pow(xres*yres*24,1/3), e.g 205^3 for a 800x450 buffer (!). Speed obviously suffers with larger size.\n\nCONTROLS: up/down=prev/next CA, b=box, 7-9=speed, c=color method, v=view, p=pause, space=regen, w/s=zoom,  t=text\n",
            "flags": 48,
            "hasliked": 0,
            "id": "DsSBWy",
            "likes": 16,
            "name": "Huge 3D Automata",
            "published": 3,
            "tags": [
                "3d",
                "interactive",
                "voxel",
                "automata"
            ],
            "usePreview": 0,
            "username": "misol101",
            "viewed": 312
        },
        "renderpass": [
            {
                "code": "\n// Increase SIZE in Common if your GPU can handle it!\n\n// Press UP/DOWN for variants.\n\n// More keys: b=box, 7-9=speed, c=color, v=view, p=pause, space=regen, w/s=zoom\n\n\n// Voxel cube from https://www.shadertoy.com/view/4lfSW4 by glk7\n\n#define EPS 0.001\n\nfloat N;\nint colmethod;\nint bbox;\nbool inverted;\n\nfloat text(vec2 uv, float index)\n{\n    float col = 0.0;\n    vec2 center = text_res/2.0;\n    \n    text_pos(2, 2.0 + STRHEIGHT(0.0));\n    col += print_integer(index,0,uv) + _lsl() + print_integer(LAST_PATT,0,uv);// + _spc() + print_integer(iFrameRate,0,uv); \n    \n    return col;\n}\n\n\n// Taken from https://iquilezles.org/articles/palettes\nvec3 ColorPalette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat cellval( in ivec3 p )\n{\n    int iN=int(N);\n    int n=p.x+p.y*iN+p.z*iN*iN;\n    int pos = (6-1) - (n % 6);\n    int pi=(n%CPP)/6;\n    n /= CPP;\n\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    ivec2 p2 = ivec2(n%r.x,n/r.x);\n\n    vec4 outv = texelFetch(iChannel0, p2, 0 );\n\n    int val = int(outv[pi]);\n    val >>= 4*pos;\n    val = val & 0xf;\n    \n    return float(val);\n}\n\nbool map(in vec3 p, out float v) \n{\n    p+=5.; // 0 == -5\n\n    if (bbox == 1) {\n        int NM=int(N)-1;\n        int x=int(p.x),y=int(p.y),z=int(p.z);\n        if ((x==0 && y==0) || (x==0 && z==0) || (y==0 && z==0) || (x==NM && y==NM) || (x==NM && z==NM) || (y==NM && z==NM)  || (y==0 && z==NM) || (x==0 && z==NM) || (x==0 && y==NM)  || (y==0 && x==NM) || (z==0 && y==NM)  || (z==0 && x==NM) ) {\n            v=-1.;\n            return true;\n        }\n    }\n\n    float cv = cellval(ivec3(p));\n\n    if(colmethod == 1) {\n        v=cv*0.12; // col by state value\n    } else\n        v=length(p-N/2.)*0.1+1.5; // col by distance\n\n    return !inverted ? cv > 1. : int(cv) == 1;\n}\n\nbool IRayAABox(in vec3 ro, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax, out vec3 p0, out vec3 p1) \n{\n    vec3 t0 = (bmin - ro) * invrd;\n    vec3 t1 = (bmax - ro) * invrd;\n\n    vec3 tmin = min(t0, t1);\n    vec3 tmax = max(t0, t1);\n    \n    float fmin = max(max(tmin.x, tmin.y), tmin.z);\n    float fmax = min(min(tmax.x, tmax.y), tmax.z);\n    \n    p0 = ro + rd*fmin;\n    p1 = ro + rd*fmax;\n    return fmax >= fmin;   \n}\n\nvec3 AABoxNormal(vec3 bmin, vec3 bmax, vec3 p) \n{\n    return normalize(smoothstep(0.1, 0.0, bmax - p) - \n                     smoothstep(0.1, 0.0, p - bmin));\n}\n\nbool Voxels(in vec3 ro, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax, out vec3 n, out vec3 p, out float v)\n{\n    n = vec3(0.0);\n    p = vec3(0.0);\n    v = 0.0;\n    \n    vec3 re = vec3(0.0);\n    vec3 pa = vec3(0.0);\n    if (!IRayAABox(ro, rd, invrd, bmin, bmax, ro, re)) return false;\n    \n    if (dot(re - ro, rd) < EPS) return false;\n    vec3 ep = floor(ro + rd*EPS);\n\n    bool ret = false;\n    for (int i = 0; i < int(N*3.); ++i) {\n        if (map(ep, v)) {\n            ret = true;\n            break;\n        }\n\n        IRayAABox(ro - rd*2.0, rd, invrd, ep, ep+1.0, pa, ro);\n        ep = floor(ro + rd*EPS);\n\n        if (dot(re - ro, rd) < EPS) {\n            ret = false;\n            break;\n        }\n\n    }\n    \n    if (ret) {\n    \tn = AABoxNormal(ep, ep+1.0, ro);\n        p = ro;   \n    }\n    return ret;\n}\n\nfloat ShadowFactor(in vec3 ro, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax) \n{\n    vec3 re = vec3(0.0);\n    vec3 pa = vec3(0.0);\n    \n    IRayAABox(ro, -rd, -invrd, bmin, bmax, re, pa);\n    if (dot(re - ro, rd) <= EPS) return 1.0;\n    \n    vec3 ep = floor(ro + rd*EPS);\n    float v = 0.0;\n    float ret = 1.0;\n    for (float i = 0.0; i < 32.; ++i) {\n        if (map(ep, v)) {\n            ret = -i;\n        \tbreak;\n        }\n        \n        IRayAABox(ro - rd*2.0, rd, invrd, ep, ep+1.0, pa, ro);\n        ep = floor(ro + rd*EPS);\n        \n        if (dot(re - ro, rd) <= EPS) {\n            ret = 1.0;\n            break;\n        }\n    }\n    \n    return ret;\n}\n\nfloat AOFactor(in vec3 ro, in vec3 n, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax) \n{\n    float t = ShadowFactor(ro, rd, invrd, bmin, bmax);\n    return (1.0 - step(0.0, t)) * clamp(-t * 0.3, 0.0, 1.0) + (step(0.0, t)) * t;\n}\n\nfloat AmbientOcclusion(in vec3 ro, in vec3 n, in vec3 bmin, in vec3 bmax) \n{   \n    const float nf = 0.707;\n    const vec3 v0 = (vec3(1.0, 1.0, 0.0) * nf) + EPS;\n    const vec3 v1 = (vec3(-1.0, 1.0, 0.0) * nf) + EPS;\n    const vec3 v2 = (vec3(0.0, 1.0, 1.0) * nf) + EPS;\n    const vec3 v3 = (vec3(0.0, 1.0, -1.0) * nf) + EPS;\n    \n    const vec3 v4 = -v0;\n    const vec3 v5 = -v1;\n    const vec3 v6 = -v2;\n    const vec3 v7 = -v3;\n    \n    const vec3 invv0 = 1.0/v0;\n    const vec3 invv1 = 1.0/v1;\n    const vec3 invv2 = 1.0/v2;\n    const vec3 invv3 = 1.0/v3;\n    const vec3 invv4 = 1.0/v4;\n    const vec3 invv5 = 1.0/v5; \n    const vec3 invv6 = 1.0/v6;\n    const vec3 invv7 = 1.0/v7;\n    vec3 invn = 1.0/(n);\n    \n    float r = 0.0;\n    r += AOFactor(ro, n, n, invn, bmin, bmax);\n\tr += AOFactor(ro, n, v0, invv0, bmin, bmax);\n    r += AOFactor(ro, n, v1, invv1, bmin, bmax);\n    r += AOFactor(ro, n, v2, invv2, bmin, bmax);\n    r += AOFactor(ro, n, v3, invv3, bmin, bmax);\n    r += AOFactor(ro, n, v4, invv4, bmin, bmax);\n    r += AOFactor(ro, n, v5, invv5, bmin, bmax);\n\tr += AOFactor(ro, n, v6, invv6, bmin, bmax);\n    r += AOFactor(ro, n, v7, invv7, bmin, bmax);\n    \n    return clamp(r * 0.2, 0.0, 1.0);\n}\n\n\nvec3 GetColor(float v) \n{\n\treturn ColorPalette(v, vec3(0.5, 0.5, 0.5), \n                           vec3(0.5), \n                           vec3(0.6, 0.4, 0.3), \n                           vec3(0.6, 0.4, 0.3));  \n}\n\nvoid CameraOrbitRay(in vec2 fragCoord, in float n, in vec3 c, in float d, float zmod, int view,\n                    out vec3 ro, out vec3 rd, out mat3 t) \n{\n    float yp=-3., xrot=-0.66;\n    if (view == 1) yp=0., xrot=0.0;\n    if (view == 2) yp=0., xrot=1.;\n\n    float a = 1.0/max(iResolution.x, iResolution.y);\n    rd = normalize(vec3((fragCoord - iResolution.xy*0.5)*a, n));\n \n    ro = vec3(0.0, yp, -d+zmod);\n\n    float mxc, myc;\n    if (iMouse.z > 0.) {\n        mxc = clamp(-((iMouse.x / iResolution.x)*2.0 - 1.0), -1.0, 1.0);\n        myc = clamp((iMouse.y / iResolution.y)*2.0 - 1.0, -1.0, 1.0);\n    } else {\n        mxc=sin(sin(iTime*0.33))*1.17;\n        myc = xrot;\n    }\n\n    float mxs = sqrt(1.0-(mxc*mxc));\n    float mys = sqrt(1.0-(myc*myc));\n    \n    t = mat3(mxc, mxs, 0, -mxs*myc, mxc*myc, mys, mxs*mys, -mxc*mys, myc);\n        \n    ro = t * ro;\n    ro = c + ro;\n\n    rd = t * rd;\n    rd = normalize(rd);\n}\n\nvec3 LightDir(in mat3 t) \n{\n    vec3 l = normalize(vec3(-1.0, -1.0, 1.0));\n    return t * l;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    N=SIZE;\n    int maxsize = int(pow(iResolution.x*iResolution.y*float(CPP), 1./3.));\n    if (maxsize < int(N)) N=float(maxsize-(1-maxsize%2));\n\n    float index = texelFetch(iChannel1, ivec2(0,0), 0 ).x;\n    float hidetext = texelFetch(iChannel1, ivec2(4,0), 0 ).x;\n    colmethod = int(texelFetch(iChannel1, ivec2(6,0), 0 ).x);\n    float zmod = texelFetch(iChannel1, ivec2(7,0), 0 ).x;\n    int view = int(texelFetch(iChannel1, ivec2(10,0), 0 ).x);\n    bbox = int(texelFetch(iChannel1, ivec2(8,0), 0 ).x);\n\n    text_res = iResolution.xy / DOWN_SCALE;\n    float text_pixel = 0.;\n    if (hidetext < 1.) text_pixel = text(fragCoord, index);    \n\n    inverted = getInverted(int(index));\n\n   \tvec3 bpos = vec3(-5.0);\n    \n   \tvec3 bmin = vec3(N, N, N) + bpos;\n    vec3 bmax = vec3(0.0, 0.0, 0.0) + bpos;\n    \n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    mat3 t = mat3(1.0);\n    CameraOrbitRay(fragCoord, 0.5, bpos+vec3(N*0.5), N*1.37, zmod, view, ro, rd, t);\n    \n    vec3 l = LightDir(t);\n    \n    vec3 invrd = 1.0 / rd;\n    vec3 invl = 1.0 / l;\n    \n    vec3 p = vec3(0.0);\n    vec3 n = vec3(0.0);\n    float v = 0.0;\n    \n    vec3 color = vec3(0.03, 0.03, 0.03);\n    #ifdef HORIZON\n    float yp=(iResolution.y - fragCoord.y);\n    float hp=0.10; if(view==1) hp=0.4; if(view==2) hp=1.;\n    float yf1=iResolution.y*hp, yf2=iResolution.y*(hp+0.2);\n    if (yp >= yf1 && yp < yf2) color = mix(vec3(0.4, 0.45, 0.85),vec3(0.03, 0.03, 0.03), 1.-(yf2-yp)/(yf2-yf1));\n    else if (yp < yf1) color = vec3(0.4, 0.45, 0.85);\n    #endif\n \n    if (Voxels(ro, rd, invrd, bmin, bmax, n, p, v)) {\n    \tcolor = GetColor(v);\n        vec3 diff = color * max(dot(-l, n), 0.0);\n        diff *= clamp(ShadowFactor(p, -l, -invl, bmin, bmax), 0.0, 1.0);\n        vec3 amb = color * AmbientOcclusion(p, n, bmin, bmax) * 0.7 + color * 0.3;\n        color = diff*0.8 + amb*0.2;\n    }\n   \n    color = pow(color, vec3(0.55));\n    fragColor = vec4(color, 1.0);\n    \n    fragColor += text_pixel;    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "music",
                        "id": 35,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Persistive Keyboard Input buffer\n\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_7     = 55;\nconst int KEY_8     = 56;\nconst int KEY_9     = 57;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_P     = 80;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\n\nbool readKey( int key ) {\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, .25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nvec4 keyStep(int ix, int iy, int key, float delta, float maxval) {\n    vec3 keystate = texelFetch(iChannel0, ivec2(ix,iy), 0 ).xyz;\n    float kx=keystate.x;\n    float ky=keystate.y;\n    if( readKey(key) ) {\n        if (ky == 0.) {\n            kx+=1.;\n            if (kx >= maxval) kx=0.;\n            if (kx < 0.) kx=maxval-delta;\n        }\n        ky+=0.01;\n        if (ky >= 1.0) ky=0.;\n    }\n    else {\n        ky = 0.;\n    }\n    return vec4(kx,ky,0.,0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int ix = int(fragCoord.x), iy = int(fragCoord.y);\n\n    if (iy > 1) { fragColor = vec4(0.,0.,0.,1.0); return; }\n\n    if (ix == 0 && iy == 0) {\n        vec3 keystate = texelFetch(iChannel0, ivec2(ix,iy), 0 ).xyz;\n        float kx=keystate.x;\n        float ky=keystate.y;\n        if( readKey(KEY_UP)||readKey(KEY_DOWN)||readKey(KEY_LEFT)||readKey(KEY_RIGHT) ) {\n            if (ky == 0.) {\n                if (readKey(KEY_DOWN) || readKey(KEY_RIGHT)) {\n                    kx+=1.001;\n                    if (kx > LAST_PATT+0.5) kx=0.5;\n                } else {\n                    kx-=1.001;\n                    if (kx < 0.) kx=LAST_PATT+0.5;\n                }\n            }\n            ky+=0.01;\n            if (ky >= 1.0) ky=0.;\n        }\n        else {\n            ky = 0.;\n        }\n        fragColor = vec4(kx,ky,0.,0.);\n        return;\n    }\n\n    if (ix == 2 && iy == 0) {\n        float speed = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_7)) speed = 0.;\n        if( readKey(KEY_8)) speed = -1.;\n        if( readKey(KEY_9)) speed = 5.;\n        fragColor = vec4(speed,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 4 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_T, 1., 2.);\n        return;\n    }\n\n    if (ix == 6 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_C, 1., 2.);\n        return;\n    }\n\n    if (ix == 7 && iy == 0) {\n        float zmod = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_W)) zmod += 1.;\n        if( readKey(KEY_S)) zmod -= 1.;\n        zmod = clamp(zmod, -20., 40.);\n        fragColor = vec4(zmod,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 8 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_B, 1., 2.);\n        return;\n    }\n\n    if (ix == 9 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_P, 1., 2.);\n        if (readKey(KEY_DOWN) || readKey(KEY_UP))\n            fragColor = vec4(0.);\n        return;\n    }\n\n    if (ix == 10 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_V, 1., 3.);\n        return;\n    }\n\n\n    fragColor = vec4(0.,0.,0.,1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Automata buffer, pixel packed with 4 bits per state and max 8 digits per component for 6*4=24 cells per pixel \n\nint N;\n\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_SPACE  = 32;\nconst int KEY_D  = 68;\n\nbool readKey( int key ) {\n\tfloat keyVal = texture( iChannel2, vec2( (float(key)+.5)/256.0, .25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nint cell( in ivec3 p, int xp,int yp, int zp) {\n    int n=(p.x+xp)+(p.y+yp)*N+(p.z+zp)*N*N;\n    int pos = (6-1) - (n % 6);\n    int pi=(n%CPP)/6;\n    n/=CPP;\n\n    int resx = int(iResolution.x);\n    ivec2 p2 = ivec2(n%resx, n/resx);\n    \n    int val = int(texelFetch(iChannel0, p2, 0 )[pi]);\n    val >>= 4*pos;\n    val = val & 0xf;\n    return val == int(liveval) ? 1 : 0;\n}\n\nint cellwrap( in ivec3 p, int xp,int yp, int zp) {\n    int x=p.x+xp, y=p.y+yp, z=p.z+zp;\n    if (x==0) x=N-2;  if (x==N-1) x=1;\n    if (y==0) y=N-2;  if (y==N-1) y=1;\n    if (z==0) z=N-2;  if (z==N-1) z=1;\n    int n=x+y*N+z*N*N;\n    int pos = (6-1) - (n % 6);\n    int pi=(n%CPP)/6;\n    n/=CPP;\n\n    int resx = int(iResolution.x);\n    ivec2 p2 = ivec2(n%resx, n/resx);\n    \n    int val = int(texelFetch(iChannel0, p2, 0 )[pi]);\n    val >>= 4*pos;\n    val = val & 0xf;\n    return val == int(liveval) ? 1 : 0;\n}\n\nint cellval( in ivec3 p, int xp,int yp, int zp) {\n    int n=(p.x+xp)+(p.y+yp)*N+(p.z+zp)*N*N;\n    int pos = (6-1) - (n % 6);\n    int pi=(n%CPP)/6;\n    n/=CPP;\n\n    int resx = int(iResolution.x);\n    ivec2 p2 = ivec2(n%resx, n/resx);\n    \n    int val = int(texelFetch(iChannel0, p2, 0 )[pi]);\n    val >>= 4*pos;\n    val = val & 0xf;\n    return val;\n}\n\nvec4 cv4( in ivec3 p, int xp,int yp, int zp) {\n    int n=(p.x+xp)+(p.y+yp)*N+(p.z+zp)*N*N;\n    n/=CPP;\n\n    int resx = int(iResolution.x);\n    ivec2 p2 = ivec2(n%resx, n/resx);\n    \n    return texelFetch(iChannel0, p2, 0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    N=int(SIZE);\n    int maxsize = int(pow(iResolution.x*iResolution.y*float(CPP), 1./3.));\n    if (maxsize < N) { N=maxsize-(1-maxsize%2); }\n\n    int pos1d=int(fragCoord.x) + int(fragCoord.y) * int(iResolution.x);\n    pos1d *= CPP;\n    if (pos1d > N*N*N) { fragColor = vec4(0.); return; }\n    fragCoord.x = float(pos1d % int(iResolution.x));\n    fragCoord.y = float(pos1d / int(iResolution.x));\n\n    int index = int(texelFetch(iChannel1, ivec2(0,0), 0 ).x);\n    float xres = texelFetch(iChannel3, ivec2(0,0), 0 ).x;\n    int speed = 1+int(texelFetch(iChannel1, ivec2(2,0), 0 ).x);\n    int pause = int(texelFetch(iChannel1, ivec2(9,0), 0 ).x);\n\n    int z=pos1d/(N*N);\n    pos1d-=z*N*N;\n    int y=pos1d/N;\n    int x=pos1d-y*N;\n\n    setRules(index);\n    if (readKey(KEY_D) && withermethod >= 0) { setRules(withermethod); } //wither\n\n    ivec4 fst=ivec4(0);\n\n    bool regen = iFrame < 1 || readKey(KEY_SPACE) || readKey(KEY_UP) || readKey(KEY_DOWN) || int(xres) != int(iResolution.x);\n\n    speed += speedplus;\n    if (!regen && (iFrame % (speed+1) > 0 || pause == 1)) {\n        fragColor = cv4(ivec3(x,y,z),0,0,0);\n        return;\n    }\n\n    for (int i=0; i<CPP; i++) {\n        int fi=i/6;\n        int xi=x+i,yi=y,zi=z;\n        if (xi >= N) {xi-=N; yi++; if (yi >= N) {yi=0; zi++;}}\n        ivec3 pos3d=ivec3(xi,yi,zi);\n\n        int NM=N-1;\n        if (xi==0 || yi==0 || zi==0 || xi==NM || yi==NM || zi==NM) { \n            fst[fi] = fst[fi]<<4;\n            continue;\n        }\n\n        if (regen) {\n            pos3d-=N/2;\n\n            if (hash1(fragCoord.x*0.03*fragCoord.y*0.021+iTime*0.04) < density) {\n                if (clearmethod == 0) {\n                    if (length(vec3(pos3d))<radius) {\n                        fst[fi] = (fst[fi] << 4) | int(liveval);\n                        continue;\n                    }\n                } else if (clearmethod == 1) {\n                    int iradius=int(radius);\n                    if (abs(pos3d.x)<iradius && abs(pos3d.y)<iradius && abs(pos3d.z)<iradius) {\n                        fst[fi] = (fst[fi] << 4) | int(liveval);\n                        continue;\n                    }\n                } else {\n                    fst[fi] = (fst[fi] << 4) | int(liveval);\n                    continue;\n                }\n            }\n            fst[fi] = (fst[fi] << 4);\n            continue;\n        }\n\n        int st = cellval(pos3d,0,0,0);\n\n        int count = 0;\n        if (countmethod == 0) {\n            // Mooore\n            if (wrap == 1) {\n                for (int i=-1; i<=1; i++)\n                    for (int j=-1; j<=1; j++)\n                        for (int k=-1; k<=1; k++)\n                            if((i|j|k)!=0)\n                                count += cellwrap(pos3d,i,j,k);\n            } else {\n                for (int i=-1; i<=1; i++)\n                    for (int j=-1; j<=1; j++)\n                        for (int k=-1; k<=1; k++)\n                            if((i|j|k)!=0)\n                                count += cell(pos3d,i,j,k);\n            }\n        } else {\n            // Neumann \n            if (wrap == 1) {\n                count = cellwrap(pos3d,0,-1,0) + cellwrap(pos3d,0,1,0) + cellwrap(pos3d,-1,0,0) + cellwrap(pos3d,1,0,0) + cellwrap(pos3d,0,0,-1) + cellwrap(pos3d,0,0,1);\n            } else {\n                count = cell(pos3d,0,-1,0) + cell(pos3d,0,1,0) + cell(pos3d,-1,0,0) + cell(pos3d,1,0,0) + cell(pos3d,0,0,-1) + cell(pos3d,0,0,1);\n            }\n        }\n\n        if(st <= 1) {\n            if (((1<<count) & bornset) > 0)\n                st = int(liveval);\n        }\n        else {\n            if (((1<<count) & liveset) == 0)\n                st--;\n        }\n\n        fst[fi] = (fst[fi] << 4) | st;\n\n        fragCoord.x+=1.;\n        if(fragCoord.x >= iResolution.y) { fragCoord.y+=1.; fragCoord.x=0.; }\n    }\n\n    fragColor = vec4(fst);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define SIZE 125.\n\nconst int CPP = 24; // Cells Per Pixel (only 6,12,18,24 will work)\n\n#define HORIZON\n\nconst float LAST_PATT = 23.01;\n\nint liveset, bornset, clearmethod, countmethod, withermethod;\nfloat liveval;\nfloat radius;\nfloat density;\nint speedplus, wrap;\n\nvoid setRules(int index) {\n    int v1, v2;\n    countmethod=0, clearmethod=0, withermethod=-1;\n    speedplus=0, wrap=1;\n\n    if (index == 0) {  liveval=10.; v1=240, v2=448; radius=6.; density=0.4;  withermethod=8; }                          // pyroclastic\n    if (index == 1) {  countmethod=1; liveval=2.; v1=127, v2=10; clearmethod=1; radius=1.0; density=1.0; speedplus=4; wrap=0; } // crystal\n    if (index == 2) {  liveval=8.;  v1=5382088, v2=9701408; radius=8.0; density=0.5; speedplus=-1; wrap=0; }            // amoeba II\n    if (index == 3) {  liveval=2.;  v1=134209536, v2=942080; clearmethod=2; density=0.499; wrap=1; }                    // clouds\n    if (index == 4) {  liveval=2.;  v1=593808, v2=2195520; radius=35.0; density=0.3; wrap=0; }                          // slowburning star\n    if (index == 5) {  liveval=4.;  v1=134217600, v2=16; clearmethod=1; radius=12.0; density=0.5; wrap=1; }             // struct builder\n    if (index == 6) {  liveval=5.;  v1=371520, v2=63793088; clearmethod=1; radius=6.0; density=0.6; }                   // expanding shells\n    if (index == 7) {  liveval=2.;  v1=0, v2=2; clearmethod=1; radius=1.0; density=1.0; speedplus=20; wrap=0; }         // single point\n    if (index == 8) {  liveval=10.; v1=580, v2=848; radius=13.; density=0.1;  withermethod=0; }                         // builder\n    if (index == 9) {  liveval=5.;  v1=16, v2=16; clearmethod=1; radius=15.0; density=0.4; }                            // 445\n    if (index == 10) { countmethod=1; liveval=2.; v1=127, v2=10; clearmethod=1; radius=4.0; density=1.0; speedplus=4;wrap=0; } // crystal (same, radius change)\n    if (index == 11) { liveval=3.;  v1=448, v2=448; radius=24.0; density=0.4; wrap=0;}                                  // 678\n    if (index == 12) { liveval=10.; v1=5382088, v2=9701408; radius=10.0; density=0.5; speedplus=-1; wrap=0; }           // amoeba II slow\n    if (index == 13) { liveval=7.;  v1=148064, v2=53477506; radius=1.0; clearmethod=1; density=1.; speedplus=12; }      // build cube\n    if (index == 14) { liveval=8.;  v1=21635016, v2=1052704; clearmethod=2; density=0.5; wrap=0; }                      // wither\n    if (index == 15) { liveval=11.; v1=65646754, v2=1123384; radius=7.; density=0.5; wrap=0; }                          // constant explosions\n    if (index == 16) { liveval=2.;  v1=134209536, v2=942080; clearmethod=2; density=0.515; wrap=0; }                    // clouds II\n    if (index == 17) { liveval=2.;  v1=134209536, v2=942080; clearmethod=2; density=0.58; wrap=0; }                     // clouds III (funkycube)\n\n    if (index == 18) { liveval=4.;  v1=134217600, v2=16; clearmethod=1; radius=17.0; density=0.5; wrap=0; }             // inv. struct builder\n    if (index == 19) { liveval=8.;  v1=5382088, v2=9701408; radius=10.0; density=0.5; speedplus=-1; wrap=0; }           // inv. amoeba II\n    if (index == 20) { liveval=5.;  v1=16, v2=16; clearmethod=1; radius=20.0; density=0.4; }                            // inv. 445\n    if (index == 21) { liveval=2.;  v1=134209536, v2=942080; clearmethod=2; density=0.52; wrap=1; }                     // inv. clouds\n    if (index == 22) { liveval=5.;  v1=134217216, v2=45280; clearmethod=0; radius=10.; density=0.8; wrap=0; }           // inv. amoeba I\n    if (index == 23) { liveval=5.;  v1=38553186, v2=2506768; clearmethod=0; radius=14.; density=0.58; wrap=0; }         // inv. little puffs\n\n    if (index==1 || index==10 || index==13) withermethod=4;\n    if (index==2 || index==15) withermethod=14;\n\n    liveset = v1; bornset = v2;\n}\n\nbool getInverted(int index) {\n    return index >= 18;\n}\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*138.5453123);\n}\n\n\n\n// FONT\n// From https://www.shadertoy.com/view/Mt2GWD by Flyguy\n\n#define DOWN_SCALE 1.0\n\n#define MAX_INT_DIGITS 4\n\n#define CHAR_SIZE vec2(8, 12)\n#define CHAR_SPACING vec2(8, 12)\n\n#define STRWIDTH(c) (c * CHAR_SPACING.x)\n#define STRHEIGHT(c) (c * CHAR_SPACING.y)\n\n#define NORMAL 0\n#define INVERT 1\n#define UNDERLINE 2\n\nint TEXT_MODE = NORMAL;\n\n//Automatically generated from the 8x12 font sheet here:\n//http://www.massmind.org/techref/datafile/charset/extractor/charset_extractor.htm\n\nvec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000);\nvec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000);\nvec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000);\nvec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000);\nvec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000);\nvec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000);\nvec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000);\nvec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000);\nvec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000);\nvec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000);\nvec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000);\nvec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000);\nvec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000);\nvec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000);\nvec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000);\nvec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000);\nvec4 ch_0 = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000);\nvec4 ch_1 = vec4(0x001030,0xF03030,0x303030,0xFC0000);\nvec4 ch_2 = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000);\nvec4 ch_3 = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000);\nvec4 ch_4 = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000);\nvec4 ch_5 = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000);\nvec4 ch_6 = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000);\nvec4 ch_7 = vec4(0x00FEC6,0xC6060C,0x183030,0x300000);\nvec4 ch_8 = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000);\nvec4 ch_9 = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000);\nvec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000);\nvec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000);\nvec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000);\nvec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000);\nvec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000);\nvec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000);\nvec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000);\nvec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000);\nvec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000);\nvec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000);\nvec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000);\nvec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000);\nvec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000);\nvec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000);\nvec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000);\nvec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000);\nvec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000);\nvec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000);\nvec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000);\nvec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000);\nvec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000);\nvec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000);\nvec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000);\nvec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00);\nvec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000);\nvec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000);\nvec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000);\nvec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000);\nvec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000);\nvec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000);\nvec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000);\nvec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000);\nvec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000);\nvec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000);\nvec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000);\nvec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000);\nvec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000);\nvec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00);\nvec4 ch_a = vec4(0x000000,0x00780C,0x7CCCCC,0x760000);\nvec4 ch_b = vec4(0x00E060,0x607C66,0x666666,0xDC0000);\nvec4 ch_c = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000);\nvec4 ch_d = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000);\nvec4 ch_e = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000);\nvec4 ch_f = vec4(0x00386C,0x6060F8,0x606060,0xF00000);\nvec4 ch_g = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78);\nvec4 ch_h = vec4(0x00E060,0x606C76,0x666666,0xE60000);\nvec4 ch_i = vec4(0x001818,0x007818,0x181818,0x7E0000);\nvec4 ch_j = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78);\nvec4 ch_k = vec4(0x00E060,0x60666C,0x786C66,0xE60000);\nvec4 ch_l = vec4(0x007818,0x181818,0x181818,0x7E0000);\nvec4 ch_m = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000);\nvec4 ch_n = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000);\nvec4 ch_o = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000);\nvec4 ch_p = vec4(0x000000,0x00DC66,0x666666,0x7C60F0);\nvec4 ch_q = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E);\nvec4 ch_r = vec4(0x000000,0x00EC6E,0x766060,0xF00000);\nvec4 ch_s = vec4(0x000000,0x0078CC,0x6018CC,0x780000);\nvec4 ch_t = vec4(0x000020,0x60FC60,0x60606C,0x380000);\nvec4 ch_u = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000);\nvec4 ch_v = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000);\nvec4 ch_w = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000);\nvec4 ch_x = vec4(0x000000,0x00C66C,0x38386C,0xC60000);\nvec4 ch_y = vec4(0x000000,0x006666,0x66663C,0x0C18F0);\nvec4 ch_z = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000);\nvec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000);\nvec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000);\nvec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000);\nvec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000);\nvec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000);\n\nvec2 text_res = vec2(0);\nvec2 print_pos = vec2(0);\n\n//Extracts bit b from the given number.\n//Shifts bits right (num / 2^bit) then ANDs the result with 1 (mod(result,2.0)).\nfloat extract_bit(float n, float b)\n{\n    b = clamp(b,-1.0,24.0);\n\treturn floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n}\n\n//Returns the pixel at uv in the given bit-packed sprite.\nfloat sprite(vec4 spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    \n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));\n    \n    float pixels = 0.0;\n    pixels += extract_bit(spr.x, bit - 72.0);\n    pixels += extract_bit(spr.y, bit - 48.0);\n    pixels += extract_bit(spr.z, bit - 24.0);\n    pixels += extract_bit(spr.w, bit - 00.0);\n    \n    return bounds ? pixels : 0.0;\n}\n\n//Prints a character and moves the print position forward by 1 character width.\nfloat char(vec4 ch, vec2 uv)\n{\n    if( TEXT_MODE == INVERT )\n    {\n      //Inverts all of the bits in the character.\n      ch = pow(2.0,24.0)-1.0-ch;\n    }\n    if( TEXT_MODE == UNDERLINE )\n    {\n      //Makes the bottom 8 bits all 1.\n      //Shifts the bottom chunk right 8 bits to drop the lowest 8 bits,\n      //then shifts it left 8 bits and adds 255 (binary 11111111).\n      ch.w = floor(ch.w/256.0)*256.0 + 255.0;  \n    }\n\n    float px = sprite(ch, CHAR_SIZE, uv - print_pos);\n    print_pos.x += CHAR_SPACING.x;\n    return px;\n}\n\n\n//Returns the digit sprite for the given number.\nvec4 get_digit(float d)\n{\n    d = floor(d);\n    \n    if(d == 0.0) return ch_0;\n    if(d == 1.0) return ch_1;\n    if(d == 2.0) return ch_2;\n    if(d == 3.0) return ch_3;\n    if(d == 4.0) return ch_4;\n    if(d == 5.0) return ch_5;\n    if(d == 6.0) return ch_6;\n    if(d == 7.0) return ch_7;\n    if(d == 8.0) return ch_8;\n    if(d == 9.0) return ch_9;\n    return vec4(0.0);\n}\n\n//Prints out the given number starting at pos.\nfloat print_number(float number, vec2 uv)\n{\n    float result = 0.0;\n    \n\tfor(int i = 3;i >= -1;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n        \n        if(i == -1) //Add a decimal point.\n        {\n            result += char(ch_per,uv);\n        }\n        \n        if(abs(number) > pow(10.0, float(i)) || i == 0) //Clip off leading zeros.\n        {\n        \tresult += char(get_digit(digit),uv);\n        }\n    }   \n    return result;\n}\n\nfloat print_integer(float number, int zeros, vec2 uv)\n{\n    float result = 0.0;\n    \n\tfor(int i = MAX_INT_DIGITS;i >= 0;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n\n        if(abs(number) > pow(10.0, float(i)) || zeros > i  || i == 0) //Clip off leading zeros.\n        {\n        \tresult += char(get_digit(digit),uv);\n        }\n    }   \n    return result;\n}\n\n\nfloat text_mode(int mode) {\n    TEXT_MODE = mode;\n    return 0.;\n}\n\n#define text_pos(a,b) print_pos = vec2(a, b)\n\n#define _spc() char(ch_spc,uv)\n#define _exc() char(ch_exc,uv)\n#define _quo() char(ch_quo,uv\n#define _hsh() char(ch_hsh,uv)\n#define _dol() char(ch_dol,uv)\n#define _pct() char(ch_pct,uv)\n#define _amp() char(ch_amp,uv)\n#define _apo() char(ch_apo,uv)\n#define _lbr() char(ch_lbr,uv)\n#define _rbr() char(ch_rbr,uv)\n#define _ast() char(ch_ast,uv)\n#define _crs() char(ch_crs,uv)\n#define _com() char(ch_com,uv)\n#define _dsh() char(ch_dsh,uv)\n#define _per() char(ch_per,uv)\n#define _lsl() char(ch_lsl,uv)\n#define _0() char(ch_0,uv)\n#define _1() char(ch_1,uv)\n#define _2() char(ch_2,uv)\n#define _3() char(ch_3,uv)\n#define _4() char(ch_4,uv)\n#define _5() char(ch_5,uv)\n#define _6() char(ch_6,uv)\n#define _7() char(ch_7,uv)\n#define _8() char(ch_8,uv)\n#define _9() char(ch_9,uv)\n#define _col() char(ch_col,uv)\n#define _scl() char(ch_scl,uv)\n#define _les() char(ch_les,uv)\n#define _equ() char(ch_equ,uv)\n#define _grt() char(ch_grt,uv)\n#define _que() char(ch_que,uv)\n#define _ats() char(ch_ats,uv)\n#define _A() char(ch_A,uv)\n#define _B() char(ch_B,uv)\n#define _C() char(ch_C,uv)\n#define _D() char(ch_D,uv)\n#define _E() char(ch_E,uv)\n#define _F() char(ch_F,uv)\n#define _G() char(ch_G,uv)\n#define _H() char(ch_H,uv)\n#define _I() char(ch_I,uv)\n#define _J() char(ch_J,uv)\n#define _K() char(ch_K,uv)\n#define _L() char(ch_L,uv)\n#define _M() char(ch_M,uv)\n#define _N() char(ch_N,uv)\n#define _O() char(ch_O,uv)\n#define _P() char(ch_P,uv)\n#define _Q() char(ch_Q,uv)\n#define _R() char(ch_R,uv)\n#define _S() char(ch_S,uv)\n#define _T() char(ch_T,uv)\n#define _U() char(ch_U,uv)\n#define _V() char(ch_V,uv)\n#define _W() char(ch_W,uv)\n#define _X() char(ch_X,uv)\n#define _Y() char(ch_Y,uv)\n#define _Z() char(ch_Z,uv)\n#define _lsb() char(ch_lsb,uv)\n#define _rsl() char(ch_rsl,uv)\n#define _rsb() char(ch_rsb,uv)\n#define _pow() char(ch_pow,uv)\n#define _usc() char(ch_usc,uv)\n#define _a() char(ch_a,uv)\n#define _b() char(ch_b,uv)\n#define _c() char(ch_c,uv)\n#define _d() char(ch_d,uv)\n#define _e() char(ch_e,uv)\n#define _f() char(ch_f,uv)\n#define _g() char(ch_g,uv)\n#define _h() char(ch_h,uv)\n#define _i() char(ch_i,uv)\n#define _j() char(ch_j,uv)\n#define _k() char(ch_k,uv)\n#define _l() char(ch_l,uv)\n#define _m() char(ch_m,uv)\n#define _n() char(ch_n,uv)\n#define _o() char(ch_o,uv)\n#define _p() char(ch_p,uv)\n#define _q() char(ch_q,uv)\n#define _r() char(ch_r,uv)\n#define _s() char(ch_s,uv)\n#define _t() char(ch_t,uv)\n#define _u() char(ch_u,uv)\n#define _v() char(ch_v,uv)\n#define _w() char(ch_w,uv)\n#define _x() char(ch_x,uv)\n#define _y() char(ch_y,uv)\n#define _z() char(ch_z,uv)\n#define _lpa() char(ch_lpa,uv)\n#define _bar() char(ch_bar,uv)\n#define _rpa() char(ch_rpa,uv)\n#define _tid() char(ch_tid,uv)\n#define _lar() char(ch_lar,uv)\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// resolution change\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { fragColor = vec4(iResolution.x); }\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}