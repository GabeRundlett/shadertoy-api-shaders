{
    "Shader": {
        "info": {
            "date": "1591696901",
            "description": "I am releasing a no-shadows version of the shader. For some reason uncommenting lines 211-231 and line 255 causes the compile time to go out of control on Windows+Nvidia despite only a handful of shadow steps being taken. Someone know why?",
            "flags": 0,
            "hasliked": 0,
            "id": "wllczN",
            "likes": 20,
            "name": "Flooded Megacity (no shadows)",
            "published": 3,
            "tags": [
                "voxels",
                "city",
                "ruins"
            ],
            "usePreview": 1,
            "username": "ShnitzelKiller",
            "viewed": 506
        },
        "renderpass": [
            {
                "code": "#define FDIST 0.5\n\n#define CELL_SIZE 3.\n#define MINI_CELL_SIZE .15\n#define WINDOW_SIZE vec3(0.5, 0.5, 0.45)\n#define WINDOW_STRIDE 1.\n#define WINDOW_THICKNESS 0.05\n#define ROOM_DEPTH 10.\n#define MAX_VOXELS 200\n#define REFLECTION_VOXELS 20\n#define REFRACTION_VOXELS 10\n#define MAX_HEIGHT 40.\n#define SHADOW_STEPS 10\n#define EPS 0.005\n#define SHADOW_EPS 0.01\n#define WATER_HEIGHT -2.\n#define IOR 1.33\n#define GLASS_IOR 5.\n#define ABSORPTION_RATE vec3(0.7, 0.8, 0.9)\n\n#define WATER_MAT 6\n\n#define MOON_COL vec3(0.4, 0.4, 0.4)\n#define MOON_RADIUS 0.11\n#define AMBIENT_COL vec3(0.1, 0.1, 0.15)\n\n#define SILL_COLOR vec3(1., 0.9, 0.9)\n\n#define PI 3.141593\n\nstruct Hit {\n    float t;\n    int mat;\n    vec3 n;\n    vec3 id;\n};\n\n\nfloat hash( in vec3 P )\n{\n    //  https://github.com/BrianSharpe/Wombat/blob/master/Value3D.glsl\n\n    // establish our grid cell and unit position\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n    vec3 Pf_min1 = Pf - 1.0;\n\n    // clamp the domain\n    Pi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\n    vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\n\n    // calculate the hash\n    vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\n    Pt *= Pt;\n    Pt = Pt.xzxz * Pt.yyww;\n    vec2 hash_mod = vec2( 1.0 / ( 635.298681 + vec2( Pi.z, Pi_inc1.z ) * 48.500388 ) );\n    vec4 hash_lowz = fract( Pt * hash_mod.xxxx );\n    vec4 hash_highz = fract( Pt * hash_mod.yyyy );\n\n    //\tblend the results and return\n    vec3 blend = Pf * Pf * Pf * (Pf * (Pf * 6.0 - 15.0) + 10.0);\n    vec4 res0 = mix( hash_lowz, hash_highz, blend.z );\n    vec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n    return dot( res0, blend2.zxzx * blend2.wwyy );\n}\n\nvec3 tex(in vec3 p) {\n    float fac = 0.5*(hash(p)+hash(p*2.5));\n    float fac2 = smoothstep(0.45, 0.65, fac);\n    return mix(vec3(0.9, 0.8, 0.8), vec3(0.8, 0.7, 0.6), fac2);\n}\n\nvec3 ramp(in float t) {\n\treturn abs(fract(t + vec3(3,2,1)/3.)*6. - 3.) - 1.;\n}\n\nfloat buildings(in vec3 ro) {\n    return -ro.z/2. + 5.*sin(ro.x/2.) * sin(ro.y/2.);\n}\n\nfloat holes(in vec3 id) {\n    id = mod(id+5., 10.)-5.;\n    return step(10., dot(id, id));\n}\n\nfloat cylinders(in vec3 id) {\n    id.xy = mod(id.xy+22.5, 45.)-22.5;\n    float density = step(abs(length(id.xy)-5.), 1.);\n    density = min(density, step(4., length(id.xz-vec2(0., 2.))));\n\treturn density;\n}\n\nfloat voxMap(in vec3 id) {\n    float build1 = min(max(buildings(id), buildings(id*0.25)) + 2.*(hash(id)-0.5), holes(id));\n\tfloat build2 = cylinders(id);\n    return max(build1, build2);\n}\n\nfloat occupancy(in vec3 id) {\n    //return step(0.5, -step(length(id.xz - vec2(0., 4.)), 2.5) + voxMap(id/10.) + 0.25*(voxMap(id)-0.5));\n    return step(0.5, voxMap(id));\n}\n\n\nvec3 cellID(in vec3 ro) {\n    return floor(ro/(2.*CELL_SIZE) + 0.5);\n}\n\nvec3 cellMod(in vec3 ro) {\n    return mod(ro + CELL_SIZE, CELL_SIZE*2.) - CELL_SIZE;\n}\n\nfloat traceCell(in vec3 ro, in vec3 rd) {\n    vec3 dr = 1.0/rd;\n    vec3 n = ro * dr;\n    vec3 k = CELL_SIZE * abs(dr);\n    \n    vec3 pout =  k - n;\n    return min(pout.x, min(pout.y, pout.z));\n}\n\nfloat traceCell_normal(in vec3 ro, in vec3 rd, in vec3 r, out vec3 nn) {\n    vec3 dr = 1.0/rd;\n    vec3 n = ro * dr;\n    vec3 k = r * abs(dr);\n    \n    vec3 pout =  k - n;\n    nn = -sign(rd) * step(pout.xyz, pout.zxy) * step(pout.xyz, pout.yzx);\n    return min(pout.x, min(pout.y, pout.z));\n}\n\nfloat skinnyBox(in vec3 modpos, in vec3 rd, in vec3 id, out vec3 pnear, out vec3 pfar) {\n    vec2 offset = vec2(1., 0.);\n    vec3 occp = vec3(\n        occupancy(id + offset.xyy),\n    \toccupancy(id + offset.yxy),\n    \toccupancy(id + offset.yyx)\n    );\n    vec3 occm = vec3(\n        occupancy(id - offset.xyy),\n    \toccupancy(id - offset.yxy),\n    \toccupancy(id - offset.yyx)\n    );\n    vec3 sig = step(-0.5, sign(rd));\n    vec3 sizesp = mix(vec3(MINI_CELL_SIZE), vec3(CELL_SIZE), occp);\n    vec3 sizesm = -mix(vec3(MINI_CELL_SIZE), vec3(CELL_SIZE), occm);\n    pnear = (mix(sizesp, sizesm, sig) - modpos)/rd;\n    pfar = (mix(sizesm, sizesp, sig) - modpos)/rd;\n    /*vec3 ts[2];\n    ivec3 index = ivec3(step(-0.5, sig));\n    ts[index.x].x = (mix(MINI_CELL_SIZE, CELL_SIZE, occp.x) - modpos.x)/rd.x;\n    ts[index.y].y = (mix(MINI_CELL_SIZE, CELL_SIZE, occp.y) - modpos.y)/rd.y;\n    ts[index.z].z = (mix(MINI_CELL_SIZE, CELL_SIZE, occp.z) - modpos.z)/rd.z;\n    ts[1-index.x].x = (-mix(MINI_CELL_SIZE, CELL_SIZE, occm.x) - modpos.x)/rd.x;\n    ts[1-index.y].y = (-mix(MINI_CELL_SIZE, CELL_SIZE, occm.y) - modpos.y)/rd.y;\n    ts[1-index.z].z = (-mix(MINI_CELL_SIZE, CELL_SIZE, occm.z) - modpos.z)/rd.z;\n    pnear = ts[0];\n    pfar = ts[1];*/\n    return occp.x + occp.y + occp.z + occm.x + occm.y + occm.z;\n}\n\n\nHit voxtrace(in vec3 ro, in vec3 rd, int iters, bool stopWater) {\n    Hit h;\n    h.t = 0.;\n    // box marching\n    for (int i=0; i<iters; i++) {\n        vec3 pos = ro + rd*h.t;\n        h.id = cellID(pos);\n        if (stopWater && h.id.z < WATER_HEIGHT) {\n            h.mat = WATER_MAT;\n            return h;\n        } else if (h.id.z > MAX_HEIGHT) {\n            return h;\n        }\n        vec3 modpos = cellMod(pos);\n        float maxdist = traceCell(modpos, rd);\n        \n        \n        if (occupancy(h.id) > 0.5) {\n            vec3 pnear, pfar;\n            float neighbors = skinnyBox(modpos, rd, h.id, pnear, pfar);\n            float tnear = max(pnear.x, max(pnear.y, pnear.z));\n            float tfar = min(pfar.x, min(pfar.y, pfar.z));\n            if (neighbors > 0.5 && tfar > tnear && tnear > -2.*EPS) {\n                if (h.id.z >= WATER_HEIGHT) {\n                    if (neighbors < 2.5) {\n                        h.mat = 3;\n                    } else if (neighbors < 4.5) {\n                        h.mat = 1;\n                    } else {\n                        h.mat = 2;\n                    }\n                } else {\n                    h.mat = 5;\n                }\n                h.t += tnear;\n                h.n = -sign(rd) * step(pnear.zxy, pnear.xyz) * step(pnear.yzx, pnear.xyz);\n                return h;\n            }\n    \t}\n        \n        h.t += maxdist + EPS;\n        \n    }\n     \n    h.mat = 0;\n    return h;\n}\n\n/*float shadowtrace(in vec3 ro, in vec3 rd) {\n    float t = 0.;\n    for (int i=0; i<SHADOW_STEPS; i++) {\n        vec3 pos = ro + rd*t;\n        vec3 id = cellID(pos);\n        vec3 modpos = cellMod(pos);\n        float maxdist = traceCell(modpos, rd);\n        \n        if (occupancy(id) > 0.5) {\n            vec3 pnear, pfar;\n            skinnyBox(modpos, rd, id, pnear, pfar);\n            float tnear = max(pnear.x, max(pnear.y, pnear.z));\n            float tfar = min(pfar.x, min(pfar.y, pfar.z));\n            if (tfar > tnear && tnear > -SHADOW_EPS) {\n                return 0.;\n            }\n    \t}\n        t += maxdist + EPS;\n    }\n    return 1.;\n}*/\n\n\n\n// Schlick approximation for the Fresnel factor\nfloat schlick_fresnel(float R0, float cos_ang) {\n    return R0 + (1.-R0) * pow(1.-cos_ang, 5.);\n}\n\nvec3 shade(in vec3 eye, in vec3 rd, in Hit h, in vec3 sundir) {\n    vec3 ro = eye + h.t * rd;\n    if (h.mat == 0) {\n        // sky color\n        vec3 sky = mix(vec3(0.), vec3(0.1, 0.05, 0.0), 1.-pow(max(0., rd.z), .5));\n        float c = max(0., dot(rd, sundir));\n        float s = sqrt(1.-c*c);\n        vec2 n = normalize(vec2(s, sqrt(MOON_RADIUS*MOON_RADIUS-s*s)));\n        float fac = max(0.,1.-0.5*(1.-n.y));\n        sky = mix(fac * vec3(0.9, 0.95, 1.), sky, smoothstep(MOON_RADIUS-0.01, MOON_RADIUS, s));\n        return sky;\n    } else if (h.mat == 1 || h.mat == 3 || h.mat == 4 || h.mat == 5) {\n        // buildings\n        \n        float fac = max(0., dot(h.n, sundir));\n        //fac *= shadowtrace(ro + SHADOW_EPS*sundir, sundir);\n        float fac2 = abs(dot(h.n, -sundir));\n        vec3 albedo;\n        if (h.mat == 1) albedo = tex(ro);\n        else if (h.mat == 3) {\n            vec3 absmod = abs(cellMod(ro));\n            float coord = max(absmod.x, max(absmod.y, absmod.z))*1.253;\n            float stripe = smoothstep(0.45, 0.55, 2.*abs(fract(coord)-0.5) + 0.5*(hash(ro*2.)-0.5));\n            albedo = mix(1.-tex(ro), 0.5*tex(ro*2.), stripe);\n        }\n        else if (h.mat == 4) albedo = SILL_COLOR;\n        else if (h.mat == 5) albedo = vec3(1.); //underwater\n        return albedo * (MOON_COL * fac + AMBIENT_COL * fac2);\n    } else return vec3(1., 0., 1.);\n}\n\nvec3 winmod(in vec3 ro) {\n    return (fract(ro/(WINDOW_STRIDE*2.)+0.5)-0.5)*2.*WINDOW_STRIDE;\n}\n\nvec3 winID(in vec3 ro) {\n    return floor(ro/(WINDOW_STRIDE*2.)+0.5);\n}\n\nfloat win_mask(in vec3 ro, in vec3 n, float margin) {\n    vec3 win = step(1.-(WINDOW_SIZE + margin)/WINDOW_STRIDE, abs(fract(ro/(WINDOW_STRIDE*2.))-0.5)*2.);\n    return win.x * win.y * win.z * step(abs(n.z), 0.2) * step(WATER_HEIGHT * CELL_SIZE*2., ro.z);\n}\n\nvec3 shade_interior(in vec3 eye, in vec3 rd, in vec3 id, in vec3 sundir) {\n    vec3 n;\n    float t = traceCell_normal(eye, rd, vec3(WINDOW_THICKNESS,WINDOW_SIZE.y, WINDOW_SIZE.z), n);\n    vec3 albedo;\n    vec3 ro = eye + rd * t;\n    if (n.x > 0.5) {\n        t = traceCell_normal(eye, rd, vec3(ROOM_DEPTH, WINDOW_STRIDE, WINDOW_STRIDE), n);\n    \tro = eye + rd * t;\n        float hass = hash(id);\n        vec3 tilecolor = 0.8 + 0.2 * (ramp(hass)-0.5);\n        float ang = hass * PI * .5;\n        float sr = sin(ang);\n        float cr = cos(ang);\n        mat2 rot = mat2(cr, -sr, sr, cr);\n        vec2 tile = step(mod(rot*ro.xy, hass), vec2(0.5*(1.-hass)));\n        float tilefac = abs(tile.x-tile.y);\n        vec3 floorcol = mix(vec3(0.5+0.5*fract(hass*145.7)), tilecolor, tilefac);\n        vec3 wallcol = 0.95+0.05*(ramp(1.-hass)-0.5);\n        albedo = mix(wallcol, floorcol, step(0.1, n.z));\n    } else {\n        albedo = SILL_COLOR;\n    }\n    vec3 lightpos = vec3(-0.25*ROOM_DEPTH, 0., WINDOW_STRIDE*0.95);\n    vec3 l = lightpos - ro;\n    float ll = length(l);\n    float fac = max(0.25, dot(n, l)/(ll*ll));\n    \n    return albedo * fac * 3. * hash(id);\n}\n\nvec3 shade_fake(in vec3 eye, in vec3 rd, in Hit h, in vec3 sundir) {\n    vec3 ro = eye + rd * h.t;\n    if (h.mat == 2) {\n        // add in fake windows without reflections\n        if (win_mask(ro, h.n, 0.) > 0.5) {\n            vec3 id = winID(ro);\n            vec3 row = winmod(ro);\n            mat2 rot = mat2(h.n.x, -h.n.y, h.n.y, h.n.x);\n            vec3 ro2 = vec3(rot * row.xy, row.z);\n            vec3 rd2 = vec3(rot * rd.xy, rd.z);\n            sundir = vec3(rot * sundir.xy, sundir.z);\n            return shade_interior(ro2, rd2, id, sundir);\n        } else if (win_mask(ro, h.n, 0.2) > 0.5) {\n            h.mat = 4;\n\t\t\treturn shade(eye, rd, h, sundir);\n        } else {\n            h.mat = 1;\n            return shade(eye, rd, h, sundir);\n        }\n    } else if (h.mat == WATER_MAT) {\n        // water refractions\n        vec3 rdr = refract(rd, h.n, 1./1.33);\n        Hit h3 = voxtrace(ro, rdr, REFRACTION_VOXELS, false);\n        vec3 refrcol = shade(ro, rdr, h3, sundir);\n        refrcol *= pow(ABSORPTION_RATE, vec3(h3.t));\n        return refrcol;\n    } else {\n        return shade(eye, rd, h, sundir);\n    }\n}\n\n// shade materials which require reflections\nvec3 shade_refl(in vec3 eye, in vec3 rd, in Hit h, in vec3 sundir) {\n    vec3 ro = eye + h.t * rd;\n    if (h.mat == 2) {\n        // windows\n        vec3 basecolor = shade_fake(eye, rd, h, sundir);\n        if (win_mask(ro, h.n, 0.) > 0.5) {\n            vec3 rdr = reflect(rd, h.n);\n            Hit h2 = voxtrace(ro, rdr, REFLECTION_VOXELS, true);\n            vec3 reflcol = shade_fake(ro, rdr, h2, sundir);\n            float R0 = (GLASS_IOR-1.)/(GLASS_IOR+1.);\n            float fresnel = schlick_fresnel(R0, dot(h.n, rdr));\n            return mix(basecolor, reflcol, fresnel);\n        } else {\n            return basecolor;\n        }\n    } else if (h.mat == WATER_MAT) {\n        float R0 = (IOR-1.)/(IOR+1.);\n        R0*=R0;\n        float fresnel = schlick_fresnel(R0, -rd.z);\n        \n        vec2 disp = 0.01 * vec2(cos(ro.x*0.5 + 0.25*ro.y + 10.*iTime), sin(ro.x +2.*ro.y));\n        vec3 wn = normalize(vec3(disp, 1.));\n        h.n = wn;\n        vec3 refrcol = shade_fake(eye, rd, h, sundir);\n        \n     \t// water reflections\n         \n        vec3 rdr = reflect(rd, wn);\n        Hit h2 = voxtrace(ro, rdr, REFLECTION_VOXELS, false);\n        vec3 reflcol = shade_fake(ro, rdr, h2, sundir);\n        \n        return mix(refrcol, reflcol, fresnel);\n    } else {\n        return shade_fake(eye, rd, h, sundir);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float mouseY = iMouse.y < 1. ? 0. : (0.5-iMouse.y/iResolution.y) * PI;\n    float mouseX = iMouse.x < 1. ? iTime*0.25 : -(iMouse.x/iResolution.x) * 2. * PI;\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n\tvec3 eye = vec3(0., iTime * 30., 20.1);\n    vec3 w = vec3(cos(mouseX) * cos(mouseY), sin(mouseX) * cos(mouseY), -sin(mouseY));\n    vec3 u = normalize(cross(w, vec3(0., 0., 1.)));\n    vec3 v = cross(u, w);\n    vec3 rd = normalize(FDIST*w + uv.x*u + uv.y*v);\n    \n    Hit h = voxtrace(eye, rd, MAX_VOXELS, true);\n    vec3 ro = eye + h.t * rd;\n    vec3 sundir = normalize(vec3(1., -2., 1.2));\n\n    vec3 col = shade_refl(eye, rd, h, sundir);\n    fragColor = vec4(pow(col, vec3(0.75)),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}