{
    "Shader": {
        "info": {
            "date": "1712792122",
            "description": "Morphological antialiasing (MLAA) provided by AMD; ported to GLSL [ https://github.com/GPUOpen-LibrariesAndSDKs/MLAA11 ]\nuse Mouse to set border\nchange \"fInvEdgeDetectionTreshold\" in \"Common\" for the luminance difference when detecting edges",
            "flags": 32,
            "hasliked": 0,
            "id": "MfyGWW",
            "likes": 1,
            "name": "Fork MLAA (prov konero 092",
            "published": 3,
            "tags": [
                "antialiasing",
                "aa",
                "mlaa"
            ],
            "usePreview": 0,
            "username": "konero",
            "viewed": 166
        },
        "renderpass": [
            {
                "code": "// AMD Morphological Anti-Aliasing (MLAA) Sample\n//\n// https://github.com/GPUOpen-LibrariesAndSDKs/MLAA11\n//\n// Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved.\n//\n// SPDX-License-Identifier: MIT\n\n// MLAA (provided by AMD)\n// Copyright (c) 2023 by Denis Reischl\n//\n// SPDX-License-Identifier: MIT\n\n/*\n     [_] PASS I   : Render Scene with much artifacts, set\n                    Texel Luma to Alpha channel\n     ----------------------------------------------------------\n     \n     [_] PASS II  : Detect Edges and count their lengths\n     ----------------------------------------------------------\n     \n     [X] PASS III : Blend Colors (right), \n                    show edges (topleft), \n                    present\n     ----------------------------------------------------------\n     \n     Morphological antialiasing (MLAA) provided by AMD\n     [ https://github.com/GPUOpen-LibrariesAndSDKs/MLAA11 ]\n     [ /mlaa11/src/Shaders/MLAA11.hlsl ]\n     \n     ported to GLSL\n     \n     - left top : show edges in red\n     \n     - right : AA applied\n     \n     - left bottom : no AA applied\n    \n     - use Mouse to set border\n    \n     - change \"fInvEdgeDetectionTreshold\" in \"Common\" for the luminance \n       difference when detecting edges\n       \n     - luma is applied to alpha channel when rendering scene (Buffer A)\n     \n     - UINTs stored to FLOATs via helpers uvec4 <-> FLOAT4 ( B8G8R8A8_UNORM ) \n       UINT4_to_FLOAT4_D3DX_B8G8R8A8_UNORM (in Buffer B / mainImage)\n       D3DX_FLOAT4_to_UINT4_B8G8R8A8_UNORM (in Common / MLAA_BlendColor_PS)       \n*/\n\nvoid mainImage( out vec4 cOut, in vec2 vXY )\n{\n    // get mouse, uv\n    vec2 vM = (iMouse.z > .0f) ? abs(iMouse.xy / iResolution.xy) : vec2(.5f);\n    vec2 vUv = vXY.xy / iResolution.xy;\n    vec2 vBorder = vec2(4.f) / iResolution.xy;\n    \n    if (vUv.x > (vM.x + vBorder.x))\n        // apply MLAA\n        cOut = MLAA_BlendColor_PS(iChannel0, iChannel1, ivec2(vXY), ivec2(iResolution.xy) - 1, false);\n    else if (vUv.x > (vM.x - vBorder.x))\n        // border color\n        cOut = vec4(1.f, 1.f, .8f, 1.f);\n    else if (vUv.y < (vM.y - vBorder.y))\n        // no AA applied\n        cOut = vec4(textureLod(iChannel0,vUv,0.).xyz, 1.);\n    else if (vUv.y > (vM.y + vBorder.y))\n        // show edges (red)\n        cOut = MLAA_BlendColor_PS(iChannel0, iChannel1, ivec2(vXY), ivec2(iResolution.xy) - 1, true);\n    else\n        // border color\n        cOut = vec4(1.f, 1.f, .8f, 1.f);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// AMD Morphological Anti-Aliasing (MLAA) Sample\n//\n// https://github.com/GPUOpen-LibrariesAndSDKs/MLAA11\n//\n// Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n//\n\n//-----------------------------------------------------------------------------------------\n// File: MLAA11.hlsl\n//\n// Set of shaders used to apply Morphological Anti-Aliasing (MLAA) to a scene\n// as a post-process operation.\n//\n// GLSL-Port 2023 by Denis Reischl\n//-----------------------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------------------\n// Defines\n//-----------------------------------------------------------------------------------------\n#ifndef MAX_EDGE_COUNT_BITS\n#define MAX_EDGE_COUNT_BITS\t\t\t4\t\t\t// Default edge count bits is 4\n#endif\n\n#ifndef SHOW_EDGES\n#define SHOW_EDGES\t\t\t\t\t0\t\t\t// Disabled by default      \n#endif\n\n#ifndef USE_STENCIL\n#define USE_STENCIL\t\t\t\t\t0\t\t\t// Disabled by default      \n#endif\n\n//#define USE_GATHER                            // Disabled by default\n\n//-----------------------------------------------------------------------------------------\n// Static Constants\n//-----------------------------------------------------------------------------------------\n// Set the number of bits to use when storing the horizontal and vertical counts\n// This number should be half the number of bits in the color channels used\n// E.g. with a RT format of DXGI_R8G8_int this number should be 8/2 = 4\n// Longer edges can be detected by increasing this number; however this requires a \n// larger bit depth format, and also makes the edge length detection function slower\nconst uint kNumCountBits = uint(MAX_EDGE_COUNT_BITS);\n\n// The maximum edge length that can be detected\nconst uint kMaxEdgeLength = ((1u << (kNumCountBits - 1u)) - 1u);\n\n// Various constants used by the shaders below\nconst uint kUpperMask = (1u << 0u);\nconst uint kUpperMask_BitPosition = 0u;\nconst uint kRightMask = (1u << 1u);\nconst uint kRightMask_BitPosition = 1u;\nconst uint kStopBit = (1u << (kNumCountBits - 1u));\nconst uint kStopBit_BitPosition = (kNumCountBits - 1u);\nconst uint kNegCountShift = (kNumCountBits);\nconst uint kPosCountShift = (00u);\nconst uint kCountShiftMask = ((1u << kNumCountBits) - 1u);\n\nconst ivec3 kZero = ivec3(0, 0, 0);\nconst ivec3 kUp = ivec3(0, -1, 0);\nconst ivec3 kDown = ivec3(0, 1, 0);\nconst ivec3 kRight = ivec3(1, 0, 0);\nconst ivec3 kLeft = ivec3(-1, 0, 0);\n\n// This constant defines the luminance intensity difference to check for when testing any \n// two pixels for an edge.\nconst float fInvEdgeDetectionTreshold = 1.f / 32.f;\n\n//-----------------------------------------------------------------------------------------\n// Utility functions\n//-----------------------------------------------------------------------------------------\n//--------------------------------------------------------------------------------------\n// Returns true if the colors are different\n//--------------------------------------------------------------------------------------\nbool CompareColors(float a, float b)\n{\n\treturn (abs(a - b) > fInvEdgeDetectionTreshold);\n}\nbvec2 CompareColors2(vec2 a, vec2 b)\n{\n    return bvec2(abs(a.x - b.x) > fInvEdgeDetectionTreshold, abs(a.y - b.y) > fInvEdgeDetectionTreshold);\n}\n//--------------------------------------------------------------------------------------\n// Check if the specified bit is set\n//--------------------------------------------------------------------------------------\nbool IsBitSet(uint Value, const uint uBitPosition)\n{\n\treturn (((Value & (1u << uBitPosition)) > 0u) ? true : false);\n}\n//--------------------------------------------------------------------------------------\n//--------------------------------------------------------------------------------------\nuint RemoveStopBit(uint a)\n{\n\treturn a & (kStopBit - 1u);\n}\n//--------------------------------------------------------------------------------------\n//--------------------------------------------------------------------------------------\nuint DecodeCountNoStopBit(uint count, uint shift)\n{\n\treturn RemoveStopBit((count >> shift) & kCountShiftMask);\n}\n//--------------------------------------------------------------------------------------\n//--------------------------------------------------------------------------------------\nuint DecodeCount(uint count, uint shift)\n{\n\treturn (count >> shift) & kCountShiftMask;\n}\n//--------------------------------------------------------------------------------------\n//--------------------------------------------------------------------------------------\nuint EncodeCount(uint negCount, uint posCount)\n{\n\treturn ((negCount & kCountShiftMask) << kNegCountShift) | (posCount & kCountShiftMask);\n}\n\n//-----------------------------------------------------------------------------\n// uvec4 <-> FLOAT4 ( B8G8R8A8_UNORM )\n// modified code from \"d3dx_dxgiformatconvert.inl\"\n//-----------------------------------------------------------------------------\nuint D3DX_FLOAT_to_UINT(float _V, float _Scale) { return uint(floor(_V * _Scale + 0.5f)); }\n\nvec4 UINT4_to_FLOAT4_D3DX_B8G8R8A8_UNORM(uvec4 Input)\n{\n\tvec4 Output;\n\tOutput.z = float(Input.x & 0x000000ffu) / 255.f;\n\tOutput.y = float(Input.y & 0x000000ffu) / 255.f;\n\tOutput.x = float(Input.z & 0x000000ffu) / 255.f;\n\tOutput.w = float(Input.w & 0x000000ffu) / 255.f;\n\treturn Output;\n}\n\nuvec4 D3DX_FLOAT4_to_UINT4_B8G8R8A8_UNORM(vec4 Input)\n{\n\tuvec4 Output;\n\tOutput = uvec4(D3DX_FLOAT_to_UINT(clamp(Input.z, 0.f, 1.f), 255.f),\n\t\tD3DX_FLOAT_to_UINT(clamp(Input.y, 0.f, 1.f), 255.f),\n\t\tD3DX_FLOAT_to_UINT(clamp(Input.x, 0.f, 1.f), 255.f),\n\t\tD3DX_FLOAT_to_UINT(clamp(Input.w, 0.f, 1.f), 255.f));\n\treturn Output;\n}\n\n//----------------------------------------------------------------------------\n//\tMLAA pixel shader for edge detection.\n//\tPixel shader used in the first phase of MLAA.\n//\tThis pixel shader is used to detect vertical and horizontal edges.\n//-----------------------------------------------------------------------------\nuint MLAA_SeperatingLines(sampler2D Sampler, ivec2 Offset, ivec2 TextureSize)\n{\n\tvec2 center;\n\tvec2 upright;\n\n\tcenter.xy = texelFetch(Sampler, clamp(Offset, ivec2(0, 0), TextureSize), 0).aa;\n\tupright.y = texelFetch(Sampler, clamp(Offset + kUp.xy, ivec2(0, 0), TextureSize), 0).a;\n\tupright.x = texelFetch(Sampler, clamp(Offset + kRight.xy, ivec2(0, 0), TextureSize), 0).a;\n\n\tuint rVal = 0u;\n\n\tbvec2 result = CompareColors2(center, upright);\n\n\t// Check for seperating lines\n\tif (result.y)\n\t\trVal |= kUpperMask;\n\tif (result.x)\n\t\trVal |= kRightMask;\n\n\treturn rVal;\n}\n\n//-----------------------------------------------------------------------------\n//\tPixel shader for the second phase of the algorithm.\n//\tThis pixel shader calculates the length of edges.\n//-----------------------------------------------------------------------------\nuvec2 MLAA_ComputeLineLength(sampler2D Sampler, ivec2 Offset, ivec2 TextureSize)\n{\n\t// Retrieve edge mask for current pixel\t\n\tuint pixel = MLAA_SeperatingLines(Sampler, Offset, TextureSize);\n\tuvec4 EdgeCount = uvec4(0, 0, 0, 0); // x = Horizontal Count Negative, y = Horizontal Count Positive, z = Vertical Count Negative, w = Vertical Count Positive\t\t\t\t    \n\n\t// We use a single branch for vertical and horizontal edge testing\n\t// Doing this is faster than two different branches (one for vertical, one for horizontal)\n\t// In most case both V and H edges are spatially coherent (apart from purely horizontal or \n\t// vertical edges but those don't happen often compared to other cases).\t\t\t\t\n\t\n    if ((pixel & (kUpperMask | kRightMask)) != 0u)\n    {\n        uvec4 EdgeDirMask = uvec4(kUpperMask, kUpperMask, kRightMask, kRightMask);\n        uvec4 EdgeFound;\n        EdgeFound.x = (pixel & EdgeDirMask.x) != 0u ? 0xFFFFFFFFu : 0u;\n        EdgeFound.y = (pixel & EdgeDirMask.y) != 0u ? 0xFFFFFFFFu : 0u;\n        EdgeFound.z = (pixel & EdgeDirMask.z) != 0u ? 0xFFFFFFFFu : 0u;\n        EdgeFound.w = (pixel & EdgeDirMask.w) != 0u ? 0xFFFFFFFFu : 0u;\n        \n        // Nullify the stopbit if we're not supposed to look at this edge\n        uvec4 StopBit;\n        StopBit.x = (EdgeFound.x != 0u) ? kStopBit : 0u;\n        StopBit.y = (EdgeFound.y != 0u) ? kStopBit : 0u;\n        StopBit.z = (EdgeFound.z != 0u) ? kStopBit : 0u;\n        StopBit.w = (EdgeFound.w != 0u) ? kStopBit : 0u;\n\n        for (int i = 1; i <= int(kMaxEdgeLength); i++)\n        {\n            uvec4 uEdgeMask;\n\n            uEdgeMask.x = MLAA_SeperatingLines(Sampler, clamp(Offset + ivec2(-i, 0), ivec2(0, 0), TextureSize), TextureSize);\n            uEdgeMask.y = MLAA_SeperatingLines(Sampler, clamp(Offset + ivec2(i, 0), ivec2(0, 0), TextureSize), TextureSize);\n            uEdgeMask.z = MLAA_SeperatingLines(Sampler, clamp(Offset + ivec2(0, i), ivec2(0, 0), TextureSize), TextureSize);\n            uEdgeMask.w = MLAA_SeperatingLines(Sampler, clamp(Offset + ivec2(0, -i), ivec2(0, 0), TextureSize), TextureSize);\n\n            EdgeFound = EdgeFound & (uEdgeMask & EdgeDirMask);\n            EdgeCount.x = EdgeFound.x != 0u ? EdgeCount.x + 1u : EdgeCount.x | StopBit.x;\n            EdgeCount.y = EdgeFound.y != 0u ? EdgeCount.y + 1u : EdgeCount.y | StopBit.y;\n            EdgeCount.z = EdgeFound.z != 0u ? EdgeCount.z + 1u : EdgeCount.z | StopBit.z;\n            EdgeCount.w = EdgeFound.w != 0u ? EdgeCount.w + 1u : EdgeCount.w | StopBit.w;\n        }\n    }\n\treturn uvec2(EncodeCount(EdgeCount.x, EdgeCount.y), EncodeCount(EdgeCount.z, EdgeCount.w));\n}\n\n//-----------------------------------------------------------------------------\t\n//\tMain function used in third and final phase of the algorithm\n//\tThis code reads previous inputs and perform anti-aliasing of edges by \n//  blending colors as required.\n//-----------------------------------------------------------------------------\nvoid BlendColor(sampler2D Sampler,\n\tuint count,\n\tivec2 pos,\n\tivec2 dir,\n\tivec2 ortho,\n\tbool _inverse,\n\tinout vec4 color)\n{\n\t// Only process pixel edge if it contains a stop bit\n\tif (IsBitSet(count, kStopBit_BitPosition + kPosCountShift) || IsBitSet(count, kStopBit_BitPosition + kNegCountShift))\n    {\n        // Retrieve edge length\n        uint negCount = DecodeCountNoStopBit(count, kNegCountShift);\n        uint posCount = DecodeCountNoStopBit(count, kPosCountShift);\n\n        // Fetch color adjacent to the edge\n        vec4 adjacentcolor = texelFetch(Sampler, pos + dir, 0);\n\n        if ((negCount + posCount) == 0u)\n        {\n            float weight = 1.0 / 8.0; // Arbitrary\t\t\t\n            // Cheap approximation of gamma to linear and then back again\n            color.xyz = sqrt(mix(color.xyz * color.xyz, adjacentcolor.xyz * adjacentcolor.xyz, weight));\n            return;\n        }\n        else\n        {\n            // If no sign bit is found on either edge then artificially increase the edge length so that\n            // we don't start anti-aliasing pixels for which we don't have valid data.\n            if (!(IsBitSet(count, (kStopBit_BitPosition + kPosCountShift)))) posCount = kMaxEdgeLength + 1u;\n            if (!(IsBitSet(count, (kStopBit_BitPosition + kNegCountShift)))) negCount = kMaxEdgeLength + 1u;\n\n            // Calculate some variables\n            float _length = float(negCount + posCount) + 1.f;\n            float midPoint = _length / 2.f;\n            float _distance = float(negCount);\n\n            const uint upperU = 0x00u;\n            const uint risingZ = 0x01u;\n            const uint fallingZ = 0x02u;\n            const uint lowerU = 0x03u;\n\n            ///////////////////////////////////////////////////////////////////////////////////////\n            // Determining what pixels to blend\n            // 4 possible values for shape - x indicates a blended pixel:\n            //\n            // 0: |xxxxxx| -> (h0 > 0) && (h1 > 0) : upperU     - blend along the entire inverse edge\n            //     ------\n            //\n            //\n            // 1:     xxx| -> (h0 < 0) && (h1 > 0) : risingZ    - blend first half on inverse, \n            //     ------                                         blend second half on non-inverse\n            //    |xxx                                            \n            //\n            // 2: |xxx     -> (h0 > 0) && (h1 < 0) : fallingZ   - blend first half on non-inverse, \n            //     ------                                         blend second half on inverse\n            //        xxx|                                        \n            //\n            // 3:          -> (h0 < 0) && (h1 < 0) : lowerU     - blend along the entire non-inverse edge\n            //     ------\n            //    |xxxxxx|\n            ///////////////////////////////////////////////////////////////////////////////////////\n\n            uint shape = 0x00u;\n            if (CompareColors((texelFetch(Sampler, pos - (ortho * ivec2(int(negCount))), 0).a), \n                              (texelFetch(Sampler, pos - (ortho * (ivec2(int(negCount) + 1))), 0).a)))\n            {\n                shape |= risingZ;\n            }\n\n            if (CompareColors((texelFetch(Sampler, pos + (ortho * ivec2(int(posCount))), 0).a), \n                              (texelFetch(Sampler, pos + (ortho * (ivec2(int(posCount) + 1))), 0).a)))\n            {\n                shape |= fallingZ;\n            }\n\n            // Parameter \"_inverse\" is hard-coded on call so will not generate a dynamic branch condition\n            if ((_inverse && (((shape == fallingZ) && (float(negCount) <= midPoint)) ||\n                ((shape == risingZ) && (float(negCount) >= midPoint)) ||\n                ((shape == upperU))))\n                || (!_inverse && (((shape == fallingZ) && (float(negCount) >= midPoint)) ||\n                    ((shape == risingZ) && (float(negCount) <= midPoint)) ||\n                    ((shape == lowerU)))))\n            {\n                float h0 = abs((1.0 / _length) * (_length - _distance) - 0.5);\n                float h1 = abs((1.0 / _length) * (_length - _distance - 1.0) - 0.5);\n                float area = 0.5f * (h0 + h1);                \n                // Cheap approximation of gamma to linear and then back again\n                color.xyz = sqrt(mix(color.xyz * color.xyz, adjacentcolor.xyz * adjacentcolor.xyz, area));\n            }\n        }\n    }\n}\n\n//-----------------------------------------------------------------------------\n//\tMLAA pixel shader for color blending.\n//\tPixel shader used in third and final phase of the algorithm\n//-----------------------------------------------------------------------------\nvec4 MLAA_BlendColor_PS(sampler2D Sampler, sampler2D SamplerEdges, ivec2 Offset, ivec2 TextureSize, bool bShowEdgesOnly)\n{\n    if (bShowEdgesOnly)\n    {\n        vec4 rVal = texelFetch(Sampler, Offset, 0);\n\n        uint hcount, vcount;\n        uvec2 _count = D3DX_FLOAT4_to_UINT4_B8G8R8A8_UNORM(texelFetch(SamplerEdges, Offset, 0)).xy;\n        hcount = _count.x; vcount = _count.y;\n\n        if ((hcount != 0u) || (vcount != 0u))\n        {\n            if ((IsBitSet(hcount, kStopBit_BitPosition + kPosCountShift) || IsBitSet(hcount, kStopBit_BitPosition + kNegCountShift)) ||\n                (IsBitSet(vcount, kStopBit_BitPosition + kPosCountShift) || IsBitSet(vcount, kStopBit_BitPosition + kNegCountShift)))\n            {\n                uint Count = 0u;\n                Count += DecodeCountNoStopBit(hcount, kNegCountShift);\n                Count += DecodeCountNoStopBit(hcount, kPosCountShift);\n                Count += DecodeCountNoStopBit(vcount, kNegCountShift);\n                Count += DecodeCountNoStopBit(vcount, kPosCountShift);\n                if (Count != 0u)\n                    rVal = vec4(1, 0, 0, 1);\n            }\n        }\n        return rVal;\n    }\n    else\n    {\n        uint hcount, vcount;\n        uint hcountup, vcountright;\n\n        uvec2 _count = D3DX_FLOAT4_to_UINT4_B8G8R8A8_UNORM(texelFetch(SamplerEdges, Offset, 0)).xy;\n        hcount = _count.x; vcount = _count.y;\n        hcountup = D3DX_FLOAT4_to_UINT4_B8G8R8A8_UNORM(texelFetch(SamplerEdges, Offset - kUp.xy, 0)).x;\n        vcountright = D3DX_FLOAT4_to_UINT4_B8G8R8A8_UNORM(texelFetch(SamplerEdges, Offset - kRight.xy, 0)).y;\n\n        // Retrieve pixel from original image\n        vec4 rVal = texelFetch(Sampler, Offset, 0);\n        // Blend pixel colors as required for anti-aliasing edges\n        if (hcount != 0u)\t\tBlendColor(Sampler, hcount, Offset, kUp.xy, kRight.xy, false, rVal);   // H down-up\n        if (hcountup != 0u)\t    BlendColor(Sampler, hcountup, Offset - kUp.xy, -kUp.xy, kRight.xy, true, rVal);   // H up-down    \t\t\t\t    \n        if (vcount != 0u)\t\tBlendColor(Sampler, vcount, Offset, kRight.xy, kUp.xy, false, rVal);   // V left-right\t\t\t\t\n        if (vcountright != 0u)\tBlendColor(Sampler, vcountright, Offset - kRight.xy, -kRight.xy, kUp.xy, true, rVal);   // V right-left    \t\t\t\n        \n        return rVal;\n    }\n}\n\n//-----------------------------------------------------------------------------\n// EOF\n//-----------------------------------------------------------------------------",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// AMD Morphological Anti-Aliasing (MLAA) Sample\n//\n// https://github.com/GPUOpen-LibrariesAndSDKs/MLAA11\n//\n// Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved.\n//\n// SPDX-License-Identifier: MIT\n\n// MLAA (provided by AMD)\n// Copyright (c) 2023 by Denis Reischl\n//\n// SPDX-License-Identifier: MIT\n\n/*\n     [X] PASS I   : Render Scene with much artifacts, set\n                    Texel Luma to Alpha channel\n     ----------------------------------------------------------\n     \n     [_] PASS II  : Detect Edges and count their lengths\n     ----------------------------------------------------------\n     \n     [_] PASS III : Blend Colors (right), \n                    show edges (topleft), \n                    present\n     ----------------------------------------------------------\n     \n     Morphological antialiasing (MLAA) provided by AMD\n     [ https://github.com/GPUOpen-LibrariesAndSDKs/MLAA11 ]\n     [ /mlaa11/src/Shaders/MLAA11.hlsl ]\n     \n     ported to GLSL\n     \n     - left top : show edges in red\n     \n     - right : AA applied\n     \n     - left bottom : no AA applied\n    \n     - use Mouse to set border\n    \n     - change \"fInvEdgeDetectionTreshold\" in \"Common\" for the luminance \n       difference when detecting edges\n       \n     - luma is applied to alpha channel when rendering scene (Buffer A)\n     \n     - UINTs stored to FLOATs via helpers uvec4 <-> FLOAT4 ( B8G8R8A8_UNORM ) \n       UINT4_to_FLOAT4_D3DX_B8G8R8A8_UNORM (in Buffer B / mainImage)\n       D3DX_FLOAT4_to_UINT4_B8G8R8A8_UNORM (in Common / MLAA_BlendColor_PS)       \n*/\n\n\n#define PI 3.141592654f\n\n// box intersection by Inigo Quilez : https://www.shadertoy.com/view/ld23DV\n// https://iquilezles.org/articles/boxfunctions\nvec4 iBox( in vec3 ro, in vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad ) \n{\n    // convert from ray to box space\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x,t1.y),t1.z);\n    float tF = min(min(t2.x,t2.y),t2.z);\n    \n    // no intersection\n\tif( tN>tF || tF<0.0 ) return vec4(-1.0);\n\n    // this works as long as the ray origin is not inside the box\n    vec4 res = vec4(tN, step(tN,t1) );\n    \n    // add sign to normal and convert to ray space\n\tres.yzw = (txi * vec4(-sign(rdd)*res.yzw,0.0)).xyz;\n\n\treturn res;\n}\n\n// bottom plane intersection\nvec4 iPlane(in vec3 vOri, in vec3 vDir)\n{\n    // ortho project up-origin/up-dir\n    float fT = -vOri.y/vDir.y;\n    return vec4(fT, vec3(0.f, 1.f, 0.f));\n}\n\n// lookat matrix.. from https://www.shadertoy.com/view/Xtl3W2\nmat3 LookAt(in vec3 vOri, in vec3 vTar, in float fRoll )\n{\n    vec3 vW = normalize( vTar - vOri );\n    vec3 vU = normalize( cross(vW, vec3(sin(fRoll),cos(fRoll),0.0) ) );\n    vec3 vV = normalize( cross(vU,vW));\n    return mat3( vU, vV, vW );\n}\n\n// y rotation matrix\nmat4 Rotate4X(float fAng) \n{\n  float fS = sin(fAng);\n  float fC = cos(fAng);\n\n  return mat4(1.f, 0.f, 0.f, 0.f, 0.f, fC, fS, 0.f, 0.f, -fS, fC, 0.f, 0.f, 0.f, 0.f, 1.f);\n}\n\n// by Inigo Quilez : https://iquilezles.org/articles/palettes\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) { return a + b*cos( 6.28318*(c*t+d) ); }\n\n// simple checkers\nfloat checkers(vec2 vUv, float fDist)\n{\n    return mix(.3f, 1.f, (1. - step(0.995 - fDist * 0.01, max(fract(vUv.x), fract(vUv.y))))) * clamp(max(0.f, 5.f - fDist * .25f), 0.f, 1.f);\n}\n\nvoid mainImage( out vec4 cOut, in vec2 vUv )\n{\n    float fTime = iTime * .05f;\n    \n\t// create view ray\n    vec2 vP = (-iResolution.xy + 2.0 * vUv.xy) / iResolution.y;\n    vec2 vM = vec2(fTime, 2.4f);\n    vec3 vOri = vec3(sin(vM.x) * vM.y, 1.3f, cos(vM.x) * vM.y);\n\tvec3 vDir = normalize(LookAt(vOri, vec3(0.f, 1.f, 0.f), 0.f) * vec3(vP.xy, 2.f) );\n    \n    // box transform\n    mat4 txi = mat4(1.f, vec4(0.f), 1.f, vec4(0.f), 1.f, 0.f, 0.f, 1.f, 0.f, 1.f) * Rotate4X(fTime);\n    mat4 txx = inverse( txi );\n    \n    // trace box or bottom plane\n    vec3 vPos, vNor, vOpos, sBox = vec3(.4f, .6f, .8f) ;\n\tvec4 vInt = iBox(vOri, vDir, txx, txi, sBox);\n    float fTHit = vInt.x;\n    if ((fTHit <= 0.f) && (vDir.y < 0.f)) { vInt = iPlane(vOri, vDir); fTHit = vInt.x; }\n    \n    if (fTHit > 0.f)\n    {\n        // normal, position\n        vNor = vInt.yzw;\n        vPos = vOri + vDir * fTHit;\n        \n        // box or plane ?\n        if (vPos.y > 0.01f)\n        {\n            // colorize for MLAA\n            vec3 vOpos = (txx*vec4(vPos,1.f)).xyz;\n            cOut = vec4(vec3(max(vec2(.3f, .3f), step(.5f, fract(vOpos.xz))), 0.f), 1.f);\n            cOut.r = cOut.g = cOut.b = mix(cOut.r, cOut.g, .5f);\n            cOut.rgb *= pal( floor(sin(max(abs(fract(vOpos.x) - .5f), abs(fract(vOpos.z) - .5f)) * PI) * 20.f) * .25f,\n                    vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n        }\n        else\n        {\n            // colorize for MLAA\n            vec2 vC = vec2(floor(vPos.xz) * vec2(.33f, .22f));\n            cOut.rgb = mix( vec3(.3f, 1.f, 1.f),\n                pal(sin(vC.x + vC.y), vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) ), \n                checkers(vPos.xz, fTHit));\n            cOut.rgb -= - fTHit * .01f;\n        }\n\n        // simple diffuse\n        cOut.xyz *= max(dot(normalize(vec3(-3.f, 5.f, -6.f)), vNor), 0.3f);\n    }\n    else\n        cOut = vec4(pal(floor(fract(abs(vDir.y * 10.f)) * 10.f) * .1f, \n            vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.3,0.20,0.20) ) , 1.f);\n            \n    // compute luma and set as alpha\n\tcOut.a = sqrt(dot(cOut.rgb, vec3(.299f, .587f, .114f)));\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// AMD Morphological Anti-Aliasing (MLAA) Sample\n//\n// https://github.com/GPUOpen-LibrariesAndSDKs/MLAA11\n//\n// Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved.\n//\n// SPDX-License-Identifier: MIT\n\n// MLAA (provided by AMD)\n// Copyright (c) 2023 by Denis Reischl\n//\n// SPDX-License-Identifier: MIT\n\n/*\n     [_] PASS I   : Render Scene with much artifacts, set\n                    Texel Luma to Alpha channel\n     ----------------------------------------------------------\n     \n     [X] PASS II  : Detect Edges and count their lengths\n     ----------------------------------------------------------\n     \n     [_] PASS III : Blend Colors (right), \n                    show edges (topleft), \n                    present\n     ----------------------------------------------------------\n     \n     Morphological antialiasing (MLAA) provided by AMD\n     [ https://github.com/GPUOpen-LibrariesAndSDKs/MLAA11 ]\n     [ /mlaa11/src/Shaders/MLAA11.hlsl ]\n     \n     ported to GLSL\n     \n     - left top : show edges in red\n     \n     - right : AA applied\n     \n     - left bottom : no AA applied\n    \n     - use Mouse to set border\n    \n     - change \"fInvEdgeDetectionTreshold\" in \"Common\" for the luminance \n       difference when detecting edges\n       \n     - luma is applied to alpha channel when rendering scene (Buffer A)\n     \n     - UINTs stored to FLOATs via helpers uvec4 <-> FLOAT4 ( B8G8R8A8_UNORM ) \n       UINT4_to_FLOAT4_D3DX_B8G8R8A8_UNORM (in Buffer B / mainImage)\n       D3DX_FLOAT4_to_UINT4_B8G8R8A8_UNORM (in Common / MLAA_BlendColor_PS)       \n*/\n\nvoid mainImage( out vec4 cOut, in vec2 vXY )\n{\n    // detect edges and compute their lengths, convert from UINT4 to FLOAT4\n\tuvec2 auLineL = MLAA_ComputeLineLength(iChannel0, ivec2(vXY), ivec2(iResolution.xy) - 1);\n\tcOut = UINT4_to_FLOAT4_D3DX_B8G8R8A8_UNORM(uvec4(auLineL, 0, 0));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}