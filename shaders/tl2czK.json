{
    "Shader": {
        "info": {
            "date": "1594872789",
            "description": "Using ray marching to render multiple reflective balls on a reflective catwalk.",
            "flags": 0,
            "hasliked": 0,
            "id": "tl2czK",
            "likes": 1,
            "name": "Reflective Balls",
            "published": 3,
            "tags": [
                "raymarching",
                "reflection",
                "animated"
            ],
            "usePreview": 0,
            "username": "vipiao",
            "viewed": 360
        },
        "renderpass": [
            {
                "code": "\n// Inspird by \"[TUT] RayMarching for Dummies!\".\n\n#define PI 3.1415926538\n\n#define MAX_STEPS 300\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nfloat GetDist(vec3 p) {\n\tvec4 s = vec4(2.5, 1, 2.5, 1);\n    \n    vec3 p2 = p;\n    p2.y = mod(p.y+1., 5.)-1.;\n    float sphereDist =  length(p2-s.xyz)-s.w;\n    float planeDist = p.y;\n    \n    float d = min(sphereDist, planeDist);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    vec3 pos = ro;\n    vec3 posMod;\n    bool isRelective = true;\n    int numR = 0;\n    int occlusion = 0;\n    float curveFactor = -0.0005;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        // Reflection.\n        /*vec3 reflectionPoint = vec3(1.+iTime*5.,0,0);\n        vec3 reflectionNormal = normalize(vec3(-1,-0.5,0));\n        vec3 relPos = pos-reflectionPoint;\n        float proj = dot(relPos, reflectionNormal);\n        if(proj < 0.){\n        \tpos -= 2.*reflectionNormal * proj;\n            rd = reflect(rd, reflectionNormal);\n        }*/\n        \n        //\n        posMod.x = mod(pos.x, 5.);\n        posMod.y = pos.y;\n        posMod.z = mod(pos.z, 5.);\n        float dS = GetDist(posMod);\n        pos += rd*dS;\n        \n        // Curve.\n        vec3 sideways = normalize(vec3(-rd.z, rd.y, rd.x));\n        rd = normalize(rd + vec3(0,curveFactor*dS,0) + sideways*dS*0.002);\n        \n        dO += dS;\n        //if(dO>MAX_DIST || dS<SURF_DIST) break;\n        if(dS<SURF_DIST) {\n            if (pos.z >= 5. || pos.z <= 0. || pos.y > 5.) isRelective = false;\n            break;\n        }\n        occlusion ++;\n        if (i == MAX_STEPS-1){\n        \treturn dO/(pow(float(occlusion), 0.5)*0.1+1.);\n        }\n    }\n    // Reflect.\n    for(int j=0; j</*int(mod(iTime,5.))*/10 && isRelective; j++) {\n        numR++;\n        dO *= 1.;\n        vec3 normal;\n        if (pos.y < SURF_DIST) {\n            normal = vec3(0,1,0);\n        } else {\n            normal = normalize(posMod-vec3(2.5, 1, 2.5));\n        }\n        if (dot(rd,normal) < 0.) {\n        \trd = reflect(rd, normal);\n            numR++;\n        }\n        pos += rd*SURF_DIST*2.;\n\n        for(int i=0; i<MAX_STEPS; i++) {\n            // Reflection.\n            /*vec3 reflectionPoint = vec3(1.+iTime*5.,0,0);\n            vec3 reflectionNormal = normalize(vec3(-1,-0.5,0));\n            vec3 relPos = pos-reflectionPoint;\n            float proj = dot(relPos, reflectionNormal);\n            if(proj < 0.){\n                pos -= 2.*reflectionNormal * proj;\n                rd = reflect(rd, reflectionNormal);\n            }*/\n            \n            //\n            posMod.x = mod(pos.x, 5.);\n            posMod.y = pos.y;\n            posMod.z = mod(pos.z, 5.);\n            float dS = GetDist(posMod);\n            pos += rd*dS;\n        \n            // Curve.\n            vec3 sideways = normalize(vec3(-rd.z, rd.y, rd.x));\n        \trd = normalize(rd + vec3(0,curveFactor*dS,0) + sideways*dS*0.002);\n            \n            dO += dS;\n            //if(dO>MAX_DIST || dS<SURF_DIST) break;\n            if(dS<SURF_DIST) {\n            \tif (pos.z >= 5. || pos.z <= 0. || pos.y > 5.) isRelective = false;\n                break;\n            }\n            occlusion ++;\n            if (i == MAX_STEPS-1){\n                return dO/(pow(float(occlusion), 0.5)*0.1+1.);\n            }\n        }\n    }\n    /*for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }*/\n    return dO/(pow(float(occlusion), 0.5)*0.1+1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0.+iTime*1.*5., 1.+0.15+cos(iTime*PI*.2)*1., cos(iTime*PI*.2*0.5+PI*0.5)*3.5*0.+4.);\n    //vec3 ro = vec3(0.+iTime*1.*5., 6.+cos(iTime)*3.5, 2.5+cos(iTime+PI*0.5)*3.5);\n    float angle = sin(iTime*0.2)*PI*0.5+PI;\n    //vec3 ro = vec3(0., 1., 0.);\n    \n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n    float x = -rd.z*sin(angle + PI*0.) + rd.x*cos(angle + PI*0.);\n    float z = rd.x*sin(angle + PI*0.) + rd.z*cos(angle + PI*0.);\n    rd.x = x;\n    rd.z = z;\n    \n    float d = RayMarch(ro, rd);\n    col = vec3(d/150.);\n    \n    fragColor = vec4(col, 1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}