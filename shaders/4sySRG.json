{
    "Shader": {
        "info": {
            "date": "1465146676",
            "description": "Just learning, understanding and training with Voronoi distance and celular map creation. It's just a draft. Experimenting\n\nReferences: Iquilez https://iquilezles.org/articles/voronoilines/voronoilines.htm\n",
            "flags": 0,
            "hasliked": 0,
            "id": "4sySRG",
            "likes": 5,
            "name": "Worley-Voronoi-Whatever... :D",
            "published": 3,
            "tags": [
                "pgatrcelularworleyvoronoi"
            ],
            "usePreview": 0,
            "username": "jviedma",
            "viewed": 808
        },
        "renderpass": [
            {
                "code": "//References: Iquilez https://iquilezles.org/articles/voronoilines\n//https://www.shadertoy.com/view/ldl3W8\n//https://iquilezles.org/articles/distance\n//Learning a little bit about voronoi\n\n\n#define ANIMATE\nconst int DISTANCE = 1; // Different border Calculation \n\t\t\t\t\t\t//4 is worley without borders, no second loop\nconst float BorderThickness = 0.1;\nconst bool ShowPoint = false;\n\nconst vec3 red = vec3(1.0,0.0,0.0);\nconst vec3 black = vec3(0.0,0.0,0.0);\nconst vec3 white = vec3(1.0,1.0,1.0);\nconst vec3 yellow = vec3(1.0,1.0,0.0);\nconst vec3 blue = vec3(0.0,0.0,1.0);\nconst vec3 green = vec3(0.0,1.0,0.0);\nconst vec3 purple = vec3(1.0,0.0,1.0);\nconst vec3 orange = vec3(1.0,5.0,0.0);\n\n\n\nvec2 Hash2(vec2 p)\n{\n\tfloat r = 523.0*sin(dot(p, vec2(53.3158, 43.6143)));\n\treturn vec2(fract(15.32354 * r), fract(17.25865 * r));\n}\n\nfloat DistanceBetweenARectAndaPoint2D(vec2 p, vec2 rp, vec2 v)\n{\n   \n    vec2 v1 = rp - p;\n    \n    vec3 cp = cross(vec3(v,0),vec3(v1,0));\n    \n    return length(cp)/length(v);\n}\n\nvoid BisectionRect2D(vec2 p1, vec2 p2, out vec2 rp, out vec2 v)\n{\n\tv = p1-p2;\n    \n    v = vec2(v.y,v.x);\n    \n    if(v.x != 0.0){v.x = -v.x;}\n    else{v.y = -v.y;}\n    \n    rp = 0.5*(p1+p2);\n}\n\nvec2 IntersectionPoint(vec2 rp1, vec2 v1, vec2 rp2, vec2 v2)\n{\n    vec2 rpp = (rp2 -rp1) / v1;\n    vec2 vpp = v2 / v1;\n    \n    float sol1 = vpp.x - vpp.y;\n    float sol2 = rpp.y - rpp.x;\n    \n    \n    return rp2 + v2 *(sol2/sol1);\n}\n\nfloat iQuilezDistance(vec2 a, vec2 b)\n{\n    float quilez = dot( 0.5*(a+b), normalize(b-a));\n    \n    return quilez;\n}\n\nfloat distance4(vec2 p, vec2 rp, vec2 v)\n{\n    float e = 2.0/iResolution.y;\n    float f = DistanceBetweenARectAndaPoint2D(p, rp, v);\n    \n    float g = length( vec2(DistanceBetweenARectAndaPoint2D(p+vec2(e,0.0), rp, v)-DistanceBetweenARectAndaPoint2D(p-vec2(e,0.0), rp, v),\n                          DistanceBetweenARectAndaPoint2D(p+vec2(0.0,e), rp, v)- DistanceBetweenARectAndaPoint2D(p-vec2(0.0,e), rp, v))/(2.0*e));\n    return f/ g;\n}\n\n\nvec4 Worley(vec2 p, out float dist)\n{\n    vec2 integer = floor(p);\n\t\n    vec2 relativeSquarePoint;    \n        \n    vec2 closestpoint;\n    vec2 ndClosestPoint;\n    vec2 trdClosesPoint;\n    float MinDistance = 1000.0;\n    float NdMinDistance = 1000.0;\n\tfloat TrdMinDistance = 1000.0;\n    \n    float linedistance =10000.0;\n    \n    for(int i = -1; i <= 1; i++)\n    {\n    \tfor(int j = -1; j <= 1; j++)\n        {\n            vec2 relativeSquarePoint1 = integer + vec2(i,j);\n\t\t\tvec2 offset = Hash2(relativeSquarePoint1);\n            #ifdef ANIMATE\n        \toffset.x = 0.5 + 0.5*cos( iTime + 6.2831*offset.x );\n            offset.y = 0.5 + 0.5*sin( iTime + 6.2831*offset.y );\n        \t#endif\t\n           \tvec2 squarepoint = relativeSquarePoint1 +offset;\n            \n            float CurrentDistance = distance(squarepoint, p);\n            \n            \n            if(MinDistance > CurrentDistance)\n            {    \n            \tMinDistance = CurrentDistance;\n                closestpoint = squarepoint;\n                relativeSquarePoint = relativeSquarePoint1;\n            }\n            /*\n\t\t\telse if(NdMinDistance > CurrentDistance)\n            {\n                NdMinDistance = CurrentDistance;\n                ndClosestPoint = squarepoint ;\n            }\n            /*\n            else if(TrdMinDistance > CurrentDistance)\n            {\n                TrdMinDistance = CurrentDistance;\n                trdClosesPoint = squarepoint ;\n            }\n\t\t\t*/\n        }\n    }\n    \n    \n    vec2 CurrentDecimal = fract(closestpoint);\n    vec2 CurrentInteger = floor(closestpoint);\n    \n    vec2 spc1 = closestpoint - p;\n   \tif(DISTANCE!=4)\n    {\n        for(int i=-2; i<=2; i++)\n        {\n            for(int j =-2;j<=2;j++)\n            {\n                vec2 relativeSquarePoint2 = relativeSquarePoint+vec2(i,j);\n                vec2 offset = Hash2(relativeSquarePoint2);\n                #ifdef ANIMATE\n                offset.x = 0.5 + 0.5*cos( iTime + 6.2831*offset.x );\n                offset.y = 0.5 + 0.5*sin( iTime + 6.2831*offset.y );\n                #endif\t\n                vec2 SquarePoint2 = relativeSquarePoint2 +offset;\n                float CurrentDistance = distance(SquarePoint2, p);\n\n                vec2 spc2 = SquarePoint2 -p;      \t\n\n                if( !(i==0 && j==0 ))\n                {\t//La distamcia mÃ­nima no es solo con la bisectriz con el segundo punto mÃ¡s cercano\n                    //Sino con muchos otros puntos, por eso el cÃ¡lculo de la distancia debe venir aquÃ­\n\n                    if(DISTANCE == 1)\n                    {\n                        vec2 v1;\n                        vec2 rp1;\n                        BisectionRect2D(closestpoint, SquarePoint2, rp1, v1);\n                        linedistance = min(linedistance,DistanceBetweenARectAndaPoint2D(p,rp1 ,v1));\n                    }\n                    if(DISTANCE == 2)\n                        linedistance = min(linedistance,(0.5*(MinDistance + CurrentDistance) - MinDistance) /(MinDistance + CurrentDistance));\n                    if(DISTANCE == 3)\n                    {\n                        linedistance = min(linedistance,iQuilezDistance(closestpoint-p, SquarePoint2-p));\n                    }\n                }\n            }\n        }\n    }\n\n   \tdist = linedistance;\n    linedistance = smoothstep(0.00,BorderThickness,linedistance);\n    \n       \n    return vec4(MinDistance,linedistance,relativeSquarePoint.x,relativeSquarePoint.y);\n}\n\nvec3 SelectColor(float i, float j)\n{\n    float a = mod((i * i + i +j), 6.0);\n    if(a==0.0){return red;}\n    if(a==1.0){return yellow;}\n    if(a==2.0){return green;}\n    if(a==3.0){return blue;}\n    if(a==4.0){return orange;}\n    return purple;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 p =  2.0*vec2(gl_FragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    \n    float dd;\n    \n    vec4 d = Worley(4.0*p,dd);\n     \n    vec3 col = SelectColor(floor(d[2]+1.0*sin(iTime + 6.2)),floor(d[3]+1.0*cos(iTime)));\n    \n    \n    col = mix( col, col*0.5, smoothstep( 0.01, 1.0, 0.5*sin(32.0*d.x-p.y)*cos(32.0*(d.x-p.y)) ) );\n    col = mix( col, white, smoothstep( 0.1, 1.0, 0.6*sin(32.0*d.x-p.y+10.0)*cos(32.0*(d.x-p.y+10.0)) ) );\n    \n    if(ShowPoint)\n    \tcol = mix( col, yellow, 1.0 - smoothstep( 0.000, 0.5, d.x ));\n    \n    \n    col = mix( col, col*0.2, 1.0 - smoothstep( 0.01, 0.5, dd ) );\n    col = mix( col, black, (1.0 - smoothstep( 0.999, 1.0, d.y )));\n    \n    \n\tfragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}