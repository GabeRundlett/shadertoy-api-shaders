{
    "Shader": {
        "info": {
            "date": "1539813911",
            "description": "PBR",
            "flags": 32,
            "hasliked": 0,
            "id": "lt3fDM",
            "likes": 3,
            "name": "PBR raymarhing",
            "published": 3,
            "tags": [
                "atmosphere",
                "pbr"
            ],
            "usePreview": 0,
            "username": "IBets",
            "viewed": 632
        },
        "renderpass": [
            {
                "code": "\nfloat World(vec3 samplePoint){\n    \n    samplePoint = RotateY(-iTime / 2.0) * samplePoint;\n    \n    float plane  = PlaneSDF(samplePoint, vec3(0.0, 1.0, 0.0), -1.0);\n    float sphere = SphereSDF(samplePoint - vec3(0.0, abs(sin(iTime)), 0.0), 1.0);\n   \tfloat cube   = CubeSDF(RotateX(iTime / 2.0) *(samplePoint - vec3(1.1, 1.1, 1.1)), vec3(0.3, 0.3, 0.3));\n    \n    float dist = UnionSDF(plane, sphere);\n    dist = UnionSDF(dist, cube);\n    return dist;\n}\n\nfloat Occlusion(vec3 at, vec3 normal) {\n\tfloat b = 0.;\t\n\tfor (int i = 1; i <= 4; i++) {\n\t\tfloat L = .06 * float(i);\n\t\tfloat d = World(at + normal * L);\n\t\tb += max(0., L - d);\n\t}\n\treturn 1.0 - min(b, 1.);\n}\n\n\n\nvec3 Normal(vec3 a) {\n\tvec2 e = vec2(.001, 0.);\n\tfloat w = World(a);\n\treturn normalize(vec3(World(a+e.xyy) - w,\n\t\t\t\t\t\t  World(a+e.yxy) - w,\n\t\t                  World(a+e.yyx) - w));\n}\n\n\nfloat Trace(vec3 origin, vec3 dir){ \n\n    float depth = MIN_DIST;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = World(origin + depth * dir);\n        if (dist < EPSILON) return depth;\n        \n        depth += dist;\n        if (depth >= MAX_DIST) return MAX_DIST;\n        \n    }\n    return MAX_DIST;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  \n    vec3 color = vec3(1.0, 1.0, 0.0);\n        \n    mat4  viewToWorld = ViewMatrix(CameraPosition, CameraDirPoint, vec3(0.0, 1.0, 0.0));    \n    vec3  dir = (viewToWorld * vec4(Ray(iResolution.xy, fragCoord), 0.0)).xyz; \n  \n    \n    float dist = Trace(CameraPosition, dir);\n    vec3  position = CameraPosition + dist * dir;\n    vec3  normal = Normal(position);\n    \n     \n    if (dist > MAX_DIST - EPSILON) {       \n        fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n\t\treturn;\n    }\n    \n    \n    if (Trace(position + normal * vec3(0.01), normalize(LightPosition)) < MAX_DIST){\n        fragColor = vec4(vec3(0.05), 1.0);\n       \treturn;\n    }    \n    \n    vec3  baseColor  = vec3(1.0, 1.0, 1.0);       \n    float oclussion = 0.6;\n    float metallic  = 0.2;\n    float roughness = 0.4;\n \n    float alphaRoughness = roughness * roughness;\n   \n    vec3 f0 = vec3(0.04);\n    vec3 diffuseColor = baseColor.rgb * (1.0 - f0) * (1.0 - metallic);\n\n    vec3  specularColor = mix(f0, baseColor.rgb, metallic);\n    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n\n    float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);\n    vec3  specularEnvironmentR0 = specularColor.rgb;\n    vec3  specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;\n    \n    \n    vec3 N = normalize(normal);\n    vec3 V = normalize(CameraPosition - position);\n    vec3 L = normalize(LightPosition);\n    vec3 H = normalize(L + V);\n    vec3 R = -normalize(reflect(V, N));\n    \n    \n    PBRInfo pbrInputs;\n    pbrInputs.NdotL = max(0.001, dot(N, L));\n    pbrInputs.NdotV = max(0.001, abs(dot(N, V)));\n    pbrInputs.NdotH = max(0.0, dot(N, H));\n    pbrInputs.LdotH = max(0.0, dot(L, H));\n    pbrInputs.VdotH = max(0.0, dot(V, H));\n    pbrInputs.Roughness = roughness;\n    pbrInputs.Metalness = metallic;\n    pbrInputs.Reflectance0 = specularEnvironmentR0;\n    pbrInputs.Reflectance90 = specularEnvironmentR90;\n    pbrInputs.AlphaRoughness = alphaRoughness;\n    pbrInputs.DiffuseColor = diffuseColor;\n    pbrInputs.SpecularColor = specularColor;\n\n  \n    color = vec3(0.1) + CookTorrance(pbrInputs); \n    color = mix(color, vec3(0.), smoothstep(0.0, 50.0, dist));  \n    color = mix(color, color * Occlusion(position, normal), oclussion);\n   \n    fragColor = vec4(vec3(Ray(iResolution.xy, fragCoord).xy, 0.0), 1.0);\n\n    \n    \n   \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\nvec2 RSI(vec3 r0, vec3 rd, float sr) {  \n    float A = dot(rd, rd);\n    float B = 2.0 * dot(rd, r0);\n    float C = dot(r0, r0) - (sr * sr);\n    float D = (B * B) - 4.0 * A * C;\n    if (D < 0.0) return vec2(1e5, -1e5);\n    return vec2((-B - sqrt(D)) / (2.0 * A),  (-B + sqrt(D)) / (2.0 * A));\n}\n\nvec3 Atmosphere(vec3 r, vec3 r0, vec3 pSun, float iSun, float rPlanet, float rAtmos, vec3 kRlh, float kMie, float shRlh, float shMie, float g) {\n   \n    pSun = normalize(pSun);\n    r = normalize(r);\n\n    vec2 p = RSI(r0, r, rAtmos);\n    if (p.x > p.y)\n        return vec3(0, 0, 0);\n\n    p.y = min(p.y, RSI(r0, r, rPlanet).x);\n    float iStepSize = (p.y - p.x) / float(ATMOSPHERE_STEPS_X);\n\n  \n    float iTime = 0.0;\n    vec3 totalRlh = vec3(0.0);\n    vec3 totalMie = vec3(0.0);\n \n    float iOdRlh = 0.0;\n    float iOdMie = 0.0;\n\n    float mu = dot(r, pSun);\n    float mumu = mu * mu;\n    float gg = g * g;\n    float pRlh = 3.0 / (16.0 * PI) * (1.0 + mumu);\n    float pMie = 3.0 / (8.0 * PI) * ((1.0 - gg) * (mumu + 1.0)) / (pow(1.0 + gg - 2.0 * mu * g, 1.5) * (2.0 + gg));\n\n  \n    for (int i = 0; i < ATMOSPHERE_STEPS_X; i++) {\n    \n        vec3 iPos = r0 + r * (iTime + iStepSize * 0.5);\n        float iHeight = length(iPos) - rPlanet;\n\n        float odStepRlh = exp(-iHeight / shRlh) * iStepSize;\n        float odStepMie = exp(-iHeight / shMie) * iStepSize;\n\n        iOdRlh += odStepRlh;\n        iOdMie += odStepMie;\n     \n        float jStepSize = RSI(iPos, pSun, rAtmos).y / float(ATMOSPHERE_STEPS_Y);\n\n        float jTime = 0.0;     \n        float jOdRlh = 0.0;\n        float jOdMie = 0.0;\n      \n        for (int j = 0; j < ATMOSPHERE_STEPS_Y; j++)\n        {\n            vec3 jPos = iPos + pSun * (jTime + jStepSize * 0.5);\n            float jHeight = length(jPos) - rPlanet;           \n            jOdRlh += exp(-jHeight / shRlh) * jStepSize;\n            jOdMie += exp(-jHeight / shMie) * jStepSize; \n            jTime += jStepSize;\n        }\n\n        vec3 attn = exp(-(kMie * (iOdMie + jOdMie) + kRlh * (iOdRlh + jOdRlh)));    \n        totalRlh += odStepRlh * attn;\n        totalMie += odStepMie * attn;    \n        iTime += iStepSize;\n\n    }\n \n    return iSun * (pRlh * kRlh * totalRlh + pMie * kMie * totalMie);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  \n         \n    mat4  viewToWorld = ViewMatrix(CameraPosition, CameraDirPoint, vec3(0.0, 1.0, 0.0));    \n    vec3  dir = (viewToWorld * vec4(Ray(iResolution.xy, fragCoord), 0.0)).xyz; \n  \n  \n    vec3 color = Atmosphere(\n        dir,\n        vec3(0, 6372e3, 0) + CameraPosition,\n        normalize(LightPosition), \n        22.0, \n        6371e3, \n        6471e3, \n        vec3(5.5e-6, 13.0e-6, 22.4e-6), \n        21e-6, \n        8e3,\n        1.2e3, \n        0.758 \n    );\n\n \n    color = 1.0 - exp(-1.0 * color);   \n   \tfragColor = vec4(color, 1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const float PI = 3.141592653589793;\nconst float EPSILON =  0.001;\nconst int   MAX_MARCHING_STEPS = 512;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst int   ATMOSPHERE_STEPS_X = 16;\nconst int   ATMOSPHERE_STEPS_Y = 8;\n\nconst vec3  LightPosition  = vec3(1.0, 0.8, 0.5);\nconst vec3  CameraPosition = vec3(0.9, 0.9, 10.0);\nconst vec3  CameraDirPoint = vec3(0., 0.5, 0.0);\n\n\n\nmat3 RotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c));\n}\n\n\nmat3 RotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c));\n}\n\n\nmat3 RotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1));\n}\n\n\n\nmat4 ViewMatrix(vec3 eye, vec3 center, vec3 up) {\n\tvec3 f = normalize(center - eye);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n\treturn mat4(vec4(s, 0.0),\n\t\t\t\tvec4(u, 0.0),\n\t\t\t\tvec4(-f, 0.0),\n\t\t\t\tvec4(0.0, 0.0, 0.0, 1));\n}\n\n\n\nfloat PlaneSDF(vec3 p, vec3 n, float d) {\n    return dot(p, n) - d;\n}\n    \n    \nfloat SphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\n\nfloat CubeSDF(vec3 p, vec3 s) {   \n    vec3 d = abs(p) - s;   \n    float insideDistance  = min(max(d.x, max(d.y, d.z)), 0.0);\n    float outsideDistance = length(max(d, 0.0));   \n    return insideDistance + outsideDistance;\n}\n\nfloat IntersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n\nfloat UnionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n\nfloat DifferenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\nstruct MaterialConstantBuffer {\n    vec3  EmissiveFactor;\n    vec3  BaseColorFactor;\n    float MatallicFactor;\n    float RoughnessFactor;\n};\n\n\nstruct PBRInfo {\n    float NdotL;\n    float NdotV;\n    float NdotH;\n    float LdotH;\n    float VdotH;\n    float Roughness;\n    float Metalness;\n    float AlphaRoughness;\n    vec3  Reflectance0;\n    vec3  Reflectance90;  \n    vec3  DiffuseColor;\n    vec3  SpecularColor;\n};\n\n\nvec3 SpecularReflection(PBRInfo pbrInputs) {\n    return pbrInputs.Reflectance0 + (pbrInputs.Reflectance90 - pbrInputs.Reflectance0) * pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);\n}\n\nfloat GeometricOcclusion(PBRInfo pbrInputs) {\n    float NdotL = pbrInputs.NdotL;\n    float NdotV = pbrInputs.NdotV;\n \n    float r = pbrInputs.AlphaRoughness * pbrInputs.AlphaRoughness;\n    float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r + (1.0 - r) * (NdotL * NdotL)));\n    float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r + (1.0 - r) * (NdotV * NdotV)));\n    return attenuationL * attenuationV;\n\n    \n}\n\nfloat MicrofacetDistribution(PBRInfo pbrInputs) {\n    float roughnessSq = pbrInputs.AlphaRoughness * pbrInputs.AlphaRoughness;\n    float f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;\n    return roughnessSq / (PI * f * f);\n}\n\n\nvec3 CookTorrance(PBRInfo pbrInputs) {\n    vec3  F = SpecularReflection(pbrInputs);\n    float G = GeometricOcclusion(pbrInputs);\n    float D = MicrofacetDistribution(pbrInputs);\n\n    vec3 diffuseContrib = (1.0 - F) * (pbrInputs.DiffuseColor / PI);\n    vec3 specContrib = F * G * D / (4.0 * pbrInputs.NdotL * pbrInputs.NdotV);\n    return pbrInputs.NdotL * ( diffuseContrib + specContrib);\n\n}    \n    \n    \nvec3 Ray(vec2 size, vec2 fragCoord) {   \n    vec2 uv =  2.0 * (fragCoord / size) - 1.;\n\tuv.x *= size.x / size.y;\n    return normalize(vec3(uv, -5));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}