{
    "Shader": {
        "info": {
            "date": "1642379916",
            "description": "It turns out that with a slight modification, a convolution with a gaussian kernel gives the exact solution to the 2D heat equation. So the initial function literally just becomes more blurred over time.",
            "flags": 0,
            "hasliked": 0,
            "id": "flGXRc",
            "likes": 16,
            "name": "2D Heat Equation - Square",
            "published": 3,
            "tags": [
                "2d",
                "heat",
                "pde",
                "plate"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 465
        },
        "renderpass": [
            {
                "code": "// Error function approximation\nfloat erf(in float x) {\n    //return sign(x) * sqrt(1.0 - exp2(-1.787776 * x * x));\n    float t = 1.0 / (1.0 + 0.3275911 * abs(x));\n    return (1.0 - (((((1.061405429 * t - 1.453152027) * t + 1.421413741) * t - 0.284496736) * t + 0.254829592) * t) * exp(-x * x)) * sign(x);\n}\n\nvec3 heatPalette(in float h) {\n    return pow(vec3(0.98, 0.93, 0.1), vec3(h));\n}\n\nfloat heatSquare(in vec2 p, in float t, in float k) {\n    float w = 2.0 * sqrt(k * t);\n    float a = erf((p.x + 1.0) / w) - erf((p.x - 1.0) / w);\n    float b = erf((p.y + 1.0) / w) - erf((p.y - 1.0) / w);\n    return a * b / 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 5.0;\n    vec2 corner = vec2(2.5 * iResolution.x / iResolution.y, 2.5);\n\n    float t = max(0.0, iTime - 1.0);\n    float temp = heatSquare(uv, t, 0.01);\n    fragColor = vec4(heatPalette((1.0 - temp) * 100.0), 1.0);\n\n    vec2 textTimeUv = 0.25 * (uv + corner + vec2(0.3, -0.1));\n    fragColor.rgb = digitIn(fragColor.rgb, vec3(1.0), textTimeUv, 100.0, t);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "        /////////////////////////////////////////////////////////////////\n       //                                                            ////\n      //  \"little debugging font\"                                   // //\n     //                                                            //  //\n    //  This utility uses a small bitmapped font (3x5) to render  //   //\n   //  floats, primarily intended for debugging. The code can    //    //\n  //  be copy/pasta'd into the Common tab as needed.            //     //\n //                                                            //     //\n////////////////////////////////////////////////////////////////     //\n//                                                            //    //\n// Creative Commons Attribution-NonCommercial-ShareAlike      //   //                                       //  //\n// 3.0 Unported License                                       //  //\n//                                                            // //\n// by Val \"valalalalala\" GvM ðŸ’ƒ 2021                          ////\n//                                                            ///\n////////////////////////////////////////////////////////////////\n\nconst int CHARACTERS[14] = int[14](31599, 9362, 31183, 31207, 23524, 29671, 29679, 30994, 31727, 31719, 1488, 448, 2, 3640);\n\nfloat digitIsOn(in int digit, in vec2 id) {   \n    if (id.x < 0.0 || id.y < 0.0 || id.x > 2.0 || id.y > 4.0 ) return 0.0;\n    return floor(mod(float(CHARACTERS[int(digit)]) / pow(2.0, id.x + id.y * 3.0), 2.0));\n}\n\nfloat digitSign(in float v, in vec2 id) {\n    return digitIsOn(10 - int((sign(v) - 1.0) * 0.5), id);\n}\n\nint digitCount(in float v) {\n    return int(floor(log(max(v, 1.0) ) / log(10.0)));\n}\n\nfloat digitFirst(in vec2 uv, in float scale, in float v, in int decimalPlaces) {\n    vec2 id = floor(uv * scale);\n\n    if (0.0 < digitSign(v, id)) return 1.0;\n    v = abs(v);\n\n    int digits = digitCount(v);\n    float power = pow(10.0, float(digits));\n    \n    float offset = floor(0.1 * scale);\n    id.x -= offset;\n\n    float n;\n    for (int i = 0; i < 33; i++, id.x -= offset, v -= power * n, power /= 10.0) {\n        n = floor(v / power);\n        if (0.0 < digitIsOn(int(n), id)) return 1.0;   \n        if (i == digits) {\n            id.x -= offset;\n            if (0.0 < digitIsOn(int(12), id)) return 1.0;\n        }\n\n        if (i >= digits + decimalPlaces) return 0.0;\n    }\n\n    return 0.0;\n}\n\nfloat digitFirst(in vec2 uv, in float scale, in float v) {\n    return digitFirst(uv, scale, v, 3);\n}\n\nvec3 digitIn(in vec3 color, in vec3 toMix, in vec2 uv, in float scale, in float v) {\n    float f = digitFirst(uv, scale, v);\n    return mix(color, toMix, f);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}