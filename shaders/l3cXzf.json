{
    "Shader": {
        "info": {
            "date": "1719341955",
            "description": "I decided to make a beach scene inspired by my first shader of all time, a 2d palm tree with coconuts.\nNote that the trees significantly slow down the render, so keep the count low. (sub 30).\nEdit: added gamma correction.",
            "flags": 0,
            "hasliked": 0,
            "id": "l3cXzf",
            "likes": 5,
            "name": "The Beach V1",
            "published": 3,
            "tags": [
                "raymarching",
                "phong",
                "sdf",
                "fbm",
                "water",
                "ocean",
                "distance",
                "mountains",
                "sand",
                "beach"
            ],
            "usePreview": 0,
            "username": "spenceryonce",
            "viewed": 114
        },
        "renderpass": [
            {
                "code": "#define MAX_MARCHING_STEPS 270\n#define MIN_DIST 0.0\n#define MAX_DIST 40.0\n#define EPSILON 0.001\n#define NUM_TREES 2\n#define WATER_SCALE 1.0\n#define SUN_POS vec3\\\n    (0.0-sin(iTime*0.3)*4.0, \\\n    7.0-cos(iTime*0.3)*2.0,  \\\n    10.0+sin(iTime*0.3)*4.0)\n#define SUN_COLOR vec3(0.9412, 0.8824, 0.7725)\n\n\n// Noise function\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nfloat noise(vec2 x) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 x, float H) {\n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for (int i = 0; i < 5; i++) {\n        t += a * noise(f * x);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\n// SDF functions\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat cylinderSDF(vec3 p, float h, float r) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat planeSDF(vec3 p, vec4 n) {\n    return dot(p, n.xyz) + n.w;\n}\n\nfloat terrainSDF(vec3 p) {\n    float height = 2.0 * fbm(p.xz * 0.2, 0.8);\n    return p.y - height;\n}\n\nfloat waterSDF(vec3 p, float scale) {\n    float time = iTime * 0.3;\n    float wave1 = sin(p.x * 0.5 * scale + time) * 0.1;\n    float wave2 = sin(p.z * 0.7 * scale - time * 1.3) * 0.07;\n    float wave3 = sin((p.x * 0.3 + p.z * 0.4) * scale + time * 0.8) * 0.05;\n    return p.y - wave1 - wave2 - wave3;\n}\n\nfloat treeSDF(vec3 p, float trunkHeight, float trunkRadius, float leavesRadius) {\n    // Trunk\n    float trunk = cylinderSDF(p, trunkHeight, trunkRadius);\n    trunk -= 0.005 * sin(p.y*20.0+10.0); \n    \n    // Leaves (simplified as a sphere)\n    vec3 leavesCenter = vec3(0.0, trunkHeight, 0.0);\n    float leaves = sphereSDF(p - leavesCenter, leavesRadius);\n    leaves += 0.05 * sin(p.y*20.0+15.0);\n    \n    return min(trunk, leaves);\n}\n\nfloat sunSDF(vec3 p) {\n    return length(p - SUN_POS) - 1.0; // Sun radius is 1.0\n}\n\nfloat sunGlow(vec3 p, vec3 rd) {\n    vec3 sunDir = normalize(SUN_POS - p);\n    float sunDot = max(dot(rd, sunDir), 0.0);\n    return pow(sunDot, 32.0);\n}\n\n// Random position generator\nvec2 random2(vec2 st) {\n    st = vec2(dot(st, vec2(127.1, 311.7)),\n              dot(st, vec2(269.5, 183.3)));\n    return -1.0 + 2.0 * fract(sin(st) * 43758.5453123);\n}\n\n// Smooth min function for soft union\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n// Scene SDF\nfloat sceneSDF(vec3 p) {\n    // Ground (beach)\n    float ground = planeSDF(p-vec3(0.,1.,0.), vec4(0.0, 1.0, 0.0, 1.0));\n    \n    // Mountains using terrain SDF\n    float mountains = terrainSDF(p-vec3(0.0, -2.0, 10.0));\n\n    // Water\n    float water = waterSDF(p,WATER_SCALE);\n    float sun = sunSDF(p);\n\n    // Scattered trees\n    float trees = MAX_DIST;\n    for (int i = 0; i < NUM_TREES; i++) {\n        vec2 randomOffset = random2(vec2(float(i), 1.0)) * 10.0;\n        vec3 treePos = vec3(randomOffset.x, 0.0, randomOffset.y + 10.0);\n        float terrainHeight = -terrainSDF(treePos - vec3(0.0, -2.0, 10.0)); // Place tree on terrain surface\n        if (terrainHeight > 0.1) {\n            treePos.y = terrainHeight; // Place tree on terrain surface\n            float tree = treeSDF((p - treePos) * vec3(1.0, 1.0, 1.0), 0.5, 0.05, 0.1);\n            trees = min(trees, tree);\n        }\n    }\n    \n    // Combine all elements\n    float scene = water; // Smooth union of ground and mountains\n    scene = min(scene, mountains);\n    scene = min(scene, trees);\n    scene = min(scene, sun);\n    \n    return scene;\n}\n\n// Ray marching\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float depth = MIN_DIST;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 p = ro + depth * rd;\n        float dist = sceneSDF(p);\n        if (dist < EPSILON) {\n            return depth;\n        }\n        depth += dist;\n        if (depth >= MAX_DIST) {\n            return MAX_DIST;\n        }\n    }\n    return MAX_DIST;\n}\n\n// Normal estimation\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 phongLighting(vec3 p, vec3 normal, vec3 viewDir, vec3 objectColor) {\n    vec3 lightDir = normalize(SUN_POS - p);\n\n    float diff = max(dot(normal, lightDir), 0.0);\n    vec3 diffuse = diff * SUN_COLOR;\n\n    float ambientStrength = 0.2;\n    vec3 ambient = ambientStrength * SUN_COLOR;\n\n    float specularStrength = 0.5;\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\n    vec3 specular = specularStrength * spec * SUN_COLOR;\n\n    return (ambient + diffuse + specular) * objectColor;\n}\n\n// Color function\nvec3 getColor(vec3 p, vec3 normal, vec3 viewDir) {\n    vec3 lightDir = normalize(vec3(1.0, 1.0, -1.0)); // Directional light\n    vec3 lightColor = vec3(1.0, 1.0, 0.9); // Slightly warm sunlight\n    \n    // Sky color\n    vec3 skyColor = mix(vec3(0.4, 0.6, 1.0), vec3(0.7, 0.9, 1.0), p.y * 0.1 + 0.5);\n    \n    // Ground color (beach sand)\n    vec3 groundColor = vec3(0.9, 0.8, 0.6);\n    \n     // Updated water color and effect\n    vec3 baseWaterColor = vec3(0.0, 0.4, 0.6);\n    vec3 waterHighlight = vec3(0.2, 0.7, 0.9);\n    float waterNoise = fbm(p.xz * WATER_SCALE + iTime * 0.1, 0.7);\n    vec3 waterColor = mix(baseWaterColor, waterHighlight, waterNoise * 0.5 + 0.5);\n    float waterHeight = -waterSDF(p, WATER_SCALE);\n    \n    // Mountain color\n    vec3 mountainColor = vec3(0.5, 0.4, 0.3);\n    \n    // Palm tree colors\n    vec3 trunkColor = vec3(0.3961, 0.2549, 0.0392);\n    vec3 leavesColor = vec3(0.1843, 0.5059, 0.0941);\n\n    float sunDist = sunSDF(p);\n    float glow = sunGlow(p, viewDir);\n    \n    // Determine the color based on the position and normal\n    vec3 objectColor;\n    if (sunDist < EPSILON) {\n        float sunPattern = sin(p.x * 10.0) * sin(p.y * 10.0) * sin(p.z * 10.0);\n        vec3 sunDetailColor = mix(SUN_COLOR, vec3(1.0), sunPattern * 0.1);\n        return sunDetailColor;\n    }else if (waterSDF(p,WATER_SCALE) < 0.001) { \n        objectColor = waterColor;\n        // Add specular highlight to water\n        float spec = pow(max(dot(reflect(-lightDir, normal), -viewDir), 0.0), 32.0);\n        objectColor += vec3(0.5) * spec;\n    }else if (p.y < 2.0 * fbm(p.xz * 0.2, 0.8)) {\n        objectColor = mountainColor;\n        if (p.y < waterHeight + 0.25) {\n            float sandBlend = smoothstep(waterHeight, waterHeight + 0.25, p.y);\n            objectColor = mix(groundColor, mountainColor, sandBlend);\n        }\n        // Check if it's a tree\n        for (int i = 0; i < NUM_TREES; i++) {\n            vec2 randomOffset = random2(vec2(float(i), 1.0)) * 10.0;\n            vec3 treePos = vec3(randomOffset.x, 0.0, randomOffset.y + 10.0);\n            treePos.y = -terrainSDF(treePos - vec3(0.0, -2.0, 10.0));\n            vec3 relativePos = p - treePos;\n            if (length(relativePos.xz) < 0.06 && relativePos.y < 0.5) {\n                objectColor = trunkColor;\n            } else if (length(relativePos - vec3(0.0, 0.5, 0.0)) < 0.3) {\n                objectColor = leavesColor;\n            }\n        }\n    } \n    if (objectColor == vec3(0.0)){\n        return mix(skyColor, SUN_COLOR, glow * 0.9);\n    }\n    \n    vec3 litColor = phongLighting(p, normal, viewDir, objectColor);\n    return mix(litColor, SUN_COLOR, glow * 0.3);\n}\n\nvoid mainImage(out vec4 O, vec2 fc) {\n    vec2 uv = (fc.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec3 ro = vec3(0.0, 2.0, -5.0); // Camera position\n    vec3 rd = normalize(vec3(uv, 1.0)); // Ray direction\n    \n    float dist = rayMarch(ro, rd);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Ray didn't hit anything, return sky/sun color\n        float glow = sunGlow(ro, rd);\n        vec3 skyColor = mix(vec3(0.4, 0.6, 1.0), vec3(0.7, 0.9, 1.0), rd.y * 0.5 + 0.5);\n        O = vec4(mix(skyColor, SUN_COLOR, glow * 0.5), 1.0);//fragColor = vec4(mix(vec3(0.4, 0.6, 1.0), vec3(0.7, 0.9, 1.0), uv.y + 0.5), 1.0);\n    } else {\n        vec3 p = ro + dist * rd;\n        vec3 normal = estimateNormal(p);\n        vec3 color = getColor(p, normal, -rd);\n        color = pow(color, vec3(0.454545));\n        O = vec4(color, 1.0);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}