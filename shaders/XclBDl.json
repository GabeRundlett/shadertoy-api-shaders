{
    "Shader": {
        "info": {
            "date": "1724601341",
            "description": "A experimental lava texture .. it's done adding a pseudo-random rotation vector each frame to the texture coordinate. Coloring this was quite tricky.\nIt takes some time to converge, but then it remains stable.\n",
            "flags": 32,
            "hasliked": 0,
            "id": "XclBDl",
            "likes": 7,
            "name": "MoltenTexture",
            "published": 3,
            "tags": [
                "texture",
                "lava",
                "hot",
                "molten"
            ],
            "usePreview": 0,
            "username": "kuvkar",
            "viewed": 117
        },
        "renderpass": [
            {
                "code": "/*\n    A lava texture.. it's done adding a pseudo-random rotation vector each frame to the texture coordinate. Coloring this was quite tricky.\n    It takes some time to converge, but then it remains stable until resolution runs out from floats.\n*/\n\nvec3 dark = vec3(20.0, 33.0, 48.0) / 255.0 * 1.5;\nvec3 violets = vec3(90.0, 82.0, 100.0) / 255.0 * 1.7;\nvec3 bright = vec3(249.0, 113.0, 48.0) / 255.0;\nvec3 reds = vec3(247.0, 50.0, 48.0) / 255.0 * 1.2;\n\nvec3 getColor(in float f)\n{\n    vec3 col = dark;\n    col = mix(col, violets, smoothstep(0., 0.5, f));\n    col = mix(col, reds, smoothstep(0.4, .9, f));\n    col = mix(col, bright, smoothstep(0.8, 1., f));\n    col = mix(col, bright * 1.4, smoothstep(0.8, 1.2, f));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 suv = fragCoord/iResolution.xy;\n    suv.y /= iResolution.x / iResolution.y;\n    vec2 suuv = texture(iChannel1, suv).yz;\n    \n    // the coloring madness. \n    vec3 basecol = texture(iChannel0, suv + suuv * .525).rgb;\n    vec3 basecol2 = texture(iChannel2, suv + suuv * 0.2).rgb;\n    vec3 basecol3 = texture(iChannel3, suv * 2.0 + suuv * 3.0).rgb;\n\n    basecol3 += texture(iChannel3, suv + suuv * .1 * vec2(1., 6)).rgb;\n    basecol3 *= 0.5;\n    \n    basecol -= basecol2 * .10;\n    vec3 col = vec3(basecol);\n    float luma = length(col.rgb);\n    \n    float rock = smoothstep(0.5, 0.4, length(basecol));\n    rock += basecol3.r;\n    rock = 1.0 - rock;\n    \n    float a = 0.05;\n    float fire = clamp(1.0 - ((rock - a) / a), 0.0, 1.0);\n    fire *= basecol3.r * 0.5 + .5;\n    col = getColor((fire * (1.1 - luma) * 1.5));\n    \n    vec3 rockCol = getColor(0.2 + (luma * rock) * .4);\n    \n    float edge = smoothstep(0.09, 0., abs(luma - 0.4));\n    col = mix(col, rockCol, edge);\n    \n    edge = smoothstep(0.2, 1.2, (length(basecol) + 0.1));\n    col = mix(col, rockCol, edge);\n    \n    // some nasty edges form where textures sample the highest mip levels\n    // this hides the issue a bit\n    // there could be a better way to fix this but not sure what that is.\n    float baduv = (smoothstep(0.0, .03, length(fwidth(suuv.xy))));\n    col = mix(col, rockCol * .8, baduv * .8);\n\n    float bloom = smoothstep(.4, .0, luma) * (sin(suv.x * 10. + iTime * 2.0) * 0.5 + 0.5);\n    col += vec3(bloom) * .6;\n    fragColor.rgb = col;\n    \n    \n    fragColor = smoothstep(0.0, 1., fragColor);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// https://www.shadertoy.com/view/lsf3WH\nfloat hash( in ivec2 p )  // this hash is not production ready, please\n{                         // replace this by something better\n\n    // 2D -> 1D\n    int n = p.x*3 + p.y*113;\n\n    // 1D hash by Hugo Elias\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return -1.0+2.0*float( n & 0x0fffffff)/float(0x0fffffff);\n}\n// https://www.shadertoy.com/view/lsf3WH\nfloat noise( in vec2 p )\n{\n    ivec2 i = ivec2(floor( p ));\n    vec2 f = fract( p );\n\t\n    // cubic interpolant\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return 0.5 + mix( mix( hash( i + ivec2(0,0) ), \n                     hash( i + ivec2(1,0) ), u.x),\n                mix( hash( i + ivec2(0,1) ), \n                     hash( i + ivec2(1,1) ), u.x), u.y);\n}\n\n\nfloat fbm(in vec2 uv)\n{\n    uv *= 10.0;\n    float f = noise(uv * .5) * 0.5;\n    f += noise(uv * 1.0) * 0.5 * 0.5;\n    f += noise(uv * 1.5) * 0.5 * 0.5 * 0.5;\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 data = texture(iChannel1, uv);\n    vec2 uvOffset = data.yz;\n    float oldRes = data.w;\n    \n    if (oldRes != iResolution.y) // check for resolution change\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, iResolution.y);\n        return;\n    }\n    float r = fbm(uvOffset + uv) * 3.1419265 * 3.0;\n    mat2 m = mat2(cos(r), -sin(r), sin(r), cos(r));\n    vec2 curl = vec2(1.0, 0.0) * m;\n    float t = iTimeDelta;\n\n    uvOffset.xy += curl * t * 0.015;\n    fragColor = vec4(0.0, uvOffset, iResolution.y);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}