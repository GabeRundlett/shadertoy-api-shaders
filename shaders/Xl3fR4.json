{
    "Shader": {
        "info": {
            "date": "1538689095",
            "description": "simple BW raytracer with checkerboard and mirror spheres based on Daniel A. Nagy's BASIC program for PRIMO (a simple Z80-based home computer produced in Hungary around 1985).",
            "flags": 0,
            "hasliked": 0,
            "id": "Xl3fR4",
            "likes": 1,
            "name": "primo raytacer",
            "published": 3,
            "tags": [
                "raytrace"
            ],
            "usePreview": 0,
            "username": "dabadab",
            "viewed": 377
        },
        "renderpass": [
            {
                "code": "// number of spheres\nconst int SPHERES=2;\n\n// sphere data: x, y, z, radius\nconst vec3 SPHERE_COORD[SPHERES]= vec3[2](\n        vec3(-0.3, -0.8, 3.0),\n        vec3( 0.9, -1.1, 2.0)\n    );\n\nconst float SPHERE_RADIUS[SPHERES]= float[2](\n        0.6,\n        0.2\n    );\n\nvec3 renderPixel(in vec2 fragCoord) {\n    vec3 pos=vec3(0.3,-0.5,0);\n    vec3 ray=vec3(fragCoord.x-iResolution.x/2.0, -fragCoord.y+iResolution.y/2.0, iResolution.x*1.0);\n    \n    while ( true ) {\n        float s=0.0;\n        int n = -1;\n\n        if ( !( pos.y >= 0.0 || ray.y <= 0.0 ) ) {\n            s = -pos.y/ray.y;\n            n = 0; // the floor is hit\n        }\n\n        for ( int k=0 ; k < SPHERES ; k++ ) {\n            vec3 to_sphere = SPHERE_COORD[k]-pos;\n            float sc = dot(to_sphere, ray);\n            if ( sc > 0.0 ) { // the angle between to_sphere and ray is between -90 and +90 degrees\n                float pp = dot(to_sphere, to_sphere); // TODO: length?\n                float bb = sc * sc / (length(ray) * length(ray));\n                float aa = SPHERE_RADIUS[k]*SPHERE_RADIUS[k] - pp + bb;\n                if ( aa > 0.0 ) {\n                    sc = (sqrt(bb) - sqrt(aa)) / length(ray);\n                    if ( sc < s || n < 0 ) { // this is the closest hit so far or nothing was hit previously\n                        n = k+1;\n                        s = sc;\n                    }\n                }\n            }\n        }\n\n        if ( n < 0 ) { // we hit nothing (so it's the sky)\n            return vec3(0.0);\n        }\n\n        // we hit something\n        ray = ray * s; // set the ray to the correct length\n        pos += ray; // go where the ray hit\n        if ( n == 0 ) {\n            // we hit the floor - finally!            \n            // check the shadows\n            for ( int k=0 ; k < SPHERES ; k++ ) {\n                vec2 dist_from_sphere = vec2(SPHERE_COORD[k].x-pos.x, SPHERE_COORD[k].z-pos.z);\n                if ( length(dist_from_sphere) < SPHERE_RADIUS[k] ) {\n                    // we are in the shadow\n                    return vec3(0.0);\n                }            \n            }\n            if ( (pos.x-floor(pos.x) > 0.5) != (pos.z - floor(pos.z) > 0.5) ) {\n                // white floor tile\n                return vec3(1.0);\n            } else {\n                // black floor tile\n                return vec3(0.0);\n            }\n        } else {\n            // hit a sphere\n            \n            // calculate normal vector\n            vec3 normal =pos - SPHERE_COORD[n-1];\n            float l = 2.0*dot(ray, normal)/dot(normal, normal);\n            ray = ray - ( l * normal );\n        }\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = renderPixel(fragCoord);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}