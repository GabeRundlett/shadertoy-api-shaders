{
    "Shader": {
        "info": {
            "date": "1474236587",
            "description": "I had to lock this bad boy up. I'll come back to fix the texture/colors at some point.",
            "flags": 0,
            "hasliked": 0,
            "id": "llVGDR",
            "likes": 9,
            "name": "Prisoner Bulb",
            "published": 3,
            "tags": [
                "fractal",
                "mandelbulb",
                "distanceestimation",
                "geometricorbittraps"
            ],
            "usePreview": 0,
            "username": "Aspect",
            "viewed": 1182
        },
        "renderpass": [
            {
                "code": "vec3 gradient=vec3(0.0);\n\n\n#define PI 3.1415926535\n#define oversample 0\n#define shadows 1\n\nvec3 whotrapped;\n\nfloat orbtrap=100000.0;\nfloat casez=0.;\n\nfloat opS( float d1, float d2 )\n{\n    return (-d2>d1)? -d2:d1;\n}\n\n\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nvec3 rotate( vec3 pos, float x, float y, float z )\n{\n\tmat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0, cos( x ), -sin( x ), 0.0, sin( x ), cos( x ) );\n\tmat3 rotY = mat3( cos( y ), 0.0, sin( y ), 0.0, 1.0, 0.0, -sin(y), 0.0, cos(y) );\n\tmat3 rotZ = mat3( cos( z ), -sin( z ), 0.0, sin( z ), cos( z ), 0.0, 0.0, 0.0, 1.0 );\n\n\treturn rotX * rotY * rotZ * pos;\n}\n\n\n\n\n\n//from iq's raymarching primitives\n\nvec2 box( vec3 p, vec3 b)\n{\n  //  mat4 rotmat=rotationMatrix(p,10.1*cos(iTime));\n  //  p=(rotmat*vec4(p,1.0)).xyz;\n //   b=b*2.;\n //   p=p*1.0;\n return vec2(length(max(abs(p)-b,0.0))-0.0,-44.0);\n}\n\n\nfloat shBox(vec3 p, vec3 b,float thickness)\n{\n float dist= opS(sdBox(p,b),sdBox(p+vec3(0.0,-p.y,0.0),b/thickness));\n  dist= opS(dist,sdBox(p+vec3(0.0,p.y,0.0),b/thickness));\n  dist= opS(dist,sdBox(p+vec3(p.x,0.0,0.0),b/thickness));\n  dist= opS(dist,sdBox(p+vec3(-p.x,0.0,0.0),b/thickness));\n  dist= opS(dist,sdBox(p+vec3(0.0,0.0,p.z),b/thickness));\n  dist= opS(dist,sdBox(p+vec3(0.0,0.0,-p.z),b/thickness));\n\n    \n\n    \n                return dist;\n}\n\nfloat mandel(vec3 pos)\n{\n    float dr=1.0;\n    pos=rotate(pos,cos(0.35*iTime),sin(0.35*iTime),0.0);\n    pos=pos*1.00;\n    float r=1.0;\n    vec3 zeta= pos;\n    vec3 w=pos;\n    float wr=2.0;\n    vec2 mdb=vec2(0.0);\n    vec3 c= vec3(0.0);\n    orbtrap=1.0;\n    \n    for(int i=0;i<10;++i)\n    {\n        w=rotate(w,cos(0.75*iTime),sin(0.75*iTime),0.0);\n      // w=w*(abs(cos(4.*iTime)/24.)+0.8);\n        //c=vec3(cos(iTime),sin(iTime),0.0);\n\n            wr=length(w);\n           if(wr*wr>2.)\n        {\norbtrap=float(i);\n            whotrapped=w;\n             break;\n        }\n          float wo = acos(w.y/wr);\n          float wi = atan(w.x,w.z);\n\n          dr= 8.0*pow(wr,7.0)*dr +1.;\n\n\n          wr = pow( wr, 7. );\n         // wr= wr*r + 10.*wr +1.;\n          wo = wo * 7.;\n          wi = wi * 7.;\n\n        \n          w.x = wr * sin(wo)*sin(wi);\n          w.y = wr * cos(wo);\n          w.z = wr * sin(wo)*cos(wi);\n        \t\n        \n       //  w.x = wr * cos(wo)*cos(wi);\n       //   w.y = wr * cos(wo)*sin(wi);\n       //  w.z = wr * sin(wo);\n        \t\n        \n       //  cos(theta)*cos(phi), cos(theta)*sin(phi), sin(theta)\n\n        w+=1.*pos;     \n\n    }\n    if(wr*wr<=14.)\n    {\n        float bboy1=    shBox(w,vec3(1.2),1.1)*pow(20.0,-orbtrap-0.0);\n        float bboy2=(1.00*0.5*log(wr)*wr/dr);\n        if(bboy1<bboy2)\n        {\n            casez=1.;\n         return bboy1;   \n        }\n        else\n        {\n            casez=2.;\n           return bboy2;\n        }\n        \n      \n      }\n    else{\n        casez=3.;\n     return   0.85*0.5*log(wr)*wr/dr;\n    }\n}\n\n\n\n\n\nfloat distfunc(vec3 pos)\n{  \n  //return min(box(pos,vec3(0.9,0.9,0.9)),mandel(pos));\n  return mandel(pos);\n //   return manDE(pos);\n\n}\n\nvec2 distfunc2(vec3 pos)\n{  \n  return box(pos,vec3(1.55,1.55,1.5));\n//  return mandel(pos);\n //   return manDE(pos);\n\n}\n\n\nvec3 rayMarch2(vec3 pos,vec3 rayDir,float EPSILON,inout vec2 dist)\n{\n    float mini=999999.0;\n    float origid=dist.y;\n    for (int i = 0; i < 10; i++)\n    {       \n        if ((dist.x < EPSILON)&&(dist.y!=origid))   continue;   \n        \n        dist = distfunc2(pos); \n        pos += dist.x * rayDir;\n        if(dist.x<mini) mini=dist.x;\n    }\n    return pos;\n}\n\n\nvec3 rayMarch(vec3 pos,vec3 rayDir,float EPSILON,inout vec2 dist)\n{\n    float mini=999999.0;\n    dist.y=0.;\n    for (int i = 0; i < 170; i++)\n    {       \n        if ((dist.x < EPSILON))   continue;   \n        \n        dist.x = distfunc(pos);\n        dist.y+=dist.x;\n        pos += dist.x * rayDir;\n        if(dist.x<mini) mini=dist.x;\n    }\n    return pos;\n}\n\nvec3 shadMarch(vec3 pos,vec3 rayDir,float EPSILON,inout vec2 dist)\n{\n    float mini=999999.0;\n    float origid=dist.y;\n    for (int i = 0; i < 30; i++)\n    {       \n        if ((dist.x < EPSILON)&&(dist.y!=origid))   continue;   \n        \n        dist.x= distfunc(pos); \n        pos += dist.x * rayDir;\n        if(dist.x<mini) mini=dist.x;\n    }\n    return pos;\n}\n\n//https://www.reddit.com/r/twotriangles/comments/1hy5qy/tutorial_1_writing_a_simple_distance_field/\nvec3 calculateNormal(float EPSILON, vec3 pos,in vec2 dist)\n{\n  \tvec2 eps = vec2(0.0, EPSILON);\nvec3 normal = normalize(vec3(\n    distfunc(pos + eps.yxx) - distfunc(pos - eps.yxx),\n   distfunc(pos + eps.xyx) - distfunc(pos - eps.xyx),\n    distfunc(pos + eps.xxy) - distfunc(pos - eps.xxy)));\n        \n      \t//vec2 eps = vec2(0.0, EPSILON);\n//\tvec3 normal = normalize(vec3(\n  //  distfunc(pos + eps.yxx).x -dist.x,\n  // distfunc(pos + eps.xyx).x - dist.x,\n  //  distfunc(pos + eps.xxy).x - dist.x));\n    \n    return normal;\n}\n\n\n\nvoid getRay(vec2 screenPos,out vec3 cameraOrigin,out vec3 rayDir)\n{\n    cameraOrigin = vec3(0.0+0.0*cos(iTime), 0.0+0.0*sin(iTime), 1.35+0.2*cos(iTime));  \n    vec3 cameraTarget = vec3(0.0, 0.0, 1.0);\n    vec3 upDirection = vec3(0.0, 1.0, 0.0);\n    vec3 cameraDir = normalize(cameraTarget - cameraOrigin);\n    vec3 cameraRight = normalize(cross(cameraDir,upDirection));\n\tvec3 cameraUp = normalize(cross(cameraRight,cameraDir));\n    rayDir = normalize(cameraRight * screenPos.x + cameraUp * screenPos.y + cameraDir);\n   //rayDir=normalize(cameraDir+vec3(screenPos,0.0));\n                  \n\n\n}\n\n\nvec4 render(vec2 ScreenPos)\n{\n    vec3 rayDir=vec3(0.0);\n    vec3 pos=vec3(0.0);\n    getRay(ScreenPos,pos,rayDir);\n    \n \n    const int MAX_ITER = 100;\n    const float MAX_DIST = 20.0; \n    float EPSILON = 0.00085;\n    float totalDist = 0.0;\n    vec2 dist = vec2(EPSILON,0.0);\n    vec3 lightpos=vec3(5.0,5.0,5.0);\n\n    //initial march towards objects\n    vec3 dummypos=pos;\n \tpos=rayMarch2(dummypos,rayDir,EPSILON,dist);\n             if (dist.x <EPSILON)\n        {  \n               vec3 color=vec3(0.0);\n\n        vec2 dist = vec2(EPSILON,0.0);\n\n   \t\t\t pos=rayMarch(pos,rayDir,EPSILON,dist);\n   \t\t\t\t\n            \n            if (dist.x <EPSILON)\n     \t\t\t{  \n\n\t\t\n\n                EPSILON=0.00001;\n\n            // pos=pos-0.0001*rayDir;\n             vec3 normal=calculateNormal(EPSILON,pos,dist);\n\n\n            vec3  lightdir=   normalize(lightpos-pos);  \n            vec3 halfvec= normalize(lightdir-rayDir);\n            vec3 reflected= normalize(reflect(rayDir,normal));\n#if shadows\n\n                 //shadow ray \n            EPSILON=0.005;\n            vec2 shadowdist=vec2(EPSILON,dist.y);\n           vec3 shadowpos=shadMarch(pos+0.01*lightdir,lightdir,EPSILON,shadowdist);\n            if(shadowdist.x<EPSILON)\n            {\n                color=vec3(0.0,0.0,0.0);\n\n            }\n            else\n#endif                \n            {\n\n        \n        \n   \n        \n    float diffuse = max(0.0, dot(lightdir, normal));\n       \n    float specular = pow(dot(normal,halfvec), 32.0);\n        \n     \n\n                \n             vec3 texcol=texture(iChannel0,pos.xy).xyz;\n  \t\t\t color = vec3(0.5,0.75,0.5);\n                \n                if(casez==2.)\n                {\n                    color=mix(texcol*1.,color,0.0);\n                }\n                if(casez==3.)\n                {\n                    color=mix(texcol*1.,color,0.50);\n                }\n     \n                          \n                          color*=(diffuse + specular);\n\n                \n                  //  color *= clamp(2.0*dot(pos,pos),0.0,1.0);\n\t\t\t\t color *= exp( -0.5*dist.y );\n    \t\t}     \n             return vec4(color, 1.0);\n\n\t\t}\n            \n        \nelse{\n     vec3 bg=vec3(1.0,1.0,1.00);\n    bg=exp(-(ScreenPos.x*ScreenPos.x+ScreenPos.y*ScreenPos.y)/abs(2.*(cos(1.0*iTime)+1.55)))*bg;\n    return vec4(bg,1.0);\n}\n        }\n            else{\n                \n     vec3 bg=vec3(1.00,1.0,1.00);\n    bg=exp(-(ScreenPos.x*ScreenPos.x+ScreenPos.y*ScreenPos.y)/abs(2.*(cos(1.0*iTime)+1.55)))*bg;\n    return vec4(bg,1.0);\n            }\n            \n            \n}\n\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{         \n\n \n    vec2 screenPos = -1.0 + 2.0 * fragCoord.xy / iResolution.xy; \n     screenPos.x *= iResolution.x / iResolution.y; \n\n    vec2 fc2=fragCoord.xy + vec2(-0.125, -0.375); \n\tvec2 fc3=fragCoord.xy + vec2(+0.375, -0.125);\n\tvec2 fc4=fragCoord.xy + vec2(+0.125, +0.375);\n    vec2 fc5=fragCoord.xy + vec2(-0.375, +0.125);\n    \n     vec2 scpos2=-1.0 +2.0*fc2.xy/iResolution.xy;\n     vec2 scpos3=-1.0 +2.0*fc3.xy/iResolution.xy;\n     vec2 scpos4=-1.0 +2.0*fc4.xy/iResolution.xy;\n     vec2 scpos5=-1.0 +2.0*fc5.xy/iResolution.xy;\n    \n    scpos2.x*=iResolution.x / iResolution.y;\n    scpos3.x*=iResolution.x / iResolution.y;\n    scpos4.x*=iResolution.x / iResolution.y;\n    scpos5.x*=iResolution.x / iResolution.y;\n    \n    \n  \n    fragColor=render(screenPos);\n    \n    \n#if oversample\n   fragColor+=render(scpos2)+render(scpos3)+render(scpos4);\n    fragColor/=4.;\n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}