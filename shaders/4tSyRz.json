{
    "Shader": {
        "info": {
            "date": "1507105595",
            "description": "quaternion Mouselook! (pitch yaw)\nArrow.Up-Down=accelerate\nArrow Left-Right=roll\n\nfork of\nhttps://www.shadertoy.com/view/lsd3Dl",
            "flags": 48,
            "hasliked": 0,
            "id": "4tSyRz",
            "likes": 35,
            "name": "Fly quaternion city",
            "published": 3,
            "tags": [
                "fractal",
                "collision",
                "quaternion",
                "airplane",
                "roll",
                "controls",
                "yaw",
                "pitch",
                "cloudsdale",
                "edynvr"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 2420
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 o, in vec2 u){\n o=texture(iChannel0,u/iResolution.xy, -100.0 );\n  //o+=mainImage2(o,u);\n}\n\n//everything is in BuffA!\n//it needs a buffer for camera position and rotation.",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\n#define steps 100\n#define maxdistance 4.0\n#define epsilon 0.003\n\n#define limit 3.0\n\n#define HASHSCALE3 vec3(.6531, .5563, .7498)\n\n#define dot2(p) dot(p,p)\n\n//hash function in hash without sine by Dave_Hoskins\n//https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z*15.3023+0.434);\n}\n\n#define checktree(k)                        \\\nfor (j = 0.0; j < k; j++) {             \\\n    vec3 h = floor(r*exp2(j))*exp2(-j); \\\n    float rand = hash13(h+exp2(-j-1.0));\\\n    if (rand >= 0.5) {                 \\\n        break;                          \\\n    }                                   \\\n}\n\nfloat squarering(vec3 p) {\n    vec2 q = vec2(abs(length(p.xy)-0.5),abs(p.z));\n    float len = length(max(q-0.1667,0.0))+min(max(q.x,q.y)-0.1667,0.0);\n    return len;\n}\n\nfloat truchet(vec3 p, int type) {\n    vec3 q = abs(p-0.5);\n\t\n    vec3 q2 = vec3(min(min(q.x,q.y),q.z),0,max(max(q.x,q.y),q.z));\n    q = min(q,q.yzx);\n    q2.y = max(max(q.x,q.y),q.z);\n\n    float inside = length(abs(q2.yz-vec2(0.0,0.5)))-0.1667;\n    float inside2 = length(max(abs(q2.yz-vec2(0.0,0.5)),0.0))-0.1667;\n    float outside = length(abs(q2.yz-vec2(0.5,0.5)))-0.3333;\n    \n    float len;\n    //len = min(len, squarering(p.xyz-vec3(0,0,0.5)));\n    //len = min(len, squarering(p.yzx-vec3(1,0,0.5)));\n    //len = min(len, squarering(p.zxy-vec3(1,1,0.5)));\n    if (type == 0) {\n        len = inside;\n    } else if (type == 1) {\n        //\n        len = -outside;\n    } else if (type == 2) {\n        len = inside2;\n    } else if (type == 3) {\n        len = squarering(p.xyz-vec3(0,0,0.5));\n        len = min(len, squarering(p.yzx-vec3(1,0,0.5)));\n        len = min(len, squarering(p.zxy-vec3(1,1,0.5)));\n    }\n    \n    \n    return len;\n}\n\nfloat mapOcreeeTruchet(vec3 p) {\n    \n    vec3 fp;\n    vec3 lp;\n    float len;\n    float i;\n    float size = 1.0;\n    \n    //r is the truchet cell you want the random \n    vec3 r = p;\n    float j;\n    checktree(limit);\n    i = j;\n    \n    //the position in the bottom left corner of the truchet cell\n    fp = floor(p*exp2(i))*exp2(-i);\n\n    //the local position on the truchet cell (always 0-1)\n    lp = fract(p*exp2(i));\n    \n    int type = int(hash13((fp+exp2(-i-1.0))*vec3(0.93,0.89,1.23))*4.0);\n    len = truchet(lp,type)*exp2(-i);\n    while (i <= limit) {\n        //the position in the bottom left corner of the truchet cell\n        fp = floor(p*exp2(i))*exp2(-i);\n        //the local position on the truchet cell (always 0-1)\n        lp = fract(p*exp2(i));\n        //check for the overlapping black dots\n        vec3 p2 = p*exp2(i);\n        vec3 fp2 = floor(p2-0.5);\n        for(int x = -0; x <= 1; x++) {\n            for(int y = -0; y <= 1; y++) {\n                for(int z = -0; z <= 1; z++) {\n                    r = (fp2+vec3(x,y,z))*exp2(-i);\n                    //this branch doesn't do anything, but it skips the random() once\n                    if (r != fp)\n                    {\n                        checktree(i);\n\n                        if (i==j) {\n                            vec3 q = abs(p2-fp2-vec3(x,y,z)-0.5);\n                            \n                            vec3 q2 = vec3(min(min(q.x,q.y),q.z),0,max(max(q.x,q.y),q.z));\n                            q = min(q,q.yzx);\n                            q2.y = max(max(q.x,q.y),q.z);\n                            \n                            float outside = length(abs(q2.yz-vec2(0.5,0.5)))-0.3333;\n                            \n                            len = max(-outside*exp2(-i),len);\n                        }\n                    }\n                }\n            }\n        }\n        size *= 0.5;\n        len *= -1.0;\n        i++;\n    }\n    //len *= size;\n    return len;\n    \n    /*vec3 q = abs(p-0.5);\n    \n    vec3 q2 = vec3(min(min(q.x,q.y),q.z),0,max(max(q.x,q.y),q.z));\n    q = min(q,q.yzx);\n    q2.y = max(max(q.x,q.y),q.z);\n    \n    float inside = length(abs(max(q2.yz-vec2(0.0,0.5),0.0)))-0.1667;\n    float outside = length(abs(q2.yz-vec2(0.5,0.5)))-0.3333;\n    \n    if (floor(p) == vec3(0)) {\n    \tlen = -outside;\n    } else {\n        len = inside;\n    }\n    return len;*/\n    //return outside;\n\n}\n\n\n/*\nself  : https://www.shadertoy.com/view/4tSyRz\n- single page, less duped code. trutural sorting \n- less globals, more object oriented.\n- more defines\n- larger render distance.\n- establishing [tiny namespace convention]\n- - mostly in scene()\n- - distance field is called gd() and gd1()for colors (resolves fractal G-buffer stuff?)\nparent: https://www.shadertoy.com/view/lsd3Dl\n  Rocket City by eiffie (although there are no rockets \n   and there is little if any esemblance to a city this is what eiffie called it)\n  eiffie just wanted to make a reusable flight control \n   but then messed that up with collision detection.\n*/\n\n\n\n//cut off half of the distance field along a plane that that the .y axis as its normal.\n#define cutY\n\n//epsilon  is a break condition for sphere tracking.\n//fractals need smaller eps, IEEE floats lose too much precision below .0000001\n//smaller eps result in slower fps and more convave areas.\n#define eps .00001\n//max number of raymarch spheretracking iterations, max number of gradient descents.\n#define iterRm 256\n\n\n//max view distance, far clipping sphere, centred around camera\n#define zFar 80.\n//to veil the horizon or not to veil the horizon, that is the asymptote.\n#define doFog\n\n//do shading. do calculus operations, sample derivatives of the gradient.\n#define doShade\n\n//ao on fractals is often odd, it can make things brighter.\n#define doAO\n\n//do specular light, fake reflectio of sunlight\n#define doSpec\n\n//max.iter fractal shapes, parent setting is 4. 5. is a bit \"brighter\"\n#define iterDfFractal 4.\n\n\n//does not have dynamiceps\n\n//does not have any code for reflections.\n\n\n//fractals need more iterShadAO at screenspace-edges (edge detecion)\n//, where normals are not pointing towards camera\n//Max.sample soft shadow \n#define iterAO 8.\n\n//now with autopilot, thanks Fabrice!\n//#define USE_AUTO_PILOT \n//looks like i broke it\n\n#define THRUST 0.02*iTimeDelta\n#define ROLL 1.0*iTimeDelta\n#define ROTATE 4.0*iTimeDelta\n//collision epsilon\n#define TOO_CLOSE 0.01\n//should scale with movement speed\n\n//controls (i may have swapped left and right here, do not overthing this one)\n#define LEFT_ARROW 39\n#define RIGHT_ARROW 37  \n#define UP_ARROW 38\n#define DOWN_ARROW 40\n\n#define sat(a) clamp(a,.0,1.)\n\n//load and save, originally from iq, modified\nfloat isInside(vec2 p,vec2 c){vec2 d=abs(p-.5-c)-.5;return -max(d.x,d.y);}\nvec4 load(int re){return texture(iChannel0,(.5+vec2(re,.0))/iChannelResolution[0].xy,-100.);}\nvoid store(in int re, in vec4 va, inout vec4 o, in vec2 u\n){if(isInside(u,vec2(re,0))>.0)o=va;}//o=(isInside(u,vec2(re,0))>.0)?va:o;}\n//bool KeyDown(in int key){return (texture(iChannel1,vec2((float(key)+0.5)/256.0, 0.25)).x>0.0);}\nfloat key(in int key){return texture(iChannel1,vec2((float(key)+0.5)/256.0, 0.25)).x;}\n\n\n//hash\nfloat h12(in vec2 p){\n return fract(float(iFrame)+sin(dot(p,vec2(13.3145,17.7391)))*317.7654321);}\n//quaterion math, just to be different\n\n//shape:\nvec3 Tile(vec3 p\n){\n ;vec3 a=vec3(8.0)\n ;//return p\n ;return abs(mod(p,a)-a*0.5)-a*0.25\n ;}\nfloat DERect(vec4 z,vec3 r){return length(max(abs(z.xyz)-r,0.0))/z.w;}\nconst float mr=0.5, mxr=0.975, scale = 2.52;\nconst vec3 rc=vec3(3.31,2.79,4.11),rcL=vec3(2.24,1.88,2.84);\nconst vec4 p0=vec4(4.0,0.0,-4.0,1.0);\n//colors\nconst vec3 sunDir=normalize(vec3(0.7,1.0,-0.7))\n,sunColor=vec3(1.0,0.99,.9)\n,skyColor=vec3(.25,.26,.27)\n//rainbow tinted cosmic microwave background, makes nice fog.\n;vec3 Backdrop(in vec3 rd){vec3 a= \n+skyColor\n+.05*(rd+sin(rd.yzx*5.+2.4*sin(rd.zxy*3.0)))\n+sunColor*(max(0.0,dot(rd,sunDir))*0.2+pow(max(0.0,dot(rd,sunDir)),256.));\n;return .7*a;}\n\n//return signed distane of[p] to a surface.\nfloat gd(vec3 u//gradient differential, signed distance field:\n){\n ;//u.z+=1.\n // #define DareOctree  //toggle\n ;vec3 p=u \n  #ifndef DareOctree\n ;p=Tile(p)\n  #endif\n ;vec4 z=vec4(p,1)\n ;float dG=1e3\n #ifdef DareOctree\n     //slow octree truchet (without octree traversal)\n;dG=mapOcreeeTruchet(u*.01)   //scale big to make navigable (woth collision detection scaling)\n     //https://www.shadertoy.com/view/MlcfRl\n #else    \n ;for(float n=.0;n<iterDfFractal;n++ //fractal\n ){z.xyz=clamp(z.xyz,-1.,1.)*2.-z.xyz\n  ;z*=scale/clamp(max(dot(z.xy,z.xy),max(dot(z.xz,z.xz),dot(z.yz,z.yz))),mr,mxr)\n  ;z+=p0\n  ;if(n==2.)dG=DERect(z,rcL)\n ;}\n #endif\n //;dG=min(dG,DERect(z,rc))\n #ifdef cutY\n //;dG=max(dG,u.y);\n #endif\n ;return dG;\n ;}\n\n\n//a variant of gd(), that is HERE used to get a color and tto derive a surface normal.\n//the inout vec4 mcol is a big difference.\nfloat gd1(vec3 p,inout vec4 mcol\n){p=Tile(p)\n ;vec4 z=vec4(p,1)\n ;float dG=1e3\n ;vec4 mc=vec4(0)\n ;for (float n=.0;n<5.;n++ //palette of 5 colors, i sync to abive fractal shape\n ){z.xyz=clamp(z.xyz, -1.0, 1.0) *2.0-z.xyz\n  ;z*=scale/clamp(max(dot(z.xy,z.xy),max(dot(z.xz,z.xz),dot(z.yz,z.yz))),mr,mxr)\n  ;z+=p0\n  ;if(n==3.)mc=vec4(vec3(.5,.3,.2)+z.xyz*.05,.25)\n  ;else if(n==2.)dG=DERect(z,rcL);\n }float ds=DERect(z,rc)\n ;if(dG<ds)mcol+=vec4(0.5,0.6,0.9,0.9)+vec4(z.xyz*0.025,0.0)\n ;else mcol+=mc\n ;return min(dG,ds);}\n\nvec3 fog(float ts,vec3 spc,vec3 fcol){\n //;float fog=min(pow(ts*.2,1.33)*.54,1.)//optimizd for zzFar=20.\n ;float fog=min(pow(ts*20./zFar*.2,1.33)*.54,1.)//optimizd for zzFar=20.\n //must be reciprocal log() ?\n ;return mix(spc,fcol,fog);}\n\nfloat AO(in vec3 o,in vec3 d,float s){//origin, direction, scatterHash\n ;float t=.0,a=1.,f,n=.01+.04*s\n ;for(float i=.0;i<iterAO;i++ \n ){f=max(gd(o+d*t)*1.5,n)\n  ;a=min(a,f/t+t*0.5)\n  ;t+=f;\n }return a;}//soft shadow with \"noisy lens\".\n\n\n//return occluded specular.\nvec3 SpecOcc(vec3 r,vec3 d,vec3 N,vec3 so,vec3 o,float s,vec4 mcol){\n;float l=dot(N,sunDir)//sundir must be normalized\n#ifdef doAO\n,shad=AO(so+N*.001,sunDir,s)//shadow\n#else\n,shad=.5\n#endif\n#ifdef doSpec\n;float v=dot(-d,N)\n;vec3 cc=vec3(.6,.8,1)//diffused light. sky color, shorter wavelengths diffuse more\n,lc=vec3(1,.8,.6)     //undiffused light, direct sun color, long wavelengths\n;float cd=exp(-distance(o,so))\n;vec3 R=reflect(d,N)\n;float spcl=pow(sat(dot(R,sunDir)),10.)\n,spcc=pow(max(.0,dot(R,-d)),1.+cd)*.25\n;r=r*(cd*v*cc+shad*l*lc)+(cd*spcc*cc+shad*spcl*lc)*mcol.a\n#endif\n;r=sat(r)\n;return r;}\n\n/*\n[o]RayOrigin\n[d]RayDirection\n[s]ScatterNoise\n[c]color, to be returned\n[f]FragmentSpaceScaling, to blur rasterization, against moire;a=smoothstep(s,-s,a);\n[t]TimeTraveled (implies division by speed of light) == distance to camera \n[g]gradient, signed distance to surface.\n[ao]Accumulate Occlusion, may just buffer the last step length\n[ps]PushSmallest; ps=(g<f*t &&g <ao && ts.w<.0);\n[ts]TimeSmallest    ,init: ts=vec4(-1 ), if(ps)store the 4 smallest [t>0] (abridged)\n[gs]gradientSmallest,init: gs=vec4(1e6), if(ps)store the 4 smallest abs(g)\n*/\nvec3 scene(vec3 o,vec3 d,float s){//origin,direction,scattering\n;float g=gd(o)*s*.5\n,t=g,ao=1.\n,f=2./min(iResolution.x,iResolution.y) //AntiAlias pixel size, of [2] pixels.\n;vec4 gs=vec4(1e6),ts=vec4(-1)//buffer 4 \"smallest values\"\n ;for(int i=0;i<iterRm;i++\n ){//start.raymarch\n ;g=gd(o+d*t)\n ;bool ps=all(lessThan(vec2(g,ts.w),vec2(min(f*t,ao),0)))\n       //=(g<min(f*t,ao)&&ts.w<.0);\n       //=(g<f*t&&g<ao&&ts.w<.0);\n ;if(ps //PushSmall, we remember 4*2 smallest values for AO.\n ){gs=vec4(abs(g),gs.xyz)\n  ;ts=vec4(t,ts.xyz);\n ;}\n ;t+=g\n ;ao=g\n ;if(t>zFar||g<eps)break;//raymarch loop break\n ;}//end__.raymarch loop \n ;if(g<f*t && g<gs.x){gs.x=g;ts.x=t;}//one last PushSmall\n ;vec3 c=Backdrop(d)\n     //;return c;\n ;vec3 fcol=c\n ;for(int i=0;i<4;i++ //some AA supersampling shit in here?\n ){//ts and ps values get processed for \"occlusion\"\n  //oh looks like this is just nearSurface() surface stuff.      \n  ;if(ts.x<.0)break\n  ;float px=f*ts.x\n  ;vec3 so=o+d*ts.x\n  ;vec4 mcol=vec4(.0)\n  #define g3(a) vec3(gd1(so+a.xyy,mcol),gd1(so+a.yxy,mcol),gd1(so+a.yyx,mcol))\n  ;vec3 ve=vec3(px,0,0)\n  ;vec3 dp=g3(ve),dn=g3(-ve)//positive normal//negative normal\n  ;float d1=gd1(so,mcol)\n  ;vec3 N=(dp-dn)/(length(dp-vec3(d1))+length(vec3(d1)-dn))//HNF, normalized surface normal.\n  //above begs to be inversesqrt?\n  ;vec3 spc=mcol.rgb*0.14//specular set to material\n  #ifdef doShade\n  ;spc=SpecOcc(spc,d,N,so,o,s,mcol)\n  #endif\n        //near distance can skip fog.\n  #ifdef doFog\n  ;spc=fog(ts.x,spc,fcol);\n  #else \n  //;spc=fog(ts.x,spc,fcol);\n  #endif  \n  ;c=mix(spc,c,sat(gs.x/px))\n  ;gs=gs.yzwx;ts=ts.yzwx//rotate sampling matrix\n ;}\n//;if(c!=c)c=vec3(1,0,0);//if(NaN)\n;return sat(c*2.)\n;}\n\n\nvec4 mainImage2(out vec4 fragColor, in vec2 fragCoord){\n vec3 t=normalize(vec3((2.0*fragCoord-iResolution.xy)/iResolution.y,1.0));\n vec3 o=load(0).xyz;\n vec4 fw=(load(1));\n t=qv2v(fw,t);\n //ro=eye;rd=normalize(dir);\n float s=h12(fragCoord);\n return vec4(scene(o,t,s),1.0);\n}\n\n\nvoid steer( out vec4 o, in vec2 u\n){vec4 p,qrot\n ;if(iFrame<2){//init\n ;p=vec4(.1,0,0,.01)\n ;qrot=normalize(vec4(.1,.2,.3,.8));\n }else{//next frame\n  ;p=load(0);qrot=load(1)//load state from previous frame\n  ;vec3 fw=vec3(0,0,1)\n  ;fw=qv2v(qrot,fw) //can be done simpler (take apart qmulv() and maybe skip one qinv() )\n  ;vec3 newp=p.xyz+fw*p.w*.2\n  ;if(gd(newp)>TOO_CLOSE)p.xyz=newp\n  ;else{\n   ;if(gd(vec3(p.xy,newp.z))>TOO_CLOSE)p.z=newp.z;\n   ;if(gd(vec3(p.x,newp.y,p.z))>TOO_CLOSE)p.y=newp.y;\n   ;if(gd(vec3(newp.x,p.yz))>TOO_CLOSE)p.x=newp.x;//mkay every domain checked intependently\n  ;}\n ;p.w+=THRUST*(key(UP_ARROW)-key(DOWN_ARROW));\n ;float roll=ROLL*(key(RIGHT_ARROW)-key(LEFT_ARROW));\n ;vec2 m=vec2(0)\n ;if(iMouse.z>.0\n ){\n  ;vec2 n=iMouse.xy-abs(iMouse.zw)\n  ;n.x=-n.x\n  ;m.xy-=(n)/iResolution.xy\n ;}\n #ifdef USE_AUTO_PILOT\n else{//I'm pretty sure this is how google cars steer\n  ;float d=gd(p.xyz)\n  ;newp=qmulv(qrot,vec3(d,0,0))\n  ;float d2=gd(p.xyz+newp)\n  ;m.x=sign(d2-d)*ROTATE/(.1+2.*d*d)\n ;}\n #endif\n ;vec4 qp=eYPR2q(vec3(roll,m.xy*ROTATE))\n ;qrot=normalize(qq2q(qrot,qp))//normalize before saving\n;}\n;store(0,p,o,u)//position,velocity\n;store(1,qrot,o,u)//rotation\n;}\n\nvoid mainImage(out vec4 o,vec2 u){\n;if(all(lessThan(u,vec2(2.5,1.5))))steer(o,u)\n;else o=mainImage2(o,u); \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define dd(a) dot(a,a)\n#define pi acos(-1.)\n\n//return smallest angle between 2 vectors\nfloat AngleBetween(vec3 a,vec3 b){;return acos(dot(a,b)/length(a)/length(b));}\n\n//--- quaternionRotation math (updated 2021-Jan-7) //https://www.shadertoy.com/view/4tSyRz\n//\n//ANY rotations in 3d are non-commutative!\n//\n//matrix rotations are just bulky, memory wasting\n//EulerRotations almost certainly fail to rotate over the SHORTEST path.\n//EulerRotations almost certainly will gimbalLock and get stuck along one axis\n//QuaternionRotations are superior here.\n//-> we only use EulerRorations for simple input devices (keyboard input)\n//-> we convert to quaternions, buffered as vec4.\nvec4 qid(){return vec4(0,0,0,1);}//quaternion Identity\n//\n//---quaternion & AxisAngle (==quaternion multiplication)\n//\n//return quaternion from Axis[a] and Angle[r]\nvec4 aa2q(vec3 a,float r){vec2 g=vec2(sin(r),cos(r))*.5;return normalize(vec4(a*g.x,g.y));}\n//return AxisAngle of NORMALIZED quaternion input\nvec4 q2aa(vec4 q){return vec4(q.xyz/sqrt(1.0-q.w*q.w),acos(q.w)*2.);}//assumed q is normalized coverts to axis&angle\n//return q2, rotated by q1, order matters (is non commutative) : (aka quaternion multiplication == AxisAngleRotation)\nvec4 qq2q(vec4 q1, vec4 q2){return vec4(q1.xyz*q2.w+q2.xyz*q1.w+cross(q1.xyz,q2.xyz),(q1.w*q2.w)-dot(q1.xyz,q2.xyz));}\n//extension to qq2q(), scaled by sensitivity [f] (==quaternion ANGULAR equivalent to slerp() )\nvec4 qq2qLerp(vec4 a, vec4 b, float f\n){float d=dot(a,b),t=acos(abs(d)),o=(1./sin(t));return normalize(a*sin(t*(1.0-f))*o*sign(d)+b*sin(t*f)*o);}\n//doing qq2q() multiple times, you need to normalize() the quaternion, to fix rounding errors.\n//how often you do this is up to you.\n//normalize q (assuming length(q) is already close to 1, we can skip whe sqrt()\nvec4 qn(vec4 q){return q/dd(q);}//return normalize(q);}\n//\n// quaternion & vectors\n//\n//return quaternion, that is the shortest rotation, between looking to [a before], and looking to [b after] the rotation.\nvec4 qBetween(vec3 a,vec3 b// http://wiki.secondlife.com/wiki/LlRotBetween\n){float v=sqrt(dd(a)*dd(b));if(v==0.)return qid();v=dot(a,b)/v\n ;vec3 c=a.yzx*b.zxy-a.zxy*b.yzx/v;float d=dd(c)\n ;if(d!=0.){float s=(v>-0.707107) ? 1.+v : d/(1.+sqrt(1.-d));return vec4(c,s)/sqrt(d+s*s);}\n ;if(v>0.)return qid()\n ;float m=length(a.xy);return (m!=0.) ? vec4(a.y,-a.x,0,0)/m : vec4(1,0,0,0);\n ;}//Written by Moon Metty, optimized by Strife Onizuka (faster version, without trigonometry)\nvec4 qBetween2(vec3 a,vec3 b){if(a==b)return qid();return aa2q(cross(a,b),AngleBetween(a,b));}//less code, but has some slower or less precise cases.\n//return inverse of quaternion\nvec4 qinv(vec4 q){return vec4(-q.xyz,q.w)/dd(q);}\n//return VECTOR p, rotated by quaterion q;\nvec3 qv2v(vec4 q,vec3 p){return qq2q(q,qq2q(vec4(p,.0),qinv(q))).xyz;}\n//qv2v()  with swapped inputs\n//return quaterion P (as vector), as if it i rotated by VECTOR p (asif it is a quaternion)\n//vec3 vq2v(vec3 p,vec4 q){return qq2q(qinv(q),qq2q(vec4(p,0.0),q)).xyz;}\n//vec3 vq2v(vec4 a,vec3 b){return qv2v(a,b);}//in case of namespace confuction\n//vec3 qv2v(vec3 a,vec4 b){return vq2v(a,b);}//in case of namespace confuction\n//\n//---quaternion & matrix (second to last in list, because they are bulky)\n//\n//return mat3 of [q]uaternion (rotation matrix without translation)\nmat3 q2m(vec4 q //https://www.shadertoy.com/view/WsGfWm\n){vec3 a=vec3(-1,1,1);mat3 m=mat3(.5)+mat3(0,q.zyz*a,0,q.xyx*a.xxy,0)*q.w\n +matrixCompMult(outerProduct(q.xyz,q.xyz),1.-mat3(1))//3 unnecessary multy by 0.\n ;q*=q//<-everythig except the main diagonal\n ;m-=mat3(q.y+q.z,0,0,0,q.x+q.z,0,0,0,q.x+q.y)//<- only the main diagonal\n ;return m*2.;}//this *2 scalar may not need to be internal\n//return q2m() as mat4, with [t]ranslation\nmat4 q2m(vec4 q,vec3 t //studying https://www.shadertoy.com/view/WsGfWm\n){mat3 m=q2m(q);return mat4(m[0],0,m[1],0,m[2],0,t,0);}//*=2,and add tranlation\n//return rotation matrix sub of mat4\nmat3 m42Rot(mat4 a){return mat3(a[0].xyz,a[1].xyz,a[2].xyz);}\n#define m2f(a,b) m[a][b]-m[b][a]\nvec4 m2q(mat3 m//return quaternion of orthogonal matrix (with determinant==1., or else quaternionm will not be normalized)\n){float q=2.*sqrt(abs(1.+m[0][0]+m[1][1]+m[2][2]))//http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n ;return vec4(vec3(m2f(2,1),m2f(0,1),m2f(1,0))/q/4.,q);}\n//\n//---quaternion+ EulerRot (last in list, because they are the worst)\n//\n//eulerRot2Quaternion and back \n//- not elegant, not fast\n//- and theres 6 arbitiary, incompatible and non commutative permutatuions of [yaw opitch roll] order\n//BUT, your keyboard inputs are most likely Euler-rotations, so we have to chose one:\n//wikipedia does (jaw pitch roll) order: of a plane taking of;\n//; (jaw)   first    steers like a car\n//, (pitch) secondly the nose pulls up\n//, (roll)  lastly   and in the air to roll\n//\n//above function is used here, but it lacks an inverse, unlike below other order:\n//\nfloat at2e(vec2 a){a*=2.;return atan(a.x,1.-a.y);}\n//return quaternion of Euler[yaw,pitch,roll]     //this one needs to be phased out\nvec4 eYPR2q(vec3 o){o*=.5;vec3 s=sin(o);o=cos(o)\n//https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles#Source_code\n ;vec4 a=vec4(s.xz,o.xz);return  a.yyww*a.zxxz*o.y+a.wwyy*a.xzzx*s.y*vec4(-1,1,-1,1);}\n//return Euler[yaw,pitch,roll]  of quaternion \nvec3 q2eYPR(vec4 q){vec3 r=vec3(0,2.*(q.w*q.y-q.z*q.x),0)\n ;return vec3(at2e(vec2(dot(q.wx,q.zy),dd(q.yz)))          //yaw   (z-axis rotation)\n             //at2e(vec2(q.w*q.z+q.x*q.y,q.y*q.y+q.z*q.z)) //yaw   (z-axis rotation)\n              ,(abs(r.y)>=1.)?r.y=sign(r.y)*pi*.5:asin(r.y)//pitch (y-axis rotation) (worksaved asin())\n              ,at2e(vec2(dot(q.wy,q.xz),dd(q.xy))))        //roll  (x-axis rotation)\n            //,at2e(vec2(q.w*q.x+q.y*q.z,q.x*q.x+q.y*q.y)))//roll  (x-axis rotation)\n ;}//<-untested function\n/*\n//these EulerOrders are being phased out:\n//return quaternion of Euler [pitch, yaw, roll]  //this one needs to be phased out\nvec4 ePYR2q(vec3 o){//return eYPR2q(o.zyx)\n;o*=.5;vec3 s=sin(o);o=cos(o);vec4 a=vec4(s.xy,o.xy)//https://www.shadertoy.com/view/4tSyRz\n ;return a.xyxz*a.wzyw*o.z+a.yxzx*a.zwwy*s.z*vec4(1,-1,1,-1);}\n//return quaternion of EulerRotation [around axes in (Z,Y,X)==(roll,pitch,yaw) order]\nvec4 eRPY2q(vec3 c){c*=.5;vec3 s=sin(c);c=cos(c)//http://wiki.secondlife.com/wiki/LlEuler2Rot\n ;return qq2q(qq2q(vec4(0,0,s.z,c.z),vec4(0,s.y,0,c.y)),vec4(s.x,0,0,c.x));}\n/**/\n//---end__ quaternion\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}