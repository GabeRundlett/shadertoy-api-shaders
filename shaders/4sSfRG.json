{
    "Shader": {
        "info": {
            "date": "1500792326",
            "description": "Here it is, 3D life with customizable rules and pattern editing. See comments for usage documentation. \n(revised from XsjfWW)\n\nHave fun!",
            "flags": 49,
            "hasliked": 0,
            "id": "4sSfRG",
            "likes": 9,
            "name": "3D Life Automata",
            "published": 3,
            "tags": [
                "voxels",
                "cellular",
                "cells",
                "conway",
                "explorer",
                "gameoflife",
                "cgol",
                "polycubes"
            ],
            "usePreview": 0,
            "username": "bch",
            "viewed": 1320
        },
        "renderpass": [
            {
                "code": "// Created by bch (Blake H.)  June/July 2017\n\n// Voxel architecture and rendering based on code created by inigo quilez - iq/2013\n// iq's functions used essentially unchanged include:\n// noise(),texcube(), map(), castRay(), setCamera(), maxComp(), isEdge(), calcOcc()\n// (see original shader, \"Voxel Edges\" at https://www.shadertoy.com/view/4dfGzs\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// iq's shading technique explained here:\n//\n// https://iquilezles.org/articles/voxellines\n\n// Some basic architecture for Life (2d) was lifted from chronos'\n// \"Introduction to Life\" https://www.shadertoy.com/view/MtdXRn\n\n// Thanks so much to everyone whose code I used!\n\n// ********************DOCUMENTATION********************************\n// Use mouse to view patterns from any side. \n// Use the VIEW define to control how large a pattern you can see, and how fast\n// the display will be. \n\n// If you don't see anything at first, click |> to stop and click |<| button to reset.\n\n// Press and hold RETURN to temporarily stop generations.\n// Hold down RETURN while moving around with the mouse to prevent generations\n// Press and hold SHIFT to change shading to black and white -- if you click focus\n// over to the code window this will stick until you click back.\n// Press SPACE to reset mapping/start over from generation zero.\n\n// NOTE that if you change the resolution (image size), you will need to \n// click the |<| button or press SPACE to reset the mapping and start over from\n// generation zero.\n\n// There are several demo patterns #defined at the front of Buffer A.\n// If you choose demo pattern 5 you will be in a mode where you can draw your\n// own 3D starting pattern. You will be presented with a dark blue cursor cube.\n// Move it around with arrow keys (X,Y axes) and pgup/pgdn (Z axis). The cursor position\n// is visible when the cursor overlaps an existing cube, unless it is hidden below \n// a pattern's 3D surface.\n\n// To plot a cube -- + (plus); to unplot a cube -- - (minus)\n// You can also add or subtract cubes after generations have occurred; when you \n// press RETURN or stop time to pause, the cursor cube will appear. You will need to hold\n// down RETURN when adding cubes with + or - to an active pattern, or they won't add (even\n// if you have stopped time). This is so a pattern won't run away before you finish\n// modifying it.\n\n// Rules are #defined in Buffer A in the CheckRules function. The defaults are pretty,\n// but mostly cause unrestricted growth, so they're not terribly interesting. I \n// encourage you to search for more interesting rules. I had to use a kludge to\n// allow non-contiguousrule sets (e.g., live with 4, 5, 8, 9, or 15 neighbors), \n// because WebGL 1 supports arrays poorly. I don't have a browser\n// on my Mac that supports WebGL 2. (Anyone know of one?)\n\n// Technical notes: \n// the maximum number of cells handled by the engine depends on the\n// window resolution, from a 32 x 32 x 32 cube at icon resolution up to a possible \n// 112 x 112 x 112 at full screen. Outside that limit the cells will \"wrap around\".\n// Since the full-screen buffer handles over a million cells, it is a good deal slower\n// than the smaller versions. If you want to run this shader full-screen and would like\n// it to go faster, you can adjust the resolution values in SetMapping() so that a smaller\n// mapping // will be used even if the resolution is higher. Note that any changes to\n// SetMapping() must be made in image and in Buf A. Don't change the mapping values \n// themselves! The cube of the mapping z value must not exceed the number of pixels\n// available in the window.\n\n// The CLIP_NEAR option allows the voxels nearest the camera to be ignored. Most of the\n// views are set up to allow viewing of the \"interesting\" regions without wasting a \n// lot of voxel tracing on empty space. This means that some close geometry is clipped,\n// but often that geometry would be in the way anyway. Note that if you turn on \n// MIRROR_NEIGHBORHOOD without CLIP_NEAR you won't see much mirroring; this is \n// because the renderer runs out of voxels. You can fiddle with CLIP_VALUE if you \n// want to fine-tune clipping.\n\n#define SHOW_BUFFER 0\n#define MIRROR_NEIGHBORHOOD 0\n\n#define SHOW_EDGES 1\n#define CLIP_NEAR 1\n#define CLIP_VALUE .7\n#define RETURN_KEY 13\n\n// lower view numbers are closer and use fewer voxels, so they're faster.  \n#define VIEW 3\n\n\n#if VIEW == 0\n\t#define VOXEL_DEPTH 40\n\t#define LENS -4.5\n\t#define DIST_FROM_ORIGIN -20.\n#endif\n#if VIEW == 1\n\t#define VOXEL_DEPTH 64\n\t#define LENS -5.5\n\t#define DIST_FROM_ORIGIN -40.\n#endif\n#if VIEW == 2\n\t#define VOXEL_DEPTH 128\n\t#define LENS -8.5\n\t#define DIST_FROM_ORIGIN -120.\n#endif\n#if VIEW == 3\n\t#define VOXEL_DEPTH 256\n\t#define LENS -8.5\n\t#define DIST_FROM_ORIGIN -180.\t\n#endif\n#if VIEW == 4\n\t#define VOXEL_DEPTH 240\n\t#define LENS -3.5\n\t#define DIST_FROM_ORIGIN -180.\t\n#endif\n\n#define WRAP_SIZE 48.\n// we need this because of nasty FP divide errors...\n#define FP_SLOP .001\n\n\nvec2 gTWOD_ORIGIN; // inited in setMapping, default = vec2(840, 520);\nvec3 gMapping; //     inited in setMapping, default = vec3(15.,8.,112.);\n\nvec3 globalPosition = vec3(24.,24.,24);\nvec3 globalTestColor;\nint gCursorState;\n\n\nbool keyPressed(int keyCode) {\n\treturn bool(texture(iChannel3, vec2((float(keyCode) + 0.5) / 256., .5/3.)).r);   \n}\n\nvec3 ChangingColor(in vec3 p)\n{\n\n\treturn clamp(abs(mod(iTime + fract(p.x/3.) + fract(p.y/3.) + fract(p.z/3.) + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n}\n\nvoid setMapping(float res)\n{\n    gMapping = vec3(15.,8.,112.);\n\tgTWOD_ORIGIN = vec2 (840.,520.); \n    \n    if (res <= 800.)\n    \t{\n        gMapping = vec3(12.,6.,66.);\n        gTWOD_ORIGIN = vec2 (396.,222.);    \n        }\n    if (res <= 640.)\n    \t{\n        gMapping = vec3(10.,6.,60.);\n        gTWOD_ORIGIN = vec2 (320.,180.);\n        }\n    if (res <= 512.) \n    \t{\n        gMapping = vec3(10.,5.,50.);\n        gTWOD_ORIGIN = vec2 (250.,140.);\n        }\n    if (res <= 288. )    // \"icon\" preview size, hopefully never smaller...\n\t\t{\n        gMapping = vec3(9.,4.,32.);\n        gTWOD_ORIGIN = vec2 (144.,80.);\n        }\n    return;\n}\n\n// regular mod function is buggy and unreliable\nfloat myMod(float val, float m)\n{\n    int v = int(val);\n    \n    int mi = int(m);\n    if (v < 0)\n        v += 1000 * mi;\n    int q = v/mi;\n    \n    return float(v - mi*q);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel1, (uv+0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\n{\n    vec3 m = abs( n );\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n    return x*m.x + y*m.y + z*m.z;\n}\n\n\nvec2 v3tov2(ivec3 v3)\n{\n    \n    vec3 m = gMapping;\n    vec2 o = gTWOD_ORIGIN;\n    \n    vec3 v3f = vec3(float(v3.x),float(v3.y),float(v3.z));\n    #if !MIRROR_NEIGHBORHOOD\n    if (clamp(v3f,vec3(-(m.z/2.)),vec3((m.z/2.)-1.)) != v3f) // out of range\n        return vec2(9999.,9999.);\n    #endif\n    {\n        float w = m.z;\n        \n        vec3 v = vec3(mod(v3f.x+w/2.,w),  // ranges from 0 to w\n                      mod(v3f.y+w/2.,w),\t// ranges from 0 to w\n                      mod(v3f.z+w/2.,w)); // ranges from 0 to w\n       \n        // Suppose w is 60, cellwidth is 10, cellheight is 6\n        // the x component is (0 to 59) * 10 + z mod 10\n        // or (0 to 590 step 10) + 0 to 9 \n        float xComponent = floor(v.x * m.x + myMod(v.z, m.x)+FP_SLOP);\n        \n        // The y component is (0 to 59) * 6 + floor(z/10)\n        // or (0 to 354 step 6) + 0 through 5\n        float yComponent = floor(v.y*m.y + floor(v.z/m.x+FP_SLOP)+FP_SLOP);\n\n        vec2 widthOfHalfValidAxis = m.xy * (m.z/2.);\n        \n        vec2 result = vec2(xComponent,yComponent) + o - vec2((m.z/2.)*m.x,(m.z/2.)*m.y);\n        return result;\n    }\n\n}\n\n\n\nfloat mapTerrain( vec3 p )\n{\n    gCursorState = 0;\n    \n    #if MIRROR_NEIGHBORHOOD\n    ivec3 ip = ivec3(\n        int(floor(mod(p.x+gMapping.z/2., gMapping.z)-gMapping.z/2.)),\n        int(floor(mod(p.y+gMapping.z/2., gMapping.z)-gMapping.z/2.)),\n        int(floor(mod(p.z+gMapping.z/2., gMapping.z)-gMapping.z/2.)));\n    #else\n    \n    ivec3 ip = ivec3(int(floor(p.x)),int(floor(p.y)),int(floor(p.z)));\n    \n    #endif\n    \n    vec3 t = vec3(0.);\n    \n\tglobalPosition = p;\n    \n\tfloat f;\n    \n    vec2 pix = v3tov2(ip);\n\n    \tt = texture(iChannel0,(pix+.5)/iResolution.xy).rgb;\n    \n    \n    if (t.b == 0.8)\n        {\n        if (t.r == 1.)\n            gCursorState = 1;\n        t.r = 1.;\n        gCursorState += 1;\n        }\n   \n    return 1.-t.r;\n}\n\nfloat map(in vec3 c) \n{\n    vec3 p = c + 0.5;\n\t\n\tfloat f = mapTerrain(p);\n\treturn step( f, 0.5 );\n}\n\nvec3 lig = normalize( vec3(-.2,1.6,.4) );\n\nfloat castRay( in vec3 ro, in vec3 rd, out vec3 oVos, out vec3 oDir )\n{\n\tvec3 pos;\n    \n    #if CLIP_NEAR\t\n    if (-DIST_FROM_ORIGIN > gMapping.z/2.)\n        pos  = floor(ro + rd*(-DIST_FROM_ORIGIN - gMapping.z/2.)*CLIP_VALUE);\n    else\n    #endif\n        pos = floor(ro);\n\tvec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd);\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\n\t\n\tfloat res = -1.;\n\tvec3 mm = vec3(0.0);\n\tfor( int i=0; i<VOXEL_DEPTH; i++ ) \n\t{\n\t\tif( map(pos)>0.5 ) { res=1.0; break; }\n\t\tmm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n\t\t\n            \n        dis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n\n\tvec3 nor = -mm*rs;\n\tvec3 vos = pos;\n\t\n    // intersect the cube\t\n\tvec3 mini = (pos-ro + 0.5 - 0.5*rs)*ri;\n\tfloat t = max ( mini.x, max ( mini.y, mini.z ) );\n\t\n \toDir = mm;\n\toVos = vos;\n\n\treturn t*res;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nfloat maxcomp( in vec4 v )\n{\n    return max( max(v.x,v.y), max(v.z,v.w) );\n}\n\nfloat isEdge( in vec2 uv, vec4 va, vec4 vb, vec4 vc, vec4 vd )\n{\n    vec2 st = 1. - uv;\n\n    // edges\n    vec4 wb = smoothstep( 0.85, 0.99, vec4(uv.x,\n                                           st.x,\n                                           uv.y,\n                                           st.y) ) * ( .7- va + va*vc );\n    // corners\n    vec4 wc = smoothstep( 0.85, 0.99, vec4(uv.x*uv.y,\n                                           st.x*uv.y,\n                                           st.x*st.y,\n                                           uv.x*st.y) ) * ( .8- vb + vd*vb );\n    return maxcomp( max(wb,wc) );\n}\n\nfloat calcOcc( in vec2 uv, vec4 va, vec4 vb, vec4 vc, vec4 vd )\n{\n    vec2 st = 1.0 - uv;\n\n    // edges\n    vec4 wa = vec4( uv.x, st.x, uv.y, st.y ) * vc;\n\n    // corners\n    vec4 wb = vec4(uv.x*uv.y,\n                   st.x*uv.y,\n                   st.x*st.y,\n                   uv.x*st.y)*vd*(1.0-vc.xzyw)*(1.0-vc.zywx);\n    \n    return wa.x + wa.y + wa.z + wa.w +\n           wb.x + wb.y + wb.z + wb.w;\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3(0.0);\t\n    \n    // raymarch\t\n\tvec3 vos, dir;\n\t\n    // sets gTWOD_ORIGIN and gMapping\n    setMapping(iResolution.x);\n    \n    float t = castRay( ro, rd, vos, dir );\n\tif( t>0.0 )\n\t{\n        vec3 pos = ro + rd*t;\n        vec3 nor = -dir*sign(rd);\n        \n        vec3 uvw = pos - vos;\n\t\t\n\t\tvec3 v1  = vos + nor + dir.yzx;\n\t    vec3 v2  = vos + nor - dir.yzx;\n\t    vec3 v3  = vos + nor + dir.zxy;\n\t    vec3 v4  = vos + nor - dir.zxy;\n\t\tvec3 v5  = vos + nor + dir.yzx + dir.zxy;\n        vec3 v6  = vos + nor - dir.yzx + dir.zxy;\n\t    vec3 v7  = vos + nor - dir.yzx - dir.zxy;\n\t    vec3 v8  = vos + nor + dir.yzx - dir.zxy;\n\t    vec3 v9  = vos + dir.yzx;\n\t    vec3 v10 = vos - dir.yzx;\n\t    vec3 v11 = vos + dir.zxy;\n\t    vec3 v12 = vos - dir.zxy;\n \t    vec3 v13 = vos + dir.yzx + dir.zxy; \n\t    vec3 v14 = vos - dir.yzx + dir.zxy ;\n\t    vec3 v15 = vos - dir.yzx - dir.zxy;\n\t    vec3 v16 = vos + dir.yzx - dir.zxy;\n    \n\t\tvec4 vc = vec4( map(v1),  map(v2),  map(v3),  map(v4)  );\n\t    vec4 vd = vec4( map(v5),  map(v6),  map(v7),  map(v8)  );\n\t    vec4 va = vec4( map(v9),  map(v10), map(v11), map(v12) );\n\t    vec4 vb = vec4( map(v13), map(v14), map(v15), map(v16) );\n\t\t\n\t\tvec2 uv = vec2( dot(dir.yzx, uvw), dot(dir.zxy, uvw) );\n        \n        \n        // wireframe\n        float www = 1.0 - isEdge( uv, va, vb, vc, vd );\n        \n        vec3 wir = smoothstep( 0.4, 0.5, abs(uvw-0.5) );\n        float vvv = (1.0-wir.x*wir.y)*(1.0-wir.x*wir.z)*(1.0-wir.y*wir.z);\n\n        nor += .2*length(texcube( iChannel2,.02*pos, nor).xyz);\n        nor += .5*texcube( iChannel2,.02*pos,nor ).zyx;\n        col = .25+texcube( iChannel1, 0.01*pos, nor).xyz;\n        \n        col += 1.4*vec3(0.1,0.3,0.4);\n        col *= 0.5 + .25*texcube( iChannel2, 0.5*pos, nor ).x;\n        col *= 1.5 - 0.45*(1.0-vvv)*www;\n\t\t\n\n\n        // lighting\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(lig*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );\n        float sky = 0.5 + 0.5*nor.y;\n        float amb = clamp(0.75 + pos.y/25.0,0.3,1.0);\n        float occ = 1.0;\n\t\n        // ambient occlusion\n        occ = calcOcc( uv, va, vb, vc, vd );\n        occ = 1.0 - occ/8.0;\n        occ = occ*occ;\n        occ = occ*occ;\n        occ *= amb;\n\n        // lighting\n        vec3 lin = vec3(0.0);\n        lin += 2.5*dif*vec3(1.00,0.90,0.70)*(0.5+0.5*occ);\n        lin += 0.5*bac*vec3(0.15,0.10,0.10)*occ;\n        lin += 2.0*sky*vec3(0.40,0.30,0.15)*occ;\n     \n        #if SHOW_EDGES\n        // line glow\t\n        float lineglow = 0.0;\n        lineglow += smoothstep( 0.6, 1.0,     uv.x )*(1.0-va.x*(1.0-vc.x));\n        lineglow += smoothstep( 0.6, 1.0, 1.0-uv.x )*(1.0-va.y*(1.0-vc.y));\n        lineglow += smoothstep( 0.6, 1.0,     uv.y )*(1.0-va.z*(1.0-vc.z));\n        lineglow += smoothstep( 0.6, 1.0, 1.0-uv.y )*(1.0-va.w*(1.0-vc.w));\n        lineglow += smoothstep( 0.6, 1.0,      uv.y*      uv.x )*(1.0-vb.x*(1.0-vd.x));\n        lineglow += smoothstep( 0.6, 1.0,      uv.y* (1.0-uv.x))*(1.0-vb.y*(1.0-vd.y));\n        lineglow += smoothstep( 0.6, 1.0, (1.0-uv.y)*(1.0-uv.x))*(1.0-vb.z*(1.0-vd.z));\n        lineglow += smoothstep( 0.6, 1.0, (1.0-uv.y)*     uv.x )*(1.0-vb.w*(1.0-vd.w));\n\t\t\n        vec3 linCol = 2.0*ChangingColor(globalPosition);\n               \n        linCol *= (0.5+0.5*occ)*0.5;\n        lin += 3.0*lineglow*linCol;\n\n        // black & white shading\t\t\n        vec3 col2 = vec3(1.3)*(0.2+0.8*dot(nor,lig))*occ*(0.6+0.1*vvv)*exp( -0.03*(t+(DIST_FROM_ORIGIN / 1.5)) );;\n        col2 += vec3(1.*(1.0-www)*(dot(nor,lig)/4.+.2) *occ) ;\n        \n        // Handle cursor display for free-form input\n        if (iTime == 0. || keyPressed(RETURN_KEY))\n        {\n            vec3 posmod = mod(pos,2.);\n            vec3 posrem = pos-posmod;\n            vec3 posplus = floor((posmod + .05)/1.02);\n            vec3 posminus = floor((posmod - .05)/1.02);\n\n\n\n            ivec3 ipos1 = ivec3(int(posrem.x+posplus.x),\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n                               int(posrem.y+posplus.y),\n                               int(posrem.z+posplus.z));\n            ivec3 ipos2 = ivec3(int(posrem.x+posminus.x),\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n                               int(posrem.y+posminus.y),\n                               int(posrem.z+posminus.z));\n\n\n            vec2 pix1 = v3tov2(ipos1);\n            vec2 pix2 = v3tov2(ipos2);\n\n            vec3 tt1 = texture(iChannel0,(pix1+.5)/iResolution.xy).rgb;\n            vec3 tt2 = texture(iChannel0,(pix2+.5)/iResolution.xy).rgb;\n\n            int cursorState = 0;\n\n            if (tt1.b == 0.8 || tt2.b == 0.8)\n                {\n                if (tt1.r == 1. || tt2.r == 1.)\n                    cursorState = 1;\n                cursorState += 1;\n                }\n\n            if (cursorState == 1)\n            \t{\n                col *= vec3(0.,.1,1.) * fract(pos.x)*fract(pos.x);\n            \tcol2 /=5.;\n                }\n            if (cursorState == 2)\n                {\n                    col *= vec3(.3,.3,1.3);\n                col2 /= 2.;\n                }\n        }\n        \n        col = col*lin;\n        col += 4.0*linCol*vec3(1.0,2.0,3.0)*(1.0-www);\n        col += 0.1*lineglow*linCol;\n        #endif\n        \n        col *= min(0.1,exp( -0.035*(t+(DIST_FROM_ORIGIN / 2.)) ));\n        \n      \n            \n        if (keyPressed(16))\n        \tcol = col2;\n        \n\t}\n\n\t// gamma\t\n\tcol = pow( col, vec3(0.65) );\n\n    return col;\n}\n\n// fabrice's icon message...\n/*float message(vec2 p) {  \n    int x = int(p.x+1.)-1, y=int(p.y)-10,  i;\n    if (x<1||x>32||y<0||y>2) return -1.; \n    i = ( y==2? i=  757737252: y==1? i= 1869043565: y==0? 623593060: 0 )/ int(exp2(float(32-x)));\n \treturn i==2*(i/2) ? 1. : 0.;\n}*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //display icon message\n    //if (iResolution.x == 288.) { \n    //    float c=message(fragCoord.xy/8.); if(c>=0.){ fragColor=vec4(c);return; } }\n    \n    //globalTestColor = vec3(0.);\n    #if !SHOW_BUFFER\n    // inputs\t\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    \n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/ iResolution.y;\n\t\n    vec2 mo=vec2(.06,-.10);\n\n    if( iMouse.w<=0.00001 && iMouse.xy == vec2(0.))\n        mo=vec2(.06,-.10);\n    else\n    \tmo = iMouse.xy / iResolution.xy -vec2(-.5,.5);  // mo goes from -.5 to .5\n    mo.y = -mo.y;\n    \n\tfloat time = .001*iTime + 1. * mo.x;\n    // camera\n\t\n    /*\n\t adapted from TEKF's wonderful polar camera. (https://www.shadertoy.com/view/XdsGDB)\n\t*/\n    vec2 m = mo.yx * vec2(3.14,6.28); // Movement scaling.\n    vec2 c = cos(m);\n\tvec4 s;\n\ts.xy = sin(m);\n\ts.zw = -s.xy;\n    vec3 ro = vec3(0.,0.,DIST_FROM_ORIGIN); \n    ro.yz = ro.yz*c.x + ro.zy*s.zx;\n\tro.xz = ro.xz*c.y + ro.zx*s.yw;\n    ro.z = -ro.z;\n    \n    \n    float cr = 0.; // camera rotation\n\tvec3 ta = vec3(0.5,0.5,0.5);\n\n    mat3 cam = setCamera( ro, ta, cr );\n\t\n\t// build ray\n    \n    // iq's fisheye effect....\n    //float r2 = p.x*p.x*.35 + p.y*p.y;\n    //p *= (7.-sqrt(37.5-11.5*r2))/(r2+1.0);\n    \n    vec3 rd = normalize( cam * vec3(p.xy,LENS) );  \n\n    vec3 col = render( ro, rd );\n    \n\t// vignetting\t\n\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t\n\t//if (length(globalTestColor) > 0.)\n    //    fragColor = vec4(globalTestColor,1.0);\n    //else\n        \n        fragColor = vec4( col, 1.0 );\n    #else\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    #endif\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n\t/*float time = 1.0*iTime;\n\n    float cr = 0.0;\n\tvec3 ro = path( time+0.0, 0.0 ) + vec3(0.0,0.7,0.0);\n\tvec3 ta = path( time+2.5, 0.0 ) + vec3(0.0,0.7,0.0);\n\n    mat3 cam = setCamera( ro, ta, cr );\n\n    vec3 col = render( ro + cam*fragRayOri, cam*fragRayDir );\n    \n    fragColor = vec4( col, 1.0 );\n*/\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/******************************/\n// Sample starting patterns:\n// 0: 5 x 5 plane\n// 1: 3 x 3 x 3 cube\n// 2: 3 x 3 x 3 cube, compared with hollow 3 x 3 x 3 cube\n// 3: Hollow 5 x 5 x 5 cube\n// 4: 30 x 30 x 30 wireframe (2 cells thick)\n// 5: \"Random\" cells\n// 6: Draw your own 3D pattern (keyboard controlled)\n#define START_PATTERN 3\n// approximate maximum generations per second\n#define SPEED 20.\n#define THREED_ORIGIN ivec3 (0,0,0)\n#define FP_SLOP .001\n#define RANDOM_DENSITY .10\n#define AQUA vec3(0.,1.,1.)\n#define RETURN_KEY 13\n#define SPACEBAR   32\n#define BACK_ARROW 37\n#define FWD_ARROW  39\n#define UP_ARROW   38\n#define DOWN_ARROW 40 \n#define PAGE_UP    33\n#define PAGE_DOWN  34\n#define PLUS\t   107\n#define MINUS\t   109\n\nvec3 globalColor = vec3(0.,0.,0.);\n\n\n// regular mod function is buggy and unreliable\nfloat myMod(float val, float m)\n{\n    int v = int(val);\n    \n    int mi = int(m);\n    if (v < 0)\n        v += 1000 * mi;\n    int q = v/mi;\n    \n    return float(v - mi*q);\n}\n\n// This default rule set is very basic. Some more complicated sets allow patterns that\n// will maintain themselves for a while without growing larger. For example, \n// try LIVE: 6,7,8,9,11,13,14,17  BIRTH: 8, 9 with a 10 x 10 x 10 cube.\n// (lRules = 0x00016BC0, bRules = 0x00000300)\n\nvoid checkRules(int neighbors, inout bool live, inout bool birth)\n{\n    live = false;\n    birth = false;\n    \n    // 31           <----bits ---->          0 correspond to neighbor counts\n    // oooo o000 0000 0001 1111 1111 1100 0000\n    // oooo o000 0000 0000 0000 0011 1000 0000\n    \n    float lRules = float(0x0001FFC0);\n    float bRules = float(0x00000380);\n    float n = float(neighbors);\n    \n    if (myMod(floor(lRules/pow(2.,n)),2.0) == 1.) live = true;\n    if (myMod(floor(bRules/pow(2.,n)),2.0) == 1.) birth = true;\n    \n    return;\n}\n\n// from fb39ca4\nbool keyPressed(int keyCode) {\n\tfloat startTime = 0.;\n    if (iResolution.x == 288.) startTime += 10.;\n    if (iTime <0.1 + startTime && keyCode == 32 && START_PATTERN != 6) return true;\n    return bool(texture(iChannel1, vec2((float(keyCode) + 0.5) / 256., .5/3.)).r);   \n}\n\n\n\nvec3 getMapping(float res, out vec2 TWOD_ORIGIN)\n{\n    vec3 mapping = vec3(15.,8.,112.);\n\tTWOD_ORIGIN = vec2 (840.,520.); \n    \n    if (res <= 800.)\n    \t{\n        mapping = vec3(12.,6.,66.);\n        TWOD_ORIGIN = vec2 (396.,222.);    \n        }\n    if (res <= 640.)\n    \t{\n        mapping = vec3(10.,6.,60.);\n        TWOD_ORIGIN = vec2 (320.,180.);\n        }\n    if (res <= 512.) \n    \t{\n        mapping = vec3(10.,5.,50.);\n        TWOD_ORIGIN = vec2 (250.,140.);\n        }\n    \n    if (res <= 288. )    // \"Icon\" preview size. Hopefully never smaller...\n\t\t{\n        mapping = vec3(9.,4.,32.);\n        TWOD_ORIGIN = vec2 (144.,80.);\n        }\n    return mapping;\n}\n\nvec2 v3tov2(ivec3 v3, vec3 m, vec2 o)\n{\n    vec3 v3f = vec3(float(v3.x),float(v3.y),float(v3.z));\n    \n    if (clamp(v3f,vec3(-(m.z/2.)),vec3((m.z/2.)-1.)) != v3f) // out of range\n        return vec2(9999.,9999.);\n    else\n    {\n        float w = m.z;\n        vec3 v = vec3(myMod(v3f.x+w/2.,w),  // ranges from 0 to w\n                      myMod(v3f.y+w/2.,w),\t// ranges from 0 to w\n                      myMod(v3f.z+w/2.,w)); // ranges from 0 to w\n       \n        // Suppose w is 60, cellwidth is 10, cellheight is 6\n        // the x component is (0 to 59) * 10 + z mod 10\n        // or (0 to 590 step 10) + 0 to 9 \n        float xComponent = floor(v.x * m.x + myMod(v.z, m.x)+FP_SLOP);\n        \n        // The y component is (0 to 59) * 6 + floor(z/10)\n        // or (0 to 354 step 6) + 0 through 5\n        float yComponent = floor(v.y*m.y + floor(v.z/m.x+FP_SLOP)+FP_SLOP);\n        \n\n        vec2 widthOfHalfValidAxis = m.xy * (m.z/2.);\n        \n        vec2 result = vec2(xComponent,yComponent) + o - vec2((m.z/2.)*m.x,(m.z/2.)*m.y);\n        \n        return result;\n    }\n\n}\n\nivec3 v2tov3(vec2 v2,vec3 m, vec2 o)\n{    \n\n    \n    // m.z = wrap size\n    v2 -= o;\n    \n    float x = floor(v2.x/m.x+FP_SLOP);\n    float y = floor(v2.y/m.y+FP_SLOP);\n    float z = myMod(v2.x,m.x)+ m.x*myMod(v2.y,m.y);\n    \n    if (clamp(vec3(x,y,z), vec3(-(m.z/2.),   -(m.z/2.),    0.),\n                           vec3( (m.z/2.)-1., (m.z/2.)-1., m.z - 1.)) != vec3(x,y,z))\n        return ivec3(999,999,999);\n    else\n    \treturn ivec3(int(floor(x)),\n    \t\t\t     int(floor(y)),\n                     int(floor(z - m.z/2.)))-THREED_ORIGIN;\n\t\n}\n\nfloat hash(ivec3 ip)  // from https://www.shadertoy.com/view/4sfGzS \n{\n     vec3 p = vec3(float(ip.x),float(ip.y),float(ip.z));\n    \n     p  = fract( p*sin(iDate.w)*sin(iDate.y)+.1 );\n     p *= vec3(17.61,9.471,11.62);\n     return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nvec3 fVec3(ivec3 iv)\n{\n    return vec3(float(iv.x),float(iv.y),float(iv.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    /*\n\t\tAgain, we need to access the texture using coordinates in the range [0, 1]\n\t*/\n    vec2 uv = (fragCoord.xy) / iResolution.xy;\n    vec2 f = fragCoord.xy - vec2(.5);\n\n    vec2 TWOD_ORIGIN = vec2 (840.,520.);\n    \n    vec3 color = vec3(0.0);\n\tvec3 testColor = vec3(0.);\n\n    bool LIVE = false;\n    bool DEAD = false;\n    bool moved = false;\n    bool reset = keyPressed(SPACEBAR);\n    bool paused = keyPressed(RETURN_KEY);            \n    \n    float startTime = 0.;\n    if (iResolution.x < 500.) startTime = 10.;\n    \n    vec3 m = getMapping(iResolution.x, TWOD_ORIGIN);\n    // Last Valid Pixel in a 2d block -- some of them don't get used\n    // in some mappings.\n    vec2 lvp = vec2(m.x - (m.x * m.y - m.z) -1.,m.y - 1.);\n    \n    if(iTime < 1.0 + startTime || iFrame < 60 || keyPressed(RETURN_KEY) || reset == true ) \n    { \n\t\tivec3 uv3 = v2tov3(f,m, TWOD_ORIGIN);\n        vec3 uv3f = fVec3(uv3);\n        \n        //Sample Initial Patterns\n        \n#if START_PATTERN == 0       \n        //5x5 plane\n        \n        if (clamp(uv3f, vec3(-2,0,-2), vec3(2,0,2)) == uv3f)\n            \n#endif\n            \n#if START_PATTERN == 1\n                \n        //3x3x3 cube\n        if (clamp(uv3f, vec3(-1), vec3(1)) == uv3f)\n           \n\n#endif\n            \n#if START_PATTERN == 2\n            \n        //3x3x3 cube and 3x3x3 hollow cube\n        if ((clamp(uv3f-vec3(12,0,0), vec3(-1), vec3(1)) == uv3f-vec3(12,0,0)) ||\n           (clamp(uv3f+vec3(12,0,0), vec3(-1), vec3(1)) == uv3f+vec3(12,0,0)) && (uv3 != ivec3(-12,0,0)))\n        \n#endif\n            \n#if START_PATTERN == 3\n\t\t//5x5x5 hollow cube\n        if (clamp(uv3f, vec3(-2), vec3(2)) == uv3f &&\n          !(clamp(uv3f, vec3(-1), vec3(1)) == uv3f))\n          \n#endif\n            \n#if START_PATTERN == 4\n            \n        // 30 x 30 wireframe (2 cells thick)\n        \n           vec3 neg = vec3(-16,-14,-14);\n           if ((clamp(uv3f, vec3(-16.), vec3(15.)) == uv3f) &&\n           !(clamp(uv3f, neg.xyz, (-neg - 1.).xyz) == uv3f) &&\n           !(clamp(uv3f, neg.yzx, (-neg - 1.).yzx) == uv3f) &&\n           !(clamp(uv3f, neg.zxy, (-neg - 1.).zxy) == uv3f))\n        \n#endif \n            \n#if START_PATTERN == 5            \n\n \t\t\tvec3 sz = vec3(-m.z/6.);\n            if (clamp(uv3f, sz, -sz) == uv3f && hash(uv3)>1.-RANDOM_DENSITY )                      \n\n#endif            \n\n#if START_PATTERN != 6\n            \n            color = vec3(1.0,1.0,0.);\n            \n#endif\n            \n#if START_PATTERN == 6\n            \n        // Do draw-your-own pattern:    \n          \n        /***************************************************************/\n\t\tvec2 offset2 = vec2(0.);\n\t\tvec2 origZees2 = vec2(myMod(f.x,m.x), myMod(f.y,m.y));\n\t\tvec2 zees2 = vec2(0.);\n        vec4 thisPixel = texture(iChannel0,uv);\n        \n        if (!keyPressed(SPACEBAR) )\n            color = texture(iChannel0, uv).rgb;\n        if (f == v3tov2(ivec3(0,0,0), m, TWOD_ORIGIN) && thisPixel.g == 0.)\n        \t{\n            color = vec3(0.,0.1,.8);\n            thisPixel.b = color.b;\n            moved = false;\n            }\n        \n\t\tif ((origZees2.x) + (origZees2.y)* m.x <= m.z) // don't check unused pixels in mapping\n\t\t\t{\n\t\t\tif (keyPressed(BACK_ARROW))\n\t\t\t\t{\n\t\t\t\toffset2.x += m.x;\n                moved = true;\n                }   \n\t\t\tif (keyPressed(FWD_ARROW))\n\t\t\t\t{\n\t\t\t\toffset2.x -= m.x; \n\t\t\t\tmoved = true;\n                } \n\t\t\tif (keyPressed(DOWN_ARROW))\n\t\t\t\t{\n\t\t\t\toffset2.y += m.y;\n\t\t\t\tmoved = true;\n                }\n\t\t\tif (keyPressed(UP_ARROW))\n\t\t\t\t{\n\t\t\t\toffset2.y -= m.y;\n\t\t\t\tmoved = true;\n                }\n\t\t\tif (keyPressed(PAGE_UP))\n\t\t\t\t{\n\t\t\t\tif (origZees2 == lvp)\n\t\t\t\t\t{\n\t\t\t\t\tzees2 = -lvp;\n\t\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\tif (origZees2.x < m.x - 1.)\n\t\t\t\t\t\tzees2.x = +1.;\n\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\tzees2.x = -(m.x - 1.) ;\n\t\t\t\t\t\tzees2.y = +1.; // we already know zees.y < lvp.y\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tmoved = true;\n                }\n\t\t\tif (keyPressed(PAGE_DOWN))\n\t\t\t\t{\n\t\t\t\tif (origZees2 == vec2(0.))\n\t\t\t\t\t{\n\t\t\t\t\tzees2 = lvp;\n\t\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\tif (origZees2.x > 0.)\n\t\t\t\t\t\tzees2.x = -1.;\n\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\tzees2.x = m.x - 1.;\n\t\t\t\t\t\tzees2.y = -1.; // we already know zees.y > 0\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tmoved = true;\n                }\n\t\t\t\n            if (moved == true)\n            \t{\n                vec2 newF2 = (f + offset2 + zees2 + .5) / iResolution.xy;\n\t\t\t\tvec4 pixelMovedFrom = texture(iChannel0, newF2);\n                if (pixelMovedFrom.b == .8)\n                \tcolor.b = .8;\n                else\n                    color.b = 0.;\n                if (thisPixel.b == .8)\n                    color.b = 0.;\n                }\n            else\n                color.b = thisPixel.b;\n\n            if (keyPressed(PLUS) && thisPixel.b == .8)\n               \t{\n                color.r = 1.;\n                moved = true;\n                }\n            if (keyPressed(MINUS) && thisPixel.b == .8)\n                {\n                color.r = 0.;\n                moved = true;\n                }\n            }\n\n\t\t/************************************************************/\n#endif\n    }\n    else if (!reset)\n    {\n        color = vec3(texture(iChannel0, uv)).rgb; \n   \n    }\n\n    \n    if ((iResolution.x > 288. && !keyPressed(RETURN_KEY) && !keyPressed(SPACEBAR) && !moved) || (iResolution.x == 288. && iTime > 1.0))\n    \t{\n    \tif (iTime > 1.00 + startTime)\n            {\n                \n                int neighbors = 0;\n\n                \n                // This method is faster\n                /***************************************************************/\n                vec2 offset = vec2(0.);\n                vec2 origZees = vec2(myMod(f.x,m.x), myMod(f.y,m.y));\n                \n                if ((origZees.x) + (origZees.y)* m.x <= m.z) // don't sample unused pixels in mapping\n                {\n                    for (float x = -1.0; x <= 1.0; x += 1.0)\n                    {\n                \t\tfor (float y = -1.0; y <= 1.0; y += 1.0)\n                    \t{\n                            for (float z = -1.0; z <= 1.0; z += 1.0)\n                            {\n                            \tvec3 offset3 = vec3(x,y,z);\n                                if (offset3 != vec3(0.)) // don't count point itself\n                                {\n                                \toffset = vec2(m.x*x, m.y*y);\n                                    \n                                    vec2 zees = vec2(0.);\n                                    \n                                    if (z == +1.)\n                                    {\n                                    \tif (origZees == lvp)\n                                        {\n                                        \tzees = -lvp;\n                                        }\n                                        else\n                                        {\n                                        \tif (origZees.x < m.x - 1.)\n                                                zees.x = +1.;\n                                            else\n                                            {\n                                            \tzees.x = -(m.x - 1.) ;\n                                                zees.y = +1.; // we already know zees.y < lvp.y\n                                            }\n                                        }\n                                  \t}\n                                \tif (z == -1.)\n                                    {\n                                    \tif (origZees == vec2(0.))\n                                        {\n                                        \tzees = lvp;\n                                        }\n                                        else\n                                        {\n                                        \tif (origZees.x > 0.)\n                                                zees.x = -1.;\n                                            else\n                                            {\n                                            \tzees.x = m.x - 1.;\n                                                zees.y = -1.; // we already know zees.y > 0\n                                            }\n                                        }\n                                    }\n                                    \n                                 \tvec2 newF = (f + offset + zees + .5) / iResolution.xy;\n                                    vec4 lookup = texture(iChannel0, newF);\n                                    if (lookup.r > 0.0) neighbors ++;\n                                }\n                            }\n                        }\n                    }\n                }\n                /************************************************************/\n                \n                \n                // this method is too slow.\n                /*************************************************************\n                ivec3 thisCell = v2tov3(f,m,TWOD_ORIGIN);\n\t\t\t\t//vec2 testConversion = v3tov2(thisCell);\n                //if (f != testConversion)\n                //    testColor = vec3(1.);\n                //if (thisCell == ivec3(999,999,999))\n                //    testColor = vec3(1.,0.,0.);\n                \n                // OK: major brokenness here. check v2tov3, v3tov2\n                // but right now must rest eyes a bit\n                \n                if (thisCell != ivec3(999,999,999))  // not out of range // \n                {\n                    float maxMag = (m.z-1.)/2.;\n                    for(int x = -1; x <= 1; x += 1)\n                    {\n                        for( int y = -1; y <= 1; y += 1)\n                        {\n                            for ( int z = -1; z <= 1; z += 1)\n                            {\n                            if (ivec3(x,y,z) != ivec3(0)) // don't count the cell itself\n                                {\n                                ivec3 cellToTest = ivec3(thisCell) + ivec3(x,y,z);\t\n                                // wrap around...\n                                if (abs(float(cellToTest.x)+.5) > maxMag)\n                                    cellToTest.x -= int(sign(float(cellToTest.x)) * (m.z-1.));\n                                if (abs(float(cellToTest.y)+.5) > maxMag)\n                                    cellToTest.y -= int(sign(float(cellToTest.y)) * (m.z-1.));\n                                if (abs(float(cellToTest.z)+.5) > maxMag)\n                                    cellToTest.z -= int(sign(float(cellToTest.z)) * (m.z-1.));\t\n\n\n                                vec2 newF = v3tov2(cellToTest,m,TWOD_ORIGIN) + .5;\n                                newF /= iResolution.xy;\t\t // Scale the offset down\n                                vec4 lookup = texture(iChannel0, newF); // Apply offset and sample\n\n                                neighbors += lookup.r;\t\t\t\t\t\t   // Accumulate the result\n                                }\t    \t\t\t\t\t\t\t \n                            }\n                        }\n                    }\n                }\n\t\t\t\t********************************************************/\t\t\t\t\n\n                   \n                vec3 cell = texture(iChannel0, uv).rgb;\n\t\t\t\tif (cell.b > 0.) DEAD = true;   // dying cells turn black\n                if (cell.r > 0.) LIVE = true;\t// new cells turn white\n                \n                bool liveVal = false;\n                bool birthVal = false;\n                checkRules(neighbors, liveVal, birthVal);\n                \n                if(LIVE)\n               \t{\n                    //if(neighbors >= MINLIVE && neighbors <= MAXLIVE)\n                    if (liveVal)\n                    \tcolor.r = 1.;\n                    else\n                         color.r = 0.;\n                }\n                else  \n                {\n                    //if(neighbors >= MINBIRTH && neighbors <= MAXBIRTH)\n                    if (birthVal)\n                    \tcolor.r = 1.;\n                    else\n                    \tcolor.r = 0.;\n                }\n\n            }\n   \t\telse if (!keyPressed(SPACEBAR) && !moved)// not mod speed, so don't calc next gen, just copy existing\n        \tif (iTime != 0.)\n            \tcolor = vec4(texture(iChannel0, uv)).rgb;\n    \t}\n    else if (!keyPressed(SPACEBAR) && !moved)// not mod speed, so don't calc next gen, just copy existing\n        color = vec4(texture(iChannel0, uv)).rgb;\n    \n    //add grid  \n\n\n    if (myMod(f.x,m.x) == 0. || myMod(f.y,m.y) == 0.)\n    \tcolor.g = 0.2;\n\n    \n   if (length(testColor) > 0. /*&& (fragCoord.x>=60. && fragCoord.x<90. && fragCoord.y>=30. && fragCoord.y<60.)*/) color = testColor;\n    fragColor = vec4(color, 1.0); \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}