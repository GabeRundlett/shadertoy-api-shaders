{
    "Shader": {
        "info": {
            "date": "1507157349",
            "description": "quaternion Mouselook! (pitch yaw) lets you follow any path easily without gimbal lock\nArrow.Up-Down=accelerate\nArrow Left-Right=roll\n\nhttps://www.shadertoy.com/view/4tSyRz\nwith the distance field of\nhttps://www.shadertoy.com/view/llSyRR",
            "flags": 49,
            "hasliked": 0,
            "id": "llSyzz",
            "likes": 36,
            "name": "the ride never ends",
            "published": 3,
            "tags": [
                "truchet",
                "quaternion",
                "vr",
                "marbles",
                "fly",
                "dynamiceps",
                "edynvr"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 5553
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 o, in vec2 u){\n o=texture(iChannel0,u/iResolution.xy, -100.0 );\n  //o+=mainImage2(o,u);\n}\n\n//everything is in BuffA!\n//it needs a buffer for camera position and rotation.",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//very slow performing octree of https://www.shadertoy.com/view/MlcfRl\n//(lacks octree traversal)\n\n//#define doThuchetOctree\n\n#define PI acos(-1.)\n\n/*\nself  : https://www.shadertoy.com/view/4tSyRz\n- single page, less duped code. trutural sorting \n- less globals, more object oriented.\n- more defines\n- larger render distance.\n- establishing [tiny namespace convention]\n- - mostly in scene()\n- - distance field is called gd() and gd1()for colors (resolves fractal G-buffer stuff?)\nparent: https://www.shadertoy.com/view/lsd3Dl\n  Rocket City by eiffie (although there are no rockets \n   and there is little if any esemblance to a city this is what eiffie called it)\n  eiffie just wanted to make a reusable flight control \n   but then messed that up with collision detection.\n\nparent: https://www.shadertoy.com/view/llSyRR\n   truchet mable distance field gradient\n\n\nthe TnL of one parent doesnt work too well with the shape of the other parent.\nThis is a qquck merger that is not too much of an eyesore.\n\nAn odd mix of surface normal and phong?\nits fractal AO (cares for smalles last 4 marches)\n without shadows also makes it look uncanny.\n*/\n\n//- - resource hogs and StackHeap Crashers:\n//epsilon  is a break condition for sphere tracking.\n//fractals need smaller eps, IEEE floats lose too much precision below .0000001\n//smaller eps result in slower fps and more convave areas.\n#define eps .002\n//max number of raymarch spheretracking iterations, max number of gradient descents.\n#define iterRm 180\n//max view distance, far clipping sphere, centred around camera\n#define zFar 1500.\n//to veil the horizon or not to veil the horizon, that is the asymptote.\n//#define doFog\n//for the way that TnL is done here, fog is actually quite useful\n//normally i hate distance fog, but the TnL of this shader uses it nicely\n\n//- - shape and TnL:\n//fractals need more iterShadAO at screenspace-edges (edge detecion)\n//, where normals are not pointing towards camera\n//Max.sample soft shadow \n#define iterAO 2.\n//do shading. do calculus operations, sample derivatives of the gradient.\n#define doShade\n//ao on fractals is often odd, it can make things brighter.\n#define doAO\n//do specular light, fake reflectio of sunlight\n#define doSpec\n//this sloppy merger is better doing doNormals AND doThuchetCoaster , or None!\n//mostly because the fractal shape has \"special\" defined \"normals\"\n//otherwise the [texturing and Lighting] does not match the [shape] too well.\n#if 1\n //truchet setting\n #define doNormals\n #define doThuchetCoaster\n#else\n //fratal setting\n //max.iter fractal shapes, parent setting is 4. 5. is a bit \"brighter\"\n #define iterDfFractal 4.\n //cut off half of the distance field along a plane that that the .y axis as its normal.\n #define cutY\n#endif\n\n//- - controls:\n#define THRUST 0.04*iTimeDelta\n#define ROLL 1.0*iTimeDelta\n#define ROTATE 4.0*iTimeDelta\n//collision epsilon\n#define TOO_CLOSE 0.01\n//todo: TOO_CLOSE should internally scale with movement speed\n//controls (i may have swapped left and right here, do not overthing this one)\n#define LEFT_ARROW 39\n#define RIGHT_ARROW 37  \n#define UP_ARROW 38\n#define DOWN_ARROW 40\n\n\n//now with autopilot, thanks Fabrice!\n//#define USE_AUTO_PILOT \n//looks like i broke it\n\n\n\n//does not have dynamiceps\n\n//does not have any code for reflections.\n\n\n//octree truchet graddient:\n//octree truchet iterations\n#define limit 3.0\n\n#define HASHSCALE3 vec3(.6531, .5563, .7498)\n\n#define dot2(p) dot(p,p)\n\n//hash function in hash without sine by Dave_Hoskins\n//https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z*15.3023+0.434);\n}\n\n#define checktree(k)                        \\\nfor (j = 0.0; j < k; j++) {             \\\n    vec3 h = floor(r*exp2(j))*exp2(-j); \\\n    float rand = hash13(h+exp2(-j-1.0));\\\n    if (rand >= 0.5) {                 \\\n        break;                          \\\n    }                                   \\\n}\n\nfloat squarering(vec3 p) {\n    vec2 q = vec2(abs(length(p.xy)-0.5),abs(p.z));\n    float len = length(max(q-0.1667,0.0))+min(max(q.x,q.y)-0.1667,0.0);\n    return len;\n}\n\nfloat truchet(vec3 p, int type) {\n    vec3 q = abs(p-0.5);\n\t\n    vec3 q2 = vec3(min(min(q.x,q.y),q.z),0,max(max(q.x,q.y),q.z));\n    q = min(q,q.yzx);\n    q2.y = max(max(q.x,q.y),q.z);\n\n    float inside = length(abs(q2.yz-vec2(0.0,0.5)))-0.1667;\n    float inside2 = length(max(abs(q2.yz-vec2(0.0,0.5)),0.0))-0.1667;\n    float outside = length(abs(q2.yz-vec2(0.5,0.5)))-0.3333;\n    \n    float len;\n    //len = min(len, squarering(p.xyz-vec3(0,0,0.5)));\n    //len = min(len, squarering(p.yzx-vec3(1,0,0.5)));\n    //len = min(len, squarering(p.zxy-vec3(1,1,0.5)));\n    if (type == 0) {\n        len = inside;\n    } else if (type == 1) {\n        //\n        len = -outside;\n    } else if (type == 2) {\n        len = inside2;\n    } else if (type == 3) {\n        len = squarering(p.xyz-vec3(0,0,0.5));\n        len = min(len, squarering(p.yzx-vec3(1,0,0.5)));\n        len = min(len, squarering(p.zxy-vec3(1,1,0.5)));\n    }\n    \n    \n    return len;\n}\n\nfloat mapOcreeeTruchet(vec3 p) {\n    \n    vec3 fp;\n    vec3 lp;\n    float len;\n    float i;\n    float size = 1.0;\n    \n    //r is the truchet cell you want the random \n    vec3 r = p;\n    float j;\n    checktree(limit);\n    i = j;\n    \n    //the position in the bottom left corner of the truchet cell\n    fp = floor(p*exp2(i))*exp2(-i);\n\n    //the local position on the truchet cell (always 0-1)\n    lp = fract(p*exp2(i));\n    \n    int type = int(hash13((fp+exp2(-i-1.0))*vec3(0.93,0.89,1.23))*4.0);\n    len = truchet(lp,type)*exp2(-i);\n    while (i <= limit) {\n        //the position in the bottom left corner of the truchet cell\n        fp = floor(p*exp2(i))*exp2(-i);\n        //the local position on the truchet cell (always 0-1)\n        lp = fract(p*exp2(i));\n        //check for the overlapping black dots\n        vec3 p2 = p*exp2(i);\n        vec3 fp2 = floor(p2-0.5);\n        for(int x = -0; x <= 1; x++) {\n            for(int y = -0; y <= 1; y++) {\n                for(int z = -0; z <= 1; z++) {\n                    r = (fp2+vec3(x,y,z))*exp2(-i);\n                    //this branch doesn't do anything, but it skips the random() once\n                    if (r != fp)\n                    {\n                        checktree(i);\n\n                        if (i==j) {\n                            vec3 q = abs(p2-fp2-vec3(x,y,z)-0.5);\n                            \n                            vec3 q2 = vec3(min(min(q.x,q.y),q.z),0,max(max(q.x,q.y),q.z));\n                            q = min(q,q.yzx);\n                            q2.y = max(max(q.x,q.y),q.z);\n                            \n                            float outside = length(abs(q2.yz-vec2(0.5,0.5)))-0.3333;\n                            \n                            len = max(-outside*exp2(-i),len);\n                        }\n                    }\n                }\n            }\n        }\n        size *= 0.5;\n        len *= -1.0;\n        i++;\n    }\n    //len *= size;\n    return len;\n    \n    /*vec3 q = abs(p-0.5);\n    \n    vec3 q2 = vec3(min(min(q.x,q.y),q.z),0,max(max(q.x,q.y),q.z));\n    q = min(q,q.yzx);\n    q2.y = max(max(q.x,q.y),q.z);\n    \n    float inside = length(abs(max(q2.yz-vec2(0.0,0.5),0.0)))-0.1667;\n    float outside = length(abs(q2.yz-vec2(0.5,0.5)))-0.3333;\n    \n    if (floor(p) == vec3(0)) {\n    \tlen = -outside;\n    } else {\n        len = inside;\n    }\n    return len;*/\n    //return outside;\n\n}\n\n\n//end of copiec gradient:\n\n\n\n\n//---lib.core:\n#define sat(a) clamp(a,.0,1.)\n\n\n//---lib.buffer, originally from iq, modified\nfloat isInside(vec2 p,vec2 c){vec2 d=abs(p-.5-c)-.5;return -max(d.x,d.y);}\nvec4 load(int re){return texture(iChannel0,(.5+vec2(re,.0))/iChannelResolution[0].xy,-100.);}\nvoid store(in int re, in vec4 va, inout vec4 o, in vec2 u\n){if(isInside(u,vec2(re,0))>.0)o=va;}//o=(isInside(u,vec2(re,0))>.0)?va:o;}\n//bool KeyDown(in int key){return (texture(iChannel1,vec2((float(key)+0.5)/256.0, 0.25)).x>0.0);}\nfloat key(in int key){return texture(iChannel1,vec2((float(key)+0.5)/256.0, 0.25)).x;}\n\n//---lib.quaterion\nvec4 qid(){return vec4(0.0,0.0,0.0,1.0);}\n//return q2, rotated by q1, order matters when unsigned(axes) are not identical.\nvec4 qmulq(vec4 q1, vec4 q2){return vec4(q1.xyz*q2.w+q2.xyz*q1.w+cross(q1.xyz,q2.xyz)\n,(q1.w*q2.w)-dot(q1.xyz,q2.xyz));}\nvec4 aa2q(vec3 axis, float angle){return vec4(normalize(axis)*sin(angle*0.5),cos(angle*0.5));}\nvec4 qinv(vec4 q){return vec4(-q.xyz,q.w)/dot(q,q);}//inverse quaternion\n//return p, rotated by q;\nvec3 qmulv(vec4 q, vec3 p){return qmulq(q,qmulq(vec4(p,.0),qinv(q))).xyz;}\n//rotate pitch,yaw,roll in that order:\nvec4 qpyr(vec3 o){o*=0.5;vec3 s=sin(o),c=cos(o)\n;return vec4(s.x*c.y*c.z+s.y*c.x*s.z,s.y*c.x*c.z-s.x*c.y*s.z\n,s.x*s.y*c.z+s.z*c.x*c.y, c.x*c.y*c.z-s.x*s.y*s.z);}\n/*\nvec4 q2aa(vec4 q){return vec4(q.xyz/sqrt(1.0-q.w*q.w),acos(q.w)*2.0);}//assumed q is normalized coverts to axis&angle\nvec4 qlookat(vec3 v){return aa2q(vec3(-v.y,v.x,0.0),acos(v.z/length(v)));}//point in direction v\nvec3 vmulq(vec3 p, vec4 q){return qmulq(qinv(q),qmulq(vec4(p,0.0),q)).xyz;}//inverse rotation\nvec4 qslerp(vec4 q1, vec4 q2, float f){\n\tfloat d=dot(q1,q2),theta=acos(abs(d)),ost=(1.0/sin(theta)); \n\treturn normalize(q1*sin(theta*(1.0-f))*ost*sign(d)+q2*sin(theta*f)*ost); \n}\n*/\n\n//---lib.shape:\nvec3 Tile(vec3 p){vec3 a=vec3(8.0);return abs(mod(p,a)-a*0.5)-a*0.25;}\nfloat DERect(vec4 z,vec3 r){return length(max(abs(z.xyz)-r,0.0))/z.w;}\nconst float mr=0.5, mxr=0.975, scale = 2.52;\nconst vec3 rc=vec3(3.31,2.79,4.11),rcL=vec3(2.24,1.88,2.84);\nconst vec4 p0=vec4(4.0,0.0,-4.0,1.0);\nfloat torus(vec3 p,vec2 r){\n return length(vec2(abs(abs(length(p.xy)-r.x)-.1),abs(p.z)-.1))-r.y;}\nfloat square(vec3 p,vec2 r){\n return length(vec2(abs(max(abs(p.x),abs(p.y))-r.x),p.z))-r.y;}\n\n//----lib.color\nconst vec3 sunDir=normalize(vec3(0.7,1.0,-0.7))\n,sunColor=vec3(1.0,0.99,.9)\n,skyColor=vec3(.25,.26,.27)\n//rainbow tinted cosmic microwave background, makes nice fog.\n;vec3 Backdrop(in vec3 rd){vec3 a= \n+skyColor\n+.05*(rd+sin(rd.yzx*5.+2.4*sin(rd.zxy*3.0)))\n+sunColor*(max(0.0,dot(rd,sunDir))*0.2+pow(max(0.0,dot(rd,sunDir)),256.));\n;return .7*a;}\n\n//----lib.hash for scatter-noise\n#define HASHSCALE1 .1031\n//#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n//hash function by Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p){p=fract(p*HASHSCALE3)\n;p+=dot(p,p.yxz+19.19);return fract((p.xxy+p.yxx)*p.zyx);}\nfloat h12(in vec2 p){\n return fract(float(iFrame)+sin(dot(p,vec2(13.3145,17.7391)))*317.7654321);}\n\n\n\n//---lib.setting: (BVHs and fuzzy-boolean mixes of shapes)\n#define u2(a) ((a)*2.-1.)\n//truched3dcoaster\nfloat thuchetCoaster(vec3 p)\n{vec3 p2 = mod(p,2.)-1.\n;vec3 floorpos=floor(p*.5)\n;float len=1e10\n;vec3 orientation = u2(floor(hash33(floorpos)+0.5))\n;vec3 p3 = p2*orientation\n;mat3 truchet=mat3\n(vec3(p3.yz*vec2(1, 1)+vec2(-1,-1),p3.x)\n,vec3(p3.zx*vec2(1, 1)+vec2( 1, 1),p3.y)\n,vec3(p3.yx*vec2(1,-1)+vec2( 1, 1),p3.z))\n;vec3 lens=vec3\n(torus(truchet[0],vec2(1.0,0.02))\n,torus(truchet[1],vec2(1.0,0.02))\n,torus(truchet[2],vec2(1.0,0.02)))\n;vec3 mask = vec3(lessThan(lens,min(lens.yzx,lens.zxy)))\n;vec3 p4 = truchet[int(dot(mask,vec3(0,1,2)))]\n;float dir = u2(mod(dot(floorpos,vec3(1.0)),2.0))//*dot(mask,vec3(-1.0,1.0,-1.0));\n;p4=vec3(fract(dir*(atan(p4.x,p4.y)/6.28*4.0)+iTime*0.5)-0.5,length(p4.xy)-1.0,p4.z)\n;return min(dot(lens,mask),length(p4)-0.1);\n}//https://www.shadertoy.com/view/llSyRR\n\n\n//return signed euclidean distane of[u] to a surface, gradient3d (imagine static thermodynamics)\nfloat gd(vec3 u){//gradient differential, signed distance field:\n#ifdef doThuchetOctree\nu-=1.;\nreturn -mapOcreeeTruchet(u*.1);//scaling gradient for collision detection scale.\n#endif\n#ifdef doThuchetCoaster\nreturn thuchetCoaster(u)\n    ;\n#else\nvec3 p=Tile(u)\n;vec4 z=vec4(p,1)\n;float dG=1e3\n;for(float n=.0;n<iterDfFractal;n++ //fractal\n){z.xyz=clamp(z.xyz,-1.,1.)*2.-z.xyz\n ;z*=scale/clamp(max(dot(z.xy,z.xy),max(dot(z.xz,z.xz),dot(z.yz,z.yz))),mr,mxr)\n ;z+=p0\n ;if(n==2.)dG=DERect(z,rcL);\n}\n;dG=min(dG,DERect(z,rc))\n#ifdef cutY\n;dG=max(dG,u.y);\n#endif\n;return dG;\n#endif\n;}\n\n//return first derivative of the gd()\n//FAST non-analytic 3pass estimate of first derivative of map() == normals3d\nvec3 normal(vec3 p, float l){vec2 e=vec2(.1,0)\n;return normalize(vec3\n(l-gd(p-e.xyy)\n,l-gd(p-e.yxy)\n,l-gd(p-e.yyx)));}//todo, replace with \"automatic differentiation\"\n//1passPerDoman is less precise than 2passPerDomain variant, but not by much.\n\n//A variant of gd(), that is HERE used to get a color and to derive a surface normal.\n//the inout vec4 mcol is a big difference.\n//gd1 exists because the fractal shape gets \"specual treatment\" for color\n//, due to \"nnormals being tricky within a KIFS\"\nfloat gd1(vec3 p,inout vec4 mcol)\n{p=Tile(p)\n;vec4 z=vec4(p,1)\n;float dG=1e3\n;vec4 mc=vec4(0)\n;for (float n=.0;n<5.;n++ //palette of 5 colors, i sync to abive fractal shape\n){z.xyz=clamp(z.xyz, -1.0, 1.0) *2.0-z.xyz\n ;z*=scale/clamp(max(dot(z.xy,z.xy),max(dot(z.xz,z.xz),dot(z.yz,z.yz))),mr,mxr)\n ;z+=p0\n ;if(n==3.)mc=vec4(vec3(.5,.3,.2)+z.xyz*.05,.25)\n ;else if(n==2.)dG=DERect(z,rcL);\n}float ds=DERect(z,rc)\n;if(dG<ds)mcol+=vec4(0.5,0.6,0.9,0.9)+vec4(z.xyz*0.025,0.0)\n;else mcol+=mc\n;return min(dG,ds);}\n\n//return [c]color, modified by distance fog\n//[ts] DistanceToCamera [is a delta [time since] photon got emmited]\n//there is no such thing as global distance, but there is a global speed if light.\n//[f] FogColor (assume a cosmic microwave background image pixel)\n//,designed for a zFar of 20, scales, but not too well.\nvec3 fog(float ts,vec3 c,vec3 f){\n//;float fog=min(pow(ts*.2,1.33)*.54,1.)//only for zFar=20.\n;float fog=min(pow(ts*20./zFar*.2,1.33)*.54,1.)//optimizd for zFar=20.\n//must be reciprocal log() ?\n;return mix(c,f,fog);}\n\n//return ambient occlusion\n//[o] LightSourcePosition\n//[d] LightDirection\n//[s] ScatterHash\nfloat AO(in vec3 p,in vec3 d,float s){\n;float t=.0,a=1.,f,n=.01+.04*s\n;for(float i=.0;i<iterAO;i++ \n){f=max(gd(p+d*t)*1.5,n)\n ;a=min(a,f/t+t*0.5)\n ;t+=f;\n}return a;}//soft shadow with \"noisy lens\".\n\n#ifdef doShade\n //return occluded specular of [r]\n //[r]accumulator to return, ends up being \"phong glossy\"\n //[o]rigin\n //[d]direction\n //[p]point in space; p=o+d*ts.x\n //[N]surfaceNormal at [p]\n //[s]ScatterHash\n //[mcol] materialColor (diffuse)\n vec3 SpecOcc(vec3 r,vec3 d,vec3 N,vec3 p,vec3 o,float s,vec4 mcol){\n ;float l=dot(N,sunDir)//sundir must be normalized\n #ifdef doAO\n ,shad=AO(p+N*.001,sunDir,s)//shadow\n #else\n ,shad=.5\n #endif\n #ifdef doSpec\n ;float v=dot(-d,N)\n ;vec3 cc=vec3(.6,.8,1)//diffused light. sky color, shorter wavelengths diffuse more\n ,lc=vec3(1,.8,.6)     //undiffused light, direct sun color, long wavelengths\n ;float cd=exp(-distance(o,p))\n ;vec3 R=reflect(d,N)\n ;float spcl=pow(sat(dot(R,sunDir)),10.)\n ,spcc=pow(max(.0,dot(R,-d)),1.+cd)*.25\n ;r=r*(cd*v*cc+shad*l*lc)+(cd*spcc*cc+shad*spcl*lc)*mcol.a\n #endif\n ;r=sat(r)\n ;return r;}\n#endif\n\n//-------------------------main renderer\n/*\n[o]RayOrigin\n[d]RayDirection\n[s]ScatterNoise\n[c]color, to be returned\n[f]FragmentSpaceScaling, to blur rasterization, against moire;a=smoothstep(s,-s,a);\n[t]TimeTraveled (implies division by speed of light) == distance to camera \n[g]gradient, signed distance to surface.\n[ao]Accumulate Occlusion, may just buffer the last step length\n[ps]PushSmallest; ps=(g<f*t &&g <ao && ts.w<.0);\n[ts]TimeSmallest    ,init: ts=vec4(-1 ), if(ps)store the 4 smallest [t>0] (abridged)\n[gs]gradientSmallest,init: gs=vec4(1e6), if(ps)store the 4 smallest abs(g)\n*/\nvec3 scene(vec3 o,vec3 d,float s){//origin,direction,scattering\n;float g=gd(o)*s*.5\n,t=g,ao=1.\n,f=2./min(iResolution.x,iResolution.y) //AntiAlias pixel size, of [2] pixels.\n;vec4 gs=vec4(1e6),ts=vec4(-1)//buffer 4 \"smallest values\"\n ;for(int i=0;i<iterRm;i++\n ){//start.raymarch\n ;g=gd(o+d*t)\n ;bool ps=all(lessThan(vec2(g,ts.w),vec2(min(f*t,ao),0)))\n       //=(g<min(f*t,ao)&&ts.w<.0);\n       //=(g<f*t&&g<ao&&ts.w<.0);\n ;if(ps //PushSmall, we remember 4*2 smallest values for AO.\n ){gs=vec4(abs(g),gs.xyz)\n  ;ts=vec4(t,ts.xyz);\n ;}\n ;t+=g\n ;ao=g\n ;if(t>zFar||g<eps)break;//raymarch loop break\n ;}//end__.raymarch loop \n ;if(g<f*t && g<gs.x){gs.x=g;ts.x=t;}//one last PushSmall\n ;vec3 c=Backdrop(d)\n     //;return c;\n ;vec3 fcol=c\n ;for(int i=0;i<4;i++ //some AA supersampling shit in here?\n ){//ts and ps values get processed for \"occlusion\"\n  //oh looks like this is just nearSurface() surface stuff.      \n  ;if(ts.x<.0)break\n  ;float px=f*ts.x\n  ;vec3 so=o+d*ts.x\n  ;vec4 mcol=vec4(.0)\n  #define g3(a) vec3(gd1(so+a.xyy,mcol),gd1(so+a.yxy,mcol),gd1(so+a.yyx,mcol))\n  ;vec3 ve=vec3(px,0,0)\n  ;vec3 dp=g3(ve),dn=g3(-ve)//positive normal//negative normal\n  #ifndef doNormals \n  ;float d1=gd1(so,mcol)\n  ;vec3 N=(dp-dn)/(length(dp-vec3(d1))+length(vec3(d1)-dn))//HNF, normalized surface normal.\n  #else\n  ;vec3 N=normal(so,eps)*.5+.5\n   #endif\n  //above begs to be inversesqrt?\n  ;vec3 spc=mcol.rgb*0.14//specular set to material\n  #ifdef doShade\n  ;spc=SpecOcc(spc,d,N,so,o,s,mcol)\n  #endif\n        //near distance can skip fog.\n  #ifdef doFog\n  ;spc=fog(ts.x,spc,fcol);\n  #else \n  //;spc=fog(ts.x,spc,fcol);\n  #endif  \n  ;c=mix(spc,c,sat(gs.x/px))\n  ;gs=gs.yzwx;ts=ts.yzwx//rotate sampling matrix\n ;}\n//;if(c!=c)c=vec3(1,0,0);//if(NaN)\n;return sat(c*2.)\n;}\n\n\nvec4 mainImage2(out vec4 fragColor, in vec2 fragCoord,vec3 A,vec3 D){\n vec3 t=normalize(vec3((2.0*fragCoord-iResolution.xy)/iResolution.y,1.0));\n vec3 o=load(0).xyz;\n vec4 fw=(load(1));\n t=qmulv(fw,t);\n //ro=eye;rd=normalize(dir);\n float s=h12(fragCoord);\n return vec4(scene(o,t,s),1.0);\n}\n\n\nvoid steer( out vec4 o, in vec2 u ){\n    ;vec4 p,qrot\n;if(iFrame<2){//init\n ;p=vec4(.1,0,0,.01)\n ;qrot=normalize(vec4(.1,.2,.3,.8));\n}else{//next frame\n ;p=load(0);qrot=load(1)//load state from previous frame\n ;vec3 fw=vec3(0,0,1)\n ;fw=qmulv(qrot,fw) //this can be done simpler\n ;vec3 newp=p.xyz+fw*p.w*.2\n ;if(gd(newp)>TOO_CLOSE)p.xyz=newp\n ;else\n  {if(gd(vec3(p.xy,newp.z))>TOO_CLOSE)p.z=newp.z;\n  ;if(gd(vec3(p.x,newp.y,p.z))>TOO_CLOSE)p.y=newp.y;\n  ;if(gd(vec3(newp.x,p.yz))>TOO_CLOSE)p.x=newp.x;//mkay every domain checked intependently\n }\n ;p.w+=THRUST*(key(UP_ARROW)-key(DOWN_ARROW));\n ;float roll=ROLL*(key(RIGHT_ARROW)-key(LEFT_ARROW));\n ;vec2 m=vec2(0)\n ;if(iMouse.z>.0\n ){\n  ;vec2 n=iMouse.xy-abs(iMouse.zw)\n  ;n.x=-n.x\n  ;m.xy-=(n)/iResolution.xy\n ;}\n #ifdef USE_AUTO_PILOT\n else{//I'm pretty sure this is how google cars steer\n  ;float d=gd(p.xyz)\n  ;newp=qmulv(qrot,vec3(d,0,0))\n  ;float d2=gd(p.xyz+newp)\n  ;m.x=sign(d2-d)*ROTATE/(.1+2.*d*d)\n ;}\n #endif\n ;vec4 qp=qpyr(vec3(m.yx*ROTATE,roll))\n ;qrot=normalize(qmulq(qrot,qp))//normalize before saving\n;}\n;store(0,p,o,u)//position,velocity\n;store(1,qrot,o,u)//rotation\n;}\n\n\n///by replacing mainImage() with the below, you can turn a non vr shader into a VR shader\n//and steer() is half decent quaternion-camera controls.\n//\n//the core trick is that mainImage() uses mainVR as subroutine!!!!\n\n\n/*vec4 mainImage2(out vec4 o, in vec2 u,vec3 A,vec3 D){\n vec3 d=normalize(vec3((2.0*u-iResolution.xy)/iResolution.y,1.0));\n vec3 l=load(0).xyz;\n vec4 fw=(load(1));//poaded camera position and camera rotation\n //   \n //no, this part below doesnt make sense to me.\n //instead i just overwrite the VR-headset-position and -rotation\n //its simpler and more compatible with non-vr\n #ifdef doVr \n //t=qmulv(fw,A);\n #else\n d=qmulv(fw,d);\n #endif\n //t=qmulv(D,t);//am i doing this right? //2022 me, 5 years later, apparently this is all correct.\n //ro=eye;\n  ;d=normalize(d); float s=h12(u);\n // l.y+=1.;\n #if 1\n return vec4(RayMarch5(l,d),1); //reflective\n #else\n return vec4(RayMarch2(l,d,s),1); //non reflective\n #endif\n}*/\n\n//shitty VR ignores [A]=HeadSetOrigin and [d]=HeadSetDirection\n//you can only move your view with keyboard and mouse.\nvoid mainImage3(out vec4 o,vec2 u,in vec3 A,in vec3 D){\n;if(all(lessThan(u,vec2(2.5,1.5))))steer(o,u) ;else //update seering (camera properties)\n o=mainImage2(o,u,A,D); }                           //update image segment\n//Outoput,Uv,[A]=RayOrigin,[D]=RayDirection\nvoid mainVR(out vec4 o,in vec2 u,in vec3 a,in vec3 d){\n ;if(all(lessThan(u,vec2(2.5,1.5))))steer(o,u) ;else //update seering (camera properties)\n mainImage3(o,u,a,d);                                //update image segment\n;}\n\n//mainimage translates a camera to map that to ONE vr cam.     \nvoid mainImage(out vec4 O,in vec2 U){\n const vec3 cameraPos=vec3(0);//camPos is simple offset\n const float rad=360./acos(-1.),dar=acos(-1.)/180.;\n vec2 m=u2(iMouse.xy/iResolution.xy); \n m=PI*mix(vec2(1.-m.x,m.y*.35),vec2(1,0),step(iMouse.z,.0));\n vec2 fov=vec2(25.);fov.x=atan(tan(fov.y/rad)*iResolution.x/iResolution.y)*rad;\n mat3 cam;\n cam[0]=vec3(cos(m.x),0,sin(m.x));//camera.right\n m.x=m.x+PI*.5;\n cam[1]=vec3(cos(m.x)*cos(m.y),sin(m.y),sin(m.x)*cos(m.y));//cameraFwd\n //cam[2]=-cross(cam[0],cam[1]));//camUp\n fov=(2.*U/iResolution.xy-1.)*sin(fov*dar)/sin(PI*.5-fov*dar);\n cam[0]=cameraPos-cam[1]+fov.x*cam[0]-fov.y*cross(cam[0],cam[1]);\n cam[1]=normalize(cam[0]-cameraPos);\n // scene is accidentally backwards, ugh\n cam[1]*=vec3(-1,1,-1);cam[0]*=vec3(-1,1,-1);\n mainVR(O,U,cam[0],cam[1])\n;}\n\n\n/*\nvoid mainImage(out vec4 o,vec2 u){\n;if(all(lessThan(u,vec2(2.5,1.5))))steer(o,u)\n;else o=mainImage2(o,u); \n}*/\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}