{
    "Shader": {
        "info": {
            "date": "1574886734",
            "description": "Progress. Much obliged to iq for everything and the shadertoy community (credited where relevant). \nTODO when I grok it better: AA, soft shadows, artifact cleanup, more elaborate sphere movement",
            "flags": 32,
            "hasliked": 0,
            "id": "WdVSRt",
            "likes": 13,
            "name": "Temple of the Star",
            "published": 3,
            "tags": [
                "raymarching",
                "triplanar",
                "textures",
                "bloom",
                "reflections",
                "buffer",
                "architecture",
                "smoothmin"
            ],
            "usePreview": 1,
            "username": "desertsky",
            "viewed": 1300
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0,fragCoord.xy/iResolution.xy);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.14159265\n#define numrep 9.\n\nvec2 r(vec2 ax, float a) {return mat2(cos(a),-sin(a),sin(a),cos(a))*ax;}\n\n//polar mod from http://mercury.sexy/hg_sdf/\nfloat pModPolar(inout vec2 p, float repetitions) \n{\n    float angle = 2.*PI/repetitions;\n    float a = atan(p.y, p.x) + angle/2.;\n    float r = length(p);\n    float c = floor(a/angle);\n    a = mod(a,angle) - angle/2.;\n    p = vec2(cos(a), sin(a))*r;\n    if (abs(c) >= (repetitions/2.)) c = abs(c);\n    return c;\n}\n\n// fancy sdIcosDodecaStar poly from https://www.shadertoy.com/view/4lSGRV\nfloat sdDodecahedron(vec3 p, float radius)\n{\n    const float phi = 1.61803398875;  // Golden Ratio = (sqrt(5)+1)/2;\n    const vec3 n = normalize(vec3(phi,1,0));\n\n    p = abs(p / radius);\n    float a = dot(p, n.xyz);\n    float b = dot(p, n.zxy);\n    float c = dot(p, n.yzx);\n    return (max(max(a,b),c)-n.x) * radius;\n}\n\nfloat sdIcosahedron(vec3 p, float radius)\n{\n    const float q = 2.61803398875;  // Golden Ratio + 1 = (sqrt(5)+3)/2;\n    const vec3 n1 = normalize(vec3(q,1,0));\n    const vec3 n2 = vec3(0.57735026919);  // = sqrt(3)/3);\n\n    p = abs(p / radius);\n    float a = dot(p, n1.xyz);\n    float b = dot(p, n1.zxy);\n    float c = dot(p, n1.yzx);\n    float d = dot(p, n2) - n1.x;\n    return max(max(max(a,b),c)-n1.x,d) * radius;\n}\n\nfloat sdIcosDodecaStar(vec3 p, float radius)\n{\n    return min(sdDodecahedron(p,radius),  sdIcosahedron(p.zyx,radius));\n}\n\nfloat smoothMin(float distA, float distB, float k)\n{\n    float h = max(k-abs(distA - distB),0.0)/k;\n    return min(distA, distB) - h*h*h*k*1.0/6.0;\n}\n\n//sky+noise: https://www.shadertoy.com/view/4l23Rh\nmat2 m2 = mat2(0.8,  0.6, -0.6,  0.8);\nmat2 im2 = mat2(0.8,  -0.6, 0.6,  0.8);\n\nfloat noise(in vec2 p){\n\n    float res=0.;\n    float f=1.;\n    for( int i=0; i< 3; i++ ) \n    {\t\t\n        p=m2*p*f+.6;     \n        f*=1.2;\n        res+=sin(p.x+sin(2.*p.y));\n    }        \t\n    return res/3.;\n}\n\nfloat fbmabs( vec2 p ) \n{\n\n    float f=1.;   \n    float r = 0.0;\t\n    for(int i = 0;i<8;i++)\n    {\t\n        r += abs(noise( p*f )+.5)/f;       \n        f *=2.;\n        p=im2*p;    \n    }\n    return 1.-r*.5;\n}\n\nvec3 sky(in vec2 p)\n{\t\n    return sin(vec3(1.7,1.5,1)+ .7+ .9*fbmabs(p*4.-.02*iTime))+.25;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n    return length(p.xz-c.xy)-c.z;\n}\n\nfloat checkers( in vec2 p )\n{\n    vec2 q = floor(p);\n    return mod(q.x+q.y,2.);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec2 map(vec3 pos)\n{\n\n    float bluesphere = length(vec3(sin(iTime*2.)*1.5,cos(iTime/2.)*2.+.75,cos(iTime*2.)*1.5)-pos)-.25;    \n    float redsphere = length(vec3(cos(iTime*2.)*1.5,sin(iTime/2.)*2.+.75,sin(iTime*2.)*1.5)-pos)-.25;\n\n    float ico = sdIcosDodecaStar(vec3(.0,1.+sin(iTime/3.),.0)-pos,1.);\n    float plane = pos.y+1.5;    \n\n    // columns           \n    vec3 colpos = pos;\n    float qa = pModPolar(colpos.xz,numrep+4.);\n    colpos.x-=2.4;\n    float column = sdCylinder(vec3(0)-colpos, vec3(.145));\n    float columnbox = sdBox(vec3(0.,0.6,0)-colpos,vec3(1.5,2.5,1.5));\n    float columns = max(column,columnbox);\n\n    //gates: block, then hole\n    vec3 boxpos = pos;\n    float q = pModPolar(boxpos.xz,numrep);\n    boxpos.x-=5.;\n    float box = sdRoundBox(boxpos,vec3(.7,3.,1.2),.24);    \n\n    vec3 cypos = pos;\n    cypos.y /= 10.;\n    cypos.yz = r(cypos.yz,PI/2.);\n    cypos.xz = r(cypos.xz,PI/2.);\n    cypos.yz = r(cypos.yz,.5);\n\n    q = pModPolar(cypos.yz,numrep);\n    cypos.x-=.055;\n    cypos.z+=.44;\n    cypos.z/=6.5;\n\n    float cyhole = sdCylinder(vec3(0.,0.,.0)+cypos,vec3(.0,.1,.21));\n    float gates = max(-cyhole,box);\n    float doorway = min(cyhole,box);\n    doorway = min(doorway, columns);\n\n    //SDF+matID\n    vec2 scene = vec2(10.);\n    scene = vec2(smoothMin(scene.x,bluesphere,0.4), scene.x<bluesphere ? scene.y:2.);\n    scene = vec2(smoothMin(scene.x,ico,0.4), scene.x<ico ? scene.y:3.);\n    scene = vec2(smoothMin(scene.x,redsphere,0.4), scene.x<redsphere ? scene.y:4.);\n    scene = vec2(smoothMin(scene.x,plane,.4),scene.x<plane ? scene.y:1.);\n    scene = vec2(smoothMin(scene.x,columns,.84),scene.x<columns? scene.y:5.);\n    scene = vec2(min(scene.x,gates),scene.x<gates ? scene.y:5.);\n    return scene;\n}\n\nvec2 rm(vec3 ro, vec3 rd)\n{\n    vec2 dO = vec2(0.);\n    for (int i = 0; i < 128; i++)\n    {\n        vec2 t = map(ro + dO.x * rd);\n        dO.x += t.x;\n        dO.y = t.y;\n        if(t.x < .01 || dO.x > 30.) break;\n    }\n    return dO;\n}\n\nvec3 n(vec3 pos)\n{\n    float d = map(pos).x;\n    vec2 e = vec2(.001,.0);\n    vec3 pn = d - vec3(\n        map(pos-e.xyy).x,\n        map(pos-e.yxy).x,\n        map(pos-e.yyx).x\n    );\n    return normalize(pn);\n}\n\n\n//Tri-linear Texturing Function from https://www.shadertoy.com/view/Xd3XDS\n\nvec3 t3(sampler2D tex, vec3 p, vec3 n)\n{\n    return  (texture(tex,p.xy).rgb*n.z*n.z\n             +texture(tex,p.zy).rgb*n.x*n.x\n             +texture(tex,p.xz).rgb*n.y*n.y);\n}\n\n// light\nvec3 l(vec3 pos)\n{\n    vec3 total = vec3(0.);\n    vec3 nor = n(pos);\n    vec3 sundir = normalize(vec3(6.0,5.,0.)); \n    vec3 sundif = clamp(dot(nor,sundir),.0,1.)*vec3(.7,.5,.3)+sky(vec2(iTime/4.+pos.x,pos.y))*vec3(.7,.24,.7)*.3;\n    vec3 skydif = clamp(dot(nor,vec3(.0,1.,.0)),.0,1.)*vec3(.15,.250,.35);\n\n    vec3 bounce = clamp(dot(nor,-sundir),.0,1.)*vec3(.15);  \n    total+=sundif+bounce+skydif;  \n    return total;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;   \n    {    \n        vec3 ro = vec3(cos(iTime/3.)*4.+sin(iTime/3.)*3.,-1.,sin(iTime/3.)*4.+cos(iTime/3.)*3.);\n        vec3 ta = vec3(.0,sin(iTime/3.),.0);\n        vec3 ww = normalize(ta-ro);\n        vec3 uu = normalize(cross(ww,vec3(.0,1.,.0)));\n        vec3 vv = normalize(cross(uu,ww));\n        vec3 rd = normalize(uv.x*uu+uv.y*vv+ww*1.5);\n        vec2 r = rm(ro,rd);\n        vec3 pos = ro+rd*r.x;\n\n        //bg\n        vec3 col = vec3(.5,-.5+uv.y,uv.y+.75)*sky(vec2(uv.x/3.+iTime/14.,uv.y/3.));\n\n        //materials\n        if(r.x < 30.)\n        {\n            //floor\n            if(r.y == 1.) \n            {  \n                float f = checkers(pos.xz);\n                col=l(pos*vec3(f))*sky(iTime/4.+pos.xz)*vec3(.9,.7,.9)*.5;\n                vec3 ro = pos+n(pos)*.02;\n                vec3 rd = normalize(reflect(rd,n(pos)));\n                vec2 r = rm(ro,rd);\n                vec3 prf = ro+rd*r.x;\n\n                if(r.y == 2.) \n                {\n                    col += .25*l(pos)*vec3(.2)+fbmabs(pos.xy*10.)*vec3(.1,.1,2.9);   \n                } \n                else if(r.y == 4.) \n                {\n                    col += .25*l(pos)*vec3(.2)+fbmabs(pos.xy*10.)*vec3(2.1,.1,.6);                      \n                } \n                else if(r.y == 5.)\n                {\n                    vec3 N = n(pos);\n                    vec3 C = t3(iChannel0,pos,N).rgb;\n                    col += .25*l(prf)*C.xyz;                   \n                }\n            }\n\n            //ballz\n            if(r.y == 2.) \n            {  \n                col = l(pos)*vec3(.2)+fbmabs(pos.xy*10.)*vec3(.1,.1,2.9);         \n            }\n            if(r.y == 4.) \n            {  \n                col = l(pos)*vec3(.2)+fbmabs(pos.xy*10.)*vec3(2.1,.1,.6);   \n            }\n\n            //dodecaicosomething\n            if(r.y == 3.) \n            {\n                col = vec3(.05,.06,.02);\n                vec3 ro = pos+n(pos)*.02;\n                vec3 rd = normalize(reflect(rd,n(pos)));\n                vec2 r = rm(ro,rd);\n                vec3 prf = ro+rd*r.x;  \n                if(r.y == 2.) {\n                    col = l(pos)*vec3(2)+fbmabs(pos.xy*10.)*vec3(.1,.1,2.9);   \n                } \n                else if(r.y == 4.) \n                {\n                    col = l(pos)*vec3(.2)+fbmabs(pos.xy*10.)*vec3(2.1,.1,.6);   \n                } \n                else if(r.y ==1.) \n                {\n                    float f = checkers(prf.xz);\n                    col+=l(prf*vec3(f))*sky(-iTime/4.+prf.xz)*(vec3(.5+uv.y))*vec3(.75,.50+uv.y,.75);\n                } \n                else if(r.y == 5.)\n                {\n                    vec3 N = n(pos);\n                    vec3 C = t3(iChannel0,pos,N).rgb;\n                    col = l(prf)*C.xyz;                   \n                }\n                else\n                {\n                    col+=l(prf)*vec3(.5,.5,uv.y+.75)/1.+sky(vec2(uv.x+-iTime/8.,uv.y))/2.*vec3(.5,.0+uv.y,.5);\n                }\n            }  \n\n            //gates\n            if(r.y == 5.)\n            {\n                vec3 N = n(pos);         \n                vec3 C = t3(iChannel0,pos,N).rgb;\n                col = l(pos)*C.xyz;\n            }\n        }\n        fragColor = vec4(col,1.0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//lovely bloom adapted from https://www.shadertoy.com/view/XslGDr\n\nvec3 samplef(vec2 tc);\nvec3 blur(vec2 tc, float offs);\nvec3 highlights(vec3 pixel, float thres);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 tc = fragCoord.xy / iResolution.xy;\n\tvec3 color = blur(tc, 2.0);\n\tcolor += blur(tc, 3.0);\n\tcolor += blur(tc, 5.0);\n\tcolor += blur(tc, 7.0);\n\tcolor /= 2.;\n\t\n\tcolor += samplef(tc);\n\tfragColor.xyz = mix(samplef(tc), color, 1.);\n\tfragColor.w = 1.0;\n}\n\nvec3 samplef(vec2 tc)\n{\n\treturn pow((texture(iChannel0, tc).xyz),vec3(1.00));\n}\n\nvec3 hsample(vec2 tc)\n{\n\treturn highlights(samplef(tc), 0.6);\n}\n\nvec3 blur(vec2 tc, float offs)\n{\n\tvec4 xoffs = offs * vec4(-2.0, -1.0, 1.0, 2.0) / iResolution.x;\n\tvec4 yoffs = offs * vec4(-2.0, -1.0, 1.0, 2.0) / iResolution.y;\n\t\n\tvec3 color = vec3(0.0, 0.0, 0.0);\n\tcolor += hsample(tc + vec2(xoffs.x, yoffs.x)) * 0.00366;\n\tcolor += hsample(tc + vec2(xoffs.y, yoffs.x)) * 0.01465;\n\tcolor += hsample(tc + vec2(    0.0, yoffs.x)) * 0.02564;\n\tcolor += hsample(tc + vec2(xoffs.z, yoffs.x)) * 0.01465;\n\tcolor += hsample(tc + vec2(xoffs.w, yoffs.x)) * 0.00366;\n\t\n\tcolor += hsample(tc + vec2(xoffs.x, yoffs.y)) * 0.01465;\n\tcolor += hsample(tc + vec2(xoffs.y, yoffs.y)) * 0.05861;\n\tcolor += hsample(tc + vec2(    0.0, yoffs.y)) * 0.09524;\n\tcolor += hsample(tc + vec2(xoffs.z, yoffs.y)) * 0.05861;\n\tcolor += hsample(tc + vec2(xoffs.w, yoffs.y)) * 0.01465;\n\t\n\tcolor += hsample(tc + vec2(xoffs.x, 0.0)) * 0.02564;\n\tcolor += hsample(tc + vec2(xoffs.y, 0.0)) * 0.09524;\n\tcolor += hsample(tc + vec2(    0.0, 0.0)) * 0.15018;\n\tcolor += hsample(tc + vec2(xoffs.z, 0.0)) * 0.09524;\n\tcolor += hsample(tc + vec2(xoffs.w, 0.0)) * 0.02564;\n\t\n\tcolor += hsample(tc + vec2(xoffs.x, yoffs.z)) * 0.01465;\n\tcolor += hsample(tc + vec2(xoffs.y, yoffs.z)) * 0.05861;\n\tcolor += hsample(tc + vec2(    0.0, yoffs.z)) * 0.09524;\n\tcolor += hsample(tc + vec2(xoffs.z, yoffs.z)) * 0.05861;\n\tcolor += hsample(tc + vec2(xoffs.w, yoffs.z)) * 0.01465;\n\t\n\tcolor += hsample(tc + vec2(xoffs.x, yoffs.w)) * 0.00366;\n\tcolor += hsample(tc + vec2(xoffs.y, yoffs.w)) * 0.01465;\n\tcolor += hsample(tc + vec2(    0.0, yoffs.w)) * 0.02564;\n\tcolor += hsample(tc + vec2(xoffs.z, yoffs.w)) * 0.01465;\n\tcolor += hsample(tc + vec2(xoffs.w, yoffs.w)) * 0.00366;\n\n\treturn color;\n}\n\nvec3 highlights(vec3 pixel, float thres)\n{\n\tfloat val = (pixel.x + pixel.y + pixel.z) / 3.0;\n\treturn pixel * smoothstep(thres - 0.1, thres + 0.1, val);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}