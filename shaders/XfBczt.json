{
    "Shader": {
        "info": {
            "date": "1722793834",
            "description": "source https://glslsandbox.com/e#79500.0 and star nest ",
            "flags": 1,
            "hasliked": 0,
            "id": "XfBczt",
            "likes": 1,
            "name": "space and particles ",
            "published": 3,
            "tags": [
                "particles",
                "stars",
                "universe"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 79
        },
        "renderpass": [
            {
                "code": "\n\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.010 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\nfloat sdStar(in vec2 p, in float r, in float n, in float w)\n{\n    // these 5 lines can be precomputed for a given shape\n    //float m = n*(1.0-w) + w*2.0;\n    float m = n + w*(2.0-n);\n    \n    float an = 3.1415927/n;\n    float en = 3.1415927/m;\n    vec2  racs = r*vec2(cos(an),sin(an));\n    vec2   ecs =   vec2(cos(en),sin(en)); // ecs=vec2(0,1) and simplify, for regular polygon,\n\n    // symmetry (optional)\n    p.x = abs(p.x);\n    \n    // reduce to first sector\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n\n    // line sdf\n    p -= racs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, racs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\t//get coords and direction\n\tvec3 dir=rd;\n\tvec3 from=ro;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam;\n            p.xy*=mat2(cos(iTime*0.02),sin(iTime*0.02),-sin(iTime*0.02),cos(iTime*0.02) );// the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.2-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.03,1.);\t\n}\nconst float a=1.0;\nconst float b=.1759;\nconst float PI=3.14159265359;\n#define THICKNESS .11\n#define ARMS 4.\n#define GRID 96.\n#define COLORS 2.\n#define STARS 2.\n#define SPEED 1.\n#define time iTime\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\nfloat spiralSDF(vec2 p,vec2 c, float phase){\n    p = p - c;\n    float t=atan(p.y, p.x) + phase;\n    float r=length(p.xy);\n    float n=(log(r/a)/b-t)/(2.*PI);\n\n    // Cap the spiral\n    float upper_r=a*exp(b*(t+2.*PI*ceil(n)));\n    float lower_r=a*exp(b*(t+2.*PI*floor(n)));\n    return min(abs(upper_r-r),abs(r-lower_r));\n}\n#define PI 3.14159265358979\n#define N 40\nuniform vec2 resolution;\n\nuniform vec2 mouse;\n\n#define time iTime\n#define resolution iResolution.xy\n#define saturate(oo) clamp(oo, 0.0, 1.0)\n\n// Quality Settings\n#define MarchSteps 6\n\n// Scene Settings\n#define ExpPosition vec3(0.0)\n#define Radius 2.0\n#define Background vec4(0.1, 0.0, 0.0, 1.0)\n\n// Noise Settings\n#define NoiseSteps 100\n#define NoiseAmplitude 0.1\n#define NoiseFrequency 5.2\n#define Animation vec3(0.0, -3.0, 0.5)\n\n// Colour Gradient\n#define Color1 vec4(1.0, 1.0, 1.0, 1.0)\n#define Color2 vec4(0.0, 0.3, 1, 1.0)\n#define Color3 vec4(0.0, 0.03, 1.0, 1.0)\n#define Color4 vec4(0.05, 0.02, 0.02, 1.0)\n\n\n\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) { return x - floor(x * (2.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r){ return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v)\n{\n\tconst vec2  C = vec2(1.0/6.0, 1.0/3.0);\n\tconst vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n\t// First corner\n\tvec3 i  = floor(v + dot(v, C.yyy));\n\tvec3 x0 = v - i + dot(i, C.xxx);\n\n\t// Other corners\n\tvec3 g = step(x0.yzx, x0.xyz);\n\tvec3 l = 2.0 - g;\n\tvec3 i1 = min(g.xyz, l.zxy);\n\tvec3 i2 = max(g.xyz, l.zxy);\n\tvec3 x1 = x0 - i1 + C.xxx;\n\tvec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n\tvec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n\t// Permutations\n\ti = mod289(i);\n\tvec4 p = permute( permute( permute( i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n\t// Gradients: 7x7 points over a square, mapped onto an octahedron.\n\t// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n\tfloat n_ = 0.142857142857; // 1.0/7.0\n\tvec3  ns = n_ * D.wyz - D.xzx;\n\tvec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n\tvec4 x_ = floor(j * ns.z);\n\tvec4 y_ = floor(j - 7.0 * x_);    // mod(j,N)\n\n\tvec4 x = x_ *ns.x + ns.yyyy;\n\tvec4 y = y_ *ns.x + ns.yyyy;\n\n\tvec4 h = 1.0 - abs(x) - abs(y);\n\tvec4 b0 = vec4(x.xy, y.xy);\n\tvec4 b1 = vec4(x.zw, y.zw);\n\n\tvec4 s0 = floor(b0) * 2.0 + 1.0;\n\tvec4 s1 = floor(b1) * 2.0 + 1.0;\n\tvec4 sh = -step(h, vec4(0.0));\n\n\tvec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n\tvec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n\tvec3 p0 = vec3(a0.xy, h.x);\n\tvec3 p1 = vec3(a0.zw, h.y);\n\tvec3 p2 = vec3(a1.xy, h.z);\n\tvec3 p3 = vec3(a1.zw, h.w);\n\n\t//Normalise gradients\n\tvec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n\n\tp0 *= norm.x;\n\tp1 *= norm.y;\n\tp2 *= norm.z;\n\tp3 *= norm.w;\n\n\t// Mix final noise value\n\tvec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n\tm = m * m;\n\n\treturn 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat Turbulence(vec3 position, float minFreq, float maxFreq, float qWidth)\n{\n\tfloat value = 0.0;\n\tfloat cutoff = clamp(0.2/qWidth, 0.0, maxFreq);\n\tfloat fade;\n\tfloat fOut = minFreq;\n\n\tfor(int i=NoiseSteps ; i>=0 ; i--)\n\t{\n\t\tif(fOut >= 0.5 * cutoff) break;\n\n\t\tfOut *= 3.0;\n\t\tvalue += abs(snoise(position * fOut))/fOut;\n\t}\n\n\tfade = clamp(2.0 * (cutoff-fOut)/cutoff, 0.0, 1.0);\n\tvalue += fade * abs(snoise(position * fOut))/fOut;\n\n\treturn 1.0-value;\n}\n\nfloat SphereDist(vec3 position)\n{\n\treturn length(position - ExpPosition) - Radius;\n}\n\nvec4 Shade(float distance)\n{\n\tfloat c1 = saturate(distance*5.0 + 0.5);\n\tfloat c2 = saturate(distance*5.0);\n\tfloat c3 = saturate(distance*3.4 - 0.5);\n\t\n\tvec4 a = mix(Color1,Color2, c1);\n\tvec4 b = mix(a,     Color3, c2);\n\treturn \t mix(b,     Color4, c3);\n}\n\n\n// Draws the scene\nfloat RenderScene(vec3 position, out float distance)\n{\n\tfloat noise = Turbulence(position * NoiseFrequency + Animation*time, 0.1, 1.5, 0.03) * NoiseAmplitude;\n\tnoise = saturate(abs(noise));\n\tdistance = SphereDist(position) - noise;\n\t\t\n\treturn noise;\n}\n\n// Basic ray marching method.\nvec4 March(vec3 rayOrigin, vec3 rayStep)\n{\n\tvec3 position = rayOrigin;\n\t\n\tfloat distance;\n\tfloat displacement;\n\t\n\tfor(int step = MarchSteps; step >=0  ; --step)\n\t{\n\t\tdisplacement = RenderScene(position, distance);\n\t\n\t\tif(distance < 0.05) break;\n\t\t\n\t\tposition += rayStep * distance;\n\t}\n\treturn mix(Shade(displacement), Background, float(distance >= 0.5));\n}\n\nbool IntersectSphere(vec3 ro, vec3 rd, vec3 pos, float radius, out vec3 intersectPoint)\n{\n\tvec3 relDistance = (ro - pos);\n\t\n\tfloat b = dot(relDistance, rd);\n\tfloat c = dot(relDistance, relDistance) - radius*radius;\n\tfloat d = b*b - c;\n\t\n\tintersectPoint = ro + rd*(-b - sqrt(d));\n\t\n\treturn d >= 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n    float phase = 2.*3.14159/ARMS;\n    for(float i = 0.;i<ARMS;i++){\nfloat d2= 01.-spiralSDF(uv,vec2(0.),.3*SPEED*iTime*i);\nuv*=d2;\n}\n\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,1.);\n\nvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    // Normalized pixel coordinates (from 0 to 1)\n    ;\n    float t = iTime/3.0;\n     \n\n    float sn = 5.0;\n    float sw = fract(t);\n    float d = sdStar( p,0.7, sn, sw );\n\n    // Time varying pixel color\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\nfloat size = 0.05;\n\tfloat dist = 0.600;\n\tfloat ang = 0.0;\n\tvec2 pos = vec2(0.0,0.0);\n    uv.xy*=mat2(cos(iTime),sin(iTime),-sin(iTime), cos(iTime));\n\tvec3 color = vec3(0.1);;\n\t   float t3 = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv) + .27)) * 10.2;\n\tfloat si = sin(t3);\n\tfloat co = cos(t3);\n\tmat2 ma = mat2(co, si, -si, co);\n\n\tfor(int i=0; i<N; i++){\n\t\tfloat r = 1.4;\n\t\tang += PI / (float(N)*0.2)+(time/60.0);\n\t\tpos = vec2(cos(ang),sin(ang))*r*sin(time+ang/.5);\n\t\tdist += size / distance(pos,uv*10.);\n\t\tvec3 c = vec3(0.03, 0.05, 0.1);\n\t\tcolor = c*dist;  \n\t}\n    \n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n\nvec2 p3 = (gl_FragCoord.xy / resolution.xy) * 2.0 - 1.0;\n\tp3.x *= resolution.x/resolution.y;\n\n\tfloat rotx = mouse.y * 4.0;\n\tfloat roty = -mouse.x * 4.0;\n\n\n\t// camera\n\tvec3 ro = zoom * normalize(vec3(cos(roty), cos(rotx), sin(roty)));\n\tvec3 ww = normalize(vec3(0.0, 0.0, 0.0) - ro);\n\tvec3 uu = normalize(cross( vec3(-1.0, 0.5, 0.0), ww));\n\tvec3 vv = normalize(cross(ww, uu));\n\tvec3 rd = normalize(p3.x*uu + p3.y*vv + 1.5*ww);\n\n\tvec4 col3 = Background;\n\n\tvec3 origin;\n\t\n\tif(IntersectSphere(ro, rd, ExpPosition, Radius + NoiseAmplitude*6.0, origin))\n\t{\n\t\tcol3 = March(origin, rd);\n\t}\n\n\tvec3 from=vec3(1.,.5,0.5)*color;\n\t\n\t\n\tmainVR(fragColor, fragCoord, from, dir);\t\n  fragColor*=vec4(color*col3.xyz,0.);\n  fragColor+=vec4(color*3.*vec3(1.,0.,.5),0.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}