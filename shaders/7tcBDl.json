{
    "Shader": {
        "info": {
            "date": "1663800492",
            "description": "Approximating a quadratic bezier curve with a biarc.\nInspired by https://www.shadertoy.com/view/sldXWl but using a different heuristic,\nwhich follows the quadratic bezier curve a bit more tightly.\n\nRed: Biarc\nGreen: Bezier\n\nMove control point with mouse",
            "flags": 0,
            "hasliked": 0,
            "id": "7tcBDl",
            "likes": 7,
            "name": "Biarc quadratic Bezier approx",
            "published": 3,
            "tags": [
                "2d",
                "distancefield",
                "bezier",
                "beziercurve",
                "spline",
                "curve",
                "quadratic",
                "arc",
                "biarc"
            ],
            "usePreview": 0,
            "username": "NinjaKoala",
            "viewed": 235
        },
        "renderpass": [
            {
                "code": "/*\nSee https://www.shadertoy.com/view/sl3BWs for some explanation.\n*/\n\n//#define INCENTER /* Use the incenter heuristic instead */\n//#define DISTANCE_FIELD /* Show distance field */\n\nconst vec3 dot_col=vec3(0,0,1);\nconst vec3 line_col=vec3(0,0,1);\nconst vec3 bezier_col=vec3(0,1,0);\nconst vec3 arc_col=vec3(1,0,0);\nconst vec3 bg_col=vec3(1);\n\nconst float dot_size=.004;\nconst float line_width=.001;\n\nconst float zoom=1.;\n\nconst float pi=3.1415925;\n\nvec2 parametric_quadratic_bezier(float t, vec2 p0, vec2 p1, vec2 p2){\n\treturn mix(mix(p0,p1,t),mix(p1,p2,t),t);\n}\n\nfloat quadratic_bezier_normal_iteration(float t, vec2 a0, vec2 a1, vec2 a2){\n\tvec2 a_1=a1+t*a2;\n\n\tvec2 uv_to_p=a0+t*a_1;\n\tvec2 tang=a_1+t*a2;\n\n\tfloat l_tang=dot(tang,tang);\n\treturn t-dot(tang,uv_to_p)/l_tang;\n}\n\nfloat quadratic_bezier_dis_approx_sq(vec2 uv, vec2 p0, vec2 p1, vec2 p2){\n\tvec2 a2=p0-2.*p1+p2;\n\tvec2 a1=-2.*p0 +2.*p1;\n\tvec2 a0=p0-uv;\n\n\tfloat d0=1e38;\n\n\tvec3 t0=vec3(0.,.5,1.);\n\tfloat t;\n\n\tfor(int i=0;i<3;i++){\n\t\tt=t0[i];\n\t\tfor(int j=0;j<3;j++){\n\t\t\tt=quadratic_bezier_normal_iteration(t,a0,a1,a2);\n\t\t}\n\t\tt=clamp(t,0.,1.);\n\t\tvec2 uv_to_p=(a2*t+a1)*t+a0;\n\t\td0=min(d0,dot(uv_to_p,uv_to_p));\n\t}\n\n\treturn d0;\n}\n\nfloat quadratic_bezier_dis_approx(vec2 uv, vec2 p0, vec2 p1, vec2 p2){\n\treturn sqrt(quadratic_bezier_dis_approx_sq(uv,p0,p1,p2));\n}\n\nfloat segment_dis(vec2 p, vec2 a, vec2 b){\n\tvec2 pa=p-a, ba=b-a;\n\tfloat h=clamp(dot(pa,ba)/dot(ba,ba), 0., 1.);\n\treturn length(pa-ba*h);\n}\n\nvec2 incenter(vec2 p0, vec2 p1, vec2 p2){\n\tvec2 v1=normalize(p1-p0);\n\tvec2 v2=normalize(p2-p0);\n\n\tvec2 v3=normalize(p2-p1);\n\tvec2 v4=normalize(p0-p1);\n\n\tvec3 line1, line2;\n\tline1.xy=(v1+v2)/2.;\n\tline1.xy=vec2(-line1.y,line1.x);\n\tline1.z=-dot(line1.xy,p0);\n\n\tline2.xy=(v3+v4)/2.;\n\tline2.xy=vec2(-line2.y,line2.x);\n\tline2.z=-dot(line2.xy,p1);\n\n\tvec3 l12=cross(line1,line2);\n\n\treturn l12.xy/l12.z;\n}\n\nvec2 circumcenter(vec2 p0, vec2 p1, vec2 p2){\n\tvec3 line1, line2;\n\tline1.xy=p1-p0;\n\tline1.z=-dot(line1.xy,(p0+p1)/2.);\n\n\tline2.xy=p2-p1;\n\tline2.z=-dot(line2.xy,(p1+p2)/2.);\n\n\tvec3 m1=cross(line1,line2);\n\tm1/=m1.z;\n\n\treturn m1.xy;\n}\n\nvec2 compute_best_node(vec2 p0, vec2 p1, vec2 p2){\n\tvec2 m1=incenter(p0,p1,p2);\n\tvec2 m2=circumcenter(p0,m1,p2);\n\n\tvec2 a2=p0-2.*p1+p2;\n\tvec2 a1=2.*(p1-p0);\n\tvec2 a0=p0-m2;\n\n\tfloat b3=dot(a2,a2);\n\tfloat b2=2.*dot(a2,a1);\n\tfloat b1=2.*dot(a2,a0)+dot(a1,a1);\n\n\tfloat c2=b3;\n\tfloat c1=b2+b3;\n\tfloat c0=b1+b2+b3;\n\n\tfloat discriminant=c1*c1-4.*c2*c0;\n\n\tif(discriminant < 0.){\n\t\treturn m1;\n\t}\n\n\tfloat disc_sq=sqrt(discriminant);\n\n\tfloat root1=(-c1-disc_sq)/(2.*c2);\n\tfloat root2=(-c1+disc_sq)/(2.*c2);\n\n\tif(root1 > 0. && root1 < 1.){\n\t\treturn parametric_quadratic_bezier(root1,p0,p1,p2);\n\t}\n\telse if(root2 > 0. && root2 < 1.){\n\t\treturn parametric_quadratic_bezier(root2,p0,p1,p2);\n\t}\n\telse{\n\t\treturn m1;\n\t}\n}\n\nvec2 compute_arc_midpoint(vec2 p0, vec2 p1, vec2 p2){\n\tvec3 line1, line2;\n\n\tline1.xy=p1-p0;\n\tline1.z=-dot(line1.xy,p0);\n\n\tline2.xy=p2-p0;\n\tline2.z=-dot(line2.xy,(p0+p2)/2.);\n\n\tvec3 l12=cross(line1,line2);\n\n\treturn l12.xy/l12.z;\n}\n\nfloat arc_dis(vec2 uv, vec2 p0, vec2 p1, vec2 m0, float r0){\n\tvec2 m1=normalize((p0+p1)/2.-m0);\n\t\n\tif(dot(m1,normalize(uv-m0))>dot(m1,normalize(p0-m0))){\n\t\treturn abs(distance(uv,m0)-r0);\n\t}\n\telse{\n\t\treturn min(distance(uv,p0),distance(uv,p1));\n\t}\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tfloat border=2./iResolution.x;\n\n\tvec2 uv=fragCoord.xy/iResolution.xy;\n\tuv-=.5;\n    uv.y*=iResolution.y/iResolution.x;\n\n\tvec2 mouse=iMouse.xy/iResolution.xy;\n\tmouse-=.5;\n    mouse.y*=iResolution.y/iResolution.x;\n\n\tborder*=zoom;\n\tuv*=zoom;\n\tmouse*=zoom;\n\n\tvec2 p0=vec2(-.2,-.2);\n\tvec2 p1=mouse;\n\tvec2 p2=vec2(.2,-.2);\n    \n    // Animate if mouse is in left bottom corner\n    if(max(iMouse.x, iMouse.y) < 20.){\n        p1=vec2(-.26,.1)+vec2(.2*sin(iTime),.08*cos(iTime));\n    }\n\n\t#ifdef INCENTER\n\tvec2 p3=incenter(p0,p1,p2);\n\t#else\n\tvec2 p3=compute_best_node(p0,p1,p2);\n\t#endif\n\n\tvec2 m1=compute_arc_midpoint(p0,p1,p3);\n\tfloat r1=distance(m1,p0);\n\n\tvec2 m2=compute_arc_midpoint(p2,p1,p3);\n\tfloat r2=distance(m2,p2);\n\n\tvec3 color=bg_col;\n\n\tfloat dis=1e38;\n\n\t#ifdef DISTANCE_FIELD\n\tfloat sgn=1.;\n\n\tdis=min(dis,arc_dis(uv,p0,p3,m1,r1));\n\tdis=min(dis,arc_dis(uv,p2,p3,m2,r2));\n\n\t//iq's sd color scheme\n\tcolor = vec3(1.0) - sgn*vec3(0.1,0.4,0.7);\n\tcolor *= 1.0 - exp(-8.0 * abs(dis));\n\tcolor *= 0.8 + 0.2*cos(480.0*abs(dis));\n\tcolor = mix(color, vec3(1.0), 1.0-smoothstep(0.0,0.005,abs(dis)));\n\t#endif\n\n\tdis=segment_dis(uv,p0,p1)-line_width;\n\tdis=min(dis,segment_dis(uv,p1,p2)-line_width);\n\tcolor=mix(line_col,color,smoothstep(-border/2.,border/2.,dis));\n\n\tdis=quadratic_bezier_dis_approx(uv,p0,p1,p2)-line_width;\n\tcolor=mix(bezier_col,color,smoothstep(-border/2.,border/2.,dis));\n\n\t#ifndef DISTANCE_FIELD\n\tdis=arc_dis(uv,p0,p3,m1,r1)-line_width;\n\tdis=min(dis,arc_dis(uv,p2,p3,m2,r2)-line_width);\n\tcolor=mix(arc_col,color,smoothstep(-border/2.,border/2.,dis));\n\t#endif\n    \n    dis=distance(uv,p0)-dot_size;\n\tdis=min(dis,distance(uv,p1)-dot_size);\n\tdis=min(dis,distance(uv,p2)-dot_size);\n\tcolor=mix(dot_col,color,smoothstep(-border/2.,border/2.,dis));\n\n\tfragColor=vec4(color,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}