{
    "Shader": {
        "info": {
            "date": "1533357415",
            "description": "A short story about humanity, from a global perspective. Followed by a minigame in the spirit of SimEarth (see below to enable).\n\nRestart to sync music.\n\nRead the comment at the top of the code for commentary and instructions.",
            "flags": 112,
            "hasliked": 0,
            "id": "XttcWn",
            "likes": 116,
            "name": "[SH18] Humanity",
            "published": 3,
            "tags": [
                "game",
                "simulation",
                "global",
                "earth",
                "wind",
                "human",
                "erosion",
                "predator",
                "prey",
                "ecology",
                "climate",
                "sh18",
                "tectonic"
            ],
            "usePreview": 1,
            "username": "davidar",
            "viewed": 15752
        },
        "renderpass": [
            {
                "code": "#define DISABLE_MINIGAME // PLEASE TRY REMOVING THIS LINE\n#define DISABLE_SCATTERING // PLEASE TRY REMOVING THIS LINE\n/* 2018 David A Roberts <https://davidar.io>\n\n\n                                H U M A N I T Y\n\nThis story begins four and a half billion years ago, with a lump of molten rock.\nWater contained within was vaporised by the heat, which escaped and began\ncirculating through the early atmosphere forming around the planet. As time\nprogressed and the rock cooled, the water vapour began to condense into oceans.\nThe flow of liquid water across the surface carved valleys in the terrain,\nleaving an accumulation of sediment in its wake.\n\nA number of processes are gradually revealed through several visualisations:\n\n1. Tectonic plates, whose movements rearrange continents, uplift mountain\n   ranges, and rift into deep ocean trenches.\n\n2. River basins that have been etched in the land by hydraulic erosion.\n\n3. Global mean temperatures, ranging from below-freezing (blue) at the poles to\n   above-freezing (orange) at the equator. The distribution of heat shifts as\n   the simulation cycles between summer and winter.\n\n4. Global wind circulation patterns, driven by high-pressure (blue) and\n   low-pressure (orange) systems. These also change with the seasons, as well as\n   the evolving terrain.\n\n5. The distribution of terrestrial lifeforms, divided into plants (green), prey\n   (orange) and predators (red). The changing seasons trigger migrations into\n   regions that have warmed enough to support greater rates of plant growth.\n\nConcluding the prelude on the early earth, the pace slows to a cycle between day\nand night, terrain becoming fixed as tectonic movements become imperceptible.\nSoon the night reveals unprecedented patterns of light, as humanity proceeds to\ncolonise the surface of the planet.\n\nThis rapid expansion brings its own set of changes, as humans begin to burn\nlarge amounts of fossil fuels to power their settlements. Carbon that had lain\ndormant for millions of years is released into the atmosphere, and dispersed\naround the planet.\n\nOver several hundred years, humans burn through all available fossil fuel\nresources, releasing five trillion tonnes of carbon into the atmosphere. This\nstrengthens the greenhouse effect, raising the global average temperature by\nalmost 10 degrees Celsius. Large regions of land around the equator are rendered\nuninhabitable by extreme temperatures, resulting in the disappearance of\nhumanity from a significant portion of the planet.\n\n                                      ***\n\nThe minigame begins after humanity has left the planet, either through\nextinction or, for the lucky few, seeking a new home amongst the stars. Time\nspeeds up again, and the planet gradually recovers as the excess carbon is\nreabsorbed. Use the mouse to draw terrain on the map, and observe how it\ninfluences the earth system. Hold any of the following keys on the keyboard:\n\n- D: lower terrain with the mouse, instead of raising it\n- U: alter tectonic uplift rather than directly raising/lowering terrain\n- T: tectonic plates visualisation\n- R: river basin visualisation\n- C: temperature visualisation\n- F: wind flow and air pressure visualisation\n- L: terrestrial life visualisation\n- S: spherical globe view\n\nThe original SimEarth game can be played here:\n\n  https://archive.org/details/msdos_SimEarth_-_The_Living_Planet_1990\n\n\n\n\n\n\n\n\n\n\n\n\n\n*/\n\n#define buf(p) textureLod(iChannel0,(p)/iResolution.xy,0.)\n#define keypress(k) (texelFetch(iChannel1, ivec2(k,0), 0).w > 0.)\n\n#define CAMERA_DIST 25.\n\n#define DEEP_WATER vec4(0.01, 0.02, 0.08, 1)\n#define SHALLOW_WATER vec4(0.11, 0.28, 0.51, 1)\n#define WARM vec4(1.,0.5,0.,1)\n#define COOL vec4(0.,0.5,1.,1)\n\nvec3 fromlatlon(float lat, float lon) {\n    return vec3(sin(lon*PI/180.) * cos(lat*PI/180.), sin(lat*PI/180.), cos(lon*PI/180.) * cos(lat*PI/180.));\n}\n\nvec3 sun_pos(float t) {\n    float month = mod(t/2., 12.);\n    float delta = 1. - 2. * smoothstep(1.5, 4.5, month) + 2. * smoothstep(7.5, 10.5, month);\n    return fromlatlon(23.5 * delta, -360. * t/15.);\n}\n\nvec4 climate(vec2 fragCoord, vec2 pass) {\n    vec2 p = fragCoord * MAP_RES / iResolution.xy;\n    if (p.x < 0.5) p.x = 0.5;\n    vec2 uv = p / iResolution.xy;\n    return texture(iChannel1, uv + pass);\n}\n\nvec4 map_land(vec2 fragCoord, bool ocean) {\n    vec2 p = fragCoord;\n    vec2 grad = vec2(buf(p+E).z - buf(p+W).z, buf(p+N).z - buf(p+S).z);\n    float light = cos(atan(grad.y, grad.x) + 0.25*PI) * clamp(0.2 * length(grad), 0., 1.);\n    vec4 fragColor = vec4(vec3(0.015 + 0.085 * light), 1);\n    if (!ocean) fragColor.rgb *= 3.;\n    float y = buf(fragCoord).z;\n    if (y < OCEAN_DEPTH) {\n        if (ocean)\n            fragColor = mix(DEEP_WATER, SHALLOW_WATER, y / OCEAN_DEPTH);\n        else\n            fragColor.rgb = vec3(0);\n    }\n    fragColor.w = MAP_HEIGHT(y);\n    return fragColor;\n}\n\nvec4 map_flow(vec2 fragCoord) {\n    float mbar = climate(fragCoord, PASS3).x;\n    vec4 r = WARM;\n    r = mix(r, vec4(1), smoothstep(1000., 1012., floor(mbar)));\n    r = mix(r, COOL, smoothstep(1012., 1024., floor(mbar)));\n    \n    vec2 p = fragCoord * MAP_RES / iResolution.xy;\n    if (p.x < 1.) p.x = 1.;\n    vec2 uv = p / iResolution.xy;\n    vec2 v = texture(iChannel1, uv + PASS4).xy;\n    \n    vec4 c = texture(iChannel2, fragCoord/iResolution.xy);\n    float flow = (c.x > 0.) ? 1. : c.y;\n    flow *= clamp(length(v), 0., 1.);\n    \n    vec4 fragColor = map_land(fragCoord, false);\n    fragColor = mix(fragColor, r, 0.5 * flow);\n    return fragColor;\n}\n\nvec4 map_temp(vec2 fragCoord) {\n    float height = MAP_HEIGHT(buf(fragCoord).z);\n    float temp0 = climate(fragCoord, PASS3).z;\n    float temp = temp0 - mix(4., 3., smoothstep(WARMING_START_TIME, WARMING_END_TIME, iTime)) * height;\n    temp = floor(temp/2.)*2.;\n    vec4 r = COOL;\n    r = mix(r, vec4(1), smoothstep(-20.,  0., temp));\n    r = mix(r, WARM,    smoothstep(  0., 25., temp));\n    vec4 fragColor = map_land(fragCoord, false);\n    fragColor = mix(fragColor, r, 0.35);\n    return fragColor;\n}\n\nvec4 map_life(vec2 fragCoord) {\n    vec4 c = texture(iChannel3, fragCoord/iResolution.xy);\n    float vege = c.x;\n    float prey = c.y * 2.;\n    float pred = max(c.z, 0.);\n\n    vec4 fragColor = map_land(fragCoord, true);\n    fragColor = mix(fragColor, vec4(0.0, 1.0, 0.1, 1), 0.75 * smoothstep(0., 5., vege - prey - pred));\n    fragColor = mix(fragColor, vec4(0.8, 0.5, 0.0, 1), 0.75 * smoothstep(0., 5., prey - pred));\n    fragColor = mix(fragColor, vec4(0.5, 0.0, 0.0, 1), 0.75 * smoothstep(0., 5., pred));\n    return fragColor;\n}\n\nvec4 map_plates(vec2 fragCoord) {\n    vec2 p = fragCoord;\n    float q = buf(p).x;\n    float uplift = buf(p).y;\n    vec4 r = vec4(0,0,0,1);\n    r.rgb = (q < 0.) ? vec3(1) : .6 + .6 * cos(2.*PI*q + vec3(0,23,21));\n    vec4 fragColor = map_land(fragCoord, false);\n    fragColor = r * (5. * fragColor + 3. * clamp(2. * uplift - 1., 0., 1.) + 0.05);\n    return fragColor;\n}\n\nvec4 map_rivers(vec2 fragCoord) {\n    vec4 fragColor = map_land(fragCoord, true);\n    float flow = buf(fragCoord).w;\n    fragColor.rgb = mix(fragColor.rgb, .6 + .6 * cos(2.*PI * fract(flow) + vec3(0,23,21)),\n                        clamp(0.15 * log(floor(flow)), 0., 1.));\n    return fragColor;\n}\n\nvec4 map_sat(vec2 fragCoord) {\n    vec2 p = fragCoord;\n    vec2 uv = p / iResolution.xy;\n    float y = buf(p).z;\n    float lat = 180. * uv.y - 90.;\n    float lon = 360. * uv.x - 180.;\n    float height = MAP_HEIGHT(y);\n    vec2 grad = vec2(buf(p+E).z - buf(p+W).z, buf(p+N).z - buf(p+S).z);\n    float light = cos(atan(grad.y, grad.x) + 0.25*PI);\n    float illum = 0.75 + 0.25 * light * clamp(log(1. + length(grad)), 0., 1.);\n    float clouds = 1.;\n    \n    vec4 ocean = mix(vec4(0.01, 0.02, 0.08, 1), vec4(0.11, 0.28, 0.51, 1), y / OCEAN_DEPTH);\n    \n    if ((SLOWING_START_TIME < iTime && iTime < STORY_END_TIME) || keypress(KeyS)) {\n        vec3 q = fromlatlon(lat, lon);\n        vec2 ngrad = normalize(grad);\n        vec3 orient = normalize(fromlatlon(lat - ngrad.y, lon - ngrad.x) - q);\n        vec3 normal = normalize(mix(q, orient, 0.25 * clamp(log(1. + length(grad)), 0., 1.)));\n        vec3 sun = sun_pos(iTime);\n        float m = smoothstep(-1., 0., iTime - DAYNIGHT_START_TIME);\n        illum = clamp(mix(illum, dot(normal, sun), m), 0., 1.);\n        clouds *= mix(1., dot(q, sun), m);\n        ocean *= mix(1., dot(q, sun), m);\n    }\n    \n    float temp0 = climate(p, PASS3).z;\n    float temp = temp0 - mix(4., 3., smoothstep(WARMING_START_TIME, WARMING_END_TIME, iTime)) * height;\n    \n    // dry land\n    vec3 dry = vec3(0.89, 0.9, 0.89);\n    dry = mix(dry, vec3(0.11, 0.10, 0.05), smoothstep(-10., 0., temp));\n    dry = mix(dry, vec3(1.00, 0.96, 0.71), smoothstep( 0., 20., temp));\n    dry = mix(dry, vec3(0.81, 0.48, 0.31), smoothstep(20., 30., temp));\n\n    // vegetation\n    vec3 veg = vec3(0.89, 0.9, 0.89);\n    veg = mix(veg, vec3(0.56, 0.49, 0.28), smoothstep(-10., 0., temp));\n    veg = mix(veg, vec3(0.18, 0.34, 0.04), smoothstep( 0., 20., temp));\n    veg = mix(veg, vec3(0.05, 0.23, 0.04), smoothstep(20., 30., temp));\n\n    float moisture = texture(iChannel3, uv).w;\n    vec4 land = vec4(0,0,0,1);\n    land.rgb = mix(dry, veg, plant_growth(moisture, temp));\n    //land.rgb = mix(dry, veg, moisture/5.);\n    land.rgb *= illum;\n    if (iTime < LAND_END_TIME) {\n        float c = (15. - y) / 3.5;\n        float heat = clamp(2. / pow(iTime + 1., 2.), 0., 1.);\n        vec4 rock = mix(vec4(0.58, 0.57, 0.55, 1), vec4(0.15, 0.13, 0.1, 1), smoothstep(0., 3., c));\n        rock *= light * clamp(0.2 * length(grad), 0., 1.);\n        rock += 5. * c * heat * vec4(1., 0.15, 0.05, 1.);\n        land = mix(rock, land, smoothstep(LAND_START_TIME, LAND_END_TIME, iTime));\n    }\n    vec4 r = vec4(0,0,0,1);\n    if (y < OCEAN_DEPTH && iTime > OCEAN_START_TIME) {\n        r = mix(land, ocean, smoothstep(0., 2., iTime - OCEAN_START_TIME));\n    } else {\n        r = land;\n    }\n    \n    float vapour = texture(iChannel2, uv).w;\n    r.rgb = mix(r.rgb, vec3(1), 0.3 * clouds * log(1. + vapour) * smoothstep(0., LAND_END_TIME, iTime));\n    return r;\n}\n\nvec4 map_co2(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    float ppmv = 377. + 3. * texture(iChannel2, uv).z;\n    vec4 fragColor = vec4(0);\n    fragColor = mix(fragColor, vec4(0.10, 0.11, 0.22, 1), smoothstep(377., 379., ppmv));\n    fragColor = mix(fragColor, vec4(0.10, 0.40, 0.36, 1), smoothstep(379., 381., ppmv));\n    fragColor = mix(fragColor, vec4(0.58, 0.48, 0.08, 1), smoothstep(381., 383., ppmv));\n    fragColor = mix(fragColor, vec4(0.43, 0.14, 0.09, 1), smoothstep(383., 385., ppmv));\n    fragColor = mix(fragColor, vec4(0.25, 0.09, 0.21, 1), smoothstep(385., 387., ppmv));\n    return fragColor;\n}\n\nvec4 map(vec2 uv) {\n    vec2 p = uv * iResolution.xy;\n#ifndef DISABLE_MINIGAME\n    if (iTime > STORY_END_TIME) {\n        if (keypress(KeyC)) return map_temp(p);\n        if (keypress(KeyF)) return map_flow(p);\n        if (keypress(KeyL)) return map_life(p);\n        if (keypress(KeyR)) return map_rivers(p);\n        if (keypress(KeyT)) return map_plates(p);\n    }\n#endif\n    vec4 fragColor = map_sat(p);\n    if (iTime < SLOWING_START_TIME - 10.) {\n        float s = LAND_END_TIME + 5.;\n        float t = iTime + uv.x;\n        fragColor = mix(fragColor, map_plates(p), smoothstep(s - 1., s + 1., t)); s += 8.;\n        fragColor = mix(fragColor, map_rivers(p), smoothstep(s - 1., s + 1., t)); s += 8.;\n        fragColor = mix(fragColor, map_temp(p),   smoothstep(s - 1., s + 1., t)); s += 16.;\n        fragColor = mix(fragColor, map_flow(p),   smoothstep(s - 1., s + 1., t)); s += 16.;\n        fragColor = mix(fragColor, map_life(p),   smoothstep(s - 1., s + 1., t)); s += 18.;\n        fragColor = mix(fragColor, map_sat(p),    smoothstep(s - 1., s + 1., t));\n    }\n    return fragColor;\n}\n\n#define rexp(p) (-log(1e-4 + (1. - 2e-4) * hash12(p)))\n\nfloat edge(vec2 a, vec2 b, vec2 p, float width) {\n    // https://iquilezles.org/articles/distfunctions\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\t\n    float d = length(pa - ba * h);\n    float x = distance(p,a) / (distance(p,a) + distance(p,b));\n    return 1.5 * mix(rexp(a), rexp(b), x) * smoothstep(width/2., 0., d) * smoothstep(1.75, 0.5, distance(a,b));\n}\n\nfloat network(vec2 p, float width) {\n    // based on https://www.shadertoy.com/view/lscczl\n    vec2 c = floor(p) + hash22(floor(p));\n    vec2 n = floor(p) + N + hash22(floor(p) + N);\n    vec2 e = floor(p) + E + hash22(floor(p) + E);\n    vec2 s = floor(p) + S + hash22(floor(p) + S);\n    vec2 w = floor(p) + W + hash22(floor(p) + W);\n    \n    float m = 0.;\n    m += edge(n, e, p, width);\n\tm += edge(e, s, p, width);\n    m += edge(s, w, p, width);\n    m += edge(w, n, p, width);\n   \n    for (float y = -1.; y <= 1.; y++) {\n        for (float x = -1.; x <= 1.; x++) {\n            vec2 q = floor(p) + vec2(x,y) + hash22(floor(p) + vec2(x,y));\n            float intensity = distance(p,q) / clamp(rexp(floor(p) + vec2(x,y)), 0., 1.);\n            m += edge(c, q, p, width);\n            m += 10. * exp(-40. * intensity);\n        }\n    }\n    \n    return m;\n}\n\nfloat speckle(vec2 p, float density) {\n    float m = 0.;\n    for (float y = -1.; y <= 1.; y++) {\n        for (float x = -1.; x <= 1.; x++) {\n            vec2 q = floor(p) + vec2(x,y) + hash22(floor(p) + vec2(x,y));\n            float a = 1.5 * rexp(q) * pow(1.5 * clamp(density, 0., 0.67), 1.5);\n            m += a * exp(-2.0 * distance(p,q) / clamp(density, 0.67, 1.));\n        }\n    }\n    return m;\n}\n\nvec4 map_night(vec2 uv) {\n    vec2 fragCoord = uv * iResolution.xy;\n    float lat = 180. * uv.y - 90.;\n    float lon = 360. * uv.x - 180.;\n    vec3 p = fromlatlon(lat, lon);\n    \n    vec2 uv2 = fragCoord / iResolution.y + 1.;\n    vec2 wiggle = vec2(FBM(vec3(50. * uv2, 1)), FBM(vec3(50. * uv2, 2))) - 0.5;\n    \n    float height = MAP_HEIGHT(buf(fragCoord).z);\n    float density = 0.75;\n    if (height >= 0.) {\n        float width = 3e-3;\n        density += 0.5 * network(100. * uv2 + 1.0 * wiggle, 100. * width);\n        density += 1.0 * network( 30. * uv2 + 0.3 * wiggle,  30. * width);\n        density += 2.0 * network( 10. * uv2 + 0.1 * wiggle,  10. * width);\n        density += smoothstep(0.1, 0., height); // coast\n        density *= 0.1 + clamp(2. * FBM(12. * p) - 0.5, 0., 1.);\n        density *= 0.2 + 1.3 * clamp(2. * FBM(1.5 * p) - 0.67, 0., 1.);\n    }\n    float cities = speckle(1000. * uv, density);\n    cities *= 0.5 * FBM(vec3(50. * uv, iTime));\n    \n    float human = max(-texture(iChannel3, uv).z, 0.);\n    float temp = climate(fragCoord, PASS3).y;\n    vec3 night = vec3(0.00, 0.00, 0.01);\n    if (height > 0.) {\n        night = vec3(0.00, 0.00, 0.02);\n        night *= 1. + 1.5 * clamp(FBM(50. * p) - 0.15, 0., 1.);\n    }\n    if (human > 0.) {\n        float pop = FBM(vec3(fragCoord,0)) + 0.1;\n        pop += clamp(FBM(vec3(fragCoord/7.,0)) - 0.5, 0., 0.25);\n        pop = clamp(2. * pop - 1., 0., 1.);\n        float lit = pow(pop, 4.) * (0.67 + 0.33 * sin(2.*PI * (hash12(fragCoord) + iTime)));\n        vec3 lights = vec3(0.95, 0.76, 0.47);\n        lights = mix(lights, vec3(0.91, 0.14, 0.16), smoothstep(30., 35., temp));\n        night = mix(night, 0.75 * sqrt(density) * lights, smoothstep(0., 1., cities * human));\n        night = clamp(night, 0., 1.);\n    }\n    return vec4(night, 1);\n}\n\nvec4 background(vec2 fragCoord) {\n    vec2 p = (2. * fragCoord.xy - iResolution.xy) / iResolution.x;\n    return vec4(vec3(0.01) * (1. - length(p)/2.), 1.);\n}\n\nvec2 project(vec2 fragCoord, float scale, float zoom) {\n    vec2 p = (2. * fragCoord.xy - iResolution.xy) / iResolution.x;\n    p /= scale;\n    vec3 dir = normalize(vec3(PI * p, -zoom * (CAMERA_DIST - 1.)));\n    float b = CAMERA_DIST * dir.z;\n    float h = b*b - CAMERA_DIST*CAMERA_DIST + 1.;\n    if (h >= 0.) {\n        vec3 q = vec3(0., 0., CAMERA_DIST) - dir * (b + sqrt(h));\n        p = zoom * vec2(atan(q.x, q.z) / PI, 0.5 - acos(q.y / length(q)) / PI);\n    } else {\n        return vec2(0,99);\n    }\n    return p;\n}\n\nvec4 unwrap(vec2 fragCoord) {\n    vec4 col = background(fragCoord);\n    float scale = mix(0.2, 1., smoothstep(-1., 1., iTime / LAND_START_TIME));\n    float zoom = pow(2. * clamp((iTime - OCEAN_START_TIME)/5., 0., 1.), 5.) + 1.;\n    vec2 p = project(fragCoord, scale, zoom);\n    if (p.y < 1.) {\n        p.x += 5. * (1. - smoothstep(-1., 1., iTime / LAND_START_TIME));\n        if (iTime < OCEAN_START_TIME) p.x = mod(p.x + 1., 2.) - 1.;\n        p.y = mix(p.y, fragCoord.y/iResolution.y - 0.5, smoothstep(0., 5., iTime - OCEAN_START_TIME));\n        vec2 uv = vec2(0.5 * p.x + 0.5, p.y + 0.5);\n        if (abs(p.y) <= 0.5 && abs(p.x) <= 1.) col = map(uv);\n    }\n    return col;\n}\n\nvec4 rewrap(vec2 fragCoord) {\n    vec4 col = background(fragCoord);\n    float t = clamp((iTime - (SLOWING_START_TIME - 10.))/10., 0., 1.);\n    float scale = 1.;\n    float zoom = pow(2. - 2. * t, 5.) + 1.;\n    vec2 p = project(fragCoord, scale, zoom);\n    if (p.y < 1.) {\n        p.y = mix(fragCoord.y/iResolution.y - 0.5, p.y, smoothstep(-10., 0., iTime - SLOWING_START_TIME));\n        vec2 uv = vec2(0.5 * p.x + 0.5, p.y + 0.5);\n        if (abs(p.y) <= 0.5 && abs(p.x) <= 1.) col = map(uv);\n    }\n    return col;\n}\n\nvec4 marble(vec2 fragCoord) {\n    vec2 p = (2. * fragCoord.xy - iResolution.xy) / iResolution.x;\n    float lat = 0.;//15. * sin(0.1 * iTime);\n    float lon = -5. * max(iTime - TECTONICS_END_TIME, 0.);\n    if (iMouse.z > 0.) {\n        lat = 90.  - 180. * iMouse.y/iResolution.y;\n        lon = 180. - 360. * iMouse.x/iResolution.x;\n    }\n    vec3 camPos = CAMERA_DIST * fromlatlon(lat, lon);\n    vec3 w = normalize(-camPos);\n    vec3 u = normalize(cross(w, vec3(0,1,0)));\n    vec3 v = normalize(cross(u, w));\n    mat3 camera = mat3(u, v, w);\n    \n    float scale = mix(1. / PI, 0.9 * iResolution.y / iResolution.x,\n                      smoothstep(SLOWING_START_TIME, TECTONICS_END_TIME, iTime));\n    \n    vec3 sun = sun_pos(iTime);\n    vec3 dir = normalize(camera * vec3(p / scale, length(camPos) - 1.));\n    \n    vec4 fragColor = background(fragCoord);\n    \n\tvec2 f = ray_vs_sphere(camPos, dir, 1.);\n    float dist = f.x;\n#ifdef DISABLE_SCATTERING\n    vec3 atmosphere = vec3(0);\n#else\n\tvec2 e = ray_vs_sphere(camPos, dir, R_INNER + ATMOSPHERE_THICKNESS);\n\tif (e.x > e.y) return fragColor;\n\te.y = min(e.y, f.x);\n    vec3 atmosphere = in_scatter(camPos, dir, e, sun);\n#endif\n    vec3 col = fragColor.rgb;\n    vec3 day = fragColor.rgb;\n    \n    float overlay_vis = smoothstep(0., 5., iTime - CO2_START_TIME + lat/90.);\n    overlay_vis *= smoothstep(0., -5., iTime - OVERLAY_END_TIME);\n    if (iTime < STORY_END_TIME) atmosphere *= 1. - overlay_vis;\n    \n    if (f.x < f.y) {\n        vec3 q = camPos + dir * dist;\n        float lat = 90. - acos(q.y / length(q)) * 180./PI;\n        float lon = atan(q.x, q.z) * 180./PI;\n        vec2 uv = vec2(lon/360., lat/180.) + 0.5;\n        day = map(uv).rgb;\n        vec3 night = map_night(uv).rgb;\n        float light = dot(q, sun);\n        col = mix(night, day, smoothstep(-0.1, 0.1, light));\n        col = mix(col, night, overlay_vis);\n        vec4 co2 = map_co2(uv * iResolution.xy);\n        vec4 overlay = mix(co2, vec4(0), smoothstep(0., 5., iTime - WARMING_START_TIME + lat/90.));\n        col += atmosphere;\n        col = mix(col, overlay.rgb, 0.5 * overlay.a * overlay_vis);\n    } else {\n        col += atmosphere;\n    }\n    \n    fragColor.rgb = mix(day, col, smoothstep(SLOWING_START_TIME, DAYNIGHT_START_TIME, iTime));\n    \n    return fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if (iTime < LAND_START_TIME) {\n        fragColor = unwrap(fragCoord);\n    } else if (iTime < SLOWING_START_TIME - 10.) {\n        fragColor = map(fragCoord/iResolution.xy);\n    } else if (iTime < SLOWING_START_TIME) {\n        fragColor = rewrap(fragCoord);\n    } else if (iTime < STORY_END_TIME) {\n        fragColor = marble(fragCoord);\n        fragColor *= smoothstep(0., -10., iTime - STORY_END_TIME);\n    }\n#ifndef DISABLE_MINIGAME\n    else if (keypress(KeyS)) {\n        fragColor = marble(fragCoord);\n    } else {\n        fragColor = map(fragCoord/iResolution.xy);\n        fragColor *= smoothstep(0., 5., iTime - STORY_END_TIME);\n    }\n#endif\n    fragColor.rgb = pow(fragColor.rgb, vec3(1./1.5));\n    fragColor.a = 1.;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define OCEAN_START_TIME 15.\n#define LAND_START_TIME 20.\n#define OCEAN_END_TIME 25.\n#define LAND_END_TIME 30.\n#define SLOWING_START_TIME 113.\n#define DAYNIGHT_START_TIME 120.\n#define HUMAN_START_TIME 125.\n#define TECTONICS_END_TIME 126.\n#define CO2_START_TIME 180.\n#define WARMING_START_TIME 200.\n#define WARMING_END_TIME 220.\n#define OVERLAY_END_TIME 230.\n#define MUSIC_END_TIME 235.\n#define STORY_END_TIME 250.\n\n#define OCEAN_DEPTH ocean_depth(iTime)\n\n#define ATMOSPHERE_THICKNESS 0.2\n\n#define MAP_HEIGHT(y) (0.4 * max(0., (y) - OCEAN_DEPTH))\n\n#define MAP_LOD max(1., floor(log2(iResolution.x / 144.)))\n#define MAP_ZOOM pow(2., MAP_LOD)\n#define MAP_RES (iResolution.xy / MAP_ZOOM)\n\n#define PASS1 vec2(0.0,0.0)\n#define PASS2 vec2(0.0,0.5)\n#define PASS3 vec2(0.5,0.0)\n#define PASS4 vec2(0.5,0.5)\n\n#define N  vec2( 0, 1)\n#define NE vec2( 1, 1)\n#define E  vec2( 1, 0)\n#define SE vec2( 1,-1)\n#define S  vec2( 0,-1)\n#define SW vec2(-1,-1)\n#define W  vec2(-1, 0)\n#define NW vec2(-1, 1)\n\n#define PI 3.14159265359\n\n#define KeyC 67\n#define KeyD 68\n#define KeyF 70\n#define KeyL 76\n#define KeyR 82\n#define KeyS 83\n#define KeyT 84\n#define KeyU 85\n#define KeyW 87\n\nfloat hash13(vec3);\nvec2 plate_move(float q, int iFrame, float iTime) {\n    if (iTime >= TECTONICS_END_TIME && iTime < STORY_END_TIME) return vec2(0);\n    vec2 v = vec2(cos(2.*PI*q), sin(2.*PI*q));\n    if (hash13(vec3(v,iFrame)) < 0.05) {\n        if (hash13(vec3(v+1.,iFrame)) < abs(v.x) / (abs(v.x) + abs(v.y))) {\n            return vec2(sign(v.x),0.);\n        } else {\n            return vec2(0.,sign(v.y));\n        }\n    }\n    return vec2(0);\n}\n\nfloat ocean_depth(float t) {\n    if (TECTONICS_END_TIME < t && t < STORY_END_TIME) t = TECTONICS_END_TIME;\n    float d = 7.25 + 0.25 * sin(t/5.);\n    d *= smoothstep(OCEAN_START_TIME, OCEAN_END_TIME, t);\n    return d;\n}\n\nfloat plant_growth(float moisture, float temp) {\n    float growth = clamp(moisture / 3., 0., 1.);\n    // https://www2.nrel.colostate.edu/projects/century/MANUAL/html_manual/man96.html#FIG3-8B\n    growth *= smoothstep(0., 25., temp) - smoothstep(25., 35., temp);\n    return growth;\n}\n\n\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n// https://www.shadertoy.com/view/4djSRW\n// Trying to find a Hash function that is the same on ALL systens\n// and doesn't rely on trigonometry functions that change accuracy \n// depending on GPU. \n// New one on the left, sine function on the right.\n// It appears to be the same speed, but I suppose that depends.\n\n// * Note. It still goes wrong eventually!\n// * Try full-screen paused to see details.\n\n\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n//#define HASHSCALE1 443.8975\n//#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\n// By David Hoskins, May 2014. @ https://www.shadertoy.com/view/4dsXWn\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat Noise(in vec3 p)\n{\n    vec3 i = floor(p);\n        vec3 f = fract(p); \n        f *= f * (3.0-2.0*f);\n\n    return mix(\n                mix(mix(hash13(i + vec3(0.,0.,0.)), hash13(i + vec3(1.,0.,0.)),f.x),\n                        mix(hash13(i + vec3(0.,1.,0.)), hash13(i + vec3(1.,1.,0.)),f.x),\n                        f.y),\n                mix(mix(hash13(i + vec3(0.,0.,1.)), hash13(i + vec3(1.,0.,1.)),f.x),\n                        mix(hash13(i + vec3(0.,1.,1.)), hash13(i + vec3(1.,1.,1.)),f.x),\n                        f.y),\n                f.z);\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 ) * 1.7;\n\nfloat FBM( vec3 p )\n{\n    float f;\n\n        f = 0.5000 * Noise(p); p = m*p;\n        f += 0.2500 * Noise(p); p = m*p;\n        f += 0.1250 * Noise(p); p = m*p;\n        f += 0.0625   * Noise(p); p = m*p;\n        f += 0.03125  * Noise(p); p = m*p;\n        f += 0.015625 * Noise(p);\n    return f;\n}\n\n\n// Written by GLtracy\n// https://www.shadertoy.com/view/lslXDr\n\n// ray intersects sphere\n// e = -b +/- sqrt( b^2 - c )\nvec2 ray_vs_sphere( vec3 p, vec3 dir, float r ) {\n\tfloat b = dot( p, dir );\n\tfloat c = dot( p, p ) - r * r;\n\t\n\tfloat d = b * b - c;\n\tif ( d < 0.0 ) {\n\t\treturn vec2( 1e4, -1e4 );\n\t}\n\td = sqrt( d );\n\t\n\treturn vec2( -b - d, -b + d );\n}\n\n// Mie\n// g : ( -0.75, -0.999 )\n//      3 * ( 1 - g^2 )               1 + c^2\n// F = ----------------- * -------------------------------\n//      8pi * ( 2 + g^2 )     ( 1 + g^2 - 2 * g * c )^(3/2)\nfloat phase_mie( float g, float c, float cc ) {\n\tfloat gg = g * g;\n\t\n\tfloat a = ( 1.0 - gg ) * ( 1.0 + cc );\n\n\tfloat b = 1.0 + gg - 2.0 * g * c;\n\tb *= sqrt( b );\n\tb *= 2.0 + gg;\t\n\t\n\treturn ( 3.0 / 8.0 / PI ) * a / b;\n}\n\n// Rayleigh\n// g : 0\n// F = 3/16PI * ( 1 + c^2 )\nfloat phase_ray( float cc ) {\n\treturn ( 3.0 / 16.0 / PI ) * ( 1.0 + cc );\n}\n\n// scatter const\nconst float R_INNER = 1.0;\n//const float R = R_INNER + 0.5;\n\nconst int NUM_OUT_SCATTER = 8;\nconst int NUM_IN_SCATTER = 80;\n\nfloat density( vec3 p, float ph ) {\n\treturn exp( -max( length( p ) - R_INNER, 0.0 ) / ATMOSPHERE_THICKNESS / ph );\n}\n\nfloat optic( vec3 p, vec3 q, float ph ) {\n\tvec3 s = ( q - p ) / float( NUM_OUT_SCATTER );\n\tvec3 v = p + s * 0.5;\n\t\n\tfloat sum = 0.0;\n\tfor ( int i = 0; i < NUM_OUT_SCATTER; i++ ) {\n\t\tsum += density( v, ph );\n\t\tv += s;\n\t}\n\tsum *= length( s );\n\t\n\treturn sum;\n}\n\nvec3 in_scatter( vec3 o, vec3 dir, vec2 e, vec3 l ) {\n\tconst float ph_ray = 0.05;\n    const float ph_mie = 0.02;\n    \n    const vec3 k_ray = vec3( 3.8, 13.5, 33.1 );\n    const vec3 k_mie = vec3( 21.0 );\n    const float k_mie_ex = 1.1;\n    \n\tvec3 sum_ray = vec3( 0.0 );\n    vec3 sum_mie = vec3( 0.0 );\n    \n    float n_ray0 = 0.0;\n    float n_mie0 = 0.0;\n    \n\tfloat len = ( e.y - e.x ) / float( NUM_IN_SCATTER );\n    vec3 s = dir * len;\n\tvec3 v = o + dir * ( e.x + len * 0.5 );\n    \n    for ( int i = 0; i < NUM_IN_SCATTER; i++, v += s ) {   \n\t\tfloat d_ray = density( v, ph_ray ) * len;\n        float d_mie = density( v, ph_mie ) * len;\n        \n        n_ray0 += d_ray;\n        n_mie0 += d_mie;\n        \n#if 0\n        vec2 e = ray_vs_sphere( v, l, R_INNER );\n        e.x = max( e.x, 0.0 );\n        if ( e.x < e.y ) {\n           continue;\n        }\n#endif\n        \n        vec2 f = ray_vs_sphere( v, l, R_INNER + ATMOSPHERE_THICKNESS );\n\t\tvec3 u = v + l * f.y;\n        \n        float n_ray1 = optic( v, u, ph_ray );\n        float n_mie1 = optic( v, u, ph_mie );\n\t\t\n        vec3 att = exp( - ( n_ray0 + n_ray1 ) * k_ray - ( n_mie0 + n_mie1 ) * k_mie * k_mie_ex );\n        \n\t\tsum_ray += d_ray * att;\n        sum_mie += d_mie * att;\n\t}\n\t\n\tfloat c  = dot( dir, -l );\n\tfloat cc = c * c;\n    vec3 scatter =\n        sum_ray * k_ray * phase_ray( cc ) +\n     \tsum_mie * k_mie * phase_mie( -0.78, c, cc );\n    \n\t\n\treturn 10.0 * scatter;\n}\n\n// angle : pitch, yaw\nmat3 rot3xy( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\n// ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( radians( 90.0 - fov * 0.5 ) );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// 2018 David A Roberts <https://davidar.io>\n\n// plate tectonics and hydraulic erosion model\n\n#define buf(p) textureLod(iChannel0,fract((p)/iResolution.xy),0.)\n#define keypress(k) (texelFetch(iChannel3, ivec2(k,0), 0).x > 0.)\n\n// procedural craters based on https://www.shadertoy.com/view/MtjGRD\nfloat craters(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    float va = 0.;\n    float wt = 0.;\n    for (int i = -2; i <= 2; i++) for (int j = -2; j <= 2; j++) for (int k = -2; k <= 2; k++) {\n        vec3 g = vec3(i,j,k);\n        vec3 o = 0.8 * hash33(p + g);\n        float d = distance(f - g, o);\n        float w = exp(-4. * d);\n        va += w * sin(2.*PI * sqrt(d));\n        wt += w;\n\t}\n    return abs(va / wt);\n}\n\nfloat protoplanet(vec2 uv) {\n    float lat = 180. * uv.y - 90.;\n    float lon = 360. * uv.x;\n    vec3 p = 1.5 * vec3(sin(lon*PI/180.) * cos(lat*PI/180.), sin(lat*PI/180.), cos(lon*PI/180.) * cos(lat*PI/180.));\n    float x = 0.;\n    for (float i = 0.; i < 5.; i++) {\n        float c = craters(0.4 * pow(2.2, i) * p);\n        float noise = 0.4 * exp(-3. * c) * FBM(10. * p);\n        float w = clamp(3. * pow(0.4, i), 0., 1.);\n\t\tx += w * (c + noise);\n\t}\n    return pow(x, 3.);\n}\n\nvec2 move(float q) {\n    return plate_move(q, iFrame, iTime);\n}\n\nfloat slope(vec2 p, vec2 q) {\n    if (p == q) return 0.;\n    return (buf(q).z - buf(p).z) / distance(p,q);\n}\n\nvec2 rec(vec2 p) { // direction of water flow at point\n    vec2 d = vec2(0);\n    if (slope(p + N,  p) >= slope(p + d, p)) d = N;\n    if (slope(p + NE, p) >= slope(p + d, p)) d = NE;\n    if (slope(p + E,  p) >= slope(p + d, p)) d = E;\n    if (slope(p + SE, p) >= slope(p + d, p)) d = SE;\n    if (slope(p + S,  p) >= slope(p + d, p)) d = S;\n    if (slope(p + SW, p) >= slope(p + d, p)) d = SW;\n    if (slope(p + W,  p) >= slope(p + d, p)) d = W;\n    if (slope(p + NW, p) >= slope(p + d, p)) d = NW;\n    return d;\n}\n\nvoid mainImage(out vec4 c, in vec2 p) {\n    if(iTime < OCEAN_START_TIME && iFrame % 50 < 1 || iFrame < 10) {\n        c = vec4(0);\n        c.x = -1.;\n        c.w = hash12(p);\n        c.z = clamp(15. - 3.5 * protoplanet(p / iResolution.xy), 0., 15.);\n        return;\n    }\n    \n    c = buf(p);\n    \n    if (iTime < OCEAN_START_TIME) return;\n    float smoothstart = smoothstep(OCEAN_START_TIME, OCEAN_END_TIME, iTime);\n    \n    vec4 n = buf(p + N);\n    vec4 e = buf(p + E);\n    vec4 s = buf(p + S);\n    vec4 w = buf(p + W);\n    \n    if (iTime < TECTONICS_END_TIME || iTime > STORY_END_TIME) {\n        // diffuse uplift through plate\n        float dy = 0.;\n        if (e.x == c.x) dy += e.y - c.y;\n        if (w.x == c.x) dy += w.y - c.y;\n        if (n.x == c.x) dy += n.y - c.y;\n        if (s.x == c.x) dy += s.y - c.y;\n        c.y = max(0., c.y + 0.1 * dy);\n    }\n    \n    // tectonic uplift\n    float max_uplift = 1.;\n    if (c.z - OCEAN_DEPTH > 1.) max_uplift = 1. / (c.z - OCEAN_DEPTH);\n    c.z += clamp(2. * c.y - 1., 0., max_uplift);\n    \n    if (c.z >= OCEAN_DEPTH - 0.05) {\n        // thermal erosion\n        float dz = 0.;\n        if (abs(e.z - c.z) > 1.) dz += e.z - c.z;\n        if (abs(w.z - c.z) > 1.) dz += w.z - c.z;\n        if (abs(n.z - c.z) > 1.) dz += n.z - c.z;\n        if (abs(s.z - c.z) > 1.) dz += s.z - c.z;\n        c.z = max(0., c.z + 0.02 * dz);\n\n        // flow accumulation\n        c.w = 1. + fract(c.w);\n        if (rec(p + N)  == -N)  c.w += floor(buf(p + N).w);\n        if (rec(p + NE) == -NE) c.w += floor(buf(p + NE).w);\n        if (rec(p + E)  == -E)  c.w += floor(buf(p + E).w);\n        if (rec(p + SE) == -SE) c.w += floor(buf(p + SE).w);\n        if (rec(p + S)  == -S)  c.w += floor(buf(p + S).w);\n        if (rec(p + SW) == -SW) c.w += floor(buf(p + SW).w);\n        if (rec(p + W)  == -W)  c.w += floor(buf(p + W).w);\n        if (rec(p + NW) == -NW) c.w += floor(buf(p + NW).w);\n\n        if (rec(p) == vec2(0)) { // local minima\n            c.z += 0.001; // extra sediment\n        } else {\n            vec4 receiver = buf(p + rec(p));\n            if (c.z >= OCEAN_DEPTH) c.w = floor(c.w) + fract(receiver.w); // basin colouring\n            // hydraulic erosion with stream power law\n            float pslope = (c.z - receiver.z) / length(rec(p));\n            float dz = min(pow(floor(c.w), 0.8) * pow(pslope, 2.), c.z);\n            dz *= smoothstart;\n            c.z = max(c.z - 0.05 * dz, receiver.z);\n        }\n    } else {\n        c.w = fract(c.w);\n    }\n\t\n    // approximation of sediment accumulation\n    if (iTime < TECTONICS_END_TIME || iTime > STORY_END_TIME) {\n        c.z += 2.5e-4 * clamp(c.z + 2.5, 0., 10.) * smoothstart;\n    } else if (c.z >= OCEAN_DEPTH - 0.05) {\n        c.z += 2.5e-4;\n    }\n    \n    bool subduct = false;\n    float prev_uplift = c.y;\n    \n    if (iFrame % 5000 < 10) {\n        // generate new plate boundaries\n        c.x = -1.;\n    } else if (c.x < 0.) { // no plate under this point yet\n        if (length(hash33(vec3(p,iFrame))) < 7e-3) {\n            // seed a new plate with random velocity\n            c.x = fract(hash13(vec3(p,iFrame)) + 0.25);\n        } else {\n            // accretion\n            int dir = int(4.*hash13(vec3(p,iFrame)));\n            if(dir == 0) c.x = s.x;\n            if(dir == 1) c.x = w.x;\n            if(dir == 2) c.x = n.x;\n            if(dir == 3) c.x = e.x;\n        }\n        c.y = clamp(c.y, 0., 1.);\n    } else if (move(n.x) == S) {\n        if (move(c.x) != S) subduct = true;\n        c = n;\n    } else if (move(e.x) == W) {\n        if (move(c.x) != W) subduct = true;\n        c = e;\n    } else if (move(s.x) == N) {\n        if (move(c.x) != N) subduct = true;\n        c = s;\n    } else if (move(w.x) == E) {\n        if (move(c.x) != E) subduct = true;\n        c = w;\n    } else if (move(c.x) != vec2(0) && buf(p - move(c.x)).x >= 0.) {\n        // rift\n        c.x = -1.;\n        if (c.z < OCEAN_DEPTH) {\n            c.y = 0.;\n            c.z = 0.;\n        }\n        c.w = hash12(p);\n    }\n    \n    if (subduct) {\n        c.y = 1.;\n    } else if (iTime < TECTONICS_END_TIME || iTime > STORY_END_TIME) {\n        c.y = max(c.y - 1e-4, 0.);\n    }\n    \n    if (iMouse.z > 0. && iTime > STORY_END_TIME && !keypress(KeyS)) {\n        vec2 r = (p - iMouse.xy) / 10.;\n        float magnitude = 0.5 * exp(-0.5 * dot(r,r));\n        if (keypress(KeyD)) magnitude *= -1.;\n        if (keypress(KeyU)) c.y += magnitude / 10.;\n        else c.z += magnitude;\n    }\n    \n    c.y = clamp(c.y, 0., 1.);\n    c.z = max(c.z, 0.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 15623,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/john-murphy-composer/adagio-in-d-minor-2014"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// 2018 David A Roberts <https://davidar.io>\n\n// atmospheric pressure and circulation model\n\n#define buf(uv) texture(iChannel1, uv)\n\n#define SIGMA vec4(6,4,1,0)\nvec4 normpdf(float x) {\n\treturn 0.39894 * exp(-0.5 * x*x / (SIGMA*SIGMA)) / SIGMA;\n}\n\n// mean sea level pressure\nvec4 mslp(vec2 uv) {\n    float lat = 180. * (uv.y * iResolution.y / MAP_RES.y) - 90.;\n    float y = textureLod(iChannel0, uv * MAP_ZOOM, MAP_LOD).z;\n    float height = MAP_HEIGHT(y);\n    vec4 r;\n    if (y > OCEAN_DEPTH) { // land\n        r.x = 1012.5 - 6. * cos(lat*PI/45.); // annual mean\n        r.y = 15. * sin(lat*PI/90.); // January/July delta\n    } else { // ocean\n        r.x = 1014.5 - 20. * cos(lat*PI/30.);\n        r.y = 20. * sin(lat*PI/35.) * abs(lat)/90.;\n    }\n    r.z = height;\n    return r;\n}\n\n// horizontally blurred MSLP\nvec4 pass1(vec2 uv) {\n    vec4 r = vec4(0);\n    for (float i = -20.; i <= 20.; i++)\n        r += mslp(uv + i*E/iResolution.xy) * normpdf(i);\n    return r;\n}\n\n// fully blurred MSLP\nvec4 pass2(vec2 uv) {\n    vec4 r = vec4(0);\n    for (float i = -20.; i <= 20.; i++)\n        r += buf(uv + i*N/iResolution.xy + PASS1) * normpdf(i);\n    return r;\n}\n\n// time-dependent MSLP and temperature\nvec4 pass3(vec2 uv) {\n    vec4 c = buf(uv + PASS2);\n    float t = mod(iTime/2., 12.); // simulated month of the year\n    float delta = 1. - 2. * smoothstep(1.5, 4.5, t) + 2. * smoothstep(7.5, 10.5, t);\n    float mbar = c.x + c.y * delta;\n    \n    float lat = 180. * (uv.y * iResolution.y / MAP_RES.y) - 90.;\n    float land = step(OCEAN_DEPTH, textureLod(iChannel0, uv * MAP_ZOOM, MAP_LOD).z);\n    float height = c.z;\n    float temp = -27. + 73. * tanh(2.2 * exp(-0.5 * pow((lat + 5. * delta)/30., 2.)));\n    temp -= mbar - 1012.;\n    temp /= 1.8;\n    temp += 1.5 * land;\n    float th = 4.;\n    \n    if (iTime > WARMING_START_TIME && iTime < STORY_END_TIME + 15.) {\n        // approximation of CO2 forcing\n        // https://www.nature.com/articles/nclimate3036\n        float temp2 = 9. + 50. * tanh(2.2 * exp(-0.5 * pow((lat + 5. * delta)/30., 2.)));\n        temp2 -= mbar - 1012.;\n        temp2 /= 1.8;\n        temp2 += 4. * land;\n        float th2 = 3.;\n        float m = smoothstep(WARMING_START_TIME, WARMING_END_TIME, iTime);\n        m -= smoothstep(5., 15., iTime - STORY_END_TIME);\n        temp = mix(temp, temp2, m);\n        th = mix(th, th2, m);\n    }\n    \n    return vec4(mbar, temp - th * height, temp, 0);\n}\n\n// wind vector field\nvec4 pass4(vec2 uv) {\n    vec2 p = uv * iResolution.xy;\n    float n = buf(mod(p + N, MAP_RES)/iResolution.xy + PASS3).x;\n    float e = buf(mod(p + E, MAP_RES)/iResolution.xy + PASS3).x;\n    float s = buf(mod(p + S, MAP_RES)/iResolution.xy + PASS3).x;\n    float w = buf(mod(p + W, MAP_RES)/iResolution.xy + PASS3).x;\n    vec2 grad = vec2(e - w, n - s) / 2.;\n    float lat = 180. * fract(uv.y * iResolution.y / MAP_RES.y) - 90.;\n    vec2 coriolis = 15. * sin(lat*PI/180.) * vec2(-grad.y, grad.x);\n    vec2 v = coriolis - grad;\n    return vec4(v,0,0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    if (uv.x < 0.5) {\n        if (uv.y < 0.5) {\n    \t\tfragColor = pass1(uv - PASS1);\n        } else {\n    \t\tfragColor = pass2(uv - PASS2);\n        }\n    } else {\n        if (uv.y < 0.5) {\n    \t\tfragColor = pass3(uv - PASS3);\n        } else {\n    \t\tfragColor = pass4(uv - PASS4);\n        }\n    }\n    \n    int x = int(fragCoord.x);\n    int y = int(fragCoord.y);\n    if (x < 256 && y < 3) fragColor.w = texelFetch(iChannel3, ivec2(x,y), 0).x;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// 2018 David A Roberts <https://davidar.io>\n\n// wind flow map, atmospheric water vapour, and air pollution model\n\nfloat map(vec2 fragCoord) {\n    return MAP_HEIGHT(texture(iChannel0, fragCoord/iResolution.xy).z);\n}\n\nvec2 getVelocity(vec2 uv) {\n    vec2 p = uv * MAP_RES;\n    if (p.x < 0.5) p.x = 0.5;\n    vec2 v = texture(iChannel1, p/iResolution.xy + PASS4).xy;\n    if (length(v) > 1.) v = normalize(v);\n    return v;\n}\n\nvec2 getPosition(vec2 fragCoord) {\n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n            vec2 uv = (fragCoord + vec2(i,j)) / iResolution.xy;\n            vec2 p = texture(iChannel2, fract(uv)).xy;\n            if(p.x == 0.) {\n                if (hash13(vec3(fragCoord + vec2(i,j), iFrame)) > 1e-4) continue;\n                p = fragCoord + vec2(i,j) + hash21(float(iFrame)) - 0.5; // add particle\n            } else if (hash13(vec3(fragCoord + vec2(i,j), iFrame)) < 8e-3) {\n                continue; // remove particle\n            }\n            vec2 v = getVelocity(uv);\n            p = p + v;\n            p.x = mod(p.x, iResolution.x);\n            if(abs(p.x - fragCoord.x) < 0.5 && abs(p.y - fragCoord.y) < 0.5)\n                return p;\n        }\n    }\n    return vec2(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if (iFrame < 10) {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    vec4 c = texture(iChannel2, fragCoord/iResolution.xy);\n    float particle = (c.x > 0.) ? 1. : 0.9 * c.y;\n    vec2 p = getPosition(fragCoord);\n    fragColor.xy = (p == vec2(0)) ? vec2(0., particle) : p;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 v = getVelocity(uv);\n    vec2 vn = getVelocity(uv + N/iResolution.xy);\n    vec2 ve = getVelocity(uv + E/iResolution.xy);\n    vec2 vs = getVelocity(uv + S/iResolution.xy);\n    vec2 vw = getVelocity(uv + W/iResolution.xy);\n    float div = (ve - vw).x/2. + (vn - vs).y/2.;\n    \n    float height = map(fragCoord);\n    float hn = map(fragCoord + N);\n    float he = map(fragCoord + E);\n    float hs = map(fragCoord + S);\n    float hw = map(fragCoord + W);\n    vec2 hgrad = vec2(he - hw, hn - hs)/2.;\n    \n    vec4 climate = texture(iChannel1, uv * MAP_RES / iResolution.xy + PASS3);\n    float mbar = climate.x;\n    float temp = climate.y;\n    c = texture(iChannel2, fract((fragCoord - v) / iResolution.xy));\n    \n    // water vapour advection\n    float w = c.w;\n    float noise = clamp(3. * FBM(vec3(5. * fragCoord/iResolution.xy, iTime)) - 1., 0., 1.);\n    if (iTime < OCEAN_END_TIME) w += 0.08 * noise * (1. - smoothstep(OCEAN_START_TIME, OCEAN_END_TIME, iTime));\n    if (height == 0.) w += noise * clamp(temp + 2., 0., 100.)/32. * (0.075 - 3. * div - 0.0045 * (mbar - 1012.));\n    w -= 0.005 * w; // precipitation\n    w -= 0.3 * length(hgrad); // orographic lift\n    fragColor.w = clamp(w, 0., 3.);\n    \n    // pollution advection\n    float co2 = c.z;\n    vec4 d = texture(iChannel3, fragCoord/iResolution.xy);\n    bool human = d.z == -1.;\n    float moisture = d.w;\n    if (human) {\n        co2 += 0.015;\n    } else {\n        co2 -= 0.01 * plant_growth(moisture, temp);\n    }\n    fragColor.z = clamp(co2, 0., 3.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// 2018 David A Roberts <https://davidar.io>\n\n// soil moisture, vegetation, predator, prey, and human colonisation model\n\n#define map(p) texture(iChannel0,fract((p)/iResolution.xy))\n#define buf(p) texture(iChannel3,fract((p)/iResolution.xy))\n\nvec2 move(float q) {\n    return plate_move(q, iFrame, iTime);\n}\n\nvec4 climate(vec2 fragCoord, vec2 pass) {\n    vec2 p = fragCoord * MAP_RES / iResolution.xy;\n    if (p.x < 0.5) p.x = 0.5;\n    vec2 uv = p / iResolution.xy;\n    return texture(iChannel1, uv + pass);\n}\n\nvec2 offset(vec2 p) {\n    vec4 c = map(p);\n    vec4 n = map(p + N);\n    vec4 e = map(p + E);\n    vec4 s = map(p + S);\n    vec4 w = map(p + W);\n    if(iFrame % 3000 < 10 || c.x < 0.) { // no plate under this point\n        return vec2(0);\n    } else if (move(n.x) == S) {\n        return N;\n    } else if (move(e.x) == W) {\n        return E;\n    } else if (move(s.x) == N) {\n        return S;\n    } else if (move(w.x) == E) {\n        return W;\n    } else if (move(c.x) != vec2(0) && map(p - move(c.x)).x >= 0.) { // rift\n        return vec2(0);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if (iTime < OCEAN_START_TIME) {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    float height = MAP_HEIGHT(texture(iChannel0, fragCoord/iResolution.xy).z);\n    float temp = climate(fragCoord, PASS3).y;\n    float vapour = texture(iChannel2, fragCoord/iResolution.xy).w;\n    vec2 p = fragCoord + offset(fragCoord);\n    vec4 c = buf(p);\n    float moisture = c.w;\n    moisture *= 1. - 1e-5 * moisture * clamp(temp, 0., 15.);\n    if (iTime > OCEAN_END_TIME) moisture += 3. * clamp(vapour, 0., 0.01);\n    moisture = clamp(moisture, 0., 5.);\n    if (height == 0.) moisture = 5.;\n    \n    if (iTime < OCEAN_END_TIME) {\n        c.xyz = hash32(fragCoord) * vec3(0.5, 1., 2.);\n    } else if(height > 0.) {\n        float reproduction = 2. + clamp(temp, -15., 15.)/30.;\n        // easier for prey to evade predators at higher altitudes which tend to have more hiding places\n        float evasion = clamp(height, 0.5, 1.5);\n        float predation = 2. - evasion;\n        \n        // generalised Lotka-Volterra equations\n        float vege = c.x;\n        float prey = c.y;\n        float pred = max(c.z, 0.);\n        float human = max(-c.z, 0.);\n        float dvege = plant_growth(moisture, temp) - prey;\n        float dprey = reproduction * vege - predation * pred - 0.5;\n        float dpred = predation * prey - 1.;\n        float dt = 0.1;\n        vege += dt * vege * dvege;\n        prey += dt * prey * dprey;\n        pred += dt * pred * dpred;\n        c.xyz = clamp(vec3(vege, prey, pred), 0.01, 5.);\n\n        // diffusion\n        vec4 n = buf(p + N);\n        vec4 e = buf(p + E);\n        vec4 s = buf(p + S);\n        vec4 w = buf(p + W);\n        c.xyz += dt * (max(n,0.) + max(e,0.) + max(s,0.) + max(w,0.) - 4. * c).xyz * vec3(0.25, 0.5, 1.);\n        \n        if (iTime > STORY_END_TIME) {\n            human = 0.;\n        } else if (iTime > HUMAN_START_TIME && iTime < WARMING_START_TIME &&\n                   moisture > 4.9 && 5. < temp && temp < 30.) {\n            int dir = int(4.*hash13(vec3(p,iFrame)));\n            if (length(hash33(vec3(p,iFrame))) < 1e-2) human = 1.;\n            if ((dir == 0 && s.z == -1.) ||\n                (dir == 1 && w.z == -1.) ||\n                (dir == 2 && n.z == -1.) ||\n                (dir == 3 && e.z == -1.)) {\n                human = 1.;\n            }\n        } else if (temp > 35.) {\n            // approximating the maximum wet-bulb temperature by the average (dry-bulb) air temperature\n            // sustained wet-bulb temperature above 35C is fatal for humans:\n            // http://www.pnas.org/content/107/21/9552\n            // photosynthesis of crops also becomes ineffective at similar temperatures\n            human -= 0.01;\n        }\n        if (human > 0.) c.z = -human;\n    } else {\n        c.xyz = vec3(0);\n    }\n    \n    fragColor = vec4(c.xyz, moisture);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}