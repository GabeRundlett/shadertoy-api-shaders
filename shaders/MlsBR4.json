{
    "Shader": {
        "info": {
            "date": "1513029731",
            "description": "Procedural Planet",
            "flags": 32,
            "hasliked": 0,
            "id": "MlsBR4",
            "likes": 16,
            "name": "Spinning Planet",
            "published": 3,
            "tags": [
                "planet"
            ],
            "usePreview": 0,
            "username": "marian42",
            "viewed": 930
        },
        "renderpass": [
            {
                "code": "const float pi = 3.141592;\nconst float waterThreshold = 0.54;\nconst vec3 lightDir = normalize(vec3(-0.7, 0.7, 0.9));\nconst vec3 glow = vec3(0.168, 0.208, 0.5);\n\nfloat map(float value, float fromStart, float fromEnd, float toStart, float toEnd) {\n\treturn toStart + (toEnd - toStart) * (value - fromStart) / (fromEnd - fromStart);   \n}\n\nvec4 getTexValue(float phi, float theta) {\n\treturn texture(iChannel0, vec2(fract(theta / 2.0 / pi), phi / pi));\n}\n\nvec3 blendColors(vec3 color1, vec3 color2, float progress, float gradientPosition, float gradientSize) {\n    float v = (progress - gradientPosition + gradientSize) / 2.0 / gradientSize;\n    return mix(color1, color2, clamp(v, 0.0, 1.0));\n}\n\nvec3 getWater(float height, vec3 viewDir, vec3 normal, vec3 world) {\n\tconst vec3 deepWater = vec3(0.04, 0.36, 0.83);\n    const vec3 shallowWater = vec3(0.29, 0.76, 0.93);\n    \n    vec3 color = blendColors(deepWater * (0.6 + 0.4 * clamp(height * 1.4, 0.0, 1.0)), shallowWater, height, 0.995, 0.03);\n    \n    float ambient = 0.05;\n\tfloat diffuse = mix(max(0.0, dot(lightDir, normal)), max(0.0, dot(lightDir, world)), 0.85);\n\tvec3 R = reflect(-lightDir, world);\n\tfloat specular = pow(max(0.0, dot(R, viewDir)), 6.0);\n    float light = ambient + 0.8 * diffuse + 0.5 * specular;\n    return light * color;\n}\n\nvec3 getLand(float height, vec3 viewDir, vec3 normal, vec3 world) {\n\tconst vec3 forest = vec3(0.12, 0.52, 0.17);\n    const vec3 desert = vec3(0.937, 0.922, 0.757);\n    const vec3 ice = vec3(1.0);\n    \n    float latitude = asin(abs(world.y));\n    \n    vec3 color = blendColors(forest, ice, latitude, 1.1 + 0.3 * height, 0.02);\n    color = blendColors(desert, color, latitude, 0.25 + 0.3 * height, 0.15);\n    \n    float ambient = 0.05;\n\tfloat diffuse = mix(max(0.0, dot(lightDir, normal)), max(0.0, dot(lightDir, world)), 0.7);\n\tcolor *= ambient + 0.8 * diffuse;\n    return color;\n}\n\nvec3 getColor(vec3 pos, vec3 viewDir) {    \n    float theta = acos(pos.y);\n    float phi = 2.0 * pi * fract((atan(pos.x, pos.z)) / (2.0 * pi));\n    \n    vec4 texValue = getTexValue(theta, phi + iTime * 0.4);\n    float height = texValue.r;\n    \n    const float bumpiness = 0.3;    \n    vec3 normal = normalize(pos\n                      + bumpiness * texValue.g * vec3(-sin(theta) * sin(phi), 0.0, sin(theta) * cos(phi))\n                      + bumpiness * texValue.b * vec3(cos(theta) * cos(phi), -sin(theta), cos(theta) * sin(phi)));\n    \n    vec3 color;\n   \tif (height < waterThreshold) {\n        color = getWater(height / waterThreshold, viewDir, normal, pos);\n    } else {\n        color = getLand(map(height, waterThreshold, 1.0, 0.0, 1.0), viewDir, normal, pos);\n    }\n    \n    color = mix(color, vec3(max(0.0, dot(lightDir, pos))), texValue.a);\n    return color;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / iResolution.xy - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 2.2;\n    float radiusSquared = pow(uv.x, 2.0) + pow(uv.y, 2.0);\n    float radius = sqrt(radiusSquared);\n    vec3 world = vec3(uv.x, uv.y, sqrt(1.0 - radiusSquared));\n    vec3 viewDir = vec3(0.0, 0.0, 1.0);\n\tfragColor = vec4(0, 0, 0, 1.0);\n    if (radius < 1.0) {\n    \tvec3 surfaceColor = getColor(world, viewDir);\n        float rim = 1.0 - dot(viewDir, world);\n        fragColor.rgb = mix(surfaceColor, glow, 0.8 * pow(rim, 5.0));\n    } else {\n    \tradius -= 1.0;\n        fragColor.rgb = mix(glow, vec3(0.0, 0.0, 0.0), pow(radius / 0.08, 0.6));\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float pi = 3.141592;\n\nfloat map(float value, float fromStart, float fromEnd, float toStart, float toEnd) {\n\treturn toStart + (toEnd - toStart) * (value - fromStart) / (fromEnd - fromStart);   \n}\n\n\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nvec3 noise3(vec3 p) {\n\treturn vec3(noise(p + vec3(0.268, 0.920, 0.015)),\n                noise(p + vec3(0.143, 0.920, 0.578)),\n                noise(p + vec3(0.229, 0.793, 0.670)));\n}\n\nfloat getOctaves(vec3 p, float octaves) {\n\tfloat result = 0.0;\n    for (float octave = 0.0; octave < octaves; octave += 1.0) {\n    \tresult += pow(2.0, -octave) * noise(p * pow(2.0, octave));\n    }\n    float maxValue = 2.0 - pow(2.0, -octaves + 1.0);\n    return result / maxValue;\n}\n\nconst float iceCapStart = 0.85;\n\nfloat getHeight(float phi, float theta) {\n    vec3 world = vec3(sin(theta) * cos(phi), cos(theta), sin(theta) * sin(phi));\n    //world += vec3(1.0, 0.0, 0.0) * iTime * 0.5;\n    vec3 warp = noise3(world * 3.0);\n    vec3 sampleAt = world * 1.5 + warp * 0.2;\n    float result = getOctaves(sampleAt, 12.0);\n    \n    if (abs(world.y) > iceCapStart) {\n    \tresult = mix(result, 1.0, pow((abs(world.y) - iceCapStart) / 0.2, 4.0));   \n    }\n    \n    return result;\n}\n\nfloat getClouds(float phi, float theta) {\n    vec3 world = vec3(sin(theta) * cos(phi), cos(theta), sin(theta) * sin(phi));\n    \n    vec3 warp = noise3(world * 6.0);\n    \n    float clouds = getOctaves(world * 2.2 + warp * 1.0, 8.0);\n    return clamp((pow(clouds, 2.0) - 0.3) * 4.0, 0.0, 1.0);\n}\n\n\nvoid initialize(out vec4 fragColor, in vec2 uv) {\n   \tfloat phi = uv.x * 2.0 * pi;\n    float theta = uv.y * pi;\n    \n    const float dPhi = 0.001;\n    const float dTheta = 0.001;\n    \n    fragColor.r = getHeight(phi, theta);\n    fragColor.g = (getHeight(phi + dPhi, theta) - getHeight(phi - dPhi, theta)) / (2.0 * dPhi);\n    fragColor.b = (getHeight(phi, theta + dTheta) - getHeight(phi, theta + dTheta)) / (2.0 * dTheta);\n    \n    fragColor.a = getClouds(phi, theta);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (iFrame == 0) {\n    \tinitialize(fragColor, fragCoord / iResolution.xy);   \n    } else {        \n    \tfragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}