{
    "Shader": {
        "info": {
            "date": "1624102488",
            "description": "Raymarched jelly/bloby character. Another practice shader and just for fun...",
            "flags": 0,
            "hasliked": 0,
            "id": "Nlj3Dm",
            "likes": 5,
            "name": "Jelly Character",
            "published": 3,
            "tags": [
                "raymarching",
                "cartoon",
                "character",
                "toon"
            ],
            "usePreview": 0,
            "username": "propagant",
            "viewed": 336
        },
        "renderpass": [
            {
                "code": "//Raymarched random jelly character by Matej Vanco, 2021\n\n#define ITER 64\n#define MAXD 64.0\n#define SURD 0.005\n#define BGC vec3(0.45,0.24,0.1) * 4.\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n#define noise(p, a, s, d) cos(-p * a + iTime * s) * d;\n\n\nstruct ray\n{\n    vec3 o,d;\n    float l;\n};\n\n//Iq's smooth opu\nvec4 opu(vec4 a, vec4 b, float s)\n{\n    float k = s;\n    float d1 = a.w;\n    float d2 = b.w;\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return vec4(mix(b.rgb,a.rgb,h),mix( d2, d1, h ) - k*h*(1.0-h));\n}\n\n//Iq's smooth ops\nvec4 ops(vec4 a, vec4 b, float s)\n{\n    float k = s;\n    float d1 = a.w;\n    float d2 = b.w;\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return vec4(mix(b.rgb,a.rgb,h),mix( d2, -d1, h ) + k*h*(1.0-h));\n}\n\n//Full geometry generation\nvec4 geo(vec3 p)\n{\n    p.x += noise(p.x, 39.,6.0,0.003);\n    p.y = p.y + sin(iTime * 1.5) * 0.05;\n    vec3 objCenter = vec3(0.,0.,1.0);\n    //---head\n    vec3 headCenter = objCenter + vec3(0.,0.32,-0.03);\n    vec4 s0 = vec4(vec3(.45,.34,.1), length(p - headCenter) - 0.1);\n    //mouth\n    vec4 b0 = vec4(vec3(.45,.14,.1)*0.5, length(max(abs(vec3(p.xy * rot(25.), p.z) - headCenter - vec3(0.15, -.03, -.1)) - vec3(0.12,cos(iTime * 1.5) * 0.015,.08),0.0))-0.02);\n    vec4 s0b0 = ops(b0,s0,0.05);\n\n    //---body\n    //center\n    vec4 b1 = vec4(vec3(.45,.26,.1), length(max(abs(p - objCenter - vec3(0., .0, .0)) - vec3(0.15,.2,.1),0.0))-0.01);\n    //r-l subtracted curves\n    vec4 b2 = vec4(vec3(-0.2), length(max(abs(vec3(abs(p.x),p.yz) - objCenter - vec3(0.6, -0.3, 0.0)) - vec3(0.2,.2,.1),0.0))-0.25);\n    vec4 b1b2 = ops(b2,b1,0.15) + noise(p.y, -38.,8.0,0.001);\n    //lHand\n    vec4 b3 = vec4(vec3(.45,.34,.1), length(max(abs(vec3(p.xy * rot(-35.),p.z) - objCenter - vec3(-0.215, .01, -.02)) - vec3(0.001,.1,.001),0.0))-0.05);\n    vec4 b4 = vec4(vec3(.45,.29,.1)*0.9, length(max(abs(vec3(p.xy * rot(-94.1),p.z) - objCenter - vec3(0.25, -.12, -.02)) - vec3(0.001,.07,.001),0.0))-0.03);\n    //rHand\n    vec4 b5 = vec4(vec3(.45,.34,.1), length(max(abs(vec3(p.xy * rot(-30.7),p.z) - objCenter - vec3(-0.24, -.08, -.02)) - vec3(0.001,.1,.001),0.0))-0.05);\n    vec4 b6 = vec4(vec3(.45,.29,.1)*0.9, length(max(abs(vec3(p.xy * rot(30.5),p.z) - objCenter - vec3(-0.18, .1, -.04)) - vec3(0.001,.07,.001),0.0))-0.03);\n    \n    //---legs\n    vec4 b7 = vec4(mix(vec3(.85,.54,.0), vec3(0.25,0.14,0.1), smoothstep(p.x+0.1 ,-0.25,0.01)), length(max(abs(p - objCenter - vec3(0.06, -.38, .0)) - vec3(0.015,.05,.05),0.0))-0.005) + \n    noise(p.y, -38.8,12.5,0.008);\n    vec4 b8 = vec4(vec3(.85,.1,.1)*2., length(max(abs(p - objCenter - vec3(-0.06, -.38, .0)) - vec3(0.015,.05,.05),0.0))-0.005) + \n    noise(p.y, -32.8,12.5,0.008);\n    \n    //---body joints\n    vec4 Lhand = opu(b4,b3,.05);\n    vec4 Rhand = opu(b5,b6,.05);\n    vec4 legs = opu(b7,b8,0.2);\n    \n    //---body connection\n    vec4 hands = opu(Rhand,Lhand,.05);\n    vec4 body = opu(b1b2,hands,.05);\n    vec4 full = opu(body, legs,.2);\n    \n    return opu(s0b0,full,0.05);\n}\n\n//Normals generation\nvec3 normal(vec3 p)\n{\n    vec2 o = vec2(0.001,0.);//slight offset\n    float c = geo(p).w;\n    return normalize(c - vec3(geo(p - o.xyy).w, geo(p - o.yxy).w, geo(p - o.yyx).w));\n}\n\n//Simples lighting + BlinnPhong specs\nfloat light(vec3 p)\n{\n    vec3 LP = vec3(0.2,0.5,0.5);\n    vec3 lp = normalize(LP - p);\n    vec3 n = normal(p);\n    \n    float l = clamp(dot(n,lp),0.25,1.);\n    float s = pow(max(dot(n,lp),0.),80.)*3.0;\n    \n    return pow(l + s,0.25);\n}\n\n//Raymarching core\nvec4 march(ray r)\n{\n    vec3 c = vec3(0.);\n    for(int i = 0; i < ITER; i++)\n    { \n        if(r.l > MAXD ) \n        {\n            c = BGC * 2.;\n            break;\n        }\n        vec3 p = r.o + r.d * r.l;\n        vec4 g = geo(p);\n        if(g.w < SURD) \n        {\n            c = g.rgb * 2.5;\n            break;\n        }\n        r.l += g.w;\n    }\n    return vec4(c, r.l);\n}\n\n//Output img\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    ray r = ray(vec3(0.),vec3(uv,1.0),0.);\n    vec4 m = march(r);\n    vec3 p = r.o + r.d * m.w;\n    vec3 col = vec3(m.rgb) * light(p);\n\n    fragColor = vec4(col,1.0) + 0.1;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}