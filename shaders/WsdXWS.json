{
    "Shader": {
        "info": {
            "date": "1572790115",
            "description": "Trying to do something similar to what Google gives when querying the word \"trypophobia\". \nBased on Inigo Quilez's fish demo https://www.shadertoy.com/view/ldj3Dm",
            "flags": 0,
            "hasliked": 0,
            "id": "WsdXWS",
            "likes": 17,
            "name": "Trypophobia",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "trypophobia",
                "tripophobia"
            ],
            "usePreview": 0,
            "username": "avin",
            "viewed": 831
        },
        "renderpass": [
            {
                "code": "// fun mode :)\n#define BEER_MOD false\n\n#define SKIN_COL vec3(221, 192, 148) / 255.\n\n\n//-----------------------------------------------------------------------------------\n\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 sdSurface(in vec3 p)\n{\n    p.y *= 0.39;\n\n    float h = 1.0;\n    vec3 q = p;\n\n    vec3 rp = floor(p * 2.5);\n    p = fract(p * 2.5) - 0.5;\n\n    float r1 = rand(rp.xz);\n    float r2 = rand(rp.xz * 10.0);\n    float r3 = rand(rp.xz * 13.5);    \n    h = smoothstep(length(p), 0.7 + 0.29 * r3, 0.4 + 0.1 * r2) * 0.9 * (0.5 + r1 * 0.5);\n\n    h += texture(iChannel1, 0.541 * q.xz).x * 0.075;\n    h -= texture(iChannel0, 0.1 * q.xz).x * 0.01;\n    h -= texture(iChannel0, 0.02 * q.xz).x * 0.23;\n\n    return vec3((p.y + h) * 0.1, p.x, 0.0);\n}\n\nvec3 sdEggs(in vec3 p)\n{\n    p.y = min(p.y, 0.69);\n    p.y += 0.5;    \n\n    vec3 pp = floor(p * 2.5) - 0.5;\n    float r0 = rand(pp.xz);\n\n    float k = step(.65, r0);    \n   \n    p = fract(p * 2.5) - 0.5;\n\n    float r1 = rand(pp.xz * 1.25);\n    if(!BEER_MOD){\n    \tp.y += .30 - cos(iTime * 5. + r1 * 10.) * .02;\n    }\n    \n    p.y -= clamp(p.y, 0.0, .21);\n    \n    float b = length(p) - .35 + sin(iTime * r0 * 10. * .25) * .025;    \n    return vec3(p.y * .01 + b * .15, 1., k);\n}\n\nvec4 map(in vec3 p)\n{   \n    vec4 d1 = vec4(sdSurface(p), 0.0);\n    vec4 d2 = vec4(sdEggs(p), 1.0);\n    if (d2.b > 0.) {\n        return (d2.x < d1.x) ? d2 : d1;\n    } else {\n        return d1;\n    }\n}\n\nvec4 intersect(in vec3 ro, in vec3 rd)\n{\n    const float maxd = 20.0;\n    const float precis = 0.0001;\n    float h = precis * 1.0;\n    float t = .0;\n    float m = 0.0;\n    float l = 0.0;\n    float r = 0.0;\n    for (int i = 0; i < 100; i++) {\n        vec4 res = map(ro + rd * t);\n        if (h < precis || t > maxd) {\n            break;\n        }\n\n        h = res.x;\n        l = res.y;\n        r = res.z;\n        m = res.w;\n        t += h;\n    }\n\n    if (t > maxd) {\n        m = -1.0;\n    }\n\n    return vec4(t, l, m, r);\n}\n\nvec3 calcNormal(in vec3 pos, in float e)\n{\n    vec3 eps = vec3(e, 0.0, 0.0);\n    return normalize(vec3(map(pos + eps.xyy).x - map(pos - eps.xyy).x,\n        map(pos + eps.yxy).x - map(pos - eps.yxy).x,\n        map(pos + eps.yyx).x - map(pos - eps.yyx).x));\n}\n\nvec3 lig = normalize(vec3(0.9, 0.05, 0.52));\n\nfloat softshadow(in vec3 ro, in vec3 rd, float mint, float k)\n{\n    float res = 1.0;\n    float t = mint;\n    float h = 1.0;\n    for (int i = 0; i < 40; i++) {\n        h = map(ro + rd * t).x;\n        res = min(res, smoothstep(0.0, 1.0, k * h / t));\n        t += clamp(h, 0.05, 0.5);\n        if (h < 0.0001){\n            break;\n        }            \n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x / iResolution.y;\n    vec2 m = vec2(0.5);\n    if (iMouse.z > 0.0) {\n        m = iMouse.xy / iResolution.xy;\n    }\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n\n    float an = 1.5 + 0.1 * sin(iTime * 0.17) * 2.0 - 2.0 * (m.x - .55);\n\n    vec3 ta = vec3(0.0, .0, -2.0);\n    vec3 ro = ta + vec3(4.0 * sin(an), 4.0 + cos(iTime * 0.14 + 20.0), 4.0 * cos(an));\n\n    // camera matrix\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n\n    vec3 rd = normalize(p.x * uu + p.y * vv + 2.5 * ww);\n\n    //-----------------------------------------------------\n    // render\n    //-----------------------------------------------------\n\n    vec3 col = vec3(0.4, 0.6, 0.8);\n    vec3 bcol = col;\n\n    float pt = (1.0 - ro.y) / rd.y;\n\n    vec3 oro = ro;\n    if (pt > 0.0) {\n        ro = ro + rd * pt;\n    }\n\n    // raymarch\n    vec4 tmat = intersect(ro, rd);\n    if (tmat.z > -0.5) {\n        float eps = 0.01 + 0.03 * step(0.5, tmat.z);\n        // geometry\n        vec3 pos = ro + tmat.x * rd;\n        vec3 nor = calcNormal(pos, eps);\n        vec3 ref = reflect(rd, nor);\n\n        // materials\n        vec4 mate = vec4(0.5, 0.5, 0.5, 0.0);\n\n        if (tmat.z < 1.0) {\n            vec3 te = SKIN_COL * 0.58;\n\n            mate.xyz = 0.9956 * te;\n            //mate.w = 5.0 * (0.5 + 0.5 * te.x);\n            mate.w = 0.1;\n\n            mate.xyz *= 1.5;\n        } else {\n            vec3 te = texture(iChannel1, 1.33 * pos.xz).rrr * 3.0;\n\n            mate.xyz = 0.1226 * te;\n            mate.w = 8.50;\n        }\n\n        float k = tmat.b;\n\n        // lighting\n        float sky = clamp(nor.y, 0.0, 1.0);\n        float bou = clamp(-nor.y, 0.0, 1.0);\n        float dif = max(dot(nor, lig), 0.0);\n        float bac = max(0.3 + 0.7 * dot(nor, -vec3(lig.x, 0.0, lig.z)), 0.0);\n        float sha = 0.0;\n        if (dif > 0.001){\n            sha = softshadow(pos + 0.01 * nor, lig, 0.0005, 32.0);\n        }            \n        float fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 5.0);\n        float spe = max(0.0, pow(clamp(dot(lig, reflect(rd, nor)), 0.0, 1.0), mate.w)) * mate.w;\n        float sss = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 3.0);\n\n        // lights\n        vec3 lin = vec3(0.0);\n        float cc = 0.55 * texture(iChannel2, 1.8 * 0.02 * pos.xz + 0.007 * iTime * vec2(1.0, 0.0)).x;\n        cc += 0.25 * texture(iChannel2, 1.8 * 0.04 * pos.xz + 0.011 * iTime * vec2(0.0, 1.0)).x;\n        cc += 0.10 * texture(iChannel2, 1.8 * 0.08 * pos.xz + 0.014 * iTime * vec2(-1.0, -1.0)).x;\n        cc = 0.6 * (1.0 - smoothstep(0.0, 0.025, abs(cc - 0.4))) + 0.4 * (1.0 - smoothstep(0.0, 0.150, abs(cc - 0.4)));\n        dif *= 1.0 + 2.0 * cc;\n\n        lin += 3.5 * dif * vec3(1.00, 1.00, 1.00) * sha;\n        lin += 3.0 * sky * vec3(0.10, 0.10, 0.15);\n        lin += 1.0 * bou * vec3(0.20, 0.20, 0.20);\n        lin += 2.0 * bac * vec3(0.50, 0.60, 0.70);\n        lin += 2.0 * sss * vec3(0.20, 0.20, 0.20) * (0.2 + 0.8 * dif * sha) * mate.w;\n        lin += 2.0 * spe * vec3(1.0) * sha * (0.3 + 0.7 * fre);\n\n        // surface-light interacion\n        col = mate.xyz * lin;\n\n        // fog\n        tmat.x = max(0.0, tmat.x - 1.3);\n        col *= 0.65;\n        float hh = 1.0 - exp(-0.5 * tmat.x);\n        col = col * (1.0 - hh) * (1.0 - hh) + 0.25 * vec3(0.1, 0.12, 0.2) * hh;\n    }\n\n    //-----------------------------------------------------\n    // postprocessing\n    //-----------------------------------------------------\n\n    // Light control\n    col = pow(clamp(col, 0.0, 1.0), vec3(0.45));\n\n    // Color compressor\n    col = mix(col, vec3(dot(col, vec3(0.333))), -0.5);\n\n    // Color control\n    col = 0.5 * col + 0.5 * col * col * (3.0 - 2.0 * col);\n\n    // Border dark\n    col *= 0.2 + 0.8 * pow(32.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.3);\n\n    // Fade in\n    col *= smoothstep(0.0, 1.0, iTime);\n\n    fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}