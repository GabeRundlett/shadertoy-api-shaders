{
    "Shader": {
        "info": {
            "date": "1542456606",
            "description": "It is a gyroid mixed with voronoi. It is fast because it doesn't have shadows/reflection.",
            "flags": 0,
            "hasliked": 0,
            "id": "XtyBWW",
            "likes": 27,
            "name": "voronoi gyroid",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "voronoi",
                "gyroid"
            ],
            "usePreview": 0,
            "username": "abje",
            "viewed": 975
        },
        "renderpass": [
            {
                "code": "#define FAR 40.0\n#define EPS 0.001\n#define STEPS 1000\n\n#define voronoiscale 0.4\n#define voronoiscalefloor 1.0\n#define voronoiborder 0.1\n#define gyroidborder 0.03\n#define roundness 0.05\n#define edge 0.3\n\n#define ambient 0.3\n\n#define dot2(a) dot(a,a)\n#define rot(A) mat2(cos(A),-sin(A),sin(A),cos(A))\n\n#define PI acos(-1.0)\n\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .01099)\n\nfloat torus(vec3 p, float r) {\n    vec2 q = vec2(length(p.xz)-r,p.y);\n    \n    return length(q);\n}\n\nfloat map(vec3 p) {\n    \n    vec3 s = sin(p);\n    vec3 c = cos(p.yzx);\n    float len = abs(dot(s,c)*0.7)-gyroidborder;\n    \n    //float t1 = torus(p+vec3(1,0,0),2.0);\n    //float t2 = torus(p.yzx-vec3(1,0,0).yzx,2.0);\n    //float len = abs(t1-t2)*max(t1,t2)*0.3-0.1;\n    \n    vec4 q = vec4(abs(p)-2.0*PI+roundness,len);\n    return length(max(q,0.0))*0.8+min(0.0,max(max(max(q.x,q.y),q.z),q.w))-roundness;\n}\n\n\n//if this is under 0, ignore voronoi\nfloat map2(vec3 p) {\n    \n    vec3 q = abs(p);\n    \n    float a = max(max(q.x,q.y),q.z);\n    \n    return 2.0*PI-a-edge;\n}\n\nfloat planetrace(vec3 p, vec3 d,vec3 plane) {\n    float len = -min(dot(p,plane)+voronoiborder,0.0)/max(dot(d,plane),EPS);\n    return len;\n}\n\nvec3 hash34(vec4 p4)\n{\n\tp4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.zzyw)*p4.zywx).xyz;\n}\n\nvec3 noise(vec3 p3)\n{\n    //animated whitenoise, moving linearly to different random points\n    //float floortime = floor(iTime);\n    //return mix(hash34(vec4(p3,floortime))-0.5,hash34(vec4(p3,floortime+1.0))-0.5,iTime-floortime);\n    \n    //moving around in circles\n    //return sin(vec3(iTime+p3.xzz*p3.yxy+p3))*0.5+0.5;\n    \n    //static procedual whitenoise\n    return (hash34(vec4(p3,0.75))-0.5)*0.8;\n    \n    //volume texture noise (fastest, for me at least)\n    //return (texelFetch(iChannel0,ivec3(mod(p3,32.0)),0).rgb-0.5)*0.5;\n}\n\nvec4 holes(vec3 ro, vec3 rd, float scale) {\n    /*\n    vec3 p = abs(mod(ro,0.2)-0.1);\n    \n    return -p.z+0.05;\n    */\n    \n    \n    ro /= scale;\n    \n    float len = 10000.0;\n    vec3 cell;\n    vec3 center = floor(ro);\n    vec3 center2;\n    \n    //finding closest voronoi cell\n    for(float x = -1.0; x <= 1.0; x++) {\n    \tfor(float y = -1.0; y <= 1.0; y++) {\n    \t\tfor(float z = -1.0; z <= 1.0; z++) {\n                vec3 orig = vec3(x,y,z)+center;\n                orig += noise(orig);\n                if (len > dot2(ro-orig)) {\n                    cell = orig;\n                    center2 = vec3(x,y,z)+center;\n                    len = dot2(ro-orig);\n                }\n            }\n    \t}\n    }\n    \n    \n    //raytracing\n    vec3 normal;\n    \n    len = 10000.0;\n    center = center2;\n    \n    for(float x = -1.0; x <= 1.0; x++) {\n        for(float y = -1.0; y <= 1.0; y++) {\n            for(float z = -1.0; z <= 1.0; z++) {\n                if (!(x==0.0&&y==0.0&&z==0.0)) {\n                    vec3 orig = vec3(x,y,z)+center;\n                    orig += noise(orig);\n                    vec3 mid = mix(orig,cell,0.5);\n                    vec3 plane = vec3((orig-cell));\n                    float num = planetrace(ro-vec3(mid),rd,plane);\n\n                    if (num < len) {\n                        len = num;\n                        normal = -plane;\n                    }\n                }\n            }\n        }\n    }\n    \n    return vec4(len*scale,normal);\n}\n\nvec3 normal(vec3 p) {\n    vec2 e = vec2(EPS,0);\n    \n    return normalize(vec3(\n        map(p+e.xyy),\n        map(p+e.yxy),\n        map(p+e.yyx))\n       -map(p));\n}\n\nvec3 normal2(vec3 p) {\n    vec2 e = vec2(EPS,0);\n    \n    return normalize(vec3(\n        map2(p+e.xyy),\n        map2(p+e.yxy),\n        map2(p+e.yyx))\n       -map2(p));\n}\n\nvec4 ray(vec3 ro, vec3 rd, float maxdist) {\n    float d = 0.0;\n    \n    vec3 n = vec3(-1);\n    for(int i = 0; i < STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float l = map(p);\n        float l2 = map2(p);\n        \n        if (l < EPS && l2 > EPS) {\n            vec4 h = holes(p, rd, voronoiscale);\n            if (h.x > l) {\n                if (l2 < h.x) {\n                    n = vec3(-2);\n                    l = l2;\n                } else {\n                    n = h.yzw;\n                    l = h.x;\n                }\n            } else {\n                n = vec3(-1);\n            }\n        }\n        \n        d += l;\n        if (d > maxdist||l < EPS) {\n            break;\n        }\n    }\n    if (n == vec3(-1)) n = normal(ro+rd*d);\n    if (n == vec3(-2)) n = normal2(ro+rd*d);\n    return vec4(d,n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(0,0,-12.0);\n    vec3 rd = normalize(vec3(uv,1));\n    \n    if (length(iMouse.xy/iResolution.y) > 0.1) {\n        rd.yz *= rot(-iMouse.y/iResolution.y*3.14+3.14*0.5);\n        ro.yz *= rot(-iMouse.y/iResolution.y*3.14+3.14*0.5);\n        rd.xz *= rot(-iMouse.x/iResolution.x*6.28);\n        ro.xz *= rot(-iMouse.x/iResolution.x*6.28);\n    } else {\n        rd.xz *= rot(iTime*0.2);\n        ro.xz *= rot(iTime*0.2);\n    }\n    ro.y = max(ro.y-1.5,-2.0*PI+0.1);\n    \n    float plane;\n    if (rd.y >= 0.0) {\n        plane = FAR;\n    } else {\n        plane = min(-(ro.y+6.28)/rd.y,FAR);\n    }\n    \n    \n    vec4 r = ray(ro,rd, plane);\n    \n    vec3 background = vec3(0.2,0.4,0.3)*(rd.y*0.5+0.5)\n                     +vec3(0.4,0.2,0.5)*(dot(rd,vec3(-1.0/sqrt(3.0)))*0.5+0.5);\n    \n    background *= 0.2;\n    \n    if (r.x < plane) {\n        vec3 p = ro+rd*r.x;\n        vec3 n = r.yzw;\n        \n        fragColor = vec4(1);\n        \n        vec3 lightn = normalize(vec3(1));\n        float light = max(ambient, dot(n,lightn));\n        \n        fragColor *= light;\n        \n        fragColor = mix(fragColor,vec4(background,1), r.x/FAR);\n        \n    } else if (plane < FAR) {\n        r.x = plane;\n        vec3 p = ro+rd*plane;\n        vec3 n = vec3(0,1,0);\n        \n        //rd = refract(rd,n,0.9);\n        \n        vec4 vor = holes(p, rd, voronoiscalefloor);\n        \n        vec3 col;\n        \n        if (vor.x > 0.0) {\n            col = vec3(0.2,0.1,0.8);\n        } else {\n            col = vec3(0.5,0.5,0.0);\n        }\n            \n        vec3 lightn = normalize(vec3(1));\n        float light = max(ambient, dot(n,lightn));\n\n        col *= light;\n        \n        vec3 rd2 = reflect(rd,n);\n        \n        if (vor.x > 0.0) {\n            p += rd*vor.x;\n            r.x += vor.x;\n            n = vor.yzw;\n            fragColor = vec4(0.6,0.2,0.3,1);\n            \n            float light = max(ambient, dot(n,lightn));\n\t\t\t\n            fragColor *= light;\n            \n            fragColor.xyz = mix(fragColor.xyz,col,0.3);\n            \n        } else {\n            fragColor.xyz = col;\n        }\n        \n        fragColor += clamp(dot(rd2,lightn)*200.0-199.0,0.0,1.0);\n    }\n    fragColor = mix(fragColor,vec4(background,1), min(r.x/FAR,1.0));\n    \n    fragColor = sqrt(fragColor);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "volume",
                        "id": 40,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}