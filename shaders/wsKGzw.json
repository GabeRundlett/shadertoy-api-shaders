{
    "Shader": {
        "info": {
            "date": "1569947420",
            "description": "texture.r = height field.  Flooding, then letting the water flow away.\n\nNB: better to use with the x32 accelerator in the Unofficial plugin ;-) ",
            "flags": 32,
            "hasliked": 0,
            "id": "wsKGzw",
            "likes": 2,
            "name": "flood automata",
            "published": 3,
            "tags": [
                "terrain",
                "cellular",
                "flood",
                "automaton"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 500
        },
        "renderpass": [
            {
                "code": "// flood automata: water flows on texture terrain. \n// ( better to use with the x32 accelerator in the Unofficial plugin ;-) )\n// everything is in bufA.\n// NB: it's apparently crucial to visit neighborhood in random order.\n\nvoid mainImage( out vec4 O, vec2 U ) {\n    O = T(U);\n#if !REL\n    O.w -= O.x; // make .w represent the relative water level\n#endif\n    //if ( O.w >  0. ) O.b = 64.*O.w, O.rg *= .6;       // wet: paint blue\n    if ( O.w >  0. ) O = mix( O, vec4(0,0,1,1), min(1.,4.*O.w));\n                   //O.g += .5*sin(16.*O.w+iTime);\n                   //O.g += (O.x+O.w-.5);\n    \n    // show water amount (more reliable with #REL = 1 )\n    if (U.y==.5 && U.x/R.x < textureLod(iChannel0,vec2(.5),99.).w ) \n        O = vec4(1,0,0,0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// It's apparently crucial to visit neighborhood in random order.\n// I have the impression there is a residual bias towards bottom left vs top right.\n\n#define MODE -2 // 0: early fill. +-1: sink from borders +-2: flood from borders\n                //                -1,-2: reinforce border flux at every frame. why needed ?\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    if (iFrame < 30 ) {                         // --- initialization\n        O = texture(iChannel1, U/=R );          // x = terrain\n#if MODE==2 || MODE==-2\n        O.w = 0.; U = abs(2.*U-1.); if ( max(U.x,U.y)>.9 ) O=vec4(0,0,0,1); return; // flood from borders\n#elif MODE==1 || MODE==-1\n        U = abs(2.*U-1.); if ( max(U.x,U.y)>.9 ) O=vec4(0,0,0,1); return; // sink. why can't flow through borders ?\n#endif\n        \n#if REL\n        O.w = 1.-O.x;                           // w = water level\n#else // ABS\n        O.w = 1.;\n#endif\n        return; \n    }\n                                                // --- simulation\n    O = T(U);                                   // restore previous state\n#if MODE == -1\n    vec2 V = abs(2.*U/R-1.); if ( max(V.x,V.y)>.9 ) O-=O;   // sink. forced: why can't flow through borders ?\n#elif MODE==-2\n    vec2 V = abs(2.*U/R-1.); if ( max(V.x,V.y)>.9 ) O.w=1.; // flood. forced: why asymetric leaks through borders ?\n#endif\n    \n  //if (U==vec2(.5)) O.b++;\n    float time = // T(0).b/60., \n                    float(iFrame)/60.,\n                 // iTime,                      // not ok with plugin accelerator ;-)\n           eps = 1./256.;\n    \n#if 0                                           // check neighborhood\n    for( int k=0; k<9; k += k==3 ?2 :1 ) {\n#else                                           // check neighborhood randomnly\n    int ofs = int( 6.*9.* fract( 1e4*sin( dot( U-time, vec2(1,17.34) ) )));\n  //int dir = 1;                                // clock order\n    int dir = int[](1,2,4,5,7,8) [ ofs/9 ];     // random order\n    for( int p=0; p<9; p++ ) {\n        int k = ( p*dir + ofs ) % 9; \n        if (k==4) continue;\n#endif\n        vec4 N = T( U + vec2( k%3-1, k/3-1 ) ); \n#if REL\n        float v = (N.w+N.x) - (O.w+O.x); \n        eps = max( 1./256., abs(v)*.5) ;        // comment for fix flux\n        if ( N.w > 0. && v > 0. ) O.w += eps;   // wet neighbor, higher than us: fill in\n        if ( O.w > 0. && v < 0. ) O.w -= eps;   // we are wet, and higher than neighbor: fill out    \n#else\n        float v = N.w - O.w; \n        eps = max( 1./256., abs(v)*.5 );        // comment for fix flux\n        if ( N.w > N.x && v > 0. ) O.w += eps;  // wet neighbor, higher than us: fill in\n        if ( O.w > O.x && v < 0. ) O.w -= eps;  // we are wet, and higher than neighbor: fill out    \n#endif\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define R     ( iResolution.xy ) \n#define T(U)   texelFetch( iChannel0, ivec2(U), 0 )\n#define REL    1  // 1: water in .w is relative to terrain height .x  \n                  // 0: absolute water level\n\n\n/*\n//https://en.wikipedia.org/wiki/Linear_congruential_generator\nuint seed = 0U;\nfloat LCG() { \n    seed = 1664525U * seed + 1013904223U; // % 2^32\n    return float(seed)/exp2(32.);\n}\n*/\n  ",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}