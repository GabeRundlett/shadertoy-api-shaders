{
    "Shader": {
        "info": {
            "date": "1462191052",
            "description": "Does this break browsers? Trying to find a balance between quality/compiling.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "4sdXDl",
            "likes": 36,
            "name": "Simple Hybrid Fract",
            "published": 3,
            "tags": [
                "fractal",
                "hybrid"
            ],
            "usePreview": 0,
            "username": "eiffie",
            "viewed": 2240
        },
        "renderpass": [
            {
                "code": "//spikey\n#define SHAPE length(z.yz)\n//normal\n//#define SHAPE length(z.xyz)\n//bizarro\n//#define SHAPE length(z.yz-z.xx)\n//etc...\n#define HIGH_QUAL\n#ifdef HIGH_QUAL\n#define MARCH_STEPS 199\n#else\n#define MARCH_STEPS 99\n#endif\nfloat k;\nvec3 mcol=vec3(0.0);\nvoid AbsBox(inout vec4 z){//abs box by kali \n z.xyz=abs(z.xyz+1.0)-1.0; \n z*=1.5/clamp(dot(z.xyz,z.xyz),0.25,1.0);\n}\nvoid Bulb(inout vec4 z, in vec4 c){//mandelBulb by twinbee\n float r = length(z.xyz);\n float zo = asin(z.z / r) * k + iTime*0.15;\n float zi = atan(z.y, z.x) * 7.0;\n z=pow(r, k-1.0)*vec4(r*vec3(cos(zo)*vec2(cos(zi),sin(zi)),sin(zo)),z.w*k)+c; \n}\nfloat DE(vec3 p){\n  vec4 c = vec4(p,1.0),z = c;\n  Bulb(z,c);\n  float r0=(length(z.xyz)-1.15)/z.w;\n  z.xyz-=1.0;\n  for(int i=0;i<7;i++)AbsBox(z);\n  float r=SHAPE;\n  mcol.rgb=vec3(1.0,0.5,0.2)+abs(sin(0.2*r+100.0*z.yxz/z.w));\n  return 0.5 * max((r-1.0) / z.w,-r0);\n}\nvec3 sky(vec3 rd, vec3 L){//modified bananaft's & public_int_i's code\n  float d=0.4*dot(rd,L)+0.6;\n  rd.y+=sin(sqrt(clamp(-rd.y,0.0,0.9))*90.0)*0.45*max(-0.1,rd.y);\n  rd=abs(rd);\n  float y=max(0.,L.y),sun=max(1.-(1.+10.*y+rd.y)*length(rd-L),0.)\n    +.3*pow(1.-rd.y,12.)*(1.6-y);\n  return d*mix(vec3(0.3984,0.5117,0.7305),vec3(0.7031,0.4687,0.1055),sun)\n    *((.5+pow(y,.4))*(1.5-abs(L.y))+pow(sun,5.2)*y*(5.+15.0*y));\n}\nfloat rnd;\nvoid randomize(in vec2 p){rnd=fract(float(iFrame)+sin(dot(p,vec2(13.3145,117.7391)))*42317.7654321);}\n\nvec3 scene(vec3 ro, vec3 rd){\n  vec3 L=normalize(vec3(0.4,0.025,0.5));\n  vec3 bcol=sky(rd,L);\n  vec4 col=vec4(0.0);//color accumulator\n  float t=DE(ro)*rnd,d,od=1.0,px=1.0/iResolution.x;\n  ro+=rd*t;\n  for(int i=0;i<MARCH_STEPS;i++){\n    d=DE(ro);\n    if(d<px*t){\n      float dif=clamp(1.0-d/od,0.2,1.0);\n      vec3 scol=mcol*dif*(1.3-0.3*t);\n#ifdef HIGH_QUAL\n      \tvec2 s=vec2(DE(ro+d*4.0*L),DE(ro+d*16.0*L));\n        scol*=clamp(0.5*s.x/d+(s.y/d)/8.0,0.0,1.0);\n#endif\n      float alpha=(1.0-col.w)*clamp(1.0-d/(px*t),0.0,1.0);\n      col+=vec4(clamp(scol,0.0,1.0),1.0)*alpha;\n      if(col.w>0.9)break;\n    }\n    t+=d;ro+=rd*d;od=d;\n    if(t>6.0)break;\n  }\n  col.rgb+=bcol*(1.0-clamp(col.w,0.0,1.0));\n  return col.rgb;\n}\nmat3 lookat(vec3 fw){\n fw=normalize(fw);vec3 rt=normalize(cross(fw,vec3(0.0,1.0,0.0)));return mat3(rt,cross(rt,fw),fw);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n   k=7.0+3.0*sin(iTime*0.15);\n   randomize(fragCoord);\n   float tim=iTime*0.3,r=2.0+cos(tim*0.7);\n   vec2 uv=(fragCoord-0.5*iResolution.xy)/iResolution.x;\n   vec3 ro=vec3(sin(tim)*r,sin(tim*0.4),cos(tim)*r);\n   vec3 rd=lookat(-ro)*normalize(vec3(uv,1.0));\n   fragColor=vec4(scene(ro,rd)*2.0,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}