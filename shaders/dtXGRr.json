{
    "Shader": {
        "info": {
            "date": "1671178549",
            "description": "Light direction = mouse click location to center of viewport. (hold click)\n\nPlanet texture based on https://www.shadertoy.com/view/lsyfWD\n\nMy first shader (that was worth posting)",
            "flags": 0,
            "hasliked": 0,
            "id": "dtXGRr",
            "likes": 5,
            "name": "Moon Orbiting Planet",
            "published": 3,
            "tags": [
                "space",
                "planet",
                "stars",
                "moon",
                "physics",
                "planets",
                "projectle"
            ],
            "usePreview": 0,
            "username": "MaxShaders",
            "viewed": 233
        },
        "renderpass": [
            {
                "code": "struct Circle {\n    vec3 center;\n    float radius;\n    vec4 color;\n};\n\nfloat Clamp(float a, float b, float x) {\n    return max(a, min(b, x));\n}\n\nvec4 DrawCircle(vec2 uv, Circle c, bool AA) {\n    float d = length(c.center.xy - uv) - c.center.z;\n    float blur = AA ? smoothstep(1.0, 0.985, 1. - clamp(0., 1., length(d - c.radius) / c.radius)) : 1.;\n    return d <= c.radius ? vec4(c.color.xyz, blur * c.color.w) : vec4(0.);\n}\n\nfloat N(vec2 i) {\n    float t = tan(sin(i.x)) + cos(i.y);\n    return fract(sin(t * 3456.) * 6547.);\n}\n\nvec4 depthSort(vec4 c1, float d1, vec4 c2, float d2) {\n    c1.w = clamp(0., 1., c1.w);\n    c2.w = clamp(0., 1., c2.w);\n    if(length(c1) != 0. && length(c2) != 0.)\n    {\n        return d1 < d2 ? c1 + c2 * (1. - c1.w) : c2 + c1 * (1. - c2.w);\n    }\n    return c1 + c2;\n}\n\nvec4 FresnelCircle(vec2 uv, Circle c, float ammount) {\n    float d = length(c.center.xy - uv);\n    float r = c.radius + c.center.z;\n    if(d > r) return vec4(0.);\n    return vec4(pow(d / (r), ammount));\n}\n\nvec4 bloomCircle(vec2 uv, Circle c, float scale, float intensity, bool hollow) {\n    float d = length(c.center.xy - uv);\n    if(hollow && d < c.radius) return vec4(0.);\n    d = clamp(0., 1., 1. - min(c.radius * scale, d - c.radius) / (c.radius * scale));\n    return vec4(vec3(1.) * intensity * d * d, intensity * d * d);\n}\n\nvec4 combineColors(vec4 c1, vec4 c2) {\n    return vec4(c1.xyz * c1.w + c2.xyz * c2.w, clamp(0., 1., c1.w + c2.w));\n}\n\n//Based on https://www.shadertoy.com/view/lsyfWD\nvec3 PlanetTexture(vec2 uv, float distToEdge, float tscale)\n{\n    float speed = 0.5;\n    vec2 scale = vec2(6., 2.) * tscale;\n    vec2 p = uv * scale / iResolution.xy;\n    \n    for(float i = 1.; i < 10.; i += 1.) \n    {\n        p.x += 0.3 / i * sin(i * 3.* p.y + iTime * speed) + iMouse.x / 1000.;\n        p.y += 0.3 / i * cos(i * 3.* p.x + iTime * speed) + iMouse.y / 1000.;\n    }\n    \n    float r = cos(p.x + p.y + 1.) * .3 + .5;\n    float g = sin(p.x + p.y + 1.) *.5 + .5;\n    float b = (sin(p.x + p.y) + cos(p.x + p.y)) * .8 + .5;\n    vec3 color = 0.4 + vec3(r,g,b) * 0.25;\n    return color * 3. * distToEdge;\n}\n\nfloat shadeCircle(vec2 uv, Circle c, vec2 dir, float scale, float offset) {\n    dir = normalize(dir);\n    float dist = c.radius;\n    vec2 center = vec2(c.center.xy - dist * -offset * dir);\n    return (scale / 2.) + max(1., scale) * max(0.0, (1. / dist - (length(uv - center) * dot(normalize(uv - center), dir) / dist)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ///Set true to keep light direction without holding mouse down\n    bool KeepLightDir = false; //<--------------------------------\n\n\n    float t = mod(iTime / 2., 3.);\n    vec2 uv = fragCoord;\n    float Z = iResolution.y / 10.;\n    vec2 lightDir = vec2(-1., -1.);\n    lightDir *= iMouse.z > 0. || KeepLightDir ? normalize(vec2(iMouse.x - iResolution.x / 2., iMouse.y - iResolution.y / 2.)) : vec2(1.);\n\n    //Moon orbit motion\n    float t_moon = t * 0.5;\n    vec3 g = vec3(0., -1., 0.) * iResolution.y;\n    vec3 A = g;\n    vec3 Vi = vec3(1.0, 2.2 , -0.1) * iResolution.y;\n    vec3 Pi = vec3(0.1, -0.1, 0.5) * vec3(iResolution.xy, Z);\n    \n    vec3 Vel = Vi + A * t_moon;\n    vec3 Pos = vec3(Pi + Vel * t_moon + 0.5 * A * t_moon * t_moon);\n    \n    //Moon\n    Circle m;\n    m.center = Pos.xyz;\n    m.radius = 0.1 * iResolution.y;\n    float moonD = -m.center.z / Z;\n    m.color = vec4(0.55, 0.5, 0.7, 1.) * (clamp(0., 1., 1.4 - moonD));\n    vec4 moon = DrawCircle(uv, m, false);\n    float moonR = m.radius + m.center.z;\n    moon = combineColors(moon, 1.5 * FresnelCircle(uv, m, 5.) *  vec4(0.2, 0.4, 0.5, 0.5));\n    \n    float distToEdge1 = 2. * FresnelCircle(uv, m, 4.).w;\n    moon.xyz *= 0.5 + PlanetTexture(uv - m.center.xy, distToEdge1, 10. * distToEdge1).xzy / 2.;\n    m.radius = moonR;\n    moon.xyz *= shadeCircle(uv, m, lightDir, 0.0, 0.2) / 2.;\n    moon += bloomCircle(uv, m, 0.3, 0.9, true) * vec4(0.1, 0.15, 0.25, 0.2) * pow(shadeCircle(uv, m, lightDir, 0.0, 0.8), 2.);\n    \n    //Planet\n    Circle w;\n    w.center = vec3(0.5, -1., 0.0) * vec3(iResolution.xy, 65.);\n    float planetD = -w.center.z / Z;\n    w.radius = 1.5 * iResolution.y;\n    w.color = vec4(0.5, 0.4, 0.3, 1.) * 1.;\n    vec4 planet = DrawCircle(uv, w, true);\n    \n    Circle Atmosphere;\n    Atmosphere.center = w.center - vec3(0., -2., 0.);\n    Atmosphere.radius = w.radius;\n    vec4 planetAtmosphere = FresnelCircle(uv, Atmosphere, 80.) + (bloomCircle(uv, Atmosphere, 0.015, 1., true));\n    planetAtmosphere *= vec4(0.4, 0.6, 0.9, 1.);\n    \n    planet.xyz *= shadeCircle(uv, w, lightDir, 0.2, 0.2);\n    planet.w = sign(planet.x);\n    \n    vec4 planetBloom = bloomCircle(uv, w, 0.4, 0.5, false) * vec4(0.4, 0.6, 0.9, 0.1);\n    planetBloom *= shadeCircle(uv, Atmosphere, lightDir, 0.0, 0.9) * 1.;\n    float distToEdge = FresnelCircle(uv, w, 12.).w;\n    planet.xyz *= PlanetTexture(uv.yx, distToEdge, 2. * distToEdge) / 1.;\n    planet += planetAtmosphere * max(0.1, shadeCircle(uv, Atmosphere, lightDir, 0.1, 0.0)) * 1.8;\n    \n    \n    moon += planetBloom * moon / 2.;\n    float shadow = Clamp(0.15, 1., 1. -dot(normalize(vec3(0, 1., 0.)), vec3(lightDir, 0.)) / 1.);\n    moon.xyz *= shadow;\n    \n    //Stars\n    vec4 stars = vec4(0.0);\n    float n = N(uv);\n    if(n >= 0.999)\n    {\n        stars += vec4(n * (.8 + sin(4. * iTime * N(uv.yx)) * 0.2));\n    }\n    \n    vec4 planet_moon = depthSort(moon, moonD, planet, planetD);\n    vec4 planets_bloom = depthSort(planet_moon, 0.0, planetBloom, 1.);\n    vec4 planets_stars = depthSort(planets_bloom, 0.0, stars, 1.);\n    fragColor = planets_stars;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}