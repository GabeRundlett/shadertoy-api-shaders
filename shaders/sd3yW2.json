{
    "Shader": {
        "info": {
            "date": "1654065891",
            "description": "Use mouse to change the view position.",
            "flags": 0,
            "hasliked": 0,
            "id": "sd3yW2",
            "likes": 22,
            "name": "Procedural flowing liquid",
            "published": 3,
            "tags": [
                "procedural",
                "noise",
                "liquid",
                "generation",
                "textureadvection"
            ],
            "usePreview": 0,
            "username": "vipiao",
            "viewed": 611
        },
        "renderpass": [
            {
                "code": "\n/*\nThe flow is represented by a vector field. A point in 2d space gives a 2d vector.\nTo make the liquid flow naturally, volume should be conserved.\nA vector field that conserves volume is said to have a divergence of 0 all over.\nThe function \"whirl\" generates a whirl at the position \"center\".\nSuch a whirl has 0 divergence since it only spins the volume in circular motion at a random speed.\n\"whirldNoise\" generates several such whirls in a grid pattern.\nThis is the same as a sum of whirl vector fields.\nThe divergence of a sum of vector fields is a sum of the divergence of these vector fields.\nThis means \"whirldNoise\" also has 0 divergence.\n\"layeredWhirlNoise\" adds multiple such whirl noises on top of each other with different frequencies\nand magnitudes. By the same logic, this function will also have 0 divergence, so volume is conserved.\nBy slowly changing the seed of the layeredWhirlNoise function, the flow will change over time.\n\nTo animate the noise function to make it move in the direction of the vector field,\na technique similar to Shepard's tone is being used. Shepard's tone uses multiple rising sound frequencies\nadded together making a sound that will rise. The frequencies that are too high are faded away and new\nlower frequencies are added in. The fading is too slow for humans to notice resulting in the illusion\nof an ever increasing tone. In the animation the same is done, but for noise functions instead.\nThe one noise function is distorted in the direction of the vector field. When the distortion\nis too large, it is faded away as it is being replaced with a less distorted version of the noise function.\n*/\n\n// Change parameters to change the simulation.\n#define DIRECTION_CHANGE_SPEED 1.0\n#define LIQUID_SPEED 1.0\n#define NOISE_FREQ 40.\n\n// \"hash13\" is taken from:\n//https://www.shadertoy.com/view/4djSRW\n// Generates random noise from p3.\nfloat hash13(vec3 p3){\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n// A simple 3d noise function that correlates similar positions in 3d. Is more smooth than rand3d.\nfloat boxNoise(vec3 pos){\n\tvec3 ind = vec3(floor(pos));\n    vec3 f = fract(pos);\n    \n    vec3 u = f * f * (3.0 - 2.0 * f);\n    \n    return mix(mix(mix( hash13(ind + vec3(0,0,0)), hash13(ind + vec3(1,0,0)), u.x),\n                   mix( hash13(ind + vec3(0,1,0)), hash13(ind + vec3(1,1,0)), u.x), u.y),\n               mix(mix( hash13(ind + vec3(0,0,1)), hash13(ind + vec3(1,0,1)), u.x),\n                   mix( hash13(ind + vec3(0,1,1)), hash13(ind + vec3(1,1,1)), u.x), u.y), u.z);\n}\n// Creates a whirl vector field at \"center\" sampled at \"pos\".\nvec2 whirl(vec2 pos, vec2 center, float ff, float seed){\n    vec2 relPos = pos - center;\n    float ll = length(relPos);\n    float mm = 1. - 2. * boxNoise(vec3(center, ll*ff + seed));\n    vec2 dir = vec2(-relPos.y, relPos.x) / ll;\n    \n    return dir * mm * ll / (1.+abs(ll));\n}\n// Distributes whirls at a grid of 1 by 1 cells.\nvec2 whirldNoise(vec2 pos, float seed){\n\tvec2 botL = floor(pos);\n    vec2 ee = vec2(1,0);\n    float ff = 2.;\n    return\n        whirl(pos, botL      , ff, seed) * max(1.-length(pos-botL      ), 0.)*1. +\n        whirl(pos, botL+ee.xy, ff, seed) * max(1.-length(pos-botL-ee.xy), 0.)*1. +\n        whirl(pos, botL+ee.yx, ff, seed) * max(1.-length(pos-botL-ee.yx), 0.)*1. +\n        whirl(pos, botL+ee.xx, ff, seed) * max(1.-length(pos-botL-ee.xx), 0.)*1.\n    ;\n}\n// Layer the whirls with different frequencies and magnitudes.\nvec2 layeredWhirlNoise(vec2 pos, int nn, float seed){\n    vec2 rr = vec2(0.);\n    float ff = 1.;\n    for(int ii=0;ii<nn;ii++){\n        rr += whirldNoise(pos / ff, seed) * ff;\n        ff *= 0.67;\n        pos += vec2(1,-1);\n    }\n    return rr;\n}\n// Calculates the pixel color.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n    float aspectRatio = iResolution.x / iResolution.y;\n    \n    vec2 camPos = (vec2(iMouse.xy) - vec2(iResolution.xy) * 0.5)*0.05;\n    float zoom = 6.; // How many distance units are visible in the horizontal direction.\n    vec2 pos = camPos.xy + uv * zoom*2.;\n    \n    // Calculate color.\n    // The flow vector field.\n    vec2 ww = LIQUID_SPEED*4.0*layeredWhirlNoise(pos*0.1, 5, iTime*0.2*DIRECTION_CHANGE_SPEED);\n    \n    float ff = 2.*LIQUID_SPEED; // The pace of swapping textures\n    float t0 = mod(ff*iTime, 1.);\n    float t1 = mod(ff*iTime + 0.5, 1.);\n    vec3 n0 = vec3(\n        boxNoise(vec3((pos - t0 * ww) * NOISE_FREQ, 0. + 0.5*iTime)),\n        boxNoise(vec3((pos - t0 * ww) * NOISE_FREQ, 1. + 0.5*iTime)),\n        boxNoise(vec3((pos - t0 * ww) * NOISE_FREQ, 2. + 0.5*iTime))\n    );\n    vec3 n1 = vec3(\n        boxNoise(vec3((pos - t1 * ww) * NOISE_FREQ, 3. + 0.5*iTime)),\n        boxNoise(vec3((pos - t1 * ww) * NOISE_FREQ, 4. + 0.5*iTime)),\n        boxNoise(vec3((pos - t1 * ww) * NOISE_FREQ, 5. + 0.5*iTime))\n    );\n    float mm = -abs(t1*2.-1.)+1.;\n    vec3 color = mix(n0, n1, mm);\n    \n    // An average of two noise functions have less variance.\n    // This could lead to contrast visible oscillations of variance.\n    // Compensate by reducing variance when noise is mixed.\n    float var = abs(round(t0 * 2. - 0.5) - t0 * 2. + 0.5)*(2. - sqrt(2.));\n    // Apply variance reduction.\n    color = mix(color, vec3(0.5), var);\n    //color *= length(ww); // Uncomment to only see moving liquid.\n    \n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}