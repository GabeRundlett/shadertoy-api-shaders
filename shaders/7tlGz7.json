{
    "Shader": {
        "info": {
            "date": "1621846774",
            "description": "Just a little test",
            "flags": 32,
            "hasliked": 0,
            "id": "7tlGz7",
            "likes": 10,
            "name": "Terrain Water Demo",
            "published": 3,
            "tags": [
                "test",
                "simple",
                "terrain",
                "water"
            ],
            "usePreview": 1,
            "username": "milesWaugh",
            "viewed": 524
        },
        "renderpass": [
            {
                "code": "vec3 tex(vec2 c) {\n    return textureLod(iChannel0, c / iResolution.xy, 0.0).rgb;\n}\n\nvec3 gl(vec3 z) {\n    return vec3(z.x * z.x, z.y * z.y, z.z * z.z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 fc = tex(fragCoord);\n    \n    for(int i = -3; i < 4; i++) {\n        fc += gl(tex(fragCoord + vec2(i, 0)) / (abs(float(i)) + 1.));\n    }\n    for(int i = -3; i < 4; i++) {\n        fc += gl(tex(fragCoord + vec2(0, i)) / (abs(float(i)) + 1.));\n    }\n    \n    fc *= 1.6;\n    fc = fc / (fc + vec3(1.));\n    fc *= 1.0;\n    fc = smoothstep(0., 1., fc);\n    fc = vec3(sqrt(fc.r), sqrt(fc.g), sqrt(fc.b));\n    fc = max(fc, 0.);\n    \n    fragColor = vec4(fc, 0.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define s sqrt(.5)\n#define l normalize(vec3(0.5,0.4,1))\n#define pi 3.141592653589793\n#define cam vec3(0.,0.,iTime)\n\n//DAVE HOSKINS' HASH FUNCTIONS\n//https://www.shadertoy.com/view/4djSRW\nvec3 rnd32(vec2 p) {\n    vec3 p3 = fract(p.xyx * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return fract((p3.xxy + p3.yzz) * p3.zyx);\n}\n\nfloat rnd12(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 rnd23(vec3 p3) {\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\n//Thanks to Inigo for helping me a bunch with the artifacts created \n//when I was using the built-in noise textures!\nvec3 textu(sampler2D sam, vec2 uv) {\n    ivec2 res = textureSize(sam, 0).xy;\n    uv = uv * vec2(res) - 0.5;\n    ivec2 iuv = ivec2(floor(uv));\n    vec2 f = fract(uv);\n    f = f * f * (3.0 - 2.0 * f);\n    vec4 rg1 = texelFetch(sam, (iuv + ivec2(0, 0)) & (res - 1), 0);\n    vec4 rg2 = texelFetch(sam, (iuv + ivec2(1, 0)) & (res - 1), 0);\n    vec4 rg3 = texelFetch(sam, (iuv + ivec2(0, 1)) & (res - 1), 0);\n    vec4 rg4 = texelFetch(sam, (iuv + ivec2(1, 1)) & (res - 1), 0);\n    return mix(mix(rg1, rg2, f.x), mix(rg3, rg4, f.x), f.y).rgb;\n}\n\nfloat tex(vec3 z) {\n    z += cam;\n    float t = 0.;\n    for(int i = 0; i < 10; i++) {\n        float p = 2.;\n        float p2 = pow(2.5, float(i));\n        vec2 pos = pow(p, float(i)) * z.xz / 30.;\n        pos += p2 / 1000.;\n        pos *= 20.;\n        /*pos*=512.;\n        pos.x = sin(pi*(fract(pos.x)-.5))*.5+floor(pos.x)+0.5;\n        pos.y = sin(pi*(fract(pos.y)-.5))*.5+floor(pos.y)+0.5;\n        pos/=512.;\n        t += textu(iChannel0,pos).r/p2;*/\n        float pff = rnd12(vec2(floor(pos.x), floor(pos.y)));\n        float pcf = rnd12(vec2(ceil(pos.x), floor(pos.y)));\n        float pfc = rnd12(vec2(floor(pos.x), ceil(pos.y)));\n        float pcc = rnd12(vec2(ceil(pos.x), ceil(pos.y)));\n        float pxf = mix(pff, pcf, smoothstep(0., 1., fract(pos.x)));\n        float pxc = mix(pfc, pcc, smoothstep(0., 1., fract(pos.x)));\n        t += mix(pxf, pxc, smoothstep(0., 1., fract(pos.y))) / p2;\n    }\n    return t;\n}\n\nfloat tex2(vec3 z) {\n    z += cam;\n    z *= 50.;\n    float t = 0.;\n    \n    for(int i = 0; i < 5; i++) {\n        float p = 2.;\n        float p2 = pow(2.5, float(i));\n        vec2 pos = pow(p, float(i)) * z.xz / 30.;\n        pos += p2 / 1000.;\n        pos *= 26.;\n        /*pos*=512.;\n        pos.x = sin(pi*(fract(pos.x)-.5))*.5+floor(pos.x)+0.5;\n        pos.y = sin(pi*(fract(pos.y)-.5))*.5+floor(pos.y)+0.5;\n        pos/=512.;\n        t += textu(iChannel0,pos).r/p2;*/\n        float pff = rnd12(vec2(floor(pos.x), floor(pos.y)));\n        float pcf = rnd12(vec2(ceil(pos.x), floor(pos.y)));\n        float pfc = rnd12(vec2(floor(pos.x), ceil(pos.y)));\n        float pcc = rnd12(vec2(ceil(pos.x), ceil(pos.y)));\n        float pxf = mix(pff, pcf, smoothstep(0., 1., fract(pos.x)));\n        float pxc = mix(pfc, pcc, smoothstep(0., 1., fract(pos.x)));\n        t += mix(pxf, pxc, smoothstep(0., 1., fract(pos.y))) / p2;\n    }\n    \n    return t;\n}\n\nvec3 albedo(vec3 n, vec3 z) {\n    return vec3(0.5, (pow(n.y, 10.) + tex2(z) * 0.35 - 0.3) * .5 + 0.25, 0.1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 pcol = texture(iChannel1, fragCoord / iResolution.xy);\n    vec2 uv = 2. * ((fragCoord + rnd23(vec3(fragCoord.xy, iTime))) - iResolution.xy * .5) / iResolution.x;\n    vec3 inc = normalize(vec3(uv, 1.));\n    inc = vec3(inc.x, inc.y * s - inc.z * s, inc.z + inc.y);\n    float raylength = 0.;\n    vec3 z = vec3(0.);\n    int iters = 0;\n    float sdf = 1.;\n    vec3 n, nr;\n    bool pass = false;\n    float rw = 0.;\n    vec3 zo;\n    vec3 incr = inc;\n    float ter, wat;\n    bool inter = false;\n    \n    while(iters < 500) {\n        iters++;\n        float t = tex(z);\n        ter = z.y - (t * 0.8 - 2.25);\n        wat = z.y + 1.5;\n        float d = 0.0001;\n        bool terbol = abs(sdf - ter) < 0.00001;\n        \n        if(pass) {\n            sdf = ter;\n            if(abs(sdf) < 0.001 || iters > 128 || raylength > 10.) {\n                float t2 = tex(z + vec3(0., 0., d));\n                float t4 = tex(z + vec3(d, 0., 0.));\n                n = normalize(vec3(t - t4, d, t - t2));\n                inter = true;\n                break;\n            }\n        } else {\n            sdf = min(ter, wat);\n            rw = raylength;\n            if(abs(sdf) < 0.000001 || iters > 128 || raylength > 10.) {\n                if(terbol) {\n                    float t2 = tex(z + vec3(0., 0., d));\n                    float t4 = tex(z + vec3(d, 0., 0.));\n                    n = normalize(vec3(t - t4, d, t - t2));\n                    inter = false;\n                    break;\n                } else {\n                    pass = true;\n                    float t5 = tex2(z);\n                    float t6 = tex2(z + vec3(0.0002, 0., 0.));\n                    float t7 = tex2(z + vec3(0., 0., 0.0002));\n                    vec3 n2 = normalize(vec3(t6 - t5, 0.001, t7 - t5));\n                    nr = normalize(vec3(0., 1., 0.) + n2 / 32.);\n                    zo = z;\n                    incr = inc;\n                    inc = refract(inc, nr, 0.7);\n                    inter = true;\n                    if(inc == vec3(0.)) {\n                        break;\n                    }\n                }\n            }\n        }\n        \n        raylength += sdf * (terbol ? 1. : .9);\n        z = pass ? inc * (raylength - rw) + zo : inc * raylength;\n    }\n    \n    vec3 nre;\n    incr = normalize(incr);\n    vec3 refl = reflect(incr, nr);\n    \n    if(inter) {\n        iters = 0;\n        sdf = 1.;\n        float rayr = .001;\n        vec3 camp = zo;\n        z = camp + refl * rayr;\n        \n        while(iters < 500) {\n            iters++;\n            float t = tex(z);\n            ter = z.y - (t * 0.8 - 2.25);\n            float d = 0.0001;\n            sdf = ter;\n            \n            if(abs(sdf) < 0.001) {\n                float t2 = tex(z + vec3(0., 0., d));\n                float t4 = tex(z + vec3(d, 0., 0.));\n                nre = normalize(vec3(t - t4, d, t - t2));\n                break;\n            }\n            if(rayr > 10. || iters > 128) {\n                nre = vec3(0.);\n                break;\n            }\n            \n            rayr += sdf * .9;\n            z = refl * rayr + camp;\n        }\n    }\n    \n    vec3 li = vec3(1., .7, .35);\n    vec3 am = vec3(0.6, 0.8, 1.);\n    float rd = (raylength - rw) * 100.;\n    vec3 r = reflect(incr, nr);\n    float fresnel = 1. + dot(incr, nr);\n    fresnel = 0.05 + 0.95 * fresnel * fresnel * fresnel * fresnel * fresnel;\n    vec3 spec = vec3(max(dot(r, l), 0.));\n    spec = vec3(pow(spec.x, 250.) * 30. * fresnel * li);\n    vec3 absorb = vec3(exp(-rd), exp(-rd * 0.2), exp(-rd * 0.1));\n    float scatter = exp(-raylength * .033);\n    float lambert = max(dot(n, l), 0.);\n    \n    if(inter) {\n        if(dot(nre, nre) > 0.5) {\n            spec = (am * .08 + lambert * 2. * vec3(1., 0.9, 0.7)) * albedo(n, z) * fresnel;\n        } else {\n            spec = fresnel * (am * .8 + 5. * spec * li);\n        }\n    } else {\n        spec += lambert * lambert * lambert * lambert * .5 * vec3(1., 0.9, 0.7) * fresnel;\n    }\n    \n    vec3 dif = (am * .08 + li * lambert * 2.5) * albedo(n, z);\n    vec3 col = dif * absorb + spec;\n    col = vec3(max(col.r, 0.), max(col.g, 0.), max(col.b, 0.));\n    col = mix(am, col, scatter);\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}