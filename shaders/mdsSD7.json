{
    "Shader": {
        "info": {
            "date": "1669066463",
            "description": "Modified the text console (based on conversation with mla), created a demo to show debugging capabilities.\nUnderlying shader is [url]https://www.shadertoy.com/view/Ms2fWW[/url] by sh17b. (How the heck is this shader so small?)",
            "flags": 0,
            "hasliked": 0,
            "id": "mdsSD7",
            "likes": 2,
            "name": "Text Console Demo",
            "published": 3,
            "tags": [
                "draw",
                "debug",
                "int",
                "float",
                "debugging",
                "write"
            ],
            "usePreview": 0,
            "username": "Hatchling",
            "viewed": 652
        },
        "renderpass": [
            {
                "code": "vec2 Path(vec2 x) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tf = f*f*(3.-2.*f);\n\treturn textureLod(iChannel2, (p+vec2(37.5,17.5) + f)/256.0, 0.).xy;\n}\n\n#define S(x) vec4(Path(x*vec2(.04,.1))*vec2(6,9),0,0)\n\nvoid hellCarting( out vec4 o, in vec2 C, inout TextCursor textCur ) \n{\n    vec4 p = vec4(C.xy,0,0)/iResolution.xyxy-.5, d=p, t, c, s;\n    p.z += iTime*8.;\n    p -= S(p.z);\n    float x, r, w, i;\n    for(i=1.5; i>0.; i-=.01)\n    {\n        // Select one of 5 type of wood beam separation\n        vec2 z = (p.zz-2.)*.25;\n        z = Path(z - fract(z))*4.+.5;\n        z = (z - fract(z))/10.;\n        z = mix(z, vec2(1.), step(vec2(.4), z));      \n        z *= step(4., mod(p.z-2., 8.));\n\t\tfloat f = mix(z.x, z.y, step(p.x, 0.));                \n        \n        t = abs(mod(c=p+S(p.z), 8.)-4.);\n        w = step(0., c.y);\n        r = (step(2.6, t.x) - step(2.8, t.x)) * w;        \n        s = texture(iChannel0, (c.y*t.x > 3. ? t.zxy:t.yzx)-3.);\n        x = min(t.x + f, t.y)-s.x * (1.-r) - r*.8;  \n         \n        // Hacky way of doing word wrapping.\n        {\n            TextCursor temp = textCur;             \n            printFloat(x, temp);   \n            if(temp.coord.y != textCur.coord.y)\n            {\n                printChar(cNl, textCur);       \n            }\n        }\n        printFloat(x, textCur);\n        printChar(cSp, textCur);\n                     \n        if(x < .01) break;\n        p -= d*x*.5;\n     }\n    w = step(t.x, 0.8) * step(2.8, t.z) + step(2.8, t.x) * step(0., c.y);\n\to = p.wyyw*.02 + 1.3* mix(s, vec4(.8), r) * mix(vec4(1), vec4(1,.5,.2,1), w ) * i/p.w;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Draw the scene normally.\n    TextCursor tDummy;\n    hellCarting(fragColor, fragCoord, tDummy);\n\n    // Draw debugging info.\n    {\n        Font f;\n        f.texSize = iChannelResolution[3].xy;\n        f.charSize = iChannelResolution[3].xy / vec2(16, 16);\n\n        TextCursor t;\n        const vec2 charScale = vec2(15, 15);\n        t.startPos = vec2(0, iResolution.y);\n        t.coord = ivec2(0);\n        t.font = f;\n        t.color = vec4(1,1,0,1);\n        t.charSize = vec2(1,1) * charScale;\n        t.charSpace = vec2(1, 1) * charScale;\n        t.pageWidth = int(iResolution.x / t.charSize.x);\n        t.fragCoord = fragCoord;\n    \n        vec4 colorDummy;\n        hellCarting(colorDummy, iMouse.xy, t);\n        drawText(t, iChannel3, fragColor);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// This code is released into the public domain.\n// If you need a license instead, consider this CC0, MIT or BSD licensed, take your pick.\n\n// If you want to print numbers larger than 32 digits, increase maxStringLength\n\nconst int maxStringLength = 32;\nconst ivec2 cNl    = ivec2(-1, -1);\nconst ivec2 cSp    = ivec2( 0, 13);\nconst ivec2 cPlus  = ivec2(11, 13);\nconst ivec2 cMinus = ivec2(13, 13);\nconst ivec2 cDot   = ivec2(14, 13);\n\nconst ivec2[10] Digits = ivec2[10]\n(\n    ivec2(0, 12), ivec2(1, 12), ivec2(2, 12), ivec2(3, 12), ivec2(4, 12), \n    ivec2(5, 12), ivec2(6, 12), ivec2(7, 12), ivec2(8, 12), ivec2(9, 12) \n);\n#define chd(name, index) const ivec2 name = Digits[index];\nchd(c0,  0) chd(c1,  1) chd(c2,  2) chd(c3,  3) chd(c4,  4)\nchd(c5,  5) chd(c6,  6) chd(c7,  7) chd(c8,  8) chd(c9,  9)\n\nconst ivec2[26] Uppercase = ivec2[26]\n(\n    ivec2( 1, 11), ivec2( 2, 11), ivec2( 3, 11), ivec2( 4, 11), ivec2( 5, 11), \n    ivec2( 6, 11), ivec2( 7, 11), ivec2( 8, 11), ivec2( 9, 11), ivec2(10, 11), \n    ivec2(11, 11), ivec2(12, 11), ivec2(13, 11), ivec2(14, 11), ivec2(15, 11), \n    ivec2( 0, 10), ivec2( 1, 10), ivec2( 2, 10), ivec2( 3, 10), ivec2( 4, 10), \n    ivec2( 5, 10), ivec2( 6, 10), ivec2( 7, 10), ivec2( 8, 10), ivec2( 9, 10),\n    ivec2(10, 10) \n);\n#define chu(name, index) const ivec2 name = Uppercase[index];\nchu(cA,  0) chu(cB,  1) chu(cC,  2) chu(cD,  3) chu(cE,  4)\nchu(cF,  5) chu(cG,  6) chu(cH,  7) chu(cI,  8) chu(cJ,  9)\nchu(cK, 10) chu(cL, 11) chu(cM, 12) chu(cN, 13) chu(cO, 14)\nchu(cP, 15) chu(cQ, 16) chu(cR, 17) chu(cS, 18) chu(cT, 19)\nchu(cU, 20) chu(cV, 21) chu(cW, 22) chu(cX, 23) chu(cY, 24)\nchu(cZ, 25)\n\nconst ivec2[26] Lowercase = ivec2[26]\n(\n    ivec2( 1,  9), ivec2( 2,  9), ivec2( 3,  9), ivec2( 4,  9), ivec2( 5,  9), \n    ivec2( 6,  9), ivec2( 7,  9), ivec2( 8,  9), ivec2( 9,  9), ivec2(10,  9), \n    ivec2(11,  9), ivec2(12,  9), ivec2(13,  9), ivec2(14,  9), ivec2(15,  9), \n    ivec2( 0,  8), ivec2( 1,  8), ivec2( 2,  8), ivec2( 3,  8), ivec2( 4,  8), \n    ivec2( 5,  8), ivec2( 6,  8), ivec2( 7,  8), ivec2( 8,  8), ivec2( 9,  8),\n    ivec2(10,  8) \n);\n#define chl(name, index) const ivec2 name = Lowercase[index];\nchl(ca,  0) chl(cb,  1) chl(cc,  2) chl(cd,  3) chl(ce,  4)\nchl(cf,  5) chl(cg,  6) chl(ch,  7) chl(ci,  8) chl(cj,  9)\nchl(ck, 10) chl(cl, 11) chl(cm, 12) chl(cn, 13) chl(co, 14)\nchl(cp, 15) chl(cq, 16) chl(cr, 17) chl(cs, 18) chl(ct, 19)\nchl(cu, 20) chl(cv, 21) chl(cw, 22) chl(cx, 23) chl(cy, 24)\nchl(cz, 25)\n\nstruct String\n{\n    ivec2[maxStringLength] chars;\n    int count;\n};\n\n#define setString(string, n, contents)\\\n{\\\n    ivec2[n] _s_ = ivec2[n] contents ;\\\n    for(int _i_ = 0; _i_ < min(maxStringLength, n); _i_++)\\\n    {\\\n        string.chars[_i_] = _s_[_i_];\\\n    }\\\n    string.count = n;\\\n}\n#define declString(string, n, contents)\\\nString string;\\\n{\\\n    ivec2[n] _s_ = ivec2[n] contents ;\\\n    for(int _i_ = 0; _i_ < min(maxStringLength, n); _i_++)\\\n    {\\\n        string.chars[_i_] = _s_[_i_];\\\n    }\\\n    string.count = n;\\\n}\n\nstruct Font\n{\n    vec2 texSize;\n    vec2 charSize;\n};\n\nstruct TextCursor\n{\n    vec2 startPos;\n    ivec2 coord;\n    Font font;\n    vec4 color;\n    vec2 charSize;\n    vec2 charSpace;\n    int pageWidth;\n    vec2 fragCoord;\n    vec2 outUV;\n    vec4 outColor;\n};\n\nvec4 getFontCharRect(in Font f, ivec2 char)\n{\n    vec2 uvSize = f.charSize / f.texSize;\n    return vec4(char, char+ivec2(1)) * uvSize.xyxy;\n}\n\nvec4 getCharScreenRect(in TextCursor t)\n{\n    vec2 leftTop = t.startPos + t.charSpace * vec2(t.coord.x, -t.coord.y);\n    vec2 rightBottom = leftTop + t.charSize * vec2(1, -1);\n    \n    return vec4(leftTop.x, rightBottom.y, rightBottom.x, leftTop.y);\n}\n\nvoid updateOutUV(ivec2 char, inout TextCursor t)\n{\n    vec4 fontRect = getFontCharRect(t.font, char);\n    vec4 screenRect = getCharScreenRect(t);\n    vec2 screenRectUV = (t.fragCoord - screenRect.xy) / (screenRect.zw - screenRect.xy);\n    \n    if(clamp(screenRectUV, vec2(0), vec2(1)) != screenRectUV)\n    {\n        return;\n    }\n    \n    t.outUV = screenRectUV * (fontRect.zw - fontRect.xy) + fontRect.xy;\n    t.outColor = t.color;\n}\n\nvoid blend(vec4 src, inout vec4 dest)\n{\n    dest.rgb = mix(dest.rgb, src.rgb, src.a);\n    dest.a = mix(dest.a, 1.0, src.a);\n}\n\nvoid incrementCursor(inout TextCursor t)\n{\n    t.coord.x += 1;\n    if(t.coord.x >= t.pageWidth)\n    {\n        t.coord.x = 0;\n        t.coord.y += 1;\n    }\n}\n\nvoid newlineCursor(inout TextCursor t)\n{\n    t.coord.x = 0;\n    t.coord.y += 1;\n}\n\nvoid printChar(ivec2 char, inout TextCursor t)\n{\n    if(char == cNl)\n    {\n        newlineCursor(t);\n        return;\n    }\n    \n    updateOutUV(char, t);\n    incrementCursor(t);\n}\n\nvoid printString(String s, inout TextCursor t)\n{\n    for(int i = 0; i < min(s.count, maxStringLength); i++)\n    {\n        printChar(s.chars[i], t);\n    }\n}\n\nvoid printLine(String s, inout TextCursor t)\n{\n    for(int i = 0; i < min(s.count, maxStringLength); i++)\n    {\n        printChar(s.chars[i], t);\n    }\n    printChar(cNl, t);\n}\n\nvoid printInt(int val, inout TextCursor t)\n{\n    if(val < 0)\n    {\n        printChar(cMinus, t);\n        val = -val;\n    }\n    \n    int[maxStringLength] digits;\n    int count = 0;\n    \n    for(;;)\n    {\n        digits[count++] = val % 10;\n        \n        if(count >= maxStringLength)\n            break;\n        \n        val /= 10;\n        \n        if(val == 0)\n            break;\n    }\n    \n    for(int i = count-1; i >= 0; i--)\n    {  \n        printChar(Digits[digits[i]], t);\n    } \n}\n\nvoid printFloat(float val, inout TextCursor t)\n{\n    if(val < 0.0)\n    {\n        printChar(cMinus, t);\n        val = -val;\n    }\n    \n    int[maxStringLength] digits;\n    int count = 0;\n    \n    int iVal = int(val);\n    val -= float(iVal);\n    \n    for(;;)\n    {\n        digits[count++] = iVal % 10;\n        \n        if(count >= maxStringLength)\n            break;\n        \n        iVal /= 10;\n        \n        if(iVal == 0)\n            break;\n    }\n    \n    for(int i = count-1; i >= 0; i--)\n    {  \n        printChar(Digits[digits[i]], t);\n    } \n    \n    printChar(cDot, t);\n        \n    const int maxDecimalCount = 4;\n    for(int i = 0; i < maxDecimalCount; i++)\n    {\n        val *= 10.0;\n        \n        int digit = int(val);\n        val -= float(digit);\n        \n        printChar(Digits[digit], t);\n        \n        if(val <= 0.0)\n            break;\n    }\n}\n\nvoid drawText(TextCursor t, sampler2D fontTexture, inout vec4 fragColor)\n{\n    vec4 color = t.outColor;\n    color.a *= texture(fontTexture, t.outUV).r;\n    blend(color, fragColor);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}