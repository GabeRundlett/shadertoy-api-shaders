{
    "Shader": {
        "info": {
            "date": "1688710392",
            "description": "click to interact\ntool used to find these worlds https://www.shadertoy.com/view/ddsBD8",
            "flags": 32,
            "hasliked": 0,
            "id": "ddlfWH",
            "likes": 8,
            "name": "4 worlds of base3 symetryB ",
            "published": 3,
            "tags": [
                "automata"
            ],
            "usePreview": 0,
            "username": "lomateron",
            "viewed": 203
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 a = texelFetch(iChannel0,ivec2(fragCoord),0)*(1./2.);\n    int f = iFrame%2;\n    if(f==0){a = a.xyzw;}\n    if(f==1){a = a.yxwz;}\n    fragColor = a;\n}\n//a function has N inputs and 1 output\n//each input and output is in base2\n//then there are 2^2^N different functions\n//each function can be used in a world simulation\n//exploring all 2^2^N worlds is immpossible for a human so lets decrease the worlds to explore\n//functions were doesnt matter how inputs are swaped the output stays the same\n//then there are 2^(N+1) different functions to explore\n//if using base3 then there are 3^((N+1)(N+2)/2) different functions to explore\n//thats a lot of worlds so lets decrease the worlds to explore\n//functions were doesnt matter how inputs are swaped the output stays the same   and also\n//were FFFFFFFFFFFF (there is no simple description for this other rule...)\n//then there are 3^((N+1)(N+2)/2/3) different functions to explore\n//in this shader N=9 because 3*3 grid of pixels is read per pixel\n//so there are 3^19 worlds to explore\n\n//I name functions with first rule(swapping inputs...) symetryA functions\n//and functions with symetryA + second rule(FFFFFFFFFFFF...) symetryB functions",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define base 3U    //cant be changed\nvec4 read(vec2 u, vec2 m)\n{\n    vec2 z = floor(iResolution.xy/vec2(4,1));\n    vec2 o = mod(u+m,z);\n         u = floor(u/z)*z+o;\n    return texelFetch(iChannel0,ivec2(u),0);\n}\nfloat shiftEq(float a, float b, float c,\n              float x, float y, float z)\n{\n                       float r =-1.;\n    if(a==x && b==y && c==z){r = 0.;}\n    if(c==x && a==y && b==z){r = 1.;}\n    if(b==x && c==y && a==z){r = 2.;}\n    return r;\n}\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    uint a1 = +( 8U +18U*1U)\n              +(13U +18U*0U) *18U*9U\n              +18U*9U*18U*9U *0U;\n         a1 = +( 4U +18U*1U)\n              +( 4U +18U*0U) *18U*9U\n              +18U*9U*18U*9U *0U;\n    uint a2 = +( 8U +18U*4U)\n              +(10U +18U*4U) *18U*9U\n              +18U*9U*18U*9U *0U;\n    uint a3 = +(13U +18U*6U)\n              +(13U +18U*0U) *18U*9U\n              +18U*9U*18U*9U *0U;\n    uint a4 = +( 9U +18U*1U)\n              +( 0U +18U*9U) *18U*9U\n              +18U*9U*18U*9U *0U;\n    float x = floor(4.*u.x/iResolution.x);\n         uint a = 0U;\n    if(x==0.){a = a1;}\n    if(x==1.){a = a2;}\n    if(x==2.){a = a3;}\n    if(x==3.){a = a4;}\n    float c0 = 0.;\n    float c1 = 0.;\n    float c2 = 0.;\n    float z = 1.;\n    for(float y=-z; y<=z; y+=1.){\n    for(float x=-z; x<=z; x+=1.){\n        float v = read(u,vec2(x,y)).x;\n        c0 += float(v==0.);\n        c1 += float(v==1.);\n        c2 += float(v==2.);\n    }}\n    float h = 0.;\n    float dv = 0.; //divisor\n    float md = 0.; //modulo\n    h = shiftEq(c0,c1,c2, 9.,0.,0.); if(h>=0.){dv =  0.;  md = h;}\n    h = shiftEq(c0,c1,c2, 8.,1.,0.); if(h>=0.){dv =  1.;  md = h;}\n    h = shiftEq(c0,c1,c2, 7.,2.,0.); if(h>=0.){dv =  2.;  md = h;}\n    h = shiftEq(c0,c1,c2, 6.,3.,0.); if(h>=0.){dv =  3.;  md = h;}\n    h = shiftEq(c0,c1,c2, 5.,4.,0.); if(h>=0.){dv =  4.;  md = h;}\n    h = shiftEq(c0,c1,c2, 4.,5.,0.); if(h>=0.){dv =  5.;  md = h;}\n    h = shiftEq(c0,c1,c2, 3.,6.,0.); if(h>=0.){dv =  6.;  md = h;}\n    h = shiftEq(c0,c1,c2, 2.,7.,0.); if(h>=0.){dv =  7.;  md = h;}\n    h = shiftEq(c0,c1,c2, 1.,8.,0.); if(h>=0.){dv =  8.;  md = h;}\n    h = shiftEq(c0,c1,c2, 7.,1.,1.); if(h>=0.){dv =  9.;  md = h;}\n    h = shiftEq(c0,c1,c2, 6.,2.,1.); if(h>=0.){dv = 10.;  md = h;}\n    h = shiftEq(c0,c1,c2, 5.,3.,1.); if(h>=0.){dv = 11.;  md = h;}\n    h = shiftEq(c0,c1,c2, 4.,4.,1.); if(h>=0.){dv = 12.;  md = h;}\n    h = shiftEq(c0,c1,c2, 3.,5.,1.); if(h>=0.){dv = 13.;  md = h;}\n    h = shiftEq(c0,c1,c2, 2.,6.,1.); if(h>=0.){dv = 14.;  md = h;}\n    h = shiftEq(c0,c1,c2, 5.,2.,2.); if(h>=0.){dv = 15.;  md = h;}\n    h = shiftEq(c0,c1,c2, 4.,3.,2.); if(h>=0.){dv = 16.;  md = h;}\n    h = shiftEq(c0,c1,c2, 3.,4.,2.); if(h>=0.){dv = 17.;  md = h;}\n    h = shiftEq(c0,c1,c2, 3.,3.,3.); if(h>=0.){dv = 18.;  md = h;}\n    uint dp = uint(dv);\n    uint mp = uint(md);\n    for(uint i=0U; i<dp; i++){a =  a    /base;}\n                              a = (a+mp)%base;\n                              //a = (a+1U)%base;\n    fragColor = vec4(a,read(u,vec2(0)).xyz);\n    {\n        uvec2 p = uvec2(u) + 1920U*1080U*uint(iFrame);\n              p = 1103515245U * ( (p>>1U) ^ (p.yx   ) );\n        uint  q = 1103515245U * ( (p.x  ) ^ (p.y>>3U) );\n        vec2  v = fract(vec2(4,1)*u.xy/iResolution.xy)-.5;\n        float s = .02;\n        if(iMouse.z>.5){s = .001;}\n        if(iMouse.z>.5){v = +(     u.xy/iResolution.xy-.5)\n                            -(iMouse.xy/iResolution.xy-.5);}\n        uint m = uint(step(dot(v,v),s));\n        if(iFrame==0           ){fragColor = vec4((q%3U*m+1U)%3U);}\n        if(iMouse.z>.5 && m!=0U){fragColor = vec4((q%3U*m+1U)%3U);}\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}