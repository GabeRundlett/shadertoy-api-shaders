{
    "Shader": {
        "info": {
            "date": "1546318750",
            "description": "Modding huwbs Milki with my Navier-Stokeish Happy Fucking New Year",
            "flags": 48,
            "hasliked": 0,
            "id": "3ds3WN",
            "likes": 4,
            "name": "MilkyNavier",
            "published": 3,
            "tags": [
                "3d",
                "ray",
                "simulation",
                "march",
                "huwb",
                "navier",
                "stokes"
            ],
            "usePreview": 0,
            "username": "felipunkerito",
            "viewed": 471
        },
        "renderpass": [
            {
                "code": "\n#define RAYMARCH\n#define HEIGHTMAPSCALE 90.\n#define MARCHSTEPS 25\n\n\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos );\n\nfloat h( vec3 p ) { return 0.4*textureLod(iChannel0, p.xz/HEIGHTMAPSCALE + 0.5, 0. ).x; }\nfloat DE( vec3 p ) { return 1.2*( p.y - ( h(p) ) ); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy/iResolution.xy;\n    vec2 qq = q*2.-1.;\n    float eps = 0.1;\n    \n#ifdef RAYMARCH\n    \n    vec3 L = normalize(vec3(.3,.5,1.));\n    \n    // raymarch the milk surface\n    vec3 ro;\n    vec3 rd = computePixelRay( qq, ro );\n    float t = 0.;\n    float d = DE(ro+t*rd);\n    \n    for( int i = 0; i < MARCHSTEPS; i++ )\n    {\n        if( abs(d) < eps )\n            break;\n        \n        float dNext = DE(ro+(t+d)*rd);\n        \n        // detect surface crossing\n        // https://www.shadertoy.com/view/Mdj3W3\n\t\tfloat dNext_over_d = dNext/d;\n        if( dNext_over_d < 0.0 )\n        {\n            // estimate position of crossing\n\t\t\td /= 1.0 - dNext_over_d;\n\t\t\tdNext = DE( ro+rd*(t+d) );\n        }\n        \n\t\tt += d;\n\t\td = dNext;\n    }\n    \n    float znear = 95.;\n    float zfar  = 130.;\n    \n    // hit the milk\n    if( t < zfar )\n    //if( d < eps ) // just assume always hit, turns out its hard to see error from this\n    {\n        vec3 p = ro+t*rd;\n        \n\t    fragColor = vec4( textureLod(iChannel0, p.xz/HEIGHTMAPSCALE+0.5, 0. ).x );\n        \n        // finite difference normal\n        float h0 = h(p);\n        vec2 dd = vec2(0.01,0.);\n        vec3 n = normalize(vec3( h0-h(p + dd.xyy), dd.x, h0-h(p + dd.yyx) ));\n        \n        // improvised milk shader, apologies for hacks!\n        vec3 R = reflect( rd, n );\n        float s = 1.4*pow( clamp( dot( L, R ), 0., 1. ), 4000. );\n        float ndotL = clamp(dot(n,L),0.,1.);\n        float dif = 1.42*(0.8+0.2*ndotL);\n        // occlude valleys a little and boost peaks which gives a bit of an SSS look\n        float ao = mix( 0.8, .99, smoothstep(0.,1.,(h0+1.5)/6.));\n        // milk it up\n        vec3 difCol = texture( iChannel0, p.xz/HEIGHTMAPSCALE + 0.5 ).rgb;\n        difCol += 0.6 * texture( iChannel1, R ).rgb;\n        fragColor.xyz = difCol*(dif)*ao + vec3(1.,.79,0.74)*s;\n        // for bonus points, emulate an anisotropic phase function by creaming up the region\n        // between lit and unlit\n        float creamAmt = smoothstep( 0.2, 0., abs(ndotL - 0.2) );\n        fragColor.xyz *= mix( vec3(1.), vec3(1.,0.985,0.975), creamAmt );\n    }\n    \n    // fade to background\n    vec3 bg = vec3(0.5) + 0.5*pow(clamp(dot(L,rd),0.,1.),20.);\n    bg *= vec2(1.,0.97).yxx;\n    fragColor.xyz = mix( fragColor.xyz, bg, smoothstep(znear,zfar,t) );\n    \n\t// vignette (borrowed from donfabio's Blue Spiral)\n\tvec2 uv =  q.xy-0.5;\n\tfloat distSqr = dot(uv, uv);\n\tfragColor.xyz *= 1.0 - .5*distSqr;\n    \n#else\n    float sh = 1. - texture(iChannel0, q).x;\n    vec3 c =\n       vec3(exp(pow(sh-.25,2.)*-5.),\n            exp(pow(sh-.4,2.)*-5.),\n            exp(pow(sh-.7,2.)*-20.));\n    fragColor = vec4(c,1.) + texture( iChannel0, uv );\n#endif\n}\n\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos )\n{\n    // camera orbits around origin\n\t\n    float camRadius = 60.;\n\tfloat theta = -3.141592653/2.;\n    float xoff = camRadius * cos(theta);\n    float zoff = camRadius * sin(theta);\n    cameraPos = vec3(xoff,20.,zoff);\n     \n    // camera target\n    vec3 target = vec3(0.,0.,0.);\n     \n    // camera frame\n    vec3 fo = normalize(target-cameraPos);\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\n    vec3 up = normalize(cross(fo,ri));\n     \n    // multiplier to emulate a fov control\n    float fov = .5;\n\t\n    // ray direction\n    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);\n\t\n\treturn rayDir;\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Undefine the next line for camera input.\n//#define WATERPAINTING\n// Heavily bitting P_Malin's https://www.shadertoy.com/view/XdlGz8 for the fake 3D effect.\n//#define FAKETHREED\nconst float forceVector = 10.0;\nconst float forceColour = 10.0;\nconst float dx = 0.5;\nconst float dt = dx * dx * 0.5;\nconst float siz = 0.1;\nconst float di = 1.25;\nconst float alp = ( dx * dx ) / dt;\nconst float rbe = 1.0 / ( 4.0 + alp );\nconst float vo = 20.0;\nconst float vf = 0.0025;\nconst float mul = 10.0;\nconst float e = 0.05;\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define HEIGHTMAPSCALE 90.0\n\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos );\n\n//2D Vector field visualizer by nmz (twitter: @stormoid)\n\n/*\n\tThere is already a shader here on shadertoy for 2d vector field viz, \n\tbut I found it to be hard to use so I decided to write my own.\n\n\tHeavily modified by felipunkerito to make it work as an interactive vector field \n\tfor my fluid sim.\n\n*/\n\n#define keyTex iChannel3\n#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float arrow_density = 0.2;\nconst float arrow_length = 0.95;\n\nconst vec3 luma = vec3(0.2126, 0.7152, 0.0722);\n\nfloat segm(in vec2 p, in vec2 a, in vec2 b) //from iq\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp(dot(pa,ba)/dot(ba,ba), 0., 1.);\n\treturn length(pa - ba*h)*20.*arrow_density;\n}\n\nfloat cur( vec2 uv )\n{\n    \n    float xpi = 1.0 / iResolution.x;\n    float ypi = 1.0 / iResolution.y;\n    \n    float x = uv.x;\n    float y = uv.y;\n    \n    float top = texture( iChannel0, vec2( x, y + ypi ) ).r;\n    float lef = texture( iChannel0, vec2( x - xpi, y ) ).r;\n    float rig = texture( iChannel0, vec2( x + xpi, y ) ).r;\n    float dow = texture( iChannel0, vec2( x, y - ypi ) ).r;\n    \n    float dY = ( top - dow ) * 0.5;\n    float dX = ( rig - lef ) * 0.5;\n    \n    return dX * dY;\n}\n\nvec2 vor( vec2 uv )\n{\n    \n    vec2 pre = uv;\n    \n    float xpi = 1.0 / iResolution.x;\n    float ypi = 1.0 / iResolution.y;\n    \n    float x = uv.x;\n    float y = uv.y;\n\n    vec2 dir = vec2( 0 );\n    dir.y = ( cur( vec2( x, y + ypi ) ) ) - ( cur( vec2( x, y - ypi ) ) );\n    dir.x = ( cur( vec2( x + xpi, y ) ) ) - ( cur( vec2( x - xpi, y ) ) );\n    \n    dir = normalize( dir );\n    \n    if( length( dir ) > 0.0 )\n    \n    uv -= dt * vo * cur( uv ) * dir;\n    \n    return uv;\n    \n}\n\nfloat dis( vec2 uv, vec2 mou )\n{\n\n    return length( uv - mou );\n\n}\n\nfloat cir( vec2 uv, vec2 mou, float r )\n{\n\n    float o = smoothstep( r, r - 0.05, dis( uv, mou ) );\n    \n    return o;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.y;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 mou = iMouse.xy / iResolution.y;\n    p *= mul;\n    mou *= mul;\n    \n    float fO = 0.0;\n    fO += texture( iChannel1, vor( uv ) ).r + texture( iChannel1, vor( uv ) ).g + texture( iChannel1, vor( uv ) ).b;\n   \tfO *= 0.333;\n    \n    vec2 ep = vec2( e, 0 );\n    vec2 rz= vec2( 0 );\n    vec2 fra = fract( uv );\n\n    float t0 = 0.0, t1 = 0.0, t2 = 0.0;\n    t0 += texture( iChannel0, uv ).a * dt * vf;\n    t1 += texture( iChannel0, uv + ep.xy ).a * dt * vf;\n    t2 += texture( iChannel0, uv + ep.yx ).a * dt * vf;\n    vec2 g = vec2( ( t1 - t0 ), ( t2 - t0 ) ) / ep.xx;\n    vec2 t = vec2( -g.y, g.x );\n\n    p += 0.9 * t + g * 0.3;\n    rz += t;\n    \n    vec2 fld = rz;\n    \n    if( cir( p, mou, siz * mul ) > 0.1 && iMouse.z > 0.5 )\n            \n        fld += forceVector * texture( iChannel2, uv ).xy;\n    \n    float o = 0.0;\n    \n    if( iFrame <= 4 || KEY_I < 0.5 )\n    \n    o = texture( iChannel0, uv ).a * 0.99;\n    \n    fO += o;\n    \n    if( uv.y < 0.00 || uv.x < 0.00 || uv.x > 1.0 || uv.y > 1.0 ) o *= 0.0;\n    \n    fragColor = vec4( 0, fld, fO );\n    \n}\n\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos )\n{\n    // camera orbits around origin\n\t\n    float camRadius = 60.;\n\tfloat theta = -3.141592653/2.;\n    float xoff = camRadius * cos(theta);\n    float zoff = camRadius * sin(theta);\n    cameraPos = vec3(xoff,20.,zoff);\n     \n    // camera target\n    vec3 target = vec3(0.,0.,0.);\n     \n    // camera frame\n    vec3 fo = normalize(target-cameraPos);\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\n    vec3 up = normalize(cross(fo,ri));\n     \n    // multiplier to emulate a fov control\n    float fov = .5;\n\t\n    // ray direction\n    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);\n\t\n\treturn rayDir;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define HEIGHTMAPSCALE 90.0\n\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos );\n\nfloat hash( vec2 a )\n{\n\n    return fract( sin( a.x * 3433.8 + a.y * 3843.98 ) * 45933.8 );\n\n}\n\nfloat noise( vec2 uv )\n{\n    \n    vec2 lv = fract( uv );\n    lv = lv * lv * ( 3.0 - 2.0 * lv );\n    vec2 id = floor( uv );\n    \n    float bl = hash( id );\n    float br = hash( id + vec2( 1, 0 ) );\n    float b = mix( bl, br, lv.x );\n    \n    float tl = hash( id + vec2( 0, 1 ) );\n    float tr = hash( id + vec2( 1 ) );\n    float t = mix( tl, tr, lv.x );\n    \n    float c = mix( b, t, lv.y );\n    \n    return c;\n\n}\n\nfloat fbm( vec2 uv )\n{\n\n\tfloat f = noise( uv * 4.0 );\n    f += noise( uv * 8.0 ) * 0.5;  \n    f += noise( uv * 16. ) * 0.25; \n    f += noise( uv * 32. ) * 0.125; \n    f += noise( uv * 64. ) * 0.0625;\n    f /= 2.0;\n    \n    return f;\n\n}\n\nfloat cur( vec2 uv )\n{\n    \n    float xpi = 1.0 / iResolution.x;\n    float ypi = 1.0 / iResolution.y;\n    \n    float x = uv.x;\n    float y = uv.y;\n    \n    float top = texture( iChannel0, vec2( x, y + ypi ) ).r;\n    float lef = texture( iChannel0, vec2( x - xpi, y ) ).r;\n    float rig = texture( iChannel0, vec2( x + xpi, y ) ).r;\n    float dow = texture( iChannel0, vec2( x, y - ypi ) ).r;\n    \n    float dY = ( top - dow ) * 0.5;\n    float dX = ( rig - lef ) * 0.5;\n    \n    return dX * dY;\n}\n\nvec2 vor( vec2 uv )\n{\n    \n    vec2 pre = uv;\n    \n    float xpi = 1.0 / iResolution.x;\n    float ypi = 1.0 / iResolution.y;\n    \n    float x = uv.x;\n    float y = uv.y;\n\n    vec2 dir = vec2( 0 );\n    dir.y = ( cur( vec2( x, y + ypi ) ) ) - ( cur( vec2( x, y - ypi ) ) );\n    dir.x = ( cur( vec2( x + xpi, y ) ) ) - ( cur( vec2( x - xpi, y ) ) );\n    \n    dir = normalize( dir );\n    \n    if( length( dir ) > 0.0 )\n    \n    uv -= dt * vo * cur( uv ) * dir;\n    \n    return uv;\n    \n}\n\nvec2 dif( vec2 uv )\n{\n\n    float xpi = 1.0 / iResolution.x;\n    float ypi = 1.0 / iResolution.y;\n    \n    float x = uv.x;\n    float y = uv.y;\n    \n    vec2 cen = texture( iChannel0, uv ).xy;\n    vec2 top = texture( iChannel0, vec2( x, y + ypi ) ).xy;\n    vec2 lef = texture( iChannel0, vec2( x - xpi, y ) ).xy;\n    vec2 rig = texture( iChannel0, vec2( x + xpi, y ) ).xy;\n    vec2 dow = texture( iChannel0, vec2( x, y - ypi ) ).xy;\n    \n    return ( di * rbe ) * ( top + lef + rig + dow + alp * cen ) * rbe;\n    \n}\n\nvec2 adv( vec2 uv )\n{\n    \n    // Eulerian.\n    vec2 pre = texture( iChannel1, vor( uv ) ).yz;\n    pre = iTimeDelta * dt * pre;\n    \n    uv -= pre;\n    \n    return uv;\n    \n}\n\nfloat dis( vec2 uv, vec2 mou )\n{\n\n    return length( uv - mou );\n\n}\n\nfloat cir( vec2 uv, vec2 mou, float r )\n{\n\n    float o = smoothstep( r, r - 0.05, dis( uv, mou ) );\n    \n    return o;\n\n}\n\nvec4 forc( vec2 uv, vec2 p, vec2 mou, sampler2D tex, out float cen )\n{\n    \n    vec4 col = vec4( 0 );\n    \n    #ifdef WATERPAINTING\n    \n    if( iFrame <= 10 )\n    \n    col += 0.2 * texture( iChannel2, uv );\n    \n    if( iMouse.z > 0.5 )\n\tcol += cir( p, mou, siz );\n    \n    #else\n    float tim = iTime * 0.1;\n    if( iMouse.z > 0.5 && cir( p, mou, siz ) > 0.1 )\n\tcol += forceColour * vec4( noise( uv + tim ), noise( uv + tim + 1.0 ), noise( uv + tim + 2.0 ), 1 );\n    \n    #endif\n    \n    return col;\n\n}\n\nvec2 div( vec2 uv, vec2 p, vec2 mou )\n{\n    \n    float xpi = 1.0 / iResolution.x;\n    float ypi = 1.0 / iResolution.y;\n    \n    float x = uv.x;\n    float y = uv.y;\n    \n    float cen = texture( iChannel0, uv ).a;\n    float top = texture( iChannel0, vec2( x, y + ypi ) ).r;\n    float lef = texture( iChannel0, vec2( x - xpi, y ) ).r;\n    float rig = texture( iChannel0, vec2( x + xpi, y ) ).r;\n    float dow = texture( iChannel0, vec2( x, y - ypi ) ).r;\n    \n    float dX = dt * ( rig - lef ) * 0.5;\n    float dY = dt * ( top - dow ) * 0.5;\n    \n    vec2 vel = vec2( 0 );\n    \n    if( iMouse.z > 0.5 && cir( p, mou, siz ) > 0.1 )\n    \n    vel = forceVector * texture( iChannel3, uv ).xy;\n    \n    return vec2( dX, dY ) + vel;\n\n}\n\nvec2 pre( vec2 uv, vec2 p, vec2 mou )\n{\n\n    vec2 pre = uv;\n    \n    uv -= ( di * dx * dx ) * div( uv, p, mou );\n    \n    return uv;\n\n}\n\nvec2 vel( vec2 uv, vec2 p, vec2 mou )\n{\n    \n    vec2 pr = pre( uv, p, mou );\n    vec2 die = div( uv, p, mou );\n    \n    uv += dt * die - pr;\n   \n    return uv;\n    \n}\n\nvec4 jac( vec2 uv, vec2 p, vec2 mou, out float cen )\n{\n\n    vec4 col = vec4( 0.0 ); float dam = 1.0; vec4 colO = vec4( 0 ); vec2 pre = uv;\n    \n    vec2 tem = uv;\n \n    uv = adv( uv );\n    uv -= dt * ( vel( uv, p, mou ) * dif( uv ) );\n    col += forc( uv, p, mou, iChannel0, cen );\n    colO = texture( iChannel0, uv ) + col * dt;\n    colO *= 0.99;\n    \n    if( pre.y < 0.01 || pre.x < 0.01 || pre.x > 1.0 || pre.y > 1.0 ) colO *= 0.0;\n    \n    return colO;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 p = fragCoord / iResolution.y;\n\n    vec2 mou = iMouse.xy / iResolution.y;\n    \n    float ini = 0.0;\n    \n    float cen = 0.0;\n    \n    vec4 colO = jac( uv, p, mou, cen );\n    \n    fragColor = colO;\n    \n}\n\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos )\n{\n    // camera orbits around origin\n\t\n    float camRadius = 60.;\n\tfloat theta = -3.141592653/2.;\n    float xoff = camRadius * cos(theta);\n    float zoff = camRadius * sin(theta);\n    cameraPos = vec3(xoff,20.,zoff);\n     \n    // camera target\n    vec3 target = vec3(0.,0.,0.);\n     \n    // camera frame\n    vec3 fo = normalize(target-cameraPos);\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\n    vec3 up = normalize(cross(fo,ri));\n     \n    // multiplier to emulate a fov control\n    float fov = .5;\n\t\n    // ray direction\n    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);\n\t\n\treturn rayDir;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "float scr( vec2 uv, vec2 mou )\n{\n\n    return length( uv - mou );\n\n}\n\nfloat dis( vec2 p, vec2 uv, vec2 mou )\n{\n\n    float fin = smoothstep( 0.025, 0.025 - 0.005, scr( uv, mou ) );\n    \n    return fin;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 p = fragCoord / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 mou = iMouse.xy / iResolution.y;\n     \n    float xDif = mou.x - texture( iChannel0, uv ).x;\n    float yDif = mou.y - texture( iChannel0, uv ).y;\n\n    float deltaTemp = iTimeDelta;\n    \n    if( xDif != 0.0 && iMouse.z > 0.5 )\n    {\n\n        if( deltaTemp == 0.0 ) deltaTemp = 1.0;\n\n        float vX = xDif / deltaTemp;\n\n    }\n\n    if( yDif != 0.0 && iMouse.z > 0.5 )\n    {\n\n        if( deltaTemp == 0.0 ) deltaTemp = 1.0;\n\n        float vY = yDif / deltaTemp;\n\n    }\n    \n    fragColor = vec4( mou, 1, 1 );\n    fragColor.xy += texture( iChannel0, uv ).xy;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}