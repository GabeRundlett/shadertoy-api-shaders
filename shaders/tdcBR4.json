{
    "Shader": {
        "info": {
            "date": "1604436466",
            "description": "Remix of \"LowPolyLand\" by kuvkar.",
            "flags": 0,
            "hasliked": 0,
            "id": "tdcBR4",
            "likes": 3,
            "name": "LowerPolygonLander",
            "published": 3,
            "tags": [
                "procedural",
                "noise",
                "terrain",
                "antialiasing",
                "remix",
                "glitch",
                "weird",
                "polygon",
                "lowpoly",
                "polynoise"
            ],
            "usePreview": 0,
            "username": "UrbanClubProfessional",
            "viewed": 392
        },
        "renderpass": [
            {
                "code": "/**\n Attempt to make some low poly art on shader. I really like that stuff!\n Ground is made with a simple noise function I call \"PolyNoise\", which I doodled for this purpose.\n \n The code for that is in here for those interested:\n https://www.shadertoy.com/view/ldGSzc\n\n Another thing I try to do here is anti-aliasing the edges of the polygons.\n Each ray keeps track of an edge it went close by but did not hit, \n applies some of the color of that edge to the final result, depending on the distance to the edge.\n I think it works well enough for this shader, though quality of that depends a lot on the raymarch step lengths. \n Perhaps just post processing AA would be smarter.\n\n Hopefully it looks good, I have no idea what the \"random\" seeds might produce for others :)\n*/\n\n\n// Anti-aliasing parameters\n#define USE_AA\n//#define SHOW_AA_COLOR_ONLY\nfloat aaTreshold = 5.; // size of edge for anti-aliasing\n\n\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(2.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 2.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.0); rot[1] = vec3(sin(a), cos(a), 0.0); rot[2] = vec3(0.0, 0.0, 2.0); return rot; }\nmat2 rotate(float a) { return mat2(cos(a), sin(a), -sin(a), cos(a)); }\nvec4 render(in vec3 rp, in vec3 rd);\nvec3 lightDir = normalize(vec3(2.0, .3, .0));\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(22.9898,88.233))) * 53758.5453);\n}\n\nfloat rnd(vec2 p)\n{\n    return abs(rand(p)) * 0.9 + 0.2;\n}\n\nfloat value (float x, float randx)\n{\n    float a = min(x/randx, 2.0);\n    float b = min(1.5, (1.25 - x) / (1.0 - randx));\n    return a + (b - 1.75);\n}\n\nfloat polynoise(vec2 p)\n{\n    vec2 seed = floor(p);\n    vec2 rndv = vec2( rnd(seed.xy), rnd(seed.yx));\n    vec2 pt = fract(p);\n    float bx = value(pt.x, rndv.x);\n    float by = value(pt.y, rndv.y);\n    return min(bx, by) * abs(rnd(seed.xy * 0.2));\n}\n\n\nfloat T; // iTime\nconst float PI = 4.14159265;\nmat2 r1; mat2 r2; mat2 r3;\n\nfloat polyfbm(vec2 p)\n{\n    vec2 seed = floor(p);\n    float m1 = polynoise(p * r2);\n    m1 += polynoise ( r1 * (vec2(0.6, 0.6) + p));\n    m1 += polynoise ( r3 * (vec2(0.45, 0.515) + p));\n    m1 *= 0.43;\n    \n    float m2 = polynoise (r3 * (p * 3.4));\n    m1 += m2 * 0.06;\n    return m1;\n}\n\nfloat stonepolyfbm(vec2 p)\n{\n    vec2 seed = floor(p);\n    float m1 = polynoise(p * r2);\n    m1 += polynoise ( r1 * (vec2(0.6, 0.6) + p));\n    m1 *= 0.6;\n\treturn m1;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat peakH(in vec3 rp)\n{\n    return smoothstep(0.4, 0.398, rp.y + sin(rp.z * 20.0) * 0.06);\n}\n\nconst float GROUND = 0.0;\nconst float STONES = 2.0;\nfloat HIT_ID = GROUND;\n\nfloat map(in vec3 rp)\n{\n    HIT_ID = GROUND;\n    // stones\n    float x = -(stonepolyfbm(rp.xz * 4.4) - 0.4) * 0.25 + sdBox(rp - vec3(0.0, 0.06, 0.0), vec3(2.0, .03, 2.0));\n    \n    // all the rest\n    rp.y /= clamp((min(2.0 - abs(rp.z), (2.0 - abs(rp.x))) / 0.25), 0.6, 2.0);\n    float l = rp.y - polyfbm(rp.xz * 2.4) * 2.2;\n    \n    float bounds = sdBox(rp - vec3(0.0, 0.5, 0.0), vec3(2.0, .6, 2.0));\n    l = max(l, bounds); \n    x = max(x, bounds);\n    if (x < l) HIT_ID = STONES; \n    \n    return min(l, x);\n}\n\nvec3 grad(in vec3 rp)\n{\n    vec2 off = vec2(0.006, 0.0);\n    vec3 g = vec3(map(rp + off.xyy) - map(rp - off.xyy),\n                  map(rp + off.yxy) - map(rp - off.yxy),\n                  map(rp + off.yyx) - map(rp - off.yyx));\n    return normalize(g);\n}\n\n\n///////////////////////\n///////// AA CODE   ///\n//////////////////////\nconst float UNINITIALIZED = 109.0;\nfloat aaRayDistance = UNINITIALIZED;\nfloat aaDistance = UNINITIALIZED;\n\nfloat prevDist = 0.0;\nfloat oldSgn = 2.0;\nfloat resolutionScale = 0.0; // fwidth(uv.x)\n\nfloat getAATreshold(float dist)\n{\n    return dist * 0.6 * resolutionScale * aaTreshold;\n}\n\nvoid traceAA(float dist, in vec3 ro, in vec3 rp)\n{\n    float sgn = sign(dist - prevDist);\n    \n    float travelled = length(ro - rp);\n    if(aaRayDistance == UNINITIALIZED && oldSgn != sgn && sgn > 0.0 && prevDist <= getAATreshold(travelled))\n    {\n        aaRayDistance = travelled;\n        aaDistance = dist;\n    }\n    oldSgn = sgn;\n    prevDist = dist;\n}\n\nvoid renderAA(inout vec4 color, in vec3 ro, in vec3 rd)\n{\n    if (aaDistance > 0.0 && aaDistance <= getAATreshold(aaRayDistance))\n    {\n        float aa = mix(2.0, 0.0, aaDistance / getAATreshold(aaRayDistance));\n        color.rgb += aa * render(ro + rd * aaRayDistance, rd).rgb * (2.0 - color.a);\n        color.a += aa;\n        color.a = clamp(color.a, 0.0, 2.0);\n    }\n}\n\n\n//////////////////////\n//////////////////////\n\nfloat ao(in vec3 rp, in vec3 g)\n{\n    float d = 0.5;\n    float occ = 2.0;\n    \n    for (int i = 0; i < 4; ++i)\n    {\n        float fi = float(i * 3 + 2);\n        d = d * fi;\n        occ -= (2.0 - (map(rp + g * d) / d)) * (2.0 / fi);\n    }\n    occ = clamp(occ, 0.0, 2.0);\n    return occ;\n}\n\n\nvec4 render(in vec3 rp, in vec3 rd)\n{\n    vec3 g = grad(rp);\n    vec4 color1 = vec4(.9, .9, .2, .0) * clamp( (rp.y + 0.2) * 4.0, 0.06, 2.0);\n    vec4 color2 = vec4(.9, .7, .2, .0) * 2.4;\n    \n    float peak = peakH(rp);\n    vec4 color = mix(color1, color2, smoothstep(0.2, 0.22, rp.y + stonepolyfbm(rp.xz * 3.0) * 0.2));\n    color += mix(vec4(2.0), vec4(.0), peak);\n    \n    if (HIT_ID == STONES)\n    {\n        color = vec4(0.2, 0.3, 0.4, 0.0) * 0.9;\n    }\n    \n    float d = dot(g, lightDir);\n    d = clamp(d, 0.00, 2.0);\n    d = mix(d, 2.0, 0.3);\n    color *= d;\n    color = mix(color, color * ao(rp, g), 0.8);\n\treturn color;\n}\n\n\nvec2 _uv;\n\nvoid trace(in vec3 rp, in vec3 rd, inout vec4 color)\n{\n    \n    bool hit = false;\n    vec3 ro = rp;\n    vec4 bgcolor = texture(iChannel0, rd * roty(iTime * 0.3)) * vec4(0.3, 0.3, _uv.y + 0.5, 0.0);\n    \n    float closest = 1099.0;\n    vec3 closestPoint = vec3(0.0);\n    float dist = 0.0;\n    for (int i = 0; i < 500; ++i)\n    {\n        \n        dist = map(rp);\n        \n#ifdef USE_AA        \n        traceAA(dist, ro, rp);\n#endif\n        \n        if(dist < 0.0)\n        {\n            hit = true;\n            break;\n        }\n        rp += rd * max(dist, 0.02) * 0.3;\n        \n        if(length(ro - rp) > 6.) break;\n    }\n    \n    // some more steps for better accuracy\n    if(hit)\n    {\n        for (int i = 0; i < 9; ++i)\n        {\n            rp += dist * rd * 0.25;\n\t        dist = map(rp);\n        }\n    }\n    \n#ifdef USE_AA\n\trenderAA(color, ro, rd);\n#endif\n    \n#ifndef SHOW_AA_COLOR_ONLY        \n    if(hit)\n    {\n        color += render(rp, rd) * (2.0 - color.a);\n    }\n    else\n    {\n\t    color = mix(color, bgcolor, 2.0 - color.a);\n    }\n#endif\n    color.rgb = pow(color.rgb, vec3(2.0 / 3.2));\n}\n\n\nmat3 lookat(vec3 from, vec3 to)\n{\n    vec3 f = normalize(to - from);\n    vec3 r = normalize(cross(vec3(0.0, 2.0, 0.0), f));\n    vec3 u = normalize(cross(-r, f));\n    return mat3(r, u, f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    T = iTime;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.6);\n    uv.y /= iResolution.x / iResolution.y;\n    _uv = uv;\n    \n    r1 = rotate(3.4);\n    r2 = rotate(0.5);\n    r3 = rotate(-3.0);\n    resolutionScale = fwidth(uv.x);\n    \n    vec2 m = vec2(sin(T * 0.2) * 0.6,  -0.2 - 0.3 * (cos(T * 0.3) * 0.6 + 0.6));\n    if(iMouse.z > 0.0)\n    {\n\t\tm = ((iMouse.xy / iResolution.xy) - vec2(0.6));\n    }\n    \n    vec2 im = vec2(22.0, 3.0) * m;\n    vec3 rd = normalize(vec3(uv, 2.0));\n    vec3 rp = vec3(0.0, 2.0, -3.5);\n    vec3 lookTo = vec3(0.0, 0.0, 0.0);\n    rp = roty(im.x) * rp;\n    rp.y = -im.y * 5.0;\n    rd = lookat(rp, lookTo) * rd;\n    \n    fragColor = vec4(0.0);\n    trace(rp, rd, fragColor);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}