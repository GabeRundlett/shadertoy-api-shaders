{
    "Shader": {
        "info": {
            "date": "1520044467",
            "description": "One weird trick to figure out whether the shader is paused! \n\nThe screen flashes when you click in the canvas. When you pause and then click, the play symbol changes to a pause symbol. It won't change back till you hit play again.",
            "flags": 48,
            "hasliked": 0,
            "id": "XdtyWB",
            "likes": 6,
            "name": "minidemo #3: pause detection",
            "published": 3,
            "tags": [
                "detection",
                "pause"
            ],
            "usePreview": 0,
            "username": "mattz",
            "viewed": 676
        },
        "renderpass": [
            {
                "code": "/* \"minidemo #3: pause detection\", by mattz\n   License Creative Commons Attribution 3.0 (CC BY 3.0) Unported License.\n\n   This could be helpful, assuming you're using a separate render pass\n   to manage state, like https://www.shadertoy.com/view/Md3yRB\n\n   In that shader, I wanted the rendering to smoothly transition \n   between rendering modes when running, but to transition instantly \n   when paused -- otherwise the GUI would seem unresponsive.\n\n   A fun puzzle was to figure out how to tell from within the shader\n   whether it was paused or not. I finally figured out that if you\n   store the current and previous render times somewhere in a control\n   buffer, you can compare the PREVIOUS time to the CURRENT value\n   of the iTime uniform. If the shader is paused, then they will be\n   equal (at least in the browsers I've tested with).\n\n   Of course, you need to trigger a render after hitting the pause \n   button, otherwise Shadertoy will just keep displaying the last \n   frame rendered before the pause. So the pause detection code \n   doesn't do anything until the user clicks in the canvas...\n\n */\n\n// Signed distance to 2D line\nfloat dline(vec2 p, vec2 a, vec2 b) {\n    \n    vec2 ba = b-a;\n    vec2 n = normalize(vec2(-ba.y, ba.x));\n    \n    return dot(p, n) - dot(a, n);\n    \n}\n\n// Signed distance to 2D box\nfloat dbox(vec2 p, vec4 b) {\n    \n    p = abs(p - b.xy) - b.zw;\n    return max(p.x, p.y);\n    \n}\n\n// Very very simple render example\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // we expect the render time of LAST frame to be stored at \n    // some known place in a buffer\n    float prev_render_time = texelFetch(iChannel0, ivec2(0), 0).x;\n    \n    // compare to the current iTime uniform -- if equal, we are paused\n    bool is_paused = (prev_render_time == iTime);\n    \n    // everything from here down is just rendering.\n    vec2 ctr = 0.5*iResolution.xy;\n    float scl = 2.0 / iResolution.y;\n    \n    vec2 p = (fragCoord - ctr)*scl;\n\n    float d = 1e5;\n    \n    if (is_paused) {\n        p = abs(p);\n        d = dbox(p, vec4(0.3, 0, .15, .5));\n    } else {\n        vec2 p0 = vec2(0.5, 0);\n        vec2 p1 = vec2(-0.6, 0.5);\n        p.y = abs(p.y);\n        d = max(dline(p, p1, p0), -p.x - 0.6);\n    }\n    \n    float bg_lum = (min(iMouse.z, iMouse.w) > 0.) ? .6 : .5;    \n       \n    float lum = mix(0., bg_lum, smoothstep(0., scl, d));\n    lum = pow(lum, 1.0/2.2);\n    \n    fragColor = vec4(vec3(lum), 1);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    // store LAST frame's render time in fragColor.x\n    fragColor.x = fragColor.y;\n\n    // store the CURRENT render time in fragColor.y\n    fragColor.y = iTime;\n    \n    \n    // that's it!\n    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}