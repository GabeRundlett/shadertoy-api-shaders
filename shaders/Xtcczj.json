{
    "Shader": {
        "info": {
            "date": "1533217962",
            "description": "Combining random vertical and horizontal line segments to vaguely form pseudo digitized script logograms used in various parts of Asia.",
            "flags": 0,
            "hasliked": 0,
            "id": "Xtcczj",
            "likes": 61,
            "name": "Pseudo CJKV Characters",
            "published": 3,
            "tags": [
                "font",
                "vector",
                "letter",
                "char",
                "psuedo"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 1791
        },
        "renderpass": [
            {
                "code": "/*\n\n\tPseudo CJKV Characters\n\t----------------------\n\n\tCombining random vertical and horizontal line segments to vaguely form \n\tpseudo digitized script logograms used in various parts of Asia. From \n\t834144373's perpective, it will look like a bunch of meaningless random \n\tlines strung together by an illiterate Westerner. :D\n\n\tFabrice Neyret recently posted a trimmed down version of Otavio Good's\n\t\"Runes\" example, and it reminded me of a pseudo Chinese character\n\tversion I'd seen around in a few places. This particular image was\n\tmodelled from memory off an image I came across on a Tumblr blog called \n    \"Experiments In Processing\" run by Jerome Herr. The link is below, for \n\tanyone interested.\n\n\tAs you can see, it's just some random horizontal and vertical lines. \n\tThis should have been a very simple exercise -- Render 16 horizontal \n\tsegments and 16 vertical segments in a random fashion, and you're done. \n\tCouldn't be easier... unless you have the logic of a drunk squirrel, and \n\tspend ages not realizing that four lines bound three cells and not four. :D\n\n\tAnyway, to a Westerner like myself, it gives the impression of digitized\n\tChinese characters for about 2 seconds, before the brain starts to sense\n\tthat something's amiss. At that point, the characters take on a pseudo\n\talien appearance, which is vaguely interesting in its own right. Someone\n\twith more expertise might be able to apply some heuristics to make it\n\tlook more one way or the other, but this was just a quick diversion, so I\n\twouldn't take it too seriously. :)\n\n\tI'll put together a fancier example later, but for now, I just wanted to \n\tshow a proof of concept. By the way, if you didn't require rounded lines, \n\tyou could push this out in a couple of tweets or less.\n\n\tInspired by:\n\n\trunes (simplified version)  - FabriceNeyret2\n    https://www.shadertoy.com/view/4ltyDM\n    Which in turn was based on:\n\trunes - otaviogood \n\thttps://www.shadertoy.com/view/MsXSRn\n\t\n\n    Image based on:\n\n\t// Dave Hoskins tracked down the image I based this off of:\n    grid stuff 5: pseudo-chinese\n\thttp://p5art.tumblr.com/page/13 -- That could change later.\n\n    // The rest of the blog contains some really cool imagery and is \n    // worth perusing through:\n\tExperiments In Processing - Jerome Herr\n    http://p5art.tumblr.com/archive\n\n\t\n\n*/\n\n// Westernize the psuedo script, as per Stb's suggestion. \n//#define PSEUDO_WESTERN\n\n#ifdef PSEUDO_WESTERN\nconst int vMax = 3;\nconst int hMax = 2;\nconst float th = 1./2.5; // Line drawing probability threshold.\n#else\nconst int vMax = 4;\nconst int hMax = 4;\nconst float th = 1./3.; // Line drawing probability threshold.\n#endif\n\n\n// This is a rewrite of IQ's original. It's self contained, which makes it much\n// easier to copy and paste. I've also tried my best to minimize the amount of \n// operations to lessen the work the GPU has to do, but I think there's room for\n// improvement.\n//\nfloat n3D(vec3 p){\n    \n    // Just some random figures, analogous to stride. You can change this, if you want.\n\tconst vec3 s = vec3(1, 57, 113);\n\t\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    \n    // Setting up the stride vector for randomization and interpolation, kind of. \n    // All kinds of shortcuts are taken here. Refer to IQ's original formula.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; // Cell's fractional component.\n\t\n    // A bit of cubic smoothing, to give the noise that rounded look.\n    p = p*p*(3. - 2.*p);\n    \n    // Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\n    // then interpolating along X. There are countless ways to randomize, but this is\n    // the way most are familar with: fract(sin(x)*largeNumber).\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\t\n    // Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    // Interpolating along Z, and returning the 3D noise value.\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n}\n\nfloat fbm(vec3 p, float sc){\n    \n    p *= sc;\n    return n3D(p)*.57 + n3D(p*2.)*.28 + n3D(p*4.)*.15;\n    \n}\n\n// vec2 to float hash formula.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(111.71, 157.93)))*43758.5453); }\n\n// IQ's 2D unsigned box formula.\nfloat sBox(vec2 p, vec2 b){ return length(max(abs(p) - b, 0.)); }\n\n\n// Based on the imagery produced, this is probably self explanatory: Partition\n// space into grid cells, then randomly render lines within the cell to produce\n// a character. It's take most people ten minutes to code, but it took me much\n// longer... It always does. Sigh! :D\n\nfloat ChChars(vec2 p){\n    \n    // The distance field value. Initiate it to the maximum.\n    float d = 1.;\n    \n    // Line drawing probability threshold. If the unique ID of the line segment\n    // exceeds this amount, render it. See the define above.\n    //const float th = 1./3.;\n    \n    const float lw = .005;  // Line width -- Editable.\n    const float sp = 2./9.; // Cell spacing -- Editable.\n    // The individual line segment lengths: Exclude the cell edge spacing, then \n    // divide by 3. High school logic... that took me an embarassing amount of\n    // time, due to the fact that the 4x4 horizontal lines and 4x4 vertical lines \n    // surround a \"3x3\" grid, and not a 4x4 one. It's not the first time I've made\n    // that dumb mistake, and it won't be the last. :)\n    const float ll = (1. - sp*2.)/3.;  \n    \n    // Unique character cell ID.\n    vec2 ip = floor(p);\n    \n    // Local cell coordinates -- Edged out by the cell edge spacing.\n    p -= ip + sp;\n   \n    // Iterate through all the possible combinations of lines segments\n    // in both the horizontal and the vertical. By the way, if rounded\n    // edges weren't a requirement, this wouldn't be necessary... and\n    // there might be some clever way to do it without the loops, but\n    // nothing immediately came to mind. Either way, there's no 3D \n    // involved, so the GPU will have no trouble with this at all.\n    for(int j = 0; j<vMax; j++){\n        for(int i = 0; i<hMax; i++){          \n            \n\n            // Individual segment ID... I'm pretty sure that's right, but\n            // I'd double check, just to make sure.\n            vec2 ijp = ip*16. + vec2(i, j*4);\n\n            float rndX= hash21(ijp); // Individual horizontal line ID.\n            float rndY = hash21(ijp + .5); // Individual vertical line ID.\n\n            // The line segment starting position. As we iterate throught the loop,\n            // advance by the line length.\n            vec2 q = p - vec2(i, j)*ll;\n\n            // Draw the horizontal lines to the right of the first column.\n            if(rndX>th && i>0){\n               d = min(d, sBox(q + vec2(ll/2., 0), vec2(ll/2. + lw, lw)));\n            }\n\n            // Draw the vertical lines above the last row.\n            if(rndY>th && j>0){\n                d = min(d, sBox(q + vec2(0, ll/2.), vec2(lw, ll/2. + lw)));\n            }  \n\n        }\n    }\n    \n    // Return the 2D distance field.\n    return d;\n    \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n     \n    // Centered, scaled, aspect correct screen coordinates: Fabrice and I were lightly \n    // discussing this the other day. As Fabrice pointed out, the \"fragCoord\" term is \n    // already in aspect correct form, so you only need center it then scale (with an \n    // aspect preserving scalar or vector) to get it into the form you want. \n    //\n    // Introducing an unnecessary stretching\\squashing step then correcting it doesn't make\n    // a lot of sense. In mathematical terms, both sides of the following do the same thing, \n    // but the right hand side is kind of absurd, unless obfuscation is the objective: :)\n    //\n    // (p - q)/s.y = vec2((p.x - q.x)*s.x/s.y, p.y - q.y)/s;\n    //\n    // Just for the record, it doesn't phase me how it's done, but more code than the\n    // following hurts Fabrice's eyes. :D\n    //\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    \n    // Scaling and movement.\n    vec2 p = uv*5. + vec2(0, .5) + vec2(.5, 0)*iTime;\n    \n    // UV distortion to give the stokes a hand drawn vibe. Obviously, a lot more effort \n    // could be put into this, but it's just a basic example. I might work on this later, \n    // to get a wind swept paper look happening.\n    //p += (vec2(n3D(vec3(p/2., iTime/2. + 1.)), n3D(vec3(p/2., iTime/2. + 1.37) )) - .5)*.1;\n    p += (vec2(fbm(vec3(p, 1.), 2.5), fbm(vec3(p, 1.37), 2.5)) - .5)*.04;\n    \n    // The distance field to the grid full of pseudo characters.\n    float d = ChChars(p);\n    // The distance field for the corresponding shadow.\n    float dSh = ChChars(p - vec2(1, -.8)*.1);\n    \n    // Distance field shade value. Not to be confused with the shadow above. :)\n    float dShade = max(1. - d*16., 0.)*.04;\n    \n    // Set the background to a bland creme color, then mix in some subtle diagonal lines.\n    vec3 col = vec3(.96, .92, .88);\n    float pat = clamp(sin((p.x + p.y)*128.) + .0, 0., 1.);\n    col = mix(col, vec3(0), pat*.1);\n   \n    // Apply the distance field to the canvas. Just a mild shadow and icon outline,\n    // followed by black or red characters.\n    \n    // Set the character color to something dark.\n    vec3 charCol = vec3(.03);\n    // Using the individual character cell ID, \"floor(p),\" obtain a random number, then \n    // set the occasional character to red.\n    if(hash21(floor(p))>.9) charCol = vec3(1, .03, .01);\n\n    // Shadow (offset distance field), light character outline, and color layers.\n    col = mix(col, vec3(0), (1. - smoothstep(0., .03, dSh - .06))*.25);\n    col = mix(col, vec3(1), (1. - smoothstep(0., .02, d - .06))*.5);\n    col = mix(col, charCol + dShade, 1. - smoothstep(0., .01, d - .04));\n    \n    \n    // Just the field lines, for anyone interested.\n    //col = vec3(1)*(clamp(cos(d*6.2831*8.) + .1, 0., 1.));\n    \n    /*\n    // Show the grid border -- Kind of self explanatory, but the option's\n    // there anyway. :)\n    vec2 q = abs(fract(p) - .5);\n    d = max(q.x, q.y) - .5 + .015;\n    col = mix(col, vec3(0), smoothstep(0., .01, d + .02)*.8);\n    col = mix(col, vec3(1), smoothstep(0., .005, d));\n    */\n    \n    \n    // Apply a tiny sprinkling of noise, just to break things up a little.\n    float ns = fbm(vec3(p, 1), 64.);//n3D(vec3(p, 1)*64.)*.57 + n3D(vec3(p, 1)*128.)*.28 + n3D(vec3(p, 1)*256.)*.15;\n    col *= ns*.25 + .8;\n    \n    // Positioning a mild spot light in the opposite direction of the shadow offset to give\n    // a very subtle indication that something is causing the shadows.\n    col *= max(1.2 - length(uv - vec2(-1, .8)*.3)*.35, 0.);\n\n\n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}