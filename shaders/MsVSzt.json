{
    "Shader": {
        "info": {
            "date": "1466112194",
            "description": "... You make the path raymarching.\n\nArrow Keys or Mouse. I recommend to use mouse.\nSpace to restart\nYou have to avoid blue blocks. You are the red ball.\n\nJust training and learning.\n",
            "flags": 112,
            "hasliked": 0,
            "id": "MsVSzt",
            "likes": 12,
            "name": "RayMarcher There is no Path....",
            "published": 3,
            "tags": [
                "pgatrgameraymarchingrunnervoronoise"
            ],
            "usePreview": 1,
            "username": "jviedma",
            "viewed": 2106
        },
        "renderpass": [
            {
                "code": "// Created by Javier Viedma - jviedma/2016\n// MASTER UNIVERSITARIO EN INFORMÃTICA GRAFICA, VIDEOJUEGOS Y REALIDAD VIRTUAL. PGATR. PRÃCTICA 2.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Just learning. Very noobish.\n\n// References: https://www.reddit.com/r/twotriangles/comments/1hy5qy/tutorial_1_writing_a_simple_distance_field/\n// References: Iquillez https://www.youtube.com/watch?v=CHmneY8ry84\n// References: Iquillez https://www.shadertoy.com/view/Xds3zN\n// References: Iquillez https://iquilezles.org/articles/voronoilines\n// References: Iquillez https://www.shadertoy.com/view/MddGzf\n\n\n\n/*#############Graphic Options######################*/\n#define ANIMATE //if you have a good graphic card\n//#define BUMP //if you have an incredibly good graphic card, just training\n\nconst int \tMAX_ITER \t= 100; \t\t// 100 is a safe number to use, it won't produce too many artifacts and still be quite fast\nconst float MAX_DIST \t= 50.0;\nconst float EPSILON \t= 0.001; \t// At this distance we are close enough to the object that we have essentially hit it\n\n\nconst vec3 background = vec3(0.6,0.7,0.7);\n\n//Worley-Voronoi pattern\nconst bool \tDISTANCE \t\t= true;\nbool \t\tspecial \t\t= false;\nconst float BorderThickness = 0.1;\n/*##################################################*/\n\n\nfloat speed = 1.0;\n\n// storage register/texel addresses\nconst vec2 txPlayerPos  = vec2(0.0);\nconst vec2 txState      = vec2(1.0,0.0);\nconst vec2 txCubeActive = vec2(2.0,0.0);\nconst vec2 txypos \t\t= vec2(3.0,0.0);\nconst vec2 txSpeed \t\t= vec2(4.0,0.0);\nconst vec2 txPoints\t\t= vec2(5.0,0.0);\n\n/*##################################################*/\n/*#################Worley###########################*/\n//References: Iquillez https://iquilezles.org/articles/voronoilines\n/*##################################################*/\nvec2 Hash2(vec2 p)\n{\n\tfloat r = 523.0*sin(dot(p, vec2(53.3158, 43.6143)));\n\treturn vec2(fract(15.32354 * r), fract(17.25865 * r));\n}\n\nfloat DistanceBetweenARectAndaPoint2D(vec2 p, vec2 rp, vec2 v)\n{\n   \n    vec2 v1 = rp - p;\n    \n    vec3 cp = cross(vec3(v,0),vec3(v1,0));\n    \n    return length(cp)/length(v);\n}\n\nvoid BisectionRect2D(vec2 p1, vec2 p2, out vec2 rp, out vec2 v)\n{\n\tv = p1-p2;\n    \n    v = vec2(v.y,v.x);\n    \n    if(v.x != 0.0){v.x = -v.x;}\n    else{v.y = -v.y;}\n    \n    rp = 0.5*(p1+p2);\n}\n\nvec4 Worley(vec2 p, out float dist)\n{\n    vec2 integer = floor(p);\n\t\n    vec2 relativeSquarePoint;    \n        \n    vec2 closestpoint;\n    vec2 ndClosestPoint;\n    vec2 trdClosesPoint;\n    float MinDistance = 1000.0;\n    float NdMinDistance = 1000.0;\n\tfloat TrdMinDistance = 1000.0;\n    \n    float linedistance =10000.0;\n    \n    for(int i = -1; i <= 1; i++)\n    {\n    \tfor(int j = -1; j <= 1; j++)\n        {\n            vec2 relativeSquarePoint1 = integer + vec2(i,j);\n\t\t\tvec2 offset = Hash2(relativeSquarePoint1);\n            #ifdef ANIMATE\n        \toffset.x = 0.5 + 0.5*cos( iTime + 6.2831*offset.x );\n            offset.y = 0.5 + 0.5*sin( iTime + 6.2831*offset.y );\n        \t#endif\t\n           \tvec2 squarepoint = relativeSquarePoint1 +offset;\n            \n            float CurrentDistance = distance(squarepoint, p);\n            \n            \n            if(MinDistance > CurrentDistance)\n            {    \n            \tMinDistance = CurrentDistance;\n                closestpoint = squarepoint;\n                relativeSquarePoint = relativeSquarePoint1;\n            }\n        }\n    }\n    \n    \n    vec2 CurrentDecimal = fract(closestpoint);\n    vec2 CurrentInteger = floor(closestpoint);\n    \n    vec2 spc1 = closestpoint - p;\n   \tif(DISTANCE)\n    {\n        for(int i=-2; i<=2; i++)\n        {\n            for(int j =-2;j<=2;j++)\n            {\n                vec2 relativeSquarePoint2 = relativeSquarePoint+vec2(i,j);\n                vec2 offset = Hash2(relativeSquarePoint2);\n                #ifdef ANIMATE\n                offset.x = 0.5 + 0.5*cos( iTime + 6.2831*offset.x );\n                offset.y = 0.5 + 0.5*sin( iTime + 6.2831*offset.y );\n                #endif\t\n                vec2 SquarePoint2 = relativeSquarePoint2 +offset;\n                float CurrentDistance = distance(SquarePoint2, p);\n\n                vec2 spc2 = SquarePoint2 -p;      \t\n\n                if( !(i==0 && j==0 ))\n                {\t//La distamcia mÃ­nima no es solo con la bisectriz con el segundo punto mÃ¡s cercano\n                    //Sino con muchos otros puntos, por eso el cÃ¡lculo de la distancia debe venir aquÃ­\n                \tvec2 v1;\n                  \tvec2 rp1;\n                  \tBisectionRect2D(closestpoint, SquarePoint2, rp1, v1);\n                  \tlinedistance = min(linedistance,DistanceBetweenARectAndaPoint2D(p,rp1 ,v1));\n                }\n            }\n        }\n    }\n\n   \tdist = linedistance;\n    linedistance = smoothstep(0.00,BorderThickness,linedistance);\n    \n       \n    return vec4(MinDistance,linedistance,relativeSquarePoint.x,relativeSquarePoint.y);\n}\nconst vec3 red = vec3(1.0,0.0,0.0);\nconst vec3 black = vec3(0.0,0.0,0.0);\nconst vec3 white = vec3(1.0,1.0,1.0);\nconst vec3 yellow = vec3(1.0,1.0,0.0);\nconst vec3 blue = vec3(0.0,0.0,1.0);\nconst vec3 green = vec3(0.0,1.0,0.0);\nconst vec3 purple = vec3(1.0,0.0,1.0);\nconst vec3 orange = vec3(1.0,5.0,0.0);\n\nvec3 SelectColor(float i, float j)\n{\n    float a = mod((i * i + i +j), 6.0);\n    if(a==0.0){return red;}\n    if(a==1.0){return yellow;}\n    if(a==2.0){return green;}\n    if(a==3.0){return blue;}\n    if(a==4.0){return orange;}\n    return purple;\n}\n/*##################################################*/\n/*#################SHAPES###########################*/\n//References: Iquillez https://www.shadertoy.com/view/Xds3zN\n/*##################################################*/\nvec3 PlayerPosition = vec3(0.0);\n\n\nfloat player(vec3 pos, float radius, inout vec3 col)\n{\n    col =vec3(1.0,0.0,0.0);\n    return length(pos+PlayerPosition) - radius;\n}\n\nfloat Floor( vec3 pos, inout vec3 col)\n{\n    float dd;\n    \n    vec4 d = Worley(2.*vec2(pos.x,pos.z-(iTime*speed)),dd);\n     \n    col = 0.4 + 0.1*vec3(1.0);\n    \n    if(special)\n    {\n        col = SelectColor(floor(d[2]+1.0*sin(iTime + 6.2)),floor(d[3]+1.0*cos(iTime)));\n        col = mix( col, col*0.5, smoothstep( 0.01, 1.0, 0.5*sin(32.0*d.x-pos.y)*cos(32.0*(d.x-pos.y)) ) );\n        col = mix( col, white, smoothstep( 0.1, 1.0, 0.6*sin(32.0*d.x-pos.y+10.0)*cos(32.0*(d.x-pos.y+10.0)) ) );    \n    }\n\n    col = mix( col, col*0.2, 1.0 - smoothstep( 0.01, 0.5, dd ) );\n    col = mix( col, vec3(0.0), (1.0 - smoothstep( 0.999, 1.0, d.y )));\n    \n    \n    \n    #ifdef BUMP\n\treturn pos.y +0.0+col.z*0.07;\n    #endif\n    \n    return pos.y;\n}\nfloat WallR( vec3 pos, float offset, inout vec3 col)\n{\n    float dd;\n    \n    vec4 d = Worley(2.*vec2(pos.y,pos.z-(iTime*speed)),dd);\n     \n    col = 0.4 + 0.4*vec3(1.0);\n\n    if(special)\n    {\n        col = SelectColor(floor(d[2]+1.0*sin(iTime + 6.2)),floor(d[3]+1.0*cos(iTime)));\n        col = mix( col, col*0.5, smoothstep( 0.01, 1.0, 0.5*sin(32.0*d.x-pos.y)*cos(32.0*(d.x-pos.y)) ) );\n        col = mix( col, white, smoothstep( 0.1, 1.0, 0.6*sin(32.0*d.x-pos.y+10.0)*cos(32.0*(d.x-pos.y+10.0)) ) );    \n    }\n    \n    col = mix( col, col*0.2, 1.0 - smoothstep( 0.01, 0.5, dd ) );\n    col = mix( col, vec3(0.0), (1.0 - smoothstep( 0.999, 1.0, d.y )));\n\n    #ifdef BUMP\n\treturn  pos.x +offset + 0.4*cos(pos.z-(iTime*speed)) +0.4*sin(atan(pos.y*4.)*pos.y)+col.z*0.2;\n    #endif\n    \n\treturn pos.x +offset + 0.4*cos(pos.z-(iTime*speed)) +0.4*sin(atan(pos.y*4.)*pos.y);\n}\nfloat WallL( vec3 pos, float offset, inout vec3 col)\n{\n    \n    float dd;\n    \n    vec4 d = Worley(2.*vec2(pos.y,pos.z-(iTime*speed)),dd);\n     \n    col = 0.4 + 0.1*vec3(1.0);\n\t\n    if(special)\n    {\n        col = SelectColor(floor(d[2]+1.0*sin(iTime + 6.2)),floor(d[3]+1.0*cos(iTime)));\n        col = mix( col, col*0.5, smoothstep( 0.01, 1.0, 0.5*sin(32.0*d.x-pos.y)*cos(32.0*(d.x-pos.y)) ) );\n        col = mix( col, white, smoothstep( 0.1, 1.0, 0.6*sin(32.0*d.x-pos.y+10.0)*cos(32.0*(d.x-pos.y+10.0)) ) );    \n    }\n    \n    col = mix( col, col*0.2, 1.0 - smoothstep( 0.01, 0.5, dd ) );\n    col = mix( col, vec3(0.0), (1.0 - smoothstep( 0.999, 1.0, d.y )));\n    \n    #ifdef BUMP\n\treturn  - pos.x +offset + 0.4*cos(pos.z-(iTime*speed)) +0.4*sin(atan(pos.y*4.)*pos.y)-col.z*0.2;\n    #endif\n    \n\treturn - pos.x +offset + 0.4*cos(pos.z-(iTime*speed)) +0.4*sin(atan(pos.y*4.)*pos.y);\n}\nfloat box(vec3 pos, vec3 size)\n{\n    \n    return length(min(abs(pos) - size, 0.0));\n}\n\nvec3 blockposition1 = vec3(7.0,0.0,50.0);\nvec3 blockposition2 = vec3(3.5,0.0,50.0);\nvec3 blockposition3 = vec3(0.0,0.0,50.0);\nvec3 blockposition4 = vec3(-3.5,0.0,50.0);\nvec3 blockposition5 = vec3(-7.0,0.0,50.0);\n\nfloat udRoundBox( vec3 p, vec3 b, float r,inout vec3 col)\n{\n    col =vec3(0.4,0.4,0.8);\n  \treturn length(max(abs(p)-b,0.0))-r;\n}\n/*##################################################*/\n/*################RAYMARCHER########################*/\n// References: https://www.reddit.com/r/twotriangles/comments/1hy5qy/tutorial_1_writing_a_simple_distance_field/\n// References: Iquillez https://www.youtube.com/watch?v=CHmneY8ry84\n// References: Iquillez https://www.shadertoy.com/view/Xds3zN\n/*##################################################*/\n\nvec4 distfunc(vec3 pos)\n{\n    vec3 col1;\n    vec2 d1 = vec2(player(pos, 0.4,col1),1.0);\n    vec3 col2;\n    vec2 d2 = vec2(Floor(pos,col2), 1.0);\n    vec3 col3;\n    vec2 d3 = vec2(WallR(pos, 10.0,col3),1.0);\n    vec3 col4;\n    vec2 d4 = vec2(WallL(pos, 10.0,col4),1.0);\n    vec3 col5;\n   \tvec2 dd1 = vec2( udRoundBox(  pos+blockposition1, vec3(1.),1.0 ,col5 ),1.0);\n    vec3 col6;\n   \tvec2 dd2 = vec2( udRoundBox(  pos+blockposition2, vec3(1.),1.0 ,col6 ),1.0);\n    vec3 col7;\n   \tvec2 dd3 = vec2( udRoundBox(  pos+blockposition3, vec3(1.),1.0 ,col7 ),1.0);\n    vec3 col8;\n   \tvec2 dd4 = vec2( udRoundBox(  pos+blockposition4, vec3(1.),1.0 ,col8 ),1.0);\n    vec3 col9;\n   \tvec2 dd5 = vec2( udRoundBox(  pos+blockposition5, vec3(1.),1.0 ,col9 ),1.0);\n    \n    \n    vec3 col = col1;\n    float minimun = d1.x;\n\t\n    if(d2.x<minimun)\n    {\n        minimun = d2.x;\n        col = col2;\n    }\n    if(d3.x<minimun)\n    {\n        minimun = d3.x;\n        col = col3;\n    }\n    if(d4.x<minimun)\n    {\n        minimun = d4.x;\n        col = col4;\n    }\n    if(dd1.x<minimun)\n    {\n        minimun = dd1.x;\n        col = col5;\n    }\n    if(dd2.x<minimun)\n    {\n        minimun = dd2.x;\n        col = col6;\n    }\n    if(dd3.x<minimun)\n    {\n        minimun = dd3.x;\n        col = col7;\n    }\n    if(dd4.x<minimun)\n    {\n        minimun = dd4.x;\n        col = col8;\n    }\n    if(dd5.x<minimun)\n    {\n        minimun = dd5.x;\n        col = col9;\n    }\n    \n    return vec4(minimun,col);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 eps = vec2(0.0, EPSILON);\n    vec3 normal = normalize(vec3(\n        distfunc(pos + eps.yxx).x - distfunc(pos - eps.yxx).x,\n        distfunc(pos + eps.xyx).x - distfunc(pos - eps.xyx).x,\n        distfunc(pos + eps.xxy).x - distfunc(pos - eps.xxy).x));\n    return normal;\n}\n\nfloat softshadow( in vec3 rayOrigin, in vec3 rayDirection, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    \n    for (int i = 0; i < MAX_ITER; i++)\n    {\n        float h = distfunc( rayOrigin + rayDirection*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    \n    return clamp( res, 0.0, 1.0 );\n}\n\nvoid lighting(inout vec3 col, vec3 pos, float distanc, vec3 rayDir, vec3 normal)\n{\n    vec3 light = normalize(vec3(1.0*cos(iTime*6.0),0.8,0.3));\n    \n    if (distanc < EPSILON)\n    {       \n        vec3 ObjMaterial = vec3(distfunc(pos).y,distfunc(pos).z,distfunc(pos).a);\n        \n        vec3 reflection = reflect( rayDir, normal );\n        float ambient = (0.5 + 0.5*normal.y)*0.3 ;\n        float diffuse = max(0.0, dot(normal,light));\n        float specular = pow(clamp( dot( reflection, light ), 0.0, 1.0 ),16.0);\n        float shadow = softshadow( pos, light, 0.02, 2.5 );\n        \n        //--------------------------------------------------------------------\n        float back = clamp( dot( normal, normalize(vec3(-light.x,0.0,-light.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dome = smoothstep( -0.1, 0.1, reflection.y );\n        float fre = pow( clamp(1.0+dot(normal,rayDir),0.0,1.0), 2.0 );\n\t\t//--------------------------------------------------------------------\n        \n        vec3 ilum = vec3(0.0);\n        ilum += 1.20*diffuse*vec3(1.00,0.85,0.55)*shadow*ObjMaterial;\n\t\tilum += 1.20*specular*vec3(1.00,0.85,0.55)*diffuse;\n        ilum += 0.20*ambient*vec3(0.50,0.70,1.00);\n        ilum += 0.15*dome*vec3(0.50,0.70,1.00)*softshadow( pos, reflection, 0.02, 2.5 );\n        ilum += 0.30*back*vec3(0.25,0.25,0.25);\n        ilum += 0.40*fre*vec3(1.00,1.00,1.00);\n        \n\n\t\tcol =ilum;\n    }\n    \n    \n}\n\nvoid rayCast(inout float dist, inout vec3 pos, in vec3 rayDir )\n{\n    float totalDist = 0.0;\n    \n    for (int i = 0; i < MAX_ITER; i++)\n    {\n    \t// Either we've hit the object or hit nothing at all, either way we should break out of the loop\n        if (dist < EPSILON || totalDist > MAX_DIST)\n            break; // If you use windows and the shader isn't working properly, change this to continue;\n\n        dist = distfunc(pos).x; // Evalulate the distance at the current point\n        totalDist += dist;\n        pos += dist * rayDir; // Advance the point forwards in the ray direction by the distance\n    }\n}\n\nvoid render(inout vec3 col, in vec3 rayDir, in vec3 cameraOrigin)\n{   \n    float dist = EPSILON;\n   \tvec3 pos = cameraOrigin;\n    \n    rayCast(dist, pos, rayDir);\n    lighting(col ,pos, dist,rayDir,calcNormal(pos));\n}\n\nmat3 setCamera( in vec3 cameraOrigin, in vec3 cameraTarget, in vec3 upDirection )\n{\n\tvec3 cameraDir  = normalize(cameraTarget-cameraOrigin); //Camera direction\n\tvec3 cameraRight = normalize(cross(upDirection, cameraOrigin));\n\tvec3 cameraUp = cross(cameraDir, cameraRight);\n    \n    return mat3( cameraRight, cameraUp , cameraDir );\n}\n\nvec4 RayMarcher(in vec2 fragCoord)\n{\n    vec2 p = -1.0 + 2.0 * gl_FragCoord.xy / iResolution.xy; // screenPos can range from -1 to 1\n\tp.x *= iResolution.x / iResolution.y; // Correct aspect ratio\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n    //BackGround\n    vec3 col = background;\n    \n    \n\t// camera\t\n\tvec3 cameraOrigin \t= vec3( 0.0+mo.x*0.5, 4.0+mo.y, 4.0 ); //camera origin\n\tvec3 cameraTarget \t= vec3( 0.0, 0.0, 0.0 ); //Camera target\n    vec3 upDirection \t= vec3(\t0.0, -1.0, 0.0 );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera(cameraOrigin, cameraTarget, upDirection );\n    \n    vec3 rayDir = normalize(ca[0] * p.x + ca[1] * p.y +ca[2]);\n    \n    render(col, rayDir, cameraOrigin);\n    \n    return vec4( col, 1.0 );\n    \n}\n/*##################################################*/\n/*################BITWISE######################*/\nfloat SampleDigit(const in float n, const in vec2 vUV)\n{\n    if( abs(vUV.x-0.5)>0.5 || abs(vUV.y-0.5)>0.5 ) return 0.0;\n\n    // digit data by P_Malin (https://www.shadertoy.com/view/4sf3RN)\n    float data = 0.0;\n         if(n < 0.5) data = 7.0 + 5.0*16.0 + 5.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    else if(n < 1.5) data = 2.0 + 2.0*16.0 + 2.0*256.0 + 2.0*4096.0 + 2.0*65536.0;\n    else if(n < 2.5) data = 7.0 + 1.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 3.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 4.5) data = 4.0 + 7.0*16.0 + 5.0*256.0 + 1.0*4096.0 + 1.0*65536.0;\n    else if(n < 5.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n    else if(n < 6.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n    else if(n < 7.5) data = 4.0 + 4.0*16.0 + 4.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 8.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    else if(n < 9.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    \n    vec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n    float fIndex = vPixel.x + (vPixel.y * 4.0);\n    \n    return mod(floor(data / pow(2.0, fIndex)), 2.0);\n}\n\nfloat PrintInt( in vec2 uv, in float value )\n{\n    float res = 0.0;\n    float maxDigits = 1.0+ceil(.01+log2(value)/log2(10.0));\n    float digitID = floor(uv.x);\n    if( digitID>0.0 && digitID<maxDigits )\n    {\n        float digitVa = mod( floor( value/pow(10.0,maxDigits-1.0-digitID) ), 10.0 );\n        res = SampleDigit( digitVa, vec2(fract(uv.x), uv.y) );\n    }\n\n    return res;\n}\n\n//=================================================================================================\n\n\n\nint Mask(int x, int y) {\n   \n    int rest = y;\n    \n    for(int i=0;i<5;i++)\n    {\n    \tif(pow(2.0,float(4-i))<=float(rest))\n        {\n            if(4-i==x)\n            {\n                return 1;\n            }\n            \n            rest = rest - int(pow(2.0,float(4-i)));\n            \n            if(rest==0)\n            {\n             \treturn 0;  \n            }\n        }\n    }\n    \n    return 0;\n    \n}\n/*##################################################*/\n/*##################################################*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //------------------------\n    // load game state\n    //------------------------\n    \n    vec4 PlayerPos \t= texture( iChannel0, (txPlayerPos+0.5)/iChannelResolution[0].xy );\n    float state    \t= texture( iChannel0, (txState+0.5)/iChannelResolution[0].xy ).x;\n    float zpos    \t= texture( iChannel0, (txypos+0.5)/iChannelResolution[0].xy ).x;\n    int CubeActive  = int(texture( iChannel0, (txCubeActive+0.5)/iChannelResolution[0].xy ).x);\n    float Speed    \t= texture( iChannel0, (txSpeed+0.5)/iChannelResolution[0].xy ).x;\n    float Points    = texture( iChannel0, (txPoints+0.5)/iChannelResolution[0].xy ).x;\n    \n    speed = speed + Speed*20.0;\n    \n    if(Mask(0,CubeActive)==1)blockposition1.z = zpos;\n \tif(Mask(1,CubeActive)==1)blockposition2.z = zpos;\n \tif(Mask(2,CubeActive)==1)blockposition3.z = zpos;\n \tif(Mask(3,CubeActive)==1)blockposition4.z = zpos;\n \tif(Mask(4,CubeActive)==1)blockposition5.z = zpos;\n    \n    PlayerPosition = PlayerPos.xyz;\n    \n    vec4 col = RayMarcher(fragCoord);\n    \n    vec2 uv = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    float f = PrintInt( (uv-vec2(-1.5,0.8))*10.0, Points );\n    col = mix( col, vec4(1.0,1.0,1.0,1.0), f );\n    \n    \n    col = mix( col, vec4(1.0,0.5,0.2,1.0), state *(0.5+0.5*sin(30.0*iTime)));\n    fragColor=col;\n}\n\n\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 3666,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/loob-label/1-whitelie-sinkin-llb037"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\n// storage register/texel addresses\nconst vec2 txPlayerPos  = vec2(0.0);\nconst vec2 txState      = vec2(1.0,0.0);\nconst vec2 txCubeActive = vec2(2.0,0.0);\nconst vec2 txypos \t\t= vec2(3.0,0.0);\nconst vec2 txSpeed \t\t= vec2(4.0,0.0);\nconst vec2 txPoints\t\t= vec2(5.0,0.0);\n\n\nconst float inputSpeed = 3.0;\nconst float KEY_SPACE = 32.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\n\n\n//----------------------------------------------------------------------------------------------\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nfloat isInside( vec2 p, vec4 c ) { vec2 d = abs(p-0.5-c.xy-c.zw*0.5) - 0.5*c.zw - 0.5; return -max(d.x,d.y); }\n\nvec4 loadValue( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\nvoid storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\nvoid storeValue( in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\n//----------------------------------------------------------------------------------------------\nbool ballboxIntersection(vec2 circle, vec2 rect, float rectwidth, float rectheight, float circler)\n{\n   float circleDistanceX = abs(circle.x - rect.x - rectwidth/2.0);\n   float circleDistanceY = abs(circle.y - rect.y - rectheight/2.0);\n \n   if (circleDistanceX > (rectwidth/2.0 + circler)) { return false; }\n   if (circleDistanceY > (rectheight/2.0 + circler)) { return false; }\n \n   if (circleDistanceX <= (rectwidth/2.0)) { return true; }\n   if (circleDistanceY <= (rectheight/2.0)) { return true; }\n \n   float cornerDistance_sq = pow(circleDistanceX - rectwidth/2.0, 2.0) + pow(circleDistanceY - rectheight/2.0, 2.0);\n \n   return (cornerDistance_sq <= (pow(circler, 2.0)));\n}\nint Mask(int x, int y) {\n   \n    int rest = y;\n    \n    for(int i=0;i<5;i++)\n    {\n    \tif(pow(2.0,float(4-i))<=float(rest))\n        {\n            if(4-i==x)\n            {\n                return 1;\n            }\n            \n            rest = rest - int(pow(2.0,float(4-i)));\n            \n            if(rest==0)\n            {\n             \treturn 0;  \n            }\n        }\n    }\n    \n    return 0;\n    \n}\n\nfloat blockposition1 = 6.0;\nfloat blockposition2 = 2.0;\nfloat blockposition3 = -2.0;\nfloat blockposition4 = -6.0;\nfloat blockposition5 = -10.0;\n\nfloat rectwidth=4.0;\nfloat rectheight=2.0;\nfloat radius=0.4;\n\nbool crash(vec2 playerPosition, float ypos, int CubeActive)\n{\n    if(Mask(0,CubeActive)==1)\n    {\n        if(ballboxIntersection(playerPosition,vec2(blockposition1,ypos),rectwidth,rectheight,radius))\n        {\n        \treturn true;  \n        }\n    }\n \tif(Mask(1,CubeActive)==1)\n    {\n        if(ballboxIntersection(playerPosition,vec2(blockposition2,ypos),rectwidth,rectheight,radius))\n        {\n        \treturn true;  \n        }\n    }\n \tif(Mask(2,CubeActive)==1)\n    {\n        if(ballboxIntersection(playerPosition,vec2(blockposition3,ypos),rectwidth,rectheight,radius))\n        {\n        \treturn true;  \n        }\n    }\n    if(Mask(3,CubeActive)==1)\n    {\n        if(ballboxIntersection(playerPosition,vec2(blockposition4,ypos),rectwidth,rectheight,radius))\n        {\n        \treturn true;  \n        }\n    }\n \tif(Mask(4,CubeActive)==1)\n    {\n        if(ballboxIntersection(playerPosition,vec2(blockposition5,ypos),rectwidth,rectheight,radius))\n        {\n        \treturn true;  \n        }\n    }\n    return false;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n    \n    vec4  playerPosition \t= loadValue( txPlayerPos );\n    float state     \t\t= loadValue( txState ).x;\n    float ypos \t\t\t\t= loadValue( txypos ).x;\n    int  CubeActive \t\t= int(loadValue( txCubeActive ).x);\n    float speed \t\t\t= loadValue( txSpeed ).x;\n    float points\t\t\t= loadValue( txPoints ).x;\n    \n    //---------------------------------------------------------------------------------\n    // reset\n\t//---------------------------------------------------------------------------------\n\tif( iFrame==0 ) state = -1.0;\n\t\n    if( state < -0.5 )\n    {\n        state = 0.0;\n        playerPosition = vec4(0.0,-0.5,-0.8,0.0);\n        ypos = 50.0;\n        speed = 0.4;\n        CubeActive = 1;\n       \n    }\n    \n    // if game mode (not game over), play game\n    else if( state < 0.5 ) \n\t{\n        //-------------------\n        // Player\n        //-------------------\n        vec4 oldPlayerPos = playerPosition;\n        \n        if( iMouse.w>0.01 )\n        {\n            // move with mouse\n            playerPosition.x = 5.0*(-1.0 + 2.0*iMouse.x/iResolution.x)*iResolution.x/iResolution.y;\n        }\n        \n        // move with keyboard\n        float moveRight = texture( iChannel1, vec2(KEY_RIGHT,0.25) ).x;\n        float moveLeft  = texture( iChannel1, vec2(KEY_LEFT,0.25) ).x;\n        playerPosition.x += 0.3*inputSpeed*(moveRight - moveLeft);\n        playerPosition.x = clamp( playerPosition.x, -10.0, 10.0 );\n        \n        float moveUp = texture( iChannel1, vec2(KEY_UP,0.25) ).z;\n        float moveDown  = texture( iChannel1, vec2(KEY_DOWN,0.25)).z;\n        playerPosition.z += 0.3*inputSpeed*(moveUp - moveDown);\n        playerPosition.z = clamp( playerPosition.z, -2.0, 4.0 );\n        \n        ypos-=speed;\n        speed=clamp( speed, speed+0.0001, 1.9 );\n        if(crash(playerPosition.xz,ypos,CubeActive))\n        {\n        \tstate = 1.0; \n        }\n        if(ypos <= -4.0)\n        {\n            if(CubeActive!=0){points+=1.0;}\n            ypos = 40.0;\n            CubeActive = int(mod(iTime*20.0+iTime*sin(iTime*4.0),31.0));\n        }\n\t\t\n    }\n    else if( state > 0.5 )   \n    {\n        speed = 0.0;\n        //GameOver\n        float pressSpace = texture( iChannel1, vec2(KEY_SPACE,0.25) ).x;\n        \n        if( pressSpace>0.5 )\n        {\n            speed = 0.4;\n            state = -1.0;\n            points = 0.0;\n        } \n    }\n\n    \n    fragColor = vec4(0.0);\n \n    storeValue( txPlayerPos, vec4(playerPosition),        fragColor, fragCoord );\n    storeValue( txState,  \t vec4(state,0.0,0.0,0.0), \t  fragColor, fragCoord );\n    storeValue( txypos,\t\t vec4(ypos,0.0,0.0,0.0), \t  fragColor, fragCoord );\n    storeValue( txCubeActive,vec4(CubeActive,0.0,0.0,0.0),fragColor, fragCoord );\n\tstoreValue( txSpeed,\t vec4(speed,0.0,0.0,0.0), \t  fragColor, fragCoord );\n    storeValue( txSpeed,\t vec4(speed,0.0,0.0,0.0), \t  fragColor, fragCoord );\n    storeValue( txPoints,\t vec4(points,0.0,0.0,0.0), \t  fragColor, fragCoord );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}