{
    "Shader": {
        "info": {
            "date": "1624032012",
            "description": "Rendering repeat line sequences within triangle cells to create a synchronized line animation.",
            "flags": 0,
            "hasliked": 0,
            "id": "flj3Wm",
            "likes": 50,
            "name": "Synchronized Line Animation",
            "published": 3,
            "tags": [
                "triangle",
                "line",
                "hexagon",
                "geometry"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 701
        },
        "renderpass": [
            {
                "code": "/*\n\n\tSynchronized Line Animation\n\t---------------------------    \n    \n    Rendering repeat line sequences within triangle cells to create a synchronized \n    line animation.\n    \n    This particular sequence is a rough recreation of an animation that I've seen \n    in various reincarnations before. I'm pretty sure the original was conceived by \n    a visual artist known as Admiral Potato, who has an awesome body of work... and \n    a Shadertoy account, from what I can see. The link to his work is below.\n    \n    It's based on a very simple idea: Partition space into some kind of grid, then\n    use the vertex, midpoint, etc, geometry to render node based line animations. \n    I've done similar things before with a simple square grid, but hadn't tried it \n    with a more interesting tiling arrangement.\n    \n    Aesthetically, I adhered to the spirit of the original, but rendered it in a way\n    that was more condusive to realtime constraints. Anyway, this was just a simple\n    but rushed geometric animation example, so don't worry about the code itself too \n    much. It was a spur of the moment thing, which meant it was hacked together with \n    old routines of mine and without a lot of forethought. Hopefully, Admiral Potato \n    himself will one day convert his original to pixel shader form and post it on \n    Shadertoy. \n\n\n\n    Reference link:\n    \n    // Admiral Potato's Tumblr page. If you're interested in graphics, then \n    // you've probably seen versions of his work floating around the net.\n    http://admiralpotato.tumblr.com/\n    \n    // The link to the original animation.\n    Hex Doctor - Admiral Potato\n    http://nuclearpixel.com/motion/hex-doctor/\n    \n \n\n*/\n\n\n// Color palette: Pink\\Green: 0, Copper\\Gold: 1, Silver: 2\n#define PALETTE 0\n\n// Display the triangle cell borders.\n//#define SHOW_CELLS\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n\n// IQ's signed distance to a 2D triangle.\nfloat sdTri(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2){\n \n    vec2 e0 = p1 - p0, e1 = p2 - p1, e2 = p0 - p2;\n\n\tvec2 v0 = p - p0, v1 = p - p1, v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0, e0)/dot(e0, e0), 0., 1.);\n\tvec2 pq1 = v1 - e1*clamp( dot(v1, e1)/dot(e1, e1), 0., 1.);\n\tvec2 pq2 = v2 - e2*clamp( dot(v2, e2)/dot(e2, e2), 0., 1.);\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x);\n    vec2 d = min( min( vec2(dot(pq0, pq0), s*(v0.x*e0.y - v0.y*e0.x)),\n                       vec2(dot(pq1, pq1), s*(v1.x*e1.y - v1.y*e1.x))),\n                       vec2(dot(pq2, pq2), s*(v2.x*e2.y - v2.y*e2.x)));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n\n// Triangle's incenter and radius.\nvec3 inCentRad(vec2 p0, vec2 p1, vec2 p2){\n    \n    // Side lengths.\n    float bc = length(p1 - p2), ac = length(p0 - p2), ab = length(p0 - p1);\n    vec2 inCir = (bc*p0 + ac*p1 + ab*p2)/(bc + ac + ab);   \n    \n    // Area.\n    float p = (bc + ac + ab)/2.;\n    float area = sqrt(p*(p - bc)*(p - ac)*(p - ab));\n    \n    return vec3(inCir, area/p);\n}\n\n// IQ's line distace formula. \nfloat sdLine(in vec2 p, in vec2 a, in vec2 b){\n\n\tp -= a, b -= a;\n\treturn length(p - b*clamp(dot(p, b)/dot(b, b), 0., 1.));\n}\n\n\n\n// Skewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 skewXY(vec2 p, vec2 s){\n    \n    return mat2(1, -s.y, -s.x, 1)*p;\n}\n\n// Unskewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 unskewXY(vec2 p, vec2 s){\n    \n    //float idm = 1. - s.x*s.y;\n    //if(idm == 0.) idm += 1e-6;\n    //mat2 inM = 1./(idm)*mat2(1, s.y, s.x, 1);\n    //return inM*p;\n    return inverse(mat2(1, -s.y, -s.x, 1))*p;\n}\n\n/*\n// Exponential easing function.\nfloat exponentialOut(float t) {\n  return t == 1. ? t : 1. - pow(2., -8.*t);\n}\n\n// Quad easing function. \nfloat easeOutQuad(float t) {\n    return -t*(t - 2.);\n}\n*/ \n\n// Global distance values for the two colored lines and end points.\n// This was hacked in at the last minutes... I'll incorporate it\n// into the structure below at some stage.\nfloat line = 1e5;\nfloat line2 = 1e5;\nfloat circle = 1e5;\nfloat circle2 = 1e5;\n \n\n// Global vertices, local coordinates, etc, of the triangle cell.\nstruct triS{\n    \n    vec2[3] v; // Outer vertices.\n    vec2 p; // Local coordinate.\n    vec2 id; // Position based ID.\n    float dist; // Distance field value.\n    float triID; // Triangle ID.\n};\n\n// A regular extruded block grid.\n//\n// The idea is very simple: Produce a normal grid full of packed square pylons.\n// That is, use the grid cell's center pixel to obtain a height value (read in\n// from a height map), then render a pylon at that height.\n\ntriS blocks(vec2 q){\n    \n\n    const float tf = 2./sqrt(3.);\n    // Scale.\n\tconst vec2 scale = vec2(tf, 1)*vec2(1./2.);\n\n    // Brick dimension: Length to height ratio with additional scaling.\n\tconst vec2 dim = vec2(scale);\n    // A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = dim*2.;\n    \n     // Skewing half way along X, and not skewing in the Y direction.\n    const vec2 sk = vec2(tf/2., 0);\n    \n    // Distance.\n    float d = 1e5;\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    // Individual block ID and block center.\n    vec2 idi, cntr;\n    \n    // Four block corner postions.\n    const vec2[4] ps4 = vec2[4](vec2(-.5, .5), vec2(.5), vec2(.5, -.5), vec2(-.5)); \n    \n    // Unskewed block corner postions.\n    vec2[4] vert = vec2[4](vec2(-.5, .5), vec2(.5), vec2(.5, -.5), vec2(-.5)); \n    // Unskewing to enable rendering back in normal space.\n    vert[0] = unskewXY(vert[0]*dim, sk);\n    vert[1] = unskewXY(vert[1]*dim, sk);\n    vert[2] = unskewXY(vert[2]*dim, sk);\n    vert[3] = unskewXY(vert[3]*dim, sk); \n    \n    // Skewed local coordinates.\n    vec2 skqxy = skewXY(q.xy, sk);\n    \n    \n    float triID = 0.; // Triangle ID. Not used in this example, but helpful.\n \n    // Initializing the global vertices and local coordinates of the triangle cell.\n    triS gT, tri1, tri2;\n    \n    // Initialize the various distance field values to a maximum.\n    line = 1e5;\n    line2 = 1e5;\n    circle = 1e5;\n    circle2 = 1e5;\n    \n\n    // End point width and line width values.\n    const float cw = .02;\n    const float lw = .007;\n    \n    // Fractional time for the four nodes. \n    const int ttm = 4;\n    float tm = 2. - iTime;\n    float modtm = mod(tm, float(ttm));\n    int index = int(modtm);\n    // Another animation thread.\n    float tm2 = iTime;\n    float modtm2 = mod(tm2, float(ttm));\n    int index2 = int(modtm2);\n \n\n    // Iterate through four neighboring grid squares -- Each square is skewed\n    // and subdivided diagonally to determine the nearest triangle. Yeah, it's\n    // annoying work, but the lines are rendered outside the confines of each\n    // triangle cell, which means neighboring cells need to be accounted for.\n    for(int i = min(0, iFrame); i<4; i++){    \n        \n        // Block center.\n        cntr = ps4[i]/2.;\n\n        // Skewed local coordinates.\n        p = skqxy;\n        //ip = floor(p/s - cntr) + .5 + cntr; // Local tile ID.\n        // Correct positional individual tile ID.\n        idi = (floor(p/s - cntr) + .5 + cntr)*s;\n        p -= idi; // New local position.\n        // Unskew the local coordinates.\n        p = unskewXY(p, sk);       \n         \n        // Unskewing the rectangular cell ID.\n\t\tidi = unskewXY(idi, sk);  \n\n        \n        // Partioning the rectangle into two triangles.\n        for(int triJ = min(0, iFrame); triJ<2; triJ++){\n        \n            // Vertices for triangle one or two.\n            if(triJ==0) tri1.v = vec2[3](vert[0], vert[1], vert[2]); \n            else tri1.v = vec2[3](vert[0], vert[2], vert[3]);\n            \n            tri1.id = idi + inCentRad(tri1.v[0], tri1.v[1], tri1.v[2]).xy; // Position Id.\n            tri1.triID = float(i + triJ*4); // Triangle ID. Not used here.\n            tri1.dist = sdTri(p, tri1.v[0], tri1.v[1], tri1.v[2]); // Field distance.\n            tri1.p = p; // 2D coordinates.\n\n            // Mid edge points.\n            vec2[3] mid = vec2[3](mix(tri1.v[0], tri1.v[1], .5), mix(tri1.v[1], tri1.v[2], .5), mix(tri1.v[2], tri1.v[0], .5));\n\n            // Animating three edge lines and three vertex based lines.\n            for(int j = min(0, iFrame); j<3; j++){\n\n                 \n                // Three edge lines. Each map out a rhomboid path between four nodes.\n                //\n                // Rhombic nodal points -- These are hand picked.\n                vec2[4] pnt = vec2[4](mix(tri1.v[(0 + j)%3], mid[(2 + j)%3], .5), mix(mid[(2 + j)%3], mid[(0 + j)%3], .5), \n                                mix(mid[(2 + j)%3], mid[(1 + j)%3], .5), mid[(2 + j)%3]);\n                vec4 vAng = vec4(6.2831/3., 6.2831/6., 6.2831/3., 6.2831/6.); // Sweep angle.\n                vec2 p0 = p - pnt[(index + 1)%4]; // Pivot point.\n                float ang = mix(0., vAng[index], (fract(tm))); // Angular position.\n                p0 *= rot2(-ang); // Angular pivot.\n                vec2 p1 = (pnt[index] - pnt[(index + 1)%4]); // Anchor point.\n\n                // Line and circular end points for this edge.\n                float ln = sdLine(p0, vec2(0), p1);\n                float cir = min(length(p0), length(p0 - p1));  \n\n                // Add the line and end points for this edge to the total.\n                circle = min(circle, cir - cw);\n                line = min(line, ln - lw); \n\n                // Three vertex-based lines. Each map out a rhomboid path between four nodes.\n                //\n                // Do the same as above.\n                pnt = vec2[4](tri1.v[(0 + j)%3], mix(tri1.v[(0 + j)%3], tri1.v[(1 + j)%3], .25), \n                              mix(tri1.v[(0 + j)%3], tri1.v[(2 + j)%3], .25), vec2(0));\n                vec2 refDir = mix(pnt[0], pnt[2], .5) - pnt[1];\n                pnt[3] = pnt[1] + length(refDir)*normalize(refDir)*2.;\n\n                p0 = p - pnt[(index2 + 1)%4];\n                vAng = vAng.wzyx;\n                ang = mix(0., vAng[index2], (fract(tm2)));\n                p0 *= rot2(-ang);\n                p1 = (pnt[index2] - pnt[(index2 + 1)%4]);\n                ln = sdLine(p0, vec2(0), p1);\n\n                cir = min(length(p0), length(p0 - p1));  \n              \n                circle2 = min(circle2, cir - cw);\n                line2 = min(line2, ln - lw); \n                \n                \n                // If applicable, update the overall minimum distance value,\n                // then return the correct triangle information.\n                if(tri1.dist<d){\n                    d = tri1.dist;\n                    gT = tri1;\n                    //gT.id = idi + inCentRad(gT.v[0], gT.v[1], gT.v[2]).xy;\n                }\n                \n                \n            } \n        }\n        \n        if(line>1e6) break; // Fake break to help the compiler.\n    \n        \n    }\n    \n    // Return the distance, position-based ID and triangle ID.\n    return gT;\n}\n\n// A simpler triangle routine to help render the background.\nfloat gTri;\n\nvec4 getTri(vec2 p, float sc){\n \n    \n    // Rectangle stretch.\n    vec2 rect = vec2(2./sqrt(3.), 1)*sc; \n    //const vec2 rect = vec2(.85, 1.15)*scale; \n    // Skewing half way along X, and not skewing in the Y direction.\n    vec2 sk = vec2(rect.x/2./sc, 0); // 12 x .2\n    //p.x += rect.x/2.; \n     \n     p = skewXY(p, sk);\n    \n    // Unique position-based ID for each cell. Technically, to get the central position\n    // back, you'd need to multiply this by the \"rect\" variable, but it's kept this way\n    // to keep the calculations easier. It's worth putting some simple numbers into the\n    // \"rect\" variable to convince yourself that the following makes sense.\n\tvec2 id = floor(p/rect) + .5; \n    // Local grid cell coordinates -- Range: [-rect/2., rect/2.].\n\tp -= id*rect; \n    \n    \n    // Equivalent to: \n    //float tri = p.x/rect.x < -p.y/rect.y? 1. : 0.;\n    // Base on the bottom (0.) or upside down (1.);\n    gTri = dot(p, 1./rect)<0.? 0. : 1.;\n   \n    p = unskewXY(p, sk);\n    \n    return vec4(p, id);\n    \n    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n\n    // Resolution and aspect correct screen coordinates.\n    float iRes = min(iResolution.y, 800.);\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iRes; \n    \n     \n    // Scaling and translation.\n    const float gSc = 1.;\n    vec2 p = rot2(3.14159/6.)*uv*gSc;// + vec2(0, iTime/24.);//rot2(3.14159/6.)*\n    vec2 oP = p; // Saving a copy for later.\n    \n    // Resolution and scale based smoothing factor.\n    float sf = gSc/iResolution.y;\n    \n    // Sun direction and shadow sample.\n    vec2 sDir = rot2(3.14159/6.)*normalize(vec2(-1));\n    triS gTSh = blocks(p - sDir*.025);\n    \n    // Shadow field values.\n    float lineSh = line, line2Sh = line2, circleSh = circle, circle2Sh = circle2;\n    \n    // Take a function sample. \n    triS gT = blocks(p); \n    \n \n    // Triangle vertices, local coordinates and position-based ID.\n    // With these three things, you can render anything you want.\n    vec2[3] svV = gT.v;\n    vec2 svP = gT.p;\n    vec2 svID = gT.id;\n\n    \n    // Initializing the scene to a dark background color.\n    vec3 bg = vec3(.07);\n    vec3 col = bg;  \n    \n  \n    #ifdef SHOW_CELLS\n    // Triangle edge lines.\n    float ln = 1e5;\n    ln = min(ln, sdLine(svP, svV[0], svV[1]));\n    ln = min(ln, sdLine(svP, svV[1], svV[2]));\n    ln = min(ln, sdLine(svP, svV[2], svV[0]));\n    ln -= .0015; \n     \n    // Render the triangle cell edges.\n    col = mix(col, col*1.6, (1. - smoothstep(0., sf*4.*iRes/450., ln - .0005)));\n    col = mix(col, col*.3, (1. - smoothstep(0., sf*2., ln)));\n    #endif\n    \n \n    // The triangle background pattern.\n    //\n    // Sunken holes.\n    vec2 q = oP;\n    float tSc = 1./2./4.;\n    vec2 offs = vec2(sqrt(3.), 1)/3./16.;\n    vec4 triSh = getTri(q - sDir*.025*tSc, tSc);\n    float dotsSh = length(triSh.xy - offs) - .02;\n    if(gTri<.5) dotsSh = length(triSh.xy + offs) - .02;\n    \n    vec4 tri = getTri(q, tSc); \n    \n    float dots = length(tri.xy - offs) - .02;\n    if(gTri<.5) dots = length(tri.xy + offs) - .02;\n    \n    // Render the sunken holes.\n    col = mix(col, bg*.55, 1. - smoothstep(0., sf*2., dots - .003));\n    col = mix(col, (bg + .03)*(max(dots - dotsSh, 0.)/(.025/8.)*.5 + .5), 1. - smoothstep(0., sf, dots));\n \n    // Raised holes.\n    q = oP; \n    q += vec2(sqrt(3.), 1)/2.*tSc;\n    triSh = getTri(q - sDir*.025*tSc, tSc);\n    dotsSh = length(triSh.xy) - .02;\n    \n    tri = getTri(q, tSc);\n    dots = length(tri.xy) - .02;\n    \n     // Render the raised holes.\n    col = mix(col, bg*.55, 1. - smoothstep(0., sf*2., dots - .003));\n    col = mix(col, 1.3*(bg + .03)*(max(dotsSh - dots, 0.)/(.025/8.)*.5 + .5), 1. - smoothstep(0., sf, dots));\n\n\n    // Render the drop shadow over the background.\n    float shadow = min(min(lineSh, line2Sh), min(circleSh, circle2Sh));\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*12., shadow - .006))*.5);\n \n    // Back texture. Not used.\n    //vec3 tx = texture(iChannel0, oP).xyz; tx *= tx;\n    //tx = smoothstep(-.1, .5, tx);\n    //col *= tx*2.;\n    \n    // Color palette.\n    vec3 col1 = vec3(.75, 1, .3);//vec3(.3, 1, .5);//vec3(1, .75, .3)\n    vec3 col2 = vec3(1, .2, .4);//vec3(1, .2, .4);\n    #if PALETTE == 1\n    col1 = vec3(1, .65, .25);\n    col2 = vec3(.75, .35, .15);\n    #elif PALETTE == 2\n    col1 = vec3(.6);\n    col2 = col1;\n    #endif\n     \n    // Render the hexagon line layers -- AO, stroke, color, etc.\n    float sh2 = max(.2 - line2/.006, 0.);\n    sh2 *= max(line2Sh - line2, 0.)/.025 + .5;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., line2 - .003))*.35);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, line2 - .003));\n    col = mix(col, col2*sh2, 1. - smoothstep(0., sf, line2));\n    //col = mix(col, col*2., 1. - smoothstep(0., sf, line2 + .007)); // Extra shine.\n   \n    // Render the triangle line layers with a higher Z value.\n    float sh = max(.2 - line/.006, 0.);\n    sh *= max(lineSh - line, 0.)/.025 + .5;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., line - .003))*.35);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, line - .003));\n    col = mix(col, col1*sh, 1. - smoothstep(0., sf, line));\n    //col = mix(col, col*2., 1. - smoothstep(0., sf, line + .007)); // Extra shine.\n    \n    \n    \n    // Silver end points.\n    col1 = vec3(1); col2 = col1;\n    // Gold ends.\n    //col1 = vec3(1.2, .95, .5); col2 = col1;\n    // Silver fluorescent ends.\n    //col1 = mix(col1*3., vec3(1), .65); col2 = mix(col2*4., vec3(1), .65);\n    \n    // Render the hexagonal end points.\n    sf *= 1.5;\n    sh2 = max(.7 - circle2/.016, 0.);\n    sh2 *= max(circle2Sh - circle2, 0.)/.025*.5 + .5;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., circle2 - .003))*.35);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, circle2 - .003));\n    col = mix(col, col2*sh2, 1. - smoothstep(0., sf, circle2));\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf*1.5, circle2 + .01));\n   \n    // Render the triangle end points.\n    sh = max(.7 - circle/.016, 0.);\n    sh *= max(circleSh - circle, 0.)/.025*.5 + .5;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., circle - .003))*.35);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, circle - .003));\n    col = mix(col, col1*sh, 1. - smoothstep(0., sf, circle));\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf*1.5, circle + .01));\n    \n    \n    // Fake overhead lighting to roughly match the shadows.\n    col *= max(1.25 - length(uv + sDir*.5)*.5, 0.);\n    \n    \n    // Subtle vignette.\n    //uv = fragCoord/iResolution.xy;\n    //col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625)*1.05;\n    \n    \n    // Rought gamma correction and presentation.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}