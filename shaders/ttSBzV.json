{
    "Shader": {
        "info": {
            "date": "1599328790",
            "description": "Credit to jorge2017a1 for the original but partial credit to me for making a bunch of edits of course! :D ",
            "flags": 0,
            "hasliked": 0,
            "id": "ttSBzV",
            "likes": 1,
            "name": "Bunny Fork Fun ",
            "published": 3,
            "tags": [
                "fun",
                "forked"
            ],
            "usePreview": 0,
            "username": "celifrog",
            "viewed": 269
        },
        "renderpass": [
            {
                "code": "\n// sphinx\n// note: compilation error corrected, but white part is still wrong ???\n\n// ?\n// thank you\n// here is a bunny\n// which white part?\n\n// Bugs fixed ?\n// i fixed it ;) you have to change every pow(x,a) to pow(abs(x),a), because nvidia cards dont allow negative powers ^^\n\n\n\n#define SURFACE_THRESHOLD \t.001\n#define FAR_PLANE\t\t5.\n\n#define VIEW_POSITION\t\tvec3(0., -.15, 1.5)\t\t\n#define VIEW_TARGET\t\tvec3(0., 0., -1.);\n\n#define LIGHT_POSITION\t\tvec3(128., 64., 128.)// * vec3(sin(time*.125), 1., cos(time*.125))\n#define PI \t\t\t(4.*atan(1.))\n\n\nstruct ray\n{\n\tvec3 origin;\n\tvec3 position;\n\tvec3 direction;\n\tfloat range;\n\tfloat total_range;\n\tfloat edge;\n\tfloat id;\n};\n\n\t\nstruct light\n{\n\tvec3 position;\n\tvec3 direction;\n\tvec3 color;\t\n};\n\n\nstruct material\n{\n\tfloat roughness;\n\tfloat index;\n\tvec3 normal;\n\tvec3 color;\n};\n\nmat2 rmat(in float t)\n{\n\tfloat c = cos(t);\n\tfloat s = sin(t);\n\treturn mat2(c, s, -s, c);\n}\n\n\nmat3 rmat(in vec3 r)\n{\n\tvec3 a = vec3(cos(r.x)*cos(r.y),sin(r.y),sin(r.x)*cos(r.y));\n\t\n\tfloat c = cos(r.z);\n\tfloat s = sin(r.z);\n\tvec3 as  = a*s;\n\tvec3 ac  = a*a*(1.- c);\n\tvec3 ad  = a.yzx*a.zxy*(1.-c);\n\tmat3 rot = mat3(\n\t\tc    + ac.x, \n\t\tad.z - as.z, \n        \tad.y + as.y,\n\t\tad.z + as.z, \n\t\tc    + ac.y, \n\t\tad.x - as.x,\n\t\tad.y - as.y, \n\t\tad.x + as.x, \n\t\tc    + ac.z);\n\treturn rot;\t\n}\n\nfloat sphere(vec3 p, float r)\n{\n\treturn length(p)-r;\t\n}\n\t\nfloat smoothmax(float a, float b, float k)\n{\n\treturn log(exp(k*a)+exp(k*b))/k;\n}\n\nfloat smoothmin(float a, float b, float k)\n{\n\treturn -(log(exp(k*-a)+exp(k*-b))/k);\n}\n\nvec3 rotx(vec3 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n\n\nfloat cube(vec3 p,vec3 s)\n{\n\tvec3 d = (abs(p) - s);\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nfloat bunny(vec3 p)\n{\n        float b = FAR_PLANE;\n\tp *= .75;\n\tp.y += .5;\n\tp.z += .5;\n\tp.x = abs(p.x)+.5;\n\t\n\n       \n        vec3 bp01 = p - vec3(.5, 0.14, .16);\n        vec3 bp00 = p - vec3(.5, 0.18, .26);\n        vec3 bp0 = p - vec3(.5, 0.25, .25);\n        vec3 bp2 = p - vec3(.5, 0.25, .35);\n        vec3 bp1 = p - vec3(.5, 0.20, .6);\n        vec3 bp3 = p - vec3(.5, 0.25, .75);\n        vec3 bp4 = p - vec3(.5, 0.2, .84);\n        vec3 bp5 = p - vec3(.58, 0.25, .34)* vec3(1., .8, 1.);\n        vec3 bp6 = (p - vec3(.6, 0.12, .5)) * vec3(2., 1.8, .8);\n        vec3 bp7 = (p - vec3(.6, 0.1, .55)) ;\n        vec3 bp8 = (p - vec3(.56, 0.08, .7)) * vec3(1., 1., .35);\n        vec3 bp9 = (p - vec3(.56, 0.34, .62));\n        vec3 bp10 = (p - vec3(.56, 0.25, .86)) * vec3(1., 1., .35);\n        vec3 bp11 = (p - vec3(.56, 0.25, .82)) * vec3(.8, 1.1, .85);;\n        vec3 bp12 = (p - vec3(.5, 0.16, .9));\n    \n        bp9 \t= rotx(bp9, -1.9) * vec3(.8, .15, .5);;\n        \n        float b01 = sphere(bp01, .001);\n        float b00 = sphere(bp00, .05);\n        float b0  = sphere(bp0, .05);\n        float b1  = sphere(bp1, .07);\n        float b2  = sphere(bp2, .15);\n        float b3  = sphere(bp3, .01);\n        float b4  = sphere(bp4, .055);\n        float b5  = sphere(bp5, .12);\n        float b6  = sphere(bp6, .08);\n        float b7  = sphere(bp7, .0001);\n        float b8  = sphere(bp8, .01);\n        float b9  = sphere(bp9, .02);\n        float b10 = sphere(bp10, .001);\n        float b11 = sphere(bp11, .1);\n        float b12 = sphere(bp12, .1);\n    \n        b00  = smoothmin(b00,   b01, 60.);   //torso\n        b0   = smoothmin(b00,   b0, 3765.);     //torso\n        b    = smoothmin(b0,    b1, 5.);      //torso\n        b    = smoothmin(b,     b2, 35.);\n        b    = smoothmin(b,     b3, 8.);\n        \n        b    = smoothmin(b,     b4, 27.);    //head\n\n        b6 = smoothmin(b5, b6, 32.0);  //back leg\n        b7 = smoothmin(b6, b7, 96.0);  \n        b  = smoothmin( b, b7, 252.0);  \n    \n        b  = smoothmin(b, b8, 36.0);  //front legs\n    \n        b  = smoothmin(b, b9, 192.0);  //ears\n    \n        b  = smoothmax(b, -b10, 94.0);  //eye\n        b  = smoothmin(b,  b11, 256.0);  \n    \n        b  = smoothmin(b,  b11, 999.0);  //nose\n        b  = smoothmax(b,  -b12, 764.0); \n    \n  \n    return b;\n}\n\n\n\nvec2 map(in vec3 position)\n{\n\tfloat fx \t\t= abs(fract(position.x*11.)-.5);\n\tfloat fy \t\t= abs(fract(position.z*2.)-.5);\n\tfloat f \t\t= position.y + max(max(fx, fy)*.2, .095)+.5;\n\t\n\tposition.xz \t\t*= rmat(iTime*.125);\n\t\n\tfloat b \t\t= bunny(position);\n\n\tfloat id \t\t= b < f ? 1. : 2.;\n\t\n\treturn vec2(min(f,b), id);\n}\n\n\nvec3 derive(const in vec3 position, const in float range)\n{\n\tvec2 offset     = vec2(0., range);\n\tvec3 normal     = vec3(0.);\n\tnormal.x    \t= map(position+offset.yxx).x-map(position-offset.yxx).x;\n\tnormal.y    \t= map(position+offset.xyx).x-map(position-offset.xyx).x;\n\tnormal.z    \t= map(position+offset.xxy).x-map(position-offset.xxy).x;\n\treturn normalize(normal);\n}\n\n\t\nvoid emit(inout ray r)\n{\n\tfloat minimum_range\t= SURFACE_THRESHOLD;\n\tfloat closest_range\t= FAR_PLANE;\n\t\n\tfor(int i = 0; i < 156; i++)\n\t{\n\t\tvec2 scene\t= map(r.position);\n\t\tr.range \t= scene.x;\n\t\tr.id\t\t= scene.y;\n\t\tr.range \t= r.range < 0. ? r.range - r.range * .5 : r.range;\n\t\t\t\n\t\tr.range\t \t*= .6;\t\t//slow down ray\n\t\tminimum_range\t*= 1.0125;\t//relax surface\n\t\t\n\t\tr.total_range\t+= r.range;\n\t\t\n\t\tr.position \t= r.origin + r.direction * r.total_range;\t\n\t\t\n\t\tif(closest_range > r.range)\n\t\t{\n\t\t\tr.edge += .001225;\t\n\t\t}\n\t\t\n\t\tclosest_range\t= min(closest_range, abs(r.range));\n\t\t\n\t\tif(r.range < minimum_range || r.total_range > FAR_PLANE)\n\t\t{\n\t\t\tbreak;\t\n\t\t}\n\t}\t\n}\n\n\nfloat fresnel(const in float i, const in float ndl)\n{   \n\treturn i + (1.-i) * pow(abs(1.-ndl), 5.0);\n}\n\n\nfloat geometry(in float i, in float ndl, in float ndv)\n{\n\tndl             = max(ndl, 0.);\n\tndv             = max(ndv, 0.);\n\tfloat k         = i * sqrt(PI/PI);\n\tfloat ik        = 1. - k;\n\treturn (ndl / (ndl * ik + k)) * ( ndv / (ndv * ik + k) );\n}\n\n\nfloat distribution(const in float r, const in float ndh)\n{  \n\tfloat m     = 2./(r*r) - 1.;\n\treturn (m+r)*pow(abs(ndh), m)*.5;\n}\n\n\nfloat shadow(const in vec3 position, const in vec3 direction)\n{\n\tfloat exposure \t= 1.0;\n\tfloat penumbra \t= 0.15;\n\tfloat umbra\t= .00125;\n    \tfor(int i = 1; i < 8; ++i)\n    \t{\n\t\tfloat range\t= map(position + direction * penumbra).x;\n\t\t\n\t\tif ( range < umbra) return umbra;\n\t\t\n\t\texposure \t= min( exposure, 1. * range / penumbra);\n\t\tpenumbra \t+= range;\n\t}\n\t\n\treturn exposure;\n}\n\n\nfloat occlusion(in vec3 p, in vec3 n )\n{\n  \tfloat occlusion = 8.;\n  \tfloat penumbra \t= PI*PI;\n  \tfor ( int i=0; i < 1; i++ )\n  \t{\n  \t\tfloat radius \t= .125 * penumbra * float(i);\n    \t\tfloat range \t= map(n * radius + p).x - radius;\n    \t\tocclusion \t-= penumbra++ * range++;\n  \t}\n  \treturn 9.0 - 99.0 * -occlusion++;\n}\n\n\n//adapted from this nice sun here: http://glslsandbox.com/e#28403.2\nvec3 sky(in vec3 direction, in vec3 light_direction)\n{ \n\tfloat yd \t= min(-direction.y, 0.);\n\n\tdirection.y \t= max(direction.y, 0.4)+.05;\n    \n\tvec3 col \t= vec3(0.);\n    \n\tcol += vec3(.4, .4 - exp( -direction.y * 20.) * .3, .0) * exp(-direction.y * 9.); // Red / Green \n\tcol += vec3(.3, .5, .6) * (1. - exp(-direction.y * 8.)) * exp(-direction.y * .9) ; // Blue\n    \n\tcol = mix(col, vec3(.1),  .1-exp(yd*7.)) * .65; // Fog\n    \n\tvec3 sun_color = vec3(1., .66, .25);\n\tcol += pow(dot(abs(direction), light_direction), 15. ) * sun_color * .35;\n\tcol += pow(dot(abs(direction), light_direction), 150.0) *.05;\n\t\n    \treturn clamp(pow(abs(col), vec3(1.1))*2., 0., 1.);\n}\n\n\nvec4 shade( ray r,  light l,  material m)\n{\n\tvec3 half_direction \t\t= normalize(r.direction-l.direction);\n\tfloat half_normal   \t\t= dot(half_direction, m.normal);\n\t\t\n\tif(r.total_range < FAR_PLANE)\n\t{\t\n\t\t//exposure coefficients\n\t\tfloat light_exposure    \t= dot(m.normal,  l.direction);   \n\t\tfloat view_exposure     \t= dot(m.normal, -r.direction);  \n\t\t\n\t\t//microfacet lighting components\n\t\tfloat d             \t\t= distribution(m.roughness, half_normal);\n\t\tfloat g             \t\t= geometry(m.roughness, light_exposure, view_exposure);\n\t\tfloat f             \t\t= fresnel(m.index, light_exposure);\n\t\tfloat n             \t\t= clamp(-1. - fresnel(f, view_exposure), 0., 1.);\n\t\t\n\t\t//bidrectional reflective distribution function\n\t\tfloat brdf              \t= n * (g*d*f--)/(view_exposure*light_exposure*4.);\t\t\n\t\t\n\t\tfloat shadows\t\t\t= shadow(r.position, l.direction);\n\t\tshadows\t\t\t\t= clamp(shadows, .025, 1.);\n\n\t\tfloat occlusions\t\t= occlusion(r.position, m.normal);\n\t\tocclusions\t\t\t= clamp(occlusions, .05, 1.);\n\t\n\t\tvec3 color\t\t\t= m.color * n + m.color * l.color + brdf * l.color;\n\t\tcolor \t\t\t\t*= shadows * occlusions;\n\t\tcolor \t\t\t\t+= exp(.025 * r.total_range) * l.color * .95;\n\t\treturn vec4(color, occlusions * shadows);\n\t}\n\telse\n\t{\n\t\treturn vec4(sky(r.direction, l.direction), 1.) * 1.5 + vec4(exp(-r.total_range));\t\n\t}\n}\n\nvec3 hsv(float h,float s,float v)\n{\n\treturn mix(vec3(1.),clamp((abs(fract(h+vec3(3.,2.,1.)/3.)*6.-3.)-1.),0.,1.),s)*v;\n}\n\nvec3 facet(vec3 normal, vec3 position, float roughness)\n{\n\troughness *= .95;\n\treturn normal;\n}\n\nvec3 cartesian_to_spherical(vec3 c)\n{\n    vec3 s;\n    s.x = length(c);\n    s.y = atan(c.z / c.x);\n    s.z = asin(c.y / s.x);\n\treturn s;\n}\n\nvoid assign_material(in ray r, out material m)\n{\n\tm=material(0., 0., vec3(0.), vec3(0.));\n\t\n\tif(r.id == 0.)\n\t{\n\t\tm.roughness \t= .5;\n\t\tm.index \t= .5;\n\t\tvec3 p\t\t= fract(r.position);\n\t\tm.color \t+= float(p.x < .99 ^^ p.y < .99 ^^ p.z < .99) + .25;\n\t}\n\telse if(r.id == 1.)\n\t{\n\t\tm.roughness \t= .93125;\n\t\tm.index\t\t= .25;\n\t\tm.color\t\t= vec3(.9);\n\t}\n\telse if(r.id == 2.)\n\t{\n\t\tm.roughness \t= 1.5;\n\t\tm.index \t= .5;\n\t\tvec3 p\t\t= fract(r.position);\n\t\tm.color \t+= float(p.x < .5 ^^ p.y < .5 ^^ p.z < .5) * .5 + .125;\n\t}\n\t\n\tm.normal = derive(r.position, SURFACE_THRESHOLD);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 aspect\t\t= iResolution.xy/iResolution.yy;\n\t\n\tvec2 uv \t\t= fragCoord.xy/iResolution.xy;\n\tuv     \t\t\t= uv * 2. - 1.;\n    \tuv   \t\t\t*= aspect;\n   \t\n\t//view\n\tray r;\n\tr.range \t\t= 5.;\n\tr.total_range\t\t= 0.;\n\tr.edge\t\t\t= 2.;\n\tr.origin\t\t= VIEW_POSITION;\n\tr.position\t\t= r.origin;\n\t\n\tvec3 target\t\t= VIEW_TARGET;\n\tfloat fov\t\t= 2.5;\n\tvec3 w \t\t\t= normalize(target-r.position);\n    \tvec3 u \t\t\t= normalize(cross(w, vec3(9.,9.,0.)));\n    \tvec3 v \t\t\t= normalize(cross(u,w));\n\t\n    \tmat3 view\t \t= mat3(u.x, v.x, w.x, \n\t\t\t\t       u.y, v.y, w.y, \n\t\t\t\t       u.z, v.z, w.z);\n\n//\tuv.y \t\t\t= (mouse.y-.5+uv.y);\n\tuv.y \t\t\t-= .2;\n\tr.direction  \t\t= normalize(uv.x * u + uv.y * v + fov * w) * view;\n\tr.direction.xz\t\t*= rmat(PI);\n\t//r.direction.xz\t\t*= rmat(.5 * mouse.x * PI + PI * .75);\n\t\n\t//trace\n\temit(r);\n\t\n\t//shade\t\t\n\tmaterial m;\n\tassign_material(r, m);\n\t\t\n\tlight l;\n\tl.position \t\t= LIGHT_POSITION;\n\tvec4 color\t\t= vec4(0.);\t\n\t\n\t//reflections\n\tif(r.total_range < FAR_PLANE)\n\t{\n\t\t//reflection\n\t\tray rr\t\t\t= r;\n\t\trr.position\t\t= rr.position + m.normal * SURFACE_THRESHOLD * 1.5;\n\t\trr.origin\t\t= rr.position;\n\t\trr.direction \t\t= normalize(reflect(r.direction, m.normal));\n\n\t\trr.range\t\t= -10.;\n\t\trr.total_range\t\t= 5.;\n\n\t\temit(rr);\n\n\t\tmaterial rm;\n\t\tassign_material(rr, rm);\n\t\tl.direction\t\t= normalize(l.position - rr.position);\n\t\tvec3 rsky\t\t= sky(reflect(rr.direction, -rm.normal), l.direction);\n\t\tl.color \t\t= rsky;\n\t\tvec4 reflection\t\t= shade(rr, l, rm);\n\n\t\tl.direction\t\t= normalize(l.position - r.position);\n\t\tvec3 skyVec\t\t= sky(reflect(r.direction, m.normal), l.direction);\n\t\tl.color\t\t\t= clamp(mix(skyVec, reflection.xyz*reflection.w, m.index), 0., 1.);\n\t\t\n\t\tcolor \t\t\t= shade(r, l, m);\n\t\tcolor \t\t\t= mix(max(color, reflection), color, clamp(1.-m.index + m.roughness, 0., 1.)) \n\t\t\t                  + vec4(.01 * -r.edge * -skyVec, 0.) * -color.w++;\n\t}\n\telse\n\t{\n\t\tr.position \t= r.origin * r.direction * FAR_PLANE;\t\n\t\tl.direction\t= normalize(l.position - r.position);\n\t\tl.color\t\t= sky(r.direction, l.direction);\n\t\tcolor.xyz\t+= l.color*1.25+2.5/(r.position.y+1.35)*.125;\n\t}\n\t\n\tcolor \t= pow(color*.85, vec4(.6));\n\tcolor.w = 1.;\n\tfragColor \t\t= color;\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}