{
    "Shader": {
        "info": {
            "date": "1600570227",
            "description": "used this to learn: https://www.shadertoy.com/view/4tyXDR",
            "flags": 0,
            "hasliked": 0,
            "id": "ttBBWz",
            "likes": 19,
            "name": "Refraction, Fresnel, Absorption",
            "published": 3,
            "tags": [
                "raytracing",
                "transparency",
                "refraction",
                "fresnel"
            ],
            "usePreview": 0,
            "username": "MyGoodSir",
            "viewed": 2000
        },
        "renderpass": [
            {
                "code": "/*********************************\\\n| Shader Written by Joseph Adrian |\n| \t\t  Aug. 27, 2020\t\t\t  |\n|\t\t\t\t\t\t\t\t  |\n|\t\t\t\t\t\t\t\t  |\n\\*********************************/\n\n#define AA 1\n#define MAX_BOUNCES 8\n\n\t/*\t\t\t\t\t\t\t\t*\\\n   /|\t\t\t\t\t\t\t\t |\\\n  o)| \t\t\tSTRUCTURES\t\t\t |(o\n   \\|\t\t\t\t\t\t\t\t |/\n    \\*\t\t\t\t\t\t\t\t*/\n\nstruct LightData{\n    vec3 dir, col, amb;\n}light;\n\nstruct MaterialData{\n    vec3 diffuse;\n    float specularity;\n    float reflectivity;\n    vec3 absorbsion;\n    bool flec, frac, fres;\n    float ri_outer, ri_inner;\n    int objType;\n}obj;\n\nstruct Ray{\n    vec3 ori, dir;\n};\n\n\t/*\t\t\t\t\t\t\t\t*\\\n   /|\t\t\t\t\t\t\t\t |\\\n  o)| \t\tHELPER FUNCTIONS\t\t |(o\n   \\|\t\t\t\t\t\t\t\t |/\n    \\*\t\t\t\t\t\t\t\t*/\n\n//hash function from https://www.shadertoy.com/view/4djSRW\n//(you can find it in the \"common\" tab)\n\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(121.01836, 119.30347, 130.04261));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//Exponential Smooth Minimum\n\nfloat exsmin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\n//Polynomial Smooth Minimum\n\nfloat polsmin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//Power Smooth Minimum\n\nfloat powsmin( float a, float b, float k )\n{\n    a = pow( a, k ); b = pow( b, k );\n    return pow( (a*b)/(a+b), 1.0/k );\n}\n\nmat3 makeVP(vec3 pos, vec3 dir, float roll){\n    vec3 w = normalize(dir - pos);\n    vec3 u = normalize(cross(w, vec3(sin(roll), cos(roll), 0.)));\n    vec3 v = normalize(cross(u, w));\n    return mat3(u, v, w);\n}\n\n\t/*\t\t\t\t\t\t\t\t*\\\n   /|\t\t\t\t\t\t\t\t |\\\n  o)| DISTANCE AND NORMAL FUNCTIONS\t |(o\n   \\|\t\t\t\t\t\t\t\t |/\n    \\*\t\t\t\t\t\t\t\t*/\n\nvec4 danBox(Ray r, vec3 hs, out vec2 uv){//not mine\n\t// ray-box intersection\n    vec3 m = 1.0/r.dir;    // how many steps on each axis to travel 1 unit on that axis\n    vec3 n = m*r.ori;         // how many steps on each axis the ray origin is from the object origin\n    vec3 k = abs(m)*hs; // how many steps on each axis it takes to get from the center of the box to the edge\n\t\n    vec3 t1 = -n - k;   // how many steps on each axis to get from the ray origin to the negative surface of the box.\n    vec3 t2 = -n + k;   // how many steps on each axis to get from the ray origin to the positive surface of the box.\n\n\tfloat timeNear = max( max( t1.x, t1.y ), t1.z );\n\tfloat timeFar = min( min( t2.x, t2.y ), t2.z );\n\n\tif( timeNear > timeFar || timeFar < 0.0)\n        return vec4(-1.0);\n\n\t//vec3 normal = -sign(rayDirection)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    \n    if (timeNear < 0.0)\n        timeNear = timeFar;\n    \n    vec3 relPoint = r.ori + r.dir * timeNear;\n    \n    vec3 absRelPoint = abs(relPoint) / hs;\n    \n    vec3 normal;\n    vec3 uaxis;\n    vec3 vaxis;\n    // if Y isn't the biggest value it can't be the normal axis\n    if (absRelPoint.x >= absRelPoint.y)\n    {\n        // if X is the winner\n        if (absRelPoint.x >= absRelPoint.z)\n        {\n            normal = vec3(1.0, 0.0, 0.0) * -sign(r.dir);\n\t\t\tuaxis = vec3(0.0,1.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);            \n        }\n        // else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(r.dir);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }\n    }\n    // else X isn't the biggest value so it can't be the normal axis\n    else\n    {\n        // if Y is the winner\n        if (absRelPoint.y >= absRelPoint.z)\n        {\n            normal = vec3(0.0, 1.0, 0.0) * -sign(r.dir);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);\t           \n        }\n        // else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(r.dir);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }        \n    }\n    \n\tuv = vec2\n\t(\n\t\tdot(relPoint, uaxis),\n\t\tdot(relPoint, vaxis)\n\t);    \n\n\treturn vec4( timeNear, normal );   \n}\n\nvec4 danSphere(Ray r, vec4 sphere) {\n  \tvec3 cto = r.ori - sphere.xyz;//ray from sphere center to ray origin\n    \n    //oid = \"orthogonal intersection distance\" (vague and stupid name, ik)\n    //distance from spheres center to the point at which the ray \n    //intersects the line that: \n    //passes through the ray, \n    //passes through the spheres center, \n    //and is orthogonal to cto\n  \tfloat oid = dot(cto, r.dir);\n    \n    float dts = dot(cto, cto) - sphere.w*sphere.w;//distance to surface\n    \n    if(dts > 0.0 && oid > 0.0) { return vec4(-1.0); }\n    \n    float dsc = oid * oid - dts;//descriminant\n    \n    if(dsc < 0.0){ return vec4(-1.0); }\n    \n    float sv = 1.0;//sign value. used to correct the direction of the normal if the ray is inside the sphere.\n    float t = -oid - sqrt(dsc);//the time (distance along the ray) of the ray hit\n    if(t < 0.0){\n        t = -oid + sqrt(dsc);\n        sv = -1.0;\n    }\n    vec3 norm = normalize((r.ori + r.dir*t) - sphere.xyz) * sv;\n    \n    return vec4(t, norm);\n    \n}\n\nvec4 danPlane(Ray r, vec4 plane, out vec2 uv){\n    float t = -(dot(r.ori, plane.xyz)+plane.w)/dot(r.dir,plane.xyz);//time\n    vec3 ua = normalize(cross(plane.xyz, vec3(0., 1., 0.)));//u axis\n    vec3 va = normalize(cross(plane.xyz, ua));//v axis\n    vec3 hpos = r.ori + r.dir * t;//hit position\n    uv.x = dot(hpos, ua);\n    uv.y = dot(hpos, va);\n    return vec4(t, plane.xyz);\n}\n\n//r = ray, rb = ray bounds, p = plane, nn = nearplane normal, fn = farplane normal\nvoid rayclamp(Ray r, inout vec2 rb, vec4 p, inout vec3 nn, inout vec3 fn){\n    vec2 uv;\n    vec4 ri = danPlane(r, p, uv);//ray info\n    if(dot(ri.yzw, r.dir) < 0.0){\n        if(ri.x > rb.x){\n            rb.x = ri.x;\n            nn = ri.yzw;\n        }\n    }\n    else{\n        if(ri.x < rb.y){\n            rb.y = ri.x;\n            fn = ri.yzw;\n        }\n    }\n    \n}\n\nvec4 danObject (Ray r)//not mine\n{\n    if(obj.objType == 0){\n    \treturn danSphere(r, vec4(0.0, 0.0, 0.0, 0.5));\n    }\n    else{\n    \tvec2 uv;\n    \tvec4 ret = danBox(r, vec3(0.5), uv);\n    \tif (dot(r.dir, ret.yzw) > 0.0)\n            ret.yzw *= -1.0;\n    \treturn ret;\n    }\n}\n\nvec3 cbPattern(vec2 uv){\n    return vec3(mod(floor(uv.x * 4.0) + floor(uv.y * 4.0), 2.) < 1.0 ? 1.0 : 0.25);\n}\n\n\nvec3 lighting(Ray r, vec3 dif, vec3 norm, float sp, bool shd){\n    vec3 col = dif * light.amb;\n    \n    Ray scheck = r;\n    scheck.dir = -light.dir;\n    if(shd && norm.y >= 0.9/*magic?*/ && danObject(scheck).x >=0.0) { return col;}\n    \n    float dp = clamp(dot(norm, -light.dir), 0., 1.);\n    col += dif * dp * light.col;\n    \n    if(sp > 0.0){\n        vec3 rfn = reflect(-light.dir, norm);\n        dp = clamp(dot(r.dir, rfn), 0., 1.);\n        col += light.col * pow(dp, sp);\n    }\n    return col;\n}\n\nfloat fresnelValue(float n1, float n2, vec3 normal, vec3 incident){\n    if(obj.fres){\n        //schlick approx.\n        float r0 = (n1-n2)/(n1+n2);\n        r0*=r0;\n        float cx = -dot(normal, incident);\n        if(n1>n2){\n            float n = n1/n2;\n            float st2 = n*n*(1.0-cx*cx);\n            \n            if(st2>1.0) { return 1.0; }\n            cx = sqrt(1.0-st2);\n        }\n        float x = 1.0 - cx;\n        float o = r0+(1.0-r0)*x*x*x*x*x;\n        \n        o = (obj.reflectivity +(1.0-obj.reflectivity) * o);\n        return o;\n    }\n    else{\n        return obj.reflectivity;\n    }\n}\n\n\n\n\n//NOT MINE\n\n\n\nvec3 GetSceneRayColor (Ray r)\n{\n    // Returns the lit RGB for this ray intersecting with the scene, ignoring the main object.\n    // Used for reflection off the surface of the object, and refraction out the back of the object.\n    \n    // if we hit the box, return the lit box color\n    vec2 uv;\n    Ray temp = r;\n    temp.ori += vec3(0.0, 1.51, 0.0);\n    vec4 rayInfo = danBox(temp, vec3(1.0, 1.0, 1.0), uv);\n    if (rayInfo.x >= 0.0){\n        temp = r;\n        temp.ori += r.dir*rayInfo.x;\n        return lighting(temp, cbPattern(uv), rayInfo.yzw, 100.0, true);\n    }\n    // else return skybox color\n    else\n        return texture(iChannel0, r.dir).rgb;\n}\n\n//============================================================\nvec3 GetObjectInternalRayColor (Ray r)\n{\n    // bounce around inside the object as many times as needed (or until max bounces) due total internal reflection\n    float multiplier = 1.0;\n    vec3 ret = vec3(0.0);\n    float absorbDistance = 0.0;\n\tfor (int i = 0; i < MAX_BOUNCES; ++i)\n    {\n        // try and intersect the object\n    \tvec4 rayInfo = danObject(r);\n        \n        // should \"never\" happen but handle it anyways\n    \tif (rayInfo.x < 0.0)  \n            return ret;\n        \n        // move the ray position to the intersection point.\n        r.ori = r.ori + r.dir * rayInfo.x;\n        \n        // calculate beer's law absorption.\n        absorbDistance += rayInfo.x;    \n        vec3 absorb = exp(-obj.absorbsion * absorbDistance);\n        \n        // calculate how much to reflect or transmit (refract or diffuse)\n        float reflectMultiplier = fresnelValue(obj.ri_inner, obj.ri_outer, r.dir, rayInfo.yzw);\n        float refractMultiplier = 1.0 - reflectMultiplier;\n        \n        // add in refraction outside of the object\n        vec3 refractDir = refract(r.dir, rayInfo.yzw, obj.ri_inner / obj.ri_outer);\n        Ray temp = r;\n        temp.ori+=refractDir*0.001; temp.dir = refractDir;\n        ret += GetSceneRayColor(temp) * refractMultiplier * multiplier * absorb;\n        \n        // add specular highlight based on refracted ray direction\n        ret += lighting(r, obj.diffuse, refractDir, obj.specularity, false) * refractMultiplier * multiplier * absorb; \n        \n        // follow the ray down the internal reflection path.\n        r.dir = reflect(r.dir, rayInfo.yzw);\n        \n        // move the ray slightly down the reflect path\n        r.ori += r.dir * 0.001;\n        \n        // For reflection, we are only going to be reflecting what is refracted on further bounces.\n        // So, we just need to make sure the next bounce is added in at the reflectMultiplier amount, recursively.\n\t\tmultiplier *= reflectMultiplier;        \n    }\n    \n    // return the color we calculated\n    return ret;\n}\n\n//============================================================\nvec3 RayTracePixelColor (Ray r)\n{   \n    vec4 bestRayHitInfo = vec4(1000.0, 0.0, 0.0, 0.0);\n    vec3 rayHitDiffuse = vec3(1.0);\n    vec3 additiveColor = vec3(0.0);\n    \n    vec3 ret = vec3(0.0);\n           \n    // see if we've hit the platform and remember if we have\n    vec2 uv;    \n    Ray temp = r;\n    temp.ori += vec3(0.0, 1.51, 0.0);\n    vec4 rayInfo = danBox(temp, vec3(1.0, 1.0, 1.0), uv);\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {\n        bestRayHitInfo = rayInfo;\n        rayHitDiffuse = cbPattern(uv);\n    }\n    \n    // if we've hit the main object, and it's closer than the platform\n    rayInfo = danObject(r);\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {       \n        // light the surface of the ball a bit\n        additiveColor += lighting(r, obj.diffuse, rayInfo.yzw, obj.specularity, false);\n        \n        // move the ray to the intersection point\n        r.ori += r.dir * rayInfo.x;    \n         \n        // calculate how much to reflect or transmit (refract or diffuse)\n        float reflectMultiplier = fresnelValue(obj.ri_outer, obj.ri_inner, r.dir, rayInfo.yzw);\n        float refractMultiplier = 1.0 - reflectMultiplier;\n        \n        // get reflection color\n        if(obj.flec){\n        \tvec3 reflectDir = reflect(r.dir, rayInfo.yzw);\n            Ray temp = r;\n        \ttemp.ori+=reflectDir*0.001; temp.dir = reflectDir;\n        \tret += GetSceneRayColor(temp) * reflectMultiplier;\n        }\n        \n        // get refraction color\n        if(obj.frac){\n        \tvec3 refractDir = refract(r.dir, rayInfo.yzw, obj.ri_outer / obj.ri_inner);\n            Ray temp = r;\n        \ttemp.ori+=refractDir*0.001; temp.dir = refractDir;\n        \tret += GetObjectInternalRayColor(temp) * refractMultiplier;\n        }\n        \n        return ret + additiveColor;\n    }\n    // else we missed the object, so return either the skybox color, or the platform color, as appropriate\n    else\n    {\n        if (bestRayHitInfo.x == 1000.0)    \n            return texture(iChannel0, r.dir).rgb;\n        else\n        {\n            // move the ray to the intersection point (so we can shadow) and light the pixel\n        \tr.ori += r.dir * bestRayHitInfo.x;    \n            return lighting(r, rayHitDiffuse, bestRayHitInfo.yzw, 100.0, true);    \n        }\n    }\n}\n\n\nvoid setup_vals(){\n    obj.diffuse = vec3(0.0);\n    obj.specularity = 0.00;\n    obj.reflectivity = 0.0;\n    obj.absorbsion = vec3(1.40, 1.40, 0.02);\n    obj.frac = true;\n    obj.flec = true;\n    obj.fres = true;\n    obj.ri_outer = 1.0029;\n    obj.ri_inner = 1.125;\n    obj.objType = 0;\n    \n    light.dir = normalize(-vec3(1.0,2.0,1.0));\n    light.col = vec3(1.0);\n    light.amb = vec3(0.1);\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    setup_vals();\n    \n    vec3 lookAt = vec3(0.0); //what the camera should be looking at\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;//normalize mouse coordinates\n\t\n    \n\t//camera position as a function of mouse location\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 3.14159;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 3.14) - 1.0 : 0.5;\n    vec3 cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 3.0;\n\n    //construct orthonormal basis for cameraspace\n    vec3 cameraFwd  = normalize(lookAt - cameraPos);\n    vec3 cameraLeft  = normalize(cross(normalize(lookAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\n    vec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n\n    //setup fov and view depth(?)\n    float cameraViewWidth\t= 6.0;\n    float cameraViewHeight\t= cameraViewWidth * iResolution.y / iResolution.x;\n    float cameraDistance\t= 6.0;  // intuitively backwards!\n\n    //----- Ray Setup\n    vec2 rawPercent = (fragCoord.xy / iResolution.xy); //normalized viewport coordinates\n    vec2 percent = rawPercent - vec2(0.5,0.5);//center coordinates in midde of screen\n\t\n    //find ray direction (there are easier ways of setting all this up tbh)\n    vec3 rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n        - (cameraLeft * percent.x * cameraViewWidth)\n        + (cameraUp * percent.y * cameraViewHeight);\n    vec3 rayDir = normalize(rayTarget);    \n\tRay r;\n    r.ori = cameraPos;\n    r.dir = rayDir;\n    \n    //----- Ray Trace\n    vec3 finalColor = vec3(0.0);\n    \n    #if AA\n        for (int i = 1; i <= 16; ++i)\n        {\n            // calculate stratified subpixel jitter in a 4x4 grid\n            float x = mod(float(i)-1.0, 4.0);\n            float y = mod(floor(float(i) / 4.0), 4.0);\n            vec2 jitter = hash21(float(i)) / 4.0;\n            jitter.x += x / 4.0;\n            jitter.y += y / 4.0;\n            \n            // set up the jittered ray\n            rawPercent = ((fragCoord.xy + jitter) / iResolution.xy); \n            percent = rawPercent - vec2(0.5,0.5);\n\n            rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n                - (cameraLeft * percent.x * cameraViewWidth)\n                + (cameraUp * percent.y * cameraViewHeight);\n            rayDir = normalize(rayTarget);\n            r.dir = rayDir;\n\t\t\t// raytrace\n            vec3 color = RayTracePixelColor(r);\n            \n            // incrementally average our pixel color in\n            finalColor = mix(finalColor, color, 1.0 / float(i));            \n        }\n    #else\n   \t\tfinalColor = RayTracePixelColor(r);\n    #endif\n    \n    //----- Final color, gamma corrected\n    fragColor = vec4(pow(finalColor, vec3(1.0/2.2)),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}