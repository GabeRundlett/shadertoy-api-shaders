{
    "Shader": {
        "info": {
            "date": "1641558962",
            "description": "Rolling polygons generate hypotrochoids and epitrochoids in interesting ways - see Mathologer video: [url]https://www.youtube.com/watch?v=oEN0o9ZGmOM[/url]\n\nLots of controls, see code header for details. 'x' to change display mode, 'a' to set P/M types. ",
            "flags": 48,
            "hasliked": 0,
            "id": "7tKXWy",
            "likes": 42,
            "name": "Hypotrochoids & Polygons",
            "published": 3,
            "tags": [
                "polygon",
                "golden",
                "mathologer",
                "hypotrochoids"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 988
        },
        "renderpass": [
            {
                "code": "/////////////////////////////////////////////////////////////////////////////////\n//\n// Hypotrochoids & Polygons. Created by Matthew Arcus, mla, 2022\n//\n// See Mathologer video: https://www.youtube.com/watch?v=oEN0o9ZGmOM for the\n// maths. A hypertrochoid is generated by two sets of polygons, sharing\n// vertices, rotating in circles (this is related to Daniel Bernoulli's Double\n// Generation Theorem - any hypertrochoid is generated by one circle rolling\n// around another in two different ways). This is still true for an epitrochoid,\n// where the circle rotates around the outside of a fixed circle - the other\n// generating configuration has a larger circle rotating around a smaller, but\n// making _internal_ contact.\n//\n// This shader has two display modes (switch with 'x') - the default where just\n// one polygon is shown from each set, as well as the fixed and rolling circles\n// generating the hypotrochoid (generally different for the two types of polygon),\n// the other mode shows all polygons, but doesn't show the circles as otherwise\n// the display gets too confusing (use 'c' and 'f' to show the circles anyway).\n//\n// To set the type P/M, press 'a', and use the mouse, pressing 'a'\n// again fixes the selected type. For M < P we get a hypotrochoid generated by\n// M-gons and P-M = N-gons. For M > P,  we get an epitrochoid generated by M-gons\n// and M-P = N-gons. In both cases the trochoid has P-fold symmetry.\n//\n// To set d, the distance of the generating point from the centre of the M-gon,\n// press 'd' & select a value with mouse-x. Press 'd' again to fix the selected value.\n//\n// Such modal UIs can be confusing, so we show some large blobs in the top left\n// indicating when modal input is being processed.\n//\n// Controls:\n// <mouse>: select parameters as described above\n// <up>/<down>: zoom in and out\n// <left>/<right>: change scale\n// 'x': switch display mode\n// 'a': set hypotrochoid type with mouse\n// 's': set polygon offsets with mouse (for star polygons)\n// 'd': set d parameter with mouse (relative point distance from circle centre)\n// 'c': show rolling circles in both modes\n// 'f': show fixed circles in both modes\n// 't': show trochoid\n// 'p': show points\n// 'm': show m-gons\n// 'n': show n-gons\n// 'h': hide text\n// 'z': slow down\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// Type is P/M. M is the number of N-gons, N is the number of M-gons\n// For a hypotrochoid, P = M+N, for an epitrochoid, P = M-N\nint P = 9, M = 5, N; // Set N later from P and M\nfloat D = 1.2; // Relative distance of point from centre of travelling circle\nint offi = 0, offj = 0; // Set > 0.0 for star polygons\nfloat R = 1.0; // Radius of main fixed circle\nfloat r;       // Radius of main rolling circle, set later\nint mode = 0;\nfloat time;\n\n// Centre of the M-gons\nvec2 icentre(int i) {\n  float theta = TWOPI*(time + float(i))/float(N);\n  return (R-r)*vec2(cos(theta),sin(theta));\n}\n\n// Centre of the N-gons\nvec2 jcentre(int j) {\n  float phi = TWOPI*(time + float(j))/float(M);\n  float sign = M>P?1.0:-1.0;\n  return D*r*vec2(cos(phi),sign*sin(phi));\n}\n\n// The ith point of the jth N-gon, or the jth point of the ith M-gon\nvec2 point(int i, int j) {\n  return icentre(i) + jcentre(j); // Magic!\n}\n\n// The trochoid curve function.\nvec2 trochoid(float t) {\n  float theta = TWOPI*t;\n  float phi = (R-r)/r*theta;\n  // For epitrochoid, R-r is negative and all works out fine...\n  return vec2((R-r)*cos(theta)+D*r*cos(phi),\n              (R-r)*sin(theta)-D*r*sin(phi));\n}\n\nvoid mainImage(out vec4 outColor, vec2 fragCoord) {\n  mode = int(key(CHAR_X));\n  vec2 z = 1.2*(2.0*fragCoord - iResolution.xy ) / iResolution.y;\n  z *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  z = z.yx; // Make stars point upwards\n  vec4 amouse = keymouse(CHAR_A);\n  vec4 smouse = keymouse(CHAR_S);\n  vec4 dmouse = keymouse(CHAR_D);\n  if (amouse.x > 0.0) {\n    // set type\n    M = 2+int(14.0*amouse.y);\n    P = 2+int(14.0*amouse.x);\n  }\n  N = abs(M-P); \n  if (dmouse.x > 0.0) D = 4.0*dmouse.x;\n  if (smouse.x > 0.0) {\n    offi = int(5.0*smouse.x)%(N-1);\n    offj = int(5.0*smouse.y)%(M-1);\n  }\n  time = iTime;\n  if (mode == 1) time *= 0.5;\n  if (key(CHAR_Z)) time *= 0.5;\n  R = M>P?0.4:1.0;\n  R *= exp(0.1*float(keycount(KEY_LEFT)-keycount(KEY_RIGHT)));\n\n  r = R*float(M)/float(P);\n  float px = fwidth(length(z));\n  vec3 col = vec3(1,1,0.8);\n  float lwidth = 0.015;\n  lwidth *= exp(0.1*float(keycount(KEY_PAGE_DOWN)-keycount(KEY_PAGE_UP)));\n  float lwidth2 = 0.5*lwidth;\n  float bwidth = 0.2*lwidth;\n  float pwidth = 2.0*lwidth;\n  if (key(CHAR_Q)) {\n    vec3 tex = texture(iChannel0,fragCoord/iResolution.y).xyz;\n    float tfact = 0.5+0.75*dot(tex,tex);\n    col *= 0.5+0.5*sqrt(tex);\n    lwidth *= tfact;\n    lwidth2 *= tfact;\n    pwidth *= tfact;\n    bwidth *= tfact;\n  }\n\n  // Most, but not all, drawing happens within this radius.\n  float tlimit = 0.05+(abs(r-R)+D*r);\n  //assert(length(z) < tlimit);\n  bool inlimit = length(z) < tlimit;\n  if (mode == 0 || key(CHAR_F)) {\n    // Draw fixed circles\n    col = mix(vec3(0),col,smoothstep(-px,px,abs(length(z)-R)-lwidth));\n    col = mix(vec3(0),col,smoothstep(-px,px,abs(length(z)-D*R)-lwidth));\n  }\n  if (inlimit && !key(CHAR_T)) {\n    // Draw the curve: basic algorithm, take n points on the whole curve\n    // & run through points looking for points a,b,c in a row that\n    // \"bracket\" minimum, ie. f(a) > f(b) < f(c), so there must be (at\n    // least) one (local) minimum between a and c. Then use \"Golden Section\n    // search\" to refine the bracketed interval if it looks like we might\n    // be sufficiently close to the curve.\n    float d = 1e8;\n    // If M and N aren't coprime, we get GCD(M,N) separate trochoids.\n    // rotated by multiples of 2PI/(M-N) or 2PI/(M+N).\n    int cycles = gcd(M,N);\n    int T = 15*(M+N); // Total number of segments\n    float delta = float(M)/float(T); // Segment size\n    float testwidth = 10.0*lwidth*lwidth; // Squared width plus leeway\n    const int csize = 8;\n    float candidates[csize];\n    for (int cycle = 0; cycle < cycles; cycle++) {\n      int cindex0 = 0;\n      int cindex = 0;\n      vec2 z1 = rotate(z,TWOPI*float(cycle)/float(P));\n      float t0 = float(T*cycle/cycles);\n      vec2 p0 = trochoid(t0), p1 = trochoid(t0+delta);\n      float d0 = distance2(z1,p0), d1 = distance2(z1,p1);\n      for (int i = 0; i < T/cycles; i++) {\n        vec2 p2 = trochoid(t0+2.0*delta);\n        float d2 = distance2(z1,p2);\n        // Look for a bracketed minimum that is close enough.\n        if (d1 < d0 && d1 < d2 &&\n            (segment2(z1,p0,p1) < testwidth || segment2(z1,p1,p2) < testwidth)) {\n          //assert(length(p0) < length(p2));\n          // This shenanigans puts outward going arcs before inward going\n          // arcs, so, if we are lucky, we get a nice interwoven look.\n          if (length(p0) < length(p2)) {\n            candidates[cindex++] = t0;\n          } else {\n            for (int j = cindex; j > cindex0; j--) {\n              candidates[j] = candidates[j-1];\n            }\n            candidates[cindex0++] = t0;\n            cindex++;\n          }\n          if (cindex == csize) break;\n        }\n        t0 += delta;\n        d0 = d1; d1 = d2;\n        p0 = p1; p1 = p2;\n      }\n      //assert(cindex == 0);\n      if (cindex == 0) continue;\n      for (int i = 0; i < cindex; i++) {\n        float t0 = candidates[i], t1 = t0+delta, t2 = t0+2.0*delta;\n        vec2 p0 = trochoid(t0), p1 = trochoid(t1), p2 = trochoid(t2);\n        float d1 = distance2(z1,p1);\n        // Golden section search. We bracket the minimum\n        // with a,b,c, f(a) > f(b) < f(c). Then choose\n        // larger of the two interval (a,b),(b,c) and\n        // split by the golden section to give d. So\n        // eg. have a < d < b - if f(d) < f(b), then\n        // new interval (a,d,b) is bracketed, else\n        // (d,b,c) is bracketed.\n        for (int i = 0; i < 3; i++) {\n          bool left = t1-t0 > t2-t1;\n          float t3 = left ? t0+0.618*(t1-t0) : t2+0.618*(t1-t2);\n          vec2 p3 = trochoid(t3);\n          float d3 = distance2(z1,p3);\n          if (left) {\n            if (d3 < d1) {\n              // t3 is new best minimum\n              t2 = t1; t1 = t3;\n              p2 = p1; p1 = p3; d1 = d3;\n            } else {\n              t0 = t3; p0 = p3;\n            }\n          } else {\n            if (d3 < d1) {\n              // t3 is new best minimum \n              t0 = t1; t1 = t3;\n              p0 = p1; p1 = p3; d1 = d3;\n            } else {\n              t2 = t3; p2 = p3;\n            }\n          }\n        }\n        // Check distance to both segments\n        d = 1e8;\n        //assert (length(p0) < length(p1));\n        d = min(d,segment2(z1,p0,p1));\n        d = min(d,segment2(z1,p1,p2));\n        d = sqrt(d); // d has been distance squared up to now.\n        col = mix(vec3(1,0.8,0.3),col,smoothstep(-px,px,d-lwidth));\n        col = mix(vec3(0),col,smoothstep(-px,px,abs(d-lwidth)-bwidth));\n      }\n    }\n  }\n  if (mode == 0 || key(CHAR_C)) {\n    if (!key(CHAR_M)) {\n      for (int i = 0; i < N; i++) {\n        float t = distance2(z,icentre(i));\n        vec3 ccol = vec3(0);\n        col = mix(ccol,col,smoothstep(-px,px,abs(sqrt(t)-abs(r))-lwidth2));\n        if (mode == 0) break;\n      }\n    }\n    if (!key(CHAR_N)) {\n      for (int j = 0; j < M; j++) {\n        float t = distance2(z,jcentre(j));\n        vec3 ccol = vec3(0);\n        col = mix(ccol,col,smoothstep(-px,px,abs(sqrt(t)-abs(D*(R-r)))-lwidth2));\n        if (mode == 0) break;\n      }\n    }\n  }\n  if (inlimit && !key(CHAR_M)) {\n    float d = 1e8;\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < M; j++) {\n        vec2 p = point(i,j);\n        vec2 q = point(i,j+1+offj);\n        d = min(d,segment2(z,p,q));\n      }\n      if (mode == 0) break;\n    }\n    col = mix(vec3(0.7,0,0),col,smoothstep(-px,px,sqrt(d)-lwidth));\n    col = mix(vec3(0),col,smoothstep(-px,px,abs(sqrt(d)-lwidth)-bwidth));\n  }\n  if (inlimit && !key(CHAR_N)) {\n    float d = 1e8;\n    for (int j = 0; j < M; j++) {\n      for (int i = 0; i < N; i++) {\n        vec2 p = point(i,j);\n        vec2 q = point(i+1+offi,j);\n        d = min(d,segment2(z,p,q));\n      }\n      if (mode == 0) break;\n    }\n    col = mix(vec3(0,0,0.8),col,smoothstep(-px,px,sqrt(d)-lwidth));\n    col = mix(vec3(0),col,smoothstep(-px,px,abs(sqrt(d)-lwidth)-bwidth));\n  }\n\n  if (inlimit && !key(CHAR_P)) {\n    // Show points\n    float d = 1e8;\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < M; j++) {\n        d = min(d,distance2(z,point(i,j)));\n        if (mode == 0 && i > 0) break;\n      }\n    }\n    col = mix(vec3(0),col,smoothstep(-px,px,sqrt(d)-pwidth));\n  }\n  // Show blobs for modes\n  vec2 scoord = 256.0*vec2(fragCoord.x,iResolution.y-fragCoord.y)/iResolution.y;\n  float sx = fwidth(scoord.x);\n  if (key(CHAR_A)) col *= smoothstep(-sx,sx,distance(scoord,vec2(15,15))-10.0);\n  if (key(CHAR_S)) col *= smoothstep(-sx,sx,distance(scoord,vec2(45,15))-10.0);\n  if (key(CHAR_D)) col *= smoothstep(-sx,sx,distance(scoord,vec2(75,15))-10.0);\n  if (!key(CHAR_H)) {\n    float fsize = iResolution.y/12.0;\n    vec2 fdim = vec2(0.4,1);\n    vec2 p = fragCoord/fsize;\n    vec2 uv = vec2(0);\n    int dochar = 0;\n    vec4 limits = vec4(0.3,0.7,0,1);\n    int chars[11];\n    int cindex = 0;\n    if (P/10 > 0) chars[cindex++] = 48+P/10;\n    chars[cindex++] = 48+P%10;\n    chars[cindex++] = 32+15;\n    if (M/10 > 0) chars[cindex++] = 48+M/10;\n    chars[cindex++] = 48+M%10;\n    for (int i = 0; i < cindex; i++) {\n      dochar += char(p,fdim*vec2(i,0),limits,chars[i],uv);\n    }\n    cindex = 0;\n    int dint = int(round(10.0*D));\n    chars[cindex++] = 48+dint/10;\n    chars[cindex++] = 0x2E; // .\n    chars[cindex++] = 48+dint%10;\n    // These calculations could be neater...\n    float xcoord = iResolution.x/fsize-float(cindex)*fdim.x-(1.0-fdim.x);;\n    for (int i = 0; i < cindex; i++) {\n      dochar += char(p,vec2(xcoord,0)+fdim*vec2(i,0),limits,chars[i],uv);\n    }\n    \n    //vec4 t = textureGrad(iChannel1,uv,dFdx(p/16.0),dFdy(p/16.0));\n    // textureLod seems to give sharper characters at low resolutions\n    vec4 t = textureLod(iChannel1,uv,0.0);\n    if (dochar > 0) col *= 1.0-t.x;\n  }\n  col = pow(col,vec3(0.4545));\n  if (alert) col.b = 1.0;\n  outColor = vec4(col,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x);\n  int j = int(uv.y);\n  if ( iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (i == 0) {\n    float w1 = keystate(j,2).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      t.x++;\n    }\n  } else if (i == 1) {\n    if (j == 0 && iMouse.z != 0.0) t.xy = iMouse.xy;\n    if (j == 1 && iMouse.z == 0.0) t.xy = iMouse.xy;\n  } else if (i == 2 && iMouse.z > 0.0 && key(j)) {\n    t = vec4(iMouse.xy/iResolution.xy,0,iTime);\n  }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const float PI = 3.14159;\nconst float TWOPI = 2.0*PI;\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nfloat distance2(vec2 p, vec2 q) {\n  p -= q;\n  return dot(p,p);\n}\n\nfloat segment2(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return distance2(p,b*h);\n}\n\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n// Macros for use in \"common\" blocks.\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))\n#define keymouse(key) (store(2,(key)));\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\nint gcd(ivec2 v) {\n    while(bool(v = v.yx)) v.y %= v.x;\n    return v.y;\n}\n\nint gcd(int a, int b) {\n  return gcd(ivec2(a,b));\n}\n\n// https://www.shadertoy.com/view/4sBfRd\nint char(vec2 p, vec2 q, vec4 limits, int c, inout vec2 uv) {\n    p -= q;\n    if (p.x<limits.x|| p.x>limits.y || p.y<limits.z|| p.y>limits.w) return 0;\n    uv = p/16.0 + fract(vec2(c,15-c/16)/16.0);\n    return 1;\n}\n\nint char(vec2 p, vec2 q, int c, inout vec2 uv) {\n  return char(p,q,vec4(0,1,0,1),c,uv);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}