{
    "Shader": {
        "info": {
            "date": "1588453635",
            "description": "yes\nif you have the plugin:\nalt+down to restart in fullscreen\nuse acceleration 4x",
            "flags": 32,
            "hasliked": 0,
            "id": "3sXBRB",
            "likes": 16,
            "name": "Galaxy vortex",
            "published": 3,
            "tags": [
                "fluid",
                "particles"
            ],
            "usePreview": 1,
            "username": "michael0884",
            "viewed": 663
        },
        "renderpass": [
            {
                "code": "obj getObj(int id)\n{\n    obj o;\n    \n    vec4 a = texel(ch0, i2xy(ivec3(id, 0, 0))); \n    o.X = a.xy; o.V = a.zw;\n    o.Y = texel(ch0, i2xy(ivec3(id, 1, 0)));\n    \n    o.id = id;\n    return o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    sN = SN; \n    N = ivec2(R*P/vec2(sN));\n    TN = N.x*N.y;\n    ivec2 pi = ivec2(floor(pos));\n    \n    int ID = int(texel(ch1, pi).x); \n    obj O = getObj(ID);\n    float d1 = exp(-0.15*distance(pos, O.X));\n    float d2 = 1.*O.Y.x;\n   \n    loop(j,4)\n    {\n        vec4 nb = texel(ch0, i2xy(ivec3(ID, j, 2)));\n        loop(i,4)\n    \t{\n            if(nb[i] < 0.) continue;\n            vec2 nbX = texel(ch0, i2xy(ivec3(nb[i], 0, 0))).xy; \n        \td1 += exp(-0.15*distance(pos, nbX));\n    \t}\n    }\n    d1*=0.07;\n    // Output to screen\n    fragColor = vec4(sin(vec3(1,2,3)*d2*0.3)*d1 + d1,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define R iResolution.xy\n#define PI 3.14159265\n\n#define dt 2.\n#define loop(i,x) for(int i = min(0, iFrame); i < x; i++)\n\n\n//sim stuff\nstruct obj\n{\n    int id; //ID\n    vec2 X; //position\n    vec2 V; //velocity\n    vec4 Y; //inner params \n};\n    \nfloat Force(float d)\n{\n    return -4.*exp(-0.6*d);\n}\n\n//40% of the buffer used for particles\n#define P 0.8\n#define SN ivec2(8, 3)\n\nivec2 N; //buffer size\nivec2 sN; //buffer single element size\nint TN; //buffer length\n\nivec2 i2xy(ivec3 sid)\n{\n    return sN*ivec2(sid.x%N.x, sid.x/N.x) + sid.yz;\n}\n\nivec3 xy2i(ivec2 p)\n{\n    ivec2 pi = p/sN;\n    return ivec3(pi.x + pi.y*N.x, p.x%sN.x, p.y%sN.y);\n}\n\nivec2 cross_distribution(int i)\n{\n    return (1<<(i/4)) * ivec2( ((i&2)/2)^1, (i&2)/2 ) * ( 2*(i%2) - 1 );\n}\n\n//hash funcs\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//L1 particle buffer - simulation\n//L2 directional graph - sort\n//L3 neighbor graph - sort\n\nint ID;\nobj O; //this object\n\n//sort arrays\nvec4 lnk0, lnk1;\nvec4 d0, d1;\n\n//L3\nvec4 EA[SN.x]; //element array\n\nvoid insertion_sort(float t, int id);\nobj getObj(int id); vec4 saveObj(int i);\nbool iscoincidenceEA(int id);\nvoid sort0(int idtemp, int D); void sort1(int idtemp, int D);\n\nvoid mainImage( out vec4 Q, in vec2 pos )\n{\n    //4 pix per layer, 3 layers\n    sN = SN; \n    N = ivec2(R*P/vec2(sN));\n    TN = N.x*N.y;\n    int S = 3; //log2(sN.x)\n    \n    ivec2 p = ivec2(floor(pos));\n    if(any(greaterThan(p, sN*N-1))) discard;\n   \n    ivec3 sid = xy2i(p); ID = sid.x;\n    O = getObj(ID);\n    d0 = vec4(1e6); d1 = vec4(1e6);\n    lnk0 = vec4(-1); lnk1 = vec4(-1);\n    \n    switch(sid.z)\n    {\n    case 0: //particle\n        if(sid.z >= 2) discard;\n        \n       \t//load all neighbors\n        loop(i,4)\n        {\n            EA[i] = texel(ch0, i2xy(ivec3(ID, i, 2))); \n        }\n        \n        vec2 F = -0.0005*(O.X - R*0.5)/(pow(length(O.X - R*0.5),1.)+1.); \n        vec2 Fp = vec2(0);\n        float DIV = 0.;\n        vec2 avgP = vec2(0.,0.);\n        \n        vec2 Lnb = texel(ch0, i2xy(ivec3(EA[3].w, 0, 0))).xy;\n        float scale = 0.25*distance(O.X, Lnb);  \n        \n        loop(j,4)\n        {\n            vec4 nb = EA[j];\n            loop(i,4)\n            {\n                int pid = int(nb[i]);\n                if(pid < 0 || pid >= TN || pid == ID) continue; \n                obj nbO = getObj(pid);\n                \n                float d = distance(O.X, nbO.X);\n                vec2 dv = (nbO.V - O.V);\n                float sk = exp(-d/scale)/scale;\n                float divD = 1./(length((nbO.X - O.X))+1.);\n                float dotv = divD*dot(O.X - nbO.X, dv); //divergence correction\n                \n                vec2 antidivergence = 0.3*dv*abs(dotv)*sk;\n                vec2 pressure = 0.01*sk*divD*(nbO.X - O.X)*(nbO.Y.x - O.Y.x);\n                Fp += (nbO.X - O.X)*Force(d)*divD;\n                DIV += dotv*sk;\n                avgP += vec2(nbO.Y.x, 1)*sk;\n                F += pressure + antidivergence + 0.0005*(nbO.X - O.X)*divD/(0.1*d*d+1.);\n            }\n        }\n        \n        if(iMouse.z > 0.) \n        {\n            float d = distance(iMouse.xy, O.X);\n            F += 0.004*normalize(iMouse.xy - O.X)/(sqrt(d)+2.);\n        }\n        \n        O.Y.x += (DIV + 0.6*(avgP.x/avgP.y - O.Y.x) - O.Y.x*0.01)*dt;\n        O.V += (F)*dt;\n        O.X += (O.V+0.1*Fp)*dt;\n\n        \n        /*//border conditions\n        if(R.x - O.X.x < 2.) {O.V.x = -abs(O.V.x); O.X.x = mix(O.X.x,R.x - 2.,0.5);}\n        if(O.X.x < 2.)  {O.V.x = abs(O.V.x); O.X.x = mix(O.X.x,2.,0.5);}\n        if(R.y - O.X.y < 2.)  O.V.y = -abs(O.V.y);\n        if(O.X.y < 2.)  {O.V.y = abs(O.V.y); O.X.y = mix(O.X.y, 2.,0.5);}*/\n        \n        if(iFrame<10)\n        {\n            O.X = R*vec2(i2xy(ivec3(ID,0,0)))/vec2(N*sN);\n\t\t\tO.V = 0.2*(hash22(3.14159*pos) - 0.5) + 0.2*vec2(O.X.y-R.x*0.5, R.y*0.5-O.X.x)/R;\n            O.Y = vec4(0);\n        }\n\n        Q = saveObj(sid.y);\n        return;\n        \n    case 1: //dir graph\n        if(sid.y >= 4) discard;\n        \n        //sort neighbors and neighbor neighbors\n        vec4 nb0 = texel(ch0, i2xy(ivec3(ID, sid.y, 1)));\n        loop(i,4)\n        {\n            sort0(int(nb0[i]), sid.y);  //sort this\n            //use a sudorandom direction of the neighbor\n            vec4 nb1 = texel(ch0, i2xy(ivec3(nb0[i], (iFrame+ID)%4, 1)));\n            loop(j,2)\n            {\n                sort0(int(nb1[j]), sid.y);  \n            }\n        }\n        \n        //random sorts\n        loop(i,4) sort0(int(float(TN)*hash13(vec3(iFrame, ID, i))), sid.y);\n        \n        Q = lnk0;\n        return;\n        \n    case 2: // neighbor graph\n        \n        //basic XOR sort\n        int ste = iFrame % S;\n        int id0 = sid.y;\n        int id1 = id0^((1<<(ste+1))-1); //pair id, by flipping first n bits, n - is the step\n        if(id1 >= sN.x) discard;\n\t    //sort this block\n        vec4 nb = texel(ch0, i2xy(ivec3(ID, id0, 2)));\n        vec4 nb1 = texel(ch0, i2xy(ivec3(ID, id1, 2)));\n        loop(i,4)\n        {\n            sort1(int(nb[i]), sid.y);  \n            sort1(int(nb1[i]), sid.y);  \n        }\n\n        if(id1 == sN.x-1 || id0 == sN.x-1) //if last pair\n        {\n            //load entire array\n            loop(i,sN.x)\n            {\n                EA[i] = texel(ch0, i2xy(ivec3(ID, i, 2))); \n            }\n            \n            //do random sorts\n            loop(j,4)\n            {\n            \tvec4 nb1 = texel(ch0, i2xy(ivec3(ID, j, 1)));\n                loop(i,2)\n                {\n                   //check coincidence with entire array\n                   if(iscoincidenceEA(int(nb1[i+iFrame%2]))) continue;\n                   sort1(int(nb1[i+iFrame%2]), sid.y);  \n                }\n            }\n            \n            loop(i,4) \n            {\n                int nbid = int(float(TN)*hash13(vec3(iFrame, ID, i))); \n                if(iscoincidenceEA(nbid)) continue;\n                sort1(nbid, sid.y);\n            }\n        }\n        \n        //store sorted\n        Q = (id0>id1) ? lnk1 : lnk0;\n        return;\n    }\n     \n}\n\nvec4 saveObj(int i)\n{\n    switch(i)\n    {\n    case 0:  \n        return vec4(O.X, O.V);\n    case 1:\n        return O.Y;\n    case 2:\n        return vec4(0.);\n    case 3:\n        return vec4(0.);\n    }\n}\n\nobj getObj(int id)\n{\n    obj o;\n    \n    vec4 a = texel(ch0, i2xy(ivec3(id, 0, 0))); \n    o.X = a.xy; o.V = a.zw;\n    o.Y = texel(ch0, i2xy(ivec3(id, 1, 0)));\n    \n    o.id = id;\n    return o;\n}\n\nvoid insertion_sort(float t, int id)\n{\n    if(d0.x > t)\n    {\n        d1 = vec4(d0.w, d1.xyz); d0 = vec4(t, d0.xyz);\n        lnk1 = vec4(lnk0.w, lnk1.xyz); lnk0 = vec4(id, lnk0.xyz);\n    } else if(d0.y > t)\n    {\n        d1 = vec4(d0.w, d1.xyz); d0.yzw = vec3(t, d0.yz); \n        lnk1 = vec4(lnk0.w, lnk1.xyz); lnk0.yzw = vec3(id, lnk0.yz);\n    } else if(d0.z > t)\n    {\n        d1 = vec4(d0.w, d1.xyz); d0.zw = vec2(t, d0.z); \n        lnk1 = vec4(lnk0.w, lnk1.xyz); lnk0.zw = vec2(id, lnk0.z);\n    }else if(d0.w > t)\n    {\n        d1 = vec4(d0.w, d1.xyz); d0.w = t; \n        lnk1 = vec4(lnk0.w,lnk1.xyz); lnk0.w = float(id); \n    }else if(d1.x > t)\n    {\n        d1 = vec4(t, d1.xyz);\n        lnk1 = vec4(id, lnk1.xyz);\n    }else if(d1.y > t)\n    {\n        d1.yzw = vec3(t, d1.yz);\n        lnk1.yzw = vec3(id, lnk1.yz);\n    }else if(d1.z > t)\n    {\n        d1.zw = vec2(t, d1.z);\n        lnk1.zw = vec2(id, lnk1.z);\n    }else if(d1.w > t)\n    {\n        d1.w = t;\n        lnk1.w = float(id);\n    }\n}\n\nbool iscoincidence(int id)\n{\n    return (id < 0) || \n           any(equal(lnk0,vec4(id))) || \n           any(equal(lnk1,vec4(id)));\n}\n\nbool iscoincidenceEA(int id)\n{\n    bool f = id < 0;\n    for(int i = 0; i < SN.x; i++)\n    {\n        f = f || any(equal(EA[i],vec4(id))); \n    }\n    return f;\n}\n\n\nvoid sort0(int idtemp, int D) //sort closest objects in sN.x directions\n{\n    if(iscoincidence(idtemp)) return; //particle already sorted\n    \n    vec2 nbX = texel(ch0, i2xy(ivec3(idtemp, 0, 0))).xy; \n   \n    vec2 dx = nbX - O.X;\n    int dir = int(2.*(atan(dx.y, dx.x)+PI)/PI); \n    \n    if(dir != D) return; //not in this sector\n    \n    float t = length(dx);\n   \n    insertion_sort(t, idtemp);\n}\n\nvoid sort1(int idtemp, int D) //sort closest objects \n{\n    if(iscoincidence(idtemp)) return; //particle already sorted\n    \n    vec2 nbX = texel(ch0, i2xy(ivec3(idtemp, 0, 0))).xy; \n   \n    vec2 dx = nbX - O.X;\n    \n    float t = length(dx);\n   \n    insertion_sort(t, idtemp);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//voronoi particle tracking + graph augmented\n\nfloat d;\nint id;\nvec2 p;\n\nfloat particleDistance(int i)\n{\n    return distance(p, texel(ch0, i2xy(ivec3(i, 0, 0))).xy);\n}\n\nvoid sort(int utemp)\n{\n    if(utemp < 0) return; \n   \tfloat dtemp = particleDistance(utemp);\n    if(dtemp < d) //sorting\n    {\n        d = dtemp;\n        id = utemp;\n    }\n}\n\n\nvoid mainImage( out vec4 Q, in vec2 pos )\n{\n    sN = SN; \n    N = ivec2(R*P/vec2(sN));\n    TN = N.x*N.y;\n    d = 1e10;\n    id = 1;\n    p = pos;\n    ivec2 pi = ivec2(floor(pos));\n    \n    sort(1+0*int(texel(ch1, pi).x));\n    \n    int ID = id;\n    loop(j,4)\n    {\n        int nbid = int(texel(ch1, pi+cross_distribution(j)).x);\n        sort(nbid);\n        vec4 nb = texel(ch0, i2xy(ivec3(ID, j, 1)));\n        sort(int(nb[0]));  //sort this\n    }\n    \n    loop(i,8) //random sort\n    {\n        sort(int(float(TN)*hash13(vec3(iFrame, pi.x, pi.y*i))));\n    }\n    \n   \tQ = vec4(id, d, 0, 0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}