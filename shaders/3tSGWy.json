{
    "Shader": {
        "info": {
            "date": "1560858521",
            "description": "from base version [url]https://shadertoy.com/view/wtjGzt[/url],\nhere I add the filtering of high frequencies. #BIAS / #SPREAD to trade thresholding.\nClick to switch off.\nIn addition, note how #grad() =||dFdxy()|| improves compare to fwidth().",
            "flags": 0,
            "hasliked": 0,
            "id": "3tSGWy",
            "likes": 38,
            "name": "antialiasing fract (2)",
            "published": 3,
            "tags": [
                "antialiasing",
                "fract",
                "tuto",
                "short",
                "smoothfract",
                "shannonnyquist"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 1712
        },
        "renderpass": [
            {
                "code": "// Self-ref: https://www.shadertoy.com/view/3tSGWy\n\n// Improved version on \"antialiasing fract\"  https://shadertoy.com/view/wtjGzt\n// dealing with antialiasing of 2 use-case of fract: ramps and bars.\n// Here: also deal with Shannon-Nyquiest filtering for high frequencies.\n\n//#define grad(x) fwidth(x)\n  #define grad(x) length(vec2(dFdx(x),dFdy(x)))\n\n// w = pixel width = grad(continous signal) . c = possibly fracted signal.\n#define Nyquist(w,c) mix(.5, c, clamp((.5-BIAS-(w))/.25/SPREAD,0.,1.) )\n\n#define BIAS -.0  // < 0: prefer a bit of aliasing to blur \n#define SPREAD 1. // < 1: transition more brutal \n\nfloat aafract(float x) {    // --- antialiased fract\n    float v = fract(x),\n          w = grad(x),      // pixel width. NB: x must not be discontinuous or factor discont out\n          c = v < 1.-w ? v/(1.-w) : (1.-v)/w; // replace right step by down slope (-> chainsaw is continuous).\n               // shortened slope : added downslope near v=1 \n    return c; \n // return Nyquist(w,c); // version with high-freq filtering integrated\n}\n\nfloat aastep(float x) {     // --- antialiased step(.5)\n    float w = grad(x),      // pixel width. NB: x must not be discontinuous or factor discont out\n          c = smoothstep(.7,-.7,(abs(fract(x-.25)-.5)-.25)/w); // just use  (offseted) smooth squares\n    return c;\n // return Nyquist(w,c);    // version with high-freq filtering integrated\n}\n\nvoid mainImage( out vec4 O, in vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( u - .5*R ) / R.y;            // normalized coordinates\n    float a = atan(U.y,U.x), l = length(U); // polar coordinates\n \n    float v = 20.*a/6.28 + 10./l +iTime, // + sin(10.*l), // some fancy field\n        //v = 100.*exp(-3.*abs(.8*U.x+.2*U.y)),           // linear gradient\n        //v = 200.*a/6.28,                                // radial gradient\n          w = grad(v);                      // pixel width. \n#if 0\n    v = .5+.5*sin(6.28*v); // use with v = 200.*a/6.28 above\n#else\n    v = U.y > 0.\n            // top: spiral displayed with ramps, using fract\n            ? U.x < 0. ? fract( v ) : aafract( v )\n            // bottom: spiral displayed with bars, using step(fract)\n            : U.x < 0. ? step(.5,fract(v)) : aastep(v);\n#endif\n    // version with Nyquist not already integrated in aafract/aastep:\n    // ( just to demo Nyquist also applied to aliased fract case. ) \n    if (iMouse.z<=0.) v = Nyquist(w,v);\n  //v *= iMouse.y/R.y;\n    \n    O = vec4( pow(v, 1./2.2) ); // final conversion to sRGB ( NB: sqrt(v) would be a good approx )\n    if ( abs(U.x) < 1./R.y ) O = vec4(1,0,0,0); // red separator\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}