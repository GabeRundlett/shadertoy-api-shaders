{
    "Shader": {
        "info": {
            "date": "1647954647",
            "description": "A quantization transfer function that supports sloped steps as well as uneven step distributions.",
            "flags": 48,
            "hasliked": 0,
            "id": "stsyD8",
            "likes": 14,
            "name": "SemiQuantize",
            "published": 3,
            "tags": [
                "quantization"
            ],
            "usePreview": 0,
            "username": "TinyTexel",
            "viewed": 409
        },
        "renderpass": [
            {
                "code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n    \n#define VarTex iChannel0\n#define OutCol col\n#define OutChannel w\n\n#define WriteVar(v, cx, cy) {if(uv.x == float(cx) && uv.y == float(cy)) OutCol.OutChannel = v;}\n#define WriteVar4(v, cx, cy) {WriteVar(v.x, cx, cy) WriteVar(v.y, cx, cy + 1) WriteVar(v.z, cx, cy + 2) WriteVar(v.w, cx, cy + 3)}\n\nfloat ReadKey(int keyCode) {return texelFetch(iChannel2, ivec2(keyCode, 0), 0).x;}\nfloat ReadKeyToggle(int keyCode) {return texelFetch(iChannel2, ivec2(keyCode, 2), 0).x;}\n\nfloat ReadVar(int cx, int cy) {return texelFetch(VarTex, ivec2(cx, cy), 0).OutChannel;}\nvec2 ReadVar2(int cx, int cy) {return vec2(ReadVar(cx, cy), ReadVar(cx, cy + 1));}\nvec3 ReadVar3(int cx, int cy) {return vec3(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2));}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n\nfloat ReadVar(inout int x) { return ReadVar(x++, 0); }\nvec2 ReadVar2(inout int x) { return ReadVar2(x++, 0); }\nvec3 ReadVar3(inout int x) { return ReadVar3(x++, 0); }\nvec4 ReadVar4(inout int x) { return ReadVar4(x++, 0); }\n\nvec4 A, B, C, D;\n\n// C. Schlick. \"Fast alternatives to Perlinâ€™s bias and gain function\"\n// inverse(Bias(x,s)) =   Bias(x  ,1-s)\n// inverse(Bias(x,s)) = 1-Bias(1-x,  s)\nfloat Bias(float x, float s)\n{\n    if(s == 0.0) return x != 1.0 ? 0.0 : 1.0;\n    if(s == 1.0) return x != 0.0 ? 1.0 : 0.0;\n    \n    return x / ((1.0/s - 2.0) * (1.0 - x) + 1.0);\n}\n\nfloat linstep(float a, float b, float x)\n{\n    x = clamp((x - a) / (b - a), 0.0, 1.0);\n    return x;\n}\n\nfloat smootherstep(float a, float b, float x)\n{\n    x = clamp((x - a) / (b - a), 0.0, 1.0);\n    return x*x*x * (x * (x * 6.0 - 15.0) + 10.0);\n}\n\nfloat bump(float a, float b, float x)\n{\n    x = clamp((x - a) / (b - a), 0.0, 1.0);\n    x = (x - x*x) * 4.0;\n    return x*x*x;\n}\n\n\n#define STEPMAP smootherstep\n#define BUMPMAP bump\n// count [0..s] | sharp [0..1] | bias [0..0.5..1] | blend [0..1]\nfloat Quantize(float y, float count, float sharp, float bias, float blend)\n{\n    if(count == 0.0) return y;\n    \n    float yu = y;\n    yu = Bias(yu, bias);\n    yu *= count;\n    float yi = floor(yu);\n    float yf = yu - yi;\n\n    return mix(Bias((yi + (sharp == 1.0 ? (yf < 0.5 ? 0.0 : 1.0) : STEPMAP(sharp*0.5, 1.0 - sharp*0.5, yf))) / count, 1.0-bias), y, blend);\n}\n\n\n// count [0..s] | sharp [0..1] | blend [0..1]\nfloat Quantize(float y, float count, float sharp, float blend)\n{\n    if(count == 0.0) return y;\n    \n    float yu = y;\n    yu *= count;\n    float yi = floor(yu);\n    float yf = yu - yi;\n\n    return mix(((yi + (sharp == 1.0 ? (yf < 0.5 ? 0.0 : 1.0) : STEPMAP(sharp*0.5, 1.0 - sharp*0.5, yf))) / count), y, blend);\n}\n\nvec3 Quantize(vec3 v, float count, float sharp, float blend)\n{\n    return vec3(Quantize(v.r, count, sharp, blend),\n                Quantize(v.g, count, sharp, blend),\n                Quantize(v.b, count, sharp, blend));\n}\n\nfloat QBumps(float y, float count, float sharp)\n{\n    if(count == 0.0) return 0.0;\n    \n    float yu = y;\n    yu *= count;\n    float yi = floor(yu);\n    float yf = yu - yi;\n\n    return sharp == 1.0 ? 0.0 : BUMPMAP(sharp*0.5, 1.0 - sharp*0.5, yf);\n}\n\nvec3 QBumps(vec3 v, float count, float sharp)\n{\n    return vec3(QBumps(v.r, count, sharp),\n                QBumps(v.g, count, sharp),\n                QBumps(v.b, count, sharp));\n}\n\n\n// count [0..s] | sharp [0..1] | bias [0..0.5..1] | blend [0..1]\nfloat Quantize2(float y, float count, float sharp, float bias, float blend)\n{\n    if(count == 0.0) return y;\n    \n    float y0 = y;\n    \n        float yu = y;\n    yu = Bias(yu, bias);\n    \n    float sw = 1.0 / count * 0.5 * sharp;\n    yu = mix(sw, 1.0 - sw, yu);    \n    \n\n    yu *= count;\n    float yi = floor(yu);\n    float yf = yu - yi;\n\n    return mix(Bias((yi + (sharp == 1.0 ? (yf < 0.5 ? 0.0 : 1.0) : STEPMAP(sharp*0.5, 1.0 - sharp*0.5, yf))) / count, 1.0-bias), y0, blend);\n}\n\n// count [0..s] | sharp [0..1] | blend [0..1]\nfloat Quantize2(float y, float count, float sharp, float blend)\n{\n    if(count == 0.0) return y;\n    \n    float y0 = y;\n    \n    float sw = 1.0 / count * 0.5 * sharp;\n    y = mix(sw, 1.0 - sw, y);     \n    \n    float yu = y;\n    yu *= count;\n    float yi = floor(yu);\n    float yf = yu - yi;\n\n    return mix(((yi + (sharp == 1.0 ? (yf < 0.5 ? 0.0 : 1.0) : STEPMAP(sharp*0.5, 1.0 - sharp*0.5, yf))) / count), y0, blend);\n}\n#undef STEPMAP\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{\n    Resolution = iResolution;\n    \n    vec3 col = vec3(0.0);\n    vec2 uv = uv0.xy - 0.5;\n    \n    int I = 0;\n    vec4 iMouse     = ReadVar4(I);\n    vec4 mouseAccu  = ReadVar4(I);\n    vec4 wasdAccu   = ReadVar4(I);\n    float frameAccu = ReadVar (I);\n    float knobVal   = ReadVar (I);\n    ActiveKnobMatId = int(ReadVar(I));\n\n    int KnobMatId = 0;\n    ivec2 KnobMatStateBuffOrigin = ivec2(KnobMatId * 4, KnobMatStateBuffY0);\n\n    A.x = texelFetch(iChannel0, ivec2(0, 0) + KnobMatStateBuffOrigin, 0).w;\n    //A.y = texelFetch(iChannel0, ivec2(1, 0) + KnobMatStateBuffOrigin, 0).w;\n    //A.z = texelFetch(iChannel0, ivec2(2, 0) + KnobMatStateBuffOrigin, 0).w;\n    //A.w = texelFetch(iChannel0, ivec2(3, 0) + KnobMatStateBuffOrigin, 0).w;\n\n    B.x = texelFetch(iChannel0, ivec2(0, 1) + KnobMatStateBuffOrigin, 0).w;\n    //B.y = texelFetch(iChannel0, ivec2(1, 1) + KnobMatStateBuffOrigin, 0).w;\n    //B.z = texelFetch(iChannel0, ivec2(2, 1) + KnobMatStateBuffOrigin, 0).w;\n    //B.w = texelFetch(iChannel0, ivec2(3, 1) + KnobMatStateBuffOrigin, 0).w;\n\n    C.x = texelFetch(iChannel0, ivec2(0, 2) + KnobMatStateBuffOrigin, 0).w;\n    //C.y = texelFetch(iChannel0, ivec2(1, 2) + KnobMatStateBuffOrigin, 0).w;\n    //C.z = texelFetch(iChannel0, ivec2(2, 2) + KnobMatStateBuffOrigin, 0).w;\n    //C.w = texelFetch(iChannel0, ivec2(3, 2) + KnobMatStateBuffOrigin, 0).w;\n\n    D.x = texelFetch(iChannel0, ivec2(0, 3) + KnobMatStateBuffOrigin, 0).w;\n    //D.y = texelFetch(iChannel0, ivec2(1, 3) + KnobMatStateBuffOrigin, 0).w;\n    //D.z = texelFetch(iChannel0, ivec2(2, 3) + KnobMatStateBuffOrigin, 0).w;\n    //D.w = texelFetch(iChannel0, ivec2(3, 3) + KnobMatStateBuffOrigin, 0).w;\n        \n\n    {\n        vec2 tex = uv0;\n        tex -= iResolution.xy * 0.5;\n        tex /= iResolution.yy * 0.4;\n\n        //tex *= 0.25+0.0375;\n\n\n        col = mix(vec3(1.0), vec3(0.95), Grid(tex.xy * 4.0, 0.0));        \n        col = mix(col, vec3(0.75), Grid(tex.xy * 1.0, 0.0));        \n        col = mix(col, vec3(0.5), Cross(tex.xy * 1.0, 0.)); \t\n\n\n        // relevant plotting code:\n\n        // black\n        float f = clamp(tex.x * 0.5 + 0.5, 0.0, 1.0);\n        {\n            float count = round(mix(1.0, 8.0, A.x));\n            \n            float sharp = B.x;\n            \n            float bias = C.x;\n            \n            float blend = D.x;\n\n            f = Quantize(f, count, sharp, bias, blend);\n        }\n        f = f * 2.0 - 1.0;\n        \n        col = mix(col, vec3(0.), Graph(f - tex.y, 1.));  \n    }\n\n#if 1\n{\n    // vignetting\n    vec2 s = abs(uv0/iResolution.xy*2.0-1.0);\n    s.x = 1.0-Pow3(s.x);    s.y = 1.0-Pow3(s.y);\n    col *= mix(1.0, 0.4, Pow2(1.0-sqrt(s.x*s.y)));\n}\n#endif\n\n#if 1\n//if(ReadKeyToggle(KEY_TAB) != 0.0)\n{    \n    #if 0\n    {\n        float width = KnobSizeTotal * 4.0;\n        \n        if(uv.x < width+4.0 && uv.y > GetKnobMatPosY1()-4.0 && uv.y < GetKnobMatPosY0() + 48.0+2.0)\n        {\n            col *= 0.75;\n        }\n         \n    }\n    #endif\n    \n    // knobs\n    vec3 ui = texelFetch(iChannel0, ivec2(uv), 0).rgb;\n    \n    vec3 kcol = vec3(0.1);\n    if(ui.z == 1.0) kcol = vec3(0.1, 0.0, 0.0); else\n    if(ui.z == 2.0) kcol = vec3(0.0, 0.05, 0.0); else\n    if(ui.z == 3.0) kcol = vec3(0.0, 0.0, 0.18); else\n    if(ui.z == 4.0) kcol = vec3(0.1, 0.1, 0.0); else\n    if(ui.z == 5.0) kcol = vec3(0.0, 0.08, 0.08); else\n    if(ui.z == 6.0) kcol = vec3(0.1, 0.0, 0.1);\n    \n    //col = mix(col, kcol, ui.y);\n    //col = mix(col, kcol*(1.0-ui.y), ui.y);\n    col = mix(col, vec3(0.0), ui.y);\n    col = mix(col, mix(kcol*10.0, vec3(1.0), 0.5), ui.x*1.5);\n    //col = mix(col, vec3(0.99), ui.x);\n}\n#endif\n\n\n    \n\toutCol = vec4(GammaEncode(clamp01(col)), 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/* persistent state stuff and knobs */\n\n\n#define KeyBoard iChannel1\n\nfloat ReadKey(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 0), 0).x;}\nfloat ReadKeyToggle(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 2), 0).x;}\n\n#define VarTex iChannel0\n#define OutCol col\n#define OutChannel w\n\n#define WRITEVAR(v, cx, cy) {if(uv.x == float(cx) && uv.y == float(cy)) OutCol.OutChannel = v;}\n#define WRITEVAR2(v, cx, cy) {WRITEVAR(v.x, cx, cy) WRITEVAR(v.y, cx, cy + 1)}\n#define WRITEVAR3(v, cx, cy) {WRITEVAR(v.x, cx, cy) WRITEVAR(v.y, cx, cy + 1) WRITEVAR(v.z, cx, cy + 2)}\n#define WRITEVAR4(v, cx, cy) {WRITEVAR(v.x, cx, cy) WRITEVAR(v.y, cx, cy + 1) WRITEVAR(v.z, cx, cy + 2) WRITEVAR(v.w, cx, cy + 3)}\n\n#define WriteVar(v, x) {WRITEVAR(v, x, 0) ++x;}\n#define WriteVar2(v, x) {WRITEVAR2(v, x, 0) ++x;}\n#define WriteVar3(v, x) {WRITEVAR3(v, x, 0) ++x;}\n#define WriteVar4(v, x) {WRITEVAR4(v, x, 0) ++x;}\n\nfloat ReadVar(int cx, int cy) {return texelFetch(VarTex, ivec2(cx, cy), 0).OutChannel;}\nvec2 ReadVar2(int cx, int cy) {return vec2(ReadVar(cx, cy), ReadVar(cx, cy + 1));}\nvec3 ReadVar3(int cx, int cy) {return vec3(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2));}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n\nfloat ReadVar(inout int x) { return ReadVar(x++, 0); }\nvec2 ReadVar2(inout int x) { return ReadVar2(x++, 0); }\nvec3 ReadVar3(inout int x) { return ReadVar3(x++, 0); }\nvec4 ReadVar4(inout int x) { return ReadVar4(x++, 0); }\n\nvec3 Knob(vec2 uv, KnobState state)\n{\n    if(state.colId < 0.0) return vec3(0.0);\n    \n    uv -= state.p;\n    \n    float v = 0.0;\n    \n    float l = length(uv);\n    \n    v = abs(l - (state.r.x - state.r.y)) - state.r.y;\n    \n    float sh = 1.0;\n    sh = clamp01(v * 0.18);\n    sh = 1.0-(1.0-sh)*(1.0-sh);\n    sh = mix(0., 1.0, sh);\n    v = clamp01(v);\n    \n    v = 1.0 - v;\n    float o;\n    {\n        float a = state.n;\n\n        bool tc = state.signed;\n        if(tc) a = a * 0.5 + 0.5;\n        a *= 2.0;\n        bool ac = a > 1.0;\n        float m = clamp01((ac ? uv.x : -uv.x)+0.5);\n        if(ac) a = a - 1.0;\n\n        m = min(m, clamp01((tc ? 1.0 : -1.0) * dot(AngToVec((1.0-a)*Pi), uv)+0.5));\n        if(!tc && ac) m = 1.0-m;\n       \n        o = m;\n    }\n    \n    float r = v;\n    r = v * mix(0.18, 0.95, o);\n\n    if(state.signed && uv.x < 0.0) { r = v * mix(0.06, 0.6, o);}\n    \n    return vec3(r, 1.0 - sh, state.colId);\n}\n\n// https://www.shadertoy.com/view/4tfBzn\nfloat TextSDF(vec2 p, float glyph)\n{\n    p = abs(p.x - .5) > .5 || abs(p.y - .5) > .5 ? vec2(0.) : p;\n    return 2. * (texture(iChannel3, p / 16. + fract(vec2(glyph, 15. - floor(glyph / 16.)) / 16.)).w - 127. / 255.);\n}\n\nvoid ValueText(inout vec4 col, vec2 uv0, float n)\n{\n    vec2 p = uv0 * 0.5;\n    \n    vec2 scale = vec2(4., 8.);\n    vec2 t = floor(p / scale);   \n\n    if(t.x < 0.0 || t.x > 5.0 || t.y != 0.0) return;\n    if((n == 0.0 || abs(n) == 1.0) && t.x > 1.0) return;\n    if(t.x == 0.0 && n >= 0.0) return;\n    \n\n    float c = 0.0;\n    \n    if(t.x == 0.0) c = 45.0;\n    else if(t.x == 1.0) c = n == 0.0 ? 48.0 : (abs(n) == 1.0 ? 49.0 : 46.0);\n    else\n    c = abs(n) == 1.0 ? 48.0 : 48.0 + mod(floor(abs(n)*1000.0 * exp2((4.0-t.x) * -(log2(10.0)/log2(2.0)))), 10.0);\n\n    p = (p - t * scale) / scale;\n    p.x = (p.x - 0.5) * 0.5 + 0.5;\n\n    if (c == 0.) return;\n    \n    float sdf = TextSDF(p, c);\n    \n    sdf = smoothstep(-0.05, 0.05, sdf);\n\n    col.r = (1.0 - sdf);// * 0.999;\n}\n\nfloat KnobMatIdButtonMat(inout vec4 col, vec2 uv)\n{\n    vec2 uv2 = vec2(uv.x, uv.y - GetKnobMatPosY0());\n    \n    float width = KnobSizeTotal * 4.0;\n    float height = 48.0;\n    float ButtonCountX = 4.0;\n    float ButtonCountY = 2.0;\n\n    if(uv2.x < width && uv2.y >= 0.0 && uv2.y < height)\n    {\n        float wi = width / ButtonCountX;\n        float hi = height / ButtonCountY;\n\n        float ix = 0.0;\n        float iy = 1.0;\n\n        ix = floor(uv2.x / wi);\n        uv2.x = (uv2.x / wi - ix) * wi;\n\n        iy = floor(uv2.y / hi);\n        uv2.y = (uv2.y / hi - iy) * hi;\n        iy = float(ButtonCountY) - 1.0 - iy;\n\n        uv2 -= vec2(wi, hi) * 0.5;\n\n        float buttonSizeMod = 2.0;\n        float l = length(uv2) + buttonSizeMod;\n\n        float ll = min(wi, hi) * 0.5;\n\n        float i = ix + iy * ButtonCountX;\n\n        bool isActive = int(i) == ActiveKnobMatId;\n\n        float buttonOpacity = isActive ? 1.0 : 0.5;\n        float shadowOpacity = isActive ? 0.6 : 0.4;\n\n        col.rgb = vec3(smoothstep(ll-3.0, ll-4.5, l)       * buttonOpacity , \n                   pow(smoothstep(ll    , ll-4.0, l), 2.0) * shadowOpacity, .0);\n                   \n        return i;\n    }\n    \n    return -1.0;\n}\n\nfloat KnobMatIdButtonMat(vec2 uv)\n{\n    vec4 col;\n    return KnobMatIdButtonMat(col, uv);\n}\n\n/*\nbool IsUIPixel(vec2 uv)\n{\n    vec2 uv2 = vec2(uv.x, uv.y - GetKnobMatPosY0());\n\n    float width = KnobSizeTotal * 4.0;\n    float height = 48.0;\n    if(uv.x < width && uv2.y >= 0.0 && uv2.y < height) return true;\n\n    if(uv.x < width && uv.y < GetKnobMatPosY0() && uv.y > GetKnobMatPosY1() ) return true;\n    \n    return false;\n}\n*/\n\nvoid mainImage( out vec4 col, in vec2 uv0 )\n{  \n    Resolution = iResolution;\n    \n    col = vec4(0.0);\n    vec2 uv = uv0 - 0.5;\n   \n    //col = texelFetch(iChannel0, ivec2(0), 0);\n    //if(uv.y > 5.0) return;\n    \n    int I = 0;\n    vec4 iMouseLast     = ReadVar4(I);\n    vec4 iMouseAccuLast = ReadVar4(I);\n    vec4 wasdAccuLast   = ReadVar4(I);\n    float frameAccuLast = ReadVar (I);\n    float knobVal       = ReadVar (I);\n    ActiveKnobMatId = int(ReadVar(I));\n    //float numKeyLast    = ReadVar (I);\n    \n    vec2 iMouseClick    = ReadVar2(I);\n    \n    //float numKey = \n    bool isClick = iMouseLast.z < 0.0 && iMouse.z >= 0.0;\n    \n    if(isClick) iMouseClick = iMouse.xy;\n    \n    bool shift = ReadKey(KEY_SHIFT) != 0.0;\n    \n    float kW = ReadKey(KEY_W);\n    float kA = ReadKey(KEY_A);\n    float kS = ReadKey(KEY_S);\n    float kD = ReadKey(KEY_D);\n    \n    float left  = ReadKey(KEY_LEFT);\n    float right = ReadKey(KEY_RIGHT);\n    float up    = ReadKey(KEY_UP);\n    float down  = ReadKey(KEY_DOWN);\n    \n    vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n    \n    bool didInteractUI = false;\n    \n    float knopMouseDelta = mouseDelta.y * (1.0 / 96.0 * (shift ? 0.125 : 1.0));\n     \n   // ActiveKnobMatId = ReadKeyToggle(KEY_TAB) != 0.0 ? 1 : 0;\n    if(isClick)\n    {\n        float i;\n        if((i = KnobMatIdButtonMat(iMouseClick.xy)) >= 0.0)\n        {\n            ActiveKnobMatId = int(i);\n        }\n    }\n        \n    if(uv.y >= float(KnobMatStateBuffY0) && uv.y < float(KnobMatStateBuffY0 + 4))\n    {\n        int ActiveKnobMatIdTemp = ActiveKnobMatId;\n        \n        ActiveKnobMatId = int(uint(uv.x) / 4u);\n        \n        bool IsKnobMatActuallyActive = ActiveKnobMatId == ActiveKnobMatIdTemp;\n        \n        ivec2 KnobMatStateBuffOrigin = ivec2(ActiveKnobMatId * 4, KnobMatStateBuffY0);\n    \n        KnobState knob;\n    \tif(GetKnob(ivec2(uv) - KnobMatStateBuffOrigin, iChannel0, frameAccuLast == 0.0, /*out*/ knob))\n        {\n            if(!isClick && IsKnobMatActuallyActive && knob.colId >= 0.0)\n            if(SqrLen(iMouseClick.xy - knob.p) < Pow2(knob.r.x))\n            {\n                float n = clamp(knob.n + knopMouseDelta * (knob.signed ? 2.0 : 1.0), knob.signed ? -1.0 : 0.0, 1.0);\n                //n = round(n*32.0)/32.0;\n                knobVal = knob.n = n;\n                didInteractUI = true;\n            }\n\n            col.w = knob.n;\n        }\n        \n        ActiveKnobMatId = ActiveKnobMatIdTemp;\n    }\n    \n    float knobVal0 = 0.0;\n    {\n        KnobState knob; int i;\n        if((GetKnob(iMouseClick.xy, iChannel0, /*out*/ knob).x) >= 0)\n        {\n            knobVal0 = knob.n;\n            didInteractUI = true;\n        }\n        \n        //if(uv.y != 4.0) knobVal0 = knobVal;\n    }\n    \n    {\n        KnobState state;\n        bool isKnob = GetKnob(uv0, iChannel0, frameAccuLast == 0.0, /*out*/ state).x >= 0;\n\n        if(isKnob)\n        {\n            vec3 k = Knob(uv0, state);\n            col.rgb = k;\n        }\n        \n    \tValueText(col, uv0, knobVal0);\n        //KnobMatIdButtonMat(col, uv0);\n    }\n    \n\n    \n    bool anyK = false;\n    \n    anyK = anyK || iMouse.z > 0.0;\n    anyK = anyK || shift;\n    anyK = anyK || kW != 0.0;\n    anyK = anyK || kA != 0.0;\n    anyK = anyK || kS != 0.0;\n    anyK = anyK || kD != 0.0;\n    anyK = anyK || left  != 0.0;\n    anyK = anyK || right != 0.0;\n    anyK = anyK || up    != 0.0;\n    anyK = anyK || down  != 0.0;\n    \n    \n    float frameAccu = frameAccuLast + 1.0;\n    //if(anyK) frameAccu = 0.0;\n    \n    \n    vec4 wasdAccu = wasdAccuLast;\n    wasdAccu += vec4(kW, kA, kS, kD);\n    wasdAccu += vec4(up, left, down, right);        \n    \n        \n    bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n    cond0 = cond0 && !didInteractUI;\n    \n    vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n    vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n    \n    vec4 iMouseAccu = iMouseAccuLast + vec4(mouseDelta2, mouseDelta3);\n    \n\n    \n    int J = 0;\n    WriteVar4(iMouse,       J);\n    WriteVar4(iMouseAccu,   J);\n    WriteVar4(wasdAccu,     J);\n    WriteVar(frameAccu,     J);\n    WriteVar(knobVal,       J);\n    WriteVar(float(ActiveKnobMatId), J);\n\n    WriteVar2(iMouseClick,  J);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "vec3 Resolution;\n\n#define Frame float(iFrame)\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\n/* http://keycode.info/ */\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_TAB 9\n#define KEY_CTRL 17\n#define KEY_SHIFT 16\n#define KEY_SPACE 32 \n#define KEY_A 0x41\n#define KEY_D 0x44\n#define KEY_S 0x53\n#define KEY_W 0x57\n\n#define KEY_N1 49\n#define KEY_N2 50\n#define KEY_N3 51\n#define KEY_N4 52\n#define KEY_N5 53\n#define KEY_N6 54\n#define KEY_N7 55\n#define KEY_N8 56\n\nconst float Pi = 3.14159265359;\nconst float Pi2 = Pi * 2.0;\nconst float Pi05 = Pi * 0.5;\n\nconst float RcpPi  = 1.0 / (1.0 * Pi);\nconst float RcpPi2 = 1.0 / (2.0 * Pi);\nconst float RcpPi4 = 1.0 / (4.0 * Pi);\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\nfloat Pow5(float x) {return Pow4(x)*x;}\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}   \n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\n\nfloat ddxyLen(float v) { return length(vec2(dFdx(v), dFdy(v))); }\nfloat ddxyRcpLen(float v) { return rsqrt( Pow2(dFdx(v)) + Pow2(dFdy(v)) ); }\n\n\nfloat rescale(float v) { return v * ddxyRcpLen(v); }\n\nfloat Graph(float f, float b)\n{\n    return clamp01(1.0 - (abs(rescale(f))-0.5-b)); \n}\n\n\nfloat Line(float u, float b) { return Graph(u, b); }\nfloat Lines(float u, float b) { return Graph(sin(u * Pi), b); }\n\nfloat Grid(vec2 uv, float b)\n{\n    float xl = Lines(uv.x, b);    \n    float yl = Lines(uv.y, b);\n\n    return max(xl, yl);\n}\n\nfloat Cross(vec2 uv, float b)\n{\n    float xl = Line(uv.x, b);    \n    float yl = Line(uv.y, b);\n\n    return max(xl, yl);\n}\n\nfloat Dot(vec2 sp, vec2 dp, float dr)\n{\n    float v = length(sp - dp) - dr;\n    \n    if(v > dr) return 0.0;\n    \n    v *= ddxyRcpLen(v);\n    v = 1.0 - clamp(v * 1.0, 0.0, 1.0);\n    \n    return v;\n}\n\n\nfloat Intersect_Ray_Cube(vec3 rp, vec3 rd, vec3 cth, out vec2 t)\n{\t\n\tvec3 m = 1.0 / -rd;\n\tvec3 o = If(lessThan(rd, vec3(0.0)), -cth, cth);\n\t\n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\tt.x = max(uf.x, max(uf.y, uf.z));\n\tt.y = min(ub.x, min(ub.y, ub.z));\n\t\n\tbool inside = t.x < 0.0 && t.y > 0.0;\n    \n\tif(inside) {return 0.0;}\n\t\n\treturn t.y < t.x ? -1.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\nfloat Intersect_Ray_Sphere(vec3 rp, vec3 rd, vec3 sp, float sr2, out vec2 t)\n{\t\n\trp -= sp;\n\t\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rp, rd);\n\tfloat c = dot(rp, rp) - sr2;\n\t\n\tfloat D = b*b - 4.0*a*c;\n\t\n\tif(D < 0.0) return 0.0;\n\t\n\tfloat sqrtD = sqrt(D);\n\t// t = (-b + (c < 0.0 ? sqrtD : -sqrtD)) / a * 0.5;\n\tt = (-b + vec2(-sqrtD, sqrtD)) / a * 0.5;\n\t\n\t// if(start == inside) ...\n\tif(c < 0.0) t.xy = t.yx;\n\n\t// t.x > 0.0 || start == inside ? infront : behind\n\treturn t.x > 0.0 || c < 0.0 ? 1.0 : -1.0;\n}\n\n/*\nSOURCE: \n\t\"Building an Orthonormal Basis from a 3D Unit Vector Without Normalization\"\n\t\thttp://orbit.dtu.dk/files/126824972/onb_frisvad_jgt2012_v2.pdf\n\t\t\n\t\"Building an Orthonormal Basis, Revisited\" \n\t\thttp://jcgt.org/published/0006/01/01/\n\t\n\t- modified for right-handedness here\n\t\nDESCR:\n\tConstructs a right-handed, orthonormal coordinate system from a given vector of unit length.\n\nIN:\n\tn  : normalized vector\n\t\nOUT:\n\tox\t: orthonormal vector\n\toz\t: orthonormal vector\n\t\nEXAMPLE:\n\tfloat3 ox, oz;\n\tOrthonormalBasis(N, OUT ox, oz);\n*/\nvoid OrthonormalBasisRH(vec3 n, out vec3 ox, out vec3 oz)\n{\n\tfloat sig = n.z < 0.0 ? 1.0 : -1.0;\n\t\n\tfloat a = 1.0 / (n.z - sig);\n\tfloat b = n.x * n.y * a;\n\t\n\tox = vec3(1.0 + sig * n.x * n.x * a, sig * b, sig * n.x);\n\toz = vec3(b, sig + n.y * n.y * a, n.y);\n}\n\n// s0 [-1..1], s1 [-1..1]\n// samples spherical cap for s1 [cosAng05..1]\n// samples hemisphere if s1 [0..1]\nvec3 Sample_Sphere(float s0, float s1)\n{\n    float ang = Pi * s0;\n    float s1p = sqrt(1.0 - s1*s1);\n    \n    return vec3(cos(ang) * s1p, \n                           s1 , \n                sin(ang) * s1p);\n}\n\n// s0 [-1..1], s1 [-1..1]\n// samples spherical cap for s1 [cosAng05..1]\nvec3 Sample_Sphere(float s0, float s1, vec3 normal)\n{\t \n    vec3 sph = Sample_Sphere(s0, s1);\n\n    vec3 ox, oz;\n    OrthonormalBasisRH(normal, ox, oz);\n\n    return (ox * sph.x) + (normal * sph.y) + (oz * sph.z);\n}\n\n// s0 [-1..1], s1 [-1..1]\nvec3 Sample_Hemisphere(float s0, float s1, vec3 normal)\n{\n    vec3 smpl = Sample_Sphere(s0, s1);\n\n    if(dot(smpl, normal) < 0.0)\n        return -smpl;\n    else\n        return smpl;\n}\n\n// s0 [-1..1], s1 [0..1]\nvec2 Sample_Disk(float s0, float s1)\n{\n    return vec2(cos(Pi * s0), sin(Pi * s0)) * sqrt(s1);\n}\n\n// s0 [-1..1], s1 [0..1]\nvec3 Sample_ClampedCosineLobe(float s0, float s1)\n{\t \n    vec2 d  = Sample_Disk(s0, s1);\n    float y = sqrt(clamp01(1.0 - s1));\n    \n    return vec3(d.x, y, d.y);\n}\n\n// s0 [-1..1], s1 [0..1]\nvec3 Sample_ClampedCosineLobe(float s0, float s1, vec3 normal)\n{\t \n    vec2 d  = Sample_Disk(s0, s1);\n    float y = sqrt(clamp01(1.0 - s1));\n\n    vec3 ox, oz;\n    OrthonormalBasisRH(normal, ox, oz);\n\n    return (ox * d.x) + (normal * y) + (oz * d.y);\n}\n\n// s [-1..1]\nfloat Sample_Triangle(float s) \n{ \n    float v = 1.0 - sqrt(1.0 - abs(s));\n    \n    return s < 0.0 ? -v : v; \n}\n\n// Box-Muller Transform: \n// https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform\n// u (0..1] | v [-1..1]\nvec2 Sample_Gauss2D(float u, float v)\n{\n    float l = sqrt(-2.0 * log(u));\n    \n    return vec2(cos(v * Pi), sin(v * Pi)) * l;\n}\n\n\n// http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html\nuint WeylHash(uvec2 c) \n{\n    return ((c.x * 0x3504f333u) ^ (c.y * 0xf1bbcdcbu)) * 741103597u; \n}\n\n\nuint  asuint2(float x) { return x == 0.0 ? 0u : floatBitsToUint(x); }\nuvec2 asuint2(vec2 x) { return uvec2(asuint2(x.x ), asuint2(x.y)); }\nuvec3 asuint2(vec3 x) { return uvec3(asuint2(x.xy), asuint2(x.z)); }\nuvec4 asuint2(vec4 x) { return uvec4(asuint2(x.xy), asuint2(x.zw)); }\n\nfloat Float01(uint x) { return float(    x ) * (1.0 / 4294967296.0); }\nfloat Float11(uint x) { return float(int(x)) * (1.0 / 2147483648.0); }\n\nvec2 Float01(uvec2 x) { return vec2(      x ) * (1.0 / 4294967296.0); }\nvec2 Float11(uvec2 x) { return vec2(ivec2(x)) * (1.0 / 2147483648.0); }\n\nvec3 Float01(uvec3 x) { return vec3(      x ) * (1.0 / 4294967296.0); }\nvec3 Float11(uvec3 x) { return vec3(ivec3(x)) * (1.0 / 2147483648.0); }\n\nvec4 Float01(uvec4 x) { return vec4(      x ) * (1.0 / 4294967296.0); }\nvec4 Float11(uvec4 x) { return vec4(ivec4(x)) * (1.0 / 2147483648.0); }\n\nconst uint rPhi1  = 2654435761u;\n\nconst uint rPhi2a = 3242174893u;\nconst uint rPhi2b = 2447445397u;\n\nconst uint rPhi3a = 3518319149u;\nconst uint rPhi3b = 2882110339u;\nconst uint rPhi3c = 2360945581u;\n\nconst uint rPhi4a = 3679390609u;\nconst uint rPhi4b = 3152041517u;\nconst uint rPhi4c = 2700274807u;\nconst uint rPhi4d = 2313257579u;\n\nconst uvec2 rPhi2 = uvec2(rPhi2a, rPhi2b);\nconst uvec3 rPhi3 = uvec3(rPhi3a, rPhi3b, rPhi3c);\nconst uvec4 rPhi4 = uvec4(rPhi4a, rPhi4b, rPhi4c, rPhi4d);\n\nuint  Roberts(uint  off, uint n) { return off + rPhi1 * n; }\nuvec2 Roberts(uvec2 off, uint n) { return off + rPhi2 * n; }\nuvec3 Roberts(uvec3 off, uint n) { return off + rPhi3 * n; }\nuvec4 Roberts(uvec4 off, uint n) { return off + rPhi4 * n; }\n\n#define _SEED uvec4(0xCAF0FC2Eu, 0xEA18994Au, 0x4D86D399u, 0x10EB49F0u)\n\nuvec4 PhiHash(uint  v, uint seed) { return ((v   * rPhi2a)                                                    ^ (_SEED ^ uvec4(seed))) * rPhi1; }\nuvec4 PhiHash(uvec2 v, uint seed) { return ((v.x * rPhi2a) ^ (v.y * rPhi2b)                                   ^ (_SEED ^ uvec4(seed))) * rPhi1; }\nuvec4 PhiHash(uvec3 v, uint seed) { return ((v.x * rPhi3a) ^ (v.y * rPhi3b) ^ (v.z * rPhi3c)                  ^ (_SEED ^ uvec4(seed))) * rPhi1; }\nuvec4 PhiHash(uvec4 v, uint seed) { return ((v.x * rPhi4a) ^ (v.y * rPhi4b) ^ (v.z * rPhi4c) ^ (v.w * rPhi4d) ^ (_SEED ^ uvec4(seed))) * rPhi1; }\n\nvec4 PhiHash01(float v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash01(vec2  v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash01(vec3  v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash01(vec4  v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\n\nvec4 PhiHash11(float v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash11(vec2  v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash11(vec3  v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash11(vec4  v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\n\n\nuint MixHash(uvec2 h)\n{\n    return ((h.x ^ (h.y >> 16u)) * rPhi2.x) ^ \n           ((h.y ^ (h.x >> 16u)) * rPhi2.y);\n}\n\nuint MixHash(uvec3 h)\n{\n    return ((h.x ^ (h.y >> 16u) ^ (h.z << 15u)) * rPhi3.x) ^ \n           ((h.y ^ (h.z >> 16u) ^ (h.y << 15u)) * rPhi3.y) ^\n           ((h.z ^ (h.y >> 16u) ^ (h.x << 15u)) * rPhi3.z);\n}\n\nuint MixHash(uvec4 h)\n{\n    return ((h.x ^ (h.y >> 16u) ^ (h.z << 15u)) * rPhi4.x) ^ \n           ((h.y ^ (h.z >> 16u) ^ (h.w << 15u)) * rPhi4.y) ^\n           ((h.z ^ (h.w >> 16u) ^ (h.x << 15u)) * rPhi4.z) ^\n           ((h.w ^ (h.x >> 16u) ^ (h.y << 15u)) * rPhi4.w);\n}\n\n// low bias version https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash(uint x)\n{\n    x ^= x >> 16u;\n    x *= 0x7feb352dU;\n    x ^= x >> 15u;\n    x *= 0x846ca68bU;\n    x ^= x >> 16u;\n\n    return x;\n}\n\nuvec2 WellonsHash(uvec2 h) { return uvec2(WellonsHash(h.x), WellonsHash(h.y)); }\nuvec3 WellonsHash(uvec3 h) { return uvec3(WellonsHash(h.x), WellonsHash(h.y), WellonsHash(h.z)); }\nuvec4 WellonsHash(uvec4 h) { return uvec4(WellonsHash(h.x), WellonsHash(h.y), WellonsHash(h.z), WellonsHash(h.w)); }\n\nuvec4 WellonsHash(uint  v, uint seed) { return WellonsHash(        v  ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash(uvec2 v, uint seed) { return WellonsHash(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash(uvec3 v, uint seed) { return WellonsHash(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash(uvec4 v, uint seed) { return WellonsHash(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\n\n// minimal bias version https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash2(uint x)\n{\n    x ^= x >> 17u;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11u;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15u;\n    x *= 0x31848babU;\n    x ^= x >> 14u;\n\n    return x;\n}\n\nuvec2 WellonsHash2(uvec2 h) { return uvec2(WellonsHash2(h.x), WellonsHash2(h.y)); }\nuvec3 WellonsHash2(uvec3 h) { return uvec3(WellonsHash2(h.x), WellonsHash2(h.y), WellonsHash2(h.z)); }\nuvec4 WellonsHash2(uvec4 h) { return uvec4(WellonsHash2(h.x), WellonsHash2(h.y), WellonsHash2(h.z), WellonsHash2(h.w)); }\n\nuvec4 WellonsHash2(uint  v, uint seed) { return WellonsHash2(        v  ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash2(uvec2 v, uint seed) { return WellonsHash2(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash2(uvec3 v, uint seed) { return WellonsHash2(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash2(uvec4 v, uint seed) { return WellonsHash2(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\n\n#undef _SEED\n\n\n// https://en.wikipedia.org/wiki/Linear_congruential_generator\nuint LCG(uint x) { return x * 22695477u + 1u; }\n\nfloat Hash01(inout uint h)\n{\n    h = LCG(h);\n\n    return Float01(h * rPhi1);\n}\n\nfloat Hash11(inout uint h)\n{\n    h = LCG(h);\n\n    return Float11(h * rPhi1);\n}\n\nuint HashU(inout uint h)\n{\n    h = LCG(h);\n\n    return h * rPhi1;\n}\n\nvec2 Hash01x2(inout uint h) { return vec2(Hash01(h), Hash01(h)); }\nvec3 Hash01x3(inout uint h) { return vec3(Hash01(h), Hash01(h), Hash01(h)); }\nvec4 Hash01x4(inout uint h) { return vec4(Hash01(h), Hash01(h), Hash01(h), Hash01(h)); }\n\nvec2 Hash11x2(inout uint h) { return vec2(Hash11(h), Hash11(h)); }\nvec3 Hash11x3(inout uint h) { return vec3(Hash11(h), Hash11(h), Hash11(h)); }\nvec4 Hash11x4(inout uint h) { return vec4(Hash11(h), Hash11(h), Hash11(h), Hash11(h)); }\n\nuvec2 HashUx2(inout uint h) { return uvec2(HashU(h), HashU(h)); }\nuvec3 HashUx3(inout uint h) { return uvec3(HashU(h), HashU(h), HashU(h)); }\nuvec4 HashUx4(inout uint h) { return uvec4(HashU(h), HashU(h), HashU(h), HashU(h)); }\n\n\n// ===============================================  KNOB STUFFS  =========================================================================== //\nstruct KnobState\n{\n    vec2 p;\n    vec2 r;\n    bool signed;\n    float colId;\n    \n    float n;\n};\n\nKnobState CreateKnobState(vec2 p, vec2 r, bool signed, float n)\n{\n    KnobState state;\n    state.p = p;\n    state.r = r;\n    state.signed = signed;\n    state.colId = 0.0;\n    state.n = n;\n\n    return state;\n}\n\nint ActiveKnobMatId = 0;\n\nconst int KnobMatCount = 2; \nconst int KnobMatKnobCount = 16;\nconst int KnobCount = KnobMatKnobCount * KnobMatCount;\n\nconst int KnobMatStateBuffY0 = 5;\nconst int KnobMatStaticStateBuffY0 = 9;\n\nconst float KnobOuterRadius = 16.0; \nconst float KnobCircleThick =  4.0; \nconst float KnobPadding     =  4.0; \nconst float KnobSizeTotal   =  2.0 * (KnobOuterRadius + KnobPadding);\nfloat GetKnobMatPosY0() { return Resolution.y*0.5 + (KnobSizeTotal*2.0); } \nfloat GetKnobMatPosY1() { return Resolution.y*0.5 - (KnobSizeTotal*2.0); } \n \nKnobState GetKnobOfMat(ivec2 xy, bool signed, float n, float colId)\n{\n    float x = float(xy.x);\n    float y = float(xy.y);\n    \n    KnobState knob;\n    knob.p.x = 0.5 * KnobSizeTotal + x * KnobSizeTotal;\n    knob.p.y = 0.5 * KnobSizeTotal + y * KnobSizeTotal;\n    \n    knob.p.y = GetKnobMatPosY0() - knob.p.y;\n\n    knob.r = vec2(KnobOuterRadius, KnobCircleThick);\n    knob.signed = signed;\n    knob.colId = colId;\n\n\tknob.n = n;\n    \n    return knob;\n}\n\nbool GetKnob0(ivec2 xy, sampler2D stateBuffer, out KnobState knob)\n{\n    KnobState knob0;\n    knob0.n = 1.25;\n    knob = knob0;\n    \n    if(xy.x < 0 || xy.x > 3 || \n       xy.y < 0 || xy.y > 3) return false;\n\n    if(ActiveKnobMatId < 0 || ActiveKnobMatId >= KnobMatCount) return false;\n\n    int i = xy.x + xy.y * 4;\n    \n    i += ActiveKnobMatId * KnobMatKnobCount;\n    \n    const bool fals = false;\n    const bool IsSigned[KnobCount] = bool[]\n    (\n        //========  0  ========//\n        fals, fals, fals, fals,// A\n        fals, fals, fals, fals,// B\n        fals, fals, fals, fals,// C\n        fals, fals, fals, fals,// D\n        \n        //========  1  ========//\n        fals, fals, fals, fals,// A\n        fals, fals, fals, fals,// B\n        fals, fals, fals, fals,// C\n        fals, fals, fals, fals // D\n    );\n    \n    const float DefaultValue[KnobCount] = float[]\n    (\n        //======  0  ======//\n        0.25, 0.5, 0.5, 0.0,// A \n        0.5, 0.0, 0.0, 0.0,// B \n        0.5, 0.0, 0.0, 0.0,// C \n        0.0, 0.0, 0.0, 0.0,// D \n    \n        //======  1  ======//\n        0.0, 0.0, 0.0, 0.0,// A \n        0.0, 0.0, 0.0, 0.0,// B \n        0.0, 0.0, 0.0, 0.0,// C \n        0.0, 0.0, 0.0, 0.0 // D \n    );\n    \n    const float ColId[KnobCount] = float[]\n    (\n        //======  0  ======//\n        0.0, -1.0, -1.0, -1.0,// A \n        0.0, -1.0, -1.0, -1.0,// B \n        0.0, -1.0, -1.0, -1.0,// C \n        0.0, -1.0, -1.0, -1.0,// D \n    \n        //======  1  ======//\n        0.0, 0.0, 0.0, 0.0,// A \n        0.0, 0.0, 0.0, 0.0,// B \n        0.0, 0.0, 0.0, 0.0,// C \n        0.0, 0.0, 0.0, 0.0 // D \n    );    \n    \n    knob = GetKnobOfMat(xy, IsSigned[i], DefaultValue[i], ColId[i]);\n    \n    return true;\n}\n\nbool GetKnob(ivec2 xy, sampler2D stateBuffer, bool doInit, out KnobState knob)\n{\n\tif(!GetKnob0(xy, stateBuffer, /*out*/ knob)) return false;\n\n    ivec2 KnobMatStateBuffOrigin = ivec2(ActiveKnobMatId * 4, KnobMatStateBuffY0);\n\n    if(!doInit)\n    knob.n = texelFetch(stateBuffer, KnobMatStateBuffOrigin + xy, 0).w;\n    \n    return true;\n}\n\nbool GetKnob(ivec2 xy, sampler2D stateBuffer, out KnobState knob)\n{\n    return GetKnob(xy, stateBuffer, false, knob);\n}\n\nivec2 GetKnob(vec2 uv, sampler2D stateBuffer, bool doInit, out KnobState knob)\n{\n    int x = int(floor(uv.x / KnobSizeTotal));\n    int y = int(floor((GetKnobMatPosY0() - uv.y) / KnobSizeTotal));\n    \n    if(x < 0 || x >= 4 || y < 0 || y >= 4) return ivec2(-1, -1);\n    \n    {\n    \tif(!GetKnob0(ivec2(x, y), stateBuffer, /*out*/ knob)) return ivec2(-1, -1);\n        \n        if(SqrLen(uv - knob.p) < Pow2(knob.r.x + KnobPadding))\n        {\n            ivec2 KnobMatStateBuffOrigin = ivec2(ActiveKnobMatId * 4, KnobMatStateBuffY0);\n        \n\t        if(!doInit)\n            knob.n = texelFetch(stateBuffer, KnobMatStateBuffOrigin + ivec2(x, y), 0).w;\n\n            return ivec2(x, y);\n        }\n    }\n    \n    return ivec2(-1, -1);\n}\n\nivec2 GetKnob(vec2 uv, sampler2D stateBuffer, out KnobState knob)\n{\n    return GetKnob(uv, stateBuffer, false, /*out*/ knob);\n}\n\n/*\nbool WriteKnobMatStaticStateToTexture(inout vec4 col, ivec2 uv)\n{\n    int i = uv.x;\n    int j = uv.y - KnobMatStaticStateBuffY0;\n\n    if(i < 0 || i >= KnobCount) return false;\n    if(j < 0 || j >= 3        ) return false;\n    \n    \n    const bool fals = false;\n    const bool IsSigned[KnobCount] = bool[]\n    (\n        //========  0  ========//\n        true, true, true, fals,// A\n        true, true, fals, fals,// B\n        fals, fals, true, true,// C\n        true, true, fals, fals,// D\n        \n        //========  1  ========//\n        fals, fals, fals, fals,// A\n        fals, fals, fals, fals,// B\n        fals, fals, fals, fals,// C\n        fals, fals, fals, fals // D\n    );\n    \n    const float DefaultValue[KnobCount] = float[]\n    (\n        //======  0  ======//\n        0.0, 0.0, 0.0, 0.0,// A \n        0.0, 0.0, 0.0, 0.0,// B \n        0.0, 0.0, 0.0, 0.0,// C \n       -1.0, 1.0, 0.0, 0.0,// D\n    \n        //======  1  ======//\n        0.0, 0.0, 0.0, 0.0,// A \n        0.0, 0.0, 0.0, 0.0,// B \n        0.0, 0.0, 0.0, 0.0,// C \n        0.0, 0.0, 0.0, 0.0 // D \n    );\n    \n    const float ColId[KnobCount] = float[]\n    (\n        //======  0  ======//\n        5.0, 5.0, 4.0, 4.0,// A \n        2.0, 2.0, -.1, -.1,// B \n        1.0, 1.0, 1.0, 1.0,// C \n        0.0, 0.0, -.1, -.1,// D\n    \n        //======  1  ======//\n        0.0, 0.0, 0.0, 0.0,// A \n        0.0, 0.0, 0.0, 0.0,// B \n        0.0, 0.0, 0.0, 0.0,// C \n        0.0, 0.0, 0.0, 0.0 // D \n    );  \n    \n    if(j == 0) { col.w = IsSigned[i] ? 1.0 : 0.0; }\n    if(j == 1) { col.w = DefaultValue[i]; }\n    if(j == 2) { col.w = ColId[i]; }\n    \n    return true;\n}\n    bool IsSigned2 = texelFetch(stateBuffer, ivec2(i, KnobMatStaticStateBuffY0 + 0), 0).w != 0.0;\n    float DefaultValue2 = texelFetch(stateBuffer, ivec2(i, KnobMatStaticStateBuffY0 + 1), 0).w;\n    float ColId2 = texelFetch(stateBuffer, ivec2(i, KnobMatStaticStateBuffY0 + 2), 0).w;\n    knob = GetKnobOfMat(xy, IsSigned2, DefaultValue2, ColId2);\n*/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}