{
    "Shader": {
        "info": {
            "date": "1614300308",
            "description": "See comments for details. Use mouse to scrub time.",
            "flags": 96,
            "hasliked": 0,
            "id": "WtGBW1",
            "likes": 104,
            "name": "HODL",
            "published": 3,
            "tags": [
                "crypto",
                "coin",
                "blockchain",
                "bitcoin",
                "btc",
                "nft",
                "currency"
            ],
            "usePreview": 1,
            "username": "BigWIngs",
            "viewed": 4767
        },
        "renderpass": [
            {
                "code": "// \"HODL\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// I had started a bitcoin texture a couple of years ago but\n// never finished it. With the recent bullrun I got motivated\n// again to finish it. I tried to use symmetries as much as possible\n// but in the end, its still a shitload of manual tweaks because\n// the thing really isn't as symmetrical as it looks. Oww well.\n//\n// Music: Fly Me To The Moon (prod. ibrahim) - Going Spaceward\n// https://soundcloud.com/going-spaceward/fly-me-to-the-moon\n\n//#define SHOW_COIN_TEXTURE\n//#define SHOW_BACKGROUND\n#if HW_PERFORMANCE!=0\n#define USE_AA\n#endif\n \n#define MAX_STEPS 100\n#define MAX_DIST 5.\n#define SURF_DIST .001\n\n#define S smoothstep\n\nvec3 Transform(vec3 p) {\n    vec4 pr = GetProgress(iTime, iMouse.xy/iResolution.xy);\n    \n    float a = 10.*pr.x-4.*pr.x*pr.x;\n    \n    p.xz *= Rot(pr.x*6.2832);\n    p.yz *= Rot(a*6.2832);\n    \n    return p;\n}\n\nfloat GetDist(vec3 p) {\n    \n    p = Transform(p);\n    \n    float \n        dist = length(p.xy),\n        d = dist-.5,\n        side = -sign(p.z);\n    \n    d = max(d, abs(p.z)-.03);\n   \t\n    p.x /= iResolution.x/iResolution.y;\n    \n    vec2 uv = vec2(p.x*side, p.y)+.5;\n    d -= .003*texture(iChannel0, uv).r*S(.0, .01, abs(p.z));\n    \n    float a = atan(p.x, p.y)*200.;\n    d += S(.025, .015, abs(p.z))*(sin(a)+sin(3.*a)*.25+sin(5.*a)*.0625)*.003;\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.,dS;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec4 GetNormal(in vec3 p) {\n    vec2 e = vec2(-1., 1.)*1e-3;   \n    float \n        t1 = GetDist(p + e.yxx), \n        t2 = GetDist(p + e.xxy),\n        t3 = GetDist(p + e.xyx), \n        t4 = GetDist(p + e.yyy),\n        c = .25/e.y*(t1 + t2 + t3 + t4 - 4.0*GetDist(p));\n        \n    vec3 n = normalize(e.yxx*t1 + e.xxy*t2 + e.xyx*t3 + e.yyy*t4);\n    \n    return vec4(n, c);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n        \n    return normalize(i);\n}\n\nvec3 Bg(vec3 rd, float lod) {\n    \n    lod = mix(5., 10., lod);\n    \n    vec3 \n        xy = textureLod(iChannel1, rd.xy+.5, lod).rgb,\n        xz = textureLod(iChannel1, rd.xz+.5, lod).rgb,\n        yz = textureLod(iChannel1, rd.yz+.5, lod).rgb;\n    \n    rd = abs(rd);\n    \n    return rd.x*yz + rd.y*xz + rd.z*xy+pow(rd.z*rd.z, 3.);\n}\n\nvec4 Render(vec2 frag, vec2 res) {\n    vec2 \n        uv = (frag-.5*res.xy)/res.y,\n        m = iMouse.xy/res.xy;\n    \n    vec4 pr = GetProgress(iTime, m);\n    \n    float \n        t = pr.x,\n        alpha = 0.,\n        d;\n    \n    vec3 \n        ro = vec3(0, 0, -4)*mix(.2, 1., S(.5, 0., abs(t-.5))),\n        rd = GetRayDir(uv, ro, vec3(0), 1.),\n        col=vec3(0);\n  \n    vec2 i = RaySphere(ro, rd, vec3(0), .5);\n    \n    \n    if(i.x>-1.) {\n        d = RayMarch(ro, rd);\n\n        if(d<MAX_DIST) {\n            vec3 p = ro + rd * d;\n            vec4 n = GetNormal(p);\n            vec3 r = reflect(rd, n.xyz);\n\n            p = Transform(p);\n            \n            float \n                bump = WaveletNoise(p.xy*10.,3.,2.),\n                dif = dot(n.xyz, normalize(vec3(1,2,3)))*.5+.5,\n                dirt = 1.-max(0., -n.w);\n            \n            col = Bg(r, max(0., n.w))+dif*.03;\n            col *= vec3(255,150,40)/255.; \n            col *= pow(dirt, 10.);\n            col *= mix(1., bump, .2);\n            \n            vec3 spec = vec3( pow(abs(r.y),10.) );\n            spec *= mix(vec3(1), GetBgCol(iTime)*(1.-pr.z), step(r.y, 0.));\n            col += spec;\n            \n            alpha = 1.;\n        }\n    }\n    return vec4(col, alpha);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 col = vec3(0);\n    \n    #ifdef SHOW_COIN_TEXTURE\n    col = texture(iChannel0, fragCoord.xy/iResolution.xy).rgb;\n    #else\n    #ifdef SHOW_BACKGROUND\n    col = texture(iChannel1, fragCoord.xy/iResolution.xy).rgb;\n    #else\n   \n    col = texture(iChannel1, fragCoord.xy/iResolution.xy).rgb;\n    \n    vec4 coin = Render(fragCoord, iResolution.xy);  \n    #ifdef USE_AA\n    coin += Render(fragCoord+vec2(.5,0), iResolution.xy);  \n    coin += Render(fragCoord+vec2(0,.5), iResolution.xy);  \n    coin += Render(fragCoord+vec2(.5,.5), iResolution.xy);  \n    coin /= 4.;\n    #endif\n    \n    col = mix(col, coin.rgb, coin.a);\n    #endif\n    #endif\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    // vignette\n    vec2 uv = (fragCoord.xy-iResolution.xy*.5)/iResolution.y;\n    float d = dot(uv, uv);\t\t\n    col /= d*d+1.;\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "musicstream",
                        "id": 25563,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/going-spaceward/fly-me-to-the-moon"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"HODL\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// Bitcoin texture. \n// I tried to make use of symmetries as much as possible\n// but in the end its just a lot of detail that needs to be hand coded.\n\n#define SS smoothstep\n#define sat(x) clamp(x, 0., 1.)\n\nfloat box(vec2 p, float x, float y, float z, float w, float b) {\n\tfloat \n        v = SS(x-b, x+b, p.x)*SS(z+b, z-b, p.x),\n        h = SS(y-b, y+b, p.y)*SS(w+b, w-b, p.y);\n    return v*h;\n}\n\nfloat sdBox(vec2 p, vec2 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.)) + min(max(p.x, p.y), 0.);\n}\n\nfloat cir(vec2 uv, float x, float y, float r, float w, float b) {\n\treturn SS(w+b, w-b, abs(r-length(uv-vec2(x, y))));\n}\n\nfloat r = .05;\nfloat _A(vec2 uv) {return box(uv, .1, .1, .9, .5, r)-box(uv, .2, .1, .8, .4, r)+(box(uv, .15, .5, .8, .9, r)-box(uv, .25, .5, .7, .8, r));}\nfloat _B(vec2 uv) {\n    uv.y = abs(uv.y-.5);\n    return max(min(box(uv, .1, -.1, .74, .4, r),1.-box(uv, .2, .05, .9, .3, r)), step(.675,uv.x)*cir(uv, .675, .175, .175, .05, r));\n}\nfloat _D(vec2 uv) {return box(uv, .1, .1, .9, .9, r)-box(uv, .2, .2, .8, .8, r);}\nfloat _F(vec2 uv) {return box(uv, .1, .5, .9, .9, r)-box(uv, .2, .6, 1., .8, r)+box(uv, .1, .1, .2, .5, r);}\nfloat _I(vec2 uv) {return box(uv, .1, .1, .2, .9, r);}\nfloat _L(vec2 uv) {return max(box(uv, .1, .1, .9, .2, r), box(uv, .1, .1, .2, .9, r));}\nfloat _O(vec2 uv) {return _D(uv);}\nfloat _J(vec2 uv) {return min(_O(uv), 1.-box(uv, .0, .3, .8, 1.1, r));}\nfloat _P(vec2 uv) {return box(uv, .1, .5, .9, .9, r)-box(uv, .2, .6, .8, .8, r)+box(uv, .1, .1, .2, .5, r);}\nfloat _C(vec2 uv) {return min(_O(uv), 1.-box(uv, .5, .4, 1., .6, r));}\nfloat _G(vec2 uv) {return max(min(_O(uv), 1.-box(uv, .5, .5, 1., .7, r)), box(uv, .6, .4, .9, .5, r));}\nfloat _E(vec2 uv) {return box(uv, .1, .1, .9, .9, r)-box(uv, .2, .2, 1., .8, r)+box(uv, .2, .45, .9, .55, r);}\nfloat _M(vec2 uv) {return box(uv, .1, .1, .9, .9, r)-box(uv, .2, .0, .8, .8, r)+box(uv, .45, .1, .55, .8, r);}\nfloat _N(vec2 uv) {\n    return max(box(vec2(abs(uv.x-.5),uv.y), .3, .1, .4, .9, r), \n               box(vec2(uv.x-(.9-uv.y)*.82, uv.y), .1, .1, .25, .9, r));\n}\nfloat _R(vec2 uv) {return _A(uv);}\nfloat _S(vec2 uv) {\n    float y = 1.-uv.x;\n    y = y*y*y*.15;\n    return max(min(max(box(uv, .1, .45, .9, .9, r)\n        -box(uv, .2, .55, .8, .8, r),\n        +box(uv, .8, .1, .9, .6, r)),\n        1.-box(uv, .5, .55, 1., .7, r)),\n               box(vec2(uv.x, uv.y-y), .1, .1, .9, .2, r));\n}\nfloat _T(vec2 uv) {return max(box(uv, .1, .8, .9, .9, r), box(uv, .45, .1, .55, .85, r));}\nfloat _Y(vec2 uv) {return box(uv, .1, .5, .9, .9, r)-box(uv, .2, .6, .8, 1., r)+box(uv, .45, .1, .55, .5, r);}\nfloat _Z(vec2 uv) {\n    float y = abs(uv.y-.5);\n    float x = uv.y>.5 ? uv.x : 1.-uv.x;\n    return sat(box(vec2(x, y), .1, .3, .9, .4, r)+ \n               box(vec2(uv.y-uv.x*.95+.15, uv.y), .1, .2, .25, .8, r)+\n             box(vec2(x,y), .1, .2, .2, .3, r));\n}\nfloat _dot(vec2 uv) { return SS(.3+r, .3-r, length(uv-vec2(.5)));}\nfloat _ONE(vec2 uv) {return max(max(box(uv, .2, .1, .3, .9, r), box(uv, .1, .1, .4, .2, r)),box(vec2(uv.x, uv.y-uv.x*.5), .1, .66, .26, .785, r));}\nfloat _NINE(vec2 uv) {return _P(vec2(1.-uv.x, uv.y));}\n\n#define _w if(within(uv, c+=s, .0, c+w, 1.)) e +=\n#define _d _w _dot(local(uv, c, .0, c+w, 1.));\n#define _s _w 0.;\n#define _1 _w _ONE(local(uv, c, .0, c+w, 1.));\n#define _9 _w _NINE(local(uv, c, .0, c+w, 1.));\n#define A _w _A(local(uv, c, .0, c+w, 1.));\n#define B _w _B(local(uv, c, .0, c+w, 1.));\n#define D _w _D(local(uv, c, .0, c+w, 1.));\n#define E _w _E(local(uv, c, .0, c+w, 1.));\n#define F _w _F(local(uv, c, .0, c+w, 1.));\n#define G _w _G(local(uv, c, .0, c+w, 1.));\n#define I _w _I(local(uv, c, .0, c+w, 1.)); c-=s*.75;\n#define J _w _J(local(uv, c, .0, c+w, 1.));\n#define L _w _L(local(uv, c, .0, c+w, 1.));\n#define R _w _R(local(uv, c, .0, c+w, 1.));\n#define S _w _S(local(uv, c, .0, c+w, 1.));\n#define T _w _T(local(uv, c, .0, c+w, 1.));\n#define C _w _C(local(uv, c, .0, c+w, 1.));\n#define M _w _M(local(uv, c, .0, c+w, 1.));\n#define N _w _N(local(uv, c, .0, c+w, 1.));\n#define O _w _O(local(uv, c, .0, c+w, 1.));\n#define P _w _P(local(uv, c, .0, c+w, 1.));\n#define Y _w _Y(local(uv, c, .0, c+w, 1.));\n#define Z _w _Z(local(uv, c, .0, c+w, 1.));\n\nfloat Text(vec2 uv) {\n    float \n        e = 0.,\n        c = 0.,\n        w = 1./76.,\n        s = w *.9;\n    \n    if( uv.x<.536) {\n        if(uv.x<.287) {\n            if(uv.x<.145) {\n                _1 T R O Y O Z _s _9 _9 _9 _s\n            } else {\n                c=.14;\n                F I N E _s C O P P E R _s _s\n            }\n        } else {\n            c=.287;\n            if(uv.x<.445) {\n                M J B _s M O N E T A R Y _s \n            } else {\n                c=.44;\n                M E T A L S _s _s\n            }\n        }\n    } else {\n        c = .532;\n\n        if(uv.x<.70) {\n            if(uv.x<.62) {\n                B I T C O I N _d \n            } else {\n                c = .61;\n                D I G I T A L _d\n            }\n        } else {\n            c=.687;\n\n            if(uv.x<.857) {\n                D E C E N T R A L I Z E D _d\n            } else {\n                c=.845;\n                P E E R _s T O _s P E E R\n            }\n        }\n    }\n    return e;\n}\n\nfloat DooHicky(vec2 p, float reps, float h, float w, float x1, float y1, float x2, float y2) {\n    float m = 0.;\n    vec2 lp = local(p, x1,y1,x2,y2);\n    if(lp.y>0. && lp.y<1.&&lp.x>0.&&lp.x<1.) {\n        lp.x-=.5;\n        lp.y = fract(lp.y*reps)-.5;\n        float d = sdBox(lp, vec2(h));\n        m = SS(.1,.0, d)*2.;\n        m = max(m, SS(.05, .0, abs(abs(lp.x)-.15)-w));\n    }\n    return m*.5;\n}\n\nfloat Bitcoin(vec2 uv) {\n    // https://www.shadertoy.com/view/WtGBW1\n    vec2 m = iMouse.xy/iResolution.xy;\n    //uv *= .4; uv -= (m-.5);\n    \n    float \n        e = 0., d, x, y, k, holes, rings, id;\n    r = .05;\n    \n    vec2 \n        st = vec2(atan(uv.x, uv.y)/6.283+.5, length(uv)),\n        lp, //used for local coordinates\n        p = uv;\n    \n    st.x = fract(st.x+.29);\n    if(st.y>.425 && st.y<.462) {\n     \te = Text(local(st, .0917, .425, 1., .462));\n    } else if (st.y>.472 && st.y<.5) {\n    \ty = 1.-(abs(.486-st.y)/.014);\n        e = sat(y*2.);\n    }\n    else \n    if(st.y>.4){ \n        x = fract(st.x*36.-.25);\n        y = remap01(.4, .423, st.y);\n        e = max(e, box(vec2(x, y), .15, .0, .85, 1., r));\n        e = max(e, SS(.2, .1, abs(y-.5))*.5);\n    } else { // center \n        d = sdBox(uv-vec2(-.063,-.198), vec2(.027, .1));  // bottom left\n        d = min(d, sdBox(uv-vec2(.032,-.178), vec2(.027, .12))); // bottom right\n        d = min(d, sdBox(uv-vec2(-.073,.171), vec2(.14, .028)));// top\n        d = min(d, sdBox(uv-vec2(-.04+uv.y*.2,-.18-uv.x*.03), vec2(.12, .031)));//bottom\n        d = min(d, sdBox(uv-vec2(-.07,.198), vec2(.027, .1))); // top left\n        d = min(d, sdBox(uv-vec2(.021,.198), vec2(.028, .1))); // top left\n        d = min(d, sdBox(uv, vec2(.135, .17))); // center fill\n        d = min(d, length((uv-vec2(.075, .101))*vec2(.82,1))-.098);// top arc\n        d = min(d, length((uv-vec2(.075, -.085))*vec2(.82,1))-.12);// bottom arc\n        \n        holes = length((uv-vec2(.02, .092))*vec2(.9,1))-.055;\n        holes = min(holes, sdBox(uv-vec2(-.012,.092), vec2(.034, .055)));   \n        holes = min(holes, length((uv-vec2(.04, -.084))*vec2(.8,1))-.06);\n        holes = min(holes, sdBox(uv-vec2(-.0,-.084), vec2(.045, .06)));\n        \n        d = max(d, -holes);\n \n        y = st.y*78.;\n        id = floor(y);\n        rings = fract(y)-.5;\n        \n        k = 18.\n            +step(abs(st.x-.3)-.2, 0.)\n            -step(abs(st.x-.6)-.05, 0.)*2.;\n        if(d*holes>0. && (id>k||abs(uv.x)<.05)) {\n            r = 0.;\n            // concentric circles\n            if(id>19.&&id<27. && mod(id,2.)==0.) { // resistors\n                float len = .55/(id+1.);\n                float s = remap01(20.,26., id);\n                float ph = mix(.65, .5, pow(s, .8))+.18;\n                x = fract(st.x*4.);\n                r=SS(.01, .0, abs(x-ph)-len);\n            }\n            rings = SS(.2, .0, abs(rings)-r*.2)*mix(.5, 1., r);\n            lp = uv-vec2(-.024,0);\n                \n            if(lp.y>.3&&lp.y<.35&&abs(lp.x)<.075) {\n                x = remap(.3, .35, .075, .015, uv.y);\n                k = step(0., abs(lp.x)-x);\n                rings *= k;\n                x = Min(abs(lp.x-.06), abs(lp.x-.044), abs(lp.x-.027));\n                y = Min(abs(lp.x+.033), abs(lp.x+.054), abs(lp.x+.018));\n                x = min(x, y);\n                rings += (1.-k)*SS(.003,.0, x)*.5;\n            } else if(lp.y<-.3 && lp.y>-.35) {\n                lp.x -=.008;\n                x = remap(-.3, -.35, .078, .015, uv.y);\n                k = step(0., abs(lp.x)-x);\n                rings *= k;\n                x = Min(abs(lp.x-.065), abs(lp.x-.045), abs(lp.x-.028));\n                y = Min(abs(lp.x+.032), abs(lp.x+.053), abs(lp.x+.018));\n                x = min(x, y);\n                rings += (1.-k)*SS(.003,.0, x)*.5;\n            }\n            e = max(e, rings);\n        }\n        \n        e = max(e, SS(.005, .0, abs(d)));\n        \n        // stuff in holes\n        if(holes<-.01) {\n            lp = local(uv, -.038,-.139+.006,-.022-.005,.141-.004);\n            if(lp.x>0.&& lp.x<1.&&lp.y>0.&&lp.y<1.) {\n                y = lp.y;\n                d = length(fract(lp*vec2(1,27))-.5);\n                d = SS(.3, .0, d)*step(.05, abs(abs(y-.573)-.335));\n                e = max(e, d);\n            }\n            e = max(e, DooHicky(uv, 1., .25, .01, -.032,-.137, -.008,-.114));\n            e = max(e, DooHicky(uv, 1., .25, .01, -.032,.069, -.005,.046));\n            \n            d = sdBox(uv-vec2(.045, .097), vec2(.008,.012));\n            d = min(d, sdBox(uv-vec2(-.028,.11), vec2(.001,.008))-.001);\n            \n            r = abs(sdBox(uv-vec2(-.015,.094), vec2(.03,.006))-.03)-.0005;\n            d = min(d, max(r, -uv.x-.02));\n            d = min(d, sdBox(vec2(abs(uv.x)-.012, uv.y-.113), vec2(.008,.012)));\n            \n            \n            lp = uv-vec2(.017,-.014);\n            lp.y = abs(lp.y)-.09;\n            d = min(d, sdBox(lp, vec2(.014,.004)));\n            d = max(d, -sdBox(lp, vec2(.005,.004)));\n            // lines\n            lp.x -= lp.y*.3-.01;\n            lp.y = abs(lp.y-.0016)-.007;\n            d = min(d, sdBox(lp, vec2(.028,.0)));\n            \n            x = abs(abs(uv.x-.03)-.026)-.013;\n            d = min(d, sdBox(vec2(x, uv.y+.068), vec2(.007,.011))-.003);\n           \n            r = sdBox((uv-vec2(-.015,-.083))*vec2(1,1.4), vec2(.04,.0))-.055;\n            r = max(r, uv.x-.056);\n            \n            r = abs(abs(r)-.011)-.0005;\n            d = min(d, max(r, -uv.x-.02));\n                  \n            e = max(e, SS(.003,-.002, d)); \n        }\n        \n        x = abs(abs(uv.y-.03)-.022)-.011;\n        d = sdBox(vec2(uv.x-.22, x), vec2(.013,.004))-.002; \n        d = min(d, sdBox(uv-vec2(.22, .095), vec2(.013,.015))-.002);\n        d = max(d, length(uv)-.24);\n        d = min(d, sdBox(uv-vec2(.22, .04), vec2(.001,.05))+.002);\n        e = max(e, SS(.004, .0, d));\n        \n        lp = uv-vec2(-.28,-.037);\n        \n        if(uv.x<0.) {\n            if(lp.y>.0) {\n                e *= SS(.00, .001, Line(lp,vec2(-.017,.0125),vec2(.08,.105))-.022);\n            \n                d = Line(lp,vec2(0,0),vec2(-.034,.027));\n                d = min(d, Line(lp,vec2(.026,0),vec2(-.021,.04)));\n                d = min(d, Line(lp,vec2(.026,0.025),vec2(-.008,.052)));\n                d = min(d, Line(lp,vec2(.04,0.037),vec2(.006,.065)));\n                d = min(d, Line(lp,vec2(.066,0.037),vec2(.021,.078)));\n                d = min(d, Line(lp,vec2(.068,0.062),vec2(.0365,.094)));\n                d = min(d, Line(lp,vec2(.082,0.075),vec2(.055,.112)));\n                d = min(d, Line(lp,vec2(.095,0.088),vec2(.075,.126)));\n                \n                lp.y = abs(lp.y-.135); \n                d = min(d, Line(lp,vec2(.11,.023),vec2(.14,.023)));\n                d = min(d, Line(lp,vec2(.11,.023),vec2(.097,.0)));\n            } else {\n                d = Line(lp,vec2(.015,-.013),vec2(-.026,-.033));\n                d = min(d, Line(lp,vec2(.03,-.025),vec2(-.009,-.047)));\n                d = min(d, Line(lp,vec2(.045,-.038),vec2(.01,-.063)));\n                d = min(d, Line(lp,vec2(.06,-.051),vec2(.031,-.08)));\n                d = min(d, Line(lp,vec2(.04,-.072),vec2(.045,-.08)));\n                d = min(d, Line(lp,vec2(.09,-.076),vec2(.07,-.09)));\n                d = min(d, Line(lp,vec2(.09,-.12),vec2(.07,-.09)));\n                      \n               e *= SS(.00, .001, Line(lp,vec2(.04,-.06),vec2(-.018,-.01))-.022);\n            }\n            e = max(e, SS(.003, .0, d)*.5);\n        } else {\n            if(uv.y>-.07) {\n                d = Line(uv,vec2(.38,.05),vec2(.3365,.106));\n                d = min(d, Line(uv,vec2(.36,.05),vec2(.326,.095)));\n                d = min(d, Line(uv,vec2(.362,.107),vec2(.349,.107)));\n                d = min(d, Line(uv,vec2(.347,.038),vec2(.3175,.08)));\n                d = min(d, Line(uv,vec2(.336,.026),vec2(.307,.067)));\n                d = min(d, Line(uv,vec2(.325,.014),vec2(.2965,.054)));\n                d = min(d, Line(uv,vec2(.314,.00),vec2(.286,.039)));\n                d = min(d, Line(uv,vec2(.303,-.012),vec2(.275,.024)));\n                d = min(d, Line(uv,vec2(.292,-.025),vec2(.263,.008)));\n                d = min(d, Line(uv,vec2(.28,-.037),vec2(.25,-.01)));\n                d = min(d, Line(uv,vec2(.27,-.05),vec2(.218,-.01)));\n                e *= SS(.00, .001, Line(uv,vec2(.352,.08),vec2(.255,-.05))-.028);\n            } else {\n                d = Line(uv,vec2(.237,-.115),vec2(.278,-.076));\n                d = min(d, Line(uv,vec2(.245,-.127),vec2(.288,-.088)));\n                d = min(d, Line(uv,vec2(.252,-.141),vec2(.297,-.101)));\n                d = min(d, Line(uv,vec2(.26,-.153),vec2(.306,-.114)));\n                d = min(d, Line(uv,vec2(.267,-.165),vec2(.315,-.125)));\n                e *= SS(.00, .001, Line(uv,vec2(.295,-.18),vec2(.323,-.14))-.01);\n                e *= SS(.00, .001, Line(uv,vec2(.259,-.093),vec2(.291,-.147))-.03);\n            }\n            \n            e = max(e, SS(.003, .0, d)*.5);   \n        }\n    }\n    \n     // straight lines\n    y = remap01(-.132, .082, p.y);\n    y += clamp(remap01(.45, .475, st.y),0.,1.)*.05;\n   \n    if(st.y<.475 && y>0. && y<1.) {\n        bool \n            rightSide = (p.x-.197-.19*y>.0 && p.x-.321+.16*y>.0),\n            leftSide = (p.x<-.14 && y>.05 && y<.88 && p.x+p.y*1.2>-.325 && p.x-p.y*1.1>-.24);\n    \n        if ( rightSide || leftSide) {\n            y *= 17.;\n            id = floor(y);\n            y = fract(y)-.5;\n            \n            r = 0.;\n            if(id==7.||id==9.||id==11.)\n                r = SS(.002, .0, abs(p.x-.4)-.015);\n                \n            e = SS(.2, .0, abs(y)-.2*r)*mix(.5, 1., r);\n            \n            // diagonal lines\n            d = sdBox(uv-vec2(.336,-.065), vec2(.03, .03));\n            r = SS(-.2, .2, sin((uv.x+uv.y)*250.));\n            r *= SS(.01, .0, d+.013);\n            d = SS(.003,-.002, d)*.7+r;\n            e = max(e, d); \n        }\n        \n        lp = (uv - vec2(.26,-.063))*.7;\n        d = max(sdBox(lp, vec2(.014,.004)), -sdBox(lp, vec2(.005,.004)));\n        e = max(e, SS(.003, .0, d));\n    }\n    \n    e = max(e, DooHicky(p, 5., .35, .01, -.212,.02, -.159,-.107));\n    e = max(e, DooHicky(p, 2., .35, .05, -.125,-.22, -.099,-.268));\n    e = max(e, DooHicky(p, 2., .3, .05, -.143,.12, -.17,.076));\n    e = max(e, DooHicky(p, 1., .3, .05, -.143,-.141, -.17,-.114));\n   \n    lp = vec2(p.x-step(p.y,0.)*.01, abs(p.y+.004));\n    e = max(e, DooHicky(lp, 1., .2, .02, .045,.245, .095,.205));\n    \n    lp = vec2(p.x-step(p.y,0.)*.01, abs(p.y));\n    e = max(e, DooHicky(lp, 2., .3, .02, -.045,.3, -.005,.35));\n    \n    return e;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float e = 0.;\n    \n    vec2 oldRes = texture(iChannel0, vec2(.5)/iResolution.xy).rg;\n    \n    if(oldRes.x!=iResolution.x)\n        e = Bitcoin((fragCoord.xy-.5*iResolution.xy) / iResolution.y);   \n    else\n        e = texture(iChannel0, fragCoord.xy/iResolution.xy).r;\n    \n    if(fragCoord == vec2(1,1))\n        fragColor = vec4(iResolution.xy, 0,0);\n    else    \n        fragColor = vec4(e);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// \"HODL\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// Background layer. See my tutorial about this here:\n// https://www.youtube.com/watch?v=3CycKKJiwis\n\n#define S smoothstep\n#define NUM_LAYERS 4.\n\nvec2 GetPos(vec2 id, vec2 offs, float t) {\n    float \n        n = N21(id+offs),\n        n1 = fract(n*10.),\n        n2 = fract(n*100.),\n        a = t+n;\n        \n    return offs + vec2(sin(a*n1), cos(a*n2))*.4;\n}\n\nfloat Connect(vec2 a, vec2 b, vec2 uv, float t) {\n    t = .5-abs(t-.5);\n    float \n        d = Line(uv, a, b),\n        d2 = length(a-b),\n        fade = S(1.5, .5, d2+t)*S(.9,.6, t*2.),\n        r = 6./iResolution.y;\n    \n    return S(r, 0., d)*fade;\n}\n\nfloat NetLayer(vec2 st, float n, float T) {\n    vec2 \n        id = floor(st)+n,\n        p[9];\n\n    float \n        t = iTime+10.,\n        m=0., d, s,\n        pulse, sparkle=0.;\n    \n    st = fract(st)-.5;\n    \n    int i=0;\n    for(float y=-1.; y<=1.; y++) {\n    \tfor(float x=-1.; x<=1.; x++) {\n            p[i++] = GetPos(id, vec2(x,y), t);\n    \t}\n    }\n    \n    for(int i=0; i<9; i++) {\n        m += Connect(p[4], p[i], st, T);\n\n        d = length(st-p[i]);\n\n        s = (.005/(d*d));\n        s *= S(1., .7, d);\n        pulse = sin((fract(p[i].x)+fract(p[i].y)+t)*5.)*.4+.6;\n        pulse = pow(pulse, 20.);\n\n        s *= pulse;\n        sparkle += s;\n    }\n    \n    m += Connect(p[1], p[3], st, T);\n\tm += Connect(p[1], p[5], st, T);\n    m += Connect(p[7], p[5], st, T);\n    m += Connect(p[7], p[3], st, T);\n    m += sparkle*S(.05, .5, abs(T-.5));\n    \n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float \n        t, y, m = 0., r, d, glow, moon;\n        \n    vec2 \n        uv = (fragCoord-iResolution.xy*.5)/iResolution.y,\n        M = iMouse.xy/iResolution.xy,\n        st = uv,\n        offs = vec2(0, -y*300.);\n    \n    vec4 p = GetProgress(iTime, M);\n    t = p.x;\n    y = p.z;\n    offs.y = -p.w;\n    \n    for(float i=0.; i<1.; i+=1./NUM_LAYERS) {\n        float \n            size = mix(15., 1., i),\n            fade = S(0., .6, i)*S(1., .8, i);\n            \n        m += fade * NetLayer(st*size-offs, i, t);\n    }\n\t\n    vec3 \n        baseCol = GetBgCol(iTime),\n        col = baseCol*m*.2;\n    \n    glow = max(0., -t*(1.-t)*4.+.5-uv.y);\n    col += baseCol*(exp(offs.y/10.)+glow*glow);\n    \n    y = remap01(1., .92, y);\n    r = .12;\n    st = uv-vec2(0, y);\n    d=length(st);\n    moon = S(.002, -.002, d-r);\n    glow = S(.0,.01,  y)*.0005/(d*d*d);\n    glow = mix(glow, .4, moon);\n    if(d<r) {\n        r = .135; \n        moon *= WaveletNoise(st*5./(sqrt(r*r-d*d)/r), .1, 2.)*.5+.5;\n    }\n    col += moon+glow;\n    \n    fragColor = vec4(min(col,vec3(1)),1);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "float remap01(float a, float b, float t) {\n\treturn (t-a)/(b-a);\n}\n\nfloat remap(float a, float b, float c, float d, float t) {\n    return ((t-a)/(b-a))*(d-c)+c;\n}\n\nvec2 local(vec2 uv, float x1, float y1, float x2, float y2) {\n\treturn vec2(uv.x-x1, uv.y-y1)/vec2(x2-x1, y2-y1);\n}\nvec2 local(vec2 uv, vec4 p) { return local(uv, p.x, p.y, p.z, p.w);}\n\nbool within(vec2 uv, float x1, float y1, float x2, float y2) {\n\treturn uv.x>x1&&uv.x<x2&&uv.y>y1&&uv.y<y2;\n}\nbool within(vec2 uv, vec4 p) {\n    return within(uv, p.x, p.y, p.z, p.w);\n}\nfloat Line(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 \n        pa = p - a, \n        ba = b - a;\n        \n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\n\t\n    return length(pa - ba * h);\n}\n\nfloat N21(vec2 p) {\n\tvec3 a = fract(vec3(p.xyx) * vec3(213.897, 653.453, 253.098));\n    a += dot(a, a.yzx + 79.76);\n    return fract((a.x + a.y) * a.z);\n}\n\nvec2 RaySphere(vec3 ro, vec3 rd, vec3 s, float r) {\n    float t = dot(s-ro, rd);\n    vec3 p = ro+rd*t;\n    float y = length(s-p);\n    if(y<r) {\n        float x = sqrt(r*r-y*y);\n        return vec2(t-x, t+x);\n    }\n    return vec2(-1, -1);\n}\n\nvec4 GetProgress(float T, vec2 M) {\n    T += M.x/.03; \n    float \n        t = fract(T*.03),\n        y = t*(1.-t)*4.;\n    return vec4(t, 1.-abs(t-.5)*2., y, y*75.);\n}\n\nvec3 GetBgCol(float T) {\n    return vec3(1., .7, .2).brg;\n}\n\nfloat WaveletNoise(vec2 p, float z, float k) {\n    // https://www.shadertoy.com/view/wsBfzK\n    float d=0.,s=1.,m=0., a;\n    for(float i=0.; i<4.; i++) {\n        vec2 q = p*s, g=fract(floor(q)*vec2(123.34,233.53));\n    \tg += dot(g, g+23.234);\n\t\ta = fract(g.x*g.y)*1e3;// +z*(mod(g.x+g.y, 2.)-1.); // add vorticity\n        q = (fract(q)-.5)*mat2(cos(a),-sin(a),sin(a),cos(a));\n        d += sin(q.x*10.+z)*smoothstep(.25, .0, dot(q,q))/s;\n        p = p*mat2(.54,-.84, .84, .54)+i;\n        m += 1./s;\n        s *= k; \n    }\n    return d/m;\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Min(float a, float b, float c) {\n  return min(a, min(b, c));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}