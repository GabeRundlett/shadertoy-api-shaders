{
    "Shader": {
        "info": {
            "date": "1722458788",
            "description": "Based on a reference picture I took in Gran Canaria a few years back. ( https://flic.kr/p/2q7sunn )",
            "flags": 0,
            "hasliked": 0,
            "id": "XfByzG",
            "likes": 10,
            "name": "Hazy Sunset",
            "published": 3,
            "tags": [
                "2d",
                "sunset",
                "fog",
                "mountains"
            ],
            "usePreview": 0,
            "username": "draradech",
            "viewed": 278
        },
        "renderpass": [
            {
                "code": "const vec3 colSun   = vec3(.99, .90, .70);\nconst vec3 colSky   = vec3(.45, .30, .20);\nconst vec3 colFront = vec3(.05, .03, .01);\nconst vec3 colBack  = vec3(.37, .28, .20);\n\nconst float numLayers = 10.;\nconst float yOffset = -.7;\nconst float layerOffset = .08;\nconst float layerScaleFactor = .8;\nconst float grainStrength = .07;\n\nconst float maxHeight = max(1. + yOffset, pow(layerScaleFactor, numLayers - 1.) + layerOffset * (numLayers - 1.) + yOffset);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    \n    float hitLayer = 0.;\n    float distanceScale = 1.;\n    for (float curLayer = 0.; uv.y < maxHeight && curLayer < numLayers; curLayer++)\n    {\n        float xPos = uv.x / distanceScale + .4 * iTime;\n        float octaves = 9. - curLayer / 3.;\n        float seed = curLayer;\n        float height = distanceScale * octaveNoise1D(xPos, seed, octaves);\n        height += yOffset + layerOffset * curLayer;\n        if (uv.y < height)\n        {\n            hitLayer = curLayer + 1.;\n            break;\n        }\n        distanceScale *= layerScaleFactor;\n    }\n    \n    vec3 col;\n    if (hitLayer == 0.)\n    {\n        vec2 sun = vec2(-.5, 1.);\n        float d = distance(sun, uv) * 2.;\n        float bright = 1. / d;\n        col = mix(colSky, colSun, bright);\n    }\n    else\n    {\n        col = mix(colFront, colBack, hitLayer / numLayers);\n    }\n\n    col += grainStrength * hash31(vec3(fragCoord, iTime));\n    fragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ################### hash implementations ###################\n\n// https://www.pcg-random.org/\nuint pcg(uint v)\n{\n\tuint state = v * 747796405u + 2891336453u;\n\tuint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n\treturn (word >> 22u) ^ word;\n}\n\nuvec2 pcg2d(uvec2 v)\n{\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    return v;\n}\n\n// http://www.jcgt.org/published/0009/03/02/\nuvec3 pcg3d(uvec3 v) {\n\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    v ^= v >> 16u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    return v;\n}\n\n// http://www.jcgt.org/published/0009/03/02/\nuvec4 pcg4d(uvec4 v)\n{\n    v = v * 1664525u + 1013904223u;\n    \n    v.x += v.y*v.w;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    v.w += v.y*v.z;\n    \n    v ^= v >> 16u;\n    \n    v.x += v.y*v.w;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    v.w += v.y*v.z;\n    \n    return v;\n}\n\n// Integer Hash - I\n// - Inigo Quilez, Integer Hash - I, 2017\n//   https://www.shadertoy.com/view/llGSzw\nuint iqint1(uint n)\n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n\n    return n;\n}\n\n// Integer Hash - II\n// - Inigo Quilez, Integer Hash - II, 2017\n//   https://www.shadertoy.com/view/XlXcW4\nuvec3 iqint2(uvec3 x)\n{\n    const uint k = 1103515245u;\n\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n\n    return x;\n}\n\n// Integer Hash - III\n// - Inigo Quilez, Integer Hash - III, 2017\n//   https://www.shadertoy.com/view/4tXyWN\nuint iqint3(uvec2 x)\n{\n    uvec2 q = 1103515245U * ( (x>>1U) ^ (x.yx   ) );\n    uint  n = 1103515245U * ( (q.x  ) ^ (q.y>>3U) );\n\n    return n;\n}\n\n\n\n// ################### float versions with consistent naming scheme ###################\n\nvec4  pcg44(vec4  p) {return  vec4( pcg4d( floatBitsToUint(p) ) ) / float(0xffffffffu);}\nvec3  pcg33(vec3  p) {return  vec3( pcg3d( floatBitsToUint(p) ) ) / float(0xffffffffu);}\nvec2  pcg22(vec2  p) {return  vec2( pcg2d( floatBitsToUint(p) ) ) / float(0xffffffffu);}\nfloat pcg11(float p) {return float(   pcg( floatBitsToUint(p) ) ) / float(0xffffffffu);}\n\nvec3  iq33(vec3  p) {return  vec3( iqint2( floatBitsToUint(p) ) ) / float(0xffffffffu);}\nfloat iq21(vec2  p) {return float( iqint3( floatBitsToUint(p) ) ) / float(0xffffffffu);}\nfloat iq11(float p) {return float( iqint1( floatBitsToUint(p) ) ) / float(0xffffffffu);}\n\n\n\n// ################### decide which hashes to use ###################\n\nfloat hash11(float p)\n{\n    //return pcg33(vec3(p)).x;\n    return pcg11(p);\n    //return iq11(p);\n}\n\nfloat hash31(vec3 p)\n{\n    return pcg33(p).x;\n    //return iq33(p).x;\n}\n\n\n\n// ################### functions using hashes ###################\n\nfloat octaveNoise1D(float pos, float seed, float octaves)\n{\n    float result = 0.;\n    float divisor = 0.;\n    float octaveScale = 1.;\n    float offset = 63.949 * seed;\n    for (float i = 0.; i < octaves; i++)\n    {\n        divisor += 1. * octaveScale;\n        float posLeft = floor(pos + offset);\n        float posRight = posLeft + 1.;\n        float rightFactor = fract(pos + offset);\n        float noiseLeft = hash11(posLeft) * octaveScale;\n        float noiseRight = hash11(posRight) * octaveScale;\n        result += mix(noiseLeft, noiseRight, smoothstep(0., 1., rightFactor));\n        octaveScale *= .5;\n        pos *= 2.;\n    }\n    return result / divisor;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}