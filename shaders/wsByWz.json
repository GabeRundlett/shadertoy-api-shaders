{
    "Shader": {
        "info": {
            "date": "1586419260",
            "description": "random gradients at nodes (dash)\nare multiplied by a (blue) smooth interpolation kernel ( -> red/pink, green/cyan)\nand summed to form the smooth noise function (white), \nmuch like base functions in Finite Elements Method used to form the smooth solution.",
            "flags": 0,
            "hasliked": 0,
            "id": "wsByWz",
            "likes": 13,
            "name": "Perlin/gradient noise explained",
            "published": 3,
            "tags": [
                "noise",
                "perlin",
                "gradient",
                "tuto",
                "short",
                "wavelet",
                "finiteelements",
                "functionbase"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 860
        },
        "renderpass": [
            {
                "code": "#define hash(p)   ( 2.* fract(sin( (p) * 78.233 ) * 43758.5453) -1. )\n                                                                // interpolation kernel\nfloat P(float x)  { x = clamp(x,0.,1.); return x*x*(3.-2.*x); } // = smoothstep, BTW ;-)\n\n#define draw(v,w)   max(0., w - abs(v-U.y) / fwidth(v-U.y) )    // antialiased curve y = v(x)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float Z = 1.;\n    vec2 R = iResolution.xy,\n         U = Z * ( 2.*u - R ) / R.y; \n    \n    float x = U.x + 0.*iTime, \n          i = floor(x), f = fract(x),                   // node id, local coord in cell\n         g0 = hash(i),                                  // random slopes at nodes\n         g1 = hash(i+1.),\n         K0 = P(1.-f),                                  // gradients (i.e. tangents)\n         K1 = P(f),\n         P0 = g0* f     * K0,                           // gradients * kernels\n         P1 = g1*(f-1.) * K1,\n          d = sin(62.28*f),                             // for dashs (applied to gradients)\n         c0 = max( draw(P0,1.), draw(g0* f    ,.7) *d ),// left curve + gradient in cell\n         c1 = max( draw(P1,1.), draw(g1*(f-1.),.7) *d ),// right curve + gradient in cell\n#define C(i) mod(floor((i)/2.),2.)\n          c = C(i)*c0 + C(i+1.)*c1                      // to visually separate neighbor wavelets\n              + max( draw(K0,.7) , draw(K1,.7 ));\n    \n    O = mod(i,2.) == 0.                                 // for consistant wavelet coloring \n        ? vec4( c0, c1, c, 1 )                          // draw wavelets ( in red &  green \n        : vec4( c1, c0, c, 1 );                         // + blue tint to separate from neighbors )\n    O += draw( P0+P1, 1.5 )                             // reconstructed smooth noise function\n      +  float( floor(u-R/2.).y == 0.) *d               // axis\n      + max(0., 5.-R.y/Z/2.* length( vec2(fract(x+.5)-.5, U.y)) ); // nodes\n    //+ .2* step(abs(U.y),1.);                          // [-1,1] range in grey\n    \n    O = pow(O, vec4(1./2.2) );                          // to sRGB\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}