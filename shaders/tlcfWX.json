{
    "Shader": {
        "info": {
            "date": "1613566769",
            "description": "A brute force AO.",
            "flags": 0,
            "hasliked": 0,
            "id": "tlcfWX",
            "likes": 12,
            "name": "AO (Ambient Occlusion)",
            "published": 3,
            "tags": [
                "raytracing",
                "raycast",
                "ao"
            ],
            "usePreview": 0,
            "username": "moranzcw",
            "viewed": 1551
        },
        "renderpass": [
            {
                "code": "// AO (Ambient Occlusion) - by moranzcw - 2021\n// Email: moranzcw@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define Epsilon 1e-2\n#define PI 3.14159265359\n#define Samples 48.0\n#define AOradius 2.5\n\n// --------------------------------------\n// oldschool rand() from Visual Studio\n// --------------------------------------\nint   seed = 1;\nvoid  srand(int s ) { seed = s; }\nint   rand(void)  { seed=seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\n// --------------------------------------\n// hash by Hugo Elias\n// --------------------------------------\nint hash( int n ) { n=(n<<13)^n; return n*(n*n*15731+789221)+1376312589; }\n\nstruct Ray \n{ \n    vec3 origin, direction;\n};\n\nstruct Sphere \n{\n\tfloat radius;\n\tvec3 position;\n};\n\nSphere spheres[4];\n\nvoid initSpheres()\n{\n    spheres[0] = Sphere(0.5, vec3(-1.7, 0.5, -1.6));\n    spheres[1] = Sphere(1.0, vec3(1.8, 1.0, -0.5));\n    spheres[2] = Sphere(2.0, vec3(0.0, 2.0, -2.8));\n    spheres[3] = Sphere(1000.0, vec3(0.0, -1000.0, 0.0));\n}\n\nfloat intersect(Sphere sphere, Ray ray)\n{\n\tvec3 op = sphere.position - ray.origin;\n\tfloat t1, t2 = Epsilon;\n    float b = dot(op, ray.direction);\n    float det = b * b - dot(op, op) + sphere.radius * sphere.radius;\n    \n\tif (det < 0.0)\n        return 0.0;\n    else\n        det = sqrt(det);\n    \n    t1 = b - det;\n    t2 = b + det;\n    if(t1 > Epsilon)\n        return t1;\n    if(t2 > Epsilon)\n        return t2;\n    return 0.0;\n}\n\nRay cameraRay(vec3 camPosition, vec3 lookAt, vec2 fragCoord)\n{\n    vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n\n    vec3 cz = normalize(lookAt - camPosition);\n\tvec3 cx = normalize(cross(cz, vec3(0.0, 1.0, 0.0)));\n\tvec3 cy = normalize(cross(cx, cz));\n    \n    return Ray(camPosition, normalize(0.53135 * (iResolution.x/iResolution.y*uv.x * cx + uv.y * cy) + cz));\n}\n\nvec3 hemiSpherePoint(vec3 normal)\n{\n    float theta = 2.0 * PI * frand();\n    float cosPhi = frand();\n    float sinPhi = sqrt(1.0-cosPhi*cosPhi);\n    \n    vec3 zAxis = normal;\n    vec3 xAxis = normalize(cross(normal, vec3(1.0, 0.0, 0.0)));\n    vec3 yAxis = normalize(cross(normal, xAxis));\n    \n    vec3 x = cos(theta) * xAxis;\n    vec3 y = sin(theta) * yAxis;\n    vec3 horizontal = normalize(x + y) * sinPhi;\n    vec3 z = cosPhi * zAxis;\n    vec3 p = horizontal + z;\n    \n    return p;\n}\n\nfloat AO(vec3 point, vec3 normal)\n{\n    float li = 0.0;\n    float count = 0.0;\n    for(float i=0.0; i<Samples; i++)\n    {\n        Ray ray = Ray(point, hemiSpherePoint(normal));\n        \n        float t = 1e10;\n        for(int i=0; i<4; i++)\n        {\n            float temp = intersect(spheres[i], ray);\n            t = step(Epsilon, temp) * min(temp, t) + step(temp, Epsilon) * t;\n        }\n        li += dot(ray.direction, normal) * smoothstep(0.0, AOradius, t);\n        count += dot(ray.direction, normal);\n    }\n    return sqrt(li / count);\n}\n\nvec3 background(float yCoord) \n{\t    \n    return mix(vec3(0.1515, 0.2375, 0.5757), vec3(0.0546, 0.0898, 0.1953), yCoord);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    // init random seed\n    ivec2 q = ivec2(fragCoord);\n    srand( hash(q.x+hash(q.y+hash(1117*iFrame))));\n    \n    // init spheres\n    initSpheres();\n    \n    // camera ray\n    vec3 camPosition = mix(vec3(-2.0, 3.0, 6.0), vec3(2.0, 3.0, 6.0), sin(iTime*0.3));\n    vec3 lookAt = vec3(0.0, 2.0, 0.0);\n    Ray ray = cameraRay(camPosition, lookAt, fragCoord);\n    \n\tvec3 color=vec3(0.0);\n    \n    // intersect\n    float t = 1e10;\n    int id;\n    float hitAnything = 0.0;\n    for(int i=0; i<4; i++)\n    {\n        float temp = intersect(spheres[i], ray);\n        if(temp > Epsilon && temp < t)\n        {\n            t = temp;\n            id = i;\n            hitAnything = 1.0;\n        }\n    }\n    \n    // AO\n    float ao = 0.0;\n    if(hitAnything > 0.0)\n    {\n        vec3 point = ray.origin + t * ray.direction;\n        vec3 normal = normalize(point - spheres[id].position);\n        ao = AO(point, normal);\n    }\n    \n    color = mix(background(fragCoord.y/iResolution.y), vec3(.9)*ao, 1. - smoothstep(0., .99, t*t/1e3));;\n    \n    color = pow(color,vec3(1.0/2.2)); // gamma\n\tfragColor = vec4(color, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}