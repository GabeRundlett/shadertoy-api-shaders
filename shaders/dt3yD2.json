{
    "Shader": {
        "info": {
            "date": "1699646571",
            "description": "un lancer de rayon simple sur des objets géométriques, la texture des\nobjets à l’aide de procédures, les équations d’éclairement,  des\nmodèles d’éclairement plus complexes prenant en compte la réflexion, et l’occlusion ambiante.",
            "flags": 0,
            "hasliked": 0,
            "id": "dt3yD2",
            "likes": 0,
            "name": "Ray Tracing - M1 Info",
            "published": 3,
            "tags": [
                "lyon1",
                "chargueericgalin"
            ],
            "usePreview": 1,
            "username": "Josephir",
            "viewed": 168
        },
        "renderpass": [
            {
                "code": "// IMAGE - M1 INFO\n/* VERY IMPORTANT !!\n\n    - TO CHANGE SCENES, PLEASE DO SO IN INTERSECT(), YOU CAN CALL ALL THE OTHER SCENES FROM THERE !! \n\n    - TO SEE THE AMBIENT OCCLUSION PLEASE COMMENT THE LINE `x = Hit(1000., vec3(0), -1);` in Shade()\n    AND DECOMMENT IT IN INTERSECT().\n\n    - IN COLOR() YOU CAN PLAY AROUND WITH THE NUMBER OF SCENE LIGHTS.\n\n    - TO MAKE GOURSAT STOP GROWING REPLACE `+ 3.5 * cos(iTime) + 14.5` WITH  ` + 11.8`\n\n    - TO MAKE OCTAEDER AND PIPECONNECTOR STOP GROWING REPLACE `+ cos(iTime) * 67.5 - 82.5` WITH `-25.`\n*/ \n\n#define MAX_REFLECTION 5\n\n// Definition of primitives\nstruct Sphere {\n    vec3 center;// Center\n    float radius;// Radius\n    int id;// Texture Id\n};\n\nstruct Ellipsoid {\n    vec3 center;// Center\n    vec3 radius;// Radius\n    int id;// Texture Id\n};\n\nstruct Cylinder {\n    vec3 bottomCenter;// Bottom Center\n    vec3 topCenter;// Top Center\n    float radius;// Radius\n    int id;// Texture Id\n};\n\nstruct Disc {\n    vec3 normal;// Normal\n    vec3 point;// Center\n    float radius;// Radius\n    int id;// Texture Id\n};\n\nstruct Capsule {\n    vec3 bottomCenter;// Bottom Center\n    vec3 topCenter;// Top Center\n    float radius;// Radius\n    int id;// Texture Id\n};\n\nstruct Box {\n    vec3 bottomCorner;// First Corner\n    vec3 topCorner;// Second Corner\n    int id;// Texture Id\n};\n\nstruct Torus {\n    vec3 center;// Center\n    float bigRadius;// Radius between center and the donut cirlce\n    float smallRadius;// Radius between the donut circle and the outer circle\n    int id;// Texture Id\n};\n\nstruct Goursat {\n    vec3 center;// Center\n    int id;// Texture Id\n};\n\nstruct Octaeder {\n    vec3 center;// Center\n    int id;// Texture Id\n};\n\nstruct PipeConnector {\n    vec3 center;// Center\n    int id;// Texture Id\n};\n\nstruct Plane {\n    vec3 normal;// Normal\n    vec3 point;// Point\n    int id;// Texture Id\n};\n\nstruct Hit {\n    float t;// Intersection depth\n    vec3 normal;// Normal\n    int id;// Texture Id\n};\n\nstruct Ray {\n    vec3 origin;// Origin\n    vec3 direction;// Direction\n    bool isHomo;// Homothetie boolean\n    bool isRot;// Rotation boolean\n};\n\nstruct Light {\n    vec3 lightColor;//color\n    vec3 lightPos;//position\n};\n\nstruct Scene {\n    //for transformation ray( translation, homo, rotation )\n    Ray tabRay[10];\n    vec3 tabScale[10];\n    vec3 tabAngle[10];\n\n    int nbSphere;// Number of displayed Spheres in the Scene\n    Sphere tabSphere[10];// Array of Spheres\n    Plane plane;// Plane of the Scene\n\n    int nbEllipsoid;// Number of displayed Ellipsoide in the Scene\n    Ellipsoid tabEllipsoid[10];// Array of Ellipsoides\n\n    int nbCylinder;// Number of displayed Cylinder in the Scene\n    Cylinder tabCylinder[10];// Array of Cylinders\n\n    int nbCapsule;// Number of displayed Capsule in the Scene\n    Capsule tabCapsule[10];// Array of Capsules\n\n    int nbBox;// Number of displayed Box in the Scene\n    Box tabBox[10];// Array of Boxes\n\n    int nbTorus;// Number of displayed Torus in the Scene\n    Torus tabTorus[10];// Array of Torus\n\n    int nbGoursat;// Number of displayed EL Goursat in the Scene\n    Goursat tabGoursat[10];// Array of EL Goursat\n\n    int nbOctaeder;// Number of displayed Octaeder in the Scene\n    Octaeder tabOctaeder[10];// Array of Octaeders\n\n    int nbPipeConnector;// Number of displayed PipeConnector in the Scene \n    PipeConnector tabPipeConnector[10];// Array of PipeConnector\n\n    int nbLight;// Number of displayed Light sources in the Scene\n    Light tabLight[25];// Array of Light sources\n};\n\nstruct Material {\n    vec3 diffuse;// Diffuse\n    vec3 ambient;//ambiant\n    vec3 specular;//specular\n    float coefShininess; // reflection coef\n    float reflexivity; // reflexivity du materiel\n    vec3 mirrorColor; // couleur du miroir\n};\n\n//////////////////////////////////////////////////////////////////////////\n//Texturing\n\n/**\n * @brief fonctions using for checkerboard Texture\n * \n * @param vec2 p \n * @return float \n */\nfloat Checkers(in vec2 p) {\n    // Filter kernel\n    vec2 w = fwidth(p)+.001;\n    // Box box filter\n    vec2 i = 2. * (abs(fract((p-.5*w)*.5)-.5)-abs(fract((p+.5*w)*.5)-.5))/w;\n    // xor pattern\n    return 0.5 - 0.5 * i.x * i.y;\n}\n\n/**\n * @brief Compute point on ray\n * \n * @param Ray ray \n * @param float t \n * @return vec3 \n */\nvec3 Point(Ray ray,float t) {\n    return ray.origin + t * ray.direction;\n}\n\n/**\n * @brief Hashing function\n * \n * @param p : Vector in space\n * @return float : a random number in [-1,1]\n */\nfloat Hash(in vec3 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n/**\n * @brief Procedural value noise with cubic interpolation\n * \n * @param p : Point \n * @return float : a random coefiscient\n */\nfloat Noise(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(mix(mix( Hash(i+vec3(0,0,0)), \n                        Hash(i+vec3(1,0,0)),f.x),\n                   mix( Hash(i+vec3(0,1,0)), \n                        Hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( Hash(i+vec3(0,0,1)), \n                        Hash(i+vec3(1,0,1)),f.x),\n                   mix( Hash(i+vec3(0,1,1)), \n                        Hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n/**\n * @brief Sum of Noize\n * \n * @param p : Point\n * @param waveLength : Controls the size of noise patterns\n * @param coef : Coefficient for noise calculation\n * @param iterations : Number of iterations for noise summation\n * @return float : Resulting turbulence value\n */\nfloat Turbulence(in vec3 p, float waveLength, float coef, int iterations) {// somme de bruits \n    float turbulence = coef * Noise(p / waveLength);\n    for (int i = 0; i < iterations; i++) { //boucle pour calculer la somme de bruit\n        coef = coef * 0.5;\n        waveLength = waveLength * 0.5;\n        turbulence = turbulence + coef * Noise(p / waveLength);\n    }\n    return turbulence;\n}\n\n/**\n * @brief convert a float into the type int\n * \n * @param a : Float\n * @return int \n */\nint convert(float a){\n    if (a < 0.0) {\n        a= a - 1.0;\n    }\n    return int(a);\n}\n\n/**\n * @brief Texture of a checkerboard\n * \n * @param point : Point in the space\n * @param color1 : First color of the checkerboard\n * @param color2 : Second color of the checkerboard\n * @return vec3 : Resulting texture\n */\nvec3 Checkboard(vec3 point, vec3 color1, vec3 color2 ){\n    vec3 w = fwidth(point) +.001;\n    int x = convert(point.x);    //convertion en entier\n    int y = convert(point.y);    //correction partie entière des valeurs négatifs pour evité le cas de int(0.4)=int(-0.4)\n    int z = convert(point.z);\n\n        if ((x + y + z) % 2 == 0) {//modulo 2 pour faire 2 cas: coordonées paire, coordonées impaire\n        return color1 / w;\n    } else {\n        return color2 / w;\n    }   \n}\n\n/**\n * @brief Texture of a marble\n * \n * @param point : Point in the space\n * @param color1 : First material of the marble\n * @param color2 : Second material of the marble\n * @return Material : Resulting Marble\n */\nMaterial MarbleTexture(vec3 point, Material color1, Material color2) {\n    point = point + Turbulence(point, 1., 20., 10);\n    float t = cos(point.x);\n    Material finalColor = Material(color1.diffuse * t + color2.diffuse * (0.6 - t), vec3(0.2), color1.specular * t + color2.specular * (1.0 - t), 50., 0., vec3(0.));\n    return finalColor;\n}\n\n/**\n * @brief Texture of a Veins marble\n * \n * @param point : Point in the space\n * @param color1 : Vein material of the marble\n * @param color2 : back material of the marble\n * @return Material : Resulting Veins Marble\n */\nMaterial VeinMarbleTexture(vec3 point, Material color1, Material color2) {\n    point = point + Turbulence(point, 5., 5., 10);\n    float t = tan(point.x*3.);\n    if(t < 4.) {\n        return color1;\n    } \n    else {\n        return color2;\n    }\n}\n\n// Source : https://www.shadertoy.com/view/wl3czM\nfloat n21(vec2 p) {\n\tconst vec3 s = vec3(7, 157, 0);\n\tvec2 h,\n\t     ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\th = s.zy + dot(ip, s.xy);\n\th = mix(fract(sin(h) * 43.5453), fract(sin(h + s.x) * 43.5453), p.x);\n\treturn mix(h.x, h.y, p.y);\n}\n\n// Source : https://www.shadertoy.com/view/wl3czM\nfloat n11(float p) {\n\tfloat ip = floor(p);\n\tp = fract(p);\n\tvec2 h = fract(sin(vec2(ip, ip + 1.) * 12.3456) * 43.5453);\n\treturn mix(h.x, h.y, p * p * (3. - 2. * p));\n}\n\n/**\n * @brief Texture of a Wood \n * \n * @param point : Point in the space\n * @return Material : Resulting a Wood Texture\n */\nfloat WoodTexture(vec2 p) {\n\tp.x *= 71.;\n\tp.y *= 1.9;\n\treturn n11(n21(p) * 30.);\n}\n\n/**\n * @brief Texture of a Wood \n * \n * @param point : Point in the space\n * @return Material : Resulting a Wood Texture\n */\nvec3 WoodTexture2(vec3 p, vec3 color1, vec3 color2) {\n    p = p + Turbulence(p, 5., 0.5, 5);\n    float r = sqrt (p.x * p.x + p.y * p.y);\n    float pattern = 0.5 + 0.5 * cos (10. * 3.1415927 * r) ;   \n    return mix(color1, color2, pattern); \n}\n\n/**\n * @brief Definition of all texture in the scene\n * \n * @param p : Point in the space\n * @param i : Texture index\n * @return Material : Specific material per index\n */\nMaterial Texture(vec3 p, int i) {\n    if (i == 1) { // uniform\n         // return Material(vec3(.8,.0,.1),vec3(0.2,0.2,0.2), vec3(0.2, 0.2, 0.2), 50., 0., vec3(0.));\n        return Material(vec3(.8,.5,.4), vec3(0.2), vec3(0.7, 0.7, 0.7), 50., 0., vec3(0.));\n    }\n    else if (i == 2) { // variation\n        vec3 colorA = vec3(0.1,0.1,0.9);\n        vec3 colorB = vec3(1.,0.8,0.2);\n        return Material(mix(colorA, colorB, sin(iTime*0.5)),vec3(0.4,0.4,0.4), vec3(0.2, 0.2, 0.2), 50., 0., vec3(0.) );\n    }\n    else if (i == 3) { // Checkboard\n        vec3 texture = Checkboard(p, vec3(1., 1., 1.), vec3(0., 0., 0.));\n        return Material(texture, vec3(0.4,0.4,0.4), vec3(0.2, 0.2, 0.2), 50., 0., vec3(0.) );\n    }\n    else if (i == 4) { // Marble\n        Material color1 = Material(vec3(1.2, 1.2, 1.2), vec3(0.4,0.4,0.4), vec3(0.9, 0.9, 0.9), 50., 0., vec3(0.));\n        Material color2 = Material(vec3(0.83, .83, .83), vec3(0.4,0.4,0.4), vec3(0.2, 0.2, 0.2), 50., 0., vec3(0.));\n        Material marble = MarbleTexture(p, color1, color2);\n        return marble;\n    }\n    else if (i == 5) { // Marble\n        Material color1 = Material(vec3(0.3, 0.3, 0.3), vec3(0.2,0.2,0.2), vec3(0, 0, 0), 1., 0., vec3(0.));\n        Material color2 = Material(vec3(0.9, 0.9, 0.2), vec3(0.7,0.7,0.7), vec3(3, 3, 3), 100., 0., vec3(0.));\n        Material marble = VeinMarbleTexture(p, color1, color2);\n        return marble;\n    }\n    else if (i == 6) { // Mirror\n        return Material(vec3(.8,.5,.4), vec3(.7), vec3(0.2), 50., 1., vec3(0,0, 0.));\n    }\n    else if (i == 7) { // Wood\n        float woodValue = WoodTexture(p.xy);\n        vec3 color1 = vec3(0.4, 0.2, 0.1);\n        vec3 color2 = vec3(0.2, 0.1, 0.07);\n        vec3 texture = mix(color1, color2, woodValue);\n        return Material(texture, vec3(.2), vec3(0.1), 50., 0., vec3(0, 0, 0));\n    }\n    else if (i == 8) { // Wood 2\n        vec3 color1 = vec3(.17, .1, .05);\n        vec3 color2 = vec3(.08, .05, .03);\n        vec3 texture = WoodTexture2(p, color1, color2);\n        return Material(texture, vec3(.7), vec3(0.2), 50., 0., vec3(0, 0, 0));\n    }\n    else if (i == 0) { // classic checkboard\n        float f = Checkers(.5*p.xy);\n        vec3 col = vec3(.4,.5,.7) + f * vec3(.1);\n        return Material(col, vec3(0.2, 0.2, 0.2), vec3(0.9, 0.9, 0.9), 50., 0., vec3(0.));\n    }\n    return Material(vec3(0),vec3(0.,0.,0.), vec3(0.2, 0.2, 0.2), 50., 0., vec3(0.));\n}\n\n/**\n * @brief resolv second order equation : ax² + bx + c = 0\n * \n * @param a : float\n * @param b : float\n * @param c : float\n * @return float : min of the 2 solution\n */\nfloat solvRoots(float a, float b, float c) {\n    float t;\n    //on calcul le déterminant d pour trouver les racine de l'équation\n    float d = b * b - 4. * a * c;\n    if (d > 0.){\n        float t1 = (-b - sqrt(d)) / (2.0 * a);\n        float t2 = (-b + sqrt(d)) / (2.0 * a);\n        float t = min(t1, t2);\n        return t;\n    }\n}\n\n//////////////////////////////////////////////////////////////////////\n//Intersection functions\n\n/**\n * @brief Classic sphere intersection\n * \n * @param ray : The ray\n * @param sph : Structure information\n * @param x : Returned intersection information\n * @return true\n * @return false\n */\nbool IntersectSphere(Ray ray, Sphere sph, out Hit x) {\n    vec3 oc = ray.origin - sph.center;\n    float b = dot(oc, ray.direction);\n    float c = dot(oc, oc) - sph.radius * sph.radius;\n    float d = b * b - c;\n    if (d>0.) {\n        float t = -b - sqrt(d);\n        if (t>0.) {\n            vec3 p = Point(ray,t);\n            x = Hit(t, normalize(p-sph.center), sph.id); \n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * @brief Classic Plane intersection\n * \n * @param ray : The ray\n * @param pl : Structure information\n * @param x : Returned intersection information\n * @return true \n * @return false \n */\nbool IntersectPlane(Ray ray, Plane pl, out Hit x) {\n    pl.normal = normalize(pl.normal);\n    float t = -dot(ray.origin - pl.point, pl.normal) / dot(ray.direction, pl.normal);\n    if (t > 0.) {\n        vec3 p = Point(ray, t);\n        x = Hit(t, pl.normal, pl.id);\n        return true;\n    }\n    return false;\n}\n\n/**\n * @brief intersect between a Ray and an Ellipsoid\n * \n * @param ray : The ray\n * @param ellip : Structure information\n * @param x : Returned intersection information\n * @return true \n * @return false \n */\nbool IntersectEllipsoid(Ray ray, Ellipsoid ellip, out Hit x) {\n    vec3 oc = ray.origin - ellip.center;\n    float a = dot((ray.direction / ellip.radius), (ray.direction / ellip.radius));\n    float b = 2. * dot((oc / ellip.radius), (ray.direction / ellip.radius));\n    float c = dot((oc/ellip.radius), (oc/ellip.radius)) - dot(ellip.radius, ellip.radius);\n\n    float t = solvRoots(a, b, c);\n    if (t>0.) {\n        vec3 p = Point(ray,t);\n        x = Hit(t,normalize(p-ellip.center),ellip.id);\n        return true;\n    }\n    return false;\n}\n\n/**\n * @brief intersect between a Ray and a Cylinder body\n * \n * @param ray : The ray\n * @param cyl : Structure information\n * @param x : Returned intersection information\n * @return true \n * @return false \n */\nbool IntersectCylinderBody(Ray ray, Cylinder cyl, out Hit x) {\n    vec3 oa = ray.origin - cyl.bottomCenter;\n    vec3 u = normalize(cyl.topCenter - cyl.bottomCenter);\n    \n    float a = dot(ray.direction, ray.direction) - dot(ray.direction, u) * dot(ray.direction, u); \n    float b = 2. * ( dot(oa, ray.direction) - dot(oa, u) * dot(ray.direction, u));\n    float c = dot(oa, oa) - dot(oa, u) * dot(oa, u) - cyl.radius * cyl.radius;\n    float t = solvRoots(a, b, c);\n    if (t>0.) {\n        vec3 p = Point(ray, t);\n        float v = dot(p - cyl.bottomCenter, u);\n        vec3 h = cyl.bottomCenter + v * u;\n        if (v >= 0. && v <= length(cyl.topCenter - cyl.bottomCenter)) {\n            x = Hit(t, normalize(p - h), cyl.id);\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * @brief intersect between a Ray and a Disc\n * \n * @param ray : The ray\n * @param disc : Structure information\n * @param x : Returned intersection information\n * @return true \n * @return false \n */\nbool IntersectDisc(Ray ray,Disc disc,out Hit x) {\n    disc.normal = normalize(disc.normal);\n    bool pl = IntersectPlane(ray, Plane(disc.normal, disc.point, disc.id), x);\n    if (pl) {\n        vec3 p = Point(ray, x.t);\n        if (length(p - disc.point) < disc.radius) {\n            // x = Hit(x.t,disc.n, disc.i);\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * @brief intersect between a Ray and a Cylinder\n * \n * @param ray : The ray\n * @param cyl : Structure information\n * @param x : Returned intersection information\n * @return true \n * @return false \n */\nbool IntersectCylinder(Ray ray, Cylinder cyl, out Hit x) {\n    x = Hit(1000., vec3(0), -1);\n    Hit x_;\n    \n    Disc ds1 = Disc(-normalize(cyl.topCenter - cyl.bottomCenter), cyl.bottomCenter, cyl.radius, cyl.id);\n    Disc ds2 = Disc(normalize(cyl.topCenter - cyl.bottomCenter), cyl.topCenter, cyl.radius, cyl.id);\n    bool b1 = IntersectDisc(ray, ds1, x_);\n    if (b1 && x_.t < x.t) {\n        x = x_;\n    }\n    bool b2 = IntersectDisc(ray, ds2, x_);\n    if (b2 && x_.t < x.t) {\n        x = x_;\n    }\n    bool body = IntersectCylinderBody(ray, cyl, x_);\n    if (body && x_.t < x.t) {\n        x = x_;\n    }\n    return b1 || b2 || body;  \n}\n\n/**\n * @brief intersect between a Ray and a Capsule\n * \n * @param ray : The ray\n * @param cap : Structure information\n * @param x : Returned intersection information\n * @return true \n * @return false \n */\nbool IntersectCapsule(Ray ray, Capsule cap, out Hit x) {\n    x = Hit(1000., vec3(0), -1);\n    Hit x_;\n    Sphere sph1 = Sphere(cap.bottomCenter, cap.radius, cap.id);\n    Sphere sph2 = Sphere(cap.topCenter, cap.radius, cap.id);\n    bool b1 = IntersectSphere(ray, sph1, x_);\n    if (b1 && x_.t < x.t) {\n        x = x_;\n    }\n    bool b2 = IntersectSphere(ray, sph2, x_);\n    if (b2 && x_.t < x.t) {\n        x = x_;\n    }\n    Cylinder cyl;\n    cyl.bottomCenter = cap.bottomCenter;\n    cyl.topCenter = cap.topCenter;\n    cyl.radius = cap.radius;\n    cyl.id = cap.id;\n    bool body = IntersectCylinderBody(ray, cyl, x_);\n    if (body && x_.t < x.t) {\n        x = x_;\n    }\n    return b1 || body || b2;  \n}\n\n// Source : https://www.shadertoy.com/view/fsB3Wt\nfloat cbrt(in float x) { return sign(x) * pow(abs(x), 1.0 / 3.0); }\n\nint solveQuartic(in float a, in float b, in float c, in float d, in float e, inout vec4 roots) {\n    b /= a; c /= a; d /= a; e /= a; // Divide by leading coefficient to make it 1\n\n    // Depress the quartic to x^4 + px^2 + qx + r by substituting x-b/4a\n    // This can be found by substituting x+u and the solving for the value\n    // of u that makes the t^3 term go away\n    float bb = b * b;\n    float p = (8.0 * c - 3.0 * bb) / 8.0;\n    float q = (8.0 * d - 4.0 * c * b + bb * b) / 8.0;\n    float r = (256.0 * e - 64.0 * d * b + 16.0 * c * bb - 3.0 * bb * bb) / 256.0;\n    int n = 0; // Root counter\n\n    // Solve for a root to (t^2)^3 + 2p(t^2)^2 + (p^2 - 4r)(t^2) - q^2 which resolves the\n    // system of equations relating the product of two quadratics to the depressed quartic\n    float ra =  2.0 * p;\n    float rb =  p * p - 4.0 * r;\n    float rc = -q * q;\n\n    // Depress using the method above\n    float ru = ra / 3.0;\n    float rp = rb - ra * ru;\n    float rq = rc - (rb - 2.0 * ra * ra / 9.0) * ru;\n\n    float lambda;\n    float rh = 0.25 * rq * rq + rp * rp * rp / 27.0;\n    if (rh > 0.0) { // Use Cardano's formula in the case of one real root\n        rh = sqrt(rh);\n        float ro = -0.5 * rq;\n        lambda = cbrt(ro - rh) + cbrt(ro + rh) - ru;\n    }\n\n    else { // Use complex arithmetic in the case of three real roots\n        float rm = sqrt(-rp / 3.0);\n        lambda = -2.0 * rm * sin(asin(1.5 * rq / (rp * rm)) / 3.0) - ru;\n    }\n\n    // Newton iteration to fix numerical problems (using Horners method)\n    // Suggested by @NinjaKoala\n    for (int i=0; i < 2; i++) {\n        float a_2 = ra + lambda;\n        float a_1 = rb + lambda * a_2;\n        float b_2 = a_2 + lambda;\n\n        float f = rc + lambda * a_1; // Evaluation of λ^3 + ra * λ^2 + rb * λ + rc\n        float f1 = a_1 + lambda * b_2; // Derivative\n\n        lambda -= f / f1; // Newton iteration step\n    }\n\n    // Solve two quadratics factored from the quartic using the cubic root\n    if (lambda < 0.0) return n;\n    float t = sqrt(lambda); // Because we solved for t^2 but want t\n    float alpha = 2.0 * q / t, beta = lambda + ra;\n\n    float u = 0.25 * b;\n    t *= 0.5;\n\n    float z = -alpha - beta;\n    if (z > 0.0) {\n        z = sqrt(z) * 0.5;\n        float h = +t - u;\n        roots.xy = vec2(h + z, h - z);\n        n += 2;\n    }\n\n    float w = +alpha - beta;\n    if (w > 0.0) {\n        w = sqrt(w) * 0.5;\n        float h = -t - u;\n        roots.zw = vec2(h + w, h - w);\n        if (n == 0) roots.xy = roots.zw;\n        n += 2;\n    }\n\n    return n;\n}\n\n/**\n * @brief intersect between a Ray and a Box\n * \n * @param ray : The ray\n * @param bx : Structure information\n * @param x : Returned intersection information\n * @return true \n * @return false \n */\nbool IntersectBox(Ray ray, Box bx, out Hit x) {\n    vec3 t0, t1;\n    //défini tout les cas de t0 et t1 pour x puis y puis z dans tous les angles de la cam\n    if (ray.direction.x >= 0.) { \n        t0.x = (bx.bottomCorner.x - ray.origin.x) / ray.direction.x;\n        t1.x = (bx.topCorner.x - ray.origin.x) / ray.direction.x;\n    } \n    else { \n        t0.x = (bx.topCorner.x - ray.origin.x) / ray.direction.x;\n        t1.x = (bx.bottomCorner.x - ray.origin.x) / ray.direction.x;\n    } \n    \n    if (ray.direction.y >= 0.) { \n        t0.y = (bx.bottomCorner.y - ray.origin.y) / ray.direction.y;\n        t1.y = (bx.topCorner.y - ray.origin.y) / ray.direction.y;\n    } \n    else { \n        t0.y = (bx.topCorner.y - ray.origin.y) / ray.direction.y;\n        t1.y = (bx.bottomCorner.y - ray.origin.y) / ray.direction.y;\n    } \n    \n    if (ray.direction.z >= 0.) { \n        t0.z = (bx.bottomCorner.z - ray.origin.z) / ray.direction.z;\n        t1.z = (bx.topCorner.z - ray.origin.z) / ray.direction.z;\n    } \n    else { \n        t0.z = (bx.topCorner.z - ray.origin.z) / ray.direction.z;\n        t1.z = (bx.bottomCorner.z - ray.origin.z) / ray.direction.z;\n    }\n    //filtre des cas ne touchant pas la boite\n    if (t0.x > t1.y || t0.y > t1.x) return false;\n    //filtre pour trouver tmin et tmax\n    float tmin = max(t0.x, t0.y);\n    float tmax = min(t1.x, t1.y);\n    //même opération étendu à z\n    if (tmin > t1.z || t0.z > tmax) return false;\n    tmin = max(tmin, t0.z);\n    tmax = min(tmax, t1.z);\n    //sélection du t:\n    float t = (tmin < 0.) ? tmax : tmin;\n    if (t > 0.) {\n        vec3 p = Point(ray, t);\n        //le centre du box\n        vec3 c = (bx.bottomCorner + bx.topCorner) / 2.;\n        x = Hit(t, normalize(p - c), bx.id);\n        return true;\n    }\n    return false;\n}\n\n/**\n * @brief intersect between a Ray and a Torus\n * \n * @param ray : The ray\n * @param tor : Structure information\n * @param x : Returned intersection information\n * @return true \n * @return false \n */\nbool IntersectTorus(Ray ray, Torus tor, out Hit x) { \n\n    // http://heigeas.free.fr/laure/ray_tracing/tore.html\n\n    if (tor.bigRadius > tor.smallRadius) {\n        vec3 oc = ray.origin - tor.center;\n\n        float f = dot(ray.direction, ray.direction);\n        float g = 2. * dot(oc, ray.direction); \n        float h = dot(oc, oc) + (tor.bigRadius * tor.bigRadius) - (tor.smallRadius * tor.smallRadius);\n\n        float i = - 4. * (tor.bigRadius * tor.bigRadius) * ((ray.direction.x * ray.direction.x) + (ray.direction.y * ray.direction.y));\n        float j = - 8. * (tor.bigRadius * tor.bigRadius) * ((oc.x * ray.direction.x) + (oc.y * ray.direction.y)); \n        float k = - 4. * (tor.bigRadius * tor.bigRadius) * ((oc.x * oc.x) + (oc.y * oc.y)); \n\n        float a = f * f;\n        float b = 2. * f * g;\n        float c = (2. * f * h) + (g * g) + i;\n        float d = (2. * g * h) + j;\n        float e = (h * h) + k;\n\n        vec4 roots;\n        int nroots = solveQuartic(a, b, c, d, e, roots); \n\n        if (nroots > 0) {\n            float t1, t2, t;\n            if (nroots == 2) {\n                t =  min(roots.x, roots.y);\n            }\n\n            if (nroots == 4) {\n                t1 = min(roots.x, roots.y);\n                t2 = min(roots.z, roots.w);\n                t = min (t1, t2);\n            }\n\n            if (t > 0.) {\n                vec3 p = Point(ray, t);\n                vec3 normale;\n\n                vec3 odt = oc + ray.direction * t;\n                float oxdt = oc.x + ray.direction.x * t;\n                float oydt = oc.y + ray.direction.y * t;\n                float ozdt = oc.z + ray.direction.z * t;\n\n                normale.x = 4. * oxdt * (dot(oc, oc) + 2. * dot(oc, ray.direction * t) + dot(ray.direction * t, ray.direction * t) + dot(tor.bigRadius, tor.bigRadius) - dot(tor.smallRadius, tor.smallRadius)) - 8. * dot(tor.bigRadius, tor.bigRadius) * oxdt;\n                normale.y = 4. * oydt * (dot(oc, oc) + 2. * dot(oc, ray.direction * t) + dot(ray.direction * t, ray.direction * t) + dot(tor.bigRadius, tor.bigRadius) - dot(tor.smallRadius, tor.smallRadius)) - 8. * dot(tor.bigRadius, tor.bigRadius) * oydt;\n                normale.z = 4. * ozdt * (dot(oc, oc) + 2. * dot(oc, ray.direction * t) + dot(ray.direction * t, ray.direction * t) + dot(tor.bigRadius, tor.bigRadius) - dot(tor.smallRadius, tor.smallRadius));\n                \n                x = Hit(t, normalize(normale),tor.id);\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\n\n/**\n * @brief intersect between a Ray and a Goursat Box\n * \n * @param ray : The ray\n * @param goursat : Structure information\n * @param x : Returned intersection information\n * @return true \n * @return false \n */\nbool IntersectGoursat(Ray ray, Goursat goursat, out Hit x) {\n\n    // http://heigeas.free.fr/laure/ray_tracing/cubetroue.html\n\n    vec3 oc = ray.origin - goursat.center;\n    vec3 rayD2 = ray.direction * ray.direction;\n    vec3 rayD3 = rayD2 * ray.direction;\n    vec3 rayO2 = oc * oc;\n    vec3 rayO3 = rayO2 * oc;\n\n    float f = dot(rayD2, rayD2);\n    float g = 4.* dot(oc, rayD3);\n    float h = 6. * dot(rayO2, rayD2);\n    float i = 4. * dot(rayO3, ray.direction);\n    float j = dot(rayO2, rayO2);\n\n    float k = -5. * dot(ray.direction, ray.direction);\n    float l = -10. * dot(oc, ray.direction);\n    float m = -5. * dot(oc, oc) + 3.5 * cos(iTime) + 14.5;\n\n    float a = f;\n    float b = g;\n    float c = h + k;\n    float d = i + l;\n    float e = j + m;\n\n    vec4 roots;\n    int nroots = solveQuartic(a, b, c, d, e, roots);\n\n    if (nroots > 0) {\n        float t1, t2, t;\n        if (nroots == 2) {\n            t =  min(roots.x, roots.y);\n        }\n\n        if (nroots == 4) {\n            t1 = min(roots.x, roots.y);\n            t2 = min(roots.z, roots.w);\n            t = min (t1, t2);\n        }\n\n        if (t > 0.) {\n            vec3 p = Point(ray, t);\n            vec3 normale;\n\n            float ocX2 = oc.x * oc.x;\n            float ocX3 = ocX2 * oc.x;\n            \n            float ocY2 = oc.y * oc.y;\n            float ocY3 = ocY2 * oc.y;\n            \n            float ocZ2 = oc.z * oc.z;\n            float ocZ3 = ocZ2 * oc.z;\n\n\n            float dXt = ray.direction.x * t;\n            float dYt = ray.direction.y * t;\n            float dZt = ray.direction.z * t;\n\n            float dXt2 = dXt * dXt;\n            float dYt2 = dYt * dYt;\n            float dZt2 = dZt * dZt;\n\n            float dXt3 = dXt2 * dXt;\n            float dYt3 = dYt2 * dYt;\n            float dZt3 = dZt2 * dZt;\n\n            normale.x = 4. * ( ocX3 + 3.*dot(ocX2, dXt) + 3.*dot(oc.x, dXt2) + dXt3) - 10. * (oc.x + ray.direction.x * t );\n            normale.y = 4. * ( ocY3 + 3.*dot(ocY2, dYt) + 3.*dot(oc.y, dYt2) + dYt3) - 10. * (oc.y + ray.direction.y * t );\n            normale.z = 4. * ( ocZ3 + 3.*dot(ocZ2, dZt) + 3.*dot(oc.z, dZt2) + dZt3) - 10. * (oc.z + ray.direction.z * t );\n\n            x = Hit(t, normalize(normale - p), goursat.id);\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * @brief intersect between a Ray and an Octaeder\n * \n * @param ray : The ray\n * @param octa : Structure information\n * @param x : Returned intersection information\n * @return true \n * @return false \n */\nbool IntersectOctaeder(Ray ray, Octaeder octa, out Hit x) {\n\n    // https://mathcurve.com/surfaces/goursat/goursat.shtml\n\n    vec3 oc = ray.origin - octa.center;\n    vec4 roots;\n\n    float rdx = ray.direction.x;\n    float rdy = ray.direction.y;\n    float rdz = ray.direction.z;\n\n    float rdx2 = rdx * rdx;\n    float rdy2 = rdy * rdy;\n    float rdz2 = rdz * rdz;\n\n    float odx = oc.x * rdx;\n    float ody = oc.y * rdy;\n    float odz = oc.z * rdz;\n\n    float ocx2 = oc.x * oc.x;\n    float ocy2 = oc.y * oc.y;\n    float ocz2 = oc.z * oc.z;\n\n    float l = 8. * (dot(rdx2, rdy2) + dot(rdy2, rdz2) + dot(rdz2, rdx2)); \n    float m = 8. * (2. * (dot(odx, rdy2) + dot(ody, rdx2) \n                        + dot(ody, rdz2) + dot(odz, rdy2) \n                        + dot(odz, rdx2) + dot(odx, rdz2)));\n\n    float n =  8. * (dot(ocx2, rdy2) + dot(ocy2, rdx2)\n                    + dot(ocy2, rdz2) + dot(ocz2, rdy2)\n                    + dot(ocz2, rdx2) + dot(ocx2, rdz2)\n                    + 4. * (dot(odx, ody) + dot(ody, odz) + dot(odz, odx)));\n    float o = 8. * (2. * (dot(ocx2, ody) + dot(ocy2, odx) \n                        + dot(ocy2, odz) + dot(ocz2, ody) \n                        + dot(ocz2, odx) + dot(ocx2, odz) ));\n\n    float p = 8. * (dot(ocx2, ocy2) + dot(ocy2, ocz2) + dot(ocz2, ocx2));\n\n    float q = 5. * (dot(ray.direction, ray.direction));\n    float r = 5. * (2. * (dot(oc, ray.direction)));\n    float s = 5. * (dot(oc, oc)) + cos(iTime) * 67.5 - 82.5;\n\n    float f = l;\n    float g = m;\n    float h = n + q;\n    float i = o + r;\n    float j = p + s;\n\n    int nroots = solveQuartic(f, g, h, i, j, roots);\n\n    if (nroots > 0) {\n        float t1, t2, t;\n        if (nroots == 2) {\n            t =  min(roots.x, roots.y);\n        }\n\n        if (nroots == 4) {\n            t1 = min(roots.x, roots.y);\n            t2 = min(roots.z, roots.w);\n            t = min (t1, t2);\n        }\n\n        if (t > 0.) {\n            vec3 p = Point(ray, t);\n            vec3 normale;\n\n            normale.x = 16. * (oc.x + ray.direction.x * t) * ( dot(oc.y, oc.y) + 2. * dot(oc.y, ray.direction.y * t) + dot(ray.direction.y * t, ray.direction.y * t) \n                            + dot(oc.z, oc.z) + 2. * dot(oc.z, ray.direction.z * t) + dot(ray.direction.z * t, ray.direction.z * t)) \n                            + 10. * (oc.x + ray.direction.x * t);\n            normale.y = 16. * (oc.y + ray.direction.y * t) * ( dot(oc.x, oc.x) + 2. * dot(oc.x, ray.direction.x * t) + dot(ray.direction.x * t, ray.direction.x * t) \n                            + dot(oc.z, oc.z) + 2. * dot(oc.z, ray.direction.z * t) + dot(ray.direction.z * t, ray.direction.z * t)) \n                            + 10. * (oc.y + ray.direction.y * t);\n            normale.z = 16. * (oc.z + ray.direction.z * t) * ( dot(oc.x, oc.x) + 2. * dot(oc.x, ray.direction.x * t) + dot(ray.direction.x * t, ray.direction.x * t) \n                            + dot(oc.y, oc.y) + 2. * dot(oc.y, ray.direction.y * t) + dot(ray.direction.y * t, ray.direction.y * t)) \n                            + 10. * (oc.z + ray.direction.z * t);\n\n            x = Hit(t, normalize(normale), octa.id);\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * @brief intersect between a Ray and a PipeConnector \n * \n * @param ray : The ray\n * @param pip : Structure information\n * @param x : Returned intersection information\n * @return true \n * @return false \n */\nbool IntersectPipeConnector(Ray ray, PipeConnector pip, out Hit x) {\n\n    // https://mathcurve.com/surfaces/goursat/goursat.shtml\n\n    vec3 oc = ray.origin - pip.center;\n    vec4 roots;\n\n    float rdx = ray.direction.x;\n    float rdy = ray.direction.y;\n    float rdz = ray.direction.z;\n\n    float rdx2 = rdx * rdx;\n    float rdy2 = rdy * rdy;\n    float rdz2 = rdz * rdz;\n\n    float odx = oc.x * rdx;\n    float ody = oc.y * rdy;\n    float odz = oc.z * rdz;\n\n    float ocx2 = oc.x * oc.x;\n    float ocy2 = oc.y * oc.y;\n    float ocz2 = oc.z * oc.z;\n\n    float l = 2. * (dot(rdx2, rdy2) + dot(rdy2, rdz2) + dot(rdz2, rdx2)); \n    float m = 2. * (2. * (dot(odx, rdy2) + dot(ody, rdx2) \n                        + dot(ody, rdz2) + dot(odz, rdy2) \n                        + dot(odz, rdx2) + dot(odx, rdz2)));\n\n    float n =  2. * (dot(ocx2, rdy2) + dot(ocy2, rdx2)\n                    + dot(ocy2, rdz2) + dot(ocz2, rdy2)\n                    + dot(ocz2, rdx2) + dot(ocx2, rdz2)\n                    + 4. * (dot(odx, ody) + dot(ody, odz) + dot(odz, odx)));\n    float o = 2. * (2. * (dot(ocx2, ody) + dot(ocy2, odx) \n                        + dot(ocy2, odz) + dot(ocz2, ody) \n                        + dot(ocz2, odx) + dot(ocx2, odz) ));\n\n    float p = 2. * (dot(ocx2, ocy2) + dot(ocy2, ocz2) + dot(ocz2, ocx2));\n\n    float q = -3. * (dot(ray.direction, ray.direction));\n    float r = -3. * (2. * (dot(oc, ray.direction)));\n    float s = -3. * (dot(oc, oc)) + cos(iTime) * 67.5 - 82.5;\n\n    float f = l;\n    float g = m;\n    float h = n + q;\n    float i = o + r;\n    float j = p + s;\n\n    int nroots = solveQuartic(f, g, h, i, j, roots);\n\n    if (nroots > 0) {\n        float t1, t2, t;\n        if (nroots == 2) {\n            t =  min(roots.x, roots.y);\n        }\n\n        if (nroots == 4) {\n            t1 = min(roots.x, roots.y);\n            t2 = min(roots.z, roots.w);\n            t = min (t1, t2);\n        }\n\n        if (t > 0.) {\n            vec3 p = Point(ray, t);\n            vec3 normale;\n\n            normale.x = 4. * (oc.x + ray.direction.x * t) * ( dot(oc.y, oc.y) + 2. * dot(oc.y, ray.direction.y) \n                            + dot(ray.direction.y * t, ray.direction.y * t) + dot(oc.z, oc.z) \n                            + 2. * dot(oc.z, ray.direction.z) + dot(ray.direction.z * t, ray.direction.z * t)) \n                            + 6. * (oc.x + ray.direction.x * t);\n            normale.y = 4. * (oc.y + ray.direction.y * t) * ( dot(oc.x, oc.x) + 2. * dot(oc.x, ray.direction.x) \n                            + dot(ray.direction.y * t, ray.direction.y * t) + dot(oc.z, oc.z) \n                            + 2. * dot(oc.z, ray.direction.z) + dot(ray.direction.z * t, ray.direction.z * t)) \n                            + 6. * (oc.y + ray.direction.y * t);\n            normale.z = 4. * (oc.z + ray.direction.z * t) * ( dot(oc.x, oc.x) + 2. * dot(oc.x, ray.direction.x) \n                            + dot(ray.direction.y * t, ray.direction.y * t) + dot(oc.z, oc.z) \n                            + 2. * dot(oc.z, ray.direction.z) + dot(ray.direction.z * t, ray.direction.z * t))\n                            + 6. * (oc.z + ray.direction.z * t);\n\n            x = Hit(t, normalize(normale), pip.id);\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * @brief Translates the origin of a ray by a specified point.\n * \n * @param ray : The ray\n * @param p : point\n * @return Ray the translated ray \n */\nRay Translation(Ray ray, vec3 p) {\n    return Ray(ray.origin - p, ray.direction, false, false);\n}\n\n/**\n * @brief Translates the origin of a ray by a specified point.\n * \n * @param ray : The ray vector in space\n * @param p : point\n * @return Ray the translated ray in space\n */\nvec3 Translation(vec3 ray, vec3 p) {\n    return ray - p;\n}\n\n/**\n * @brief Applies rotation to a given normal vector around a specified point.\n * \n * This function applies rotations to a normal vector around the specified point 'tr'.\n * \n * @param normal The normal vector to be rotated.\n * @param rot A vector representing the rotation angles around X, Y, and Z axes.\n * @param tr The center point around which the rotation is performed.\n * @return vec3 The rotated normal vector.\n */\nvec3 RotationNormal(vec3 normal, vec3 rot, vec3 tr) {\n    //construire les matrices de rotations\n    mat3 rotationX = mat3(\n        1., 0.      , 0.       ,\n        0., cos(rot.x), -sin(rot.x),\n        0., sin(rot.x), cos(rot.x)\n    );\n    mat3 rotationY = mat3(\n        cos(rot.y), 0., -sin(rot.y),\n        0.      , 1., 0.       ,\n        sin(rot.y), 0., cos(rot.y)\n    );\n    mat3 rotationZ = mat3(\n        cos(rot.z), -sin(rot.z), 0.,\n        sin(rot.z), cos(rot.z) , 0.,\n        0.      , 0.       , 1.\n    );\n    normal = rotationX * rotationY * rotationZ * normal;\n    return normal;\n}\n\n/**\n * @brief Applies rotation to a ray around a specified point.\n * \n * This function applies rotations to a given ray using the rotation angle around the specified point 'tr'.\n * \n * @param ray The original ray to be rotated.\n * @param rot A vector representing the rotation angles around X, Y, and Z axes.\n * @param tr The center point around which the rotation is performed.\n * @return Ray The rotated ray.\n */\nRay Rotation(Ray ray, vec3 rot, vec3 tr) {\n    //construire les matrices de rotations\n    mat3 rotationX = mat3(\n        1., 0.      , 0.       ,\n        0., cos(rot.x), -sin(rot.x),\n        0., sin(rot.x), cos(rot.x)\n    );\n    mat3 rotationY = mat3(\n        cos(rot.y), 0., -sin(rot.y),\n        0.      , 1., 0.       ,\n        sin(rot.y), 0., cos(rot.y)\n    );\n    mat3 rotationZ = mat3(\n        cos(rot.z), -sin(rot.z), 0.,\n        sin(rot.z), cos(rot.z) , 0.,\n        0.      , 0.       , 1.\n    );\n    //ramener à 0\n    ray.direction = rotationZ * rotationY * rotationX * ray.direction;\n    ray.origin = Translation(ray.origin, tr);\n    //effectuer la rotation\n    ray.origin = rotationZ * rotationY * rotationX * ray.origin;\n    //ramener à où c'était\n    ray.origin = Translation(ray.origin, -tr);\n    return Ray(ray.origin, ray.direction, ray.isHomo, true);\n}\n\n/**\n * @brief Applies a homothety transformation to a ray around a specified point.\n * \n * This function applies a homothety transformation to a given ray by changing its direction and origin,\n * relative to the specified point 'tr'.\n * \n * @param ray The original ray to be transformed.\n * @param homo A vector representing scaling factors for the ray's direction.\n * @param tr The center point around which the homothety transformation is performed.\n * @return Ray The transformed ray.\n */\nRay Homothetie(Ray ray, vec3 homo, vec3 tr) {\n    // change direction\n    ray.direction = ray.direction / homo;\n\n    // move to 0 origin\n    ray.origin = Translation(ray.origin, tr);\n    // change origin\n    ray.origin = ray.origin / homo;\n    // get back the origin\n    ray.origin = Translation(ray.origin, -tr);\n    // normalize the direction\n    ray.direction = normalize(ray.direction);\n    return Ray(ray.origin, ray.direction, true, ray.isRot);\n}\n\n/**\n * @brief Transforms a hit point obtained in homothetic space back to the original space.\n * \n * This function takes a hit point 'homoHit' obtained in homothetic space and transforms it back\n * to the original space using the given baseRay and homoRay for reference. The 'scale' vector\n * is used to scale the transformed point.\n * \n * @param homoHit The hit point in homothetic space.\n * @param baseRay The original ray used as a reference for transformation.\n * @param homoRay The transformed ray used as a reference for transformation.\n * @param scale A vector representing the scaling factors.\n * @return Hit The hit point in the original space.\n */\nHit Homothetie(Hit homoHit, Ray baseRay, Ray homoRay, vec3 scale) {\n    // point d'intersection dans le repère non transformé\n    vec3 homoPoint = Point(homoRay, homoHit.t);\n    // point d'intersection sur le vrai objet transformé\n    homoPoint *= scale;\n    \n    Hit hit = homoHit;\n    // nouveau t à partir du vrai point transformé (on résout juste homoPoint = baseRay.o + t * baseRay.d, \n    // en choisissant n'importe quelle composante, ici x)\n    hit.t = (homoPoint.x - baseRay.origin.x) / baseRay.direction.x;\n    \n    return hit;\n}\n\n/**\n * @brief Computes the center point between two given points.\n * \n * @param cornerA The first point.\n * @param cornerB The second point.\n * @return vec3 The center point between 'cornerA' and 'cornerB'.\n */\nvec3 FindTheCenter(vec3 cornerA, vec3 cornerB) {\n    return (cornerA + cornerB)/2.;\n}\n\n/**\n * @brief Creates a scene of all the objects.\n * \n * @param ray The ray\n * @return Dynamic scene.\n */\nScene sceneAllObjects(Ray ray){\n    Scene scene;\n    scene.plane = Plane(vec3(0.,0.,1.), vec3(0.,0.,0.),0);\n\n    for (int i = 0; i < 10; i++) {\n        scene.tabRay[i] = ray;\n    }\n\n    scene.nbSphere = 1;\n    scene.nbEllipsoid = 1;\n    scene.nbCylinder = 1;\n    scene.nbCapsule = 1;\n    scene.nbBox = 1;\n    scene.nbTorus = 1;\n    scene.nbGoursat = 1;\n    scene.nbOctaeder = 1;\n    scene.nbPipeConnector = 1;\n    \n    scene.tabSphere[0] = Sphere(vec3(-4.,5.,4.),1.,1);\n    scene.tabEllipsoid[0] = Ellipsoid(vec3(-4., 0., 4.), vec3(1., 1.2, 0.5), 1);\n    scene.tabCylinder[0] = Cylinder(vec3(0.,5.,0.), vec3(0., 5., 2.1), .75, 1);\n    scene.tabCapsule[0] = Capsule(vec3(0.,2.,0.), vec3(0., 2., 3.1), 0.5 ,1);\n    scene.tabBox[0] = Box(vec3(-1.1, -1.1, 0.1), vec3(2.5, 0.1, 2.1), 1);\n    \n    scene.tabRay[5] = Translation(scene.tabRay[0], vec3(0, -3, 2)); \n    scene.tabTorus[0] = Torus(vec3(0., 0., 0.), 1., .5, 1);\n    \n    scene.tabGoursat[0] = Goursat(vec3(0., -8., 2.1), 1);\n    \n    scene.tabOctaeder[0] = Octaeder(vec3(-10., -8., 4), 1);\n    scene.tabPipeConnector[0] = PipeConnector(vec3(-23., -3, 10), 1);\n    \n    return scene;\n}\n\n/**\n * @brief Creates a scene where we test Translation, Homotethy and Rotation functions.\n * \n * @param ray The ray\n * @return Dynamic scene.\n */\nScene sceneTransformation(Ray ray) {\n    Scene scene;\n    scene.plane = Plane(vec3(0.,0.,1.), vec3(0.,0.,0.),4);\n    \n    for (int i = 0; i < 9; i++) {\n        scene.tabRay[i] = ray;\n    }\n\n    // //Box homothethy\n    scene.nbBox = 1;\n    scene.tabBox[0] = Box(vec3(-4., -1., 2.), vec3(-2, 1., 4.), 2);\n    scene.tabScale[0] = vec3(1., sin(iTime+1.5*3.1415)+2., cos(iTime)+2.);\n    scene.tabRay[0] = Homothetie(scene.tabRay[0], scene.tabScale[0], FindTheCenter(scene.tabBox[0].bottomCorner, scene.tabBox[0].topCorner));\n\n    scene.nbTorus = 1;\n    scene.tabTorus[0] = Torus(vec3(0., 0., 0.), 1., .2, 7);\n    scene.tabRay[1] = Translation(scene.tabRay[1], vec3(0., 0., 4.));\n    scene.tabScale[1] = vec3(1., 1., 4.);\n    scene.tabAngle[1] = vec3(0.5*-iTime, 0., 0.);\n    scene.tabRay[1] = Rotation(scene.tabRay[1], scene.tabAngle[1], scene.tabTorus[0].center);\n    scene.tabRay[1] = Homothetie(scene.tabRay[1], scene.tabScale[1], scene.tabTorus[0].center);\n\n    scene.nbGoursat = 1;\n    scene.tabGoursat[0] = Goursat(vec3(0, 6, 1), 5); \n    scene.tabScale[2] = vec3(1.,2.,1.);\n    scene.tabRay[2] = Homothetie(scene.tabRay[2], scene.tabScale[2], scene.tabGoursat[0].center);\n\n    scene.nbOctaeder = 1;\n    scene.tabOctaeder[0] = Octaeder(vec3(0, -6, 2.2), 1);\n    scene.tabAngle[3] = vec3(0., iTime, 10.*iTime);\n    scene.tabRay[3] = Rotation(scene.tabRay[3], scene.tabAngle[3], scene.tabOctaeder[0].center);\n\n    return scene;\n}\n\n/**\n * @brief Creates a scene with spheres.\n * \n * @param ray The ray\n * @return Dynamic scene.\n */\nScene sceneSphere(Ray ray) {\n    Scene scene;\n    scene.plane = Plane(vec3(0.,0.,1.), vec3(0.,0.,0.),0);\n    \n    for (int i = 0; i < 10; i++) {\n        scene.tabRay[i] = ray;\n    }\n\n     scene.nbSphere = 4;\n     scene.tabSphere[0] = Sphere(vec3(-3, 0, 1), 1.5, 6);\n     scene.tabSphere[1] = Sphere(vec3(0.,-3.,1.),1.5,8);\n     scene.tabSphere[2] = Sphere(vec3(3.,0.,1.),1.5,6);\n     scene.tabSphere[3] = Sphere(vec3(0.,3.,1.),1.5,7);\n\n    return scene;\n}\n\n/**\n * @brief Creates a scene where we display our Textures.\n * \n * @param ray The ray\n * @return Dynamic scene.\n */\nScene sceneTexture(Ray ray) {\n    Scene scene;\n    scene.plane = Plane(vec3(0.,0.,1.), vec3(0.,0.,0.),0);\n\n    for (int i = 0; i < 10; i++) {\n        scene.tabRay[i] = ray;\n    }\n\n    scene.nbSphere = 1;\n    scene.nbEllipsoid = 1;\n    scene.nbCylinder = 1;\n    scene.nbCapsule = 1;\n    scene.nbBox = 1;\n    scene.nbTorus = 1;\n    scene.nbGoursat = 0;\n    scene.nbOctaeder = 0;\n    scene.nbPipeConnector = 0;\n    \n    scene.tabSphere[0] = Sphere(vec3(0.,-5.,1.), 2.,7);\n    scene.tabEllipsoid[0] = Ellipsoid(vec3(-4., -5., 4.5), vec3(1.,1.,0.5), 4);\n    scene.tabCylinder[0] = Cylinder(vec3(0.,3.,0.), vec3(0., 3., 2.1), .75, 3);\n    scene.tabCapsule[0] = Capsule(vec3(-2.,3.,2.), vec3(-4., 3., 3.), 0.5 ,2);\n    scene.tabBox[0] = Box(vec3(-4., -1.5, 0.), vec3(-2.1, 1.5, 5.), 5);\n    scene.tabTorus[0] = Torus(vec3(0., 0., 0.), 1., .5, 6);\n    scene.tabOctaeder[0] = Octaeder(vec3(0., 5., 3.), 1);\n    \n    return scene;\n}\n\nScene sceneMultiLight(Ray ray) {\n     /* RAPPEL : \n        ACTIVER MULTILIGHT DANS COLOR()\n        LES POSITIONS DE LUMIERES ET LEURS COULEURS SONT GERES DANS LA FONCTION COLOR()\n    */\n    Scene scene;\n    scene.plane = Plane(vec3(0.,0.,1.), vec3(0.,0.,0.),0);\n\n    for (int i = 0; i < 10; i++) {\n        scene.tabRay[i] = ray;\n    }\n\n    scene.nbSphere = 2;\n    scene.tabSphere[0] = Sphere(vec3(0.,-2.,1.), 1.,1);\n    scene.tabSphere[1] = Sphere(vec3(0.,2.,1.), 1.,1);\n\n    return scene;\n}\n\nScene sceneOA(Ray ray) {\n    /* RAPPEL : \n        POUR TESTER L'OA IL FAUT COMMENTER LA LIGNE `x = Hit(1000.,vec3(0),-1);`\n        DE LA FONCTION SHADE ET IL FAUT LA DECOMMENTER DE LA FONCTION INTERSECT\n    */\n    Scene scene;\n    scene.plane = Plane(vec3(0.,0.,1.), vec3(0.,0.,0.),0);\n\n    for (int i = 0; i < 10; i++) {\n        scene.tabRay[i] = ray;\n    }\n\n    scene.nbGoursat = 1;\n    scene.tabGoursat[0] = Goursat(vec3(0.,0.,2.5),1);\n\n    return scene;\n}\n\n/**\n * @brief Performs ray intersection with the scene.\n *\n * @param ray The ray to intersect with the scene object.\n * @param x Reference to the Hit structure, stores intersection information.\n * @return True if there is an intersection, false otherwise.\n */\nbool Intersect(Ray ray, inout Hit x) {\n\n    /* RAPPEL : \n    ON DECOMENTE ICI ET ON COMMENTE DANS LA FONCTION SHADE() ET ON PEUT VOIR L'OA \n    NOUBLIEZ DE MODIFER LA FONCTON COLOR POUR L'OA AUSSI\n    */\n    // x = Hit(1000., vec3(0.), -1);\n\n    Scene scene = sceneTransformation(ray);\n    Hit current;\n    bool ret=false;\n    int idR = 0;\n\n    if (IntersectPlane(ray,scene.plane,current) && current.t<x.t) {\n        x = current;\n        ret=true;\n    }\n\n    for (int i = 0; i < scene.nbSphere; i++) {\n        if (IntersectSphere(scene.tabRay[i + idR], scene.tabSphere[i], current)) {\n            if (scene.tabRay[i+idR].isHomo)\n                current = Homothetie(current, ray, scene.tabRay[i+idR], scene.tabScale[i+idR]);\n            if (current.t < x.t){\n                x = current;\n                if (scene.tabRay[i+idR].isRot)\n                    x.normal = RotationNormal(x.normal, -scene.tabAngle[i+idR], scene.tabSphere[i].center);\n                ret=true;\n            }\n        }\n    }\n    idR += scene.nbSphere;\n    \n    for (int i = 0; i < scene.nbEllipsoid; i++) {\n        if (IntersectEllipsoid(scene.tabRay[i + idR],scene.tabEllipsoid[i],current) && current.t<x.t) {\n            if (scene.tabRay[i+idR].isHomo)\n                current = Homothetie(current, ray, scene.tabRay[i+idR], scene.tabScale[i+idR]);\n            if (current.t < x.t){\n                x = current;\n                if (scene.tabRay[i+idR].isRot)\n                    x.normal = RotationNormal(x.normal, -scene.tabAngle[i+idR], scene.tabEllipsoid[i].center);\n                ret=true;\n            }\n        }\n    }\n    idR += scene.nbEllipsoid;\n\n    for (int i = 0; i < scene.nbCylinder; i++) {\n        if (IntersectCylinder(scene.tabRay[i + idR], scene.tabCylinder[i],current) && current.t<x.t) {\n            if (scene.tabRay[i+idR].isHomo)\n                current = Homothetie(current, ray, scene.tabRay[i+idR], scene.tabScale[i+idR]);\n            if (current.t < x.t){\n                x = current;\n                if (scene.tabRay[i+idR].isRot)\n                    x.normal = RotationNormal(x.normal, -scene.tabAngle[i+idR], FindTheCenter(scene.tabCylinder[i].bottomCenter, scene.tabCylinder[i].topCenter));\n                ret=true;\n            }\n        }\n    }\n    idR += scene.nbCylinder;\n\n    for (int i = 0; i < scene.nbCapsule; i++) {\n        if (IntersectCapsule(scene.tabRay[i + idR], scene.tabCapsule[i],current)&&current.t<x.t) {\n            if (scene.tabRay[i+idR].isHomo)\n                current = Homothetie(current, ray, scene.tabRay[i+idR], scene.tabScale[i+idR]);\n            if (current.t < x.t){\n                x = current;\n                if (scene.tabRay[i+idR].isRot)\n                    x.normal = RotationNormal(x.normal, -scene.tabAngle[i+idR], FindTheCenter(scene.tabCapsule[i].bottomCenter, scene.tabCapsule[i].topCenter));\n                ret=true;\n            }\n        }\n    }\n    idR += scene.nbCapsule;\n\n    for(int i = 0; i < scene.nbBox; i++) {\n        if (IntersectBox(scene.tabRay[i+idR], scene.tabBox[i], current)) {\n            if (scene.tabRay[i+idR].isHomo)\n                current = Homothetie(current, ray, scene.tabRay[i+idR], scene.tabScale[i+idR]);\n            if (current.t < x.t) {\n                x = current;\n                if(scene.tabRay[i+idR].isRot)\n                    x.normal = RotationNormal(x.normal, -scene.tabAngle[i+idR], FindTheCenter(scene.tabBox[i].bottomCorner, scene.tabBox[i].topCorner));\n                ret=true;\n            }\n        }\n    }\n    idR += scene.nbBox;\n\n    for (int i = 0; i < scene.nbTorus; i++) {\n        if (IntersectTorus(scene.tabRay[i + idR], scene.tabTorus[i], current)) {\n            if(scene.tabRay[i + idR].isHomo)\n                current = Homothetie(current, ray, scene.tabRay[i + idR], scene.tabScale[i + idR]);\n            if(current.t < x.t){\n                x = current;\n                if(scene.tabRay[i + idR].isRot)\n                    x.normal = RotationNormal(x.normal, -scene.tabAngle[i + idR], scene.tabTorus[i].center);\n                ret=true;\n            }\n        }\n    }\n    idR += scene.nbTorus;\n\n    for (int i = 0; i < scene.nbGoursat; i++) {\n        if (IntersectGoursat(scene.tabRay[i + idR], scene.tabGoursat[i], current)) {\n            if (scene.tabRay[i+idR].isHomo)\n                current = Homothetie(current, ray, scene.tabRay[i + idR], scene.tabScale[i+idR]);\n            if (current.t < x.t){\n                x = current;\n                if (scene.tabRay[i+idR].isRot)\n                    x.normal = RotationNormal(x.normal, -scene.tabAngle[i + idR], scene.tabGoursat[i].center);\n                ret=true;\n            }\n        }\n    }\n    idR += scene.nbGoursat;\n\n    for (int i = 0; i < scene.nbOctaeder; i++) {\n        if (IntersectOctaeder(scene.tabRay[i + idR], scene.tabOctaeder[i], current)) {\n            if (scene.tabRay[i + idR].isHomo)\n                current = Homothetie(current, ray, scene.tabRay[i + idR], scene.tabScale[i+idR]);\n            if (current.t < x.t){\n                x = current;\n                if (scene.tabRay[i + idR].isRot)\n                    x.normal = RotationNormal(x.normal, -scene.tabAngle[i + idR], scene.tabOctaeder[i].center);\n                ret=true;\n            }\n        }\n    }\n    idR += scene.nbOctaeder;\n\n    for (int i = 0; i < scene.nbPipeConnector; i++) {\n        if (IntersectPipeConnector(ray, scene.tabPipeConnector[i], current)) {\n            if (scene.tabRay[i + idR].isHomo)\n                current = Homothetie(current, ray, scene.tabRay[i + idR], scene.tabScale[i + idR]);\n            if (current.t < x.t){\n                x = current;\n                if (scene.tabRay[i + idR].isRot)\n                    x.normal = RotationNormal(x.normal, -scene.tabAngle[i + idR], scene.tabPipeConnector[i].center);\n                ret=true;\n            }\n        }\n    }\n    idR += scene.nbPipeConnector;\n    return ret;\n}\n\n/**\n * @brief Generates a random direction within a hemisphere oriented by a given normal.\n * \n * @param seed An integer seed value to determine the randomness of the direction.\n * @param normal The normal vector representing the orientation of the hemisphere.\n * @return vec3 A random direction vector within the hemisphere.\n */\nvec3 Hemisphere(int seed,vec3 normal) {\n    float a, b;\n    a = fract(sin(176.19 * float(seed)));// Uniform randoms\n    b = fract(sin(164.19 * float(seed)));\n    float u = 2. * 3.1415 * a;// Random angle\n    float v = acos(2. * b - 1.);// Arcosine distribution to compensate for poles\n    vec3 d = vec3(cos(u) * cos(v), sin(u) * cos(v), sin(v));// Direction\n    if (dot(d, normal) < 0.) { // Hemishper\n        d = -d; \n    }\n    return d;\n}\n\n/**\n * @brief Computes ambient occlusion at a given point on a surface.\n * \n * @param point The point on the surface for which ambient occlusion is calculated.\n * @param normal The surface normal at the specified point.\n * @param numSamples The number of samples to use for occlusion calculation.\n * @return float The ambient occlusion value in the range [0, 1].\n */\nfloat AmbientOcclusion(vec3 point, vec3 normal, int numSamples) {\n    if (numSamples == 0) {\n        return 1.;\n    }\n\n    float occ = 0.0;\n    \n    for (int i = 0; i < numSamples; i++) {\n        // Generate a random direction in a hemisphere around the normal\n        vec3 hemisphereDir = Hemisphere(i, normal);\n        \n        // Create a ray from the point in the direction of the hemisphereDir\n        Ray occRay = Ray(point + normal * 0.001, hemisphereDir, false, false);\n        \n        // Check for intersections with scene objects\n        Hit occHit;\n        occHit = Hit(.1, vec3(0.), -1);\n        bool hit = Intersect(occRay, occHit);\n        \n        // If no intersection, increase occlusion\n        if (hit && occHit.t < 3. ) {\n            occ += 1.0;\n        }\n    }\n\n    // Normalize occlusion value\n    occ /= float(numSamples) * 4.5;\n    \n    return occ;\n}\n\n/**\n * @brief Calculates the background color based on the viewing direction.\n * \n * @param rd The viewing direction vector.\n * @return vec3 The background color for the given viewing direction.\n */\nvec3 Background(vec3 rd) {\n    return mix(vec3(.8,.8,.9),vec3(.7,.7,.8),rd.z);\n}\n\n/**\n * @brief Creates a camera rotation matrix based on the camera origin and target point.\n * \n * @param ro The camera origin.\n * @param ta The target point that the camera is looking at.\n * @return mat3 The camera rotation matrix.\n */\nmat3 setCamera(in vec3 ro, in vec3 ta) {\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(0, 0, 1);\n    vec3 cu = -normalize(cross(cw, cp));\n    vec3 cv = -normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\n/**\n * @brief Sets up an array of lights with evenly distributed positions and colors.\n *\n * @param l an array of Light structures representing the lights. It is modified in place.\n * @param n The number of lights in one dimension (total number of lights = n * n).\n */\nvoid MultiLight(inout Light l[25], int n) {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            int index = i * n + j;\n            l[index].lightColor = vec3(1.0 / float(n * n), 1.0 / float(n * n), 1.0 / float(n * n));\n            l[index].lightPos = vec3(1.0 + float(i) / 10.0, 1.0 + float(j) / 10.0, 4.0);\n        }\n    }\n}\n\n/**\n * @brief Apply Phong Model to illuminate the scene and add object Shadows. \n * Can also permit you to see the OA with `if(true)` and `m.ambient` returned\n *\n * @param m Object material.\n * @param n The surface normal at the specified point.\n * @param p The point on the surface.\n * @param camera The camera ray.\n * @return The computed color for the specified point on the surface.\n */\nvec3 Color(Material m, vec3 n, vec3 p, Ray camera) {\n    /*RAPPEL : \n        Eclairage :     \n            UTILISES MULTILIGHT POUR LES OMBRES DEGRADES OU BIEN UTILISES 2 LUMIERES \n            POUR ECLAIRCIR LA SCENE\n\n        Voir OA : N'OUBLIEZ PAS D'AJOUTER `x = Hit(1000., vec3(0), -1);` dans Intersect()\n            et l'enlever de Shade(). \n            Decommenter le `if (true)` et commenter l'autre \n            `if (!Intersect(r, randomHit) ...)` et retourner m.ambient au lieu \n            de finalColor\n    */\n    Scene scene;\n\n    // OMBRE DEGRADE\n    // scene.nbLight = 25;\n    // MultiLight(scene.tabLight, 5);\n\n    // NOMBRE DE LUMIERES INITIALISES AVEC LES COORDOONES DE LUMIERES\n    scene.nbLight = 2;\n    scene.tabLight[0].lightPos = vec3(0,0,4);\n    scene.tabLight[0].lightColor = vec3(1,1,1);\n    scene.tabLight[1].lightPos = vec3(4,4,2);\n    scene.tabLight[1].lightColor = vec3(1,1,1);\n\n    // Rotation de lumiere sur l'axe z\n    Ray rotLight = Rotation(Ray(scene.tabLight[0].lightPos, vec3(0), false, false), vec3(0, 0, iTime), vec3(1, 0, 0));\n    // Pour faire une rotation sur la lumiere decommente cette ligne de code\n    // scene.tabLight[0].lightPos = rotLight.origin; \n    // scene.tabLight[1].lightPos = rotLight.origin; \n\n    Hit randomHit;\n    vec3 finalColor;\n\n    // Je dois calculer la lumiere spectrale et la lumiere diffus           \n    vec3 camDirection = normalize(camera.origin - p); // Direction de la caméra  \n    for (int i = 0; i < scene.nbLight; i++) {\n         vec3 lightDirection = normalize(scene.tabLight[i].lightPos - p);\n         Ray r = Ray(p + n * 0.001, lightDirection, false, false); // le rayon que j'envoie de point d'intersect de mon objet\n\n        randomHit = Hit( length(scene.tabLight[i].lightPos - p), vec3(0.), -1);\n    \n        if (!Intersect(r, randomHit) && randomHit.t >= length(scene.tabLight[i].lightPos - p)) {\n        //if (true) {\n            vec3 reflectDirection = reflect(-lightDirection, n);// Direction de réflexion de lumiere depuis mon objet   \n            \n            float spec = pow(max(dot(camDirection, reflectDirection), 0.0),  m.coefShininess);// coefficient de shininess contrôle la netteté du reflet             \n            vec3 specularColor = m.specular * spec * scene.tabLight[i].lightColor;// Éclairage speculaire             \n            \n            float diff = max(dot(n, lightDirection), 0.0);     \n            vec3 diffuseColor = m.diffuse * diff * scene.tabLight[i].lightColor;// Éclairage diffus\n\n            // Couleur a retourner\n            finalColor += (specularColor * (1. / float(scene.nbLight)) + diffuseColor);// / float(scene.nbLight);\n            // finalColor = m.ambient;\n        } else {\n            finalColor += vec3(0,0,0); \n        }   \n    }\n\n    float ao = AmbientOcclusion(p, n, 64); \n    return finalColor * (1. - ao );\n}\n\n// Rendering\nvec3 Shade(Ray ray) {\n    vec3 resultColor = vec3(0.0);\n\n    for (int reflection = 0; reflection < MAX_REFLECTION; reflection++) {\n        Hit x;\n        x = Hit(1000., vec3(0), -1);\n        bool idx = Intersect(ray, x);\n\n        if (idx) {\n            vec3 p = Point(ray, x.t);\n            Material mat = Texture(p, x.id);\n\n            // return x.normal;//débug normale\n\n            // Si le matériau est un miroir, calculez la couleur réfléchie\n            if (mat.reflexivity > 0.) {\n                vec3 n = x.normal;\n                vec3 reflectDir = reflect(ray.direction, n);\n                ray = Ray(p + n * 0.001, reflectDir, false, false);\n                resultColor += (1.0 - mat.reflexivity) * Color(mat, n, p, ray) + mat.mirrorColor;\n            }\n            else {\n                // Si ce n'est pas un miroir, calculez la couleur normale et terminez la boucle\n                resultColor += Color(mat, x.normal, p, ray);\n                break;\n            }\n        }\n        else {\n            // Si aucune intersection n'est trouvée, retournez la couleur d'arrière-plan\n            resultColor += Background(ray.direction);\n            break;\n        }\n    }\n\n    return resultColor;\n}\n\nvec3 ColorOriginal(Material m,vec3 n) {\n    vec3 light = normalize(vec3(10, 2, 5));\n    float diff = clamp(dot(n, light), 0., 1.);\n    vec3 col = m.diffuse * diff + vec3(.2,.2,.2);\n    return col;\n}\n\nvec3 ShadeOriginal(Ray ray) {\n    // Intersect contains all the geo detection\n    Hit x;\n\n    //DECOMMENTER SI VOUS ACTIVER L'OA SEULEMENT, A REMETTRE PAR LA SUITE\n    x = Hit(1000., vec3(0), -1);\n    bool idx=Intersect(ray,x);\n    \n    if(idx) {\n        vec3 p=Point(ray,x.t);\n        Material mat = Texture(p, x.id);\n        \n        return ColorOriginal(mat, x.normal);\n    }\n    else {\n        return Background(ray.direction);\n    }\n    return vec3(0);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) {\n    // From uv which are the pixel coordinates in [0,1], change to [-1,1] and apply aspect ratio\n    vec2 uv=(-iResolution.xy + 2.* fragCoord.xy) / iResolution.y;\n    \n    // Mouse control\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    // Ray origin\n    //défini la position de la cam\n    vec3 ro=13. * normalize(vec3(sin(2. * 3.14 * mouse.x), cos(2. * 3.14 * mouse.x), 1.4 * (mouse.y - .1)));\n    vec3 ta=vec3(0., 0., 1.5);\n    mat3 ca=setCamera(ro, ta);\n    \n    // Ray\n    vec3 rd = ca*normalize(vec3(uv.xy * tan(radians(22.5)), 1.));\n    \n    // Render\n    vec3 col = Shade(Ray(ro, rd, false, false));\n    \n    fragColor = vec4(col,1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}