{
    "Shader": {
        "info": {
            "date": "1595843190",
            "description": "Some ghosts floating around on the Cyber Space. Huge thanks to iq, I got into this because of his work on demoscene and graphics. I am actually using quite a few of his work, the cylinder sdf, the ao...\n\nUse your mouse to rotate the around.",
            "flags": 32,
            "hasliked": 0,
            "id": "3tlBRn",
            "likes": 18,
            "name": "Retro Vibes: Cyber Ghosts",
            "published": 3,
            "tags": [
                "retro",
                "crt"
            ],
            "usePreview": 0,
            "username": "NoxWings",
            "viewed": 752
        },
        "renderpass": [
            {
                "code": "#define USE_POST             1\n#define POST_INTENSITY       1.0 /* (sin(iTime)*0.5+0.5) */\n\n#define BARREL_DISTORTION    1\n#define SCAN_LINES\t\t\t 1\n#define CHROMATIC_ABERRATION 1\n#define VIGNETTE             1\n\n\nfloat crtCurve(in vec2 uv)\n{\n    float domeCurvature = 2.0;\n    float domex = 1.0 - pow(abs(uv.x), domeCurvature);\n    float domey = 1.0 - pow(abs(uv.y), domeCurvature);\n    return domex * domey;\n}\n\nvec2 crtDistortedUV(in vec2 uv, in float strength)\n{\n    vec2 s = 1.0/iResolution.xy;\n    vec2 offset = vec2(1, 0);\n    \n    float p = crtCurve(uv);\n    float h1 = crtCurve(uv + s * offset.xy);\n    float v1 = crtCurve(uv + s * offset.yx);\n       \n   \treturn uv - (p - vec2(h1, v1)) * strength;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord/iResolution.xy);\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv2 = uv * 2.0 - 1.0;\n    vec2 texUV = uv;\n    vec3 color = vec3(0);\n    \n#if USE_POST == 1\n    #if BARREL_DISTORTION == 1\n    {\n        float distortion = 30.0;\n        distortion = mix(0.0, distortion, POST_INTENSITY);\n        vec2 compression = distortion / vec2(300.0, 200.0);\n        \n        // Compression\n        uv2 *= 1.0 + compression;\n        // Distortion\n        uv2 = crtDistortedUV(uv2, distortion);\n        \n        if (abs(uv2.x) > 1.0 || abs(uv2.y) > 1.0) \n        {\n            fragColor = vec4(vec3(0), 1.0);\n            return;\n        }\n        \n        texUV = uv2 * 0.5 + 0.5;\n    }\n    #endif\n#endif\n      \n    vec4 buffer = texture(iChannel0, texUV);\n    color = buffer.rgb;\n\n#if USE_POST == 1\n    #if CHROMATIC_ABERRATION == 1\n    {\n\t\tfloat intensity = 0.00007 * POST_INTENSITY;\n        float lensDistortion = 0.4; \n        \n        float radialIntensity = pow(length(uv2), lensDistortion);\n    \tvec2 radialDirection = normalize(uv2);\n        \n\t    vec3 waveLengths = vec3(440, 575, 650);\n\t    vec3 offsets = (waveLengths.g - waveLengths) * intensity * radialIntensity;\n        \n        float mixed = clamp(length(uv2) + 0.1, 0.0, 1.0);\n               \n    \tcolor.r = mix(color.r, texture(iChannel0, texUV + radialDirection * offsets.r).r, mixed);\n    \tcolor.b = mix(color.b, texture(iChannel0, texUV + radialDirection * offsets.b).b, mixed);       \n    }\n    #endif\n    \n\t#if VIGNETTE == 1\n    {\n    \tfloat radial = 1.0 - clamp(-0.2 + pow(length(uv2 / 1.4), 2.2), 0.0, 1.0);\n        radial = mix(1.0, radial, POST_INTENSITY);\n    \tcolor.rgb *= vec3(radial);\n    }\n    #endif\n    \n    #if SCAN_LINES == 1\n    {\n        float lines = iResolution.y / 4.0;\n        float scan = smoothstep(0.03, 0.2, fract(uv.y * lines));\n        scan = mix(1.0, scan, POST_INTENSITY);\n\t    color *= scan;\t\n    }\n    #endif\n#endif\n    \n    color = pow(color, vec3(0.4545));\n    fragColor = vec4(color.rgb, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define FAR_PLANE 50.0\n#define EPSILON 0.01\n#define t iTime\n\n//#define DEBUG_TEXTURE_FILTERING\n\n// -----------------------------------------------------------------------------\n// Math\n\n#define PI 3.1416\n#define HALF_PI PI / 2.0\n#define TAU PI * 2.0\n#define DEG2RAD TAU/360.\n\n#define S(x, y, z) smoothstep(x, y, z)\n\nmat3 lookAtMatrix(in vec3 lookAtDirection) \n{\n\tvec3 ww = normalize(lookAtDirection);\n    vec3 uu = cross(ww, vec3(0.0, 1.0, 0.0));\n    vec3 vv = cross(uu, ww);\n    return mat3(uu, vv, -ww);\n}\n\n// -----------------------------------------------------------------------------\n// Camera\n\nstruct Camera {\n    vec3 position;\n\tvec3 direction;\n};\n\nCamera createOrbitCamera(vec2 uv, vec2 mouse, vec2 resolution, float fov, vec3 target, float height, float distanceToTarget)\n{\n    vec2 r = mouse / resolution * vec2(3.0 * PI, 0.5 * PI);\n    float halfFov = fov * 0.5;\n    float zoom = cos(halfFov) / sin(halfFov);\n    \n    vec3 position = target + vec3(sin(r.x), 0.0, cos(r.x)) * distanceToTarget + vec3(0, height, 0);\n    vec3 direction = normalize(vec3(uv, -zoom));\n    direction = lookAtMatrix(target - position) * direction;\n    \n    return Camera(position, direction);\n}\n\n// -----------------------------------------------------------------------------\n// Scene\n\n#define SKY 0\n#define FLOOR 1\n#define GHOST_EYE 2\n#define GHOST_PUPIL 3\n#define GHOST_BODY1 4\n#define GHOST_BODY2 5\n#define GHOST_BODY3 6\n\nstruct Entity {\n    int id;\n\tfloat d;\n};\n\nEntity emin(Entity a, Entity b)\n{\n    if (a.d < b.d) return a; return b;\n}\n\nEntity emax(Entity a, Entity b)\n{\n    if (a.d > b.d) return a; return b;\n}\n\nfloat sdSphere(in vec3 p, float radius)\n{\n    return length(p) - radius;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane(in vec3 p, float height)\n{\n    return p.y + height;\n}\n\nEntity ghost(in vec3 p, in int bodyId) \n{        \n    float rand = float(bodyId * 3);\n    vec3 q = p + vec3(0, sin((rand-1.)*7. + t * 5.0) * 0.1, 0);\n    \n    // BODY\n    float body = sdCappedCylinder(q - vec3(0.0, -1.0, 0.0), 1.0, 1.0);\n    Entity ghost = Entity(bodyId, body);\n    float head = sdSphere(q, 1.0);\n    ghost.d = min(ghost.d, head);\n    \n    float bv = 0.5;\n    if (ghost.d > bv) {\n        ghost.d = ghost.d - bv * 0.5;\n        return ghost;\n    }\n    \n    // BODY FLUCTUATION\n    float majorModChangeFreq = 5.0;\n    float repeat = 6.5;\n    float fluctuationHeight = 2.0;\n    float fluctuationRaymarchSpeed = 0.5;\n    vec2 movement = normalize(vec2(1.0, 1.0)) * 15.0;\n    \n    float fluctuation = (0.9 + 0.2 * sin(rand + t * majorModChangeFreq))\n        \t* sin(rand + q.x * repeat + t * movement.x)\n            * sin(rand + q.z * repeat + t * movement.y)\n         \t* fluctuationHeight;\n    \n    float fluctuationPlane = sdPlane(q, 1.1 - 0.1 * fluctuation) * fluctuationRaymarchSpeed;\n    ghost.d = max(ghost.d, -fluctuationPlane);\n    \n    // EYES\n    vec3 eyesCoord = vec3(abs(q.x), q.yz);\n    Entity eyes = Entity(GHOST_EYE, sdSphere(eyesCoord - vec3(0.35, 0.2, 0.7), 0.3));\n    \n    ghost = emin(ghost, eyes);\n    \n    // PUPILS\n    \n    Entity pupils = Entity(GHOST_PUPIL, sdSphere(eyesCoord - vec3(0.37, 0.23, 0.82), 0.2));\n    ghost = emin(ghost, pupils);\n    \n    return ghost;\n}\n\nEntity scene(in vec3 p)\n{\n    Entity scene;\n    Entity plane = Entity(FLOOR, sdPlane(p, 1.0)); scene = plane;\n    Entity ghost1 = ghost(p - vec3(-2.0,  1.0, -1.5), GHOST_BODY1); scene = emin(scene, ghost1);\n    Entity ghost2 = ghost(p - vec3(0.0,  1.2,  0.0), GHOST_BODY2); scene = emin(scene, ghost2);\n    Entity ghost3 = ghost(p - vec3(2.0, 1.0, -1.5), GHOST_BODY3); scene = emin(scene, ghost3);\n    \n    return scene;\n}\n\n// -----------------------------------------------------------------------------\n// Normals\n\nvec3 sceneNormal(in vec3 p)\n{\n    vec2 offset = vec2(EPSILON, 0);\n    float d = scene(p).d;\n    return normalize(vec3(\n\t\td - scene(p - offset.xyy).d,\n        d - scene(p - offset.yxy).d,\n        d - scene(p - offset.yyx).d\n    ));\n}\n\n// -----------------------------------------------------------------------------\n// Shading\n\nfloat calcAO( in vec3 pos, in vec3 nor ) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ ) {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = scene( aopos ).d;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nfloat traceShadow(in vec3 ro, in vec3 rd, float hardness)\n{\n    float d = EPSILON * 2.0;\n    float k = hardness;\n    float res = 1.0;\n    \n    for (int i=0; i < 128 && d <= FAR_PLANE; i++)\n    {\n        vec3 p = ro + rd * d;\n        float stepDistance = scene(p).d;\n        \n        if (stepDistance < EPSILON) return 0.0;\n        \n        res = min(res, k * stepDistance / d);\n        d += stepDistance;\n    }\n    \n    return clamp(res, 0.0, 1.0);\n}\n\nvec3 shading(vec3 p, vec3 n, vec3 diffuseColor)\n{\n    vec3 sunColor = vec3(6.0);\n    vec3 sunDirection = normalize(vec3(1.0, 1.0, 1.0));\n    \n    float shadowOcclusion = traceShadow(p +  n * EPSILON * 2.0, sunDirection, 28.);\n    float ao = calcAO(p, n);\n    \n    vec3 ambientColor = vec3(0.1) * ao;\n    vec3 diffuse = clamp(dot(n, sunDirection), 0.0, 1.0) * sunColor;\n\n    return (ambientColor + shadowOcclusion * diffuse) * diffuseColor;\n}\n\nvec3 getFloorColor(vec2 uv)\n{\n    vec3 lineColor = vec3(0.43, 0.0, 0.5);\n    vec3 backgroundColor = vec3(0.0005, 0.001, 0.001);\n    float lineWidth = 0.05;    \n    float tiling = 0.2;\n    \n    vec2 cellUV = fract(vec2(0.5, t / 2.0) + uv * tiling) * 2.0 - 1.0;\n    \n    float grid = smoothstep(1.0 - lineWidth, 1.0, max(abs(cellUV.x), abs(cellUV.y)));\n    \n    float radialGradient = S(10.0, 50.0, length(uv));\n    \n    return grid * mix(lineColor, backgroundColor, radialGradient) + (1.0 - grid) * backgroundColor; \n}\n\n// https://iquilezles.org/articles/filtering\nvec3 getFloorFiltered(vec2 uv)\n{\n    float detail = 15.;\n    int maxSamples = 4;\n    \n    vec2 uvX = dFdx(uv);\n    vec2 uvY = dFdy(uv);\n    \n    int sx = 1 + int( clamp(detail * length(uvX), 0.0, float(maxSamples - 1)) );\n    int sy = 1 + int( clamp(detail * length(uvY), 0.0, float(maxSamples - 1)) );\n    \n    vec3 value = vec3(0);\n    for(int i=0; i<sx; i++)\n    for(int j=0; j<sy; j++) {\n        vec2 offset = vec2(float(i), float(j)) / vec2(float(sx), float(sy));       \n        value += getFloorColor(uv + offset.x * uvX + offset.y * uvY);\n    }\n    \n    #ifdef DEBUG_TEXTURE_FILTERING\n    return vec3(float(sx*sy) / float(maxSamples * maxSamples));\n    #endif\n    \n    return value / float(sx*sy);\n}\n\nvec3 getMaterialColor(Entity e, vec3 p, vec3 n)\n{\n    vec3 topColor = vec3(0.18, 0.05, 0.01);\n    vec3 botColor = vec3(0.10, 0.005, 0.001);\n    \n    vec3 color = vec3(0);\n    \n    if (e.id == FLOOR)\n    {\n        color = getFloorFiltered(p.xz);\n    }\n    else if (e.id == GHOST_BODY1)\n    {\n        color = mix(botColor.rbb, topColor.rbb, S(0.0, 1.5, p.y));\n    }\n    else if (e.id == GHOST_BODY2)\n    {\n        color = mix(botColor.bgr, topColor.bgr, S(0.0, 1.5, p.y));\n    }\n    else if (e.id == GHOST_BODY3)\n    {\n        color = mix(botColor.grb, topColor.grb, S(0.0, 1.5, p.y));\n    }\n    else if (e.id == GHOST_EYE)\n    {\n        color = vec3(0.18, 0.18, 0.18);\n    }\n    else if (e.id == GHOST_PUPIL)\n    {\n        color = vec3(0.01, 0.01, 0.01);\n    }\n    \n    return shading(p, n, color); \n}\n\n// -----------------------------------------------------------------------------\n// Raymarching - SphereTracing\n\nEntity trace(vec3 origin, vec3 direction)\n{\n    Entity res = Entity(SKY, 0.0);\n    \n    for (int i = 0; i < 512 && res.d <= FAR_PLANE; i++)\n    {\n        vec3 p = origin + direction * res.d;\n        Entity closestEntity = scene(p);\n        \n        res.id = closestEntity.id;\n        res.d += closestEntity.d;\n        \n        if (closestEntity.d < EPSILON) \n        {\n            return res;\n        }\n    }\n    \n    res.id = SKY;\n    res.d = FAR_PLANE;\n    return res;\n}\n\n// -----------------------------------------------------------------------------\n// Main\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float camHeight = 1.0;\n    float vFOV = 60.0 * DEG2RAD + cos(iTime) * 10.0 * DEG2RAD;\n    float distanceToTarget = 8.0 + sin(iTime) * 1.0;\n    vec3 target = vec3(0, 0.5, 0);\n    Camera cam = createOrbitCamera(uv, iMouse.xy, iResolution.xy, vFOV, target, camHeight, distanceToTarget);\n    \n    vec3 ro = cam.position;\n    vec3 rd = cam.direction;\n    \n    Entity e = trace(ro, rd);\n  \n    vec3 p = ro + rd * e.d;\n    vec3 n = sceneNormal(p);\n    \n    vec3 col = vec3(0);\n\n    if (e.id == SKY)\n    {\n        vec3 skyTopColor = vec3(0.05, 0.1, 1.0);\n        vec3 skyHorizonColor = vec3(0.7, 0.1, 0.8);\n        col = mix(skyTopColor, skyHorizonColor, exp(-8.0*rd.y));\n    } else {\n        col = getMaterialColor(e, p, n);\n    }\n    \n    fragColor = vec4(col, 0.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}