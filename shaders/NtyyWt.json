{
    "Shader": {
        "info": {
            "date": "1671043591",
            "description": "Psytrance plasma",
            "flags": 0,
            "hasliked": 0,
            "id": "NtyyWt",
            "likes": 3,
            "name": "Psychedelic plasma rogo1965",
            "published": 3,
            "tags": [
                "voronoi",
                "plasma"
            ],
            "usePreview": 0,
            "username": "rogo1965",
            "viewed": 215
        },
        "renderpass": [
            {
                "code": "\n#define DISCO 1\n#define time iTime*.05+300.\n#define tau 6.2831\nvec2 hash( vec2 p )\n{\n    //p = mod(p, 4.0); // tile\n    p = vec2(dot(p,vec2(127.1,311.7)),\n             dot(p,vec2(269.5,183.3)));\n    \n    return fract(sin(p)*18.5453);\n}\n\n\n\n\n// Compact, self-contained version of IQ's 2D value noise function.\nfloat n2D(vec2 p){\n   \n    // Setup.\n    // Any random integers will work, but this particular\n    // combination works well.\n    const vec2 s = vec2(1, 113);\n    // Unique cell ID and local coordinates.\n    vec2 ip = floor(p); p -= ip;\n    // Vertex IDs.\n    vec4 h = vec4(0., s.x, s.y, s.x + s.y) + dot(ip, s);\n   \n    // Smoothing.\n    p = p*p*(3. - 2.*p);\n    //p *= p*p*(p*(p*6. - 15.) + 10.); // Smoother.\n   \n    // Random values for the square vertices.\n    h = fract(sin(h)*43758.5453);\n   \n    // Interpolation.\n    h.xy = mix(h.xy, h.zw, p.y);\n    return mix(h.x, h.y, p.x); // Output: Range: [0, 1].\n}\n// FBM -- 4 accumulated noise layers of modulated amplitudes and frequencies.\nfloat fbm(vec2 p){ return n2D(p)*.533 + n2D(p*2.)*.267 + n2D(p*4.)*.133 + n2D(p*8.)*.067; }\n\n\n// return distance, and cell id\nvec2 voronoi( in vec2 x )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tvec3 m = vec3( 8.0 );\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec2  o = hash( n + g );\n      //vec2  r = g - f + o;\n\t    vec2  r = g - f + (0.5+0.5*sin(time+tau*o));\n\t\tfloat d = dot( r, r );\n        if( d<m.x )\n            m = vec3( d, o );\n    }\n\n    return vec2( sqrt(m.x), m.y+m.z );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy/max(iResolution.x,iResolution.y);\n    p-=20.;\n    p.x+=22.*sin(0.1*iTime)/15.;\n    p.y+=22.*cos(0.1*iTime)/15.;\n    p *= .9;\n    //p.y+=.45;\n    // compute voronoi patterm\n    vec2 c = p/20.*voronoi( (8.0+2.0*sin(0.2*time))*p*fbm(p) );\n    //c = c-voronoi( (8.0+2.0*sin(0.2*time))*p*fbm(p) );\n\n    vec2 stt =  vec2(atan(c.x,p.y), length(p));\n    #if DISCO\n    stt = stt+voronoi( (1.0+2.0*sin(0.2*time))*p*fbm(p) );\n    #endif\n    // colorize\n    //vec3 col =  vec3(c.y,c.x,1.-p.x) ;\t\n    vec3 col = 0.5 + 0.5*cos( stt.y*stt.x*6.2831 + vec3(0.0,smoothstep( 0.08, 0.7, fbm(stt)),smoothstep( 0.7, 0.9, fbm(stt))) );\t\n    // gradient\n    //col *= clamp(1.0 - 0.4*c.x*c.x,0.0,1.0);\n    col *= vec3(0.5+0.5*cos(44.*time),0.5+0.5*sin(22.*time),0.5+0.5*sin(11.*time));\n    // dots\n    //col -= (1.0-smoothstep( 0.08, 0.09, c.x));\n    \n    // the matrix color effect\n    col.r = pow(col.r,3./2.);\n    col.g = pow(col.g,4./5.);\n    col.g = pow(col.g,3./2.);\n\t\n    fragColor = vec4( col, 1.0 );\n   \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}