{
    "Shader": {
        "info": {
            "date": "1629791349",
            "description": "Something Logarithmic - not it's final form - but another good experiment in raymarching log spherical warps. The texture gets crunchy near the center - but not sure how to fix.",
            "flags": 0,
            "hasliked": 0,
            "id": "fscGWr",
            "likes": 33,
            "name": "Something Logarithmic",
            "published": 3,
            "tags": [
                "raymarching",
                "animation",
                "truchet",
                "logarithmic"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 610
        },
        "renderpass": [
            {
                "code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n        \n    Something Logarithmic\n    @byt3_m3chanic 08/24/21\n    \n    More ray marching a log spherial mapped animated\n    truchet tile system. More learning shader and \n    something to keep in my toolbox for later use.\n    \n    fun to play with tile size (sz) and density\n    \n    found post online on Log Spherical Warping \n    https://www.osar.fr/notes/logspherical/\n    \n*/\n\n#define R\t\t\tiResolution\n#define T\t\t\tiTime\n#define M\t\t\tiMouse\n\n#define PI2\t\t\t6.28318530718\n#define PI\t\t\t3.14159265358\n\n#define MAX_DIST \t85.\n#define MIN_DIST\t.0001\n\nfloat hash21(vec2 p){ return fract(sin(dot(p,vec2(26.34,45.32)))*4324.23); }\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// constants \nconst float sz = 2.,hl = sz*.5;\nconst vec2 boxSize = vec2(sz*.475,.12);\n\nconst float density = 10.;\nconst float dshalf = density/2.;\n\n//globals and stuff\nvec3 hit, hitPoint;\nvec2 sid, cellId;\nfloat shorten = 1., lpscale, movement, trackspeed, time;\nmat2 turn;\n\nvec2 map(vec3 q){\n    vec2 res = vec2(1e5,0.);\n\n    vec3 p = q;\n    p.xz*=turn;\n\n    // log-spherical map\n    float r = length(p);\n    float mul = r/lpscale;\n    p = vec3(log(r), acos(p.y / r ), atan(p.z, p.x));\n    p *= lpscale;\n    p -= vec3(movement,dshalf,hl);\n    \n    vec2 id = floor((p.xz+hl)/sz);\n    p.xz = mod(p.xz+hl,sz)-hl;\n\n    float hs = hash21(id);\n    float dir = mod(id.y + id.x,2.) <.5 ? -1. : 1.;\n\n    if(hs>.5) p.x *= -1.;\n    // get closest point and make vector for 1/4 torus\n    vec2 d2 = vec2(length(p.xz - hl), length(p.xz + hl));  \n    vec2 pp = d2.x<d2.y ? vec2(p.xz - hl) : vec2(p.xz + hl);\n    float pth = abs(min(d2.x, d2.y) - hl);\n\n    float tr = length(vec2(pth, p.y+.15))-.25;\n    float bx = box(p,boxSize.xyx)-.025;\n\n    bx = max(bx,-tr);\n    if(bx<res.x) {\n        res = vec2(bx,3.);\n        sid = id;\n        hit = p;\n    }\n    \n    //balls\n    pp *= rot(trackspeed*dir);\n     \n    float amt = 4.;\n    float dbl = 8.;\n    \n    float a = atan(pp.y, pp.x);\n    // make id\n    float ai = floor(dir*a/PI*amt);\n    a = (floor(a/PI2*dbl) + .5)/dbl;\n    vec2 qr = rot(-a*PI2)*pp; \n    qr.x -= hl;\n\n    vec3 bq = vec3(qr.x, p.y+.15, qr.y);\n   \n    float sph = length(bq)-.1;\n    \n    if(sph<res.x) {\n        res = vec2(sph,4.);\n        sid = vec2(ai,dir);\n        hit = bq;\n    }\n\n    res.x *= mul/shorten;\n    return res;\n} \n// @iq https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t){\n    float e = t*MIN_DIST;\n    vec2 h = vec2(1.,-1.)*.5773;\n    return normalize( h.xyy*map( p + h.xyy*e).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e).x + \n\t \t\t\t\t  h.xxx*map( p + h.xxx*e).x );\n}\n//@iq https://iquilezles.org/articles/palettes\nconst vec3 c = vec3(0.959,0.970,0.989),\n           d = vec3(0.067,0.812,0.910);\nvec3 hue(float t){ \n    return .45 + .45*cos(PI2*t*(c+d) ); \n}\n\nvec4 FC= vec4(0.000,0.000,0.000,0.);\nvec3 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, inout float d) {\n    \n    vec3 C = vec3(0);\n    vec3 p = ro;\n    float m = 0.;\n    \n    // marcher\n    for(int i=0;i<150;i++) {\n        p = ro + rd * d;\n        vec2 ray = map(p);\n        if(abs(ray.x)<MIN_DIST*d||d>MAX_DIST)break;\n        d += i<128? ray.x*.5: ray.x * .75;\n        m  = ray.y;\n    } \n    \n    cellId = sid;\n    hitPoint = hit;\n    \n    float alpha = 0.;\n    if(d<MAX_DIST) {\n    \n        vec3 p = ro + rd * d;\n        vec3 n = normal(p,d);\n        vec3 lpos = vec3(2.0,5.0,3.85);\n        vec3 l = normalize(lpos-p);\n        \n        vec3 h = vec3(.5);\n\n        float diff = clamp(dot(n,l),.03,1.);\n        float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 9.);\n        fresnel = mix(.01, .9, fresnel);\n\n        float shdw = 1.;\n        float t=.0;\n        for( float i=.01; i < 32.;i++ ){\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 24.*h/t);\n            t += h;\n            if( shdw<MIN_DIST || t>32. ) break;\n        }\n        diff = mix(diff,diff*shdw,.65);\n        \n        vec3 view = normalize(p - ro);\n        vec3 ret = reflect(normalize(lpos), n);\n        float spec =  0.5 * pow(max(dot(view, ret), 0.), 24.);\n        \n        h = vec3(1);\n\n        if(m==3.) {\n            vec3 uv = hitPoint;\n            float px  = fwidth(uv.x*1.75);\n            \n            vec2 id = cellId;\n            vec2 grid = uv.xz;\n            float hs = hash21(id);\n            float chk = mod(id.y + id.x,2.) * 2. - 1.;\n\n            vec2 d2 = vec2(length(grid-hl), length(grid+hl));\n            vec2 gx = d2.x<d2.y? vec2(grid-hl) : vec2(grid+hl);\n            float pth = abs(min(d2.x,d2.y)-hl);\n            vec2 vuv = vec2(pth, uv.z);\n            \n            float back = length(gx)-hl;\n            back=(chk>0.^^ hs>.5) ? smoothstep(-px,px,back) : smoothstep(px,-px,back);\n            \n            vec2 pid = floor(grid*4.);\n            vec2 puv = fract(grid*4.)-.5;\n            float fs = hash21(pid);\n            if(fs>.5)puv.x*=-1.;\n            vec2 d5 = vec2(length(puv-.5), length(puv+.5));\n            vec2 kx = d5.x<d5.y? vec2(puv-.5) : vec2(puv+.5);\n            \n            float ptrn = length(kx)-.5;\n            ptrn = smoothstep(px,-px,abs(abs(abs(abs(ptrn)-.1)-.1)-.1)-.05);\n            vec3 c2 = hue((10.+cellId.x*.05) );\n            vec3 c3 = hue((1. -cellId.x*.075) );\n            vec3 c4 = hue((cellId.x)*.05);\n            \n            h = mix(c3,mix(c3, c2,ptrn),back);\n            \n            float circle4;\n            float circle2 = length(gx)-hl;\n            float circle3 = smoothstep(px,-px,abs(circle2)-.13);\n            circle4 = smoothstep(px,-px,abs(abs(abs(circle2)-.2)-.065)-.012);\n            circle2 = smoothstep(px,-px,abs(abs(circle2)-.125)-.15);\n            \n            h=mix(h,vec3(.4),circle2);\n            h=mix(h,c4,circle3);\n            h=mix(h,vec3(0),circle4);\n \n            ref = mix(vec3(0),h-fresnel,circle2);\n        }\n\n        if(m==4.) {\n            h=mod(cellId.x+25.,2.)==0.?vec3(.03):vec3(.9);\n            ref = h-fresnel;\n        }\n        \n        C = diff*h+spec;\n        \n        ro = p+n*.001;\n        rd = reflect(rd,n);\n        \n    } else {\n        C = FC.rgb;\n    }\n    return C;\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n    // precal\n    time = iTime;\n  \n    lpscale = floor(density)/PI;\n    turn = rot(time*5.*PI/180.);\n\n    trackspeed = .75*time;\n    movement = .95*T*lpscale*.125;\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,0,9.);\n    vec3 rd = normalize(vec3(uv,-1));\n    \n    float y = M.xy == vec2(0) ? 0. : (M.x/R.x * 1. - .5) * PI;\n    \n    mat2 rx = rot(.8+.1*sin(time*.1));\n    mat2 ry = rot(y);\n    \n    ro.yz *= rx;ro.xz *= ry;\n    rd.yz *= rx;rd.xz *= ry;\n    \n    vec3 C = vec3(0);\n    vec3 ref=vec3(0);\n    vec3 fill=vec3(1.);\n    \n    float d =0.;\n    //@BigWIngs - reflection loop\n    for(float i=0.; i<2.; i++) {\n        vec3 pass = render(ro, rd, ref, d);\n        C += pass*fill;\n        fill*=ref;\n        if(i==0.) FC = vec4(FC.rgb,exp(-.00015*d*d*d));\n    }\n\n    C = mix(C,FC.rgb,1.-FC.w);\n    C = clamp(C,vec3(MIN_DIST),vec3(1));\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n// end",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}