{
    "Shader": {
        "info": {
            "date": "1633905330",
            "description": "The scene consists in one plane, one sphere at the center, and 5 spheres orbiting around it. The distance from a point to the scene is pretty easy to compute, but I added the twist of smoothing the min function so that objects blur one into another.",
            "flags": 0,
            "hasliked": 0,
            "id": "sdtXDB",
            "likes": 3,
            "name": "Jumping blobs",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "smoothmin",
                "smoothmax",
                "directionallight"
            ],
            "usePreview": 0,
            "username": "ninofiliu",
            "viewed": 322
        },
        "renderpass": [
            {
                "code": "const int MAX_STEPS = 100;\nconst float MIN_DISTANCE = 0.0001;\nconst float MAX_DISTANCE = 50.0;\nconst float EPSILON_NORMAL = 0.01;\n    \nvec3 getRay(vec2 fragCoord, vec3 camera, vec3 lookAt) {\n    const float zoom = 1.5;\n    vec2 uv = (fragCoord - (iResolution.xy / 2.0)) / iResolution.y;\n    vec3 c = normalize(lookAt - camera);\n    vec3 u = vec3(c.y, -c.x, 0.0);\n    vec3 v = normalize(vec3(c.z*c.x, c.z*c.y, c.x*c.x+c.y*c.y));\n    return normalize(c + (uv.x * u + uv.y * v) / zoom);\n}\n\nbool isInSphere(vec3 camera, vec3 ray, vec3 center, float radius) {\n    float d = distance(camera, center);\n    float dp = dot(ray, center-camera);\n    return dp*dp > d*d-radius*radius;\n}\n\nfloat getDS(vec3 marcher) {\n    const int len = 7;\n    const float a = 3.0;\n    \n    float mins[len];\n    \n    mins[0] = marcher.z;\n    mins[1] = distance(marcher, vec3(0.0, 0.0, 0.7)) - 1.0;\n    int nb = len - 2;\n    for (int i = 0; i < len-2; i++) {\n        float angle = radians(270.0 * float(i) / float(nb));\n        vec3 center = vec3(cos(angle), sin(angle), 0.5+1.0*sin(3.0*iTime+float(i)));\n        mins[2+i] = distance(marcher, center) - 0.7;\n    }\n    \n    float sa = 0.0;\n    float sb = 0.0;\n    for (int i = 0; i < len; i++) {\n        sa += mins[i] * exp(-a * mins[i]);\n        sb += exp(-a * mins[i]);\n    }\n    \n    return sa / sb;\n}\n\nvec3 march(vec3 camera, vec3 ray) {\n    vec3 marcher = camera;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float ds = getDS(marcher);\n        if (ds < MIN_DISTANCE || ds > MAX_DISTANCE) { break; }\n        marcher += ds * ray;\n    }\n    return marcher;\n}\n\nvec3 getNormal(vec3 camera, vec3 ray) {\n    vec3 surface = march(camera, ray);\n    float dx = getDS(surface+vec3(EPSILON_NORMAL, 0.0, 0.0));\n    float dy = getDS(surface+vec3(0.0, EPSILON_NORMAL, 0.0));\n    float dz = getDS(surface+vec3(0.0, 0.0, EPSILON_NORMAL));\n    return normalize(vec3(dx, dy, dz));\n}\n\nfloat getLight(vec3 camera, vec3 ray) {\n    vec3 source = vec3(4.0, 0.0, 5.0);\n    vec3 surface = march(camera, ray);\n    vec3 normal = getNormal(camera, ray);\n    return -dot(normal, normalize(surface-source));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float speed = 0.7;\n    vec3 camera = vec3(5.0 * vec2(cos(speed*iTime), sin(speed*iTime)), 1.0);\n    vec3 lookAt = vec3(0.0, 0.0, 0.5);\n    vec3 ray = getRay(fragCoord, camera, lookAt);\n    \n    fragColor = vec4(vec3(0.0), 1.0);\n    fragColor.rgb += 0.5+0.5*getLight(camera, ray);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}