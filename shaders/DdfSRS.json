{
    "Shader": {
        "info": {
            "date": "1669072407",
            "description": "Variation on nice idea by Hatchling: [url]https://www.shadertoy.com/view/mdsSD7[/url] - just keep track of the current \"writing position\" and only draw the box containing the current pixel. \n\nShows data under mouse (or screen centre until mouse pressed).",
            "flags": 16,
            "hasliked": 0,
            "id": "DdfSRS",
            "likes": 8,
            "name": "Text Console Demo II",
            "published": 3,
            "tags": [
                "text",
                "font",
                "console",
                "sh17b"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 960
        },
        "renderpass": [
            {
                "code": "// Adding debug output to a shader, basic idea from Hatchling\n\nvoid print(float x); // The debug function, definition down below\n\n// Original shader by Trisomie21\n\nvec2 Path(vec2 x) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tf = f*f*(3.-2.*f);\n\treturn textureLod(iChannel2, (p+vec2(37.5,17.5) + f)/256.0, 0.).xy;\n}\n\n#define S(x) vec4(Path(x*vec2(.04,.1))*vec2(6,9),0,0)\n\nvec4 mainimage(in vec2 C ) {\n    vec4 o = vec4(0);\n    vec4 p = vec4(C.xy,0,0)/iResolution.xyxy-.5, d=p, t, c, s;\n    p.z += iTime*8.;\n    p -= S(p.z);\n    float x, r, w, i;\n    for(i=1.5; i>0.; i-=.01)\n    {\n        // Select one of 5 type of wood beam separation\n        vec2 z = (p.zz-2.)*.25;\n        z = Path(z - fract(z))*4.+.5;\n        z = (z - fract(z))/10.;\n        z = mix(z, vec2(1.), step(vec2(.4), z));      \n        z *= step(4., mod(p.z-2., 8.));\n\t\tfloat f = mix(z.x, z.y, step(p.x, 0.));                \n        \n        t = abs(mod(c=p+S(p.z), 8.)-4.);\n        w = step(0., c.y);\n        r = (step(2.6, t.x) - step(2.8, t.x)) * w;        \n        s = texture(iChannel0, (c.y*t.x > 3. ? t.zxy:t.yzx)-3.);\n        x = min(t.x + f, t.y)-s.x * (1.-r) - r*.8;  \n        print(x);\n        if(x < .01) break;\n        p -= d*x*.5;\n     }\n    w = step(t.x, 0.8) * step(2.8, t.z) + step(2.8, t.x) * step(0., c.y);\n\to = p.wyyw*.02 + 1.3* mix(s, vec4(.8), r) * mix(vec4(1), vec4(1,.5,.2,1), w ) * i/p.w;\n    return o;\n}\n\n//////////////////////////////////////////////////////////////////////////\n// Debug apparatus\n//////////////////////////////////////////////////////////////////////////\n\nconst int nrows = 25, ncols = 7, digits = 7;\nint gethudpos(vec2 fragCoord) {\n  // Compute where this pixel is in the hud table\n  vec2 cellsize = iResolution.xy/vec2(ncols,nrows);\n  ivec2 cellindex = ivec2(fragCoord/cellsize);\n  float fsize = cellsize.y; // \"Font size\" = line height in pixels\n  int col = cellindex.x;\n  int row = nrows-1-cellindex.y;\n  return row*ncols+col;\n}\n\nfloat hud(vec2 fragCoord, float hudval) {\n  // Write the hud value.\n  vec2 cellsize = iResolution.xy/vec2(ncols,nrows);\n  float fsize = cellsize.y; // \"Font size\" = line height in pixels\n  // Get diffs for textureGrad\n  float sharpness = 0.5;\n  float uvscale = sharpness/16.0/fsize;\n  vec2 dx = vec2(uvscale,0), dy = vec2(0,uvscale);\n  //ivec2 cellindex = ivec2(fragCoord/cellsize);\n  //int col = cellindex.x;\n  //int row = cellindex.y;\n  vec2 p = mod(fragCoord,cellsize)/fsize; // Cell coordinates\n  // Draw the character\n  vec4 metrics = vec4(0.25,0.75,0,1);\n  float charwidth = metrics.y-metrics.x;\n  float colwidth = cellsize.x/fsize-1.0; // Cell width in chars, with padding\n  int charpos = int(p.x/charwidth);\n  vec2 uv = vec2(0);\n  int c = floatchar(hudval,digits,charpos); // Get character at charpos, 0 if out of range\n  if (floor(hudval) == hudval) {\n    int h = int(hudval);\n    if (h%15 == 0) c = charpos >= 9 ? -1 : int[](32,70,73,90,90,66,85,90,90)[charpos];\n    else if (h%3 ==0) c = charpos >= 5 ? -1 : int[](32,70,73,90,90)[charpos];\n    else if (h%5 == 0) c = charpos >= 5 ? -1 : int[](32,66,85,90,90)[charpos];\n  }\n  if (c < 0) return 0.0;\n  float charstart = charwidth*float(charpos); // character start\n  uv = char(vec2(p.x-charstart+metrics.x,p.y),c);\n  vec4 t = textureGrad(iChannel3,uv,dx,dy);\n  return t.x;  \n}\n\nint hudpos = -1;        // The hud position this pixel is in\nint hudwritepos = 0;    // Position being written to\nfloat hudval;           // The value to write\nbool gothudval = false; // Indicate if a value has been written\n\nvoid print(float x) {\n  if (hudpos < 0 || hudpos != hudwritepos++) return;\n  gothudval = true;\n  hudval = x;\n  if (key(CHAR_Z) && (hudpos%3 == 0 || hudpos%5 == 0)) hudval = float(hudpos);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  fragColor = mainimage(fragCoord);\n  //return; // Uncomment to compare version without debug\n  vec2 mouse = 0.5*iResolution.xy;\n  if (iMouse.x > 0.0) mouse = iMouse.xy;\n  hudpos = gethudpos(fragCoord);\n  // Rerun shader with constant coords\n  mainimage(mouse);\n  // And display any debug output.\n  if (gothudval) {\n    float h = hud(fragCoord,hudval);\n    fragColor.xyz = mix(fragColor.xyz,vec3(1),h);\n  }\n  if (alert) fragColor.xyz = 1.0-fragColor.xyz;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "bool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n#define key(code) (texelFetch(iChannel1, ivec2((code),2),0).x != 0.0)\n\n// https://www.shadertoy.com/view/4sBfRd\nvec2 char(vec2 p, int c) {\n  // Compute uv for font texture.\n  // p is [0,1] coordinates in square character\n  return (p + vec2(c,15-c/16))/16.0;\n}\n\n// Wrapper for division to allow emulation of GPU style division\n// on CPU, not that this makes much difference to result.\nfloat fdiv(float x, float y) { return x/y; }\n\n// If we've found the character for the target index, return it.\n#define CHAR(c) { if (index++ == cindex) return(c); }\n#define SIGN(x) { if ((x) < 0.0) CHAR(MINUS) else CHAR(SPACE) } \n\n// Format x to digits precision and return the character at cindex,\n// or -1 if cindex is out of range.\nint floatchar(float x, int digits, int cindex) {\n  if (cindex < 0 || cindex > digits+6) return -1;\n  int index = 0;\n  const float pmax = 1e15; //  Large power of 10 with a nice representation\n  const int emax = 15; // Exponent of pmax\n  const float pow10[] = float[]( 1e1,1e2,1e3,1e4,1e5,1e6,1e7,1e8 );\n  const int SPACE = 0x20, ZERO = 0x30, POINT = 0x2e, MINUS = 0x2d, PLUS = 0x2b;\n  const int A = 0x61, E = 0x65, F = 0x66, I = 0x69, N = 0x6e;\n  if (isinf(x)) {\n    SIGN(x);\n    CHAR(I); CHAR(N); CHAR(F);\n  } else if (isnan(x)) {\n    // Maybe show the bits\n    if (floatBitsToInt(x) < 0) CHAR(MINUS);\n    CHAR(N); CHAR(A); CHAR(N);\n  } else if (x == 0.0) {\n    SIGN(x);\n    CHAR(ZERO);\n  } else {\n    SIGN(x);\n    x = abs(x);\n    int exp = 0; // Compute exponent here\n    float llimit = pow10[digits-2], ulimit = 10.0*llimit;\n    // Now put x in the range llimit <= x <= ulimit\n    // This is a delicate business if we aren't to\n    // lose too much precision\n    while (x > llimit*pmax) { x /= pmax; exp += emax; }\n    while (x < fdiv(ulimit,pmax)) { x *= pmax; exp -= emax; }\n    if (x >= ulimit) {\n      float p = 1.0;\n      while (fdiv(x,p) > ulimit) {\n        exp++; p *= 10.0;\n      }\n      x = fdiv(x,p);\n    } else if (x < llimit) {\n      float p = 1.0;\n      while (x*p < llimit) {\n        exp--;  p *= 10.0;\n      }\n      x *= p;\n    }\n    assert(!isinf(x));\n    assert(!isnan(x));\n    assert(x >= llimit);\n    assert(x <= ulimit); // Equality is possible!\n    // Round to an integer which has exactly the significant figures we want.\n    int n = int(round(x));\n    if (n == int(ulimit)) {\n      // Just in case the round has taken us the wrong way\n      n /= 10; exp++;\n    }\n    assert(n >= int(llimit));\n    assert(n < int(ulimit));\n    // Now we have a correctly rounded integer representation together\n    // with the correct exponent. The rest is just formatting.\n\n    // See if we want to use exponent notation\n    int e = 0;\n    if (exp <= -digits-4) {\n      e = exp+digits-1;\n      exp = -digits+1;\n    } else if (exp > 0) {\n      e = exp+digits-1;\n      exp = -digits+1;\n    }\n    while(n%10 == 0 && exp < 0) {\n      // Remove trailing zeros\n      n /= 10; exp++;\n    }\n    int m = 1, i = exp+1;\n    while (10*m <= n) { m *= 10; i++; }\n    // i is number of characters in front of decimal point\n    if (i <= 0) {\n      CHAR(ZERO);\n      CHAR(POINT);\n      // Add leading digits for 0 < x < 1\n      while(i < 0) {\n        CHAR(ZERO); i++;\n      }\n    }\n    while(m != 0) {\n      CHAR(ZERO+n/m%10);\n      m /= 10; i--;\n      // Don't print trailing point!\n      if (i == 0 && m != 0) CHAR(POINT);\n    }\n    if (e != 0) {\n      CHAR(E);\n      CHAR(e < 0 ? MINUS : PLUS);\n      e = abs(e);\n      CHAR(ZERO+e/10); CHAR(ZERO+e%10); \n    }\n  }\n  return -1;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}