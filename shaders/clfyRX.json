{
    "Shader": {
        "info": {
            "date": "1690979938",
            "description": "fork of : https://www.shadertoy.com/view/csl3DS\n\nHorizontal Digital Format\nRemove noise artifacts ?",
            "flags": 0,
            "hasliked": 0,
            "id": "clfyRX",
            "likes": 12,
            "name": "Nixi Digital",
            "published": 3,
            "tags": [
                "clock",
                "digital",
                "vertical",
                "seconds",
                "nixitubes"
            ],
            "usePreview": 0,
            "username": "Smoothie",
            "viewed": 2587
        },
        "renderpass": [
            {
                "code": "#define TWELVE_HOUR_CLOCK   0\n#define GLOWPULSE    1\n#define SECONDS      1\n#define SHOW_GRID      0\n\nfloat pi = atan(1.0)*4.0;\nfloat tau = atan(1.0)*8.0;\n\nconst float scale = 1.0 / 6.0;\n\nvec2 digitSize = vec2(1.0,1.5) * scale;\nvec2 digitSpacing = vec2(1.1,1.6) * scale;\n\n\n\n// hash function copy from https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 cubic(vec2 p) {\n  return p * p * (3.0 - 2.0 * p);\n}\n\nvec2 quintic(vec2 p) {\n  return p * p * p * (10.0 + p * (-15.0 + p * 6.0));\n}\n\nfloat whiteNoise2x1(vec2 p) {\n  float random = dot(p, vec2(12., 78.));\n  random = sin(random);\n  random = random * 43758.5453;\n  random = fract(random);\n  return random;\n}\n\n//noise func from here https://github.com/SuboptimalEng/shader-tutorials/blob/main/04-worley-voronoi-noise/shader.frag \nfloat noise(vec2 uv) {\n  vec2 gridUv = fract(uv);\n  vec2 gridId = floor(uv);\n\n  gridUv = quintic(gridUv);\n\n  float botLeft = whiteNoise2x1(gridId);\n  float botRight = whiteNoise2x1(gridId + vec2(1.0, 0.0));\n  float b = mix(botLeft, botRight, gridUv.x);\n\n  float topLeft = whiteNoise2x1(gridId + vec2(0.0, 1.0));\n  float topRight = whiteNoise2x1(gridId + vec2(1.0, 1.0));\n  float t = mix(topLeft, topRight, gridUv.x);\n\n  float noise = mix(b, t, gridUv.y);\n\n  return noise;\n}\n\n\n//Distance to a line segment,\nfloat dfLine(vec2 start, vec2 end, vec2 uv)\n{\n\tstart *= scale;\n\tend *= scale;\n    \n\tvec2 line = end - start;\n\tfloat frac = dot(uv - start,line) / dot(line,line);\n\treturn distance(start + line * clamp(frac, 0.0, 1.0), uv);\n}\n\n//Distance to the edge of a circle.\nfloat dfCircle(vec2 origin, float radius, vec2 uv)\n{\n\torigin *= scale;\n\tradius *= scale;\n    \n\treturn abs(length(uv - origin) - radius);\n}\n\n//Distance to an arc.\nfloat dfArc(vec2 origin, float start, float sweep, float radius, vec2 uv)\n{\n\torigin *= scale;\n\tradius *= scale;\n    \n\tuv -= origin;\n\tuv *= mat2(cos(start), sin(start),-sin(start), cos(start));\n\t\n\tfloat offs = (sweep / 2.0 - pi);\n\tfloat ang = mod(atan(uv.y, uv.x) - offs, tau) + offs;\n\tang = clamp(ang, min(0.0, sweep), max(0.0, sweep));\n\t\n\treturn distance(radius * vec2(cos(ang), sin(ang)), uv);\n}\n\n//Distance to the digit \"d\" (0-9).\nfloat dfDigit(vec2 origin, float d, vec2 uv)\n{\n\tuv -= origin;\n\td = floor(d);\n\tfloat dist = 1e6;\n\t\n\tif(d == 0.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(1.000,1.000), vec2(1.000,0.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.000,1.000), vec2(0.000,0.500), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,1.000),0.000, 3.142, 0.500, uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,0.500),3.142, 3.142, 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 1.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.500,1.500), vec2(0.500,0.000), uv));\n\t\treturn dist;\n\t}\n\tif(d == 2.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(1.000,0.000), vec2(0.000,0.000), uv));\n\t\tdist = min(dist, dfLine(vec2(0.388,0.561), vec2(0.806,0.719), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,1.000),0.000, 3.142, 0.500, uv));\n\t\tdist = min(dist, dfArc(vec2(0.700,1.000),5.074, 1.209, 0.300, uv));\n\t\tdist = min(dist, dfArc(vec2(0.600,0.000),1.932, 1.209, 0.600, uv));\n\t\treturn dist;\n\t}\n\tif(d == 3.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.000,1.500), vec2(1.000,1.500), uv));\n\t\tdist = min(dist, dfLine(vec2(1.000,1.500), vec2(0.500,1.000), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,0.500),3.142, 4.712, 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 4.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.700,1.500), vec2(0.000,0.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.000,0.500), vec2(1.000,0.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.700,1.200), vec2(0.700,0.000), uv));\n\t\treturn dist;\n\t}\n\tif(d == 5.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(1.000,1.500), vec2(0.300,1.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.300,1.500), vec2(0.200,0.900), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,0.500),3.142, 5.356, 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 6.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.067,0.750), vec2(0.500,1.500), uv));\n\t\tdist = min(dist, dfCircle(vec2(0.500,0.500), 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 7.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.000,1.500), vec2(1.000,1.500), uv));\n\t\tdist = min(dist, dfLine(vec2(1.000,1.500), vec2(0.500,0.000), uv));\n\t\treturn dist;\n\t}\n\tif(d == 8.0)\n\t{\n\t\tdist = min(dist, dfCircle(vec2(0.500,0.400), 0.400, uv));\n\t\tdist = min(dist, dfCircle(vec2(0.500,1.150), 0.350, uv));\n\t\treturn dist;\n\t}\n\tif(d == 9.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.933,0.750), vec2(0.500,0.000), uv));\n\t\tdist = min(dist, dfCircle(vec2(0.500,1.000), 0.500, uv));\n\t\treturn dist;\n\t}\n\n\treturn dist;\n}\n\n//Distance to a number\nfloat dfNumber(vec2 origin, float num, vec2 uv)\n{\n\tuv -= origin;\n\tfloat dist = 1e6;\n\tfloat offs = 0.0;\n\t\n\tfor(float i = 5.0;i > -3.0;i--)\n\t{\t\n\t\tfloat d = mod(num / pow(10.0,i),10.0);\n\t\t\n\t\tvec2 pos = digitSpacing * vec2(offs,0.0);\n\n\t\tif(i == 0.0)\n\t\t{\n\t\t\tdist = min(dist, dfCircle(vec2(offs+0.9,0.1)*1.1, 0.04,uv));\n\t\t}\n\t\t\n\t\tif(num > pow(10.0,i) || i == 0.0)\n\t\t{\n\t\t\tdist = min(dist, dfDigit(pos, d, uv));\n\t\t\toffs++;\n\t\t}\t\n\t}\n\treturn dist;\t\n}\n\n//Distance to a number This handles 2 digit integers, leading 0's will be drawn\nfloat dfNumberInt(vec2 origin, int inum, vec2 uv)\n{\n    float num = float(inum);\n\tuv -= origin;\n\tfloat dist = 1e6;\n\tfloat offs = 0.0;\n\t\n\tfor(float i = 1.0;i >= 0.0;i--)\n\t{\t\n\t\tfloat d = mod(num / pow(10.0,i),10.0);\n\t\t\n\t\tvec2 pos = digitSpacing * vec2(offs,0.0);\n\t\t\n        dist = min(dist, dfDigit(pos, d, uv));\n        offs++;\n\t}\n\treturn dist;\t\n}\n\nfloat dfColon(vec2 origin, vec2 uv) {\n\tuv -= origin;\n\tfloat dist = 1e6;\n\tfloat offs = 0.0;\n\n    dist = min(dist, dfCircle(vec2(offs+0.9,0.9)*1.1, 0.04,uv));\n    dist = min(dist, dfCircle(vec2(offs+0.9,0.4)*1.1, 0.04,uv));\n    return dist;\n}\n\n//Length of a number in digits\nfloat numberLength(float n)\n{\n\treturn floor(max(log(n) / log(10.0), 0.0) + 1.0) + 2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\n\tvec2 aspect = iResolution.xy / iResolution.y;\n\tvec2 uv = (fragCoord.xy / iResolution.y - aspect/2.0) *1.1;\n\t\n    \n    int hour = int(iDate.w/3600.);\n#if TWELVE_HOUR_CLOCK\n    if( hour > 12 ) hour -= 12;\n    if( hour == 0 ) hour = 12;\n#endif\n    int minute = int(mod(iDate.w/60.,60.));\n    \n    \n\tfloat nsize = numberLength(999999.);\n\tvec2 pos = vec2((-digitSize.x*1.1),digitSize.y/1.4);\n\n    vec2 basepos = pos;\n    pos.y = basepos.y;\n\tfloat dist = 1e6;\n\tdist = min(dist, dfNumberInt(pos, hour, uv));\n    \n    \n    pos.y -= 0.32;\n    float dist2 = 1e6;\n\tdist = min(dist, dfNumberInt(pos, minute, uv));\n\n \n#ifdef SECONDS\n    int seconds = int(mod(iDate.w,60.));\n    \n    //pos.y += 0.27;\n\t//dist = min(dist, dfColon( pos, uv ));\n    pos.y -= 0.32;\n\tdist = min(dist, dfNumberInt(pos, seconds, uv));\n#endif\n    \n\tvec3 color = vec3(0);\n\t\n\tfloat shade = 0.4;\n\t\n\tshade = 0.006 / (dist);\n\t\n\tcolor += vec3(0.2,0.8,0.2) * shade;\n#if GLOWPULSE\n\tcolor += vec3(0,1,0.2) * shade * noise((uv + vec2(iTime*0.3)) * 2.5 + .5);// * 10.*(noise(uv.yx));\n#endif\n\n    #ifdef SHOW_GRID\n    float grid = 0.5-max(abs(mod(uv.x*64.0,1.0)-0.5), abs(mod(uv.y*64.0,1.0)-0.5));\n    \n    color *= 0.25+vec3(smoothstep(0.0,64.0 / iResolution.y,grid))*0.75;\n    #endif\n\t\n\tfragColor = vec4( color , 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}