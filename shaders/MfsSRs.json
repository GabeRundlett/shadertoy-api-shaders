{
    "Shader": {
        "info": {
            "date": "1705613083",
            "description": "Implementation of the function in the answer to this question:\n\nhttps://computergraphics.stackexchange.com/questions/13875/triangle-barycentric-coordinates-interpolate-edge-dependent",
            "flags": 0,
            "hasliked": 0,
            "id": "MfsSRs",
            "likes": 1,
            "name": "Triangle edge interpolation",
            "published": 3,
            "tags": [
                "barycentric",
                "interpolation"
            ],
            "usePreview": 0,
            "username": "Reynolds",
            "viewed": 206
        },
        "renderpass": [
            {
                "code": "float area(vec2 p0, vec2 p1, vec2 p2) \n{\n\treturn (\n        (p1.x - p0.x)*(p2.y - p0.y) - (p2.x - p0.x)*(p1.y - p0.y)\n        );\n}\n\nvec3 barycentric(vec2 p, vec2 v0, vec2 v1, vec2 v2)\n{\n    float A = area(v0, v1, v2);\n    float A_u = area(p, v1, v2);\n    float A_v = area(p, v2, v0);\n    float A_w = area(p, v0, v1);\n    \n    return vec3(A_u, A_v, A_w) / A; \n}\n\n\n/* This function returns three edge functions (e_0, e_1, e_2) each e_i corresponds to edge \n * v_i - v_{i+1}. The functions are 1 on their corresponding edge and 0 on the other edges.\n * Inside the triangle they are smooth. At vertices they are singular.\n \n * You can probably simplify this a lot.\n */\nvec3 triangleEdgeFunctions(vec2 p, vec2 v0, vec2 v1, vec2 v2)\n{\n    vec3 uvw = barycentric(p, v0, v1, v2);\n    //no AA I don't care haha! What are you gonna do stab me?\n    if(uvw.x < 0.0 || uvw.y < 0.0 || uvw.z < 0.0) {\n        uvw = vec3(0.0, 0.0, 0.0);\n    }\n    \n    float h_0 = 1.0 - uvw[0] - uvw[1];\n    float h_1 = 1.0 - uvw[1] - uvw[2];\n    float h_2 = 1.0 - uvw[2] - uvw[0];\n    \n    vec3 alpha = vec3(\n               h_2 / (h_2 + h_0),\n               h_0 / (h_0 + h_1),\n               h_1 / (h_1 + h_2));\n    \n    vec3 beta = vec3( \n                h_1 / (h_1 + h_0),\n                h_2 / (h_2 + h_1),\n                h_0 / (h_0 + h_2));\n    \n    float e_0 = uvw[0] * alpha[0] + uvw[1] * beta[0];\n    float e_1 = uvw[1] * alpha[1] + uvw[2] * beta[1];\n    float e_2 = uvw[2] * alpha[2] + uvw[0] * beta[2];\n    \n    return vec3(e_0, e_1, e_2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //vertices of the triangle.\n    vec2 v0 = vec2(0.1, 0.1);\n    vec2 v1 = vec2(0.9, 0.1);\n    vec2 v2 = vec2(0.5, 0.9);\n    \n    vec3 e = triangleEdgeFunctions(uv, v0, v1, v2); \n    \n    vec3 col_0 = vec3(1, 0, 0);\n    vec3 col_1 = vec3(0, 1, 0);\n    vec3 col_2 = vec3(0, 0, 1);\n    \n    vec3 col = e[0] * col_0 + e[1] * col_1 + e[2] * col_2; \n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}