{
    "Shader": {
        "info": {
            "date": "1505077240",
            "description": "Still exploring voxels.\nMouse enable to look around.",
            "flags": 0,
            "hasliked": 0,
            "id": "lllcW4",
            "likes": 26,
            "name": "Voxel City at sunset",
            "published": 3,
            "tags": [
                "raytracing",
                "transparency",
                "voxel",
                "relfect"
            ],
            "usePreview": 1,
            "username": "ocb",
            "viewed": 4105
        },
        "renderpass": [
            {
                "code": "// Author: ocb\n// Title: Voxels City at sunset\n\t\n\n#define PI 3.141592653589793\n#define PIdiv2 1.57079632679489\n#define TwoPI 6.283185307179586\n#define INFINI 1000000.\n\n// to activate prozacgod proposal\n// straight path, no building traversal\n// Speed is increased for fun and focal is wide to visualy push-away horizon\n\n#define prozacgod\n\n#define NO_TRANSPARENCY\n#define BORDER\n\n#define boxDim 100.\n#define maxBoxRnge 250\n#define maxReflRnge 70\n#define emptyChance 30.\n#define buildSize 12.\n\n// object name\n#define GND -1\n#define SKY -1000\n#define NONE 0\n#define BOX 1\n#define GLASS 2\n\n//Global var\nvec3 color = vec3(0.);\nvec3 lightRay = normalize(vec3(1.,.1,.2));\n\n// z axis rotation\nmat2 rotz(in float a){ float s = sin(a); float c = cos(a); return mat2(c, s, -s,c);}\n\n\n//Hash functions\nfloat H1 (in float v) { \t\t\t\t\t\t\n    return fract(sin(v) * 437585.);\n}\nfloat H2 (in vec2 st,in float time) { \t\t\t\t\t\t\n    return fract(sin(dot(st,vec2(12.9898,8.233))) * 43758.5453123+time);\n}\nfloat H3 (in vec3 st,in float time) { \t\t\t\t\t\t\n    return fract(sin(dot(st,vec3(12.9898,8.233,17.6533107))) * 43758.5453123+time);\n}\n\n//Sky light + diffuse clouds\nvec3 skyGlow(in vec3 ray){\n    vec3 col = vec3(0.);\n    float a = dot(lightRay, ray);\n    col += vec3(0.995,0.641,0.038)*(smoothstep(.98,1.,a));\n    col += 1.2*vec3(.4*max(ray.x+.7,0.)*(.8-max(0.,ray.y)), .4,.4)*(1.-ray.y)*(ray.x+1.5)*.4;\n    col += (1.5*texture(iChannel0,ray.yz*.3+.005*iTime).x)*vec3(.25,.15,.1);\n\treturn col;\n}\n\nvec3 setBox(in vec3 p){\n    return floor(p/boxDim + .5);\t// return box coord. for a position\n}\n\nvec3 deBox(in vec3 box){\n    return box*boxDim;\t\t// return the position of the center of the box\n}\n\n// Find next box along the ray path\nvec3 getNextBox(in vec3 p, in vec3 v, in vec3 box){\n    vec3 d = sign(v);\n\tvec3 dt = ((box+d*.5)*boxDim-p)/v;\n    float dmin = min(min(dt.x,dt.y),dt.z);\n    d *= step(dt, vec3(dmin));\n    return box+d;\n}\n\n// Construction law: here random.\nbool checkBox(in vec3 box){\n    float h = H3(floor(box),0.)*(emptyChance + 2.);\n    return bool(int(floor( max(0.,h-emptyChance) )));\n}\n\n// Construction law for buildings\nbool checkBox2(in vec3 box){\n    float h = H2(floor(box.xz/buildSize+50.),0.);\n    #ifdef prozacgod\n    if(floor(box.z/buildSize) == 0.) \n        if(box.y <= -11.) return true;\n        else return false;\n    else return bool(step(min(31.,(h-.15)*float(maxBoxRnge)), -box.y+20.));\n    #else\n    return bool(step(min(31.,(h-.1)*float(maxBoxRnge)), -box.y+20.));\n    #endif\n}\n\n// Browse all the boxes along the ray untill maxBoxRnge reached or borders of rect area.\n// if a box is found, find normal vector, hilight borders of box, and\n// if transparency, add a very little color (value decreasing with the number of hits)\n// and find next box, as transparency means ray do not stop.\n// else (if full object) break. The ray stop here. Return t parameter. \nvec4 browseBox(in vec3 box, in vec3 pos, in vec3 ray, inout int hitObj){\n    float t = INFINI, tt = INFINI;\n    float hitNbr = 0.;\n    vec3 d;\n    vec3 startBox = box;\n    for(int i=0; i<maxBoxRnge;i++){\n        if(int(abs(box.x-startBox.x)) > maxBoxRnge-125 || int(abs(box.z-startBox.z)) > maxBoxRnge-125) break;\n    \tvec3 newBox = getNextBox(pos,ray,box);\n        d = box - newBox;\n        \n        if(checkBox2(newBox)) {\n            hitNbr ++;\n            \n            vec3 o = deBox(newBox+.5*d);\n            \n            if(abs(d.x) == 1.){\n                tt = (o.x-pos.x)/ray.x;\n                vec3 p = pos+tt*ray;\n                #ifdef BORDER\n                if(box.y>-11. ) {\n                    color += .02*(smoothstep(.4*boxDim, .5*boxDim ,abs(o.y-p.y)) + smoothstep(.4*boxDim, .5*boxDim ,abs(o.z-p.z)));\n                }\n                #endif\n            }\n            else if(abs(d.y) == 1.){\n                tt = (o.y-pos.y)/ray.y;\n                vec3 p = pos+tt*ray;\n                #ifdef BORDER\n                if(box.y>-11.) {\n                    color += .02*(smoothstep(.4*boxDim, .5*boxDim ,abs(o.x-p.x)) + smoothstep(.4*boxDim, .5*boxDim ,abs(o.z-p.z)));\n                }\n                #endif\n            }\n            else{\n                tt = (o.z-pos.z)/ray.z;\n                vec3 p = pos+tt*ray;\n                #ifdef BORDER\n                if(box.y>-11.) {\n                    color += .02*(smoothstep(.4*boxDim, .5*boxDim ,abs(o.x-p.x)) + smoothstep(.4*boxDim, .5*boxDim ,abs(o.y-p.y)));\n                }\n                #endif\n            }\n            \n            \n            #ifdef NO_TRANSPARENCY\n            if(bool(mod(newBox.y, 2.))){\n                hitObj = BOX;\n                t = tt;\n                break;\n            }\n            else{\n                vec3 refl = reflect(ray,d);\n                color += .15/hitNbr*((dot(d,lightRay)+1.)*.3+.4)*vec3(0.08,.1,0.3);\n                color += .2/hitNbr*skyGlow(refl);\n                hitObj = GLASS;\n            }\n            #endif\n        }\n        box = newBox;\n    }\n    color = clamp(color,0.,1.);\n    return vec4(d,t);\n}\n\n\n// Return true only if a fulfill box is found (used for the reflect and shadow)\nbool browseBoxSimple(in vec3 box, in vec3 pos, in vec3 ray){\n    bool ret = false;\n    for(int i=0; i<maxReflRnge;i++){\n    \tbox = getNextBox(pos,ray,box);\n        if(checkBox2(box) && bool(mod(box.y, 2.)) ){\n            ret = true;\n            break;\n        }\n    }\n    return ret;\n}\n\nvec3 getCamPos(in vec3 camTarget){\n    #ifdef prozacgod\n    float \trau = 100., alpha = PIdiv2, theta = -.001;\n    #else\n    float \trau = 100.,\n            alpha = iMouse.x/iResolution.x*4.*PI,\n            theta = iMouse.y/iResolution.y*PI+(PI/2.0001);\t\n    \t\t\n            // to start shader\n    \t\tif (iMouse.xy == vec2(0.)){\n                alpha = PIdiv2;\n                theta = -.001;\n            }\n    #endif\n    return rau*vec3(-cos(theta)*sin(alpha),sin(theta),cos(theta)*cos(alpha))+camTarget;\n}\n\nvec3 getRay(in vec2 st, in vec3 pos, in vec3 camTarget){\n    #ifdef prozacgod\n    st *= rotz(-.6*sin((iTime+.2)*.5));\n    float \tfocal = .5;\n    vec3 ww = normalize( camTarget - vec3(fract((iTime-.1)*.01)*100000.,700.*sin(iTime*.1)-300.,5.*buildSize*boxDim*(.4*sin((iTime-.1)*.5)+.5)) );\n    #else\n    float \tfocal = 2.;\n    vec3 ww = normalize( camTarget - pos);\n    #endif\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0)) ) ;\n    vec3 vv = cross(uu,ww);\n\t// create view ray\n\treturn normalize( st.x*uu + st.y*vv + focal*ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 st = fragCoord.xy/iResolution.xy-.5;\n    st.x *= iResolution.x/iResolution.y;\n    \n    // camera def\n    vec3 camTarget = //vec3(0.,1500.,0.);\n        \t\t\t //vec3(1800);\n        \t\t\t //vec3(3000.*sin(iTime*.02),1200.,2500.*cos(iTime*.03));\n        \t\t\t#ifdef prozacgod\n        \t\t\t vec3(fract(iTime*.01)*100000.,700.*sin(iTime*.1)-300.,5.*buildSize*boxDim*(.4*sin(iTime*.5)+.5));\n    \t\t\t\t#else\n    \t\t\t\t vec3(3000.*sin(iTime*.03),1400.*sin(iTime*.05-PIdiv2)+400.,2500.*cos(iTime*.04));\n    \t\t\t\t#endif\n        \t\t\n    vec3 pos = getCamPos(camTarget);\n    vec3 ray = getRay(st, pos,camTarget);\n\t\n    float t = INFINI;\n    vec3 norm;\n    int hitObj = SKY;\n    vec3 p = pos;\n    \n    vec3 box = setBox(p);\n\n    vec4 info = browseBox(box, p, ray, hitObj);\n    \n    if(hitObj == SKY) {\n        color += skyGlow(ray);\n        if(ray.y<0.) color = mix(color,vec3(0.),sqrt(-ray.y*8.));\n    }\n    else if(hitObj == BOX){\n        norm = info.xyz;\n        t = info.w;\n        p += t*.999*ray;\n        box = setBox(p);\n        vec3 refl = reflect(ray,norm);\n        if(p.y<-1025.) color.b += .15*(smoothstep(.48,.5 ,abs(fract(p.x*.002)-.5)) +smoothstep(.48,.5,abs(fract(p.z*.002)-.5)));\n        if(norm == vec3(0.,-1.,0.) && bool(step(3.,mod(box.x,3.)*mod(box.z,3.))) ){\n            //color += vec3(1.,.8,.6)*smoothstep(.35,.5,abs(fract(p.x/boxDim)-.5))*smoothstep(.35,.5,abs(fract(p.z/boxDim)-.5));\n\t\t\tfloat r = length(p.xz-deBox(box).xz)/boxDim;\n            color += vec3(1.,.8,.6)*.01/(r*r+.01);\n            color += max(0.,.15-r);\n        }\n        if(!browseBoxSimple(box, p, refl)){\n            if(box.y == -10.) color += .2*skyGlow(refl);\n            else color += .7*skyGlow(refl)*clamp(0.,1.,refl.y+.6);\n        }\n    }\n    else /* GLASS */ color += skyGlow(ray);\n        \n    \n    fragColor = vec4(color,1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 48,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}