{
    "Shader": {
        "info": {
            "date": "1570380712",
            "description": ".",
            "flags": 0,
            "hasliked": 0,
            "id": "wdKGDm",
            "likes": 11,
            "name": "Tesseracts grid slice",
            "published": 3,
            "tags": [
                "4d",
                "tesseract"
            ],
            "usePreview": 0,
            "username": "mlkn",
            "viewed": 561
        },
        "renderpass": [
            {
                "code": "// started from https://www.shadertoy.com/view/MsGBDD\n\n#define h1 vec2(0.5, -0.5)\n\nfloat t = 0.0;\nvec2 p;\nvec4 c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16;\nvec4 gridOffset;\nmat4 rotation;\nfloat edgeWidth;\n\nmat4 rot4d(float wx, float wy, float wz, float xy, float xz, float yz)\n{\n    float cwx = cos(wx);\n    float swx = sin(wx);\n    float cwy = cos(wy);\n    float swy = sin(wy);\n    float cwz = cos(wz);\n    float swz = sin(wz);\n    float cxy = cos(xy);\n    float sxy = sin(xy);\n    float cxz = cos(xz);\n    float sxz = sin(xz);\n    float cyz = cos(yz);\n    float syz = sin(yz);\n\n    return mat4(\n        // 1\n        cwx*cxy*cxz-swx*swy*sxy*cxz-swx*cwy*swz*sxz,\n        -cwx*sxy*cyz-swx*swy*cxy*cyz-cwx*cxy*sxz*syz-swx*swy*sxy*sxz*syz-swx*cwy*swz*cxz*syz,\n        cwx*sxy*syz+swx*swy*cxy*syz-cwx*cxy*sxz*cyz-swx*swy*sxy*sxz*cyz-swx*cwy*swz*cxz*cyz,\n        -swx*cwy*cwz,\n        // 2\n        cwy*sxy*cxz-swy*swz*sxz,\n        cwy*cxy*cyz-cwy*sxy*sxz*syz-swy*swz*cxz*syz,\n        -cwy*cxy*syz-cwy*sxy*sxz*cyz-swy*swz*cxz*cyz,\n        -swy*cwz,\n        // 3\n        cwz*sxz, cwz*cxz*syz, cwz*cxz*cyz, -swz,\n        // 4\n        swx*cxy*cxz+cwx*swy*sxy*cxz+cwx*cwy*swz*sxz,\n        -swx*sxy*cyz+cwx*swy*cxy*cyz-swx*cxy*sxz*syz+cwx*swy*sxy*sxz*syz+cwx*cwy*swz*cxz*syz,\n        swx*sxy*syz-cwx*swy*cxy*syz-swx*cxy*sxz*cyz+cwx*swy*sxy*sxz*cyz+cwx*cwy*swz*cxz*cyz,\n        cwx*cwy*cwz\n    );\n}\n\nvoid computeTesseractVertices()\n{\n    c1 = rotation*(h1.xxxx + gridOffset);\n    c2 = rotation*(h1.yxxx + gridOffset);\n    c3 = rotation*(h1.xyxx + gridOffset);\n    c4 = rotation*(h1.xxyx + gridOffset);\n    c5 = rotation*(h1.xxxy + gridOffset);\n    c6 = rotation*(h1.yyxx + gridOffset);\n    c7 = rotation*(h1.xyyx + gridOffset);\n    c8 = rotation*(h1.xxyy + gridOffset);\n    c9 = rotation*(h1.yxxy + gridOffset);\n    c10 = rotation*(h1.xyxy + gridOffset);\n    c11 = rotation*(h1.yxyx + gridOffset);\n    c12 = rotation*(h1.yyyx + gridOffset);\n    c13 = rotation*(h1.yyxy + gridOffset);\n    c14 = rotation*(h1.yxyy + gridOffset);\n    c15 = rotation*(h1.xyyy + gridOffset);\n    c16 = rotation*(h1.yyyy + gridOffset);\n}\n\nfloat drawSegment(vec4 vertex1, vec4 vertex2)\n{\n    float d = distance(vertex1.xy, vertex2.xy);\n    float d1 = distance(p, vertex1.xy);\n    float d2 = distance(p, vertex2.xy);\n    \n    return (1.0 - smoothstep( 0.0, edgeWidth, abs(d - d1 - d2)))\n        * smoothstep(0.5, 1.0, d1/d);\n}\n\nfloat drawEdges()\n{\n    return drawSegment(c1, c2)\n        + drawSegment(c1, c3)\n        + drawSegment(c1, c4)\n        + drawSegment(c1, c5)\n        + drawSegment(c2, c6)\n        + drawSegment(c2, c9)\n        + drawSegment(c2, c11)\n        + drawSegment(c3, c6)\n        + drawSegment(c3, c7)\n        + drawSegment(c3, c10)\n        + drawSegment(c4, c7)\n        + drawSegment(c4, c8)\n        + drawSegment(c4, c11)\n        + drawSegment(c5, c8)\n        + drawSegment(c5, c9)\n        + drawSegment(c5, c10)\n        + drawSegment(c6, c12)\n        + drawSegment(c6, c13)\n        + drawSegment(c7, c12)\n        + drawSegment(c7, c15)\n        + drawSegment(c8, c14)\n        + drawSegment(c8, c15)\n        + drawSegment(c9, c13)\n        + drawSegment(c9, c14)\n        + drawSegment(c10, c13)\n        + drawSegment(c10, c15)\n        + drawSegment(c11, c12)\n        + drawSegment(c11, c14)\n        + drawSegment(c16, c12)\n        + drawSegment(c16, c13)\n        + drawSegment(c16, c14)\n        + drawSegment(c16, c15);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    p = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    vec2 m = 2.0*(2.0*iMouse.xy - iResolution.xy)/iResolution.y;\n    \n    rotation = rot4d(2.35, 0.62, 0.0, 0.0, 0.0, 0.0);\n    float globalT = fract(iTime*0.2);\n    t = min(globalT*1.3, 1.0);\n    \n    edgeWidth = mix(0.01, 0.0015, min(t*3.3, 1.0));\n    \n    float invT2 = (1.0-t)/0.8;\n\n    float gridMoveT = mix(1.0-t, invT2*invT2*invT2*0.8, step(0.2, t));\n    float endTStuff = max(globalT-0.7, 0.0)/0.3;\n    float gridMoveEnd = sin(globalT * mix(0.0, 1000.0, endTStuff))\n            *sin(endTStuff*100.0)*0.5;\n\n    float colorMult = smoothstep(0.07, 0.3, t) * 0.04\n        *(1.0 - smoothstep(0.7, 1.0, globalT))\n        *(1.0-abs(gridMoveEnd));\n    \n    fragColor.rgb = vec3(0);\n    for (int i = -1; i <= 1; i++)\n    {\n        for (int j = -1; j <= 1; j++)\n        {\n            for (int k = -1; k <= 1; k++)\n            {\n                for (int l = -1; l <= 1; l++)\n                {\n                    gridOffset=vec4( i, j, k, l )*max(gridMoveT,gridMoveEnd)*1.3;\n                    computeTesseractVertices();\n                    \n                    fragColor.rgb += drawEdges()*vec3(i+2, j+2, l+2)*colorMult;\n                }\n            }\n        }\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}