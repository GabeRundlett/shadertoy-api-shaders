{
    "Shader": {
        "info": {
            "date": "1707669899",
            "description": "Golden number spiral",
            "flags": 0,
            "hasliked": 0,
            "id": "43f3z2",
            "likes": 1,
            "name": "Golden number spiral",
            "published": 3,
            "tags": [
                "golden"
            ],
            "usePreview": 0,
            "username": "antoinebou12",
            "viewed": 154
        },
        "renderpass": [
            {
                "code": "// Function to calculate color for the visual effect, including prime-like points and depth modulation\nvec3 calculateColor(vec2 uv, float time) {\n    // Time-based rotation\n    float angle = time * 0.2;\n    float cosA = cos(angle);\n    float sinA = sin(angle);\n    uv = mat2(cosA, -sinA, sinA, cosA) * uv;\n\n    // Spiral pattern parameters\n    float goldenAngle = radians(137.508);\n    float r = length(uv) * 8.0;\n    float theta = atan(uv.y, uv.x);\n\n    // Depth effect simulation\n    float z = mod(r, 10.0);\n    float phi = mod(theta, 2.0 * 3.14);\n\n    // Prime-like points visualization\n    float primeEffect = step(0.5, fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453));\n    primeEffect = smoothstep(0.45, 0.55, primeEffect);\n    \n    // Determine if the point is odd or even based on the radius\n    float oddEvenEffect = mod(r, 2.0); // 0 for even, 1 for odd\n\n    // Apply different color schemes based on the point's type\n    vec3 primeColor = mix(vec3(0.9, 1.0, 0.7), vec3(0.1, 0.0, 0.6), abs(sin(z) + cos(phi)));\n    vec3 oddColor = vec3(0.7, 0.3, 0.5); // Example odd color\n    vec3 evenColor = vec3(0.3, 0.5, 0.7); // Example even color\n\n    // Color modulation based on depth and prime effect\n    vec3 col;\n    if (primeEffect == 1.0) {\n        col = primeColor; // Use prime color for prime-like points\n    } else if (oddEvenEffect == 0.0) {\n        col = oddColor; // Use odd color for odd points\n    } else {\n        col = evenColor; // Use even color for even points\n    }\n\n    col *= primeEffect * 0.5 + 0.5; // Apply the prime-like effect dimming\n\n    return col;\n}\n\n// ACES tone mapping function for color correction and enhancement\nvec3 aces_tonemap(vec3 color) {\n    mat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n    );\n    mat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n    );\n    vec3 v = m1 * color;\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\n}\n\n// Main image function with supersampling and ACES tone mapping\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 accumColor = vec4(0.0);\n    vec2 offsets[9] = vec2[](\n        vec2(-0.33, -0.33), vec2(0.0, -0.33), vec2(0.33, -0.33),\n        vec2(-0.33, 0.0), vec2(0.0, 0.0), vec2(0.33, 0.0),\n        vec2(-0.33, 0.33), vec2(0.0, 0.33), vec2(0.33, 0.33)\n    );\n\n    for (int i = 0; i < 9; i++) {\n        vec2 ssCoord = fragCoord + offsets[i];\n        vec2 uv = (ssCoord - 0.5 * iResolution.xy) / iResolution.y;\n        uv *= 50.0 * iTime * 0.01;\n\n        vec3 col = calculateColor(uv,(iMouse.x / iResolution.x) * 10.0);\n        col = aces_tonemap(col); // Apply ACES tone mapping\n\n        accumColor += vec4(col, 1.0);\n    }\n\n    fragColor = accumColor / 9.0; // Average for anti-aliasing effect\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}