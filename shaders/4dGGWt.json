{
    "Shader": {
        "info": {
            "date": "1456896559",
            "description": "Establishing an approximate conservative interior and exterior limit of a SDF contour, as required by processes like anti-aliasing and resolution refinement.",
            "flags": 0,
            "hasliked": 0,
            "id": "4dGGWt",
            "likes": 49,
            "name": "Conservative Raymarching",
            "published": 3,
            "tags": [
                "raymarching",
                "antialiasing",
                "silhouette",
                "conservative",
                "refinement"
            ],
            "usePreview": 0,
            "username": "paniq",
            "viewed": 3361
        },
        "renderpass": [
            {
                "code": "\n// thanks to Sebastian Aaltonen for dropping the final clue that\n// finally enabled me to fix this implementation\n\n#define MAX_STEPS 50\n\n// undef to disable hole, then parameter s.w not needed\n// #define CONVEX\n\n// sdUberprim with precomputed constants\nfloat sdUnterprim(vec3 p, vec4 s, vec3 r, vec2 ba, float sz2) {\n    vec3 d = abs(p) - s.xyz;\n    float q = length(max(d.xy, 0.0)) + min(0.0,max(d.x,d.y)) - r.x;\n    // hole support: without this line, all results are convex\n#ifndef CONVEX    \n    q = abs(q) - s.w;\n#endif\n    \n    vec2 pa = vec2(q, p.z - s.z);\n    vec2 diag = pa - vec2(r.z,sz2) * clamp(dot(pa,ba), 0.0, 1.0);\n    vec2 h0 = vec2(max(q - r.z,0.0),p.z + s.z);\n    vec2 h1 = vec2(max(q,0.0),p.z - s.z);\n    \n    return sqrt(min(dot(diag,diag),min(dot(h0,h0),dot(h1,h1))))\n        * sign(max(dot(pa,vec2(-ba.y, ba.x)), d.z)) - r.y;\n}\n\n// s: width, height, depth, thickness\n// r: xy corner radius, z corner radius, bottom radius offset\nfloat sdUberprim(vec3 p, vec4 s, vec3 r) {\n    // these operations can be precomputed\n    s.xy -= r.x;\n#ifdef CONVEX  \n    r.x -= r.y;\n#else\n    r.x -= s.w;\n    s.w -= r.y;\n#endif\n    s.z -= r.y;\n    vec2 ba = vec2(r.z, -2.0*s.z);\n    return sdUnterprim(p, s, r, ba/dot(ba,ba), ba.y);\n}\n\n// example parameters\n#define SHAPE_COUNT 9.0\nvoid getfactor (int i, out vec4 s, out vec3 r) {\n    //i = 4;\n    if (i == 0) { // cube\n        s = vec4(1.0);\n        r = vec3(0.0);\n    } else if (i == 1) { // cylinder\n        s = vec4(1.0);\n        r = vec3(1.0,0.0,0.0);\n    } else if (i == 2) { // cone\n        s = vec4(0.0,0.0,1.0,1.0);\n        r = vec3(0.0,0.0,1.0);\n\t} else if (i == 3) { // pill\n        s = vec4(1.0,1.0,2.0,1.0);\n        r = vec3(1.0,1.0,0.0);\n    } else if (i == 4) { // sphere\n        s = vec4(1.0);\n        r = vec3(1.0,1.0,0.0);\n    } else if (i == 5) { // pellet\n        s = vec4(1.0,1.0,0.25,1.0);\n        r = vec3(1.0,0.25,0.0);\n    } else if (i == 6) { // torus\n        s = vec4(1.0,1.0,0.25,0.25);\n        r = vec3(1.0,0.25,0.0);\n    } else if (i == 7) { // pipe\n        s = vec4(vec3(1.0),0.25);\n        r = vec3(1.0,0.1,0.0);\n    } else if (i == 8) { // corridor\n        s = vec4(vec3(1.0),0.25);\n        r = vec3(0.1,0.1,0.0);\n\t}\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 1.5 + sin(time * 0.1) * 0.7;\n\tcamPos = vec3(4.5*sin(an),2.0,4.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\nvec3 doBackground( void )\n{\n    return vec3( 0.0, 0.0, 0.0);\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat doobject (vec3 p, float k) {\n    float u = smoothstep(0.0,1.0,smoothstep(0.0,1.0,fract(k)));\n    int s1 = int(mod(k,SHAPE_COUNT));\n    int s2 = int(mod(k+1.0,SHAPE_COUNT));\n    \n    vec4 sa,sb;\n    vec3 ra,rb;\n    getfactor(s1,sa,ra);\n    getfactor(s2,sb,rb);\n    \n    return  sdUberprim(p.zyx, mix(sa,sb,u), mix(ra,rb,u));\n}\n\nbool interior;\n\nfloat doModel( vec3 p ) {\n    float k = iTime*0.5;\n    float d = doobject(p - vec3(0.0,0.0,-0.5), k);\n    float d2 = doobject(p - vec3(0.0,0.0,0.5), k + 1.0);\n    if (interior)\n    \td = min(d, d2);\n   \telse\n    \td = smin(d, d2, 0.4);\n    \n    return d;\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd, vec2 pixel, float bias, out int steps )\n{\n\tconst float maxd = 20.0;           // max trace distance\n\tfloat aperture = max(pixel.y,pixel.x) / sqrt(2.0);        // aperture of cone\n    float C = sqrt(aperture*aperture + 1.0);\n    // radius of sphere at t=1\n    float R = aperture/C;\n    // constant adjustment factor for t so that the cone sphere touches the distance radius\n    float A = C / (C + bias*aperture);\n    // for a better demo of how the above factors work, see https://www.shadertoy.com/view/4lfBWH\n    \n    float t = 0.0;\n\tfloat res = -1.0;\n    steps = 0;\n    float tc = (bias > 0.0)?0.0:1.0;\n    for( int i=0; i<MAX_STEPS; i++ ) {\n        steps = i;\n\t\tfloat limit = bias*R*t;\n        // add small bias to reduce iteration count\n        limit += 1e-03*t;\n\t    float h = doModel( ro+rd*t );\n        t = (t + h)*A;\n    \tif((h <= limit) || (t > maxd)) {\n            break;\n        }\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\n// first derivative of scalar field: this is our vector field F\nvec3 grad( in vec3 pos )\n{\n    const vec2 d = vec2(0.0, 0.002);\n    return vec3(\n        doModel(pos + d.yxx) - doModel(pos - d.yxx),\n        doModel(pos + d.xyx) - doModel(pos - d.xyx),\n        doModel(pos + d.xxy) - doModel(pos - d.xxy)) / (2.0 * 0.002);\n}\n\n// second derivative of scalar field: first derivative of F\nmat3 Fgrad( in vec3 pos )\n{\n    const vec2 d = vec2(0.0, 0.002);\n    return mat3(\n        grad(pos + d.yxx) - grad(pos - d.yxx),\n        grad(pos + d.xyx) - grad(pos - d.xyx),\n        grad(pos + d.xxy) - grad(pos - d.xxy)) / (2.0 * 0.002);\n}\n\n// curl of F; zero everywhere when our F is derived from a scalar field :-(\n// need to generate a field F with three independent noise variables to \n// get something useful here.\nvec3 curl(in vec3 pos) {\n    mat3 dF = Fgrad(pos);\n    return vec3(\n        dF[2].y - dF[1].z,\n        dF[0].z - dF[2].x,\n        dF[1].x - dF[0].y);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    return grad(pos);\n}\n\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nbool dorender( out float dist, out int steps, out vec3 position, in vec2 fragCoord, in vec2 resolution, in float bias)\n{\n    vec2 p = (-resolution.xy + 2.0*fragCoord.xy)/resolution.y;\n\n    //-----------------------------------------------------\n    // camera1\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, 0.0 );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n\t// raymarch\n    float t = calcIntersection( ro, rd, 1.0 / resolution, bias, steps );\n    dist = t;\n    if( t>-0.5 )\n    {\n        // geometry\n        position = ro + t*rd;\n        return true;\n\t}\n    return false;\n}\n\nvec3 hue2rgb (float hue) {\n    return clamp(abs(mod(hue * 6.0 + vec3(0.0,4.0,2.0),6.0) - 3.0) - 1.0,0.0,1.0);\n}\n\n// maps n=0 to blue, n=1 to red, n=0.5 to green\nvec3 normhue (float n)  {\n    return hue2rgb((1.0 - clamp(n,0.0,1.0)) * 0.66667);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    float dist;\n    float dist_inner;\n    float dist_outer;    \n    \n    interior = false;\n    vec2 resolution = iResolution.xy;\n    vec3 pos;\n    int steps;\n    bool hit = dorender(dist, steps, pos, fragCoord, resolution, 1.0);\n\n    float K = 8.0;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 hresolution = floor((iResolution.xy + (K - 1.0)) / K);\n    vec2 hfragCoord = floor(uv * hresolution) + 0.5;\n    interior = false;\n    vec3 pos_inner;\n    int steps_inner;\n    bool hit_inner = dorender(dist_inner, steps_inner, pos_inner, hfragCoord, hresolution, -1.0);\n    interior = false;\n    vec3 pos_outer;\n    int steps_outer;\n    bool hit_outer = dorender(dist_outer, steps_outer, pos_outer, hfragCoord, hresolution, 1.0);\n    \n    fragColor = vec4(vec3(0.0),1.0);\n#if 1\n    if (hit_outer) {\n        if (hit_inner) {\n            if (hit) {\n\t        \tvec3 nor = calcNormal(pos);\n            \tfragColor = vec4((nor*0.5+0.5)*0.5,1.0);\n            } else {\n                // must not happen\n                fragColor = vec4(vec3(1.0),1.0);\n            }\n        } else if (hit)\n            fragColor.g = 1.0;\t\n        else\n        \tfragColor.r = 1.0;\n\t} else if (hit) {\n        // must not happen\n        fragColor = vec4(vec3(1.0),1.0);\n    }\n    \n    #if 1\n    if (hit) {\n        // outer shell always closer than surface\n        if (dist < dist_outer)\n            fragColor = vec4(1.0,0.7,0.0,1.0);\n       \t// inner shell always contained within surface\n        else if (hit_inner && (dist_inner < dist))\n            fragColor = vec4(1.0,0.7,1.0,1.0);\n    }\n    #endif\n#else\n    vec3 c0 = normhue(float(steps_outer)/float(MAX_STEPS));\n    vec3 c1 = normhue(float(steps_inner)/float(MAX_STEPS));\n    vec3 c2 = normhue(float(steps)/float(MAX_STEPS));\n    \n    fragColor = vec4((c0 + c1 + c2)/3.0,1.0);\n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}