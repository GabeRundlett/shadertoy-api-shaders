{
    "Shader": {
        "info": {
            "date": "1642190311",
            "description": "@lsdlive\nCC-BY-NC-SA\n\nSpiral #4 (Keep Going)",
            "flags": 0,
            "hasliked": 0,
            "id": "NslcD7",
            "likes": 26,
            "name": "Spiral #4 (Keep Going)",
            "published": 3,
            "tags": [
                "raymarching",
                "spiral"
            ],
            "usePreview": 0,
            "username": "lsdlive",
            "viewed": 575
        },
        "renderpass": [
            {
                "code": "/*\n@lsdlive\nCC-BY-NC-SA\n\nSpiral #4 (Keep Going)\n\nGeometries are generated with sphere-tracing algorithms:\nhttp://www.michaelwalczyk.com/blog/2017/5/25/ray-marching\nhttps://iquilezles.org/articles/distfunctions\nhttp://mercury.sexy/hg_sdf/\n\nSome notation:\np: position (usually in world space)\nrd: ray direction (eye or view vector)\n*/\n\n#define time iTime\n\nmat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n// http://mercury.sexy/hg_sdf/\n// hglib mirrorOctant\nvoid mo(inout vec2 p, vec2 d) {\n\tp.x = abs(p.x) - d.x;\n\tp.y = abs(p.y) - d.y;\n\tif (p.y > p.x) p = p.yx;\n}\n\n// hglib pMod1\nfloat re(float p, float d) {\n\treturn mod(p - d * .5, d) - d * .5;\n}\n\n// hglib pModPolar\nvoid amod(inout vec2 p, float d) {\n\tfloat a = re(atan(p.x, p.y), d); // beware, flipped y,x\n\tp = vec2(cos(a), sin(a)) * length(p);\n}\n\n// signed cross\nfloat sc(vec3 p, float d) {\n    p = abs(p);\n    p = max(p, p.yzx);\n    return min(p.x, min(p.y, p.z)) - d;\n}\n\nfloat g = 0.;\nfloat de(vec3 p) {\n    vec3 q = p;\n\n    p.xy *= r2d(-time * .1);\n    p.xy *= r2d(p.z*.02);\n    p.z = re(p.z, 2.);\n\n    amod(p.xy, 6.28 / 4.);\n    mo(p.xz, vec2(.7, 1.3));\n    float sc2 = sc(p, 1.3);\n\n    amod(p.xy, 6.28 / 2.);\n    mo(p.xy, vec2(1.2, .2));\n    float d = sc(p, .4);\n\n    d = max(d, -sc2);\n\n    q.xy *= r2d(-time);\n    q.xy *= r2d(q.z*.9);\n    q.x = abs(q.x) - .3;\n    q.y = abs(q.y) - .24;\n    d = min(d, length(q.xy) - .01);\n\n    q.x = abs(q.x) - 2.3;\n    q.y = abs(q.y) - 3.;\n    d = min(d, length(q.xy) - .03);\n\n    g += .01 / (.02 + d * d);\n    return d;\n}\n\n\nfloat random(vec2 uv) {\n    return fract(sin(dot(uv, vec2(12.2544, 35.1571))) * 5418.548416);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    uv *= 1.2;\n\n    vec3 ro = vec3(0, 0, -4. + time * 4.);\n    vec3 rd = normalize(vec3(uv, 1. - length(uv) * .2));\n\n    float t = 0.;\n    vec3 p;\n    float grain = random(uv);\n    for (float i = 0.; i < 1.; i += .01) {\n        p = ro + rd * t;\n        float d = de(p);\n        d = max(abs(d), .02);\n        d *= 1. + grain * .03;\n        t += d * .4;\n    }\n\n    vec3 c = vec3(.18, .37, .2);\n    c += g * .025;\n    c.r += sin(p.z) * .2;\n    c = mix(c, vec3(.15, .1, .2), 1. - exp(-.01 * t * t));\n    c *= 1.4;\n    c = clamp(c, 0., 1.);\n\n    fragColor = vec4(c, 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}