{
    "Shader": {
        "info": {
            "date": "1688855557",
            "description": "Testing my bloom implementation (kinda slow ðŸ˜­)\nhttps://theowlhouse.fandom.com/wiki/Glyph_Magic",
            "flags": 32,
            "hasliked": 0,
            "id": "ddsfW4",
            "likes": 17,
            "name": "More glyph magic",
            "published": 3,
            "tags": [
                "sdf",
                "glow",
                "glyphs",
                "owlhouse",
                "toh"
            ],
            "usePreview": 0,
            "username": "fishy",
            "viewed": 360
        },
        "renderpass": [
            {
                "code": "#define BLOOM_PASS iChannel1\n\n// https://github.com/GarrettGunnell/AcerolaFX/blob/main/Shaders/AcerolaFX_Tonemapping.fx\nconst mat3 ACESInputMat = mat3(\n    vec3(0.59719, 0.35458, 0.04823),\n    vec3(0.07600, 0.90834, 0.01566),\n    vec3(0.02840, 0.13383, 0.83777)\n);\n\nconst mat3 ACESOutputMat = mat3(\n    vec3( 1.60475, -0.53108, -0.07367),\n    vec3(-0.10208,  1.10813, -0.00605),\n    vec3(-0.00327, -0.07276,  1.07602)\n);\n\nvec3 RRTAndODTFit(vec3 v) {\n    vec3 a = v * (v + 0.0245786f) - 0.000090537f;\n    vec3 b = v * (0.983729f * v + 0.4329510f) + 0.238081f;\n    return a / b;\n}\n\nvec3 HillACES(vec3 col) {\n    col = col * ACESInputMat;\n    col = RRTAndODTFit(col);\n    return clamp(col * ACESOutputMat, 0.0, 1.0);\n}\n\nvec2 getTile(vec2 p, float tile)\n{\n    float tileWidth = 1.-exp2(-floor(tile));\n    return vec2((p)/exp2(floor(tile))/2.+vec2(tileWidth, 0));\n}\n\nvec4 computeBloom(sampler2D bloomTex, vec2 uv, float mip, float power, float str, float threshold)\n{\n    vec4 albedo = vec4(0);\n\tfor(float i = 0.; i < mip; i++)\n\t{\n        vec4 col = max(vec4(0), texture(bloomTex, getTile(uv.xy, i)) - threshold);\n\t\talbedo += col * exp2(-power*i);\n\t}\n    return albedo * str;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 outputColor = texture(iChannel0, uv, 0.0).rgb + computeBloom(BLOOM_PASS, uv, 6.0, 0.7, 0.5, 0.0).rgb;\n\n    fragColor = vec4(HillACES(outputColor), 1.0);\n    //fragColor = log(texture(iChannel1, uv) + 1.0)*4.0;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define csgInit() float r = 1e30\n#define csgEnd() return r\n#define csgUnion(d) r = min(r, d)\n#define csgMirrorX(p) vec2(abs(p.x), p.y)\n#define csgMirrorY(p) vec2(p.x, abs(p.y))\n\nfloat sdSegment(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdRing(vec2 p, vec2 o, float r)\n{\n    return abs(distance(p, o) - r);\n}\n\nfloat sdPoint(vec2 p, vec2 o)\n{\n    return distance(p, o);\n}\n\nfloat sdPointedEggRing(vec2 p, vec2 o, float r, float h)\n{\n    return abs(p.y - o.y > 0.0? length(vec2(abs(p.x), p.y) - o + vec2(h, 0.0)) - (r+h) : length(p - o) - r);\n}\n\nfloat sdCubicBezier(vec2 uv, vec2 s, vec2 c1, vec2 c2, vec2 e, float res)\n{\n    float r = 1e20;\n    float st = 1./res;\n    vec2 prev = s;\n    for(float i = 0.; i < 1.; i += st)\n    {\n        float j = 1.-i;\n        vec2 point = j*j*j*s+3.*j*j*i*c1+3.*j*i*i*c2+i*i*i*e;\n        r = min(r, sdSegment(uv, prev, point));\n        prev = point;\n    }\n    r = min(r, sdSegment(uv, prev, e));\n    return r;\n}\n\nfloat sdGlyph(vec2 uv, int type)\n{\n    csgInit();\n    csgUnion(sdRing(uv, vec2(0), 1.0));\n    switch(type)\n    {\n        case 0:\n            csgUnion(sdSegment(csgMirrorX(uv), vec2(0, 1), vec2(0.15, 0.7)));\n            csgUnion(sdRing(uv, vec2(0, 0.66), 0.154));\n            csgUnion(sdSegment(csgMirrorX(uv), vec2(0, 0.506), vec2(0.953, -0.3)));\n            csgUnion(sdSegment(uv, vec2(0.953, -0.3), vec2(-0.953, -0.3)));\n            csgUnion(sdSegment(uv, vec2(0, 0.506), vec2(0, -1)));\n            csgUnion(sdSegment(uv, vec2(-0.1, 0), vec2(0.1, 0.1)));\n            csgUnion(sdSegment(uv, vec2(-0.1, -0.1), vec2(0.1, 0)));\n            csgEnd();\n        case 1:\n            csgUnion(sdSegment(csgMirrorX(uv), vec2(0, 1), vec2(0.4, 0.6)));\n            csgUnion(sdSegment(csgMirrorX(uv), vec2(0.4, 0.6), vec2(0.0, -0.3)));\n            csgUnion(sdSegment(uv, vec2(0.953, -0.3), vec2(-0.953, -0.3)));\n            csgUnion(sdCubicBezier(csgMirrorX(uv), vec2(0.0, 0.2), vec2(0.2, 0.2), vec2(0.6, 0.1), vec2(0.97, -0.2), 3.0));\n            csgUnion(sdSegment(uv, vec2(0, 1), vec2(0, -0.3)));\n            csgUnion(sdSegment(csgMirrorX(uv), vec2(0, -0.3), vec2(0.15, -0.45)));\n            csgUnion(sdSegment(csgMirrorX(uv), vec2(0.15, -0.45), vec2(0, -0.6)));\n            csgEnd();\n        case 2:\n            csgUnion(sdSegment(csgMirrorX(uv), vec2(0, -0.2), vec2(0.25, 0.05)));\n            csgUnion(sdRing(uv, vec2(0, -0.5), 0.3));\n            csgUnion(sdPoint(uv, vec2(0, -0.5)));\n            csgUnion(sdSegment(csgMirrorX(uv), vec2(0, 0.4), vec2(0.25, 0.65)));\n            csgUnion(sdSegment(uv, vec2(0.1, 0.5), vec2(-0.1, 0.5)));\n            csgUnion(sdSegment(uv, vec2(-0.25, 0.65), vec2(0.25, 0.65)));\n            csgUnion(sdSegment(uv, vec2(0, -0.2), vec2(0, 0.4)));\n            csgEnd();\n        case 3:\n            csgUnion(sdPointedEggRing(uv, vec2(0.0, -0.5), 0.5, 0.95));\n            csgUnion(sdRing(uv, vec2(0.0, -0.5), 0.5));\n            csgUnion(sdPoint(uv, vec2(0.0, -0.5)));\n            csgUnion(sdPointedEggRing(uv, vec2(0.0, 0.3), 0.3, 0.65));\n            csgUnion(sdRing(uv, vec2(0.0, 0.3), 0.3));\n            csgEnd();\n    }\n        \n}\n\nvec3[] colors = vec3[](vec3(1.000,0.812,0.251), vec3(0.110,0.667,1.000), vec3(0.200,1.000,0.082), vec3(1.000,0.271,0.059));\nvec3 glyph(vec2 uv, float thickness, int type)\n{\n    float sdf = sdGlyph(uv, type);\n    return smoothstep(0.02, 0.0, sdf - thickness) * colors[type];\n}\n\nvec2 transformCoordinates(in vec2 uv, float scale, float rotA, float rotB)\n{\n    uv *= rotMat(rotA);\n    uv.x /= scale;\n    uv *= rotMat(rotB);\n    return uv;\n}\n\nvec3 glyphLayer(vec2 uv, float prob, float time, float speed)\n{\n    vec2 cid = floor(uv);\n    vec4 cellRand0 = hash42(cid) * vec4(vec3(40.0), 1.0);\n    vec4 cellRand1 = hash42(cid + 10.0);\n    vec4 cellRand2 = hash42(cid + 20.0);\n    float scale = 3.0 + cellRand2.x*3.0;\n    vec2 cp = scale*fract(uv)-scale*0.5;\n    if (cellRand1.w > prob)\n    {\n        return vec3(0.0);\n    }\n    return glyph(transformCoordinates(cp, sin(time*speed*(1.0 + cellRand1.x) + cellRand0.x), time*speed*0.5*cellRand1.y + cellRand0.y, -time*speed + cellRand0.z), 0.01, int(cellRand0.w * 4.0));\n}\n\nvec3 glyph3d(vec2 uv, vec2 offset)\n{\n    float scale = 0.5;\n    vec3 col = vec3(0);\n    for(float i = 0.0; i < 12.0; i++)\n    {\n        col += glyphLayer(uv*scale + offset + hash21(scale)*100.0, 0.5, iTime, 1.);\n        scale *= 1.2;\n    }\n    return col;\n}\n\nvec3 glyphRow(vec2 uv, float time)\n{\n    uv.y += time;\n    float xrand = hash12(floor(uv.yy));\n    uv.x += time * (xrand-0.5)*4.0;\n    float rand = hash12(floor(uv));\n    return glyph(3.0 * fract(uv) - 1.5, 0.01, int(rand*4.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ouv = fragCoord/iResolution.xy;\n    fragCoord += hash22(fragCoord + fract(iTime) * 300.0)-0.5;\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    vec4 m = vec4((iMouse.xy*2.-iResolution.xy)/iResolution.y, iMouse.zw);\n    float px = 2.0/iResolution.y;\n    \n    vec3 col = glyph3d(uv, vec2(sin(iTime*0.5), -iTime));\n    //col = glyphRow(uv, iTime*0.2);\n    \n    col *= 5.0;\n    fragColor = mix(texture(iChannel0, ouv), vec4(col, 1.0), 0.5);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float size = exp2(floor(log2(1.-uv.x)));\n    \n\tfragColor = texture(iChannel0, vec2(fract(uv.x/size), uv.y/size));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float s = 2./(H_BLUR_RES+1.);\n    vec4 a = vec4(0);\n    float m = 0.;\n    float mip = exp2(floor(log2(1.-uv.x)));\n    vec2 rot = vec2(1, 0);\n    vec2 ratio = vec2(iResolution.y/iResolution.x, 1);\n    for(float o = 0.; o < H_BLUR_RES; o++)\n    {\n        float t = ((o\n        #if DO_JITTER == 1\n         + hash12(fragCoord+fract(iTime))-0.5\n        #endif\n        )/H_BLUR_RES)*2.-1.;\n        float w = exp(-5.0*t*t);\n        m += w;\n        vec2 newCoords = uv.xy + H_BLUR_SIZE*rot*t*ratio;\n        #if DO_MIPMAP_CHECK == 1\n        float newCoordsMip = exp2(floor(log2(1.-newCoords.x)));\n        if(newCoordsMip == mip)\n        #endif\n            a += texture(iChannel0, newCoords)*w;\n    }\n    \n\tfragColor = a/m;\n    fragColor = mix(texture(iChannel1, uv), fragColor, 0.3);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float s = 2./(V_BLUR_RES+1.);\n    vec4 a = vec4(0);\n    float m = 0.;\n    float mip = exp2(floor(log2(1.-uv.x)));\n    vec2 rot = vec2(0, 1);\n    vec2 ratio = vec2(iResolution.y/iResolution.x, 1);\n    for(float o = 0.; o < V_BLUR_RES; o++)\n    {\n        float t = ((o\n        #if DO_JITTER == 1\n         + hash12(fragCoord+fract(iTime) + 100.0)-0.5\n        #endif\n        )/H_BLUR_RES)*2.-1.;\n        float w = exp(-5.0*t*t);\n        m += w;\n        vec2 newCoords = uv.xy + V_BLUR_SIZE*rot*t*ratio;\n        #if DO_MIPMAP_CHECK == 1\n        float newCoordsMip = exp2(floor(log2(1.-newCoords.x)));\n        if(newCoordsMip == mip)\n        #endif\n            a += texture(iChannel0, newCoords)*w;\n    }\n    \n\tfragColor = a/m;\n    fragColor = mix(texture(iChannel1, uv), fragColor, 0.3);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define H_BLUR_SIZE 0.05\n#define H_BLUR_RES 16.0\n\n#define V_BLUR_SIZE 0.05\n#define V_BLUR_RES 16.0\n\n#define DO_MIPMAP_CHECK 1\n#define DO_JITTER 1\n\n#define rotMat(t) mat2(cos(t), -sin(t), sin(t), cos(t))\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}