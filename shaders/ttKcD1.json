{
    "Shader": {
        "info": {
            "date": "1610970679",
            "description": "Simple chessboard pattern for learning purposes",
            "flags": 0,
            "hasliked": 0,
            "id": "ttKcD1",
            "likes": 0,
            "name": "Chessboard example",
            "published": 3,
            "tags": [
                "2d",
                "chessboard"
            ],
            "usePreview": 0,
            "username": "cottayson",
            "viewed": 293
        },
        "renderpass": [
            {
                "code": "#define BLACK (vec3(0.0, 0.0, 0.0))\n#define WHITE (vec3(1.0, 1.0, 1.0))\n#define RED (vec3(1.0, 0.0, 0.0))\n#define GREEN (vec3(0.0, 1.0, 0.0))\n#define BLUE (vec3(0.0, 0.0, 1.0))\n#define YELLOW (vec3(1.0, 1.0, 0.0))\n#define PURPLE (vec3(0.0, 1.0, 1.0))\n\n// Proof that iResolution.z = 1 (example of fetching information in GLSL)\nvec3 proof(vec2 uv, vec3 c1, vec3 c2) {\n    if (uv.x < iResolution.z * iResolution.x / 2.0) {\n        return c1;\n    } else {\n        return c2;\n    }\n}\n\nvec3 drawRect(vec2 uv, vec3 lastcolor, vec3 newcolor, vec4 rect) {\n    if (uv.x > rect.x && uv.y > rect.y && uv.x < rect.x + rect.z && uv.y < rect.y + rect.w) {\n        return newcolor;\n    }\n    return lastcolor;\n}\n\n// Draw chessboard using drawRect method.\nvec3 drawChessboardSlow(vec2 uv, vec3 color1, vec3 color2, vec2 rectSize, vec2 screenSize) {\n    float w = screenSize.x;\n    float h = screenSize.y;\n    vec3 colacc = color1;\n    for (int i = 0; i <= int(w / rectSize.x); i++) {\n        for(int j = 0; j <= int(h / rectSize.y); j++) {\n            float coef = float((i + j) % 2);\n            colacc = drawRect(\n                uv, colacc, \n                color2 * coef + colacc * (1.0 - coef),\n                vec4(w - float(i + 1) * rectSize.x, h - float(j + 1) * rectSize.y,\n                     rectSize.x, rectSize.y));\n        }\n    }\n    return colacc;\n}\n\n// Draw chessboard directly from pixel position.\nvec3 drawChessboardFast(vec2 uv, vec3 c1, vec3 c2, vec2 rectSize, vec2 screenSize) {\n    int i = int((screenSize.x - uv.x) / rectSize.x);\n    int j = int((screenSize.y - uv.y) / rectSize.y);\n    if ((i + j) % 2 == 0) {\n        return c1;\n    } else {\n        return c2;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Simple pixel coordinates (from (0,0) to iResolution.xy) (iResolution.z = 1)\n    vec2 uv = fragCoord;\n    float w = iResolution.x; // width of screen in pixels\n    float h = iResolution.y; // height of screen in pixels\n\n    vec3 col = vec3(1.0, 1.0, 1.0);\n    \n    vec2 rectSize = vec2(1.0, 1.0) * 10.0;\n    \n    \n    // col = drawChessboardSlow(uv, RED, GREEN, rectSize, iResolution.xy);\n    col = drawChessboardFast(uv, RED, GREEN, rectSize, iResolution.xy);\n\n    \n    // col = proof(uv, RED, WHITE);\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}