{
    "Shader": {
        "info": {
            "date": "1622869080",
            "description": "Testing ... original code for Autodesk flame matchbox by lewis@lewissaunders.com",
            "flags": 32,
            "hasliked": 0,
            "id": "ftlGWj",
            "likes": 4,
            "name": "Ls_Glint",
            "published": 3,
            "tags": [
                "highlights",
                "glint"
            ],
            "usePreview": 0,
            "username": "pucknz",
            "viewed": 410
        },
        "renderpass": [
            {
                "code": "//\n//\n//                          MMMMMMMMMMMMMMMMMMMMMMMMMMMM\n//                        MM.                          .MM\n//                       MM.  .MMMMMMMMMMMMMMMMMMMMMM.  .MM\n//                      MM.  .MMMMMMMMMMMMMMMMMMMMMMMM.  .MM\n//                     MM.  .MMMM        MMMMMMM    MMM.  .MM\n//                    MM.  .MMM           MMMMMM     MMM.  .MM\n//                   MM.  .MmM              MMMM      MMM.  .MM\n//                  MM.  .MMM                 MM       MMM.  .MM\n//                 MM.  .MMM                   M        MMM.  .MM\n//                MM.  .MMM                              MMM.  .MM\n//                 MM.  .MMM                            MMM.  .MM\n//                  MM.  .MMM       M                  MMM.  .MM\n//                   MM.  .MMM      MM                MMM.  .MM\n//                    MM.  .MMM     MMM              MMM.  .MM\n//                     MM.  .MMM    MMMM            MMM.  .MM\n//                      MM.  .MMMMMMMMMMMMMMMMMMMMMMMM.  .MM\n//                       MM.  .MMMMMMMMMMMMMMMMMMMMMM.  .MM\n//                        MM.                          .MM\n//                          MMMMMMMMMMMMMMMMMMMMMMMMMMMM\n//\n//\n//\n//\n// Adaptation pour Natron par F. Fernandez\n// Code original : Ls_Glint Matchbox pour Autodesk Flame\n\n// Adapted to Natron by F.Fernandez\n// Original code : Ls_Glint Matchbox for Autodesk Flame\n\n\n// iChannel0: pass2_result, filter = linear , wrap = clamp\n// iChannel1: Source, filter = linear , wrap = clamp\n// iChannel2: Mask, filter = linear , wrap = clamp\n// BBox: iChannel0\n\n\n// Glint pass 3: Gaussian blur vertical and comp\n// lewis@lewissaunders.com\n\n\n\nfloat blursize = 0.5;     // Blur : , min=0.0, max=10000.0\nfloat blursizer = 1.0;    // Blur weight R : , min=0.0, max=10000.0\nfloat blursizeg = 1.0;    // Blur weight G : , min=0.0, max=10000.0\nfloat blursizeb = 1.0;    // Blur weight B : , min=0.0, max=10000.0\n\nbool screen = true; // Screen Highlights : (Screens the glints over the image instead of simply adding them)\nbool usematte = false; // Use Matte on Glint Source : (Generate glints only from highlights inside the matte; the matte can also be RGB to selectively tint the stars)\nbool useblendmatte = false; // Use Matte to Blend (faster) : (Only processes pixels inside the matte - this is really fast for small mattes, but glints will be cut off at the matte edge)\nbool outputglints = false; // Output Glints Only : (Output just the glints on black)\n\n\n// RGB to Rec709 YPbPr\nvec3 yuv(vec3 rgb) {\n    return mat3(0.2215, -0.1145, 0.5016, 0.7154, -0.3855, -0.4556, 0.0721, 0.5, -0.0459) * rgb;\n}\n\n// Return a 1D Gaussian blur from texture tex\n// xy: centre of blur in pixels\n// res: pixel size of mipmap level selected by lod param\n// sizes: sigma of blurs, in pixels\n// dir: direction of blur, usually vec2(1.0, 0.0) for horizontal followed by\n//      another pass for vertical\nvec4 gaussianblur(sampler2D tex, vec2 xy, vec2 res, float sizered, float sizegreen, float sizeblue, float sizealpha, vec2 dir) {\n    vec4 sigmas = vec4(sizered, sizegreen, sizeblue, sizealpha);\n\n    // Set up state for incremental coefficient calculation, see GPU Gems\n    // We use vec4s to store four copies of the state, for different size\n    // red/green/blue/alpha blurs\n    vec4 gx, gy, gz;\n    gx = 1.0 / (sqrt(2.0 * 3.141592653589793238) * sigmas);\n    gy = exp(-0.5 / (sigmas * sigmas));\n    gz = gy * gy;\n    // vec4 a, centre, sample1, sample2 = vec4(0.0);\n    vec4 a = vec4(0.0);\n    vec4 centre = vec4(0.0);\n    vec4 sample1 = vec4(0.0);\n    vec4 sample2 = vec4(0.0);\n\n    // First take the centre sample\n    centre = texture(tex, xy / res);\n    a += gx * centre;\n    vec4 energy = gx;\n    gx *= gy;\n    gy *= gz;\n\n    // Now the other samples\n    float support = max(max(max(sigmas.r, sigmas.g), sigmas.b), sigmas.a) * 3.0;\n    for(float i = 1.0; i <= support; i++) {\n        sample1 = texture(tex, (xy - i * dir) / res);\n        sample2 = texture(tex, (xy + i * dir) / res);\n        a += gx * sample1;\n        a += gx * sample2;\n        energy += 2.0 * gx;\n        gx *= gy;\n        gy *= gz;\n    }\n\n    a /= energy;\n\n    if(sizered < 0.1) a.r = centre.r;\n    if(sizegreen < 0.1) a.g = centre.g;\n    if(sizeblue < 0.1) a.b = centre.b;\n\n    return a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = vec2(iResolution.x, iResolution.y);\n    vec2 xy = fragCoord.xy;\n\n    vec3 frontpix = texture(iChannel1, xy/res).rgb;\n    vec3 mattepix = texture(iChannel2, xy/res).rgb;\n\n    vec3 blurred = gaussianblur(iChannel0, xy, res, blursize*blursizer, blursize*blursizeg, blursize*blursizeb, 0.0, vec2(0.0, 1.0)).rgb;\n\n    // Blend with front input\n    vec3 result;\n    float blurredluma;\n    if(useblendmatte == true) {\n        blurred *= mattepix;\n        blurredluma = yuv(blurred.rgb).r; // Luma is used for matte output below\n    }\n    if(screen == true) {\n        result = max(max(frontpix, blurred), blurred+frontpix-(blurred*frontpix));\n    } else {\n        result = frontpix + blurred;\n    }\n    if(outputglints == true) {\n        result = blurred;\n    }\n\n    // Matte output is luma of glint only\n    fragColor = vec4(result, blurredluma);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//\n//\n//                          MMMMMMMMMMMMMMMMMMMMMMMMMMMM\n//                        MM.                          .MM\n//                       MM.  .MMMMMMMMMMMMMMMMMMMMMM.  .MM\n//                      MM.  .MMMMMMMMMMMMMMMMMMMMMMMM.  .MM\n//                     MM.  .MMMM        MMMMMMM    MMM.  .MM\n//                    MM.  .MMM           MMMMMM     MMM.  .MM\n//                   MM.  .MmM              MMMM      MMM.  .MM\n//                  MM.  .MMM                 MM       MMM.  .MM\n//                 MM.  .MMM                   M        MMM.  .MM\n//                MM.  .MMM                              MMM.  .MM\n//                 MM.  .MMM                            MMM.  .MM\n//                  MM.  .MMM       M                  MMM.  .MM\n//                   MM.  .MMM      MM                MMM.  .MM\n//                    MM.  .MMM     MMM              MMM.  .MM\n//                     MM.  .MMM    MMMM            MMM.  .MM\n//                      MM.  .MMMMMMMMMMMMMMMMMMMMMMMM.  .MM\n//                       MM.  .MMMMMMMMMMMMMMMMMMMMMM.  .MM\n//                        MM.                          .MM\n//                          MMMMMMMMMMMMMMMMMMMMMMMMMMMM\n//\n//\n//\n//\n// Adaptation pour Natron par F. Fernandez\n// Code original : Ls_Glint Matchbox pour Autodesk Flame\n\n// Adapted to Natron by F.Fernandez\n// Original code : Ls_Glint Matchbox for Autodesk Flame\n\n\n// iChannel0: Source, filter = linear , wrap = clamp\n// iChannel1: Mask, filter = linear , wrap = clamp\n// BBox: iChannel0\n\n\n// Glint pass 1: convolve with a dynamically generated star function\n// lewis@lewissaunders.com\n\n\n// TODO: option to downres / process / upres, as request by GP-M\n\n\n\nfloat threshold = .3;              // Threshold : (Highlights darker than this are ignored), min=0.0, max=200.0\nfloat thresholdclamp = 5.0;         // Threshold Clamp : (Highlights brighter than this don't increase the glint further, to avoid hot pixels creating huge stars), min=0.0, max=200.0\n\nfloat gain = 50.0;                  // Gain : (Overall brightness of stars), min=0.0, max=2000.0\nfloat size = 100.0;                  // Size : (Size of the stars), min=0.01, max=400.0\nfloat rays = 6.0;                   // Rays : (How many points each star has), min=0.0, max=100.0\nfloat spin = 48.0;                  // Spin : (Rotate the stars), min=-360.0, max=360.0\nfloat falloff = 1.9;                // Falloff : (Dissolves away ends of rays), min=-2.0, max=4.0\nfloat twirl = 0.0;                  // Twirl : (Bend the arms of the stars), min=-1080.0, max=1080.0\nfloat barrel = 0.0;                 // Barrel Distort : (Bend stars around center of frame), min=-10.0, max=10.0\nfloat barrelbend = 2.0;             // Barrel Bend : (Bendiness of barrel distortion), min=1.0, max=20.0\nfloat saturation = 0.0;             // Saturation : (How much star colour comes from the underlying image), min=-10.0, max=10.0\nfloat extrasize = 1.0;              // Extra Size : (Extra multiplier on size if you want extra big glints - it will get slow, be careful!), min=0.01, max=20.0\nfloat extrarays = 1.0;              // Extra Rays : (Extra multiplier on ray count if you want many more ray arms - it will get slow, be careful!), min=0.01, max=20.0\n\nvec3 tint = vec3( 1.0 , 1.0 , 1.0); // Tint : (Tint the stars towards this colour)\n\nbool dirton = true; // Use Noise : \nbool usematte = true; // Use Matte on Glint Source : (Generate glints only from highlights inside the matte; the matte can also be RGB to selectively tint the stars)\nbool useblendmatte = false; // Use Matte to Blend (faster) : (Only processes pixels inside the matte - this is really fast for small mattes, but glints will be cut off at the matte edge)\n\nvec2 dirtParam = vec2( 0.1, 5.0 ); // Dirt Parameters : \n\nvec3 dispDispOffsetDispCycles = vec3( 0.25 , -45.0 , 1.0 ); // Dispersion Parameters : \n\nvec2 aspectAA = vec2( 1.0 , 1.4 ); // Aspect and AA samples : \n\n\n\n#define realsize (size*extrasize)\n#define samples (size*extrasize*aspectAA.y)\n#define tau (2.0*3.1415926535)\n\n// RGB to Rec709 YPbPr\nvec3 yuv(vec3 rgb) {\n    return mat3(0.2215, -0.1145, 0.5016, 0.7154, -0.3855, -0.4556, 0.0721, 0.5, -0.0459) * rgb;\n}\n\n// Rec709 YPbPr to RGB\nvec3 rgb(vec3 yuv) {\n    return mat3(1.0, 1.0, 1.0, 0.0, -0.1870, 1.8556, 1.5701, -0.4664, 0.0) * yuv;\n}\n\n// Noise\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453) - 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / vec2(iResolution.x, iResolution.y);\n    vec3 frontpix = texture(iChannel0, uv).rgb;\n    vec3 mattepix = texture(iChannel1, uv).rgb;\n    vec3 sampler, glint = vec3(0.0);\n    vec2 offset;\n    float angle;\n\n    // If matte is being used to blend with, we can take a massive shortcut where it's black\n    if(useblendmatte && (length(mattepix) < 0.0001)) {\n        fragColor = vec4(frontpix, 0.0);\n        return;\n    }\n\n    // Iterate around rays\n    for(float ray = 0.0; ray < floor(rays*extrarays); ray++) {\n        // Figure out what angle this ray is at\n        angle = ray * tau/floor(rays*extrarays);\n\n        // Spin rotates entire glint\n        angle -= spin/360.0 * tau;\n\n        // Iterate along arm of ray\n        for(float i = realsize/samples; i < realsize; i += realsize/samples) {\n            // Twirl ray around further as we move out\n            angle -= (twirl/samples * i/realsize)/360.0 * tau;\n\n            // Offset along ray direction\n            offset = i/vec2(iResolution.x, iResolution.y) * vec2(cos(angle), sin(angle));\n\n            // Horizontal stretch/squash for anamorphic glints\n            offset.x *= aspectAA.x;\n\n            // Barrel pushes ends of rays away towards edge of frame\n            offset -= pow((i/realsize), barrelbend) * 0.1 * barrel * (-uv+vec2(0.5, 0.5));\n\n            // Read a pixel\n            sampler = texture(iChannel0, uv + offset).rgb;\n\n            // Affect it by the matte\n            if(usematte) {\n                sampler *= texture(iChannel1, uv + offset).rgb;\n            }\n\n            // Only keep pixels over threshold\n            sampler = min(sampler, thresholdclamp);\n            sampler *= max(sampler - threshold, 0.0);\n\n            // Falloff darkens the ray ends\n            if(falloff > 1.0) {\n                sampler *= max(0.0, mix(1.0, -falloff+2.0, i/realsize));\n            } else {\n                sampler *= max(0.0, mix(falloff, 1.0, i/realsize));\n            }\n\n            // Do saturation in YUV\n            vec3 sampley = yuv(sampler);\n            sampley.gb *= saturation;\n\n            // Hue varies along length of ray\n            float hue = dispDispOffsetDispCycles.b * tau *-i/realsize;\n            hue -= dispDispOffsetDispCycles.g/360.0 * tau;\n\n            // I'm adventurously using YUV to do a rainbow tint here\n            // The discontinuities in the usual HSV method bug me\n            // and are probably slower than this, which just requires\n            // matrix mults and a bit of trig\n            // Hue is the angle around centre of UV plane\n            vec2 rainbow = vec2(cos(hue), sin(hue)) * sampley.r;\n            sampley.gb = mix(sampley.gb, rainbow, dispDispOffsetDispCycles.r * i/realsize);\n            sampler = rgb(sampley);\n\n            if(dirton) {\n                // Multiply by a bit of noise texture\n                float noiz = rand(vec2(42.1, 12.4) + 0.01 * vec2(dirtParam.y/100.0)   * offset);\n                noiz +=      rand(vec2(4.1, 1.4)   + 0.01 * vec2(dirtParam.y/1000.0)  * offset);\n                noiz +=      rand(vec2(2.1, 2.4)   + 0.01 * vec2(dirtParam.y/10000.0) * offset);\n                sampler *= mix(1.0, clamp(10.0 * noiz, 0.0, 99.0), dirtParam.x);\n            }\n\n            // Accumulate\n            glint += sampler;\n        }\n    }\n    // Normalise all our accumulated samples\n    glint /= floor(rays*extrarays) * samples;\n\n    // Master brightness\n    glint *= gain;\n\n    // Tint in YUV space\n    vec3 glinty = yuv(glint);\n    vec3 tinty = yuv(tint);\n    tinty.gb *= glinty.r; // If U/V aren't 0 when Y is black, bad things happen...\n    glinty.gb = mix(glinty.gb, tinty.gb, 4.0*length(tinty.gb));\n    glint = rgb(glinty);\n\n    fragColor = vec4(glint, 0.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//\n//\n//                          MMMMMMMMMMMMMMMMMMMMMMMMMMMM\n//                        MM.                          .MM\n//                       MM.  .MMMMMMMMMMMMMMMMMMMMMM.  .MM\n//                      MM.  .MMMMMMMMMMMMMMMMMMMMMMMM.  .MM\n//                     MM.  .MMMM        MMMMMMM    MMM.  .MM\n//                    MM.  .MMM           MMMMMM     MMM.  .MM\n//                   MM.  .MmM              MMMM      MMM.  .MM\n//                  MM.  .MMM                 MM       MMM.  .MM\n//                 MM.  .MMM                   M        MMM.  .MM\n//                MM.  .MMM                              MMM.  .MM\n//                 MM.  .MMM                            MMM.  .MM\n//                  MM.  .MMM       M                  MMM.  .MM\n//                   MM.  .MMM      MM                MMM.  .MM\n//                    MM.  .MMM     MMM              MMM.  .MM\n//                     MM.  .MMM    MMMM            MMM.  .MM\n//                      MM.  .MMMMMMMMMMMMMMMMMMMMMMMM.  .MM\n//                       MM.  .MMMMMMMMMMMMMMMMMMMMMM.  .MM\n//                        MM.                          .MM\n//                          MMMMMMMMMMMMMMMMMMMMMMMMMMMM\n//\n//\n//\n//\n// Adaptation pour Natron par F. Fernandez\n// Code original : Ls_Glint Matchbox pour Autodesk Flame\n\n// Adapted to Natron by F.Fernandez\n// Original code : Ls_Glint Matchbox for Autodesk Flame\n\n\n// iChannel0: pass1_result, filter = linear , wrap = clamp\n// BBox: iChannel0\n\n\n// Glint pass 2: Gaussian blur horizontal\n// lewis@lewissaunders.com\n\n\n\nfloat blursize = 0.5;     // Blur : , min=0.0, max=10000.0\nfloat blursizer = 1.0;    // Blur weight R : , min=0.0, max=10000.0\nfloat blursizeg = 1.0;    // Blur weight G : , min=0.0, max=10000.0\nfloat blursizeb = 1.0;    // Blur weight B : , min=0.0, max=10000.0\n\n\n\n// Return a 1D Gaussian blur from texture tex\n// xy: centre of blur in pixels\n// res: pixel size of mipmap level selected by lod param\n// sizes: sigma of blurs, in pixels\n// dir: direction of blur, usually vec2(1.0, 0.0) for horizontal followed by\n//      another pass for vertical\nvec4 gaussianblur(sampler2D tex, vec2 xy, vec2 res, float sizered, float sizegreen, float sizeblue, float sizealpha, vec2 dir) {\n    vec4 sigmas = vec4(sizered, sizegreen, sizeblue, sizealpha);\n\n    // Set up state for incremental coefficient calculation, see GPU Gems\n    // We use vec4s to store four copies of the state, for different size\n    // red/green/blue/alpha blurs\n    vec4 gx = vec4(0.0);\n    vec4 gy = vec4(0.0);\n    vec4 gz = vec4(0.0);\n\n    gx = 1.0 / (sqrt(2.0 * 3.141592653589793238) * sigmas);\n    gy = exp(-0.5 / (sigmas * sigmas));\n    gz = gy * gy;\n    // vec4 a, centre, sample1, sample2 = vec4(0.0);\n    vec4 a = vec4(0.0);\n    vec4 centre = vec4(0.0);\n    vec4 sample1 = vec4(0.0);\n    vec4 sample2 = vec4(0.0);\n\n    // First take the centre sample\n    centre = texture(tex, xy / res);\n    a += gx * centre;\n    vec4 energy = gx;\n    gx *= gy;\n    gy *= gz;\n\n    // Now the other samples\n    float support = max(max(max(sigmas.r, sigmas.g), sigmas.b), sigmas.a) * 3.0;\n    for(float i = 1.0; i <= support; i++) {\n        sample1 = texture(tex, (xy - i * dir) / res);\n        sample2 = texture(tex, (xy + i * dir) / res);\n        a += gx * sample1;\n        a += gx * sample2;\n        energy += 2.0 * gx;\n        gx *= gy;\n        gy *= gz;\n    }\n    \n    a /= energy;\n    \n    if(sizered < 0.1) a.r = centre.r;\n    if(sizegreen < 0.1) a.g = centre.g;\n    if(sizeblue < 0.1) a.b = centre.b;\n    \n    return a; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = vec2(iResolution.x, iResolution.y);\n    vec2 xy = fragCoord.xy;\n    fragColor = gaussianblur(iChannel0, xy, res, blursize*blursizer, blursize*blursizeg, blursize*blursizeb, 0.0, vec2(1.0, 0.0));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}