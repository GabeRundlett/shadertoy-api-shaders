{
    "Shader": {
        "info": {
            "date": "1638558995",
            "description": "An HexaGold :-,)",
            "flags": 0,
            "hasliked": 0,
            "id": "7lV3Wd",
            "likes": 62,
            "name": "HexaGold",
            "published": 3,
            "tags": [
                "hexagon",
                "hex",
                "hexa",
                "gold"
            ],
            "usePreview": 0,
            "username": "aiekick",
            "viewed": 1260
        },
        "renderpass": [
            {
                "code": "// Created by Stephane Cuillerdier - Aiekick/2021 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned with Noodlesplate (https://github.com/aiekick/NoodlesPlate)\n\n// turning table angle offset for the thumbnail at time 0\n#define THUMBNAIL_ANGLE_OFFSET 0.35\n\n// from IQ, https://www.shadertoy.com/view/Xds3zN\n// sdf of heaxagong\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// hexagons repeat placement\n#define ox 1.3\n#define oz 1.5\n\n// hexacone :-,)\n// reduce hexagon size with height\n#define hex_size vec2(0.5 - p.y * 0.1, 10)\n\t\n// common part used by the map and mat functions\n// return the two sdf's\nvoid common_map(vec3 p, out float df0, out float df1)\n{\n    // the horizontal wave\n\tdf0 = p.y - 1.0 + sin(length(p.xz) * 0.8 - iTime);\n\t\n    // first hexagones row\n\tvec3 q0 = p;\n\tq0.x = mod(q0.x - ox, ox + ox) - ox;\n\tq0.z = mod(q0.z - oz * 0.5, oz) - oz * 0.5;\n\tfloat hex0 = sdHexPrism(q0.xzy, hex_size) - 0.2; \n\t\n    // second hexagones row\n\tvec3 q1 = p;\n\tq1.x = mod(q1.x, ox + ox) - ox;\n\tq1.z = mod(q1.z, oz) - oz * 0.5;\n\tfloat hex1 = sdHexPrism(q1.xzy, hex_size) - 0.2; \n\t\n    // the hexagones\n\tdf1 = min(hex0, hex1);\n}\n\n// from IQ\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k)\n{\n    return smin(a, b, -k);\n}\n\n// return the final SDF\nfloat map(vec3 p)\n{\n    float df0, df1;\n    common_map(p, df0, df1);\n    \n    // final df\n    return smax(df0, df1, 0.1);\n    //return max(df0, df1);\n}\n\n// same code as map but with decomposition of the last max()\n// for return the material id\nfloat mat(vec3 p)\n{\n\tfloat df0, df1;\n    common_map(p, df0, df1);\n    \n    // max() decomposition for get df id\n\tif (df0 > df1)\n\t\treturn 1.0;\n\treturn 0.0;\n}\n\n// get normal for the surface point and a precision\nvec3 getNormal(vec3 p, float prec)\n{\n\tvec3 e = vec3(prec, 0, 0);\n\treturn normalize(vec3(\n\t\tmap(p+e)-map(p-e),\n\t\tmap(p+e.yxz)-map(p-e.yxz),\n\t\tmap(p+e.zyx)-map(p-e.zyx)));\n}\n\n// IQ Occ\nfloat getAmbiantOcclusion(vec3 p, vec3 n, float k)\n{\n    const float aoStep = 0.1; \n\tfloat occl = 0.;\n    for(int i = min(iFrame,0); i < 6; ++i)\n    {\n        float diff = float(i)*aoStep;\n        float d = map(p + n*diff);\n        occl += (diff - d) * pow(2., float(-i));\n    }\n    return min(1., 1. - k*occl);\n}\n\n// IQ Shadow\nfloat getShadow(vec3 ro, vec3 rd, float minD, float maxD, float k)\n{\n    float res = 1.0;\n    float d = minD;\n\tfloat s = 0.;\n    for(int i = min(iFrame,0); i < 20; ++i)\n    {\n        s = map(ro + rd * d);\n        if( abs(s)<d*d*1e-5 ) return 0.0;\n        res = min( res, k * s / d );\n\t\td += s;\n        if(d >= maxD) break;\n    }\n    return res;\n}\n\n// get the perpsective camera\nvec3 cam(vec2 uv, vec3 ro, vec3 cv, float fov)\n{\n\tvec3 cu = normalize(vec3(0,1,0));\n  \tvec3 z = normalize(cv-ro);\n    vec3 x = normalize(cross(cu,z));\n  \tvec3 y = cross(z,x);\n  \treturn normalize(z + fov*uv.x*x + fov*uv.y*y);\n}\n\n// from IQ https://www.shadertoy.com/view/MsS3Wc\n// Smooth HSV to RGB conversion \nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 si = iResolution.xy;\n    \n    // central uv\n    vec2 uvc = (2.*fragCoord.xy-si)/si.y;\n    \n    // classice turning table camera\n\tfloat a = iTime * 0.1 + THUMBNAIL_ANGLE_OFFSET;\n\tvec3 ro = vec3(cos(a), 0.0, sin(a)) * 20.0;\n\tro.y = 20.0;\n\tvec3 rd = cam(uvc, ro, vec3(0), 0.4);\n\n    vec3 col = vec3(0.1);\n\n    // log raymarching\n    float s = 1., d = 0., md = 100.;\n\tfor (int i = min(iFrame,0); i < 200; i++)\n\t{\n\t\tif (d*d/s>1e8 || d > 70.) break;\n\t\ts = map(ro + rd * d);\n\t\td += s * 0.5;\n\t}\n\t\n\tif (d < md)\n\t{\n        // surface point\n\t\tvec3 p = ro + rd * d;\n        \n        // surface normal, precision of 0.1 for remove some aliasing\n\t\tvec3 n = getNormal(p, 0.1);\n\t\t\n\t\t// light pos\n\t\tvec3 lp = vec3(0,5,0);\n\t\t\n\t\t// light dir\n\t\tvec3 ld = normalize(lp - p);\n\t\t\t\t\t\t\t\t\n        // diffuse, ambiant occlusion, shadow, specular\n\t\tfloat diff = pow(dot(n, ld) * .5 + .5,2.0);\n\t\tfloat ao = getAmbiantOcclusion(p, n, 40.0);\n\t\tfloat sha = clamp(getShadow(p, ld, 0.01, 150.0, 5.0), 0. ,0.9);\n\t\tfloat spe = pow(max(dot(-rd, reflect(-ld, n)), 0.0), 32.0);\n\t\t\n\t\tif (mat(p) < 0.5) // hexa sides\n        { \n\t\t\t// smooht hsv\n            vec3 base = hsv2rgb_smooth(vec3(atan(p.x,p.z)/3.14159*0.5 - iTime * 0.1, 0.8, 0.8)); \n            \n            // vary base color according to ao\n\t\t\tcol = mix(base, vec3(1), ao) * 0.5;\n\t\t} \n        else // hexa face\n        { \n            // reflected gold\n            col = vec3(1.0, 0.85, 0.0) * texture(iChannel0, reflect(rd, n)).rgb;\t\n        }\n\t\t\n        // final brdf\n\t\tcol += diff * sha * 0.5 + spe;\n        \n        // clamp for avoid overlight\n\t\tcol = clamp(col, 0., 1.);\n\t}\n\t\n    // distance fog\n\tcol *= exp(1.0-d*d*0.001);\n\t\n    // final color\n\tfragColor = vec4(col,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}