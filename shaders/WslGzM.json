{
    "Shader": {
        "info": {
            "date": "1547834578",
            "description": "just some raymarching test",
            "flags": 32,
            "hasliked": 0,
            "id": "WslGzM",
            "likes": 9,
            "name": "Marcher of Puppets",
            "published": 3,
            "tags": [
                "raymarch"
            ],
            "usePreview": 0,
            "username": "crocidb",
            "viewed": 406
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 100\n#define MAX_DIST 90.0\n#define SURF_DIST 0.01\n\nconst vec3 color_floor = vec3(0.478, 0.395, 0.012);\nconst vec3 color_croci = vec3(1.0);\n\n// Noise and FBM (as seen on iq tutorials)\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\nconst mat3 m3i = mat3( 0.00, -0.80, -0.60,\n                       0.80,  0.36, -0.48,\n                       0.60, -0.48,  0.64 );\nconst mat2 m2 = mat2(  0.80,  0.60,\n                      -0.60,  0.80 );\nconst mat2 m2i = mat2( 0.80, -0.60,\n                       0.60,  0.80 );\n\nfloat hash1( vec2 p )\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat hash1( float n )\n{\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n\nvec4 noised( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n\n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n\tfloat f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z), \n                      2.0* du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                                      k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                                      k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\n\nvec4 fbm( in vec3 x, int octaves ) \n{\n    float f = 1.98;  // could be 2.0\n    float s = 0.49;  // could be 0.5\n    float a = 0.0;\n    float b = 0.5;\n    vec3  d = vec3(0.0);\n    mat3  m = mat3(1.0,0.0,0.0,\n                   0.0,1.0,0.0,\n                   0.0,0.0,1.0);\n    for( int i=0; i < octaves; i++ )\n    {\n        vec4 n = noised(x);\n        a += b*n.x;          // accumulate values\t\t\n        d += b*m*n.yzw;      // accumulate derivatives\n        b *= s;\n        x = f*m3*x;\n        m = f*m3i*m;\n    }\n    return vec4( a, d );\n}\n\nvec3 applyFog( in vec3  rgb,       // original color of the pixel\n               in float distance ) // camera to point distance\n{\n    const float b = .01;\n    float fogAmount = 1.0 - exp( -pow(distance, 1.45)*b );\n    vec3  fogColor  = vec3(0.812, 0.275, 0.016);\n    return mix( rgb, fogColor, fogAmount );\n}\n\n// Marching functions\n\nstruct object\n{\n    float d;\n    int id;\n};\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0));\n}\n\nfloat croce(vec3 p)\n{\n    return min(sdBox(p, vec3(0.2, 1.0, 0.2)), sdBox(p - vec3(0.0, 0.25, 0.0), vec3(0.8, 0.2, 0.2)));\n}\n\nobject croci( in vec3 p)\n{\n    vec3 c = vec3(3.5, 0.0, 2.7);\n    vec3 q = mod(p,c)-0.5*c;\n    return object(croce(q), 1);\n}\n\nobject floor_plane(vec3 p)\n{\n    float f = p.y - .1 + fbm(p, 8).x * 0.25;\n    //float g = p.y - .1 + fbm(p, 12).y * 0.25;\n    return object(f, 0);\n}\n\nobject getDist(vec3 p) \n{\n    vec4 s = vec4(0.0, 1.0, 6.0, 1.0);\n    object box = croci(p - s.xyz);\n    object plane = floor_plane(p);\n    \n    if (box.d < plane.d && p.z > 2.8)\n    {\n        return box;\n    }\n    \n    return plane;\n}\n\nobject rayMarch(vec3 ro, vec3 rd)\n{\n    object obj;\n    obj.d = 0.0;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * obj.d;\n        object o = getDist(p);\n        \n        obj.d += o.d;\n        obj.id = o.id;\n        \n        if (obj.d > MAX_DIST || o.d < SURF_DIST) break;\n    }\n    \n    return obj;\n}\n\nvec3 getNormal(vec3 p)\n{\n    object o = getDist(p);\n    vec2 e = vec2(0.01, 0.0);\n    \n    vec3 n = o.d - vec3(\n        getDist(p - e.xyy).d,\n        getDist(p - e.yxy).d,\n        getDist(p - e.yyx).d);\n    \n\treturn normalize(n);\n}\n\nfloat getDiffuse(vec3 p)\n{\n    vec3 lightPos = vec3(2.0, 7.5, 15.0);\n    lightPos.xz += vec2(sin(iTime * .8), cos(iTime)) * 0.6;\n    \n    vec3 l = normalize(lightPos - p);\n    vec3 n = getNormal(p);\n    \n    float diffuse = max(0.0, dot(l, n));\n    \n    object o = rayMarch(p + n * SURF_DIST * 2.0, l);\n    if (o.d < length(lightPos - p)) diffuse *= .1;\n    \n    return diffuse;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    vec2 uv2 = (fragCoord/iResolution.xy);\n\n    vec3 col = vec3(0);\n    \n    vec2 movement = vec2(\n        ((iMouse.x - iResolution.x / 2.0) * 0.0005),\n        ((iMouse.y - iResolution.y / 2.0) * 0.0005));\n    \n    vec3 ro = vec3(1.75 + movement.x, 2.2 + (iMouse.y * 0.0005), -1.3);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n    \n    object o = rayMarch(ro, rd);\n    vec3 p = ro + rd * o.d;\n    \n    float diffuse = getDiffuse(p);\n    \n    if (o.id == 0)\n    {\n        col = color_floor * .05 + diffuse * color_floor;\n    }\n    else\n    {\n        col = color_croci * .5 + diffuse * .5;\n    }\n    \n    if (o.d > MAX_DIST)\n    {\n        col = texture(iChannel0, uv2).r * vec3(0.812, 0.275, 0.016);\n    }\n    else\n    {\n        //col = mix(col, vec3(0.812, 0.275, 0.016), clamp(0.0, 1.0, pow(o.d, 1.2) / pow(40.0, 1.2)));\n        col = applyFog(col, o.d);\n    }\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// SNOISE function from: https://www.shadertoy.com/view/lsf3RH\nfloat snoise(vec3 uv, float res)\n{\n\tconst vec3 s = vec3(1e0, 1e2, 1e3);\n\t\n\tuv *= res;\n\t\n\tvec3 uv0 = floor(mod(uv, res))*s;\n\tvec3 uv1 = floor(mod(uv+vec3(1.), res))*s;\n\t\n\tvec3 f = fract(uv); f = f*f*(3.0-2.0*f);\n\n\tvec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\n\t\t      \t  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\n\n\tvec4 r = fract(sin(v*1e-1)*1e3);\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\tr = fract(sin((v + uv1.z - uv0.z)*1e-1)*1e3);\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\treturn mix(r0, r1, f.z)*2.-1.;\n}\n\nfloat noise(vec2 uv, float baseres)\n{\n    float n = 0.0;\n    for (int i = 0; i < 7; i++)\n    {\n        float v = pow(2.0, float(i));\n        n += (1.5 / v) * snoise(vec3(uv + vec2(1.,1.) * (float(i) / 17.), 1), v * baseres);\n    }\n    \n    \n    return clamp((1.0 - n) * .5, 0., 1.);\n}\n\nconst vec2 center = vec2(0.5, 0.5);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy);\n    \n    vec2 s1 = uv + vec2(iTime * 0.04, 0.0);\n    vec2 s2 = uv + vec2(iTime * -0.02, iTime * - 0.05);  \n    \n    float dist = 1.0 - length(uv - center);\n    \n    float samplings = noise(s1, 10.0) * noise(s2, 10.0);\n    float n = samplings * pow(dist, 4.5);\n    n += dist * .4f;\n    n += pow(dist, 7.0) * .7;\n    \n    \n    fragColor = vec4(n);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}