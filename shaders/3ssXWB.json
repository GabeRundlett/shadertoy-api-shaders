{
    "Shader": {
        "info": {
            "date": "1552055826",
            "description": "(a)%(b)==(a)-((a)/(b))*(b)  //division before multiplication!!!\n//use this explicit minteger modulo,and you will be SAFE\n\n//float version just adds a floor;\nmod(a,b)==(a)-(floor((a)/(b))*(b))\n\nand for VERY short intervals you may want to do a +.5 offset",
            "flags": 0,
            "hasliked": 0,
            "id": "3ssXWB",
            "likes": 13,
            "name": "how to not use [%] modulo",
            "published": 3,
            "tags": [
                "modulo",
                "precision",
                "integer",
                "offset",
                "33",
                "negative",
                "interval",
                "fixed",
                "period",
                "webgl2",
                "webgl1",
                "remainder",
                "incompatible",
                "version",
                "3cubessum"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 7729
        },
        "renderpass": [
            {
                "code": "//do not use the [%] operand\n//thats all folks.\n\n//2 main reasons to not use [%]\n//- it makes your code incpompatible with Webgl(1)\n//- it is inconsistent for negative inputs, and almost certtainly nonsense\n//- - see that yellow diagonal in the left half /in webgl2)\n//- - , thats [%] for negative inputs.\n//- - move mouse to the left half, \n//- - and have the other inpout negated, for even worse cases.\n//- move mouse close to center\n//- , thats modulo with very short period (a tricky bitch)\n\n//see the purple line\n//, thats code that i made for this shader, its awesome:\n\n//webgl2 % operand is a sick pathetic joke.\n//this shader has 2 things:\n//- a canvas to run 1 function in 2 modes\n//- - one is Webgl2 exclusive, showing you how pathethic [%] is\n//- - one is Webgl1 OPTIONAL, shows how the same function takes type int ant type float.\n//- 4 green circles, your function is the opengl2 mode one\n//- 1 green circle, your function os the opengl(1) mode one.\n\n\n//this shader compares modulo \n//and uses __VERSION__ to emulate webgl case within Webgl2.\n\n//3rd reason to not use [%] EVER\n//this sdhader has a 3rd type of modulo\n//it returns type float\n//it takes type int and type float as inouts\n//it is a LOT like [%] \n//- - will NOT (necessarily) convert to type float internally on type int inputs.\n//- - - type float output is just for output consistency, you modify that, you can do that!\n//- - BUT it is fixed for negative inoputs\n//- but i likely will easily do 33%33 and mod/33.,33.) correctly\n\n\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n   // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor=Port(iTime,u.xy,iResolution.xyz,iMouse);\n    //fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//core identity here is\n// mo(a,b) = (a)-(fl((a)/(b))*(b))     //div before mult! fl() is only relevant for type float\n// mod(a,b) = (a)-(floor((a)/(b))*(b)) //div before mult! for type float\n// mod(a,b) = a-((a/b)*b)              //INTEGER division for multiplication.\n\n//convention vec2(0) is in the center of the screen:\n#define dd(a)dot(a,a)\n#define                    viewZoom 2.\n#define Aa   (min(r.x,r.y)/viewZoom) //1/Aa is a hairlineWidth, for smoothstep(Aa,-Aa,distanceField())\n#define fra(u)((u-.5*r.xy)*viewZoom/r.y)\n\n//convention: assert [indexing starts at 0] and run with it in all namespaces\n//this feels sick initially, but you can get used to it:\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n#define i0 int\n#define i1 ivec2\n#define i2 ivec3\n#define i3 ivec4\n#define m1 mat2\n#define m2 mat3\n#define m3 mat4\n//sadly good aliases eat a lot of good namespace\n\n//convention: code uses a lot of #define to\n//- induce functions to work over n domains (not just in 2d or 3d, butjsut as well in 1d and 4d)\n//- induce functions to work with different input types\n//- convention: label functions after output domainCount\n//--inputDomainCount || inputTypes are NOT part of a function label, but part of its parameters. \n//--(same label comes in different versions)\n//--- eg hashv3() returns 4 domains of type float (a vec4==v3), it may come in many inputType variants\n//--- eg, a mo*() function may return type int or type float; as mov0() moi0()\n//--convention: inducedFunctionParameters are enumerated alphabetically, constantss may replace a letter\n\n//concention: explicitly define matAB as structs, because\n//- it defines vec in the same namespace as mat, this induction simplifies things\n//--it is no longer possible to confuse rows for columns or noncommutativity in multiplication.\n//--outerproduct() is barely used anyways\n//- this makes a lot of sense for a chain rule in higher dimensions\n//- matrix syntax has too many silly constrains for what this sometimes needs\n//- piecewise operators on matrices are shit in opengl\n//- it enforces .a .b .c swivel namespaces, which at least are sorted alphabetically!\nstruct v33{v3 a;v3 b;};//mat24 //for 2 domains(density/distance field)\nstruct v22{v2 a;v2 b;};//mat23\nstruct v11{v1 a;v1 b;};//mat22\nstruct v00{v0 a;v0 b;};//mat21==vec2\nstruct v333{v3 a;v3 b;v3 c;};//mat34 //for 3 domains(density/distance field); also used in DA,but as bridge to non-DA.\nstruct v222{v2 a;v2 b;v2 c;};//mat33\nstruct v111{v1 a;v1 b;v1 c;};//mat32\nstruct v2222{v2 a;v2 b;v2 c;v2 d;};//mat43\n//v222 g111(v2 a,v2 b){return v222(v1(a.x,b.x),v1(a.y,b.y),v1(a.z,b.z));}\nv111 g111(v33 a){return v111(v1(a.a.x,a.b.x),v1(a.a.y,a.b.y),v1(a.a.z,a.b.z));}\nv2222 muv(v2222 a,v3 b){return v2222(a.a*b.x,a.b*b.y,a.c*b.z,a.d*b.w);}\nv3 ddv(v2222 a){return v3(dd(a.a),dd(a.b),dd(a.c),dd(a.d));}\n//as long as its less than a vec4, the above seems silly\n//, but with chain rule stuff, we may quickly get into more json-like domains.\n\n//above [v*] struct implies matrix arithmetic,below [w*] struct implies AD\n//convention; the w-struct implies chain-rule syntax, where each domain[a] is the derivative of the domain[b] to its left.\n//where later domains are (analytic) lower-exponent-differentials\n//[.b] is always a derivative of [.a],along one (of multiple) domain(s)\nstruct w00{v0 a;v0 b;};\nstruct w01{v0 a;v1 b;};\nstruct w02{v0 a;v2 b;};\nstruct w03{v0 a;v3 b;};\nstruct DAm2{w02 x;w02 y;w02 z;};//for 3 domains (density/distance field) \nstruct DAm1{w01 x;w01 y;};      //for 2 domains (heightmap,isoline,contour)\nstruct DAm0{w01 x;};            //for 2 domains (heightmap,isoline,contour)\n\n//incude [[Poeter-Duff] [Compositing Digital Images] siggraph 1984];\nstruct v10{v1 a;v0 b;};//currently only for alpha compositing plans\nstruct v20{v2 a;v0 b;};//...for MAT arithmetic\nstruct v30{v3 a;v0 b;};\nv10 su(v10 a,v10 b){return v10(a.a-b.a,a.b-b.b);}\nv10 mu(v10 a,v10 b){return v10(a.a*b.a,a.b*b.b);}\nv10 mu(v10 a, v0 b){return v10(a.a*b,a.b*b);}\nv20 su(v20 a,v20 b){return v20(a.a-b.a,a.b-b.b);}\nv20 mu(v20 a,v20 b){return v20(a.a*b.a,a.b*b.b);}\nv20 mu(v20 a, v0 b){return v20(a.a*b,a.b*b);}\nv30 su(v30 a,v30 b){return v30(a.a-b.a,a.b-b.b);}\nv30 mu(v30 a,v30 b){return v30(a.a*b.a,a.b*b.b);}\nv30 mu(v30 a, v0 b){return v30(a.a*b,a.b*b);}\n\n//induced alphaCompositingFunctions, named after PorterDuff\n//this is boolean/fuzzy logic, BUT .w is a scalar (actually .w and .a should be swapped, to make this work over nDomains)\n//0==invisible:  .w domain[0..1]:domain[transparent:visible]  \n//https://en.wikipedia.org/wiki/Alpha_compositing\n//https://doc.qt.io/archives/qq/qq17-compositionmodes.html\n//iff(you want to keep an alpha channel after a composition\n//){ you must preMultiplay all inputs; a.xyz*=a.w ; b.xyz*=b.w; a=pdOver(a,b)\n//;}else{in some other contexts, *=.w can be skipped;}\n//.x inputs (ant interpolants) should be sat()ed,or you likely get [color inverted hazes]\n//,[possible error to test against:] this version is still not haze-free (as of 2019-02)?\n//this function collection ommits some trivial cases:\n//- ommits 2 functions, that simply return a or b\n//- ommits the variant that returns 0 and a&b-inoput-swapped functions to half function/count\n\n/*\nvec4 ut(vec4 a,vec1 b){return a*(1.-b);}v41 ut(v41 a,vec1 b){return mu(a,(1.-b));}\nvec3 ut(vec3 a,vec1 b){return a*(1.-b);}v31 ut(v31 a,vec1 b){return mu(a,(1.-b));}\nvec2 ut(vec2 a,vec1 b){return a*(1.-b);}v21 ut(v21 a,vec1 b){return mu(a,(1.-b));}\nvec1 ut(vec1 a,vec1 b){return a*(1.-b);}v11 ut(v11 a,vec1 b){return mu(a,(1.-b));}//#define ut(a,b) (a*(1.-b))\n#define Over 0.\n#define Atop 1.\n#define Out 2.\n#define Xor 3.\n#define In 4.\n//note; colors atop of identical color is a too easy debugging culpit.\n//note,that atop may returns the alpha of a,and not the alpha max(a,b)\nvec4 pdOut(vec4 a,vec4 b){return ut(b,a.w);}\nvec4 pdOver(vec4 a,vec4 b){return ut(b,a.w)+a;}\nvec4 pdAtop(vec4 a,vec4 b){return ut(b,a.w)+a*b.w;}\nvec4 pdXor(vec4 a,vec4 b){return ut(b,a.w)+ut(a,b.w);}\nvec4 pdIn(vec4 a,vec4 b){return a*b.w;}//pdIn() is just multiplication,note swapped AB case here\n//#define pd5(z)z pdOut(z a,z b){return ut(b,a.b);}z pdOver(z a,z b){return ad(ut(b,a.b),a);}z pdAtop(z a,z b){return ad(ut(b,a.b),mu(a,b.b));}z pdXor(z a,z b){return ad(ut(b,a.b),ut(a,b.b));}\n//pd5(v11)pd5(v21)pd5(v31)pd5(v41)//if you want alpha seperated in a struct\n//making tweening/unifying functionms of alpha compositing is silly fun. c is best range [0..1]\n//this reduces it to 5. within pd() unifying function,because 4/5 include ut(a,b),i segregate 1/5_pdIn()\n#define pdOverAtop(a,b,c) a*mix(b,1.,c)\n#define pdOutXor(a,b,c) mix(ut(a,b),vec3(0),c)\nvec3 pf(vec4 a,float c,vec4 b//c sets a mix type of this generalized function\n){if(c>3.)return a.xyz*b.w//pdIn is just multiplication.\n ;vec3 d=vec3(0);d=mix(pdOverAtop(a.xyz,b.w,c),pdOutXor(a.xyz,b.w,c-2.),step(2.,c));return d+ut(b.xyz,a.w) ;}\nvec4 pd(vec4 a,vec2 c,vec4 b){c.x=sat(c.x)//c sets a mix type.makes little sense to bilinn 4 functions on a plane,done anyways\n ;a=mix(a*mix(b.w,1.,c.y),ut(a,b.w)*c.y,c.x)+ut(b,a.w)\n ;return a;}//you likely want to a=sat(a) the c.x input,or have some negative-outlineglow-colors on -1>c>1\n/**/\n\n#define eul 2.7182818284590452353602874713526624977572470936999595749\n#define pi acos(-1.)\n#define tau pi*2.\n#define norma normalize\n\n#define u2(a)((a)*2.-1.) //frame shifts\n#define u5(a)((a)*.5+.5)\n#define u5cos(a) u5(cos(a))\n\nfloat mi(float a,float b){return min(a,b);}\nvec2 mi(vec2 a,vec2 b){return min(a,b);}\n#define   ne(a) -(a)      //negation may be a different operand on different input types (eg complex numbers or chain rule structure)\n#define ma(a,b) ne(mi(ne(a),ne(b)))\n#define cl(a,b,c) mi(ma(a,0.),1.)//explicit clamp for AD\n#define sat(x) cl(x,0.,1.)\n\nv1 cs(v1 a){return v1(cos(a.x),sin(a.y));}\nv1 cs(v0 a){return cs(v1(a));}\n//convention: if it has a period in an infinite context, it is an instrument\n//instruments are usually concerned with polar coordinates\n#define insCos(t,p) cos((t)*acos(-1.)*p)\n\n\n//convention; if its return range is [0..1] 0r [-1..1] or [0..2], it is is an envelope\n//envelopes usually amplify instruments\n//envelopes are bounds of sets in terms of 2nd order logic\n#define envOexp(t) exp(-(t))\n#define envIlin(t,s) min(s,1.)\n\n//convention: an instrument, bound in a context, is a construct(ion)\n//that is, within a frame, we usually have a period, but outside of it we have no significant period\n\n//convention: a melody is a fract()ured instrument, with [time] multiplied with a small value [nancarrow]\n\n\n\n\n\n//core demoed function:\n//core demoed function:\n\n\n\n//below segment aims to unify mod() and [%], and while doing that, uncovers all the involved discrepancies:\n//- to get a unifying mo() function that runs on opengl1 and that takes type float as well as type int(float), and returns the same float\n//- you may expect that mod(a,b)/b== float(int(a)%int(b))/b ; they overlap nicely, except for [negative inputs(a,b)] or [for b close to 0]\n//the [b close to 0] is expected, as we [divide in b] to fit it into our view.\n//less expected is that the divergence can be accounted for, and then they overlap nicely for all [a>0,b>0]\n//- or      compare [(mod(a,b)-.5)/b] with [float(int(a)%int(b)   )/b] //this ends ip being a bad choice   #define   plusOffset\n//- instead compare [ mod(a,b)    /b] with [float(int(a)%int(b)+.5)/b] //this ends up being a good choice  #undefine plusOffset\n//so, this is a mess. lets go on to fix 2 more issues with a 3rd function, we must add 1 thing:\n//- negative inputs behaving better (best continue pattern of positive inputs, no mirroring!)\n\n//mo() includes a pseudo-integer modulo [%] , that runs fine in opengl_es100, and uses the same mo() namespace for pseudo-float modulo()\n//it is pseudo() as in\n//- for positive inputs, behaves identical to [mod(a,b)/b] or [float(int(a)%int(b)+.5)/b]\n//- for negative inputs, behaves better (continues the period into negative space)\n//- is optionally well defined for b=0\n//- is unaffected for cases where you scale [a] and [b] by a [quadraticField] like; a*=[phi=1.61] b*=[phi=1.61]\n//--that is, it behaves differently when irrational numbers scale it; it remains a constant period over x, regardness of any irrational scaling!\n//--compare that with a less predictable yellow line, that fractures by phi-scalings\n//b is a period\n//mod(a,b)-.5=a%b=a-floor(b/a)*a is explicit type independent modulo in interval [b] (div before mult!)\n//we define an array of functions to be less type dependent and more aware of asymptotes\nv0 di(v0 a,v0 b){if(b==0.)return 0.;return a/b;}//type float of type independent worksave division\ni0 di(i0 a,i0 b){if(b==0 )return 0 ;return a/b;}//type int   of type independent worksave division\nv0 fl(v0 a     ){return floor(a)               ;}//type float of type independent floor()\ni0 fl(i0 a     ){return       a                ;}//type int   of type independent floor() (tautological namespace)\n#define fmad(a,b,c) ((a)*(b)+(c))         //a lot of hardware is optimized for fmad()\n#define emod(a,b,c) fmad(ne(a),b,c)       //emod() is fmad() with negated [a]\n#define   mo(a,b)  (emod(fl(di(a,b)),b,a))//mo(a,b)=(a)-(fl((a)/(b))*(b)) //div before mult! fl() is only relevant for type float\n//thats it, use mo(a,b) instead of mod(a,b), and compare them\n//then replace mo(a,b) [a and b] with integers, and compare it with float(a%b)\n//we do all that in the code below, spoiler, there is a +.5 offset involved:\n\n\n\n\n\n//modifiable modes:\n//modifiable modes:\n\n\n#define plusOffset \n//plusOffset is a bad idea , is a bad offset          , approaches/evades an asymptote poorly with a bad identity crysis\n#undef  plusOffset \n//no plusoofset is a good idea , is a more intuitive offset, faces an asymptote with consistency\n\n//#define ScalebyGolden \n//lets really mess up shit by scaling shit by golden ratios.\n\n#define pretentVersion 300 //set what opengl version we want to try [100,300], will become pretentVersion=min(pretentVersion,__VERSION__)\n//needed to compare with [%] which only exists if __VERSION__>=300\n#if (__VERSION__<pretentVersion)//compileTime min(), modify pretentVersion, __VERSION__ is readOnly\n #undef pretentVersion\n #define pretentVersion __VERSION__\n#endif\n//to run code parts, designed to run in opengl1, while still running in opengl2\n//to chose to run opengl1 or opengl1 code parts\n\n\n\n\n\n\n\n#define turm v0 t,v1 u,v2 r,v3 m\n//moWebgl2test() tests mo()=[mod(a,b),floor(a%b+.5)] for [a>0,b>0] is opengl __VERSION__ independent (and float()-typecasting (type independent))\n//modulo with negative inputs must always be tested, most assertions are false assumptions here.\n//this section shows how pathethic  [a%b] performs for [a<0 || b<0] (left screen half, iMouse.x in left screen half)\n//this sectioncan demo how pathethic mod(a,b) erforms for [a==b==63.]\n#if (pretentVersion<300)\nv3 moWebgl2test(turm\n){//we run on Webgl1, the older version of webgl, that likely runs on most modern smartphones\n ;v0 a=63.    //do [a%b, mod(a,m)]\n ;a=u.x-r.x/2.//2d screenspace shows more than 1 [a] in 1 view, screenSpaceCenter sets a=0\n ;v0 b=3.    //period\n ;b=m.x-r.x/2.//mouse.x sets period, screenSpaceCenter==0\n #ifdef ScalebyGolden\n ;a*=sqrt(5.)*.5+.5//plusOffset means we can scale by Phi, and only the blue line is least affected\n ;b*=sqrt(5.)*.5+.5//plusOffset means we can scale by Phi, and only the blue line is least affected\n //;b*=sqrt(5.)*.5-.5//we can scale by Phi, but not by phi, phi is a terrible idea here, unless we also define plusOffset\n //;a*=sqrt(5.)*.5-.5//we can scale by Phi, but not by phi, phi is a terrible idea here, unless we also define plusOffset\n #endif\n ;//remove above line and be amazed how [mo(63.,63.) != mod(63.,63.) ] , even for b>0.\n ;//b=0.;asymptotic div0 test , uncommenting this line may cause a [compileTime parserError]:[div0 syntax error]\n #ifdef plusOffset\n ;v0 w=(mod(a,b)              )/b //pink   lines are shit,known to fail for mod(63.,63.),because people are idiots.\n ;v0 o=(v0( mo(  a,    b ))   )/b //purple lines are good\n ;v0 n=(v0(mo(i0(a),i0(b)))+.5)/b //yellow lines are good (except for the +.5 offset) and for negative values, well lets just do the [else]:\n #else\n //the -.5 offset is possibly a better choice in the long run?\n ;v0 w=(mod(a,b)           -.5)/b //pink   lines are shit\n ;v0 o=(v0(mo(   a,    b ))-.5)/b //purple lines are good\n ;v0 n=(v0(mo(i0(a),i0(b)))   )/b //yellow lines are good (well its the pointSymmetric mopdulo), offset a bit in negative a, accounting for [[year 0]]\n #endif \n ;u=fra(u)\n ;vec4 s=vec4(dd((u.xy-cs(t))),w,o,n) // (dd((u.xy)) draws 1 circle to indicate opengl1\n ;s.x=sqrt(s.x)-.1\n ;s-=vec4(.2,u.yyy)\n ;v0 aA=1./(Aa)\n ;s=-(abs(s)-aA)//optional draw as lines\n ;s=step(-aA,s)\n ;//s=smoothstep(-aA,aA,s)//alternative smoothstep border.y\n ;s.xy+=s.w;s.xy*=.5\n ;s=s.yxzw\n ;return vec4(s.xyz,1);}\n#else\nv3 moWebgl2test(turm\n){//we run on Webgl2, the newer version of webgl, that may not be supported in hardware/settings\n ;v0 a=63.    //do [a%b, mod(a,m)]\n ;a=u.x-r.x/2.//2d screenspace shows more than 1 [a] in 1 view, screenSpaceCenter sets a=0\n ;v0 b=3.    //period\n ;b=m.x-r.x/2.//mouse.x sets period, screenSpaceCenter==0\n #ifdef ScalebyGolden\n ;a*=sqrt(5.)*.5+.5//plusOffset means we can scale by Phi, and only the blue/green lines are least affected\n ;b*=sqrt(5.)*.5+.5//plusOffset means we can scale by Phi, and only the blue/green lines are least affected\n //;b*=sqrt(5.)*.5-.5//we can scale by phi, only useful while we have NOT defined plusOffset\n //;a*=sqrt(5.)*.5-.5//we can scale by phi, only useful while we have NOT defined plusOffset\n #endif\n ;//b=0.;asymptotic div0 test , uncommenting this line may cause a [compileTime parserError]:[div0 syntax error]\n #ifdef plusOffset\n ;v0 w=mod(a,b)            /b //pink   lines are shit  ,known to fail for mod(63.,63.),because people are idiots.\n ;v0 o=v0((mo(a,b)))       /b //purple lines are good\n ;v0 n=(v0(i0(a)%i0(b))+.5)/b //yellow lines are shit\n #else\n ;v0 w=(   mod(a,b)    -.5)/b //pink   lines are shit  ,known to fail for mod(63.,63.),because people are idiots.\n ;v0 o=(v0((mo(a,b)))  -.5)/b //purple lines are good\n ;v0 n=(v0(i0(a)%i0(b))   )/b //yellow lines are shit\n #endif\n ;//n=((a)%(b))... haves so badly, you just should NEVER use it\n ;//- fails for negative inputs\n ;//- openGl_es300=webgl2 only, may be faster, but is likely nor worth because worst of all:\n ;//- shows a FATAL compiler error for [b==int(0.)] [compileTime parserError]:[div0 syntax error]\n ;//since we divide [w,o,n] with 0, we expect an asymptote for small b\n ;//- while this is interestring, lets not get too confused by it\n ;//n and w overlap nicely, except for negative inputs\n ;//o and w overlap nicely, for all cases\n ;//n and o overlap nicely, \n ;u=fra(u)\n ;vec4 s=vec4(dd(abs(u.xy-cs(t))-.5),w,o,n) // (dd(abs(u.xy)-.5) draws 4 circles to indicate opengl2\n ;s.x=sqrt(s.x)-.1\n ;s-=vec4(.2,u.yyy)\n ;v0 aA=1./(Aa)\n ;s=-(abs(s)-aA)//optional draw as lines\n ;s=step(-aA,s)\n ;s=s.yxzw\n ;//s=smoothstep(-aA,aA,s)//alternative smoothstep border.y\n ;s.xy+=s.w;s.xy*=.5\n ;return vec4(s.xyz,1);}\n#endif\n\nv3 mouseTest(turm\n){u=fra(u)\n ;m.xy=fra(m.xy)\n ;m.zw=fra(m.zw)\n ;m-=u.xyxy\n ;v2 s=sqrt(v2(dd(m.xy),dd(m.zw),dd(u-cs(t*.1))))\n ;v0 aA=1./(Aa)\n ;s=smoothstep(aA,-aA,s-aA*9.)\n ;s*=mat3(1,1,0,1,0,1,0,1,1)*.5//color.rgb <= NonNormalized.cmy\n ;return v3(s,1)\n ;}\n\nv1 aud(v0 t\n){v0 a=insCos(t,880.-10.*cos(exp(t))*t)//cosine with dynamically oscillating wavelength over time. \n ;a*=min(t*9.,1.)//fadein envelope\n ;a*=envOexp(t)\n ;return v1(a)//audio is always at least stereo\n ;}\n\n//v3 aud(v0 t,v1 u,v2 r,v3 m){return v3(0);}\n\nv1 Port(v0 t){return aud(t);}\nv3 Port(v0 t,v1 u,v2 r,v3 m//r.z was intended for projectionMapping\n){//v3 o=mouseTest(t,u,r,m)\n ;//v3 a=aud(t,u,r,m)\n ;//o+=a.x\n ;v3 o=moWebgl2test(t,u,r,m)\n ;o+=mouseTest(t,u,r,m)\n ;return o;}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}