{
    "Shader": {
        "info": {
            "date": "1616160336",
            "description": "An extruded octagon diamond grid-based blobby Truchet pattern.",
            "flags": 0,
            "hasliked": 0,
            "id": "3tGBWV",
            "likes": 42,
            "name": "Extruded Octagon Diamond Truchet",
            "published": 3,
            "tags": [
                "blob",
                "diamond",
                "truchet",
                "pattern",
                "extrude",
                "octagon"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 780
        },
        "renderpass": [
            {
                "code": "/*\n\n    Extruded Octagon Diamond Truchet\n    --------------------------------\n    \n    This is an extruded octagon diamond blobby Truchet that features all tile\n    combinations. The template itself has been repurposed from my recent extruded\n    Truchet example.\n    \n    The Truchet pattern was coded up pretty quickly, so there'd be more efficient \n    ways to go about it, like encoding the 2D field into a texture and reading from \n    that, but this was easier. :) \n    \n    Other versions of the octagon diamond Truchet have already been posted, so \n    the blobby version is here mainly to complete the set. I like the pattern \n    because it has a weird sea creature feel to it. It'd be cool to see other dual \n    multitile blobby Truchet patterns, if anyone feels up to it.\n    \n\n\n    References:\n    \n    // Fizzer put together a Truchet pattern based on an octagonal diamond grid a\n    // while back. The Truchet here is a different kind (blobs instead of arcs), but \n    // is essentially based on the same premise.\n    4.8^2 Truchet - Fizzer\n    https://www.shadertoy.com/view/MlyBRG\n    \n    // An extruded ocatagon diamond blobby Truchet pattern using 2D techniques.\n\tFaux Layered Extrusion - Shane\n    https://www.shadertoy.com/view/Wsc3Ds\n\n\n*/\n\n\n// Subtle textured lines.\n#define LINES\n\n// Split the individual tile blocks at the borders.\n//#define SPLIT_TILES\n\n// Show the tile background.\n//#define SHOW_TILES\n\n// Bevel the extruded pattern.\n#define BEVEL\n\n\n// Object ID: Either the back plane or the metaballs.\nint objID;\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n\n// The ocatagonal-dimond grid boundaries.\nvec4 gridField(vec2 q){\n    \n    // Offsetting the diamond tiles by half a unit. \n    vec2 p = q - .5;\n    vec2 ip = floor(p) + .5;\n    p -= ip;\n\n    \n    const float sqrt2 = sqrt(2.);\n    \n    // Side length. Due to the symmetry, it's the side length of both the\n    // octagon and diamond.\n    float s = 1./(1. + sqrt2);\n    \n    // 2D diamond field... The dimensions are calculated using basic trigonometry. \n    // Although, I was still too lazy to do it myself.\n    float dia = (abs(p.x) + abs(p.y))/sqrt2 - s/2.;\n    \n    float d = 1e5;\n    \n    // If we're inside a diamond, then render the diamond tile. Anything outside of this\n    // will obviously be inside an octagon tile.\n    if(dia<.0){\n        \n        d = dia;\n        \n        ip += .5;\n        \n    }\n    else {\n        \n        // If we're inside an octagon cell (outside a diamond), then obtain the \n        // ID (similar to the diaomond ID, but offset by half a cell) and \n        // fractional coordinates.\n        p = q;\n        ip = floor(p) + .5;\n        p -= ip; // Equivalent to: fract(p) - .5;\n        \n        \n        \n        float oct = max((abs(p.x) + abs(p.y))/sqrt(2.), max(abs(p.x), abs(p.y))) - .5;\n        d = oct;\n    } \n    \n    return vec4(d, ip, dia);\n    \n}\n \n\n// Adx's considerably more concise version of Fizzer's circle solver.\n// On a side note, if you haven't seen it before, his \"Quake / Introduction\" \n// shader is well worth the look: https://www.shadertoy.com/view/lsKfWd\nvoid solveCircle(vec2 a, vec2 b, out vec2 o, out float r){\n    \n    vec2 m = a + b;\n    o = dot(a, a)/dot(m, a)*m;\n    r = length(o - a);\n    \n}\n\n\n// Truchet distance formula. It's set to circles, but you could try\n// the octagonal distance metric, if you wanted.\nfloat distT(vec2 p){\n    \n    return length(p);\n    \n    /*\n    // Straight and curved.\n    p = abs(p);\n    return max(length(p) - .04, max((p.x + p.y)*.7071, max(p.x, p.y)));\n    */\n    \n    /*\n    // 16 sided, for that straight edged look.\n    p = abs(p);\n    float d = max(max(p.x, p.y), (p.x + p.y)*.7071);\n    p *= rot2(3.14159/8.);\n    return max(d, max(max(p.x, p.y), (p.x + p.y)*.7071));\n    */\n\n}\n\n\n// A blobby octagonal diamond structure. Test to see whether the pixel is inside\n// a diamond tile or an octagonal tile, then render the appropriate tile.\n// A diamond tile will have two circles cut out at opposite ends, and an octagon\n// will have various circles cut out at the correct positions. It's all pretty simple.\n// However blobby Truchet tiles on square-based grids need to have their distances\n// flipped on alternating checkered tiles. It slightly complicates the code, but\n// I'm sure it's nothing that people can't handle. :)\n//\n// Uncomment the \"SHOW_GRID\" define and refer to imagery get a better idea.\nvec3 distFieldT(vec2 q){\n    \n    \n    float d = 1e5;\n    \n    // Offsetting the diamond tiles by half a unit.\n    vec2 p = q - .5;\n    \n    // Tile ID and local coordinates.\n    vec2 ip = floor(p) + .5;\n    p -= ip;\n    \n    \n    const float sqrt2 = sqrt(2.);\n    \n    // Side length. Due to the symmetry, it's the side length of both the\n    // octagon and diamond.\n    float s = 1./(1. + sqrt2);\n    \n    // 2D diamond field... The dimensions are calculated using basic trigonometry. \n    // Although, I was still too lazy to do it myself.\n    float dia = (abs(p.x) + abs(p.y))/sqrt2 - s/2.;\n    \n   \n    \n    \n    float shape = 1e5;\n    \n    // If we're inside a diamond, then render the diamond tile. Anything outside of this\n    // will obviously be inside an octagon tile. In case it isn't obvious, you could test\n    // for an octagonal hit too, but a diamond is easier.\n    if(dia<.0){\n        \n        \n        // Rotate random tiles.\n        float rnd = hash21(ip);\n        if(rnd<.5) p = rot2(3.14159/2.)*p;\n        \n        // Chop out two circles on opposite corners. Use the define to display\n        // the grid and refer to the imagery.\n        p.y = abs(p.y);\n        d = min(d, distT(p - vec2(0, s/sqrt2)) - s/2.);\n        \n        // Flip the distances on alternating checkered tiles.\n        float ch = mod(ip.x + ip.y, 2.);\n        if(ch<.5) d = -d;\n        \n        // Flip the distances on random tiles as well.\n        if(rnd<.5) d = -d;\n        \n        // Moving the tile ID away from the center of the octagonal tile\n        // to the center of the diamond tile.\n        ip += .5;\n        \n        shape = dia;\n        \n    }\n    else {\n    \n       \n        \n        // If we're inside an octagon cell (outside a diamond), then obtain the \n        // ID (similar to the diaomond ID, but offset by half a cell) and \n        // fractional coordinates.\n        p = q;\n        vec2 ip = floor(p) + .5;\n        p -= ip; // Equivalent to: fract(p) - .5;\n        \n        shape = max((abs(p.x) + abs(p.y))/sqrt2, max(abs(p.x), abs(p.y))) - .5;\n        \n        // Rotate random tiles. You don't really the extra addition, but I \n        // figured it might mix things up more... maybe. :)\n        float rnd = hash21(ip + vec2(.11, .41));\n        float rnd2 = hash21(ip + vec2(.17, .31));\n        \n        if(rnd<.5) p = rot2(3.14159/4.)*p;\n        \n        if(rnd2<.333){\n            // Chop out four circles on opposite corners. Use the define to display\n            // the grid and refer to the imagery. \n        \n            // Four small circles.\n            d = min(d, distT(p - vec2(-.5, s/2.)) - s/2.);\n            d = min(d, distT(p - vec2(s/2., .5)) - s/2.);\n            d = min(d, distT(p - vec2(.5, -s/2.)) - s/2.);\n            d = min(d, distT(p - vec2(-s/2., -.5)) - s/2.);\n        }\n        else if(rnd2<.666){\n            \n            // Two large arcs with two small circle cutouts.\n            \n            // Random rotation.\n            float rnd3 = hash21(ip + vec2(.27, .53));\n            p = rot2(3.14159/2.*floor(rnd3*64.))*p;\n            \n            \n            vec2 o; float r;\n            solveCircle(vec2(-.5, 0), vec2(sqrt2/4.), o, r); \n            // Top left;\n            d = min(d, distT(p - o) - r);\n            d = max(d, -(distT(p - vec2(-s/2., .5)) - s/2.));\n            \n            // Bottom right.\n            d = min(d, distT(p + o) - r);\n            d = max(d, -(distT(p - vec2(s/2., -.5)) - s/2.));\n            \n            \n        \n        }\n        else {\n        \n            // One large arc with three small circle cutouts.\n        \n            // Random rotation.\n            float rnd4 = hash21(ip + vec2(.34, .67));\n            p = rot2(3.14159/2.*floor(rnd4*64.))*p;\n            \n            vec2 o; float r;\n            solveCircle(vec2(-.5, 0), vec2(sqrt2/4.), o, r); \n            // Top left;\n            d = min(d, distT(p - o) - r);\n            d = max(d, -(distT(p - vec2(-s/2., .5)) - s/2.));\n            \n            \n            d = min(d, distT(p - vec2(.5, -s/2.)) - s/2.);\n            d = min(d, distT(p - vec2(-s/2., -.5)) - s/2.);\n            \n            \n        \n        }\n        \n        // Tile flipping: As an aside, I've never been able to logically \n        // combine the two following lines, but surely there's a way?\n        // Probably a question for Fabrice Neyret to answer. :)\n        \n        // Flip the distances on alternating checkered tiles.\n        if(mod(ip.x + ip.y, 2.)>.5)  d = -d;\n        \n        \n        // Flip the distances on random tiles as well.\n        if(rnd<.5) d = -d;\n       \n    }\n    \n    \n    #ifdef SPLIT_TILES\n    d = max(d - .03, -(abs(shape) - .01)) + .03;\n    #else\n    #ifdef SHOW_TILES\n    d = max(d, -(abs(shape) - .01));\n    #endif\n    #endif\n    \n    d -= .03; // Extra width.\n     \n    \n    \n    \n    //d = min(d + .05, abs(d + .02) - .05); // Truchet border.\n    \n    //d = mix(max(d - .03, -(abs(shape) - .01)), d - .03, smoothstep(-.1, .1, sin(iTime)));\n    \n    // Return the distance and center tile ID.\n    return vec3(d, ip);\n    \n}\n\n// Local stud position. Bad global hack, but it was a\n// last minute addition. :)\nvec2 stdP;\n \n// Distance function.\nfloat m(vec3 p){\n    \n    // Back plane.\n    float fl = -p.z;\n    \n    // Octagon diamond Truchet object.\n    vec3 o3 = distFieldT(p.xy);\n    // Extruding the 2D field above.\n    float obj = max(o3.x, abs(p.z) - .125);\n    #ifdef BEVEL\n    obj -= smoothstep(.03, .1, -o3.x)*.05;// + obj*.5;\n    #endif\n    \n    // The cylindrical beacon like objects. I added them in out of sheer\n    // bordom. I guess they're anaolgous to eyes, or something. :)\n    float sc = 1.;\n    vec2 q = p.xy;\n    vec2 iq = floor(q/sc) + .5;\n    q -= iq*sc;\n    \n    // Placing cylinders on alternate octagon vertices.\n    const float s = 1./(1. + sqrt(2.));\n    vec2 ep = vec2(s/2., .5);\n    // Rotating alternate checkered octagons to align things.\n    if(mod(iq.x + iq.y, 2.)<.5) q = rot2(3.14159/4.)*q;\n    // Polar repetition.\n    float a = atan(q.x, q.y);    \n    a = (floor(a/6.2831*4.) + .5)/4.*6.2831;\n    ep = rot2(a)*ep;\n    stdP = q - ep; // Centered local beacon coordinates.\n    float cyl = length(stdP) - .06*sc;\n    \n    // The cylindrical beacon.\n    float beacon = max(cyl, abs(p.z) - .25);\n       \n\n     \n    // Object ID.\n    objID = fl<obj && fl<beacon? 0 : obj<beacon? 1 : 2;\n    \n    // )verall minimum distance.\n    return min(min(fl, obj), beacon);\n    \n}\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int iter = 16; \n    \n    ro += n*.0015; // Bumping the shadow off the hit point.\n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n    \n    //rd = normalize(rd + (hash33R(ro + n) - .5)*.03);\n    \n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<iter; i++){\n\n        float d = m(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 2., occ = 0.;\n    for( int i = min(iFrame, 0); i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = m(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        \n        // Deliberately redundant line that may or may not stop the \n        // compiler from unrolling.\n        if(sca>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);\n}\n  \n\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 nr(in vec3 p) {\n\t\n    const vec2 e = vec2(.001, 0);\n    \n    //return normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\t\n    //                      m(p + e.yyx) - m(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp[i] = m(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n\n\nvoid mainImage(out vec4 c, vec2 u){\n\n    \n    // Aspect correct coordinates. Only one line necessary.\n    u = (u - iResolution.xy*.5)/iResolution.y;\n    \n    // Unit direction vector, camera origin and light position.\n    vec3 r = normalize(vec3(u, 1)), o = vec3(0, iTime/2., -3), l = o + vec3(.25, .25, 2);\n    \n    // Rotating the camera about the XY plane, etc.\n    r.yz = rot2(.15)*r.yz;\n    r.xz = rot2(-cos(iTime*3.14159/32.)/8.)*r.xz;\n    r.xy = rot2(sin(iTime*3.14159/32.)/8.)*r.xy;\n    \n \n  \n    \n    // Standard raymarching setup.\n    float d, t = hash21(r.xy*57. + fract(iTime))*.5, glow = 0.;\n    // Raymarch.\n    for(int i=0; i<96; i++){ \n        \n        d = m(o + r*t); // Surface distance.\n        if(abs(d)<.001) break; // Surface hit.\n        t += d*.9; // Advance the overall distance closer to the surface.\n        \n        //float rnd = hash21(r.xy + float(i)/113. + fract(iTime)) - .5;\n        glow += .2/(1. + abs(d)*5.);// + rnd*.2;\n        \n         \n    }\n    \n    // Object ID: Back plane (0), or the metaballs (1).\n    int gObjID = objID;\n    \n    // Saving the local beacon coordinates.\n    vec2 lStdP = stdP;\n    \n    \n    // Very basic lighting.\n    // Hit point and normal.\n    vec3 p = o + r*t, n = nr(p); \n    \n    \n    // UV texture coordinate holder.\n    vec2 uv = p.xy;\n    // Cell ID and local cell coordinates for the texture we'll generate.\n    float sc = .5; // Scale: .5 to about .2 seems to look OK.\n    vec2 iuv = floor(uv/sc) + .5; // Cell ID.\n    uv -= iuv*sc; // Local cell coordinates.\n  \n     \n    // Smooth borders.\n    vec4 b2 = gridField(p.xy*5. + vec2(.5, 0));\n    float bord = abs(b2.x/5.) - .003;\n \n\n    // Subtle lines for a bit of texture.\n    #ifdef LINES\n    float lSc = 20.;\n    float pat = (abs(fract((uv.x - uv.y)*lSc - .5) - .5)*2. - .5)/lSc;\n    float pat2 = (abs(fract((uv.x + uv.y)*lSc + .5) - .5)*2. - .5)/lSc;\n    #else\n    float pat = 1e5, pat2 = 1e5;\n    #endif  \n\n    \n    // Colors for the floor and extruded face layer. Each were made up and \n    // involve subtle gradients, just to mix things up.\n    float sf = dot(sin(p.xy - cos(p.yx*2.)), vec2(.5));\n    float sf2 = dot(sin(p.xy*1.5 - cos(p.yx*3.)), vec2(.5));\n    vec4 col1 = mix(vec4(1., .75, .6, 0), vec4(1, .85, .65, 0), smoothstep(-.5, .5, sf));\n    vec4 col2 = mix(vec4(.4, .7, 1, 0), vec4(.3, .85, .95, 0), smoothstep(-.5, .5, sf2)*.5);\n    col1 = pow(col1, vec4(1.6));\n    col2 = mix(col1.zyxw, pow(col2, vec4(1.4)), .666);   \n    col1 = mix(col1, col1.xzyw*col1, smoothstep(.25, .75, sf2)*.5);\n    //col1 = mix(col1, col1.yxzw, smoothstep(.4, .8, sf3)*.5); \n\n\n    // Object color.\n    vec4 oCol;\n    \n    \n    // Use whatever logic to color the individual scene components. I made it\n    // all up as I went along, but things like edges, textured line patterns,\n    // etc, seem to look OK.\n    //\n    if(gObjID == 0){\n    \n        // Blue background:\n\n        // Blue with some subtle lines.\n        oCol = mix(col2, vec4(0), (1. - smoothstep(0., .01, pat2))*.35);\n        // Square borders: Omit the middle of edges where the Truchet passes through.\n        oCol = mix(oCol, vec4(0), (1. - smoothstep(0., .01, bord))*.8);\n\n        // Darken alternate checkers. \n        if(mod((b2.y) + (b2.z), 2.)<.5 && b2.w>0.) oCol *= .8;\n\n        // Using the Truchet pattern for some bottom edging.\n        float edge = distFieldT(p.xy).x;\n        oCol = mix(oCol, vec4(0), (1. - smoothstep(0., .01, edge - .015))*.8);\n       \n        #ifdef SHOW_TILES\n        // Display the background grid pattern.\n        b2 = gridField(p.xy);\n        float bord2 = abs(b2.x) - .002;\n        oCol = mix(oCol, vec4(0), (1. - smoothstep(0., .01, bord2 - .02)));\n        oCol = mix(oCol, mix(col1*.5 + .5, col2, .5), (1. - smoothstep(0., .01, bord2)));\n        #endif\n        \n\n  \n    }\n    else if(gObjID == 1){\n       \n        // 2D Truchet pattern.\n        d = distFieldT(p.xy).x;\n    \n\n        // Light sides with a dark edge. \n        oCol = mix(col1*.5 + .5, col2, .5);\n        oCol = mix(oCol, vec4(0), 1. - smoothstep(0., .01, d + .03));\n        \n        // Colored gradient with subtle line pattern,\n        vec4 fCol = mix(col1, vec4(0), (1. - smoothstep(0., .01, pat))*.35);\n        // Borders: Omit the middle of edges where the Truchet passes through.\n        fCol = mix(fCol, vec4(0), (1. - smoothstep(0., .01, bord))*.8);\n        \n        // Darken alternate checkers. \n        if(mod((b2.y) + (b2.z), 2.)<.5 && b2.w>0.) fCol *= .8;\n        \n        // Apply the gradient face to the Truchet, but leave enough room\n        // for an edge.\n        oCol = mix(oCol, fCol, 1. - smoothstep(0., .01, d + .05));\n        \n        // If the cylindrical markers are included, render dark rings just under them.\n        float beacons = length(lStdP) - .14*sc;\n        oCol = mix(oCol, vec4(0), (1. - smoothstep(0., .01, beacons)));\n        \n    }\n    else {\n    \n        // The cylinder markers:\n        \n        // Color and apply patterns, edges, etc.\n\n        float beacons = length(lStdP);\n        oCol = mix(col1*.5 + .5, col2, .5);\n        \n        oCol = mix(oCol, vec4(0), (1. - smoothstep(0., .01, abs(beacons - .103*sc) - .0035)));\n        oCol = mix(oCol, vec4(0), (1. - smoothstep(0., .01, beacons - .03*sc)));\n        \n    \n    }\n\n\n    // Basic point lighting.   \n    vec3 ld = l - p;\n    float lDist = length(ld);\n    ld /= lDist; // Light direction vector.\n    float at = 1./(1. + lDist*lDist*.125); // Attenuation.\n\n    \n    // Very, very cheap shadows -- Not used here.\n    //float sh = min(min(m(p + ld*.08), m(p + ld*.16)), min(m(p + ld*.24), m(p + ld*.32)))/.08*1.5;\n    //sh = clamp(sh, 0., 1.);\n    float sh = softShadow(p, l, n, 8.); // Shadows.\n    float ao = calcAO(p, n); // Ambient occlusion.\n    \n    \n    float df = max(dot(n, ld), 0.); // Diffuse.\n    float sp = pow(max(dot(reflect(r, n), ld), 0.), 32.); // Specular.\n    \n      \n    // Apply the lighting and shading. \n    c = oCol*(df*sh + sp*sh + .5 + glow/16.)*at*ao;\n    // Very metallic: Interesting, but ultimately, a bit much. :)\n    //c = oCol*oCol*1.5*(pow(df, 3.)*2.*sh + sp*sh*2. + .25)*at*ao;    \n      \n \n    // Rough gamma correction.\n    c = sqrt(max(c, 0.));  \n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}