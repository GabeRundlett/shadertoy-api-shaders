{
    "Shader": {
        "info": {
            "date": "1709778083",
            "description": "Example output from LatticeRobot",
            "flags": 0,
            "hasliked": 0,
            "id": "43sXRX",
            "likes": 1,
            "name": "LatticeRobot GLSL Output",
            "published": 3,
            "tags": [
                "sdf",
                "lattice",
                "ugf",
                "latticerobot"
            ],
            "usePreview": 0,
            "username": "bcourter",
            "viewed": 77
        },
        "renderpass": [
            {
                "code": "\n/////////////////////////////////////////////////////////////////////////////////////////////\n//\n// LatticeRobot CodeRep output v0.1\n// This code is example output from LatticeRobot's lattice CodeRep generator.  \n// It is intended for other implicits to use to fill shapes with spatially varying lattices.\n//\n// https://www.latticerobot.com\n//\n// LICENSE: This code is provided under an MIT license.  \n// BETA WARNING: This format will evolve through 2024\n//\n// Documentation:\n// Immediately below, there is a library, followed by the custom code for this parameterized\n// unit cell.  A complier directive replaces the uniforms with internal parameters\n// for the purpose of this Shadertoy demo.\n//\n// Lattice Variants and Index:\n// The latticeIndex uniform accesses the four variants of the lattice F(p), with the shape \n// defined by the preimage of the non-positive values of that variant:\n//\n//   0: Solid. The Solid lattice:\n//       F(p) - bias\n//\n//   1: Inverse. The inverse of the Solid lattice:\n//       -F(p) + bias\n//\n//   2: Thin. A thin band of the Solid lattice:\n//       abs(F(p) - bias) - thickness / 2\n//\n//   3: Twin. The twin axes produced by the inverse of the Thin lattice:\n//       -abs(F(p) - bias) + thickness / 2\n//\n// Common Lattice Parameters (with default value and units):\n//   * size_x, size_y, and size_z (10 mm): The dimensions of the desired bounding box. \n//   * bias (0 mm): The offset of the baseline lattice surface.  Not precise distance.\n//   * thickness (1 mm): Thin and Twin only.  The thickness of the wall of the thin lattice or\n//        the span of the spacing of the twin lattice.  Not precise distance.\n//\n// Special Lattice Parameters (for only this lattice):\n//   * drop_x, drop_y, and drop_z (1): Lattice-specific parameters that attenuate coefficients.\n//   * gyroid (0): interpolates the Diamond TPMS to Gyroid TPMS.  \n//  \n/////////////////////////////////////////////////////////////////////////////////////////////\n\n// Implicit library\n\n#define PI 3.14159265358979\n#define SQRT2 1.41421356237\n#define SQRT3 1.73205080757\n\nstruct Implicit {\n\tfloat Distance;\n\tvec3 Gradient;\n};\n\nImplicit CreateImplicit() { return Implicit(0.0, vec3(0.0)); }\nImplicit CreateImplicit(float iValue) { return Implicit(iValue, vec3(0.0)); }\n\nImplicit Negate(Implicit iImplicit) {\n\treturn Implicit(-iImplicit.Distance, -iImplicit.Gradient);\n}\n\nImplicit Add(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance + b.Distance, a.Gradient + b.Gradient);\n}\nImplicit Subtract(Implicit a, Implicit b)  {\n\treturn Implicit(a.Distance - b.Distance, a.Gradient - b.Gradient);\n}\n\nImplicit Add(float iT, Implicit iImplicit) {\n\treturn Implicit(iT + iImplicit.Distance, iImplicit.Gradient);\n}\nImplicit Add(Implicit iImplicit, float iT) { return Add(iT, iImplicit); }\nImplicit Subtract(float iT, Implicit iImplicit) { return Add(iT, Negate(iImplicit)); }\nImplicit Subtract(Implicit iImplicit, float iT) { return Add(-iT, iImplicit); }\n\nImplicit Multiply(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance * b.Distance, a.Distance * b.Gradient + b.Distance * a.Gradient);\n}\nImplicit Multiply(float iT, Implicit iImplicit) { return Implicit(iT * iImplicit.Distance, iT * iImplicit.Gradient); }\nImplicit Multiply(Implicit iImplicit, float iT) { return Multiply(iT, iImplicit); }\n\nImplicit Divide(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance / b.Distance, (b.Distance * a.Gradient - a.Distance * b.Gradient) / (b.Distance * b.Distance));\n}\nImplicit Divide(Implicit a, float b) { return Implicit(a.Distance / b, a.Gradient / b); }\nImplicit Divide(float a, Implicit b) { return Divide(CreateImplicit(a), b); }\n\nImplicit Min(Implicit a, Implicit b) {\n\tif (a.Distance <= b.Distance)\n\t\treturn a;\n\n\treturn b;\n}\nImplicit Min(Implicit a, float b) { return Min(a, CreateImplicit(b)); }\nImplicit Min(float a, Implicit b) { return Min(CreateImplicit(a), b); }\nImplicit Min(Implicit a, Implicit b, Implicit c) { return Min(a, Min(b, c)); }\nImplicit Min(Implicit a, Implicit b, Implicit c, Implicit d) { return Min(a, Min(b, Min(c, d))); }\n\nImplicit Max(Implicit a, Implicit b) {\n\tif (a.Distance >= b.Distance)\n\t\treturn a;\n\n\treturn b;\n}\nImplicit Max(Implicit a, Implicit b, Implicit c) { return Max(a, Max(b, c)); }\nImplicit Max(Implicit a, float b) { return Max(a, CreateImplicit(b)); }\nImplicit Max(float a, Implicit b) { return Max(CreateImplicit(a), b); }\nImplicit Max(Implicit a, Implicit b, Implicit c, Implicit d) { return Max(a, Max(b, Max(c, d))); }\n\nImplicit Compare(Implicit iA, Implicit iB) {\n    if (iA.Distance < iB.Distance)\n        return CreateImplicit(-1.0);\n\n    if (iA.Distance > iB.Distance)\n        return CreateImplicit(1.0);\n\n    return CreateImplicit(0.0);\n}\nImplicit Compare(Implicit iA, float iB) { return Compare(iA, CreateImplicit(iB)); }\nImplicit Compare(float iB, Implicit iA) { return Compare(iA, CreateImplicit(iB)); }\nImplicit Compare(float iA, float iB) { return CreateImplicit(iA == iB ? 0. : (iA > iB ? 1. : -1.)); }\n\nImplicit Conditional(bool condition, Implicit shape1, Implicit shape2) {\n  if (condition)\n    return shape1;\n\n  return shape2;\n}\n\nImplicit Exp(Implicit iImplicit) {\n\tfloat exp = exp(iImplicit.Distance);\n\treturn Implicit(exp, exp * iImplicit.Gradient);\n}\n\nImplicit Log(Implicit iImplicit) {\n\treturn Implicit(log(iImplicit.Distance), iImplicit.Gradient / iImplicit.Distance);\n}\n\nImplicit Pow(Implicit iMantissa, Implicit iExponent) {\n    float result = pow(iMantissa.Distance, iExponent.Distance);\n\treturn Implicit(result, result * log(iMantissa.Distance) * iMantissa.Gradient);\n}\n\nImplicit Sqrt(Implicit iImplicit) {\n\tfloat sqrt = sqrt(iImplicit.Distance);\n\treturn Implicit(sqrt, iImplicit.Gradient / (2.0 * sqrt));\n}\n\nImplicit Abs(Implicit iImplicit) {\n\treturn Implicit(abs(iImplicit.Distance), sign(iImplicit.Distance) * iImplicit.Gradient);\n}\n\nImplicit Mod(Implicit iImplicit, Implicit iM) {\n\treturn Implicit(mod(iImplicit.Distance, iM.Distance), iImplicit.Gradient);  // TODO fix gradient\n}\nImplicit Mod(Implicit iImplicit, float iM) {\n\treturn Implicit(mod(iImplicit.Distance, iM), iImplicit.Gradient);  // TODO fix gradient\n}\n\nImplicit Sin(Implicit iImplicit) {\n\treturn Implicit(sin(iImplicit.Distance), cos(iImplicit.Distance) * iImplicit.Gradient);\n}\n\nImplicit Cos(Implicit iImplicit) {\n\treturn Implicit(cos(iImplicit.Distance), -sin(iImplicit.Distance) * iImplicit.Gradient);\n}\n\nImplicit Tan(Implicit iImplicit) {\n    float sec = 1. / cos(iImplicit.Distance);\n\treturn Implicit(tan(iImplicit.Distance), sec * sec * iImplicit.Gradient);\n}\n\nImplicit Asin(Implicit iImplicit) {\n\treturn Implicit(asin(iImplicit.Distance), iImplicit.Gradient / sqrt(1.0 - iImplicit.Distance * iImplicit.Distance));\n}\n\nImplicit Acos(Implicit iImplicit) {\n\treturn Implicit(acos(iImplicit.Distance), -iImplicit.Gradient / sqrt(1.0 - iImplicit.Distance * iImplicit.Distance));\n}\n\nImplicit Atan(Implicit iImplicit) {\n\treturn Implicit(atan(iImplicit.Distance), iImplicit.Gradient / (1.0 + iImplicit.Distance * iImplicit.Distance));\n}\n\nImplicit Atan(Implicit a, Implicit b) {  // this version is not correct, but avoids a shading issue.\n    vec3 grad = (b.Distance * a.Gradient - a.Distance * b.Gradient);\n    return Implicit(atan(a.Distance, b.Distance), grad);\n}\n\n// Primitives\n\nImplicit Circle(vec2 p, vec2 center, float iRadius)\n{\n\tvec2 centered = p - center;\n    float len = length(centered);\n\tfloat length = len - iRadius;\n\treturn Implicit(length, vec3(centered / len, 0.0));\n}\n\nmat2 Rotate2D(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(\n        vec2(c, -s),\n        vec2(s, c)\n    );\n}\n\nImplicit RectangleCenterRotated(vec2 p, vec2 center, vec2 size, float angle) {\n\tvec2 centered = p - center;\n    mat2 rot = Rotate2D(-angle);\n    centered = rot * centered;\n\n\tvec2 b = size * 0.5;\n\tvec2 d = abs(centered)-b;\n\tfloat dist = length(max(d, vec2(0.0))) + min(max(d.x, d.y), 0.0);\n\n\tvec2 grad = d.x > d.y ? vec2(1.0, 0.0) : vec2 (0.0, 1.0);\n\tif (d.x > 0. && d.y > 0.)\n\t\tgrad = d / length(d);\n\n\tgrad *= -sign(centered);\n\n\treturn Implicit(dist, vec3(grad * rot, 0.0));\n}\n\nImplicit BoxCenter(vec3 iP, vec3 iCenter, vec3 iSize) {\n\tvec3 p = iP - iCenter;\n\tvec3 b = iSize * 0.5;\n\n\tvec3 d = abs(p)-b;\n\tfloat dist = length(max(d, vec3(0.))) + min(max(d.x, max(d.y, d.z)), 0.);\n\n\tvec3 grad = (d.x > d.y) && (d.x > d.z) ? vec3(1., 0., 0.) :\n\t\t(d.y > d.z ? vec3(0., 1., 0.) : vec3(0., 0., 1.));\n\n\tif (d.x > 0. || d.y > 0. || d.z > 0.)\n\t{\n\t\td = max(d, 0.);\n\t\tgrad = d / length(d);\n\t}\n\n\tgrad *= sign(p);\n\n\treturn Implicit(dist, grad);\n}\n\n// Used by ScaledLattice() \n\nImplicit SphereNative(vec3 iP, vec3 iCenter, float iRadius) {\n\tvec3 centered = iP - iCenter;\n    float length = length(centered);\n\tfloat dist = length - iRadius;\n\treturn Implicit(dist, centered / length);\n}\n\nconst vec3 center = vec3(0.5); \n\n#define STANDALONE 0\nfloat count = 1.00000000;\nfloat size_x = 10.00000000;\nfloat size_y = 10.00000000;\nfloat size_z = 10.00000000;\nfloat bias = 0.00000000;\nfloat thickness = 1.00000000;\nint variantIndex = 2;\n\nvec3 DirX = vec3(1.0, 0.0, 0.0);\nvec3 DirY = vec3(0.0, 1.0, 0.0);\nvec3 DirZ = vec3(0.0, 0.0, 1.0);\n\nfloat Dot(vec3 a, vec3 b) {\n  float _Dot_002 = a.x * b.x + a.y * b.y;\n  return _Dot_002 + a.z * b.z;\n}\n\nImplicit Dot(Implicit a_x, Implicit a_y, Implicit a_z, vec3 b) {\n  Implicit _Dot_000 = Multiply(a_x, b.x);\n  Implicit _Dot_001 = Multiply(a_y, b.y);\n  Implicit _Dot_002 = Add(_Dot_000, _Dot_001);\n  Implicit _Dot_003 = Multiply(a_z, b.z);\n  return Add(_Dot_002, _Dot_003);\n}\n\nImplicit Dot(Implicit a_x, Implicit a_y, Implicit a_z, Implicit b_x, Implicit b_y, Implicit b_z) {\n  Implicit _Dot_000 = Multiply(a_x, b_x);\n  Implicit _Dot_001 = Multiply(a_y, b_y);\n  Implicit _Dot_002 = Add(_Dot_000, _Dot_001);\n  Implicit _Dot_003 = Multiply(a_z, b_z);\n  return Add(_Dot_002, _Dot_003);\n}\n\nfloat Length(vec3 v) {\n  float _Length_000 = Dot(v, v);\n  return sqrt(_Length_000);\n}\n\nImplicit Length(Implicit v_x, Implicit v_y, Implicit v_z) {\n  Implicit _Length_000 = Dot(v_x, v_y, v_z, v_x, v_y, v_z);\n  return Sqrt(_Length_000);\n}\n\nImplicit Clamp(Implicit t, float a, float b) {\n  Implicit _Clamp_000 = Min(t, b);\n  return Max(a, _Clamp_000);\n}\n\nvoid RepeatCentered(Implicit p_x, Implicit p_y, Implicit p_z, vec3 period, out Implicit RepeatCentered_x, out Implicit RepeatCentered_y, out Implicit RepeatCentered_z) {\n  vec3 halfPeriod = period * 0.5;\n  Implicit _RepeatCentered_000_x = Add(p_x, halfPeriod.x);\n  Implicit _RepeatCentered_001_x = Mod(_RepeatCentered_000_x, period.x);\n  Implicit _RepeatCentered_002_x = Subtract(_RepeatCentered_001_x, halfPeriod.x);\n  Implicit _RepeatCentered_000_y = Add(p_y, halfPeriod.y);\n  Implicit _RepeatCentered_001_y = Mod(_RepeatCentered_000_y, period.y);\n  Implicit _RepeatCentered_002_y = Subtract(_RepeatCentered_001_y, halfPeriod.y);\n  Implicit _RepeatCentered_000_z = Add(p_z, halfPeriod.z);\n  Implicit _RepeatCentered_001_z = Mod(_RepeatCentered_000_z, period.z);\n  Implicit _RepeatCentered_002_z = Subtract(_RepeatCentered_001_z, halfPeriod.z);\n  RepeatCentered_x = _RepeatCentered_002_x;\n  RepeatCentered_y = _RepeatCentered_002_y;\n  RepeatCentered_z = _RepeatCentered_002_z;\n}\n\nImplicit IntersectSharp3(Implicit a, Implicit b, Implicit c) {\n  Implicit _IntersectSharp3_000 = Max(a, b);\n  return Max(_IntersectSharp3_000, c);\n}\n\nImplicit Sphere(vec3 p, vec3 center, float radius) {\n  vec3 c = p - center;\n  float len = Length(c);\n  float dist = len - radius;\n  vec3 _Sphere_000 = c / len;\n  return Implicit(dist, _Sphere_000);\n}\n\nImplicit LineSegment(Implicit p_x, Implicit p_y, Implicit p_z, vec3 a, vec3 b) {\n  Implicit pa_x = Subtract(p_x, a.x);\n  Implicit pa_y = Subtract(p_y, a.y);\n  Implicit pa_z = Subtract(p_z, a.z);\n  vec3 ba = b - a;\n  Implicit _h_003 = Dot(pa_x, pa_y, pa_z, ba);\n  float _h_004 = Dot(ba, ba);\n  Implicit _h_005 = Divide(_h_003, _h_004);\n  Implicit h = Clamp(_h_005, 0.0, 1.0);\n  vec3 _LineSegment_002 = ba * h.Distance;\n  Implicit _LineSegment_003_x = Subtract(pa_x, _LineSegment_002.x);\n  Implicit _LineSegment_003_y = Subtract(pa_y, _LineSegment_002.y);\n  Implicit _LineSegment_003_z = Subtract(pa_z, _LineSegment_002.z);\n  return Length(_LineSegment_003_x, _LineSegment_003_y, _LineSegment_003_z);\n}\n\nImplicit LineSegmentRepeatMirror(Implicit p_x, Implicit p_y, Implicit p_z, vec3 a, vec3 b, vec3 size) {\n  Implicit _mod_out_000_x;\n  Implicit _mod_out_000_y;\n  Implicit _mod_out_000_z;\n  RepeatCentered(p_x, p_y, p_z, size, _mod_out_000_x, _mod_out_000_y, _mod_out_000_z);\n  Implicit mod_x = Abs(_mod_out_000_x);\n  Implicit mod_y = Abs(_mod_out_000_y);\n  Implicit mod_z = Abs(_mod_out_000_z);\n  return LineSegment(mod_x, mod_y, mod_z, a, b);\n}\n\nImplicit BoxCenteredSharp(Implicit p_x, Implicit p_y, Implicit p_z, vec3 center, vec3 size) {\n  Implicit _planes_000_x = Subtract(p_x, center.x);\n  Implicit _planes_001_x = Abs(_planes_000_x);\n  vec3 _planes_002 = size * 0.5;\n  Implicit planes_x = Subtract(_planes_001_x, _planes_002.x);\n  Implicit _planes_000_y = Subtract(p_y, center.y);\n  Implicit _planes_001_y = Abs(_planes_000_y);\n  Implicit planes_y = Subtract(_planes_001_y, _planes_002.y);\n  Implicit _planes_000_z = Subtract(p_z, center.z);\n  Implicit _planes_001_z = Abs(_planes_000_z);\n  Implicit planes_z = Subtract(_planes_001_z, _planes_002.z);\n  return IntersectSharp3(planes_x, planes_y, planes_z);\n}\n\nImplicit indexedLattice(vec3 p, int index, out Implicit solid) {\n  vec3 size = vec3(size_x, size_y, size_z);\n  vec3 halfsize = size * 0.5;\n  vec3 _beam0_002 = vec3(0.0, halfsize.y, 0.0);\n  vec3 _beam0_003 = vec3(0.0, 0.0, halfsize.z);\n  Implicit p_x = Implicit(p.x, DirX);\n  Implicit p_y = Implicit(p.y, DirY);\n  Implicit p_z = Implicit(p.z, DirZ);\n  Implicit beam0 = LineSegmentRepeatMirror(p_x, p_y, p_z, _beam0_002, _beam0_003, size);\n  vec3 _beam1_002 = vec3(halfsize.x, 0.0, 0.0);\n  vec3 _beam1_003 = vec3(0.0, 0.0, halfsize.z);\n  Implicit _beam1_004 = LineSegmentRepeatMirror(p_x, p_y, p_z, _beam1_002, _beam1_003, size);\n  Implicit beam1 = Min(beam0, _beam1_004);\n  vec3 _beam2_002 = vec3(halfsize.x, 0.0, 0.0);\n  vec3 _beam2_003 = vec3(0.0, halfsize.y, 0.0);\n  Implicit _beam2_004 = LineSegmentRepeatMirror(p_x, p_y, p_z, _beam2_002, _beam2_003, size);\n  Implicit beam2 = Min(beam1, _beam2_004);\n  vec3 _beam3_002 = vec3(halfsize.x, halfsize.y, halfsize.z);\n  vec3 _beam3_003 = vec3(0.0, 0.0, halfsize.z);\n  Implicit _beam3_004 = LineSegmentRepeatMirror(p_x, p_y, p_z, _beam3_002, _beam3_003, size);\n  Implicit beam3 = Min(beam2, _beam3_004);\n  vec3 _beam4_002 = vec3(halfsize.x, halfsize.y, halfsize.z);\n  vec3 _beam4_003 = vec3(0.0, halfsize.y, 0.0);\n  Implicit _beam4_004 = LineSegmentRepeatMirror(p_x, p_y, p_z, _beam4_002, _beam4_003, size);\n  Implicit beam4 = Min(beam3, _beam4_004);\n  vec3 _beams_002 = vec3(halfsize.x, halfsize.y, halfsize.z);\n  vec3 _beams_003 = vec3(halfsize.x, 0.0, 0.0);\n  Implicit _beams_004 = LineSegmentRepeatMirror(p_x, p_y, p_z, _beams_002, _beams_003, size);\n  Implicit beams = Min(beam4, _beams_004);\n  Implicit lattice = Subtract(beams, bias);\n  solid = lattice;\n  if (index == 0) return solid;\n  Implicit inverse = Multiply(-1.0, lattice);\n  if (index == 1) return inverse;\n  Implicit _thin_000 = Abs(lattice);\n  Implicit thin = Subtract(_thin_000, thickness * 0.5);\n  if (index == 2) return thin;\n  Implicit twin = Multiply(-1.0, thin);\n  if (index == 3) return twin;\n  return Sphere(p, vec3(0.0), 0.5);\n}\n\nImplicit scaledLattice(vec3 scaledP, int index, out Implicit scaledBase) {\n  vec3 p = (scaledP - center) * 10.0;\n  Implicit base;\n  Implicit indexed = indexedLattice(p, index, base);\n  scaledBase = Divide(base, 10.0);\n  return Divide(indexed, 10.0);\n}\n\n\n// Implicit API not used by GCLS (mostly unused in LR)\n\nImplicit Square(Implicit iImplicit) {\n\tfloat square = iImplicit.Distance * iImplicit.Distance ;\n\treturn Implicit(square, 2. *  square * iImplicit.Gradient);\n}\n\nvec3 Boundary(vec3 iP, Implicit i) {\n    return -i.Distance * i.Gradient;\n}\n\nImplicit Shell(Implicit iImplicit, float thickness, float bias) {\n\tthickness *= 0.5;\n\treturn Subtract(Abs(Add(iImplicit, bias * thickness)), thickness);\n}\n\nImplicit EuclideanNorm(Implicit a, Implicit b) {\n    return Sqrt(Add(Multiply(a, a), Multiply(b, b)));\n}\nImplicit EuclideanNorm(Implicit a, Implicit b, Implicit c) {\n    return Sqrt(Add(Add(Multiply(a, a), Multiply(b, b)), Multiply(c, c)));\n}\n\n// Booleans\n\nImplicit UnionChamfer(Implicit iA, Implicit iB, float k, out float param) {\n    Implicit h = Multiply(Max(Subtract(CreateImplicit(k), Abs(Subtract(iA, iB))), CreateImplicit()), 1.0 / k);\n    Implicit h2 = Multiply(h, 0.5);\n    Implicit result = Subtract(Min(iA, iB), Multiply(h2, k * 0.5));\n    param = h2.Distance;\n    param = iA.Distance < iB.Distance ? param : (1.0 - param);\n\n    return result;\n}\nImplicit UnionChamfer(Implicit iA, Implicit iB, float k) {\n    float param;\n    return UnionChamfer(iA, iB, k, param);\n}\n\nImplicit UnionRound(Implicit iA, Implicit iB, float k, out float param)\n{\n    Implicit h = Multiply(Max(Subtract(CreateImplicit(k), Abs(Subtract(iA, iB))), CreateImplicit()), 1.0 / k);\n    Implicit h2 = Multiply(Multiply(h, h), 0.5);\n    Implicit result = Subtract(Min(iA, iB), Multiply(h2, k * 0.5));\n    param = 0.5 + 0.5 * (iA.Distance - iB.Distance) / (iA.Distance + iB.Distance);\n\n    return result;\n}\nImplicit UnionRound(Implicit iA, Implicit iB, float k) {\n    float param;\n    return UnionRound(iA, iB, k, param);\n}\n\n\nImplicit PlaneNative(vec3 p, vec3 origin, vec3 normal)\n{\n    vec3 grad = normalize(normal);\n    float v = dot(p - origin, grad);\n    return Implicit(v, grad);\n}\nImplicit PlaneNative(vec2 p, vec2 origin, vec2 normal)\n{\n    return PlaneNative(vec3(p, 0.0), vec3(origin, 0.0), vec3(normal, 0.0));\n}\n\nmat3 RotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0.0),\n        vec3(s, c, 0.0),\n        vec3(0.0, 0.0, 1.0)\n    );\n}\n\nvec3 RotateX(vec3 p, float a) {\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(p.x, -sa * p.y + ca * p.z, ca * p.y + sa * p.z);\n}\nvec3 RotateY(vec3 p, float a) {\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\nvec3 RotateZ(vec3 p, float a) {\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca * p.x + sa * p.y, -sa * p.x + ca * p.y, p.z);\n}\n\n// ColorImplicit\n\nstruct ColorImplicit {\n\tfloat Distance;\n\tvec3 Gradient;\n\tvec4 Color;\n};\n\nColorImplicit CreateColorImplicit(Implicit implicit, vec4 color) {\n    return ColorImplicit(implicit.Distance, implicit.Gradient, color);\n}\nColorImplicit CreateColorImplicit(float distance, vec4 color) {\n    return CreateColorImplicit(CreateImplicit(distance), color);\n}\n\nColorImplicit Min(ColorImplicit a, ColorImplicit b) {\n\tif (a.Distance <= b.Distance)\n\t\treturn a;\n\n\treturn b;\n}\n\nColorImplicit Max(ColorImplicit a, ColorImplicit b) {\n\tif (a.Distance >= b.Distance)\n\t\treturn a;\n\n\treturn b;\n}\n\nColorImplicit Add(ColorImplicit a, ColorImplicit b) {\n\treturn ColorImplicit(\n        a.Distance + b.Distance,\n        a.Gradient + b.Gradient,\n        0.5 * (a.Color + b.Color)\n    );\n}\nColorImplicit Add(ColorImplicit a, float b) { return CreateColorImplicit(Add(Implicit(a.Distance, a.Gradient), b), a.Color); }\n\nColorImplicit Subtract(ColorImplicit a, ColorImplicit b) {\n\treturn ColorImplicit(\n        a.Distance - b.Distance,\n        a.Gradient - b.Gradient,\n        0.5 * (a.Color + b.Color)\n    );\n}\nColorImplicit Subtract(ColorImplicit a, float b) { return CreateColorImplicit(Subtract(Implicit(a.Distance, a.Gradient), b), a.Color); }\n\n/////////////////////////////////////////////////////////////////////////////////////////////\n//\n// LatticeRobot Renderer v0.1\n//\n// This renderer is similar to the one used by LatticeRobot, derived from IQ and related ShaderToys as commented below.  \n//\n/////////////////////////////////////////////////////////////////////////////////////////////\n\n\n#if STANDALONE\n\n// Renderer uniforms\n\nuniform vec2 resolution;\nuniform float time;\nuniform float fov;\nuniform vec3 camera;\nuniform float count;\n\n// LatticeRobot uniforms\n\nuniform vec3 color_primary;\nuniform vec3 color_secondary;\nuniform vec3 color_boundingbox;\nuniform vec3 color_background;\n\n#else \n\nconst float cHigh = 0.8;\nconst float cMed = 0.7;\nconst float cLow = 0.3;\nconst vec3 color_primary = vec3(cMed, cMed, cHigh);\nconst vec3 color_secondary = vec3(cHigh, cMed, cMed);\nconst vec3 color_boundingbox = vec3(cHigh, cHigh, cHigh);\nconst vec3 color_background = vec3(1.0, 1.0, 1.0);\n\n#endif\n\n// Tree root\nColorImplicit map(vec3 p) {\n#if (STANDALONE==0)\n\n    float time = iTime;\n    vec2 resolution = iResolution.xy;\n\n#endif\n\n    vec4 colorCool = vec4(color_primary, 1.0);\n    vec4 colorWarm = vec4(color_secondary, 1.0);\n    vec4 colorLightGray = vec4(color_boundingbox, 1.0);\n\n    float amp = 0.05;\n    vec3 pOrig = p * vec3(1. + amp * cos(time), 1. + amp * cos(time), 1. + amp * sin(time));  // play with size\n    p = pOrig * count + center;\n\n    Implicit base;\n    ColorImplicit merged = CreateColorImplicit(Divide(scaledLattice(p, variantIndex, base), count), colorLightGray);\n    ColorImplicit bounds = CreateColorImplicit(BoxCenter(pOrig + center, center, 0.1 * vec3(size_x, size_y, size_z)), colorLightGray);\n\n    float bumpOffset = 0.05;\n    float bump = pow(abs(cos((1.5 * time + p.z) * 0.4)), 400.);\n    ColorImplicit colorField = Add(merged, -bump * bumpOffset);\n\n    vec4 baseColor = variantIndex == 1 ? colorWarm : colorCool;\n    colorField.Color = baseColor;\n    if (variantIndex > 1) {\n        colorField.Color = (base.Distance > 0.0) ? colorCool : colorWarm;\n    }\n\n    colorField.Color = colorField.Color + vec4(bump * 0.2);\n    return Max(colorField, bounds);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos) {\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map(pos + e.xyy*eps).Distance +\n\t\t\t\t\t  e.yyx*map(pos + e.yyx*eps).Distance +\n\t\t\t\t\t  e.yxy*map(pos + e.yxy*eps).Distance +\n\t\t\t\t\t  e.xxx*map(pos + e.xxx*eps).Distance );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadowBanding( in vec3 ro, in vec3 rd, in float mint, in float tmax ) {\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ ) {\n\t\tfloat h = map( ro + rd*t ).Distance;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float w ) {\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<256 && t<maxt; i++ ) {\n        float h = map(ro + t*rd).Distance;\n        res = min( res, h/(w*t) );\n        t += clamp(h, 0.005, 0.50);\n        if( res<-1.0 || t>maxt ) break;\n    }\n    res = max(res,-1.0);\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res);\n}\n\n// advanced via https://www.shadertoy.com/view/lsKcDD\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique ) {\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n\n    for( int i=0; i<32; i++ ) {\n\t\tfloat h = map( ro + rd*t ).Distance;\n\n        // traditional technique\n        if( technique==0 ) {\n        \tres = min( res, 10.0*h/t );\n        }\n        // improved technique\n        else {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            float y = (i==0) ? 0.0 : h*h/(2.0*ph);\n\n            // float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d/max(0.0,t-y) );\n            ph = h;\n        }\n\n        t += h;\n\n        if( res<0.0001 || t>tmax ) break;\n\n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor ) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ ) {\n        float hr = 0.01 + 0.15*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).Distance;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - occ*1.5, 0.0, 1.0 );\n}\n\n// IQ rendering https://www.shadertoy.com/view/wlXSD7\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n#if (STANDALONE==0)\n\n    float time = iTime;\n    vec2 resolution = iResolution.xy;\n\n#endif\n    vec2 p = (-resolution.xy + 2.0*fragCoord)/resolution.y;\n\n    float rad = 1.25;\n    float lightAng = 0.0;\n\tvec3 ro = vec3( rad*cos(lightAng), rad*sin(lightAng), 0.7 );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,0.0,1.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    vec3 tot = vec3(0.0);\n\n    // camera movement\n\tfloat an = 0.125*(time-10.0);\n    mat3 rot = RotateZ(an);\n    mat3 rotInv = RotateZ(-an);\n\n    // create view ray\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // raymarch\n    const float tmax = 2.5;\n    float t = 0.0;\n    ColorImplicit hit;\n    for( int i=0; i<256; i++ ) {\n        vec3 pos = (ro + t*rd) * rot;\n        hit = map(pos);\n        if( hit.Distance < 0.0001 || t > tmax ) break;\n        t += hit.Distance * 0.45;  // slow down to not miss sharp features and TPMS with Lipschitz > 1.  \n    }\n\n    if (t > tmax)\n        tot = vec3(1.0);\n        vec3 nor;\n\n#if 0    // 1 for simple renderer\n    // shading/lighting\n    vec3 col = color_background;\n    if( t<tmax ) {\n        vec3 pos = (ro + t*rd) * rot;\n        //vec3 nor = calcNormal(pos);\n        nor = normalize(hit.Gradient);\n\n        float dif = clamp( dot(nor, vec3(0.8, 0., 0.6) * rot ), 0.0, 1.0 );\n        float amb = 0.5 ;\n        col = vec3(0.6)*amb + vec3(1.)*dif;\n        col = col * hit.Color.rgb;\n    }\n#else\n    // shading/lighting\n    vec3 col = color_background;\n    if( t<tmax ) {\n        vec3 pos = (ro + t*rd) * rot;\n        // nor = calcNormal(pos);\n        nor = normalize(hit.Gradient);\n        vec3 lig = normalize(vec3(0.6,0.0,0.4)) * rot;\n        vec3 hal = normalize(lig-rd*rot);\n        float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n        float occ = calcOcclusion( pos, nor );\n        if( dif>0.001 ) dif *= softshadow( pos, lig, 0.0001, 1.0, 0.2 );\n        float spe = pow(clamp(dot(nor,hal),0.0,1.0),16.0)*dif*(0.04+0.96*pow(clamp(1.0-dot(hal,-rd*rot),0.0,1.0),5.0));\n        float amb = 0.5 + 0.5*dot(nor,vec3(0.0,0.0,1.0));\n        col =  hit.Color.rgb * amb*occ;\n        col += hit.Color.rgb * dif * 0.8;\n\n        col *= 0.8;\n\n        col += vec3(1.,1.,1.)*spe*2.0;\n    }\n#endif\n\n    tot += col;\n\tfragColor = vec4( tot, 1.0 );\n}\n\n#if STANDALONE\n\nvoid main() {\n    vec2 fragCoord = gl_FragCoord.xy;\n    gl_FragColor = vec4( 1. );\n\n    mainImage(gl_FragColor, fragCoord);\n}\n\n#endif\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}