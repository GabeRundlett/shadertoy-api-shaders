{
    "Shader": {
        "info": {
            "date": "1531396963",
            "description": "Procedural modeling of galactic dust clouds (see comments)\n\nRef for preset :\nM51 : https://fr.wikipedia.org/wiki/M51_(galaxie)#/media/File:Messier51_sRGB.jpg",
            "flags": 48,
            "hasliked": 0,
            "id": "lldczr",
            "likes": 29,
            "name": "Spiral galaxy dust clouds",
            "published": 3,
            "tags": [
                "procedural",
                "noise",
                "clouds",
                "perlin",
                "spiral",
                "galaxy"
            ],
            "usePreview": 1,
            "username": "ABizard",
            "viewed": 1951
        },
        "renderpass": [
            {
                "code": "#define keyboardChannel iChannel1\n#define fontTexChannel iChannel2\n#define bufAChannel iChannel3\n\n// Thanks to FabriceNeyret for his help :-)\n\n/*\nProcedural modeling of galactic dust clouds (in arms, spurs, and at lower scales),\nusing a logarithmic spiral conform parametrization,\nand multiplicative Perlin noise\nColors of stars and bulb are approximations - the main purpose of this work\nis the dust clouds\n\nSome controls are not on sliders - change the values in the define's below :-)\n\nControls :\nG : display control sliders (see \"## Sliders ##\" below)\nL : show the model in spiral parametric space\nF : fancy colors / black & white\nB : bulb\nS : do the spurs\nA : noise anisotropy\nO : true opacity / raw density\n\n(Debug) :\nM : display the mesh\nN : display the multiplicative noise\nD : display info\nI : invert the colors\n\n## Sliders : ##\n\nAW : Arms veins width\nLa : Lacunarity  @ not on point @\n\nSA : Spurs incident angle with the arms\nSF : Spurs frequency (= number of spurs)\nSL : Spurs veins length\nSW : Spurs veins width\n\nDF : Veins displacement frequency\nDA : Veins displacement amplitude\n\nAA : Dust anisotropy angle\nAS : Dust anisotropy strength\n\nOF : Dust clouds layer opacity factor\nLD : Low density factor (between veins)\nHD : High density factor (within veins)\n*/\n\n//////////////////////////////////////////////\n// Parameters for the spiral :\n// Warp\n#define BETA 1.38\n// Rotation\n#define GAMMA 0.38\n// Number of spiral arms\n#define N 2\n// Direction of the arms\n#define CLOCKWISE true\n///////\n\n//////////////////////////////////////////////\n// Shape function for the spurs\n// Both function and inverse derivative are needed (to match the spurs angle)\n#if 1\n    #define F(x) POW2(x)*2.\n    // Derivative is 4x, so the inverse is x/4\n    #define INV_DFDX(x) x/4.\n#else\n    #define F(x) exp(x)\n    // Derivative is exp(x), so the inverse is log(x)\n    #define INV_DFDX(x) log(x)\n#endif\n\n//////////////////////////////////////////////\n// Colors settings\n#define BULB_COLOR (FANCY_COL ? vec3(1,.95,.85) : BLACK)\n\n#define DUST_COLOR (FANCY_COL ? vec3(.3,.15,.1)*1.2 : BLACK)\n#define STARS_COLOR vec3(.85,.95,1)\n#define HII_COLOR vec3(1,.2,.25)\n#define BACKGROUND (FANCY_COL ? vec3(.25,.3,.3)*.5 : WHITE)\n\n\n\n\n\n//////////////////////////////////////////////\n// Slider i value (between 0 and 1), read from BufA\n\n#define SliderValue(i) (texture(bufAChannel,SliderPosFromI(i)).x * sliders[i].value_factor)\n\n#define ARM_WIDTH       \tSliderValue(0)\n#define LACUNARITY      \tSliderValue(1)\n#define SPURS_ANGLE     \tSliderValue(2)\n#define SPURS_FREQ      \tSliderValue(3)\n#define SPURS_LENGTH    \tSliderValue(4)\n#define SPURS_WIDTH     \tSliderValue(5)\n#define DISPLAC_FREQ    \t(round(SliderValue(6)*FirstDiv*2.)/FirstDiv/2.)\n#define DISPLAC_AMPL    \tSliderValue(7)\n#define ANISOTROPY_ANGLE   \tSliderValue(8)\n#define ANISOTROPY_STRENGTH\tSliderValue(9)\n#define DUST_OPACITY_FACTOR\tSliderValue(10)\n#define LOW_DENSITY_F   \tSliderValue(11)\n#define HIGH_DENSITY_F  \tSliderValue(12)\n\n// Cycle for the cyclic noise (will be =(n_orth,n))\nvec2 cycle;\n\n\n// Convert dust clouds density to an opacity\nfloat densityToOpacity(float dens, float width, float opacity_factor){\n    return 1. - exp(-dens*width*opacity_factor);\n}\n\n\n// High resolution density using Perlin multiplicative noise\nfloat cloudDens(vec2 uv){\n    \n    // There are currently implementation problems about resolution\n    // r should be the resolution for one cell of the mesh\n    \n    vec2 r = 1./fwidth(uv);\n    return cyclicMultNoise(uv,r,cycle);\n    \n    //mat2 J = transpose(inverse(mat2(dFdx(uv),dFdy(uv))));\n    //vec2 r = .5*vec2(length(J[0]),length(J[1]));\n    //return cyclicMultNoise(uv,r,cycle);\n    \n    //return (.5+.5*sin(length(r))); // or r.x instead of length\n    //return (.5+.5*sin(length(1./length(fwidth(uv)))));\n}\n\n//////////////////////////////////////////////\n///////////////////  MAIN  ///////////////////\n//////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    vec3 color;\n    \n    // Centered normalized coordinates in [-1,1]\n    vec2 pixel = 2.*(fragCoord-R.xy/2.) / R.y;\n    \n    // Perspective distortion to match M51\n    pixel *= 1.1*vec2(.9,1);\n    \n    // Polar coordinates\n\tfloat rho = length(pixel),\n          theta = atan(pixel.y,pixel.x); // theta in [-PI,PI]\n    \n    // Flip theta if the galaxy arms are clockwise\n    if(CLOCKWISE)\n       theta = -theta;\n    \n    // Parameters of the spiral\n    float beta=BETA,    // warp\n    \t  gamma=GAMMA;  // rotation\n    int   n=N;          // number of arms\n    \n    \n    ///////////////////////\n    // Conform parametrization along the logarithmic spiral\n    // Idea : the orthogonal to a log spiral is another log spiral\n    \n    // Parameter for the orthogonal spirals\n    float beta_orth = exp(-1./log(beta));\n    \n    // Number of arms in the orthogonal spiral\n    int n_orth = int(round(float(n)*1./log(beta)));\n    \n    vec2 uv_param;\n    if(LINEARIZE){\n        // Use direct screen coordinates\n        uv_param = fragCoord/R.y;\n        uv_param.x += iMouse.x/R.x*10. - 1.;\n        uv_param *= float(n);\n    }\n    else{\n        // Continuous parameter along the spiral arms\n        // uv_param.y is in [0,n[, orthogonal to arms\n        // uv_param.x is in R, along the arms\n        //     with 0 around the border of the screen (press M),\n        //     and +inf at the center\n        \n        #define PARAM(BETA,N,GAMMA)\\\n                     (logBase(BETA,rho)-(theta+GAMMA))*float(N)/(2.*PI)\n        uv_param.y = PARAM(beta     ,n     ,gamma);\n        uv_param.x = PARAM(beta_orth,n_orth,0.   );\n        // Move the discontinuity caused by atan (between -PI and PI)\n        // st. parametrization is continuous along the arms\n        uv_param.x += float(n_orth)*abs(floor(uv_param.y/float(n)));\n        uv_param.y = mod(uv_param.y,float(n));\n    }\n    \n    cycle = vec2(n_orth,n);\n    \n    ///////////////////////////////////\n    \n    /////////////////////////\n\t// Stars\n    color = BACKGROUND;\n    \n    if(FANCY_COL){\n        color = LINEARIZE ? color : mix(BULB_COLOR,color,clamp(rho,0.,1.));\n        \n        // Stars waves in arms\n        float starfield = clamp(2.*periodicDirac(uv_param.y-ARM_POS-.15,1.,3.5)\n                     * (POW2(exp(-cyclicMultNoise(uv_param,R.xy*5.,cycle)))*.2+.4) ,0.,1.);\n        color = mix(color,\n                    LINEARIZE ? STARS_COLOR : mix(BULB_COLOR,STARS_COLOR,clamp(rho,0.,1.)),\n                    starfield);\n\n        \n        // Random stars\n        color = mix(color,\n                    STARS_COLOR,\n                    smoothstep(.07,.06,cyclicMultNoise(fragCoord,R.xy,R.xy))\n                   );\n        \n\n        // Red HII clusters\n        vec4 hII = vec4(HII_COLOR,1)*\n            pow(cyclicAddNoise(uv_param*2.5,6,cycle)*starfield,13.)*300.;\n        color = mix(color,\n                    hII.rgb,\n                    min(hII.a,1.));\n    }\n    \n    \n    //////////////////////////\n    // High resoluion dust clouds density\n    float dens;\n    if(NOISE_ANISOTROPY)\n        dens = cloudDens(uv_param*RMat2D(ANISOTROPY_ANGLE)*vec2(1,1.+ANISOTROPY_STRENGTH));\n    else\n        dens = cloudDens(uv_param);\n    \n    \n    //////////////////////////\n    // Spiral arms veins\n    \n    // uv_param is original coordinates in parametrization\n    // uv is a copy used for veins, for displacement\n    vec2 uv = uv_param;\n    \n    if(DISPLAC_FREQ>0.)\n    \tuv += (cyclicAddNoise(uv*DISPLAC_FREQ,5,cycle*DISPLAC_FREQ)-.5)*DISPLAC_AMPL;\n    \n    // Periodic gaussian function in [0,1], period 1, spike at offset\n    #define gauss(x,width) exp(-POW2((x)/(2.*width)))\n    #define periodGauss(x,offset,width) gauss(mod(x+.5-offset,1.)-.5,width)\n    float arms_veins = periodGauss(uv.y,ARM_POS,ARM_WIDTH / (LINEARIZE ? 1. : rho));\n    \n    \n    //////////////////////////\n    // Spurs veins\n    float spurs_veins;\n    if(DO_SPURS){\n        float angle = PI/2.-SPURS_ANGLE;\n        \n        // Use a function for the shape of the spurs\n        float y_spurs = mod(uv.y,1.)-ARM_POS;\n        float fy = F(y_spurs + (INV_DFDX(tan(angle))));\n        \n        float u_spurs = (uv.x+fy)*(SPURS_FREQ);\n        \n        spurs_veins = periodGauss(u_spurs,0.,SPURS_WIDTH / (LINEARIZE ? 1. : rho));\n        \n        // Cut below the arm\n        spurs_veins *= step(0.,y_spurs);\n        \n        // Smooth fading\n        spurs_veins *= smoothstep(SPURS_LENGTH,0.,y_spurs);\n        \n    }\n    else{\n        spurs_veins = 0.;\n    }\n    \n    \n    //////////////////////////\n    // Combine low resolution veins and high resolution density\n    // to obtain final density\n    \n    // holes : low resolution lacunarity in veins\n    // @ not on point, result is ugly @\n    float holes = max(0.,-1. + (1.+LACUNARITY)*cyclicAddNoise(uv/FirstDiv*2.,5,vec2(n_orth,n)/FirstDiv*2.));\n    \n    // Combine veins by a max to avoid high value at incident points\n    float veins = max(0.,max(arms_veins,spurs_veins) - holes);\n    \n    // Remap x from [0,1] to [a,b]\n    #define remap(a,b,x) (x*(b-a)+a)\n    \n    // Combine veins and density\n    float x = dens * remap(LOW_DENSITY_F,HIGH_DENSITY_F,veins);\n    \n    // Get opacity from density\n    if(!RAW_DENSITY)\n        x = densityToOpacity(x,1.,DUST_OPACITY_FACTOR);\n    \n    ///////////////\n    //## Debug ##//\n    //x = dens;\n    //x = spike;\n    //x = fwidth(spike)*10.;\n    //x = holes;\n    //x = fwidth(uv.y);\n    //x = uv_param.y/2.;\n    //x = POW3(uv_param.x/25.);\n    ///////////////\n    \n    // Use dust clouds opacity to hide stars light\n    color = mix(color,DUST_COLOR,x);\n    \n    // Bulb\n    if(DO_BULB && !LINEARIZE){\n        color = mix(color,BULB_COLOR,clamp(1.-pow(rho,BULB_COMPR)/BULB_R,0.,1.)*.9);\n    }\n    \n    //////////////////////////////////////\n    //////////////////////////////////////\n    //////// Additionnal displays ////////\n    //////////////////////////////////////\n    //////////////////////////////////////\n    \n    // Clamp the color st. blending with additionnal displays stays nice\n    color = clamp(color,0.,1.);\n    \n    /////////////////////////\n    // Draw the mesh\n    if(DISP_MESH){\n        float s = float(1 << MESH_COMPR);\n        if(!LINEARIZE)\n            s *= rho*sqrt(rho)*log(beta);\n        #define DRAWMESH(XY) color = mix(color,GREEN/2.,periodicDirac(uv_param.XY,1.,s))\n        DRAWMESH(x);\n        DRAWMESH(y);\n        // Draw the 0 line on x (pink = +, turquoise = -)\n    \tif(abs(uv_param.x)<.015) color = uv_param.x>0. ? PINK : TURQUOISE;\n    }\n    \n    \n    // Display only multiplicative noise\n    if(DISP_NOISE){\n        vec2 mouse = 2.*iMouse.xy/R.y;\n        float dens = cloudDens(pixel-mouse);\n        color = (RAW_DENSITY ?\n                 vec3(.5,.2,.2)*dens :\n                 2.*vec3(.5,.7,.9)*(1.-densityToOpacity(dens,1.,DUST_OPACITY_FACTOR))\n                 );\n    }\n    \n    #define tex fontTexChannel\n\n    // Shortcuts for printing\n    #define NextLine nextLine(pp)\n    #define WriteWord(word,style) writeWord(word,style,pp,tex,color)\n    #define WriteNumber(number,d1,d2,style) writeNumber(number,d1,d2,style,pp,tex,color)\n    #define WriteStandardChar(char,style) writeStandardChar(char,style,pp,tex,color)\n\n    \n    // Display information about opacity/density\n    if(DISP_INFO || DISP_NOISE){\n        \n        vec2 pos = vec2(10,335)/vec2(640,360);\n        float scale = 1./30.;\n        PrintPosition pp = getDisplayPos(pos,scale);\n        PrintStyle style = DefaultPrintStyle;\n        WriteWord(int[](_D,_i,_s,_p,_l,_a,_y,_COLON,_),style);\n        if(RAW_DENSITY){\n            int[] word_opacity = int[](_D,_e,_n,_s,_i,_t,_y,_,\n                                       _LPAR,_r,_a,_w,_,_n,_o,_i,_s,_e,_RPAR);\n            WriteWord(word_opacity,style);\n        }\n        else{\n            int[] disp_width = int[](_O,_p,_a,_c,_i,_t,_y,_,\n                                     _MINUS,_,_D,_u,_s,_t,_,_o,_p,_a,_c,_i,_t,_y,_,_f,_a,_c,_t,_o,_r,_,_EQ,_);\n            WriteWord(disp_width,style);\n            WriteNumber(DUST_OPACITY_FACTOR,1,2,style);\n        }\n    }\n    \n    // Display the sliders\n    if(DISP_SLIDERS){\n        float slider_disp = texelFetch(bufAChannel,ivec2(fragCoord),0).y;\n        \n    \tcolor = mix(color, SLIDER_COLOR, slider_disp);\n        vec2 pos = vec2(5,106)/vec2(640,360);\n        float scale = 1./29.9;\n        PrintPosition pp = getDisplayPos(pos,scale);\n        PrintStyle style1 = DefaultPrintStyle;\n        \n        // Write sliders labels\n        WriteWord(sliders_labels,style1);\n        \n        // Write sliders values\n        PrintStyle style2 = NewPrintStyle(BLACK,GREEN);\n        pos = vec2(6,17)/vec2(640,360);\n        scale = 1./34.;\n        pp = getDisplayPos(pos,scale);\n        for(int i=0; i<NB_SLIDERS; i++){\n            WriteNumber(min(SliderValue(i),9.9),1,1,style2);\n            WriteStandardChar(_,style2);\n        }\n        \n        \n        int islider = int(texture(bufAChannel,vec2(0)).z*float(NB_SLIDERS));\n        \n        if(islider < NB_SLIDERS){\n            // Write current slider full name\n        \tPrintStyle style4 = NewPrintStyle(BLACK,LAGOON);\n            pos = vec2(max(float(islider)*(SLIDER_W+SLIDER_SPACING)*640.-50.,5.),122)/vec2(640,360);\n        \tscale = 1./30.;\n       \t\tpp = getDisplayPos(pos,scale);\n            int[19] name;\n            switch(islider){\n                case 0 : name = int[](_A,_r,_m,_s,_ ,_w,_i,_d,_t,_h,_ ,_ ,_ ,_ ,_ ,_ ,_ ,_ ,_ ); break;\n                case 1 : name = int[](_L,_a,_c,_u,_n,_a,_r,_i,_t,_y,_ ,_ ,_ ,_ ,_ ,_ ,_ ,_ ,_ ); break;\n                case 2 : name = int[](_S,_p,_u,_r,_s,_ ,_a,_n,_g,_l,_e,_ ,_ ,_ ,_ ,_ ,_ ,_ ,_ ); break;\n                case 3 : name = int[](_S,_p,_u,_r,_s,_ ,_f,_r,_e,_q,_u,_e,_n,_c,_y,_ ,_ ,_ ,_ ); break;\n                case 4 : name = int[](_S,_p,_u,_r,_s,_ ,_l,_e,_n,_g,_t,_h,_ ,_ ,_ ,_ ,_ ,_ ,_ ); break;\n                case 5 : name = int[](_S,_p,_u,_r,_s,_ ,_w,_i,_d,_t,_h,_ ,_ ,_ ,_ ,_ ,_ ,_ ,_ ); break;\n                case 6 : name = int[](_D,_i,_s,_p,_l,_a,_c,46,_ ,_f,_r,_e,_q,_u,_e,_n,_c,_y,_ ); break;\n                case 7 : name = int[](_D,_i,_s,_p,_l,_a,_c,46,_ ,_a,_m,_p,_l,_i,_t,_u,_d,_e,_ ); break;\n                case 8 : name = int[](_A,_n,_i,_s,_o,_t,_r,_o,_p,_y,_ ,_a,_n,_g,_l,_e,_ ,_ ,_ ); break;\n                case 9 : name = int[](_A,_n,_i,_s,_o,_t,_r,_o,_p,_y,_ ,_s,_t,_r,_e,_n,_g,_t,_h); break;\n                case 10: name = int[](_D,_u,_s,_t,_ ,_o,_p,_a,_c,_i,_t,_y,_ ,_f,_a,_c,_t,_o,_r); break;\n                case 11: name = int[](_L,_o,_w,_ ,_d,_e,_n,_s,_i,_t,_y,_ ,_f,_a,_c,_t,_o,_r,_ ); break;\n                case 12: name = int[](_H,_i,_g,_h,_ ,_d,_e,_n,_s,_i,_t,_y,_ ,_f,_a,_c,_t,_o,_r); break;\n            }\n            WriteWord(name,style4);\n        }\n        \n        // Global restore default button\n        PrintStyle style3 = NewPrintStyle(BLACK,LIGHT_BLUE*2.);\n        pos = vec2(560,20)/vec2(640,360);\n        scale = 1./30.;\n        pp = getDisplayPos(pos,scale);\n        WriteWord(int[](_R,_e,_s,_t,_o,_r,_e),style3);\n        NextLine;\n        WriteWord(int[](_d,_e,_f,_a,_u,_l,_t),style3);\n        \n        // Per-slider restore default buttons\n        pos = vec2(10,-6)/vec2(640,360);\n        scale = 1./20.;\n        pp = getDisplayPos(pos,scale);\n        for(int i=0; i<NB_SLIDERS; i++){\n            WriteStandardChar(26,style3);\n            WriteStandardChar(_,style3);\n        }\n    }\n    \n    if(INVERT_COLORS)\n    \tcolor = 1.-color;\n    \n    fragColor = vec4(color,1);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define PI 3.141593\n#define R iResolution\n\n\n//////////////////////////////////////////////\n// Keyboard controls and params tuning\n\n#define keyToggle(K) (texture(keyboardChannel,vec2((.5+float(K))/256.,0.75)).x > 0.)\n\n\n#define DISP_SLIDERS    \t!keyToggle(_G)\n#define LINEARIZE       \t keyToggle(_L)\n#define FANCY_COL       \t!keyToggle(_F)\n#define DO_BULB         \t!keyToggle(_B)\n#define BULB_R .03\n#define BULB_COMPR 3.\n#define DO_SPURS        \t!keyToggle(_S)\n#define NOISE_ANISOTROPY\t!keyToggle(_A)\n#define RAW_DENSITY\t    \t keyToggle(_O)\n\n// Debug :\n#define DISP_MESH       \t keyToggle(_M)\n#define MESH_COMPR 13\n#define DISP_NOISE      \t keyToggle(_N)\n#define DISP_INFO       \t keyToggle(_D)\n#define INVERT_COLORS   \t keyToggle(_I)\n\n\n// Arm offset (currently needed because of the spurs discontinuity)\n#define ARM_POS .3\n\n////////////////////\n// Sliders\n#define SLIDER_W      \t.025\n#define SLIDER_H      \t.2\n#define SLIDER_SPACING\t.025\n#define SLIDER_LINE_W \t.01\n// Center position of first slider\n#define SLIDER_POS\t\tvec2(.025,.2)\n#define SLIDER_COLOR    RED\n\n// i-th slider center\n#define SliderPosFromI(i) (SLIDER_POS + float(i)*vec2(SLIDER_W+SLIDER_SPACING,0))\n// slider index from position\n// if index >= NB_SLIDERS, then position is beyond sliders\n#define iSliderFromPos(pos) int((pos.x-SLIDER_POS.x+SLIDER_W/2.)/(SLIDER_W+SLIDER_SPACING))\n\n// Ascii values of chars\nconst int\t_=32,           // space\n\t\t\t_LPAR=40,\t\t// (\n\t\t\t_RPAR=41,\t\t// )\n\t\t\t_MINUS=45,\t\t// -\n\t\t\t_DOT=46,\t\t// .\n    \t\t_COLON=58,\t\t// :\n    \t\t_EQ=61,\t\t\t// =\n\t\t\t_0=48,\n\t\t\t_A=65,\t_B=66,\t_C=67,\t_D=68,\t_E=69,\n\t\t\t_F=70,\t_G=71,\t_H=72,\t_I=73,\t_J=74,\n\t\t\t_K=75,\t_L=76,\t_M=77,\t_N=78,\t_O=79,\n\t\t\t_P=80,\t_Q=81,\t_R=82,\t_S=83,\t_T=84,\n\t\t\t_U=85,\t_V=86,\t_W=87,\t_X=88,\t_Y=89,\n\t\t\t_Z=90,\n\t\t\t_a=97,\t_b=98,\t_c=99,\t_d=100,\t_e=101,\n\t\t\t_f=102,\t_g=103,\t_h=104,\t_i=105,\t_j=106,\n\t\t\t_k=107,\t_l=108,\t_m=109,\t_n=110,\t_o=111,\n\t\t\t_p=112,\t_q=113,\t_r=114,\t_s=115,\t_t=116,\n\t\t\t_u=117,\t_v=118,\t_w=119,\t_x=120,\t_y=121,\n\t\t\t_z=122;\n\n// Sliders default values, and value factors\nstruct Slider{\n    float def_value;\n    float value_factor;\n};\nconst Slider[] sliders =\n    Slider[](\n        Slider(.11,1./8.),\n        Slider(.0 ,2.   ),\n        Slider(.32,PI   ),\n        Slider(.17,10.  ),\n        Slider(.38,2.   ),\n        Slider(.1 ,1./3.),\n        Slider(.27,1.   ),\n        Slider(.25,1.   ),\n        Slider(.13,PI   ),\n        Slider(.25,2.   ),\n        Slider(.22,6.   ),\n        Slider(.38,1.   ),\n        Slider(.56,3.   )\n    );\n\nconst int NB_SLIDERS = sliders.length();\n\n// Labels of the sliders\n// Shader is way faster by putting it in a separate array,\n// rather than in the Slider structure\nconst int[] sliders_labels = int[](_A,_W,_,\n                                   _L,_a,_,\n                                   _S,_A,_,\n                                   _S,_F,_,\n                                   _S,_L,_,\n                                   _S,_W,_,\n                                   _D,_F,_,\n                                   _D,_A,_,\n                                   _A,_A,_,\n                                   _A,_S,_,\n                                   _O,_F,_,\n                                   _L,_D,_,\n                                   _H,_D);\n\n// Pow functions\n// cheaper than pow(x,y)\n#define POW2(A) ((A)*(A))\n#define POW3(A) (POW2(A)*(A))\n#define POW4(A) (POW3(A)*(A))\n\n// 2D rotation matrix\n#define RMat2D(A) mat2(cos(A),-sin(A),sin(A),cos(A))\n\n// Colors\n#define BLACK\t\tvec3(0)\n#define WHITE\t\tvec3(1)\n#define RED  \t\tvec3(1,0,0)\n#define GREEN\t\tvec3(0,1,0)\n#define BLUE \t\tvec3(0,0,1)\n#define TURQUOISE \tvec3(0,1,1)\n#define YELLOW \t\tvec3(1,1,0)\n#define LIGHT_BLUE\tvec3(0,.5,1)\n#define LAGOON\t\tvec3(0,1,.5)\n#define PINK\t\tvec3(1,.3,.7)\n\nfloat logBase(float base, float x){\n    return log(x)/log(base);\n}\n\n// Periodic function __|__|__|__|__\n// s : dirac compression\nfloat periodicDirac(float x, float period, float s){\n\treturn pow(abs(cos(x*(PI/period))),s);\n}\n\n// Point to rectangle distance\nfloat dRect(vec2 p, vec2 center, vec2 size){\n    return length(max(abs(p-center)-size/2.,0.));\n}\n\n///////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////\n////////////////////// Font printing lib //////////////////////\n///////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////\n\nstruct PrintPosition{\n    vec2 uv,\n         pos;\n    float scale;\n};\n\nstruct PrintStyle{\n    vec3 char_color,\n         outline_color;\n    float outline_size;\n};\n\nPrintStyle NewPrintStyle(vec3 col1, vec3 col2, float w){\n\treturn PrintStyle(col1,col2,w);\n}\nPrintStyle NewPrintStyle(vec3 col1, vec3 col2){\n\treturn PrintStyle(col1,col2,.05);\n}\nPrintStyle NewPrintStyle(vec3 col){\n\treturn PrintStyle(col,col,0.);\n}\n#define DefaultPrintStyle NewPrintStyle(BLACK,YELLOW)\n\n#define getDisplayPos(pos,scale) PrintPosition((fragCoord-pos*R.xy)/(scale*R.x),pos,scale);\n#define nextLine(p)\tp.pos.y -= scale*1.5,\\\n\t\t\t\t\tp = getDisplayPos(p.pos,p.scale);\n\nvoid writeChar(int char, PrintStyle style,\n               float w, float x_offset, // Dimensions of the bbox of the char\n               inout PrintPosition p, sampler2D font_tex, inout vec3 color){\n    \t#define getFont(uv,char) texture(font_tex, (uv+vec2(char%16,15-char/16))/16.)\n\t\tvec2 uv = p.uv;\n    \tuv.x += x_offset;\n    \tfloat outline_size = style.outline_size;\n    \tif(uv.x>0. && uv.x<w && uv.y>0. && uv.y<1.){\n            // We are inside the bbox, display the char\n            color = mix(color,style.outline_color,smoothstep(outline_size+.51,outline_size+.48,getFont(uv,char).a));\n            color = mix(color,style.char_color, getFont(uv,char).r);\n        }\n\t\tuv.x -= w; // move uv for next char\n    \tp.uv = uv;\n}\n\nconst float default_ch_w = .8,\n            default_ch_off = .3;\n\nvoid writeStandardChar(int char, PrintStyle style,\n                     inout PrintPosition p, sampler2D font_tex, inout vec3 color){\n    writeChar(char,style,\n              default_ch_w,default_ch_off,\n              p,font_tex,color);\n}\n\n#define writeWord(word, style, p, font_tex, color)\\\n\tfor(int i_=0;i_<word.length();i_++)\\\n        writeStandardChar(word[i_],style,p,font_tex,color);\n\n\n\nint powInt(int a, int b){\n    int r = 1;\n    for(int i=0;i++<b;r*=a);\n    return r;\n}\n\nint intLog(int x, int base){\n    if(x<1) return 0;\n    int res = 0;\n    for(;x>=base;res++)\n        x /= base;\n    return res;\n}\n\nvoid writeNumber(float number, int min_int_digits, int dec_digits,\n                 PrintStyle style,\n                 inout PrintPosition p, sampler2D font_tex, inout vec3 color){\n\t\n    if(isnan(number)){\n    \tPrintStyle NaN_style = PrintStyle(BLACK,RED,.05);\n        writeWord(int[](_N,_a,_N),NaN_style,p,font_tex,color);\n    }\n    else if(isinf(number)){\n        PrintStyle Inf_style = PrintStyle(BLACK,LIGHT_BLUE,.05);\n        writeWord(int[](_I,_n,_f),Inf_style,p,font_tex,color);\n    }\n    else{\n        // Display the minus if number is negative\n        if(number<0.)\n            writeStandardChar(_MINUS,style,p,font_tex,color);\n        \n        // Round the number according to the number of decimal digits\n        float decimal_digits_factor = float(powInt(10,dec_digits));\n        int rounded_number = int(round(abs(number)*decimal_digits_factor));\n        \n        int int_part = rounded_number/int(decimal_digits_factor);\n        int int_digits = 1 + intLog(int_part,10);\n        // Fill with zeros to match min digits\n        for(int i=0;i++< min_int_digits - int_digits ;)\n            writeStandardChar(_0,style,\n                              p,font_tex,color);\n        \n        \n        int digits = int_digits+dec_digits;\n        for(int x = powInt(10,digits);digits>0;digits--){\n            if(digits==dec_digits)\n                // Dot\n                writeChar(_DOT,style,\n                      .65,.45,\n                      p,font_tex,color);\n            writeStandardChar(_0+rounded_number/(x/=10),style,\n                              p,font_tex,color);\n            rounded_number%=x;\n        }\n    }\n        \n}\n\n///////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////\n///////////////// Multiplicative Perlin Noise /////////////////\n///////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////\n\n// Fork of \"Infinite Perlin Noise\" by LoubetG. https://shadertoy.com/view/Xs23D3\n// 2018-02-16 10:25:53\n\n// --- Fractal noise simulating heterogeneous density in galactic clouds\n// ---   -> help from Fabrice Neyret, https://www.shadertoy.com/user/FabriceNeyret2\n// ---   -> noise functions from Inigo Quilez, https://www.shadertoy.com/view/XslGRr\n\n\n// Number of computed scales\n#define NbScales 22.\n\n// Anti aliasing\n#define LimitDetails 2.5\n#define SmoothZone 100.\n\n#define ZoomDistance 10.\n\n// Size of the first Perlin Noise grid\n#define FirstDivision 8.\n\n#define GazConcentration 1\n\n// Caracteristic ratio of the frequencies (0.5 for octaves)\n#define fRatio .5\n\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// random hash\nvec2 hash( vec2 p ) { // -> [-1,1]\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)));\n\treturn -1. + 2.*fract(sin(p+20.)*53758.545312);\n}\n\n// Tileable anisotropic noise doesnt work\n// To be fixed\n#define TILEABLE_NOISE 1\nfloat noise( vec2 p, vec2 cycle ) { // -> [-1,1]\n    vec2 i = floor(p),\n         f = fract(p);\n\tvec2 u = smoothstep(0.,1.,f);\n#if TILEABLE_NOISE\n    return mix( mix( dot( hash( mod(i + vec2(0,0),cycle) ), f - vec2(0,0) ), \n                     dot( hash( mod(i + vec2(1,0),cycle) ), f - vec2(1,0) ), u.x),\n                mix( dot( hash( mod(i + vec2(0,1),cycle) ), f - vec2(0,1) ), \n                     dot( hash( mod(i + vec2(1,1),cycle) ), f - vec2(1,1) ), u.x),\n                u.y);\n#else\n    return mix( mix( dot( hash( i + vec2(0,0) ), f - vec2(0,0) ), \n                     dot( hash( i + vec2(1,0) ), f - vec2(1,0) ), u.x),\n                mix( dot( hash( i + vec2(0,1) ), f - vec2(0,1) ), \n                     dot( hash( i + vec2(1,1) ), f - vec2(1,1) ), u.x),\n                u.y);\n#endif\n}\n\n// -----------------------------------------------\n\nfloat cyclicMultNoise( vec2 uv, vec2 resolution, vec2 base_cycle ) {\n\n\tfloat d = 1.; // initial density\n    \n\tfloat n_tiles_level_1 = pow(2.,FirstDivision+round(ZoomDistance/log(2.)));\n    \n    uv *= n_tiles_level_1;\n\tvec2 cycle = base_cycle*n_tiles_level_1;\n    \n\t// computation of the multiplicative noise\n\tfloat q = n_tiles_level_1;\n\tfor (float i = 0.; i < NbScales; i++) {\n        // Stop if the value is too low (and we assume it will thus stay low)\n\t\tif (d<1e-2) continue;\n\t\t\n\t\t// compute only the visible scales\n\t\tfloat crit = q - length(resolution)/LimitDetails;\n\t\tif (crit < SmoothZone) {\n            \n            float n = noise(uv + 10.7*i*i, cycle); // n : [-1,1]\n\n            // Sharpen the noise\n            for (int j = 0; j < GazConcentration; j++) {\n                n = sin(n*PI/2.); // n : [-1,1] -> [-1,1]\n            }\n\n            n = n+1.; // n : [-1,1] -> [0,2]\n            \n            if (crit>0.) {\n                // avoid aliasing by linear interpolation\n\t\t\t\tfloat t = crit/SmoothZone;\n\t\t\t\tn = mix(n,1.,t);\n\t\t\t}\n            \n\t\t\td *= n;\n\t\t}\n\t\t\n        // go to the next octave\n\t\tuv *= fRatio;\n        cycle *= fRatio;\n        q*= fRatio;\n\t}\n\t\n\td = max(d,0.);\n    return d;\n}\n\n\n///////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////\n//////////////////// Additive Perlin Noise ////////////////////\n///////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////\n\n#define FirstDiv 8.\n\nfloat noise2( vec2 p, vec2 cycle )\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = smoothstep(0.,1.,f);\n    return mix( mix( hash( mod(i + vec2(0,0),cycle) ), \n                     hash( mod(i + vec2(1,0),cycle) ), u.x),\n                mix( hash( mod(i + vec2(0,1),cycle) ), \n                     hash( mod(i + vec2(1,1),cycle) ), u.x), u.y).x;\n}\n\nfloat cyclicAddNoise( vec2 uv, int octaves, vec2 base_cycle){\n    float f=0.;\n    vec2 cycle = base_cycle*FirstDiv;\n    uv *= FirstDiv;\n    for(int i=0;i<octaves; i++){\n        f += 1./(pow(2.,float(i+1)))*noise2( uv,cycle );\n        uv *= 2.;\n        cycle *= 2.;\n    }\n\n    return (f+1.)/2.;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n#define selfChannel iChannel0\n#define keyboardChannel iChannel1\n\n/*\n    Utils buffer for sliders :\n- o.x is sliders value\n- o.y is sliders display\n- o.z is slider currently being clicked (to display corresponding text)\n- o.w is previous R.x (to reload sliders upon window resizing)\n*/\n\n// Draw a slider as 2 rectangles\nfloat dispSlider(vec2 uv, vec2 pos, float value){\n    return step(0., - dRect(uv,pos,vec2(SLIDER_LINE_W*R.y/R.x,SLIDER_H))\n               \t\t* dRect(uv,pos+vec2(0,value*SLIDER_H-SLIDER_H/2.),vec2(SLIDER_W,SLIDER_LINE_W)));\n}\n\nvoid mainImage( out vec4 o, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/R.xy,\n         mouse = iMouse.xy/R.xy,\n         click = sign(iMouse.z)*abs(iMouse.zw)/R.xy;\n    vec4 prev_o = texture(selfChannel,uv);\n    \n    bool resized = prev_o.w != R.x/1200.;\n    \n    if((!DISP_SLIDERS || click.x<0.) && !resized){\n        // Nothing to do, o is previous o\n        o = prev_o;\n        o.z = 1.;\n        return;\n    }\n    \n    // General restore defaults button\n    bool restore_defaults = DISP_SLIDERS && click.x>.87 && click.y<.11;\n    \n    // Slider of the current pixel\n    int islider_uv = iSliderFromPos(uv);\n    \n    // Init / Re-init at default values\n    if(iFrame == 0 || resized || restore_defaults){\n        float value = sliders[islider_uv].def_value;\n        float display = islider_uv<NB_SLIDERS ?\n                               dispSlider(uv,SliderPosFromI(islider_uv),value)\n                               : 0.;\n        o = vec4(value,display,1.,R.x/1200.);\n        return;\n    }\n    \n    // Current slider according to mouse click x, between 0 and NB_SLIDERS-1\n    // (or more if mouse beyond sliders)\n    int islider_mouse = iSliderFromPos(click);\n    \n    // Was the mouse click on the slider ?\n    bool mouse_x_in_slider = mod(click.x-SLIDER_POS.x+SLIDER_W/2.,SLIDER_W+SLIDER_SPACING)<=SLIDER_W;\n    bool mouse_y_in_slider = abs(click.y-SLIDER_POS.y) < SLIDER_H/2.;\n    bool mouse_in_slider = mouse_x_in_slider && mouse_y_in_slider;\n    \n    // Current slider in o.z\n    o.z = mouse_in_slider ? float(islider_mouse)/float(NB_SLIDERS) : 1.;\n    \n    // Is the current pixel on the same slider than the mouse click ?\n    bool pixel_in_mouse_slider = (islider_uv == islider_mouse);\n    \n    if(!pixel_in_mouse_slider || islider_mouse>=NB_SLIDERS){\n        // Nothing to do, o is previous o\n        // but still update o.z\n        o.xyw = prev_o.xyw;\n        return;\n    }\n    \n    // Current slider restore default button\n    bool restore_default_current = click.y<=.055 && mouse_x_in_slider;\n    \n    // Current slider update\n    if(mouse_in_slider || restore_default_current){\n        float value = restore_default_current ?\n            \t\t\t\t  sliders[islider_mouse].def_value\n            \t\t\t\t: clamp((mouse.y-SLIDER_POS.y+SLIDER_H/2.)/SLIDER_H,0.,1.);\n        float display = dispSlider(uv,SliderPosFromI(islider_mouse),value);\n        o = vec4(value,display,o.z,R.x/1200.);\n    }\n    else{\n        o = prev_o;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}