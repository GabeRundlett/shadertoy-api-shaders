{
    "Shader": {
        "info": {
            "date": "1603163845",
            "description": "My first experiment with particles, you can use the mouse to turn around.\nNot my prettiest one but I found it very fascinating to watch. Can't stop staring at it. ðŸ˜‰\nFast on my old PC but very slow on my phone, please watch on PC. ",
            "flags": 32,
            "hasliked": 0,
            "id": "wdVyWm",
            "likes": 20,
            "name": "Metaball Flock",
            "published": 3,
            "tags": [
                "particles",
                "metaball",
                "flock",
                "vectorball",
                "pbd"
            ],
            "usePreview": 0,
            "username": "xjorma",
            "viewed": 612
        },
        "renderpass": [
            {
                "code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n#define AA 0\n\nvec4 Load(in int id)\n{\n\treturn texelFetch(iChannel0, ivec2(id % int(MAX_PER_ROW), id / int(MAX_PER_ROW)), 0);\n}\n\n\n\nvec3 Fog(vec3 rgb,float distance, vec3 fogColor)\n{\n    float fogAmount = 1.0 - exp( -distance*0.3 );\n    return mix( rgb, fogColor, fogAmount );\n}\n\n\nvec3 Render(vec3 ro,vec3 rd,vec3 cd,float dist)\n{\n    float mint = dist;\n    vec3  c = vec3(0);\n    for(int i = 0; i < NB_PART; i++)\n    {\n        vec3 pos = Load(i).xyz;\n        float t = sphIntersect( ro, rd, pos, BALL_RADIUS).x;\n        if(t > 0. && t < mint)\n        {\n            mint = t;\n            c = pos;\n        }     \n    }\n    \n    vec3 col;\n    if(mint<dist)\n    {\n        vec3 i = (ro + mint * rd);\n        vec3 n = normalize(i - c);\n        vec3 r = reflect(rd, n);\n        col = texture(iChannel1, r).rgb * color(i, iTime);\n        col = Fog(col, mint, vec3(0)); \n    }\n    else\n    {\n        col = vec3(0);\n    }\n    \n    \n    \n    return col;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 tot = vec3(0.0);\n        \n#if AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n \n        // camera\n        \n        float theta\t= radians(360.)*(iMouse.x/iResolution.x-0.5);\n        float phi\t= radians(90.)*(iMouse.y/iResolution.y-0.5)-1.;\n        vec3 ro = 3.*vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        //vec3 ro = vec3(0.0,.2,4.0);\n        vec3 ta = vec3( 0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        //vec3 cd = ca[2];    \n        \n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        \n        vec3 col = Render(ro ,rd ,ca[2],12.);\n        \n\n        tot += col;\n            \n#if AA\n    }\n    tot /= 4.;\n#endif\n\n\tfragColor = vec4( sqrt(tot), 1.0 );\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 27,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n#define NB_PART\t\t\t512\n#define MAX_PER_ROW\t\t256.\n#define BALL_RADIUS\t\t0.05\n#define BALL_RANGE\t\tvec3(0.3,1.,1.);\n\n\n#define COLOR_0\t\tvec3(255, 215,   0) / 255.;\n#define COLOR_1 \tvec3(184, 115,  51) / 255.;\n#define COLOR_2\t\tvec3(200, 200, 200) / 255.;\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nfloat sdSphere( in vec3 p, in float r )\n{\n    return length(p)-r;\n}\n\nfloat sdf0(in vec3 p, in float t)\n{\n    vec3  d = BALL_RANGE;\n    float r = 0.6;\n    return sdSphere( p - d*vec3(sin(t / 2.0 + 3.2), sin(t / 2.1 + 0.4), sin(t / 2.3 + 0.7)), r );\n}\n\nfloat sdf1(in vec3 p, in float t)\n{\n    vec3  d = BALL_RANGE;\n    float r = 0.6;\n    return sdSphere( p - d*vec3(sin(t / 2.4 + 1.3), sin(t / 1.9 + 2.2), sin(t / 2.5 + 1.2)), r );\n}\n\nfloat sdf2(in vec3 p, in float t)\n{\n    vec3  d = BALL_RANGE;\n    float r = 0.6;\n    return sdSphere( p - d*vec3(sin(t / 2.9 + 2.3), sin(t / 3.0 + 0.3), sin(t / 2.6 + 2.8)), r );\n}\n\n\nconst float k = 8.;\n\nfloat map(in vec3 p, float t)\n{\n    // MetaBall\n \tfloat sminAcc = 0.;\n    sminAcc += exp2(-k * sdf0(p, t));\n    sminAcc += exp2(-k * sdf1(p, t));\n    sminAcc += exp2(-k * sdf2(p, t));\n    return -log2( sminAcc )/k;\n}\n\n#define EPS  0.001\nvec3 calcNormal( in vec3 pos, float t)\n{\n    const float ep = EPS;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep, t ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep, t ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep, t ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep, t ) );\n}\n\nconst float IDWMin = 0.01;\n// https://en.wikipedia.org/wiki/Inverse_distance_weighting\nvec3 color(in vec3 pos, in float t)\n{\n    vec3 c0 = COLOR_0;\n    vec3 c1 = COLOR_1;\n    vec3 c2 = COLOR_2;\n    float d0 = 1. / max(sdf0(pos, t), IDWMin);\n    float d1 = 1. / max(sdf1(pos, t), IDWMin);\n    float d2 = 1. / max(sdf2(pos, t), IDWMin);    \n    return (c0 * d0 + c1 * d1  + c2 * d2) / ( d0 + d1 + d2);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\nvec4 Load(in int id)\n{\n\treturn texelFetch(iChannel0, ivec2(id % int(MAX_PER_ROW), id / int(MAX_PER_ROW)), 0);\n}\n\n\nconst float pushDist = BALL_RADIUS * 8.;\n\nvec3 push(in vec3 p, in int id)\n{\n    vec3 off = vec3(0);\n    for(int i = 0; i < NB_PART; i++)\n    {\n        if(i != id)\n        {\n\t        vec3 pp = Load(i).xyz;\n            vec3 v = p - pp;\n            float d = length(v);\n            if( d < pushDist)\n            {\n                off += 0.5 * v * pow(pushDist - d, 2.);\n            }\n        }\n    }\n    return p + off;\n}\n\nvec3 project(in vec3 p, in float t)\n{\n    vec3 n = calcNormal(p, t);\n    float d = map(p, t);\n    return p - d * n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = floor(fragCoord);\n    int\tpixId = int(fragCoord.x + MAX_PER_ROW * fragCoord.y);\n    if( fragCoord.x >= MAX_PER_ROW || pixId >= NB_PART)\n    {\n        discard;\n    }\n    vec3\tpos;\n    if(iFrame == 0)\n    {\n        pos = ((vec3(pixId & 7, (pixId>>3) & 7, pixId>>6)) - 4.) / 8.;\n        pos = push(pos, pixId);\n    }\n    else\n    {\n        pos = Load(pixId).xyz;\n        pos = push(pos, pixId);\n        pos = project(pos, iTime);\n    }    \n    fragColor = vec4(pos,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}