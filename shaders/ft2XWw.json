{
    "Shader": {
        "info": {
            "date": "1627821460",
            "description": "The Fly was one of the first 'horror' movies I saw (waaay too young...).\nI think the unsung hero in the movie is the fly itself. This is a tribute to that little performer.\nIf anyone has tips to speed up compile time they'd be most welcome!",
            "flags": 1,
            "hasliked": 0,
            "id": "ft2XWw",
            "likes": 24,
            "name": "The Fly",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "glow",
                "movie",
                "cineshader"
            ],
            "usePreview": 1,
            "username": "dean_the_coder",
            "viewed": 6291
        },
        "renderpass": [
            {
                "code": "// 'The Fly' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/ft2XWw\n//  YouTube HD: https://youtu.be/Vq-9sCiXFLo\n// YouTube 360: https://youtu.be/wJyUM3pxl7I\n//\n// Processed by 'GLSL Shader Shrinker' (Shrunk by 1,642 characters)\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// The Fly was one of the first 'horror' movies I saw (waaay\n// too young...). An awesome movie!\n// I think the unsung hero in the movie is the fly itself.\n// This is a tribute to that little performer.\n//\n// Tricks to get the performance:\n// - As always, making use of abs() to reflect objects.\n//   (There's only one window pane, and one horizontal pipe\n//   on the wall - The others are mirrored.)\n// - There's only one point light. The extra whiteness inside\n//   the 'pod' is faked in the material code.\n// - I tend to avoid using Shadertoy's textures.\n//   This is partly due to performance, but mostly because I'm\n//   a bit of a purist and like the idea of 'everything you\n//   see is generated in real time'. Although using that wood\n//   texture is always very tempting! :)\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// Blackle and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define R\tiResolution\n#define Z0\tmin(iTime, 0.)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S01(a)\tsmoothstep(0., 1., a)\n#define S(a, b, c)\tsmoothstep(a, b, c)\n\nfloat t,\n      g = 0.;\n\n#define HASH\tp = fract(p * .1031); p *= p + 3.3456; return fract(p * (p + p));\n\nvec4 h44(vec4 p) { HASH }\n\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(h44(h), h44(h + s.x), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat n21(vec2 p) { return n31(vec3(p, 1)); }\n\nfloat fbm(vec3 p) {\n\tfloat i,\n\t      a = 0.,\n\t      b = .5;\n\tfor (i = Z0; i < 4.; i++) {\n\t\ta += b * n31(p);\n\t\tb *= .5;\n\t\tp *= 2.;\n\t}\n\n\treturn a * .5;\n}\n\n#define minH(a)\tif (a.x < h.x) h = a\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat cyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(length(p.xy), p.z)) - hr;\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat cap(vec3 p, float h, float r) {\n\tp.y -= clamp(p.y, 0., h);\n\treturn length(p) - r;\n}\n\nfloat tor(vec3 p, vec2 t) {\n\tvec2 q = vec2(length(p.xz) - t.x, p.y);\n\treturn length(q) - t.y;\n}\n\nfloat link(vec3 p, float le, float r1, float r2) {\n\tvec3 q = vec3(p.x, max(abs(p.y) - le, 0.), p.z);\n\treturn length(vec2(length(q.xy) - r1, q.z)) - r2;\n}\n\nfloat pod(vec3 p, bool isDr, out float w) {\n\tfloat d, dr,\n\t      s = step(3.25, p.y),\n\t      a = atan(p.x, p.z);\n\tw = (max(0., p.y - 1.) + sat(1. - p.y)) * .25 + s * .1;\n\td = max(cap(p, 3.2, 1.5 - sqrt(w * w + .001)), -p.y);\n\tw = d;\n\tdr = p.y * .09 - 1.3 - p.z - S(2.3, 3.3, p.y) - S(.3, 1.5, abs(p.x));\n\tif (isDr) return max(d, -dr);\n\td -= .15 * sat(sin(p.y * 30.)) * (1. - s) * step(1., p.y) + sat(sin(a * 25.) * .1 * s) * step(p.y, 3.5);\n\treturn isDr ? max(w, -dr) : max(max(d, dr), dr);\n}\n\nvec2 map(vec3 p) {\n\tvec2 h = vec2(p.y, 2);\n\tfloat d, podd,\n\t      w = t * 4.;\n\tvec3 pp = vec3(cos(w) * cos(w * 1.3) * .5, 1.5 + sin(w * .5) * .5, -6. * (S(10., 5., t) + S(32., 40., t)));\n\tpp = mix(pp, vec3(0, .3, 0), sat(S(16., 20., t) - S(28., 32., t)));\n\tminH(vec2(length(p - pp) - .02, 1));\n\tminH(vec2(8. - p.z, 4));\n\tpp = p;\n\tpp.x++;\n\tpp.y -= 3.3;\n\td = max(min(abs(4.5 - pp.z) - .5, 18. - p.x), -box(pp, vec3(1.26, 2.12, 4.6)));\n\tpp.xy = abs(abs(pp.xy) - vec2(.64, 1.08)) - vec2(.32, .54);\n\td = max(d, -box(pp, vec3(.3, .5, 9)));\n\tminH(vec2(d, 3));\n\tpp = p - vec3(7, 1, 0);\n\tminH(vec2(cyl(pp - vec3(0, .3, 1.2), vec2(S01(2. - pp.y), .1) * .8), 5));\n\tw = .05 * step(p.y, 1.5);\n\td = box(pp, vec3(2. - w, .7, 1. - w));\n\tpp.x = abs(pp.x) - 1.5;\n\tpp.y += .7;\n\td = min(d, box(pp, vec3(.05, .2, .8)) - .1);\n\tminH(vec2(d, 8));\n\tpp = p.zxy;\n\tpp.x -= 4.1;\n\tpp.y -= 1.4;\n\td = length(pp.xy + vec2(.5, 5.1)) - .16 - .03 * step(abs(cos(pp.z)), .05);\n\tpp.z = abs(pp.z - .4) - .15;\n\td = min(d, link(pp, 4., .5, .1));\n\tp.z--;\n\tpp = p;\n\tw = S(15., 12., t) + S(23., 26., t);\n\tpp.x += pow(sin(w * 1.6), 4.);\n\tpp.z += S(.7, 0., abs(w * 1.7 - 1.) - .3) * .3;\n\tminH(vec2(pod(pp, true, w), 7));\n\td = min(d, pod(p, false, podd) * .9);\n\tw = .05 + abs(.01 * sin((p.y - abs(p.x)) * 36.));\n\tp.yz++;\n\td = min(min(d, link(p, .5, 1.5, w)), link(p, .5, 1.2, w));\n\tp.y -= 1.7;\n\tp.z -= .3;\n\td = max(min(d, max(max(tor(p, vec2(.9, .7)), -p.z), tor(p - vec3(0, -.7, 0), vec2(1)))), -podd - .06);\n\tminH(vec2(d, 6));\n\td = max(length(p.xz) - .4, abs(p.y + .6) - .01);\n\tminH(vec2(d, 0));\n\tw = 1.;\n\tif (t > 16.) {\n\t\tif (t < 19.) w = .001 + .02 * (.5 + .5 * sin(t * 6.));\n\t\telse if (t < 23.) w = step(fbm(vec3(1, 1, t * 10.)), .2);\n\t}\n\n\tg += .005 / (.1 + d * d * 1e2 * w);\n\treturn h;\n}\n\nvec3 N(vec3 p, float t) {\n\tfloat h = t * .2;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h).x;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat shadow(vec3 p, vec3 ld) {\n\tfloat i, h,\n\t      s = 1.,\n\t      t = .1;\n\tfor (i = Z0; i < 30.; i++) {\n\t\th = map(t * ld + p).x;\n\t\ts = min(s, 15. * h / t);\n\t\tt += h;\n\t\tif (s < .001 || t > 18.) break;\n\t}\n\n\treturn sat(s);\n}\n\nfloat ao(vec3 p, vec3 n, float h) { return map(h * n + p).x / h; }\n\nfloat fog(vec3 v) { return exp(dot(v, v) * -.002) * S(12., 6., v.y); }\n\nvec3 lights(vec3 p, vec3 rd, float d, vec2 h) {\n\tif (h.y == 1.) return vec3(.01);\n\tvec3 ld = normalize(vec3(2, 4, -1) - p),\n\t     n = N(p, d),\n\t     c = vec3(.2);\n\tfloat lig,\n\t      hs = 0.,\n\t      gg = g;\n\tif (h.y == 3.) c -= n31(p * .8) * .06;\n\telse if (h.y == 6.) c = vec3(.5 - .18 * n31(p * 26.)) * .3 * (1. + 6. * step(length(p - vec3(0, 1.5, 2)), 1.7));\n\telse if (h.y == 2.) c = mix(vec3(.04, .02, .02), vec3(.06, .04, .02), n21(p.xz * vec2(2.3, 30)));\n\telse if (h.y == 0.) c = vec3(1.2);\n\telse if (h.y == 4.) {\n\t\tc = vec3(.1, .2, .3) * (.24 - rd.y) * .6 + .01;\n\t\ths++;\n\t}\n\telse if (h.y == 5.) c = vec3(.15, .01, .02);\n\n\tfloat ao = mix(ao(p, n, 1.), ao(p, n, 2.), .7),\n\t      l1 = sat(.1 + .9 * dot(ld, n)) * (.3 + .7 * sat(hs + shadow(p, ld))) * (.3 + .7 * ao),\n\t      l2 = sat(.1 + .9 * dot(ld * vec3(-1, 0, -1), n)) * .3 + pow(sat(dot(rd, reflect(ld, n))), 10.),\n\t      fre = S(.7, 1., 1. + dot(rd, n)) * .5;\n\tlig = l1 + l2 * ao;\n\tg = gg;\n\treturn mix(lig * c * vec3(2, 1.6, 1.5), vec3(.01), fre);\n}\n\nvec4 march(inout vec3 p, vec3 rd, float s) {\n\tfloat i,\n\t      d = .01;\n\tg = 0.;\n\tvec2 h;\n\tfor (i = Z0; i < s; i++) {\n\t\th = map(p);\n\t\tif (abs(h.x) < .0015) break;\n\t\td += h.x;\n\t\tif (d > 25.) return vec4(0);\n\t\tp += h.x * rd;\n\t}\n\n\treturn vec4(g + lights(p, rd, d, h), h.y);\n}\n\nvec3 scene(vec3 rd) {\n\tvec3 p = vec3(0);\n\tp -= vec3(1, -2. + t * .0125, 5.5 - t / 40.);\n\tvec4 col = march(p, rd, 80.);\n\tcol.rgb *= fog(p);\n\tif (col.w >= 6.) {\n\t\tfloat lp = length(p);\n\t\tvec3 n = N(p, lp);\n\t\tif (col.w == 7.) {\n\t\t\trd = refract(rd, n, 1.);\n\t\t\tp -= n * .3;\n\t\t\tcol += march(p, rd, 32.) * fog(p);\n\t\t\tcol *= .5;\n\t\t\tn = N(p, lp);\n\t\t}\n\n\t\trd = reflect(rd, n);\n\t\tp += n * .01;\n\t\tcol += .1 * march(p, rd, 32.) * fog(p);\n\t}\n\n\treturn col.rgb;\n}\n\n#define rgba(col)\tvec4(pow(max(vec3(0), col), vec3(.45)) * sat(t), 0)\n\nvoid mainVR(out vec4 fragColor, vec2 fc, vec3 ro, vec3 rd) {\n\tt = mod(iTime, 40.);\n\trd.xz *= mat2(1, 0, 0, -1);\n\tfragColor = rgba(scene(rd));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tt = mod(iTime, 40.);\n\tvec2 q = fc.xy / R.xy,\n\t     uv = (fc - .5 * R.xy) / R.y;\n\tvec3 f = normalize(vec3(mix(.5, .33, S(1., 10., t)), 0, 1)),\n\t     r = normalize(cross(vec3(0, 1, 0), f)),\n         col = scene(normalize(f + r * uv.x + cross(f, r) * uv.y));\n\tcol *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\tfragColor = rgba(col);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}