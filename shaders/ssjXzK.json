{
    "Shader": {
        "info": {
            "date": "1620628938",
            "description": "click for new seeds. (better seen in fullscreen ).\nIt is the reference case for [url]https://shadertoy.com/view/ssBSRK[/url].\nWith present power-of-2 textures all is good, while it was not for ordinary buffers.",
            "flags": 0,
            "hasliked": 0,
            "id": "ssjXzK",
            "likes": 3,
            "name": "how MIPmap is wrong - refcubemap",
            "published": 3,
            "tags": [
                "glsl",
                "mipmap",
                "bug"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 378
        },
        "renderpass": [
            {
                "code": "// correct reference against \"how MIPmap is wrong\" by FabriceNeyret2. https://shadertoy.com/view/ssBSRK\n\n#define col(l)   m = T(U,l).w * float(1<<(2*l)); if (m > 0.01 ) O\n#define R        iResolution.xy\n\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U = (U-.5*R)/R.y; \n    if ( abs(U.x) > .5 ) { O = vec4(0); return; } // you don't want to see cubeMap sides ;-)\n    U = U*R+.5*R;\n    O = vec4( T(U,0).w );      // particles\n    float m;\n    \n#if 0                          // ( better with texelFetch )                       \n    col(4).g += .3;\n    col(5).r += .2 + .4* m;\n    col(6).b += .2 + .2* m;\n // col(4).g += m/2.; col(5).r += m/2.; col(6).b += m/2.; // cloud color scheme\n\n#else\n    col(4).g += .3;\n    col(5).r += .4;  // (.5+.5*cos(24.*m))*m*2.;\n    col(6).b += .5;\n // col(1).b -= .5;            // more LODs\n // col(2).r -= .4; \n // col(3).g -= .3;\n#endif\n\n// if (m>0.) O +=  ( .6 + .6 * cos( 6.3*(m/6.)  + vec4(0,23,21,0)  ) ) * (m>6. ? 1. : .5); // hue\n\n// O = T(U,0);                 // debug\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//#define R        iResolution.xy // bugged for cubeMaps\n\n#define T0(U,l)   textureLod( iChannel0, vec3((U)/R*2.-1.,1)*vec3(1,-1,1), float(l) )\n  #define T(U,l)  T0(U,l)                                              // using texture interpolation\n//#define T(U,l)  T0( floor( (U)/float(1<<l) ) * float(1<<l) +.5 , l ) // trying to emulate texelFetch array\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// .xy = particle coords  .w = density field : +1 at particle location then MIPmap\n\n#define hash2(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n#define R        vec2(1024) // bugged for cubeMaps\n\n\nvoid mainCubemap( out vec4 O, vec2 U, vec3 C, vec3 D )\n{\n        if (iFrame == 0 || iMouse.w > 0. ) {                  // --- initialization\n            O = vec4( hash2(U+iTime) *R ,  0,-1 );            // random coords\n            return;\n        }\n     // O = texture(iChannel1,U/R); return; // cubemap debug qualibration\n        \n        O = T(U,0);                                     // recover previous state\n        \n        if ( O.w < 0. ) {                                     // new coords not yet splated \n            O.w = 0.;\n            for ( float y = .5; y < .01*R.y; y++ )            // splat some particles on screen\n                for ( float x = .5; x < .01*R.x; x++ )\n                    if( floor(T(vec2(x,y),0).xy) == floor(U) )    // if point in pixel, splat \n                        { O.w++; return; }\n          }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            }
        ],
        "ver": "0.1"
    }
}