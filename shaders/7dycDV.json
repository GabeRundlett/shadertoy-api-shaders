{
    "Shader": {
        "info": {
            "date": "1655832377",
            "description": "Hex Directional Flow with a cyclone flow map and a Sinewave perpendicular to the Flow Vector like water waves",
            "flags": 0,
            "hasliked": 0,
            "id": "7dycDV",
            "likes": 28,
            "name": "Wind Waves of Cyclone using HDF",
            "published": 3,
            "tags": [
                "wave",
                "water",
                "hexagon",
                "sine",
                "hex",
                "gabor",
                "flowmap",
                "wind",
                "vectorfield",
                "viridis",
                "cyclone",
                "directionalflow"
            ],
            "usePreview": 0,
            "username": "gehtsiegarnixan",
            "viewed": 715
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright Â© 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nUpdate: I made a faster version using my Square Directional Flow \n(https://www.shadertoy.com/view/7ddBWl).\n\nThis is using my Hex Directional Flow algorithm \n(https://www.shadertoy.com/view/fsGyDG) with Sine waves instead of a texture.\nI also made a flowmap that is an aproximation of a tropical cyclone flowmap \n(https://www.shadertoy.com/view/fdKcWd). I wanted to aproximate the water wave height.\n\nI looked up the forumlas for the relationship between windspeed and waves, but the math\nis very complicated and I gave up. So I went for what looks alright \n(https://www.desmos.com/calculator/lewikf6y0f).\n\nThe easy water wave math can be found here \n(https://en.wikipedia.org/wiki/Dispersion_(water_waves)). Wikipeda explains the \nrelationship between water depth, wavelength and wave velocity \n(https://www.desmos.com/calculator/2nlmht2mmy). The amplitude and windspeed don't have\nsuch linear interaction, but there are formuals for observed wave spectra on the ocean\nafter long periods of steady wind (https://wikiwaves.org/Ocean-Wave_Spectra). I just can\nnot figure out how to solve for the wavespeed/wavelength for a give depth and windspeed.\nA single wave can be described by the gerstner formula \n(https://catlikecoding.com/unity/tutorials/flow/waves/), but I couldn't find how the wind\naffects the wave steepness and when exactly they break on the open sea. I found some\nhints here (http://hyperphysics.phy-astr.gsu.edu/hbase/Waves/watwav2.html) when they \nbreak. \n\nI played around with circular and straight waves, but the circular ones don't look \nthat different for how much more work they are. So I kept the straight waves, but see\ndD and cD to test for yourself.\n\nAnimating the flowmap also turned out to have some significant drawbacks. Since im sampling\na lower res hexagonal version leads to flickering waves, so you can only do it VERY slowly. \n*/\n\n#define pi              3.1415926536\n#define sqrtG           3.1320919527\n#define twoPi           6.2831853072\n#define sqrt3 \t\t\t1.7320508076 //sqrt(3)\n#define half_sqrt3\t\t0.8660254038 //sqrt(3)/2\n#define inv_sqrt3\t\t0.5773502693 // 1/sqrt(3)\n#define inv_twice_sqrt3\t0.2886751346 // 1/(2 sqrt(3))\n\n// if you want flat tops (hex rotated by 30deg) swap xy in hr and the p.x to p.y in hexDist\nconst vec2 r = vec2(1, sqrt3); // 1, sqrt(3)\nconst vec2 h = vec2(0.5,half_sqrt3); // 1/2, sqrt(3) /2\n\n// Hexagonal Distanstance from the 0,0 coords\nfloat hexDist(vec2 p) {\n\tp = abs(p);   \n    return max(dot(p, h), p.x);\n}\n\n// struct to fill with needed HexTile Parametes\nstruct hexParams {\n  vec2 gv;\n  vec2 id;\n  float edist;\n};\n\n// From BigWIngs \"Hexagonal Tiling\" https://www.shadertoy.com/view/3sSGWt\nhexParams hexTile(vec2 uv) {   \n    vec2 a = mod(uv, r)-h;\n    vec2 b = mod(uv-h, r)-h;    \n    vec2 gv = dot(a, a) < dot(b,b) ? a : b; //center hex UV coords\n    \n    // float edist = .5-hexDist(gv);  // Edge distance.\n    float edist = (.5-hexDist(gv))*2.; //  Edge distance with range 0-1\n    // float cdist = dot(gv, gv); // squared distance from the center.\n    // float cdist = dot(gv, gv)*3.; // squared distance with range 0-1\n    vec2 id = uv-gv; // simple ID calculation\n    \n    return hexParams(gv,id,edist); // xy hex coords + z distance to edge\n}\n\n// makes viridis colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 viridis(float t) {\n    const vec3 c0 = vec3(0.274344,0.004462,0.331359);\n    const vec3 c1 = vec3(0.108915,1.397291,1.388110);\n    const vec3 c2 = vec3(-0.319631,0.243490,0.156419);\n    const vec3 c3 = vec3(-4.629188,-5.882803,-19.646115);\n    const vec3 c4 = vec3(6.181719,14.388598,57.442181);\n    const vec3 c5 = vec3(4.876952,-13.955112,-66.125783);\n    const vec3 c6 = vec3(-5.513165,4.709245,26.582180);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n//shifts value range from -1-1 to 0-1\nfloat make0to1(float x) {\n    return (1.0 + x) / 2.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 makeM1to1(vec2 x) {\n    return (x - 0.5) * 2.0;\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time) {  \n    float size = 1./(1.4 * sqrt(radius)); // of the entire cyclone\n    float curl = 2.5; // kind of arbitrary but between 1-3.5 looks good\n    float hole = 1./(4.*size); // also kind of arbitrary\n    \n    //point += vec2(cos(time),sin(time))*0.1*hole; //rotating center\n    \n    float angle = atan(point.y, point.x); //angle around center\n    float dist = length(point); // distance to point\n    float spiral = fract(dist/radius + (angle-time)/twoPi);\n    \n    //right slanted donut https://www.desmos.com/calculator/ocm71awnym\n    spiral -= 1.212;\n    spiral = 1.+ (pow(1.57*(spiral)+0.8,2.)/spiral);\n        \n    float flowAngle = pi + angle -(dist*curl) -(spiral*0.8);\n    \n    // left slanted donut https://www.desmos.com/calculator/uxyefly7fi\n    float spiralStrength = 0.05;\n    float mask = (1. - spiralStrength)-(pow(dist*size-hole, 2.0)/dist);\n    mask += spiral*spiralStrength; \n    mask = clamp(mask, 0.0, 1.0);  // saturate\n    \n    vec2 flow = normalize(vec2(cos(flowAngle),sin(flowAngle)));\n    flow *= mask; // apply strength mask\n    \n    //flow = (flow+1.0)/2.0; // to save as texture\n    flow += vec2(0.0001,0.0001); //adding tiny offset so it isnt 0\n    return flow;\n}\n\n// generates pixelated directional waves\nfloat flowHexCell(vec2 uv, vec2 offset, float gridRes, float time, float len) {    \n    hexParams hexValues = hexTile(uv * gridRes + offset); \n    hexValues.gv =  hexValues.gv / gridRes;\n    hexValues.id = (hexValues.id - offset)/ gridRes;    \n    \n    float radius = 0.3; // of the first spiral \n    //cyclone like flowmap\n    vec2 flowMap = cycloneFlow(hexValues.id - vec2(0.885, 0.5), radius, time*0.2);    \n    \n    float speed = length(flowMap); // Wind Speed    \n    vec2 dir = normalize(flowMap); // Wind Direction    \n    len *= pow(speed,0.5); // make slower waves smaller\n    float k = twoPi / len; //Wave Number    \n    float a = pow(speed,1.5); //Amplitude \n    float s = speed; //Steepness\n    time *= sqrtG * sqrt(len); // deep water speed\n    \n    float dD = dot(uv,dir); //Directional/Straight Wave\n    //float cD = length(hexValues.gv + (dir/(gridRes))); //Circular Wave\n    \n    //add random phase offsets for even FlowMaps or you get interference\n    //time += texture( iChannel0, hexValues.id).x;\n    \n    float wave = make0to1(sin(k * (dD - time))); // make sin wave\n    //wave = (1.- pow(wave, (1.-s/2.))); //cheap gerstner height wave aprox\n    \n    wave *= a * hexValues.edist; // apply amplitue and alpha mask    \n    return wave;\n}\n\n// 3 hex pixaled flowing sin thier edges get hidden by each other\nfloat triDirectionalFlow(vec2 uv, float gridRes, float time, float len) {\n    float a = flowHexCell(uv, vec2(0.,0.), gridRes, time, len);\n    float b = flowHexCell(uv, vec2(0,inv_sqrt3), gridRes, time, len);\n    float c = flowHexCell(uv, vec2(0.5,inv_twice_sqrt3), gridRes, time, len);\n\n    return a + b + c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float gridRes = 32.0; //Hex Grid Resolution\n    float waveLen = 1./ (gridRes * 3.0); // Maximum Sin Wave Length\n    float time = iTime * 0.05; // flow speed multiplier\n    \n    vec2 uv = fragCoord/iResolution.y; //square UVs  \n    float wave = triDirectionalFlow(uv,gridRes,time, waveLen);\n    \n    vec3 col = vec3(viridis(wave));\n    fragColor = vec4(col,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}