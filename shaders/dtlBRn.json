{
    "Shader": {
        "info": {
            "date": "1692638484",
            "description": "This shows a simple scene that demonstrates how to find the closest point to the surface of an SDF. The blue spheres are the \"search\" points and the red spheres are the closest points.\n\nNote the little dents in the SDF are just for visualization. :)\n\n",
            "flags": 0,
            "hasliked": 0,
            "id": "dtlBRn",
            "likes": 12,
            "name": "Closest Point to SDF",
            "published": 3,
            "tags": [
                "raymarching",
                "sdf"
            ],
            "usePreview": 0,
            "username": "tristanantonsen",
            "viewed": 297
        },
        "renderpass": [
            {
                "code": "// Ray marching constants\n#define MAX_STEPS 250\n#define SURF_DIST 0.0001\n#define MAX_DIST 100.0\n#define PI 3.141592653592\n#define TAU 6.283185307185\n\n\n////////////////////////////////////////////////////////////////\n// Signed Distance Functions\n// iquilezles.org/articles/distfunctions\n////////////////////////////////////////////////////////////////\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  return dot(p,normalize(n)) + h;\n}\n\nfloat sdSphere( vec3 p, vec3 c, float r )\n{\n    return length(p-c) - r;\n}\n\nfloat sdEllipsoid( vec3 po, vec3 c, vec3 r )\n{\n    vec3 p = po-c;\n\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdRoundedBox(vec3 p, vec3 s, float r) {\n    p = abs(p)-(s-r);\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.) - r;\n}\n\n////////////////////////////////////////////////////////////////\n// SDF Operations\n////////////////////////////////////////////////////////////////\n\nfloat opUnion(float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction(float d1, float d2) {\n    //NOTE: Flipped order because it makes more sense to me\n    return max(-d2, d1);\n}\nfloat opIntersection(float d1, float d2) {\n    return max(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d1, -d2, h ) + k*h*(1.0-h);\n}\nfloat opSmoothIntersection(float d1, float d2, float k){\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n////////////////////////////////////////////////////////////////\n// Rotations\n////////////////////////////////////////////////////////////////\n\nvec3 rotX(vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat3 m = mat3(\n        1., 0., 0.,\n        0., c, -s,\n        0., s, c\n        );\n    return m * p;\n}\n\nvec3 rotY(vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat3 m = mat3(\n        c, 0., s,\n        0., 1., 0.,\n        -s, 0., c\n        );\n    return m * p;\n}\n\nvec3 orbitControls(vec3 po) {\n    vec2 m = (vec2(iMouse.x, iMouse.y) / iResolution.xy) + 0.5;\n    vec3 p = po;\n    p = rotY(po, -m.x*TAU - PI);\n    //p = rotX(p, -m.y*PI - PI / 2.0);\n    return p;\n}\n\n\n////////////////////////////////////////////////////////////////\n// Ray Marching Functions\n////////////////////////////////////////////////////////////////\n\nvec2 sdf(vec3 po) {\n\n    // rotation\n    vec3 p = rotX(po, 0.5*iTime);\n    p = rotY(p, 0.5*iTime);\n\n    // main\n    float s1 = sdEllipsoid(p, vec3(0., -0., 0.),vec3(0.9, 0.85, 0.9));\n    float b1 = sdRoundedBox(p, vec3(0.5), 0.05);\n\n    float d = mix(s1, b1, 0.5*sin(iTime)+0.5);\n    vec2 res = vec2(d, 1.0); // id to track color\n    return res;\n}\n\nvec3 gradientSDF(vec3 p) {\n    float epsilon = 0.0001;\n    vec3 dx = vec3(epsilon, 0., 0.0);\n    vec3 dy = vec3(0., epsilon, 0.0);\n    vec3 dz = vec3(0., 0.0, epsilon);\n\n    float ddx = sdf(p + dx).x - sdf(p - dx).x;\n    float ddy = sdf(p + dy).x - sdf(p - dy).x;\n    float ddz = sdf(p + dz).x - sdf(p - dz).x;\n    \n    return normalize(vec3(ddx, ddy, ddz));\n}\n\nvec2 map(vec3 po) {\n    // Mouse\n    vec2 m = (2.*iMouse.xy-iResolution.xy)/iResolution.y;  \n    vec3 p = orbitControls(po);\n    vec3 pSym = vec3(abs(p.x), p.y, p.z);\n    vec2 res;\n    res.y = 1.;\n\n    // main sdf (light blue)\n    // this is what the \"closest points\" are in reference to\n    res = sdf(p);\n    \n    // Creating some points orbiting semi-randomly around the sdf\n    float offset = 1.5; // search point distance from origin\n    \n    // Point 1\n    float x1 = offset * cos(2.*iTime);\n    float z1 = offset * sin(2.*iTime);\n    vec3 sP1 = vec3(x1, 1.*sin(iTime), z1);\n    // translation vector v = -d * n; d = sdf value @ point, n = gradient @ point\n    vec3 cP1 = -sdf(sP1).x * gradientSDF(sP1) + sP1; // this is the line that finds the closest points\n    float s1 = sdSphere(p, sP1, 0.075);\n    float c1 = sdSphere(p, cP1, 0.05);\n\n    // Point 2\n    float x2 = offset * sin(2.*iTime);\n    float z2 = offset * cos(2.*iTime);\n    vec3 sP2 = vec3(x2, 1.*cos(iTime), z2);\n    vec3 cP2 = -sdf(sP2).x * gradientSDF(sP2) + sP2;\n    float s2 = sdSphere(p, sP2, 0.075);\n    float c2 = sdSphere(p, cP2, 0.05);\n    \n    // Point 3\n    float x3 = offset * sin(2.*iTime+PI/2.);\n    float z3 = offset * sin(2.*iTime-PI/2.);\n    vec3 sP3 = vec3(x3, 1.*cos(iTime), z3);\n    vec3 cP3 = -sdf(sP3).x * gradientSDF(sP3) + sP3;\n    float s3 = sdSphere(p, sP3, 0.075);\n    float c3 = sdSphere(p, cP3, 0.05);\n    \n    // Connectors (red)\n    float rc = 0.005; // connector radius\n    float l1 = sdCapsule(p, sP1, cP1, rc);\n    float l2 = sdCapsule(p, sP2, cP2, rc);\n    float l3 = sdCapsule(p, sP3, cP3, rc);\n    \n    // final visualization/adding to the SDF\n    res.x = opSmoothSubtraction(res.x, c1, 0.05);\n    res.x = opSmoothSubtraction(res.x, c2, 0.05);\n    res.x = opSmoothSubtraction(res.x, c3, 0.05);\n\n    // creating a body consisting of the \"search point\" spheres\n    float searchPoints = s1;\n    searchPoints = opUnion(searchPoints, s2);\n    searchPoints = opUnion(searchPoints, s3);\n    \n    // creating a body consisting of the \"closest point\" spheres\n    float closestPoints = c1;\n    closestPoints = opUnion(closestPoints, c2);\n    closestPoints = opUnion(closestPoints, c3);\n    \n    float connectors = l1;\n    connectors = opSmoothUnion(connectors, l2, 0.01);\n    connectors = opSmoothUnion(connectors, l3, 0.01);\n    \n    // adding to the sdf & assigning colors\n    \n    if (searchPoints < res.x) res.y = 2.0;\n    res.x = opUnion(res.x, searchPoints);\n    if (closestPoints < res.x) res.y = 3.0;    \n    res.x = opUnion(res.x, closestPoints);\n    if (connectors < res.x) res.y = 4.0;    \n    res.x = opUnion(res.x, connectors);\n    \n    return res;\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd) {\n    float d = 0.0;\n    float mat = 1.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        if (i >= MAX_STEPS ) break;\n        vec3 p = ro + rd * d;\n        vec2 ds = map(p);\n        d += ds.x;\n        mat = ds.y;\n        if (d >= MAX_DIST || ds.x < SURF_DIST) break;\n        i++;\n    }\n    return vec2(d, mat);\n}\n\nvec3 gradient(vec3 p) {\n    float epsilon = 0.0001;\n    vec3 dx = vec3(epsilon, 0., 0.0);\n    vec3 dy = vec3(0., epsilon, 0.0);\n    vec3 dz = vec3(0., 0.0, epsilon);\n\n    float ddx = map(p + dx).x - map(p - dx).x;\n    float ddy = map(p + dy).x - map(p - dy).x;\n    float ddz = map(p + dz).x - map(p - dz).x;\n    \n    return normalize(vec3(ddx, ddy, ddz));\n}\n\nvec3 rayDirection(vec2 p, vec3 ro, vec3 rt) {\n\n    // screen orientation\n    vec3 vup = vec3(0., 1.0, 0.0);\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    vec3 vw = normalize(ro - rt);\n    vec3 vu = normalize(cross(vup, vw));\n    vec3 vv = cross(vw, vu);\n    float theta = radians(30.); // half FOV\n    float viewport_height = 2. * tan(theta);\n    float viewport_width = aspectRatio * viewport_height;\n    vec3 horizontal = -viewport_width * vu;\n    vec3 vertical = viewport_height * vv;\n    float focus_dist = length(ro - rt);\n    vec3 center = ro - vw * focus_dist;\n\n    vec3 rd = center + p.x * horizontal + p.y * vertical - ro;\n\n    return normalize(rd);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord / iResolution.xy - 0.5) * 2.0; // normalizing\n\n    // Ray Marching\n    vec3 rt = vec3(0., -0.05, -1.);\n    vec3 ro = vec3(0., -0.05, -10.02);\n\n    vec3 rd = rayDirection(uv, ro, rt);\n    vec2 d = rayMarch(ro, rd);\n\n    // Background\n    float v = length(uv) * .75;\n    fragColor = vec4(0.1,0.7,1.,1.);\n    fragColor += vec4(mix(0.2, 0.4, smoothstep(0.0, 1.0, uv.y)));\n    fragColor += vec4(mix(0.2, 0.4, smoothstep(0.0, 1.0, uv.x)));\n    \n\n    if (d.x <= 100.0) {\n        vec3 p = ro + rd * d.x;\n        vec3 pr = orbitControls(p);\n        vec3 N = gradient(p);\n        float light1 = dot(N, normalize(vec3(1, 1,-1)))*.5+.5;\n        float light2 = dot(N, normalize(vec3(-1, 1,-1)))*.5+.5;\n        vec3 illumination = 0.5 * vec3(light1) + 0.5 * vec3(light2);\n        vec3 c1 = vec3(0.2,0.8,1.);\n        vec3 c2 = vec3(0.8,0.2,1.);\n        \n        vec3 color = c1;\n        \n        if (d.y == 1.) color.xyz = c1;        \n        if (d.y == 2.) color.xyz = vec3(0.2, 0.2, 0.9);        \n        if (d.y == 3.) color.xyz = vec3(1., 0., 0.);        \n        if (d.y == 4.) color.xyz = vec3(1., 0., 0.);        \n        \n        \n        \n        color *= illumination; \n\n        // Specular highlights\n        vec3 R = reflect(normalize(vec3(1.,0.,0.)), N);\n        vec3 specular = vec3(1.0) * pow(max(dot(R, rd), 0.0),10.0);\n                \n        // fake fresnel\n        float nDotV = dot(N, rd) + 1.;\n        color += nDotV * nDotV * 0.45 + specular * 0.08;\n        \n        \n        fragColor = vec4(color, 1.0);\n        \n    }\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}