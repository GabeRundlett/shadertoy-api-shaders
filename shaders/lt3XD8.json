{
    "Shader": {
        "info": {
            "date": "1479360494",
            "description": "Combining techniques like normal-based edging, bump mapping and bump-based edging to produce a detailed looking surface without the high cost.",
            "flags": 0,
            "hasliked": 0,
            "id": "lt3XD8",
            "likes": 61,
            "name": "Twisted Geometry",
            "published": 3,
            "tags": [
                "tunnel",
                "raymarch",
                "bump",
                "edges",
                "geometric",
                "twist"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 4881
        },
        "renderpass": [
            {
                "code": "/*\n\n\tTwisted Geometry\n\t----------------\n\n\tCombining techniques like normal-based edging, bump mapping and bump-based edging to \n    produce a detailed looking surface without the high cost.\n\n\tAs I'm sure everyone knows, adding fine detail to surfaces via the distance funtion \n    can slow things down considerably, but you can get around that by raymarcing the general \n    scene and bump mapping the details, which is what I'm doing here.\n\n\tThe downside is that normal based edging only picks up on the raymarched portion. \n    However, it's also possible to perform bump-based edging. Therefore, by combining the \n    two, you can produce a stylized, cartoonish look without the high cost.\n\n*/\n\n// Maximum ray distance.\n#define FAR 30. \n\n// Amount of object twisting about the Z-axis.\n#define ZTWIST .5 \n\n// Comment this out to omit the detailing. Basically, the bump mapping won't be included.\n#define SHOW_DETAILS\n\n// Object ID, used for the gold trimming in the bump mapping section.\nfloat svObjID;\n\n\n// 2D rotation. Always handy. Angle vector, courtesy of Fabrice.\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n// Smooth minimum. Courtesy of IQ.\nfloat sminP( float a, float b, float smoothing ){\n\n    float h = clamp((b-a)/smoothing*.5 + .5, 0., 1.);\n    return mix(b, a, h) - smoothing*h*(1. - h);\n}\n\n// Standard lattice variation, of which there are infinitely many.\nfloat lattice(vec3 p){\n \n\n    // Repeat field entity one, which is just some square tubes repeated in all directions \n    // every two units, then combined with a minimum function. Otherwise known as a lattice.\n    p = abs(mod(p, 2.) - 1.);\n\tfloat x1 = min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - .32;\n    \n\n    // Repeat field entity two, which is just an abstract object repeated every half unit. \n    p = abs(mod(p,  .5) - .25);\n    float x2 = min(p.x, min(p.y, p.z));\n    \n    svObjID = step(x2, x1);\n\n    // Combining the two entities above.\n    return max(x1, x2) - .05;    \n    \n}\n\n// For all intents and purposes, this is a twisty lattice smoothly bounded by a square \n// tube on the outside. I have a million different shaders based on this concept alone, \n// but I won't bore you with them. Instead, Dila and Aiekick have some pretty good examples \n// on Shadertoy making use of it that are worth looking at.\nfloat map(vec3 p){\n\n    // Twist the scene about the Z-axis. It's an old trick. Put simply, you're\n    // taking a boring scene object and making it more interesting by twisting it. :)\n    p.xy *= rot(p.z*ZTWIST);\n    \n    // Produce a repeat object. In this case, just a simple lattice variation.\n    float d =  lattice(p); \n    \n    // Bound the lattice on the outside by a boxed column (max(abs(x), abs(y)) - size) \n    // and smoothly combine it with the lattice. Note that I've perturbed it a little \n    // by the lattice result (d*.5) in order to add some variation. Pretty simple.\n    p = abs(p);\n    d = sminP(d, -max(p.x, p.y) + 1.5 - d*.5, .25);\n     \n    return d*.7;\n}\n\n// Raymarching.\nfloat trace(vec3 ro, vec3 rd){\n\n    float t = 0., d;\n    for (int i=0; i<80; i++){\n\n        d = map(ro + rd*t);\n        if(abs(d)<.001*(t*.125 + 1.) || t>FAR) break;\n        t += d;\n    }\n    return min(t, FAR);\n}\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D channel, vec3 p, vec3 n){\n    \n    // Matching the texture rotation with the object warping. Matching transformed texture \n    // coordinates can be tiring, but it needs to be done if you want things to line up. :)\n    p.xy *= rot(p.z*ZTWIST); \n    n.xy *= rot(p.z*ZTWIST); \n    \n    n = max(abs(n) - .2, 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(channel, p.yz).xyz;\n    vec3 ty = texture(channel, p.xz).xyz;\n    vec3 tz = texture(channel, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like \n    // that. :) Once the final color value is gamma corrected, you should see correct \n    // looking colors.\n    return tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n}\n\n// The bump mapping function.\nfloat bumpFunction(in vec3 p){\n    \n    // Matching the rotation in the distance function. Comment it out, and you'll see\n    // why it's needed.\n    p.xy *= rot(p.z*ZTWIST); \n    \n    // A reproduction of the lattice at higher frequency. Obviously, you could put\n    // anything here. Noise, Voronoi, other geometrical formulas, etc.\n    return min(abs(lattice(p*4.))*1.6, 1.);\n   \n   \n}\n\n// Standard function-based bump mapping function with some edging thrown into the mix.\nvec3 doBumpMap(in vec3 p, in vec3 n, float bumpfactor, inout float edge){\n    \n    // Resolution independent sample distance... Basically, I want the lines to be about\n    // the same pixel with, regardless of resolution... Coding is annoying sometimes. :)\n    vec2 e = vec2(2./iResolution.y, 0); \n    \n    float f = bumpFunction(p); // Hit point function sample.\n    \n    float fx = bumpFunction(p - e.xyy); // Nearby sample in the X-direction.\n    float fy = bumpFunction(p - e.yxy); // Nearby sample in the Y-direction.\n    float fz = bumpFunction(p - e.yyx); // Nearby sample in the Y-direction.\n    \n    float fx2 = bumpFunction(p + e.xyy); // Sample in the opposite X-direction.\n    float fy2 = bumpFunction(p + e.yxy); // Sample in the opposite Y-direction.\n    float fz2 = bumpFunction(p + e.yyx);  // Sample in the opposite Z-direction.\n    \n     \n    // The gradient vector. Making use of the extra samples to obtain a more locally\n    // accurate value. It has a bit of a smoothing effect, which is a bonus.\n    vec3 grad = vec3(fx - fx2, fy - fy2, fz - fz2)/(e.x*2.);  \n    //vec3 grad = (vec3(fx, fy, fz ) - f)/e.x;  // Without the extra samples.\n\n\n    // Using the above samples to obtain an edge value. In essence, you're taking some\n    // surrounding samples and determining how much they differ from the hit point\n    // sample. It's really no different in concept to 2D edging.\n    edge = abs(fx + fy + fz + fx2 + fy2 + fz2 - 6.*f);\n    edge = smoothstep(0., 1., edge/e.x);\n    \n    // Some kind of gradient correction. I'm getting so old that I've forgotten why you\n    // do this. It's a simple reason, and a necessary one. I remember that much. :D\n    grad -= n*dot(n, grad);          \n                      \n    return normalize(n + grad*bumpfactor); // Bump the normal with the gradient vector.\n\t\n}\n\n// The normal function with some edge detection rolled into it. Sometimes, it's possible \n// to get away with six taps, but we need a bit of epsilon value variance here, so there's \n// an extra six.\nvec3 nr(vec3 p, inout float edge, float t){ \n\t\n    // Larger epsilon for greater sample spread, thus thicker edges.\n    vec2 e = vec2(2./iResolution.y, 0); \n    \n    // Take some distance function measurements from either side of the hit point on all \n    // three axes.\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p)*2.;\t// The hit point itself - Doubled to cut down on calculations.\n     \n    // Edges - Take a geometry measurement from either side of the hit point. Average them, \n    // then see how much the value differs from the hit point itself. Do this for X, Y and \n    // Z directions. Here, the sum is used for the overall difference, but there are other \n    // ways. Note that it's mainly sharp surface curves that register a discernible \n    // difference.\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = max(max(abs(d1 + d2 - d), abs(d3 + d4 - d)), abs(d5 + d6 - d)); // Etc.\n    \n    // Once you have an edge value, it needs to normalized, and smoothed if possible. \n    // How you do that is up to you. This is what I came up with for now, but I might tweak \n    // it later.\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n\t\n    // Redoing the calculations for the normal with a more precise epsilon value.\n    e = vec2(.005*min(1. + t, 5.), 0);\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx); \n    \n    // Return the normal.\n    // Standard, normalized gradient mearsurement.\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cao(in vec3 p, in vec3 n){\n\t\n    float sca = 1., occ = 0.;\n    for(float i=0.; i<5.; i++){\n    \n        float hr = .01 + i*.5/4.;        \n        float dd = map(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - occ, 0., 1.);    \n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with \n// limited iterations is impossible... However, I'd be very grateful if someone could \n// prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on \n    // my slow test machine, anyway.\n    const int maxIterationsShad = 20; \n    \n    vec3 rd = (lp-ro); // Unnormalized direction ray.\n\n    float shade = 1.0;\n    float dist = 0.05;    \n    float end = max(length(rd), 0.001);\n    //float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. \n    // Obviously, the lowest number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Thanks to IQ for this tidbit.\n        //So many options here: \n        // dist += clamp( h, 0.0005, 0.2 ), dist += min( h, stepDist ), etc.\n        dist += clamp(h, 0.01, 0.2);\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0.001 || dist > end) break; \n    }\n\n    // Capping the final value.\n    return max(shade, 0.); \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Screen cooridinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\n    // Ray origin and unit direction vector.\n    vec3 ro = vec3(0, 0, iTime);\n    vec3 rd = normalize(vec3(uv, .6));\n    \n    /*\n    // Sinusoidal camera warp. Really cool effect, but probably a little too much \n    // warping for this scene. Even so, try it out, if you get bored enough. :)\n    float xAxis = uv.x*3.14159; // Better in vector form, but more readable like this.\n    float yAxis = uv.y*3.14159;\n    xAxis *= 1.;\n    yAxis *= .7;\n\trd = (vec3(sin(xAxis)*cos(yAxis), sin(yAxis), cos(xAxis)*cos(yAxis)));\n    */\n    \n    // Cheap look around.\n    rd.xy *= rot(iTime/4.);\n    rd.xz *= rot(iTime/4.);\n    \n    // Point light, near the camera.\n    vec3 lp = ro + vec3(0, .25, .25);\n    \n    // Raymarch.\n    float t = trace(ro, rd);\n    \n    // Surface hit point.\n    vec3 sp = ro + rd*t;\n    \n    // Normal with edge component.\n    float edge;\n    vec3 sn = nr(sp, edge, t);\n    \n    // Shadows and ambient self shadowing.\n    float sh = softShadow(sp, lp, 16.); // Soft shadows.\n    float ao = cao(sp, sn); // Ambient occlusion.\n    \n    // Light direction vector setup and light to surface distance.\n    lp -= sp;\n    float lDist = max(length(lp), .0001);\n    lp /= lDist;\n    \n    // Attenuation.\n    float atten = 1. / (1.0 + lDist*lDist*.2);\n    \n    // Texturing the object.\n    vec3 tx = tex3D(iChannel0, sp, sn);\n    tx = smoothstep(0.05, .5, tx); // Giving it a bit more brightness and contrast.\n    \n    // Alternative, textureless pattern. Not really for me.\n    //float pat = clamp(cos(bumpFunction(sp)*3.14159*6.)*2. + .75, 0., 1.);\n    //tx = mix(vec3(.15), vec3(1), pat);\n   \n    // Heavy bump. We do this after texture lookup, so as not to disturb the normal too much.\n    float edge2 = 0.;\n    #ifdef SHOW_DETAILS\n    sn = doBumpMap(sp, sn, .125/(1. + t/FAR), edge2);    \n    \n    // If the bump object ID is flagged, color it gold.\n    if(svObjID < .5) tx *= vec3(1.5, .85, .25);\n    #endif\n    \n    // Applying the normal-based and bump mapped edges.\n    tx *= (1.-edge*.7)*(1.-edge2*.7);\n    \n    // Diffuse, specular and Fresnel.\n    float dif = max(dot(lp, sn), 0.);\n    dif = pow(dif, 4.)*0.66 + pow(dif, 8.)*0.34; // Ramping up the diffuse.\n    float spe = pow(max(dot(reflect(rd, sn), lp), 0.), 6.);\n    float fre = pow(clamp(dot(rd, sn) + 1., 0., 1.), 4.);\n    \n    \n    // Combining the terms above to produce the final color.\n    vec3 fc = tx *(dif*sh*1.5 + .3 + vec3(.5, .7, 1)*fre*sh*4.) + vec3(1, .7, .3)*spe*sh*3.;\n    fc *= atten*ao;\n    \n    // Mixing in some blueish fog.\n    vec3 bg = mix(vec3(.4, .6, 1), vec3(.7, .9, 1), rd.y*.25+.25);\n    fc = mix(bg, fc, 1./(1. + t*t*.015));\n    \n    \n    // Post processing. Contrast, coloring.\n    //fc = fc*.5 + vec3(1.2, 1.05, .9)*pow(max(fc, 0.), vec3(1, 1.2, 1.5))*.5; \n    \n    // Uncomment this to see the AO and the scene without the bump detailing.\n    //fc = vec3(ao); \n    \n    // Approximate gamma correction.\n\tfragColor = vec4(sqrt(clamp(fc, 0., 1.)), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}