{
    "Shader": {
        "info": {
            "date": "1667783498",
            "description": "A procedural sea creature. It's a recursive/fractal SDF, rendered with raymarching. Info: [url]https://iquilezles.org/articles/raymarchingdf/[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "csB3zy",
            "likes": 210,
            "name": "Sea Creature",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "raymarching",
                "distancefield",
                "sea",
                "sdf",
                "ocean",
                "creature"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 9370
        },
        "renderpass": [
            {
                "code": "// Copyright Inigo Quilez, 2022 - https://iquilezles.org/\n// I am the sole copyright owner of this Work. You cannot host, display, distribute\n// or share this Work neither as it is or altered, on Shadertoy or anywhere else,\n// in any form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot sell this\n// Work, mint an NFTs of it or train a neural network with it without my permission.\n// I share this Work for educational purposes, and you can link to it through an URL\n// with proper attribution and unmodified art. If these conditions are too\n// restrictive contact me and we'll definitely work it out.\n\n\n// I made this after I saw leon's shader for the Inercia Shader Royale 2022\n// (https://www.shadertoy.com/view/md2GDD), not because of any particular reason\n// (KIFS fractals are very popular and I've done my share\n// https://www.shadertoy.com/view/lssGRM and https://www.shadertoy.com/view/4sX3R2)\n// but because sometimes you just see something pretty and that inspires to\n// attempt doing something on your own too.\n//\n// I'm using smooth-minimum and smooth-abs to blend all spheres together into a\n// single organic shape. The rest is color tweaking.\n//\n// The shader runs slow because I'm doing volumetric rendering so I get some sweet\n// transparencies. With regular raymarching this runs at 60 fps in a full screen,\n// but as usual I'm okey with doing something 4x slower if that makes it look\n// 10% better!\n\n\n// https://iquilezles.org/articles/intersectors/\nvec2 sphIntersect( in vec3 ro, in vec3 rd, float ra )\n{\n\tfloat b = dot( ro, rd );\n\tfloat c = dot( ro, ro ) - ra*ra;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n    h = sqrt(h);\n\treturn vec2(-b-h,-b+h);\n}\n\n// https://iquilezles.org/articles/smin/\nvec4 smin( vec4 a, vec4 b, float k )\n{\n    float h = max( k-abs(a.x-b.x), 0.0 )/k;\n    float m = h*h*0.5;\n    float s = m*k*0.5;\n    vec2 r = (a.x<b.x) ? vec2(a.x,m) : vec2(b.x,1.0-m);\n    return vec4(r.x-s, mix( a.yzw, b.yzw, r.y ) );\n}\n\n// https://iquilezles.org/articles/functions/\nfloat sabs( float x, float k )\n{\n    return sqrt(x*x+k);\n}\n\nvec2 rot( vec2 p, float a )\n{\n    float co = cos(a);\n    float si = sin(a);\n    return mat2(co,-si,si,co) * p;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.0, cos(cr),sin(cr));\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n//======================================================================\n// creature\n//======================================================================\n\n// euclidean distance to creature, and color at closest point\nvec4 map( in vec3 p, float time )\n{\n    float d1 = 0.10*sin(-time*6.283185/8.0 +  3.0*p.y); // animate body\n    float d2 = 0.05*sin( time*10.0         + 60.0*p.y); // animate flagellum\n\n    vec4 dcol = vec4(1e20,0.0,0.0,0.0);\n    float sc = 1.0;\n    for( int i=0; i<20; i++ )\n    {\n        // rotate coords\n        p.xz = rot(p.xz, 17.0*sc + d1*smoothstep( 5.0, 1.0,float(i))); // body\n        p.yz = rot(p.yz, -1.0*sc + d2*smoothstep(10.0,12.0,float(i))); // flagellum\n        \n        // smooth mirror and translate coords\n        p.x = sabs(p.x,0.0001*sc) - 0.22*sc;\n\n        // distance\n        float d = (i==19) ? length(p*vec3(1.0,1.0,0.1)) - 0.1*sc :\n                            length(p) - (0.1*sc + 0.001*sc*sin(2000.0*p.y*sc));\n        // color\n        vec3 c = (i==9) ? vec3(0.75) :\n                          vec3(0.4,0.2,0.2) + vec3(0.1,0.5,0.6)*float(i)/20.0 + 0.1*cos(vec3(0,1,2)-p*10.0);\n\n        // blend in distance and color\n        dcol = smin(dcol, vec4(d,c), 0.12*sc);\n    \n        // scale coords for next iteration\n        sc /= 1.2;\n    }\n    \n    return dcol;\n}\n\n// https://iquilezles.org/articles/nvscene2008/rwwtt.pdf\nfloat calcAO( in vec3 pos, in vec3 nor, in float time )\n{\n\tfloat occ = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        float h = 0.01 + 0.4*float(i)/7.0;\n        vec3  w = normalize( nor + normalize(sin(float(i)+vec3(0,2,4))));\n        float d = map( pos + h*w, time ).x;\n        occ += h-d;\n    }\n    return clamp( 1.0 - 0.71*occ, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, float dis, in float time )\n{\n    const vec2 e = vec2(0.001,0.0);\n    return normalize( vec3( map( pos + e.xyy, time ).x,\n                            map( pos + e.yxy, time ).x,\n                            map( pos + e.yyx, time ).x)-dis );\n}\n\n//======================================================================\n// CITA - Crap In The Air\n//======================================================================\n\n// a 3D dithered grid of spheres\nvec4 mapCITA( in vec3 pos, in float time )\n{\n    pos.y += time*0.02;\n\n    const float rep = 1.5;\n    vec3 ip = floor(pos/rep);\n    vec3 fp = fract(pos/rep);\n    vec3 op = vec3( (fp.x<0.0)?-1.0:0.0, (fp.y<0.0)?-1.0:0.0, (fp.z<0.0)?-1.0:0.0 );\n    \n    // note we only need to check 8 cells, not 27\n    vec4 dr = vec4(1e20);\n    for( int i=0; i<2; i++ )\n    for( int j=0; j<2; j++ )\n    for( int k=0; k<2; k++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 id = ip + b + op;\n        \n        // random location per sphere\n        vec3 ra = fract(sin(dot(id,vec3(1,123,1231))+vec3(0,1,2))*vec3(338.5453123,278.1459123,191.1234));\n        vec3 o = 0.3*sin(6.283185*time/48.0 + 50.0*ra);\n        vec3 r = b - fp + o;\n        \n        float d = dot(r,r);\n        if( d<dr.x ) dr = vec4(d,r);\n    }\n    return vec4(sqrt(dr.x)*rep-0.02,dr.yzw);\n}\n\n// https://iquilezles.org/articles/raymarchingdf/\nvec4 raycastCITA( in vec3 ro, in vec3 rd, in float px, in float tmax, in float time )\n{\n    float t = 0.0;\n    vec3 res = vec3(0.0);\n\tfor( int i=0; i<256; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n        vec4 h = mapCITA( pos, time );\n        res = h.yzw;\n        if( h.x<0.0005*px*t || t>tmax ) break;\n\t\tt += h.x;\n\t}\n\treturn (t<tmax) ? vec4(t,res) : vec4(-1.0);\n}\n\n//======================================================================\n// rendering\n//======================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n    float time = mod( iTime, 48.0 );\n    \n    // camera location and lense\n    vec3  ta = 0.08*sin( 6.283185*time/24.0+vec3(0,2,4) );\n    vec3  ro = ta + 1.85*vec3( cos(7.0*mo.x), 0.25, sin(7.0*mo.x) );\n    float fl = 2.5;\n\n    if( time>9.0 && time<16.0) { ta.z += 0.1; fl = 5.0; }    \n    \n    // camera-to-world transformation and ray direction\n    mat3 ca = setCamera( ro, ta, 0.05 );\n    vec3 rd = normalize( ca*vec3(p,fl) );\n    \n    // background\n    vec3 back = vec3(0.0003,0.013,0.04)*(1.0-clamp(-1.25*rd.y,0.0,1.0));\n    \n    // render creature\n    float ft = -1.0;\n    vec3 col = back;\n    \n    // bounding sphere\n    vec2 b = sphIntersect( ro, rd, 1.2 );\n    if( b.y>0.0 )\n    {\n        // raymarch creature from bounding sphere's entry to exit point\n        vec4  sum = vec4(0.0);\n        float tmax = b.y;\n        float t = max(0.0,b.x);\n        for( int i=0; i<256 && t<tmax; i++ )\n        {\n            vec4  res = map( ro + t*rd, time );\n            float dis = res.x;\n            \n            // raymarching step size (outter vs inner)\n            float dt = (dis>0.0) ? dis*0.8+0.001 : (-dis+0.002);\n            \n            // inside creature\n            if( dis<0.0 )\n            {\n                // record depth-buffer\n                if( ft<0.0 ) ft=t; \n                \n                // local geometry (position, normal, convexity)\n                vec3  pos = ro + t*rd;\n                vec3  nor = calcNormal( pos, res.x, time );\n                float occ = calcAO( pos, nor, time );\n\n                // color and opacity\n                vec4 tmp = vec4(res.yzw*res.yzw,min(20.0*dt,1.0));\n\n                // main light\n                float ll = 15.0*exp2(-2.0*t);\n                tmp.rgb *= (0.5+0.5*dot(nor,-rd))*ll*3.0/(1.0+ll);\n                \n                // subsurface scattering\n                float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n                tmp.rgb += fre*fre*(0.5+0.5*tmp.rgb)*0.8;\n                \n                // occlusion\n                tmp.rgb *= 1.6*mix(tmp.rgb*0.1+vec3(0.2,0.0,0.0),vec3(1.0),occ*1.4);\n      \n                // fog\n                //tmp.rgb = mix( back, tmp.rgb, exp2(-0.1*t*vec3(4.0,3.5,3.0)/fl) );\n\n                // composite front to back, and exit if opaque\n                tmp.rgb *= tmp.a;\n                sum += tmp*(1.0-sum.a);\n                if( sum.a>0.995 ) break;\n            }\n            t += dt;\n        }\n\n        // composite with background\n        sum = clamp(sum,0.0,1.0);\n        col = col*(1.0-sum.w) + sum.xyz;\n    }\n    \n    // render cita\n    vec4  cita = raycastCITA( ro, rd, 2.0/fl, (ft>0.0) ? ft : 15.0, time );\n    if( cita.x>0.0 )\n    {\n        // color\n        vec3 citacol = vec3(0.9,1.0,1.0);\n        // fog\n        citacol = mix( back, citacol, exp2(-0.1*cita.x*vec3(4.0,3.5,3.0)/fl) );\n        // blend in\n        float fre = clamp(dot(normalize(cita.yzw),rd),0.0,1.0);\n        col = mix( col, citacol, fre*0.3 );\n    }\n\n    // gain\n    //col = col*3.0/(3.0+col);\n    \n    // gamma and color tweak\n    col = pow( col, vec3(0.45,0.5,0.5) );\n    \n    // vignette\n    col *= 1.2 - 0.35*length(p);\n    \n    // dither to remove banding in the background\n    col += fract(sin(fragCoord.x*vec3(13,1,11)+fragCoord.y*vec3(1,7,5))*158.391832)/255.0;\n \n    // return color\n    fragColor = vec4(col, 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}