{
    "Shader": {
        "info": {
            "date": "1425165856",
            "description": "Collection of smooth minimums, maximums, ramps, and absolutes.",
            "flags": 0,
            "hasliked": 0,
            "id": "ltf3W2",
            "likes": 44,
            "name": "Smooth Minimums",
            "published": 3,
            "tags": [
                "sdf",
                "blending",
                "blend",
                "function",
                "smooth",
                "minimum",
                "minimums",
                "minima"
            ],
            "usePreview": 0,
            "username": "TinyTexel",
            "viewed": 2890
        },
        "renderpass": [
            {
                "code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\nCollection of smooth minimums, maximums, ramps, and absolutes.\nRelated: https://iquilezles.org/articles/smin\n\nGiven a smooth absolute function 'SAbs' the following template can be used to construct smooth ramp/minimum/maximum functions:\n\nfloat SAbs(float x, float k) { ... }\nfloat SRamp(float x, float k) { return (x + SAbs(x, k)) * 0.5; }\nfloat SMin(float a, float b, float k) { return a - SRamp(a - b, k); }\nfloat SMax(float a, float b, float k) { return a + SRamp(b - a, k); }\n\ni.e: SAbs => SRamp => [SMin|SMax]\n\n\nHowever, for smooth minimums an often more efficient form is\n\nfloat SMin(float a, float b, float r)\n{\n    float n = max(0.0, 1.0 - abs(a - b) / r);\n    \n    float o = poly(n);\n    \n    return min(a, b) - o * r * 0.5;\n}\n\nwhere 'poly' is a polynomial that can be derived from a given smooth absolute polynomial.\nAssuming 'poly' to be maximally of degree 6, the following functions (Mathematica code) can be used to map between SAbs and 'poly' on the interval [0,1]:\n\nSAbsFromPoly6[x_, a0_, b0_, c0_, d0_, e0_, f0_, g0_] := a0 + x - b0 (-1 + x) + c0 (-1 + x)^2 - d0 (-1 + x)^3 + e0 (-1 + x)^4 - f0 (-1 + x)^5 + g0 (-1 + x)^6\npoly6FromSAbs[x_, a_, b_, c_, d_, e_, f_, g_] := (-1 + a + b + c + d + e + f + g) + (1 - b - 2 c - 3 d - 4 e - 5 f - 6 g) x + (c + 3 d + 6 e + 10 f + 15 g) x^2 + (-d - 4 e - 10 f - 20 g) x^3 + (e + 5 f + 15 g) x^4 + (-f - 6 g) x^5 + g*x^6\n\nFor example, for AbsC2/SMinC2 we have\n\npoly6FromSAbs[x, 1/3, 0, 1, -1/3, 0, 0, 0] == x^3/3 (see SMinC2)\nHornerForm[SAbsFromPoly6[x, 0, 0, 0, 1/3, 0, 0, 0]] == 1/3 + (1 - x/3) x^2 (see AbsC2)\n\n\nCoding smins this way originally inspired by the Media Molecule smooth minimum code:\n// https://www.mediamolecule.com/blog/article/siggraph_2015 | slide 30\n// by Dave Smith @ Media Molecule\nsoft_min(a, b, r) \n{ \n\tfloat e = max(r - abs(a - b), 0); \n\treturn min(a, b) - e*e*0.25/r; \n}\n\nI just generalized this code a bit to support higher degree polynomials.\n\n\n(I used the following code to reverse engineer how sabs relates to poly: FullSimplify[-SMinMM[-x, x, 2], Assumptions -> x \\[Element] Reals && x > 0 && x < 1])\n*/\n\n\nfloat SAbsC1(float x, float k)\n{\n    x = abs(x) / k;\n    \n    return k * (x > 1.0 ? x : (x*x) * 0.5 + 0.5);\n}\n\nfloat SRampC1(float x, float k) { return (x + SAbsC1(x, k)) * 0.5; }\n\n/*/\nfloat SMinC1(float a, float b, float k) { return a - SRampC1(a - b, k); }\nfloat SMaxC1(float a, float b, float k) { return a + SRampC1(b - a, k); }\n/*/\n// by Dave Smith @ Media Molecule\nfloat SMinC1(float a, float b, float r)\n{\n    float n = max(0.0, r - abs(a - b));\n    \n    float o = n * n * 0.25;\n    \n    return min(a, b) - o / r;\n}\n\nfloat SMaxC1(float a, float b, float r)\n{\n    return -SMinC1(-a, -b, r);\n}\n//*/\n\n\nfloat SAbsC2(float x, float k)\n{\n    float v = abs(x)/k;\n    \n    return max(abs(x), k * (0.333333 + (v*v)*(1.0 - v*0.333333)));\n}\n\nfloat SRampC2(float x, float k) { return (x + SAbsC2(x, k)) * 0.5; }\n\n/*/\nfloat SMinC2(float a, float b, float k) { return a - SRampC2(a - b, k); }\nfloat SMaxC2(float a, float b, float k) { return a + SRampC2(b - a, k); }\n/*/\nfloat SMinC2(float a, float b, float r)\n{\n    float n = max(0.0, 1.0 - abs(a - b) / r);\n    \n    float o = n * n * n * 0.166667;\n    \n    return min(a, b) - o * r;\n}\n\nfloat SMaxC2(float a, float b, float r)\n{\n    return -SMinC2(-a, -b, r);\n}\n//*/\n\n\nfloat SAbsC3(float x, float k)\n{\n    x = abs(x) / k;\n    \n    return k * (x > 1.0 ? x : 0.3 + (x*x) * (1.0 + (x*x) * (-0.5 + x * 0.2)));\n    \n}\n\nfloat SRampC3(float x, float k) { return (x + SAbsC3(x, k)) * 0.5; }\n\n/*/\nfloat SMinC3(float a, float b, float k) { return a - SRampC3(a - b, k); }\nfloat SMaxC3(float a, float b, float k) { return a + SRampC3(b - a, k); }\n/*/\nfloat SMinC3(float a, float b, float r)\n{\n    float n = max(0.0, 1.0 - abs(a - b) / r);\n    \n    float o = (0.25 - n*0.1) * ((n*n)*(n*n));\n    \n    return min(a, b) - o*r;\n}\n\nfloat SMaxC3(float a, float b, float r)\n{\n    return -SMinC3(-a, -b, r);\n}\n//*/\n\n\n\n// C2, similar in shape to SAbsC1\nfloat SAbsQ(float x, float k)\n{\n    x = abs(x) / k;\n    float xx = x*x;\n    \n    return k * mix(x, xx * 0.5 + 0.5, max(0.0, 1.0 - xx*x));\n}\n\nfloat SRampQ(float x, float k) { return (x + SAbsQ(x, k)) * 0.5; }\n\nfloat SMinQ(float a, float b, float k) { return a - SRampQ(a - b, k); }\nfloat SMaxQ(float a, float b, float k) { return a + SRampQ(b - a, k); }\n\n\n// C2, curvature approx. linear\nfloat SAbsK(float x, float k)\n{\n    float xx = (x/k) * (x/k);\n    \n    return max(abs(x), k * (0.40625 + xx * (0.65625 + xx * (-0.03125 - 0.03125 * xx))));\n}\n\nfloat SRampK(float x, float k) { return (x + SAbsK(x, k)) * 0.5; }\n\nfloat SMinK(float a, float b, float k) { return a - SRampK(a - b, k); }\nfloat SMaxK(float a, float b, float k) { return a + SRampK(b - a, k); }\n\n\n// SAbsCos faster than SAbsC2 but SMinCos slower than SMinC2\n// C2, cosine based\nfloat SAbsCos(float x, float k)\n{\n    float n = 0.63662 * k;// 2/Pi*k\n    \n    return max(abs(x), cos(x / n) * -n + k); \n}\n\nfloat SRampCos(float x, float k) { return (x + SAbsCos(x, k)) * 0.5; }\n\n//float SMinCos(float a, float b, float k) { return a - SRampCos(a - b, k); }\n//float SMaxCos(float a, float b, float k) { return a + SRampCos(b - a, k); }\n\n\n// C2, bevel\nfloat SAbsBevelC2(float x, float k, float s)\n{\n    float ax = abs(x) / k;\n    \n    float v = (s - ax) / (s - 1.0);\n    float poly = 0.5857864376269051 + (v*v*v) * (0.14213562373095012 + (0.7867965644035753 - 0.5147186257614305 * v) * v);\n    return max(abs(x), k * (ax < s ? 0.5857864376269051 + 0.4142135623730949 * s : mix(s, 1.0, poly)));\n}\n\nfloat SRampBevelC2(float x, float k, float s) { return (x + SAbsBevelC2(x, k, s)) * 0.5; }\n\nfloat SMinBevelC2(float a, float b, float k, float s) { return a - SRampBevelC2(a - b, k, s); }\nfloat SMaxBevelC2(float a, float b, float k, float s) { return a + SRampBevelC2(b - a, k, s); }\n\n\n\n// Cinf, hyperbolic, unbounded range of influence\nfloat SAbsHyp(float x, float k)\n{\n    return sqrt(x * x + k);\n}\n\nfloat SRampHyp(float x, float k) { return (x + SAbsHyp(x, k)) * 0.5; }\n\nfloat SMinHyp(float a, float b, float k) { return a - SRampHyp(a - b, k); }\nfloat SMaxHyp(float a, float b, float k) { return a + SRampHyp(b - a, k); }\n\n\n// Cinf, exponential, unbounded range of influence\nfloat SRampExp(float x, float k)\n{\n    return x / (1.0 - exp2(-x * k));\n}\n\nfloat SAbsExp(float x, float k)\n{\n    return x + 2.0 * SRampExp(-x, k);// == x*coth((x*k)/2)\n}\n\nfloat SMinExp(float a, float b, float k) { return a - SRampExp(a - b, k); }\nfloat SMaxExp(float a, float b, float k) { return a + SRampExp(b - a, k); }\n\n\n\n\nfloat Curve(float x, float y)\n{\n    return clamp(1.0 - abs(x-y) * 200.0, 0.0, 1.0);\n}\n\nfloat FuncA(float x)\n{\n    float a = x * 2.0 - 1.0;\n    \n    return a * a + 0.1;\n}\n\nfloat FuncB(float x)\n{\n    float a = x * 0.25;\n    \n    a *= 0.75 * sin(iTime);\n    \n    return a + 0.5;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord / iResolution.xy;\n    \n    float x = uv.x;\n    float y = uv.y;\n    \n    \n    float ref = Curve(FuncA(x), y) + Curve(FuncB(x), y);\n    \n    vec3 res1 = Curve(SMinC3(FuncA(x), FuncB(x), 0.40), y) * vec3(1.0, 0.0, 0.0);\n    vec3 res2 = Curve(SMinC2(FuncA(x), FuncB(x), 0.40), y) * vec3(0.0, 1.0, 0.0);\n    vec3 res3 = Curve(SMinC3(FuncA(x), FuncB(x), 0.35), y) * vec3(1.0, 0.0, 1.0);\n    \n    vec3 res4 = Curve(SMinBevelC2(FuncA(x), FuncB(x), 0.125, 0.25), y)  * vec3(1.0, 1.0, 0.0);  \n    \n    //perf testing:\n    //for(float i = 0.0; i < 10000.0; ++i) res1.r = SMinC3(res1.r, FuncB(x), 0.25);\n    \n    //fragColor = vec4(res1 + ref*0.25, 1.0); return;\n    fragColor = vec4(res2*1.0 + res3*1.0 + res4*1.0 + ref * 0.25, 1.0);\n}\n\n\n// DEPRECATED:\n/*\n\n\n// C2, even degrees only polynomial\nfloat SAbsC2b(float x, float k)\n{\n    float xx = (x/k) * (x/k);\n    \n    return max(abs(x), k * (0.375 + xx * (0.75 - 0.125 * xx)));\n}\n\nfloat SRampC2b(float x, float k) { return (x + SAbsC2b(x, k)) * 0.5; }\n\nfloat SMinC2b(float a, float b, float k) { return a - SRampC2b(a - b, k); }\nfloat SMaxC2b(float a, float b, float k) { return a + SRampC2b(b - a, k); }\n\n// C3, even degrees only polynomial\nfloat SAbsC3b(float x, float k)\n{\n    x = abs(x) / k;\n    float xx = x*x;\n    \n    return k * (x > 1.0 ? x : (0.3125 + xx * (0.9375 + xx * (-0.3125 + 0.0625 * xx))));\n}\n\nfloat SRampC3b(float x, float k) { return (x + SAbsC3b(x, k)) * 0.5; }\n\nfloat SMinC3b(float a, float b, float k) { return a - SRampC3b(a - b, k); }\nfloat SMaxC3b(float a, float b, float k) { return a + SRampC3b(b - a, k); }\n\n\n\n// C3, cosine based\nconst float Pi = 3.141593;\nconst float RcpPiSqr = 0.101321;\n\nfloat SAbsCos2(float x, float r)\n{\n    const float n = 0.398679;\n    \n    return abs(x) > r ? abs(x) : (x*x * 0.5 / r) + (r * (n - cos(x * Pi / r) * RcpPiSqr));\n}\n\nfloat SRampCos2(float x, float k)\n{\n    return 0.5 * (x - SAbsCos2(x, k));\n}\n\nfloat SMinCos2(float a, float b, float k)\n{\n    return a + SRampCos2(b - a, k);\n}\n\n// C2, norm3 approx ((1-x^3)^(1/3) rotated 135° CW)\nfloat SAbsNorm3(float x, float k)\n{\n    float v = abs(x) / k;\n    \n    return max(abs(x), k * (((v * -0.237797 + 0.300792) * v + 0.524406) * (v * v) + 0.412599)); \n}\n\nfloat SRampNorm3(float x, float k)\n{\n    return 0.5 * (x - SAbsNorm3(x, k));\n}\n\nfloat SMinNorm3(float a, float b, float k)\n{\n    return a + SRampNorm3(b - a, k);\n}\n\n*/\n\n\n\n/*\nrelated Mathematica code:\n\nground truth smmoth abs of norm3 approx ((1-x^3)^(1/3) rotated 135° CW):\n\nrnorm3[x_] := \n 2 - Sqrt[(x^2 - (2 + Sqrt[4 + x^6])^(2/3))^2/(2 + Sqrt[4 + x^6])^(\n   2/3) + (x + (4 + 5 x^3 - (3 x^5)/(2 + Sqrt[4 + x^6])^(2/3) - \n       3 x (2 + Sqrt[4 + x^6])^(2/3))^(1/3))^2]/Sqrt[2]\n\n\n\nplot ground truth smooth abs with piecewise linear curvature (the one SAbsK approximates):\n\ns = NDSolve[{u''[x] == Sqrt[2] \\!\\(\\*\nTagBox[GridBox[{\n{\"\\[Piecewise]\", GridBox[{\n{\"0\", \nRowBox[{\"x\", \"<\", \nRowBox[{\"-\", \"1\"}]}]},\n{\nRowBox[{\"1\", \"+\", \"x\"}], \nRowBox[{\nRowBox[{\"x\", \">=\", \nRowBox[{\"-\", \"1\"}]}], \"&&\", \nRowBox[{\"x\", \"<\", \"0\"}]}]},\n{\nRowBox[{\"1\", \"-\", \"x\"}], \nRowBox[{\nRowBox[{\"x\", \">=\", \"0\"}], \"&&\", \nRowBox[{\"x\", \"<\", \"1\"}]}]},\n{\"0\", \nTagBox[\"True\",\n\"PiecewiseDefault\",\nAutoDelete->True]}\n},\nAllowedDimensions->{2, Automatic},\nEditable->True,\nGridBoxAlignment->{\n             \"Columns\" -> {{Left}}, \"ColumnsIndexed\" -> {}, \n              \"Rows\" -> {{Baseline}}, \"RowsIndexed\" -> {}},\nGridBoxItemSize->{\n             \"Columns\" -> {{Automatic}}, \"ColumnsIndexed\" -> {}, \n              \"Rows\" -> {{1.}}, \"RowsIndexed\" -> {}},\nGridBoxSpacings->{\"Columns\" -> {\nOffset[0.27999999999999997`], {\nOffset[0.84]}, \nOffset[0.27999999999999997`]}, \"ColumnsIndexed\" -> {}, \"Rows\" -> {\nOffset[0.2], {\nOffset[0.4]}, \nOffset[0.2]}, \"RowsIndexed\" -> {}},\nSelectable->True]}\n},\nGridBoxAlignment->{\n          \"Columns\" -> {{Left}}, \"ColumnsIndexed\" -> {}, \n           \"Rows\" -> {{Baseline}}, \"RowsIndexed\" -> {}},\nGridBoxItemSize->{\n          \"Columns\" -> {{Automatic}}, \"ColumnsIndexed\" -> {}, \n           \"Rows\" -> {{1.}}, \"RowsIndexed\" -> {}},\nGridBoxSpacings->{\"Columns\" -> {\nOffset[0.27999999999999997`], {\nOffset[0.35]}, \nOffset[0.27999999999999997`]}, \"ColumnsIndexed\" -> {}, \"Rows\" -> {\nOffset[0.2], {\nOffset[0.4]}, \nOffset[0.2]}, \"RowsIndexed\" -> {}}],\n\"Piecewise\",\nDeleteWithContents->True,\nEditable->False,\nSelectWithContents->True,\nSelectable->False]\\)  (1 + u'[x]^2)^(3/2), u'[0] == 0, u[1] == 1}, \n  u, {x, -2, 2}]\nEvaluate[{u[0] /. s}]\nPlot[{Abs[x], Evaluate[{u[x] /. s}]}, {x, -1, 1}, \n PlotRange -> {-0, 1}, AspectRatio -> Automatic]\n\n\n*/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}