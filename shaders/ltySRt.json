{
    "Shader": {
        "info": {
            "date": "1485681274",
            "description": "Fast, animated 2d cellular block algorithm. The blocks have been added to a back plane and raymarched to give a pseudo 3D block effect.",
            "flags": 0,
            "hasliked": 0,
            "id": "ltySRt",
            "likes": 89,
            "name": "Cellular Blocks",
            "published": 3,
            "tags": [
                "voronoi",
                "triangle",
                "block"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 4733
        },
        "renderpass": [
            {
                "code": "/*\n\n\tFast Cellular Blocks\n\t--------------------\n\n\tAfter looking at IQ and Aiekick's 2D Voronoi triangle-metric examples (the ones that \n\tlook like blocks), I thought it'd be interesting to raymarch the pattern onto a back \n\tplane to see just how 3D it looked. The result was an interesting voxelized look with\n\tmore depth than the regular, or bump mapped, examples you see around. After that, I \n\tfigured I'd add some variance by rounding things off, combining layers, etc, but ran \n\tinto speed problems.\n\n\tAt that stage, I wondered whether the much faster cellular tiled approach could emulate \n\tthe pattern, and thankfully, it could. I came up with the layered repeat-tile approach \n    a while back, and have explained it in other examples. The result, here, is an \n\tartifact-free, animated triangle metric at a small fraction of the cost.\n\n    Unlike my other cellular tiled examples, this one is animated. It was a proof of concept, \n\twhich was put in as an afterthought, so probably needs some tuning. Nevertheless, it\n\tworks well enough for the purpose of this demonstration.\n\n\tAt best, a normal animated Voronoi algorithm utilizing the triangle metric would have \n\tnine iterations (many use more) consisting of several operations. The algorithm used \n\there uses just four, each with a fraction of the operations.\n\n\tI haven't utilized the speed to its full potential. However, there are still two \n\traymarched layers - each containing a more expensive distance metric - and my slowest \n\tcomputer can handle it easily. I'll do something more interesting with it later.\n\n\tBy the way, I made a very basic example with very little code for anyone who'd like to\n\tlook at the algorithm without having to sift through a bunch of window dressing. The\n\tlink is below.\n\n\t// The main inspiration for this, and practically all the other examples.\n\tBlocks -IQ\n    https://www.shadertoy.com/view/lsSGRc\n\n\n\t// Just the cellular block algorithm.\n    Fast, Minimal Animated Blocks - Shane\n\thttps://www.shadertoy.com/view/MlVXzd\n\n*/\n\n\n// Far plane. Redundant here, but included out of habit.\n#define FAR 10. \n\nfloat objID = 0.; // Object ID. Used to identify the large block and small block layers.\n\n\n/*\n\n// Just the function itself. Everything else can be ignored, if you just want to produce repeat\n// block tile patterns.\n\n// Distance metric. A slightly rounded triangle is being used, which looks a little more organic.\nfloat dm(vec2 p){\n    \n    p = fract(p) - .5;\n    \n    //return max(abs(p.x)*.866025 + (p.y)*.5, -(p.y)); // Regular triangle metric.\n    \n    return (dot(p, p)*4.*.25 + .75)*max(abs(p.x)*.866025 + p.y*.5, -p.y);\n    //return (1.-(dot(p, p)*4.*.5 + .5)*.5)*max(abs(p.x)*.866025 + p.y*.5, -p.y);\n    //return (1.-dot(p, p)*4.*.166)*max(abs(p.x)*.866025 + p.y*.5, -p.y);\n    \n    //return max(-max(abs(p.x)*.866025 - p.y*.5, p.y) + .25, max(abs(p.x)*.866025 + p.y*.5, -p.y));\n    //return (length(p) + .5)*max(abs(p.x)*.866025 + p.y*.5, -p.y);\n    \n}\n\n\n// Very cheap wrappable cellular tiles. This one produces a block pattern on account of the\n// metric used, but other metrics will produce the usual patterns.\n//\n// Construction is pretty simple: Plot two points in a wrappble cell and record their distance. \n// Rotate by a third of a circle then repeat ad infinitum. Unbelievably, just one rotation \n// is needed for a random looking pattern. Amazing... to me anyway. :)\n//\n// Note that there are no random points at all, no loops, and virtually no setup, yet the \n// pattern appears random anyway.\nfloat cell(vec2 p){\n\n    \n    // Matrix to rotate the layer by TAU/3. radians - or 120 degrees -\n    // which makes sense when dealing with the equilateral triangle metric.\n    const mat2 m = mat2(-.5, .866025, -.866025, -.5);    \n    \n    // Abstract varitation, just for fun.\n    //const mat2 m = mat2(-1, 1, -1, -1)*.7071;\n    //const mat2 m = mat2(.5, .866025, -.866025, .5);\n     \n    // Two rotating point plus offset\n    const float offs = .666 - .166;\n    vec2 a = sin(vec2(1.93, 0) + iTime)*.166;\n    float d0 = dm(p + vec2(a.x, 0));\n    float d1 = dm(p + vec2(0, offs + a.y));\n    \n    // Rotate the layer, and plot another two points.\n    p = m*(p + .5);\n    float d2 = dm(p + vec2(a.x, 0));\n    float d3 = dm(p + vec2(0, offs + a.y)); \n    \n    // Find the distance to the nearest point.\n    // It works with just one rotation and four points very well.\n    return min(min(d0, d1), min(d2, d3))*2.;    \n\n     \n    // Add another two points and a rotation, and the pattern looks even more random.\n    //p = m*(p + .5);\n    //float d4 = dm(p +  vec2(a.x, 0));\n    //float d5 = dm(p +  vec2(0, offs + a.y));\n    \n    //return min(min(min(d0, d1), min(d2, d3)), min(d4, d5))*2.;\n         \n    \n}\n\n*/\n\n// Distance metric. A slightly rounded triangle is being used, which looks a little more organic.\nfloat dm(vec2 p){\n    \n    p = fract(p) - .5;\n    \n    //return max(abs(p.x)*.866025 + (p.y)*.5, -(p.y)); // Regular triangle metric.\n    \n    return (dot(p, p)*4.*.25 + .75)*max(abs(p.x)*.866025 + p.y*.5, -p.y);\n    //return (1.-(dot(p, p)*4.*.5 + .5)*.5)*max(abs(p.x)*.866025 + p.y*.5, -p.y);\n    //return (1.-dot(p, p)*4.*.166)*max(abs(p.x)*.866025 + p.y*.5, -p.y);\n    \n    //return max(-max(abs(p.x)*.866 - p.y*.5, p.y) + .25, max(abs(p.x)*.866025 + p.y*.5, -p.y));\n    //return (length(p) + .5)*max(abs(p.x)*.866025 + p.y*.5, -p.y);\n    \n}\n\n// Distance metric for the second pattern. It's just a reverse triangle metric.\nfloat dm2(vec2 p){\n    \n    p = fract(p) - .5;   \n    \n    //return max(abs(p.x)*.866025 + -p.y*.5, p.y); \n    return (dot(p, p)*4.*.25 + .75)*max(abs(p.x)*.866025 - p.y*.5, p.y);\n    \n    //return max(-max(abs(p.x)*.866025 + p.y*.5, -p.y) + .2, max(abs(p.x)*.866025 - p.y*.5, p.y));\n    //return (length(p)*1. + .5)*max(abs(p.x)*.866025 - p.y*.5, p.y);\n    \n}\n\n// Very cheap wrappable cellular tiles. This one produces a block pattern on account of the\n// metric used, but other metrics will produce the usual patterns.\n//\n// Anyway, plot two points in a wrappble cell and record the minimum distance, rotate by a third\n// of a circle whilst storing the overall minimum, then repeat ad infinitum. In this case just\n// one rotation is needed for a random looking pattern. Amazing.\n//\n// Note that there are no random points at all, no loops, and virtually no setup, yet the \n// pattern appears random anyway.\n//\n// By the way, this particular function combines two patterns for the large and small blocks,\n// but the original is commented out above, for anyone interested.\nfloat cell(vec2 q){\n\n    \n    // SETUP.\n    //\n    // Matrix to rotate the layer by TAU/3. radians - or 120 degrees -\n    // which makes sense when dealing with the equilateral triangle metric.\n    const mat2 m = mat2(-.5, .866025, -.866025, -.5);    \n    \n    // Abstract varitation, just for fun.\n    //const mat2 m = mat2(-1, 1, -1, -1)*.7071;\n    //const mat2 m = mat2(.5, .866025, -.866025, .5);\n     \n    // FIRST PATTERN.\n    // Two rotating points plus offset\n    vec2 p = q;\n    const float offs = .666 - .166;\n    vec2 a = sin(vec2(1.93, 0) + iTime)*.166;\n    float d0 = dm(p + vec2(a.x, 0));\n    float d1 = dm(p + vec2(0, offs + a.y));\n    \n    // Rotate the layer, and plot another two points.\n    p = m*(p + .5);\n    float d2 = dm(p + vec2(a.x, 0));\n    float d3 = dm(p + vec2(0, offs + a.y)); \n    \n    // Find the distance to the nearest point.\n    // It works with just one rotation and four points very well.\n    float l1 = min(min(d0, d1), min(d2, d3))*2.; \n    \n    \n    // SECOND PATTERN... The small blocks, just to complicate things. :)\n    p = q;\n    d0 = dm2(p + vec2(a.x, 0));\n    d1 = dm2(p + vec2(0, offs + a.y));\n    \n    // Rotate the layer, and plot another two points.\n    p = m*(p + .5);\n    d2 = dm2(p + vec2(a.x, 0));\n    d3 = dm2(p + vec2(0, offs + a.y)); \n    \n    // Find the distance to the nearest point.\n    // It works with just one rotation and four points very well.\n    float l2 = min(min(d0, d1), min(d2, d3))*2.; \n    \n    \n    // COMBINING PATTERNS.\n    objID = step(l1, -(l2 - .4)); // Object, or pattern, ID.\n \n    // Combine layers.\n    return max(l1, -(l2 - .4));\n\n   \n    \n}\n\n// The heightmap. We're combining two patterns, each with their own distance metric, so the cell\n// function is more complicated than it normally would be. However, there's another that has been\n// commented out that people can refer to, if they're interested.\nfloat heightMap(vec3 p){\n \n    return cell(p.xy*2.); // Just one layer.\n \n}\n\n// The distance function. Just a heightmap function applied to a plane. Pretty standard stuff.\nfloat map(vec3 p){\n   \n    float tx = heightMap(p);\n    \n    return 1.2 - p.z + (.5 - tx)*.125;\n    \n}\n\n// Normal calculation, with some edging and curvature bundled in.\nvec3 nr(vec3 p, inout float edge, inout float crv) { \n\t\n    // Roughly two pixel edge spread, regardless of resolution.\n    vec2 e = vec2(2./iResolution.y, 0);\n\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p)*2.;\n\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n    \n    // Wider sample spread for the curvature.\n    e = vec2(12./450., 0);\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n    crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .5, 0., 1.);\n\n    \n    e = vec2(2./450., 0); //iResolution.y - Depending how you want different resolutions to look.\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cao(in vec3 p, in vec3 n){\n\t\n    float sca = 2., occ = 0.;\n    for(float i=0.; i<6.; i++){\n    \n        float hr = .01 + i*.75/5.;        \n        float dd = map(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.8;\n    }\n    \n    return clamp(1.0 - occ, 0., 1.);    \n    \n    \n}\n\n// Compact, self-contained version of IQ's 3D value noise function.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(mod(h, 6.2831))*43758.5453), fract(sin(mod(h + s.x, 6.2831))*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// Simple environment mapping. Pass the reflected vector in and create some\n// colored noise with it. The normal is redundant here, but it can be used\n// to pass into a 3D texture mapping function to produce some interesting\n// environmental reflections.\nvec3 eMap(vec3 rd, vec3 sn){\n    \n    vec3 sRd = rd; // Save rd, just for some mixing at the end.\n    \n    // Add a time component, scale, then pass into the noise function.\n    rd.xy -= iTime*.25;\n    rd *= 3.;\n    \n    float c = n3D(rd)*.57 + n3D(rd*2.)*.28 + n3D(rd*4.)*.15; // Noise value.\n    c = smoothstep(0.5, 1., c); // Darken and add contast for more of a spotlight look.\n    \n    //vec3 col = vec3(c, c*c, c*c*c*c).zyx; // Simple, warm coloring.\n    vec3 col = vec3(min(c*1.5, 1.), pow(c, 2.5), pow(c, 12.)).zyx; // More color.\n    \n    // Mix in some more red to tone it down and return.\n    return mix(col, col.yzx, sRd*.25+.25); \n    \n}\n\nvoid mainImage( out vec4 fragColor, vec2 u ){\n\n    // Unit direction ray, ray origin (camera position), and light.\n    vec3 rd = normalize(vec3(u - iResolution.xy*.5, iResolution.y)), \n         ro = vec3(-iTime*.125, -iTime*.05, 0), l = ro + vec3(.5, -1.5, -1.);\n    \n    /*\n    // Mild perspective and lens effects.\n    r = normalize(vec3(r.xy, (r.z - length(r.xy)*.2)*1.2));\n    vec2 a = sin(vec2(1.57, 0) - 3.14159/32.);\n    r.yz = mat2(a, -a.y, a.x) * r.yz;\n    r.xz = r.xz*mat2(a, -a.y, a.x);\n    */\n\n    \n    // Raymarching against a back plane usually doesn't require many iterations -\n    // nor does it require a far-plane break - buy I've given it a few anyway.\n    float d, t = 0.;\n    \n    for(int i=0; i<64;i++){\n        \n        d = map(ro + rd*t); // Distance the nearest surface point.\n        if(abs(d)<0.001 || t>FAR) break; // The far-plane break is redundant here.\n        t += d*.86; // The accuracy probably isn't needed, but just in case.\n    }\n    \n    //t = min(t, FAR); // Capping \"t\" to the far plane. Not need here.    \n    \n    float svObjID = objID; // Store the object ID just after raymarching.\n    \n    vec3 sCol = vec3(0); // Scene color.\n    \n    // Edge and curvature variables. Passed into the normal function.\n    float edge = 0., crv = 1.;\n    \n    if(t<FAR){\n    \n        vec3 p = ro + rd*t, n = nr(p, edge, crv);//normalize(fract(p) - .5);\n\n        l -= p; // Light to surface vector. Ie: Light direction vector.\n        d = max(length(l), 0.001); // Light to surface distance.\n        l /= d; // Normalizing the light direction vector.\n\n\n        // Attenuation and extra shading.\n        float atten = 1./(1. + d*d*.05);\n        float shade = heightMap(p);\n        \n        \n        // Texturing. Because this is a psuedo 3D effect that relies on the isometry of the\n        // block pattern, we're texturing isometrically... groan. :) Actually, it's not that \n        // bad. Rotate, skew, repeat. You could use tri-planar texturing, but it's doesn't\n        // look quite as convincing in this instance.\n        //\n        // By the way, the blocks aren't perfectly square, but the texturing doesn't seem to\n        // be affected.\n        vec2 tuv = vec2(0);\n        vec3 q = p;\n        const mat2 mr3 = mat2(.866025, .5, -.5, .866025); // 60 degrees rotation matrix.\n        q.xy *= mr3; // Rotate by 60 degrees to the starting alignment.\n        if((n.x)>.002) tuv = vec2((q.x)*.866 - q.y*.5, q.y); // 30, 60, 90 triangle skewing... kind of.\n        q.xy *= mr3*mr3; // Rotate twice for 120 degrees... It works, but I'll improve the logic at some stage. :)\n        if (n.x<-.002) tuv = vec2((q.x)*.866 - q.y*.5, q.y);\n        q.xy *= mr3*mr3; // Rotate twice.\n        if (n.y>.002) tuv = vec2((q.x)*.866 - q.y*.5, q.y);\n        \n        // Pass in the isometric texture coordinate, roughly convert to linear space (tx*tx), and\n        // make the colors more vibrant with the \"smoothstep\" function.\n        vec3 tx = texture(iChannel0, tuv*2.).xyz;\n        tx = smoothstep(.05, .5, tx*tx);\n        \n        if(svObjID>.5) tx *= vec3(2, .9, .3); // Add a splash of color to the little blocks.\n       \n        \n        float ao = cao(p, n); // Ambient occlusion. Tweaked for the this example.\n       \n       \n        float diff = max(dot(l, n), 0.); // Diffuse.\n        float spec = pow(max(dot(reflect(l, n), rd), 0.), 6.); // Specular.\n        //diff = pow(diff, 4.)*0.66 + pow(diff, 8.)*0.34; // Ramping up the diffuse.\n        \n        \n        // Cheap way to add an extra color into the mix. Only applied to the small blocks.\n        if(svObjID>.5) {\n        \tfloat rg = dot(sin(p*6. + cos(p.yzx*4. + 1.57/3.)), vec3(.333))*.5 + .5;\n        \ttx = mix(tx, tx.zxy, smoothstep(0.6, 1., rg));\n        }\n\n        \n        // Applying the lighting.\n        sCol = tx*(diff + .5) + vec3(1, .6, .2)*spec*3.;\n        \n        \n        // Alternative, mild strip overlay.\n        //sCol *= clamp(sin(shade*6.283*24.)*3. + 1., 0., 1.)*.35 + .65;\n        \n        \n        // Adding some cheap environment mapping to help aid the illusion a little more.\n        sCol += (sCol*.75 + .25)*eMap(reflect(rd, n), n)*3.; // Fake environment mapping.\n        \n        //sCol = pow(sCol, vec3(1.25))*1.25; More contrast, if you were going for that look.\n        \n        // Using the 2D block value to provide some extra shading. It's fake, but gives it a\n        // more shadowy look.\n        sCol *= (smoothstep(0., .5, shade)*.75 + .25);\n         \n        // Applying curvature, edging, ambient occlusion and attenuation. You could apply this\n        // in one line, but I thought I'd seperate them for anyone who wants to comment them\n        // out to see what effect they have.\n        sCol *= min(crv, 1.)*.7 + .3;\n        sCol *= 1. - edge*.85;\n        sCol *= ao*atten;\n \n        \n    }\n    \n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(clamp(sCol, 0., 1.)), 1.);\n    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}