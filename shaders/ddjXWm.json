{
    "Shader": {
        "info": {
            "date": "1670420522",
            "description": "Another family trip. But can they leave footprints?",
            "flags": 0,
            "hasliked": 0,
            "id": "ddjXWm",
            "likes": 12,
            "name": "Ectoplasmic Penguins",
            "published": 3,
            "tags": [
                "ghost",
                "tux",
                "footprint"
            ],
            "usePreview": 1,
            "username": "dr2",
            "viewed": 241
        },
        "renderpass": [
            {
                "code": "// \"Ectoplasmic Penguins\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n// (Starting from \"Tux Family Trip\" ...)\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\n\n#define N_PENG 6\n\nstruct Leg {\n  vec2 cs1, cs2, cs3;\n  float zFoot;\n};\nstruct Walker {\n  Leg leg[2];\n  vec3 wPos;\n  vec2 csHead, csBod;\n  float szFac, hHip, lLeg, stride, tPhs;\n};\nWalker wlk[N_PENG];\n\nvec3 sunDir, qHit, wPos;\nfloat tCur, dstFar, spd, fAng;\nint idObj;\nconst int idLeg = 1, idFoot = 2, idBod = 3, idHead = 4, idBk = 5, idEye = 6, idFlp = 7;\nbool isSh;\nconst float pi = 3.1415927;\n\n#define CosSin(x) (sin ((x) + vec2 (0.5 * pi, 0.)))\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvoid SetWlkConf ()\n{  // (based on \"Walkers\")\n  vec2 w;\n  float sDir, t, tH, tt, tV, limT, fUp, limEx, a1, a2, fh, sz, x;\n  tH = 0.01;\n  tV = 0.3;\n  limT = 0.5;\n  limEx = 0.95;\n  fUp = 1.;\n  x = 10.5;\n  sz = 1.;\n  for (int j = 0; j < N_PENG; j ++) {\n    wlk[j].szFac = sz;\n    wlk[j].lLeg = 0.9;\n    wlk[j].hHip = limEx * 4. * wlk[j].lLeg * cos (atan (limT));\n    wlk[j].tPhs = mod (tCur * spd * (3./2.) / (wlk[j].szFac * wlk[j].hHip * limT), 4.);\n    for (int k = 0; k < 2; k ++) {\n      t = mod (wlk[j].tPhs + float (2 * k), 4.);\n      if (t > 1.) {\n        sDir = -1.;\n        t = (t - 1.) / 3.;\n      } else sDir = 1.;\n      tt = 0.5 - abs (t - 0.5);\n      a1 = atan (limT * (((tt < tH) ? tt * tt / tH : 2. * tt - tH) / (1. - tH) - 1.)) *\n         sign (0.5 - t) * sDir;\n      fh = wlk[j].hHip;\n      if (sDir > 0.) fh -= fUp * smoothstep (0., tV, tt);\n      a2 = - acos (fh / (4. * wlk[j].lLeg * cos (a1)));\n      wlk[j].leg[k].cs1 = CosSin (-0.5 * pi + a1 + a2);\n      wlk[j].leg[k].cs2 = CosSin (-2. * a2);\n      wlk[j].leg[k].cs3 = CosSin (0.5 * pi - a1 + a2);\n      w = Rot2Cs (vec2 (0., -2. * wlk[j].lLeg), wlk[j].leg[k].cs2);\n      w.y -= 2. * wlk[j].lLeg + 0.1;\n      wlk[j].leg[k].zFoot = Rot2Cs (w, wlk[j].leg[k].cs3).y - 0.8;\n    }\n    wlk[j].stride = 4.08;\n    wlk[j].csBod = CosSin (0.05 * pi * sin (0.5 * pi * wlk[j].tPhs + pi));\n    wlk[j].csHead = CosSin (0.2 * pi * (2. * SmoothBump (0.25, 0.75, 0.25,\n       mod (0.4 * tCur / wlk[j].szFac, 1.)) - 1.));\n    wlk[j].wPos = wPos - vec3 (x, -0.3 * wlk[j].szFac, 0.);\n    x -= 8.5 * wlk[j].szFac;\n    sz *= 0.75;\n  }\n}\n\nfloat PengDf (vec3 p, float dMin, Walker wk)\n{  // (based on \"Tux the Penguin\")\n  vec3 pp, q, qq, fSize;\n  float d, legRad;\n  p.y -= wk.hHip;\n  if (! isSh) d = PrSphDf (p, 7.);\n  if (isSh || d < dMin) {\n    legRad = 0.12;\n    pp = p;\n    p.xy = Rot2Cs (p.xy, wk.csBod);\n    p.y -= 0.9;\n    p.xz = - p.xz;\n    q = p;\n    d = PrEllipsDf (q.xzy, vec3 (2.6, 2.4, 2.8));\n    DMINQ (idBod);\n    q = p;\n    q.xz = Rot2Cs (q.xz, wk.csHead);\n    qq = q;\n    q.y -= 3.;\n    d = PrEllipsDf (q.xzy, vec3 (1.6, 1.2, 2.6));\n    q.x = abs (q.x);\n    q -= vec3 (0.6, 1., -0.8);\n    d = max (d, - PrCylDf (q, 0.3, 0.5));\n    DMINQ (idHead);\n    q = qq;\n    q.x = abs (q.x);\n    q -= vec3 (0.6, 4., -0.8);\n    d = PrSphDf (q, 0.3);\n    DMINQ (idEye);\n    q = qq;\n    q.yz -= vec2 (3., -1.2);\n    d = max (PrEllipsDf (q, vec3 (0.8, 0.4, 1.2)), 0.01 - abs (q.y));\n    DMINQ (idBk);\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (2.2, 0.6, -0.4);\n    q.yz = Rot2Cs (q.yz, CosSin (-0.25 * pi));\n    q.xy = Rot2Cs (q.xy, CosSin (fAng)) - vec2 (0.2, -0.8);\n    d = PrEllipsDf (q.xzy, vec3 (0.2, 0.5, 1.8));\n    DMINQ (idFlp);\n    for (int k = 0; k < 2; k ++) {\n      p = pp;\n      p.x += 1. * sign (float (k) - 0.5);\n      p.y -= -0.2;\n      q = p.yxz;\n      q.xz = Rot2Cs (q.xz, wk.leg[k].cs1);\n      q.z -= wk.lLeg;\n      d = PrCapsDf (q, legRad, wk.lLeg);\n      DMINQ (idLeg);\n      q.z -= wk.lLeg;\n      q.xz = Rot2Cs (q.xz, wk.leg[k].cs2);\n      q.z -= wk.lLeg;\n      d = PrCapsDf (q, legRad, wk.lLeg);\n      DMINQ (idLeg);\n      q.z -= wk.lLeg + 0.1;\n      q.xy = q.yx;\n      q.yz = Rot2Cs (q.yz, wk.leg[k].cs3);\n      q.z = - q.z;\n      q.xz = Rot2Cs (q.xz, CosSin (0.05 * pi * sign (float (k) - 0.5))) + vec2 (0., 0.8);\n      fSize = vec3 (0.3, 0.13, 1.);\n      d = SmoothMin (PrEllipsDf (vec3 (Rot2Cs (vec2 (abs (q.x), q.z - 0.8),\n         CosSin (-0.15 * pi)) + vec2 (0., 0.8), q.y).xzy, fSize), PrEllipsDf (q, fSize), 0.05);\n      DMINQ (idFoot);\n    }\n  } else dMin = min (dMin, d);\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin;\n  dMin = dstFar;\n  for (int j = VAR_ZERO; j < N_PENG; j ++) {\n    dMin = min (wlk[j].szFac * PengDf ((p - wlk[j].wPos) / wlk[j].szFac, dMin / wlk[j].szFac,\n       wlk[j]), dMin);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.001 || dHit > dstFar || p.y < 0.) break;\n    dHit += d;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 40; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = vec3 (0.75, 0.75, 0.8);\n  } else {\n    q = 0.01 * (ro.xz + 2. * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    sd = max (dot (rd, sunDir), 0.);\n    skCol = vec3 (0.3, 0.4, 0.8) + step (0.1, sd) * vec3 (1., 1., 0.9) *\n       min (0.3 * pow (sd, 64.) + 0.5 * pow (sd, 2048.), 1.);\n    col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return col;\n}\n\nfloat GrndHt (vec2 p)\n{\n  return 0.7 * Fbm2 (0.1 * p.yx);\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy),\n     GrndHt (p.xz + e.yx)), e.x)).xzy;\n}\n\nfloat FootSil (vec2 s)\n{\n  s.x = abs (s.x);\n  return min (length (vec2 (3.3, 1.) * (Rot2Cs (s + vec2 (0., 0.8),\n     CosSin (0.15 * pi)) - vec2 (0., 0.8))), length (vec2 (3.3, 1.) * s)) - 0.9;\n}\n\nfloat PengFoot (vec3 p)\n{\n  vec3 q;\n  float dMin, s;\n  dMin = 1.;\n  for (int j = VAR_ZERO; j < N_PENG; j ++) {\n    for (int k = 0; k < 2; k ++) {\n      if (mod (wlk[j].tPhs + float (2 * k), 4.) > 1.) {\n        s = sign (float (k) - 0.5);\n        dMin = min (dMin, FootSil (Rot2Cs (((p.xz - wlk[j].wPos.xz) / wlk[j].szFac +\n           vec2 (1.1 * s, wlk[j].leg[k].zFoot)), CosSin (-0.05 * pi * s))));\n      }\n    }\n    for (int k = 0; k < 2; k ++) {\n      q = p;\n      if (q.z < wlk[j].wPos.z) {\n        q.x -= wlk[j].wPos.x;\n        q /= wlk[j].szFac;\n        s = sign (float (k) - 0.5);\n        dMin = min (dMin, FootSil (Rot2Cs (vec2 (q.x + 1.1 * s, wlk[j].stride *\n           (fract ((q.z + (0.25 * s + 0.5) * wlk[j].stride - 0.3) /\n           wlk[j].stride + 0.5) - 0.5)), CosSin (-0.05 * pi * s))));\n      }\n    }\n  }\n  return 1. - smoothstep (0., 0.01, dMin);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, roo, colB;\n  float dstObj, dstGrnd, sh, nDotL, fadeFac;\n  fadeFac = SmoothBump (0.25, 0.75, 0.22, fract (0.03 * tCur));\n  fAng = -0.2 * pi + 0.15 * pi * SmoothBump (0.25, 0.75, 0.1, mod (0.2 * tCur, 1.)) *\n     sin (8. * pi * tCur);\n  SetWlkConf ();\n  roo = ro;\n  if (rd.y < 0.) {\n    dstGrnd = - ro.y / rd.y;\n    ro += dstGrnd * rd;\n    col = mix (vec3 (1., 1., 1.), vec3 (0.95, 0.97, 1.),\n       smoothstep (0.4, 0.6, Fbm2 (0.25 * ro.xz)));\n    col *= 1. - 0.2 * PengFoot (ro) * (1. - smoothstep (0.8, 1., dstGrnd / dstFar));\n    vn = GrndNf (ro);\n    isSh = true;\n    sh = (dstGrnd < dstFar) ? ObjSShadow (ro + 0.01 * vn, sunDir) : 1.;\n    sh = mix (sh, 1., min (1., 1.5 * fadeFac));\n    col *= 0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.);\n    col = mix (col, vec3 (0.2, 0.5, 0.9), 0.9 * pow (abs (rd.y), 12.));\n    if (dstGrnd >= dstFar) col = mix (col, vec3 (0.75, 0.75, 0.8), pow (1. + rd.y, 16.));\n  } else {\n    col = SkyBgCol (ro, rd);\n  }\n  colB = col;\n  ro = roo;\n  isSh = false;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    if (idObj == idBod) {\n      col4 = mix (vec4 (0.15, 0.15, 0.25, 0.1), vec4 (0.95, 0.95, 0.95, 0.05),\n         step (qHit.z, -1.3));\n      col4 = mix (vec4 (1., 0.9, 0., 0.2), col4, smoothstep (0., 0.05,\n         min (2.25 - qHit.y, abs (qHit.z + 1.2) - 0.15)));\n    } else if (idObj == idHead) {\n      col4 = (qHit.z < 0.5 && length (qHit.xy) < 0.4) ? vec4 (0.95, 0.95, 0.95, 0.05) :\n         vec4 (0.15, 0.15, 0.25, 0.1);\n      col4 = mix (vec4 (1., 0.9, 0., 0.2), col4, smoothstep (0., 0.05, qHit.y + 1.4));\n    } else if (idObj == idBk) {\n      col4 = vec4 (1., 0.8, 0.2, 0.2);\n    } else if (idObj == idEye) {\n      col4 = vec4 (0., 0., 0., -1.);\n    } else if (idObj == idLeg) {\n      col4 = vec4 (0.8, 0.8, 0.2, 0.2) * (0.8 + 0.2 * SmoothBump (0.1, 0.9, 0.05,\n         fract (8. * qHit.z)));\n    } else if (idObj == idFoot) {\n      col4 = vec4 (0.4, 0.4, 1., 0.2);\n    } else if (idObj == idFlp) {\n      col4 = mix (vec4 (0.95, 0.95, 0.95, 0.05), vec4 (0.15, 0.15, 0.25, 0.1),\n         step (-0.05, qHit.x));\n    }\n    vn = ObjNf (ro);\n  }\n  col = colB;\n  if (dstObj < dstFar) {\n    if (col4.a >= 0.) {\n      isSh = true;\n      sh = ObjSShadow (ro + 0.01 * vn, sunDir);\n      nDotL = max (dot (vn, sunDir), 0.);\n      nDotL *= nDotL;\n      col = col4.rgb * (0.2 + 0.1 * max (- dot (vn, sunDir), 0.) + 0.8 * sh * nDotL) +\n         col4.a * step (0.95, sh) * pow (max (dot (sunDir, reflect (rd, vn)), 0.), 32.);\n    } else col = mix (vec3 (0., 0.3, 0.), SkyBgCol (ro, reflect (rd, vn)), 0.5);\n    col = mix (col, colB, clamp (1.2 * fadeFac - 0.1 + 0.1 * (Fbm1 (16. * tCur) - 0.5), 0., 1.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur += 5.;\n  spd = 3.;\n  wPos = vec3 (0., 0., spd * tCur);\n  az = - pi;\n  el = -0.05 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  } else {\n    az +=  0.3 * pi * (2. * SmoothBump (0.25, 0.75, 0.22, fract (0.02 * tCur)) - 1.);\n  }\n  el = clamp (el, -0.3 * pi, -0.01 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = wPos + vuMat * vec3 (0., 3.5, -45.);\n  zmFac = 4.;\n  dstFar = 150.;\n  sunDir = vuMat * normalize (vec3 (0.5, 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}