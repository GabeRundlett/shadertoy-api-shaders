{
    "Shader": {
        "info": {
            "date": "1569905573",
            "description": "Jellyfish movement shader",
            "flags": 0,
            "hasliked": 0,
            "id": "3sKGzw",
            "likes": 9,
            "name": "Single Animated Jellyfish",
            "published": 3,
            "tags": [
                "animation",
                "jellyfish",
                "movement"
            ],
            "usePreview": 0,
            "username": "BradyInstead",
            "viewed": 471
        },
        "renderpass": [
            {
                "code": "\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat noise(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return ((2.2 * n_xyz)+1.)/2.;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nfloat bump(vec3 pos)\n{\n    vec3 npos = abs(sin(pos.xyz))*8. + iTime*.5;\n    float n = noise(npos);\n    return sin(n*10.);\n}\n\nvoid contrast( inout vec3 color, in float c) {\n    float t = 0.5 - c * 0.5; \n    color.rgb = color.rgb * c + t;\n}\n\nvec3 hueShift( vec3 color, float hueAdjust ){\n\n    const vec3  kRGBToYPrime = vec3 (0.299, 0.587, 0.114);\n    const vec3  kRGBToI      = vec3 (0.596, -0.275, -0.321);\n    const vec3  kRGBToQ      = vec3 (0.212, -0.523, 0.311);\n\n    const vec3  kYIQToR     = vec3 (1.0, 0.956, 0.621);\n    const vec3  kYIQToG     = vec3 (1.0, -0.272, -0.647);\n    const vec3  kYIQToB     = vec3 (1.0, -1.107, 1.704);\n\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I       = dot (color, kRGBToI);\n    float   Q       = dot (color, kRGBToQ);\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    hue += hueAdjust;\n\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    vec3    yIQ   = vec3 (YPrime, I, Q);\n\n    return vec3( dot (yIQ, kYIQToR), dot (yIQ, kYIQToG), dot (yIQ, kYIQToB) );\n\n}\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat noise(float p){\n\tfloat fl = floor(p);\n  float fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\n\nfloat capsule( vec3 p, vec3 a, vec3 b, float r , float nmod)\n{\n    p.x += sin(p.y*2. + iTime*3.)*.2;\n    p.z += cos(p.y*2. + iTime*3.)*.2;\n    \n    float shaping = .05*abs(sin(iTime*3. + p.x + p.z + p.y*4. + p.z))*nmod;\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r + shaping;\n}\n\nfloat sphere(vec3 p)\n{\n    //p.y *= 1.25;\n    float shaping = .1*abs(sin(3.36 + p.x + p.z + p.y*4.));\n    return length(p + bump(p)*.006) - .6+shaping;\n}\n\nfloat torus( vec3 p, vec2 t )\n{\n   \tp.y *= .4;\n  \tvec2 q = vec2(length(p.xz)-t.x,p.y);\n  \treturn length(q)-t.y;\n}\n\nfloat model(vec3 p)\n{\n    //p = opRep(p, vec3(10.));\n    p*=.45;\n    p.y -= 1.25;\n    \n    p.y += sin(iTime*3. + p.y*3.)*.075;\n    p.x += sin(iTime*3. + p.y*3.)*.05;\n    p.z += sin(iTime*3. + p.y*3.)*.05;\n    \n    // head\n    float head = sphere(p);\n    float torus = torus(p + vec3(0., .1 + sin(iTime*3.)*.05, 0.), vec2(.65, .05));\n    \n    head = opSmoothUnion(head, torus, .2);\n    \n    // tentacles\n    vec3 cp = p + vec3(0., -.0, 0.);\n    \n    float tent = capsule(cp + vec3(-.2, .15, .2), vec3(0.), vec3(0., -3., 0.), .2, 2.);\n    tent = min(tent, capsule(cp + vec3(.2, .15, .2), vec3(0.), vec3(0., -3., 0.), .2, 2.));\n    tent = min(tent, capsule(cp + vec3(.2, .15, -.2), vec3(0.), vec3(0., -3., 0.), .2, 2.));\n    \n    for(float i = 0.; i < 15.; i++)\n    {\n    \ttent = min(tent, capsule(cp, vec3(0.), vec3(sin(i + rand(i*10.)), -2., cos(i + rand(i))), .075, 1.));\n    }\n    \n    return opSmoothUnion(tent*.9, head, .1);\n}\n\nfloat raymarch(in vec3 ro, in vec3 rd)\n{\n    float dist = 0.;\n    for(int i = 0; i < 90; i++)\n    {\n\t\tfloat m = model(ro+rd*dist);\n        dist += m;\n        \n        if(m < .01) return dist;\n        else if(dist > 20.) break;\n    }\n    return -1.;\n}\n\nvec3 normal(vec3 pos)\n{\n    vec3 eps = vec3(.01, -.01, 0.);\n    \n    return normalize(vec3(\n        model(pos + eps.xzz) - model(pos + eps.yzz),\n        model(pos + eps.zxz) - model(pos + eps.zyz),\n        model(pos + eps.zzx) - model(pos + eps.zzy)));\n}\n\nfloat shadow(in vec3 pos, in vec3 ld)\n{\n    float spread = 3.;\n    float res = 1.0;\n\tfor(float t = .2; t < .4;)\n    {\n        float dist = model(pos+ld*t);\n        if(dist<.001) return 0.;\n        res = min(res, spread*dist/t);\n        t += dist;\n    }\n    return res;\n}\n\nvec3 background()\n{\n    return vec3(.15, .05, .3);\n}\n\nvec3 shade(vec3 pos, vec3 nor, vec3 rd, float dist, vec3 ro)\n{\n    if(dist < 0.) return background();\n    \n    //vec3 ld = .6 * vec3(sin(iTime*.5 + .75), 1., cos(iTime*.5 + .75));\n    vec3 ld = normalize(ro + vec3(1.));\n    \n    float dif = max(dot(nor,ld), 0.)*.6;\n    float sha = 0.;\n    if(dif > .01) sha = shadow(pos, ld);\n    vec3 lin = vec3(dif*sha);\n    \n    // add color\n    vec3 col1 = vec3(.2, .9, .8);\n    vec3 col2 = vec3(.0, 0.3, .6);\n    vec3 col = mix(col1, col2, lin)*.75;\n    \n    // bump & shift\n    //float bump = bump(pos);\n    //col = hueShift(col, bump*.25 + .75);\n    //col.bg *= 2. + pow(1., 2.0)*.2;\n    \n    //col = hueShift(col, 4.25);\n    //col = min(col*1.5, vec3(1.));\n    //col *= pow(exp(-.02*dist*dist), .2);\n    //col = pow(col, vec3(1.5));\n    //col.rgb = mix(background(), col, exp(-.003*dist*dist)*1.0).rgb;\n    \n    //col *= 1.2;\n    \n    contrast(col, 1.5);\n    \n    col*=1.5;\n    \n    //col.rb *= .9;\n    \n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    p += noise(vec3(p.x*5., p.y*5., iTime))*.05;\n    \n    //vec3 ro = vec3(sin(iTime*.5), 1., cos(iTime*.5))*7.;\n    //vec3 ro = vec3(6.);\n    vec3 ta = vec3(0., 0., 0.);\n    \n    vec3 ro = vec3(cos(iTime/2.), 1., sin(iTime/2.))*7.;\n    \n    vec3 w = normalize (ta-ro);\n    vec3 u = normalize (cross (w, vec3(0., 1., 0.)));\n    vec3 v = normalize (cross (u, w));\n    mat3 mat = mat3(u, v, w);\n    vec3 rd = normalize (mat*vec3(p.xy,1.));\n    \n    float dist = raymarch(ro, rd);\n    vec3 pos = ro+rd*dist;\n    vec3 nor = normal(pos);\n    \n    vec3 col = shade(pos, nor, rd, dist, ro);\n    col = vec3(dot(col.rgb, vec3(0.299, 0.587, 0.114)));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}