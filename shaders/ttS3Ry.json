{
    "Shader": {
        "info": {
            "date": "1559996540",
            "description": "A game where a screenshot of it will give you zero information about the game state.\nYour infer shapes from the patters of movement.\n\nControls:\nReset: Space\nP1: up/down arrow\nP2: \"W\" / \"S\"\nSingleplayer: \"1\"\nMultiplayer: \"2\"",
            "flags": 48,
            "hasliked": 0,
            "id": "ttS3Ry",
            "likes": 5,
            "name": "Anti-Screenshot Pong",
            "published": 3,
            "tags": [
                "game",
                "pong"
            ],
            "usePreview": 0,
            "username": "qwert33",
            "viewed": 617
        },
        "renderpass": [
            {
                "code": "// Postprocess to give black/white a different movement characteristic.\n\nfloat space;\nfloat time;\n\n// Code made by Dominik Schmid (DominikSchmid93@gmail.com)\n// All rights reserved.\n// I'm willing to give permission but you need to request it.\n\n//======= configuration ======\nconst bool stars              = true;  // whether to postprocess\nconst bool antialiasing       = !stars;  // performance / quality tradeoff\nconst float star_brightness   = 0.5;\nconst float period_animating  = 7.0;\nconst float period_paused     = 3.0;  // set to 0.0 for continuous spinning\nconst float noise_speed       = 1.04;\nconst float noise_period      = 2.0;\nconst float symbol_spin_speed = 0.5;\nconst float symbol_size       = 0.47;\nconst float vignette_strength = 1.8;\n//============================\n\n\n\n\nfloat semiCircle(float x) {\n    x = (2.0 * x - 1.0);\n    return sqrt(1.0 - x*x);\n}\n\n\nfloat rand(vec2 p){\n    p /= iResolution.xy;\n    return fract(sin(dot(p.xy, vec2(12.9898, 78.2377))) * 43758.5453);\n}\n\n\n// makes a rotation matrix\nmat2 rotate(float theta) {\n    float s = sin(theta);\n    float c = cos(theta);\n    return mat2(\n        c, -s,\n        s,  c\n    );\n}\n\n// magic function to make a bending curve\nfloat twang(float x, float d) {\n    return (\n        (x * (d*d*d + d)) /\n        (d * (d*d + abs(x)))\n    );\n}\n\n// clamps to 0..1\nfloat clamp01(float x) {\n    return max(0.0, min(1.0, x));\n}\n\n// maps from pixel coordinate frame to UV coordinate frame\nvec2 toSpace_uv(vec2 space_pixel) {\n    return space_pixel.xy / space;\n}\n\nfloat getNoise(vec2 noiseCoord, float angleOffset, float noiseSeed, float r) {\n    float angle = 10. * time;\n    //if (fract(time / 2.) > .5) noiseCoord += vec2(100.);\n    angle += angleOffset;\n    r *= space;\n    noiseCoord += vec2(\n        floor(r * sin(angle)),\n        floor(r * cos(angle))\n    );\n    //noiseCoord *= rotate(floor(time*2.));\n\n    noiseCoord.x += noiseSeed;\n    \n    return rand(noiseCoord);    \n}\n\n\n// --- access to the image of ascii code c from Fabrice \nvec4 char(vec2 pos, float c) {\n    pos = clamp(pos,0.,1.);  // would be more efficient to exit if out.\n\n    vec4 tx = texture( iChannel2, pos/16. + fract( floor(vec2(c, 15.999-c/16.)) / 16. ) )*2. ;\n    vec4 ty = texture( iChannel2, pos/16.012 + fract( floor(vec2(c, 15.999-c/16.012)) / 16.012 ) )/3.0 ;\n    return .5*(tx+ty).xxxx;\n}\n\nbool KeyPressed(int key)\n{ \n    return texelFetch(iChannel1, ivec2(key,0.0), 0 ).x > 0.5;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    space = min(iResolution.x, iResolution.y);\n    time = iTime;\n    \n    vec2 pix = fragCoord;\n    vec2 uv = toSpace_uv(pix.xy);//(p.xy - iResolution.xy / 2.0) / space;\n    uv -= toSpace_uv(iResolution.xy / 2.0);\n    // uv += toSpace_uv(vec2(sin(time), 0.0)); // minor wobble to test antialiasing\n    \n    \n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec3 oricol = texture( iChannel0, vec2(q.x,q.y) ).xyz;\n    fragColor = vec4(oricol,1.0);\n    \n    float layer = oricol.r;\n    \n    float layer0 = !stars? 0.0 : getNoise(pix, radians(  0.0), 0.0, 0.021*noise_speed);\n    float layer1 = !stars? 1.0 : getNoise(pix, radians(180.0), 0.5, .02*noise_speed);\n    float brightness = mix(layer0, layer1, layer);\n\n    if (stars) {\n        brightness = 1.0 - twang(1.0 - brightness, star_brightness); // make stars less bright if we have more pixels\n        if (brightness>.9) brightness *= 2.0;\n    }\n    fragColor = vec4(brightness);\n    \n    if (stars) {\n        // apply some post-processing\n        fragColor *= vec4(0.8, 1.0, 0.9, 1.0);\n        fragColor *= pow(vignette_strength, -length(uv));  // vignette\n    }\n    \n    // Show instructions\n    if ((KeyPressed(KEY_1) || KeyPressed(KEY_2) || KeyPressed(KEY_0)) && abs(uv.x) > .4) {\n        fragColor = vec4(0.);\n        if (KeyPressed(KEY_0)) return;\n    \tfragColor += char((fragCoord - vec2(0.,iResolution.y*.6)) * .01, 87.);\n    \tfragColor += char((fragCoord - vec2(0.,iResolution.y*.2)) * .01, 83.);\n        \n        float x = KeyPressed(KEY_2)? .85 : .1;\n    \tfragColor += char((fragCoord - vec2(iResolution.x * x, iResolution.y*.6)) * .01, 17.);\n    \tfragColor += char((fragCoord - vec2(iResolution.x * x, iResolution.y*.2)) * .01, 19.);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Pong code adapted from https://www.shadertoy.com/view/Ws2GD1\n\n\nconst float GameSpeedMultiplier = 0.35;\nconst float InputSpeed = 2.0 * GameSpeedMultiplier;\nconst float BallSpeed = 1.5 * GameSpeedMultiplier;\nconst float BallSpeedIncreasePerSecond = 0.2 * GameSpeedMultiplier;\nconst float SpeedLimit = 3.9 * GameSpeedMultiplier;\n\nconst float PlayerPaddleXPos = -0.85;\nconst float GpuPaddleXPos = 0.85;\n\nfloat Hash( in float n )\n{\n    return fract(sin(n)*138.5453123);\n}\n\nvoid StoreValue( in ivec2 txPos, in vec4 value, inout vec4 fragColor, in ivec2 fragPos )\n{\n    fragColor = (fragPos==txPos) ? value : fragColor;\n}\n\nbool KeyPressed(int key)\n{ \n    return texelFetch(iChannel1, ivec2(key,0.0), 0 ).x > 0.5;\n}\n\nvoid UpdatePaddlePos(in float moveUp, in float moveDown, float limits, float totalHalfPaddleHeight, inout vec2 paddlePos)\n{\n    paddlePos.y += iTimeDelta * InputSpeed * (moveUp - moveDown);\n    paddlePos.y = clamp(paddlePos.y, -limits + totalHalfPaddleHeight, limits - totalHalfPaddleHeight);\n}\n\nfloat GetSpeed(in float pointStartTime)\n{\n    return clamp(0.0, SpeedLimit, BallSpeed + (iTime - pointStartTime) * BallSpeedIncreasePerSecond);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iCurPixel = ivec2(fragCoord-0.5);\n \n    // don't compute gameplay outside of the data area\n    if (fragCoord.x > float(TX_DATA_SIZE.x) || fragCoord.y > float(TX_DATA_SIZE.y)) discard;\n    \n    // load game state\n    vec2 playerPaddlePos = LoadValue(iChannel0, txPlayerPaddlePos).xy;\n    vec2 gpuPaddlePos = LoadValue(iChannel0, txGPUPaddlePos).xy;\n    vec4 ballPosDir = LoadValue(iChannel0, txBallPosDir);\n    vec2 score = LoadValue(iChannel0, txScore).xy;\n    vec3 state = LoadValue(iChannel0, txState).xyz;\n    float numPlayers = LoadValue(iChannel0, txNumPlayers).x;\n    \n    if(iFrame == 0)\n    {\n        ballPosDir = vec4(0.0, 0.0, 0.0, 0.0);\n        playerPaddlePos = vec2(PlayerPaddleXPos, 0.0);\n        gpuPaddlePos = vec2(GpuPaddleXPos, 0.0);\n        state.x = -1.0;\n        state.z = 1.0;\n        score = vec2(0, 0);\n        numPlayers = 1.0;\n    }\n    \n    bool startNew = state.x < -0.5 && (KeyPressed(KEY_SPACE) || numPlayers < .5);\n    if (KeyPressed(KEY_0) || KeyPressed(KEY_1) || KeyPressed(KEY_2)) {\n        startNew = true;\n        if (KeyPressed(KEY_0)) numPlayers = 0.;\n        if (KeyPressed(KEY_1)) numPlayers = 1.;\n        if (KeyPressed(KEY_2)) numPlayers = 2.;\n    }\n    \n    if(startNew) {\n        ballPosDir.xy = vec2(0.0, 0.0);\n        ballPosDir.zw = normalize(vec2(state.z, Hash(float(iFrame) * 1.5) * 0.25));\n        state.x = 0.0;\n        state.y = iTime;    \n        gpuPaddlePos.y = 0.0;\n        playerPaddlePos.y = 0.0;\n    }\n    else if (state.x < -0.5) {}\n    else\n    {        \n        float limits = HalfFieldHeight - HalfWallWidth;\n        float totalHalfPaddleHeight = PaddleHalfSize.y;\n        \n        \n        // Update player paddle position\n        float moveUp; \n        float moveDown;\n        if (numPlayers < .5) {\n        \tmoveUp = step(0.0, ballPosDir.y - (playerPaddlePos.y + totalHalfPaddleHeight));\n            moveDown = step(0.0, (playerPaddlePos.y - totalHalfPaddleHeight) - ballPosDir.y);\n        } else {\n            moveUp = KeyPressed(KEY_W) || (numPlayers < 1.5 && KeyPressed(KEY_UP)) ? 1. : 0.;\n            moveDown = KeyPressed(KEY_S) || (numPlayers < 1.5 && KeyPressed(KEY_DOWN)) ? 1. : 0.;\n        }\n        UpdatePaddlePos(moveUp, moveDown, limits, totalHalfPaddleHeight, playerPaddlePos);\n        \n        // Update GPU paddle position\n        if (numPlayers > 1.5) {\n            moveUp = texelFetch(iChannel1, ivec2(KEY_UP, 0), 0).x;\n            moveDown  = texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).x;\n        } else {\n            moveUp = step(0.0, ballPosDir.y - (gpuPaddlePos.y + totalHalfPaddleHeight));\n            moveDown = step(0.0, (gpuPaddlePos.y - totalHalfPaddleHeight) - ballPosDir.y);\n        }\n        \n        UpdatePaddlePos(moveUp, moveDown, limits, totalHalfPaddleHeight, gpuPaddlePos);\n        \n        // Update ball position\n        //@{\n        ballPosDir.xy += ballPosDir.zw * GetSpeed(state.y) * iTimeDelta;\n        \n        // Bound with limits\n        if(ballPosDir.y + BallRadius >= limits)\n        {\n            ballPosDir.y = limits - BallRadius;\n            ballPosDir.w *= -1.0;\n        }\n        else if(ballPosDir.y - BallRadius <= -limits)\n        {\n            ballPosDir.y = BallRadius - limits;\n            ballPosDir.w *= -1.0;\n        }\n        \n        if(ballPosDir.x + BallRadius >= (gpuPaddlePos.x - PaddleHalfSize.x))\n        {\n            if(abs(ballPosDir.y - gpuPaddlePos.y) <= totalHalfPaddleHeight + BallRadius)\n            {\n                ballPosDir.x = gpuPaddlePos.x - PaddleHalfSize.x - BallRadius;\n                ballPosDir.z *= -1.0;\n                ballPosDir.w += (ballPosDir.y - gpuPaddlePos.y) * 5.0;\n                ballPosDir.zw = normalize(ballPosDir.zw);\n            }\n        }\n        else if(ballPosDir.x - BallRadius <= playerPaddlePos.x + PaddleHalfSize.x)\n        {\n            if(abs(ballPosDir.y - playerPaddlePos.y) <= totalHalfPaddleHeight + BallRadius)\n            {\n                ballPosDir.x = playerPaddlePos.x + PaddleHalfSize.x + BallRadius;\n                ballPosDir.z *= -1.0;\n                ballPosDir.w += (ballPosDir.y - playerPaddlePos.y) * 5.0;\n                ballPosDir.zw = normalize(ballPosDir.zw);\n            }\n        }\n        //@} \n           \n        // Check score\n        if(ballPosDir.x - BallRadius > gpuPaddlePos.x)\n        {\n            score.x += 1.0;\n            state.x = -1.0;\n            state.z = -1.0;\n        }\n        else if(ballPosDir.x + BallRadius < playerPaddlePos.x)\n        {\n            score.y += 1.0;\n            state.x = -1.0;\n            state.z = 1.0;\n        }\n    }\n    \n    fragColor = vec4(0.0);\n    \n    StoreValue(txPlayerPaddlePos, vec4(playerPaddlePos, 0.0, 0.0), fragColor, iCurPixel);\n    StoreValue(txGPUPaddlePos, vec4(gpuPaddlePos, 0.0, 0.0), fragColor, iCurPixel);\n    StoreValue(txBallPosDir, ballPosDir, fragColor, iCurPixel);\n    StoreValue(txScore, vec4(score, 0.0, 0.0), fragColor, iCurPixel);\n    StoreValue(txState, vec4(state, 0.0), fragColor, iCurPixel);    \n    StoreValue(txNumPlayers, vec4(numPlayers, 0., 0., 0.), fragColor, iCurPixel);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const float Thickness = 0.001;\n\nconst vec3 BallColor = vec3(1.0, 1.0, 1.0);\nconst vec3 PaddleColor = vec3(1.0, 1.0, 1.0);\nconst vec3 BorderColor = vec3(1.0, 1.0, 1.0);\n\n// Digit data by P_Malin (https://www.shadertoy.com/view/4sf3RN)\nconst int[] font = int[](0x75557, 0x22222, 0x74717, 0x74747, 0x11574, 0x71747, 0x71757, 0x74444, 0x75757, 0x75747);\nconst int[] powers = int[](1, 10, 100, 1000, 10000);\nfloat PrintInt( in vec2 uv, in int value )\n{\n    const int maxDigits = 2;\n    if( abs(uv.y-0.5)<0.5 )\n    {\n        int iu = int(floor(uv.x));\n        if( iu>=0 && iu<maxDigits )\n        {\n            int n = (value/powers[maxDigits-iu-1]) % 10;\n            uv.x = fract(uv.x);//(uv.x-float(iu)); \n            ivec2 p = ivec2(floor(uv*vec2(4.0,5.0)));\n            return float((font[n] >> (p.x+p.y*4)) & 1);\n        }\n    }\n    return 0.0;\n}\n\nfloat sdSquare(in vec2 p, in vec2 pos, in vec2 size)\n{\n    vec2 d = abs(p - pos) - size;\n    return length(max(d,0.0));\n}\n\nvec3 RenderBall(vec2 pos, vec2 ballPos, vec3 col)\n{\n    float t = sdSquare(pos, ballPos, vec2(BallRadius, BallRadius));\n    return mix(BallColor, col, smoothstep(0.0, Thickness, t));\n}\n\nvec3 RenderPaddle(vec2 pos, vec2 paddlePos, vec3 col)\n{\n    //float t = SegmentMask(pos, paddlePos - vec2(0.0, PaddleHalfSize.y), paddlePos + vec2(0.0, PaddleHalfSize.y), PaddleHalfSize.x);\n    float t = sdSquare(pos, paddlePos, PaddleHalfSize);\n    \n    return mix(PaddleColor, col, smoothstep(0.0, Thickness, t));\n}\n\nvec3 RenderBorders(in vec2 pos, in float distToCenter, in vec3 col)\n{\n    float t = abs(abs(pos.y) - distToCenter) / HalfWallWidth;\n    \n    return mix(BorderColor, col, smoothstep(0.0, Thickness, t - 1.0));\n}\n\nvec3 RenderScore(in vec2 score, in vec2 fragCoord, in vec3 col)\n{\n    const vec2 displacement = vec2(0.3, -0.65);\n    vec2 uv = (2.0*fragCoord-iResolution.xy) / iResolution.y;\n    \n    col = mix(col, vec3(1.0, 1.0, 1.0), PrintInt((uv + displacement) * vec2(10.0, 7.0), int(score.x)));\n    col = mix(col, vec3(1.0, 1.0, 1.0), PrintInt((uv + displacement * vec2(-0.4, 1.0)) * vec2(10.0, 7.0), int(score.y)));\n    \n    return col;\n}\n\nvec3 RenderCenterLine(in vec2 pos, in float limitsDistToCenter, in vec3 col)\n{\n    float t = abs(pos.x) - 0.003;\n    float dashT = step(0.0, sin(pos.y * 200.0));\n    float limitsT = (abs(pos.y) - limitsDistToCenter);\n    \n    col = mix(vec3(1.0, 1.0, 1.0), col, smoothstep(0.0, Thickness, max(t, limitsT) + dashT));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    pos.y *= iResolution.y / iResolution.x;  \n    \n     // load game state\n    vec2 playerPaddlePos = LoadValue(iChannel0, txPlayerPaddlePos).xy;\n    vec2 gpuPaddlePos = LoadValue(iChannel0, txGPUPaddlePos).xy;\n    vec2 ballPos = LoadValue(iChannel0, txBallPosDir).xy;\n    vec2 score = LoadValue(iChannel0, txScore).xy;\n    \n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n    col = RenderBall(pos, ballPos, col);\n    col = RenderPaddle(pos, playerPaddlePos, col);\n    col = RenderPaddle(pos, gpuPaddlePos, col);\n    col = RenderBorders(pos, HalfFieldHeight, col);\n    col = RenderCenterLine(pos, HalfFieldHeight, col);\n    col = RenderScore (score, fragCoord, col);\n    \n    \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const ivec2 txPlayerPaddlePos = ivec2(0,0);\nconst ivec2 txGPUPaddlePos = ivec2(1,0);\nconst ivec2 txBallPosDir = ivec2(2,0);\nconst ivec2 txScore = ivec2(3,0);\nconst ivec2 txState = ivec2(4,0);\nconst ivec2 txNumPlayers = ivec2(5, 0);\nconst ivec2 TX_DATA_SIZE = ivec2(6, 1);\n\n\nconst int KEY_SPACE = 32;\nconst int KEY_UP  = 38;\nconst int KEY_DOWN = 40;\nconst int KEY_W  = 87;\nconst int KEY_S = 83;\nconst int KEY_0 = 48;\nconst int KEY_1 = 49;\nconst int KEY_2 = 50;\n\n\nconst vec2 PaddleHalfSize = vec2(0.025, 0.08);\nconst float HalfWallWidth = 0.01;\nconst float BallRadius = 0.025;\nconst float HalfFieldHeight = 0.53;\n\nvec4 LoadValue( in sampler2D iChannel, in ivec2 re )\n{\n    return texelFetch( iChannel, re, 0 );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}