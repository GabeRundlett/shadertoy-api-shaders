{
    "Shader": {
        "info": {
            "date": "1500553223",
            "description": "Floating aimlessly down the river.\nWASD to steer / throttle\nmouse to rotate camera\nMuch as I'd like to, I can't make further changes to this shader as I'm on holiday. Have fun with the competition!\n",
            "flags": 112,
            "hasliked": 0,
            "id": "ldjfDD",
            "likes": 35,
            "name": "[SH17B] Adrift",
            "published": 3,
            "tags": [
                "river",
                "boat",
                "sh17b"
            ],
            "usePreview": 1,
            "username": "P_Malin",
            "viewed": 2605
        },
        "renderpass": [
            {
                "code": "// [SH17B] Adrift - https://www.shadertoy.com/view/ldjfDD\n// @P_Malin\n\n// Entry for Round 2 of the 2017 Shadertoy competition https://www.shadertoy.com/events/competition\n\n// Floating aimlessly down the river.\n// WASD to steer / throttle\n// mouse to rotate camera\n// G toggles gravity\n// . , spin\n\n// A mashup of two of my old shaders \n// \"shader rally\" - https://www.shadertoy.com/view/XdcGWS\n// \"where the river goes\" - https://www.shadertoy.com/view/XdG3zd\n\n#define ENABLE_WATER\n#define ENABLE_FOAM\n#define ENABLE_WATER_RECEIVE_SHADOW\n\n\n//#define ENABLE_LANDSCAPE_RECEIVE_SHADOW\n\nconst int k_raymarchSteps = 64;\n\n\n//#if ( __VERSION__ < 300 )\n//#endif\n\n#define iChannelSim iChannel2\n\n///////////////////////////\n///////////////////////////\n// Common\n///////////////////////////\n///////////////////////////\n\n\n/////////////////////////\n// Constants\n\nfloat PI = acos(-1.0);\n\n/////////////////////////\n// Storage\n\nvec4 LoadVec4( in ivec2 vAddr )\n{\n    return texelFetch( iChannelSim, vAddr, 0 );\n}\n\nvec3 LoadVec3( in ivec2 vAddr )\n{\n    return LoadVec4( vAddr ).xyz;\n}\n\nbool AtAddress( vec2 p, ivec2 c ) { return all( equal( floor(p), vec2(c) ) ); }\n\nvoid StoreVec4( in ivec2 vAddr, in vec4 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in ivec2 vAddr, in vec3 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n\n/////////////////////////\n\n// Keyboard \n\n\n// Keyboard constants definition\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\nconst int KEY_COMMA = 188;\nconst int KEY_PER   = 190;\n\nbool KeyIsPressed(int key)\n{\n\treturn texelFetch( iChannel1, ivec2(key, 0), 0 ).x > 0.0;\n}\n\nbool KeyIsToggled(int key)\n{\n\treturn texelFetch( iChannel1, ivec2(key, 2), 0 ).x > 0.0;\n}\n\n/////////////////////////\n// Rotation\n\nvec2 Rotate( const in vec2 vPos, const in float t )\n{\n    float s = sin(t);\n    float c = cos(t);\n    \n    return vec2( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y);\n}\n\nvec3 RotX( const in vec3 vPos, float t )\n{\n    vec3 result;\n    result.x = vPos.x;\n  \tresult.yz = Rotate( vPos.yz, t );\n    return result;\n}\n\nvec3 RotY( const in vec3 vPos, float t )\n{\n    vec3 result;\n    result.y = vPos.y;\n  \tresult.xz = Rotate( vPos.xz, t );\n    return result;\n}\n\nvec3 RotZ( const in vec3 vPos, float t )\n{\n    vec3 result;\n    result.z = vPos.z;\n  \tresult.xy = Rotate( vPos.xy, t );\n    return result;\n}\n\n\n/////////////////////////\n// Vec\n\nvec3 Vec3Parallel( vec3 x, vec3 n )\n{\n    float d = dot( x, n );\n    \n    return x - n * d;    \n}\n\nvec3 Vec3Perp( vec3 x, vec3 n )\n{\n    return x - Vec3Parallel( x, n );\n}\n\n/////////////////////////\n// Quaternions\n\nvec4 QuatMul(const in vec4 lhs, const in vec4 rhs) \n{\n      return vec4( lhs.y*rhs.z - lhs.z*rhs.y + lhs.x*rhs.w + lhs.w*rhs.x,\n                   lhs.z*rhs.x - lhs.x*rhs.z + lhs.y*rhs.w + lhs.w*rhs.y,\n                   lhs.x*rhs.y - lhs.y*rhs.x + lhs.z*rhs.w + lhs.w*rhs.z,\n                   lhs.w*rhs.w - lhs.x*rhs.x - lhs.y*rhs.y - lhs.z*rhs.z);\n}\n\nvec4 QuatFromAxisAngle( vec3 vAxis, float fAngle )\n{\n\treturn vec4( normalize(vAxis) * sin(fAngle), cos(fAngle) );    \n}\n\nvec4 QuatFromVec3( vec3 vRot )\n{\n    float l = length( vRot );\n    if ( l <= 0.0 )\n    {\n        return vec4( 0.0, 0.0, 0.0, 1.0 );\n    }\n    return QuatFromAxisAngle( vRot, l );\n}\n\nmat3 QuatToMat3( const in vec4 q )\n{\n\tvec4 qSq = q * q;\n\tfloat xy2 = q.x * q.y * 2.0;\n\tfloat xz2 = q.x * q.z * 2.0;\n\tfloat yz2 = q.y * q.z * 2.0;\n\tfloat wx2 = q.w * q.x * 2.0;\n\tfloat wy2 = q.w * q.y * 2.0;\n\tfloat wz2 = q.w * q.z * 2.0;\n \n\treturn mat3 (\t\n     qSq.w + qSq.x - qSq.y - qSq.z, xy2 - wz2, xz2 + wy2,\n     xy2 + wz2, qSq.w - qSq.x + qSq.y - qSq.z, yz2 - wx2,\n     xz2 - wy2, yz2 + wx2, qSq.w - qSq.x - qSq.y + qSq.z );\n}\n\nvec3 QuatMul( vec3 v, vec4 q )\n{\n    // TODO Validate vs other quat code\n    vec3 t = 2.0 * cross(q.xyz, v);\n\treturn v + q.w * t + cross(q.xyz, t);\n}\n\nvec3 ObjToWorld( vec3 v, mat3 m )\n{\n    return v * m;\n}\n\nvec3 WorldToObj( vec3 v, mat3 m )\n{\n    return m * v;\n}\n\n///////////////////\n// Random\n\n#define MOD2 vec2(4.438975,3.972973)\n\nfloat Hash( float p ) \n{\n    // https://www.shadertoy.com/view/4djSRW - Dave Hoskins\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);    \n\t//return fract(sin(n)*43758.5453);\n}\n\nfloat SmoothNoise(in vec2 o) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat a = Hash(n+  0.0);\n\tfloat b = Hash(n+  1.0);\n\tfloat c = Hash(n+ 57.0);\n\tfloat d = Hash(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n    return res;\n}\n\nconst int k_fbmSteps = 3;\nconst int k_fbmWaterSteps = 4;\n\nfloat FBM( vec2 p, float ps ) {\n\tfloat f = 0.0;\n    float tot = 0.0;\n    float a = 1.0;\n    for( int i=0; i<k_fbmSteps; i++)\n    {\n        f += SmoothNoise( p ) * a;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f / tot;\n}\n\nfloat FBM_Simple( vec2 p, float ps ) {\n\tfloat f = 0.0;\n    float tot = 0.0;\n    float a = 1.0;\n    for( int i=0; i<3; i++)\n    {\n        f += SmoothNoise( p ) * a;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f / tot;\n}\n\nvec3 SmoothNoise_DXY(in vec2 o) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat a = Hash(n+  0.0);\n\tfloat b = Hash(n+  1.0);\n\tfloat c = Hash(n+ 57.0);\n\tfloat d = Hash(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\tvec2 dt = 6.0 * f - 6.0 * f2;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\tfloat du = dt.x;\t\n\tfloat dv = dt.y;\t\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n\tfloat dx = (b-a)*du + (a-b+d-c)*du*v;\n\tfloat dy = (c-a)*dv + (a-b+d-c)*u*dv;    \n    \n    return vec3(dx, dy, res);\n}\n\n#ifdef ENABLE_WATER\nvec3 FBM_DXY( vec2 p, vec2 flow, float ps, float df ) {\n\tvec3 f = vec3(0.0);\n    float tot = 0.0;\n    float a = 1.0;\n    //flow *= 0.6;\n    for( int i=0; i<k_fbmWaterSteps; i++)\n    {\n        p += flow;\n        flow *= -0.75; // modify flow for each octave - negating this is fun\n        vec3 v = SmoothNoise_DXY( p );\n        f += v * a;\n        p += v.xy * df;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f / tot;\n}\n#endif\n\nfloat GetRiverMeander( const float x )\n{\n    return sin(x * 0.3) * 1.5;\n}\n\nfloat GetRiverMeanderDx( const float x )\n{\n    return cos(x * 0.3) * 1.5 * 0.3;\n}\n\nfloat GetRiverBedOffset( const vec3 vPos )\n{\n    float fRiverBedDepth = 0.3 + (0.5 + 0.5 * sin( vPos.x * 0.001 + 3.0)) * 0.4;\n    float fRiverBedWidth = 2.0 + cos( vPos.x * 0.1 ) * 1.0;;\n    \n    float fRiverBedAmount = smoothstep( fRiverBedWidth, fRiverBedWidth * 0.5, abs(vPos.z - GetRiverMeander(vPos.x)) );\n        \n    return fRiverBedAmount * fRiverBedDepth;    \n}\n\nfloat kSceneScale = 10.;\n\nfloat GetTerrainHeight( vec3 vPos )\n{   \n    vPos /=  kSceneScale;\n    float fbm = FBM( vPos.xz * vec2(0.5, 1.0), 0.5 );\n    float fTerrainHeight = fbm * fbm; \n    fTerrainHeight -= GetRiverBedOffset(vPos);\n        \n    return fTerrainHeight * kSceneScale;\n}\n\nfloat GetTerrainHeightSimple( vec3 vPos )\n{    \n    vPos /=  kSceneScale;\n    \n    float fbm = FBM_Simple( vPos.xz * vec2(0.5, 1.0), 0.5 );\n    float fTerrainHeight = fbm * fbm;\n    \n    fTerrainHeight -= GetRiverBedOffset(vPos);\n        \n    return fTerrainHeight * kSceneScale;\n}\n\nfloat GetFlowDistance( const vec2 vPos )\n{\n    return -GetTerrainHeightSimple( vec3( vPos.x, 0.0, vPos.y ) );\n}\n\nvec2 GetBaseFlow( const vec2 vPos )\n{\n    return vec2( 1.0, GetRiverMeanderDx(vPos.x) );\n}\n\nvec2 GetGradient( const vec2 vPos )\n{\n    vec2 vDelta = vec2(0.01, 0.00);\n    float dx = GetFlowDistance( vPos + vDelta.xy ) - GetFlowDistance( vPos - vDelta.xy );\n    float dy = GetFlowDistance( vPos + vDelta.yx ) - GetFlowDistance( vPos - vDelta.yx );\n    return vec2( dx, dy );\n}\n\nvec3 GetFlowRate( vec2 vPos )\n{\n    vPos /= kSceneScale;\n    vec2 vBaseFlow = GetBaseFlow( vPos );\n\n    vec2 vFlow = vBaseFlow;\n    \n    float fFoam = 0.0;\n\n\tfloat fDepth = -GetTerrainHeightSimple( vec3(vPos.x, 0.0, vPos.y) * kSceneScale );\n    float fDist = GetFlowDistance( vPos * kSceneScale ) / kSceneScale;\n    vec2 vGradient = GetGradient( vPos * kSceneScale );\n    \n    vFlow += -vGradient * 40.0 / (1.0 + fDist * 1.5);\n    vFlow *= 1.0 / (1.0 + fDist * 0.5);\n\n#if 1\n    float fBehindObstacle = 0.5 - dot( normalize(vGradient), -normalize(vFlow)) * 0.5;\n    float fSlowDist = clamp( fDepth * 5.0, 0.0, 1.0);\n    fSlowDist = mix(fSlowDist * 0.9 + 0.1, 1.0, fBehindObstacle * 0.9);\n    //vFlow += vGradient * 10.0 * (1.0 - fSlowDist);\n    fSlowDist = 0.5 + fSlowDist * 0.5;\n    vFlow *= fSlowDist;\n#endif    \n    \n    float fFoamScale1 =0.5;\n    float fFoamCutoff = 0.4;\n    float fFoamScale2 = 0.35;\n    \n    fFoam = abs(length( vFlow )) * fFoamScale1;// - length( vBaseFlow ));\n\tfFoam += clamp( fFoam - fFoamCutoff, 0.0, 1.0 );\n    //fFoam = fFoam* fFoam;\n    fFoam = 1.0 - pow( fDist, fFoam * fFoamScale2 );\n    //fFoam = fFoam / fDist;\n    return vec3( vFlow * 0.6, fFoam  );\n}\n\n\n///////////////////////////\n// Common Simulation Addresses\n\nivec2 addrVehicle = ivec2( 0.0, 0.0 );\n\nivec2 offsetVehicleParam0 = ivec2( 0.0, 0.0 );\n\nivec2 offsetVehicleBody = ivec2( 1.0, 0.0 );\nivec2 offsetBodyPos = ivec2( 0.0, 0.0 );\nivec2 offsetBodyRot = ivec2( 1.0, 0.0 );\nivec2 offsetBodyMom = ivec2( 2.0, 0.0 );\nivec2 offsetBodyAngMom = ivec2( 3.0, 0.0 );\n\nivec2 addrCamera = ivec2( 0.0, 1.0 );\nivec2 offsetCameraPos = ivec2( 0.0, 0.0 );\nivec2 offsetCameraTarget = ivec2( 1.0, 0.0 );\n\nivec2 addrPrevCamera = ivec2( 0.0, 2.0 );\n\n///////////////////////////\n// Simulation Structures\n\n\nstruct Body\n{\n    // Persistent State\n    vec3 vPos;\n    vec4 qRot;\n    vec3 vMomentum;\n    vec3 vAngularMomentum;\n    \n    // Derived\n    mat3 mRot;\n    \n    // Constant\n    float fMass;\n    float fIT; // Hacky scalar for inertia tensor\n    \n    // Per frame\n    vec3 vForce;\n    vec3 vTorque;\n};\n\nvoid BodyLoadState( out Body body, ivec2 addr )\n{\n    body.vPos = LoadVec3( addr + offsetBodyPos );\n    body.qRot = LoadVec4( addr + offsetBodyRot );\n    body.vMomentum = LoadVec3( addr + offsetBodyMom );\n    body.vAngularMomentum = LoadVec3( addr + offsetBodyAngMom );\n}\n\nvoid BodyStoreState( ivec2 addr, const in Body body, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec3( addr + offsetBodyPos, body.vPos, fragColor, fragCoord );\n    StoreVec4( addr + offsetBodyRot, body.qRot, fragColor, fragCoord );\n    StoreVec3( addr + offsetBodyMom, body.vMomentum, fragColor, fragCoord );\n    StoreVec3( addr + offsetBodyAngMom, body.vAngularMomentum, fragColor, fragCoord );\n}\n\n\n\n\nstruct Vechicle\n{\n    Body body;        \n    float fSteerAngle;\n};\n\nvoid VehicleLoadState( out Vechicle vehicle, ivec2 addr )\n{    \n    BodyLoadState( vehicle.body, addr + offsetVehicleBody );\n\n    vec4 vParam0;\n    vParam0 = LoadVec4( addr + offsetVehicleParam0 );\n    vehicle.fSteerAngle = vParam0.x;\n}\n\nvoid VehicleStoreState( ivec2 addr, const in Vechicle vehicle, inout vec4 fragColor, in vec2 fragCoord )\n{\n    BodyStoreState( addr + offsetVehicleBody, vehicle.body, fragColor, fragCoord );\n    vec4 vParam0 = vec4( vehicle.fSteerAngle, 0.0, 0.0, 0.0 );\n    StoreVec4( addr + offsetVehicleParam0, vParam0, fragColor, fragCoord);\n}\n\n\nstruct Camera\n{\n    vec3 vPos;\n    vec3 vTarget;\n};\n\nvoid CameraLoadState( out Camera cam, in ivec2 addr )\n{\n\tcam.vPos = LoadVec3( addr + offsetCameraPos );\n\tcam.vTarget = LoadVec3( addr + offsetCameraTarget );\n}\n\nvoid CameraStoreState( Camera cam, in ivec2 addr, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec3( addr + offsetCameraPos, cam.vPos, fragColor, fragCoord );\n    StoreVec3( addr + offsetCameraTarget, cam.vTarget, fragColor, fragCoord );    \n}\n\n// ------------ 8< ------------ 8< ------------ 8< ------------ 8< ------------\n\n\nstruct VehicleState\n{\n    vec3 vPos;\n    \n    vec4 qRot;\n    mat3 mRot;\n    float fSteerAngle;\n};\n\nstruct SceneState\n{\n    VehicleState vehicleState;\n};\n    \nSceneState SetupSceneState()\n{\n    SceneState sceneState;\n    \n    sceneState.vehicleState.vPos = LoadVec3( addrVehicle + offsetVehicleBody + offsetBodyPos );\n    \n    sceneState.vehicleState.qRot = LoadVec4( addrVehicle + offsetVehicleBody + offsetBodyRot );\n    sceneState.vehicleState.mRot = QuatToMat3( sceneState.vehicleState.qRot );\n    \n    vec4 vParam0;\n    vParam0 = LoadVec4( addrVehicle + offsetVehicleParam0 );\n    sceneState.vehicleState.fSteerAngle = vParam0.x;\n    \n\n    return sceneState;\n}\n\n\n\n\n\nint OBJ_ID_SKY = 0,\n    OBJ_ID_GROUND = 1,\n    OBJ_ID_BOAT_INT = 2,\n    OBJ_ID_BOAT_EXT = 3,\n    OBJ_ID_BOAT_MOTOR = 4;\n    \n    \n\nfloat g_fTime;\n\nconst vec3 g_vSunDir = vec3( -1.0, 0.7, 0.25 );\nvec3 GetSunDir() { return normalize( g_vSunDir ); }\n\nconst vec3 g_sunColour = vec3( 1.0, 0.85, 0.5 ) * 8.0;\nconst vec3 g_skyColour = vec3( 0.1, 0.6, 1.0 ) * 1.0;\n\nconst vec3 k_bgSkyColourUp = g_skyColour * 4.0;\nconst vec3 k_bgSkyColourDown = g_skyColour * 6.0;\nconst vec3 k_fogColour = (k_bgSkyColourUp + k_bgSkyColourDown) * 0.5;\n\nconst vec3 k_envFloorColor = vec3(0.3, 0.2, 0.2);\n\nconst vec3 k_vFogExt = vec3(0.01, 0.015, 0.015) * 0.1;\nconst vec3 k_vFogIn = vec3(1.0, 0.9, 0.8) * 0.0015;\n\n\nconst float k_fFarClip = 1000.0;\n\nstruct SceneResult\n{\n\tfloat fDist;\n\tint iObjectId;\n    vec3 vUVW;\n};\n    \n        \nvoid Scene_Union( inout SceneResult a, in SceneResult b )\n{\n    if ( b.fDist < a.fDist )\n    {\n        a = b;\n    }\n}\n\n    \nvoid Scene_Subtract( inout SceneResult a, in SceneResult b )\n{\n    if ( a.fDist < -b.fDist )\n    {\n        a.fDist = -b.fDist;\n        a.iObjectId = b.iObjectId;\n        a.vUVW = b.vUVW;\n    }\n}\n\nvec4 kCollideSpheres[] = vec4[] ( \n        vec4( 0.0, 0.0,  1.5, 0.4),\n    \n        vec4( 0.3, 0.1,  1.0, 0.5),\n        vec4( -0.3, 0.1,  1.0, 0.5),\n    \n        vec4( 0.6, 0.2,  0.0, 0.6),\n        vec4( -0.6, 0.2,  0.0, 0.6),\n    \n        vec4( 0.6, 0.1,  -1.4, 0.5),\n        vec4( -0.6, 0.1,  -1.4, 0.5),\n        vec4( 0.0, 0.0,  -1.5, 0.5)\n);\n  \n\nfloat GetCollisionDistance( vec3 vPos )\n{\n    float fClosest = 100000.0;\n    \n    for (int i=0; i<kCollideSpheres.length(); i++)\n    {    \n        float d = length( vPos.xyz - kCollideSpheres[i].xyz) - kCollideSpheres[i].w;\n        \n        fClosest = min( fClosest, d );\n    }\n    \n    return fClosest;\n}\n\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat GetBoatHullDistance( vec3 vPos )\n{\n    vec3 vBoatDomain = vPos;\n    vBoatDomain.x = abs(vBoatDomain.x);\n    \n    float boatDist = length( vBoatDomain.xyz - vec3(-3.9,3.2,-0.6)) - 5.5;\n    float boatRearDist = length( vBoatDomain.xyz - vec3(0,2,3.9)) - 6.0;\n\n    boatDist = -min( -boatDist, - boatRearDist);\n    \n    float boatBaseDist = length( vBoatDomain.xyz - vec3(0,4,0)) - 4.4;\n    boatDist = -min( -boatDist, - boatBaseDist);\n    \n    \n    return boatDist;\n}\n\nfloat GetBoatTopDistance( vec3 vPos )\n{\n    return length( vPos - vec3(0,-10,1)) - 10.0-.7;\n}\n\nSceneResult GetBoatDistance( vec3 vPos )\n{    \n    SceneResult result;\n    result.iObjectId = OBJ_ID_BOAT_EXT;\n    result.vUVW = vPos;\n    \n    result.fDist = GetBoatHullDistance(vPos);\n    \n    SceneResult intResult;\n    intResult.iObjectId = OBJ_ID_BOAT_INT;\n    intResult.vUVW = vPos;\n\n    float boatInsideDist = GetBoatHullDistance(vPos - vec3(0,.15,0) );\n\n    boatInsideDist = max( boatInsideDist, -udRoundBox( vPos - vec3(0,0.2,-.8), vec3(1.0, .01, 0.2), 0.05) );\n    \n    boatInsideDist = max( boatInsideDist, vPos.z);\n    \n    intResult.fDist = boatInsideDist;\n    \n    Scene_Subtract( result, intResult );\n    \n\n    float boatTopDist = GetBoatTopDistance(vPos);\n\n    result.fDist = -smin(-result.fDist, -boatTopDist, .05 );\n    return result;\n}\n\nfloat InsideBoat( vec3 vPos )\n{\n    return max( GetBoatHullDistance(vPos), GetBoatTopDistance(vPos) );\n}\n\nfloat InsideBoat( VehicleState vehicleState, vec3 vPos )\n{\n    vec3 vLocalPos = vehicleState.mRot * (vPos - vehicleState.vPos);\n    return InsideBoat(vLocalPos);\n}\n\n\n\nSceneResult GetVehicleDistance( const in VehicleState vehicleState, const vec3 vPos )\n{\n    SceneResult result;    \n\n    vec3 vLocalPos = vehicleState.mRot * (vPos - vehicleState.vPos);    \n    result = GetBoatDistance( vLocalPos );\n\n    \n    SceneResult motorResult;\n    \n    vec3 vMotorBodyPos = vec3(0,-0.0, -2.0);\n    \n    vec3 vMotorWorldPos = ObjToWorld(vMotorBodyPos, vehicleState.mRot) +  vehicleState.vPos;\n    vec3 vMotorDomain = WorldToObj( vPos - vMotorWorldPos, vehicleState.mRot );\n    \n    vec3 vPivot = vec3(0,0,-0.2);\n    vMotorDomain = RotY( vMotorDomain + vPivot, -vehicleState.fSteerAngle * .9) - vPivot;\n    motorResult.fDist = udRoundBox( vMotorDomain, vec3(.08, .15, .15), 0.05);\n    motorResult.iObjectId = OBJ_ID_BOAT_MOTOR;\n    motorResult.vUVW = vMotorDomain;\n    \n    Scene_Union( result, motorResult );\n    \n    \n    return result;\n}\n\n\nSceneResult Scene_GetDistance( const vec3 vPos, SceneState sceneState )\n{\n    SceneResult result;\n    float fTerrainDist = vPos.y - GetTerrainHeight( vPos );\n    result.fDist = fTerrainDist;\n    result.iObjectId = OBJ_ID_GROUND;\n    result.vUVW = vPos;\n    //min( fTerrainDist, fVehicleDist );\n    \n    SceneResult vehicleResult = GetVehicleDistance( sceneState.vehicleState, vPos );\n\n    Scene_Union( result, vehicleResult );\n    \n    return result;\n}\n\n#ifdef ENABLE_WATER\nvec4 SampleWaterNormal( vec2 vUV, vec2 vFlowOffset, float fMag, float fFoam )\n{    \n    vec2 vFilterWidth = max(abs(dFdx(vUV)), abs(dFdy(vUV)));\n  \tfloat fFilterWidth= max(vFilterWidth.x, vFilterWidth.y);\n    \n    float fScale = (1.0 / (1.0 + fFilterWidth * fFilterWidth * 2000.0));\n    float fGradientAscent = 0.25 + (fFoam * -1.5);\n    vec3 dxy = FBM_DXY(vUV * 20.0, vFlowOffset * 20.0, 0.75 + fFoam * 0.25, fGradientAscent);\n    fScale *= max(0.25, 1.0 - fFoam * 5.0); // flatten normal in foam\n    vec3 vBlended = mix( vec3(0.0, 1.0, 0.0), normalize( vec3(dxy.x, fMag, dxy.y) ), fScale );\n    return vec4( normalize( vBlended ), dxy.z * fScale );\n}\n\nfloat SampleWaterFoam( vec2 vUV, vec2 vFlowOffset, float fFoam )\n{\n    float f =  FBM_DXY(vUV * 30.0, vFlowOffset * 50.0, 0.8, -0.5 ).z;\n    float fAmount = 0.2;\n    f = max( 0.0, (f - fAmount) / fAmount );\n    return pow( 0.5, f );\n}\n    \n\nvec4 SampleFlowingNormal( vec2 vUV, vec2 vFlowRate, const float fFoam, const float time, out float fOutFoamTex )\n{\n    vUV /= kSceneScale;\n    \n    float fMag = 2.5 / (1.0 + dot( vFlowRate, vFlowRate ) * 5.0);\n    float t0 = fract( time );\n    float t1 = fract( time + 0.5 );\n    \n    float o0 = t0 - 0.5;\n    float o1 = t1 - 0.5;\n    \n    vec4 sample0 = SampleWaterNormal( vUV, vFlowRate * o0, fMag, fFoam );\n    vec4 sample1 = SampleWaterNormal( vUV, vFlowRate * o1, fMag, fFoam );\n\n    float weight = abs( t0 - 0.5 ) * 2.0;\n    //weight = smoothstep( 0.0, 1.0, weight );\n\n    float foam0 = SampleWaterFoam( vUV, vFlowRate * o0 * 0.25, fFoam );\n    float foam1 = SampleWaterFoam( vUV, vFlowRate * o1 * 0.25, fFoam );\n    \n    vec4 result=  mix( sample0, sample1, weight );\n    result.xyz = normalize(result.xyz);\n\n    fOutFoamTex = mix( foam0, foam1, weight );\n\n    return result;\n}\n#endif // #ifdef ENABLE_WATER\n\nvec2 GetWindowCoord( const in vec2 vUV )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x / iResolution.y;\n\n\treturn vWindow;\t\n}\n\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget )\n{\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\t\t\t\t\t\t\t  \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * 2.0);\n\n\treturn vDir;\n}\n\nSceneResult Scene_Trace( const in vec3 vRayOrigin, const in vec3 vRayDir, SceneState sceneState, float minDist, float maxDist )\n{\t\n    SceneResult result;\n    result.fDist = 0.0;\n    result.vUVW = vec3(0.0);\n    result.iObjectId = -1;\n    \n\tfloat t = minDist;\n\tconst int kRaymarchMaxIter = 128;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\t\t\n        float epsilon = 0.0001 * t;\n\t\tresult = Scene_GetDistance( vRayOrigin + vRayDir * t, sceneState );\n        if ( result.fDist < epsilon )\n\t\t{\n\t\t\tbreak;\n\t\t}\n                        \n        if ( t > maxDist )\n        {\n            result.iObjectId = -1;\n\t        t = maxDist;\n            break;\n        }       \n        \n        if ( result.fDist > 1.0 )\n        {\n            result.iObjectId = -1;            \n        }    \n        \n        t += result.fDist;        \n\t}\n    \n    result.fDist = t;\n\n\n    return result;\n}    \n\nvec3 Scene_GetNormal(const in vec3 vPos, SceneState sceneState)\n{\n    const float fDelta = 0.0001;\n    vec2 e = vec2( -1, 1 );\n    \n    vec3 vNormal = \n        Scene_GetDistance( e.yxx * fDelta + vPos, sceneState ).fDist * e.yxx + \n        Scene_GetDistance( e.xxy * fDelta + vPos, sceneState ).fDist * e.xxy + \n        Scene_GetDistance( e.xyx * fDelta + vPos, sceneState ).fDist * e.xyx + \n        Scene_GetDistance( e.yyy * fDelta + vPos, sceneState ).fDist * e.yyy;\n    \n    return normalize( vNormal );\n} \n\n\nvoid TraceWater( vec3 vRayOrigin, vec3 vRayDir, out SceneResult intersection )\n{\n \tintersection.fDist = k_fFarClip;\n    \n    float t = -vRayOrigin.y / vRayDir.y;\n    if ( t > 0.0 )\n    {\n        intersection.fDist = t;\n    }    \n}\n\nstruct Surface\n{\n    vec3 vPos;\n    vec3 vNormal;\n    vec3 vAlbedo;\n    vec3 vSpecR0;\n    float fGloss;\n    float fSpecScale;\n};\n    \nvoid GetSurfaceInfo( vec3 vRayOrigin, vec3 vRayDir, SceneResult intersection, SceneState sceneState, out Surface surface )\n{\n    surface.vPos = vRayOrigin + vRayDir * intersection.fDist;\n    surface.vNormal = Scene_GetNormal( surface.vPos, sceneState );\n\n    surface.vAlbedo = vec3(0.5);\n    surface.vSpecR0 = vec3(0.001);\n    surface.fGloss = 0.0;\n    surface.fSpecScale = 1.0;\n    \n    if ( intersection.iObjectId == OBJ_ID_GROUND )\n    {\n        vec3 vTexPos = intersection.vUVW / kSceneScale;\n\n        #if 0\n        surface.vAlbedo = texture( iChannel0, vTexPos.xz ).rgb;\n        surface.vAlbedo = surface.vAlbedo * surface.vAlbedo;\n        #else\n        vec3 vWeights = surface.vNormal * surface.vNormal;\n        vec3 col = vec3(0.0);\n        vec3 samp;\n        samp = texture( iChannel0, vTexPos.xz ).rgb;\n        col += samp * samp * vWeights.y;\n        samp = texture( iChannel0, vTexPos.xy ).rgb;\n        col += samp * samp * vWeights.z;\n        samp = texture( iChannel0, vTexPos.yz ).rgb;\n        col += samp * samp * vWeights.x;\n        col /= vWeights.x + vWeights.y + vWeights.z;\n        surface.vAlbedo = col;\n        #endif\n        \n        surface.vAlbedo = mix( surface.vAlbedo, surface.vAlbedo * vec3(0.4, 0.6, 0.1), clamp(intersection.vUVW.y, 0.0, 1.0) );\n\n            surface.fGloss = clamp( 0.9 - (surface.vAlbedo.g - surface.vAlbedo.r) * 5.0, 0.0, 1.0);\n\n            float fWaterLine = 0.08;\n            float fWetness = clamp( 1.0 - (surface.vPos.y + 0.04) / fWaterLine , 0.0, 1.0);\n            surface.fGloss = mix( surface.fGloss, 0.95, fWetness );\n            surface.vAlbedo = mix( surface.vAlbedo, surface.vAlbedo * 0.8, fWetness );\n            \n        \n    }\n\n    if ( intersection.iObjectId == OBJ_ID_BOAT_INT )\n    {\n        surface.vAlbedo = texture( iChannel3, intersection.vUVW.yx ).rgb;\n        surface.fGloss = clamp( surface.vAlbedo.r * 1.5, 0.0, 1.0 );\n        surface.vAlbedo = surface.vAlbedo * surface.vAlbedo;        \n        surface.fSpecScale = 1.0;\n    }\n\n    if ( intersection.iObjectId == OBJ_ID_BOAT_EXT )\n    {\n        surface.vAlbedo = vec3(0.7);\n        surface.fGloss = 0.9;\n        surface.fSpecScale = 1.0;\n    }\n\n    if ( intersection.iObjectId == OBJ_ID_BOAT_EXT || intersection.iObjectId == OBJ_ID_BOAT_INT )\n    {\n        surface.vAlbedo *= mix(texture( iChannel0, intersection.vUVW.zx ).rgr, vec3(1.0), clamp( intersection.vUVW.y * 2.0, 0.0, 1.0));\n    }\n    \n    if ( intersection.iObjectId == OBJ_ID_BOAT_MOTOR )\n    {\n\t    surface.vSpecR0 = vec3(0.9);\n        \n        surface.vAlbedo = vec3(0.0);\n        surface.fGloss = 0.9;\n        surface.fSpecScale = 1.0;\n    }    \n        \n}\n   \nfloat GIV( float dotNV, float k)\n{\n\treturn 1.0 / ((dotNV + 0.0001) * (1.0 - k)+k);\n}\n\nfloat GetSunShadow( const vec3 vPos, SceneState sceneState )\n{\n    vec3 vSunDir = GetSunDir();\n\n    SceneResult shadowResult;\n    float k_fShadowDist = 4.0;\n\t\n\tshadowResult = Scene_Trace( vPos + vSunDir * k_fShadowDist, -vSunDir, sceneState, 0.01f, k_fShadowDist );\n    \n    float fShadowFactor = 1.0;\n    if( shadowResult.fDist < (k_fShadowDist - 0.1) )\n    {\n        fShadowFactor = 0.0;\n    }\n\n    return fShadowFactor;\n}\n\nvoid AddSunLight( Surface surf, const vec3 vViewDir, const float fShadowFactor, inout vec3 vDiffuse, inout vec3 vSpecular )\n{\n    vec3 vSunDir = GetSunDir();\n\n\tvec3 vH = normalize( vViewDir + vSunDir );\n\tfloat fNdotL = clamp(dot(GetSunDir(), surf.vNormal), 0.0, 1.0);\n\tfloat fNdotV = clamp(dot(vViewDir, surf.vNormal), 0.0, 1.0);\n\tfloat fNdotH = clamp(dot(surf.vNormal, vH), 0.0, 1.0);\n    \n    float diffuseIntensity = fNdotL;\n    \n    vDiffuse += g_sunColour * diffuseIntensity * fShadowFactor;\n\t//vDiffuse = fShadowFactor * vec3(100.0);\n\t\n\tfloat alpha = 1.0 - surf.fGloss;\n\t// D\n\n\tfloat alphaSqr = alpha * alpha;\n\tfloat pi = 3.14159;\n\tfloat denom = fNdotH * fNdotH * (alphaSqr - 1.0) + 1.0;\n\tfloat d = alphaSqr / (pi * denom * denom);\n\n\tfloat k = alpha / 2.0;\n\tfloat vis = GIV(fNdotL, k) * GIV(fNdotV, k);\n\n\tfloat fSpecularIntensity = d * vis * fNdotL;\n\tvSpecular += g_sunColour * fSpecularIntensity * fShadowFactor;\n}\n    \nvoid AddSkyLight( Surface surf, inout vec3 vDiffuse, inout vec3 vSpecular )\n{\n    float skyIntensity = max( 0.0, surf.vNormal.y * 0.3 + 0.7 );\n    vDiffuse += g_skyColour * skyIntensity;       \n}\n\nvec3 GetFresnel( vec3 vView, vec3 vNormal, vec3 vR0, float fGloss )\n{\n    float NdotV = max( 0.0, dot( vView, vNormal ) );\n\n    return vR0 + (vec3(1.0) - vR0) * pow( 1.0 - NdotV, 5.0 ) * pow( fGloss, 20.0 );\n}\n\nvec3 GetWaterExtinction( float dist )\n{\n    float fOpticalDepth = dist * 6.0 / kSceneScale;\n\n    vec3 vExtinctCol = 1.0 - vec3(0.5, 0.4, 0.1);           \n    vec3 vExtinction = exp2( -fOpticalDepth * vExtinctCol );\n    \n    return vExtinction;\n}\n\nvec3 GetSkyColour( vec3 vRayDir, float fCloudScale )\n{    \n\tvec3 vSkyColour = mix( k_bgSkyColourDown, k_bgSkyColourUp, clamp( vRayDir.y, 0.0, 1.0 ) );\n\n    float fCloud = texture( iChannel1, vRayDir.xz * 0.01 / (vRayDir.y) ).r;\n    fCloud = clamp( fCloud * fCloud * 3.0 - 1.0, 0.0, 1.0);\n    fCloud *= fCloudScale;\n    vSkyColour = mix( vSkyColour, vec3(8.0), fCloud );    \n    \n    float fSunDotV = dot(GetSunDir(), vRayDir);    \n    float fDirDot = clamp(fSunDotV * 0.5 + 0.5, 0.0, 1.0);\n    vSkyColour += g_sunColour * (1.0 - exp2(fDirDot * -0.5)) * 2.0;\n    \n    return vSkyColour;\n}\n\nvec3 GetEnvColour( vec3 vRayDir, float fGloss )\n{\n\treturn mix( k_envFloorColor, k_bgSkyColourUp, clamp( vRayDir.y * (1.0 - fGloss * 0.5) * 0.5 + 0.5, 0.0, 1.0 ) );\n}\n\n\nvec3 GetRayColour( const in vec3 vRayOrigin, const in vec3 vRayDir, SceneState sceneState, out SceneResult traceResult )\n{\n    traceResult = Scene_Trace( vRayOrigin, vRayDir, sceneState, 0.01f, 1000.0f );\n\n    if ( traceResult.iObjectId == OBJ_ID_SKY )\n    {\n        return GetSkyColour( vRayDir, 1.0 );\n    }\n    \n    Surface surface;\n    GetSurfaceInfo( vRayOrigin, vRayDir, traceResult, sceneState, surface );\n\n    vec3 vIgnore = vec3(0.0);\n    vec3 vResult = vec3(0.0);\n    float fSunShadow = 1.0;\n    AddSunLight( surface, -vRayDir, fSunShadow, vResult, vIgnore );\n    AddSkyLight( surface, vResult, vIgnore);\n    return vResult * surface.vAlbedo;\n}\n\nvec3 GetRayColour( const in vec3 vRayOrigin, const in vec3 vRayDir, SceneState sceneState )\n{\n\tSceneResult intersection;\n    return GetRayColour( vRayOrigin, vRayDir, sceneState, intersection );\n}\n\nvec3 GetSceneColour( const in vec3 vRayOrigin,  const in vec3 vRayDir, out float fSceneDistance )\n{\n    SceneState sceneState = SetupSceneState();\n        \n\tSceneResult primaryInt;\n\tprimaryInt = Scene_Trace( vRayOrigin, vRayDir, sceneState, 0.01f, 1000.0f );\n\n\n    float fFogDistance = 0.0;\n    vec3 vResult = vec3( 0.0 );\n    \n    float fSunDotV = dot(GetSunDir(), vRayDir);    \n\n    if ( primaryInt.iObjectId == OBJ_ID_SKY )\n    {\n        vResult = GetSkyColour( vRayDir, 1.0 );\n        fFogDistance = k_fFarClip;\n    }\n    else\n    {\n        SceneResult waterInt;\n        TraceWater( vRayOrigin, vRayDir, waterInt );\n\n        vec3 vReflectRayOrigin;\n        vec3 vSpecNormal;\n        vec3 vTransmitLight;\n\n        Surface specSurface;\n        vec3 vSpecularLight = vec3(0.0);\n\n        vec3 vWaterHitPos = vRayOrigin + vRayDir * waterInt.fDist;\n        float fInsideBoat = InsideBoat( sceneState.vehicleState, vWaterHitPos );\n    #ifdef ENABLE_WATER\n        vec3 vFlowRateAndFoam = GetFlowRate( vWaterHitPos.xz );\n        vec2 vFlowRate = vFlowRateAndFoam.xy;\n        #ifdef ENABLE_FOAM\n        float fFoam = vFlowRateAndFoam.z;\n        fFoam += clamp(.5 - fInsideBoat * 2.0, 0.0, 1.0);\n        float fFoamScale = 1.5;\n        float fFoamOffset = 0.2;\n        fFoam = clamp( (fFoam - fFoamOffset) * fFoamScale, 0.0, 1.0 );\n        fFoam = fFoam * fFoam * 0.5;\n        #else\n        float fFoam = 0.0;\n        #endif            \n\n        float fWaterFoamTex = 1.0;\n        vec4 vWaterNormalAndHeight = SampleFlowingNormal( vWaterHitPos.xz, vFlowRate, fFoam, g_fTime, fWaterFoamTex );\n        \n        if( vRayDir.y < -0.01 )\n        {\n            // lie about the water intersection depth\n            waterInt.fDist -= (0.04 * (1.0 - vWaterNormalAndHeight.w) / vRayDir.y);\n        }\n        \n        if( waterInt.fDist < primaryInt.fDist &&\n          \tfInsideBoat > 0.0 )\n        {\n            fFogDistance = waterInt.fDist;\n            vec3 vWaterNormal = vWaterNormalAndHeight.xyz;\n\n            vReflectRayOrigin = vWaterHitPos;\n            vSpecNormal = vWaterNormal;\n\n            vec3 vRefractRayOrigin = vWaterHitPos;\n            vec3 vRefractRayDir = refract( vRayDir, vWaterNormal, 1.0 / 1.3333 );\n\n            SceneResult refractInt;\n            vec3 vRefractLight = GetRayColour( vRefractRayOrigin, vRefractRayDir, sceneState, refractInt ); // note : dont need sky\n\n            float fEdgeAlpha = clamp( (1.0 + vWaterNormalAndHeight.w * 0.25) - refractInt.fDist * 10.0, 0.0, 1.0 );\n            fFoam *= 1.0 - fEdgeAlpha;\n            \n\t        vec3 vRefractHitPos = vRayOrigin + vRayDir * refractInt.fDist;\n            \n            // add extra extinction for the light travelling to the point underwater\n            vec3 vExtinction = GetWaterExtinction( refractInt.fDist + abs( vRefractHitPos.y ) );\n\n            specSurface.vPos = vWaterHitPos;\n            specSurface.vNormal = normalize( vWaterNormal + GetSunDir() * fFoam ); // would rather have SSS for foam\n            specSurface.vAlbedo = vec3(1.0);\n            specSurface.vSpecR0 = vec3( 0.01, 0.01, 0.01 );\n\n            vec2 vFilterWidth = max(abs(dFdx(vWaterHitPos.xz)), abs(dFdy(vWaterHitPos.xz)));\n  \t\t\tfloat fFilterWidth= max(vFilterWidth.x, vFilterWidth.y);\n            float fGlossFactor = exp2( -fFilterWidth * 0.3 / kSceneScale );\n            specSurface.fGloss = 0.99 * fGlossFactor;            \n            specSurface.fSpecScale = 1.0;\n            \n            vec3 vSurfaceDiffuse = vec3(0.0);\n\n            float fSunShadow = 1.0;\n        #ifdef ENABLE_WATER_RECEIVE_SHADOW\n            fSunShadow = GetSunShadow( vWaterHitPos, sceneState );\n        #endif\n            AddSunLight( specSurface, -vRayDir, fSunShadow, vSurfaceDiffuse, vSpecularLight);\n            AddSkyLight( specSurface, vSurfaceDiffuse, vSpecularLight);\n\n            vec3 vInscatter = vSurfaceDiffuse * (1.0 - exp( -refractInt.fDist * 0.1 )) * (1.0 + fSunDotV);\n            vTransmitLight = vRefractLight.rgb;\n            vTransmitLight += vInscatter;\n            vTransmitLight *= vExtinction;   \n\n\n    #ifdef ENABLE_FOAM\n            float fFoamBlend = 1.0 - pow( fWaterFoamTex, fFoam * 5.0);// * (1.0 - fWaterFoamTex));\n            vTransmitLight = mix(vTransmitLight, vSurfaceDiffuse * 0.8, fFoamBlend );\n            specSurface.fSpecScale = clamp(1.0 - fFoamBlend * 4.0, 0.0, 1.0);\n    #endif\n        }\n        else\n    #endif // #ifdef ENABLE_WATER\n        {\n            fFogDistance = primaryInt.fDist;\n\n            Surface primarySurface;\n            GetSurfaceInfo( vRayOrigin, vRayDir, primaryInt, sceneState, primarySurface );\n\n            vSpecNormal = primarySurface.vNormal;\n            vReflectRayOrigin = primarySurface.vPos;\n            \n            //primarySurface.m_albedo = mix( primarySurface.m_albedo, vec3(1.0, 0.0, 0.0), fWetness );\n            \n            vTransmitLight = vec3(0.0);\n            float fSunShadow = 1.0;\n       #ifdef ENABLE_LANDSCAPE_RECEIVE_SHADOW\n            fSunShadow = GetSunShadow( primaryInt.m_pos );\n       #endif\n            AddSunLight( primarySurface, -vRayDir, fSunShadow, vTransmitLight, vSpecularLight);\n            AddSkyLight( primarySurface, vTransmitLight, vSpecularLight);\n            vTransmitLight *= primarySurface.vAlbedo;\n            specSurface = primarySurface;\n        }\n\n        vec3 vReflectRayDir = reflect( vRayDir, vSpecNormal );\n        vec3 vReflectLight = GetRayColour( vReflectRayOrigin, vReflectRayDir, sceneState );\n\n        vReflectLight = mix( GetEnvColour(vReflectRayDir, specSurface.fGloss), vReflectLight, pow( specSurface.fGloss, 40.0) );\n        \n        vec3 vFresnel = GetFresnel( -vRayDir, vSpecNormal, specSurface.vSpecR0, specSurface.fGloss );\n\n        vSpecularLight += vReflectLight;\n        vResult = mix(vTransmitLight, vSpecularLight, vFresnel * specSurface.fSpecScale );\n    }\n    \n    float fCloudScale = 0.0;\n    if ( fFogDistance >= k_fFarClip )\n    {\n        vResult = smoothstep( 0.9995, 0.9999, fSunDotV ) * g_sunColour * 200.0;\n        fCloudScale = 1.0;\n    }    \n    \n    vec3 vFogColour = GetSkyColour(vRayDir, fCloudScale);    \n    \n    vec3 vFogExtCol = exp2( k_vFogExt * -fFogDistance );\n    vec3 vFogInCol = exp2( k_vFogIn * -fFogDistance );\n    vResult = vResult*(vFogExtCol) + vFogColour*(1.0-vFogInCol);\n    \n    fSceneDistance = fFogDistance;\n    \n    return vResult;\n}\n\nfloat GetCoC( float fDistance, float fPlaneInFocus )\n{\n\t// http://http.developer.nvidia.com/GPUGems/gpugems_ch23.html\n\n    float fAperture = 0.7;\n    float fFocalLength = 0.035;\n  \n\treturn abs(fAperture * (fFocalLength * (fDistance - fPlaneInFocus)) /\n          (fDistance * (fPlaneInFocus - fFocalLength)));  \n}\n\n// POSTFX\n\nvec3 ApplyVignetting( const in vec2 vUV, const in vec3 vInput )\n{\n\tvec2 vOffset = (vUV - 0.5) * sqrt(2.0);\n\t\n\tfloat fDist = dot(vOffset, vOffset);\n\t\n\tconst float kStrength = 0.9;\n\t\n\tfloat fShade = mix( 1.0, 1.0 - kStrength, fDist );\t\n\n\treturn vInput * fShade;\n}\n\nvec3 Tonemap( vec3 x )\n{\n    float a = 0.010;\n    float b = 0.132;\n    float c = 0.010;\n    float d = 0.163;\n    float e = 0.101;\n\n    return ( x * ( a * x + b ) ) / ( x * ( c * x + d ) + e );\n}\n\nvec3 ApplyPostFX( const in vec2 vUV, const in vec3 vInput )\n{\n\tvec3 vFinal = ApplyVignetting( vUV, vInput );\t\n\t\n\tvFinal = Tonemap(vFinal * 1.5);\n\t    \n\treturn vFinal;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    g_fTime = iTime;\n\n    vec3 vCameraPos = LoadVec3( addrCamera + offsetCameraPos );\n    vec3 vCameraTarget = LoadVec3( addrCamera + offsetCameraTarget );\n    \n    vec2 vUV = fragCoord.xy / iResolution.xy;\n    \n    vec3 vRayOrigin = vCameraPos;\n\tvec3 vRayDir = GetCameraRayDir( GetWindowCoord(vUV), vCameraPos, vCameraTarget );\n\t\n    float fSceneDistance = 0.0;\n    \n\tvec3 vResult = GetSceneColour(vRayOrigin, vRayDir, fSceneDistance);\n    \n    vec3 vFinal = ApplyPostFX( vUV, vResult );\n    fragColor = vec4(vFinal, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// [SH17B] Adrift - https://www.shadertoy.com/view/ldjfDD\n// @P_Malin\n\n// Simulation Shader\n\n// WASD to drive.\n// G toggle gravity\n// . and , flip vehicle\n\n\n//#define ENABLE_DEBUG_FORCES\n#define ENABLE_GRAVITY_TOGGLE\n\n//#if ( __VERSION__ < 300 )\n//#endif\n\n#define iChannelSim iChannel0\n\n///////////////////////////\n///////////////////////////\n// Common\n///////////////////////////\n///////////////////////////\n\n\n/////////////////////////\n// Constants\n\nfloat PI = acos(-1.0);\n\n/////////////////////////\n// Storage\n\nvec4 LoadVec4( in ivec2 vAddr )\n{\n    return texelFetch( iChannelSim, vAddr, 0 );\n}\n\nvec3 LoadVec3( in ivec2 vAddr )\n{\n    return LoadVec4( vAddr ).xyz;\n}\n\nbool AtAddress( vec2 p, ivec2 c ) { return all( equal( floor(p), vec2(c) ) ); }\n\nvoid StoreVec4( in ivec2 vAddr, in vec4 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in ivec2 vAddr, in vec3 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n\n/////////////////////////\n\n// Keyboard \n\n\n// Keyboard constants definition\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\nconst int KEY_COMMA = 188;\nconst int KEY_PER   = 190;\n\nbool KeyIsPressed(int key)\n{\n\treturn texelFetch( iChannel1, ivec2(key, 0), 0 ).x > 0.0;\n}\n\nbool KeyIsToggled(int key)\n{\n\treturn texelFetch( iChannel1, ivec2(key, 2), 0 ).x > 0.0;\n}\n\n/////////////////////////\n// Rotation\n\nvec2 Rotate( const in vec2 vPos, const in float t )\n{\n    float s = sin(t);\n    float c = cos(t);\n    \n    return vec2( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y);\n}\n\nvec3 RotX( const in vec3 vPos, float t )\n{\n    vec3 result;\n    result.x = vPos.x;\n  \tresult.yz = Rotate( vPos.yz, t );\n    return result;\n}\n\nvec3 RotY( const in vec3 vPos, float t )\n{\n    vec3 result;\n    result.y = vPos.y;\n  \tresult.xz = Rotate( vPos.xz, t );\n    return result;\n}\n\nvec3 RotZ( const in vec3 vPos, float t )\n{\n    vec3 result;\n    result.z = vPos.z;\n  \tresult.xy = Rotate( vPos.xy, t );\n    return result;\n}\n\n\n/////////////////////////\n// Vec\n\nvec3 Vec3Parallel( vec3 x, vec3 n )\n{\n    float d = dot( x, n );\n    \n    return x - n * d;    \n}\n\nvec3 Vec3Perp( vec3 x, vec3 n )\n{\n    return x - Vec3Parallel( x, n );\n}\n\n/////////////////////////\n// Quaternions\n\nvec4 QuatMul(const in vec4 lhs, const in vec4 rhs) \n{\n      return vec4( lhs.y*rhs.z - lhs.z*rhs.y + lhs.x*rhs.w + lhs.w*rhs.x,\n                   lhs.z*rhs.x - lhs.x*rhs.z + lhs.y*rhs.w + lhs.w*rhs.y,\n                   lhs.x*rhs.y - lhs.y*rhs.x + lhs.z*rhs.w + lhs.w*rhs.z,\n                   lhs.w*rhs.w - lhs.x*rhs.x - lhs.y*rhs.y - lhs.z*rhs.z);\n}\n\nvec4 QuatFromAxisAngle( vec3 vAxis, float fAngle )\n{\n\treturn vec4( normalize(vAxis) * sin(fAngle), cos(fAngle) );    \n}\n\nvec4 QuatFromVec3( vec3 vRot )\n{\n    float l = length( vRot );\n    if ( l <= 0.0 )\n    {\n        return vec4( 0.0, 0.0, 0.0, 1.0 );\n    }\n    return QuatFromAxisAngle( vRot, l );\n}\n\nmat3 QuatToMat3( const in vec4 q )\n{\n\tvec4 qSq = q * q;\n\tfloat xy2 = q.x * q.y * 2.0;\n\tfloat xz2 = q.x * q.z * 2.0;\n\tfloat yz2 = q.y * q.z * 2.0;\n\tfloat wx2 = q.w * q.x * 2.0;\n\tfloat wy2 = q.w * q.y * 2.0;\n\tfloat wz2 = q.w * q.z * 2.0;\n \n\treturn mat3 (\t\n     qSq.w + qSq.x - qSq.y - qSq.z, xy2 - wz2, xz2 + wy2,\n     xy2 + wz2, qSq.w - qSq.x + qSq.y - qSq.z, yz2 - wx2,\n     xz2 - wy2, yz2 + wx2, qSq.w - qSq.x - qSq.y + qSq.z );\n}\n\nvec3 QuatMul( vec3 v, vec4 q )\n{\n    // TODO Validate vs other quat code\n    vec3 t = 2.0 * cross(q.xyz, v);\n\treturn v + q.w * t + cross(q.xyz, t);\n}\n\nvec3 ObjToWorld( vec3 v, mat3 m )\n{\n    return v * m;\n}\n\nvec3 WorldToObj( vec3 v, mat3 m )\n{\n    return m * v;\n}\n\n///////////////////\n// Random\n\n#define MOD2 vec2(4.438975,3.972973)\n\nfloat Hash( float p ) \n{\n    // https://www.shadertoy.com/view/4djSRW - Dave Hoskins\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);    \n\t//return fract(sin(n)*43758.5453);\n}\n\nfloat SmoothNoise(in vec2 o) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat a = Hash(n+  0.0);\n\tfloat b = Hash(n+  1.0);\n\tfloat c = Hash(n+ 57.0);\n\tfloat d = Hash(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n    return res;\n}\n\nconst int k_fbmSteps = 3;\nconst int k_fbmWaterSteps = 4;\n\nfloat FBM( vec2 p, float ps ) {\n\tfloat f = 0.0;\n    float tot = 0.0;\n    float a = 1.0;\n    for( int i=0; i<k_fbmSteps; i++)\n    {\n        f += SmoothNoise( p ) * a;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f / tot;\n}\n\nfloat FBM_Simple( vec2 p, float ps ) {\n\tfloat f = 0.0;\n    float tot = 0.0;\n    float a = 1.0;\n    for( int i=0; i<3; i++)\n    {\n        f += SmoothNoise( p ) * a;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f / tot;\n}\n\nvec3 SmoothNoise_DXY(in vec2 o) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat a = Hash(n+  0.0);\n\tfloat b = Hash(n+  1.0);\n\tfloat c = Hash(n+ 57.0);\n\tfloat d = Hash(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\tvec2 dt = 6.0 * f - 6.0 * f2;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\tfloat du = dt.x;\t\n\tfloat dv = dt.y;\t\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n\tfloat dx = (b-a)*du + (a-b+d-c)*du*v;\n\tfloat dy = (c-a)*dv + (a-b+d-c)*u*dv;    \n    \n    return vec3(dx, dy, res);\n}\n\n#ifdef ENABLE_WATER\nvec3 FBM_DXY( vec2 p, vec2 flow, float ps, float df ) {\n\tvec3 f = vec3(0.0);\n    float tot = 0.0;\n    float a = 1.0;\n    //flow *= 0.6;\n    for( int i=0; i<k_fbmWaterSteps; i++)\n    {\n        p += flow;\n        flow *= -0.75; // modify flow for each octave - negating this is fun\n        vec3 v = SmoothNoise_DXY( p );\n        f += v * a;\n        p += v.xy * df;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f / tot;\n}\n#endif\n\nfloat GetRiverMeander( const float x )\n{\n    return sin(x * 0.3) * 1.5;\n}\n\nfloat GetRiverMeanderDx( const float x )\n{\n    return cos(x * 0.3) * 1.5 * 0.3;\n}\n\nfloat GetRiverBedOffset( const vec3 vPos )\n{\n    float fRiverBedDepth = 0.3 + (0.5 + 0.5 * sin( vPos.x * 0.001 + 3.0)) * 0.4;\n    float fRiverBedWidth = 2.0 + cos( vPos.x * 0.1 ) * 1.0;;\n    \n    float fRiverBedAmount = smoothstep( fRiverBedWidth, fRiverBedWidth * 0.5, abs(vPos.z - GetRiverMeander(vPos.x)) );\n        \n    return fRiverBedAmount * fRiverBedDepth;    \n}\n\nfloat kSceneScale = 10.;\n\nfloat GetTerrainHeight( vec3 vPos )\n{   \n    vPos /=  kSceneScale;\n    float fbm = FBM( vPos.xz * vec2(0.5, 1.0), 0.5 );\n    float fTerrainHeight = fbm * fbm; \n    fTerrainHeight -= GetRiverBedOffset(vPos);\n        \n    return fTerrainHeight * kSceneScale;\n}\n\nfloat GetTerrainHeightSimple( vec3 vPos )\n{    \n    vPos /=  kSceneScale;\n    \n    float fbm = FBM_Simple( vPos.xz * vec2(0.5, 1.0), 0.5 );\n    float fTerrainHeight = fbm * fbm;\n    \n    fTerrainHeight -= GetRiverBedOffset(vPos);\n        \n    return fTerrainHeight * kSceneScale;\n}\n\nfloat GetFlowDistance( const vec2 vPos )\n{\n    return -GetTerrainHeightSimple( vec3( vPos.x, 0.0, vPos.y ) );\n}\n\nvec2 GetBaseFlow( const vec2 vPos )\n{\n    return vec2( 1.0, GetRiverMeanderDx(vPos.x) );\n}\n\nvec2 GetGradient( const vec2 vPos )\n{\n    vec2 vDelta = vec2(0.01, 0.00);\n    float dx = GetFlowDistance( vPos + vDelta.xy ) - GetFlowDistance( vPos - vDelta.xy );\n    float dy = GetFlowDistance( vPos + vDelta.yx ) - GetFlowDistance( vPos - vDelta.yx );\n    return vec2( dx, dy );\n}\n\nvec3 GetFlowRate( vec2 vPos )\n{\n    vPos /= kSceneScale;\n    vec2 vBaseFlow = GetBaseFlow( vPos );\n\n    vec2 vFlow = vBaseFlow;\n    \n    float fFoam = 0.0;\n\n\tfloat fDepth = -GetTerrainHeightSimple( vec3(vPos.x, 0.0, vPos.y) * kSceneScale );\n    float fDist = GetFlowDistance( vPos * kSceneScale );\n    vec2 vGradient = GetGradient( vPos * kSceneScale );\n    \n    vFlow += -vGradient * 40.0 / (1.0 + fDist * 1.5);\n    vFlow *= 1.0 / (1.0 + fDist * 0.5);\n\n#if 1\n    float fBehindObstacle = 0.5 - dot( normalize(vGradient), -normalize(vFlow)) * 0.5;\n    float fSlowDist = clamp( fDepth * 5.0, 0.0, 1.0);\n    fSlowDist = mix(fSlowDist * 0.9 + 0.1, 1.0, fBehindObstacle * 0.9);\n    //vFlow += vGradient * 10.0 * (1.0 - fSlowDist);\n    fSlowDist = 0.5 + fSlowDist * 0.5;\n    vFlow *= fSlowDist;\n#endif    \n    \n    float fFoamScale1 =0.5;\n    float fFoamCutoff = 0.4;\n    float fFoamScale2 = 0.35;\n    \n    fFoam = abs(length( vFlow )) * fFoamScale1;// - length( vBaseFlow ));\n\tfFoam += clamp( fFoam - fFoamCutoff, 0.0, 1.0 );\n    //fFoam = fFoam* fFoam;\n    fFoam = 1.0 - pow( fDist, fFoam * fFoamScale2 );\n    //fFoam = fFoam / fDist;\n    return vec3( vFlow * 0.6, fFoam  );\n}\n\n///////////////////////////\n// Common Simulation Addresses\n\nivec2 addrVehicle = ivec2( 0.0, 0.0 );\n\nivec2 offsetVehicleParam0 = ivec2( 0.0, 0.0 );\n\nivec2 offsetVehicleBody = ivec2( 1.0, 0.0 );\nivec2 offsetBodyPos = ivec2( 0.0, 0.0 );\nivec2 offsetBodyRot = ivec2( 1.0, 0.0 );\nivec2 offsetBodyMom = ivec2( 2.0, 0.0 );\nivec2 offsetBodyAngMom = ivec2( 3.0, 0.0 );\n\nivec2 addrCamera = ivec2( 0.0, 1.0 );\nivec2 offsetCameraPos = ivec2( 0.0, 0.0 );\nivec2 offsetCameraTarget = ivec2( 1.0, 0.0 );\n\nivec2 addrPrevCamera = ivec2( 0.0, 2.0 );\n\n///////////////////////////\n// Simulation Structures\n\n\nstruct Body\n{\n    // Persistent State\n    vec3 vPos;\n    vec4 qRot;\n    vec3 vMomentum;\n    vec3 vAngularMomentum;\n    \n    // Derived\n    mat3 mRot;\n    \n    // Constant\n    float fMass;\n    float fIT; // Hacky scalar for inertia tensor\n    \n    // Per frame\n    vec3 vForce;\n    vec3 vTorque;\n};\n\nvoid BodyLoadState( out Body body, ivec2 addr )\n{\n    body.vPos = LoadVec3( addr + offsetBodyPos );\n    body.qRot = LoadVec4( addr + offsetBodyRot );\n    body.vMomentum = LoadVec3( addr + offsetBodyMom );\n    body.vAngularMomentum = LoadVec3( addr + offsetBodyAngMom );\n}\n\nvoid BodyStoreState( ivec2 addr, const in Body body, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec3( addr + offsetBodyPos, body.vPos, fragColor, fragCoord );\n    StoreVec4( addr + offsetBodyRot, body.qRot, fragColor, fragCoord );\n    StoreVec3( addr + offsetBodyMom, body.vMomentum, fragColor, fragCoord );\n    StoreVec3( addr + offsetBodyAngMom, body.vAngularMomentum, fragColor, fragCoord );\n}\n\n\n\n\nstruct Vechicle\n{\n    Body body;        \n    float fSteerAngle;\n};\n\nvoid VehicleLoadState( out Vechicle vehicle, ivec2 addr )\n{    \n    BodyLoadState( vehicle.body, addr + offsetVehicleBody );\n\n    vec4 vParam0;\n    vParam0 = LoadVec4( addr + offsetVehicleParam0 );\n    vehicle.fSteerAngle = vParam0.x;\n}\n\nvoid VehicleStoreState( ivec2 addr, const in Vechicle vehicle, inout vec4 fragColor, in vec2 fragCoord )\n{\n    BodyStoreState( addr + offsetVehicleBody, vehicle.body, fragColor, fragCoord );\n    vec4 vParam0 = vec4( vehicle.fSteerAngle, 0.0, 0.0, 0.0 );\n    StoreVec4( addr + offsetVehicleParam0, vParam0, fragColor, fragCoord);\n}\n\n\nstruct Camera\n{\n    vec3 vPos;\n    vec3 vTarget;\n};\n\nvoid CameraLoadState( out Camera cam, in ivec2 addr )\n{\n\tcam.vPos = LoadVec3( addr + offsetCameraPos );\n\tcam.vTarget = LoadVec3( addr + offsetCameraTarget );\n}\n\nvoid CameraStoreState( Camera cam, in ivec2 addr, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec3( addr + offsetCameraPos, cam.vPos, fragColor, fragCoord );\n    StoreVec3( addr + offsetCameraTarget, cam.vTarget, fragColor, fragCoord );    \n}\n\n// ------------ 8< ------------ 8< ------------ 8< ------------ 8< ------------\n\n\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\n// RAYTRACE\n\nfloat kFarClip=10.0;\n\nstruct SurfaceInfo\n{\n    vec3 vUVW;\n    int iId;\n};\n\nstruct ClosestSurface\n{\n    float fDist;\n    SurfaceInfo surface;\n};\n    \nvoid ClosestSurfaceInit( inout ClosestSurface closest, int iId, vec3 vUVW )\n{\n    closest.fDist = 10000.0;\n    closest.surface.vUVW = vUVW;\n    closest.surface.iId = iId;\n}\n\n\nClosestSurface ClosestSurfaceUnion( const in ClosestSurface a, const in ClosestSurface b )\n{\n    if ( a.fDist < b.fDist )\n    {\n        return a;\n    }\n\n    return b;        \n}\n    \nstruct C_Intersection\n{\n\tvec3 vPos;\n\tfloat fDist;\t\n\tvec3 vNormal;\n    SurfaceInfo surface;\n};\n    \n\n///////////////////\n// Scene\n\n#define MAT_TERRAIN 1\n#define MAT_CAR_BODY 4\n#define MAT_CAR_WINDOW 3\n#define MAT_CHROME 3\n#define MAT_GRILL 2\n#define MAT_BLACK_PLASTIC 2\n#define MAT_AXLE 2\n#define MAT_WHEEL 5\n#define MAT_REAR 2\n#define MAT_SUSPENSION 6\n#define MAT_WOOD 7\n\nfloat GetTerrainDistance( const vec3 vPos )\n{    \n    return vPos.y - GetTerrainHeightSimple( vPos );\n    /*\n    float fbm = FBM( vPos.xz * vec2(0.5, 1.0), 0.5 );\n    float fTerrainHeight = fbm * fbm;\n    fTerrainHeight = fTerrainHeight * (sin(vPos.x * 0.1) + 1.0) * 0.5 + vPos.y + 3.0;    \n    \n    //float h = 1.0 - exp(-abs(vPos.x + 15.0) * 0.01);\n    \n    //fTerrainHeight += sin(vPos.x * 0.05) * 5.0 * h;\n    //fTerrainHeight += sin(vPos.z * 0.05) * 5.0 * h;\n    fTerrainHeight -= 2.5;\n\n\treturn fTerrainHeight;\n*/\n}\n\nClosestSurface GetEnvironmentClosestSurface( const vec3 vPos )\n{\n    ClosestSurface terrainClosest;\n    terrainClosest.surface.iId = MAT_TERRAIN;\n    terrainClosest.surface.vUVW = vec3(vPos.xz,0.0);\n    terrainClosest.fDist = GetTerrainDistance( vPos );\n\n    return terrainClosest;\n}\n\nClosestSurface GetSceneClosestSurface( const vec3 vPos )\n{    \n    ClosestSurface closest = GetEnvironmentClosestSurface( vPos );\n    \n    return closest;\n}\n\nvec3 GetSceneNormal( const in vec3 vPos )\n{\n    const float fDelta = 0.0001;\n\n    vec3 vDir1 = vec3( 1.0, -1.0, -1.0);\n    vec3 vDir2 = vec3(-1.0, -1.0,  1.0);\n    vec3 vDir3 = vec3(-1.0,  1.0, -1.0);\n    vec3 vDir4 = vec3( 1.0,  1.0,  1.0);\n\t\n    vec3 vOffset1 = vDir1 * fDelta;\n    vec3 vOffset2 = vDir2 * fDelta;\n    vec3 vOffset3 = vDir3 * fDelta;\n    vec3 vOffset4 = vDir4 * fDelta;\n\n    ClosestSurface c1 = GetSceneClosestSurface( vPos + vOffset1 );\n    ClosestSurface c2 = GetSceneClosestSurface( vPos + vOffset2 );\n    ClosestSurface c3 = GetSceneClosestSurface( vPos + vOffset3 );\n    ClosestSurface c4 = GetSceneClosestSurface( vPos + vOffset4 );\n\t\n    vec3 vNormal = vDir1 * c1.fDist + vDir2 * c2.fDist + vDir3 * c3.fDist + vDir4 * c4.fDist;\t\n\t\t\n    return normalize( vNormal );\n}\n\nvoid TraceScene( out C_Intersection outIntersection, const in vec3 vOrigin, const in vec3 vDir )\n{\t\n\tvec3 vPos = vec3(0.0);\n\t\n\tfloat t = 0.1;\n\tconst int kRaymarchMaxIter = 32;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\n\t\tfloat fClosestDist = GetSceneClosestSurface( vOrigin + vDir * t ).fDist;\n\t\tt += fClosestDist;\n\t\tif(abs(fClosestDist) < 0.01)\n\t\t{\n\t\t\tbreak;\n\t\t}\t\t\n\t\tif(t > kFarClip)\n\t\t{\n\t\t\tt = kFarClip;\n\t\t\tbreak;\n\t\t}\n\t}\n    \n\toutIntersection.fDist = t;\n\toutIntersection.vPos = vOrigin + vDir * t;\n    \n    if( t >= kFarClip )\n    {\n        outIntersection.surface.iId = 0;\n        outIntersection.surface.vUVW = vec3( 0.0 );\n        outIntersection.vNormal = vec3(0.0, 1.0, 0.0);\n    }\n    else\n    {\n\t\toutIntersection.vNormal = GetSceneNormal( outIntersection.vPos );\n        outIntersection.surface = GetSceneClosestSurface( outIntersection.vPos ).surface;\n    }\n}\n\n///////////////////\n\n\nvoid BodyResetForFrame( inout Body body )\n{\n    body.vForce = vec3(0.0);\n    body.vTorque = vec3(0.0);\n}\n\nvoid BodyCalculateDerivedState( inout Body body )\n{\n    body.mRot = QuatToMat3( body.qRot );    \n}\n\nvoid BodyApplyGravity( inout Body body, float dT )\n{\n    float fAccel_MpS = -9.81;\n    body.vForce.y += body.fMass * fAccel_MpS;\n}\n\nvoid BodyIntegrate( inout Body body, float dT )\n{\n#ifdef ENABLE_GRAVITY_TOGGLE    \n    if( !KeyIsToggled( KEY_G ) )\n#endif // ENABLE_GRAVITY_TOGGLE        \n    {\n    \tBodyApplyGravity( body, dT );\n    }\n    \n    body.vMomentum += body.vForce * dT;\n    body.vAngularMomentum += body.vTorque * dT;\n    \n    vec3 vVel = body.vMomentum / body.fMass;\n    vec3 vAngVel = body.vAngularMomentum / body.fIT;\n\n    body.vPos += vVel * dT;\n    vec4 qAngDelta = QuatFromVec3( vAngVel * dT );\n    body.qRot = QuatMul( qAngDelta, body.qRot );\n\n    body.qRot = normalize( body.qRot );\n}\n\nvoid BodyApplyForce( inout Body body, vec3 vPos, vec3 vForce )\n{    \n    body.vForce += vForce;\n    body.vTorque += cross(vPos - body.vPos, vForce);     \n}\n\nvoid BodyApplyImpulse( inout Body body, vec3 vPos, vec3 vImpulse )\n{    \n    body.vMomentum += vImpulse;\n    body.vAngularMomentum += cross(vPos - body.vPos, vImpulse);     \n}\n\nvec3 BodyPointVelocity( const in Body body, vec3 vWorldPos )\n{\n    vec3 vVel = body.vMomentum / body.fMass;\n    vec3 vAngVel = body.vAngularMomentum / body.fIT;\n    \n    return vVel + cross( vAngVel, vWorldPos - body.vPos );\n}\n\n\nvoid BodyApplyDebugForces( inout Body body )\n{\n#ifdef ENABLE_DEBUG_FORCES    \n    float debugForceMag = 20000.0;\n    if ( KeyIsPressed( KEY_LEFT ) )\n    {\n        vec3 vForcePos = body.vPos;\n        vec3 vForce = vec3(-debugForceMag, 0.0, 0.0);\n        BodyApplyForce( body, vForcePos, vForce );\n    }\n    if ( KeyIsPressed( KEY_RIGHT ) )\n    {\n        vec3 vForcePos = body.vPos;\n        vec3 vForce = vec3(debugForceMag, 0.0, 0.0);\n        BodyApplyForce( body, vForcePos, vForce );\n    }\n    if ( KeyIsPressed( KEY_UP ) )\n    {\n        vec3 vForcePos = body.vPos;\n        vec3 vForce = vec3(0.0, 0.0, debugForceMag);\n        BodyApplyForce( body, vForcePos, vForce );\n    }\n    if ( KeyIsPressed( KEY_DOWN ) )\n    {\n        vec3 vForcePos = body.vPos;\n        vec3 vForce = vec3(0.0, 0.0, -debugForceMag);\n        BodyApplyForce( body, vForcePos, vForce );\n    }\n#endif // ENABLE_DEBUG_FORCES                \n    \n    float debugTorqueMag = 4000.0;\n    if ( KeyIsPressed( KEY_COMMA ) )\n    {\n        vec3 vForcePos = body.vPos;\n        vec3 vForce = vec3(0.0, -debugTorqueMag, 0.0);\n\t\tvForcePos.x += 2.0;\n        BodyApplyForce( body, vForcePos, vForce );\n\t\t//vForcePos.x -= 4.0;\n        //vForce = -vForce;\n        //BodyApplyForce( body, vForcePos, vForce );\n    }\n    if ( KeyIsPressed( KEY_PER ) )\n    {\n        vec3 vForcePos = body.vPos;\n        vec3 vForce = vec3(0.0, debugTorqueMag, 0.0);\n\t\tvForcePos.x += 2.0;\n        BodyApplyForce( body, vForcePos, vForce );\n\t\t//vForcePos.x -= 4.0;\n        //vForce = -vForce;\n        //BodyApplyForce( body, vForcePos, vForce );\n    }        \n}\n\nvoid BodyFloatShapeSphere( inout Body body, vec3 vSphereWorld, float fSphereRadius, float dT )\n{   \n    float fDistUnderwater = fSphereRadius - vSphereWorld.y;\n    float fFractionUnder = clamp( fDistUnderwater / (fSphereRadius * 2.0), 0.0, 1.0);\n    \n    if ( fFractionUnder > 0.01 )\n    {\n        vec3 vForcePos = vSphereWorld;        \n        vec3 vForce = vec3(0,1,0) * fFractionUnder * 2500.0;\n        BodyApplyForce( body, vForcePos, vForce );\n\n\n        // hack drag\n\n        vec3 vPointVel = BodyPointVelocity( body, vSphereWorld );\n\n        vec3 vFlowRateAndFoam = GetFlowRate( vForcePos.xz );\n\n        //vec3 vRiverVel = vec3(vFlowRateAndFoam.x, 0.0, vFlowRateAndFoam.z) * kSceneScale;\n        vec3 vRiverVel = -vec3(vFlowRateAndFoam.x, 0.0, vFlowRateAndFoam.y) * kSceneScale;\n \n        vec3 vDragForce = (fFractionUnder * ( vRiverVel - vPointVel )) * 400.;\n\n        if ( dot(vDragForce, vDragForce) > 0.0 )\n        {        \n            vec3 vBoatForwardsDir = ObjToWorld( vec3(1,0,0), body.mRot);\n            float fLongDot = dot(vBoatForwardsDir, normalize(vDragForce));\n            vDragForce *= (1.0 -abs(fLongDot)) * .6 + .4;\n\n            BodyApplyForce( body, vForcePos, vDragForce );\n        }\n\n    }\n}\n\n\nvoid BodyCollideShapeSphere( inout Body body, vec3 vSphereOrigin, float fSphereRadius, float dT )\n{           \n    vec3 vSphereWorld = ObjToWorld( vSphereOrigin, body.mRot) + body.vPos;\n    \n    BodyFloatShapeSphere( body, vSphereWorld, fSphereRadius, dT );\n        \n    ClosestSurface closest = GetSceneClosestSurface( vSphereWorld );\n    \n    float fDepth = fSphereRadius - closest.fDist;\n    \n    if ( fDepth < 0.0 )\n        return;\n    \n    vec3 vNormal = GetSceneNormal( vSphereWorld );\n    vec3 vHitPos = vSphereWorld - vNormal * closest.fDist;    \n    vec3 vPointVel = BodyPointVelocity( body, vHitPos );\n    \n    float fDot = dot( vPointVel, vNormal );\n    \n    if( fDot >= 0.0 )\n        return;\n    \n    float fRestitution = 0.5;\n    \n    vec3 vRelativePos = (vHitPos - body.vPos);\n    float fDenom = (1.0/body.fMass );\n    float fCr = dot( cross( cross( vRelativePos, vNormal ), vRelativePos), vNormal);\n    fDenom += fCr / body.fIT;\n    \n    float fImpulse = -((1.0 + fRestitution) * fDot) / fDenom;\n    \n    fImpulse += fDepth / fDenom;\n    \n    vec3 vImpulse = vNormal * fImpulse;\n    \n    vec3 vFriction = Vec3Perp( vPointVel, vNormal ) * body.fMass;\n    float fLimit = 100000.0;\n    float fMag = length(vFriction);\n    if( fMag > 0.0 )\n    {\t        \n        vFriction = normalize( vFriction );\n\n        fMag = min( fMag, fLimit );\n        vFriction = vFriction * fMag;\n\n        //BodyApplyForce( body, vHitPos, vFriction );\n        vImpulse += vFriction * dT;        \n    }\n    else\n    {\n        vFriction = vec3(0.0);\n    }\n    \n    BodyApplyImpulse( body, vHitPos, vImpulse );\n}\n\n\nvec4 kCollideSpheres[] = vec4[] ( \n        vec4( 0.0, 0.0,  1.5, 0.4),\n    \n        vec4( 0.3, 0.1,  1.0, 0.5),\n        vec4( -0.3, 0.1,  1.0, 0.5),\n    \n        vec4( 0.6, 0.2,  0.0, 0.6),\n        vec4( -0.6, 0.2,  0.0, 0.6),\n    \n        vec4( 0.6, 0.1,  -1.4, 0.5),\n        vec4( -0.6, 0.1,  -1.4, 0.5),\n        vec4( 0.0, 0.0,  -1.5, 0.5)\n);\n  \nvoid BodyCollide( inout Body body, float dT )\n{\n    for (int i=0; i<kCollideSpheres.length(); i++)\n    {\n        BodyCollideShapeSphere( body, kCollideSpheres[i].xyz, kCollideSpheres[i].w, dT );\n    }\n}\n\n\n///////////////////////\n\n///////////////////////\n\nvoid VehicleResetForFrame( inout Vechicle vehicle )\n{\n    BodyResetForFrame( vehicle.body );\n}\n\nvoid VehicleSetup( inout Vechicle vehicle )\n{\n    vehicle.body.fMass = 1000.0;\n    vehicle.body.fIT = 1000.0;\n}\n\n/////////////////////\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (( fragCoord.x > 13.0 ) || ( fragCoord.y > 3.0 ) )\n    {\n        fragColor = vec4(0.0);\n        discard;\n        return;\n    }\n    \n    \n    Vechicle vehicle;\n    \n    VehicleLoadState( vehicle, addrVehicle );\n    VehicleSetup( vehicle );\n    VehicleResetForFrame( vehicle );\n\n    if ( iFrame < 1 )\n    {        \n        vehicle.body.vPos = vec3( 0.0, 0.0, 0.0 );\n        vehicle.body.vMomentum = vec3( 0.0 );\n        vehicle.body.qRot = QuatFromAxisAngle( vec3(0,1,0), -0.8 );\n        vehicle.body.vAngularMomentum = vec3( 0.0, 0.5, 0.0 );        \n        \n        vehicle.fSteerAngle = 0.0;\n    }\n\n    BodyCalculateDerivedState( vehicle.body );\n    \n    // TODO: dT for steering\n    if ( KeyIsPressed( KEY_A ) || KeyIsPressed( KEY_LEFT )  )\n    {\n        vehicle.fSteerAngle += 0.05;\n    }    \n    if ( KeyIsPressed( KEY_D ) || KeyIsPressed( KEY_RIGHT )  )\n    {\n        vehicle.fSteerAngle -= 0.05;\n    }    \n    \n    vehicle.fSteerAngle *= 0.9;\n    \n    float fSteerAngle = vehicle.fSteerAngle * 0.25;// / ( 1.0 + length(vehicle.body.vMomentum) * 0.0001 );\n    \n    float dT = 1.0 / 60.0;\n\n    vec3 vMotorBodyPos = vec3(0,-0.2, -2.0);\n    vec3 vMotorWorld = ObjToWorld( vMotorBodyPos, vehicle.body.mRot) + vehicle.body.vPos;\n    vec3 vMotorBodyDir = vec3(sin(fSteerAngle), 0.0, cos(fSteerAngle));\n    vec3 vMotorDir = ObjToWorld( vMotorBodyDir, vehicle.body.mRot );\n    \n    float fMotorForce = 0.0;\n    if ( KeyIsPressed( KEY_W ) || KeyIsPressed( KEY_UP ) )\n    {\n        fMotorForce += 7.0;\n    }    \n\n    if ( KeyIsPressed( KEY_S ) || KeyIsPressed( KEY_DOWN ) )\n    {\n        fMotorForce -= 2.0;\n    }    \n\n    if ( vMotorWorld.y < 0.0 )\n    {\n    \tBodyApplyForce( vehicle.body, vMotorWorld, vMotorDir * vehicle.body.fMass * fMotorForce );\n    }\n        \n\tBodyApplyDebugForces( vehicle.body );\n    BodyCollide( vehicle.body, dT );\n    \n    BodyIntegrate( vehicle.body, dT );\n\n    fragColor = vec4( 0.0 );\n    \n    VehicleStoreState( addrVehicle, vehicle, fragColor, fragCoord );\n      \n    Camera prevCam;\n    \n    // load old camera data\n    CameraLoadState( prevCam, addrCamera );\n\n    // store in addrPrevCamera\n    CameraStoreState( prevCam, addrPrevCamera, fragColor, fragCoord );\n    \n    Camera cam;\n    \n\tvec2 vMouse = iMouse.xy / iResolution.xy;\n    if ( iMouse.z <= 0.0 && iMouse.y <= 0.0 )\n    {\n        vMouse = vec2(0.5, 0.2);\n    }\n\tfloat fAngle = (-vMouse.x * 2.0 + 1.0) * 3.14;\n   \tfloat fDistance = 8.0 - vMouse.y * 6.0;\n    \n    cam.vTarget = vec3( 0.0, 1.0, 0.0 ) * vehicle.body.mRot + vehicle.body.vPos;\n    cam.vPos = vec3( 0.0, 0.0, -fDistance ) * vehicle.body.mRot + vehicle.body.vPos + vec3(0.0, 2.0, 0.0);\n    \n    cam.vPos -= cam.vTarget;\n    cam.vPos = RotY( cam.vPos, fAngle );\n    cam.vPos += cam.vTarget;\n            \n    CameraStoreState( cam, addrCamera, fragColor, fragCoord );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "musicstream",
                        "id": 11326,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/soundholder/subtle-river-flow-stereo-ms"
                    },
                    {
                        "channel": 3,
                        "ctype": "musicstream",
                        "id": 11327,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/janice0217/indiana-jones-theme-song-hso"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}