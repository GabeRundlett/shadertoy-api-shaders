{
    "Shader": {
        "info": {
            "date": "1712882394",
            "description": "A small ray marching example for rendering a few textured cubes.",
            "flags": 0,
            "hasliked": 0,
            "id": "XfKGDR",
            "likes": 2,
            "name": "Ray marching textured cubes",
            "published": 3,
            "tags": [
                "raymarching",
                "shading",
                "cubes",
                "cuboids",
                "rectangularcuboids",
                "blinnphongshading"
            ],
            "usePreview": 0,
            "username": "pwyr",
            "viewed": 158
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415926535897932384626433832795\n\n#define MAX_DISTANCE 10000.0\n\n#define GAMMA_VALUE 2.2\n\n// =============================================================================\n// Rigid Bodies\n// =============================================================================\n\nstruct RectCuboid{\n    vec3 pos;\n    vec4 rot; // w component is the scalar part (quaternion)\n    vec3 scale;\n};\n\nconst int rigidBodyCount = 5;\n\nRectCuboid[rigidBodyCount] rigidBodies = RectCuboid[](\n    RectCuboid(vec3(0.0, -0.5, 0.0), vec4(0.0, 0.0, 0.0, 1.0), vec3(20.0, 1.0, 20.0)),\n    RectCuboid(vec3(0.0, 0.5, 0.8), vec4(0.0, 0.95, 0.0, 0.309), vec3(1.0)),\n    RectCuboid(vec3(-1.0, 0.5, -0.3), vec4(0.0, 0.809, 0.0, 0.5879), vec3(1.0)),\n    RectCuboid(vec3(0.7, 0.5, -0.3), vec4(0.0, 0.58779, 0.0, 0.809), vec3(1.0)),\n    RectCuboid(vec3(0.0, 1.5, 0.0), vec4(0.0, 0.156, 0.0, 0.9877), vec3(1.0))\n);\n\n// =============================================================================\n// Utilities\n// =============================================================================\n\nmat3 rotMatrixOf(vec4 q) {\n    float xx = q.x*q.x;\n    float yy = q.y*q.y;\n    float zz = q.z*q.z;\n    float xy = q.x*q.y;\n    float xz = q.x*q.z;\n    float xw = q.x*q.w;\n    float yz = q.y*q.z;\n    float yw = q.y*q.w;\n    float zw = q.z*q.w;\n    return mat3(1.0-2.0*(yy+zz), 2.0*(xy-zw), 2.0*(xz+yw),\n                2.0*(xy+zw), 1.0-2.0*(xx+zz), 2.0*(yz-xw),\n                2.0*(xz-yw), 2.0*(yz+xw), 1.0-2.0*(xx+yy));\n}\n\nvec4 gamma(vec4 color) {\n    return pow(color, vec4(vec3(1.0 / GAMMA_VALUE), 1.0));\n}\n\n// =============================================================================\n// Raymarching - Data Retrieval\n// =============================================================================\n\nfloat signedDistanceTo(RectCuboid c, vec3 pos) {\n    // transform in rigid body space\n    vec3 x = rotMatrixOf(c.rot)*(pos - c.pos); \n    // closest point on the cuboid surface\n    vec3 cx = clamp(x, -0.5*c.scale, 0.5*c.scale);\n    return sign(dot(cx,x-cx))*length(x-cx);\n}\n\nfloat signedDistance(vec3 pos, out int rbIndex) {\n    float dist = MAX_DISTANCE;\n    for (int i = 0; i != rigidBodyCount; ++i) {\n        float curDist = signedDistanceTo(rigidBodies[i], pos);\n        if (curDist < dist) {\n            dist = curDist;\n            rbIndex = i;\n        }\n    }\n    return dist;\n}\n\nvec3 normalOf(RectCuboid c, vec3 pos) {\n    vec2 eps = vec2(0.000001, 0.0);\n\n    vec3 normal = vec3(\n        signedDistanceTo(c, pos+eps.xyy) - signedDistanceTo(c, pos-eps.xyy),\n        signedDistanceTo(c, pos+eps.yxy) - signedDistanceTo(c, pos-eps.yxy),\n        signedDistanceTo(c, pos+eps.yyx) - signedDistanceTo(c, pos-eps.yyx)\n    );  \n    \n    // lazy workaround to avoid the necessity of double-precision floating-points\n    if (dot(normal, normal) == 0.0) {\n        eps *= 1000.0;\n        normal = vec3(\n            signedDistanceTo(c, pos+eps.xyy) - signedDistanceTo(c, pos-eps.xyy),\n            signedDistanceTo(c, pos+eps.yxy) - signedDistanceTo(c, pos-eps.yxy),\n            signedDistanceTo(c, pos+eps.yyx) - signedDistanceTo(c, pos-eps.yyx)\n        );  \n    }\n    return normalize(normal);\n}\n\nvec3 colorOf(RectCuboid c, sampler2D tex, vec3 pos) {\n    float eps = 0.01;\n\n    vec3 x = rotMatrixOf(c.rot)*(pos - c.pos); \n    vec3 cx = clamp(x, -0.5*c.scale, 0.5*c.scale);\n    vec2 uv;\n    if (abs(cx.x) > 0.5*c.scale.x - eps)\n        uv = (cx.yz+0.5*c.scale.yz)/c.scale.yz;\n    else if (abs(cx.y) > 0.5*c.scale.y - eps)\n        uv = (cx.xz+0.5*c.scale.xz)/c.scale.xz;\n    else \n        uv = (cx.xy+0.5*c.scale.xy)/c.scale.xy;\n    return texture(tex, uv).xyz;\n} \n\n// =============================================================================\n// Raymarching Algorithm\n// =============================================================================\n\nvec3 rayMarch(vec3 pos, vec3 dir, out int rbIndex) {\n    const float hitEps = 0.001;\n    const int maxIter = 256;\n    \n    float d = 0.0;\n    for (int i = 0; i != maxIter; ++i) {\n        if (d >= MAX_DISTANCE) break;\n        \n        float curDist = signedDistance(pos + d * dir, rbIndex);\n        if (curDist < hitEps) {\n            return pos + d * dir;\n        }\n        d += curDist;\n    }\n    \n    rbIndex = -1;\n    return vec3(0.0);\n}\n\n// =============================================================================\n// Camera\n// =============================================================================\n\nstruct Camera {\n    vec3 pos;\n    mat3 rot;\n} cam;\n\nvoid updateCamera() {\n    float angle = 0.5*iTime;\n    vec4 quat = vec4(sin(angle/2.0)*vec3(0.0,1.0,0.0), cos(angle/2.0));\n    cam.rot = rotMatrixOf(quat);\n    cam.pos = cam.rot * vec3(0.0, 1.3, 7.0);\n}\n\nvec3 viewDir(vec2 fragCoord) {\n    float aspectRatio = iResolution.x / iResolution.y;\n    float fov = 0.5 * PI;\n    vec2 uv = fragCoord/iResolution.xy;\n    float uvScaleX = tan(0.5 * fov);\n    vec2 uvScale = vec2(uvScaleX, uvScaleX / aspectRatio);\n    return cam.rot * rotMatrixOf(vec4(0.0157,0.0,0.0,0.99999)) * normalize(vec3(uvScale*(uv-vec2(0.5)), -1.0));\n}\n\nvec4 backgroundColor(vec3 dir) {\n    float t = pow(abs(dot(vec3(0.0,1.0,0.0), dir)), 0.25);\n    return pow(mix(vec4(0.9,0.2,0.2,1.0), vec4(0.08,0.01,0.01,1.0), min(t+0.3, 1.0)), vec4(vec3(1.3), 1.0));\n}\n\nvec3 floorColor(vec3 pos) {\n    const float invScale = 1.5;\n    float t = 0.3; // texture strength\n    \n    vec2 tileUV = mod(invScale*pos.xz, 1.0);\n    ivec2 pattern = ivec2(mod(invScale*pos.xz, 2.0));\n    if ((pattern.x+pattern.y) % 2 == 0) {\n        return (1.0-t) * vec3(0.02,0.02,0.02) + t * texture(iChannel0, tileUV).xyz;\n    } else {\n        return (1.0-t) * vec3(0.6,0.6,0.6) + t * texture(iChannel1, tileUV).xyz;\n    }\n}\n\n// =============================================================================\n// Light Source\n// =============================================================================\n\nstruct Light {\n    vec3 pos;\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n} light;\n\nvoid updateLight() {\n    light.pos = vec3(10.0, 10.0, 6.0);\n    light.ambient = vec3(0.11, 0.11, 0.11);\n    light.diffuse = vec3(0.7, 0.4, 0.5);\n    light.specular = vec3(1.0, 0.4, 0.4);\n}\n\n// =============================================================================\n// Scene Logic\n// =============================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera updates\n    updateCamera();\n    vec3 dir = viewDir(fragCoord);\n    \n    // ray marching algo\n    int rbIndex;\n    vec3 pos = rayMarch(cam.pos, dir, rbIndex);\n    \n    // bg and rigid body color computation\n    if (rbIndex == -1) {\n        fragColor = gamma(backgroundColor(dir));\n        return;\n    }\n    vec3 color;\n    if (rbIndex == 0) {\n        color = floorColor(pos);\n    } else {\n        color = colorOf(rigidBodies[rbIndex], iChannel0, pos);\n    }\n    \n    // set light pos and colors\n    updateLight();\n\n    // Blinn-Phong shading\n    vec3 ambient = light.ambient * color;\n    \n    vec3 n = normalOf(rigidBodies[rbIndex], pos);\n    vec3 l = normalize(light.pos - pos);\n    vec3 diffuse = light.diffuse * color * max(0.0f, dot(n, l));\n\n    vec3 v = normalize(cam.pos - pos);\n    vec3 h = normalize(l + v);\n    vec3 specular = light.specular * color * pow(max(0.0f, dot(h, n)), 8.0);\n\n    fragColor = gamma(vec4(ambient + diffuse + specular, 1.0f));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}