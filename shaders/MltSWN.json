{
    "Shader": {
        "info": {
            "date": "1479751821",
            "description": "Intended to make metaballs, ready to use the technique for something else. Got it wrong ;) Also added some light + AO.",
            "flags": 0,
            "hasliked": 0,
            "id": "MltSWN",
            "likes": 8,
            "name": "Daily Shade day 20: mmmetaballs",
            "published": 3,
            "tags": [
                "raymarch",
                "daily"
            ],
            "usePreview": 0,
            "username": "psonice",
            "viewed": 710
        },
        "renderpass": [
            {
                "code": "/* \nDay 20: With backgrounds part-done, it’s time to get distracted…\nFixed the occlusion, added some lighting, made a blobby thing.\nThe blobby thing should be more blobby than this, but I can’t\nremember how to do the smooth-junction operation and no internet.\nClose, but no banana.\n*/\n\n//#define DEBUG\n#ifdef DEBUG\nint debugStep = 0;\nfloat debugValue = 0.0;\n#endif\n\n// Rotation\n#define R(p,a) p=cos(a)*p+sin(a)*vec2(-p.y,p.x);\n\n\n#define kINFINITY 10000.0 // An unimaginably large number\n#define kSQRT2 1.414213\n#define kISQRT2 0.707107\n#define kPI 3.141592\n\n// maximum iteration count\n#define kMAXITERS 200\n#define kEPSILON 0.001\n#define kMAXINTERSECTIONS 1\n\n// refractive index\n#define kREFRACT 1.0/1.5\n\n// materials\n#define kFLOORMATERIAL 0\n#define kGLASSMATERIAL 1\n#define kMIRRORMATERIAL 2\n#define kMATTEMATERIAL 3\n\n#define kFLOORCOLOUR vec3(0.7, 0.65, 0.6)\n#define kGLASSCOLOUR vec3(1.0, 0.5, 0.1)\n#define kMIRRORCOLOUR vec3(0.8)\n#define kMATTECOLOUR vec3(0.9, 0.85, 0.8)\n\n#define kZENITHCOLOUR vec3(0.3, 0.7, 1.0)\n#define kNADIRCOLOUR vec3(0.7, 0.6, 0.4)\n#define kHORIZONCOLOUR vec3(0.95)\n#define kSUNCOLOUR vec3(100, 90, 70)\n\n// A ray. Has origin + direction.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n    \n// Distance to nearest surface\nstruct SDResult {\n    float d; // Distance\n    int material; // Nearest material\n};\n\n// A camera. Has a position and a direction. \nstruct Camera {\n    vec3 pos;\n    Ray ray;\n};\n    \n// A disk. Has position, size, colour.\nstruct Disk {\n    vec3 pos;\n    float radius;\n    vec3 col;\n};\n    \nstruct Sphere {\n    vec3 pos;\n    float radius;\n};\n    \nstruct Box {\n\tvec3 pos;\n\tvec3 size;\n    float radius;\n};\n    \nfloat eps = kEPSILON;\nfloat divergence;\n\nvec3 smoothBlend(in vec3 point, in vec3 about, in float radius) {\n    point -= about;\n    point = mix(-point, point, smoothstep(-radius, radius, point));\n    return point + about;\n}\n    \n// Distance to sphere (signed)\nfloat sphereDist(in Ray ray, in Sphere sphere) {\n    return length(ray.origin - sphere.pos) - sphere.radius;\n}\n\n// Distance to sphere surface\nfloat uSphereDist(in Ray ray, in Sphere sphere) {\n    return abs(length(ray.origin - sphere.pos) - sphere.radius);\n}\n\n// Distance to box surface (signed)\nfloat boxDist(in Ray ray, in Box box) {\n    vec3 dist = abs(ray.origin - box.pos) - (box.size * 0.5);\n    vec3 cDist = max(dist, 0.0);\n    return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(cDist) - box.radius;\n}\n\n// Distance to box surface\nfloat uBoxDist(in Ray ray, in Box box) {\n    return abs(length(max(abs(ray.origin - box.pos) - (box.size * 0.5), 0.0)) - box.radius);\n}\n\n// distance to floor\nfloat floorDist(in Ray ray) {\n    float dist = ray.origin.y;\n    return dist;\n}\n\n// traced coords of floor intersection, floor at height y\nvec2 floorPos(in Ray ray, in float y) {\n    float dist = (ray.origin.y - y) / ray.dir.y;\n \treturn ray.origin.xz + ray.dir.xz * dist; \n}\n\n/*\n---- Random/hash stuff ----\n*/\n\n// Normalised random number, borrowed from Hornet's noise distributions: https://www.shadertoy.com/view/4ssXRX\nfloat nrand(in vec2 n) {\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n// random value based on texture channel 2\nvec3 texrand(in vec2 n, in float mipLevel) {\n    return texture(iChannel2, n, mipLevel).xyz;\n}\n\n// returns a hash value for a fixed size cell\nfloat hashForCell(in vec3 pos, in float cellSize) {\n    float hash = nrand(floor(pos.xz / cellSize) + 68.0);\n    return hash;\n}\n\n// returns a random colour based on the cell hash\nvec3 randomColourForCell(in vec3 pos, in float cellSize) {\n\tfloat hash = hashForCell(pos, cellSize); \n    return vec3(\n        nrand(vec2(hash * 2.0, hash * 4.0)),\n        nrand(vec2(hash * 4.0, hash * 8.0)),\n        nrand(vec2(hash * 8.0, hash * 16.0))\n\t);\n\tvec3 c = vec3(hash, mod(hash + 0.15, 1.0), mod(hash + 0.3, 1.0)) * 0.75;\n}\n\n/*\n---- INTERSECTION OPS ----\n*/\n\n// Union of two signed distances\nfloat unionOp(float d0, float d1) {\n    return min(d0, d1);\n}\n\n// Union of two unsigned distances\nfloat unionOpU(float d0, float d1) {\n    return min(d0, d1);\n}\n\nfloat smoothUnionOp(float d0, float d1, float r) {\n    float minD = min(d0, d1);\n    float maxD = max(d0, d1);\n    return mix(minD, maxD, 1. - smoothstep(0.0, r, maxD - minD));\n \treturn min(d0, d1);   \n}\n\n// Intersection of two signed distances\nfloat intersectOp(float d0, float d1) {\n    return max(d0, d1);\n}\n\n// Intersection of two unsigned distances\nfloat intersectOpU(float d0, float d1) {\n    return max(d0, d1);\n}\n\n// Difference of two signed distances\nfloat differenceOp(float d0, float d1) {\n    return max(d0, -d1);\n}\n\n// Difference of two unsigned distances\nfloat differenceOpU(float d0, float d1) {\n    return max(d0, -d1);\n}\n\n/*\n---- Scene rendering ----\n*/\n\n// Get the distance to the scene (returns a struct containing distance and nearest material)\nSDResult sceneDist(in Ray ray) {\n    SDResult result;\n    result.d = kINFINITY;\n    \n    float t = iTime * 1.;\n    \n    for (float i=0.0; i<8.0; i++) {\n       \t// random spheres...\n        Sphere s = Sphere(\n            vec3(\n                sin(i*0.8 + t), \n                sin(i*0.825 + i + t), \n                sin(i*0.8 + i*1.2 + t)) * 7.0,\n            3.0);\n        result.d = smoothUnionOp(result.d, sphereDist(ray, s), 1.0);\n    }\n   \n    result.material = kMATTEMATERIAL;\n    return result;\n}\n\n// Gets the normal\nvec3 normal(in Ray ray) {\n    vec2 eps = vec2(0.0001, 0);\n    float baseDist = sceneDist(ray).d;\n \treturn normalize(vec3(\n        sceneDist(Ray(ray.origin + eps.xyy, ray.dir)).d - baseDist,\n        sceneDist(Ray(ray.origin + eps.yxy, ray.dir)).d - baseDist,\n        sceneDist(Ray(ray.origin + eps.yyx, ray.dir)).d - baseDist\n        ));\n}\n\n// Moves the ray to the surface. Helps avoid artefacts due to ray intersection imprecision.\nvoid clampToSurface(in Ray ray, in float d, inout vec3 n) {\n \tray.origin += n * d;\n \td = sceneDist(ray).d;\n \tn = normal(ray);\n}\n\n// Calulcate a fresnel term for reflections\nfloat fresnelTerm(in Ray ray, in vec3 n, in float power) {\n\tfloat fresnel = min(1., dot(ray.dir, n) + 1.0);\n\tfresnel = pow(fresnel, power);\n    return fresnel;\n}\n\n// gets a reasonable texture coordinate from the normal\nvec2 texCoordFromNormal(in vec3 n) {\n\tvec2 c = n.xy * abs(n.z) + n.xz * abs(n.y) + n.yz * abs(n.x);\n    return c * 0.5 + 0.5;\n//    c.x = mix(n.x, n.y, abs(n.y) - abs(n.x));\n //   c.y = mix(n.y, n.z, abs(n.z) - abs(n.y));\n //   return c * 0.5 + 0.5;\n}\n\n/*\n---- LIGHTING ----\n*/\n\n// Pretty background colour of some sort...\nvec3 backgroundColour (in Ray ray, in float divergence) {\n    \n    // Declare a horizon and extremity (either zenith or nadir)\n    vec3 base, extremity, texture;\n    float x = smoothstep(0.0,1.0,abs(ray.dir.y));\n    \n    if (ray.dir.y >= 0.0) {\n        // sky: fake as hell clouds\n    \tbase = mix(kHORIZONCOLOUR, kZENITHCOLOUR, x);\n        texture = vec3(1);\n        float cloudFactor = 0.0;\n        \n        vec2 coord = ray.dir.xz / 8.0;\n        float scale = 1.0;\n        for (int i=0; i<4; i++) {\n            float offset = iTime * 0.03 / scale;\n            cloudFactor += texrand(coord + vec2(0, -offset), 3.0).r * scale;\n            coord *= 2.0;\n            scale *= 0.5;\n        }\n        cloudFactor /= 1.5;\n        vec3 cloud = mix(vec3(0.4), vec3(1), cloudFactor);\n        base = mix(base, cloud, cloudFactor * ray.dir.y * ray.dir.y);\n        \n    } else {\n        // ground: fake as hell desert\n        texture = kNADIRCOLOUR * 0.5;\n        vec2 floorCoord = floorPos(ray, -30.0);// + vec2(0, iTime * 100.0);\n        texture *= (sin(floorCoord.x * .183 + floorCoord.y * 0.183 + sin(floorCoord.y * 0.3) * 0.5) \n                    + sin(floorCoord.x * .15 + floorCoord.y * 0.22 + sin(floorCoord.x * 0.26) * 0.5))\n            * 0.25 + 0.5;\n\t\tbase = mix(kHORIZONCOLOUR, kNADIRCOLOUR + texture, x);\n        \n    }\n    \n    \n    return base;\n}\n\n// Technically broken, but seems to make soft shadows? *shrug*\nfloat occlusion(in Ray ray, in vec3 n) {\n    vec3 origin = ray.origin;\n    float o = 0.0;\n    ray.dir = n;\n    float x = eps;\n    origin += ray.dir * x;\n    for (float i=1.0; i<8.0; i++) {\n    \tray.origin = origin + ray.dir * x;\n        float d = sceneDist(ray).d;\n        o += max(x - d, 0.0) / x / i * 0.5;\n        \n        x *= 2.0;\n    }\n \treturn 1.0 - o;\n}\n\nvec3 light(in Ray ray, in vec3 n) {\n    // get the half-angle\n    ray.dir = (ray.dir, n) * 0.5;\n    return backgroundColour(ray, 0.0);\n}\n\n/*\n---- RAY MARCHING ----\n*/\n\n// The main marching loop\nvoid marchRay(inout Ray ray, inout vec3 colour) {\n    bool inside = false; // are we inside or outside the glass object\n    vec3 impact = vec3(1); // This decreases each time the ray passes through glass, darkening colours\n\n    vec3 startpoint = ray.origin;\n    \n#ifdef DEBUG   \nvec4 debugColour = vec4(1, 0, 0, 1);\n#endif\n    \n    SDResult result;\n    vec3 n;\n    vec3 glassStartPos;\n    \n    for (int i=0; i<kMAXITERS; i++) {\n        // Get distance to nearest surface\n        result = sceneDist(ray);\n        \n        // Step half that distance along ray (helps reduce artefacts)\n        float stepDistance = inside ? abs(result.d) : result.d;\n        ray.origin += ray.dir * stepDistance * 0.3;\n        if (length(ray.origin) > 40.0) { break; }\n        \n        if (stepDistance < eps) {\n            // colision\n            // normal\n            // Get the normal, then clamp the intersection to the surface\n    \t\tn = normal(ray);\n            //clampToSurface(ray, stepDistance, n);\n#ifdef DEBUG\n#endif\n            \n            if ( result.material == kMATTEMATERIAL ) {\n                // ray hit thing\n                \n                // tex coord from normal\n                vec2 coord = texCoordFromNormal(n);\n                \t\n                float fresnel = fresnelTerm(ray, n, 2.0);\n                \n                // Add some noise to the normal, since this is pretending to be grit...\n                vec3 randomNoise = texture(iChannel2, n.xy * .50, fresnel * 4.0).rgb;\n                randomNoise += texture(iChannel2, n.xz * .50, fresnel * 4.0).rgb;\n                randomNoise += texture(iChannel2, n.yz * .50, fresnel * 4.0).rgb;\n                randomNoise /= 3.0;\n                n = mix(n, randomNoise, 0.3);\n                colour = kMATTECOLOUR * light(ray, n) * vec3(occlusion(ray, n));\n                /*\n\t\t\t\tn = mix(n, normalize(vec3(randomNoise.x, 1, randomNoise.y)), randomNoise.z);\n                \n                // Colour is just grey with crappy fake lighting...\n                colour += mix(\n                    kFLOORCOLOUR, \n                    vec3(0), \n                    pow(max((-n.x+n.y) * 0.5, 0.0), 2.0)\n                ) * impact;\n\t\t\t\t*/\n                impact *= 0.;\n                break;\n            }\n            \n            // check what material it is...\n            \n            if (result.material == kMIRRORMATERIAL) {\n                \n                // handle interior glass / other intersecion\n                if (inside) {\n                     float glassTravelDist =  min(distance(glassStartPos, ray.origin) / 16.0, 1.);\n    \t\t\t\tglassStartPos = ray.origin;\n                    // mix in the colour\n                \timpact *= mix(kGLASSCOLOUR, kGLASSCOLOUR * 0.1, glassTravelDist);\n                    \n                }\n                \n                // it's a mirror, reflect the ray\n                ray.dir = reflect(ray.dir, n);\n                    \n                // Step 2x epsilon into object along normal to ensure we're beyond the surface\n                // (prevents multiple intersections with same surface)\n                ray.origin += n * eps * 2.0;\n                \n                // Mix in the mirror colour\n                impact *= kMIRRORCOLOUR;\n                \n            } else {\n                // glass material\n            \n                if (inside) {\n                \t// refract glass -> air\n                \tray.dir = refract(ray.dir, -n, 1.0/kREFRACT);\n                    \n                    // Find out how much to tint (how far through the glass did we go?)\n                    float glassTravelDist =  min(distance(glassStartPos, ray.origin) / 16.0, 1.);\n    \n                    // mix in the colour\n                \timpact *= mix(kGLASSCOLOUR, kGLASSCOLOUR * 0.1, glassTravelDist);\n                    \n#ifdef DEBUG\ndebugValue += glassTravelDist / 2.0;\n#endif\n      \n                \n              \t} else {\n               \t\t// refract air -> glass\n                \tglassStartPos = ray.origin;\n                    \n              \t  \t// Mix the reflection in, according to the fresnel term\n                \tfloat fresnel = fresnelTerm(ray, n, 1.0);\n                    fresnel = fresnel;\n    \t\t\t\t/*\n                    colour = mix(\n                    \tcolour, \n                    \ttexture(iChannel1, reflect(ray.dir, n)), \n                    \tvec4(fresnel) * impact);\n*/\n                    colour = mix(\n                        colour,\n                        backgroundColour(ray, 0.0),\n                        vec3(fresnel) * impact);\n                    impact *= 1.0 - fresnel;\n    \t\t\t\n                \t// refract the ray\n            \t\tray.dir = refract(ray.dir, n, kREFRACT);\n                    \n#ifdef DEBUG\n//debugValue += 0.5;\n#endif\n                }\n            \n            \t// Step 2x epsilon into object along normal to ensure we're beyond the surface\n                ray.origin += (inside ? n : -n) * eps * 2.0;\n                \n                // Flip in/out status\n                inside = !inside;\n            }\n        }\n        \n        // increase epsilon\n        eps += divergence * stepDistance;\n    }\n    \n    // So far we've traced the ray and accumulated reflections, now we need to add the background.\n   // colour += texture(iChannel0, ray.dir) * impact;\n    ray.origin = startpoint;\n    colour.rgb += backgroundColour(ray, 0.0) * impact;\n    \n#ifdef DEBUG\n//debugColour.rgb = ray.dir;\ndebugColour.rgb = vec3(float(debugStep)/2.0);\ncolour = debugColour;\n#endif\n}\n\n// Sets up a camera at a position, pointing at a target.\n// uv = fragment position (-1..1) and fov is >0 (<1 is telephoto, 1 is standard, 2 is fisheye-like)\nCamera setupCam(in vec3 pos, in vec3 target, in float fov, in vec2 uv) {\n\t\t// cam setup\n    // Create camera at pos\n\tCamera cam;\n    cam.pos = pos;\n    \n    // A ray too\n    Ray ray;\n    ray.origin = pos;\n    \n    // FOV is a simple affair...\n    uv *= fov;\n    \n    // Now we determine hte ray direction\n\tvec3 cw = normalize (target - pos );\n\tvec3 cp = vec3 (0.0, 1.0, 0.0);\n\tvec3 cu = normalize ( cross(cw,cp) );\n\tvec3 cv = normalize ( cross (cu,cw) );\n    \n\tray.dir = normalize ( uv.x*cu + uv.y*cv + 0.5 *cw);\n    \n    // Add the ray to the camera and our work here is done.\n\tcam.ray = ray;\n    \n    // Ray divergence\n    divergence = fov / iResolution.x;\n    \n\treturn cam;\n}\n\nvec3 camPath(in float time) {\n    float r = 20.0;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = mouse * kPI * 2.0 + kPI;\n    vec3 camPos = vec3(r, 0, 0);\n\t\n    R(camPos.xz, time + mouse.x);\n    R(camPos.zy, sin(time) * kPI + mouse.y);\n    \n    return camPos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // We'll need a camera. And some perspective.\n    \n\t// Get some coords for the camera angle from the frag coords. Convert to -1..1 range.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2. - 1.;\n    \n    // Aspect correction so we don't get oval bokeh\n    uv.y *= iResolution.y/iResolution.x;\n    \n    // Make a camera with ALL NEW AND IMPROVED! camera code :)\n    float camTime = iTime / 4.0;\n    vec3 camPos = camPath(camTime);\n    vec3 camTarget = vec3(0);\n    //camTarget.y -= 3.0;\n    Camera cam = setupCam(camPos, camTarget, 0.500, uv);\n    \n    // Let's raymarch some stuff and inject that into the scene...\n    \n    // Create an empty colour\n    vec3 col = vec3(0);\n    \n    // Trace that ray!\n    marchRay(cam.ray, col);\n    \n\tfragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}