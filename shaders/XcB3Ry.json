{
    "Shader": {
        "info": {
            "date": "1704347812",
            "description": "Gravitational fluid simulation accelerated with a data structure similar to Radiance Cascades",
            "flags": 48,
            "hasliked": 0,
            "id": "XcB3Ry",
            "likes": 37,
            "name": "Continuous gravity simulation 2",
            "published": 3,
            "tags": [
                "advection",
                "physics",
                "gravity",
                "cfd"
            ],
            "usePreview": 1,
            "username": "Suslik",
            "viewed": 1829
        },
        "renderpass": [
            {
                "code": "// Controls: click anywhere on the image, then hit spacebar or the |< button.\n// Depending on where you click before restarting, it will create different initial conditions.\n// Use LMB to add mass anywhere.\n\n// The core observation that inspired this demo is that gravity interaction where each point is gravitationally pulled by and pulls  \n// every other point is very similar to interaction in global illumination where every point of every surface lights every other point.\n// This many-to-many N^2 long-distance interaction seems to be represented very well by separating long-distance and short-distance\n// interactions into a hierarchy of cascades of varying spatial frequencies -- the core idea used by Radiance Cascades\n// for solving global illumination, and a similar data structure implemented here to solve gravity.\n\n// A continuous solver for the Newton's gravity equation (F=-G m1 m2 / r^2)\n// based on a data structure similar to Radiance Cascades (https://www.shadertoy.com/view/mlSfRD)\n// uses the same integration as https://www.shadertoy.com/view/XfBGWw\n\n\n// There's no particles here, dots you see are just a texture. The model is fully continuous and is more similar to a fluid than particles.\n\n// The scheme conserves mass and momentum (energy or angular momentum are not conserved precisely so there's some energy loss).\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;    \n    fragColor = texture(iChannel0, uv);\n    vec4 resColor = vec4(0.0f);\n    ivec2 atlasSize = ivec2(iResolution.xy);\n    uint cascadeIndex = 0u;//uint(iMouse.y / 100.0f);\n    vec2 atlasUv = GetAtlasBilinearTapPoint(uv, cascadeIndex, atlasSize, 0);\n    \n    vec4 pixel = texture(iChannel0, atlasUv);\n    vec2 impulse = GetImpulse(pixel);\n    float density = GetDensity(pixel);\n    float color = GetColor(pixel);\n    float phase = color / max(1e-7f, density);\n    vec2 velocity = impulse / max(1e-7f, density);\n    vec2 pixelVelocity = velocity * 2.0f;\n    \n    vec4 linearColor = (texture(iChannel0, atlasUv)) * vec4(vec2(0.002f), 1.0f, 1.0f);\n    //fragColor = pow(linearColor, vec4(vec3(1.0f / 2.2f), 1.0f));\n    //fragColor = vec4(velocity / 50.0f, density, 0.0f) * fract(phase / 100.0f);\n    \n    InterpNodes3 interpNodes3 = GetHexGridInterpNodes(fragCoord.xy, vec2(100.0f));\n    \n    float c = 0.0f;\n    for(int i = 0; i < 3; i++)\n    {\n        vec3 node3Seed = hash3i3f(ivec3(interpNodes3.indices[i].xy, 0));\n        float timePhase = float(iFrame) * dt + node3Seed.x;\n        InterpNodes2 interpNodes2 = GetLinearInterpNodes(timePhase, 0.2f);        \n        for(int j = 0; j < 2; j++)\n        {\n            vec3 node2Seed = hash3i3f(ivec3(interpNodes3.indices[i].xy, interpNodes2.indices[j]));\n            float timeDelta = interpNodes2.positions[j] - timePhase;\n            vec2 uv = (fragCoord.xy + pixelVelocity * timeDelta) / 350.0f + node2Seed.xy;\n            \n            vec4 texSample = texture(iChannel1, uv);\n            c += texSample.r * density * interpNodes3.weights[i] * interpNodes2.weights[j];\n        }\n    }\n\n    fragColor.rgb = pow(Vibrance(saturate(c * 0.5f), vec3(0.1f, 0.3f, 0.8f)), vec3(1.0f / 6.0f));\n    \n    //for verification\n    /*vec2 testUv = GetAtlasBilinearTapPoint(uv, cascadeIndex, atlasSize, 1);\n    fragColor = texelFetch(iChannel0, ivec2(atlasSize.x / 2, 0) + ivec2(fragCoord.xy) / 2, 0) / 1.0f;\n    vec2 refDelta = vec2(ivec2(iResolution.xy) / 4 - ivec2(fragCoord.xy) / 2);\n    float l = length(refDelta);\n    vec2 refAcc = refDelta / (l * l * l) * 10000.0f;\n    fragColor = vec4(abs(refAcc - fragColor.xy), 0.0f, 0.0f);*/\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float dt = 0.01f;\nconst uint cascadesCount = 6u;\nconst float minDistance = 1.0f;\nconst float mouseDragDist = 20.0f;\n//this can be 2 or 4\n#define SCALING_FACTOR 4\n\n#if SCALING_FACTOR == 2\n    const float cascade0Dist = 5.0f;\n#else\n    const float cascade0Dist = 5.1f;\n#endif\n\n\n//http://www.jcgt.org/published/0009/03/02/paper.pdf\nuvec3 hash33UintPcg(uvec3 v)\n{\n    v = v * 1664525u + 1013904223u;\n    v.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;\n    //v += v.yzx * v.zxy; //swizzled notation is not exactly the same because components depend on each other, but works too\n\n    v ^= v >> 16u;\n    v.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;\n    //v += v.yzx * v.zxy;\n    return v;\n}\n\nvec3 hash3i3f(ivec3 seed)\n{\n    uvec3 hash_uvec3 = hash33UintPcg(uvec3(seed));\n    return vec3(hash_uvec3) * (1.0f / float(~0u));\n}\n\nvec4 PackPixel(vec2 velocity, float density, float color)\n{\n    return vec4(velocity, density, color);\n}\n\nvec2 GetImpulse(vec4 pixel)\n{\n    return pixel.xy;\n}\n\nfloat GetDensity(vec4 pixel)\n{\n    return pixel.z;\n}\n\nfloat GetColor(vec4 pixel)\n{\n    return pixel.w;\n}\n\nvec4 GatherAdvectedPixel(sampler2D tex, ivec2 dstIndex, int searchRadius, ivec4 gatherMinmax, float dt)\n{\n    ivec2 srcIndex;\n    \n    vec2 resImpulse = vec2(0.0f);\n    float resDensity = 0.0f;\n    float resColor = 0.0f;\n    \n    ivec4 srcMinmax = ivec4(\n        max(gatherMinmax.xy, dstIndex - ivec2(searchRadius)),\n        min(gatherMinmax.zw, dstIndex + ivec2(searchRadius)));\n        \n    for(srcIndex.y = srcMinmax.y; srcIndex.y < srcMinmax.w; srcIndex.y++)\n    {\n        for(srcIndex.x = srcMinmax.x; srcIndex.x < srcMinmax.z; srcIndex.x++)\n        {\n            vec4 srcPixel = texelFetch(tex, srcIndex, 0);\n            vec2 srcImpulse = GetImpulse(srcPixel);\n            float srcDensity = GetDensity(srcPixel);\n            float srcColor= GetColor(srcPixel);\n            vec2 srcVelocity = srcImpulse / max(1e-7f, srcDensity);\n            \n            vec2 advectedIndex = vec2(srcIndex) + srcVelocity * dt;\n            vec2 weights = max(vec2(1.0f, 1.0f) - abs(advectedIndex - vec2(dstIndex)), 0.0f);\n            \n            float weight = weights.x * weights.y;\n            resImpulse += srcImpulse * weight;\n            resDensity += srcDensity * weight;\n            resColor += srcColor * weight;\n        }\n    }\n    return PackPixel(resImpulse, resDensity, resColor);\n}\n\nfloat CrossProduct(vec2 a, vec2 b) //returns a pseudoscalar\n{\n    return a.x * b.y - a.y * b.x;\n}\n\nvec2 CrossProduct(vec2 a, float b) //b is a pseudoscalar\n{\n    return vec2(-a.y, a.x) * b;\n}\n\nvec4 ComputeLocalInteraction(sampler2D tex, ivec2 dstIndex, float dt)\n{\n    float totalDensity = 0.0f;\n    float totalColor = 0.0f;\n    float totalMass = 0.0f;\n    vec2 totalImpulse = vec2(0.0f, 0.0f);\n    vec2 totalMassCenter = vec2(0.0f, 0.0f);\n    float totalAngularImpulse = 0.0f;\n    float totalInertiaMoment = 0.0f;\n\n    vec2 dv = vec2(0.0f, -30.0f) * dt;\n    ivec2 size = textureSize(tex, 0);\n\n    vec4 centerPixel = texelFetch(tex, dstIndex, 0);\n    float resDensity = GetDensity(centerPixel);\n    float resColor = GetColor(centerPixel);\n    \n    int searchRadius = 10;\n    ivec2 offset;\n    for(offset.y = -searchRadius; offset.y <= searchRadius; offset.y++)\n    {\n        for(offset.x = -searchRadius; offset.x <=  searchRadius; offset.x++)\n        {\n            ivec2 srcIndex = dstIndex + offset * 4;\n            vec4 srcPixel = texelFetch(tex, srcIndex, 0);\n            vec2 srcImpulse = GetImpulse(srcPixel);\n            float srcDensity = GetDensity(srcPixel);\n            vec2 delta = -vec2(srcIndex);\n\n            /*srcImpulse += dv * srcDensity;\n            if(srcIndex.x < 0 || srcIndex.y < 0 || srcIndex.x >= size.x || srcIndex.y >= size.y)\n            {\n                srcImpulse = vec2(0.0f);\n                srcDensity = 1e3f;\n            }*/\n            float srcAngularImpulse = -CrossProduct(srcImpulse, delta);\n            float srcInertiaMoment = dot(delta, delta) * srcDensity;\n            vec2 srcMassCenter = srcDensity * vec2(srcIndex);\n            \n            totalMass += srcDensity;\n            totalImpulse += srcImpulse;\n            totalMassCenter += srcMassCenter;\n            totalAngularImpulse += srcAngularImpulse;\n            totalInertiaMoment += srcInertiaMoment;\n        }\n    }\n\n    float invMass = 1.0f / max(1e-7f, totalMass);\n    vec2 resMassCenter = totalMassCenter * invMass;\n    vec2 resMassCenterVelocity = totalImpulse * invMass;\n    \n    float resMassCenterAngularImpulse = totalAngularImpulse - CrossProduct(totalImpulse, resMassCenter);\n    float resMassCenterIntertiaMoment = totalInertiaMoment - dot(resMassCenter, resMassCenter) * totalMass;\n    float resAngularVelocity = resMassCenterAngularImpulse / max(1e-7f, resMassCenterIntertiaMoment);\n    \n    vec2 resVelocity = resMassCenterVelocity - CrossProduct(vec2(dstIndex) - resMassCenter, resAngularVelocity);\n    \n\n    return vec4(PackPixel(resVelocity * resDensity, resDensity, resColor));\n}\n\nfloat Checkerboard(vec2 uv)\n{\n    return step(0.5f, fract(uv.y + 0.5f * step(0.5f, fract(uv.x))));\n}\n\nvec4 VelocityToColor(vec2 v)\n{\n    return length(v) * vec4(v.x > 0.0f ? 1.0f : 0.0f, v.x < 0.0f ? 1.0f : 0.0f, 0.0f, 0.0f);\n}\n\nivec2 GetCascadeSize(ivec2 atlasSize, uint cascadeIndex)\n{\n    ivec2 baseSize = atlasSize / 2;\n    return baseSize >> cascadeIndex;\n}\n\nivec2 GetAtlasPixel(ivec2 cascadePixel, uint cascadeIndex, int fieldIndex, ivec2 atlasSize)\n{\n    ivec2 baseSize = atlasSize / 2;\n    ivec2 currOffset = ivec2(baseSize.x * fieldIndex, 0);\n    ivec2 currSize = baseSize;\n    for(uint i = 0u; i < cascadeIndex; i++)\n    {\n        currOffset.y += currSize.y;\n        currSize.y /= 2;\n    }\n    return currOffset + cascadePixel;\n}\n\nstruct CascadeLocation\n{\n    ivec2 cascadePixel;\n    uint cascadeIndex;\n    int fieldIndex;\n};\n\nCascadeLocation GetCascadeLocation(ivec2 atlasPixel, ivec2 atlasSize)\n{\n    CascadeLocation loc;\n    loc.cascadePixel = ivec2(0);\n    ivec2 baseSize = atlasSize / 2;\n\n    loc.fieldIndex = atlasPixel.x < baseSize.x ? 0 : 1;\n    \n    ivec2 currOffset = ivec2(baseSize.x * loc.fieldIndex, 0);\n    \n    ivec2 currSize = baseSize;\n    for(loc.cascadeIndex = 0u; loc.cascadeIndex < cascadesCount; loc.cascadeIndex++)\n    {\n        if(atlasPixel.y >= currOffset.y && atlasPixel.y < currOffset.y + currSize.y && atlasPixel.x >= currOffset.x && atlasPixel.x <= currOffset.x + currSize.x)\n        {\n            loc.cascadePixel = atlasPixel - currOffset;\n            return loc;\n        }\n        currOffset.y += currSize.y;\n        currSize /= 2;\n    }\n    //loc.cascadeIndex = 0u;\n    loc.fieldIndex = -1;\n    return loc;\n}\n\nint idot(ivec2 a, ivec2 b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\nfloat saturate(float v)\n{\n    return clamp(v, 0.0f, 1.0f);\n}\nvec2 IntegrateGravityRangeAcceleration(sampler2D atlasTex, ivec2 cascadePixel, uint cascadeIndex, ivec2 atlasSize, vec2 dist0Minmax, vec2 fade0Minmax)\n{\n    float dist0Mult = float(1u << cascadeIndex);\n\n    ivec2 cascadeSize = GetCascadeSize(atlasSize, cascadeIndex);\n    int aabbSize = int(floor((dist0Minmax.y + fade0Minmax.y) / dist0Mult + 1.0f));\n    \n    ivec4 aabbMinMax = ivec4(\n        max(ivec2(0), cascadePixel - ivec2(aabbSize)),\n        min(cascadeSize - ivec2(1), cascadePixel + ivec2(aabbSize)));\n        \n     \n    vec2 totalAcceleration = vec2(0.0f);\n    ivec2 baseAtlasPixel = GetAtlasPixel(cascadePixel, cascadeIndex, 0, atlasSize);\n    \n    float areaMult = float((1u << cascadeIndex) * (1u << cascadeIndex));\n    ivec2 srcCascadePixel;\n    for(srcCascadePixel.y = aabbMinMax.y; srcCascadePixel.y <= aabbMinMax.w; srcCascadePixel.y++)\n    {\n        for(srcCascadePixel.x = aabbMinMax.x; srcCascadePixel.x <= aabbMinMax.z; srcCascadePixel.x++)\n        {\n            ivec2 offset = srcCascadePixel - cascadePixel;\n            \n            float len0 = length(vec2(offset)) * dist0Mult;\n            float ratio = 1.0f;\n            ratio *= saturate((len0 - (dist0Minmax.x - fade0Minmax.x)) / (2.0f * fade0Minmax.x));\n            ratio *= saturate(1.0f - (len0 - (dist0Minmax.y - fade0Minmax.y)) / (2.0f * fade0Minmax.y));\n            //if(len0 < dist0Minmax.x || len0 > dist0Minmax.y) ratio *= 0.5f;\n            \n            if(ratio < 1e-3f) continue; \n            \n            \n            ivec2 srcAtlasPixel = baseAtlasPixel + offset;\n            vec4 srcPackedPixel = texelFetch(atlasTex, srcAtlasPixel, 0);\n            float density = GetDensity(srcPackedPixel);\n            float srcMass = density * areaMult;\n            \n            vec2 delta = vec2(offset) * dist0Mult;\n            float l = length(delta);\n            totalAcceleration += ratio * srcMass * delta / max(1e-7f, l * l * l);\n        }\n    }\n    return totalAcceleration;\n}\n\nfloat GetCascadeDist(uint cascadeIndex)\n{\n    return pow(float(SCALING_FACTOR), float(cascadeIndex));\n    //return float(cascadeIndex + 1u);\n}\n\nvec2 GetAtlasBilinearTapPoint(vec2 uv, uint cascadeIndex, ivec2 atlasSize, int fieldIndex)\n{\n    ivec2 baseSize = atlasSize / 2;\n    ivec2 currOffset = ivec2(baseSize.x * fieldIndex, 0);\n    ivec2 currSize = baseSize;\n    for(uint i = 0u; i < cascadeIndex; i++)\n    {\n        currOffset.y += currSize.y;\n        currSize.y /= 2;\n    }\n    return (vec2(currOffset) + vec2(baseSize) * uv / pow(2.0f, float(cascadeIndex))) / vec2(atlasSize);\n}\n\n\n\nconst float pi = 3.141592f;\n\n//Amazing resource explaining cube coordinates of hexagon grids:\n//https://www.redblobgames.com/grids/hexagons/more-pixel-to-hex.html#justin-pombrio\nmat2 skewed_to_grid = mat2(1.0f, 0.0f, 0.5f, sqrt(3.0f) / 2.0f);\n\nvec2 GridToSkewed(vec2 grid_pos)\n{\n    return inverse(skewed_to_grid) * grid_pos;\n}\n\nvec2 SkewedToGrid(vec2 skewed_pos)\n{\n    return skewed_to_grid * skewed_pos;\n}\n\nvec3 SkewedToCube(vec2 skewed_pos)\n{\n    return vec3(skewed_pos.xy, -skewed_pos.x - skewed_pos.y);\n}\n\n//https://justinpombrio.net/programming/2020/04/28/pixel-to-hex.html\nvec3 CubeToTri(vec3 cube_pos)\n{\n    return floor(cube_pos.xyz - cube_pos.zxy);\n}\n\nvec3 TriToHex(vec3 tri_index)\n{\n    return round((tri_index.xyz - tri_index.yzx) / 3.0f);\n}\n\nfloat max3(vec3 v)\n{\n    return max(max(v.x, v.y), v.z);\n}\nfloat HexOuterDist(vec3 cube_delta)\n{\n    return 1.0f - max3(abs(cube_delta.xyz - cube_delta.yzx));\n}\n\nfloat HexInnerDist(vec3 cube_delta)\n{\n    return length(cube_delta) / (sqrt(2.0f) / sqrt(3.0f)); //(sqrt(2.0f) / 2.0f) for inscribed normalization\n}\n\nstruct InterpNodes3\n{\n    vec2 positions[3];\n    ivec2 indices[3];\n    vec3 weights;\n};\n\nInterpNodes3 GetHexGridInterpNodes(vec2 pos, vec2 grid_step)\n{\n    vec2 hex_size = grid_step * sqrt(3.0f);\n    InterpNodes3 interp_nodes3;\n    for(int i = 0; i < 3; i++)\n    {\n        vec2 grid_pos = pos / hex_size;\n        vec2 skewed_offset = vec2(float(i) / 3.0f);\n        vec2 skewed_pos = GridToSkewed(grid_pos) + skewed_offset;\n        vec3 cube_pos = SkewedToCube(skewed_pos);\n        vec3 hex_index = TriToHex(CubeToTri(cube_pos));\n        vec2 hex_skewed_pos = hex_index.xy - skewed_offset;\n        vec2 hex_grid_pos = SkewedToGrid(hex_skewed_pos);\n        interp_nodes3.positions[i] = hex_grid_pos * hex_size;\n        interp_nodes3.indices[i] = ivec2(hex_index.xy) * ivec2(3, 1) + ivec2(i, 0);\n        interp_nodes3.weights[i] = HexOuterDist(cube_pos - hex_index);\n    }\n    return interp_nodes3;\n}\n\nmat2 Rotate2Mat(float ang)\n{\n    return mat2(cos(ang), sin(ang), -sin(ang), cos(ang));\n}\n\nvec2 Rotate2(vec2 vec, float ang)\n{\n    return Rotate2Mat(ang) * vec;\n}\n\nstruct InterpNodes2\n{\n    vec2 positions;\n    ivec2 indices;\n    vec2 weights;\n};\nInterpNodes2 GetLinearInterpNodes(float position, float grid_step)\n{\n    float grid_pos = position / grid_step;\n    vec2 global_phases = vec2(grid_pos * 0.5f) + vec2(0.5f, 0.0);\n    vec2 indices = floor(global_phases) * 2.0f + vec2(0.0f, 1.0f);\n    vec2 weights = vec2(1.0f) - abs(grid_pos - indices);\n    return InterpNodes2(indices * grid_step, ivec2(indices), weights);\n}\n\nfloat SmoothStep(float val)\n{\n    return 3.0f * val * val - 2.0f * val * val * val;\n}\n\nvec3 Vibrance(float val, vec3 base_color)\n{\n    return pow(vec3(saturate(SmoothStep(val))), vec3(1.0f) / (base_color + 1e-6));\n}\n\nconst int VK_SPACE = 32;",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 atlasPixel = ivec2(fragCoord);\n    ivec2 atlasSize = ivec2(iResolution.xy);\n    CascadeLocation loc = GetCascadeLocation(atlasPixel, atlasSize);\n    ivec2 atlasPixelTest = GetAtlasPixel(loc.cascadePixel, loc.cascadeIndex, loc.fieldIndex, atlasSize);\n    ivec2 baseSize = atlasSize / 2;\n\n    ivec2 mousePixel = atlasSize - ivec2(10);\n    \n    vec4 mouseData = texelFetch(iChannel0, mousePixel, 0);\n    vec2 mouseVelocity = (iMouse.z > 0.5f && mouseData.z > 0.5f) ? 0.5f * (iMouse.xy - mouseData.xy) / dt : vec2(0.0f);\n\n    vec4 resColor = vec4(0.0f);\n    if(loc.fieldIndex == 0)\n    {\n        if(loc.cascadeIndex > 0u)\n        {\n            ivec2 baseAtlasPixel = GetAtlasPixel(loc.cascadePixel * 2, loc.cascadeIndex - 1u, loc.fieldIndex, atlasSize);\n            for(int x = 0; x < 2; x++)\n            {\n                for(int y = 0; y < 2; y++)\n                {\n                    resColor += texelFetch(iChannel0, baseAtlasPixel + ivec2(x, y), 0) * 0.25f;\n                }\n            }\n        }else\n        {\n            if(iFrame < 10 || texelFetch(iChannel2, ivec2(VK_SPACE, 0), 0).r > 0.5f)\n            {\n                vec2 delta0 = vec2(atlasPixel) - vec2(baseSize) * vec2(0.4f, 0.45f);\n                vec2 delta1 = vec2(atlasPixel) - vec2(baseSize) * vec2(0.6f, 0.55f);\n                \n                \n                float dir = 0.0f;\n                vec2 velocity = vec2(0.0f);\n                float density = 0.0f;\n                float color = 0.0f;\n                \n                for(int i = 0; i < 250; i++)\n                {\n                    vec3 particleHash0 = hash3i3f(ivec3(i, 0, 0));\n                    vec3 particleHash1 = hash3i3f(ivec3(i, 1, 0));\n                    vec2 delta = vec2(atlasPixel) - vec2(baseSize) * particleHash0.xy;\n                    if(length(delta) < iResolution.x / 100.0f)\n                    {\n                        velocity = (particleHash1.xy - vec2(0.5f)) * 300.0f * (iMouse.x / iResolution.x);\n                        //velocity += vec2(-delta.y, delta.x) * (particleHash1.z - 0.5f) * 10.0f * (iMouse.y / iResolution.y);\n                        density = 6.0f;\n                        float r = length(delta);\n                        float centMass = density * 3.1415f * r * r;\n                        float centAcc = centMass / max(1e-7f, r * r);\n                        vec2 normDelta = delta / max(1e-7f, length(delta));\n                        vec2 tangentDir = vec2(-normDelta.y, normDelta.x);\n                        float centVelocity = sqrt(centAcc * r);\n                        velocity += 1.0f * tangentDir * centVelocity * (particleHash1.z > 0.0f ? 1.0f : 1.0f);\n                        color = 0.5f;\n                    }\n                }\n                vec2 delta = vec2(0.0f);\n                if(length(delta0) < length(delta1))\n                {\n                    delta = delta0;\n                    dir = 1.0f;\n                }else\n                {\n                    delta = delta1;\n                    dir = -1.0f;\n                }\n                vec4 texturedPixel = (texture(iChannel1, vec2(atlasPixel) / vec2(baseSize)) - vec4(0.2f, 0.2f, 0.0f, 0.0f)) * vec4(vec2(0.0f), 5.0f, 1.0f);\n                vec4 packedPixel = PackPixel(velocity * density, density, color * density);\n                float ratio = 1.0f - pow(max(0.0f, 1.0f - iMouse.y / float(atlasSize.y)), 5.0f);\n                resColor = mix(\n                    texturedPixel,\n                    packedPixel,\n                    ratio);\n                    \n                /*resColor = (atlasPixel.x == baseSize.x / 2 && atlasPixel.y == baseSize.y / 2) ?\n                    PackPixel(vec2(0.0f), 10000.0f, 0.0f) :\n                    PackPixel(vec2(0.0f), 0.0f, 0.0f);*/\n            }else\n            {\n                vec4 advectedPixel = GatherAdvectedPixel(iChannel0, atlasPixel, 10, ivec4(ivec2(0), baseSize.xy), dt);\n                vec2 impulse = GetImpulse(advectedPixel);\n                float density = GetDensity(advectedPixel);                \n                float color = GetColor(advectedPixel);\n\n                vec2 acceleration = vec2(0.0f, 0.0f);\n                {\n                    vec2 uv = (vec2(loc.cascadePixel) + vec2(0.5f)) * float(1 << loc.cascadeIndex) / vec2(baseSize);\n                    vec2 atlasUv = GetAtlasBilinearTapPoint(uv, loc.cascadeIndex + 1u, atlasSize, 1);\n                    acceleration += texture(iChannel0, atlasUv).xy;\n                }\n                impulse += acceleration * density * dt;\n                if(iMouse.z > 0.5f && mouseData.z > 0.5f)\n                {\n                    vec2 delta = vec2(atlasPixel) * 2.0f - iMouse.xy;\n                    if(length(delta) < iResolution.x / 100.0f)\n                    {\n                        density += 0.6f;\n                        //vec2 velocity = vec2(sin(iTime * 17.0f), sin(iTime * 7.0f)) * iResolution.x / 20.0f;\n                        //vec2 velocity = vec2(20.0f, 0.0f);//(iMouse.xy - mouseData.xy) * 2.0f;\n                        vec2 velocity = mouseVelocity;\n                        impulse += 0.1f * density * velocity;\n                    }\n                }\n                \n                \n                \n                resColor = PackPixel(impulse, density, color);\n            }\n            //resColor = texelFetch(iChannel1, atlasPixel, 0);\n        }\n    }else\n    if(loc.fieldIndex == 1)\n    {\n        vec2 cascadeRange = vec2(\n            (loc.cascadeIndex == 0u ? 0.0f : GetCascadeDist(loc.cascadeIndex - 1u)) + minDistance,\n            GetCascadeDist(loc.cascadeIndex) + minDistance) * cascade0Dist;\n        vec2 fadeRange = vec2(1 << loc.cascadeIndex, 1 << (loc.cascadeIndex + 1u)) * 2.0f;\n        vec2 acceleration = IntegrateGravityRangeAcceleration(iChannel0, loc.cascadePixel, loc.cascadeIndex, atlasSize, cascadeRange, fadeRange);\n        if(loc.cascadeIndex + 1u < cascadesCount)\n        {\n            vec2 uv = (vec2(loc.cascadePixel) + vec2(0.5f)) * float(1 << loc.cascadeIndex) / vec2(baseSize);\n            vec2 atlasUv = GetAtlasBilinearTapPoint(uv, loc.cascadeIndex + 1u, atlasSize, 1);\n            acceleration += texture(iChannel0, atlasUv).xy;\n        }\n        resColor = vec4(acceleration, 0.1f, 0.0f);\n    }\n    \n    if(atlasPixel.x == mousePixel.x && atlasPixel.y == mousePixel.y)\n    {\n        if(length(iMouse.xy - mouseData.xy) > mouseDragDist)\n        {\n            mouseData.xy = iMouse.xy + normalize(mouseData.xy - iMouse.xy) * mouseDragDist;\n        }\n        if(iMouse.z > 0.5f && mouseData.z < 0.5f) mouseData.xy = iMouse.xy;\n        mouseData.zw = iMouse.zw;\n        resColor = mouseData;\n    }\n    fragColor = resColor;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}