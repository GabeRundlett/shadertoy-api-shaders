{
    "Shader": {
        "info": {
            "date": "1609635273",
            "description": "Donald Duck from Walt Disney.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "3ltyzX",
            "likes": 24,
            "name": "Donald Duck",
            "published": 3,
            "tags": [
                "disney",
                "donald"
            ],
            "usePreview": 0,
            "username": "leon",
            "viewed": 533
        },
        "renderpass": [
            {
                "code": "// Donald Duck from Walt Disney\n// geometry practice, animation test and lighting playground\n//\n// by Leon Denise 2021.01.03\n// \n// thanks to Inigo Quilez, Dave Hoskins, Koltes, NuSan\n// for sharing useful lines of code\n//\n// Licensed under hippie love conspiracy\n\nfloat map(vec3 p);\n\n// NuSan\n// https://www.shadertoy.com/view/3sBGzV\nvec3 getNormal(vec3 p) {\n\tvec2 off=vec2(0.001,0);\n\treturn normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n}\n\n// Inigo Quilez\n// https://www.shadertoy.com/view/Xds3zN\nfloat getAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\nint material;\nconst int mat_skin = 0;\nconst int mat_eye_globe = 1;\nconst int mat_eye_pupil = 2;\nconst int mat_eye_iris = 3;\nconst int mat_beak = 4;\nconst int mat_ear = 5;\nconst int mat_hat_bottom = 6;\nconst int mat_hat_top = 7;\nconst int mat_floor = 8;\n\nfloat rough;\nvec2 mouse;\n\nfloat donald (vec3 p, float scale)\n{\n    float d,dd,ddd,x,y,z;\n    vec3 pp;\n    material = 0;\n    \n    p = p / scale;\n    \n    // head\n    d = sdSphere(p,0.45);\n    \n    // hair\n    dd = sdCone(rx(t(p,0,.5,.3), -.5), vec2(sin(1.4),cos(1.4)), .2);\n    d = u(d, dd, .1);\n    dd = sdCone(rz(rx(t(p,0.1,.5,.3), -.5), .5), vec2(sin(1.4),cos(1.4)), .2);\n    d = u(d, dd, .03);\n    \n    // cheeks\n    dd = sdSphere(t(ax(p),.3,-.2,.3),0.2);\n    d = u(d, dd, .1);\n    \n    // eye lids\n    vec3 axsmooth = vec3(sqrt(p.x*p.x+0.0005),p.yz);\n    dd = sdLink(t(axsmooth,.2,0,.4), .2,.15, .05);\n    d = u(d, dd, .1);\n        \n    // eye globes\n    pp = rx(tz(atx(p,0.2),0.5), .2);\n    dd = sdEllipsoid(pp, vec3(0.15,0.3,0.05));\n    material = dd < d ? mat_eye_globe : material;\n    d = min(d,dd);\n    \n    // eye pupils\n    pp = t(p, -mouse.x*.2, -mouse.y*.3, 0);\n    pp = rx(tz(atx(pp,0.2),0.5), .2);\n    dd = sdEllipsoid(tz(pp,0.05), vec3(0.04, .1, 0.04)*1.5);\n    material = dd < d ? mat_eye_pupil : material;\n    d = min(d,dd);\n    \n    // beak top\n    pp = t(p,0,-.3,0.5+0.3);\n    pp.y -= 0.05*cos(p.x*0.3*tau*5.);\n    pp.y += 0.05*cos(p.z*0.5*tau*2.)*cos(p.z);\n    dd = sdRoundBox(pp, vec3(.3, 0.01, 0.5), .01);\n    dd = diff(dd, length(pp.xz)-0.4, .1);\n    \n    // beak cheeks\n    pp = t(ax(p), 0.3,-.3,.5);\n    ddd = sdSphere(pp, .1);\n    dd = u(dd, ddd, .1);\n    \n    // beak bottom\n    pp = tz(rx(t(p, 0,-.3,.4), -.5), .3);\n    pp.y += 0.1*cos(p.z*5.+2.);\n    ddd = sdRoundCylinder(pp, .15, .01, .01);\n    dd = u(dd, ddd, .1);\n    \n    material = dd < d ? mat_beak : material;\n    d = min(d, dd);\n    \n    // hat bottom\n    pp = ty(rz(p,.3),.45);\n    dd = sdCylinder(pp,.2,.1);\n    material = dd < d ? mat_hat_bottom : material;\n    d = min(d, dd);\n    \n    // hat top\n    dd = sdRoundCylinder(ty(pp, .2), .2,.1+.2*sin(abs(pp.x)),.01);\n    material = dd < d ? mat_hat_top : material;\n    d = min(d, dd);\n    \n    // hat tail\n    pp = t(pp,.3,.1,0).xzy;\n    dd = max(sdCylinder(pp, .3, .1), -sdCylinder(pp, .28, 1.));\n    pp.y = abs(pp.y);\n    pp.yz *= rot(.5);\n    dd = max(-pp.z, dd);\n    material = dd < d ? mat_hat_bottom : material;\n    d = min(d, dd);\n    \n    return d * scale;\n}\n\nfloat map(vec3 p)\n{\n    float d,dd;\n    material = 0;\n    \n    // donald\n    d = donald(rx(ry(p, -.2+.1*sin(iTime)), .1*cos(iTime)), 1.);\n    \n    // little donalds jumping\n    p.z += 2.5;\n    p.y += .3;\n    p.xz *= rot(-iTime);\n    float c = moda(p.xz, 5.);\n    p.x -= 1.5;\n    p = bounce(p, iTime*4.+c, .6, .8);\n    p.zy *= rot(.3*sin(iTime*8.+c));\n    int m = material;\n    dd = donald(p, .4);\n    material = dd < d ? material : m;\n    d = min(d, dd);\n    \n    return d;\n}\n\nvec3 getColor(vec3 pos, vec3 normal, vec3 ray, float shade)\n{\n    vec3 color = vec3(0);\n    rough = 0.2;\n    switch (material)\n    {\n        // skin\n        case mat_skin:\n        color = vec3(1);\n        break;\n        \n        // hat bottom\n        case mat_hat_bottom:\n        color = vec3(0);\n        break;\n        \n        // hat top\n        case mat_hat_top:\n        color = vec3(0,0,1);\n        break;\n\n        // globe\n        case mat_eye_globe:\n        color = vec3(0.6627, 0.8745, 0.9137);\n        break;\n\n        // pupil\n        case mat_eye_pupil:\n        color = vec3(0);\n        break;\n        \n        // beak\n        case mat_beak:\n        color = vec3(0.8667, 0.7451, 0.0471);\n        break;\n        \n        // beak\n        case mat_floor:\n        color = vec3(0);\n        rough = 0.1;\n        break;\n    }\n\n    // shadows\n    float ao = getAO(pos, normal);\n    color *= ao*0.5+0.5;\n    color *= shade*0.5+0.5;\n    \n    return color;\n}\n\nvoid mainImage( out vec4 color, in vec2 coordinate )\n{\n\n    // coordinates\n    vec2 uv = coordinate / iResolution.xy;\n    vec2 p = 2.*(coordinate - 0.5 * iResolution.xy)/iResolution.y;\n    float rng = hash12(coordinate + iTime);\n    \n    // camera\n    vec3 pos = vec3(0,-.1,4);\n    \n    // camera control\n    bool clic = iMouse.z > 0.5;\n    if (clic)\n    {\n        mouse = vec2(iMouse.xy/iResolution.xy)*2.-1.;\n        mouse *= 0.5;\n    }\n    else\n    {\n        mouse = vec2(-.1,0);\n    }\n    \n    pos.yz *= rot(mouse.y-.2);\n    pos.xz *= rot(mouse.x);\n    \n    // look at\n    vec3 z = normalize(vec3(0,-.1,0)-pos);\n    vec3 x = normalize(cross(z, vec3(0,1,0)));\n    vec3 y = normalize(cross(x, z));\n    vec3 ray = normalize(z * 3.8 + x * p.x + y * p.y);\n    \n    // background gradient\n    color = vec4(vec3(0.8667, 0.2392, 0.0471) * ss(3.0, 0., length(p)), 1);\n    \n    // raymarch iteration\n    const int count = 30;\n    for (int index = 0; index < count; ++index)\n    {\n        // estimate distance\n        float dist = map(pos);\n        \n        // hit volume\n        if (dist < 0.01)\n        {\n            // coloring\n            vec3 normal = getNormal(pos);\n            float shade = float(count-index)/float(count);\n            color.rgb = getColor(pos, normal, ray, shade);\n            \n            /*\n            // reflection\n            dist = 0.5+.5*rng;\n            vec3 rngv = hash33(pos*1000.+iTime)*2.-1.;\n            ray = reflect(ray,normalize(normal+rngv*rough));\n            pos += ray*dist;\n            \n            // color diffusion\n            color.rgb += 0.3*getColor(pos, getNormal(pos), ray, shade);\n            */\n            \n            // exit loop\n            break;\n        }\n        \n        // dithering trick inspired by Duke\n        dist *= 0.9 + 0.1 * rng;\n        \n        // keep marching\n        pos += ray * dist;\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nconst float pi = 3.1415;\nconst float tau = 6.283;\n\n// transform shortcuts\n//\n// booleans\n#define u(a,b,k) opSmoothUnion(a,b,k)\n#define sub(a,b,k) opSmoothSubtraction(a,b,k)\n#define diff(a,b,k) opSmoothIntersection(a,b,k)\n// translate\n#define t(p,x,y,z) (p-vec3(x,y,z))\n#define tx(p,x) (p-vec3(x,0,0))\n#define ty(p,y) (p-vec3(0,y,0))\n#define tz(p,z) (p-vec3(0,0,z))\n// rotate\n#define rx(p,a) vec3(p.yz*rot(a),p.x).zxy\n#define ry(p,a) vec3(p.xz*rot(a),p.y).xzy\n#define rz(p,a) vec3(p.xy*rot(a),p.z).xyz\n// mirror\n#define ax(p) vec3(abs(p.x),p.y,p.z)\n#define ay(p) vec3(p.x,abs(p.y),p.z)\n#define az(p) vec3(p.x,p.y,abs(p.z))\n// mirror and offset\n#define atx(p,d) vec3(abs(p.x)-d,p.y,p.z)\n#define atz(p,d) vec3(p.x,p.y,abs(p.z)-d)\n// smooth\n#define ss(a,b,t) smoothstep(a,b,t)\n// repeat\n#define repeat(p,r) (mod(p,r)-r/2.)\n// elongate\n#define ey(p, h) vec3(p.x, p.y - clamp( p.y, -h, h ), p.z)\n\n// Rotation 2D matrix\nmat2 rot(float a) { float c = cos(a), s = sin(a); return mat2(c,-s,s,c); }\n\nvec3 bounce(vec3 p, float time, float jump, float scale)\n{\n    p.y -= abs(cos(time))*jump;\n    float stretch = pow(1.-(0.5+0.5*cos(time*2.)), 20.);\n    p.xz *= 1.-.2*stretch*scale;\n    p.y *= 1.+.4*stretch*scale;\n    return p;\n}\n\n\nfloat moda (inout vec2 p, float count) {\n    float an = tau/count;\n    float a = atan(p.y,p.x)+an*.5;\n    float c = floor(a/an);\n    a = mod(a,an)-an*.5;\n    c = mix(c,abs(c),step(count*.5,abs(c)));\n    p =vec2(cos(a),sin(a))*length(p);\n    return c;\n}\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\n\n// smooth union\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n// smooth substraction\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n// smooth intersection\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n// Sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\n// Cylinder\nfloat sdCylinder(vec3 p, float r, float h)\n{\n    return max(length(p.xz)-r, abs(p.y)-h);\n}\n\n// Dome\nfloat sdDome(vec3 p, float r)\n{\n    return max(p.y, length(p)-r);\n} \n\n// Box\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// Capsule\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n// Ellipsoid\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n// Torus\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// Vertical Capsule\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n// Round Cylinder\nfloat sdRoundCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n// Round Box\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n// Cone\nfloat sdCone( vec3 p, vec2 c, float h )\n{\n  float q = length(p.xz);\n  return max(dot(c.xy,vec2(q,p.y)),-h-p.y);\n}\n\n// Link\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}