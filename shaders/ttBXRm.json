{
    "Shader": {
        "info": {
            "date": "1565377273",
            "description": "Recreating the latest Numberphile's video ([url]https://www.youtube.com/watch?v=pAMgUB51XZA[/url]) on the OEIS A265326 sequence ([url]https://oeis.org/A265326[/url]). Odd numbers also form parallelograms, so there's nothing special about primes here...",
            "flags": 0,
            "hasliked": 0,
            "id": "ttBXRm",
            "likes": 9,
            "name": "OEIS A265326",
            "published": 3,
            "tags": [
                "2d",
                "sequence",
                "bit",
                "primes",
                "oeis"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 967
        },
        "renderpass": [
            {
                "code": "// Created by inigo quilez - iq/2019\n\n// Graphs the sequence OEIS A265326 (https://oeis.org/A265326)\n//\n// Doing this in a shader is very inefficient because this is\n// a 2D grapher tool trying to plot a 1D graph, so each pixel\n// in each pixel row is performing the same computations, and\n// that's a waste. Still, it works.\n\n\n// N numbers per pixel-column\nconst int N = 32;\n\nbool isPrime( int x )\n{\n\tif( x==1 ) return false;\n\tif( x==2 ) return true;\n\tif( x==3 ) return true;\n\tif( x==5 ) return true;\n\tif( x==7 ) return true;\n\tif( (x&1)==0 ) return false;\n\tif( (x%3)==0 ) return false;\n\tif( (x%5)==0 ) return false;\n\n    int xm = 1 + int(sqrt(float(x)));\n    \n\tint y = 7;\n\tfor( int i=0; i<(2560*N/30); i++ )\n\t{\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 4;  if( y>=xm    ) return true;\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 2;  if( y>=xm )    return true;\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 4;  if( y>=xm )    return true;\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 2;  if( y>=xm )    return true;\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 4;  if( y>=xm )    return true;\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 6;  if( y>=xm )    return true;\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 2;  if( y>=xm )    return true;\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 6;  if( y>=xm )    return true;\n\t}\n\t\n\treturn true;\n}\n\nint bit_reverse( int x )\n{\n    // bind the first bit set to 1\n    int n; for( n=31; n>=0; n-- ) if( (x&(1<<n))!=0 ) break;\n    \n    // reverse the rest of the bits\n    int y = 0;\n    for( int i=0; i<=n; i++ )\n    {\n        y <<= 1; \n        y  += 1&x;\n        x >>= 1;\n    }\n    \n    return y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 p = ivec2(floor(fragCoord));\n\tint   h = int(iResolution.y*0.4);\n        \n    float f = 0.0;\n    for( int i=0; i<N; i++ )\n    {\n        int x = N*p.x + i;\n\n      \t// You can replace the if( isPrime(x) ) bellow with\n        // just if( (x&1)==1 ) to see the parallelograms at\n        // full. Since primes except for 2 are all odd this\n        // graph comes as no surprise.\n\n        if( isPrime(x) )\n        {\n            int y = bit_reverse(x) - x;\n            \n            y = h + y/(2*N); // 2N rows per pixel\n            \n            if( y==p.y )\n            {\n                f = 1.0;\n                break;\n            }\n        }\n    }\n    \n    fragColor = vec4(f,f,f,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}