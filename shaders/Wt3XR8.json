{
    "Shader": {
        "info": {
            "date": "1580487748",
            "description": "Zooming in to an Apollonian Gasket. Mouse moves centre of image.\n\na: disable mouse\nv: vary circle radius\nz: disable zoom\n",
            "flags": 16,
            "hasliked": 0,
            "id": "Wt3XR8",
            "likes": 13,
            "name": "Apollonian Zoom",
            "published": 3,
            "tags": [
                "2d",
                "zoom",
                "apollonian"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 430
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Apollonian circles. Iterated inversion in a ring of circles.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float N = 5.0; // Number of circles\nconst int max_iterations = 40;\nconst float pi = 3.14159265;\n\n// Circles are represented as vec3(x,y,r2) where\n// (x,y) is the centre and r2 is the squared radius.\n\n// Invert pos in circle c\nvec2 invert(vec2 pos, vec3 c) {\n  vec2 p = pos-c.xy;\n  float p2 = dot(p,p);\n  return p*c.z/p2 + c.xy;\n}\n  \n// Invert pos in circle if it is inside \nbool checkinverse(inout vec2 pos, vec3 c, inout float r2min) {\n  vec2 p = pos-c.xy; \n  float p2 = dot(p,p);\n  r2min = min(r2min,abs(p2-c.z));\n  if (p2 > c.z) {\n    return false;\n  } else {\n    pos = p*c.z/p2 + c.xy;\n    return true;\n  }\n}\n\nbool checkinverse2(inout vec2 pos, vec3 c, inout float r2min) {\n  vec2 p = pos-c.xy; \n  float p2 = dot(p,p);\n  r2min = min(r2min,abs(p2-c.z));\n  if (p2 < c.z) {\n    return false;\n  } else {\n    pos = p*c.z/p2 + c.xy;\n    return true;\n  }\n}\n\n// N circles in a ring, with tangency points on unit circle,\n// plus a central circle, tangent to the others, plus an\n// surrounding circle, tangent to the ring circles.\n// The radius of the ring circles can vary so as to overlap\n// or to leave a gap.\nvec4 gasket(vec2 pos, bool varyradius){\n  float theta = pi/N;\n  float r = 1.0/cos(theta);\n  float s = tan(theta);\n  float r2min = 1e10;\n  float t = -0.2*iTime;\n  float rfactor = !varyradius?1.0:0.95 + 0.26*(1.0+cos(0.5*iTime));\n  for(int n = 0; n < max_iterations; n++){\n    vec3 c = vec3(0,0,pow(r-s,2.0));\n    // Try inverting in central circle\n    if (!checkinverse(pos,c,r2min) &&\n        !checkinverse2(pos,vec3(0.0,0.0,pow(r+s,2.0)),r2min)) {\n      bool found = false;\n      // else try in the circles of the ring.\n      for (float i = 0.0; i < N; i++) {\n        vec3 c = vec3(r*sin(2.0*i*theta+t),\n                      r*cos(2.0*i*theta+t),\n                      rfactor*s*s);\n        if (checkinverse(pos,c,r2min)) {\n          found = true;\n          break;\n        }\n      }\n      if (!found) return vec4(pos,n,r2min);\n    }\n  }\n  return vec4(pos,max_iterations,r2min);\n}\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 getCol(vec4 n){\n  vec3 col = hsv2rgb(vec3(mod(n.z/20.0,1.0),0.8,0.8));\n  col *= 0.6+0.4*smoothstep(0.05,0.1,sqrt(n.w));\n  return col;\n}\n\nbool keypress(int code) {\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\nconst int CHAR_A = 65;\nconst int CHAR_D = 68;\nconst int CHAR_H = 72;\nconst int CHAR_J = 74;\nconst int CHAR_V = 86;\nconst int CHAR_Z = 90;\n\nvec2 cmul(vec2 z, vec2 w) {\n  return vec2(z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x);\n}\n\nvec2 cinv(vec2 z) {\n  return z/dot(z,z)*vec2(1,-1);\n}\n\nvec2 csqrt(vec2 z) {\n  float r = length(z);\n  return vec2(sqrt(0.5*(r+z.x)),sign(z.y)*sqrt(0.5*(r-z.x)));\n}\n\n#define AA 2.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  fragColor.xyz = vec3(0);\n  vec2 z0 = 2.0 * fragCoord.xy / iResolution.y - vec2(iResolution.x / iResolution.y, 1.0);\n  float zoom = 1.0; \n  if (!keypress(CHAR_Z)) zoom = exp(45.0-mod(0.4*iTime,60.0));\n  for (float i = 0.0; i < AA; i++) {\n    for (float j = 0.0; j < AA; j++) {\n      float delta = 1.0/(AA*iResolution.y);\n      vec2 z = z0 + delta*vec2(i,j);\n      z *= zoom;\n      if (keypress(CHAR_H)) {\n        z.y += 1.0;\n        z = invert(z,vec3(0,-1,2)); // Map half plane to unit disk.\n      }\n      if (keypress(CHAR_D)) {\n        z = invert(z,vec3(0,0,1)); // Invert in unit disk\n      }\n      if (!keypress(CHAR_A) && iMouse.x != 0.0) {\n        vec2 m = 2.0 * iMouse.xy / iResolution.y - vec2(iResolution.x / iResolution.y, 1.0);\n        //m = 1.2*vec2(cos(0.0789*iTime),sin(0.0789*iTime));\n        m *= zoom;\n        // Map origin to m with an inversion\n        vec2 c = m/dot(m,m); // m inverted in unit circle\n        z = invert(z,vec3(c,dot(c,c)-1.0));\n      }\n      bool varyradius = !keypress(CHAR_V);\n      vec4 data = gasket(z,varyradius);\n             \n      fragColor.xyz += getCol(data);\n    }\n  }\n  fragColor.xyz /= AA*AA;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}