{
    "Shader": {
        "info": {
            "date": "1518054114",
            "description": "1st part of Stargate Sequence\n\ncontribution to:\nhttps://www.facebook.com/groups/147749602472741/permalink/200252703889097/",
            "flags": 32,
            "hasliked": 0,
            "id": "4sdcz4",
            "likes": 36,
            "name": "Stargate Sequence-1st part",
            "published": 3,
            "tags": [
                "space",
                "2001",
                "odyssey"
            ],
            "usePreview": 0,
            "username": "patu",
            "viewed": 1934
        },
        "renderpass": [
            {
                "code": "#define time iTime\n#define res iResolution\n\n#define GA 2.399\n#define rot mat2(cos(GA),sin(GA),-sin(GA),cos(GA))\n#define pixel vec3(.001*iResolution.y/iResolution.x,.001, 0)\n\nfloat intensity(vec3 col) {\n\treturn dot(col, vec3(0.2126, 0.7152, 0.0722));\n}\n\n// \tsimplyfied version of Dave Hoskins blur\nvec3 dof(sampler2D tex,vec2 uv,float rad, vec3 org)\n{\n\tvec3 acc=vec3(0);\n    vec2 angle=vec2(0, rad);\n    rad = 2.3;\n    \n\tfor (int j=0;j<64;j++)\n    {  \n        rad += 1./rad;\n\t    angle*=rot;\n        \n        vec3 col=texture(tex,uv+pixel.xy*(rad-1.)*angle).rgb;\n        if (intensity(col) > .1) {            \n\t\t\tacc+=col.xyz;      \n \t    }\n\t}\n\t\n    return org + acc / 64.;\n}\n\n//-------------------------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n\tvec2 uv = gl_FragCoord.xy / res.xy;\n    vec3 orgColor = \n        texture(iChannel0,uv).rgb \n    \t+ texture(iChannel0,uv + pixel.xz).rgb * .5\n        + texture(iChannel0,uv + pixel.zx).rgb * .5\n        + texture(iChannel0,uv - pixel.xz).rgb * .5\n        + texture(iChannel0,uv - pixel.zx).rgb * .5;\n    \n    \n    fragColor=vec4(dof(iChannel0,uv, 5., orgColor / 3.) * .5, 1.);    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float rand(vec3 x) // iq's 3D noise\n{\n    vec3 f = fract(x);\n    vec3 p = x - f;\n    f = f*f*(3.0 - 2.0*f);\n    vec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\n    vec2 rg = texture(iChannel0, (uv + 0.5)/256.0, -100.0).rg;\n    return mix(rg.y, rg.x, f.z);\n}\n\nfloat fbm(vec3 x)\n{\n    float r = 0.0;\n    float w = 1.0, s = 1.0;\n    for (int i=0; i<5; i++)\n    {\n        w *= 0.5;\n        s *= 2.0;\n        r += w * rand(s * x);\n    }\n    return r;\n}\n\nvec4 computeGate(vec2 pos)\n{\n    vec4 col = vec4(0.);\n    pos.y += fbm(vec3(pos.xyx * .01)) * 20.;   \t\n    \n    if (fract(pos.x * 20.) < .4) return col;    \n   \n    pos.y += sin(pos.y * .1) * 15.;\n    \n    col = (vec4(1.) * fbm(vec3(pos * vec2(2., 1.) + 10., 10.)));\t\n   \n    if (fract(col.r * 1.) < .1) col *= 0.;\n        \n    col.r *= clamp(fbm(vec3(pos.xyx + .5)) * 4. * sin(pos.x * 10. + iTime * .6), 0., 1.);\n    col.g *= clamp(fbm(vec3(pos.xyx + 20.)) * 27. * sin(pos.y * 2. - iTime * .2), 0., 1.);\n    col.b *= clamp(fbm(vec3(pos.xyx + 30.)) * 14. * sin(pos.y * 12.- iTime * .44 ) * 1., 0., 1.);\n    \n    col *= round(fbm(vec3(pos.xy, pos.x)));\n    col *= floor(fbm(vec3(pos.yx * 4., 0.)) + .6);\n    \n    return clamp(col, 0., 1.) * 2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 point = (fragCoord.xy / iResolution.xy) - .5;\n\tpoint = point.yx;\n\t\n    vec2 coord = point;\n    //coord.x += 1;\n\tfragColor = 0.* (1.-abs(point.y * 5.)) * clamp(\n        vec4(.5 * sin(-iTime) + .5, .5 * sin(iTime) + .5, 0., 0.), 0., 1.);\n\t\n    coord.y = (0.25/coord.y) * sign(coord.y);\t\n    coord.x *= coord.y;\t\n\tcoord.y += iTime * 5.25;\n\t\t\n\tvec4 center = (vec4(min(1., smoothstep(1., 0.3, pow(abs(point.y * .8), .2)))));\t\n\t//center.gba *= 0.;\n    fragColor += computeGate(coord * vec2(1., sign(point.y))) + center;\t\n    \n    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}