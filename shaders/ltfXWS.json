{
    "Shader": {
        "info": {
            "date": "1439299130",
            "description": "Since these descriptions have a character limit, I made a big ol' comment at the top of the code instead. Wow, look at how much I wrote about this tiny little shader. I do really pointless things sometimes.",
            "flags": 0,
            "hasliked": 0,
            "id": "ltfXWS",
            "likes": 42,
            "name": "Antialiased Blocky Sampling",
            "published": 3,
            "tags": [
                "2d",
                "texture",
                "antialiasing",
                "filtering",
                "aa"
            ],
            "usePreview": 0,
            "username": "Permutator",
            "viewed": 4323
        },
        "renderpass": [
            {
                "code": "/* There are a few shaders on this site already that attempt to do this (most notably\n * <https://www.shadertoy.com/view/ldlSzS>), but none of them were quite what I wanted,\n * so I made this one myself.\n * \n * It has an interface almost as simple as texture's, with only one extra parameter\n * for the resolution of the texture. You don't need to pass in the screen resolution\n * or anything, since it uses dFdx and dFdy. I haven't tested this, but it should also\n * work on textures that have been transformed in complex ways, such as ones in 3D\n * environments.\n * It doesn't use fwidth. It uses the Pythagorean Theorem instead. I don't really get\n * why fwidth doesn't just work like that in the first place... Maybe fwidth has some\n * hidden meaning that I don't understand? In any case, it isn't the right function\n * for this.\n * It also has no branching and only calls texture once, using the GPU's built-in\n * bilinear interpolation.\n * \n * You can honestly just lift the v2len and textureBlocky functions out of this shader,\n * put them into your own, and use them. It's very easy.\n * \n * Since copyright law exists, I guess I ought to put this under a license of some kind\n * if I want you to be able to use it. It's tiny and actually rather self-evident, so\n * I'll put it under the CC0 1.0 Public Domain Dedication:\n * <http://creativecommons.org/publicdomain/zero/1.0/>\n * Ta-dahhh! Now you can use it however you want without even giving me credit.\n */\n\n\n\n// change this value to compare different interpolation methods.\n// \n// 0: antialiased blocky interpolation\n// 1: linear interpolation\n// 2: aliased blocky interpolation\n#define RENDER_MODE 0\n\n\n\n// basically calculates the lengths of (a.x, b.x) and (a.y, b.y) at the same time\nvec2 v2len(in vec2 a, in vec2 b) {\n    return sqrt(a*a+b*b);\n}\n\n\n// samples from a linearly-interpolated texture to produce an appearance similar to\n// nearest-neighbor interpolation, but with resolution-dependent antialiasing\n// \n// this function's interface is exactly the same as texture's, aside from the 'res'\n// parameter, which represents the resolution of the texture 'tex'.\nvec4 textureBlocky(in sampler2D tex, in vec2 uv, in vec2 res) {\n    uv *= res; // enter texel coordinate space.\n    \n    \n    vec2 seam = floor(uv+.5); // find the nearest seam between texels.\n    \n    // here's where the magic happens. scale up the distance to the seam so that all\n    // interpolation happens in a one-pixel-wide space.\n    uv = (uv-seam)/v2len(dFdx(uv),dFdy(uv))+seam;\n    \n    uv = clamp(uv, seam-.5, seam+.5); // clamp to the center of a texel.\n    \n    \n    return texture(tex, uv/res, -1000.).xxxx; // convert back to 0..1 coordinate space.\n}\n\n\n\n// simulates nearest-neighbor interpolation on a linearly-interpolated texture\n// \n// this function's interface is exactly the same as textureBlocky's.\nvec4 textureUgly(in sampler2D tex, in vec2 uv, in vec2 res) {\n    return textureLod(tex, (floor(uv*res)+.5)/res, 0.0).xxxx;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy * 2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n    float theta = iTime / 12.;\n    vec2 trig = vec2(sin(theta), cos(theta));\n    uv *= mat2(trig.y, -trig.x, trig.x, trig.y) / 8.;\n    \n    #if RENDER_MODE == 0\n    fragColor = textureBlocky(iChannel0, uv, iChannelResolution[0].xy);\n    #elif RENDER_MODE == 1\n    fragColor = texture(iChannel0, uv);\n    #elif RENDER_MODE == 2\n    fragColor = textureUgly(iChannel0, uv, iChannelResolution[0].xy);\n    #endif\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    }
                ],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}