{
    "Shader": {
        "info": {
            "date": "1543254978",
            "description": "TrueType glyph outline rendering. The glyph  function renders the outline of a lower case g extracted using the freetype library (www.freetype.org) from the Computer Modern Roman Serif font.  ",
            "flags": 0,
            "hasliked": 0,
            "id": "4tGBRV",
            "likes": 70,
            "name": "TrueType Glyph Outline",
            "published": 3,
            "tags": [
                "bezier",
                "glyph",
                "truetype",
                "ttf"
            ],
            "usePreview": 1,
            "username": "glk7",
            "viewed": 2528
        },
        "renderpass": [
            {
                "code": "// Created by genis sole 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\nfloat segment(vec2 uv, float e, vec2 a, vec2 b)\n{         \n    b -= a;\n    uv -= a;\n    return smoothstep(0.0, e, \n                      length( uv - b * clamp(dot(b, uv) / dot(b, b), 0.0, 1.0)));\n}\n\nfloat segment_line(vec2 uv, float e, vec2 a, vec2 b) \n{\n    b -= a;\n    uv -= a;\n    vec2 d = normalize(b);\n    \n    float sd1 = smoothstep(e*0.1, 2.0*e, abs(dot(vec2(-d.y, d.x), uv)));\n    float sd2 = smoothstep(e*0.1, e, abs(dot(vec2(-d.y, d.x), uv)));\n    float t = min(step(0.0, dot(d, uv)), step(0.0, dot(d, b - uv)));\n    \n    float fo = clamp(pow(length(uv - b*0.5)/(length(b)*4.0), 4.0), 0.0, 1.0);\n    \n \treturn mix(mix(0.8 + 0.2*sd2,1.0, fo) , sd1, t); \n}\n\nfloat point(vec2 uv, float e, vec2 p) \n{\n\treturn 1.0 - ((1.0 - smoothstep(1.5*e, 3.0*e, length(uv - p))) * 0.8); \n}\n\nfloat cpoint(vec2 uv, float e, vec2 p)\n{\n    const float s = 1.5;\n\tfloat d = segment(uv, 1.5*e, p + e*vec2(s), p - e*vec2(s)) *\n              segment(uv, 1.5*e, p + e*vec2(s, -s), p - e*vec2(s, -s));\n    return 1.0 - (1.0 - d) * 0.7;\n}\n\nfloat bezier(vec2 uv, float e, vec2 b0, vec2 b1, vec2 b2)\n{   \n    // Nehab and Hoppe quadratic bezier distance aproximation.\n    // http://hhoppe.com/ravg.pdf\n    b0 -= uv;\n    b1 -= uv;\n    b2 -= uv;\n    \n    float a = determinant(mat2(b0, b2));\n    float b = 2.0 * determinant(mat2(b1, b0));\n    float d = 2.0 * determinant(mat2(b2, b1));\n    \n    float f = b*d - a*a;\n    vec2 d21 = b2 - b1;\n    vec2 d10 = b1 - b0;\n    vec2 d20 = b2 - b0;  \n    \n    vec2 gf = 2.0 * (b*d21 + d*d10 + a*d20);  \n    gf = vec2(gf.y, -gf.x);\n    \n    vec2 pp = -f*gf / dot(gf, gf);\n    vec2 d0p = b0 - pp;  \n    float ap = determinant(mat2(d0p, d20));\n    float bp = 2.0 * determinant(mat2(d10, d0p)); \n    float t = clamp((ap + bp) / (2.0*a + b + d), 0.0, 1.0);\n    \n    vec2 dist = vec2(length(mix(mix(b0, b1, t), mix(b1, b2, t), t)), length(pp));\n\n    float fo = clamp(0.0, 1.0, pow(length(b1)/(length(d20)*4.0), 4.0));\n    \n    return min(smoothstep(e*0.1, 2.0*e, dist.x), \n               \t\t\t  mix(0.8 + 0.2*smoothstep(e*0.1, e, dist.y), 1.0, fo));\n}\n\nfloat move_to(inout vec2 p, vec2 to, vec2 uv, float e)\n{\n\tp = to;\n    return point(uv, e, to);\n}\n\nfloat line_to(inout vec2 p, vec2 to, vec2 uv, float e)\n{\n\tfloat d = min(segment_line(uv, e, p, to), point(uv, e, to));\n    p = to;\n    return d;\n}\n\nfloat conic_to(inout vec2 p, vec2 c, vec2 to, vec2 uv, float e)\n{\n\tfloat d = min(min(bezier(uv, e, p, c, to), cpoint(uv, e, c)), point(uv, e, to));\n    p = to;\n    return d;\n}\n\nfloat glyph(vec2 uv, float e) \n{\n    vec2 p = vec2(0.0);\n\n    float r = 1.0;\n    r = min(r, move_to(p, vec2(57, -162), uv, e) );\n    r = min(r, conic_to(p, vec2(57, -96), vec2(107, -39), uv, e) );\n    r = min(r, conic_to(p, vec2(158, 18), vec2(246, 43), uv, e) );\n    r = min(r, conic_to(p, vec2(156, 100), vec2(156, 225), uv, e) );\n    r = min(r, conic_to(p, vec2(156, 321), vec2(219, 395), uv, e) );\n    r = min(r, conic_to(p, vec2(123, 475), vec2(123, 606), uv, e) );\n    r = min(r, conic_to(p, vec2(123, 727), vec2(219, 816), uv, e) );\n    r = min(r, conic_to(p, vec2(315, 905), vec2(455, 905), uv, e) );\n    r = min(r, conic_to(p, vec2(578, 905), vec2(672, 831), uv, e) );\n    r = min(r, conic_to(p, vec2(770, 927), vec2(889, 928), uv, e) );\n    r = min(r, conic_to(p, vec2(942, 928), vec2(967, 895), uv, e) );\n    r = min(r, conic_to(p, vec2(993, 862), vec2(993, 827), uv, e) );\n    r = min(r, conic_to(p, vec2(993, 796), vec2(973, 781), uv, e) );\n    r = min(r, conic_to(p, vec2(954, 766), vec2(934, 766), uv, e) );\n    r = min(r, conic_to(p, vec2(909, 766), vec2(891, 782), uv, e) );\n    r = min(r, conic_to(p, vec2(874, 799), vec2(874, 825), uv, e) );\n    r = min(r, conic_to(p, vec2(874, 868), vec2(907, 881), uv, e) );\n    r = min(r, conic_to(p, vec2(901, 883), vec2(887, 883), uv, e) );\n    r = min(r, conic_to(p, vec2(787, 883), vec2(702, 803), uv, e) );\n    r = min(r, conic_to(p, vec2(786, 725), vec2(786, 604), uv, e) );\n    r = min(r, conic_to(p, vec2(786, 483), vec2(690, 394), uv, e) );\n    r = min(r, conic_to(p, vec2(594, 305), vec2(455, 305), uv, e) );\n    r = min(r, conic_to(p, vec2(340, 305), vec2(252, 369), uv, e) );\n    r = min(r, conic_to(p, vec2(217, 328), vec2(217, 272), uv, e) );\n    r = min(r, conic_to(p, vec2(217, 221), vec2(248, 181), uv, e) );\n    r = min(r, conic_to(p, vec2(279, 141), vec2(326, 135), uv, e) );\n    r = min(r, line_to(p, /*vec2(340, 133),*/ vec2(479, 133), uv, e) );\n    r = min(r, line_to(p, /*vec2(561, 133),*/ vec2(606, 131), uv, e) );\n    r = min(r, conic_to(p, vec2(651, 129), vec2(715, 115), uv, e) );\n    r = min(r, conic_to(p, vec2(780, 102), vec2(831, 76), uv, e) );\n    r = min(r, conic_to(p, vec2(964, 2), vec2(965, -158), uv, e) );\n    r = min(r, conic_to(p, vec2(965, -275), vec2(830, -348), uv, e) );\n    r = min(r, conic_to(p, vec2(696, -422), vec2(510, -422), uv, e) );\n    r = min(r, conic_to(p, vec2(322, -422), vec2(189, -347), uv, e) );\n    r = min(r, conic_to(p, vec2(57, -273), vec2(57, -162), uv, e) );\n    r = min(r, move_to(p, vec2(164, -162), uv, e) );\n    r = min(r, conic_to(p, vec2(164, -246), vec2(263, -310), uv, e) );\n    r = min(r, conic_to(p, vec2(362, -375), vec2(512, -375), uv, e) );\n    r = min(r, conic_to(p, vec2(659, -375), vec2(758, -311), uv, e) );\n    r = min(r, conic_to(p, vec2(858, -248), vec2(858, -162), uv, e) );\n    r = min(r, conic_to(p, vec2(858, -101), vec2(823, -62), uv, e) );\n    r = min(r, conic_to(p, vec2(788, -23), vec2(716, -7), uv, e) );\n    r = min(r, conic_to(p, vec2(645, 8), vec2(595, 11), uv, e) );\n    r = min(r, line_to(p, /*vec2(545, 14),*/ vec2(453, 14), uv, e) );\n    r = min(r, line_to(p, vec2(332, 14), uv, e) );\n    r = min(r, conic_to(p, vec2(262, 10), vec2(213, -41), uv, e) );\n    r = min(r, conic_to(p, vec2(164, -92), vec2(164, -162), uv, e) );\n    r = min(r, move_to(p, vec2(276, 604), uv, e) );\n    r = min(r, conic_to(p, vec2(276, 352), vec2(455, 352), uv, e) );\n    r = min(r, conic_to(p, vec2(545, 352), vec2(600, 434), uv, e) );\n    r = min(r, conic_to(p, vec2(633, 489), vec2(633, 606), uv, e) );\n    r = min(r, conic_to(p, vec2(633, 858), vec2(455, 858), uv, e) );\n    r = min(r, conic_to(p, vec2(365, 858), vec2(309, 776), uv, e) );\n    r = min(r, conic_to(p, vec2(276, 721), vec2(276, 604), uv, e) );\n    \n\treturn r;    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tfloat s = 50.*64.;\n    float e = s/iResolution.x;\n    vec2 uv = fragCoord * e;\n\tuv -= vec2(0.34, 0.20)*s;\n    fragColor = vec4(vec3(pow(glyph(uv, e)*0.8, 0.4545)),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}