{
    "Shader": {
        "info": {
            "date": "1573022835",
            "description": "Extruded interpolated fonts. Mouseable.",
            "flags": 0,
            "hasliked": 0,
            "id": "3stXDX",
            "likes": 18,
            "name": "Font Forest",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "font"
            ],
            "usePreview": 0,
            "username": "ShnitzelKiller",
            "viewed": 797
        },
        "renderpass": [
            {
                "code": "// Inspired by FabriceNeyret2's https://www.shadertoy.com/view/tdcXW2\n// remade in \"real\" 3D with raymarching\n\n#define FDIST 0.5\n#define MAXSTEP 100\n#define TOL 0.001\n#define MAXDIST 20.\n#define INTERP_SCALE -3.\n#define REPEAT_SCALE 1.5\n#define MOUSE_SCALE 0.014\n#define TEXSCALE vec2(1.5, 1.)\n#define TEX_BIAS 0.49803921568\n\n//comment this out if you have weird artifacts where segments don't line up\n#define SHUFFLE\n\nfloat rand(vec2 uv) {\n    return fract(814.*sin(uv.x*15829.+uv.y*874.));\n}\n\nfloat noise1D(float t) {\n    return fract(14950.5*sin(1905.1*t));\n}\n\nvec2 id2coord(in float id) {\n    #ifdef SHUFFLE\n    id = floor(noise1D(id) * 256.);\n    #endif\n    return vec2(mod(id, 16.), floor(id/16.))/16.;\n}\n\nvoid transform(inout vec3 ro) {\n    vec2 id = floor((ro.xy+REPEAT_SCALE*0.5)/REPEAT_SCALE);\n    float offset = rand(id)*256.;\n    ro = vec3(mod(ro.xy+REPEAT_SCALE*0.5, REPEAT_SCALE)-REPEAT_SCALE*0.5, ro.z*INTERP_SCALE + offset);\n}\n\n/**\nCompute analytic gradient\n*/\nvec3 grad(in vec3 ro) {\n    transform(ro);\n    float t = ro.z;\n    float id = floor(t);\n    vec2 offset = clamp(ro.xy+0.5, 0., 1.)/16.;\n    vec2 coords1 = id2coord(id) + offset;\n    vec2 coords2 = id2coord(id+1.) + offset;\n    \n    vec4 tex1 = textureGrad(iChannel0,coords1,dFdx(offset),dFdy(offset));\n    vec4 tex2 = textureGrad(iChannel0,coords2,dFdx(offset),dFdy(offset));\n    \n    float dist1 = tex1.w-TEX_BIAS;\n    float dist2 = tex2.w-TEX_BIAS;\n    \n    vec2 norm1 = (tex1.yz-TEX_BIAS)*2.;\n    vec2 norm2 = (tex2.yz-TEX_BIAS)*2.;\n    \n    float tf = fract(t);\n    float alpha = smoothstep(0., 1., tf);\n    vec3 n = vec3(norm1 * (1.-alpha) + norm2 * alpha, (dist2 - dist1) * INTERP_SCALE * 6. * (tf - tf*tf));\n    n.y = -n.y;\n    return normalize(n);\n}\n\nfloat map(in vec3 ro) {\n    transform(ro);\n    float t = ro.z;\n    float id = floor(t);\n    vec2 offset = clamp(ro.xy+0.5, 0., 1.)/16.;\n    vec2 coords1 = id2coord(id) + offset;\n    vec2 coords2 = id2coord(id+1.) + offset;\n    \n    float dist1 = textureGrad(iChannel0, coords1,dFdx(offset), dFdy(offset)).w-TEX_BIAS;\n    float dist2 = textureGrad(iChannel0, coords2,dFdx(offset), dFdy(offset)).w-TEX_BIAS;\n    vec2 displacement = abs(ro.xy)-0.5;\n    float alpha = smoothstep(0., 1., fract(t));\n    return max(max(displacement.x, displacement.y), 0.5*(dist1 * (1.-alpha) + dist2*alpha));\n}\n\nvec2 raymarch(in vec3 eye, in vec3 rd) {\n    float t = 0.0;\n    int i;\n    for (i=0; i<MAXSTEP; i++) {\n        vec3 pos = eye + rd*t;\n        float dist = map(pos);\n        t += dist;\n        if (abs(dist) < TOL || t > MAXDIST) break;\n    }\n    return vec2(t, i);\n}\n\nbool shadowmarch(in vec3 eye, in vec3 rd, float lightdist) {\n    float t = 0.0;\n    float minstep = 0.01;\n    for (int i=0; i<50; i++) {\n        vec3 pos = eye + rd * t;\n        float dist = map(pos);\n        if (dist < 0.) return true;\n        else if (t > lightdist) return false;\n        float s = max(dist, minstep);\n        minstep += 0.001;\n        t += s;\n        \n    }\n    return false;\n}\n\nvec3 albedo(in vec3 n, in vec3 ro) {\n    vec2 texcoord1 = ro.yz * TEXSCALE;\n    vec2 texcoord2 = ro.xz * TEXSCALE;\n    vec3 tex1 = texture(iChannel1, texcoord1.yx).xyz;\n    vec3 tex2 = texture(iChannel1, texcoord2.yx).xyz;\n    return (abs(n.x) * tex1 + abs(n.y) * tex2 - 0.5)*0.7 + 0.5;\n}\n\nfloat shade(in vec3 n, in vec3 ro, in vec3 lightpos, in bool shadow) {\n    vec3 l = lightpos - ro;\n    float ldist = length(l);\n    if (shadow && shadowmarch(ro + n*TOL*2., l/ldist, ldist)) {\n    \treturn 0.;\n    }\n    return max(0.,dot(l, n))/ldist*min(1., 2.5/(ldist*ldist));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.xx;\n\t\n    vec3 up = vec3(0, 0, 1);\n    vec3 eye = vec3(REPEAT_SCALE*0.6*cos(iTime*0.5 + iMouse.x*MOUSE_SCALE), REPEAT_SCALE*0.6*sin(iTime*0.5 + iMouse.x*MOUSE_SCALE), iTime*2.);\n    vec3 lightpos = vec3(REPEAT_SCALE*0.2, REPEAT_SCALE*0.5, iTime*2.+1.5);\n    vec3 lightpos2 = vec3(-REPEAT_SCALE*0.2, -REPEAT_SCALE*0.5, iTime*2.);\n    vec3 w = normalize(vec3(-eye.xy, iMouse.w > 1. ? (iMouse.y-iResolution.y*.5) * MOUSE_SCALE * REPEAT_SCALE * 0.66 : 2.*cos(iTime*0.13)));\n    vec3 u = normalize(cross(w, up));\n    vec3 v = cross(u, w);\n    vec3 rd = normalize(w*FDIST + u*uv.x + v*uv.y);\n\tvec2 t = raymarch(eye, rd);\n    vec3 ro = t.x * rd + eye;\n    vec3 n = grad(ro);\n    float fac1 = shade(n, ro, lightpos, true);\n    float fac2 = shade(n, ro, lightpos2, false);\n    vec3 a = albedo(n, ro);\n    float fogfac = min(0.1,t.x*0.005);\n    vec3 finalcol = a*fac1*vec3(0.7, 0.8, 1.) + a*fac2*vec3(0.5, 0.25, 0.25) + vec3(0., 0., 0.05)*n.z/t.x + fogfac*mix(vec3(2, 0.4, 0.0), vec3(2, 3, 5), rd.z*.5+.5);\n    fragColor = vec4(pow(finalcol, vec3(0.6)),1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}