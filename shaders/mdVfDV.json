{
    "Shader": {
        "info": {
            "date": "1698686064",
            "description": "CC0: The aurelia logo\nWatched an Aurelia presentation at Swetugg. Saw the logo and thought I\ncould probably shaderify it: https://aurelia.io/\n",
            "flags": 0,
            "hasliked": 0,
            "id": "mdVfDV",
            "likes": 13,
            "name": "The aurelia logo",
            "published": 3,
            "tags": [
                "2d",
                "logo"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 290
        },
        "renderpass": [
            {
                "code": "// CC0: The aurelia logo\n// Watched an Aurelia presentation at Swetugg. Saw the logo and thought I\n// could probably shaderify it: https://aurelia.io/\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nvec4 daurelia(vec2 p, float r) {\n  vec2 p0 = p;\n  vec2 p1 = p;\n  p1.x += -0.033;\n  p1.y += -0.004;\n  vec2 p2 = p;\n  p2.x += 0.48;\n  p2.y += -0.06;\n  vec2 p3 = p;\n  p3.x += -0.495;\n  p3.y += -0.06;\n  vec2 p4 = p;\n  p4.x += 0.39;\n  p4.y += -0.86;\n  vec2 p5 = p;\n  p5.x += 0.78;\n  p5.y += 0.4;\n  vec2 p6 = p;\n  p6.x += 0.035;\n\n  float d0 = box(p0, vec2(1.0, 0.285)-r);\n  float d1 = box(p1, vec2(0.225, 1.01)-r);\n  float d2 = box(p2, vec2(0.17, 0.63)-r);\n  float d3 = box(p3, vec2(0.11, 0.63)-r);\n  float d4 = box(p4, vec2(0.06, 0.06)-r);\n  float d5 = box(p5, vec2(0.06, 0.07)-r);\n  float d6 = box(p6, vec2(0.55, 0.45)-r);\n\n  d0 -= r;\n  d1 -= r;\n\n  float d7 = -(d0 - 0.06);\n\n  d1 = pmax(d1, d7, r);\n\n  float d = d2;\n  d = min(d, d3);\n  d = min(d, d4);\n  d = min(d, d5);\n  d -= r;\n  d = pmax(d, d7,r);\n  return vec4(d0, d1, d, d6);\n}\n\n\nfloat dot2(vec2 p) {\n  return dot(p, p);\n}\n\nvec3 aurelia(vec3 col, float aa, vec2 p) {\n  const vec3 baseCol00 = HSV2RGB(vec3(341.0/360.0, 0.96, 0.85));\n  const vec3 baseCol01 = HSV2RGB(vec3(260.0/360.0, 0.75, 0.36));\n  const vec3 baseCol10 = HSV2RGB(vec3(285.0/360.0, 0.68, 0.45));\n  const vec3 baseCol11 = HSV2RGB(vec3(268.0/360.0, 0.72, 0.40));\n\n  const mat2 arot = ROT(radians(34.0));\n  const vec2 soff = vec2(0.01, 0.01)*(arot);\n\n  p *= arot;\n  vec4 ad = daurelia(p, 0.0);\n  vec4 sad = daurelia(p+soff, 0.025);\n  float m0 = clamp(0.35*dot2(p-vec2(1.0, 0.0)), 0.0, 1.0);\n  float m1 = clamp(0.35*dot2(p-vec2(0.0, 1.0)), 0.0, 1.0);\n  float shd = mix(0.75, 1.0, smoothstep(aa, -aa, -ad.w));\n  vec3 bcol0 = mix(baseCol00, baseCol01, m0);\n  vec3 bcol1 = mix(baseCol00, baseCol01, m1)*shd;\n  vec3 bcol2 = mix(baseCol10, baseCol11, m1)*shd;\n  float sd = min(min(sad.x, sad.y), sad.z);\n  float od = min(min(ad.x, ad.y), ad.z);\n  od = abs(od)-aa;\n  col *= mix(1.0, 0.4, exp(-60.0*max(sd+0.01, 0.0)));\n  col = mix(col, mix(bcol0, col, 0.0), smoothstep(aa, -aa, ad.x));\n  col = mix(col, mix(bcol1, col, 0.0), smoothstep(aa, -aa, ad.y));\n  col = mix(col, mix(bcol2, col, 0.0), smoothstep(aa, -aa, ad.z));\n  col = mix(col, vec3(1.0), smoothstep(aa, -aa, od));\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float aa = sqrt(2.0)/RESOLUTION.y;\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = vec3(1.0);\n  \n  vec2 ap = p;\n  float iz = mix(0.25, 2.0, smoothstep(-0.5, 0.5, -cos(0.5*TIME-0.075*(p.x))));\n  ap /= iz;\n  aa /= iz;\n  ap += sin(vec2(1.0, sqrt(2.0))*0.125*TIME)*4.0;\n\n  ap *= 0.5;\n  ap -= round(ap);\n  ap *= 2.0;\n  \n  col = aurelia(col, aa, ap);  \n  col = sqrt(col);\n  \n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}