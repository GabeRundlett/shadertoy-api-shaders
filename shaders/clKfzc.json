{
    "Shader": {
        "info": {
            "date": "1702363506",
            "description": "ordinary study.\ni mean normal study!",
            "flags": 0,
            "hasliked": 0,
            "id": "clKfzc",
            "likes": 22,
            "name": "ordinary study",
            "published": 3,
            "tags": [
                "2d",
                "sdf",
                "normals",
                "normal"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 282
        },
        "renderpass": [
            {
                "code": "const float gBoxSize       = 1.0;\nconst float gMarchEpsilon  = 0.4;\nconst float gNormalEpsilon = gMarchEpsilon * 0.5;\nconst float gUnderStepFac  = 1.0;\n\n#define VISUALIZE_NORMAL_DIRECTION 1\n\n\nfloat gZoom  = 0.6;\nfloat gLW    = 2.0; // line width.           scaled at runtime.\nfloat gSSEps = 4.0; // screen-space epsilon. scaled at runtime.\nvec2  gRd;          // ray direction\nfloat gT;\n\nfloat map(in vec2 p) {\n\n    float boxRad  = gBoxSize;\n    \n    float box     = sdBox   (p               , v1 * boxRad);\n    float circle  = sdCircle(p, vSE * boxRad * 0.5, 0.75 * boxRad); \n    \n    float d       = 1e9;\n    d = min(d, box);\n    d = max(d, -circle);\n  \n    if (false) {\n        d = length(p) - boxRad * 8.0;\n        d = max(d,  p.x - boxRad);\n        d = max(d, -p.x - boxRad);\n        d = max(d, -p.y - boxRad);\n        d = max(d,  p.y - boxRad);\n    }\n\n    \n    return d;\n}\n\nvoid drawCircle(inout vec3 c, in vec4 clr, in float a, in vec2 p, in vec2 cen, in float rad, bool dashed) {\n    vec2 v = (p - cen);\n    float d = length(v) - rad;\n    \n    float modulate = 1.0;\n    if (dashed) {\n        modulate = fract(atan(v.y, v.x) / 3.14159 * 10.0) * 2.0 - 1.0;\n        modulate = smoothstep(0.6, 0.5, abs(modulate));\n        \n    }\n    \n    \n    c = mix(c, clr.rgb, a * clr.a * smoothstep(gSSEps/2.0, -gSSEps/2.0, d + gLW * 1.5));\n    a *= modulate;\n    c = mix(c, clr.rgb, a *         smoothstep(gSSEps    , 0.0        , abs(d) - gLW));    \n}\n\nvoid drawCircle(inout vec3 c, in vec4 clr, in float a, in vec2 p, in vec2 cen, in float rad) {\n    drawCircle(\n        c, clr, a, p, cen, rad, false);\n}\n\n\nvoid drawSegment(inout vec3 c, in vec4 clr, in float a, in vec2 p, in vec2 p1, in vec2 p2) {\n    float d = sdSegment(p, p1, p2);\n    \n    c = mix(c, clr.rgb, a * smoothstep(gSSEps, 0.0, abs(d) - gLW));    \n}\n\nvoid drawRay(inout vec3 c, in vec4 clr, in float a, in vec2 p, in vec2 ro, in vec2 rd) {\n    float d = 1e9;\n    \n    vec2 rn = vec2(rd.y, -rd.x);\n    float width = gLW * 4.0;\n    \n    vec2 p1 = ro;\n    vec2 p2 = ro + rd;\n    \n    d = min(d, sdSegment(p, p1, p2));\n    d = min(d, sdSegment(p, p2, p2 + 0.2 * ( rn - rd)));\n    d = min(d, sdSegment(p, p2, p2 + 0.2 * (-rn - rd)));\n    d = min(d, sdCircle (p, p1, width));\n    \n    \n    d -= width;\n    c = mix(c, clr.rgb, a * clr.a * smoothstep(gSSEps/2.0, -gSSEps/2.0, d + gLW * 1.5));\n    c = mix(c, clr.rgb, a *         smoothstep(gSSEps    , 0.0        , abs(d) - gLW));\n}\n\nvoid drawMarch(inout vec3 col, in vec2 q, in vec2 ro, in vec2 rd) {\n    \n    uint maxSteps = 100u;\n    \n    vec2 pPrev = ro;\n    \n    const vec4 clr1 = vec4(0.0, 0.8, 0.2, 0.0);\n    const vec4 clr2 = vec4(0.5, 0.8, 0.2, 0.1);\n    \n    float t = 0.0;\n    for (uint n = 0u; n < maxSteps; ++n) {\n        vec2  p = ro + rd * t;\n        float d = map(p);\n        drawCircle (col, clr1, 0.2, q, p, d);\n        drawCircle (col, clr1, 0.6, q, p, gLW * 4.0);\n        drawSegment(col, clr1, 0.6, q, pPrev, p);\n        if (d < gMarchEpsilon) {\n            vec2 rdp = vec2(rd.y, -rd.x);\n            drawCircle (col, clr1, 0.6, q, p, d);\n            drawCircle (col, clr2, 0.6, q, p, gMarchEpsilon, true);\n            drawCircle (col, clr2, 0.6, q, p, gNormalEpsilon, true);\n            drawSegment(col, clr1, 0.6, q, p + rdp * d, p - rdp * d);\n            break;\n        }\n        t += d * gUnderStepFac;\n        if (t > gBoxSize * 6.0) {\n            break;\n        }\n        pPrev = p;\n    }\n    \n    \n}\n\n\nvec2 wrldFromScrn(in vec2 p) {\n    return (p * 2.0 - RES) / MINRES / gZoom;\n}\n\nvec1 wrldFromScrn(in vec1 p) {\n    return p / MINRES / gZoom;\n}\n\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    vec2  p = wrldFromScrn(XY);\n    vec2  m = wrldFromScrn(iMouse.xy);\n    \n    gLW     = wrldFromScrn(gLW);\n    gSSEps  = wrldFromScrn(gSSEps);\n    gT      = iTime;\n    \n    if (length(iMouse.xy) < 50.0) {\n        m.x = cos(gT * 0.13) / gZoom;\n        m.y = sin(gT * 0.13) / gZoom;\n    }\n    \n    gRd = normalize(m);\n    \n    float d = map(p);\n    \n    vec3  c    = vec3(1e9, 0.0, 1e9);\n    vec3  cIn  = vec3(0.3, 0.5, 0.8);\n    vec3  cOut = vec3(0.7, 0.4, 0.2);\n    vec4  cCrc = vec4(0.9, 1.0, 0.3, 0.3);\n    vec1  aCrc = 0.2;\n    vec1  aNrm = 0.8;\n    vec4  cRay = vec4(1.0, 0.4, 0.2, 0.6);\n    vec1  aRay = 0.8;\n    vec3  cBrd = vec3(0.0, 0.8, 1.0);\n        \n    // inside the SDF\n    c = mix(c, cIn , smoothstep( 0.0, gLW, -d));\n    \n    // outside the SDF\n    c = mix(c, cOut, smoothstep( 0.0, gLW,  d));\n    \n    // isolines\n    float isoT = gT * 0.03 / gZoom;\n    float iso = fract((d - isoT) * MINRES / 30.0 * gZoom) * 2.0 - 1.0;\n    c = mix(0.8 * c, c, smoothstep(0.5, 0.0, abs(iso)));\n    iso = fract((d - isoT) / 10. * MINRES / 30.0 * gZoom) * 2.0 - 1.0;\n    c = mix(c, 1.2 * c, smoothstep(0.5, 0.0, abs(iso + 0.5) * 10.0));\n    \n    #if VISUALIZE_NORMAL_DIRECTION\n    float dGdX     = (map(p + vX * gNormalEpsilon) - map(p - vX * gNormalEpsilon)) / 2.0;\n    float dGdY     = (map(p + vY * gNormalEpsilon) - map(p - vY * gNormalEpsilon)) / 2.0;\n    vec2  gradient = vec2(dGdX, dGdY);\n    vec2  normal   = normalize(gradient);\n    float ang      = atan(normal.y, normal.x);\n    float s        = smoothstep(-0.1, 0.1, sin(ang * 16.0));\n    c              = mix(c, c * 0.5, s);\n    #endif\n\n    // boundary of the SDF\n    c = mix(c, cBrd, smoothstep( gSSEps, 0.0,  abs(d) - gLW));\n    \n    // draw the distance at the mouse point,\n    drawCircle(c, cCrc, aCrc, p, m, abs(map(m)));\n    drawCircle(c, cCrc, aCrc, p, m, gLW);\n    \n\n    float spread = 10.0;\n    float num = 10.0;\n    vec2 rd = normalize(m);\n    for (float f = -gNormalEpsilon * spread; f <= gNormalEpsilon * spread; f += gNormalEpsilon * (spread * 2.0 / num)) {\n        vec2 ro = m - rd * gBoxSize * 5.0;\n        ro += f * vec2(rd.y, -rd.x);\n        drawMarch(c, p, ro, rd);\n    }\n        \n    \n    RGBA.rgb = c;\n    RGBA.a   = 1.0;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const vec2 vX  = vec2( 1.0,  0.0);\nconst vec2 vY  = vX.yx;\nconst vec2 v0  = vX.yy;\nconst vec2 v1  = vX.xx;\nconst vec2 vSE = vX - vY;\n\n#define RES    (iResolution.xy)\n#define MINRES (min(RES.x, RES.y))\n#define vec1   float\n\n\nfloat sdCircle( in vec2 p, in vec2 cen, in float r ) {\n    return length(p - cen) - r;\n}\n\n//-----------------------------------------------------------\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}