{
    "Shader": {
        "info": {
            "date": "1581022716",
            "description": "Hue, as all angular quantities, is not easy to interpolate and filter.\nWIP tests based on unwrapped-diffusion ( better use acceleration -cf plugin )\n- local extrema vanish (left)\n- only poles (and sources) can \"attach\" colors\n- diffusion does a good job",
            "flags": 48,
            "hasliked": 0,
            "id": "Wl3SDM",
            "likes": 7,
            "name": "filtering hue 2",
            "published": 3,
            "tags": [
                "hue",
                "interpolation",
                "phasor",
                "chrominance"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 499
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 U = u/R;\n    vec4 BG = vec4(0);\n    \n    O = hue( texture(iChannel0,U).x ); \n    \n    // hue\n    if keyToggle(32) {\n      //O = vec4( .5+ texture(iChannel0,U).x );                        // B&W\n      //O = vec4( .5+.5* sin(50.*texture(iChannel0,U).x ));            // isovals\n        O = vec4( .5+.5* sin(300.*U.x+6.283*texture(iChannel0,U).x )); // phasor\n     // O *=      .5+.5* sin(300.*U.x+6.283*texture(iChannel0,U).x );  // phasor (color)\n        BG = vec4(0,1,0,1);\n    }\n    \n    if (int(u) == int(R)/2  ) O = BG;\n    if (int(u) == int(R*.83)) O = BG; \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//#define T(d)        texture(iChannel0,U+d/R)\n  #define T(d) fract( texture(iChannel0,U+d/R) - T + .5 )-.5 + T\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U /= R;\n    \n    //O = texture(iChannel0,U,1.);    // linear diffusion\n    \n#if 0\n    vec2 d = vec2(1,0);               // --- unwrapped diffusion (cross pattern)\n    vec4 T  = texture(iChannel0,U),   // first unwrap the neighborhood\n         T1 = T( d),                  // to never filter cross-wrap.\n         T2 = T(-d),\n         T3 = T( d.yx),\n         T4 = T(-d.yx);\n    O = ( T1+T2+T3+T4 ) / 4.;\n#else\n    O-=O; int N = 5;                  // --- unwrapped diffusion (NxN filter)\n    vec4 T  = texture(iChannel0,U);   // first unwrap the neighborhood\n    for (int k=0; k < N*N; k++)       // to never filter cross-wrap.\n        O += T(vec2( k%N -N/2, k/N -N/2 ));\n  //O = fract( O - T + .5 )-.5 + T;\n    O /= float(N*N);\n  //O = fract( O - T + .5 )-.5 + T;\n#endif\n    \n  //O = .5 + sign(O-.5)*sqrt(2.*abs(O-.5));\n  //O = .5*sin(6.263*O);\n    \n    if (iChannelResolution[2].x < 10.) { O-=O; return; } // wait texture\n    if (iFrame < 1 || texelFetch(iChannel0,ivec2(0),0)==vec4(0) ) { // --- init state\n        float  k = 1.;\n        k = U.x<.5 ? .5+8.*(.5-U.x) : U.x-.5<.33 ? 1. : 3.;\n        \n      //O.x = 3.*rgb2hls(texture(iChannel1,U)).x; return; // hue from true image\n      //T = texture(iChannel2,U,0.); O.x = T.a > .9 ? T.x : .3*T.x; return; // isolated random dots      \n      //O.x = abs(U.y-.5)>.25 ? U.x : 2.*U.x; return; // 1 vs 2 rainbow -> bipole\n      //U -= .5; O.x = 20.*length(U); return;         // concentric, no pole\n      //U -= .5; O.x = 4.5*atan(U.x,-U.y); return;    // radial, 1 pole + bad cycling\n\n        vec2 V = texture(iChannel2,U,5.).xy - .5;     // dir field from rand texture\n      //k = 8.*U.x;\n        if (U.x<.5) { O.x = k*8.*V.x; return; }       // left: no pole\n      //if (U.x<.5) { O.x = 9.*U.x;  if (U.y>.5) O.x += .5;return; }  // left: gradiant + PI-jump\n      //V *= sin(20.*U.x);                            // strip modulation\n        \n        O.x = atan(V.y,V.x);                          // dir = norm rand texture\n      //O.x = atan(dFdy(V.x),dFdx(V.x));              // gradients of rand texture.x\n      //O.x = atan(dFdx(V.x),-dFdy(V.x));             // isolines of rand texture.x\n        \n        O.x *= k/6.2816;                              // hue on [0,1]\n        return;\n    }\n    \n#if 0 // sources\n    if (length(U-.5) < .05 ) O.x = 1.;\n    if (length(U-vec2(.8,.3)) < .05 ) O.x = 1.;\n    if (length(U-.8) < .05 ) O.x = .5;\n    if (length(U-.3) < .05 ) O.x = .7;\n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define R iResolution.xy\n\n#define keyToggle(a)  ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\nvec4 rgb2hls(vec4 C) {\n    float r =C.r, g=C.g, b=C.b,\n        M = max(r,max(g,b)),\n        m = min(r,min(g,b)),\n        l = (M + m) / 2.,\n        d =  M - m;\n\n    if (M == m) return vec4(0,l,0,0);\n    \n    C.y = l;\n    C.z = .5* d / min(l, 1.-l);\n    C.x =  r > max(g,b) ? (g - b) / d + (g < b ? 6. : 0.)\n         : g > b        ? (b - r) / d + 2.\n         :                (r - g) / d + 4.;\n    C.x /= 6.;\n    return C;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}