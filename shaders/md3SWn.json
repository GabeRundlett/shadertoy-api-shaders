{
    "Shader": {
        "info": {
            "date": "1679614238",
            "description": "Basket weaving with truchet tiles.",
            "flags": 0,
            "hasliked": 0,
            "id": "md3SWn",
            "likes": 8,
            "name": "Screen Weaver",
            "published": 3,
            "tags": [
                "2d",
                "truchet"
            ],
            "usePreview": 0,
            "username": "QuantumSuper",
            "viewed": 296
        },
        "renderpass": [
            {
                "code": "// ScreenWeaver 0.4.230325 by QuantumSuper\n// basket weaving with truchet tiles\n//\n// - Thanks @FabriceNeyret2 for finishing off some superfluous chars -\n\n#define S(a) smoothstep(1.,.0,a/min(fwidth(a),.1))\n\nfloat hash21(vec2 p){ //pseudorandom generator, see The Art of Code on youtu.be/rvDo9LvfoVE\n    p = fract(p*vec2(13.81, 741.76));\n    p += dot(p, p+42.23);\n    return fract(p.x*p.y);\n}\nvec2 hash22(vec2 p){\n    return vec2(hash21(p.xy),hash21(p.yx));\n}\n\nvec2 flipTile(vec2 p, vec2 o){ //flipping tiles along x||y \n    return p*sign(hash22(o)-.5);\n}\n\nfloat getTile(vec2 p){ //define single tile\n    float a = 0.;\n    vec2 v = p,\n        w = vec2(-p.y,p.x);\n        \n    // Draw lines\n    if (0==1) // Thanks to @FabriceNeyret2Â´s anti-aliased loop de-weaving (did not get it to work quite yet)\n  \n        for (int j=0; j<2; j++, v=-p, w=-w )\n            for (float i=0.;i<1.;i+=.5 )\n                v = (  S( abs(v + .1-i  ) )\n                     + S( abs(v + .4-i  ) )\n                    )\n                   *( 1.- S(w + .1-i ) ),\n                a += v.x + v.y;\n    \n    else // original approach\n    \n        for (float i=0.;i<1.;i+=.5){\n            for (float j=-1.;j<3.;j+=2.){\n                for (float k=.1;k<.7;k+=.3){\n                    for (int l=0;l<2;l++){\n                        a += smoothstep(.01,.0, abs(j*p[l]+k-i))*smoothstep(.0,.01,float(2*l-1)*j*p[1-l]+.1-i+.01);\n                    }\n                }\n            }\n        }\n    \n    // Draw squares\n    p=fract(2.*p+.2); \n    a += (p.x<.4 && p.y <.4) ? .5  : .0; \n    \n    return a;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n \n    // Define view\n    vec2 uv = (2.*fragCoord-iResolution.xy) / max(iResolution.x, iResolution.y); //long edge -1 to 1\n\tvec3 col = vec3(.5/length(uv)); //vignette\n    uv *= 5.*sin(1.5*length(uv)-.2*iTime); //warp space\n    \n    // Draw tiles\n    vec2 uvId = floor(uv);\n    uv = fract(uv)-.5; \n    uv = flipTile(uv, uvId+ceil(iTime/.2)); //\"randomize\" pattern\n\tcol = pow(col*getTile(uv), vec3(.4545)); //gamma correction\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}