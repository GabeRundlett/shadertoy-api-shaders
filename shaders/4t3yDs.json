{
    "Shader": {
        "info": {
            "date": "1534567338",
            "description": "WIP",
            "flags": 0,
            "hasliked": 0,
            "id": "4t3yDs",
            "likes": 2,
            "name": "Another Petri Dish",
            "published": 3,
            "tags": [
                "voronoi"
            ],
            "usePreview": 0,
            "username": "momoro",
            "viewed": 572
        },
        "renderpass": [
            {
                "code": "mat2 rotate(float angle) {\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle)\n    );\n}\n\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                    vec2(12.9898, 78.233)))*\n        \t\t\t\t 43758.5453123);\n}\n\nfloat random1 (float f) {\n    return random(vec2(f, -0.128));\n}\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk:\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\nfloat noise(float s) {\t\n    float i = floor(s);\n    float f = fract(s);\n    float n = mix(random(vec2(i, 0.)), \n                  random(vec2(i+1., 0.)), \n                  smoothstep(0.0, 1., f)); \n   \n    return n;\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat map(float value, float inMin, float inMax, float outMin, float outMax) {\n\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n\n} \n\n\n\nvec2 map(vec2 value, vec2 inMin, vec2 inMax, vec2 outMin, vec2 outMax) {\n\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n\n}\n\n\n\nvec3 map(vec3 value, vec3 inMin, vec3 inMax, vec3 outMin, vec3 outMax) {\n\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n\n}\n\n\n\nvec4 map(vec4 value, vec4 inMin, vec4 inMax, vec4 outMin, vec4 outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 color;\n\n    for(float i=0.; i<2.; i++) {\n        vec2 st = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n        st = rotate(i * 1.128) * st;\n        \n\n        st *=6.440 * i/0.376;\n        st += vec2(-0.170,-0.240);\n\n        // Tile\n        vec2 i_st = floor(st);\n        vec2 f_st = fract(st);\n\n        float m_dist = 1.; // min distance\n\n        for(int j=-2; j<=2; j++) {\n            for(int i=-2; i<=2; i++) {\n\n                // Neighbor place in the grid\n                vec2 neighbor = vec2(float(i), float(j));\n\n                // Random position from current + neighbor place in the grid\n                vec2 offset = random2(i_st + neighbor);\n\n                // Animate the offset\n                offset = 0.5 + 0.5 * sin(iTime + 6.2831 * offset );\n\n                // Position of the cell\n                vec2 pos = neighbor + offset - f_st;\n\n                // Cell distance\n                float dist = length(pos);\n\n                // Metaball\n                m_dist = smin(m_dist, dist, 1.344);            \n            }\n        }\n\n\n        float f = m_dist;\n        f *= 5.;\n        float steps = 5.0;\n        f = ceil(f *steps) / steps;\n\n        float h = map(f, 0., 0.7, 0.628, 0.764);\n        h += (st.x + 0.376)/10. * (st.y/10. - 1.280) * 1.264;\n\n        float s = map(f, 0., 1., 0.852, 0.752);\n        float v = map(f, 0., 0.696, 0.280, 0.824);\n\n        color += hsv2rgb(vec3(h, s, v));\n        //color *= \tfwidth(f) * 3.640;\n\n        //color *= 2.896;\n\n        vec2 uv= st;\n        f = 0.;\n        uv.x *= noise(iTime - 20.);\n        uv.y *= noise(iTime);\n        f = 1.0 - length(uv);\n\n        vec2 uv2 = st;\n        uv2 += 0.308;\n        float q = map(1.0 - length(uv2), -0.496, 1., -0.552, 1.072);\n        q += 3.744;\n\n\n      //  color *= abs(vec3(f)) * 0.356 ;\n        color *= q * .2;\n    }\n    \n    fragColor = vec4(color, 1.0);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}