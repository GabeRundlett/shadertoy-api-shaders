{
    "Shader": {
        "info": {
            "date": "1482962942",
            "description": "2D zoom",
            "flags": 0,
            "hasliked": 0,
            "id": "llKXRh",
            "likes": 18,
            "name": "Maskit slice-circle inversion ",
            "published": 3,
            "tags": [
                "kleinian"
            ],
            "usePreview": 0,
            "username": "JosLeys",
            "viewed": 1079
        },
        "renderpass": [
            {
                "code": "//by Jos Leys\nvec3  background1Color=vec3(1.0,1.0,1.0);\nvec3  color3=vec3(0.6,0.0,0.2);\n\nfloat KleinR =0.;\nfloat KleinI =0.;\n\nfloat box_size_x=1.;\n\n//circle inversion\nbool SI=true;\nvec2 InvCenter=vec2(0.,-1.);\nfloat rad=1.;\n\n\nfloat wrap(float x, float a, float s){\n\tx -= s; \n\treturn (x-a*floor(x/a)) + s;\n}\n\n\nvoid TransA(inout vec2 z, float a, float b){\n\tfloat iR = 1. / dot(z,z);\n\tz *= -iR;\n\tz.x = -b - z.x; z.y = a + z.y; \n\t\n}\n\nfloat  JosKleinian(vec2 z)\n{\n\tvec2 lz=z+vec2(1.), llz=z+vec2(-1.);\n    float flag=0.;\n        KleinR = 1.958591;\n        KleinI = 0.011278;\n       float d=0.; float d2=0.;\n         z=z-InvCenter;\n\t\td=length(z);\n\t\td2=d*d;\n\t\tz=(rad*rad/d2)*z+InvCenter; \n\n\tfloat a = KleinR;\n    float b = KleinI;\n\tfloat f = sign(b)*1. ;     \n\tfor (int i = 0; i < 100 ; i++) \n\t{\n                z.x=z.x+f*b/a*z.y;\n\t\tz.x = wrap(z.x, 2. * box_size_x, - box_size_x);\n\t\tz.x=z.x-f*b/a*z.y;\n                       \n\t\t//If above the separation line, rotate by 180° about (-b/2, a/2)\n        if  (z.y >= a * 0.5 + f *(2.*a-1.95)/4. * sign(z.x + b * 0.5)* (1. - exp(-(7.2-(1.95-a)*15.)* abs(z.x + b * 0.5))))\t\n        {z = vec2(-b, a) - z;}\n        \n\t\t//Apply transformation a\n\t\tTransA(z, a, b);\n\t\t\n        //\n\t\t//If the iterated points enters a 2-cycle , bail out.\n        if(dot(z-llz,z-llz) < 1e-5) {break;}\n        //if the iterated point gets outside z.y=0 and z.y=a\n        if(z.y<0. || z.y>a){flag=1.; break;}\n        //Store prévious iterates\n\t\tllz=lz; lz=z;\n\t}\n\n\treturn flag;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float zoom=1.-0.9*abs(sin(iTime*0.1)); \n    uv = zoom*uv-vec2(zoom*0.5,0.5*(1.+zoom));\n    uv.x *= iResolution.x/iResolution.y;\n    float hit=JosKleinian(uv);\n      vec3 c =(1.-hit)*background1Color+hit*color3;\n   \n\tfragColor = vec4(c, 1.0);\n    \n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}