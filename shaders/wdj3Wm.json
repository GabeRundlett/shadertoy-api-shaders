{
    "Shader": {
        "info": {
            "date": "1549073235",
            "description": "Above the clouds infinite skills create miracles...",
            "flags": 0,
            "hasliked": 0,
            "id": "wdj3Wm",
            "likes": 13,
            "name": "VolumetricFlow",
            "published": 3,
            "tags": [
                "3d",
                "ray",
                "sdf",
                "marching",
                "volumetrics"
            ],
            "usePreview": 0,
            "username": "felipunkerito",
            "viewed": 1028
        },
        "renderpass": [
            {
                "code": "#define PI  acos( -1.0 )\n#define TPI     2.0 * PI\n#define HASHSCALE  .1031\n\nmat2 rot( float a )\n{\n\n\treturn mat2( cos( a ), -sin( a ),\n               \t sin( a ),  cos( a )\n               );\n\n}\n\n// https://www.shadertoy.com/view/4djSRW\n\nfloat hash(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Thanks Shane.\nfloat noise3D(vec3 p){\n\n    // Just some random figures, analogous to stride. You can change this, if you want.\n\t  const vec3 s = vec3(7, 157, 113);\n\n\t  vec3 ip = floor(p); // Unique unit cell ID.\n\n    // Setting up the stride vector for randomization and interpolation, kind of.\n    // All kinds of shortcuts are taken here. Refer to IQ's original formula.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n\n\t  p -= ip; // Cell's fractional component.\n\n    // A bit of cubic smoothing, to give the noise that rounded look.\n    p = p*p*(3. - 2.*p);\n\n    // Smoother version of the above. Weirdly, the extra calculations can sometimes\n    // create a surface that's easier to hone in on, and can actually speed things up.\n    // Having said that, I'm sticking with the simpler version above.\n\t//p = p*p*p*(p*(p * 6. - 15.) + 10.);\n\n    // Even smoother, but this would have to be slower, surely?\n\t//vec3 p3 = p*p*p; p = ( 7. + ( p3 - 7. ) * p ) * p3;\n\n    // Cosinusoidal smoothing. OK, but I prefer other methods.\n    //p = .5 - .5*cos(p*3.14159);\n\n    // Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\n    // then interpolating along X. There are countless ways to randomize, but this is\n    // the way most are familar with: fract(sin(x)*largeNumber).\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\n    // Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n\n    // Interpolating along Z, and returning the 3D noise value.\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\n}\n\n/*\nfloat fbm( in vec3 p )\n{\n\n    p.xy *= rot( time * 0.5 );\n\n    float f = 0.0;\n    f += 0.5000 * noise3D( p ); p *= 2.02;\n    f += 0.2500 * noise3D( p ); p *= 2.03; //p += iTime + FRE;\n    f += 0.1250 * noise3D( p ); p *= 2.01; //p -= iTime + WAV;\n    f += 0.0625 * noise3D( p );\n    f += 0.0125 * noise3D( p );\n    return f / 0.9375;\n\n}\n*/\n\nfloat fbm( vec3 p )\n{\n\n\tfloat amp = 1.0, fre = 1.0, res = 0.0, div = 0.0,\n\ttim = 0.8;\n\n\tfor( int i = 0; i < 7; ++i )\n\t{\n\n\t\tres += amp * noise3D( p * fre );\n\t\tp += 0.025 * tim * iTime;\n\t\tdiv += amp;\n\t\tamp *= 0.5;\n\t\tfre *= 2.0;\n\t\ttim *= 0.5;\n\n   }\n\n\tres /= div;\n\n\treturn res;\n}\n\nfloat map( vec3 p )\n{\n\n    float f = 0.0;\n\n    f = p.y - 1.5 + fbm( p ) * 5.0;\n\n    return f;\n\n}\n\nfloat ray( vec3 ro, vec3 rd, out float den )\n{\n\n    float t = 0.0, maxD = 0.0; den = 0.0;\n\n    for( int i = 0; i < 128; ++i )\n    {\n\n        vec3 p = ro + rd * t;\n\n        den = 0.5 * map( p );\n\n        maxD = maxD < den ? den : maxD;\n\n        if( den > 0.99 || t > 20.0 ) break;\n\n        // https://www.shadertoy.com/view/MscXRH\n        t += max( maxD * 0.05, 0.05 );\n\n        //t += 0.05;\n\n    }\n\n    den = maxD;\n\n    return t;\n\n}\n\nvec3 shad( vec3 ro, vec3 rd, vec2 uv )\n{\n\n    //float wav = texture( iChannel1, vec2( 0.5, 0.6 ) ).x * 0.5;\n    //float fre = texture( iChannel1, vec2( 0.2, 0.5 ) ).x * 0.5;\n\n    vec2 mou = iMouse.xy / iResolution.y;\n\n    float den = 0.0;\n    float t = ray( ro, rd, den );\n\n    vec3 p = ro + rd * t;\n\n    vec3 col = mix( vec3( 0.9 ),\n               \t   mix( vec3( min( 0.3, mou.y ), 0.2, 0.6 ),\n               \t         mix( vec3( 0.8, 0.8, 0.8 ),\n               \t        \t  vec3( 0.2, 0.5, 0.8 ),\n               \t        \t  uv.y ),\n               \t        \t  den\n               \t       ),\n                    den );\n\n    //col *= sqrt( col );\n\n    return col;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n\n    vec2 mou = iMouse.xy / iResolution.xy;\n\n    //float pi = acos( -1.0 );\n    vec3 ro = vec3( 0, 0.25, 0 );\n    //ro.y -= fbm( ro );\n    ro.xz *= rot( mou.x * TPI );\n    //ro.yz *= rot( gyroscope.y );\n    vec3 rd = normalize( vec3( uv, 1.0 ) );\n    //rd.y -= fbm( ro );\n    rd.xz *= rot( mou.x * TPI );\n    //rd.yz *= rot( gyroscope.y );\n\n    //ro *= rotationMatrix;\n    //rd *= rotationMatrix;\n\n    float den = 0.0, t = ray( ro, rd, den );\n\n    vec3 bco = mix( vec3( 0.8, 0.8, 0.8 ),\n               \t   vec3( 0.2, 0.5, 0.8 ),\n               \t   uv.y );\n\n    vec3 col = den < 0.99 ? shad( ro, rd, uv ) : bco;\n\n    //vec3 bkCol = mix( vec3( 0.8 ), vec3( 0.2, 0.5, 0.8 ), uv.y );\n\t  //vec3 col = mix( bkCol, shad( ro, rd, uv ), den );\n\n    // Output to screen\n    fragColor = vec4( col, 1 );\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}