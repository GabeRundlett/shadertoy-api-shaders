{
    "Shader": {
        "info": {
            "date": "1696845319",
            "description": "A LUT generator for volumetric atmospheric scattering",
            "flags": 0,
            "hasliked": 0,
            "id": "ddcBz8",
            "likes": 2,
            "name": "AtmosphereLUT",
            "published": 3,
            "tags": [
                "atmosphere"
            ],
            "usePreview": 0,
            "username": "barth",
            "viewed": 206
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415926535897932\n#define POINTS_FROM_CAMERA 120// number sample points along camera ray\n#define OPTICAL_DEPTH_POINTS 120// number sample points along light ray\n\n// rotation using https://www.wikiwand.com/en/Rodrigues%27_rotation_formula\nvec3 rotateAround(vec3 vector, vec3 axis, float theta) {\n    // Please note that unit vector are required, i did not divided by the norms\n    return cos(theta) * vector + cross(axis, vector) * sin(theta) + axis * dot(axis, vector) * (1.0 - cos(theta));\n}\n\n// A narrower version of line intersect sphere. It will return true only when the intersection is at a positive distance from the ray origin.\nbool rayIntersectSphere(vec3 rayOrigin, vec3 rayDir, vec3 spherePosition, float sphereRadius, out float t0, out float t1) {\n    vec3 relativeOrigin = rayOrigin - spherePosition;// rayOrigin in sphere space\n\n    float a = 1.0;\n    float b = 2.0 * dot(relativeOrigin, rayDir);\n    float c = dot(relativeOrigin, relativeOrigin) - sphereRadius*sphereRadius;\n\n    float d = b*b - 4.0*a*c;\n\n    if (d < 0.0) return false;// no intersection\n\n    float s = sqrt(d);\n\n    float r0 = (-b - s) / (2.0*a);\n    float r1 = (-b + s) / (2.0*a);\n\n    t0 = min(r0, r1);\n    t1 = max(r0, r1);\n\n    //return true;\n    return t1 > 0.0;\n}\n\nconst float EARTH_RADIUS = 1000e3;\nconst float ATMOSPHERE_RADIUS = 100e3;\nconst vec3 SUN_DIR = vec3(0.0, 1.0, 0.0);\n\nstruct Object {\n    float radius;\n    vec3 position;\n};\nconst Object object = Object(EARTH_RADIUS, vec3(0.0));\n\nstruct Atmosphere {\n    float radius;// atmosphere radius (calculate from planet center)\n    float falloff;// controls exponential opacity falloff\n    float sunIntensity;// controls atmosphere overall brightness\n    float rayleighStrength;// controls color dispersion\n    float mieStrength;// controls mie scattering\n    float densityModifier;// density of the atmosphere\n    float redWaveLength;// the wave length for the red part of the scattering\n    float greenWaveLength;// same with green\n    float blueWaveLength;// same with blue\n    float mieHaloRadius;// mie halo radius\n};\nconst Atmosphere atmosphere = Atmosphere(EARTH_RADIUS + ATMOSPHERE_RADIUS, 1.0, 10.0, 1.0, 1.0, 1.0, 700.0, 530.0, 440.0, 0.6);\n\n// based on https://www.youtube.com/watch?v=DxfEbulyFcY by Sebastian Lague\nvec2 densityAtPoint(vec3 samplePoint) {\n    float heightAboveSurface = length(samplePoint - object.position) - object.radius;\n    float height01 = heightAboveSurface / (atmosphere.radius - object.radius);// normalized height between 0 and 1\n\n    vec2 localDensity = vec2(\n    atmosphere.densityModifier * exp(-height01 * atmosphere.falloff),\n    atmosphere.densityModifier * exp(-height01 * atmosphere.falloff * 0.5)\n    );\n\n    localDensity *= (1.0 - height01);\n\n    return localDensity;// density with exponential falloff\n}\n\n\nvec2 opticalDepth(vec3 rayOrigin, vec3 rayDir, float rayLength) {\n\n    vec3 densitySamplePoint = rayOrigin;// that's where we start\n\n    float stepSize = rayLength / float(OPTICAL_DEPTH_POINTS - 1);// ray length between sample points\n\n    vec2 accumulatedOpticalDepth = vec2(0.0);\n\n    for (int i = 0; i < OPTICAL_DEPTH_POINTS; i++) {\n        accumulatedOpticalDepth += densityAtPoint(densitySamplePoint) * stepSize;// linear approximation : density is constant between sample points\n        densitySamplePoint += rayDir * stepSize;// we move the sample point\n    }\n\n    return accumulatedOpticalDepth;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 vUV = fragCoord/iResolution.xy;\n\n    float height01 = vUV.y;\n    float lutx = vUV.x;\n    float costheta = lutx * 2.0 - 1.0;\n    float theta = acos(costheta);\n\n    vec3 surfacePoint = rotateAround(vec3(0.0, EARTH_RADIUS, 0.0), vec3(0.0, 0.0, 1.0), theta);\n    vec3 surfaceNormal = normalize(surfacePoint);\n    vec3 atmospherePoint = surfacePoint + surfaceNormal * ATMOSPHERE_RADIUS * height01;\n\n    float t0, t1;\n    rayIntersectSphere(atmospherePoint, SUN_DIR, vec3(0.0), EARTH_RADIUS + ATMOSPHERE_RADIUS, t0, t1);\n\n    vec2 sunRayOpticalDepth = opticalDepth(atmospherePoint, SUN_DIR, t1);\n\n    vec3 color = vec3(sunRayOpticalDepth.x, sunRayOpticalDepth.y, 0.0);\n    //color = log(1.0 + color);\n    \n    color = 1.0 / (1.0 + 1e-5 * color);\n    //color = exp(-1e-5 * color);\n    \n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}