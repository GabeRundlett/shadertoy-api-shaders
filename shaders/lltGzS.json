{
    "Shader": {
        "info": {
            "date": "1470721422",
            "description": "Focusing on color and lighting. Same geometry as Blue DNA.\nGot the radial blur working better too partly because I use a more orange specular lighting and also I fooled \naround with the decay and exposure more this time. ",
            "flags": 96,
            "hasliked": 0,
            "id": "lltGzS",
            "likes": 39,
            "name": "Your Genes at Dawn",
            "published": 3,
            "tags": [
                "music",
                "blur",
                "lighting",
                "color",
                "radial",
                "godrays",
                "helix",
                "dna"
            ],
            "usePreview": 1,
            "username": "Yusef28",
            "viewed": 2327
        },
        "renderpass": [
            {
                "code": "//Radial Blur Based on shaders by Shane and Passion\n//Shane's https://www.shadertoy.com/view/XsKGRW\n//Passion's https://www.shadertoy.com/view/MdG3RD\n\n//Also\n//Radial Blur - IQ https://www.shadertoy.com/view/4sfGRn\n//Rays of Blinding Light - mu6k https://www.shadertoy.com/view/lsf3Dn\n\n//and an nvidia gpu gems 3 tutorial\n//    http://http.developer.nvidia.com/GPUGems3/gpugems3_ch13.html\n//I am still trying to understand that first equation which is a model\n//for daylight. It's a little more complex than this radial blur algorithm\n//that they and we are using but this alg is based on that equation.\n\n\n\n\n//I explain basically every line of code.\n//I'm sure a lot of you wont need that but it helps me understand and \n//hopefully someone new to all this will find it useful.\n\nconst float SAMPLES = 55.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    //so we need some coefficients\n    float weight = 0.005; //weighting factor to get a weighted of each sample\n    //orback to 0.08\n    \t\t\t\t\t\n    float decay = 0.9; //used to decrease the weighting fact so each step adds less to the sum,\n    \t\t\t\t\t//to model scattering and absortion\n    \n    float density = 0.9;//0.3 //used to scale the step size of the samples and step size(or totaal distance)\n    \t\t\t\t\t//determines how far in each ray direction calulations and bluring is done for\n    \t\t\t\t\t//higher density means longer streaks of light and also more blur\n    float exposure = 3.1;  //or back to 1.1\n    /*from nvidia: exposure controls the overall intensity of the \n    post-process, weight controls the intensity of each sample, \n        and decayi (for the range [0, 1]) dissipates each sample's \n        contribution as the ray progresses away from the light source. \n        This exponential decay factor practically allows each light shaft \n        to fall off smoothly away from the light source.*/\n    \n    \t\t\t\t\t\t \n    //uv here will be used as a direction vector. So each coordinate will have it's cooresponding\n    //vector. eg. coor 0.5, 0.5, is a vector, 0.5, 0.5\n    //This vector is used as a ray and the algorithm will step through the ray in this \n    //direction, from 0.,0., to the end of the ray at the current coordinate.\n    \n    \n\t\n    \n    //we subtract 0.5 to shift it to -0.5 to +0.5 so 0.0, 0.0 is center of screen\n    //so the blur goes out in all directions\n    vec2 tuv = uv-0.5; //also we use a new vec2 because we still need uv for sampling and \"jitter\"\n    \n    vec2 duv = tuv/SAMPLES*density;\n    \n    vec4 initColor = texture(iChannel0, uv.xy)*0.14;//portion of total color to start with.\n    //color in this case comes from channel0 which is a buffer that returns the scene color\n    \n    //jitter is a way of reducing banding which is a type of artifact... which we don't want\n    //shane's version uses time to change the jitter which seems like a good idea but I'm\n    //going for simple right now so I'm going with Passions which is just muliplying duv and random\n    \n    //this is added as an offset to uv.  uv which will be used to sample each texture in the alg loop.\n    //so we add a random percentage of duv to uv.\n    //random is key because the issue is banding is you get these weird lines or waves\n    //so to smooth them out you can offset each point by a random amount.\n    uv+=duv*fract(sin(dot(uv, vec2(12.9898, 78.233)))*43758.5453);\n    \n    for(float i=0.;i<SAMPLES;i++)\n    {\n        \n     \n        //for each step move along the ray towards the center(uv - stepsize for all steps\n        //where step is fraction of uv, will result in 0, 0 the middle\n        uv-=duv;\n        \n        //add weighted percentage of scene color\n        \n        \n        initColor+=texture(iChannel0, uv)*weight; \n        \n        weight*=decay;//decay the weight.\n        \n    }\n    \n\tinitColor*=exposure;\n  \tinitColor*= (1. - dot(tuv, tuv)*.975);\n\tfragColor = vec4(vec3(initColor),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 4515,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/felipe-moreno-11/resident-evil-4-soundtrack"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\n#define PI 3.1415926535898\n\nconst float freq1 = 0.15;\nconst float freq2 = 0.25;\nconst float ampl1 = 2.4;\nconst float ampl2 = 1.7;\n\n//take in vec2 return random float 0 - 1\nfloat rnd(vec2 p)\n{\n    vec2 seed = vec2(13.234, 72.1849);\n    return fract(sin(dot(p,seed))*43251.1234);    \n}\n//color to gray scale\nfloat getGrey(vec3 p)\n{\n    return p.x*0.299 + p.y*0.587 + p.z*0.114;\n}\n\n//shane's hash function\nvec3 hash33(vec3 p)\n{\n    float d = sin(dot(p, vec3(7, 157, 113)));\n    return fract(vec3(20578, 262134, 30475)*d);\n}\n\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n               dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Value Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm(vec2 st)\n    {\n    float f = noise(st)*1.; st*=2.01;\n    f += noise(st)*0.5; st*=2.02;\n    f += noise(st)*0.25; st*=2.04;\n    f += noise(st)*0.125; st*=2.03;\n    return f;\n    }\n    \n//from shane, and he got it from an nvidia tutorial you can google\nvec3 triPlanar(sampler2D tex, vec3 p, vec3 n)\n{\n    vec3 norm = max(abs(n), 0.0001);\t\n     float sum = norm.x+norm.y+norm.z;\n     norm = norm/sum;\n     return vec3(texture(tex, p.yz)*norm.x + \n                 texture(tex, p.xz)*norm.y +\n                 texture(tex, p.xy)*norm.z);\n    \n}\n\n//iq has a youtube video on this\nfloat smoothMin(float a, float b, float smoothing)\n{\n   \tfloat h = clamp((b-a)*0.5/smoothing +0.5, 0.0,1.0);\n    return mix(b, a, h) - smoothing*h*(1.0-h);\n}\n\n//paths for the tunnels\n//sin and cos, sin for y, and cos for x, and then reversed for path 2. \nvec2 path(in float z){ return vec2(ampl1*sin(z*freq1), ampl2*cos(z*freq2));}\nvec2 path2(in float z){return vec2(ampl2*sin(z*freq2*1.5), ampl1*cos(z*freq1*1.3));}\n\n//rotation matrix (clockwise)\nmat2 rot(float a)\n{\n     float c = cos(a),s = sin(a);\n     return mat2(c, -s, s, c);\n}\n//makes the dna strands\nfloat helix(vec3 p )\n{\n    \n    //create two cylinders which will be twisted\n    float cyl1 = length(p.xz + vec2(1.0,0.0)) - 0.2 ;\n    float cyl2 = length(p.xz - vec2(1.0, 0.0)) - 0.2 ;;\n    //mod space on y for bars\n    p.y = mod(p.y,.4)-.2;\n    //create y repeated cylinders cut at abs(p.x etc)\n    float bar = max(length(p.yz) - 0.07, abs(p.x) - .9) ;\n    //return helix (union of cylinders and bars)\n\treturn min(min(cyl1, bar), cyl2);\n}\n\nfloat map(vec3 p )\n{\n    //repeat distant helix only\n    if(floor(p.z) > 0.){\n        p.xz = mod(p.xz, 10.) -5.;\n    }\n    //rotate each cell based on y for helix shape\n    p.xz*=rot(p.y*3.14159/7.);\n    //spin the cell aorund\n    p.xz*=rot(iTime/2.);\n    //return the helixes\n    return helix(p);\n}\n\n//basic raymarch\nfloat trace(vec3 ro, vec3 rd)\n{\n   \tfloat t = 0.0,dist;\n    for(int i=0; i<96; i++)\n    {\n     dist = map(ro + rd*t);\n     if(dist<0.0001 || t > 120.){break;}\n     t += dist*0.75;\n    }\n return t;   \n}\n\n//basic normal calculation \nvec3 normal(vec3 sp)\n{\n    //we swizzel a vec2 epsilon to get vec3\n    vec2 e = vec2(.0001, 0.0);\n    return normalize (\n    vec3(map(sp+e.xyy) - map(sp-e.xyy),\n         map(sp+e.yxy) - map(sp-e.yxy),\n         map(sp+e.yyx) - map(sp-e.yyx))\n    );\n}\n\n\n\n//ao from shane\nfloat calculateAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv  = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n    \n    vec3 lookAt = vec3(.0, 0.0, 0.0);\n    vec3 campos = lookAt + vec3(.0, 0.0, -6.0);\n    \n    vec3 light1 = campos + vec3(0.0, .125, -0.25);\n    vec3 light2 = campos + vec3(1.0, 0.0, 5.0);\n    \n\n    float FOV = PI/3.;\n    vec3 forward = normalize(lookAt - campos);\n    vec3 right = normalize(vec3(forward.z, 0.0, 0.0));\n    vec3 up = cross(forward, right);\n    vec3 rd = normalize(forward + FOV*right*uv.x + FOV*up*uv.y);\n    rd.xy*=rot(-.8);\n    \n\n    float t = trace(campos,rd);\n    \n    float fog = smoothstep(0.0, .95, t/30.);\n    \n    vec3 Col;\n    \n        \n        vec3 sp = t*rd + campos;\n        \n        vec3 csp = sp;\n        \n        //same as in map\n        if(floor(sp.z) > 0.){\n            csp = mod(sp,10.)-5.;\n        }\n        csp.xz*=rot(iTime/2.);\n        vec3 norm = normal(sp);\n        \n        \n        const float texscale = 0.25;\n        vec3 oldnorm = norm;\n        \n        float ao = calculateAO(sp, norm);\n\n        vec3 ld1 = light1 - sp;\n        vec3 ld2 = light2 - sp;\n        \n        float distl1 = max(length(ld1), 0.001);\n        float distl2 = max(length(ld2), 0.001);\n        \n    \tld1/=distl1;\n        ld2/=distl2;\n        \n        float atten1 = 1.0/(1.0 + distl1*0.2 + distl1*distl1*0.02);\n        float atten2 = 1.0/(1.0 + distl2*0.2 + distl1*distl2*0.02);\n        \n        float ambient = .5;\n        \n        float diff1 = max(dot(norm, ld1), 0.00)*1.;\n        float diff2 = max(dot(norm, ld2), 0.00)*1.;\n        \n        float spec1 = pow(max(dot(reflect(-ld1, norm), -rd), 0.), 8.0);\n        float spec2 = pow(max(dot(reflect(-ld2, norm), -rd),0.), 8.0);\n        \n        float fresnel =  pow(clamp(dot(norm, rd) + 1., 0.0, 1.0), 1.0);\n        vec3 tex = triPlanar(iChannel0, csp*texscale/2., norm).xyz;\n        Col += tex*(diff1*tex.xyz + ambient+ vec3(0.9, 0.5, 0.2)*spec1*10. + fresnel*tex*0.25)*atten1*2.;\n    \tCol += tex*(diff2*vec3(0.9, 0.5, 0.2)* + ambient + vec3(0.9, 0.5, 0.2)*spec2*400. + fresnel*tex*0.25)*atten2;  \n    \n\n    \n    vec3 grey1 = vec3(0.77, 0.89, 1.);\n    vec3 grey2 = vec3(1., 0.89, 0.77);\n    vec3 bg = mix(grey1, grey2, 1.0-uv.y);\n    Col =  mix(Col, bg, fog);\n    \t\n\t\t\n    \n\tfragColor = vec4(pow(Col,vec3(0.9)),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\n\n//old version\n\n\n\n#define PI 3.1415926535898\n\nconst float freq1 = 0.15;\nconst float freq2 = 0.25;\nconst float ampl1 = 2.4;\nconst float ampl2 = 1.7;\n\n//color to gray scale\nfloat getGrey(vec3 p)\n{\n    return p.x*0.299 + p.y*0.587 + p.z*0.114;\n}\n\n//shane's hash function\nvec3 hash33(vec3 p)\n{\n    float d = sin(dot(p, vec3(7, 157, 113)));\n    return fract(vec3(20578, 262134, 30475)*d);\n}\n\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n               dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Value Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm(vec2 st)\n    {\n    float f = noise(st)*1.; st*=2.01;\n    f += noise(st)*0.5; st*=2.02;\n    f += noise(st)*0.25; st*=2.04;\n    f += noise(st)*0.125; st*=2.03;\n    \n    return f;\n    }\n//from shane, and he got it from an nvidia tutorial you can google\nvec3 triPlanar(sampler2D tex, vec3 p, vec3 n)\n{\n    //this thing gets the normal, abs because we only need positive values, \n    //negative ones are going into the surface so not needed?\n    //we get max I guess because I guess if the normal is 0 or too small it's not helpful lol\n    //we get the sum and use it to get the percentage each component contributes to the whole.\n vec3 norm = max(abs(n), 0.0001);\t//I'll keep it simple with just this\n float sum = norm.x+norm.y+norm.z;\n norm = norm/sum;//so now the normal is a weighting factor, each component is  weight out of 100 percent\n    \n    //I kinda get this. it's doing the scaling here, but it's still hard to visualize \n    //that adding texures of the yz, xz, and xy planes would result it a crisp image.\n    //for example, if the texture was a chess board pattern...hmmm maybe.\n    return vec3(texture(tex, p.yz)*norm.x + \n                texture(tex, p.xz)*norm.y +\n                texture(tex, p.xy)*norm.z) ;\n    \n}\n\n//triangle wave\nvec3 tri(vec3 x)\n{\n     return abs(x - floor(x)-0.5);   \n}\n\nfloat surf(vec3 p)\n{\n    \n//this function is beyond me right now lol\n//I mean I know it's adjusting the walls of the tunnel in some way\n//and I know tri function returns values in the triangle waves distribution\n//I don't know if there is any significance to the scaling values used on p\n//I can't see exactly what nested tris would do\n//dotting with vec3 0.444, or vec3 0.222 I guess just randomizes things?\n//p.xz = what and why? lol\n    \n \tfloat n = dot(tri(p*0.48 + tri(p*0.24).yzx), vec3(0.444));\n    p.xz = vec2(p.x+p.z, p.z-p.x)*0.7071;\n    return dot(tri(p*0.72 + tri(p*0.36).yzx), vec3(0.222)) + n;\n       \n       //dotting increases the amplitude of the perturbations\n       //so does adding n.\n       //makes sense, dotting with higher values means larger scalar result\n       //nested tris with one swizzled makes things more random \n}\n\nfloat smoothMin(float a, float b, float smoothing)\n{\n   \t//a and b are the distances of the two things to smooth\n    //h is a factor based on the difference between the two distances and smoothing\n    //something like a fraction of the difference between\n    //mix is a form of interpolation , so is smoothing*h*(1.0-h)\n    //so the result will be a distance based on the interpolation between the \n    //two input distances with some sort of smoothing factor.\n    //this is based on what I read from iq and the little I know of linear interpolation\n    float h = clamp((b-a)*0.5/smoothing +0.5, 0.0,1.0);\n    return mix(b, a, h) - smoothing*h*(1.0-h);\n   \n}\n\n//paths for the tunnels\n//sin and cos, sin for y, and cos for x, and then reversed for path 2. \nvec2 path(in float z){ return vec2(ampl1*sin(z*freq1), ampl2*cos(z*freq2));}\nvec2 path2(in float z){return vec2(ampl2*sin(z*freq2*1.5), ampl1*cos(z*freq1*1.3));}\n\nmat2 rot(float a)\n{\n float cs = cos(a);\n    float si = sin(a);\n    \n    return mat2(cs, -si, si, cs);\n}\nfloat map(vec3 p )\n{\n    vec3 oldp = p;\n    float iz =floor(p.z);\n float ix =floor(p.x);\n   \n    if(iz > 0. && iz < 20.)\n    p.xz = mod(p.xz, 10.) -5.;\n    \n    p.xz*=rot(p.y*PI/5.);\n    p.xz*=rot(iTime/2.);\n   // oldp.xz*=rot(iTime);//thought I needed this for surf at end but no\n\n    \n    float cyl1 = length(p.xz + vec2(1.0,0.0)) - 0.2;// - ((surf(p*30.)/60.));//+sin(p.y*8.)/50.;\n    float cyl2 = length(p.xz - vec2(1.0, 0.0)) - 0.2;// - ((surf(p*30.)/60.));//+sin(p.y*8.)/50.;\n    \n     p.y = mod(p.y,.4)-.2;\n    float bar = max(length(p.yz) - 0.07, abs(p.x) - .9) ;//-surf(p*20.)/50.;\n    \n\t\n   // p.xz*=rot(iTime);\n\tfloat dna =  min(min(cyl1, bar), cyl2) ;//if I wanted the noise applied to everything\n    \n    //if I wanted to added another object\n    ///float cell = length(p)-.1-surf(p*3.)/4.;\n    //return min(dna, cell);\n    \n    return dna ;// \n    //before I just had \n    //return min(min(cyl1, bar), cyl2);\n    \n    //other cool things\n    //return min(min(cyl1, bar), cyl2) - (1.0-abs(surf(oldp*3.)/50.));\n    //return min(min(cyl1, bar), cyl2) - (abs(fbm(oldp.yy*4.)/5.));\n\n}\n\nvec3 bumpMap(sampler2D tex, in vec3 p, in vec3 n, float bumpfactor)\n{\n    //ok so I don't understand this technique yet.\n    //I mean I can visualize getting the greyscale values from the texture \n    //at three points around the ref, based on the point and the normal.\n    \n    //usually if you want a gradient you\n    //want to get the difference between the ref and points around it\n    \n    //we do this when we take the normal although in that cause we are \n    //getting distances. Here we imply distance by getting greyscale values.\n    //the resulting gradient then cna be considered a normal because each of\n    //it's components is a basis vector that is the slope between the \n    //the components of the ref and the point representing the change from that point\n    //to a bit away.\n    \n    \n    \n    const vec3 eps = vec3(0.001, 0., 0.);//I use swizzling here, x is eps\n    float ref = getGrey(triPlanar(tex, p, n));//reference value \n    \n    vec3 grad = vec3(getGrey(triPlanar(tex, p - eps, n)) - ref,\n                     //eps.yxz means 0.,0.001, 0. \"swizzling\n                     getGrey(triPlanar(tex, p - eps.yxz, n)) - ref,\n                     getGrey(triPlanar(tex, p - eps.yzx, n)) - ref)/eps.xxx;\n    \n    //so grad is the normal...then he does:\n    grad -= n*dot(grad, n);//takes the dot of the surface normal \n    //and the texture normal (the gradient), so percentage of how similar they are\n    //multplies by the surface normal again so scaling it by that percentage\n    //and subtracting that from the gradient.\n    //so the result is only the portion of the gradient that is not part of n??\n    \n    // and returning the surface normal + that gradient portion plus a bump factor\n    //why???\n    return normalize(n + grad*bumpfactor);\n}\n\n// Surface normal.\nvec3 getNormal(in vec3 p) {\n\t//as I explained in the bump function, it get's the gradient\n    //around the point of interest, although here instead of a reference we\n    //get the slope between a bit above to a bit below the point of interest, etc.\n    //They are the slopes of distances so float values, and they are used to \n    //represent components of a vector3 and that vector can be used as the normal.\n   \n\tconst float eps = 0.001;\n\treturn normalize(vec3(\n\t\tmap(vec3(p.x+eps,p.y,p.z))-map(vec3(p.x-eps,p.y,p.z)),\n\t\tmap(vec3(p.x,p.y+eps,p.z))-map(vec3(p.x,p.y-eps,p.z)),\n\t\tmap(vec3(p.x,p.y,p.z+eps))-map(vec3(p.x,p.y,p.z-eps))\n\t));\n\n}\n\n\nfloat calcAo(vec3 p, vec3 n)\n{\n    //I get the general idea of ao, but I do not understand\n    //why we are subtraction d by the distance.\n    \n   //I also can't really picture this algorithm as a whole, \n    //like what kind of values are being accumulated and what ...\n \t\nconst float ao_samples = 5.;\n    float r = 0.0, w = 1.0, d;\n    for(float i = 0.01 ; i<ao_samples ; i+=1.1)\n    {\n    d = i/ao_samples;//1/5, 2/5, 3/5, 4/5, 1\n    r += w*(d - map(p + n*d));\n     //r is accumulating the weighted results\n        \n        //map(p + n*d) means move a ray from the sp out in direction of normal.\n        //n is normalized so it's length is 1.\n        //d is from 0.20 to 1, so ray will only move out by max 1.\n        //d - map(p+n*d) then means (0.20 to 1) - distance to closest object as ray moves away from\n        //initial surface in direction of normal.\n        //so you would expect map(p + n*d) to be either the distance to sp, in the case that\n        //there is no real occlusion.\n        //in the case that there is occlusion you would expect map(p+n*d) to get smaller again \n        //as it gets closer to another surface.\n        \n        //I'm pretty sure w means the further you get from the initial surface, the less you take \n        //into consideration the distance to the next object?\n       \n        \n        //ok I figured out a way to look at this.\n        //take a sphere who's closest face is distance 2. away from camera. \n        //from that surface, add n*d... so you move directed away from the \n        //the surface towards the camera again.\n        //first step is by 0.2 because d will be 0.20 and so the distnace \n        //returned will be 0.20\n        //0.20 - 0.20 will be 0, and w *0 will be zero.\n        //each step will happen the same way, for all points if there is just a sphere.\n        \n        //so no occulution.\n        \n        //if we use a cube on a plane instead, a point on a face of the cube\n        //that is close to the plane, means as the ray travels out from that point\n        //along the normal, it will retain the same distance to the plane.\n        //let's say that distance is 0.2.\n        //then for each step, the map will return 0.2, \n        //and d - 0.2 will be 0, 0.2, 0.4, 0.6, and 0.8(wait know d starts at 0.01,so its ~-0.2, 0.0, 0.2..\n        //if we didn't subtract by d we would always just have ~-0.2.\n        //w* is an acculumation weight, and if...ok I'll come back to this.\n       \n       \n    w*=0.5;\n    }\n\n    return 1.0 - clamp(r,0.0, 1.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv  = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n    \n    vec3 lookAt = vec3(.0, 0.0, 0.0);\n    vec3 campos = lookAt + vec3(.0, 0.0, -6.0);\n    \n    vec3 light1 = campos + vec3(0.0, .125, -0.25);\n    vec3 light2 = campos + vec3(1.0, 0.0, 5.0);\n    \n   // lookAt.xy += path(lookAt.z);\n   // campos.xy += path(campos.z);\n    \n   // light1.xy += path(light1.z);\n\t//light2.xy += path(light2.z);\n    //I've ommitted adding path to the lights because it seems redundant\n    //although it does make a difference somehow.\n    \n    float FOV = PI/3.;//is a bit more than one so multiplying this by right and up in ray\n    //direction increases those vector components (x and y) so it kinda stretches the screen\n    //so you can see more.\n    vec3 forward = normalize(lookAt - campos);\n    vec3 right = normalize(vec3(forward.z, 0.0, 0.0));//don't really need -forward.x?\n    \t\t\t\t\t\t\t//pretty cool using forward.z as the x component in this vector\n    vec3 up = cross(forward, right);\n    \n    \n    vec3 rd = normalize(forward + FOV*right*uv.x + FOV*up*uv.y);\n    rd.xy*=rot(-.8);\n    \n    float t = 0.0, dt;\n    for(int i = 0;i<128; i++)\n    {\n        dt = map(campos + rd*t);\n    if(dt<0.005 || t > 150.){break;}\n    \n    t += dt*0.75;\n    }\n    \n    \n    float fog = smoothstep(0.0, .95, t/30.);\n    \n    vec3 Col;// = vec3(0.1, 0.2, 0.3);//-(uv.y+0.1)/2.;\n    if(dt<0.05)\n    {\n        \n        t += dt;//adds the final bit needed to be right on surface?\n        \n        vec3 sp = t*rd + campos;\n        \n                vec3 csp = sp;\n        float iz = floor(sp.z);\n        if(iz > 0. && iz < 20.)\n        csp = mod(sp,10.)-5.;\n                csp.xz*=rot(iTime/2.);//need to rotate the texture the same way I rotate the objects\n        \n        \n     //  csp.y*=50.;//the texture produces some weird horizontal lines so I scale the y axis to \n        //kind of smooth it out. Not perfect but seems to be an improvement. \n\t\t\t\t\n\n        vec3 norm = getNormal(sp);\n        \n        \n        const float texscale = 0.25;\n        vec3 oldnorm = norm;\n        norm = bumpMap(iChannel1, csp*texscale*4., norm, 0.04)*0.9-0.02;//bump map changes the normal\n        //norm = bumpMap(iChannel2, csp*texscale*8., norm, 0.04);//bump map changes the normal\n        \n        float ao = calcAo(sp, norm);\n        \n      \t//these two get the direction from the surface to the light\n        //(light is at 0,0,6, surface is at 0.0 or less than 0, so 0,0,6 - 0,0,0 = 0,0,6 so\n        //towards the light.\n        //which is what we want so we can do the diffuse calculation with both \n        //vectores pointing in the same direction, out of the surface.\n        \n        vec3 ld1 = light1 - sp;\n        vec3 ld2 = light2 - sp;\n        \n        float distl1 = max(length(ld1), 0.001);\n        float distl2 = max(length(ld2), 0.001);\n        \n        \n    \tld1/=distl1;\n        ld2/=distl2;\n        \n        float atten1 = 1.0/(1.0 + distl1*0.2 + distl1*distl1*0.02);\n        float atten2 = 1.0/(1.0 + distl2*0.2 + distl1*distl2*0.02);\n        \n        float ambient = .5;\n        \n        float diff1 = max(dot(norm, ld1), 0.00)*1.;\n        float diff2 = max(dot(norm, ld2), 0.00)*1.;\n        \n        //reverse light direction because reflection kind of reverses it again?\n        //reverse ray direction to get amount of light heading towards our eyes \n        float spec1 = pow(max(dot(reflect(-ld1, norm), -rd), 0.), 8.0);\n        float spec2 = pow(max(dot(reflect(-ld2, norm), -rd),0.), 8.0);\n        \n        //passing on curvature for now \n        \n        //fresnel here just adds some brightness where the normal is inline with our eyes\n        float fresnel =  pow(clamp(dot(norm, rd) + 1., 0.0, 1.0), 1.0);\n        \n        \n        vec3 tex = triPlanar(iChannel0, csp*texscale/2., norm).xyz;\n        //tex = vec3(getGrey(tex));\n        //tex = vec3(160./255., 180./255., 245./255.)/9.;\n\n    //tex = tex.zxx;\n        \n        Col += tex*(diff1*tex.xyz + ambient+ vec3(0.9, 0.5, 0.2)*spec1*10. + fresnel*tex*0.25)*atten1*2.;\n    \tCol += tex*(diff2*vec3(0.9, 0.5, 0.2)* + ambient + vec3(0.9, 0.5, 0.2)*spec2*400. + fresnel*tex*0.25)*atten2;  \n        \n        //Col *= ao*pow((1.0-dot(-rd, norm)), 1./4.)-0.5;//adding ao and that awesome affect that is\n        //the opposite of the fresnel term so the highlights become the low lights... \n        //I found this in another shader, the cool virus shader. I'll add the link asap.\n       \n        \n    \t\n    }\n\n    \n    \n    \n    \tvec3 col = vec3(0.1, 0.2, 0.3)+(uv.y+0.1)/2.;    \n    \t\tcol = vec3(0.1, 0.2, 0.3)*1.6;//used when using radial blur\n    \t\tvec3 bg = col.xyz+(fbm(uv*3.)*0.9-0.9)/9.;\n    \t\tbg = mix(vec3(0.9, 0.5, 0.2)*1.9, vec3(0.2, 0.7, 0.9)*1.3, uv.x+0.4)/2.;\n    \t\tbg = mix(vec3(0.77, 0.89, 1.), \n                     1.1*vec3(1., 0.89, 0.77), 1.0-(uv.y+0.2))/1.7;\n    \tCol =  mix(Col, bg, fog);\n    \t\n\t\t\n    \n\tfragColor = vec4((Col)/1.94,1.0);\n}\n\n*/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}