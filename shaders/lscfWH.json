{
    "Shader": {
        "info": {
            "date": "1524878784",
            "description": "You can never have too few boolean ops... let's go nuts with boolean operations! :) Not sure where I want to go with this yet.\n\nIf performance is bad for your setup, set SHADOW to 'false' on line 25 (in buffer A).",
            "flags": 32,
            "hasliked": 0,
            "id": "lscfWH",
            "likes": 10,
            "name": "Metaballs in \"ribbons\"",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "metaballs",
                "fxaa",
                "pbr",
                "booleans"
            ],
            "usePreview": 1,
            "username": "MacSlow",
            "viewed": 833
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Metaballs in \"ribbons\" - idea about some nested boolean ops\n//\n// Copyright 2018 Mirco M端ller\n//\n// Author(s):\n//   Mirco \"MacSlow\" M端ller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float FXAA_SPAN_MAX = 8.;\nconst float FXAA_REDUCE_MIN = 1. / 128.;\nconst float FXAA_REDUCE_MUL = 1. / 8.;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iChannelResolution[0].xy;\n    vec2 offset = 1. / iChannelResolution[0].xy;\n\n    vec3 lum = vec3 (.299, .587, .114);\n    float lumTL = dot (lum, texture (iChannel0, (uv + vec2 (-1., -1.))*offset).rgb);\n    float lumBL = dot (lum, texture (iChannel0, (uv + vec2 (-1., 1.))*offset).rgb);\n    float lumC  = dot (lum, texture (iChannel0, uv).rgb);\n    float lumTR = dot (lum, texture (iChannel0, (uv + vec2 (1., -1.))*offset).rgb);\n    float lumBR = dot (lum, texture (iChannel0, (uv + vec2 (1., 1.))*offset).rgb);\n\n    vec2 blurDir;\n    float blurReduce = max((lumTR + lumTL + lumBR + lumBL) * (FXAA_REDUCE_MUL * .25),\n                           FXAA_REDUCE_MIN);\n    blurDir.x = ((lumTR + lumTL) - (lumBR + lumBL));\n    blurDir.y = ((lumTL + lumBL) - (lumTR + lumBR));\n    float inverseDirAdjustment = 1. / (min (abs (blurDir.x), abs (blurDir.y)) + blurReduce);\n    \n    blurDir = min (vec2 (FXAA_SPAN_MAX), max (vec2 (-FXAA_SPAN_MAX),\n                                              blurDir * inverseDirAdjustment));\n    blurDir *= offset;\n\n    vec3 result1 = .5 * (texture (iChannel0, uv + blurDir * vec2 (1. / .3 - .5)).rgb +\n                         texture (iChannel0, uv + blurDir * vec2 (2. / .3 - .5)).rgb);\n    vec3 result2 = result1 * .5 +\n                   .25 * (texture (iChannel0, uv + blurDir * vec2 (0. / .3 - .5)).rgb +\n                          texture (iChannel0, uv + blurDir * vec2 (3. / .3 - .5)).rgb);\n\n    float lumMin = min (lumC, min (min (lumTL, lumTR), min (lumBL, lumBR)));\n    float lumMax = max (lumC, max (max (lumTL, lumTR), max (lumBL, lumBR)));\n    float lumResult2 = dot (lum, result2);\n\n    if (lumResult2 > lumMax || lumResult2 < lumMin) {\n        fragColor = vec4 (result1, 1.);\n    } else {\n        fragColor = vec4 (result2, 1.);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Metaballs in \"ribbons\" - idea about some nested boolean ops\n//\n// Copyright 2018 Mirco M端ller\n//\n// Author(s):\n//   Mirco \"MacSlow\" M端ller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.14159265359;\nconst bool SHADOW = true;\nconst int MAX_ITER = 64;\nconst float EPSILON = .001;\n\nfloat saturate (in float v) { return clamp (v, .0, 1.); }\n\nfloat distriGGX (in vec3 N, in vec3 H, in float roughness) {\n    float a2     = roughness * roughness;\n    float NdotH  = max (dot (N, H), .0);\n    float NdotH2 = NdotH * NdotH;\n\n    float nom    = a2;\n    float denom  = (NdotH2 * (a2 - 1.) + 1.);\n    denom        = PI * denom * denom;\n\n    return nom / denom;\n}\n\nfloat geomSchlickGGX (in float NdotV, in float roughness) {\n    float nom   = NdotV;\n    float denom = NdotV * (1. - roughness) + roughness;\n\n    return nom / denom;\n}\n\nfloat geomSmith (in vec3 N, in vec3 V, in vec3 L, in float roughness) {\n    float NdotV = max (dot (N, V), .0);\n    float NdotL = max (dot (N, L), .0);\n    float ggx1 = geomSchlickGGX (NdotV, roughness);\n    float ggx2 = geomSchlickGGX (NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n\nvec3 fresnelSchlick (in float cosTheta, in vec3 F0, float roughness) {\n\treturn F0 + (max (F0, vec3(1. - roughness)) - F0) * pow (1. - cosTheta, 5.);\n}\n\nmat2 r2d (in float a) {\n\tfloat c = cos (radians (a));\n    float s = sin (radians (a));\n    return mat2 (vec2(c, s), vec2(-s, c));\n}\n\nfloat opRepeat1 (inout float p, in float size) {\n    float hsize = .5 * size;\n    float cell = floor ((p + hsize) / size);\n    p = mod (p + hsize, size) - hsize;\n    return cell;\n}\n\nvec2 opRepeat2 (inout vec2 p, in vec2 size) {\n    vec2 hsize = .5 * size;\n    vec2 cell = floor ((p + hsize) / size);\n    p = mod (p + hsize, size) - hsize;\n    return cell;\n}\n\nfloat opCombine (in float d1, in float d2, in float r) {\n    float h = saturate (.5 + .5 * (d2 - d1) / r);\n    return mix (d2, d1, h) - r * h * (1. - h);\n}\n\nfloat sdSphere (in vec3 p, in float r) {\n    return length (p) - r;\n}\n\nfloat vmax (in vec3 p) {\n    return max (p.x, max (p.y, max (p.z, .0)));\n}\n\nfloat udBox (in vec3 p, in vec3 size) {\n    return length (vmax (abs (p) - size));\n}\n\nfloat sdBox (in vec3 p, in vec3 size, in float r)\n{\n  vec3 d = abs(p) - size;\n  return min (max (d.x, max (d.y,d.z)), .0) + length (max (d, .0)) - r;\n}\n\nfloat metaballs (in vec3 p, in float factor) {\n    float r1 = factor * .1 + .3 * (.5 + .5 * sin (2. * iTime));\n    float r2 = factor * .15 + .2 * (.5 + .5 * sin (3. * iTime));\n    float r3 = factor * .2 + .2 * (.5 + .5 * sin (4. * iTime));\n    float r4 = factor * .25 + .1 * (.5 + .5 * sin (5. * iTime));\n\n    float t = 2. * iTime;\n    vec3 offset1 = vec3 (-.1*cos(t), .1, -.2*sin(t));\n    vec3 offset2 = vec3 (.2, .2*cos(t), .3*sin(t));\n    vec3 offset3 = vec3 (-.2*cos(t), -.2*sin(t), .3);\n    vec3 offset4 = vec3 (.1, -.4*cos(t), .4*sin(t));\n    vec3 offset5 = vec3 (.4*cos(t), -.2, .3*sin(t));\n    vec3 offset6 = vec3 (-.2*cos(t), -.4, -.4*sin(t));\n    vec3 offset7 = vec3 (.3*sin(t), -.6*cos(t), .6);\n    vec3 offset8 = vec3 (-.3, .5*sin(t), -.4*cos(t));\n\n    float ball1 = sdSphere (p + offset1, r4);\n    float ball2 = sdSphere (p + offset2, r2);\n\tfloat metaBalls = opCombine (ball1, ball2, r1);\n\n    ball1 = sdSphere (p + offset3, r1);\n    ball2 = sdSphere (p + offset4, r3);\n\tmetaBalls = opCombine (metaBalls, opCombine (ball1, ball2, .2), r2);\n\n    ball1 = sdSphere (p + offset5, r3);\n    ball2 = sdSphere (p + offset6, r2);\n\tmetaBalls = opCombine (metaBalls, opCombine (ball1, ball2, .2), r3);\n\n    ball1 = sdSphere (p + offset7, r3);\n    ball2 = sdSphere (p + offset8, r4);\n\tmetaBalls = opCombine (metaBalls, opCombine (ball1, ball2, .2), r4);\n\n    return metaBalls;\n}\n\nfloat map (in vec3 p) {\n    float metaBallsRibbons1 = metaballs (p, 1.05);\n    float metaBallsRibbons2 = metaballs (p, 0.95);\n    float metaBallsCore = metaballs (p, .4);\n    float metaBallsRibbons = max (-metaBallsRibbons2, metaBallsRibbons1);\n    vec3 boxCenter = p + iTime * vec3 (.0, .75, .0);\n    //boxCenter.zx *= r2d (4.*iTime);\n    opRepeat1 (boxCenter.y, .2);\n    float box = udBox (boxCenter, vec3(12., .0125, 12.));\n    metaBallsRibbons = max (metaBallsRibbons, box);\n    float metaBalls = min (metaBallsCore, metaBallsRibbons);\n\n    float room = sdBox (p, vec3 (150., 7., 150.), .0);\n\n    return min (metaBalls, -room);\n}\n\nfloat march (in vec3 ro, in vec3 rd) {\n    float t = .0;\n    float d = .0;\n    for (int i = 0; i < MAX_ITER; ++i) {\n        vec3 p = ro + d * rd;\n        t = map (p);\n        if (t < EPSILON) break;\n        d += t*.975;\n    }\n\n    return d;\n}\n\nvec3 normal (in vec3 p, in float epsilon) {\n\tfloat d = map (p);\n    vec3 e = vec3 (epsilon, .0, .0);\n    return normalize (vec3 (map (p + e.xyy) - d,\n                            map (p + e.yxy) - d,\n                            map (p + e.yyx) - d));\n}\n\nfloat shadow (in vec3 p, in vec3 lPos) {\n    float lDist = distance (p, lPos);\n    vec3 lDir = normalize (lPos - p);\n    float dist = march (p, lDir);\n    return dist < lDist ? .1 : 1.;\n}\n\nvec3 shade (in vec3 ro, in vec3 rd, in float d) {\n    vec3 p = ro + d * rd;\n    vec3 nor = normal (p, d*EPSILON);\n\n    // \"material\" hard-coded for the moment\n    float mask = .9;\n    vec3 albedo = mix (vec3 (.5), vec3 (.2), mask);\n    float metallic = .5;\n    float roughness = mix (.9, .1, mask);\n    float ao = 1.;\n\n    // lights hard-coded as well atm\n    vec3 lightColors[2];\n    lightColors[0] = vec3 (.7, .8, .9)*3.;\n    lightColors[1] = vec3 (.9, .8, .7)*6.;\n\n    vec3 lightPositions[2];\n    lightPositions[0] = vec3 (-1.5, 1.0, -3.);\n    lightPositions[1] = vec3 (2., -.5, 3.);\n\n\tvec3 N = normalize (nor);\n    vec3 V = normalize (ro - p);\n\n    vec3 F0 = vec3 (0.04); \n    F0 = mix (F0, albedo, metallic);\n    vec3 kD = vec3(.0);\n\t           \n    // reflectance equation\n    vec3 Lo = vec3 (.0);\n    for(int i = 0; i < 2; ++i) \n    {\n        // calculate per-light radiance\n        vec3 L = normalize(lightPositions[i] - p);\n        vec3 H = normalize(V + L);\n        float distance    = length(lightPositions[i] - p);\n        float attenuation = 20. / (distance * distance);\n        vec3 radiance     = lightColors[i] * attenuation;\n        \n        // cook-torrance brdf\n        float aDirect = pow (roughness + 1., 2.);\n        float aIBL =  roughness * roughness;\n        float NDF = distriGGX(N, H, roughness);        \n        float G   = geomSmith(N, V, L, roughness);      \n        vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0, roughness);       \n        \n        vec3 kS = F;\n        kD = vec3(1.) - kS;\n        kD *= 1. - metallic;\t  \n        \n        vec3 nominator    = NDF * G * F;\n        float denominator = 4. * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n        vec3 specular     = nominator / max(denominator, .001);  \n\n        // add to outgoing radiance Lo\n        float NdotL = max(dot(N, L), 0.0);                \n        Lo += (kD * albedo / PI + specular) * radiance * NdotL;\n        if (SHADOW) {\n\t    \tLo *= shadow (p+.01*N, L);\n        }\n    }\n\n    vec3 irradiance = texture (iChannel0, N).rgb;\n    vec3 diffuse    = irradiance * albedo;\n    vec3 ambient    = (kD * diffuse) * ao;\n\n    return 3.*ambient + Lo;\n}\n\nvec3 camera (in vec2 uv, in vec3 ro, in vec3 aim, in float zoom) {\n    vec3 camForward = normalize (vec3 (aim - ro));\n    vec3 worldUp = vec3 (.0, 1., .0);\n    worldUp.xy *= r2d (35.*sin (.5+iTime));\n    vec3 camRight = normalize (cross (worldUp, camForward));\n    vec3 camUp = normalize (cross (camForward, camRight));\n    vec3 camCenter = ro + camForward * zoom;\n    \n    return normalize (camCenter + uv.x * camRight + uv.y * camUp - ro);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uvRaw = uv;\n    uv = uv *2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // set up \"camera\", view origin (ro) and view direction (rd)\n    float angle = radians (300. + 55. * iTime);\n    float dist = 2.75 + cos (1.5*(iTime + 2.));\n    vec3 ro = vec3 (dist * cos (angle), cos (iTime), dist * sin (angle));\n    vec3 aim = vec3 (.0);\n    float zoom = 2.;\n\n    vec3 rd = camera (uv, ro, aim, zoom);\n    float d = march (ro, rd);\n    vec3 n = normal (ro + d * rd, d*EPSILON);\n    vec3 col = shade (ro, rd, d);\n\n    col = mix (col, vec3 (.2, .6, .4), pow (1. - 1. / d, 7.));\n\tcol = .3 * col + .7 * sqrt (col);\n    col *= 1.25*vec3 (.9, .8, .7);\n    col *= .3 + .7 * pow (16. * uvRaw.x * uvRaw.y * (1. - uvRaw.x) * (1. - uvRaw.y), .2);\n\n\tfragColor = vec4 (col, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}