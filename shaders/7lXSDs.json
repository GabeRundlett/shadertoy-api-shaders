{
    "Shader": {
        "info": {
            "date": "1626903750",
            "description": "test to load big voxels models thanks to custom textures\nsee explanation of how to make it work in the top of the shader",
            "flags": 32,
            "hasliked": 0,
            "id": "7lXSDs",
            "likes": 13,
            "name": "Bigger voxel models",
            "published": 3,
            "tags": [
                "models",
                "voxel",
                "scene",
                "octree",
                "customtextures"
            ],
            "usePreview": 1,
            "username": "mdb",
            "viewed": 453
        },
        "renderpass": [
            {
                "code": "/*\n\nshader by mdb\nLoad custom model of a lot of voxel,\ninspired by https://www.shadertoy.com/view/lsGGDd for loading the textures\n\n------------------------------------------------------------------------------\n- How to load a model ? ------------------------------------------------------\n\n=> Open the javascript console of your browser:\n               Mac      /     Windows\n  Chrome:  cmd + opt + J  /  ctrl + shift J\n  Firefox: cmd + opt + K  /  ctrl + shift K\n  IE:          na         /  F12   \n\n=> Then copy the following line in the console\n\n  gShaderToy.SetTexture(0, {mSrc:'https://dl.dropboxusercontent.com/s/e5k9k7ph4pyhg6c/pirateShop.png?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'nearest', wrap: 'repeat', vflip:'false', srgb:'false', internal:'byte' }});\n\n=> hit return to execute\n\nDone !!\n\n-----------------------------------------------------------------------------\n- list of models ------------------------------------------------------------\n(other lines to enter in the console as before)\n1:\"painterly cottage\" from https://sketchfab.com/3d-models/painterly-cottage-0772aec70d584c60a27000af5f6c1ef4\n\n  gShaderToy.SetTexture(0, {mSrc:'https://dl.dropboxusercontent.com/s/gbzyos7j1opgoda/homeTree.png?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'nearest', wrap: 'repeat', vflip:'false', srgb:'false', internal:'byte' }});\n\n2:\"Shipwrecked Chinese Supply Store\" from https://sketchfab.com/3d-models/dae-villages-shipwrecked-chinese-supply-store-af2da248227c4dac96fc2570e58e26da\n\n  gShaderToy.SetTexture(0, {mSrc:'https://dl.dropboxusercontent.com/s/e5k9k7ph4pyhg6c/pirateShop.png?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'nearest', wrap: 'repeat', vflip:'false', srgb:'false', internal:'byte' }});\n\n3:\"minecraft cathedral\" from https://sketchfab.com/3d-models/cathedral-faed84a829114e378be255414a7826ca\n\n  gShaderToy.SetTexture(0, {mSrc:'https://dl.dropboxusercontent.com/s/qye7wo2wmsyjhb1/cathedral.png?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'nearest', wrap: 'repeat', vflip:'false', srgb:'false', internal:'byte' }});\n \n4:\"birds\" from https://sketchfab.com/3d-models/lekking-ruffs-f5e8e5a459a14e2fb46f7d79f6ca7edc\n  \n  gShaderToy.SetTexture(0, {mSrc:'https://dl.dropboxusercontent.com/s/muw5khk9ukepkfw/birds.png?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'nearest', wrap: 'repeat', vflip:'false', srgb:'false', internal:'byte' }});\n \n5:\"landscape of nevada (detailed)\" from https://sketchfab.com/3d-models/cathedral-gorge-state-park-nevada-672f50581e2e441ab2cf0ad92b23ebc1\n\n gShaderToy.SetTexture(0, {mSrc:'https://dl.dropboxusercontent.com/s/p3ov2isdk862i98/landscape.png?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'nearest', wrap: 'repeat', vflip:'false', srgb:'false', internal:'byte' }});\n \n6:\"monster garden\" from https://sketchfab.com/3d-models/monstergarden-9397658152d243ab9f22c619fad0293e\n\n gShaderToy.SetTexture(0, {mSrc:'https://dl.dropboxusercontent.com/s/dz48pbe8421yuc4/monsterGarden.png?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'nearest', wrap: 'repeat', vflip:'false', srgb:'false', internal:'byte' }});\n\n7:\"cob over a light\" from sketchfab (i lost the origin)\n    \n gShaderToy.SetTexture(0, {mSrc:'https://dl.dropboxusercontent.com/s/mdaljwicod0c0r2/cob.png?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'nearest', wrap: 'repeat', vflip:'false', srgb:'false', internal:'byte' }});\n\n-----------------------------------------------------------------------------\n- How the data is stored:  --------------------------------------------------\nthe data is stored in a texture as an octree\n\nthe tree is stored as:\nNode:\n    8 pixels for each child\n    \n    and for each pixel (rgba, 4 uint8):\n        if pixel.a = 0:\n            it is a child !\n            the index of the child is:\n                idx = pixel.r + (pixel.g << 8) + (pixel.b << 16)\n         \n         if pixel.a = 1:\n             it is an empty leaf\n         \n         if pixel.a = 2:\n             it is a leaf\n             the leaf color is pixel.rgb\n\n\nif you want to see the octree, you can uncomment showTree on line 81\n\n*/\n\n//#define showTree\n\n#define maxDepth 12\n\nvec3 treeUp = vec3(2.0);\nvec3 treeDown = vec3(-2.0);\n\nvec3 col = vec3(0.0);\n#define OUT -200.0\n\nuvec4 treeTex(uint idx){\n    uint w = uint(iChannelResolution[0].x);\n    vec4 data = texelFetch(iChannel0, ivec2(idx % w, idx / w), 0); \n    return uvec4(data * 255.0);\n}\n\nfloat rand(vec3 p){\n    uint idx = uint(p.x) + uint(p.y)*64u + uint(p.z)*64u*64u;\n    idx ^= 3646844786u;\n    idx *= 474746u;\n    idx >>= 16;\n    idx *= 563563u;\n    idx >> 13;\n    idx *= 454749u;\n    return float(idx)/4294967295.0;\n}\n\n//tree traversal stuff\n\nuint a;\nuint find_firstNode(vec3 t0, vec3 tM){\n    uint first = 0u;\n    if(t0.x > t0.y && t0.x > t0.z){ // entry YZ\n        if(tM.y < t0.x) first |= 2u;\n        if(tM.z < t0.x) first |= 1u;\n    }else if(t0.y > t0.z){ // entry XZ\n        if(tM.x < t0.y) first |= 4u;\n        if(tM.z < t0.y) first |= 1u;\n    }else{  // entry XY\n        if(tM.x < t0.z) first |= 4u;\n        if(tM.y < t0.z) first |= 2u; \n    }\n    return first;\n}\n\nuint next_Node(vec3 t1, uint yz, uint xz,uint xy){\n    if(t1.x < t1.y && t1.x < t1.z){\n        return yz;\n    }else if(t1.y < t1.z){\n        return xz;\n    }else{\n        return xy;\n    }\n}\n\nvec4 procTree( vec3 t0, vec3 t1, out vec3 normal)\n{   \n    //init variables\n    vec3 color;\n    int actualDepth = 0;\n    uint nodeIdx[maxDepth];\n    uint childIdx[maxDepth];\n    vec3 t0s[maxDepth];\n    vec3 t1s[maxDepth];\n    t0s[actualDepth] = t0;\n    t1s[actualDepth] = t1;\n    const int END = 8;\n    const uvec3[] nextNode = uvec3[](uvec3( 4 , 2 , 1 ),\n                                     uvec3( 5 , 3 ,END),\n                                     uvec3( 6 ,END, 3 ),\n                                     uvec3( 7 ,END,END),\n                                     uvec3(END, 6 , 5 ),\n                                     uvec3(END, 7 ,END),\n                                     uvec3(END,END, 7 ),\n                                     uvec3(END,END,END));\n    \n    vec3 tM = 0.5 * (t0 + t1);\n    childIdx[actualDepth] = find_firstNode(t0, tM);\n    nodeIdx[actualDepth] = 0u;\n    uvec4 dataComp = treeTex(nodeIdx[actualDepth] + a ^ childIdx[actualDepth]);\n    nodeIdx[actualDepth + 1] = dataComp.x + (dataComp.y << 8) + (dataComp.z << 16);\n    \n    // start loop\n    for(int i = 0; i < 600; i ++){\n        if (actualDepth < 0)return vec4(OUT);//visited all nodes\n        \n        uint currNode =  childIdx[actualDepth];\n        dataComp = treeTex(nodeIdx[actualDepth] + a ^ childIdx[actualDepth]);\n        t1 = t1s[actualDepth];\n        if(t1.x <= 0.0 || t1.y <= 0.0 || t1.z <= 0.0) dataComp = uvec4(0, 0, 0, 1); \n        bool leaf = (dataComp.w != 0u);\n        bool back = (currNode == 8u);\n        \n        if (leaf || back){\n            if(back){actualDepth -= 1; currNode = childIdx[actualDepth];}\n            t0 = t0s[actualDepth];\n            t1 = t1s[actualDepth];\n            tM = 0.5 * (t0 + t1);\n            vec3 dt = t1 - t0;\n            vec3 idx = vec3(float(currNode&4u)/4.0, float(currNode&2u)/2.0, float(currNode&1u));\n            vec3 t0_ = t0 + 0.5*dt*idx;\n            vec3 t1_ = t0 + 0.5*dt*(1.0 + idx);\n            vec3 tM_ = 0.5*(t0_ + t1_);\n            \n            if (leaf && !back && (dataComp.w == 2u)){//the node is a full leaf\n                t0 = t0_;\n                color = vec3(dataComp.xyz)/255.0;\n                \n                if(t0.x > t0.y && t0.x > t0.z){ // entry YZ\n                    normal = vec3(1.0, 0.0, 0.0);\n                    return vec4(color, t0.x);\n                }\n                if(t0.y > t0.z){ // entry XZ\n                    normal = vec3(0.0, 1.0, 0.0);\n                    return vec4(color, t0.y);\n                }\n                // entry XY\n                normal = vec3(0.0, 0.0, 1.0);\n                return vec4(color, t0.z);\n                       \n                \n            }\n            #ifdef showTree   \n                col -= 0.011;\n            #endif\n            \n            uvec3 next = nextNode[currNode];\n                             \n            childIdx[actualDepth] = next_Node(t1_, next.x, next.y, next.z);\n            dataComp = treeTex(nodeIdx[actualDepth] + a ^ childIdx[actualDepth]);\n            nodeIdx[actualDepth + 1] = dataComp.x + (dataComp.y << 8) + (dataComp.z << 16);\n        \n        } else {\n            t0 = t0s[actualDepth];\n            t1 = t1s[actualDepth];\n            actualDepth += 1;\n           \n            tM = 0.5 * (t0 + t1);\n\n            vec3 dt = t1 - t0;\n            vec3 idx = vec3(float(currNode&4u)/4.0, float(currNode&2u)/2.0, float(currNode&1u));\n            vec3 t0_ = t0 + 0.5*dt*idx;\n            vec3 t1_ = t0 + 0.5*dt*(1.0 + idx);\n            vec3 tM_ = 0.5*(t0_ + t1_);\n            childIdx[actualDepth] = find_firstNode(t0_, tM_);\n            \n            dataComp = treeTex(nodeIdx[actualDepth] + a ^ childIdx[actualDepth]);\n            nodeIdx[actualDepth + 1] = dataComp.x + (dataComp.y << 8) + (dataComp.z << 16);\n        \n            t0s[actualDepth] = t0_;\n            t1s[actualDepth] = t1_;\n        }\n        \n    }\n    return vec4(OUT);\n}\n\n\n\nvec4 ray_step(vec3 ro, vec3 rd, out vec3 normal){\n    a = 0u;\n    vec3 flip = -sign(rd);\n    vec3 size = (treeUp + treeDown)*0.5;\n    \n    if (rd.x < 0.0){\n        ro.x = size.x - ro.x;\n        rd.x = -rd.x;\n        a |= 4u;\n    }\n    if (rd.y < 0.0){\n        ro.y = size.y - ro.y;\n        rd.y = -rd.y;\n        a |= 2u;\n    }\n    if (rd.z < 0.0){\n        ro.z = size.z - ro.z;\n        rd.z = -(rd.z);\n        a |= 1u;\n    }\n    \n    vec3 invDir = 1.0/rd;\n    vec3 t0 = (treeDown - ro) * invDir;\n    vec3 t1 = (treeUp - ro) * invDir;\n\n    float tmin = max(max(t0.x, t0.y), t0.z);\n    float tmax = min(min(t1.x, t1.y), t1.z);\n    if ((tmin < tmax) && (tmax > 0.0f)){\n        vec4 res = procTree(t0, t1, normal);\n        normal *= flip;\n        return res;\n    }else{ //doesn't intersect\n        return vec4(OUT);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //test if any model is loaded\n    if(iChannelResolution[0].x == iResolution.x &&\n       iChannelResolution[0].y == iResolution.y){\n        fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n        return;\n    }\n    vec2 uv = fragCoord/iResolution.xy*2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 0.3; // small FOV\n    \n    vec3 camPos = vec3(-3.0*cos(iTime*0.5), 0.1 + 0.6*sin(iTime*0.7*0.5), -3.0*sin(iTime*0.5))*1.9;\n    vec3 target = vec3(0.0);\n    \n    vec3 dir0 = normalize(target - camPos);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(up, dir0));\n         up = cross(dir0, right);\n    \n    vec3 rd = normalize(right * uv.x + up * uv.y + dir0);\n    \n    //back ground\n    vec3 col2 = vec3(0.082,0.086,0.137);\n    \n    //intersect object\n    vec3 normal;\n    vec4 res = ray_step(camPos, rd, normal);\n    if (res.w != OUT){\n        col2 = res.rgb;  \n    }\n    \n    uv = fragCoord/iResolution.xy;\n    \n    // color stuff \n    //col2 = col2*col2*(3.0-2.0*col2);\n    col2 *= 0.8 + 0.2*pow(16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.4 );\n    \n    fragColor = vec4(col + col2,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//just contain the warning if the model is not loaded (see the main shader)\n//and also the python script for generating the imageTexture with the octree data\n//to imorte an object file to voxels\n\n// say \"action needed\"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n    uv -= vec2(0.08, 0.12);\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    ivec2 idx = ivec2(floor(uv*7.0));\n    vec2 uv2 = vec2(0.25, 0.1) + vec2(0.5, 0.8)*fract(uv*7.0);\n    if(idx.y == 0){\n        if(idx.x == 0)col.r = texture(iChannel0, (vec2(14, 9) + uv2)/16.0).r;\n        if(idx.x == 1)col.r = texture(iChannel0, (vec2( 5, 9) + uv2)/16.0).r;\n        if(idx.x == 2)col.r = texture(iChannel0, (vec2( 5, 9) + uv2)/16.0).r;\n        if(idx.x == 3)col.r = texture(iChannel0, (vec2( 4, 9) + uv2)/16.0).r;\n        if(idx.x == 4)col.r = texture(iChannel0, (vec2( 5, 9) + uv2)/16.0).r;\n        if(idx.x == 5)col.r = texture(iChannel0, (vec2( 4, 9) + uv2)/16.0).r;\n    }\n    if(idx.y == 1){\n        if(idx.x == 0)col.r = texture(iChannel0, (vec2( 1, 9) + uv2)/16.0).r;\n        if(idx.x == 1)col.r = texture(iChannel0, (vec2( 3, 9) + uv2)/16.0).r;\n        if(idx.x == 2)col.r = texture(iChannel0, (vec2( 4, 8) + uv2)/16.0).r;\n        if(idx.x == 3)col.r = texture(iChannel0, (vec2( 9, 9) + uv2)/16.0).r;\n        if(idx.x == 4)col.r = texture(iChannel0, (vec2(15, 9) + uv2)/16.0).r;\n        if(idx.x == 5)col.r = texture(iChannel0, (vec2(14, 9) + uv2)/16.0).r;\n    }\n    //col = texture(iChannel0, uv).rrr;\n    fragColor = vec4(col, 1.0); \n}\n/*\nthis is the bython script that allows me to create a voxel model from a polygon model\nthis script is not the best but it works\n\nto make it work for yourself there is some conditions\nyou must fill all the data in the begining of the script\nthe input model:\n    - is an obj\n    - all color is from a single texture\n    - texture alpha will be ignored (avoid transparent texture)\n    - no materials\n\nto create a texture that contains all the colors from a model with multiples\ntextures and also lighting information, I recomend baking the all model\nto a texture in blender and then use this texture as the texture for the model\n\nto use the output image of the model in shadertoy, follow this shader that explain how\nto import custom textures: https://www.shadertoy.com/view/lsGGDd\n\n//python script/////////////////////////////////////////////////////////////\n\n# info for model\nmodelPath = ''  # '.obj' needed\ntexturePath = ''\noutputName = ''  # '.png'\ntreeDepth = 8\n\n# save voxels data in a 8 bits RGBA texture\nfrom PIL import Image\nimport numpy as np\n\nclass Poly:\n    def __init__(self, vertex, uvs):\n        self.vertex = vertex\n        self.uvs = uvs\n\n\ndef split(polys: list, mid, axis=0):\n    up = []\n    down = []\n    for poly in polys:\n        vertex = np.array(poly.vertex)\n        uv = poly.uvs.copy()\n        idxUp = vertex[:, axis] > mid\n        idxDown = vertex[:, axis] < mid\n        idxOn = vertex[:, axis] == mid\n        if np.all(idxUp | idxOn):  # all on one side\n            up += [poly]\n\n        elif np.all(idxDown | idxOn):  # all on the other side\n            down += [poly]\n\n        elif np.all(~ idxOn):\n            idxUp2 = []\n            idxDown2 = []\n            idxOn2 = []\n            vertex2 = []\n            uv2 = []\n            for i in range(len(poly.vertex)):\n                idxUp2 += [idxUp[i]]\n                idxDown2 += [idxDown[i]]\n                idxOn2 += [idxOn[i]]\n                vertex2 += [vertex[i]]\n                uv2 += [uv[i]]\n                if idxUp[i] != idxUp[(i + 1) % len(vertex)]:\n                    if not (idxOn[i] or idxOn[(i + 1) % len(vertex)]):\n                        A = vertex[i]\n                        B = vertex[(i + 1) % len(vertex)]\n                        x = (mid - A[axis]) / (A[axis] - B[axis])\n                        v2 = A + (A - B) * x\n                        vt2 = uv[i] + (uv[i] - uv[(i + 1) % len(vertex)]) * x\n                        vertex2 += [v2]\n                        uv2 += [vt2]\n                        idxUp2 += [False]\n                        idxDown2 += [False]\n                        idxOn2 += [True]\n\n            on = np.array(idxOn2, bool)\n            vertex2 = np.array(vertex2)\n            uv2 = np.array(uv2)\n            up += [Poly(vertex2[idxUp2 | on], uv2[idxUp2 | on])]\n            down += [Poly(vertex2[idxDown2 | on], uv2[idxDown2 | on])]\n\n    return [down, up]\n\n\nclass Node:\n    maxDepth = treeDepth\n    Tree = []\n\n    def __init__(self, depth=0):\n        self.depth = depth\n        self.child = None\n        self.colors = []\n        self.up = np.array([1, 1, 1], float)\n        self.down = np.array([-1, -1, -1], float)\n\n    def initChild(self):\n        dxyz = self.up - self.down\n        child = []\n        for x in range(2):\n            for y in range(2):\n                for z in range(2):\n                    c = Node(self.depth + 1)\n                    c.down = self.down + np.array([x, y, z]) * dxyz / 2\n                    c.up = self.down + dxyz / 2 + np.array([x, y, z]) * dxyz / 2\n                    child += [c]\n        return child\n\n    def append(self, poly):\n        if self.depth == Node.maxDepth:\n            center = np.mean(poly.uvs, axis=0)\n            center = np.array([center[0], 1.0 - center[1]])\n            coord = np.array(center * texture.size, int)\n            coord = np.minimum(coord + 1, texture.size) - 1\n            data = texture.getpixel((coord[0], coord[1]))\n            self.colors += [data[:3]]\n            return\n\n        if self.child is None:\n            self.child = self.initChild()\n\n        polys = [[poly]]\n        # cut triangle in 8\n        for axis in range(3):\n            new = []\n            mid = (self.up[axis] + self.down[axis]) / 2\n            for i in range(2 ** axis):\n                new += split(polys[i], mid, axis=axis)\n            polys = new\n\n        for i in range(8):\n            for poly in polys[i]:\n                self.child[i].append(poly)\n\n    def treeDepth(self):\n        if self.child is None:\n            return self.depth\n        return max(c.treeDepth() for c in self.child)\n\n    def importObj(self, objfile):\n        vertex = []\n        vMin = np.zeros(3, float)\n        vMax = np.zeros(3, float)\n        uvs = []\n        faceCount = 0\n        with open(objfile, 'r') as f:  # get all vertex and texture info\n            for line in f:\n                line = line.replace('\\n', '')\n                if line:\n                    line = line.replace('  ', ' ')\n                    data = line.split(' ')\n                    if data[0] == 'v':\n                        v = np.array([float(data[1]), float(data[2]), float(data[3])])\n                        vMax = np.maximum(vMax, v)\n                        vMin = np.minimum(vMin, v)\n                        vertex += [v]\n                    if data[0] == 'vt':\n                        uvs += [np.array([float(data[1]), float(data[2])])]\n                    if data[0] == 'f':\n                        faceCount += 1\n        # find vMin and vMax of the cube AABB\n        vMid = 0.5 * (vMin + vMax)\n        side = np.max(vMax - vMin)\n\n        with open(objfile, 'r') as f:  # append all the faces\n            i = 0\n            for line in f:\n                line = line.replace('  ', ' ')\n                line = line.replace(' \\n', '')\n                line = line.replace('\\n', '')\n                if line:\n                    data = line.split(' ')\n                    if data[0] == 'f':\n                        i += 1\n                        print('\\rinsert ' + str(i) + ' / ' + str(faceCount), end='')\n                        v = []\n                        uv = []\n                        for idx in data[1:]:\n                            v += [(vertex[int(idx.split('/')[0]) - 1] - vMid)/side * 2.0]\n                            uv += [uvs[int(idx.split('/')[1]) - 1]]\n                        p = Poly(v, uv)\n                        self.append(p)\n\n        print()\n\n    def fillData(self):\n        if self.child is not None:\n            currentIdx = len(Node.Tree)\n            Node.Tree += [[], [], [], [], [], [], [], []]\n            for i, c in enumerate(self.child):\n                if c.child is not None:\n                    l = len(Node.Tree)\n                    Node.Tree[currentIdx + i] = [l & 255,\n                                                 (l >> 8) & 255,\n                                                 (l >> 16) & 255,\n                                                 0]\n                else:  # it's a leaf !\n                    if len(c.colors) == 0:  # empty leaf\n                        Node.Tree[currentIdx + i] = [0, 0, 0, 1]\n                    else:\n                        col = np.zeros(3, float)\n                        for co in c.colors:\n                            col += co\n                        col /= len(c.colors)\n                        col = np.array(col, int)\n\n                        Node.Tree[currentIdx + i] = [*col, 2]\n                c.fillData()\n            return\n\n    def createArray(self):\n        Node.Tree = []\n        self.fillData()\n\n        w = int(np.ceil(np.sqrt(len(Node.Tree))))\n        out = Node.Tree.copy()\n        out += [[0, 0, 0, 0]] * (w*w - len(Node.Tree))\n        out = np.array(out, np.uint8)\n        out = out.reshape((w, w, 4))\n\n        im = Image.fromarray(out)\n        im.save(\"outputName\")\n\n\n# textures\ntexture = Image.open(\"texturePath\")\n\nTree = Node()\nTree.importObj('objectPath')\nTree.createArray()\nprint(f\"{len(Node.Tree) = }\")\n\n*/",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}