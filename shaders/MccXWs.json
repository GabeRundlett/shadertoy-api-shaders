{
    "Shader": {
        "info": {
            "date": "1714605001",
            "description": "Use the mouse to look around :)",
            "flags": 0,
            "hasliked": 0,
            "id": "MccXWs",
            "likes": 10,
            "name": "Sliced Watermelon",
            "published": 3,
            "tags": [
                "3d",
                "ray",
                "raymarch",
                "rays",
                "marching",
                "march",
                "watermelon"
            ],
            "usePreview": 1,
            "username": "ianertson",
            "viewed": 149
        },
        "renderpass": [
            {
                "code": "#define R iResolution\n#define T (iTime)\n#define M_PI 3.1415\n#define TAU (M_PI * 2.0)\n#define ZERO min(iFrame, 0)\n\n#define STEPS 90\n#define FAR 60.0\n#define NEAR 0.003\n\n#define AMBIENT 0.25\n\n#define rgb(X, Y, Z) vec3(float(X) / 255.0, float(Y) / 255.0, float(Z) / 255.0)\n\nmat2 rot(float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\nfloat smin(float a, float b, float k) {float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0); return mix(a, b, h) - k*h*(1.0-h); }\nfloat smax(float a, float b, float k) {return smin(a, b, -k); }\nfloat sgt(in float a, in float b, in float s) {float h = clamp(0.5 + 0.5 * (a - b) / s, 0.0, 1.0); return mix(0.0, 1.0, h*h*(3.0-2.0*h));}\nfloat slt(in float a, in float b, in float s) {float h = clamp(0.5 + 0.5 * (b - a) / s, 0.0, 1.0); return mix(0.0, 1.0, h*h*(3.0-2.0*h));}\nvec3 aces(vec3 x) { return clamp((x*(2.51*x+0.03))/(x*(2.43*x+0.59)+0.14),0.0,1.0); }\n\nvec3 thash(vec2 p, float seed) {\n    return textureLod(iChannel0, ((p  + seed) / 256.0), 0.0).xyz;\n}\n\nvec3 tnoise(vec2 p, float s) {\n  p += 3.3828714;\n  vec2 id = floor(p); vec2 lv = fract(p);lv = lv*lv*(3.0-2.0*lv);\n  return mix(mix(thash(id+vec2(0,0),s),thash(id+vec2(1,0),s),lv.x),\n             mix(thash(id+vec2(0,1),s),thash(id+vec2(1,1),s),lv.x),lv.y);\n}\n\nvec3 tnoise(vec2 p, float s, float freq, float warp, const in int oct) {\n  vec3 n = vec3(0.0);\n  float div = 0.0;\n  float amp = 1.0;\n  vec2 tx = vec2(0.0);\n  for (int i = ZERO; i < oct; i++) {\n    n += amp*tnoise((p+tx)*freq,s);\n    div += amp;\n    amp *= 0.5;\n    freq *= 2.0;\n    tx += warp * vec2(sin(n.x*6.28), cos(n.y*6.28));\n\n  }\n  return n / div;\n}\n\nstruct Data {\n    vec3 p;\n    vec3 n;\n    float d;\n    int id;\n};\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), FAR, -1)\n\nstruct Light {\n    vec3 p;\n    vec3 c;\n    float s;\n};\n\nvec3 getLightDir(Light light, vec3 p) {\n    return normalize(light.p - p);\n}\n\nvec3 getLightAtt(Light light, vec3 p, vec3 N) {\n    vec3 L = getLightDir(light, p);\n    float NdotL = max(AMBIENT, dot(N, L));\n    float dist = distance(light.p, p);\n    return (light.c * light.s * NdotL) / max(0.0001, dist * dist);\n}\n\n#define ID_MELON 1\n#define ID_GROUND 2\n#define ID_MELON_SLICE 3\n\n#define SAMPLE(DIST, ID) { if (DIST < dist) { id = ID; dist = DIST; } }\n\nfloat melonSDF(vec3 p, float r) {\n    float d = length(p * vec3(1.109, 1, 1.109)) - r;\n    return d / 1.3;\n}\n\nfloat melonSliceSDF(vec3 p, float r) {\n    float d = length(p) - r;\n    vec3 dir = vec3(0, 1, 0);\n    dir = mix(dir, vec3(1.0, 0, 0), smoothstep(0.05, 0.15, p.x));\n    dir = mix(dir, vec3(-1.0, 0, 0), smoothstep(0.05, 0.15, -p.x));\n    d = smax(d, dot(p, (dir)), 0.1);\n    d *= 0.333333333;\n    return d;\n}\n\nfloat groundSDF(vec3 p) {\n    return p.y+1.0;\n}\n\nfloat sdf(vec3 p, inout Data data) {\n    float dist = FAR;\n    int id = -1;\n    \n    float melon = melonSDF(p, 1.0);\n    SAMPLE(melon, ID_MELON);\n    \n    float melonSlice = melonSliceSDF(p - vec3(1.5, -0.4, 0), 0.6);\n    SAMPLE(melonSlice, ID_MELON_SLICE);\n    \n    float ground = groundSDF(p);\n    SAMPLE(ground, ID_GROUND);\n    \n    data.id = id;\n    \n    return dist;\n}\n\nbool march(vec3 ro, vec3 rd, inout Data data) {\n    float d = 0.0;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(p, data);\n        if (abs(next) <= NEAR) break;\n        if (abs(next) >= FAR) return false;\n        d += next;\n    }\n    \n    vec3 p = ro+rd*d;\n    vec2 e = vec2(NEAR, 0.0);\n    vec3 n = normalize(sdf(p, data) - vec3(\n        sdf(p - e.xyy, data),\n        sdf(p - e.yxy, data),\n        sdf(p - e.yyx, data)\n    ));\n    \n    data.p = p;\n    data.n = n;\n    data.d = d;\n    \n    return true;\n}\n\nfloat getShadow(Light light, vec3 ro, vec3 n) {\n    vec3 L = getLightDir(light, ro);\n    float NdotL = dot(n, L);\n    if (NdotL <= 0.00003) return AMBIENT;\n    vec3 rd = L;\n    \n    vec3 offset = thash((ro.xz * 14.9323 + 8.0*ro.y)*16., 4.49128);\n    \n    Data data = NEW_DATA;\n    \n    float d = NEAR*3.0 + (offset.x*0.06);\n    float s = 0.0;\n    \n    for (int i = ZERO; i < 24; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(p, data);\n        float acc = clamp(next, 0.005, 0.5);\n        \n        s += next;\n        d += acc;\n    }\n    d = abs(d);\n    d = (d / (1.0 + d));\n    return clamp(d, AMBIENT, 1.0);\n}\n\nvec3 forEachLight(Light light, vec3 ro, vec3 rd, vec3 diffuse, inout Data data) {\n    vec3 N = data.n;\n    vec3 p = data.p;\n    vec3 L = getLightDir(light, p);\n    vec3 att = getLightAtt(light, p, N);\n    vec3 ref = reflect(N, L);\n    float VdotR = max(0.0, dot(rd, ref));\n    float spec = pow(VdotR, 32.0);\n    float shadow = getShadow(light, p, N);\n    return (diffuse + spec) * att * shadow;\n}\n\nvec3 getAlbedoMelon(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec3 col = vec3(0.0);\n    vec3 dark1 = rgb(104, 152, 27);\n    vec3 dark2 = rgb(121, 162, 0);\n    vec3 bright1 = rgb(207, 215, 145);\n    vec3 bright2 = rgb(162, 192, 21);\n    float u = acos(p.y);\n    float v = atan(p.x, p.z);    \n    u = 0.5 - u / M_PI;\n    v = 0.5 + v / M_PI;\n    vec2 uv = vec2(v,u);\n    \n    vec2 lv = fract(uv*8.0);\n    vec2 id = floor(uv*8.0);\n    \n    vec2 alv = abs(lv*2.0-1.0);\n    \n    vec3 xf = tnoise(uv, 4.49482, 32.0, 0.05, 3);\n    \n    \n    float d = smoothstep(0.9, xf.x*0.25, alv.x);\n    float b = clamp(1.0-(d * (1.0 + xf.y)), 0.0, 1.0);\n    \n    \n    vec3 mf = tnoise(uv, 0.3123, 9.0, 0.1, 3);\n    vec3 hf = tnoise(uv, 2.2381, 16.0, 0.1, 3);\n    \n    vec3 darkColor = mix(dark1, dark2, mf.x);\n    vec3 brightColor = mix(bright1, bright2, hf.x);\n    \n    col = mix(col, darkColor, d);\n    col = mix(col, brightColor, b);\n    \n    \n    \n    return col;\n}\n\nvec3 getAlbedoMelonSlice(inout Data data) {\n    vec3 p = data.p - vec3(1.5, 0, 0);\n    vec3 n = data.n;\n    vec3 col = vec3(0.0);\n    vec3 dark1 = rgb(104, 152, 27);\n    vec3 dark2 = rgb(121, 162, 0);\n    vec3 bright1 = rgb(207, 215, 145);\n    vec3 bright2 = rgb(162, 192, 21);\n    float u = acos(p.y);\n    float v = atan(p.x, p.z);    \n    u = 0.5 - u / M_PI;\n    v = 0.5 + v / M_PI;\n    vec2 uv = vec2(v,u);\n    \n    vec2 lv = fract(uv*8.0);\n    vec2 id = floor(uv*8.0);\n    \n    vec2 alv = abs(lv*2.0-1.0);\n    \n    vec3 xf = tnoise(uv, 4.49482, 32.0, 0.05, 3);\n    \n    \n    float d = smoothstep(0.9, xf.x*0.25, alv.y);\n    float b = clamp(1.0-(d * (1.0 + xf.y)), 0.0, 1.0);\n    \n    \n    float side = max(max(abs(dot(n, vec3(1, 0, 0))),\n                 sgt(length(p.x), 0.1, 0.01)), sgt(p.y, -0.41, 0.01));\n    \n    \n    vec3 mf = tnoise(uv, 0.3123, 9.0, 0.1, 3);\n    vec3 hf = tnoise(uv, 2.2381, 16.0, 0.1, 3);\n    \n    vec3 darkColor = mix(dark1, dark2, mf.x);\n    vec3 brightColor = mix(bright1, bright2, hf.x);\n    \n    col = mix(col, darkColor, d);\n    col = mix(col, brightColor, b);\n    \n    col = mix(col, vec3(1, 0, 0), side);\n    \n    \n    vec2 kp = fract(p.zy*8.0);\n    vec2 idk = floor(p.zy*8.0);\n    vec3 rr1 = thash(idk*2., 3.32132);\n    \n    if (rr1.y > 0.5) {\n      vec2 akp = abs(kp*2.0-1.0);\n      float ra = mix(0.25, 0.15, rr1.x);\n      float fe = ra*0.25;\n      float dt = smoothstep(ra+fe, ra-fe, length(akp));\n      col = mix(col, vec3(1.0), dt*side);\n    }\n    \n    \n    \n    return col;\n}\n\n\nvec3 getAlbedo(inout Data data) {\n    switch (data.id) {\n        case ID_MELON: return getAlbedoMelon(data); break;\n        case ID_MELON_SLICE: return getAlbedoMelonSlice(data); break;\n    }\n    \n    return vec3(0.96);\n}\n\nvec3 getColor(vec3 ro, vec3 rd, inout Data data) {\n    Light light = Light(vec3(1, 1, -3), vec3(0.97, 0.89, 0.79), 6.0);\n\n    vec3 col = vec3(0.0);\n    \n    if (march(ro, rd, data)) {\n        vec3 albedo = getAlbedo(data);\n        vec3 diffuse = albedo / M_PI;\n        col += forEachLight(light, ro, rd, diffuse, data);\n    }\n    \n    return col;\n}\n\n\nvoid mainImage(out vec4 o, in vec2 fc)\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc.xy - 0.5 * R.xy) / R.y;\n    vec4 m = vec4((iMouse.xy - 0.5 * R.xy) / R.y, iMouse.zw);\n    \n    vec3 ro = vec3(0, 0, -3.);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n    if (m.z > 0.001) {\n        ro.yz *= rot(m.y*TAU);\n        ro.xz *= rot(m.x*TAU);\n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n    } else {\n        float a = sin(T);\n        ro.xz *= rot(a);\n        rd.xz *= rot(a);\n    }\n    \n    Data data = NEW_DATA;\n    col += getColor(ro, rd, data);\n    \n    col += col;\n    col = aces(col);\n    col = pow(col, vec3(1.0 / 2.2));\n    \n\n    o = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}