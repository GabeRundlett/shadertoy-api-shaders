{
    "Shader": {
        "info": {
            "date": "1511222012",
            "description": "0f9isdf",
            "flags": 0,
            "hasliked": 0,
            "id": "MlsfR4",
            "likes": 102,
            "name": "fractal pulse",
            "published": 3,
            "tags": [
                "1320",
                "cineshader"
            ],
            "usePreview": 1,
            "username": "macbooktall",
            "viewed": 48928
        },
        "renderpass": [
            {
                "code": "#define MAXDIST 20.\n#define GIFLENGTH 1.570795\n\nstruct Ray {\n\tvec3 ro;\n    vec3 rd;\n};\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat length6( vec3 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y + p.z, 1.0/6.0 );\n}\n\nfloat fractal(vec3 p)\n{\n   \tfloat len = length(p);\n    p=p.yxz;\n\n    float scale = 1.25;\n    const int iterations = 28;\n    float a = iTime;\n\tfloat l = 0.;\n    \n    vec2 rotationAnimAmp = vec2(0.05,0.04);\n\tvec2 rotationPhase = vec2(.45 + sin(iTime*4. + len*0.4) * 0.025,0.15 + cos(-0.2+iTime*4. + len*0.2) * 0.05);\n\t\n    // uncomment this to find good spots with the mouse :)\n    //m = iMouse.xy / iResolution.xy;\n    \n    vec3 juliaOffset = vec3(-3.,-1.15,-.5);\n    \n    pR(p.xy,.5+sin(-0.25+iTime*4.)*0.1);\n    \n    for (int i=0; i<iterations; i++) {\n\t\tp = abs(p);\n        // scale and offset the position\n\t\tp = p*scale + juliaOffset;\n        \n        // Rotate the position\n        pR(p.xz,rotationPhase.x*3.14 + cos(iTime*4. + len)*rotationAnimAmp.y);\n\t\tpR(p.yz,rotationPhase.y*3.14 + sin(iTime*4. + len)*rotationAnimAmp.x);\t\t\n        l=length6(p);\n\t}\n\treturn l*pow(scale, -float(iterations))-.25;\n}\n\nvec2 map(vec3 pos) {\n    float l = length(pos);\n\n    float dist = fractal(pos);\n\n    return vec2(dist, 0.);\n}\n\nvec2 march(Ray ray) \n{\n    const int steps = 30;\n    const float prec = 0.001;\n    vec2 res = vec2(0.);\n    \n    for (int i = 0; i < steps; i++) \n    {        \n        vec2 s = map(ray.ro + ray.rd * res.x);\n        \n        if (res.x > MAXDIST || s.x < prec) \n        {\n        \tbreak;    \n        }\n        \n        res.x += s.x;\n        res.y = s.y;\n        \n    }\n   \n    return res;\n}\n\nvec3 calcNormal(vec3 pos) \n{\n\tconst vec3 eps = vec3(0.005, 0.0, 0.0);\n                          \n    return normalize(\n        vec3(map(pos + eps).x - map(pos - eps).x,\n             map(pos + eps.yxz).x - map(pos - eps.yxz).x,\n             map(pos + eps.yzx).x - map(pos - eps.yzx).x ) \n    );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\nfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.2*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= .95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );    \n}\nvec4 render(Ray ray) \n{\n    vec3 col = vec3(0.);\n\tvec2 res = march(ray);\n   \n    if (res.x > MAXDIST) \n    {\n        return vec4(col, MAXDIST);\n    }\n    \n    vec3 p = ray.ro+res.x*ray.rd;\n    vec3 normal = calcNormal(p);\n    vec3 pos = p;\n    ray.ro = pos;\n    // color with ambient occlusion\n   \tcol = vec3(pow(calcAO(p, normal), 3.2))*0.5;\n   \n    col = mix(col, vec3(0.), clamp(res.x/MAXDIST, 0., 1.));\n   \treturn vec4(col, res.x);\n}\nmat3 camera(in vec3 ro, in vec3 rd, float rot) \n{\n\tvec3 forward = normalize(rd - ro);\n    vec3 worldUp = vec3(sin(rot), cos(rot), 0.0);\n    vec3 x = normalize(cross(forward, worldUp));\n    vec3 y = normalize(cross(x, forward));\n    return mat3(x, y, forward);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 camPos = vec3(9., 6.5, 12.);\n    vec3 camDir = camPos + vec3(-.85, -.5, -1. );\n    mat3 cam = camera(camPos, camDir, 0.);\n    \n    vec3 rayDir = cam * normalize( vec3(uv, 1. + sin(iTime*4.)*0.05) );\n    \n    Ray ray;\n    ray.ro = camPos;\n    ray.rd = rayDir;\n    \n    vec4 col = render(ray);\n    col.xyz = pow(col.xyz, vec3(0.6));\n\tfragColor = vec4(col.xyz,clamp(1.-col.w/MAXDIST, 0., 1.));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}