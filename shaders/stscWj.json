{
    "Shader": {
        "info": {
            "date": "1648745723",
            "description": "Noise Levels / Stepped noise with some fancy scrollers - totally Cheating by just using color / distance gets crunchy.. ",
            "flags": 0,
            "hasliked": 0,
            "id": "stscWj",
            "likes": 14,
            "name": "Noise Levels",
            "published": 3,
            "tags": [
                "raymarching",
                "noise"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 329
        },
        "renderpass": [
            {
                "code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Noise Levels / Stepped noise with some fancy scrollers\n    3/31/22 | @byt3_m3chanic\n    \n*/\n\n#define R \t\t    iResolution\n#define T \t\t    iTime\n#define M \t\t    iMouse\n\n#define PI          3.14159265358\n#define PI2         6.28318530718\n\n#define MAX_DIST    100.\n#define MIN_DIST    .0001\n\n#define SCALE       .5\n#define MHEIGHT     4.0\n#define SHEIGHT     .25\n\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 a) { return fract(sin(dot(a,vec2(21.23,41.232)))*4123.2323); }\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\tvec2 u = f*f*(3.-2.*f);\n    return mix( mix( hash21( i + vec2(0,0) ), \n                     hash21( i + vec2(1,0) ), u.x),\n                mix( hash21( i + vec2(0,1) ), \n                     hash21( i + vec2(1,1) ), u.x), u.y);\n}\n\n//@iq smooth union\nfloat box(vec3 p, vec3 d) {\n    p = abs(p) - d;\n    return length(max(p, 0.)) + min(0., max(max(p.x,p.y),p.z));\n}\nfloat box( in vec2 p, in vec2 b ) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n// cheap hight map\nfloat height_map(vec2 p) {\n    float height = noise(p * SCALE) * MHEIGHT;\n    height = floor(height / SHEIGHT) * SHEIGHT;\n    return height;\n}\n\nfloat time,clr;\nmat2 rx,ry;\n\nvec2 map (in vec3 p) {\n\n    p.xz+=T*.5;\n    vec2 res = vec2(100.,-1.);\n\tfloat height = height_map(p.xz);\n    clr=height;\n    float d = (p.y+3.)-height;\n    if(d<res.x) res = vec2(d*.5,2.);\n    \n    return res;\n}\n\nvec3 normal(vec3 p, float t, float md){\n    t*=md;\n    float d = map(p).x;\n    vec2 e = vec2(t,0);\n    vec3 n = d - vec3(\n        map(p-e.xyy).x,\n        map(p-e.yxy).x,\n        map(p-e.yyx).x\n    );\n    return normalize(n);\n}\n\nvec3 shade(vec3 p, vec3 rd, float d, float m) {\n    vec3 n = normal(p,d,1.);\n    vec3 lpos = vec3(-6,10,6);\n    clr-=.5;\n    vec3 c = vec3(1.-(clr*.5),0,(clr*.6));\n    vec3 l = normalize(lpos-p);\n\n    //@Shane\n    float shdw = 1.0;\n    for( float t=.01;t<14.; ) {\n        float h = map(p + l*t).x;\n        if( h<.0001 ) { shdw = 0.; break; }\n        shdw = min(shdw, 24.*h/t);\n        t += h * .95;\n        if( shdw<.0001 || t>42. ) break;\n    }\n    \n    return mix(c,c*shdw,.75);\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n\n    vec2 uv = (-R.xy + 2.0*F)/max(R.x,R.y);\n    vec3 C=vec3(.0);\n\n    float z = M.xy == vec2(0) ? 0. : -(M.y/R.y * 6. - 3.) * PI;\n    float y = M.xy == vec2(0) ? 0. : -(M.x/R.x * 1. - .5) * PI;\n    \n    float zoom = 10.+z;\n    vec3 ro = vec3(uv*zoom,-zoom);\n    vec3 rd = vec3(0.,0.,1.);\n\n    if(uv.y<.4&&uv.y>-.4){\n\n        rx = rot(-.785);\n        ry = rot(-.785+y);\n        ro.yz*=rx;ro.xz*=ry;\n        rd.yz*=rx;rd.xz*=ry;\n\n        vec3 p = ro;\n        for(int i=0;i<125;i++) {\n            vec2 ray = map(p);\n\n            float d = i<32?ray.x*.5:ray.x;\n            float m = ray.y;\n\n            p += rd * d;\n            if (d*d < 1e-8) {\n                C=shade(p,rd,d,ray.y);\n                break;\n            }\n            if(distance(p,rd)>75.) { break; }\n        }\n\n    }else{ \n\n        uv.x+=uv.y>.0?T*.5:-T*.5;\n        float px = fwidth(uv.x);\n        \n        vec2 f = fract(uv*55.)-.5;\n        vec2 fid = floor(uv*55.)+.5;\n\n        float ht = noise(fid+T*.25);\n\n        vec3 ledh=vec3(1,0,0);\n        vec3 ledc=vec3(0,0,1);\n        ht*=.85;\n\n        float ff = box(f,vec2(.3,.3))-.075;\n        ff=smoothstep(.075+px,-px,ff);\n\n        float avg = (fid.y*.1)+3.;\n        float avx = (fid.y*.1)-2.3; \n\n        if(ht>avg&&ht<avg+.1) C=mix(C,ledh,ff);\n        if(ht>avx&&ht<avx+.1) C=mix(C,ledh,ff);\n\n        if(ht>avg+.25&&ht<avg+1.1) C=mix(C,ledc,ff);\n        if(ht>avx+.25&&ht<avx+1.1) C=mix(C,ledc,ff);\n\n    } \n    \n    C = pow(C,vec3(0.4545) );\n    O = vec4(C,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}