{
    "Shader": {
        "info": {
            "date": "1686308786",
            "description": "gravity is strong enough near the surface of neutron stars to cause a curious relativistic light deflection effect: a perfect sphere that you can see more than half the surface of from any viewpoint",
            "flags": 0,
            "hasliked": 0,
            "id": "dtKSRW",
            "likes": 6,
            "name": "Neutron Star II",
            "published": 3,
            "tags": [
                "dynamic",
                "neutronstar"
            ],
            "usePreview": 1,
            "username": "hashtagexo",
            "viewed": 200
        },
        "renderpass": [
            {
                "code": "// Fork of \"Shader2 Sun\" by PatrickHuang. https://shadertoy.com/view/cl3SD7\n// 2023-06-05 14:42:27\n\n// based on https://www.shadertoy.com/view/4dXGR4\n\n// by trisomie21 燥波算法-屏闪效果\n// 输入是vec3的UV坐标，和float的分辨率。 这里的uv.z是一个时间上的变化，用来控制噪声\n\nfloat snoise(vec3 uv, float res)\t\n{\n\tconst vec3 s = vec3(1e0, 1e2, 1e4); //1e2表示10的二次方，所以这里是(1,100,10000) 用来调整噪声幅度\n\t\n\tuv *= res; //uv*分辨率 做标准化\n\t\n\tvec3 uv0 = floor(mod(uv, res))*s;\n\tvec3 uv1 = floor(mod(uv+vec3(1.), res))*s;\n\t\n    //f向量计算平滑的渐变值\n\tvec3 f = fract(uv); f = f*f*(3.0-1.9*f);\n\t\n\tvec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\n\t\t      \t  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\n\t\n\tvec4 r = fract(sin(v*1e-4)*1e5);\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\tr = fract(-sin((v + uv1.z - uv0.z)*1e-3)*1e5);\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\treturn mix(r0, r1, f.z)*2.-1.6;\n}\n\n//定义一个存储纹理值的float数组\nfloat freqs[4];\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //音乐会转换成纹理值 从channel1的音乐图像中中获取不同位置的像素值，并且存储在freqs上\n\tfreqs[0] = texture( iChannel1, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel1, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel1, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[3] = texture( iChannel1, vec2( 0.30, 0.25 ) ).x;\n    \n    //基于音乐纹理的值计算出亮度，基于亮度计算出半径，再计算半径的倒数\n\tfloat brightness\t= freqs[1] * 0.25 + freqs[2] * 0.25; //越响，亮度就越高现在的范围是[0,0.5]\n\tfloat radius\t\t= 0.31 + brightness * 0.096; //basic半径是0.24 再加上brightness的值\n\tfloat invRadius \t= 1.0/radius;\n\t\n    //定义两个颜色向量\n\tvec3 orange\t\t\t= vec3( 0.2, 0.03, 0.93 ); // now they purple & bluish\n\tvec3 orangeRed\t\t= vec3( 0.1, 0.03, 0.998 );\n    \n    //全局变量iTime*0.1得到时间值，控制纹理平移的速度\n\tfloat time\t\t= iTime * 3.90;\n    \n    //Part1 日冕\n    \n    //计算屏幕的高宽比，并把像素坐标映射到[-0.5,0.5]的范围内，并且根据屏幕宽高比进行调整\n\tfloat aspect\t= iResolution.x/iResolution.y;\n\tvec2 uv\t\t\t= fragCoord.xy / iResolution.xy; //uv范围在[0,1]\n\tvec2 p \t\t\t= -0.5 + uv; //p的范围在[-0.5,0.5]\n\tp.x *= aspect;  //p.x 缩放到[-0.85,0.85]\n    \n    //计算淡入淡出的效果因子\n    //因为原点是(0,0)所以这里计算向量2.2*p的长度就是距离原点的距离\n\tfloat fade\t\t= pow( length( 2.0 * p ), 0.55 ); //2.2是控制淡入淡出范围的系数. fade值再距离原点近的时候小，在离原点远的时候大。\n\tfloat fVal1\t\t= 1.0 - fade; //低频\n\tfloat fVal2\t\t= 1.0 - fade; //高频\n\t\n    //计算角度, 距离，时间坐标\n\tfloat angle\t\t= atan( p.x, p.y )/3.1; //计算(x,y)和y轴正方向的夹角，并且除2pai之后映射到[0,1]之间\n\tfloat dist\t\t= length(p); //向量的长度就是(x,y)距离原点的距离\n\tvec3 coord\t\t= vec3( angle, dist, time * 0.4 ); //构建coord\n\t\n    //第一次计算噪声 用角度，距离，时间坐标 计算噪声值\n    //第二个参数频率分别给的15和45，对应的是低频与高频\n\tfloat noise1\t= abs( snoise( coord + vec3( 0.0, -time * ( 1.65 + brightness * 0.1 ), time * -0.5 ), 95.0 ) );\n\tfloat noise2\t= abs( snoise( coord + vec3( 0.0, -time * ( 1.75 + brightness * 0.1 ), time * -0.5 ), 95.0 ) );\t\n\t\n    \n    //第二次计算噪声 用第一次的值作为参数传入\n    //每次迭代会计算一个不同功率的噪声值，并将其与之前的结果相加。这样做的目的是增加噪声的复杂性和变化程度，以生成更加丰富和细节的效果。\n    //每次循环中计算不同功率的噪声值并且与fval1和fval2相加 noise的返回值是[-1,1]所以其实不会太超范围\n    for( int i=1; i<=7; i++ ){\n\t\tfloat power = pow( 2.0, float(i + 1) ); //power是功率\n\t\tfVal1 += ( 0.5 / power ) * snoise( coord + vec3( 0.0, time, time * 0.02 ), ( power * ( 10.0 ) * ( noise1 + 1.0 ) ) );\n\t\tfVal2 += ( 0.5 / power ) * snoise( coord + vec3( 0.0, time, time * 0.06 ), ( power * ( 15.0 ) * ( noise2 + 1.0 ) ) );\n\t}\n    \n\t//最后的低频noise与高频noise\n\tfloat corona\t\t= pow( fVal1 * max( 1.1 - fade, 0.0 ), 2.01 ) * 10.0;\n\tcorona\t\t\t\t+= pow( fVal2 * max( 1.1 - fade, 0.0 ), 2.01 ) * 10.0;\n    \n    //更加随机(更非对称)\n\tcorona\t\t\t\t*= 0.001 - noise1;\n    \n    if( dist < radius ){\n        //使日冕在球体的表面附近更加强烈，dist/radius的取值范围是[0,1] 其乘上一个很高的指数，目的就是让它只有在边缘位置才有取值\n\t\tcorona\t\t\t*= pow( dist * invRadius, 6.0 );\n    }\n    \n    \n    //Part2 光晕效果\t\n    //对纹理坐标进行变换，并计算出球体的半径和形状因子\n\tvec2 sp = -1.0 + 2.0 * uv; //sp范围在[-1,1]\n\tsp.x *= aspect; //x的范围变成了[-1.7,1.7] 也就是让圆变成一个圆\n\tsp *= ( 1.99 - brightness );//brightness控制球体的大小\n  \tfloat r = dot(sp,sp); //相当于计算了纹理坐标距离各个分量距离原点的距离平方和 x²+y² = r\n\tfloat f = (1.0-sqrt(abs(1.0-r)))/(r) + brightness * 0.2;  //得到球体外观\n    //这一行 首先看(1.0-sqrt(abs(1.0-r)))，细想，要是正好在圆上，就是x²+y² = 1，那sqrt(abs(1.0-r) = 0,(1.0-sqrt(abs(1.0-r)))就= 1，所以圆上亮度最高\n    //然后圆心处的亮度最低，这样就会有一个环形，为了填充中间的空白，再除一个r，就实现了路中间是填充的效果\n    //最后加上brightness分量，保证了有动态的亮度效果\n    \n    \n    //Part3 球本体+材质\n    //定义球体的计算向量\n\tvec3 sphereNormal \t= vec3( 0.0, 0.0, -1.04);\n\tvec3 dir \t\t\t= vec3( 0.0 );\n\tvec3 center\t\t\t= vec3( 0.5, 0.5, 2.0 );//球体的中心，其中z分量并没有被使用到\n\tvec3 starSphere\t\t= vec3( 0.02 );\n    \n\tif( dist < radius ){\n        //newUv是去采样纹理的\n  \t\tvec2 newUv;\n        //把纹理map采样到球形上\n        float MaptoSphere = (1.0-sqrt(abs(1.0-r)))/(r); //这个MaptoSphere的函数，把整个四方形的map映射到我们希望的球体上\n \t\tnewUv.x = sp.x * MaptoSphere;\n  \t\tnewUv.y = sp.y * MaptoSphere;\n\t\tnewUv += vec2( time, 1.0001*time ); //对x轴加上时间分量，有平移效果，y轴乘0.1time 有自转的倾斜角\n\t\t\n        //对UV再加上一定的局部偏移\n\t\tvec3 texSample \t= texture( iChannel0, newUv ).rgb;\n\t\tfloat uOff\t\t= ( texSample.g * brightness * 6.5 + time ); //绿色分量*brightness + 时间，玄学随机偏移量\n\t\tvec2 starUV\t\t= newUv + vec2( uOff, 0.0 ); //只对x进行偏移\n\t\tstarSphere\t\t= texture( iChannel0, starUV ).rgb; //用偏移之后的对纹理map进行采样\n        //starSphere\t\t= texture( iChannel0, newUv ).rgb;\n\t}\n\t\n    //Part4 背景颜色\n    \n    //计算背景颜色被太阳的照亮值，距离圆心越近，就越亮，min是限制在不能大于1，max是限制不能大于0\n\tfloat starGlow\t= min( max( 0.93 - dist * ( 1.0 - brightness ), 0.0 ), 1.4 );\n    starGlow *= 0.66; //让它不那么亮\n\t\n    //设置透明度与RGB\n\tfragColor.rgb\t= vec3( f * ( 0.95 + brightness * 0.8 ) * orange ) + starSphere + corona * orange + starGlow * orangeRed;\n    //fragColor.rgb\t= vec3( f );//01光晕\n    //fragColor.rgb\t= corona * orange; //02日冕\n    //fragColor.rgb\t= starSphere; //03球本体\n    //fragColor.rgb\t= starGlow * orangeRed; //04背景颜色\n\tfragColor.a\t\t= 1.0;\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}