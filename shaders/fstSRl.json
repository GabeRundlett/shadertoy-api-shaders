{
    "Shader": {
        "info": {
            "date": "1633807911",
            "description": "Isosurfaces of random quadratic polynomials, clipped by another isosurface. Inspired by some of the Windows 11 wallpapers (at least Microsoft's artists are still competent). I might try this again with cubics to get more complicated shapes.",
            "flags": 0,
            "hasliked": 0,
            "id": "fstSRl",
            "likes": 3,
            "name": "Quadratic Isosurfaces",
            "published": 3,
            "tags": [
                "3d",
                "raytracing"
            ],
            "usePreview": 0,
            "username": "silentsiege",
            "viewed": 307
        },
        "renderpass": [
            {
                "code": "const uint antiA = 3u; //raise or lower this\n\nconst mat4x3 bgPal = mat4x3(0.5,0.5,0.5,0.5,0.5,0.5,1.0,1.0,1.0,0.0,0.33,0.67);\nconst mat4x3 sfPal = mat4x3(0.5,0.5,0.5,0.5,0.5,0.5,1.0,1.0,1.0,0.0,0.10,0.20);\n\nconst float err = 1e10;\nmat3  fA, cA;\nvec3  fB, cB;\nfloat fC, cC;\n\nvec3 bgCol;\nvec3 sfCol;\n\n\nvec3 hash3(uint n) \n{\n    //https://www.shadertoy.com/view/llGSzw\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec3 k = n * uvec3(n,n*16807U,n*48271U);\n    return vec3( k & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nmat2x3 boxM(uint n) {\n    vec3 U = hash3(n), V = hash3(n + 2568758767u);\n    U = sqrt(-2.*log(U));\n    V *= 2.*3.14159265;\n    return mat2x3(U*cos(V), U*sin(V));\n}\n\nvec3 pal(float t, mat4x3 a) {\n    //https://www.shadertoy.com/view/ll2GD3\n    return a[0] + a[1]*cos(2.*3.14159265*(a[2]*t+a[3]));\n}\n\nvoid set(uint n) {\n    n *= 100u;\n    for (uint i = 0u; i < 3u; ++i) {\n        mat2x3 tmp = boxM(n++);\n        fA[i] = tmp[0];\n        cA[i] = tmp[1];\n        fA[i][i] /= sqrt(2.);\n        cA[i][i] /= sqrt(2.);\n    }\n\n    fB = 2.*(hash3(n++) - 1.);\n    cB = 2.*(hash3(n++) - 1.);\n    fA *= .3;\n    \n    cB *= .3;\n    cA *= .2;\n    cC = 0.;\n    fC = 0.;\n    \n    bgCol = pow(pal(hash3(n++).x, bgPal), vec3(.35));\n    sfCol = pow(pal(hash3(n++).x, sfPal), vec3(1.));\n    \n}\n\nfloat eval(vec3 x, mat3 A, vec3 B, float C) {\n    return dot(x, A*x) + dot(B, x) + C;\n}\n\nvec3 grad(vec3 x, mat3 A, vec3 B) {\n    return B + A*x + x*A;\n}\n\nvec3 param(vec3 x, vec3 d, mat3 A, vec3 B, float C) {\n    return vec3(eval(x,A,B,C), dot(grad(x,A,B), d), dot(d, A*d));\n}\n\nfloat func(vec3 x) {\n    return eval(x, fA, fB, fC);\n}\n\nfloat cond(vec3 x) { \n    return eval(x, cA, cB, cC);\n}\n\nvec3 funcGrad(vec3 x) {\n    return grad(x, fA, fB);\n}\n\nvec3 condGrad(vec3 x) {\n   return grad(x, cA, cB);\n}\n\nvec2 solve(vec3 p) {\n    float a = p.z, b = p.y, c = p.x;\n    float disc = b*b - 4.*a*c;\n\n    if (disc < 0.) return vec2(err);\n    \n    vec2 tmp;\n    \n    if (false && abs(a) < 1e-6 )\n        tmp = vec2(-c/b, err);\n    else if (false && abs(c) < 1e-6)\n        tmp = vec2(0., -a/b);\n    else {\n        tmp.x = (-b - sign(b)*sqrt(disc))/2./a;\n        tmp.y = c/a/tmp.x;\n    }\n    if (tmp.y < tmp.x) tmp = tmp.yx;\n    if (tmp.x < 0.)    tmp = vec2(tmp.y, err);\n    if (tmp.x < 0.)    tmp = vec2(err);\n    return tmp;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    const float duration = 3., speed = 1.;\n    set(uint(iTime/duration) + 0u);\n    fC -= iTime * speed;\n    \n    const float delta = 1.5, focal = 1.3;\n    \n    vec2 uv = (2.*fragCoord - iResolution.xy) / iResolution.y;\n    float pixel = 1./iResolution.y;\n    \n    vec3 ro = vec3(0., 0., 4.);\n    \n    vec3 colTot = vec3(0.);\n    \n    for (uint nAA = 0u; nAA < antiA*antiA; ++nAA) {\n        const float aaStep = 1./float(antiA);\n        vec2 uv1 = vec2(nAA/antiA, nAA%antiA)*aaStep + .5*aaStep;\n        uv1 = (uv1 - .5) * 2.*pixel;\n        vec3 rd = normalize(vec3(uv+uv1, -focal));\n        \n        vec3 fPar = param(ro, rd, fA, fB, fC);\n        vec3 cPar = param(ro, rd, cA, cB, cC);\n        vec2 cIsect = solve(cPar);\n        \n        vec3 col;\n        \n        if (cIsect.x < err) {\n            float hit = func(ro+rd*cIsect.x);\n            vec2 pot = delta * (floor(hit / delta) + vec2(0., 1.));\n            vec4 fIsect = vec4(solve(fPar-vec3(pot.x,0.,0.)), solve(fPar-vec3(pot.y,0.,0.)));\n\n            float t = err;\n            for (int i = 0; i < 4; ++i) {\n                if (fIsect[i] < min(t, cIsect.y) && fIsect[i] > cIsect.x)\n                    t = fIsect[i];\n            }\n\n            vec3 pos = ro + t*rd;\n            vec3 fGrad = funcGrad(pos)/delta;\n            vec3 cGrad = condGrad(pos)/abs(cond(pos));\n            \n            float occ = length(fGrad) / length(cGrad);\n            occ = sqrt(occ);\n            occ = 1. - occ/sqrt(1. + occ*occ);\n            occ = sqrt(occ);\n            \n            col = t < err ? sfCol * occ : bgCol;\n            col = mix(col, sfCol, smoothstep(-2.*pixel, -pixel, -1./cIsect.x));\n        }\n        else\n            col = bgCol;\n        colTot += col;\n    }\n    colTot /= float(antiA*antiA);\n\n    colTot = pow(colTot, vec3(1./2.2));\n    fragColor = vec4(colTot,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}