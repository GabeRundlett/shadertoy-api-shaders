{
    "Shader": {
        "info": {
            "date": "1515126467",
            "description": "Diffusion-limited aggregation. Let it grow for a minute or two and see what happens...",
            "flags": 48,
            "hasliked": 0,
            "id": "Xljfzw",
            "likes": 38,
            "name": "improved 3D DLA",
            "published": 3,
            "tags": [
                "grid",
                "diffusion",
                "march",
                "dla",
                "aggregation",
                "limited"
            ],
            "usePreview": 0,
            "username": "mattz",
            "viewed": 1356
        },
        "renderpass": [
            {
                "code": "/* improved 3D DLA, by mattz. \n   License Creative Commons Attribution 3.0 (CC BY 3.0) Unported License.\n\n   Mouse rotates (or click in bottom left for auto-rotate).\n   Press 'F' to toggle food particles, SPACE to reset.\n\n   Improves on \"3D diffusion limited aggregation\" \n   https://www.shadertoy.com/view/XtSfRz\n\n     - more compact representation in back buffer allows\n       simulation of larger structures\n\n     - eliminated AO artifacts by examining 3x3x3 neighborhood\n       instead of 2x2x2\n\n     - glowy growth of new spheres (instead of appear instantly)\n\n     - scene zoom tracks structure size\n\n     - should work better at preview size when browsing shadertoy\n\n     - thanks to iq for help with lighting & obscurance\n\n   See also https://en.wikipedia.org/wiki/Diffusion-limited_aggregation\n   \n*/\n\n\nconst int num_wander = 64;\nint nx, ny;\nint yshift, xmask;\nfloat nbox;\nivec3 vec_stride;\nint estart;\nvec3 ctr;\n\nconst uint mask15 = 0x7fffu;\nconst uint mask5 = 0x1fu;\n\nconst float fract_bins = 32.0;\n\nconst uint age_mask = 0x3ffu;\nconst uint color_mask = mask5;\nconst uint color_shift = 10u;\n\nvoid check_res() {\n    \n    int nboxi;\n\n    if (iResolution.x >= 256. && iResolution.y >= 192.) {\n        \n        ny = 192;  \n        nx = 256;  \n        nboxi = 31;\n        \n        yshift = 8;\n        xmask = 0xff;\n        \n    } else {\n        \n        ny = 96;\n        nx = 128;\n        nboxi = 23;\n        \n        yshift = 7;\n        xmask = 0x7f;\n        \n    }\n           \n    vec_stride = ivec3(nboxi*nboxi,\n                       nboxi,\n                       1); // for converting idx <-> voxel / slot\n    \n    estart = nboxi*nboxi*nboxi; // number of voxel/slots\n    \n    nbox = float(nboxi);\n    \n    ctr = vec3(0.5*nbox) - 0.5;\n\n}\n\n// flat index -> tex coord\nivec2 idx2tex(int idx) {\n    return ivec2(idx & xmask, idx >> yshift);\n}\n\nivec2 vec2tex(ivec3 v) {\n    return idx2tex(vec_stride.x*v.x + vec_stride.y*v.y + vec_stride.z*v.z);\n}\n\nivec2 vec2tex(vec3 vox) {\n    return vec2tex(ivec3(floor(vox+0.5)));\n}\n\nivec2 extra2tex(int e) {\n    return idx2tex(estart + e);\n}\n\nvec3 fract2pos(uvec3 u) {\n    return (vec3(u) + 0.5 - 0.5*fract_bins) / fract_bins;\n}\n\nuvec3 pos2fract(vec3 v) {\n    v = floor(fract(v+.5)*fract_bins);\n    return uvec3(v);\n}\n\nuvec3 uint2uvec(uint udata) {\n            \n    // bits 15..30 are xyz\n    uvec3 v = uvec3(udata);\n    v = v >> ivec3(0, 5, 10);\n    v = v & mask5;\n\n    return v;\n    \n}\n\nuint uvec2uint(uvec3 v) {\n    v &= mask5;\n    return v.x | (v.y << 5) | (v.z << 10);\n}\n\nuvec4 get_xyzmat(float fdata) {\n    \n    uint udata = floatBitsToUint(fdata);\n    \n    // bits 0..15 are xyz, 15..30 are material\n    return uvec4(uint2uvec(udata), (udata >> 15) & mask15);\n\n    \n}\n\nuvec2 get_age_color(uint m) {\n    \n    uint age = m & age_mask;\n    uint color = (m >> color_shift) & color_mask;\n    \n    return uvec2(age, color);\n    \n}\n\n// minimum of vector\nfloat min3(vec3 a) {\n\treturn min(a.x, min(a.y, a.z));\n}\n\n// max of vector\nfloat max3(vec3 a) {\n\treturn max(a.x, max(a.y, a.z));\n}\n\n// point in box?\nbool inbox(vec3 c, float tol) {\n    float d = max3(abs(c - ctr));\n    return d < 0.5*nbox + tol;\n}\n\n//////////////////////////////////////////////////////////////////////\n\nconst float farval = 10000.0;\nconst vec4 miss = vec4(vec3(0.0), farval);\nconst float rad = .475;\nconst float wrad = .175;\n\nconst int rsteps = 90;\n\nfloat rmax;\n\nvec3 L = normalize(vec3(-0.7, 1.0, -1.0));\nmat3 Rview;\n\n// RGB from hue\nvec3 hue(float h) {\n    vec3 c = mod(h*6.0 + vec3(2, 0, 4), 6.0);\n    return h >= 1.0 ? vec3(h-1.0) : clamp(min(c, -c+4.0), 0.0, 1.0);\n}\n\n// rotate about x-axis \nmat3 rotX(in float t) {\n    float cx = cos(t), sx = sin(t);\n    return mat3(1., 0, 0, \n                0, cx, sx,\n                0, -sx, cx);\n}\n\n\n// rotate about y-axis \nmat3 rotY(in float t) {\n    float cy = cos(t), sy = sin(t);\n    return mat3(cy, 0, -sy,\n                0, 1., 0,\n                sy, 0, cy);\n\n}\n\n// ray-sphere intersection\nvec4 sphere(in vec3 o, in vec3 d, in vec3 ctr, in float r) {\n\t\n    vec3 oc = o - ctr;\n    \n    float a = dot(d, d);\n    float b = 2.0*dot(oc, d);\n    float c = dot(oc, oc) - r*r;\n        \n    float D = b*b - 4.0*a*c;\n    \n    if (D > 0.0) {\n        \n        float sqrtD = sqrt(D);\n        \n        float t = 0.5 * ( -b - sqrtD ) / a;\n        \n        if (t >= 0.0) {\n            vec3 n = normalize( oc + t*d );\n            return vec4(n, t);\t\n        }\n        \n    }\n    \n    return miss;\n\t\t\n}\n\n// ray-box intersection\nfloat box(vec3 ro, vec3 rd, vec3 b) {\n\t\n\tvec3 rdi = 1.0/rd;\t\n\t\t\n\tvec3 t1 = (-b - ro)*rdi;\n\tvec3 t2 = ( b - ro)*rdi;\n\t\n\tvec3 tmin = min(t1, t2);\n\tvec3 tmax = max(t1, t2);\n    \n    float ta = max3(tmin);\n    float tb = min3(tmax);\n\t\n\tif (ta <= tb) {\n\t\treturn ta;\n\t} else {\n\t\treturn farval;\n\t}\n\n}\n\n// select whichever basis edge minimizes time to hit\nvec3 bselect(vec3 k, vec3 d, vec3 b1, vec3 b2) {\n\treturn (abs(dot(k,b1)*dot(d,b2)) < abs(dot(k,b2)*dot(d,b1))) ? b1 : b2;\n}\n\n// for stepping through cube lattice\nfloat stepcube(in vec3 p, in vec3 d) {\n\t\n\t// g is half-integer coords from p in the direction of d\n\tvec3 g = floor(p+vec3(0.5))-vec3(0.5) + step(vec3(0.0), d);\n\n\t// k is the vector from p to the corner in direction d\n\tvec3 k = g-p;\n\t\n\t// select the basis vector representing the first to intersect\t\n\tvec3 b = bselect(k, d, \n\t\t\t\t\t bselect(k, d, vec3(1.0, 0.0, 0.0), \n\t\t\t\t\t \t\t\t   vec3(0.0, 1.0, 0.0)), \n\t\t\t\t\t\t           vec3(0.0, 0.0, 1.0));\n\t\n\t// compute the distance along the ray to the nearest cube edge\n\treturn dot(k,b) / dot(d, b);\n\t\n}\n\n// exponential radius scaling based on age\nfloat rscale(uint age) {\n    return 1.0 - exp(-0.05*float(age));\n}\n   \n// distance map for AO below\nfloat map(vec3 p) {    \n        \n    float result = farval;\n    \n    ivec3 vbase = ivec3(floor(p+0.5));   \n    \n    for (int j=0; j<27; ++j) {\n\n        ivec3 joffs = ivec3(j / 9, (j / 3) % 3, j % 3) - 1;\n        ivec3 v = vbase + joffs;\n        vec3 vf = vec3(v);\n        \n        if (inbox(vf, 0.0)) {\n            \n            vec4 tdata = texelFetch(iChannel0, vec2tex(v), 0);\n            if (tdata != vec4(0)) {\n                // my NVidia GPU does not like iterating directly over vec4's :(\n                float td[4] = float[4](tdata.x, tdata.y, tdata.z, tdata.w);\n                for (int i=0; i<4; ++i) {\n                    if (td[i] != 0.0) {\n                        \n                        uvec4 u = get_xyzmat(td[i]);            \n                        uvec2 ac = get_age_color(u.w);\n                                    \n                        vec3 q = vf + fract2pos(u.xyz);\n                        \n                        result = min(result, length(p-q)-rad*rscale(ac.x));\n                        \n                    }\n                }\n            }            \n        }        \n    }\n    \n    return result;\n    \n}\n\n// adapted from https://www.shadertoy.com/view/Xds3zN\nfloat calcAO( in vec3 pos, in vec3 nor ) {\n\n    float occ = 0.0;\n    float sca = 1.0;\n    \n    for( int i=0; i<5; i++ ) {\n    \n        float hr = 0.05 + 0.1*float(i);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.5;\n        \n    }\n    \n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n    \n}\n\n// dimming due to position within swarm & AO - thanks for the help, iq!\nfloat dim_factor(vec3 ro, vec3 rd, float t, vec3 n, bool do_ao) {\n       \n    vec3 pos = ro + rd*t;\n    vec3 dis = pos - ctr;\n    float len = length(dis);\n    \n    float oc1 = min(len/rmax, 1.0);\n    float oc2 = 0.5 + 0.5*dot(n, dis/len);\n    \n    float f = 0.1 + 1.1*oc1*oc2;\n    \n    if (do_ao) { f *= calcAO(pos, n); }\n    \n    return f;\n    \n}\n\nstruct rayhit {\n    vec4 nt;\n    vec4 color;\n    bool do_ao;\n};\n\n// select closest ray intersection result\nvec4 pselect(vec4 a, vec4 b) {\n    return a.w < b.w ? a : b;\n}\n\n// raytrace against sphere whose position is given\n// by texture lookup\nvoid spheres(in vec3 ro, in vec3 rd, in vec3 p,\n             in vec4 tdata, \n             inout rayhit rresult) {\n    \n    // oddly, need to create array from vector otherwise\n    // shader hangs on my fancy NVidia GPU :(\n    float td[4] = float[4]( tdata.x, tdata.y, tdata.z, tdata.w );\n    \n    for (int i=0; i<4; ++i) {\n        if (td[i] != 0.) {\n            \n            uvec4 u = get_xyzmat(td[i]);            \n            uvec2 ac = get_age_color(u.w);                      \n            float rs = rscale(ac.x);\n            \n            vec4 s = sphere(ro, rd, p + fract2pos(u.xyz), rad*rs);\n            \n            if (s.w < rresult.nt.w) {\n                rresult.nt = s;\n                vec3 c = hue((float(ac.y) + 0.5) / 32.);\n                float k = 1.0 - exp(-0.015*float(ac.x));\n                c = mix(vec3(2.0), c, k);\n                rresult.color = vec4( c, k );\n                rresult.do_ao = true;\n            }\n                        \n        }\n    }\n    \n}\n\nconst int KEY_F = 70;\n\n/* Compare key state to default state. */\nfloat keyState(int key, float default_state) {\n    return abs( texelFetch(iChannel1, ivec2(key, 2), 0).x - default_state );\n}\n\n// raytrace against sphere whose position is given\n// by texture lookup\nvoid sphere_tex(in vec3 ro, in vec3 rd, in ivec2 tex, \n                inout rayhit rresult) {\n    \n    vec4 ct = texelFetch(iChannel0, tex, 0);\n    if (ct.w > 0.) {\n        vec4 s = sphere(ro, rd, ct.xyz, wrad);\n        if (s.w < rresult.nt.w) {\n            rresult.nt = s;\n            rresult.color = vec4(hue(ct.w), 1.);\n            rresult.do_ao = false;\n        }\n    }\n}\n\n// ray trace\nvec3 shade(in vec3 ro, in vec3 rd) {\n    \n    // added to cube step\n    const float eps = 0.001;\n    \n    // raytrace against bounding box\n    float curw = box(ro, rd, 0.5*vec3(nbox)+rad+eps);\n\n    // center box grid\n    ro += ctr;\n    \n    // raytrace result\n    rayhit rresult = rayhit(miss, vec4(0), false);\n    \n    // wandering food particles\n    if (keyState(KEY_F, 1.0) != 0.) {\n        for (int i=0; i<num_wander; ++i) {\n            sphere_tex(ro, rd, extra2tex(i), rresult);        \n        }\n    }\n\n    // if hit box, raytrace thru\n    if (curw < farval) {\n\n        // march along ray thru grid\n        for (int i=0; i<rsteps; ++i) {\n\n            // point in grid\n            vec3 p = ro + curw * rd;\n\n            // base cell \n            ivec3 vbase = ivec3(p);\n\n            // for each neighbor in 2x2x2 neighborhood\n            for (int j=0; j<8; ++j) {\n\n                // offset to neighbor\n                ivec3 joffs = ivec3(j >> 2, j >> 1, j) & 1;\n\n                // center of cell\n                ivec3 v = vbase + joffs;\n                vec3 p = vec3(v);\n\n                if (inbox(p, 0.0)) {\n                    vec4 tdata = texelFetch(iChannel0, vec2tex(v), 0);\n                    if (tdata != vec4(0)) {\n                        spheres(ro, rd, p, tdata, rresult);\n                    }\n                }\n                \t\n\n            } // for each neighbor\n\n            curw += stepcube(p, rd) + eps;\n\n        } // for each step along ray\n\n    } // if hit bounding box\n\n    vec3 bgcolor = vec3(0);\n    \n    // if hit a sphere, shade it\n    if (rresult.nt.w < farval) {\n\n        vec3 n = rresult.nt.xyz;\n        \n        vec3 diffamb = (0.2*clamp(dot(n,L), 0.0, 1.0)+0.8) * rresult.color.xyz;\n        vec3 R = 2.0*n*dot(n,L)-L;\n        \n        float f = dim_factor(ro, rd, rresult.nt.w, n, rresult.do_ao);\n        f = mix(1.0, f, rresult.color.w);\n\n        float spec = f*1.0*pow(clamp(-dot(R, rd), 0.0, 1.0), 20.0);\n        \n        return (diffamb + spec) * f;\n\n    } else {\n        \n        return bgcolor;\n        \n    }\n    \t\n}\t\n\n// basic view setup and raytrace\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    check_res();\n    \n    rmax = texelFetch(iChannel0, extra2tex(num_wander), 0).y;\n    float dcam = min(3.*max(rmax, 6.0), 1.8*nbox);\n    \n    vec2 uv = (fragCoord.xy - .5*iResolution.xy) * 0.8 / (iResolution.y);\n   \n    const vec3 tgt = vec3(0.0, 0.0, 0.0);\n    vec3 cpos = vec3(0.0, 0.0, dcam);\n    const vec3 up = vec3(0, 1, 0);\n\n    vec3 rz = normalize(tgt - cpos),\n        rx = normalize(cross(rz,vec3(0,1.,0))),\n        ry = cross(rx,rz);\n\n    float thetay = 0.4*iTime;\n    float thetax = 0.75 * smoothstep(0.0, 5.0, iTime);\n\n    if (max(iMouse.x, iMouse.y) > 80.0) { \n        thetax = (iMouse.y - .5*iResolution.y) * -5.0/iResolution.y; \n        thetay = (iMouse.x - .5*iResolution.x) * 10.0/iResolution.x; \n    }\n\n    Rview = mat3(rx,ry,rz)*rotY(thetay)*rotX(thetax); \n    L = Rview*L;\n\n    vec3 rd = Rview*normalize(vec3(uv, 1.)),\n        ro = tgt + Rview*vec3(0,0,-length(cpos-tgt));\n\n    fragColor.xyz = shade(ro, rd);\n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const int num_wander = 64;\nint nx, ny;\nint yshift, xmask;\nfloat nbox;\nivec3 vec_stride;\nint estart;\nvec3 ctr;\n\nconst uint mask15 = 0x7fffu;\nconst uint mask5 = 0x1fu;\n\nconst uint age_mask = 0x3ffu;\nconst uint color_mask = mask5;\nconst uint color_shift = 10u;\n\nconst float fract_bins = 32.0;\n\nvoid check_res() {\n    \n    int nboxi;\n\n    if (iResolution.x >= 256. && iResolution.y >= 192.) {\n        \n        ny = 192;  \n        nx = 256;  \n        nboxi = 31;\n        \n        yshift = 8;\n        xmask = 0xff;\n        \n    } else {\n        \n        ny = 96;\n        nx = 128;\n        nboxi = 23;\n        \n        yshift = 7;\n        xmask = 0x7f;\n        \n    }\n\n\n    vec_stride = ivec3(nboxi*nboxi,\n                       nboxi,\n                       1); // for converting idx <-> voxel / slot\n    \n    estart = nboxi*nboxi*nboxi; // number of voxel/slots\n    \n    nbox = float(nboxi);\n    \n    ctr = vec3(0.5*nbox) - 0.5;\n\n}\n\n// flat index -> tex coord\nivec2 idx2tex(int idx) {\n    return ivec2(idx & xmask, idx >> yshift);\n}\n\nivec2 vec2tex(ivec3 v) {\n    return idx2tex(vec_stride.x*v.x + vec_stride.y*v.y + vec_stride.z*v.z);\n}\n\nivec2 vec2tex(vec3 vox) {\n    return vec2tex(ivec3(floor(vox+0.5)));\n}\n\nivec2 extra2tex(int e) {\n    return idx2tex(estart + e);\n}\n\nvec3 fract2pos(uvec3 u) {\n    return (vec3(u) + 0.5 - 0.5*fract_bins) / fract_bins;\n}\n\nuvec3 pos2fract(vec3 v) {\n    v = floor(fract(v+.5)*fract_bins);\n    return uvec3(v);\n}\n\nuvec3 uint2uvec(uint udata) {\n            \n    // bits 15..30 are xyz\n    uvec3 v = uvec3(udata);\n    v = v >> ivec3(0, 5, 10);\n    v = v & mask5;\n\n    return v;\n    \n}\n\nuint uvec2uint(uvec3 v) {\n    v &= mask5;\n    return v.x | (v.y << 5) | (v.z << 10);\n}\n\n\nuvec4 get_xyzmat(in float fdata) {\n    \n    uint udata = floatBitsToUint(fdata);\n    \n    // bits 0..15 are xyz, 15..30 are material\n    return uvec4(uint2uvec(udata), (udata >> 15) & mask15);\n\n    \n}\n\nuvec2 get_age_color(uint m) {\n    \n    uint age = m & age_mask;\n    uint color = (m >> color_shift) & color_mask;\n    \n    return uvec2(age, color);\n    \n}\n\n// minimum of vector\nfloat min3(vec3 a) {\n\treturn min(a.x, min(a.y, a.z));\n}\n\n// max of vector\nfloat max3(vec3 a) {\n\treturn max(a.x, max(a.y, a.z));\n}\n\n// point in box?\nbool inbox(vec3 c, float tol) {\n    float d = max3(abs(c - ctr));\n    return d < 0.5*nbox + tol;\n}\n\n//////////////////////////////////////////////////////////////////////\n\nconst uint occ_bit = 0x80000000u;\nconst uint exp_mask = 0x7f800000u;\nconst uint exp_hibit = 0x40000000u;\n\nfloat set_xyzmat(uvec4 xyzm) {\n    \n    // set high bit to 1 just to mark cell occupied\n\tuint udata = occ_bit | ((xyzm.w & mask15) << 15) | uvec2uint(xyzm.xyz);\n    if ((udata & exp_mask) == 0u) { udata |= exp_hibit; }\n    \n    return uintBitsToFloat(udata);\n    \n}\n\nuint set_age_color(uvec2 ac) {\n    return (ac.x & age_mask) | ((ac.y & color_mask) << color_shift);\n}\n\n//////////////////////////////////////////////////////////////////////\n\n// from https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p) {\n\n    #define HASHSCALE3 vec3(.1031, .1030, .0973)\n\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n// sample uniform on face of sphere\nvec3 random_dir(vec2 ti) {\n   \n    vec2 pq = hash22(ti);\n    \n    float z = pq.y * 2. - 1.;\n    float s = sqrt(1. - z*z);\n    \n    float theta = pq.x * 6.283185307179586;\n    \n    return vec3(cos(theta)*s, sin(theta)*s, z).yzx;\n    \n}\n\n\n// get flat index from tex coord\nint tex2idx(ivec2 tex) {\n    return tex.x + (tex.y << yshift);\n}\n\n\nvoid age_particle(inout float f) {\n    \n    if (f != 0.) {\n        \n        uvec4 xyzm = get_xyzmat(f);\n        uvec2 ac = get_age_color(xyzm.w);        \n        \n        if (ac.x < age_mask) { ++ac.x; }\n        xyzm.w = set_age_color(ac);\n        \n        f = set_xyzmat(xyzm);\n        \n    }\n    \n}\n\n// this is the main logic behind the dla algorithm\nvoid mainImage( out vec4 fragColor, in vec2 floatFC ) {\n    \n    check_res();\n   \n    // future operations assume fragCoord is exact integer\n    ivec2 fc = ivec2(floatFC);\n\n    // check if current fragment in minimum texture area \n    ivec2 outside = fc - ivec2(nx, ny);\n    if (max(outside.x, outside.y) > 0) {\n        return;\n    }\n\n    // get the flat index (within texture) of this texel\n    int idx = tex2idx(fc);  \n    \n    if (idx > estart + num_wander) { \n        return; \n    }\n    \n\t// each voxel has a number of \"slots\" (possible spheres)\n    // to keep things simple and avoid having to loop to check \n    // for free slots, we have a fixed destination slot\n    // which increments each frame.\n    int f = iFrame;\n    \n    // get the fragment color by looking up in the texture (feedback buffer)        \n    fragColor = texelFetch(iChannel0, fc, 0);\n    \n    if (iFrame == 0 || texelFetch(iChannel1, ivec2(32, 0), 0).x > 0.) {\n                \n        fragColor = vec4(0);\n\n        // on first frame, just write a single seed sphere in the middle of the scene\n        if (fc == vec2tex(ctr)) {\n            fragColor.x = set_xyzmat(uvec4(pos2fract(ctr), 0u));\n        }\n        \n        return;\n                \n    } \n    \n                    \n    // see if it's a wandering food particle\n    bool is_wander = (idx >= estart && idx < estart + num_wander);\n        \n    int widx = -1; // wandering particle index\n    vec3 p_wander;    // wandering particle position\n    vec4 wander_tdata; // cell at wandering pos\n\n    // texel one past wandering food particles stores max radius\n    if (idx == estart + num_wander) {\n            \n        // update max radius\n        float rmax = fragColor.x;\n\n        // for each food particle\n        for (int i=0; i<num_wander; ++i) {\n\n            // get its current position\n            vec4 p = texelFetch(iChannel0, extra2tex(i), 0);\n            vec3 fp = floor(p.xyz + 0.5);\n\n            // if it's in bounding cube\n            if (inbox(fp, 0.0)) {\n\n                // lookup the current frame's slot inside this voxel\n                vec4 q = texelFetch(iChannel0, vec2tex(ivec3(fp)), 0);\n\n                // if there's any sphere there, update the distance\n                if (q != vec4(0)) {\n                    rmax = max(rmax, length(fp - ctr));                    \n                }\n\n            }\n            \n        }\n\n        fragColor = vec4(rmax, mix(fragColor.y, rmax, 0.01), 0, 0);\n        return;    \n            \n    } else if (is_wander) { \n            \n        // this texel corresponds to a wandering food particle, \n        // so stash its index and position\n        widx = idx - estart;\n        p_wander = fragColor.xyz;\n        wander_tdata = texelFetch(iChannel0, vec2tex(p_wander), 0);\n              \n    } else { \n\n        // this texel corresponds to the current frame slot in some voxel\n\n        // see if this texel corresponds to some food particle,\n        // if so, stash its index and position\n        for (int i=0; i<num_wander; ++i) {\n            vec4 p = texelFetch(iChannel0, extra2tex(i), 0);\n            if (inbox(floor(p.xyz + 0.5), 0.0) && p.w != 0.0 && vec2tex(p.xyz) == fc) {\n                widx = i;\n                p_wander = p.xyz;\n                wander_tdata = fragColor;\n            }\n        }\n        \n        age_particle(fragColor.x);\n        age_particle(fragColor.y);\n        age_particle(fragColor.z);\n        age_particle(fragColor.w);\n\n\n    }\n\n    // if no current wandering particle, leave fragment unchanged\n    if (widx < 0) { return; }\n    \n    int dst_slot = (wander_tdata.x == 0. ? 0 :\n                    wander_tdata.y == 0. ? 1 :\n                    wander_tdata.z == 0. ? 2 : \n                    wander_tdata.w == 0. ? 3 :\n                    4);\n    \n    const uint miss = uint(-1);\n    uint hit = miss;\n\n    if (dst_slot < 4) {\n\n        // get the floor of 2x2x2 neighborhood for this wandering poxel\n        ivec3 vbase = ivec3(floor(p_wander));\n\n\n        // check for collision among 2x2x2 neighborhood\n        for (int j=0; j<8; ++j) {\n\n            ivec3 joffs = ivec3(j >> 2, j >> 1, j) & 1;\n            ivec3 v = vbase+joffs; // neighbor voxel\n            vec3 fv = vec3(v);\n\n            // if neighbor in bounding cube\n            if (inbox(fv, 0.0)) {\n\n                vec4 tdata = texelFetch(iChannel0, vec2tex(v), 0);\n                \n                float td[4] = float[4](tdata.x, tdata.y, tdata.z, tdata.w);\n                \n                for (int i=0; i<4; ++i) {\n                    if (td[i] != 0.) {\n                        uvec4 u = get_xyzmat(td[i]);\n                        vec3 pos = fv + fract2pos(u.xyz);\n                        if (length(pos - p_wander) < 0.9) {\n                            hit = u.w;\n                        }\n                    }\n                }\n\n            }\n        }\n        \n    }\n\n    // now we need to update wandering particles and/or add them into\n    // grid if collided...\n\n    if (is_wander) { // current texel is wandering particle\n\n        // get bounding sphere radius\n        float rmax = texelFetch(iChannel0, extra2tex(num_wander), 0).x;\n        rmax = max(rmax, 3.0);\n\n        // starting radius\n        float rseed = rmax + 1.0;\n        float r = length(p_wander - ctr);\n\n        // if hit or not yet generated or too old\n        if (hit != miss || r > rseed + 1.0 || fragColor.w < 1.2) {\n\n            p_wander = ctr + random_dir(vec2(float(f) + iDate.w, widx))*rseed;\n            fragColor = vec4(p_wander, 1.95);\n\n        } else { // otherwise add brownian motion and age the particle\n\n            fragColor.xyz += random_dir(vec2(float(f) + iDate.w, widx)) * 0.35;\n            fragColor.w = mix(fragColor.w, 1.2, 0.001);\n\n        }\n\n    } else {\n        \n        \n        if (hit != miss) { // current texel is where particle should be added\n       \n            uvec2 ac = get_age_color(hit);\n            ac.x = 0u;\n            ++ac.y;\n            \n            fragColor[dst_slot] = set_xyzmat(uvec4(pos2fract(p_wander), set_age_color(ac)));\n\n        }\n        \n    }\n\n\t\n    \n   \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}