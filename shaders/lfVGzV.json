{
    "Shader": {
        "info": {
            "date": "1713018558",
            "description": "Simplest sphere normalmap lit with dot product",
            "flags": 0,
            "hasliked": 0,
            "id": "lfVGzV",
            "likes": 1,
            "name": "Sphere normalmap shaded",
            "published": 3,
            "tags": [
                "sphere",
                "normal"
            ],
            "usePreview": 0,
            "username": "Chalouek",
            "viewed": 129
        },
        "renderpass": [
            {
                "code": "#define up vec3(0.,1.,0.)\nvec4 ColorCorrection(vec4);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    vec3 center = vec3(uv-vec2(0.5),0);\n    center.x *= ratio;\n    center /= 0.3;// size of circle\n    float len = length(center);// .xy magnitude\n\n    vec4 background = vec4(0.,0.3,1.,1.)/8.;\n//logic mask for optimization, cause aliasing\n    if (len < 1.) {\n        float AAmask = clamp((1.-len)*200.,0.,1.);//smooth fallof mask for basic anti-aliasing\n        center.z = sqrt(1.-len*len); //estimation of z normal by .xy magnitude\n        vec3 rotAxis = vec3(0.,1.,1.); // axis of light rotation vector\n        vec3 rotsin = normalize(cross(rotAxis,up));//custom \"x\" light axis\n        vec3 rotcos = normalize(cross(rotsin,rotAxis));//custom \"y\" light axis\n        // combine of 2 new custom axis modified with sin cos rotation of 1 unit circle \n        //(what sin and cos basiacally is representing)\n        vec3 light = rotsin*sin(iTime)+rotcos*cos(iTime);\n        float lit = dot(center,light);//dot between circle surface normals and light normal is shading!\n        lit = clamp(lit,0.,1.);//clamping in case of post processing\n        float gasLayer = 1./center.z;//something like secant, for surface dust denisty distribution mask;\n        fragColor = ColorCorrection(vec4(lit)*4.+vec4(gasLayer*pow((cos(iTime)+2.)/4.,2.))*vec4(0.,0.3,1.,1.));\n        fragColor = mix(fragColor,background,1.-AAmask);//applying anti-aliasing mask\n    } else {\n        //code for other pixels\n        fragColor = background;\n    }\n}\n//nice neurtral tonemap that packs values from 0 to infinite in 0 to 1\nvec4 ColorCorrection(vec4 image){\n    return 1.-(1./(1.+image));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}