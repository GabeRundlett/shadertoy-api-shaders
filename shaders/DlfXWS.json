{
    "Shader": {
        "info": {
            "date": "1675559325",
            "description": "use the mouse to look around.",
            "flags": 32,
            "hasliked": 0,
            "id": "DlfXWS",
            "likes": 46,
            "name": "Infinite Dodecahedron",
            "published": 3,
            "tags": [
                "wireframe",
                "antialias",
                "mirror",
                "infinite",
                "dodecahedron",
                "infinity"
            ],
            "usePreview": 0,
            "username": "xjorma",
            "viewed": 792
        },
        "renderpass": [
            {
                "code": "// Created by David Gallardo - xjorma/2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 c = separableBlur(iChannel0, ivec2(fragCoord), 10, 1, ivec2(iResolution)).rgb * 0.8 + texelFetch(iChannel1, ivec2(fragCoord), 0).rgb;\n    fragColor = vec4(sqrt(c), 1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const int nbRef = 5;     // 5 max! Not enought bits in a float.\nconst int nbBits = 3;\n\n#define NO_UNROLL_ZERO min(0, iFrame)\n\nconst float PI = radians(180.0);\n\nvec4 separableBlur(in sampler2D tex, in ivec2 c, in int radius, in int axis, ivec2 res)\n{\n    vec4 acc = vec4(0);\n    for(int i = -radius; i <= radius; i ++)\n    {\n        ivec2 uv = c;\n        uv[axis] += i;\n        float t = float(i) / float(radius);\n        float w = exp(-4.0*t*t);\n\t\tacc += texelFetch(tex, uv, 0)*w;\n    }\n    return acc / (0.5 * float(radius) * sqrt(PI));    // Gaussian integral\n}\n\nconst int numPlanes = 12;\n\nconst vec3 planes[numPlanes / 2] = vec3[](\nvec3(0.0, 1.00747072906e-07, -1.0),\nvec3(0.0, 0.89442718029, -0.447213709354),\nvec3(0.850650787354, 0.27639311552, -0.447213679552),\nvec3(0.52573120594, -0.723606586456, -0.447213947773),\nvec3(-0.525731146336, -0.723606586456, -0.447213888168),\nvec3(-0.850650787354, 0.276393145323, -0.447213739157));\n\nconst int numVertices = 20;\n\nconst vec3 vextexplanes[numVertices] = vec3[](\nvec3(0.356822151585, 0.491123815541, -0.794654232951),\nvec3(0.577350469481, -0.187592375793, -0.794654349975),\nvec3(0.0, -0.607062228519, -0.794654296349),\nvec3(-0.577350469481, -0.187592375793, -0.794654349975),\nvec3(-0.356822151585, 0.491123815541, -0.794654232951),\nvec3(-0.577350217029, 0.794654569487, -0.187592222894),\nvec3(-0.934172366371, -0.303531064052, -0.187592332104),\nvec3(0.0, -0.982246973058, -0.187592334382),\nvec3(0.934172366371, -0.303531064052, -0.187592332104),\nvec3(0.577350217029, 0.794654569487, -0.187592222894),\nvec3(0.0, 0.982246969732, 0.187592351794),\nvec3(-0.934172366371, 0.303531064052, 0.187592332104),\nvec3(-0.577350217029, -0.794654569487, 0.187592222894),\nvec3(0.577350217029, -0.794654569487, 0.187592222894),\nvec3(0.934172366371, 0.303531064052, 0.187592332104),\nvec3(0.0, 0.607062228519, 0.794654296349),\nvec3(0.577350469481, 0.187592375793, 0.794654349975),\nvec3(0.356822151585, -0.491123815541, 0.794654232951),\nvec3(-0.356822151585, -0.491123815541, 0.794654232951),\nvec3(-0.577350469481, 0.187592375793, 0.794654349975) );\n\nconst int totalPlane = numPlanes + numVertices;\n\nfloat clipTriangle(float t)\n{\n    float v = 1.5 - abs((t - floor(t * 0.5) * 2.0) - 1.0) * 2.0;\n    return clamp(v, 0.0, 1.0);\n}\n\nvec4 getPlane(in int id, in float t)\n{\n    if(id < numPlanes / 2)\n    {\n        return vec4(planes[id % (numPlanes / 2)], -1.0);\n    }\n    else if(id < numPlanes)\n    {\n        return vec4(-planes[id % (numPlanes / 2)], -1.0);\n    }\n    return vec4(vextexplanes[id - numPlanes], mix(-1.25840880545, -1.0981855332, clipTriangle(t * 0.2)));\n}\n\nint getid(in int id)\n{\n    if(id < numPlanes)\n    {\n        return id % (numPlanes / 2);\n    }\n    return 6;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Created by David Gallardo - xjorma/2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\nconst float fltMax = 100000.;\nconst float fltMin = -100000.;\n\n\nbool convexIntersect( in vec3 ro, in vec3 rd, out vec2 oDis, out vec3 oOutNor,out vec3 oInNor, out ivec2 ids)\n{\n    oDis = vec2(fltMin, fltMax);\n    oOutNor =  oInNor = vec3(0);\n    ids = ivec2(-1);\n    for(int i = 0 ;i < totalPlane; i++)\n    {\n        vec4 plane = getPlane(i, iTime);\n        float t = -(plane.w + dot(plane.xyz, ro)) / dot(plane.xyz, rd);\n        if(dot(plane.xyz, rd) < 0.) // enter\n        {\n            if(t > oDis.x)\n            {\n                oDis.x = t;\n                oOutNor = plane.xyz;\n                ids.x = getid(i);\n            }\n        }\n        else  // exit\n        {\n            if(t < oDis.y)\n            {\n                oDis.y = t;\n                oInNor = - plane.xyz;\n                ids.y = getid(i);\n            }\n        }\n    }\n    return oDis.x < oDis.y;\n}\n\nfloat render(in vec3 ro,in vec3 rd)\n{\n    float  col = 0.0;\n    vec3  oN, iN;\n    ivec2 ids;\n    vec2  d;\n    if(convexIntersect(ro, rd, d, oN, iN, ids))\n    {\n        // polyhedron interior + exterior\n        col = float(ids.x) * float(1 << (nbBits * (nbRef + 1))) + float(ids.y) * float(1 << (nbBits * nbRef));\n        // Reflection\n        for(int i = 0; i < nbRef; i++)\n        {\n            ro += rd * d.y;\n            rd = reflect(rd, iN);\n            convexIntersect(ro, rd, d, oN, iN, ids);\n            col += float(ids.y) * float(1 << (nbBits * (nbRef - 1 - i)));            \n        }\n    }\n    return col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 tot = vec4(0.0);      \n\tvec2 rook[4] = vec2[](vec2( 1./8., 3./8.), vec2( 3./8.,-1./8.), vec2(-1./8.,-3./8.), vec2(-3./8., 1./8.));\n    for( int n = NO_UNROLL_ZERO; n < 4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        // camera        \n        float theta\t= radians(360.) * (iMouse.x/iResolution.x-0.5) + iTime*.2;\n        float phi\t= radians(110.) * (iMouse.y/iResolution.y-0.5) - radians(90.);\n        vec3 ro = 2.3 * vec3( sin(phi) * cos(theta), cos(phi), sin(phi) * sin(theta));\n        vec3 ta = vec3( 0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        tot[n] = render(ro ,rd);  \n    }\n    fragColor = tot;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Created by David Gallardo - xjorma/2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\nvec4 logn(in vec4 v, float n)\n{\n    return log(v) / log(n);\n}\n\n\nfloat sobelFilter(in sampler2D tex, in ivec2 c)\n{\n    ivec4 tleft  = ivec4(texelFetch(tex, c + ivec2(-1, 1), 0));\n    ivec4 left   = ivec4(texelFetch(tex, c + ivec2(-1, 0), 0));\n    ivec4 bleft  = ivec4(texelFetch(tex, c + ivec2(-1,-1), 0));\n    ivec4 top    = ivec4(texelFetch(tex, c + ivec2( 0, 1), 0));\n    ivec4 bottom = ivec4(texelFetch(tex, c + ivec2( 0,-1), 0));\n    ivec4 tright = ivec4(texelFetch(tex, c + ivec2( 1, 1), 0));\n    ivec4 right  = ivec4(texelFetch(tex, c + ivec2( 1, 0), 0));\n    ivec4 bright = ivec4(texelFetch(tex, c + ivec2( 1,-1), 0));\n    \n    ivec4 x = (tleft ^ tright) | (left ^ right) | (bleft ^ bright);\n    ivec4 y = (tleft ^ bleft) | (top ^ bottom) | (tright ^ bright);\n    \n    ivec4 m = x | y;\n    \n    vec4 b = ceil(logn(vec4(m) + 1.0 , float(1 << nbBits))) / float( 2 + nbRef);\n    return dot(b, vec4(0.25));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 c = vec3(sobelFilter(iChannel0, ivec2(fragCoord)));\n    fragColor = vec4(pow(vec3(c), vec3(4,3.5,2.5)), 1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Created by David Gallardo - xjorma/2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = separableBlur(iChannel0, ivec2(fragCoord), 10, 0, ivec2(iResolution));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}