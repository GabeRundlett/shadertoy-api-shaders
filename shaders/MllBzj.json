{
    "Shader": {
        "info": {
            "date": "1512552905",
            "description": "Application of screenspace balanced isolines in procedural transforms\nBetter seen in fullscreen.\n\nIlusion: lines keeps undistorted despite the stretching. ;-)",
            "flags": 0,
            "hasliked": 0,
            "id": "MllBzj",
            "likes": 24,
            "name": "Moebius Spiral iso-grid",
            "published": 3,
            "tags": [
                "spiral",
                "mobius",
                "illusion",
                "complex",
                "screenspace",
                "tuto",
                "weave",
                "balanced"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 1080
        },
        "renderpass": [
            {
                "code": "// variant of  https://shadertoy.com/view/llsfRj\n// application from https://shadertoy.com/view/Xlffzj\n\n#define S(v) smoothstep(2./iResolution.y, 0., v )\n\n// --- direct transforms\nvec2 Mobius(vec2 p, vec2 z1, vec2 z2)\n{\n\tz1 = p - z1; p -= z2;\n\treturn mat2(z1,z1.y,-z1.x) * p / dot(p, p);\n}\n\nvec2 spiralZoom(vec2 p, vec2 offs, float n, float spiral, float spiral2, float zoom, vec2 phase)\n{\n\tp -= offs;\n\tfloat a = atan(p.y, p.x)/6.283 + iTime/32.;\n\tfloat d = length(p);\n\treturn mat2(n,spiral2, spiral,-zoom) * vec2(a, log(d)) + phase;\n}\n\n// --- inverse transforms\nvec2 iMobius(vec2 p, vec2 z1, vec2 z2)     \n{                               \n    float s = sign(p.x), sb = sign(p.y),             // make unique sol: s=1,x1,y1 otherwise 4\n          l = length(p), t = p.y/p.x,                // solve  u = v*l ; tan(u,v) = p.y/p.x\n          c = s / sqrt(1.+t*t),                      // c = cos(atan( ) )\n        v = length(z1-z2) / sqrt( 1.+ l*l -2.*l*c ), // c = (u²+v²-|z1z2|² ) / 2uv\n        u = v*l;                                   \n    vec2  a = 2.*(z1-z2);                            // solve |P-z1| = u ; |P-z2| = v\n    float b = u*u-v*v + dot(z2,z2)-dot(z1,z1);       // ||²-||²: a.P + b = 0\n    // y = -( b + a.x* x ) / a.y                     // normalize by a.y\n    b /= a.y; a /= a.y;                              // ( in Shane example a.y was = 0 ! )\n    float A = 1. +  a.x*a.x,                         //  |P-z1|² = u² , P = (x,y)\n          B =     2.* b*a.x -2.*dot(vec2(1,-a.x),z1),\n          C =           b*b +2.*b*z1.y + dot(z1,z1) - u*u,\n          D = max(0., B*B - 4.*A*C),\n         x1 = (-B+sb*sqrt(D))/(2.*A), y1 = -( b + a.x*x1 );\n     //  x2 = (-B-sb*sqrt(D))/(2.*A), y2 = -( b + a.x*x2 );\n  // if (abs(A)<1e-5) { x1 = x2 = -C/B; y1 = y2 = -( b + a.x*x1 ) / a.y; } // degenerate case\n\treturn vec2(x1,y1);                    \n}\n\nvec2 ispiralZoom(vec2 p, vec2 offs, float n, float spiral, float spiral2, float zoom, vec2 phase)\n{\n    p = inverse(mat2(n,spiral2, spiral,-zoom)) * (p-phase) ;\n    p.x = (p.x - iTime/32.) * 6.283;             // ( p.x, p.y )  = ( a, log(d) )\n    return exp(p.y) * vec2(cos(p.x),sin(p.x)) + offs;\n}\n\n// --- demo configuration \nvec2 Z1 = vec2(-.875, -.525),  // in Shane example Z1.y=Z2.y was causing a degenerescence\n     Z2 = vec2(.375, -.125);\nfloat spiral = 3.14159*.2,\n      spiral2 = 2.5; // ~= 3.14159*.8 . was 1\n\nvec2 MobiusSpiral(vec2 q)      // total direct transform\n{\n    q = Mobius(q, Z1, Z2);\n    return spiralZoom(q, vec2(-.5), 5., spiral, spiral2, .5, vec2(-1, 1)*iTime*.125);\n}\nfloat DrawInvMobiusSpiral(vec2 q, vec2 uv0, float r) // total inverse transform + draw iso-X\n{\n    vec2 v; float s = 0.;\n    q = ispiralZoom(q, vec2(-.5), 5., spiral, spiral2, .5, vec2(-1, 1)*iTime*.125);\n    v = iMobius(q, Z1, Z2);  \n    return S(length(uv0-v) - r ) ; //* (.5+.5* cos( 3.14 * length(uv0-v) / r / 2.) );\n}\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n\tvec2 R = iResolution.xy,\n        uv0 = (U -.5*R) / R.y,\n    uv = MobiusSpiral(uv0);\n#define f(v) (fract(v/spiral2+.5)-.5)*spiral2                    // suppress the wrapping glitch\n    mat2 M = inverse(mat2(f(dFdx(uv)),f(dFdy(uv)))) / R.y;       // measure compression, for LOD\n     \n    O *= 0.;\n    float l,a, r=0.; vec2 q;\n    for (int i=0; i<2; i++) {\n        //q = floor(uv*4.)/4.;\n        \n        l = log2(20.*length(M[1]));\n        a = fract(l);\n        l = exp2(floor(l));                                      // compute H-LOD\n        q = vec2( floor(uv.x*l+float(i)) / l, uv.y );            // H isolines in screen space\n        O += (1.-O)* (1.-a)* DrawInvMobiusSpiral(q, uv0, r );\n        q = vec2( floor(uv.x*(l*2.)+float(i)) / (l*2.), uv.y );  // inter-LOD fading\n        O += (1.-O)* a* DrawInvMobiusSpiral(q, uv0, r );\n#if 1   \n        l = log2(46.*length(M[0])); // was 100\n        a = fract(l);\n        l = exp2(floor(l));                                      // compute V-LOD\n        q = vec2( uv.x, floor(uv.y*l+float(i)) / l );            // V isolines in screen space\n        O += (1.-O)* (1.-a)* DrawInvMobiusSpiral(q, uv0, r );\n        q = vec2( uv.x, floor(uv.y*(l*2.)+float(i)) / (l*2.) );  // inter-LOD fading\n        O += (1.-O)* a* DrawInvMobiusSpiral(q, uv0, r );\n#endif\n\n    }\n    O = sqrt(O);                                                 // to sRGB\n} ",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}