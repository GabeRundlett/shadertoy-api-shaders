{
    "Shader": {
        "info": {
            "date": "1630749410",
            "description": "tribute to https://iquilezles.org/articles/normalsSDF/normalsSDF.htm  ;-)\n( how to compute centered finite differences with only 4 fetches ).",
            "flags": 0,
            "hasliked": 0,
            "id": "7s33Df",
            "likes": 10,
            "name": "tetrahedron in cube",
            "published": 3,
            "tags": [
                "raymarching",
                "short"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 337
        },
        "renderpass": [
            {
                "code": "\n#define rot(a)    mat2( cos(a+vec4(0,11,33,0)) )              // rotation                  \n\nvoid mainImage(out vec4 O, vec2 U) {    \n    float t=9.,s,c,e,l; \n    vec3  R = iResolution,\n          D = normalize(vec3( U+U, -3.5*R.y ) - R ),          // ray direction\n          p = 7./R, q,a,                                      // marching point along ray \n       // M =  iMouse.xyz/R -.5;\n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(20,8,0)/1e2*cos(iTime+vec3(0,11,0));\n     \n    for ( O=vec4(1) ; O.x > 0. && t > .01 ; O-=.01 )\n        q = p,\n        q.yz *= rot( .5-6.*M.y),                              // rotations\n        q.xz *= rot( 2.-6.*M.x),\n        a = abs(q),\n        c = max(a.x,max(a.y,a.z))-1.,                         // cube\n#define A(x,y,z) vec3(x,y,z)/sqrt(3.)\n#define D(x,y,z) dot(q,A(x,y,z))\n        t = max(c, 1.3 - max(max(D(1,1,-1),D(1,-1,1)),max(D(-1,1,1),D(-1,-1,-1))) ), // tetrahedron corners\n        t = min(t, s = length(q)-.4),                         // central sphere\n#define C(s) length( abs(q.s) - 1. )\n        t = min(t, e = max(min(C(xy),min(C(yz),C(xz)))-.01, c) ), // cube edges\n#define P(x,y,z) length( q - max(0.,D(x,y,z))*A(x,y,z) )\n        t = min(t, l = max( min(min(P(1,1,-1),P(1,-1,1)),min(P(-1,1,1),P(-1,-1,-1))) -.1 , c ) ), // tetra axes\n        p += t*D;                                             // step forward = dist to obj          \n\n    if (t==e) O.rg *=.7;                                      // coloring\n    if (t==s) O.gb *= 0.; else if (t!=c) O *= .7;\n    if (t==l) O.gb *= 0.;\n}\n\n\n\n\n\n/* // smart AA https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n     // O.r++;                        // uncomment to see where the oversampling occurs\n    }\n} */",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}