{
    "Shader": {
        "info": {
            "date": "1698769966",
            "description": "Change your point of view, and you will see things differently.",
            "flags": 0,
            "hasliked": 0,
            "id": "DsVBDt",
            "likes": 4,
            "name": "Change the point of view",
            "published": 3,
            "tags": [
                "3d",
                "raymarching"
            ],
            "usePreview": 0,
            "username": "IWBTShyGuy",
            "viewed": 144
        },
        "renderpass": [
            {
                "code": "// Change your point of view, and you will see things differently.\n// ref: https://www.shadertoy.com/view/mlSyRz\n\n// The MIT License\n// Copyright Â© 2023 IWBTShyGuy\n\n// regular N-gon, if you want circle, let N = 0\nconst int N0 = 5;\nconst int N1 = 6;\n\nconst float ANGLE = PI / 4.0;\nconst float THICKNESS = 0.01;\n\nvec2 feetRegularPolygon(in vec2 p, in int n, in float r) {\n    vec2 h;\n    float dist = 10.0 * r;\n    for (int i = 0; i < n; i++) {\n        float t0 = 2.0 * PI * float(i) / float(n),\n        t1 = 2.0 * PI * float(i + 1) / float(n);\n        vec2 a = vec2(-sin(t0), cos(t0)) * r,\n        b = vec2(-sin(t1), cos(t1)) * r,\n        ab = b - a, ap = p - a,\n        hab = ap - clamp(dot(ap, ab) / dot(ab, ab), 0.0, 1.0) * ab;\n        float dist0 = length(hab);\n        if (dist0 < dist) {\n            dist = dist0;\n            h = hab;\n        }\n    }\n    return p + h;\n}\n\nvec2 feetCircle(in vec2 p, in float r) {\n    if (length(p) == 0.0) return vec2(0, r);\n    else return r * normalize(p);\n}\n\nvec2 feet0(in vec2 p) {\n    if (N0 == 0) return feetCircle(p, 0.5);\n    return feetRegularPolygon(p, N0, 0.5);\n}\n\nvec2 feet1(in vec2 p) {\n    if (N1 == 0) return feetCircle(p, 0.5);\n    return feetRegularPolygon(p, N1, 0.5);\n}\n\nfloat sDistCone0(in vec3 p) {\n    Camera cam = Camera(\n        vec3(0, 0, -1),\n        vec3(0, 0, 1),\n        vec3(0, 1, 0),\n        ANGLE,\n        1.0\n    );\n    vec2 uv = 2.0 * screenUV(cam, p) - 1.0,\n    h = feet0(uv);\n    float signum = sign(distance(uv, h) - THICKNESS / 2.0);\n    h = h + normalize(uv - h) * THICKNESS / 2.0;\n    Ray ray = cameraRay(cam, (h + 1.0) / 2.0);\n    vec3 op = p - ray.origin;\n    return signum * length(op - dot(op, ray.direction) * ray.direction);\n}\n\nfloat sDistCone1(in vec3 p) {\n    Camera cam = Camera(\n        vec3(0, 0, 1),\n        vec3(0, 0, -1),\n        vec3(0, 1, 0),\n        ANGLE,\n        1.0\n    );\n    vec2 uv = 2.0 * screenUV(cam, p) - 1.0,\n    h = feet1(uv);\n    float signum = sign(distance(uv, h) - THICKNESS / 2.0);\n    h = h + normalize(uv - h) * THICKNESS / 2.0;\n    Ray ray = cameraRay(cam, (h + 1.0) / 2.0);\n    vec3 op = p - ray.origin;\n    return signum * length(op - dot(op, ray.direction) * ray.direction);\n}\n\nfloat sDist(in vec3 p) {\n    float dist0 = max(-0.5 - p.z, sDistCone0(p));\n    float dist1 = max(p.z - 0.5, sDistCone1(p));\n    return max(dist0, dist1);\n}\n\nvec3 calcNormal(vec3 p) {\n    const vec2 e = vec2(1.e-4,0);\n    return normalize(vec3(\n        sDist(p + e.xyy) - sDist(p - e.xyy),\n        sDist(p + e.yxy) - sDist(p - e.yxy),\n        sDist(p + e.yyx) - sDist(p - e.yyx)\n    ));\n}\n\nvec3 color(vec3 p, vec3 normal, vec3 dir) {\n    return vec3(-dot(dir, normal));\n}\n\nvoid mainImage0(out vec4 O, in vec2 U) {\n    vec2 r = iResolution.xy;\n    float t = mod(iTime, 4.0 * PI);\n    if (t < 2.0 * PI) t = max(t - PI, 0.0);\n    else t = PI + max(t - 3.0 * PI, 0.0);\n    vec3 camPos = vec3(sin(t), 0.6 * sin(t), cos(t));\n    Camera cam = Camera(\n        camPos,\n        -normalize(camPos),\n        vec3(0,1,0),\n        PI / 6.0,\n        r.x / r.y\n    );\n    Ray ray = cameraRay(cam, U / r);\n    vec3 ro = ray.origin, rd = ray.direction, p;\n\n    float dist = 0.0, dist0;\n    const float MAX_DIST = 2.;\n    for(int i = 0; i++ < 255\n        && (dist0 = sDist(p = ro + dist * rd)) > 1.0e-5\n        && (dist += dist0) < MAX_DIST;); \n    \n    vec3 col = vec3(0);\n    if (dist < MAX_DIST) col = color(p, calcNormal(p), rd);\n    \n    O = vec4(col, min(dist, MAX_DIST));\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    \n// smart anti-aliasing\n// reference: https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\n\n// If defined, Activate AA, level: 2 or 3\n#define AA 2\n\n// If defined, visualize anti-aliased pixels.\n//#define VISUALIZE_AA\n#ifdef AA\n    if ( fwidth(length(O.w)) > 0.1) {\n        vec4 o;\n#if (AA == 2)\n        for (int k = 0; k < 4; k++) {\n              mainImage0(o,U + (vec2(k % 2, k / 2) - 0.5) / 1.5);\n              O += o;\n        }\n        O /= 5.0;\n#elif (AA == 3)\n        for (int k = 0; k < 9; k += k == 3 ? 2 : 1 ) {\n              mainImage0(o, U + vec2(k % 3 - 1, k / 3 - 1) / 3.0);\n              O += o;\n        }\n        O /= 9.0;\n#endif\n#ifdef VISUALIZE_AA\n        O = vec4(1);\n    } else {\n        O = vec4(0,0,0,1);\n#endif\n    }\n#endif\n\n    O.xyz = pow(O.xyz, vec3(.4545));\n    O.w = 1.0;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float PI = 3.141592653;\n\nstruct Camera {\n    vec3 position;\n    vec3 direction;\n    vec3 up_direction; // not require dot(direction, up_direction) == 0\n    float fov;\n    float aspect; // x / y\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\n// perspective camera ray, uv = fragCoord / iResolution.xy\n// cf: https://qiita.com/aa_debdeb/items/301dfc54788f1219b554\nRay cameraRay(in Camera camera, in vec2 uv) {\n    uv = uv * 2.0 - 1.0;\n    float h = tan(camera.fov * 0.5);\n    float w = h * camera.aspect;\n    vec3 right = normalize(cross(camera.direction, camera.up_direction));\n    vec3 up = normalize(cross(right, camera.direction));\n    vec3 direction = normalize(right * w * uv.x + up * h * uv.y + camera.direction);\n    Ray ray;\n    ray.origin = camera.position;\n    ray.direction = direction;\n    return ray;\n}\n\nvec2 screenUV(in Camera camera, in vec3 p) {\n    vec3 op = p - camera.position;\n    float r = dot(op, camera.direction);\n    float v_unit = r * tan(camera.fov * 0.5);\n    float u_unit = v_unit * camera.aspect;\n    vec3 right = normalize(cross(camera.direction, camera.up_direction));\n    vec3 up = normalize(cross(right, camera.direction));\n    vec2 xy = vec2(\n        dot(op, right) / u_unit,\n        dot(op, up) / v_unit\n    );\n    return (1.0 + xy) * 0.5;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}