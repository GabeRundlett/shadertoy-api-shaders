{
    "Shader": {
        "info": {
            "date": "1630169486",
            "description": "Clickdrag mouse to rotate the camera.",
            "flags": 0,
            "hasliked": 0,
            "id": "fd33z2",
            "likes": 3,
            "name": "neonwave heartbeat",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "pali6",
            "viewed": 340
        },
        "renderpass": [
            {
                "code": "vec3 camPos = vec3(0, 0, 0);\nvec3 camDir = vec3(0, 0, -1);\nvec3 camUp = vec3(0, 450. / 800., 0);\nfloat camF = 0.4;\nfloat rtStep = 0.2;\nfloat rtlStep = 0.025;\nfloat rtglStep = 0.2;\nconst int maxSteps = 48;\nconst int maxlSteps = 32;\nconst int maxglSteps = 64;\n\nfloat time;\n\nvec3 lightPos = vec3(4, 3, -1);\n\nvec3 INVALID = vec3(1e10, 1e20, -1e30);\n\nfloat smin(float a, float b)\n{\n    float x = b - a;\n    return a + ((1. - 0.5)*x+0.55)*(1. - smoothstep(-1.8,0.4,x))+(0.5*x - 0.55)*(1. - smoothstep(-0.86,1.6,x));\n    // return (a + b - log(exp(a - b) + exp(b - a))) / 2.;\n}\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 rayDir(vec2 uv)\n{\n    vec3 camRight = normalize(cross(camDir, camUp));\n    return normalize(camDir * camF + (uv.y - 0.5) * 2. * camUp + (uv.x - 0.5) * 2. * camRight);\n}\n\nvec3 orbit(vec3 normal, float dist, float speed, float offset)\n{\n    vec3 v1 = normalize(cross(normal, vec3(0.42, 0.1, -0.1)));\n    vec3 v2 = normalize(cross(normal, v1));\n    return dist * (v1 * cos(time * speed + offset) + v2 * sin(time * speed + offset));\n}\n\nfloat scene(vec3 pos)\n{\n    vec3 ballCenter = vec3(0, 0, -5);\n    float ballRadius = 2.;\n    float result =  distance(pos, ballCenter) - ballRadius + sin(pos.y * 5. + time) / 3. * cos(time * 0.2);\n    vec3 ballCenter2 = ballCenter + orbit(vec3(0, 1, 0), 3., 1., 0.);\n    result = smin(result, distance(pos, ballCenter2) - 0.3);\n    result = smin(result, distance(pos, ballCenter + orbit(vec3(-4, 12, 0), 2.7, 1.7, 0.2)) - 0.3);\n    result = smin(result, distance(pos, ballCenter + orbit(vec3(-4, 2, 5), 2.7, 1.8, 0.2)) - 0.3);\n    result = smin(result, distance(pos, ballCenter + orbit(vec3(8, 7, -8), 2.7, 1.9, 0.2)) - 0.3);\n    result = smin(result, distance(pos, ballCenter + orbit(vec3(-14, -5, -1), 2.7, 2.0, 0.2)) - 0.3);\n    result = smin(result, distance(pos, ballCenter + orbit(vec3(1, 12, 0), 2.7, 0.8, 0.8)) - 0.3);\n    result = smin(result, distance(pos, ballCenter + orbit(vec3(-7, -5, 8), 2.6, 1.7, 0.1)) - 0.3);\n    result = smin(result, distance(pos, ballCenter + orbit(vec3(-1, 1, 22), 2.5, 1.2, 0.2)) - 0.3);\n    result = smin(result, distance(pos, ballCenter2 + orbit(vec3(0.1, -0.5, -1), 0.8, -0.41, -0.2)) - 0.15);\n    /*\n    result -= (dot(pos - ballCenter, normalize(vec3(1, 3, 7)))) * 0.1;\n    result -= (dot(pos - ballCenter, normalize(vec3(-7, 2, 1)))) * 0.1;\n    result -= (dot(pos - ballCenter, normalize(vec3(2, -1, 0.3)))) * 0.1;\n    result -= (dot(pos - ballCenter, normalize(vec3(4, 3, -1)))) * 0.1;\n    */\n    // result += 1./distance(pos, vec3(-2, -2, -7));\n    result = 2. - abs(result - 2.);\n    result = smin(result, length((pos - ballCenter).xz) - 0.3);\n    return result;\n}\n\nvec3 sceneNormal(vec3 pos)\n{\n    float d = 0.001;\n    float base = scene(pos);\n    return normalize(vec3(\n        scene(pos + vec3(d, 0, 0)) - base,\n        scene(pos + vec3(0, d, 0)) - base,\n        scene(pos + vec3(0, 0, d)) - base\n    ));\n}\n\nvec4 rt(vec3 rayPos, vec3 rayDir)\n{\n    float lastVal = 0.;\n    float retVal = 0.;\n    float stp = rtStep;\n    for(int i = 0; i < maxSteps; i++)\n    {\n        float val = scene(rayPos);\n        if(val < 0.001)\n        {\n            retVal = 1.;\n        }\n        if(sign(val * lastVal) == -1.)\n            stp /= 2.;\n        lastVal = val;\n        rayPos += rayDir * stp * sign(val);\n    }\n    return vec4(rayPos, 1.);\n}\n\nvec4 rtl(vec3 rayPos, vec3 rayDir, float maxDist)\n{\n    float lastVal = 0.;\n    float tot = 0.;\n    for(int i = 0; i < maxlSteps; i++)\n    {\n        float val = scene(rayPos);\n        if(maxDist <= 0.1 || val > 40.)\n        {\n            float a = -val / (lastVal - val);\n            rayPos -= rtStep * rayDir * a;\n            return vec4(rayPos, tot);\n        }\n        if(val <= 0.001)\n            tot += rtlStep * (-val);\n        lastVal = val;\n        float step = rtlStep;\n        maxDist -= length(rayDir) * step;\n        rayPos += rayDir * step;\n    }\n    return vec4(rayPos, tot);\n}\n\nvec3 rtgl(vec3 rayPos, vec3 rayDir)\n{\n    float lastVal = 0.;\n    vec3 result = vec3(0., 0., 0.);\n    for(int i = 0; i < maxglSteps; i++)\n    {\n        float val = scene(rayPos);\n        float sound = texture(iChannel0, vec2(abs(rayPos.y) * 0.1, 0)).x;\n        float power = sound * 5. + 0.1;\n        val = sign(val) * pow(abs(val), power) * (1. + power * 0.2) ;\n        if(val < 0.01)\n        {\n            float a = -val / (lastVal - val);\n            // val = (lastVal + val) / 2.;\n            //result += rtStep * smoothstep(0.1, 0.2, val) * (1. - smoothstep(0.2, 0.3, val)) * val * a;\n            return result;\n        }\n        //if(lastVal > 0.1 && val < 0.09)\n        //    result += rtStep * val * 3.;\n        float xd = rtglStep * smoothstep(0.1, 0.2, val) * (1. - smoothstep(0.3, 0.4, val)) * val * val;\n        result.x += xd;\n        result.y += xd * min(1., sound * 1.5 + 0.2);\n        // result += min(10., 1. / pow(val, 2.2) * smoothstep(0., 1., (val - 0.05) / 0.1)) * rtStep;\n        rayPos += rayDir * rtglStep * min(max(0.1, val), 1.0);\n        lastVal = val;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime * 0.1;\n    lightPos = vec3(3., 3.*sin(iTime), -4. + cos(iTime));\n    vec2 mousePos = iMouse.xy / iResolution.xy;\n    if(mousePos.x <= 0.01 && mousePos.y <= 0.01)\n        mousePos.y = 0.5;\n    camPos = vec3(cos(mousePos.x * 3.14 * 2.)*sin(mousePos.y * 3.14), -cos(mousePos.y * 3.14), sin(mousePos.x * 3.14 * 2.)*sin(mousePos.y * 3.14)) * 5. + vec3(0, 0, -5);\n    camDir = normalize(vec3(0, 0, -5) - camPos);\n    vec3 lol = camDir;\n    if(lol.y < 0.)\n        lol *= -1.;\n    lol.y = 0.;\n    camUp = normalize(cross(camDir, cross(camDir, lol))) * iResolution.y / iResolution.x;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col;\n    /*\n    vec4 hitInfo = rt(camPos, rayDir(uv));\n    vec3 hit = hitInfo.xyz;\n    if(hitInfo.w != 0.)\n    {\n        vec4 lightHitInfo = rtl(lightPos, hit - lightPos, distance(hit, lightPos));\n        vec3 lightHit = lightHitInfo.xyz;\n        col = mix(vec3(1, 0.1, 0.2), vec3(0.4, 0.4, 0.2), distance(hit, vec3(0, 0, -5)) / 6.);\n        float light = 0.1;\n        light += 4. / distance(lightHit, lightPos) * max(0., dot(sceneNormal(hit), -normalize(hit - lightPos)) * (1. / (1. + lightHitInfo.w * 100.)));\n        // light += 4. / distance(hit, lightPos) * max(0., dot(sceneNormal(hit), -normalize(hit - lightPos)));\n        col *= light;\n        // col -= vec3(1.-light, 1.-light, 1.-light);\n    }\n    else\n    {\n        col = vec3(0, 0, 0); //texture(iChannel0, hit.xy / 5.0 - vec2(1, 1)).xyz;\n    }\n    */\n    vec3 gl = rtgl(camPos, rayDir(uv));\n    col.b += gl.x * 2.;\n    col.r += gl.y * 2.5;\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 35,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}