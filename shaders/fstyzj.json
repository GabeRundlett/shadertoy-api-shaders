{
    "Shader": {
        "info": {
            "date": "1653752830",
            "description": "Monster Skeleton Preset 43.7 with iron man coloring :)",
            "flags": 0,
            "hasliked": 0,
            "id": "fstyzj",
            "likes": 21,
            "name": "Monster Skeleton Preset 43.7",
            "published": 3,
            "tags": [
                "kifs"
            ],
            "usePreview": 0,
            "username": "aiekick",
            "viewed": 411
        },
        "renderpass": [
            {
                "code": "// Created by Stephane Cuillerdier - Aiekick/2022 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// the shading used for these kifs, are so simple\n\n// its just the ambient occlusion used as a ratio in a linear interpolation between two colors\n\n// in my experiments, its was just 2 matcaps\n// like in this video https://twitter.com/aiekick/status/1524851894761537550\n\n// for shadertoy, i just tried to recreate a similar shading as my matcaps\n\n// with iron man colors\n\n// can be cool if shadertoy can add some matcaps (as samples)\n\n//#define CAN_TUNE_SHAPE_WITH_MOUSE\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n\tfragColor = vec4(0,0,0,1);\n    \n    // one time sdf transform \n    vec2 shape_mouse = vec2(0.468359,0.95317);\n#ifdef CAN_TUNE_SHAPE_WITH_MOUSE\n    if (iMouse.z > 0.0)\n    {\n        shape_mouse = iMouse.xy/iResolution.xy;\n    }\n#endif\n\tvec2 rm = k2Pi * shape_mouse;\n\tscene_mtx = rotX(rm.x) * rotY(rm.x) * rotZ(rm.x) * rotX(rm.y);\n\t\t\n    // ray origin, ray direction\n    vec2 mr = iMouse.xy / iResolution.xy;\n\tfloat ca = iTime * 0.4;\n\tfloat cd = 30.0;\n    \n#ifndef CAN_TUNE_SHAPE_WITH_MOUSE\n    if (iMouse.y > 0.0)\n    {\n        cd = 15.0 + iMouse.y / iResolution.y * 30.0;\n    }\n#endif\n\tvec3 ro = vec3(cos(ca) * cd, sin(ca) * 15.0, sin(ca) * cd);\n\tvec3 lp = ro + vec3(0.0, 10.0, 0.0);\n\tvec3 rd = camera(fragCoord, iResolution.xy, ro, vec3(0), vec3(0.5));\n\n\tfloat md = 0.0;\n\tif (march(ro, rd, 300.0, 100, 0.8, md))\n\t{\n\t\tvec3 p = ro + rd * md;\n\t\tvec3 n = getNormal(p, 0.001);\n        \n        // ambiant occluison factor\n\t\tfloat ao = getAmbiantOcclusion(p, n, 6.98795);\n\t\tfloat ratio = clamp((1.0-ao) * 3.07229, 0.0, 1.0);\n        \n        // light dir\n        vec3 ld = normalize(lp-p);\n\t\t\n        // linera interpolation fo two colors by the ao ratio\n        vec3 col = mix(vec3(0.4,0,0), vec3(0.46,0.42,0.21), vec3(ratio));\n\t\t\n        // just a simple shading for reproduce the matcaps i was using\n        // based on a cubemap here\n        vec3 refl = refract(rd, -n, 0.4);\n\t\tfloat diff = clamp( dot( n, ld ), 0.0, 1.0 );\n\t\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. );\n\t\tfloat spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),32.);\n\t\tfloat amb = 0.23; \t\n\t\tvec3 cube = texture(iChannel0, refl, 2.0).rgb;\n\t\tfloat sha = getShadow(p, ld, 0.0, 50.0, 10.0);\n\t\t\n        // lighting\n\t\tcol *= (1.0 + sha) * 0.5;\n        col += 0.25 * diff * sha;\n        col += 0.2 * ao;\n        col += 0.15 * fre;\n        col += 0.5 * cube;\n        col += 0.25 * spe;\n        \n        // gamma\n        fragColor.rgb = pow(col, vec3(5.0));\n    }\n\t\t\n    // aces (filmic) tonemap, with custom coefs\n\tfragColor.rgb = acesFilm(fragColor.rgb, 2.4, 0.1, 2.4, 0.29, 0.2);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float kPi = radians(180.);\nconst float k2Pi = radians(360.);\n\nmat3 scene_mtx;\n\nmat3 rotZ(float t)\n{\n    float s = sin(t);\n    float c = cos(t);\n    return mat3(c, s, 0., -s, c, 0., 0., 0., 1.);\n}\n\nmat3 rotX(float t)\n{\n    float s = sin(t);\n    float c = cos(t);\n    return mat3(1., 0., 0., 0.,\tc, \ts, 0., -s, c);\n}\n\nmat3 rotY(float t)\n{\n    float s = sin(t);\n    float c = cos(t);\n    return mat3 (c, 0., -s, 0., 1., 0, s, 0, c);\n}\n\nfloat map(vec3 p)\n{\n\tfloat scaleAccum = 1.;\n    for(int i = 0; i < 18; ++i)\n    {\n\t\tp.yz = sqrt(p.yz*p.yz+0.16406);\n\t\tp *= 1.21;\n\t\tscaleAccum *= 1.21;\n        p -= vec3(2.43307,5.28488,0.9685);\n        p = scene_mtx * p;\n\t}\n\t\n\treturn length(p) / scaleAccum - 0.15;\n}\n\nvec3 getNormal(vec3 p, float prec)\n{\n\tvec3 e = vec3(prec, 0, 0);\n\treturn normalize(vec3(\n\t\tmap(p+e)-map(p-e),\n\t\tmap(p+e.yxz)-map(p-e.yxz),\n\t\tmap(p+e.zyx)-map(p-e.zyx)));\n}\n\nfloat getAmbiantOcclusion(vec3 p, vec3 n, float k)\n{\t\t\t\t\n    float o = 0.0, d = 0.0;\n    for(float diff = 0.0, c = 0.0; diff < 6.0; diff+=0.1, ++c)\n    {\n        d = map(p + n * diff);\n        o += (diff - d) * pow(2., float(-c));\n    }\n    return min(1., 1. - k * o);\n}\n\nfloat getShadow(vec3 ro, vec3 rd, float minD, float maxD, float k)\n{\n    float res = 1.0;\n    float d = minD;\n\tfloat s = 0.;\n    for(int i = 0; i < 50; ++i)\n    {\n        s = map(ro + rd * d);\n        if( abs(s) < d*d*1e-5 ) return 0.0;\n        res = min( res, k * s / d );\n\t\td += s;\n        if(d >= maxD) break;\n    }\n    return res;\n}\n\nbool march(vec3 ro, vec3 rd, float far, int iters, float prec, out float md)\n{\n\tmd = 0.0;\n\tfloat d = 0.0, s = 1.0;\n\tvec3 p = ro;\n\tfor (int i=0;i<iters;i++)\n\t{\n\t\tif (abs(s)<0.001) break;\n\t\tif (d > far) return false;\n\t\ts = map(p);\n\t\td += s * prec;\n\t\tp = ro+rd*d;\n\t}\n\tmd = d;\n\treturn true;\n}\n\nvec3 camera(vec2 g, vec2 s, vec3 ro, vec3 tgt, vec3 fov)\n{\n\tvec2 uv = (g * 2.0 - s)/s.y * fov.xy; \n\tvec3 z = normalize(tgt-ro);\n\tvec3 x = normalize(cross(vec3(0,1,0),z));\n\tvec3 y = cross(z, x);\n\treturn normalize(uv.x*x+uv.y*y+z*fov.z);\n}\n\nvec3 acesFilm(const vec3 x, float a, float b, float c, float d, float e) \n{\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}