{
    "Shader": {
        "info": {
            "date": "1713212701",
            "description": "Escher's Kubische Ruimteverdeling meets Interstellar Tesseract. Change iChannel0 if you don't have a webcam. Ps: how do I mirror wrap?",
            "flags": 2,
            "hasliked": 0,
            "id": "XfVGDG",
            "likes": 4,
            "name": "Escher Interstellar Tesseract",
            "published": 3,
            "tags": [
                "sdf",
                "texture",
                "escher",
                "tesseract",
                "interstellar"
            ],
            "usePreview": 0,
            "username": "matigekunstintelligentie",
            "viewed": 474
        },
        "renderpass": [
            {
                "code": "float a = -0.14; // value=-0.14, min=-1.0, max=1.0, step=0.01\nfloat b = 0.02; // value=0.02, min=-0.0, max=1.0, step=0.01\nfloat c = -0.02 ; // value=-0.02, min=-1.0, max=1.0, step=0.01\nfloat d = -0.08; // value=-0.08, min=-1.0, max=1.0, step=0.01\nfloat mobius = 1.; // value=1.0, min=0.0, max=1.0, step=0.01\nfloat colour = 1.; // value=1, min=0, max=1, step=1 (No, Yes)\n\n\n\n// Complex operators from Roy Wiggins\nvec2 cMul(vec2 a, vec2 b) {\n    return vec2( a.x*b.x -  a.y*b.y,a.x*b.y + a.y * b.x);\n}\n\nvec2 cInverse(vec2 a) {\n    return  vec2(a.x,-a.y)/dot(a,a);\n}\nvec2 cDiv(vec2 a, vec2 b) {\n    return cMul( a,cInverse(b));\n}\nvec2 cExp(in vec2 z){\n    return vec2(exp(z.x)*cos(z.y),exp(z.x)*sin(z.y));\n}\n\n\n\n// Raymarching code from Kishimisu\n\nfloat fov = 1.1;\n\nvec3 axis = vec3(1,0,0);\n\nfloat  sdSphere(vec3 p, float s){\n\treturn length(p) - s;\n}\n\nfloat max3 (vec3 v) {\n  return max (max (v.x, v.y), v.z);\n}\n\nfloat sdBox(vec3 p, vec3 b){\n\tvec3 q = abs(p) - b;\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat opUnion(float d1, float d2){\n\treturn min(d1, d2);\n}\n\nfloat opSubtraction(float d1, float d2){\n\treturn max(-d1, d2);\n}\n\nfloat opIntersection(float d1, float d2){\n\treturn max(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k){\n\tfloat h = clamp(0.5 + 0.5 * (d2-d1)/k, 0.0, 1.0);\n\treturn mix(d2, d1, h) - k*h*(1.0-h);\n}\n\nmat2 rot2D(float angle){\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\treturn mat2(c, -s, s, c);\n}\n\nmat3 rot3D(vec3 axis, float angle){\n\taxis = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat oc = 1.0 - c;\n\t\n\treturn mat3(\n\toc*axis.x*axis.x+c,\n\toc*axis.x*axis.y-axis.z*s,\n\toc*axis.z*axis.x+axis.y*s,\n\toc*axis.x*axis.y+axis.z*s,\n\toc*axis.y*axis.y+c,\n\toc*axis.y*axis.z-axis.x*s,\n\toc*axis.z*axis.x-axis.y*s,\n\toc*axis.y*axis.z+axis.x*s,\n\toc*axis.z*axis.z+c\n\t);\n}\n\nvec3 rot3D(vec3 p, vec3 axis, float angle){\n\treturn mix(dot(axis,p)*axis, p, cos(angle)) + cross(axis, p) * sin(angle);\n}\n\nfloat map(vec3 p){\n\tp = mod(p, 1.) - 0.5;\n\t\n\tfloat rightbox = sdBox(p, vec3(0.5,0.05 ,0.05));\n\tfloat topbox = sdBox(p, vec3(0.05,0.5 ,0.05));\n\tfloat backbox = sdBox(p, vec3(0.05,0.05 ,0.5));\n\t\n\t\n\t\n\tfloat t = iTime;\n\tfloat f = 6.;\n\tif(mod(iTime + 0.5,f) < f/2.){\n\t\tt = -iTime;\n\t}\n\t\n\t\n\tfloat mainbox = sdBox(vec3((mod(p.x+t,1.)-0.5),p.y,p.z), vec3(0.15,0.15 ,0.15));\n\t\n\tf = 2.;\n\tif(mod(iTime + 0.5,f) < f/2.){\n\t\tmainbox = sdBox(vec3(p.x,(mod(p.y+t,1.)-0.5),p.z), vec3(0.15,0.15 ,0.15));\n\t}\n\t\n\n\n\treturn opSmoothUnion(min(min(rightbox, topbox),backbox),mainbox, 0.05);\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+iTime*0.1+d) );\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = map(p) - \n        vec3(map(p-e.xyy), map(p-e.yxy),map(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float slow_time = 0.25*iTime;\n    vec3 final_col = vec3(0.);\n    int AA = 2;\n    for( int m=0; m<AA; m++ ){\n        for( int n=0; n<AA; n++ ){\n            // Screen coordinate (from [-aspect, -1] to [aspect, 1])\n\n            vec2 uv   = (2.0*(gl_FragCoord.xy+vec2(float(m),float(n))/float(AA))-iResolution.xy) / iResolution.y;\n\n\n\n            uv = mix(uv,cDiv(a*uv + b, c*uv + d),mobius);\n\n\n            // Initialisation\n            vec3 ro = vec3(0, 0,-7. * (0.5 + 0.5*cos(slow_time*0.4)));\n            vec3 rd = normalize(vec3(uv * fov, 1));\n\n\n            ro.xyz *= rot3D(vec3(10.*cos(slow_time*0.14),10.*cos(slow_time*0.15),10.*cos(slow_time*0.16)),slow_time*0.5); \n            rd.xyz *= rot3D(vec3(10.*cos(slow_time*0.13),10.*cos(slow_time*0.12),10.*cos(slow_time*0.11)),slow_time*0.5);\n\n            float t = 0.05;\n\n            vec3 col = vec3(0.);\n\n            int i ;\n            // Raymarching\n            for(i = 0; i<150; i++){\n                vec3 p = ro + rd*t; // position along the ray\n\n                p.y += (cos(t + iTime*0.7)*0.2)*(0.5+0.5*cos(iTime*0.13));\n                p.x += (sin(t + iTime*0.6)*0.2)*(0.5+0.5*cos(iTime*0.11));\n\n                float d = map(p);\n                vec3 n = GetNormal(p);\n\n                t += d;\n\n                uv = gl_FragCoord.xy/iResolution.xy;\n\n                vec3 colXY = texture(iChannel0, p.xy * 2.5 + 0.5).rgb;\n                vec3 colYZ = texture(iChannel0, p.yz * 2.5 + 0.5).rgb;\n                vec3 colXZ = texture(iChannel0, p.xz * 2.5 + 0.5).rgb;\n\n                n = abs(n);\n                col = (colXY*n.z + colYZ*n.x + colXZ*n.y);\n\n                if (d<.0001 || t>100.){\n                    break;\n                }\n            }\n            final_col += col;\n        }\n\t}\n    \n    \n    final_col/=float(AA*AA);\n\n\t\t\n\tfragColor = vec4(final_col,1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "webcam",
                        "id": 31,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/presets/webcam.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}