{
    "Shader": {
        "info": {
            "date": "1602028741",
            "description": "Recursively tiling this hexadrafter irreptile from George Sicherman [url]https://userpages.monmouth.com/~colonel/drirrep/index.html[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "tddyWl",
            "likes": 51,
            "name": "Irreptile Triangle",
            "published": 3,
            "tags": [
                "irreptile"
            ],
            "usePreview": 0,
            "username": "tdhooper",
            "viewed": 1117
        },
        "renderpass": [
            {
                "code": "/*\n\n    Irreptile Triangle\n    ------------------\n\n    Recursively tiling this hexadrafter irreptile from George Sicherman\n    https://userpages.monmouth.com/~colonel/drirrep/index.html\n\n*/\n\n// Polygon distance, iq https://www.shadertoy.com/view/wdBXRW\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cross2d( in vec2 v0, in vec2 v1) { return v0.x*v1.y - v0.y*v1.x; }\n\nconst int N = 6;\n\nfloat sdPoly( in vec2[N] v, in vec2 p )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n    }\n    \n    return s*sqrt(d);\n}\n\n\n// Spectrum palette, iq https://www.shadertoy.com/view/ll2GD3\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return 1. - pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n\n#define PI 3.14159265359\n\n\n// MATRIX\n\nmat3 trs(vec2 t) {\n\treturn mat3(1, 0, t.x, 0, 1, t.y, 0, 0, 1);\n}\n\nmat3 rot(float a) {\n\treturn mat3(cos(a), -sin(a), 0, sin(a), cos(a), 0, 0, 0, 1);\n}\n\nmat3 scl(vec2 s) {\n\treturn mat3(s.x, 0, 0, 0, s.y, 0, 0, 0, 1);\n}\n\nfloat decomposeScale(mat3 m) {\n\tvec3 a = vec3(0) * m;\n\tvec3 b = vec3(1,0,0) * m;\n    return distance(a, b);\n}\n\n\n// MAIN\n\nconst int count = 11;\nmat3 tiles[count];\n\nfloat h = sqrt(3.) / 2.;\n\nfloat sdTile(vec2 p) {\n    vec2[] poly = vec2[](\n    \tvec2(0, 0),\n        vec2(2.5, 0),\n        vec2(2.5 - .25, -h / 2.),\n        vec2(1.5 - .25, -h / 2.),\n        vec2(1., -h),\n        vec2(.5, -h)\n    );\n\treturn sdPoly(poly, p);\n}\n\n//#define LOOP\n\nvec3 shadeTile(float d, float s, int i, int iteration) {\n    d = -d;\n    d *= iResolution.y * 2. / s;\n    d += .001 * iResolution.y;\n    //d += (.002 / s + .0008)  * iResolution.y;\n    d = clamp(d, 0., 1.) / 4.;\n    float t = float(i);\n    #ifdef LOOP\n        float time = mod(iTime / 3., 1.);\n        if (iteration > 0) {\n            t /= float(count);\n        } else {\n            t /= 3.;\n        }\n    \t//t *= 1.666;\n        t += time;\n    #else\n        if (iteration > 0) {\n            t /= float(count);\n            t = t * mix(1., 10., cos(iTime / 10.) * .5 + .5);\n        } else {\n            t /= 3.;\n        }\n        t += iTime / 3.;\n    #endif\n    vec3 col = d * spectrum(t);\n    return col;\n}\n\nbool drawTiles(inout vec2 p, inout vec3 col, inout float scale, int iteration) {\n    \n\tfloat scaleOut;\n    vec2 pOut;\n    bool hit = false;\n    \n    vec2 p2 = p;\n    float scale2 = scale;\n\n    for(int i = 0; i < count; i++ )\n    {\n        mat3 txm = tiles[i];\n        p = (vec3(p2, 1) * txm).xy;\n        scale = scale2 * decomposeScale(txm);\n\n        float d = sdTile(p);\n        col -= shadeTile(d, scale, i, iteration);\n\n        if (d < 0.) {\n            pOut = p;\n\t\t\tscaleOut = scale;\n            hit = true;\n        }\n        \n        if (iteration == 0 && i == 2) {\n        \tbreak;\n        }\n    }\n    \n    p = pOut;\n    scale = scaleOut;\n\n    return hit;\n}\n\nvec3 render(vec2 p) {\n\n    float scale = 1.;\n    vec3 col = vec3(1);\n\n    // recurse\n    for(int i = 0; i < 4; i++) {\n        if ( ! drawTiles(p, col, scale, i)) {\n            if (i == 0) {\n            \tcol = vec3(.8);\n            }\n            break;\n        }\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\tp *= .55;\n    p *= vec2(1,-1);\n    p -= vec2(-.5,h/2.);\n    \n    \n    // prepare matrices\n    \n    // tri\n    mat3 triOrigin = trs(vec2(-.5, sqrt(3.) / 6.)) * scl(vec2(3));\n    tiles[0] = triOrigin * trs(vec2(1., -h));\n    tiles[1] = triOrigin * rot(PI / 1.5) * trs(vec2(1., -h));\n    tiles[2] = triOrigin * rot(PI / -1.5) * trs(vec2(1., -h));\n    \n    // long\n    mat3 rect = trs(vec2(-3.5, h)) * scl(vec2(-1));\n    mat3 longOrigin = scl(vec2(3. / 1.5)) * trs(vec2(-5, 0)) * scl(vec2(-1, 1));\n    tiles[3] = longOrigin;\n    tiles[4] = tiles[3] * rect;\n    \n    // box\n    mat3 boxOrigin = trs(vec2(-.5, h)) * scl(vec2(1.5 / .25));\n    tiles[5] = boxOrigin * rot(PI / -3.);\n    tiles[6] = tiles[5] * rect;\n    tiles[7] = boxOrigin * trs(vec2(-1, 0)) * rot(PI / -3.);\n    tiles[8] = tiles[7] * rect;\n    tiles[9] = boxOrigin * trs(vec2(-2, 0)) * rot(PI / -3.);\n    tiles[10] = tiles[9] * rect;\n\n    \n    // draw\n    \n   \tvec3 col = render(p);\n    col = pow(col, vec3(1./2.2));\n    fragColor = vec4(col, 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}