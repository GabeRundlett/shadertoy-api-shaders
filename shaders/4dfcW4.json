{
    "Shader": {
        "info": {
            "date": "1488136720",
            "description": "Попытка разобраться как работает шейдер пламени",
            "flags": 0,
            "hasliked": 0,
            "id": "4dfcW4",
            "likes": 10,
            "name": "Coldshine: Flame explained",
            "published": 3,
            "tags": [
                "3d"
            ],
            "usePreview": 0,
            "username": "coldshine",
            "viewed": 571
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265\n\n/**\n *   Original: https://www.shadertoy.com/view/MdX3zr\n *   Попытка разобраться как работает шейдер пламени\n */\n\n\n/**\n * Функция генерации шума. Алгоритм:\n * 1. делим пространство на кубическую (т.к. 3D-шейдер) сетку\n * 2. находим некий псевдо-случайный угол для каждой вершины куба\n * 3. находим косинус псевдо-случайного угла для каждой вершины\n * 4. находим псевдо-случайное значеие для точки в кубе: \n *    - находим проекцию на горизонтальные ребра куба (интерполяция по x)\n *    - находим проекцию на перднюю и заднюю грань куба (интерполяция по y)\n *    - находим точку между передней и задней гранью (интерполяция по z)\n */\nfloat hash(float angle) {\n    return sin(cos(angle) * angle);\n}\n\nfloat valueNoise(vec3 currentRayPosition)\n{\n    // найдем координаты куба в котором находится currentRayPosition\n    \n    // вначале находим дальнюю левую нижнюю точку сетки куба:\n    vec3 integer = floor(currentRayPosition); \n    \n    // находим локальную позицию точки внутри куба\n    // можно было бы записать так:\n    // vec3 f = currentRayPosition - integer\n    // но можно проще, что равносильно:\n    vec3 f = fract(currentRayPosition);\n    \n    // в пределах куба f изменяется линейно, от 0 до 1\n    // мы можем использовать f в качестве функции для интерполяции \n    // то есть по f будем находить псевдо-рандомное значение для каждой точки куба\n    \n    // в оригинале - косинусная интерполяция, \n\t// vec3 f = cos(fractional * PI)*(-.5)+.5;    \n    // которая дает более сглаженый шум в сравнении с линейным:\n    // https://www.desmos.com/calculator/8zudfzbmyd\n    // но на данном шейдере разницы практически не заметно\n    // подробнее про функции интерполяции:\n    // http://paulbourke.net/miscellaneous/interpolation/\n    \n    float dx = 1.;   // изменение (дельта) угла по оси x\n    float dy = 57.;  // изменение (дельта) угла по оси y\n    float dz = 21.;  // изменение (дельта) угла по оси z\n    \n    // угол = скалярному произведению вектора i и вектора значений изменения угла\n    float angle = dot(integer, vec3(dx, dy, dz));\n    \n    // находим косинус для каждого угла по формуле y = sin(cos(x) * x), график функции \n    // https://www.desmos.com/calculator/nhkq8uwxqm\n    // для дальней стороны куба\n    float fbl = angle; // нижний левый угол\n    float fbr = angle + dx; // нижний правый\n    float ftl = angle + dy; // верхний левый\n    float ftr = angle + dy + dx; // верхний правый\n\n    // и для ближней стороны куба\n    float nbl = angle + dz; // нижний левый угол\n    float nbr = angle + dz + dx; // нижний правый\n    float ntl = angle + dz + dy; // верхний левый\n    float ntr = angle + dz + dy + dx; // верхний правый  \n\n    // находим проекцию точки на горизонтальные грани  интерполируя от левого к правому углу \n    // для дальней стороны\n    float ft = mix(hash(fbl), hash(fbr), f.x);\n    float fb = mix(hash(ftl), hash(ftr), f.x);\n    // и ближней\n    float nt = mix(hash(nbl), hash(nbr), f.x);\n    float nb = mix(hash(ntl), hash(ntr), f.x);\n    \n    // находим проекцию точки на сторону куба интерполируя от проекции на верхней грани к нижней\n    // для дальней стороны\n    float far = mix(ft, fb, f.y);\n    // и ближней     \n    float near = mix(nt, nb, f.y); \n    \n    // находим значение для точки интерполируя от дальней стороне куба к ближней     \n    float result = mix(far, near, f.z);\n    return result;\n}\n\nvec2 rotate(vec2 p, float theta) {\n\treturn vec2(\n\t\tp.x*cos(theta)+p.y*sin(theta),\n\t\tp.x*sin(theta)-p.y*cos(theta)\n\t);\n}\n\n\nfloat makeNoise(vec3 currentRayPosition) {\n    vec3 currentRayPositionForFlame = currentRayPosition;\n    currentRayPositionForFlame.y += iTime*2.;\n    \n    // первая октава шума Перлина\n    // http://libnoise.sourceforge.net/glossary/#octave\n    float distanceToFlame = valueNoise(currentRayPositionForFlame);\n    \n    // вторая октава\n    // 3 - частота (чем больше - тем больше зернистость, или деформация)\n    // 0.5 - сокращает амплитуду на 2 (чем меньше - тем больше скученность) \n    distanceToFlame += valueNoise(currentRayPosition*3.) * 0.5;\n\n    // придаем форму пламени\n    // с увеличением Y, увеличивается площадь по xz\n    distanceToFlame *= currentRayPosition.y * .25;\n\treturn distanceToFlame;\n}\n\n\n// signed-distance function - функция расстояния до сферы по признаку\n// currentRayPosition - это текущая позиция конкретного луча\nfloat sdSphere(vec3 currentRayPosition)\n{\n    float sphereRadius = 1.; // радиус сферы\n    vec3 spherePosition = vec3(0.0, 1., 0.0); //координаты сферы    \n    vec3 sphereModificator = vec3(1.0, 0.5, 1.0); //вытягиваем сферу по y (также влияет на пламя)\n    \n    float distanceToSphere = length(currentRayPosition * sphereModificator + spherePosition) - sphereRadius;\n    \n\treturn distanceToSphere; // внутри сферы < 0, на границе = 0, снаружи > 0\n}\n\n// signed distance function\n// функция расстояния до сферы с эффектом пламени\nfloat flame(vec3 currentRayPosition)\n{\n    // поворачиваем пламя по оси Y\n\t//currentRayPosition.xz = rotate(currentRayPosition.xz, iTime);\n    \n    float flameDistance = 0.;\n\tflameDistance += sdSphere(currentRayPosition);\n    flameDistance += makeNoise(currentRayPosition);\n        \n    // в итоге учитываем расстояние до сферы и до noise\n    // причем сфера и noise считаются как один объект\n    return flameDistance;\n}\n\n\n// signed distance function\n// сцена - то есть граница, за которой лучи перестают быть видимыми\nfloat scene(vec3 currentRayPosition)\n{\n    // abs - модуль, flameDistance всегда положительно\n    // значит пламя находится всегда в пределах сцены \n    float flameDistance = abs(flame(currentRayPosition)); \n    float rayMaxLength =  100.; // максимальная длина луча\n    \n    float cutoff = rayMaxLength - length(currentRayPosition);\n\t// если длина луча больше максимального значения (cutoff отрицательный) - \n    // отсекаем дальнейший рендеринг в raymarch условием if( distanceToScene > epsilon )\n    return min(cutoff, flameDistance); \n}\n\n\nvec4 raymarch(vec3 cameraOrigin, vec3 rayDirection)\n{\n    /**\n\t * Эта функция итеративно анализирует сцену \n     * чтобы приблизить ближайший момент достижения лучом поверхности\n\t */\n\tfloat distanceToScene = 0.0; \n    float color = 0.0; // если луч не достиг какого-либо объекта - возвращаем черный цвет\n    float epsilon = 0.02;\n\t\n    vec3 currentRayPosition = cameraOrigin; // луч начинает движение от камеры\n    \n    bool glowed = false;\n    \n    int maxRaySteps = 64; // максимальное число шагов луча\n\t\n    // с каждой итерацией двигаем луч дальше от камеры на расстояние = мин. дистанции до ближайшего объекта \n\tfor(int i=0; i<maxRaySteps; i++)\n\t{\n        \n\t\t// получаем расстояние от текущей позиции луча до сцены + погрешность epsilon \n        distanceToScene = scene(currentRayPosition) + epsilon;\n        \n        // двигаем луч в соответствии с направлением direction и шагом distanceToSphere (rayDirection направляет к текущему uv.xy)\n\t\tcurrentRayPosition += distanceToScene * rayDirection;\n        \n        // Если луч еще не преодалел максимальное значение\n\t\tif( distanceToScene > epsilon )\n\t\t{\n            float distanceToFlame = flame(currentRayPosition);\n            if(distanceToFlame < .0) {\n                // Луч достиг объекта пламени\n                // Ставим флаг что луч прошел сквозь пламя  \n\t\t\t\tglowed=true;\n            }\n            if (glowed) {\n                // Если наш луч начал проходить/прошел сквозь пламя\n                // увеличиваем интенсивность цвета от 0 до 63/64\n                // Чем дальше луч - тем ярче цвет\n            \tcolor = float(i) / float(maxRaySteps);\n            }\n\t\t}\n\t}\n\treturn vec4(currentRayPosition, color); // vec4(xyz позиция пикселя с формой, цвет)\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0; //[0,0] - центр, [-1,-1] < [uv.x,uv.y] < [1,1]\n\tuv.x *= iResolution.x/iResolution.y; //пропорции\n    \n    // Чтобы было 3D - нам нужно \"отодвинуть\" источник векторов (или лучей) от плоскости по оси z.\n\t// Для этого создаем камеру. От нее будем запускать лучи к нашим объектам.\n    // x - это сдвиг камеры по горизонтали, y - по вертикали, z - отдаляет или приближает камеру\n    // положительный z - право-сторонняя система координат, отрицательный - левосторонняя\n    vec3 cameraOrigin = vec3(0., -2. , 4.);\n\n    // Далее, нам нужно задать направление движения лучей от камеры к объектам\n    // Для этого используем нормализованный вектор rayDirection\n    // xy - это текущие координаты точки в uv\n    // коэффициент при x - сплющили поле зрения на 1.6\n    // -1 при y - инверсия, перевернули всю картинку кверх ногами\n    // z - направление движения луча, должно быть от камеры, то есть у cameraOrigin мы будем уменьшать z\n    // число z также влияет на поле зрения (как зум у фотокамеры)\n    // чем меньше z, тем больше поле зрения\n    // вспоминаем свойство нормализации - xyz изменяются пропорционально\n    // чем больше значение какого-либо компонента - тем меньше значение других компонентов\n    // соответственно uv.x, uv.y будут меньше чем на самом деле и вся сцена будет казаться меньше\n    vec3 rayDirection = normalize(vec3(uv.x*1.6, -uv.y, -1.5));\n\n    vec3 currentRayPosition = vec3(0.);\n    float shape = 0.;\n    float limits = 0.5;\n    // сужаем область raymarch до ~1/3 экрана (от -0.5 до 0.5)\n    if (uv.x > -limits && uv.x < limits) {\n\t    vec4 result = raymarch(cameraOrigin, rayDirection);\n    \n\t    currentRayPosition = result.xyz;\n        shape = result.w;\n    }\n    \n    vec3 orange = vec3(1.,.5,.1); // оранжевый цвет\n    vec3 blue = vec3(0.1,.5,1.); // голубой цвет\n    float colorChange = currentRayPosition.y*.02+.4;\n\n    vec3 blueToOrange = mix(orange, blue, colorChange); // 3 аргументом задаем формулу перехода из голубого цвета в ораньжевый\n    \n    vec3 black = vec3(0.); //цвет фона - черный\n\tvec3 result = mix(black, blueToOrange, pow(shape*2., 4.)); //добавляем плавный переход в черный    \n\t\n    fragColor = vec4(result, 1.0);    \n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}