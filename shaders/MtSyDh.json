{
    "Shader": {
        "info": {
            "date": "1508328081",
            "description": "A tiled version of improved perlin noise. Reference implementation: http://mrl.nyu.edu/~perlin/noise/ . Shader code based on https://www.shadertoy.com/view/XscGzl .",
            "flags": 0,
            "hasliked": 0,
            "id": "MtSyDh",
            "likes": 3,
            "name": "Tiled Improved Perlin Noise",
            "published": 3,
            "tags": [
                "noise",
                "tiled",
                "perlin",
                "improved"
            ],
            "usePreview": 0,
            "username": "VinceTavernier",
            "viewed": 684
        },
        "renderpass": [
            {
                "code": "// Permutation table\nconst int p[] = int[](151,160,137,91,90,15,\n   131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n   190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n   88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n   77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n   102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n   135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n   5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n   223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n   129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n   251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n   49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n   138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180);\n\n// Coordinate hashing function\nfloat gradient(int hash, vec3 unit)\n{\n\tint h = hash & 15;\n    float u = h<8 ? unit.x : unit.y,\n          v = h<4 ? unit.y : (h==12||h==14 ? unit.x : unit.z);\n    return ((h&1) == 0 ? u : -u) + ((h&2) == 0 ? v : -v);\n}\n\n// Smootherstep interpolant\nvec3 fade(vec3 t)\n{\n    return t*t*t*(t*(6.*t - 15.) + 10.);\n}    \n\n/**\n * The meat of it:\n *\n * It helps to visualize the unit cube:\n *\n *      (0,1,1)----------------(1,1,1)\n *        /|                     /|\n *       / |                    / |\n *      /  |                   /  |\n *     /   |                  /   |\n * (0,1,0)-+--------------(1,1,0) |\n *    |    |                 |    |\n *    |    |                 |    |\n *    |    |                 |    |\n *    | (0,0,1)--------------+-(1,0,1)\n *    |   /                  |   /\n *    |  /                   |  /\n *    | /                    | /\n *    |/                     |/ \n * (0,0,0)----------------(1,0,0)\n */\nfloat noise(in vec3 coord, in int N)\n{\n    coord *= float(N);\n    \n    ivec3 c = ivec3(coord);   // current cell\n    vec3 unit = fract(coord); // orientation in current cell\n   \n    vec3 unit_000 = unit;\n    vec3 unit_100 = unit - vec3(1, 0, 0);\n    vec3 unit_001 = unit - vec3(0, 0, 1);\n    vec3 unit_101 = unit - vec3(1, 0, 1);\n    vec3 unit_010 = unit - vec3(0, 1, 0);\n    vec3 unit_110 = unit - vec3(1, 1, 0);\n    vec3 unit_011 = unit - vec3(0, 1, 1);\n    vec3 unit_111 = unit - 1.;\n    \n    // Hash cell coordinates\n    int A = p[(c.x  ) % N] + c.y, AA = p[A % N] + c.z, AB = p[(A+1) % N] + c.z,\n        B = p[(c.x+1) % N] + c.y, BA = p[B % N] + c.z, BB = p[(B+1) % N] + c.z;\n\n    float x000 = gradient(p[(AA  ) % N], unit_000);\n\tfloat x100 = gradient(p[(BA  ) % N], unit_100);\n\tfloat x010 = gradient(p[(AB  ) % N], unit_010);\n\tfloat x110 = gradient(p[(BB  ) % N], unit_110);\n    float x001 = gradient(p[(AA+1) % N], unit_001);\n\tfloat x101 = gradient(p[(BA+1) % N], unit_101);\n\tfloat x011 = gradient(p[(AB+1) % N], unit_011);\n\tfloat x111 = gradient(p[(BB+1) % N], unit_111);\n\n    // Compute fade curves\n    vec3 w = fade(unit);\n    \n    return mix(mix(mix(x000, x100, w.x),\n                   mix(x010, x110, w.x),\n                   w.y),\n               mix(mix(x001, x101, w.x),\n                   mix(x011, x111, w.x),\n                   w.y),\n               w.z);\n}\t\n\nvoid mainImage(out vec4 O, in vec2 U)\n{\n    // Number of cells\n    int N = 64;\n    // 0-1 U\n    U /= iResolution.y;\n    \n    //U = fract(2.*U); // uncomment to check tiling\n    \n    // horizontal slice through 3D noise\n    vec3 coord = vec3(U, iTime/200.);\n    \n    O = .5*vec4(noise(coord, N))+.5;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}