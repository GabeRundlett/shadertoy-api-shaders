{
    "Shader": {
        "info": {
            "date": "1571048697",
            "description": "Camera calibration display HIL",
            "flags": 0,
            "hasliked": 0,
            "id": "3dGGWV",
            "likes": 1,
            "name": "Monitor HIL Texture",
            "published": 3,
            "tags": [
                "camera",
                "random",
                "calibration",
                "move"
            ],
            "usePreview": 0,
            "username": "mmichal",
            "viewed": 323
        },
        "renderpass": [
            {
                "code": "const int DIRECTION  = 1; // 1, 2, 3, 4;\nconst bool COLOR  = true;\n\n\n\n// Flolowing Antialiasing functions come from: \n// https://www.shadertoy.com/view/ltfXWS\nvec2 v2len(in vec2 a, in vec2 b) {\n    return sqrt(a*a+b*b);\n}\n\nvec4 textureBlocky(in sampler2D tex, in vec2 uv, in vec2 res, in bool color) {\n    uv *= res; // enter texel coordinate space.\n    vec2 seam = floor(uv+.5); // find the nearest seam between texels.\n    \n    // here's where the magic happens. scale up the distance to the seam so that all\n    // interpolation happens in a one-pixel-wide space.\n    uv = (uv-seam)/v2len(dFdx(uv),dFdy(uv))+seam;\n    uv = clamp(uv, seam-.5, seam+.5); // clamp to the center of a texel.\n    \n    if(color){\n    \treturn texture(tex, uv/res, -1000.); // convert back to 0..1 coordinate space.\n    } else {\n        return texture(tex, uv/res, -1000.).xxxx; // convert back to 0..1 coordinate space.\n    }\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    float zoom = 1.5;\t// 10x zoom on the texture in respect to x\n    float speed = 10.0; // 10 s to pass screen x resolution\n\n    zoom = 1./zoom;\n    vec2 uv = fragCoord/iResolution.x;\n    uv *= zoom;    \n    \n    if(DIRECTION == 1){\n        uv = vec2(uv.x+((iTime/speed)*zoom), uv.y);\n        fragColor = textureBlocky(iChannel0, uv, iChannelResolution[0].xy, COLOR);\n    } else if(DIRECTION == 2){\n        uv = vec2(uv.x-((iTime/speed)*zoom), uv.y), \n        fragColor = textureBlocky(iChannel0, uv, iChannelResolution[0].xy, COLOR);\n    } else if(DIRECTION == 3){\n        uv = vec2(uv.y+((iTime/speed)*zoom), uv.x);\n        fragColor = textureBlocky(iChannel0, uv, iChannelResolution[0].xy, COLOR);\n    } else if(DIRECTION == 4){\n        uv = vec2(uv.y-((iTime/speed)*zoom), uv.x);\n        fragColor = textureBlocky(iChannel0, uv, iChannelResolution[0].xy, COLOR);\n    }else{\n    \tfragColor = vec4(1., 0., 0., 1.);\n    }\n\n   \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}