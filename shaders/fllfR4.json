{
    "Shader": {
        "info": {
            "date": "1650675805",
            "description": "Fun with circles and sine waves",
            "flags": 8,
            "hasliked": 0,
            "id": "fllfR4",
            "likes": 0,
            "name": "Blob Dance Party",
            "published": 3,
            "tags": [
                "2d",
                "circles"
            ],
            "usePreview": 0,
            "username": "cra_manning_w",
            "viewed": 233
        },
        "renderpass": [
            {
                "code": "//For the behavior of blob shape, see 'blobRadius()' and 'randBlob()'.\n//For the behavior of blob color, see 'colorBlob()'.\n//For the behavior of the lights, see 'genLighting()', 'getWorldLighting()', and 'getBlobLighting()'.\n\n///////////////////////\n//    Blob shape     //\n///////////////////////\n\n//The size of blobs relative to their cell.\n#define BLOB_AVERAGE_SIZE_PER_CELL_SIZE 0.4\n\n\n//A distorted circle.\nstruct Blob\n{\n    float initialRadius;\n    \n    Ripple fastRhythm;\n    float fastRhythmWeight;\n    \n    Ripple slowRhythm1, slowRhythm2;\n    float slowRhythmWeight;\n    \n    vec2 center;\n    float scale; //A bit redundant, but makes the shape much easier to manipulate\n};\n\n//Gets the oscillating effect from a blob's slow rhythms.\nfloat blobSlowRhythm(Blob blob, float thetaT)\n{\n    return blob.slowRhythmWeight * (\n        ripple(blob.slowRhythm1, thetaT, iTime) +\n        ripple(blob.slowRhythm2, thetaT + 0.4128901, iTime) //Arbitrary offset to keep the rhythms unaligned\n    );\n}\n//Gets the min/max of a blob's slow rhythm output.\nvec2 blobSlowRhythmRange(Blob blob)\n{\n    return blob.slowRhythmWeight *\n              (rippleRange(blob.slowRhythm1) +\n               rippleRange(blob.slowRhythm2));\n}\n\n//Gets the oscillating effect from a blob's fast rhythms.\nfloat blobFastRhythm(Blob blob, float thetaT)\n{\n    return blob.fastRhythmWeight *\n           ripple(blob.fastRhythm, thetaT, iTime);\n}\n//Gets the min/max of a blob's fast rhythm output.\nvec2 blobFastRhythmRange(Blob blob)\n{\n    return blob.fastRhythmWeight * rippleRange(blob.fastRhythm);\n}\n\n//Computes the blob's radius at a specific angle, determined by a direction vector.\nfloat blobRadius(Blob blob, vec2 offset)\n{\n    float thetaT = angleT(offset);\n    return blob.scale * (blob.initialRadius +\n                         blobSlowRhythm(blob, thetaT) +\n                         blobFastRhythm(blob, thetaT));\n}\n\n//Returns 1) the signed-distance to this blob,\n//        2) a 0-or-1 value indicating whether you're inside the blob.\nvec2 blobCollision(Blob blob, vec2 pos)\n{\n    vec2 relativePos = pos - blob.center;\n    float dist = length(relativePos),\n          radius = blobRadius(blob, relativePos);\n    \n    float signedDist = dist - radius;\n    float mask = 1.0 - max(0.0, sign(signedDist));\n    return vec2(signedDist, mask);\n}\n\n//Generates a randomized blob, given some uniform-random 0-1 values,\n//    and the range of possible values.\nBlob randBlob(vec3 rngSeeds,\n              vec2 rangeInitialRadius,\n              vec2 rangeFastPolyrhythm, vec2 rangeFastAmplitude, vec2 rangeFastSpikes,\n              vec2 rangeSlow1Speed, vec2 rangeSlow1Spikes,\n              vec2 rangeSlow2Speed, vec2 rangeSlow2Spikes,\n              vec2 rangeSlowAmplitude,\n              vec2 cellCenter, float cellSize)\n{\n    float halfCellSize = cellSize * 0.5;\n    \n    //Generate some random signals.\n    vec4 rng1 = hashTo4(rngSeeds * 7777.7777),\n         rng2 = hashTo4((rngSeeds.zxy + rng1.wxz) * 5555.5555),\n         rng3 = hashTo4((rngSeeds.yzx + rng1.yzw) * 8989.9898),\n         rng4 = hashTo4(rngSeeds.xzy * 5555.5555);\n\n    float polyrhythm = floor(mix(rangeFastPolyrhythm.x, rangeFastPolyrhythm.y, rng1.r));\n    float tempo = BLOB_TEMPO * polyrhythm;\n    \n    //The blob will wander around its center position.\n    //The wandering is based on sampling from a noise texture\n    //    (so we can take non-uniform sources like blue noise).\n    //Depends on linear sampling to get a smooth wandering.\n    float wanderSpeed = mix(0.001, 0.02, rng4.x),\n          wanderLookupAngle = PI2 * iTime * wanderSpeed;\n    vec2 wanderRadiusTexels = 10.0 / iChannelResolution[1].xy,\n         wanderLookupDir = vec2(cos(wanderLookupAngle), sin(wanderLookupAngle)),\n         wanderLookup = rng4.yz + (wanderRadiusTexels * wanderLookupDir);\n    vec4 wanderNoise = texture(iChannel1, wanderLookup);\n    vec2 wanderPosOffset = halfCellSize *\n                           mix(vec2(-0.5), vec2(0.5),\n                               smoothstep(0.0, 1.0, wanderNoise.xy));\n                               \n    vec2 blobCenter = cellCenter + wanderPosOffset +\n                      (halfCellSize * mix(vec2(-0.5), vec2(0.5), rng3.gb));\n    \n    return Blob(\n        mix(rangeInitialRadius.x, rangeInitialRadius.y, rng1.g),\n        //Fast rhythm:\n        Ripple(mix(rangeFastAmplitude.x, rangeFastAmplitude.y, rng1.b),\n               tempo,\n               int(mix(rangeFastSpikes.x, rangeFastSpikes.y, rng1.a)),\n               true),\n        1.0,\n        //Slow rhythms:\n        Ripple(1.0,\n               mix(rangeSlow1Speed.x, rangeSlow1Speed.y, rng2.r),\n               int(mix(rangeSlow1Spikes.x, rangeSlow1Spikes.y, rng2.g)),\n               false),\n        Ripple(1.0,\n               mix(rangeSlow2Speed.x, rangeSlow2Speed.y, rng2.b),\n               int(mix(rangeSlow2Spikes.x, rangeSlow2Spikes.y, rng2.a)),\n               false),\n        mix(rangeSlowAmplitude.x, rangeSlowAmplitude.y, rng3.r),\n        //Transform:\n        blobCenter,\n        BLOB_AVERAGE_SIZE_PER_CELL_SIZE * cellSize\n    );\n}\n\n\n\n////////////////////////\n//    Dance Floor     //\n////////////////////////\n\n//A \"dance floor\" is split into a grid,\n//    and N blobs are generated within each grid.\n//The blobs wander back and forth by using a position offset,\n//    taken by linear-sampling a noise texture.\n\n//The range/probability of blobs per-cell are kept constant to make the code simpler (and faster).\n//The number of blobs for a specific cell is computed as a random value within this range, floored to integer.\n#define BLOBS_COUNT_MIN 0.2   /* Chance of 0 blobs in a cell */\n#define BLOBS_COUNT_MAX 1.5\n#define N_MAX_BLOBS (int(BLOBS_COUNT_MAX))\n\nstruct DanceFloor\n{\n    float cellSize;\n    float seed;\n\n    //Each dance floor gets a pseudo-random offset to help hide the grid alignment.\n    vec2 offset;\n};\n\n//Generates a dance floor with a pseudo-random offset.\nDanceFloor makeDanceFloor(float cellSize, float seed)\n{\n    return DanceFloor(cellSize, seed,\n                      cellSize * fract(seed * vec2(9999.2374, 4444.98725)));\n}\n\nvec2 danceFloorCellIndex(DanceFloor df, vec2 pos) { return floor((pos - df.offset) / df.cellSize); }\nvec2 danceFloorCellPos(DanceFloor df, vec2 cellIdx) { return ((cellIdx + 0.5) * df.cellSize) + df.offset; }\n\n//Generates the blobs for a specific dance floor cell.\n//The cell index should be integers, but is passed as floats for simplicity.\nvoid blobsInCell(DanceFloor danceFloor, vec2 cellIndex,\n                 out int nBlobs, out Blob blobs[N_MAX_BLOBS])\n{\n    vec3 noiseInput = vec3((cellIndex * 2.952832938), danceFloor.seed);\n    \n    nBlobs = int(mix(BLOBS_COUNT_MIN, BLOBS_COUNT_MAX, hashTo1(noiseInput * 888.888)));\n   \n    vec2 cellCenter = danceFloorCellPos(danceFloor, cellIndex);\n    for (int i = 0; i < min(N_MAX_BLOBS, nBlobs); ++i) //Explicitly limit the iterations to a hard-coded max,\n    {                                                  //    in case that helps the compiler optimize/unroll\n        blobs[i] = randBlob(\n            hashTo3(vec3(hashTo1(noiseInput.xy * 9191.1919),\n                         noiseInput.z * 1919.9191,\n                         float(i * 3000))),\n            \n            //Radius:\n            vec2(0.87, 1.2),\n            \n            //Fast:\n            vec2(1.0, 3.99999), vec2(0.02, 0.2), vec2(2.0, 6.75),\n            \n            //Slow1:\n            vec2(0.175, 0.25), vec2(1.0, 4.5),\n            //Slow2:\n            vec2(0.3, 0.4), vec2(1.0, 4.15),\n            //Slow general:\n            vec2(0.2, 0.4),\n            \n            //Transform data:\n            cellCenter, danceFloor.cellSize\n        );\n    }\n}\n\n//Describes a specific point inside a blob.\nstruct BlobHit\n{\n    vec2 cellIndex;\n    float blobIndex;\n    \n    float blobRadius;\n    \n    //The point, relative to the blob's center.\n    vec2 posOffset;\n    //The point's distance from the blob center.\n    float dist;\n};\n\n//Finds which blob in the dance floor a given position is touching.\n//Returns whether any such blob was found, and outputs data about the blob into an 'out' variable.\nbool danceFloorBlobAt(DanceFloor danceFloor, vec2 pos,\n                      out BlobHit hitData, out Blob blobData, out int blobIdx)\n{\n    vec2 cellIndex = danceFloorCellIndex(danceFloor, pos);\n    cellIndex = floor(cellIndex);\n    \n    //Check the neighboring cells as well as this one, to handle blobs near the boundary.\n    for (int x = -1; x <= 1; ++x)\n    {\n        for (int y = -1; y <= 1; ++y)\n        {\n            vec2 neighborCellIndex = cellIndex + vec2(x, y);\n            \n            //Get the blobs in this cell.\n            int nBlobs;\n            Blob blobs[N_MAX_BLOBS];\n            blobsInCell(danceFloor, neighborCellIndex, nBlobs, blobs);\n                        \n            //Check for collision.\n            for (int i = 0; i < nBlobs; ++i) {\n                vec2 toPos = pos - blobs[i].center;\n                float radius = blobRadius(blobs[i], toPos);\n                float dist = length(toPos);\n                if (dist <= radius)\n                {\n                    blobIdx = i;\n                    blobData = blobs[i];\n                    hitData = BlobHit(neighborCellIndex, float(i),\n                                      radius, toPos, dist);\n                    return true;\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n\n\n//////////////////////////\n//    World lighting    //\n//////////////////////////\n\n//Computes the global \"ambient\" light brightness, from 0 to 1.\nfloat getGlobalLight(float time)\n{\n    //Define a bunch of cycling amplitudes.\n    //Mix them together in different ways (max, min, mul, add),\n    //    and then smoothly interpolate between the ways.\n    \n    float modeT = OSCILLATE(0.0, 1.0, time / 6.0);\n    \n    Ripple cycles[] = Ripple[](\n        Ripple(1.0, 0.7, 1, false),\n        Ripple(0.7, 0.1, 1, false),\n        Ripple(1.0, 0.6, 1, false),\n        Ripple(1.0, 0.3, 1, false)\n    );\n    \n    float rMin = 99999.999,\n          rMax = -99999.999,\n          rSum = 0.0,\n          rProd = 1.0;\n    for (int i = 0; i < cycles.length(); ++i)\n    {\n        float r = ripple(cycles[i], iTime, iTime);\n        rMin = min(rMin, r);\n        rMax = max(rMax, r);\n        rSum += r;\n        rProd *= r;\n    }\n\n    if (modeT < 0.33333)\n        return SATURATE(mix(rProd, rMin, INV_LERP(0.0, 0.33333, modeT)));\n    else if (modeT < 0.66667)\n        return SATURATE(mix(rMin, rSum, INV_LERP(0.33333, 0.66667, modeT)));\n    else\n        return SATURATE(mix(rSum, rMax, INV_LERP(0.66667, 1.0, modeT)));\n}\n\n\n//////////////////////////\n//    Floor lighting    //\n//////////////////////////\n\n\nconst vec3[] LIGHT_COLORS = vec3[](\n    vec3(1.0, 0.0, 0.0),\n    vec3(0.0, 1.0, 0.0),\n    vec3(1.0, 1.0, 0.0),\n    vec3(1.0, 0.0, 0.5),\n    vec3(0.0, 0.3, 1.0)\n);\n\n#define STREAK_THICKNESS 0.012\n\n//Party lighting for one dance floor.\nstruct FloorLighting\n{\n    vec3 dir;\n    vec2 offset;\n    int nStreaks;\n    float streaksAngleSpacing;\n    vec4 streakColor;\n};\n\n\n//Computes randomized lighting for a dance floor.\nFloorLighting genLighting(DanceFloor df, float time)\n{\n    //Change the lighting at regular intervals, based on tempo.\n    float lightingIdx = floor((time * BLOB_TEMPO * 0.5) +\n                              (0.2 * hashTo1(df.seed * 12.439782)));\n    \n    vec2 seeds = vec2(df.seed, lightingIdx);\n    vec4 rand1 = hashTo4(seeds * 4565.6545);\n    \n    float lightingAngle = PI2 * sign(rand1.x - 0.5) *\n                          mix(0.0, PI2/4.0, rand1.x);\n    \n    return FloorLighting(\n        vec3(cos(lightingAngle), sin(lightingAngle), -1.0),\n        mix(vec2(-0.5), vec2(0.5), hashTo2(rand1.xyz +\n                                           (rand1.w * df.seed) +\n                                           3453.34534)),\n        int(mix(0.0, 5.99999, rand1.y)),\n        PI2 * mix(0.01, 0.031, rand1.z),\n        vec4(RAND_IN_ARRAY(LIGHT_COLORS, rand1.w),\n             mix(0.5, 1.0, hashTo1((time * (df.seed + 0.1)) * 8979.7899)))\n    );\n}\n\n//Computes the influence of floor lighting on a given pixel,\n//    not including the light's effect on blobs.\nvec3 getWorldLighting(FloorLighting lights, vec2 pos)\n{\n    vec3 color = vec3(0.0);\n    //See if any streaks are passing through this position.\n    for (int i = 0; i < lights.nStreaks; ++i)\n    {\n        float angleOffset = lights.streaksAngleSpacing *\n                            float(i - (lights.nStreaks / 2)),\n              aSin = sin(angleOffset),\n              aCos = cos(angleOffset);\n        vec2 streakOrigin = (lights.dir.xy * -2.5) + lights.offset,\n             //Note that direction doesn't need to be normalized.\n             streakDir = normalize(mat2(aCos, aSin, -aSin, aCos) * lights.dir.xy);\n\n        float lineDist = distToLine(streakOrigin, streakDir, pos);\n        if (lineDist < STREAK_THICKNESS)\n        {\n            //The line gets weaker at the edges, and far from the source.\n            float lineStrength = (1.0 - (lineDist / STREAK_THICKNESS)) *\n                                 //Note: this second term can break if\n                                 //    the line is exactly vertical.\n                                 (1.0 - SATURATE((pos - streakOrigin).x / streakDir.x / 6.0));\n            color += lights.streakColor.rgb * lights.streakColor.a * lineStrength;\n        }\n    }\n    \n    return SATURATE(color);\n}\n\n//Computes the influence of floor lighting on the surface of a blob.\nvec3 getBlobLighting(FloorLighting lights, Blob blob, BlobHit hit,\n                     vec3 blobNormal, float globalAmbient)\n{\n    //Mute the party light's saturation when lighting a blob,\n    //    since blobs already have a specific color palette.\n    vec3 lightHSV = RGBtoHSV(lights.streakColor.rgb);\n    lightHSV.y /= mix(2.0, 8.0, 1.0 - globalAmbient);\n    vec3 lightColor = HSVtoRGB(lightHSV);\n    \n    //Augment the computed normal with a smooth dropoff\n    //    based on the side of the blob we are on.\n    float offsetNormalStrength = mix(9.0, 20.0, globalAmbient);\n    vec3 normal = normalize(blobNormal +\n                            vec3(hit.posOffset * offsetNormalStrength, 0.05));\n    \n    float ambient = 0.0,\n          diffuse = dot(normal, -lights.dir);\n    \n    return max(ambient, diffuse) * lightColor;\n}\n\n\n//////////////////////////\n//    Blob coloring     //\n//////////////////////////\n\n//Each blob takes from this palette.\n//I used an online palette generator to find these.\n#if 1\n    const vec3 BODY_PALETTE[] = vec3[](\n        vec3(1.000, 0.749, 0.718), //#FFBFB7\n        vec3(1.000, 0.792, 0.498), //#FFCA7F\n        vec3(1.000, 0.831, 0.278) //#FFD447\n    );\n    const vec3 BORDER_PALETTE[] = vec3[](\n        vec3(0.196, 0.051, 0.427), //#320D6D\n        vec3(0.369, 0.063, 0.165), //#5E102A\n        vec3(0.298, 0.110, 0.000) //#4C1C00\n    );\n    const vec3 DETAILS_PALETTE[] = vec3[](\n        vec3(0.600, 0.400, 0.573), //#996692\n        vec3(0.722, 0.424, 0.302), //#B86C4D\n        vec3(0.439, 0.012, 0.325) //#700353\n    );\n#elif 0\n    //TODO: Try some different palettes\n#else\n    #error No palette chosen!\n#endif\n\n\n//Computes the color for a point in a blob.\nvec3 colorBlob(DanceFloor floor, FloorLighting lighting, float worldAmbient,\n               Blob blob, BlobHit hit,\n               int floorIdx, int blobIdx)\n{\n    //Generate random numbers to color with.\n    vec3 rand1 = hashTo3(5120.0 *\n                           vec3(vec2(hit.cellIndex) / PI,\n                                hashTo1(vec2(floorIdx, blobIdx))));\n\n    //Pick a randomized palette.\n    //Bias each dance floor towards a specific palette.\n    vec3 paletteBias = hashTo3(float(floorIdx + 1) * 5434.3454);\n    #define PALETTE_T(noiseChannel) applyBias(rand1.noiseChannel, \\\n                                              paletteBias.noiseChannel, \\\n                                              0.45)\n    vec3 cBody = RAND_IN_ARRAY(BODY_PALETTE, PALETTE_T(x)),\n         cBorder = RAND_IN_ARRAY(BORDER_PALETTE, PALETTE_T(y)),\n         cDetails = RAND_IN_ARRAY(DETAILS_PALETTE, PALETTE_T(z));\n         \n    //Apply a floor-wide adjustment to the palette.\n    //HSV space is more convenient for this kind of work.\n    vec3 hsvBody = RGBtoHSV(cBody),\n         hsvBorder = RGBtoHSV(cBorder),\n         hsvDetails = RGBtoHSV(cDetails);\n    vec3 colorRand3 = hashTo3(7348.3498 * float(floorIdx)),\n         shiftRange = vec3(0.05, 0.1, 0.075),\n         shiftAmount = mix(-shiftRange, shiftRange, colorRand3);\n    hsvBody = SATURATE(hsvBody + shiftAmount);\n    hsvBorder = SATURATE(hsvBorder + shiftAmount);\n    hsvDetails = SATURATE(hsvDetails + shiftAmount);\n    cBody = HSVtoRGB(hsvBody);\n    cBorder = HSVtoRGB(hsvBorder);\n    cDetails = HSVtoRGB(hsvDetails);\n\n    //Simulate a bump-map via a scalar that tracks\n    //    whether the surface is facing inward or outward.\n    #define BUMP_STRENGTH 0.6\n    float bumpOutward = 0.0;\n\n    //Calculate some measurements.\n    float blobAverageRadius = blob.initialRadius * blob.scale;\n    float thetaT = angleT(hit.posOffset),\n          edgeT = hit.dist / hit.blobRadius,\n          circleT = hit.dist / blobAverageRadius;\n    float slowRhythm = blobSlowRhythm(blob, thetaT),\n          fastRhythm = blobFastRhythm(blob, thetaT);\n    vec2 slowRhythmRange = blobSlowRhythmRange(blob),\n         fastRhythmRange = blobFastRhythmRange(blob);\n    float slowRhythmT = INV_LERP(slowRhythmRange.x, slowRhythmRange.y, slowRhythm),\n          fastRhythmT = INV_LERP(fastRhythmRange.x, fastRhythmRange.y, fastRhythm);\n        \n\n    //Fade to the border color at the edge of the blob.\n    float borderMask = smoothstep(0.0, 1.0, pow(edgeT, 2.0 / floor.cellSize));\n    bumpOutward = SATURATE(pow(edgeT, 10.0)*5.0);\n    \n    //Add a \"rim\" circle.\n    //The circle has an inside dropoff, and an outside dropoff.\n    //It's positioned based on the blob's \"initialRadius\",\n    //    so it's circular and not affected by the rhythms,\n    //    but very small influences *are* added from rhythms to create more motion.\n    float perfectAlignment = pow(fastRhythmT * slowRhythmT, 2.5);\n    float innerEnd = OSCILLATE(mix(0.70, 0.60, perfectAlignment),\n                               0.72,\n                               fastRhythmT),\n          outerStart = OSCILLATE(0.75,\n                                 mix(0.77, 0.82, perfectAlignment),\n                                 slowRhythmT);\n    #define RIM_BUMP_STRENGTH 1.0\n    float blobCircleEndRadius = outerStart * blobAverageRadius;\n    //Define it as a piecewise equation with 3 parts:\n    //   1. inside the circle\n    //   2. on the border\n    //   3. outside the circle\n    float inCircleT = INV_LERP(0.0, innerEnd, circleT),\n          outCircleT = INV_LERP(blobCircleEndRadius, hit.blobRadius,\n                                hit.dist);\n    float pastInner = step(innerEnd, circleT),\n          pastOuter = step(outerStart, circleT);\n    vec3 circlePhases = vec3(1.0-pastInner,\n                             pastInner*(1.0-pastOuter),\n                             pastOuter);\n    #define INNER_SLOPE_EXP 5.0\n    #define OUTER_SLOPE_EXP 0.4\n    // Vary the rim strength based on the rhythms.\n    vec3 rimStrengthWeights = vec3(0.1,\n                                   0.85,\n                                   0.05),\n         rimStrengths = vec3(1.0,\n                             pow(slowRhythmT, 5.0),\n                             pow(fastRhythmT, 2.0));\n    float rimStrength = dot(rimStrengthWeights, rimStrengths) /\n                        (rimStrengthWeights.x + rimStrengthWeights.y + rimStrengthWeights.z);\n    vec3 perPhaseStrengths = rimStrength * vec3(\n        pow(inCircleT, INNER_SLOPE_EXP),\n        1.0,\n        pow(1.0 - outCircleT, OUTER_SLOPE_EXP)\n    );\n    vec3 perPhaseDerivative = rimStrength * RIM_BUMP_STRENGTH * vec3(\n        -(1.0 / innerEnd) * INNER_SLOPE_EXP *\n          pow(inCircleT, INNER_SLOPE_EXP-1.0),\n        0.0,\n        OUTER_SLOPE_EXP *\n          pow(-outCircleT + 1.0, OUTER_SLOPE_EXP - 1.0)\n    );\n    float rimMask = dot(circlePhases, perPhaseStrengths),\n          rimBump = clamp(dot(circlePhases, perPhaseDerivative), -1.0, 1.0);\n    //If the border bump and rim bump are pushing in the same direction,\n    //    average them together.\n    //Otherwise, take the larger of the two by magnitude.\n    bumpOutward = (sign(rimBump) != sign(bumpOutward)) ?\n                      (rimBump + bumpOutward)/2.0 :\n                      ((abs(rimBump) > abs(bumpOutward)) ?\n                           rimBump : bumpOutward);\n    \n    //TODO: Add an angle-based effect inside the rim.\n    \n    vec3 detailedBody = mix(cBody, cDetails, rimMask);\n    vec3 albedo = mix(detailedBody, cBorder, borderMask);\n    \n    //Add some lighting.\n    vec2 towardsOutside = normalize(hit.posOffset);\n    //TODO: Should the normal take into account the blob radius's changes? It fortunately has an analytical derivative.\n    vec3 normal = normalize(vec3(towardsOutside * bumpOutward,\n                                 1.0 / BUMP_STRENGTH));\n    vec3 lightColor = getBlobLighting(lighting, blob, hit, normal, worldAmbient);\n\n    return albedo * lightColor;\n}\n\n\n////////////////////////////\n//    Post-processing     //\n////////////////////////////\n\nvec3 postProcess(vec3 color)\n{\n    //Disable PP until I'm finished with lighting.\n    return color;\n\n    //Increase brightness and contrast.\n    vec3 colorHSV = RGBtoHSV(color);\n    colorHSV.z = smoothstep(0.0, 1.0, pow(colorHSV.z, 0.68));\n    color = HSVtoRGB(colorHSV);\n    \n    return color;\n}\n\n\n/////////////////\n//    main     //\n/////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float worldAmbient = getGlobalLight(iTime);\n    \n    //Set the background color to something neutral:\n    fragColor.rgb = vec3(0.23, 0.21, 0.25);\n    fragColor.a = 1.0;\n\n    vec2 uv = -1.0 + (2.0 * fragCoord/iResolution.xy);\n    uv.x *= iResolution.x/iResolution.y;\n\n    //Generate the dance floors, and collect the world lights.\n    #define N_FLOORS 5\n    DanceFloor floors[N_FLOORS];\n    FloorLighting floorLights[N_FLOORS];\n    vec3 worldLightColor = vec3(0.0);\n    for (int floorI = 0; floorI < N_FLOORS; ++floorI)\n    {\n        float floorT = float(floorI + 1) / float(N_FLOORS),\n              floorSize = pow(floorT, 1.6235) * 2.0,\n              floorSeed = float(floorI) * PHI * 1000.0;\n\n        floors[floorI] = makeDanceFloor(floorSize, floorSeed);\n        floorLights[floorI] = genLighting(floors[floorI], iTime);\n        \n        worldLightColor += getWorldLighting(floorLights[floorI], uv);\n    }\n    \n    //Render the blob at this pixel.\n    vec3 blobColor = vec3(0.0);\n    for (int floorI = 0; floorI < N_FLOORS; ++floorI)\n    {\n        DanceFloor df = floors[floorI];\n        \n        BlobHit blobHit;\n        Blob blob;\n        int blobI;\n        if (danceFloorBlobAt(df, uv, blobHit, blob, blobI))\n        {\n            FloorLighting lighting = floorLights[floorI];\n            \n            float floorT = float(floorI + 1) / float(N_FLOORS),\n                  fadeT = 1.0 - (floorT - (1.0 / float(N_FLOORS)));\n            blobColor = colorBlob(df, lighting, worldAmbient,\n                                  blob, blobHit,\n                                  floorI, blobI) *\n                           pow(fadeT, 0.75);//TODO: Check out this param\n            break;\n        }\n    }\n    \n    //Compute the final color.\n    fragColor.rgb = postProcess(SATURATE(blobColor + worldLightColor));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//TODO: Figure this all out.\n\n#define NOTE(Hz, amplitude) (sin(float(Hz) * PI2 * time) * float(amplitude))\n#define CHORD(Hz, weights, amplitude) \\\n    (float(amplitude) * dot(weights, \\\n                            sin(Hz * PI2 * time)))\n#define SHARPEN(x) (-1.0 + (2.0 * smoothstep(-1.0, 1.0, x)))\n\n#define MUSIC_TEMPO (BLOB_TEMPO / 4.0)\n\nfloat rhythm(float amp1, float amp2, float amp3, float amp4, float amp5, float amp6,\n             float time)\n{\n    float sum = NOTE(MUSIC_TEMPO * 1.0, amp1) + NOTE(MUSIC_TEMPO * 2.0, amp2) +\n                NOTE(MUSIC_TEMPO * 3.0, amp3) + NOTE(MUSIC_TEMPO * 4.0, amp4) +\n                NOTE(MUSIC_TEMPO * 5.0, amp5) + NOTE(MUSIC_TEMPO * 6.0, amp6);\n    return (0.5 + (0.5 * sum)) / (amp1 + amp2 + amp3 + amp4 + amp5 + amp6);\n}\n#define RHYTHM(amp1, amp2, amp3, amp4, amp5, amp6) rhythm(float(amp1), float(amp2), \\\n                                                          float(amp3), float(amp4), \\\n                                                          float(amp5), float(amp6), \\\n                                                          time)\n\n#define BEATS_PER_MEASURE 4\n#define MEASURE(n) SHARPEN(SHARPEN(0.5 + (0.5 * NOTE(MUSIC_TEMPO / (float(n) * float(BEATS_PER_MEASURE)), 1.0))))\n\nvec2 mainSound(int samp, float time)\n{\n    return vec2(0);\n    \n    float beat = CHORD(vec3(55, 110, 220),\n                       vec3(0.55, 0.35, 0.1),\n                       1.0) *\n                  //RHYTHM(1, 0, 0, 0, 0, 0) *\n                  MEASURE(1);\n    \n    \n    return vec2(beat);\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "\n///////////////////////\n//    Randomness     //\n///////////////////////\n\n// A modified version of this: https://www.shadertoy.com/view/4djSRW\n\n//Hash 1D from 1D-3D data\nfloat hashTo1(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nfloat hashTo1(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hashTo1(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//Hash 2D from 1D-3D data\nvec2 hashTo2(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvec2 hashTo2(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvec2 hashTo2(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//Hash 3D from 1D-3D data\nvec3 hashTo3(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\nvec3 hashTo3(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\nvec3 hashTo3(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n//Hash 4D from 1D-4D data\nvec4 hashTo4(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\nvec4 hashTo4(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\nvec4 hashTo4(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\nvec4 hashTo4(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\n//////////////////////\n//    Utilities     //\n//////////////////////\n\n#define PI 3.1415926535898\n#define PI2 (2.0 * PI)\n\n#define PHI 1.618033988\n\n\n#define OSCILLATE(a, b, input) (mix(a, b, 0.5 + (0.5 * cos(PI2 * (input)))))\n\n#define INV_LERP(a, b, x) ((x-a) / (b-a))\n#define SATURATE(x) clamp(x, 0.0, 1.0)\n\n#define RAND_IN_ARRAY(array, t) array[int(mix(0.0, float(array.length()) - 0.00001, t))]\n\n\n//Gets the angle of the given vector, in the range 0-1.\nfloat angleT(vec2 dir) { return 0.5 + (0.5 * atan(dir.y, dir.x)/PI); }\n\n//Given a uniformly-distributed value, and another target value,\n//    biases the uniform value towards the target.\n//The \"biasStrength\" should be between 0 and 1.\nfloat applyBias(float x, float target, float biasStrength)\n{\n    //Degenerative case if x=0.\n    if (x == 0.0)\n        return mix(x, target, biasStrength);\n    \n    //Get the \"scale\" of the target relative to x.\n    //Multiplying x by this number would give exactly the target.\n    float scale = target / x;\n    \n    //Weaken the \"scale\" by pushing it towards 1.0, then apply it to 'x'.\n    //Make sure to respect the sign, in case 'x' or 'target' is negative.\n    return x * sign(scale) * pow(abs(scale), biasStrength);\n}\n\nfloat distToLine(vec2 lineP, vec2 lineDir, vec2 pos)\n{\n    //Reference: https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\n    \n    vec2 numerator2 = lineDir * (lineP - pos).yx;\n    return abs(numerator2.x - numerator2.y) / length(lineDir);\n}\n\n//RGB<=>HSV converter, from here: https://stackoverflow.com/a/17897228\nvec3 RGBtoHSV(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\nvec3 HSVtoRGB(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n////////////////\n//   Ripple   //\n////////////////\n\n//An oscillating value, as a function of the angle around a circle.\nstruct Ripple\n{\n    float scale, speed;\n    int nSpikes;\n    bool canBeNegative;\n};\nfloat ripple(Ripple r, float angleT, float time)\n{\n    float inpt = (time * r.speed) +\n                  (angleT * float(r.nSpikes));\n    float minVal = (r.canBeNegative ? -r.scale : 0.0);\n    return OSCILLATE(minVal, r.scale, inpt);\n}\n\nvec2 rippleRange(Ripple r)\n{\n    return vec2(r.canBeNegative ? -r.scale : 0.0,\n                r.scale);\n}\n\n\n//////////////////////\n//    Constants     //\n//////////////////////\n\n//The speed at which blobs \"dance\".\n#define BLOB_TEMPO 2.0",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}