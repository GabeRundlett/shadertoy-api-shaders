{
    "Shader": {
        "info": {
            "date": "1614277755",
            "description": "How to best display out-of-gamut colors. \nmouse.y to choose ref vs 5 methods. bottom-left to go back to auto-demo.\n\nPorting to GLSL Björn Ottosson [url]https://bottosson.github.io/posts/gamutclipping/[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "tlKfDh",
            "likes": 3,
            "name": "sRGB gamut clipping",
            "published": 3,
            "tags": [
                "saturation",
                "lab",
                "colorspace",
                "gamutclipping"
            ],
            "usePreview": 1,
            "username": "FabriceNeyret2",
            "viewed": 538
        },
        "renderpass": [
            {
                "code": "// ported to GLSL from https://bottosson.github.io/posts/gamutclipping/\n\n/*\nCopyright (c) 2021 Björn Ottosson\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\n#define cbrtf(x)  ( sign(x)*pow(abs(x),1./3.) )\n#define FLT_MAX     3.402823466e+38\n\n\nstruct Lab {float L; float a; float b;};\nstruct RGB {float r; float g; float b;};\n\nLab linear_srgb_to_oklab(RGB c)\n{\n\tfloat l = 0.4122214708f * c.r + 0.5363325363f * c.g + 0.0514459929f * c.b;\n\tfloat m = 0.2119034982f * c.r + 0.6806995451f * c.g + 0.1073969566f * c.b;\n\tfloat s = 0.0883024619f * c.r + 0.2817188376f * c.g + 0.6299787005f * c.b;\n\n\tfloat l_ = cbrtf(l);\n\tfloat m_ = cbrtf(m);\n\tfloat s_ = cbrtf(s);\n\n\treturn Lab(\n\t\t0.2104542553f * l_ + 0.7936177850f * m_ - 0.0040720468f * s_,\n\t\t1.9779984951f * l_ - 2.4285922050f * m_ + 0.4505937099f * s_,\n\t\t0.0259040371f * l_ + 0.7827717662f * m_ - 0.8086757660f * s_\n\t);\n}\n\nRGB oklab_to_linear_srgb(Lab c)\n{\n    float l_ = c.L + 0.3963377774f * c.a + 0.2158037573f * c.b;\n    float m_ = c.L - 0.1055613458f * c.a - 0.0638541728f * c.b;\n    float s_ = c.L - 0.0894841775f * c.a - 1.2914855480f * c.b;\n\n    float l = l_ * l_ * l_;\n    float m = m_ * m_ * m_;\n    float s = s_ * s_ * s_;\n\n    return RGB(\n        +4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s,\n        -1.2684380046f * l + 2.6097574011f * m - 0.3413193965f * s,\n        -0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s\n    );\n}\n\n// Finds the maximum saturation possible for a given hue that fits in sRGB\n// Saturation here is defined as S = C/L\n// a and b must be normalized so a^2 + b^2 == 1\nfloat compute_max_saturation(float a, float b)\n{\n    // Max saturation will be when one of r, g or b goes below zero.\n\n    // Select different coefficients depending on which component goes below zero first\n    float k0, k1, k2, k3, k4, wl, wm, ws;\n\n    if (-1.88170328f * a - 0.80936493f * b > 1.)\n    {\n        // Red component\n        k0 = +1.19086277f; k1 = +1.76576728f; k2 = +0.59662641f; k3 = +0.75515197f; k4 = +0.56771245f;\n        wl = +4.0767416621f; wm = -3.3077115913f; ws = +0.2309699292f;\n    }\n    else if (1.81444104f * a - 1.19445276f * b > 1.)\n    {\n        // Green component\n        k0 = +0.73956515f; k1 = -0.45954404f; k2 = +0.08285427f; k3 = +0.12541070f; k4 = +0.14503204f;\n        wl = -1.2681437731f; wm = +2.6097574011f; ws = -0.3413193965f;\n    }\n    else\n    {\n        // Blue component\n        k0 = +1.35733652f; k1 = -0.00915799f; k2 = -1.15130210f; k3 = -0.50559606f; k4 = +0.00692167f;\n        wl = -0.0041960863f; wm = -0.7034186147f; ws = +1.7076147010f;\n    }\n\n    // Approximate max saturation using a polynomial:\n    float S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b;\n\n    // Do one step Halley's method to get closer\n    // this gives an error less than 10e6, except for some blue hues where the dS/dh is close to infinite\n    // this should be sufficient for most applications, otherwise do two/three steps \n\n    float k_l = +0.3963377774f * a + 0.2158037573f * b;\n    float k_m = -0.1055613458f * a - 0.0638541728f * b;\n    float k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n    {\n        float l_ = 1.f + S * k_l;\n        float m_ = 1.f + S * k_m;\n        float s_ = 1.f + S * k_s;\n\n        float l = l_ * l_ * l_;\n        float m = m_ * m_ * m_;\n        float s = s_ * s_ * s_;\n\n        float l_dS = 3.f * k_l * l_ * l_;\n        float m_dS = 3.f * k_m * m_ * m_;\n        float s_dS = 3.f * k_s * s_ * s_;\n\n        float l_dS2 = 6.f * k_l * k_l * l_;\n        float m_dS2 = 6.f * k_m * k_m * m_;\n        float s_dS2 = 6.f * k_s * k_s * s_;\n\n        float f  = wl * l     + wm * m     + ws * s;\n        float f1 = wl * l_dS  + wm * m_dS  + ws * s_dS;\n        float f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2;\n\n        S = S - f * f1 / (f1*f1 - 0.5f * f * f2);\n    }\n\n    return S;\n}\n\n// finds L_cusp and C_cusp for a given hue\n// a and b must be normalized so a^2 + b^2 == 1\nstruct LC { float L; float C; };\nLC find_cusp(float a, float b)\n{\n\t// First, find the maximum saturation (saturation S = C/L)\n\tfloat S_cusp = compute_max_saturation(a, b);\n\n\t// Convert to linear sRGB to find the first point where at least one of r,g or b >= 1:\n\tRGB rgb_at_max = oklab_to_linear_srgb(Lab( 1., S_cusp * a, S_cusp * b ));\n\tfloat L_cusp = cbrtf(1.f / max(max(rgb_at_max.r, rgb_at_max.g), rgb_at_max.b));\n\tfloat C_cusp = L_cusp * S_cusp;\n\n\treturn LC( L_cusp , C_cusp );\n}\n\n// Finds intersection of the line defined by \n// L = L0 * (1 - t) + t * L1;\n// C = t * C1;\n// a and b must be normalized so a^2 + b^2 == 1\nfloat find_gamut_intersection(float a, float b, float L1, float C1, float L0)\n{\n\t// Find the cusp of the gamut triangle\n\tLC cusp = find_cusp(a, b);\n\n\t// Find the intersection for upper and lower half seprately\n\tfloat t;\n\tif (((L1 - L0) * cusp.C - (cusp.L - L0) * C1) <= 0.f)\n\t{\n\t\t// Lower half\n\n\t\tt = cusp.C * L0 / (C1 * cusp.L + cusp.C * (L0 - L1));\n\t}\n\telse\n\t{\n\t\t// Upper half\n\n\t\t// First intersect with triangle\n\t\tt = cusp.C * (L0 - 1.f) / (C1 * (cusp.L - 1.f) + cusp.C * (L0 - L1));\n\n\t\t// Then one step Halley's method\n\t\t{\n\t\t\tfloat dL = L1 - L0;\n\t\t\tfloat dC = C1;\n\n\t\t\tfloat k_l = +0.3963377774f * a + 0.2158037573f * b;\n\t\t\tfloat k_m = -0.1055613458f * a - 0.0638541728f * b;\n\t\t\tfloat k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n\t\t\tfloat l_dt = dL + dC * k_l;\n\t\t\tfloat m_dt = dL + dC * k_m;\n\t\t\tfloat s_dt = dL + dC * k_s;\n\n\t\t\t\n\t\t\t// If higher accuracy is required, 2 or 3 iterations of the following block can be used:\n\t\t\t{\n\t\t\t\tfloat L = L0 * (1.f - t) + t * L1;\n\t\t\t\tfloat C = t * C1;\n\n\t\t\t\tfloat l_ = L + C * k_l;\n\t\t\t\tfloat m_ = L + C * k_m;\n\t\t\t\tfloat s_ = L + C * k_s;\n\n\t\t\t\tfloat l = l_ * l_ * l_;\n\t\t\t\tfloat m = m_ * m_ * m_;\n\t\t\t\tfloat s = s_ * s_ * s_;\n\n\t\t\t\tfloat ldt = 3. * l_dt * l_ * l_;\n\t\t\t\tfloat mdt = 3. * m_dt * m_ * m_;\n\t\t\t\tfloat sdt = 3. * s_dt * s_ * s_;\n\n\t\t\t\tfloat ldt2 = 6. * l_dt * l_dt * l_;\n\t\t\t\tfloat mdt2 = 6. * m_dt * m_dt * m_;\n\t\t\t\tfloat sdt2 = 6. * s_dt * s_dt * s_;\n\n\t\t\t\tfloat r = 4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s - 1.;\n\t\t\t\tfloat r1 = 4.0767416621f * ldt - 3.3077115913f * mdt + 0.2309699292f * sdt;\n\t\t\t\tfloat r2 = 4.0767416621f * ldt2 - 3.3077115913f * mdt2 + 0.2309699292f * sdt2;\n\n\t\t\t\tfloat u_r = r1 / (r1 * r1 - 0.5f * r * r2);\n\t\t\t\tfloat t_r = -r * u_r;\n\n\t\t\t\tfloat g = -1.2681437731f * l + 2.6097574011f * m - 0.3413193965f * s - 1.;\n\t\t\t\tfloat g1 = -1.2681437731f * ldt + 2.6097574011f * mdt - 0.3413193965f * sdt;\n\t\t\t\tfloat g2 = -1.2681437731f * ldt2 + 2.6097574011f * mdt2 - 0.3413193965f * sdt2;\n\n\t\t\t\tfloat u_g = g1 / (g1 * g1 - 0.5f * g * g2);\n\t\t\t\tfloat t_g = -g * u_g;\n\n\t\t\t\tfloat b = -0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s - 1.;\n\t\t\t\tfloat b1 = -0.0041960863f * ldt - 0.7034186147f * mdt + 1.7076147010f * sdt;\n\t\t\t\tfloat b2 = -0.0041960863f * ldt2 - 0.7034186147f * mdt2 + 1.7076147010f * sdt2;\n\n\t\t\t\tfloat u_b = b1 / (b1 * b1 - 0.5f * b * b2);\n\t\t\t\tfloat t_b = -b * u_b;\n\n\t\t\t\tt_r = u_r >= 0.f ? t_r : FLT_MAX;\n\t\t\t\tt_g = u_g >= 0.f ? t_g : FLT_MAX;\n\t\t\t\tt_b = u_b >= 0.f ? t_b : FLT_MAX;\n\n\t\t\t\tt += min(t_r, min(t_g, t_b));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn t;\n}\n\n/*\nfloat clamp(float x, float min, float max)\n{\n\tif (x < min)\n\t\treturn min;\n\tif (x > max)\n\t\treturn max;\n\n\treturn x;\n}\n\nfloat sgn(float x)\n{\n\treturn (float)(0.f < x) - (float)(x < 0.f);\n}\n*/\n\nRGB gamut_clip_preserve_chroma(RGB rgb)\n{\n\tif (rgb.r < 1. && rgb.g < 1. && rgb.b < 1. && rgb.r > 0. && rgb.g > 0. && rgb.b > 0.)\n\t\treturn rgb;\n\n\tLab lab = linear_srgb_to_oklab(rgb);\n\n\tfloat L = lab.L;\n\tfloat eps = 0.00001f;\n\tfloat C = max(eps, sqrt(lab.a * lab.a + lab.b * lab.b));\n\tfloat a_ = lab.a / C;\n\tfloat b_ = lab.b / C;\n\n\tfloat L0 = clamp(L, 0., 1.);\n\n\tfloat t = find_gamut_intersection(a_, b_, L, C, L0);\n\tfloat L_clipped = L0 * (1. - t) + t * L;\n\tfloat C_clipped = t * C;\n\n\treturn oklab_to_linear_srgb(Lab( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nRGB gamut_clip_project_to_0_5(RGB rgb)\n{\n\tif (rgb.r < 1. && rgb.g < 1. && rgb.b < 1. && rgb.r > 0. && rgb.g > 0. && rgb.b > 0.)\n\t\treturn rgb;\n\n\tLab lab = linear_srgb_to_oklab(rgb);\n\n\tfloat L = lab.L;\n\tfloat eps = 0.00001f;\n\tfloat C = max(eps, sqrt(lab.a * lab.a + lab.b * lab.b));\n\tfloat a_ = lab.a / C;\n\tfloat b_ = lab.b / C;\n\n\tfloat L0 = 0.5;\n\n\tfloat t = find_gamut_intersection(a_, b_, L, C, L0);\n\tfloat L_clipped = L0 * (1. - t) + t * L;\n\tfloat C_clipped = t * C;\n\n\treturn oklab_to_linear_srgb(Lab( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nRGB gamut_clip_project_to_L_cusp(RGB rgb)\n{\n\tif (rgb.r < 1. && rgb.g < 1. && rgb.b < 1. && rgb.r > 0. && rgb.g > 0. && rgb.b > 0.)\n\t\treturn rgb;\n\n\tLab lab = linear_srgb_to_oklab(rgb);\n\n\tfloat L = lab.L;\n\tfloat eps = 0.00001f;\n\tfloat C = max(eps, sqrt(lab.a * lab.a + lab.b * lab.b));\n\tfloat a_ = lab.a / C;\n\tfloat b_ = lab.b / C;\n\n\t// The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.\n\tLC cusp = find_cusp(a_, b_);\n\n\tfloat L0 = cusp.L;\n\n\tfloat t = find_gamut_intersection(a_, b_, L, C, L0);\n\n\tfloat L_clipped = L0 * (1. - t) + t * L;\n\tfloat C_clipped = t * C;\n\n\treturn oklab_to_linear_srgb(Lab( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nRGB gamut_clip_adaptive_L0_0_5(RGB rgb, float alpha) // alpha = 0.05f\n{\n    if (alpha<0.) alpha = 0.05; // default\n\tif (rgb.r < 1. && rgb.g < 1. && rgb.b < 1. && rgb.r > 0. && rgb.g > 0. && rgb.b > 0.)\n\t\treturn rgb;\n\n\tLab lab = linear_srgb_to_oklab(rgb);\n\n\tfloat L = lab.L;\n\tfloat eps = 0.00001f;\n\tfloat C = max(eps, sqrt(lab.a * lab.a + lab.b * lab.b));\n\tfloat a_ = lab.a / C;\n\tfloat b_ = lab.b / C;\n\n\tfloat Ld = L - 0.5f;\n\tfloat e1 = 0.5f + abs(Ld) + alpha * C;\n\tfloat L0 = 0.5f*(1. + sign(Ld)*(e1 - sqrt(e1*e1 - 2.f *abs(Ld))));\n\n\tfloat t = find_gamut_intersection(a_, b_, L, C, L0);\n\tfloat L_clipped = L0 * (1.f - t) + t * L;\n\tfloat C_clipped = t * C;\n\n\treturn oklab_to_linear_srgb(Lab( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nRGB gamut_clip_adaptive_L0_L_cusp(RGB rgb, float alpha) // alpha = 0.05f\n{\n    if (alpha<0.) alpha = 0.05; // default\n\tif (rgb.r < 1. && rgb.g < 1. && rgb.b < 1. && rgb.r > 0. && rgb.g > 0. && rgb.b > 0.)\n\t\treturn rgb;\n\n\tLab lab = linear_srgb_to_oklab(rgb);\n\n\tfloat L = lab.L;\n\tfloat eps = 0.00001f;\n\tfloat C = max(eps, sqrt(lab.a * lab.a + lab.b * lab.b));\n\tfloat a_ = lab.a / C;\n\tfloat b_ = lab.b / C;\n\n\t// The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.\n\tLC cusp = find_cusp(a_, b_);\n\n\tfloat Ld = L - cusp.L;\n\tfloat k = 2. * (Ld > 0. ? 1. - cusp.L : cusp.L);\n\n\tfloat e1 = 0.5*k + abs(Ld) + alpha * C/k;\n\tfloat L0 = cusp.L + 0.5 * (sign(Ld) * (e1 - sqrt(e1 * e1 - 2.f * k * abs(Ld))));\n\n\tfloat t = find_gamut_intersection(a_, b_, L, C, L0);\n\tfloat L_clipped = L0 * (1.f - t) + t * L;\n\tfloat C_clipped = t * C;\n\n\treturn oklab_to_linear_srgb(Lab( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\n\n#define toRGB(C)   RGB((C).r,(C).g,(C).b)\n#define fromRGB(C) vec4(C.r,C.g,C.b,1)\n\nvoid mainImage( out vec4 O, vec2 u ) // ----------------------------------------\n{\n    vec2 R = iResolution.xy,\n         U = u/R;\n    int t = ( length(iMouse.xy)<10.) ? int(iTime)%6          // method ref,1..5 :\n                                     : int(6.*iMouse.y/R.y); // demo or tune\n    U.x = 1.05*U.x - .05;\n    if (U.x>0.) {\n        O = texture(iChannel0, U);\n        \n        O = 3.*O-1.;                 // put here your out of gamut transform\n        \n        RGB C = toRGB( O );\n        switch(t) {\n            case 0: break;\n            case 1: C = gamut_clip_preserve_chroma(C);           break;\n            case 2: C = gamut_clip_project_to_0_5(C);            break;\n            case 3: C = gamut_clip_project_to_L_cusp(C);         break;\n            case 4: C = gamut_clip_adaptive_L0_0_5( C, -1. );    break;\n            case 5: C = gamut_clip_adaptive_L0_L_cusp( C, -1. ); break;\n        }\n        O = fromRGB( C );\n    }\n    else {                           // buttons\n      O = vec4( smoothstep(1.5/R.y,0., length( u/R.y - vec2(.04,(float(t)+.5)/6.) ) -.03 ) );\n      if (t==0) O.gb*=0.;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}