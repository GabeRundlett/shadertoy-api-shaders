{
    "Shader": {
        "info": {
            "date": "1652086123",
            "description": "2D version of reference: https://www.facebook.com/gianni.sarcone/videos/799221661057267/\n\ntoo bad we have to compute twice the same thing ( direct and reverse ) to draw vs get the camera target the center.\nWIP: try to zoom 4x faster",
            "flags": 0,
            "hasliked": 0,
            "id": "fl2Bzm",
            "likes": 28,
            "name": "infinite zoom in rolling squares",
            "published": 3,
            "tags": [
                "2d",
                "short",
                "reproduction"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 456
        },
        "renderpass": [
            {
                "code": "#define rot(a) mat2(cos(a+vec4(0,pi/2.,-pi/2.,0)))\n\nvoid mainImage( out vec4 O, vec2 u )\n{ \n    float d = 9., r = 2./5., Z = 4.*(2.-.8*r),                // r: margin Z: fractal scale\n         pi = 3.1415927, l=1., N = 8.,                        // N : fractal depth\n          z = 1., a = pow(3.,z)-1.,                           // z = speed of zoom\n          T = fract(iTime/30./z/z), t = 2.*pi*log(1.+a*T)/log(1.+a);// [0,2pi] with speed slowing as we zoom, so as to loop\n    vec2  R = iResolution.xy, D,\n          U = ( 2.*u - R ) / R.y / Z, A;\n // if (u.x<10.) { O = vec4(u.y/R.y < t/(2.*pi),0,0,0); return; }   // test cycle\n    \n    // --- follow target location ( to offset camera there )\n    vec2 P = vec2(0),L, D0 = vec2(1,0); D=D0;\n    for(float i=0.; i<N; i++) {\n        D  = D0 *=  rot(-t);                                  // rotate    \n        if (sin(t)<0.) D=-D;                                  // frame change after each corner\n        if (cos(t)*sin(t)<0.) D = vec2(-D.y,D.x); \n        P -= (1.-r)*vec2(-D.y,D.x)/l;                         // offset\n        t *= 3.;   l *= Z;                                    // zoom\n        P += 2.*floor( mod(t*2./pi,3.) - 1. ) *D/l;           // cycloïd-translate cube\n        L = 1.41* cos( mod(t, pi/2.) + pi/4. + vec2(0,pi/2.) )/l;\n        P -= L.x*D +L.y*vec2(-D.y,D.x);\n     }\n    t /= pow(3.,N);                                           // restore t\n    \n    // --- zoom and center on target\n // U *= pow(Z,-z*T);\n    U *= pow(Z,-z*t/(2.*pi));\n    U += P;\n\n    // --- implicit draw of squares\n    for(float i=0.; i<N; i++) {\n        U *= rot(t);                                          // rotate\n        A = abs(U); d = min(d, abs( max(A.x,A.y) -1.+r/2. )); // draw square\n                                                              // --- iterate:\n        D = vec2(1,0); a=0.;                                  // frame change after each corner\n        if (sin(t)<0.) D=-D, a-=2.;\n        if (cos(t)*sin(t)<0.) D = vec2(-D.y,D.x), a--;\n        \n        U += (1.-r)*vec2(-D.y,D.x), U *= Z;                   // offset & zoom\n        t *= 3.;                                              // smaller is faster\n        U -= 2.*floor( mod(t*2./pi,3.) - 1. ) *D;             // cycloïd-translate cube\n        U += 1.41* cos( mod(t, pi/2.) + pi/4. + vec2(0,pi/2.) +pi/2.*a );\n    }\n    \n   O = vec4( smoothstep( .8,-.8, (d-r/2.)/fwidth(d) )); // draw\n   \n //O +=  smoothstep( .8,-.8, R.y*length( (2.*u-R)/R.y -P) - 6.)*vec4(1,-1,-1,0);\n //O +=  smoothstep( .8,-.8, R.y*length( 2.*u - R ) / R.y - 6.)*vec4(1,-1,-1,0);\n}\n\n\n\n\n\n\n\n/** // --- naive version with 1/4 turn modulo \n\n#define rot(a) mat2(cos(a+vec4(0,1.57,-1.57,0)))\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = ( 2.*u - R ) / R.y, A;\n    float d = 9., r = 2./5.,  t = iTime/3.;  \n    \n    for(int i=0; i<3; i++) {\n        t = mod(t,1.57);\n        U *= rot(t);                                     // rotate\n        A = abs(U); d = min(d, abs( max(A.x,A.y) -1.+r/2. )); // draw square\n\n        U.y += 1.-r, U*= 4.*(2.-.8*r);                   // iterate: offset & zoom\n        t *= 3.;\n        U.x -= 2.*floor(t/1.57)-2.;                      // displace cube\n        U += 1.41* cos( mod(t, 1.57) + .7854 + vec2(0,1.57) );\n    }\n    \n    O = vec4( smoothstep( .8,-.8, (d-r/2.)/fwidth(d) )); // draw\n}\n/**/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}