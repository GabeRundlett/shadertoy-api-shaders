{
    "Shader": {
        "info": {
            "date": "1638588055",
            "description": "nice girl-haha-2d",
            "flags": 0,
            "hasliked": 0,
            "id": "sl3Szr",
            "likes": 9,
            "name": "nice girl-haha-2d",
            "published": 3,
            "tags": [
                "nicegirlhaha2d"
            ],
            "usePreview": 0,
            "username": "jorge2017a2",
            "viewed": 355
        },
        "renderpass": [
            {
                "code": "//por jorge2017a2\n//nice girl-haha-2d\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n///\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(8.*antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(6.*antialiasing(0.85),b,d)\n\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\n///---------------------------\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n    \nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  //colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj-0.05,0.0));\nreturn colOut;\n}\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\n\nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{   p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\n\nvec3 HacerFigura(vec2 p, vec3 col)\n{   vec2 p0=p;\n\n    float r01a, r01b,h01;\n    float ra1,ra2,ha, rb1,rb2,hb ;\n    ra1=0.2; ra2=0.27; ha=1.2; //pierna\n    rb1=0.1;rb2=0.2; hb=1.2; //rodilla\n    r01a=0.56; r01b=0.40; h01=1.5; //cuerpo\n    \n    //cabeza\n    float ra4, rb4,h4;\n    ra4=0.45; rb4=0.32;h4=0.4;\n    float d7a= sdUnevenCapsule(p-vec2(-0.5,3.65),ra4,rb4,h4);  //cabeza\n    \n    //cuello\n    float ra3, rb3,h3;\n    ra3=0.15; rb3=0.12;h3=0.3;\n    float d6a= sdUnevenCapsule(p-vec2(-0.5,3.0),ra3,rb3,h3);  //cuello\n    \n    //cuerpo\n    p=rotatev2(p0, radians(-10.0));\n    float d0a= sdUnevenCapsule(p-vec2(0.0,1.3),r01a,r01b,h01);  //cuerpo\n    float d0b= sdCircle(p*vec2(0.9,0.65)-vec2(-1.1,1.5), 0.8 ); //curva izq\n    float d0c= sdCircle(p*vec2(0.9,0.65)-vec2( 1.1,1.5), 0.8 ); //curva der\n    d0a=differenceSDF(d0a,d0b);\n    d0a=differenceSDF(d0a,d0c);\n    \n    //brazo izq\n    float r21a,r21b,h21;\n    r21a=0.12; r21b=0.15; h21=1.0;\n    vec2 p1a=rotatev2(p0-vec2(-1.3,2.0), radians(25.0));\n    vec2 p1b=rotatev2(p0-vec2(-1.3,2.0), radians(-45.0));\n    float d4a= sdUnevenCapsule(p1a,r21a,r21b,h21);  //brazo izq\n    float d4b= sdUnevenCapsule(p1b,r21b,r21a,h21);  //ante brazo izq\n    \n    //brazo der\n    float r22a,r22b,h22;\n    r22a=0.12; r22b=0.15; h22=1.0;\n    vec2 p2a=rotatev2(p0-vec2(0.2,2.0), radians(10.0));\n    vec2 p2b=rotatev2(p0-vec2(0.2,2.0), radians(10.0));\n    \n    p2a=rotatev2(p2a, radians(-25.0));\n    p2b=rotatev2(p2b, radians(55.0));\n    float d5a= sdUnevenCapsule(p2a,r22a,r22b,h22);  //brazo izq\n    float d5b= sdUnevenCapsule(p2b,r22b,r22a,h22);  //ante brazo izq\n    \n    //pierna izq\n    p=rotatev2(p0-vec2(-0.05,0.0), radians(-20.0));\n    float d1a= sdUnevenCapsule(p-vec2(0.0,0.0),ra1,ra2,ha);\n    //------rodilla\n    p=rotatev2(p0, radians(10.0));\n    float d1b= sdUnevenCapsule(p-vec2(0.0,-1.3),rb1,rb2,hb);\n    \n    //pierna der\n    p=rotatev2(p0, radians(10.0));\n    float d2a= sdUnevenCapsule(p-vec2(-0.1,0.0),ra1,ra2,ha);\n    //-------rodilla\n    p=rotatev2(p0, radians(20.0));\n    float d2b= sdUnevenCapsule(p-vec2(-0.1,-1.3),rb1,rb2,hb);\n    \n    //calzon 2\n    p=rotatev2(p0, radians(-10.0));\n    float dbx1=sdBox(p-vec2(0.0,2.8),vec2(0.8,1.0) );\n    dbx1=differenceSDF(d0a,dbx1);\n    \n    //pies\n    p1a=rotatev2(p0-vec2(-0.4,-1.1), radians(45.0));\n    p1b=rotatev2(p0-vec2(-0.1,-1.2), radians(45.0));\n    float d8a= sdCircle(p1a*vec2(0.9,0.5), 0.15 );\n    float d8b= sdCircle(p1b*vec2(0.9,0.5),0.15 );\n    \n    float k=0.07;\n    d0a=opSmoothUnion(d0a ,d4a,k);\n    d0a=opSmoothUnion(d0a ,d4b,k);\n    d0a=opSmoothUnion(d0a ,d5a,k);\n    d0a=opSmoothUnion(d0a ,d5b,k);\n    \n    col= DrawFigBorde(vec3(1.0,0.7,0.0), col, d0a);  //cuerpo\n    col= DrawFigBorde(vec3(0.4), col, d8a); //pies 1\n    col= DrawFigBorde(vec3(0.4), col, d8b); //pies 2\n    col= DrawFigBorde(vec3(1.0,0.7,0.0), col, d1b); //rodilla izq\n    col= DrawFigBorde(vec3(1.0,0.7,0.0), col, d1a); //pierna izq\n    col= DrawFigBorde(vec3(1.0,0.7,0.0), col, d2a); //pierna der\n    col= DrawFigBorde(vec3(1.0,0.7,0.0), col, d2b); //rodilla der\n    col= DrawFigBorde(vec3(1.0,0.5,0.0), col, d6a);\n    col= DrawFigBorde(vec3(0.4), col, d7a);\n   col= DrawFigBorde(vec3(0.4), col, dbx1);    \n    return col;\n}\n\nvec3 HacerFiguraOpScale( in vec2 p,vec3 col , float s)\n{\n    \n    col=HacerFigura(p/s,col)*s;\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv-=vec2(0.0,-0.5);\n    float esc=3.0;\n    uv*=esc;\n    vec3  col=vec3(0.45,0.7,1.0)-uv.y*0.5/esc;\n\n    float s1=1.0*sin(iTime*0.25+1.0);\n    float s2=1.0*sin(iTime*0.5 +2.0);\n    float s3=1.0*sin(iTime*0.75+4.0);\n    float s4=clamp(fract(iTime*2.0),0.2,s1);\n\n\n    col=HacerFiguraOpScale(uv,col,abs(s1));\n    col=HacerFiguraOpScale(uv-vec2( 2.0,0.0),col,abs(s2));\n    col=HacerFiguraOpScale(uv-vec2(-2.0,0.0),col,abs(s3));\n    col=HacerFiguraOpScale(uv,col,abs(s4));\n\n    \n    col=pow(col, vec3(0.65454));\n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}