{
    "Shader": {
        "info": {
            "date": "1712790742",
            "description": "sdasdx",
            "flags": 0,
            "hasliked": 0,
            "id": "4cKGDD",
            "likes": 5,
            "name": "Vedremo",
            "published": 3,
            "tags": [
                "luciona"
            ],
            "usePreview": 0,
            "username": "marcellix",
            "viewed": 146
        },
        "renderpass": [
            {
                "code": "#define blur 1.\n#define DITHER\n#define QUALITY 2\n#define DECAY .974\n#define EXPOSURE .24\n\n#if (QUALITY==2)\n #define SAMPLES 64\n #define DENSITY .97\n #define WEIGHT .25\n#elif (QUALITY==1)\n #define SAMPLES 32\n #define DENSITY .95\n #define WEIGHT .25\n#else\n #define SAMPLES 16\n #define DENSITY .93\n #define WEIGHT .36\n#endif\n\n#define NUM_OCCLUDERS 5 // One at the center, four at the corners\n\n#define ViewZoom 3.\n#define fsaa 14./min(iResolution.x,iResolution.y)\n#define fra(u) (u-.5*iResolution.xy)*ViewZoom/iResolution.y\n#define iterBayerMat 1\n#define bayer2x2(a) (4-(a).x-((a).y<<1))%4\n\nfloat GetBayerFromCoordLevel(vec2 pixelpos) {\n    ivec2 p = ivec2(pixelpos); int a = 0;\n    for(int i = 0; i < iterBayerMat; i++) {\n        a += bayer2x2(p>>(iterBayerMat-1-i)&1)<<(2*i);\n    }\n    return float(a) / float(2<<(iterBayerMat*2-1));\n}\n\nfloat bayer128(vec2 a) {\n    a = floor(a);\n    return fract(dot(a, vec2(.5, a.y*.75)));\n}\n\n#define dither128(p) (bayer128(p)-.499969482)\n\nfloat iib(vec2 u) {\n    return dither128(u);\n}\n\nvec3 sun(vec2 uv) {\n    // Cap the time at 19 seconds for the sun's movement\n    float cappedTime = min(iTime, 18.85);\n    vec2 p = vec2(sin(cappedTime), sin(cappedTime * .5) * .5);\n    vec3 res;\n    float di = distance(uv, p);\n    res.x = di <= .3333 ? sqrt(1. - di * 3.) : 0.;\n    res.yz = p;\n    res.y /= (iResolution.x / iResolution.y);\n    res.yz = (res.yz + 1.) * .5;\n    return res;\n}\n\n#define SS blur/min(iResolution.x,iResolution.y)\n\nfloat circle(vec2 p, float r) {\n    return smoothstep(SS, -SS, length(p) - r * 1.2);\n}\n\nvec4 BA(in vec2 uv) {\n    uv = uv * 2. - 1.;\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n\n    float occluders = 0.0;\n    float radius = 0.5; // Adjust for desired spacing\n    vec2 positions[NUM_OCCLUDERS];\n    // Corrected positions for an \"X\" pattern and center\n    positions[0] = vec2(0.0, 0.0); // Center\n    positions[1] = vec2(radius, -radius); // Lower Right\n    positions[2] = vec2(-radius, -radius); // Lower Left\n    positions[3] = vec2(radius, radius); // Upper Right\n    positions[4] = vec2(-radius, radius); // Upper Left\n\n    // Adjusting timing for sequential activation after a 5 second delay\n    float timeSinceStart = iTime - 5.0;\n    if (timeSinceStart > 0.0) {\n        // Activate center first\n        if (timeSinceStart > 0.0) occluders += circle(uv - positions[0], 0.1);\n        // Sequential activation\n        if (timeSinceStart > 3.0) occluders += circle(uv - positions[1], 0.1);\n        if (timeSinceStart > 4.0) occluders += circle(uv - positions[2], 0.1);\n        if (timeSinceStart > 9.0) occluders += circle(uv - positions[3], 0.1);\n        if (timeSinceStart > 10.0) occluders += circle(uv - positions[4], 0.1);\n    }\n\n    vec3 light = min(sun(uv), 1.);\n    float col = max(light.x - occluders, 0.);\n    return vec4(col, occluders, light.yz);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 ic = BA(uv);\n    vec2 lightpos = ic.zw;\n    float occ = ic.x;\n    float obj = ic.y;\n    float dither = iib(fragCoord);\n    vec2 dtc = (uv - lightpos) * (1. / float(SAMPLES) * DENSITY);\n    float illumdecay = 1.;\n\n    for (int i = 0; i < SAMPLES; i++) {\n        uv -= dtc;\n        #ifdef DITHER\n            float s = BA(uv + (dtc * dither)).x;\n        #else\n            float s = BA(uv).x;     \n        #endif\n        s *= illumdecay * WEIGHT;\n        occ += s;\n        illumdecay *= DECAY;\n    }\n        \n    fragColor = vec4(vec3(1,1,1) * obj / 3. + occ * EXPOSURE, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}