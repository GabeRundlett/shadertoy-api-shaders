{
    "Shader": {
        "info": {
            "date": "1529435659",
            "description": "inspired from online multiplayer game [url]http://slither.io/[/url]\n\nwith mouse control. :-)",
            "flags": 32,
            "hasliked": 0,
            "id": "MsVfzy",
            "likes": 6,
            "name": "slither (mouse control)",
            "published": 3,
            "tags": [
                "game",
                "reproduction"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 677
        },
        "renderpass": [
            {
                "code": "// mouse control variant of https://shadertoy.com/view/XsGBRG\n\n\n//#define rnd(p) fract(sin((p) * mat2(127.1,311.7,269.5,183.3) )*43758.5453123)\n#define rnd(p) fract(sin( (p) * vec2(27.1,311.7) )*43758.5453123)\n#define rot(a) mat2(cos( a + vec4(0,33,11,0)))   // From https://www.shadertoy.com/view/XlsyWX\n#define hue(v) ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) ) // From https://www.shadertoy.com/view/ll2cDc\n\n\n// --- return hexa cell center + dist to center. // From https://www.shadertoy.com/view/lsVBWw\n\nvec2 Hcoords( vec2 U, out float d ) {\n#define SQR3S2 0.866\n    U.y /= SQR3S2;\n    U.x -= .5*U.y;                           // global slant\n\n    vec2 F = fract(U);                       // triangular barycentric coordinates\n    bool u = F.x+F.y > 1.;       \n    vec3 q = vec3(F, fract(1.-F.x-F.y));\n    if (u) q = 1.-q;\n    vec3   r = q - q.zxy;\n\n    U = floor(U);                            // hexagonal center, d = dist to border\n    if      ( r.x>0. && r.y<0. ) U += vec2(!u,u), d = min(r.x,-r.y);\n    else if ( r.y>0. && r.z<0. ) U += vec2(u,!u), d = min(r.y,-r.z);\n    else                         U += vec2(u)   , d = min(r.z,-r.x);\n        \n    return U;\n}\n\n#define blend(c,d) O = mix(O, vec4(c), smoothstep(.02,0.,d))\n#define B(U,d,h)   length( U -(d)*D -(h)*H )   // Ball at coord(d,h) relative to (D,H)\n\nvoid mainImage( out vec4 O,  vec2 U )\n{\n    vec2 R = iResolution.xy, r = 400.*R/R.y / PIX;\n    U *= 400./R.y;\n    U /= PIX; \n    float d;\n    vec2 P = Hcoords(U * rot(-.2), d);\n    O = ( smoothstep(.0,.01,d-.33)*.4 + sqrt(clamp(-5.*(d-.23),0.,1.))*.2 )\n         * vec4(.7,.7,1,0)*.6;\n    \n    for (float i=0.; i<20.; i++) {           // draw energy balls\n        d = length( U - rnd(i)*r+.06*cos(i+4.*iTime+vec2(33,0)) );\n        vec2 r = rnd(i+.5);\n        O +=  .01*(1.+r.x+.3*sin(6.3*r.y+13.*iTime)) / (d*d) * hue(i/10.);\n    }\n    \n    vec2 D = V*D(T(L-1.).z), H = vec2(-D.y,D.x);\n    for (float i=0.; i<L; i+=k) {           // draw worm body\n        P = T(i).xy;\n        d = length( U - P );\n        blend(d, d-.37);\n    }\n    float h = T(L-1.).w;\n    d =       B( U-P, 1., .7 );              // draw worm eyes\n    d = min(d,B( U-P, 1.,-.7 ));\n    blend(1., d-.15);\n    \n    d =       B( U-P, 1.4, .7+h );\n    d = min(d,B( U-P, 1.4,-.7+h ));\n    blend(0., d-.08);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define m .39/1.41                   // screen modulo margin\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    if (U.y>1.) return;\n    float i = U.x-.5;                // queued positions : 0 ... L-1 (head)\n\n    vec2 R = iResolution.xy, r = 400.*R/R.y / PIX;\n         \n    \n    if (iFrame==0) {                 // --- initial position\n        vec2 P0 = vec2(330,150)/PIX, D = D0, H = vec2(-D.y,D.x);\n        O.xy = mod( P0 + i/k * D + .3*H*sin(i/k/2.), r+.39/1.41 );\n        O.z  = A0;                   // angle: only useful at head\n    }\n    else {                           // --- simulation\n        O = T(i);                    // previous state\n        if (i==L-1.) {               // head motion\n            vec2 M = iMouse.xy * 400./R.y / PIX;\n            float a = 0.;\n            if (iMouse.z>0.)         // mouse control turns head\n                a = - 2. * sign( cross2(normalize(M-O.xy),D(O.z)) ),\n                O.z += a*dt;\n            O.w = mix( O.w, .15*a, dt*3. );\n            O.z += .1* sin(i/k/2.+5.*iTime)/5.;              // snake motion \n            O.xy = mod( O.xy + V/k * D(O.z) +m, r+2.*m )-m;  // head move\n        }\n        else O.xy = T(i+1.).xy;      // segments (and inter-step) follows\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define PIX 64.                 // pixel size (i.e. zoom )\n\n#define k   7.                  // steps between segments\n#define L   (15.*k)             // segments * steps ( = pos to queue )\n#define dt  (1./60.)\n#define D0  vec2(10,5)/PIX      // initial inter-segment vector\n#define A0  atan((D0).y,(D0).x) // corresponding angle and length\n#define V   length(D0)\n\n#define D(a)         vec2(cos(a),sin(a))\n#define cross2(a,b) ( (a).x*(b).y-(a).y*(b).x )\n#define T(i)         texelFetch(iChannel0,ivec2(i,0),0)\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}