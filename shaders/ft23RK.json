{
    "Shader": {
        "info": {
            "date": "1624276972",
            "description": "...meanwhile inside an alien wrist-watch",
            "flags": 32,
            "hasliked": 0,
            "id": "ft23RK",
            "likes": 39,
            "name": "tetrahedral truchet gears",
            "published": 3,
            "tags": [
                "gears",
                "truchet",
                "tetrahedron",
                "octahedron"
            ],
            "usePreview": 1,
            "username": "flockaroo",
            "viewed": 1068
        },
        "renderpass": [
            {
                "code": "// created by florian berger (flockaroo) - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// tetrahedral truchet gears\n// ...actually its sheared cubes divided into 2 tetrahedrons and one octahedron\n\n// i've seen others use this \"tetrahedral\" symmetry before...\n// here 2 wonderful examples (most likely not a complete list):\n//   Shane - Simplex Truchet Tubing - https://www.shadertoy.com/view/XsffWj\n//   mattz - rainbow spaghetti      - https://www.shadertoy.com/view/lsjGRV\n\n// the freedom of symmetry is a bit more limited here when matching gears from cell to cell,\n// and i think one can find more complext tilted gear-configurations, but at some point my brain did hurt, so i left it at that ;-)\n\n#ifndef Res\n#define Res (iResolution.xy)\n#endif\n\n#define BLUR_SAMP 4\n\n// ...some blurring of borders\n\nvoid mainImageS( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv0=fragCoord/iResolution.xy;\n    #ifdef BORDER_LOD_SPEEDUP\n    vec2 uv1=uv0-.25;\n    vec2 uv2=uv0*.5+vec2(.5,0);\n    vec2 fact2=smoothstep(.24,.25,abs(uv0-.5));\n    fragColor=mix(texture(iChannel1,uv1),texture(iChannel1,uv2),max(fact2.x,fact2.y));\n    fragColor*=1.-2.*dot(uv0-.5,uv0-.5);\n    fragColor.w=1.;\n    #else\n    fragColor=texture(iChannel1,uv0);\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor=vec4(0);\n    int NumSamp=BLUR_SAMP;\n    vec2 delta=(fragCoord-.5*iResolution.xy)*.02;\n    for(int i=0;i<NumSamp;i++){\n        vec4 c;\n        float fi=float(i)/float(NumSamp-1)-.5;\n        if(NumSamp==1) fi=0.;\n        mainImageS(c,fragCoord+delta*fi*.75);\n        fragColor+=c*(1.+vec4(1,0,-1,0)*fi*3.);\n    }\n    fragColor/=float(NumSamp);\n    fragColor.w=1.;\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// tetrahedral truchet gears\n\n// only center region will be rendered in full res + some border blur added (for better performance)\n#define BORDER_LOD_SPEEDUP\n\n// quaternion helpers\n#define PI  3.14159265359\n#define PI2 6.28318530718\n#define PIH 1.57079632679\n\n#define PIH 1.57079632679\n\n\nvec4 inverseQuat(vec4 q)\n{\n    //return vec4(-q.xyz,q.w)/length(q);\n    // if already normalized this is enough\n    return vec4(-q.xyz,q.w);\n}\n\nvec4 multQuat(vec4 a, vec4 b)\n{\n    return vec4(cross(a.xyz,b.xyz) + a.xyz*b.w + b.xyz*a.w, a.w*b.w - dot(a.xyz,b.xyz));\n}\n\nvec3 transformVecByQuat( vec3 v, vec4 q )\n{\n    return v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w*v );\n}\n\nvec4 axAng2Quat(vec3 ax, float ang)\n{\n    return vec4(normalize(ax),1)*sin(vec2(ang*.5)+vec2(0,PI2*.25)).xxxy;\n}\n\n#define Def_cross(a,b) vec3( (a).y*(b).z-(a).z*(b).y, (a).z*(b).x-(a).x*(b).z, (a).x*(b).y-(a).y*(b).x )\n#define Def_dot(a,b) ((a).x*(b).x+(a).y*(b).y+(a).z*(b).z)\n#define Def_multQuat(a,b) (vec4(Def_cross((a).xyz,(b).xyz) + (a).xyz*(b).w + (b).xyz*(a).w, (a).w*(b).w - Def_dot((a).xyz,(b).xyz)))\n#define Def_AxAng2Quat(ax,ang) (vec4(normalize(ax),1)*sin(vec2((ang)*.5)+vec2(0,PI2*.25)).xxxy)\n\n#define Q_X_45 vec4(0.38268343237,0,0,0.92387953251)\n#define Q_Y_45 vec4(0,0.38268343237,0,0.92387953251)\n#define Q_Z_45 vec4(0,0,0.38268343237,0.92387953251)\n#define Q_X_90 vec4(0.70710678119,0,0,0.70710678119)\n#define Q_Y_90 vec4(0,0.70710678119,0,0.70710678119)\n#define Q_Z_90 vec4(0,0,0.70710678119,0.70710678119)\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// tetrahedral truchet gears\n\n// use this in windows - otherwise might not compile (angle doesnt like if's)\n#define AVOID_IFS\n#ifdef _WINDOWS_\n#define AVOID_IFS\n#endif\n\n#define GEAR_ANIM\n#define VIEWER_ANIM\n//#define CELL_COLORS\n\n#define Res vec2(iResolution.xy)\n#define Res0 vec2(textureSize(iChannel0,0))\n#define Res1 vec2(textureSize(iChannel1,0))\n\n#ifndef Res\n#define Res (iResolution.xy)\n#endif\n\nfloat CamDist = 1.;\nfloat CamShake = 1.;\n\n#define ViewerDist (CamDist)\n\n#define tanFOVh (1.6)\n\nvoid getCamQuatAndPos(out vec4 camQuat, out vec3 camPos)\n{\n    vec2 ang=vec2(iMouse.y/iResolution.y*12.8,iMouse.x/iResolution.x*12.8);\n    vec3 coffs=vec3(0);\n    vec4 r=sin(vec4(.7,1,1.3,1.7)*iTime*.5);\n    if(iMouse.x<.5) { \n        ang=vec2(-1.57+sin(iTime*.1-1.0)*-1.,-sin(iTime*.07-1.)*3.);\n        coffs=vec3(iTime*.2,0,0);\n    }\n    vec4 q=vec4(0,0,0,1);\n    // calc rotation quaternion for scene rotation\n    q=multQuat(q,axAng2Quat(vec3(1,0,0), ang.x));\n    q=multQuat(q,axAng2Quat(vec3(0,0,1), ang.y));\n    q=normalize(q+.01*r*CamShake);\n    camQuat = inverseQuat(q);\n    camPos = transformVecByQuat(vec3(0,0,ViewerDist+r.z*.025*CamShake),camQuat)+coffs;\n}\n\nvoid apply_trafo_r(inout vec3 pos, float transl)\n{\n    vec3 cp; vec4 cq;\n    getCamQuatAndPos(cq,cp);\n    pos=transformVecByQuat(pos,cq)+cp*transl;\n}\n\nvoid apply_trafo_r(inout vec3 pos) { apply_trafo_r(pos,1.0); }\n\nvoid apply_frustum_r(inout vec3 pos, inout vec3 dir, vec2 fragCoord)\n{\n    dir=normalize(vec3((fragCoord-.5*iResolution.xy)/iResolution.x*2.,-1./tanFOVh));\n    apply_trafo_r(dir,0.);\n}\n\n\nfloat distTorus(vec3 p, float R, float r)\n{\n    return length(vec3(p.xy-normalize(p.xy)*R,p.z))-r;\n}\n\n// iq's exponantial smooth-min funcs\nfloat smin( float a, float b, float k )\n{\n    k=3./k;\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nfloat smax(float a, float b, float k) { return -smin(-a,-b,k); }\n\n// iq's polynomial smooth-min func\nfloat smin_( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax_(float a, float b, float k) { return -smin_(-a,-b,k); }\n\nfloat tri(float x) { return 1.-4.*abs(fract(x*0.159154943092+.25)-.5); }\n\nfloat tooth(float x) {\n    //return clamp(sin(x)*1.1,-1.,1.);\n    return clamp(tri(x)*1.4,-1.,1.);\n}\n\n// iq's box-funcs\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRect( vec2 p, vec2 b )\n{\n  vec2 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nfloat distGear(vec3 p, float R, int numTeeth)\n{\n    float w=.2*R;\n    float lp=length(p);\n    float lpxy=length(p.xy);\n    float d=10000.;\n    float ang=atan(p.y,p.x);\n    d=abs(p.z)-w*1.2/*+lpxy/R*w*.0*/;\n    vec3 p2=p;\n    float a=-.5*PI/float(numTeeth); // 1/4 of tooth angle\n    vec2 cs=cos(a-vec2(0,PI2*.25));\n    p2.xy=mat2(cs.x,cs.y,-cs.y,cs.x)*p.xy;\n    p2.xy=abs(p2.xy);\n    if(p2.x>p2.y) p2.xy=p2.yx;\n    \n    // --- spokes ---\n    // edge cut\n    //float d2=abs(p.z)-R*.05;\n    //d2=smax(d2,-sdRect(abs(p2.xy)-vec2(.55)*R,vec2(.25*R))+.22*R,.05*R);\n    //d2=smin(d2,.28*R+.2*abs(p.z)-abs(.45*R-lpxy),.05*R);\n    //d=max(d,d2);\n    // rect profile\n    d=max(d,.28*R+.2*abs(p.z)-abs(.45*R-lpxy));\n    d=smin(d,smax(abs(p2.x),abs(p2.z)*1.7,.006)-.09*R+.02*p2.y,.0035);\n    // rotated rect profile\n    //d=max(d,.28*R+.2*abs(p.z)-abs(.45*R-lpxy));\n    //d=smin(d,abs(p2.x)+abs(p2.z)-.07*R,.0035);\n    \n    // --- teeth\n    // ...by tooth func\n    //d=max(d,length(p+vec3(p.xy/lpxy,0)*.1*R*tooth(ang*float(numTeeth)))-R);\n    // ...by doing actual tooth (gives better distance field to avoid overstepping)\n    float dang=a*2.; // 1/2 of tooth angle  (alternatingly with pos/neg flank)\n    float tidx=floor((ang+.5*dang)/dang);\n    float flank=mod(tidx,2.)*2.-1.;\n    float ang0=(tidx)*dang; // center angle of tooth flank\n    vec2 cs0=cos(ang0-vec2(0,PI2*.25));\n    float Rfl=R*1.;\n    float d2=length(p.xyz-vec3((cs0*(R*sqrt(2.)-Rfl)+flank*cs0.yx*vec2(-1,1)*Rfl)*sqrt(.5),0.))-Rfl;\n    d2=min(d2,lp-R*.9);\n    d2=max(d2,lp-R*1.1);\n    d=max(d,d2);\n    return d;\n}\n\n// iq's line distance\nfloat distLine( vec3 p, vec3 a, vec3 b )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\n\nfloat SideLength = 1.;\n\n#ifndef GEAR_ANIM\nuniform float GearAng;\n#else\n#define GearAng (.25*PI2*sin(iTime*PI2/3.)*1.)\n#endif\n\n// put num gears into -ang/2..ang/2 (first and last gear only half)\nfloat distGearsAng(vec3 p, float R, float r, float ang, int num, float axang, float YOff, float soff)\n{\n    float GearR=SideLength*.09;\n    float ph0=atan(GearR/R);\n    float ph1=(ang-ph0-ph0)/float(num-2)/2.;\n    float pang=atan(p.y,p.x);\n    float ang2=-ang*.5;\n    float ang1=ang2;\n    int i;\n    for(i=min(iFrame,0);i<num;i++) {\n        if(pang>=ang2) {\n            ang1=ang2;\n            if      (i==num-2) ang2=ang*.5;\n            else if (i==0)     ang2+=ph0+ph1;\n            else               ang2+=ph1+ph1;\n        }\n        if(pang<ang2) {\n            break;\n        }\n    }\n    float s=float(i%2)*2.-1.;\n    float rg1=((i==0)    ?GearR:R*tan(ph1))*.95;\n    float rg2=((i==num-2)?GearR:R*tan(ph1))*.95;\n    float d=10000.;\n    vec3 pg;\n\n    float raild=GearR*.5;\n    \n    int numTeeth=12;\n    \n    int n1,n2;\n    float axang1,axang2;\n    float gearAng1,gearAng2;\n    gearAng1=gearAng2=GearAng;\n    axang1=axang2=axang;\n    vec4 axq=axAng2Quat(vec3(0,1,0),axang2);\n    n1=n2=numTeeth;\n    \n    float zo,gao;\n    pg=transformVecByQuat(p, axAng2Quat(vec3(0,0,1),-ang1));\n    zo=sin((ang1-ang*.5)/ang*PI2)*GearR*YOff;\n    pg.z+=zo*soff;\n    gao=(ang1+ang*.5)/ang*PI2*GearR*YOff*.5/rg1;\n    pg.x-=R;\n    pg=transformVecByQuat(pg,axq);\n    d=min(d,max(length(pg.xy)-.01*R,abs(pg.z)-raild));\n    pg=transformVecByQuat(pg,axAng2Quat(vec3(0,0,1),(gearAng1+gao)*s));\n    d=min(d,distGear(pg,rg1,n1));\n    \n    pg=transformVecByQuat(p, axAng2Quat(vec3(0,0,1),-ang2));\n    zo=sin((ang2-ang*.5)/ang*PI2)*GearR*YOff;\n    pg.z+=zo*soff;\n    gao=(ang2+ang*.5)/ang*PI2*GearR*YOff*.5/rg2;\n    pg.x-=R;\n    pg=transformVecByQuat(pg,axq);\n    d=min(d,max(length(pg.xy)-.01*R,abs(pg.z)-raild));\n    //d=min(d,distLine(pg,vec3(0,0,-raild),vec3(0,0,raild))-.01*R);\n    pg=transformVecByQuat(pg,axAng2Quat(vec3(0,0,1),(gearAng2+gao)*-s));\n    d=min(d,distGear(pg,rg2,n2));\n    \n    //vec2 rail=cos(axang-vec2(0,PI*.5))*raild;\n    //d=min(d,distTorus(p-vec3(0,0,1)*rail.x,R-rail.y,.01*R));\n    //d=min(d,distTorus(p+vec3(0,0,1)*rail.x,R+rail.y,.01*R));\n    //...is this faster than 2 the toruses above ?!\n    vec2 cs=cos(-axang-vec2(0,PI*.5));\n    vec2 p2=mat2(cs,cs.yx*vec2(-1,1))*vec2(length(p.xy)-R,p.z);\n    p2.y=abs(p2.y);\n    d=min(d,length(p2-vec2(0,raild))-.01*R);\n    return d;\n}\n\nfloat Thick;\n\nfloat AxAng;\n\n#define T1 1\n#define T2 2\n#define O1 3\n#define O2 4\n#define O3 5\n\nint mtl=0;\n\n\nfloat distOctCell(vec3 p, float axAng, int dtnum) \n{\n    float ZOff=0., soff=-1.;\n    float s=1.;\n    if (p.x-p.y<0.) s=-1.;\n    if(abs(p.y)>abs(p.x)) { \n        p.xy=p.yx*vec2(1,-1); \n        if(mtl==O2) { p.y*=-1.; soff*=-1.; }\n        if(mtl==O3) p.z*=-1.;\n        if(mtl==O1) p.z*=-1.;\n    }\n    if(p.x<0.) { \n        if(mtl==O2) { p.z*=1.; soff*=-1.; }\n        if(mtl==O3) p.z*=-1.;\n        if(mtl==O1) p.z*=-1.;\n    }\n    p.x=-abs(p.x);\n    float d=1000.;\n    float R=SideLength/2./sqrt(3.);\n    float r=Thick*SideLength;\n    float d2;\n    float x0=SideLength*.5;\n    \n    if(mtl==O2) { ZOff=.0792; }\n    \n    d2=distGearsAng((p-vec3(-x0,0,0)).xzy*vec3(1,-1,1),R,r,atan(sqrt(2.))*2.,5+dtnum,axAng*s,ZOff,soff);\n    d=min(d,d2);\n    return d;\n}\n\n\nfloat distTetrCell(vec3 p) \n{\n    if(p.x<.0) { p.yz=p.zy*vec2(1,-1); }\n    p.x=abs(p.x)*-1.;\n    float d=1000.;\n    float R=SideLength/2./sqrt(3.);\n    float r=Thick*SideLength;\n    float d2;\n    float x0=SideLength*(.5/sqrt(2.));\n    \n    d2=distGearsAng((p-vec3(-x0,0,0)).xyz,R,r,atan(sqrt(.5))*2.,3,PI*.5,0.,1.); d=min(d,d2);\n    return d;\n}\n\nfloat distLine(vec3 p, vec3 t)\n{\n    return length(p-dot(p,t)/dot(t,t)*t);\n}\n\n\nvec4 getRand(ivec3 v)\n{\n    return texelFetch(iChannel0,(v.xy+ivec2(7,17)*v.z)%256,0);\n}\n\nfloat PosCos=0.;\n\nconst vec4 qzp45=Q_Z_45;\nconst vec4 qxp45=Q_X_45;\nconst vec4 qxm45=-Q_X_45*vec4(1,1,1,-1);\nconst vec4 qyp90=Def_multQuat(Q_Z_45,Q_Y_90);\nconst vec4 qxp90=Def_multQuat(Q_Z_45,Q_X_90);\n\n#define sel2(x1, x2, f)    ( mix(x1,x2,step(1.,f)) )\n#define sel3(x1, x2, x3, f) ( sel2(sel2(x1,x2,f),x3,f-1.) )\n\nfloat distTruch(vec3 p)\n{\n    p += PosCos*SideLength * ( cos(p.zxy*1.7/SideLength+0.*iTime) - .1*sin(p.zxy*1.7/SideLength*10.+0.*iTime) );\n    mat3 m=mat3( 0,1,1, 1,0,1, 1,1,0 )*SideLength/sqrt(2.);\n    vec4 q;\n    vec3 v=inverse(m)*p;\n    vec3 v0=floor(v);\n    v-=v0;\n    vec3 pc=m*(v0+.5);\n    \n    float d=10000.;\n    float ro=sqrt(2.)/4.*SideLength;\n    float d2;\n    p-=pc;\n    vec4 r=getRand(ivec3(v0));\n    \n    #ifndef AVOID_IFS\n       // this is more overlookable, but...\n       // ...windows wont compile this (guess angle is not coping with the many if's)\n       \n       //lower tetrahedron\n       if      (v.x+v.y+v.z<1.) { q=qxm45; mtl=T1; d2=distTetrCell(transformVecByQuat(p+ro,q)); }\n       //upper tetrahedron\n       else if (v.x+v.y+v.z>2.) { q=qxp45; mtl=T2; d2=distTetrCell(transformVecByQuat(p-ro,q)); }\n       //center octahedron\n       else if (r.x>.66)        { q=qxp90; mtl=O1; d2=distOctCell (transformVecByQuat(p,q),PI/6.,0);  }\n       else if (r.x>.33)        { q=qyp90; mtl=O2; d2=distOctCell (transformVecByQuat(p,q),PI*.5,-1); }\n       else                     { q=qzp45; mtl=O3; d2=distOctCell (transformVecByQuat(p,q),PI/6.,0);  }\n       d=d2;\n       \n    #else\n       \n       float region=floor(v.x+v.y+v.z);  // 0->tetra1, 1->octahedron, 2->tetra2\n       \n       mtl=(r.x<.333)?O2:((r.x<.666)?O1:O3);\n       mtl=(region==0.)?T1:((region==2.)?T2:mtl);\n   \n       d=(region==1.)?\n            distOctCell (transformVecByQuat(p,sel3(qyp90,qxp90,qzp45,r.x*3.)),PI/sel2(2.,6.,r.x*3.),(r.x<.333)?-1:0):\n            distTetrCell(transformVecByQuat(p-ro*(region-1.),mix(qxm45,qxp45,region*.5)));\n       \n    #endif\n\n    //#define PRISM_CELLS\n    #ifdef PRISM_CELLS\n    vec3 p0;\n    p0=m*floor(v0+v+.5);\n    d=min(d,distLine(p-p0,m*vec3(1,0,0))-.003);\n    d=min(d,distLine(p-p0,m*vec3(0,1,0))-.003);\n    d=min(d,distLine(p-p0,m*vec3(0,0,1))-.003);\n    #endif\n    return d;\n}\n\nfloat dist(vec3 p)\n{\n    float d=distTruch(p);\n    return d;\n}\n\nvec3 getGradF(vec3 p, float eps) \n{ \n    vec2 d=vec2(eps,0); \n    float d0=dist(p);\n    return vec3(dist(p+d.xyy)-d0,dist(p+d.yxy)-d0,dist(p+d.yyx)-d0)/eps; \n}\n\nvec3 getGrad_(vec3 p, float eps) \n{ \n    vec2 d=vec2(eps*.5,0); \n    float d0=dist(p);\n    return vec3(dist(p+d.xyy)-dist(p-d.xyy),dist(p+d.yxy)-dist(p-d.yxy),dist(p+d.yyx)-dist(p-d.yyx))/eps; \n}\n\n// suggestion from Shane - windows compile improvements\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getGrad(in vec3 p, float eps) {\n\t\n    vec2 e = vec2(eps*.5, 0);\n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp[i] = dist(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\nvoid march(inout vec3 pos, vec3 dir)\n{\n    float eps=.0001;\n    float dsum=0.;\n    for(int i=min(0,iFrame);i<120;i++)\n    {\n        float d=dist(pos)*.66;\n        pos+=dir*d;\n        dsum+=d;\n        if (d<eps*dsum*5. || dsum>10.0) break;\n        if(i>1000) break; // Fake break. (not sure if necessary)\n    }\n}\n\n#ifndef RandTex \n#define RandTex iChannel0\n#endif\n\nvec4 myenv(vec3 pos, vec3 dir, float period)\n{\n    vec4 r=vec4(0);\n    float sc=.2*period;\n    int num=8;\n    for(int i=min(0,iFrame);i<num;i++) { r+=texture(RandTex,dir.xy/dir.z*sc+iTime*.003*step(0.,dir.z)); sc*=.5; }\n    r/=float(num);\n    vec3 col=mix(vec3(.6,.7,.8)+.6*r.y,r.zwx*vec3(.5,.3,0),1.-smoothstep(-.3,.3,dir.z));\n    return vec4(col,1);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifdef BORDER_LOD_SPEEDUP\n    if(fragCoord.y>Res.y*.5) { discard; return; }\n    vec2 uv2=fragCoord/Res*2.-vec2(1,0);\n    if(max(abs(uv2-.5).x,abs(uv2-.5).y)<.24) { discard; return; }\n    fragCoord=(fragCoord.x<Res.x*.5)?fragCoord+.25*Res:(fragCoord-vec2(.5*Res.x,0))*2.;\n    #endif\n    \n    vec3 light=normalize(vec3(0,0,1));\n    vec3 pos,dir;\n    pos=vec3(0);\n    apply_trafo_r(pos);\n    apply_frustum_r(pos,dir,fragCoord);\n    \n    vec3 pos0=pos;\n    \n    march(pos,dir);\n    \n    vec3 pos1=pos;\n    \n    vec3 n=normalize(getGrad(pos,.001));\n    //vec3 c0=vec3(1,.85,.77)+.0;\n    vec3 c0=vec3(1);\n    //vec3 c0=vec3(1,.86,.8);\n    \n    #ifdef CELL_COLORS\n       // tetrahedra configurations red, orange\n       if (mtl==T1) c0=vec3(1,.5,0)*.4+.6;\n       if (mtl==T2) c0=vec3(1,0,0)*.4+.6;\n       // octahedra configurations green, blue, magenta\n       if (mtl==O1) c0=vec3(.5,1,.5)*.4+.6;\n       if (mtl==O2) c0=vec3(.5,.5,1)*.4+.6;\n       if (mtl==O3) c0=vec3(1,0,1)*.4+.6;\n    #endif\n    \n    vec4 r=texelFetch(iChannel0,ivec2(fragCoord)%256,0);\n    \n    #if 1\n    float ao=1.;\n    //ao*=clamp(dist(pos+n/ 10.)* 10.,0.,1.);\n    //ao*=clamp(dist(pos+n/ 20.)* 20.,0.,1.);\n    float sc=SideLength*.003;\n    vec3 na=normalize(n)+.12*(r.xyz-.5);\n    float f=.7;\n    /*ao*=clamp(dist(pos+na*sc)/sc,0.,1.)*(1.-f)+f; sc*=2.; f=pow(f,.9);\n    ao*=clamp(dist(pos+na*sc)/sc,0.,1.)*(1.-f)+f; sc*=2.; f=pow(f,.9);\n    ao*=clamp(dist(pos+na*sc)/sc,0.,1.)*(1.-f)+f; sc*=2.; f=pow(f,.9);\n    ao*=clamp(dist(pos+na*sc)/sc,0.,1.)*(1.-f)+f; sc*=2.; f=pow(f,.9);\n    ao*=clamp(dist(pos+na*sc)/sc,0.,1.)*(1.-f)+f; sc*=2.; f=pow(f,.9);\n    ao*=clamp(dist(pos+na*sc)/sc,0.,1.)*(1.-f)+f; sc*=2.; f=pow(f,.9);\n    ao*=clamp(dist(pos+na*sc)/sc,0.,1.)*(1.-f)+f; sc*=2.; f=pow(f,.9);\n    ao*=clamp(dist(pos+na*sc)/sc,0.,1.)*(1.-f)+f; sc*=2.; f=pow(f,.9);*/\n    // suggestion from Shane - windows compile improvements\n    // Looping the unrolled AO statements. \n    for(int i=min(0, iFrame);i<8;i++){\n       ao*=clamp(dist(pos+na*sc)/sc,0.,1.)*(1.-f)+f; sc*=2.; f=pow(f,.9);\n       if(ao>1e8) break; // Fake break.\n    }\n    ao=ao*.7+.3;\n    #else\n    float ao=1.;\n    float sc=SideLength*.3,scmin=SideLength*.01;\n    vec3 na=normalize(getGrad(pos,scmin*.2))+.12*(r.xyz-.5);\n    float df=dist(pos+na*scmin*.2)/(scmin*.2);\n    for(int i=min(0,iFrame);i<30;i++)\n    {\n        //na=normalize(getGrad(pos,sc*.2));\n        //df=dist(pos+n*sc*.01)/(sc*.01);\n        float ao2=clamp(dist(pos+na*sc)/(sc/df),0.,1.);\n        ao*=mix(ao2,1.,\n        //1.-sqrt(sc)*.2\n        .85\n        );\n        sc*=.7;\n        if(sc<scmin) break;\n    }\n    #endif\n    \n    vec3 lightCol=vec3(.97,1.03,1);\n    \n    fragColor.xyz=c0;\n    fragColor.xyz*=(n*.03+.97);\n    fragColor.xyz*=(clamp(dot(n,light),0.,1.)*.4+.6);\n    fragColor.xyz*=ao;\n    vec3 R=reflect(normalize(pos1-pos0),n);\n    fragColor.xyz=fragColor.xyz*.85+.3*clamp(dot(R,light),0.,1.)*lightCol*c0;\n    //fragColor.xyz=fragColor.xyz*.7+.3*myenv(vec3 (0), R, .1).xyz;\n    vec3 dp=pos-pos0;\n    vec3 dpn=normalize(dp);\n    fragColor.xyz=mix(fragColor.xyz,mix(vec3(-.0,.05,.0),lightCol,clamp(dot(dp,light)/5.+.1,0.,1.))+dpn*.03,1.-exp(-length(pos-pos0)/5.));\n    fragColor.xyz*=fragColor.xyz+.2;\n    \n    fragColor.w=length(dp);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}