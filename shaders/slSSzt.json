{
    "Shader": {
        "info": {
            "date": "1629027301",
            "description": "The original shader interactively shows raymarching iterations for a *single* ray.\nThis shader simultaneously shows raymarching iterations for *all* rays starting from a single point.",
            "flags": 16,
            "hasliked": 0,
            "id": "slSSzt",
            "likes": 21,
            "name": "Raymarching wavefront",
            "published": 3,
            "tags": [
                "raymarching",
                "visualization"
            ],
            "usePreview": 0,
            "username": "pyBlob",
            "viewed": 493
        },
        "renderpass": [
            {
                "code": "/*\nThe original shader interactively shows raymarching for a single ray.\nThis shader simultaneously shows raymarching for ALL rays starting from a single point.\nEvery red point is the endpoint of some ray for some raymarching iteration.\nI think, this is one of the first visualizations that shows the individual raymarching steps all at once.\n\nWavefront mode:\n    - Move raymarching source with your mouse.\n    - Uncomment original sdf in scene(vec2) function.\n\nRay mode (original):\n    - Pick raymarching source by pressing mouse.\n    - Move raymarchign target.\n    - R: toggle original ray visualization.\n*/\n\nconst int AA = 16;\nconst int iterations = 20;\nconst int substep = 1;\n\n#define T (iTime * 1.)\nconst float _precision = 1e-4;\nconst float maxSteps = float(iterations);\nconst float maxDistance = 5.;\n\nconst int y_press = 0;\nconst int y_delta = 1;\nconst int y_toggle = 2;\n\nconst int key_R = 0x52;\nbool visualizeRay()\n{\n    return texelFetch(iChannel3, ivec2(key_R, y_toggle), 0).x > .5;\n}\n\nvec2 _p; float _d = 1e10;\n\nfloat sdBox(vec2 p,vec2 s)\n{\n    return length(max(p=abs(p)-s,0.))+min(max(p.x,p.y),0.);\n}\n\nfloat sdLine(vec2 p,vec2 a,vec2 b)\n{\n    return length(-clamp(dot(p-=a,b-=a)/dot(b,b),0.,1.)*b+p);\n}\n\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, float rb )\n{\n    sca = normalize(sca);\n    scb = normalize(scb);\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x > scb.x*p.y) ? dot(p,scb) : length(p);\n    return sqrt(max(0., dot(p,p) + ra*ra - 2.0*ra*k)) - rb;\n}\n\nfloat side(float r, float h)\n{\n    return sqrt(r*r - h*h);\n}\n\nfloat sdArcTo(in vec2 p, in vec2 a, in vec2 b, float r)\n{\n    vec2 m = a + b;\n    float tb = dot(m, b) / length(m);\n    float arc = sdArc(p, vec2(m.y, -m.x), vec2(side(r, tb), tb), r, 0.);\n    //return min(min(length(p-a), length(p-b)), min(length(p-m), min(arc, length(p)))) -.01;\n    return arc;\n}\n\nfloat sdMoon(vec2 p, float d, float ra, float rb )\n{\n    p.y = abs(p.y);\n    float a = (ra*ra - rb*rb + d*d)/(2.0*d);\n    float b = sqrt(max(ra*ra-a*a,0.0));\n    if( d*(p.x*b-p.y*a) > d*d*max(b-p.y,0.0) )\n          return length(p-vec2(a,b));\n    return max( (length(p          )-ra),\n               -(length(p-vec2(d,0))-rb));\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat scene(vec2 p)\n{\n    p.x += .5;\n    float ball = length(p - vec2(1, 0)) - .3;\n    float lens = length(p - vec2(.8, 0)) - .15;\n    float wire = abs(p.y) - .05;\n    vec2 q = p; q.y = abs(q.y);\n    float eye = max(max(ball,-lens),-wire);\n    float bx = (pow(.3,2.)-pow(.15,2.)+pow(.2,2.))/(2.*.2);\n    float bh = side(.3, bx);\n    float ballArc = sdArcTo(q - vec2(1, 0), vec2(-bx,bh), vec2(side(.3,.05), .05), .3);\n    float lensArc = sdArcTo(q - vec2(.8, 0), vec2(.2-bx,bh), vec2(side(.15,.05), .05), .15);\n    float wireLine = sdLine(q, vec2(.8+side(.15,.05), .05), vec2(1.+side(.3,.05), .05));\n    float eye1 = min(min(ballArc, lensArc), wireLine) * sign(eye);\n    float socket = min(\n        sdBox(vec2(p.x,abs(p.y))-vec2(1,.6),vec2(.3,.05)),\n        sdBox(vec2(p.x,abs(p.y))-vec2(1.25,.55),vec2(.05,.05))\n    );\n    //if (false)\n        return min(eye1, socket); // proper sdf\n    return min(eye, socket); // original sdf\n}\n\nvec2 getNormal(vec2 p)\n{    \n\tvec2 e = vec2(_precision, 0);\n    return normalize(vec2(scene(p+e.xy)-scene(p-e.xy),scene(p+e.yx)-scene(p-e.yx)));\n}\n\nvoid visualize(vec2 ro, vec2 rd, float t, float d, float i)\n{\n    vec2 n = getNormal(ro+rd*t);\n    \n    float x  = clamp(floor(T)-i,0.,1.);\n    float f1 = x + (1.-x) * fract(T);\n    float f2 = clamp((f1-.75)*16.,0.,1.);\n    float f3 = floor(abs(cos(min(f1*8.,1.)*6.283))+.5);\n    float a  = mix(atan(-n.y,-n.x),atan(rd.y,rd.x),f2);\n\n    // ray line\n    _d = min(_d,sdLine(_p,ro+rd*t,ro+rd*t+vec2(cos(a),sin(a))*d*floor(f3)));\n\n    // step indicator\n    _d = min(_d,length(_p-ro-rd*t)-.015);\n\n    if (i == floor(T))\n    {\n        // circle\n        _d = min(_d,abs(length(_p-ro-rd*t)-clamp(d*f3,0.,1e4)));\n    }\n}\n\nvec4 march(vec2 ro, vec2 rd)\n{\n    float t = 0., s = float(maxSteps), d;\n\n    for(float i = 0.; i < maxSteps; i++)\n    {\n        d = scene(ro+rd*t);\n\n        if (d < _precision || t > maxDistance || i > floor(T))\n        {\n            s = float(i);\n            break;\n        }\n\n\t\tvisualize(ro,rd,t,d,i);\n        \n        t += d;\n    }\n    \n    return vec4(ro+rd*t,d,s);\n}\n\nvoid swap(inout vec2 a, inout vec2 b)\n{\n    vec2 z = a;\n    a = b;\n    b = z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zero = min(0., iTime);\n\n    _p = (2.*fragCoord.xy-iResolution.xy)/iResolution.yy;\n\tvec2 m = (2.*iMouse.xy-iResolution.xy)/iResolution.yy;\n    vec2 c = (2.*abs(iMouse.zw)-iResolution.xy)/iResolution.yy;\n    bool demo = iMouse.z == 0.;\n    \n    if (demo)\n    {\n        float a = .3 * iTime;\n        c = vec2(.5, 0.) + .5 * vec2(cos(a), sin(a));\n        m = c;\n    }\n    else if (visualizeRay())\n    {\n        //swap(m, c);\n    }\n    else\n    {\n        c = m;\n    }\n    \n    vec2 ro = c;//vec2(-1,0);\n    vec2 rd = normalize(m-ro);\n    vec4 h  = march(ro,rd);\n    \n    // camera & scene\n    _d = min(_d,min(min(abs(length(_p-ro)-.01),sdLine(_p,ro,ro+rd*.05)),scene(_p)));\n        \n    // normal arrow\n    if (h.z < _precision)\n    {\n        vec2 n = getNormal(h.xy);\n        vec2 t = vec2(-n.y,n.x);\n\n        _d = min(_d,sdLine(_p,h.xy,h.xy+n*.1));\n        _d = min(_d,sdLine(_p,h.xy+n*.1,h.xy+n*.1+t*.025));\n        _d = min(_d,sdLine(_p,h.xy+n*.1,h.xy+n*.1-t*.025));\n        _d = min(_d,sdLine(_p,h.xy+n*.1+t*.025,h.xy+n*.125));\n        _d = min(_d,sdLine(_p,h.xy+n*.1-t*.025,h.xy+n*.125));\n    }\n    \n    _d = abs(_d)-1./iResolution.y;\n    \n\tfragColor = vec4(vec3(smoothstep(_d,_d+.005,.005)),1.0);\n\n    vec4 col = vec4(0);\n    for (int i=1 ; i<2*AA ; i+=2)\n    for (int j=1 ; j<2*AA ; j+=2)\n    {\n        vec2 jitter = (vec2(i, j) / float(AA) - .5) / iResolution.yy;\n        vec2 ro1 = ro;// + jitter;\n        vec2 _p1 = _p + jitter;\n        vec2 rd1 = normalize(_p1 - ro1);\n        float r = length(_p1 - ro1);\n        float t1 = 0.;\n        for (int i=0 ; i<iterations*substep ; ++i)\n        {\n            t1 += scene(ro1 + rd1 * t1) / float(substep);\n            //col += vec4(1,0,0,1) * max(0., 1. - abs(t1 - r) * iResolution.y / 1.);\n            col += vec4(1,0,0,1) * step(abs(t1 - r) * iResolution.y, 1.);\n        }\n    }\n    col /= float(AA * AA);\n    fragColor = col + fragColor * (1. - col.w);\n    fragColor.xyz = pow(fragColor.xyz, vec3(.45));\n    //fragColor = vec4(visualizeRay());\n    \n    //fragColor = vec4(sin(scene(_p) * iResolution.y));\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}