{
    "Shader": {
        "info": {
            "date": "1530359751",
            "description": "Refraction, Hue shift",
            "flags": 0,
            "hasliked": 0,
            "id": "MdVfWy",
            "likes": 26,
            "name": "Refraction & Hue shift",
            "published": 3,
            "tags": [
                "raymarching",
                "refraction",
                "hue"
            ],
            "usePreview": 0,
            "username": "setchi",
            "viewed": 1128
        },
        "renderpass": [
            {
                "code": "#define PI 3.141592654\n#define HASHSCALE1 .1031\n\nconst float EPS = 1e-2;\nfloat OFFSET = EPS * 5.0;\nfloat TIME;\n\nvec3 hue(float hue) {\n    vec3 rgb = fract(hue + vec3(0., 2. / 3., 1. / 3.));\n    rgb = abs(rgb * 2. - 1.);\n    return clamp(rgb * 3. - 1., 0., 1.);\n}\n\nvec3 hsvToRgb(vec3 hsv) {\n    return ((hue(hsv.x) - 1.) * hsv.y + 1.) * hsv.z;\n}\n\nfloat hash11(float p) {\n    vec3 p3 = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash12(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 rotate2d(vec2 p, float angle) {\n    return p * mat2(cos(angle), -sin(angle),\n        sin(angle), cos(angle));\n}\n\nvec3 rotateX(vec3 p, float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec3(p.x, c * p.y + s * p.z, -s * p.y + c * p.z);\n}\n\nvec3 rotateY(vec3 p, float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec3(c * p.x - s * p.z, p.y, s * p.x + c * p.z);\n}\n\nfloat qinticInOut(float t) {\n    return t < 0.5 ?\n        +16.0 * pow(t, 5.0) :\n        -0.5 * pow(2.0 * t - 2.0, 5.0) + 1.0;\n}\n\nfloat sineInOut(float t) {\n    return -0.5 * (cos(PI * t) - 1.0);\n}\n\nfloat box(vec2 p, float size) {\n    p += 0.5;\n    size = 0.5 + size * 0.5;\n    p = step(p, vec2(size)) * step(1.0 - p, vec2(size));\n    return p.x * p.y;\n}\n\nfloat postEffectPattern(vec2 p) {\n    float t1 = fract(TIME);\n    float e11 = qinticInOut(t1) - 0.5;\n\n    float t2 = fract(TIME - 0.05);\n    float e21 = qinticInOut(t2) - 0.5;\n    float e22 = sineInOut(t2) - 0.5;\n\n    float ofs = 0.6 + TIME * 0.2;\n    float diff = 0.35;\n    float scale = 1.3;\n\n    float index = 2.;\n    index = mix(index, 5., box(rotate2d(p, PI * e11 + ofs + diff * 1.), scale * 3.6 * abs(e11)));\n    index = mix(index, 4., box(rotate2d(p, PI * e11 + ofs + diff * 2.), scale * 3.6 * abs(e11)));\n    index = mix(index, 1., box(rotate2d(p, PI * e21 + ofs + diff * 3. + 0.2), scale * 3.6 * abs(e21)));\n    index = mix(index, 0., box(rotate2d(p, PI * e21 + ofs + diff * 3. + 0.2), scale * 3.0 * abs(e21)));\n    index = mix(3., index, box(rotate2d(p, PI * e22 + ofs + diff * 0.), 20. * abs(e22)));\n\n    return index;\n}\n\nfloat sdHexPrism(vec3 p, vec2 h) {\n    vec3 q = abs(p);\n    return max(q.z - h.y, max((q.x * 0.866025 + q.y * 0.5), q.y) - h.x);\n}\n\nfloat sdPlane(vec3 p) {\n    return p.y + 5.;\n}\n\nfloat udBox(vec3 p, vec3 b, float r) {\n    return length(max(abs(p) - b, 0.0)) - r;\n}\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat dGlass(vec3 p) {\n    float it = mod(floor(TIME - 0.5), 4.);\n\n    if (it == 0.)\n        return sdSphere(p, .6);\n    if (it == 1.)\n        return sdTorus(rotateX(p, PI / 2.), vec2(.5, .2));\n    if (it == 2.)\n        return sdHexPrism(p, vec2(0.45));\n    if (it == 3.)\n        return udBox(rotateY(rotateX(p, PI / 4.), PI / 4.), vec3(0.4), 0.05);\n}\n\nfloat map(vec3 p) {\n    float b = sdPlane(p);\n    float c = dGlass(p);\n    return min(b, c);\n}\n\nvec3 floorPattern(vec2 p) {\n    return vec3(0.2) * mod(floor(p.x * 0.3) + floor(p.y * 0.3), 2.0);\n}\n\nvec2 intersect(vec3 ro, vec3 ray) {\n    float t = 0.0;\n    for (int i = 0; i < 256; i++) {\n        float res = abs(map(ro + ray * t));\n        if (res < 0.005) return vec2(t, res);\n        t += res;\n    }\n\n    return vec2(-1.0);\n}\n\nvec3 normal(vec3 pos, float e) {\n    vec3 eps = vec3(e, 0.0, 0.0);\n\n    return normalize(vec3(\n        map(pos + eps.xyy) - map(pos - eps.xyy),\n        map(pos + eps.yxy) - map(pos - eps.yxy),\n        map(pos + eps.yyx) - map(pos - eps.yyx)));\n}\n\nmat3 createCamera(vec3 ro, vec3 ta, float cr) {\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvec3 renderScene(vec2 p) {\n    float t1 = fract(TIME);\n    float e1 = qinticInOut(t1) - 0.5;\n    float e2 = sineInOut(t1) - 0.5;\n    float ofs = 0.6 + TIME * 0.2;\n    float t2 = abs(1. - e2 - ofs) * PI;\n\n    vec3 ro = vec3(cos(t2) * 24. * e1, 2., sin(t2) * 24. * e1);\n    vec3 ta = vec3(0);\n    mat3 cm = createCamera(ro, ta, 0.);\n    vec3 ray = cm * normalize(vec3(p, 10.0));\n\n    vec3 fresnel = vec3(0);\n\n    for (int i = 0; i < 6; i++) {\n        vec2 res = intersect(ro, ray);\n\n        if (res.y <= -0.5) {\n            return vec3(1);\n        }\n\n        vec3 pos = ro + ray * res.x;\n        vec3 nor = normal(pos, 0.008);\n\n        if (dGlass(pos) > 0.005) {\n            vec3 col = vec3(0);\n            col += floorPattern(pos.xz);\n            col += fresnel;\n            return col + vec3(0.001, 0.002, 0.004) * res.x * 3.;\n        }\n\n        if (i == 0 && dot(-ray, nor) < 0.5) {\n            float a = 1. - dot(-ray, nor) * 2.;\n            fresnel = mix(fresnel, vec3(0., 0.8, 0.8), a);\n        }\n\n        float eta = 1.1;\n\n        bool into = dot(-ray, nor) > 0.0;\n        nor = into ? nor : -nor;\n        eta = into ? 1.0 / eta : eta;\n\n        ro = pos - nor * OFFSET;\n        ray = refract(ray, nor, eta);\n\n        if (ray == vec3(0.0)) {\n            ro = pos + nor * OFFSET;\n            ray = reflect(ray, nor);\n        }\n    }\n}\n\nvec3 render(vec2 p) {\n    vec3 col = renderScene(p);\n    float effect = postEffectPattern(p);\n    float hue = hash11(floor(TIME + 0.5));\n\n    if (effect == 0.)\n        return col;\n    if (effect == 1.)\n        return hsvToRgb(vec3(hue + p.x * .08, 1, 1));\n    if (effect == 2.)\n        return mix(col, hsvToRgb(vec3(hue - 0.2 - p.y * .08, 1, 1)), 0.7);\n    if (effect == 3.)\n        return vec3(1.);\n\n    return mix(col, hsvToRgb(vec3(hue + (effect - 4.) * 0.1, 1, 1)), 0.7);\n}\n\nvec3 aaRender(vec2 p) {\n    vec3 col = vec3(0.0);\n    const int num = 4;\n\n    for (int i = 0; i < num; i++) {\n        float fi = float(i + 1);\n        col += render(p + vec2(step(fi, 2.001), mod(fi, 2.001)) * 0.0015);\n    }\n\n    return col / float(num);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    float timeScale = 0.7;\n    TIME = iTime * timeScale + 10.;\n\n    vec3 col = aaRender(uv);\n    fragColor = vec4(pow(col, vec3(1.0 / 2.2)), 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}