{
    "Shader": {
        "info": {
            "date": "1556190548",
            "description": "just playing around with sdfs, the code is a mess",
            "flags": 0,
            "hasliked": 0,
            "id": "wtlGWn",
            "likes": 2,
            "name": "Heating Coils",
            "published": 3,
            "tags": [
                "sdfbeginner"
            ],
            "usePreview": 0,
            "username": "madpew",
            "viewed": 110
        },
        "renderpass": [
            {
                "code": "float max_depth = 70.;\n\nfloat box(vec3 p, vec3 c)\n{\n  vec3 q = abs(p)-c;\n  return min(0., max(q.x, max(q.y, q.z))) + length(max(q,0.));\n}\n\nfloat sphere(vec3 p, float r)\n{\n  return length(p)-r;\n}\n\nfloat torus(vec3 p, vec2 t)\n{\nvec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\nfloat handle_glow = 0.;\nfloat gate_glow = 0.;\nfloat pulse_glow = 0.;\n\n// the SDF map\nfloat map(vec3 p)\n{\n  vec3 op = p;\n  vec3 pulse_p = mod(p, vec3(5.,5.,5.))-vec3(2.5,2.5,2.5);\n  vec3 p2 = mod(p, 6.)-6.*.5;\n  p = mod(p,3.)-3.*.5; // fold the scene, offset mod\n  float angle = p.z*3.1415*1.;\n  \n  vec3 pr = p;\n  pr.x = p.x * cos(angle) - p.y * sin(angle);\n  pr.y = p.x * sin(angle) + p.y * cos(angle);\n  float result = 0.;\n  \n  float grid = min(box(p2+vec3(0,0,-3), vec3(4,.2,.2)), box(p2+vec3(0,0,0), vec3(.2,4,.2)));\n  \n  float handle_thickness = 0.2 + 0.05 * sin(op.z+iTime*4.);\n  float handle = box(pr, vec3(handle_thickness,handle_thickness,4));\n  float gate = torus(p, vec2(.45,.05));\n  \n  float pulse = sphere(vec3(0,0,-0.8 + 0.1*sin(iTime)), 0.20);\n\n  gate_glow += pow(1. - min(gate, 1.), 10.);\n  handle_glow += pow(0.5 - min(handle, 0.5), 3.);\n  pulse_glow += pow(1. - min(pulse, 1.), 5.);\n  \n  result = min(min(handle, grid), gate);\n  \n  return result;\n  \n}\n\nvec3 n(vec3 p)\n{\n  vec2 eps = vec2(0.0001, 0.);\n  return normalize(vec3(map(p+eps.xyy) - map(p-eps.xyy), map(p+eps.yxy) - map(p-eps.yxy), map(p+eps.yyx) - map(p-eps.yyx)));\n}\n\nfloat diffuse(vec3 n, vec3 l)\n{\n  return dot(n, normalize(l))*.3+.7;\n}\n\nvec4 raymarch(vec2 uv)\n{\n  // ray marching\n  vec3 ro = vec3(0,0,-13); // ray origin\n  vec3 rd = normalize(vec3(uv, 1)); // ray direction / cam direction\n  \n  // move camera around\n  ro.x += sin(iTime)*.4;\n  ro.y += sin(iTime*.6)*.6;\n  ro.z = iTime*1.9; //0\n  \n  rd.x += sin(iTime*.4)*0.2; // left right camera\n  rd.y += sin(iTime*.3)*0.2; // up down camera\n  rd.z += 1.;//0.3*sin(iTime)+0.7; \n  rd = normalize(rd);\n  \n  vec3 p = ro; // current point\n  \n  float depth = 0.;\n  bool hit = false;\n  float pathlen = 0.;\n  \n  for(float i=0.;i<max_depth; i++) // depth trace steps\n  { \n    float d = map(p); // get SDF\n    \n    if (d<0.001)\n    {\n      depth = i/max_depth;\n      hit = true;\n      break;\n    }\n    \n    rd.x = rd.x + 0.00005*pathlen*sin(iTime+pathlen*0.2 + sin(iTime));\n    rd.y = rd.y + 0.00005*pathlen*sin(iTime+pathlen*0.2 + cos(iTime));\n    \n    vec3 rd2 = rd;\n    float angle = d*.9*.1;\n    rd.x = rd2.x * cos(angle) - rd2.y * sin(angle);\n    rd.y = rd2.x * sin(angle) + rd2.y * cos(angle);\n\n    p += d * rd * 0.9;\n    pathlen += d * 0.9;\n  }\n  \n  vec3 color = vec3(1.5,1.5,1.2);\n  \n  if (hit)\n  {\n    // depth debug\n    color = vec3(1.-depth);\n    \n    // normal debug\n    color += .2 * n(p);\n    color += vec3(diffuse(n(p), vec3(0.5,-2.2,-2.))) * texture(iChannel0, p.xz + p.xy).xxx;\n    \n  }\n  \n  color += vec3(1,.3,0) * gate_glow * 0.2;\n  color += vec3(.3,.2,.1) * handle_glow;\n  color += vec3(0,0,1) * (pulse_glow*0.4);\n      \n  \n  // fog\n  float fog = length(ro-p);\n  color = mix(color, vec3(0.35,0.35,.35),1.-exp(-0.003*fog*fog));\n\n  return vec4(color,1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy;\n  uv -= 0.5;\n  \n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  // uv = uv - mod(uv, .004);\n\n  // rotate and bend uv\n  vec2 uv2 = uv;\n  uv2.x = uv.x * cos(iTime*.2 + uv.y*.2) - uv.y * sin(iTime*.2 + uv.x*.2);\n  uv2.y = uv.y * cos(iTime*.2 + uv.x*.2) + uv.x * sin(iTime*.2 + uv.y*.2);\n  \n  vec4 c = raymarch(uv2);\n  \n  // gamma and grading\n  fragColor = pow(c, 1.5*vec4(1.0,1.0,1.0,1));\n   \n  // vignette\n  fragColor -= mix(vec4(0),fragColor,.5*dot(uv,uv)+.5);\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}