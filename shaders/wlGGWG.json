{
    "Shader": {
        "info": {
            "date": "1579844164",
            "description": "traning. 麻の葉",
            "flags": 0,
            "hasliked": 0,
            "id": "wlGGWG",
            "likes": 62,
            "name": "Ashanoha",
            "published": 3,
            "tags": [
                "pattern",
                "japanese",
                "traning",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "coposuke",
            "viewed": 28538
        },
        "renderpass": [
            {
                "code": "#define PI  \t3.14159265357989\n#define TAU \t(PI * 2.0)\n#define HEX_COS (0.86602540378443 * 0.5)\n#define HEX_TAN (0.57735026918962 * 0.5)\n\n\nstruct Animation\n{\n    float screenAngle;\n    float screenScale;\n    vec2  screenOffset;\n    float lineWidth;\n    float lineColorOffset;\n    float meshColorOffset;\n    float meshColorDist;\n    float lightAngle;\n    float blendLine;\n    float blendSolid;\n    float blendMesh;\n};\n\n\nmat2 rotate(float angle)\n{\n    float s = sin(angle), c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nvec2 pmod(vec2 pos, float num, out float id)\n{\n    float angle = atan(pos.x, pos.y) + PI / num;\n    float split = TAU / num;\n    id = floor(angle / split);\n\tangle = id * split;\n    return rotate(-angle) * pos;\n}\n\nfloat cubicInOut(float time)\n{\n  return (time < 0.5) ? (4.0 * time * time * time) : (1.0 - 4.0 * pow(1.0 - time, 3.0));\n}\n\n// for line\nvoid map(vec2 uv, out vec3 near, out vec3 neighbor)\n{\n    vec2 point;\n    near = vec3(1e+4);\n\n    for(float y=-1.0; y<=1.0; y+=2.0)\n    {\n        point = vec2(0.0, HEX_COS + y * HEX_TAN * 0.25);\n        float dist = distance(uv, point);\n        near = near.z < dist ? near : vec3(point, dist);\n    }\n    \n    for(float x=-1.0; x<=1.0; x+=2.0)\n    {\n\t    for(float y=-1.0; y<=1.0; y+=2.0)\n        {\n            for(float both=-1.0; both<=1.0; both+=2.0)\n            {\n                point = vec2(x * 0.125, HEX_COS + y * HEX_COS * 0.5);\n                point.x += both * 0.5     * 0.125 * -x;\n                point.y += both * HEX_TAN * 0.125 * -y;\n                float dist = distance(uv, point);\n                near = near.z < dist ? near : vec3(point, dist);\n            }\n        }\n    }\n    \n    neighbor = vec3(1e+4);\n    \n    for(float y=-1.0; y<=1.0; y+=2.0)\n    {\n        point = vec2(0.0, HEX_COS + y * HEX_TAN * 0.25);\n        if(near.xy != point)\n        {\n            vec2 center = (point + near.xy) * 0.5;\n            float dist = dot(uv - center, normalize(near.xy - point));\n            neighbor = neighbor.z < dist ? neighbor : vec3(point, dist);\n        }\n    }\n    \n    for(float x=-1.0; x<=1.0; x+=2.0)\n    {\n\t    for(float y=-1.0; y<=1.0; y+=2.0)\n        {\n            for(float both=-1.0; both<=1.0; both+=2.0)\n            {\n                point = vec2(x * 0.125, HEX_COS + y * HEX_COS * 0.5);\n                point.x += both * 0.5     * 0.125 * -x;\n                point.y += both * HEX_TAN * 0.125 * -y;\n                \n                if(near.xy != point)\n                {\n                    vec2 center = (point + near.xy) * 0.5;\n                    float dist = dot(uv - center, normalize(near.xy - point));\n                    neighbor = neighbor.z < dist ? neighbor : vec3(point, dist);\n                }\n            }\n        }\n    }\n}\n\n// for normal\nvec4 normalmap(vec2 uv)\n{\n    vec2 point = vec2(0);\n    vec3 near = vec3(1e+4);\n    vec3 neighbor = vec3(1e+4);\n    \n    for(float y=-1.0; y<=1.0; y+=2.0)\n    {\n        point = vec2(0.0, HEX_COS + y * HEX_TAN * 0.5);\n        float dist = distance(uv, point);\n        near = near.z < dist ? near : vec3(point, dist);\n    }\n    \n\tfor(float y=-1.0; y<=1.0; y+=2.0)\n    {\n        point = vec2(0.0, HEX_COS + y * HEX_TAN * 0.5);\n        if(near.xy != point)\n        {\n            vec2 center = (point + near.xy) * 0.5;\n            float dist = dot(uv - center, normalize(near.xy - point));\n            neighbor = neighbor.z < dist ? neighbor : vec3(point, dist);\n        }\n    }\n    \n    for(float x=-1.0; x<=1.0; x+=2.0)\n    {\n\t    for(float y=-1.0; y<=1.0; y+=2.0)\n        {\n            point = vec2(x * 0.25, HEX_COS - y * (HEX_COS - HEX_TAN * 0.5));\n            vec2 center = (point + near.xy) * 0.5;\n            float dist = dot(uv - center, normalize(near.xy - point));\n            neighbor = neighbor.z < dist ? neighbor : vec3(point, dist);\n        }\n    }\n    \n    return vec4(normalize(vec3(neighbor.xy - near.xy, 1.0)), neighbor.z);\n}\n\nvoid animate(float time, vec2 uv, inout Animation anim)\n{\n    float animLoop = floor(floor(time) / 13.0);\n    float animType = mod(floor(time), 13.0);\n    float animTime = fract(time);\n    float clockwise = mod(animLoop, 2.0) <= 0.0 ? 1.0 : -1.0;\n    \n    anim.screenScale = 2.0;\n    anim.screenAngle = PI * 0.166667;\n    anim.screenOffset= vec2(0, 0);\n    anim.lineWidth   = 0.01;\n    anim.lineColorOffset = 0.0;\n    anim.meshColorOffset = 0.0;\n    anim.meshColorDist = 200.0;\n    anim.lightAngle = 0.0;\n    anim.blendLine = 0.0;\n    anim.blendMesh = 0.0;\n    anim.blendSolid = 0.0;\n    \n    if(animType <= 0.0)\n    {\n        anim.screenScale = cubicInOut(animTime) * 1.0 + 1.0;\n    \tanim.lineWidth   = cubicInOut(1.0 - animTime) * 0.4 + 0.01;\n    \tanim.lineColorOffset = animTime;\n    \tanim.blendLine = 1.0;\n    }\n    else if(animType <= 1.0)\n    {\n        anim.screenScale -= animTime * 0.02;\n    \tanim.lineColorOffset = PI * 2.0 * animTime;\n    \tanim.blendLine = 1.0;\n    }\n    else if(animType <= 2.0)\n    {\n        anim.screenScale -= animTime * 0.02 + 0.02;\n    \tanim.lineColorOffset = PI * 2.0 * animTime;\n        anim.meshColorOffset = PI * 3.0 * animTime;\n    \tanim.blendLine = smoothstep(1.0, 0.0, animTime);\n    \tanim.blendMesh = smoothstep(0.0, 1.0, animTime);\n    }\n    else if(animType <= 3.0)\n    {\n        anim.screenScale -= animTime * 0.02 + 0.04;\n        anim.meshColorOffset = PI * 3.0 * animTime + PI;\n    \tanim.meshColorDist = smoothstep(1.0, 0.2, animTime) * 200.0;\n   \t \tanim.lightAngle  = PI * 2.0 * time;\n    \tanim.blendMesh = smoothstep(0.8, 0.2, animTime);\n    \tanim.blendSolid = smoothstep(0.0, 1.0, animTime);\n    }\n    else if(animType <= 4.0)\n    {\n        anim.screenScale -= animTime * 0.02 + 0.06;\n    \tanim.blendSolid = 1.0;\n    }\n    else if(animType <= 10.0)\n    {\n        animTime += animType - 5.0;\n        anim.screenScale -= clamp(animTime * 0.02 + 0.08, 0.0, 0.1);\n        animTime /= 11.0 - 5.0;\n        anim.screenAngle += smoothstep(0.0, 1.0, animTime) * PI * 0.5 * clockwise;\n        \n        uv = rotate(PI * 2.0 * animTime * clockwise) * uv;\n        float pos = abs(uv.x + 0.0) + animTime;\n        float blend = smoothstep(-0.1, 0.0, sin(pos * PI * 3.0 * sin(animTime * PI)));\n    \tanim.blendSolid = blend;\n        anim.blendLine = 1.0 - blend;\n    \tanim.lineColorOffset = PI * 2.0 * animTime;\n    }\n    else if(animType <= 11.0)\n    {\n        anim.screenScale -= 0.1;\n        anim.screenAngle += PI * 0.5 * clockwise;\n        anim.lightAngle += PI * 2.0 * animTime;\n    \tanim.blendSolid = 1.0;\n    }\n    else if(animType <= 12.0)\n    {\n        anim.screenScale -= 0.1;\n        anim.screenAngle += PI * 0.5 * clockwise;\n        anim.lightAngle += PI * 2.0 * animTime;\n\n        float lineTime = (sin(animTime * PI * 3.0 - PI * 0.5) * 0.5 + 0.5);\n        lineTime = lineTime * lineTime * (animTime - (uv.x * uv.y * 0.2));\n        anim.lineWidth = clamp(lineTime, 0.0, 1.0) * 0.5;\n        anim.blendLine = 1.0;\n    \tanim.blendSolid = 1.0;\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n \n    // animation\n    Animation anim;\n    animate(iTime, uv, anim);\n    \n    // view\n    uv *= anim.screenScale;\n    uv += anim.screenOffset;\n    uv = rotate(anim.screenAngle) * uv;\n\n    // tiling\n    vec2 uvLocal = uv;\n    uvLocal.x = mod(uv.x, 1.0) - 0.5;\n    uvLocal.y = mod(uv.y, HEX_COS * 2.0) - HEX_COS;\n    \n    // rot tiling\n    float id;\n    uvLocal = pmod(uvLocal, 6.0, id);\n\n    // scene\n    vec3 near, neighbor;\n    map(uvLocal, near, neighbor);\n    \n    // lighting\n    vec4 normal = normalmap(uvLocal);\n    normal.xy = rotate(id * PI / 3.0) * normal.xy;\n    float dist = normal.w;\n    dist = 1.0 - pow(1.0 - dist, 20.0);\n\n    vec3 lightDir = normalize(vec3(rotate(anim.lightAngle) * vec2(1,0), 0.25));\n    float light = dot(normal.xyz, lightDir) * 0.8 + 0.2;\n    \n    // draw\n    float lineWidth = (1.0 - smoothstep(0.0, anim.lineWidth, neighbor.z));\n    vec3 lineColor = cos(vec3(0,2,4) * PI / 3.0 + anim.lineColorOffset) * 0.25 + 1.0;\n    vec3 meshColor = cos(vec3(0,2,4) * PI / 3.0 + anim.meshColorOffset + anim.meshColorDist * neighbor.z) * 0.35 + 0.65;\n    float solid = (dist * light) * 0.6 + 0.2;\n    solid = 1.0 - pow(1.0 - solid, 3.0);\n    \n    fragColor.rgb = vec3(0);\n    fragColor.rgb = mix(fragColor.rgb, vec3(solid), anim.blendSolid);\n    fragColor.rgb = mix(fragColor.rgb, lineColor, lineWidth * anim.blendLine);\n    fragColor.rgb = mix(fragColor.rgb, meshColor, anim.blendMesh);\n    \n    // degamma\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0 / 2.2));\n    \n    // displacement\n    fragColor.a = mix(0.0, normal.w * 4.0, anim.blendSolid);\n    \n    // debug\n    //fragColor.gb = vec2(0);\n    //fragColor.r = 1.0 - pow(1.0 - near.z, 5.0);\n    //fragColor.r = neighbor.z * 10.0;\n    //fragColor.r = normal.w * 7.0;\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Ashanoha\",\n\t\"description\": \"soundproof cushion\",\n\t\"model\": \"car\"\n}\n*/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}