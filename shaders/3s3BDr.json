{
    "Shader": {
        "info": {
            "date": "1604767261",
            "description": "Using a texture buffer to store more (recursively useful) costas arrays\nIdeally this becomes a512x512 or 1024x1024 texture of greater utility (of making procgen hashes/noises/melodies) than any other (static but faster for being static) noisy texutre.",
            "flags": 32,
            "hasliked": 0,
            "id": "3s3BDr",
            "likes": 1,
            "name": "Costas8 LUT-texture #0",
            "published": 3,
            "tags": [
                "noise",
                "fft",
                "gradient",
                "dither",
                "derivative",
                "fourier",
                "distribution",
                "dft",
                "dft",
                "laplachian",
                "costasarray",
                "patternfree",
                "unniquederivati"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 371
        },
        "renderpass": [
            {
                "code": "//i forgot, it only stores 8 bit per .rgb so values>255 must be split\n//and i fail at buffering and reading values\n//well that was a nice day ofclassifying costasArrays...\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n   ;fragColor=texture(iChannel3,(fragCoord+.5)/iResolution.xy)\n    ;return\n    \n        \n        //remember the ealsy exit here!!!\n        \n        \n    ;vec2 q = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n#ifdef SHOW_FOURIER\n    if (q.x > 0.5)\n    {\n        vec2 dft = textureLod(iChannel1, q-vec2(0.5,0.0), 0.).xy;\n        float amp = length(dft) / SIZE; \n        col = vec3(amp);\n    }\t\n    else\n#endif\n    {\n        col = textureLod(iChannel0, q, 0.).rgb;\n        //col = length(col)*vec3(0.577);\n    }\n    \n    //Distribution plot\n    float tot = 0.;\n    if (fragCoord.y> SIZE && fragCoord.x < SIZE)\n    {\n        const float bands = 60.;\n        float bt = floor(fragCoord.x*bands/SIZE);\n        float pt = (floor((fragCoord.x)*bands/SIZE)+0.5)/bands;\n        const float width = 6.;\n        for (float j = 0.; j<=width; j++)\n        for (float i = 0.; i<SIZE; i++)\n        {\n            float v = texelFetch(iChannel0, ivec2(bt+j, i + 0.5), 0).x;\n            if (abs(v-pt) < .5/bands)\n            \ttot += 1.;\n        }\n        tot /= SIZE*width;\n        col.rgb = vec3(smoothstep(0.00,1.,tot*SIZE-fragCoord.y + SIZE + 1.))*vec3(.4,.4,.5);\n        col.rgb += vec3(smoothstep(1.,0.,abs(tot*SIZE-fragCoord.y + SIZE + 0.5)))*vec3(.8,.8,.8);\n        if(fragCoord.y < (SIZE+50.))\n        {\n        \tcol.rgb = max(col.rgb, vec3(0.9,0.6,0.1)*vec3(smoothstep(1.4,0.,abs(fragCoord.x - SIZE/2.))));\n        \tcol.rgb = max(col.rgb, vec3(0.55,0.5,0.4)*vec3(smoothstep(1.4,0.,abs(abs(fragCoord.x - SIZE/2.)-SIZE/4.))));\n        }\n    }\n    \n    //First and second derivatives plot\n    if (fragCoord.y> SIZE && fragCoord.x > SIZE)\n    {\n        col = vec3(1);\n#ifndef DIAGONAL_DERIVATIVES \n        //Horizontal derivatives\n        float t0 = texelFetch(iChannel0, ivec2(fragCoord.x - SIZE, SIZE),0).x;\n        float t1 = texelFetch(iChannel0, ivec2(fragCoord.x-1. - SIZE, SIZE),0).x;\n        float t2 = texelFetch(iChannel0, ivec2(fragCoord.x+1. - SIZE, SIZE),0).x;\n#else\n        //Diagonal derivative\n        float t0 = texelFetch(iChannel0, ivec2(fragCoord.x - SIZE, SIZE+1.),0).x;\n        float t1 = texelFetch(iChannel0, ivec2(fragCoord.x-1. - SIZE, SIZE),0).x;\n        float t2 = texelFetch(iChannel0, ivec2(fragCoord.x+1. - SIZE, SIZE+2.),0).x;\n#endif\n        float dr = (t0 - t1)*iResolution.x*0.00025/globalScale;\n        float dr2 = (t1 + t2 - t0*2.)*iResolution.x*0.001/globalScale;\n    \n        col.rgb = smoothstep(1.5,.0, abs(dr*SIZE-fragCoord.y + SIZE + 35.))*vec3(1.0,0.7,0.3);\n        col.rgb += smoothstep(1.5,.0, abs(dr2*SIZE-fragCoord.y + SIZE + 10.))*vec3(0.5,0.7,1);\n    \n    }\n    \n    col *= smoothstep(0.,1.7,abs(fragCoord.y-SIZE+1.));\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n//Type 1 = Orbit noise (https://www.shadertoy.com/view/4t3yDn)\n//Type 2 = Bicubic noise (https://www.shadertoy.com/view/XlVcWV)\n//Type 3 = Value noise\n//Type 4 = Gradient noise (from iq : https://www.shadertoy.com/view/XdXGW8)\n//Type 5 = Simplex noise (modified from iq's to use normalized gradients as per the original paper)\n//Type 6 = FBM (base noise can be defined in buffer A)\n#define NOISE_TYPE 1\n\n//#define SCROLL_COORDS\n#define DIAGONAL_DERIVATIVES\n#define SHOW_FOURIER\n#define SIZE (floor(iResolution.y/2.5)*2.)\n\nconst float globalScale = 1.;\n\n\n//See: https://www.shadertoy.com/view/Xt3cDn\nuint baseHash(uvec2 p)\n{\n    uint h32 = p.y + 374761393U + p.x*3266489917U;\n    h32 = 2246822519U*(h32^(h32 >> 15));\n    h32 = 3266489917U*(h32^(h32 >> 13));\n    return h32^(h32 >> 16);\n}\n\nfloat hash12(vec2 x)\n{\n    uint n = baseHash(uvec2(ivec2(x)));\n    return float(n)*(1.0/float(0xffffffffU));\n}\n\nvec2 hash22(vec2 x)\n{\n    uint n = baseHash(uvec2(ivec2(x)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec4 hash42(vec2 x)\n{\n    uint n = baseHash(uvec2(ivec2(x)));\n    uint n2 = n*48271U;\n    uvec4 rz = uvec4(n, n*16807U, n*n*48271U, n*n*69621U);\n    return vec4(rz & uvec4(0x7fffffffU))/float(0x7fffffff);\n}\n//end of signal inspector\n\n\n/*\n//the idea, cycle multiple pallettes of multiple tiled costas arrays, each of them a prime in size.\n//and then do a weighted mix\n//the result should be a weightable noise/dither, with very large period (depending on LUT sizes)\n\n//this can come close to a VERY large animarteable 2d bluenoise, that is generated on runtime, and hashable.\n\n//currently in experimental stage.\n//the diagonal banding is a bit diasssapointing.\n//this is due to, where ever mod(x,n)=mod(y,n) for quite similar N\n//gets the same inputs for small tiles (which are stronger in blue noise)\n    \n//lets just try larger primes&tiles\n//and hope that prime-gaps being less repetitie will remove the banding.\n\n//added NAIVE detection of both diagonal mirrorings\n\n//todo, with this i am very close to ANIMATED blue noise\n\n\nmixed prime base animated bluenoise\nthe idea is, to have a number, where each digit has a different base\n, and each base is a prime\n, and the 0th digit has the largest prime (like 13) \n, and the Nth digit has the smallest prime == 3\nthis way, small primes auromatically have an exponential effect\non the generated cumulative number\n(this may not be worth its calculation though, but i will solve for it once)\n\neach prime is a tiled layer, animated with a different offset, over time, set by \na pqfm, primal quadratic field matrix.\nso that 2 space domains, and 1 dtime domain, bith have period as long as possible.\n\ni also have a bias for costasArrays (of prime-size), that are \n- diagonally mirror symmetric\n- animate NICELY, when tiled and pallette shifted.\n/**/\n\n#define arrLen 40\n    \n#define animatePaletteSpeed .9\n\n//tile sizes\n//int gpo(int a){int b[arrLen]=int[7](241,239,281,269,19,17,13);return b[a];}\n\nint gpo(int i\n){int p[]=int[arrLen](2,3,5,7,11,13,17,19,23,29,31,37,41,47,53,59,61,67,71,79,101,107,137,149,167\n                 ,179,191,197,227,239,241,269,281,311,347,359,419,431,461,487)\n ;i=clamp(i,0,39);//worksafing, clamp faster than mod\n ;return p[i];}\n  \n//int gpo(int a){int b[arrLen]=int[arrLen](2,3,5,7,11,13,17,79,101,239,241,269,281,487);return b[a];}\n\n/*\n//costas arrays of tile sizes\nint getCostasOf(int a,int p){//return costas at Position of Array#\n //return texture((vec2(p,a)+.1)/iResolution.xy.xy)\n    ;}\n    /*\n bool r=false;\n if(a<4){\n  if(a<2){\n   if(a==0){\n          int c[]=int[241](1,38,3,156,46,114,231,141,9,155,15,226,55,39,138,205,60,100,161,203,209,186,160,181,66,8,27,71,233,223,170,169,45,25,184,194,78,173,165,196,120,117,102,57,172,69,159,131,76,108,180,236,145,58,163,157,241,73,179,125,127,214,143,225,175,74,28,140,238,166,201,59,204,232,198,124,49,24,6,17,81,52,77,213,99,149,215,62,22,185,218,89,26,146,34,23,106,240,135,105,123,75,90,136,68,122,2,98,33,182,234,210,116,35,30,202,11,70,10,104,121,37,118,111,227,109,112,50,64,91,48,171,197,195,32,85,206,207,94,12,235,150,113,151,192,42,228,31,86,82,144,44,56,29,115,224,107,154,193,101,63,174,96,47,5,13,20,229,134,164,239,137,142,219,40,19,53,36,129,133,221,152,139,208,67,158,97,167,187,211,88,191,92,80,41,126,162,222,200,148,84,93,237,178,16,65,230,4,199,14,190,176,119,132,21,177,168,216,128,87,43,212,103,217,110,188,54,130,79,183,147,220,7,72,95,153,18,61,83,51,189\t);if(r)return c[(241-p)%241];return c[p%241];\t//\t76\t\tgood very\n       ;}else{\n      int c[]=int[239](4,151,89,144,236,156,6,229,193,21,65,56,227,101,226,28,201,105,207,154,125,17,185,167,7,100,11,96,106,163,121,122,135,130,64,18,221,90,198,40,73,199,37,212,83,149,141,19,98,146,202,132,107,23,60,172,42,208,225,215,219,119,131,171,168,214,45,150,170,230,138,145,234,61,134,33,210,186,159,213,237,161,27,43,51,114,142,81,239,22,41,224,129,118,194,116,197,157,5,26,232,231,216,110,162,189,36,3,53,203,191,47,72,86,180,209,160,55,178,10,147,233,67,85,25,140,95,39,152,133,192,111,113,235,177,94,169,153,123,126,74,195,204,92,139,32,12,76,102,52,238,49,79,20,166,127,80,183,228,173,88,84,77,109,179,75,217,97,59,120,29,218,82,220,143,115,44,1,70,35,14,206,9,108,205,137,190,184,223,136,57,187,38,15,158,16,50,181,24,200,87,188,48,54,69,104,78,34,2,13,165,124,8,66,182,71,58,99,176,174,196,63,128,164,91,175,30,68,46,211,112,117,103,222,31,148,62,93,155\t);if(r)return c[(239-p)%239];return c[p%239];\t//\t47\t\tgood very\n  ;}}else{\n   if(a==2){\n           int c[]=int[281](108,277,20,24,177,157,241,58,204,270,106,59,30,265,127,84,208,140,86,143,130,128,193,203,161,111,38,5,87,252,125,149,218,98,36,70,97,210,75,76,185,180,201,226,121,279,238,14,219,207,31,91,122,105,233,35,244,102,189,50,181,27,221,142,21,133,172,178,266,236,79,229,165,264,18,89,187,115,191,268,171,69,271,215,54,51,7,22,242,167,199,8,131,237,188,224,186,6,196,247,146,174,113,256,278,129,19,198,182,136,216,163,46,28,47,137,42,158,67,53,225,12,1,217,272,41,49,72,32,200,117,126,258,213,119,61,248,255,169,134,281,173,4,261,257,104,124,40,223,77,11,175,222,251,16,154,197,73,141,195,138,151,153,88,78,120,170,243,276,194,29,156,132,63,183,245,211,184,71,206,205,96,101,80,55,160,2,43,267,62,74,250,190,159,176,48,246,37,179,92,231,100,254,60,139,260,148,109,103,15,45,202,52,116,17,263,192,94,166,90,13,110,212,10,66,227,230,274,259,39,114,82,273,150,44,93,57,95,275,85,34,135,107,168,25,3,152,262,83,99,145,65,118,235,253,234,144,239,123,214,228,56,269,280,64,9,240,232,209,249,81,164,155,23,68,162,220,33,26,112,147\t);if(r)return c[(281-p)%281];return c[p%281];\t//\t1121\te\tgood, very good\n           ;}else{\n          int c[]=int[269](77,170,158,48,161,199,10,258,227,75,209,203,165,187,151,11,207,94,79,110,175,255,248,3,98,17,109,67,12,253,40,27,212,154,193,141,223,167,168,159,69,18,192,174,225,127,190,237,123,264,13,80,202,90,222,172,246,83,82,143,213,72,140,112,107,121,208,39,247,37,198,33,183,21,244,53,96,131,144,14,134,15,1,118,245,243,197,130,201,108,8,200,76,19,25,230,250,259,180,229,97,218,221,265,220,228,89,62,241,171,66,78,215,236,269,135,191,188,84,267,142,211,256,59,145,74,57,38,232,239,92,20,224,266,182,93,148,41,210,184,4,177,23,137,35,46,70,122,150,102,16,217,47,88,49,113,189,149,234,166,63,251,105,71,160,32,85,179,155,114,162,68,156,233,125,216,100,51,226,153,73,99,263,136,235,205,185,26,242,219,176,260,52,106,124,268,257,204,196,132,169,58,54,64,147,249,104,133,101,128,164,262,252,5,152,117,56,31,61,139,95,36,86,120,45,91,206,129,7,194,30,126,9,24,173,231,116,28,138,178,34,186,55,60,238,240,42,146,163,195,261,103,43,214,181,44,119,254,87,50,29,157,6,22,81,65,2,111,115\t);if(r)return c[(269-p)%269];return c[p%269];\t//\t678\t\tgood very\n ;}}}else{\n   if(a==4){int c[]=int[19](1,12,16,18,19,10,15,8,14,17,9,5,3,2,11,6,13,7,4);if(r)return c[(19-p)%19];return c[p%197];}//is too symmetrical\n   if(a==5){\n       int c[]=int[17](2,11,8,6,16,17,12,3,14,10,13,15,5,4,9,1,7);if(r)return c[(17-p)%17];return c[p%17];\t//\t11\t\tgood\n    }else {int c[]=int[13](0,6,8,4,5,9,12,2,7,1,11,10,3);if(r)return c[(13-p)%13];return c[p%13];\t//\t144\n//more best ofs:\n\n/**/\n    \n/*\tint c[]=int[17](2,11,8,6,16,17,12,3,14,10,13,15,5,4,9,1,7);if(r)return c[(17-p)%17];return c[p%17];\t//\t11\t\tgood\n/*\tint c[]=int[11](0,4,10,7,8,2,1,9,5,3,6);if(r)return c[(11-p)%11];return c[p%11];\t//\t57\t\tgood very\n/*\tint c[]=int[13](0,6,8,4,5,9,12,2,7,1,11,10,3);if(r)return c[(13-p)%13];return c[p%13];\t//\t144\n/*\tint c[]=int[ 7](1,4,5,3,0,6,2);if(r)return c[(7-p)%7];return c[p%7];\t//\t22\t\tgood very\n/*\tint c[]=int[ 5](1,2,4,0,3);if(r)return c[(5-p)%5];return c[p%5];\t//\t4\t\tgood\n\n\n/*\nfloat mixArrayFloat[](int a[7],int b[7],float c,int l){\n    for(i=0;i<l;i++)\n      a[i]=mix(a[i],b[i],c);\n    }return a;}\n*/\n           // ;}}}\n            \n            \n\n\n\n\n/*\n\n#define EL ;}else\n#define I0 if((y&1)>0)\n#define I1 if((y&2)>0)\n#define I2 if((y&4)>0)\n#define I3 if((y&8)>0)\n#define I4 if((y&16)>0)\n#define I5 if((y&32)>0)\n#define I20 I2{I1{I0\n#define I30 I3{I20\n#define I40 I4{I30\n\nfloat gca(int x,int y\n){    I5{I40{\n          EL{\n     ;}EL{I0{\n          EL{\n ;}}EL{I1{I0{\n          EL{\n     ;}EL{I0{\n          EL{\n  ;}}}EL{I20{\n          EL{\n     ;}EL{I0{\n          EL{\n ;}}EL{I1{I0{\n          EL{\n     ;}EL{I0{\n          EL{\n ;}}}}EL{I30{\n          EL{\n     ;}EL{I0{\n          EL{\n ;}}EL{I1{I0{\n          EL{\n     ;}EL{I0{\n          EL{\n  ;}}}EL{I20{\n          EL{\n     ;}EL{I0{\n          EL{\n ;}}EL{I1{I0{\n          EL{\n     ;}EL{I0{\n          EL{\n;}}}}}EL{I40{\n          EL{\n     ;}EL{I0{\n          EL{\n ;}}EL{I1{I0{\n          EL{\n     ;}EL{I0{\n          EL{\n  ;}}}EL{I20{\n          EL{\n     ;}EL{I0{\n          EL{\n ;}}EL{I1{I0{\n          EL{\n     ;}EL{I0{\n          EL{\n ;}}}}EL{I30{\n          EL{\n     ;}EL{I0{\n          EL{\n ;}}EL{I1{I0{\n          EL{\n     ;}EL{I0{\n          EL{\n  ;}}}EL{I20{\n          EL{\n     ;}EL{I0{\n          EL{\n ;}}EL{I1{I0{\n          EL{\n     ;}EL{I0{\n          EL{\n ;}}}}}}\n return 1.;}\n              \n              /**/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "/*\ntodo\n- maybe expand qhite square to 1024x1024 (and include up to 2x as many primes, each in over 2x as long lists)\n- fill the inner bkack area with costas arrays (quite big gaps still)\n- make use of the unused whiteSpace in the square (this will add non-prime lists)\n\n*/\n\n//return lenggth of Nth costas array (that has a prime length AND a good entry)\n/*\n//return Nth prime by index 0->2,1->3 2->5,... 95-> 499\nint prime94to499(int i\n){int p[]=int[95](2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97\n                ,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191\n                ,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283\n                ,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401\n                ,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499)\n ;i=clamp(i,0,94);//worksafing, clamp faster than mod\n ;return p[i];}*/\n\n//DSS means, it is a DumbSubSet of the above, just because we do not know ALL costasArrays of a given size (except for s sizes up to 32)\n//which leaves many primes having null, or only very few (and way too bad for this recursive-noise/dither/hash utility)\nint primeDss94to499(int i){return gpo(i);}\n\n#define EL ;}else\n#define I0 if((y&1)>0)\n#define I1 if((y&2)>0)\n#define I2 if((y&4)>0)\n#define I3 if((y&8)>0)\n#define I4 if((y&16)>0)\n#define I5 if((y&32)>0)\n#define I20 I2{I1{I0\n#define I30 I3{I20\n#define I40 I4{I30\nint gca(int x,int y,bool r\n){int p=x\n ;    I5{I40{\t\treturn 1\n          EL{\t\treturn 1\n     ;}EL{I0{\t\treturn 1\n          EL{\t\treturn 1\n ;}}EL{I1{I0{\t\treturn 1\n          EL{\t\treturn 1\n     ;}EL{I0{\t\treturn 1\n          EL{\t\treturn 1\n  ;}}}EL{I20{\t\treturn 1\n          EL{\t\treturn 1\n     ;}EL{I0{\t\treturn 1\n          EL{\t\treturn 1\n ;}}EL{I1{I0{\t\treturn 1\n          EL{\t\treturn 1\n     ;}EL{I0{\t\treturn 1\n          EL{\treturn 1\t\n ;}}}}EL{I30{\treturn 1\t\n          EL{return 1\t\t\n     ;}EL{I0{return 1\t\t\n          EL{return 1\t\t\n ;}}EL{I1{I0{return 1\t\t\n          EL{return 1\t\n     ;}EL{I0{return 1\t\n          EL{return 1\t\n  ;}}}EL{I20{int c[]=int[487](\t229,422,169,459,328,204,107,57,121,133,426,144,190,39,257,428,191,348,136,223,362,418,456,374,87,161,278,453,199,300,396,451,308,198,314,339,434,390,14,263,193,137,98,113,282,341,391,440,431,63,154,336,370,394,351,450,8,321,101,318,185,196,50,313,67,296,65,337,295,433,155,183,287,195,99,481,317,157,288,139,114,202,468,106,128,212,25,179,232,368,293,393,432,465,389,381,439,43,75,254,59,134,462,222,448,84,7,325,290,115,342,383,44,81,110,416,274,455,301,353,9,291,284,392,264,350,224,85,166,160,365,303,10,102,437,19,42,403,80,332,214,180,379,12,438,262,430,349,464,449,217,307,187,51,71,237,78,410,331,130,26,249,171,329,470,129,176,475,3,272,163,454,484,373,226,167,269,458,88,142,399,189,72,347,61,463,153,388,182,13,17,260,41,429,74,62,207,34,29,358,385,82,215,6,306,320,197,482,299,372,352,86,326,141,203,220,151,447,387,216,380,104,20,127,240,175,243,246,1,423,271,89,279,310,315,297,156,371,266,225,419,486,227,487,421,228,270,376,162,304,323,319,289,100,283,436,15,261,259,192,258,146,40,125,402,239,411,472,177,247,231,170,356,117,384,405,333,27,233,357,344,45,255,123,427,401,73,79,253,109,122,478,91,311,69,66,236,443,209,30,119,406,132,250,461,205,152,33,335,234,294,442,64,35,235,345,77,60,252,206,58,408,251,330,108,213,415,5,164,324,159,140,277,398,309,52,68,444,36,359,46,111,479,281,316,435,184,18,148,126,55,211,120,414,477,273,280,200,340,467,382,21,404,412,131,476,425,90,400,53,238,210,174,24,474,248,424,460,143,221,96,361,112,275,201,397,219,188,95,38,47,124,92,54,445,31,386,334,181,369,286,265,138,363,276,302,452,322,483,158,267,364,457,354,327,116,469,22,241,473,245,2,230,377,367,11,285,16,194,147,49,93,70,37,346,256,135,145,97,48,480,312,298,338,395,466,218,105,150,56,32,407,28,172,118,23,413,178,4,378,305,103,186,149,94,446,360,83,417,165,485,268,420,375,168,366,355,292,343,441,76,208,409,173,471,242,244\t);if(r)return c[(487-p)%487];return c[p%487];\t//\t0\t\tthe only one\n          EL{return 461\t//\t461\n     ;}EL{I0{return 431\t//\t431\n          EL{return 419\t//\t419\n ;}}EL{I1{I0{return 359\t//\t359\n          EL{return 347\t//\t347\n     ;}EL{I0{return 311\t//\t311\n          EL{int c[]=int[281](108,277,20,24,177,157,241,58,204,270,106,59,30,265,127,84,208,140,86,143,130,128,193,203,161,111,38,5,87,252,125,149,218,98,36,70,97,210,75,76,185,180,201,226,121,279,238,14,219,207,31,91,122,105,233,35,244,102,189,50,181,27,221,142,21,133,172,178,266,236,79,229,165,264,18,89,187,115,191,268,171,69,271,215,54,51,7,22,242,167,199,8,131,237,188,224,186,6,196,247,146,174,113,256,278,129,19,198,182,136,216,163,46,28,47,137,42,158,67,53,225,12,1,217,272,41,49,72,32,200,117,126,258,213,119,61,248,255,169,134,281,173,4,261,257,104,124,40,223,77,11,175,222,251,16,154,197,73,141,195,138,151,153,88,78,120,170,243,276,194,29,156,132,63,183,245,211,184,71,206,205,96,101,80,55,160,2,43,267,62,74,250,190,159,176,48,246,37,179,92,231,100,254,60,139,260,148,109,103,15,45,202,52,116,17,263,192,94,166,90,13,110,212,10,66,227,230,274,259,39,114,82,273,150,44,93,57,95,275,85,34,135,107,168,25,3,152,262,83,99,145,65,118,235,253,234,144,239,123,214,228,56,269,280,64,9,240,232,209,249,81,164,155,23,68,162,220,33,26,112,147\t);if(r)return c[(281-p)%281];return c[p%281];\t//\t1121\te\tgood, very good\n;}}}}}EL{I40{int c[]=int[269](77,170,158,48,161,199,10,258,227,75,209,203,165,187,151,11,207,94,79,110,175,255,248,3,98,17,109,67,12,253,40,27,212,154,193,141,223,167,168,159,69,18,192,174,225,127,190,237,123,264,13,80,202,90,222,172,246,83,82,143,213,72,140,112,107,121,208,39,247,37,198,33,183,21,244,53,96,131,144,14,134,15,1,118,245,243,197,130,201,108,8,200,76,19,25,230,250,259,180,229,97,218,221,265,220,228,89,62,241,171,66,78,215,236,269,135,191,188,84,267,142,211,256,59,145,74,57,38,232,239,92,20,224,266,182,93,148,41,210,184,4,177,23,137,35,46,70,122,150,102,16,217,47,88,49,113,189,149,234,166,63,251,105,71,160,32,85,179,155,114,162,68,156,233,125,216,100,51,226,153,73,99,263,136,235,205,185,26,242,219,176,260,52,106,124,268,257,204,196,132,169,58,54,64,147,249,104,133,101,128,164,262,252,5,152,117,56,31,61,139,95,36,86,120,45,91,206,129,7,194,30,126,9,24,173,231,116,28,138,178,34,186,55,60,238,240,42,146,163,195,261,103,43,214,181,44,119,254,87,50,29,157,6,22,81,65,2,111,115\t);if(r)return c[(269-p)%269];return c[p%269];\t//\t678\t\tgood very\n          EL{int c[]=int[241](1,38,3,156,46,114,231,141,9,155,15,226,55,39,138,205,60,100,161,203,209,186,160,181,66,8,27,71,233,223,170,169,45,25,184,194,78,173,165,196,120,117,102,57,172,69,159,131,76,108,180,236,145,58,163,157,241,73,179,125,127,214,143,225,175,74,28,140,238,166,201,59,204,232,198,124,49,24,6,17,81,52,77,213,99,149,215,62,22,185,218,89,26,146,34,23,106,240,135,105,123,75,90,136,68,122,2,98,33,182,234,210,116,35,30,202,11,70,10,104,121,37,118,111,227,109,112,50,64,91,48,171,197,195,32,85,206,207,94,12,235,150,113,151,192,42,228,31,86,82,144,44,56,29,115,224,107,154,193,101,63,174,96,47,5,13,20,229,134,164,239,137,142,219,40,19,53,36,129,133,221,152,139,208,67,158,97,167,187,211,88,191,92,80,41,126,162,222,200,148,84,93,237,178,16,65,230,4,199,14,190,176,119,132,21,177,168,216,128,87,43,212,103,217,110,188,54,130,79,183,147,220,7,72,95,153,18,61,83,51,189);if(r)return c[(241-p)%241];return c[p%241];\t//\t76\t\tgood very\n     ;}EL{I0{int c[]=int[239](4,151,89,144,236,156,6,229,193,21,65,56,227,101,226,28,201,105,207,154,125,17,185,167,7,100,11,96,106,163,121,122,135,130,64,18,221,90,198,40,73,199,37,212,83,149,141,19,98,146,202,132,107,23,60,172,42,208,225,215,219,119,131,171,168,214,45,150,170,230,138,145,234,61,134,33,210,186,159,213,237,161,27,43,51,114,142,81,239,22,41,224,129,118,194,116,197,157,5,26,232,231,216,110,162,189,36,3,53,203,191,47,72,86,180,209,160,55,178,10,147,233,67,85,25,140,95,39,152,133,192,111,113,235,177,94,169,153,123,126,74,195,204,92,139,32,12,76,102,52,238,49,79,20,166,127,80,183,228,173,88,84,77,109,179,75,217,97,59,120,29,218,82,220,143,115,44,1,70,35,14,206,9,108,205,137,190,184,223,136,57,187,38,15,158,16,50,181,24,200,87,188,48,54,69,104,78,34,2,13,165,124,8,66,182,71,58,99,176,174,196,63,128,164,91,175,30,68,46,211,112,117,103,222,31,148,62,93,155\t);if(r)return c[(239-p)%239];return c[p%239];\t//\t47\t\tgood very\n          EL{return 227\t//\t227\n ;}}EL{I1{I0{return 197\t//\t197\n          EL{return 191\t//\t191\n     ;}EL{I0{return 179\t//\t179\n          EL{return 167\t//\t167\n  ;}}}EL{I20{return 149\t//\t149\n          EL{return 137\t//\t137\n     ;}EL{I0{return 107\t//\t107\n          EL{int c[]=int[101](\t4,87,64,53,97,24,7,75,9,67,41,42,38,54,93,40,46,22,15,43,34,70,29,90,52,101,8,71,25,3,91,48,14,47,18,31,82,84,76,5,83,80,92,44,30,86,68,37,58,77,1,99,16,39,50,6,79,96,28,94,36,62,61,65,49,10,63,57,81,88,60,69,33,74,13,51,2,95,32,78,100,12,55,89,56,85,72,21,19,27,98,20,23,11,59,73,17,35,66,45,26\t);if(r)return c[(101-p)%101];return c[p%101];\t//\t41\t\tgood very\n ;}}EL{I1{I0{int c[]=int[79](\t5,8,15,47,41,24,36,18,45,10,76,61,32,13,43,71,63,72,44,70,28,25,33,54,22,78,55,69,12,30,64,77,68,35,34,23,48,65,16,40,3,39,9,51,49,37,57,53,27,60,29,73,46,56,67,6,52,31,21,50,11,26,4,79,38,75,1,17,19,20,42,2,7,62,66,59,14,74,58\t);if(r)return c[(79-p)%79];return c[p%79];\t//\t13\t\tgood best\n          EL{return 71\t//\t71\n     ;}EL{I0{return 67\t//\t67\n          EL{return 61\t//\t61\n ;}}}}EL{I30{return 59\t//\t59\n          EL{return 53\t//\t53\n     ;}EL{I0{return 47\t//\t47\n          EL{return 41\t//\t41\n ;}}EL{I1{I0{return 37\t//\t37\n          EL{return 31\t//\t31\n     ;}EL{I0{return 29\t//\t29\n          EL{return 23\t//\t23\n  ;}}}EL{I20{int c[]=int[19](1,12,16,18,19,10,15,8,14,17,9,5,3,2,11,6,13,7,4);return c[p%19];//is too symmetrical\n          EL{int c[]=int[17](2,11,8,6,16,17,12,3,14,10,13,15,5,4,9,1,7);if(r)return c[(17-p)%17];return c[p%17];\t//\t11\t\tgood\n     ;}EL{I0{int c[]=int[13](0,6,8,4,5,9,12,2,7,1,11,10,3);if(r)return c[(13-p)%13];return c[p%13];\t//\t144\n          EL{int c[]=int[11](0,4,10,7,8,2,1,9,5,3,6      );if(r)return c[(11-p)%11];return c[p%11];\t//\t57\t\tgood very\n ;}}EL{I1{I0{int c[]=int[ 7](1,4,5,3,0,6,2               );if(r)return c[( 7-p)% 7];return c[p% 7];\t//\t22\t\tgood very\n          EL{int c[]=int[ 5](1,2,4,0,3                   );if(r)return c[( 5-p)% 5];return c[p% 5];\t//\t4\t\tgood\n     ;}EL{I0{int c[]=int[ 3](0,2,1                       );if(r)return c[( 3-p)% 3];return c[p% 3];\t//0 no choice\n          EL{int c[]=int[ 2](1,0                         );if(r)return c[( 2-p)% 2];return c[p% 2];\t//0 no choice           \n ;}}}}}}\n return 0;}\n              \n\n//return value of costas array (of prime length) at position.x primeIndex.y\nvec3 bufferCostas(vec2 a\n){if(max(a.x,a.y)>511.)return vec3(0.);\n ;ivec2 u=ivec2(a)\n ;//int p=prime94to499(u.y);\n ;int p=primeDss94to499(u.y);\n ;if(u.y>39||u.x>=p)return vec3(1);\n ;ivec3 b=ivec3(gca(u.x,u.y,true),0,0);\n ;b.z=(b.x&255     )    //8 lowest bits\n ;b.y=(b.x&65280   )/256//8 next bits\n ;b.x=(b.x&16711680)/256/256//8 highest bits\n ;return vec3(b.zyx)/255.\n ;}\n\nvoid mainImage(out vec4 O,vec2 u\n){\n ;vec3 c=bufferCostas(u);\n ;O=vec4(c,1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//costas arrays of tile sizes\nint getCostasOf(int a,int p){//return costas at Position of Array#\n ;vec3 f=texture(iChannel3,(vec2(p,a))/iResolution.xy).zyx;\n //;if(f>0.9)return 9999\n //;return int(f*float(gpo(a)))\n    \n ;ivec3 b=ivec3(f*255.);\n ;b.x+=b.y*256+b.z*256*256\n ;return b.x\n //;b.z=(b.x&255     )    //8 lowest bits\n //;b.y=(b.x&65280   )>> 8//8 next bits\n //;b.x=(b.x&16711680)>>16//8 highest bits\n //;return vec3(b)/255.\n    \n ;}\n\nint Cs(ivec2 u,int a,int iFrame){\n ;int r=0\n ;int per=gpo(a)\n ;u=u%per //tile to positive infinity\n ;//if(max(u.x,u.y)>per-1)return 0; //only show one tile\n ;int c=getCostasOf(a,per-u.y)\n //;if(c==9999)return 0;//catches empty entries\n ;//if(c+1==u.x)return per;return 0;//monochrome (makes nice starfields)\n ;r=c-u.x\n ;if(r<0)r+=per\n ;r=getCostasOf(a,per-r)  //we reverse the second pass, (habbitually, there may be a better approach)\n ;//r+=getCostasOf(a,per)//optional for a better match with simpler mode \n ;//r=r%per;\n ;r=(r+iFrame/4)%(per);\n ;return r;}\n\nvec4 CostasNoise(ivec2 u,int iFrame,vec4 m){\n ;u/=2\n\n ;float r=0.;\n    \n //last 3 entries are better set to 0, they are very small and too symmetrical costas arrays (cause diagonal bands)\n //;float f[]=float[7](1.,0.,0.,0.,0.,0.,0.)//singleton    \n ;float f[]=float[40](\n  1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,\n  1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,\n  1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,\n  1.,1.,1.,1.,1.,1.,1.,1.,1.,1.)\n     \n //;float f[]=float[arrLen](1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.)\n     \n    // float[7](1.,1.,1.,1.,1.,1.,1.)//flat (strong banding)\n //;float f[]=float[7](4.,3.,2.,1.,0.,0.,0.)//valley\n;float blue[]=f//float[7](1.,2.,4.,8.,16.,32.,0.)//blue (most banding?)\n //;float f[]=float[7](1.,2.,2.,1.,0.,0.,0.)//windowed \n ;float yellow[]=f//float[7](64.,32.,16.,8.,4.,2.,0.)//anti-blue /least banding)\n     //dissappointingly, even small prime tiles as small as 19*19 salready have too stron giagonal banding\n     //so i guess, i just need larger tiles and larger primes.\n     //i take a bet that it is a bad idea to repeat prime-gaps (espoecially short ones), which may result in the banding\n\n ;m=clamp(m,0.,1.)\n \n ;for(int i=0;i<40;i++){\n      blue[i]=mix(blue[i],yellow[i],m.x);\n }    \n;for(int i=0;i<40;i++){\n      f[i]=mix(blue[i],f[i],m.y);//mix to flat\n }\n    \n    ;float s=0.;\n    ;int ass=8\n  // for(int i=0;i<2;i++ \n   ;for(int i=0;i<40+1;i++\n\n       ){  \n       \n       if(\n           i==7\n           //i==20\n          // i==21\n       //    i<8\n       ){\n       s+=f[i]\n        ;r+=float(Cs(u,i,iFrame))/float(gpo(i))*f[i];\n           ;}}\n    \n //;r+=float(Cs(u,3,iFrame))/float(gpo(3))*f[0];\n //;r+=float(Cs(u,2,iFrame))/float(gpo(2))*f[2];\n// ;u=u.yx//addition, to make half of the arrays diagonally flipped\n //;r+=float(Cs(u,1,iFrame))/float(gpo(1))*f[1];\n //;r+=float(Cs(u,3,iFrame))/float(gpo(3))*f[3];\n //large above, small below\n //;r+=float(Cs(u,4,iFrame))/float(gpo(4))*f[4];    \n //;u=u.yx//addition, to make half of the arrays diagonally flipped\n //;r+=float(Cs(u,5,iFrame))/float(gpo(5))*f[5];\n //;r+=float(Cs(u,6,iFrame))/float(gpo(6))*f[6]; \n     \n    \n ;float a=r/s//(f[0]+f[1]+f[2]+f[3]+f[4]+f[5]+f[6])//divide by sum of weights\n ;return vec4(a,a,a,1);\n}\n\nfloat wrap(vec2 u,int iFrame,float iTime,vec4 m){//O=getCostasOfFloat(u);\n ;if(m.z<=0.){m.y=0.;m.x=cos(iTime*.3)*.5+.5;}\n ;//u*=2.2\n ;u/=2.5\n ;float g=(sqrt(5.)*.5+.5)\n ;float speed=.00003*iTime\n ;vec2 s= (vec2(cos(speed),sin(speed*g))*.5+.5)*10000000. \n     //i am pleased that this noise still has a strong pattern to make scrolling easily noticable.\n     //thile its color palette cycles.\n ;ivec2 scroll=ivec2(0);\n ;//ivec2 scroll=ivec2(s);\n ;//u.x+=u.y*(sqrt(5.)*.5+.5) //optionally skew diagonal banding by goldenRatio (sucks)\n ;//u.x+=u.y*u.y*g\n ;return CostasNoise(ivec2(u)+scroll,iFrame,m).x;}\n\n\n\n\n\n//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n\n//modified (simplified) nuttall filter for orbit noise\n//see: https://www.shadertoy.com/view/XtVcWc\nfloat nuttall(float x, float w)\n{\n    const float pi = 3.14159265358979;\n    if (abs(x) > w)\n        return 0.;\n    //Standard Nuttall\n    //return 0.355768 - 0.487396*cos(pi*x/w + pi) + 0.144232*cos(2.*pi*x/w) - 0.012604*cos(3.*pi*x/w + pi*3.);\n    return 0.365 - (0.5)*cos(pi*x/w + pi) + (0.135)*cos(2.*pi*x/w);\n}\n\nfloat orbitNoise(vec2 p)\n{\n    //return wrap(p,iFrame,iTime);\n    //return fract(p.x-p.y);\n    \n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n    float rz = 0.;\n    float orbitRadius = .75;\n\n    //16 taps\n    for (int j = -1; j <= 2; j++)\n    for (int i = -1; i <= 2; i++)\n    {\n        vec2 dp = vec2(j,i);\n        vec4 rn = hash42(dp + ip) - 0.5;\n        vec2 op = fp - dp + rn.zw*orbitRadius;\n        rz += nuttall(length(op),1.85)*dot(rn.xy*1.7, op);\n    }\n    return rz*0.5+0.5;\n    //return smoothstep(-1.0, 1.0,rz);\n    /**/\n}\n\nvec4 powX(float x) {float x2 = x*x; return vec4(x2*x, x2, x, 1.0); }\nvec4 MNParamsA(float B, float C){ return vec4(12. - 9.*B - 6.*C, -18. + 12.*B + 6.*C, 0.0, 6. -2.*B)/6.; }\nvec4 MNParamsB(float B, float C){ return vec4(-B -6.*C, 6.*B + 30.*C, -12.*B - 48.*C, 8.*B + 24.*C)/6.; }\n\nfloat eval(float c0, float c1, float c2, float c3, float x) \n{    \n    const float B = .8;\n    const float C = 0.25;\n    vec4 pA = MNParamsA(B, C);\n    vec4 pB = MNParamsB(B, C);\n    \n    return c0*dot(pB, powX(x + 1.0)) + c1*dot(pA, powX(x)) +\n           c2*dot(pA, powX(1.0 - x)) + c3*dot(pB, powX(2.0 - x));\n}\n\nfloat bicubicNoise(in vec2 p)\n{\n    vec2 fp = fract(p);\n    vec2 ip = floor(p);\n    \n    float s99 = hash12(ip+vec2(-1,-1)), s19 = hash12(ip+vec2(1,-1));\n    float s00 = hash12(ip+vec2(0,0)),   s20 = hash12(ip+vec2(2,0));\n    float s91 = hash12(ip+vec2(-1, 1)), s11 = hash12(ip+vec2(1, 1));\n    float s02 = hash12(ip+vec2(0,2)),   s22 = hash12(ip+vec2(2,2));\n    float s09 = hash12(ip+vec2(0,-1)),  s29 = hash12(ip+vec2(2,-1));\n    float s90 = hash12(ip+vec2(-1,0)),  s10 = hash12(ip+vec2(1,0));\n    float s01 = hash12(ip+vec2(0,1)),   s21 = hash12(ip+vec2(2,1));\n    float s92 = hash12(ip+vec2(-1,2)),  s12 = hash12(ip+vec2(1,2));\n    \n    float rz =  eval(eval(s99, s09, s19, s29, fp.x), eval(s90, s00, s10, s20, fp.x),\n                eval(s91, s01, s11, s21, fp.x), eval(s92, s02, s12, s22, fp.x), fp.y);\n    \n    //return rz;\n    return smoothstep(0.0,1.,rz);\n}\n\nfloat valueNoise(vec2 p)\n{\n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n\tvec2 ramp = fp*fp*(3.0-2.0*fp);\n\n    float rz= mix( mix( hash12(ip + vec2(0.0,0.0)), hash12(ip + vec2(1.0,0.0)), ramp.x),\n                   mix( hash12(ip + vec2(0.0,1.0)), hash12(ip + vec2(1.0,1.0)), ramp.x), ramp.y);\n    \n    return rz;\n}\n\nvec2 hashz( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\t//return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n    return normalize(-1.0 + 2.0*fract(sin(p)*43758.5453123) + 1e-7);\n}\n\n//from iq: https://www.shadertoy.com/view/Msf3WH\nfloat simplex( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hashz(i+0.0)), dot(b,hashz(i+o)), dot(c,hashz(i+1.0)));\n\n    return dot( n, vec3(80.0) )*0.5+0.5;\n\t\n}\n\nvec2 hashg(vec2 x) { return hash22(x)*2.0-1.0;}\n\n//From iq: https://www.shadertoy.com/view/XdXGW8\nfloat gradientNoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    float rz =  mix( mix( dot( hashg( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hashg( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hashg( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hashg( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n    \n    //return rz*0.75+0.5;\n    return smoothstep(-.9,.9,rz);\n}\n\nfloat fbm(vec2 p)\n{\n    float rz = 0.;\n    float amp = 1.95;\n    for (int i = 0; i < 7; i++)\n    {\n        rz += orbitNoise(p*1.)/amp;\n        //rz += bicubicNoise(p*1.3)/amp;\n        //rz += gradientNoise(p*.6)/amp;\n        //rz += valueNoise(p)/amp;\n        //rz += simplex(p*.35)/amp;\n        amp *= 2.;\n        p *= 2.06;\n    }\n    //return rz;\n    return smoothstep(0.,1.,rz); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef SHOW_FOURIER\n    if(fragCoord.x > SIZE)\n    {\n        fragColor = vec4(0);\n        return;\n    }\n#endif\n    vec2 p = fragCoord/iResolution.xy;\n    vec2 q = p;\n\tp.x *= iResolution.x/iResolution.y;\n    \n#ifdef SCROLL_COORDS\n    p += vec2(1,1.5)*iTime*0.03;\n#endif\n    \n    if (fragCoord.y > SIZE)        p*=0.75;\n    \n    vec3 col = vec3(0);\n    \n   // p *= globalScale;\n    \n    col= vec3(wrap(p*iResolution.y*2.5,iFrame,iTime,iMouse/iResolution.xyxy));\n    /*\n    \n#if (NOISE_TYPE == 1)\n    col = orbitNoise(p*40.)*vec3(1);\n#elif (NOISE_TYPE == 2)\n    col = bicubicNoise(p*55.)*vec3(1);\n#elif (NOISE_TYPE == 3)\n    col = valueNoise(p*40.)*vec3(1);\n#elif (NOISE_TYPE == 4)\n    col = gradientNoise(p*25.)*vec3(1);\n#elif (NOISE_TYPE == 5)\n    col = simplex(p*14.)*vec3(1);\n#elif (NOISE_TYPE == 6)\n    col = fbm(p*20.)*vec3(1);\n#endif\n    */\n    //if (col.x >= 1. || col.x <= 0.) col = vec3(1,0,0); //Range check\n    col = clamp(col, 0.,1.);\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n//Horizontal + Vertical Discrete Fourier Transform of the input \n//adapted from FabriceNeyret2's https://www.shadertoy.com/view/XtScWt\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b)); } \n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord )\n{\n   \tfragColor = vec4(0);\n    \n#ifdef SHOW_FOURIER\n    if(fragCoord.x > SIZE || fragCoord.y > SIZE) return;\n    \n    for(float i = 0.; i < SIZE; i++)  \n\t{\n\t\tvec2 xn = texelFetch(iChannel0, ivec2(i, fragCoord.y), 0).rr;\n        vec2 yn = texelFetch(iChannel1, ivec2(fragCoord.x, i), 0).ba;\n\t\tvec2 ang = - 6.2831853 * (fragCoord-.5 -SIZE/2.) * i/SIZE;\n\t\tfragColor.zw += cmul(xn, ang.x);\n\t\tfragColor.xy += cmul(yn, ang.y);\n    }\n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}