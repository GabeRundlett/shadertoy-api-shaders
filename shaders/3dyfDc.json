{
    "Shader": {
        "info": {
            "date": "1608065953",
            "description": "I use this for my wallpaper.\nWhat you can do:\nuse the camera buffer in BufferA iChannel1,\nset xflip to true,\nface the camera while looking at the screen.",
            "flags": 32,
            "hasliked": 0,
            "id": "3dyfDc",
            "likes": 4,
            "name": "Game of Life Canvas",
            "published": 3,
            "tags": [
                "procedural",
                "conway",
                "wallpaper",
                "gol"
            ],
            "usePreview": 0,
            "username": "TheNosiriN",
            "viewed": 447
        },
        "renderpass": [
            {
                "code": "#define RES iResolution.xy\n#define COORDS gl_FragCoord.xy\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = COORDS/RES;\n    \n    \n    fragColor = texture(iChannel0, uv);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Made by TheNosiriN\n/* http://vexorian.com/2015/05/cloudy-conway.html */\n\n\n#define RES iResolution.xy\n#define COORDS gl_FragCoord.xy\n#define UV (gl_FragCoord.xy/iResolution.xy)\n\nconst bool xflip = false;\n\n\nvec4 get4(vec2 p){\n    return texture(iChannel0, (COORDS+p) / iResolution.xy);\n}\n\n\nfloat get(int x, int y){\n    return get4(vec2(x, y)).a;\n}\n\n\nvec3 getColor(){\n    vec2 c = xflip ? vec2(RES.x-COORDS.x, COORDS.y) : COORDS;\n    return kuwaharaFiltering(iChannel1, c, RES, 5).rgb;//texture(iChannel1, UV).rgb;\n}\n\n\n\nvec4 evaluate(float sum)\n{\n    vec4 cell = get4(nosiri2);\n    float wasAlive = cell.w;\n    float has3 = step(abs(sum - 3.0), 0.1);\n    float has2 = step(abs(sum - 2.0), 0.1);\n    float isAlive = min(1.0, has3 + has2 * wasAlive);\n    float justDied = (1.0-isAlive) * wasAlive;\n    float afterGlow = cell.z;\n    \n    float r = max(afterGlow * nosiri, justDied);\n    \n    \n    vec3 screen = pow(getColor(), vec3(2.0));\n    \n    /*vec3 cellColor = vec3(0.3, 1.0, 1.0);\n    vec3 glowColor = vec3(1.0, 0.3, 1.0);\n    vec3 traceColor = vec3(1.0, 1.0, 0.0);\n    \n    return vec4(\n        r * pow(\n            cellColor,\n            vec3((1.0-r) * (1.0-isAlive)) * mix(glowColor, 1.0-traceColor, r*2.0) * 100.0\n        ), isAlive\n    );*/\n    return vec4(\n        r * pow(\n            mix(vec3(0.3, 0.7, 1.0), screen, pow(r, 20.0)), vec3(0.2)\n        ), isAlive\n    );\n}\n\n\n\n#define R (iResolution.xy)\n#define T(U) texelFetch( iChannel0, ivec2(U), 0 )\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord == vec2(0.5,0.5)){ fragColor.a=R.x; return; }\n    vec4 pc = T(vec2(0,0));\n    if (R.x!=pc.a){ fragColor = vec4(0); return; }\n    \n    float sum = \n    get(-1, -1) + get(-1, 0) +\n    get(-1,  1) + get(0, -1) +\n    get( 0,  1) + get(1, -1) +\n    get( 1,  0) + get(1, 1);\n    \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = COORDS/RES;\n    \n    \n    float inputSize = 10.0;//min(RES.x, RES.y) * 0.05;\n    if (distance(iMouse.xy, COORDS) < inputSize) {\n        sum = 3.0;\n    }\n    \n    float noise = perlin_noise(vec3(COORDS * 0.1, iTime*0.1)) * 0.5 + 0.5;\n    float lim = 0.65;\n    \n    if (noise > lim && noise < lim+0.01){\n        sum = 3.0;\n    }\n    \n\n    fragColor = evaluate(sum);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "video",
                        "id": 11,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "vec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031,.11369,.13787));\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n\nfloat perlin_noise(vec3 p)\n{\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return \tmix(\n        \t\tmix(\n                \tmix(dot(pf - vec3(0, 0, 0), hash33(pi + vec3(0, 0, 0))), \n                        dot(pf - vec3(1, 0, 0), hash33(pi + vec3(1, 0, 0))),\n                       \tw.x),\n                \tmix(dot(pf - vec3(0, 0, 1), hash33(pi + vec3(0, 0, 1))), \n                        dot(pf - vec3(1, 0, 1), hash33(pi + vec3(1, 0, 1))),\n                       \tw.x),\n                \tw.z),\n        \t\tmix(\n                    mix(dot(pf - vec3(0, 1, 0), hash33(pi + vec3(0, 1, 0))), \n                        dot(pf - vec3(1, 1, 0), hash33(pi + vec3(1, 1, 0))),\n                       \tw.x),\n                   \tmix(dot(pf - vec3(0, 1, 1), hash33(pi + vec3(0, 1, 1))), \n                        dot(pf - vec3(1, 1, 1), hash33(pi + vec3(1, 1, 1))),\n                       \tw.x),\n                \tw.z),\n    \t\t\tw.y);\n}\n\n\n// https://www.shadertoy.com/view/4tXyWN\nuint hash( uvec2 x )\n{\n    uvec2 q = 1103515245U * ( (x>>1U) ^ (x.yx   ) );\n    uint  n = 1103515245U * ( (q.x  ) ^ (q.y>>3U) );\n    return n;\n}\n\nconst float nosiri = 0.99;\n\n\n\n// https://www.shadertoy.com/view/MsXSz4\nvec4 kuwaharaFiltering(sampler2D channel, vec2 coords, vec2 resolution, int radius)\n{\n     vec2 src_size = vec2 (1.0 / resolution.x, 1.0 / resolution.y);\n     vec2 uv = coords.xy/resolution.xy;\n     float n = float((radius + 1) * (radius + 1));\n     int i; \n\t int j;\n     vec3 m0 = vec3(0.0); vec3 m1 = vec3(0.0); vec3 m2 = vec3(0.0); vec3 m3 = vec3(0.0);\n     vec3 s0 = vec3(0.0); vec3 s1 = vec3(0.0); vec3 s2 = vec3(0.0); vec3 s3 = vec3(0.0);\n     vec3 c;\n\n     for (int j = -radius; j <= 0; ++j)  {\n         for (int i = -radius; i <= 0; ++i)  {\n             c = texture(channel, uv + vec2(i,j) * src_size).rgb;\n             m0 += c;\n             s0 += c * c;\n         }\n     }\n\n     for (int j = -radius; j <= 0; ++j)  {\n         for (int i = 0; i <= radius; ++i)  {\n             c = texture(channel, uv + vec2(i,j) * src_size).rgb;\n             m1 += c;\n             s1 += c * c;\n         }\n     }\n\n     for (int j = 0; j <= radius; ++j)  {\n         for (int i = 0; i <= radius; ++i)  {\n             c = texture(channel, uv + vec2(i,j) * src_size).rgb;\n             m2 += c;\n             s2 += c * c;\n         }\n     }\n\n     for (int j = 0; j <= radius; ++j)  {\n         for (int i = -radius; i <= 0; ++i)  {\n             c = texture(channel, uv + vec2(i,j) * src_size).rgb;\n             m3 += c;\n             s3 += c * c;\n         }\n     }\n\n     \n     vec4 finalCol = vec4(0.0);\n     \n     float min_sigma2 = 1e+2;\n     m0 /= n;\n     s0 = abs(s0 / n - m0 * m0);\n\n     float sigma2 = s0.r + s0.g + s0.b;\n     if (sigma2 < min_sigma2) {\n         min_sigma2 = sigma2;\n         finalCol = vec4(m0, 1.0);\n     }\n\n     m1 /= n;\n     s1 = abs(s1 / n - m1 * m1);\n\n     sigma2 = s1.r + s1.g + s1.b;\n     if (sigma2 < min_sigma2) {\n         min_sigma2 = sigma2;\n         finalCol = vec4(m1, 1.0);\n     }\n\n     m2 /= n;\n     s2 = abs(s2 / n - m2 * m2);\n\n     sigma2 = s2.r + s2.g + s2.b;\n     if (sigma2 < min_sigma2) {\n         min_sigma2 = sigma2;\n         finalCol = vec4(m2, 1.0);\n     }\n\n     m3 /= n;\n     s3 = abs(s3 / n - m3 * m3);\n\n     sigma2 = s3.r + s3.g + s3.b;\n     if (sigma2 < min_sigma2) {\n         min_sigma2 = sigma2;\n         finalCol = vec4(m3, 1.0);\n     }\n     \n     return finalCol;\n}\n\nconst vec2 nosiri2 = vec2(0.0);",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}