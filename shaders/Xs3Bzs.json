{
    "Shader": {
        "info": {
            "date": "1526300772",
            "description": "https://www.shadertoy.com/view/Xlc3D2",
            "flags": 0,
            "hasliked": 0,
            "id": "Xs3Bzs",
            "likes": 30,
            "name": " Lens Flare alpha resolume",
            "published": 3,
            "tags": [
                "update"
            ],
            "usePreview": 0,
            "username": "captainflo22",
            "viewed": 2086
        },
        "renderpass": [
            {
                "code": "float rnd(vec2 p)\n{\n    float f = fract(sin(dot(p, vec2(12.1234, 72.8392) )*45123.2));\n return f;   \n}\n\nfloat rnd(float w)\n{\n    float f = fract(sin(w)*1000.);\n return f;   \n}\n\nfloat regShape(vec2 p, int N)\n{\n float f;\n    \n    \nfloat a=atan(p.x,p.y)+.2;\nfloat b=6.28319/float(N);\nf=smoothstep(.5,.51, cos(floor(.5+a/b)*b-a)*length(p.xy));\n    \n    \n    return f;\n}\nvec3 circle(vec2 p, float size, float decay, vec3 color,vec3 color2, float dist, vec2 mouse)\n{\n \t \n    \n    //l is used for making rings.I get the length and pass it through a sinwave\n    //but I also use a pow function. pow function + sin function , from 0 and up, = a pulse, at least\n    //if you return the max of that and 0.0.\n    \n    float l = length(p + mouse*(dist*4.))+size/2.;\n    \n    //l2 is used in the rings as well...somehow...\n    float l2 = length(p + mouse*(dist*4.))+size/3.;\n    \n    ///these are circles, big, rings, and  tiny respectively\n    float c = max(00.01-pow(length(p + mouse*dist), size*1.4), 0.0)*50.;\n    float c1 = max(0.001-pow(l-0.3, 1./40.)+sin(l*30.), 0.0)*3.;\n    float c2 =  max(0.04/pow(length(p-mouse*dist/2. + 0.09)*1., 1.), 0.0)/20.;\n    float s = max(00.01-pow(regShape(p*5. + mouse*dist*5. + 0.9, 6) , 1.), 0.0)*5.;\n    \n   \tcolor = 0.5+0.5*sin(color);\n    color = cos(vec3(0.44, .24, .2)*8. + dist*4.)*0.5+.5;\n \tvec3 f = c*color ;\n    f += c1*color;\n    \n    f += c2*color;  \n    f +=  s*color;\n    return f-0.01;\n}\n\nfloat sun(vec2 p, vec2 mouse)\n{\n float f;\n    \n    vec2 sunp = p+mouse;\n    float sun = 1.0-length(sunp)*8.;\n    return f;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy-0.5;\n    //uv=uv*2.-1.0;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec2 mm = iMouse.xy/iResolution.xy - 0.5;\n    mm.x *= iResolution.x/iResolution.y;\n    \n    \n    vec3 circColor = vec3(0.9, 0.2, 0.1);\n    vec3 circColor2 = vec3(0.3, 0.1, 0.5);\n    \n    //now to make the sky not black\n    vec3 color = mix(vec3(0.0, 0.0, 0.00)/1.0, vec3(0.0, 0.0, 0.0), uv.y)*3.-0.52*sin(iTime/0.4)*0.1+0.2;\n    \n    //this calls the function which adds three circle types every time through the loop based on parameters I\n    //got by trying things out. rnd i*2000. and rnd i*20 are just to help randomize things more\n    for(float i=0.;i<10.;i++){\n        color += circle(uv, pow(rnd(i*2000.)*1.0, 2.)+1.41, 0.0, circColor+i , circColor2+i, rnd(i*20.)*3.+0.2-.5, mm);\n    }\n    //get angle and length of the sun (uv - mouse)\n        float a = atan(uv.y-mm.y, uv.x-mm.x);\n    \tfloat l = max(1.0-length(uv-mm)-0.84, 0.0);\n    \n    float bright = 0.1;//+0.1/1/3.;//add brightness based on how the sun moves so that it is brightest\n    //when it is lined up with the center\n    \n    //add the sun with the frill things\n    color += max(0.1/pow(length(uv-mm)*5., 5.), 0.0)*abs(sin(a*5.+cos(a*9.)))/20.;\n    color += max(0.1/pow(length(uv-mm)*10., 1./20.), .0)+abs(sin(a*3.+cos(a*9.)))/8.*(abs(sin(a*9.)))/1.;\n\n    //add another sun in the middle (to make it brighter)  with the20color I want, and bright as the numerator.\n    color += (max(bright/pow(length(uv-mm)*4., 1./2.), 0.0)*4.)*vec3(0.2, 0.21, 0.3)*4.;\n       // * (0.5+.5*sin(vec3(0.4, 0.2, 0.1) + vec3(a*2., 00., a*3.)+1.3));\n    \t\n    //multiply by the exponetial e^x ? of 1.0-length which kind of masks the brightness more so that\n    //there is a sharper roll of of the light decay from the sun. \n        color*= exp(1.0-length(uv-mm))/5.;\n\tfragColor = vec4(color,0.5);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}