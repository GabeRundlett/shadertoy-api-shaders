{
    "Shader": {
        "info": {
            "date": "1602319203",
            "description": "gpu version of https://diglib.eg.org/bitstream/handle/10.1111/cgf13951/v39i2pp545-554.pdf?sequence=1&isAllowed=y\nextremly slow on gpu.",
            "flags": 0,
            "hasliked": 0,
            "id": "tdycRD",
            "likes": 9,
            "name": "Segment Tracing",
            "published": 3,
            "tags": [
                "raytracing",
                "metaball",
                "tracing",
                "segment"
            ],
            "usePreview": 0,
            "username": "yuchengzhong",
            "viewed": 608
        },
        "renderpass": [
            {
                "code": "//#define SSAA\nfloat intensity(vec3 pos,vec3 center,float radius)\n{\n    vec3 delta = pos-center;\n    float len = dot(delta,delta);\n    float localLen = 1.0-len / radius;\n\treturn (len > radius) ? 0.0 : localLen*localLen*localLen;\n    //return CubicFalloff(pos,center,radius);\n}\n\nvec2 K(vec3 start,vec3 end,vec3 center,float radius,float radius2,float radius2Inv,float energy) //energy = 1.0\n{\n    vec3 es = end - start;\n    vec3 cs = center - start;\n    vec3 ce = center - end;\n    float scsSqrt = length(cs);\n    float sceSqrt = length(ce);\n    float scs = scsSqrt*scsSqrt;\n    float sce = sceSqrt*sceSqrt;\n    float sesSqrt = length(es);\n\tvec3 axis = es/sesSqrt;\n\tfloat l = dot(cs,axis);\n\tfloat kk = 0.0;\n\tif (l < 0.0)\n\t{\n\t\tkk = CubicFalloffK(scs, sce,scsSqrt,sceSqrt, radius,radius2,radius2Inv, energy);\n\t}\n\telse if (sesSqrt < l)\n\t{\n\t\tkk = CubicFalloffK(sce, scs,sceSqrt,scsSqrt, radius,radius2,radius2Inv, energy);\n\t}\n\telse\n\t{\n\t\tfloat dd = scs - (l * l);\n\t\tvec3 pc = start + axis * l;\n\t\tkk = CubicFalloffK(dd, max(sce, scs),sqrt(dd),max(sceSqrt, scsSqrt), radius,radius2,radius2Inv, energy);\n\t}\n\tfloat grad = max(abs(dot(axis,cs)/scsSqrt), abs(dot(axis,ce)/sceSqrt));\n    float localLen = 1.0-scs / radius;\n\tfloat intensity =  (scs > radius) ? 0.0 : localLen*localLen*localLen;\n\treturn vec2(kk * grad,intensity);\n}\n#define global_k 1.0\n#define eps 0.001\nfloat scene(vec3 pos)\n{\n    //float t = iTime;\n    vec3 center = vec3(0.0,0.0,0.0);\n    float radius = 1.5;\n    \n    float I = 0.0;\n    for(int i=0;i<32;i++)\n    {\n        \n        I += intensity(pos,center+3.0*random3(i),radius);\n    }\n    return I-0.5;\n}\n\nvec2 sceneK(vec3 start,vec3 end)\n{\n    //float t = iTime;\n    vec3 center = vec3(0.0,0.0,0.0);\n    float radius = 1.5;\n    float radius2 = radius * radius;\n    float radius2Inv = 1.0/radius2;\n    \n    float k = 0.0;\n    float I = 0.0;\n    for(int i=0;i<32;i++)\n    {\n        vec2 data = K(start,end,center+3.0*random3(i),radius,radius2,radius2Inv,1.0);\n        k+=data.x;\n        I += data.y;\n    }\n    return vec2(k,I-0.5);\n}\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd )\n{\n    float mint = 5.0;\n    float maxt = 15.0;//min max intersect\n\tfloat t = mint;\n\n\tfor(int i=0;i<128;i++)\n\t{\n\t\tfloat I = scene(ro+rd*t);\n\t\tif (I > 0.0)\n        {\n\t\t\treturn vec2(t,float(i));\n        }\n        float ts = max(abs(I) / global_k, eps);\n\t\tt += ts;\n        if(t > maxt)\n        {\n            break;\n        }\n\t}\n\treturn vec2(-1.0,0.0);\n}\nvec2 calcIntersection2( in vec3 ro, in vec3 rd )\n{\n    float mint = 5.0;\n    float maxt = 15.0;//min max intersect\n\tfloat t = mint;\n\tfloat c = 1.5;\n\tfloat ts = (maxt - mint);\n\n\tfor(int i=0;i<128;i++)\n\t{\n        vec3 pt = ro+rd*t;\n\t\tvec3 pts = ro+rd*(t + ts);\n        vec2 data = sceneK(pt, pts);\n\t\tfloat I = data.y;\n\t\tif (I > 0.0)\n        {\n\t\t\treturn vec2(t,float(i));\n        }\n\t\tfloat k = data.x;\n\t\tfloat tk = abs(I) / k;\n\t\ttk = min(tk, ts);\n\t\tts = tk;\n\t\tif(tk >= 0.0)\n\t\t{\n\t\t\tt += max(tk, eps);\n\t\t}\n\t\tts = tk * c;\n        if(t > maxt)\n        {\n            break;\n        }\n\t}\n\treturn vec2(-1.0,0.0);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const vec3 v1 = vec3(1.0,0.0,0.0);\n    const vec3 v2 = vec3(0.0,1.0,0.0);\n    const vec3 v3 = vec3(0.0,0.0,1.0);\n\n\treturn normalize(vec3(scene(pos + v1*eps),scene(pos + v2*eps),scene(pos + v3*eps))\n                     -vec3(scene(pos - v1*eps),scene(pos - v2*eps),scene(pos - v3*eps)));\n}\nvec3 illuminate( in vec3 pos , in vec3 camdir )\n{\n    return calcNormal(pos)*0.5+0.5;\n}\n\nvec3 background( vec3 rd )\n{\n\treturn texture(iChannel0, rd).rgb * texture(iChannel0, rd).rgb;\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 colAcc = vec3(0.0,0.0,0.0);\n    \n    float t = iTime;\n    vec3 campos = vec3(10.0*sin(t*0.3),2.5*sin(t*0.5),-10.0*cos(t*0.3));\n    vec3 camtar = vec3(0.0,0.0,0.0);\n    \n    mat3 camMat = calcLookAtMatrix( campos, camtar, 0.0 );\n    #ifdef SSAA\n    for(float i=-0.5;i<1.0;i+=1.0)\n    {\n    for(float j=-0.5;j<1.0;j+=1.0)\n    {    \n    vec2 xy = (fragCoord.xy+0.5*vec2(i,j) - iResolution.xy/2.0) / min(iResolution.xy.x, iResolution.xy.y);\n    #else\n    vec2 xy = (fragCoord.xy - iResolution.xy/2.0) / min(iResolution.xy.x, iResolution.xy.y); \n    #endif\n\tvec3 camdir = normalize( camMat * vec3(xy,1.0) );\n    \n    vec3 col = vec3(0.0,0.0,0.0);\n    \n    float dist = 0.0;\n    float times = 256.0;\n    if(fragCoord.x/iResolution.x>0.501)\n    {        \n        vec2 data = calcIntersection2(campos, camdir);\n        dist = data.x;\n        times = data.y;\n    }\n    else if(fragCoord.x/iResolution.x<0.499)\n    {\n        vec2 data = calcIntersection(campos, camdir);\n        dist = data.x;\n        times = data.y;\n    }\n    else\n    {\n        dist = -2.0;   \n    }\n    if (dist==-1.0)\n    {\n        col = background(camdir);\n    }\n    else if(dist == -2.0)\n    {\n        col = vec3(1.0,0.0,0.0);   \n    }\n    else\n    {\n    \tvec3 inters = campos + dist * camdir;\n    \tcol = illuminate(inters, camdir);\n    }\n    if(fragCoord.y/iResolution.y<0.5)\n    {\n        col = mix(vec3(0.0,1.0,0.0),vec3(1.0,0.0,0.0),times/64.0);   \n    }\n        col = pow(col, vec3(0.8));\n        colAcc+=col;\n    \n    \n    \n\n    #ifdef SSAA\n    }\n    }\n\tfragColor = vec4(colAcc*0.25,1.0);\n    #else\n    fragColor = vec4(colAcc,1.0);\n    #endif\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float CubicFalloff(vec3 pos,vec3 center,float radius)\n{\n    vec3 delta = pos-center;\n    float len = dot(delta,delta);\n    float localLen = 1.0-len / radius;\n\treturn (len > radius) ? 0.0 : localLen*localLen*localLen;\n}\n\nfloat CubicFalloffK(float energy, float radius)\n{\n\treturn 1.72 * abs(energy) / radius;\n}\n\nfloat CubicFalloffK(float start, float end,float startSqrt,float endSqrt, float radius,float radius2,float radius2Inv, float energy)\n{\n    float absE = abs(energy);\n    float absE6Radius2Inv = absE * 6.0*radius2Inv;\n\tif (start > radius2)\n    {\n\t\treturn 0.0;\n    }\n    float radius202 = radius2 *0.2;\n\tif (end < radius202)\n\t{\n\t\tfloat t = (1.0 - end *radius2Inv);\n\t\treturn  absE6Radius2Inv*endSqrt* (t * t);\n\t}\n\telse if (start > radius202)\n\t{\n\t\tfloat t = (1.0 - start *radius2Inv);\n\t\treturn absE6Radius2Inv*startSqrt* (t * t);\n\t}\n\telse\n    {\n\t\treturn 1.72 * absE / radius;//CubicFalloffK\n    }\n}\nfloat SquaredNorm(vec3 a)\n{\n    return dot(a,a);   \n}\n\nvec3 hash3( uint n ) \n{\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec3 k = n * uvec3(n,n*16807U,n*48271U);\n    return vec3( k & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\nvec3 random3(int n)\n{\n    return hash3(uint(n))*2.0-1.0;   \n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}