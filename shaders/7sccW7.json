{
    "Shader": {
        "info": {
            "date": "1653532272",
            "description": "TL // Light saber fight",
            "flags": 4,
            "hasliked": 0,
            "id": "7sccW7",
            "likes": 7,
            "name": "TL // Light saber fight",
            "published": 3,
            "tags": [
                "noise",
                "fbm",
                "lights"
            ],
            "usePreview": 0,
            "username": "fpiaggio",
            "viewed": 630
        },
        "renderpass": [
            {
                "code": "#define HorizontalAmplitude\t\t10.010\n#define VerticleAmplitude\t\t0.010\n#define HorizontalSpeed\t\t\t0.10\n#define VerticleSpeed\t\t\t10.50\n#define ParticleMinSize\t\t\t1.76\n#define ParticleMaxSize\t\t\t10.61\n#define ParticleBreathingSpeed\t\t0.30\n#define ParticleColorChangeSpeed\t0.70\n#define ParticleCount\t\t\t2.0\n#define ParticleColor1\t\t\tvec3(.0, 2.0, 2.0)\n#define ParticleColor2\t\t\tvec3(5.0, 1.0, 1.0)\n#define iTime iTime+getSound()*.2\n\nfloat getSound() \n{\n    float s=0.;\n    for (float i=0.; i<20.; i++) {\n        s+=texture(iChannel0,vec2(0.,i/20.)).r;\n    }\n    for (float i=0.; i<20.; i++) {\n        s+=texture(iChannel0,vec2(i/20.,0.)).r;\n    }\n    return s/20.;\n}\nmat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n    return mat2(\n        c, s,\n        -s, c\n    );\n}\nfloat hash( float x )\n{\n    return fract( sin( x ) * 43758.5453 );\n}\n\nfloat noise( vec2 uv )\n{\n    vec3 x = vec3( uv.xy, 90.0 );\n    \n    vec3 p = floor( x );\n    vec3 f = fract( x );\n    \n    f = f*f*(3.0 - 2.0*f);\n    \n    float offset = 57.0;\n    \n    float n = dot( p, vec3(1.0, offset, offset*2.0) );\n    \n    return mix(\tmix(\tmix( hash( n + 0.0 ), \t\thash( n + 1.0 ), f.x ),\n        \t\t\t\tmix( hash( n + offset), \thash( n + offset+1.0), f.x ), f.y ),\n\t\t\t\tmix(\tmix( hash( n + offset*2.0), hash( n + offset*2.0+1.0), f.x),\n                    \tmix( hash( n + offset*3.0), hash( n + offset*3.0+1.0), f.x), f.y), f.z);\n}\n\nfloat snoise( vec2 uv )\n{\n    return noise( uv ) * 2.0 - 1.0;\n}\n\n\nfloat perlinNoise( vec2 uv )\n{   \n    float n = \t\tnoise( uv * 1.0 ) \t* 128.0 +\n        \t\tnoise( uv * 2.0 ) \t* 64.0 +\n        \t\tnoise( uv * 4.0 ) \t* 32.0 +\n        \t\tnoise( uv * 8.0 ) \t* 16.0 +\n        \t\tnoise( uv * 16.0 ) \t* 8.0 +\n        \t\tnoise( uv * 32.0 ) \t* 4.0 +\n        \t\tnoise( uv * 64.0 ) \t* 2.0 +\n        \t\tnoise( uv * 128.0 ) * 1.0;\n    \n    float noiseVal = n / ( 1.0 + 2.0 + 4.0 + 8.0 + 16.0 + 32.0 + 64.0 + 128.0 );\n    noiseVal = abs(noiseVal * 2.0 - 1.0);\n\t\n    return \tnoiseVal;\n}\n\nfloat fBm( vec2 uv, float lacunarity, float gain )\n{\n    float sum = 0.0;\n    float amp = 7.0;\n    \n    for( int i = 0; i < 10; ++i )\n    {\n        sum += ( perlinNoise( uv ) ) * amp;\n        amp *= gain;\n        uv *= lacunarity;\n    }\n    \n    return sum;\n}\n\nvec3 particles( vec2 pos )\n{\n\t\n\tvec3 c = vec3( 0, 0, 0 );\n\t\n\tfloat noiseFactor = fBm( pos, 0.01, 0.1);\n\t\n\tfor( float i = 1.0; i < ParticleCount+1.0; ++i )\n\t{\n\t\tfloat cs = cos( iTime * HorizontalSpeed * (i/ParticleCount) + noiseFactor ) * HorizontalAmplitude;\n\t\tfloat ss = sin( iTime * VerticleSpeed   * (i/ParticleCount) + noiseFactor ) * VerticleAmplitude;\n\t\tvec2 origin = vec2( cs , ss );\n\t\t\n\t\tfloat t = sin( iTime * ParticleBreathingSpeed * i ) * 0.5 + 0.5;\n\t\tfloat particleSize = mix( ParticleMinSize, ParticleMaxSize, t );\n\t\tfloat d = clamp( sin( length( pos - origin )  + particleSize ), 0.0, particleSize);\n\t\t\n\t\tfloat t2 = sin( iTime * ParticleColorChangeSpeed * i ) * 0.5 + 0.5;\n\t\tvec3 color = mix( ParticleColor1, ParticleColor2, t2 );\n\t\tc += color * pow( d, 5.0 );\n\t}\n\t\n\treturn c;\n}\n\nfloat line( vec2 a, vec2 b, vec2 p )\n{\n\tvec2 aTob = b - a;\n\tvec2 aTop = p - a;\n\t\n\tfloat t = dot( aTop, aTob ) / dot( aTob, aTob) * fBm(a, 0., 0.);\n\t\n\tt = clamp( t, 0.0, 1.0);\n\t\n\tfloat d = length( p - (a + aTob * t)  );\n\td = 1.0 / d;\n\t\n\treturn clamp( d, 0.0, 1.0 );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord -.5*iResolution.xy )/iResolution.y;\n    float scale = 200.0;\n    float v = 70.0 + sin(iTime) * 30.;\n    uv *= r2d(iTime*0.25);\n    float freqA = mix( 0.4, 1.2, sin(iTime + 30.0) * 0.5 + 0.5 );\n\tfloat freqB = mix( 0.4, 1.2, sin(iTime + 20.0) * 0.5 + 0.5 );\n\tfloat freqC = mix( 0.4, 1.2, sin(iTime + 10.0) * 0.5 + 0.5 );\n    vec3 finalColor = vec3( 0.0 );\n    finalColor = (particles( sin( abs(uv* (sin(iTime*0.2)+0.6)*5.) ) ) * length(uv)) * 0.20;\n    uv *= r2d(sin(-iTime*2.25));\n    float t = line( vec2(-v, -v), vec2(0.0, v), uv * scale );\n    uv *= r2d(cos(-iTime*1.25));\n    finalColor += vec3( 8.0 * t, 2.0 * t, 4.0 * t) * freqA;\n\tt = line( vec2(0.0, v), vec2(v, -v), uv * scale );\n    uv *= r2d(-iTime*.45);\n\tfinalColor += vec3( 2.0 * t, 2.0 * t, 4.0 * t) * freqB;\n\tt = line( vec2(-v, -v), vec2(v, -v), uv * scale );\n    uv *= r2d(sin(iTime*100.15));\n    finalColor += vec3( 2.0 * t, 6.0 * t, 4.0 * t) * freqB;\n\n    fragColor = vec4(finalColor,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "mic",
                        "id": 32,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/mic.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}