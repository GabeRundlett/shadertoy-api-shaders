{
    "Shader": {
        "info": {
            "date": "1624488394",
            "description": "The goal of this is to create a compact music arranger that can be re-used to make all kinds of fun shadertoy music.",
            "flags": 40,
            "hasliked": 0,
            "id": "7t23z3",
            "likes": 13,
            "name": "Music Maker v1 (GPU Music)",
            "published": 3,
            "tags": [
                "2d",
                "sound",
                "gpusound"
            ],
            "usePreview": 0,
            "username": "Plento",
            "viewed": 522
        },
        "renderpass": [
            {
                "code": "/*\n    Cole Peterson \n    \n    WIP\n    \n    - The goal of this is to create a compact music arranger that can be re-used\n    to make all kinds of fun shadertoy music.\n    \n    - Create patterns that can be looped and arranged.\n    \n    - Working on a simpler, more intuitive way to play notes.\n\n*/\n\nfloat line( in vec2 p, in vec2 a, in vec2 b ){\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = u / R;\n    vec2 uv2 = vec2(u.xy - 0.5*R.xy)/R.y;\n    \n    vec3 col = vec3(0);\n    \n    uv += iTime*.031;\n    \n    vec2 id = floor(uv*110.)*.03;\n    vec2 id2 = floor(uv*20.);\n    \n    vec3 tex = texture(iChannel0, id).xyz;\n    \n    col = tex;\n    \n    if(cos(id2.x*10. + id2.y*8. + iTime) > 0.)\n        col = mix(col.rrr, col, .5+.5*cos(length(uv)*4. - iTime));\n    \n    col *= (1.-step(.44, abs(uv2.y)));\n    f = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define R iResolution.xy\n\n// Constants\nconst float pi = 3.1415;\nconst float BPM = 175.0;\n\n\nconst float pitchWheel = 4.0;\n\nconst float swing = -0.4;\n\n\n// noise\nvec2 hash22(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// Metronome sound\nfloat blip(float t, float hz, float k){\n    return (1. - exp(-t*40.)) * sin(pi*2.*hz*t) * exp(-t * k);\n}\n\n\n\n// A beat\nfloat b(float t){\n    return mod(t, 60. / BPM);\n}\n\n\n\n// Various durations of time\nfloat bar_l = 240. / BPM; // Bar\nfloat beat_l = 60. / BPM; // beat\nfloat half_l = 30. / BPM; // half beat\nfloat quarter_l = 15. / BPM; // quarter beat\n\n\n// Get the correct time for a note based on its time offset\n// q = note start time (bar, beat, half beat, quarter beat)\n// nBeats = number of beats in pattern\n// t = time\nfloat noteTime(vec4 q, float nBeats, float t){\n    float start = t - (bar_l*q.x + beat_l*q.y + half_l*q.z + quarter_l*q.w);\n    return mod(max(start, 0.), nBeats*60. / BPM);\n}\n\n\n// Loop a pattern\n// q = pattern start time (bar, beat, half beat, quarter beat)\n// loop = number of times to loop pattern\n// nb = number of beats in pattern\n// t = time\nfloat seq(vec4 q, float loop, float nb, float t){\n    float start = (bar_l*q.x + beat_l*q.y + half_l*q.z + quarter_l*q.w);\n    float dur = nb*loop*60. / BPM;\n    \n    if(t > start && t < start + dur)\n        return t - start;\n    else\n        return 0.;\n}\n\n\n\n\n// Distortions\nfloat dist1(float s, float d){\n \treturn clamp(d * s, -1., 1.);   \n}\nvec2 dist2(vec2 s, float d){\n \treturn clamp(d * s, vec2(-1.0), vec2(1.0));   \n}\n\n\n\n// Attack and decay from exponential and sqrt funcs\nfloat env(float t, float atk, float rel){\n    return (1. - exp(-t*atk)) * exp(-t*rel);\n}\n\n// Linear envelope thing\n// t = time\n// p = (attack, sustain, release)\nfloat envelope(float t, vec3 p){\n    float a = t / p.x;\n    float b = (p.y + p.x + p.z - t);\n    return max(min(min(a, 1.), b), 0.);\n}\n\n\n\n// Note stuff\nconst float baseFreq = 110.0; // A1\nconst float d12thRootOf2 = pow(2.0, 1.0 / 12.0);\n\n// Return the note's frequency\nfloat n(float k){\n    return baseFreq * pow(d12thRootOf2, k + pitchWheel);\n}\n\n\n\n// Waveforms\nfloat sine(float t, float hz){\n    return sin(hz*t*pi*2.);\n}\n\nfloat triangle(float t, float hz){\n    return (2. / pi) * asin(sin(2.*pi*t*hz));\n}\n\nfloat tri(float t, float hz){\n    return (2. / pi) * asin(sin(2.*pi*t*hz));\n}\n\nfloat sqr(float t, float hz){\n    return sign(sin(2.*pi*t*hz)) * 0.5;\n}\n\nfloat saw(float t, float hz){\n    return 2.*mod(pi*.5*(hz*t) / pi, 1.) - 1.;\n}\n\n// Stereo versions\nvec2 sqr_2(float t, float nt, float sep){\n    return vec2(sqr(t, n(nt)), sqr(t, n(nt) + sep));\n}\n\nvec2 tri_2(float t, float nt, float sep){\n    return vec2(tri(t, n(nt)), tri(t, n(nt) + sep));\n}\n\nvec2 sine_2(float t, float nt, float sep){\n    return vec2(sine(t, n(nt)), sine(t, n(nt) + sep));\n}\n\nvec2 saw_2(float t, float nt, float sep){\n    return vec2(saw(t, n(nt)), saw(t, n(nt) + sep));\n}\n\n\n\n\n// Chords\nvec2 minor_tri(float t, float nt, float sep){\n    vec2 ms = vec2(0);\n    \n    ms += .5*tri_2(t, nt - 12., sep);\n    \n    ms += tri_2(t, nt, sep);\n    ms += tri_2(t, nt + 3., sep);\n    ms += tri_2(t, nt + 7., sep);\n    \n    return ms / 4.;\n}\n\nvec2 major_tri(float t, float nt, float sep){\n    vec2 ms = vec2(0);\n    \n    ms += .1*tri_2(t, nt - 12., sep);\n    \n    ms += tri_2(t, nt, sep);\n    ms += tri_2(t, nt + 4., sep);\n    ms += tri_2(t, nt + 7., sep);\n    \n    return ms / 4.;\n}\n\n\n\n\n\n\n\n\n// Synths\n\n\n// Major triad thingy\nvec2 synth_2(float k, float dur, vec4 q, float nBeats, float t){\n    vec2 ms = vec2(0);\n    float t0 = noteTime(q, nBeats, t);\n\n    ms += major_tri(t0, k, 0.75);\n    \n    return ms * smoothstep(0.0, .05, t0) * smoothstep(2.0, .0, t0);\n    \n}\n\n\n// lead saw / triangle thingy\nvec2 synth_5(float k, float dur, vec4 q, float nBeats, float t){\n    vec2 ms = vec2(0);\n    dur = (dur * 60.) / BPM;\n    \n    float t0 = noteTime(q, nBeats, t);\n\n    ms += tri_2(t0, k, 6.);\n    ms += .2*saw_2(t0, k + 12., 6.);\n    \n    return ms * smoothstep(0.0, .1, t0) * smoothstep(dur + .25, dur, t0);\n    \n}\n\n// Saw lead \nvec2 synth_6(float k, float dur,float oct, vec4 q, float nBeats, float t){\n    vec2 ms = vec2(0);\n    dur = (dur * 60.) / BPM;\n    \n    float t0 = noteTime(q, nBeats, t);\n\n    ms += saw_2(t0, k + 24., 2.);\n    //ms += .35*saw_2(t0, k + 12., 3.);\n    \n    //return ms * smoothstep(0.0, .1, t0) * smoothstep(1.8, 0., t0);\n    return ms * smoothstep(0.0, .2, t0) * smoothstep(dur + .25, dur, t0);\n    \n}\n\n// Subby bass \nvec2 synth_3(float k, float dur, vec4 q, float nBeats, float t){\n    vec2 ms = vec2(0);\n    dur = (dur * 60.) / BPM;\n    \n    float t0 = noteTime(q, nBeats, t);\n    \n    ms += .2*tri_2(t0, k, 0.4);\n    ms += sine_2(t0, k - 12., 0.);\n    \n    return ms * smoothstep(0.0, .01, t0) * smoothstep(dur + .01, dur, t0);\n    //return ms * smoothstep(0.0, .4, t0) * smoothstep(2.2, .0, t0);\n}\n\n\n\n\n// Drums\nvec2 snare(vec4 q, float nBeats, float t){\n    float t0 = noteTime(q, nBeats, t);\n\n    vec2 s = exp(-t0*16.) * hash22(iSampleRate * vec2(t0, t0*1.423)) * 2.0 - 1.0; \n    s = dist2(s, 1.13) * .85;\n    s += 1.3*dist1(exp(-t0*24.) * sine(t0, 200.), 4.0);\n    s += .1*dist1(exp(-t0*24.) * sine(t0, 150.), 3.0);\n    return s * 0.25;\n}\n\n\nvec2 kick(vec4 q, float nBeats, float t){\n    float t0 = noteTime(q, nBeats, t);\n    \n    vec2 s = vec2(0);\n    s += 1.5*dist2(exp(-t0*22.) * vec2(sine(t0, 72.)), 4.7);\n    s += 4. * exp(-t0*15.) * vec2(sine(t0, 70.));\n    return s * .15;\n}\n\nvec2 hat(vec4 q, float nBeats, float t){\n    float t0 = noteTime(q, nBeats, t);\n    \n    vec2 s = envelope(t0, vec3(.1, .01, .01)) * hash22(iSampleRate * vec2(t, t*1.423)) * 2.0 - 1.0; \n    \n    //s = dist2(s, 1.1) * .85;\n    return s * 0.4;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n\n/*\n    Cole Peterson\n    \n    WIP\n    \n    - The goal of this is to create a compact music arranger that can be re-used\n    to make all kinds of fun shadertoy music.\n    \n    - Create patterns that can be looped and arranged.\n    \n    - Working on a simpler, more intuitive way to play notes and arrange patterns.\n\n*/\n\n// t = time\n// nb = Number of beats in this pattern\nvec2 pattern_chords_1(float t, float nb){\n    vec2 ms = vec2(0);\n    \n    // play note 15 for 4 beats on the first bar. vec4(bar, beat, half beat, quarter beat)\n    ms += synth_2(15., 4., vec4(0., 0., 0., 0.), nb, t);\n    \n    // play note 10 for 4 beats on the second bar... ect.\n    ms += synth_2(10., 4., vec4(1., 0., 0., 0.), nb, t);\n    \n    ms += synth_2(13., 4., vec4(2., 0., 0., 0.), nb, t);\n    ms += synth_2(8., 4., vec4(3., 0., 0., 0.), nb, t);\n    \n    return ms;\n}\n\n\nvec2 pattern_lead_1(float t, float nb){\n    vec2 ms = vec2(0);\n    \n    ms += synth_5(15. + 12., 4., vec4(0., 0., 0., 0.), nb, t);\n    ms += synth_5(17. + 12., 4., vec4(1., 0., 0., 0.), nb, t);\n    ms += synth_5(13. + 12., 4., vec4(2., 0., 0., 0.), nb, t);\n    ms += synth_5(15. + 12., 4., vec4(3., 0., 0., 0.), nb, t);\n    \n    ms += synth_5(15. + 12., 4., vec4(4., 0., 0., 0.), nb, t);\n    ms += synth_5(17. + 12., 4., vec4(5., 0., 0., 0.), nb, t);\n    ms += synth_5(20. + 12., 4., vec4(6., 0., 0., 0.), nb, t);\n    ms += synth_5(19. + 12., 4., vec4(7., 0., 0., 0.), nb, t);\n     \n    return ms;\n}\n\n\nvec2 pattern_lead_2(float t, float nb){\n    vec2 ms = vec2(0);\n    \n    ms += synth_6(15., 2., 1., vec4(0., 2., 0., 0.), nb, t);\n    ms += synth_6(14., 4., 1., vec4(1., 0., 0., 0.), nb, t);\n    ms += synth_6(13., 4., 1., vec4(2., 0., 0., 0.), nb, t);\n    ms += synth_6(15., 2., 1., vec4(3., 0., 0., 0.), nb, t);\n    ms += synth_6(7., 2., 1., vec4(3., 2., 0., 0.), nb, t);\n    ms += synth_6(10., 4., 1., vec4(4., 0., 0., 0.), nb, t);\n    ms += synth_6(12., 4., 1., vec4(5., 0., 0., 0.), nb, t);\n    ms += synth_6(8., 4., 1., vec4(6., 0., 0., 0.), nb, t);\n    ms += synth_6(7., 4., 1., vec4(7., 0., 0., 0.), nb, t);\n    \n    return ms;\n}\n\n\nvec2 pattern_bass_1(float t, float nb){\n    vec2 ms = vec2(0);\n    \n    ms += synth_3(3., 4., vec4(0., 0., 0., 0.), nb, t);\n    ms += synth_3(-2., 4., vec4(1., 0., 0., 0.), nb, t);\n    ms += synth_3(1., 4., vec4(2., 0., 0., 0.), nb, t);\n    ms += synth_3(-4., 4., vec4(3., 0., 0., 0.), nb, t);\n     \n    return ms;\n}\n\n\nvec2 pattern_drums_hat(float t, float nb){\n    vec2 ms = vec2(0);\n    \n    ms += hat(vec4(0., 0., 0., 0.), nb, t);\n    ms += hat(vec4(0., 1., 0., 0.0), nb, t);\n    ms += hat(vec4(0., 1., 1., 1.0 + swing), nb, t);\n    ms += hat(vec4(0., 2., 0., 0.0), nb, t);\n    ms += hat(vec4(0., 3., 0., 0.0), nb, t);\n    ms += hat(vec4(0., 3., 1., 1.0 + swing), nb, t);\n    \n    return ms;\n}\n\nvec2 pattern_drums_kick(float t, float nb){\n    vec2 ms = vec2(0);\n    \n    ms += kick(vec4(0., 0., 0., 0.), nb, t);\n    ms += kick(vec4(0., 0., 3., 1. + swing), nb, t);\n    ms += kick(vec4(0., 3., 0., 0.), nb, t);\n    \n    return ms;\n}\n\nvec2 pattern_drums_snare(float t, float nb){\n    vec2 ms = vec2(0);\n    \n    ms += snare(vec4(0., 2., 0., 0.), nb, t);\n    ms += snare(vec4(0., 6., 0., 0.), nb, t);\n    \n    return ms;\n}\n\n\n\n\n\n// Arrange song\nvec2 snd(float t){\n    vec2 ms = vec2(0);\n    \n    ms += .3*pattern_chords_1(seq(vec4(0., 0., 0., 0.), 32., 16., t), 16.);\n    \n    ms += .35*pattern_bass_1(seq(vec4(4., 0., 0., 0.), 32., 16., t), 16.);\n    \n    ms += .0544*pattern_lead_1(seq(vec4(8., 0., 0., 0.), 32., 32., t), 32.);\n    \n    ms += .036*pattern_lead_2(seq(vec4(24., 0., 0., 0.), 16., 16., t), 32.);\n    \n    \n    ms += .5*pattern_drums_hat(seq(vec4(4., 0., 0., 0.), 32., 16., t), 4.);\n    ms += .7*pattern_drums_kick(seq(vec4(4., 0., 0., 0.), 32., 16., t), 8.);\n    ms += .5*pattern_drums_snare(seq(vec4(4., 0., 0., 0.), 32., 16., t), 8.);\n    \n    return ms * .5;\n}\n\nvec2 mainSound( int samp, float time ){\n    vec2 ms = snd(time);\n    \n    float vol = min(time*.6, 1.);\n    \n    \n    //ms += blip(b(time), 825., 60.) * .4;\n    return ms * vol;\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "\nfloat line( in vec2 p, in vec2 a, in vec2 b ){\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    \n    uv *= 1. + cos(iTime*3.)*.04;\n    \n    float sun = smoothstep(.3, .305, length(uv));\n    sun *= smoothstep(.3, .36, (.5 + .5*cos(cos(iTime-length(uv)*20.)+atan(uv.y / uv.x) * 30.)));\n    \n    vec3 col = .3 + .4*cos(vec3(.6, 6., 1.)*length(uv*2.)+iTime+vec3(2., 2.2, 1.))* (1.-abs(uv.y));\n    col = mix(.5 + .3*cos(vec3(.6, 2., 4.)*length(uv*4.)-iTime), col, sun);\n    \n\n    \n    f = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}