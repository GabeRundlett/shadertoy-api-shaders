{
    "Shader": {
        "info": {
            "date": "1478729112",
            "description": "Playing around with a simple triangle animation. A remake this gif https://twitter.com/bigblueboo/status/792742608904785921",
            "flags": 0,
            "hasliked": 0,
            "id": "lt3XRM",
            "likes": 15,
            "name": "Overlapping Triangles",
            "published": 3,
            "tags": [
                "fractal",
                "triangles"
            ],
            "usePreview": 0,
            "username": "Wumpf",
            "viewed": 855
        },
        "renderpass": [
            {
                "code": "#define ENABLE_ANTIALIAS\n\n#define PI2 6.28318530718\n#define NUMTRI 21\n\nfloat triangle(in vec2 uv, float size, float rotation)\n{\n    float crot = cos(rotation);\n    float srot = sin(rotation);\n    uv = vec2(dot(uv, vec2(crot, -srot)), dot(uv, vec2(srot, crot)));\n   \n    float dist = max(max(-2.0 * uv.y, uv.y - uv.x * sqrt(3.0)), uv.y + uv.x * sqrt(3.0)); // Equilateral Tri.\n    \n    if(dist > size)\n        return 0.0;\n    else\n        return 1.0;\n}\n\nfloat evaluate(in vec2 uv, float scaledTime)\n{\n    float value = 0.0;\n    for(int i=0; i<NUMTRI; ++i)\n    {\n        float fi = float(i);\n        float rotDir = mod(fi, 2.0) * 2.0 - 1.0;\n        float tridelay = fi * 0.05;\n        float time = smoothstep(tridelay, tridelay + 1.0, scaledTime) * PI2 / 3.0;\n    \tvalue += triangle(uv, fi * 0.025, time * rotDir);\n    }\n\n    return mod(value, 2.0);\n}\n\nfloat sampleImage(in vec2 uv, float scaledTime, float pixSize)\n{\n    float sampleValue;\n#ifdef ENABLE_ANTIALIAS\n    // Simple multisampling (rotated grid multisampling)\n    sampleValue  = evaluate(uv + vec2(-0.375, 0.125) * pixSize, scaledTime);\n    sampleValue += evaluate(uv + vec2(0.125, 0.375) * pixSize, scaledTime);\n    sampleValue += evaluate(uv + vec2(0.375, -0.125) * pixSize, scaledTime);\n    sampleValue += evaluate(uv + vec2(-0.125, -0.375) * pixSize, scaledTime);\n   \tsampleValue /= 4.0;\n#else\n   \tsampleValue = evaluate(uv, scaledTime);\n#endif\n    \n    return sampleValue;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pixSize = 1.0 / iResolution.y;// assume wider than tall\n\tvec2 uv = vec2(0.5) - fragCoord.xy * pixSize; \n    uv.x -= (iResolution.y - iResolution.x) / iResolution.y * 0.5;\n\tuv.y += 0.08;// move stuff up a bit\n    \n    float scaledTime = mod(iTime, 16.0) * 0.2;\n    \n    float value = sampleImage(uv, scaledTime, pixSize);\n    \n    fragColor = vec4(value,value,value, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}