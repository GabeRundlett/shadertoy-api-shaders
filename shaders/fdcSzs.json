{
    "Shader": {
        "info": {
            "date": "1633696292",
            "description": "my first shader.",
            "flags": 0,
            "hasliked": 0,
            "id": "fdcSzs",
            "likes": 2,
            "name": "oct",
            "published": 3,
            "tags": [
                "octahedron"
            ],
            "usePreview": 0,
            "username": "Kornelius",
            "viewed": 213
        },
        "renderpass": [
            {
                "code": "\nfloat plane(vec3 pos) {\nreturn pos.y;\n}\n\n\n\nfloat romb(vec3 p) \n{\n\nvec4 oct = vec4(2.5, .7, 0.0, 0.45);\n\n\n  p = abs(p-oct.xyz);\n     \n  \n  float m = p.x+p.y+p.z-oct.w*0.5554;\n  vec3 q;\n       if(-100.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( -3.5*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n     q.xyz -= clamp(sin(iTime)/2.0, 0.0, .19);\n\n  float k = clamp(0.5*(q.z-q.y+oct.w),0.0,oct.w); \n  return length(vec3(q.x,q.y-oct.w+k,q.z-k)*p*4.0);\n  }\n\n\nfloat octahedron(vec3 p)\n{\n\n\nvec4 s= vec4(2.5, 0.35*2.0 - sin(iTime*2.0)/55.0, 0.0, 0.25);\n\n  p = abs(p - s.xyz);\n  vec3 q = p-1.0*clamp(round(p/1.0),-1.0,.3);\n  return (q.x+q.y+q.z-s.w)*0.57735027;\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvec2 map(vec3 pos) {\n\n\nvec2 res = vec2(1e10, -1.0);\n\nvec2 romb = vec2(romb(pos), 1.0);\nvec2 plane = vec2(plane(pos), 2.0);\nvec2 octahedron= vec2(octahedron(pos), 3.0);\n\n\nif(romb.x < res.x) {res = romb;}\nif(octahedron.x < res.x) {res = octahedron;}\nif(plane.x < res.x) {res = plane;}\n\n\n\n\nreturn res; \n\n\n}\n\nvec2 raycast(vec3 ro, vec3 rd) {\nfloat epsilon = 0.01; \n\nvec2 res;\n\nfloat t = 0.0; \nfor(int i = 0; i < 180; ++i) \n{\nvec2 res = map(ro+rd*t);\nif(res.x < epsilon)\n{\nreturn vec2(t, res.y);\n}\nt += res.x;\n} \nreturn res;\n\n}\n\n\nvec3 calcNormal(vec3 p)\n{\n\n   const float h = 0.001; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ).x + \n                      k.yyx*map( p + k.yyx*h ).x + \n                      k.yxy*map( p + k.yxy*h ).x + \n                      k.xxx*map( p + k.xxx*h ).x );  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 light = normalize(vec3(0.2, -1.0, .2942342));\n    vec3 ro = vec3(6, 0.75, 0.0);\n    vec3 rd = vec3(-1, (fragCoord.y-iResolution.y/2.0)/iResolution.x, -fragCoord.x/iResolution.x+0.5);\n    rd = normalize(rd); \n    \n    vec2 res = raycast(ro, rd); \n    float t = res.x;\n    float m = res.y;\n    \n    vec3 col = vec3(0.0, 0, 0);\n    \n   if(m != -1.0){\n    vec3 pos = ro + rd * t; \n    if(m == 1.0) {//robm\n    \n    col = 0.5 + 2.5*cos(iTime+rd.xyx+vec3(6,0,4));\n    }\n    else if(m==2.0) {// plane\n    col = vec3(0., .0, .0);\n    \n    float ao = clamp(length(pos.xyz - vec3(1.5, 0.25, .04)), 0.0, 1.0); \n    col = col * 0.25 + ao * +.5 * col;\n    }\n    else if(m==3.0) {// octahedron\n    col = 0.5 + 0.5*cos(iTime+rd.xyx+vec3(3,0,4));\n    \n    }\n \n   \n    vec3 nor = calcNormal(pos);\n    float dif = clamp(dot(nor, -light), 0.0, 1.0); \n    \n    col = 0.55 * col +.75*dif * col;\n\n   \n    fragColor = vec4(col, 1.0);\n}\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}