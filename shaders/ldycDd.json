{
    "Shader": {
        "info": {
            "date": "1523743062",
            "description": "Fork of https://www.shadertoy.com/view/MlGSz3 to display a cat walk animation.",
            "flags": 0,
            "hasliked": 0,
            "id": "ldycDd",
            "likes": 4,
            "name": "cat walk",
            "published": 3,
            "tags": [
                "2d",
                "spline",
                "cat",
                "fourier",
                "catmullrom",
                "walk"
            ],
            "usePreview": 0,
            "username": "LLB",
            "viewed": 343
        },
        "renderpass": [
            {
                "code": "// This modification by LLB\n// based on https://www.shadertoy.com/view/MlGSz3 by revers / iq\n// and on https://creapills.com/differantly-dessin-un-seul-trait-dft-20171122 by differantly\n\n// revers: This is fork of iq's \"Fourier - interpolation\" [ https://www.shadertoy.com/view/4lGSDw ].\n//         It compares Fourier (green line) with Catmull-Rom (black line) interpolation. \n//         Fourier version produces more round shape, but is slower (over 3 times on my video card)\n//         than Catmull-Rom.\n\n// Original created by inigo quilez - iq/2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// A set of points gets interpolated by computing the DFT (Discrete Fourier Transform)\n// and then its inverse, and evaluating the it at more than 38 points. This results in\n// an interpolation sort of made of cosine/sine waves. Would be nice to do a regular\n// Hermite spline interpolation as well to compare.\n//\n// More info: https://iquilezles.org/articles/fourier\n\n\n\n/**\n * Tension. Default Catmul-Rom matrix\n * has tension equal to 0.5.\n *\n * Values below 0.5 will cause sharp edges,\n * values above 0.5 will produce more curly lines.\n */\n#define T 0.6\n\n/**\n * Catmull-Rom Matrix\n */\nconst mat4 CRM = mat4(-T,        2.0 - T,  T - 2.0,         T,\n                       2.0 * T,  T - 3.0,  3.0 - 2.0 * T,  -T,\n                      -T,        0.0,      T,               0.0,\n                       0.0,      1.0,      0.0,             0.0);\n/**\n * Catmull-Rom Spline Interpolation\n */\nvec2 interpolate(vec2 G1, vec2 G2, vec2 G3, vec2 G4, float t) {\n    vec2 A = G1 * CRM[0][0] + G2 * CRM[0][1] + G3 * CRM[0][2] + G4 * CRM[0][3];\n    vec2 B = G1 * CRM[1][0] + G2 * CRM[1][1] + G3 * CRM[1][2] + G4 * CRM[1][3];\n    vec2 C = G1 * CRM[2][0] + G2 * CRM[2][1] + G3 * CRM[2][2] + G4 * CRM[2][3];\n    vec2 D = G1 * CRM[3][0] + G2 * CRM[3][1] + G3 * CRM[3][2] + G4 * CRM[3][3];\n\n    return t * (t * (t * A + B) + C) + D;\n}\n//=======================================================================================\n\nfloat sdSegmentSq(vec2 p, vec2 a, vec2 b) {\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\tvec2 d = pa - ba * h;\n\treturn dot(d, d);\n}\n\nfloat sdPointSq(vec2 p, vec2 a) {\n\tvec2 d = p - a;\n\treturn dot(d, d);\n}\n\nconst int NUM = 26;\n\nvec3 draw(vec3 col, float d) {\n\td = sqrt(d);\n\tfloat e = 1.0 / iResolution.x;\n\tcol = mix(col, vec3(0.1, 0.1, 0.2), 1.0 - smoothstep(0.0 * e, 2.0 * e, d));\n\tcol *= 0.75 + 0.25 * smoothstep(0.0, 0.13, sqrt(d));\n    return col;\n}\n\nvec3 catmullRom(vec2 path[NUM], vec2 uv) {\n\tvec3 col = vec3(1.0);\n\n    //------------------------------------------------------\n\t// Catmull-Rom interpolation\n\t// (added by revers)\n\t//------------------------------------------------------\n\t{\n\t\tfloat d = 1e5;\n\t\tfloat ani = float(NUM); // min(mod((12.0 + iTime) / 10.1, 1.3), 1.0) * float(NUM);\n\n\t\tvec2 p = path[0];\n\n\t\tfor (int i = 0; i < NUM - 3; i++) {\n\t\t\tfloat fi = float(i);\n\n\t\t\tif (fi > ani) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvec2 A = path[i + 0];\n\t\t\tvec2 B = path[i + 1];\n\t\t\tvec2 C = path[i + 2];\n\t\t\tvec2 D = path[i + 3];\n\n\t\t\tfor (float t = 0.0; t <= 1.01; t += 0.1) {\n\t\t\t\tvec2 q = interpolate(A, B, C, D, t);\n\n\t\t\t\td = min(d, sdSegmentSq(uv, p, q));\n\t\t\t\tp = q;\n\n\t\t\t\tif (fi + t > ani) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        col = draw(col, d);\n\t\t//col = mix(col, vec3(0.1, 0.1, 0.2), 1.0 - smoothstep(0.0 * e, 2.0 * e, d));\n\t\t//col *= 0.75 + 0.25 * smoothstep(0.0, 0.13, sqrt(d));\n\t}\n    return col;\n}\n\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tfloat e = 1.0 / iResolution.x;\n\tvec2 uv = fragCoord / iResolution.x;\n    \n  \n    vec2 path[NUM];\n    vec3 col = vec3(0.8, 0.7, 0.5) + uv.y * 0.7 - uv.x * 0.1;\n\n    //------------------------------------------------------\n    // path\n    //------------------------------------------------------\n    {\n        float x = (0.5+0.5*sin(iTime*4.) ) * 0.1;\n        float x2 = (0.5+0.5*sin(3.14 + iTime*4.) ) * 0.1;\n\t    vec2 an = vec2(x, 0.);\n\t    vec2 an2 = vec2(x2, 0.);\n\t    vec2 anh = vec2(0., x) * 0.1;\n\n        int i = 0;\n        path[i++] = vec2( 0.12, 0.55 ) + an2 * 0.1;\n        path[i++] = vec2( 0.13, 0.48 ) + an * 0.1;\n        path[i++] = vec2( 0.1, 0.32 ) + an2 * 0.2;\n        path[i++] = vec2( 0.3, 0.11 ) + an2;\n        path[i++] = vec2( 0.25, 0.15 ) + an2 * 0.5;\n        path[i++] = vec2( 0.3, 0.3 );\n        path[i++] = vec2( 0.18, 0.35 );\n        path[i++] = vec2( 0.08, 0.1 ) + an;\n        path[i++] = vec2( 0.11, 0.23 ) + an * 0.5;\n        path[i++] = vec2( 0.3, 0.22 );\n        path[i++] = vec2( 0.45, 0.21 );\n        path[i++] = vec2( 0.57, 0.1 ) + an * 0.5;\n        path[i++] = vec2( 0.5, 0.14 ) + an * 0.2;\n        path[i++] = vec2( 0.45, 0.18 ) + an * 0.2;\n        path[i++] = vec2( 0.43, 0.28 ) + anh;\n        path[i++] = vec2( 0.5, 0.35 ) + anh;\n        path[i++] = vec2( 0.59, 0.33 ) + anh;\n        path[i++] = vec2( 0.68, 0.37 ) + anh;\n        path[i++] = vec2( 0.64, 0.32 ) + anh;\n        path[i++] = vec2( 0.65, 0.25 ) + anh;\n        path[i++] = vec2( 0.59, 0.25 ) + anh;\n        path[i++] = vec2( 0.59, 0.31 ) + anh;\n        path[i++] = vec2( 0.63, 0.27 ) + anh;\n        path[i++] = vec2( 0.5, 0.22 ) + an2 * 0.2;\n        path[i++] = vec2( 0.45, 0.1 ) + an2;\n        path[i++] = vec2( 0.7, -0.1 );\n    }\n    \n\t//------------------------------------------------------\n\t// draw path\n\t//------------------------------------------------------\n    \n\tcol *= catmullRom(path, uv);\n\tfor (int i = 0; i < (NUM - 1); i++) {\n      path[i].x += sin(float(i))*0.01;\n      path[i].y += sin(float(i+5))*0.01;\n    }\n\tcol *= mix(0.8, 1., catmullRom(path, uv).x);\n\n    col = draw(col, sdSegmentSq(uv, vec2(0.1, 0.11), vec2(0.8, 0.12)));\n    col = draw(col, sdSegmentSq(uv, vec2(0.05, 0.05), vec2(0.75, 0.06)));\n    \n\tfragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}