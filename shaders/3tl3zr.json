{
    "Shader": {
        "info": {
            "date": "1555521974",
            "description": "Trying out ray marching",
            "flags": 0,
            "hasliked": 0,
            "id": "3tl3zr",
            "likes": 3,
            "name": "sun-earth-moon",
            "published": 3,
            "tags": [
                "raymarching",
                "planets",
                "solarsystem"
            ],
            "usePreview": 0,
            "username": "kapusta",
            "viewed": 543
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 3000\n#define MAX_DIST 5000.0\n#define HIT_DIST 0.01\n\n#define SUN_SIZE 50.\n#define AMBIENT_LIGHT 0.1\n\n#define MOUSE_SENS 0.2\n\n#define PI 3.1415926535\n\nmat2 rotate2(float a){\n\treturn mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nmat3 rotate3(float a)\n{\n\treturn mat3(cos(a), 0., sin(a), 0., 1., 0., -sin(a), 0., cos(a));\n}\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 dir;\n    bool hit;\n};\n    \nRay CreateRay(vec3 origin, vec3 dir)\n{\n\tRay ray;\n    ray.origin = origin;\n    ray.dir = dir;\n    ray.hit = false;\n    \n    return ray;\n}\n\nfloat dSphere(vec3 p)\n{\n\treturn length(p) - 1.;\n}\n\nfloat moon(vec3 p)\n{\n  \treturn 0.016*exp(cos(p.x)+cos(p.y)+cos(p.z)+3.) + 0.008*exp(cos(p.x+PI)+cos(p.y+PI)+cos(p.z+PI)+3.);\n}\n\nfloat earth(vec3 p)\n{\n\treturn cos(p.x * 0.3) * cos(p.y * 0.3) * cos(p.z * 0.3) * 1.1;\n}\n\nint hitIndex;\nvec3 colors[3] = vec3[](\n    vec3(0.),\n\tvec3(.51, .76, .94),\n    vec3(.7, .76, .8)\n);\n\nfloat minSunDist = 1./0.;\n\nfloat getDist(vec3 rp)\n{\n    \n    float d0 = dSphere(-rp / SUN_SIZE) * SUN_SIZE;\n    minSunDist = min(d0, minSunDist);\n    \n    vec3 p0 = vec3(150., 0., 0.) * rotate3(iTime*1.) - rp;\n    float d1 = dSphere(p0 / 20.) * 20. + earth(p0 * 1.);\n    \n    vec3 p1 = p0 + vec3(30., 0., 0.) * rotate3(iTime * 1.5);\n    float d2 = dSphere(p1 / 10.) * 10.+ moon(p1);\n    \n    float m = min(min(d0, d1), d2);\n    \n    if(m == d0)hitIndex = 0;\n    else if(m == d1)hitIndex = 1;\n    else hitIndex = 2;\n    \n    return m;\n}\n\nvec3 getNormal(vec3 rp)\n{      \n    float dist = getDist(rp);\n    \n    vec2 offset = vec2(0.01, 0.0);   \n    vec3 n = vec3(getDist(rp + offset.xyy),\n                  getDist(rp + offset.yxy),\n                  getDist(rp + offset.yyx));\n    \n    return normalize(n - dist);\n}\n\nRay rayMarch(vec3 origin, vec3 dir)\n{\n    vec3 nDir = normalize(dir);\n    Ray ray = CreateRay(origin, nDir);\n    \n    float td = 0.;\n    \n   \tfor(int s = 0;s < MAX_STEPS && td < MAX_DIST;++s)\n   \t{   \n        float d = getDist(ray.origin + ray.dir);\n        \n        td += d;\n        \n  \t\tray.dir += nDir * d * 0.5;\n        \n        if(d < HIT_DIST)\n        {          \n            ray.hit = true;\n            return ray;\n        }\n   \t}\n    \n   \treturn ray;\n}\n\nfloat shadow(vec3 pos)\n{\n\tRay ray = rayMarch(pos, -pos);\n    \n    return step(length(pos) - SUN_SIZE - 1., length(ray.dir));\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(100.989,78.233))) * 44308.5453);\n}\n\nvec3 stars(vec3 dir)\n{   \n    vec2 uv = (asin(dir.z) + PI*0.5)/(PI * length(dir.xy)) * dir.xy * 40.;\n    float r = rand(floor(uv));\n    \n    uv = (fract(uv)*2. - 1.) * 1.2;\n    \n    float a = 0.5;\t\n    float d = pow(pow(abs(uv.x), a) + pow(abs(uv.y), a), 1./a);\n    \n\treturn vec3((1. - min(d, 1.)) * step(r, 0.05)) * vec3(220, 234, 232) / 255.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.x;\n    \n    float time = mod(float(iTime), 100.0);\n    \n    vec3 viewDir = normalize(vec3(uv, -1.0));\n    viewDir.xz *= rotate2((1. - 2. * iMouse.x / iResolution.x) * PI * MOUSE_SENS);\n    viewDir.yz *= rotate2((1. - 2. * iMouse.y / iResolution.y) * PI * MOUSE_SENS + .3);\n    \n    Ray ray = rayMarch(vec3(0.0, 150.0, 220.0), viewDir);\n    vec3 rayPos = ray.origin + ray.dir;\n    \n    fragColor.rgb = colors[hitIndex];\n    \n    float glow = max(1. - minSunDist / 30., 0.0);\n    \n   \tif(ray.hit && hitIndex > 0)\n    {        \n        vec3 normal = getNormal(rayPos);\n        vec3 toLight = normalize(-rayPos);\n            \n        float illumination = shadow(rayPos);\n        \n        illumination *= dot(normal, toLight);\n        illumination += AMBIENT_LIGHT;\n\n        fragColor.rgb *= illumination;  \n    }\n    else{        \n        fragColor.rgb = AMBIENT_LIGHT + stars(viewDir); \n    }\n    \n    fragColor.rgb += vec3(252, 226, 156) / 255. * min(glow*glow*2., 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}