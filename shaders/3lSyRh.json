{
    "Shader": {
        "info": {
            "date": "1593638332",
            "description": "Derp",
            "flags": 0,
            "hasliked": 0,
            "id": "3lSyRh",
            "likes": 23,
            "name": "Socolar-C5-var tiling [Day 194]",
            "published": 3,
            "tags": [
                "tiling",
                "aperiodic",
                "mdtmjvm",
                "socolar"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 512
        },
        "renderpass": [
            {
                "code": "// This is Socolar-C5 but with mirror simmetry added in the first rule\n\n// Mostly mathematically correct with some number crunching (about 20%) \n// https://tilings.math.uni-bielefeld.de/substitution/socolar-c5/\n\n// Substitution tilings are super fun stuff\n// Although they may seem a bit intimidating, because they,\n// I think starting one from scratch is a good way to get started,\n// because code can get... uh... convoluted, like here.\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n\nfloat sdEquilateralTriangle(  vec2 p, float r ){   \n    r = r*1./3.;\n\tp.y -= r;\n    p.y += r*1.5;\n    float d = dot(vec2(abs(p.x),p.y) - -normalize(vec2(0.,1)*rot(tau/3.))*(r), -normalize(vec2(0.,1)*rot(tau/3.)));\n    d = max(d,p.y - r*2.);\n    d = max(d,-p.y - r);\n    return d;\n}\n\nfloat sdRhombus( vec2 p, float height, float angleHoriz, float angleVert ){\n\n    float hypothenuse = sin(pi/2.)*height*0.5/sin(angleHoriz/2.);\n    float base = sin( angleVert/2.)*hypothenuse/sin(pi/2.);\n\t\n    float triarea = height*0.5*base*0.5;\n    float triheight = triarea*2./hypothenuse;\n    \n    float triAngle = asin(triheight*sin(pi/2.)/base);\n    vec2 hdir = vec2(0.,1.)*rot(-triAngle);\n    p = abs(p);    \n    p -= normalize(hdir)*triheight/1.;\n    \n\treturn dot(p,vec2(0.,1.)*rot( -triAngle));\n}\n        \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\t\n    \n    vec3 col = vec3(0);\n    \n    \n    float id = 0.;\n    float iters = 5.;\n    \n    float d = 10e5;\n    \n    float s = 1.;\n\n    uv += vec2(sin(iTime/2.6  + cos(iTime/4.)),cos(iTime/2. + sin(iTime/4.)))*0.2;    \n    uv *= 0.7;\n    \n    \n    vec2 p = uv;\n    float sc = 1.;\n    \n    float palvar = 1.;\n    \n    float lside = 2.;\n    float lsplithoriz = 2.35 ; // 2.35 is totally crunched\n    \n    \n    float avert = 2.*( asin( lsplithoriz*0.5*sin(pi/2.)/lside) );\n    float ahoriz = (tau - 2.*avert)/2.;\n    \n    float ahorizb = avert/2.;\n    float avertb = (tau - ahorizb*2.)/2.;\n    \n    float lsplitvert = 2.*sin(ahoriz/2.)*lside/sin(pi/2.);\n    \n    float ratiosidevert = lside/(lside + lsplitvert);\n    \n    float ratiohorizvert = lsplithoriz/(lsplithoriz + lsplitvert);\n    \n    float lsidesmall = lside * ratiosidevert;\n    \n    float lsplitvertsmall = lside - lsidesmall;\n    \n    float lsplithorizsmall = lsplitvertsmall*ratiohorizvert;\n    float lsplitvertb = lsplitvertsmall*1./2.62; // last minute crunch from 2.6 to 2.62?\n    \n    \n    for(float i = 0.; i < iters; i++){\n    \tfloat Llside = lside * sc;\n    \t\n        float Llsplithoriz = lsplithoriz * sc;\n    \n        float Llsplitvert = lsplitvert * sc;\n    \n    \tfloat Lratiosidevert = ratiosidevert * sc;\n    \n    \tfloat Lratiohorizvert = ratiohorizvert * sc;\n    \n    \tfloat Llsidesmall = lsidesmall * sc;\n    \n    \tfloat Llsplitvertsmall = lsplitvertsmall * sc;\n    \n    \tfloat Llsplithorizsmall = lsplithorizsmall * sc;\n    \n    \tfloat Llsplitvertb = lsplitvertb * sc;\n        \n        if(id == 0.){\n        \tfloat drh = sdRhombus(p, Llsplitvert, ahoriz, avert );\n        \n            vec2 pb = p + vec2(0,Llsplitvert*0.5 - Llsplitvertsmall/2.);\n\n            float drhb = sdRhombus(pb, Llsplitvertsmall, ahoriz, avert );\n\n            p.x = abs(p.x);\n            vec2 pc = p + vec2(0. - Llsplithoriz*0.5, - Llsplitvertsmall*0.5);\n            pc.y += Llsplitvertsmall*0.495; // some crunch here\n            mat2 pcr = rot(avert*0.5*6.); \n            pc *= pcr;\n            pc.y -= Llsplitvertsmall*0.503;\n            float drhc = sdRhombus( pc, Llsplitvertsmall, ahoriz, avert );\n\n            vec2 pd = p + vec2(0. - Llsplithoriz*0.5, - Llsplitvertsmall*0.5);\n            pd.y += Llsplitvertsmall*0.5;\n            mat2 pdr = rot(-avert/1.);\n            pd *= pdr;\n            pd.y -= Llsplitvertsmall*0.5;\n\n            float drhd = sdRhombus( pd, Llsplitvertsmall, ahoriz, avert );\n\n            vec2 pe = p + vec2(0. - Llsplithoriz*0.5, - Llsplitvertsmall*0.5);\n            pe.y += Llsplitvertsmall*0.5;\n            mat2 per = rot(-avert/1.);\n            pe *= per;\n            pe.y -= Llsplitvertsmall*1.;\n\n            pe.x -= Llsplithorizsmall*0.862;\n\n            float drhe = sdRhombus( pe, Llsplitvertsmall, ahoriz, avert );\n\n            \n            vec2 pba = p;\n            pba.x -= Llsplitvertb/2.125;\n            pba.y += Llsplitvertb/1.55;\n\n            pba *= rot(ahoriz/1.5);\n                        \n            float drhba = sdRhombus( pba, Llsplitvertb, ahorizb, avertb );\n\n\n\n\n            d = min(d, abs(drh));\n            d = min(d, abs(drhb));\n            d = min(d, abs(drhc));\n            d = min(d, abs(drhd));\n            d = min(d, abs(drhe));\n            d = min(d, abs(drhba));\n            \n\n            if (drhb < 0.) {\n                p = pb;\n            } else if (drhc < 0.) {\n                p = pc;\n            } else if (drhd < 0.) {\n                p = pd;\n            } else if (drhe < 0.) {\n                p = pe;\n            } else if (drhba < 0.) {\n                p = pba;\n            } else {\n                break;\n            }\n\n            if ( drhb < 0. || drhc < 0. || drhd < 0. || drhe < 0. ){\n\t\t\t\tid = 0.;\n                palvar += 0.4;\n            } else {\n                palvar += 2.1;\n\t\t\t\tid = 1.;\n\t\t\t}\n            sc *= lsplitvertsmall/lsplitvert;\t\n        } else if (id == 1.) {\n            \n            p *= rot(1.*pi);\n            \n            p.y = abs(p.y);\n            //p*=0.5;\n            vec2 pa = p*1.;\n            float dra = sdRhombus( pa, Llsplitvertb, ahorizb, avertb );\n\t\t\t\n            vec2 pb = p;\n            float drb = sdRhombus( pb, Llsplitvertsmall, ahoriz, avert );\n            \n            \n            vec2 pc = p;\n            pc.y += 0.5*Llsplitvertsmall;\n            pc *= rot(avert);\n            pc.y -= 0.5*Llsplitvertsmall;\n            float drc = sdRhombus( pc, Llsplitvertsmall, ahoriz, avert );\n\n            vec2 pd = pc;\n            pd.y -= 0.62*Llsplitvertsmall;\n            \n            pd.y -= 0.5*Llsplitvertsmall;\n            pd *= rot(avert/2.);\n            \n            pd.y += 0.5*Llsplitvertsmall;\n            \n            float drd = sdRhombus( pd, Llsplitvertsmall, ahoriz, avert );\n\n            vec2 pe = pc;\n            \n            pe.y -= 0.5*Llsplitvertsmall;\n            \n            pe *= rot(-ahorizb);\n            //pe.x += Llsplithorizb*lsplithorizsmall/lsplithoriz/0.75;\n            pe.x += 0.58*Llsplitvertsmall;\n            \n            float dre = sdRhombus( pe, Llsplitvertb, ahorizb, avertb );\n\n            vec2 pf = p;\n            \n            pf.y -= 0.505*Llsplitvertsmall;\n            pf *= rot(-ahorizb);\n            \n            pf.x += 0.58*Llsplitvertsmall;\n            \n            //pe.x += Llsplithorizb*lsplithorizsmall/lsplithoriz/0.75;\n            //pe.x += 0.58*Llsplitvertsmall*lsplitvertsmall/lsplitvert;\n            \n            float drf = sdRhombus( pf, Llsplitvertb, ahorizb, avertb );\n\n            \n\t\t\t\n            //d = min(d, abs(dra));\n            \n            d = min(d, abs(drb));\n            d = min(d, abs(drc));\n            d = min(d, abs(drd));\n            d = min(d, abs(dre));\n            d = min(d, abs(drf));\n            \n            \n\t\t\tif (drb < 0.) {\n                p = pb;\n            } else if (drc < 0.) {\n                p = pc;\n            } else if (drd < 0.) {\n                p = pd;\n            } else if (dre < 0.) {\n                p = pe;\n            } else if (drf < 0.) {\n                p = pf;\n            } else  {\n                break;\n            }\n\n            if ( drb < 0. || drc < 0. || drd < 0.){\n\t\t\t\tid = 0.;\n                palvar += 1.1;\n            } else if ( dre < 0. || drf < 0.) {\n\t\t\t\tid = 1.;\n                palvar += 2.1;\n            } else {\n            \tbreak;\n            }\n            sc *= lsplitvertsmall/lsplitvert;\n            \n            \n        }\n            \n    }\n    \n    \n    #define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n    \n    col = mix(col,pal(0.5,0.56,vec3(3.,0.7,0.2),3.4, palvar + iTime + uv.x/2. + uv.y/2.)/1.,smoothstep(dFdx(uv.x),0.,-d));\n    \n    //col = mix(col,pal(0.5,0.56,vec3(2.,0.7,0.2),1., palvar + iTime + uv.x*2. + uv.y*2.)/1.,smoothstep(dFdx(uv.x),0.,-d));\n    \n    \n    d = abs(d);\n    \n    float w = 0.0002;\n    col = mix(col,vec3(0.04),smoothstep(dFdx(uv.x) + w, w,d));\n    \n    \n    col = pow(col,vec3(0.454545));\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}