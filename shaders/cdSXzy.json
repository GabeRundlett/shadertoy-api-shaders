{
    "Shader": {
        "info": {
            "date": "1670435579",
            "description": "Black body temperature to RGB.\n\nThe hotter it is, the more it tends to blue",
            "flags": 0,
            "hasliked": 0,
            "id": "cdSXzy",
            "likes": 3,
            "name": "Blackbody Temperature To RGB",
            "published": 3,
            "tags": [
                "vector",
                "wavelength",
                "linearalgebra",
                "calculus",
                "researchpaper"
            ],
            "usePreview": 0,
            "username": "Remming_Senegal",
            "viewed": 227
        },
        "renderpass": [
            {
                "code": "// a VERY SPECIAL THANKS to this research paper:\n// https://www.fourmilab.ch/documents/specrend/\n// Needless to say this shader used so many pieces of that paper that this shader is basically a ripoff of all that work\n// I learned alot though! Will use this somewhere!\n\n#define LAMBDA_RED 780.0\n#define LAMBDA_VIOLET 380.0\n\n#define NMTOM(a) (a)*pow(10.0,-9.0)\n#define MTONM(a) (a)*pow(10.0,+9.0)\n\nconst mat3 NTSC_Chromaticity = \nmat3(\n    0.67, 0.21, 0.14,\n    0.33, 0.71, 0.08,\n    0.00, 0.08, 0.78\n);\nconst vec3 NTSC_White = vec3 (0.3101,0.3162, 1.0 - (0.3101 + 0.3162) );\n\n// Calculate spectra of a blackbody when a given wavelength is plugged into it\nfloat bb_spectrum(float wavelength, float bbTemp)\n{\n    float wlm = NMTOM(wavelength);\n\n    return (3.74183e-16 * pow(wlm, -5.0)) / (exp(1.4388e-2 / (wlm * bbTemp)) - 1.0);\n}\n\nvec3 XYZ(float bbTemp) {\n\n    // delta lambda is equal to 5nm\n    // stolen from https://www.fourmilab.ch/documents/specrend/\n    const int cie_colour_match_length = 81;\n    vec3 cie_colour_match[81] = vec3[](\n        vec3(0.0014,0.0000,0.0065), vec3(0.0022,0.0001,0.0105), vec3(0.0042,0.0001,0.0201),\n        vec3(0.0076,0.0002,0.0362), vec3(0.0143,0.0004,0.0679), vec3(0.0232,0.0006,0.1102),\n        vec3(0.0435,0.0012,0.2074), vec3(0.0776,0.0022,0.3713), vec3(0.1344,0.0040,0.6456),\n        vec3(0.2148,0.0073,1.0391), vec3(0.2839,0.0116,1.3856), vec3(0.3285,0.0168,1.6230),\n        vec3(0.3483,0.0230,1.7471), vec3(0.3481,0.0298,1.7826), vec3(0.3362,0.0380,1.7721),\n        vec3(0.3187,0.0480,1.7441), vec3(0.2908,0.0600,1.6692), vec3(0.2511,0.0739,1.5281),\n        vec3(0.1954,0.0910,1.2876), vec3(0.1421,0.1126,1.0419), vec3(0.0956,0.1390,0.8130),\n        vec3(0.0580,0.1693,0.6162), vec3(0.0320,0.2080,0.4652), vec3(0.0147,0.2586,0.3533),\n        vec3(0.0049,0.3230,0.2720), vec3(0.0024,0.4073,0.2123), vec3(0.0093,0.5030,0.1582),\n        vec3(0.0291,0.6082,0.1117), vec3(0.0633,0.7100,0.0782), vec3(0.1096,0.7932,0.0573),\n        vec3(0.1655,0.8620,0.0422), vec3(0.2257,0.9149,0.0298), vec3(0.2904,0.9540,0.0203),\n        vec3(0.3597,0.9803,0.0134), vec3(0.4334,0.9950,0.0087), vec3(0.5121,1.0000,0.0057),\n        vec3(0.5945,0.9950,0.0039), vec3(0.6784,0.9786,0.0027), vec3(0.7621,0.9520,0.0021),\n        vec3(0.8425,0.9154,0.0018), vec3(0.9163,0.8700,0.0017), vec3(0.9786,0.8163,0.0014),\n        vec3(1.0263,0.7570,0.0011), vec3(1.0567,0.6949,0.0010), vec3(1.0622,0.6310,0.0008),\n        vec3(1.0456,0.5668,0.0006), vec3(1.0026,0.5030,0.0003), vec3(0.9384,0.4412,0.0002),\n        vec3(0.8544,0.3810,0.0002), vec3(0.7514,0.3210,0.0001), vec3(0.6424,0.2650,0.0000),\n        vec3(0.5419,0.2170,0.0000), vec3(0.4479,0.1750,0.0000), vec3(0.3608,0.1382,0.0000),\n        vec3(0.2835,0.1070,0.0000), vec3(0.2187,0.0816,0.0000), vec3(0.1649,0.0610,0.0000),\n        vec3(0.1212,0.0446,0.0000), vec3(0.0874,0.0320,0.0000), vec3(0.0636,0.0232,0.0000),\n        vec3(0.0468,0.0170,0.0000), vec3(0.0329,0.0119,0.0000), vec3(0.0227,0.0082,0.0000),\n        vec3(0.0158,0.0057,0.0000), vec3(0.0114,0.0041,0.0000), vec3(0.0081,0.0029,0.0000),\n        vec3(0.0058,0.0021,0.0000), vec3(0.0041,0.0015,0.0000), vec3(0.0029,0.0010,0.0000),\n        vec3(0.0020,0.0007,0.0000), vec3(0.0014,0.0005,0.0000), vec3(0.0010,0.0004,0.0000),\n        vec3(0.0007,0.0002,0.0000), vec3(0.0005,0.0002,0.0000), vec3(0.0003,0.0001,0.0000),\n        vec3(0.0002,0.0001,0.0000), vec3(0.0002,0.0001,0.0000), vec3(0.0001,0.0000,0.0000),\n        vec3(0.0001,0.0000,0.0000), vec3(0.0001,0.0000,0.0000), vec3(0.0000,0.0000,0.0000)\n    );\n    \n    vec3 xyz = vec3(0.0);\n    float lambda = LAMBDA_VIOLET;\n    int i = 0;\n    while(lambda <= LAMBDA_RED) {\n        // get the specular intensity of the color matching function\n        float spec_intens = bb_spectrum(lambda,bbTemp);\n        xyz += spec_intens*cie_colour_match[i];\n        i++;\n        lambda += 5.0;\n    }\n    \n    return xyz;\n}\n\nvec3 ChromaticityValue(vec3 CIE) {\n    float x = CIE.x / (CIE.x + CIE.y + CIE.z);\n    float y = CIE.y / (CIE.x + CIE.y + CIE.z);\n    float z = CIE.z / (CIE.x + CIE.y + CIE.z);\n    \n    return vec3(x,y,z);\n}\n\nvec3 constrainRGB(vec3 col) {\n    vec3 ret = col;\n    float w = -min(0.0, min(col.r,min(col.g,col.b)));\n    \n    w = (0.0 < col.r) ? 0.0 : col.r;\n    w = (0.0 < col.g) ? w : col.g;\n    w = (0.0 < col.b) ? w : col.b;\n    w = -w;\n    \n    if(w > 0.0) {\n        ret.r += w;\n        ret.g += w;\n        ret.b += w;\n    }\n    \n    return ret;\n}\n\nvec3 normalizeRGB(vec3 col) {\n#define MAX(a , b) ((a) > (b)) ? (a) : (b)\n    float greatest = MAX(col.r, MAX(col.g, col.b));\n    \n    if(greatest > 0.0) {\n        return col/greatest;\n    }\n    \n    return col;\n\n}\n\nvec3 getJVector(vec3 w, mat3 table, vec3 xyz) {\n    // linear algebra moment\n    \n    float xc = xyz.x;\n    float yc = xyz.y;\n    float zc = xyz.z;\n\n    float xr, yr, zr, xg, yg, zg, xb, yb, zb;\n    float xw, yw, zw;\n    float rx, ry, rz, gx, gy, gz, bx, by, bz;\n    float rw, gw, bw;\n    \n    // values from table\n    xr = table[0][0];\n    yr = table[1][0];\n    zr = 1.0 - (xr + yr);\n    \n    xg = table[0][1];\n    yg = table[1][1];\n    zg = 1.0 - (xg + yg);\n    \n    xb = table[0][2];\n    yb = table[1][2];\n    zb = 1.0 - (xb + yb);\n    \n    // white values\n    xw = w.x;\n    yw = w.y;\n    zw = w.z;\n    \n    // More declarations\n    rx = (yg * zb) - (yb * zg);  ry = (xb * zg) - (xg * zb);  rz = (xg * yb) - (xb * yg);\n    gx = (yb * zr) - (yr * zb);  gy = (xr * zb) - (xb * zr);  gz = (xb * yr) - (xr * yb);\n    bx = (yr * zg) - (yg * zr);  by = (xg * zr) - (xr * zg);  bz = (xr * yg) - (xg * yr);\n    \n    // Declaring the white factor\n    rw = ((rx * xw) + (ry * yw) + (rz * zw)) / yw;\n    gw = ((gx * xw) + (gy * yw) + (gz * zw)) / yw;\n    bw = ((bx * xw) + (by * yw) + (bz * zw)) / yw;\n    \n    // scale by the white factor\n    rx = rx / rw;  ry = ry / rw;  rz = rz / rw;\n    gx = gx / gw;  gy = gy / gw;  gz = gz / gw;\n    bx = bx / bw;  by = by / bw;  bz = bz / bw;\n    \n    float r = (rx * xc) + (ry * yc) + (rz * zc);\n    float g = (gx * xc) + (gy * yc) + (gz * zc);\n    float b = (bx * xc) + (by * yc) + (bz * zc);\n    \n    return vec3(r,g,b);\n}\n\n// The almighty\nvec3 getRGB(float bbTemp) {\n    vec3 cc = XYZ(bbTemp);\n    \n    vec3 col = ChromaticityValue(cc);\n    \n    vec3 J = getJVector(NTSC_White, NTSC_Chromaticity, col);\n    \n    vec3 constrained = constrainRGB(J);\n    \n    vec3 n = normalizeRGB(constrained);\n    \n    return n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Left side of the screen is RGB at 1000 Kelvin\n    // Right side of the screeen is RGB at 10000 Kelvin\n    uv.x *= 9000.0;\n    uv.x += 1000.0;\n    \n    vec3 col = getRGB(uv.x);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}