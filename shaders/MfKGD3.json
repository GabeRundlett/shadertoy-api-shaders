{
    "Shader": {
        "info": {
            "date": "1713373136",
            "description": "Use the mouse to look around",
            "flags": 0,
            "hasliked": 0,
            "id": "MfKGD3",
            "likes": 9,
            "name": "Road with boxes",
            "published": 3,
            "tags": [
                "ray",
                "raymarch",
                "rays",
                "road",
                "march",
                "boxes"
            ],
            "usePreview": 1,
            "username": "ianertson",
            "viewed": 221
        },
        "renderpass": [
            {
                "code": "#define R iResolution.xy\n#define T (iTime)\n#define M_PI 3.14159265358979323846264338327950288\n#define TAU (M_PI*2.0)\n#define FUI floatBitsToUint\n#define ZERO min(0, iFrame)\n\nmat2 rot(float a) { float s = sin(a); float c = cos(a); return mat2(c, s, -s, c); }\nvec3 aces(vec3 x) { return clamp((x*(2.51*x+0.03))/(x*(2.43*x+0.59)+0.14),0.0,1.0); }\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\nfloat smin(float a, float b, float k) {float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0); return mix(a, b, h) - k*h*(1.0-h); }\nfloat smax(float a, float b, float k) {return smin(a, b, -k); }\nfloat sabs(in float v, in float k) {return smax(-v, v, k);}\nfloat sclamp(in float v, in float mi, in float ma, in float k) {return smin(smax(v, mi, k), ma, k);}\nfloat sgt(in float a, in float b, in float s) {float h = clamp(0.5 + 0.5 * (a - b) / s, 0.0, 1.0); return mix(0.0, 1.0, h*h*(3.0-2.0*h));}\nfloat slt(in float a, in float b, in float s) {float h = clamp(0.5 + 0.5 * (b - a) / s, 0.0, 1.0); return mix(0.0, 1.0, h*h*(3.0-2.0*h));}\n\n\nvec3 thash(vec2 p, float seed) {\n    return textureLod(iChannel0, ((p  + seed) / 256.0), 0.0).xyz;\n}\n\nvec3 tnoise(vec2 p, float s) {\n  p += 3.3828714;\n  vec2 id = floor(p); vec2 lv = fract(p);lv = lv*lv*(3.0-2.0*lv);\n  return mix(mix(thash(id+vec2(0,0),s),thash(id+vec2(1,0),s),lv.x),\n             mix(thash(id+vec2(0,1),s),thash(id+vec2(1,1),s),lv.x),lv.y);\n}\n\nvec3 tnoise(vec2 p, float s, float freq, float warp, const in int oct) {\n  vec3 n = vec3(0.0);\n  float div = 0.0;\n  float amp = 1.0;\n  vec2 tx = vec2(0.0);\n  for (int i = ZERO; i < oct; i++) {\n    n += amp*tnoise((p+tx)*freq,s);\n    div += amp;\n    amp *= 0.5;\n    freq *= 2.0;\n    tx += warp * vec2(sin(n.x*6.28), cos(n.y*6.28));\n\n  }\n  return n / div;\n}\n\nfloat hash(vec2 ip, float seed) {\n  uvec2 p = FUI(ip); uint s = FUI(seed); uvec2 k = ~p + ~s;\n  p ^= p << 17U; p ^= p >> 13U; p ^= p << 5U;\n  p += (p ^ k) + p * k; p *= 1013U; p ^= (p >> 4U);\n  return float(p.x * k.y + p.y + p.y * k.x + k.y) / float(0xFFFFFFFFU);\n}\n\nfloat noise(vec2 p, float s) {\n  p += 3.3828714;\n  vec2 id = floor(p); vec2 lv = fract(p);lv = lv*lv*(3.0-2.0*lv);\n  return mix(mix(hash(id+vec2(0,0),s),hash(id+vec2(1,0),s),lv.x),\n             mix(hash(id+vec2(0,1),s),hash(id+vec2(1,1),s),lv.x),lv.y);\n}\n\nfloat noise(vec2 p, float s, float freq, float warp, const in int oct) {\n  float n = 0.0;\n  float div = 0.0;\n  float amp = 1.0;\n  vec2 tx = vec2(0.0);\n  for (int i = ZERO; i < oct; i++) {\n    n += amp*noise((p+tx)*freq,s);\n    div += amp;\n    amp *= 0.5;\n    freq *= 2.0;\n    tx += warp * vec2(sin(n*6.28), cos(n*6.28));\n\n  }\n  return n / div;\n}\n\n#define NEAR 0.003\n#define FAR 90.0\n#define STEPS 90\n#define SHADOW_STEPS 32\n\nstruct Data {\n    vec3 p;\n    vec3 n;\n    float d;\n    int id;\n};\n\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), FAR, -1)\n\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n\nstruct Light {\n    vec3 p;\n    vec3 c;\n    float s;\n    int t;\n};\n\nvec3 getLightDir(Light light, vec3 p) {\n    switch (light.t) {\n        case LIGHT_POINT: return normalize(p - light.p); break;\n        case LIGHT_AMBIENT: return normalize(light.p); break;\n    }\n    \n    return normalize(p - light.p);\n}\n\nvec3 getLightAtt(Light light, vec3 p, vec3 n) {\n    vec3 L = getLightDir(light, p);\n    float NdotL = max(0.0, dot(n, L));\n    \n    switch (light.t) {\n        case LIGHT_POINT: {\n            float dist = distance(light.p, p);\n            return (NdotL * light.s * light.c) / max(0.003, dist*dist);\n        } break;\n        default:\n        case LIGHT_AMBIENT: {\n            return (NdotL * light.s * light.c);\n        }; break;\n    }\n    \n    return vec3(1.0);\n}\n\nfloat boxSDF(vec3 p, vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.0)) + min(0.0, max(p.x, max(p.y, p.z)));\n}\n\nfloat groundSDF(vec3 p) {\n    if (p.y >= 10.003) return p.y;\n    vec3 n1 = tnoise(p.xz*4., 2.23918, 0.05, 0.1, 3);\n    float h1 = n1.x;\n    \n    //float h1 = noise(p.xz, 2.23918, 0.05, 0.1, 3);\n    float h = h1;\n    \n    h *= smoothstep(8.0, 20.0, abs(p.x));\n    \n    h *= 10.;\n    return p.y - h;\n}\n\nfloat roadSDF(vec3 p) {\n    float w = 6.0;\n    float h = 1.;\n    p.y += 0.9999999*h;\n    return max(abs(p.y)-1.5*h, abs(p.x)-w);\n}\n\n#define ID_GROUND 0\n#define ID_BOX 1\n#define ID_ROAD 2\n\n#define SAMPLE(_dist, _id) { if (_dist < dist) { dist = _dist; id = _id; } }\n\nfloat sdf(vec3 p, inout Data data) {\n    int id = -1;\n    float dist = FAR;\n    \n    float ground = groundSDF(p);\n    float road = roadSDF(p);\n    ground = smax(ground, -road, 0.2);\n    //float box = boxSDF(p - vec3(0, 1., 0.2), vec3(1.0));\n    \n    SAMPLE(ground, ID_GROUND)\n    SAMPLE(road, ID_ROAD);\n    //SAMPLE(box, ID_BOX);\n    \n    float freqZ = 4.0;\n    float freqX = 3.0;\n    float zid = floor((p.z) / freqZ);\n    float xid = floor((p.x)/ freqX);\n    float px = p.x;\n    p.z = mod(p.z, freqZ);\n    p.x = mod(p.x, freqX);\n    float r1 = hash(vec2(xid, zid), 3.2132);\n    \n    \n    \n    if (round(r1-0.2) > 0.9 && abs(px) <= 6.0) {\n        float boxSize = mix(0.1, 0.4, fract(r1*10.289128));\n        float box = boxSDF(p - vec3(freqX*0.5, boxSize+0.5+0.12, freqZ*0.5), vec3(boxSize))-0.1;\n        box /= 1.4;\n        SAMPLE(box, ID_BOX);\n    }\n    \n    data.id = id;\n    \n    return dist;\n}\n\nbool march(in vec3 ro, in vec3 rd, inout Data data) {\n    data.d = FAR;\n    float d = 0.0;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(p, data);\n        if (next <= (NEAR * (1.0 + abs(d)))) break;\n        if (next >= FAR) return false;\n        d += next;\n    }\n    \n    vec3 p = ro+rd*d;\n    vec2 e = vec2(NEAR, 0.0);\n    vec3 n = normalize(sdf(p, data) - vec3(\n        sdf(p - e.xyy, data),\n        sdf(p - e.yxy, data),\n        sdf(p - e.yyx, data)\n    ));\n    \n    data.n = n;\n    data.p = p;\n    data.d = d;\n    \n    return true;\n}\n\nfloat getShadow(Light light, vec3 ro, vec3 n) {\n    Data data = NEW_DATA;\n    data.d = FAR;\n    float d = NEAR*2.0;\n    vec3 rd = getLightDir(light, ro);\n    float NdotL = dot(n, rd);\n    \n    if (NdotL < NEAR*2.) return 0.0;\n    \n    \n    for (int i = ZERO; i < SHADOW_STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(p, data);\n        d += clamp(next, 0.009, 1.0);\n    }\n    \n    return d / (1.0 + d);\n}\n\n\n\n//#define DEBUG_TEXTURE getAlbedoGround\n\nvec3 getAlbedoGround(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec3 p = data.p;\n    vec2 uv = data.p.xz;\n    \n    vec3 n1 = tnoise(uv*16., 3.3912);\n    vec3 n2 = tnoise(uv*4., 55.4924);\n    \n    float grain1 = n1.x;//noise(uv*16., 3.3912);\n    float grain2 = n1.y;//noise(uv*8., 66.698438);\n    float grain3 = n1.z;//noise(uv*4., 33.8885);\n    float grain4 = n2.x;//noise(uv*2., 44.49289);\n    \n    vec3 g1 = vec3(0.1, 0.9, 0.003);\n    vec3 g2 = vec3(0.3, 0.6, 0.02);\n    vec3 g3 = vec3(0.003, 0.9, 0.1);\n    vec3 g4 = (g1*g2*g3);\n    col = mix(g1, g2, grain1);\n    col = mix(col, g3, grain2);\n    col = mix(col, g4, grain3);\n    col = mix(col, col*col, grain1);\n    return col;\n}\n\n\n//#define DEBUG_TEXTURE getAlbedoBox\nvec3 getAlbedoBox(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec3 p = data.p;\n    vec3 n = data.n;\n    \n    vec2 uv = mix(mix(p.xz, p.yz, round(abs(dot(n, vec3(1, 0, 0))))),\n        p.xy, round(abs(dot(n, vec3(0, 0, 1)))));\n    uv *= 0.5;\n    vec2 lv = fract(uv*4.);\n    \n    vec3 b1 = vec3(0.77, 0.65, 0.5);\n    vec3 b2 = vec3(0.49, 0.35, 0.2);\n    vec3 b3 = vec3(0.41, 0.19, 0.105);\n    \n    vec3 n1 = tnoise(uv, 3.4123, 32.0, 0.01, 4);\n    vec3 n2 = tnoise(uv, 10.5321, 32.0, 0.01, 4);\n    vec3 n3 = tnoise(uv, 66.59381, 24.0, 0.01, 1);\n    vec3 grain = fract(sin(6.28*cross(n1*2.0-1.0, n2*2.0-1.0)));\n    vec2 pat = vec2(cos(uv.x*6.28*7.+3.2*sin(uv.y*6.28*2.+n1.x)), sin(uv.y*6.28*7.+3.2*cos(uv.x*6.28*2.+n3.y)));\n    \n    col = mix(b1, b2, n1.x);\n    col = mix(col, b3, max(0.0, n1.y-n1.x));\n    col = mix(col, b3*b2, mix(pat.x, pat.y, n3.y));\n    col = col*col;\n    return col;\n}\n\nvec3 getAlbedoRoad(inout Data data) {\n    vec3 p = data.p;\n    vec2 uv = data.p.xz;\n    vec3 col = vec3(0.4, 0.4, 0.4);\n    \n    vec3 n1 = tnoise(uv, 3.2192193, 64.0, 0.04, 4);\n    \n    float grain = n1.x;//noise(uv, 3.2192193, 64.0, 0.04, 4);\n    \n    col *= grain;\n    \n    vec3 yellow = vec3(0.7, 0.25, 0.05);\n    \n    float lz = fract(p.z*0.5);\n    lz = abs(lz*2.0-1.0);\n    \n    col = mix(col, yellow, slt(abs(p.x), 0.25, 0.1)*sgt(lz, 0.5, 0.1));\n    \n   // if (abs(p.x) < 0.25 && mod(p.z, 2.0) >= 1.0) col = yellow;\n    \n    return col;\n}\n\nvec3 getAlbedo(inout Data data) {\n    switch (data.id) {\n        case ID_GROUND: return getAlbedoGround(data); break;\n        case ID_BOX: return getAlbedoBox(data); break;\n        case ID_ROAD: return getAlbedoRoad(data); break;\n        default: return vec3(0.7);\n    }\n    \n    return vec3(0.7);\n}\n\nvec3 forEachLight(Light light, vec3 ro, vec3 rd, vec3 diffuse, inout Data data) {\n    vec3 N = data.n;\n    vec3 p = data.p;\n    vec3 L = getLightDir(light, p);\n    vec3 att = getLightAtt(light, p, N);\n    float shadow = getShadow(light, data.p, N);\n    return diffuse * att * shadow;\n}\n\nvec3 getSky(in vec3 ro, in vec3 rd) {\n    vec3 col = vec3(0.0);\n    float dotup = max(0.0, dot(rd, vec3(0, 1, 0)));\n    vec3 blue = vec3(0.04, 0.4, 0.8);\n    \n    col += pow(blue, vec3(1.0 + 9.*dotup));\n    \n    return col;\n}\n\nvec3 getColor(in vec3 ro, in vec3 rd, inout Data data) {\n\n    vec3 col = vec3(0.0);\n    \n    Light light = Light(vec3(3, 2, -3.), vec3(0.97, 0.95, 0.89), 1.0, LIGHT_AMBIENT);\n    \n    if (march(ro, rd, data)) {\n        vec3 albedo = getAlbedo(data);\n        vec3 diffuse = albedo / M_PI;\n        col += forEachLight(light, ro, rd, diffuse, data);\n    } else {\n        col += getSky(ro, rd);\n    }\n    \n    col = max(col, vec3(0.0));\n    float depth = (data.d / (FAR - NEAR));\n    float dotup = max(0.0, dot(rd, vec3(0, 1, 0)));\n    col = mix(col, vec3(1.0), mix(smoothstep(0.1, 0.9, depth), 0.0, smoothstep(-0.5, 0.3, dotup)));\n    \n    vec3 L = getLightDir(light, ro);\n    float VdotL = max(0.0, dot(rd, L));\n    col += light.c*light.c*pow(VdotL, 24.0);\n    \n    return col;\n}\n\nvoid mainImage(out vec4 o, in vec2 fc) {\n  vec3 col = vec3(0.0);\n  vec2 uv = (fc-0.5*R.xy)/R.y;\n  vec4 m = vec4((iMouse.xy-0.5*R.xy)/R.y,iMouse.zw);\n  \n  vec3 ro = vec3(0., 1.9, -6.0);\n  \n  vec3 rd = normalize(vec3(uv, 1.0));\n  \n  if (m.z > 0.001) {\n      ro.yz *= rot(m.y*TAU);\n      ro.xz *= rot(m.x*TAU);\n      rd.yz *= rot(m.y*TAU);\n      rd.xz *= rot(m.x*TAU);\n  }\n  \n  ro.z += T*9.;\n  ro.x += sin(T*2.)*3.;\n  ro.y += (0.5+0.5*cos(T*4.));\n  ro.y = max(ro.y, 1.9);\n  \n  Data data = NEW_DATA;\n  \n  #ifdef DEBUG_TEXTURE\n  data.p = vec3(0.0);\n  data.p.xz = (fc/R.xy);\n  col += DEBUG_TEXTURE(data);\n  #else\n  col += getColor(ro, rd, data);\n  col = pow(col, vec3(1.0 / 2.2));\n  col = aces(col);\n  #endif\n  o = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}