{
    "Shader": {
        "info": {
            "date": "1562753307",
            "description": "Drag to move vertices. Press A to edit UVs instead. Press Space to hide the grid.",
            "flags": 48,
            "hasliked": 0,
            "id": "WtsSDH",
            "likes": 26,
            "name": "Goo Tool",
            "published": 3,
            "tags": [
                "grid",
                "texture",
                "mapping",
                "mesh",
                "editor",
                "bilinear"
            ],
            "usePreview": 1,
            "username": "TimoKinnunen",
            "viewed": 1138
        },
        "renderpass": [
            {
                "code": "// Goo Tool by Timo Kinnunen 2019\n//\n// Based on mapping edit https://www.shadertoy.com/view/MddGW2 by FabriceNeyret2\n// which was inspired from https://www.shadertoy.com/view/MstGW2\n//\n// Each pixel of Buffer A encodes two pairs pair of vertex coordinates:\n// .xy relative to screen\n// .zw relative to texture, negative if screen coordinates unlocked\n//\n// Image shader connects GRID+1 vertices to make GRID quads.\n\n// Author : Sebastien Berube\n// Created : Dec 2015\n// Modified : Jan 2016\n//\n// This shader uses the vanishing point on the image plane in order to infer the world space direction of parallel lines.\n// From 4 points (2D) on the image plane, it will use projective geometry properties in order to generate 4 points (3D) world space.\n// \n// This is a very important concept for 3D scene reconstruction from 2D images.\n//\n// The one line that is important in this shader is : \"p1_to_p2 = dirVanishingPoint\", in function \"resolveAdjacentCorner()\".\n// What this means is : the 3D line starting from the camera center and going towards the vanishing point of 2 parallel lines \n//                      are all parallel with each other (as all lines directed towards this vanishing point are parallel).\n//                      Although parallel lines are nerver supposed to cross each other in reality, they however do on the \n//                      projected image plane, and this allows computation of the vanishing point intersection in 2D first,\n//                      and then inferring 3D direction by casting a ray from the camera center through this vanishing point\n//                      on the image plane.\n//\n// License : Creative Commons Non-commercial (NC) license\n//\nconst vec2 SS1_BOTTOM_LEFT  = vec2( 0.180, 0.320);\nconst vec2 SS1_BOTTOM_RIGHT = vec2( 0.332, 0.360);\nconst vec2 SS1_TOP_RIGHT    = vec2( 0.332, 0.640);\nconst vec2 SS1_TOP_LEFT     = vec2( 0.180, 0.766);\n\nconst vec2 SS2_BOTTOM_LEFT  = vec2( 0.820, 0.343);\nconst vec2 SS2_BOTTOM_RIGHT = vec2( 0.970, 0.33);\nconst vec2 SS2_TOP_RIGHT    = vec2( 0.965, 0.745);\nconst vec2 SS2_TOP_LEFT     = vec2( 0.815, 0.675);\n  \nstruct Cam { vec3 r; vec3 u; vec3 d; vec3 o;}; //R=Right, U=Up, D=Direction, O=Origin\nCam CAM_lookAt(vec3 at, float fPitch, float dst, float rot) \n{ \n    Cam cam;\n    cam.d = vec3(cos(rot)*cos(fPitch),sin(fPitch),sin(rot)*cos(fPitch));\n    cam.u = vec3(-sin(fPitch)*cos(rot),cos(fPitch),-sin(fPitch)*sin(rot));\n    cam.r = cross(cam.d,cam.u); cam.o = at-cam.d*dst;\n    return cam;\n}\nCam CAM_mouseLookAt(vec3 at, float dst, vec4 mouse)\n{\n    vec2 res = iResolution.xy; vec2 spdXY = vec2(25.1416,4.0);\n    float fMvtX = (mouse.x/res.x)-0.535;\n    if(fMvtX>0.15) dst *= (1.0+(fMvtX-0.15)/0.03);\n    else if(fMvtX<-0.15) dst *= (1.0-(fMvtX+0.15)/(-0.2));\n\t//fMvtX += iTime*0.0150;//Auto turn\n    return CAM_lookAt(at,spdXY.y*((mouse.y/res.y)-0.5),dst,spdXY.x*fMvtX);\n}\n//Function to cast a ray through a given coordinate (uv) on the image plane.\n//It returns the direction of a 3D Ray.\n//Note : screen center is uv=[0,0]\nvec3 ray(vec2 uv, Cam cam)\n{\n    return normalize(uv.x*cam.r+uv.y*cam.u+cam.d);\n}\n\n//Function which does the opposite of the previous function:\n//It receives a 3D world space position, then flattens it on the image plane \n//and returns its [uv] coordinates.\n//Note : screen center is uv=[0,0]\nvec2 camProj(Cam c, vec3 p)\n{\n    p = p-c.o;\n    float cZ = dot(p,c.d);\n    float cX = dot(p,c.r);\n\tfloat cY = dot(p,c.u);\n    return vec2(cX/cZ,cY/cZ);\n}\n\n//Simple utility function which returns the distance from point \"p\" to a given line segment defined by 2 points [a,b]\nfloat distanceToLineSeg(vec2 p, vec2 a, vec2 b)\n{\n    //e = capped [0,1] orthogonal projection of ap on ab\n    //       p\n    //      /\n    //     /\n    //    a--e-------b\n    vec2 ap = p-a;\n    vec2 ab = b-a;\n    vec2 e = a+clamp(dot(ap,ab)/dot(ab,ab),0.0,1.0)*ab;\n    return length(p-e);\n}\n\n//Utility function returning the intersection point of two 2D lines\n//[p1a,p1b] = line1\n//[p2a,p2b] = line1\nvec2 lineLineIntersection(vec2 p1a, vec2 p1b, vec2 p2a, vec2 p2b)\n{\n    vec2 d1 = (p1b-p1a); //Direction Line 1\n    vec2 d2 = (p2b-p2a); //Direction Line 2\n    vec2 d1n = vec2(d1.y, -d1.x); //orthogonal line to d1 (normal), optimal direction to reach d1 from anywhere\n    float dist = dot(p1a-p2a,d1n);//projection on the optimal direction = distance\n    float rate = dot(d2,d1n); //rate : how much is our d2 line in the optimal direction? (<=1.0)\n    float t = 10000000.0 ; //INFINITY! (rare parallel case)\n    if(rate != 0.0)\n\t\tt = dist/rate; //Starting from p2a, find the distance to reach the other line along d2.\n    return p2a+t*d2;  //start point + distance along d2 * d2 direction = intersection.\n}\n\n//Utility function to compute the distance along a ray to reach a plane, in 3D.\n//The value returned is the distance along ray to the plane intersection.\n//o = ray origin\n//d = ray direction\n//po = plane origin\n//pn = plane normal\nfloat rayPlaneIntersec(vec3 o, vec3 d, vec3 po, vec3 pn) \n{\n    //Same principle as lineLineIntersection() :\n    //\"How far is the plane\"/\"approach rate\".\n    //No need to normalize pn, as dot product above and under cancel out and do not scale the result.\n    return dot(po-o,pn)/dot(d,pn);\n}\n\nstruct screenSpaceQuad{ vec2 a; vec2 b; vec2 c; vec2 d; };\nstruct worldSpaceQuad{  vec3 a; vec3 b; vec3 c; vec3 d; };\n\n//perspectiveCam : the camera from which the points in screen space come from\n//P1 : known world space position of p1\n//p1 : screen space p1 (which is resolved, already)\n//p2 : screen space p2 (which must be adjacent to p1 - cannot be the opposite corner)\n//parallel_a : first point (screen space) in the other line parallel to (p1,p2)\n//parallel_b : second point (screen space) in the other line parallel to (p1,p2)\nvec3 resolveAdjacentCorner(in Cam perspectiveCam, vec3 P1, vec2 p1_resolved, vec2 p2_adjacent, vec2 parallel_a, vec2 parallel_b)\n{\n    //screen space intersection (vanishing point on the projection plane)\n    vec2 ssIntersec = lineLineIntersection(p1_resolved,p2_adjacent,parallel_a,parallel_b);\n    //Vanishing point direction, from camera, in world space.\n    vec3 dirVanishingPoint = ray(ssIntersec, perspectiveCam);\n    vec3 p1_to_p2 = dirVanishingPoint; //Since vanishing point is at \"infinity\", p1_to_p2 == dirVanishingPoint\n    vec3 r2 = ray(p2_adjacent, perspectiveCam);//Ray from camera to p2, in world space\n    \n    //<Line3D intersection : where p1_to_p2 crosses r2>\n    //(Note : this could probably be made simpler with a proper 3D line intersection formula)\n    //Find (rb,p1_to_p2) intersection:\n    vec3 n_cam_p1_p2 = cross(p1_to_p2,r2); //normal to the triangle formed by point p1, point p2 and the camera origin\n    vec3 n_plane_p2 = cross(n_cam_p1_p2,r2); //normal to the plane which is crossed by line p1-p2 at point p2\n    float t = rayPlaneIntersec(P1,p1_to_p2,perspectiveCam.o,n_plane_p2);\n    vec3 p2_ws = P1+t*p1_to_p2;\n    //</Line3D intersection>\n    return p2_ws;\n}\n    \n//Finds each corner, one by one.\nvoid resolvePerspective(in Cam perspectiveCam, in screenSpaceQuad ssQuad, out worldSpaceQuad wsQuad)\n{\n    vec3 ra = ray(ssQuad.a, perspectiveCam); //Find the direction of the ray passing by point a in screen space.\n\t                                      //For the sake of simplicity, screenspace [uv.x,uv.y] = worldspace [x,y]. Z = depth.\n    //Let's place point a in an arbitrary position along the ray ra. \n    //It does not matter at which distance exactly, as it is the relationship between\n    //the corners that is important. The first corner distance simply defines the scaling of the 3D scene.\n    wsQuad.a = perspectiveCam.o + 4.5*ra; //5.5 = arbitrary scaling. Projective geometry does not preserve world space scaling.\n    wsQuad.b = resolveAdjacentCorner(perspectiveCam, wsQuad.a, ssQuad.a, ssQuad.b, ssQuad.c, ssQuad.d);\n    wsQuad.c = resolveAdjacentCorner(perspectiveCam, wsQuad.b, ssQuad.b, ssQuad.c, ssQuad.a, ssQuad.d);\n    wsQuad.d = resolveAdjacentCorner(perspectiveCam, wsQuad.a, ssQuad.a, ssQuad.d, ssQuad.b, ssQuad.c);\n}\n\nvec3 apply_atmosphere(float travelDist, vec3 rd, vec3 color, vec3 p)\n{\n    //From this nice article on fog:\n    //https://iquilezles.org/articles/fog\n    //or this PowerPoint from Crytek:\n\t//GDC2007_RealtimeAtmoFxInGamesRev.ppt p17\n    vec3 ref = p+rd;\n\tvec3 c_atmosphere = mix(vec3(0.87,0.94,1.0),vec3(0.6,0.80,1.0),clamp(3.0*ref.y/length(ref.xz),0.,1.));\n    c_atmosphere = mix(vec3(0.47,0.54,0.3),c_atmosphere,clamp(3.0*ref.y/length(ref.xz),-1.,0.)+1.);\n    float c = 1.08;\n    float b = 0.06*.3;\n\n    float cumul_density = c * exp(-1.0*b) * (1.0-exp( -travelDist*1.0*b ))/1.0;\n    cumul_density = clamp(cumul_density,0.0,1.0);\n    vec3 FinalColor = mix(color,c_atmosphere,cumul_density);\n    return FinalColor;\n}\n\nvec3 alphaBlend(vec3 c1, vec3 c2, float alpha)\n{\n    return mix(c1,c2,clamp(alpha,0.0,1.0));\n}\n\nvec2 pixel2uv(vec2 px, bool bRecenter, bool bUniformSpace)\n{\n    if(bRecenter)\n    {\n        px.xy-=iResolution.xy*0.5;\n\t}\n    \n    vec2 resolution = bUniformSpace?iResolution.xx:iResolution.xy;\n    vec2 uv = px.xy / resolution;\n    return uv;\n}\n\nvec3 drawPoint(vec2 uv, vec2 point, vec3 cBack, vec3 cPoint, float radius, float fZoom)\n{\n    radius /= fZoom;\n    float distPt = length(uv-point);\n    float alphaPt = 1.0-smoothstep(radius-.003/fZoom,radius,distPt);\n    return alphaBlend(cBack,cPoint,alphaPt);\n}\n\nvec3 drawLine(vec2 uv, vec2 pa, vec2 pb, vec3 cBack, vec3 cLine, float radius, float fZoom)\n{\n    radius /= fZoom;\n    float distLine = distanceToLineSeg(uv,pa,pb);\n    float alphaLine = 1.0-smoothstep(radius-.003/fZoom,radius,distLine);\n    return alphaBlend(cBack,cLine,alphaLine);\n}\n\n//wsQuad.a = origin (lower left corner)\n//wsQuad.a,b,c,d = CCW point order.\nvec2 findParallelogramUV(vec3 o, vec3 d, worldSpaceQuad wsQuad)\n{\n    //Note : This is tricky because axis are not orthogonal.\n    vec3 uvX_ref = wsQuad.b-wsQuad.a; //horizontal axis\n    vec3 uvY_ref = wsQuad.d-wsQuad.a; //vertical axis\n    vec3 quadN = cross(uvY_ref,uvX_ref);\n    float t = rayPlaneIntersec(o, d, wsQuad.a, quadN);\n        \n    vec3 p = o+t*d;\n    vec3 X0_N = cross(uvY_ref,quadN);\n    vec3 Y0_N = cross(uvX_ref,quadN);\n    \n    //Vertical component : find the point where plane X0 is crossed\n    float t_x0 = rayPlaneIntersec(p, uvX_ref, wsQuad.a, X0_N);\n    vec3 pY = p+t_x0*uvX_ref-wsQuad.a;\n    //Horizontal component : find the point where plane Y0 is crossed\n    float t_y0 = rayPlaneIntersec(p, uvY_ref, wsQuad.a, Y0_N);\n    vec3 pX = p+t_y0*uvY_ref-wsQuad.a;\n    \n    //All is left to find is the relative length ot pX, pY compared to each axis reference\n    return vec2(dot(pX,uvX_ref)/dot(uvX_ref,uvX_ref),\n\t            dot(pY,uvY_ref)/dot(uvY_ref,uvY_ref));\n}\n\nvec3 drawPerspectiveScene(Cam perspectiveCam, vec2 uv, screenSpaceQuad ssQuad, worldSpaceQuad wsQuad, vec3 cBackground, float fZoom)\n{\n    vec3 cScene = cBackground;\n    cBackground = texture(iChannel1,clamp(uv+0.5,0.,1.)).xyz;\n    cScene = cBackground;//alphaBlend(cScene,cBackground,0.9995);\n\n    float fLineWidth = 0.0025;\n    cScene = drawLine(uv, ssQuad.a, ssQuad.b, cScene, vec3(0), fLineWidth, fZoom);\n    cScene = drawLine(uv, ssQuad.b, ssQuad.c, cScene, vec3(0), fLineWidth, fZoom);\n    cScene = drawLine(uv, ssQuad.c, ssQuad.d, cScene, vec3(0), fLineWidth, fZoom);\n    cScene = drawLine(uv, ssQuad.d, ssQuad.a, cScene, vec3(0), fLineWidth, fZoom);\n    //cScene = alphaBlend(cScene,cBackground,0.5);\n\n    /*\n    float fPointRad = 0.006;\n    cScene = drawPoint(uv, ssQuad.a, cScene, vec3(0,1,0), fPointRad, fZoom);\n    cScene = drawPoint(uv, ssQuad.b, cScene, vec3(0,1,0), fPointRad, fZoom);\n    cScene = drawPoint(uv, ssQuad.c, cScene, vec3(0,1,0), fPointRad, fZoom);\n    cScene = drawPoint(uv, ssQuad.d, cScene, vec3(0,1,0), fPointRad, fZoom);\n    \n    //Show results\n    fPointRad = 0.004;\n    vec2 aDebug = camProj(perspectiveCam,wsQuad.a);\n    vec2 bDebug = camProj(perspectiveCam,wsQuad.b);\n    vec2 cDebug = camProj(perspectiveCam,wsQuad.c);\n    vec2 dDebug = camProj(perspectiveCam,wsQuad.d);\n    cScene = drawPoint(uv, aDebug, cScene, vec3(0,0,1), fPointRad, fZoom);\n    cScene = drawPoint(uv, bDebug, cScene, vec3(0,0,1), fPointRad, fZoom);\n    cScene = drawPoint(uv, cDebug, cScene, vec3(0,0,1), fPointRad, fZoom);\n    cScene = drawPoint(uv, dDebug, cScene, vec3(0,0,1), fPointRad, fZoom);\n    */\n    return cScene;\n}\n\nCam setupPerspectiveCamera()\n{\n    Cam cam;\n    cam.o = vec3(0,0,0);\n    cam.r = vec3(1,0,0);\n    cam.u = vec3(0,1,0);\n    cam.d = vec3(0,0,-1);\n    return cam;\n}\n\nscreenSpaceQuad setupPerspectiveQuad(vec2 mouse_uv)\n{\n    screenSpaceQuad ssQuad;\n    \n    //Arbitrary screen-space parallelograms.\n    if(fract(iTime/4.0)> 0.5)\n    {\n        ssQuad.a = SS1_BOTTOM_LEFT-0.5;\n    \tssQuad.b = SS1_BOTTOM_RIGHT-0.5;\n    \tssQuad.c = SS1_TOP_RIGHT-0.5;\n    \tssQuad.d = SS1_TOP_LEFT-0.5;\n    }\n    else\n    {\n     \tssQuad.a = SS2_BOTTOM_LEFT-0.5;\n    \tssQuad.b = SS2_BOTTOM_RIGHT-0.5;\n    \tssQuad.c = SS2_TOP_RIGHT-0.5;\n    \tssQuad.d = SS2_TOP_LEFT-0.5;   \n    }\n    /*\n    if(iMouse.z > 0.0 && mouse_uv.x < 0.5 && mouse_uv.y < 0.5) //if mouse btn down\n    {\n\t\tssQuad.d = mouse_uv;\n    }\n    */\n    return ssQuad;\n}\n\nvec2 inversePerspective_uv(Cam perspectiveCam, vec2 uv_01, screenSpaceQuad ssQuad, worldSpaceQuad wsQuad )\n{\n    vec3 x_ws = wsQuad.b-wsQuad.a;\n    vec3 y_ws = wsQuad.d-wsQuad.a;\n    vec3 p_ws = wsQuad.a+uv_01.x*x_ws + uv_01.y*y_ws;\n    vec2 puv = camProj(perspectiveCam,p_ws);\n\treturn puv;\n}\n\nCam setupSceneCamera(vec4 mouse)\n{\n    float targetDistance = 10.5*1.;\n    vec3 cam_tgt = vec3(0,0,-3.0);\n    Cam cam = CAM_lookAt(cam_tgt, -0.2, targetDistance, 1.5*radians(180.)+0.*4.71+0.*-0.75+0.*iTime*0.1);//4.71\n    if(mouse.xz != vec2(0.0,0.0)/* && ( iMouse.x > iResolution.x/4.0 || iMouse.y > iResolution.y/4.0) */) //Mouse button down : user control\n    {\n    \tcam = CAM_mouseLookAt(cam_tgt, targetDistance, mouse);\n    }\n    return cam;\n}\n\nvec4 draw3DScene(Cam perspectiveCam, Cam sceneCam, vec2 uv, worldSpaceQuad wsQuad, screenSpaceQuad ssQuad)\n{\n    vec3 o = sceneCam.o;\n    vec3 d = ray(uv,sceneCam);\n    \n    vec3 cScene = vec3(0);\n    \n    float t = rayPlaneIntersec(o,d, vec3(0,-15.0,0), vec3(0,1,0));\n    if(t<0.0)\n    {\n        t = 1000.0;\n        cScene = vec3(1); //apply_atmosphere(t,vec3(1),o+t*d);\n    }\n    else\n    {\n\t\tvec3 pFloor = o+t*d;\n    \tvec3 cFloor = texture(iChannel1,pFloor.xz*vec2(0.25,-0.25)).xyz*\n            (1.0-pow(1.0-\n                4.0*(0.5-abs(0.5-fract(pFloor.x*0.25)))*(0.5-abs(0.5-fract(pFloor.z*0.25))),\n                32.0));\n    \tcScene = cFloor; //apply_atmosphere(t,cFloor,pFloor);\n    }\n    \n    float fZoom = 3.0*iResolution.x/1920.;\n    vec2 aDebug = camProj(sceneCam,wsQuad.a);\n    vec2 bDebug = camProj(sceneCam,wsQuad.b);\n    vec2 cDebug = camProj(sceneCam,wsQuad.c);\n    vec2 dDebug = camProj(sceneCam,wsQuad.d);\n    vec2 oDebug = camProj(sceneCam,perspectiveCam.o);\n    \n    /*\n    cScene = drawPoint(uv,aDebug,cScene,vec3(1,0,0),0.005, fZoom);\n    cScene = drawPoint(uv,bDebug,cScene,vec3(1,0,0),0.005, fZoom);\n    cScene = drawPoint(uv,cDebug,cScene,vec3(1,0,0),0.005, fZoom);\n    cScene = drawPoint(uv,dDebug,cScene,vec3(1,0,0),0.005, fZoom);\n    cScene = drawPoint(uv,oDebug,cScene,vec3(0,0,1),0.005, fZoom);\n    cScene = drawLine(uv,aDebug,oDebug,cScene,vec3(0,0.8,1),0.0025, fZoom);\n    cScene = drawLine(uv,bDebug,oDebug,cScene,vec3(0,0.8,1),0.0025, fZoom);\n    cScene = drawLine(uv,cDebug,oDebug,cScene,vec3(0,0.8,1),0.0025, fZoom);\n    cScene = drawLine(uv,dDebug,oDebug,cScene,vec3(0,0.8,1),0.0025, fZoom);\n    */\n    cScene = drawLine(uv,aDebug,bDebug,cScene,vec3(0),0.0025, fZoom);\n    cScene = drawLine(uv,bDebug,cDebug,cScene,vec3(0),0.0025, fZoom);\n    cScene = drawLine(uv,cDebug,dDebug,cScene,vec3(0),0.0025, fZoom);\n    cScene = drawLine(uv,dDebug,aDebug,cScene,vec3(0),0.0025, fZoom);\n    \n    //Projection Plane (camera near plane)\n    /*float tImage = rayPlaneIntersec(o,d, perspectiveCam.O+normalize(perspectiveCam.D), perspectiveCam.D);\n    if(tImage>0.0 && tImage <= t) //tImage < 0 when the ray never intersects the floor plane (intersection happens behind camera)\n    {\n        vec3 pImage = o+tImage*d;\n        vec2 uv = camProj(perspectiveCam,pImage);\n        \n        if(abs(uv.x)<0.5 && abs(uv.y)<0.5*iResolution.y/iResolution.x)\n        {\n            vec3 cPersp = drawPerspectiveScene(perspectiveCam, uv, ssQuad, wsQuad, vec3(0.55), fZoom*0.1);\n            cScene = alphaBlend(cScene,cPersp,0.95);\n            t = tImage;\n        }\n    }*/\n    //\n    vec3 nQuad = cross((wsQuad.b-wsQuad.a),(wsQuad.d-wsQuad.a));\n    float tQuad = rayPlaneIntersec(o,d, wsQuad.a, nQuad);\n    if(tQuad>0.0 && tQuad <= t) //tQuad < 0 when the ray never intersects the floor plane (intersection happens behind camera)\n    {\n        vec2 uv = findParallelogramUV(o,d,wsQuad);\n        if(uv.x>0.0 && uv.x<1.0 &&\n           uv.y>0.0 && uv.y<1.0 )\n        {\n            vec2 tuv = inversePerspective_uv(perspectiveCam, uv, ssQuad, wsQuad);\n        \tvec3 cTest = drawPerspectiveScene(perspectiveCam, tuv, ssQuad, wsQuad, vec3(0.55), fZoom*0.25);\n            cScene = cTest;//alphaBlend(cScene,cTest,0.95);\n            t = tQuad;\n        }\n    }\n\n\n    cScene = apply_atmosphere(t,d,cScene,o+t*d);\n\n    return vec4(cScene,t);\n}\n\nvec4 perpectiveImage(vec2 fragCoord, vec2 BL, vec2 BR, vec2 TR, vec2 TL) {\n    float perspectiveImageSize = 0.25;\n    float fZoom = 3.0*iResolution.x/1920.;\n    vec4 mouse = texelFetch(iChannel0,ivec2(0,1),0)*iResolution.xyxy;\n    \n    vec2 perspective_uv = pixel2uv(fragCoord/perspectiveImageSize, true, true);\n    vec2 perspective_mouse_uv = pixel2uv(mouse.xy/perspectiveImageSize, true, true);\n\t\n    worldSpaceQuad wsQuad;\n    screenSpaceQuad ssQuad/* = setupPerspectiveQuad(perspective_mouse_uv)*/;\n\n    ssQuad.a = BL-0.5;\n    ssQuad.b = BR-0.5;\n    ssQuad.c = TR-0.5;\n    ssQuad.d = TL-0.5;\n\n    Cam perspectiveCam = setupPerspectiveCamera();\n    resolvePerspective(perspectiveCam,ssQuad,wsQuad);\n    /*\n    //Perspective view\n    if(fragCoord.x<iResolution.x*perspectiveImageSize && fragCoord.y<iResolution.y*perspectiveImageSize)\n    {\n        vec3 cPerspective = drawPerspectiveScene(perspectiveCam, perspective_uv, ssQuad, wsQuad, vec3(0.55), fZoom*perspectiveImageSize);\n        fragColor = vec4(cPerspective,1.0);\n    }\n    //Inverse view\n    else if(fragCoord.x>iResolution.x*(1.0-perspectiveImageSize) && fragCoord.y<iResolution.y*perspectiveImageSize)\n    {\n        vec2 fragCoordLocal = vec2( fragCoord.x-iResolution.x*(1.0-perspectiveImageSize),fragCoord.y);\n        vec2 inverse_perspective_uv = pixel2uv(fragCoordLocal/perspectiveImageSize, false, false);\n        \n        vec2 tuv = inversePerspective_uv(perspectiveCam, inverse_perspective_uv, ssQuad, wsQuad);\n        vec3 cTest = drawPerspectiveScene(perspectiveCam, tuv, ssQuad, wsQuad, vec3(0.55), fZoom*perspectiveImageSize);\n        fragColor = vec4(cTest,1.0);\n    }\n    //3D Scene\n    else\n    {*/\n        vec2 uvScene = pixel2uv(fragCoord, true, true);\n\t    Cam sceneCam = setupSceneCamera(mouse);\n\t    vec4 cScene = draw3DScene(perspectiveCam, sceneCam, uvScene, wsQuad, ssQuad);\n        return cScene;\n    /*}*/\n}\n\n\n#define key(k) ( texture(iChannel2,vec2((.5+float(k))/256.,.75)).x > 0.)\n\nfloat L(vec2 U, vec2 a, vec2 b) {\n    vec2 v=b-a;\n    return pow(4e-1 / length(clamp( dot(U-a,v)/dot(v,v), 0.,1.) *v - U+a ),1.3);\n}\n#undef R\n// shakes unlocked vertex pairs\n//\n// (in reality hides almost all failure cases of bilinear mapping when vertices are axis-aligned)\nvec4 shake(vec4 P11, vec2 R, int ix, int iy) {\n    if(P11.x<= 0.0 && P11.y<= 0.0) {\n        float a = 10.*iTime + float(ix)/float(GRID.x)*R.x+117.1*float(iy)/float(GRID.y)*R.y;\n        float dampen = iMouse.z>0.0 ? clamp((distance(iMouse.xy, -P11.xy*R)-1.)/2.,0.,1.) : 1.0;\n        P11.xy -= dampen* 3.2* vec2(cos(a),sin(a))/R;\n    }\n    return P11;\n}\nvoid mainImage(out vec4 O, vec2 Uorig) {\n    vec2 Rorig = iResolution.xy;\n    vec2 U = Uorig;\n    vec2 R = Rorig;\n\n    bool changeOrigins = key(65);\n    bool gridIsVisible = !key(32);\n    bool dragActive = iMouse.z > 0.0;\n    bool display3D = key(67);\n\n    vec2 st = -U;\n    if(gridIsVisible && changeOrigins) {\n        vec2 margin = vec2(20);\n        if(display3D) {\n            margin += R * 0.125;\n        }\n        if(U.x >= margin.x && U.y >= margin.y && U.x < R.x-margin.x && U.y < R.y-margin.y) {\n            st = (U-margin)/(R-margin-margin);\n        }\n        U -= margin;\n        R -= margin+margin;\n    }\n    \n    vec4 col = vec4(0,0,0,1);\n    vec4 col3D = vec4(0,0,0,1e10);\n\n    /*if(!changeOrigins && display3D) {\n        col.a = 1e10;\n    }*/\n    for (int iy=0; iy <= GRID.y; iy++) {\n        vec4 P00, P01, P10 = T(0,iy), P11 = T(0,iy+1);\n\n        if(!changeOrigins) {\n            P10 = shake(P10,R,0,iy);\n            P11 = shake(P11,R,0,iy+1);\n        }\n        for (int ix=0; ix <= GRID.x; ix++) {\n            P00 = P10;\n            P01 = P11;\n            P10 = T(ix+1,iy);\n            P11 = T(ix+1,iy+1);\n\n            if(!changeOrigins) {\n                P10 = shake(P10,R,ix+1,iy);\n                P11 = shake(P11,R,ix+1,iy+1);\n            }\n\n            vec2 p00=clamp(abs(P00.xy),0.,1.)*R;\n            vec2 p01=clamp(abs(P01.xy),0.,1.)*R;\n            vec2 p10=clamp(abs(P10.xy),0.,1.)*R;\n            vec2 p11=clamp(abs(P11.xy),0.,1.)*R;\n            vec2 uv00=P00.zw*R;\n            vec2 uv01=P01.zw*R;\n            vec2 uv10=P10.zw*R;\n            vec2 uv11=P11.zw*R;\n\n\n            if(ix < GRID.x && iy < GRID.y) {\n                if(display3D) {\n                    vec4 result = perpectiveImage(Uorig,P00.zw,P10.zw,P11.zw,P01.zw);\n                    if(result.a<col3D.a) col3D = result;\n                } \n                if(!gridIsVisible || !changeOrigins) {\n                    vec2 uv = invBilinear(U,p00,p10,p11,p01);\n                    if(uv.x>-0.5) {\n                        st = mix(mix(uv00,uv10,uv.x),mix(uv01,uv11,uv.x),uv.y)/R;\n                    }\n                }\n            }\n                \n            if (gridIsVisible) {\n                vec2 point = (changeOrigins) ? uv00 : p00;\n                vec2 line1 = (changeOrigins) ? uv01 : p01;\n                vec2 line2 = (changeOrigins) ? uv10 : p10;\n                vec4 lglow = (changeOrigins) ? vec4(1,0,0,0) : vec4(0,1,0,0);\n\n                float mask1 = smoothstep(3.,0.,(6.-length(U-point)));\n                // draw one vertical and one horizontal segment\n                float segs = \n                    ((iy<GRID.y)? L(U,point,line1):0.)+\n                    ((ix<GRID.x)? L(U,point,line2):0.);\n                col.a *= mask1 * (1.-segs);\n                col += lglow * mask1 * segs;\n                // draw point\n                float mask2 = smoothstep(0.,3.,abs(6.-length(U-point)));\n                col.a *= mask2;\n                col.rgb += smoothstep(2.,0.,abs(4.-length(U-point)));\n            }\n        }\n    }\n\n    if(st.x<0.0) {\n    \tO = vec4(0);\n    } else {\n        O = textureLod(iChannel1, st, -100.0);\n    }\n    O.rgb *= col.a;\n    O += col;\n    if(display3D) {\n        if(changeOrigins) {\n            O = mix(O, vec4(col3D.rgb,1),0.75*col.a);\n        } else {\n            O = vec4(col3D.rgb,1);\n        }\n    }\n\n    // press B to show buffer A\n    if(key(66)) {\n        vec4 tex = texelFetch(iChannel0,ivec2(.0625*Uorig),0);\n        float texLen = length(tex);\n        tex.rgb = mix(tex.rgb, 0.5+0.5*tex.rgb, float(texLen != 0.0));\n        O = O*clamp(1.0-2.0*texLen,0.0,1.0)+mix(tex,1.0-tex,tex.a);\n        O = mix(O,fract(O),ceil(O-floor(O)));\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define key(k) ( texture(iChannel2,vec2((.5+float(k))/256.,.75)).x > 0.)\n\n/*\nLeast Squares Fitting of Data by Linear or Quadratic Structures\nDavid Eberly, Geometric Tools, Redmond WA 98052\nhttps://www.geometrictools.com/\nThis work is licensed under the Creative Commons Attribution 4.0 International License. To view a copy\nof this license, visit http://creativecommons.org/licenses/by/4.0/ or send a letter to Creative Commons,\nPO Box 1866, Mountain View, CA 94042, USA.\nCreated: July 15, 1999\nLast Modified: February 14, 2019\n*/\nvec3 getPoint(int Ux, int Uy) {\n    return TR(Ux,Uy).xyz;\n}\nvec2 calculateLinearSystemMatrixAndVectorElements(ivec2 bl, ivec2 tr, vec3 mean) {\n    // Compute the linear system matrix and vector elements.\n    float xxSum = 0.0f, xySum = 0.0f, xzSum = 0.0f, yySum = 0.0f, yzSum = 0.0f;\n    for(int iy = bl.y; iy < tr.y; iy++) {\n        for(int ix = bl.x; ix < tr.x; ix++) {\n            vec3 diff = getPoint(ix, iy)- mean;\n            xxSum += diff.x * diff.x;\n            xySum += diff.x * diff.y;\n            xzSum += diff.x * diff.z;\n            yySum += diff.y * diff.y;\n            yzSum += diff.y * diff.z;\n        }\n    }\n    // Solve the linear system.\n    float det = xxSum * yySum - xySum * xySum;\n    if(det == 0.0) {\n        return vec2(0); // The output is invalid. The points are all the same or they are collinear.\n    }\n    // Compute the fitted plane h(x,y)=meanZ+barA0*(x-meanX)+barA1*(y-meanY).\n    float barA0 = (yySum * xzSum - xySum * yzSum) / det;\n    float barA1 = (xxSum * yzSum - xySum * xzSum) / det;\n    return vec2(barA0,barA1);\n}\nvec3 calculateMean(ivec2 bl, ivec2 tr) {\n    // Compute the mean of the points.\n    vec3 bar = vec3(0);\n    for(int iy = bl.y; iy < tr.y; iy++) {\n        for(int ix = bl.x; ix < tr.x; ix++) {\n            bar = bar+ getPoint(ix,iy);\n        }\n    }\n    bar = bar/float((tr.y-bl.y)*(tr.x-bl.x));\n    return bar;\n}\nvec4 fitHeightPlaneZ(ivec2 bl, ivec2 tr, vec3 mean) {\n    // barA0*(x-meanX)+barA1*(y-meanY)+ -1.0*(z-meanZ)==0.0\n    vec2 h = calculateLinearSystemMatrixAndVectorElements(bl, tr, mean);\n    // Convert to plane H(x,y)=h.x*x+h.y*y+meanZ+(-h.x*meanX-h.y*meanY).\n    return vec4(h,mean.z,-h.x*mean.x-h.y*mean.y);\n}\nvec4 fitHeightPlaneZ(ivec2 bl, ivec2 tr) {\n    vec3 mean = calculateMean(bl, tr);\n    // Compute the fitted plane h(x,y)=meanZ+barA0*(x-meanX)+barA1*(y-meanY).\n    return fitHeightPlaneZ(bl, tr, mean);\n}\nvec3 normalHeightPlaneZ(vec4 h) {\n    return vec3(h.xy,-1);\n}\nvec3 applyHeightPlaneZ(vec3 p, vec4 h) {\n    return (h.x==0.0&&h.y==0.0) ? p : vec3(p.xy,dot(vec4(p.xy,1,1),h));\n}\n// Author : Sebastien Berube\n// Created : Dec 2015\n// Modified : Jan 2016\n//\n// This shader uses the vanishing point on the image plane in order to infer the world space direction of parallel lines.\n// From 4 points (2D) on the image plane, it will use projective geometry properties in order to generate 4 points (3D) world space.\n// \n// This is a very important concept for 3D scene reconstruction from 2D images.\n//\n// The one line that is important in this shader is : \"p1_to_p2 = dirVanishingPoint\", in function \"resolveAdjacentCorner()\".\n// What this means is : the 3D line starting from the camera center and going towards the vanishing point of 2 parallel lines \n//                      are all parallel with each other (as all lines directed towards this vanishing point are parallel).\n//                      Although parallel lines are nerver supposed to cross each other in reality, they however do on the \n//                      projected image plane, and this allows computation of the vanishing point intersection in 2D first,\n//                      and then inferring 3D direction by casting a ray from the camera center through this vanishing point\n//                      on the image plane.\n//\n// License : Creative Commons Non-commercial (NC) license\n//\n \nstruct Cam { vec3 r; vec3 u; vec3 d; vec3 o;}; //R=Right, U=Up, D=Direction, O=Origin\n\n//Function to cast a ray through a given coordinate (uv) on the image plane.\n//It returns the direction of a 3D Ray.\n//Note : screen center is uv=[0,0]\nvec3 ray(vec2 uv, Cam cam)\n{\n    return normalize(uv.x*cam.r+uv.y*cam.u+cam.d);\n}\n\n//Simple utility function which returns the distance from point \"p\" to a given line segment defined by 2 points [a,b]\nfloat distanceToLineSeg(vec2 p, vec2 a, vec2 b)\n{\n    //e = capped [0,1] orthogonal projection of ap on ab\n    //       p\n    //      /\n    //     /\n    //    a--e-------b\n    vec2 ap = p-a;\n    vec2 ab = b-a;\n    vec2 e = a+clamp(dot(ap,ab)/dot(ab,ab),0.0,1.0)*ab;\n    return length(p-e);\n}\n\n//Utility function returning the intersection point of two 2D lines\n//[p1a,p1b] = line1\n//[p2a,p2b] = line1\nvec2 lineLineIntersection(vec2 p1a, vec2 p1b, vec2 p2a, vec2 p2b)\n{\n    vec2 d1 = (p1b-p1a); //Direction Line 1\n    vec2 d2 = (p2b-p2a); //Direction Line 2\n    vec2 d1n = vec2(d1.y, -d1.x); //orthogonal line to d1 (normal), optimal direction to reach d1 from anywhere\n    float dist = dot(p1a-p2a,d1n);//projection on the optimal direction = distance\n    float rate = dot(d2,d1n); //rate : how much is our d2 line in the optimal direction? (<=1.0)\n    float t = 10000000.0 ; //INFINITY! (rare parallel case)\n    if(rate != 0.0)\n\t\tt = dist/rate; //Starting from p2a, find the distance to reach the other line along d2.\n    return p2a+t*d2;  //start point + distance along d2 * d2 direction = intersection.\n}\n\n//Utility function to compute the distance along a ray to reach a plane, in 3D.\n//The value returned is the distance along ray to the plane intersection.\n//o = ray origin\n//d = ray direction\n//po = plane origin\n//pn = plane normal\nfloat rayPlaneIntersec(vec3 o, vec3 d, vec3 po, vec3 pn) \n{\n    //Same principle as lineLineIntersection() :\n    //\"How far is the plane\"/\"approach rate\".\n    //No need to normalize pn, as dot product above and under cancel out and do not scale the result.\n    return dot(po-o,pn)/dot(d,pn);\n}\n\nstruct screenSpaceQuad{ vec2 a; vec2 b; vec2 c; vec2 d; };\nstruct worldSpaceQuad{  vec3 a; vec3 b; vec3 c; vec3 d; };\n\n//perspectiveCam : the camera from which the points in screen space come from\n//P1 : known world space position of p1\n//p1 : screen space p1 (which is resolved, already)\n//p2 : screen space p2 (which must be adjacent to p1 - cannot be the opposite corner)\n//parallel_a : first point (screen space) in the other line parallel to (p1,p2)\n//parallel_b : second point (screen space) in the other line parallel to (p1,p2)\nvec3 resolveAdjacentCorner(in Cam perspectiveCam, vec3 P1, vec2 p1_resolved, vec2 p2_adjacent, vec2 parallel_a, vec2 parallel_b)\n{\n    //screen space intersection (vanishing point on the projection plane)\n    vec2 ssIntersec = lineLineIntersection(p1_resolved,p2_adjacent,parallel_a,parallel_b);\n    //Vanishing point direction, from camera, in world space.\n    vec3 dirVanishingPoint = ray(ssIntersec, perspectiveCam);\n    vec3 p1_to_p2 = dirVanishingPoint; //Since vanishing point is at \"infinity\", p1_to_p2 == dirVanishingPoint\n    vec3 r2 = ray(p2_adjacent, perspectiveCam);//Ray from camera to p2, in world space\n    \n    //<Line3D intersection : where p1_to_p2 crosses r2>\n    //(Note : this could probably be made simpler with a proper 3D line intersection formula)\n    //Find (rb,p1_to_p2) intersection:\n    vec3 n_cam_p1_p2 = cross(p1_to_p2,r2); //normal to the triangle formed by point p1, point p2 and the camera origin\n    vec3 n_plane_p2 = cross(n_cam_p1_p2,r2); //normal to the plane which is crossed by line p1-p2 at point p2\n    float t = rayPlaneIntersec(P1,p1_to_p2,perspectiveCam.o,n_plane_p2);\n    vec3 p2_ws = P1+t*p1_to_p2;\n    //</Line3D intersection>\n    return p2_ws;\n}\nvec4 stateFit(ivec2 id,vec4 data,vec4 info,bool changeOrigins,bool dragActive,bool display3D) {\n    return fitHeightPlaneZ(max(ivec2(0),id*2-1),min(GRID*2+1,id*2+3));\n}\nvec4 stateRepro(ivec2 id,vec4 data,vec4 info,bool changeOrigins,bool dragActive,bool display3D) {\n    worldSpaceQuad wsQuad;\n    screenSpaceQuad ssQuad;\n\n    int ix = id.x/2,iy=id.y/2;\n    vec4            P01 = T(ix,iy+1),      P11 = T(ix+1,iy+1);\n    vec4            P00 = T(ix,iy  ),      P10 = T(ix+1,iy  );\n    vec2       TL = P01.zw,           TR = P11.zw;\n    vec2       BL = P00.zw,           BR = P10.zw;\n    ssQuad.d = TL-0.5;     ssQuad.c = TR-0.5;\n    ssQuad.a = BL-0.5;     ssQuad.b = BR-0.5;\n\n    Cam perspectiveCam;\n    perspectiveCam.o = vec3(0,0,0);\n    perspectiveCam.r = vec3(1,0,0);\n    perspectiveCam.u = vec3(0,1,0);\n    perspectiveCam.d = vec3(0,0,-1);\n    vec3 ra = ray(ssQuad.a, perspectiveCam); //Find the direction of the ray passing by point a in screen space.\n\t                                      //For the sake of simplicity, screenspace [uv.x,uv.y] = worldspace [x,y]. Z = depth.\n    //Let's place point a in an arbitrary position along the ray ra. \n    //It does not matter at which distance exactly, as it is the relationship between\n    //the corners that is important. The first corner distance simply defines the scaling of the 3D scene.\n    wsQuad.a = perspectiveCam.o + 4.5*ra; //5.5 = arbitrary scaling. Projective geometry does not preserve world space scaling.\n    wsQuad.b = resolveAdjacentCorner(perspectiveCam, wsQuad.a, ssQuad.a, ssQuad.b, ssQuad.c, ssQuad.d);\n    wsQuad.c = resolveAdjacentCorner(perspectiveCam, wsQuad.b, ssQuad.b, ssQuad.c, ssQuad.a, ssQuad.d);\n    wsQuad.d = resolveAdjacentCorner(perspectiveCam, wsQuad.a, ssQuad.a, ssQuad.d, ssQuad.b, ssQuad.c);\n\n    vec3 returned;\n    if((id.y & 1) != 0) {\n        returned = ((id.x & 1) == 0) ? wsQuad.d : wsQuad.c;\n    } else {\n        returned = ((id.x & 1) == 0) ? wsQuad.a : wsQuad.b;\n    }\n    return vec4(returned,0);\n    //return vec4(vec3(id.xyx)/vec3(GRID.xyx*2),0.5).xwyz*vec4(1,1,1,0)+vec4(0,0,0,1);\n}\nvec4 stateUV(ivec2 id,vec4 data,vec4 info,bool changeOrigins,bool dragActive,bool display3D) {\n    vec4 O = vec4(0);\n    if (iTime < 5. || data.x == 0.0) {\n        O.zw = (vec2(id)-vec2(1,0))/vec2(GRID);\n        O.xy = -((vec2(id)-vec2(1,0))/vec2(GRID)*(R-40.)+20.)/R;\n        if(O.x == 0.0 && O.y == 0.0) {\n            O.x = -0.000001;\n        }\n        if(id.x>1&&id.x<4&&id.y>1&&id.y<4) O-=vec4(0,0,-0.06,0.036)+.04*(vec2(id)-vec2(2.5,2.5)).xyxy;\n        if(id.x>3&&id.x<6&&id.y>1&&id.y<4) O-=vec4(0,0,-0.04,0.035)+.06*(vec2(id)-vec2(4.5,2.5)).xyxy;\n        return O;\n    }\n    if(!changeOrigins && display3D) {\n        O = vec4(data);\n        return O;\n    }\n    if(!dragActive) {\n        O = vec4(data);\n        return O;\n    }\n    if(id.x != int(info.x) || id.y != int(info.y)) {\n        O = vec4(data);\n        return O;\n    }\n    if(changeOrigins) {\n        if(display3D) {\n            O = vec4(-abs(data.xy), clamp((iMouse.xy-20.-0.125*R)/(R-40.-0.25*R),-0.1875,1.1875));\n        } else {\n            O = vec4(-abs(data.xy), clamp((iMouse.xy-20.)/(R-40.),0.,1.));\n        }\n        if(O.x == 0.0 && O.y == 0.0) {\n            O.x = -0.000001;\n        }\n        return O;\n    }\n    O = vec4(iMouse.xy/R, data.zw);\n    if(O.x == 0.0 && O.y == 0.0) {\n        O.x = 0.000001;\n    }\n   \n    return O;\n}\nvoid mainImage(out vec4 O, vec2 U) {\n    bool changeOrigins = key(65);\n    bool dragActive = iMouse.z > 0.0;\n    bool display3D = key(67);\n    vec4 data = texelFetch(iChannel0,ivec2(U),0);\n    vec4 info = texelFetch(iChannel0,ivec2(0),0);\n\n    ivec2 id = ivec2(U);\n    if(id.x == 0 && id.y == 0) {\n        if(float(dragActive)==info.z) {\n            O = info;\n            return;\n        }\n        if(!dragActive) {\n            O = vec4(0);\n            return;\n        }\n        float mdist = 1e10;\n        vec2 mid = vec2(0);\n        vec2 mouse = iMouse.xy;\n        if(changeOrigins && display3D) {\n            mouse = (iMouse.xy-20.-0.125*R)/(R-40.-0.25*R)*R;\n        }\n        for(int iy = 0; iy <= GRID.y; iy++) {\n            for(int ix = 0; ix <= GRID.x; ix++) {\n                vec4 curr = T(ix,iy);\n                vec2 point = ((changeOrigins)? curr.zw:abs(curr.xy))*R;\n                float dist = length(mouse-point);\n                if(dist<mdist) {\n                    mid = vec2(ix+1,iy);\n                    mdist = dist;\n                }\n            }\n        }\n        if(mdist > 100.0) {\n            O = vec4(0);\n            return;\n        }\n        O = vec4(mid, 1, 0);\n        return;\n    }\n    if(id.x == 0 && id.y == 1) {\n        if(!dragActive || changeOrigins) {\n            O = data;\n            return;\n        }\n        O = vec4(iMouse/R.xyxy);\n        return;\n    }\n    if(id.x>=1&&id.x<GRID.x+2&&id.y<=GRID.y) {\n        O = stateUV(id,data,info,changeOrigins,dragActive,display3D);\n        return;\n    }\n    if(id.x>=GRID.x+2&&id.x<GRID.x+2+GRID.x*2&&id.y<GRID.y*2) {\n        O = stateRepro(id-ivec2(GRID.x+2,0),data,info,changeOrigins,dragActive,display3D);\n        return;\n    }\n    if(id.x>=GRID.x+2+GRID.x*2&&id.x<GRID.x+2+GRID.x*2+GRID.x&&id.y<GRID.y) {\n        O = stateFit(id-ivec2(GRID.x+2+GRID.x*2,0),data,info,changeOrigins,dragActive,display3D);\n        return;\n    }\n    if(id.x>=1&&id.x<49&&id.y>=1&&id.y<28) {\n        O = vec4(id*0,0,0)/128.;\n        return;\n    }\n    O = vec4(0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define S 1\n#define GRID ivec2(8,6)\n\n#define T(i,j) texelFetch(iChannel0,ivec2(i+1,j),0)\n#define TR(i,j) texelFetch(iChannel0,ivec2(i+2+GRID.x,j),0)\n#define R (iResolution.xy)\n\nfloat cross2d( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\n// From: Iq\n// https://www.shadertoy.com/view/lsBSDm\n// given a point p and a quad defined by four points {a,b,c,d}, return the bilinear\n// coordinates of p in the quad. Returns (-1,-1) if the point is outside of the quad.\nfloat cross2( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = cross2( g, f );\n    if ( k2==0.0 ) k2 = 0.001; \n    float k1 = cross2( e, f ) + cross2( h, g );\n    float k0 = cross2( h, e );\n    \n    float w = k1*k1 - 4.0*k0*k2;\n    \n    if( w<0.0 ) return vec2(-1.0);\n\n    w = sqrt( w );\n    \n    float v1 = (-k1 - w)/(2.0*k2);\n    float v2 = (-k1 + w)/(2.0*k2);\n    float u1 = (h.x - f.x*v1)/(e.x + g.x*v1);\n    float u2 = (h.x - f.x*v2)/(e.x + g.x*v2);\n    bool  b1 = v1>0.0 && v1<1.0 && u1>0.0 && u1<1.0;\n    bool  b2 = v2>0.0 && v2<1.0 && u2>0.0 && u2<1.0;\n    \n    vec2 res = vec2(-1.0);\n\n    if(  b1 && !b2 ) res = vec2( u1, v1 );\n    if( !b1 &&  b2 ) res = vec2( u2, v2 );\n    \n    return res;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}