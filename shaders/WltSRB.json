{
    "Shader": {
        "info": {
            "date": "1584222913",
            "description": "Rendering in ACEScg retains bounce colors better than rendering in sRGB. See code for more info. Settings are in the Common tab.\ncamera controls via mouse + shift key\nlight controls via WASD/Arrow keys",
            "flags": 48,
            "hasliked": 0,
            "id": "WltSRB",
            "likes": 48,
            "name": "ACEScg",
            "published": 3,
            "tags": [
                "pathtracing",
                "rendering",
                "tonemapping",
                "tonemap",
                "aces",
                "acescg"
            ],
            "usePreview": 0,
            "username": "TinyTexel",
            "viewed": 2620
        },
        "renderpass": [
            {
                "code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\nGood intro to ACES: https://chrisbrejon.com/cg-cinematography/chapter-1-5-academy-color-encoding-system-aces/\n\nOn Average the rendering with sharp RGB primaries produces results closer to the spectral refrence:\nhttps://computergraphics.stackexchange.com/questions/8152/for-shader-math-why-should-linear-rgb-keep-the-gamut-of-srgb\n\nRendering in ACEScg retains bounce colors better than rendering in sRGB. \nThat is because the AP1 primaries (i.e. ACEScg RGB primaries) cover a wider gamut than the Rec. 709 primaries which sRGB uses.\nThis means that saturated sRGB colors are not fully saturated in ACEScg.\nYou can still get strongly saturated colors by picking colors in ACEScg directly instead of doing so in sRGB.\n\nHowever, picking colors in sRGB and converting them to ACEScg before rendering has two advantages.\n\nFirst, the sRGB gamut lies largely inside and covers a decent portion of the Pointer's gamut, a comprehensive sampling of naturally occuring albedos.\nSo using sRGB to pick albedos ensures your values to be reasonable.\n(see Rec. 709 / sRGB section here: https://www.tftcentral.co.uk/articles/pointers_gamut.htm)\n\nSecond, since ACEScg has a wider gamut than sRGB, there is no guarantee that your rendering results will be in gamut (for LDR displays).\nPicking colors in sRGB mitigates that problem even if it doesn't completely solve it.\nFor example bounce colors can still get saturated to a point where they are not longer in sRGB gamut. \nSo softclipping the rendering+tonemapping result before applying the inverse sRGB EOTF might be a good idea.\n\ncamera controls via mouse + shift key\nlight controls via WASD/Arrow keys\n\nCommon:  settings\nBufferA: rendering\nImage:   tonemapping\n\n*/\nfloat sRGB_InvEOTF(float c)\n{\n    return c > 0.0031308 ? pow(c, 1.0/2.4) * 1.055 - 0.055 : c * 12.92;\n}\n\nfloat sRGB_EOTF(float c)\n{\n    return c > 0.04045 ? pow(c / 1.055 + 0.055/1.055, 2.4) : c / 12.92;\n}\n\nvec3 sRGB_InvEOTF(vec3 rgb)\n{\n    return If(greaterThan(rgb, vec3(0.0031308)), pow(rgb, vec3(1.0/2.4)) * 1.055 - 0.055, rgb * 12.92);\n}\n\nvec3 sRGB_EOTF(vec3 rgb)\n{\n    return If(greaterThan(rgb, vec3(0.04045)), pow(rgb / 1.055 + 0.055/1.055, vec3(2.4)), rgb / 12.92);\n}\n\n\nfloat ACEScc_from_Linear(float lin) \n{    \n    if (lin <= 0.0) \n        return -0.3584474886;\n    \n    if (lin < exp2(-15.0))\n    \treturn log2(exp2(-16.0) + lin * 0.5) / 17.52 + (9.72/17.52);\n    \n    return log2(lin) / 17.52 + (9.72/17.52);\n}\n\nvec3 ACEScc_from_Linear(vec3 lin) \n{\n    return vec3(ACEScc_from_Linear(lin.r),\n                ACEScc_from_Linear(lin.g),\n                ACEScc_from_Linear(lin.b));\n}\n\n\nfloat Linear_from_ACEScc(float cc) \n{\n    if (cc < -0.3013698630)\n    \treturn exp2(cc * 17.52 - 9.72)*2.0 - exp2(-16.0)*2.0;\n    \n    return exp2(cc * 17.52 - 9.72);\n}\n\nvec3 Linear_from_ACEScc(vec3 cc) \n{\n    return vec3(Linear_from_ACEScc(cc.r),\n                Linear_from_ACEScc(cc.g),\n                Linear_from_ACEScc(cc.b));\n}\n\n\nfloat ACEScct_from_Linear(float lin)\n{\n    if(lin > 0.0078125)\n        return log2(lin) / 17.52 + (9.72/17.52);\n    \n\treturn lin * 10.5402377416545 + 0.0729055341958355;\n}\n\nvec3 ACEScct_from_Linear(vec3 lin) \n{\n    return vec3(ACEScct_from_Linear(lin.r),\n                ACEScct_from_Linear(lin.g),\n                ACEScct_from_Linear(lin.b));\n}\n\n\nfloat Linear_from_ACEScct(float cct)\n{\n    if(cct > 0.155251141552511)\n        return exp2(cct * 17.52 - 9.72);\n    \n\treturn cct / 10.5402377416545 - (0.0729055341958355/10.5402377416545);\n}\n\nvec3 Linear_from_ACEScct(vec3 cct) \n{\n    return vec3(Linear_from_ACEScct(cct.r),\n                Linear_from_ACEScct(cct.g),\n                Linear_from_ACEScct(cct.b));\n}\n\n\n\n// ACES fit by Stephen Hill (@self_shadow)\n// https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl \n\n// sRGB => XYZ => D65_2_D60 => AP1\nconst mat3 sRGBtoAP1 = mat3\n(\n\t0.613097, 0.339523, 0.047379,\n\t0.070194, 0.916354, 0.013452,\n\t0.020616, 0.109570, 0.869815\n);\n\nconst mat3 AP1toSRGB = mat3\n(\n     1.704859, -0.621715, -0.083299,\n    -0.130078,  1.140734, -0.010560,\n    -0.023964, -0.128975,  1.153013\n);\n\n// AP1 => RRT_SAT\nconst mat3 RRT_SAT = mat3\n(\n\t0.970889, 0.026963, 0.002148,\n\t0.010889, 0.986963, 0.002148,\n\t0.010889, 0.026963, 0.962148\n);\n\n\n// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\nconst mat3 ACESInputMat = mat3\n(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3 ACESOutputMat = mat3\n(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 x)\n{\n    vec3 a = (x            + 0.0245786) * x;\n    vec3 b = (x * 0.983729 + 0.4329510) * x + 0.238081;\n    \n    return a / b;\n}\n\n\nvec3 ToneTF0(vec3 x)\n{\n    vec3 a = (x            + 0.0509184) * x;\n    vec3 b = (x * 0.973854 + 0.7190130) * x + 0.0778594;\n    \n    return a / b;\n}\n\nvec3 ToneTF1(vec3 x)\n{\n    vec3 a = (x          + 0.0961727) * x;\n    vec3 b = (x * 0.9797 + 0.6157480) * x + 0.213717;\n    \n    return a / b;\n}\n\nvec3 ToneTF2(vec3 x)\n{\n    vec3 a = (x            + 0.0822192) * x;\n    vec3 b = (x * 0.983521 + 0.5001330) * x + 0.274064;\n    \n    return a / b;\n}\n\n\n// https://twitter.com/jimhejl/status/1137559578030354437\nvec3 ToneMapFilmicALU(vec3 x)\n{\n    x *= 0.665;\n    \n   #if 0\n    x = max(vec3(0.0), x - 0.004f);\n    x = (x * (6.2 * x + 0.5)) / (x * (6.2 * x + 1.7) + 0.06);\n    \n    x = sRGB_EOTF(x);\n   #else\n    x = max(vec3(0.0), x);\n    x = (x * (6.2 * x + 0.5)) / (x * (6.2 * x + 1.7) + 0.06);\n    \n    x = pow(x, vec3(2.2));// using gamma instead of sRGB_EOTF + without x - 0.004f looks about the same\n   #endif\n    \n    return x;\n}\n\n\nvec3 Tonemap_ACESFitted(vec3 srgb)\n{\n    vec3 color = srgb * ACESInputMat;\n   \n   #if 1\n    color = ToneTF2(color);\n   #else\n    color = RRTAndODTFit(color);\n   #endif\n    \n    color = color * ACESOutputMat;\n\n    return color;\n}\n\nvec3 Tonemap_ACESFitted2(vec3 acescg)\n{\n    vec3 color = acescg * RRT_SAT;\n    \n   #if 1\n    color = ToneTF2(color); \n   #elif 1\n    color = RRTAndODTFit(color);\n   #elif 1\n    color = ToneMapFilmicALU(color);\n   #endif\n    \n    color = color * ACESOutputMat;\n    //color = ToneMapFilmicALU(color);\n\n    return color;\n}\n\nvec3 ColorGrade(vec3 col)\n{\n    col = ACEScct_from_Linear(col);\n    {\n        vec3 s = vec3(1.1, 1.2, 1.0);\n        vec3 o = vec3(0.1, 0.0, 0.1);\n        vec3 p = vec3(1.4, 1.3, 1.3);\n        \n        col = pow(col * s + o, p);\n    }\n    col = Linear_from_ACEScct(col);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 tex = fragCoord.xy / iResolution.xy;\n    \n    vec3 col = textureLod(iChannel0, tex, 0.0).rgb;\n\n    col *= exp2(EXPOSURE);\n    \n    #ifdef DO_COLORGRADE\n\tcol = ColorGrade(col);\n    #endif\n    \n    //if(false)\n    {\n        #if MODE == 0\n        col = Tonemap_ACESFitted2(col);\n        #elif MODE == 1\n        col = Tonemap_ACESFitted(col);\n        #else\n        col = RRTAndODTFit(col);\n        #endif\n    }\n    \n    fragColor = vec4(sRGB_InvEOTF(clamp(col, 0.0, 1.0)), 0.0);\n    //fragColor = vec4(col, 0.0);\n}\n\n\n\n/*\n\nvec3 PQ(vec3 Lo)\n{\n    const float c1 = 107.0 / 128.0;\n    const float c2 = 2413.0 / 128.0;\n    const float c3 = 2392.0 / 128.0;\n    const float m1 = 1305.0 / 8192.0;\n    const float m2 = 2523.0 / 32.0;\n    \n    vec3 Lp = pow(Lo, vec3(m1));\n    \n    return pow((c1 + c2 * Lp) / (1.0 + c3 * Lp), vec3(m2));\n}\n\n*/",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\nGood intro to ACES: https://chrisbrejon.com/cg-cinematography/chapter-1-5-academy-color-encoding-system-aces/\n\nOn Average the rendering with sharp RGB primaries produces results closer to the spectral refrence:\nhttps://computergraphics.stackexchange.com/questions/8152/for-shader-math-why-should-linear-rgb-keep-the-gamut-of-srgb\n\nRendering in ACEScg retains bounce colors better than rendering in sRGB. \nThat is because the AP1 primaries (i.e. ACEScg RGB primaries) cover a wider gamut than the Rec. 709 primaries which sRGB uses.\nThis means that saturated sRGB colors are not fully saturated in ACEScg.\nYou can still get strongly saturated colors by picking colors in ACEScg directly instead of doing so in sRGB.\n\nHowever, picking colors in sRGB and converting them to ACEScg before rendering has two advantages.\n\nFirst, the sRGB gamut lies largely inside and covers a decent portion of the Pointer's gamut, a comprehensive sampling of naturally occuring albedos.\nSo using sRGB to pick albedos ensures your values to be reasonable.\n(see Rec. 709 / sRGB section here: https://www.tftcentral.co.uk/articles/pointers_gamut.htm)\n\nSecond, since ACEScg has a wider gamut than sRGB, there is no guarantee that your rendering results will be in gamut (for LDR displays).\nPicking colors in sRGB mitigates that problem even if it doesn't completely solve it.\nFor example bounce colors can still get saturated to a point where they are not longer in sRGB gamut. \nSo softclipping the rendering+tonemapping result before applying the sRGB EOTF might be a good idea.\n\ncamera controls via mouse + shift key\nlight controls via WASD/Arrow keys\n\nCommon:  settings\nBufferA: rendering\nImage:   tonemapping\n\n*/\n\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_SHIFT 0x10\n#define KEY_A 0x41\n#define KEY_D 0x44\n#define KEY_S 0x53\n#define KEY_W 0x57\n\n#define KeyBoard iChannel1\n\nfloat ReadKey(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 0), 0).x;}\n\n\n#define VarTex iChannel0\n#define OutCol outCol\n#define OutChannel w\n\n#define WriteVar(v, cx, cy) {if(uv.x == float(cx) && uv.y == float(cy)) OutCol.OutChannel = v;}\n#define WriteVar4(v, cx, cy) {WriteVar(v.x, cx, cy) WriteVar(v.y, cx, cy + 1) WriteVar(v.z, cx, cy + 2) WriteVar(v.w, cx, cy + 3)}\n\nfloat ReadVar(int cx, int cy) {return texelFetch(VarTex, ivec2(cx, cy), 0).OutChannel;}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n\n\n// sRGB => XYZ => D65_2_D60 => AP1\nconst mat3 sRGBtoAP1 = mat3\n(\n\t0.613097, 0.339523, 0.047379,\n\t0.070194, 0.916354, 0.013452,\n\t0.020616, 0.109570, 0.869815\n);\n\nvec3 MapColor(vec3 srgb)\n{\n    #if MODE == 0\n    return srgb * sRGBtoAP1;\n    #else\n    return srgb;\n    #endif\n}\n\nfloat Intersect_Scene(\nvec3 rp, vec3 rd,\nout float t, out vec3 n, out vec3 a)\n{\n     float hit;\n   \n    {\n    \tvec2 tt; vec3 n0, n1;\n\t\tfloat th = Intersect_Ray_Cube(rp, rd, vec3(0.0, -0.8, 0.0), vec3(1.5, 0.05, 1.5), /*out:*/ tt, n0, n1);\n      \n        hit = th > 0.0 ? 1.0 : 0.0;\n        t = tt.x;\n        n = n0;\n        a = MapColor(AlbedoPlane0);\n        \n        vec3 p = rp + rd * tt.x;\n        if((p.x > 0.0) == (p.z > 0.0)) a = MapColor(AlbedoPlane1);\n    }\n    \n    {\n        vec2 tt;\n\t\tfloat th = Intersect_Ray_Sphere(rp, rd, vec3(0.0), 0.5, /*out:*/ tt);\n        \n        if(th > 0.0)\n        if(hit <= 0.0 || tt.x < t)\n        {\n            t = tt.x;\n            n = normalize(rp + rd * tt.x);\n            a = MapColor(AlbedoSphere);\n            \n            hit = 1.0;\n        }\n    }\n    \n    return hit;\n}\n\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{     \n    vec2 uv = uv0.xy - 0.5;\n\tvec2 tex = uv0.xy / iResolution.xy;\n    vec2 tex21 = tex * 2.0 - vec2(1.0);\n    \n    vec4 mouseAccu  = ReadVar4(1, 0);\n    vec4 wasdAccu   = ReadVar4(2, 0);\n    float frameAccu = ReadVar (3, 0);\n\n    vec2 ang = vec2(Pi * 0.3, -Pi * 0.02);\n    ang += mouseAccu.xy * 0.008;\n\n    Cam cam = NewCam(ang, Pi * 0.5, iResolution.x / iResolution.y);\n    //vec3 cpos = -cam.Front * 2.5;\n    float cdist = exp2(1.0 + mouseAccu.w * 0.02);\n    vec3 cpos = -cam.Front * cdist;\n\n    vec3 pxId  = vec3(frameAccu, uv); \n         pxId *= vec3( 0.76032, 1.47035, 0.92526); \n         pxId += vec3(-0.69060, 0.02293, 0.68109);\n    \n    uint h = WellonsHash(uvec3(uv, iFrame), 0u).x;\n    \n    {\n        vec2 off;\n        {\n            // filter kernel:\n            float h0 = Hash11(h);\n            float h1 = Hash11(h);\n            \n        \toff = vec2(Sample_Triangle(h0), \n                       Sample_Triangle(h1));\n        }\n           \n        #if 1\n        {\n            // bloom kernel:\n            float h0 = Hash11(h);\n            float h1 = Hash01(h);\n            \n        \toff += AngToVec(h0 * Pi) * Pow2(log2(1.0 - Pow2(h1))) * 0.25;\n        }\n        #endif\n        \n        tex21 = (uv0.xy + off) / iResolution.xy * 2.0 - vec2(1.0);\n    }\n    \n    vec2 llp;// local sample pos on lens\n    {\n        float h0 = Hash11(h);\n        float h1 = Hash01(h);\n        \n        llp = Sample_Disk(h0, h1);\n        llp *= 0.05;\n    }\n    \n    vec3 glp;// global sample pos on lens\n    float S1 = cdist - 0.0;// set sphere sharp\n    vec3 rdir = NewRay(cam, tex21, llp, S1, /*out:*/ glp);\n    \n    vec2 lightAng = vec2(Pi * 1.0, Pi * 0.3);\n    lightAng.x += (wasdAccu.y - wasdAccu.w) * 0.06; \n    lightAng.y += (wasdAccu.x - wasdAccu.z) * 0.04;    \n    \n    vec3 light0 = AngToVec(lightAng);\n    vec3 light = light0;\n    {\n        float h0 = Hash11(h);\n        float h1 = Hash01(h);\n        \n        h1 = mix(0.999, 1.0, h1);\n        \n        light = Sample_Sphere(h0, h1, light);\n    }\n    \n    \n    vec3 pot = vec3(1.0);\n    vec3 col = vec3(0.0);\n    \n    vec3 pos = cpos + glp;\n    vec3 dir = rdir;\n\n    for(float i = 0.0; i < 4.0; ++i)\n    {\n        bool hit; float t; vec3 n; vec3 a;\n        hit = Intersect_Scene(pos, dir, /*out:*/ t, n, a) == 1.0;\n        \n        if(hit)\n    \t{\n    \t    vec3 p = pos + dir * t;\n\t\n    \t    pot *= a;\n    \t    \n    \t    float sh;\n    \t    {\n    \t        float t2; vec3 n2; vec3 a2;\n    \t        sh = Intersect_Scene(p + n * 0.0001, light, /*out:*/ t2, n2, a2);\n    \t        sh = 1.0 - sh;\n    \t    }\n    \t    \n    \t    col += pot * clamp01(dot(light, n)) * sh * 1.0;// * RcpPi;// impl scale prim light E by Pi\n    \t    \n    \t    pos = p + n * 0.0001;\n    \t    {\n    \t        float h0 = Hash11(h);\n    \t    \tfloat h1 = Hash01(h);\n    \t        \n    \t    \tdir = Sample_ClampedCosineLobe(h0, h1, n);\n    \t    }\n    \t    \n    \t} \n    \telse \n    \t{\n    \t    //col += pot * MapColor(textureLod(iChannel2, dir, 0.0).rgb);\n    \t    \n    \t    if(i == 0.0 && dot(light0, dir) > 0.999) col += vec3(Pi);\n    \t    \n    \t    break;\n    \t}\n    }\n    \n    \n    vec3 colLast = textureLod(iChannel0, tex, 0.0).rgb;\n    \n    col = mix(colLast, col, 1.0 / (frameAccu + 1.0));    \n    \n    outCol = vec4(col, 0.0);\n    \n    \n    {\n        vec4 iMouseLast     = ReadVar4(0, 0);\n        vec4 iMouseAccuLast = ReadVar4(1, 0);\n        vec4 wasdAccuLast   = ReadVar4(2, 0);\n        float frameAccuLast = ReadVar (3, 0);\n        float modeLast      = ReadVar (4, 0);\n\n\n        bool shift = ReadKey(KEY_SHIFT) != 0.0;\n\n        float kW = ReadKey(KEY_W);\n        float kA = ReadKey(KEY_A);\n        float kS = ReadKey(KEY_S);\n        float kD = ReadKey(KEY_D);\n\n        float left  = ReadKey(KEY_LEFT);\n        float right = ReadKey(KEY_RIGHT);\n        float up    = ReadKey(KEY_UP);\n        float down  = ReadKey(KEY_DOWN);\n        \n        \n        bool anyK = false;\n        \n        anyK = anyK || iMouse.z > 0.0;\n        anyK = anyK || shift;\n        anyK = anyK || kW != 0.0;\n        anyK = anyK || kA != 0.0;\n        anyK = anyK || kS != 0.0;\n        anyK = anyK || kD != 0.0;\n        anyK = anyK || left  != 0.0;\n        anyK = anyK || right != 0.0;\n        anyK = anyK || up    != 0.0;\n        anyK = anyK || down  != 0.0;\n        \n        \n        frameAccuLast += 1.0;\n        if(anyK || float(MODE) != modeLast) frameAccuLast = 0.0;\n        \n\n        vec4 wasdAccu = wasdAccuLast;\n        wasdAccu += vec4(kW, kA, kS, kD);\n        wasdAccu += vec4(up, left, down, right);        \n\n        \n        vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n\n        bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n        vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n        vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n\n        vec4 iMouseAccu = iMouseAccuLast + vec4(mouseDelta2, mouseDelta3);\n\n        \n        WriteVar4(iMouse,        0, 0);\n        WriteVar4(iMouseAccu,    1, 0);\n        WriteVar4(wasdAccu,      2, 0);\n        WriteVar (frameAccuLast, 3, 0);\n        WriteVar (float(MODE)  , 4, 0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\nGood intro to ACES: https://chrisbrejon.com/cg-cinematography/chapter-1-5-academy-color-encoding-system-aces/\n\nRendering in ACEScg retains bounce colors better than rendering in sRGB. \nThat is because the AP1 primaries (i.e. ACEScg RGB primaries) cover a wider gamut than the Rec. 709 primaries which sRGB uses.\nThis means that saturated sRGB colors are not fully saturated in ACEScg.\nYou can still get strongly saturated colors by picking colors in ACEScg directly instead of doing so in sRGB.\n\nHowever, picking colors in sRGB and converting them to ACEScg before rendering has two advantages.\n\nFirst, the sRGB gamut lies largely inside and covers a decent portion of the Pointer's gamut, a comprehensive sampling of naturally occuring albedos.\nSo using sRGB to pick albedos ensures your values to be reasonable.\n(see Rec. 709 / sRGB section here: https://www.tftcentral.co.uk/articles/pointers_gamut.htm)\n\nSecond, since ACEScg has a wider gamut than sRGB, there is no guarantee that your rendering results will be in gamut (for LDR displays).\nPicking colors in sRGB mitigates that problem even if it doesn't completely solve it.\nFor example bounce colors can still get saturated to a point where they are not longer in sRGB gamut. \nSo softclipping the rendering+tonemapping result before applying the sRGB EOTF might be a good idea.\n\ncamera controls via mouse + shift key\nlight controls via WASD/Arrow keys\n\nCommon:  settings\nBufferA: rendering\nImage:   tonemapping\n\n*/\n\n\n#define EXPOSURE 1.0\n// #define DO_COLORGRADE\n\n#define MODE 0\n/*\nMODE 0: rendering in ACEScg (AP1      primaries, D60 white point) + tonemapping with desaturated AP1 primaries\nMODE 1: rendering in sRGB   (Rec. 709 primaries, D65 white point) + tonemapping with desaturated AP1 primaries\nMODE 2: rendering + tonemapping in sRGB\n*/\n\n#if MODE != 0\n#undef DO_COLORGRADE\n#endif\n\n// albedos in linear sRGB (see MapColor() in Buffer A for sRGB->ACEScg conversion)\nconst vec3 AlbedoSphere = vec3(0.02, 1.0, 0.05);\nconst vec3 AlbedoPlane0 = vec3(1.00, 0.0, 0.05);\nconst vec3 AlbedoPlane1 = vec3(0.00, 0.1, 1.00);\n\n///////////////////////////////////////////////////////////////////////////\n//=======================================================================//\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\nconst float RcpPi = 1.0 / Pi;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\n\nvec3 AngToVec(vec2 ang)\n{\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    return vec3(cosPhi * cosTheta, \n                         sinTheta, \n                sinPhi * cosTheta); \n}\n\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nstruct Cam\n{\n\tvec3 Front, Right, Up;\n\tfloat Aspect;\n\tfloat AxisLen;\t\n};\n\nCam NewCam(vec2 ang, float fov, float aspect)\n{\n    Cam cam;\n\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    cam.Front = vec3(cosPhi * cosTheta, \n                              sinTheta, \n                     sinPhi * cosTheta);\n\n    cam.Right = vec3(-sinPhi, 0.0, cosPhi);\n    cam.Up    = cross(cam.Right, cam.Front);\n\n    cam.Aspect = aspect;\n    cam.AxisLen = aspect * tan(Pi05 - fov * 0.5);\n\n    return cam;\n}\n\n// tc [-1..1]\nvec3 NewRay(Cam cam, vec2 tc)\n{\n    tc.x *= cam.Aspect;\n\n    vec3 imgPos = cam.Front * cam.AxisLen + (cam.Right * tc.x + cam.Up * tc.y);\n    \n    vec3 dir = normalize(imgPos);\n\n    return dir;\n}\n\n// tc [-1..1]\nvec3 NewRay(Cam cam, vec2 tc, vec2 llp, float S1, out vec3 glp)\n{\n    tc.x *= cam.Aspect;\n\n    vec3 imgPos = cam.Front + (cam.Right * tc.x + cam.Up * tc.y) / cam.AxisLen;\n    \n    glp = cam.Right * llp.x + cam.Up * llp.y;\n    \n    vec3 dir = normalize(imgPos * S1 - glp);\n\n    return dir;\n}\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tcp\t\t: cube position\n\tcth\t\t: cube thickness (cth = 0.5 -> unit cube)\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(0.5), OUT t);\n*/\nfloat Intersect_Ray_Cube(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout vec2 t)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n\tvec3 o = If(lessThan(rd, vec3(0.0)), -cth, cth);\n\t\n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\tt.x = max(uf.x, max(uf.y, uf.z));\n\tt.y = min(ub.x, min(ub.y, ub.z));\n\t\n\t// if(ray start == inside cube) \n\tif(t.x < 0.0 && t.y > 0.0) {t.xy = t.yx;  return 1.0;}\n\t\n\treturn t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\n/*\n[...]\n\nOUT:\n\tn0 : normal for t.x\n\tn1 : normal for t.y\n\nEXAMPLE:\t\n\tvec2 t; vec3 n0, n1;\n\tfloat hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(0.5), OUT t, n0, n1);\n*/\nfloat Intersect_Ray_Cube(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout vec2 t, out vec3 n0, out vec3 n1)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n    vec3 os = If(lessThan(rd, vec3(0.0)), vec3(1.0), vec3(-1.0));\n    //vec3 os = sign(-rd);\n\tvec3 o = -cth * os;\n\t\n    \n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\t//t.x = max(uf.x, max(uf.y, uf.z));\n\t//t.y = min(ub.x, min(ub.y, ub.z));\n\t\n    if(uf.x > uf.y) {t.x = uf.x; n0 = vec3(os.x, 0.0, 0.0);} else \n                    {t.x = uf.y; n0 = vec3(0.0, os.y, 0.0);}\n    if(uf.z > t.x ) {t.x = uf.z; n0 = vec3(0.0, 0.0, os.z);}\n    \n    if(ub.x < ub.y) {t.y = ub.x; n1 = vec3(os.x, 0.0, 0.0);} else \n                    {t.y = ub.y; n1 = vec3(0.0, os.y, 0.0);}\n    if(ub.z < t.y ) {t.y = ub.z; n1 = vec3(0.0, 0.0, os.z);}\n    \n    \n\t// if(ray start == inside cube) \n\tif(t.x < 0.0 && t.y > 0.0) \n    {\n        t.xy = t.yx;  \n        \n        vec3 n00 = n0;\n        n0 = n1;\n        n1 = n00;\n        \n        return 1.0;\n    }\n\t\n\treturn t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tsp2\t\t: sphere position\n\tsr2\t\t: sphere radius squared\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Sphere(pos, dir, vec3(0.0), 1.0, OUT t);\n*/\nfloat Intersect_Ray_Sphere(\nvec3 rp, vec3 rd, \nvec3 sp, float sr2, \nout vec2 t)\n{\t\n\trp -= sp;\n\t\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rp, rd);\n\tfloat c = dot(rp, rp) - sr2;\n\t\n\tfloat D = b*b - 4.0*a*c;\n\t\n\tif(D < 0.0) return 0.0;\n\t\n\tfloat sqrtD = sqrt(D);\n\t// t = (-b + (c < 0.0 ? sqrtD : -sqrtD)) / a * 0.5;\n\tt = (-b + vec2(-sqrtD, sqrtD)) / a * 0.5;\n\t\n\t// if(start == inside) ...\n\tif(c < 0.0) t.xy = t.yx;\n\n\t// t.x > 0.0 || start == inside ? infront : behind\n\treturn t.x > 0.0 || c < 0.0 ? 1.0 : -1.0;\n}\n\n/*\nSOURCE: \n\t\"Building an Orthonormal Basis from a 3D Unit Vector Without Normalization\"\n\t\thttp://orbit.dtu.dk/files/126824972/onb_frisvad_jgt2012_v2.pdf\n\t\t\n\t\"Building an Orthonormal Basis, Revisited\" \n\t\thttp://jcgt.org/published/0006/01/01/\n\t\n\t- modified for right-handedness here\n\t\nDESCR:\n\tConstructs a right-handed, orthonormal coordinate system from a given vector of unit length.\n\nIN:\n\tn  : normalized vector\n\t\nOUT:\n\tox\t: orthonormal vector\n\toz\t: orthonormal vector\n\t\nEXAMPLE:\n\tfloat3 ox, oz;\n\tOrthonormalBasis(N, OUT ox, oz);\n*/\nvoid OrthonormalBasisRH(vec3 n, out vec3 ox, out vec3 oz)\n{\n\tfloat sig = n.z < 0.0 ? 1.0 : -1.0;\n\t\n\tfloat a = 1.0 / (n.z - sig);\n\tfloat b = n.x * n.y * a;\n\t\n\tox = vec3(1.0 + sig * n.x * n.x * a, sig * b, sig * n.x);\n\toz = vec3(b, sig + n.y * n.y * a, n.y);\n}\n\n// s0 [-1..1], s1 [-1..1]\n// samples spherical cap for s1 [cosAng05..1]\n// samples hemisphere if s1 [0..1]\nvec3 Sample_Sphere(float s0, float s1)\n{\n    float ang = Pi * s0;\n    float s1p = sqrt(1.0 - s1*s1);\n    \n    return vec3(cos(ang) * s1p, \n                           s1 , \n                sin(ang) * s1p);\n}\n\n// s0 [-1..1], s1 [-1..1]\n// samples spherical cap for s1 [cosAng05..1]\nvec3 Sample_Sphere(float s0, float s1, vec3 normal)\n{\t \n    vec3 sph = Sample_Sphere(s0, s1);\n\n    vec3 ox, oz;\n    OrthonormalBasisRH(normal, ox, oz);\n\n    return (ox * sph.x) + (normal * sph.y) + (oz * sph.z);\n}\n\n// s0 [-1..1], s1 [-1..1]\nvec3 Sample_Hemisphere(float s0, float s1, vec3 normal)\n{\n    vec3 smpl = Sample_Sphere(s0, s1);\n\n    if(dot(smpl, normal) < 0.0)\n        return -smpl;\n    else\n        return smpl;\n}\n\n// s0 [-1..1], s1 [0..1]\nvec2 Sample_Disk(float s0, float s1)\n{\n    return vec2(cos(Pi * s0), sin(Pi * s0)) * sqrt(s1);\n}\n\n// s0 [-1..1], s1 [0..1]\nvec3 Sample_ClampedCosineLobe(float s0, float s1)\n{\t \n    vec2 d  = Sample_Disk(s0, s1);\n    float y = sqrt(clamp01(1.0 - s1));\n    \n    return vec3(d.x, y, d.y);\n}\n\n// s0 [-1..1], s1 [0..1]\nvec3 Sample_ClampedCosineLobe(float s0, float s1, vec3 normal)\n{\t \n    vec2 d  = Sample_Disk(s0, s1);\n    float y = sqrt(clamp01(1.0 - s1));\n\n    vec3 ox, oz;\n    OrthonormalBasisRH(normal, ox, oz);\n\n    return (ox * d.x) + (normal * y) + (oz * d.y);\n}\n\n// s [-1..1]\nfloat Sample_Triangle(float s) \n{ \n    float v = 1.0 - sqrt(abs(s));\n    \n    return s < 0.0 ? -v : v; \n}\n\n\n//=======================================================================//\n///////////////////////////////////////////////////////////////////////////\n\n\n\nuint  asuint2(float x) { return x == 0.0 ? 0u : floatBitsToUint(x); }\nuvec2 asuint2(vec2 x) { return uvec2(asuint2(x.x ), asuint2(x.y)); }\nuvec3 asuint2(vec3 x) { return uvec3(asuint2(x.xy), asuint2(x.z)); }\nuvec4 asuint2(vec4 x) { return uvec4(asuint2(x.xy), asuint2(x.zw)); }\n\nfloat Float01(uint x) { return float(    x ) * (1.0 / 4294967296.0); }\nfloat Float11(uint x) { return float(int(x)) * (1.0 / 2147483648.0); }\n\nvec2 Float01(uvec2 x) { return vec2(      x ) * (1.0 / 4294967296.0); }\nvec2 Float11(uvec2 x) { return vec2(ivec2(x)) * (1.0 / 2147483648.0); }\n\nvec3 Float01(uvec3 x) { return vec3(      x ) * (1.0 / 4294967296.0); }\nvec3 Float11(uvec3 x) { return vec3(ivec3(x)) * (1.0 / 2147483648.0); }\n\nvec4 Float01(uvec4 x) { return vec4(      x ) * (1.0 / 4294967296.0); }\nvec4 Float11(uvec4 x) { return vec4(ivec4(x)) * (1.0 / 2147483648.0); }\n\n// constants rounded to nearest primes\nconst uint rPhi1  = 2654435761u;\n\nconst uint rPhi2a = 3242174893u;\nconst uint rPhi2b = 2447445397u;\n\nconst uint rPhi3a = 3518319149u;\nconst uint rPhi3b = 2882110339u;\nconst uint rPhi3c = 2360945581u;\n\nconst uint rPhi4a = 3679390609u;\nconst uint rPhi4b = 3152041517u;\nconst uint rPhi4c = 2700274807u;\nconst uint rPhi4d = 2313257579u;\n\nconst uvec2 rPhi2 = uvec2(rPhi2a, rPhi2b);\nconst uvec3 rPhi3 = uvec3(rPhi3a, rPhi3b, rPhi3c);\nconst uvec4 rPhi4 = uvec4(rPhi4a, rPhi4b, rPhi4c, rPhi4d);\n\nuint  Roberts(uint  off, uint n) { return off + rPhi1 * n; }\nuvec2 Roberts(uvec2 off, uint n) { return off + rPhi2 * n; }\nuvec3 Roberts(uvec3 off, uint n) { return off + rPhi3 * n; }\nuvec4 Roberts(uvec4 off, uint n) { return off + rPhi4 * n; }\n\n#define _SEED uvec4(0xCAF0FC2Eu, 0xEA18994Au, 0x4D86D399u, 0x10EB49F0u)\n\nuvec4 PhiHash(uint  v, uint seed) { return ((v   * rPhi2a)                                                    ^ (_SEED ^ uvec4(seed))) * rPhi1; }\nuvec4 PhiHash(uvec2 v, uint seed) { return ((v.x * rPhi2a) ^ (v.y * rPhi2b)                                   ^ (_SEED ^ uvec4(seed))) * rPhi1; }\nuvec4 PhiHash(uvec3 v, uint seed) { return ((v.x * rPhi3a) ^ (v.y * rPhi3b) ^ (v.z * rPhi3c)                  ^ (_SEED ^ uvec4(seed))) * rPhi1; }\nuvec4 PhiHash(uvec4 v, uint seed) { return ((v.x * rPhi4a) ^ (v.y * rPhi4b) ^ (v.z * rPhi4c) ^ (v.w * rPhi4d) ^ (_SEED ^ uvec4(seed))) * rPhi1; }\n\nvec4 PhiHash01(float v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash01(vec2  v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash01(vec3  v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash01(vec4  v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\n\nvec4 PhiHash11(float v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash11(vec2  v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash11(vec3  v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash11(vec4  v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\n\nuint MixHash(uvec2 h)\n{\n    return ((h.x ^ (h.y >> 16u)) * rPhi2.x) ^ \n           ((h.y ^ (h.x >> 16u)) * rPhi2.y);\n}\n\nuint MixHash(uvec3 h)\n{\n    return ((h.x ^ (h.y >> 16u) ^ (h.z << 15u)) * rPhi3.x) ^ \n           ((h.y ^ (h.z >> 16u) ^ (h.y << 15u)) * rPhi3.y) ^\n           ((h.z ^ (h.y >> 16u) ^ (h.x << 15u)) * rPhi3.z);\n}\n\nuint MixHash(uvec4 h)\n{\n    return ((h.x ^ (h.y >> 16u) ^ (h.z << 15u)) * rPhi4.x) ^ \n           ((h.y ^ (h.z >> 16u) ^ (h.w << 15u)) * rPhi4.y) ^\n           ((h.z ^ (h.w >> 16u) ^ (h.x << 15u)) * rPhi4.z) ^\n           ((h.w ^ (h.x >> 16u) ^ (h.y << 15u)) * rPhi4.w);\n}\n\n// low bias version https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash(uint x)\n{\n    x ^= x >> 16u;\n    x *= 0x7feb352dU;\n    x ^= x >> 15u;\n    x *= 0x846ca68bU;\n    x ^= x >> 16u;\n\n    return x;\n}\n\nuvec2 WellonsHash(uvec2 h) { return uvec2(WellonsHash(h.x), WellonsHash(h.y)); }\nuvec3 WellonsHash(uvec3 h) { return uvec3(WellonsHash(h.x), WellonsHash(h.y), WellonsHash(h.z)); }\nuvec4 WellonsHash(uvec4 h) { return uvec4(WellonsHash(h.x), WellonsHash(h.y), WellonsHash(h.z), WellonsHash(h.w)); }\n\nuvec4 WellonsHash(uint  v, uint seed) { return WellonsHash(        v  ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash(uvec2 v, uint seed) { return WellonsHash(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash(uvec3 v, uint seed) { return WellonsHash(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash(uvec4 v, uint seed) { return WellonsHash(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\n\n// minimal bias version https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash2(uint x)\n{\n    x ^= x >> 17u;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11u;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15u;\n    x *= 0x31848babU;\n    x ^= x >> 14u;\n\n    return x;\n}\n\nuvec2 WellonsHash2(uvec2 h) { return uvec2(WellonsHash2(h.x), WellonsHash2(h.y)); }\nuvec3 WellonsHash2(uvec3 h) { return uvec3(WellonsHash2(h.x), WellonsHash2(h.y), WellonsHash2(h.z)); }\nuvec4 WellonsHash2(uvec4 h) { return uvec4(WellonsHash2(h.x), WellonsHash2(h.y), WellonsHash2(h.z), WellonsHash2(h.w)); }\n\nuvec4 WellonsHash2(uint  v, uint seed) { return WellonsHash2(        v  ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash2(uvec2 v, uint seed) { return WellonsHash2(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash2(uvec3 v, uint seed) { return WellonsHash2(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash2(uvec4 v, uint seed) { return WellonsHash2(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\n\n#undef _SEED\n\n\n// https://en.wikipedia.org/wiki/Linear_congruential_generator\nuint LCG(uint x) { return x * 22695477u + 1u; }\n\nfloat Hash01(inout uint h)\n{\n    h = LCG(h);\n\n    return Float01(h * rPhi1);\n}\n\nfloat Hash11(inout uint h)\n{\n    h = LCG(h);\n\n    return Float11(h * rPhi1);\n}\n\nuint HashU(inout uint h)\n{\n    h = LCG(h);\n\n    return h * rPhi1;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}