{
    "Shader": {
        "info": {
            "date": "1580313225",
            "description": "Just playing around with the smooth blending functions, and a little bit of randomness... kinda.\nReally need to work on lighting though...",
            "flags": 0,
            "hasliked": 0,
            "id": "wttXRr",
            "likes": 2,
            "name": "Globules",
            "published": 3,
            "tags": [
                "smoothblending"
            ],
            "usePreview": 0,
            "username": "samhattangady",
            "viewed": 305
        },
        "renderpass": [
            {
                "code": "/*\nday003: Globules\n29 Jan 2020\n\nJust playing around with the smooth blending functions,\nand a little bit of randomness... kinda.\nReally need to work on lighting though...\n*/\nvec3 rotate3D(vec3 point, vec3 rotation) {\n    vec3 r = rotation;\n\tmat3 rz = mat3(cos(r.z), -sin(r.z), 0,\n                   sin(r.z),  cos(r.z), 0,\n                   0,         0,        1);\n    mat3 ry = mat3( cos(r.y), 0, sin(r.y),\n                    0       , 1, 0       ,\n                   -sin(r.y), 0, cos(r.y));\n    mat3 rx = mat3(1, 0       , 0        ,\n                   0, cos(r.x), -sin(r.x),\n                   0, sin(r.x),  cos(r.x));\n    return rx * ry * rz * point;\n}\n\nfloat sdfSphere(vec3 position, vec3 center, float radius) {\n    return distance(position, center) - radius;\n}\n\nfloat sdfPlane( vec3 position, vec4 n ) {\n    return dot(position, normalize(n.xyz)) + n.w;\n}\n\nfloat smin(float d1, float d2, float k) {\n    float res = exp2( -k*d1 ) + exp2( -k*d2 );\n    return -log2( res )/k;\n}\n\n\nfloat distanceField(vec3 position) {\n    float d = sdfSphere(position, vec3(0.35*sin(iTime*0.5), 0.2*cos(iTime*0.8), 0.0), 0.55);\n    \n    vec3 moon = vec3(0.95*cos(iTime*0.4), 0.85*sin(iTime*1.4), -0.85*cos(iTime));\n    float d1 = sdfSphere(position, moon, 0.2);\n    d = smin(d, d1, 3.0);\n    \n    d1 = sdfSphere(position, vec3(0.95*cos(iTime*2.3), 0.95*sin(iTime*3.4), 0.95*cos(iTime*1.5)), 0.05);\n    d = smin(d, d1, 3.0);\n    \n    d1 = sdfSphere(position, moon+vec3(0.35*cos(iTime*1.3), 0.49*sin(iTime*2.4), 0.35*cos(iTime*2.8)), 0.01);\n    d = smin(d, d1, 8.0);\n    \n    float d2 = sdfPlane(position, vec4(0.1*sin(iTime*0.2), 1.0, 0.07*sin(iTime*0.3), 0.75+0.2*sin(iTime*0.3)));\n\n    return smin(d2, d, 8.0);\n}\n\nvec3 calcNormal( vec3 p ) \n{\n    // We calculate the normal by finding the gradient of the field at the\n    // point that we are interested in. We can find the gradient by getting\n    // the difference in field at that point and a point slighttly away from it.\n    const float h = 0.0001;\n    return normalize( vec3(\n        \t\t\t       -distanceField(p)+ distanceField(p+vec3(h,0.0,0.0)),\n                           -distanceField(p)+ distanceField(p+vec3(0.0,h,0.0)),\n                           -distanceField(p)+ distanceField(p+vec3(0.0,0.0,h)) \n    \t\t\t\t ));\n}\n\nfloat raymarch( vec3 direction, vec3 start) {\n    // We need to cast out a ray in the given direction, and see which is\n    // the closest object that we hit. We then move forward by that distance,\n    // and continue the same process. We terminate when we hit an object\n    // (distance is very small) or at some predefined distance.\n    float far = 15.0;\n    float d = 0.0;\n    vec3 pos = start;\n    for (int i=0; i<100; i++) {\n    \tfloat sphereDistance = distanceField(pos);\n        pos += sphereDistance*direction;\n\n        d += sphereDistance;\n        if (sphereDistance < 0.01) {\n        \tbreak;\n        }\n        if (d > far) {\n        \tbreak;\n        }\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalise and set center to origin.\n    vec2 p = fragCoord/iResolution.xy;\n    p -= 0.5;\n    p.y *= iResolution.y/iResolution.x;\n    \n    vec3 cameraPosition = vec3(0.0, 0.0, -6.0);\n    //vec3 cameraOrientation = vec3(0.0, 0.0, 0.0);\n    vec3 planePosition = vec3(p, -5.0);\n    // planePosition = rotate3D(planePosition, vec3(0.0, 0.0, iTime));\n    \n    vec3 lookingDirection = (planePosition - cameraPosition);\n    \n    // Rotate light around origin in xz plane\n    float angle = iTime;\n    vec2 lightPos2D = mat2(cos(angle),-sin(angle),sin(angle),cos(angle))*vec2(0.0,1.0); \n    vec3 lightPoint = normalize(vec3(1.0*sin(iTime*0.5), 1.0, -1.0));\n    vec3 lightFacing = lightPoint - vec3(0.0);\n    \n    // raymarch to check for colissions.\n    float dist = raymarch(lookingDirection, planePosition);\n    vec3 color = vec3(0.01);\n    if (dist < 15.0) {\n        color = vec3(0.05, 0.105, 0.305);\n    \tvec3 normal = calcNormal(planePosition+ dist*lookingDirection);\n        float light = dot(lightFacing, normal);\n        color += 0.4* smoothstep(0.3, 1.0, light);\n    }\n    \n    // gamma correction\n    color = pow( color, vec3(1.0/2.2) );\n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}