{
    "Shader": {
        "info": {
            "date": "1367010098",
            "description": "An exercise on animating something alive. Modelling is basic and shading is meh, but overall it looks good I think! Note this is a stateless animation.",
            "flags": 0,
            "hasliked": 0,
            "id": "Mss3zM",
            "likes": 184,
            "name": "Insect",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "distancefield",
                "rayarching",
                "animation"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 40944
        },
        "renderpass": [
            {
                "code": "// Copyright Inigo Quilez, 2013 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither as it is\n// or altered, here on Shadertoy or anywhere else, in any form including\n// physical and digital. You cannot use this Work in any commercial or\n// non-commercial product, website or project. You cannot sell this Work\n// and you cannot mint an NFTs of it or train a neural network with it\n// without permission. I share this Work for educational purposes, and you\n// can link to it, through an URL, proper attribution and unmodified \n// screenshot, as part of your educational material. If these conditions\n// are too restrictive please contact me and we'll definitely work it out.\n\nfloat hash( float n )\n{\n    return fract(sin(n)*158.5453);\n}\n\nfloat noise( in float x )\n{\n    float i = floor(x);\n    float f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return mix( hash(i+0.0), hash(i+1.0),f);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float a = textureLod(iChannel1,(i+vec2(0.5,0.5))/64.0, 0.0).x;\n\tfloat b = textureLod(iChannel1,(i+vec2(1.5,0.5))/64.0, 0.0).x;\n\tfloat c = textureLod(iChannel1,(i+vec2(0.5,1.5))/64.0, 0.0).x;\n\tfloat d = textureLod(iChannel1,(i+vec2(1.5,1.5))/64.0, 0.0).x;\n    return 2.0*mix(mix(a,b,f.x), mix(c,d,f.x),f.y);\n}\n\nfloat fbmcheap( in vec3 x )\n{\n    float f = 0.0;\n    float s = 0.5;\n    for( int i=0; i<6; i++ )\n    {\n        f += s*texture(iChannel3,x).x;\n        x *= 1.93;\n        s *= 0.51;\n    }\n    return f;\n}\n\n// https://iquilezles.org/articles/noacos/\n/*\nmat3x3 rotationAlign( vec3 d, vec3 z )\n{\n    vec3  v = cross( z, d );\n    float c = dot( z, d );\n    float k = 1.0/(1.0+c);\n    return mat3x3( v.x*v.x*k + c,     v.y*v.x*k - v.z,    v.z*v.x*k + v.y,\n                   v.x*v.y*k + v.z,   v.y*v.y*k + c,      v.z*v.y*k - v.x,\n                   v.x*v.z*k - v.y,   v.y*v.z*k + v.x,    v.z*v.z*k + c    );\n}\n*/\n// same as above, specialized for z=(0,0,1)\nmat3x3 rotationAlign( vec3 d )\n{\n    float k = 1.0/(1.0+d.z);\n    return mat3x3(  d.y*d.y*k + d.z, -d.x*d.y*k,       d.x,\n                   -d.y*d.x*k,        d.x*d.x*k + d.z, d.y,\n                   -d.x,             -d.y,             d.z );\n}\n\n// https://iquilezles.org/articles/distfunctions/\nvec2 sdSegmentH( float le, vec3 p )\n{\n\tfloat h = clamp( p.x/le, 0.0, 1.0 );\n    p.x -= le*h;\n\treturn vec2( length(p), h );\n}\n\n// https://www.shadertoy.com/view/tdS3DG\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    k *= 1.4;\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*h/(6.0*k*k);\n}\n\n// https://iquilezles.org/articles/filteringrm/\nvoid calcDpDxy( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy, in float t, in vec3 nor, out vec3 dpdx, out vec3 dpdy )\n{\n    dpdx = t*(rdx*dot(rd,nor)/dot(rdx,nor) - rd);\n    dpdy = t*(rdy*dot(rd,nor)/dot(rdy,nor) - rd);\n}\n\n// https://iquilezles.org/articles/simpleik/\nvec3 solve( vec3 p, float r1, float r2, vec3 dir )\n{\n\tvec3 q = p*( 0.5 + 0.5*(r1*r1-r2*r2)/dot(p,p) );\n\t\n\tfloat s = r1*r1 - dot(q,q);\n\ts = max( s, 0.0 );\n\tq += sqrt(s)*normalize(cross(p,dir));\n\t\n\treturn q;\n}\n\nvec3 solve( vec3 a, vec3 b, float l1, float l2, vec3 dir )\n{\n\treturn a + solve( b-a, l1, l2, dir );\n}\n\n#define ZERO (min(iFrame,0))\n\n//----------------------------------------------------------------\n\nfloat terrainBase( vec2 x )\n{\n\tx += 100.0;\n\tx *= 0.6;\n\n\tvec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float a = textureLod(iChannel0,(p+vec2(0.5,0.5))/1024.0,0.0).x;\n\tfloat b = textureLod(iChannel0,(p+vec2(1.5,0.5))/1024.0,0.0).x;\n\tfloat c = textureLod(iChannel0,(p+vec2(0.5,1.5))/1024.0,0.0).x;\n\tfloat d = textureLod(iChannel0,(p+vec2(1.5,1.5))/1024.0,0.0).x;\n\tfloat r = mix(mix( a, b,f.x), mix( c, d,f.x), f.y);\n\t\n\treturn 12.0*r;\n}\n\nfloat terrain( vec2 x )\n{\n\tfloat f = terrainBase( x );\n\tfloat h = smoothstep( 0.4, 0.8, noise( 2.0*x ) );\n\tf -= 0.2*h;\n\treturn f;\n}\n\nfloat terrainD( vec2 x )\n{\n\tfloat f = terrainBase( x );\n\tfloat h = smoothstep( 0.4, 0.8, noise( 2.0*x ) );\n\tf -= 0.2*h;\n\n    float d = noise( 35.0*x.yx*vec2(0.1,1.0) );\n\tf += 0.003*d * h*h;\n    f += 0.01*texture(iChannel0,0.5*x).x;\n\n\treturn f;\n}\n\nstruct Monster\n{\n\tvec3 center;\n\tvec3 mww;\n\tvec3 ne[6];\n\tvec3 f0b[6];\n}monster;\n\nvec2 sdMonster( in vec3 p )\n{\n\tvec3 q = p - monster.center;\n\t\n\tif( dot(q,q)>25.0 ) return vec2(32.0);\n\t\n\tvec3 muu = vec3(1.0,0.0,0.0);\n\tvec3 mvv = normalize( cross(monster.mww,muu) );\n\tq = vec3( q.x, dot(mvv,q), dot(monster.mww,q) );\n\n    vec3 ref = q;\n    \n    // body\n\tfloat f = 0.5 - 0.5*q.z;\n    float g = smoothstep(-0.2,0.2,q.y);\n\tfloat ab = (0.5 + g*0.5*cos( 1.0 + 40.0*pow(0.5-0.5*q.z,2.0) ))*(1.0-f);\n    float d1 = sdEllipsoid( q, vec3(0.65,0.45,1.0)*(1.0+0.3*ab) );\n\tfloat ho = 1.0-clamp( 3.0*abs(q.x), 0.0, 1.0 );\n\td1 += 0.1*(1.0-sqrt(1.0-ho*ho))*smoothstep( 0.0,0.1,-q.z );\n\n    float eye = length( vec3(abs(q.x),q.yz) - vec3(0.3,0.05,0.9) ) - 0.3; \n    d1 = smax(d1,-eye,0.05);\n\n    float b = 1.0 + 5.0*sqrt(clamp(f,0.0,1.0))*g;\n\t// legs\n    float s = sign(q.x);\n    for( int j=0; j<3; j++ )\n\t{\n        int i = (q.x>0.0)?j:j+3;\n\t\tfloat h = float(j)/3.0;\n\t\t\n\t\tvec3 bas = monster.center + muu*s*0.5 + monster.mww*1.0*(h-0.33) ;\n\n\t\tvec3 n1 = monster.ne[i];\n\n        {\n        float  le = 1.6;//length(n1-bas);\n        mat3x3 tx = rotationAlign( (n1-bas)/le );\n        vec3   w = tx*(p-bas);\n        vec2   hh = sdSegmentH( le, w.zyx );\n        float  dd = hh.x-mix(0.15,0.05,hh.y) + 0.05*sin(6.2831*hh.y);\n        dd += 0.005*(sin(60.0*w.x+w.z*2.0)*sin(60.0*w.y+w.z*3.0));\n        bas -= monster.center;\n\t    bas = vec3( bas.x, dot(mvv,bas), dot(monster.mww,bas) );\n        float h = clamp( 0.5 + 0.5*(d1-dd)/0.2, 0.0, 1.0 );\n        ref = mix(ref,bas+w.zyx,h);\n\t\td1 = smin( d1, dd, 0.2 );\n        b = mix(b,0.0,h);\n        }\n\n        {\n        float  le = 1.2;//length(n1-bas);\n        mat3x3 tx = rotationAlign( (monster.f0b[i]-n1)/le );\n        vec3   w = tx*(p-n1);\n        vec2   hh = sdSegmentH( le, w.zyx );\n        float  dd = hh.x-mix(0.06,0.02,hh.y) + 0.01*cos(2.0*6.2831*hh.y);\n        float h = clamp( 0.5 + 0.5*(d1-dd)/0.1, 0.0, 1.0 );\n        ref = mix(ref,bas+vec3(1.6,0.0,0.0)+w.zyx,h);\n\t\td1 = smin( d1, dd, 0.1 );\n        }\n\t}\n\t\n    // bump!\n    //if( doBump )  // set to true for true displacement\n    d1 -= (1.0+b)*0.02*(textureLod(iChannel2,1.5*ref.xz,0.0).x-0.15);\n    \n\tvec2 res = vec2( 0.5*d1, 1.0 );\n\n\t// eyes\n\tif( eye<res.x ) res = vec2( eye, 0.0 );\n\n\treturn res;\n}\n\nvec3 sdMonsterC( in vec3 p )\n{\n\tvec3 q = p - monster.center;\n\t\n\tvec3 muu = vec3(1.0,0.0,0.0);\n\tvec3 mvv = normalize( cross(monster.mww,muu) );\n\tq = vec3( q.x, dot(mvv,q), dot(monster.mww,q) );\n\tvec3 res = q;\n\n    // body\n\tfloat f = 0.5 - 0.5*q.z;\n    float g = smoothstep(-0.2,0.2,q.y);\n\tfloat ab = (0.5 + g*0.5*cos( 1.0 + 40.0*pow(0.5-0.5*q.z,2.0) ))*(1.0-f);\n\tfloat d1 = sdEllipsoid( q, vec3(0.65,0.45,1.0)*(1.0+0.3*ab) );\n\tfloat ho = 1.0-clamp( 3.0*abs(q.x), 0.0, 1.0 );\n\td1 += 0.1*(1.0-sqrt(1.0-ho*ho))*smoothstep( 0.0,0.1,-q.z );\n\n\t// legs\n    float s = sign(q.x);\n    for( int j=ZERO; j<3; j++ )\n\t{\n        int i = (q.x>0.0)?j:j+3;\n\t\tfloat h = float(j)/3.0;\n\t\t\n\t\tvec3 bas = monster.center + muu*s*0.5 + monster.mww*1.0*(h-0.33) ;\n\n\t\tvec3 n1 = monster.ne[i];\n\n        {\n        float  le = 1.6;//length(n1-bas);\n        mat3x3 tx = rotationAlign( (n1-bas)/le );\n        vec3   w = tx*(p-bas);\n        vec2   hh = sdSegmentH( le, w.zyx );\n        float  dd = hh.x-mix(0.15,0.05,hh.y) + 0.05*sin(6.2831*hh.y);\n        bas -= monster.center;\n\t    bas = vec3( bas.x, dot(mvv,bas), dot(monster.mww,bas) );\n        float h = clamp( 0.5 + 0.5*(d1-dd)/0.2, 0.0, 1.0 );\n        res = mix(res,bas+w.zyx,h);\n        d1 = smin(d1,dd, 0.2);\n        }\n        \n        {\n        float  le = 1.2;//length(n1-bas);\n        mat3x3 tx = rotationAlign( (monster.f0b[i]-n1)/le );\n        vec3   w = tx*(p-n1);\n        vec2   hh = sdSegmentH( le, w.zyx );\n        float dd = hh.x-mix(0.06,0.02,hh.y) + 0.01*cos(2.0*6.2831*hh.y);\n        float h = clamp( 0.5 + 0.5*(d1-dd)/0.1, 0.0, 1.0 );\n        res = mix(res,bas+vec3(1.6,0.0,0.0)+w.zyx,h);\n\t\td1 = smin( d1, dd, 0.1 );\n        \n        }\n\t}\n\t\t\n\treturn res;\n}\n\nvec2 map( in vec3 p )\n{\n    vec2 res = sdMonster( p);\n\n\tfloat d2 = 0.5*(p.y - terrain(p.xz));\n\tif( d2<res.x ) res = vec2(d2,2.0);\n\t\n\treturn res;\n}\n\nvec2 mapD( in vec3 p )\n{\n    vec2 res = sdMonster( p);\n\n\tfloat d2 = 0.5*(p.y - terrainD(p.xz));\n\tif( d2<res.x ) res = vec2(d2,2.0);\n\t\n\treturn res;\n}\n\nvec3 raycast( in vec3 ro, in vec3 rd )\n{\n\tfloat mind = 0.1;\n\tfloat maxd = 70.0;\n\n    float tp = (15.0-ro.y)/rd.y;\n    if( tp>0.0 )\n    {\n    if( ro.y<15.0 ) maxd=min(maxd,tp);\n    else            mind=max(mind,tp);\n    }\n\n    float t = mind;\n\tfloat d = 0.0;\n    float m = 1.0;\n    for( int i=0; i<256; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        float h = res.x;\n\t\td = res.y;\n\t\tm = res.y;\n        if( abs(h)<(0.0005*t)||t>maxd ) break;\n        t += h;\n    }\n\n    if( t>maxd ) m=-1.0;\n    return vec3( t, d, m );\n}\n\n\n// https://iquilezles.org/articles/normalsSDF/\nvec3 calcNormal( in vec3 pos )\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*mapD(pos+e*0.002).x;\n    }\n    return normalize(n);\n}\n\n// https://iquilezles.org/articles/rmshadows/\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float maxd = 70.0;\n    \n    if( ro.y<15.0 )\n    {\n    float tp = (15.0-ro.y)/rd.y;\n    if( tp>0.0 ) maxd=min(maxd,tp);\n    }\n    \n    float res = 1.0;\n    float t = mint;\n\tfloat h = 1.0;\n    for( int i=0; i<48; i++ )\n    {\n        h = map(ro + rd*t).x;\n        res = min( res, smoothstep(0.0,1.0,k*h/t) );\n\t\tt += clamp( h, 0.025, 1.0 );\n\t\tif( h<0.001 || t>maxd) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 path( float t )\n{\n    vec3 pos = vec3( 0.0 );\n    pos.z += t*0.4;\n\tpos.y = 1.0 + terrainBase( pos.xz );\n\treturn pos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = vec2(0.5);\n\tif( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // animate\n    //-----------------------------------------------------\n\t\n\tfloat ctime = 15.0 + iTime;\n\n\t// mobe body\n\tfloat atime = 2.0*ctime;\n\tfloat ac = noise( 0.5*ctime );\n\tatime += 4.0*ac;\n    monster.center = path( atime );\n\tvec3 centerN = path( atime+2.0 );\n\tmonster.mww = normalize( centerN - monster.center );\n    monster.center.y -= 0.25;\n\t\n\t// move legs\n\tfor( int i=0; i<6; i++ )\n\t{\n\t\tfloat s = -sign( float(i)-2.5 );\n\t\tfloat h = mod( float(i), 3.0 )/3.0;\n\n\t\tfloat z = 0.5*atime + 1.0*h + 0.25*s;\n\t\tfloat iz = floor(z);\n\t\tfloat fz = fract(z);\n        float az = smoothstep(0.66,1.0,fz);\n\t\t\n\t\tvec3 fo = vec3(s*1.5, 0.7*az*(1.0-az), (iz + az + (h-0.3)*4.0)*0.4*2.0 );\n\t\tfo.y += terrain( fo.xz );\n        monster.f0b[i] = fo;\n\t\t\n\t\tvec3 ba = monster.center + vec3(1.0,0.0,0.0)*s*0.5 + monster.mww*1.0*(h-0.33) ;\n\n\t\tmonster.ne[i] = solve( ba, fo, 1.6, 1.2, s*vec3(0.0,0.0,-1.0) );\n\t}\n\t\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n\t\n    // follow the monster\n\tfloat an = 0.0 + 0.1*ctime - 6.28*m.x;\n\tfloat cr = 0.3*cos(0.2*ctime);\n    vec3 ro = monster.center + vec3(4.0*sin(an),0.2,4.0*cos(an));\n    vec3 ta = monster.center;\n\tro.y = 0.5 + terrainBase( ro.xz );\n\t\n    // shake\n\tro += 0.04*sin(4.0*ctime*vec3(1.1,1.2,1.3)+vec3(3.0,0.0,1.0) );\n\tta += 0.04*sin(4.0*ctime*vec3(1.7,1.5,1.6)+vec3(1.0,2.0,1.0) );\n\t\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(cr),cos(cr),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t\n    // barrel distortion\t\n    float r2 = p.x*p.x*0.32 + p.y*p.y;\n    p *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\n\t\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 3.0*ww );\n    \n    // ray differentials\n    vec2 px = (-iResolution.xy+2.0*(fragCoord.xy+vec2(1.0,0.0)))/iResolution.y;\n    r2 = px.x*px.x*0.32 + px.y*px.y;\n    px *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\n    vec2 py = (-iResolution.xy+2.0*(fragCoord.xy+vec2(0.0,1.0)))/iResolution.y;\n    r2 = py.x*py.x*0.32 + py.y*py.y;\n    py *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\n    vec3 rdx = normalize( px.x*uu + px.y*vv + 3.0*ww );\n    vec3 rdy = normalize( py.x*uu + py.y*vv + 3.0*ww );\n    \n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n    const vec3 lig = normalize(vec3(-1.0,0.4,0.2));\n\tfloat nds = clamp(dot(rd,lig),0.0,1.0);\n\tvec3 bgc = vec3(0.9+0.1*nds,0.95+0.05*nds,0.9)*(0.7 + 0.3*rd.y)*0.98;\n    vec3 col = bgc;\n\n\t// raymarch\n    vec3 tmat = raycast(ro,rd);\n    if( tmat.z>-0.5 )\n    {\n        float t = tmat.x;\n        \n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\t\tvec3 ref = reflect( rd, nor );\n\n        // derivatives        \n        vec3 dpdx, dpdy;\n        calcDpDxy( ro, rd, rdx, rdy, t, nor, dpdx, dpdy );\n    \n        // materials\n        float mocc = 1.0;\n\t\tvec4 mate = vec4(0.0);\n\t\tfloat ks = 1.0;\n        \n\t\t// eyes\n\t\tif( tmat.z<0.5 )\n\t\t{\n            mate = vec4(0.01,0.01,0.01,30.0);\n            ks *= 0.07;\n            mate.xyz *= mix(vec3(1.0,0.3,0.0),vec3(0.5,0.8,1.0),0.5+0.5*nor.y);\n\t\t\tmate.w *= 0.8 + 0.2*sin(20.0*ref.x)*sin(20.0*ref.y)*sin(20.0*ref.z);\n\t\t\tmate.xyz += 0.001*sin(5.0*ref);\n\t\t\tmate.xyz *= 0.5;\n\t\t}\n\t\t// body\n\t\telse if( tmat.z<1.5 )\n\t\t{\n            // do shading in mosnter space\t\t\t\n\t\t\tvec3 q = pos - monster.center;\n\t\t\tvec3 muu = vec3(1.0,0.0,0.0);\n\t\t\tvec3 mvv = normalize( cross(monster.mww,muu) );\n\t\t\tq = vec3( q.x, dot(mvv,q), dot(monster.mww,q) );\n\t\t\tvec3 n = vec3( nor.x, dot(mvv,nor), dot(monster.mww,nor) );\n\n            // texture coords\n            vec3 w = sdMonsterC(pos);\n\n            // base color\t\t\t\n            mate.xyz = 0.15*vec3(1.0,0.7,0.4);\t\t\t\n            // bumps\n            float te = textureLod(iChannel2,1.5*w.xz,0.0).x;\n            mate.xyz = mix(mate.xyz,vec3(0.4,0.3,0.04),smoothstep(0.2,0.8,te));\n\n            // texture\n            mate.xyz += 0.08*smoothstep(vec3(0.4,0.3,0.2),vec3(0.7,0.6,0.8),vec3(fbmcheap(w*0.5)));\n\n\t\t\t// color adjustment\n\t\t\tmate.w = 1.0;\n            mate.xyz *= 0.25+1.0*mate.xzy*vec3(0.98,1.6,1.4);\n\t\t\t\n            // occlusion\t\t\t\n\t\t\tfloat ho = 1.0-clamp( 5.0*abs(q.x), 0.0, 1.0 );\n            mocc *= 1.0-(1.0-sqrt(1.0-ho*ho))*smoothstep( 0.0,0.1,-q.z );\n            float eye = length( vec3(abs(q.x),q.yz) - vec3(0.3,0.05,0.9) ) - 0.3; \n            mocc *= clamp(1.0-2.0/(1.0+100.0*eye),0.0,1.0);\n\n\t\t}\n        // terrain\t\t\n\t\telse if( tmat.z<2.5 )\n\t\t{\n\t\t\tmate = vec4(1.0, 0.9, 0.5, 0.0);\n            float nn =  noise( 2.0*pos.xz );\n\n            mate.xyz = mix( 0.7*mate.xyz, mate.xyz*0.65*vec3(0.8,0.9,1.0), 1.0-smoothstep( 0.4, 0.9, nn ) );\n\t\t\tmate.xyz *= 0.45;\n\n\t\t\tvec3 ff  = 0.05+0.95*textureGrad( iChannel0, 0.08*pos.xz, 0.08*dpdx.xz, 0.08*dpdy.xz ).xyz;\n\t\t\t     ff *= 0.05+0.95*textureGrad( iChannel0, 0.52*pos.xz, 0.52*dpdx.xz, 0.52*dpdy.xz ).xyz;\n\t\t\t     ff *= 0.05+0.95*textureGrad( iChannel0, 4.03*pos.xz, 4.03*dpdx.xz, 4.03*dpdy.xz ).xyz;\n\t\t\t\n\t\t\tfloat aa = mix( 1.0, 0.3, smoothstep( 0.65, 0.8, nn ) );\n            mate.xyz *= (1.0-aa) + aa*sqrt(ff)*3.0;\n\t\t\t\n            float d = smoothstep( 0.0, 0.5, abs(nn-0.75) );\n            mate.xyz *= 0.6+0.4*d;\n            d = smoothstep( 0.0, 0.2, abs(nn-0.75) );\n            mocc *= 0.7+0.3*d;\n\t\t\tmocc *= pow( clamp( 0.5*length( pos.xz - monster.center.xz ), 0.0, 1.0 ), 2.0 );\n\t\t}\n\n\t\t// lighting\n\t\tfloat occ = (0.5 + 0.5*nor.y)*mocc;\n        float dif = max(dot(nor,lig),0.0);\n        float bac = max(dot(nor,normalize(vec3(-lig.x,-lig.y*0.5,-lig.z))),0.0);\n\t\tfloat sha = 0.0; if( dif>0.01 ) sha=softshadow( pos, lig, 0.05, 32.0 );\n        vec3  hal = normalize(lig-rd);\n        float fre = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 2.0 );\n        float spe = pow( clamp( dot(hal,nor), 0.0, 1.0), 24.0 );\n\t\tspe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n\t\t\n\t\t// lights\n\t\tvec3 lin = vec3(0.0);\n        lin += 3.0*dif*vec3(1.50,1.00,0.65)*pow(vec3(sha),vec3(1.0,1.2,1.5));\n        lin += 1.0*mix(vec3(0.10,0.05,0.0),vec3(0.2,0.3,0.35)*2.0*mocc, 0.5+0.5*nor.y );\n\t\tlin += 3.0*bac*vec3(0.30,0.20,0.15)*occ;\n        lin += 1.0*fre*vec3(0.50,0.50,0.50)*occ*15.0*mate.w*(0.05+0.95*dif*sha);\n\t\tlin += 1.0*spe*vec3(1.0)*6.0*occ*mate.w*dif*sha;\n\t\tcol = mate.xyz * lin;\n\t\tcol += 1.0*spe*vec3(1.0)*10.0*occ*mate.w*dif*sha*ks;\n\n\t\t// fog\t\t\n\t\tcol = mix( col, 0.8*bgc, clamp(1.0-1.2*exp(-0.03*tmat.x ),0.0,1.0) );\n    }\n\telse\n\t{\n        // sun\t\t\n\t    vec3 sun = vec3(1.0,0.8,0.5)*pow( nds, 24.0 );\n\t    col += sun;\n\t}\n    // sun scatter\n\tcol += 0.4*vec3(0.2,0.14,0.1)*pow( nds, 16.0 );\n\n    // color\n    col *= 4.0/(3.0+col);\n    col = pow( col, vec3(0.45,0.5,0.55) );\n    col.z += 0.1;\n    \n\t// vigneting\n\tvec2 q = fragCoord/iResolution.xy;\n    col *= 0.2 + 0.8*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}