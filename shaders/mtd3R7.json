{
    "Shader": {
        "info": {
            "date": "1682161589",
            "description": "test for some screen space ambient occlusion from depth buffer",
            "flags": 32,
            "hasliked": 0,
            "id": "mtd3R7",
            "likes": 15,
            "name": "screen space ambient occlusion",
            "published": 3,
            "tags": [
                "blur",
                "lighting",
                "sampling",
                "ssao",
                "ambiantocclusion"
            ],
            "usePreview": 0,
            "username": "mdb",
            "viewed": 759
        },
        "renderpass": [
            {
                "code": "//blur\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 offset = 1. / iResolution.xy;\n    vec3 col = vec3(0.);\n    float nb_accu = 0.;\n    \n    vec4 p0 = texture(iChannel0, uv);\n    \n    int n = 2;\n    for(int i=-n; i<=n; i++){\n    for(int j=-n; j<=n; j++){\n        vec2 uv2 = uv+vec2(i, j)*offset;\n        vec4 p = texture(iChannel0, uv2);\n        vec3 c = texture(iChannel1, uv2).rgb;\n        float w = smoothstep(1.0, 0.0, 10.*abs(p0.w - p.w)/p0.w)\n                *smoothstep(1.0, 0.0, length(p0.xyz - p.xyz));\n        col += c*w;\n        nb_accu += w;\n    }\n    }\n    col /= nb_accu;\n    if (p0.w > 100.) col = vec3(0.2);\n    fragColor = vec4(col, 1.);;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//rendering of the scene\n\n#define NUMBOX 15\nstruct Box{vec3 up, down;};\nBox[NUMBOX] boxs;\n\n// pseudo random numbers////////////////////////////////////////////////\nuint seed = 0u;\nvoid hash(){\n    seed ^= 2747636419u;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n}\n\nfloat random(){\n    hash();\n    return float(seed)/4294967295.0;\n}\n\nvoid initBoxs(){\n    seed = uint(iFrame)/400u;\n    for(int idx = 0; idx < NUMBOX - 1; idx++){\n        vec3 a = vec3(random(), random(), random());\n        vec3 b = vec3(random(), random(), random());\n        a = 2.0*a - 1.0;\n        b = 2.0*b - 1.0;\n        vec3 s = vec3(1.1);\n        a *= s; b *= s;\n        boxs[idx] = Box(max(a, b), min(a, b));\n    }\n    boxs[NUMBOX - 1] = Box(vec3(10.0, -0.95, 10.0), vec3(-10.0, -1.0, -10.0));\n}\n/////////////////////////////////////////////////////////////////////////\n\n\nvec2 box(vec3 ro, vec3 rd, Box AABB){\n        vec3 down = AABB.down;\n        vec3 up = AABB.up;\n        \n        vec3 dirfrac = 1.0 / rd;\n        float t1 = (down.x - ro.x)*dirfrac.x;\n        float t2 = (up.x - ro.x)*dirfrac.x;\n        float t3 = (down.y - ro.y)*dirfrac.y;\n        float t4 = (up.y - ro.y)*dirfrac.y;\n        float t5 = (down.z - ro.z)*dirfrac.z;\n        float t6 = (up.z - ro.z)*dirfrac.z;\n\n        float tmin = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));\n        float tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));\n\n        // if tmax < 0, ray (line) is intersecting AABB, but the whole AABB is behind us\n        if (tmax < 0.0) return vec2(-1.0);\n\n        // if tmin > tmax, ray doesn't intersect AABB\n        if (tmin > tmax) return vec2(-1.0);\n\n        return vec2(tmin, tmax);\n}\n\nvec3 normal(vec3 pos, Box b){\n    pos -= 0.5*(b.up + b.down);\n    pos /= 0.5*abs(b.up - b.down);\n    vec3 n = vec3(0.0);\n    if(abs(pos.x)>0.995){n.x = pos.x;}\n    if(abs(pos.y)>0.995){n.y = pos.y;}\n    if(abs(pos.z)>0.995){n.z = pos.z;}\n    n = normalize(n);\n    return n;\n}\n\nfloat intersect(vec3 ro, vec3 rd, out vec3 n){\n\n    float t = 1e3;\n    for(int i = 0; i < NUMBOX; i++){\n        Box B = boxs[i];\n        float t2 = box(ro, rd, B).x;\n        \n        if( t2 > 0.0001 && t2 < t){\n            t = t2;\n            n = normal(ro + t*rd, B);\n        }\n    }\n    if(t > 1e2) {\n        n = -rd;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initBoxs();\n    vec2 uv = fragCoord/iResolution.xy*2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    //ray\n    vec3 target = vec3(0.0, 0.0, 0.0);\n    vec3 camPos = vec3(cos(iTime), 0.5 + 0.2*cos(iTime), sin(iTime))*2.0;\n    vec3 dir0 = normalize(target-camPos);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(up, dir0));\n    up = cross(dir0, right);\n    vec3 rd = normalize(dir0 + right*uv.x + up*uv.y);\n    //scene\n    vec3 n;\n    float t = intersect(camPos, rd, n);\n    \n    fragColor = vec4(n, t);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//ambient occlusion\n\nuint seed = 4u;\nvoid hash(){\n    seed ^= 2747636419u;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n}\n\nfloat random(){\n    hash();\n    return float(seed)/4294967295.0;\n}\n\nvoid initRandomGenerator(vec2 uv, vec2 dim, int f){\n    seed = uint(uv.y*dim.x + uv.x) + uint(f)*uint(dim.x)*uint(dim.y);\n}\n//////////////////////////////////////////////////////////////////////////\n#define PI 3.14159265359\nvec3 newDir(vec3 n){\n    float teta = random()*2.0*PI;\n    float z = random()*2.0-1.0;\n    vec3 v = vec3(sqrt(1.0-z*z)*cos(teta), sqrt(1.0-z*z)*sin(teta), z);\n    if(dot(n, v) < 0.0) return -v;\n    return v;\n}\n\nvec3 sampleVec(vec3 n, float radius){\n    vec3 d = newDir(n);\n    float r = random();\n    d *= mix(0.001, radius, r*r);\n    return d;\n}\n\n\n/////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    initRandomGenerator(fragCoord, iResolution.xy, iFrame);\n    //camera\n    vec3 target = vec3(0.0, 0.0, 0.0);\n    vec3 camPos = vec3(cos(iTime), 0.5 + 0.2*cos(iTime), sin(iTime))*2.0;\n    vec3 dir0 = normalize(target-camPos);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(up, dir0));\n    up = cross(dir0, right);\n    \n    //ssao\n    int max_sample = 16;\n    float radius = 0.65;\n    \n    float ao = 0.;\n    float nb_sample = 0.;\n    vec4 fragData = texture(iChannel0, uv);\n    vec3 n = fragData.xyz;\n    float depth = fragData.w;\n    uv = 2. * uv - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 pos = normalize(dir0 + right*uv.x + up*uv.y) * depth;\n    \n    \n    for(int i = 0; i < max_sample; i++){\n        \n        vec3 samplePos = pos + sampleVec(n, radius);\n        float depth2 = length(samplePos);\n        samplePos /= dot(samplePos, dir0);\n        vec2 uv2 = vec2(dot(right, samplePos), dot(up, samplePos));\n        uv2.x /= iResolution.x/iResolution.y;\n        uv2 = 0.5*uv2+0.5;\n        \n    \n        if(uv2.x >= 0. && uv2.x <= 1. && uv2.y >= 0. && uv2.y <= 1.){\n            float sampleDepth = texture(iChannel0, uv2).w;\n            \n            float rangeCheck = smoothstep(0.0, 1.0, radius / abs(depth - sampleDepth));\n            ao += (sampleDepth <= depth2 - 0.01 ? 1. : 0.)*rangeCheck;\n            nb_sample += 1.;\n        }\n        \n    }\n    ao /= nb_sample;\n    ao = 1. - ao;\n    \n    //out\n    fragColor = vec4(vec3(ao*0.95), 1.); \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}