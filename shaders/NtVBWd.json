{
    "Shader": {
        "info": {
            "date": "1667166688",
            "description": "Participation in the JFIG 2022 Shadertoy contest.\nInspired by: https://en.wikipedia.org/wiki/Pont_de_pierre_(Bordeaux).",
            "flags": 32,
            "hasliked": 0,
            "id": "NtVBWd",
            "likes": 35,
            "name": "[ConcoursJFIG2022]Pont de pierre",
            "published": 3,
            "tags": [
                "raymarching",
                "sdf",
                "spheretracing",
                "boundingvolume",
                "contest",
                "bridge",
                "boundingbox",
                "concoursjfig2022"
            ],
            "usePreview": 1,
            "username": "sukupaper",
            "viewed": 846
        },
        "renderpass": [
            {
                "code": "// Author: paperu\n// Title: [ConcoursJFIG2022] Pont de pierre\n\n/*\n\n       oYo               oYo\n        |                 |\n    ____|_________________|____\n    ===========================\n        _                 _\n       (o)       _       (o)\n    -_  \"  _-''`` ``''-_  \"  _-\n      \\   /             \\   /\n    ~~|   |~~~~~~~~~~~~~|   |~~\n\nParticipation in the JFIG 2022 Shadertoy contest.\nInspired by: https://en.wikipedia.org/wiki/Pont_de_pierre_(Bordeaux).\n\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 st = (fragCoord.xy - iResolution.xy*.5)/iResolution.x;\n    vec2 st2 = fragCoord.xy/iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    ivec2 uv = ivec2(fragCoord.xy);\n    float dc = length(st);\n    dc = dc*dc;\n    \n    vec3 colorGlow = vec3(0.);\n    for(int i = 0; i < BLUR_FILTER_SZ; i++)\n    {\n        colorGlow += texelFetch(iChannel1, ivec2(uv.x, uv.y + i*GLOW_LEVEL), 0).rgb*GAUSSIAN_KERNEL[i];\n        colorGlow += texelFetch(iChannel1, ivec2(uv.x, uv.y - i*GLOW_LEVEL), 0).rgb*GAUSSIAN_KERNEL[i];\n    }\n    \n    vec3 colorSharp;\n    { // Kind of chromatic aberrations\n        float aa = 1./iResolution.x, b = dc*18.;\n        colorSharp = vec3(\n            texture(iChannel0, st2 + st*aa*b).r,\n            texture(iChannel0, st2).g,\n            texture(iChannel0, st2 - st*aa*b).b\n        );\n    }\n    \n    // Mixing colors\n    vec3 color = vec3(colorGlow*.4 + colorSharp);\n    \n    { // Vignetting effect\n        color *= (1. - dc*ratio*1.25);\n    }\n    \n    { // Gamma correction\n        color = LIN_2_SRGB(color);\n    }\n    \n    fragColor = vec4(color, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// --------- Settings\n\n// > Map raymarching steps number to color space (purple/blue = low step count, yellow/red = high step count)\n// #define DEBUG_PERFORMANCES_ENABLED\n\n// > Shows albedo only\n// #define SHADING_DISABLED\n\n// > Shows each individual bounding box with an unique color\n// #define SHOW_BOUNDING_BOXES_ENABLED\n\n// > I tend to believe that 30fps version is better than 60fps (especially for transitions)\n#define FAKE_30_FPS_LIMIT_ENABLED\n\n// > Bruteforce antialiasing\n#define NB_AA_SAMPLE 4\n#define AA_ENABLED\n\n#define RAY_EPSILON 10e-3\n#define NORMAL_EPSILON 10e-4\n\n#define BB_INTERSECT_IT_MAX 6\n\n// --------- Constant and ids\n// Bounding box ids\n#define UNDEFINED_BB_ID 0\n#define BRIDGE_BB_ID 1\n#define FENCE_BB_ID 2\n#define STREET_LAMP_BB_ID 3\n#define WATER_BB_ID 4\n\n// Signed distance functions (sdf) ids\n#define UNDEFINED_SDF_ID -1\n#define S_LAMP_BODY_SDF_ID 0\n#define S_LAMP_WALL_SDF_ID 1\n#define S_LAMP_LIGHTBULB_SDF_ID 2\n#define BRIDGE_MOLDING_SDF_ID 3\n#define BRIDGE_PILLAR_SDF_ID 4\n#define BRIDGE_VAULT_SDF_ID 5\n#define BRIDGE_WALL_SDF_ID 6\n#define BRIDGE_DECO_INTER_SDF_ID 7\n#define BRIDGE_DECO_CORONA_SDF_ID 8\n\n#define JFIG_2022_TEXT_SIZE 9\nconst vec2 JFIG_2022_TEXT[JFIG_2022_TEXT_SIZE] = vec2[](vec2(10.,11.), vec2(6.,11.), vec2(9.,11.), vec2(7.,11.), vec2(0.,5.), vec2(2.,12.), vec2(0.,12.), vec2(2.,12.), vec2(2.,12.));\n\n// --------- Data structures declaration\nstruct Ray          // A 3d ray\n{\n    vec3 o, d;      // origin, direction\n};\n\nstruct Tpos         // Results of bounding box intersection test\n{\n    float min, max; // tmin and tmax position along the ray\n    int bbId;       // bounding box id\n    bool isRm;      // bounding box has to be \"raymarched\"\n};\n\nstruct BBrmSettings // Settings for bounding box with raymarched content\n{\n    int maxStep;    // max number of raymarching step\n    float epsilon;  // epsilon value (performances/quality trade-off)\n};\n\nstruct Result       // Returned at the end of the entire scene intersection test\n{\n    float t;        // t position along the ray at the intersection found\n    int bbId;       // bounding box id (if isRm==true)\n    int sdfId;      // sdf id (if isRm==true)\n    int nbIterations; // raymarching iteration number (if isRm==true)\n    bool isRm;      // if intersection found is in a raymarched bounding box\n    Ray ray;        // ray used for intersection test\n};\n\nstruct SMatSettings // Some basic material settings\n{\n    vec3 albedo;    // material base color/texture\n    float specAmt;  // specular amount\n    float specPow;  // specular size\n    bool isEmissive;// material is emissive\n};\n\nstruct CameraSettings// Same but for camera\n{\n    vec3 pos, target;// position and target (for look at matrix)\n    float fov, sz;   // field of view + sensor size\n    float rotAngle;  // rotation angle\n    vec3 rotAxis;    // rotation axis\n    vec2 st;         // screen coordinates\n};\n\n// --------- Global variables\n// Counter for raymarching steps\n#ifdef DEBUG_PERFORMANCES_ENABLED\nfloat STEP_OBSERVER = 0.;\n#endif\n\n// Some global variables (mainly for animation purpose)\nfloat GRID_MODE_ENABLED = 0.;\nfloat GRID_MODE_POS_ENABLED = 0.;\nfloat GRID_MODE_POS_X = 0.;\nfloat GRID_MODE_SIZE = 1.;\nfloat GRID_MODE_THICKNESS = .0012;\nfloat INFINITE_BRIDGE_ENABLED = 1.;\n\nfloat IS_NIGHT = 0.;\nvec3 SUN_DIRECTION = vec3(0,-1,0);\nvoid setSunDirection(in float a)\n{\n    SUN_DIRECTION = axisRot(vec3(1,0,.25), a)*SUN_DIRECTION;\n}\n\n// Raymarching settings for all bounding box (including not raymarched ones)\n#define DEFAULT_BBRM_SETTINGS BBrmSettings(0, 0.)\nconst BBrmSettings BB_RM_SETTINGS[] = BBrmSettings[]\n(\n    DEFAULT_BBRM_SETTINGS,    // UNDEFINED_BB_ID\n    BBrmSettings(50, .001),   // BRIDGE_BB_ID\n    BBrmSettings(30, .00025), // FENCE_BB_ID\n    BBrmSettings(50, .0005),  // STREET_LAMP_BB_ID\n    DEFAULT_BBRM_SETTINGS     // WATER_BB_ID\n);\n\n#define BB_TPOS_LIST_SIZE 6\nTpos BB_TPOS_LIST[BB_TPOS_LIST_SIZE];\n\n// --------- Utilitary functions\nRay getReflectedRay(in vec3 p, in vec3 n, in vec3 v)\n{\n    vec3 r = reflect(v, n);\n    return Ray(p + r*RAY_EPSILON, r);\n}\n\nRay getShadowRay(in vec3 p, in vec3 n, in vec3 ld)\n{\n    return Ray(p - ld*RAY_EPSILON, -ld);\n}\n\n// ray-box intersection test functions by iq from: https://iquilezles.org/articles/intersectors/\nTpos boxInfXZIntersection(in Ray view, in float boxSize, in int id, in bool isRm) \n{\n    float ro = view.o.y, rd = view.d.y, invRd = 1./rd, invRdRo = invRd*ro;\n    float k = abs(invRd)*boxSize;\n    vec2 tNF = -vec2(invRdRo) + vec2(-k, k);\n    if(tNF.x > tNF.y || tNF.y < 0.) return Tpos(-1., -1., id, isRm);\n    return Tpos(tNF.x, tNF.y, id, isRm);\n}\nTpos boxInfXZIntersection(in Ray view, in float top, in float bottom, in int id, in bool isRm) \n{\n    float boxSize = top - bottom;\n    view.o.y -= top + bottom;\n    return boxInfXZIntersection(view, boxSize, id, isRm);\n}\nTpos boxInfXIntersection(in Ray view, in vec2 boxSize, in int id, in bool isRm) \n{\n    vec2 ro = view.o.yz, rd = view.d.yz, invRd = 1./rd, invRdRo = invRd*ro;\n    vec2 k = abs(invRd)*boxSize;\n    vec4 t12 = -invRdRo.xyxy + vec4(-k, k);\n    vec2 tNF = vec2(max(t12.x, t12.y), min(t12.z, t12.w));\n    if(tNF.x > tNF.y || tNF.y < 0.) return Tpos(-1., -1., id, isRm);\n    return Tpos(tNF.x, tNF.y, id, isRm);\n}\nTpos boxInfXIntersection(in Ray view, in float top, in float bottom, in float width, in float moveZ, in int id, in bool isRm) \n{\n    vec2 boxSize = vec2(top - bottom, width);\n    view.o.yz -= vec2(top + bottom, moveZ);\n    return boxInfXIntersection(view, boxSize, id, isRm);\n}\nTpos boxInfXIntersection(in Ray view, in float top, in float bottom, in float width, in int id, in bool isRm) \n{\n    return boxInfXIntersection(view, top, bottom, width, 0., id, isRm);\n}\n\n// --------- CSG modelisation with SDF\n\n// ----- Street lamp SDF parts\n// tbh I dont know how different street light parts are supposed to be named\nfloat streetLampBodySDF(in vec3 pp)\n{\n    pp.xy = vec2(length(pp.xz), pp.y);\n    \n    const float th1 = .015;\n    const float py1 = .48;\n    const float py2 = -.175;\n    \n    vec2 p = pp.xy;\n    vec2 ap = abs(p.xy);\n    \n    float a = atan(p.x, pp.z);\n    vec2 p1 = vec2(ap.x, p.y + .25)*ROT(0.008) - cos(a*15.)*.0003;\n    float b1 = p1.x - th1;\n    float c1 = length(p.xy + vec2(0., py1 - .06)) - .04;\n    float c2 = length(p.xy + vec2(0., py1 - .015)) - .06;\n    c1 = max(c1, c2);\n    float c3 = length(p.xy + vec2(0., py1 - .1)) - .03;\n    float c4 = length(vec2(ap.x -.065, p.y + py1 - .14)) - .05;\n    c2 = max(c3, -c4);\n    float b2 = length(max(abs(p + vec2(0., py1 - .16)) - vec2(.015, .003), 0.)) - .01;\n    float b3 = max(ap.x - .04, p.y + py1 - .02);\n    float c5 = length(vec2(ap.x - .06, p.y + py1 - .04)) - .05;\n    b3 = max(b3, -c5);\n    float apy2 = abs(p.y + py2) - .019;\n    float b4 = max(ap.x - .022, abs(apy2) - .02);\n    float c6 = length(vec2(ap.x - .026, abs(apy2) - .018)) - .014;\n    b4 = max(b4, -c6);\n    float py3 = py2 - .265;\n    float c7 = (length(vec2(p.x*1.5, p.y + py3)) - .022)/1.5;\n    float c8 = max(length(vec2(p.x, p.y + py3 + .03)) - .016, -(p.y + py3 + .03));\n    c7 = min(c7, c8);\n    \n    float d = b1;\n    d = min(d, c1);\n    d = min(d, c2);\n    d = min(d, b2);\n    d = min(d, b3);\n    d = min(d, b4);\n    d = max(d, p.y + py3);\n    d = min(d, c7);\n    \n    return d;\n}\nfloat lampSupportSubPartSDF(in vec3 pp)\n{\n    const float th1 = .0055;\n    const float r1 = .1;\n    vec2 p = pp.xy;\n    float c1 = length(vec2(length(p) - .1, pp.z)) - th1;\n    c1 = max(c1, max(p.x, -p.y));\n    float c2 = length(vec2(length(vec2(p.x, p.y - r1*(1. - .45))) - r1*.45, pp.z)) - th1;\n    c2 = max(c2, -max(p.x, -p.y));\n    float p1x = p.x + r1*(1. - .35);\n    float c3 = length(vec2(length(vec2(p1x, p.y)) - r1*.35, pp.z)) - th1;\n    c3 = max(c3, max(p1x, p.y));\n    c1 = min(c1, c2);\n    c1 = min(c1, c3);\n    return c1;\n}\nfloat lampSupport1SDF(in vec3 pp)\n{\n    pp.x -= .115;\n    \n    vec2 p = pp.xy;\n    \n    const float th2 = .0025;\n    p.y -= .13;\n    p.x += .055;\n    vec2 pp1 = abs(p) - vec2(.02, .03);\n    float c4 = length(vec2(length(pp1) - .03, pp.z)) - th2;\n    c4 = max(c4, max(-pp1.x, pp1.y));\n    c4 = max(max(c4, -max(p.x, p.y)), -max(-p.x, -p.y));\n    c4 = min(c4, max(length(vec2(p.y, pp.z)) - th2 - smoothstep(0.015, 0.00, abs(p.x))*.005, abs(p.x) - .029));\n    \n    float d = lampSupportSubPartSDF(pp);\n    d = min(d, c4);\n    return d;\n}\nfloat lampSupport2SDF(in vec3 pp)\n{\n    vec3 p = pp;\n    p.y += .3;\n    vec3 ap1 = abs(p);\n    float b1 = max(max(ap1.x - .135, ap1.y - .0075), ap1.z - .0075);\n    float c1 = max(length(ap1.xz*ROT(-T/8.) - .0885) - .007 - p.y*.1, abs(p.y) - .03);\n    b1 = min(b1, c1);\n    const float sz1 = 1.5;\n    vec3 p1 = p*sz1 - vec3(.12,-.112,0.);\n    b1 = min(b1, lampSupportSubPartSDF(p1)/sz1);\n    return b1;\n}\nfloat lampSDF(in vec3 p, inout int sdfId)\n{\n    p.y -= .02;\n    p.x -= .125;\n    \n    vec2 p1 = vec2(length(p.xz), p.y);\n    float py1 = p.y + 0.14;\n    float py2 = p.y + .25;\n    float c2 = length(p.xz);\n    float n1 = max(dot(p1.xy, normalize(vec2(3., 1.))), abs(py1 - .07) - .06);\n    n1 = min(n1, max(c2 - .05, abs(py1) - .008));\n    vec3 p2 = vec3(p.x, py1, p.z);\n    p2.xz = abs(p2.xz) - .03;\n    p2.xz *= ROT(T/8.);\n    p2.yx *= ROT(.068);\n    float lightBulb = c2 - .025*(IS_NIGHT - .1);\n    float c1 = min(length(p2.xz) - .003, lightBulb);\n    c1 = max(max(c1, py1), -py2);\n    float c3 = max(c2 - .04, abs(py2) - .004);\n    vec3 p3 = vec3(p.xz, py2);\n    float s1 = max(length(p3) - .03, abs(py2 + .01) - .01);\n    float s2 = length(p3 + vec3(0.,0.,.03)) - .012;\n    s1 = min(s1, s2);\n    \n    float d = n1;\n    d = min(d, c1);\n    d = min(d, c3);\n    d = min(d, s1);\n\n    sdfId =\n        d == lightBulb ? S_LAMP_LIGHTBULB_SDF_ID\n        : S_LAMP_BODY_SDF_ID;\n\n    return d;\n}\nfloat streetLampBaseSDF(in vec3 pp)\n{\n    vec3 p1 = pp + vec3(0., 0.51, 0.);\n    const vec3 dim = vec3(.1, .05, .035);\n    float b1 = box(p1, dim*vec3(1.,.1,1.));\n    p1.y += .04;\n    b1 = min(b1, box(p1, dim*.8));\n    p1.y += .01;\n    b1 = min(b1, box(p1, dim*vec3(1.3,.1,1.3)));\n    p1.y += .095;\n    b1 = min(b1, box(p1, dim*vec3(1.2, 1.8, 1.2)));\n    return b1;\n}\nfloat streetLampSDF(in vec3 pp, in float type, inout int sdfId)\n{\n    const vec3 position = vec3(0., .785, .7);\n    const float size = .5;\n    \n    pp = vec3(pp.xy, abs(pp.z));\n\n    pp -= position;\n    pp /= size;\n    vec3 q = pp;\n    float ver4 = type; // 1. or 0.\n    float nd = 3. + ver4;\n    float a = atan(q.x, q.z)/T + .5;\n    float aId = floor(a*nd + 1.24 + ver4*(1.5 - 1.24));\n    q.xz *= ROT(-aId*(T/nd));\n    q.y -= .25;\n    \n    float d = streetLampBodySDF(pp);\n    d = min(d, mix(lampSupport1SDF(q), lampSupport2SDF(q), ver4));\n    d = min(d, lampSDF(q, sdfId));\n    d = max(d, -(pp.y + .5));\n    d = min(d, streetLampBaseSDF(pp));\n    \n    return d*size;\n}\n\n// ----- Fences SDF\nfloat fencesSDF(in vec3 p, inout int sdfId)\n{\n    vec3 ap = abs(p);\n    // fencesSDF\n    float aposz = abs(ap.z - 0.7);\n    float aposy = abs(p.y - .435);\n    const float th1 = .002;\n    float b4 = max(abs(p.y - .48) - .005, aposz - .01);\n    float b5 = max((abs(aposy - .025) - th1), aposz - th1);\n    float b6 = max(max(ap.x - .14, aposy - .053), aposz - .015) - step(.465, p.y)*.0015; // bad\n    const float divx1 = .25;\n    float ppx1 = REP(p.x, divx1);\n    float b7 = max(max(abs(ppx1) - .015, aposz - th1), aposy - .05);\n    const float divx2 = .05;\n    float ppx2 = REP(p.x + .025, divx2);\n    float b8 = max(max(abs(ppx2) - th1, aposz - th1), aposy - .05);\n    const float th2 = .001;\n    float ppx3 = REP(p.x, divx2);\n    vec2 ppcr = vec2(ppx3, p.y - .435);\n    ppcr = abs(ppcr);\n    ppcr *= ROT(-T/8.);\n    float ppx4 = REP(p.x + divx1*.5, divx1);\n    float b9 = max(min(max(abs(ppcr.x) - th2, abs(ppcr.y) - .06), abs(length(ppcr) - .0145) - th2), abs(ppx4) - .1);\n    b9 = max(b9, aposz - th2);\n    b4 = min(b5, b4);\n    b4 = min(b4, b7);\n    b4 = min(b4, b8);\n    b4 = min(b4, b9);\n\n    float lampPillar = b6;\n    b4 = min(b4, lampPillar);\n\n    const vec3 position = vec3(0., .785, .7);\n    const float size = .5;\n    vec3 pp  = vec3(p.xy, ap.z);\n    pp -= position;\n    pp /= size;\n    float lampBase = streetLampBaseSDF(pp)*size;\n    b4 = min(b4, lampBase);\n\n    sdfId =\n        b4 == lampPillar ? S_LAMP_WALL_SDF_ID\n        : S_LAMP_BODY_SDF_ID;\n\n    return b4;\n}\n\n// ----- Bridge SDF parts\nfloat bridgePillarSDF(in vec3 p, inout int sdfId)\n{\n    const float rd1 = .25;\n    vec3 ap = abs(p);\n    vec2 k = vec2(\n        mix(\n            length(vec2(p.x, ap.z - .625)) - rd1,\n            ap.x - rd1,\n            step(ap.z, .625)\n        ),\n        p.y + .185\n    );\n    float s1 = max(dot(k, normalize(vec2(.2, 1.))), k.x + .1);\n    s1 = min(s1, max(abs(k.y) - .01, k.x + .09));\n    s1 = min(s1, max(abs(k.y + .005) - .01, k.x + .095));\n    s1 += p.y*.02; // bad\n\n    sdfId = BRIDGE_PILLAR_SDF_ID;\n\n    return s1;\n}\nfloat bridgeDecoSDF(in vec3 p, inout int sdfId)\n{\n    const float szMain = .15;\n    const float rd1 = .5;\n    const float th1 = .05;\n    const float rd2 = .04;\n    const float th2 = .02;\n    const float h = .08;\n    const float rd3 = .04;\n    const float th3 = .005;\n\n    p.z = abs(p.z) - .599;\n    p.y -= .125;\n\n    p /= szMain;\n\n    float c1 = length(p.xy) - rd1;\n    float disc1 = max(abs(p.z - th1*.25) - .05, (c1));\n    float tor1 = RBOX(vec2(c1, p.z), th1, .07);\n\n    vec3 p1 = p;\n    float isUp = step(0., p1.y);\n    p1.y = abs(p1.y);\n    p1.y -= rd1 - .0125*(1. - isUp);\n    p1.xy = abs(p1.xy);\n    p1.xy *= ROT(-.5*isUp);\n    float b1 = RBOX(p1, vec3(.1 + .6*(1. - isUp), 1, 1)*(th1 + .065), .02);\n\n    p.z -= th1*1.25;\n\n    vec3 p2 = vec3(abs(p.x), p.yz);\n    vec3 p3 = p2;\n    p2.y += rd1 + .28;\n    float apx = p2.x - rd2*3.;\n    float sapx1 = sign(apx);\n    float sapx2 = 1. - (sapx1*.5 + .5);\n    float b2 = max(RBOX(vec2(abs(apx) - rd2*2., p2.z), th2, .01), abs(p2.y + h*sapx1*sapx2) - (.02 + .06*sapx2));\n    p2.xy = vec2((p2.x - rd2*3.) - sign(p2.y)*rd2, elong(p2.y, h));\n    float tor2 = RBOX(vec2(length(p2.xy) - rd2, p2.z), th2, .01);\n    tor2 = min(tor2, b2);\n\n    float tor3 = RBOX(vec2(length(p3.xy + vec2(-rd3, rd1 - .185)) - rd3, p3.z), th3, .01);\n\n    float d = tor1;\n    d = min(d, b1);\n    d = min(d, tor2);\n    d = min(d, tor3);\n    d = min(d, disc1);\n\n    sdfId =\n        d == disc1 ? BRIDGE_DECO_INTER_SDF_ID\n        : BRIDGE_DECO_CORONA_SDF_ID;\n\n    return d*szMain;\n}\n\nfloat bridgeSDF(in vec3 p, inout int sdfId)\n{\n    vec3 ap = abs(p);\n\n    const vec2 sz1 = vec2(341./880., 63./105.);\n    \n    float b1 = max(ap.y - sz1.x, ap.z - sz1.y);\n    float c1 = length(vec2(ap.x - 1., p.y + sz1.x*2.15)) - 1.;\n    float c2 = length(vec2(ap.x - 1., p.y + sz1.x*3.2)) - 1.5;\n    \n    float c3 = max(max(min(c2, p.y + .06), -c1), ap.z - sz1.y - .02);\n    vec3 pc4 = vec3(p.xy, ap.z);\n    const float radc4 = 4.2;\n    float dist2c4 = radc4 + sz1.y - .05;\n    pc4.yz *= ROT(0.27);\n    float c4 = length(abs(pc4.xz) - vec2(1., dist2c4)) - radc4;\n    \n    float b2 = max(abs(p.y - .37) - .03, ap.z - .725);\n    vec2 pp = p.xy;\n    const float lll = 1./82.;\n    pp.x = mod(pp.x, lll*4.) - lll*2.;\n    pp = abs(pp - vec2(0., .3));\n    float b3 = max(max(pp.x - lll*1.2, pp.y - .07), abs(ap.z - .75) - .05);\n    b2 = max(b2, -b3);\n\n    int bpSdfId;\n\n    float pillar = bridgePillarSDF(p, bpSdfId);\n\n    int bridgeDecoSdfId;\n    float bridgeDeco = bridgeDecoSDF(p, bridgeDecoSdfId);\n    \n    float d = max(b1, -c1);\n    d = min(d, c3);\n    d = max(d, -c4);\n    d = min(d, pillar);\n    d = min(d, b2);\n    d = min(d, bridgeDeco);\n\n    sdfId =\n        d == b2 ? BRIDGE_MOLDING_SDF_ID\n        : d == pillar ? BRIDGE_PILLAR_SDF_ID\n        : d == -c4 || d == c3 ? BRIDGE_VAULT_SDF_ID\n        : d == bridgeDeco ? bridgeDecoSdfId\n        : BRIDGE_WALL_SDF_ID;\n\n    return d;\n}\n\n// coordinate transformations applied to the scene\nvoid sdfGlobalMap(inout vec3 p, inout float dId)\n{\n    dId = REP_ID_CYCLIC(p.x, 2., 2.);\n    p.x = REP(p.x, 2.);\n}\n\n// compute ALL sdf of the scene, really heavy\nfloat sdfMain1(in vec3 p, inout int sdfId)\n{\n    float dId;\n    sdfGlobalMap(p, dId);\n    float d = bridgeSDF(p, sdfId);\n    d = min(d, fencesSDF(p, sdfId));\n    d = min(d, streetLampSDF(p, dId, sdfId));\n    return d;\n}\nfloat sdfMain1(in vec3 p)\n{\n    int sdfId;\n    return sdfMain1(p, sdfId);\n}\n\n// compute selected sdf with its associated bounding box id\nfloat sdfMain2(in vec3 p, in int bbId, inout int sdfId)\n{\n    float divId, dSurface = 10e9;\n    \n    vec3 pp = p;\n    sdfGlobalMap(pp, divId);\n    \n    switch(bbId)\n    {\n    case BRIDGE_BB_ID:      dSurface = bridgeSDF(pp, sdfId); break;\n    case FENCE_BB_ID:       dSurface = fencesSDF(pp, sdfId); break;\n    case STREET_LAMP_BB_ID: dSurface = streetLampSDF(pp, divId, sdfId); break;\n    }\n    \n    dSurface = mix(max(dSurface, abs(p.x) - 1.52), dSurface, INFINITE_BRIDGE_ENABLED);\n    float dGrid = GRID_SDF(p, GRID_MODE_SIZE, GRID_MODE_THICKNESS, dSurface);\n    return mix(\n        dSurface,\n        dGrid,\n        mix(1., step(p.x - GRID_MODE_POS_X, 0.), GRID_MODE_POS_ENABLED)*GRID_MODE_ENABLED\n    );\n}\n\nfloat sdfMain2(in vec3 p, in int bbId)\n{\n    int sdfId;\n    return sdfMain2(p, bbId, sdfId);\n}\n\n// --------- SDF normal\nvec3 sdfNormal(in vec3 p, in int bbId)\n{\n    vec3 u = vec3(0., BB_RM_SETTINGS[bbId].epsilon, sdfMain2(p, bbId));\n    return normalize(vec3(sdfMain2(p + u.yxx, bbId), sdfMain2(p + u.xyx, bbId), sdfMain2(p + u.xxy, bbId)) - u.z);\n}\n\n// --------- SDF ray marching\nbool intersectSDF(in Tpos tHit, in Ray view, out float t, out int nbIterations, inout int sdfId)\n{\n    nbIterations = 0;\n    int i = BB_RM_SETTINGS[tHit.bbId].maxStep;\n    float d, epsilon = BB_RM_SETTINGS[tHit.bbId].epsilon;\n    for(t = tHit.min; (d = sdfMain2(GET_POS(view, t), tHit.bbId, sdfId)) >= epsilon; t += d)\n    {\n#ifdef DEBUG_PERFORMANCES_ENABLED\n        STEP_OBSERVER++;\n#endif\n        if(t > tHit.max) return false; // no need to iterate outside of the current bounding box (no intersection found)\n        if(i-- < 0) break;             // \"return break\" here is just cheating for removing holes in rendering\n        nbIterations++;\n    }\n    return true;\n}\n\n// --------- Bounding box functions\nvoid keepNearestT(in float t, in Tpos tTest, inout Tpos tOut)\n{\n    if(IS_BETWEEN(tTest.min, t, tOut.min))\n    {\n        tOut.min = tTest.min;\n        tOut.bbId = tTest.bbId;\n        tOut.isRm = tTest.isRm;\n    }\n    else if(IS_BETWEEN(tTest.max, t, tOut.min) || IS_BETWEEN(t, tTest.min, tTest.max))\n    {\n        tOut.min = t;\n        tOut.bbId = tTest.bbId;\n        tOut.isRm = tTest.isRm;\n    }\n    \n    if(IS_BETWEEN(tTest.max, tOut.min, tOut.max))\n        tOut.max = tTest.max;\n    else if(IS_BETWEEN(tTest.min, tOut.min, tOut.max))\n        tOut.max = tTest.min;\n}\n\nvoid updateAllBB(in Ray view)\n{\n    const float bridgeTop = .2005;\n    const float bridgeBottom = -.2;\n    const float bridgeThickness = .789;\n    const float zGap = .7;\n    const float fenceBottom = bridgeTop + 10e-7;\n    const float fenceTop = fenceBottom + .043;\n    const float fenceThickness = .022;\n    const float streetLampBottom = fenceTop;\n    const float streetLampTop = streetLampBottom + .266;\n    const float streetLampThickness = .088;\n    const float waterTop = bridgeBottom;\n    const float waterBottom = waterTop - 10e-5;\n    const float skyBottom = 3.;\n    const float skyTop = skyBottom + 8.;\n    BB_TPOS_LIST[0] = boxInfXIntersection(view, fenceTop, fenceBottom, fenceThickness, zGap, FENCE_BB_ID, true);\n    BB_TPOS_LIST[1] = boxInfXIntersection(view, fenceTop, fenceBottom, fenceThickness, -zGap, FENCE_BB_ID, true);\n    BB_TPOS_LIST[2] = boxInfXIntersection(view, bridgeTop, bridgeBottom, bridgeThickness, BRIDGE_BB_ID, true);\n    BB_TPOS_LIST[3] = boxInfXIntersection(view, streetLampTop, streetLampBottom, streetLampThickness, zGap, STREET_LAMP_BB_ID, true);\n    BB_TPOS_LIST[4] = boxInfXIntersection(view, streetLampTop, streetLampBottom, streetLampThickness, -zGap, STREET_LAMP_BB_ID, true);\n    BB_TPOS_LIST[5] = boxInfXZIntersection(view, waterTop, waterBottom, WATER_BB_ID, false);\n}\n\nvoid intersectAllBB(in float t, out Tpos tHit)\n{\n    tHit = Tpos(10e9, 10e9, UNDEFINED_BB_ID, false);\n    for(int i = 0; i < BB_TPOS_LIST_SIZE; i++)\n        keepNearestT(t, BB_TPOS_LIST[i], tHit);\n}\n\nResult intersectBB(in Ray ray)\n{\n    updateAllBB(ray);\n    Tpos tHit;\n    float t = 0.;\n    int sdfId = UNDEFINED_SDF_ID, nbIterations = 0;\n    for(int i = 0; i < BB_INTERSECT_IT_MAX; i++)\n    {\n        intersectAllBB(t, tHit);\n#ifdef SHOW_BOUNDING_BOXES_ENABLED\n        if(IS_RIGHT_HALF_SCREEN) break;\n#endif\n        if(tHit.isRm)\n        {\n            if(intersectSDF(tHit, ray, t, nbIterations, sdfId))\n                break;\n            t = tHit.max;\n        }\n        else\n        {\n            t = tHit.min;\n            break;\n        }\n    }\n    return Result(t, tHit.bbId, sdfId, nbIterations, tHit.isRm, ray);\n}\n\n// --------- Material and color functions\nfloat starSdf(in vec2 p, in float divVal, in float sizeMin, in float sizeMax, in float seed)\n{\n    p *= ROT(seed);\n    vec2 pId = REP_ID(p, divVal)*seed;\n    p = REP(p, divVal);\n    float rd1 = RAND(pId);\n    float rd = mix(divVal*sizeMin, divVal*sizeMax, rd1);\n    p += vec2(rd1, RAND(pId.yx*12.78))*(divVal*.5 - rd);\n    return length(p) - rd;\n}\n\nfloat starySky(in vec2 uv, in float size)\n{\n    float aa = 10e-4;\n    vec2 minMax = vec2(.05, .1);\n    uv *= size;\n    float fc = .2 + .05; // cnoise(uv*size*.05)*.5 + \n    minMax *= fc;\n    float d = starSdf(uv, .4, minMax.x, minMax.y, 1.);\n    d = min(d, starSdf(uv, .55, minMax.x, minMax.y, 4.));\n    d = min(d, starSdf(uv, .3333, minMax.x, minMax.y, 6.));\n    return smoothstep(0., -aa*2., d/size);\n}\n\nvoid computeSkyColor(in vec3 ray, in vec3 sunDir, inout vec3 outColor, inout vec3 outColorOnly, inout vec3 ambientOut, inout float isNight, inout float isNightTransition)\n{\n    const float sunRadius = 0.;\n    const float sunBlur = .00005;\n    const vec3 sunColor = vec3(1.15, 1.1, 1.)*100.;\n\n    float sunDistReal = dot(ray, sunDir)*.5 + .5;\n    float sunDist = dot(ray, sunDir) + 1. - sunRadius;\n    float sunHeight = sunDir.y*.5 + .5;\n    float horizonDist = dot(vec3(0,1,0), ray) * .5 + .5;\n    float sunInfluenceDist = opSmoothUnion(horizonDist - .5, sunDistReal - .001, .2);\n    \n    float skyDayCurve = SS_QUAD(horizonDist);\n    vec3 skyDay = mix(vec3(0.554,0.909,0.985), vec3(0.159,0.493,0.985)*.5, skyDayCurve);\n    \n    float curveA = POW5(1. - sunDistReal);\n    vec3 colorA = mix(vec3(0.985,0.549,0.218), vec3(0.960,0.690,0.350), curveA);\n    float skyRiseCurve = smoothstep(-.01, .1, sunInfluenceDist);\n    skyRiseCurve = clamp(1. - POW5(1. - sunInfluenceDist), 0., 1.);\n    vec3 skyRise = mix(colorA, vec3(0.226,0.409,0.985)*.5*(1. - .5*sunHeight), skyRiseCurve);\n    \n    float skyNightCurve = SS_QUAD(sunDistReal);\n    vec3 skyNight = mix(vec3(0.031,0.076,0.115)*.5, vec3(0.015,0.075,0.185)*.1, skyNightCurve);\n\n    float nightDayCurve = smoothstep(.45, .55, sunHeight);\n    vec3 sky = mix(skyDay, skyNight, nightDayCurve);\n\n    isNight = smoothstep(.55, .65, sunHeight);\n    isNightTransition = smoothstep(.45, .5, sunHeight)*smoothstep(.65, .60, sunHeight);\n    \n    float transitionCurve = smoothstep(.0, .2, abs(sunHeight - .5));\n    sky = mix(skyRise, sky, transitionCurve);\n\n    ambientOut = mix(\n        vec3(0.438,0.335,0.230),\n        mix(vec3(.122,.438,.985), vec3(.122,.438,.985)*.01, nightDayCurve),\n        transitionCurve\n    );\n\n    outColorOnly = sky;\n\n    sky = mix(sky, sunColor, smoothstep(sunBlur, -sunBlur, sunDist));\n    \n    vec2 pol = vec2(atan(ray.x, ray.z), ray.y);\n    float stars = starySky(pol, 30.);\n    sky = mix(sky, sky + stars*.8, nightDayCurve);\n    \n    outColor = sky;\n}\n\n// A basic procedural brick texture\nvoid brickSdf(in vec2 p, in float aa, inout vec2 pId, inout float dOut,\n    in float gapBase, in float gapRdn, in float sz, in vec2 pat, in float rdBase)\n{\n    pat /= sz;\n    rdBase /= sz;\n    \n    pId = REP_ID(p, pat);\n    p.x += RAND(pId.yy)*pat.x;\n    pId = REP_ID(p, pat);\n    p = REP(p, pat);\n\t\n    float rd1 = RAND(pId.xy);\n    float gap = (gapBase + rd1*gapRdn)/sz;\n    float d = RBOX(p, (pat - rdBase*2. - gap)*.5, rdBase);\n    \n    dOut = smoothstep(-aa, aa, d);\n}\n\n// Set material settings depending on intersected sdf (messy code here)\nvoid getMaterialSettings(in float isNight, in int sdfId, in vec3 p, inout SMatSettings material)\n{\n    const vec3 mainTone = vec3(0.990,0.734,0.538);\n    const vec3 secTone = vec3(0.990,0.666,0.370);\n    const vec3 brickTone = vec3(0.975,0.385,0.273);\n    switch(sdfId)\n    {\n    case S_LAMP_BODY_SDF_ID:\n        material.albedo = vec3(.2);\n        material.specAmt = .9;\n        material.specPow = 20.;\n        break;\n    case S_LAMP_WALL_SDF_ID:\n        {\n            vec2 uv = vec2(REP(p.x, 2.), p.y + .058);\n            vec2 pId;\n            float d;\n            brickSdf(uv, MIN2(fwidth(uv)), pId, d, .005, .05, 22., vec2(1.,.5), .04);\n            vec3 c = mainTone;\n            material.albedo = mix(c*mix(.7, 1., RAND(pId)), c*1.1, d);\n            material.specAmt = 0.;\n        }\n        break;\n    case S_LAMP_LIGHTBULB_SDF_ID:\n        material.isEmissive = true;\n        material.albedo = isNight*vec3(1.,1.,.7)*4.;\n        break;\n    case BRIDGE_MOLDING_SDF_ID:\n        {\n            vec2 uv1 = vec2(REP(p.x, 2.), p.y), uv2 = p.xz, pId1, pId2;\n            float isBridgeFloor = step(max(abs(p.z) - .65, -p.y + .35), 0.), d1, d2;\n            brickSdf(uv1, 10e-3, pId1, d1, .005, .05, 1., vec2(4./82.,1.), .0);\n            brickSdf(uv2, length(fwidth(uv2)), pId2, d2, .001, .002, 1., vec2(.035), .005);\n            vec3 c1 = mainTone, c2 = vec3(secTone);\n            material.albedo = mix(\n                mix(c1*mix(.7, 1., RAND(pId1)), c1*1.1, d1),\n                mix(c2*mix(.7, 1., RAND(pId2)), mainTone*1.1, d2),\n                isBridgeFloor\n            );\n            material.specAmt = 0.;\n        }\n        break;\n    case BRIDGE_PILLAR_SDF_ID:\n        {\n            float apZ = abs(p.z) - .625;\n            vec2 uv1 = vec2(REP(p.x, 2.), apZ);\n            vec2 pol = vec2(atan(uv1.x, uv1.y)/T, p.y);\n            vec2 uv2 = vec2(p.z, p.y);\n            vec2 uv = mix(uv2, pol, step(.0, apZ));\n            vec2 pId;\n            float d;\n            brickSdf(uv, MIN2(fwidth(uv)), pId, d, .005, .05, 20., vec2(1.,.8), .04);\n            vec3 c = mainTone*1.2;\n            material.albedo = mix(c*mix(.5, 1., RAND(pId)), c*.4, d);\n            material.specAmt = 0.;\n        }\n        break;\n    case BRIDGE_VAULT_SDF_ID:\n        {\n            float isVaultInt = step(max(abs(p.z) - .55, -p.y - .2), 0.), d1, d2;\n            p.xy = vec2(REP(p.x + 1., 2.), p.y + .85);\n            vec2 pol1 = vec2(length(p.xy), atan(p.x, p.y)), pId1;\n            vec2 pol2 = vec2(pol1.y, p.z), pId2;\n            brickSdf(pol1, 10e-2, pId1, d1, .005, .01, 7., vec2(1.,.2), .001);\n            brickSdf(pol2, MIN2(fwidth(pol2)), pId2, d2, .02, .01, 25., vec2(1.,.2), .05);\n            vec3 c1 = mainTone, c2 = brickTone;\n            material.albedo = mix(\n                c1*mix(.7, 1., RAND(pId1)),\n                mix(c2*mix(.7, 1., RAND(pId2)), vec3(1.,.8,.5), d2),\n                isVaultInt\n            );\n            material.specAmt = 0.;\n        }\n        break;\n    case BRIDGE_WALL_SDF_ID:\n        {\n            p.xy = vec2(REP(p.x + 1., 2.), p.y + 1.2);\n            vec2 pol = vec2(atan(p.x, p.y), length(p.xy)).yx, pId;\n            float d;\n            brickSdf(pol, MIN2(fwidth(pol)), pId, d, .02, .01, 25., vec2(1.,.2), .05);\n            vec3 c = brickTone;\n            material.albedo = mix(c*mix(.7, 1., RAND(pId)), vec3(1.,.8,.5), d);\n            material.specAmt = 0.;\n        }\n        break;\n    case BRIDGE_DECO_INTER_SDF_ID:\n        {\n            vec2 uv = p.xy;\n            vec2 pId;\n            float d;\n            brickSdf(uv, 10e-5, pId, d, .005, .01, 5., vec2(1.,.2), .01);\n            vec3 c = mainTone*.8;\n            material.albedo = mix(c*mix(.9, 1., RAND(pId)), c*1.05, d);\n            material.specAmt = 0.;\n        }\n        break;\n    case BRIDGE_DECO_CORONA_SDF_ID:\n            material.albedo = mainTone;\n            material.specAmt = 0.;\n        break;\n    }\n}\n\nvoid shadingDay(in SMatSettings mat, in vec3 amb, in vec3 vd, in vec3 n, in vec3 ld, in float penumbra, inout vec3 outColor)\n{\n    amb *= .05 + .1*max(0., dot(reflect(ld, vec3(0,1,0)), n));\n    float diff = max(0., dot(-ld, n));\n    float spec = pow(max(0., dot(-vd, reflect(ld, n))), mat.specPow);\n    outColor = (amb*6. + vec3(mix(mix(diff, spec, mat.specAmt), 0., penumbra)))*mat.albedo;\n}\n\nfloat getLightPower(in SMatSettings mat, in vec3 lpos, in vec3 n, in vec3 vd, in vec2 pw)\n{\n    float dist = length(lpos);\n    vec3 ld = lpos/dist;\n    float diff = max(0., dot(-ld, n));\n    return (pw.x*diff)/pow(dist, pw.y);\n}\n\nvoid computeShading(in Result res, in float isNightTransition, in vec3 ambientColor, inout vec3 outColor)\n{\n    vec3 p = GET_POS(res.ray, res.t), n = sdfNormal(p, res.bbId);\n\n    SMatSettings mat = SMatSettings(vec3(1), .4, 10., false);\n    getMaterialSettings(IS_NIGHT, res.sdfId, p, mat);\n\n#ifdef SHADING_DISABLED\n    outColor = mat.albedo; return;\n#endif\n    \n    // for light bulbs\n    if(mat.isEmissive)\n    {\n        outColor = mat.albedo;\n        return;\n    }\n    \n    vec3 vd = res.ray.d, ldir;\n    float penumbra, lum, isBottomLight;\n\n    { // night lights\n        isBottomLight = step(p.y - .37, 0.);\n        vec3 ppf = vec3(\n            DIV_F(p.x, 2.) + 1.,\n            mix(vec2(1.3, sign(p.z)*.7), vec2(0., sign(p.z)*.75), isBottomLight)\n        );\n        vec2 pw = mix(vec2(.3, 7.), vec2(.03, 3.), isBottomLight)*vec2(IS_NIGHT, 1.);\n        vec3 ld1 = p - ppf; // closest light\n        vec3 ld2 = p - ppf - vec3(2.*sign(REP(p.x, 2.)), 0., 0.); // left and right ligths\n        vec3 ld3 = p - ppf + vec3(0., 0., 1.4*sign(p.z)); // in front light\n        lum = getLightPower(mat, ld1, n, vd, pw)\n            + getLightPower(mat, ld2, n, vd, pw)\n            + getLightPower(mat, ld3, n, vd, pw);\n        lum *= IS_NIGHT;\n\n        ldir = mix(SUN_DIRECTION, ld1, step(.1, IS_NIGHT));\n    }\n\n    { // shadow\n        Result shadowRes = intersectBB(getShadowRay(p, n, ldir));\n        penumbra = float(shadowRes.bbId != UNDEFINED_BB_ID);\n        penumbra = mix(penumbra, penumbra*(1. - isBottomLight), step(.1, IS_NIGHT));\n        penumbra = mix(penumbra, 1., isNightTransition);\n        if(res.bbId == STREET_LAMP_BB_ID) lum = 0.;\n    }\n\n    // little trick (specular lights cannot work during night)\n    mat.specAmt = mix(mat.specAmt, 0., IS_NIGHT);\n    \n    // compute shading\n    shadingDay(mat, ambientColor, vd, n, ldir, penumbra, outColor);\n\n    // adjusting color\n    outColor *= mix(vec3(1), lum*vec3(1.,.9,.6), IS_NIGHT);\n\n    // approximative ambient occlusion\n    {\n        float k = max(0., 1. - float(res.nbIterations)/float(BB_RM_SETTINGS[res.bbId].maxStep));\n        outColor = mix(outColor, outColor*k*k, penumbra*(1. - IS_NIGHT));\n    }\n}\n\n// --------- Scene setting and rendering functions + animations\nvoid computeWaterReflectionIntersection(in float time, inout float fresnelAngle, inout Ray view, inout Result res)\n{\n    vec3 p = GET_POS(view, res.t), n = vec3(0., 1., 0.);\n\n    vec2 uv = p.xz, uv2 = uv + time*.2, uv3 = uv + time*.1;\n    vec2 sh = vec2(cnoise(uv2), cnoise(-uv3*8.5))*.2;\n    float pillarsSdf = sdfMain2(vec3(uv.x, -.95, uv.y), BRIDGE_BB_ID);\n    float pillarWave = mix(cos(pillarsSdf*20. - time*3.), 0.1, min(pillarsSdf*1.5, 1.));\n\n    float a = dot(view.d, n)*.5 + .5;\n    float ma = (1. - pow(a*2.02, 3.5));\n\n    n = normalize(n + vec3(sh.x, 0., sh.y)*pillarWave*ma);\n\n    fresnelAngle = clamp(a*a*a*8., .1, .98);\n\n    view = getReflectedRay(p, n, view.d);\n    res = intersectBB(view);\n}\n\nfloat croissantSdf(in vec2 p, in float off2, in float anim)\n{\n    p = -p;\n    float off1 = mix(.075, .13, anim);\n    float d1 = MOON(p - vec2(0., off1));\n    float d2 = MOON(p*ROT((T/3.)*1.) - vec2(0., off1));\n    float d3 = MOON(p*ROT((T/3.)*2.) - vec2(0., off1));\n    d1 = max(d1, -d3 + off2);\n    d2 = max(d2, -d1 + off2);\n    d3 = max(d3, -d2 + off2);\n    return min(d1, min(d2, d3));\n}\n\nvoid computeScene(in Ray view, in float time,\n    in float pixelateDist, in float tPlane, in vec3 bgColor, inout vec3 colorOut,\n    in vec3 patternColor\n    )\n{\n    vec3 skyColor, skyColorOnly, ambientColor;\n    float isNightTransition;\n    computeSkyColor(view.d, SUN_DIRECTION, skyColor, skyColorOnly, ambientColor, IS_NIGHT, isNightTransition);\n    \n    Result res = intersectBB(view);\n    vec3 pos = GET_POS(res.ray, res.t);\n    \n    float patternOpacity = tPlane <= res.t ? pixelateDist : 0.;\n    \n    if(GRID_MODE_ENABLED*(1. - GRID_MODE_POS_ENABLED) > 0.\n        || (GRID_MODE_POS_ENABLED > 0. && (pos.x < GRID_MODE_POS_X))\n    )\n    {\n        colorOut = res.isRm ? vec3(1.) : bgColor;\n        colorOut = mix(colorOut, patternColor, patternOpacity);\n        return;\n    }\n    \n    float depht = res.t, fresnelAngle = 1.;\n    if(res.bbId == WATER_BB_ID)\n    {\n        computeWaterReflectionIntersection(time, fresnelAngle, view, res);\n        computeSkyColor(view.d, SUN_DIRECTION, skyColor, skyColorOnly, ambientColor, IS_NIGHT, isNightTransition);\n        depht += res.t;\n    }\n    \n    if(res.bbId == UNDEFINED_BB_ID)\n    {\n        colorOut = hsv2rgb(rgb2hsv(skyColor)*vec3(1.,1.2,1.1));\n        colorOut = mix(colorOut, patternColor, patternOpacity);\n        return;\n    }\n    else computeShading(res, isNightTransition, ambientColor, colorOut);\n    \n    colorOut = mix(vec3(0.), colorOut, fresnelAngle);     // reflection mixing\n    colorOut = hsv2rgb(rgb2hsv(colorOut)*vec3(1.03,1.2,1.1));\n    colorOut = mix(skyColorOnly, colorOut, exp(-depht*.005)); // fog\n    \n    colorOut = mix(colorOut, patternColor, patternOpacity);\n    \n    float d = pos.x - GRID_MODE_POS_X;\n    d = min(pow(d*5., .2), 1.);\n    colorOut = mix(mix(colorOut, vec3(2.), GRID_MODE_POS_ENABLED), colorOut, d);\n}\n\nfloat charSdf(in vec2 uv, in vec2 sel)\n{\n    const float sz = 4., u = 1./16.;\n    return max((texture(iChannel3, uv + sel*u + u*.5).a - .5)*u, box(uv, u*.5));\n}\n\nfloat jfig2022textSdf(in vec2 uv, in float spcg)\n{\n    const float jfig2022TextSize = float(JFIG_2022_TEXT_SIZE);\n    float uvx = uv.x, wdth = jfig2022TextSize*.5*spcg;\n    uv.x += wdth - spcg*.5;\n    float idx = floor(uv.x/spcg + .5);\n    int idxInt = int(idx);\n    float d = charSdf(uv - vec2(idx*spcg, 0.), JFIG_2022_TEXT[idxInt]);\n    return max(d, abs(uvx) - wdth);\n}\n\nvec3 backgroundColor(in vec2 uv, in float aa, in float sz, in float t)\n{\n    const mat2 r = ROT(T/8.);\n    const mat2 r2 = ROT(-T/8.);\n    return mix(\n        vec3(BORDEAUX*mix(.9, 1.1, uv.y*10. + .5)),\n        BORDEAUX,\n        smoothstep(-aa, aa, abs(croissantSdf(REP((uv*r)*sz + t, 1.)*r2, 0., 0.))/sz - aa*.25)\n    );\n}\n\nfloat titleScreenSdf(in vec2 uv, in float aa, in float offset, in float sz1, in float ftsz,\n    in float spacing, in float anim)\n{\n    offset *= sz1;\n    spacing /= 16.;\n    uv *= sz1;\n    float dt = jfig2022textSdf(uv/ftsz, spacing)*ftsz;\n    float dc = croissantSdf(uv, offset, anim);\n    float d = max(dc, -dt + offset);\n    d = min(d, dt);\n    return smoothstep(-aa, aa, d/sz1);\n}\n\nbool timingSel(in float tStart, in float tEnd, in float tIn, inout float tOut)\n{\n    tOut = INV_MIX(tStart, tEnd, tIn);\n    return tIn < tEnd;\n}\n\nvoid computeSceneCameraAnim(inout float currT, in vec2 st, in float aa, in vec2 m, inout CameraSettings cam, \ninout float pixelationEnabled, inout float shutterPosOut, inout vec3 bgColorOut)\n{\n    cam.st = st;\n    cam.pos = vec3(0., 0., -5.);\n    cam.target = vec3(0.);\n    cam.fov = 1.;\n    cam.sz = 1.;\n    cam.rotAngle = 0.;\n    cam.rotAxis = vec3(0., 1., 0.);\n    \n    currT = mod(currT, 100.); // time loop\n    \n    bgColorOut = backgroundColor(st, aa, 50., currT*.5);\n    \n    float t0 = SM1(TIMING(currT,.1,2.));\n    INFINITE_BRIDGE_ENABLED = 0.;\n    GRID_MODE_ENABLED = 1.;\n    GRID_MODE_SIZE = 1./5.;\n    shutterPosOut = mix(.2*t0, .5*smoothstep(100., 96., currT), smoothstep(56., 58., currT));\n    \n    float sunDirection = -1.;\n    \n    float t;\n    if(timingSel(0., 2.5, currT, t))\n    {\n        cam.st.y += .75;\n    }\n    else if(timingSel(2.5, 7.5, currT, t))\n    {\n        cam.st.y += mix(.75, 0., SM1(t));\n        GRID_MODE_SIZE = 1./200.;\n        GRID_MODE_THICKNESS = .00001;\n        cam.pos = vec3(0., 0., -5.);\n        cam.target = vec3(1., mix(1., .65, ISM1(t)), -.7);\n        cam.fov = 7.;\n        cam.rotAngle = t*.5 + .15;\n    }\n    else if(timingSel(7.5, 10., currT, t))\n    {\n        GRID_MODE_SIZE = 1./400.;\n        GRID_MODE_THICKNESS = .00001;\n        cam.pos = vec3(2., 0., -5.);\n        cam.target = vec3(mix(0., .25, ISM1(t)), .45, -.7);\n        cam.fov = 10.;\n    }\n    else if(timingSel(10., 15., currT, t))\n    {\n        GRID_MODE_SIZE = 1./5.;\n        float id = step(0., st.x);\n        cam.st.x = REP(st.x, .5);\n        cam.pos = vec3(0., 0.1, 100.*(1. - id)) + vec3(.01, 100.*id, 0.);\n        cam.rotAngle = mix(currT, 0., id);\n        cam.fov = length(cam.pos*mix(.2, .25, id));\n        cam.st.y += sign(st.x)*.5*mix(1., -1., ISM1(t));\n    }\n    else if(timingSel(15., 18., currT, t))\n    {\n        GRID_MODE_POS_ENABLED = 1.;\n        GRID_MODE_POS_X = 1.53;\n        cam.pos = mix(vec3(2., 1., 0.), vec3(2., .25, 0.), ISM1(t));\n        cam.target = vec3(1.5, .5, 0.);\n        cam.fov = length(cam.pos*.2);\n        cam.rotAngle = 0.;\n        pixelationEnabled = max(t - .2, 0.);\n    }\n    else if(timingSel(18., 22., currT, t))\n    {\n        cam.pos = mix(vec3(0., .25, -7.), vec3(-3., 1.5, -4.), ISM1(t));\n        cam.target = vec3(1.75, .5, 0.);\n        cam.fov = 2.;\n        cam.rotAngle = 0.;\n        GRID_MODE_POS_ENABLED = 1.;\n        GRID_MODE_POS_X = 1.53;\n        pixelationEnabled = min(t + .05, 1.);\n    }\n    else if(timingSel(22., 24., currT, t))\n    {\n        cam.pos = mix(vec3(5., 0., -7.), vec3(7., 1.53, -7.), ISM1(t));\n        cam.target = vec3(1.5, .5, 0.);\n        cam.fov = 2.;\n        cam.rotAngle = 0.;\n        GRID_MODE_POS_ENABLED = 1.;\n        GRID_MODE_POS_X = mix(1.75, .5, t);\n        pixelationEnabled = 1.;\n    }\n    else if(timingSel(24., 26., currT, t))\n    {\n        cam.pos = mix(vec3(2., 7., 0.), vec3(2., 20., 0.), ISM1(t));\n        cam.target = vec3(0.5, 0., 0.);\n        cam.fov = 2.;\n        cam.rotAngle = 0.;\n        GRID_MODE_POS_ENABLED = 1.;\n        GRID_MODE_POS_X = mix(1.25, 0., t);\n        pixelationEnabled = 1.;\n    }\n    else if(timingSel(26., 30., currT, t))\n    {\n        cam.pos = vec3(0., 0., -3.);\n        cam.target = vec3(0., .25, 0.);\n        cam.fov = .75;\n        cam.rotAngle = ISM1(t)*T;\n        GRID_MODE_POS_ENABLED = 1.;\n        GRID_MODE_POS_X = mix(.5, 0., t);\n        pixelationEnabled = 1.;\n    }\n    else if(timingSel(30., 34., currT, t))\n    {\n        cam.pos = mix(vec3(-2., 0., -20.), vec3(-5., 8., -20.), ISM1(t));\n        cam.target = vec3(-t*.5, .25, 0.);\n        cam.fov = mix(9.5, .5, ENL(ISM1(t), .25));\n        cam.rotAngle = 0.;\n        GRID_MODE_POS_ENABLED = 1.;\n        GRID_MODE_POS_X = 0.;\n        INFINITE_BRIDGE_ENABLED = 1.;\n        pixelationEnabled = 1.;\n        GRID_MODE_POS_X = mix(0., -5., SM1(max(0., t - .25)));\n    }\n    else if(timingSel(34., 38., currT, t))\n    {\n        cam.pos = mix(vec3(0., 5., 1.), vec3(0., 1., 3.), t);\n        cam.target = mix(vec3(0., .25, 0.), vec3(-10., .25, 0.), ISM1(t));\n        cam.fov = 1.;\n        cam.rotAngle = 0.;\n        GRID_MODE_POS_ENABLED = 1.;\n        GRID_MODE_POS_X = -almostIdentity(t, .5, 0.)*8.;\n        INFINITE_BRIDGE_ENABLED = 1.;\n        pixelationEnabled = 1.;\n    }\n    else if(timingSel(38., 42., currT, t))\n    {\n        cam.pos = mix(vec3(-4., 2., 1.), vec3(-4., .25, 1.), ISM1(t));\n        cam.target = vec3(0., .25, 0.);\n        cam.rotAngle = 0.;\n        GRID_MODE_POS_ENABLED = 1.;\n        GRID_MODE_POS_X = -t*8.;\n        INFINITE_BRIDGE_ENABLED = 1.;\n        pixelationEnabled = 1.;\n    }\n    else if(timingSel(42., 46., currT, t))\n    {\n        cam.pos = vec3(0., .5, mix(2., 30., ISM1(t)));\n        cam.target = vec3(0., .25, 0.);\n        cam.rotAngle = .5*(1. - ISM1(t));\n        GRID_MODE_ENABLED = 0.;\n        INFINITE_BRIDGE_ENABLED = 1.;\n        sunDirection = mix(sunDirection, -.75, t);\n    }\n    else if(timingSel(46., 56., currT, t))\n    {\n        cam.pos = vec3(0., .5, -6.);\n        cam.target = vec3(0., .25, 0.);\n        cam.rotAngle = mix(-T*.4, T*.82, SM1(ENL(t, .75)));\n        cam.rotAxis = vec3(0.125, 1., 0.);\n        GRID_MODE_ENABLED = 0.;\n        INFINITE_BRIDGE_ENABLED = 1.;\n        sunDirection = mix(-.2, -2., t*1.7);\n    }\n    else\n    {\n        cam.pos = vec3(0., 7.*(m.y + .45), -4.5);\n        cam.rotAngle = -(m.x + .5)*T + currT*.1;\n        GRID_MODE_ENABLED = 0.;\n        INFINITE_BRIDGE_ENABLED = 1.;\n        sunDirection = currT*.2 + 4.;\n    }\n    \n    setSunDirection(sunDirection);\n    \n    timingSel(0., 5., currT, t);\n    bgColorOut = mix(\n        vec3(1),\n        bgColorOut,\n        titleScreenSdf(\n            cam.st - vec2(0., .75), aa, aa*2.,\n            1.75,\n            1.4 + t*.1,\n            1. + t,\n            .5 + .5*t\n        )\n    );\n}\n\nvoid getViewFromCameraSettings(in CameraSettings cam, inout Ray view)\n{\n    view.o = cam.pos;\n    view.d = normalize(vec3(cam.st*cam.sz, -cam.fov));\n    view.o = axisRot(cam.rotAxis, cam.rotAngle)*view.o;\n    view.d = lookAt(view.o, cam.target)*view.d;\n}\n\nvoid intersectWithTransitionPlane(in Ray view, inout float t)\n{\n    view.o.x -= GRID_MODE_POS_X;\n    view.d = view.d.zyx;\n    view.o = view.o.zyx;\n    Tpos tBoxRes = boxInfXIntersection(view, vec2(10., 10e-3), 0, false);\n    t = tBoxRes.min;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 st = (fragCoord.xy - iResolution.xy*.5)/iResolution.x;\n    float aa = 1./iResolution.x;\n    vec2 m = (iMouse.xy - iResolution.xy*.5)/iResolution.xy;\n    float t = iTime;\n\n#ifdef FAKE_30_FPS_LIMIT_ENABLED\n    t = DIV_F(t, 1./30.);\n#endif\n\n    CameraSettings camera;\n    vec3 bgColor;\n    float pixelationEnabled = 1., shutterPos = .5;\n    computeSceneCameraAnim(t, st, aa, m, camera, pixelationEnabled, shutterPos, bgColor);\n\n    if(abs(st.y) - shutterPos > 0.)\n    {\n        fragColor = vec4(0.);\n        return;\n    }\n\n    vec4 colorAlpha = vec4(0.);\n\n#ifdef AA_ENABLED\n    vec2 aa2 = 1./iResolution.xy;\n    vec2 cameraStBase = camera.st;\n    for(int i = 0; i < NB_AA_SAMPLE; i++)\n    {\n        camera.st = cameraStBase + randomVec2(vec2(iFrame + i)*10e-5)*aa2;\n#endif\n    \n        Ray view;\n        getViewFromCameraSettings(camera, view);\n\n        float tPlane = 10e9;\n        vec3 patternColor = vec3(0.);\n        float patternOpacity = 0.;\n        { // magical barrier at transition\n            intersectWithTransitionPlane(view, tPlane);\n            if(tPlane > 0. && GRID_MODE_POS_ENABLED > 0.)\n            {\n                vec3 p = GET_POS(view, tPlane);\n\n                float angle = t*.25;\n                mat2 r1 = ROT(angle);\n                mat2 r2 = ROT(-angle);\n                vec2 speed = vec2(.25, -.25)*t*0.;\n                vec2 pidPixel, stPixel, uvPixel, szPixel;\n                randomPixelate(\n                    p.yz*r1 - speed,\n                    vec2(.5), 2., 5,\n                    0., // /*t*10e-7 + */GRID_MODE_POS_X*10e-7\n                    pidPixel, stPixel, uvPixel, szPixel\n                );\n                stPixel += speed;\n                stPixel *= r2;\n                uvPixel *= r2;\n\n                uvPixel = uvPixel.yx;\n\n                float d1 = max(sdfMain1(vec3(p.x, stPixel)), -p.y - .35) - 0.05;\n                d1 = min(d1, p.y + .35);\n                const float smv = .2;\n                d1 = smoothstep(smv*2., -smv, d1);\n\n                float sz = szPixel.x*1.5*d1;\n                float aa = fwidth(tPlane);\n                float d2 = smoothstep(aa, -aa, abs(croissantSdf(uvPixel/sz, 0., 0.)*sz + aa*.5) - aa*.5);\n\n                patternOpacity = d2*pixelationEnabled;\n\n                patternColor = SpectrumPoly((d1 + .1)*.65)*5.;\n            }\n        }\n\n        vec3 color;\n        computeScene(view, t, patternOpacity, tPlane, bgColor, color, patternColor);\n\n\n    #ifdef DEBUG_PERFORMANCES_ENABLED\n        {\n            // color = mix(color, vec3(1.,0.,0.), STEP_OBSERVER > 20.);\n            const float targetItMax = 80.;\n            color = hsv2rgb(vec3(mix(.7, 0., clamp(STEP_OBSERVER/targetItMax, 0., 1.)), 1., 1.));\n        }\n    #endif\n\n    #ifdef SHOW_BOUNDING_BOXES_ENABLED\n        if(IS_RIGHT_HALF_SCREEN)\n        {\n            Result res = intersectBB(view);\n            color = hsv2rgb(vec3(float(res.bbId)/float(BRIDGE_DECO_CORONA_SDF_ID), 1., 1.));\n        }\n    #endif\n\n        float bloomLimit = VEC3_COMP_SUM(color);\n        colorAlpha += vec4(color, step(4., bloomLimit));\n        \n#ifdef AA_ENABLED\n    }\n    colorAlpha /= float(NB_AA_SAMPLE);\n#endif\n    \n    // poor motion blur\n    /*colorAlpha.rgb = mix(\n        colorAlpha.rgb,\n        min(texelFetch(iChannel0, ivec2(fragCoord.xy), 0).rgb, vec3(1.)),\n        min(.008/iTimeDelta, .99)\n    );*/\n    \n    fragColor = colorAlpha;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// --------- Settings\n#define GLOW_LEVEL 1\n\n// --------- Constants\n#define T 6.2831853\n\n// --------- Macro and utilitary functions\n#define ROT(a) (mat2(cos(a), sin(a), -sin(a), cos(a)))\n#define GET_POS(v,t) (v.o + v.d*t)\n#define IS_BETWEEN(a,b,c) (b < a && a < c)\n#define SRGB_2_LIN(c) (pow(c,vec3(2.2)))\n#define LIN_2_SRGB(c) (pow(c,vec3(1./2.2)))\n#define MIX_LIN(a,b,t) (LIN_2_SRGB(mix(SRGB_2_LIN(a),SRGB_2_LIN(b),t)))\n#define RBOX(p,s,r) (length(max(abs(p)-(s),0.))-(r))\n#define SS_QUAD(x) (x*x/(2.*x*x-2.*x+1.))\n#define REP(x,d) (mod(x,d)-d*.5)\n#define REP2(x,d) (mod(x,d))\n#define REP_ID(x,d) (floor(x/d))\n#define REP_ID_CYCLIC(x,d,n) (floor(mod(x, d*n)/d))\n#define DIV_F(a,d) floor((a)/(d))*(d)\n#define VEC3_COMP_SUM(v) (v.x+v.y+v.z)\n#define INV_MIX(s,e,v) (((v)-(s))/((e)-(s)))\n#define RAY3D(q,div,th) (abs(REP(q,div))-th*.5)\n#define MIN3(v) (min((v).x,min((v).y,(v).z)))\n#define MIN2(v) (min((v).x,(v).y))\n#define GRID_SDF(p,div,th,d) (MIN3(max(vec3(abs(d)),RAY3D(p,div,0.)))-th)\n#define RAND_FROM(rdf,lm,mx) (step(lm,floor(rdf*mx)))\n#define COS_ANIM(x) (cos(x)*.5+.5)\n#define POW5(x) ((x)*(x)*(x)*(x)*(x))\n#define CIRCLE(p,r) (length(p)-r)\n#define MOON(p) (max(CIRCLE(p,.25),-CIRCLE(p-vec2(0.,0.09),.24)))\n#define BORDEAUX SRGB_2_LIN(vec3(0.447,0.125,0.267))\n#define RAND(v) (fract(sin(dot((v).xy,vec2(12.9898,78.233)))*43758.585))\n#define IS_RIGHT_HALF_SCREEN ((gl_FragCoord.x - iResolution.x*.5)/iResolution.x > 0.)\n\n// From: https://iquilezles.org/articles/functions/\n#define SM1(x) (x*x*x/(3.*x*x - 3.*x + 1.))\n#define TIMING(t,tS,tE) (clamp(INV_MIX(tS,tE,t), 0., 1.))\n#define ENL(t,s) ((t - .5)*s + .5)\nfloat ISM1(in float x)\n{\n  float a = pow(x, 1./3.);\n  return a/(a + pow(1. - x, 1./3.));\n}\nfloat almostIdentity(in float x, in float m, in float n)\n{\n    if(x > m) return x;\n    float a = 2.*n - m, b = 2.*m - 3.*n, t = x/m;\n    return (a*t + b)*t*t + n;\n}\n\nfloat box(in vec3 p, in vec3 s) { p = abs(p) - s; return max(p.x, max(p.y, p.z)); }\nfloat box(in vec2 p, in float s) { p = abs(p) - s; return max(p.x, p.y); }\nfloat elong(in float x, in float l) { x = abs(x) - l; return x*step(0., x); }\n\nmat3 axisRot(in vec3 ax, in float a)\n{\n    ax = normalize(ax);\n    float s = sin(a), c = cos(a);\n    float oc = 1. - c;\n    return mat3(\n        oc*ax.xxz*ax.xyx + vec3(c, vec2(-ax.z, ax.y)*s),\n        oc*ax.xyy*ax.yyz + vec3(ax.z*s, c, -ax.x*s),\n        oc*ax.zyz*ax.xzz + vec3(-ax.y*s, ax.x*s, c)\n    );\n}\n\nmat3 lookAt(in vec3 cameraPos, in vec3 target)\n{\n    vec3 dir = normalize(target - cameraPos);\n    vec3 right = normalize(cross(vec3(0., 1., 0.), dir));\n    vec3 up = normalize(cross(dir, right));\n    return mat3(-right, up, -dir);\n}\n\nvec2 randomVec2(in vec2 seed)\n{\n    return vec2(cos(RAND(seed)), sin(RAND(seed.yx*vec2(13.41564, -5.8545) + 2.215)));\n}\n\n// generic 2D noise, from: https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec4 mod289(vec4 g){return g-floor(g*(1./289.))*289.;}vec4 permute(vec4 g){return mod289((g*34.+1.)*g);}vec4 taylorInvSqrt(vec4 g){return 1.79284-.853735*g;}vec2 fade(vec2 g){return g*g*g*(g*(g*6.-15.)+10.);}float cnoise(vec2 g){vec4 v=floor(g.rgrg)+vec4(0.,0.,1.,1.),d=fract(g.rgrg)-vec4(0.,0.,1.,1.);v=mod289(v);vec4 r=v.rbrb,a=v.ggaa,p=d.rbrb,e=d.ggaa,c=permute(permute(r)+a),f=fract(c*(1./41.))*2.-1.,t=abs(f)-.5,b=floor(f+.5);f=f-b;vec2 m=vec2(f.r,t.r),o=vec2(f.g,t.g),l=vec2(f.b,t.b),u=vec2(f.a,t.a);vec4 n=taylorInvSqrt(vec4(dot(m,m),dot(l,l),dot(o,o),dot(u,u)));m*=n.r;l*=n.g;o*=n.b;u*=n.a;float i=dot(m,vec2(p.r,e.r)),x=dot(o,vec2(p.g,e.g)),s=dot(l,vec2(p.b,e.b)),S=dot(u,vec2(p.a,e.a));vec2 I=fade(d.rg),y=mix(vec2(i,s),vec2(x,S),I.r);float q=mix(y.r,y.g,I.g);return 2.3*q;}\n\n// by iq from: https://iquilezles.org/articles/distfunctions/\nfloat opSmoothUnion(in float d1, in float d2, in float k)\n{\n    float h = clamp(.5 + .5*(d2-d1)/k, 0., 1.);\n    return mix(d2, d1, h) - k*h*(1. - h);\n}\n\n// From: https://www.shadertoy.com/view/lsS3Wc\nvec3 hsv2rgb(in vec3 c)\n{\n    const vec4 k = vec4(1., 2./3., 1./3., 3.);\n    return c.z*mix(k.xxx, clamp(abs(fract(c.xxx + k.xyz)*6. - k.www) - k.xxx, 0., 1.), c.y);\n}\nvec3 rgb2hsv(in vec3 c)\n{\n    const float eps = 0.0000001;\n    vec4 k = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);\n    vec4 p = mix(vec4(c.zy, k.wz), vec4(c.yz, k.xy), (c.z<c.y) ? 1.0 : 0.0);\n    vec4 q = mix(vec4(p.xyw, c.x), vec4(c.x, p.yzx), (p.x<c.x) ? 1.0 : 0.0);\n    float d = q.x - min(q.w, q.y);\n    return vec3(abs(q.z + (q.w - q.y) / (6.0*d+eps)), d / (q.x+eps), q.x);\n}\n\n// Create a kind of \"recursive coordinates pixelation\"\nvoid randomPixelate(\n    in vec2 uv, in vec2 div, in float mult, in int nbIt, in float seed,\n    inout vec2 pid, inout vec2 p, inout vec2 uvOut, inout vec2 szOut\n)\n{\n    for(int i = 0; i < nbIt; i++)\n    {\n        pid = REP_ID(uv, div);\n        div /= floor(RAND(pid + seed)*mult + 1.);\n    }\n    \n    pid = REP_ID(uv, div);\n    uvOut = REP(uv, div);\n    szOut = div;\n    p = floor(uv/div)*div; // +.5\n}\n\n// From: https://www.shadertoy.com/view/wlSBzD\nvec3 SpectrumPoly(in float x)\n{\n    return (vec3(1.220023e0,-1.933277e0, 1.623776e0)+(vec3(-2.965000e1, 6.806567e1,-3.606269e1)+(vec3( 5.451365e2,-7.921759e2, 6.966892e2)+(vec3(-4.121053e3, 4.432167e3,-4.463157e3)+(vec3( 1.501655e4,-1.264621e4, 1.375260e4)+(vec3(-2.904744e4, 1.969591e4,-2.330431e4)+(vec3( 3.068214e4,-1.698411e4, 2.229810e4)+(vec3(-1.675434e4, 7.594470e3,-1.131826e4)+ vec3( 3.707437e3,-1.366175e3, 2.372779e3)*x)*x)*x)*x)*x)*x)*x)*x)*x;\n}\n\n\n// --------- Fx functions and var\n// https://www.rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/\nconst int BLUR_FILTER_SZ = 5;\nconst float GAUSSIAN_SUM = 4070.;\nconst float GAUSSIAN_KERNEL[BLUR_FILTER_SZ] = float[]\n(\n    924./GAUSSIAN_SUM,\n    792./GAUSSIAN_SUM,\n    495./GAUSSIAN_SUM,\n    220./GAUSSIAN_SUM,\n    66./GAUSSIAN_SUM\n);",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    ivec2 uv = ivec2(fragCoord.xy);\n    \n    vec3 colorGlow = vec3(0.);\n    for(int i = 0; i < BLUR_FILTER_SZ; i++)\n    {\n        vec4 c1 = texelFetch(iChannel0, ivec2(uv.x + i*GLOW_LEVEL, uv.y), 0);\n        vec4 c2 = texelFetch(iChannel0, ivec2(uv.x - i*GLOW_LEVEL, uv.y), 0);\n        colorGlow += c1.rgb*c1.a*GAUSSIAN_KERNEL[i];\n        colorGlow += c2.rgb*c2.a*GAUSSIAN_KERNEL[i];\n    }\n    \n    fragColor = vec4(colorGlow, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}