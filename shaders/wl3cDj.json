{
    "Shader": {
        "info": {
            "date": "1612401925",
            "description": "A minimalist grid based water simulation that accounts for the dispersion relation of surface gravity waves.\n",
            "flags": 48,
            "hasliked": 0,
            "id": "wl3cDj",
            "likes": 93,
            "name": " Water Surface Simulation",
            "published": 3,
            "tags": [
                "wave",
                "simulation",
                "water"
            ],
            "usePreview": 0,
            "username": "TinyTexel",
            "viewed": 3040
        },
        "renderpass": [
            {
                "code": "// author: Mirko Salm (https://twitter.com/Mirko_Salm)\n\n/*\n\nA minimalist grid based water simulation that accounts for the dispersion relation of surface gravity waves.\n\n\nMy main contributions here are: \n\n    - two dispersion kernels (13 tabs in 1 pass / 30 tabs in 2 passes) with which the vertical acceleration of deep water can be computed\n    - a blending scheme that locally morphs a deep water kernel into one that handles shallow water\n    - a high quality rendering approach based on an efficient C2 continuous bicubic reconstruction of the water height field\n\n\nAlgorithm overview:\n\n    Buffer A: water simulation (solves a simple second order partial differential equation using Verlet integration)\n    Buffer B: horizontal pass of the high quality dispersion kernel (the complementing vertical pass is part of Buffer A)\n    Buffer C: bicubic pre-filtering of the simulation result (computes smoothed partial derivatives + height field values at grid vertices)\n    Image   : rendering using the pre-filtered water height field stored in Buffer C\n\n\nControls:\n\n    left mouse (hold/click) - add water (hold shift key for individual droplets)\n    space key  (hold)       - flatten/dampen water surface\n\n    [1] - toggle terrain animation off/on\n    [2] - toggle grid windowing off/on (off leads to waves being reflected at the borders of the grid)\n    [3] - toggle mini map on/off (also shows if windowing is active)\n    [4] - toggle wave field rendering style in mini map between |gradient|² and height value\n    [5] - toggle rain drops off/on\n\n\n\n▬▬▬ 0.Motivation and previous work ▬▬▬\n▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬\n\nVolumetric fluid simulations can achieve impressive and interesting results both visually as well as gameplay-wise.\nHowever, in cases where we are only interested in a small subset of those possible results, a more minimalist approach might suffice.\nA typical case could be a scene where objects interacting with a body of water are supposed to cause believable disturbances to its surface. \nIf those disturbances are rather small than it can be reasonable to model them as deformations to a height field instead of to a volume.\n\nCompared to volumetric models height field based fluid simulations are usually less memory and performance intensive while being easier to implement and maintain.\nNaturally, this makes them an attractive choice in many cases.\n\nAs early as 1990 [1] described the idea of using a height field based water simulation in the context of computer graphics.\nWhere [1] proposed to use an implicit integration scheme to advance the simulation, [2] instead opted for a simple Verlet integrator; effectively trading stability for simplicity.\nAnother aspect in which [1] and [2] differed is that in an attempt to simulate deep instead of shallow water (as was done in [1]) [2] replaced the operator with \nwhich the vertical acceleration of the height field was computed. Source code of a practical implementation of that method can be found in [4].\nIn [5] the same author addressed the stability issue of the Verlet integrator by introducing an exponential solver.\n\nThe deep water operator introduced in [2] is rather computationally expensive as it is implemented via a non-separable 13x13 convolution kernel.\nAlso, no theoretical background on that operator is provided. Both of these concerns will be addressed here.\n\nBefore moving on it seems sensible to shortly motivate, from a phenomenological point of view, why we care about the difference of shallow and deep water.\nFor that purpose let us consider the idealized case of a single rain drop falling onto a perfectly flat water surface for which we ignore its surface tension. \nIn both cases circular wavefronts begin to emitt from the point where the drop hits the surface.\nIn the case of shallow water we can actually only observe a single wavefront while in deep water multiple wavefronts of different wavelengths \ntraveling at different velocities emerge. Replicating this dispersive behavior in deep water is one of the major challenges addressed here.\n\nIt is also important to note that for the type of waves considered here we are not interested in the absolute depth of the water but the wavelength-relative depth.\nTherefore, an absolute water depth that may be considered \"deep\", i.e. larger than 0.5*λ, for some wave with a wavelength λ of ~1m, could easily count as \"shallow\", \ni.e. smaller than 0.05*λ, for, let's say, a tsunami wavefront.\n\n\nabridged sources as a quick reference:\n\n[1] - \"Rapid, Stable Fluid Dynamics for Computer Graphics\"\n[2] - \"Interactive Water Surfaces\"\n[3] - \"Nonlocal diffusion and applications\"\n[4] - \"Simulating Ocean Water\"\n[5] - \"eWave: Using an Exponential Solver on the iWave Problem\"\n\n\n▬▬▬ 1.Basics and shallow water ▬▬▬\n▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬\n \nA straightforward way to simulate an interactable water surface is to numerically solve the wave equation on a deformed height field [1]. The wave equation reads as follows:\n( https://en.wikipedia.org/wiki/Wave_equation )\n\n ░░░░░░░░░░░░░░░░░░░░░░░░░░░\n ░                         ░\n   ∂²                      \n   ―― h(x,y) = c ∇²h(x,y),   (Equation 1.1)\n   ∂t²                     \n ░                         ░\n ░░░░░░░░░░░░░░░░░░░░░░░░░░░\n \nwhere\nt is time,\nh(x, y) is the water height at the coordiantes (x,y),\nc is a constant, and\n∇² is the spatial Laplace operator (sum of the second order partial derivatives, i.e. ∇²h(x, y) = ∂²h(x,y)/∂x² + ∂²h(x,y)/∂y²).\n\nThis equation tells us that the second derivative of the height field with respect to time (i.e. its vertical accelertion) is directly propotional to its Laplacian.\n\nIn [1] the authors show that the wave equation can indeed provide a reasonable approximation for shallow water if we set \n\n ░░░░░░░░░░░░\n ░          ░\n   c = g*D,   (Equation 1.2)\n ░          ░\n ░░░░░░░░░░░░\n \nwhere \ng is the acceleration due to gravity and \nD is the water depth (D>0).\n\nA minimalist implementation of a grid based simulation based on equation 1.1 can be broken down into two steps:\na. Compute the vertical acceleration of the height field using a discrete Laplace operator.\nb. Update the value of the height field based on its vertical acceleration.\n\n\n▬▬▬ Computing the Laplacian and the vertical acceleration ▬▬▬\n\nOn a regular grid the discrete Laplacian can be computed using one of the ubiquitous 3x3 Laplace kernels (see en.wikipedia.org/wiki/Discrete_Laplace_operator).\nUnfortunately, their quality is insufficient for our use case and does not result in a reasonable behaviour when plugged into the simulation.\nWe can, however, quite easily build kernels of good quality by windowing the infinite impulse response (IIR) filter we get from computing the Laplacian of the 2d sinc filter:\n\n ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n ░                                                                       ░\n                 ∂²             ∂²\n   ∇²sinc(x,y) = ―― sinc(x,y) + ―― sinc(x,y)                                // the continuous IIR filter\n                 ∂x²            ∂y²\n                 \n   wnd(x) = max(0, 1-x²)²                                                   // the windowing function (falls off to 0 at x = 1)\n   \n                 ∂²\n   _lapKern[x] = ―― sinc(x) * wnd(x/(radius+1))                             // the unnormalized discrete FIR kernel in 1d (x ∈ int && |x| <= radius)\n                 ∂x²                                                        // square brackets are used to denote that only integer arguments are allowed\n   \n   lapKern[x] = x!=0 ? _lapKern[x] : _lapKern[0] - sum_all_tabs(_lapKern)   // the re-normalized 1d kernel, i.e. sum_all_tabs(lapKern) == 0\n   \n   lapKern[x,y] = s*(lapKern[x] + lapKern[y])                               // the final 2d kernel; \n ░                                                                        ░ // s is a constant that scales lapKern's frequency response so as to better match that of ∇²sinc\n ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n\n\nAs we can see, the resulting 2d filter is the sum of two 1d filters that compute the second order partial derivatives in the x and y directions, respectively.\nAs a result the number of tabs scales linearly with the filter radius making it feasible to use filters with relatively wide footprints.\nHowever, a filter with radius=4 already produces good results:\n\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒  \n ▒                                                                              ▒\n   float lapKern[5] = float[5](3.14, -1.848826, 0.353877, -0.091300, 0.016249);   // the associated 2d filter has 18 tabs = (radius*2+1) + (radius*2+1)\n ▒                                                                              ▒\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒  \n \nNote that we work with a negated Laplacian kernel here, i.e. s < 0. The reasons for doing so is that it will later help to streamline the generalization of the operator.\nA consequence of negating the kernel is that we need to alter equation 1.2 slightly: \n\n ▒▒▒▒▒▒▒▒▒▒▒▒▒\n ▒           ▒\n   c = -g*D.   (equation 1.2b)\n ▒           ▒\n ▒▒▒▒▒▒▒▒▒▒▒▒▒\n \nWe can now compute the vertical acceleration A at a given grid vertex with coordinates (x,y) as\n\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n ▒                                                 ▒\n   A[x,y] = -g*D[x,y] * convolve(h[x,y], lapKern).   (equation 1.3)\n ▒                                                 ▒\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n\n\n▬▬▬ Updating the height field ▬▬▬\n\nGiven the vertical acceleration we can use a basic Verlet integrator to update our height field:\n( https://en.wikipedia.org/wiki/Verlet_integration#Verlet_integration_(without_velocities) )\n\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n ▒                                                 ▒\n   h₀[x,y] = (2*h₋₁[x,y] - h₋₂[x,y]) + A[x,y]*Δt²,   (equation 1.4)\n ▒                                                 ▒\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n\nwhere\nh₀  is the height field state after the current time step,\nh₋₁ is the previous height field state,\nh₋₂ is the height field state preceding h₋₁,\nA   is the vertical acceleration at the previous time step, and\nΔt  is the duration of the time step (assumed to be constant).\n\nThe derivation shown on Wikipedia uses finite differences. \nA different approach to derive equation 1.4 is to perform a quadratic extrapolation using h₋₁, A, and h₋₂ to determine the parameters of the curve:\n   \n ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ \n ░                                             ░\n   quadratic(t) = a + b*t + c*t²,\n   \n                    ∂² \n   quadratic''(t) = ―― quadratic(t) = 2c\n                    ∂t²\n                     \n   solve\n       h₋₁ = quadratic  (-1*Δt)\n       A   = quadratic''(-1*Δt)\n       h₋₂ = quadratic  (-2*Δt)\n   for a, b, and c.\n   \n   h₀ = quadratic(0) = (2*h₋₁ - h₋₂) + A*Δt² □ \n ░                                             ░\n ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n \nAt this point we have all we need to build a simple simulation for shallow water.\n\nThe approach outlined so far is very similar to the one described in [2].\nOne difference is that [2] adds a friction parameter α to the integration scheme resulting in the following expression:\n\n ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n ░                                                ░\n            1            \n   h₀ = ―――――――――― ((2 + α Δt)*h₋₁ - h₋₂ + A*Δt²).  (equation 1.5)\n         1 + α Δt\n ░                                                ░\n ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n\nThe addition of friction helps to smooth out some of the high frequency noise that the Laplacian kernel produces.\nA similarly, if not even more, effective approach in that regard is to apply a subtle exponential smoothing to the height field state buffer:\n( https://en.wikipedia.org/wiki/Exponential_smoothing )\n\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n ▒                           ▒\n   h₀'  = h₋₁*(1-w) + h₀ *w,   (equation 1.6)\n   h₋₁' = h₋₂*(1-w) + h₋₁*w,\n ▒                           ▒\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n \nwhere w = 1 - exp(-Δt*β) with β >= 0 being a damping constant.\n\nHowever, both approaches do not substantially improve the stability of the explicit integration scheme. \nEven just extending the integrator to support variable time steps can lead to the simulation becoming increasingly unstable over time.\nThese instabilities can manifest themselves for instance in the form of coherent wavefronts dispersing into multiple ones, additional wavefronts \nbeing spawned that travel in wrong directions, or, in the worst case, the whole simulation blowing up and corrupting the entire state buffer in a heartbeat.\nStable solvers for partial differential equations do of course exist (see [5] for one example specifically tailored to the problem at hand), \nbut they generally come at the cost of a lot of additional complexity.\n\n\nThe most substantial aspect in which the approach presented in [2] differs from the one described so far is the choice of the convolution kernel.\nThe reason for that is that [2] attempts to simulate deep instead of shallow water. In deep water the wavelength-to-speed relation is quite different. \nTo account for that [2] proposes to use a kernel that implements the half-Laplacian [3] instead of the common Laplacian.\nThe reasoning behind that choice is detailed in the following section.\n\n\n\n▬▬▬ 2.Intermediate depths and deep water ▬▬▬\n▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬\n\nThe velocity of water waves depends on a variety of factors like their wavelengths, gravity, surface tension, and water depth.\nFor waves that are large enough that the effects of surface tension are negligible, i.e. so called surface gravity waves, \nthis dependency can be described by the following dispersion relation\n( https://en.wikipedia.org/wiki/Dispersion_(water_waves) )\n\n ░░░░░░░░░░░░░░░░░░░░░░░\n ░                     ░\n   ω² = g*k*tanh(k*D),   (equation 2.1)\n ░                     ░\n ░░░░░░░░░░░░░░░░░░░░░░░\n\nwhere\nω is the angular velocity of the wave,\ng is the acceleration due to gravity,\nk is the wavenumber (k = 2π/λ; λ being the wavelength),\nD is the water depth (D>0), and\ntanh is the hyperbolic tangent (tanh(x) = 2/(1 + exp(-2x)) - 1), which is a sigmoid curve ranging from -1 to 1 on the interval (-inf, +inf).\n\nIn shallow water, i.e. when D < 0.05*λ, equation 2.1 reduces to\n\n ░░░░░░░░░░░░░░░░\n ░              ░\n   ω² ≈ g*D*k².   (equation 2.2)\n ░              ░\n ░░░░░░░░░░░░░░░░\n\nIn deep water, i.e. when D > 0.5*λ, we get\n\n ░░░░░░░░░░░░░░░\n ░             ░\n   ω² ≈ g*|k|.   (equation 2.3)\n ░             ░\n ░░░░░░░░░░░░░░░\n \n\nIn an effort to generalize the shallow water model from the previous chapter let us first consider how the dispersion relation \ncan be used to relate the vertical acceleration of an individual sine wave to its function value:\n\n        wave(x,t) =     s*sin(k*x - ω*t), (Equation 2.4a)\n \n     ∂²\n A = ―― wave(x,t) = -ω²*s*sin(k*x - ω*t), (equation 2.4b)\n     ∂t²\n \n              ░░░░░░░░░░░░░░░░░░░░░░\n              ░                    ░\n  it follows    A = -ω²*wave(x,t).        (equation 2.5)\n              ░                    ░\n              ░░░░░░░░░░░░░░░░░░░░░░\n \nwhere\ns is the amplitude,\nk is the wavenumber (k = 2π/λ),\nω is the angular velocity,\nt is time, and\nA is the vertical acceleration.\n\nLet us now consider the height field that represents our water surface as a superposition, i.e. a sum, of an arbitrary number of sine waves.\nFor the purpose of computing the vertical acceleration of that height field we simply apply equation 2.5 to each of those sine waves individually.\nProceeding in this manner is justified by linearity and can be formally expressed via the Fourier transform as\n( https://en.wikipedia.org/wiki/Fourier_transform )\n\n ░░░░░░░░░░░░░░░░░░░░\n ░                  ░\n   A = ℱ⁻¹(-ω²*ℱh),   (equation 2.6)\n ░                  ░\n ░░░░░░░░░░░░░░░░░░░░\n \nwhere\n ℱ⁻¹ is the inverse Fourier transform,\n ℱ   is the forward Fourier transform, and\n h   is the height field representing the water surface.\n\nWhile equation 2.6 may look complicated, its practical implications are actually rather tame.\nTo compute A in our shallow water model we use a convolution kernel that approximates a negative Laplacian (remember that we flipped the sign of the operator (see Equation 1.2b)).\nThe frequency response of the (negative) Laplacian is a radially symmetric, bi-variate paraboloid:\n\n ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n ░                                         ░\n   -∇²h(x,y) = ℱ⁻¹((kᵪ²+kᵧ²)*(ℱh)(kᵪ,kᵧ)).   (equation 2.7)\n ░                                         ░\n ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n \nIn the generalized model we simply replace this filter with one that has a frequency response that is equal to equation 2.1, i.e. the more general version of dispersion relation.\nIt is straightforward to show that inserting the shallow water dispersion relation, i.e. equation 2.2, into equation 2.6 gives us a result that is consistent with our work so far:\n \n A = ℱ⁻¹(-(g*D*k²)*ℱh) \n \n   = g*D*ℱ⁻¹(-k²*ℱh)  // g and D do not depend on the wavenumber so they can be moved out of the inverse Fourier transform\n            \n   = g*D*∇²h\n   \n   =-g*D*(-∇²)h. \n            \nDoing the same but with the deep water dispersion relation gives us:\n\n A = ℱ⁻¹(-(g*|k|)*ℱh) \n \n   = -g*ℱ⁻¹(|k|*ℱh) \n             ______   \n   = -g*ℱ⁻¹(√-(-k²)*ℱh) \n         ___\n   = -g*√-∇²h. \n                                                          ___\nThe square root of the Laplacian, or half-Laplacian [3], √-∇² does, at least for our purposes, nothing more than denote an operator that when applied to\na function convolves it with a linear filter that has a frequency response equal to |k| (in contrast to the frequency resonse of the negative Laplacian, which is k²).\n(The half-Laplacian is a special case of the fractional Laplacian [3], for which it is convention to defined it based on the negative Laplacian: (-∇²)ˢ with s ∈ (0,1).)\nThe frequency response of the half-Laplacian in 2d is a radially symmetric, bi-variate (upside down) cone:\n\n ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n ░  ___               _______              ░\n   √-∇²h(x,y) = ℱ⁻¹(√kᵪ²+kᵧ²*(ℱh)(kᵪ,kᵧ)).   (equation 2.8)\n ░                                         ░\n ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n \nLikewise, we can define the operator based on equation 2.1 as [3]\n\n ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n ░  ___      ___                  _______       _______                 ░\n   √-∇²tanh(√-∇²*D)h(x,y) = ℱ⁻¹(√kᵪ²+kᵧ²*tanh(√kᵪ²+kᵧ²*D)*(ℱh)(kᵪ,kᵧ)).   (equation 2.9)\n ░                                                                      ░\n ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n \nPutting it all together the ground-truth version of our generalized model computes the vertical acceleration of the height field as [4]\n\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n ▒           ___      ___          ▒\n   A = -g * √-∇²tanh(√-∇²*D)h(x,y)   (equation 2.10)\n ▒                                 ▒\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n \n \nWhat complicates implementing equation 2.10 is the dependency of the filter kernel on the water depth D.\nFor the shallow water model this dependency reduced to a vertical scaling by D.\nBut in the general case the way the shape of the kernel changes with D is less straightforward.\nBasically, the shape of the frequency response of the kernel at intermediate depths is a cone with a bulge instead of a sharp tip at its center.\nHow large this bulge is depends on D. For shallow water this bulge grows so large that it covers all relevant frequency ranges and can be approximated by a paraboloid scaled by D.\nFor deep water, on the other hand, it shrinks so much that we can simply omit it and assume the spectrum to be a perfect cone with a sharp apex.\n\n[4] proposes to pre-compute a whole array of filter kernels for different values of D and than interpolate between them at runtime based on the local water depth.\nHowever, no reasonably sized FIR filter kernel can faithfully reproduce the desired asymptotic frequency response for deep water, i.e. |k|.\nThe reason for that is that windowing the IIR filter blurs out its frequency response.\nThis effect is quite prominent around the DC, i.e. at k=0, where the spectrum has a C¹ discontinuity (the apex of the cone shape).\nAs a consequence a kernel of practical size typically resembles the ground-truth at D~1 more so than it does for the originally intended D->∞.\n\nAlternatively, we could implement equation 2.9 directly using fast Fourier transforms (FFTs). This would get us an accurate frequency response but at the cost of performance.\nOther downsides of this approach would be a substantial increase in implementation complexity and reduced flexibility.\nThis is because when using FFTs we would need to simulate the entire grid at each time step while using spatial FIR kernels allows us to selectively \ncompute A where it is required (after all, large parts of the grid might be masked out due to geomtry replacing the water in these regions).\n\nTherefore, we will stick to the spatial FIR filter based implementation approach here and simply accept that as a consequence we are not able to accurately handle D>1.\n\nIn an attempt to support variable water depths with minimal effort we simply interpolate between a shallow and a deep water kernel.\nThe shallow water kernel is already given by the discrete Laplacian filter described in section 1.\nIn order to complete the picture we still need a discrete FIR kernel for deep water and\na blending scheme that combines the two kernels in a way that results in a sensible approximation of equation 2.10.\n\n\n▬▬▬ Deep water dispersion kernels ▬▬▬\n\nSimilar to the shallow water kernel, the shape of the deep water kernel in frequency space is not particularly complex.\nHowever, the additional square root operation that turns the paraboloid into a cone does complicate the computation of the spatial kernel shape considerably [3].\nLuckily in our case the computation of the kernel is not performance critical so we can brute force the problem numerically by \npeforming an approximate inverse Fourier transform of the brick-wall filtered half-Laplacian to determine the tab weights of the discrete filter.\nThe resulting weights are windowed using max(0, 1-(x²+y²))², which is just a radially symmetric variant of the window we used in section 1.\nLastly the windowed kernel is renormalized and empricially scaled to match the ground-truth reference.\nAs discussed before no reasonably large FIR filter can actually approximate the half-Laplacian, i.e. asymptotic deep water kernel, well.\nTherefore we use the general model with D=1 as the reference that we try to match when scaling the kernel.\nBy not already using the general model with D=1 for the computation of the original tab weights we end up with a\ncompromise between the kernel we would ideally like to approximate and the one that we can actually still decently replicate in practice.\n\nComputing a 5x5 and a 15x15 kernel with this approach results in the following weights (one quadrant):\n\n ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n ░                                                                ░  \n   float hLapKern[9] = float[9]( 2.25    , -0.509315,  0.023306, \n                                -0.509315, -0.070842, -0.002754,    (kern5x5)\n                                 0.023306, -0.002754, -0.000141);\n ░                                                                ░  \n ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ \n        \n ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░      \n ░                                                                                                                         ░\n   float hLapKern[64] = float[64]( 2.32    , -0.472083,  0.050161, -0.030779,  0.009510, -0.005206,  0.001515, -0.000381, \n                                  -0.472083, -0.083063, -0.008956, -0.005801, -0.000604, -0.000797, -0.000027, -0.000047,  \n                                   0.050161, -0.008956, -0.006594, -0.002202, -0.001030, -0.000306, -0.000111, -0.000012, \n                                  -0.030779, -0.005801, -0.002202, -0.001290, -0.000496, -0.000210, -0.000049, -0.000004,    (kern15x15)\n                                   0.009511, -0.000604, -0.001030, -0.000496, -0.000259, -0.000084, -0.000018,  0.      , \n                                  -0.005206, -0.000797, -0.000306, -0.000210, -0.000084, -0.000025, -0.000001,  0.      , \n                                   0.001515, -0.000027, -0.000111, -0.000049, -0.000018, -0.000001,  0.      ,  0.      , \n                                  -0.000381, -0.000047, -0.000012, -0.000004,  0.      ,  0.      ,  0.      ,  0.      );        \n ░                                                                                                                         ░\n ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n\n\nWhen comparing the simulation behaviors resulting from these two kernels it becomes clear that kern5x5 provides only a poor approximation of kern15x15.\nAnd that while, judging from its frequency response, even Kernel15x15 itself is only a decent approximation for D=1. \nThe two takeaways here are that on the one hand using a compact kernel we can not expect to get much more out of it than a rough scetch of the wave behavior in deep water.\nAnd on the other hand, if we do aim to achieve even just a decent approximation of the ground-truth behavior at reasonable \ncomputational costs we need a more efficient way to compute the half-Laplacian.\n\n\n--- Compact deep water kernels ---\n\nConsidering our modest expectations regarding the simulation quality achieveable by small kernels like kern5x5 \nit seems worth exploring how far further we can reduce the number of used filter tabs without sacrificing even more quality.\n\nThe two important optimization criteria we need to balance here are the isotropy of the spectral response and \nits shape in the upper frequency range (the lower range is a lost case for small kernels anyway).\nThe construction approach outlined in the following attempts to streamline this balancing act.\n\nFirst, we construct a high-pass filter kernel with optimized radial symmetry in frequency space (by optimizing the tab weights explicitly via least squares). \nIts frequency response will be naturally bell curve shaped (since FIR filters tend towards a shoulder/toe when approaching Nyquist).\nWe then blend this kernel with a discrete Laplacian, which has a paraboloid shaped frequency response, to match the reference spectrum as well as possible.\nSince both kernels individually already feature decently isotropic spectra any kernel resulting from a weighted sum of the two does as well.\n\nA possible result using a 13 taps kernel with a diamond shaped footprint has the following weights (one quadrant; including 0-weights):\n\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n ▒                                                                ▒\n   float hLapKern[9] = float[9]( 2.093378, -0.329871, -0.026409,\n                                -0.329871, -0.167064,  0.      ,    (kern13)\n                                -0.026409,  0.      ,  0.      ); \n ▒                                                                ▒\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n \nThe choice to use a diamond shaped footprint is motivated by the fact that by using a 3x3 footprint we can already construct a reasonably isotropic spectrum \nfor the high-pass kernel while the quality of the blended in Laplace kernel benefits from a slightly larger radius. \nAdding another 8 tabs in the main directions so an even wider Laplace kernel can be used results in the following 21 tabs kernel (one quadrant; including 0-weights):   \n\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n ▒                                                                                      ▒\n   float hLapKern[25] = float[25]( 2.269921, -0.450589, 0.017898, -0.010277, 0.003477, \n                                  -0.450589, -0.127990, 0.      ,  0.      , 0.      , \n                                   0.017898,  0.      , 0.      ,  0.      , 0.      ,    (kern21)\n                                  -0.010277,  0.      , 0.      ,  0.      , 0.      , \n                                   0.003477,  0.      , 0.      ,  0.      , 0.      );     \n ▒                                                                                      ▒\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n\nThe difference in quality between kern13 and kern21 becomes only really noticeable once we end up dynamically \nfading out the high-pass kernel contribution in shallow water (see the \"Blending shallow and deep water kernels\" section).\n\n\n--- A high quality deep water kernel ---\n\nThe idea of blending multiple kernels together can also be used to construct a (comparatively) high quality half-Laplacian kernel with a wider footprint.\nWe achieve this by replacing the single compact high-pass kernel used previously with two larger separable kernels.\nHaving, in addition to the discrete Laplacian, two instead of just one high-pass filtering results available gives us \nanother degree of freedom for optimizing the spectral response of the filter.\nThe disantvantage of this approach over the compact kernels described previously is that in order to be efficient we need to perform the convolution in two passes.\nDoing so increases implementation complexity as well as causing a not insignificant performance overhead due to the necessary round trip through global memory.\nThe following kernels and pseudo code demonstrate a possible implementation of this idea:\n\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n ▒                                                                                                                                               ▒\n   float lowKern3[4] = float[4](5.0/16.0, 15.0/64.0, 3.0/32.0, 1.0/64.0);   \n    \n   float lowKern7[8] = float[8](429.0/2048.0, 3003.0/16384.0, 1001.0/8192.0, 1001.0/16384.0, 91.0/4096.0, 91.0/16384.0, 7.0/8192.0, 1.0/16384.0);   \n    \n   float lapKern7[8] = float[8](3.22, -1.933599, 0.438458, -0.163745, 0.070153, -0.02964, 0.01061, -0.002237);   \n ▒                                                                                                                                               ▒\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n ▒                                                           ▒\n   h' = (convolveX(h₋₁, lowKern3), \n         convolveX(h₋₁, lowKern7), \n                   h₋₁           , \n         convolveX(h₋₁, lapKern7))\n   \n   lowpass3  = convolveY(h'.x, lowKern3)\n   lowpass7  = convolveY(h'.y, lowKern7)\n   laplacian = convolveY(h'.z, lapKern7) + h'.w\n   \n   highpass = h'.z - lerp(lowpass3, lowpass7 , 0.772)\n   halfLaplacian =   lerp(highpass, laplacian, 0.190)*1.255;    (kernHQ)\n   \n   A = -g * halfLaplacian\n ▒                                                           ▒\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒  \n\n(An isolated implementation of this pseudo code can be found here: https://www.shadertoy.com/view/wtGyzK (also shows a plot of the spectral response of the kernel).)\n\nThe resulting kernel kernHQ is a reasonable approximation for the ground-truth kernel at D=2. \nThis means that we, in addition to performance, also improved the quality of the simulation when compared to the results achieved with kern15x15.\n\nLooking at the simulation results we can see that, in comparison to the compact kernels, the high quality kernel produces a less stiff wave propagation behavior   \ndue to the increased relative speed of the lower frequency waves. That behavior can, however, become somewhat less apparent the more chaotic the wave field becomes.\n\n(Side note: the deep water kernel proposed in [2] is the half-Laplacian of a Gaussian (which is not explicitly stated in the article). \nI managed to derive the analytical form from the numerical one presented there, but failed (in multiple attempts) to achieve useful results using that kernel. \nUsing the half-Laplacian of a Gaussian instead of a sinc function leads to incorrect dispersion behavior in the high ends. \nFor example, in the case of a water drop hitting a flat surface this leads to high frequency oscillations being emitted from the point of impact for a long time.\nI suspect that the author might have compensated this erroneous behavior by additionally damping the integration.)\n\n\n▬▬▬ Blending shallow and deep water dispersion kernels ▬▬▬\n\nWith a shallow and a deep water kernel at hand we can now dynamically blend between the two in an attempt to approximate the wave propagation behavior at intermediate depths.\nThe reference operator we try to match is the one based on the intermediate depth dispersion relation for surface gravity waves (equations 2.1 and 2.10):\n\n shallow (D < 0.05*λ)               intermediate                   deep (D > 0.5*λ)\n ░░░░░░░░░░░░░░░░░░░░░     ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒      ░░░░░░░░░░░░░░░░░░░░░\n ░                   ░     ▒           ___      ___      ▒      ░             ___   ░\n   A = -g * D*(-∇²)h  🠈🠊   A = -g * √-∇²tanh(√-∇²*D)h    🠈🠊    A = -g * (√-∇²)h \n ░                   ░     ▒                             ▒      ░                   ░\n ░░░░░░░░░░░░░░░░░░░░░     ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒      ░░░░░░░░░░░░░░░░░░░░░\n \nFor now let us assume that if D>1 using the deep water kernel without further modifications is already optimal. This means we concern ourselfs only with the interval D ∈ [0,1].\nUnder this assumption a reasonable choice for a straightforward blending approach is:\n\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n ▒                                            ▒\n   kern = (shallowKern*(1-w) + deepKern*w)*D,   (equation 2.11)\n ▒                                            ▒\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n \nwith w = ξ(D), where ξ(D) is a transfer function that optimizes the blending behaviour.\n\nA good approximation to a possible least-squares optimization result for this transfer function is\n\n ░░░░░░░░░░░░░░░░░░░░\n ░                  ░\n            13 D²\n   ξ(D) = ――――――――.   (equation 2.12)\n          4 + 9 D²\n ░                  ░\n ░░░░░░░░░░░░░░░░░░░░\n \nThe way the kernel stops morphing as D approaches 1 can be a bit abrupt, though.       \nTo mitigate this we can slightly dampen the blending behavior by adapting the coefficients as follows\n\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n ▒                  ▒\n            7 D²\n   ξ(D) = ――――――――.   (equation 2.13)\n          2 + 5 D²\n ▒                  ▒\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n \nIf we chose to use the high quality deep water kernel we need account for the fact that kernHQ approximates D=2 instead of D=1 (as was our initial assumption here).\nIt is however relatively straightforward to do so by only slightly modifying how the highpass filtering contribution is computed:\n \n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n ▒                                                       ▒\n   highpass = h'.z - lerp(lowpass3, lowpass7, 0.772*D2),\n ▒                                                       ▒\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n \nwhere D2 = min(max(0, D-1), 1) (i.e. we linearly blend in the lowpass7 contribution as D approaches 2 after passing 1).\n\nAn animated spectrum plot of the resulting kernel can be found here: https://www.shadertoy.com/view/WtcfzN (also allows to plot kern13).\n\nOne complication with equation 2.11 is that scaling the vertical acceleration by D leads to erroneous simulation \nbehavior along shorelines (shorelines emitting high frequency waves) if the features of the obstacle height map are not aligned with the main axes of the grid. \nOversampling the [0,1]-clamped D value does help, but not substantially.\nOversampling the whole simulation step using high quality reconstructions when sampling both the water state buffer as well as the obstacle height field would likely\nresolve the issue, but is impractical in many cases. An easy and effective way to mitigate the problem is to linearly remap D so it does not completely fall off to 0:\n\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n ▒                   ▒\n   D' = D*(1-σ) + σ,   (equation 2.14)\n ▒                   ▒\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒ \n \nwhere σ is a remapping constant.\n \nDoing so sacrifices simulation accuracy while still retaining the non-linear character of the overall behavior.\n\n\n▬▬▬ 3.Rendering ▬▬▬\n▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬\n\nThere are two primary issues we face when it comes to rendering the water surface. First our height field likely contains a significant amount of \nhigh frequency noise caused by the contributions of the Laplacian kernels (even by those baked into the deep water kernels).\nAnd second, we need an efficient way to compute high quality normals since the shading of water is typically characterized by specular reflections\nof which the quality is quite susceptible to C2 discontinuities and, especially inconvenient for us, to high frequency noise.\n\nFortunately both of those concerns can be accounted for by performing a C2 continuous bicubic reconstruction using an aggressive filter during the pre-filtering pass.\nA demo of the technique can be found here: www.shadertoy.com/view/WtsBDH (\"Bicubic C2 cont. Interpolation\").\nAnd the derivation is documented here:     www.shadertoy.com/view/3tfBzX (\"Cubic Reconstruction\").\n\nWhat this approach boils down to is that in a pre-filtering pass we reconstruct the height field exactly at its vertices using a C2 continuous bicubic filter kernel\nto evaluate the function value plus a number of partial derivatives of the filter-associated continuous height field.\nBy storing the filtered derivatives alongside the filtered value we are able to efficiently evaluate the continuous height field\nusing only the data stored at the vertices of the local 2x2 neighborhood of any given evaluation point.\nDifferent to the demo linked above we don't use the interpolating kernel here but a generalization of the bicubic B-spline that uses \nadditional side lobes (resulting in a 5x5 kernel). We set the side lobes weight so that the frequency response of the filter falls off to 0 at the Nyquist frequency.\nThis filters out virtually all of the noisy frequency content and does so in a highly radially symmetric fashion.\n\n\n▬▬▬ 4.Conclusion ▬▬▬\n▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬\n\nImplementing a height field based water simulation is comparatively straightforward. \nHowever, the choice of the dispersion kernel used to compute the vertical acceleration of the height field can be surprisingly nuanced.\nHere we proposed a number of shallow and deep water dispersion kernels that offer different performance-quality tradeoffs.\nIn addition, we presented a novel approach that locally performs a water depth dependent blending between a given shallow and a deep water kernel.\nFinally, we showed how the rendering of the resulting height field can benefit from using a C2 continuous reconstruction and how to implemented it efficiently.\n\nAn interesting extention to the algorithm at hand would be a phase shift filter that computes the horizontal offsets necessary for turning the sinusoidal wave field\ninto one that is composed of Gerstner waves. [4] shows how to do just that using FFTs. However, an implementation based on spatial FIR filters might be more practical.\n\n\n▬▬▬ Sources ▬▬▬\n▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬\n \n[1] - Kass, Michael, and Gavin Miller. \"Rapid, stable fluid dynamics for computer graphics.\" \n      Proceedings of the 17th annual conference on Computer graphics and interactive techniques. 1990.\n      pdf: https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.89.1204&rep=rep1&type=pdf\n\n[2] - Jerry Tessendorf, “Interactive Water Surfaces,” \n      Game Programming Gems 4 , ed. Andrew Kirmse, Charles River Media, (2004).\n      pdf: http://people.clemson.edu/~jtessen/papers_files/Interactive_Water_Surfaces.pdf\n      \n[3] - Bucur, Claudia, and Enrico Valdinoci. \"Nonlocal diffusion and applications.\" \n      Vol. 20. Cham: Springer, 2016.\n      pdf: https://www.researchgate.net/publication/275669247_Nonlocal_Diffusion_and_Applications\n\n[4] - Tessendorf, Jerry. \"Simulating ocean water.\" \n      Simulating nature: realistic and interactive techniques. SIGGRAPH 1.2 (2001): 5.\n      pdf: https://www.researchgate.net/publication/264839743_Simulating_Ocean_Water\n      \n[5] - Tessendorf, Jerry. \"eWave: Using an Exponential Solver on the iWave Problem.\" \n      Technical Note (2014).      \n      pdf: https://people.cs.clemson.edu/~jtessen/reports/papers_files/ewavealgorithm.pdf\n      \n      \n      \nRelated:\n\n  Simulation\n- https://www.shadertoy.com/view/wtGyzK | \"half-Laplacian\"                     (plot of the half-Laplacian kernel)\n- https://www.shadertoy.com/view/WtcfzN | \"Gravity Waves Dispersion Kernel\"    (plot of the frequency response of the depth dependent dispersion kernel)\n\n  Rendering\n- https://www.shadertoy.com/view/3tfBzX | \"Cubic Reconstruction\"               (derivation of the bicubic reconstruction scheme)\n- https://www.shadertoy.com/view/wlsBz2 | \"C2-interpolating cubic Kernel\"      (plot + background info on the kernel used to compute the derivatives)\n\n*/\n\n\n\n\n\n// CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n// To the extent possible under law, Mirko Salm has waived all copyrights and related or neighboring rights to this work.\n\n// CUBIC AND BICUBIC RECONSTRUCTION KERNELS ============================================================================================\n\nfloat kern_v(float x) { return 1.0-x*x*(3.0-2.0*abs(x)); }\nfloat kern_d(float x) { float o = abs(x)-1.0; return x*(o*o); }\n\nfloat kern_vD1(float x) { return x*(abs(x)*6.0-6.0); }\nfloat kern_dD1(float x) { return (abs(x)-1.0)*(abs(x)*3.0-1.0); }\n\nfloat kern_vD2(float x) { return abs(x) * 12.0 - 6.0; }\nfloat kern_dD2(float x) { return x * 6.0 + (x > 0.0 ? -4.0 : 4.0); }\n\n\nvec4 kern(vec2 p)\n{\n    return vec4(kern_d(p.x) * kern_v(p.y),\n                kern_v(p.x) * kern_d(p.y),\n                kern_d(p.x) * kern_d(p.y),\n                kern_v(p.x) * kern_v(p.y));\n}\n\nmat4 kern4x4(vec2 p)\n{\n    vec2 v   = vec2(kern_v  (p.x), kern_v  (p.y));\n    vec2 d   = vec2(kern_d  (p.x), kern_d  (p.y));\n    \n    vec2 vD1 = vec2(kern_vD1(p.x), kern_vD1(p.y));\n    vec2 dD1 = vec2(kern_dD1(p.x), kern_dD1(p.y));\n    \n    mat4 m = mat4\n    (\n        /*   kernDx       |  kernDy       |  kernDxy        |  kern    */\n        vec4(dD1.x * v.y  ,  d.x * vD1.y  ,  dD1.x * vD1.y  ,  d.x * v.y),\n        vec4(vD1.x * d.y  ,  v.x * dD1.y  ,  vD1.x * dD1.y  ,  v.x * d.y),\n        vec4(dD1.x * d.y  ,  d.x * dD1.y  ,  dD1.x * dD1.y  ,  d.x * d.y),\n        vec4(vD1.x * v.y  ,  v.x * vD1.y  ,  vD1.x * vD1.y  ,  v.x * v.y)\n    );\n    \n    return m;\n}\n\nvoid kern4x4(vec2 p, out mat4 mA, out mat4 mB)\n{\n    vec2 v   = vec2(kern_v  (p.x), kern_v  (p.y));\n    vec2 d   = vec2(kern_d  (p.x), kern_d  (p.y));\n    \n    vec2 vD1 = vec2(kern_vD1(p.x), kern_vD1(p.y));\n    vec2 dD1 = vec2(kern_dD1(p.x), kern_dD1(p.y));\n    \n    vec2 vD2 = vec2(kern_vD2(p.x), kern_vD2(p.y));\n    vec2 dD2 = vec2(kern_dD2(p.x), kern_dD2(p.y));\n    \n    mA = mat4\n    (\n        /*   kernDx       |  kernDy       |  kernDxy        |  kern    */\n        vec4(dD1.x * v.y  ,  d.x * vD1.y  ,  dD1.x * vD1.y  ,  d.x * v.y),\n        vec4(vD1.x * d.y  ,  v.x * dD1.y  ,  vD1.x * dD1.y  ,  v.x * d.y),\n        vec4(dD1.x * d.y  ,  d.x * dD1.y  ,  dD1.x * dD1.y  ,  d.x * d.y),\n        vec4(vD1.x * v.y  ,  v.x * vD1.y  ,  vD1.x * vD1.y  ,  v.x * v.y)\n    );\n\n    mB = mat4\n    (\n        /*   kernDxx      |  kernDyy      |  kernDxxy       |  kernDxyy    */\n        vec4(dD2.x * v.y  ,  d.x * vD2.y  ,  dD2.x * vD1.y  ,  dD1.x * vD2.y),\n        vec4(vD2.x * d.y  ,  v.x * dD2.y  ,  vD2.x * dD1.y  ,  vD1.x * dD2.y),\n        vec4(dD2.x * d.y  ,  d.x * dD2.y  ,  dD2.x * dD1.y  ,  dD1.x * dD2.y),\n        vec4(vD2.x * v.y  ,  v.x * vD2.y  ,  vD2.x * vD1.y  ,  vD1.x * vD2.y)\n    );\n}\n\n\n// BICUBIC SAMPLING ROUTINES =============================================================================================================\n\n// this is the most basic version which only evaluates the function value\nfloat SampleBicubic(sampler2D channel, vec2 uv)\n{\n    uv -= vec2(0.5);\n    \n    vec2 uvi = floor(uv);\n    vec2 uvf = uv - uvi;\n\n    ivec2 uv0 = ivec2(uvi);\n    \n    float r = 0.0;\n    for(int j = 0; j < 2; ++j)\n    for(int i = 0; i < 2; ++i)\n    {\n        vec4 c = texelFetch(channel, uv0 + ivec2(i, j), 0);\n        \n        vec2 l = uvf;\n        \n        if(i != 0) l.x -= 1.0;\n        if(j != 0) l.y -= 1.0;\n        \n        r += dot(c, kern(l));\n    }\n    \n\treturn r;\n}\n\n// ... this version also outputs derivatives (used here to compute normals)\nvec4 SampleBicubic2(sampler2D channel, vec2 uv)\n{\n    uv -= vec2(0.5);\n    \n    vec2 uvi = floor(uv);\n    vec2 uvf = uv - uvi;\n\n    ivec2 uv0 = ivec2(uvi);\n    \n    vec4 r = vec4(0.0);\n    for(int j = 0; j < 2; ++j)\n    for(int i = 0; i < 2; ++i)\n    {\n        vec4 c = texelFetch(channel, uv0 + ivec2(i, j), 0);\n        \n        vec2 l = uvf;\n        \n        if(i != 0) l.x -= 1.0;\n        if(j != 0) l.y -= 1.0;\n        \n        r += kern4x4(l) * c;\n    }\n    \n    // r = vec4(df/dx, df/dy, ddf/dxy, f)\n\treturn r;\n}\n\n// ... this version also outputs higher order derivatives (only used to debug C2 continuity here)\nvec4 SampleBicubic3(sampler2D channel, vec2 uv, out vec4 d2)\n{\n    uv -= vec2(0.5);\n    \n    vec2 uvi = floor(uv);\n    vec2 uvf = uv - uvi;\n\n    ivec2 uv0 = ivec2(uvi);\n    \n    d2 = vec4(0.0);\n    vec4 r = vec4(0.0);\n    for(int j = 0; j < 2; ++j)\n    for(int i = 0; i < 2; ++i)\n    {\n        vec4 c = texelFetch(channel, uv0 + ivec2(i, j), 0);\n        \n        vec2 l = uvf;\n        \n        if(i != 0) l.x -= 1.0;\n        if(j != 0) l.y -= 1.0;\n        \n        mat4 mA, mB;\n        kern4x4(l, /*out*/ mA, mB);\n        \n        r  += mA * c;\n        d2 += mB * c;\n    }\n    \n    // r  = vec4(  df/dx,   df/dy,  ddf/dxy ,         f)\n    // d2 = vec4(ddf/dxx, ddf/dyy, dddf/dxxy, dddf/dxyy)\n\treturn r;\n}\n\n\n// IMAGE ==========================================================================================================================\n\nfloat ReadKey(int keyCode) {return texelFetch(iChannel2, ivec2(keyCode, 0), 0).x;}\nfloat ReadKeyToggle(int keyCode) {return texelFetch(iChannel2, ivec2(keyCode, 2), 0).x;}\n\nvoid mainImage( out vec4 fragColor, in vec2 uv0 )\n{    \n    #if 0\n    fragColor = texelFetch(iChannel1, ivec2(uv0-0.5), 0);\n    return;\n    #endif\n\n    bool isTerrainAnimated = ReadKeyToggle(KEY_N1) == 0.0;\n\n   #if 1\n    // mini map\n    bool doShowWaveField = ReadKeyToggle(KEY_N3) != 0.0;\n   \n    if(doShowWaveField)\n    if(uv0.x < GridSize && uv0.y < GridSize)\n    {\n        vec3 col = vec3(1.0) - normalize(vec3(texelFetch(iChannel0, ivec2(uv0 - 0.5), 0).xy, .01)).z;\n        \n        float d = EvalTerrainHeight(uv0, isTerrainAnimated ? iTime : 0.0);\n        \n        bool doShowHeightField = ReadKeyToggle(KEY_N4) != 0.0;\n        if(doShowHeightField) col = (texelFetch(iChannel0, ivec2(uv0 - 0.5), 0).www * 1.0 + 0.5);\n        \n        col *= col;\n\n        float l = -min(d, 0.0)*3.;\n        col = mix(vec3(0.125, 0.125, 1.0 ), col, 1.0-(exp2(-(l*2.0 + l*l*1.0))));\n        col = mix(col, vec3(1.0  , 0.0  , 0.25), smoothstep(-0.05, 0.0, d));\n\n        bool isGridWindowSharp = ReadKeyToggle(KEY_N2) != 0.0;\n        if(isGridWindowSharp && (uv0.x == 0.5 || uv0.y == 0.5 || uv0.x == GridSize-0.5 || uv0.y == GridSize-0.5)) col = vec3(0.0, 1.0, 1.0); \n\n        fragColor = vec4(sqrt(clamp01(col.rgb)), 0.0);\n        return;\n    }\n   #endif\n \n    vec3 col;\n    \n    vec2 uv = uv0;\n    vec2 tc = uv0 / iResolution.xx;\n    \n   #if 0\n    if(uv0.x >= iResolution.x*0.5)\n    uv.x -= iResolution.x*0.5;\n   #endif\n    \n    col = vec3(texture(iChannel0, uv0/iResolution.xy*0.125).r);\n    \n    \n    vec2 uv2 = PatchUVfromScreenUV(uv0.xy, iResolution.xy);\n\n    float time = isTerrainAnimated ? iTime : 0.0;\n\n    vec3 V = vec3(0.0, 0.0, 1.0);\n    vec3 L = normalize(vec3(1.0, 1.0, 1.0));\n    vec3 L2 = normalize(vec3(-1.0, -1.0, 2.0));\n    vec3 H = normalize(L + V);\n\n\n    vec3 terrN;\n    {\n        float s = 1.0/128.0;\n        \n        float hx0 = EvalTerrainHeight(uv2 - vec2(s, 0.0), time);\n        float hx1 = EvalTerrainHeight(uv2 + vec2(s, 0.0), time);\n        float hy0 = EvalTerrainHeight(uv2 - vec2(0.0, s), time);\n        float hy1 = EvalTerrainHeight(uv2 + vec2(0.0, s), time);\n        \n        vec2 dxy = vec2(hx1 - hx0, hy1 - hy0) / (2.0 * s);\n        \n        terrN = normalize(vec3(-dxy, 0.03));\n    }\n    \n    vec3 terrCol = clamp01(dot(terrN, L))*(1.0/(1.0+1.0*(1.0-clamp01(dot(terrN, H)))))*vec3(1.0)*0.05;\n\n\n    vec4 d2;\n    vec4 h = SampleBicubic3(iChannel0, uv2, d2);// sample water surface\n    \n    float nscale = 32.0;\n    vec3 N = normalize(vec3(-h.xy * nscale, 1.0));\n    \n    vec3 R = 2.0*dot(V, N)*N - V;\n\n    float ct = clamp01(dot(N, L));\n    float ct2 = dot(N, L) * 0.5 + 0.5;\n    \n    float d = h.w - EvalTerrainHeight(uv2-N.xy*4.0, time);\n    \n    float waterMask = smoothstep(-0.01, 0.01, d);\n    \n    // diffuse\n    float v =  clamp01(ct2+0.15);\n    v = 1.0-v;\n    v = cubic(v);\n    \n    col = exp(-(v * 12.0 + 5.) * vec3(0.05, 0.3, 1.))*1.4;\n    //col *= mix(0.25, 1.0, clamp01(dot(terrN, L)+0.5));\n\n    float l = max(0.0, d);\n    col = mix(terrCol, col, (1.0-exp2(-(l*2.0 + l*l*1.0))));\n    col += vec3(0.0, 0.25, 1.0)*0.1;\n    \n    // specular\n    float c = 1.0 - (dot(R, L)*0.5+0.5);\n    float c2 = 1.0 - (dot(R, L2)*0.5+0.5);\n    float spec = 0.0;\n    spec += smoothstep(0.9, 0.99, dot(R, L))*0.5; \n    float spec0 = spec;\n    spec += smoothstep(0.7, 0.9, dot(R, L))*0.125; \n    spec += smoothstep(0.8, 0.9, dot(R, L2))*0.02; \n    spec += smoothstep(0.95, 0.99, N.z)*0.02; \n    spec += exp2(-32.0*(c))*0.25;\n    \n    col += vec3(1.0) * spec * waterMask;\n    \n    col = GammaEncode(clamp01(col));\n    \n    fragColor = vec4(col, 0.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n    #define USE_HQ_KERNEL\n     \n    // #define USE_AXISALIGNED_OBSTACLES\n\nconst float GridScale = 100.0;// vertex spacing; 1 -> meters | 100 -> centimeters \n\nconst float GridSize = 256.0;// vertex count per dimension\n\n\n\nfloat TrigNoise(vec3 x, float a, float b)\n{\n    vec4 u = vec4(dot(x, vec3( 1.0, 1.0, 1.0)), \n                  dot(x, vec3( 1.0,-1.0,-1.0)), \n                  dot(x, vec3(-1.0, 1.0,-1.0)),\n                  dot(x, vec3(-1.0,-1.0, 1.0))) * a;\n\n    return dot(sin(x     + cos(u.xyz) * b), \n               cos(x.zxy + sin(u.zwx) * b));\n}\n\nfloat TrigNoise(vec3 x)\n{\n    return TrigNoise(x, 2.0, 1.0);\n}  \n\n\n\nfloat EvalTerrainHeight(vec2 uv, float time)\n{\n    uv -= vec2(GridSize * 0.5);\n    \n  #ifdef USE_AXISALIGNED_OBSTACLES\n    return max(max((-uv.x-64.0), uv.y-64.0), min((uv.x-32.0), -uv.y-8.0)) * 0.02;\n  #endif\n    \n    float w = time * 0.125;\n    //w = 0.0;\n    \n    float terr = -(TrigNoise(vec3(uv * 0.01, w)) + 1.0) * 0.5;\n    \n    return terr;\n}\n\n\nvec2 PatchUVfromScreenUV(vec2 screenUV, vec2 screenResolution)\n{\n    return vec2(GridSize * 0.5) + (screenUV - screenResolution.xy*0.5)/screenResolution.xx * 226.0;\n}\n\n\n/*\n// x: [0, inf], s: (-1, 1] / (soft, hard]\nfloat SoftClip(float x, float s)\n{\n    return (1.0 + x - sqrt(1.0 - 2.0*s*x + x*x)) / (1.0 + s);\n}\n\nvec3 SoftClip(vec3 x, float s)\n{\n    return (1.0 + x - sqrt(1.0 - 2.0*s*x + x*x)) / (1.0 + s);\n}\n\n*/\n\n\n\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\n/* http://keycode.info/ */\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_CTRL 17\n#define KEY_SHIFT 16\n#define KEY_SPACE 32 \n#define KEY_A 0x41\n#define KEY_D 0x44\n#define KEY_S 0x53\n#define KEY_W 0x57\n\n#define KEY_N1 49\n#define KEY_N2 50\n#define KEY_N3 51\n#define KEY_N4 52\n#define KEY_N5 53\n#define KEY_N6 54\n#define KEY_N7 55\n#define KEY_N8 56\n\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\n\nvec3 AngToVec(vec2 ang)\n{\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    return vec3(cosPhi * cosTheta, \n                         sinTheta, \n                sinPhi * cosTheta); \n}\n\nfloat cubic(float x) {return x*x*(3.-2.*x);}\nvec2  cubic(vec2  x) {return x*x*(3.-2.*x);}\nvec3  cubic(vec3  x) {return x*x*(3.-2.*x);}\nvec4  cubic(vec4  x) {return x*x*(3.-2.*x);}\n\nfloat quintic(float x){ return ((x * 6.0 - 15.0) * x + 10.0) * x*x*x;}\nvec2  quintic(vec2  x){ return ((x * 6.0 - 15.0) * x + 10.0) * x*x*x;}\nvec3  quintic(vec3  x){ return ((x * 6.0 - 15.0) * x + 10.0) * x*x*x;}\nvec4  quintic(vec4  x){ return ((x * 6.0 - 15.0) * x + 10.0) * x*x*x;}\n\n\nuint  asuint2(float x) { return x == 0.0 ? 0u : floatBitsToUint(x); }\nuvec2 asuint2(vec2 x) { return uvec2(asuint2(x.x ), asuint2(x.y)); }\nuvec3 asuint2(vec3 x) { return uvec3(asuint2(x.xy), asuint2(x.z)); }\nuvec4 asuint2(vec4 x) { return uvec4(asuint2(x.xy), asuint2(x.zw)); }\n\nfloat Float01(uint x) { return float(    x ) * (1.0 / 4294967296.0); }\nfloat Float11(uint x) { return float(int(x)) * (1.0 / 2147483648.0); }\n\nvec2 Float01(uvec2 x) { return vec2(      x ) * (1.0 / 4294967296.0); }\nvec2 Float11(uvec2 x) { return vec2(ivec2(x)) * (1.0 / 2147483648.0); }\n\nvec3 Float01(uvec3 x) { return vec3(      x ) * (1.0 / 4294967296.0); }\nvec3 Float11(uvec3 x) { return vec3(ivec3(x)) * (1.0 / 2147483648.0); }\n\nvec4 Float01(uvec4 x) { return vec4(      x ) * (1.0 / 4294967296.0); }\nvec4 Float11(uvec4 x) { return vec4(ivec4(x)) * (1.0 / 2147483648.0); }\n\n// constants rounded to nearest primes\nconst uint rPhi1  = 2654435761u;\n\nconst uint rPhi2a = 3242174893u;\nconst uint rPhi2b = 2447445397u;\n\nconst uint rPhi3a = 3518319149u;\nconst uint rPhi3b = 2882110339u;\nconst uint rPhi3c = 2360945581u;\n\nconst uint rPhi4a = 3679390609u;\nconst uint rPhi4b = 3152041517u;\nconst uint rPhi4c = 2700274807u;\nconst uint rPhi4d = 2313257579u;\n\nconst uvec2 rPhi2 = uvec2(rPhi2a, rPhi2b);\nconst uvec3 rPhi3 = uvec3(rPhi3a, rPhi3b, rPhi3c);\nconst uvec4 rPhi4 = uvec4(rPhi4a, rPhi4b, rPhi4c, rPhi4d);\n\nuint  Roberts(uint  off, uint n) { return off + rPhi1 * n; }\nuvec2 Roberts(uvec2 off, uint n) { return off + rPhi2 * n; }\nuvec3 Roberts(uvec3 off, uint n) { return off + rPhi3 * n; }\nuvec4 Roberts(uvec4 off, uint n) { return off + rPhi4 * n; }\n\n// http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html\nuint WeylHash(uvec2 c) \n{\n    return ((c.x * 0x3504f333u) ^ (c.y * 0xf1bbcdcbu)) * 741103597u; \n}\n\n// low bias version https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash(uint x)\n{\n    x ^= x >> 16u;\n    x *= 0x7feb352dU;\n    x ^= x >> 15u;\n    x *= 0x846ca68bU;\n    x ^= x >> 16u;\n\n    return x;\n}\n\nuvec2 WellonsHash(uvec2 v) { return uvec2(WellonsHash(v.x), WellonsHash(v.y)); }\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/* Simulation */\n\nfloat ReadKey(int keyCode) {return texelFetch(iChannel1, ivec2(keyCode, 0), 0).x;}\nfloat ReadKeyToggle(int keyCode) {return texelFetch(iChannel1, ivec2(keyCode, 2), 0).x;}\n\n#define FETCH(uv) texelFetch(iChannel0, clamp(uv, ivec2(0), ivec2(GridSize-1.0)), 0).r\n#define FETCH2(uv) texelFetch(iChannel2, clamp(uv, ivec2(0), ivec2(GridSize-1.0)), 0).r\n#define FETCH3(uv) texelFetch(iChannel2, clamp(uv, ivec2(0), ivec2(GridSize-1.0)), 0)\n\nvoid mainImage( out vec4 col, in vec2 uv0 )\n{\n\n    // =================================================================================== //\n    // program state\n    bool isGrid = uv0.x < GridSize && uv0.y < GridSize;\n    bool isStateColumn = uv0.x == iResolution.x - 0.5;\n    \n    if(!isGrid && !isStateColumn) { discard; }\n\n    ivec2 uv = ivec2(uv0 - 0.5);\n    int stateColumnX = int(iResolution.x - 1.0);\n    \n    float iFrameTest     = texelFetch(iChannel0, ivec2(stateColumnX, 0), 0).x;\n    vec4  iMouseLast     = texelFetch(iChannel0, ivec2(stateColumnX, 1), 0);\n    float iTimeDeltaLast = texelFetch(iChannel0, ivec2(stateColumnX, 2), 0).x;\n\n    bool isInit = float(iFrame) == iFrameTest;\n    if( !isInit)\n    {\n        iTimeDeltaLast = iTimeDelta;\n    }\n    \n    if(isStateColumn)\n    {\n        if(uv.y == 0) col = vec4(float(iFrame) + 1.0, 0.0, 0.0, 0.0);\n        if(uv.y == 1) col = iMouse;\n        if(uv.y == 2) col = vec4(iTimeDelta, 0.0, 0.0, 0.0);\n        \n        return;\n    }\n    \n    if(!isGrid) return;\n    // =================================================================================== //\n\n    col = vec4(0.0);\n    \n    vec2 h12 = texelFetch(iChannel0, uv, 0).xy;\n\n    bool isTerrainAnimated = ReadKeyToggle(KEY_N1) == 0.0;\n    \n    float terrH = EvalTerrainHeight(uv0, isTerrainAnimated ? iTime : 0.0);\n    float mask = smoothstep(0.0, -0.05, terrH);\n    float D = clamp01(-terrH);\n    float lD2 = clamp01(-terrH-1.0);\n    \n   \n#ifdef USE_HQ_KERNEL\n\n    // 30 tabs version (vertical pass; horizontal pass in Buffer B)\n    float lowp3[4] = float[4](5.0/16.0, 15.0/64.0, 3.0/32.0, 1.0/64.0);   \n    float lowp7[8] = float[8](429.0/2048.0, 3003.0/16384.0, 1001.0/8192.0, 1001.0/16384.0, 91.0/4096.0, 91.0/16384.0, 7.0/8192.0, 1.0/16384.0);   \n    float lapl7[8] = float[8](3.22, -1.9335988099476562, 0.4384577800334821, -0.1637450351359609, 0.07015324480535713, -0.02963974593026339, 0.010609595665007715, -0.0022370294899667453);   \n\n    float lowpass3  = 0.0;\n    float lowpass7  = 0.0;\n    float laplacian = 0.0;\n    \n    for(int y = -7; y <= 7; ++y)\n    {\n        vec3 f = FETCH3(uv + ivec2(0, y)).xyz;\n    \n        int i = abs(y);\n\n        lowpass3  += f.x * (i < 4 ? lowp3[i] : 0.0);\n        lowpass7  += f.y * lowp7[i];\n        laplacian += f.z * lapl7[i];\n    }\n\n    vec4 f0 = FETCH3(uv);\n    \n    laplacian += f0.w;\n    \n    float highpass = f0.z - mix(lowpass3, lowpass7, 0.772 * lD2);\n    float halfLaplacian =   mix(highpass, laplacian, 0.19)*1.255;\n\n    float Aa = laplacian;\n    float Ab = halfLaplacian;\n   \n#else\n\n   #if 0\n    // 21 tabs version\n    const int r  = 4;\n    const int r1 = r + 1;\n\n    float kernA[r1] = float[r1](3.14, -1.8488262937460072, 0.3538769077873216, -0.0913000638886917, 0.016249449847377015);\n\n    float kernB[r1*r1] = float[r1*r1](2.269921105564736    , -0.4505893247500618, 0.01789846106075618, -0.01027660288590306, 0.0034772145111404747, \n                                     -0.4505893247500618   , -0.1279900243271159, 0.                 ,  0.                 , 0.                   , \n                                      0.01789846106075618  ,  0.                , 0.                 ,  0.                 , 0.                   , \n                                     -0.01027660288590306  ,  0.                , 0.                 ,  0.                 , 0.                   , \n                                      0.0034772145111404747,  0.                , 0.                 ,  0.                 , 0.                   );  \n   #else\n    // 13 tabs version\n    const int r  = 2;\n    const int r1 = r + 1;\n \n    float kernA[r1] = float[r1](2.85, -1.5792207792207793, 0.15422077922077923);\n \n    float kernB[r1*r1] = float[r1*r1](2.0933782605117255  , -0.32987120049780483, -0.026408964879028916, \n                                     -0.32987120049780483 , -0.1670643997510976 ,  0.0                 ,\n                                     -0.026408964879028916,  0.0                ,  0.0                 );\n   #endif\n     \n      \n    float Aa = 0.0;\n    float Ab = 0.0;\n\n    for(int y = -r; y <= r; ++y)\n    for(int x = -r; x <= r; ++x)\n    {\n        float w = (kernB[abs(x) + abs(y) * r1]);\n\n        if(w == 0.0) continue;\n\n        float f = FETCH(uv + ivec2(x, y));\n\n        Ab += f * w;\n\n        if(y == 0) Aa += f * kernA[abs(x)];                \n        if(x == 0) Aa += f * kernA[abs(y)];                \n    }     \n\n#endif\n\n  #ifndef USE_AXISALIGNED_OBSTACLES\n    // mitigate erroneous simulation behavior along shorelines\n    D = mix(0.25, 1.0, D);\n  #endif\n  \n    float A = mix(Aa, Ab, (D*D) / (2.0/7.0 + 5.0/7.0 * (D*D))) * D;\n    \n   // A = Ab;// deep\n   // A = Aa * 0.5;// shallow\n\n    A *= -9.81*GridScale;\n\n\n    // painting\n    bool isSingleDrop = ReadKey(KEY_SHIFT) != 0.0;\n    \n    if(iMouse.w > 0.0 || (!isSingleDrop && iMouse.z > 0.0 || (iMouse.x != iMouseLast.x && iMouse.y != iMouseLast.y)))\n    {\n        vec2 c = PatchUVfromScreenUV(iMouse.xy, iResolution.xy);\n        \n        vec2 vec = (uv0 - c);\n  \n        if(!isSingleDrop)\n        if(iMouseLast.z > 0.0 || iMouseLast.w > 0.0)\n        {\n            vec2 c2 = PatchUVfromScreenUV(iMouseLast.xy, iResolution.xy);\n            \n            vec = uv0 - (c2 + (c-c2)*clamp01(dot(c-c2, uv0-c2)/dot(c-c2,c-c2)));\n        }\n  \n        float v = exp2(-dot(vec, vec) * 1.0);\n        h12 = mix(h12, vec2(0.75), v);\n    }\n    \n    if(iFrame == 0) h12 = vec2(0.0);\n\n    // rain drops\n    if(ReadKeyToggle(KEY_N5) == 0.0)\n    if(WellonsHash(uint(iFrame)) < 100000000u)\n    {\n        vec2 c = Float01(WellonsHash(uint(iFrame) * uvec2(3242174893u, 2447445397u) + 3u)) * GridSize;\n        vec2 vec = (uv0 - c);\n    \n        float v = exp2(-dot(vec, vec) * 1.0);\n        h12 = mix(h12, vec2(0.75), v);\n    }\n\n    float dt = 0.016667;\n    float dt2 =  dt * dt;\n\n    float h0 = 0.0;\n    float h1 = h12.x;\n    float h2 = h12.y;\n\n#if 1\n    // Verlet integration\n    h0 = (2.0 * h1 - h2) + A * dt2;\n\n#else\n\n    // ...damped version\n    float a = 1.0/2.0;\n    float adt = a * dt;\n    \n    h0 = (((2.0 + adt) * h1 - h2) + A * dt2) / (1.0 + adt);\n\n#endif\n\n    vec2 h01 = vec2(h0, h1);\n\n    // exponential state buffer smoothing\n    float beta = 2.0;\n    h01 = mix(h01, h12, 1.0-exp2(-dt*beta));\n\n    // mask out obstacles\n    h01 *= mask;\n\n    // grid windowing\n    bool isGridWindowed = ReadKeyToggle(KEY_N2) == 0.0;\n    if(isGridWindowed)\n    {\n        float r = 32.0;\n\n        vec2 u = min((vec2(GridSize*0.5) - abs(uv0 - vec2(GridSize*0.5))) / r, vec2(1.0));\n\n        u = 1.0 - u;\n        u *= u;\n        u *= u;\n        u = 1.0 - u;\n\n        float s = u.x*u.y;\n\n        h01 *= mix(0.75, 1.0, s);        \n    }\n    \n    if(ReadKey(KEY_SPACE) != 0.0) { h01 *= 0.95; } \n    \n    col = vec4(h01, 0.0, 0.0);\n}\n\n\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/* horizontal pass of hq deep water kernel */\n\n#define FETCH(uv) texelFetch(iChannel0, clamp(uv, ivec2(0), ivec2(GridSize-1.0)), 0).r\n\nvoid mainImage(out vec4 col, in vec2 uv0)\n{\n  #ifndef USE_HQ_KERNEL\n    discard; return;\n  #endif\n  \n    bool isGrid = uv0.x < GridSize && uv0.y < GridSize;\n\n    if(!isGrid) return;\n\n    ivec2 uv = ivec2(uv0 - 0.5);\n    \n    float lowp3[4] = float[4](5.0/16.0, 15.0/64.0, 3.0/32.0, 1.0/64.0);   \n    float lowp7[8] = float[8](429.0/2048.0, 3003.0/16384.0, 1001.0/8192.0, 1001.0/16384.0, 91.0/4096.0, 91.0/16384.0, 7.0/8192.0, 1.0/16384.0);   \n    float lapl7[8] = float[8](3.22, -1.9335988099476562, 0.4384577800334821, -0.1637450351359609, 0.07015324480535713, -0.02963974593026339, 0.010609595665007715, -0.0022370294899667453);   \n\n    float lowpass3  = 0.0;\n    float lowpass7  = 0.0;\n    float laplacian = 0.0;\n    \n    for(int x = -7; x <= 7; ++x)\n    {\n        float f = FETCH(uv + ivec2(x, 0));\n    \n        int i = abs(x);\n\n        lowpass3  += f * (i < 4 ? lowp3[i] : 0.0);\n        lowpass7  += f * lowp7[i];\n        laplacian += f * lapl7[i];\n    }\n\n    float f0 = FETCH(uv);\n    \n    col = vec4(lowpass3, lowpass7, f0, laplacian);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\n    pre-filter pass (prepares height field for rendering)\n    https://www.shadertoy.com/view/WtsBDH (\"Bicubic C2 cont. Interpolation\")\n*/\n\n#define FETCH(uv) (texelFetch(iChannel0, uv, 0).r)\n\nvoid mainImage( out vec4 fragColor, in vec2 uv0 )\n{    \n    if(uv0.x > GridSize || uv0.y > GridSize) return;\n\n    ivec2 uv = ivec2(uv0 - 0.5);\n    \n    vec4 col = vec4(0.0);\n    \n    // ======================================================= GENERALIZED CUBIC BSPLINE =======================================================\n    \n    float kernD0[3];\n    float kernD1[3];\n    \n    kernD0[0] = 2.0/3.0; kernD0[1] = 1.0/6.0; kernD0[2] = 0.0;\n    kernD1[0] =     0.0; kernD1[1] =    -0.5; kernD1[2] = 0.0;\n    \n    float sw;// side lobes weight\n\n    sw = 0.0;// cubic BSpline\n    \n   #if 0\n   \n    sw = 0.25;// similar to 1/3 but less ringing\n    \n   #elif 0\n   \n    sw = 1.0/3.0;// kernD0[0] == 1\n    \n   #elif 0\n    \n    sw = 0.186605;// max abs derivative == 1\n    \n   #elif 0\n    \n    sw = 1.0/6.0;// maximaly flat pass band\n    \n   #elif 1\n    \n    sw = -0.25;// spectrum falls off to 0 at Nyquist frequency\n    \n   #endif\n    \n    // add a pair of side lobes:\n    kernD0[0] += 1.0 * sw; kernD0[1] += -1.0/3.0 * sw; kernD0[2] += -1.0/6.0 * sw;\n    \t                   kernD1[1] += -1.0     * sw; kernD1[2] +=  0.5     * sw;\n    \n    int r = sw == 0.0 ? 1 : 2;\n    for(int j = -r; j <= r; ++j)\n    for(int i = -r; i <= r; ++i)\n    {\n    \tfloat f = FETCH(uv + ivec2(i, j));\n        \n        int x = abs(i);\n        int y = abs(j);\n        \n        float kAx = kernD0[x];\n        float kAy = kernD0[y];\n        \n        float kBx = kernD1[x] * (i > 0 ? -1.0 : 1.0);\n        float kBy = kernD1[y] * (j > 0 ? -1.0 : 1.0);\n        \n        col += f * vec4(kBx * kAy, \n                        kAx * kBy, \n                        kBx * kBy,\n                        kAx * kAy);\n    }\n    \n    // col = vec4(df/dx, df/dy, d^2f/dxy, f)\n    fragColor = col;\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}