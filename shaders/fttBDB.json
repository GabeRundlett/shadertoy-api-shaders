{
    "Shader": {
        "info": {
            "date": "1664567157",
            "description": "The day Earth's DNA streams changed forever.",
            "flags": 96,
            "hasliked": 0,
            "id": "fttBDB",
            "likes": 44,
            "name": "Silent Assimilation",
            "published": 3,
            "tags": [
                "3d",
                "raymarch",
                "voxel",
                "mountains",
                "aliens",
                "silent",
                "assimilation"
            ],
            "usePreview": 0,
            "username": "Dave_Hoskins",
            "viewed": 800
        },
        "renderpass": [
            {
                "code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// By David Hoskins, 2022.\n\n\nvec3 cameraPos, cameraTar;\nvec3 camRay;\nfloat gTime;\nfloat fade;\n\n#define ANG2 1.33\n#define ANG3 1.4\n#define ZERO min(0, iFrame)\nconst mat2 rotMat = mat2(cos(ANG2), sin(ANG3), -sin(ANG3), cos(ANG2)) * 2.;\nconst vec3 MOON_DIR = normalize(vec3(-.5, .4, -.5));\nconst vec3 MOON_DIR2 = normalize(MOON_DIR + vec3(.02, -0.002, 0.0));\n\n#define MOUSE_SCRUB\n\n//----------------------------------------------------------------------------------------------------------\n// Thanks for palette, iq...\n// https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec3 getColour(float id)\n {\n    \n    return pal(id, vec3(0.25,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n\n}\n\n\nconst int   SEEDS = 50;\nconst float STEP_SIZE = 150.;\n#define SIZE .3\n\n//----------------------------------------------------------------------------------------------------------\nvec2 distanceRayPoint(vec3 ro, vec3 rd, vec3 p)\n{\n    p -= ro;\n    float h = dot(p,rd);\n    return vec2(length(p-rd*h), h);\n}\n\n//----------------------------------------------------------------------------------------------------------\nvec3 getOffset(in vec3 id, float si)\n{\n    return clamp(tri(id+gTime*.1), si*.25, (1.0-si*.25));\n}\n\n// Find a single seed at ground position.\n// Needs surrounding squares to prevent edge cutoff...\n\n//----------------------------------------------------------------------------------------------------------\nvec3 singleSeed(in vec3 ro)\n{\n    ro.y += gTime*250.0+3.; // A very subtle +3 increase for ground lights to arrive early!\n\n    vec3 p = ro / STEP_SIZE, sm3at = vec3(0);\n    float i = 0.0;\n    float sb = .1;\n    vec3 col = vec3(0);\n    \n    vec3 pos = floor(p);\n    for (int z = -1; z <= 1; z++)\n    {\n        for (int y = -1; y <= 1; y++)\n        {\n            for (int x = -1; x <= 1; x++)\n            {\n                vec3 p2     = pos;\n                p2         += vec3(x, y, z);\n                vec3 id     = hash33(p2*19.31);\n                float si    = (id.x+id.z)*.3+.04;\n                vec3 offset = getOffset(id, si);\n                vec3 mat    = getColour(id.x+id.y);\n                p2 += offset;\n                p2-= p;\n                i = dot(p2,p2);\n                if (i < si*.2)\n                {\n                    col += mat*smoothstep(si*.05, 0.0, i)*fade;\n                    i= max((i-si*.15),0.0)*4.;\n                     col += sin(smoothstep(si*.3,si*.1,i)*3.14)*.2*fade;//* smoothstep(si*.1,si*.15,i);//smoothstep(0.014, .013, i)*fade*.4;\n                }\n            }\n        }\n    }\n\n\n    return col;\n}\n\n//----------------------------------------------------------------------------------------------------------\n// Render all seeds...\n// This uses iq's 'Voxel Edges' renderer, it visits every voxel and adds a randomly positioned point,\n// producing a evenly distributed cloud of seeds.\n// I believe I was inspired by iapafoto, who does the same here:\n// https://www.shadertoy.com/view/Xl2BRR\nvec3 floatingSeeds(in vec3 ro, in vec3 rd, in float tmax)\n{ \n \n    vec2 d;\n    ro.y += 250.*gTime; // ...float down\n    \n    ro /= STEP_SIZE;\n\tvec3 pos = floor(ro),\n         ri = 1./rd,\n\t\t rs = sign(rd),\n\t\t dis = (pos-ro + 0.5 +rs*.5) * ri,\n         sum = vec3(0), col = sum;\n    \n\tfor( int i = 0; i < SEEDS; i++ )\n    {\n        vec3 id = hash33(pos*19.31);\n        float si = (id.x+id.z)*.3+.04;\n\n        vec3 offset = getOffset(id, si);\n\n        d = distanceRayPoint(ro, rd, pos+offset);\n        \n        float d2 = d.y * STEP_SIZE - tmax;\n\n        vec3 mat =  getColour(id.x+id.y);\n        \n        if (d2 < 0.0 && d.y > 0.0)\n        {\n            col = mat * pow(smoothstep(si, 0.0,d.x),80.)*15.;\n            col *= fade;\n            sum += col;\n        }\n        fade *= .92;\n        // step through voxel borders...\n\t\tvec3 mm = step(dis.xyz, dis.yzx) * step(dis.xyz, dis.zxy);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\n\t}\n  \n\treturn sum;\n}\n\n//----------------------------------------------------------------------------------------------------------\nfloat moon(vec3 dir)\n{\n    float d = clamp(pow(max(dot(MOON_DIR, camRay), 0.), 8000.0)*1., 0.0, .002)*1000.;\n    float d2 = pow(max(dot(MOON_DIR2, camRay), 0.), 4000.0)*30.;\n    return clamp(d-d2, 0.0, 1.);\n}\n\n\n//----------------------------------------------------------------------------------------------------------\nvec3 getSky(vec3 dir)\n{\n\tvec3 col = mix(vec3(FOG_COLOUR), vec3(0.01, 0.01,0.03),clamp((1.-exp(-dir.y))*3., 0.0, 1.));\n\n    col += moon(dir)* vec3(.35,.3,.2);\n    return col;\n}\n\n//----------------------------------------------------------------------------------------------------------\nvec3 noiseD(in vec2 x) \n{\n    vec2 f = fract(x);\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.*f*f*(f*(f-2.0)+1.);\n\n\tvec4 n = texelFetch(iChannel0, ivec2(floor(x)) & TWRAP, 0);\n\treturn vec3(n.x + n.y * u.x + n.z * u.y + n.w * u.x*u.y,\n\t\t\t\tdu * (n.yz + n.w*u.yx));\n}\n\n//----------------------------------------------------------------------------------------------------------\nfloat terrain( in vec2 p, float z)\n{\n   \n    float a = 0.0;\n    \n    p+= vec2(-260,300);\n    \n    vec2  d = vec2(0.0);\n    float h = length(p);\n\n    // Mountains and flats depending on distance from 0\n    float b = smoothstep(0.0, 2000.0, h)*500.0;\n    b*= (1.0+smoothstep(3000.0,6000.0,h)*.6);\n    \n    p = p*0.0005;\n    \n    // Decrease iteration detail with distance..\n    int iter = 13-int(log2(z*.05+2.0));\n    \n    iter = clamp(iter, 1, 12);\n    \n\tfor (int i = ZERO; i < iter; i++)\n\t{\n       vec3 n = noiseD(p);\n        \n        d += n.yz;\n        a += b*n.x/(.7+dot(d,d));\n\t\tb *= 0.51;\n        p = rotMat*p;\n        //p -= n.yz*.3;\n\t} \n\n\treturn a;\n}\n\n//-------------------------------------------------------------------------------------------------------\nfloat map(vec3 p, float z)\n{\n    return  p.y-terrain(p.xz, z);\n}\n\n//-------------------------------------------------------------------------------------------------------\n// March the whole scene...\n#define FAR 10000.\nfloat rayMarch(in vec3 rO, in vec3 rD, in float t)\n{\n\tfloat d;\n    float adj = .5;// Estimate error adjust starts very small\n\n    for(int j = ZERO; j < 200 && t < FAR; j++)\n\t{\n        d = map(rO + t*rD, t);\n        if (d < .01) break;\n        t += d * adj;\n        adj += .003;\n\t}\n \n\treturn t;\n}\n\n\n//----------------------------------------------------------------------------------------------------------\nvec3 getNormal(vec3 pos, float ds)\n{\n\n    float c = map(pos, 0.);\n    vec2 eps_zero = vec2(max(ds, .01), 0.0);\n    return normalize(vec3(map(pos + eps_zero.xyy, 0.0),\n                          map(pos + eps_zero.yxy, 0.0),\n                          map(pos + eps_zero.yyx, 0.0)) - c);\n}\n\n\n//----------------------------------------------------------------------------------------------------------\nvec3 getCamera(vec2 uv)\n{\n\n\tcameraPos = vec3(sin(gTime*.37)*300., 500.+sin(gTime)*250., cos(gTime*.83)*300.);\n\tcameraTar = cameraPos+vec3(sin(gTime*.5)*150.,sin(gTime*.33+3.3)*90.-7., cos(gTime*.5)*150.);\n\n    vec3 cw = normalize(cameraTar-cameraPos);\n\tvec3 cu = normalize(cross(cw,vec3(0,1,0)));\n\tvec3 cv = normalize(cross(cu,cw));\n    return normalize(uv.x*cu + uv.y*cv + cw * 1.);\n}\n\n\n//----------------------------------------------------------------------------------------------------------\nvec3 lighting(vec3 p, vec3 nor)\n{\n    float l = max(dot(MOON_DIR, nor), 0.0);\n    vec3 ref = reflect(nor, camRay);\n    l += pow(max(dot(ref, MOON_DIR), 0.0), 30.0);\n    \n    return vec3(l);\n    \n}\n\n//----------------------------------------------------------------------------------------------------------\nvec3 material(vec3 p, vec3 nor)\n{\n    vec3 g = texture(iChannel3, p.xz*0.004).xyz;\n    vec3 mat = g*.2+vec3(0,0,.035);\n\n    g = texture(iChannel1, p.xz*0.002).xyz;\n    g = g*vec3(.15,.16,.1);\n    mat  = mix(mat, g, smoothstep(.8, 1.0, nor.y));\n    mat  = mix(mat, vec3(.0,.0,0.0), smoothstep(.9, .8, nor.y) *  smoothstep(.7, .8, nor.y));\n    \n    return mat+vec3(0.04,0.04,nor.y*.1);\n}\n\n//----------------------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    gTime = iTime * .25+272.;\n    #ifdef MOUSE_SCRUB\n    gTime += iMouse.x*30./iResolution.x;\n    #endif\n    gTime += hash12(fragCoord)*.005;\n\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    camRay = getCamera(uv);\n\n\n    fade = min(1.0, iTime*.02);\n\n    vec3 col = getSky(camRay);\n    \n    float dis = rayMarch(cameraPos, camRay, hash12(fragCoord)*4.);\n    float d = 0.0;\n    if (dis < FAR)\n    {\n        vec3 pos = cameraPos+camRay * dis;\n        d = dis*.0001;\n        vec3 nor = getNormal(pos, d*d*100.);\n        \n        // Do all the lighting...\n        // I got enough contrast from the texturing/lighting so I left out the shadows...\n        col = material(pos,nor) * lighting(pos, nor);\n        col += singleSeed(pos);\n        col =  mix(FOG_COLOUR, col, exp(-d*d));\n    } \n     \n    col += floatingSeeds(cameraPos, camRay, dis-hash12(fragCoord)*5.);\n    col =  mix(FOG_COLOUR, col, exp(-d*d));\n    col = clamp(col, 0.0, 1.0);  // ...Don't want of over egg it.\n    col = col*col*(3.0-2.0*col); // ...Stretch for higher contrast\n    col *= smoothstep(0.0, 8.0, iTime);\n    \n    fragColor = vec4(sqrt(col),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "musicstream",
                        "id": 29897,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/ambientindigo/abductions-from-the-album-alien-invasion?si=13136b4f5b784872a7ba7de19364a87a&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// By David Hoskins, 2022.\n\n\n#define TSIZE 256.\n#define TWRAP 255\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UI4 uvec4(UI3, 1979697957U)\n#define UIF (1.0 / float(0xffffffffU))\n\n\n#define SUN_COLOUR vec3(1., .9, .8)\n#define FOG_COLOUR vec3(.1, .13, .16)\n\n\n#define tri(x) abs(fract(x)-.5)*2.\n//---------------------------------------------------------------------------------------------------------------\nfloat hash12(uvec2 q)\n{\n\tq *= UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\nfloat hash12(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n\n\nvec2 hash21(float p)\n{\n\tuvec2 n = uint(int(p)) * UI2;\n\tn = (n.x ^ n.y) * UI2;\n\treturn vec2(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\n\nvec3 hash32(vec2 q)\n{\n\tuvec3 n = uvec3(ivec3(q.xyx)) * UI3;\n\tn = (n.x ^ n.y ^ n.z) * UI3;\n\treturn vec3(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\n\nvec3 hash33(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n\nfloat hash13(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tuint n = (q.x ^ q.y ^ q.z) * UI0;\n\treturn float(n) * UIF;\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// By David Hoskins, 2022.\n\n\n// Derivative pre-process...\n\nfloat derivHash(ivec2 q2)\n{\n   uvec2 q = uvec2((q2+9) & TWRAP);  // ...Seeded and wrapped.\n   float f = hash12(q);\n   return pow(f, .85 );\n}\n\n//---------------------\n//|                   |\n//|                   |\n//|                   |\n//|                   |\n//|                   |\n//|****               |\n//|****               |\n//|****               |\n//---------------------\n// The block is in the bottom left 256x256 of buffer texture\nvoid mainImage( out vec4 colour, in vec2 coord )\n{\n\n// Draw it ony once to relavent area...\n\n// It seems the buffers are also doubled as I need to draw 2 frames...\n  if (iFrame < 2 && coord.x < TSIZE && coord.y < TSIZE)\n  {\n\n    vec4 data, n;\n    ivec2 co = ivec2(floor(coord));\n\n    float a = derivHash(co);\n    float b = derivHash((co+ivec2(1,0)));\n    float c = derivHash((co+ivec2(0,1)));\n    float d = derivHash((co+ivec2(1,1)));\n\n// Pre-calc all we can...\n    data.x = a;\t \t\t\n    data.y = b-a; \t\t\t\n    data.z = c-a; \t\t\t\n    data.w = a - b - c + d;\n\n    colour = data;\n  }\n  else discard;\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}