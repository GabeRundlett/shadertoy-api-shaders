{
    "Shader": {
        "info": {
            "date": "1714171362",
            "description": "Path Tracing in the Cornell Box.\n\nFeatures: \n• Metallic and non-metallic surfaces\n• Levels of roughness\n• Light sources and emission power\n• Caustics\n• Transparency\n• Transmittance\n• Reflections\n• Refraction\n• Dispersion\n• FXAA\n• MSAA\n",
            "flags": 32,
            "hasliked": 0,
            "id": "4fdSR2",
            "likes": 4,
            "name": "Cornell Box Path Tracing",
            "published": 3,
            "tags": [
                "3d",
                "raytracing",
                "raytracer",
                "cornellbox",
                "raytrace",
                "pathtrace",
                "caustics",
                "pathtracing",
                "pathtracer",
                "box",
                "fxaa",
                "msaa",
                "path",
                "spectral"
            ],
            "usePreview": 1,
            "username": "David654",
            "viewed": 204
        },
        "renderpass": [
            {
                "code": "#define FXAA\n\n// Credits: https://www.shadertoy.com/view/mtScRc\nvec4 fxaa(sampler2D tex, vec2 uv, vec2 texelSz)\n{\n    // Maximum texel span\n    const float span_max = 8.0;\n    // These are more technnical and probably don't need changing:\n    // Minimum \"dir\" reciprocal\n    const float reduce_min = (1.0/128.0);\n    // Luma multiplier for \"dir\" reciprocal\n    const float reduce_mul = (1.0/32.0);\n\n    const vec3 luma = vec3(0.299, 0.587, 0.114);\n\n    // Sample center and 4 corners\n    vec3 rgbCC = texture(tex, uv).rgb;\n    vec3 rgb00 = texture(tex, uv + vec2(-0.5, -0.5) * texelSz).rgb;\n    vec3 rgb10 = texture(tex, uv + vec2(+0.5, -0.5) * texelSz).rgb;\n    vec3 rgb01 = texture(tex, uv + vec2(-0.5, +0.5) * texelSz).rgb;\n    vec3 rgb11 = texture(tex, uv + vec2(+0.5, +0.5) * texelSz).rgb;\n\n    //Get luma from the 5 samples\n    float lumaCC = dot(rgbCC, luma);\n    float luma00 = dot(rgb00, luma);\n    float luma10 = dot(rgb10, luma);\n    float luma01 = dot(rgb01, luma);\n    float luma11 = dot(rgb11, luma);\n\n    // Compute gradient from luma values\n    vec2 dir = vec2((luma01 + luma11) - (luma00 + luma10), (luma00 + luma01) - (luma10 + luma11));\n\n    // Diminish dir length based on total luma\n    float dirReduce = max((luma00 + luma10 + luma01 + luma11) * reduce_mul, reduce_min);\n\n    // Divide dir by the distance to nearest edge plus dirReduce\n    float rcpDir = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n\n    // Multiply by reciprocal and limit to pixel span\n    dir = clamp(dir * rcpDir, -span_max, span_max) * texelSz.xy;\n\n    // Average middle texels along dir line\n    vec4 A = 0.5 * (\n    texture(tex, uv - dir * (1.0 / 6.0))\n    + texture(tex, uv + dir * (1.0 / 6.0))\n    );\n\n    // Average with outer texels along dir line\n    vec4 B = A * 0.5 + 0.25 * (\n    texture(tex, uv - dir * (0.5))\n    + texture(tex, uv + dir * (0.5))\n    );\n\n\n    // Get lowest and highest luma values\n    float lumaMin = min(lumaCC, min(min(luma00, luma10), min(luma01, luma11)));\n    float lumaMax = max(lumaCC, max(max(luma00, luma10), max(luma01, luma11)));\n\n    // Get average luma\n    float lumaB = dot(B.rgb, luma);\n\n    //If the average is outside the luma range, using the middle average\n    return ((lumaB < lumaMin) || (lumaB > lumaMax)) ? A : B;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col;\n    #ifdef FXAA\n        col = fxaa(iChannel0, uv, sqrt(2.0) / iResolution.xy).rgb;\n    #else\n        col = texture(iChannel0, uv).rgb;\n    #endif\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.1415926\n#define EPSILON 0.0001\n#define MAX_DIST 999999.9\n\nvec2 seed1;\nvec2 seed2;\nuvec4 R_STATE;\nfloat samplePart = 1.0;\n\nvec3 rotateX(in vec3 v, float theta)\n{\n    float sin = sin(theta);\n    float cos = cos(theta);\n    return v *= mat3(1, 0, 0, 0, cos, -sin, 0, sin, cos);\n}\n\nvec3 rotateY(in vec3 v, float theta)\n{\n    float sin = sin(theta);\n    float cos = cos(theta);\n    return v *= mat3(cos, 0, sin, 0, 1, 0, -sin, 0, cos);\n}\n\nvec3 rotateZ(in vec3 v, float theta)\n{\n    float sin = sin(theta);\n    float cos = cos(theta);\n    return v *= mat3(cos, -sin, 0, sin, cos, 0, 0, 0, 1);\n}\n\nuint TausStep(uint z, int S1, int S2, int S3, uint M)\n{\n    uint b = (((z << S1) ^ z) >> S2);\n    return (((z & M) << S3) ^ b);\n}\n\nuint LCGStep(uint z, uint A, uint C)\n{\n    return (A * z + C);\n}\n\nvec2 hash22(vec2 p)\n{\n    p += seed1.x;\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nfloat random()\n{\n    R_STATE.x = TausStep(R_STATE.x, 13, 19, 12, uint(4294967294));\n    R_STATE.y = TausStep(R_STATE.y, 2, 25, 4, uint(4294967288));\n    R_STATE.z = TausStep(R_STATE.z, 3, 11, 17, uint(4294967280));\n    R_STATE.w = LCGStep(R_STATE.w, uint(1664525), uint(1013904223));\n    return 2.3283064365387e-10 * float((R_STATE.x ^ R_STATE.y ^ R_STATE.z ^ R_STATE.w));\n}\n\nvec3 randomOnSphere()\n{\n    vec3 rand = vec3(random(), random(), random());\n    float theta = rand.x * 2.0 * 3.14159265;\n    float v = rand.y;\n    float phi = acos(2.0 * v - 1.0);\n    float r = pow(rand.z, 1.0 / 3.0);\n    float x = r * sin(phi) * cos(theta);\n    float y = r * sin(phi) * sin(theta);\n    float z = r * cos(phi);\n    return vec3(x, y, z);\n}\n\nvec3 standardObserver1964[] =\nvec3[] (\nvec3(0.00016, 0.000017, 0.000705), // 380 nm\nvec3(0.000662, 0.000072, 0.002928), // 385 nm\nvec3(0.002362, 0.000253, 0.010482), // 390 nm\nvec3(0.007242, 0.000769, 0.032344), // 395 nm\nvec3(0.01911, 0.002004, 0.086011), // 400 nm\nvec3(0.0434, 0.004509, 0.19712), // 405 nm\nvec3(0.084736, 0.008756, 0.389366), // 410 nm\nvec3(0.140638, 0.014456, 0.65676), // 415 nm\nvec3(0.204492, 0.021391, 0.972542), // 420 nm\nvec3(0.264737, 0.029497, 1.2825), // 425 nm\nvec3(0.314679, 0.038676, 1.55348), // 430 nm\nvec3(0.357719, 0.049602, 1.7985), // 435 nm\nvec3(0.383734, 0.062077, 1.96728), // 440 nm\nvec3(0.386726, 0.074704, 2.0273), // 445 nm\nvec3(0.370702, 0.089456, 1.9948), // 450 nm\nvec3(0.342957, 0.106256, 1.9007), // 455 nm\nvec3(0.302273, 0.128201, 1.74537), // 460 nm\nvec3(0.254085, 0.152761, 1.5549), // 465 nm\nvec3(0.195618, 0.18519, 1.31756), // 470 nm\nvec3(0.132349, 0.21994, 1.0302), // 475 nm\nvec3(0.080507, 0.253589, 0.772125), // 480 nm\nvec3(0.041072, 0.297665, 0.57006), // 485 nm\nvec3(0.016172, 0.339133, 0.415254), // 490 nm\nvec3(0.005132, 0.395379, 0.302356), // 495 nm\nvec3(0.003816, 0.460777, 0.218502), // 500 nm\nvec3(0.015444, 0.53136, 0.159249), // 505 nm\nvec3(0.037465, 0.606741, 0.112044), // 510 nm\nvec3(0.071358, 0.68566, 0.082248), // 515 nm\nvec3(0.117749, 0.761757, 0.060709), // 520 nm\nvec3(0.172953, 0.82333, 0.04305), // 525 nm\nvec3(0.236491, 0.875211, 0.030451), // 530 nm\nvec3(0.304213, 0.92381, 0.020584), // 535 nm\nvec3(0.376772, 0.961988, 0.013676), // 540 nm\nvec3(0.451584, 0.9822, 0.007918), // 545 nm\nvec3(0.529826, 0.991761, 0.003988), // 550 nm\nvec3(0.616053, 0.99911, 0.001091), // 555 nm\nvec3(0.705224, 0.99734, 0), // 560 nm\nvec3(0.793832, 0.98238, 0), // 565 nm\nvec3(0.878655, 0.955552, 0), // 570 nm\nvec3(0.951162, 0.915175, 0), // 575 nm\nvec3(1.01416, 0.868934, 0), // 580 nm\nvec3(1.0743, 0.825623, 0), // 585 nm\nvec3(1.11852, 0.777405, 0), // 590 nm\nvec3(1.1343, 0.720353, 0), // 595 nm\nvec3(1.12399, 0.658341, 0), // 600 nm\nvec3(1.0891, 0.593878, 0), // 605 nm\nvec3(1.03048, 0.527963, 0), // 610 nm\nvec3(0.95074, 0.461834, 0), // 615 nm\nvec3(0.856297, 0.398057, 0), // 620 nm\nvec3(0.75493, 0.339554, 0), // 625 nm\nvec3(0.647467, 0.283493, 0), // 630 nm\nvec3(0.53511, 0.228254, 0), // 635 nm\nvec3(0.431567, 0.179828, 0), // 640 nm\nvec3(0.34369, 0.140211, 0), // 645 nm\nvec3(0.268329, 0.107633, 0), // 650 nm\nvec3(0.2043, 0.081187, 0), // 655 nm\nvec3(0.152568, 0.060281, 0), // 660 nm\nvec3(0.11221, 0.044096, 0), // 665 nm\nvec3(0.081261, 0.0318, 0), // 670 nm\nvec3(0.05793, 0.022602, 0), // 675 nm\nvec3(0.040851, 0.015905, 0), // 680 nm\nvec3(0.028623, 0.01113, 0), // 685 nm\nvec3(0.019941, 0.007749, 0), // 690 nm\nvec3(0.013842, 0.005375, 0), // 695 nm\nvec3(0.009577, 0.003718, 0), // 700 nm\nvec3(0.006605, 0.002565, 0), // 705 nm\nvec3(0.004553, 0.001768, 0), // 710 nm\nvec3(0.003145, 0.001222, 0), // 715 nm\nvec3(0.002175, 0.000846, 0), // 720 nm\nvec3(0.001506, 0.000586, 0), // 725 nm\nvec3(0.001045, 0.000407, 0), // 730 nm\nvec3(0.000727, 0.000284, 0), // 735 nm\nvec3(0.000508, 0.000199, 0), // 740 nm\nvec3(0.000356, 0.00014, 0), // 745 nm\nvec3(0.000251, 0.000098, 0), // 750 nm\nvec3(0.000178, 0.00007, 0), // 755 nm\nvec3(0.000126, 0.00005, 0), // 760 nm\nvec3(0.00009, 0.000036, 0), // 765 nm\nvec3(0.000065, 0.000025, 0), // 770 nm\nvec3(0.000046, 0.000018, 0), // 775 nm\nvec3(0.000033, 0.000013, 0) // 780 nm\n);\n\nfloat standardObserver1964_w_min = 380.0f;\nfloat standardObserver1964_w_max = 780.0f;\nint standardObserver1964_length = 81;\n\nvec3 wavelengthToXYZ(float wavelength)\n{\n    float pos = (wavelength - standardObserver1964_w_min) / (standardObserver1964_w_max - standardObserver1964_w_min);\n    float index = pos * float(standardObserver1964_length);\n    float floorIndex = floor(index);\n    float blend = clamp(index - floorIndex, 0.0, 1.0);\n    int index0 = int(floorIndex);\n    int index1 = index0 + 1;\n    index1 = min(index1, standardObserver1964_length - 1);\n\n    return mix(standardObserver1964[index0], standardObserver1964[index1], blend);\n}\n\nvec3 XYZtosRGB(vec3 XYZ)\n{\n    mat3 m = mat3(\n    3.2404542, -1.5371385, -0.4985314,\n    -0.9692660,  1.8760108,  0.0415560,\n    0.0556434, -0.2040259,  1.0572252);\n\n    return XYZ * m;\n}\n\nvec3 sRGBtoXYZ(vec3 sRGB)\n{\n    mat3 m = mat3(\n    0.4124564, 0.2126729, 0.0193339,\n    0.3575761, 0.7151522, 0.1191920,\n    0.1804375, 0.0721750, 0.9503041);\n\n    return sRGB * m;\n}\n\nvec3 wavelengthTosRGB(float wavelength)\n{\n    return abs(XYZtosRGB(wavelengthToXYZ(wavelength)));\n}\n\nfloat applyGammasRGBChannel(float sRGBChannel)\n{\n    if(sRGBChannel > 0.0031308)\n    {\n        return 1.055 * pow(sRGBChannel, 1.0/2.4) - 0.055;\n    }\n    else\n    {\n        return sRGBChannel * 12.92;\n    }\n}\n\nvec3 applyGammasRGB(vec3 sRGB)\n{\n    return vec3(applyGammasRGBChannel(sRGB.r), applyGammasRGBChannel(sRGB.g), applyGammasRGBChannel(sRGB.b));\n}\n\nvec3 gammaCorrection(vec3 col)\n{\n    return pow(col, vec3(1.0 / 2.2));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define CAMERA_POS vec3(0, 3, -6)\n#define CAMERA_FOV 60.0\n#define MAX_REFLECTIONS 100\n#define SAMPLES 16\n#define EPS 0.001\n#define MSAA 1\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n    vec3 colorFactor;\n    float wavelength;\n};\n\nvec2 iSphere(in vec3 origin, in vec3 direction, float ra, inout vec3 normal1, inout vec3 normal2)\n{\n    float b = dot(origin, direction);\n    float c = dot(origin, origin) - ra * ra;\n    float h = b * b - c;\n    if(h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    float t1 = -b - h;\n    float t2 = -b + h;\n\n    vec3 intersectionPoint1 = origin + direction * t1;\n    vec3 intersectionPoint2 = origin + direction * t2;\n    normal1 = normalize(intersectionPoint1);\n    normal2 = normalize(intersectionPoint2);\n\n    return vec2(t1, t2);\n}\n\nvec2 iBox(in vec3 origin, in vec3 direction, vec3 boxSize, inout vec3 normal1, inout vec3 normal2)\n{\n    vec3 m = 1.0 / direction;\n    vec3 n = m * origin;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    if(tN > tF || tF < 0.0)\n    {\n        return vec2(-1.0);\n    }\n\n    normal1 = (tN > 0.0) ? step(vec3(tN), t1) : step(t2, vec3(tF));\n    normal1 *= -sign(direction);\n\n    normal2 = (tN > 0.0) ? step(t2, vec3(tF)) : step(vec3(tN), t1);\n    normal2 *= -sign(direction);\n\n    return vec2(tN, tF);\n}\n\nvec3 castRay(Ray ray, inout vec3 normal1, inout vec3 normal2)\n{\n    vec2 minIntersection = vec2(MAX_DIST);\n    vec2 intersection;\n    vec3 intersectionPoint;\n    int index = -1;\n\n    vec3 outNormal1;\n    vec3 outNormal2;\n\n    vec3 boxPos = vec3(0, 1, 0);\n    float boxSize = 2.0;\n    float wallThickness = 0.001;\n    float lightSourceSize = boxSize * 0.5;\n\n    // FLOOR\n    intersection = iBox(ray.origin - boxPos, ray.direction, vec3(boxSize, wallThickness, boxSize), outNormal1, outNormal2);\n\n    if(intersection.x > 0.0 && intersection.x < minIntersection.x)\n    {\n        minIntersection = intersection;\n        index = 0;\n        normal1 = outNormal1;\n        normal2 = outNormal2;\n    }\n\n    // BACK WALL\n    intersection = iBox(ray.origin - vec3(boxPos.x, boxPos.y + boxSize - wallThickness, boxPos.z + boxSize + wallThickness), ray.direction, vec3(boxSize, boxSize, wallThickness), outNormal1, outNormal2);\n\n    if(intersection.x > 0.0 && intersection.x < minIntersection.x)\n    {\n        minIntersection = intersection;\n        index = 1;\n        normal1 = outNormal1;\n        normal2 = outNormal2;\n    }\n\n    // RIGHT WALL\n    intersection = iBox(ray.origin - vec3(boxPos.x + boxSize + wallThickness, boxPos.y + boxSize - wallThickness, boxPos.z), ray.direction, vec3(wallThickness, boxSize, boxSize), outNormal1, outNormal2);\n\n    if(intersection.x > 0.0 && intersection.x < minIntersection.x)\n    {\n        minIntersection = intersection;\n        index = 2;\n        normal1 = outNormal1;\n        normal2 = outNormal2;\n    }\n\n    // LEFT WALL\n    intersection = iBox(ray.origin - vec3(boxPos.x -boxSize - wallThickness, boxPos.y + boxSize - wallThickness, boxPos.z), ray.direction, vec3(wallThickness, boxSize, boxSize), outNormal1, outNormal2);\n\n    if(intersection.x > 0.0 && intersection.x < minIntersection.x)\n    {\n        minIntersection = intersection;\n        index = 3;\n        normal1 = outNormal1;\n        normal2 = outNormal2;\n    }\n\n    // CEILING\n    intersection = iBox(ray.origin - vec3(boxPos.x, boxPos.y + 2.0 * boxSize, boxPos.z), ray.direction, vec3(boxSize, wallThickness, boxSize), outNormal1, outNormal2);\n\n    if(intersection.x > 0.0 && intersection.x < minIntersection.x)\n    {\n        minIntersection = intersection;\n        index = 4;\n        normal1 = outNormal1;\n        normal2 = outNormal2;\n    }\n\n    // LIGHT\n    intersection = iBox(ray.origin - vec3(boxPos.x, boxPos.y + 2.0 * boxSize - 0.001, boxPos.z), ray.direction, vec3(lightSourceSize, wallThickness, lightSourceSize), outNormal1, outNormal2);\n\n    if(intersection.x > 0.0 && intersection.x < minIntersection.x)\n    {\n        minIntersection = intersection;\n        index = 5;\n        normal1 = outNormal1;\n        normal2 = outNormal2;\n    }\n\n    boxPos.y += 0.02;\n\n    // GLASS BALL\n    float radius = 0.7;\n    vec3 pos = boxPos + vec3(1.1, radius, -0.4);\n    intersection = iSphere(ray.origin - pos, ray.direction, radius, outNormal1, outNormal2);\n\n    if(intersection.x > 0.0 && intersection.x < minIntersection.x)\n    {\n        minIntersection = intersection;\n        index = 6;\n        normal1 = outNormal1;\n        normal2 = outNormal2;\n    }\n\n    // BOX\n    vec3 boxDim = vec3(0.7, 1.5, 0.7);\n    pos = boxPos + vec3(-0.6, 1.495, 0.7);\n    vec3 boxRo = rotateY(ray.origin, 0.4);\n    vec3 boxRd = rotateY(ray.direction, 0.4);\n    intersection = iBox(boxRo - pos, boxRd, boxDim, outNormal1, outNormal2);\n\n    if(intersection.x > 0.0 && intersection.x < minIntersection.x)\n    {\n        minIntersection = intersection;\n        index = 7;\n        normal1 = rotateY(outNormal1, -0.4);\n        normal2 = rotateY(outNormal2, -0.4);\n    }\n\n    // MIRROR BALL\n    radius = 0.4;\n    pos = boxPos + vec3(-0.4, radius, -1.0);\n    intersection = iSphere(ray.origin - pos, ray.direction, radius, outNormal1, outNormal2);\n\n    if(intersection.x > 0.0 && intersection.x < minIntersection.x)\n    {\n        minIntersection = intersection;\n        index = 8;\n        normal1 = outNormal1;\n        normal2 = outNormal2;\n    }\n    return vec3(minIntersection, index);\n}\n\nstruct Material\n{\n    vec3 albedo;\n    float roughness;\n    float metallic;\n    float refraction;\n    float transmittance;\n    vec3 emissionColor;\n    float emissionPower;\n};\n\nfloat fresnel(vec3 rd, vec3 normal, float n1, float n2)\n{\n    float cos = abs(dot(-rd, normal));\n    float sin = sqrt(1.0 - pow(cos, 2.0));\n    float sq = sqrt(1.0 - pow(n1 / n2 * sin, 2.0));\n    float n1cos = n1 * cos;\n    float n2cos = n2 * cos;\n    float n1sq = n1 * sq;\n    float n2sq = n2 * sq;\n    float Rs = pow((n1cos - n2sq) / (n1cos + n2sq), 2.0);\n    float Rp = pow((n1sq - n2cos) / (n1sq + n2cos), 2.0);\n    float R = 0.5 * (Rs + Rp);\n    return R;\n}\n\nfloat sellmeier(float wavelength, float B1, float B2, float C1, float C2)\n{\n    float w_um = wavelength / 1000.0;\n    float w2 = w_um * w_um;\n    float n2 = 1.0 + B1 * w2 / (w2 - C1) + B2 * w2 / (w2 - C2);\n    return sqrt(n2);\n}\n\nvec3 getSky(vec3 rd)\n{\n    rd = rotateX(rd, PI / 2.0);\n    rd = rotateZ(rd, 3.0 * PI / 2.0);\n\n    vec2 skyUV = vec2(atan(rd.x, rd.y), asin(rd.z) * 2.0) / PI * 0.5 + 0.5;\n\n    vec3 col = texture(iChannel1, skyUV).rgb;\n    vec3 sun = vec3(0.95, 0.9, 1.0);\n    return clamp(col, 0.0, 1.0);\n}\n\nvec4 trace(inout Ray ray, inout vec3 contribution, inout bool isInside)\n{\n    vec3 normal1, normal2;\n    vec3 second = castRay(ray, normal1, normal2);\n    vec2 intersection = second.xy;\n    vec3 intersectionPoint = ray.origin + ray.direction * intersection.x;\n    int index = int(second.z);\n\n    if(index == -1)\n    {\n        //return vec4(getSky(ray.rd), 1);\n        return vec4(vec3(0), 1);\n    }\n\n    Material mat;\n    vec4 color;\n\n    if(index == 0)\n    {\n        mat = Material(vec3(1, 1, 1), 1.0, 1.0, 0.0, 0.0, vec3(1, 1, 1), 0.0);\n    }\n    else if(index == 1)\n    {\n        mat = Material(vec3(1, 1, 1), 1.0, 0.0, 0.0, 0.0, vec3(1, 1, 1), 0.0);\n    }\n    else if(index == 2)\n    {\n        mat = Material(vec3(0, 1, 0), 1.0, 0.0, 0.0, 0.0, vec3(0, 1, 0), 0.0);\n    }\n    else if(index == 3)\n    {\n        mat = Material(vec3(1, 0, 0), 1.0, 0.0, 0.0, 0.0, vec3(1, 0, 0), 0.0);\n    }\n    else if(index == 4)\n    {\n        mat = Material(vec3(1, 1, 1), 0.0, 0.25, 0.0, 0.0, vec3(1, 1, 1), 0.0);\n    }\n    else if(index == 5)\n    {\n        mat = Material(vec3(1, 1, 1), 1.0, 0.0, 0.0, 0.0, vec3(1, 1, 1), 40.0);\n    }\n    else if(index == 6)\n    {\n        mat = Material(vec3(1, 1, 1), 0.0, 1.0, 1.5, 0.9306, vec3(1, 1, 1), 0.0);\n    }\n    else if(index == 7)\n    {\n        mat = Material(vec3(1, 1, 1), 0.0, 1.0, 1.5, 0.9306, vec3(1, 1, 1), 0.0);\n    }\n    else if(index == 8)\n    {\n        mat = Material(vec3(1, 1, 1), 0.0, 1.0, 0.0, 0.0, vec3(1, 1, 1), 0.0);\n    }\n\n    mat.roughness *= mat.roughness;\n    \n    float currIntersection = isInside ? intersection.y : intersection.x;\n    vec3 currNormal = isInside ? normal2 : normal1;\n    \n    if(dot(ray.direction, currNormal) > 0.0) currNormal *= -1.0;\n\n    vec3 rand = randomOnSphere();\n    vec3 diffuse = normalize(rand * dot(rand, currNormal));\n    vec3 specular = reflect(ray.direction, currNormal);\n    float specularBounce = (mat.metallic >= random()) ? 1.0 : 0.0;\n\n    vec3 emission = mat.emissionColor * mat.emissionPower;\n\n    contribution *= mix(mat.albedo, vec3(1), specularBounce);\n\n    float fmix = (1.0 - mat.roughness) * specularBounce;\n\n    if(mat.refraction >= 1.0)\n    {\n        float n1 = 1.000273;\n        float n2 = sellmeier(ray.wavelength, 1.03961212, 0.231792344, 6.00069867e-3, 2.00179144e-2);\n        \n        float specularBounce = fresnel(ray.direction, currNormal, n1, n2) + 1.0 - mat.transmittance >= random() ? 1.0 : 0.0;\n\n        if(specularBounce == 1.0)\n        {\n            float f = isInside ? -1.0 : 1.0;\n            \n            ray.origin += ray.direction * (currIntersection - EPS * f);\n            ray.direction = mix(diffuse, specular, fmix);\n            return vec4(emission, 0);\n        }\n\n        float f = !isInside ? -1.0 : 1.0;\n        ray.origin += ray.direction * (currIntersection + EPS * f);\n        ray.direction = mix(diffuse, specular, fmix);\n        ray.direction = refract(ray.direction, currNormal, n1 / n2);\n        isInside = !isInside;\n        return vec4(emission, 0);\n    }\n\n    ray.origin += ray.direction * (intersection.x - EPS);\n    ray.direction = mix(diffuse, specular, fmix);\n\n    return vec4(emission, 0);\n}\n\nvec3 traceRay(in Ray ray)\n{\n    vec3 light = vec3(0.0);\n    vec3 contribution = ray.colorFactor;\n    bool isInside = false;\n\n    for(int i = 0; i < MAX_REFLECTIONS; i++)\n    {\n        vec4 refCol = trace(ray, contribution, isInside);\n        if(refCol.a == 1.0)\n        {\n            return light + refCol.rgb * contribution;\n        }\n        else\n        {\n            light += refCol.rgb * contribution;\n        }\n        \n        float p = max(contribution.r, max(contribution.g, contribution.b));\n        \n        if(random() > p)\n        {\n            break;\n        }\n        \n        contribution *= 1.0 / p;\n    }\n\n    return light;\n}\n\nvec3 render(in vec2 uv)\n{\n    vec3 ro = CAMERA_POS;\n    float invTanFov = 1.0 / tan(radians(CAMERA_FOV) * 0.5);\n    vec3 rd = normalize(vec3(invTanFov, uv));\n    rd = rd.yzx;\n    \n    seed1 = hash22(gl_FragCoord.xy - iTime);\n    seed2 = hash22(gl_FragCoord.xy + iTime);\n    vec2 uvRes = hash22(uv + 1.0) * iResolution.xy + iResolution.xy;\n    R_STATE.x = uint(seed1.x + uvRes.x);\n    R_STATE.y = uint(seed1.y + uvRes.x);\n    R_STATE.z = uint(seed2.x + uvRes.y);\n    R_STATE.w = uint(seed2.y + uvRes.y);\n    \n    vec3 outColor;\n\n    for(int i = 0; i < SAMPLES; i++)\n    {\n        float wavelength = mix(380.0, 780.0, random());\n        vec3 sRGB = wavelengthTosRGB(wavelength);\n        Ray ray = Ray(ro, rd, sRGB, wavelength);\n\n        outColor += traceRay(ray);\n    }\n\n    outColor /= float(SAMPLES);\n    \n    outColor = gammaCorrection(outColor);\n\n    return outColor;\n}\n\nvec2 getUV(vec2 offset)\n{\n    return (2.0 * gl_FragCoord.xy + offset - iResolution.xy) / iResolution.y;\n}\n\nvec3 renderAAx1()\n{\n    return render(getUV(vec2(0)));\n}\n\nvec3 renderAAx2()\n{\n    float bxy = float(int(gl_FragCoord.x + gl_FragCoord.y) & 1);\n    float nbxy = 1. - bxy;\n    vec3 colAA = (render(getUV(vec2(0.33 * nbxy, 0.))) + render(getUV(vec2(0.33 * bxy, 0.66))));\n    return colAA / 2.0;\n}\n\nvec3 renderAAx3()\n{\n    float bxy = float(int(gl_FragCoord.x + gl_FragCoord.y) & 1);\n    float nbxy = 1. - bxy;\n    vec3 colAA = (render(getUV(vec2(0.66 * nbxy, 0.))) + render(getUV(vec2(0.66 * bxy, 0.66))) + render(getUV(vec2(0.33, 0.33))));\n    return colAA / 3.0;\n}\n\nvec3 renderAAx4()\n{\n    vec4 e = vec4(0.125, -0.125, 0.375, -0.375);\n    vec3 colAA = render(getUV(e.xz)) + render(getUV(e.yw)) + render(getUV(e.wx)) + render(getUV(e.zy));\n    return colAA /= 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 sampleUV = fragCoord / iResolution.xy;\n    samplePart = texture(iChannel0, sampleUV).a;\n    vec3 sampleCol = texture(iChannel0, sampleUV).rgb;\n    fragColor.rgb = sampleCol;\n    \n    vec3 col;\n    \n    if(MSAA == 2) col = renderAAx2();\n    else if(MSAA == 3) col = renderAAx3();\n    else if(MSAA == 4) col = renderAAx4();\n    else col = renderAAx1();\n    \n    samplePart++;\n    \n    fragColor = vec4(mix(fragColor.rgb, col, 1.0 / samplePart), samplePart);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}