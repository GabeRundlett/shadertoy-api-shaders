{
    "Shader": {
        "info": {
            "date": "1524987206",
            "description": "Cone traced depth of field, based on [url]https://www.shadertoy.com/view/4scBW8[/url], after a suggestion by bioccular. Not really the most efficient way of doing that particular effect... Now the last thing I want to try is cone traced motion blur.",
            "flags": 0,
            "hasliked": 0,
            "id": "MddfW8",
            "likes": 39,
            "name": "Bokeh Cone Tracing",
            "published": 3,
            "tags": [
                "3d",
                "raymarch",
                "dof"
            ],
            "usePreview": 0,
            "username": "Klems",
            "viewed": 2003
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265359\n#define rot(a) mat2(cos(a + PI*0.25*vec4(0,6,2,0)))\n#define FOV 0.7\n\nconst vec3 forward = normalize(vec3(1, 2, 3));\n\n// Dave Hoskins hash\nvec3 hash33( in vec3 p3 ) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n// cosine based hue to rgb conversion\nvec3 hue( in float c ) {\n    return cos(2.0*PI*c + 2.0*PI/3.0*vec3(3,2,1))*0.5+0.5;\n}\n\n// tonemapping from https://www.shadertoy.com/view/lslGzl\nvec3 filmicToneMapping( vec3 col ) {\n    col = max(vec3(0.), col - vec3(0.004));\n    return (col * (6.2 * col + .5)) / (col * (6.2 * col + 1.7) + 0.06);\n}\n\n// main distance function, returns distance, color and normal\nfloat de( in vec3 p, in float r, out vec3 color, out vec3 normal ) {\n    float d = 9e9;\n    color = vec3(0);\n    vec3 center = floor(p)+0.5;\n    float phase = 0.01*dot(p, forward);\n    \n    // 8 taps voronoi\n    for (float x = -0.5 ; x < 1.0 ; x++)\n    for (float y = -0.5 ; y < 1.0 ; y++)\n    for (float z = -0.5 ; z < 1.0 ; z++) {\n        vec3 sphere = center+vec3(x, y, z);\n        vec3 rnd = hash33(sphere);\n        sphere += (rnd-0.5)*0.3;\n        vec3 inSphere = p-sphere;\n        float len = length(inSphere);\n        vec3 norm = inSphere/len;\n        float R = 0.01+(rnd.x*rnd.y)*0.1;\n        float dist = len-R;\n        \n        // found the closest sphere, update distance and normal\n        if (dist < d) {\n            d = dist;\n            normal = norm;\n        }\n        \n        // figure out how much light there is inside the radius\n        float area = R*R*R;\n    \tfloat maxArea = r*r*r;\n        float scale = smoothstep(r, -r, dist)*area/max(area, maxArea);\n        \n        // add lights\n        vec3 lightColor = hue(rnd.z*0.2 + phase);\n        color += scale*lightColor*100.0;\n    }\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 rnd = hash33(vec3(fragCoord, iFrame));\n    vec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n    \n    vec3 right = normalize(cross(forward, vec3(0, 1, 0)));\n    vec3 up = cross(right, forward);\n    vec3 dir = normalize(forward/tan(FOV*0.5)+right*uv.x+up*uv.y);\n    vec3 from = forward*iTime*4.0;\n    \n    float focal = 4.0;\n    float sinPix = sin(FOV / iResolution.y);\n    vec4 acc = vec4(0, 0, 0, 1);\n    vec3 dummy = vec3(0);\n    float totdist = de(from, 0.0, dummy, dummy)*rnd.x;\n    \n    for (int i = 0 ; i < 50 ; i++) {\n\t\tvec3 p = from + totdist * dir;\n        float r = max(totdist*sinPix, abs((totdist-focal)*0.03));\n        vec3 color = vec3(0);\n        vec3 normal = vec3(0);\n        float dist = de(p, r, color, normal);\n        \n        // apply fog to the given color\n        float fog = 1.0-exp(-totdist * 0.15);\n        color = mix(color, vec3(0), fog);\n        \n        // find out the orientation of the light source with the aperture\n        float theta = atan(dot(normal, right), dot(normal, up));\n        // change the shape of the cone tracing radius according to that\n        float R = r * (cos(theta*6.0)*0.2+0.8);\n        \n        // cone trace the surface\n\t\tfloat alpha = smoothstep(R, -R, dist);\n        acc.rgb += acc.a * (alpha*color.rgb);\n        acc.a *= (1.0 - alpha);\n        \n        // hit a surface, stop\n        if (acc.a < 0.01) break;\n        // continue forward\n        totdist += max(abs(dist), r*0.5);\n\t}\n    \n    fragColor.rgb = filmicToneMapping(acc.rgb);\n    fragColor.a = 1.0;\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}