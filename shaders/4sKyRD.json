{
    "Shader": {
        "info": {
            "date": "1521233257",
            "description": "Random Delaunay triangulation on a regular grid. My response to Shane's wishlist :)\nAlso check out [url=http://polycu.be/edit/?h=M963jR]PolyCu.be edition[/url] with panning/zooming.",
            "flags": 0,
            "hasliked": 0,
            "id": "4sKyRD",
            "likes": 58,
            "name": "Random Delaunay Triangulation",
            "published": 3,
            "tags": [
                "procedural",
                "voronoi",
                "random",
                "distance",
                "delaunay"
            ],
            "usePreview": 0,
            "username": "tomkh",
            "viewed": 2775
        },
        "renderpass": [
            {
                "code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// by Tomasz Dobrowolski' 2018\n\n// Random Delaunay triangulation on regular grid.\n\n// +LMB to see distance to Voronoi edges\n\n// This is a response to Shane, who wrote:\n// \"I'm writing a wish list, an out-of-the-box way to cheaply produce\n//  a geometric Delaunay triangulation of random 2D points\"\n// in https://www.shadertoy.com/view/Xsyczh\n\n// I wouldn't describe my method \"out of the box\", as it is more or\n// less straigh-forward implementation for heavily restricted\n// point set on a regular grid.\n// Nevertheless, enjoy!\n\n// Also check out PolyCube's edition with panning/zooming:\n// http://polycu.be/edit/?h=M963jR\n\n#define FLIP_ANIMATION 1\n\n// Hash variation by Shane,\n// from https://www.shadertoy.com/view/4dSfzD\nvec2 hashPt(vec2 p, float timeOffset) {\n   float n = sin(dot(p, vec2(41, 289)));\n   // Animated.\n   p = fract(vec2(262144, 32768)*n);\n   return sin( p*6.2831853 + timeOffset )*.5 + .5;\n}\n\n// We generate point in the cell center\n// restricted in movement to box half the cell width/height,\n// so Delaunay triangles behaves regularly.\nvec2 cellPt(vec2 p) {\n    return p + .5 + (hashPt(p, iTime) - .5)*.5;\n}\n\n// Fast distance to edge-Voronoi.\n// Since seed positions are heavily restricted,\n// 3x3 check is enough to search for a closest point\n// as well as search for a pair of neighbours.\nvec2 edgeVoronoi(vec2 p) {\n   vec2 h, pH = floor(p);\n\n   vec2 mh = cellPt(pH) - p;\n   float md = 8.0;\n   for (int j=-1; j<=1; ++j )\n   for (int i=-1; i<=1; ++i ) {\n      h = cellPt(pH + vec2(i,j)) - p;\n      float d = dot(h, h);\n      if (d < md) {\n         md = d;\n         mh = h;\n      }\n   }\n\n   const float eps = .0001;\n   float ed = 8.0;\n\n   for (int j=-1; j<=1; ++j )\n   for (int i=-1; i<=1; ++i ) {\n      h = cellPt(pH + vec2(i,j)) - p;\n      if (dot(h-mh, h-mh) > eps)\n         ed = min( ed, dot( 0.5*(h+mh), normalize(h-mh) ) );\n   }\n   return vec2(sqrt(md),ed);\n}\n\n// Signed distance to a line crossing (p0, p1) segment.\nfloat distLine( vec2 p0, vec2 p1 ) {\n   vec2 e0 = p1 - p0;\n   return dot( p0, normalize(vec2(e0.y,-e0.x)) );\n}\n\n// Use \"parabolic lifting\" method to calculate if two triangles are about to flip.\n// This is actually more reliable than circumscribed circle method.\n// The technique is based on duality between Delaunay Triangulation\n// and Convex Hull, where DT is just a boundary of convex hull\n// of projected seeds onto paraboloid.\n// We project (h1 h2 h3) triangle onto paraboloid\n// and return the distance of the origin\n// to a plane crossing projected triangle.\nfloat flipDistance(vec2 h1, vec2 h2, vec2 h3)\n{\n   // Projects triangle on paraboloid.\n   vec3 g1 = vec3(h1, dot(h1,h1));\n   vec3 g2 = vec3(h2, dot(h2,h2));\n   vec3 g3 = vec3(h3, dot(h3,h3));\n   // Return signed distance of (g1, g2, g3) plane to the origin.\n   #if FLIP_ANIMATION\n     return dot(g1, normalize(cross(g3-g1, g2-g1)));\n   #else\n     // If we don't do animation, we are only interested in a sign,\n     // so normalization is unnecessary.\n   \t return dot(g1, cross(g3-g1, g2-g1));\n   #endif\n}\n\n// Find distance to closest Delaunay edge in (h0, h1, h2, h3) quad.\nfloat delaunayQuad(vec2 h0, vec2 h1, vec2 h2, vec2 h3) {\n   // Get distance to quad (note: in general it can be concave, but we don't care).\n   float md = min(\n      min(distLine(h0, h1), distLine(h1, h2)),\n      min(distLine(h2, h3), distLine(h3, h0)));\n   if (md < 0.0)\n      return 8.0; // outside of the quad\n\n   // Calculate flip distance relative to h2, but any other point would do.\n   float dc = flipDistance(h0 - h2, h1 - h2, h3 - h2);\n\n   #if FLIP_ANIMATION\n     float f = clamp(dc*6. + .5, 0., 1.);\n   #else\n     float f = float(dc > 0.0);\n   #endif\n   // Flipping rotates diagonal from (h0 h2) to (h3 h1).\n   // Calculate distance to diagonal (positive from both sides).\n   return min(md, abs(distLine(mix(h0, h3, f), mix(h2, h1, f))));\n}\n\n// Final function visits 4 quads around the center cell.\nfloat delaunayTriangulation(vec2 p) {\n   vec2 pH = floor(p);\n\n   vec2 o = cellPt(pH) - p;\n   // Go clock-wise around center cell.\n   vec2 h0 = cellPt(pH + vec2(-1, 0)) - p;\n   vec2 h1 = cellPt(pH + vec2(-1,-1)) - p;\n   vec2 h2 = cellPt(pH + vec2( 0,-1)) - p;\n   vec2 h3 = cellPt(pH + vec2( 1,-1)) - p;\n   vec2 h4 = cellPt(pH + vec2( 1, 0)) - p;\n   vec2 h5 = cellPt(pH + vec2( 1, 1)) - p;\n   vec2 h6 = cellPt(pH + vec2( 0, 1)) - p;\n   vec2 h7 = cellPt(pH + vec2(-1, 1)) - p;\n\n   float md =   delaunayQuad(h0,h1,h2,o);\n   md = min(md, delaunayQuad(o,h2,h3,h4));\n   md = min(md, delaunayQuad(h6,o,h4,h5));\n   md = min(md, delaunayQuad(h7,h0,o,h6));\n   return md;\n}\n\n// Do shading with pseudo-linear color space and fake anti-aliasing.\nvec3 lin(vec3 col) { return col*col; }\nvec3 gamma(vec3 col) { return sqrt(max(vec3(0),col-.03)); }\nvec3 shade(float tri, float dist, vec2 ev, float ss) {\n   ss *= .6;\n   return\n    mix(\n     mix(\n      mix(\n       mix(\n        mix(\n         lin(vec3(.7,.5,1.))*(dist*2.2 + .1),\n         lin(vec3(.7,.6,1.)),\n         smoothstep(.03+ss,.03-ss,ev.y)*.3\n        ),\n        vec3(0), // edge shadow\n        smoothstep(.05,.01+ss,tri)*.3\n       ),\n       lin(vec3(1.,.7,.3)),\n       max(\n        smoothstep(ss*2.,0.,abs(fract(dist*8.+.5)-.5)/8.)*.7*step(1./16.,dist),\n        smoothstep(.01+ss,.01-ss,tri))\n      ),\n      vec3(0), // seed point shadow\n      smoothstep(.08,min(.075,.05+ss),ev.x)*.7\n     ),\n     lin(vec3(1,.8,.5)),\n     smoothstep(.05+ss,.05-ss,ev.x)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ss = .01;\n    vec2 p = (fragCoord.xy - iResolution.xy*.5)*ss;\n    vec2 ev = edgeVoronoi(p);\n    float tri = delaunayTriangulation(p);\n    float dist = (iMouse.z > 0.) ? ev.y : tri;\n    vec3 col = shade(tri, dist, ev, ss);\n    fragColor = vec4(gamma(col), 1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}