{
    "Shader": {
        "info": {
            "date": "1670454663",
            "description": "Fits a cubic curve to the unit interval, satisfying slopes k0 at x = 0 and k1 at x = 1, derived from Hermite basis functions.\nMouse x and y control k0 and k1.",
            "flags": 0,
            "hasliked": 0,
            "id": "msBXzy",
            "likes": 14,
            "name": "Hermite step",
            "published": 3,
            "tags": [
                "graph",
                "cubic",
                "ramp",
                "hermite",
                "step",
                "interpolate"
            ],
            "usePreview": 0,
            "username": "grinist",
            "viewed": 250
        },
        "renderpass": [
            {
                "code": "// Fits a cubic curve to the unit interval, satisfying slopes k0 at x = 0 and k1 at x = 1,\n// derived from Hermite basis functions.\n// One powerhouse of a function - you can get many family favorites with\n// just two extra slope parameters! \\:D/\n// The function values will escape the [0, 1] range with steep / negative slopes.\n// Mouse x and y control k0 and k1\n\n// For (k0, k1):\n// (1, 1) lerp\n// (0, 0) smoothstep\n// (0, 2) squared\n// (2, 0) inv squared\n// (3, 0) cubed\n// (0, 3) inv cubed\n// (0, 1) almost unit identity\n// (6, 0) a nice bounce to 1.25 at center\n\nfloat hermiteStep(float x, float k0, float k1)\n{\n    return x * (k0 + x * (3.0 - k0 - k0 - k1 + x * (k0 - 2.0 + k1)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    setupGraph(vec2(0.5), vec2(1.6), fragCoord, iResolution);\n\n    // background\n\tfcol = mix(vec4(1.0, 1.0, 1.0, 1.0), vec4(0.8, 0.8, 0.8, 1.0), sqrlength(xy - graphCenter) / sqrlength(graphSize * 0.5));\n    \n\t// grid\n    drawGrid(0.1, px, vec4(0.0, 0.0, 0.0, 0.125));\n\tdrawGrid(0.5, px, vec4(0.0, 0.0, 0.0, 0.25));\n\tdrawGrid(1.0, px, vec4(0.0, 0.0, 0.0, 0.5));\n    \n    // curves\n    \n    // slope parameters\n    vec2 k = vec2(2.0, 0.0);\n    if (iMouse.z > 0.0)\n    {\n        k = graphPos + iMouse.xy / iResolution.xy * graphSize;\n        k *= 10.0;\n    }\n    else\n    {\n        float t = (iTime + 15.0) * 1.257; // nice initial values and a 25 sec loop\n        k = vec2(cos(t * 0.8), sin(t * 0.6)) * 0.5 + 0.5;\n        k *= 3.0;\n    }\n\n    // slopes around unit interval\n    vec3 col = vec3(0.15, 0.55, 0.9);\n    vec2 d = xy * 2.0;\n    float a = max(0.0, 0.5 - dot(d, d));\n    drawFunc(k.x * xy.x, px, vec4(col, a));\n    d = (xy - vec2(1, 1)) * 2.0;\n    a = max(0.0, 0.5 - dot(d, d));\n    drawFunc(k.y * (xy.x - 1.0) + 1.0, px, vec4(col, a));\n\n    // hermite step\n    vec2 unit = (step(xy, vec2(-px)) - step(xy, vec2(1.0 + px)));\n    a = 0.2 + 0.8 * (unit.x * unit.y);\n\tdrawFunc(hermiteStep(xy.x, k.x, k.y), 3.0 * px, vec4(col, a));\n\n\tfragColor = fcol;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec2 graphSize;\nvec2 graphCenter;\nvec2 graphPos; // bottom left\n\nvec2 xy;\t// current graph coords\nfloat px;\t// pixel size in graph units, assumes uniform graph\nfloat aa;\t// aa falloff radius\nvec4 fcol;\t// current fragment color\n\nfloat lerpstep(float a, float b, float x)\n{\n    return (a == b) ? step(x, a) : clamp((x - a) / (b - a), 0.0, 1.0);\n}\n\nfloat sqrlength(vec2 v)\n{\n    return dot(v, v);\n}\n\nvoid mixColor(vec4 col, float alpha)\n{\n    fcol = vec4(mix(fcol.rgb, col.rgb, alpha * col.a), 1.0);\n}\n\nvoid drawGrid(float stepSize, float r, vec4 col)\n{\n\tvec2 grid = abs(vec2(-0.5) + fract((xy + vec2(stepSize) * 0.5) / stepSize));\n    float d = min(grid.x, grid.y) * stepSize;\n    mixColor(col, lerpstep(r + aa, r - aa, d));\n}\n\nvoid drawCircle(vec2 pos, float r, vec4 col)\n{\n    float d = length(pos - xy);\n    mixColor(col, lerpstep(r + aa, r - aa, d));\n}\n\n// Draws an explicit function of x with a known derivative.\n// Uses y distance to curve, breaks with great derivatives and discontinuities.\nvoid drawFunc(float y, float dy, float r, vec4 col)\n{\n    float d = abs(y - xy.y);\n    float yspan = sqrt(1.0 + dy * dy); // accurate, decent approximate: abs(dy) + 1.0 / (abs(dy) + 1.0)\n\tmixColor(col, lerpstep(yspan * (r + aa), yspan * (r - aa), d));\n}\n\n// Draws an explicit function of x, uses screen space derivative.\nvoid drawFunc(float y, float r, vec4 col)\n{\n    drawFunc(y, dFdx(y) / px, r, col);\n}\n\n// Draws an explicit function of x with a known inverse.\n// Uses distance to curve in both y and x.\nvoid drawFuncWithInverse(float y, float x, float r, vec4 col)\n{\n    vec2 d = abs(vec2(xy.x - x, xy.y - y));\n    mixColor(col, lerpstep(r + aa, r - aa, max(d.x, d.y) / length(d) * min(d.x, d.y)));\n}\n\nvoid setupGraph(vec2 center, vec2 size, vec2 fragcoord, vec3 resolution)\n{\n    graphSize = size * (resolution.xy / resolution.y);\n    graphCenter = center;\n    graphPos = graphCenter - 0.5 * graphSize;\n    xy = graphPos + fragcoord / resolution.xy * graphSize;\n\tpx = graphSize.y / resolution.y;\n    aa = 0.5 * px;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}