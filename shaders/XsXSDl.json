{
    "Shader": {
        "info": {
            "date": "1409764142",
            "description": "A light bulb...",
            "flags": 0,
            "hasliked": 0,
            "id": "XsXSDl",
            "likes": 35,
            "name": "Light Bulb",
            "published": 3,
            "tags": [
                "raymarching",
                "reflection",
                "refraction"
            ],
            "usePreview": 0,
            "username": "EvilRyu",
            "viewed": 3687
        },
        "renderpass": [
            {
                "code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define BULB 0.0\n#define BASE 1.0\n#define LINE 2.0\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\nvoid rotate_z(inout vec3 p, float a) { \n\tfloat c,s;vec3 q=p; \n \tc = cos(a); s = sin(a); \n \tp.x = c * q.x - s * q.y; \n \tp.y = s * q.x + c * q.y;\n} \n\nfloat sphere(vec3 p, float r) {\n    return length(p)-r;\n}\n\nfloat upperbulb(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz) ,p.y)) - vec2(h.x*max((1.0-p.y),0.0), h.y);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat cylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz) ,p.y)) - vec2(h.x, h.y);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec3 bulb(vec3 pos, float mate){\n    float d1 = sphere(pos, 0.4);\n    float d2 = upperbulb(vec3(pos.x, pos.y-0.5, pos.z), vec2(0.2, 0.3));\n    float d3 = cylinder(vec3(pos.x, pos.y-0.96, pos.z), vec2(0.16+0.011*sin(82.0*pos.y), 0.15));\n    float d4 = cylinder(vec3(pos.x, pos.y-10.0, pos.z), vec2(0.03, 10.0));\n    float dg = smin(d1, d2, 0.23);\n    float d = smin(dg, d3, 0.08);\n    if(d3 < dg) mate = BASE;\n    if(d4 < d) mate = LINE;\n    d = smin(d, d4, 0.2);\n    return vec3(d, mate, 1e10);\n}\n\nvec3 base(vec3 pos) {\n    float mate;\n    float d1 = cylinder(vec3(pos.x, pos.y-0.96, pos.z), vec2(0.16+0.011*sin(82.0*pos.y), 0.15));\n    float d2 = cylinder(vec3(pos.x, pos.y-11.0, pos.z), vec2(0.03, 10.0));\n    rotate_z(pos, 3.14159265*0.5);\n    float d3 = cylinder(vec3(pos.x+0.05+0.041*sin(50.0*pos.y), \n                             pos.y, pos.z+0.041*cos(50.0*pos.y)), \n                        vec2(0.005, 0.08));\n    float d = smin(d1, d2, 0.2);\n    if(d1 < d2) mate = BASE; else mate = LINE;\n    if(d > d3) {d = d3; mate = LINE;}\n    return vec3(d, mate, d3);\n}\n\n\nvec3 f(vec3 pos){\n    vec3 p1 = pos + vec3(0.0, 0.36, 0.5);\n    vec3 d1 = bulb(p1, BULB);\n    return d1;\n}\n\nvec3 f_partial(vec3 pos) {\n    vec3 p1 = pos + vec3(0.0, 0.36, 0.5);\n    vec3 d1 = base(p1);    \n    return d1;\n}\n\nvec3 calcnormal(vec3 p){ \n    vec3 e=vec3(0.001,0.0,0.0); \n    return normalize(vec3(f(p+e.xyy).x-f(p-e.xyy).x, \n                      f(p+e.yxy).x-f(p-e.yxy).x, \n                      f(p+e.yyx).x-f(p-e.yyx).x)); \n}\n\nvec3 lighting(vec3 n, vec3 ro, vec3 rd, vec3 p, vec4 mate, float type) {\n    vec3 l1dir = normalize(vec3(1.0));\n    vec3 l1col = vec3(1.0);\n    \n    float diff = max(0.0, dot(n, l1dir));\n    float back = max(0.0, dot(n, -l1dir));\n    float spec = max(0.0, pow(clamp(dot(l1dir, reflect(rd, n)), 0.0, 1.0), 32.0));\n    \n    vec3 lin;\n    \n    if(type < BASE) {\n        lin = 2.0 * spec * vec3(0.7, 0.9, 1.0);\n    } else {\n    \tlin = (diff + 0.5 * back) * mate.xyz + spec * vec3(1.0);\n    }\n    return lin;\n}\n\nvec3 intersect( in vec3 ro, in vec3 rd, bool partial)\n{\n  \tfloat t = 0.0;\n    vec3 ret = vec3(-1.0, -1.0, 1e5);\n    vec3 h = vec3(1.0);\n   \n    for( int i=0; i<64; i++ )\n   \t{\n      \tif( h.x<0.0005 || t>10.0 ) continue;\n        if(partial) h = f_partial(ro + rd*t);\n        else h = f(ro + rd*t);\n       \tret = vec3(t,h.y,min(ret.z,h.z));\n        t += h.x;\n    }\n    \n    if(t>10.0) ret = vec3(-1.0, -1.0, ret.z);\n    return ret;\n}\n\nvec4 material(float id, vec3 pos){\n    vec4 mate = vec4(1.0);\n    if(id < BULB+1.0) mate = vec4(0.98823, 0.6156, 0.6039, 0.8);\n    else if(id < BASE + 1.0) mate = vec4(0.7529, 0.7529, 0.7529, 0.5);\n    else if(id < LINE + 1.0) mate = vec4(0.02, 0.02, 0.02, 0.5);\n    return mate;\n}\n\nvec3 getbg(vec3 pos) {\n    return texture(iChannel0, pos).xyz;\n}\n\nvec3 getcolor(vec3 ro, vec3 rd, out vec3 pos, out vec4 mate, out vec3 n, \n              out float type, bool partial) {\n    vec3 res, col = vec3(0.0);\n\n    res = intersect(ro, rd, partial);\n   \n    type = res.y;\n    col += pow(max(1.0 - res.z,0.0), 21.0+20.0*sin(iTime))*\n           (vec3(1.7, 0.6470, 0.0));\n    if(res.x > 0.0){\n        pos = ro + rd * res.x;\n        mate = material(res.y, pos);\n        n = calcnormal(pos);\n        col += lighting(n, ro, rd, pos, mate, type);\n    }\n    else\n    {\n        col += getbg(rd);\n        type = 1e10;\n    }\n    return col;\n}\n\n\nvec3 tracer(vec2 fragCoord) {\n    float fov=3.0;\n    vec3 col = vec3(0.0);\n    vec2 p = 2.0*(fragCoord.xy)/iResolution.xy-1.0;\n    p.x*=iResolution.x/iResolution.y;\n\tvec2 m = iMouse.xy / iResolution.xy;\n\tif (iMouse.x == 0.0 && iMouse.y == 0.0) {\n\t\tm = vec2(iTime * 0.06 + 0.14,0.5);\t\n\t}\n\tm = -1.0 + 2.0 * m;\n\tm *= vec2(4.0,-1.5);\n\t\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n\tvec3 ro = vec3(cos(m.x)*cos(m.y)*fov, sin(m.y)*fov, sin(m.x)*cos(m.y)*fov);\n\n    vec3 cf = normalize(ta-ro); \n    vec3 cs = normalize(cross(cf,vec3(0.0,1.0,0.0))); \n    vec3 cu = normalize(cross(cs,cf)); \n    vec3 rd = normalize(p.x*cs + p.y*cu + fov*cf);\n\t\t\n    vec3 pos, n;\n    vec4 mate;\n    float dist, type;\n    col = getcolor(ro, rd, pos, mate, n, type, false);\n    if(type < BASE) {\n        vec3 refr = normalize(refract(rd, n, 0.8));\n        float reflection = 0.04 + 0.96 * pow(1.0 - dot(-rd, n), 5.0);\n        vec3 reflcol = getbg(normalize(reflect(rd, n)));\n        vec3 refrcol = getcolor(pos+refr*0.001, refr, pos, mate, n, type, true);\n\t\tcol = mix(refrcol*(1.0-reflection)+reflcol*0.3, col, 0.4); \n    }\n    return  col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec3 col = tracer(fragCoord);\n\t// post\n    col=pow(clamp(col,0.0,1.0),vec3(0.45)); \n    col=col*0.6+0.4*col*col*(3.0-2.0*col);\n    col=mix(col, vec3(dot(col, vec3(0.33))), -0.7); \n    col*=pow(20.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7); \n    fragColor = vec4( col, 1.0 );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}