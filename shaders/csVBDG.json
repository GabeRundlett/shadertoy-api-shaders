{
    "Shader": {
        "info": {
            "date": "1698625740",
            "description": "More fun with the Ulam spiral.\n\nhttps://en.wikipedia.org/wiki/Ulam_spiral",
            "flags": 0,
            "hasliked": 0,
            "id": "csVBDG",
            "likes": 33,
            "name": "Ulam Race (286 chars)",
            "published": 3,
            "tags": [
                "2d",
                "spiral",
                "codegolf",
                "ulam"
            ],
            "usePreview": 0,
            "username": "fenix",
            "viewed": 320
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  I wanted to experiment more with the Ulam spiral from my last shader, and this seemed\n//  like an interesting test/pattern. Indeed I found a couple more bugs, needing to adjust\n//  the bottom region in order to see the correct animation. \n//\n//  Credit is due here to @SnoopethDuckDuck for the the ulam number factorization, saving\n//  a few characters. I tried to be judicious but please feel free to golf further if I\n//  missed something!\n// ---------------------------------------------------------------------------------------\n\n// My attempt to fix OpenGL, also includes color change (hopefully an improvement): 286 chars\n//*\nvoid mainImage(out vec4 O, vec2 u)\n{\n    O.xyz = iResolution; \n\n    int I = int(u = 2.*floor((sqrt(iTime)*3.+1.)*(u+u-O.xy)/O.y)),\n        J = int(u.y),\n        D = J-I, S = I+J,\n        p = 1 + S/2 + int(iTime*30.)\n              - ( I > 0 && S == 0 ? J*J - D : // squares diagonal - bottom right\n                  I > abs(J)      ? I*I + D : // right region\n                  S > 0           ? J*J     : // top region\n                  D > 0           ? I*I     : // left region\n                                    J*J - D); // bottom region\n    \n    O = p < 0 ?\n            O-O :\n            p%40 > 0 ?\n                abs(cos(vec4(p/40) * vec4(5,8,7,0))) * fract(vec4(-p)/40.) : O;\n}\n/**/\n\n// From SnoopethDuckDuck: 287 chars\n/*\nvoid mainImage(out vec4 O, vec2 u)\n{\n    O.xyz = iResolution; \n\n    int I = int(u = 2.*floor((sqrt(iTime)*3.+1.)*(u+u-O.xy)/O.y)),\n        J = int(u.y),\n        D = J-I, S = I+J,\n        p = ( I > 0 && S == 0 ? J*J - D : // squares diagonal - bottom right\n              I > abs(J)      ? I*I + D : // right region\n              S > 0           ? J*J     : // top region\n              D > 0           ? I*I     : // left region\n                                J*J - D   // bottom region\n             ) - S/2 + 1 - int(iTime*30.) ; \n    \n    O = p < 1 ? p%40 < 0 ? abs(cos( vec4(1-p/40)*vec4(5,2,6,0) ))*fract(vec4(p)/40.)\n                         : O\n              : O-O;\n}\n/**/\n\n// From FabriceNeyret2: 294 chars, but the \"cars\" are in the wrong place for me\n/*\nvoid mainImage(out vec4 O, vec2 u)\n{\n    O.xyz = iResolution; \n    u = 2.* floor ( ( sqrt(iTime) * 3. + 1.) * (u + u - O.xy) / O.y  );\n\n    int I = int(u),\n        J = int(u.y),\n        D = J-I, S = (I+J)/2,\n        p = ( I > 0 && S == 0  ? J*J - D +S : // squares diagonal - bottom right\n              I > abs(J)       ? I*I + D :    // right region\n              S > 0            ? J*J     :    // top region\n              D > 0            ? I*I     :    // left region\n                                 J*J - D      // bottom region\n             ) - S + 1 - int(iTime*30.) ; \n    \n    O = p < 1 ? -p%40 > 0 ? abs(cos( vec4(1-p/40)*vec4(5,2,6,0) )) *fract(vec4(p)/40.)\n    //O = p < 1 ? -(p - 7)%40 > 0 ? abs(cos( vec4(1-p/40)*vec4(5,2,6,0) )) *fract(vec4(p)/40.) //this version works for me\n                          : O\n              : O-O;\n}\n/**/\n\n// From SnoopethDuckDuck: 309 chars\n/*\nvoid mainImage(out vec4 O, vec2 u)\n{\n    O.xyz = iResolution; \n    u = floor((sqrt(iTime) * 3. + 1.) * (u + u - O.xy) / O.y);\n\n    int I = int(u),\n        J = int(u.y),\n        K = 4*J*J,\n        L = 4*I*I,\n        m = I > 0 && I == -J ? K - 4*J :     // squares diagonal - bottom right\n            I > abs(J)       ? L - 3*I + J : // right region\n            J > abs(I)       ? K - I - J :   // top region\n            J > I            ? L - I - J :   // left region\n                               K + I - 3*J;  // bottom region\n\n    float p = float(m + 1 - int(iTime * 30.)) / 40.,\n          n = fract(p);\n    \n    O = p < .025 ? n > 0. ? abs(cos((p-n)*vec4(5, 2, 6, 0)))*n\n                          : O/O\n                 : O-O;\n}\n/**/\n\n// Original: 350 chars\n/*\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec2 R = iResolution.xy, \n         U = floor((sqrt(iTime) * 3. + 1.) * (u + u - R) / R.y);\n\n    int I = int(U.x),\n        J = int(U.y),\n        K = 4*J*J,\n        L = 4*I*I,\n        m = I > 0 && I == -J     ? K - 4*J + 1 :     // squares diagonal - bottom right\n            I > 0 && I >= abs(J) ? L - 3*I + J + 1 : // right region\n            J > 0 && J >= abs(I) ? K - I - J + 1 :   // top region\n            I < 0 && J >= I      ? L - I - J + 1 :   // left region\n                                   K + I - 3*J + 1;  // bottom region\n                                   \n    float p = float(m - int(iTime * 30.)) / 40.,\n          n = fract(p);\n    \n    O = p < .025 ?\n            n == 0. ?\n                vec4(1) :\n                abs(cos(floor(p) * vec4(5, 2, 6, 0))) * n :\n            vec4(0);\n}\n/**/\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}