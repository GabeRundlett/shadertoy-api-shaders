{
    "Shader": {
        "info": {
            "date": "1640506181",
            "description": "Game of Life simulation with various spaceships and collisions in book form. Forked to give more of a printed paper aesthetic",
            "flags": 32,
            "hasliked": 0,
            "id": "7tGXDz",
            "likes": 24,
            "name": "Fork Book of Life",
            "published": 3,
            "tags": [
                "simulation",
                "automata",
                "life",
                "gameoflife",
                "page",
                "book",
                "turning"
            ],
            "usePreview": 0,
            "username": "davidar",
            "viewed": 486
        },
        "renderpass": [
            {
                "code": "const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\nconst float PI = 3.1415926535897932384626433832795;\n\nfloat time()\n{\n    float mt = mod(iTime, 12.0);\n    return mt < 8.0 ? 0.0 : (mt - 8.0) / 4.0;\n}\n\nint pagesFlipped()\n{\n    return mod(iTime, 24.0) >= 12.0 ? 1 : 0;\n}\n\nfloat radius()\n{\n    return 0.982 - 2.0 * pow(time() - 0.3, 2.0);\n}\n\nvec2 circleBase()\n{\n    return vec2(4.0 - 4.0 * time(), 0.23);\n}\n\nvec2 circleCenter()\n{\n    return circleBase() + vec2(0.0, radius() - 0.002);\n}\n\nfloat arcAngle()\n{\n    return 2.0 * (PI - atan((8.0 - 4.0 * time()) / radius()));\n}\n\nfloat partArcAngle()\n{\n    float a = arcAngle();\n    float pa = 4.0 * time() / radius();\n    return pa < a ? pa : a;\n}\n\nvec2 lineEnd()\n{\n    return vec2(-4.0, 0.232);\n}\n\nvec2 lineStart()\n{\n    vec2 cc = circleCenter();\n    return cc + reflect(cc - circleBase() + vec2(0.0, 0.002), normalize(lineEnd() - cc));\n}\n\nfloat line2D(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat lineSDF(vec3 p)\n{\n    float pa = partArcAngle();\n    if (pa < arcAngle()) {\n        return MAX_DIST;\n    }\n    float len = 4.0 * time() - pa * radius();\n    vec2 l1 = lineStart();\n    vec2 ld = normalize(lineEnd() - l1);\n    float d2d = line2D(p.xy, l1, l1 + len * ld) - 0.002;\n    \n    return max(d2d, abs(p.z)-2.0);\n}\n\nfloat arc2D( in vec2 p, in vec2 sca, in vec2 scb, in float ra, float rb )\n{\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    if (scb.y*p.x>scb.x*p.y)\n    {\n        return sqrt((p.x - ra*scb.x)*(p.x - ra*scb.x) + (p.y - ra*scb.y)*(p.y - ra*scb.y)) - rb;\n    }\n    else\n    {\n        return sqrt(dot(p,p) + ra*ra - 2.0*ra*length(p)) - rb;\n    }\n    //float k = (scb.y*p.x>scb.x*p.y) ? dot(p,scb) - rb/280.0 : length(p);\n    //return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat arcSDF(vec3 p)\n{\n    float t = time();\n    float r = radius();\n    float hpa = partArcAngle() / 2.0;\n    if (hpa == 0.0) {\n        return MAX_DIST;\n    }\n    vec2 cp = circleBase() + vec2(0.0, r - 0.002);\n    float ma = 1.5 * PI - hpa;\n    float d2d = arc2D(p.xy - cp,\n        vec2(sin(ma), cos(ma)),\n        vec2(sin(hpa), cos(hpa)),\n        r, 0.002);\n    \n    return max(d2d, abs(p.z)-2.01);\n}\n\nfloat roundedCross2D( in vec2 p, in float h )\n{\n    float k = 0.5*(h+1.0/h);\n    p = abs(p);\n    return ( p.x<1.0 && p.y<p.x*(k-h)+h ) ? \n             k-sqrt(dot(p-vec2(1,k),p-vec2(1,k)))  :\n           sqrt(min(dot(p-vec2(0,h),p-vec2(0,h)),\n                    dot(p-vec2(1,0),p-vec2(1,0))));\n}\n\nfloat roundedCrossSDF(vec3 p)\n{\n    float d2d = roundedCross2D(p.xy - vec2(0.0, 0.23), 0.05);\n    \n    return max(d2d, abs(p.z)-2.1);\n}\n\nfloat trapezoid2D(vec2 p, float r1, float r2, float he)\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot(k2,k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot(ca,ca),dot(cb,cb)) );\n}\n\nfloat trapezoidSDF(vec3 p)\n{\n    float d2d = trapezoid2D(p.xy - vec2(0.0, 0.13), 4.2, 4.0, 0.1);\n    \n    return max(d2d, abs(p.z)-2.0);\n}\n\nfloat coverSDF(vec3 p)\n{\n    vec3 d = abs(p) - vec3(4.23, 0.03, 2.03);\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    float outsideDistance = length(max(d, 0.0));\n    return insideDistance + outsideDistance;\n}\n\nfloat sceneSDF(vec3 p) {\n    return min(min(min(\n        coverSDF(p),\n        max(trapezoidSDF(p),-roundedCrossSDF(p))),\n        arcSDF(p)),\n        lineSDF(p));\n}\n\n// ##################################################\n\nvec3 pageCoord(vec3 p)\n{\n    float t = time();\n    \n    if (p.y > 0.231)\n    {\n        if (arcSDF(p) < EPSILON)\n        {\n            vec2 rl = p.xy - circleCenter();\n            float ad = (PI / 2.0 + atan(rl.y, rl.x)) * radius();\n            if (length(rl) < radius())\n            {\n                return vec3(circleBase().x + ad, p.z, 0.0);\n            }\n            else\n            {\n                return vec3(-(circleBase().x + ad), p.z, 1.0);\n            }\n        }\n        else //if (lineSDF(p) < EPSILON)\n        {\n            float ld = distance(lineStart(), p.xy);\n            float ad = partArcAngle() * radius();\n            return vec3(-(circleBase().x + ad + ld), p.z, 1.0);\n        }\n    }\n    else\n    {\n        return vec3(p.x, p.z, p.x > 4.05 - 4.0 * t ? 1.0 : 0.0);\n    }\n}\n\nvec3 colFromPoint(vec3 p)\n{\n    if (p.y < 0.031)\n    {\n        return vec3(0,0,0.1);\n    }\n    else\n    {\n        vec3 pc = pageCoord(p);\n        vec2 uv = pc.xy / 2.;\n        vec3 fragColor = vec3(0.9, 0.85, 0.8);\n        \n        fragColor += 0.2 * FBM(300. * uv.xyy) - 0.05;\n        if (abs(pc.x) < 3.85 && abs(pc.y) < 1.85)\n        {\n            int sbuf = (int(pc.z) ^ pagesFlipped());\n            vec4 tc = texture(iChannel0, vec2(78.0 * float(sbuf) + (pc.x + 3.9) * 10.0, (pc.y + 1.9) * 10.0)/iResolution.xy);\n            float text = mix(0.6, 0.4, (tc.x + tc.y)/2.);\n            text += 0.2 * (FBM(20. * uv.xyy) - 0.5);\n            text += 0.1 * (FBM(50. * uv.xyy) - 0.5);\n            float ink = smoothstep(0.5, 0.49, text);\n            ink -= smoothstep(0.65, 0.75, FBM(25. * uv.xyy));\n            fragColor = mix(fragColor, vec3(0.8, 0.75, 0.7), smoothstep(0.55, 0.49, text));\n            fragColor = mix(fragColor, vec3(0.01, 0, 0), clamp(ink, 0., 1.));\n        }\n        return fragColor * clamp(p.y/0.18, 0., 1.5);\n    }\n}\n\nvec3 backColor(vec2 fc)\n{\n    return texture(iChannel3, vec3(fc/iResolution.xy - 0.5, -0.5)).rgb;\n}\n\n// ##################################################\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.7 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime/8.0),\n                          3.0,\n                          -1.5 + 3.0 * cos(iTime/8.0));\n    vec3 light1Intensity = vec3(0.5, 0.5, 0.5);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n// ##################################################\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(7.5 * sin(0.5 * sin(iTime/8.0)), 12.0 - 2.0 * abs(sin(iTime/8.0)), 7.5 * cos(0.5 * sin(iTime/8.0)));\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.23, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON)\n    {\n        fragColor = vec4(backColor(fragCoord), 1.0);\n    }\n    else\n    {\n        vec3 p = eye + dist * worldDir;\n\n        vec3 K_a = 0.3 * colFromPoint(p);\n        vec3 K_d = colFromPoint(p);\n        vec3 K_s = vec3(0);\n        float shininess = 1.0;\n\n        vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n\n        fragColor = vec4(pow(color, vec3(1./2.2)), 1.0);\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "cubemap",
                        "id": 27,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const int shipc = 17;\n\nconst ivec3[] shipsz = ivec3[](\nivec3(3,3,0),      //Glider\nivec3(5,4,9),      //Lightweight spaceship\nivec3(6,5,29),     //Middleweight spaceship\nivec3(7,5,59),     //Heavyweight spaceship\nivec3(9,9,94),     //Loafer\nivec3(12,8,175),   //Copperhead\nivec3(13,12,271),  //Canada goose\nivec3(12,10,427),  //Turtle\nivec3(10,15,547),  //Dart\nivec3(7,16,697),   //Edge-repair spaceship 1\nivec3(8,16,809),   //B29\nivec3(11,17,937),  //Brain\nivec3(10,9,1124),  //Coe ship\nivec3(11,16,1214), //Weekender\nivec3(9,22,1390),  //Wasp\nivec3(12,24,1588), //Swan\nivec3(21,11,1876)  //Non-monotonic spaceship 1\n);\n\nconst vec2[] shipsp = vec2[](\nvec2(0.25,0.25),\nvec2(0.5,0.0),\nvec2(0.5,0.0),\nvec2(0.5,0.0),\nvec2(1.0/7.0,0.0),\nvec2(0.1,0.0),\nvec2(0.25,0.25),\nvec2(1.0/3.0,0.0),\nvec2(1.0/3.0,0.0),\nvec2(1.0/3.0,0.0),\nvec2(0.25,0.25),\nvec2(1.0/3.0,0.0),\nvec2(0.5,0.0),\nvec2(2.0/7.0,0.0),\nvec2(1.0/3.0,0.0),\nvec2(0.25,0.25),\nvec2(0.25,0.0)\n);\n\nconst uint[] ships = uint[](\n0x47c83179u,0x11030be6u,0x210182ffu,0x4cc90501u,\n0x201c0101u,0x3000b01u,0x2313a0du,0xa0c31210u,\n0x20b000c0u,0x60611a5u,0x1a81180u,0x40002019u,\n0x8b813004u,0xf01db4u,0xc8708a48u,0x428428a4u,\n0x871b4d01u,0xc8050060u,0x40110049u,0xe5013e50u,\n0x49104006u,0x5008010u,0x50314188u,0x9010304u,\n0x38210183u,0x8206050u,0x5048404au,0x218b4800u,\n0x10600806u,0xc006c12u,0x71cf488eu,0xe4c217cu,\n0x5f0c2u,0x3908e3du,0x271f0480u,0x60fcc1d0u,\n0x4220200cu,0x781b018u,0x201b148u,0x20140480u,\n0x8c018030u,0x460900a0u,0x400a403u,0x6010c118u,\n0xac400e00u,0x80e14800u,0xae389080u,0x41801808u,\n0x1c040803u,0x1810008u,0x400c00u,0x80580900u,\n0x110220u,0x6008505u,0xb85a0400u,0x803800a0u,\n0x2800u,0x600e00a0u,0x3006016u,0x1d703u,\n0x10029e20u,0xc31709a0u,0x84005c2u,0x69e20c3cu,\n0x400a01d7u,0x58000u\n);\n\n\n\n\nuint shipBit(int n, int x, int y)\n{\n    int b = shipsz[n].z + x + y * shipsz[n].x;\n    return (ships[b / 32] >> (31 - (b % 32))) % 2u;\n}\n\nint Cell(int n, in ivec2 p)\n{\n    ivec2 r = ivec2(78, 38);\n    p = (p+r) % r;\n    vec4 c = texelFetch(iChannel0, p + (n%2 == 1 ? ivec2(78,0) : ivec2(0)), 0);\n    return ((n/2 == 0 ? c.x : c.y) > 0.5) ? 1 : 0;\n}\n\nfloat hash1( float n )\n{\n    return fract(sin(n + iDate.w)*138.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 px = ivec2( fragCoord );\n    float f = 0.0;\n    int e = 0;\n    \n    if (px.x < 2*78 && px.y < 38)\n    {\n        int b = px.x / 78;\n        if (iFrame % 3 == 0)\n        {\n            int k = Cell(b, px+ivec2(-1,-1)) + Cell(b, px+ivec2(0,-1)) + Cell(b, px+ivec2(1,-1))\n                  + Cell(b, px+ivec2(-1, 0))                           + Cell(b, px+ivec2(1, 0))\n                  + Cell(b, px+ivec2(-1, 1)) + Cell(b, px+ivec2(0, 1)) + Cell(b, px+ivec2(1, 1));\n\n            e = Cell(b, px);\n\n            f = ( ((k==2)&&(e==1)) || (k==3) ) ? 1.0 : 0.0;\n\n            if( iFrame == 0\n                || (b == 1 && mod(iTime, 24.0) < 2.0)\n                || (b == 0 && mod(iTime, 24.0) >= 12.0 && mod(iTime, 24.0) < 14.0))\n            {\n                if (iFrame != 0 && mod(iTime, 60.0) < 48.0)\n                {\n                    ivec2 gpx = px - ivec2(b==1?78:0,0);\n\n                    int si1 = int(floor((iDate.w + hash1(1.1)) * float(shipc))) % shipc;\n                    int si2 = int(floor((iDate.w + hash1(2.3)) * float(shipc))) % shipc;\n                    bool sr1 = int(floor((iDate.w + hash1(5.8)) * 2.0)) % 2 == 1;\n                    bool sr2 = int(floor((iDate.w + hash1(13.21)) * 2.0)) % 2 == 1;\n                    int ssm = (shipsz[si1].y / 2 + shipsz[si2].y / 2) / 2;\n                    int sy1 = int(floor((iDate.w + hash1(34.55)) * float(ssm * 2 + 1))) % (ssm * 2 + 1) - ssm;\n                    int sy2 = int(floor((iDate.w + hash1(89.144)) * float(ssm * 2 + 1))) % (ssm * 2 + 1) - ssm;\n\n                    float stps = floor(min(min(float(36 - shipsz[si1].x) / shipsp[si1].x,\n                        float(36 - shipsz[si2].x) / shipsp[si2].x), 140.0));\n\n                    ivec2 sp1 = ivec2(39 - shipsz[si1].x - int(shipsp[si1].x * stps),\n                        (38 + 19 + sy1 - shipsz[si1].y / 2 + (sr1?1:-1) * int(shipsp[si1].y * stps)) % 38);\n                    ivec2 sp2 = ivec2(38 + shipsz[si2].x + int(shipsp[si2].x * stps),\n                        (38 + 19 + sy2 - shipsz[si2].y / 2 + (sr2?1:-1) * int(shipsp[si2].y * stps)) % 38);\n\n                    if (gpx.x >= sp1.x && gpx.x < sp1.x + shipsz[si1].x\n                        && (sp1.y <= (sp1.y + shipsz[si1].y - 1) % 38 && (gpx.y >= sp1.y % 38 && gpx.y <= (sp1.y + shipsz[si1].y - 1) % 38)\n                        || (sp1.y > (sp1.y + shipsz[si1].y - 1) % 38 && (gpx.y >= sp1.y % 38 || gpx.y <= (sp1.y + shipsz[si1].y - 1) % 38))))\n                    {\n                        f = float(shipBit(si1, gpx.x - sp1.x, ((sr1 ? shipsz[si1].y + 37 - (gpx.y - sp1.y) : gpx.y - sp1.y + 38) % 38)));\n                    }\n                    else if (gpx.x <= sp2.x && gpx.x > sp2.x - shipsz[si2].x\n                        && (sp2.y <= (sp2.y + shipsz[si2].y - 1) % 38 && (gpx.y >= sp2.y % 38 && gpx.y <= (sp2.y + shipsz[si2].y - 1) % 38)\n                        || (sp2.y > (sp2.y + shipsz[si2].y - 1) % 38 && (gpx.y >= sp2.y % 38 || gpx.y <= (sp2.y + shipsz[si2].y - 1) % 38))))\n                    {\n                        f = float(shipBit(si2, sp2.x - gpx.x, ((sr2 ? shipsz[si2].y + 37 - (gpx.y - sp2.y) : gpx.y - sp2.y + 38) % 38)));\n                    }\n                    else\n                    {\n                        f = 0.0;\n                    }\n                }\n                else\n                {\n                    e = 0;\n                    f = step(0.7, hash1(fragCoord.x*13.0+hash1(fragCoord.y*71.1)));\n                }\n            }\n            else if( (b == 1 && mod(iTime, 24.0) < 11.0)\n                || (b == 0 && mod(iTime, 24.0) >= 12.0 && mod(iTime, 24.0) < 23.0))\n            {\n                e = 0;\n                f = float(Cell(b, px));\n            }\n        }\n        else\n        {\n            e = Cell(b + 2, px);\n            f = float(Cell(b, px));\n        }\n    }\n    \n\tfragColor = vec4(f, float(e), 0.0, 0.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n// https://www.shadertoy.com/view/4djSRW\n// Trying to find a Hash function that is the same on ALL systens\n// and doesn't rely on trigonometry functions that change accuracy \n// depending on GPU. \n// New one on the left, sine function on the right.\n// It appears to be the same speed, but I suppose that depends.\n\n// * Note. It still goes wrong eventually!\n// * Try full-screen paused to see details.\n\n\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n//#define HASHSCALE1 443.8975\n//#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n        vec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n        vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n        p3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n        vec3 p3 = fract(vec3(p) * HASHSCALE3);\n        p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n        vec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n        vec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n        vec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n        p4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\n// By David Hoskins, May 2014. @ https://www.shadertoy.com/view/4dsXWn\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat Noise(in vec3 p)\n{\n    vec3 i = floor(p);\n\tvec3 f = fract(p); \n\tf *= f * (3.0-2.0*f);\n\n    return mix(\n\t\tmix(mix(hash13(i + vec3(0.,0.,0.)), hash13(i + vec3(1.,0.,0.)),f.x),\n\t\t\tmix(hash13(i + vec3(0.,1.,0.)), hash13(i + vec3(1.,1.,0.)),f.x),\n\t\t\tf.y),\n\t\tmix(mix(hash13(i + vec3(0.,0.,1.)), hash13(i + vec3(1.,0.,1.)),f.x),\n\t\t\tmix(hash13(i + vec3(0.,1.,1.)), hash13(i + vec3(1.,1.,1.)),f.x),\n\t\t\tf.y),\n\t\tf.z);\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 ) * 1.7;\n\nfloat FBM( vec3 p )\n{\n    float f;\n\t\n\tf = 0.5000 * Noise(p); p = m*p;\n\tf += 0.2500 * Noise(p); p = m*p;\n\tf += 0.1250 * Noise(p); p = m*p;\n\tf += 0.0625   * Noise(p); p = m*p;\n\tf += 0.03125  * Noise(p); p = m*p;\n\tf += 0.015625 * Noise(p);\n    return f;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}