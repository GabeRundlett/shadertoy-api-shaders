{
    "Shader": {
        "info": {
            "date": "1630422297",
            "description": "Triangular grid to create some triangular Truchet tiles. leaving out the corners of the original grid leaves a hexagonal gap in the wires.\nSome kind of techy dynamic neural net thing.",
            "flags": 0,
            "hasliked": 0,
            "id": "7dtGRB",
            "likes": 11,
            "name": " HexTruchet",
            "published": 3,
            "tags": [
                "truchet",
                "hex",
                "tiles",
                "electronic",
                "beinner"
            ],
            "usePreview": 0,
            "username": "hjd3481",
            "viewed": 380
        },
        "renderpass": [
            {
                "code": "#define SIN_60 0.8660254\n\n/////////////////////////////////////////////////////////////\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n/////////////////////////////////////////////////////////////\nvec3 blob( vec2 uv, vec2 p )\n{\n    //un-skew the uv to get round dots\n    uv.x += uv.y * 0.5; //skew x to shift diagonal into triangles\n    uv.x /= SIN_60;\n    //also scale the position to get the origin to the correct place.\n    p.x /= SIN_60;\n        \n    float d = distance( uv, p );\n    \n    float r = 0.123;\n    float outer = smoothstep(r + 0.001, r - 0.001, d); //invert\n    \n    float rb = 0.066;\n    float inner = smoothstep(rb - 0.001, rb + 0.001, d); \n    \n    \n    float glow = smoothstep(rb+0.3, rb, d);  //invert\n    \n    return vec3(outer,inner, glow);\n}\n/////////////////////////////////////////////////////////////\nvec3 pulse( float falloff, vec3 rnd )\n{\n    //vec3 colA = vec3(0.4,0.01,0.0);\n    //vec3 colB = vec3(1.0,0.7,0.0);\n    \n    vec3 colA = vec3(0.1,0.01,0.5);\n    vec3 colB = vec3(0.4,0.45,1.0);\n    \n    float v = abs(sin(((iTime*(1.0+rnd.z))+rnd.x) * (rnd.y+0.1) * 5.0));\n    vec3 col = mix( colA, colB, vec3(v*v*v));\n    \n    return col * pow( falloff, mix(7.0,3.0,v));\n    \n}\n/////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.y; //y-fov\n    vec2 uv = fragCoord/iResolution.x; //x-fov\n\n     // Time varying pixel color\n    vec3 col = vec3(0);\n    \n    //offset zoom centre\n    uv -= 0.5;    \n     \n    //sacle (zoom)\n    float tilesY = mix(10.0, 14.0, sin(iTime*0.1)*0.5+0.5); //zoom in and out\n    uv *= tilesY;\n    \n    //pan the image \n    uv += vec2(0.45233 * iTime, sin(iTime*-0.1250235) * 1.41 );    \n   \n        \n    //squares -> euqlaterial triangles\n    uv.x *= SIN_60; //scale to get equalateral. mul by sin60 to get h == 1/2a (equalaterial triangle corner = 60deg)\n    uv.x -= uv.y * 0.5; //skew x to shift diagonal into triangles\n    \n    vec2 id = floor(uv.xy);\n    \n    vec2 idRightB = id + vec2(1.0, 0.0);\n\n    vec2 idBottomA = id + vec2(0.0, -1.0);   \n    \n    \n    \n    uv = fract(uv);\n    \n    //get diagonal of the skewed grid to get a triangular chequer pattern.\n    float sn = sign( (uv.x+uv.y)-1.0f );\n    \n    uv = mix(uv, vec2(1)-uv, sn*0.5+0.5); //flip UV in top right triangle\n        \n    //convert the grid-id to a triangle-id\n    \n    float daigonalHashOffset = 1.7133453;\n    \n    vec2 idSign = id + ((-sn)*daigonalHashOffset);\n    id += sn*daigonalHashOffset; //add some offset based on the chequer/sign \n    \n    idRightB += (-sn)*daigonalHashOffset; //flipping the sign gets us the upper-right triangle in the un-skewed cell.\n    idBottomA += (-sn)*daigonalHashOffset; \n    \n    vec3 rnd = hash32(id); //get a noise per triangle\n       \n    \n    float dots = 0.0;\n    \n    //Draw edges between triangles randomly\n    int numEdges = 0;\n    \n    vec3 rndEdges = fract(rnd + (floor(iTime)*vec3(0.2,0.1,0.3)) ); //step-tick the random values by adding a \n    \n    if(rndEdges.x < 0.5)\n    {\n        dots += smoothstep( 0.05, 0.04, abs(uv.x - 0.5));\n        ++numEdges;\n    }\n  \n    if(rndEdges.y < 0.5)\n    {\n        dots += smoothstep( 0.05, 0.04, abs(uv.y - 0.5));\n        ++numEdges;\n    }\n    \n    if( rndEdges.z < 0.5 && numEdges < 2 /*|| numEdges==0*/ )\n    {\n        dots += smoothstep( 0.05, 0.04, abs((uv.x+uv.y) - 0.5));\n    }\n    \n    //Draw rings around the edge-centres between trianges, between the solid edges above\n    vec3 dotA = blob(uv, vec2(0.5,0.0));\n    vec3 dotB = blob(uv, vec2(0.25,0.5));\n    vec3 dotC = blob(uv, vec2(0.75,0.5));\n    \n    float dotsMask = 1.0;\n    \n    dots += dotA.x;\n    dotsMask *= dotA.y;\n    \n    dots += dotB.x;\n    dotsMask *= dotB.y;\n    \n    dots += dotC.x;\n    dotsMask *= dotC.y;\n      \n    //cut out the ring centres\n        \n     \n    //draw backgound       \n    //random dark gray triangle bg\n    col = vec3((sin((iTime*rnd.z+rnd.x)*5.)+1.0)*0.05); \n    \n    //draw wires\n    //colour a bit like copper traces\n    vec3 wiresCol = vec3( 0.8,0.6,0.4 );\n    col = mix( col, wiresCol ,clamp(dots,0.0,1.0) );\n    \n    col *= dotsMask; //mask out holes to black again (ingore bg)\n    \n    //draw glow \n    \n    //get the same random values from neighbouring triangles so the blobs on the edges match up\n    vec3 rndA = hash32(idBottomA); \n    if(sn >= 0.0)\n    {\n        rndA = hash32(id);\n    }\n    \n    vec3 rndB = hash32(id); \n    if(sn >= 0.0)\n    {\n        rndB = hash32(idRightB);\n    }\n    \n    vec3 rndC = hash32(idSign);\n    if(sn >= 0.0)\n    {\n        rndC = hash32(id);\n    }\n\n    col += pulse(dotA.z,rndA); \n    col += pulse(dotB.z,rndB); \n    col += pulse(dotC.z,rndC); \n    \n        \n    //visualise random triangle\n    //col += rnd*0.25;\n    \n    //visualize uvs\n    //col.rg += uv * 0.5;\n    \n       \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}