{
    "Shader": {
        "info": {
            "date": "1664471840",
            "description": "path tracing experiment - tinted glass lamborghini",
            "flags": 32,
            "hasliked": 0,
            "id": "stVBD1",
            "likes": 48,
            "name": "tinted glass lamborghini",
            "published": 3,
            "tags": [
                "glass",
                "pathtracing",
                "refract",
                "car",
                "lamborghini"
            ],
            "usePreview": 1,
            "username": "flockaroo",
            "viewed": 842
        },
        "renderpass": [
            {
                "code": "// created by florian berger (flockaroo) - 2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// path traced lamborghini countach made of glass\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 c0=textureLod(iChannel0,fragCoord/iResolution.xy,0.);\n    vec4 c=textureLod(iChannel0,fragCoord/iResolution.xy,max(1.7-1.7*(1.-exp2(-c0.w/12.)),0.));\n    fragColor=c/c0.w;\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// path traced lamborghini countach made of glass\n\n//#define HOLLOW_CAR\n\n#ifndef SHADEROO\n#define iMouseData vec4(iMouse.xy,0,0)\n#define UNIFORM(tp,name,val) tp name = val; \n#else\n#define UNIFORM(tp,name,val) uniform tp name;\n#endif\n\n// new/old model of countach (basically just the tires differ for now)\n#define NEW_MODEL\n\n#define RandTex iChannel0\n\n////////////////////////\n//// quaternions, sdf's, helper funcs\n////////////////////////\n\n#define PI  3.14159265359\n#define PI2 6.28318530718\n#define PIH 1.57079632679\n\n#define ROTM(ang) mat2(cos(ang-vec2(0,PIH)),-sin(ang-vec2(0,PIH)))\n\nvec3 rotZ(float ang,vec3 v) { return vec3(ROTM(ang)*v.xy,v.z); }\n\nvec4 inverseQuat(vec4 q)\n{\n    //return vec4(-q.xyz,q.w)/length(q);\n    // if already normalized this is enough\n    return vec4(-q.xyz,q.w);\n}\n\nvec4 multQuat(vec4 a, vec4 b)\n{\n    return vec4(cross(a.xyz,b.xyz) + a.xyz*b.w + b.xyz*a.w, a.w*b.w - dot(a.xyz,b.xyz));\n}\n\nvec3 transformVecByQuat( vec3 v, vec4 q )\n{\n    return (v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w*v ));\n}\n\nvec4 angVec2Quat(vec3 ang)\n{\n    float lang=length(ang);\n    return vec4(ang/lang,1) * sin(lang*.5+vec4(0,0,0,PI2*.25));\n}\n\nvec4 axAng2Quat(vec3 ax, float ang)\n{\n    return vec4(normalize(ax),1)*sin(ang*.5+vec4(0,0,0,PI2*.25));\n}\n\n// iq's sdf primitives\nfloat distBox( vec3 p, vec3 halfSize)\n{\n    vec3 q = abs(p) - halfSize;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat distBoxR( vec3 p, vec3 halfSize, float r) { return distBox( p, halfSize-r ) - r ; }\n\nfloat distCyl( vec3 p, float r, float h )\n{\n  vec2 d = vec2( length(p.xy)-r, abs(p.z) - h*.5 );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat distCylR( vec3 p, float r, float h, float R )\n{\n  vec2 d = vec2( length(p.xy)-(r-R), abs(p.z) - (h*.5-R) );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0))-R;\n}\n\nfloat distTorus(vec3 p, float R, float r)\n{\n    return length(p-vec3(normalize(p.xy),0)*R)-r;\n}\n\nfloat dDirLine(vec3 p, vec3 c, vec3 dir, float l)\n{\n    p-=c;\n    dir=normalize(dir);\n    float dp=dot(p,dir);\n    //return length(p-dp*dir);\n    return max(max(length(p-dp*dir),-dp),dp-l);\n}\n\n// iq's exponantial smooth-min func\nfloat smin( float a, float b, float k )\n{\n    k=3./k;\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\n// iq's polynomial smooth-min func\nfloat smin_( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// flatness: // 0->sphere, 100-> nearly cylindric\nfloat distTire(vec3 p, float r, float w, float h, float flatness)\n{\n    float l=length(p.xy);\n    //p=abs(p);\n    float d=1000.;\n    // outer sphere\n    float rfl=r*(1.+flatness);\n    d=min(d,length(vec2(l+rfl-r,p.z))-rfl);\n    float rz=-(rfl-r)+sqrt(rfl*rfl-p.z*p.z);\n    //d=min(d,l-rz);\n    float ang = atan(p.x,p.y);\n    //p.z+=cos(ang*100.)*w*.01*smoothstep(.87*r,1.*r,l);\n    // main torus\n    d=max(d,length(vec2(l-r+h*.5,p.z))-w*.5);\n    //d=max(d,-l+r*.61);\n    float w_l=sqrt(w*w-h*h); // w_laufflaeche\n    float dz=.122*w_l;\n    float zfr=mod(p.z,dz);\n    float z=p.z-zfr+dz*.5;\n    // rillen\n    d=max(d,-length(vec2(l-rz,p.z-z))+dz*.2);\n    // rim radius\n    d=max(d,-(l-(r-h)));\n    return d;\n}\n\nfloat distRim(vec3 p, float r, float w, float sh)  // outer rim radius, rim width;\n{\n    vec3 p0=p;\n    p.z=abs(p.z);\n\n    float d=1000.;\n    float dmain=distCyl(p,r+sh-.005,w-.005)-.005;\n    d=min(d,dmain);\n\n    //d=max(d,-(distCyl(p-vec3(0,0,w*.5),r-sh*.5-.005,w*.05-.005)-.005));\n    float d2=length(p-vec3(0,0,+w*.03+r*1.5))-r*1.5;\n    d2=-smin_(-d2,-(distCyl(p-vec3(0,0,w*.5),r-sh*1.2-.005,w*1.-.005)-.005),.005);\n    d=-smin(-d,d2,.01);\n\n    float mang,ang;\n    float ang0 = atan(p.y,p.x);\n    float dang;\n#ifdef NEW_MODEL\n    dang=PI2/5.;\n#else\n    dang=PI2/15.;\n#endif\n    mang=mod(ang0,dang);\n    ang=ang0-mang+dang*.5;\n    // rim holes\n#ifdef NEW_MODEL\n    d=max(d,-distCyl(p-vec3(r*.53*cos(ang-vec2(0,PIH)),0.),.17*r,w*1.3));\n#else\n    d=max(d,-distBox(rotZ(-ang,p-vec3(r*.64*cos(ang-vec2(0,PIH)),0.)),vec3(.17*r,.17*r,w*1.3)*.52));\n#endif\n    dang=PI2/5.;\n    mang=mod(ang0+dang*.5,dang);\n    ang=ang0-mang+dang*.5;\n    // screw holes\n    d2=distCyl(p-vec3(r*.28*cos(ang-vec2(0,PIH)),w*.05),.016,w*.19);\n    d=max(d,-d2);\n    // screws\n    d=min(d, d2+.005);\n\n    // axle\n    d=min(d, distCyl(p,.03-.01,w*.25-.01)-.01);\n    return d;\n}\n\nfloat distWheelDim(vec3 p, float w_mm, float h_perc, float rimD_inch, float shoulder_mm, float flatness)\n{\n    float w=w_mm*.001;\n    float h=w*h_perc/100.;\n    float d=10000.,d2;\n    float rrim=rimD_inch*.5*.0254;\n    d2=distTire(p, rrim+h, w, h, flatness );\n    d=min(d,d2);\n    float rimw=sqrt(w*w-h*h)+shoulder_mm*.001;\n    d2=distRim(p, rrim, rimw, shoulder_mm*.001 );\n    d=min(d,d2);\n    return d;\n}\n\n\nbool intersectBox(vec3 p, vec3 dir, vec3 size)\n{\n    size*=.5*sign(dir);\n\n    vec3 vmin = (-size-p)/dir;\n    vec3 vmax = ( size-p)/dir;\n    \n    float tmin=vmin.x, tmax=vmax.x;\n    \n    if ((tmin > vmax.y) || (vmin.y > tmax)) return false; \n    tmin=max(tmin,vmin.y);\n    tmax=min(tmax,vmax.y);\n \n    if ((tmin > vmax.z) || (vmin.z > tmax)) return false; \n    tmin=max(tmin,vmin.z);\n    tmax=min(tmax,vmax.z);\n \n    return true; \n}\n\nUNIFORM(float,LightAzim,.2)\nUNIFORM(float,LightElev,.8)\n\nvec3 getLightDir() \n{\n    return normalize(vec3(-cos(LightAzim-vec2(0,1.57))*cos(LightElev),sin(LightElev)));\n    float t=iTime*1.+3.;\n    return normalize(vec3(cos(t*.3-vec2(0,1.57)),.5*sin(t*.7)));\n}\n\nvec4 getRand(vec2 coord)\n{\n    float t=iTime*0.;\n    vec4 c=vec4(0);\n    c+=texture(RandTex,coord+.003*t);\n    c+=texture(RandTex,coord/2.+.003*t)*2.;\n    c+=texture(RandTex,coord/4.+.003*t)*4.;\n    c+=texture(RandTex,coord/8.+.003*t)*8.;\n    return c/(1.+2.+4.+8.);\n}\n\n#define FloorZ -.66\n//#define HomePos vec3(0,0,-FloorZ*1.5)\n//#define CamDist0 18.\n\n// environment just a sky and some dark floor\nvec4 myenv(vec3 pos, vec3 dir, float period_)\n{\n#ifdef CUBEMAP    \n    return texture(iChannel1,dir.yzx);\n#endif\n    vec3 sun = normalize(getLightDir());\n    vec3 skyPos=pos+dir/abs(dir.z)*(120.-pos.z);\n    float cloudPat=(1.+.4*(getRand(skyPos.xy*.0002).x-.5));\n    vec3 colHor=vec3(.3,.4,.5)+.4;\n    float dirl=dot(dir,sun);\n    vec3 clouds=mix(vec3(1.)*(1.-2.*dirl),vec3(.8,1.,1.2),cloudPat);\n    vec3 colSky=mix(vec3(1.5,.75,0.)*3.,clouds,clamp(7.*dir.z,0.,1.));\n    //colSky=mix(colSky,vec3(1),cloudPat);\n    //colSky*=mix(1.,cloudPat,dir.z*5.);\n    vec3 colFloor=vec3(.3);\n    \n    vec3 col=mix(colSky,colFloor,1.-smoothstep(-.01,.01,dir.z));\n    col=mix(colHor,col,clamp(abs(dir.z*5.)-.1,0.,1.));\n    \n    col*=.9;\n    \n    //float sunang=acos(dot(dir,sun));\n    float sunang=atan(length(cross(dir,sun)),dot(dir,sun));\n    //col+=15.*(1.-smoothstep(.02,.03,sunang));\n    //col+=6.*exp(-sunang/.20);\n    col+=15.*clamp(2.*exp(-sunang/.042),0.,1.);\n    col+=2.*clamp(2.*exp(-sunang/.20),0.,1.);\n    \n    return vec4(col,1);\n}\n\n\n#define Res (iResolution.xy)\n\nvec3 BodySize=vec3(1.8,4.14,1.0);\n\nfloat distCar(vec3 p)\n{\n    vec3 p1,p2;\n    p.x=abs(p.x);\n    vec3 p0=p;\n    // torus\n    float d=10000.,d2;\n    p=p0-vec3(-p.y*.01,0,0);\n    vec3 p01=p;\n    float yfall=min((p.y+0.0)*abs(p.y+0.0),0.);\n    float yfall2=(p.y>.0?2.5:7.)*min((-abs(p.y)+1.2)*abs(-abs(p.y)+1.2),0.);\n    yfall=mix(yfall,yfall2,step(0.,-p.z));\n    //yfall=0.;\n    // ----------- 1 ------------------ side phase\n    d2=dot(p-.51*BodySize*vec3(.5,0,1.+.15*yfall)-(.2+.2*p.y)*max(0.,p.x-.92+p.y*.03)*vec3(0,0,1),normalize(vec3(.8,0,1.-.9*yfall)));\n    d=min(d,d2);\n    \n    // ----------- 3 ------------------\n    vec3 n=normalize(vec3(0,1,2.5));\n    float dpx=max(p.x*1.-1.,-.5);\n    float dpy=max(p.y-.78+.65*dpx,0.);\n    p2=p-.05*(1.-dpx*5.-dpx*dpx*10.)*(1.-exp(-dpy/.2)-dpy*.8);\n    //vec3 p2=p-.05*(1.-dpx*5.-dpx*dpx*10.)*min(1.-dpy*.2,1.);\n    // ----------- 2 ------------------ front cut\n    d2=dot(p2-.5*BodySize*vec3(0,1,1)-vec3(0,0,-.75),normalize(vec3(0,1,2.5)));\n    d=-smin_(-d,-d2,.06*exp(-(p.y-1.1)*(p.y-1.1)*3.));\n    //d=-smin(-d,-d2,.13*clamp(1.-(p.y-1.)*(p.y-1.)*1.2,0.,1.));\n    //d=-min(-d,-d2);\n    \n    // -------------------------------- main box ---- done after cuts to get sharp contour line on sides (no smin there)\n    d2=distBoxR(p+vec3(min(+.35*p.z*p.z,.1),0,0),\n                vec3(BodySize.xz,100).xzy*.5*vec3(exp(-(step(0.,p.y)*2.+2.)*p.y*p.y*p.y*p.y/500.),1,1.+.15*yfall),\n                max(.02,-1.*p.z-.07*p.y));\n    d=max(d,d2);\n    \n    // ----------- 4 ------------------ engine cover\n    p-=vec3(0,-1.65,.48);\n    vec3 bs=vec3(BodySize.x*.25*1.1-p.y*.17+p.z*.4,1,.3);\n    d2=distBoxR(p+vec3(0,0,-p.y*.14),bs,.02);\n    d=max(d,-d2);\n    float pry=clamp(floor(p.y/.22+.5),1.,4.)*.22;\n    d2=distBoxR(p+vec3(0,-pry,.01-p.y*.14),bs-vec3(.06,.92,0),.02);\n    d=max(d,-d2);\n\n    d2=abs(p0.y)-BodySize.y*.5;\n    d2+=.005*exp(-(length(vec2(max(d+.03,0.),d2)))/.0025);\n    d=-smin_(-d,-d2,.01);\n    \n    d2=distBox(p01-vec3(0,-1.1,.3),vec3(.47,.5,.5));\n    d+=.004*exp(-abs(d2)/.004);\n\n    // ------------------------------- side air hole\n    p=p0-vec3(.9,-.35,.04);\n    float sn=(.6-.4*sin(p.y*6.));\n    d2=distBox(p,vec3(.2*sn,.5,.23*sn)*.5-.02)-.02;\n    d=max(d,-d2);\n\n    // ------------------------------- upper air hole\n    p=p01-vec3(.67,-.627,.35);\n    d2=distBoxR(p,vec3(.32,.45,.25)*.5,.02-p.y*.15);\n    //d=max(d,-d2);\n    float d3=dot(p,normalize(vec3(.58,-.5,1.)));\n    float lw=.028+p.x*.028;\n    d3=(fract(d3/lw)-.5)*lw;\n    d3=abs(d3)-lw*.3;\n    d3=max(d2,-d3);\n    //d2=max(d2,-d3);\n    d3=max(d3,(d+.01-p.y*.045));\n    d=max(d,-d2);\n    d=min(d,d3);\n\n    // make hollow (6cm thick)\n    //d=abs(d+.03)-.03;\n    \n    // ------------------------------ door\n    //   --- front win border\n    d2=dot(p01-vec3(.475,.19,0),normalize(vec3(2.,-1,0)));\n    //   --- inner border\n    d2=min(d2, dot(p01-vec3(.475,.19,0),normalize(vec3(1,0,0))) );\n    d3 = d2;\n    p=p01-vec3(.475,-.4,0);\n    float s=step(0.,-(p0.z-.2))*((p0.z-.2)*(p0.z-.2)-.25*(p0.z-.2));\n    p.y=p.y-s;\n    //   --- front door border\n    float dr=dot(p,normalize(vec3(0,1,0)));\n    d2=min(d2, dr );\n    p.y=p.y+2.*s-1.35;\n    float d4=10000.;\n    //   --- rear door border\n    d4=min(d4, dot(p,normalize(vec3(0,-1,0))) );\n    //   --- floor door border\n    d4=min( d4, dot(p01-vec3(0,0,-.22),normalize(vec3(0,0,1))) );\n    //d+=.005*exp2(-length(vec2(d2-.0,d))/.0025);\n    d2=min(d2,d4);\n    d+=.003*exp2(-abs(d2)/.003);\n    \n    // ------------------------------ side window\n    d4=min(d4, dot(p01-vec3(.87,0,0),normalize(vec3(-1,0,0))) );\n    d2=min(d2,d4);\n    d3-=.22;\n    //d3=min(d3,min(d4,dr)-.04);\n    //d3-=.22;\n    d+=.005*exp2(-length(vec2(min(d2-.04,0.),d))/.0025);\n    if(d3<min(d4,dr)-.04)\n    //d+=.003*exp2(-d3*d3/.003/.003);\n    d=min(d,length(vec2(d3,d))-.003);\n\n    // ------------------------------- front lights\n    p=p0-vec3(.65,1.6,0);\n    d2=distBox(p,vec3(.32-step(0.,p.x)*.25*p.y,.16,.2)*.5);\n    //d=max(d,-sqrt(d*d+d2*d2)+.005);\n    d+=.003*exp(-abs(d2)/.003);\n    p=p0-vec3(.63,1.85,0);\n    d2=distBox(p,vec3(.29-step(0.,p.x)*.45*p.y,.16,.34)*.5);\n    d=max(d,-d2);\n\n    // ------------------------------ wheels\n    p1=BodySize*.5*vec3(1, .59,-.65);\n    p2=BodySize*.5*vec3(1,-.63,-.65);\n    d=max(d,-distCylR((p0-p1).yzx,.35,.85,.05));\n    //d=max(d,-distCylR((p0-p2).yzx,.35,.8,.05));\n    d=max(d,-distBoxR(rotZ(0.4,(p0-p2).yzx),vec3(.37,.28,.45)+.015,.2-(p0-p2).y*.2));\n    //d=min(d,distCylR((p0-p1-vec3(-.18,0,.04)).yzx,.31,.27,.08));\n    //d=min(d,distCylR((p0-p2-vec3(-.145,0,.04)).yzx,.31,.27,.08));\n    //return distWheelDim(pos,345.,35.,15.,10.,2.7);\n\n    //d=min(d,distWheelDim((p0-p2-vec3(-.13,0,.04)).yzx,215.,70.,14.,20.,1.));\n    //d=min(d,distWheelDim((p0-p1-vec3(-.16,0,.04)).yzx,205.,70.,14.,20.,1.));\n\n#ifndef NEW_MODEL    \n    float wheelDimRear [] = float[](215.,70.,14.,15.,1.);\n    float wheelDimFront[] = float[](205.,70.,14.,15.,1.);\n    vec3 pfront = p1+vec3(-.16,0,.04);\n    vec3 prear  = p2+vec3(-.13,0,.04);\n#else\n    float wheelDimRear [] = float[](345.,35.,15.,12.,2.7);\n    float wheelDimFront[] = float[](205.,50.,15.,12.,1.);\n    vec3 pfront = p1+vec3(-.15,0,.04);\n    vec3 prear  = p2+vec3(-.19,0,.04);\n#endif\n    \n    bool front = p0.y>0.;\n    p=p0-(front?pfront:prear);\n    d=min(d,\n        distWheelDim(p.yzx,\n                     front?wheelDimFront[0]:wheelDimRear[0],\n                     front?wheelDimFront[1]:wheelDimRear[1],\n                     front?wheelDimFront[2]:wheelDimRear[2],\n                     front?wheelDimFront[3]:wheelDimRear[3],\n                     front?wheelDimFront[4]:wheelDimRear[4])\n         );\n         \n    //d=min(d,distWheelDim((p0-p2-vec3(-.19,0,.04)).yzx,345.,35.,15.,10.,2.7));\n    //d=min(d,distWheelDim((p0-p1-vec3(-.15,0,.04)).yzx,205.,50.,15.,10.,1.));\n    //d=max(d,-(length(p0-p1*vec3(1,-1,1))-.37));\n    \n    //p=p0-vec3(p.y*.02,0,0);\n    \n    /*d=min(d,length(p0.xy-floor(p0.xy+.5))-.01);\n    d=min(d,length(p0.yz-floor(p0.yz+.5))-.01);\n    d=min(d,length(p0.zx-floor(p0.zx+.5))-.01);*/\n    \n    //d2=length(vec2(length(p.xy)-2.5,p.z))-.01;\n    //d=min(d,d2);\n    return d;\n}\n\nbool carEnabled;\n\nfloat distFloor(vec3 p)\n{\n    return abs(p.z+.8)-.2;\n}\n\nfloat dist(vec3 p)\n{\n    float d=10000.;\n    \n    // ----------------------------- car\n    if(carEnabled) {\n        d=min(d,distCar(p));\n        #ifdef HOLLOW_CAR\n        d=abs(d+.015)-.015;\n        #endif\n    }\n    //d=min(d,length(p-vec3(1.3,2.5,0))-.6);\n    \n    // ----------------------------- floor\n    d=min(d,distFloor(p));\n    return d;  \n}\n\nvec3 getGrad(vec3 p, float eps) \n{ \n    vec3 d=vec3(eps,0,0); \n    float d0=dist(p);\n    return vec3(dist(p+d.xyy)-d0,dist(p+d.yxy)-d0,dist(p+d.yyx)-d0)/eps; \n}\n\nfloat eps=.005;\n\nfloat march(inout vec3 pos, vec3 dir)\n{\n    for(int i=0;i<80;i++)\n    {\n        float d=dist(pos);\n        pos+=dir*abs(d*.35);\n        if (abs(d)<eps) return 1.;\n    }\n    return 0.;\n}\n\nvoid getTrafo(inout vec3 pos, inout vec3 dir, vec2 fc)\n{\n    vec2 sc=(fc-Res*.5)/Res.x*2.;\n    dir=normalize(vec3(0,0,-1.5)+vec3(sc,0));\n    pos=vec3(0,0,4.5*exp(-iMouseData.z/3000.));\n    float ph = iMouse.x/600.*10.;\n    float th = iMouse.y/400.*10.;\n    if (iMouse.x<1.) { ph=-iTime*.3*0.+2.; th=1.3; }\n    pos=vec3(pos.x,ROTM(th)*pos.yz);\n    dir=vec3(dir.x,ROTM(th)*dir.yz);\n    pos=vec3(ROTM(ph)*pos.xy,pos.z);\n    dir=vec3(ROTM(ph)*dir.xy,dir.z);\n}\n\nfloat fermi(float x) { return 1./(1.+exp(-x)); }\n\nfloat myrefract(inout vec3 dir, vec3 n, float N) // return fres (N supposed to be >1)\n{\n    float dn=dot(dir,n);\n    float fres=1.-abs(dot(dir,n));\n    fres*=fres*fres;\n    fres=.1+.9*fres;\n    if (dn>0.) { N=1./N; }\n    vec3 ds=dir-dn*n;\n    if(length(ds)*(1.-1./N)>1.) {  // total reflection\n        dir=reflect(dir,n); return 1.;\n    }\n    dir-=ds*(1.-1./N);\n    if (dn>0.) {\n        fres=1.-abs(dot(dir,n));\n        fres*=fres*fres;\n        fres=.2+.8*fres;\n    }\n    dir=normalize(dir);\n    return fres;\n}\n\nvec4 getRand(int i) { ivec2 r=textureSize(RandTex,0); return texelFetch(RandTex,ivec2(i,i/r.x)%r,0); }\n\nuniform float simpleRender;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 fragCoord0=fragCoord;\n    ivec2 randCoord=(ivec2(fragCoord0)+iFrame*ivec2(63,7))&0xFF;\n    vec4 r =texelFetch(RandTex,randCoord,0);\n    vec4 r0=r;\n    fragCoord.xy+=r.yz-.5;\n    fragColor = texelFetch(iChannel1,ivec2(fragCoord0),0);\n    vec3 pos,dir;\n    getTrafo(pos,dir,fragCoord);\n    pos.z-=.2;\n    pos-=dir*r.x*.5;\n    vec3 pos0=pos;\n    \n    const int MaxNumBounce=6;\n    vec3 col=vec3(1);\n    for(int i=0;i<MaxNumBounce;i++) {\n        vec3 posp=pos;\n        carEnabled=intersectBox(pos-vec3(0,0,-.05),dir,BodySize+vec3(0,0,.1));\n        float hit;\n        hit=march(pos,dir);\n        \n        if(dist(pos-dir*eps*2.)<0.) col*=exp(-length(pos-posp)/2.*vec3(.5,.65,1));\n\n        vec3 n=normalize(getGrad(pos,eps));\n        \n        if(simpleRender>.5) { fragColor=vec4((n*.5+.5)*100.,100); return; }\n        \n        if(hit<.5) {\n             if(dist(pos)>1.) break;\n             else continue;\n        }\n        \n        vec3 dirRefr=dir;\n        float fres=myrefract(dirRefr, n, 1.5);\n        \n        randCoord+=ivec2(0,i+1)+iFrame*ivec2(r0.w*10.,0);\n        vec4 r =texelFetch(RandTex,randCoord&0xFF,0);\n    \n        if (dist(pos)==distFloor(pos)) { fres=fres*.5; }\n        \n        if(r.x>fres){ //refract\n            dir=dirRefr;\n            if (dist(pos)==distFloor(pos))\n            {\n                dir=(r.yzw-.5); dir=dir-dot(dir,n)+abs(dot(dir,n))*n; dir=normalize(dir);\n                col*=mix(vec3(.8,.2,.2),vec3(.8),mod(floor(pos.x)+floor(pos.y),2.));\n            }\n        } else { //reflect\n            dir=reflect(dir,n);\n        }\n        \n        pos+=dir*eps*2.;\n    }\n    \n    col*=myenv(vec3(0),dir,1.).xyz;\n    \n    fragColor.xyz+=col;\n    fragColor.w++;\n    \n    if (iFrame<10 || iMouse.xy!=texelFetch(iChannel1,ivec2(0),0).xy || iMouseData.z!=texelFetch(iChannel1,ivec2(0),0).z) {\n        fragColor=vec4(col,1);\n    }\n    if (ivec2(fragCoord0)==ivec2(0)) {\n        fragColor.xy=iMouse.xy;\n        fragColor.z=iMouseData.z;\n    }\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}