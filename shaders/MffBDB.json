{
    "Shader": {
        "info": {
            "date": "1724273723",
            "description": "originals https://www.shadertoy.com/view/wlV3DV",
            "flags": 0,
            "hasliked": 0,
            "id": "MffBDB",
            "likes": 1,
            "name": "chaotic particles",
            "published": 3,
            "tags": [
                "particles"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 70
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265359\n#define PI2 (PI/2.)\n\n// tuneables\n#define SCALE 15.0\n#define ROUGH 0.25\n#define REFL 0.02\n#define LIGHTWRAP (iTime/100.5)*5.0 // was 5.0, this is clearly more fun\n#define NUM_LIGHTS 100\n#define SPHERE_RAD 1.5\n#define ORBIT_DIST 4.0\n#define ALBEDO vec3(0.25)\n#define HUE_SHIFT_RATE 0.25\n#define HUE_BAND_SCALE 0.25\n#define VERTICAL_ACCUM_SIN_SCALE 0.5\n#define LIGHT_INTENSITY 0.5\n\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n// GGX code borrowed from John Hable: https://gist.github.com/Kuranes/3065139b10f2d85074da\nfloat GGX(vec3 N, vec3 V, vec3 L, float roughness, float F0)\n{\n    float alpha = roughness*roughness;\n\n    vec3 H = normalize(V+L);\n\n    float dotNL = saturate(dot(N,L));\n\n    float dotLH = saturate(dot(L,H));\n    float dotNH = saturate(dot(N,H));\n\n    float F, D, vis;\n\n    // D\n    float alphaSqr = alpha*alpha;\n    float denom = dotNH * dotNH *(alphaSqr-1.0) + 1.0;\n    D = alphaSqr/(PI * denom * denom);\n\n    // F\n    float dotLH5 = pow(1.0-dotLH,5.);\n    F = F0 + (1.-F0)*(dotLH5);\n\n    // V\n    float k = alpha/2.;\n    float k2 = k*k;\n    float invK2 = 1.-k2;\n    vis = 1./(dotLH*dotLH*invK2 + k2);\n\n    float specular = dotNL * D * F * vis;\n    return specular;\n}\n\n// blatantly stolen from https://gist.github.com/eieio/4109795 (because rainbows)\nvec3 hsv_to_rgb(float h, float s, float v)\n{\n\tfloat c = v * s;\n\th = mod((h * 6.0), 6.0);\n\tfloat x = c * (1.0 - abs(mod(h, 2.0) - 1.0));\n\tvec3 color;\n\n\tif (0.0 <= h && h < 1.0) {\n\t\tcolor = vec3(c, x, 0.0);\n\t} else if (1.0 <= h && h < 2.0) {\n\t\tcolor = vec3(x, c, 0.0);\n\t} else if (2.0 <= h && h < 3.0) {\n\t\tcolor = vec3(0.0, c, x);\n\t} else if (3.0 <= h && h < 4.0) {\n\t\tcolor = vec3(0.0, x, c);\n\t} else if (4.0 <= h && h < 5.0) {\n\t\tcolor = vec3(x, 0.0, c);\n\t} else if (5.0 <= h && h < 6.0) {\n\t\tcolor = vec3(c, 0.0, x);\n\t} else {\n\t\tcolor = vec3(0.0, 0.0, 0.0);\n\t}\n\n\tcolor.rgb += v - c;\n\n\treturn color;\n}\n\nstruct PointLight\n{\n    vec3 pos;\n    vec3 color;\n};\n\nvec3 sphereNorm(vec2 ws, vec3 c, float r)\n{\n    vec3 pt = vec3((ws-c.xy)/r, 0);\n    pt.z = -cos(length(pt.xy)*PI2);\n    return normalize(pt);\n}\n\nbool sphereTest(vec2 ws, vec3 c, float r)\n{\n    vec3 pt = vec3(ws-c.xy, c.z);\n    return (dot(pt.xy, pt.xy) < r*r);\n}\n\nvec3 spherePos(vec2 ws, vec3 c, float r)\n{\n    vec3 pt = vec3(ws, c.z);\n    pt.z -= cos(length((ws-c.xy)/r)*PI2)*r;\n    return pt;\n}\n\n\nvec4 sphere(vec3 pt, vec3 N, PointLight pl, float rough, float refl)\n{   \n    vec3 V = vec3(0, 0, -1);\n    vec3 pToL = pl.pos - pt;\n    vec3 L = normalize(pToL);\n    \n    float decay = length(pToL);\n    decay = 1./decay*decay;\n    \n    float diffuse = dot(N,L) / PI;\n    float spec = GGX(N, V, L, rough, refl);\n            \n    if (dot(N,L) >= 0.)\n    {\n    \treturn vec4(decay * pl.color * (spec + diffuse * ALBEDO), pt.z);\n    }\n    else\n    {\n        return vec4(0, 0, 0, pt.z);\n    } \n}\n\nstruct LightAnim\n{\n    vec3 period;\n    vec3 shift;\n    vec3 orbit;\n    vec3 offset;\n};\n\n\nPointLight getLight(vec3 color, LightAnim anim)\n{\n    vec3 pos = sin(iTime * anim.period + anim.shift) * anim.orbit + anim.offset;\n    PointLight mypt = PointLight(pos, color);\n    return mypt;\n}\n\n\nvec4 renderLight(vec2 cs, PointLight pt)\n{\n    return vec4(pt.color * saturate(.1 - abs(length(cs-pt.pos.xy)))*100., pt.pos.z);\n}\n\nvoid drawWriteZ(vec4 result, inout vec4 fragColor)\n{\n    fragColor.xyz += result.xyz;\n    fragColor.w = result.w;\n}\n\nvoid drawTestZ(vec4 result, inout vec4 fragColor)\n{\n\tif (result.w <= fragColor.w || fragColor.w < 0.)\n    {\n        fragColor.xyz += result.xyz;\n    }\n}\n\nvoid planet(vec2 csUv, inout vec4 fragColor, LightAnim anim, bool isGeo, vec3 norm, vec3 pos, vec3 color)\n{\n    PointLight ptL = getLight(color, anim);\n    \n   \n    drawTestZ(renderLight(csUv, ptL), fragColor);\n}\n#define time iTime\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.xy;       \n    vec4 csUv = vec4(uv-vec2(0.5, 0.5), iMouse.xy/iResolution.xy);\n    csUv.x *= aspect;\n    csUv.xy *= SCALE;   \n    \n    float sphereRad = SPHERE_RAD;\n    float orbitDelta = ORBIT_DIST;\n    float orbit = sphereRad+orbitDelta;\n    float t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .07)) * 0.2;\n\tfloat si = sin(t);\n\tfloat co = cos(t);\n\tmat2 ma = mat2(co, si, -si, co);\n    // period, shift, orbit, offset\n    LightAnim anim = LightAnim(vec3(1, 0, 1), vec3(0, PI2, PI2), vec3(orbit, 0, -orbit), vec3(0, 0, 10));\n    \n    vec3 sphereCenter = vec3(0, 0, 10);\n    \n    vec3 sPos = spherePos(csUv.xy, sphereCenter, sphereRad);\n    vec3 sNorm = sphereNorm(csUv.xy, sphereCenter, sphereRad);\n    bool isSphere = sphereTest(csUv.xy, sphereCenter, sphereRad);\n    vec2 p = uv*7.;\n\t\n\tfloat time = time + length(p)*cos(time/4. + length(p+p)*cos(time/8. + length(p)*cos(time/16.)));\n\tvec3 color = vec3(0.0, 0.3, 0.5);\n\t\n\tfloat f = 0.0;\n\n\tfor(float i = 0.0; i < 20.0; i++){\n\t\t\n\t\tfloat s = sin(time + i - PI / 10.0) * 0.8;\n\t\tfloat c = cos(time + i + PI / 10.0) * 0.8;\n \n\t\tf += 0.011 / (abs(p.x + c) * abs(p.x + s));\n\t}\n    fragColor.xyzw = vec4(0, 0, 0, -1); // lazy \"depth\" value\n    \n    const int totalPlanets=NUM_LIGHTS;\n    anim.orbit.yx*=ma;\n    for (int i = 0; i < totalPlanets; ++i)\n    {\n        float rat = 1.-float(i)/float(totalPlanets);\n        \n        float hue = mod(HUE_SHIFT_RATE*-iTime+rat*HUE_BAND_SCALE,1.);\n        \n        vec3 color = hsv_to_rgb(hue, 1., LIGHT_INTENSITY*rat);\n        \n    \tplanet(csUv.xy*ma, fragColor, anim, isSphere, sNorm, sPos, color);\n        anim.shift.yx*=ma;\n        anim.orbit.y += sin(iTime)*VERTICAL_ACCUM_SIN_SCALE; // making things more interesting...\n        \n        anim.shift += LIGHTWRAP*2.*PI;\n    \t   \n    }\n    \n    fragColor.xyz = pow(fragColor.xyz, 1./vec3(2.2));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}