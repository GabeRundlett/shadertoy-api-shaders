{
    "Shader": {
        "info": {
            "date": "1578406371",
            "description": "It's day 19 of my month of coding daily",
            "flags": 40,
            "hasliked": 0,
            "id": "WlKGRW",
            "likes": 50,
            "name": "Day 19 - Virus",
            "published": 3,
            "tags": [
                "virus",
                "geodesic",
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 1643
        },
        "renderpass": [
            {
                "code": "// All geodesic reflection functions and are from tdhooper! shadertoy.com/view/4tG3zW\n// They are in common tab! \n\n// Buffer A is draw buffer\n// Buffer B is TAA from https://www.shadertoy.com/view/4dSBDt\n\n\n// These little guys really like fresnel :D\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    col *= 2.;\n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI acos(-1.)\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n    float t = dot(p, planeNormal)+offset;\n    if (t < 0.) {\n        p = p - (2.*t)*planeNormal;\n    }\n    return sign(t);\n}\n\nint Type=5;\nvec3 nc,pab,pbc,pca;\nvoid initIcosahedron() {\n    float cospin=cos(PI/float(Type)), scospin=sqrt(0.75-cospin*cospin);\n\tnc=vec3(-0.5,-cospin,scospin);\n\tpab=vec3(0.,0.,1.);\n\tpbc=vec3(scospin,0.,0.5);\n\tpca=vec3(0.,scospin,cospin);\n\tpbc=normalize(pbc);\tpca=normalize(pca);\n}\n\nvec3 bToC(vec3 A, vec3 B, vec3 C, vec3 barycentric) {\n\treturn barycentric.x * A + barycentric.y * B + barycentric.z * C;\n}\n\nvec3 pIcosahedron(inout vec3 p, int subdivisions) {\n    p = abs(p);\n\tpReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n\tpReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n\tpReflect(p, nc, 0.);\n    \n    if (subdivisions > 0) {\n\n        vec3 A = pbc;\n       \tvec3 C = reflect(A, normalize(cross(pab, pca)));\n        vec3 B = reflect(C, normalize(cross(pbc, pca)));\n       \n        vec3 n;\n\n\n        float d = .5;\n        \n        vec3 p1 = bToC(A, B, C, vec3(1.-d, .0, d));\n        vec3 p2 = bToC(A, B, C, vec3(1.-d, d, .0));\n        n = normalize(cross(p1, p2));\n        pReflect(p, n, 0.);\n        \n        if (subdivisions > 1) {\n\n            A = reflect(A, n);\n            B = p1;\n            C = p2;\n\n            p1 = bToC(A, B, C, vec3(.5, .0, .5));\n            p2 = bToC(A, B, C, vec3(.5, .5, .0));\n            n = normalize(cross(p1, p2));\n            pReflect(p, n, 0.);\n            \n\n\t\t\tp2 = bToC(A, B, C, vec3(.0, .5, .5));\n            p1 = bToC(A, B, C, vec3(.5, .5, .0));\n            n = normalize(cross(p1, p2));\n            pReflect(p, n, 0.);\n        }\n    }\n    \n    return pca;\n}\n\n\n\n// Inigo quilez\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\nfloat r31(vec3 u){\n\treturn fract(sin(u.y*415125.1 + u.x *12425.125125 + u.z*12525.215215215)*124115.125235);\n}\nfloat valueNoise(vec3 uv){\n    vec3 id = floor(uv);\n    vec3 fd = fract(uv);\n    fd = smoothstep(0.,1., fd);\n    \n    float ibl = r31(id + vec3(0,-1,0));\n    float ibr = r31(id + vec3(1,-1,0));\n    float itl = r31(id + vec3(0));\n    float itr = r31(id + vec3(1,0,0));\n    \n    \n    float jbl = r31(id + vec3(0,-1,1));\n    float jbr = r31(id + vec3(1,-1,1));\n    float jtl = r31(id + vec3(0,0, 1));\n    float jtr = r31(id + vec3(1,0, 1));\n    \n    \n    float ibot = mix(ibl, ibr, fd.x); \n    float iup = mix(itl, itr, fd.x);\n    float jbot = mix(jbl, jbr, fd.x);\n    float jup = mix(jtl, jtr, fd.x);\n    \n    float i = mix(ibot, iup, fd.y);\n    float j = mix(jbot, jup, fd.y);\n    \n    //return j;\n    return mix(i, j, fd.z); \n}\n\nfloat fbmOld(vec3 p){\n\n    float n = 0.;\n    p *= 0.1;\n    \n    float f = valueNoise(p); \n    \n    float q = valueNoise(p*1.4);\n    \n    float j = valueNoise(p*3.);\n    float l = valueNoise(p*6.);\n    \n    float z = valueNoise(p*f*q*4.);\n    float i = valueNoise(p*f*q*4.5);\n   \n    n += f*0.9 + q*1. + z*0.36 + j*0.4 + l * 0.2;\n    //n += f*1.8 + q*0.5 + z*0.5 + i*0.4;\n    \n\treturn n;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define PI acos(-1.)\n\n\n#define mx (20.*iMouse.x/iResolution.y)\n#define iTime (iTime + mx )\n\n\n\n// Noise (from iq)\nfloat noise (in vec3 p) {\n\tvec3 f = fract (p);\n\tp = floor (p);\n\tf = f * f * (3.0 - 2.0 * f);\n\tf.xy += p.xy + p.z * vec2 (37.0, 17.0);\n\tf.xy = texture (iChannel0, (f.xy + 0.5) / 256.0, -256.0).yx;\n\treturn mix (f.x, f.y, f.z);\n}\n\nfloat fbm (in vec3 p) {\n    \n    float n = 0.; \n    p *= 3.;\n    \n    float f = noise(p); \n    \n    float q = noise(p*1.4);\n    \n    float j = noise(p*3.);\n    float l = noise(p*6.);\n    \n    float z = noise(p*f*q*4.);\n    float i = noise(p*f*q*4.5);\n   \n    n += f*0.9 + q*1. + z*0.36 + j*0.4 + l * 0.2;\n    \n    return n;\n}\n\n\n\n\n#define dmin(a, b) a.x < b.x ? a : b\n\n#define tendrilLength 3.5\n#define orbSize 0.13\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x) , cos(x))\n#define pmod(p, x) mod(p, x) - x*0.5\nvec2 map(vec3 p){\n    \n    #define modDistX 10.\n    #define modDistZ 10.\n    #define modDistY (modDistZ*1.5)\n    vec3 id = vec3(\n    \tfloor(p.x / modDistX ),\n    \tfloor(p.z / modDistZ ),\n    \tfloor(p.y / modDistY ) // wat\n    );    \n\n    float r = fract(sin(id.x*2123.52421 + id.y*214.512 + id.z)*24.123);    \n    \n    \n    p.y += id.x*(2.*r - 1.)*8.;\n    \n    \n    p.z += sin(iTime*r*0.4)*0.2;\n    p.x += sin(iTime*r*2.4)*0.2;\n    p.y += sin(iTime*r*0.4)*2.4;\n    \n    p.x = pmod(p.x, modDistX);\n    \n    p.z = pmod(p.z, modDistZ);\n    p.y = pmod(p.y, modDistY);\n    \n\n    \n    \n\tvec2 d = vec2(10e5);\n    if (id.xy == vec2(0.)){\n        p.xy *= rot(0.2 + iTime*(1. - 2.*r)*0.1);\n        p.xz *= rot(0.2 + iTime*(1. - 2.*fract(r*2214.124))*0.02);\n        \n    } else {\n        p.xy *= rot(0.2 + iTime*(1. - 2.*r)*0.2);\n        p.xz *= rot(0.2 + iTime*(1. - 2.*fract(r*2214.124))*0.2);\n    }\n    //p.xy *= rot(0.2 + iTime*r*0.02);\n    \n    vec3 z = p;\n    \n    //p.z += id.x*modDistX*0.5;\n    \n    \n   \tvec3 n = pIcosahedron(p, int(1));\n\n    //d = dmin(d, vec2(dot(p - 1., n),1.));\n    \n\t\n    float dSphere = min(d.x, length(p) - 1.4);\n    d.x = dSphere;\n    \n    d.x = opSmoothUnion(d.x,max(length(p.xy) - 0.01, (dot(p, n) - tendrilLength)), 0.5);\n    \n    \n    p.z -= tendrilLength + orbSize*2.;\n    d.x = opSmoothUnion(d.x, length(p) - orbSize, 0.1);\n    \n    \n    \n    if (d.x == dSphere){\n    \td.y = 4.;\n    }\n    \n    d.x -= fbm(z)*0.06;\n    \n    \n    \n    d.x *= 0.5;\n    //d = dmin(d, vec2(length(p) - 1.,1.));\n    \n    \n    \n\treturn d;\n}\n\n#define modTime sin(iTime*0.8 +  sin(iTime*0.6))\n#define fov (1. + modTime*0.04)\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 d = normalize(lookAt - ro);\n\tvec3 right = normalize(cross(vec3(0,1,0),d ));\n\tvec3 up = normalize(cross(d,right ));\n    return d + right*uv.x*fov + up*uv.y*fov;\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.001,0.);\n    return normalize(\n                    -vec3(\n                    \tmap(p - t.xyy).x - map(p + t.xyy).x,\n                    \tmap(p - t.yxy).x - map(p + t.yxy).x,\n                    \tmap(p - t.yyx).x - map(p + t.yyx).x\n                    )\n                    );\n}\n\n    #define zoom 10.\nvec3 render(vec3 ro, vec3 lookAt, vec2 uv, inout float t) {\n    vec3 col = vec3(0);\n    vec3 rd = getRd(ro, lookAt, uv);\n\n    vec3 p = ro; float tL = 0.;\n    rd.xz *= rot(0.1 - modTime*0.04);\n    rd.yz *= rot(sin(iTime*0.6)*0.1);\n    \n    for (int i = 0; i < 100; i ++){\n    \tvec2 d = map(p);\n        \n        if(d.x < 0.002){\n        \t\n            vec3 n = getNormal(p);\n            \n            vec3 lDir = normalize(vec3(1));\n            \n        \tvec3 h = normalize(lDir - rd);\n            \n            float diff = max(dot(n, lDir), 0.);\n            float spec = max(dot(n, h), 0.);\n            float fres = pow(1. - max(dot(n, -rd), 0.), 3.);\n            float fresB = pow(max(dot(n, -rd), 0.), 3.);\n            float fresC = pow(max(dot(n, -rd), 0.)*1., 20.);\n            \n            //col += n*0.5 + 0.5;\n            //col += mix(fresB*vec3(0,0.2,.9)*1., vec3(0.02,0.2,0.5), max(pow(fresC, 0.34) +0.15, 0.));\n            col += fresB*vec3(0,0.34,.9)*1.;\n            \n            if (d.y==4.) {\n            \tcol += fres*vec3(1.,1.,1)*2.;\n            \tcol -= pow(fresC, 0.5)*vec3(0,0.34,.9)*1.;\n            }else {\n             \tcol += vec3(1)*pow(1. - max(dot(n, -rd), 0.), 2.);\n            \tcol -= pow(fresC, 0.5)*vec3(0,0.34,.9)*1.;\n            }\n            break;\n        }\n        if (tL > 40.) {\n        \tbreak;\n        }\n    \n        \n        tL += d.x;\n        p = ro + rd*tL;\n    }\n    \n    t = tL;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initIcosahedron();\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    \n    vec3 lookAt = vec3(0. + modDistX*0.5,0. + modTime*0.5 - modDistY*0.5,0. + modDistZ*0.5);\n    vec3 ro = lookAt + vec3(sin(0.2 + sin(iTime*0.2)*0.15)*zoom, 0., cos(0.4)*zoom);\n    ro.x += 3.4;\n    float t = 0.;\n    \n    \n    \n    \n    vec2 st =  0.5/iResolution.xy;\n    col += render(ro, lookAt, uv, t);\n    //col += render(ro, lookAt, uv + st, t);\n\n    \n    //col /= 2.;\n    \n    //col *= 1.;\n    \n    col = clamp(col, 0., 1.);\n    col = mix(col, vec3(0.,0.05,0.8)*0.01, smoothstep(0.,1.,t*0.04));\n    \n    col *= 1. - pow(length(uv)*0.86 + 0.1, 2.)*1.;\n    col = pow(col, vec3(0.45));\n    \n    \n    \n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "ivec2 offsets[8] = ivec2[8]( ivec2(-1,-1), ivec2(-1, 1), \n\tivec2(1, -1), ivec2(1, 1), \n\tivec2(1, 0), ivec2(0, -1), \n\tivec2(0, 1), ivec2(-1, 0));\n\nvec3 RGBToYCoCg( vec3 RGB )\n{\n\tfloat Y = dot(RGB, vec3(  1, 2,  1 )) * 0.25;\n\tfloat Co= dot(RGB, vec3(  2, 0, -2 )) * 0.25 + ( 0.5 * 256.0/255.0 );\n\tfloat Cg= dot(RGB, vec3( -1, 2, -1 )) * 0.25 + ( 0.5 * 256.0/255.0 );\n\treturn vec3(Y, Co, Cg);\n}\n\nvec3 YCoCgToRGB( vec3 YCoCg )\n{\n\tfloat Y= YCoCg.x;\n\tfloat Co= YCoCg.y - ( 0.5 * 256.0 / 255.0 );\n\tfloat Cg= YCoCg.z - ( 0.5 * 256.0 / 255.0 );\n\tfloat R= Y + Co-Cg;\n\tfloat G= Y + Cg;\n\tfloat B= Y - Co-Cg;\n\treturn vec3(R,G,B);\n}\n\n//#define NO_AA\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;    \n    vec3 new = RGBToYCoCg(textureLod(iChannel0, q, 0.0).xyz);\n    vec3 history = RGBToYCoCg(textureLod(iChannel1, q, 0.0).xyz);\n    \n    vec3 colorAvg = new;\n    vec3 colorVar = new*new;\n    \n    // Marco Salvi's Implementation (by Chris Wyman)\n    for(int i = 0; i < 8; i++)\n    {\n        vec3 fetch = RGBToYCoCg(texelFetch(iChannel0, ivec2(fragCoord.xy)+offsets[i], 0).xyz);\n        colorAvg += fetch;\n        colorVar += fetch*fetch;\n    }\n    colorAvg /= 9.0;\n    colorVar /= 9.0;\n    float gColorBoxSigma = 0.75;\n\tvec3 sigma = sqrt(max(vec3(0.0), colorVar - colorAvg*colorAvg));\n\tvec3 colorMin = colorAvg - gColorBoxSigma * sigma;\n\tvec3 colorMax = colorAvg + gColorBoxSigma * sigma;\n    \n    history = clamp(history, colorMin, colorMax);\n  \n\tfragColor = vec4(YCoCgToRGB(mix(new, history, 0.95)), 1.0);\n#ifdef NO_AA\n    fragColor = vec4(YCoCgToRGB(new), 1.0);\n#endif\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define pi acos(-1.)\n#define tau (2.*pi)\n\n#define tempo 170.\n#define hbeat ((60./tempo)/1.)\n#define qnote (hbeat/2.)\n#define beat  (hbeat*2.)\n#define qbeat  (beat/4.)\n#define measure  (hbeat*2.)\n\n\nfloat note(float note, float octave){\n\treturn 27.5*pow(2., ((octave*12.) + note )/12.);\n}\nfloat noise( vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.1);\n}\nfloat random(float st){\n\treturn fract(sin(st*42151.5524124));\n}\nfloat rand(float t) {\n\treturn fract(sin(t*3211251.325235325));\n}\n\n\nvec2 makeBells(float t, float freq, float scale) {\n    vec2 s = vec2(0);\n    float r = random( mod(floor(t/ hbeat), 26.) + 4.);\n    float rC = r;\n    float rB = random( mod(floor((t + 4.)/ hbeat) + 4., 26.));\n        float env = exp(-t*15.);\n        \n        float iters = 2.;\n    \tfor (float i = 0.; i < iters; i++) {\n       \t\t//s.x += sin(freq *tau*t) * env * scale ;\n            s.x += sin(freq *tau*t) * scale * (2. + sin(t));\n            \n            freq *= 3.06;\n        }\n\t\t//s.x /= iters;\n    \t//s.x += sin( (random(t)) *tau*t) * env*2. ;\n        \n        //s.x = clamp(s.x*1.6,-1., 1.);\n\n        \n        s.y = s.x;\n    \n    return s;\n}\n\nvec2 reverbChannelB(float t) {\n\tvec2 s = vec2(0);\n    \n    vec2 reverb = vec2(0);\n    float st = 0.001; float iters = 100.;\n    for (float i = 0.; i < iters; i++) {\n    \treverb += ((makeBells(t - i*st + random(i )*0.4, note(9.,1.), 0.4 ))/iters) *(1. - i/iters) ;\n    \treverb += ((makeBells(t - i*st + sin(t*0.2)*0.01 + random(i )*0.4, note(16.,1.), 0.7))/iters) *(1. - i/iters) ;\n    \treverb += ((makeBells(t - i*st - sin(t*0.3)*0.01 + random(i )*0.4, note(19.,1.), 0.7))/iters) *(1. - i/iters) ;\n    \treverb += ((makeBells(t - i*st + 0.02 - sin(t*0.4)*0.01 + random(i )*0.4, note(12.,2.), 0.7))/iters) *(1. - i/iters) ;\n    \treverb += ((makeBells(t - i*st - 0.01 + sin(t*0.5 + sin(0.2*t*note(16.,2.)*tau*0.5 + sin(0.3*t*note(16. + 7.,1.)))*0.13*sin(t*0.8))*0.01 + random(i )*0.4, note(16.,2.), 0.3))/iters) *(1. - i/iters) ;\n    }\n\n    s += ((makeBells(t , note(9.,1.), 0.4 ))/iters)*0.001;\n    s += ((makeBells(t  , note(12.,2.), 0.1))/iters)*0.001;\n    s += ((makeBells(t  , note(18.,2.), 0.5))/iters)*0.001;\n    \n    //s += makeBells(t, note(9.,1.))*0.01;\n    s += reverb*5.5;\n    //s *= 2.;\n\treturn s;\n}\n\nvec2 droneChannel(float t){\n\tvec2 s = vec2(0);\n\tfloat iters = 20.;\n    \n    \n    for(float i = 0.; i < iters; i++){\n        float r = random(i);\n        float rB = fract(r*124.52412);\n    \ts += reverbChannelB(t + r*0.1 + 0.02*r + sin(0.6*t*(1. - rB*0.05))*(0. + r*0.01));\n    }\n    s += reverbChannelB(t)*0.5;\n    \n    s /= iters;\n    \n    \n    \n    return s;\n}\n\nvec2 mainSound( in int samp, float time )\n{\n    vec2 s = vec2(0);\n    \n    \n    \n    s += droneChannel(time + random(time)*0.0001*sin(time))*0.5;\n    \n    s *= smoothstep(0.,1.,time*0.5);\n    return s;\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}