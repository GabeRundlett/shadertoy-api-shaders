{
    "Shader": {
        "info": {
            "date": "1466341313",
            "description": "A simple voxel flythrough. Based on fb39ca4's, IQ's, Reinder's, etc, voxel framework.",
            "flags": 0,
            "hasliked": 0,
            "id": "MdGXWG",
            "likes": 52,
            "name": "Voxel Flythrough",
            "published": 3,
            "tags": [
                "raymarching",
                "voxel",
                "flythrough"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 2731
        },
        "renderpass": [
            {
                "code": "/*\n\n\tVoxel Flythrough\n\t----------------\n\n\tThe cliche voxel flythrough - Everyone should do at least one. :) I've been meaning to put one \n\tof these up for ages, ever since admiring Reinder's Minecraft Blocks port. Other inspiration \n\tcame from IQ's Voxel Edges and just about every flythrough voxel scene in every demo. :)\n\n\tI had originally intended to make it look like some kind of alien space port, but then realized\n\tthat would require actual work, so went with the abstract, naive version. :) I also wanted the\n\tto keep the code readable enough for anyone who might want to try one of these themselves.\n\n\tThe voxel setup is reasonably straight forward, and so is the distance function, which is\n\tdescribed below.\n\n\tMainly based on the following:\n\n\tVoxel Ambient Occlusion - fb39ca4\n    https://www.shadertoy.com/view/ldl3DS\n\n\tMinecraft Blocks - Reinder\n    https://www.shadertoy.com/view/MdlGz4\n    Based on: http://jsfiddle.net/uzMPU/ - Markus Persson\n\n\tVoxel Edges - IQ\n\thttps://www.shadertoy.com/view/4dfGzs\n\n\tVoxel Corridor - Shane\n\thttps://www.shadertoy.com/view/MdVSDh\n\n*/\n\n#define FAR 60.\n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // n = max(abs(n), 0.001);// etc.\n    n /= (n.x + n.y + n.z ); \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    // Rough sRGB to RGB conversion to account for the gamma correction we're doing before presenting\n    // the final value to the screen... or something like that.... but filtering is done in sRGB... \n    // I think? Sigh! Why does it always have to be so complicated? :)\n    return p*p; \n}\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){    \n   \n    //return vec2(0); // Straight.\n    float a = sin(z * 0.11);\n    float b = cos(z * 0.14);\n    return vec2(a*4. -b*1.5, b*1.7 + a*1.5); \n    //return vec2(a*4. -b*1.5, 0.); // Just X.\n    //return vec2(0, b*1.7 + a*1.5); // Just Y.\n}\n\n\n\n\n// Compact, self-contained version of IQ's 3D value noise function.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// Random cloud-shaped structures. Since the distance field is voxelized, you don't need real clouds, just\n// something that approximates it, so some pseudo-random 3D sinusoidal shapes will do. The sinudoidal \n// function has been arranged in such a way as to provide an open area for the camera to fly through.\n// In turn, the open area is wrapped around a path. By the way, if you were doing this with something like \n// 3d value noise, you could could carve a path through it with a cylinder and no one would be the wiser.\nfloat map(vec3 p){\n    \n    p.xy -= path(p.z); // Perturb an object around a path.\n   \n\tp = cos(p*.1575 + sin(p.zxy*.4375)); // 3D sinusoidal mutation.\n    \n    // Spherize. The result is some mutated, spherical blob-like shapes.\n    float n = dot(p, p); \n    \n    p = sin(p*3. + cos(p.yzx*3.)); // Finer bumps. Subtle, and almost not necessary with voxelization.\n    \n    return n - p.x*p.y*p.z*.35 - .9; // Combine, and we're done.\n    \n}\n\n// The brick groove pattern. Thrown together too quickly.\n// Needs some tidy up, but it's quick enough for now.\n//\nconst float w2h = 1.; // Width to height ratio.\nconst float mortW = .05; // Morter width.\n\nfloat brickShade(vec2 p){\n    \n    p = fract(p);\n    return pow(16.*p.x*p.y*(1.-p.x)*(1.-p.y), 0.25);\n    \n}\n\nfloat brickMorter(vec2 p){\n    \n    p.x -= .5;\n    \n    p = abs(fract(p + vec2(0, .5)) - .5)*2.;\n    \n    // Smooth grooves. Better for bump mapping.\n    return smoothstep(0., mortW, p.x)*smoothstep(0., mortW*w2h, p.y);\n    \n}\n\nfloat brick(vec2 p){\n    \n\tp = fract(p*vec2(0.5/w2h, 0.5))*2.;\n\n    return brickMorter(p)*(brickShade(p)*.5 + .5);\n}\n\n\n// Surface bump function. Cheap, but with decent visual impact.\nfloat bumpSurf( in vec3 p, in vec3 n){\n\n    n = abs(n);\n    \n    if (n.x>0.5) p.xy = p.zy;\n    else if (n.y>0.5) p.xy = p.zx;\n    \n    return brick(p.xy);\n    \n}\n\n// Standard function-based bump mapping function.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const vec2 e = vec2(0.001, 0);\n    float ref = bumpSurf(p, nor);                 \n    vec3 grad = (vec3(bumpSurf(p - e.xyy, nor),\n                      bumpSurf(p - e.yxy, nor),\n                      bumpSurf(p - e.yyx, nor) )-ref)/e.x;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n\n\n// This is just a slightly modified version of fb39ca4's code, with some\n// elements from IQ and Reinder's examples. They all work the same way:\n// Obtain the current voxel, then test the distance field for a hit. If\n// the ray has moved into the voxelized isosurface, break. Otherwise, move\n// to the next voxel. That involves a bit of decision making - due to the\n// nature of voxel boundaries - and the \"mask,\" \"side,\" etc, variable are\n// an evolution of that. If you're not familiar with the process, it's \n// pretty straight forward, and there are a lot of examples on Shadertoy, \n// plus a lot more articles online.\n//\nvec3 voxelTrace(vec3 ro, vec3 rd, out vec3 mask){\n    \n    vec3 p = floor(ro) + .5;\n\n\tvec3 dRd = 1./abs(rd); // 1./max(abs(rd), vec3(.0001));\n\trd = sign(rd);\n    vec3 side = dRd*(rd * (p - ro) + 0.5);\n    \n    mask = vec3(0);\n\t\n\tfor (int i = 0; i < 80; i++) {\n\t\t\n        if (map(p)<0.) break;\n        \n        // Note that I've put in the messy reverse step to accomodate\n        // the \"less than or equals\" logic, rather than just the \"less than.\"\n        // Without it, annoying seam lines can appear... Feel free to correct\n        // me on that, if my logic isn't up to par. It often isn't. :)\n        mask = step(side, side.yzx)*(1.-step(side.zxy, side));\n\t\tside += mask*dRd;\n\t\tp += mask * rd;\n\t}\n    \n    return p;    \n}\n\n\n// Voxel shadows. They kind of work like regular hard-edged shadows. They\n// didn't present too many problems, but it was still nice to have Reinder's\n// Minecraft shadow example as a reference. Fantastic example, if you've\n// never seen it:\n//\n// Minecraft - Reinder\n// https://www.shadertoy.com/view/4ds3WS\n//\nfloat voxShadow(vec3 ro, vec3 rd, float end){\n\n    float shade = 1.0;\n    vec3 p = floor(ro) + .5;\n\n\tvec3 dRd = 1./abs(rd);//1./max(abs(rd), vec3(.0001));\n\trd = sign(rd);\n    vec3 side = dRd*(rd * (p - ro) + 0.5);\n    \n    vec3 mask = vec3(0);\n    \n    float d = 1.;\n\t\n\tfor (int i = 0; i < 16; i++) {\n\t\t\n        d = map(p);\n        \n        if (d<0. || length(p-ro)>end) break;\n        \n        mask = step(side, side.yzx)*(1.-step(side.zxy, side));\n\t\tside += mask*dRd;\n\t\tp += mask * rd;                \n\t}\n\n    // Shadow value. If in shadow, return a dark value.\n    return shade = step(0., d)*.7 + .3;\n    \n}\n\n///////////\n//\n// This is a trimmed down version of fb39ca4's voxel ambient occlusion code with some \n// minor tweaks and adjustments here and there. The idea behind voxelized AO is simple. \n// The execution, not so much. :) So damn fiddly. Thankfully, fb39ca4, IQ, and a few \n// others have done all the hard work, so it's just a case of convincing yourself that \n// it works and using it.\n//\n// Refer to: Voxel Ambient Occlusion - fb39ca4\n// https://www.shadertoy.com/view/ldl3DS\n//\nvec4 voxelAO(vec3 p, vec3 d1, vec3 d2) {\n   \n    // Take the four side and corner readings... at the correct positions...\n    // That's the annoying bit that I'm glad others have worked out. :)\n\tvec4 side = vec4(map(p + d1), map(p + d2), map(p - d1), map(p - d2));\n\tvec4 corner = vec4(map(p + d1 + d2), map(p - d1 + d2), map(p - d1 - d2), map(p + d1 - d2));\n\t\n    // Quantize them. It's either occluded, or it's not, so to speak.\n    side = step(side, vec4(0));\n    corner = step(corner, vec4(0));\n    \n    // Use the side and corner values to produce a more honed in value... kind of.\n    return 1. - (side + side.yzwx + max(corner, side*side.yzwx))/3.;    \n\t\n}\n\nfloat calcVoxAO(vec3 vp, vec3 sp, vec3 rd, vec3 mask) {\n    \n    // Obtain four AO values at the appropriate quantized positions.\n\tvec4 vAO = voxelAO(vp - sign(rd)*mask, mask.zxy, mask.yzx);\n    \n    // Use the fractional voxel postion and and the proximate AO values\n    // to return the interpolated AO value for the surface position.\n    sp = fract(sp);\n    vec2 uv = sp.yz*mask.x + sp.zx*mask.y + sp.xy*mask.z;\n    return mix(mix(vAO.z, vAO.w, uv.x), mix(vAO.y, vAO.x, uv.x), uv.y);\n\n}\n///////////\n\n// XT95's really clever, cheap, SSS function. The way I've used it doesn't do it justice,\n// so if you'd like to really see it in action, have a look at the following:\n//\n// Alien Cocoons - XT95: https://www.shadertoy.com/view/MsdGz2\n//\nfloat thickness( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n\tconst float nbIte = 6.0;\n\tfloat ao = 0.0;\n    \n    for( float i=1.; i< nbIte+.5; i++ ){\n        \n        float l = (i*.75 + fract(cos(i)*45758.5453)*.25)/nbIte*maxDist;\n        \n        ao += (l + map( p -n*l )) / pow(1. + l, falloff);\n    }\n\t\n    return clamp( 1.-ao/nbIte, 0., 1.);\n}\n\n// Simple environment mapping. Pass the reflected vector in and create some\n// colored noise with it. The normal is redundant here, but it can be used\n// to pass into a 3D texture mapping function to produce some interesting\n// environmental reflections.\nvec3 envMap(vec3 rd, vec3 sn){\n    \n    float c = n3D(rd*3.)*.66 + n3D(rd*6.)*.34;\n    c = smoothstep(0.4, 1., c);\n    return vec3(min(c*1.5, 1.), pow(c, 3.), pow(c, 16.));\n    //vec3 col = tex3D(iChannel1, rd/4., sn);\n    //return smoothstep(.0, 1., col*col*2.);//col*col*2.;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n\t// Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 camPos = vec3(0, 0, iTime*8.); // Camera position, doubling as the ray origin.\n\tvec3 lookAt = camPos + vec3(0, 0, .25);  // \"Look At\" position.\n\n \n    // Light positioning. \n \tvec3 lightPos = camPos + vec3(0, 1, 5);// Put it a bit in front of the camera.\n\n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and light vector along the path. The \"path\" function is \n\t// synchronized with the distance function.\n\tlookAt.xy += path(lookAt.z);\n\tcamPos.xy += path(camPos.z);\n\tlightPos.xy += path(lightPos.z);\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159265/3.; // FOV - Field of view.\n    vec3 forward = normalize(lookAt-camPos);\n    vec3 right = normalize(vec3(forward.z, 0, -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    \n    // Distorted version.\n    //vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    //rd = normalize(vec3(rd.xy, rd.z - dot(rd.xy, rd.xy)*.25));    \n    \n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    // Naturally, it's synchronized with the path in some kind of way.\n\trd.xy = rot2( path(lookAt.z).x/24. )*rd.xy;\n\n    \n    // Raymarch the voxel grid.\n    vec3 mask;\n\tvec3 vPos = voxelTrace(camPos, rd, mask);\n\t\n    // Using the voxel position to determine the distance from the camera to the hit point.\n    // I'm assuming IQ is responsible for this clean piece of logic.\n\tvec3 tCube = (vPos-camPos - .5*sign(rd))/rd;\n    float t = max(max(tCube.x, tCube.y), tCube.z);\n\n\n\t\n    // Initialize the scene color.\n    vec3 sceneCol = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t<FAR){\n\t\n   \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = camPos + rd*t;\n        \n        // Voxel normal.\n        vec3 sn = -(mask * sign( rd ));\n        \n        // Sometimes, it's necessary to save a copy of the unbumped normal.\n        vec3 snNoBump = sn;\n        \n        // I try to avoid it, but it's possible to do a texture bump and a function-based\n        // bump in succession. It's also possible to roll them into one, but I wanted\n        // the separation... Can't remember why, but it's more readable anyway.\n        //\n        // Texture scale factor.\n        const float tSize0 = 1./4.;\n        // Texture-based bump mapping.\n\t    sn = doBumpMap(iChannel0, sp*tSize0, sn, 0.01);\n\n        // Function based bump mapping. Comment it out to see the under layer. It's pretty\n        // comparable to regular beveled Voronoi... Close enough, anyway.\n        sn = doBumpMap(sp, sn, .1);\n        \n       \n\t    // Ambient occlusion.\n\t    float ao = calcVoxAO(vPos, sp, rd, mask);\n\n        \n    \t// Light direction vectors.\n\t    vec3 ld = lightPos - sp;\n\n        // Distance from respective lights to the surface point.\n\t    float lDist = max(length(ld), 0.001);\n    \t\n    \t// Normalize the light direction vectors.\n\t    ld /= lDist;\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.2 + lDist*.1); // + distlpsp*distlpsp*0.025\n    \t\n    \t// Ambient light.\n\t    float ambience = 0.25;\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.0);\n   \t\n    \t// Specular lighting.\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.);\n\n  \n        // Object texturing.\n\t    //vec3 texCol = vec3(1, .75, .5);//vec3(1, .05, .15);//vec3(1, .5, .15);//vec3(1, .6, .4) + step(abs(snNoBump.y), .5)*vec3(0,.4, .6);\n\t    vec3 texCol = vec3(.55, .7, 1.3);\n    \n        //float rnd = fract(sin(dot(vPos, vec3(7, 157, 113)))*43758.5453);\n        //texCol *= rnd*.5+.5;\n        //if(rnd>.5) texCol = vec3(1);\n        \n        // Multiplying by the texture color.\n\t    texCol *= tex3D(iChannel0, sp*tSize0, sn)*4.;\n        \n        texCol *= bumpSurf( sp, sn)*.5 + .5; // Enhance the bump.\n        \n        \n        /////////   \n        // Translucency, courtesy of XT95. See the \"thickness\" function.\n        vec3 hf =  normalize(ld + sn);\n        float th = thickness( sp, sn, 1., 1. );\n        float tdiff =  pow( clamp( dot(rd, -hf), 0., 1.), 1.);\n        float trans = (tdiff + .0)*th;  \n        trans = pow(trans, 4.);        \n    \t////////  \n\n        \n        // Shadows... I was having all sorts of trouble trying the move the ray off off the\n        // block. Thanks to Reinder's \"Minecraft\" example for showing me the ray needs to \n        // be bumped off by the normal, not the unit direction ray. :)\n        float shading = voxShadow(sp + snNoBump*.01, ld, lDist);\n    \t\n    \t// Combining the above terms to produce the final color.\n        sceneCol = texCol*(diff + ambience) + vec3(.7, .9, 1.)*spec;// + vec3(.5, .8, 1)*spec2;\n        sceneCol += vec3(1, 0.05, .15)*trans*2.;\n        sceneCol += envMap(reflect(rd, sn), sn);\n        \n        //vec3 rfCol = texture(iChannel2, reflect(rd, sn)).xyz; // Forest scene.\n        //sceneCol += rfCol*rfCol*.5;\n\n\t    // Shading.\n        sceneCol *= atten*shading*ao;\n        \n        // \"fb39ca4\" did such a good job with the AO, that it's worth a look on its own. :)\n        //sceneCol = vec3(ao); \n\n\t   \n\t\n\t}\n       \n    // Blend in a bit of fog for atmospheric effect.\n    vec3 fog = mix(vec3(.96, .48, .36), vec3(.24, .32, .64), -rd.y*.5 + .5); //.zyx\n    //vec3 fog = mix(vec3(.32, .28, .16)*3., vec3(.32, .04, .08)*2., -rd.y*.5 + .5);\n    \n    // I'll tidy this up later.\n    sceneCol = mix(sceneCol, fog*sqrt(fog)*1.2, smoothstep(0., .95, t/FAR)); // exp(-.002*t*t), etc. fog.zxy\n\n    // Clamp and present the roughly gamma corrected pixel to the screen. :)\n\tfragColor = vec4(sqrt(clamp(sceneCol, 0., 1.)), 1.0);\n\t\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}