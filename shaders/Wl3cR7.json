{
    "Shader": {
        "info": {
            "date": "1608643366",
            "description": "License CC0 - Circular Pattern Tiling\n  I wanted to create circular tiling, turned out ok\n",
            "flags": 0,
            "hasliked": 0,
            "id": "Wl3cR7",
            "likes": 15,
            "name": "\"Circular\" Pattern Tiling",
            "published": 3,
            "tags": [
                "2d",
                "tiling",
                "circular"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 425
        },
        "renderpass": [
            {
                "code": "// License CC0 - \"Circular\" Pattern Tiling\n//  I wanted to create \"circular\" tiling, turned out ok\n//  mod1  - From: http://mercury.sexy/hg_sdf/\n//  star5 - From: https://iquilezles.org/articles/distfunctions2d\n\n#define PI  3.141592654\n#define TAU (2.0*PI)\n\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nvec2 toRect(vec2 p) {\n  return p.x*vec2(cos(p.y), sin(p.y));\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\n// Like many tiling functions modifies the input argument\n//  and returns a vector indicating which tile we are in\nvec3 modCircularPattern(inout vec2 p) {\n  vec2 pp = toPolar(p);\n\n  float nx = floor(pp.x + 0.5);\n  pp.x -= nx;\n  mod1(pp.x, 1.0);\n  pp.x += nx;\n  float cy = floor(0.5*nx*TAU)*2.0;\n  \n  float ny = mod1(pp.y, TAU/cy);\n  if(nx > 0.0) {\n    p = toRect(pp) - vec2(nx, 0.0);\n    return vec3(nx, mod(ny+cy*0.5, cy), cy);\n  } else {\n    return vec3(0.0, 0.0, 1.0);\n  }\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x+s*p.y, -s*p.x+c*p.y);\n}\n\nfloat star5(vec2 p, float r, float rf) {\n  const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n  const vec2 k2 = vec2(-k1.x,k1.y);\n  p.x = abs(p.x);\n  p -= 2.0*max(dot(k1,p),0.0)*k1;\n  p -= 2.0*max(dot(k2,p),0.0)*k2;\n  p.x = abs(p.x);\n  p.y -= r;\n  vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n  float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n  return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nfloat df(vec2 p) {\n  const float lw = 0.033;\n\n  float nx = floor(length(p) + 0.5);\n  rot(p, iTime/sqrt(1.0+nx));\n\n  vec3 n = modCircularPattern(p);\n\n  rot(p, 0.1*TAU*(n.y+n.x));;\n\n  float d = star5(p, 0.5-lw, 0.5);  \n  d = abs(d) - lw;\n\n  return d;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord.xy / iResolution.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n\n  float aa = 2.0/iResolution.y;\n  \n  float s = 0.25*mix(0.1, 1.0, 0.5+0.5*sin(iTime*0.5));\n  float d = df(p/s)*s;\n  \n  vec3 col = mix(vec3(1.0), vec3(0.125), tanh(length(0.05*p/s)));\n  \n  col = mix(col, vec3(0.0), smoothstep(-aa, aa, -d));\n  col = pow(col, vec3(1.0/2.2));\n  \n  fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}