{
    "Shader": {
        "info": {
            "date": "1691473793",
            "description": "Drag to see the effect.",
            "flags": 0,
            "hasliked": 0,
            "id": "cl2yzh",
            "likes": 6,
            "name": "Raymarching Frosted Glass",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 1,
            "username": "alphardex",
            "viewed": 785
        },
        "renderpass": [
            {
                "code": "mat2 rotation2d(float angle){\n    float s=sin(angle);\n    float c=cos(angle);\n    \n    return mat2(\n        c,-s,\n        s,c\n    );\n}\n\nmat4 rotation3d(vec3 axis,float angle){\n    axis=normalize(axis);\n    float s=sin(angle);\n    float c=cos(angle);\n    float oc=1.-c;\n    \n    return mat4(\n        oc*axis.x*axis.x+c,oc*axis.x*axis.y-axis.z*s,oc*axis.z*axis.x+axis.y*s,0.,\n        oc*axis.x*axis.y+axis.z*s,oc*axis.y*axis.y+c,oc*axis.y*axis.z-axis.x*s,0.,\n        oc*axis.z*axis.x-axis.y*s,oc*axis.y*axis.z+axis.x*s,oc*axis.z*axis.z+c,0.,\n        0.,0.,0.,1.\n    );\n}\n\nvec2 rotate(vec2 v,float angle){\n    return rotation2d(angle)*v;\n}\n\nvec3 rotate(vec3 v,vec3 axis,float angle){\n    return(rotation3d(axis,angle)*vec4(v,1.)).xyz;\n}\n\nfloat sdBox(in vec2 p,in vec2 b)\n{\n    vec2 d=abs(p)-b;\n    return length(max(d,0.))+min(max(d.x,d.y),0.);\n}\n\nfloat sdBox(vec3 p,vec3 b)\n{\n    vec3 q=abs(p)-b;\n    return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.);\n}\n\nfloat opUnion(float d1,float d2)\n{\n    return min(d1,d2);\n}\n\nvec2 opUnion(vec2 d1,vec2 d2)\n{\n    return(d1.x<d2.x)?d1:d2;\n}\n\nvec2 map(vec3 p){\n    vec2 d=vec2(1e10,0.);\n    \n    vec2 m=(iMouse.xy-iResolution.xy*.5)/iResolution.xy;\n    vec3 p1=p;\n    p1.z-=.2;\n    float tilt=.5;\n    p1=rotate(p1,vec3(0.,1.,0.),m.x*tilt);\n    p1=rotate(p1,vec3(1.,0.,0.),m.y*tilt);\n    float d1=sdBox(p1,vec3(.4,.4,.001));\n    d=opUnion(d,vec2(d1,1.));\n    vec3 p2=p;\n    float d2=sdBox(p2,vec3(1.,1.,.001));\n    d=opUnion(d,vec2(d2,2.));\n    return d;\n}\n\nvec3 calcNormal(in vec3 p)\n{\n    const float h=.0001;\n    const vec2 k=vec2(1,-1);\n    return normalize(k.xyy*map(p+k.xyy*h).x+\n    k.yyx*map(p+k.yyx*h).x+\n    k.yxy*map(p+k.yxy*h).x+\n    k.xxx*map(p+k.xxx*h).x);\n}\n\nfloat gaussian(vec2 d,float sigma){\n    return exp(-(d.x*d.x+d.y*d.y)/(2.*sigma*sigma));\n}\n\nvec4 gaussianBlur2D(in sampler2D tex,in vec2 st,in vec2 offset,const int kernelSize){\n    vec4 accumColor=vec4(0.);\n    \n    #define GAUSSIANBLUR2D_KERNELSIZE 20\n    float kernelSizef=float(kernelSize);\n    \n    float accumWeight=0.;\n    const float k=.15915494;// 1 / (2*PI)\n    vec2 xy=vec2(0.);\n    for(int j=0;j<GAUSSIANBLUR2D_KERNELSIZE;j++){\n        if(j>=kernelSize)\n        break;\n        xy.y=-.5*(kernelSizef-1.)+float(j);\n        for(int i=0;i<GAUSSIANBLUR2D_KERNELSIZE;i++){\n            if(i>=kernelSize)\n            break;\n            xy.x=-.5*(kernelSizef-1.)+float(i);\n            float weight=(k/kernelSizef)*gaussian(xy,kernelSizef);\n            accumColor+=weight*texture(tex,st+xy*offset);\n            accumWeight+=weight;\n        }\n    }\n    return accumColor/accumWeight;\n}\n\nvec3 render(vec2 uv){\n    vec3 col=vec3(0.);\n    \n    vec4 tex=texture(iChannel0,uv);\n    vec4 blurTex=gaussianBlur2D(iChannel0,uv,1./iResolution.xy,10);\n    \n    uv=(uv-.5)*2.;\n    \n    vec3 ro=vec3(0.,0.,1.);\n    vec3 rd=normalize(vec3(uv,0.)-ro);\n    \n    float depth=0.;\n    for(int i=0;i<64;i++){\n        vec3 p=ro+rd*depth;\n        vec2 t=map(p);\n        float d=t.x;\n        float m=t.y;\n        depth+=d;\n        \n        if(d<.01){\n            // col=vec3(1.);\n            vec3 normal=calcNormal(p);\n            \n            vec3 objectColor=vec3(1.);\n            if(m==1.){\n                objectColor=blurTex.xyz;\n            }else if(m==2.){\n                objectColor=tex.xyz;\n            }\n            vec3 lightColor=vec3(1.,1.,1.);\n            \n            if(m==1.){\n                float ambIntensity=.1;\n                vec3 ambient=lightColor*ambIntensity;\n                col+=ambient*objectColor;\n                \n                // diffuse\n                vec3 lightPos=vec3(20.);\n                vec3 lightDir=normalize(lightPos-p);\n                float diff=dot(normal,lightDir);\n                diff=max(diff,0.);\n                vec3 diffuse=lightColor*diff;\n                col+=diffuse*objectColor;\n                \n                // specular\n                vec3 reflectDir=reflect(-lightDir,normal);\n                vec3 viewDir=normalize(ro-p);\n                // float spec=dot(viewDir,reflectDir);\n                vec3 halfVec=normalize(lightDir+viewDir);\n                float spec=dot(normal,halfVec);\n                spec=max(spec,0.);\n                float shininess=32.;\n                spec=pow(spec,shininess);\n                vec3 specular=lightColor*spec;\n                col+=specular*objectColor;\n            }else if(m==2.){\n                // ambient\n                // float ambIntensity=.2;\n                float ambIntensity=1.;\n                vec3 ambient=lightColor*ambIntensity;\n                col+=ambient*objectColor;\n            }\n            \n            break;\n        }\n    }\n    \n    return col;\n}\n\nvec3 getSceneColor(vec2 fragCoord){\n    vec2 uv=fragCoord/iResolution.xy;\n    vec3 col=render(uv);\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec3 tot=vec3(0.);\n    \n    float AA_size=2.;\n    float count=0.;\n    for(float aaY=0.;aaY<AA_size;aaY++)\n    {\n        for(float aaX=0.;aaX<AA_size;aaX++)\n        {\n            tot+=getSceneColor(fragCoord+vec2(aaX,aaY)/AA_size);\n            count+=1.;\n        }\n    }\n    tot/=count;\n    \n    fragColor=vec4(tot,1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}