{
    "Shader": {
        "info": {
            "date": "1566009860",
            "description": "A simple procedural city generator.\n\nYou can now move around with keys:\nArrows = Turn, move\nSpace,Ctrl = Up down\nShift = Move faster\nF1 = Back to demo mode\n\nOr press F2 to ride the train :)",
            "flags": 49,
            "hasliked": 0,
            "id": "wt2SDW",
            "likes": 22,
            "name": "TomCity",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "sdf",
                "city"
            ],
            "usePreview": 1,
            "username": "tmulgrew",
            "viewed": 1143
        },
        "renderpass": [
            {
                "code": "//#define DEBUG\n\n#define TMIN 0.1\n\n// Try 500 or even 1000 if you have a fast GPU\n#define TMAX 200.0\n#define LIMIT 0.0005\n#define SHADOWLIMIT 0.0035\n#define STEPS 256\n#define SHADOWSTEPS 65\n#define SCREENDIST 0.5\n\n// Enable bump mapping (slower)\n#define BUMP\n\n// Enable ambient occlusion (even slower)\n#define AO\n\n// Render small objects like doors, window shutters\n#define SMALLOBJECTS\n\n// Add vines to buildings\n#define VINES\n\n// Ruined city effect. (Ideally disable glow below)\n//#define RUINS\n\n// Glow effect around edges of melt-in\n#define GLOW\n\n// Materials\n#define M_GROUND \t1.0\n#define M_BLD \t\t2.0\n#define M_ROAD\t\t3.0\n#define M_PAVEMENT\t4.0\n#define M_BRIDGE\t5.0\n#define M_STEEL\t\t6.0\n#define M_RAIL\t\t7.0\n#define M_WOOD\t\t8.0\n\nstruct Material {\n \tvec3 col;\n    float spec;\n    float bump;\n    float refl;\n};\n\n// Environment\nconst vec3 light \t= normalize(vec3(0.3, -1., 0.7));\nconst vec3 fog \t\t= vec3(0.9,0.925,1.0);\n\n#ifdef GLOW\nfloat glow = 0.;\n#endif\n\n// Misc\n\nvec2 minDist(in vec2 d1, in vec2 d2) {\n \treturn d1.x < d2.x ? d1 : d2;   \n}\n\nvec2 carveDist(in vec2 d, float c) {\n    return vec2(max(d.x, -c), d.y);\n}\n\nvec2 carveDist(in vec2 d1, in vec2 d2) {\n \treturn d1.x > -d2.x ? d1 : vec2(-d2.x, d2.y);   \n}\n\nvec3 orientPos(in vec3 p, int o) {\n    //return p;\n    switch (o) {\n        case 0: return p;\n        case 1: return vec3(-p.z,p.y,p.x);\n        case 2: return vec3(-p.x,p.y,-p.z);\n        case 3: return vec3(p.z,p.y,-p.x);\n        default: return p;\n    }\n}    \n\n// Trig\nvec3 rotatex(in vec3 p, float a) {\n\treturn vec3(p.x,\n                cos(a) * p.y - sin(a) * p.z,\n                cos(a) * p.z + sin(a) * p.y);\n}\n\nvec3 rotatey(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.z,\n                p.y,\n                cos(a) * p.z - sin(a) * p.x);\n}\n\n// Shapes\nfloat sphere(in vec3 p, float r) { return length(p) - r; }\n\nfloat box(in vec3 p, in vec3 s) { \n    vec3 d = abs(p) - s; \n    return max(d.x, max(d.y, d.z));\n}\nfloat box(in vec3 p, in vec3 c1, in vec3 c2) {\n \tvec3 center = (c1+c2)*0.5;\n    vec3 s = (c2-c1)*0.5;\n    return box(p - center, s);\n}\n\n// Grid access\nGridCell read(int x, int y, int z) {    \n    return read(iChannel0, iResolution, x, y, z);\n}\n\n// Scene\n#define WALL (HALF-0.1)\n\nvec2 wallDist(in vec3 p, bool l, bool r, int flags, float param) {\n    \n    // Main wall\n    \n    if ((flags & F_WALL) != 0) {\n        vec2 d = vec2(box(p, vec3(-(l ? BLOCK : HALF),-HALF,HALF-0.7), vec3(r ? BLOCK : HALF,-1.,HALF-0.2)), M_BLD);\n        if ((flags & F_DOOR) != 0)\n        {\n            // Gate hole\n            d = carveDist(d, box(p, vec3(-1.2,-HALF+.1,-HALF), vec3(1.2,1.5,HALF)));\n\n            // Gate\n            vec3 doorp = p - vec3(-1.2,0,HALF-.7);\n            doorp = rotatey(doorp, -param);\n            d = minDist(d, vec2(box(doorp, vec3(0,-HALF+.5,0), vec3(2.4,-1.1,.25)), M_WOOD));        \n        }\n        return d;\n    }\n    else {\n\t\tvec2 d = vec2(box(p, vec3(-(l ? BLOCK : HALF),-HALF,HALF-0.7), vec3(r ? BLOCK : HALF,HALF,HALF-0.2)), M_BLD);   \n        if ((flags & F_DOOR) != 0) {\n            // Door hole\n            d = carveDist(d, box(p, vec3(-1.2,-HALF,-HALF), vec3(1.2,1.5,HALF)));\n\n#ifdef SMALLOBJECTS       \n            // Door step\n            d = minDist(d, vec2(box(p, vec3(-1.2,-HALF,HALF-1.1), vec3(1.2,-HALF+.5,HALF)), M_WOOD));\n\n            // Door\n            vec3 doorp = p - vec3(-1.2,0,HALF-.7);\n            doorp = rotatey(doorp, -param);\n            d = minDist(d, vec2(box(doorp, vec3(0,-HALF+.5,0), vec3(2.4,1.5,.25)), M_WOOD));\n#endif        \n        }\n        else if ((flags & F_WINDOW) != 0) {\n            // Window hole\n            d = carveDist(d, box(p, vec3(1.5, 1.5, HALF)));\n\n#ifdef SMALLOBJECTS       \n            // Shutters\n            vec3 windowp = vec3(abs(p.x),p.y,p.z) - vec3(1.5,0,HALF-.7);\n            windowp = rotatey(windowp, param);\n            d = minDist(d, vec2(box(windowp, vec3(-1.49, -1.5, 0), vec3(0,1.5,.2)), M_WOOD));\n#endif\n            // Sill\n            d = minDist(d, vec2(box(p, vec3(-1.6, -1.7, HALF-0.4), vec3(1.6, -1.5, HALF)), M_BLD));\n        }\n\t    return d;\n    }    \n}\n\nvec2 buildingDist(in vec3 p, bool n, bool s, bool e, bool w, int y, int flags, float param) {\n    \n    // Note: Pushing the boxes into the neighbouring cells - when the wall/floor/ceiling\n    // is supposed to be continuous in that direction - helps remove seams at the overlap.\n    // The overlapping content is effectively clipped when ray tracing, because it only\n    // sees the content inside the same cell. However the normal calculating routine can \n    // see the overlap, and therefore doesn't treat it like the corner/edge of the box.\n    \n    // Ceiling/roof\n    vec2 d;\n    if ((flags & F_WALL) == 0) {\n \t\td = vec2(box(p, vec3(-(w?BLOCK:HALF),HALF-0.5,-(s?BLOCK:HALF)), vec3(e?BLOCK:HALF,HALF,n?BLOCK:HALF)), M_BLD);  \n    \n        // Floor if at ground level\n        if (y == 0)\n            d.x = min(d.x, box(p, vec3(-(w?BLOCK:HALF),-HALF,-(s?BLOCK:HALF)), vec3(e?BLOCK:HALF,-HALF + 0.3,n?BLOCK:HALF)));\n    \n    }\n    else\n        d = vec2(TMAX, 0);\n    // Walls\n    for (int o = 0; o < 4; o++) {\n        if (!n) {\n            vec3 wallp = orientPos(p, o);\n         \td = minDist(d, wallDist(wallp, w, e, flags, param));    \n            flags &= ~F_DOOR;\n        }\n        \n        // Rotate 90 degrees\n        bool temp = n;\n        n = e;\n        e = s;\n        s = w;\n        w = temp;                    \n    }\n    \n    return d;\n}\n\n#define ROAD (HALF*0.6)\n#define HALFP (HALF+1.0)\n#define HALFM (HALF-0.1)\n\nvec2 roadDist(in vec3 p, int shape) {\n    \n    // Road, extruded to block height, so we can carve it from the pavement\n    float rd;        \n    switch(shape) {\n     \tcase S_R:\t\n        \trd = box(p, vec3(-ROAD,-HALFM,-ROAD), vec3(ROAD,HALFP,HALFP));\n        \tbreak;\n        case S_R_I: \n        \trd = box(p, vec3(-ROAD,-HALFM,-HALFP), vec3(ROAD,HALFP,HALFP));\n        \tbreak;\n        case S_R_L:\t\n        \trd = min(\t\n                box(p, vec3(-ROAD,-HALFM,-ROAD), vec3(ROAD,HALFP,HALFP)), \n              \tbox(p, vec3(-ROAD,-HALFM,-ROAD), vec3(HALFP,HALFP,ROAD))  \n            );\n        \tbreak;\n        case S_R_T: \n        \trd = min(\t\n                box(p, vec3(-HALFP,-HALFM,-ROAD), vec3(HALFP,HALFP,ROAD)), \n              \tbox(p, vec3(-ROAD,-HALFM,-HALFP), vec3(ROAD,HALFP,ROAD))  \n            );\n        \tbreak;\n        case S_R_X: \n        \trd = min(\t\n                box(p, vec3(-HALFP,-HALFM,-ROAD), vec3(HALFP,HALFP,ROAD)), \n              \tbox(p, vec3(-ROAD,-HALFM,-HALFP), vec3(ROAD,HALFP,HALFP))  \n            );\n        \tbreak;\n        default: return vec2(HALF,0);\n    }\n    \n    // Pavement\n    float pd = box(p, vec3(-HALF,-HALF,-HALF), vec3(HALF,-HALF+0.4,HALF));\n    \n    // Carve road from pavement\n    pd = max(pd, -rd);\n    \n    //return vec2(pd, M_PAVEMENT);\n    \n    // Carve road down to 0.2\n    rd = max(rd, p.y - (-HALF+0.2));\n    \n    // Combine\n    return rd < pd ? vec2(rd, M_ROAD) : vec2(pd, M_PAVEMENT);\n}\n\nvec2 traintrackDist(in vec3 p, int shape) {\n    \n    // Base\n  \tvec2 d = vec2(box(p, vec3(-HALF,-HALF,-BLOCK), vec3(HALF, -HALF+0.5, BLOCK)), M_BRIDGE);\n\n    // Rails\n    vec3 railPos = vec3((HALF - 2.4) * sign(p.x), -HALF+1.1, 0);\n    d = minDist(d, vec2(box(p - railPos, vec3(0.2, 0.3, BLOCK)), M_RAIL));\n                      \n    // Slats\n    vec3 slatPos = vec3(0, -HALF+0.65, round(p.z/2.)*2.);\n    d = minDist(d, vec2(box(p - slatPos, vec3(HALF-1., .15, .4)), M_WOOD));\n    \n    return d;\n}\n\nvec2 wellDist(in vec3 p) {\n \t\n    float cylinder = length(p.xz) - 3.5;\n    cylinder = max(cylinder, (p.y - -2.5));\n    cylinder = max(cylinder, -(length(p.xz) - 2.5));\n    \n    return vec2(cylinder, M_BLD);   \n}\n\nvec2 tableDist(in vec3 p) {\n \tfloat table = box(p - vec3(0, -HALF+1.5, 0), vec3(1.5,.1,2.5));\n    vec2 legPos = vec2(1.1,2.1) * sign(p.xz);\n    float leg = length(p.xz - legPos) - .2;\n    leg = max(leg, p.y - (-HALF+1.6));\n    table = min(table, leg);\n    return vec2(table, M_WOOD);\n                      \n}\n\nvec2 blockDist(in vec3 p, in vec3 cellCenter, in GridCell cell, int y) {\n    vec2 d = vec2(TMAX, 0);\n    \n    // Position in different spaces:\n    // p\t= world space\n    // cp\t= cell space unrotated (relative to center of cell)\n    // rcp\t= rotated cell space (to account for cell rotation)\n    vec3 cp = p - cellCenter;\n    vec3 rcp = orientPos(cp, cell.orient);\n    \n    switch (cell.type) {\n        case T_BLD:        \n        \t// Originally this switch called buildingDist explicitly on each case statement.\n        \t// This caused the shader to take 11s to compile (inlining presumably).\n        \t// Using this method the shader takes ~2s to compile.\n        \tbool n = false, s = false, e = false, w = false;\n            switch (cell.shape) {\t\t\t\t\t \n                case S_:\tn = s = e = w = true; break;\n                case S_O:\tbreak;\n                case S_U:\tn = true; break;\n                case S_L:\tn = e = true; break;\n                case S_I:\tn = s = e = true; break;\n                case S_II:\tn = s = true; break;\n            }\n        \n        \td = minDist(d, buildingDist(rcp, n, s, e, w, y, cell.flags, cell.param));\n        \tbreak;\n        \n        case T_ROAD:\n        \td = minDist(d, roadDist(rcp, cell.shape));\n        \tbreak;\n        \n        case T_TRAINTRACK:\n        \td = minDist(d, traintrackDist(rcp, cell.shape));\n        \tbreak;   \n        \n        case T_WELL:\n        \td = minDist(d, wellDist(cp));\n        \tbreak;\n        \n        case T_TABLE:\n        \td = minDist(d, tableDist(rcp));\n        \tbreak;\n        \n        case T_DEBUG:\n        \treturn vec2(length(rcp) - .5, M_STEEL);\n    }\n    \n    // Train track poles.\n    if ((cell.flags & F_POLES) != 0) {\n        vec2 polepos = vec2(HALF-1.) * sign(cp.xz);\n        d = minDist(d, vec2(length(cp.xz - polepos) - .25, M_STEEL));\n    }\n    \n    // Melt in effect\n#ifndef RUINS    \n    if (iFrame > 5 && !isManualControl(iChannel0) && !isTrainRide(iChannel0)) {\n        float h = float(iFrame % LIFESPAN) / 60.0;\n        h *= 0.7;\n        h = pow(max(h,0.01),2.0);\n#else\n        float h = 27.0;\n#endif        \n        if (h < float(GRID_H) * BLOCK + 33.0) {\n            vec2 uv = mod(p.xz, vec2(float(GRID_W),float(GRID_L))*BLOCK);\n            h -= texture(iChannel1, uv * 0.0025).x * 3.0;\n            h -= texture(iChannel1, uv * 0.0002).x * 30.0;\n            //h = max(h, -.1);\n\n#ifdef GLOW            \n            glow += 1. / (abs(d.x-(h-p.y))+.4);\n#endif            \n            d = carveDist(d, h-p.y);\n        }\n#ifndef RUINS    \n    }\n#endif    \n    // Apply ground last, so that it doesn't melt\n    d = minDist(d, vec2(p.y, M_GROUND));\n    \n    return d;\n}\n\n// Rendering\n\nvec2 raycast(in vec3 from, in vec3 dir, out vec3 c, out GridCell cell, int steps, float limit) {\n\n    // Avoid divide by 0\n    if (abs(dir.x) < 0.0001) dir.x = 0.0001;\n    if (abs(dir.y) < 0.0001) dir.y = 0.0001;\n    if (abs(dir.z) < 0.0001) dir.z = 0.0001;\n    \n    // Cell address\n    c = floor(from / BLOCK);\n    \n    // Trace through cells\n    float t = TMIN;\n    int i = 0;\n    while (true) {\n    \n        // Next cell border for each axis\n        // This is the cell border if dir negative or the next cell border if positive\n        vec3 b = c + (sign(dir) + vec3(1)) * 0.5;\n\n        // Distance to each border        \n        vec3 bd = (b*BLOCK - from) / dir;\n\n        // Trace up to nearest distance\n        float nearest = min(bd.x, min(bd.y, bd.z));\n        \n        // Ray march in grid cell\n\t    cell = read(int(c.x), int(c.y), int (c.z));\n\t    vec3 cellCenter = (c + vec3(.5)) * BLOCK;\n        while (t < nearest) {\n\t\t\tvec2 d = blockDist(from + t*dir, cellCenter, cell, int(c.y));\n            if (abs(d.x) < limit*t || i >= steps) \n                return vec2(t, d.y);\n            t += d.x;            \n            i++;\n        }\n        \n        // Advance to next cell\n        t = nearest;\n        if (bd.x < bd.y && bd.x < bd.z)\tc.x += sign(dir.x);\n        else if (bd.y < bd.z)\t\t\tc.y += sign(dir.y);\n        else \t\t\t\t\t\t\tc.z += sign(dir.z);\n\n        // Ray missed?\n        if (t >= TMAX \n            || (c.y >= float(GRID_H) && dir.y >= 0.)\n           \t|| (c.y < 0. && dir.y <= 0.))\n            return vec2(TMAX, 0);        \n\t}\n}\n\nvec3 normal(in vec3 p, in vec3 c, in GridCell cell, float t) {  \n\n    // Get cell info\n    vec3 cellCenter = (c + vec3(.5)) * BLOCK;    \n    int y = int(c.y);\n    \n    vec2 s = vec2(0.1 / t, 0);\n    float d = blockDist(p, cellCenter, cell, y).x;\t\t\t// Need original distance to compare it to\n    vec3 r = vec3(\n        blockDist(p + s.xyy, cellCenter, cell, y).x - d,\n        blockDist(p + s.yxy, cellCenter, cell, y).x - d,\n        blockDist(p + s.yyx, cellCenter, cell, y).x - d);    \n    return normalize(r);\n}\n\nvec2 boxuv(in vec3 p, in vec3 n) {\n    vec3 an = abs(n);\n    return an.x > an.y && an.x > an.z ? p.yz\n         : an.y > an.z                ? p.zx\n         :                              p.xy;\n}\n\nfloat vines1(in vec2 uv, float y) {\n    uv *= .5;\n    float v = texture(iChannel1, uv * .0625).x * .125\n            + texture(iChannel1, uv * .03125).x * .25\n            + texture(iChannel1, uv * .015625).x * .5;\n    v = 1. - (pow(abs(.5 - v), .5) + y*.005 + .07) * 4.;\n    return clamp(v, 0., 1.);\n}\n\nfloat vines(in vec2 uv, float y) {\n    uv *= .5;\n \treturn max(vines1(uv, y), vines1(uv.yx + vec2(.5), y));\n}\n\nvec3 addVines(in vec3 col, in vec2 uv, float y) {\n    return mix(col, vec3(.1, .4, .1), vines(uv,y));\n}\n\nMaterial mat(float m, in vec2 uv, in vec3 p) {\n    Material material;\n    material.spec = .5;\n    material.bump = 5.;\n    material.refl = 0.;\n    if (m == M_GROUND) {\n        material.col = vec3(.6,.7,.6) * texture(iChannel1, uv*0.5).xxx;\n    }\n    else if (m == M_BLD) {\n        vec3 col = texture(iChannel3, uv * 0.125).xyz;\n        material.col = vec3(length(col)) * .4 + col.zxy * .1;\n        material.bump = 10.;\n    }\n    else if (m == M_ROAD) {\n        material.col = vec3(.2) * texture(iChannel1, uv).xxx + vec3(.3);\n        material.spec = 2.;\n        material.bump = 15.;\n    }\n    else if (m == M_PAVEMENT) {\n        vec3 col = texture(iChannel3, uv * 0.25).xyz;\n        material.col = mix(vec3(length(col)), col, 0.3) * .6;\n        material.bump = 10.;\n    }\n    else if (m == M_WOOD) {\n        // Add some octaves of noise\n        float v = texture(iChannel1, uv * .0625).x * .125\n                + texture(iChannel1, uv * .03125).x * .25\n                + texture(iChannel1, uv * .015625).x * .5;\n        v = fract(v * 16.);\n        material.col = mix(vec3(.2, .15, .1), vec3(.28, .22, .19), clamp(v,0.,1.));\n        material.bump = 0.;\n    }\n    else if (m == M_BRIDGE) {\n        material.col = texture(iChannel3, uv * 0.25).xyz * .2 + vec3(.2);\n    }\n    else if (m == M_STEEL)\n    {\n        material.col = vec3(0.5);\n        material.spec = 2.;\n    }\n    else if (m == M_RAIL)\n    {\n        material.col = vec3(0.2); \n        material.refl = .1;\n    }\n    else \n        material.col = vec3(0.2);\n\n#ifdef VINES    \n    if (m == M_BLD || m == M_BRIDGE) {\n        material.col = addVines(material.col, uv, p.y);\n    \tmaterial.bump = 10.;\n    }\n    else if (m == M_WOOD || m == M_STEEL || m == M_PAVEMENT) {\n        material.col = addVines(material.col, uv, p.y + 15.);\n    \tmaterial.bump = 10.;     \t   \n    }\n#endif    \n    return material;\n}\n\nfloat shading(in vec3 e, in vec3 n, float diffuse, float specular, float shiny) {\n    float d = dot(n, -light) * diffuse;\n    vec3 h = -(normalize(e) + light) / 2.0;\n    float s = pow(dot(n, h), shiny) * specular;\n    return max(d + s, 0.0);\n}\n\n// Get bump map height\nfloat bumph(float m, in vec2 uv, in vec3 p) {    \n    if (m == M_ROAD) {\n        return texture(iChannel2, uv * .5).x;\n    }    \n    else if (m == M_WOOD) {\n#ifdef VINES\n        return 1.0 - vines(uv, p.y + 15.);\n#endif\n        return 0.;\n    }\n    else\n    \treturn length(mat(m, uv, p).col);\t\t// Default to intensity of material colour\n}\n\nvec3 bump(float matType, in vec2 uv, in vec3 n, float strength, in vec3 p) {\n    // My take on bump mapping (probably not best pratice).\n    // Using intensity of the colour texture as height.\n    // Take difference between left and right texels and above and below texels to offset \n    // the normal in the u and v directions respectively.\n    float e = 0.005;\n    float bu = bumph(matType, uv-vec2(e,0),p) - bumph(matType, uv+vec2(e,0),p);\n    float bv = bumph(matType, uv-vec2(0,e),p) - bumph(matType, uv+vec2(0,e),p);\n    return normalize (n + (bu*n.zxy + bv*n.yzx) * strength);\t\t// n.zxy and n.yzx are tangental vectors (assuming n is axis aligned)\n}\n\n//IQ - https://iquilezles.org/articles/raymarchingdf\nfloat ambientOcclusion(in GridCell cell, in vec3 p, in vec3 cellCenter, in vec3 n, int y) {\n    float ra = 0., w = 1., d = 0.;\n    for (float i = 1.; i < 4.; i += 1.){\n        d = i / 5.;\n        ra += w * (d - blockDist(p + n * d, cellCenter, cell, y).x);\n        w *= .5;\n    }\n    return 1. - clamp(ra, 0., 1.);\n}\n\nvec3 renderPixel(in vec3 from, in vec3 dir) {\n    \n    // Trace ray\n    vec3 c;\t\t\t\t\t\t\t\t// Cell address - returned by raycast, so that normal and ao can search in correct cell\n    GridCell cell;    \n    vec3 col = vec3(0);\n    float env;\n    vec2 h = raycast(from, dir, c, cell, STEPS, LIMIT);\n    vec3 envFrom;\n    vec3 envDir;\n    if (h.x < TMAX) {\n        \n        // Position and normal\n        vec3 p = from + h.x * dir;\n        vec3 n = normal(p, c, cell, h.x);\n        \n        // Material\n        vec2 uv = boxuv(p, n);\n        Material material = mat(h.y, uv, p);\n        \n        // Bump mapping\n#ifdef BUMP\n        // Bump mapping is not noticeable beyond about 50 units so it can be disabled for performance.\n        // But just switching it off causes an ugly black seam - I'm guessing the mipmap level logic \n        // doesn't like the neighbouring fragments to not perform the fetches.\n        // By adding a small buffer range where we calculate the bump map normal but don't use it makes \n        // the seam go away.\n        if (h.x < 55.) {\n      \t\tvec3 bumpn = bump(h.y, uv, n, material.bump, p);\n            if (h.x < 50.)\n                n = bumpn;\n        }\n#endif       \n        \n        // Basic shading\n        float i = shading(dir, n, 0.6, material.spec, 8.0);\n        vec3 dummy;\n        GridCell dummyCell;\n        if (i > 0. && raycast(p, -light, dummy, dummyCell, SHADOWSTEPS, SHADOWLIMIT).x < TMAX)\n            i = 0.;\t\t\t\t\t\t\t// TODO: Soft shadows                \n        float ambient = 0.3;\n\n        // Ambient occlusion\n#ifdef AO\n        // Again, not really noticeable beyond about 75 units.\n        if (h.x < 75.) {\n            // For performance we just trace inside the cell containing p\n            vec3 cellCenter = (c + vec3(.5)) * BLOCK;\n            float ao = ambientOcclusion(cell, p, cellCenter, n, int(c.y));            \n            ao *= ambient;\n            ambient = mix(ambient, ao, 0.75);\n        }\n#endif\n        \n        i = clamp(i + ambient, 0.0, 1.0);\n        col = material.col * i;\n        \n#ifdef GLOW        \n        col += glow * vec3(.5, .7, 1.) * .015;\n#endif        \n        \n        // Fog\n        col = mix(col, fog, pow(h.x/TMAX,3.0));\n        \n        // Reflection\n        if (material.refl > 0.) {\n            col *= (1. - material.refl);\n            env = material.refl;\n            envFrom = p;\n            envDir = reflect(dir, n);\n        }\n    }\n    else {\n     \tenvFrom = from;\n        envDir = dir;\n        env = 1.;\n    }\n\n    if (env > 0.)\n    {\n        // Ray miss\n        vec3 envCol = vec3(.7,.2,0);\n        if (envDir.y > .1) {\n            vec2 uv = envDir.xz * (5.0 / envDir.y);\n            float cloud = texture(iChannel1, uv * 0.005).x*4. + \n                texture(iChannel1, uv * 0.01).x*2. +\n                texture(iChannel1, uv * 0.02).x;\n            cloud = clamp(cloud*.13 - .4,0.,1.);\n            envCol += vec3(cloud);\n        }\n        envCol = mix(fog, envCol, max(envDir.y-.1, 0.));\n        \n        col += envCol * env;\n    }\n    \n    // Fade in/out\n    if (iFrame > 5 && !isManualControl(iChannel0) && !isTrainRide(iChannel0)) {\n        float fade = float(abs(((iFrame+LIFESPAN/2) % LIFESPAN) - LIFESPAN/2)) * 0.008;\n        fade = clamp(fade,0.0,1.0);    \n        col *= fade;\n    }\n    \n    return col;\n}\n\nvec3 getTrainPos() {\n\treturn vec3(mod(iTime * 5., float(GRID_W)*BLOCK), BLOCK*1.75, HALF);\n}\n\n// Main loop\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int iteration = iFrame/LIFESPAN;\n    \n    // Move camera down alley\n    vec2 s = fragCoord.xy - iResolution.xy / 2.0;\n    vec3 dir = normalize(vec3(s / (SCREENDIST * iResolution.x), 1));\n    vec3 from;\n    if (isManualControl(iChannel0)) {\n     \tfrom = getState(iChannel0, STATE_POS).xyz;\n        vec2 ang = getState(iChannel0, STATE_DIR).xy;\n        dir = rotatex(dir, ang.x);\n        dir = rotatey(dir, ang.y);\n    }\n    else if (isTrainRide(iChannel0)) {\n     \tfrom = getTrainPos();\n        dir = rotatey(dir, PI*.5);\n    }\n    else {\n        from = vec3(HALF, -cos(float(iteration)*1.02) * 25.0 + 27.0, mod(iTime * 7.5, float(GRID_L)*BLOCK));        \n        if (iFrame > 5)\n            dir = rotatey(dir, iTime * 0.1);\n        else\n        {\n            from.y = float(GRID_H) * BLOCK * .25;\n            from.z = 18. * BLOCK;\n        }\n    }\n    \n    // Render\n    fragColor = vec4(renderPixel(from, dir), 1);\n    \n#ifdef DEBUG    \n\tfragColor = texture(iChannel0, fragCoord / iResolution.xy * 0.25) * 20.0;\n#endif\n}\n\n\nvoid mainVR(out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir) \n{\n    vec3 adj = vec3(1,1,-1);\n    bool isTrain = isTrainRide(iChannel0);\n\tvec3 from = isTrain ? getTrainPos() : getState(iChannel0, STATE_POS).xyz;\n    vec2 ang = isTrain ? vec2(0,PI*.5) : getState(iChannel0, STATE_DIR).xy;\n    from.y = from.y - HALF + 4.9;\n    from += rotatey(fragRayOri*adj*3., ang.y);\n    vec3 dir = rotatey(fragRayDir*adj, ang.y);\n    fragColor = vec4(renderPixel(from, dir), 1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.14159265\n\n#define BLOCK\t8.0\n#define HALF\t(BLOCK*0.5)\n\n// Building grid parameters\n#define BLD_GRID_W\t\t8\n#define BLD_GRID_H\t\t8\n#define BLD_GRID_MAX\t2\n#define BLD_GRID_SQUARE\t4\n#define BLD_MAX_TALL\t5\n\n// World grid parameters\n#define GRID_W\t\t\t(BLD_GRID_W*BLD_GRID_SQUARE)\n#define GRID_L\t\t\t(BLD_GRID_H*BLD_GRID_SQUARE)\n#define GRID_H\t\t\tBLD_MAX_TALL\n\n// Object types\n#define T_BLD\t\t\t1\n#define T_EMPTY\t\t\t2\n#define T_ROAD\t\t\t3\n#define T_TRAINTRACK\t4\n#define T_WELL\t\t\t5\n#define T_TABLE\t\t\t6\n#define T_DEBUG\t\t\t100\n\n// Shape constants. S_R are for road. Others are for building.\n// The shape of the last letter is the shape of the object. \n// E.g. S_L is corner of a building. S_R_T is T junction in road.\n#define S_\t\t\t\t0\n#define S_O\t\t\t\t1\n#define S_U\t\t\t\t2\n#define S_L\t\t\t\t3\n#define S_I\t\t\t\t4\n#define S_II\t\t\t5\n#define S_R\t\t\t\t6\n#define S_R_I\t\t\t7\n#define S_R_L\t\t\t8\n#define S_R_T\t\t\t9\n#define S_R_X\t\t\t10\n\n// Object modifier flags (bitmasked)\n#define F_POLES\t\t\t1\n#define F_DOOR\t\t\t2\n#define F_WINDOW\t\t4\n#define F_WALL\t\t\t8\n\n// # frames before regenerating\n#define LIFESPAN\t\t2000\n\n// State for manual keyboard control\n// # is the X coordinate of the fragment in Buffer A where the state is persisted\n#define STATE_POS\t\t\t0\n#define STATE_DIR\t\t\t1\n#define STATE_MANUALCONTROL\t2\n\n// A grid cell stored in Buffer A. (Bit like a voxel.)\nstruct GridCell {\n \tint type;\t\t// Main type of object. T_xxx\n    int orient;\t\t// 90 degree clockwise rotation\n    int shape;\t\t// Shape of object. E.g. roads have T junctions, buildings have corners, walls etc. S_xxx\n    int flags;\t\t// Bitmask of flags to add/modify the cell content. F_xxx\n    float param;\t// Misc float param\n};\n\nGridCell makeCell(int type, int shape, int orient, int flags) {\n \tGridCell c;\n    c.type = type;\n    c.shape = shape;\n    c.orient = orient;\n    c.flags = flags;\n    return c;\n}\n\nGridCell makeCell(int type) { return makeCell(type, 0, 0, 0); }\n\nGridCell read(sampler2D buffer, vec3 iResolution, int x, int y, int z) {    \n    if (y < 0 || y >= GRID_H) \n        return makeCell(0);\n    x = x % GRID_W;\n    z = z % GRID_L;\n    if (x < 0) x += GRID_W;\n    if (z < 0) z += GRID_L;\n    vec2 uv = vec2(x + y * GRID_W, z + BLD_GRID_H);\n    vec4 frag = texture(buffer, (uv + vec2(0.5)) / iResolution.xy);\n    GridCell c;\n    c.type = int(frag.x);\n    c.shape = int(frag.y);\n    c.orient = int(frag.z) & 0x03;\n    c.flags = int(frag.z) >> 2;\n    c.param = frag.w;\n    return c;\n}\n\nbool isState(vec2 fragCoord) {\n    return int(fragCoord.y) == BLD_GRID_H + GRID_L;\n}\n\nbool isState(vec2 fragCoord, int state) {\n \treturn isState(fragCoord) && int(fragCoord.x) == state;   \n}\n\nvec4 getState(sampler2D buffer, int state) {\n \treturn texelFetch(buffer, ivec2(state, BLD_GRID_H + GRID_L), 0);\n}\n\nbool isManualControl(sampler2D buffer) {\n \treturn getState(buffer, STATE_MANUALCONTROL).x == 1.;\n}\n\nbool isTrainRide(sampler2D buffer) {\n \treturn getState(buffer, STATE_MANUALCONTROL).x == 2.;    \n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "struct Building {\n\tint x, y;\n    int w, h;\n    int tall;\n    ivec2 door;\t\t// Offset from x,y\n    int flags;\t\t// Flags to appy to whole building. F_xxx\n};\n\nfloat rand(vec2 co, float n){\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))+float(iFrame)+n) * 43758.5453);\n}\n\nbool getBldGridCoord(in vec2 fragCoord, out int x, out int y, out int n) {\n\tx = int(fragCoord.x);\n    y = int(fragCoord.y);\n    n = x % BLD_GRID_MAX;\n    x = x / BLD_GRID_MAX;    \n    return x < BLD_GRID_W && y < BLD_GRID_H;\n}\n\nBuilding randomBuilding(vec2 co) {\n\tint x1 = int(rand(co, 1.0) * float(BLD_GRID_SQUARE));\n\tint x2 = int(rand(co, 2.0) * float(BLD_GRID_SQUARE));\n\tint y1 = int(rand(co, 3.0) * float(BLD_GRID_SQUARE));\n\tint y2 = int(rand(co, 4.0) * float(BLD_GRID_SQUARE));\n    Building b;\n    b.x = min(x1, x2);\n    b.y = min(y1, y2);\n    b.w = max(x1, x2) - b.x + 1;\n    b.h = max(y1, y2) - b.y + 1;\n    b.tall = int(rand(co, 5.0) * float(BLD_MAX_TALL)) + 1;\n    b.flags = 0;\n    int doorSide = int(rand(co, 6.0) * 4.);\n    switch (doorSide) {\n     \tcase 0:\t\t\t\t// n\n        \tb.door = ivec2(int(rand(co, 7.0) * float(b.w-1)), b.h-1);\n        \tbreak;             \n        case 1:\t\t\t\t// e\n        \tb.door = ivec2(b.w-1, int(rand(co, 7.0) * float(b.h-1)));\n        \tbreak;\n     \tcase 2:\t\t\t\t// s\n        \tb.door = ivec2(int(rand(co, 7.0) * float(b.w-1)), 0);\n        \tbreak;             \n        case 3:\t\t\t\t// w\n        \tb.door = ivec2(0, int(rand(co, 7.0) * float(b.h-1)));\n        \tbreak;        \t\n    }\n    return b;    \n}\n\nvec4 encodeBuilding(in Building building) {\n    // Note IEEE 32 bit float can store integers up to 2^23\n    // Encode building dimensions in 16 bits.\n \tint r = building.x | (building.w << 4) | (building.y << 8) | (building.h << 12);\n    int g = building.tall | (building.door.x << 4) | (building.door.y << 8);    \n    int b = building.flags;\n    return vec4(r,g,b,0);\n}\n\nBuilding readBuilding(int x, int y, int n) {\n    vec2 uv = vec2(x * BLD_GRID_MAX + n, y);\n    vec4 frag = texture(iChannel0, (uv + vec2(0.5)) / iResolution.xy);\n    int r = int(frag.r);\n    int g = int(frag.g);\n    int b = int(frag.b);\n    Building building;    \n    building.x = r         & 0x0f;\n    building.w = (r >> 4)  & 0x0f;\n    building.y = (r >> 8)  & 0x0f;\n    building.h = (r >> 12) & 0x0f;\n    building.tall   = g        & 0x0f;\n    building.door.x = (g >> 4) & 0x0f;\n    building.door.y = (g >> 8) & 0x0f;\n    building.flags = b;\n    return building;\n}\n\nbool getGridCoord(in vec2 fragCoord, out int x, out int y, out int z) {\n \tx = int(fragCoord.x);\n    z = int(fragCoord.y) - BLD_GRID_H;\n    y = x / GRID_W;\n    x = x % GRID_W;\n    return x >= 0 && x < GRID_W && y >= 0 && y < GRID_H && z >= 0 && z < GRID_L;\n}\n\nbool isBuildingSubType(int sub, bool n, bool s, bool e, bool w) {\n    switch(sub) {\n        case S_: \treturn  n &&  s &&  e &&  w;\n        case S_O: \treturn !n && !s && !e && !w;\n        case S_U: \treturn  n && !s && !e && !w;\n        case S_L: \treturn  n && !s &&  e && !w;\n        case S_I: \treturn  n &&  s &&  e && !w;\n        case S_II: \treturn  n &&  s && !e && !w;\n        default: return false;\n    }    \n}\n\nGridCell getBuildingCell(bool n, bool s, bool e, bool w) {\n    for (int sub = S_; sub <= S_II; sub++) {\n        for (int orient = 0; orient < 4; orient++) {\n            if (isBuildingSubType(sub, n, s, e, w))\n                return makeCell(T_BLD, sub, orient, 0);\n            \n            // Rotate 90 degrees\n            bool temp = n;\n            n = e;\n            e = s;\n            s = w;\n            w = temp;\n        }\n    }\n    \n    return makeCell(0);\n}\n\nbool isRoadSubType(int sub, bool n, bool s, bool e, bool w) {\n    switch(sub) {\n        case S_R:\treturn  n && !s && !e && !w;\n        case S_R_I:\treturn  n &&  s && !e && !w;\n        case S_R_L:\treturn  n && !s &&  e && !w;\n        case S_R_T: return !n &&  s &&  e &&  w;\n        case S_R_X: return  n &&  s &&  e &&  w;\n        default: return false;\n    }\n}\n\n// (Also works for traintracks)\nGridCell getRoadCell(int type, int flags, bool n, bool s, bool e, bool w) {\n    for (int sub = S_R; sub <= S_R_X; sub++) {\n        for (int orient = 0; orient < 4; orient++) {\n            if (isRoadSubType(sub, n, s, e, w))\n                return makeCell(type, sub, orient, 0);\n            \n            // Rotate 90 degrees\n            bool temp = n;\n            n = e;\n            e = s;\n            s = w;\n            w = temp;\n        }\n    }\n    \n    return makeCell(T_ROAD);\n}\n\nvec4 encodeCell(in GridCell c) {\n \treturn vec4(\n        c.type, \n        c.shape, \n        c.orient | (c.flags << 2), \n        c.param);\n}\n\nGridCell read(int x, int y, int z) {    \n    return read(iChannel0, iResolution, x, y, z);\n}\n\nbool isKeyDown(int key) {\n \treturn texelFetch(iChannel1, ivec2(key, 0), 0).x != 0.;   \n}\n\nbool isNonJuncionRoad(int x, int y, int z) {\n \tGridCell cell = read(x, y,z);\n    return cell.type == T_ROAD && (cell.shape == S_R_I || cell.shape == S_R_L);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Default to existing colour\n\tfragColor = texture(iChannel0, fragCoord / iResolution.xy);    \n    \n    if (isState(fragCoord)) {\n        if (iFrame == 0) {\n         \tif (isState(fragCoord, STATE_POS)) fragColor = vec4(HALF, HALF, 0, 1);\n            if (isState(fragCoord, STATE_DIR)) fragColor = vec4(0);\n            if (isState(fragCoord, STATE_MANUALCONTROL)) fragColor = vec4(0, 0, 0, 0);\n        }\n        else {\n            if (isState(fragCoord, STATE_DIR)) {\n                // Left/right arrows turn\n                float turn = 0.;\n             \tif (isKeyDown(37)) turn -= 1.;\n                if (isKeyDown(39)) turn += 1.;\n                fragColor.y += turn * iTimeDelta * 1.7;\n            }\n            else if (isState(fragCoord, STATE_POS)) {\n                \n                float ang = getState(iChannel0, STATE_DIR).y;\n                float vel = 8.;\n                \n                // Shift doubles speed\n                if (isKeyDown(16)) vel *= 2.;\n\n                // Forward/back arrows move.\n                // Also W,S,A,D works\n                float fwd = 0.;                \n                if (isKeyDown(38) || isKeyDown(87)) fwd += 1.;\n                if (isKeyDown(40) || isKeyDown(83)) fwd -= 1.;\n                fragColor.xz += vec2(sin(ang),cos(ang)) * fwd * iTimeDelta * vel;\n                \n                float hor = 0.;\n                if (isKeyDown(68)) hor += 1.;\n                if (isKeyDown(65)) hor -= 1.;\n\t\t\t\tfragColor.xz += vec2(cos(ang),-sin(ang)) * hor * iTimeDelta * vel;              \n                    \n                // Space/ctrl moves up/down\n                float vert = 0.;\n                if (isKeyDown(32)) vert += 1.;\n                if (isKeyDown(17)) vert -= 1.;\n                fragColor.y = max(fragColor.y + vert * iTimeDelta * vel, 1.);\n                \n            }\n            else if (isState(fragCoord, STATE_MANUALCONTROL)) {\n                // Switch to manual control on keypress\n                if (isKeyDown(37) || isKeyDown(38) || isKeyDown(39) || isKeyDown(40) || isKeyDown(32) || isKeyDown(17))\n                    fragColor.x = 1.;\n                \n                // F1 switches back to demo mode\n                if (isKeyDown(112))\n                    fragColor.x = 0.;\n                \n                // F2 = train ride!\n                if (isKeyDown(113))\n                    fragColor.x = 2.;\n            }\n        }\n        return;\n    }\n        \n    int frame = iFrame;\n    \n    if (!isManualControl(iChannel0) && !isTrainRide(iChannel0))\n        frame = frame % LIFESPAN;\n    \n    if (frame == 0) {\n        // Clear buffer\n    \tfragColor = vec4(0);   \n    }\n    else if (frame == 1) {\n     \t// Seed buildings\n        int x, y, n;\n        if (getBldGridCoord(fragCoord, x, y, n)) {\n            if (rand(fragCoord, 0.0) < 0.75) {\n\t\t       \tBuilding building = randomBuilding(fragCoord);\n                if (n == 0 && rand(fragCoord, 13.0) < .4) {\n                    building.flags = F_WALL;\t\t\t\t// Convert building to a low wall\n                    building.tall = 1;\n                }\n\t            fragColor = encodeBuilding(building);            \n            }\n        }\n    }\n    else if (frame == 2) {\n        \n        // Exapand buildings into cells.\n        // Seed initial roads.\n        int x, y, z;\n        if (getGridCoord(fragCoord, x, y, z)) {\n            if ((x % (BLD_GRID_SQUARE*2)) == 0 ||\n                (z % (BLD_GRID_SQUARE*2)) == 0)\n            {                \n                if (y == 0 && (x % (BLD_GRID_SQUARE*4)) == 0)\n                    fragColor = encodeCell(makeCell(T_ROAD));\n                else if (y == 1 && (z % (BLD_GRID_SQUARE*4)) == 0)\n                    fragColor = encodeCell(makeCell(T_TRAINTRACK));\n                else\n                    fragColor = vec4(0);\n                return;\n            }                \n            \n     \t\t// Find building grid\n            bool foundBuilding = false;\n        \tint bgx = x / BLD_GRID_SQUARE;\n        \tint bgy = z / BLD_GRID_SQUARE;\n            for (int i = 0; i < BLD_GRID_MAX; i++) {\n            \tBuilding building = readBuilding(bgx, bgy, i);\n                building.x += bgx * BLD_GRID_SQUARE;\n                building.y += bgy * BLD_GRID_SQUARE;\n                if ((building.x % (BLD_GRID_SQUARE*2)) == 0)\n                {\n                    building.x++;\n                    building.w--;\n                }\n                if ((building.y % (BLD_GRID_SQUARE*2)) == 0)\n                {\n                    building.y++;\n                    building.h--;                \n                }\n                if (building.w == 0 || building.h == 0)\n                    building.tall = 0;\n\n                foundBuilding = foundBuilding || building.tall > 0;\n                if (building.x <= x && x < building.x + building.w &&\n                    building.y <= z && z < building.y + building.h &&\n                    y < building.tall) {\n                    \n                    // Calculate subtype and orientation\n                    bool n = z+1 < building.y + building.h;\n                    bool s = building.y <= z-1;\n                    bool e = x+1 < building.x + building.w;\n                    bool w = building.x <= x-1;\n                    GridCell cell = getBuildingCell(n,s,e,w);\n                    cell.flags = building.flags;\n\n                    // Flags\n                    if (y == 0 && x == building.x + building.door.x && z == building.y + building.door.y) {\n                        cell.flags = cell.flags | F_DOOR;\n                        cell.param = clamp(rand(fragCoord, 11.0)*8.-6.,0.,PI*.5);\n                    }\n                    if (rand(fragCoord, 10.0) < .9) {\n                        cell.flags = cell.flags | F_WINDOW;\n                        cell.param = clamp(rand(fragCoord, 11.0)*6.-1.,0.,PI*.6);\n                    }\n                    \n                 \tfragColor = encodeCell(cell);   \n                }                \n            }\n            \n            if (!foundBuilding && y == 0)\n                fragColor = encodeCell(makeCell(T_EMPTY));\n        }        \n    }\n    else if (frame < 100) {\n    \t// Flood fill road\n        int x, y, z;\n        if (getGridCoord(fragCoord, x, y, z)) {\n            GridCell cell = read(x, y, z);\n            int type = cell.type;\n            if (frame < 90 && type == 0 && y == 0) {\n            \n                int turn = (x%2) + (z%2)*2;\n                if ((iFrame%4) == turn) {\n                    \n                    // Bitmask of neighbouring grid squares\n                    int mask = 0;\n                    int bit = 1;\n                    for (int oz = -1; oz <=1; oz++) {\n                        for (int ox = -1; ox <= 1; ox++) {\n                            if (ox != 0 || oz != 0) {\n                                if (read(x+ox, y, z+oz).type == T_ROAD)\n                                    mask |= bit;\n                                bit <<= 1;\n                            }\n                        }\n                    }\n\n                    if ((mask & 0x5a) == 0) return;\t\t\t// No neighbouring road\n                    if ((mask & 0x0b) == 0x0b) return;\t\t// Would make 2x2 square\n                    if ((mask & 0x16) == 0x16) return;\t\t// \"\n                    if ((mask & 0x68) == 0x68) return;\t\t// \"\n                    if ((mask & 0xd0) == 0xd0) return;\t\t// \"\n\n                    fragColor = encodeCell(makeCell(T_ROAD));            \n                }\n            }\n            else if (type == T_ROAD || type == T_TRAINTRACK) {\n                \n                // Remove 1 block roads\n                if (frame >= 90) {\n                 \tif (cell.shape == S_R\n                        && !isNonJuncionRoad(x, y, z+1)\n                        && !isNonJuncionRoad(x, y, z-1)\n                        && !isNonJuncionRoad(x+1, y, z)\n                        && !isNonJuncionRoad(x-1, y, z)) {\n                     \tfragColor = encodeCell(makeCell(T_EMPTY));\n                        return;\n                    }                        \n                }\n                \n             \t// Calculate shape and orientation based on which neighbours are present\n                bool n = read(x, y, z+1).type == type;\n                bool s = read(x, y, z-1).type == type;\n                bool e = read(x+1, y, z).type == type;\n                bool w = read(x-1, y, z).type == type;\n                cell = getRoadCell(type, cell.flags, n,s,e,w);\n                \n                fragColor = encodeCell(cell);\n            }\n            \n            // Add flags for train bridge poles\n            if (y == 0 && (x%2)==0 && read(x, y+1, z).type == T_TRAINTRACK)\n            {\n                cell.flags = cell.flags | F_POLES;   \n                if (cell.type == 0) \n                    cell.type = T_EMPTY;\n                fragColor = encodeCell(cell);                \n            }\n        }        \n    }\n    else if (frame == 100) {\n     \t// Add random objects\n        int x, y, z;\n        if (getGridCoord(fragCoord, x, y, z)) {\n            \n            // Well\n            GridCell cell = read(x, y, z);\n            if (y == 0 && cell.type == T_EMPTY/* && cell.flags == 0 && rand(fragCoord, 12.0) < .2*/) {\n                int n = read(x,y,z+1).type;\n                int s = read(x,y,z-1).type;\n                int e = read(x+1,y,z).type;\n                int w = read(x-1,y,z).type;\n                int u = read(x,y+1,z).type;\n                if (n == T_EMPTY && s == T_EMPTY && e == T_EMPTY && w == T_EMPTY && u == 0) {\n                    cell.orient = int(rand(fragCoord, 15.0) * 4.);\n                    if (rand(fragCoord, 12.0) < .2) \n                        cell.type = T_WELL;\n                    else if (rand(fragCoord, 14.0) < .3) \n                     \tcell.type = T_TABLE;\n                    fragColor = encodeCell(cell);                    \n                }\n            }\n        }        \n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}