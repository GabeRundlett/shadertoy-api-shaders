{
    "Shader": {
        "info": {
            "date": "1455159109",
            "description": "Quite simple one, just for practicing\n\nReplace Lambertian BRDF with Oren-Nayar BRDF\n\n1: [url]https://www.shadertoy.com/view/XdK3WW[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "4sy3zG",
            "likes": 0,
            "name": "Ray Marching Practice 2",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "orennayar"
            ],
            "usePreview": 0,
            "username": "Takoa",
            "viewed": 425
        },
        "renderpass": [
            {
                "code": "// Sphere with Oren-Nayar BRDF\n// \n// Paper: http://www1.cs.columbia.edu/CAVE/publications/pdfs/Oren_SIGGRAPH94.pdf\n// Ref: http://shaderjvo.blogspot.jp/2011/08/van-ouwerkerks-rewrite-of-oren-nayar.html\n//\n// Note: 0.33 in coefficient A has been replaced with 0.57\n//       according to the footnote in the paper.\n\n#define PI 3.141592653\n#define INV_PI 0.3183098861\n#define GAMMA 2.2\n#define INV_GAMMA 0.4545454545\n\n#define EPSILON 0.001\n\nvec3 cameraPosition = vec3(0.0, 0.0, 2.0);\nvec3 cameraUp = vec3(0.0, 1.0, 0.0);\nvec3 cameraLookingAt = vec3(0.0, 0.0, -100.0);\n\nfloat albedo = 0.9;\nfloat roughness = 0.3;\n\nfloat getDistanceToSphere(vec3 rayPosition, vec3 spherePosition, float radius)\n{\n    return length(spherePosition - rayPosition) - radius;\n}\n\nfloat getDistance(vec3 position)\n{\n    return min(\n        getDistanceToSphere(position, vec3(-0.5, 0.0, 0.0), 1.0),\n        getDistanceToSphere(position, vec3(0.5, 0.0, 0.0), 1.0));\n}\n\nvec3 getNormal(vec3 p)\n{\n    return normalize(vec3(\n          getDistance(p + vec3(EPSILON, 0.0, 0.0)) - getDistance(p - vec3(EPSILON, 0.0, 0.0)),\n          getDistance(p + vec3(0.0, EPSILON, 0.0)) - getDistance(p - vec3(0.0, EPSILON, 0.0)),\n          getDistance(p + vec3(0.0, 0.0, EPSILON)) - getDistance(p - vec3(0.0, 0.0, EPSILON))\n        ));\n}\n\nvec3 getRayDirection(vec2 screenPosition, vec3 origin, vec3 lookingAt, vec3 up, float fov)\n{\n    vec3 d = normalize(lookingAt - origin);\n    vec3 rayRight = normalize(cross(d, up));\n    \n    return normalize(screenPosition.x * rayRight + screenPosition.y * up + 1.0 / tan(radians(fov / 2.0)) * d);\n}\n\nfloat rayMarch(inout vec3 p, vec3 rayDirection)\n{\n    float d;\n    \n    for (int i = 0; i < 128; i++)\n    {\n        d = getDistance(p);\n        p += d * rayDirection;\n    }\n    \n    return d;\n}\n\nfloat getOrenNayarReflectance(vec3 normal, vec3 lightDirection, vec3 viewDirection, float roughness, float albedo)\n{\n    float roughness2 = roughness * roughness;\n    float orenNayarA = 1.0 - 0.5 * roughness2 / (roughness2 + 0.57);\n    float orenNayarB = 0.45 * roughness2 / (roughness2 + 0.09);\n    float orenNayarL = max(0.0, dot(normal, lightDirection));\n    float orenNayarV = max(0.0, dot(normal, viewDirection));\n    float orenNayarP = max(0.0, dot(normalize(lightDirection - normal * orenNayarL), normalize(viewDirection - normal * orenNayarV)));\n    float orenNayarL2 = orenNayarL * orenNayarL;\n    float orenNayarV2 = orenNayarV * orenNayarV;\n        \n    return albedo * INV_PI * orenNayarL * (orenNayarA + orenNayarB * orenNayarP * sqrt((1.0 - orenNayarL2) * (1.0 - orenNayarV2)) / max(orenNayarL, orenNayarV));\n}\n\nvec3 pow3(vec3 color, float g)\n{\n    return vec3(pow(color.x, g), pow(color.y, g), pow(color.z, g));\n}\n\nvec3 correctGamma(vec3 color, float reflectance)\n{\n   return pow3(color * reflectance, INV_GAMMA);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 position = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 lightPosition = vec3(10.0 * cos(iTime), 10.0, 10.0 * sin(iTime));\n    vec3 rayDirection = getRayDirection(position, cameraPosition, cameraLookingAt, cameraUp, 90.0);\n    vec3 p = cameraPosition;\n    float d = rayMarch(p, rayDirection);\n    \n    if (d < EPSILON)\n    {\n        float diffuse = getOrenNayarReflectance(getNormal(p), normalize(lightPosition - p), -rayDirection, roughness, albedo);\n        \n        fragColor = vec4(correctGamma(vec3(0.3, 0.9, 0.6), diffuse), 1.0);\n    }\n    else\n    {\n        fragColor = vec4(0.2, 0.2, 0.2, 1.0);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}