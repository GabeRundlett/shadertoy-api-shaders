{
    "Shader": {
        "info": {
            "date": "1630637840",
            "description": "A shader for sableraph's weekly creative code challenge, theme was \"architecture\".\n\nIt's a little bit artifacty but the AA sorta covers it up.\n\nSpin with mouse",
            "flags": 0,
            "hasliked": 0,
            "id": "NdcGDj",
            "likes": 21,
            "name": "Abstractions",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "abstract",
                "architecture"
            ],
            "usePreview": 0,
            "username": "Tater",
            "viewed": 466
        },
        "renderpass": [
            {
                "code": "#define STEPS 150.0\n#define MDIST 100.0\n#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\nvec3 rdg = vec3(0);\nfloat h21(vec2 p){\n    return fract(43757.5453*sin(dot(p, vec2(12.9898,78.233))));\n}\nfloat h13(vec3 p3){\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat octa( vec3 p, float s){\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*-tan(5.0*pi/6.0);\n}\nfloat box(vec3 p, vec3 b){\n    vec3 d= abs(p)-b;\n    return max(d.x,max(d.y,d.z));\n}\nbool filled(vec3 id){\n    if(id.y<0.) return true;\n    float cyc = floor(iTime*0.15);\n    float hash = h13(id+cyc);\n    cyc = mod(cyc,3.0);\n    //I had to do this uglyness because compiler keeps tryning to inline everything\n    //(this saves like 2 seconds of compile time)\n    float w1 = max(abs(id.x),abs(id.z));\n    float w2 = length(id.y*id.y);\n    float w3 = 0.3;\n    if(cyc==0.0) w1 = length(id.xz);\n    if(cyc==2.0) {w2 = abs(id.y);w3 = 0.4; }\n    return(hash+w1*w3+w2*0.01<0.85);\n}\nvec2 map(vec3 p){\n    float t = iTime;\n    vec3 po = p;\n    vec2 a = vec2(9999.,1);\n    vec2 b = vec2(2);\n    \n    vec3 id = floor(p);\n    //float hash = h13(id+floor(t*0.1));\n    vec3 dir = sign(rdg)*.5;\n    vec3 q = fract(p)-.5;\n    //q = vec3(q.x,q.y,q.z);\n    vec3 rc = (dir-q)/rdg;\n\n    float dc = min(rc.x,min(rc.y,rc.z))+0.01;\n    bool ifilled = filled(id);\n    if(max(id.x,id.z)<5.0){\n        if(ifilled)a.x = box(q,vec3(0.5));\n        float nbors = 0.;\n        vec3 off = vec3(0);\n        if(filled(id+vec3(1,0,0))){nbors++;off+=vec3(1,0,0);}\n        if(filled(id+vec3(0,1,0))){nbors++;off+=vec3(0,1,0);}\n        if(filled(id+vec3(0,0,1))){nbors++;off+=vec3(0,0,1);}\n        if(filled(id+vec3(-1,0,0))){nbors++;off+=vec3(-1,0,0);}\n        if(filled(id+vec3(0,-1,0))){nbors++;off+=vec3(0,-1,0);}\n        if(filled(id+vec3(0,0,-1))){nbors++;off+=vec3(0,0,-1);}\n        if(nbors==3.0&&!ifilled)a.x = max(box(q,vec3(0.5)),-(length(q+off*0.5)-1.)*0.6);\n        float hh = h13(id+floor(iTime*0.15));\n        if(nbors==2.0&&!ifilled&&hh>0.33){\n            vec3 p2 = q+off*0.71;\n            p2.xy*=rot((1.0-abs(off.z))*pi/4.);\n            p2.yz*=rot((1.0-abs(off.x))*pi/4.);\n            p2.zx*=rot((1.0-abs(off.y))*pi/4.);\n            float cut = box(p2,vec3(1.0));\n            a.x = max(box(q,vec3(0.5)),-cut*0.6)*0.7;\n        }\n        else if(hh>0.26&&nbors==2.0&&!ifilled)a.x = max(box(q,vec3(0.5)),-(length(q+off*0.5)-1.1)*0.6);\n        \n        if(nbors==2.0&&!ifilled&&off==vec3(0))a.x = box(q,vec3(0.5));\n       // if(nbors==3.0&&!ifilled)a.x = box(q,vec3(0.5));\n    }\n    b.x = p.y;\n    a=(a.x<b.x)?a:b;\n    dc = max(dc,box(po,vec3(4,50,4)));\n    a.x = min(a.x,dc);\n    \n    return a;\n}\nvec3 norm(vec3 p,float s){\n    vec2 e = vec2(s,0);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\nvoid render( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0,6,-13);\n    if(iMouse.z>0.){\n    ro.xz*=rot(10.0*iMouse.x/iResolution.x);\n    }\n    else ro.xz*=rot(iTime*0.3);\n\n    vec3 lk = vec3(0,3.5,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = f*1.1+uv.x*r+uv.y*cross(f,r);\n    rdg = rd;\n    vec3 p = vec3(0);\n    vec2 d = vec2(0);\n    float dO= 0., shad = 0.;\n    bool hit = false;\n    \n    for(float i = 0.0; i<STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        dO+=d.x;\n        if((d.x)<0.005){\n            hit = true;\n            shad = i/STEPS;\n            break;\n        }\n        if(dO>MDIST){\n            break;\n        }\n    }\n    if(hit){\n        vec3 ld = normalize(vec3(0.5,1.01,-1));\n        //ld.xz*=rot(iTime*0.3);\n        vec3 n = norm(p,0.001);\n        vec3 h = normalize(ld-rd);\n        float spec = pow(max(dot(n,h),0.0),5.0);\n        //float fres = pow(1. - max(dot(n, -rd),0.), 5.);\n        float diff = dot(n, ld)*0.4+0.6;\n        vec3 al = vec3(1);\n        ld.xy*=rot(h21(uv)*0.005);\n        ld.yz*=rot(h21(uv+1.)*0.005);\n        ld.zx*=rot(h21(uv+2.)*0.005);\n        float shadow = 1.;\n        rdg = ld;\n        for(float h = 0.05; h<20.;){\n            float dd = map(p+ld*h).x;\n            if(dd<0.001){shadow = 0.6; break;}\n            h+=dd;\n        }\n        //shadow = max(shadow,0.8);\n        \n        //AO & soft shadow doesn't work because of the domain rep tricks, oh well\n        \n        diff -=(h21(uv)-0.4)*(pow(1.0-diff*shadow,9.0))*4.0;\n        col=al*diff+pow(spec,2.0)*0.1*shadow;\n        col*=shadow;\n    }\n    else{\n    col = mix(vec3(0.6),vec3(0.647,0.647,0.694),uv.y);\n    }\n    //col = sqrt(col);\n    fragColor = vec4(col,1.0);\n}\n\n//if you have a very good GPU you can crank up the AA and it looks a lot better\n#if HW_PERFORMANCE==0\n#define AA 1.0\n#else\n#define AA 2.0 \n#endif\n\n#define ZERO min(0.0,iTime)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float px = 1.0/AA;\n    vec4 col = vec4(0);\n    \n    if(AA==1.0) {render(col,fragCoord); fragColor = col; return;}\n    \n    for(float i = ZERO; i <AA; i++){\n        for(float j = ZERO; j <AA; j++){\n            vec4 col2;\n            vec2 coord = vec2(fragCoord.x+px*i,fragCoord.y+px*j);\n            render(col2,coord);\n            col.rgb+=col2.rgb;\n        }\n    }\n    col/=AA*AA;\n    fragColor = vec4(col);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}