{
    "Shader": {
        "info": {
            "date": "1678138633",
            "description": "By what mistake were pigeons made so happy,\nSo plump and fat and sleek and well content,\nSo little with the affairs of others meddling,\nSo little meddled with?\n- James Henry\n\nA fully raymarched scene with iridescent PBR (Pigeon Based Rendering) materials.",
            "flags": 32,
            "hasliked": 0,
            "id": "dljXRz",
            "likes": 62,
            "name": "birb",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "sdf",
                "bird",
                "pbr",
                "irridescent"
            ],
            "usePreview": 1,
            "username": "A_Toaster",
            "viewed": 704
        },
        "renderpass": [
            {
                "code": "#define EPS 0.0005\n#define NORM_EPS (EPS)\n#define SHADOW_BIAS (EPS * 10.)\n#define MAX_DIST 10.\n\n#define PI 3.1415926535\n\nconst vec3 cam_origin = vec3(-0.7, 0.7, 0.);\n\nconst vec3 ambient_boost = vec3(0.2, 0.25, 0.3);\n\nfloat head_dir;\nfloat head_bob;\nfloat body_bob;\n\n// Function prototypes\nvec3 calcNormal( in vec3 pos);\n\n\n// From https://www.shadertoy.com/view/XdsGDB\n// Set up a camera looking at the scene.\nvoid CamPolar( out vec3 pos, out vec3 ray, in vec3 origin, in vec2 rotation, in float distance, in float zoom, in vec2 fragCoord )\n{\n\t// get rotation coefficients\n\tvec2 c = vec2(cos(rotation.x),cos(rotation.y));\n\tvec4 s;\n\ts.xy = vec2(sin(rotation.x),sin(rotation.y)); // worth testing if this is faster as sin or sqrt(1.0-cos);\n\ts.zw = -s.xy;\n\n\t// ray in view space\n\tray.xy = fragCoord.xy - iResolution.xy*.5;\n\tray.z = iResolution.y*zoom;\n\tray = normalize(ray);\n\t\n\t// rotate ray\n\tray.yz = ray.yz*c.xx + ray.zy*s.zx;\n\tray.xz = ray.xz*c.yy + ray.zx*s.yw;\n\t\n\t// position camera\n\tpos = origin - distance*vec3(c.x*s.y,s.z,c.x*c.y);\n}\n\n\n// Noise functions\n// -----------------------------------------------------------------\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (i.xy+vec2(37.0,17.0)*i.z) + f.xy;\n\tvec2 rg = textureLod( iChannel3, (uv+0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n\n// SDF Functions\n// -----------------------------------------------------------------\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat dot2(vec3 p) {\n    return dot(p,p);\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n  // sampling independent computations (only depend on shape)\n  vec3  ba = b - a;\n  float l2 = dot(ba,ba);\n  float rr = r1 - r2;\n  float a2 = l2 - rr*rr;\n  float il2 = 1.0/l2;\n    \n  // sampling dependant computations\n  vec3 pa = p - a;\n  float y = dot(pa,ba);\n  float z = y - l2;\n  float x2 = dot2( pa*l2 - ba*y );\n  float y2 = y*y*l2;\n  float z2 = z*z*l2;\n\n  // single square root!\n  float k = sign(rr)*rr*rr*x2;\n  if( sign(z)*a2*z2>k ) return  sqrt(x2 + z2)        *il2 - r2;\n  if( sign(y)*a2*y2<k ) return  sqrt(x2 + y2)        *il2 - r1;\n                        return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n// Bezier SDF adapted from https://www.shadertoy.com/view/4slSWf\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\n\nvec3 getClosest( vec2 b0, vec2 b1, vec2 b2 , vec2 ends) \n{\n    float a =     det(b0,b2);\n    float b = 2.0*det(b1,b0);\n    float d = 2.0*det(b2,b1);\n    float f = b*d - a*a;\n    vec2  d21 = b2-b1;\n    vec2  d10 = b1-b0;\n    vec2  d20 = b2-b0;\n    vec2  gf = 2.0*(b*d21+d*d10+a*d20); gf = vec2(gf.y,-gf.x);\n    vec2  pp = -f*gf/dot(gf,gf);\n    vec2  d0p = b0-pp;\n    float ap = det(d0p,d20);\n    float bp = 2.0*det(d10,d0p);\n    float t = clamp( (ap+bp)/(2.0*a+b+d), ends.x, ends.y );\n    return vec3( mix(mix(b0,b1,t), mix(b1,b2,t),t), t );\n}\n\nvec2 sdBezier( vec3 a, vec3 b, vec3 c, vec3 p, in vec3 thickness )\n{\n\tvec3 w = normalize( cross( c-b, a-b ) );\n\tvec3 u = normalize( c-b );\n\tvec3 v = normalize( cross( w, u ) );\n\n\tvec2 a2 = vec2( dot(a-b,u), dot(a-b,v) );\n\tvec2 b2 = vec2( 0.0 );\n\tvec2 c2 = vec2( dot(c-b,u), dot(c-b,v) );\n\tvec3 p3 = vec3( dot(p-b,u), dot(p-b,v), dot(p-b,w) );\n\n\tvec3 cp = getClosest( a2-p3.xy, b2-p3.xy, c2-p3.xy, vec2(0., 1.) );\n    // Thickness at point\n    float t = mix(mix(thickness.x, thickness.y, cp.z), mix(thickness.y, thickness.z, cp.z), cp.z);\n\treturn vec2( 0.85*(sqrt(dot(cp.xy,cp.xy)+p3.z*p3.z) - t), cp.z );\n}\n\n// Bezier with extended end points\nvec2 sdBezierEnds( vec3 a, vec3 b, vec3 c, vec3 p, in vec3 thickness, in vec2 ends)\n{\n\tvec3 w = normalize( cross( c-b, a-b ) );\n\tvec3 u = normalize( c-b );\n\tvec3 v = normalize( cross( w, u ) );\n\n\tvec2 a2 = vec2( dot(a-b,u), dot(a-b,v) );\n\tvec2 b2 = vec2( 0.0 );\n\tvec2 c2 = vec2( dot(c-b,u), dot(c-b,v) );\n\tvec3 p3 = vec3( dot(p-b,u), dot(p-b,v), dot(p-b,w) );\n\n\tvec3 cp = getClosest( a2-p3.xy, b2-p3.xy, c2-p3.xy, ends);\n    // Thickness at point\n    float t = mix(mix(thickness.x, thickness.y, cp.z), mix(thickness.y, thickness.z, cp.z), cp.z);\n\n\treturn vec2( 0.85*(sqrt(dot(cp.xy,cp.xy)+p3.z*p3.z) - t), cp.z );\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n\nfloat opS( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opI( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opU( float d1, float d2 ) { return min(d1, d2); }\n\nvec2 opUMix(vec2 d1, vec2 d2){\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\n// polynomial smooth min\nfloat opSU( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \n// Smooth min returning mix factor\nvec2 opSUMix( float a, float b, float k ) {\n    float h = max( k-abs(a-b), 0.0 )/k;\n    float m = h*h*0.5;\n    float s = m*k*(1.0/2.0);\n    return (a<b) ? vec2(a-s,m) : vec2(b-s,1.0-m);\n}\n\nvec2 opSUMix( vec2 a, vec2 b, float k ) {\n    float h = clamp( 0.5 + 0.5*(a.x-b.x)/k, 0.0, 1.0 );\n    \n    float d =  mix( a.x, b.x, h ) - k*h*(1.0-h);\n    \n    return vec2(d, mix(a.y, b.y, h));\n}\n\nfloat opSS( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSI( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nvec3 opMirrorZ(vec3 p){\n    return vec3(p.x, p.y, abs(p.z));\n}\n\n\nvec3 opRotY(vec3 p, float a) {\n    mat3 m = mat3(\n        cos(a),  0, sin(a),\n        0,       1, 0,\n        -sin(a), 0, cos(a));\n    return p * m;\n}\n\nvec3 opRotZ(vec3 p, float a) {\n    mat3 m = mat3(\n        cos(a), -sin(a), 0,\n        sin(a),  cos(a), 0,\n        0,       0,      1);\n    return p * m;\n}\n\nvec3 opRotX(vec3 p, float a) {\n    mat3 m = mat3(\n        1, 0,       0,\n        0, cos(a), -sin(a),\n        0, sin(a),  cos(a));\n    return p * m;\n}\n// Pedestal SDF\n// -----------------------------------------------------------------\n\nfloat pedestal_ridges(vec3 p) {\n    p.xz = abs(p.xz);\n    return min(\n        sdVerticalCapsule(p - vec3(0.7, -3.5, 1.), 3., 0.15),\n        sdVerticalCapsule(p - vec3(1., -3.5, 0.7), 3., 0.15)\n    );\n}\n\n\nfloat ground_displacement(vec3 p) {\n    const mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n    vec3 q2 = p * 40.;\n    float f2 = noise( q2 ); q2 = m*q2*2.03;\n    f2 += 0.5*noise( q2 ); q2 = m*q2*2.04;\n    f2 += 0.25*noise( q2 ); q2 = m*q2*2.05;\n    f2 += 0.125*noise( q2 );\n    //f2 = f2 * f2 * (2. - f2);\n    \n    return f2 * 0.125;\n}\n\n\nfloat ground(vec3 p) {\n    vec3 q = p + vec3(0., 0.10, 0.);\n    float d = opSU(\n        opSU(\n            sdBox(q, vec3(1.01, 0.1, 1.01)),\n            sdBox(q + vec3(0., 0.15, 0.), vec3(.95, 0.1, .95)),\n            0.05\n        ),\n        opSU(\n            sdBox(q + vec3(0., 2., 0.), vec3(0.85, 2., 0.85)),\n            opSS(\n                pedestal_ridges(q),\n                sdBoxFrame(q + vec3(0., 2., 0.), vec3(0.9, 2., 0.9), 0.2),\n                0.005\n            ),\n            0.03\n        ),\n        0.09\n    );\n    \n    // Calculate displacement if very close\n    if(d < 0.1)\n        d -= 0.002 * ground_displacement(p) + 0.01;\n    // Otherwise decrease distance a bit to avoid overshoot\n    else d -= .02;\n    return d;\n}\n\n// Bird SDF\n// -----------------------------------------------------------------\nfloat feather(vec3 p) {\n    float d1 = noise(p * 20.);\n    \n    const mat3 m = mat3( 0.00,  0.80,  0.60,\n                -0.80,  0.36, -0.48,\n                -0.60, -0.48,  0.64 );\n                    \n    vec3 q2 = p + vec3(0., 0.2, 0.);\n    q2 *= mat3(-1., 1., 0.,\n              1., 1., 0.,\n              0., 0., 1.);\n    float sf = q2.y * q2.y + q2.z * q2.z;\n    \n    q2 = vec3(q2.x * 20., atan(q2.y, q2.z) * 80., 0.);\n    \n    float f0 = fract(q2.x * -0.2 + q2.y * -0.05 + d1 * 0.4);\n    float f1 = fract(q2.x * -0.2 + q2.y * 0.05 + d1 * 0.7);\n    \n    float f2 = noise( q2 ); q2 = m*q2*2.03;\n    f2 += 0.5*noise( q2 ); q2 = m*q2*2.04;\n    \n    float f = f0 - smoothstep(0.9, 1., f0) + f1 - smoothstep(0.9, 1., f1);\n    return (f2 * (f + 0.1) * 8. + f) * sqrt(sf) ;\n}\n\n\n\n// Fast voronoi-ish, credit to https://www.shadertoy.com/view/4lSXzh\nfloat voronesque( in vec3 p ) {\n    // Skewing the cubic grid, then determining the first vertex.\n    vec3 i  = floor(p + dot(p, vec3(.333333)) );  p -= i - dot(i, vec3(.166666)) ;\n\n    // Breaking the skewed cube into tetrahedra with partitioning planes, then determining which side of the \n    // intersecting planes the skewed point is on. Ie: Determining which tetrahedron the point is in.\n    vec3 i1 = step(p.yzx, p), i2 = max(i1, 1. - i1.zxy); i1 = min(i1, 1. - i1.zxy);    \n    \n    // Using the above to calculate the other three vertices. Now we have all four tetrahedral vertices.\n    vec3 p1 = p - i1 + .166666, p2 = p - i2 + .333333, p3 = p - .5;\n    \n    vec3 rnd = vec3(7, 157, 113); // I use this combination to pay homage to Shadertoy.com. :)\n    \n    // Falloff values from the skewed point to each of the tetrahedral points.\n    vec4 v = max(0.5 - vec4(dot(p, p), dot(p1, p1), dot(p2, p2), dot(p3, p3)), 0.);\n    \n    // Assigning four random values to each of the points above. \n    vec4 d = vec4( dot(i, rnd), dot(i + i1, rnd), dot(i + i2, rnd), dot(i + 1., rnd) ); \n    \n    // Further randomizing \"d,\" then combining it with \"v\" to produce the final random falloff values. \n    // Range [0, 1]\n    d = fract(sin(d)*262144.)*v*2.; \n \n    // Reusing \"v\" to determine the largest, and second largest falloff values. Analogous to distance.\n    v.x = max(d.x, d.y), v.y = max(d.z, d.w), v.z = max(min(d.x, d.y), min(d.z, d.w)), v.w = min(v.x, v.y); \n   \n    // Maximum minus second order, for that beveled Voronoi look. Range [0, 1].\n    return  max(v.x, v.y) - max(v.z, v.w);  \n}\n\nvec2 neck(vec3 p){\n    return sdBezierEnds(\n        vec3(-1.25, 0.75, 0.), \n        vec3(-1.35, 1.00, 0.), \n        vec3(-1.35, 1.20, 0.),\n        p * vec3(1., 1., 1.15),\n        vec3(0.2, 0.18, 0.05), vec2(-0.15, 1.15)\n        );\n}\n\nfloat leg_displacement( in vec3 p ){\n    return smoothstep(0., 0.2, voronesque(p * 35.));\n}\n\n\nvec2 legs(vec3 p) {\n    vec3 q = opMirrorZ(p);\n    // leg\n    float d = sdRoundCone(q, vec3(-0.9, 0.125, 0.1), vec3(-0.98, 0.03, 0.15), 0.02, 0.015);\n    \n    // First toe segment\n    \n    // middle toe\n    d = opSU(d, sdRoundCone(q, vec3(-0.98, 0.03, 0.15), vec3(-1.05, 0.015, 0.15), 0.013, 0.012), 0.01);\n    \n    // inner toe\n    d = opSU(d, sdRoundCone(q, vec3(-0.98, 0.03, 0.15), vec3(-1.04, 0.01, 0.10), 0.013, 0.010), 0.01);\n    \n    // outer toe\n    d = opSU(d, sdRoundCone(q, vec3(-0.98, 0.03, 0.15), vec3(-1.04, 0.01, 0.20), 0.011, 0.010), 0.01);\n    \n    // rear toe\n    d = opSU(d, sdRoundCone(q, vec3(-0.98, 0.03, 0.15), vec3(-0.94, 0.025, 0.14), 0.010, 0.011), 0.01);\n    \n    // Remainder of toes\n    \n    // middle toe\n    d = opU(d, sdRoundCone(q, vec3(-1.05, 0.015, 0.15), vec3(-1.06, -0.025, 0.15), 0.010, 0.010));\n    d = opU(d, sdRoundCone(q, vec3(-1.06, -0.025, 0.15), vec3(-1.05, -0.05, 0.15), 0.009, 0.011));\n    // inner toe\n    d = opU(d, sdRoundCone(q, vec3(-1.04, 0.01, 0.10), vec3(-1.05, -0.02, 0.090), 0.008, 0.010));\n    d = opU(d, sdRoundCone(q, vec3(-1.05, -0.02, 0.090), vec3(-1.04, -0.04, 0.087), 0.008, 0.010));\n    // outer toe\n    d = opU(d, sdRoundCone(q, vec3(-1.04, 0.01, 0.20), vec3(-1.05, -0.02, 0.209), 0.008, 0.010));\n    d = opU(d, sdRoundCone(q, vec3(-1.05, -0.02, 0.209), vec3(-1.04, -0.04, 0.213), 0.008, 0.010));\n    //rear toe\n    d = opU(d, sdRoundCone(q, vec3(-0.94, 0.025, 0.14), vec3(-0.91, 0.024, 0.135), 0.010, 0.011));\n    \n    // thigh\n    vec2 d_mix = opSUMix(sdEllipsoid(q - vec3(-0.9, 0.25, 0.12), vec3(0.15, 0.1, 0.05)), d, 0.05);\n    \n    float displacement = leg_displacement(p);\n    d_mix.x -= displacement * smoothstep(0.9, 1., d_mix.y) * 0.001;\n    return d_mix;\n}\n\nfloat claws(vec3 p){\n    vec3 q = opMirrorZ(p);\n    // front middle\n    float d = sdBezier(\n            vec3(-1.05, -0.05, 0.15), vec3(-1.05, -0.07, 0.15), vec3(-1.03, -0.08, 0.15), \n            q, \n            vec3(0.008, 0.008, 0.0005)\n        ).x;\n    // Front inner\n    d = opU(d, sdBezier(\n            vec3(-1.04, -0.04, 0.087), vec3(-1.04, -0.055, 0.087), vec3(-1.02, -0.065, 0.087), \n            q, \n            vec3(0.008, 0.008, 0.0005)\n        ).x);\n    \n    // Front outer\n    d = opU(d, sdBezier(\n            vec3(-1.04, -0.04, 0.213), vec3(-1.04, -0.055, 0.213), vec3(-1.02, -0.065, 0.213), \n            q, \n            vec3(0.008, 0.008, 0.0005)\n        ).x);\n    \n    // Rear\n    d = opU(d, sdBezier(\n            vec3(-0.91, 0.024, 0.135), vec3(-0.885, 0.024, 0.135), vec3(-0.87, 0.005, 0.135), \n            q, \n            vec3(0.008, 0.008, 0.0005)\n        ).x);\n    \n    return d;\n}\n\nfloat beak(vec3 p){\n\n    //return sdEllipsoid(opRotZ(p - vec3(-1.53, 1.2, 0.), -0.4), vec3(0.1, 0.03, 0.02));\n    float d = sdBezier(\n            vec3(-1.53, 1.2, 0.), vec3(-1.60, 1.17, 0.), vec3(-1.62, 1.14, 0.), \n            p * vec3(1., 1., 1.5), \n            vec3(0.025, 0.03, 0.001)\n        ).x;\n    // Subtract nostrils\n    d = opSS(sdEllipsoid(opRotZ(opMirrorZ(p) - vec3(-1.58, 1.19, 0.015), -0.4), vec3(0.01, 0.005, 0.005)),\n        d, 0.005);\n    \n    float line = sdBezier(\n            vec3(-1.53, 1.2, 0.), vec3(-1.60, 1.17, 0.), vec3(-1.62, 1.135, 0.), \n            p * vec3(1., 1., 0.1), \n            vec3(0.01, 0.01, 0.01)\n        ).x;\n    line = smoothstep(0.001, 0.02, -line);\n    \n    return d + line * 0.01;\n}\n\nfloat cere(vec3 p){\n    return sdEllipsoid(opRotZ(opMirrorZ(p) - vec3(-1.54, 1.212, 0.010), -0.3), vec3(0.04, 0.02, 0.02));\n}\n\nvec3 eye_xform(vec3 p) {\n    return opRotX(opRotY(opRotZ(opMirrorZ(p) - vec3(-1.46, 1.27, 0.061), -0.4), 0.25), 0.1);\n}\n\nfloat eyes(vec3 p){\n    return sdEllipsoid(eye_xform(p), vec3(0.035, 0.035, 0.02));\n}\n\nvec2 sdFeather(vec3 p, float l) {\n    return vec2(sdEllipsoid(p, vec3(l, 0.03, 0.1)), p.x);\n}\n\nvec2 tail(vec3 p){\n    vec3 q = opRotZ(opMirrorZ(p), 0.43);\n    \n    vec2 d = sdFeather(opRotX(opRotY(q, 0.1), -0.25) - vec3(-0.35, 0.2, 0.06), 0.5);\n    d = opUMix(d, sdFeather(opRotX(opRotY(q, 0.05), -0.125) - vec3(-0.3, 0.21, 0.04), 0.5));\n    d = opUMix(d, sdFeather(q - vec3(-0.28, 0.22, 0.02), 0.5));\n    return d;\n}\n\nvec2 wings(vec3 p){\n    vec3 q = opRotZ(opMirrorZ(p), 0.33);\n    // offset\n    q.y -= 0.1;\n    //bend\n    q = vec3(q.x, q.y, q.z + 1.1 * q.y * q.y);\n    \n    // base of wing\n    float d = sdEllipsoid(q - vec3(-1.15, 0.12, 0.24), vec3(0.35, 0.30, 0.08));\n    \n    q = opRotY(q, -0.05);\n    // first set of feathers\n    d = opSU(d, sdEllipsoid(q - vec3(-0.98, 0.10, 0.205), vec3(0.35, 0.25, 0.05)), 0.05);\n    \n    q = opRotY(q, -0.05);\n    // second set of feathers\n    d = opSU(d, sdEllipsoid(q - vec3(-0.8, 0.12, 0.18), vec3(0.25, 0.18, 0.04)), 0.05);\n\n    // final pointy feathers\n    float d2 = sdEllipsoid(opRotZ(q, -0.1) - vec3(-0.6, 0.18, 0.17), vec3(0.6, 0.11, 0.04));\n    d2 = opSU(d2, sdEllipsoid(opRotZ(q, -0.25) - vec3(-0.5, 0.18, 0.17), vec3(0.6, 0.07, 0.03)), 0.02);\n    \n    vec2 d_co = opSUMix(vec2(d, q.x), vec2(d2, 0.), 0.005);\n    \n    return d_co;\n}\n\nfloat birb(vec3 p){\n    // Neck/head\n    float d = neck(p).x;\n    \n    d = opSU(d, sdEllipsoid(p - vec3(-1.31, 0.80, 0.), vec3(0.18, 0.28, 0.18)), 0.07);\n    \n    // Body\n    float body = sdBezierEnds(\n            vec3(-0.15, 0.25, 0.), vec3(-0.45, 0.3, 0.), vec3(-0.85, 0.45, 0.), \n            p * vec3(1., 1., 1.15), \n            vec3(0.05, 0.27, 0.3), vec2(-0.1, 1.1)\n        ).x;\n    body = opSU(body, sdBezierEnds(\n            vec3(-0.85, 0.45, 0.), vec3(-1.15, 0.55, 0.), vec3(-1.25, 0.90, 0.), \n            p * vec3(1., 1., 1.25), \n            vec3(0.3, 0.4, 0.15), vec2(-0.5, 1.2)\n        ).x, 0.07);\n    \n    \n    d = opSU(d, body, 0.1);\n    \n    \n    // Head\n    d = opSU(d, sdEllipsoid(opRotZ(p - vec3(-1.33, 1.15, 0.), -0.1), vec3(0.12, 0.18, 0.09)), 0.1);\n    d = opSU(d, sdEllipsoid(p - vec3(-1.41, 1.25, 0.), vec3(0.14, 0.12, 0.10)), 0.07);\n    // Depressions on head for eyes\n    d = opSS(\n        sdEllipsoid(opRotY(opRotZ(opMirrorZ(p) - vec3(-1.42, 1.28, 0.13), -0.4), 0.25), vec3(0.1, 0.02, 0.03)),\n        d, 0.07);\n        \n    // Eye socket\n    d = opSS(\n        sdEllipsoid(opRotY(opRotZ(opMirrorZ(p) - vec3(-1.46, 1.27, 0.085), -0.4), 0.25), vec3(0.035, 0.030, 0.02)),\n        d, 0.005);\n        \n        \n    // Tail feathers\n    d = opSU(d, tail(p).x, 0.05);\n    \n    // wings - attached more smoothly at top\n    d = opSU(d, wings(p).x, 0.04 * smoothstep(0.65, 0.9, p.y));\n    \n    float f = feather(p);\n    d -= f * 0.0002;\n    \n    // Beak\n    d = opSU(d, beak(p), 0.04);\n    //cere\n    d = opSU(d, cere(p), 0.005);\n    \n\n   \n    //eyes\n    d = opU(d, eyes(p));\n    \n    // Legs\n    d = opSU(d, legs(p).x, 0.1);\n    \n    //claws\n    d = opU(d, claws(p));\n    \n    return d;\n}\n\nvec3 head_twist(vec3 p, float twist, float bob, float breath) {\n    vec3 neck_origin = vec3(-1.30, 1.20, 0.);\n    vec3 q = p - neck_origin;\n    float twist_fac = smoothstep(-0.33, -0.05, q.y);\n    float breath_fac = clamp((p.y - 0.04) * 10., 0., 1.);\n    twist_fac = 0.1 * breath_fac + 0.9 * twist_fac;\n    q = opRotY(q, twist_fac * twist);\n    q -= vec3(0., bob * twist_fac + breath * breath_fac, 0.);\n    return q + neck_origin;\n}\n\nfloat map(vec3 p) {\n    return min(\n        ground(p),\n        birb(head_twist(p, head_dir, head_bob, body_bob))\n    );\n}\n\n\nfloat marble(vec3 p) {\n    const mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n                    \n    vec3 q1 = p;\n    \n    float f1 = 0.5000*noise( q1 ); q1 = m*q1*2.01;\n    f1 += 0.2500*noise( q1 ); q1 = m*q1*2.02;\n    f1 += 0.1250*noise( q1 ); q1 = m*q1*2.03;\n    f1 = smoothstep(0.5, 0.6, f1);\n    f1 = pow(4.0*f1*(1.0-f1), 2.);\n    \n    return f1;\n}\n\nvec3 eye_albedo(vec3 p){\n    vec2 q = eye_xform(p).xy;\n    \n    float r = length(q);\n    float t = atan(q.x, q.y);\n    \n    float pupil = smoothstep(-0.015, -0.01, -r);\n    float iris = smoothstep(-0.03, 0., -r);\n    \n    vec3 iris_col = mix(vec3(0.1, 0.05, 0.), vec3(0.3, 0.2, 0.), iris);\n    \n    return mix(iris_col, vec3(0.02), pupil);\n}\n\nvoid material(in vec3 p, out vec3 albedo, out float roughness, out float ao, out float metallic, out float film_thickness, out float sss, out vec3 normal) {\n    \n    normal = calcNormal(p);\n    \n    float ground = ground(p);\n    \n    vec3 p2 = head_twist(p, head_dir, head_bob, body_bob);\n    float birb = birb(p2);\n    \n    if(ground < birb) {\n        // Ground material\n        float d = clamp(ground_displacement(p) * 5., 0., 1.);\n        d = pow(1. - d, 2.);\n        float c = marble(p * vec3(2., 0.5, 2.))\n            + marble(p * vec3(5., 1., 5.));\n        c = clamp(c, 0., 1.);\n        albedo = vec3(0.23, 0.23, 0.23);\n        roughness = mix(0.65, 0.6, c);\n        ao = mix(1., 0.7, d);\n        metallic = c * 0.3;\n        film_thickness = 0.;\n        sss = 0.;\n    } else {\n        // birb material\n        sss = 0.2;\n        float neck_dist = neck(p2).y;\n        //float neck_dist = clamp(p.y - 0.75, 0., 1.);\n        float irridescent = smoothstep(0.0, 0.4, neck_dist) * (1. - smoothstep(0.7, 0.9, neck_dist));\n        \n        // head material factor\n        float head = smoothstep(0.66, 0.8, p2.y);\n        // legs material factor\n        float legs = smoothstep(0.9, 1., legs(p2).y);\n        float leg_d = leg_displacement(p2);\n        vec3 leg_albedo = mix(vec3(0.3, 0.22, 0.22), vec3(0.3, 0.15, 0.08), leg_d);\n        float leg_roughness = mix(0.9, 0.65, leg_d);\n        \n        // beak material factor (Also claw material)\n        float beak = smoothstep(-0.01, 0., -beak(p2));\n        beak += smoothstep(-0.001, 0., -claws(p2));\n        vec3 beak_albedo = vec3(0.04, 0.04, 0.04);\n        float beak_roughness = 0.72;\n        \n        float cere = smoothstep(-0.002, 0., -cere(p2));\n        vec3 cere_albedo = vec3(0.21,0.2,0.2);\n        float cere_roughness = 0.9;\n        \n        float eyes = smoothstep(-0.001, -0.0009, -eyes(p2));\n        vec3 eye_albedo = eye_albedo(p2);\n        float eye_roughness = 0.0;\n        \n        vec3 dark_feather_albedo = mix(vec3(0.04), vec3(0.025), p2.y * 2.);\n        \n        vec2 tail = tail(p2);\n        tail = vec2(smoothstep(-0.08, -0.01, -tail.x), smoothstep(0.2, 0.3, tail.y));\n        vec3 tail_albedo = mix(vec3(0.08,0.10,0.13), dark_feather_albedo, tail.y);\n        \n        vec2 wing = wings(p2);\n        wing.x = smoothstep(-0.02, 0., -wing.x);\n        \n        \n        float f = abs(sin(p2.y * 25.)) - 0.5;\n        float py2 = p2.y * p2.y;\n        float b1 = wing.y + 0.5 * py2 - 0.65 * p2.y - 0.01 * f;\n        float b2 = wing.y + 0.5 * py2 - 0.65 * p2.y - 0.05 * f;\n        float b3 = wing.y - 1.3 * p2.y + 1. * py2 - 0.01 * f;\n        float b4 = wing.y - 1.6 * p2.y + 1. * py2 - 0.05 * f;\n    \n        \n        \n        wing.y = smoothstep(-0.1, -0.0, wing.y);\n        wing.y += smoothstep(-1.4, -1.38, b3) - smoothstep(-1.45, -1.4, b4);\n        wing.y += smoothstep(-1.02, -1., b1) - smoothstep(-0.9, -0.85, b2);\n        \n        wing.y = smoothstep(0., 1., wing.y);\n        \n        vec3 wing_albedo = mix(vec3(0.13,0.16,0.16), dark_feather_albedo, wing.y);\n        \n        \n        albedo = mix(vec3(0.11,0.14,0.15), vec3(0.037, 0.06, 0.08), head);\n        albedo = mix(albedo, leg_albedo, legs);\n        albedo = mix(albedo, beak_albedo, beak);\n        albedo = mix(albedo, cere_albedo, cere);\n        albedo = mix(albedo, cere_albedo, cere);\n        albedo = mix(albedo, eye_albedo, eyes);\n        albedo = mix(albedo, tail_albedo, tail.x);\n        albedo = mix(albedo, wing_albedo, wing.x);\n        \n        roughness = mix(0.82, leg_roughness, legs);\n        roughness = mix(roughness, beak_roughness, beak);\n        roughness = mix(roughness, cere_roughness, cere);\n        roughness = mix(roughness, eye_roughness, eyes);\n        \n        \n        sss += 0.3 * beak + 0.3 * cere;\n        \n        \n        ao = 1.;\n        metallic = irridescent * 0.7;\n        film_thickness = mix(13.5, 7.5, neck_dist);\n    }\n    \n}\n\n// Raymarching functions\n// -----------------------------------------------------------------\nbool intersect( in vec3 ro, in vec3 rd, out float dist )\n{\n\tfloat h = 1.0;\n\tdist = 0.0;\n    for( int i=0; i<128; i++ )\n    {\n\t\tif( h < EPS * dist) return true;\n\t\th = map(ro + rd * dist);\n        dist += h * 0.9;\n\t\tif( dist > MAX_DIST) return false;\n    }\n\treturn false;\n}\n\nfloat softShadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n\tfloat h = 1.0;\n    for( int i=0; i<32; i++ )\n    {\n        h = map(ro + rd*t);\n        res = min( res, k*h/t );\n\t\tt += clamp( h, 0.005, 0.5 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\n\n// From https://iquilezles.org/articles/normalsSDF/\nvec3 calcNormal( in vec3 pos)\n{\n    const float h = NORM_EPS;\n    #define ZERO (min(iFrame,0)) // non-constant zero\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+e*h);\n    }\n    return normalize(n);\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 1.0*occ, 0.0, 1.0 ) * (0.8+0.2*nor.y);\n}\n\n\n//Tonemapping\n// -----------------------------------------------------------------\n\n// linear to tonemapped\nvec3 ACES(vec3 x) {\n    return x*(2.51*x + .03) / (x*(2.43*x + .59) + .14); // https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n}\n\n// tonemapped to linear\nvec3 ACES_Inv(vec3 x) {\n    return (sqrt(-10127.*x*x + 13702.*x + 9.) + 59.*x - 3.) / (502. - 486.*x); // thanks to https://www.wolframalpha.com/input?i=2.51y%5E2%2B.03y%3Dx%282.43y%5E2%2B.59y%2B.14%29+solve+for+y\n}\n\n\n\n// Rendering functions\n// -----------------------------------------------------------------\n// https://learnopengl.com/PBR/Theory\n\n// Irridescent thin film interference effect\nvec3 thinFilm(float ndotv, float thickness, float metallic) {\n    // Relative wavelengths of each component\n    const vec3 freqs = vec3(700./435., 565./435., 1.);\n    const float ior = 2.;\n    float n2 = sin(acos(ndotv)) / ior;\n    float cos2 = cos(asin(n2));\n    float dist = thickness / cos2;\n    \n    // Strength of thin film effect is controlled by reflection angle\n    // and mettalicity of material.\n    // Power to make irridescence stronger\n    float strength = pow(metallic * ndotv, 0.2);\n    \n    vec3 rgb = (cos(dist * freqs) *strength * 0.5) + vec3(0.5);\n    return rgb;\n}\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a      = roughness*roughness;\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float num   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\t\n    return num / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float num   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return num / denom;\n}\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\t\n    return ggx1 * ggx2;\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)\n{\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);\n}\n\nvec3 light(\n    vec3 light_dir, vec3 light_col, vec3 normal, vec3 rd, float attenuation,\n    vec3 albedo, float roughness, float metallic, vec3 F0, float film_thickness, float sss\n) {\n        // Shading calculations\n        vec3 V = -rd; // Camera direction\n        vec3 H = normalize(light_dir - rd);\n        \n        float ndotl = max(dot(normal, light_dir), 0.);\n        float hdotv = max(dot(H, V), 0.);\n        float ndotv = max(dot(normal, V), 0.);\n        \n        vec3 radiance = light_col * attenuation;\n        \n        vec3 F = fresnelSchlickRoughness(hdotv, F0, roughness);\n        F *= thinFilm(ndotv, film_thickness, metallic);\n        \n        \n        float NDF = DistributionGGX(normal, H, roughness);\n        float G   = GeometrySmith(normal, V, light_dir, roughness);\n        \n        vec3 numerator    = NDF * G * F;\n        float denominator = 4.0 * ndotv * ndotl  + 0.0001;\n        vec3 specular     = numerator / denominator; \n        \n        vec3 kS = F;\n        vec3 kD = vec3(1.0) - kS;\n\n        kD *= 1.0 - metallic;\n        \n        return (kD * albedo / PI + specular) * radiance * max((dot(normal, light_dir) + sss) / (1. + sss), 0.);;\n}\n\nvec3 ambient(\n    vec3 normal, vec3 rd, float ao,\n    vec3 albedo, float roughness, float metallic, vec3 F0, float film_thickness\n) {\n    vec3 V = -rd;\n    vec3 F = fresnelSchlickRoughness(max(dot(normal, V), 0.0), F0, roughness);\n    \n    vec3 R = reflect(-V, normal);\n    \n    F *= thinFilm(dot(V, normal), film_thickness, metallic);\n    // Diffuse\n    vec3 kS = F;\n    vec3 kD = 1.0 - kS;\n    vec3 irradiance = textureLod(iChannel1, normal.zyx, 4.8).rgb + ambient_boost;\n    vec3 diffuse    = irradiance * albedo;\n    \n    //Specular\n    const float MAX_REFLECTION_LOD = 16.0;\n    vec3 prefilteredColor = textureLod(iChannel0, R.zyx,  roughness * MAX_REFLECTION_LOD + 1.).rgb;  \n    \n    \n    vec2 envBRDF  = texelFetch(iChannel2, ivec2(vec2(max(dot(normal, V), 0.0), roughness) / vec2(255.)), 0).rg;\n    vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y) * albedo;\n    \n    return (kD * diffuse + specular) * ao;\n}\n\n// -----------------------------------------------------------------\n\n// Animation functions\nfloat gain(float x, float k) \n{\n    float a = 0.5*pow(2.0*((x<0.5)?x:1.0-x), k);\n    return (x<0.5)?a:1.0-a;\n}\n\nfloat parabola( float x, float k )\n{\n    return pow( 4.0*x*(1.0-x), k );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 ro, rd;\n    \n    vec2 camRot = vec2(2.,3.5)+vec2(-4.,7.)*(iMouse.yx/iResolution.yx);\n    if(iMouse.xy == vec2(0., 0.)){\n        camRot = vec2(-0.2 + 0.05 * cos(iTime * 0.3), 0.9 + 0.08 * sin(iTime * 0.5));\n    }\n    \n    CamPolar(ro, rd,\n             cam_origin, // Origin\n             camRot, // Rotation\n             3., // Distance\n             1.2, //Zoom\n             fragCoord);\n    \n    head_dir = 0.01 * sin(iTime * 2.5);\n    \n    float st = sin(iTime * 0.3);\n    st = st * st * st * st;\n    \n    \n    head_dir += (gain(st, 30.) - 0.5) * 1.;\n    \n    head_bob = -0.05 * parabola(st, 80.);\n    body_bob = 0.005 * sin(iTime * 2.);\n    \n    vec3 sun_dir = normalize(vec3(-0.25, 1., -1.));\n    vec3 sun_color = vec3(25., 22., 20.);\n    \n    float dist;\n    \n    vec3 color;\n    if (intersect(ro, rd, dist)) {\n        //Foreground object\n        vec3 hit_pt = ro + rd * dist;\n        \n        // Get material\n        vec3  albedo; // Subsurface color\n        float roughness;\n        float ao;          // Microsurface AO\n        float metallic;\n        float film_thickness;\n        float sss; // Subsurf. scattering\n        vec3 normal;\n        \n        material(hit_pt, albedo, roughness, ao, metallic, film_thickness, sss, normal);\n        \n        // Square roughness\n        roughness = roughness * roughness;\n        \n        vec3 F0 = mix(vec3(0.04), albedo, metallic);\n        \n        // Calculate AO and shadows\n        \n        ao = ao * calcAO(hit_pt, normal);\n        float shadow = softShadow(hit_pt + normal * dist * SHADOW_BIAS, sun_dir, 0.01, 6.);\n        float attenuation = shadow * ao;\n        \n        \n        // Shading calculations\n        vec3 Lo = light(sun_dir, sun_color, normal, rd, attenuation, albedo, roughness, metallic, F0, film_thickness, sss);\n        vec3 ambient = ambient(normal, rd, ao, albedo, roughness, metallic, F0, film_thickness);\n        \n        color = Lo + ambient * 3.;\n        color = ACES(color);\n\n        fragColor = vec4(color, 1.);\n    } else {\n        //Background\n        fragColor.rgb = textureLod(iChannel0, rd.zyx, 1.4).rgb;\n    }\n    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Pre-calculated BRDF LUT for reflections\n\n#define PI 3.14159265359\n#define INV_PI 0.31830988618\n#define INV_SQRT_PI 0.56418958354\n\nvec2 SampleEquirectangular(vec3 dir)\n{\n    vec2 uv = vec2(atan(dir.z, dir.x), asin(dir.y));\n    uv *= vec2(0.1591, 0.3183);\n    uv += 0.5;\n    return uv;\n}\n\nvec3 F_Schlick(float NoV, vec3 F0, float roughness)\n{\n\treturn F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - NoV, 5.0);\n}\n\nfloat D_GGX(float NoH, float roughness)\n{\n\tfloat a = roughness * roughness;\n    float a2 = a * a;\n    float nom = a2;\n    float denom = (NoH * NoH * (a2 - 1.0) + 1.0);\n\tdenom = PI * denom * denom;\n    \n    return nom / denom;\n}\n\nfloat G_SmithIBL(float roughness, float NoL, float NoV)\n{\n\tfloat k = roughness * roughness * 0.5;\n    return (NoL * NoV) / ((k + NoV * (1.0 - k)) * (k + NoL * (1.0 - k)));\n}\n\nfloat G_SmithDirect(float roughness, float NoL, float NoV)\n{\n\tfloat k = (roughness + 1.0) * (roughness + 1.0) * 0.125;\n    return (NoL * NoV) / ((k + NoV * (1.0 - k)) * (k + NoL * (1.0 - k)));\n}\n\nvec3 ImportanceSampleGGX(vec2 Xi, float roughness, vec3 n)\n{\n\tfloat a = roughness * roughness;\n    float phi = 2.0 * PI * Xi.x;\n\tfloat cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a * a - 1.0) * Xi.y));\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n    \n    vec3 h;\n    h.x = sinTheta * cos(phi);\n    h.y = sinTheta * sin(phi);\n    h.z = cosTheta;\n    \n    vec3 up = abs(n.z) < 0.999 ? vec3(0, 0, 1) : vec3(1, 0, 0);\n    vec3 tangentX = normalize(cross(up, n));\n    vec3 tangentY = cross(n, tangentX);\n    return tangentX * h.x + tangentY * h.y + n * h.z;\n}\n\nvec2 Hammersley(uint i, uint N)\n{\n    uint bits = i;\n    bits = (bits << 16u) | (bits >> 16u);\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n    float inv = float(bits) * 2.3283064365386963e-10;\n\treturn vec2(float(i)/float(N), inv);\n}\n\n\nvec2 IntegrateBRDF(float roughness, float NoV)\n{\n\tvec3 v;\n    v.x = sqrt(1.0 - NoV * NoV);\n    v.y = 0.0;\n    v.z = NoV;\n    \n    float A = 0.0;\n    float B = 0.0;\n    \n    vec3 n = vec3(0.0, 0.0, 1.0);\n    \n    const uint numSamples = 1024u;\n    for (uint i = 0u; i < numSamples; i++)\n    {\n    \tvec2 Xi = Hammersley(i, numSamples);\n        vec3 h = ImportanceSampleGGX(Xi, roughness, n);\n        vec3 l = 2.0 * dot(v, h) * h - v;\n        \n        float NoL = clamp(l.z, 0.0, 1.0);\n        float NoH = clamp(h.z, 0.0, 1.0);\n        float VoH = clamp(dot(v, h), 0.0, 1.0);\n        \n        if (NoL > 0.0)\n        {\n            float G = G_SmithIBL(roughness, NoL, NoV);\n            float G_Vis = G * VoH / (NoH * NoV);\n            float Fc = pow(1.0 - VoH, 5.0);\n            A += (1.0 - Fc) * G_Vis;\n            B += Fc * G_Vis;\n        }\n    }\n    \n    return vec2(A, B) / float(numSamples);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    if (iFrame > 0) {\n        if(fragCoord.x > 256. || fragCoord.y > 256.){\n            fragColor = vec4(0.);\n        } else {\n    \n    \n            vec2 uv = fragCoord / vec2(256.);\n            float NoV = uv.x;\n            float roughness = uv.y;\n            fragColor = vec4(IntegrateBRDF(roughness, NoV).xy, 0.0, 1.0);\n        }\n    } else {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        return;\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}