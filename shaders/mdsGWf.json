{
    "Shader": {
        "info": {
            "date": "1666926471",
            "description": "Yet another fractal mosaic pattern.",
            "flags": 8,
            "hasliked": 0,
            "id": "mdsGWf",
            "likes": 9,
            "name": "Fractal mosaic 32 (music)",
            "published": 3,
            "tags": [
                "fractal",
                "music",
                "mosaic",
                "rug"
            ],
            "usePreview": 0,
            "username": "jarble",
            "viewed": 522
        },
        "renderpass": [
            {
                "code": "vec2 fract1(vec2 a){\n    return\n        fract(a)\n        //(fract(a)+fract(a/2.+.5))/2.\n        //(fract(a)+fract(a/2.))/2.\n        //fract(a-fract(a*4.)/2.)\n        //fract(a-floor(2.*a.x+1.5)/2.)\n    ;\n}\n\nvec3 mosaic(vec2 uv){\n  vec3 col = vec3(0);\n  vec2 offset = vec2(0);\n  vec2 uv1 = vec2(0);\n  for(int k = 0; k < 6; k++){\n        //another interesting variant:\n        //if(uv.y>uv.x) uv = uv.yx;\n        offset =\n            vec2(-uv.x,uv.y)*2.\n            //vec2(-uv.x,mod(uv.y,uv.x))*2.\n            //fract(vec2(-uv.x,uv.y))*(2.-offset/2.)\n            //vec2(mod(uv.x*2.-.5,2.),mod(uv.y,2.)*2.)\n            //vec2(mod(uv.x*2.,2.),sign(uv.x-uv.y)*mod(uv.y,2.)*2.)\n        ;\n        \n        //offset += floor(uv.x-uv.y)/2.;\n        //offset += floor(uv.x+uv.y+1.5)/2.;\n        //uv += fpow(offset.x*4.,4.)/2.;\n        //if(uv.y>uv.x) k += 1;\n\n        uv =\n            abs(fract1(uv.yx-offset)-.5)\n            //sqrt(abs(fract(uv.yx-offset)-.5))\n            //abs(fract(uv.yx-offset)-.5)*sign(.5-uv.x)\n            //(abs(fract(uv.yx-offset)-.5)*(1.-fmod(offset+2.5,2.)*2.))\n\n            //abs(fract(uv.yx/1.5-offset)-.5)/1.5\n            //abs(fract(uv.yx-offset)-.5+floor(uv.x-uv.y))\n            //abs(fract(uv.yx-offset/(1.+mod(floor(uv.x*4.),2.)))-.5)\n\n            //max(abs(fract(uv.yx-offset)-.5),abs(fract(uv.yx-vec2(uv.x,uv.y)*2.)-.5))\n\n            //abs(fract(uv.yx-offset)*(1.-col.x)-.5)\n            //abs(fract(uv.yx-offset)*abs(.5-col.x)*2.-.5)/2.\n        ;\n        //uv += length(uv/2.);\n        //uv.x *= 1.+uv.x/2.;\n        //uv.y *= 1.+uv.x/2.;\n        \n        //if(offset.x<offset.y) uv = uv.yx;\n        \n        if(uv.y > uv.x)\n        //if(uv.y < .25||uv.x>.25)\n        {col =\n            vec3(col.yz,abs(uv.x-uv.y))\n            //abs(col-vec3(col.yz,(uv.x-uv.y)/2.))\n            //vec3(col.yz,max(abs(uv.x-uv.y),col.x))\n            //vec3(col.yz,abs(uv.y-col.x))\n            //max(vec3(col.yz,abs(uv.x-uv.y)),col.yzx)\n        ;\n        //uv += uv1.yx/4.;\n        //uv /= 2.;\n        }\n        //if(uv.x<.5) col = 1.-col;\n        //uv /= 1.+mod(uv,2.);\n\n        //if(uv.y>uv.x) uv = uv.yx;\n        //if(uv.y<uv.x) uv *= sign(uv-uv.yx);\n        //else uv /= 2.;\n        //if(uv.x>uv.y) {col=col.yzx;}\n        uv1 = uv;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    vec2 uv = (fragCoord)/iResolution.y/4.0;\n    \n    uv += vec2(iTime/2.0,iTime/3.0)/16.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/4.;\n\n    vec3 col = mosaic(uv);\n    \n    fragColor = vec4(min(col*2.,vec3(1.)),1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\nvec2 mainSound(int samp, float t){\n\n  t /= 1.5;\n  //t += floor(t*pow(2.,fmod(t/4.,3.)));\n  //t = t*(1. + fmod(t*8./2.,2.))/2.;\n  //t += floor(t) + floor(t/2.)*2.+floor(t/4.)*4.+floor(t/8.)*8.;\n  //t += floor(t) + floor(t*2.)/2.+floor(t*4.)/4.+floor(t*8.)/8.;\n  //t = (t + fract(t*2.)/2.)/2.;\n  //t += fpow(t*16.,2.);\n  \n  float s1 =\n      8.\n      //pow(2.,1.+fmod(t,3.))\n  ;\n  //t *= 1. + fmod(t*s1,2.);\n  \n  //t = t + floor(t/s1+floor(t*s1))/s1;\n  //t = t + fmod(t*s1,floor(t)+1.)/s1;\n\n  //t = t + floor(floor(t*s1)+floor(t/s1))/s1;\n  float\n  m1 =\n      fmod(t,s1)\n      //fmod(t*2.-fmod(t/s1,2.),s1)\n      //fmod(mod(t,2.)/2.+mod(t,4.)/4.,s1)\n      //pow(fmod(t,s1),2.)+pow(fmod(t*s1,s1),2.)\n      //fmod(t*s1,s1)\n      //fmod(t+floor(t*s1),s1)\n      //fmod(t+floor(t)*floor(t/s1),s1)\n  ,\n  z1 =\n      (1.+fmod(t/s1,2.))\n      //(1.+fmod(mod(t,2.)/2.+mod(t,4.)/4.,2.))\n      //(1.+fmod(t/s1+floor(t),2.))\n      //(1.+fmod(t/s1+m1,2.))\n  ;\n\n  t /=\n      1.+fmod(floor(t*s1)*floor(t/s1+z1),2.)\n      //1.+fmod(floor(t*s1*sign(m1-z1))*floor(t/s1*sign(m1-z1)+z1),2.)\n      //1.+fmod(floor(t*s1+m1)*floor(t/s1+z1),2.)\n      //1.+fmod(floor(t/s1)*floor(t/s1+z1),2.)\n      //1.+fmod(floor(t/s1)*floor(t*s1+z1),2.)\n      //1.+fmod(floor(t*s1)*floor(t*s1+z1),2.)\n  ;\n  float m3 =\n      fmod((t*8.)/(m1+.5),s1*z1)\n      //fmod((t*8.)/(m1+.5)*sign(m1-z1),s1*z1)\n      //fmod((t*8.)/(m1+.5-fmod(t,8.)),s1*z1)\n      //fmod((t*8.)/(fmod(t*s1,m1+1.)+.5),s1*z1)\n      //fmod((t*8.+m1),s1*z1)\n  ;\n  //t -= (max(m1,m3)+1.)/2.;\n  t *=\n      1.+fmod(floor(t*s1)*floor(t/s1+z1),2.)\n      //1.+fmod(floor(t*s1-(1.-z1)*floor(t))*floor(t/s1+(1.+z1)*floor(t)),2.)\n      //1.+fmod(floor(t*s1/(.5+m1*2.))*floor(t/s1/(.5+m1*4.)+z1),2.)\n      //1.+fmod(floor(t/s1)*floor(t/s1+z1),2.)\n      //1.+fmod(floor(t/s1)*floor(t*s1+z1),2.)\n      //1.+fmod(floor(t*s1)*floor(t*s1+z1),2.)\n  ;\n  \n      \n  float a=\n      //pow(2.,pow(2.,fract(-t*s1)))\n      //sqrt((1.-sqrt(fract(t*s1))))*.2\n      //64.*(1.-sqrt(fract(t*s1)))*.2\n      //pow(2.,2.-log(fract(t*s1)))\n      pow(log(fract(t*s1)/4.),2.)\n      //pow(8.,1.+log(fract(-t*s1)))/8.\n  ,\n\n  nb = t*pow(2.,(m3+z1)/5.+7.);\n\n  return\n      log(abs(.5-vec2(fract(nb*.998*2.),fract(nb)))*a)\n      \n      //sitar\n      //log(abs(a/8.-abs(.5-vec2(fract(nb*.998*2.),fract(nb)))*a))\n      \n      //vec2(fract(t*nb*.998*z1),fract(t*nb*z1))*a\n  ;\n\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "#define f1(a) floor(a+floor((a)/2.))\n//#define fmod(x,y) mod(f1(f1(x)+f1((x)/8./8.)),y)\n//#define fmod(a,b) max(mod(floor(a+floor(a/8./8.))*floor(a),b),mod(floor(a),b))\n//#define fmod(a, b) mod(mod(floor(a/2.),floor(1.+a*2.)),b)\nfloat fmod(float a, float b){\n    /*\n    for(float i = 1.; i < mod(floor(a/b),8.); i++){\n        //a += floor(pow(2.,b));\n        a += mod(floor(a/b),b);\n    }\n    */\n    return\n        mod(floor(a),b)\n        //mod(floor(floor(a)*b/3.),b)\n        //mod(floor(-a*sign(.5-mod(floor(a/b*8.),2.))),b)\n        //mod(floor(a*8./b+b)*floor(a),b)\n    ;\n}\n\n#define fmod0(x,y) mod(floor(x)+1.5*floor(mod(x,y/2.)),y)\n#define fmod1(x,y) floor(mod(floor(x+floor((x)/y)/y),y))\n#define fmod2(x,y) mod(floor(x+floor(x)*y)/y,y)\n#define fmod3(x,y) mod(floor(x)*floor(x)+floor(x)*floor((x)/y),y)\n#define fmod4(x,y) mod(floor(x)*(1.+mod(floor((x)),y)),y)\n#define fmod5(x,y) mod(floor(floor((x)*2.)*2.+x),y)\n#define sqmod(x,y) floor(mod(floor(1.+x/2.)*floor(1.+x*2.),y))\n#define fmax(x,y,z) max(fmod(x,z),fmod(y,z))\n#define fpow(x,y) pow(y,fmod(x,y))",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}