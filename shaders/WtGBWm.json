{
    "Shader": {
        "info": {
            "date": "1614632506",
            "description": "Ray Marching w/ Blinn-Phong \nJust a graphics knowledge test to see how far I could get without external reference.\nThough I did have to google using pow for the specular piece of Blinn-Phong shading. I forgot and it didn't quite look right without it...",
            "flags": 0,
            "hasliked": 0,
            "id": "WtGBWm",
            "likes": 2,
            "name": "Ray Marching w/ Blinn-Phong",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "Parcle",
            "viewed": 177
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 120\n#define MISS_DIST 200.0\n// HIT_DIST should be treated as a non-inclusive max\n#define HIT_DIST 0.001\n#define SHADOW_RAY_SURFACE_ESCAPE_VECTOR_LENGTH 0.5\n#define NUM_SPHERES 7\n\nstruct hit_result {\n    vec3 hitPos;\n    float dist;\n    int iterations;\n    bool hit;\n};\nconst vec3 missColor = vec3(0.1, 0.1, 0.1);\nvec3 hitColor = vec3(0.8, 0.3, 0.5);\nconst float pi = 3.141592;\nconst float tau = pi * 2.0;\n\nfloat sdSphere(vec3 rayPos);\nfloat sdXZQuad(vec3 rayPos);\nfloat sdScene(vec3 rayPos);\nvec3 calcColor(vec3 rayOrigin, vec3 rayDir);\nvec3 calcLighting(vec3 hitPos);\nvec3 getNormal(vec3 hitPos);\nmat2 rotate(float rads);\nmat3 lookAt(vec3 origin, vec3 focus);\nhit_result castRay(vec3 rayOrigin, vec3 rayDir);\n\nvec3 cameraPos = vec3(0.0, 0.0, 100.0);\n \nvec4 spheresPosAndScale[NUM_SPHERES] = vec4[](\n                        vec4(0.0, 0.0, 0.0, 3.0),\n                        vec4(0.0, 0.0, 10.0, 4.5),\n                        vec4(0.0, 0.0, -10.0, 3.0),\n                        vec4(10.0, 0.0, 0.0, 4.5),\n                        vec4(-10.0, 0.0, 0.0, 3.0),\n                        vec4(0.0, 10.0, 0.0, 4.5),\n                        vec4(0.0, -10.0, 0.0, 3.0)\n                    );\nconst float xzPlaneYValue = -15.0;\nconst float xzPlaneScale = 35.0;\nconst float xzPlaneScaleInverse = 1.0 / xzPlaneScale;\nconst vec3 xzPlaneNormal = vec3(0.0, 1.0, 0.0);\n         \nconst float defaultSphereRadius = 1.0f;\nconst float rotationCyclesPerSecond = 0.10;\n\n\nconst vec3 lightColor = vec3(1.0);\nconst float ambientLightFactor = 0.3;\nconst float specularLightFactor = 0.3;\nconst float directionalLightFactor = 1.0 - ambientLightFactor - specularLightFactor;\nvec3 directionalLightDir;\n\nconst vec3 worldUp = vec3(0.0, 1.0, 0.0);\n\nmat3 lookAt(vec3 origin, vec3 focus) {\n    vec3 zBasis = normalize(origin - focus); // from focus to origin, as we look down the negative z axis\n    vec3 xBasis = normalize(cross(worldUp, zBasis));\n    vec3 yBasis = normalize(cross(zBasis, xBasis));\n    return mat3 (\n                    xBasis,\n                    yBasis,\n                    zBasis\n                );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord - (iResolution.xy * 0.5);\n    uv /= iResolution.y;\n    uv *= 2.0;\n    \n    float tSin = sin(iTime * 0.5);\n    float tCos = cos(iTime * 0.5);\n    hitColor += vec3(0.0, hitColor.y * tSin, hitColor.z * tCos);\n    \n    // directional lights don't have a \"position\", it is simply useful to temporarily think of it this way to manipulate the direction\n    vec3 directionalLightPos = vec3(0.0, 50.0 + (25.0 * tSin), -100.0);\n    directionalLightDir = normalize(directionalLightPos - vec3(0.0)); // direction the light is coming from, NOT the direction the light \"flows\"\n    \n    // offset the spheres as a unit to orbit y axis\n    vec3 sphereOffsets = vec3(10.0 * tSin, 0.0, 10.0 * tCos);\n    \n    mat2 rotateMatrix = rotate(tau * iTime * rotationCyclesPerSecond);\n    \n    for(int i = 0; i < NUM_SPHERES; ++i) {\n        // adjust sphere scales\n        float sinScaleFactor = (sin(iTime + (float(i) * pi * 0.7)) + 1.0) * 0.5;\n        spheresPosAndScale[i].w = mix(1.0, spheresPosAndScale[i].w, sinScaleFactor);\n        \n        // adjust sphere positions through rotation\n        spheresPosAndScale[i].xy = rotateMatrix * spheresPosAndScale[i].xy;\n         \n        // offset all spheres as a unit (orbiting y-axis)\n        spheresPosAndScale[i].xyz += sphereOffsets;\n    }\n    \n    \n    float cameraYFactor = (sin(iTime * 0.3) + 1.0) * 0.5;\n    cameraPos.y = cameraYFactor * 100.0;\n    vec3 rayOrigin = cameraPos;\n    const float cameraToPlaneZValue = -5.0;\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, cameraToPlaneZValue));\n    vec3 focus = vec3(0.0, 0.0, 0.0);\n    mat3 lookAtMat = lookAt(cameraPos, focus);\n    rayDir = lookAtMat * rayDir;\n    \n    vec3 color = calcColor(rayOrigin, rayDir);\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}\n\n// note ray direction is expected to be normalized\nvec3 calcColor(vec3 rayOrigin, vec3 rayDir) {\n    hit_result hitResult = castRay(rayOrigin, rayDir);\n    return hitResult.hit ? calcLighting(hitResult.hitPos) : missColor;\n}\n\nhit_result castRay(vec3 rayOrigin, vec3 rayDir) {\n    hit_result hitResult;\n    hitResult.hit = false;\n    hitResult.iterations = 0;\n    hitResult.dist = 0.0;\n    while(hitResult.dist < MISS_DIST && hitResult.iterations < MAX_STEPS) {\n        vec3 currRayPos = rayOrigin + (hitResult.dist*rayDir);\n        float currDist = sdScene(currRayPos);\n        if(currDist < HIT_DIST) { // hit!\n            hitResult.hit = true;\n            hitResult.hitPos = currRayPos;\n            break;\n        }\n        hitResult.dist += currDist;\n        ++hitResult.iterations;\n    }\n    \n    return hitResult;\n}\n\nfloat sdScene(vec3 rayPos) {\n    float minDist = sdXZQuad((rayPos - vec3(0.0, xzPlaneYValue, 0.0)) * xzPlaneScaleInverse) * xzPlaneScale;\n    for(int i = 0; i < NUM_SPHERES; ++i) {\n        minDist = min(minDist, sdSphere((rayPos - spheresPosAndScale[i].xyz) / spheresPosAndScale[i].w)  * spheresPosAndScale[i].w);\n    }\n\n    return minDist;\n}\n\nfloat sdSphere(vec3 rayPos) {\n    float signedDist = length(rayPos) - defaultSphereRadius;\n    return signedDist;\n}\n\nfloat sdXZQuad(vec3 rayPos) {\n    rayPos = abs(rayPos);\n    rayPos.xz -= vec2(1.0, 1.0);\n    rayPos.xz = max(rayPos.xz, 0.0);\n    return length(rayPos);\n}\n\nvec3 calcLighting(vec3 hitPos) {\n    vec3 normal = getNormal(hitPos);\n    \n    // ambient\n    vec3 ambientContribution = ambientLightFactor * lightColor * hitColor;\n    \n    // diffuse\n    float normalLightDirAlignment = dot(normal, directionalLightDir);\n    vec3 diffuseContribution = normalLightDirAlignment * directionalLightFactor * lightColor * hitColor;\n    \n    // specular\n    vec3 viewDir = normalize(cameraPos - hitPos); // from hit position to camera pos\n    vec3 halfwayVector = normalize(directionalLightDir + viewDir);\n    float normalHalfwayAlignment = dot(normal, halfwayVector);\n    float specularStrength = pow(max(normalHalfwayAlignment, 0.0), 32.0); // NOTE: one line where I \"cheated\" and didn't pull from memory\n    vec3 specularContribution = specularStrength * lightColor * specularLightFactor; // ignore hit color for specular lighting\n    \n    // shadow\n    bool inShadow = castRay(hitPos + (SHADOW_RAY_SURFACE_ESCAPE_VECTOR_LENGTH * normal), directionalLightDir).hit;\n    \n    return (normalLightDirAlignment < 0.0 || inShadow) ? ambientContribution : ambientContribution + diffuseContribution + specularContribution;\n}\n\n// Note: normal is returned normalized\nvec3 getNormal(vec3 hitPos) {\n    int closestIndex = 0;\n    float closestDist = sdSphere((hitPos - spheresPosAndScale[0].xyz) / spheresPosAndScale[0].w)  * spheresPosAndScale[0].w;\n    for(int i = 1; i < NUM_SPHERES; i++) {\n        float dist = sdSphere((hitPos - spheresPosAndScale[i].xyz) / spheresPosAndScale[i].w)  * spheresPosAndScale[i].w;\n        if(dist < closestDist) {\n            closestDist = dist;\n            closestIndex = i;\n        }\n    }\n    \n    return closestDist > HIT_DIST ? xzPlaneNormal : normalize(hitPos - spheresPosAndScale[closestIndex].xyz);\n}\n\nmat2 rotate(float rads) {\n    float sinTheta = sin(rads);\n    float cosTheta = cos(rads);\n    return mat2 ( \n                    cosTheta, sinTheta,\n                    -sinTheta, cosTheta\n                );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}