{
    "Shader": {
        "info": {
            "date": "1531644421",
            "description": "Motion graphics with shaders",
            "flags": 8,
            "hasliked": 0,
            "id": "MtdczH",
            "likes": 30,
            "name": "MotionGraphics",
            "published": 3,
            "tags": [
                "raymarching",
                "sound"
            ],
            "usePreview": 0,
            "username": "setchi",
            "viewed": 1395
        },
        "renderpass": [
            {
                "code": "#define BPM 135.0\n#define PI 3.141592654\n\n#define INIT(t) float tmp = t, nTime = t;int val, num;ivec3 chord;\n#define D(v) if (tmp >= 0.0) {nTime = tmp;}tmp -= 240.0 / BPM / float(v);\n#define R(v) tmp -= 240.0 / BPM / float(v);\n#define LOOP(b) if (tmp > 0.0) tmp = mod(tmp, float(b) * 240.0 / BPM);\n#define FOR(b,n) if(tmp>0.0){float a=float(b)*240.0/BPM;for(int i=0;i<n-1;i++){if(tmp>a)tmp-=a;}}\n\nfloat gTime;\nfloat gBeat;\nfloat gVoronoiFx;\nint gTata;\n\nvec3 hue(float hue) {\n    vec3 rgb = fract(hue + vec3(0., 2. / 3., 1. / 3.));\n    rgb = abs(rgb * 2. - 1.);\n    return clamp(rgb * 3. - 1., 0., 1.);\n}\n\nvec3 hsvToRgb(vec3 hsv) {\n    return ((hue(hsv.x) - 1.) * hsv.y + 1.) * hsv.z;\n}\n\nvec3 rotateX(vec3 p, float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec3(p.x, c * p.y + s * p.z, -s * p.y + c * p.z);\n}\n\nvec3 rotateY(vec3 p, float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec3(c * p.x - s * p.z, p.y, s * p.x + c * p.z);\n}\n\nmat2 rotate2d(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, -s, s, c);\n}\n\nfloat circularInOut(float t) {\n    return t < 0.5 ?\n        0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t)) :\n        0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\n}\n\nfloat hash11(float p) {\n    vec3 p3 = fract(vec3(p) * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nfloat fillIn(float time) {\n    float fadeIn = min(mod(gBeat / 4., 5.), 1.);\n    INIT(gTime)\n    LOOP(5)\n        FOR(1. / 16., 16) D(16)\n    return nTime * fadeIn;\n}\n\nfloat rhythm1(float time) {\n    INIT(gTime)\n    LOOP(5)\n        R(4)\n        R(8)\n        FOR(.25, 19) D(4)\n    return nTime;\n}\n\nfloat rhythm2(float time) {\n    INIT(gTime)\n    LOOP(5)\n        FOR(1. / 4., 4) R(4)\n        FOR(1, 4) R(4) R(4) R(4) R(8) D(8)\n    return nTime;\n}\n\nint tata(float time) {\n    return time > 0. && time < 0.125 ? 1 :\n           time < .2 ? 2 : 0;\n}\n\nfloat voronoi(in vec2 st) {\n    float t = gBeat * step(12., gBeat);\n\n    vec2 n = floor(st * 2.);\n    vec2 f = fract(st * 2.);\n\n    vec2 mg, mr;\n    vec2 mp;\n\n    float md = 8.0;\n    for (int j = -1; j <= 1; j++)\n    for (int i = -1; i <= 1; i++) {\n        vec2 g = vec2(i, j);\n        vec2 o = hash22(n + g);\n        vec2 p = n + g;\n        o = 0.5 + 0.5 * sin(t + 6.2831 * o);\n        vec2 r = g + o - f;\n        float d = dot(r, r);\n\n        if (d < md) {\n            md = d;\n            mr = r;\n            mg = g;\n            mp = n + g;\n        }\n    }\n\n    md = 8.0;\n    for (int j = -2; j <= 2; j++)\n    for (int i = -2; i <= 2; i++) {\n        vec2 g = mg + vec2(i, j);\n        vec2 o = hash22(n + g);\n        o = 0.5 + 0.5 * sin(t + 6.2831 * o);\n        vec2 r = g + o - f;\n\n        if (dot(mr - r, mr - r) > 0.00001) {\n            md = min(md, dot(0.5 * (mr + r), normalize(r - mr)));\n        }\n    }\n\n    float bt = circularInOut(clamp(gBeat - 19., 0., 1.));\n    float border = step(md, mix(0.005, 1., bt));\n    return mix(hash22((mp + vec2(2, 2)) / 4.).x, 100., border);\n}\n\nfloat voronoiFx(vec2 uv) {\n    float a = -gBeat * .4 * step(0., gBeat - 3.);\n    float aa = -(circularInOut(clamp(gBeat - 14., 0., 1.)) +\n                 circularInOut(clamp(gBeat - 18., 0., 1.)));\n\n    uv *= circularInOut(clamp(gBeat - 12., 0., 1.)) * .4;\n    uv *= rotate2d(a + aa * 1.5);\n\n    return voronoi(uv);\n}\n\nvec2 glitch(vec2 uv) {\n    return gTata == 0 ? uv :\n           gTata == 1 ? vec2(uv.x * hash11(uv.y), uv.y) :\n                        vec2(uv.x * hash11(uv.y), uv.y * hash11(uv.x));\n}\n\nvec2 shake(float time) {\n    float s = time * 50.0;\n    return (vec2(hash11(s), hash11(s + 11.0)) * 2.0 - 1.0) * exp(-5.0 * time) * 0.2;\n}\n\nvec3 getRo() {\n    float scale = mix(1., .7, circularInOut(clamp(gBeat - 12., 0., 1.)));\n    return (gTata == 0 ? vec3(0, 0, 10) :\n            gTata == 1 ? vec3(0, 0, 4) :\n                         vec3(0, 0, 3)) * scale;\n}\n\nvec3 getTa() { return gTata == 1 ? vec3(.5, .5, .5) : vec3(0); }\n\nvec4 permute(vec4 x) { return mod(((x * 34.0) + 1.0) * x, 289.0); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nfloat snoise(vec3 v) {\n    const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    vec3 i = floor(v + dot(v, C.yyy));\n    vec3 x0 = v - i + dot(i, C.xxx);\n\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min(g.xyz, l.zxy);\n    vec3 i2 = max(g.xyz, l.zxy);\n\n    vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n    vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n    vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n    i = mod(i, 289.0);\n    vec4 p = permute(permute(permute(\n                i.z + vec4(0.0, i1.z, i2.z, 1.0)) +\n            i.y + vec4(0.0, i1.y, i2.y, 1.0)) +\n        i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n    float n_ = 1.0 / 7.0;\n    vec3 ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_);\n\n    vec4 x = x_ * ns.x + ns.yyyy;\n    vec4 y = y_ * ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4(x.xy, y.xy);\n    vec4 b1 = vec4(x.zw, y.zw);\n\n    vec4 s0 = floor(b0) * 2.0 + 1.0;\n    vec4 s1 = floor(b1) * 2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n    vec3 p0 = vec3(a0.xy, h.x);\n    vec3 p1 = vec3(a0.zw, h.y);\n    vec3 p2 = vec3(a1.xy, h.z);\n    vec3 p3 = vec3(a1.zw, h.w);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1),\n        dot(p2, x2), dot(p3, x3)));\n}\n\nfloat udBox(vec3 p, vec3 b, float r) {\n    return length(max(abs(p) - b, 0.0)) - r;\n}\n\nfloat sdSphere(vec3 p, float radius) {\n    return length(p) - radius;\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat map(vec3 p) {\n    float rhythm = rhythm1(gTime);\n    p.x += step(8.5, gBeat) * (step(0., p.y) * 2. - 1.) * exp(-25.0 * rhythm) * step(0., rhythm);\n    p.xy += snoise(p * .2 + vec3(gTime, -gTime, 0) * 1.5) * .2 * exp(-10.0 * rhythm) * 3.5;\n\n    float t = floor(gVoronoiFx * 10.) + gBeat + .5;\n    float it = mod(floor(t), 3.);\n    float ft = fract(t) * exp(-10. * t);\n    float fillIn = (floor(min(16., gBeat * 4.)) - 8.) / 8.;\n    \n    float torus = sdTorus(rotateX(p, PI / 2.), vec2(.6, .25) * fillIn);\n    float sphere = sdSphere(p, 1.1 * fillIn);\n    float box = udBox(rotateY(rotateX(p, PI / 4.), PI / 4.), vec3(0.5) * fillIn, 0.05);\n\n    if (it == 0.)\n        return mix(box, sphere, ft);\n    if (it == 1.)\n        return mix(sphere, torus, ft);\n    if (it == 2.)\n        return mix(torus, box, ft);\n    return 0.;\n}\n\nvec2 intersect(vec3 ro, vec3 ray) {\n    float t = 0.0;\n    for (int i = 0; i < 80; i++) {\n        float res = abs(map(ro + ray * t));\n        if (res < 0.005) return vec2(t, res);\n        t += res * 0.5;\n    }\n\n    return vec2(-1.0);\n}\n\nvec3 normal(vec3 pos, float e) {\n    vec3 eps = vec3(e, 0.0, 0.0);\n\n    return normalize(vec3(\n        map(pos + eps.xyy) - map(pos - eps.xyy),\n        map(pos + eps.yxy) - map(pos - eps.yxy),\n        map(pos + eps.yyx) - map(pos - eps.yyx)));\n}\n\nmat3 createCamera(vec3 ro, vec3 ta, float cr) {\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvec3 light(vec3 pos, vec3 normal, vec3 ray, vec3 col, vec3 lpos) {\n    vec3 lvec = normalize(lpos - pos);\n    vec3 hvec = normalize(lvec - ray);\n    float llen = length(lpos - pos);\n    vec3 diffuse = col * max(dot(lvec, normal), 0.0) * (1.0 / PI);\n\n    float rough = 200.0;\n    float bpnorm = (rough + 2.0) / (2.0 * PI);\n    vec3 spec = col * bpnorm * pow(max(0.0, dot(normal, hvec)), rough);\n    return vec3(diffuse + spec) / (llen * llen);\n}\n\nvec3 render(vec2 p) {\n    if (gVoronoiFx == 100.) {\n        return vec3(0);\n    }\n\n    vec3 ro = getRo();\n    vec3 ta = getTa();\n    mat3 cm = createCamera(ro, ta, 0.);\n    vec3 ray = cm * normalize(vec3(p, 10.0));\n    vec3 col = vec3(.2);\n\n    vec2 res = intersect(ro, ray);\n\n    if (res.y < -0.5) {\n        return col;\n    }\n\n    vec3 pos = ro + ray * res.x;\n    vec3 nor = normal(pos, 0.008);\n\n    vec3 fresnel = vec3(0);\n    if (dot(-ray, nor) < 0.4) {\n        float a = 1. - dot(-ray, nor) * 2.5;\n        fresnel += mix(fresnel, hsvToRgb(vec3(gVoronoiFx * 2., 1, 1)), a) * 1.5;\n    }\n\n    col += light(pos, nor, ray, vec3(100.0, 200.0, 400.0), ro + vec3(-40.0, 20.0, 20.0));\n    col += light(pos, nor, ray, hsvToRgb(vec3(gVoronoiFx * 2., 1, 1)) * 400., ro + vec3(40.0, 20.0, 20.0));\n    col += fresnel;\n    col += texture(iChannel0, reflect(ray, nor)).xyz * .2;\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    gTime = iTime;\n    gBeat = mod(gTime * BPM / 60.0, 20.);\n    gTata = tata(rhythm2(gTime));\n\n    uv += shake(rhythm2(gTime));\n    gVoronoiFx = voronoiFx(uv);\n    uv = glitch(uv);\n\n    vec3 color = render(uv);\n    color *= smoothstep(0.2, 0.8, clamp(fillIn(gTime) * 8., 0., 1.));\n    fragColor = vec4(color, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define BPM 135.0\n\n#define INIT(t) float tmp = t, nTime = t; int val, num; ivec3 chord;\n#define D(v)if (tmp >= 0.0 ) {nTime = tmp;} tmp -= 240.0 / BPM / float(v);\n#define R(v) tmp -= 240.0 / BPM / float(v);\n#define LOOP(b) if(tmp>0.0) tmp = mod(tmp, float(b) * 240.0 / BPM);\n#define FOR(b, n) if(tmp>0.0) {float a = float(b) * 240.0 / BPM; for(int i = 0; i < n-1; i++){if (tmp> a) tmp -= a;}}\n#define V vec3(0.,1.,-1.)\n\nvec4 random2D(vec2 _v) {\n    return vec4(fract(sin(dot(_v, vec2(12.9898, 78.233))) * 43758.5453));\n}\n\nvec4 random(float _v) {\n    return random2D(_v * V.yy);\n}\n\n// Thanks to https://github.com/FMS-Cat/20180310-glsl-music/\nvec2 kick(float _phase) {\n    if (_phase < 0.0) {\n        return V.xx;\n    }\n    return V.yy * sin(_phase * 300.0 - exp(-_phase * 100.0) * 30.0) * exp(-_phase * 5.0);\n}\n\nvec2 hihat(float _seed, float _dec) {\n    return (random(_seed).xy + random(_seed + _dec).xy) * .5 * exp(-_dec);\n}\n\nvec2 _hihat(float time) {\n    INIT(time)\n    LOOP(5)\n        FOR(1. / 16., 16) D(16)\n        FOR(1, 4) R(16) R(16) D(16) R(16) R(16) R(16) D(16) R(16) R(16) R(16) D(16) R(16) R(16) R(16) D(16) D(16)\n    return hihat(nTime, nTime * 18.);\n}\n\nvec2 _kick(float time) {\n    INIT(time)\n    LOOP(5)\n        FOR(1. / 4., 4) D(4)\n        FOR(1, 4) D(16) R(16 / 3) D(16) R(16) D(16) D(16) R(16) D(16) D(16) R(16) D(16) R(16) D(16) D(16)\n    return kick(nTime);\n}\n\nvec2 mainSound( in int samp,float time) {\n    float beat = time * BPM / 60.0;\n    float fadeIn = min(mod(beat / 4., 5.), 1.);\n    return (_hihat(time) * fadeIn +\n            _kick(time) * (fadeIn * 0.7 + 0.3)) / 2.;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}