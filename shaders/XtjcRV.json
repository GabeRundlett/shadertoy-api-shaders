{
    "Shader": {
        "info": {
            "date": "1509304615",
            "description": "A test of portal technology. Portals can possess non-uniform scales. Note: I'm learning the ropes, so don't use my probably crappy code as a reference for how to do things.\nMOUSE: movement\nSPACE: central camera view (gaze into infinity (or purple!))",
            "flags": 16,
            "hasliked": 0,
            "id": "XtjcRV",
            "likes": 8,
            "name": "Scalable Portals",
            "published": 3,
            "tags": [
                "raytracing",
                "portals"
            ],
            "usePreview": 0,
            "username": "ShnitzelKiller",
            "viewed": 777
        },
        "renderpass": [
            {
                "code": "#define depth 0.1\n#define fdist 0.7\n#define background 0.\n#define portalmat1 1.\n#define portalmat2 2.\n#define framemat 3.\n#define floormat 4.\n#define geommat 5.\n#define maxdist 100.\n#define maxstep 100\n#define threshold 0.0025\n#define lightdir normalize(vec3(-1., 1., 0.5))\n#define lightintensity 1.5\n#define eps 0.01\n#define shadoweps 0.1\n#define dark vec3(0.2, 0.4, 0.4)\n#define floorheight -1.5\n#define maxpasses 20\n\n#define KEY_SPACE\t(vec2 (32.5, 0.5) / 256.0)\n\n#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n\nstruct PortalFrame {\n    vec3 c;\n    vec3 dir;\n    vec3 up;\n    vec2 dims;\n} p1, p2;\n    \n\nfloat spheresdf(vec3 pos, vec3 c, float r, out vec3 coords) {\n    pos -= c;\n    coords = pos/(r*2. + 0.1);\n    return length(pos)-r;\n}\n\nfloat boxsdf(vec3 pos, vec3 c, vec3 dims, out vec3 coords) {\n    pos -= c;\n    dims /= 2.;\n    float d = max(pos.x - dims.x, -pos.x - dims.x);\n    d = max(d, max(pos.y - dims.y, -pos.y - dims.y));\n    d = max(d, max(pos.z - dims.z, -pos.z - dims.z));\n    coords = pos/max(dims.x, max(dims.y, dims.z));\n    return d;\n}\n\nfloat cylindersdf(vec3 pos, vec3 c, float r, float h, out vec3 coords) {\n    pos -= c;\n    coords = pos/max(r, h);\n    return max(length(pos.xz)-r, max(-pos.y, pos.y - h));\n}\n\nvec2 portalsdf(vec3 pos, PortalFrame p, out vec3 coords) {\n    vec3 r = pos - p.c;\n    float h = dot(r, p.dir);\n    vec3 u = normalize(cross(p.dir, p.up));\n    vec3 v = cross(u, p.dir);\n    float x = dot(r, u);\n    float y = dot(r, v);\n    p.dims = p.dims/2.;\n    \n    //frame\n    //float d2 = max(x-dims.x, -x-dims.x);\n    //d2 = -max(d2, max(y-dims.y, -y-dims.y));\n    \n    float d = max(h-depth/2., -h-depth/2.);\n    d = max(d, max(x-p.dims.x-depth, -x-p.dims.x-depth));\n    d = max(d, max(y-p.dims.y-depth, -y-p.dims.y-depth));\n    //d = max(d, d2);\n    \n    coords = vec3(x, y, h);\n    return vec2(d, abs(x) < p.dims.x && abs(y) < p.dims.y ? portalmat1 : framemat);\n}\n\nvec2 sdf(vec3 pos, out vec3 coords) {\n    vec3 coords1;\n    vec3 coords2;\n    vec2 d1 = portalsdf(pos, p1, coords1);\n    vec2 d2 = portalsdf(pos, p2, coords2);\n\tvec2 d;\n    if (d1.x < d2.x) {\n        d = d1;\n        coords = coords1;\n    } else {\n        d = vec2(d2.x, d2.y < 2.5 ? portalmat2 : framemat);\n        coords = coords2;\n    }\n    float mindist = d.x;\n    float mat = d.y;\n    float h = max(pos.y-floorheight, length(pos.xz)-10.);\n    if (h < mindist) {\n        coords = pos;\n        mindist = h;\n        mat = floormat;\n    }\n    //primitives\n    h = spheresdf(pos, vec3(2., 0., 0.), 0.8, coords1);\n    if (h < mindist) {\n        coords = coords1;\n        mindist = h;\n        mat = geommat;\n    }\n    h = cylindersdf(pos, vec3(-0.3, -1.5, 0.), 0.1, 1.5, coords1);\n    if (h < mindist) {\n        coords = coords1;\n        mindist = h;\n        mat = geommat;\n    }\n    h = boxsdf(pos, vec3(0., -0.5, -3.), vec3(0.4, 1.7, 0.4), coords1);\n    if (h < mindist) {\n        coords = coords1;\n        mindist = h;\n        mat = geommat;\n    }\n    h = boxsdf(pos, vec3(0., -1., 3.), vec3(5., 0.5, 0.9), coords1);\n    if (h < mindist) {\n        coords = coords1;\n        mindist = h;\n        mat = geommat;\n    }\n    return vec2(mindist, mat);\n}\n\nvec2 raytrace(vec3 rp, vec3 rd, out vec3 coords) {\n    float t = 0.;\n    vec2 d = sdf(rp, coords);\n    int i;\n    for (i=0; i<maxstep; i++) {\n        t += d.x;\n        if (t > maxdist) break;\n        d = sdf(rp + t*rd, coords);\n        if (abs(d.x)<threshold) {\n            return vec2(t, d.y); \n        }\n    }\n    return vec2(maxdist, background);\n}\n\nvec3 getnormal(vec3 pos) {\n    vec3 coords;\n    vec2 diff = vec2(eps, 0.);\n    float dx = sdf(pos+diff.xyy, coords).x-sdf(pos-diff.xyy, coords).x;\n    float dy = sdf(pos+diff.yxy, coords).x-sdf(pos-diff.yxy, coords).x;\n    float dz = sdf(pos+diff.yyx, coords).x-sdf(pos-diff.yyx, coords).x;\n\treturn normalize(vec3(dx, dy, dz));\n}\n\nvec2 shaderay(vec3 pos, vec3 rd, float hardness) {\n    vec3 coords;\n\tvec3 n = getnormal(pos);\n    float lambert = max(0., dot(n, lightdir))*lightintensity;\n    vec2 ds = raytrace(pos + shadoweps*lightdir, lightdir, coords);\n    lambert = ds.y < 0.5 ? lambert : 0.;\n    vec3 h = normalize(-rd + lightdir);\n    float phong = pow(clamp(dot(h, n), 0., 1.), hardness);\n    return vec2(lambert, phong);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float space = texture (iChannel0, KEY_SPACE).r;\n    float alt = clamp(iMouse.y/iResolution.y-0.5, -0.15, 1.) * PI/2.;\n    float azi = (iMouse.x/iResolution.x-0.35) * TWO_PI;\n    float cphi = cos(alt);\n    vec3 eye = (0.01 + 5. * (1.-space)) * vec3(sin(azi)*cphi, sin(alt) + 2.*exp(-iTime), cos(azi)*cphi);\n    vec3 w = -normalize(eye);\n    eye += vec3(-0.3, 0.05, 0.);\n    vec3 u = normalize(cross(w, vec3(0., 1., 0.)));\n    vec3 v = cross(u, w);\n    vec3 rd = normalize(fdist*w + (fragCoord.x/iResolution.x-0.5)*u + (fragCoord.y/iResolution.x-0.5*iResolution.y/iResolution.x)*v);\n    \n    \n    float t = (sin(iTime/5.)+1.) * PI;\n    p1 = PortalFrame(vec3(0., 0., 0.), normalize(vec3(1., 0.1*cos(iTime*2.)*sin(t), 0.0)), vec3(0., 1., 0.2*sin(iTime*2.)*cos(t)), vec2(1.5 - 0.2*cos(t/2.), 2.+ 0.7*cos(t / 2.)));\n    p2 = PortalFrame(vec3(-1.5, 0., 0.), normalize(vec3(cos(t), 0., sin(t))), vec3(0., 1., 0.), vec2(1.5, 2.));\n    \n    \n    int i;\n    for (i=0; i<maxpasses; i++) {\n        vec3 coords;\n    \tvec2 d = raytrace(eye, rd, coords);\n        if (d.y < 0.5) {\n            //background\n            fragColor = vec4(0., 0.5, 1., 1.);\n            break;\n        } else if (d.y < 1.5) {\n            //portal1\n            u = normalize(cross(p1.dir, p1.up));\n    \t\tv = cross(u, p1.dir);\n    \t\tfloat x = dot(rd, u);\n    \t\tfloat y = dot(rd, v);\n            float z = dot(rd, p1.dir);\n            u = normalize(cross(p2.dir, p2.up));\n    \t\tv = cross(u, p2.dir);\n            vec2 scale = p2.dims/p1.dims;\n            rd = normalize(x*u*scale.x + y*v*scale.y + z*p2.dir);\n            eye = p2.c + coords.x*u*scale.x + coords.y*v*scale.y - coords.z * p2.dir + 2.*threshold*rd;\n            //dummy frag color to indicate that we can't render any further into the portals\n            fragColor = vec4(0.2, 0.8, 1., 1.);\n        } else if (d.y < 2.5) {\n            //portal2\n            u = normalize(cross(p2.dir, p2.up));\n    \t\tv = cross(u, p2.dir);\n    \t\tfloat x = dot(rd, u);\n    \t\tfloat y = dot(rd, v);\n            float z = dot(rd, p2.dir);\n            u = normalize(cross(p1.dir, p1.up));\n    \t\tv = cross(u, p1.dir);\n            vec2 scale = p1.dims/p2.dims;\n            rd = normalize(x*u*scale.x + y*v*scale.y + z*p1.dir);\n            eye = p1.c + coords.x*u*scale.x + coords.y*v*scale.y - coords.z * p1.dir + 2.*threshold*rd;\n            \n            fragColor = vec4(0.8, 0.2, 1., 1.);\n        } else if (d.y < 3.5) {\n            //portal border\n            vec3 col = mix(vec3(0.2, 0.2, 0.2), vec3(0.2, 0.7, 0.6), abs(abs(step(mod(coords.x, 0.5), 0.25)-step(mod(coords.z, 0.5), 0.25))-step(mod(coords.y, 0.5), 0.25)));\n            vec2 shade = shaderay(eye + d.x*rd, rd, 1.);\n            fragColor = vec4(max(dark.b, shade.x)*col, 1.0);\n            break;\n        } else if (d.y < 4.5) {\n            //floor\n            vec3 col = mix(vec3(0.4, 0.4, 0.4), vec3(0.7, 0.7, 0.7), abs(step(mod(coords.x, 1.), 0.25)-step(mod(coords.z, 1.), 0.25)));\n            vec2 shade = shaderay(eye + d.x*rd, rd, 10.);\n            fragColor = vec4(max(dark.b, shade.x)*col+shade.y/3., 1.0);\n            break;\n        } else {\n            //yellow checkered objects\n            vec3 col = mix(vec3(0.4, 0.8, 0.4), vec3(1., 0.7, 0.2), abs(abs(step(mod(coords.x, 0.5), 0.25)-step(mod(coords.z, 0.5), 0.25))-step(mod(coords.y, 0.5), 0.25)));\n            vec2 shade = shaderay(eye + d.x*rd, rd, 20.);\n            fragColor = vec4(max(dark.b, shade.x)*col+shade.y/3., 1.0);\n            break;\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}