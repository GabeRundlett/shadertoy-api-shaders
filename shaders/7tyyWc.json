{
    "Shader": {
        "info": {
            "date": "1662330314",
            "description": "Clock constructed with distance fields. sdOriented box is by @iq and the blackbody function is by @FabriceNeyret2 (modified by me).",
            "flags": 0,
            "hasliked": 0,
            "id": "7tyyWc",
            "likes": 6,
            "name": "Simple glowing clock",
            "published": 3,
            "tags": [
                "time",
                "sdf",
                "clock"
            ],
            "usePreview": 0,
            "username": "fishy",
            "viewed": 350
        },
        "renderpass": [
            {
                "code": "#define PI 3.141592653\n#define date (iDate * 1.0)\n\nfloat join(float a, float b)\n{\n    return min(a, b);\n}\n\nfloat sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th ) // Made by iq\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\nfloat sdDisk(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdDiskOutline(vec2 p, float r1, float r2)\n{\n    return abs(length(p) - r1) - r2*0.5;\n}\n\nfloat sdRotatedLine(vec2 p, vec2 start, float offset, float len, float theta, float thick)\n{\n    return sdOrientedBox(p, start + vec2(sin(theta), cos(theta)) * offset, vec2(sin(theta), cos(theta)) * (len + offset), thick);\n}\n\nvec4 sd(vec2 p)\n{\n    float seconds = sdRotatedLine(p, vec2(0.0, 0.0), 0.0, 0.15, (floor(date.w)/60.0)*2.0*PI, -0.001);\n    float minutes = sdRotatedLine(p, vec2(0.0, 0.0), 0.0, 0.11, (date.w/60.0/60.0)*2.0*PI, 0.0);\n    float hours = sdRotatedLine(p, vec2(0.0, 0.0), 0.0, 0.1, (date.w/60.0/60.0/12.0)*2.0*PI, 0.0);\n    float centerDisk = sdDisk(p, 0.0);\n    float outerCircle = sdDiskOutline(p, 0.23, 0.0);\n    float ticks = 1000000.0;\n    for(float i = 0.0; i < 2.0*PI; i+= 2.0*PI/12.0)\n    {\n        ticks = join(ticks, sdRotatedLine(p, vec2(0.0, 0.0), 0.18, 0.03, i, 0.0));\n    }\n    \n    for(float i = 0.0; i < 2.0*PI; i+= 2.0*PI/60.0)\n    {\n        ticks = join(ticks, sdRotatedLine(p, vec2(0.0, 0.0), 0.2, 0.01, i, -0.005));\n    }\n    return vec4(join(join(join(join(join(seconds, minutes), hours), centerDisk), outerCircle), ticks), 0.0, 0.0, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio = iResolution.y/iResolution.x;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(0.5);\n    uv.y *= ratio;\n    \n    float px = 1.0/ratio/max(iResolution.x, iResolution.y);\n\n    vec4 col = blackbody(.005/max(0.0, sd(uv).x + 0.01));\n    col += max(vec4(0.0), blackbody(erp(abs(fragCoord.y/iResolution.y - 0.5)*2.0, 0.2) * 0.5)) * 1.0;\n    fragColor = col;\n    //fragColor = vec4(uv.xy, 0.0, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec4 blackbody(float x) //By @FabriceNeyret2 (modified by me) https://www.shadertoy.com/view/4tdGWM\n{\n    vec4 O = vec4(0.0);\n    float m = .01+5.*2.0,\n        T = x*16000.; // absolute temperature (K)\n    \n    O -= O;\n    \n/*  // --- with physical units: (but math conditionning can be an issue)\n    float h = 6.6e-34, k=1.4e-23, c=3e8; // Planck, Boltzmann, light speed  constants\n\n    for (float i=0.; i<3.; i++) {  // +=.1 if you want to better sample the spectrum.\n        float f = 4e14 * (1.+.5*i); \n        O[int(i)] += 1e7/m* 2.*(h*f*f*f)/(c*c) / (exp((h*f)/(k*T)) - 1.);  // Planck law\n    }\n*/\n    // --- with normalized units:  f = 1 (red) to 2 (violet). \n    // const 19E3 also disappears if you normalized temperatures with 1 = 19000 K\n     for (float i=0.; i<3.; i += .05) {  // +=.1 if you want to better sample the spectrum.\n        float f = 1.+.5*i; \n        O[int(i)] += 10./m* (f*f*f) / (exp((19E3*f/T)) - 1.);  // Planck law\n    }\n    return O;\n}\n\n#define ease 1.5\n\nfloat erp(float x, float k)\n{\n    return x < 0.5 ? pow(2.0*x, k)*0.5  : 1. - pow(2.0*(1.0-x), k) / 2.;\n}\n\nfloat hash2(in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nfloat noise(vec2 p)\n{\n  \n    float tl = hash2(vec2(floor(p.x),  ceil(p.y)));\n    float bl = hash2(vec2(floor(p.x), floor(p.y)));\n    float tr = hash2(vec2( ceil(p.x),  ceil(p.y)));\n    float br = hash2(vec2( ceil(p.x), floor(p.y)));\n    \n    \n    float a = mix(bl, tl, erp(fract(p.y), ease));\n    float b = mix(br, tr, erp(fract(p.y), ease));\n    \n    return mix(a, b, erp(fract(p.x), ease));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}