{
    "Shader": {
        "info": {
            "date": "1584128596",
            "description": "Maps a 2D SDF to four regions, each with a different texture.\n\nUses the triangle function `clamp(1-abs(x-a),0,1)` to interpolate bands at distance a={0,1,2,3}. Notice that sum of all bands is a constant 1.0. Gamma corrects the blend, h/t spalmer\n",
            "flags": 0,
            "hasliked": 0,
            "id": "wdfcRH",
            "likes": 3,
            "name": "2D SDF to texture mapping",
            "published": 3,
            "tags": [
                "distancefield",
                "sdf"
            ],
            "usePreview": 0,
            "username": "aedion",
            "viewed": 363
        },
        "renderpass": [
            {
                "code": "// Maps 2D SDF to four regions, each with a different texture.\n//\n// Uses a \"banding\" function that takes a scalar value as input and splits that into\n// channels in range [0,1] where the sum of all channels is 1.\n//\n// The sawtooth-like function `clamp(1 - abs(x-a), 0, 1)` where a in {0,1,2,3} works great\n// for this purpose and can be SIMD pretty easily.\n//\n// The one second blip in the animation shows the different channels (alpha is black).\n//\n// A linear color space assumption is made for the math. \n// Shadertoy is in gamma space, so need to decode the textures to linear then encode the \n// result back.\n\n\n// Maps input domain [0,3] to four channels.\n// Each channel is 1.0 at the integers, and the sum of all channels is 1.\nvec4 map03To4Channel(float x03) {\n\treturn clamp(1. - abs(vec4(x03, x03 - 1., x03 - 2., x03 - 3.)), 0., 1.);\n}\n\n/* Same idea as above, but for two and three channels respectively instead of four:\n    vec2 map01To2Channel(float x01) {\n        return clamp(1. - abs(vec2(x01, x01 - 1.)), 0., 1.);\n    }\n    vec3 map02To3Channel(float x02) {\n        return clamp(1. - abs(vec3(x02, x02 - 1., x02 - 2.)), 0., 1.);\n    }\n*/\n\n// Approximated gamma correction.\n// See https://iquilezles.org/articles/gamma for basics\n// and this neat video https://www.youtube.com/watch?v=LKnqECcg6Gw\n// and this cool tutorial https://www.shadertoy.com/view/lscSzl\n#define GAMMA_CORRECTION 1\n#define GAMMA 2.2\nvec3 deGamma(vec3 c) {\n    #if GAMMA_CORRECTION\n    \tc = pow(c,vec3(GAMMA));\n    #endif\n    return c;\n}\nvec3 gamma(vec3 c) {\n    #if GAMMA_CORRECTION\n    \tc = pow(c,vec3(1./GAMMA));\n    #endif\n    return c;\n}\n\n// Sample the texture, scaling it by a factor\nvec3 factorSample(sampler2D tex, vec2 uv, float factor) {\n    vec3 c = texture(tex, uv).rgb;\n    c = deGamma(c); // before multiplying, which needs linear space\n    return c * factor;\n}\n\n// IQ's: https://iquilezles.org/articles/distfunctions2d\nfloat sdPentagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);    \n    return length(p)*sign(p.y);\n}\n\n// Smoothstep, but where \"slope\" is the derivative at value=0.5\nvec4 slopeSmoothstep(vec4 value, float slope) {\n    const float center = 0.5;\n\treturn smoothstep(0.0, 1.0, slope * (value - center) + .5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.*fragCoord/iResolution.y;\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    float sd = sdPentagon(p, .5); // Can be any SDF\n    sd = 4. * sd + 1.5; // Scale and shift\n    sd = clamp(sd,0.,3.); // Clamp into domain [0,3]\n   \n    // Map distance to channels:\n    vec4 channel = map03To4Channel(sd);\n    \n    // Blend channels using a step-like function\n    float anim = 5.*sin(iTime*12.)+6.; // range [1,11]\n    float blur = anim * fwidth(sd); // fragment width based blur (1 = smooth anti-aliasing)\n    // Can be \"lerp\" or any other function that maintains sum-of-channels = 1\n    channel = slopeSmoothstep(channel, 1. / blur);\n    \n    vec3 col;\n    if (mod(floor(iTime),4.) == 0.) { // \"for first second out of four\"\n        // Debug view\n        col = channel.rgb; // throws away .a, which turns it black\n    } else {\n        // Multiply each texture by the associated channel\n        col  = factorSample(iChannel0, uv, channel.r);\n        col += factorSample(iChannel1, uv, channel.g);\n        col += factorSample(iChannel2, uv, channel.b);\n        col += factorSample(iChannel3, uv, channel.a);\n    }\n    \n    fragColor = vec4(gamma(col),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}