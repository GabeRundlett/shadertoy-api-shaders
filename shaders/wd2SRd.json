{
    "Shader": {
        "info": {
            "date": "1554768685",
            "description": "Using FabriceNeyret2's gyroid object (again :), because the original does not render anymore in the browser here (Firefox and Chromium under Ubuntu on an AMD Vega64). This is a port back to ShaderToy/WebGL from a desktop-GL program I did of this.",
            "flags": 0,
            "hasliked": 0,
            "id": "wd2SRd",
            "likes": 16,
            "name": "Gyroid SDF",
            "published": 3,
            "tags": [
                "3d",
                "phong",
                "sdf",
                "shadow",
                "blinn",
                "gyroid",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "MacSlow",
            "viewed": 2502
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Gyroid object - Using FabriceNeyret2's gyroid object (again :), because the\n// original does not render anymore in the browser here (Firefox and Chromium\n// under Ubuntu on an AMD Vega64). This is a port back to ShaderToy/WebGL from\n// a desktop-GL program I did of this. Share and enjoy!\n//\n// The gyroid at https://www.shadertoy.com/view/XsdfRX\n//\n// Copyright 2019 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// set to 0 for free camera control\n#define AUTO_ROTATE_CAM 1\n\n// set to 0 to have still object\n#define AUTO_ROTATE_OBJECT 1\n\n// set to 1 to make object 'wiggle' a bit\n#define WAVE_OBJECT 0\n\n// set to 1 to change object \n#define GYROID_TORUS 0\n\nmat2 r2d (float deg) {\n\tfloat r = radians (deg);\n\tfloat c = cos (r);\n\tfloat s = sin (r);\n\treturn mat2 (c,s,-s,c);\n}\n\nmat3 r3d (float deg)\n{\n\tfloat r = radians (deg);\n    float c = cos (r);\n    float s = sin (r);\n    mat3 m = mat3 (vec3 ( c,  s, .0),\n                   vec3 (-s,  c, .0),\n                   vec3 (.0, .0, .0));\n\n    return m;\n}\n\n// hash(), noise(), fbm() are from an example by iq and/or Shane\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3. - 2.*f);\n\n    float n = p.x + p.y*57. + 113.*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p ) {\n    float f;\n    mat3 m = r3d (1.1);\n\n    f  = .5*noise( p ); p = m*p*2.02;\n    f += .25*noise( p ); p = m*p*2.23;\n    f += .125*noise( p ); p = m*p*2.71;\n    f += .0625*noise( p );\n\n    return f;\n}\n\n// Adapted FabriceNeyret2's gyroid object  from https://www.shadertoy.com/view/MdcfWH\nfloat gyroid (vec3 p, float size, float thickness, float scale) {\n\tfloat surfaceSide = dot (scale*sin (p), scale*cos (p.yzx));\n\tfloat d = abs (surfaceSide) - thickness;\n\tvec3 a = abs (p);\n\treturn max (d, max (a.x, max (a.y, a.z)) - size);\n}\n\nconst float PI = 3.14159;\n\n// gyroid-torus from https://www.shadertoy.com/view/WsjXDK\nfloat sdGyroidTorus (vec3 q, float rt, float rg, float ws) {\n  q.xz = vec2 (rt * atan (q.z, - q.x), length (q.xz) - rt);\n  q.yz = vec2 (rg * atan (q.z, - q.y), length (q.yz) - rg);\n  return .6* max(abs(dot(sin(q), cos(q).yzx)) - ws, abs(q.z) - .5*PI);\n}\n\nfloat map (vec3 p, inout int id, inout vec3 pout) {\n\tfloat ground = p.y + 2.;\n\n\tvec3 pobject = p + vec3 (.0, .6, .0);\n\n    #if AUTO_ROTATE_OBJECT\n\tpobject.xz *= r2d (45.*iTime);\n    #endif\n\n    #if WAVE_OBJECT\n    pobject.xz += .3* (.5 + .5*(cos (3.*iTime + 3.*pobject.y)));\n    #endif\n\n    #if GYROID_TORUS\n    float object = sdGyroidTorus (6.*pobject, 15., 4., .2);\n    #else\n    float object = gyroid (3.*pobject, 4., .075, .75);\n    #endif\n\n\tfloat d = min (ground, object);\n\n\tif (d == ground) {id = 1; pout = p;}\n\tif (d == object) {id = 2; pout = pobject;}\n\n    return d;\n}\n\nfloat march (vec3 ro, vec3 rd, inout int id, inout vec3 pout)\n{\n\tfloat t = .0;\n\tfloat d = .0;\n\tfor (int i = 0; i< 96; ++i) {\n\t\tvec3 p = ro+d*rd;\n\t\tt = map (p, id, pout);\n\t\tif (abs (t) < .00001*(1. + .125*t)) break;\n\t\td += t*.25;\n\t}\n\treturn d;\n}\n\nvec3 norm (vec3 p){\n\tint foo;\n\tvec3 bar;\n\tfloat d = map (p, foo, bar);\n\tvec2 e = vec2 (.001, .0);\n\treturn normalize (vec3 (map (p+e.xyy, foo, bar),\n                            map (p+e.yxy, foo, bar),\n                            map (p+e.yyx, foo, bar))-d);\n}\n\nfloat sha (vec3 p, vec3 lp, vec3 n, vec3 ldir) {\n\tfloat d2l = distance (lp, p);\n\tint foo;\n\tvec3 bar;\n\tfloat d2w = march (p+.01*n, ldir, foo, bar);\n\treturn d2l < d2w ? 1. : .1;\n}\n\nfloat ao (vec3 p, vec3 n, float stepsize, float i) {\n\tfloat ao = .0;\n\tfloat dist = .0;\n\tint foo;\n\tvec3 bar;\n\tfor (int a = 1; a <= 8; ++a) {\n\t\tdist = float (a)*stepsize;\n\t\tao += max (.0, (dist - map (p+n*dist, foo, bar))/dist);\n\t}\n\treturn 1. - ao*i;\n}\n\nvec3 shade (vec3 ro, vec3 rd, float d, vec3 n, vec3 lp, vec3 lc, float li, int id, vec3 pout) {\n    vec3 p = ro + d*rd;\n\tfloat ld = distance (p, lp); \n\tvec3 ldir = normalize (lp - p);\n\tfloat att = 5. / (ld*ld);\n\tvec3 mat = vec3 (.2);\n\tif (id == 1) {\n        // trying to simulate wood grain\n\t\tfloat f = fbm (5.*pout*vec3 (.8*cos(20. + pout.x + pout.z), 2., .3));\n\t\tmat = mix (vec3 (.3, .2, .1),\n\t\t\t\t   vec3 (.6, .55, .3),\n\t\t\t\t   smoothstep(.0, .9, f));\n\t}\n    if (id == 2) {\n        // a stripy texture to better 'sell' the shape of the gyroid surface\n        mat = mix (vec3 (.1),\n                   vec3 (.3),\n                   smoothstep (.1,.9,cos (60.*pout.y)));\n    }\n\tfloat s = sha (p, lp, n, ldir);\n\tfloat diff = max (.0, dot (n, ldir));\n\tvec3 h = normalize (-rd + ldir);\n\tfloat shiny = 100.;\n\tfloat sp = pow (max (.0, dot (n, h)), shiny);\n\tvec3 am = vec3 (.05);\n\tfloat ao = ao (p, n, .1, .1);\n\treturn ao*att*s*(am + diff*lc*li*mat + sp*vec3 (1.));\n}\n\nvec3 cam (vec2 uv, vec3 ro, vec3 aim, float zoom) {\n\tvec3 f =normalize (aim - ro);\n\tvec3 wu = vec3 (.0, 1., .0);\n\tvec3 r = normalize (cross (wu, f));\n\tvec3 u = normalize (cross (f, r));\n\tvec3 c = ro + f*zoom;\n\treturn normalize (c + r*uv.x+u*uv.y - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalize, aspect-correct and bulge UVs\n\tvec2 uvRaw = fragCoord.xy/iResolution.xy;\n\tvec2 uv = uvRaw*2. - 1.;\n\tuv.x *= iResolution.x/iResolution.y;\n\tuv *= 1. + .5*length (uv);\n\n\n\t// build view raw\n\tfloat dist = 4.;\n    float t = .0;\n    vec3 ro;\n    #if (AUTO_ROTATE_CAM)\n    t = .2*iTime;\n\tro = vec3 (dist*cos (t), 2., dist*sin(t));\n    #else\n    float azimuthAngle = ((iMouse.x / iResolution.x)*2. - 1.)*179.;\n    float elevationAngle = 30. + ((iMouse.y / iResolution.y)*2. - 1.)*50.;\n    float x = dist*cos (radians (azimuthAngle));\n    float y = dist*sin (radians (elevationAngle));\n    float z = dist*sin (radians (azimuthAngle));\n    ro.xz = vec2(x, z);\n    ro.y = y;\n\t#endif\n\n\tvec3 rd = cam (uv, ro, vec3 (.0, -.5, .0), 1.75);\n\n    // raymarch, point- and normal-generation\n    int id = 0;\n\tvec3 pout = vec3 (.0);\n\tfloat d = march (ro, rd, id, pout);\n    float fog = 1. / (1. + d*d*.025);\n\tvec3 p = ro + d*rd;\n\tvec3 n = norm (p);\n\n    // apply lighting/shading for four different light sources\n\tvec3 col = shade (ro, rd, d, n, vec3 (2., 1.5, 3.), vec3 (.9, .85, .5), 6.,id, pout);\n\tcol += shade (ro, rd, d, n, vec3 (.0, 4., 1.), vec3 (.2, .2, .9), 9.,id, pout);\n\tcol += shade (ro, rd, d, n, vec3 (-3., 1., .5), vec3 (.9, .5, .3), 4.,id, pout);\n\tcol += shade (ro, rd, d, n, vec3 (1., .5, -3.), vec3 (.5), 9.,id, pout);\n\n    // fog, tone-map, vignette, gamma-correct, color-correct\n    col *= fog;\n\tcol = col / (1. + col);\n\tcol *= 1. - .65*length(uvRaw*2.-1.);\n\tcol = pow (col, vec3 (1./2.2));\n    col = smoothstep (vec3 (.075), vec3 (.925), col);\n\n    fragColor = vec4(col, 1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}