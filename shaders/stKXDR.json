{
    "Shader": {
        "info": {
            "date": "1640534391",
            "description": "This one was a bit of a struggle. Getting the image from my head into the shader was more difficult than I could implement. :/",
            "flags": 1,
            "hasliked": 0,
            "id": "stKXDR",
            "likes": 14,
            "name": "Amazing Spider-Man (Sewer)",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "water",
                "caustics",
                "movie",
                "spiderman",
                "cineshader"
            ],
            "usePreview": 1,
            "username": "dean_the_coder",
            "viewed": 5147
        },
        "renderpass": [
            {
                "code": "// 'Amazing Spider-Man (Sewer)' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/stKXDR (YouTube: https://youtu.be/khgZbRSwmFk)\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// This one was a bit of a struggle. Getting the image from my head\n// into the shader was more difficult than I could implement.\n// Having webs with a small diameter going off into the distance\n// are tricky to raymarch quickly, and to make the scene better\n// I'd need some focal point adding to it (maybe lizards walking\n// on the webs, but that's beyond my ability atm).\n//\n// Hey ho - It was a fun scene to make, and I've learnt things I\n// can use in later shaders. :)\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// totetmatt, Blackle, Dave Hoskins, byt3_m3chanic, tater,\n// and a bunch of others for sharing their time and knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define R\tiResolution\n#define Z0\tmin(iTime, 0.)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S(a, b, c)\tsmoothstep(a, b, c)\n#define S01(a)\tS(0., 1., a)\n#define minH(a, b, c)\t{ float h_ = a; if (h_ < h.d) h = Hit(h_, b, c); }\n\nfloat t,\n      fade = 1.;\nstruct Hit {\n\tfloat d;\n\tint id;\n\tvec3 p;\n};\n\nfloat n31(vec3 p) {\n\t// Thanks Shane - https://www.shadertoy.com/view/lstGRB\n    const vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat n21(vec2 p) { return n31(vec3(p, 1)); }\n\nfloat smin(float a, float b) {\n\tfloat h = sat(.5 + .5 * (b - a) / .1);\n\treturn mix(b, a, h) - .1 * h * (1. - h);\n}\n\nfloat min2(vec2 v) { return min(v.x, v.y); }\n\nfloat max3(vec3 v) { return max(v.x, max(v.y, v.z)); }\n\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max3(q), 0.);\n}\n\nfloat web(vec3 p, vec3 ano) {\n\tfloat lp = dot(p, p),\n\t      d = 1e7;\n\tp.xz *= rot(ano.z);\n\tmat2 r = rot(ano.x);\n\tfor (float i = 0.; i < ano.y; i++) {\n\t\td = min(d, length(p - vec3(max(p.x, 0.), 0, 0)));\n\t\tp.xz *= r;\n\t}\n\n\tvec2 a = sin(lp * vec2(8, 32)) * .5 + 1.;\n\treturn d - .005 * (.5 + dot(a * a * a, vec2(.26, .1)) + .5);\n}\n\nvec3 rayDir(vec3 ro, vec2 uv) {\n\tvec3 f = normalize(vec3(0, 0, 4) - ro),\n\t     r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nvec3 dtc(vec2 p, vec3 c) {\n\tif (abs(p.x) > .6 || abs(p.y) > .5) return c;\n\tif (step(min2(abs(p - vec2(0, .2))), .08) * step(p.y, .3) * step(abs(p.x), .4) > 0.) return vec3(8);\n\tfloat f,\n\t      dc = step(.5, p.x);\n\tp.x = abs(p.x) - .46;\n\tf = dot(p, p);\n\tdc += step(f, .25) * step(.16, f);\n\tif (dc > 0.) return vec3(3);\n\treturn c;\n}\n\nfloat watD(vec3 p, bool b) {\n\tif (b) {\n\t\tp.xz *= rot(t * .1);\n\t\tp.z += .1 * t;\n\t}\n\telse p.xz += t;\n\n\tp.y += t * .5;\n\treturn dot(vec2(n21(p.xz * 2.3 * mat2(.5403, .84147, -.84147, .5403)), n31(p.zyx * 5.1)), vec2(.15, .06));\n}\n\nfloat wat(vec3 p) {\n\tfloat d = p.y + 1.95 + watD(p, true),\n\t      disp = watD(p, false);\n\tp.xz *= mat2(.77722, -.62922, .62922, .77722);\n\tp += vec3(1.9, 2.1, -23.4);\n\treturn smin(d, box(p, vec3(.5, .2 + disp, 15. - disp)) - .2);\n}\n\nvec3 watN(vec3 p) {\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * wat(p + e);\n\t}\n\n\treturn normalize(n);\n}\n\nfloat webs(vec3 p) {\n\tp.y += .3;\n\tp.z -= 3.;\n\tfloat d = web(p, vec3(.1, 2, 7.1));\n\td = min(d, web(p, vec3(.17, 12, 4.06)));\n\tp.xy *= mat2(.83094, -.55636, .55636, .83094);\n\treturn min(d, web(p, vec3(.1, 2, 2.02)));\n}\n\nbool water = true;\nHit map(vec3 p) {\n\tfloat lp,\n\t      d = max(p.y + 2.2, 5. - length(p.xz));\n\tHit h = Hit(d, 2, p);\n\tminH(webs(p), 4, p);\n\tif (water) minH(wat(p), 1, p);\n\tp.z -= 3.;\n\tlp = length(p);\n\td = max(abs(lp - 26.5) - 20., -(length(p.xz) - 3.));\n\tvec3 q = p;\n\tq.y++;\n\tq.yz *= mat2(.94496, -.32719, .32719, .94496);\n\tq.xz *= mat2(.9383, .34583, -.34583, .9383);\n\td = max(d, 1.2 - length(q.xy));\n\tq = p;\n\tq.y += .4;\n\tq.xz *= mat2(.77722, -.62922, .62922, .77722);\n\td = max(d, 1.5 - length(q.xy));\n\tminH(d, 3, p);\n\td = box(q + vec3(0, 1.5, 0), vec3(1, .2, 50));\n\tq.x = abs(q.x) - 1.6;\n\tq.y += 1.8;\n\td = max(min(d, box(q, vec3(1, 1, 50))), 6.52 - lp);\n\tminH(d, 2, q);\n\treturn h;\n}\n\nvec3 N(vec3 p, float t) {\n\tfloat h = t * .4;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h).d;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat shadow(vec3 p) {\n\tfloat d,\n\t      s = 1.,\n\t      t = .1,\n\t      mxt = length(p - vec3(0, 8.2, 3));\n\tvec3 ld = normalize(vec3(0, 8.2, 3) - p);\n\tfor (float i = Z0; i < 15.; i++) {\n\t\td = map(t * ld + p).d;\n\t\ts = min(s, 15. * d / t);\n\t\tt += max(.1, d);\n\t\tif (mxt - t < .5 || s < .001) break;\n\t}\n\n\treturn S01(s);\n}\n\nfloat aof(vec3 p, vec3 n, float h) { return sat(map(h * n + p).d / h); }\n\nfloat fog(float d) { return exp(d * d * -5e-4) * S(30., 5., d); }\n\nvec3 lights(vec3 p, vec3 rd, vec3 n, Hit h) {\n\tconst vec2 spe = vec2(10, 1);\n\tvec3 c, ns,\n\t     ld = normalize(vec3(0, 8.2, 3) - p);\n\tfloat ao,\n\t      sha = .02 + shadow(p) * (.01 + S(6.8, 5.8, length(p.xz)));\n\tns = vec3(n31(h.p * 50.), n31(h.p * .5), n31(h.p * 3.));\n\tif (h.id == 3) {\n        // Walls.\n\t\tconst vec3 cs = vec3(.05, .025, 0);\n\t\tfloat v = abs(fract(atan(h.p.z, h.p.x) * 1.90986) - .2);\n\t\tc = vec3(.1);\n\t\tc = mix(pow(ns.x * .03 + c, vec3(1.6, 1.1 + .5 * S(.35, .5, ns.y), 1.6)), c, sat(v * 6.) * .4);\n\t\tc *= .8 + .2 * S(1., .46, ns.z);\n\t\tc = mix(.4 * pow(c, vec3(.75, .8, .66)), c, step(.2 * ns.z - 2., p.y));\n\t\tc = mix(c, ns.x * dtc((h.p.xy - vec2(4, -.5)) * vec2(-1.5, 1.5) * mat2(.91309, -.40776, .40776, .91309), c), .2);\n\t\tc *= .5 + .5 * S01(v * 70.);\n\t\tc *= .5 + .5 * S01(abs(h.p.y - 2.5) * 40.);\n\t\tvec3 uv = p * .2;\n\t\tvec2 q = vec2(watD(uv + cs, true), watD(uv + cs.zyx, true));\n\t\tc += pow(S01(abs(length((watD(uv, true) - q) / .05) - .5)), 4.) * 2.;\n\t}\n\telse if (h.id == 2) {\n        // Ground/steps.\n\t\tc = vec3(.05 - .04 * step(length(p.xz), 6.));\n\t\tif (p.y > -2.) c *= .3 + .7 * S(0., .02, abs(fract(h.p.z * .2) - .5)) * ns.x;\n\t}\n\telse {\n\t\tif (h.id == 1) {\n            // Water.\n\t\t\tn = normalize(n + vec3(0, 0, ns.x * .07));\n\t\t\tsha += .02;\n\t\t\treturn vec3((pow(sat(dot(rd, reflect(ld, n))), 20.) * 25. + S(.6, 1., 1. + dot(rd, n)) * .1 + S(.85, 1., wat(.3 * ld + p) / .3) * .03) * sha);\n\t\t}\n\n\t\tc = vec3(ns.x);\n\t}\n\n\tao = mix(aof(p, n, .2), aof(p, n, 2.), .7);\n\treturn mix((sat(.1 + .9 * dot(ld, n)) * (.3 + .7 * sha) * (.3 + .7 * ao) + sat(.1 + .9 * dot(ld * vec3(-1, 0, -1), n)) * .2 + pow(sat(dot(rd, reflect(ld, n))), spe.x) * spe.y) * ao * c * vec3(1, .9, .8), vec3(.002), S(.7, 1., 1. + dot(rd, n)) * .5);\n}\n\nvec3 scene(vec3 p, vec3 rd) {\n\tfade = min(1., abs(t));\n\tHit h;\n\tfloat d = 0.;\n\tfor (float i = Z0; i < 1e2; i++) {\n\t\th = map(p);\n\t\tif (abs(h.d) < .0015) break;\n\t\td += h.d;\n\t\tp += h.d * rd;\n\t}\n\n\tif (h.id == 1) {\n        // We hit water - Refract.\n\t\tvec3 n = watN(p),\n\t\t     col = lights(p, rd, n, h);\n\t\trd = refract(rd, n, .99);\n\t\tp += .1 * rd;\n\t\twater = false;\n\t\tfor (float i = Z0; i < 5.; i++) {\n\t\t\th = map(p);\n\t\t\tif (abs(h.d) < .0015) break;\n\t\t\tp += rd * h.d;\n\t\t}\n\n\t\tcol += pow(lights(p, rd, n, h), vec3(1, .9, .8));\n\t\treturn mix(vec3(.002), col, fog(length(p)));\n\t}\n\n\treturn mix(vec3(.002), lights(p, rd, N(p, d), h), fog(d));\n}\n\n#define rgba(col)\tvec4(pow(max(vec3(0), col), vec3(.45)) * fade, 0)\n\nvoid mainVR(out vec4 fragColor, vec2 fc, vec3 ro, vec3 rd) {\n\tt = mod(iTime, 30.);\n\trd.xz *= mat2(1, 0, 0, -1);\n\tfragColor = rgba(scene(ro, rd));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tt = mod(iTime, 30.);\n\tvec2 uv = (fc - .5 * R.xy) / R.y,\n\t     v = fc.xy / R.xy;\n\tvec3 ro = vec3(sin(iTime * vec2(.5, .2)) * .04 + vec2(0, .2 - .4 * cos(t * .2)), 0),\n\t     col = scene(ro, rayDir(ro, uv));\n\tcol *= .5 + .5 * pow(16. * v.x * v.y * (1. - v.x) * (1. - v.y), .4);\n\tfragColor = rgba(col);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}