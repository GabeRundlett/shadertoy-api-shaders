{
    "Shader": {
        "info": {
            "date": "1481702970",
            "description": "An experimental shading technique I've created, which interpolates between the ambient color and light color, depending on the dot product of the light direction and surface normal.\n\nNot very realistic, might work in some kind of artistic render :)",
            "flags": 32,
            "hasliked": 0,
            "id": "XttXD2",
            "likes": 2,
            "name": "Ambient Interpolation Shading",
            "published": 3,
            "tags": [
                "raytracer",
                "shading",
                "ambient",
                "interpolation"
            ],
            "usePreview": 0,
            "username": "jackdavenport",
            "viewed": 744
        },
        "renderpass": [
            {
                "code": "// Ambient Interpolation Shading\n// Created by jackdavenport\n// All credit is commented above the relevant code.\n// You can use any of this code, so long as you give permission.\n// Enjoy the shader! :)\n\n// UI Shader\n\n// Thnx FabriceNeyret2!\n// Source: https://www.shadertoy.com/view/ltcXzs\nvec4 char(vec2 pos, float c) {\n    pos = clamp(pos,0.,1.);\n\treturn texture( iChannel1, pos/16. + fract( floor(vec2(c, 15.999-c/16.)) / 16. ) );\n}\n#define c(a) ch = char(uv, a); fragColor.xyz = mix(fragColor.xyz, tint.xyz, ch.x*tint.w); uv.x -= .5;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n    \n    float bord = (.5+.5*sin(iTime))*iResolution.x;\n    if(iMouse.z > 0.) {\n        bord = iMouse.x;\n    }\n    \n    vec4 ch;\n    vec4 tint = vec4(1.);\n    uv  = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    uv *= 10.;\n    uv.x += 9.;\n    uv.y += 4.8;\n    if(fragCoord.x > bord) {\n        tint.w = 0.;\n    }\n    c(65.);  // A\n    c(73.);  // I\n    c(83.);  // S\n    uv.x -= 13.5;\n    if(fragCoord.x < bord) {\n        tint.w = 0.;\n    } else {\n        tint.w = 1.;\n    }\n    c(80.);  // P\n    c(104.); // h\n    c(111.); // o\n    c(110.); // n\n    c(103.); // g\n    \n    if(fragCoord.x > bord-1. && fragCoord.x < bord+1.) {\n        fragColor.xyz = vec3(0.);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Ambient Interpolation Shading\n// Created by jackdavenport\n// All credit is commented above the relevant code.\n// You can use any of this code, so long as you give permission.\n// Enjoy the shader! :)\n\n// Main Renderer\n\n#define PI 3.14159265359\n\n#define LIGHT_COL vec3(1.,.9,.85)\n#define LIGHT_AMB vec3(.2,.2,.15)\n#define LIGHT_DIR vec3(0.639602, 0.426401, -0.639602)\n\nvec4 sph(vec3 ro, vec3 rd, vec3 p, float r) {\n    float a = dot(rd, rd);\n    float b = dot(rd, ro-p)*2.;\n    float c = dot(ro-p, ro-p)-(r*r);\n    float d = (b*b)-4.*a*c;\n    float l = (-b-sqrt(d))/(2.*a);\n    if(l < 0. || d < 0.) {\n        return vec4(0.,0.,0.,-1.);\n    }\n    return vec4(normalize((ro+rd*l)-p), l);\n}\nvec4 flr(vec3 ro, vec3 rd, vec3 p, vec3 n) {\n    float a = -dot(n, ro-p);\n    float b =  dot(n, rd);\n    float c = a / b;\n    return vec4(n, c < 0. ? -1. : c);\n}\nvec4 lequal(vec4 a, vec4 b) {\n    if(a.w < 0. || (b.w > -1. && b.w < a.w)) {\n        return b;\n    }\n    return a;\n}\n\nvec4 scnTrace(vec3 ro, vec3 rd) {\n    vec4 s = sph(ro, rd, vec3(0.), 1.);\n    s = lequal(s, flr(ro, rd, vec3(0.,-1.,0.), vec3(0.,1.,0.)));\n    return s;\n}\n\nvec3 calcLighting(vec3 col, vec3 p, vec3 n, vec3 r, float bord, vec2 fragCoord) {\n    float d = max(dot(LIGHT_DIR,n),0.);\n    float s = pow(max(dot(LIGHT_DIR,r),0.),15.);\n       \n    float a = 1.;\n    if(scnTrace(p+LIGHT_DIR*.01,LIGHT_DIR).w > -1.) {\n        a = 0.;\n    }\n    \n    if(bord < fragCoord.x) {\n    \t// Phong Shading\n     \tcol = (col*LIGHT_COL*(LIGHT_AMB+d*a))+(LIGHT_COL*s*a);\n   \t} else {\n    \t// Ambient Interpolation Shading\n    \tcol = mix(LIGHT_AMB,LIGHT_COL,d*a)*col+(LIGHT_COL*s*a);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    vec3 ro = vec3(0.,0.,-3.);\n    vec3 rd = vec3(uv, 1.);\n    \n    float bord = (.5+.5*sin(iTime))*iResolution.x;\n    if(iMouse.z > 0.) {\n        bord = iMouse.x;\n    }\n    \n\tvec4 scn = scnTrace(ro, rd);\n    vec3 col = texture(iChannel0, rd).xyz;\n    if(scn.w > -1.) {\n        vec3 p = ro+rd*scn.w;\n        vec3 n = scn.xyz;\n        vec3 r = normalize(reflect(rd, n));\n        \n        vec2 uv;\n        if(p.y < -.99) {\n            uv = p.xz * .1;\n        } else {\n          \tuv = asin(n.xy) / PI + .5;  \n        }\n        col = texture(iChannel1, uv).xyz;\n        \n        col = calcLighting(col, p, n, r, bord, fragCoord);\n    }\n    \n    fragColor.xyz = col;\n    fragColor.w   = 1.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}