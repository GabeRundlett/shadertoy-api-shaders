{
    "Shader": {
        "info": {
            "date": "1503937861",
            "description": "experiments with procedural noise for clouds, 2d for now",
            "flags": 34,
            "hasliked": 0,
            "id": "4lXczM",
            "likes": 1,
            "name": "2d cloud test",
            "published": 3,
            "tags": [
                "clouds"
            ],
            "usePreview": 0,
            "username": "westlicht",
            "viewed": 889
        },
        "renderpass": [
            {
                "code": "// hash functions\n\n#define HASHSCALE1 .1031\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n\n\n//Not able to use bit operator like <<, so use alternative noise function from YoYo\n//\n//https://www.shadertoy.com/view/Mls3RS\n//\n//And it is a better realization I think\nfloat noise(int x,int y)\n{   \n    return hash12(vec2(x,y));\n    float fx = float(x);\n    float fy = float(y);\n    \n    return 2.0 * fract(sin(dot(vec2(fx, fy) ,vec2(12.9898,78.233))) * 43758.5453) - 1.0;\n}\n\nfloat smoothNoise(int x,int y)\n{\n    return noise(x,y)/4.0+(noise(x+1,y)+noise(x-1,y)+noise(x,y+1)+noise(x,y-1))/8.0+(noise(x+1,y+1)+noise(x+1,y-1)+noise(x-1,y+1)+noise(x-1,y-1))/16.0;\n}\n\nfloat COSInterpolation(float x,float y,float n)\n{\n    float r = n*3.1415926;\n    float f = (1.0-cos(r))*0.5;\n    return x*(1.0-f)+y*f;\n    \n}\n\nfloat perlin2d(vec2 p) {\n    ivec2 i = ivec2(p);\n    vec2 frac = fract(p);\n    float v1 = smoothNoise(i.x, i.y);\n    float v2 = smoothNoise(i.x + 1, i.y);\n    float v3 = smoothNoise(i.x, i.y + 1);\n    float v4 = smoothNoise(i.x + 1, i.y + 1);\n   \tfloat i1 = COSInterpolation(v1,v2,frac.x);\n    float i2 = COSInterpolation(v3,v4,frac.x);\n    \n    return COSInterpolation(i1,i2,frac.y);\n}\n\n// WORLEY NOISE from https://www.shadertoy.com/view/MstGRl\n\n// Determines how many cells there are\n#define NUM_CELLS 16.0\n\n// Arbitrary random, can be replaced with a function of your choice\nfloat _rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand(vec2 co) { return hash12(co); }\n\n// Returns the point in a given cell\nvec2 get_cell_point(ivec2 cell) {\n\tvec2 cell_base = vec2(cell) / NUM_CELLS;\n\tfloat noise_x = rand(vec2(cell));\n    float noise_y = rand(vec2(cell.yx));\n    return cell_base + (0.5 + 1.5 * vec2(noise_x, noise_y)) / NUM_CELLS;\n}\n\n// Performs worley noise by checking all adjacent cells\n// and comparing the distance to their points\nfloat worley2d(vec2 coord) {\n    ivec2 cell = ivec2(coord * NUM_CELLS);\n    float dist = 1.0;\n    \n    // Search in the surrounding 5x5 cell block\n    for (int x = 0; x < 5; x++) { \n        for (int y = 0; y < 5; y++) {\n        \tvec2 cell_point = get_cell_point(cell + ivec2(x-2, y-2));\n            dist = min(dist, distance(cell_point, coord));\n\n        }\n    }\n    \n    dist /= length(vec2(1.0 / NUM_CELLS));\n    dist = 1.0 - dist;\n    return dist;\n}\n\n// FBM\n\n#define fbm2d(_vectype_, _name_, _noise_) \\\nfloat _name_(_vectype_ p, int firstOctave, int numOctaves, float persistence) { \\\n    float sum = 0.0; \\\n    for (int i = firstOctave; i < firstOctave + numOctaves; ++i) { \\\n        float freq = pow(2.0, float(i)); \\\n        float amp = pow(persistence, float(i)); \\\n        sum += _noise_(p * freq) * amp; \\\n    } \\\n    return sum; \\\n}\n\nfbm2d(vec2, fbmPerlin2d, perlin2d)\nfbm2d(vec2, fbmWorley2d, worley2d)\n\n\n// REMAP\n\nfloat remap(float x, float lo1, float hi1, float lo2, float hi2) {\n    return lo2 + (x - lo1) / (hi1 - lo1) * (hi2 - lo2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.y *= (iResolution.y / iResolution.x);\n    float base = fbmWorley2d(uv * 0.2 + vec2(iTime * 0.005), 1, 2, 0.6);\n    float detail = 0.3+0.2*fbmPerlin2d(uv*10.0 + vec2(iTime*0.01,0.0), 3, 5, 0.8);\n    float noise = remap(detail, 1.0 - base, 1.0, 0.0, 1.0) * 2.0;\n    //noise = base;\n    //noise = detail;\n    fragColor = vec4(noise,noise,noise,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const int firstOctave = 2;\nconst int octaves = 8;\nconst float persistence = 0.7;\n\n//Not able to use bit operator like <<, so use alternative noise function from YoYo\n//\n//https://www.shadertoy.com/view/Mls3RS\n//\n//And it is a better realization I think\nfloat noise(int x,int y)\n{   \n    float fx = float(x);\n    float fy = float(y);\n    \n    return 2.0 * fract(sin(dot(vec2(fx, fy) ,vec2(12.9898,78.233))) * 43758.5453) - 1.0;\n}\n\nfloat smoothNoise(int x,int y)\n{\n    return noise(x,y)/4.0+(noise(x+1,y)+noise(x-1,y)+noise(x,y+1)+noise(x,y-1))/8.0+(noise(x+1,y+1)+noise(x+1,y-1)+noise(x-1,y+1)+noise(x-1,y-1))/16.0;\n}\n\nfloat COSInterpolation(float x,float y,float n)\n{\n    float r = n*3.1415926;\n    float f = (1.0-cos(r))*0.5;\n    return x*(1.0-f)+y*f;\n    \n}\n\nfloat InterpolationNoise(float x, float y)\n{\n    int ix = int(x);\n    int iy = int(y);\n    float fracx = x-float(int(x));\n    float fracy = y-float(int(y));\n    \n    float v1 = smoothNoise(ix,iy);\n    float v2 = smoothNoise(ix+1,iy);\n    float v3 = smoothNoise(ix,iy+1);\n    float v4 = smoothNoise(ix+1,iy+1);\n    \n   \tfloat i1 = COSInterpolation(v1,v2,fracx);\n    float i2 = COSInterpolation(v3,v4,fracx);\n    \n    return COSInterpolation(i1,i2,fracy);\n    \n}\n\nfloat PerlinNoise2D(float x,float y)\n{\n    float sum = 0.0;\n    float frequency =0.0;\n    float amplitude = 0.0;\n    for(int i=firstOctave;i<octaves + firstOctave;i++)\n    {\n        frequency = pow(2.0,float(i));\n        amplitude = pow(persistence,float(i));\n        sum = sum + InterpolationNoise(x*frequency,y*frequency)*amplitude;\n    }\n    //\n    return sum;\n}\n\n\n// WORLEY NOISE from https://www.shadertoy.com/view/MstGRl\n\n// Determines how many cells there are\n#define NUM_CELLS 16.0\n\n// Arbitrary random, can be replaced with a function of your choice\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Returns the point in a given cell\nvec2 get_cell_point(ivec2 cell) {\n\tvec2 cell_base = vec2(cell) / NUM_CELLS;\n\tfloat noise_x = rand(vec2(cell));\n    float noise_y = rand(vec2(cell.yx));\n    return cell_base + (0.5 + 1.5 * vec2(noise_x, noise_y)) / NUM_CELLS;\n}\n\n// Performs worley noise by checking all adjacent cells\n// and comparing the distance to their points\nfloat worley(vec2 coord) {\n    ivec2 cell = ivec2(coord * NUM_CELLS);\n    float dist = 1.0;\n    \n    // Search in the surrounding 5x5 cell block\n    for (int x = 0; x < 5; x++) { \n        for (int y = 0; y < 5; y++) {\n        \tvec2 cell_point = get_cell_point(cell + ivec2(x-2, y-2));\n            dist = min(dist, distance(cell_point, coord));\n\n        }\n    }\n    \n    dist /= length(vec2(1.0 / NUM_CELLS));\n    dist = 1.0 - dist;\n    return dist;\n}\n\n// REMAP\n\nfloat remap(float x, float lo1, float hi1, float lo2, float hi2) {\n    return lo2 + (x - lo1) / (hi1 - lo1) * (hi2 - lo2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float pn = 0.3+0.7*PerlinNoise2D(uv.x + iTime*0.01,uv.y);\n    float wn = worley(uv * 0.4);\n    float noise = remap(pn, 1.0 - wn, 1.0, 0.0, 1.0) * 2.0;\n    fragColor = vec4(noise,noise,noise,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "webcam",
                        "id": 31,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/webcam.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}