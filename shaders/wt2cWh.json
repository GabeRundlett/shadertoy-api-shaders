{
    "Shader": {
        "info": {
            "date": "1594270306",
            "description": "Someone said my last shader reminded him of Twin Peaks, so I fixed it :)",
            "flags": 0,
            "hasliked": 0,
            "id": "wt2cWh",
            "likes": 4,
            "name": "Shaders are coming back in style",
            "published": 3,
            "tags": [
                "3d",
                "checkerboard",
                "ball"
            ],
            "usePreview": 0,
            "username": "koo1ant",
            "viewed": 285
        },
        "renderpass": [
            {
                "code": "#define t iTime\n#define resolution iResolution\n\n// Original shader: https://www.shadertoy.com/view/3tByzw\n\nprecision highp float;\n\nmat4 rotX(in float angle) {\n    return mat4(\n        1, 0, 0, 0,\n        0, cos(angle), - sin(angle), 0,\n        0, sin(angle), cos(angle), 0,\n    0, 0, 0, 1);\n}\n\nmat4 rotY(in float angle) {\n    return mat4(\n        cos(angle), 0, sin(angle), 0,\n        0, 1.0, 0, 0,\n        - sin(angle), 0, cos(angle), 0,\n    0, 0, 0, 1);\n}\n\nvec2 setupSpace(in vec2 f, in vec2 res)\n{\n    return\n    (f.xy / res.xy - 0.5) *\n    vec2(res.x / res.y, 1.0) * 2.0;\n}\n\nfloat sat(float v){\n    return clamp(v, 0.,1.);\n}\n\nvoid ball(inout float buf, vec2 uv, float phase, float radius, float bh) {\n    float bounce = abs(sin(t * 3.0 + phase)) * bh;\n    float bd = 1.00 + pow(abs(sin(t * 3.0 + 3.14 / 2.0 - 0.1 + phase)), 50.00) * 0.17;\n    float ballRadius = radius;\n    float shadowSize = abs(sin(t * 3.0 + phase)) * 1.00 + 1.00;\n    float a = atan(uv.y - bounce + 0.02, uv.x + -0.37);\n\n    // Shadow\n    float shadow = 1.0 - smoothstep(-0.5, 0.8, length(vec2(uv.x * (shadowSize*2.), uv.y * 1.75 * (shadowSize*2.)) - vec2(0.00, - 0.36)) - ballRadius + 0.0);\n    buf -= smoothstep(0.0, 0.8, shadow) * 0.65; // Soften the shadow a little bit\n\t\n    // Cut a hole in the buffer\n    buf *= step(0.00, length(vec2(uv.x/bd, uv.y * bd) - vec2(0.01, bounce)) - ballRadius);\n\n    // Add specular\n    float mask = sat(1.0 - step(0.00, length(vec2(uv.x/bd, uv.y * bd) - vec2(0.01, bounce)) - ballRadius));\n    float impulse = sin(t*6.+1.20); // Spin a little faster when it hits the ground\n    float spin = sin(a * 18.0 - ((t * 10.0) + impulse)) * 0.03;\n    float specular = smoothstep(\n        0.30 - spin,\n        -0.02,\n        length(vec2(uv.x / bd, uv.y * bd) - vec2(0.02, bounce + 0.14)) - ballRadius + 0.23) *  mask +\n        // Fake reflection\n        smoothstep(\n            0.30 + sin(a * 18.0 + t*10.) * 0.03,\n            +0.52,\n        length(vec2(uv.x / bd, uv.y * bd) - vec2(0.02, bounce + 0.14)) - ballRadius + 0.23) * mask;;\n\n    buf += specular;\n}\n\nvoid ground(inout float p, vec2 uv, float offset) {\n    vec2 guv = uv;\n    guv.x = abs(fract(guv.x*1.50)*2.-1.);\n\n    guv.y = fract(guv.y*2.70)*1.50 + offset + -1.00;\n    // Sine checkers\n    //p += step(sin(uv.y * 10.00) * sin(t), sin(uv.x * 10.0));\n    p -=  1.-step(0.00,guv.x+guv.y) -1.0 +step(0.77, guv.x + guv.y);\n}\n\nvoid light(inout float p, vec2 pv){\n    vec2 lightPos = vec2(pv.x, pv.y - 2.);\n    p *= 1.-smoothstep(0.0, 3.5, length(lightPos - vec2(sin(t), 0.0)));\n}\n\nvoid projection(inout vec2 pv){\n\t vec4 m =\n        vec4(pv.x, pv.y, 0.00, 0.00) *\n        rotY(sin(t * 1.0) * 0.1) *\n        rotX(0.60) *\n        1.2 + 0.2;\n    \n    pv /= abs(0.8 - m.z);\n}\n\nvec4 image()\n{\n    vec2 pv = setupSpace(gl_FragCoord.xy, resolution.xy); // Perspective UV\n    vec2 uv = setupSpace(gl_FragCoord.xy, resolution.xy); // Screen-space UV\n    float camPos = -t*0.8; // Camera speed\n    float p; // Image\n    \n   \tprojection(pv);\n    \n    pv.y += camPos;\n   \n    // Scene\n    float w = 1.50;\n    ground(p, pv, 0.00);\n    ground(p, pv, -w);\n    ground(p, pv, +w);\n    light(p, vec2(pv.x, pv.y - camPos));\n    ball(p, vec2(uv.x + 0.180 + sin(t*0.9+0.4)*0.1 , uv.y + -0.40), 1.00 , 0.18, 0.2);\n    \n    vec3 color = vec3(p);\n    color.r += -abs(uv.y)*0.1;\n    \n    return vec4(color, 1.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = image();\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}