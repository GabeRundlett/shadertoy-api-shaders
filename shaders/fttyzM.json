{
    "Shader": {
        "info": {
            "date": "1659465191",
            "description": "Using binary marching cubes to discretize the surface of an implicit function during raymarching.\nThis is a demo of the idea presented here: https://www.shadertoy.com/view/sltyRM\n\ncamera controls via mouse + shift key",
            "flags": 48,
            "hasliked": 0,
            "id": "fttyzM",
            "likes": 32,
            "name": "Binary Marching Cubes Demo",
            "published": 3,
            "tags": [
                "raymarching",
                "cubes",
                "marching"
            ],
            "usePreview": 0,
            "username": "TinyTexel",
            "viewed": 962
        },
        "renderpass": [
            {
                "code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n// https://twitter.com/Mirko_Salm\n\n/*\n    Using binary marching cubes to discretize the surface of an implicit function during raymarching.\n    This is a demo of the idea presented here: https://www.shadertoy.com/view/sltyRM\n    \n    As this is based on the original 15 marching cubes configurations, there are spots where\n    the original, triangulation based approach would result in a non-closed surface.\n    If you toggle the shading style (S) these parts of the surface show up as (desaturated) magenta.\n    \n    W - toggle wireframe\n    S - toggle shading style\n    \n    camera controls via mouse + shift key\n*/\n\n// if USE_LOOKUP_TABLE is used, GetSlopelPlane(...) isn't evaluated directly during raymarching,\n// but instead it is used to prepare a lookup table in BufferB as a replacement (this seems to be a bit faster).\n\n// #define USE_LOOKUP_TABLE\n\nfloat ReadKey(int keyCode) {return texelFetch(iChannel2, ivec2(keyCode, 0), 0).x;}\nfloat ReadKeyToggle(int keyCode) {return texelFetch(iChannel2, ivec2(keyCode, 2), 0).x;}\n\nfloat map(uvec3 tc)\n{\n    if(tc.x >= VOLUME_RES || tc.y >= VOLUME_RES || tc.z >= VOLUME_RES) return 1.0;\n    \n    float res05 = float(VOLUME_RES/2u);\n    \n    vec3 p = vec3(tc) - res05;\n    \n    vec4 n = textureLod(iChannel3, p / (32.0*6.0), 0.0);\n    \n    float f = Rotate(n.rg * 2.0 - 1.0, iTime * 0.25).x;\n    \n    return f;\n}\n\nbool ReadMCLookupEntry(sampler2D sampler, uint data, bvec3 oct, out vec3 N, out float D)\n{\n    uvec2 uv;\n    uv.x = data;\n    uv.y = (oct.x ? 1u : 0u) | (oct.y ? 2u : 0u) | (oct.z ? 4u : 0u);\n    \n    vec4 res = texelFetch(sampler, ivec2(uv), 0);\n    \n    N = res.xyz;\n    D = res.w;\n    \n    return D > -128.0;\n}\n\nbool IntersectMCCell(vec3 rp, vec3 rd, uint data, bvec3 oct, inout vec2 tt, inout vec3 N0)\n{\n    if(data == 0u) return false;\n\n    vec3 N; float D;\n    \n   #ifdef USE_LOOKUP_TABLE\n   \n    if(!ReadMCLookupEntry(iChannel1, data, oct, /*out:*/ N, D)) return false;\n    \n   #else\n   \n    if(!GetSlopelPlane(data, oct, /*out:*/ N, D)) return false;\n    \n   #endif\n\n    float PdN = dot(rp, N) - D;\n    float DdN = dot(rd, N);\n\n    float t = -1.0/DdN * PdN;\n\n    bool hit = true;\n\n    if(t < 0.0)\n    {\n        hit = PdN < 0.0;\n    }\n    else if(PdN < 0.0)\n    {\n        hit = t >= tt.x;\n    }\n    else\n    if(t > tt.x)\n    {\n        hit = t <= tt.y;\n\n        tt.x = t;\n\n        N0 = N;\n    }\n    \n    return hit;\n}\n\nbool VoxelRaycast(vec3 ro, vec3 rd, out vec3 vp, out vec3 N0, out float t)\n{\n    N0 = vec3(0.0);\n    t = 0.0;\n\tvp = floor(ro);\n\t\n    vec3 ri = 1.0/rd;\n    \n\tvec3 rs = vec3(rd.x < 0.0 ? -1.0 : 1.0,\n                   rd.y < 0.0 ? -1.0 : 1.0,\n                   rd.z < 0.0 ? -1.0 : 1.0);\n                     \n\tvec3 off = vec3(rd.x < 0.0 ? 0.0 : ri.x,\n                    rd.y < 0.0 ? 0.0 : ri.y,\n                    rd.z < 0.0 ? 0.0 : ri.z) - ro * ri;\n\n    uvec3 vpu = uvec3(ivec3(vp));\n    uvec3 rsu = uvec3(ivec3(rs));\n\n    uint data = 0u;\n    uvec3 tcL = uvec3(0x10000000u);\n\n    // when stepping into a new grid cell evaluate map() only at the 4 new vertices\n    // this is slower if evaluating map() 4 times is cheaper than shuffeling the data around\n    #define ONLY_EVAL_MAP_AT_NEW_VERTICES\n    \n#ifdef ONLY_EVAL_MAP_AT_NEW_VERTICES\n    {\n        uvec3 tc0 = uvec3(ivec3(vp));\n\n        uvec3 tc = ((tc0 + 1u) >> 1u) - 1u;\n\n        data =        (map(tc + uvec3(0u, 0u, 0u)) < 0.0 ? 1u << 0u : 0u);\n        data = data ^ (map(tc + uvec3(1u, 0u, 0u)) < 0.0 ? 1u << 1u : 0u);\n        data = data ^ (map(tc + uvec3(0u, 1u, 0u)) < 0.0 ? 1u << 2u : 0u);\n        data = data ^ (map(tc + uvec3(1u, 1u, 0u)) < 0.0 ? 1u << 3u : 0u);\n        data = data ^ (map(tc + uvec3(0u, 0u, 1u)) < 0.0 ? 1u << 4u : 0u);\n        data = data ^ (map(tc + uvec3(1u, 0u, 1u)) < 0.0 ? 1u << 5u : 0u);\n        data = data ^ (map(tc + uvec3(0u, 1u, 1u)) < 0.0 ? 1u << 6u : 0u);\n        data = data ^ (map(tc + uvec3(1u, 1u, 1u)) < 0.0 ? 1u << 7u : 0u);\n\n        tcL = tc;\n    }\n#endif\n\n\tvec3 mm = vec3(0.0);\n    vec3 t3 = vec3(0.0);\n    \n\tbool hit = false;\n\tfor(int i = 0; i < 512; i++) \n\t{\n        vec3 t30 = vp * ri + off;\n\t\t\n        vec3 mm0 = vec3(minmask(t30));\n        \n        \n       #if 1\n        uvec3 tc0 = uvec3(ivec3(vp));\n       #else\n        uvec3 tc0 = vpu;\n       #endif\n       \n        if(tc0.x >= VOLUME_RES*2u || tc0.y >= VOLUME_RES*2u || tc0.z >= VOLUME_RES*2u) return false;\n\n        uvec3 tc = ((tc0 + 1u) >> 1u) - 1u;\n\n#ifdef ONLY_EVAL_MAP_AT_NEW_VERTICES\n        if(tcL.x != tc.x || tcL.y != tc.y || tcL.z != tc.z)\n        {\n            if(mm.x != 0.0) data = ((data & 0x55u) << 1u) ^ ((data & 0xAAu) >> 1u);\n            if(mm.y != 0.0) data = ((data & 0x33u) << 2u) ^ ((data & 0xCCu) >> 2u);\n            if(mm.z != 0.0) data = ((data & 0x0Fu) << 4u) ^ ((data & 0xF0u) >> 4u);\n            \n            uint dir = dot(mm, rs) > 0.0 ? 1u : 0u;\n            \n            uvec3 off;\n            uint bm;\n            \n            off = mm.x != 0.0 ? uvec3(dir, 0u, 0u) : mm.y != 0.0 ? uvec3(0u, dir, 0u) : uvec3(0u, 0u, dir);\n            bm = 1u << (off.x + off.y * 2u + off.z * 4u);\n            data = (data & ~bm) | (map(tc + off) < 0.0 ? bm : 0u);\n\n            off = mm.x != 0.0 ? uvec3(dir, 1u, 0u) : mm.y != 0.0 ? uvec3(1u, dir, 0u) : uvec3(1u, 0u, dir);\n            bm = 1u << (off.x + off.y * 2u + off.z * 4u);\n            data = (data & ~bm) | (map(tc + off) < 0.0 ? bm : 0u);\n\n            off = mm.x != 0.0 ? uvec3(dir, 0u, 1u) : mm.y != 0.0 ? uvec3(0u, dir, 1u) : uvec3(0u, 1u, dir);\n            bm = 1u << (off.x + off.y * 2u + off.z * 4u);\n            data = (data & ~bm) | (map(tc + off) < 0.0 ? bm : 0u);\n\n            off = mm.x != 0.0 ? uvec3(dir, 1u, 1u) : mm.y != 0.0 ? uvec3(1u, dir, 1u) : uvec3(1u, 1u, dir);\n            bm = 1u << (off.x + off.y * 2u + off.z * 4u);\n            data = (data & ~bm) | (map(tc + off) < 0.0 ? bm : 0u);\n            \n            data = data & 255u;\n        }\n#else        \n        if(tcL.x != tc.x || tcL.y != tc.y || tcL.z != tc.z)\n        {\n            data =        (map(tc + uvec3(0u, 0u, 0u)) < 0.0 ? 1u << 0u : 0u);\n            data = data ^ (map(tc + uvec3(1u, 0u, 0u)) < 0.0 ? 1u << 1u : 0u);\n            data = data ^ (map(tc + uvec3(0u, 1u, 0u)) < 0.0 ? 1u << 2u : 0u);\n            data = data ^ (map(tc + uvec3(1u, 1u, 0u)) < 0.0 ? 1u << 3u : 0u);\n            data = data ^ (map(tc + uvec3(0u, 0u, 1u)) < 0.0 ? 1u << 4u : 0u);\n            data = data ^ (map(tc + uvec3(1u, 0u, 1u)) < 0.0 ? 1u << 5u : 0u);\n            data = data ^ (map(tc + uvec3(0u, 1u, 1u)) < 0.0 ? 1u << 6u : 0u);\n            data = data ^ (map(tc + uvec3(1u, 1u, 1u)) < 0.0 ? 1u << 7u : 0u);\n        }\n#endif        \n#undef DO_OPTIMIZE\n\n        tcL = tc;\n        \n        if(data != 0u)\n        {\n            vec2 tt = vec2(dot(t3 , mm ), \n                           dot(t30, mm0));\n\n            N0 = -rs * mm;\n\n            vec3 rp = ro - (vp + 0.5);\n        \n            bvec3 oct = equal(tc0 & 1u, uvec3(0u));\n        \n            if(IntersectMCCell(rp, rd, data, oct, /*inout*/ tt, N0))\n            {\n                t = tt.x;\n                \n                return true;\n            }\n            \n        }\n       \n        t3 = t30;\n        mm = mm0;\n        \n        vp += mm * rs;\n        vpu += uvec3(mm) * rsu;\n\t}\n\t\n\tN0 = -rs * mm;\n    t = dot(t3, mm);\n\n\treturn hit;\n}\n\nbool SceneRayCast(vec3 rp, vec3 rd, out vec3 n, out vec3 p)\n{\n    p = rp;\n    \n    vec2 tt; vec3 n0 = vec3(0.0);\n    float res = Intersect_Ray_Cube(rp - vec3(VOLUME_RES), rd, vec3(float(VOLUME_RES) - 1.0/1024.0), /*out:*/ tt);\n\n    if(res == -1.0) { return false; }\n    \n    if(res == 1.0)\n    {\n    \tp += rd * tt.x;\n        \n        n0 = vec3(maxmask(abs(p - vec3(VOLUME_RES)))) * -sign(rd);\n    }\n\n    vec3 vp; float t;\n\tbool hit = VoxelRaycast(p, rd, /*out:*/ vp, n, t);\n    \n    if(!hit)\n    {\n        return false;\n    }\n\n    if(n.x == 0.0 && n.y == 0.0 && n.z == 0.0)\n    {\n        n = n0;\n    }\n    \n    n = normalize(n);\n    \n    p += rd * t;\n        \n    return true;\n}\n\nvec3 EvalCol(vec3 rd, vec3 p, vec3 n)\n{\n    vec3  fm  = abs(n);\n    float fmc = dot(mix(vec3(1.0), vec3(0.0), equal(fm, vec3(0.0))), vec3(1.0));\n    \n    float wfA;\n    {\n        bvec3 b = greaterThan(abs(fract(p) - 0.5), vec3(0.45));\n\n        if(fmc != 1.0)\n        {\n            wfA = b.x || b.y || b.z ? 0.0 : 1.0;\n        }\n        else\n        {\n            bvec3 l = bvec3(b.y && b.z, b.z && b.x, b.y && b.x);\n            wfA = l.x || l.y || l.z ? 0.0 : 1.0;\n        }\n        \n    }\n    \n    float wfB;\n    {\n        bvec3 b = greaterThan(abs(fract(p*0.5+0.5) - 0.5), vec3(0.47));\n\n        wfB = b.x || b.y || b.z ? 0.0 : 1.0;\n    }\n    \n    float err = 0.0;\n    {\n        bvec3 b = greaterThan(abs(fract(p*0.5+0.5) - 0.5), vec3(0.47));\n    \n        if(fmc == 1.0)\n        if((b.x && n.x != 0.0) ||\n           (b.y && n.y != 0.0) ||\n           (b.z && n.z != 0.0)) err = 1.0; \n     }     \n     \n    float wf = mix(wfA, 1.0, 0.75) * mix(wfB, 1.0, err);\n    \n    vec3 c;\n    if(ReadKeyToggle(KEY_S) == 0.0)\n    {\n        c = n * 0.5 + 0.5;\n    }\n    else\n    {\n        c = vec3(0.125);\n        c = vec3(1.0, 0.5, 0.25);\n        \n        if(err == 1.0) c = vec3(1.0, 0.25, 0.5);\n        if(fmc == 2.0) c = vec3(0.5, 0.9, 0.25);\n        if(fmc == 3.0) c = vec3(0.25, 0.5, 1.0);\n    }\n    \n    c *= sqrt(clamp01(-dot(n, rd)));\n   \n    if(ReadKeyToggle(KEY_W) == 0.0)\n    c *= wf;\n    \n    return c;\n}\n\nvec3 EvalCol(vec3 rp, vec3 rd, vec3 p0, vec3 n)\n{\n    vec3 p = rp - p0;\n    \n    float PdN = dot(p, n);\n    float DdN = dot(rd, n);\n    \n    float t = PdN / -DdN;\n    \n    return EvalCol(rd, rp + rd * t, n);\n}\n\nvoid GetCameraRay(vec2 uv, sampler2D stateChannel, vec2 pixelCount, out vec3 rp, out vec3 rd, out vec2 tc)\n{\n    vec4 mouseAccu = texelFetch(stateChannel, ivec2(1, 0), 0); \n\n    vec2 ang = vec2(-1.4 * Pi, Pi * 0.1);\n    ang += mouseAccu.xy * 0.008;\n\n    float focalLen = 0.6;// = 0.5 * tan(Pi05 - fov * 0.5)\n\n    mat3 cmat;\n    {\n        float sinPhi   = sin(ang.x);\n        float cosPhi   = cos(ang.x);\n        float sinTheta = sin(ang.y);\n        float cosTheta = cos(ang.y);    \n\n        vec3 front = vec3(cosPhi * cosTheta, \n                                   sinTheta, \n                          sinPhi * cosTheta);\n\n        vec3 right = vec3(-sinPhi, 0.0, cosPhi);\n        \n        vec3 up    = vec3(-cosPhi * sinTheta,\n                                    cosTheta,\n                          -sinPhi * sinTheta);\n        \n        cmat = mat3(right, up, front);\n    }\n    \n    rp = -cmat[2] * exp2(6.7 + mouseAccu.w * 0.02);\n    \n    rp += vec3(VOLUME_RES);\n    \n    tc = uv * (1.0 / (pixelCount.xx*0.5)) - vec2(1.0, pixelCount.y/pixelCount.x);\n    \n    rd = normalize(cmat * vec3(tc, focalLen));     \n}\n\nvec3 EvalSceneCol(vec2 uv0, vec2 uv)\n{    \n    vec3 col = vec3(0.002);    \n    \n    vec3 rp, rd; vec2 tc;\n    GetCameraRay(uv, iChannel0, iResolution.xy, /*out*/ rp, /*out*/ rd, /*out*/ tc);\n    \n    rp += rd * 1.0;\n    \n\tvec3 c, n, p;\n    if(SceneRayCast(rp, rd, /*out:*/ n, p))\n    {\n        col = vec3(0.0);\n \n        // oversample wireframe shading\n        float count = 3.0;\n        for(float i = 0.0; i < count; ++i) \n        {\n            vec2 uv2 = uv0 + GetUVOffset(uv0, count, i);\n\n            vec3 rp, rd; vec2 tc;\n            GetCameraRay(uv2, iChannel0, iResolution.xy, /*out*/ rp, /*out*/ rd, /*out*/ tc);\n\n            col += EvalCol(rp, rd, p, n);\n        }\n        \n        col /= count;\n    }\n\n    return col;\n}\n\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{\n    vec3 col = vec3(0.0);\n    \n    vec2 uv = uv0.xy - 0.5;    \n  \n#if 0\n    col = vec3(EvalSceneCol(uv0, uv0));\n#else\n    vec2 off = GetUVOffset(uv, 1.0, 1.0);\n      \n    col = vec3(EvalSceneCol(uv0, uv0 + off));\n#endif\n    \n    {\n        // vignetting\n        vec2 s = abs(uv0/iResolution.xy*2.0-1.0);\n        s.x = 1.0-Pow3(s.x);    s.y = 1.0-Pow3(s.y);\n        col *= mix(1.0, 0.4, Pow2(1.0-sqrt(s.x*s.y)));\n    }\n    \n\toutCol = vec4(GammaEncode(clamp01(col)), 1.0);\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "volume",
                        "id": 40,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n// https://twitter.com/Mirko_Salm\n\n/*\n    data: the lower 8 bits hold the values of the binary implicit evaluated at the 8 vertices of the current grid cell\n    oct:  the octant of the current grid cell for which the slopel type is queried\n    \n  out N:  normal of the slopel plane\n  out D:  offset of the slopel plane along its normal from the slopel center\n  \n  return: is octant not empty\n*/\nbool GetSlopelPlane(uint data, bvec3 oct, out vec3 N, out float D)\n{   \n    // bit counting: https://en.wikipedia.org/wiki/Hamming_weight\n    uint d = data;\n    d -= (d >> 1u) & 0x55555555u;// put count of each 2 bits into those 2 bits\n    d = (d & 0x33333333u) + ((d >> 2u) & 0x33333333u);// put count of each 4 bits into those 4 bits \n    d = (d + (d >> 4u)) & 0xfu;// put count of each 8 bits into those 8 bits  \n    \n    bool flip = d < 5u;\n    \n    if(flip) data = data ^ 0xFFu;\n    \n    if(oct.x) data = ((data & 0x55u) << 1u) ^ ((data & 0xAAu) >> 1u);\n    if(oct.y) data = ((data & 0x33u) << 2u) ^ ((data & 0xCCu) >> 2u);\n    if(oct.z) data = ((data & 0x0Fu) << 4u) ^ ((data & 0xF0u) >> 4u);\n\n    \n    uint m = data;\n    \n    uint my = data & 0x55u;\n    my = (my ^ (my >>  1u)) & 0x33u;\n    my =  my ^ (my >>  2u);\n    m  =  m  ^ (my << 8u);\n    \n    uint mz = data & 0x33u;\n    mz = (mz ^ (mz <<  1u)) & 0x55u;\n    mz =  mz ^ (mz >>  3u);\n    m  =  m  ^ (mz << 16u);\n    \n    \n    // k will contain the quantized interpolation results + some garbage bits\n    uint k = (m | (m >> 1u)) & 0x010101u;// edges\n    \n     // bit counting: https://en.wikipedia.org/wiki/Hamming_weight\n     m -= (m >> 1u) & 0x55555555u;// put count of each 2 bits into those 2 bits\n     m = (m & 0x33333333u) + ((m >> 2u) & 0x33333333u);// put count of each 4 bits into those 4 bits \n    \n    k = k ^ ((m | (m >> 1u)) & 0x020202u);// faces\n    \n    // compact scattered bits\n    k = k ^ (k >> 6u);\n    k = k ^ (k >> 4u);\n    \n    // clean up\n    k = k & 0xCFu;\n    \n    // add the 2 missing bits \n    k = k ^ ((data & 1u) << 4u);// origin\n    // (0 | 0 | k | 0)\n    \n    // expand to 4 blocks\n    k = k ^ (k <<  8u);\n    k = k ^ (k << 16u);\n    // (k | k | k | k)\n    \n    // apply bit flips \n    k = k ^ 0xDF37F17Cu;\n    // (D | N.z | N.y | N.x)\n    \n    // counts bits in each byte block (https://en.wikipedia.org/wiki/Hamming_weight)\n    k -= (k >> 1u) & 0x55555555u;// put count of each 2 bits into those 2 bits\n    k = (k & 0x33333333u) + ((k >> 2u) & 0x33333333u);// put count of each 4 bits into those 4 bits \n    k = (k + (k >> 4u)) & 0x0f0f0f0fu;// put count of each 8 bits into those 8 bits  \n    \n    \n    uvec3 N0 = (uvec3(k) >> uvec3(0u, 8u, 16u)) & uvec3(0xFu);\n\n#if 1\n    N0 -= 4u;\n    \n    N = vec3(N0.x == 0u ? 0.0 : 1.0,\n             N0.y == 0u ? 0.0 : 1.0,\n             N0.z == 0u ? 0.0 : 1.0);\n\n    if(oct.x != flip != ((N0.x & 0x80000000u) == 0u)) N.x = -N.x;\n    if(oct.y != flip != ((N0.y & 0x80000000u) == 0u)) N.y = -N.y;\n    if(oct.z != flip != ((N0.z & 0x80000000u) == 0u)) N.z = -N.z;\n#else\n    N = vec3(N0.x < 4u ? 1.0 : N0.x > 4u ? -1.0 : 0.0,\n             N0.y < 4u ? 1.0 : N0.y > 4u ? -1.0 : 0.0,\n             N0.z < 4u ? 1.0 : N0.z > 4u ? -1.0 : 0.0);\n\n    if(oct.x != flip) N.x = -N.x;\n    if(oct.y != flip) N.y = -N.y;\n    if(oct.z != flip) N.z = -N.z;\n#endif\n\n    float count = abs(N.x) + abs(N.y) + abs(N.z);\n\n    if(count < 2.0) N.x = 1.0;\n\n    uint D0 = k >> 24u;\n    {\n        uint th = count == 3.0 ? 4u : 2u;\n\n        float v2 = D0 > 2u ? -0.5 : 0.5;\n\n        if(count  < 2.0) v2 = 128.0;\n        if(count == 2.0) v2 = 0.0;\n\n        D = D0 > th ? -128.0 : v2;\n    }\n    \n    if(flip) \n    { \n        D = -D; \n    }\n    \n    return D > -128.0;\n}\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\n#define VOLUME_RES 64u\n\n/* http://keycode.info/ */\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_TAB 9\n#define KEY_CTRL 17\n#define KEY_ALT 18\n#define KEY_SHIFT 16\n#define KEY_SPACE 32 \n#define KEY_A 0x41\n#define KEY_D 0x44\n#define KEY_S 0x53\n#define KEY_W 0x57\n\n#define KEY_N1 49\n#define KEY_N2 50\n#define KEY_N3 51\n#define KEY_N4 52\n#define KEY_N5 53\n#define KEY_N6 54\n#define KEY_N7 55\n#define KEY_N8 56\n\nconst float Pi = 3.14159265359;\nconst float Pi2 = Pi * 2.0;\nconst float Pi05 = Pi * 0.5;\n\nconst float RcpPi  = 1.0 / (1.0 * Pi);\nconst float RcpPi2 = 1.0 / (2.0 * Pi);\nconst float RcpPi4 = 1.0 / (4.0 * Pi);\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\nfloat Pow5(float x) {return Pow4(x)*x;}\n\nvec3 GammaDecode(vec3 x) {return pow(x, vec3(      2.2));}   \nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}   \n\nvec2 CosSin(float x)\n{\t\n\treturn vec2(cos(x), sin(x));\n}\n\nvec2 CmplxMul(vec2 a, vec2 b)\n{\n    return vec2(a.x*b.x - a.y*b.y, \n                a.x*b.y + a.y*b.x); \n}\n\nvec2 Rotate(vec2 v, float ang)\n{\n    return CmplxMul(v, CosSin(ang));\n}\n\nfloat Intersect_Ray_Cube(vec3 rp, vec3 rd, vec3 cth, out vec2 t)\n{\t\n\tvec3 m = 1.0 / -rd;\n\tvec3 o = If(lessThan(rd, vec3(0.0)), -cth, cth);\n\t\n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\tt.x = max(uf.x, max(uf.y, uf.z));\n\tt.y = min(ub.x, min(ub.y, ub.z));\n\t\n\tbool inside = t.x < 0.0 && t.y > 0.0;\n    \n\tif(inside) {return 0.0;}\n\t\n\treturn t.y < t.x ? -1.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\nfloat ddxyLen(float v) { return length(vec2(dFdx(v), dFdy(v))); }\n\n// http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html\nuint WeylHash(uvec2 c) \n{\n    return ((c.x * 0x3504f333u) ^ (c.y * 0xf1bbcdcbu)) * 741103597u; \n}\n\n// https://www.shadertoy.com/view/3tdBWM\nvec2 GetUVOffset(vec2 uv, float count, float smplNum)\n{\n    uvec2 uvi = uvec2(uv);\n\n    if(((uvi.x ^ uvi.y) & 4u) == 0u) uvi   = uvi.yx;\n    if(((uvi.x        ) & 4u) == 0u) uvi.x =-uvi.x;\n\n    const uint rPhi1  = 2654435761u;\n    const uint rPhi2a = 3242174893u;\n    const uint rPhi2b = 2447445397u;\n\n    float u = float((uvi.x * rPhi2a) + (uvi.y * rPhi2b)) * (1.0 / 4294967296.0);\n    uint  h = WeylHash(uvi);\n\n    float i = smplNum;\n    \n    float ang = (Pi*(2.0/count)) * (i+u);\n\n    vec2 off = vec2(cos(ang), sin(ang));\n\n    float l = float(h+uint(i)*rPhi1) * (0.25/4294967296.0) + 0.25;\n    \n    return off * l;\n}\n\nbvec3 maxmask(vec3 v)\n{\n    bool x = v.x >  v.y && v.x >  v.z;\n    bool y = v.y >= v.z && v.y >= v.x;\n    bool z = !x && !y;\n    \n    return bvec3(x, y, z);\n}\n\nbvec3 minmask(vec3 v)\n{\n    bool x = v.x <= v.y && v.x <= v.z;\n    bool y = v.y <  v.z && v.y <  v.x;\n    bool z = !x && !y;\n    \n    return bvec3(x, y, z);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n// https://twitter.com/Mirko_Salm\n\n// persistent state stuff\n\nvoid mainImage( out vec4 col, in vec2 uv0 )\n{  \n    col = vec4(0.0);\n    \n    vec2 uv = uv0 - 0.5;\n   \n    if(uv.y >= 1.0) discard;\n    \n    vec4 iMouseLast      = texelFetch(iChannel0, ivec2(0, 0), 0);\n    vec4 iMouseAccuLast  = texelFetch(iChannel0, ivec2(1, 0), 0);\n    vec4 wasdAccuLast    = texelFetch(iChannel0, ivec2(2, 0), 0);\n\n    bool ctrl  = texelFetch(iChannel1, ivec2(17, 0), 0).x != 0.0;\n    bool shift = texelFetch(iChannel1, ivec2(16, 0), 0).x != 0.0;\n    \n    float kW = texelFetch(iChannel1, ivec2(0x57, 0), 0).x;\n    float kA = texelFetch(iChannel1, ivec2(0x41, 0), 0).x;\n    float kS = texelFetch(iChannel1, ivec2(0x53, 0), 0).x;\n    float kD = texelFetch(iChannel1, ivec2(0x44, 0), 0).x;\n    \n    vec4 wasdAccu = wasdAccuLast + vec4(kW, kA, kS, kD);\n    \n    vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n    \n    bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n    \n    if(ctrl) cond0 = false;\n    \n    vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n    vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n    \n    vec2 iMouseAccu1 = iMouseAccuLast.xy + mouseDelta2;\n    vec2 iMouseAccu2 = iMouseAccuLast.zw + mouseDelta3;\n    \n    if(uv.x == 0.0 && uv.y == 0.0) col = iMouse;  \n    if(uv.x == 1.0 && uv.y == 0.0) col = vec4(iMouseAccu1, iMouseAccu2);\n    if(uv.x == 2.0 && uv.y == 0.0) col = wasdAccu;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n// https://twitter.com/Mirko_Salm\n\n/*\n    Write a marching cubes lookup table into Buffer B in case GetSlopelPlane(...) isn't used directly in Image.\n    \n    uv.x [0, 255]: marching cube configuration id\n    uv.y [0,   7]: octant id\n    \n    BufferB[uv] = vec4(slopel plane normal.xyz, slopel plane D);\n*/\n\nvec4 GetMCLookupEntry(uvec2 uv)\n{\n    uint data = uv.x;\n    bvec3 oct = equal((uv.yyy >> uvec3(0u, 1u, 2u)) & 1u, uvec3(1u));\n    \n    vec3 N; float D;\n    GetSlopelPlane(data, oct, /*out*/ N, D);\n    \n    return vec4(N, D);\n}\n\nbool ReadMCLookupEntry(sampler2D sampler, uint data, bvec3 oct, out vec3 N, out float D)\n{\n    uvec2 uv;\n    uv.x = data;\n    uv.y = (oct.x ? 1u : 0u) | (oct.y ? 2u : 0u) | (oct.z ? 4u : 0u);\n    \n    vec4 res = texelFetch(sampler, ivec2(uv), 0);\n    \n    N = res.xyz;\n    D = res.w;\n    \n    return D > -128.0;\n}\n\nvoid mainImage( out vec4 col, in vec2 uv0 )\n{  \n    if(iFrame > 1) discard;\n    \n    col = vec4(0.0);\n    \n    vec2 uv = uv0 - 0.5;\n    \n    if(uv.x >= 256.0) discard;\n    if(uv.y >=   8.0) discard;\n\n    uvec2 uv2 = uvec2(uv);\n\n    col = GetMCLookupEntry(uv2);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}