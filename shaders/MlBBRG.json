{
    "Shader": {
        "info": {
            "date": "1516194405",
            "description": "Little shader art.",
            "flags": 32,
            "hasliked": 0,
            "id": "MlBBRG",
            "likes": 26,
            "name": "Lego Crystal",
            "published": 3,
            "tags": [
                "art"
            ],
            "usePreview": 0,
            "username": "srtuss",
            "viewed": 748
        },
        "renderpass": [
            {
                "code": "// srtuss, 2018\n\n// i borrowed this code:\n#define res iResolution\nvec3 dof(sampler2D tex,vec2 uv,float rad)\n{\n    float GA =2.399; \n\tmat2 rot = mat2(cos(GA),sin(GA),-sin(GA),cos(GA));\n    \n\tvec3 acc=vec3(0);\n    vec2 pixel=vec2(.002*res.y/res.x,.002),angle=vec2(0,rad);;\n    rad=1.;\n\tfor (int j=0;j<80;j++)\n    {  \n        rad += 1./rad;\n\t    angle*=rot;\n        vec4 col=texture(tex,uv+pixel*(rad-1.)*angle);\n\t\tacc+=col.xyz;\n\t}\n\treturn acc/80.;\n}\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n\tvec2 uv = gl_FragCoord.xy / res.xy;\n\tfragColor=vec4(dof(iChannel0,uv,texture(iChannel0,uv).w),1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// srtuss, 2018\n\nvec2 rotate(vec2 p, float a)\n{\n    float co = cos(a), si = sin(a);\n    return p * mat2(co, si, -si, co);\n}\n\nfloat scene(vec3 p)\n{\n    vec2 tip = normalize(vec2(.5, 1.));\n    \n    vec3 q = p;\n\tfloat w = max(abs(q.x), abs(q.z));\n    float v = max(w - .2, dot(vec2(w, q.y), tip) - 1.6);\n    \n    q = p;\n    q.x += .55;\n    q.xy = rotate(q.xy, .3);\n    q.x -= .2;\n    w = max(abs(q.x), abs(q.z));\n    v = min(v, max(w - .2, dot(vec2(w, q.y), tip) - 1.));\n    \n    q = p;\n    q.x -= .55;\n    q.xy = rotate(q.xy, -.3);\n    q.x += .2;\n    w = max(abs(q.x), abs(q.z));\n    v = min(v, max(w - .2, dot(vec2(w, q.y), tip) - .9));\n    \n    q = p;\n    q.z -= .55;\n    q.zy = rotate(q.zy, -.3);\n    q.z += .2;\n    w = max(abs(q.x), abs(q.z));\n    v = min(v, max(w - .2, dot(vec2(w, q.y), tip) - .7));\n    \n    q = p;\n    q.z += .55;\n    q.zy = rotate(q.zy, .3);\n    q.z -= .2;\n    w = max(abs(q.x), abs(q.z));\n    v = min(v, max(w - .2, dot(vec2(w, q.y), tip) - .8));\n    \n    \n    v = max(v, -p.y);\n    \n    w = max(max(abs(p.x), abs(p.z)) - .55, abs(p.y + .15) - .15);\n    w = max(w, (abs(p.x) + abs(p.z)) / 1.4142136 - .53);\n    v = min(v, w);\n    \n    v = max(v, -max(length(p.xz) - .3, p.y + .05));\n    \n    return v;\n}\n\nvec3 normal(vec3 p, float hh)\n{\n   \tvec2 h = vec2(hh, 0.);\n    return normalize(vec3(\n        scene(p + h.xyy) - scene(p - h.xyy),\n        scene(p + h.yxy) - scene(p - h.yxy),\n        scene(p + h.yyx) - scene(p - h.yyx)));\n}\n\nvec3 sky(vec3 rd)\n{\n    return vec3(.0);\n}\n\nvec3 rtrace2(vec3 ro, vec3 rd, float pol)\n{\n    float d = 0.01;\n    for(int i = 0; i < 60; ++i)\n    {\n        d += scene(d * rd + ro) * pol;\n    }\n    \n    if(d > 5.)\n        return sky(rd);\n    \n   \tvec3 hit = ro + rd * d;\n    vec3 nml = normal(hit, .03);\n    vec3 ref = reflect(rd, nml);\n    \n    vec3 col = pow(texture(iChannel0, ref).xyz, vec3(2.));\n    \n    //col = rtrace(hit, normalize(ref), depth - 1);\n    \n    return col;\n}\n\nvec3 rtrace(vec3 ro, vec3 rd, int depth, out float z)\n{\n    if(depth <= 0)\n       \treturn vec3(0.);\n    \n    float d = 0.01;\n    for(int i = 0; i < 60; ++i)\n    {\n        d += scene(d * rd + ro);\n    }\n    \n    z = d;\n    \n    if(d > 5.)\n        return sky(rd);\n    \n   \tvec3 hit = ro + rd * d;\n    vec3 nml = normal(hit, .03);\n    vec3 ref = reflect(rd, nml);\n    \n    vec3 col = pow(texture(iChannel0, ref).xyz, vec3(2.));\n    \n    col += rtrace2(hit, normalize(ref), 1.) * .5;\n    col += rtrace2(hit, normalize(refract(rd, nml, .8)), -1.) * .5;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    float s = cos(uv.x * 11. + uv.y * 100. + iTime);\n    //uv += vec2(fract(s * 198673.), fract(s * 12902.)) * 1. / iResolution.xy;\n    \n    vec3 ro = vec3(0., 1., -3.);\n    vec3 rd = normalize(vec3(uv, 1.66));\n    \n    float pan = iTime;\n    float tilt = (iMouse.y / iResolution.y) * -6.28;\n    ro.xz = rotate(ro.xz, pan);\n    rd.xz = rotate(rd.xz, pan);\n    \n    ro.yz = rotate(ro.yz, tilt);\n    rd.yz = rotate(rd.yz, tilt);\n    \n    float z;\n    vec3 col = rtrace(ro, rd, 2, z);\n    col = col.yxz;\n    \n    float x = uv.x * (1. + uv.y * 0.5) - pan * .5;\n    col += (sin(x * 10.) + sin(x * 7.) + sin(x * 18.) + 3.) * .03 * exp(abs(uv.x) * -5. + max(-uv.y, 0.) * -1.);\n    \n    col += exp(length(vec2(uv.x * 2., uv.y + .4)) * -2.) * vec3(0.2, 1., 0.) * .3;\n    \n    col = pow(col * 1.5, vec3(1.5));\n    //col *= exp(d * -.2);\n    col *= exp(length(uv) * -.5);\n    col = pow(col, vec3(1. / 2.2));\n    \n\tfragColor = vec4(col, min((z - 3.) * .5, 1.));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}