{
    "Shader": {
        "info": {
            "date": "1361987891",
            "description": "Some colored \"ribbons\" who are illuminated by the sound.",
            "flags": 32,
            "hasliked": 0,
            "id": "lds3zr",
            "likes": 153,
            "name": "Ribbons",
            "published": 3,
            "tags": [
                "3d",
                "distancefield",
                "musicsync",
                "ribbons"
            ],
            "usePreview": 0,
            "username": "XT95",
            "viewed": 21944
        },
        "renderpass": [
            {
                "code": "\n//FXAA Shader taken from this great example by reinder - from https://www.shadertoy.com/view/ls3GWS\n//Original code - http://www.geeks3d.com/20110405/fxaa-fast-approximate-anti-aliasing-demo-glsl-opengl-test-radeon-geforce/3/\n\n#define ON\n\n\n#define FXAA_SPAN_MAX 8.0\n#define FXAA_REDUCE_MUL   (1.0/FXAA_SPAN_MAX)\n#define FXAA_REDUCE_MIN   (1.0/128.0)\n#define FXAA_SUBPIX_SHIFT (1.0/4.0)\n\nvec3 FxaaPixelShader( vec4 uv, sampler2D tex, vec2 rcpFrame) {\n    \n    vec3 rgbNW = textureLod(tex, uv.zw, 0.0).xyz;\n    vec3 rgbNE = textureLod(tex, uv.zw + vec2(1,0)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbSW = textureLod(tex, uv.zw + vec2(0,1)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbSE = textureLod(tex, uv.zw + vec2(1,1)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbM  = textureLod(tex, uv.xy, 0.0).xyz;\n\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max(\n        (lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),\n        FXAA_REDUCE_MIN);\n    float rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);\n    \n    dir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),\n          max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n          dir * rcpDirMin)) * rcpFrame.xy;\n\n    vec3 rgbA = (1.0/2.0) * (\n        textureLod(tex, uv.xy + dir * (1.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(tex, uv.xy + dir * (2.0/3.0 - 0.5), 0.0).xyz);\n    vec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (\n        textureLod(tex, uv.xy + dir * (0.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(tex, uv.xy + dir * (3.0/3.0 - 0.5), 0.0).xyz);\n    \n    float lumaB = dot(rgbB, luma);\n\n    if((lumaB < lumaMin) || (lumaB > lumaMax)) return rgbA;\n    \n    return rgbB; \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 rcpFrame = 1./iResolution.xy;\n  \tvec2 uv = fragCoord.xy / iResolution.xy;        \n    \n    #ifdef ON\n        fragColor.rgb = FxaaPixelShader( vec4( uv, uv - (rcpFrame * (0.5 + FXAA_SUBPIX_SHIFT))), iChannel0, 1./iResolution.xy );\n        fragColor.a = texture( iChannel0, uv ).a;\n    #else\n    \tfragColor = texture(iChannel0, uv);\n    #endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n//-----------------------------------------------------------------------------\n// Utils\n//-----------------------------------------------------------------------------\n#define t (iTime*.5)\n\nvec3 rotateY(vec3 v, float x)\n{\n    return vec3(\n        cos(x)*v.x - sin(x)*v.z,\n        v.y,\n        sin(x)*v.x + cos(x)*v.z\n    );\n}\n\nvec3 rotateX(vec3 v, float x)\n{\n    return vec3(\n        v.x,\n        v.y*cos(x) - v.z*sin(x),\n        v.y*sin(x) + v.z*cos(x)\n    );\n}\n\nvec3 rotateZ(vec3 v, float x)\n{\n    return vec3(\n        v.x*cos(x) - v.y*sin(x),\n        v.x*sin(x) + v.y*cos(x),\n        v.z\n    );\n}\n//-----------------------------------------------------------------------------\n// Scene/Objects\n//-----------------------------------------------------------------------------\nfloat box(vec3 p, vec3 pos, vec3 size)\n{\n\treturn max(max(abs(p.x-pos.x)-size.x,abs(p.y-pos.y)-size.y),abs(p.z-pos.z)-size.z);\n}\n\n\nfloat ribbon1(vec3 p)\n{\n\treturn box(p,vec3(cos(p.z)*.5,sin(p.z+p.x)*.5,.0),vec3(.02,0.02,3.5+t));\n}\nfloat ribbon2(vec3 p)\n{\n\treturn box(p,vec3(cos(p.z+1.5+p.x)*.6,sin(p.z+1.)*.3,.0),vec3(.02,0.02,3.+t));\n}\nfloat ribbon3(vec3 p)\n{\n\treturn box(p,vec3(sin(p.z+p.y)*.4,cos(p.z+p.x)*.5,.0),vec3(.02,0.02,4.+t));\n}\nfloat ribbon4(vec3 p)\n{\n\treturn box(p,vec3(sin(p.z+1.5+p.x)*.5,cos(p.z+1.5)*.6,.0),vec3(.02,0.02,2.+t));\n}\nfloat scene(vec3 p)\n{\n\tfloat d = .5-abs(p.y);\n\td = min(d, ribbon1(p) );\n\td = min(d, ribbon2(p) );\n\td = min(d, ribbon3(p) );\n\td = min(d, ribbon4(p) );\n\t\n\treturn d;\n}\n\n//-----------------------------------------------------------------------------\n// Raymarching tools\n//-----------------------------------------------------------------------------\n//Raymarche by distance field\nvec3 Raymarche(vec3 org, vec3 dir, int step)\n{\n\tfloat d=0.0;\n\tvec3 p=org;\n\t\n\tfor(int i=0; i<64; i++)\n\t{\n\t\td = scene(p);\n\t\tp += d * dir;\n\t}\n\t\n\treturn p;\n}\n//get Normal\nvec3 getN(vec3 p)\n{\n\tvec3 eps = vec3(0.01,0.0,0.0);\n\treturn normalize(vec3(\n\t\tscene(p+eps.xyy)-scene(p-eps.xyy),\n\t\tscene(p+eps.yxy)-scene(p-eps.yxy),\n\t\tscene(p+eps.yyx)-scene(p-eps.yyx)\n\t));\n}\n\n//Ambiant Occlusion\nfloat AO(vec3 p, vec3 n)\n{\n\tfloat dlt = 0.1;\n\tfloat oc = 0.0, d = 1.0;\n\tfor(int i = 0; i<6; i++)\n\t{\n\t\toc += (float(i) * dlt - scene(p + n * float(i) * dlt)) / d;\n\t\td *= 2.0;\n\t}\n\treturn clamp(1.0 - oc, 0.0, 1.0);\n}\n\n//-----------------------------------------------------------------------------\n// Main Loop\n//-----------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 color = vec4(0.0);\n\tfloat bass = texture( iChannel0, vec2(20./256.,0.25) ).x*.75+texture( iChannel0, vec2(50./256.,0.25) ).x*.25;\n\tvec2 v = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tv.x *= iResolution.x/iResolution.y;\n\t\n\tvec3 org = vec3(texture( iChannel0, vec2(1./256.,0.25) ).x*.2+1.,+0.3+bass*.05,t+5.);\n\tvec3 dir = normalize(vec3(v.x,-v.y,2.));\n\tdir = rotateX(dir,.15);\n\tdir = rotateY(dir,2.8);\n\t\n\t\n\tvec3 p = Raymarche(org,dir,48);\n\tvec3 n = getN(p);\n\t\n\t\n    color = vec4( max( dot(n.xy*-1.,normalize(p.xy-vec2(.0,-.1))),.0)*.01 );\n\tcolor += vec4(1.0,0.3,0.0,1.0)/(ribbon1(p-n*.01)*20.+.75)*pow(bass,2.)*3.;\n\tcolor += vec4(0.5,0.3,0.7,1.0)/(ribbon2(p-n*.01)*20.+.75)*pow(texture( iChannel0, vec2(32.4/256.,0.25) ).x,2.)*2.;\n\tcolor += vec4(0.0,0.5,1.0,1.0)/(ribbon3(p-n*.01)*20.+.75)*pow(texture( iChannel0, vec2(64.8/256.,0.25) ).x,2.)*5.;\n\tcolor += vec4(0.0,1.0,0.2,1.0)/(ribbon4(p-n*.01)*20.+.75)*pow(texture( iChannel0, vec2(80./256.,0.25) ).x,2.)*5.;\n\tcolor *= AO(p,n);\n\tcolor = mix(color,vec4(0.),vec4((min(distance(org,p)*.05,1.0))));\n\t\n\t\n\tfragColor = color;\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 19,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}