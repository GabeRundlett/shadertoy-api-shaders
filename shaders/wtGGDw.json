{
    "Shader": {
        "info": {
            "date": "1681952595",
            "description": "datamosh",
            "flags": 34,
            "hasliked": 0,
            "id": "wtGGDw",
            "likes": 2,
            "name": "datamosh",
            "published": 3,
            "tags": [
                "campinput"
            ],
            "usePreview": 0,
            "username": "armonnaeini",
            "viewed": 598
        },
        "renderpass": [
            {
                "code": "float rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 1.5453);\n}\n\n\nfloat perlin(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nvec3 colorVariation(vec2 coord, float time) {\n    // Generate Perlin noise based on the coordinate and time\n    float noiseValue = perlin(coord * 1.0 + time * 1.0);\n\n    // Map the noise value to a color offset\n    vec3 colorOffset = vec3(\n        sin(noiseValue * 12.0) * 0.95 + 0.905,\n        cos(noiseValue * 12.0) * 0.9095 + 0.905,\n        sin(noiseValue*12.0) * 0.395 + 0.025\n    );\n\n    return colorOffset;\n}\n\nvec2 displace2(vec2 coord, float time) {\n    float noiseValue = perlin(coord * 5.0 + time*2.0);\n    \n    // Calculate the distance from the current coordinate to the center of the image\n    vec2 center = vec2(0.5, 0.0);\n    float distance = length(coord - center);\n    \n    // Calculate the displacement vector\n    vec2 displacement = vec2(cos(noiseValue) * 0.5 + 0.5, tan(noiseValue) * 0.5 + 0.5);\n    \n    // Scale the displacement vector based on the distance to the center\n    float scale =  distance-.5;\n    displacement *= scale/5.;\n    return coord + displacement*4.0;\n    \n    //return coord + vec2(cos(noiseValue) * 0.5 + 0.5, sin(noiseValue) * 0.5 + 0.5);\n}\n\nfloat avg(vec4 color) {\n    float displacement = (color.r/color.r*color.r)*sin(iTime/2.);\n    // Threshold to determine if the displacement is minimal\n    float threshold = 0.5;\n\n    // Return 0 if the displacement is below the threshold, otherwise return the calculated displacement\n    return (abs(displacement) < threshold) ? 0.0 : displacement;\n}\n\n// New function to create pixelated texture coordinates\nvec2 pixelate(vec2 coord, float pixelSize) {\n    return floor(coord * pixelSize) / pixelSize;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord / iResolution.xy);\n\n    // Pixelation factor (higher values for more pixelation)\n    //float pixelationFactor = sin(iTime) + sin(iTime / 4.0) * 256.0;\n    float pixelationFactor = 256.0;\n    // Use pixelated texture coordinates for displacement\n    \n    vec2 pixelatedCoord = pixelate(uv, pixelationFactor);\n    vec4 displace = texture(iChannel1, vec2(pixelatedCoord));\n    displace.rg *= vec2(cos(iTime + pixelatedCoord.y * cos(iTime/12.0)*4.0) * 0.5 + 0.5, sin(iTime + pixelatedCoord.y * 1.0) * 0.5 + 0.5);\n    \n    vec2 displaceNew = displace2(pixelatedCoord.xy, iTime);\n\n  \n    \n    // Datamosh effect\n    float displaceFactor = 1.151;\n    vec2 datamoshUV = displace.rg * displaceFactor;\n    vec3 colorVar = colorVariation(datamoshUV, iTime);\n    vec4 datamosh = texture(iChannel0, datamoshUV);\n    \n    fragColor = vec4(datamosh.rgb / colorVar.rgb, datamosh.a);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "webcam",
                        "id": 31,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/webcam.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "webcam",
                        "id": 31,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/webcam.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float avg(vec4 color) {\n    float displacement = (color.r/color.r*color.r)*sin(iTime/2.);\n     // Threshold to determine if the displacement is minimal\n    float threshold = 0.011125;\n\n    // Return 0 if the displacement is below the threshold, otherwise return the calculated displacement\n    return (abs(displacement) < threshold) ? 0.0 : displacement;\n}\n\n\n// New function to create pixelated texture coordinates\nvec2 pixelate(vec2 coord, float pixelSize) {\n    return floor(coord * pixelSize) / pixelSize;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\t\n    float drunk = 0.0;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy);\n    vec2 normalizedCoord = mod((fragCoord.xy + vec2(0, drunk)) / iResolution.xy, 1.0);\n    \n    // Mirror the UV coordinates at the top and bottom\n    vec2 mirroredUV = vec2(uv.x, 1.0 - abs(uv.y * 2.0 - 1.0));\n\n    // Pixelation factor (higher values for more pixelation)\n    float pixelationFactor = cos(iTime)+sin(iTime/4.0)*512.0;\n\n    // Use pixelated texture coordinates for displacement\n    vec2 pixelatedCoord = pixelate(normalizedCoord, pixelationFactor);\n    vec4 displace = texture(iChannel1, vec2(pixelatedCoord));\n    \n    //datamosh effect\n    float displaceFactor = 0.2;\n    vec2 datamoshUV = uv + displace.gr * displaceFactor;\n    \n    // Background image\n    vec4 background = texture(iChannel0, vec2(uv.y, uv.y));\n    vec4 background2 = texture(iChannel1, vec2(uv.x, uv.y - avg(displace*12.)));\n       \n    vec4 datamosh = texture(iChannel0, datamoshUV);\n    // Output to screen\n   // fragColor = (displace)*.01 * background + background2;\n    fragColor = datamosh;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "webcam",
                        "id": 31,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/webcam.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "webcam",
                        "id": 31,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/webcam.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}