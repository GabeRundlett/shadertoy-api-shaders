{
    "Shader": {
        "info": {
            "date": "1667507701",
            "description": "I just learned about ray marching a few weeks ago and my mind is blow by what can be done with a limited number of lines of code. The best part of it is randomly throwing stuff together, which is exactly what this experimentation is.",
            "flags": 0,
            "hasliked": 0,
            "id": "DdS3DR",
            "likes": 22,
            "name": "Virpropeller No. 1",
            "published": 3,
            "tags": [
                "raymarching",
                "reflection",
                "abstract",
                "alien",
                "propeller"
            ],
            "usePreview": 0,
            "username": "virmoesiae",
            "viewed": 313
        },
        "renderpass": [
            {
                "code": "/*\n    AD BY VIRMODOETIAE, a.k.a VIRMOESIAE ---------------------------\n    \n    Do you like shaders? Would you like to toy with them offline?\n    Would you like an interactive UI to play around with your shader\n    variables/uniforms in real-time without compilation? Would you\n    like to have a layer-based shader blending, without having to\n    pass through obscure buffers all the time? Would like to export\n    your shaders directly as GIFs?\n    Would you like a stand-alone executable (currently for Windows-\n    only, but the source code is cross-platform) in less than 9MB?\n    \n    Then, my dear friend, come get your free copy of:\n        \n    >>> SHADERTHING <<<\n   \n    a live, offline, GUI-based shader editor developed by me,\n    virmodoetiae (a.k.a, virmoesiae) freely obtainable at:\n    \n        https://github.com/virmodoetiae/shaderthing\n    \n    For the release, head to :\n    \n        https://github.com/virmodoetiae/shaderthing/releases\n    \n    Everything, including the source code, is available under a \n    very permissive libz/libpng license, so you can really do\n    almost anything you want with it!\n    \n    Please note that currently no tutorials are available, but the\n    core usage should be intuitive to most ShaderToy users.\n    \n    Enjoy!\n*/\n\n/*\n    Is this the most optimzed code? Quite the opposite! This is mostly a \n    learning experience.\n*/\n\n// DEFINES -------------------------------------------------------------------//\n\n// Ray marching-related\n#define MAX_STEPS 1000\n#define MAX_DIST 1e3\n#define MIN_DIST 5e-3\n\n// Optical-effect related\n#define N_REFLS 2\n#define SHADW_SHARPN 50\n#define MIN_LIGHT .0125\n\n// Other shader quantities\n#define PERIOD 10.\n#define BCKG_COL vec3(.3+.15*cos(p.x/1000.-iTime/PERIOD))\n\n// Misc\n#define PI 3.141593\n#define TP 2.*PI\n#define OFFSET (10.*MIN_DIST)\n#define VECX vec3(1.,0.,0.)\n#define VECY vec3(0.,1.,0.)\n#define VECZ vec3(0.,0.,1.)\n\n// MISC ----------------------------------------------------------------------//\n\nmat3 rx(float t)\n{\n    float ct = cos(t);\n    float st = sin(t);\n    return mat3(1., 0., 0., 0., ct, -st, 0., st, ct);\n}\nmat3 ry(float t)\n{\n    float ct = cos(t);\n    float st = sin(t);\n    return mat3(ct, 0., st, 0., 1., 0., -st, 0., ct);\n}\nmat3 rz(float t)\n{\n    float ct = cos(t);\n    float st = sin(t);\n    return mat3(ct, -st, 0., st, ct, 0., 0., 0., 1);\n}\nvec3 lattice(vec3 p, vec3 c)\n{\n    return mod(p+0.5*c, c)-0.5*c;\n}\n\n// PRIMITIVE SIGNED DISTANCE FUNCTIONS (SDFs) AND OPERATIONS -----------------//\n\nfloat SDFSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat SDFBox(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.)) + min(max(q.x, max(q.y,q.z)),0.);\n}\n\nfloat SDFInfColY(vec3 p, vec2 b)\n{\n    vec2 q = abs(p.xz) - b;\n    return length(max(q, 0.)) + min(max(q.x, q.y),0.);\n}\n\nfloat DIntersect(float d0, float d1)\n{\n    return max(d0, d1);\n}\n\nfloat DSmoothIntersect(float d0, float d1, float k)\n{\n    return .5*(d0+d1+sqrt((d0-d1)*(d0-d1)+k));\n}\n\nfloat DUnite(float d0, float d1)\n{\n    return min(d0, d1);\n}\n\nfloat DSmoothUnite(float d0, float d1, float k)\n{\n    float h = clamp( 0.5 + 0.5*(d1-d0)/k, 0.0, 1.0 );\n    return mix(d1, d0, h ) - k*h*(1.0-h);\n}\n\nfloat DSubtract(float d0, float d1)\n{\n    return max(d0, -d1);\n}\n\nfloat DSmoothSubtract(float d0, float d1, float k)\n{\n    return .5*(d0-d1+sqrt((d0+d1)*(d0+d1)+k));\n}\n\n// SURFACE -------------------------------------------------------------------//\n\nstruct Surface\n{\n    float d; // Distance from cast ray origin\n    vec3 c; // Surface color\n    float r; // Surface reflectance\n};\n\nSurface SIntersect(Surface s0, Surface s1)\n{\n    Surface s;\n    if (abs(s0.d) < abs(s1.d))\n        s = s0;\n    else\n        s = s1;\n    s.d = max(s0.d, s1.d);\n    return s;\n}\n\nSurface SSmoothIntersect(Surface s0, Surface s1, float k)\n{\n    float d = DSmoothIntersect(s0.d, s1.d, k);\n    float h = d/s0.d;\n    vec3 c = s1.c*(1.-h) + s0.c*h;\n    float r = mix(s1.r, s0.r, h);\n    return Surface(d, c, r);\n}\n\nSurface SUnite(Surface s0, Surface s1)\n{\n    if (s0.d < s1.d)\n        return s0;\n    return s1;\n}\n\nSurface SSmoothUnite(Surface s0, Surface s1, float k)\n{\n    float h = clamp(.5 + .5*(s1.d-s0.d)/k, 0.0, 1.0 );\n    float d = mix(s1.d, s0.d, h ) - k*h*(1.0-h);\n    vec3 c = s1.c*(1.-h) + s0.c*h;\n    float r = mix(s1.r, s0.r, h);\n    return Surface(d, c, r);\n}\n\nSurface SSubtract(Surface s0, Surface s1)\n{\n    return Surface(max(s0.d, -s1.d), s0.c, s0.r);\n}\n\nSurface SSmoothSubtract(Surface s0, Surface s1, float k)\n{\n    Surface s = s0;\n    s.d = DSmoothSubtract(s0.d, s1.d, k);\n    return s;\n}\n\n// GLOBAL SCENE SDF ----------------------------------------------------------//\n\nSurface sceneSDF(vec3 p)\n{\n    float t = TP*iTime/PERIOD;\n    p = rx(t+.5*p.x)*(p);\n    p.y = abs(p.y)-5.-1.*sin(t);\n    float h = 10.+6.*sin(t/4.);\n    vec3 pb = lattice(p-h*fract(t)*VECX, h*VECX);//*ry(p.y*sin(t));\n    Surface s1 = Surface(SDFInfColY(pb, vec2(.5)), VECX, 0.25);\n    s1.d -= .25;\n    s1.d -= 2.*sin( .5*p.y - t)*(.5+.5*sin(t/4.));\n    Surface s2 = Surface(SDFSphere(p+VECY*(2.), 4.), vec3(1.,.5,0.), .75);\n    s2.d -= .25*sin(5.*p.x+25.*t);\n    Surface pl = Surface(p.y+2., vec3(.6,.3,.15), 0.25);\n    pl.d += .1*sin(p.x*10.+20.*t)+.1*sin(p.z*5.-20.*t);\n    s1 = SSmoothUnite(s1, s2, 4.+2.*sin(2.*t));\n    float x = .5;//1.+.9*sin(t/2.);\n    s1.d -= x;\n    pl = SSmoothSubtract(pl, s1, 0.5);\n    s1.d += x;\n    s1 = SUnite(s1, pl);\n    float m = sin(t)*sin(.5*p.y-5.*t)+cos(t)*sin(0.25*p.x-.5*t);\n    s1.d = DSmoothIntersect(\n        s1.d, \n        SDFBox(p-vec3(0.,0.,0), vec3(MAX_DIST, 6., 3.+2.*m)),\n        0.125\n    );\n    s1.d /= 7.5;\n    return s1;\n}\n\n// RAY MARCHING RELATED ------------------------------------------------------//\n\nstruct Ray \n{\n    vec3 orig; // Ray origin\n    vec3 dir; // Ray direction\n    float af; // Attenuation factor\n    int n; // Number of bounces\n};\n\nRay newRay(vec3 orig, vec3 dir)\n{\n    return Ray(orig, dir, 1., 0);\n}\n\nRay cameraRay(vec2 uv, vec3 cp, vec3 la, float zoom)\n{\n    vec3 f = normalize(la-cp);\n    vec3 r = normalize(cross(vec3(0.,1.,0.),f));\n    vec3 u = normalize(cross(f, r));\n    vec3 c = cp + f*zoom;\n    return newRay(cp, normalize(c + uv.x * r + uv.y * u-cp));\n}\n\nSurface rayMarch(Ray ray, out float pn)\n{\n    Surface s;\n    float d, dd, dd0 = MIN_DIST;\n    pn = 1.;\n    for (int iter = 0; iter < MAX_STEPS; iter++)\n    {\n        dd0 = dd; // I am not using dd0 for anything, I know...\n        s = sceneSDF(ray.orig + ray.dir*d);\n        dd = s.d;\n        if (dd > 0. && dd <= MIN_DIST || d >= MAX_DIST)\n            break;\n        pn = min(pn, float(SHADW_SHARPN)*dd/d);\n        d += dd;\n    }\n    s.d = d;\n    return s;\n}\n\nSurface rayMarch(Ray ray) // Overload without penumbra inout\n{\n    float tmp;\n    return rayMarch(ray, tmp);\n}\n\nvec3 getNormal(vec3 p)\n{\n    float d = sceneSDF(p).d;\n    vec2 e = vec2(OFFSET, 0.);\n    vec3 n = d - vec3\n        (\n            sceneSDF(p-e.xyy).d,\n            sceneSDF(p-e.yxy).d,\n            sceneSDF(p-e.yyx).d\n        );\n    return normalize(n);\n}\n\nfloat getLighting(vec3 p, inout vec3 n)\n{\n    // Light source position\n    vec3 lp = vec3(-.5, 0, -40.);\n    n = getNormal(p);\n    p += n*OFFSET;\n    vec3 dir = normalize(lp-p);\n    float pn;\n    if (rayMarch(newRay(p, dir), pn).d < length(lp-p))\n        return MIN_LIGHT;\n    return max(abs(dot(n, dir)*pn), MIN_LIGHT);\n}\n\nvoid propagate(inout Ray ray, inout vec3 col)\n{\n    // If the ray is fully attenuated, stop propagating\n    if (ray.af == 0.)\n        return;\n    Surface s = rayMarch(ray);\n    vec3 p = ray.orig + ray.dir*s.d;\n    //ray.af *= exp(s.d);\n    vec3 lCol, n;\n    lCol = BCKG_COL;\n    if (s.d < MAX_DIST)\n        lCol = max(getLighting(p, n), 0.)*s.c;\n    // If at the last reflection, set reflectance of hit surface to 0\n    // so it is rendered as fully opaque\n    s.r *= float(ray.n<N_REFLS);\n    // Cumulate col\n    col += lCol*ray.af*(1.0-s.r);\n    // Adjust attenuation by currently hit surface and prepare for next\n    // propagation\n    ray.af *= s.r;\n    if (ray.af != 0.)\n    {\n        ray.orig = p+n*OFFSET;\n        ray.dir = reflect(ray.dir, n);\n    }\n    ray.n++;\n}\n\nvec3 render(Ray r)\n{\n    // Base pass\n    vec3 col = vec3(0.);\n    propagate(r, col);\n    // Reflection passes\n    for (int i = 0; i < N_REFLS; i++)\n    {\n        propagate(r, col);\n    }\n    col = pow(col, vec3(.4545));\n    return col;\n}\n\n// MAIN ----------------------------------------------------------------------//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    // Camera position, look-at point and resulting ray\n    float t = TP*iTime/PERIOD;\n    vec3 cp = vec3(-25.*sin(t/2.), 1., -25.);\n    vec3 la = vec3(0., 0., 0.);\n    Ray ray = cameraRay(uv, cp, la, 1.);\n    // Render pixel\n    fragColor = vec4(render(ray),1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}