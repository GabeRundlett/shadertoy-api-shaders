{
    "Shader": {
        "info": {
            "date": "1662934051",
            "description": "The most well-known Julia set is defined by the iteration function x -> x^2 + c.\nChanging the exponent to negative or complex numbers leads to interesting results.\nHere it is set to -2.",
            "flags": 0,
            "hasliked": 0,
            "id": "ftdfWn",
            "likes": 5,
            "name": "Julia set of x^-2 + c",
            "published": 3,
            "tags": [
                "2d",
                "fractal",
                "julia"
            ],
            "usePreview": 0,
            "username": "chengsun",
            "viewed": 241
        },
        "renderpass": [
            {
                "code": "#define ITER_MAX 13\n#define TIME_SCALE 6\n#define ZOOM 4\n//#define CUSTOM_EXPONENT vec2(-2., 0.)\n\n\n\n// conversions between cartesian (x+yi) and polar (xe^(iy)) forms of complex numbers\nvec2 cartesian_of_polar(vec2 polar) {\n    return vec2(polar.x * cos(polar.y), polar.x * sin(polar.y));\n}\n\nvec2 polar_of_cartesian(vec2 cartesian) {\n    return vec2(length(cartesian), atan(cartesian.y, cartesian.x));\n}\n\n// multiplication of two complex numbers in cartesian form\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\n// exponential of a complex number by a complex number, both in cartesian form\nvec2 cexp(vec2 b, vec2 e) {\n    vec2 b_polar = polar_of_cartesian(b);\n    vec2 logb = vec2(log(b_polar.x), b_polar.y);\n    vec2 new_e = cmul(logb, e);\n    vec2 ans_polar = vec2(exp(new_e.x), new_e.y);\n    return cartesian_of_polar(ans_polar);\n}\n\n// cexp, specialized to e = vec2(-2., 0.)\nvec2 cexp_m2(vec2 b) {\n    vec2 b_invmag = b / vec2(dot(b, b));\n    return vec2((b_invmag.x*b_invmag.x - b_invmag.y*b_invmag.y), -2.*b_invmag.x*b_invmag.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from -ZOOM to ZOOM)\n    vec2 uv = vec2(2. * float(ZOOM)) * (fragCoord - iResolution.xy/vec2(2.)) / vec2(max(iResolution.x, iResolution.y));\n\n    // Animate the constant c\n    float t = iTime/float(TIME_SCALE);\n    vec2 c = (vec2(cos(t)*abs(cos(t)), sin(t)*abs(sin(t)))) * vec2(0.7665);\n\n    // Computation of the Julia set defined by the iteration x -> x^-2 + c\n    vec2 x = uv;\n    int iter = 0;\n    for (iter = 0; iter < ITER_MAX; ++iter) {\n        \n        if (dot(x, x) > 40.) break;\n#ifdef CUSTOM_EXPONENT\n            x = cexp(x, CUSTOM_EXPONENT);\n#else\n            x = cexp_m2(x);\n#endif\n        x += c;\n    }\n    vec3 col = vec3(float(iter) / float(ITER_MAX)) * vec3(c, 1.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}