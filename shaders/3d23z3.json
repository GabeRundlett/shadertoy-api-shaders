{
    "Shader": {
        "info": {
            "date": "1549547798",
            "description": "Molecular diffusion, mixing at an interface",
            "flags": 32,
            "hasliked": 0,
            "id": "3d23z3",
            "likes": 9,
            "name": "Molecular Diffusion",
            "published": 3,
            "tags": [
                "dynamics",
                "molecule",
                "mixing"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 502
        },
        "renderpass": [
            {
                "code": "// \"Molecular Diffusion\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n Molecular diffusion, mixing at an interface.\n An update of \"Molecular Dynamics\" that includes periodic boundaries and two\n particle colors; mouse click restarts run.\n*/\n\nvec4 Loadv4 (int idVar);\n\nconst int nMolEdge = 24;\nconst int nMol = nMolEdge * nMolEdge;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec3 col;\n  vec2 canvas, uv, ut, p, s, t, ds;\n  float dMin, d, bFac, bLen;\n  int nn;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  if (max (abs (uv.x), abs (uv.y)) > 1.) col = vec3 (0.82);\n  else {\n    bFac = Loadv4 (nMol).y;\n    bLen = bFac * float (nMolEdge);\n    ut = 0.5 * bLen * uv;\n    dMin = 2. * bLen;\n    for (int n = 0; n < nMol; n ++) {\n      p = Loadv4 (n).xy;\n      s = ut - p;\n      d = length (s);\n      t = abs (s) - bLen + 0.5;\n      ds = bLen * sign (p);\n      if (min (t.x, t.y) > 0.) d = min (d, length (s + ds));\n      else if (t.x > 0.) d = min (d, length (s + vec2 (ds.x, 0.)));\n      else if (t.y > 0.) d = min (d, length (s + vec2 (0., ds.y)));\n      if (d < dMin) {\n        dMin = d;\n        nn = n;\n      }\n    }\n    col = mix (((nn < nMol / 2) ? vec3 (0., 1., 1.) : vec3 (1., 1., 0.)), vec3 (0.3, 0.2, 0.2),\n       smoothstep (0.45, 0.5, dMin));\n  }\n  fragColor = vec4 (col, 1.);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Molecular Diffusion\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nMolEdge = 24;\nconst int nMol = nMolEdge * nMolEdge;\nconst float pi = 3.14159;\nfloat bFac;\n\nvec4 Step (int mId)\n{\n  vec4 p;\n  vec2 dr, f;\n  float rr, rri, rri3, rCut, rrCut, bLen, dt;\n  bLen = bFac * float (nMolEdge);\n  rCut = pow (2., 1./6.);\n  rrCut = rCut * rCut;\n  f = vec2 (0.);\n  p = Loadv4 (mId);\n  for (int n = 0; n < nMol; n ++) {\n    dr = p.xy - Loadv4 (n).xy;\n    if (abs (dr.x) > 0.5 * bLen) dr.x -= bLen * sign (dr.x);\n    if (abs (dr.y) > 0.5 * bLen) dr.y -= bLen * sign (dr.y);\n    rr = dot (dr, dr);\n    if (n != mId && rr < rrCut) {\n      rri = 1. / rr;\n      rri3 = rri * rri * rri;\n      f += 48. * rri3 * (rri3 - 0.5) * rri * dr;\n    }\n  }\n  dt = 0.005;\n  p.zw += dt * f;\n  p.xy += dt * p.zw;\n  p.xy -= bLen * sign (p.xy) * step (vec2 (0.5 * bLen), abs (p.xy));\n  return p;\n}\n\nvec4 Init (int mId)\n{\n  vec4 p;\n  float x, y;\n  y = float (mId / nMolEdge);\n  x = float (mId) - float (nMolEdge) * y;\n  p.xy = bFac * ((vec2 (x + 0.25 * (2. * mod (y, 2.) - 1.), y) - 0.5 * float (nMolEdge - 1)));\n  p.zw = 3. * sin (2. * pi * Hashff (float (mId)) + vec2 (0.5 * pi, 0.));\n  return p;\n}\n\nconst float txRow = 128.;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, stDat, p;\n  vec2 iFrag;\n  int mId;\n  bool init;\n  iFrag = floor (fragCoord);\n  mId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || mId >= nMol + 1) discard;\n  mPtr = iMouse;\n  init = (iFrame <= 5);\n  if (init) {\n    bFac = 1.1;\n    stDat = vec4 (0., bFac, 0., 0.);\n  } else {\n    stDat = Loadv4 (nMol);\n    ++ stDat.x;\n    bFac = stDat.y;\n    if (mPtr.z > 0. && stDat.x > 50.) {\n      stDat.x = 0.;\n      init = true;\n    }\n  }\n  if (mId < nMol) {\n    if (init) p = Init (mId);\n    else p = Step (mId);\n  }\n  Savev4 (mId, ((mId < nMol) ? p : stDat), fragColor, fragCoord);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// \"Molecular Diffusion\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nMolEdge = 24;\nconst int nMol = nMolEdge * nMolEdge;\nconst float pi = 3.14159;\nfloat bFac;\n\nvec4 Step (int mId)\n{\n  vec4 p;\n  vec2 dr, f;\n  float rr, rri, rri3, rCut, rrCut, bLen, dt;\n  bLen = bFac * float (nMolEdge);\n  rCut = pow (2., 1./6.);\n  rrCut = rCut * rCut;\n  f = vec2 (0.);\n  p = Loadv4 (mId);\n  for (int n = 0; n < nMol; n ++) {\n    dr = p.xy - Loadv4 (n).xy;\n    if (abs (dr.x) > 0.5 * bLen) dr.x -= bLen * sign (dr.x);\n    if (abs (dr.y) > 0.5 * bLen) dr.y -= bLen * sign (dr.y);\n    rr = dot (dr, dr);\n    if (n != mId && rr < rrCut) {\n      rri = 1. / rr;\n      rri3 = rri * rri * rri;\n      f += 48. * rri3 * (rri3 - 0.5) * rri * dr;\n    }\n  }\n  dt = 0.005;\n  p.zw += dt * f;\n  p.xy += dt * p.zw;\n  p.xy -= bLen * sign (p.xy) * step (vec2 (0.5 * bLen), abs (p.xy));\n  return p;\n}\n\nvec4 Init (int mId)\n{\n  vec4 p;\n  float x, y;\n  y = float (mId / nMolEdge);\n  x = float (mId) - float (nMolEdge) * y;\n  p.xy = bFac * ((vec2 (x + 0.25 * (2. * mod (y, 2.) - 1.), y) - 0.5 * float (nMolEdge - 1)));\n  p.zw = 3. * sin (2. * pi * Hashff (float (mId)) + vec2 (0.5 * pi, 0.));\n  return p;\n}\n\nconst float txRow = 128.;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, stDat, p;\n  vec2 iFrag;\n  int mId;\n  bool init;\n  iFrag = floor (fragCoord);\n  mId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || mId >= nMol + 1) discard;\n  mPtr = iMouse;\n  init = (iFrame <= 5);\n  if (init) {\n    bFac = 1.1;\n    stDat = vec4 (0., bFac, 0., 0.);\n  } else {\n    stDat = Loadv4 (nMol);\n    ++ stDat.x;\n    bFac = stDat.y;\n    if (mPtr.z > 0. && stDat.x > 50.) {\n      stDat.x = 0.;\n      init = true;\n    }\n  }\n  if (mId < nMol) {\n    if (init) p = Init (mId);\n    else p = Step (mId);\n  }\n  Savev4 (mId, ((mId < nMol) ? p : stDat), fragColor, fragCoord);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}