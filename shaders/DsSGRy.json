{
    "Shader": {
        "info": {
            "date": "1667771906",
            "description": "Move the camera with the mouse",
            "flags": 0,
            "hasliked": 0,
            "id": "DsSGRy",
            "likes": 43,
            "name": "Reflected infinity",
            "published": 3,
            "tags": [
                "reflection",
                "refraction",
                "domain",
                "glass",
                "art",
                "geometric",
                "crystal"
            ],
            "usePreview": 0,
            "username": "kishimisu",
            "viewed": 1042
        },
        "renderpass": [
            {
                "code": "/* @kishimisu - 2022 \n\n   Playing with reflection and refraction */\n\n#define AA 2\n\n#define PI 3.141592\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define impulse(freq, off) pow(smoothstep(0., .5, sin(off+(iTime-4.5)*freq)*.5+.5), 10.)\n\nfloat sdBox(vec3 p, vec3 s) {\n  vec3 q = abs(p) - s;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0)-.0;\n}\n\n// x: distance to box\n// y: distance to shape\n// z: min absolute distance to scene\nvec3 map(vec3 p) {\n    float box = sdBox(p, vec3(.9, 1.5, .9)) - .05;\n     \n    // animations\n    p.xy *= rot(impulse(.3,PI)*3.14); // xy rotation\n    p.xz *= rot(impulse(.2,0.)*1.57); // xz rotation\n    p = abs(abs(p) - impulse(1.,PI)*.4); // first domain rep\n    p = mix(p, abs(p*2. - .3), impulse(.5,0.)); // second domain rep\n    float shape = mix(length(p) - .25, sdBox(p, vec3(.25)), impulse(2., 0.))*.5; // box/sphere\n    \n    shape = max(box, shape);\n    return vec3(box, shape, min(abs(box), shape));\n}\n\nvec3 normal(vec3 p) {\n    const float h = 0.0001;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ).x + k.yyx*map( p + k.yyx*h ).x + \n                      k.yxy*map( p + k.yxy*h ).x + k.xxx*map( p + k.xxx*h ).x );\n}\n\n// refract, or reflect if total internal refraction\nvec3 rrefract(vec3 rd, vec3 n, float ior) {\n    vec3   r = refract(rd, n, ior);\n    return r == vec3(0.) ? reflect(rd, n) : r;\n}\n\nvoid initRayOriginAndDirection(vec2 fragCoord, inout vec3 ro, inout vec3 rd) {\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy*2.-1.;\n    \n    float z = iMouse.z > 0. ? 1. : smoothstep(0., 6., iTime);\n    ro = vec3(0., 0., 4.2); \n    ro.yz *= rot(iMouse.z > 0. ? m.y*1.5 : -1.5 + mix(0.5, 1.85, z));\n    ro.zx *= rot(m.x*2.+iTime*.2);\n        \n    vec3 f = normalize(vec3(0.,.2,0.)-ro), r = normalize(cross(vec3(0,1,0), f));\n    rd = normalize(f + uv.x*r + uv.y*cross(f,r));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {                  \n    vec3 tot; for (int j = 0; j < AA; j++) for (int k = 0; k < AA; k++) { // antialiasing code \n    vec2 o = vec2(float(j), float(k)) / float(AA) - 0.5;\n    \n    vec3 ro, rd;\n    initRayOriginAndDirection(fragCoord+o/2., ro, rd);\n    \n    vec3 bgColor = mix(vec3(.17,.0,.16), vec3(0.,0.,.12), rd.y-.3)*.8;\n    vec3 tintColor = vec3(1.,.5,.5) + .07*sin(vec3(1.4,.54,1.23)*iTime*.3);\n    \n    vec3 p = ro, color = bgColor;\n    float i, t, inside, entry, fresnel;\n    const float ior = 1.7;\n    \n    for (i = 0.; i < 150.; i++) {\n        vec3 d = map(p);\n\n        if (d.y < .001) {\n            // sphere hit\n            color = tintColor;\n            break;\n        }\n        \n        p += d.z*rd;\n        t += d.z;\n        \n        if (inside < .5) {\n            if (d.x < .001) { \n                // first box hit\n                vec3 n = normal(p);\n                fresnel = pow(1. - clamp(-dot(rd, n), 0., 1.), 4.);\n                rd = rrefract(rd, n, 1./ior);\n                p += rd*.04;\n                entry = t;\n                inside++;\n            }\n        } else {\n            if (d.x > -.001) {\n                // inside box bounces\n                vec3 n = normal(p);\n                rd = reflect(rd, n);\n                p += rd*.1;\n                inside++;\n            }       \n\n        }\n        if (inside > 6. || t > 15.) break;\n    }\n    \n    if (inside > 0.) {\n        float att = exp(-(t-entry)*.3);\n        color = mix(bgColor*.7, color - vec3(.5,.5,2.)*fresnel, exp(-i*.005) * att);\n    }\n    tot += color;\n\n} tot /= float(AA*AA); // antialiasing code\n  fragColor.rgb = tot;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}