{
    "Shader": {
        "info": {
            "date": "1616493074",
            "description": "ray marching ",
            "flags": 0,
            "hasliked": 0,
            "id": "ssX3WB",
            "likes": 0,
            "name": "ray marching - v2",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "jezersek",
            "viewed": 214
        },
        "renderpass": [
            {
                "code": "#define NUMBER_OF_STEPS 1000\n#define MAX_DISTANCE 40.0\n#define FOG_DISTANCE 20.0\n#define FOG_DENSITY 0.1\n#define COLLISION_THRESHOLD 0.01\n#define MAX_STEP_SIZE 1000.0\n#define EPSILON 0.001\n\n#define SHAPE_BLEND 0.9\n#define COLOR_BLEND 0.9\n\nfloat f = 1.; // focal length\nvec3 light1 = normalize(vec3(1,1,-.9));\nvec3 light2 = normalize(vec3(-1,0,-.9));\n\nfloat distance_to_wave_sphere_repeat(vec3 ray, vec3 pos, float r, float amplitude, vec3 frequency, float speed){\n    return distance(vec3(mod(ray.x+2.,2.)-1., ray.y, mod(ray.z+2.,2.)-1.), pos) - r + sin(ray.x*frequency.x+iTime*speed)*amplitude + sin(ray.y*frequency.y+iTime*speed)*amplitude + sin(ray.z*frequency.z+iTime*speed)*amplitude;\n}\n\nfloat distance_to_wave_sphere(vec3 ray, vec3 pos, float r, float amplitude, vec3 frequency, float speed){\n    return distance(ray, pos) - r + sin(ray.x*frequency.x+iTime*speed)*amplitude + sin(ray.y*frequency.y+iTime*speed)*amplitude + sin(ray.z*frequency.z+iTime*speed)*amplitude;\n}\n\nfloat distance_to_sphere(vec3 ray, vec3 pos, float r){\n    return distance(ray, pos) - r;\n}\n\nfloat smooth_min( float d1, float d2, float s ) {\n    /*float h = clamp( 0.5 + 0.5*(d2-d1)/s, 0.0, 1.0 );\n    return mix( d2, d1, h ) - s*h*(1.0-h);*/\n    \n    float t = tanh((d1-d2)*s);\n    return ((1.+t)*d2 + (1.-t)*d1)/2.;\n}\n\nfloat safe_distance(vec3 ray, out vec3 color, out float shininess){\n    float min_distance = MAX_STEP_SIZE;\n    \n    float size = .9;\n    float k = SHAPE_BLEND;\n    \n    float d = distance_to_wave_sphere_repeat(ray, vec3(0,-4,0), 1., 0.05, vec3(5.3,3.7,4.5), 1.9);\n    float d1 = distance_to_wave_sphere(ray, vec3(0,0,6), 1.5, 0.05, vec3(5.3,3.7,4.5), .9);\n    float d2 = distance_to_sphere(ray, vec3(2.*sin(iTime*2.), 2.*sin(iTime*0.8), 6.+2.*sin(iTime*0.6)), size); \n    /*float d3 = distance_to_sphere(ray, vec3(2.*sin(iTime*0.8), 2.*sin(iTime*0.6), 6.+2.*sin(iTime*2.)), size); \n    float d4 = distance_to_sphere(ray, vec3(2.*sin(iTime*0.1), 2.*sin(iTime*2.), 6.+2.*sin(iTime*0.4)), size); \n    float d5 = distance_to_sphere(ray, vec3(2.*sin(iTime*0.5), 2.*sin(iTime*2.1), 6.+2.*sin(iTime*0.7)), size); */\n   \n    //min_distance = smooth_min(smooth_min(smooth_min(d1, d2, k), smooth_min(d3, d4, k), k), d5, k);\n    \n    // shape blending\n    min_distance = smooth_min(d1, d2, k);\n    min_distance = min(min_distance, d);\n    \n    // color blending\n    vec3 color1 = vec3(1,0,0);\n    vec3 color2 = vec3(.3,0,1);\n    \n    shininess = 1.;\n      \n    float t = tanh((d1-d2)*COLOR_BLEND);\n    color = ((1.+t)*color1 + (1.-t)*color2)/2.;\n    \n    // glow on intersection\n    color += vec3(1,1,1)*(pow(1.-t*t, 10.*(4.+sin(ray.y*100.)+cos(ray.x*100.)) ));\n    \n    if(d == min_distance){\n        color *= 0.3;\n        shininess = 0.;\n    }\n    \n    \n    return min_distance;\n}\n\nfloat safe_distance(vec3 ray){\n    vec3 c = vec3(0);\n    float s = 0.;\n    return safe_distance(ray, c, s);\n}\n\nvec3 normal(vec3 ray){\n    vec3 n = vec3(0,0,0);\n    vec3 epsilon = vec3(EPSILON, 0, 0);\n    \n    float x = safe_distance(ray + epsilon.xyy) - safe_distance(ray - epsilon.xyy);\n    float y = safe_distance(ray + epsilon.yxy) - safe_distance(ray - epsilon.yxy);\n    float z = safe_distance(ray + epsilon.yyx) - safe_distance(ray - epsilon.yyx);\n    \n    return normalize(vec3(x,y,z));\n}\n\nvec3 ray_march(vec3 ray){\n    vec3 color = vec3(0,0,0);\n    float shininess = 0.;\n    vec3 bodyColor = vec3(0);\n    float d = 0.; // ray length\n    float min_distance = 100000.; // infty\n    for(int j=0; j<NUMBER_OF_STEPS; j++){\n        float step_size = safe_distance(ray*d, bodyColor, shininess);\n        \n        if(step_size < COLLISION_THRESHOLD){ // collision\n            vec3 n = normal(ray*d);\n            float l1 = max(dot(n, light1), 0.);\n            float l2 = max(dot(n, light2), 0.);\n            //color = (l1 * vec3(.9,0,0.5) + l2 * vec3(.0,.5,.7));\n            //color = -n*0.5+0.5;\n            color = bodyColor*l1 + bodyColor*l2 + (vec3(0.5)*pow(l1, 30.) + vec3(.5)*pow(l2, 30.))*shininess;\n            \n            // fog in the distance\n            color /= (exp((d-FOG_DISTANCE)*FOG_DENSITY)+1.);\n            \n            return color;\n        }\n        \n        if(step_size < min_distance) min_distance = step_size;\n        \n        d += step_size;\n        \n        if(d > MAX_DISTANCE){ // decay\n           break;\n        }\n    }\n    \n    // glow\n    //color = vec3(1.,.4,.9)*pow(max(1.-min_distance,0.),10.);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalize coordinate system\n    float mind = min(iResolution.y, iResolution.x);\n    vec2 uv = (fragCoord-iResolution.xy/2.)/mind;\n\n    \n    vec3 ray = normalize(vec3(uv, f));\n    \n    vec3 color = ray_march(ray);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}