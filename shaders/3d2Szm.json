{
    "Shader": {
        "info": {
            "date": "1553271908",
            "description": "Shadertoy version of a shader I made to demonstrate the log-spherical mapping for this article: \n\nhttps://www.osar.fr/notes/logspherical/\n\nThe log-spherical mapping allows the creation of self-similar SDFs, without loops.",
            "flags": 0,
            "hasliked": 0,
            "id": "3d2Szm",
            "likes": 69,
            "name": "Recursive Lotus",
            "published": 3,
            "tags": [
                "raymarching",
                "sdf",
                "flower",
                "recursive",
                "zoomer",
                "loopless",
                "selfsimilar",
                "logspherical"
            ],
            "usePreview": 0,
            "username": "dracusa",
            "viewed": 1777
        },
        "renderpass": [
            {
                "code": "/*\nSelf-similar flower based on the log-spherical mapping.\nAccompanying blog post: https://www.osar.fr/notes/logspherical/\n*/\n\n#define AA 2\n#define M_PI 3.1415926535897932384626433832795\n\nfloat density;\nfloat height;\nfloat fov;\nfloat camera_y;\nfloat gTime;\nfloat vcut;\nfloat lpscale;\n\nfloat camera_ty = -0.17;\nfloat interpos = -0.5;\nfloat shorten = 1.;\nfloat line_width = 0.017;\nfloat rot_XY = 0.;\nfloat rot_YZ = 0.785;\nfloat radius = 0.05;\nfloat rho_offset = 0.;\n\n// Modified from https://iquilezles.org/articles/distfunctions\nfloat sdCone( vec3 p, vec2 c )\n{\n\t// c must be normalized\n\tfloat q = length(p.xz);\n\treturn dot(c,vec2(q,p.y));\n}\n\n// Axis rotation taken from tdhooper. R(p.xz, a) rotates \"x towards z\".\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n/*\nTile space in a log-spherical grid.\n\n- in `p`: input point\n- out `sp`: point in log-spherical space without offset or tiling\n- out `tp`: point in tiled log-spherical space\n- out `rp`: point in rotated tiled log-spherical space\n- out `mul`: total amount of scaling applied at this point\n*/\nvoid tile(in vec3 p, out vec3 sp, out vec3 tp, out vec3 rp, out float mul)\n{\n\t// Apply the forward log-spherical map\n\tfloat r = length(p);\n\tp = vec3(log(r), acos(p.y / length(p)), atan(p.z, p.x));\n\n\t// Get a scaling factor to compensate for pinching at the poles\n\t// (there's probably a better way of doing this)\n\tfloat xshrink = 1.0/(abs(p.y-M_PI)) + 1.0/(abs(p.y)) - 1.0/M_PI;\n\tp.y += height;\n\tp.z += p.x * 0.3;\n\tmul = r/lpscale/xshrink;\n\tp *= lpscale;\n\tsp = p;\n\n\t// Apply rho-translation, which yields zooming\n\tp.x -= rho_offset + gTime;\n\t\n\t// Turn tiled coordinates into single-tile coordinates\n\tp = fract(p*0.5) * 2.0 - 1.0;\n\tp.x *= xshrink;\n\ttp = p;\n\tpR(p.xy, rot_XY);\n\tpR(p.yz, rot_YZ);\n\trp = p;\n}\n\nfloat sdf(in vec3 p)\n{\n\tvec3 sp, tp, rp;\n\tfloat mul;\n\ttile(p, sp, tp, rp, mul);\n\t\n\t// surface\n\tfloat spheres = abs(rp.x) - 0.012;\n\tfloat leaves = max(spheres, max(-rp.y, rp.z));\n\tleaves = max(leaves, vcut-sp.y);\n\tspheres = max(spheres, vcut-sp.y+1.07);\n\tfloat ret = min(leaves, spheres);\n\n\t// intercals\n\tvec3 pi = rp;\n\tpi.x += interpos;\n\tfloat interS = abs(pi.x) - 0.02;\n\tfloat interL = max(interS, max(-rp.y, rp.z));\n\tinterL = max(interL, vcut-sp.y+2.);\n\tinterS = max(interS, vcut-sp.y+3.);\n\tret = min(ret, min(interL, interS));\n\n\t// outline\n\tfloat ol = abs(rp.y) - radius*0.8;\n\tol = min(ol, abs(rp.z) - radius*0.8);\n\t// cut out\n\tret = max(ret, -ol);\n\n\treturn ret * mul / shorten;\n}\n\nvec3 colr(in vec3 p)\n{\n\tvec3 sp, tp, rp, ret;\n\tfloat mul;\n\ttile(p, sp, tp, rp, mul);\n\n\t// 2d outline\n\tfloat ol = abs(rp.y) - radius;\n\tol = min(ol, abs(rp.z) - radius);\n\n\t// intercals\n\tvec3 pi = rp;\n\tpi.x += interpos;\n\tfloat inter = abs(pi.x) - 0.02;\n\tinter = max(inter, vcut-sp.y+2.);\n\n\tfloat dark = smoothstep(density*0.25, density*0.5, density - sp.y);\n\tdark *= dark;\n\t\n\tif (ol < line_width)\n\t\tret = vec3 (0.6, 0.6, 0.8)*dark;\n\telse if (inter < 0.02)\n\t\tret = vec3 (0.1, 0.35, 0.05)*dark;\n\telse\n\t\tret = vec3 (0.1, 0.15, 0.25)*dark;\n\treturn ret;\n}\n\n// Adapted from https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 pos)\n{\n\tvec2 e = vec2(1.0,-1.0)*0.5773;\n\tconst float eps = 0.0005;\n\treturn normalize(\n\t\te.xyy*sdf(pos + e.xyy*eps) + \n\t\te.yyx*sdf(pos + e.yyx*eps) + \n\t\te.yxy*sdf(pos + e.yxy*eps) + \n\t\te.xxx*sdf(pos + e.xxx*eps)\n\t);\n}\n\n// From https://iquilezles.org/articles/functions\nfloat gain(float x, float k) \n{\n\tfloat a = 0.5*pow(2.0*((x<0.5)?x:1.0-x), k);\n\treturn (x<0.5)?a:1.0-a;\n}\n\nvec3 gain(vec3 v, float k)\n{\n\treturn vec3(gain(v.x, k), gain(v.y, k), gain(v.z, k));\n}\n\nfloat osc(float v1, float v2)\n{\n\treturn (sin(iTime*0.25)*0.5+0.5)*(v2-v1)+v1;\n}\n\n// Based on https://iquilezles.org/articles/raymarchingdf\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 iUV = fragCoord/iResolution.xy;\n\n\tgTime = iTime + osc(0., 4.);\n\tdensity = 26.;\n\theight = osc(0., 0.41);\n\tfov = osc(1.5, 1.07);\n\tcamera_y = osc(0.4, 1.07);\n\n\t\n\tvcut = floor(density*0.25)*2.+0.9;\n\tlpscale = floor(density)/M_PI;\n    \n\n\t // camera movement\t\n\tfloat an = 0.002*gTime + 7.0;\n\tvec3 ro = vec3(1.0*cos(an), camera_y, 1.0*sin(an));\n\tvec3 ta = vec3( 0.0, camera_ty, 0.0 );\n\t// camera matrix\n\tvec3 ww = normalize(ta - ro);\n\tvec3 uu = normalize(cross(ww,vec3(0.0,1.0,0.0)));\n\tvec3 vv = normalize(cross(uu,ww));\n\n\tvec3 bg = vec3(0.06, 0.08, 0.11)*0.3;\n\tbg *= 1.-smoothstep(0.1, 2., length(iUV*2.-1.));\n\tvec3 tot = bg;\n\t\n\t#if AA>1\n\tfor(int m=0; m<AA; m++)\n\tfor(int n=0; n<AA; n++)\n\t{\n\t\t// pixel coordinates\n\t\tvec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n\t\tvec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n\t\t#else    \n\t\tvec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\t\t#endif\n\n\t\t// create view ray\n\t\tvec3 rd = normalize(p.x*uu + p.y*vv + fov*ww);\n\n\t\t// raymarch\n\t\tconst float tmax = 3.5;\n\t\tfloat t = 0.0;\n\t\tvec3 pos;\n\t\tint iout;\n\t\tfor( int i=0; i<64; i++ )\n\t\t{\n\t\t\tpos = ro + t*rd;\n\t\t\tfloat h = sdf(pos);\n\t\t\tif( h<0.0001 || t>tmax ) break;\n\t\t\tt += h;\n\t\t\tiout = i;\n\t\t}\n\t\tfloat fSteps = float(iout) / 64.;\n\t\n\t\t// shading/lighting\t\n\t\tvec3 col = vec3(0.0);\n\t\tif( t<tmax )\n\t\t{\n\t\t\tvec3 nor = calcNormal(pos);\n\t\t\tfloat dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n\t\t\tfloat amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n\t\t\tcol = colr(pos)*amb + colr(pos)*dif;\n\t\t}\n\n\t\t// glow\n\t\tfloat gloamt = smoothstep(0.04, 0.5, length(pos));\n\t\tfloat gain_pre = 1. - gloamt*0.6;\n\t\tfloat gain_k = 1.5 + gloamt*2.5;\n\t\tcol += gain(fSteps*vec3(0.7, 0.8, 0.9)*gain_pre, gain_k);\n\n\t\t// fog\n\t\tcol = mix(col, bg, smoothstep(0.2+camera_y, 1.6+camera_y, t));\n\n\t\t// gamma        \n\t\tcol = sqrt( col );\n\t\ttot += col;\n\t#if AA>1\n\t}\n\ttot /= float(AA*AA);\n\t#endif\n\n\tfragColor = vec4(tot, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}