{
    "Shader": {
        "info": {
            "date": "1583181775",
            "description": "using a refracted ray into a cubemap to pick surface colour.\nnotice how other objects are not visible behind those in front. this requires a slightly more complex solution.",
            "flags": 0,
            "hasliked": 0,
            "id": "wlKXzV",
            "likes": 10,
            "name": "raymarching refraction (simple)",
            "published": 3,
            "tags": [
                "raymarch",
                "refraction"
            ],
            "usePreview": 0,
            "username": "isk",
            "viewed": 1126
        },
        "renderpass": [
            {
                "code": "// anti-aliasing samples. set to 0 to disable AA.\n#define AA 2\n\nconst float PI=acos(-1.);\nconst float EPS=.001,MAX=100.;\nconst int ITER=256;\n\nfloat ycyl(vec3 p, float r) {\n    return length(p.xz)-r;\n}\n\nfloat sph(vec3 p, float r) {\n    return length(p)-r;\n}\n\nfloat ztor(vec3 p, vec2 r) {\n    vec2 circ=vec2(length(p.xz)-r.x,p.y);\n    return length(circ)-r.y;\n}\n\nfloat scene(vec3 p) {\n    float d=MAX;\n    d=min(d,ycyl(p,.5));\n    d=min(d,sph(abs(p)-1.,.6));\n    d=min(d,ztor(p, vec2(1., .3)));\n    return d;\n}\n\nvec3 normal(vec3 p){\n    vec2 D=vec2(.001,0);\n    return normalize(scene(p)-vec3(scene(p-D.xyy),scene(p-D.yxy),scene(p-D.yyx)));\n}\n\nfloat march(vec3 ro, vec3 rd){\n    float t=0.,d;\n    for(int i=0; i<ITER; ++i){\n        d=scene(ro+rd*t);\n        if(abs(d)<EPS) return t;\n        t+=d;\n        if(t>MAX) return t;\n    }\n    return t;\n}\n\nvec3 ray(vec2 uv, vec3 ro, vec3 poi){\n    vec3 f=normalize(poi-ro),\n         r=normalize(cross(f,vec3(0,1,0))),\n         u=cross(r,f),\n         c=ro+f,\n         i=c+r*uv.x+u*uv.y;\n    return normalize(i-ro);\n}\n\nvec3 render(vec2 uv){\n    float orbit=-2.*PI*iMouse.x/iResolution.x;\n    vec3 ro;\n    if (iMouse.z>0.)\n        ro=vec3(sin(orbit)*5.,-2.*iMouse.y/iResolution.y+1.,cos(orbit)*5.);\n    else\n        ro=vec3(sin(iTime),cos(iTime),5.);\n    vec3 rd=ray(uv,ro,vec3(0));\n    float t=march(ro,rd);\n    if(t>=MAX) return texture(iChannel0,rd).rgb;\n    vec3 p=ro+rd*t,n=normal(p);\n    return texture(iChannel0,refract(rd,n,.75)).rgb;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv=(fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col=vec3(0);\n#if AA>1\n    vec2 aao;\n    const float AAINC=1./float(AA);\n    for (aao.x=-.5; aao.x<.5; aao.x+=AAINC)\n        for (aao.y=-.5; aao.y<.5; aao.y+=AAINC)\n            col+=render(uv+aao/iResolution.y);\n    col/=float(AA*AA);\n#else\n    col+=render(uv);\n#endif\n    fragColor=vec4(col,1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}