{
    "Shader": {
        "info": {
            "date": "1629676780",
            "description": "Thanks to @iq @BigWIngs for their time sharing their knowledge and specially to @samlo because today I learnt how to colorize different objects! \nCheck https://www.shadertoy.com/view/wd2SR3 !\nAnd now with fog thanks to @FabriceNeyret2 !",
            "flags": 0,
            "hasliked": 0,
            "id": "sdcGWH",
            "likes": 12,
            "name": "RayMarching Army",
            "published": 3,
            "tags": [
                "raymarching",
                "sdf",
                "instances",
                "instancing",
                "army"
            ],
            "usePreview": 0,
            "username": "CannaVizion",
            "viewed": 457
        },
        "renderpass": [
            {
                "code": "//Second shader after watching some tutorials from The Art of Code (AKA BigWIngs) https://www.youtube.com/c/TheArtofCodeIsCool/videos\n//and getting some code from IÃ±igo Quilez (https://iquilezles.org/articles/distfunctions)\n//Also many thanks to @samlo for his great explanation on how to colorize diferent objects https://www.shadertoy.com/view/wd2SR3\n//First steps... totally unoptimized and I still get some artifacts on the feet and the shadows\n//Starts dropping frames when in fullscreen @4K\n//This one is inspired on a video I saw about the Chinese army\n//Play around with Camera Rotation and/or Mouse Rotation\n//It's a pitty I can't add a song that matches the rhythm (something seems to be wrong when importing links from SoundCloud) \n//Feedback appreciated!\n//---Edit:\n//Added fog thanks to @FabriceNeyret2!!\n//---Edit:\n//And now with Phong illumination!\n//I replaced the previous code (see bellow) with a fork of Ray Marching Phong Template by @alijaya https://www.shadertoy.com/view/4t2fR1\n//where I added the color picking system I learnt from @samlo\n\n\n#define EPSILON 0.01\n#define MIN_DISTANCE 0.1 \n#define MAX_DISTANCE 100.0\n#define MAX_MARCHING_STEP 200\n\n#define CAM_ROTATION 1\n#define MOUSE_CAM_ROT 0\n#define HEAD_ROTATION 0                 \n#define SHADOWS 1                       //change it to 0 to disable shadows\n\n#define DARK_ID 0.\n#define CLOTH_ID 1.\n#define SKIN_ID 2.\n#define WHITE_ID 3.\n#define GROUND_ID 4.\n\n#define time iTime*4.\n#define PI 3.14159265\n\nstruct Ray {\n    vec3 o; // origin\n    vec3 d; // direction, always normalized\n};\n\nstruct Camera {\n    vec3 pos;\n    vec3 lookAt;\n    float focal;\n    vec2 sensorSize;\n};\n\nstruct Light {\n    vec3 pos;\n    vec3 color;\n};\n    \nvec3 xe = vec3(EPSILON, 0., 0.);\nvec3 ye = vec3(0., EPSILON, 0.);\nvec3 ze = vec3(0., 0., EPSILON);\n\nfloat max3 (vec3 v) {\n  return max (max (v.x, v.y), v.z);\n}\n\nmat2 rotMat(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2 (c,-s,s,c);\n}\n\n\n// get corresponding ray from uv (0.0 -> 1.0)\nRay getRay( Camera cam, vec2 uv ) {\n    vec3 camDir = normalize(cam.lookAt - cam.pos); // the camera direction\n    vec3 center = cam.pos + cam.focal * camDir; // get the coordinate of the screen center\n    vec2 coord = (uv - 0.5) * cam.sensorSize; // convert from 0.0 -> 1.0 to -sensorSize / 2. -> sensorSize / 2.\n    \n    // axis relative to camera\n    vec3 zpos = -camDir; // k hat, outward the screen\n    vec3 xpos = cross(vec3(0., 1., 0.), zpos); // i hat, cross from ypos global and zpos local\n    vec3 ypos = cross(zpos, xpos); // j hat, cross from zpos local and xpos local\n    \n    // target in screen\n    vec3 target = center + coord.x * xpos + coord.y * ypos; // get pixel target coordinate from the screen\n    \n    Ray ray;\n    ray.o = cam.pos; // the origin of the ray is from the camera duh\n    ray.d = normalize(target - cam.pos); // the direction is from the camera to the target\n    \n    return ray;\n}\n\n// project point to ray\nvec3 projPoint2Ray( vec3 point, Ray ray ) {\n    vec3 rel = point - ray.o; // get relative vector from the point to the ray origin\n    float len = dot(rel, ray.d); // project that vector to vector direction of the ray, we get the length\n    return len * ray.d + ray.o; // multiply the length with unit vector direction and add to ray origin\n}\n\n// get the distance from point to ray (or line)\nfloat distPoint2Ray( vec3 point, Ray ray ) {\n    vec3 proj = projPoint2Ray(point, ray); // project it first to the ray\n    return distance(proj, point); // get the distance from the projected position to the original position\n}\n\n// just linear interpolation, map value v between fromA and fromB to between toA and toB\nfloat lerp( float v, float fromA, float fromB, float toA, float toB ) {\n    return (v - fromA) / (fromB - fromA) * (toB - toA) + toA;\n}\n\n\n// box function\nfloat sdBox( vec3 p, vec3 s ) {\n    vec3 d = abs(p) - s;\n    return max(d.x, max(d.y, d.z));\n}\n\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nvec3 opRep( in vec3 p, in vec3 c )\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return q ;\n}\n\nfloat add (inout vec2 a, vec2 b){\n    a = mix(a,b,step(b.x,a.x));\n    return 0.;\n}\n\nvec2 sdScene( vec3 p ) {\n    vec3 armSize = vec3 (.2,.4,.2);                           //Arms Size\n    vec3 handSize = vec3 (.2,.2,.13);          \n    vec3 legSize = vec3 (.22,.8,.2);\n    vec3 bodySize = vec3 (.6,1.,.3);\n    vec3 headSize = vec3(.3,.35,.3);\n    vec3 footSize = vec3(.2,.1,.43);\n    vec3 capSize = vec3(.36,.1,.45);\n\n    vec3 clothColor = vec3(0.027,0.27,0.05);\n    vec3 skinColor = vec3(0.764,0.6,0.552);\n\n    vec3 pG = p;\n    pG.z += mod(time,4.);                                                //Global Position\n    pG = opRep(pG,vec3(3,0,4));\n    vec3 pB = pG;                                               //Body Position\n    vec3 pH = pG -vec3(0,bodySize.y+headSize.y+0.05,0);         //Head Position\n#if HEAD_ROTATION \n    pH.xz *= rotMat(-sin(time)*.5);                               //Head Rotation\n#endif\n    vec3 pCap = pH - vec3(0,headSize.y+capSize.y-.05,-capSize.z/3.3);                                               \n    vec3 pShouldL = pG - vec3 (-(bodySize.x+armSize.x+0.05),bodySize.y,0);   //Shoulder Position\n    pShouldL.yz *= rotMat(sin(time));                          //Shoulder Rotation    \n    vec3 pArmL = pShouldL + vec3 (0,armSize.y,0);               //Arm Position\n    vec3 pForeL = pShouldL-vec3(0,-2.*armSize.y-0.05,0);                       //Forearm Position\n    pForeL.xz *= rotMat(radians(90.));                           //Forearm Rotation\n    pForeL.yz *= rotMat(clamp(-sin(time)*PI/2.,0.,PI/2.));\n    pForeL += vec3(0,armSize.y,0);                             //Forearm Anchor P reposition\n    vec3 pHandL = pForeL-vec3(0,-armSize.y-handSize.y-0.05,0);\n    pHandL.xz *= rotMat(-1.*clamp(-sin(time)*PI,0.,PI/2.)+PI);    \n    vec3 pLegL = pB - vec3(-.4,-bodySize.y-.05,0);\n    pLegL.yz *= rotMat(-sin(time));\n    pLegL += vec3(0,legSize.y,0);\n    vec3 pFootL = pLegL - vec3(0,-legSize.y-footSize.y-0.05,-footSize.z/2.);\n\n    vec3 pShouldR = pG - vec3(bodySize.x+armSize.x+0.05,bodySize.y,0);\n    pShouldR.yz *= rotMat(-sin(time));\n    vec3 pArmR = pShouldR + vec3 (0,armSize.y,0);;\n    vec3 pForeR = pShouldR-vec3(0,-2.*armSize.y-0.05,0);\n    pForeR.xz *= rotMat(radians(-90.));\n    pForeR.yz *= rotMat(clamp(sin(time)*PI/2.,0.,PI/2.));\n    pForeR += vec3(0,armSize.y,0);\n    vec3 pHandR = pForeR-vec3(0,-armSize.y-handSize.y-0.05,0);\n    pHandR.xz *= rotMat(-1.*clamp(-sin(time)*PI,-PI/2.,0.)+PI);\n    vec3 pLegR = pB - vec3(.4,-bodySize.y-.05,0);\n    pLegR.yz *= rotMat(sin(time));\n    pLegR += vec3(0,legSize.y,0);\n    vec3 pFootR = pLegR - vec3(0,-legSize.y-footSize.y-0.05,-footSize.z/2.);\n\n\n    vec2 body = vec2(sdBox(pB,bodySize),CLOTH_ID);\n    vec2 head = vec2(sdBox(pH,headSize),SKIN_ID);\n    vec2 cap = vec2(sdBox(pCap,capSize)*.5,CLOTH_ID);                      \n    \n    vec2 armL = vec2(sdBox (pArmL,armSize),CLOTH_ID); \n    vec2 foreL = vec2(sdBox(pForeL,armSize),CLOTH_ID);\n    vec2 handL = vec2(sdBox(pHandL,handSize),WHITE_ID);\n    vec2 legL = vec2(sdBox(pLegL,legSize),CLOTH_ID);\n    vec2 footL = vec2(sdBox(pFootL,footSize)*.5,DARK_ID);\n\n    vec2 armR = vec2(sdBox(pArmR,armSize),CLOTH_ID);\n    vec2 foreR = vec2(sdBox(pForeR,armSize),CLOTH_ID);\n    vec2 handR = vec2(sdBox(pHandR,handSize),WHITE_ID);\n    vec2 legR = vec2(sdBox(pLegR,legSize),CLOTH_ID);\n    vec2 footR = vec2(sdBox(pFootR,footSize)*.5,DARK_ID);\n\n    vec2 floor = vec2(sdPlane(p,vec3(0,1.,0),3.),GROUND_ID);\n    // vec2 floor = vec2(p.y+3,GROUND_ID);\n\n    vec2 result = body;\n    // result = mix(result,head,step(head.x,result.x));\n    // result = mix(result,cap,step(cap))\n    add (result,head);\n    add (result,cap);\n    add (result,armL);\n    add (result,foreL);\n    add (result,handL);\n    add (result,legL);\n    add (result,footL);\n    add (result,armR);\n    add (result,foreR);\n    add (result,handR);\n    add (result,legR);\n    add (result,footR);\n    add (result,floor);\n\n    return result;\n}\n\n// estimate normal with nudging\nvec3 estimateNormal( vec3 p ) {\n    return normalize(vec3(\n        sdScene(p+xe).x - sdScene(p-xe).x,\n        sdScene(p+ye).x - sdScene(p-ye).x,\n        sdScene(p+ze).x - sdScene(p-ze).x\n    ));\n}\n\n// ray marching algorithm\nvec2 getSDF( Ray r ) {\n    float depth = MIN_DISTANCE;\n    float matID;\n    for (int i=0; i<MAX_MARCHING_STEP; i++) {\n        float dist = sdScene( r.o + depth * r.d ).x;\n        matID = sdScene (r.o + depth * r.d).y;\n        \n        if (dist < EPSILON) { // inside a scene\n            return vec2(depth,matID);\n        }\n        \n        depth += dist; // circle marching!\n        \n        if (depth >= MAX_DISTANCE) {\n            return vec2(MAX_DISTANCE,matID);\n        }\n    }\n    \n    return vec2(MAX_DISTANCE,matID);\n}\n\nvec3 ambientLight( vec3 ambientColor ) {\n    return ambientColor;\n}\n\nvec3 phongLight( vec3 diffuseColor, vec3 specularColor, float shininess, Ray ray, float dist, Light light ) {\n    vec3 p = ray.o + dist * ray.d;\n    \n    vec3 N = estimateNormal(p); // surface normal\n    vec3 L = normalize(light.pos - p); // surface to light direction\n    vec3 V = -ray.d; // surface to camera direction\n    vec3 R = reflect(-L, N); // mirror of L by the axis N\n    \n    float dotLN = dot(L, N); // project light direction to surface normal\n    float dotRV = dot(R, V); // project light reflection direction to direction to camera\n    \n    vec3 color = vec3(0.);\n    if (dotLN > 0.) { // we can see the diffuse\n        color += diffuseColor * dotLN;\n    } \n    if (dotRV > 0.) { // we can see the specular\n        color += specularColor * pow(dotRV, shininess);\n    }\n    color *= light.color; // influence of color of the light\n#if SHADOWS\n    float dif = clamp(dotLN*.5+0.5,0.,1.);\n    vec3 n = estimateNormal(p);\n    Ray shadow;\n    shadow.o = p+n*EPSILON;\n    shadow.d = L; \n    float d = getSDF(shadow).x;\n    if (d<length(light.pos-p)) color *=.1;\n#endif\n\n    return color;\n}\n\n\nvec3 calcMaterial (float id) {\n    if (id == DARK_ID)      return vec3(.1, .1, .1);\n    if (id == CLOTH_ID)     return vec3(61., 74., 37.)/256.;\n    if (id == SKIN_ID)     return vec3(0.764,0.6,0.552);\n    if (id == WHITE_ID)     return vec3(1.);\n    if (id == GROUND_ID)     return vec3(.4);\n    return vec3(.2);\n}\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // convert from fragCoord (0.0 -> iResolution.xy) to uv (0.0 -> 1.0)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 m  = iMouse.xy/iResolution.xy;\n    vec3 circleMovement = vec3(600. * cos(iTime * 2.), 600. * cos(iTime * 2.), 600. * sin(iTime * 2.)); // to get circle movement\n    \n    // set camera\n    Camera cam;\n    cam.sensorSize = iResolution.xy; // set sensor size to the screenSize\n    cam.focal = 400.; // set the focal length (distance between sensor (screen) to the aperture\n    cam.lookAt = vec3(0., 1., 0.); // where to look at (this camera use two point system)\n    cam.pos = vec3(0,4,-4.2);//circleMovement; // the position of the camera#if CAM_ROTATION\n#if CAM_ROTATION\n    cam.pos = vec3 (sin(time*.1)*8.,7.+sin(time*.05)*4.,cos(time*.1)*8.);\n#endif\n#if MOUSE_CAM_ROT\n    cam.pos.yz *= rotMat(m.y*3.14);\n    cam.pos.xz *= rotMat(-m.x*6.2831);\n#endif\n    // get ray\n    Ray ray = getRay(cam, uv); // get corresponding ray, given the uv\n\n    \n    // render\n    float dist = getSDF(ray).x;\n    float colID = getSDF(ray).y;\n\n\n    if (dist > MAX_DISTANCE - EPSILON) { // don't hit anything, set to background\n        fragColor = vec4(vec3(.7,.8,1.),1);\n        return; // or discard?\n    }\n    \n    vec3 ambientColor = vec3(0.1);\n    vec3 diffuseColor = calcMaterial(colID);\n    vec3 specularColor = vec3(1.0, 1.0, 1.0);\n    float shininess = 50.0;\n    \n    Light light1;\n    light1.pos = vec3(0,4,-5);\n    light1.color = vec3(1);\n    \n    // Light light2;\n    // light2.pos = vec3(4,4,4);\n    // light2.color = vec3(1);\n    \n    vec3 color = vec3(0.);\n    color += ambientLight(ambientColor);\n    color += phongLight(diffuseColor, specularColor, shininess, ray, dist, light1);\n    \n    color = mix(vec3(.7,.8,1.), color, exp(-max(0.,dist-12.)/20.)  );\n    // color += phongLight(diffuseColor, specularColor, shininess, ray, dist, light2);\n    fragColor = vec4(color, 1.);\n}\n\n\n\n\n/* OLD_CODE\n\n#define HEAD_ROTATION 1\n#define CAM_ROTATION 1\n#define MOUSE_CAM_ROT 0\n\n#define time iTime*4.\n\n#define MAX_STEPS 120\n#define MAX_DIST 60.\n#define SURF_DIST 0.001\n\n\n#define DARK_ID 0.\n#define CLOTH1_ID 1.\n#define CLOTH2_ID 1.5\n#define SKIN_ID 2.\n#define WHITE_ID 3.\n#define GROUND_ID 4.\n\n\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (sqrt(5)*0.5 + 0.5)\n\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\nfloat max3 (vec3 v) {\n  return max (max (v.x, v.y), v.z);\n}\n\nmat2 rotMat(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2 (c,-s,s,c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.))+max3(min(p, vec3(0)))-0.02;\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat add (inout vec2 a, vec2 b){\n    a = mix(a,b,step(b.x,a.x));\n    return 0.;\n}\nvec3 opRep( in vec3 p, in vec3 c )\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return q ;\n}\n\nvec2 GetDist (vec3 p){\n    \n    vec3 armSize = vec3 (.2,.4,.2);                           //Arms Size\n    vec3 handSize = vec3 (.2,.2,.13);          \n    vec3 legSize = vec3 (.22,.8,.2);\n    vec3 bodySize = vec3 (.6,1.,.3);\n    vec3 headSize = vec3(.3,.35,.3);\n    vec3 footSize = vec3(.2,.1,.43);\n    vec3 capSize = vec3(.36,.1,.45);\n\n    vec3 pG = p;\n    pG.z += mod(time,4.);                                                //Global Position\n    pG = opRep(pG,vec3(3,0,4));\n    vec3 pB = pG;                                               //Body Position\n    vec3 pH = pG -vec3(0,bodySize.y+headSize.y+0.05,0);         //Head Position\n#if HEAD_ROTATION \n    pH.xz *= rotMat(-sin(time)*.5);                               //Head Rotation\n#endif\n    vec3 pCap = pH - vec3(0,headSize.y+capSize.y-.05,-capSize.z/3.3);                                               \n    vec3 pShouldL = pG - vec3 (-(bodySize.x+armSize.x+0.05),bodySize.y,0);   //Shoulder Position\n    pShouldL.yz *= rotMat(sin(time));                          //Shoulder Rotation    \n    vec3 pArmL = pShouldL + vec3 (0,armSize.y,0);               //Arm Position\n    vec3 pForeL = pShouldL-vec3(0,-2.*armSize.y-0.05,0);                       //Forearm Position\n    pForeL.xz *= rotMat(radians(90.));                           //Forearm Rotation\n    pForeL.yz *= rotMat(clamp(-sin(time)*PI/2.,0.,PI/2.));\n    pForeL += vec3(0,armSize.y,0);                             //Forearm Anchor P reposition\n    vec3 pHandL = pForeL-vec3(0,-armSize.y-handSize.y-0.05,0);\n    pHandL.xz *= rotMat(-1.*clamp(-sin(time)*PI,0.,PI/2.)+PI);    \n    vec3 pLegL = pB - vec3(-.4,-bodySize.y-.05,0);\n    pLegL.yz *= rotMat(-sin(time));\n    pLegL += vec3(0,legSize.y,0);\n    vec3 pFootL = pLegL - vec3(0,-legSize.y-footSize.y-0.05,-footSize.z/2.);\n\n    vec3 pShouldR = pG - vec3(bodySize.x+armSize.x+0.05,bodySize.y,0);\n    pShouldR.yz *= rotMat(-sin(time));\n    vec3 pArmR = pShouldR + vec3 (0,armSize.y,0);;\n    vec3 pForeR = pShouldR-vec3(0,-2.*armSize.y-0.05,0);\n    pForeR.xz *= rotMat(radians(-90.));\n    pForeR.yz *= rotMat(clamp(sin(time)*PI/2.,0.,PI/2.));\n    pForeR += vec3(0,armSize.y,0);\n    vec3 pHandR = pForeR-vec3(0,-armSize.y-handSize.y-0.05,0);\n    pHandR.xz *= rotMat(-1.*clamp(-sin(time)*PI,-PI/2.,0.)+PI);\n    vec3 pLegR = pB - vec3(.4,-bodySize.y-.05,0);\n    pLegR.yz *= rotMat(sin(time));\n    pLegR += vec3(0,legSize.y,0);\n    vec3 pFootR = pLegR - vec3(0,-legSize.y-footSize.y-0.05,-footSize.z/2.);\n\n\n    vec2 body = vec2(sdBox(pB,bodySize),CLOTH1_ID);\n    vec2 head = vec2(sdBox(pH,headSize),SKIN_ID);\n    vec2 cap = vec2(sdBox(pCap,capSize),CLOTH2_ID);                      \n    \n    vec2 armL = vec2(sdBox (pArmL,armSize),CLOTH1_ID); \n    vec2 foreL = vec2(sdBox(pForeL,armSize),CLOTH1_ID);\n    vec2 handL = vec2(sdBox(pHandL,handSize)*.5,WHITE_ID);\n    vec2 legL = vec2(sdBox(pLegL,legSize),CLOTH2_ID);\n    vec2 footL = vec2(sdBox(pFootL,footSize),DARK_ID);\n\n    vec2 armR = vec2(sdBox(pArmR,armSize),CLOTH1_ID);\n    vec2 foreR = vec2(sdBox(pForeR,armSize),CLOTH1_ID);\n    vec2 handR = vec2(sdBox(pHandR,handSize)*.5,WHITE_ID);\n    vec2 legR = vec2(sdBox(pLegR,legSize),CLOTH2_ID);\n    vec2 footR = vec2(sdBox(pFootR,footSize),DARK_ID);\n\n    vec2 floor = vec2(sdPlane(p,vec3(0,1.,0),3.),GROUND_ID);\n    // vec2 floor = vec2(p.y+3,GROUND_ID);\n\n    vec2 result = body;\n    // result = mix(result,head,step(head.x,result.x));\n    // result = mix(result,cap,step(cap))\n    add (result,head);\n    add (result,cap);\n    add (result,armL);\n    add (result,foreL);\n    add (result,handL);\n    add (result,legL);\n    add (result,footL);\n    add (result,armR);\n    add (result,foreR);\n    add (result,handR);\n    add (result,legR);\n    add (result,footR);\n    add (result,floor);\n\n    return result;\n}\n\nvec3 calcMaterial (float id) {\n    if (id == DARK_ID)      return vec3(.1, .1, .1);\n    if (id == CLOTH1_ID)     return vec3(92., 112., 56.)/256.;\n    if (id == CLOTH2_ID)    return vec3(61., 74., 37.)/256.;\n    if (id == SKIN_ID)     return vec3(0.764,0.6,0.552);\n    if (id == WHITE_ID)     return vec3(1.);\n    if (id == GROUND_ID)     return vec3(.4);\n    return vec3(.2);\n}\n\nvec4 RayMarch (vec3 ro, vec3 rd){\n    float dO = 0.;\n    vec3 color;\n\n    for (int i=0; i<MAX_STEPS; i++){\n        vec3 p = ro + rd*dO;\n        float dS = GetDist(p).x;\n        float matID = GetDist(p).y;\n        color = calcMaterial(matID);\n        dO += dS;\n        if (dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n\n    }    \n    \n    return vec4(color,dO);\n}\n\nvec3 GetNormal (vec3 p){\n    vec2 d = GetDist(p);\n    vec2 e = vec2(0.01,0);\n\n    vec3 n = d.x - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat GetLight(vec3 p){\n    vec3 lightPos = vec3 (1.,10.,-10.);\n    //lightPos.xz += vec2(sin(time),cos(time));\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal (p);\n    float dif = clamp(dot(n,l)*.5+0.5,0.,1.);\n    float d = RayMarch(p+n*SURF_DIST*2.,l).w;\n    if (d<length(lightPos-p)) dif *= .1;  //Shadows\n\n    return dif;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1.,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec2 m  = iMouse.xy/iResolution.xy;\n    vec3 col = vec3(0.);        //vec3(0.,.3,.6)*smoothstep(-0.1,1.,length(uv.y));\n\n    vec3 ro = vec3 (0,4,-4.2);\n#if CAM_ROTATION\n    ro = vec3 (sin(time*.1)*8.,7.+sin(time*.05)*4.,cos(time*.1)*8.);\n#endif\n#if MOUSE_CAM_ROT\n    ro.yz *= rotMat(m.y*3.14);\n    ro.xz *= rotMat(-m.x*6.2831);\n#endif\n    vec3 la = vec3(0,0,1.);\n    vec3 rd = R(uv, ro, la,.7);\n\n    float d = RayMarch(ro,rd).w;\n    vec3 c = RayMarch(ro,rd).xyz;\n    if (d<MAX_DIST){\n        vec3 p = ro + rd*d;\n        float difuse = GetLight(p);\n        difuse = pow(difuse,.4545);\n        col= vec3(difuse)*c;\n\n    }\n\n    col = mix(vec3(.8,.9,1.), col, exp(-max(0.,d-12.)/30.)  );  //Thanks to FabriceNeyret2 for the fog!\n    //col = mix(vec3(.8,.9,1.), col, exp(-d/90.)  );\n    fragColor = vec4 (col,1.);\n\n}\n*/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}