{
    "Shader": {
        "info": {
            "date": "1548611945",
            "description": "shader tribute to an ancient DOS game called 'Evasive Maneuvers' (1994), Episode 'Imperial City' (style), http://www.errorwear.com/evasive/, unfinished, arrows to move around ... no gameplay or collisions.",
            "flags": 48,
            "hasliked": 0,
            "id": "Ws23WR",
            "likes": 9,
            "name": "Evasive Maneuvers",
            "published": 3,
            "tags": [
                "shapes",
                "unfinished",
                "keyboard",
                "tribute"
            ],
            "usePreview": 0,
            "username": "movAX13h",
            "viewed": 551
        },
        "renderpass": [
            {
                "code": "// 'Evasive Maneuvers', tribute, fragment shader by movAX13h, May 2015\n// http://www.errorwear.com/evasive/\n\n#define pillarWidth 0.02\n#define pillarRandomness 0.0012\n\n\n// globals\nvec3 color = vec3(0.0);\nvec2 uv,puv;\n\nfloat time;\nfloat timeBackground;\n\n\nvec3 rand(in float x)\n{\n    return texture(iChannel1, vec2(x, x), -100.0).rgb;\n}\n\nvoid back()\n{\n    float v = floor(uv.y * 50.0)/20.0;\n    color = mix(vec3(1.0, 0.0, 0.0), color, v);\n}\n\nvoid cityscape()\n{\n    vec2 p = puv;\n    p.x += timeBackground;\n    \n\tfloat bridge = abs(0.05*sin(20.0*p.x)+0.1*sin(4.0*p.x));\n    if (bridge < 0.125)\n    {\n        float id = floor(p.x / pillarWidth);\n        vec3 r = rand(pillarRandomness*id);\n        float d = 2.0 * (p.x + 0.01*(r.y-0.5) - id * pillarWidth) / pillarWidth - 1.0;\n        float a = 0.4*r.x + 0.1;\n        float b = 0.4*rand(pillarRandomness*(id-1.0)).x + 0.1;\n        if (p.y + 0.008*abs(d) < a) \n        {\n            float c = 0.4*rand(pillarRandomness*(id+1.0)).x + 0.1;\n            if (a > b) \n            {\n                color = vec3(0.42);\n                if (d > 0.0 && a > c) color -= 0.1;\n            }        \n            else color = vec3(0.3);\n            if (d > 0.0 && p.y + 0.1*r.z < a) color -= vec3(0.04);\n        }\n    }\n    \n    if (bridge > 0.11 - 0.03*abs(sin(30.0*p.x))) \n        color = mix(color, vec3(0.29), step(abs(p.y - 0.2 + bridge), 0.006+0.003*sin(4.0*p.x)));  \n}\n\nfloat box(vec2 p, float b)\n{\n  //return length(max(abs(p)-b,0.0));\n   return max(abs(p.x), abs(p.y)) - b;\n}\n\nvoid obstacles()\n{\n    if (uv.y > 0.269) return;\n    \n    // domain, cycles, hashes\n    vec2 p = puv;\n    p.x += time;\n    \n    float island = floor(p.x / 2.0);\n    float track = floor(uv.y / 0.09);\n    \n    vec3 r = rand(0.0033*track + 0.2713*island);\n    \n    p.x -= 0.8*r.x+0.1;\n    p.y = mod(p.y-0.18, 0.09)-0.045;\n    \n    float period = mod(p.x, 2.0);\n    if (period > 1.0) return;\n    float pCenter = abs(2.0*min(1.0, period) - 1.0);\n    \n    // pipes\n    float scale = 1.0;\n    float pos = 0.0;\n\n\tscale -= 0.51*step(abs(mod(puv.x+time-0.9, 2.0)), 0.16); // connector\n    if (scale > 0.9) \n    {\n        scale += 5.0*step(0.92, pCenter);\n        scale += 0.5*min(step(0.836, pCenter), step(pCenter, 0.85));\n        scale += 0.5*min(step(0.815, pCenter), step(pCenter, 0.828));\n        scale += 0.5*min(step(0.795, pCenter), step(pCenter, 0.806));\n        p.y -= 0.023;\n    }\n    \n    float spos = pos * scale;\n    p.y *= scale;\n\tp.y -= spos;\n    float d = abs(p.y);\n    if (d < 0.023) \n    {\n        float a = abs(p.y - 0.006)/0.023;\n        color = vec3(0.2+0.4*abs(cos(1.8*a))) - step(1.1, scale)*0.1;\n    }\n}\n\nvoid items()\n{\n    // boxes + fueltank\n    vec2 q = vec2(mod(puv.x+time+0.1, 2.0)-0.9, uv.y-0.247);\n    \n    float d = max(abs(q.x), abs(q.y)) - 0.026;\n    if (d <= 0.0)\n    {\n        float f = 0.4 + 0.6*smoothstep(0.0, 0.01, length(q-vec2(0.12, -0.12))-0.168);\n        //color = f*vec3(0.6);\n   \t\tcolor = mix(f*vec3(0.6), vec3(0.45), smoothstep(0.0, -0.008, d)*step(d, 0.0));\n    }\n    \n}\n\n\nfloat dir(vec2 a, vec2 b, vec2 c)\n{\n\treturn (a.x - c.x) * (b.y - c.y) - (b.x - c.x) * (a.y - c.y);\n}\n\nbool insideTri(vec2 p, vec2 a, vec2 b, vec2 c)\n{\n\tbool b1 = dir(p, a, b) < 0.0;\n\tbool b2 = dir(p, b, c) < 0.0;\n\tbool b3 = dir(p, c, a) < 0.0;\n  \treturn ((b1 == b2) && (b2 == b3));\n}\n\nvoid ship(vec2 pos)\n{\n    vec2 p = puv - pos;\n    float d;\n    \n    // top\n    if (insideTri(p, vec2(0.02, 0.016), vec2(0.04, 0.035), vec2(0.0, 0.035)) ||\n    \tinsideTri(p, vec2(0.02, 0.016), vec2(0.07, 0.016), vec2(0.04, 0.035)))\n    {\n        d = length(p-vec2(0.08, 0.15)) - 0.1;\n        color = mix(vec3(0.7), vec3(0.3), smoothstep(0.09, 0.0, d));\n        color = mix(sin(1.0+p.x*34.0)*vec3(0.6, 0.0, 0.0), color, step(0.001, p.y-0.018));\n    }\n    \n    // body\n   \tif (insideTri(p, vec2(0.03, 0.002), vec2(0.14, 0.016), vec2(0.02, 0.016)) ||\n    \tinsideTri(p, vec2(0.03, 0.002), vec2(0.18, 0.002), vec2(0.14, 0.016)))\n    {\n        d = length(p-vec2(0.1, 0.19)) - 0.14;\n        color = mix(vec3(0.7), vec3(0.3), smoothstep(0.09, 0.0, d));\n        \n    }\n    \n    // bottom\n    if (insideTri(p, vec2(0.03, 0.002), vec2(0.12, 0.002), vec2(0.118, -0.006)) ||\n    \tinsideTri(p, vec2(0.03, 0.002), vec2(0.118, -0.006), vec2(0.01, -0.024)))\n    {\n        d = length(p-vec2(0.04, 0.04)) - 0.01;\n        color = mix(vec3(0.3), vec3(0.7), smoothstep(0.1, 0.0, d));\n        color = mix(sin(0.6+p.x*24.0)*vec3(0.6, 0.0, 0.0), color, step(p.y+0.003, 0.001));\n    }\n    \n    // todo: engine fire, bullets & bombs\n}\n\nvoid debug()\n{\n    vec4 state = texture(iChannel1, vec2(0.0));\n    //if (state.x > 0.0) \n        color = state.xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = 0.2*iTime;\n    timeBackground = 0.1*iTime;\n    \n\tuv = fragCoord / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    puv = uv;\n    //if (iMouse.z > 0.5) puv = ceil(uv * 320.0) / 320.0;\n    \n\tback();\n    cityscape();\n    obstacles();\n    \n    vec4 shipInfo = texture(iChannel0, vec2(0.0));\n    ship(vec2(0.2, 0.5)-shipInfo.xy);\n    \n    items();\n    // ui();\n    \n    //debug();\n\n\n    \n\tcolor = clamp(color, vec3(0.0), vec3(1.0));\n\t//color = pow(color, vec3(2.2, 2.4, 2.5)) * 3.5;\n\t//color = pow(color, vec3(1.0 / 2.2));    \n\t//color -= smoothstep(0.4, 1.8, abs(uv.x));\n    //color *= 1.0 - 0.2*rand(uv);    \n    \n\tfragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float KEY_A     = 65.5/256.0;\nconst float KEY_B     = 66.5/256.0;\nconst float KEY_C     = 67.5/256.0;\nconst float KEY_D     = 68.5/256.0;\nconst float KEY_E     = 69.5/256.0;\nconst float KEY_F     = 70.5/256.0;\nconst float KEY_G     = 71.5/256.0;\nconst float KEY_H     = 72.5/256.0;\nconst float KEY_I     = 73.5/256.0;\nconst float KEY_J     = 74.5/256.0;\nconst float KEY_K     = 75.5/256.0;\nconst float KEY_L     = 76.5/256.0;\nconst float KEY_M     = 77.5/256.0;\nconst float KEY_N     = 78.5/256.0;\nconst float KEY_O     = 79.5/256.0;\nconst float KEY_P     = 80.5/256.0;\nconst float KEY_Q     = 81.5/256.0;\nconst float KEY_R     = 82.5/256.0;\nconst float KEY_S     = 83.5/256.0;\nconst float KEY_T     = 84.5/256.0;\nconst float KEY_U     = 85.5/256.0;\nconst float KEY_V     = 86.5/256.0;\nconst float KEY_W     = 87.5/256.0;\nconst float KEY_X     = 88.5/256.0;\nconst float KEY_Y     = 89.5/256.0;\nconst float KEY_Z     = 90.5/256.0;\n\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\nconst float KEY_SP    = 32.5/256.0;\n\nconst float MOVE_SPEED = 1.0;\n//const float BULLET_SPEED = 2.0;\n\nbool isKeyPressed(float key)\n{\n\treturn texture(iChannel3, vec2(key, 0.5/3.0) ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 col = vec4(0.0);\n    \n    if (fragCoord.x < 1.0) \n    {\n        col = texture(iChannel0, uv);\n        \n        if (fragCoord.y < 1.0)\n        {\n            vec2 fwd = MOVE_SPEED * iTimeDelta * vec2(sin(col.a), cos(col.a));\n\n            float d = MOVE_SPEED * iTimeDelta;\n\n            if (isKeyPressed(KEY_LEFT)) col.x += d;\n            if (isKeyPressed(KEY_RIGHT)) col.x -= d;\n\n            if (isKeyPressed(KEY_UP)) col.y -= d;\n            if (isKeyPressed(KEY_DOWN)) col.y += d;\n            \n            if (isKeyPressed(KEY_SP)) col.a += 1.0;\n        }\n        else if (fragCoord.y < 51.0)\n        {\n            if (col.a > 0.0) // is active\n            {\n                //col.x += BULLET_SPEED * iTimeDelta;\n                //if (col.x > iResolution.x) col = vec4(0.0);\n            }\n        }\n    }\n    \n    \n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}