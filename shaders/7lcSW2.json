{
    "Shader": {
        "info": {
            "date": "1640525025",
            "description": "Jump nyancat!",
            "flags": 0,
            "hasliked": 0,
            "id": "7lcSW2",
            "likes": 7,
            "name": "Jump nyancat!",
            "published": 3,
            "tags": [
                "2d",
                "spiral",
                "mobius",
                "nyancat",
                "complex"
            ],
            "usePreview": 0,
            "username": "cyperus",
            "viewed": 494
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"Jump nyancat!\" Colling Patrik, cyperus, 2021\n//\n// DESCRIPTION:\n// - cyclic nyancat jump & run        \n// - transformations: moebius, riemannsphere, logspiral\n//\n// CONTROLS:\n//   <mouse>: subdivide & twist spiral branch\n//\n// BASED on:\n//   by FabriceNeyret2\n//    - https://www.shadertoy.com/view/fldSWS \"Logarithmic Moebius color arrows\"\n//   by mla \n//    - https://www.shadertoy.com/view/7t3SDB \"Spiral Weave\" \n//   by mrharicot\n//    - https://www.shadertoy.com/view/XdfGDH \"Gaussian Blur\"\n//       \n////////////////////////////////////////////////////////////////////////////////\n\n// transformation stack (comment in out)\n#define SSS          // SelfSimilarStructure\n#define MOEBIUS\n#define MOEBIUS_RS   // RiemannSphere\n#define LOGSPIRAL\n\n// texture stack (comment in out)\n#define TEX_NYANCAT\n#define TEX_STRIPS\n#define TEX_BACKGROUND\n\n// gizmo\nconst float gizmo_subdiv = 10.;\nvec2 gizmo_polar_tile_id(in vec2 p) {\n        p = (p.xy-.5*iResolution.xy)/iResolution.x;\n        p = vec2(length(p),atan(p.y,p.x));\n        p *= 2. * gizmo_subdiv * vec2(1.,1./PI2); // subdiv scale\n        p = floor(p);                             // subdiv\n        p.x += p.x >= 0.?1.:0.;                   // radius avoid zero.\n        return p;\n}\n\n// texture\nfloat normpdf(in float x, in float sigma) {\n    // https://www.shadertoy.com/view/XdfGDH by mrharicot\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvec3 gaussianblur(sampler2D iChannel, vec2 fragCoord, float R) {\n    // https://www.shadertoy.com/view/XdfGDH by mrharicot\n    //declare stuff\n    const int mSize = 6;\n    const int kSize = (mSize-1)/2;\n    float kernel[mSize];\n    vec3 final_colour = vec3(0.0);\n\n    //create the 1-D kernel\n    float sigma = 7.0;\n    float Z = 0.0;\n    for (int j = 0; j <= kSize; ++j) {\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n\n    //get the normalization factor (as the gaussian has been clamped)\n    for (int j = 0; j < mSize; ++j) {\n        Z += kernel[j];\n    }\n\n    //read out the texels\n    for (int i=-kSize; i <= kSize; ++i) {\n        for (int j=-kSize; j <= kSize; ++j) {\n            final_colour += kernel[kSize+j]*kernel[kSize+i]*texture(iChannel, (fragCoord.xy+vec2(float(i),float(j))) / R).rgb;\n\n        }\n    }\t\t\n    return final_colour /= Z*Z;\n}\n\nvec4 nyancat(vec2 z, float scale, vec2 ju, float time) {   \n    z.x = fract(z.x-time/scale); // run, input z.x in [0., 1.], periodic & cyclic in x-direction (0)\n    z.y = fract(z.y);            // periodic in y-direction (comment in out)\n    z *= scale;\n    z.y -= ju.x*abs(cos(PI*ju.y*time));           // jump, amplitude, frequency\n    return ((.05<z.x&&z.x<.9)&&(0.<z.y&&z.y<.65)) // BB rectangle\n    ? texture(iChannel0,\n        vec2(40./256.*(z.x+floor(6.*fract(ju.y*time))),z.y+.2)) // sprite animation loop\n    : vec4(0.);   \n} \n \nvoid mainImage( out vec4 O, in vec2 uv )\n{\n    vec2  sp_k_M0 = vec2(4,2);  // subdivide & twist spiral branch\n    vec2  sp_k_U0;\n    float uc_k = float(4);      // unit-cells periodic in x-direction\n\n    vec2 R = iResolution.xy,\n         M = iMouse.xy,\n         U;\n    vec3 P, C;               // point, color\n    vec4 T;\n    bool M_init = iMouse == vec4(0.);           // mouse init\n    bool M_bd = iMouse.z > 0. && iMouse.w < 0.; // mouse button down\n    \n    float time = 0.5*iTime;  // animation velocity\n    vec2 U0 = 1.6*(uv.xy-.5*R.xy)/R.x; // U normalized in x-direction (0)\n    U = U0;    \n\n    // controls gismo\n    if(!M_init) sp_k_M0 = gizmo_polar_tile_id(M); // mouse coords\n    sp_k_U0 = gizmo_polar_tile_id(uv); // pixel coords\n    \n    // transform complex plain\n    #ifdef SSS\n    U = crpt(2.*U,  PI*0., 2, 0.1); // scale, rotate, power, translate\n    U = crpt(4.*U, -PI*0.02*time, 3, -0.7*cos(0.03*time));\n    # endif\n    \n    #ifdef MOEBIUS\n    U.x += 0.5; U /= dot(U,U); U.x -= 0.5; // inversion\n    U.x -= 0.5;\n    #endif\n    \n    #ifdef MOEBIUS_RS\n    float UU = dot(U,U); P = vec3(2.*U.x,+2.*U.y, -1.+UU)/(1.+UU); // 2D --> 3D stereographic projection   \n    P = rot3(P, normalize(vec3(0.1,1.,0.)), PI*0.05*time);         // rotation of the riemannsphere\n    U = vec2(P.x,P.y)/(1.-P.z);                                    // 3D --> 2D stereographic projection\n    #endif\n    \n    #ifdef LOGSPIRAL\n    U = clog(U)/PI2;               // complex log normalized\n    U = cmul(U,sp_k_M0);           // subdiv spiral branches, twist        \n    U += vec2(0.02, 0.03 )* time;  // move to and rotate around spiralcenter\n    //vec2 sp_id = floor(U);       // index at the branch cut (0,-+PI) not the same!   \n    vec2 sp_id = floor( vec2(-U.y,U.x) - floor(-U.y/sp_k_M0.x) * sp_k_M0 ); \n    # endif\n \n    // paint unitcellgrid\n    O = vec4(0); \n    \n    if (O.a < 1.) {\n        T = (sp_k_M0 == sp_k_U0 && M_bd) ? vec4(vec3(1.), 0.3) : O;\n        T *= T.a; O += (1.-O.a) * T; // alpha pre multiplied ,alpha under        \n    }\n    \n    #ifdef TEX_NYANCAT\n    if (O.a < 1.) {\n        T = nyancat(U, uc_k, vec2(0.1,1.), time);  T.xyz *= T.xyz; // gamma\n        T *= T.a; O += (1.-O.a) * T; // alpha pre multiplied ,alpha under\n    }\n    #endif\n    \n    #ifdef TEX_STRIPS\n    if (O.a < 1.) {\n        // show domains\n        if(M_bd) {\n            T.rgb = h2rgb((sp_id.x + sp_id.y)/4.); T.a = 1.;\n        }\n        // show stripes\n        else {\n            C.x = U.x + cosrec(0.2);                               // hue\n            C.y = 1.-(smoothpulsrec( U.y+0.5, 0.1) * cosrec(U.y)); // saturation\n            C.z = cosrec(uc_k*U.x);                                // value\n            T.rgb = hsv2rgb(C); T.a = C.z;\n        }\n        T.a *= 0.5 ;\n        T *= T.a; O += (1.-O.a) * T; // alpha pre multiplied, alpha under   \n    }\n    #endif\n    \n    // ellipse mask\n    O *= smoothstep(0.6,0., sqrt( dot( vec2(0.5,1.)*U0,U0)));\n\n    #ifdef TEX_BACKGROUND\n    if (O.a < 1.) {\n        T = vec4(gaussianblur(iChannel1, uv, R.x), 0.9);\n        T.xyz = pow(T.xyz,vec3(2.2));// gamma\n        T.xyz = pow(T.xyz,vec3(1.5));\n        T *= T.a; O += (1.-O.a) * T; // alpha pre multiplied, alpha under        \n    }\n    #endif\n    \n    O = vec4(pow(O.rgb, vec3(1./2.2)),1.); // gamma   \n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// constants\nconst float\n    PI = abs(atan(0.,-1.)),\n    PI2 = 2.*PI;\n\n// 1D\nfloat cosrec(float x) {\n    return 0.5*(1.+cos(PI2*x));\n}\n\nfloat smoothpulsrec(float x, float b) {\n    // b : pulswidth\n    x = abs( fract(x )-0.5);  \n    return 1.-smoothstep( 0., 0.5*b ,x ); \n}\n\n// 2D complex functions\nvec2 cmul(vec2 za,vec2 zb) {\n    return za*mat2(zb.x,-zb.y,zb.yx);\n}\n\nvec2 cinv(vec2 z) {\n    return vec2(z.x,-z.y)/dot(z,z);\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n    return cmul(z,cinv(w));\n}\n\nvec2 cpow(vec2 z, int n) {\n    vec2 w = z;\n    for (int i = 1; i < n; i++)\n        w = cmul(w,z);\n    return w;\n}\n\nvec2 crot(vec2 z,float a) {\n    return cmul(z, vec2(cos(-a),sin(-a)));\n}\n\nvec2 clog(vec2 z) // : 1 --> 1 (we use only the visible main branch)\n{\n    return vec2(0.5*log(z.x*z.x+z.y*z.y),atan(z.y,z.x));\n}\n\nvec2 crpt(vec2 z,float a, int n, float x0) {\n\treturn cpow(crot(z, a), n) - vec2(x0, 0.);\n}\n\n// 3D\nvec3 rot3(vec3 P, vec3 A, float a) {\n    return mix( A*dot(P,A), P, cos(a) ) + sin(a)*cross(P,A);\n}\n\n// color\nvec3 h2rgb(float h) {\n    return vec3(.6*(1.+cos(PI2*(h+vec3(0,1,2)/3.))));\n}\n\nvec3 hsv2rgb(vec3 C ) {\n    // C.x in [0.+k, 1.+k] : hue\n    // C.y in [0.,1.]      : saturation\n    // C.z in [0.,1.]      : value\n    return mix(vec3(1.), h2rgb(C.x), C.y) * C.z;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}