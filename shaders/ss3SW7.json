{
    "Shader": {
        "info": {
            "date": "1633307779",
            "description": "A decent raymarcher with some tradeoffs for performance.",
            "flags": 0,
            "hasliked": 0,
            "id": "ss3SW7",
            "likes": 4,
            "name": "Fast Raymarching w/ Reflections",
            "published": 3,
            "tags": [
                "3d",
                "reflection",
                "primitives",
                "raymarcher"
            ],
            "usePreview": 0,
            "username": "N8Shader",
            "viewed": 547
        },
        "renderpass": [
            {
                "code": "\n float sdSphere(vec3 p, vec3 c, float r) {\n        return length(p - c) - r;\n    }\n    float sdDiamond(vec3 p, vec3 c, float r) {\n        vec3 cVector = abs(p - c);\n        return (cVector.x + cVector.y + cVector.z) - r;\n    }\n    float sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}  \nfloat sdTorus( vec3 p, vec3 c, vec2 t )\n{\n  p = p - c;\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sdBox( vec3 p, vec3 c, vec3 b )\n{\n  p = p - c;\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCone( vec3 p, vec3 center, vec2 c, float h )\n{\n    p = p - center;\n  float q = length(p.xz);\n  return max(dot(c.xy,vec2(q,p.y)),-h-p.y);\n}\nfloat sdBoxFrame( vec3 p, vec3 c, vec3 b, float e )\n{\n    p = p - c;\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat random(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 uv)\n{\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    f = f * f * (3. - 2. * f);\n    \n    float lb = random(i + vec2(0., 0.));\n    float rb = random(i + vec2(1., 0.));\n    float lt = random(i + vec2(0., 1.));\n    float rt = random(i + vec2(1., 1.));\n    \n    return mix(mix(lb, rb, f.x), \n               mix(lt, rt, f.x), f.y);\n}\n\n#define OCTAVES 8\nfloat fbm(vec2 uv)\n{\n    float value = 0.;\n    float amplitude = .5;\n    \n    for (int i = 0; i < OCTAVES; i++)\n    {\n        value += noise(uv) * amplitude;\n        \n        amplitude *= .5;\n        \n        uv *= 2.;\n    }\n    \n    return value;\n}\n\nvec3 Sky(vec3 ro, vec3 rd)\n{\n    const float SC = 1e5;\n\n \t// Calculate sky plane\n    float dist = (SC - ro.y) / rd.y; \n    vec2 p = (ro + dist * rd).xz;\n    p *= 1.2 / SC;\n    \n    // from iq's shader, https://www.shadertoy.com/view/MdX3Rr\n    vec3 lightDir = normalize(vec3(-.8, .15, -.3));\n    float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n    \n    vec3 cloudCol = vec3(1.);\n    //vec3 skyCol = vec3(.6, .71, .85) - rd.y * .2 * vec3(1., .5, 1.) + .15 * .5;\n    vec3 skyCol = vec3(0.3,0.5,0.85) - rd.y*rd.y*0.5;\n    skyCol = mix( skyCol, 0.85 * vec3(0.7,0.75,0.85), pow( 1.0 - max(rd.y, 0.0), 4.0 ) );\n    \n    // sun\n    vec3 sun = 0.25 * vec3(1.0,0.7,0.4) * pow( sundot,5.0 );\n    sun += 0.25 * vec3(1.0,0.8,0.6) * pow( sundot,64.0 );\n    sun += 0.2 * vec3(1.0,0.8,0.6) * pow( sundot,512.0 );\n    skyCol += sun;\n    \n    // clouds\n    float t = iTime * 0.1;\n    float den = fbm(vec2(p.x - t, p.y - t));\n    skyCol = mix( skyCol, cloudCol, smoothstep(.4, .8, den));\n    \n    // horizon\n    skyCol = mix( skyCol,  vec3(0.45, 0.55, 0.75), pow( 1.0 - max(rd.y, 0.0), 16.0 ) );\n    \n    return skyCol;\n}\nstruct Shifter {\n    vec3 position;\n    vec3 color;\n    float timeOffset;\n};\nShifter[9] shifters = Shifter[9](\n    Shifter(vec3(0.0, 0.0, 0.0), vec3(1.25, 0.0, 0.0), 0.0),\n    Shifter(vec3(5.0, 0.0, 0.0), vec3(0.0, 0.0, 1.25), 3.0),\n    Shifter(vec3(-5.0, 0.0, 0.0), vec3(0.0, 1.25, 0.0), 6.0),\n    Shifter(vec3(0.0, 0.0, -5.0), vec3(1.25, 1.25, 0.0), 1.0),\n    Shifter(vec3(5.0, 0.0, -5.0), vec3(0.0, 1.25, 1.25), 2.0),\n    Shifter(vec3(-5.0, 0.0, -5.0), vec3(1.25, 0.0, 1.25), 4.0),\n    Shifter(vec3(0.0, 0.0, 5.0), vec3(1.25, 0.65, 0.0), 5.0),\n    Shifter(vec3(5.0, 0.0, 5.0), vec3(0.0, 0.65, 1.25), 2.5),\n    Shifter(vec3(-5.0, 0.0, 5.0), vec3(0.0, 1.25, 0.65), 3.5)\n);\n    vec4 scene_dist(vec3 p) {\n        float obj_dist = 10000.0;\n        vec3 obj_color = vec3(1.0);\n        int s = 0;\n        float minDist = 10000.0;\n        for(int r= 0; r < shifters.length(); r++) {\n            float dist = length(p - shifters[r].position); \n            if (dist < minDist) {\n                s = r;\n                minDist = dist;\n            }\n        }\n        //for(int s = 0; s <= shifters.length(); s++) {\n        float s_dist = 0.0;\n        /*if (length(p - shifters[s].position) > 5.0) {\n            continue;\n        }*/\n        //float boxDist = length(shifters[s].position - p); //sdBox(p, shifters[s].position, vec3(1.0, 1.0, 1.0));\n        //if (boxDist > obj_dist) {\n            //continue;\n        //}\n       /*if (sdDiamond(p, shifters[s].position, 2.5) > obj_dist) {\n            continue;\n        }*/\n        /*if (time_period < 3.14 * 2.0) {\n            obj_dist = mix(sdBox(p, vec3(0.0, ((sin(time / 1000.0) + 1.0) / 2.0), 0.0), vec3(1.0, 1.0, 1.0)), sdTorus(p, vec3(0.0, (sin(time / 1000.0)), 0.0) + 0.05, vec2(1.0, 0.1)), (sin(time / 1000.0) + 1.0) / 2.0);\n        } else if (time_period < 3.14 * 4.0) {\n            obj_dist = mix(sdBox(p, vec3(0.0, ((sin(time / 1000.0) + 1.0) / 2.0), 0.0), vec3(1.0, 1.0, 1.0)), sdSphere(p, vec3(0.0, ((sin(time / 1000.0) + 1.0) / 2.0), 0.0), 1.0), (sin(time / 1000.0) + 1.0) / 2.0);\n        }*/\n        float time_period = mod(iTime + shifters[s].timeOffset, 5.0);\n        if (time_period <= 1.0) {\n            s_dist = mix(sdBoxFrame(p, shifters[s].position, vec3(0.9, 0.9, 0.9), 0.25), sdTorus(p, shifters[s].position, vec2(1.0, 0.2)), time_period);\n        } else if (time_period <= 2.0) {\n            s_dist = mix(sdTorus(p, shifters[s].position, vec2(1.0, 0.2)), sdSphere(p, shifters[s].position, 1.0), time_period - 1.0);\n        } else if (time_period <= 3.0) {\n            s_dist = mix(sdSphere(p, shifters[s].position, 1.0), sdCone(p, shifters[s].position, vec2(0.5, 0.5), 1.0), time_period - 2.0);\n        } else if (time_period <= 4.0) {\n            s_dist = mix(sdCone(p, shifters[s].position, vec2(0.5, 0.5), 1.0),  sdBox(p, shifters[s].position, vec3(0.9, 0.9, 0.9)), time_period - 3.0);\n        } else if (time_period <= 5.0) {\n            s_dist = mix(sdBox(p, shifters[s].position, vec3(0.9, 0.9, 0.9)),sdBoxFrame(p, shifters[s].position, vec3(0.9, 0.9, 0.9), 0.25), time_period - 4.0);\n        }\n       //s_dist = sdSphere(p, shifters[s].position, 1.0);\n            obj_dist = s_dist;\n            obj_color =  shifters[s].color;\n    //}\n        float ground_dist = sdBox(p, vec3(0.0, -1.0, 0.0), vec3(9.5, 0.0, 9.5));\n        vec3 color;\n        if (ground_dist < obj_dist) {\n            color = vec3(0.75);\n            if (mod(round(p.x), 2.0) == mod(round(p.z), 2.0)) {\n                color = vec3(0.1);\n            }\n        } else {\n            color = obj_color;\n        }\n        return vec4(min(ground_dist, obj_dist), color);\n    }\n    vec3 calculate_normal(vec3 p) {\n        const vec3 step = vec3(0.001, 0.0, 0.0);\n        float gradX = scene_dist(p + step.xyy).x - scene_dist(p - step.xyy).x;\n        float gradY = scene_dist(p + step.yxy).x - scene_dist(p - step.yxy).x;\n        float gradZ = scene_dist(p + step.yyx).x - scene_dist(p - step.yyx).x;\n        return normalize(vec3(gradX, gradY, gradZ));\n    }\n    bool ray_march_hit(vec3 rayOrigin, vec3 rayDir) {\n        float distanceTravelled = 0.0;\n        const int NUMBER_OF_STEPS = 32;\n        const float MINIMUM_HIT_DISTANCE = 0.001;\n        const float MAXIMUM_TRACE_DISTANCE = 1000.0;\n        for(int i = 0; i < NUMBER_OF_STEPS; i++) {\n            vec3 currPos = rayOrigin + distanceTravelled * rayDir;\n            float sceneDist = scene_dist(currPos).x;\n            if (sceneDist < MINIMUM_HIT_DISTANCE) {\n                return true;\n            }\n            if (sceneDist > MAXIMUM_TRACE_DISTANCE) {\n                break;\n            }\n            distanceTravelled += sceneDist;\n        }\n        return false;\n    }\n    vec3 ray_march_diffuse(vec3 rayOrigin, vec3 rayDir, vec3 diffuse) {\n        float distanceTravelled = 0.0;\n        const int NUMBER_OF_STEPS = 64;\n        const float MINIMUM_HIT_DISTANCE = 0.001;\n        const float MAXIMUM_TRACE_DISTANCE = 1000.0;\n        const int BOUNCE_AMOUNTS = 3;\n        vec3 finalDiffuse = diffuse;\n        bool done = false;\n        for(int r = 0; r < BOUNCE_AMOUNTS; r++) {\n            if (done) {\n                break;\n            }\n            for(int i = 0; i < NUMBER_OF_STEPS; i++) {\n                vec3 currPos = rayOrigin + distanceTravelled * rayDir;\n                vec4 sceneData = scene_dist(currPos);\n                float sceneDist = sceneData.x;\n                vec3 sceneDiffuse = sceneData.yzw;\n                if (sceneDist < MINIMUM_HIT_DISTANCE) {\n                    float addWeight = pow(0.5, float(r + 1));\n                    finalDiffuse = (1.0 - addWeight) * finalDiffuse + addWeight * sceneDiffuse;\n                    vec3 normal = calculate_normal(currPos);\n                    rayOrigin = currPos;\n                    rayDir = reflect(rayDir, normal);\n                    break;\n                }\n                if (sceneDist > MAXIMUM_TRACE_DISTANCE) {\n                    done = true;\n                    break;\n                }\n                distanceTravelled += sceneDist;\n            }\n        }\n        finalDiffuse = 0.6 * Sky(rayOrigin, rayDir) + 0.4 * finalDiffuse;\n        return finalDiffuse;\n    }\n    vec3 ray_march(vec3 rayOrigin, vec3 rayDir) {\n        float distanceTravelled = 0.0;\n        const int NUMBER_OF_STEPS = 2048;\n        const float MINIMUM_HIT_DISTANCE = 0.001;\n        const float MAXIMUM_TRACE_DISTANCE = 1000.0;\n        for(int i = 0; i < NUMBER_OF_STEPS; i++) {\n            vec3 currPos = rayOrigin + distanceTravelled * rayDir;\n            vec4 sceneData = scene_dist(currPos);\n            float sceneDist = sceneData.x;\n            vec3 sceneDiffuse = sceneData.yzw;\n            if (sceneDist < MINIMUM_HIT_DISTANCE) {\n                vec3 normal = calculate_normal(currPos);\n                vec3 lightPos = vec3(200.0, -500.0, 150.0);\n                vec3 dirToLight = normalize(currPos - lightPos);\n                float lightIntensity = max(0.2, dot(normal, dirToLight));\n                vec3 reflectDir = reflect(rayDir, normal);\n                sceneDiffuse = ray_march_diffuse(currPos + reflectDir * 0.002, reflectDir, sceneDiffuse);\n                if (ray_march_hit(currPos + dirToLight * 0.01, dirToLight)) {\n                    lightIntensity = 0.15;\n                }\n                return ((sceneDiffuse) / 2.0) * lightIntensity + 0.2 * vec3(1.0, 1.0, 1.0);\n            }\n            if (sceneDist > MAXIMUM_TRACE_DISTANCE) {\n                break;\n            }\n            distanceTravelled += sceneDist;\n        }\n        return Sky(rayOrigin, rayDir);\n        \n    }\n    mat4 makeViewMatrix(vec3 eye, vec3 center, vec3 up) {\n        vec3 f = normalize(center - eye);\n        vec3 s = normalize(cross(f, up));\n        vec3 u = cross(s, f);\n        return mat4(\n            vec4(s, 0.0),\n            vec4(u, 0.0),\n            vec4(-f, 0.0),\n            vec4(0.0, 0.0, 0.0, 1)\n        );\n    }\n    vec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n        vec2 xy = fragCoord - size / 2.0;\n        float z = size.y / tan(radians(fieldOfView) / 2.0);\n        return normalize(vec3(xy, -z));\n    }\n    void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n        vec3 viewDir = rayDirection(75.0, iResolution.xy, gl_FragCoord.xy);\n    vec3 eye =vec3(15.0 * sin(iTime), 7.5 + cos(iTime) * 5.0, 15.0 * cos(iTime));\n    \n    mat4 viewToWorld = makeViewMatrix(vec3(15.0 * sin(iTime), 7.5 + cos(iTime) * 5.0, 15.0 * cos(iTime)), vec3(0.0), vec3(0.0, 1.0, 0.0));\n   \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz; \n    vec3 shaded_color = ray_march(eye, worldDir);\n        fragColor = vec4(shaded_color, 1.0);\n    }",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}