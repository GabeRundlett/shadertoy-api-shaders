{
    "Shader": {
        "info": {
            "date": "1650015945",
            "description": "origin: \n @reinder\nMy study project;",
            "flags": 32,
            "hasliked": 0,
            "id": "Nl2cDz",
            "likes": 8,
            "name": "PathTracing Test",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "gi",
                "global",
                "pathtracing",
                "montecarlo"
            ],
            "usePreview": 0,
            "username": "73begonia",
            "viewed": 505
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    fragColor = vec4(color, 1.0f);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define LIGHTCOLOR vec3(16.86, 10.76, 8.2)*0.3\n#define WHITECOLOR vec3(.7295, .7355, .729)*0.7\n#define GREENCOLOR vec3(.117, .4125, .115)*0.7\n#define REDCOLOR vec3(.611, .0555, .062)*0.7\n\nconst float eps = 0.0001;\nvec4 lightSphere = vec4(0.);\n\nfloat hash1(inout float seed) {\n    return fract(sin(seed += 0.1)*43758.5453123);\n}\n\nvec3 randomVec3(inout float seed)\n{\n    vec3 d;\n    do\n    {\n        d = 2.0f * vec3(hash1(seed), hash1(seed), hash1(seed)) - vec3(1, 1, 1);\n    } while (dot(d, d) > 1.0);\n    return normalize(d);\n}\n\nvec3 randomDirection(vec3 n, inout float seed)\n{\n  return normalize(randomVec3(seed) + n);\n}\n\nstruct Ray\n{\n  vec3 ro;\n  vec3 rd;\n};\n\nstruct Material\n{\n  vec3 normal;\n  vec3 color;\n  vec3 emissive;\n  float specularRate;\n  float roughness;\n};\n\nstruct HitResult\n{\n  bool isHit;\n  float distance;\n  vec3 hitPoint;\n  vec3 viewDir;\n  Material material;\n};\n\nvec3 nSphere( in vec3 pos, in vec4 sph ) {\n    return (pos-sph.xyz)/sph.w;\n}\n\nfloat iSphere(vec3 ro, vec3 rd, vec4 sph)\n{\n  vec3 oc = ro - sph.xyz;\n  float b = dot(oc, rd);\n  float c = dot(oc, oc) - sph.w * sph.w;\n  float h = b * b - c;\n  if (h < 0.0) return -1.0;\n\n  float s = sqrt(h);\n  float t1 = -b - s;\n  float t2 = -b + s;\n\n  return t1 < 0.0 ? t2 : t1;\n}\n\nvec3 nPlane( in vec3 ro, in vec4 obj ) {\n  return obj.xyz;\n}\n\nfloat iPlane( vec3 ro, vec3 rd, in vec4 pla ) {\n  return (-pla.w - dot(pla.xyz,ro)) / dot( pla.xyz, rd );\n}\n\nHitResult intersect( in vec3 ro, in vec3 rd) {\n  float mint = 1e20;\n  float t = -1.;\n  vec3 normal = vec3(0.);\n\n  HitResult result;\n\t\n  t = iPlane( ro, rd, vec4( 0.0, 1.0, 0.0,0.0 ) ); \n  if( t>eps && t<mint ) \n      { mint = t; normal = vec3( 0., 1., 0.); result.material.color = WHITECOLOR;}\n      \n  t = iPlane( ro, rd, vec4( 0.0, 0.0,-1.0,8.0 ) ); \n  if( t>eps && t<mint ) \n      { mint = t; normal = vec3( 0., 0.,-1.); result.material.color = WHITECOLOR;}\n      \n  t = iPlane( ro, rd, vec4( 1.0, 0.0, 0.0,0.0 ) ); \n  if( t>eps && t<mint ) \n      { mint = t; normal = vec3( 1., 0., 0.); result.material.color = GREENCOLOR;}\n      \n  t = iPlane( ro, rd, vec4( 0.0,-1.0, 0.0,5.49) ); \n  if( t>eps && t<mint ) \n      { mint = t; normal = vec3( 0., -1., 0.); result.material.color = WHITECOLOR;}\n      \n  t = iPlane( ro, rd, vec4(-1.0, 0.0, 0.0,5.59) ); \n  if( t>eps && t<mint ) \n      { mint = t; normal = vec3( -1., 0., 0.); result.material.color = REDCOLOR;}\n\n  t = iSphere( ro, rd, vec4( 1.5,1.0, 2.7, 1.0) ); \n  if( t>eps && t<mint ) \n  { \n    mint = t; \n    normal = nSphere( ro+mint*rd, vec4( 1.5,1.0, 2.7,1.0) ); \n    result.material.color = WHITECOLOR;\n    result.material.specularRate = 0.8;\n    result.material.roughness = 0.1;\n  }\n  \n  t = iSphere( ro, rd, vec4( 4.0,1.0, 4.0, 1.0) ); \n  if( t>eps && t<mint ) \n  { \n    mint = t;\n    normal = nSphere( ro+mint*rd, vec4( 4.0,1.0, 4.0,1.0) ); \n    result.material.color = GREENCOLOR;\n    result.material.specularRate = 0.3;\n    result.material.roughness = 1.0;\n  }\n  \n  t = iSphere( ro, rd, lightSphere ); \n  if( t>eps && t<mint ) \n  { \n    mint = t;  \n    normal = nSphere( ro+mint*rd, lightSphere ); \n    result.material.color = LIGHTCOLOR; \n    result.material.emissive = vec3(1., 0.894, 0.768) * 20.;\n  }\n\t\t\t\t\t  \n  result.isHit = mint > eps && mint < 1e20 ? true : false;\n  \n  if(result.isHit)\n  {\n    result.distance = mint;\n    result.hitPoint = ro + rd * mint;\n    result.material.normal = normal;\n  }\n\n  return result;\t\t\t\t\t  \n}\n\nvec3 PathTracing(vec3 ro, vec3 rd, inout float seed)\n{\n  vec3 tcol = vec3(0.);\n  vec3 fcol = vec3(1.);\n\n  float p = 0.;\n  HitResult result;\n\n  for(int i = 0; i < 8; i++)\n  {\n    result = intersect(ro, rd);\n    if(!result.isHit)\n      return vec3(0);\n    \n    float r = hash1(seed);\n    p = 0.95;\n    if(r > p) \n        fcol = vec3(0.);\n\n    Ray randomRay;\n    randomRay.ro = result.hitPoint;\n    randomRay.rd = randomDirection(result.material.normal, seed);\n\n    float cosine = abs(dot(-rd, result.material.normal));\n\n    r = hash1(seed);\n    if(r < result.material.specularRate)\n    {\n      vec3 ref = normalize(reflect(rd, result.material.normal));\n      randomRay.rd = mix(ref, randomRay.rd, result.material.roughness);\n    }\n    \n    tcol += (fcol * result.material.emissive) * cosine;\n\n    fcol = fcol * result.material.color;\n    \n    rd = randomRay.rd;\n    ro = randomRay.ro;\n  }\n  return tcol / p;\n}\n\nmat3 setCamera(in vec3 ro, in vec3 rt, in float cr)\n{\n    vec3 cw = normalize(rt - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 p = -1.0 + 2.0 * (fragCoord.xy) / iResolution.xy;\n  p.x *= iResolution.x/iResolution.y;\n\n  float seed = p.x + p.y * 3.43121412313 + fract(1.12345314312*iTime);\n  \n  lightSphere = vec4(vec3(3.), 1.);\n  \n  vec2 of = -0.5 + vec2(hash1(seed), hash1(seed));\n  p = (2.0 * (fragCoord + of) - iResolution.xy) / iResolution.y;\n  \n  vec3 ro = vec3(2.78, 2.73, -8.00);\n  vec3 ta = vec3(2.78, 2.73,  0.00);\n  \n\n  mat3 ca = setCamera(ro, ta, 0.0);\n  vec3 rd = normalize(ca * vec3(p, 3.0));\n\n  vec3 col = vec3(0.);\n  vec3 tot = vec3(0.);\n\n  for( int a=0; a<16; a++ ) \n  {\n    col = PathTracing(ro, rd, seed);\n\n    tot += col;\n    \n    seed = mod( seed*1.1234567893490423, 13.);\n  }\n  tot /= float(16.);\n\n  tot = pow(clamp(tot, 0., 1.), vec3(0.45));\n  \n  vec3 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n  tot = mix(lastFrameColor, tot, 1.0f / float(iFrame+1));\n\n  fragColor = vec4(tot, 1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}