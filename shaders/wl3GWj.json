{
    "Shader": {
        "info": {
            "date": "1577576176",
            "description": "..",
            "flags": 0,
            "hasliked": 0,
            "id": "wl3GWj",
            "likes": 2,
            "name": "jason's night sky",
            "published": 3,
            "tags": [
                "sky"
            ],
            "usePreview": 0,
            "username": "jasonszhao",
            "viewed": 401
        },
        "renderpass": [
            {
                "code": "\nfloat snoise2(vec2 v) {\n    return snoise(vec3(v, 0));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float avgRes = (iResolution.x + iResolution.y) / 2.0;\n    vec2 pos = fragCoord / avgRes * 60.0;\n    \n    \n    //geometry\n    vec2 center = vec2(iResolution.x / 2.0, iResolution.y * 1.0/3.0);\n        \n    //colors\n    \n    \n    //vec3 basePurple = vec3(174, 108, 155) / 256.0;\n    //vec3 baseBlue = vec3(18, 30, 70) / 256.0;\n    \n    vec3 basePurpleHSL = vec3(318.0/360.0, .30, .55);\n    vec3 baseBlueHSL = vec3(226.0/360.0, .59, .17);\n    \n    vec2 weightedCoords = mat2(0.1, 0.0, 0.0, 1.0) * (fragCoord - center);\n    float dist = length(weightedCoords);\n    \n    float noisedDist_ = dist * mix(0.8, 1.2, pow(snoise(vec3(weightedCoords, iTime/5.0)), 2.0));\n    \n    vec3 noisedDist = noisedDist_ * mix(vec3(1.0, 0.8, 0.9), \n                                 vec3(1.1, 1.2, 1.1), \n                                 vec3(snoise(vec3(dist/2.0, weightedCoords.yx/5.0)), \n                                      snoise(vec3(dist/2.0, 1000.0 + weightedCoords.yx/5.0)), \n                                      snoise(vec3(dist/2.0, 1000000.0+weightedCoords.yx/5.0))));\n    \n    \n    \n    vec3 baseHSL = mod(mix(basePurpleHSL, baseBlueHSL, \n                    \t\tsmoothstep(avgRes / 50.0, avgRes / 5.0, noisedDist))\n                       \t, \n                           1.0);\n    \n    vec3 base = hsl2rgb(baseHSL);\n    vec3 star = vec3(0.99, 0.99, 0.8);\n    \n    \n    float blink = cos(snoise(vec3(pos, iTime/3.0)));\n\n\n    vec3 col = mix(base, star, \n                   smoothstep(0.6, 1.0, pow(snoise(vec3(pos, blink)), 2.0)));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// (Keijiro) This shader was slightly modified from the original version.\n// It's recommended to use the original version for other purposes.\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n    return mod289((x * 34.0 + 1.0) * x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n{\n    const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, C.yyy));\n    vec3 x0 = v   - i + dot(i, C.xxx);\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min(g.xyz, l.zxy);\n    vec3 i2 = max(g.xyz, l.zxy);\n\n    // x1 = x0 - i1  + 1.0 * C.xxx;\n    // x2 = x0 - i2  + 2.0 * C.xxx;\n    // x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy;\n    vec3 x3 = x0 - 0.5;\n\n    // Permutations\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec4 p =\n      permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0))\n                            + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n                            + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    vec4 j = p - 49.0 * floor(p * (1.0 / 49.0));  // mod(p,7*7)\n\n    vec4 x_ = floor(j * (1.0 / 7.0));\n    vec4 y_ = floor(j - 7.0 * x_ );  // mod(j,N)\n\n    vec4 x = x_ * (2.0 / 7.0) + 0.5 / 7.0 - 1.0;\n    vec4 y = y_ * (2.0 / 7.0) + 0.5 / 7.0 - 1.0;\n\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4(x.xy, y.xy);\n    vec4 b1 = vec4(x.zw, y.zw);\n\n    //vec4 s0 = vec4(lessThan(b0, 0.0)) * 2.0 - 1.0;\n    //vec4 s1 = vec4(lessThan(b1, 0.0)) * 2.0 - 1.0;\n    vec4 s0 = floor(b0) * 2.0 + 1.0;\n    vec4 s1 = floor(b1) * 2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n    vec3 g0 = vec3(a0.xy, h.x);\n    vec3 g1 = vec3(a0.zw, h.y);\n    vec3 g2 = vec3(a1.xy, h.z);\n    vec3 g3 = vec3(a1.zw, h.w);\n\n    // Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(g0, g0), dot(g1, g1), dot(g2, g2), dot(g3, g3)));\n    g0 *= norm.x;\n    g1 *= norm.y;\n    g2 *= norm.z;\n    g3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n    m = m * m;\n    m = m * m;\n\n    vec4 px = vec4(dot(x0, g0), dot(x1, g1), dot(x2, g2), dot(x3, g3));\n    return 42.0 * dot(m, px);\n}\n\n\n\n// from https://github.com/Jam3/glsl-hsl2rgb/\n\nfloat hue2rgb(float f1, float f2, float hue) {\n    if (hue < 0.0)\n        hue += 1.0;\n    else if (hue > 1.0)\n        hue -= 1.0;\n    float res;\n    if ((6.0 * hue) < 1.0)\n        res = f1 + (f2 - f1) * 6.0 * hue;\n    else if ((2.0 * hue) < 1.0)\n        res = f2;\n    else if ((3.0 * hue) < 2.0)\n        res = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\n    else\n        res = f1;\n    return res;\n}\n\nvec3 hsl2rgb(vec3 hsl) {\n    vec3 rgb;\n    \n    if (hsl.y == 0.0) {\n        rgb = vec3(hsl.z); // Luminance\n    } else {\n        float f2;\n        \n        if (hsl.z < 0.5)\n            f2 = hsl.z * (1.0 + hsl.y);\n        else\n            f2 = hsl.z + hsl.y - hsl.y * hsl.z;\n            \n        float f1 = 2.0 * hsl.z - f2;\n        \n        rgb.r = hue2rgb(f1, f2, hsl.x + (1.0/3.0));\n        rgb.g = hue2rgb(f1, f2, hsl.x);\n        rgb.b = hue2rgb(f1, f2, hsl.x - (1.0/3.0));\n    }   \n    return rgb;\n}\n\nvec3 hsl2rgb(float h, float s, float l) {\n    return hsl2rgb(vec3(h, s, l));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}