{
    "Shader": {
        "info": {
            "date": "1672725230",
            "description": "Knots+Cloth!\n\nCredits:\nknarkowics's Cloth Shading: https://shadertoy.com/view/4tfBzn\nwnu's sparkle commented: https://shadertoy.com/view/Ndlczs\n\n*mouse, up/down: cam*\n*left/right: draw*\n*space: reset WFC buffer*\n*shift-space: reset cloth and attract mode*",
            "flags": 48,
            "hasliked": 0,
            "id": "mts3Dl",
            "likes": 19,
            "name": "Celtic Knotwork Curtains WFC",
            "published": 3,
            "tags": [
                "dynamics",
                "physics",
                "glitter",
                "quadtree",
                "cloth",
                "sheen",
                "curtain",
                "velvet"
            ],
            "usePreview": 1,
            "username": "fenix",
            "viewed": 372
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  I thought it might be cool to use the Celtic Knotwork WFC design on these curtains. I\n//  guess this is another entry in both my cloth shader series and my WFC series. My\n//  previous cloth shaders:\n//\n//      Tearable 3D Fishnet             https://shadertoy.com/view/NlKBW3\n//      Cloth Draping + Shadows         https://shadertoy.com/view/cdjGRR\n//      Textured Cloth                  https://shadertoy.com/view/Ddj3Wh\n//      Quadtree Tapestry               https://shadertoy.com/view/mlXGzN\n//      Drawable Curtains               https://shadertoy.com/view/clXGRX\n//\n//  And, my previous WFC (Wave Function Collapse) shaders:\n//\n//      Simple Wave Function Collapse   https://shadertoy.com/view/DdfSzj\n//      Circuit Board WFC               https://shadertoy.com/view/mdBSRW\n//      Roguelike Dungeon WFC           https://shadertoy.com/view/ddSXzW\n//      Tiny Town WFC                   https://shadertoy.com/view/ds2XzD\n//      Raymarched Circuit Board WFC    https://shadertoy.com/view/mdjSDz\n//      Superposition Weave WFC         https://shadertoy.com/view/Ds2XRV\n//      Celtic Knotwork WFC             https://shadertoy.com/view/mtfGWX\n//\n//  Most of the shader (except buffer D and the renderCurtain function) is the same as\n//  Drawable Curtains, so I need to give credit again to two other shaders that I borrowed\n//  code from, for the \"Charlie Sheen\" velvet cloth and glitter respectively:\n//\n//      knarkowics's Cloth Shading      https://shadertoy.com/view/4tfBzn\n//      wnu's sparkle commented         https://shadertoy.com/view/Ndlczs  \n//\n//  The idea of Wave Function Collapse for generating random but ordered tilings comes from:\n//\n//      https://github.com/mxgmn/WaveFunctionCollapse\n//\n//  DISCLAIMER: as with my previous WFC shaders, this is not a proper implementation of\n//  the original WFC algorithm, but something meant to approximate it.\n//\n//  The sky and moon are borrowed from my own\n//\n//    Arctic Fireflies                  https://shadertoy.com/view/cssSRs\n//\n//  Phew, that was a lot of links! There's not a lot more to say about this shader, that I\n//  didn't say before in the shaders it's built from. The border is hard-coded and the WFC\n//  algorithm runs on the interior of each curtain. Press the space bar to reset the WFC\n//  buffer. Shift-space resets the cloth buffer and restarts attract mode.\n//\n// CHANGELOG:\n// 1/4/23: Reversed order of cloth and scene render - saves time not to compute shadows\n//         for scene pixels covered by cloth anyway\n// ---------------------------------------------------------------------------------------\n\n#define SHADOW_FROM_CLOTH 1\n\nconst float FAR_CLIP = 30.;\n\n#define CLOTH_POS_UNCLAMPED(X) texture(iChannel0, ((X)+.5)/iResolution.xy).xyz\n#define CLOTH_POS_CLAMPED(X) texture(iChannel0, (clamp(X, vec2(0), vec2(CLOTH_SIDE_LEN)+.5)/iResolution.xy)).xyz\n\nvec4 getClothNormalGrad(vec2 uv)\n{\n    vec2 delta = vec2(1, 0);\n    vec3 clothPosX0 = CLOTH_POS_CLAMPED(uv + delta.xy);\n    vec3 clothPosX1 = CLOTH_POS_CLAMPED(uv - delta.xy);\n    vec3 deltaX = clothPosX0 - clothPosX1;\n    vec3 clothPosY0 = CLOTH_POS_CLAMPED(uv + delta.yx);\n    vec3 clothPosY1 = CLOTH_POS_CLAMPED(uv - delta.yx);\n    vec3 deltaY = clothPosY0 - clothPosY1;\n    vec3 normal = normalize(cross(deltaX, deltaY) );\n    vec3 clothPos = CLOTH_POS_CLAMPED(uv);\n    float grad = dot(normal, clothPosX0 - clothPos) +\n                 dot(normal, clothPosX1 - clothPos) +\n                 dot(normal, clothPosY0 - clothPos) +\n                 dot(normal, clothPosY1 - clothPos);\n\n    return vec4(normal, grad);\n}\n\n// enable to see visualization of quadtree query counts per pixel\n#define DEBUG_NUM_PROC 0\n\n#if DEBUG_NUM_PROC\n#define DEBUG_NUM_PROC_ONLY(X) X\n#else\n#define DEBUG_NUM_PROC_ONLY(X)\n#endif\n\nDEBUG_NUM_PROC_ONLY(int numProc = 0;)\n\n// originally from archee's curtain and ball: https://www.shadertoy.com/view/MldXWX\n//\n// with optimizations:\n//    * only one texel fetch per loop\n//    * compute d2 only once\n//    * removed square roots (length)\n// \n// also, updated variable names and types, added comments\nvec3 quadtreeRender(vec3 cameraPos, vec3 rayDir, float minSize, bool side)\n{\n    vec3 uvz = vec3(0, 0, FAR_CLIP);\n\n    const float STRETCH_RATIO = 3.;\n    const float voxelK2 = (STRETCH_RATIO / CLOTH_SIDE_LEN_F) * (STRETCH_RATIO / CLOTH_SIDE_LEN_F);\n    float voxelsize2 = (minSize * minSize * voxelK2);\n    \n    vec2 corner = vec2(0); // corner of current quad being considered\n    float size = CLOTH_SIDE_LEN_F / 2.; // size of quad being considered\n    float end = size;\n    if (side)\n    {\n        corner = vec2(size, 0);\n        end = CLOTH_SIDE_LEN_F;\n    }\n    bool levelup = false;\n    \n    for (int i = 0; i < 5000; ++i) // less than 200 iterations for most pixels\n    {\n        DEBUG_NUM_PROC_ONLY(++numProc;)\n\n        vec3 boundingcenter = CLOTH_POS_UNCLAMPED(corner + size * .5);\n        float d2 = length2(cross(boundingcenter - cameraPos, rayDir));\n\n        if (size <= minSize)\n        {\n        \tif (d2 <= voxelsize2 &&\n                floor(corner.x + 1.) != CLOTH_SIDE_LEN_F / 2.) // missing between left and right sides\n        \t{\n                // found small enough quadrant to render it\n                float dept = dot(rayDir, boundingcenter - cameraPos);\n                uvz = dept < uvz.z ? vec3(corner + .5 * size, dept) : uvz;\n\t        }\n          \n            levelup = true; // don't bother to descend, we've already rendered\n        }\n\n        if (d2 > size * size * voxelK2 * .5)\n        {\n            levelup = true; // not near this quadrant, don't descend into here\n        }\n        \n        if (levelup)\n        {\n            levelup = false;\n            \n            if (fract(corner.y / size / 2.) < .25)\n            {\n                corner.y += size; // we're on the top...go to the bottom\n            }\n            else\n            {\n                corner.y -= size; // we're on the bottom...go back to the top\n\n                if (fract(corner.x / size / 2.) < .25)\n                {\n                    corner.x += size; // go from right to left\n                }\n                else\n                {\n                    corner.x -= size; // done with this quad, go up a level\n                    size *= 2.0;\n                    levelup = true;\n                }\n            }\n        }\n        else\n        {\n            if (size > minSize) size /= 2.;\n        }\n        \n        if (corner.x >= end) break;    \n    }\n    \n    return uvz;\n}\n\nvoid fxCalcCamera(in vec3 cameraLookAt, in vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraLeft, out vec3 cameraUp)\n{\n    cameraFwd  = normalize(cameraLookAt - cameraPos);\n    cameraLeft = -normalize(cross(cameraFwd, vec3(0.0,1.0,0.0)));\n    cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n}\n\nvec3 fxCalcRay(in vec2 fragCoord, in vec3 iResolution, in vec3 cameraFwd, in vec3 cameraUp, in vec3 cameraLeft)\n{\n\tvec2 screenPos = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n\treturn normalize(cameraFwd - screenPos.x * cameraLeft - screenPos.y * cameraUp);\n}\n\nmat4 fxCalcCameraMat(vec3 resolution, vec3 cameraLeft, vec3 cameraUp, vec3 cameraFwd, vec3 cameraPos)\n{\n    return mat4(vec4(-cameraLeft, 0.0),\n        vec4(-cameraUp, 0.0),\n        vec4(cameraFwd, 0.0),\n        vec4(cameraPos, 1.0));\n}\n\nvec3 fxGetParticlePos(int id)\n{\n    ivec2 addr = ivec2(id % CLOTH_SIDE_LEN, id / CLOTH_SIDE_LEN);\n    return texelFetch(iChannel0, addr, 0).xyz;\n}\n\n#define MAX_STEPS 100\n#define SURF_DIST .001\n\nfloat rayMarch(vec3 ro, vec3 rd)\n{\n\tfloat d = 0.;\n    \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n    \tvec3 p = ro + rd * d;\n        float dS = scene(p, true);\n        d += dS;\n        if(d > FAR_CLIP || abs(dS) < SURF_DIST) break;\n    }\n    \n    return min(FAR_CLIP, d);\n}\n\nconst vec3 FILL_LIGHT_DIR = normalize(vec3(-1, 0.75, 1));\n\nbool shadowScene(vec3 p, vec3 lightDir)\n{\n    return rayMarch(p, lightDir) < FAR_CLIP;\n}\n\n#if SHADOW_FROM_CLOTH\nbool shadowCloth(vec3 p, vec3 lightDir)\n{\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    \n    cameraPos = p;\n    cameraLookAt = p + lightDir;\n\n    fxCalcCamera(cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n    vec3 rayDir = cameraFwd;\n\n    mat4 c2w = fxCalcCameraMat(iResolution, cameraLeft, cameraUp, cameraFwd, cameraPos);\n    mat4 w2c = inverse(c2w);\n\n    vec3 uvz1 = quadtreeRender(cameraPos, rayDir, 1./4., false); // right side\n    vec3 uvz2 = quadtreeRender(cameraPos, rayDir, 1./4., true); // left side\n    vec3 uvz = uvz1.z < uvz2.z ? uvz1 : uvz2;\n\n    return uvz.z > 0. && uvz.z < FAR_CLIP;\n}\n#endif // SHADOW_FROM_CLOTH\n\nvec3 light(vec3 n, vec3 pointLightDir, bool shadow)\n{\n    return vec3(abs(dot(n, FILL_LIGHT_DIR)) * .05) + float(!shadow) * max(0., dot(n, pointLightDir)) * .9;\n}\n\nvec2 noise( in vec3 x )\n{\n    vec3 ip = floor(x);\n    vec3 fp = fract(x);\n\tfp = fp*fp*(3.0-2.0*fp);\n\tvec2 tap = (ip.xy+vec2(37.0,17.0)*ip.z) + fp.xy;\n\tvec4 rz = textureLod( iChannel1, (tap+0.5)/256.0, 0.0 );\n\treturn mix( rz.yw, rz.xz, fp.z );\n}\n\n// from sparkle commented by wnu: https://www.shadertoy.com/view/Ndlczs\nvec3 glitter(vec3 rayHit, vec3 normal, vec3 camDir)\n{\n    float t = iTime;\n    vec3 n = normal;\n\n    /////BASE COLOR\n\n    //FRESNEL \n\n    float fre = clamp(1. + dot(camDir,normal),-1.,1.);\n    float edge = sqrt(1.2-pow(fre,1./4.2));\n\n    //PICK YOUR COLOR\n\n    vec3 colorPick = vec3(1);\n\n    //COLOR FROM NORMALS AND FRESNEL\n\n    vec3 c = 2.25*-sin(sin(t*0. + n.x*1.+ 1.57 + sin(n.z*1. + 0.76)) + n.z + t*0.+  colorPick);\n    float ss = min(.5 - edge, smoothstep(.45 - edge, 1., edge));\n    c *= ss;\n\n    ///////GLINTS/GLITTER COMPUTATION\n\n    #define PRIMARY_INTENSITY 2.3\n    #define PRIMARY_CONCENTRATION 6.\n    #define SECONDARY_INTENSITY 10.\n    #define SECONDARY_CONCENTRATION 0.9\n\n    // HOW BIG THE GLITTER SPECKS ARE ; BIGGER -> SMALLER SPECKS\n    // (7 is probably the smallest I would go)\n\n    float scale = 400.;\n    rayHit = floor(rayHit*scale)/scale;\n\n    vec3 ligt = vec3(1.);\n    vec3 h = normalize(ligt-camDir);\n    float nl = dot(n,ligt);\n\n    vec3 coord = rayHit*.5;\n    coord.xy = coord.xy*.7071+coord.yx*.7071*vec2(1,-1);\n    coord.xz = coord.xz*.7071+coord.zx*.7071*vec2(1,-1);\n    vec3 coord2 = coord;\n\n    //first layer (inner glints)\n    float pw = .5*((iResolution.x));\n    vec3 aniso = vec3( noise((coord*pw)), noise((coord.yzx*pw)) )*2.0-1.0;\n    aniso -= n*dot(aniso,n);\n    float anisotropy = min(1.,length(aniso));\n    aniso /= anisotropy;\n    anisotropy = .55;\n    float ah = abs(dot(h,aniso));\n    float nh = abs(dot(n,h));\n    float qa = exp2((1.1-anisotropy)*3.5);\n    nh = pow( nh, qa*PRIMARY_CONCENTRATION );\n    nh *= pow( 1.-ah*anisotropy, 10.0 );\n    vec3 glints = c*nh*exp2((1.2-anisotropy)*PRIMARY_INTENSITY);\n\n    //second layer (outer glints)\n    pw = .145*((iResolution.x));\n    vec3 aniso2 = vec3( noise(coord2*pw), noise(coord2.yzx*pw).x )*2.0-1.0;\n    anisotropy = .6;\n    float ah2 = abs(dot(h,aniso2));\n    float nh2 = abs(dot(n,h));\n    float q2 = exp2((.1-anisotropy)*3.5);\n    nh2 = pow( nh, q2*SECONDARY_CONCENTRATION );\n    nh2 *= pow( 1.-ah2*anisotropy, 150.0 );\n    vec3 glints2 = c*nh2*((1.-anisotropy)*SECONDARY_INTENSITY);\n\n    ///// ADD BASE COLOR AND GLINTS/GLITTER LAYERS   \n\n    vec3 col = vec3(c)/4.;\n    col += (glints+glints2);\n\n    return col*col;\n}\n\nfloat saturate(float x)\n{\n    return clamp(x, 0., 1.);\n}\n\nvec3 saturate(vec3 x)\n{\n    return clamp(x, vec3(0.), vec3(1.));\n}\n\n// From Cloth Shading by knarkowics: https://www.shadertoy.com/view/4tfBzn\nvec3 FresnelTerm(vec3 specularColor, float vdoth)\n{\n\tvec3 fresnel = specularColor + (1. - specularColor) * pow((1. - vdoth), 5.);\n\treturn fresnel;\n}\n\nfloat CharlieD(float roughness, float ndoth)\n{\n    float rcpR  = 1. / roughness;\n    float cos2h = ndoth * ndoth;\n    float sin2h = 1. - cos2h;\n    return (2. + rcpR) * pow(sin2h, rcpR * .5) / (2. * PI);\n}\n\nfloat L(float x, float r)\n{\n\tr = saturate(r);\n\tr = 1.0 - (1. - r) * (1. - r);\n\n\tfloat a = mix( 25.3245,  21.5473, r);\n\tfloat b = mix( 3.32435,  3.82987, r);\n\tfloat c = mix( 0.16801,  0.19823, r);\n\tfloat d = mix(-1.27393, -1.97760, r);\n\tfloat e = mix(-4.85967, -4.32054, r);\n\n\treturn a / (1. + b * pow(x, c)) + d * x + e;\n}\n\nfloat CharlieV(float roughness, float ndotv, float ndotl)\n{\n\tfloat visV = ndotv < .5 ? exp(L(ndotv, roughness)) : exp(2. * L(.5, roughness) - L(1. - ndotv, roughness));\n\tfloat visL = ndotl < .5 ? exp(L(ndotl, roughness)) : exp(2. * L(.5, roughness) - L(1. - ndotl, roughness));\n\n\treturn 1. / ((1. + visV + visL) * (4. * ndotv * ndotl));\n}\n\nconst vec3 MOON_DIR = normalize(vec3(1, .5, -1));\nconst vec3 MOON_COLOR = vec3(.1, .15, .3);\n\nvec3 velvet(vec4 normalGrad, vec3 rayDir, vec3 hit, vec3 baseColor)\n{\n    if (dot(normalGrad.xyz, rayDir) > 0.) normalGrad.xyz = -normalGrad.xyz;\n\n    vec3 viewDir = -rayDir;\n    vec3 lightDir = MOON_DIR;\n\n    vec3 halfVec = normalize(viewDir + lightDir);\n    float vdoth = saturate(dot(viewDir, halfVec));\n    float ndoth\t= saturate(dot(normalGrad.xyz, halfVec));\n    float ndotv = saturate(dot(normalGrad.xyz, viewDir));\n    float ndotl = saturate(abs(dot(normalGrad.xyz, lightDir)));\n\n    vec3 diffuseColor  = 0.25 * baseColor;\n    vec3 specularColor = sqrt(baseColor);\n    float roughness    = 0.5;\n\n    vec3 diffusePoint = diffuseColor * saturate(dot(normalGrad.xyz, lightDir));\n    vec3 diffuseFill = diffuseColor * saturate(dot(normalGrad.xyz, FILL_LIGHT_DIR));\n\n    vec3 f = FresnelTerm(specularColor, vdoth);\n\n    float d = CharlieD(roughness, ndoth);\n    float v = CharlieV(roughness, ndotv, ndotl);\n\n    vec3 specular = f * (d * v * PI * ndotl);\n\n    vec3 color = diffusePoint + diffuseFill + specular;\n    return color;\n}\n\n// From jarble's Glacial valleys: https://www.shadertoy.com/view/NscGWl\n// (used for moon)\nfloat fbm(in vec2 uv,int octaves)\n{\n    //this function generates the terrain height\n    uv *= 1.25;\n    float value = 0.;\n    float amplitude = 1.2;\n    float freq = 0.5,n2=0.;\n    vec2 n1 = vec2(0.);\n    for (int i = 0; i < octaves; i++)\n    {\n        n2 = sin(uv.x*freq)+cos(uv.y*freq);\n\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        value = abs(value-abs(n2-value) * amplitude);\n        amplitude *= .37;\n        freq *= 2.05;\n        uv = vec2(uv.y,uv.x+n2/(freq));\n    }\n    \n    return value;\n}\n\nfloat fbm(in vec3 p,int iters)\n{   \n    float h = fbm(p.xz,iters);\n    return h;\n}\n\nvec3 sky(vec3 rayDir)\n{\n    vec3 stars = vec3(smoothstep(.5, .8, pow(float(hash(uvec4(rayDir * iResolution.y + 4000., 1)).r) / 4.35e9, 50.))) * 4.;\n    float d = distance(rayDir, MOON_DIR);\n    if (d > .03 + + 2./iResolution.y) return stars;\n    vec3 moon = MOON_COLOR * (1. + fbm(rayDir.xxy * 100., 3));\n    return mix(moon, stars, smoothstep(.03, .03 + 2./iResolution.y, d));\n}\n\nvec4 hash4(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return vec4(x) * (1./float(0xffffffffU));\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdArc( in vec2 p, in vec2 sc, in float ra, float rb )\n{\n    // sc is the sin/cos of the arc's aperture\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n}\n\nmat2 rotate(float a)\n{\n    vec2 sc = vec2(sin(a), cos(a));\n    return mat2(sc.y, sc.x, -sc.x, sc.y);\n}\n\n// cell distance functions\nfloat sdIStSt(vec2 p)\n{\n    return min(abs(p.x - 2.), abs(p.x - 6.)) - 1.;\n}\n\nconst float ARC_ANGLE = PI / 8.;\nconst vec2 ARC_SC = vec2(sin(ARC_ANGLE), cos(ARC_ANGLE));\n\nfloat sdCross(vec2 p)\n{\n    float dist = sdArc(rotate(5. * PI / 8.) * (p - vec2(4, 2.85)), ARC_SC, 2., 1.);\n    dist = min(dist, sdArc(rotate(11. * PI / 8.) * (p - vec2(4, 3)), ARC_SC, 2., 1.));\n    dist = max(dist, -sdBox(rotate(PI / 4.) * (p - vec2(4, 0)), vec2(1.5, 1.)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p - vec2(4, 0)), vec2(1, 2)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p - vec2(2.8, 1.37)), vec2(.35, 1)));\n    return dist;\n}\n\nfloat sdIStCr(vec2 p)\n{\n    float dist = sdBox(p - vec2(2, 7), vec2(1, 4));\n    dist = min(dist, sdBox(p - vec2(6, 7), vec2(1, 4)));\n    dist = min(dist, sdCross(p));\n    return dist;\n}\n\nfloat sdICrCr(vec2 p)\n{\n    const float BIG_ARC_ANGLE = 2. * PI / 8.;\n    const vec2 BIG_ARC_SC = vec2(sin(BIG_ARC_ANGLE), cos(BIG_ARC_ANGLE));\n    float dist = sdArc(rotate(4. * PI / 8.) * (p - vec2(1.65, 4)), BIG_ARC_SC, 4.5, 1.);\n    dist = min(dist, sdArc(rotate(-4. * PI / 8.) * (p - vec2(6.35, 4)), BIG_ARC_SC, 4.5, 1.));\n\n    dist = max(dist, -sdBox(rotate(PI / 4.) * (p - vec2(4, 0)), vec2(1.5, 1.5)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p - vec2(4, 0)), vec2(1, 1.5)));\n\n    dist = max(dist, -sdBox(rotate(PI / 4.) * (p * -1. + vec2(4, 8)), vec2(1.5, 1.5)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p * -1. + vec2(4, 8)), vec2(1, 1.5)));\n\n    return dist;\n}\n\nfloat sdEndCorner(vec2 p)\n{\n    float dist = sdBox(p - vec2(2, 4), vec2(1, 1));\n    dist = min(dist, sdBox(p - vec2(6, 4), vec2(1, 1)));\n    dist = min(dist, sdBox(p - vec2(4, 6), vec2(3, 1)));\n    dist = min(dist, sdCross(p));\n    return dist;\n}\n\nfloat sdEndFoot(vec2 p)\n{\n    float dist = sdBox(p - vec2(2, 1), vec2(1, 1));\n    dist = min(dist, sdBox(p - vec2(6, 1), vec2(1, 1)));\n    const float a = PI / 2.;\n    const vec2 sc = vec2(sin(a), cos(a));\n    dist = min(dist, sdArc((p - vec2(4, 2)), sc, 2., 1.));\n    return dist;\n}\n\nfloat sdCornerStSt(vec2 p)\n{\n    float dist = sdBox(p - vec2(2, 5), vec2(1, 4));\n    dist = min(dist, sdBox(p - vec2(5, 2), vec2(4, 1)));\n    dist = min(dist, sdBox(p - vec2(6, 6.5), vec2(1, 1.5)));\n    dist = min(dist, sdBox(p - vec2(6.5, 6), vec2(1.5, 1)));\n    return dist;\n}\n\nfloat sdCornerCrSt(vec2 p)\n{\n    float dist = sdBox(p - vec2(2, 5), vec2(1, 4));\n    dist = min(dist, sdBox(p - vec2(4, 2), vec2(1, 1)));\n    dist = min(dist, sdBox(p - vec2(6, 8), vec2(1, 1)));\n    \n    vec2 p2 = rotate(PI / -2.) * (p - vec2(8, 0));\n\n    dist = min(dist, sdArc(rotate(-PI / 8.) * (p2 - vec2(6.85, 0)), ARC_SC, 2., 1.));\n    dist = min(dist, sdArc(rotate(11. * PI / 8.) * (p2 - vec2(4, 3)), ARC_SC, 2., 1.));\n    dist = max(dist, -sdBox(rotate(PI / 4.) * (p2 - vec2(4., 0.)), vec2(1.5, 1.)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p2 - vec2(4, 0)), vec2(1, 2)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p2 - vec2(2.85, 1.32)), vec2(.25, 1)));\n\n    return dist;\n}\n\nfloat sdCornerStCr(vec2 p)\n{\n    float dist = sdBox(p - vec2(5, 2), vec2(4, 1));\n    dist = min(dist, sdBox(p - vec2(2, 4), vec2(1, 1)));\n    dist = min(dist, sdBox(p - vec2(8, 6), vec2(1, 1)));\n    \n    vec2 p2 = rotate(PI / -2.) * (p.yx - vec2(8, 0));\n\n    dist = min(dist, sdArc(rotate(-PI / 8.) * (p2 - vec2(6.9, 0)), ARC_SC, 2., 1.));\n    dist = min(dist, sdArc(rotate(11. * PI / 8.) * (p2 - vec2(4, 2.85)), ARC_SC, 2.0, 1.));\n    dist = max(dist, -sdBox(rotate(-PI / 4.) * (p2 - vec2(4, 0)), vec2(1.5, 1)));\n    dist = min(dist, sdBox(rotate(-PI / 4.) * (p2 - vec2(4, 0)), vec2(1, 2)));\n    dist = min(dist, sdBox(rotate(-PI / 4.) * (p2 - vec2(5.3, 1.22)), vec2(.35, 1)));\n\n    return dist;\n}\n\nfloat sdCornerCrCr(vec2 p)\n{\n    float dist = sdBox(p - vec2(3, 2), vec2(2, 1));\n    dist = min(dist, sdBox(p - vec2(2, 3), vec2(1, 2)));\n\n    vec2 p1 = rotate(PI / -2.) * (p - vec2(8, 0));\n    \n    dist = min(dist, sdArc(rotate(11. * PI / 8.) * (p1 - vec2(4, 3)), ARC_SC, 2., 1.));\n    dist = max(dist, -sdBox(rotate(-PI / 4.) * (p1 - vec2(4, 0)), vec2(1.5, 1)));\n\n    vec2 p2 = rotate(PI / -2.) * (p.yx - vec2(8, 0));\n\n    dist = min(dist, sdArc(rotate(11. * PI / 8.) * (p2 - vec2(4, 2.85)), ARC_SC, 2., 1.));\n    dist = max(dist, -sdBox(rotate(-PI / 4.) * (p2 - vec2(4, 0)), vec2(1.5, 1)));\n    dist = min(dist, sdBox(rotate(-PI / 4.) * (p2 - vec2(4, 0)), vec2(1, 2)));\n\n    dist = max(dist, -sdBox(rotate(PI / 4.) * (p2 - vec2(7, 3)), vec2(1.5, 2.5)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p2 - vec2(7, 3)), vec2(1, 2.75)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p2 - vec2(6.67, 5.15)), vec2(.25, .99)));\n\n    return dist;\n}\n\nfloat sdTStCrSt(vec2 p)\n{\n    float dist = sdBox(p - vec2(2, 5), vec2(1, 6));\n    dist = min(dist, sdBox(p - vec2(6, .5), vec2(1, 1)));\n    dist = min(dist, sdBox(p - vec2(6, 8), vec2(1, 1)));\n    \n    vec2 p2 = rotate(PI / -2.) * (p - vec2(8, 0));\n\n    dist = min(dist, sdArc(rotate(-PI / 8.) * (p2 - vec2(6.85, 0)), ARC_SC, 2., 1.));\n    dist = min(dist, sdArc(rotate(PI / 8.) * (p2 - vec2(1.35, 0)), ARC_SC, 2., 1.));\n    dist = max(dist, -sdBox(rotate(PI / 4.) * (p2 - vec2(4, 0)), vec2(1.5, 2)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p2 - vec2(4, 0)), vec2(1, 2)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p2 - vec2(2.9, 1.3)), vec2(.25, .99)));\n\n    return dist;\n}\n\nfloat spCell(vec2 p, int type)\n{\n    float dist = 1e6;\n    \n    if (type == I_ST_ST)           dist = sdIStSt(p);\n    else if (type == I_ST_CR)      dist = sdIStCr(p);\n    else if (type == I_CR_CR)      dist = sdICrCr(p);\n    else if (type == END_CR)       dist = sdEndCorner(p);\n    else if (type == END_FOOT)     dist = sdEndFoot(p);\n    else if (type == CORNER_ST_ST) dist = sdCornerStSt(p);\n    else if (type == CORNER_CR_ST) dist = sdCornerCrSt(p);\n    else if (type == CORNER_ST_CR) dist = sdCornerStCr(p);\n    else if (type == CORNER_CR_CR) dist = sdCornerCrCr(p);\n    else if (type == T_ST_CR_ST)   dist = sdTStCrSt(p);\n\n    return smoothstep(0., 80./iResolution.y, dist);\n}\n\nvec2 rot90(vec2 v, int r)\n{\n    if (r == 0) return v;\n    if (r == 1) return vec2(v.y, 8. - v.x);\n    if (r == 2) return 8. - v;\n    if (r == 3) return vec2(8. - v.y, v.x);\n}\n\nfloat renderCelticKnots( vec2 u )\n{\n    u *= vec2(100., 50);\n    vec2 p = fract(u) * 8.;\n\n    uvec4 valid = floatBitsToUint(texelFetch(iChannel2, ivec2(u), 0));\n    if (valid == uvec4(0)) return 1.;\n    \n    float c = 0.;\n    float n = 0.;\n    for (int rot = 0; DONT_UNROLL && rot < 4; ++rot)\n    {\n        uint bit = 1u;\n        for (int type = 0; DONT_UNROLL && type < NUM_TILES; ++type)\n        {\n            if ((valid[rot] & bit) != 0u)\n            {\n                c += spCell(rot90(p,rot), type);\n                ++n;\n            }\n            bit <<= 1;\n        }\n    }\n\n    return c / n;\n}\n\nvec4 renderCurtain(vec2 fragCoord)\n{\n    vec4 fragColor = vec4(.1, .0, .9, 0);\n    fragColor = mix(vec4(1,1,1,1), fragColor, renderCelticKnots(fragCoord));\n    return fragColor;\n}\n\n// From https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    DEBUG_NUM_PROC_ONLY(numProc = 0);\n    vec2 u = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxState state = fxGetState(iFrame);\n    \n    cameraPos = -state.orbit * vec3(sin(state.camera.x) * sin(state.camera.y), cos(state.camera.y), cos(state.camera.x) * sin(state.camera.y));\n    cameraLookAt = vec3(0, .3, 0);\n    cameraPos += cameraLookAt;\n\n    fxCalcCamera(cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n    vec3 rayDir = fxCalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n    // render cloth\n    vec3 uvz1 = quadtreeRender(cameraPos, rayDir, 1./16., false); // right side\n    vec3 uvz2 = quadtreeRender(cameraPos, rayDir, 1./16., true); // left side\n    vec3 uvz = uvz1.z < uvz2.z ? uvz1 : uvz2;\n    if (uvz.z < FAR_CLIP)\n    {\n        vec4 normalGrad = getClothNormalGrad(uvz.xy);\n        vec3 normal = normalGrad.xyz;\n        vec3 hit = cameraPos + rayDir * uvz.z;\n        float ao = .0 + 1. * smoothstep(-.03, .01, normalGrad.w);\n\n        vec3 lightColor = MOON_COLOR * ao;\n\n#if 0 // enable shadows on cloth\n        vec3 offsetPos = hit + normal * 2. * SURF_DIST;\n        s = shadowScene(offsetPos, MOON_DIR);\n#if SHADOW_FROM_CLOTH\n        //s = s || shadowCloth(offsetPos, MOON_DIR); // self-shadowing adds a lot of cost, not a lot of effect\n#endif\n        if (s) lightColor *= .25;\n#endif\n        if (dot(normal, rayDir) < 0.) lightColor *= .01;\n        \n        vec4 colorGlitter = renderCurtain(uvz.xy / CLOTH_SIDE_LEN_F);\n        //colorGlitter.a = 1.; // gold sparkly curtains\n        vec3 color = velvet(normalGrad, rayDir, hit, colorGlitter.rgb) * lightColor;\n        if (colorGlitter.a > 0.)\n        {\n            color = mix(color, glitter(hit, normal, -rayDir) * ao, colorGlitter.a);\n        }\n        fragColor = vec4(color, 1);\n    }\n    else\n        fragColor.xyz = sky(rayDir);\n\n    // render scene\n    float d = rayMarch(cameraPos, rayDir);\n    if (d < uvz.z)\n    {\n        vec3 hit = cameraPos + rayDir * d;\n        vec3 normal = getSceneNormal(hit, true);\n        vec3 offsetPos = hit + normal * 2. * SURF_DIST;\n        bool s = shadowScene(offsetPos, MOON_DIR);\n#if SHADOW_FROM_CLOTH\n        s = s || shadowCloth(offsetPos, MOON_DIR);\n#endif\n        fragColor.xyz = light(normal, MOON_DIR, s) * MOON_COLOR;\n    }\n\n    fragColor.xyz = pow(ACESFilm(fragColor.xyz), vec3(1./2.2));\n    fragColor.w = 1.;\n\n    DEBUG_NUM_PROC_ONLY(fragColor = sin(float(numProc) * vec4(1, 11, 13, 0)) * sqrt(vec4(numProc)) / 10.);\n    //fragColor = texelFetch(iChannel2, ivec2(fragCoord), 0) * 1e6;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const int CLOTH_SIDE_LEN = 128;\nconst float CLOTH_SIDE_LEN_F = float(CLOTH_SIDE_LEN);\nconst float PI = 3.141592653589793;\n\nconst uvec4 MAX_UVEC4 = uvec4(0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff);\n#define DONT_UNROLL min(iFrame,0) >= 0\n\nconst int EMPTY = 0;\nconst int I_ST_ST = 1;\nconst int I_ST_CR = 2;\nconst int I_CR_CR = 3;\nconst int END_CR = 4;\nconst int END_FOOT = 5;\nconst int CORNER_ST_ST = 6;\nconst int CORNER_CR_ST = 7;\nconst int CORNER_ST_CR = 8;\nconst int CORNER_CR_CR = 9;\nconst int T_ST_CR_ST = 10;\nconst int NUM_TILES = 11;\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nint countBits(uint n)\n{\n    int count = 0;\n    while (n != 0u)\n    {\n        n &= (n - 1u);\n        count++;\n    }\n    return count;\n}\n\nint countBits(uvec4 v)\n{\n    return countBits(v.x) + countBits(v.y) + countBits(v.z) + countBits(v.w);\n}\n\nint log2int(uint n)\n{\n    int bits = 0;\n\n    if (n > 0xffffu)\n    {\n        n >>= 16u;\n        bits = 16;\n    }\n\n    if (n > 0xffu)\n    {\n        n >>= 8u;\n        bits += 8;\n    }\n\n    if (n > 0xfu)\n    {\n        n >>= 4u;\n        bits += 4;\n    }\n\n    if (n > 0x3u)\n    {\n        n >>= 2u;\n        bits += 2;\n    }\n\n    if (n > 0x1u)\n    {\n        bits += 1;\n    }\n    \n    return bits;\n}\n\nuvec4 hash(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\nvec4 noise(uvec4 p){\n    const float scale = 1.0/float(0xffffffffU);\n    uvec4 h = hash(p);\n    return vec4(h)*scale;\n}\n\nfloat length2(vec3 v) { return dot(v, v); }\nfloat length2(vec2 v) { return dot(v, v); }\n\nfloat sdBox(vec3 p, vec3 s)\n{\n    p = abs(p) - s;\n\treturn length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n// IQ's 3D line segment formula. Simpler and cheaper, but doesn't orient carved cross-sections.\nfloat sdCapsule(vec3 p, vec3 a, vec3 b){\n\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    pa = abs(pa - ba*h);\n    return length( pa );\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat scene(vec3 p, bool rod)\n{\n    float d = 1e6;\n    \n    d = min(d, sdBox(p - vec3(-.9,.05,.1), vec3(.1,.9,.1))); // wall\n    d = min(d, sdBox(p - vec3(.9,.05,.1), vec3(.1,.9,.1))); // wall\n    d = min(d, sdBox(p - vec3(0,1.,.1), vec3(1.,.1,.1))); // wall\n    d = min(d, sdBox(p - vec3(0,-.8,.1), vec3(1.,.1,.1))); // wall\n    d = min(d, sdBox(p - vec3(0,-.65,.1), vec3(.9,.05,.2))); // sill\n    d = min(d, sdBox(p + vec3(0,3.5,0), vec3(10.,1.,10.))); // floor\n    if (rod)\n    {\n        d = min(d, sdCapsule(p, vec3(-.85, .95, -.02), vec3(.85, .95, -.01)) - .01); // rod\n        d = min(d, sdSphere(p - vec3(-.85, .95, -.02), .03)); // right side ball\n        d = min(d, sdSphere(p - vec3( .85, .95, -.02), .03)); // left side ball\n    }\n    \n    return d;\n}\n\n// // https://iquilezles.org/articles/normalsSDF\nvec3 getSceneNormal(vec3 p, bool rod)\n{\n    const vec2 e = vec2(1.0,-1.0)*0.000005773;\n    return normalize( e.xyy*scene(p + e.xyy, false ) + \n\t\t\t\t\t  e.yyx*scene(p + e.yyx, false ) + \n\t\t\t\t\t  e.yxy*scene(p + e.yxy, false ) + \n\t\t\t\t\t  e.xxx*scene(p + e.xxx, false ) );\n}\n\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n#define keyDownImpl(sampler, ascii)    ( texelFetch(sampler,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n#define KEY_LEFT 37\n#define KEY_UP 38\n#define KEY_RIGHT 39\n#define KEY_DOWN 40\n\nstruct fxState\n{\n    float draw;\n    float attractCurtain;\n    float attractCamera;\n    float orbit;\n    vec2 camera;\n    vec2 lastMouse;\n};\n\nvoid initState(inout fxState state)\n{\n    state.draw = .75;\n    state.attractCurtain = 15.;\n    state.attractCamera = 1.;\n    state.orbit = 2.;\n    state.camera = vec2(sin(.0004), cos(.0002) * .25 + PI*.5);\n    state.lastMouse = vec2(0);\n}\n\nfxState fxGetStateImpl(sampler2D sampler, int iFrame)\n{\n    vec4 data0 = texelFetch(sampler, ivec2(0, CLOTH_SIDE_LEN * 2), 0);\n    vec4 data1 = texelFetch(sampler, ivec2(1, CLOTH_SIDE_LEN * 2), 0);\n    \n    fxState state;\n    state.draw = data0.x;\n    state.attractCurtain = data0.y;\n    state.attractCamera = data0.z;\n    state.orbit = data0.w;\n    state.camera = data1.xy;\n    state.lastMouse = data1.zw;\n    if (iFrame == 0) initState(state);\n    return state;\n}\n\n#define fxGetState(iFrame) fxGetStateImpl(iChannel0, iFrame)\n\nvec4 fxPutState(fxState state, ivec2 ifc)\n{\n    if (ifc == ivec2(0, CLOTH_SIDE_LEN * 2))\n        return vec4(state.draw, state.attractCurtain, state.attractCamera, state.orbit);\n    else\n        return vec4(state.camera, state.lastMouse);\n}\n\nvec4 updateState(fxState state, sampler2D keySampler, ivec2 ifc, int iFrame, vec4 iMouse, vec3 iResolution, float iTime)\n{\n    if (iFrame == 0 || keyDownImpl(keySampler, KEY_SPACE) && keyDownImpl(keySampler, KEY_SHIFT))\n    {\n        initState(state);\n    }\n    else\n    {\n        if (keyDownImpl(keySampler, KEY_LEFT))\n        {\n            state.draw += .0025;\n            state.attractCurtain = 0.;\n        }\n        if (keyDownImpl(keySampler, KEY_RIGHT))\n        {\n            state.draw -= .0025;\n            state.attractCurtain = 0.;\n        }\n        if (keyDownImpl(keySampler, KEY_UP))\n        {\n            state.orbit -= .0025;\n            state.attractCamera = 0.;\n        }\n        if (keyDownImpl(keySampler, KEY_DOWN))\n        {\n            state.orbit += .0025;\n            state.attractCamera = 0.;\n        }\n        if (state.attractCurtain != 0.)\n        {\n            state.attractCurtain = mod(state.attractCurtain, 30.) + .005;\n            state.draw = smoothstep(5., 15., state.attractCurtain) * smoothstep(30., 20., state.attractCurtain) * .5 + .3;\n        }\n        state.draw = clamp(state.draw, .3, .8);\n\n        if (iMouse.z > 0.)\n        {\n            state.attractCamera = 0.;\n            \n            if (iMouse.w < 0.)\n            {\n                state.camera += 10. * ((iMouse.xy / iResolution.x) - state.lastMouse);\n                state.camera.y = clamp(state.camera.y, PI*.1, PI*.9);\n            }\n\n            state.lastMouse = iMouse.xy / iResolution.x;\n        }\n        \n        if (state.attractCamera > 0.)\n        {\n            state.attractCamera += 1.;\n            state.camera = vec2(sin(state.attractCamera * .0016), cos(state.attractCamera * .0008) * .25 + PI*.5);\n            state.orbit = 1.5 + cos(state.attractCamera * .0012) * .5;\n        }\n    }\n    \n    return fxPutState(state, ifc);\n}\n\nvec3 fxGetParticlePos(sampler2D sampler, int id)\n{\n    ivec2 addr = ivec2(id % CLOTH_SIDE_LEN, id / CLOTH_SIDE_LEN);\n    return texelFetch(sampler, addr, 0).xyz;\n}\n\nvoid horizConstraint(sampler2D sampler, ivec2 nb, int dist, inout vec3 pos)\n{\n    vec3 nbPos = texelFetch(sampler, nb, 0).xyz;\n    vec3 delta = pos - nbPos;\n    float deltaLen = length(delta);\n    float idealDist = float(dist) * 2.7 / float(CLOTH_SIDE_LEN - 1);\n    float f = .4;\n    if (deltaLen > idealDist) f = .6;\n    pos = mix(nbPos + normalize(delta) * idealDist, pos, f);\n}\n\nvoid vertConstraint(sampler2D sampler, ivec2 nb, int dist, float f, inout vec3 pos)\n{\n    const float Y_STRETCH = 1.47;\n\n    vec3 nbPos = texelFetch(sampler, nb, 0).xyz;\n    vec3 delta = pos - nbPos;\n    float deltaLen = length(delta);\n    if (deltaLen > Y_STRETCH * float(dist) / float(CLOTH_SIDE_LEN - 1))\n    {\n        pos = mix(nbPos + normalize(delta) * Y_STRETCH * float(dist) / float(CLOTH_SIDE_LEN - 1), pos, f);\n    }\n}\n\nvec3 initVert(ivec2 v, fxState state)\n{\n    vec2 vert = vec2(v);\n    vert.y = CLOTH_SIDE_LEN_F - (CLOTH_SIDE_LEN_F - vert.y)*.83;\n    vec3 pos = (vec3(((vert - float(CLOTH_SIDE_LEN - 1) * .5))*2./CLOTH_SIDE_LEN_F, -.01) + vec3(0, .05, 0)) * vec3(state.draw, .95, 1);\n    \n    // split down the middle\n    if (v.x < CLOTH_SIDE_LEN / 2) pos.x -= .8 - state.draw;\n    else pos.x += .8 - state.draw;\n    \n    // wavy top to set up the pleats\n    float s = sin(float(v.x) * 3.14 / 4.);\n    //if (abs(s) > 1e-6) s /= sqrt(abs(s));\n    pos.z -= (1. + s) * .03;\n    return pos;\n}\n\n#define CLOTH_POS(X) texture(sampler, clamp((X+.5)/res.xy, vec2(0), vec2(CLOTH_SIDE_LEN))).xyz\n\nvec3 getClothNormal(sampler2D sampler, vec3 res, ivec2 ifc)\n{\n    vec2 uv = vec2(ifc);\n    vec2 delta = vec2(1, 0);\n    vec3 clothPosX0 = CLOTH_POS(uv + delta.xy);\n    vec3 clothPosX1 = CLOTH_POS(uv - delta.xy);\n    vec3 deltaX = clothPosX0 - clothPosX1;\n    vec3 clothPosY0 = CLOTH_POS(uv + delta.yx);\n    vec3 clothPosY1 = CLOTH_POS(uv - delta.yx);\n    vec3 deltaY = clothPosY0 - clothPosY1;\n    return normalize(cross(deltaX, deltaY));\n}\n\nvoid clothBufferMainImpl( out vec4 fragColor, vec2 fragCoord, sampler2D vertexSampler, sampler2D keySampler, int iFrame, vec4 iMouse, vec3 iResolution, float iTime)\n{\n    ivec2 ifc = ivec2(fragCoord);\n    \n    fxState state = fxGetStateImpl(vertexSampler, iFrame);\n    \n    if (ifc == ivec2(0, CLOTH_SIDE_LEN * 2) || ifc == ivec2(1, CLOTH_SIDE_LEN * 2))\n    {\n        fragColor = updateState(state, keySampler, ifc, iFrame, iMouse, iResolution, iTime);\n        return;\n    }\n    \n    if (any(greaterThan(ifc, CLOTH_SIDE_LEN * ivec2(2, 1))))\n    {\n        fragColor = vec4(0); // discard all unneeded pixels\n        return;\n    }\n    \n    if (iFrame == 0 || keyDownImpl(keySampler, KEY_SPACE) && keyDownImpl(keySampler, KEY_SHIFT))\n    {\n        // init cloth positions\n        ifc.x = (ifc.x % CLOTH_SIDE_LEN);\n        fxState initState;\n        initState.draw = .8;\n        fragColor.xyz = initVert(ifc, initState);\n        fragColor.w = 1.;\n\n        return;\n    }\n    \n    if (ifc.x >= CLOTH_SIDE_LEN)\n    {\n        // store last position on right side\n        fragColor = texelFetch(vertexSampler, ifc - ivec2(CLOTH_SIDE_LEN, 0), 0);\n        return;\n    }\n    \n    vec3 pos = texelFetch(vertexSampler, ifc, 0).xyz;\n    if (ifc.y >= CLOTH_SIDE_LEN - 6)\n    {\n        pos = initVert(ifc, state); // top six rows are pinned\n    }\n    else\n    {\n        vec3 oldPos = texelFetch(vertexSampler, ifc + ivec2(CLOTH_SIDE_LEN, 0), 0).xyz;\n        \n        pos += (pos - oldPos) * .9; // integration\n        pos += vec3(0, -.1, 0); // gravity\n        \n        // wind\n        vec3 normal = getClothNormal(vertexSampler, iResolution, ifc);\n        pos.z += sin(pos.x*.3 + iTime*.2) * .03 * normal.z;\n\n        // vertical constraints\n        for (int i = 0; i < 5; ++i)\n        {\n            float Y_STRETCH = 1.47;\n            ivec2 nbU = ifc + ivec2(0, i);\n            if (nbU.y <= CLOTH_SIDE_LEN - 1) vertConstraint(vertexSampler, nbU, i, .5, pos);\n            ivec2 nbD = ifc - ivec2(0, i);\n            if (nbD.y >= 0) vertConstraint(vertexSampler, nbD, i, .99, pos);\n        }\n\n        // horizontal constraints\n        int endL = ifc.x < CLOTH_SIDE_LEN / 2 ? CLOTH_SIDE_LEN / 2 - 1 : CLOTH_SIDE_LEN - 1;\n        int endR = ifc.x >= CLOTH_SIDE_LEN / 2 ? CLOTH_SIDE_LEN / 2 : 0;\n        for (int i = 0; i < 3; ++i)\n        {\n            ivec2 nbL = ifc + ivec2(i, 0);\n            ivec2 nbR = ifc - ivec2(i, 0);\n            if (nbL.x <= endL) horizConstraint(vertexSampler, nbL, i, pos);\n            if (nbR.x >= endR) horizConstraint(vertexSampler, nbR, i, pos);\n        }\n\n        // collision with scene\n        pos -= min(0., scene(pos, false) - .01) * getSceneNormal(pos, false);\n\n    }\n\n    fragColor = vec4(pos, 1);\n}\n\n#define clothBufferMain(fragColor, fragCoord) clothBufferMainImpl( fragColor, fragCoord, iChannel0, iChannel3, iFrame, iMouse, iResolution, iTime)\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Cloth simulation. Left side is current position, right side is last position.\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    clothBufferMain(fragColor, fragCoord);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Cloth simulation. Left side is current position, right side is last position.\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    clothBufferMain(fragColor, fragCoord);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Cloth simulation. Left side is current position, right side is last position.\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    clothBufferMain(fragColor, fragCoord);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Computes the remaining possibilities for each square (aka entropy). Each component \n// corresponds to a rotation, and within that each bit is a valid tile possibility.\n// ---------------------------------------------------------------------------------------\n\n// cell shapes\nconst mat3 S_EMPTY =\n    mat3(0,0,0,\n         0,0,0,\n         0,0,0);\n         \nconst mat3 S_I_ST_ST =\n    mat3(0,1,0,\n         0,1,0,\n         0,1,0);\n         \nconst mat3 S_I_ST_CR =\n    mat3(0,1,0,\n         0,1,0,\n         0,2,0);\n         \nconst mat3 S_I_CR_CR =\n    mat3(0,2,0,\n         0,1,0,\n         0,2,0);\n         \nconst mat3 S_END_CR =\n    mat3(0,0,0,\n         0,1,0,\n         0,2,0);\n         \nconst mat3 S_END_FOOT =\n    mat3(0,0,0,\n         0,1,0,\n         0,1,0);\n         \nconst mat3 S_CORNER_ST_ST =\n    mat3(0,1,0,\n         0,1,1,\n         0,0,0);\n         \nconst mat3 S_CORNER_CR_ST =\n    mat3(0,1,0,\n         0,1,2,\n         0,0,0);\n         \nconst mat3 S_CORNER_ST_CR =\n    mat3(0,2,0,\n         0,1,1,\n         0,0,0);\n         \nconst mat3 S_CORNER_CR_CR =\n    mat3(0,2,0,\n         0,1,2,\n         0,0,0);\n         \nconst mat3 S_T_ST_CR_ST =\n    mat3(0,1,0,\n         0,1,2,\n         0,1,0);\n         \n         \nmat3 shCell(int type)\n{\n    if (type == EMPTY)          return S_EMPTY;\n    if (type == I_ST_ST)        return S_I_ST_ST;\n    if (type == I_ST_CR)        return S_I_ST_CR;\n    if (type == I_CR_CR)        return S_I_CR_CR;\n    if (type == END_CR)         return S_END_CR;\n    if (type == END_FOOT)       return S_END_FOOT;\n    if (type == CORNER_ST_ST)   return S_CORNER_ST_ST;\n    if (type == CORNER_CR_ST)   return S_CORNER_CR_ST;\n    if (type == CORNER_ST_CR)   return S_CORNER_ST_CR;\n    if (type == CORNER_CR_CR)   return S_CORNER_CR_CR;\n    /*if (type == T_ST_CR_ST)*/ return S_T_ST_CR_ST;\n}\n\n// cell probabilities\nfloat probCell(int type)\n{\n    if (type == EMPTY)          return 0.;\n    if (type == I_ST_ST)        return .1;\n    if (type == I_ST_CR)        return .1;\n    if (type == I_CR_CR)        return .1;\n    if (type == END_CR)         return .1;\n    if (type == END_FOOT)       return .1;\n    if (type == CORNER_ST_ST)   return .1;\n    if (type == CORNER_CR_ST)   return .1;\n    if (type == CORNER_ST_CR)   return .1;\n    if (type == CORNER_CR_CR)   return .1;\n    /*if (type == T_ST_CR_ST)*/ return .1;\n\n}\n\n// cell self-connection ability\nbool selfCell(int type)\n{\n    return type == I_ST_ST || type == I_ST_CR || type == I_CR_CR;\n}\n\n#define R1(m) mat3(m[0][2], m[1][2], m[2][2], m[0][1], m[1][1], m[2][1], m[0][0], m[1][0], m[2][0])\n\n// rotate a shape matrix r times to the right\n// NOTE: R1(R1(R1(s))) seems wasteful, but I originally had R2 and R3 and it didn't seem to matter. I believe the optimizer is\n// able to optimize away the extra calculations.\nmat3 rotShape(mat3 s, int r)\n{\n    while (r < 0) r += 4;\n    r = r % 4;\n    if (r == 1) s = R1(s);\n    else if (r == 2) s = R1(R1(s));\n    else if (r == 3) s = R1(R1(R1(s)));\n    \n    return s;\n}\n\nbool tilesMatch(mat3 a, mat3 b) { return a[0][0] == b[2][0] && a[0][1] == b[2][1] && a[0][2] == b[2][2]; }\n\n// compute a bit mask showing which tiles could be compatible with a specfic other tile along one side\nuvec4 findValidTiles(int t, int d, int r)\n{\n    uvec4 valid = uvec4(0);\n    mat3 nShape = rotShape(shCell(t), d + r);\n    uint bit = 2u;\n    \n    for (int i = 1; i < NUM_TILES; ++i)\n    {\n        if (t != i || selfCell(i))\n        {\n            mat3 myShape = shCell(i);\n            for (int d = 0; d < 4; ++d)\n            {\n                if (tilesMatch(rotShape(myShape, d), nShape))\n                {\n                    valid[(d + 4 - r) % 4] |= bit;\n                }\n            }\n        }\n        bit <<= 1;\n    }\n    return valid;\n}\n\nivec2 nDir(int d)\n{\n    if (d == 0) return ivec2(0, 1);\n    if (d == 1) return ivec2(1, 0);\n    if (d == 2) return ivec2(0, -1);\n    /*if (d == 0)*/ return ivec2(-1, 0);\n}\n\n// how many components of the vector, from left to right, are all full of zeroes\nint emptyWords(uvec4 v, out uint top)\n{\n    int n = 0;\n    top = v.x;\n    if (v.x == 0u)\n    {\n        ++n;\n        top = v.y;\n        if (v.y == 0u)\n        {\n            top = v.z;\n            ++n;\n            if (v.z == 0u)\n            {\n                ++n;\n                top = v.w;\n            }\n        }\n    }\n    return n;\n}\n\n// this shouldn't be necessary, but just calling the function directly seems not to work (compiler bug...?)\nvec4 ubtf(uvec4 v)\n{\n    return uintBitsToFloat(v);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   // fxState state = fxGetState(iFrame);\n    ivec2 ifc = ivec2(fragCoord);\n    \n    if (ifc.x == 4 && ifc.y == 2 || ifc.x == 54 && ifc.y == 2)\n    {\n        fragColor = ubtf(uvec4(1u << CORNER_ST_ST, 0, 0, 0));\n        return;\n    }\n    \n    if (ifc.x == 5 && ifc.y == 3 || ifc.x == 55 && ifc.y == 3)\n    {\n        fragColor = ubtf(uvec4(1u << CORNER_CR_CR, 0, 0, 0));\n        return;\n    }\n    \n    if (ifc.x == 4 && ifc.y == 45 || ifc.x == 54 && ifc.y == 45)\n    {\n        fragColor = ubtf(uvec4(0, 0, 0, 1u << CORNER_ST_ST));\n        return;\n    }\n    \n    if (ifc.x == 5 && ifc.y == 44 || ifc.x == 55 && ifc.y == 44)\n    {\n        fragColor = ubtf(uvec4(0, 0, 0, 1u << CORNER_CR_CR));\n        return;\n    }\n    \n    if (ifc.x == 45 && ifc.y == 2 || ifc.x == 95 && ifc.y == 2)\n    {\n        fragColor = ubtf(uvec4(0, 1u << CORNER_ST_ST, 0, 0));\n        return;\n    }\n    \n    if (ifc.x == 44 && ifc.y == 3 || ifc.x == 94 && ifc.y == 3)\n    {\n        fragColor = ubtf(uvec4(0, 1u << CORNER_CR_CR, 0, 0));\n        return;\n    }\n    \n    if (ifc.x == 45 && ifc.y == 45 || ifc.x == 95 && ifc.y == 45)\n    {\n        fragColor = ubtf(uvec4(0, 0, 1u << CORNER_ST_ST, 0));\n        return;\n    }\n    \n    if (ifc.x == 44 && ifc.y == 44 || ifc.x == 94 && ifc.y == 44)\n    {\n        fragColor = ubtf(uvec4(0, 0, 1u << CORNER_CR_CR, 0));\n        return;\n    }\n    \n    if (ifc.y > 45 || ifc.y < 2 || ifc.x < 4 || ifc.x > 95 || ifc.x > 45 && ifc.x < 54)\n    {\n        fragColor = ubtf(uvec4(1, 0, 0, 0));\n        return;\n    }\n    \n    if (ifc.y == 45 || ifc.y == 2)\n    {\n        fragColor = ubtf(uvec4(0, 2, 0, 0));\n        return;\n    }\n    \n    if (ifc.x == 95 || ifc.x == 4 || ifc.x == 45 || ifc.x == 54)\n    {\n        fragColor = ubtf(uvec4(2, 0, 0, 0));\n        return;\n    }\n\n    if (ifc.y == 44 || ifc.y == 3)\n    {\n        fragColor = ubtf(uvec4(0, 8, 0, 0));\n        return;\n    }\n    \n    if (ifc.x == 94 || ifc.x == 5 || ifc.x == 44 || ifc.x == 55)\n    {\n        fragColor = ubtf(uvec4(8, 0, 0, 0));\n        return;\n    }\n\n\n    if (ifc.y >= 43 || ifc.y == 4 || ifc.x == 6 || ifc.x >= 93 || ifc.x == 43 || ifc.x == 56)\n    {\n        fragColor = ubtf(uvec4(1, 0, 0, 0));\n        return;\n    }\n    \n    if (keyDown(KEY_SPACE) ||\n        iFrame == 0)\n    {\n        // reset\n        fragColor = uintBitsToFloat(MAX_UVEC4);\n        \n        return;\n    }\n\n    fragColor = texelFetch(iChannel0, ifc, 0);\n\n    // update on staggered checkerboard pattern, to ensure no cell updates at the same time as its neighbor\n    if (((ifc.x + ifc.y) & 1) != (iFrame & 1)) return;\n    \n    vec3 h = hash3(uvec3(ifc, iFrame));\n    if (countBits(floatBitsToUint(fragColor)) == 1)\n    {\n        // if we've collapsed to a single state already, only just consider backtracking, sometimes\n        if (h.x < .25)\n        {\n            for (int d = 0; d < 4; ++d)\n            {\n                uvec4 n = floatBitsToUint(texelFetch(iChannel0, ifc + nDir(d), 0));\n                if (n == uvec4(0))\n                {\n                    fragColor = uintBitsToFloat(MAX_UVEC4); // neighbor is in trouble, revert\n                    return;\n                }\n\n            }\n        }\n        \n        return;\n    }\n\n    // compute the valid placements given our non-empty neighbors\n    uvec4 valid = MAX_UVEC4;\n    for (int d = 0; d < 4; ++d)\n    {\n        uvec4 n = floatBitsToUint(texelFetch(iChannel0, ifc + nDir(d), 0));\n        if (n != MAX_UVEC4)\n        {\n            if (countBits(n) == 1) // neighbor has collapsed to a single state, use it to limit our own possibilities\n            {\n                uint top;\n                int rot = emptyWords(n, top);\n                int type = log2int(top);\n\n                uvec4 nResult = findValidTiles(type, rot, d);\n\n                valid &= nResult;\n                if (valid == uvec4(0)) break;\n            }\n        }\n    }\n    \n    if (valid == MAX_UVEC4)\n    {\n        // if we have no collapsed neighbors, there's a chance we might collapse spontaneously\n        if (h.x < 1e-5)\n        {\n            valid = uvec4(0);\n            int rot = int(h.y * 1000.) % 4;\n            int type = int(h.z * 1000.) % NUM_TILES;\n            valid[rot] = (1u << type);\n        }\n    }\n    else // if we have collapsed neighbors, consider collapsing ourseles\n    {\n        uint top;\n        int rot = emptyWords(valid, top);\n        int numValid = countBits(valid);\n        int choice = int(h.y * 1000.) % numValid;\n        \n        // strip off 1 bit, \"choice\" times\n        while(choice > 0)\n        {\n            top &= (top - 1u);\n            if (top == 0u)\n            {\n                valid[rot] = 0u;\n                top = valid[++rot];\n            }\n            if (rot > 3) break;\n            choice--;\n        }\n        \n        // last remaining highest bit is chosen one\n        int type = log2int(top);\n        \n        // last chance rejection by probability, unless we're the only choice left\n        if (h.z < probCell(type) || numValid == 1)\n        {\n            // install the chosen valid tile\n            valid = uvec4(0);\n            valid[rot] = (1u << type);\n        }\n    }\n\n    fragColor = uintBitsToFloat(valid);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}