{
    "Shader": {
        "info": {
            "date": "1503594698",
            "description": "a rounder shaped menger sponge, I was inspired by ollj and [url=https://www.shadertoy.com/view/XsfczB]cylinder sponge[/url] by russ.",
            "flags": 48,
            "hasliked": 0,
            "id": "4tXyzN",
            "likes": 3,
            "name": "cylinder menger sponge",
            "published": 3,
            "tags": [
                "fractal",
                "cylinder",
                "mengersponge"
            ],
            "usePreview": 0,
            "username": "abje",
            "viewed": 645
        },
        "renderpass": [
            {
                "code": "//by iq https://www.shadertoy.com/view/XljGDy\nvec2 circle(in vec2 rd, in vec3 sph )\n{\n    vec2 oc = sph.xy;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.z*sph.z;\n    float h = b*b - c;\n    if( h<0.0 || dot(sph.xy,sph.xy) > sph.z*sph.z) return vec2(0.0);\n    h = sqrt( h );\n    return -b + vec2(-h,h);\n}\n\nvec2 circle2(in vec2 rd, in vec3 sph )\n{\n    vec2 oc = sph.xy;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.z*sph.z;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(1000.0);\n    h = sqrt( h );\n    return -b + vec2(-h,h);\n}\n\nvec4 cylinder(vec3 ray, vec3 pos, float size, vec3 raylen) {\n    vec3 lens = vec3(\n        circle((ray.yz)*raylen.x,vec3(pos.yz,size)).y*raylen.x,\n    \tcircle((ray.xz)*raylen.y,vec3(pos.xz,size)).y*raylen.y,\n        circle((ray.xy)*raylen.z,vec3(pos.xy,size)).y*raylen.z);\n    \n    vec3 mask = vec3(greaterThan(lens,max(lens.yzx,lens.zxy)));\n    float len = dot(lens,mask);\n    \n    return vec4(len, (pos+ray*dot(lens,mask))*(1.0-mask)/size);\n}\n\nvec4 getdata(int index) {\n    ivec2 p;\n    p.x = index%int(iResolution.x);\n    p.y = index/int(iResolution.x);\n    return texelFetch(iChannel0,p,0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy*2.0-iResolution.xy)/iResolution.y;\n    \n    vec4 rotcam = getdata(camrot);\n    \n    vec3 normal;\n    vec3 ray = normalize(vec3(uv,1.0));\n    \n\n    ray.zy *= rot(rotcam.y);\n    ray.zx *= rot(rotcam.x);\n    \n    \n    vec3 raylen = 1.0/vec3(\n        length(ray.yz),\n        length(ray.xz),\n        length(ray.xy));\n    vec3 pos = getdata(campos).xyz;\n    \n    const vec2 magicnum = vec2(1.0,-1.0);\n    \n    vec2 num = max(max(\n        circle2((ray.yz)*raylen.x,vec3(pos.yz,3.0))*raylen.x*magicnum,\n        circle2((ray.xz)*raylen.y,vec3(pos.xz,3.0))*raylen.y*magicnum),\n        circle2((ray.xy)*raylen.z,vec3(pos.xy,3.0))*raylen.z*magicnum)*magicnum;\n    \n    num.x = max(num.x,0.0);\n    \n    //uncomment for repeating fractal\n    //num = vec2(0,1000000);\n    \n    pos += ray * num.x;\n    float dist = num.x;\n    for (int i = 0; i < 6; i++) {\n        float len = 0.0;\n        for (float j = 1.0; j > exp(-(6.0-0.9)*log(3.0)); j /= 3.0) {\n        \tvec3 p = mod(pos+3.0*j,6.0*j)-3.0*j;\n            vec4 len2 = cylinder(ray, p, j, raylen);\n            \n            if (len2.x > len) {\n                normal = -len2.yzw;\n            \tlen = max(len2.x,len);\n            }\n        }\n        dist += len;\n        \n        if (len < 0.00001 || dist > num.y) {\n            break;\n        }\n        pos += ray*len;\n    }\n    if (dist < num.y) {\n        fragColor = vec4(0.5*normal+0.5,1.0);\n        fragColor *= 1.0/(dist*dist*0.001+1.0);\n    } else {\n        fragColor = vec4(0);\n    }\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float getkey(int x, int y)\n{\n    return texelFetch(iChannel1,ivec2(x,y),0).x;\n}\n\nvec4 getdata(int index) {\n    ivec2 p;\n    p.x = index%int(iResolution.x);\n    p.y = index/int(iResolution.x);\n    return texelFetch(iChannel0,p,0);\n}\nvec4 updatedata(int index) {\n    vec4 data = getdata(index);\n    \n    vec4 iMouse2 = getdata(lastmouse);\n    \n    \n    bool refresh = iFrame == 0;\n    \n    if (index == lastmouse) {\n        return iMouse;\n    } else if (index == campos) {\n        \n        if (refresh) {\n            return vec4(0,0,-3.0,1);\n        }\n        \n        vec4 rotcam = getdata(camrot);\n        \n        vec3 move = vec3(getkey(MOVE_RIGHT,0)-getkey(MOVE_LEFT,0),\n                         getkey(MOVE_UP   ,0)-getkey(MOVE_DOWN,0),\n                         getkey(MOVE_FORW ,0)-getkey(MOVE_BACK,0));\n        \n        move.zy *= rot(rotcam.y);\n        move.zx *= rot(rotcam.x);\n        \n        \n        vec3 newpos = data.xyz+movespeed*move*iTimeDelta;\n        \n        data.xyz = newpos;\n        \n        return data;\n    } else if (index == camrot) {\n        \n        if (refresh) {\n            return vec4(0);\n        }\n        \n        if (min(iMouse2.z,iMouse.z) > 0.5) {\n            data.xy += (iMouse.xy-iMouse2.xy)/iResolution.y*sensitivity;\n        }\n        return data;\n    }\n    \n    \n    return data;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n    fragColor = updatedata(coord.x+coord.y*int(iResolution.x));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define lastmouse 0\n#define campos 1\n#define camrot 2\n\n#define rot(A) mat2(cos(A),-sin(A),sin(A),cos(A))\n\n#define sensitivity 3.0\n#define movespeed 0.2\n\n//keyboard keys\n#define KEY_UP    38\n#define KEY_DOWN  40\n#define KEY_RIGHT 39\n#define KEY_LEFT  37\n#define KEY_SHIFT 16\n#define KEY_CTRL  17\n\n//movement keys\n#define MOVE_FORW   KEY_UP\n#define MOVE_LEFT   KEY_LEFT\n#define MOVE_RIGHT  KEY_RIGHT\n#define MOVE_BACK   KEY_DOWN\n#define MOVE_UP     KEY_SHIFT\n#define MOVE_DOWN   KEY_CTRL\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}