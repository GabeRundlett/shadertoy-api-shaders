{
    "Shader": {
        "info": {
            "date": "1692188104",
            "description": "Second round of the shader battle for Demodulation2023 won the 3rd place and qualified me for the final here https://www.shadertoy.com/view/DtjcRd\nConverted using https://github.com/TheNuSan/BonzomaticToShadertoy",
            "flags": 0,
            "hasliked": 0,
            "id": "ctjyzd",
            "likes": 6,
            "name": "Demodulation2023 round 1",
            "published": 3,
            "tags": [
                "shadershowdown",
                "demodulation"
            ],
            "usePreview": 0,
            "username": "z0rg",
            "viewed": 166
        },
        "renderpass": [
            {
                "code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n// Converted using NuSan's converter\n// https://github.com/TheNuSan/BonzomaticToShadertoy\n\nfloat lenny(vec2 v)\n{\n    return abs(v.x) + abs(v.y);\n}\n\nfloat hash11(float seed)\n{\n    return fract(sin(seed * 123.456) * 123.456);\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    vec3 r = normalize(cross(rd, vec3(0.0, 1.0, 0.0)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize((rd + (r * uv.x)) + (u * uv.y));\n}\n\nmat2 r2d(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(vec2(c, -s), vec2(s, c));\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p) - s;\n    return max(l.x, max(l.y, l.z));\n}\n\nfloat map(inout vec3 p)\n{\n    float pix = 0.05;\n    p = floor(p / vec3(pix)) * pix;\n    vec3 op = p;\n    float rep = 2.0;\n    float param = (p.z * 0.1) * sin(iTime);\n    vec3 _140 = p;\n    vec2 _142 = _140.xy * r2d(param);\n    p.x = _142.x;\n    p.y = _142.y;\n    p.z += (iTime+texture(iChannel0, vec2(0.0,0.)).x * 1.0);\n    p.z = mod(p.z + (rep * 0.5), rep) - (rep * 0.5);\n    float _174 = p.z;\n    vec3 _180 = p;\n    vec2 _182 = _180.xy * mix(0.5, 1.0, (sin(_174 * 2.0) * 0.5) + 0.5);\n    p.x = _182.x;\n    p.y = _182.y;\n    vec3 param_1 = p;\n    vec3 param_2 = vec3(1.0, 1.0, 0.1);\n    float shape = _cube(param_1, param_2);\n    vec3 param_3 = p;\n    vec3 param_4 = vec3(0.99, 0.99, 1.0);\n    shape = max(shape, -_cube(param_3, param_4));\n    float ground = ((-op.y) + 5.0) - (texture(iChannel3, (op.xz * 0.01) + vec2(0.0, iTime * 0.03)).x * 10.0);\n    shape = min(shape, ground);\n    return shape;\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(0.0);\n    float param = floor(iTime);\n    float param_1 = floor(-iTime);\n    vec3 ro = vec3((hash11(param) - 0.5) * 5.0, (hash11(param_1) - 0.5) * 3.0, -5.0);\n    vec3 ta = vec3(0.0);\n    vec3 rd = normalize(ta - ro);\n    vec3 param_2 = rd;\n    vec2 param_3 = uv;\n    rd = getCam(param_2, param_3);\n    vec2 param_4 = uv;\n    col = vec3(1.0, 0.0, 0.2) * (1.0 - clamp(lenny(param_4), 0.0, 1.0));\n    vec3 p = ro;\n    vec3 accCol = vec3(0.0);\n    for (int i = 0; i < 128; i++)\n    {\n        vec3 param_5 = p;\n        float _297 = map(param_5);\n        float res = _297;\n        if (res < 0.01)\n        {\n            col = vec3(0.1);\n            if (p.y > 1.0)\n            {\n                vec3 rgb = mix(vec3(1.0, 0.0, 0.2), vec3(0.0), vec3(sin((p.y * 5.0) + iTime)));\n                col = (rgb * clamp(sin(p.y * 50.0) - 0.5, 0.0, 1.0)) * 2.0;\n            }\n        }\n        if (p.y < 1.0)\n        {\n            accCol += ((vec3((sin(p.z) * 0.2) + 0.8, 0.5, 1.0) * (1.0 - clamp(res / 0.5, 0.0, 1.0))) * 0.1);\n        }\n        p += (rd * res);\n    }\n    col += accCol;\n    col = pow(col, vec3(2.2));\n    return col;\n}\n\nvec3 rdr2(vec2 uv)\n{\n    vec2 off = (vec2(0.01, 0.0) * texture(iChannel0, vec2(0.2,0.)).x) * 1.0;\n    vec3 col = vec3(0.0);\n    vec2 param = uv + off;\n    col.x = rdr(param).x;\n    vec2 param_1 = uv;\n    col.y = rdr(param_1).y;\n    vec2 param_2 = uv - off;\n    col.z = rdr(param_2).z;\n    return col;\n}\n\nvoid mainImage( out vec4 out_color, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.xy.x, fragCoord.y / iResolution.xy.y);\n    uv -= vec2(0.5);\n    uv /= vec2(iResolution.xy.y / iResolution.xy.x, 1.0);\n    uv *= (2.0 - (length(uv) * 2.0));\n    vec2 m = vec2(0.0);\n    m.x = atan(uv.x / uv.y) / 3.14;\n    vec2 param = uv;\n    m.y = (1.0 / mix(lenny(param), length(uv), -1.0)) * 0.2;\n    float d = m.y;\n    float f = (texture(iChannel0, vec2(d, 0.)).x * 1.0) * 0.1;\n    vec3 col = vec3(1.0) * f;\n    vec2 param_1 = uv;\n    col += rdr2(param_1);\n    out_color = vec4(col, 1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 19,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}