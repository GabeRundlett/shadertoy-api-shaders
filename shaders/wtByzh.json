{
    "Shader": {
        "info": {
            "date": "1594043161",
            "description": "A transformed heptagon-pentagon tiling of the plane.",
            "flags": 0,
            "hasliked": 0,
            "id": "wtByzh",
            "likes": 47,
            "name": "Heptagon-Pentagon Tiling",
            "published": 3,
            "tags": [
                "inversion",
                "tile",
                "transform",
                "pentagon",
                "heptagon"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 762
        },
        "renderpass": [
            {
                "code": "/*\n\n\tHeptagon-Pentagon Tiling\n\t------------------------\n\n\tYou can learn a lot from looking at stock images on the internet.\n\tThis particular aesthetic is my own, but it encompasses a few\n\tcommon geometric vector graphics cliches -- Colorful highlights, \n    vector borders and weird canvas coordinate manipulation. All are \n    very simple to produce.\n\n\tThis is a heptagon and pentagon tiling arrangement that you may\n\thave seen around. I have a nice neat example somewhere, but I \n\tcouldn't find it, so I've hacked in a function from an extruded\n\t3D tiling I made a while back that needs a bit of a tidy up. By\n\tthe way, I'll post that too at some stage.\n\n\tThe tiling method I've used is OK, but there are better ways to \n    produce a heptagon pentagon tiling, so I wouldn't pay too much\n\tattention to it. Having said that, it works, and will work in\t\n\tan extruded 3D setting as well.\n\n\tI've used a standard circle inversion based transformation to mix\n\tthings up a bit and give some extra perspective. It was tempting\n\tto apply some post processing, like hatching or something along\n\tthe lines of Flockaroo's pencil sketch algorithm, but I figured\n\tI should keep things simple.\n\n\n*/\n\n// Show the individual tile boundaries.\n//#define SHOW_GRID\n\n// Perform a coordinate transform. Commenting this out will show the regular pattern.\n#define TRANSFORM\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n\n// Very handy. I should write my own, but this works. I\n// rearranged it a bit, but it's the same function.\n//\n// Smooth Floor - Anastadunbar \n// https://www.shadertoy.com/view/lljSRV\nfloat floorSm(float x, float c) {\n    \n    float ix = floor(x); x -= ix;\n    return (pow(x, c) - pow(1.- x, c))/2. + ix;\n}\n\n\n// Signed distance to a regular heptagon -- Based on IQ's pentagon function.\nfloat sdHeptagon( in vec2 p, in float r){\n    \n    // PI/7: cos, sin, tan.\n    const vec3 k = vec3(.9009688679, .43388373911, .4815746188); \n    p.y = -p.y;\n    p.x = abs(p.x);\n    p -= 2.*min(dot(vec2(-k.x, k.y), p), 0.)*vec2(-k.x, k.y);\n    p -= 2.*min(dot(vec2(k.x, k.y), p), 0.)*vec2(k.x, k.y);\n    p -= 2.*min(dot(vec2(-k.x, k.y), p), 0.)*vec2(-k.x, k.y);\n\tp -= vec2(clamp(p.x, -r*k.z, r*k.z), r);    \n    return length(p)*sign(p.y);\n    \n}\n\n// Convex pentagon routine -- Adapted from IQ's triangle routine. \nfloat sdPent(in vec2 p, in vec2[5] v){\n    \n    vec2[5] e;\n    for(int i = 0; i<4; i++) e[i] = v[i + 1] - v[i];\n    e[4] = v[0] - v[4];\n   \n    float s = sign( e[0].x*e[4].y - e[0].y*e[4].x );\n    vec2 d = vec2(1e5);\n    \n    for(int i = 0; i<5; i++){\n        v[i] = p - v[i];\n        vec2 pi = v[i] - e[i]*clamp( dot(v[i], e[i])/dot(e[i], e[i]), 0., 1.);\n        d = min(d, vec2(dot(pi, pi), s*(v[i].x*e[i].y - v[i].y*e[i].x)));\n    }\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n\n// Some constants that help determine the geometry. This is a messy function. I have a \n// cleaner one somewhere, so I'll drop that in at some stage. These are just heptagon\n// and pentagon heights, widths and apothems (center to mid edge point).\nconst float PI = 3.14159;\nconst float rad7 = .5;\nconst float apothem7 = (rad7*cos(PI/7.));\nconst float side7 = rad7*sin(PI/7.)*2.;\nconst float width7s = side7*cos(2.*PI/7.);\nconst float width7 = (side7*cos(PI/7.) + side7/2.);\nconst float yDiff = (2.*apothem7*sin(.5*PI/7.));\nconst float h = sqrt(apothem7*apothem7*4. - (width7 + width7s)*(width7 + width7s));\n\nconst vec2 s = vec2(width7*2. + width7s*2., (apothem7 + apothem7 + h));\nconst vec2 s2 = s*vec2(1, 2);\nconst float yh = s.y - apothem7 - rad7;\n\n// Extra variables hacked in at the last miniute. I needed the local coordinates and\n// needed to calculate the pentagon dots seperately... I'll tidy these up later.\nvec2 pL;\nfloat pDots;\n\n// The heptagon-pentagon distance field: By the way, I poached this from a 3D extruded \n// tiling example I did a while back, so you can actually render this in a more efficient \n// manner in 2D.\n//\n// Off the top of my head, the easier 2D way involves rendering two sets of repeat heptagons \n// on a tile of dimensions that involve the figures above, and the remaining space will be \n// that of the slightly irregular pentagon. There's some alternate tile flipping involved, \n// but that's about it. \n//\n// I might produce the simpler form at some stage and post it. As mentioned, the benefit\n// of the following procedure is that it'll work in an extruded setting. Plus, you have\n// access to vertex information, etc. For more advanced imagery, you need the vertex \n// information, and so forth.\n//\nvec4 distField(vec2 p){\n    \n    \n    // Shape distance field holder. There are six in all. Four heptagons and two pentagons.\n    float[6] pl;\n    // Centers of the six individual polygons that represent a single tile. Use the show\n    // grid borders option to see more clearly.\n    vec2[6] pCntr = vec2[6](vec2(0, 0), vec2(width7s + width7, yDiff), \n                            vec2(0, -apothem7*2.), vec2(width7s + width7, apothem7*2. + yDiff),\n                            vec2(0, yDiff/2.), vec2(0, yDiff/2.));\n    \n    // Shape IDs and local coordinates.\n    vec2[6] ip;\n    vec2[6] pLoc;\n    \n    // Using the information above to produce four heptagons.\n    vec2 oP = p - pCntr[0];\n    ip[0] = floor(p/s2);\n    p = mod(p, s2) - s2/2.;\n    pLoc[0] = p;\n    pl[0] = sdHeptagon(p, apothem7);\n   \n    p = oP - pCntr[1];\n    ip[1] = floor((p)/s2);\n    p = mod(p, s2) - s2/2.;\n    pLoc[1] = p;\n    pl[1] = sdHeptagon((p)*vec2(1, -1), apothem7); \n    \n    p = oP - pCntr[2];\n    ip[2] = floor((p)/s2);\n    p = mod(p, s2) - s2/2.;\n    pLoc[2] = p;\n    pl[2] = sdHeptagon((p)*vec2(1, -1), apothem7); \n    \n    p = oP - pCntr[3];\n    ip[3] = floor((p)/s2);\n    p = mod(p, s2) - s2/2.;\n    pLoc[3] = p;\n    pl[3] = sdHeptagon(p, apothem7); \n\n\n    // Producing the two pentagons, plus some outer vertex dots.\n    p = oP - pCntr[4];\n    ip[4] = floor((p)/s);\n    \n    \n    if(mod(ip[4].y, 2.)<.5){\n       p.x -= s.x/2.;\n       ip[4] = floor((p)/s);\n    }\n\n    p = mod(p, s) - s/2.;\n    \n    ip[5] = ip[4];\n   \n    // Pentagon vertices.\n    vec2[5] v;\n    v[0] = vec2(-s.x/2. + side7/2., 0);\n    v[1] =  v[0] + rot2(-PI*2./7.)*vec2(side7, 0);\n    v[2] = vec2(0, yh);\n    v[3] = vec2(0, -yh);\n    v[4] =  v[0] + rot2(PI*2./7.)*vec2(side7, 0);\n    \n    // Pentagon one.\n    pl[4] = sdPent(p, vec2[5]( v[0], v[1], v[2], v[3], v[4]));\n    \n    pCntr[4] = (v[0] + v[1] + v[2] + v[3] + v[4])/5.;\n    \n    // The pentagon outer dots.\n    pDots = 1e5;\n    for(int i = 0; i<5; i++){\n      pDots = min(pDots, length(p - v[i]));\n    }\n    \n    pLoc[4] = p - pCntr[4];\n  \n    // Pentagon two. Same vertices, but with the local coordinates mirrored\n    // acress the X-axis.\n    pl[5] = sdPent(p*vec2(-1, 1), vec2[5]( v[0], v[1], v[2], v[3], v[4]));\n    pLoc[5] = p;\n    pCntr[5] = (v[0] + v[1] + v[2] + v[3] + v[4])*vec2(-1, 1)/5.;\n    pLoc[5] = p - pCntr[5];\n    \n    // Other pentagon outer dots.\n    for(int i = 0; i<5; i++){\n      pDots = min(pDots, length(p*vec2(-1, 1) - v[i]));\n    }    \n    \n    // Iterate through each of the six polygons, then return the minimum\n    // distance, local coordinates, ID, etc.\n    float minD = 1e5;\n    vec2 pID = vec2(0);\n    vec2 si = s2;\n    \n    int cID; \n    for(int i = 0; i<6; i++){\n        \n        if(i>3) si = s;\n        if(pl[i]<minD){\n            \n             minD = pl[i];\n             pID = ip[i]*si + pCntr[i];\n             cID = i;\n             pL = pLoc[i];\n           \n        }\n        \n    } \n    \n    // Retrun the minimum distance, shape center ID, and shape number.\n    return vec4(minD, pID, cID);\n}\n\n// The tile grid borders. Alternate rows are offset by\n// half a grid cell.\nfloat gridField(vec2 p){\n    \n    vec2 ip = floor(p/s);\n    if(mod(ip.y, 2.)<.5) p.x += s.x/2.;\n    ip = floor(p/s);\n    p = abs(mod(p, s) - s/2.);\n    return abs(max(p.x - .5*s.x, p.y - .5*s.y)) - .01;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Aspect correct screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n   \n   \n    // For all intents and purposes, this is just a fancy coordinate transformation.  For \n    // instance, \"uv = vec2(log(length(uv)), atan(uv.y, uv.x)/PI/2.*(width7 + width7s)*2.5)\" \n    // will polar transform things, and something like \"uv.y += sin(uv.x*a)*b\" will make\n    // things look wavy. This particular one is a cool circle inversion formula that people \n    // like MLA, S2C, Mattz, etc, use when they're putting together hyperbolic geometry and \n    // so forth. On a side note, I'll be putting a couple of those up pretty soon. \n    #ifdef TRANSFORM\n    // I can't remember who uses this particular style (MLA?), but many use it, and it's the \n    // one I prefer.\n    //vec2 m = vec2((2.*iMouse.xy - iResolution.xy)/iResolution.y);\n    vec2 m = vec2(cos(iTime/8.), -sin(iTime/4.))*.5;\n    float k = 1./dot(m, m);\n    vec2 c = k*m; // Circle inversion.\n    float tk = (k - 1.)/dot(uv - c, uv - c);\n    uv = tk*uv + (1. - tk)*c;\n    uv.x = -uv.x; // Maintain chirality.\n    uv = rot2(-iTime/8.)*uv;\n    #endif\n    \n    \n    // Scaling and translation.\n    float gSc = 4.;\n    vec2 p = uv*gSc - vec2(-1, -.5)*iTime/2.;\n    // Smoothing factor.\n     float sf = 1./iResolution.y*gSc;\n    \n    // The pentagon and heptagon tiling.\n    vec4 d = distField(p);\n    // The individual shape ID.\n    float cID = d.w;\n    \n     \n    // Set the background color to white.\n    vec3 col = vec3(1);\n    \n     \n    // Use the pixel angle within each individual shape to produce some angular\n    // colors, which gives the effect of light bouncing offs of cones.\n\n    // Using the shape ID to set the vertice number.\n    float n = cID<3.5? 7. : 5.;\n    // Rotate each shape, depending on its ID.\n    float oN = 0.;\n    if(cID == 1. || cID == 2.) oN = .5;\n    if(cID == 4.) oN = .25;\n    if(cID == 5.) oN = .75;\n    \n    // Rotate the shape's local coordinates.\n    vec2 q = pL;\n    q *= rot2(-oN/n*PI*2.);\n    \n    // Get the pixel angle.\n    float ang = mod(atan(q.x, q.y), 6.2831);\n    // Snapping the angle to one of five or seven palette colors. Note the smooth floor\n    // function to give smoother edges. I can thank Anastadunbar for that. :)\n    float iang = floorSm(ang*n/(PI*2.), .15)/n;\n    // The pentagons aren't nice symmetrical reqular pentagons, so the colored wedges\n    // aren't evenly spread out. This is just a quick hack to move a couple of lines.\n    if(cID == 5. && n==5. && abs(iang - 4./5.)<.1) iang = floorSm((ang - .2)*n/(PI*2.), .15)/n;\n    if(cID == 5. && n==5. && abs(iang - 4./5.)<.1) iang = floorSm((ang + .2)*n/(PI*2.), .15)/n;\n    if(cID == 4. && n==5. && abs(iang - 1./5.)<.1) iang = floorSm((ang - .2)*n/(PI*2.), .15)/n;\n    if(cID == 4. && n==5. && abs(iang - 1./5.)<.1) iang = floorSm((ang + .2)*n/(PI*2.), .15)/n;\n    \n     \n    \n    // Utilizing IQ's versatile palette formula to produce some angular colors. If\n    // I were only allowed to use one simple palette formula, this would be it.\n    vec3 lCol = .55 + .45*cos(iang*6.2831 + vec3(0, 1, 2));\n    // Flat shading override.\n    //lCol = vec3(1);\n    //float rnd = hash21(d.yz);\n    //lCol = .5 + .45*cos(rnd*6.28 + vec3(1, 2, 3));\n    \n    \n \n    // Producing some dots at the heptagonal vertices, then joining them with\n    // the pentagon dots. As an aside, the pentagon vertices where produced \n    // seperatly in the distance function, which is hacky, but it was the best\n    // way I could think of at the time.\n    float hDots = 1e5;\n    vec2 v0 = rot2(-oN/n*PI*2.)*vec2(0, .5);\n    for(int i = 0; i<7; i++){\n        if(n == 5.) break;\n        hDots = min(hDots, length(pL - v0));\n        v0 = rot2(PI*2./float(n))*v0;\n    }\n    // Combining with the pentagon dots. \n    hDots = min(hDots, pDots);\n    \n     \n    // Outer shape borders with some white dots over the top for dotted lines.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, abs(d.x) - .01)));\n    col = mix(col, vec3(1), (1. - smoothstep(0., sf, hDots - .15)));\n\n \n    // Rendering the outer borders.\n    //col = mix(col, vec3(0), (1. - smoothstep(0., sf, d.x + .09 - .035))*.35);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, d.x + .09)));\n    col = mix(col, lCol, (1. - smoothstep(0., sf, d.x + .09 + .05)));\n  \n    // Rendering the outer dots.\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, hDots - .04));\n    // Rings.\n    //col = mix(col, vec3(0), 1. - smoothstep(0., sf, abs(hDots - .04) - .02));\n   \n     \n    #ifdef SHOW_GRID\n    // Grid to show individual tiles.\n    float grid = gridField(p);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, grid - .025))*.9);\n    col = mix(col, vec3(1), (1. - smoothstep(0., sf, grid)));\n    #endif\n\n    // Output to screen\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}