{
    "Shader": {
        "info": {
            "date": "1574465210",
            "description": "WIP. Marching random paths to approximate diffuse light propagation. Use WASD and mouse to move\n",
            "flags": 48,
            "hasliked": 0,
            "id": "wsVSRK",
            "likes": 16,
            "name": "Path marching - sky illumination",
            "published": 3,
            "tags": [
                "ray",
                "fast",
                "pathtracing",
                "marcher"
            ],
            "usePreview": 0,
            "username": "michael0884",
            "viewed": 654
        },
        "renderpass": [
            {
                "code": "/// USE WASD TO MOVE AROUND\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord/iResolution.xy;\n   \n    //tonemapping\n    fragColor = 1. - exp(-pow(abs(texture(iChannel0, pos)),vec4(1./2.2)));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.14159265\n#define FOV 3.\n\n#define MAX_STEPS 256.\n#define MAX_DIST 256.\n#define LOD 0.005\n#define CAMERA_SPEED 0.04\n#define MOUSE_SENSITIVITY 0.005\n\n#define SPP 2.\n#define AVG 0.99\n\n#define N 4.\n\n#define MOUSE_INDX 0\n#define ANGLE_INDX 1\n#define POS_INDX   2\n\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.z;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec3 sdSponge(vec3 p)\n{\n   p.xy = mod(p.xy, 2.44) - 1.22;\n    \n   float d = sdBox(p,vec3(1.0));\n   vec3 res = vec3( d, 1.0, 0.0 );\n\n   float s = 1.0;\n   for( int m=0; m<5; m++ )\n   {\n      vec3 a = mod( p*s, 2.0 )-1.0;\n      s *= 3.0;\n      vec3 r = abs(1.0 - 3.0*abs(a));\n\n      float da = max(r.x,r.y);\n      float db = max(r.y,r.z);\n      float dc = max(r.z,r.x);\n      float c = (min(da,min(db,dc))-1.0)/s;\n\n      if( c>d )\n      {\n          d = c;\n          res = vec3( d, 0.2*da*db*dc, (1.0+float(m))/4.0 );\n      }\n   }\n   return res;\n}\n\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nfloat noise(float t, float seed) {\n    float i = floor(t), f = fract(t);\n    float u = 0.5 - cos(3.14159*f)*0.5;\n    return mix(hash11(i + seed),  hash11(i + 1. + seed), u);\n}\n\nfloat perlin(float t, float seed)\n{\n    float r = 0.f;\n    float f = 1.f;\n    float a = 1.f;\n    for(float i = 0.; i < 5.; i++)\n    {\n        r += noise(f*t, f+seed)*a;\n        f *= 1.4;\n        a *= 0.6;\n    }\n    return r;\n}\n\nvec3 lim_mod(vec3 p, vec3 s)\n{\n    vec3 lim =  mod(p,s) - s*0.5;\n    if(p.z > 1.)\n    {\n        lim.z = p.z - 1.;\n    }\n    return lim;\n}\n\n\nmat3 getCamera(vec2 angles)\n{\n   mat3 theta_rot = mat3(1,   0,              0,\n                          0,   cos(angles.y),  sin(angles.y),\n                          0,  -sin(angles.y),  cos(angles.y)); \n        \n   mat3 phi_rot = mat3(cos(angles.x),   sin(angles.x), 0.,\n        \t\t       -sin(angles.x),   cos(angles.x), 0.,\n        \t\t        0.,              0.,            1.); \n        \n   return theta_rot*phi_rot;\n}\n\nvec3 getRay(vec2 angles, vec2 pos)\n{\n    mat3 camera = getCamera(angles);\n    return normalize(transpose(camera)*vec3(FOV*pos.x, 1., FOV*pos.y));\n}\n\n//Keyboard constants\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "///\n/// UTILITY\n///\n/// Using the GPU as the CPU here, pretty inefficient I guess\n\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame < 1)\n    {\n        fragColor = vec4(0.);\n    }\n    \n    if(fragCoord.x <= N && fragCoord.y <= 1.)\n    {\n        //instruction\n        int I = int(fragCoord.x); \n        fragColor = texelFetch(iChannel0,  ivec2(I,0), 0);\n        switch(I)\n        {\n        case MOUSE_INDX:  //mouse speed calculation \n            if(length(iMouse.zw - iMouse.xy) > 10.)\n  \t\t    {\n   \t\t\t\tfragColor.xy = iMouse.xy - fragColor.zw; // mouse delta\n                if(iFrame < 1)\n                {\n                    fragColor.xy = vec2(0.);\n                }\n            }\n            else\n            {\n\t\t\t\tfragColor.xy = vec2(0.); // mouse delta\n            }\n    \t\tfragColor.zw = iMouse.xy; // mouse pos\n            break;\n            \n        case ANGLE_INDX:  //angle computation\n            vec4 mouse = texelFetch(iChannel0,  ivec2(MOUSE_INDX,0), 0);\n   \t\t\tfragColor.xy += vec2(1,-1)*mouse.xy*MOUSE_SENSITIVITY; // angle delta\n    \t\tfragColor.zw = iMouse.xy; // mouse pos\n            break;\n            \n        case POS_INDX:  //position\n            vec2 mousespeed = texelFetch(iChannel0,  ivec2(MOUSE_INDX,0), 0).xy;\n            vec4 angles = texelFetch(iChannel0,  ivec2(ANGLE_INDX,0), 0);\n            mat3 camera = transpose(getCamera(angles.xy));\n            fragColor.w++;\n            if(length(mousespeed) >0. || isKeyPressed(KEY_Z))\n            {\n                fragColor.w = 0.;\n            }\n            if(isKeyPressed(KEY_UP) || isKeyPressed(KEY_W))\n   \t   \t\t{\n   \t\t\t\tfragColor.xyz += camera[1]*CAMERA_SPEED;\n                fragColor.w = 0.;\n            }\n            if(isKeyPressed(KEY_DOWN) || isKeyPressed(KEY_S))\n   \t   \t\t{\n   \t\t\t\tfragColor.xyz -= camera[1]*CAMERA_SPEED;\n                fragColor.w = 0.;\n            }\n            if(isKeyPressed(KEY_RIGHT) || isKeyPressed(KEY_D))\n   \t   \t\t{\n   \t\t\t\tfragColor.xyz += camera[0]*CAMERA_SPEED;\n                fragColor.w = 0.;\n            }\n            if(isKeyPressed(KEY_LEFT) || isKeyPressed(KEY_A))\n   \t   \t\t{\n   \t\t\t\tfragColor.xyz -= camera[0]*CAMERA_SPEED;\n                fragColor.w = 0.;\n            }\n            if(iFrame < 1)\n            {\n                fragColor.xyz = vec3(0,-4,1);\n            }\n            break;\n            \n        }   \n    } else discard;\n    \n   \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "float light_map(vec3 p)\n{\n    float sd = sdSphere(p - vec3(10.*cos(0.*iTime),30., 50.), 10.);\n    //sd = min(sd, sdSphere(p - vec3(5.*cos(0.8*iTime+3.14),5.*sin(0.8*iTime+3.14), 2.), 0.5));\n    return sd;\n}\n\n\nfloat map(vec3 p)\n{\n    float sd =  min(sdSponge(p).x,sdPlane(p));\n    return sd;\n}\n\n\nvec4 calcGrad( in vec3 pos )\n{\n    vec4 e = vec4(0.0005,-0.0005, 0.25, -0.25);\n    return   (e.zwwz*map( pos + e.xyy ) + \n  \t\t\t  e.wwzz*map( pos + e.yyx ) + \n\t\t\t  e.wzwz*map( pos + e.yxy ) + \n              e.zzzz*map( pos + e.xxx ) )/vec4(e.xxx, 1.);\n}\n\n\nvec4 light( in vec3 pos )\n{\n    vec4 e = vec4(0.0005,-0.0005, 0.25, -0.25);\n    return   (e.zwwz*light_map( pos + e.xyy ) + \n  \t\t\t  e.wwzz*light_map( pos + e.yyx ) + \n\t\t\t  e.wzwz*light_map( pos + e.yxy ) + \n              e.zzzz*light_map( pos + e.xxx ) )/vec4(e.xxx, 1.);\n}\n\nvec4 trace(vec3 p, vec3 ray)\n{\n    float t = 0.;\n    for(float i = 0.; (t < MAX_DIST) && (i < MAX_STEPS); i++)\n    {\n        float DE =map(p + t*ray);\n        t += DE;\n        if(DE < t*LOD)\n        {\n            return vec4(p + t*ray, t);\n        }\n    }\n    return vec4(p + t*ray, t);\n}\n\nvec2 pos;\n#define col vec3(1.,1.,1.)\n#define ligh_atr 0.5\n\nvec3 path_march(vec3 p, vec3 ray, float diffusion, float seed)\n{  \n    float t = 0.;\n    float abs_angl = 0.;\n    vec3 fincol = vec3(1,1,1);\n   \tfloat prev_h = 1e10;\n    float h = 0.;\n    for(float i = 0.; (t < MAX_DIST) && (i <30.); i++)\n    {\n        h = map(p);\n        float ndotr = clamp(2.*(h - prev_h)/(h+prev_h),-1.,1.);\n        float light = ligh_atr*hash33(p+1.+seed).x;\n        //random direction changes + light attraction\n        vec3 datt = light*vec3(0,0,1);\n        vec3 dray = diffusion*((hash33(p+seed)-0.5)*(0.5+0.5*abs(ndotr)) + datt);\n        vec3 pray = ray;\n        ray += dray;\n        ray = normalize(ray); \n        \n        //decreasing the brightness depending on the amount of light oversampling \n        fincol *= col*dot(pray, ray);\n        fincol *= (1. - 8.*light*(1. - dot(pray, ray)));\n        t += h;\n        p += ray*h;\n        prev_h = h;\n        if(abs_angl > 8.*3.14159 || (h >1.5)) break;\n    }\n    \n    fincol *= max(0., sign(p.z-1.5))*40.*texture(iChannel0, ray.zyx).xyz; //the sky illumination stuff \n   \n    return fincol; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized centered pixel coordinates \n    pos = (fragCoord - iResolution.xy*0.5)/max(iResolution.x,iResolution.y);\n    \n    vec2 angles = texelFetch(iChannel1,  ivec2(ANGLE_INDX,0), 0).xy;\n        \n \tvec3 ray = getRay(angles, pos);\n    vec4 p = texelFetch(iChannel1,  ivec2(POS_INDX,0), 0);\n    \n    vec4 res = trace(p.xyz, ray);\n  \n    if(res.w < MAX_DIST)\n    {\n        vec3 n = calcGrad(res.xyz).xyz;\n       \n   \n        for(float i = 0.; i <SPP; i++)\n        {\n            fragColor.xyz += path_march(res.xyz+n*0.005, n, 0.85, iTime+i);\n        }\n        fragColor /= SPP;\n    }\n    else\n    {\n        fragColor = 40.*texture(iChannel0, ray.yzx);\n    }\n    float avg = (p.w <= 1.)?(0.05):(AVG*tanh(p.w*0.05));\n    fragColor = avg*texture(iChannel2, fragCoord/iResolution.xy) +(1.-avg)*fragColor;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}