{
    "Shader": {
        "info": {
            "date": "1583571362",
            "description": "arc",
            "flags": 0,
            "hasliked": 0,
            "id": "WlyXWV",
            "likes": 3,
            "name": "arctest",
            "published": 3,
            "tags": [
                "arc"
            ],
            "usePreview": 0,
            "username": "Del",
            "viewed": 310
        },
        "renderpass": [
            {
                "code": "// testing some 2d shape extrusion\n\n#define AA 2\n#define PI\t3.1415926\n#define TAU 6.2831853\n\n// 2d distance functions by IQ\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb )\n{\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdPie( in vec2 p, in vec2 c, in float r )\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p-c*clamp(dot(p,c),0.0,r)); // c = sin/cos of the aperture\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nfloat opExtrussion( in vec3 p, in float sdf, in float h )\n{\n    vec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat sdHorseshoe( in vec2 p, in vec2 c, in float r, in vec2 w )\n{\n    p.x = abs(p.x);\n    float l = length(p);\n    p = mat2(-c.x, c.y, \n              c.y, c.x)*p;\n    p = vec2((p.y>0.0)?p.x:l*sign(-c.x),\n             (p.x>0.0)?p.y:l );\n    p = vec2(p.x,abs(p.y-r))-w;\n    return length(max(p,0.0)) + min(0.0,max(p.x,p.y));\n}\n\nfloat pizza( vec2 p, vec2 c, float rad1, float rad2)\n{\n    p.x = abs(p.x);\n    \n    vec2 c2 = vec2(c.y,-c.x);\n    \n    float l = -dot(c,p.xy);\n    float q = p.x+c.x*l;\n    float l2;\n    \n    if (max(q,-sign(p.y*c.y)) < 0.0) {\n        l = -length(p.xy);\n    }\n    \n    if (l < 0.0) {\n        l2 = length(p.xy);\n    } else {\n        l2 = dot(c2,p.xy)*sign(c.y);\n    }\n    \n    \n    \n    vec2 a = vec2(max(l2-rad2,rad1-l2),l);\n    \n    return length(max(a,0.0))+min(0.0,max(a.x,a.y));\n}\n\n\nfloat map( in vec3 pos )\n{\n    float fill = (0.5+sin(iTime)*0.5)*PI;\n    \n    vec2 uv = pos.xz;\n    \n    // arc\n    float ta = radians(90.0);\n    float tb =  fill;\n    float rb = 0.1;\n    float d1 = sdArc(uv-vec2(0.0,1.5),vec2(sin(ta),cos(ta)),vec2(sin(tb),cos(tb)), 0.5, rb);  \n\n    // pie\n    float d2 = sdPie(uv,vec2(sin(tb),cos(tb)),0.5);\n    \n    // horseshoe\n    float t = 3.14-fill;\n    vec2  w = vec2(0.0,0.1);\n    //float d3 = sdHorseshoe(uv+vec2(0.0,1.5),vec2(cos(t),sin(t)), 0.5, w);    \n\n    // pizza!\n    \n    \n\tfloat d3 = pizza(uv+vec2(0.0,1.5),vec2(cos(t),sin(t)),0.4,0.5);\n    \n                       \n    d1=min(d1,d2);\n    d1=min(d1,d3);\n    d1 = opExtrussion(pos.zxy,d1,0.1);\n    return d1;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n     // camera movement\t\n    float an = sin(iTime)*0.5;\n    float y = 2.;\n    float dist=1.5;\n    \n    if (iMouse.z>0.5)\n    {\n        an=iMouse.x/iResolution.x*4.0;\n        y = (iMouse.y/iResolution.y)*8.0;\n        y-=4.0;\n        dist=3.0;\n    }\n    \n\tvec3 ro = vec3( dist*cos(an), y, dist*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 8.0;\n        float t = 0.0;\n        for( int i=0; i<80;i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n    \n        // shading/lighting\t\n        vec3 col = vec3(0.6,0.4,0.4);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            vec3 ambcol = vec3(0.4,0.3,0.3)*amb;\n            col = ambcol + vec3(0.6,0.55,0.85)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}