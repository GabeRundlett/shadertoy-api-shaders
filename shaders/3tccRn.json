{
    "Shader": {
        "info": {
            "date": "1608625080",
            "description": "A collection of \"The OpenGL Shading Language, Version 4.60.7\" snippets",
            "flags": 0,
            "hasliked": 0,
            "id": "3tccRn",
            "likes": 1,
            "name": "GLSLLangSpec4607 snippets",
            "published": 3,
            "tags": [
                "cxxswizzle"
            ],
            "usePreview": 0,
            "username": "gwiazdorrr",
            "viewed": 295
        },
        "renderpass": [
            {
                "code": "#define ISOK(x) x // ok\n#define ILGL(x)   // ok, illegal code according to the doc\n#define FAIL(x)   // general fail\n#define SNTX(x)   // failed - syntax error\n#define RSVD(x)   // failed - reserved keyword\n#define OVRL(x)   // failed - overload not found\n#define EXTS(x)   // failed - need an extension\n\n// 4.1. Basic Types\n\n//void _void;\nISOK(bool _bool;)\nISOK(int _int;)\nISOK(uint _uint;)\nISOK(float _float;)\nRSVD(double _double;)\nISOK(vec2 _vec2;)\nISOK(vec3 _vec3;)\nISOK(vec4 _vec4;)\nRSVD(dvec2 _dvec2;)\nRSVD(dvec3 _dvec3;)\nRSVD(dvec4 _dvec4;)\nISOK(bvec2 _bvec2;)\nISOK(bvec3 _bvec3;)\nISOK(bvec4 _bvec4;)\nISOK(ivec2 _ivec2;)\nISOK(ivec3 _ivec3;)\nISOK(ivec4 _ivec4;)\nISOK(uvec2 _uvec2;)\nISOK(uvec3 _uvec3;)\nISOK(uvec4 _uvec4;)\nISOK(mat2 _mat2;)\nISOK(mat3 _mat3;)\nISOK(mat4 _mat4;)\nISOK(mat2x2 _mat2x2;)\nISOK(mat2x3 _mat2x3;)\nISOK(mat2x4 _mat2x4;)\nISOK(mat3x2 _mat3x2;)\nISOK(mat3x3 _mat3x3;)\nISOK(mat3x4 _mat3x4;)\nISOK(mat4x2 _mat4x2;)\nISOK(mat4x3 _mat4x3;)\nISOK(mat4x4 _mat4x4;)\nRSVD(dmat2 _dmat2;)\nRSVD(dmat3 _dmat3;)\nRSVD(dmat4 _dmat4;)\nRSVD(dmat2x2 _dmat2x2;)\nRSVD(dmat2x3 _dmat2x3;)\nRSVD(dmat2x4 _dmat2x4;)\nRSVD(dmat3x2 _dmat3x2;)\nRSVD(dmat3x3 _dmat3x3;)\nRSVD(dmat3x4 _dmat3x4;)\nRSVD(dmat4x2 _dmat4x2;)\nRSVD(dmat4x3 _dmat4x3;)\nRSVD(dmat4x4 _dmat4x4;)\n\n// TODO: update fails\nSNTX(sampler1D _sampler1D;)\nSNTX(texture1D _texture1D;)\nRSVD(image1D _image1D;)\nRSVD(sampler1DShadow _sampler1DShadow;)\nRSVD(sampler1DArray _sampler1DArray;)\nSNTX(texture1DArray _texture1DArray;)\nRSVD(image1DArray _image1DArray;)\nRSVD(sampler1DArrayShadow _sampler1DArrayShadow;)\nISOK(uniform sampler2D _sampler2D;)\nSNTX(texture2D _texture2D;)\nRSVD(image2D _image2D;)\nISOK(uniform highp sampler2DShadow _sampler2DShadow;)\nISOK(uniform highp sampler2DArray _sampler2DArray;)\nSNTX(texture2DArray _texture2DArray;)\nRSVD(image2DArray _image2DArray;)\nISOK(uniform highp sampler2DArrayShadow _sampler2DArrayShadow;)\nRSVD(sampler2DMS _sampler2DMS;)\nSNTX(texture2DMS _texture2DMS;)\nSNTX(image2DMS _image2DMS;)\nRSVD(sampler2DMSArray _sampler2DMSArray;)\nRSVD(texture2DMSArray _texture2DMSArray;)\nSNTX(image2DMSArray _image2DMSArray;)\nRSVD(uniform sampler2DRect _sampler2DRect;)\nSNTX(texture2DRect _texture2DRect;)\nSNTX(image2DRect _image2DRect;)\nRSVD(sampler2DRectShadow _sampler2DRectShadow;)\nISOK(uniform sampler3D _sampler3D;)\nSNTX(texture3D _texture3D;)\nRSVD(image3D _image3D;)\nISOK(uniform samplerCube _samplerCube;)\nSNTX(textureCube _textureCube;)\nRSVD(imageCube _imageCube;)\nISOK(uniform highp samplerCubeShadow _samplerCubeShadow;)\nSNTX(samplerCubeArray _samplerCubeArray;)\nSNTX(textureCubeArray _textureCubeArray;)\nSNTX(imageCubeArray _imageCubeArray;)\nSNTX(samplerCubeArrayShadow _samplerCubeArrayShadow;)\nRSVD(samplerBuffer _samplerBuffer;)\nSNTX(textureBuffer _textureBuffer;)\nRSVD(imageBuffer _imageBuffer;)\nRSVD(subpassInput _subpassInput;)\nRSVD(subpassInputMS _subpassInputMS;)\n\nSNTX(uniform isampler1D _isampler1D;)\nSNTX(uniform itexture1D _itexture1D;)\nRSVD(uniform iimage1D _iimage1D;)\nRSVD(uniform isampler1DArray _isampler1DArray;)\nSNTX(uniform itexture1DArray _itexture1DArray;)\nRSVD(uniform iimage1DArray _iimage1DArray;)\nISOK(uniform highp isampler2D _isampler2D;)\nSNTX(uniform itexture2D _itexture2D;)\nRSVD(uniform iimage2D _iimage2D;)\nISOK(uniform highp isampler2DArray _isampler2DArray;)\nSNTX(uniform itexture2DArray _itexture2DArray;)\nRSVD(uniform iimage2DArray _iimage2DArray;)\nRSVD(uniform isampler2DMS _isampler2DMS;)\nSNTX(uniform itexture2DMS _itexture2DMS;)\nSNTX(uniform iimage2DMS _iimage2DMS;)\nRSVD(uniform isampler2DMSArray _isampler2DMSArray;)\nSNTX(uniform itexture2DMSArray _itexture2DMSArray;)\nSNTX(uniform iimage2DMSArray _iimage2DMSArray;)\nRSVD(uniform isampler2DRect _isampler2DRect;)\nSNTX(uniform itexture2DRect _itexture2DRect;)\nSNTX(uniform iimage2DRect _iimage2DRect;)\nISOK(uniform highp isampler3D _isampler3D;)\nRSVD(uniform itexture3D _itexture3D;)\nRSVD(uniform iimage3D _iimage3D;)\nISOK(uniform highp isamplerCube _isamplerCube;)\nSNTX(uniform itextureCube _itextureCube;)\nRSVD(uniform iimageCube _iimageCube;)\nSNTX(uniform isamplerCubeArray _isamplerCubeArray;)\nSNTX(uniform itextureCubeArray _itextureCubeArray;)\nSNTX(uniform iimageCubeArray _iimageCubeArray;)\nRSVD(uniform isamplerBuffer _isamplerBuffer;)\nSNTX(uniform itextureBuffer _itextureBuffer;)\nRSVD(uniform iimageBuffer _iimageBuffer;)\nSNTX(uniform isubpassInput _isubpassInput;)\nSNTX(uniform isubpassInputMS _isubpassInputMS;)\n\nSNTX(uniform usampler1D _usampler1D;)\nSNTX(uniform utexture1D _utexture1D;)\nRSVD(uniform uimage1D _uimage1D;)\nRSVD(uniform usampler1DArray _usampler1DArray;)\nSNTX(uniform utexture1DArray _utexture1DArray;)\nRSVD(uniform uimage1DArray _uimage1DArray;)\nISOK(uniform highp usampler2D _usampler2D;)\nSNTX(uniform utexture2D _utexture2D;)\nRSVD(uniform uimage2D _uimage2D;)\nISOK(uniform highp usampler2DArray _usampler2DArray;)\nSNTX(uniform utexture1DArray _utexture1DArray;)\nRSVD(uniform uimage2DArray _uimage2DArray;)\nRSVD(uniform usampler2DMS _usampler2DMS;)\nSNTX(uniform utexture2DMS _utexture2DMS;)\nSNTX(uniform uimage2DMS _uimage2DMS;)\nRSVD(uniform usampler2DMSArray _usampler2DMSArray;)\nSNTX(uniform utexture2DMSArray _utexture2DMSArray;)\nSNTX(uniform uimage2DMSArray _uimage2DMSArray;)\nRSVD(uniform usampler2DRect _usampler2DRect;)\nSNTX(uniform utexture2DRect _utexture2DRect;)\nSNTX(uniform uimage2DRect _uimage2DRect;)\nISOK(uniform highp usampler3D _usampler3D;)\nRSVD(uniform utexture3D _utexture3D;)\nRSVD(uniform uimage3D _uimage3D;)\nISOK(uniform highp usamplerCube _usamplerCube;)\nSNTX(uniform utextureCube _utextureCube;)\nRSVD(uniform uimageCube _uimageCube;)\nSNTX(uniform usamplerCubeArray _usamplerCubeArray;)\nSNTX(uniform utextureCubeArray _utextureCubeArray;)\nSNTX(uniform uimageCubeArray _uimageCubeArray;)\nRSVD(uniform usamplerBuffer _usamplerBuffer;)\nSNTX(uniform utextureBuffer _utextureBuffer;)\nRSVD(uniform uimageBuffer _uimageBuffer;)\nRSVD(uniform atomic_uint _atomic_uint;)\nSNTX(uniform usubpassInput _usubpassInput;)\nSNTX(uniform usubpassInputMS _usubpassInputMS;)\n\nSNTX(uniform sampler _sampler;)\nSNTX(uniform samplerShadow _samplerShadow;)\n\n\nvoid _5_4_1_Conversion_and_Scalar_Constructors()\n{\n    ISOK(int(_uint);) // converts an unsigned integer to a signed integer\n    ISOK(int(_bool);) // converts a Boolean value to an int\n    ISOK(int(_float);) // converts a float value to an int\n    RSVD(int(_double);) // converts a double value to a signed integer\n    ISOK(uint(_int);) // converts a signed integer value to an unsigned integer\n    ISOK(uint(_bool);) // converts a Boolean value to an unsigned integer\n    ISOK(uint(_float);) // converts a float value to an unsigned integer\n    RSVD(uint(_double);) // converts a double value to an unsigned integer\n    ISOK(bool(_int);) // converts a signed integer value to a Boolean\n    ISOK(bool(_uint);) // converts an unsigned integer value to a Boolean value\n    ISOK(bool(_float);) // converts a float value to a Boolean\n    RSVD(bool(_double);) // converts a double value to a Boolean\n    ISOK(float(_int);) // converts a signed integer value to a float\n    ISOK(float(_uint);) // converts an unsigned integer value to a float value\n    ISOK(float(_bool);) // converts a Boolean value to a float\n    RSVD(float(_double);) // converts a double value to a float\n    RSVD(double(_int);) // converts a signed integer value to a double\n    RSVD(double(_uint);) // converts an unsigned integer value to a double\n    RSVD(double(_bool);) // converts a Boolean value to a double\n    RSVD(double(_float);) // converts a float value to a double\n}\n\nvoid _5_4_2_Vector_and_Matrix_Constructors()\n{\n    ISOK(vec3(_float);) // initializes each component of the vec3 with the float\n\tISOK(vec4(_ivec4);) // makes a vec4 with component-wise conversion\n\tISOK(vec4(_mat2);) // the vec4 is column 0 followed by column 1\n\tISOK(vec2(_float, _float);) // initializes a vec2 with 2 floats\n\tISOK(ivec3(_int, _int, _int);) // initializes an ivec3 with 3 ints\n\tISOK(bvec4(_int, _int, _float, _float);) // uses 4 Boolean conversions\n\tISOK(vec2(_vec3);) // drops the third component of a vec3\n\tISOK(vec3(_vec4);) // drops the fourth component of a vec4\n\tISOK(vec3(_vec2, _float);) // vec3.x = vec2.x, vec3.y = vec2.y, vec3.z = float\n\tISOK(vec3(_float, _vec2);) // vec3.x = float, vec3.y = vec2.x, vec3.z = vec2.y\n\tISOK(vec4(_vec3, _float);)\n\tISOK(vec4(_float, _vec3);)\n\tISOK(vec4(_vec2, _vec2);)\n\n\tISOK(vec4 color = vec4(0.0, 1.0, 0.0, 1.0);)\n\tISOK(vec4 rgba = vec4(1.0);) // sets each component to 1.0\n\tISOK(vec3 rgb = vec3(color);) // drop the 4th component\n\n\tISOK(mat2(_float);)\n\tISOK(mat3(_float);)\n\tISOK(mat4(_float);)\n\n\tISOK(mat2(_vec2, _vec2);) // one column per argument\n\tISOK(mat3(_vec3, _vec3, _vec3);) // one column per argument\n\tISOK(mat4(_vec4, _vec4, _vec4, _vec4);) // one column per argument\n\tISOK(mat3x2(_vec2, _vec2, _vec2);) // one column per argument\n    RSVD(dmat2(_dvec2, _dvec2);)\n\tRSVD(dmat3(_dvec3, _dvec3, _dvec3);)\n\tRSVD(dmat4(_dvec4, _dvec4, _dvec4, _dvec4);)\n\tISOK(mat2(_float, _float, // first column\n\t _float, _float);) // second column\n\tISOK(mat3(_float, _float, _float, // first column\n\t _float, _float, _float, // second column\n\t _float, _float, _float);) // third column\n\tISOK(mat4(_float, _float, _float, _float, // first column\n\t _float, _float, _float, _float, // second column\n\t _float, _float, _float, _float, // third column\n\t _float, _float, _float, _float);) // fourth column\n\tISOK(mat2x3(_vec2, _float, // first column\n\t _vec2, _float);) // second column\n\tRSVD(dmat2x4(_dvec3, _double, // first column\n\t _double, _dvec3);) // second column\n\n\tISOK(mat3x3(_mat4x4);) // takes the upper-left 3x3 of the mat4x4\n\tISOK(mat2x3(_mat4x2);) // takes the upper-left 2x2 of the mat4x4, last row is 0,0\n\tISOK(mat4x4(_mat3x3);) // puts the mat3x3 in the upper-left, sets the lower right\n\t // component to 1, and the rest to 0\n}\n\nvoid _5_4_3_StructureConstructors()\n{\n    struct light {\n     float intensity;\n     vec3 position;\n    };\n    light lightVar = light(3.0, vec3(1.0, 2.0, 3.0));\n}\n\nvoid _5_4_4_ArrayConstructors()\n{\n    {\n        const float c[3] = float[3](5.0, 7.2, 1.1);\n        const float d[3] = float[](5.0, 7.2, 1.1);\n        float g;\n        // ...\n        float a[5] = float[5](g, 1.0, g, 2.3, g);\n        float b[3];\n        b = float[3](g, g + 1.0, g + 2.0);\n    }\n    {\n        vec4 b[2];\n        RSVD(vec4[3][2](b, b, b);) // constructor\n        RSVD(vec4[][2](b, b, b);) // constructor, valid, size deduced\n        RSVD(vec4[3][](b, b, b);) // constructor, valid, size deduced\n        RSVD(vec4[][](b, b, b);)\n    }\n}\n\nvoid _5_5_Vector_and_Scalar_Components_and_Length()\n{\n    {\n        vec2 pos;\n        float height;\n        pos.x; // is legal\n        ILGL(pos.z;) // is illegal\n        SNTX(height.x;) // is legal\n        ILGL(height.y;) // is illegal\n    }\n    {\n        vec4 v4;\n        v4.rgba; // is a vec4 and the same as just using v4,\n        v4.rgb; // is a vec3,\n        v4.b; // is a float,\n        v4.xy; // is a vec2,\n        ILGL(v4.xgba;) // is illegal - the component names do not come from the same set\n    }\n    {\n        vec4 v4;\n        ILGL(v4.xyzwxy;) // is illegal since it has 6 components\n        ILGL((v4.xyzwxy).xy;) // is illegal since the intermediate value has 6 components\n    }\n    {\n        vec4 pos = vec4(1.0, 2.0, 3.0, 4.0);\n        vec4 swiz = pos.wzyx; // swiz = (4.0, 3.0, 2.0, 1.0)\n        vec4 dup = pos.xxyy; // dup = (1.0, 1.0, 2.0, 2.0)\n    }\n    {\n        vec4 pos = vec4(1.0, 2.0, 3.0, 4.0);\n        pos.xw = vec2(5.0, 6.0); // pos = (5.0, 2.0, 3.0, 6.0)\n        pos.wx = vec2(7.0, 8.0); // pos = (8.0, 2.0, 3.0, 7.0)\n        ILGL(pos.xx = vec2(3.0, 4.0);) // illegal - 'x' used twice\n        ILGL(pos.xy = vec3(1.0, 2.0, 3.0);) // illegal - mismatch between vec2 and vec3\n    }\n    {\n        vec3 v;\n        SNTX(const int L = v.length();)\n    }\n}\n\nvoid _5_6_Matrix_Components()\n{\n    {\n        mat4 m;\n        m[1] = vec4(2.0); // sets the second column to all 2.0\n        m[0][0] = 1.0; // sets the upper left element to 1.0\n        m[2][3] = 2.0; // sets the 4th element of the third column to 2.0\n    }\n    {\n        mat3x4 v;\n        SNTX(const int L = v.length();)\n    }\n}\n\nvoid _5_7_Structure_and_Array_Operations()\n{\n    float diffuseColor, NdotL;\n    float lightIntensity[4];\n    diffuseColor += lightIntensity[3] * NdotL;\n    lightIntensity.length(); // return the size of the array\n}\n\nvoid _5_10_Vector_and_Matrix_Operations()\n{\n    {\n        vec3 v, u;\n        float f;\n        v = u + f;\n        v.x = u.x + f;\n        v.y = u.y + f;\n        v.z = u.z + f;\n    }\n    {\n        vec3 v, u, w;\n        w = v + u;\n        w.x = v.x + u.x;\n        w.y = v.y + u.y;\n        w.z = v.z + u.z;\n    }\n    {\n        vec3 v, u;\n        mat3 m;\n        u = v * m;\n        u.x = dot(v, m[0]); // m[0] is the left column of m\n        u.y = dot(v, m[1]); // dot(a,b) is the inner (dot) product of a and b\n        u.z = dot(v, m[2]);\n        u = m * v;\n        u.x = m[0].x * v.x + m[1].x * v.y + m[2].x * v.z;\n        u.y = m[0].y * v.x + m[1].y * v.y + m[2].y * v.z;\n        u.z = m[0].z * v.x + m[1].z * v.y + m[2].z * v.z;\n    }\n    {\n        mat3 m, n, r;\n        r = m * n;\n        r[0].x = m[0].x * n[0].x + m[1].x * n[0].y + m[2].x * n[0].z;\n        r[1].x = m[0].x * n[1].x + m[1].x * n[1].y + m[2].x * n[1].z;\n        r[2].x = m[0].x * n[2].x + m[1].x * n[2].y + m[2].x * n[2].z;\n        r[0].y = m[0].y * n[0].x + m[1].y * n[0].y + m[2].y * n[0].z;\n        r[1].y = m[0].y * n[1].x + m[1].y * n[1].y + m[2].y * n[1].z;\n        r[2].y = m[0].y * n[2].x + m[1].y * n[2].y + m[2].y * n[2].z;\n        r[0].z = m[0].z * n[0].x + m[1].z * n[0].y + m[2].z * n[0].z;\n        r[1].z = m[0].z * n[1].x + m[1].z * n[1].y + m[2].z * n[1].z;\n        r[2].z = m[0].z * n[2].x + m[1].z * n[2].y + m[2].z * n[2].z;\n    }\n}\n\n// 6.1. Function Definitions\n#define returnType float\n#define type0 float\n#define type1 float\n#define typen float\n\n// prototype\nreturnType functionName (type0 arg0, type1 arg1, typen argn);\n\n// definition\nreturnType functionName (type0 arg0, type1 arg1, typen argn)\n{\n     // do some computation\n     return 0.0;\n}\n\nfloat myfunc (float f, out float g); // g is an output paramete\n\nvoid func1() { }\nILGL(void func2() { return func1(); }) // illegal return statement\n\nvec4 f(in vec4 x, out vec4 y) { return _vec4; } // (A)\nvec4 f(in vec4 x, out uvec4 y) { return _vec4; } // (B) okay, different argument type\nRSVD(vec4 f(in ivec4 x, out dvec4 y);) // (C) okay, different argument type\nILGL(int f(in vec4 x, out vec4 y);) // error, only return type differs\nILGL(vec4 f(in vec4 x, in vec4 y);) // error, only qualifier differs\nILGL(vec4 f(const in vec4 x, out vec4 y);) // error, only qualifier differs\n\nvoid _6_1_test()\n{\n    f(_vec4, _vec4); // exact match of vec4 f(in vec4 x, out vec4 y)\n    f(_vec4, _uvec4); // exact match of vec4 f(in vec4 x, out uvec4 y)\n    OVRL(f(_vec4, _ivec4);) // matched to vec4 f(in vec4 x, out vec4 y)\n     // (C) not relevant, can't convert vec4 to\n     // ivec4. (A) better than (B) for 2nd\n     // argument (rule 3), same on first argument.\n    ILGL(f(_ivec4, _vec4);) // NOT matched. All three match by implicit\n     // conversion. (C) is better than (A) and (B)\n     // on the first argument. (A) is better than\n     // (B) and (C).\n}\n\n\nvoid _6_4_Jumps() \n{\n    float intensity;\n    if (intensity < 0.0)\n        discard;\n    vec4  v = gl_FragCoord;\n}\n\nvoid _7_1_5_Fragment_Shader_Special_Variables()\n{\n    ISOK(gl_FragCoord;)\n    ISOK(gl_FrontFacing;) \n    FAIL(gl_ClipDistance;)\n    FAIL(gl_CullDistance;)\n    ISOK(gl_PointCoord;) \n    FAIL(gl_PrimitiveID; )\n    FAIL(gl_SampleID; )\n    FAIL(gl_SamplePosition;)\n    FAIL(gl_SampleMaskIn;)\n    FAIL(gl_Layer;)\n    FAIL(gl_ViewportIndex;)\n    FAIL(gl_HelperInvocation;)\n    ISOK(gl_FragDepth;)\n    FAIL(gl_SampleMask;)\n}\n\nvoid _7_4_Built_In_Uniform_State()\n{\n    ISOK(gl_DepthRange;)\n    FAIL(gl_NumSamples);\n}\n\nvoid _8_1_Angle_and_Trigonometry_Functions()\n{\n#define _8_1_Angle_and_Trigonometry_Functions(genFType) \\\n    { genFType t = radians(genFType(0)); }\\\n    { genFType t = degrees(genFType(0)); }\\\n    { genFType t = sin(genFType(0)); }\\\n    { genFType t = cos(genFType(0)); }\\\n    { genFType t = tan(genFType(0)); }\\\n    { genFType t = asin(genFType(0)); }\\\n    { genFType t = acos(genFType(0)); }\\\n    { genFType t = atan(genFType(1), genFType(2)); }\\\n    { genFType t = atan(genFType(1)); }\\\n    { genFType t = sinh(genFType(1)); }\\\n    { genFType t = cosh(genFType(1)); }\\\n    { genFType t = tanh(genFType(1)); }\\\n    { genFType t = asinh(genFType(1)); }\\\n    { genFType t = acosh(genFType(1)); }\\\n    { genFType t = atanh(genFType(0)); }\n    \n#define _8_2_Exponential_Functions(genFType)\\\n    { genFType t = pow(genFType(0), genFType(1)); }\\\n    { genFType t = exp(genFType(0)); }\\\n    { genFType t = log(genFType(1)); }\\\n    { genFType t = exp2(genFType(0)); }\\\n    { genFType t = log2(genFType(1)); }\\\n    { genFType t = sqrt(genFType(0)); }\\\n    { genFType t = inversesqrt(genFType(1)); };\n\n#define _8_3_Common_Functions(genFType, genDType, genIType, genUType, genBType)\\\n    ISOK({ genFType t = abs(genFType(0)); })\\\n    ISOK({ genIType t = abs(genIType(0)); })\\\n\tRSVD({ genDType t = abs(genDType(0));; })\\\n    ISOK({ genFType t = sign(genFType(0)); })\\\n    ISOK({ genIType t = sign(genIType(0)); })\\\n    RSVD({ genDType t = sign(genDType(0)); })\\\n    ISOK({ genFType t = floor(genFType(0)); })\\\n    RSVD({ genDType t = floor(genDType(0)); })\\\n    ISOK({ genFType t = trunc(genFType(0)); })\\\n    RSVD({ genDType t = trunc(genDType(0)); })\\\n    ISOK({ genFType t = round(genFType(0)); })\\\n    RSVD({ genDType t = round(genDType(0)); })\\\n    ISOK({ genFType t = roundEven(genFType(0)); })\\\n    RSVD({ genDType t = roundEven(genDType(0)); })\\\n    ISOK({ genFType t = ceil(genFType(0)); })\\\n    RSVD({ genDType t = ceil(genDType(0)); })\\\n    ISOK({ genFType t = fract(genFType(0)); })\\\n    RSVD({ genDType t = fract(genDType(0)); })\\\n    ISOK({ genFType t = mod(genFType(0), float(0)); })\\\n    ISOK({ genFType t = mod(genFType(0), genFType(0)); })\\\n    RSVD({ genDType t = mod(genDType(0), double(0)); })\\\n    RSVD({ genDType t = mod(genDType(0), genDType(0)); })\\\n    ISOK({ genFType o; genFType t = modf(genFType(0), o); })\\\n    RSVD({ genDType t = modf(genDType(0), genDType(0)); })\\\n    ISOK({ genFType t = min(genFType(0), genFType(0)); })\\\n    ISOK({ genFType t = min(genFType(0), float(0)); })\\\n    RSVD({ genDType t = min(genDType(0), genDType(0)); })\\\n    RSVD({ genDType t = min(genDType(0), double(0)); })\\\n    ISOK({ genIType t = min(genIType(0), genIType(0)); })\\\n    ISOK({ genIType t = min(genIType(0), int(0)); })\\\n    ISOK({ genUType t = min(genUType(0), genUType(0)); })\\\n    ISOK({ genUType t = min(genUType(0), uint(0)); })\\\n    ISOK({ genFType t = max(genFType(0), genFType(0)); })\\\n    ISOK({ genFType t = max(genFType(0), float(0)); })\\\n    RSVD({ genDType t = max(genDType(0), genDType(0)); })\\\n    RSVD({ genDType t = max(genDType(0), double(0)); })\\\n    ISOK({ genIType t = max(genIType(0), genIType(0)); })\\\n    ISOK({ genIType t = max(genIType(0), int(0)); })\\\n    ISOK({ genUType t = max(genUType(0), genUType(0)); })\\\n    ISOK({ genUType t = max(genUType(0), uint(0)); })\\\n    ISOK({ genFType t = clamp(genFType(0), genFType(0), genFType(0)); })\\\n    ISOK({ genFType t = clamp(genFType(0), float(0), float(0)); })\\\n    RSVD({ genDType t = clamp(genDType(0), genDType(0), genDType(0)); })\\\n    RSVD({ genDType t = clamp(genDType(0), double(0), double(0)); })\\\n    ISOK({ genIType t = clamp(genIType(0), genIType(0), genIType(0)); })\\\n    ISOK({ genIType t = clamp(genIType(0), int(0), int(0)); })\\\n    ISOK({ genUType t = clamp(genUType(0), genUType(0), genUType(0)); })\\\n    ISOK({ genUType t = clamp(genUType(0), uint(0), uint(0)); })\\\n    ISOK({ genFType t = mix(genFType(0), genFType(0), genFType(0)); })\\\n    ISOK({ genFType t = mix(genFType(0), genFType(0), float(0)); })\\\n    RSVD({ genDType t = mix(genDType(0), genDType(0), genDType(0)); })\\\n    RSVD({ genDType t = mix(genDType(0), genDType(0), double(0)); })\\\n    ISOK({ genFType t = mix(genFType(0), genFType(0), genBType(0)); })\\\n    RSVD({ genDType t = mix(genDType(0), genDType(0), genBType(0)); })\\\n    OVRL({ genIType t = mix(genIType(0), genIType(0), genBType(0)); })\\\n    OVRL({ genUType t = mix(genUType(0), genUType(0), genBType(0)); })\\\n    OVRL({ genBType t = mix(genBType(0), genBType(0), genBType(0)); })\\\n    ISOK({ genFType t = step(genFType(0), genFType(0)); })\\\n    ISOK({ genFType t = step(float(0), genFType(0)); })\\\n    RSVD({ genDType t = step(genDType(0), genDType(0)); })\\\n    RSVD({ genFType t = step(double(0), genDType(0)); })\\\n    ISOK({ genFType t = smoothstep(genFType(0), genFType(0), genFType(0)); })\\\n    ISOK({ genFType t = smoothstep(float(0), float(0), genFType(0)); })\\\n    RSVD({ genDType t = smoothstep(genDType(0), genDType(0), genDType(0)); })\\\n    RSVD({ genDType t = smoothstep(double(0), double(0), genDType(0)); })\\\n    ISOK({ genBType t = isnan(genFType(0)); })\\\n    RSVD({ genBType t = isnan(genDType(0)); })\\\n    ISOK({ genBType t = isinf(genFType(0)); })\\\n    RSVD({ genBType t = isinf(genDType(0)); })\\\n    ISOK({ genIType t = floatBitsToInt(genFType(0)); })\\\n    ISOK({ genUType t = floatBitsToUint(genFType(0)); })\\\n    ISOK({ genFType t = intBitsToFloat(genIType(0)); })\\\n    ISOK({ genFType t = uintBitsToFloat(genUType(0)); })\\\n    OVRL({ genFType t = fma(genFType(0), genFType(0), genFType(0)); })\\\n    OVRL({ genFType t = fma(genDType(0), genDType(0), genDType(0)); })\\\n    OVRL({ genFType t = frexp(highpgenFType(0), genIType(0)); })\\\n    OVRL({ genFType t = frexp(genDType(0), genIType(0)); })\\\n    OVRL({ genFType t = ldexp(highpgenFType(0), genIType(0)); })\\\n    OVRL({ genFType t = ldexp(genDType(0), genIType(0); }))\n    \n#define _8_5_Geometric_Functions(genFType)\\\n    { float t = length(genFType(0)); }\\\n    { float t = distance(genFType(0),genFType(0)); }\\\n    { float t = dot(genFType(0),genFType(0)); }\\\n    { vec3 t = cross(vec3(0), vec3(0)); }\\\n    { genFType t = normalize(genFType(0)); }\\\n    { genFType t = faceforward(genFType(0),genFType(0),genFType(0)); }\\\n    { genFType t = reflect(genFType(0),genFType(0)); }\\\n    { genFType t = refract(genFType(0),genFType(0),float(0)); }\\\n    \n#define _8_7_Vector_Relational_Functions(bvec, vec, ivec, uvec) \\\n    { bvec t = lessThan(vec(0), vec(0));}\\\n    { bvec t = lessThan(ivec(0), ivec(0));}\\\n    { bvec t = lessThan(uvec(0), uvec(0));}\\\n    { bvec t = lessThanEqual(vec(0), vec(0));}\\\n    { bvec t = lessThanEqual(ivec(0), ivec(0));}\\\n    { bvec t = lessThanEqual(uvec(0), uvec(0));}\\\n    { bvec t = greaterThan(vec(0), vec(0));}\\\n    { bvec t = greaterThan(ivec(0), ivec(0));}\\\n    { bvec t = greaterThan(uvec(0), uvec(0));}\\\n    { bvec t = greaterThanEqual(vec(0), vec(0));}\\\n    { bvec t = greaterThanEqual(ivec(0), ivec(0));}\\\n    { bvec t = greaterThanEqual(uvec(0), uvec(0));}\\\n    { bvec t = equal(vec(0), vec(0));}\\\n    { bvec t = equal(ivec(0), ivec(0));}\\\n    { bvec t = equal(uvec(0), uvec(0));}\\\n    { bvec t = equal(bvec(0), bvec(0));}\\\n    { bvec t = notEqual(vec(0), vec(0));}\\\n    { bvec t = notEqual(ivec(0), ivec(0));}\\\n    { bvec t = notEqual(uvec(0), uvec(0));}\\\n    { bvec t = notEqual(bvec(0), bvec(0));}\\\n    { bool t = any(bvec(0));}\\\n    { bool t = all(bvec(0));}\\\n    { bvec t = not(bvec(0));}\\\n    \n    _8_1_Angle_and_Trigonometry_Functions(float)\n    _8_1_Angle_and_Trigonometry_Functions(vec2)\n    _8_1_Angle_and_Trigonometry_Functions(vec3)\n    _8_1_Angle_and_Trigonometry_Functions(vec4)\n    \n    _8_2_Exponential_Functions(float)\n    _8_2_Exponential_Functions(vec2)\n    _8_2_Exponential_Functions(vec3)\n    _8_2_Exponential_Functions(vec4)\n    \n    _8_3_Common_Functions(float, double, int, uint, bool)\n    _8_3_Common_Functions(vec2, dvec2, ivec2, uvec2, bvec2)\n    _8_3_Common_Functions(vec3, dvec3, ivec3, uvec3, bvec3)\n    _8_3_Common_Functions(vec4, dvec4, ivec4, uvec4, bvec4)\n    \n    _8_5_Geometric_Functions(float)\n    _8_5_Geometric_Functions(vec2)\n    _8_5_Geometric_Functions(vec3)\n    _8_5_Geometric_Functions(vec4)\n    \n    _8_7_Vector_Relational_Functions(bvec2, vec2, ivec2, uvec2)\n    _8_7_Vector_Relational_Functions(bvec3, vec3, ivec3, uvec3)\n    _8_7_Vector_Relational_Functions(bvec4, vec4, ivec4, uvec4)\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}