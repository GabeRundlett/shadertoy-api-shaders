{
    "Shader": {
        "info": {
            "date": "1590705683",
            "description": "Shows a world that is shaped like the surface of a 4D pill capsule.",
            "flags": 48,
            "hasliked": 0,
            "id": "tdlcWB",
            "likes": 1,
            "name": "Capsule World",
            "published": 3,
            "tags": [
                "raytracing",
                "noneuclidean"
            ],
            "usePreview": 0,
            "username": "logw",
            "viewed": 174
        },
        "renderpass": [
            {
                "code": "// I wanted to make a program to show what it would be like to be inside\n// a complex non-Euclidean space.  I had been thinking about this even\n// back when I only had access to a fixed-function GPU, but I only figured\n// out how to do uniform isotropic curvature (i.e., either elliptical or\n// hyperbolic geometery).  I never implemented my plans to glue together\n// chunks of different curvature.  With raytracing, I can make anisotropic\n// curvature, but I still rely on gluing pieces together to make a more\n// complex space, because as far as I know only simple shapes have\n// geodesics that can be computed easily.  In this example, I used spheres\n// and cylinders, whose geodesics can be described using trigonometry.\n//\n// You are on the surface of a 4D \"pill capsule\", meaning a segment of 4D\n// cylinder with hemihyperspherical caps on either end.  The cross section\n// of the cylinder is itself a 2D sphere (the surface of a ball).\n//\n// Walk (on ground) = WASD\n// Look = click and drag\n// Jetpack = space (direction is affected by looking up or down)\n// Tilt (in air) = WASD\n//\n// I worked out the math to do geometrically-accurate lighting, but got\n// distracted by other projects and never implemented it.  I'm releasing\n// this as-is so it doesn't stay hidden forever.\n\nconst vec3 fog_color = vec3(0.8, 0.9, 1.0);\nconst float fog_density = 0.2;\nconst int n_floor_tile_rows = 20; // around cylinder\nconst float floor_tile_height = pi / float(n_floor_tile_rows);\nconst float max_dist = log(512.0) / fog_density;\nconst vec3 color1 = vec3(1.0, 0.1, 0.5);\nconst vec3 color2 = vec3(0.1, 1.0, 0.6);\nconst vec2 n_hud_lines = vec2(6.0, 6.0);\nconst float hud_line_size = 0.35;\n\nconst uint hit_nothing = 0u;\nconst uint hit_sphere_floor = 1u;\nconst uint hit_cylinder_floor = 2u;\nconst uint hit_window = 3u;\n\nstruct Ray\n{\n    vec4 r;\n    vec4 v;\n    uint region;\n};\n\n#if 0\nvec4 hash4(in ivec4 r)\n{\n    vec4 abs_r = vec4(abs(r));\n    vec4 x = abs_r.x + vec4(32.9281, 18.3921, 22.8247, 28.02821)\n             + float(sign(r.x)) * vec4(1.0232, -0.3958, 2.0032, 1.5928);\n    vec4 y = abs_r.x + abs_r.y + vec4(10.9284, 29.2759, 13.2948, 19.0282)\n             + float(sign(r.y)) * vec4(-0.7492, -0.9428, 0.7832, 1.9482);\n    vec4 z = abs_r.x + abs_r.y + abs_r.z + vec4(16.2981, 18.2841, 15.2948, 20.7492)\n             + float(sign(r.z)) * vec4(0.3958, 0.9824, 2.0948, 1.0934);\n    vec4 w = abs_r.x + abs_r.y + abs_r.z + abs_r.w + vec4(14.02981, 19.2434, 13.4502, 27.4392)\n             + float(sign(r.w)) * vec4(-0.3249, 4.2849, 2.4981, 1.4398);\n    return 2.0 * fract(pi*tan(x)*tan(y)*tan(z)*tan(w)) - 1.0;\n}\n\nfloat noise1(in vec4 r)  // Perlin, as I understand it.\n{\n    ivec4 int_r = ivec4(floor(r));\n    const ivec4[16] offset = ivec4[16](\n        ivec4(0, 0, 0, 0), ivec4(0, 0, 0, 1),\n        ivec4(0, 0, 1, 0), ivec4(0, 0, 1, 1),\n        ivec4(0, 1, 0, 0), ivec4(0, 1, 0, 1),\n        ivec4(0, 1, 1, 0), ivec4(0, 1, 1, 1),\n        ivec4(1, 0, 0, 0), ivec4(1, 0, 0, 1),\n        ivec4(1, 0, 1, 0), ivec4(1, 0, 1, 1),\n        ivec4(1, 1, 0, 0), ivec4(1, 1, 0, 1),\n        ivec4(1, 1, 1, 0), ivec4(1, 1, 1, 1)\n    );\n    mat4[4] grad;\n    for (int row = 0; row < 4; row++)\n    {\n        for (int col = 0; col < 4; col++)\n        {\n            grad[row][col] = hash4(int_r + offset[4*row+col]);\n        }\n    }\n    vec4 fract_r = r - vec4(int_r);\n    mat4 value;\n    for (int row = 0; row < 4; row++)\n    {\n        for (int col = 0; col < 4; col++)\n        {\n            value[row][col] = dot(fract_r - vec4(offset[4*row+col]),\n                                  grad[row][col]);\n        }\n    }\n    vec4[2] weight_1D;\n    weight_1D[1] = (3.0-2.0*fract_r) * fract_r * fract_r;\n    weight_1D[0] = 1.0 - weight_1D[1];\n    vec4 weight01 = vec4(weight_1D[0][0]*weight_1D[0][1],\n                         weight_1D[0][0]*weight_1D[1][1],\n                         weight_1D[1][0]*weight_1D[0][1],\n                         weight_1D[1][0]*weight_1D[1][1]);\n    vec4 weight23 = vec4(weight_1D[0][2]*weight_1D[0][3],\n                         weight_1D[0][2]*weight_1D[1][3],\n                         weight_1D[1][2]*weight_1D[0][3],\n                         weight_1D[1][2]*weight_1D[1][3]);\n    mat4 weight = outerProduct(weight23, weight01);\n    float v0 = weight_1D[0][0]*value[0][0] + weight_1D[1][0]*value[2][0];\n    float v1 = weight_1D[0][0]*value[1][0] + weight_1D[1][0]*value[3][0];\n    return dot(vec4(1.0) * matrixCompMult(weight, value), vec4(1.0));\n}\n#endif\n\nvec3 hash3(in ivec3 r)\n{\n    vec3 abs_r = vec3(abs(r));\n    vec3 x = abs_r.x + vec3(32.9281, 18.3921, 22.8247)\n             + float(sign(r.x)) * vec3(1.0232, -0.3958, 2.0032);\n    vec3 y = abs_r.x + abs_r.y + vec3(10.9284, 29.2759, 13.2948)\n             + float(sign(r.y)) * vec3(-0.7492, -0.9428, 0.7832);\n    vec3 z = abs_r.x + abs_r.y + abs_r.z + vec3(16.2981, 18.2841, 15.2948)\n             + float(sign(r.z)) * vec3(0.3958, 0.9824, 2.0948);\n    // Use clamp because fract is not always between 0.0 and 1.0 for very\n    // large inputs.\n    return clamp(2.0 * fract(pi*tan(x)*tan(y)*tan(z)) - 1.0, -1.0, 1.0);\n}\n\nfloat noise1(in vec3 r)\n{\n    ivec3 int_r = ivec3(floor(r));\n    const ivec3[8] offset = ivec3[8](\n        ivec3(0, 0, 0), ivec3(0, 0, 1),\n        ivec3(0, 1, 0), ivec3(0, 1, 1),\n        ivec3(1, 0, 0), ivec3(1, 0, 1),\n        ivec3(1, 1, 0), ivec3(1, 1, 1)\n    );\n    vec3[8] grad;\n    for (int i = 0; i < 8; i++)\n    {\n        grad[i] = hash3(int_r + offset[i]);\n    }\n    vec3 fract_r = r - vec3(int_r);\n    mat2x4 value;\n    for (int row = 0; row < 2; row++)\n    {\n        for (int col = 0; col < 4; col++)\n        {\n            value[row][col] = dot(fract_r - vec3(offset[4*row+col]),\n                                  grad[4*row+col]);\n        }\n    }\n    vec3[2] weight_1D;\n    weight_1D[1] = (3.0-2.0*fract_r) * fract_r * fract_r;\n    weight_1D[0] = 1.0 - weight_1D[1];\n    vec2 weight0 = vec2(weight_1D[0][0], weight_1D[1][0]);\n    vec4 weight12 = vec4(weight_1D[0][1]*weight_1D[0][2],\n                         weight_1D[0][1]*weight_1D[1][2],\n                         weight_1D[1][1]*weight_1D[0][2],\n                         weight_1D[1][1]*weight_1D[1][2]);\n    mat2x4 weight = outerProduct(weight12, weight0);\n    return dot(vec4(1.0) * matrixCompMult(weight, value), vec2(1.0));\n}\n\nvec3 tile_color(in vec3 edge_dist, in vec3 r, in vec3 base_color)\n{\n    vec3 profile = 1.0 - pow(max(1.0-edge_dist, 0.0), vec3(10.0));\n    return vec3(\n        base_color\n        * max(profile.x*profile.y*profile.z\n                  - max(noise1(200.0*r)-0.3, 0.0),\n              0.0)\n    );\n}\n\nvec3 triangle_coords(in vec3 p0, in vec3 p1, in vec3 p2,\n                     in vec3 r, out ivec3 icoord)\n{\n    // Normal to the (flat) triangle\n    vec3 n = normalize(cross(p1-p0, p2-p0));\n    // Project r onto the flat triangle\n    float scale = dot(n, p0) / dot(n, r);\n    vec3 r_ = scale * r;\n    // Decompose in terms of p1-p0 and p2-p0\n    vec3 u;\n    u.xy =\n        inverse(\n            transpose(mat2x3(p1-p0, p2-p0))\n            * mat2x3(p1-p0, p2-p0)\n        ) * transpose(mat2x3(p1-p0, p2-p0)) * (r_-p0);\n    u.z = 1. - u.x - u.y;\n    vec3 coord;\n    vec3 icoordf;\n    coord = modf(4.*u, icoordf);\n    icoord = ivec3(icoordf);\n    return coord;\n}\n\nvec3 sphere_floor_color(in vec4 r)\n{\n    // Constructing the vertices of a pentagonal rotunda\n    const float sL = 2. * sin(tau/20.); // side length\n    const float prc = 0.5*sL / sin(tau/10.); // pentagon radius at corner\n    // Use to reflect across the xz (φ=0) plane\n    const vec3 ref = vec3(1., -1., 1.);\n    // normal to the plane at φ = τ/10\n    const vec3 v = vec3(-sin(tau/10.), cos(tau/10.), 0.);\n    // Use to reflect across the φ=τ/10 plane\n    const mat3 ref_ = mat3(1.) - outerProduct(2.*v, v);\n    // Corner of top pentagon\n    const vec3 p0 = vec3(prc*cos(tau/10.),\n                         prc*sin(tau/10.),\n                         sqrt(1.-prc*prc));\n    // Bottom corner of bottom pentagon\n    const vec3 p3 = vec3(cos(tau/20.), sin(tau/20.), 0.);\n    // Side corner of bottom pentagon\n    const vec3 p1 = normalize(vec3(p0.x+p3.x, 0., p0.z+p3.z));\n    // Center of the bottom pentagon\n    const vec3 p2 = normalize(p0 + p1 + ref_*p1 + p3 + ref_*p3);\n    \n    float phi = mod(atan(r.y, r.x), tau/5.) - tau/10.;\n    float s = length(r.xy);\n    // r mapped into a standard τ/10 slice centered on the x axis\n    vec3 r_ = vec3(s*cos(phi), s*sin(phi), abs(r.w));\n    // r_ reflected onto the +y side of that slice\n    vec3 r_p = vec3(r_.x, abs(r_.y), r_.z);\n    // Convex coördinates (not sure if that is a real term)\n    // of the point within the triangle.  (Coëfficients of a\n    // convex combination giving r_ as a function of the\n    // corners of the triangle\n    vec3 u = vec3(1.);\n    // Discretized version of convex coördinates giving the\n    // identity of the sub-triangle\n    ivec3 i;\n    bool checker = false;\n    vec3 color = r.w > 0. ? color1 : color2;\n    if (dot(r_p, normalize(cross(ref*p0, p0))) > 0.)\n    {\n        u = triangle_coords(vec3(0., 0., 1.), ref*p0, p0, r_, i);\n    }\n    else if (dot(r_p, normalize(cross(p1, p0))) > 0.)\n    {\n        u = triangle_coords(p0, ref*p0, p1, r_, i);\n        checker = true;\n    }\n    else if (dot(r_p, normalize(cross(p1, p2))) > 0.)\n    {\n        u = triangle_coords(p0, p1, p2, r_p, i);\n    }\n    else if (dot(r_p, normalize(cross(p1, p3))) > 0.)\n    {\n        if (dot(r_p, normalize(cross(p3, p2))) > 0.)\n        {\n            u = triangle_coords(p1, p3, p2, r_p, i);\n        }\n        else\n        {\n            u = triangle_coords(p2, p3, ref_*p3, r_p, i);\n        }\n    }\n    else\n    {\n        u = triangle_coords(p1, ref*p3, p3, r_, i);\n        checker = true;\n    }\n    if (!bool((i.x^i.y^i.z)&1))\n    {\n        u = 1. - u;\n    }\n    else if (checker)\n    {\n        color = vec3(1.);\n    }\n    return tile_color(min(1.9*u, 1.), r.xyw, color);\n}\n\nvoid cast_ray_on_sphere(in Ray R, out Ray S, out float dist,\n                        out uint hit_status)\n{\n    S = R;\n    hit_status = hit_nothing;\n    dist = 0.0;\n    vec4 new_r;\n    vec4 new_v;\n    float new_dist;\n    bool hit;\n    cast_ray_on_sphere_at_plane(R.r, R.v, Z, floor_z, new_r, new_v,\n                                new_dist, hit);\n    if (hit)\n    {\n        hit_status = hit_sphere_floor;\n        S.r = new_r;\n        S.v = new_v;\n        dist = new_dist;\n    }\n    float sign_ = R.region == region_right_sphere ? 1.0 : -1.0;\n    cast_ray_on_sphere_at_plane(R.r, R.v, sign_ * W, 0.0,\n                                new_r, new_v, new_dist, hit);\n    if (hit && (hit_status == hit_nothing || new_dist < dist))\n    {\n        hit_status = hit_window;\n        S.r = new_r;\n        S.r.w = sign_ * cylinder_length/2.0;\n        S.v = new_v;\n        S.region = region_cylinder;\n        dist = new_dist;\n    }\n}\n\nvoid cast_ray_on_cylinder(in Ray R, out Ray S, out float dist,\n                          out uint hit_status)\n{\n    S = R;\n    dist = 0.0;\n    hit_status = hit_nothing;\n    vec4 new_r;\n    vec4 new_v;\n    float new_dist;\n    bool hit;\n    cast_ray_on_cylinder_at_floor(R.r, R.v, floor_z, new_r, new_v,\n                                  new_dist, hit);\n    if (hit)\n    {\n        hit_status = hit_cylinder_floor;\n        S.r = new_r;\n        S.v = new_v;\n        dist = new_dist;\n    }\n    cast_ray_on_cylinder_at_window(R.r, R.v, cylinder_length/2.0,\n                                   new_r, new_v, new_dist, hit);\n    if (hit && (hit_status == hit_nothing || new_dist < dist))\n    {\n        hit_status = hit_window;\n        S.r = new_r;\n        S.r.w = 0.0;\n        S.v = new_v;\n        S.region = region_right_sphere;\n        dist = new_dist;\n    }\n    cast_ray_on_cylinder_at_window(R.r, R.v, -cylinder_length/2.0,\n                                   new_r, new_v, new_dist, hit);\n    if (hit && (hit_status == hit_nothing || new_dist < dist))\n    {\n        hit_status = hit_window;\n        S.r = new_r;\n        S.r.w = 0.0;\n        S.v = new_v;\n        S.region = region_left_sphere;\n        dist = new_dist;\n    }\n}\n\nvec3 cylinder_floor_color(in vec4 r)\n{\n    const int n_cols = 2*n_floor_tile_rows;\n    const float f_n_cols = float(n_cols);\n    vec2 tile_coords;\n    tile_coords.y = r.w / floor_tile_height;\n    tile_coords.x = (atan(r.y, r.x) + tau/2.) * f_n_cols / tau;\n    // Yes this rounds both 0.5 and -0.5 to 0 and that’s good\n    ivec2 i_coords = ivec2(tile_coords);\n    const int n_rows = 2 * int(cylinder_length / 2. / floor_tile_height);\n    vec3 color = vec3(1.);\n    if (n_rows/2 - abs(i_coords.y) - 1 < n_rows/3\n        && ((i_coords.y-i_coords.x)&3) < 2)\n    {\n        color = r.w > 0. ? color1 : color2;\n    }\n    vec3 edge_dist = vec3(1. - abs(1. - 2.*fract(tile_coords)), 1.);\n    return tile_color(edge_dist, r.xyw, color);\n}\n\nfloat draw_hud(in Camera camera, in vec4 dir)\n{\n    float th = asin(dot(dir, camera.body_axes[1]));\n    vec2 px = vec2(1.0/cos(th), 1.0) * field_of_view / iResolution.x;\n    float ph_px = atan(dot(dir, -camera.body_axes[2]),\n                       dot(dir, camera.body_axes[0])) / px.x;\n    float th_px = th / px.y;\n    vec2 slice = vec2(tau, pi) / px / n_hud_lines;\n    float hzig = abs(mod(ph_px, slice.x) - slice.x/2.0);\n    float hzigzag = abs((1.0-hud_line_size)*slice.x/2.0 - hzig);\n    float a = 0.0;\n    if ((1.0-hud_line_size)*slice.x/2.0 - hzig < 0.0)\n    {\n    \tfloat vzig = abs(mod(th_px, slice.y) - slice.y/2.0);\n    \ta = max(vzig-(slice.y/2.0-1.0), 0.0);\n    }\n    if (mod(th_px, slice.y) < 10.0)\n    {\n        a = max(a, max(1.0-hzigzag, 0.0));\n    }\n    return a;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 screen_coords = 2.0 * (fragCoord - iResolution.xy/2.0)\n                         / iResolution.x;\n    vec3 color = fog_color;\n    Camera camera = load_camera(iChannel1);\n    vec4 v = normalize(screen_coords.x*tan_fov*camera.axes[0]\n                       + screen_coords.y*tan_fov*camera.axes[1]\n                       - camera.axes[2]);\n    Ray R = Ray(camera.axes[3] + camera.w*W, v, camera.region);\n    Ray S;\n    float dist = 0.0;\n    float new_dist;\n    uint hit_status = hit_nothing;\n    for (uint count = 0u; count < 10u; count++)\n    {\n        if (R.region == region_right_sphere\n            || R.region == region_left_sphere)\n        {\n            cast_ray_on_sphere(R, S, new_dist, hit_status);\n        }\n        else if (R.region == region_cylinder)\n        {\n            cast_ray_on_cylinder(R, S, new_dist, hit_status);\n        }\n        else\n        {\n            break;\n        }\n        dist += new_dist;\n        if (dist >= max_dist)\n        {\n            break;\n        }\n        if (hit_status == hit_sphere_floor)\n        {\n            color = sphere_floor_color(S.r);\n            break;\n        }\n        else if (hit_status == hit_cylinder_floor)\n        {\n            color = cylinder_floor_color(S.r);\n            break;\n        }\n        else if (hit_status == hit_nothing)\n        {\n            break;\n        }\n        else if (hit_status == hit_window)\n        {\n            R = S;\n        }\n        else\n        {\n            break;\n        }\n    }\n    if (hit_status != hit_nothing)\n    {\n        color = mix(fog_color, color, exp(-fog_density*dist));\n    }\n    float hud = draw_hud(camera, v);\n    color = mix(color, 1.0-color, 0.75*hud);\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float walk_speed = 0.4; // radians/sec.\nconst float walk_accel_time = 0.25; // sec.\nconst float gravity = 0.75; // radians/sec./sec.\nconst float thrust = 1.125; // radians/sec./sec.\nconst float mouse_sensitivity = 2.0*pi; // radians / half screen\nconst float tilt_rate = 0.6; // radians/sec.\n\nvoid store(inout vec4 fragColor, in vec2 fragCoord,\n           in vec4 value, in ivec2 addr)\n{\n    if (ivec2(fragCoord) == addr)\n    {\n        fragColor = value;\n    }\n}\n\nvoid store(inout vec4 fragColor, in vec2 fragCoord,\n           in float value, in ivec3 addr)\n{\n    if (ivec2(fragCoord) == addr.xy)\n    {\n        fragColor[addr.z] = value;\n    }\n}\n\nvoid store_mat4(inout vec4 fragColor, in vec2 fragCoord,\n                in mat4 value, in ivec2 addr)\n{\n    ivec2 cur_addr = ivec2(fragCoord);\n    if (cur_addr.y == addr.y\n        && addr.x <= cur_addr.x && cur_addr.x < addr.x + 4)\n    {\n        fragColor = value[cur_addr.x-addr.x];\n    }\n}\n\nbool key_is_pressed(uint code)\n{\n    return bool(texelFetch(iChannel0, ivec2(code, 0), 0).r);\n}\n\nvoid orthogonalize(inout Camera camera)\n{\n    for (uint i = 0u; i < 4u; i++)\n    {\n        for (uint j = 0u; j < i; j++)\n        {\n            camera.body_axes[i] -= dot(camera.body_axes[i],\n                                       camera.body_axes[j])\n                                   * camera.body_axes[j];\n        }\n        camera.body_axes[i] = normalize(camera.body_axes[i]);\n    }\n}\n\nvoid move_camera_on_sphere(inout Camera camera, in vec4 dir, in float dist)\n{\n    camera.body_axes = rotation_matrix(camera.body_axes[3], dir, dist)\n                       * camera.body_axes;\n}\n\nvoid move_camera_on_cylinder(inout Camera camera, in vec4 dir, in float dist)\n{\n    vec4 dir_tan = vec4(0.0);\n    dir_tan.xyz = normalize(dir.xyz);\n    float angle = dist * length(dir.xyz);\n    if (angle != 0.0)\n    {\n        // Rotation matrix goes on the left because the rotation vectors\n        // are in global coördinates.\n        mat4 mat = rotation_matrix(camera.body_axes[3], dir_tan, angle);\n        camera.body_axes = mat * camera.body_axes;\n    }\n    camera.w += dist * dir.w;\n}\n\nvoid move_camera(inout Camera camera, in vec3 step_)\n{\n    vec4 r_;\n    vec4 v_;\n    float ray_dist;\n    float left_ray_dist;\n    bool hit;\n    bool hit_left;\n    float sphere_sign;\n    if (step_ == vec3(0.0))\n    {\n        return;\n    }\n    vec4 global_dir = camera.body_axes * vec4(normalize(step_), 0.0);\n    float dist = length(step_);\n    switch (camera.region)\n    {\n        case region_right_sphere:\n        case region_left_sphere:\n            sphere_sign = camera.region == region_right_sphere ? 1.0 : -1.0;\n            cast_ray_on_sphere_at_plane(camera.body_axes[3], global_dir,\n                                        sphere_sign * W,\n                                        0.0, r_, v_, ray_dist, hit);\n            if (hit && dist >= ray_dist)\n            {\n                move_camera_on_sphere(camera, global_dir, ray_dist);\n                camera.region = region_cylinder;\n                camera.w = sphere_sign * cylinder_length / 2.0;\n                move_camera_on_cylinder(camera, global_dir, dist - ray_dist);\n            }\n            else\n            {\n                move_camera_on_sphere(camera, global_dir, dist);\n            }\n            break;\n        case region_cylinder:\n            cast_ray_on_cylinder_at_window(camera.body_axes[3] + camera.w*W,\n                                           global_dir,\n                                           cylinder_length / 2.0, r_, v_,\n                                           ray_dist, hit);\n            cast_ray_on_cylinder_at_window(camera.body_axes[3] + camera.w*W,\n                                           global_dir,\n                                           -cylinder_length / 2.0, r_, v_,\n                                           left_ray_dist, hit_left);\n            if (hit && dist >= ray_dist)\n            {\n                move_camera_on_cylinder(camera, global_dir, ray_dist);\n                camera.region = region_right_sphere;\n                camera.w = 0.0;\n                move_camera_on_sphere(camera, global_dir, dist - ray_dist);\n            }\n            else if (hit_left && dist >= left_ray_dist)\n            {\n                move_camera_on_cylinder(camera, global_dir, left_ray_dist);\n                camera.region = region_left_sphere;\n                camera.w = 0.0;\n                move_camera_on_sphere(camera, global_dir, dist - left_ray_dist);\n            }\n            else\n            {\n                move_camera_on_cylinder(camera, global_dir, dist);\n            }\n            break;\n    }\n    update_camera(camera);\n}\n\nvoid rotate_camera_right(inout Camera camera, in float angle,\n                         inout vec3 velocity)\n{\n    camera.look.x = mod(camera.look.x + angle, tau);\n    update_camera(camera);\n}\n\nvoid rotate_camera_up(inout Camera camera, in float angle,\n                      inout vec3 velocity)\n{\n    camera.look.y = clamp(camera.look.y + angle, -pi/2.0, pi/2.0);\n    update_camera(camera);\n}\n\nvoid set_z_to_floor(inout Camera camera, in vec3 global_z)\n{\n    vec4 dir = camera.body_axes * vec4(-global_z, 0.0);\n    // No need for asin since we should already be very close.\n    // Note that we want z = 0, not floor_z, because the camera sits\n    // at z = 0 when on the floor.\n    float dist = camera.body_axes[3].z;\n    switch (camera.region)\n    {\n        case region_right_sphere:\n        case region_left_sphere:\n        \tmove_camera_on_sphere(camera, dir, dist);\n        \tbreak;\n        case region_cylinder:\n        \tmove_camera_on_cylinder(camera, dir, dist);\n        \tbreak;\n    }\n}\n\nvec4 get_mouse()\n{\n    vec4 offset = vec4(iResolution.xy, iResolution.xy) / 2.0;\n    return 2.0 * (iMouse - offset) / iResolution.x;\n}\n\nvec3 get_walk_accel(in Camera camera, in vec3 velocity, in vec3 global_z)\n{\n    vec3 accel_raw = vec3(0.0);\n    if (key_is_pressed(0x57u)) // W\n    {\n        accel_raw.z -= 1.0;\n    }\n    if (key_is_pressed(0x41u)) // A\n    {\n        accel_raw.x -= 1.0;\n    }\n    if (key_is_pressed(0x53u)) // S\n    {\n        accel_raw.z += 1.0;\n    }\n    if (key_is_pressed(0x44u)) // D\n    {\n        accel_raw.x += 1.0;\n    }\n    // Convert view coördinates to body coördinates\n    vec3 accel_body = mat3(transpose(camera.body_axes)*camera.axes)\n                      * accel_raw;\n    accel_body -= dot(accel_body, global_z) * global_z;\n    if (accel_body != vec3(0.0))\n    {\n        vec3 accel_norm = normalize(accel_body);\n    \treturn accel_norm * (walk_speed - dot(accel_norm, velocity))\n               / walk_accel_time;\n    }\n    return vec3(0.0);\n}\n\nvec3 get_accel(in Camera camera, in bool on_floor, in vec3 velocity,\n               in vec3 global_z, in vec3 global_z_unnorm)\n{\n    vec3 accel = vec3(0.0);\n    if (on_floor)\n    {\n    \taccel += get_walk_accel(camera, velocity, global_z);\n    }\n    accel -= gravity * global_z_unnorm;\n    if (key_is_pressed(0x20u)) // space\n    {\n        accel.y += thrust;\n    }\n    return accel;\n}\n\nvoid do_right_body(inout Camera camera, inout vec3 velocity,\n                   in vec3 global_z_body)\n{\n    vec4 global_z = camera.body_axes * vec4(global_z_body, 0.0);\n    float angle = abs(global_z_body.y) > 0.7 ? acos(global_z_body.y)\n                  : asin(length(global_z_body.xz));\n    if (angle > 0.001)\n    {\n    \tangle = min(0.9*angle, 0.1);\n        vec4 axis1 = global_z;\n        vec4 axis0 = camera.body_axes[1]\n                     - axis1 * dot(camera.body_axes[1], axis1);\n        if (dot(axis0, axis0) < 0.000001)\n        {\n            axis0 = camera.body_axes[2]\n                    - axis1 * dot(camera.body_axes[2], axis1);\n        }\n        axis0 = normalize(axis0);\n        mat4 rot = rotation_matrix(axis0, axis1, angle);\n        camera.body_axes = rot * camera.body_axes;\n        velocity = mat3(transpose(camera.body_axes)\n                        * transpose(rot)\n                        * camera.body_axes)\n                   * velocity;\n        update_camera(camera);\n    }\n}\n\nvoid rotate_body_by_tilt_control(inout Camera camera, inout vec3 velocity)\n{\n    mat4 rot = mat4(1.0);\n    float step_ = tilt_rate * iTimeDelta;\n    if (key_is_pressed(0x57u)) // W\n    {\n        rot = rotation_matrix(camera.axes[2], camera.axes[1], step_);\n    }\n    if (key_is_pressed(0x41u)) // A\n    {\n        rot *= rotation_matrix(camera.axes[0], camera.axes[1], step_);\n    }\n    if (key_is_pressed(0x53u)) // S\n    {\n        rot *= rotation_matrix(camera.axes[1], camera.axes[2], step_);\n    }\n    if (key_is_pressed(0x44u)) // D\n    {\n        rot *= rotation_matrix(camera.axes[1], camera.axes[0], step_);\n    }\n    camera.body_axes = rot * camera.body_axes;\n    velocity = mat3(transpose(camera.body_axes)\n                        * transpose(rot)\n                        * camera.body_axes)\n                   * velocity;\n    update_camera(camera);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (any(greaterThanEqual(ivec2(fragCoord), size_of_addrs)))\n    {\n        discard;\n    }\n    fragColor = vec4(0.0);\n    vec4 old_mouse = get_mouse();\n    Camera camera;\n    vec3 velocity = vec3(0.0);\n    bool on_floor = true;\n    if (iFrame == 0)\n    {\n        camera = new_camera(Y, X, vec2(0.0, 0.0), region_right_sphere,\n                            W, 0.0);\n    }\n    else\n    {\n        fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n        old_mouse = load(iChannel1, addr_mouse);\n        camera = load_camera(iChannel1);\n        velocity = load(iChannel1, addr_velocity).xyz;\n        on_floor = bool(load(iChannel1, addr_on_floor));\n    }\n    vec3 global_z_unnorm = (Z*camera.body_axes).xyz;\n    vec3 global_z = normalize(global_z_unnorm);\n    velocity += iTimeDelta\n                * get_accel(camera, on_floor, velocity, global_z,\n                            global_z_unnorm);\n    on_floor = on_floor && dot(velocity, global_z) <= 0.0;\n    if (on_floor)\n    {\n        do_right_body(camera, velocity, global_z);\n        global_z = normalize((Z*camera.body_axes).xyz);\n        velocity -= dot(velocity, global_z) * global_z\n            \t\t+ velocity * iTimeDelta / walk_accel_time;\n    }\n    else\n    {\n        rotate_body_by_tilt_control(camera, velocity);\n        global_z = normalize((Z*camera.body_axes).xyz);\n    }\n    vec3 step_ = velocity * iTimeDelta;\n    if (!on_floor && dot(velocity, global_z) < 0.0)\n    {\n        vec4 new_r;\n        vec4 new_v;\n        float dist;\n        bool hit;\n        if (camera.region == region_cylinder)\n        {\n            cast_ray_on_cylinder_at_floor(camera.body_axes[3] + camera.w*W,\n                                          normalize(camera.body_axes\n                                                    * vec4(step_, 0.0)),\n                                          0.0, new_r, new_v, dist, hit);\n        }\n        else if (camera.region == region_right_sphere\n                 || camera.region == region_left_sphere)\n        {\n            cast_ray_on_sphere_at_plane(\n                camera.body_axes[3],\n                normalize(camera.body_axes*vec4(step_, 0.0)),\n                Z, 0.0, new_r, new_v, dist, hit\n            );\n        }\n        if (hit && dist < length(step_))\n        {\n            step_ *= dist / length(step_);\n            velocity -= dot(velocity, global_z) * global_z;\n            on_floor = true;\n        }\n    }\n    move_camera(camera, step_);\n    if (on_floor)\n    {\n    \tset_z_to_floor(camera, global_z);\n    }\n    vec4 mouse = get_mouse();\n    if (old_mouse.z >= -1.0)\n    {\n        vec2 mouse_step = (mouse.xy - old_mouse.xy) * mouse_sensitivity;\n        if (mouse_step != vec2(0.0))\n        {\n            rotate_camera_right(camera, mouse_step.x, velocity);\n            rotate_camera_up(camera, mouse_step.y, velocity);\n        }\n    }\n    orthogonalize(camera);\n    store(fragColor, fragCoord, mouse, addr_mouse);\n    store_mat4(fragColor, fragCoord, camera.body_axes, addr_camera_axes);\n    store(fragColor, fragCoord, camera.w, addr_camera_w);\n    store(fragColor, fragCoord, vec4(camera.look, 0.0, 0.0),\n          addr_camera_look);\n    store(fragColor, fragCoord, float(camera.region), addr_camera_region);\n    store(fragColor, fragCoord, vec4(velocity, 0.0), addr_velocity);\n    store(fragColor, fragCoord, float(on_floor), addr_on_floor);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Global coördinates: w is axis of cylinder, z is up (⟂ to floor),\n// Camera coördinates: w is ⟂ to surface, -z is the pointing direction,\n//   x is right, y is up.\n\nconst float tau = radians(360.0);\nconst float pi = radians(180.0);\nconst vec4 X = vec4(1.0, 0.0, 0.0, 0.0);\nconst vec4 Y = vec4(0.0, 1.0, 0.0, 0.0);\nconst vec4 Z = vec4(0.0, 0.0, 1.0, 0.0);\nconst vec4 W = vec4(0.0, 0.0, 0.0, 1.0);\nconst float field_of_view = radians(90.0);\nconst float cylinder_length = tau; // times the radius of the cylinder\nconst float floor_level = -0.15; // times the radius of the spheres/cylinder\nconst float floor_z = sin(floor_level);\n\nconst float tan_fov = tan(field_of_view/2.0);\n\nconst ivec2 addr_camera_axes = ivec2(0, 0);\nconst ivec2 addr_mouse = ivec2(4, 0);\nconst ivec3 addr_camera_region = ivec3(5, 0, 0);\nconst ivec3 addr_on_floor = ivec3(5, 0, 1);\nconst ivec3 addr_camera_w = ivec3(5, 0, 3);\nconst ivec2 addr_camera_look = ivec2(6, 0);\nconst ivec2 addr_velocity = ivec2(7, 0);\nconst ivec2 size_of_addrs = ivec2(8, 1);\n\nconst uint region_left_sphere = 0u;\nconst uint region_right_sphere = 1u;\nconst uint region_cylinder = 2u;\n\nstruct Camera\n{\n    mat4 axes; // axes of camera coördinate system, in columns\n    // body_axes[0]: reference vector for camera rotation, initially\n    //     equal to axes[0], but gets parallel transported around\n    // body_axes[1]: direction of jet thrust and camera rotation\n    // body_axes[2]: arbitrary vector orthogonal to the others\n    // body_axes[3]: normal to the capsule surface, equal to axes[3]\n    mat4 body_axes;\n    vec2 look; // Angles giving the look direction relative to ref_axes\n    uint region;\n    float w; // w-coördinate of camera, if it is on the cylinder\n};\n\nvec4 wedge_product(in vec4 a, in vec4 b, in vec4 c)\n{\n    return vec4( determinant(mat3(a.yzw, b.yzw, c.yzw)),\n                -determinant(mat3(a.xzw, b.xzw, c.xzw)),\n                 determinant(mat3(a.xyw, b.xyw, c.xyw)),\n                -determinant(mat3(a.xyz, b.xyz, c.xyz)));\n}\n\nmat4 rotation_matrix(in uint axis0, in uint axis1, in float angle)\n{\n    mat4 result = mat4(1.0);\n    result[axis0][axis0] =  cos(angle);\n    result[axis1][axis0] = -sin(angle);\n    result[axis0][axis1] =  sin(angle);\n    result[axis1][axis1] =  cos(angle);\n    return result;\n}\n\nmat4 rotation_matrix(in vec4 axis0, in vec4 axis1, float angle)\n{\n    return mat4(1.0)\n           + (cos(angle)-1.0) * outerProduct(axis0, axis0)\n           - sin(angle) * outerProduct(axis0, axis1)\n           + sin(angle) * outerProduct(axis1, axis0)\n           + (cos(angle)-1.0) * outerProduct(axis1, axis1);\n}\n\nmat3 rotation_matrix(in vec3 axis0, in vec3 axis1, float angle)\n{\n    return mat3(1.0)\n           + (cos(angle)-1.0) * outerProduct(axis0, axis0)\n           - sin(angle) * outerProduct(axis0, axis1)\n           + sin(angle) * outerProduct(axis1, axis0)\n           + (cos(angle)-1.0) * outerProduct(axis1, axis1);\n}\n\nmat4 camera_view_wrt_body(in vec2 look)\n    // Return the view basis expressed in terms of the body basis.\n{\n    return rotation_matrix(0u, 2u, look.x)\n           * rotation_matrix(1u, 2u, look.y);\n}\n\nvoid update_camera(inout Camera camera)\n{\n    camera.axes = camera.body_axes * camera_view_wrt_body(camera.look);\n}\n    \nCamera new_camera(in vec4 dir, in vec4 right, in vec2 look, in uint region,\n                  in vec4 pos, in float w)\n{\n    Camera camera;\n    camera.body_axes =\n        mat4(right, -wedge_product(-dir, pos, right), -dir, pos);\n    camera.axes = camera.body_axes;\n    camera.look = look;\n    camera.region = region;\n    camera.w = w;\n\tupdate_camera(camera);\n    return camera;\n}\n\nvec4 load(in sampler2D iChannel1, in ivec2 addr)\n{\n    return texelFetch(iChannel1, addr, 0);\n}\n\nfloat load(in sampler2D iChannel1, in ivec3 addr)\n{\n    return texelFetch(iChannel1, addr.xy, 0)[addr.z];\n}\n\nmat4 load_mat4(in sampler2D iChannel1, in ivec2 addr)\n{\n    return mat4(texelFetch(iChannel1, addr, 0),\n                texelFetch(iChannel1, addr + ivec2(1, 0), 0),\n                texelFetch(iChannel1, addr + ivec2(2, 0), 0),\n                texelFetch(iChannel1, addr + ivec2(3, 0), 0));\n}\n\nCamera load_camera(in sampler2D iChannel1)\n{\n    Camera camera;\n    camera.body_axes = load_mat4(iChannel1, addr_camera_axes);\n    camera.look = load(iChannel1, addr_camera_look).xy;\n    camera.w = load(iChannel1, addr_camera_w);\n    camera.region = uint(load(iChannel1, addr_camera_region));\n    update_camera(camera);\n    return camera;\n}\n\nvoid cast_ray_on_sphere_at_plane(\n    in vec4 r, // origin of ray (normalized)\n    in vec4 v, // direction of ray (normalized, ⟂ to r)\n    in vec4 n, // normal to the (3D) plane\n    in float d, // offset of plane from center of sphere\n    out vec4 r_, // hit point\n    out vec4 v_, // direction of ray at hit point\n    out float th, // distance travelled\n    out bool hit) // whether it hit anything\n{\n    r_ = vec4(0.0);\n    th = 0.0;\n    hit = false;\n    float cos_angle_diff = d / length(vec2(dot(r, n), dot(v, n)));\n    if (abs(cos_angle_diff) <= 1.0 && dot(r, n) >= d)\n    {\n        hit = true;\n        th = atan(dot(v, n), dot(r, n)) + acos(cos_angle_diff);\n        r_ = r * cos(th) + v * sin(th);\n        v_ = v * cos(th) - r * sin(th);\n    }\n}\n\nvoid cast_ray_on_cylinder_at_window(\n    in vec4 r, // origin of ray (r.xyz normalized)\n    in vec4 v, // direction of ray (normalized)\n    in float win_w, // w coördinate of the window\n    out vec4 r_, // hit point\n    out vec4 v_, // direction of ray at hit point\n    out float dist, // distance travelled\n    out bool hit) // whether it hit anything\n{\n    r_ = vec4(0.0);\n    dist = 0.0;\n    hit = false;\n    if (sign(v.w) == sign(win_w) && r.w * sign(v.w) <= abs(win_w))\n    {\n        hit = true;\n        float w_dist = abs(win_w - r.w);\n        float th_dist = w_dist * length(v.xyz) / abs(v.w);\n        dist = length(vec2(w_dist, th_dist));\n        vec3 v_3D = normalize(v.xyz);\n        r_.w = win_w;\n        r_.xyz = r.xyz * cos(th_dist) + v_3D * sin(th_dist);\n        v_.w = v.w;\n        v_.xyz = (v_3D * cos(th_dist) - r.xyz * sin(th_dist)) * length(v.xyz);\n    }\n}\n\nvoid cast_ray_on_cylinder_at_floor(\n    in vec4 r, // origin of ray (r.xyz normalized)\n    in vec4 v, // direction of ray (normalized)\n    in float plane_z, // z-coördinate of the target plane which is\n                      // parallel to the floor\n    out vec4 r_, // hit point\n    out vec4 v_, // direction of ray at hit point\n    out float dist, // distance travelled\n    out bool hit) // whether it hit anything\n{\n    r_ = vec4(0.0);\n    dist = 0.0;\n    hit = false;\n    vec3 v_3D = normalize(v.xyz);\n    float cos_angle_diff = plane_z / length(vec2(r.z, v_3D.z));\n    if (abs(cos_angle_diff) <= 1.0)\n    {\n        hit = true;\n        float th = atan(v_3D.z, r.z) + acos(cos_angle_diff);\n        r_.xyz = r.xyz * cos(th) + v_3D * sin(th);\n        r_.w = r.w + th * v.w / length(v.xyz);\n        v_.xyz = (v_3D * cos(th) - r.xyz * sin(th)) * length(v.xyz);\n        v_.w = v.w;\n        dist = length(vec2(th, r_.w - r.w));\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}