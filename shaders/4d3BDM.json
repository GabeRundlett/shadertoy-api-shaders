{
    "Shader": {
        "info": {
            "date": "1531003439",
            "description": "click the tiles to move the chess pieces.\nblue: selected brick\ngreen: ok moves\nred: moves that exposes your king",
            "flags": 32,
            "hasliked": 0,
            "id": "4d3BDM",
            "likes": 27,
            "name": "chess",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "game",
                "raycasting",
                "chess"
            ],
            "usePreview": 1,
            "username": "abje",
            "viewed": 1432
        },
        "renderpass": [
            {
                "code": "/*\nnotes:\nin buf A:\npixels from and with (0,0) to and with (7,7) have informations about every brick on the chess board.\npixel.x: the brick id, if the spot on the board is empty, or what brick is on that spot.\npixel.y: the side the brick is on, 0 is white and 1 is black, empty is usually -1.\npixel.z: when you click a piece you are allowed to move, this will be set to 1, blue.\n         the spots where you can move the piece pixel.z is 2, green.\n         unless the move exposes the king to an enemy piece, then it is set to 3, red.\npixel.w: how many times the brick has been moved.\n*/\n\n#define pi acos(-1.0)\n\n#define far 20.0\n\n#define white vec3(0.9,0.75,0.8)\n#define black vec3(0.4,0.2,0.1)\n\n#define ambientlight     0.1\n\n//box intersection from iq\n//https://www.shadertoy.com/view/ld23DV\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n\tfloat tN = max(max( t1.x, t1.y ), t1.z);\n\tfloat tF = min(min( t2.x, t2.y ), t2.z);\n\n\treturn vec2(max(tN,0.0), tF);\n}\n\nfloat cone( vec2 p, vec2 c )\n{\n    p.x = abs(p.x);\n    \n    float l = dot(c,p.xy);\n    \n    vec2 q = p.xy-c*l;\n    \n    // this is optional\n    if (q.x < 0.0) {\n        l = length(p.xy)*sign(p.y*c.y);\n    }\n    \n    return l;\n}\n\nfloat cone( vec3 p, vec2 c )\n{\n    p.x = length(p.xz);\n    \n    float l = dot(c,p.xy);\n    \n    vec2 q = p.xy-c*l;\n    \n    // this is optional\n    if (q.x < 0.0) {\n        l = length(p.xy)*sign(p.y*c.y);\n    }\n    \n    return l;\n}\n\n//cylinder distance from iq\n//https://iquilezles.org/articles/distfunctions\nfloat cylinder( vec3 p, vec2 s) {\n    vec2 q = vec2(length(p.xz),p.y);\n    return length(max(abs(q)-s,0.0));\n}\n\n//torus distance from iq\n//https://iquilezles.org/articles/distfunctions\nfloat torus( vec3 p, float s) {\n    vec2 q = vec2(length(p.xz),p.y);\n    return length(abs(q)-vec2(s,0));\n}\n\nfloat halftorus(vec3 p,float s) {\n    float len = abs(length(vec2(p.x,min(p.y,0.0)))-s);\n    return length(vec3(len,max(p.y,0.0),p.z));\n}\n\n//box distance by iq\n//https://iquilezles.org/articles/distfunctions\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat box( vec3 p, vec3 b )\n{\n    vec3 q = abs(p)-b;\n\treturn max(max(q.x,q.y),q.z);\n}\n\nfloat corner(vec2 p) {\n    return length(max(p,0.0))+min(0.0,max(p.x,p.y));\n}\n\nfloat box(vec2 p, vec2 s) {\n    \n    vec2 q = abs(p)-s;\n    return corner(q);\n    \n}\n\nivec4 getpiece(vec2 p) {\n    return ivec4(texelFetch(iChannel0, ivec2(p), 0));\n}\n\nvec4 getdata(int index) {\n    return texelFetch(iChannel0,ivec2(index+8,1),0);\n}\n\nfloat pawn(vec3 p) {\n    return min(cone(p-vec3(0,0.1,0), normalize(vec2(0.6,0.2))),\n               length(p-vec3(0,0.1,0))-0.15);\n}\n\nfloat castle(vec3 p) {\n    vec3 r = vec3(length(p.xz),p.y,atan(p.x,p.y)*3.14);\n    float len = length(max(abs(r.xy-vec2(0,-0.25))-vec2(0.15,0.25),0.0));\n    \n    \n    vec2 q = abs(p.xz);\n    q = vec2(abs(max(q.x,q.y))-0.13,min(q.x,q.y));\n    \n    len = min(len,length(max(abs(vec3(q,p.y))-vec3(0.015,0.015,0.15),0.0)));\n    \n    q = abs(p.xz*rot(3.14*0.25));\n    q = vec2(abs(max(q.x,q.y))-0.13,min(q.x,q.y));\n    \n    len = min(len,udBox(vec3(q,p.y),vec3(0.015,0.015,0.15)));\n    \n    return len;\n}\n\nfloat queen(vec3 p) {\n    /*vec3 r = vec3(length(p.xz),p.y,atan(p.x,p.y)*3.14);\n    float len = length(max(abs(r.xy-vec2(0,-0.25))-vec2(0.15,0.25),0.0));\n    \n    \n    //vec2 q = abs(p.xz);\n    //q = vec2(abs(max(q.x,q.y))-0.13,min(q.x,q.y));\n    \n    //len = max(len,-length(vec3(q,p.y))+0.04);\n    \n    const mat2 rotation = rot(3.14*0.125);\n    vec2 q = abs(p.xz*rotation);\n    q = vec2(abs(max(q.x,q.y)),min(q.x,q.y))-vec2(0.13,0)*rotation;\n    \n    len = max(len,-length(vec3(q,p.y))+0.04);\n    \n    return len;*/\n    \n    \n    \n    float s = 0.3;\n    \n    vec2 q = vec2(length(p.xz),p.y);\n    q.y += 0.5;\n    \n    float l = 99999.0;\n    \n    //l = min(l,box(q-vec2(0,0.2),vec2(0.6,0.2)));\n    \n    l = min(l,corner(q*rot(pi*1.75)-sqrt(2.0)*0.5*s));\n    \n    vec2 r = q-vec2(0.55,0.3)*s;\n    r = r * rot(pi*1.25);\n    l = max(l, -corner(r));\n    \n    l = min(l, cone(q-vec2(0,6)*s,normalize(vec2(15,1))));\n    \n    r = q-vec2(0.44,0.7)*s;\n    r = r*rot(pi*0.45);\n    l = min(l, cone(r,normalize(vec2(1,1)))-0.02*s);\n    \n    r = q-vec2(0.0,2.5)*s;\n    l = min(l,box(r,vec2(1,0.1)*s));\n    \n    r = q-vec2(0.7,2.1)*s;\n    l = max(l, -length(r)+0.5*s);\n    \n    r = q-vec2(0.37,1.85)*s;\n    r = r*rot(pi*0.5);\n    l = min(l, cone(r,normalize(vec2(2,1)))-0.03*s);\n    \n    r = q-vec2(0.3,1.91)*s;\n    r = r*rot(pi*0.5);\n    l = min(l, cone(r,normalize(vec2(2,1)))-0.03*s);\n    \n    r = q-vec2(0.27,2.1)*s;\n    r = r*rot(pi*0.5);\n    l = min(l, cone(r,normalize(vec2(2,1)))-0.03*s);\n    \n    float l2 = 9999.0;\n    \n    l2 = min(l2,q.y-2.55*s);\n    l2 = min(l2,box(q-vec2(0.0,2.55)*s,vec2(0.1,0.1)*s));\n    l2 = min(l2,cone(q-vec2(0,1.2)*s,normalize(vec2(-4,1))));\n    l2 = max(l2,cone(q-vec2(0,2.95)*s,normalize(vec2(1,1))));\n    \n    l = max(l,l2);\n    \n    l = max(l,corner((q-vec2(0.6,0)*s)*vec2(1,-1)));\n    \n    return l;\n}\n\nfloat king(vec3 p) {\n    vec3 r = vec3(length(p.xz),p.y,atan(p.x,p.y)*3.14);\n    float len = length(max(abs(r.xy-vec2(0,-0.25))-vec2(0.15,0.25),0.0));\n    \n    \n    vec2 q = abs(p.xy-vec2(0,0.1));\n    q = vec2(max(q.x,q.y)-0.05,min(q.x,q.y));\n    \n    len = min(len,udBox(vec3(q,p.z),vec3(0.05,0.02,0.02)));\n    \n    return len;\n}\n\nfloat bishop(vec3 p) {\n    float len = cylinder(p-vec3(0,-0.3,0),vec2(0.1,0.2));\n    len = max(len,-(torus(p-vec3(0,-0.25,0),0.32)-0.3));\n    len = min(len,length(p-vec3(0,-0.02,0))-0.1);\n    len = min(len,max(-p.y+0.057,cone(p-vec3(0,0.163,0),normalize(vec2(0.3,0.2)))));\n    len = min(len,length(p-vec3(0,0.18,0))-0.02);\n    \n    vec3 q = p;\n    q.yz *= rot(pi*0.35);\n    len = max(len,-box(q-vec3(0,0,5), vec3(5.0,0.02,5.0)));\n    \n    return len;\n}\n\nfloat horse(vec3 p) {\n    float len = cylinder(p-vec3(0,-0.45,0),vec2(0.2,0.05));\n    \n    vec3 q = p;\n    q.yz *= rot(pi*0.1);\n    len = min(len,udBox(q-vec3(0,-0.3,-0.15),vec3(0,0.15,0))-0.07);\n    len = min(len,halftorus(-vec3(q.z,q.y,q.x)+vec3(-0.05,-0.15,0),0.1)-0.07);\n    \n    return len;\n}\n\nfloat map(vec3 p, ivec4 piece) {\n    p = mod(p,1.0)-0.5;\n    p.xz *= rot(pi*float(piece.y));\n    if (piece.x == CASTLE) {\n    \treturn castle(p);\n    } else if (piece.x == PAWN) {\n        return pawn(p);\n    } else if (piece.x == BISHOP) {\n        return bishop(p);\n    } else if (piece.x == HORSE) {\n        return horse(p);\n    } else if (piece.x == KING) {\n        return king(p);\n    } else if (piece.x == QUEEN) {\n        return queen(p);\n    } else {\n        return far;\n    }\n}\n\nvec3 normal(vec3 p, ivec4 piece) {\n    vec2 eps = vec2(0.0001,0.0);\n    \n    return normalize(vec3(\n        map(p+eps.xyy,piece)-map(p-eps.xyy,piece),\n        map(p+eps.yxy,piece)-map(p-eps.yxy,piece),\n        map(p+eps.yyx,piece)-map(p-eps.yyx,piece)));\n}\n\nivec4 tracebricks(in vec3 ro, in vec3 rd, inout float dist, in float limit) {\n    dist += 0.01;\n    ro += rd*dist;\n    vec2 pixel = floor(ro.xz)+4.0;\n    \n    vec2 invrd = 1.0/(abs(rd.xz)+0.001);\n    vec2 signrd = sign(rd.xz);\n    \n    vec2 dists = invrd * abs((signrd*0.5+0.5)-fract(ro.xz));\n    \n    vec2 mask = vec2(lessThan(dists,dists.yx));\n    \n    ivec4 piece = getpiece(pixel);\n    \n    for (int i = 0; i < 100+iFrame%2; i++) {\n        float len = map(ro,piece);\n        if (len < 0.001 || dist > limit) {\n            break;\n        }\n        float closest = dot(mask,dists);\n        len = min(len,closest);\n        dist += len;\n        dists -= len;\n        ro += len*rd;\n        if (len == closest) {\n            pixel += mask*signrd;\n            dists += mask*invrd;\n    \t\tmask = vec2(lessThan(dists,dists.yx));\n            piece = getpiece(pixel);\n        }\n    }\n    return piece;\n}\n\n// Taken from one of Shane's shaders\n// https://www.shadertoy.com/view/4lSBzm\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n    mat3 tex = mat3(\n        texture(t, p.yz).xyz,\n        texture(t, p.zx).xyz,\n        texture(t, p.xy).xyz);\n    \n    tex = matrixCompMult(tex,tex);\n    \n    return tex*n;\n}\n\nvec3 getlightpos() {\n    return vec3(0,5,0);\n}\n\nfloat smax( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(a-b)/k, 0.0, 1.0 );\n    return mix( b, a, h ) + k*h*(1.0-h);\n}\n\nfloat shadow(vec3 ro) {\n    vec3 lightpos = getlightpos();\n    float lightlen = length(ro-lightpos);\n    vec3 light = (ro-lightpos)/lightlen;\n    \n    float shadow = 0.0;\n    vec2 box = iBox(ro-vec3(0,0.5,0),-light,vec3(4.0,0.5,4.0));\n\tbox.y = min(box.y,lightlen);\n    ivec4 piece = tracebricks(ro,-light,box.x,box.y);\n\n    if (box.y < box.x+0.01) {\n        shadow = 1.0;\n    }\n    \n    return shadow;\n}\n\nvec4 lighting( vec4 color, vec3 ro, vec3 rd, vec3 normal, float shadow) {\n    vec3 lightpos = getlightpos();\n    vec3 light = normalize(ro-lightpos);\n    float ambient = ambientlight;\n    \n    float diffusion = dot(-light,normal);\n    \n    vec3 sp = pow(clamp(dot(-light,reflect(rd,normal)),0.0,1.0),25.0)*vec3(0.5,0.5,0.6);\n    \n    float lighting = clamp(diffusion*shadow,ambient,1.0);\n    \n    color.xyz = min(color.xyz*lighting+sp*shadow,1.0);\n    return color;\n}\n\nvec4 shadebrick(vec3 ro, vec3 rd, ivec4 piece) {\n    vec4 fragColor = vec4(1);\n    vec3 normal = normal(ro, piece);\n    \n    vec3 color = vec3(0);\n    if (piece.y == 1) {\n        color = color+black.xyz;\n    } else {\n        color = color+white.xyz;\n    }\n    //color = fract(ro);\n    fragColor = lighting(vec4(color,1),ro,rd,normal,1.0);\n    return (fragColor);\n}\n\nvec4 reflection(vec3 ro, vec3 rd) {\n    \n    vec2 box = iBox(ro-vec3(0,0.5,0),rd,vec3(4.0,0.5,4.0));\n    ivec4 piece = tracebricks(ro,rd,box.x,box.y);\n\n    if (box.y < box.x+0.01) {\n       return textureLod(iChannel1,rd,0.0)*0.4;\n    }\n    \n    return shadebrick(ro+rd*box.x, rd, piece);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv =  (fragCoord.xy*2.0-iResolution.xy  )/iResolution.y;\n\tvec4 muv = (abs(iMouse) *2.0-iResolution.xyxy)/iResolution.y;\n    \n    vec4 camdata = getdata(DATA_CAM);\n    vec3 ro = getro(uv, camdata);\n    vec3 rd = getrd(uv, camdata);\n    \n    //raymarching bounding box\n    vec2 box = iBox(ro-vec3(0,0.5,0),rd,vec3(4.0,0.5,4.0));\n    \n    ivec4 piece = tracebricks(ro,rd,box.x,box.y);\n    \n    if (box.y < box.x+0.01) {\n        box.x = far;\n    }\n    \n    //the chess board\n    vec2 box2 = iBox(ro-vec3(0,-0.1,0),rd,vec3(5.0,0.1,5.0));\n    \n    if (box2.y < box2.x+0.01) {\n        box2.x = far;\n    }\n    \n    if ( box.x < box2.x) {\n        ro += rd*box.x;\n\n        fragColor = shadebrick(ro, rd, piece);\n    } else {\n        if (box2.x < far) {\n            ro += rd*box2.x;\n            vec3 q = (ro-vec3(0,-0.1,0))/vec3(10,0.2,10);\n            vec3 q2 = abs(q);\n            \n            vec3 normal = vec3(greaterThan(q2,max(q2.yzx,q2.zxy)))*sign(q);\n            \n            int side = 0;\n            \n            fragColor = vec4(0);\n            vec4 color = vec4(1);\n            \n            if (normal == vec3(0,1,0)) {\n                vec2 p = abs(ro.xz);\n                if (all(lessThan(abs(p),vec2(4)))) {\n                    \n                    ivec2 p2 = ivec2(ro.xz+4.0);\n            \t\tside = (p2.x+p2.y+1)%2;\n                    \n                    if (getpiece(vec2(p2)).z == 1) {\n                        color = vec4(0,0,1,1);\n                    }\n                    if (getpiece(vec2(p2)).z == 2) {\n                        color = vec4(0,1,0,1);\n                    }\n                    if (getpiece(vec2(p2)).z == 3) {\n                        color = vec4(1,0,0,1);\n                    }\n                } else if (max(p.x,p.y) > 4.1) {\n                    side = 1;\n                    if (max(p.x,p.y) > 4.2) {\n                        side = int(getdata(DATA_TURN).x);\n                    }\n                }\n            }\n            if (side == 1) {\n                fragColor.xyz = fragColor.xyz+black;\n            } else {\n                fragColor.xyz = fragColor.xyz+white;\n            }\n            float shadow = shadow(ro);\n            fragColor = lighting(fragColor,ro,rd,normal,shadow);\n            \n            fragColor *= color;\n            fragColor += 0.4*reflection(ro,reflect(rd,normal));\n            \n        } else {\n            fragColor = vec4(0.5);\n        }\n    }\n    \n    fragColor = pow(fragColor,vec4(1.0/2.2));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec4 getdata(int index)\n{\n    return texelFetch(iChannel0,ivec2(index+8,1),0);\n}\n\nvec4 getchessbrick(ivec2 pos, int page)\n{\n    return texelFetch(iChannel0,pos+ivec2(0,page*8),0);\n}\n\nvec4 chessinit(ivec2 p)\n{\n    vec4 fragColor = vec4(0,0,0,0);\n    if (p.y > 4)\n    {\n        p.y = 7-p.y;\n        fragColor.y = 1.0;\n    }\n    \n    if (p.y == 1) {\n        fragColor.x = float(PAWN);\n    }\n    \n    else if(p.y == 0)\n    {\n\t\tconst int pieces[8] = int[8](CASTLE, HORSE, BISHOP, QUEEN, KING, BISHOP, HORSE, CASTLE);\n        fragColor.x = float(pieces[p.x]);\n    }\n    \n    if (int(fragColor.x) == EMPTY) fragColor.y = -1.0;\n    return fragColor;\n}\n\nivec2 getclickcell()\n{\n\tvec4 muv = (abs(iMouse) *2.0-iResolution.xyxy)/iResolution.y;\n    \n    vec4 camdata = getdata(DATA_CAM);\n    vec3 ro = getro(muv.xy, camdata);\n    vec3 rd = getrd(muv.xy, camdata);\n    \n    //projecting the click to the board using ray-plane intersection\n    float len = -ro.y/min(rd.y,-0.001);\n    ro += rd*len;\n    \n    //if you click outside the board, return -1\n    if (any(greaterThan(abs(ro.xz),vec2(4)))) return ivec2(-1);\n    \n    ivec2 pos = ivec2(ro.xz+4.0);\n    \n    return pos;\n}\n\nbool protectking(ivec2 ro, ivec2 from, ivec2 to, int turn)\n{\n    \n    ivec2 rd = ivec2(1);\n    for (int rot = 0; rot < 4; rot++)\n    {\n        \n        ivec2 q = abs((rd+1)/2*7-ro);\n        int steps = min(q.x,q.y)+1;\n        \n        for (int i = 1; i < steps; i++)\n        {\n            ivec2 p = ro+rd*i;\n            if (p==from) continue;\n            if (p==to) p = from;\n            \n            ivec4 brick = ivec4(getchessbrick(p,0));\n            if (brick.x != EMPTY && brick.x != ENPASSANT)\n            {\n                if ((brick.x == BISHOP || brick.x == QUEEN)\n                    && brick.y != turn) {\n                    return false;\n                }\n                break;\n            }\n        }\n        rd = ivec2(rd.y,-rd.x);\n    }\n    \n    rd = ivec2(1,0);\n    for (int rot = 0; rot < 4; rot++) {\n        \n        int steps = int(abs(dot(vec2((rd+1)/2*7-ro),vec2(rd))))+1;\n        \n        for (int i = 1; i < steps; i++) {\n            ivec2 p = ro+rd*i;\n            if (p==from) continue;\n            if (p==to) p = from;\n            \n            ivec4 brick = ivec4(getchessbrick(p,0));\n            if (brick.x != EMPTY && brick.x != ENPASSANT) {\n                if ((brick.x == CASTLE || brick.x == QUEEN)\n                    && brick.y != turn) {\n                    return false;\n                }\n                break;\n            }\n        }\n        rd = ivec2(rd.y,-rd.x);\n    }\n    \n    rd = ivec2(-2,1);\n    for (int i = 0; i < 2; i++) {\n        for (int rot = 0; rot < 4; rot++) {\n            ivec2 p = ro+rd;\n            if (max(p.x,p.y)<8&&min(p.x,p.y)>=0&&p!=from) {\n                if (p==to) p = from;\n\n                ivec4 brick = ivec4(getchessbrick(p,0));\n                if (brick.x == HORSE && brick.y != turn) {\n                    return false;\n                }\n            }\n\n            rd = ivec2(rd.y,-rd.x);\n        }\n        rd.x *= -1;\n    }\n    \n    rd = ivec2(1);\n    for (int i = 0; i < 2; i++) {\n        for (int rot = 0; rot < 4; rot++) {\n            ivec2 p = ro+rd;\n            if (max(p.x,p.y)<8&&min(p.x,p.y)>=0&&p!=from) {\n                if (p==to) p = from;\n\n                ivec4 brick = ivec4(getchessbrick(p,0));\n                if (brick.x == KING && brick.y != turn) {\n                    return false;\n                }\n            }\n\n            rd = ivec2(rd.y,-rd.x);\n        }\n        rd.x *= 0;\n    }\n    \n    int forw = 1-turn*2;\n    for (int i = -1; i < 2; i+=2) {\n        ivec2 rd = ivec2(i,forw);\n        ivec2 p = ro+rd;\n        if (max(p.x,p.y)<8&&min(p.x,p.y)>=0) {\n            if (p==to) p = from;\n\n            ivec4 brick = ivec4(getchessbrick(p,0));\n            if (brick.x == PAWN && brick.y != turn) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n\nbool checkroute(ivec2 pos, ivec2 coord, vec4 brick) {\n    \n    vec4 hitbrick = getchessbrick(coord,0);\n    \n    ivec2 diff = coord-pos;\n    ivec2 adiff = abs(diff);\n    \n    if (int(hitbrick.y) == int(brick.y)) return false;\n    \n    if (int(brick.x) == PAWN) {\n        int forw = 1;\n        if (int(brick.y) == 1) forw = -1;\n        \n        if (pos+ivec2(0,forw)==coord) {\n            return int(getchessbrick(pos+ivec2(0,forw),0).x) == EMPTY;\n        }\n        if (int(brick.w) == 0 && pos+ivec2(0,2*forw)==coord) {\n            return int(getchessbrick(pos+ivec2(0,forw),0).x) == EMPTY\n                && int(getchessbrick(pos+ivec2(0,2*forw),0).x) == EMPTY;\n        }\n        if (pos+ivec2(1,forw)==coord) {\n            return !any(equal(ivec2(getchessbrick(pos+ivec2( 1,forw),0).xy), ivec2(EMPTY,brick.y)));\n        }\n        if (pos+ivec2(-1,forw)==coord) {\n            return !any(equal(ivec2(getchessbrick(pos+ivec2(-1,forw),0).xy), ivec2(EMPTY,brick.y)));\n        }\n        \n    }\n    \n    if (int(brick.x) == HORSE) {\n        int len = diff.x*diff.x+diff.y*diff.y;\n        if (len == 5) {\n            return true;\n        }\n    }\n    \n    if (int(brick.x) == CASTLE\n      ||int(brick.x) == QUEEN) {\n        if (any(equal(pos,coord))) {\n            int len = adiff.x+adiff.y;\n            ivec2 dir = diff/len;\n            for (int i = 1; i < len; i++) {\n                vec4 brick2 = getchessbrick(pos+dir*i,0);\n                if (int(brick2.x) != EMPTY && int(brick2.x) != ENPASSANT) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    \n    if (int(brick.x) == BISHOP\n      ||int(brick.x) == QUEEN) {\n        if (adiff.x==adiff.y) {\n            ivec2 dir = diff/adiff.x;\n            for (int i = 1; i < adiff.x; i++) {\n                vec4 brick2 = getchessbrick(pos+dir*i,0);\n                if (int(brick2.x) != EMPTY && int(brick2.x) != ENPASSANT) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    \n    if (int(brick.x) == KING) {\n        if (max(adiff.x,adiff.y) == 1) {\n            return true;\n        }\n        if (int(brick.w) == 0 && diff.y == 0) {\n            if (diff.x == 2) {\n                if (int(getchessbrick(pos+ivec2(1,0),0).x) == EMPTY\n                  &&int(getchessbrick(pos+ivec2(2,0),0).x) == EMPTY\n                  &&ivec2(getchessbrick(pos+ivec2(3,0),0).xw) == ivec2(CASTLE,0)) {\n                    return true;\n                }\n            }\n            if (diff.x == -2) {\n                if (int(getchessbrick(pos+ivec2(-1,0),0).x) == EMPTY\n                  &&int(getchessbrick(pos+ivec2(-2,0),0).x) == EMPTY\n                  &&int(getchessbrick(pos+ivec2(-3,0),0).x) == EMPTY\n                  &&ivec2(getchessbrick(pos+ivec2(-4,0),0).xw) == ivec2(CASTLE,0)) {\n                    return true;\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n\nvec4 datapixels(int index, bool refresh)\n{\n    vec4 data = getdata(index);\n    \n    if (index == DATA_CLICK)\n    {\n        if (refresh)\n        {\n            data = vec4(-1,-1,iMouse.z, abs(iMouse.w));\n            return data;\n        }\n        \n        vec4 lastmouse = getdata(DATA_LAST_MOUSE);\n        float mouselen = length(lastmouse.xy-lastmouse.zw);\n        if (iMouse.z < 0.5 && lastmouse.z > 0.5 && mouselen < draglimit)\n        {\n            if (data.x < -0.5)\n            {\n                ivec2 pos = getclickcell();\n                \n                vec4 brick = getchessbrick(pos,0);\n                \n\t\t\t\tvec4 turndata = getdata(DATA_TURN);\n                \n                if (int(brick.y) == int(turndata.x))\n                {\n                \tdata.xy = vec2(pos);\n                }\n                else\n                {\n                    data.xy = vec2(-1);\n                }\n            } else {\n                data.xy = vec2(-1);\n            }\n        }\n        return data;\n    }\n    \n    if (index == DATA_TURN)\n    {\n        if (refresh)\n        {\n            data = vec4(0,iResolution.xy,0);\n            return data;\n        }\n        \n\t\tvec4 clickdata = getdata(DATA_CLICK);\n\t\tvec4 lastmouse = getdata(DATA_LAST_MOUSE);\n        float mouselen = length(lastmouse.xy-lastmouse.zw);\n        \n        if (iMouse.z < 0.5&&lastmouse.z > 0.5&&mouselen < draglimit)\n        {\n            ivec2 pos = getclickcell();\n            vec4 brick = getchessbrick(pos,0);\n            if (int(brick.z) == 2)\n            {\n                data.x = 1.0-data.x;\n            }\n        }\n    }\n    \n    if (index == DATA_KINGS+0\n      ||index == DATA_KINGS+1)\n      {\n        int king = index-DATA_KINGS;\n        \n        if (refresh) data.xy = vec2(4,king*7);\n        \n        vec4 clickdata = getdata(DATA_CLICK);\n\t\tvec4 lastmouse = getdata(DATA_LAST_MOUSE);\n        float mouselen = length(lastmouse.xy-lastmouse.zw);\n        if (iMouse.z < 0.5&&lastmouse.z > 0.5&&mouselen < draglimit)\n        {\n            ivec2 pos = getclickcell();\n            vec4 brick = getchessbrick(pos,0);\n            vec4 brick2 = getchessbrick(ivec2(clickdata.xy),0);\n            \n            int turn = int(getdata(DATA_TURN).x);\n            \n            if (int(brick.z) == 2 && int(brick2.x) == KING && turn == king)\n            {\n                data.xy = vec2(pos);\n            }\n        }\n    }\n    \n    if (index == DATA_LAST_MOUSE)\n    {\n        data = vec4(iMouse.xyz, abs(iMouse.w));\n    }\n    \n    if (index == DATA_CAM)\n    {\n        if (refresh)\n        {\n            data.xy = vec2(0,-PI*0.5);\n            return data;\n        }\n        vec4 lastmouse = getdata(DATA_LAST_MOUSE);\n        if (min(lastmouse.z,iMouse.z) > 0.5)\n        {\n            data.xy += (iMouse.xy-lastmouse.xy)/iResolution.y*sensitivity;\n        }\n    }\n    \n    return data;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 uv =  (fragCoord.xy*2.0-iResolution.xy  )/iResolution.y;\n\tvec4 muv = (abs(iMouse) *2.0-iResolution.xyxy)/iResolution.y;\n    \n\tvec4 turndata = getdata(DATA_TURN);\n    bool refresh = iFrame == 0;//dot(abs(turndata.yz-iResolution.xy),vec2(1)) > 1.0;\n    \n    \n    ivec2 coord = ivec2(fragCoord);\n    fragColor = texelFetch(iChannel0,coord,0);\n    if (refresh)\n    {\n        fragColor = vec4(-1);\n        if (all(lessThan(coord, ivec2(8))))\n        {\n            fragColor = chessinit(coord);\n        \treturn;\n        }\n    }\n    \n    // is this one of the chess-cell data pixels?\n    if (all(lessThan(coord, ivec2(8,8))))\n    {\n\t\tvec4 clickdata = getdata(DATA_CLICK);\n        vec4 lastmouse = getdata(DATA_LAST_MOUSE);\n        \n        float mouselen = length(lastmouse.xy-lastmouse.xy);\n        int turn = int(getdata(DATA_TURN).x);\n        \n        \n        if (iMouse.z < 0.5 && lastmouse.z > 0.5 && mouselen < draglimit)\n        {\n            ivec2 pos = getclickcell();\n            if (clickdata.x < -0.5)\n            {\n                vec4 brick = getchessbrick(pos,0);\n                \n                if (int(brick.y) == int(turndata.x) && int(brick.x) != EMPTY)\n                {\n                    if (pos == coord)\n                    {\n                        fragColor.z = 1.0;\n                    }\n                    else\n                    {\n                        bool route = checkroute(pos,coord,brick);\n                        if (route)\n                        {\n                            bool protect;\n                            if (int(brick.x) == KING)\n                            {\n                                protect = protectking(coord,pos,coord,turn);\n                                if (abs(pos.x-coord.x)>1)\n                                {\n                                    protect = protect&&protectking((coord+pos)/2,pos,(coord+pos)/2,turn);\n                                }\n                            }\n                            else\n                            {\n                            \tivec2 kingpos = ivec2(getdata(DATA_KINGS+int(brick.y)).xy);\n                                protect = protectking(kingpos,pos,coord,turn);\n                            }\n                            \n                            // if king is protected with the move, paint it green\n                            if (protect)\n                            {\n                        \t\tfragColor.z = 2.0;\n                            }\n                            else\n                            {\n                                fragColor.z = 3.0;\n                            }\n                        }\n                        else\n                        {\n                            fragColor.z = 0.0;\n                        }\n                    }\n                }\n            }\n            else\n            {\n                if (int(fragColor.z) == 2 && coord == pos)\n                {\n                \tvec4 brick = getchessbrick(ivec2(clickdata.xy),0);\n                    fragColor = brick;\n                    if ((coord.y == 7 || coord.y == 0) && int(brick.x) == PAWN)\n                    {\n                        fragColor.x = float(QUEEN);\n                    }\n                    fragColor.w++;\n                }\n                else if(int(fragColor.x) == ENPASSANT)\n                {\n                \tvec4 brick = getchessbrick(pos,0);\n                    \n                    if (int(brick.z) == 2)\n                    {\n                    \tfragColor = vec4(EMPTY,-1,0,0);\n                    }\n                    \n                }\n                else if (int(fragColor.z) == 1)\n                {\n                    vec4 brick = getchessbrick(pos,0);\n                    if (int(brick.z) == 2)\n                    {\n                        fragColor = vec4(EMPTY,-1,0,0);\n                    }\n                }\n                else if (ivec2(fragColor.xw) == ivec2(PAWN,1))\n                {\n                    ivec2 p = coord+ivec2(0,fragColor.y*2.0-1.0);\n                    vec4 enpassant = getchessbrick(p,0);\n                    vec4 pawn = getchessbrick(ivec2(clickdata.xy),0);\n                    if (int(enpassant.x) == ENPASSANT && int(pawn.x) == PAWN && pos == p)\n                    {\n                        fragColor = vec4(EMPTY,-1,0,0);\n                    }\n                }\n                else if ((coord.y == 2 || coord.y == 5) && coord.x == pos.x)\n                {\n                    vec4 clickbrick = getchessbrick(pos,0);\n                    vec4 pawn = getchessbrick(ivec2(clickdata.xy),0);\n                    if (coord == (pos+ivec2(clickdata.xy))/2)\n                    {\n                        fragColor = pawn;\n                        fragColor.x = float(ENPASSANT);\n                    }\n            \t}\n                else if ((coord.y == 0 || coord.y == 7) && coord.y == pos.y)\n                {\n                    vec4 clickbrick = getchessbrick(pos,0);\n                    vec4 king = getchessbrick(ivec2(clickdata.xy),0);\n                    if (int(clickbrick.z) == 2 && ivec2(king.xw) == ivec2(KING,0))\n                    {\n                        if (coord.x < 4 && pos.x == 2)\n                        {\n                            vec4 castle = getchessbrick(ivec2(0,coord.y),0);\n                            if (ivec2(castle.xw) == ivec2(CASTLE,0))\n                            {\n                                if (coord.x == 3)\n                                {\n                                    fragColor = castle;\n                                }\n                                if (coord.x == 0)\n                                {\n                                    fragColor = vec4(EMPTY,-1,0,0);\n                                }\n                            }\n                        }\n                        else if (coord.x > 4 && pos.x == 6)\n                        {\n                            vec4 castle = getchessbrick(ivec2(7,coord.y),0);\n                            if (ivec2(castle.xw) == ivec2(CASTLE,0))\n                            {\n                                if (coord.x == 5)\n                                {\n                                    fragColor = castle;\n                                }\n                                if (coord.x == 7)\n                                {\n                                    fragColor = vec4(EMPTY,-1,0,0);\n                                }\n                            }\n                        }\n                    }\n                }\n                \n            \tint turn = int(getdata(DATA_TURN).x);\n                \n                vec4 clickbrick = getchessbrick(pos,0);\n                ivec2 from = ivec2(-1);\n                ivec2 to = ivec2(-1);\n                \n                if (int(clickbrick.z) == 2)\n                {\n                    to = pos;\n                    from = ivec2(clickdata.xy);\n                    \n                    turn = 1-turn;\n                }\n                \n                fragColor.z = 0.0;\n                ivec2 kingpos = ivec2(getdata(DATA_KINGS+turn).xy);\n                if (ivec2(fragColor.xy) == ivec2(KING,turn))\n                {\n                \tfragColor.z = 3.0*float(!protectking(coord,from,to,turn));\n                }\n            }\n        }\n    }\n    \n    // or is it one of the game data pixels?\n    if (coord.y == 1 && coord.x >= 8)\n    {\n        fragColor = datapixels(coord.x-8, refresh);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define draglimit 5.0\n#define sensitivity 3.0\n\n#define EMPTY 0\n#define CASTLE 1\n#define PAWN 2\n#define BISHOP 3\n#define HORSE 4\n#define KING 5\n#define QUEEN 6\n#define ENPASSANT 7\n\n#define DATA_TURN  0\n#define DATA_CLICK 1\n#define DATA_KINGS 2 //uses 2 pixels\n#define DATA_LAST_MOUSE 4\n#define DATA_CAM   5\n\n#define PI 3.14\n\n#define rot(A) mat2(cos(A),-sin(A),sin(A),cos(A))\n#define sqr(a) (a*a)\n\nvec3 getro(vec2 uv, vec4 camdata) {\n    vec3 ro = vec3(0,0,-6);\n    ro.zy *= rot(camdata.y);\n    ro.zx *= rot(camdata.x);\n    return ro;\n}\n\nvec3 getrd(vec2 uv, vec4 camdata) {\n    vec3 rd = normalize(vec3(uv,1));\n    \n    rd.zy *= rot(camdata.y);\n    rd.zx*= rot(camdata.x);\n    return rd;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}