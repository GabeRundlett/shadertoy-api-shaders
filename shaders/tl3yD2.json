{
    "Shader": {
        "info": {
            "date": "1609914568",
            "description": "Three formulas, combinations between geometries and calculations are tested",
            "flags": 0,
            "hasliked": 0,
            "id": "tl3yD2",
            "likes": 1,
            "name": "RayMarch-形状组合计算",
            "published": 3,
            "tags": [
                "raymarch"
            ],
            "usePreview": 0,
            "username": "hanker",
            "viewed": 272
        },
        "renderpass": [
            {
                "code": "#define S(a,b,t) smoothstep(a,b,t)\n#define T iTime\n#define MAX_STEP 100\n#define MAX_DIST 100.\n#define SURFACE_DIST .001\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\nfloat intersectSDF(float distA,float distB){\n    return max(distA,distB);\n}\n\n\n\nfloat unionSDF(float distA,float distB){\n    return min(distA,distB);\n}\nfloat differenceSDF(float distA,float distB){\n    return max(distA,-distB);\n}\nfloat sdBox(vec3 p,vec3 c,vec3 s){\n    return length(max(abs(c - p) - s,0.));\n}\nfloat sdSphere(vec3 p,vec3 ori,float s){\n    return length(p - ori) - s;\n}\nfloat GetDist(vec3 p){\n    float boxDist = sdBox(p,vec3(0.,0.,0.),vec3(4.));\n    float sphereDistInner = sdSphere(p,vec3(0.,0.,0.),6. * abs(sin(T)));\n    float sphereDist = sdSphere(p,vec3(0.,0.,0.),6. * abs(sin(T)));\n    float d = differenceSDF(boxDist,sphereDistInner);\n    d = intersectSDF(d,sphereDist);\n    return d;\n}\nvec3 GetNormal(vec3 p){\n    float d = GetDist(p);\n    vec2 offset = vec2(.001,0.);\n    return normalize(d - vec3(\n       GetDist(p - offset.xyy),\n       GetDist(p - offset.yxy),\n       GetDist(p - offset.yyx)\n    ));\n}  \nfloat RayMarch(vec3 ro,vec3 rd){\n    float d = 0.;\n    for(int i = 0; i < MAX_STEP; i++){\n        vec3 p = ro + rd * d;\n        float dS = GetDist(p);\n        d += dS;\n        if(d > MAX_DIST || dS < SURFACE_DIST)break;\n    }\n    return d;\n}\nvec3 GetRayDir(vec2 uv,vec3 ro,vec3 look,float z){\n    vec3 forward = normalize(look - ro);\n    vec3 right = normalize(cross(vec3(0.,1.,0.),forward));\n    vec3 top = cross(forward,right);\n    vec3 center = ro + z * forward;\n\n    vec3 i = center + right * uv.x + top * uv.y;\n    vec3 dir = normalize(i - ro);\n\n    return dir;\n}\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2. - 1.;\n    if(iResolution.y > iResolution.x)uv.y *= iResolution.y / iResolution.x;\n    else uv.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(0.);\n    vec3 ro = vec3(8. * sin(T),5.,7.* cos(T));\n\n    vec3 rd = GetRayDir(uv,ro,vec3(0.,0.,0.),1.);\n\n    float d = RayMarch(ro,rd);\n    if(d < MAX_DIST){\n        vec3 p = ro + rd * d;\n        vec3 normal = GetNormal(p);\n        float diffuse = clamp(dot(normal,normalize(vec3(1.,2.,-3.))),0.,1.) * .5 + .5;\n        col += diffuse;\n    }\n    fragColor = vec4(col,1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}