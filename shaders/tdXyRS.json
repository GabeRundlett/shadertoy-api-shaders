{
    "Shader": {
        "info": {
            "date": "1585590440",
            "description": "Weird idea for shader using gradients of certain primitives to bend the ray during march.  Very prone to artifacts, still seemed to have an relatively interesting effect though.  Next attempt would be to factor out the anti convergence for analytic solu.",
            "flags": 0,
            "hasliked": 0,
            "id": "tdXyRS",
            "likes": 6,
            "name": "Reverse Blackhole Raymarching",
            "published": 3,
            "tags": [
                "raymarch",
                "warp"
            ],
            "usePreview": 0,
            "username": "FrickHazard",
            "viewed": 549
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415926535\n\n\n#define CONVERGENCE 0.001f\n// low values = higher time in black hole objects\n// next idea would be to more anylitcally do this\n#define DARK_ANTI_CONVERGENCE 0.05f\n// change this to lessen the effect, increasing produces less artifacts\n// 1 is where the pull/push of the black hole is equal to the ray\n#define VIEW_RAY_WEIGHT 4.0f\n#define ITERATIONS 120u\n// toggle between normal and reverse black holes\n// because of the anti convergence 0 is buggy, need to revisit\n#define PUSH 1\n#define GRID_SIZE 7.5\n// colors\nvec3 paloffset = vec3(16., 8., 16.3);\nvec3 palRep = vec3(8., 4., 6.);\n// anim\nvec3 mainSeq = vec3(0);\nvec3  darkSceneSeq = vec3(0);\n\nvoid setAnimations()\n{\n\tmainSeq.x = smoothstep(0., 4., mod(iTime, 40.)) - smoothstep(8., 12., mod(iTime, 40.));\n    mainSeq.y = smoothstep(0., 4., mod(iTime + 20., 40.)) - smoothstep(8., 12., mod(iTime + 20., 40.));\n    mainSeq.z = smoothstep(18., 20., mod(iTime, 40.)) - smoothstep(38., 40., mod(iTime, 40.));\n\n    darkSceneSeq.x = mod(iTime/16., 4.);\n  \tdarkSceneSeq.y = mod(iTime -2., 1.) * (mod(iTime, 16.) > 15. ? 1. : 0.);\n    darkSceneSeq.z = smoothstep(12., 13., mod(iTime - 2., 16.)) - smoothstep(15., 16., mod(iTime- 2., 16.));\n\n    paloffset += vec3(iTime) * 0.4;\n    palRep += vec3(0.5 + 0.5 *sin(iTime * PI * 0.01), 0.5 + 0.5 *cos(iTime * PI * 0.01), 0.5 + 0.5 *sin(iTime * PI * 0.01 + 40.));\n}\n\n// Camera code, shamelessly copied from https://www.shadertoy.com/view/4s3SRN\nvec3 cp[16];\nvoid setCamPath(){\n    const float sl = GRID_SIZE;\n    const float yBump = GRID_SIZE/2.;\n    cp[0] = vec3(0, yBump, sl);\n    cp[1] = vec3(0, yBump, 2. * sl);\n    cp[2] = vec3(sl, yBump, 2.* sl);\n    cp[3] = vec3(2.*sl, yBump,2.* sl);\n    cp[4] = vec3(2.*sl, yBump, sl);\t\n    cp[5] = vec3(2.*sl, yBump, 0);\t\n    cp[6] = vec3(sl, yBump, 0);\n    cp[7] = vec3(0, yBump, 0);\n    \n\tcp[8] = vec3(0, yBump, sl);\n    cp[9] = vec3(0, yBump, 2. * sl);\n    cp[10] = vec3(sl, yBump, 2.* sl);\n    cp[11] = vec3(2.*sl, yBump,2.* sl);\n    cp[12] = vec3(2.*sl, yBump, sl);\t\n    cp[13] = vec3(2.*sl, yBump, 0.);\t\n    cp[14] = vec3(sl, yBump, 0.);\n    cp[15] = vec3(0., yBump, 0.);\n    // for(int i =0; i < 16; i++)cp[i] += vec3(GRID_SIZE/2. + 2., 0., GRID_SIZE/2. + 2.);\n}\nvec3 Catmull(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t){\n    return (((-p0 + p1*3. - p2*3. + p3)*t*t*t + (p0*2. - p1*5. + p2*4. - p3)*t*t + (-p0 + p2)*t + p1*2.)*.5);\n}\nvec3 camPath(float t){    \n    const int aNum = 16;    \n    t = fract(t/float(aNum))*float(aNum);\t// Repeat every 16 time units.\n    // Segment number. Range: [0, 15], in this case.\n    float segNum = floor(t);\n    // Segment portion. Analogous to how far we are alone the individual line segment. Range: [0, 1].\n    float segTime = t - segNum; \n    if (segNum == 0.) return Catmull(cp[aNum-1], cp[0], cp[1], cp[2], segTime);     \n    for(int i=1; i<aNum-2; i++){\n        if (segNum == float(i)) return Catmull(cp[i-1], cp[i], cp[i+1], cp[i+2], segTime); \n    }    \n    if (segNum == float(aNum-2)) return Catmull(cp[aNum-3], cp[aNum-2], cp[aNum-1], cp[0], segTime); \n    if (segNum == float(aNum-1)) return Catmull(cp[aNum-2], cp[aNum-1], cp[0], cp[1], segTime);\n    return vec3(0);\n}\n\n// Signed distance functions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// gradients\n// prefer exact gradients for cleaner effect\n// also good exercise to do this\n\nvec3 grdBox(vec3 p, vec3 b)\n{             \n    vec3 q = abs(p) - b;\n    float t = length(max(q, 0.));\n    \n    // asymptotic limit; cant use step since infintiy can win in 0 * (1/0)\n    float lambda = (t == 0. ? 0. : (1./t));\n \t\n    float dx = step(0., q.x) * q.x * sign(p.x) * lambda +\n        \t\tstep(q.x, 0.) * step(max(q.z, q.y), q.x) * sign(p.x);\n    float dy = step(0., q.y) * q.y * sign(p.y) * lambda +\n        \t\tstep(q.y, 0.) * step(max(q.x, q.z), q.y) * sign(p.y);\n    float dz = step(0., q.z) * q.z * sign(p.z) * lambda +\n        \t\tstep(q.z, 0.) * step(max(q.x, q.y), q.z) * sign(p.z);\n    \n    return vec3(\n    \tdx,\n        dy,\n        dz\n    );\n}\n\nvec3 grdTorus(vec3 p, vec2 t)\n{\n    float xzLength = length(p.xz);\n    \n    vec2 q = vec2(xzLength-t.x,p.y);\n    \n  \tfloat sdTorus = length(q)-t.y;\n    \n    float d = (1./sdTorus) * (xzLength-t.x) * (1./xzLength);\n    \n    return vec3(\n    \td * p.x,\n        (1./sdTorus) * p.y,\n        d * p.z\n    );\n}\n\nvec3 grdSphere(vec3 p)\n{\n    float b = length(p);\n    return vec3(\n    \t(p.x)/b,\n        (p.y)/b,\n        (p.z)/b\n    );\n}\n\nvec3 grdCappedCylinder( vec3 p, float h, float r )\n{\n    //  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    // return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    \n    float lengthXZ = length(p.xz);\n    vec2 d = abs(vec2(lengthXZ,p.y)) - vec2(h,r);  \n    \n    float outerDistance = length(max(d,0.0));\n    \n    // asymptotic limit; cant use step since infintiy can win in 0 * (1/0)\n    float lambda = (outerDistance == 0. ? 0. : (1./outerDistance));\n    \n    float zeta = lambda * d.x  * 1./lengthXZ;\n    \n    float dx = step(d.x, 0.) * step(d.y, d.x) * sign(lengthXZ) * 1./lengthXZ * p.x +\n               step(0., d.x) * zeta * p.x;\n                                \n    float dz = step(d.x, 0.) * step(d.y, d.x) * 1./lengthXZ * p.z +\n               step(0., d.x) * zeta * p.z; \n                                \n    float dy = step(d.y, 0.) * step(d.x, d.y) * sign(p.y) +\n               step(0., d.y) * (d.y * sign(p.y)) * lambda;\n    \n    return vec3(\n    \tdx,\n    \tdy,\n    \tdz \n    );  \n    \n}\n\nfloat distanceToDarkScene(vec3 p, out vec3 gradient)\n{    \n    float animation = 2. * mainSeq.x + 1.;\n    float c = GRID_SIZE;\n    vec3 q = mod(p +vec3(3.5,3.5,3.5) +0.5*c,c)-0.5*c;\n    \n    vec3 b = vec3(1., animation, 1.);\n   \n    float dstS = sdSphere(q, 1.);\n    vec3 grdS = grdSphere(q);\n\n    float dstB = sdBox(q, b);\n    vec3 grdB = grdBox(q, b);\n    \n    float dstC = sdCappedCylinder(q, 0.6, 2.);\n    vec3 grdC = grdCappedCylinder(q, 0.6, 2.);\n    \n    float dstT = sdTorus(q, vec2(1., 0.6));\n    vec3 grdT = grdTorus(q, vec2(1., 0.6));\n    \n    float dist;\n    if (darkSceneSeq.x <1.)\n    { \n        gradient = grdS;\n        dist = mix(dstS, dstB, darkSceneSeq.y);\n    }    \n    else if (darkSceneSeq.x < 2.)\n    {\n        gradient = grdB;\n        dist = mix(dstB, dstC, darkSceneSeq.y);\n    }\n    else if (darkSceneSeq.x < 3.)\n    {\n        gradient = grdC;\n        dist = mix(dstC, dstT, darkSceneSeq.y);\n    }\n    else\n    { \n        gradient = grdT;\n        dist = mix(dstT, dstS, darkSceneSeq.y);\n    }\n       \n    return max(dist, DARK_ANTI_CONVERGENCE);\n}\n\nfloat distanceToScene(vec3 p)\n{   \n    vec2 animation = vec2(6.5 *mainSeq.x + 1., mainSeq.x + 1. );\n\tfloat c = GRID_SIZE;\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n\n    float dstT = min(sdTorus(q, vec2(2.5, 0.5)), sdTorus(q, vec2(0.01, 1.5 + 0.5 *sin(iTime)))) ;\n    float dstC = sdCappedCylinder(q, 2., 1.);\n    float dstS = sdSphere(q, 1.);\n    float dstB1 = sdBox(q, vec3(animation.x, 1., 1.)); \n    float dstB2 = sdBox(q, vec3(1., 1., animation.x)); \n    \n    return mix(\n           mix(dstS, min(dstB1, dstB2), mainSeq.x),\n           mix(dstC, dstT, mainSeq.y),\n    mainSeq.z);\n      \n}\n\nvec3 distortRay (vec3 ray, float darkDist, vec3 gradient)\n{\n    float animation = (darkSceneSeq.z * 0.7) + 0.3;   \n    \n    float radiusShrinker = 1./(DARK_ANTI_CONVERGENCE * DARK_ANTI_CONVERGENCE);\n    \n    float inverseOfSquaresLaw =  1./(darkDist * darkDist * radiusShrinker);\n    \n    #if PUSH\n    \tvec3 g = gradient;\n    #else\n        vec3 g = -gradient;\n    #endif\n    \n    vec3 combined = normalize(VIEW_RAY_WEIGHT * ray * animation + (1.- animation) * g * inverseOfSquaresLaw );\n    return combined;    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n  \n    setAnimations();\n    float speed = iTime*0.35 + 8.;\n    //speed = 0.;\n    \n    // Initiate the camera path spline points. Kind of wasteful not making this global, but I wanted\n    // it self contained... for better or worse. I'm not really sure what the GPU would prefer.\n    setCamPath();\n\t// Camera Setup.\n    vec3 ro = camPath(speed); // Camera position, doubling as the ray origin.\n    vec3 lk = camPath(speed + .5);  // \"Look At\" position.\n    vec3 lp = camPath(speed + .5) + vec3(0, .25, 0);     \n    float FOV = 1.57; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0, -fwd.x));\n    vec3 up = (cross(fwd, rgt));\n    \n    // Unit direction ray.\n    vec3 ray = normalize(fwd + FOV*(uv.x*rgt + uv.y*up));\n\n    vec3 start = ro;\n    \n    vec3 p = start;\n   \t\n    bool backdropHit = false;\n    float travel = 0.;\n\n    uint last_i = 0u;\n    for (uint i = 0u; i < ITERATIONS; i++)\n    {\n        float sceneDist = distanceToScene(p);\n        \n        vec3 darkGradient;\n        float darkDist = distanceToDarkScene(p, darkGradient);\n        \n        if (sceneDist < CONVERGENCE){ last_i = i; break;}\n        \n\t\tfloat marchDist = min(sceneDist, darkDist);\n        \n        travel += marchDist;\n        \n        ray = distortRay(ray, darkDist, darkGradient);\n        p += ray * marchDist;\n        \n        if (i == ITERATIONS - 1u){ backdropHit = true; }\n    }\n    \n    float r = 0.5 + 0.5 * sin((p.x/palRep.x) - paloffset.x);\n    float g = 0.5 + 0.5 * sin((p.x/palRep.y) - paloffset.y);\n    float b = 0.5 + 0.5 * sin((p.x/palRep.z) - paloffset.z);\n   \n    \n    vec3 color = vec3(r, g, b) * min(20./travel, 1.);\n    \n    fragColor = vec4(color - float(last_i) / float(ITERATIONS), 1.0);\n    \n    if (backdropHit)\n    {\n        fragColor = vec4(0.,0. ,0., 1.0);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}