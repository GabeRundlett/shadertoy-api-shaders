{
    "Shader": {
        "info": {
            "date": "1561585092",
            "description": "Learning, learn, lea, l... \nBased on: https://learnopengl.com/PBR/Theory\nSDF: http://iquilezles.org/articles/distfunctions/distfunctions.htm",
            "flags": 0,
            "hasliked": 0,
            "id": "3tSGDt",
            "likes": 3,
            "name": "PBR stuff",
            "published": 3,
            "tags": [
                "pbr"
            ],
            "usePreview": 0,
            "username": "zxxuan1001",
            "viewed": 404
        },
        "renderpass": [
            {
                "code": "#define AA 1\n#define PI 3.1415926\n#define EPSILON 0.0001\nconst int MAX_STEPS = 100;\nconst float MAX_DISTANCE = 60.0;\nconst float AA_SIZE = 2.0;\nconst vec3 FOG_COLOR = vec3(0.9, 0.9, 0.7);\nconst float ROUGHNESS = 0.6;\nconst float METALLIC = 0.8;\n\nfloat plane(vec3 p) \n{\n    return p.y;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec2 intersectSDF(vec2 d1, vec2 d2) \n{\n    return d1.x > d2.x? d1 : d2;\n}\n\nfloat opIntersection( float d1, float d2 ) \n{ \n    return max(d1, d2); \n}\n\nvec2 unionSDF(vec2 d1, vec2 d2) \n{\n    return d1.x < d2.x? d1 : d2;\n}\n\nvec2 subtractionSDF(vec2 d1, vec2 d2) \n{\n    return d1.x > -d2.x? d1 : vec2(-d2.x, d2.y);\n}\n\nfloat smoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5 * ( d2 - d1 ) / k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k * h * (1.0 - h); \n}\n\nfloat smoothSubtraction( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat smoothIntersection( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\nvec3 doTranslate(vec3 p, vec3 offset) \n{\n    return p - offset;\n}\n\nvec3 rotX(vec3 p, float d) \n{\n    mat4 rotM= mat4(1.0, 0.0, 0.0, 0.0, \n                    0.0, cos(d), -sin(d), 0.0, \n                    0.0, sin(d), cos(d), 0.0, \n                    0.0, 0.0, 0.0, 1.0);\n    return vec3(rotM * vec4(p, 1.0));\n}\n\nvec3 rotY(vec3 p, float d) \n{\n    mat4 rotM= mat4(cos(d), 0.0, sin(d), 0.0, \n                    0.0, 1.0, 0.0, 0.0,\n                    -sin(d), 0.0, cos(d), 0.0, \n                    0.0, 0.0, 0.0, 1.0);\n    return vec3(rotM * vec4(p, 1.0));\n}\n\n\nvec3 rotZ(vec3 p, float d) {\n    mat4 rotM= mat4(cos(d), -sin(d), 0.0, 0.0, \n                    sin(d), cos(d), 0.0, 0.0, \n                    0.0, 0.0, 1.0, 0.0, \n                    0.0, 0.0, 0.0, 1.0);\n    return vec3(rotM * vec4(p, 1.0));\n}\n\nfloat displacement(vec3 p) {\n    float t1 = sin(iTime *0.5);\n    float t2 = cos(iTime);\n    float t3 = sin(iTime * 1.0);\n    return sin(2.0*p.x*t1)*sin(2.0*p.y*t2)*sin(2.0*p.z*t3);\n}\n\nfloat displacedTorus(vec3 p, vec2 d) {\n    float rst = sdTorus( p , d );\n    float disp = displacement(p);\n    return rst + disp;\n}\n\nvec2 sceneSDF(vec3 p) \n{\n    vec2 result = vec2(plane(p), -1.0);\n    \n    vec3 p1 = doTranslate(p,vec3(0.0, 2.5 , 0.0));\n    p1 = rotX(p1, -30.0 * PI / 180.0);\n    vec2 result1 = vec2( displacedTorus( p1, vec2(3.0, 1.2) ), 1.0);  \n    result1.x *= 0.4;\n    result = unionSDF(result, result1);\n    return result;\n}\n\nvec2 marching(vec3 ro, vec3 rd) \n{\n    float tmax = MAX_DISTANCE;\n    float t = 0.01;\n    vec2 result = vec2(-1.0);\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * t;\n        vec2 res = sceneSDF(p);\n        if (res.x < EPSILON)\n        {\n            return result;\n        }\n        else if (t > tmax)\n        {\n            result.y = -1.0;\n            result.x = tmax;\n            break;\n        }\n        t += res.x;\n        result.x = t;\n        result.y = res.y;\n    }\n    \n    return result;\n}\n\nfloat calcShadow(in vec3 ro, in vec3 rd) {\n    float mint = 0.1;\n    float t = mint;\n    float res = 1.0;\n    float k = 4.0;\n    for (int i = 0; i < 40; i++)\n    {\n        float h = sceneSDF(ro + rd * t).x;\n        \n\t\tres = min( res, k * h / t );\n        t += clamp( h, 0.02, 0.20 );\n     \n        if ( h < EPSILON ) \n        {\n            res = min(res, 0.0);\n            break;\n        } \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    float h = 0.001;\n    for( float i = 0.0; i < 5.0; i++ )\n    {\n        float d = sceneSDF( pos + h * nor ).x;\n        occ += ( h - d ) * sca;\n        sca *= 0.85;\n        h += 0.45 * i / 5.0;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nconst vec2 OFFSET = vec2(EPSILON, 0.0);\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(p + OFFSET.xyy).x - sceneSDF(p - OFFSET.xyy).x,\n        sceneSDF(p + OFFSET.yxy).x - sceneSDF(p - OFFSET.yxy).x,\n        sceneSDF(p + OFFSET.yyx).x - sceneSDF(p - OFFSET.yyx).x\n    ));\n}\n\nvec3 ground(vec2 uv) \n{\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    uv *= 0.5;\n    float f = mod(floor(uv.x) + floor(uv.y), 2.0) * fract(uv.x) ; //Checkerboard   \n    //f = fract(uv.y); //strip\n    //f = abs(sin(uv.y) * sin(uv.x)); //grid\n    col = mix(col, vec3(242.0,236.0,172.0)/255.0, f);\n    return  col; \n}\n\n//Distribution/concentration\nfloat D_GGX(float dotnh, float roughness) \n{\n    float a = roughness * roughness;\n    float a2 = a * a;\n    float dotnh2 = dotnh * dotnh;\n    float denom =  max(dotnh2 * (a2 - 1.0) + 1.0, EPSILON);\n    return a2 /(PI * denom * denom);\n}\n\nfloat G_SGGX(float dotnv, float roughness)\n{\n    //for direct lighting\n    float r = roughness + 1.0;\n    float k = (r * r) / 8.0; \n    /* for IBL\n    float k = roughness * roughness / 2.0;\n\t*/\n    return dotnv / (dotnv * (1.0 - k) + k);\n}\n//Geometry/shadowing masking\nfloat G_Smith(float dotnv, float dotnl, float roughness)\n{\n    \n    float ggx1 = G_SGGX(dotnv, roughness);\n    float ggx2 = G_SGGX(dotnl, roughness);\n    return ggx1 * ggx2;\n}\n//Fresnel/reflectivity\nvec3 Fs(float dothv, vec3 f0)\n{\n    return max(f0 + (1.0 - f0) * pow((1.0 - dothv), 5.0), 0.0);\n}\n\nvec3 PBL(vec3 ro, vec3 p, float objId) \n{\n    vec3 Lo = vec3(0.0);\n    vec3 lights[4];\n    vec3 lightColor = vec3(300.0, 100.0, 100.0);\n    lights[0] = vec3(0.0, 10.0, -5.0);\n    lights[1] = vec3(-5.0, 15.0, 3.0);\n    lights[2] = vec3(3.0, 20.0, 3.0);\n    lights[3] = vec3(-3.0, 20.0, 3.0);\n    \n    vec3 viewDir = ro - p;\n    vec3 V = normalize(viewDir);\n    vec3 N = getNormal(p);\n    vec3 albedo = vec3(0.2, 0.87, 0.6); //surface color\n    if (objId == -1.0) \n    {//floor     \n        albedo = ground(p.xz); \n    } \n    \n    for (int i = 0; i < 2; i++)\n    {\n        vec3 lightPos = lights[i];\n        \n        vec3 lightDir = lightPos - p;\n        float dist = length(lightDir);\n \n        vec3 L = normalize(lightDir);\n        vec3 H = normalize(viewDir + lightDir);\n        \n        float sd = calcShadow(p, normalize(lightPos));\n        float att = 1.0 / ( dist * dist );\n        vec3 radiance = lightColor * att * sd; \n\n        float dothv = max(dot(H, V), 0.0);\n        float dotnh = max(dot(N, H), 0.0);\n        float dotnv = max(dot(N, V), 0.0);\n        float dotnl = max(dot(N, L), 0.0);\n\t\t\n        //Cook-Torrance specular BRDF term\n        vec3 f0 = vec3(0.04);\n        f0 = mix(f0, albedo, METALLIC);  \n        vec3 F = Fs(dothv, f0);\n        \n        float D = D_GGX(dotnh, ROUGHNESS);\n        float GS = G_Smith(dotnv, dotnl, ROUGHNESS);\n        \n        vec3 nom = D * GS * F;\n        float denom = 4.0 * dotnv * dotnl;\n        vec3 Fct = nom / max(denom, EPSILON); //avoid zero denom\n\n        vec3 Ks = F; //specular\n        vec3 Kd = vec3(1.0) - Ks; //diffuse \n        Kd *= 1.0 - METALLIC;\n        \n        //Lambert\n        vec3 Fl = albedo/PI; \n        \n        //final results\n        Lo += (Kd * Fl + Fct) * radiance * dotnl; \n    }\n    \n    float ao = calcAO(p, N);\n    vec3 ambient = vec3(0.1) * albedo * ao;\n    return ambient + Lo ;\n}\n\n \n\nmat3 getCamera( in vec3 ro, in vec3 ta)\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.0, 1.0, 0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 fog(in vec3 pixColor, in float dist) \n{\n    return mix(pixColor, vec3(0.8), 1.0 - exp(-dist * 0.003));\n}\n\nvec3 background(vec2 uv) \n{\n    vec3 col = mix(vec3(0.5, 0.5, 0.0), vec3(1.0, 0.0, 0.0), pow(0.5, uv.y * 0.2));\n    \n    return col;\n}\n\n\nvec3 render(in vec2 fragCoord) \n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5; // translate to the center of the screen\n    uv.x *= iResolution.x/iResolution.y; // restore aspect ratio\n    \n    \n    vec3 col = vec3(0.0);\n    vec2 mouse = vec2(0.1) + iMouse.xy / iResolution.xy ;\n    mouse -= 0.5;\n    float t = iTime * 0.1;\n    vec3 ro = vec3(12.0 * cos(mouse.x * 2.0 * PI + t),  10.0 + mouse.y * 20.0, 12.0 * sin(mouse.x * 2.0 * PI + t));\n    vec3 ta = vec3(0.0, 2.0, -2.0);\n    mat3 cam = getCamera(ro, ta);\n    vec3 rd = normalize(cam * vec3(uv, 1.2));\n    \n    vec2 h = marching(ro, rd);\n    vec3 p = ro + rd * h.x;\n    if (h.x < MAX_DISTANCE) \n    {\n        if (h.y == 0.0) \n        {\n            col = vec3(0.0);\n        } \n        \n        col += PBL(ro, p, h.y);\n    } else \n    {\n        //background\n        col = background(p.xy); \n    }\n    \n    col = fog(col, h.x); \n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    float count = 0.0;  \n    vec3 col = vec3(0.0);\n    for (float aay = 0.0; aay < AA_SIZE; aay++) \n    {\n        for (float aax = 0.0; aax < AA_SIZE; aax++) \n        {\n            col += render(fragCoord + vec2(aax, aay)/AA_SIZE);\n            count++;\n        }\n    }\n    col /= count;\n      \n \tcol = col / (col + vec3(1.0));\n\tcol = pow(col, vec3(1.0/2.2)); \n    fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}