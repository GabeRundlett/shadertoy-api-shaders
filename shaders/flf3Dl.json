{
    "Shader": {
        "info": {
            "date": "1623073385",
            "description": "Demonstration of rotation under L1 norm and primitives for polar transformations in L1 and L2",
            "flags": 0,
            "hasliked": 0,
            "id": "flf3Dl",
            "likes": 6,
            "name": "L1 Norm Rotation",
            "published": 3,
            "tags": [
                "rotation",
                "norm",
                "l1",
                "l2"
            ],
            "usePreview": 0,
            "username": "paniq",
            "viewed": 350
        },
        "renderpass": [
            {
                "code": "\n// uncomment to transform L2 to L1 space, rotate in L1 and \n// transform back from L1 to L2, to see how polar transformations\n// in L1 are equivalent to their counterpart in L2.\n//#define DEMO_POLAR_EQUIVALENCY\n\n// uncomment to demonstrate rotation in L2\n// uncommenting DEMO_POLAR_EQUIVALENCY will work in the inverse way\n//#define DEMO_L2_NORM_ROTATION\n\nconst float L1tau = 8.0;\nconst float L1pi = 4.0;\n\n// sign without zero\nfloat nzsign(float x) {\n    return (x < 0.0)?-1.0:1.0;\n}\n\nfloat L1cos(float x) {\n    return abs(mod(x, 8.0) - 4.0) / 2.0 - 1.0;\n}\n\nfloat L1sin(float x) {\n    return L1cos(x - 2.0);\n}\n\nfloat L1radians(float x) {\n    return x / 45.0;\n}\n\nfloat L1degrees(float x) {\n    return x * 45.0;\n}\n         \nvec2 L1polar(vec2 p) {\n    float r = abs(p.x) + abs(p.y);\n    return (r == 0.0)?vec2(0.0):vec2(2.0 * nzsign(p.y) * (1.0 - p.x / r), r);\n}\n\nvec2 L1cartesian(vec2 p) {\n    float a = p.x;\n    float r = p.y;\n    a = mod(a + 4.0, 8.0) - 4.0;\n    float cos_x = 1.0 - abs(a) / 2.0;\n    return r * vec2(cos_x, sign(a)*(1.0 - abs(cos_x)));\n}\n\nvec2 L1rotate (vec2 p, float q) {\n    p = L1polar(p);\n    return L1cartesian(vec2(p.x + q, p.y));\n}\n\nconst float L2tau = 6.28318530718;\nconst float L2pi = 3.14159265359;\n\nvec2 L2polar(vec2 p) {\n    float r = length(p);\n    return vec2(atan(p.y, p.x), r);\n}\n\nvec2 L2cartesian(vec2 p) {\n    float a = p.x;\n    float r = p.y;\n    return r * vec2(cos(a), sin(a));\n}\n\nvec2 L2rotate (vec2 p, float q) {\n#if 0 // logical\n    p = L2polar(p);\n    return L2cartesian(vec2(p.x + q, p.y));\n#else // fast\n    float c = cos(q);\n    float s = sin(q);\n    return vec2(c*p.x - s*p.y, c*p.y + s*p.x);\n#endif\n}\n\n// convert polar coordinates from L1 to L2 \nvec2 L1toL2(vec2 p) {\n    return vec2(p.x * L2tau / L1tau, p.y);\n}\n\n// convert polar coordinates from L2 to L1\nvec2 L2toL1(vec2 p) {\n    return vec2(p.x * L1tau / L2tau, p.y);\n}\n\nvec3 hue(float hue) {\n    return clamp( \n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, \n        0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = (fragCoord.xy / iResolution.xy)*2.0-1.0;\t\n\tp.x *= iResolution.x/iResolution.y;\n\n#ifndef DEMO_L2_NORM_ROTATION\n\n#ifdef DEMO_POLAR_EQUIVALENCY\n    p = L1cartesian(L2toL1(L2polar(p)));\n#endif\n\n    p = L1rotate(p, -iTime*0.5);\n\n#ifdef DEMO_POLAR_EQUIVALENCY\n    p = L2cartesian(L1toL2(L1polar(p)));\n#endif\n\n#else\n\n#ifdef DEMO_POLAR_EQUIVALENCY\n    p = L2cartesian(L1toL2(L1polar(p)));\n#endif\n\n    // the two norms have different arc lengths, so we need\n    // to adjust speed for equivalency\n    p = L2rotate(p, -iTime*0.5 * L2tau / L1tau);\n\n#ifdef DEMO_POLAR_EQUIVALENCY\n    p = L1cartesian(L2toL1(L2polar(p)));\n#endif\n\n#endif\n\n    vec2 o = L1polar(p);\n    vec3 color = texture(iChannel0, p).rrr * (hue(o.r/L1tau) * 0.5 + 0.5) * (0.7 + 0.3*clamp(L1cos(o.g * L1tau * 10.0)*10.0*0.5+0.5,0.0,1.0));\n\n\tfragColor = vec4(color, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}