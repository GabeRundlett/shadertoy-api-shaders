{
    "Shader": {
        "info": {
            "date": "1405849602",
            "description": "It's my cellphone... but can't add more buttons on it because the shader starts to take too long to compile.",
            "flags": 0,
            "hasliked": 0,
            "id": "MdfSRs",
            "likes": 18,
            "name": "Cellphone",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "EvilRyu",
            "viewed": 1269
        },
        "renderpass": [
            {
                "code": "\n// It's my cellphone, created by EvilRyu 2014\n\n#define PI 3.14159265\n#define screen_h 1.6\n#define screen_w 0.9\n#define DIFFUSE 0\n#define REFL 1\n#define EMI 2\n#define MTL_NUM 6\n\n\nfloat stime, ctime;\n\nstruct material_typ{\n  vec3 color;\n  float r0;\n  float smoothness;\n  int type;\n};\n\nmaterial_typ mtl;\n\n\nfloat roundbox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\nfloat sphere(vec3 p, float r) {\n    return length(p)-r;\n}\nfloat plane(vec3 p, float y) {\n    return length(vec3(p.x, y, p.z) - p);\n}\n\nfloat expstep(float x, float k, float n)\n{\n    return exp(-k*pow(x,n));\n}\n\nfloat cylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec2 cellphonebody( vec3 p, vec3 b, float r )\n{\n    float screen = 0.0;\n    float m = 0.0;\n    vec3 tmp = vec3(-1.75, 0.15, -0.0);\n    \n    if(p.y < 0.0) {\n      // curve of backside\n      b =  vec3(b.x*1.0/(0.1*p.z*p.z+1.0), \n          b.y*1.0*cos(p.z)*1.0*cos(p.x*0.1)-pow(p.x*p.z*p.x*p.z,2.0)*0.0071,  \n          b.z);\n    \n    }else {\n        // screen\n        if(p.x > -screen_h && p.x < screen_h && p.z > -screen_w && p.z < screen_w) {\n            screen = 1.0;\n            b.y -= 0.02;\n        }\n    \n        // slop at both sides\n        float sl1 = -p.z*p.z*0.1 + 1.75;\n        float sl2 = sl1 + 0.25;\n        float by = b.y;\n        if(p.x > sl1) {\n            b.y = by * expstep((p.x - sl1)/(sl2 - sl1), 2.0, 4.0);\n        }\n      \tsl1 += 0.15;\n      \tsl2 = sl1 + 0.25;\n        if(p.x < -sl1) {\n          b.y = b.y * expstep((-p.x - sl1)/(sl2 - sl1), 1.0, 1.5);\n      \t}\n\t\t\n\t\t\n\t\tif(abs(p.x-tmp.x) < 0.03 && abs(p.z-tmp.z) < 0.08){\n\t\t\tb.y -= 0.01;\n\t\t\tscreen = 1.0;\n\t\t}\n    \n\t\ttmp = vec3(-1.75, 0.15, -0.3);\n      if(dot(p - tmp, p - tmp) < 0.002) {\n        b.y -= 0.02;\n        screen = 1.0;\n      }\n\t\ttmp.z -= 0.15;\n\t\tif(dot(p - tmp, p - tmp) < 0.006) {\n\t\t\tb.y -= 0.02;\n\t\t\tscreen = 1.0;\n\t\t}\n\t\ttmp.z -= 0.15;\n\t\tif(dot(p - tmp, p - tmp) < 0.002) {\n\t\t\tb.y -= 0.02;\n\t\t\tscreen = 1.0;\n\t\t}\n\t\ttmp.z -= 0.15;\n\t\tif(dot(p - tmp, p - tmp) < 0.002) {\n\t\t\tb.y -= 0.02;\n\t\t\tscreen = 1.0;\n\t\t}\n\t\ttmp = vec3(1.85, 0.15, 0.6);\n\t\tif(dot(p - tmp, p - tmp) < 0.001) {\n\t\t\tb.y -= 0.02;\n\t\t\tscreen = 1.0;\n\t\t}\n\t\ttmp = vec3(0.7, 0.12, 1.12);\n\t\tif(dot(p - tmp, p - tmp) < 0.001) {\n\t\t\tb.y -= 0.02;\n\t\t\tscreen = 1.0;\n\t\t}\n    \n       b = vec3(b.x*1.0/(0.1*p.z*p.z+1.0), b.y, b.z);\n    }\n    float body = (length(max(abs(p)-b,0.0))-r) * 0.5;\n    \n    float d = 1e10;\n  \n     // buttons\n    //float d8 = cylinder(vec3(p.x + 0.7, p.z + 1.12, p.y - 0.03), vec2(0.03, 0.1));\n\t//float d6 = cylinder(vec3(p.x + 1.0, p.z + 0.95, p.y - 0.03), vec2(0.07, 0.1));\n    //float d7 = cylinder(vec3(p.x - 1.0, p.z + 0.95, p.y - 0.03), vec2(0.07, 0.1));\n    \n    // if(d > d8) {d = d8; m = 3.;}\n    if(-d < body){d = body; m = 1.+screen;} else {d = -d; m = 1.0;}\n    \n    //if(d > d6) {d = d6; m = 1.;}\n    //if(d > d7) {d = d7; m = 1.;}\n    return vec2(d,m);\n}\n\nmaterial_typ getmtl(float m) {\n\tmaterial_typ mtl;\n  \tmtl.type = DIFFUSE;\n  \tmtl.r0 = 0.1;\n  \tmtl.smoothness = 0.3;\n  \tmtl.color = vec3(1.0);\n  \tif(m < 2.0) {\n    \tmtl.color = vec3(1.0); // body\n    \tmtl.type = DIFFUSE;\n    \tmtl.r0 = 0.21;\n    \tmtl.smoothness = 0.6;\n  \t} else if( m < 3.0) {\n   \t \tmtl.color = vec3(0.05);  // screen\n    \tmtl.type = REFL;\n    \tmtl.r0 = 0.01;\n    \tmtl.smoothness = 1.0;\n  \t} else if(m < 4.0) {   \n\t\tmtl.color = vec3(0.0, 2.0, 0.0);  // power\n\t\tmtl.type = EMI;\n\t\tmtl.r0 = 0.2;\n\t\tmtl.smoothness = 0.1;\n\t}\n\treturn mtl;\n}\n\n vec2 f(vec3 p){ \n   //ry(p, stime);\n    float m = 0.;\n    float d = 1e10;\n    vec2 dc = cellphonebody(p, vec3(2.0, 0.15, 1.0), 0.03);\n    float d0 = plane(vec3(p.x, p.y + 0.23, p.z), 0.0);  \n   \n\n    if(d > dc.x) {d = dc.x; m = dc.y;}\n    if(d > d0) {d = d0; m = 4.;}\n        \n    return vec2(d, m); \n } \n\n\n float softshadow(vec3 ro, vec3 rd, float k ){ \n     float akuma=1.0,h=0.0; \n\t float t = 0.01;\n     for(int i=0; i < 70; ++i){ \n         h=f(ro+rd*t).x; \n         if(h<0.001)return 0.02; \n         akuma=min(akuma, k*max(h, 0.0)/t); \n     t+=clamp(h,0.01,2.0); \n     } \n     return akuma; \n } \n\n vec3 nor(vec3 p){ \n    vec3 e=vec3(0.001,0.0,0.0); \n    return normalize(vec3(f(p+e.xyy).x-f(p-e.xyy).x, \n                      f(p+e.yxy).x-f(p-e.yxy).x, \n                          f(p+e.yyx).x-f(p-e.yyx).x)); \n } \n\nvec2 intersect( in vec3 ro, in vec3 rd )\n{\n  \tfloat t = 0.0;\n    vec2 res = vec2(-1.0);\n    vec2 h = vec2(1.0);\n    for( int i=0; i<64; i++ )\n    {\n      if( h.x<0.0005 || t>20.0 ) continue;\n        h = f(ro + rd*t);\n        res = vec2(t,h.y);\n        t += h.x;\n    }\n    if( t>20.0 ) res=vec2(-1.0);\n    return res;\n}\n\n\nfloat phong(vec3 light, vec3 incident, vec3 normal, float smoothness) {\n  \tfloat specpower = exp2(2.0 + 2.0 * smoothness);\n    return max(0.0, pow(clamp(dot(light, reflect(incident, normal)), 0.0, 1.0), specpower)); \n}\n\n\n\nvec3 lighting(vec3 n, vec3 rd, vec3 p, material_typ mtl) {\n  \tvec3 l0_dir = vec3(1.0, 1.0, 0.5);\n    vec3 l0_col = vec3(1.1,1.0,0.9);\n    vec3 ambi_col = vec3(1.0, 1.0, 1.0); \n    vec3 diffuse, specular, lin;\n  \n    float shadow = softshadow(p, l0_dir, 10.0 );\n  \n  \tfloat diff = max(0.0, dot(n, l0_dir));\n  \tfloat spec = phong(l0_dir, rd, n, mtl.smoothness);\n  \tfloat ambi = 0.6 + 0.4 * max(0.0, dot(n, vec3(0.0, 1.0, 0.0))); \n    float back = max(0.3 + 0.7 * dot(vec3(-l0_dir.x, -1.0, -l0_dir.z), n), 0.0); \n  \n     \n    diffuse = 3.8 * diff * shadow * l0_col;\n  \tdiffuse += 0.6 * ambi * ambi_col;\n  \tdiffuse += 0.5 * back * l0_col;\n  \tdiffuse *= mtl.color;\n  \tspecular = 3.0 * spec * l0_col;\n\n  \tlin = diffuse + specular;\n     \n    float be = 0.05;// black edge for the screen\n    if(p.y>0.0 && p.x>-screen_h+be && p.x<screen_h-be && p.z>-screen_w+be && p.z<screen_w-be)\n        lin += 5.*texture(iChannel0, vec2((p.x+screen_h-be) / (2.0*(screen_h+be)),\n                              1.0-(p.z+screen_w-be) / (2.0*(screen_w+be)))).xyz;\n\n  return lin;\n\n}\nvec3 banzai(vec3 ro, vec3 rd, inout float t) {\n  \n    vec3 col;\n    vec3 p=ro; \n   \n    vec2 res = intersect(ro, rd);\n    t = res.x;\n   \n    if(t > -0.5){\n        p = ro + t * rd;\n        material_typ mtl = getmtl(res.y);\n        vec3 n=nor(p); \n    \n      if(mtl.type == EMI) {\n          col = vec3(0.0,1.0,0.0);\n      } else {\n       \n          col = lighting(n, rd, p, mtl);\n          vec3 ground = texture(iChannel1, p.xz).xxx;\n            if(int(res.y+0.1) == 4)col *= ground;\n            col *= 0.2;\n      }\n    \n    } \n  return col;\n}\n\n void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n { \n    vec2 q=fragCoord.xy/iResolution.xy; \n    vec2 uv = -1.0 + 2.0*q; \n    uv.x*=iResolution.x/iResolution.y; \n    // camera\n    stime=sin(iTime*0.2); \n    ctime=cos(iTime*0.2); \n\n    vec3 ta=vec3(0.0,0.0,0.0); \n    vec3 ro=vec3(2.0*stime,2.5, 4.5 + 0.5*ctime); \n\n    vec3 cf = normalize(ta-ro); \n    vec3 cs = normalize(cross(cf,vec3(0.0,1.0,0.0))); \n    vec3 cu = normalize(cross(cs,cf)); \n    vec3 rd = normalize(uv.x*cs + uv.y*cu + 2.8*cf);  // transform from view to world\n\n    vec3 bg = exp(uv.y-2.0)*vec3(0.1, 0.1, 0.1);\n    vec3 col;\n    float t;\n   \n    col = banzai(ro, rd, t);\n    if(t <= 0.0) col = bg;\n    col=mix(col,bg, 1.0-exp(-0.01*t*t)); \n    \n    // post\n    col=pow(clamp(col,0.0,1.0),vec3(0.45)); \n    col=mix(col, vec3(dot(col, vec3(0.33))), -0.5);  // satuation\n    col*=0.5+0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n    fragColor=vec4(col.x,col.y,col.z,1.0); \n }",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 11,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}