{
    "Shader": {
        "info": {
            "date": "1555557240",
            "description": "My my, will you look at that sexy list of tags.",
            "flags": 0,
            "hasliked": 0,
            "id": "3tX3R8",
            "likes": 77,
            "name": "Selmi Triangle",
            "published": 3,
            "tags": [
                "fractal",
                "retro",
                "illusion",
                "escher",
                "recursive",
                "sierpinski",
                "penrose",
                "impossible",
                "reutersvard"
            ],
            "usePreview": 0,
            "username": "dracusa",
            "viewed": 3902
        },
        "renderpass": [
            {
                "code": "/*\nFractal Penrose triangle aka Selmi triangle. I came across it when John Baez\nshared it a couple of months ago, and I wanted to explore the concept with a\nshader. Representations of it were first posted online by Nidhal Selmi and \nAkiyoshi Kitaoka in 2009-2010.\n\nRegarding implementation, I didn't find any super elegant or efficient way of\ngenerating it, and ended up manually placing overlapping isometric faces.\nEverything is 2D. I'm basically treating the Sierpinski triangle as a tiling,\nwith the Penrose triangle being the prototile. Somewhat experimentally,\neverything is generated in HSV color space and converted to RGB at the end,\nwhich makes for easy color management.\n\nLinks:\nhttp://math.ucr.edu/home/baez/diary/march_2019.html\nhttps://www.deviantart.com/nydhalo/art/Selmi-Triangle-136342456\nhttp://www.psy.ritsumei.ac.jp/~akitaoka/fukano2e.html\n*/\n\n\n// Sets of coordinates used for the current and adjacent tiles\nstruct TileSpace {\n\tvec2 p; // current point in tile coordinates\n\tvec2 to; // tile origin in global coordinates\n};\n\n// Existence of neighboring tiles (left/right/bottom)\nstruct Neighbors {\n\tbool L;\n\tbool BL;\n\tbool BR;\n};\n\n// Number of iterations being displayed\nint level;\n// Smoothed number of iterations and related values\nfloat smoothLevel, tilesize, lineLightness;\n// Colors in HSV space\nconst vec3 lightHSV = vec3(0., 0., 0.95);\nconst vec3 mediumHSV = vec3(0., 0., 0.4);\nconst vec3 darkHSV = vec3(0., 0., 0.14);\nconst vec3 lineHSV = vec3(0., 0., 0.);\nvec3 bgHSV;\n\n// These functions angle space for the placement of isometric cube faces\nvec2 isoM(vec2 p) { return vec2(p.y, 0.5*p.y - p.x); }\nvec2 isoL(vec2 p) { return vec2(p.x+p.y*0.5, p.y); }\nvec2 isoR(vec2 p) { return vec2(p.x+p.y*0.5, 0.5*p.y - p.x); }\n\n// These functions repeat space to draw cheap rows of faces\nfloat range(float x, float xmin, float xmax) {\n\treturn max(min(fract(x), x-xmin), x-xmax);\n}\nvec2 xRange(vec2 p, float xmin, float xmax) {\n\tp.x = range(p.x, xmin, xmax);\n\treturn p;\n}\nvec2 yRange(vec2 p, float ymin, float ymax) {\n\tp.y = range(p.y, ymin, ymax);\n\treturn p;\n}\n\n// Draw a unit square onto ret\nvoid square(inout vec3 ret, vec2 p, vec3 col, float aaSize) {\n\tp = abs(p-0.5);\n\tfloat sqgrad = max(p.x, p.y)*2.;\n\tvec3 lc = mix(lineHSV, col, lineLightness);\n\tret = mix (ret, lc, 1.-smoothstep(1., 1.+aaSize, sqgrad));\n\tret = mix(col, ret, smoothstep(1.-aaSize, 1., sqgrad));\n}\n\n/*\nConstruct a Penrose triangle in 2D by manually placing a bunch of angled\nsquares. Nothing really magic.\n*/\nvoid drawPenrose(inout vec3 ret, vec2 p, float aaSize) {\n\t// L to T\n\tsquare(ret, xRange(isoR(p)+vec2(0., 1.), 1., 2.), lightHSV, aaSize);\n\t// R to L\n\tsquare(ret, yRange(isoM(p), -3., 0.), mediumHSV, aaSize);\n\tsquare(ret, xRange(isoL(p)+vec2(0., 1.), -1., 2.), darkHSV, aaSize);\n\t// R to T\n\tsquare(ret, yRange(isoL(p)-vec2(3., 0.), -1., 2.), darkHSV, aaSize);\n\tsquare(ret, yRange(isoR(p)-vec2(4., 0.), -5., -1.), lightHSV, aaSize);\n\t// L to T cover\n\tsquare(ret, isoR(p)+vec2(-3., 1.), lightHSV, aaSize);\n\tsquare(ret, xRange(isoM(p), 1., 4.), mediumHSV, aaSize);\n}\n\n/*\nConstruct a Penrose triangle and connect it to its neighbors by adding some more\nangled squares.\n*/\nvoid drawSelmi(inout vec3 ret, TileSpace t, Neighbors n, float aaSize) {\n\tvec2 p = t.p*4.-vec2(2., 0.);\n\tp *= vec2(0.5, 0.578);\n\tp += vec2(3., 1.3);\n\tif (n.BL) {\n\t\tsquare(ret, yRange(isoR(p)+vec2(0., 0.), -3., -2.), lightHSV, aaSize);\n\t}\n\tif (n.BR) {\n\t\tsquare(ret, isoM(p)+vec2(2., 4.), mediumHSV, aaSize);\n\t}\n\tdrawPenrose(ret, p, aaSize);\n\tif (n.L) {\n\t\tsquare(ret, isoL(p)+vec2(1., 0.), darkHSV, aaSize);\n\t\tsquare(ret, isoL(p)+vec2(2., 1.), darkHSV, aaSize);\n\t\tsquare(ret, isoR(p), lightHSV, aaSize);\n\t}\n\tif (n.BL) {\n\t\tsquare(ret, isoR(p)+vec2(1., 1.), lightHSV, aaSize);\n\t\tsquare(ret, isoM(p)+vec2(1., 0.), mediumHSV, aaSize);\n\t}\n\tif (n.BR) {\n\t\tsquare(ret, isoR(p)+vec2(-3., 5.), lightHSV, aaSize);\n\t\tsquare(ret, isoR(p)-vec2(4., -6.), lightHSV, aaSize);\n\t\tsquare(ret, isoM(p)+vec2(1., 4.), mediumHSV, aaSize);\n\t}\n}\n\n/*\nConvert coordinates to \"Sierpinski tile\" coordinates. I originally rolled my own\nSierpinski function, but then I saw iq's smugly superior version so I\nrage-deleted all my code and based my new version on his:\nhttps://www.shadertoy.com/view/Md2GzR\nwhich itself was probably inspired by Syntopia's Sierpinski code:\nhttp://blog.hvidtfeldts.net/index.php/2011/08/distance-estimated-3d-fractals-iii-folding-space/\n*/\nconst vec2 va = vec2(0.0, 1.73-0.85);\nconst vec2 vb = vec2(1.0, 0.00-0.85);\nconst vec2 vc = vec2(-1.0, 0.00-0.85);\nfloat length2(vec2 p) { return dot(p,p); }\nTileSpace sierpSpace(vec2 pin) {\n\tfloat a = 0.0;\n\tvec2 p = pin;\n\tvec2 c;\n\tfloat dist, d, t;\n\tfor (int i = 0; i<7; i++) {\n\t\tif (i>=level) continue;\n\t\td = length2(p-va);                 c = va; dist=d; t=0.0;\n        d = length2(p-vb); if (d < dist) { c = vb; dist=d; t=1.0; }\n        d = length2(p-vc); if (d < dist) { c = vc; dist=d; t=2.0; }\n\t\tp = c + 2.0*(p - c);\n\t\ta = t + a*3.0;\n\t}\n\tvec2 to = (pin - p*tilesize);\n\treturn TileSpace(p, to);\n}\n\n/*\nI'm resorting to an utterly barbaric way of determining if the tile has\nneighbors to connect to: re-running down the entire fractal for each neighboring\nside to check. There's got to be a way of getting all of this in a single pass,\nbut I couldn't figure it out. Oh well, at least I reduced it to 3 taps instead\nof having to check all 6 possible neighbors, by offsetting the tile contents so\nthat it's only affected by the bottom-left connections.\n*/\n#define EPSILON 0.001\nbool approx(vec2 a, vec2 b) { return all(lessThan(abs(a-b), vec2(EPSILON))); }\nNeighbors getNeighbors(vec2 p, TileSpace t) {\n\tNeighbors n;\n\tfloat eps = tilesize*0.002;\n    // check if the tile origin is equal to the tile origin of neighboring points\n\tn.L = !approx(t.to, sierpSpace(t.to-tilesize*vec2(1.1, 0.)).to);\n\tn.BL = !approx(t.to, sierpSpace(t.to-tilesize*vec2(0.92, 0.92)).to);\n\tn.BR = !approx(t.to, sierpSpace(t.to-tilesize*vec2(-0.92, 0.92)).to);\n\treturn n;\n}\n\n/*\nEquilateral triangle distance by iq, used for the big blurry shadow.\n(Todo: project it onto the plane because right now it looks wrong.)\nAlso used for the transition effect between levels of iteration.\n*/\nfloat sdEquilateralTriangle(vec2 p)\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\n// Smooth HSV: https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb_smooth(vec3 c)\n{\n\treturn c.z * (1.-c.y*smoothstep(2.,1., abs(mod(c.x*6.+vec3(0,4,2), 6.) -3.)));\n}\n\n// Convert to ground-plane coordinates\nvec2 groundP(vec2 p)\n{\n\tp.y += 0.184;\n\tp.x = 2.*(p.x/8.)/(.5-p.y);\n\tp.y = p.y / (p.y-.5);\n\tp.y += smoothLevel*0.46;\n\tp *= 7.;\n\treturn p;\n}\n\n/*\nReturn a drawable grid on the ground-plane.\nTodo: get the AA size with the derivative of groundP instead of this shitty\nnumerical approximation.\n*/\nfloat ground(vec2 pin)\n{\n\tpin.x = abs(pin.x);\n\tvec2 p = groundP(pin);\n\tvec2 p2 = groundP(pin-vec2(1./iResolution));\n\tfloat aax = min(0.5, abs(p.x-p2.x)*1.5);\n\tfloat aay = min(0.5, abs(p.y-p2.y)*1.5);\n\tfloat ret = smoothstep(0.5-aax, 0.5, abs(fract(p.x)-0.5));\n\tret = max(ret, smoothstep(0.5-aay, 0.5, abs(fract(p.y)-0.5)));\n\treturn ret*(0.5-aay)*2.;\n}\n\n//  Dave_Hoskins hash, used for film grain effect\nfloat hash13(vec3 p3)\n{\n\tp3 = fract(p3 * .1031);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 p = uv-0.5;\n\tp.x *= iResolution.x/iResolution.y;\n\t\n\t// Slowly increase and decrease the fractal's iteration count\n\tsmoothLevel = 0.7+(4.5-0.7)*(0.5-0.5*cos(iTime*0.2));\n\tfloat trans = sdEquilateralTriangle(-0.2*(p-vec2(0., 0.33)))+0.66;\n\tlevel = int(smoothLevel-trans);\n\ttilesize = 1./pow(2.,float(level));\n\tlineLightness = smoothLevel*0.18;\n\tfloat zoom = pow(2.,smoothLevel)*1.09*tilesize;\n\tfloat aaSize = 22.*zoom*(1.0/length(iResolution))/tilesize;\n\n\t// Prepare some colors and background grid on plane\n\tbgHSV = vec3(float(level)*0.16+0.5, 0.6, 1.);\n\tvec3 bg2 = vec3(bgHSV.x+0.25, 0., 1.);\n\tbgHSV = mix(bgHSV, bg2, sqrt(uv.y));\n\tbgHSV.z *= 1.-ground(p)*0.75;\n\tvec3 ret = bgHSV;\n\n\t// Prepare coordinates for the object\n\tp = (p-vec2(0., 0.33-0.1/smoothLevel))*zoom+vec2(0.5, 0.94);\n\tTileSpace t = sierpSpace(p*2.-1.);\n\tNeighbors n = getNeighbors(p, t);\n\n\t// Shadow\n\tvec2 sp = (p-vec2(0.35, 0.2));\n\tsp.y *= 2.;\n\tsp.x += sp.y*0.3;\n\tfloat s = sdEquilateralTriangle(sp * 2.);\n\tfloat samp = 1.5/(max(sp.y+2.,0.)+1.);\n\tsamp *= 2.2-1.2*smoothstep(-1., 4., float(level));\n\tret.z *= 1. - samp/(max(s, 0.)+1.);\n\t\n\t// Draw the object\n\tdrawSelmi(ret, t, n, aaSize);\n\n\t// Draw white transition triangle\n\tvec3 c2 = vec3(bgHSV.x, 0., 0.9);\n\tret = mix(c2, ret, clamp(abs(fract(smoothLevel-trans+0.49)-0.5)*400.-4., 0., 1.));\n\n\t// Film grain effect\n\tfloat hash = hash13(vec3(fragCoord, iTime*1500.+50.));\n\tret.z *= 1.-hash*0.13*(1.-ret.y);\n\tret.x += hash*0.13*ret.y;\n\n\t// Convert to RGB\n    fragColor = vec4(hsv2rgb_smooth(ret), 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}