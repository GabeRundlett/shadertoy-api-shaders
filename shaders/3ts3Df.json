{
    "Shader": {
        "info": {
            "date": "1557939953",
            "description": "having fun with\nhttps://www.shadertoy.com/view/wlf3WX\nadded quaternion code",
            "flags": 0,
            "hasliked": 0,
            "id": "3ts3Df",
            "likes": 17,
            "name": "quaternion Headace",
            "published": 3,
            "tags": [
                "csg",
                "quaternion",
                "headace"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 719
        },
        "renderpass": [
            {
                "code": "//self: https://www.shadertoy.com/view/3ts3Df\n//parent +sorting + quaternions\n\n/*\nparent: https://www.shadertoy.com/view/wlf3WX\nHead\n----\n\nThis was painstakingly hand modeled by 'tracing' a polygonal model\nexported from Daz 3D.\n\nThe initial approach is to smooth blend small ellipses with a large\nblend radius, a technique I took from Ink Drawing by lnae\n(https://www.shadertoy.com/view/MltcDB)\n\nThe brow and jawline are formed by blending planes and spheres.\nThe nose is, of course, a few capsules.\nThe ears are various extruded and warped 2D layers, they were by\nfar the hardest part.\n\nI encourage you to comment parts out and see how it all adds up.\n\nUses a few primitives and tools from HG_SDF and IQ.\n\nApologies for the boring shading, you can see some more interesting\napplications in the GIF and 4K that this was created for:\n\n* Fractal Polycephaly https://media.giphy.com/media/J2xwceb3Kk50fGXWdj/giphy.gif\n* ᴇ s ᴄ ʜ ᴇ ʀ ᴡ ᴀ ᴠ ᴇ https://www.shadertoy.com/view/wtf3RM\n\n\nLicense: Creative Commons Attribution-NonCommercial\nhttps://creativecommons.org/licenses/by-nc/4.0/\n\n*/\n\n#define PI acos(-1.)\n\nvec2 pR(vec2 p, float a) {\n   return cos(a)*p + sin(a)*vec2(p.y, -p.x);}\n\nvec2 pRi(vec2 p, float a) {\n    pR(p, a);\n    return p;\n}\n\n#define saturate(x) clamp(x, 0., 1.)\n\nfloat vmax(vec2 v) {\n    return max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat vmin(vec3 v) {\n    return min(min(v.x, v.y), v.z);\n}\n\nfloat vmin(vec2 v) {\n    return min(v.x, v.y);\n}\n\nfloat fBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fCorner2(vec2 p) {\n    return length(max(p, vec2(0))) + vmax(min(p, vec2(0)));\n}\n\nfloat fDisc(vec3 p, float r) {\n    float l = length(p.xz) - r;\n    return l < 0. ? abs(p.y) : length(vec2(p.y, l));\n}\n\n\nfloat fHalfCapsule(vec3 p, float r) {\n    return mix(length(p.xz) - r, length(p) - r, step(0., p.y));\n}\n\n\n// IQ https://www.shadertoy.com/view/Xds3zN\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat smin2(float a, float b, float r) {\n    vec2 u = max(vec2(r - a,r - b), vec2(0));\n    return max(r, min (a, b)) - length(u);\n}\n\nfloat smax2(float a, float b, float r) {\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\n    return min(-r, max (a, b)) + length(u);\n}\n\nfloat smin(float a, float b, float k){\n    float f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\nfloat smin3(float a, float b, float k){\n    return min(\n        smin(a, b, k),\n        smin2(a, b, k)\n    );\n}\n\nfloat smax3(float a, float b, float k){\n    return max(\n        smax(a, b, k),\n        smax2(a, b, k)\n    );\n}\n\n\nfloat ellip(vec3 p, vec3 s) {\n    float r = vmin(s);\n    p *= r / s;\n    return length(p) - r;\n}\n\nfloat ellip(vec2 p, vec2 s) {\n    float r = vmin(s);\n    p *= r / s;\n    return length(p) - r;\n}\n\n\nfloat brow(vec3 p,vec3 pp,float d){\n        p = pp;\n    p += vec3(0,-.0,-.18);\n    vec3 bp = p;\n    float brow = fHalfCapsule(p * vec3(.65,1,.9), .27);\n    brow = length(p) - .36;\n    p.x -= .37;\n    brow = smax(brow, dot(p, normalize(vec3(1,.2,-.2))), .2);\n    p = bp;\n    brow = smax(brow, dot(p, normalize(vec3(0,.6,1))) - .43, .25);\n    p = bp;\n    p.yz=pR(p.yz, -.5);\n    float peak = -p.y - .165;\n    peak += smoothstep(.0, .2, p.x) * .01;\n    peak -= smoothstep(.12, .29, p.x) * .025;\n    brow = smax(brow, peak, .07);\n    p = bp;\n    p.yz=pR(p.yz, .5);\n    brow = smax(brow, -p.y - .06, .15);\n    d= smin(d, brow, .06);\n ;return d;}\n\nfloat nose(vec3 p,vec3 pp,float d){\n    p = pp;\n    p += vec3(0,.03,-.45);\n    p.yz=pR(p.yz, 3.);\n    d = smin(d, sdRoundCone(p, .008, .05, .18), .1);\n\n    p = pp;\n    p += vec3(0,.06,-.47);\n    p.yz=pR(p.yz, 2.77);\n    d = smin(d, sdRoundCone(p, .005, .04, .225), .05)\n ;return d;}\n\nfloat jaw(vec3 p,vec3 pp,vec3 pa,float d\n){p = pp\n ;vec3 jo = vec3(-.25,.4,-.07)\n ;p = pp + jo\n ;float jaw = dot(p, normalize(vec3(1,-.2,-.05))) - .069\n ;jaw = smax(jaw, dot(p, normalize(vec3(.5,-.25,.35))) - .13, .12)\n ;jaw = smax(jaw, dot(p, normalize(vec3(-.0,-1.,-.8))) - .12, .15)\n ;jaw = smax(jaw, dot(p, normalize(vec3(.98,-1.,.15))) - .13, .08)\n ;jaw = smax(jaw, dot(p, normalize(vec3(.6,-.2,-.45))) - .19, .15)\n ;jaw = smax(jaw, dot(p, normalize(vec3(.5,.1,-.5))) - .26, .15)\n ;jaw = smax(jaw, dot(p, normalize(vec3(1,.2,-.3))) - .22, .15)\n ;p = pp\n ;p += vec3(0,.63,-.2)\n ;p.yz=pR(p.yz, .15)\n ;float cr = .5\n ;jaw = smax(jaw, length(p.xy - vec2(0,cr)) - cr, .05)\n ;p = pp + jo\n ;jaw = smax(jaw, dot(p, normalize(vec3(0,-.4,1))) - .35, .1)\n ;jaw = smax(jaw, dot(p, normalize(vec3(0,1.5,2))) - .3, .2)\n ;jaw = max(jaw, length(pp + vec3(0,.6,-.3)) - .7)\n ;p = pa\n ;p += vec3(.2,.5,-.1)\n ;float jb = length(p)\n ;jb = smoothstep(.0, .4, jb)\n ;float js = mix(0., -.005, jb)\n ;jb = mix(.01, .04, jb)\n ;d=smin(d, jaw - js, jb);\n ;return d;}\n\nfloat cheek(vec3 p,vec3 pp,vec3 pa,float d){\n    p = pp;\n    p += vec3(-.2,.2,-.28);\n    p.xz=pR(p.xz, .5);\n    p.yz=pR(p.yz, .4);\n    float ch = ellip(p, vec3(.1,.1,.12)*1.05);\n    d = smin(d, ch, .1);\n    p = pp;\n    p += vec3(-.26,.02,-.1);\n    p.xz=pR(p.xz, .13);\n    p.yz=pR(p.yz, .5);\n    float temple = ellip(p, vec3(.1,.1,.15));\n    temple = smax(temple, p.x - .07, .1);\n    d = smin(d, temple, .1);\n    p = pp;\n    p += vec3(.0,.2,-.32);\n    ch = ellip(p, vec3(.1,.08,.1));\n    d = smin(d, ch, .1);\n    p = pp;\n    p += vec3(-.17,.31,-.17);\n    ch = ellip(p, vec3(.1));\n    d = smin(d, ch, .1);\n ;return d;}\n\n\nfloat mouthBase(vec3 p,vec3 pp,vec3 pa,float d){\n    p = pp;\n    p += vec3(-.0,.29,-.29);\n    p.yz=pR(p.yz, -.3);\n    d = smin(d, ellip(p, vec3(.13,.15,.1)), .18);\n    p = pp;\n    p += vec3(0,.37,-.4);\n    d = smin(d, ellip(p, vec3(.03,.03,.02) * .5), .1);\n    p = pp;\n    p += vec3(-.09,.37,-.31);\n    d = smin(d, ellip(p, vec3(.04)), .18);\n ;return d;}\n\nfloat lipBottom(vec3 p,vec3 pp,vec3 pa,float d){\n    \n    p = pp;\n    p += vec3(0,.455,-.455);\n    p.z += smoothstep(.0, .2, p.x) * .05;\n   ;float lb = mix(.035, .03, smoothstep(.05, .15, length(p)));\n    vec3 ls = vec3(.055,.028,.022) * 1.25;\n    float w = .192;\n    vec2 pl2 = vec2(p.x, length(p.yz * vec2(.79,1)));\n    float bottomlip = length(pl2 + vec2(0,w-ls.z)) - w;\n    bottomlip = smax(bottomlip, length(pl2 - vec2(0,w-ls.z)) - w, .055);\n    d = smin(d, bottomlip, lb);\n ;return d;}\n\nfloat lipTop(vec3 p,vec3 pp,vec3 pa,float d){\n        p = pp;\n    p += vec3(0,.38,-.45);\n    p.xz=pR(p.xz, -.3);\n    vec3 ls = vec3(.065,.03,.05);\n    float w = ls.x * (-log(ls.y/ls.x) + 1.);\n    vec3 pl = p * vec3(.78,1,1);\n    float toplip = length(pl + vec3(0,w-ls.y,0)) - w;\n    toplip = smax(toplip, length(pl - vec3(0,w-ls.y,0)) - w, .065);\n    p = pp;\n    p += vec3(0,.33,-.45);\n    p.yz=pR(p.yz, .7);\n    float cut;\n    cut = dot(p, normalize(vec3(.5,.25,0))) - .056;\n    float dip = smin(\n        dot(p, normalize(vec3(-.5,.5,0))) + .005,\n        dot(p, normalize(vec3(.5,.5,0))) + .005,\n        .025    );\n    cut = smax(cut, dip, .04);\n    cut = smax(cut, p.x - .1, .05);\n    toplip = smax(toplip, cut, .02);\n\n    d = smin(d, toplip, .07);\n\n ;return d;}\n\n\nfloat lipSeam(vec3 p,vec3 pp,vec3 pa,float d){\n        p = pp;\n    p += vec3(0,.425,-.44);\n    float lb = length(p);\n    float lr = mix(.04, .02, smoothstep(.05, .12, lb));\n    p.yz=pR(p.yz, .1);\n    p.y -= smoothstep(0., .03, p.x) * .002;\n    p.y += smoothstep(.03, .1, p.x) * .007;\n    p.z -= .133;\n    float seam = fDisc(p, .2);\n    seam = smax(seam, -d - .015, .01); // fix inside shape\n    d = mix(d, smax(d, -seam, lr), .65);\n ;return d;}\n\nfloat nostrils(vec3 p,vec3 pp,vec3 pa,float d){\n    // nostrils base\n    p = pp;\n    p += vec3(0,.3,-.43);\n    d = smin(d, length(p) - .05, .07);\n    // nostrils\n    p = pp;\n    p += vec3(0,.27,-.52);\n    p.yz=pR(p.yz, .2);\n    float nostrils = ellip(p, vec3(.055,.05,.06));\n    p = pp;\n    p += vec3(-.043,.28,-.48);\n    p.xy=pR(p.xy, .15);\n    p.z *= .8;\n    nostrils = smin(nostrils, sdRoundCone(p, .042, .0, .12), .02);\n    d = smin(d, nostrils, .02);\n    p = pp;\n    p += vec3(-.033,.3,-.515);\n    p.xz=pR(p.xz, .5);\n    d = smax(d, -ellip(p, vec3(.011,.03,.025)), .015);\n ;return d;}\n\nfloat eyelid(vec3 p,vec3 pp,vec3 pa,float d){\n    p = pp;\n    p += vec3(-.16,.07,-.34);\n    float eyelids = ellip(p, vec3(.08,.1,.1));\n    p = pp;\n    p += vec3(-.16,.09,-.35);\n    float eyelids2 = ellip(p, vec3(.09,.1,.07));\n        // edge top\n    p = pp;\n    p += vec3(-.173,.148,-.43);\n    p.x *= .97;\n    float et = length(p.xy) - .09;\n    // edge bottom\n    p = pp;\n    p += vec3(-.168,.105,-.43);\n    p.x *= .9;\n    float eb = dot(p, normalize(vec3(-.1,-1,-.2))) + .001;\n    eb = smin(eb, dot(p, normalize(vec3(-.3,-1,0))) - .006, .01);\n    eb = smax(eb, dot(p, normalize(vec3(.5,-1,-.5))) - .018, .05);\n    float edge = max(max(eb, et), -d);\n    d = smin(d, eyelids, .01);\n    d = smin(d, eyelids2, .03);\n    d = smax(d, -edge, .005);\n ;return d;}\n\n\nfloat earEdge(vec3 p,vec3 pp,vec3 pa,float d,float earback,inout float ear,vec3 pe){\n          // inner\n    p.xz=pR(p.xz, -.5);\n    float iear = ellip(p.zy - vec2(.01,-.03), vec2(.045,.05));\n    iear = smin(iear, length(p.zy - vec2(.04,-.09)) - .02, .09);\n\n    float ridge = iear;\n    iear = smin(iear, length(p.zy - vec2(.1,-.03)) - .06, .07);\n    ear = smax2(ear, -iear, .04);\n    earback = smin(earback, iear - .04, .02);\n    //ridge\n    \n    p = pe;\n    p.xz=pR(p.xz, .2);\n    ridge = ellip(p.zy - vec2(.01,-.03), vec2(.045,.055));\n    ridge = smin3(ridge, -pRi(p.zy, .2).x - .01, .015);\n    ridge = smax3(ridge, -ellip(p.zy - vec2(-.01,.1), vec2(.12,.08)), .02);\n    float ridger = .01;\n    ridge = max(-ridge, ridge - ridger);\n    ridge = smax2(ridge, abs(p.x) - ridger/2., ridger/2.);\n    ear = smin(ear, ridge, .045);\n    p = pe;\n    // outline\n    float outline = ellip(pRi(p.yz, .2), vec2(.12,.09));\n    outline = smin(outline, ellip(p.yz + vec2(.155,-.02), vec2(.035, .03)), .14);\n    // edge\n    float eedge = p.x + smoothstep(.2, -.4, p.y) * .06 - .03;\n    float edgeo = ellip(pRi(p.yz, .1), vec2(.095,.065));\n    edgeo = smin(edgeo, length(p.zy - vec2(0,-.1)) - .03, .1);\n    float edgeoin = smax(abs(pRi(p.zy, .15).y + .035) - .01, -p.z-.01, .01);\n    edgeo = smax(edgeo, -edgeoin, .05);\n    float eedent = smoothstep(-.05, .05, -p.z) * smoothstep(.06, 0., fCorner2(vec2(-p.z, p.y)));\n    eedent += smoothstep(.1, -.1, -p.z) * .2;\n    eedent += smoothstep(.1, -.1, p.y) * smoothstep(-.03, .0, p.z) * .3;\n    eedent = min(eedent, 1.);\n    eedge += eedent * .06;\n    eedge = smax(eedge, -edgeo, .01);\n    ear = smin(ear, eedge, .01);\n    ear = max(ear, earback);\n    ear = smax2(ear, outline, .015);\n    d = smin(d, ear, .015);\n ;return d;}\n\nfloat targus(vec3 p,float d\n){d=smin2(d,ellip(p+vec3(-.34,.2,.02),vec3(.015,.025,.015)), .035)\n ;p+=vec3(-.37,.18,.03)\n ;p.xz=pR(p.xz,.5)\n ;p.yz=pR(p.yz,-.4)\n ;d=smin(d, ellip(p,vec3(.01,.03,.015)),.015)\n ;return d ;}\n\nvec3 getPe(vec3 p\n){/* //original euler rotation code\n ;p += vec3(-.405,.12,.10)\n ;p.xy=pR(p.xy,-.12)\n ;p.xz=pR(p.xz,.35)\n ;p.yz=pR(p.yz,-.3)\n     ;return p/**/\n ;return qr(e2q(vec3(.12,.35,.3).yzx),p+vec3(-.405,.12,.10));}\n//not identical, because quaternions lack precision in small angles.\n//not identical, no clue how to translate your inputs into quaternions, this was the closest i could get, with orignal values.\n \n\nfloat ear(vec3 p,vec3 pp,vec3 pa,float d\n){p=getPe(pp)\n ;float ear=p.s+smoothstep(-.05,.1,p.y)*.015 -.005;\n ;float earback = -ear - mix(.001, .025, smoothstep(.3, -.2, p.y));\n ;d=earEdge(p,pp,pa,d,earback,ear,p)\n ;d=targus(pp,d)\n ;return d;}\n\nfloat mHead(vec3 p\n){p.yz=pR(p.yz,-.1)\n ;p.y-=.11\n ;vec3 pa=p   //backup without symmetry\n ;p.x=abs(p.x)//main symmetry\n ;vec3 pp=p   //backup\n ;float d=1e12//zFar\n ;d=       ellip(p+vec3(0,-.135, .09 )                  ,vec3(.395,.385,.395))     //skull back\n ;d=smin(d,ellip(p+vec3(0,-.135, .09 )+vec3(0   ,.1,.07),vec3(.38 ,.36 ,.35 )),.05)// skull base\n ;d=smin(d,ellip(p+vec3(0,-.145,-.175),vec3(.315,.3,.33)),.18)//forehead0\n ;p=vec3(p.x,pR(p.yz, -.5))\n ;float bb = fBox(p, vec3(.5,.67,.7))//forehead1\n ;d=smax(d,bb,.2)\n ;d=smin(d,length(pp+vec3(0,.25,-.13  ))-.28                                 ,.1 )//face base\n ;d=smin(d,ellip (pp+vec3(-.15,.13,.06)                 ,vec3(.15,.15,.15))  ,.15)//behindear0\n ;d=smin(d,length(pp+vec3(-.07,.18,.1 ))-.2                                  ,.18)//behindear1\n ;d=smin(d,ellip (pp+vec3(-.2,.12,-.14)                 ,vec3(.15,.22,.2)*.8),.15)//cheekBase\n ;d=smin(d,ellip (vec3(p.x,pR(pp.yz+vec2(.475,-.16),.8)),vec3(.19,.1 ,.2)   ),.1 )//jawBase\n ;d=brow     (p,pp,d)\n ;d=nose     (p,pp,d)\n ;d=jaw      (p,pp,pa,d)\n ;d=smin(d, ellip((pp+vec3(0,.585,-.395))*vec3(.7,1,1), vec3(.028,.028,.028)*1.2), .15)    // chin\n ;d=cheek    (p,pp,pa,d)\n ;d=mouthBase(p,pp,pa,d)\n ;d=lipBottom(p,pp,pa,d)\n ;d=lipTop   (p,pp,pa,d)\n ;d=lipSeam  (p,pp,pa,d)\n ;d=nostrils (p,pp,pa,d)\n ;d=eyelid   (p,pp,pa,d)\n ;d=min(d,length(pp+vec3(-.165,.0715,-.346))-.088)// eyeball\n ;d=min(d,length(pp+vec3(-.075,.1   ,-.37 ))-.05 )// tear duct\n ;d=ear      (p,pp,pa,d)  \n ;return d;}\n\n\nfloat sstep(float t){return sin(t * PI - PI / 2.) * .5 + .5;}\n\nfloat map(vec3 p\n){float scale = 1.\n ;float s = .2\n ;float ry = mix(sstep(sstep(sstep(mod(iTime * s, 1.)))), mod(iTime * s, 1.), .3) * PI * 2.\n ;float rx = sin(iTime * .33) * .2\n ;if (iMouse.z > 0.\n ){vec4 mouse=iMouseZwFix(iMouse,true)\n  ;//mouse.xy-=mouse.zw\n  ;ry = (.5 - mouse.x / iResolution.x) * PI * 2.\n  ;rx = (.5 - mouse.y / iResolution.y) * PI / 2.\n  ;scale = 2.;}\n ;p.yz=pR(p.yz, rx)\n ;p.xz=pR(p.xz, ry)\n ;p /= scale\n ;return mHead(p)*scale;}\n\nconst int NORMAL_STEPS=6;\nvec3 calcNormal(vec3 pos){\n    vec3 eps = vec3(.0005,0,0);\n    vec3 nor = vec3(0);\n    float invert = 1.;\n    for (int i = 0; i < NORMAL_STEPS; i++){\n        nor += map(pos + eps * invert) * eps * invert;\n        eps = eps.zxy;\n        invert *= -1.;\n    }\n    return normalize(nor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord\n){vec2 p = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y\n ;vec3 camPos = vec3(0,0,3.2)\n ;vec3 rayDirection = normalize(vec3(p,-4))\n ;vec3 rayPosition = camPos\n ;float rayLength = 0.\n ;float dist = 0.\n ;bool bg = false\n ;vec3 col = vec3(.1)\n ;for (int i = 0; i < 150; i++\n ){rayLength += dist\n  ;rayPosition = camPos + rayDirection * rayLength\n  ;dist = map(rayPosition)\n  ;if (abs(dist) < .001)break\n  ;if (rayLength > 5.) {\n            bg = true;break;       }}\n ;if ( ! bg\n ){vec3 n = calcNormal(rayPosition)\n  ;vec3 lp = vec3(-.5,.5,.5)\n  ;float l = max(dot(lp, n), 0.)\n  ;vec3 ld = normalize(lp - rayPosition)\n  ;l += .02\n  ;l += pow(max(0., 1. + dot(n, rayDirection)), 3.) * .05\n  ;col=l*vec3(1,.5,.3)\n  ;col=pow(col, vec3(1./2.2))\n  ;}\n ;fragColor = vec4(col,1);}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec4 iMouseZwFix(vec4 m,bool NewCoke\n ){if(m.z>0.){ //while mouse down\n    if(m.w>0.)return m;//mouse was clicked in THIS     iFrame \n    else m.w=-m.w      //mosue was clicked in previous iFrame\n    //remember, MouseDrag advances the iFrame Count, even while paused !!\n ;}else{if(!NewCoke||m.w>0.)return m.xyxy; //OPTIONAL onMouseUp (fold or whatever)\n    m.zw=-m.zw;}\n  return m;}\n\n#define dd(a) dot(a,a)\n\n//quaternion code\nvec4 qn(vec4 q){return q/dd(q);}//but i guess length(q)is faster than dot(q,q)\nvec4 qmu(vec4 a,vec4 b){\n return qn(vec4(a.w*b.xyz+b.w*a.xyz+cross(a.xyz,b.xyz),a.w*b.w-dot(a.xyz,b.xyz)));}\nvec4 qmu(vec4 a,vec4 b,vec4 c\n){return qmu(a,qmu(b,c));}//==  // qmu(qmu(a,b),c)\nvec4 aa2q(vec3 xyz,float r){r*=.5;return qn(vec4(xyz*sin(r),cos(r)));}//axiisAngle2Quat\nvec4 e2q(vec3 v//http://wiki.secondlife.com/wiki/LlEuler2Rot\n){v*=.5;\n ;vec3 s=sin(v),c=cos(v)\n ;return qmu(vec4(0  ,0  ,s.z,c.z)\n            ,vec4(0  ,s.y,0  ,c.y)\n            ,vec4(s.x,0  ,0  ,c.x));}\nvec3 qr(vec4 q,vec3 v){vec3 t=2.*cross(q.xyz,v);return v+q.w*t+cross(q.xyz,t);}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}