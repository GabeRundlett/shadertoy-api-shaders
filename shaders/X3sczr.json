{
    "Shader": {
        "info": {
            "date": "1726001861",
            "description": "Quasi-Fuchsian group with generators based on Ford circles.",
            "flags": 0,
            "hasliked": 0,
            "id": "X3sczr",
            "likes": 7,
            "name": "Quasi-Fuchsian: Ford circles",
            "published": 3,
            "tags": [
                "kleinian",
                "maths"
            ],
            "usePreview": 0,
            "username": "Refurio",
            "viewed": 93
        },
        "renderpass": [
            {
                "code": "\nconst int N = 20;\nint n;\nconst int depth = 100;\n\n////////////////////////////////\n// view port\n////////////////////////////////\nconst vec2 center = vec2(.5,-1.);\nconst float radius = .51;\nconst float angle = radians(0.);\n\nconst float linewidth = 1.5; // in pixels\n\n////////////////////////////////\n// complex arithmetic\n////////////////////////////////\nconst float pi = radians(180.);\nfloat arg(vec2 z) {\n  return atan(z.y, z.x);\n}\nfloat abs2(vec2 z) {\n  return z.x*z.x + z.y*z.y;\n}\nvec2 cmul(vec2 a, vec2 b) {\n  return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);\n}\n// see my \"Lambert w\" shader for the full set.\n\n////////////////////////////////\n// coloring functions:\n////////////////////////////////\n// https://github.com/hughsk/glsl-hsv2rgb/blob/master/index.glsl\nvec3 hsv(in vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nvec3 hsv(float h, float s, float v) {\n  return hsv(vec3(h, s, v));\n}\nvec3 phase(vec2 z) {\n  return hsv(vec3(arg(z)/pi, 1., 1.));\n}\nvec3 axies(vec2 z) {\n  float t = arg(z)/pi;\n  float a = mod(2.*t+2., 2.)-1.;\n  a = abs(2.*a)-1.;\n  a = asin(a)/pi+.5;\n  return vec3(a,a,a);\n}\nvec3 black  = vec3(0.,0.,0.);\nvec3 white  = vec3(1.,1.,1.);\nvec3 red    = vec3(1.,0.,0.);\nvec3 blue   = vec3(.3,.3,1.);\nvec3 orange = vec3(1.,.7,.2);\n\n// convert pixel coordinate to complex plane coordinate\nvec2 p2c(vec2 p) {\n  vec2 wh2 = iResolution.xy/2.;\n  float pr = min(wh2.x, wh2.y);\n  vec2 c = (p - wh2)/pr;\n  vec2 r = radius * vec2(cos(angle), sin(angle));\n  return cmul(r,c) + center;\n}\n\n// I got these from https://bulatov.org/math/180110/index.html\nvec2 line_refl(vec2 A, vec2 N, float d) {\n  return A - 2.*dot(A - d*N, N)*N;\n}\n// signed distance function\nfloat line_dist(vec2 A, vec2 N, float d) {\n  return dot(A, N) - d;\n}\nvec2 sphere_invert(vec2 A, vec2 C, float r) {\n  return C + r*r/abs2(A-C) * (A-C);\n}\nfloat sphere_dist(vec2 A, vec2 C, float r) {\n  return sign(r)*(length(A-C)-abs(r));\n}\n\n// oscillate between two numbers\nfloat osc(float a, float lo, float hi) {\n  return (1.-cos(a*2.*pi))/2.*(hi-lo) + lo;\n}\n\nint gcd(int i, int j) {\n  do {\n    int t = i;\n    i = j;\n    j = t%j;\n  } while(j > 0);\n  return i;\n}\n\nfloat circle_r(int p, int q) {\n  return .5/float(q*q);\n}\nvec2 circle_c(int p, int q, float r) {\n  return vec2(float(p)/float(q), r-1.);\n}\n\nbool line_iter(vec2 n, float d, inout vec2 z) {\n  if(line_dist(z, n, d) < 0.) {\n    z = line_refl(z, n, d);\n    return true;\n  }\n  return false;\n}\nbool circle_iter(int p, int q, inout vec2 z) {\n  float r = circle_r(p, q);\n  vec2 c = circle_c(p, q, r);\n  if(sphere_dist(z, c, r) < 0.) {\n    z = sphere_invert(z, c, r);\n    return true;\n  }\n  return false;\n}\nbool ford_iter(inout vec2 z) {\n  if(circle_iter(0, 1, z))\n    return true;\n  if(circle_iter(1, 1, z))\n    return true;\n  for(int q = 1; q <= n; ++q) {\n    for(int p = 1; p < q; ++p)\n      if(gcd(q, p) == 1)\n        if(circle_iter(p, q, z))\n          return true;\n  }\n  return line_iter(vec2(0, 1), -1., z);\n}\n\nfloat pixelwidth;\nvoid circle_geom(int p, int q, vec2 z, inout vec4 fragColor) {\n  float r = circle_r(p, q);\n  vec2 c = circle_c(p, q, r);\n\n  r = abs(sphere_dist(z, c, r));\n  float w = clamp(r/linewidth*pixelwidth, 0., 1.);\n  fragColor = mix(vec4(hsv(float(sign(r))/3., 1., 1.), 1.), fragColor, w);\n}\nvoid line_geom(vec2 n, float d, vec2 z, inout vec4 fragColor) {\n  float r = abs(line_dist(z, n, d));\n  float w = clamp(r/linewidth*pixelwidth, 0., 1.);\n  fragColor = mix(vec4(hsv(float(sign(d))/3., 1., 1.), 1.), fragColor, w);\n}\nvoid ford_geom(vec2 z, inout vec4 fragColor) {\n  circle_geom(0, 1, z, fragColor);\n  circle_geom(1, 1, z, fragColor);\n  for(int q = 1; q <= n; ++q)\n    for(int p = 1; p < q; ++p)\n      if(gcd(q, p) == 1)\n        circle_geom(p, q, z, fragColor);\n  line_geom(vec2(0, 1), -1., z, fragColor);\n}\n\nvec3 f(vec2 z) {\n  float t = iTime;\n  float R = 1.;\n\n  int i, k;\n  for(i = 0; i < depth; ++i)\n    if(!ford_iter(z))\n      break;\n\n  // outside\n  if(i == depth)\n    return black;\n\n  float s = float(i)/float(depth);\n  s = pow(s,.35);\n//  return hsv(arg(z), 1.-s, 1.-s);\n//  return hsv(float(i%2)*.1, s, 1.-s);\n  return hsv(0., 0., 1.-s);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  n = int(osc(.5+iTime/3., 1., float(N)+0.99));\n  vec2 z = p2c(fragCoord);\n  fragColor = vec4(f(z), 1.);\n\n  pixelwidth = min(iResolution.x, iResolution.y)/2./radius;\n  ford_geom(z, fragColor);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}