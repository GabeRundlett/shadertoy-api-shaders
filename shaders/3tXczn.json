{
    "Shader": {
        "info": {
            "date": "1591556367",
            "description": "Travelling an alien corridor - What's at the end?",
            "flags": 66,
            "hasliked": 0,
            "id": "3tXczn",
            "likes": 7,
            "name": "Alien Corridor Surprise",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "raymarching",
                "alien"
            ],
            "usePreview": 0,
            "username": "dean_the_coder",
            "viewed": 511
        },
        "renderpass": [
            {
                "code": "#define FAST_NOISE\n//#define USE_WEBCAM\n\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, vec2(123.45, 87.43))) * 5432.3);\n}\n\nfloat noise(vec2 p) {\n#ifdef FAST_NOISE\n    p *= 0.05;\n    return texture(iChannel1, p).r;\n#else\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n    \n    return mix(a, b, f.x) +\n            (c - a) * f.y * (1.0 - f.x) +\n            (d - b) * f.x * f.y;\n#endif\n}\n\nfloat fbm(vec2 p) {\n\tfloat f;\n    f  = 0.5 * noise(p * 1.1);\n    f += 0.22 * noise(p * 2.3);\n    f += 0.0625 * noise(p * 8.4);\n    return f / 0.7825;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nvec2 min2(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n  return length(vec2(length(p.xy) - t.x, p.z)) - t.y;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCorridorRibs(vec3 p) {\n    float d = 0.6;\n    p.z = mod(p.z, d) - d * 0.5;\n    \n    return sdTorus(p, vec2(2.0, 0.2));\n}\n\nfloat sdCorridorTube(vec3 p) {\n    \n    float lxy = length(p.xy);\n    float d = max(lxy - 2.0, 1.9 - lxy);\n    \n    float t = fbm((p.xy + p.yz) * 4.0) * 0.05;\n    return d - t;\n}\n\nfloat sdCorridorRoof(vec3 p) {\n    p.y -= 2.5;\n    float rib = abs(0.5 + 0.5 * sin(p.z * 1.4));\n    return length(p.xy) - 1.2 + 0.2 * pow(rib, 4.0);\n}\n\nvec3 applyCorriderCurve(vec3 p) {\n    // Curve the tunnel (Remember there is no spoon!)\n    p.xz *= rot(-0.01 * p.z);\n    \n    // Walk.\n    if (iTime < 44.0)\n    \tp.z += iTime;\n    else\n        p.z += 44.0 + 2.6 * smoothstep(0.0, 1.0, min(1.0, (iTime - 44.0) / 2.6));\n    \n    return p;\n}\n\n#define EGG_Z 49.0\n\nfloat sdCorridorFloor(vec3 p) {\n    p = applyCorriderCurve(p);\n    p.y += sin(p.x * 1.1 + sin(p.z * 0.7)) * 0.15;\n    float d = p.y + 1.5 + sin(p.z) * 0.05;\n    \n    d = min(d, length(p - vec3(0.0, -3.3, EGG_Z)) - 2.0);\n    \n    return d - fbm(p.xz) * 0.1;\n}\n\nfloat sdCorridor(vec3 p) {\n    p = applyCorriderCurve(p);\n    vec3 pp = p;\n    pp.x = abs(pp.x) - 0.8;\n    float d = smin(sdCorridorRibs(pp), sdCorridorTube(pp), 0.1);\n    d = smin(d, sdCorridorRoof(p), 0.3);\n    \n    return d;\n}\n\nfloat sdEgg(vec3 p) {\n    p = applyCorriderCurve(p);\n    \n    vec3 pp = p;\n    pp.z -= EGG_Z;\n    pp.y += 1.0;\n    \n    float d;\n\n    pp.y *= 0.7;\n    d = length(pp) - 0.4;\n    \n    float startOpenTime = 45.0;\n    float openness = min(1.0, max(0.0, iTime - startOpenTime) * 0.1);\n    if (iTime >= 55.0)\n        openness += sin((iTime - 55.0) * 1.0) * 0.05;\n    \n    float cutOut = length(pp.xz) - p.y * 0.5 - mix(0.1, 0.7, openness);\n    d = smin(d, -cutOut, -0.1);\n    \n    float rim = sdTorus(\n        (pp - vec3(0.0, mix(0.40, 0.25, openness), 0.0)).xzy,\n        vec2(0.35, 0.04) * openness);\n    d = smin(d, rim, 0.05 * openness);\n    \n    d -= fbm(pp.xz + pp.xy) * 0.05;\n    \n    return d;\n}\n\nfloat sdSurprise(vec3 p) {\n    float t = min(1.0, max(0.0, iTime - 62.0));\n    if (t <= 0.0) return 1e10;\n\n    p = applyCorriderCurve(p);\n    p.z -= EGG_Z;\n    \n    p.y += 1.5 - 1.4 * sin(t * 3.14159 * 0.5);\n    \n    float tt = max(0.0, iTime - 62.8) * 2.5;\n    return length(p) - mix(0.1, 2.0, clamp(0.0, 1.0, tt));\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    return normalize(forward + right * uv.x + up * uv.y);\n}\n\nvec2 map(vec3 p) {\n    vec2 d1 = vec2(sdCorridor(p), 1.5);\n    vec2 d2 = vec2(sdCorridorFloor(p), 2.5);\n    vec2 d3 = vec2(sdEgg(p), 3.5);\n    \n    vec2 d = min2(min2(d1, d2), d3);\n    d = min2(d, vec2(sdSurprise(p), 4.5));\n    return d;\n}\n\nvec3 calcNormal(in vec3 p) {\n    // Thanks iq!\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n    return normalize(e.xyy * map(p + e.xyy).x + \n\t\t\t\t\t e.yyx * map(p + e.yyx).x + \n\t\t\t\t\t e.yxy * map(p + e.yxy).x + \n\t\t\t\t\t e.xxx * map(p + e.xxx).x);\n}\n\nfloat calcShadow(vec3 p, vec3 lightPos, float sharpness) {\n    vec3 rd = normalize(lightPos - p);\n    \n    float h;\n    float minH = 1.0;\n    float d = 0.01;\n    for (int i = 0; i < 16; i++) {\n        h = map(p + rd * d).x;\n        minH = abs(h / d);\n        if (minH < 0.01)\n            return 0.0;\n        d += h;\n    }\n    \n    return minH * sharpness;\n}\n\nfloat calcOcc(vec3 p, vec3 n, float strength) {\n    const float dist = 0.3;\n    return 1.0 - (dist - map(p + n * dist).x) * strength;\n}\n\nfloat calcSpotlight(vec3 p, vec3 lightPos, vec3 lightDir, float cutOff, float edgeBlur) {\n    float l = dot(normalize(lightPos - p), -lightDir);\n    edgeBlur += 1.0;\n    float spotLight = smoothstep(1.0 - cutOff, (1.0 - cutOff) * edgeBlur, l) * 0.3;\n    cutOff *= 0.7;\n    spotLight = max(spotLight, smoothstep(1.0 - cutOff, (1.0 - cutOff) * 1.06, l)) * 0.5;\n    cutOff *= 0.7;\n    return max(spotLight, smoothstep(1.0 - cutOff, (1.0 - cutOff) * 1.07, l));\n}\n\nvec3 vignette(vec3 col, vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.4);\n    return col;\n}\n\nvec2 getTorchDir() {\n    \n    float tSeg = iTime;\n    \n    // Look at ceiling.\n    if (tSeg < 2.0) return vec2(0.0, 1.0);\n    tSeg -= 2.0;\n    \n    // Look ahead.\n    if (tSeg < 4.0) return vec2(0.0, mix(1.0, 0.0, smoothstep(0.0, 1.0, min(1.0, tSeg / 2.0))));\n    tSeg -= 4.0;\n    \n    // Down to floor.\n    if (tSeg < 3.5) return vec2(0.0, mix(0.0, -0.4, smoothstep(0.0, 1.0, min(1.0, tSeg / 1.5))));\n    tSeg -= 3.5;\n\n    // Up the wall.\n    if (tSeg < 4.0) {\n        float f = smoothstep(0.0, 1.0, min(1.0, tSeg / 4.0));\n        return vec2(sin(f * 3.141) * -0.6, -0.4 + 1.1 * sin(f * 3.141 / 2.0));\n    }\n    tSeg -= 4.0;\n\n    // Look ahead - Walking.\n    if (tSeg < 12.0) return vec2(0.0, mix(0.7, -0.2, smoothstep(0.0, 1.0, min(1.0, tSeg))));\n    tSeg -= 12.0;\n\n    // Is that an egg?\n    if (tSeg < 17.0) return vec2(0.0, mix(-0.2, -0.05, smoothstep(0.0, 1.0, min(1.0, tSeg / 5.0))));\n    tSeg -= 17.0;\n\n    \n    // Let's have a look...\n    return vec2(0.0, mix(-0.05, -0.35, smoothstep(0.0, 1.0, min(1.0, tSeg / 5.0))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n#ifdef USE_WEBCAM\n    if (iTime > 63.5) {\n    \tfragColor = vec4(mix(vec3(0.0), texture(iChannel0, fragCoord / iResolution.xy).rgb, min(1.0, (iTime - 63.5) * 5.0)), 1.0);\n        return;\n    }\n#endif\n\n    // Raymarch.\n    vec3 torchDir = normalize(vec3(getTorchDir(), 0.8));\n    \n    vec2 walkBump = vec2(sin(iTime * 2.5) * 0.05, pow(0.5 + 0.5 * sin(iTime * 5.0), 2.0) * 0.03);\n    walkBump *= mix(1.0, 0.0, min(1.0, max(0.0, iTime - 44.0) / 2.6));\n    \n    vec3 ro = vec3(walkBump, 0.0);\n    vec3 rd = getRayDir(ro, torchDir + vec3(0.0, 0.1, 0.0), uv);\n\n    int hit = 0;\n    float d = 0.01;\n    vec3 p;\n    for (float steps = 0.0; steps < 120.0; steps++) {\n        p = ro + rd * d;\n        vec2 h = map(p);\n        if (h.x < 0.005 * d) {\n            hit = int(h.y);\n            break;\n        }\n\n        d += h.x;\n    }\n\n    vec3 col;\n    if (hit > 0) {\n        vec3 n = calcNormal(p);\n        vec3 lightPos = vec3(0.0, -0.75, 0.0);\n        vec3 lightCol = vec3(1.0, 0.9, 0.8);\n        vec3 lightToPoint = normalize(lightPos - p);\n        vec3 skyCol = vec3(0.15, 0.2, 0.25);\n        float sha = calcShadow(p, lightPos, 5.0);\n        float occ = calcOcc(p, n, 4.0);\n        float spe = pow(max(0.0, dot(rd, reflect(lightToPoint, n))), 3.0);\n        float torch = calcSpotlight(p, lightPos, torchDir, 0.1, 0.02);\n        float backLight = clamp(dot(n, -rd), 0.01, 1.0) * 0.05;\n        float fog = 1.0 - exp(-d * 0.006);\n\n        vec3 mat;\n        if (hit == 1) {\n            // Tunnel walls.\n            mat = vec3(0.05, 0.06, 0.05);\n        } else if (hit == 2) {\n            // Tunnel floor.\n            mat = vec3(0.055, 0.06, 0.06) * 0.6;\n        } else if (hit == 3) {\n            // Egg.\n            mat = mix(vec3(0.5, 0.3, 0.2), vec3(0.05, 0.06, 0.05), 0.7);\n        } else if (hit == 4) {\n            // Surprise.\n            mat = vec3(0.0);\n        }\n\n        col = (torch * sha + (backLight + spe) * occ) * lightCol;\n        col *= mat;\n        col += torch * 0.02 * lightCol;\n        col = mix(col, skyCol, fog);\n    }\n\n    // Output to screen\n    col = pow(vignette(col, fragCoord), vec3(0.4545));\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "webcam",
                        "id": 31,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/webcam.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "musicstream",
                        "id": 23078,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/chrisjung49-1/only-war-wind-ambient"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}