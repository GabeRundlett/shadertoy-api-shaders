{
    "Shader": {
        "info": {
            "date": "1711157308",
            "description": "newtonscradle",
            "flags": 0,
            "hasliked": 0,
            "id": "X3SSDy",
            "likes": 8,
            "name": "newton's cradle01",
            "published": 3,
            "tags": [
                "newtonscradle"
            ],
            "usePreview": 0,
            "username": "kenshin",
            "viewed": 199
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 100\n#define MAX_DIST  100.\n#define MIN_DIST  .001\n#define PI        3.1415926\n#define TAU       6.2831852\n#define T         iTime\n\nconst int MAT_BASE = 1;\nconst int MAT_BARS = 2;\nconst int MAT_LINE = 3;\nconst int MAT_BALL = 4;\n\nmat2 rot2d(float radian)\n{\n    float c = cos(radian);\n    float s = sin(radian);\n    return mat2(c, -s, s, c);\n}\n\nvec2 Min(vec2 a, vec2 b)\n{\n    return a.x < b.x? a:b;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdBox(vec2 p, vec2 b)\n{\n    vec2 q = abs(p) - b;\n    return length(max(q, .0)) + min(max(q.x, q.y),.0);\n}\n\nfloat sdPlane(vec3 p, vec3 n, float h)\n{\n    return dot(p, n) - h;\n}\n\nfloat sdLineSegment(vec3 p, vec3 a, vec3 b)\n{\n    vec3 ap = p - a,\n         ab = b - a;\n    float t = dot(ap, ab) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    vec3 c = a + t * ab;\n    return length(p - c);\n}\n\nvec2 sdBall(vec3 p, float a)\n{\n    p.y -= 2.5;\n    p.xy *= rot2d(a);\n    p.y += 2.5;\n    float ball = length(p - vec3(.0, .8, .0)) - .25;\n    float ring = length(vec2(length(p.xy - vec2(.0, 1.07)) - .03, p.z)) - .01;\n    p.z = abs(p.z);\n    float line = sdLineSegment(p, vec3(.0, 1.07, .0), vec3(.0, 2.5, .65)) - .004;\n    ball = min(ball, ring);\n    float d = min(ball, line);\n    int mat = 0;\n    mat = d ==ball? MAT_BALL : MAT_LINE;\n    return vec2(d, mat);\n}\n\nvec2 sdScene(vec3 p)\n{\n    float base = sdBox(p, vec3(2., .06, 1.)) - .1;\n    float bar  = length(vec2(sdBox(p.xy, vec2(1.9, 2.5)) - .05, abs(p.z) - .7)) - .05;\n    float d = min(base, bar);\n    d = max(d, -p.y);\n    float a  = sin(T * 2.),\n          a1 = max(a, .0),\n          a5 = min(a, .0);\n    vec2 b1 = sdBall(p - vec3(1., .0, .0), a5),\n          b2 = sdBall(p - vec3(.5, .0, .0), (a + a5) * .05),\n          b3 = sdBall(p, a* .05),\n          b4 = sdBall(p + vec3(.5, .0, .0), (a + a1)* .05),\n          b5 = sdBall(p + vec3(1., .0, .0), a1);\n    vec2 ballLines = Min(Min(Min(Min(b1,b2),b3),b4),b5);\n\n    base = max(base, -p.y);\n    //bar = min()\n    d = min(d, ballLines.x);\n    int mat = 0;\n    if(d == base)\n    {\n        mat = MAT_BASE;\n    }\n    else if(d == bar)\n    {\n        mat = MAT_BARS;\n    }\n    else if(d == ballLines.x)\n    {\n        mat = int(ballLines.y);\n    }\n    return vec2(d, mat);\n}\n\nvec3 getNormal(vec3 p)\n{\n    float s = sdScene(p).x;\n    vec2  e = vec2(.001, .0);\n    return normalize(s - vec3(\n        sdScene(p - e.xyy).x,\n        sdScene(p - e.yxy).x,\n        sdScene(p - e.yyx).x\n    ));\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd)\n{\n    float t = .0;\n    float mat = .0;\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + t * rd;\n        vec2 ss = sdScene(p);\n        mat = ss.y;\n        float dist = ss.x;\n        t += dist;\n        if(abs(dist) < MIN_DIST || t > MAX_DIST) break;\n    }\n    return vec2(t, mat);\n}\n\nvec3 getRayDirection(vec2 uv, vec3 rayOrigin, vec3 lookAt, float zoom)\n{\n    vec3 f = normalize(lookAt - rayOrigin);\n    vec3 r = normalize(cross(vec3(0, 1, 0), f));\n    vec3 u = cross(f, r);\n    vec3 c = rayOrigin + f * zoom;\n    vec3 p = c + uv.y * u + uv.x * r;\n    return normalize(p - rayOrigin);\n}\n\nvec3 getLight(vec3 p)\n{\n    vec3 l = vec3(3., 10., -7.);\n    return normalize(l - p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    vec3 ro = vec3(2.5, 2., -.5);\n    ro.xz *= rot2d(-mouse.x * TAU + 1.);\n    ro.yz *= rot2d(-mouse.y * PI);\n    vec3 rd = getRayDirection(uv, ro, vec3(0, 1, 0), 2.);\n    //skybox\n    vec3 col = texture(iChannel0, rd).rgb;\n    vec2 ss = rayMarch(ro, rd);\n    float t = ss.x;\n    int mat = int(ss.y);\n    if(t < MAX_DIST)\n    {\n        vec3 p = ro + t * rd;\n        vec3 n = getNormal(p);\n        vec3 l = getLight(p);\n        vec3 r = reflect(rd, n);\n        vec3 ref = texture(iChannel0, r).rgb;\n        float diff = max(dot(n, l), .0);\n        \n        //shadow\n        vec3 p0 = p + n * (MIN_DIST + .01);\n        vec2 s = rayMarch(p0, l);\n        if(s.x < length(p0 - vec3(3., 10., -7.)))\n        {\n            diff *= .25;\n        }\n        \n        diff = pow(diff, .4545);\n        col = vec3(diff);\n        \n        if(mat == MAT_BASE)\n        {\n            col *= .2 * ref;\n        }\n        else if(mat == MAT_BARS)\n        {\n            col *= ref;\n        }\n        else if(mat == MAT_BALL)\n        {\n            col = ref;\n        }else if(mat == MAT_LINE)\n        {\n            col *= .01;\n        }\n    }\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}