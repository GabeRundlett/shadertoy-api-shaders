{
    "Shader": {
        "info": {
            "date": "1625753052",
            "description": "Flag of Australia (derived from \"Union Jack Flag\")",
            "flags": 32,
            "hasliked": 0,
            "id": "NtfXDM",
            "likes": 8,
            "name": "Flag From Down Under",
            "published": 3,
            "tags": [
                "flag",
                "dynamics",
                "physics",
                "wind",
                "unionjack",
                "australia"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 357
        },
        "renderpass": [
            {
                "code": "// \"Flag From Down Under\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Flag of Australia (derived from \"Union Jack Flag\")\n\n#define AA  1   // optional antialiasing\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec4 Loadv4 (vec2 vId);\n\nconst ivec2 nBallE = ivec2 (65, 33);\n\nconst int nsMax = 5000;\n\nvec3 sunDir;\nvec2 qgHit;\nfloat dstFar, tCur, todCur, spLen, szFac;\nconst float pi = 3.14159;\n\nvec3 GetR (vec2 v)\n{\n  return Loadv4 (v).xyz;\n}\n\nfloat SheetRay (vec3 ro, vec3 rd)\n{\n  vec3 r, q;\n  vec2 g;\n  float d, dMin, sz, szMax, szMin, grLen;\n  bvec2 ilt;\n  bool bkTrak;\n  grLen = 0.92 * spLen;\n  dMin = dstFar / (grLen * szFac);\n  ro /= szFac;\n  rd /= grLen;\n  szMax = float (nBallE.x - 1);\n  szMin = 1./32.;\n  sz = szMax;\n  g = vec2 (0.);\n  bkTrak = false;\n  for (int ns = VAR_ZERO; ns < nsMax; ns ++) {\n    if (sz == szMin) {\n      r = GetR (g) - ro;\n      q = cross (r, rd);\n      if (dot (q, q) < sz * sz) {\n        d = dot (r, rd);\n        if (d < dMin) {\n          dMin = d;\n          qgHit = g;\n        }\n      }\n      bkTrak = true;\n    }\n    q = cross (GetR (g + 0.5 * sz) - ro, rd);\n    bkTrak = bkTrak || (dot (q, q) > sz * sz);\n    if (bkTrak) {\n      bkTrak = false;\n      ilt = lessThan (fract (g / (2. * sz)), vec2 (0.5));\n      g.x += ilt.x ? sz : - sz;\n      if (! ilt.x) {\n        if (sz == 0.5 * szMax) break;\n        g.y += ilt.y ? sz : - sz;\n        if (! ilt.y) {\n          sz *= 2.;\n          if (sz == szMax) break;\n          bkTrak = true;\n        }\n      }\n    } else if (sz > szMin) sz *= 0.5;\n  }\n  return dMin * grLen * szFac;\n}\n\nvec3 GetRC (vec2 v)\n{\n  return GetR (clamp (v, vec2 (0.), vec2 (nBallE - 1)));\n}\n\nvec3 SheetNf () \n{\n  vec3 c;\n  vec2 e = vec2 (1., 0.);\n  c = GetRC (qgHit);\n  return normalize (cross (GetRC (qgHit + e.yx) - c, GetRC (qgHit + e) - c));\n}\n\nfloat SheetSilHit (vec3 ro, vec3 rd)\n{\n  vec3 blkSize, pMin, pMax, v, tm, tp;\n  float dn, df;\n  pMin = Loadv4 (vec2 (1, nBallE.y)).xyz;\n  pMax = Loadv4 (vec2 (2, nBallE.y)).xyz;\n  ro /= szFac;\n  ro -= 0.5 * (pMin + pMax);\n  blkSize = 0.5 * (pMax - pMin) + 0.5;\n  v = ro  / rd;\n  tp = blkSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  return (df > 0. && dn < df) ? szFac * dn : dstFar;\n}\n\nvec4 CylHit (vec3 ro, vec3 rd, float cylRad, float cylLen)\n{\n  vec3 s, vn;\n  float dMin, d, a, b, w, srdy;\n  dMin = dstFar;\n  a = dot (rd.xz, rd.xz);\n  b = dot (rd.xz, ro.xz);\n  w = b * b - a * (dot (ro.xz, ro.xz) - cylRad * cylRad);\n  if (w > 0.) {\n    srdy = sign (rd.y);\n    if (a > 0.) {\n      d = - b - sqrt (w);\n      if (d > 0.) {\n        d /= a;\n        s = ro + d * rd;\n      } else s.y = cylLen;\n    } else s.y = cylLen;\n    if (abs (s.y) < cylLen) {\n      dMin = d;\n      vn = vec3 (s.xz / cylRad, 0.).xzy;\n    } else if (srdy * ro.y < - cylLen) {\n      d = - (srdy * ro.y + cylLen) / abs (rd.y);\n      if (d > 0.) {\n        s = ro + d * rd;\n        if (length (s.xz) < cylRad) {\n          dMin = d;\n          vn = vec3 (0., 0., - srdy).xzy;\n        }\n      }\n    }\n  }\n  return vec4 (dMin, vn);\n}\n\nvec3 BgCol (vec3 rd)\n{\n  vec3 col;\n  vec2 u;\n  float el, f;\n  rd.xz = Rot2D (rd.xz, 0.01 * tCur);\n  el = asin (rd.y);\n  u = vec2 (atan (rd.z, - rd.x) + pi, tan (2. * atan (0.5 * el))) / (2. * pi);\n  f = 64.;\n  col = mix (vec3 (0., 0.1, 0.3), vec3 (0.8), mix (Fbm2 (f * u),\n     Fbm2 (f * (u - vec2 (1., 0.))), u.x));\n  col = mix (col, vec3 (0.2, 0.3, 0.4), smoothstep (0.95, 0.98, abs (el) / (0.5 * pi)));\n  return col;\n}\n\nvec3 SheetCol (float s)\n{  // specs from Wikipedia\n  vec4 pStar[6];\n  vec3 col, colB, colR, colW;\n  vec2 p, q;\n  float w;\n  colB = vec3 (0., 0., 139. / 255.);\n  colR = vec3 (1., 0., 0.);\n  colW = vec3 (1.);\n  col = colB;\n  p = (qgHit / (0.5 * float (nBallE.y - 1)) - 1.);\n  if (abs (p.x) < 1. && abs (p.y - 0.5) < 0.5) {\n    p *= 2.;\n    p.y -= 1.;\n    w = 1./15.;\n    q = Rot2D (p, atan (0.5));\n    col = mix (colW, col, smoothstep (0., 0.02, abs (q.y) - 3. * w));\n    col = mix (colR, col, smoothstep (0., 0.02, abs (q.y - sign (p.x) * w) - w));\n    q = Rot2D (p, atan (-0.5));\n    col = mix (colW, col, smoothstep (0., 0.02, abs (q.y) - 3.* w));\n    col = mix (colR, col, smoothstep (0., 0.02, abs (q.y - sign (p.x) * w) - w));\n    q = p;\n    col = mix (colW, col, smoothstep (0., 0.02, Minv2 (abs (q)) - 5.* w));\n    col = mix (colR, col, smoothstep (0., 0.02, Minv2 (abs (q)) - 3.* w));\n    col = mix (col, colB, smoothstep (-0.01, 0., Maxv2 (abs (q) - vec2 (2., 1.))));\n  } else {\n    p += 1.;\n    pStar[0] = vec4 (1./4., 1./4., 3./20., 7.);\n    pStar[1] = vec4 (3./4., 1./6., 1./14., 7.);\n    pStar[2] = vec4 (5./8., 9./16., 1./14., 7.);\n    pStar[3] = vec4 (3./4., 5./6., 1./14., 7.);\n    pStar[4] = vec4 (31./36., 151./240., 1./14., 7.);\n    pStar[5] = vec4 (4./5., 11./24., 1./24., 5.);\n    for (int k = 0; k < 6; k ++) {\n      q = p - vec2 (4., 2.) * pStar[k].xy;\n      if (length (q) < 2. * pStar[k].z + 0.02) {\n        q = Rot2D (q, ((pStar[k].w == 7.) ? pi : 0.) + 0.5 * pi / pStar[k].w);\n        q = Rot2D (q, 2. * pi * (floor (pStar[k].w * ((length (q) > 0.) ? atan (q.y, - q.x) : 0.) /\n           (2. * pi) + 0.5) / pStar[k].w));\n        col = mix (colW, col, smoothstep (0., 0.01, dot (vec2 (abs (q.y), - q.x - 2. * pStar[k].z),\n           sin (0.11 * pi + vec2 (0.5 * pi, 0.)))));\n      }\n    }\n  }\n  col = mix (col, vec3 (1.), 0.1);\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, dc4;\n  vec3 col, vn, q;\n  float dstObj, dstSheet, s, flSize;\n  szFac = 4. / float (nBallE.y - 1);\n  flSize = szFac * 0.5 * float (nBallE.y + 1);\n  q = ro;\n  q.y -= - 2. * flSize;\n  dc4 = CylHit (q, rd, 0.06, 3. * flSize + 0.2);\n  dstObj = dc4.x;\n  q = ro;\n  q.x -= 2. * flSize + 0.06;\n  dstSheet = (SheetSilHit (q, rd) < dstFar) ? SheetRay (q, rd) : dstFar;\n  if (min (dstSheet, dstObj) < dstFar) {\n    if (dstSheet < dstObj) {\n      vn = SheetNf ();\n      s = sign (dot (rd, vn));\n      if (s > 0.) vn = - vn;\n      col4 = vec4 (SheetCol (s), 0.03);\n    } else {\n      ro += dstObj * rd;\n      vn = dc4.yzw;\n      col4 = vec4 (0.8, 0.8, 0.85, 0.3);\n      if (abs (ro.y) < flSize + 0.1) col4 *= (0.5 + 0.5 * smoothstep (0.05, 0.1,\n         abs (mod (4. * (ro.y + 0.02) / flSize + 0.5, 1.) - 0.5)));\n    }\n    col = col4.rgb * (0.3 + 0.7 * max (dot (vn, sunDir), 0.)) +\n       col4.a * pow (max (dot (reflect (sunDir, vn), rd), 0.), 32.);\n  } else col = BgCol (rd);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, stDat;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 2.2 * pi * mPtr.x;\n    el += 0.4 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.2 * pi, 0.2 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., -0.7, -20.);\n  ro.x += 4.;\n  stDat = Loadv4 (vec2 (0, nBallE.y));\n  spLen = stDat.x;\n  dstFar = 60.;\n  sunDir = vuMat * normalize (vec3 (-0.5, 1., -1.));\n  col = vec3 (0.);\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), 5.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Flag From Down Under\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nfloat Fbm1 (float p);\nvec4 Loadv4 (vec2 vId);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst ivec2 nBallE = ivec2 (65, 33);\n\nvec3 pMin, pMax;\nivec2 idNeb[4], idNebD[4];\nfloat tCur, spLen, nStep;\nconst float pi = 3.14159;\n\nvec3 GetR (vec2 v)\n{\n  return Loadv4 (v).xyz;\n}\n\nvec3 GetV (vec2 v)\n{\n  return Loadv4 (vec2 (v.x + float (nBallE.x), v.y)).xyz;\n}\n\nvec3 SpringForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 dr, f;\n  ivec2 ivn;\n  float spLenD, fSpring, fSpringD, fDamp;\n  fSpring = 400.;\n  fDamp = 1.;\n  f = vec3 (0.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNeb[n];\n    if (ivn.y >= 0 && ivn.y < nBallE.y && ivn.x >= 0 && ivn.x < nBallE.x) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpring * (spLen - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  fSpringD = 3. * fSpring;\n  spLenD = spLen * sqrt(2.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNebD[n];\n    if (ivn.y >= 0 && ivn.y < nBallE.y && ivn.x >= 0 && ivn.x < nBallE.x) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpringD * (spLenD - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  return f;\n}\n\nvec3 BendForce (ivec2 iv, vec3 r)\n{\n  vec3 dr1, dr2, rt, f;\n  ivec2 ivd, ivp, ivm;\n  float s, c11, c22, c12, cd;\n  bool doInt;\n  f = vec3 (0.);\n  for (int nd = 0; nd < 2; nd ++) {\n    ivd = (nd == 0) ? ivec2 (1, 0) : ivec2 (0, 1);\n    for (int k = 0; k < 3; k ++) {\n      doInt = false;\n      if (nd == 0) {\n        if (k == 0 && iv.x > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.x < nBallE.x - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.x > 0 && iv.x < nBallE.x - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      } else {\n        if (k == 0 && iv.y > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.y < nBallE.y - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.y > 0 && iv.y < nBallE.y - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      }\n      if (doInt) {\n        if (k == 0) {\n          rt = GetR (vec2 (ivp));\n          dr1 = rt - GetR (vec2 (ivm));\n          dr2 = r - rt;\n          s = -1.;\n        } else if (k == 2) {\n          rt = GetR (vec2 (ivm));\n          dr1 = rt - r;\n          dr2 = GetR (vec2 (ivp)) - rt;\n          s = -1.;\n        } else {\n          dr1 = r - GetR (vec2 (ivm));\n          dr2 = GetR (vec2 (ivp)) - r;\n          s = 1.;\n        }\n        c11 = 1. / dot (dr1, dr1);\n        c12 = dot (dr1, dr2);\n        c22 = 1. / dot (dr2, dr2);\n        cd = sqrt (c11 * c22);\n        s *= cd * (c12 * cd - 1.);\n        if (k <= 1) f += s * (dr1 - c12 * c22 * dr2);\n        if (k >= 1) f += s * (c12 * c11 * dr1 - dr2);\n      }\n    }\n  }\n  return f;\n}\n\nvec3 PairForce (vec3 r)\n{\n  vec3 dr, f;\n  float rSep;\n  int nx, ny;\n  f = vec3 (0.);\n  nx = 0;\n  ny = 0;\n  for (int n = 0; n < nBallE.x * nBallE.y; n ++) {\n    dr = r - GetR (vec2 (nx, ny));\n    rSep = length (dr);\n    if (rSep > 0.01 && rSep < 1.) f += (1. / rSep - 1.) * dr;\n    if (++ nx == nBallE.x) {\n      nx = 0;\n      ++ ny;\n    }  \n  }\n  return f;\n}\n\nvec3 NormForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 f, n;\n  ivec2 e = ivec2 (1, 0);\n  f = vec3 (0.);\n  if (iv.y > 0 && iv.y < nBallE.y - 1 && iv.x > 0 && iv.x < nBallE.x - 1) {\n    n = normalize (cross (GetR (vec2 (iv + e.yx)) - GetR (vec2 (iv - e.yx)),\n       GetR (vec2 (iv + e)) - GetR (vec2 (iv - e))));\n    f = - dot (v, n) * n;\n  }\n  return f;\n}\n\nvoid IdNebs ()\n{\n  idNeb[0] = ivec2 (1, 0);\n  idNeb[1] = - idNeb[0];\n  idNeb[2] = ivec2 (0, 1);\n  idNeb[3] = - idNeb[2];\n  idNebD[0] = ivec2 (1, 1);\n  idNebD[1] = - idNebD[0];\n  idNebD[2] = ivec2 (1, -1);\n  idNebD[3] = - idNebD[2];\n}\n\nvoid Step (ivec2 iv, out vec3 r, out vec3 v)\n{\n  vec3 dr, f, wDir;\n  vec2 s;\n  float fOvlap, fBend, fGrav, fDamp, dt;\n  IdNebs ();\n  fOvlap = 1000.;\n  fBend = 50.;\n  fGrav = 0.25;\n  fDamp = 0.5;\n  wDir = vec3 (Rot2D (vec2 (-1., 0.), 0.7 * pi * (2. * Fbm1 (1.5 * tCur) - 1.)), 0.).xzy;\n  r = GetR (vec2 (iv));\n  v = GetV (vec2 (iv));\n  f = fOvlap * PairForce (r) + SpringForce (iv, r, v) + fBend * BendForce (iv, r) +\n     (1. + 8. * Fbm1 (tCur)) * NormForce (iv, r, wDir);\n  f -= fDamp * v;\n  f.y -= fGrav;\n  dt = 0.02;\n  if (iv.x != 0 || mod (float (iv.y), float ((nBallE.y - 1) / 8)) != 0. && iv.y != nBallE.y - 2) {\n    v += dt * f;\n    r += dt * v;\n  }\n}\n\nvoid Init (ivec2 iv, out vec3 r, out vec3 v)\n{\n  float fn;\n  for (int iy = 0; iy < nBallE.y; iy ++) {\n    for (int ix = 0; ix < nBallE.x; ix ++) {\n      if (iv.x == ix && iv.y == iy) {\n        r = vec3 (ix, iy, 0.);\n        r.xy -= 0.5 * (vec2 (nBallE.x, nBallE.y) - 1.);\n        r *= 0.97 * spLen;\n      }\n    }\n  }\n  fn = float (iv.y * nBallE.x + iv.x);\n  v = 1. * normalize (vec3 (Hashff (fn), Hashff (fn + 0.3), Hashff (fn + 0.6)) - 0.5);\n}\n\nvoid SheetLims ()\n{\n  vec3 p;\n  pMin = vec3 (1e6);\n  pMax = - pMin;\n  for (int iy = 0; iy < nBallE.y; iy ++) {\n    for (int ix = 0; ix < nBallE.x; ix ++) {\n      p = GetR (vec2 (ix, iy));\n      pMin = min (pMin, p);\n      pMax = max (pMax, p);\n    }\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat;\n  vec3 r, v;\n  ivec2 pxIv, iv;\n  int mId, pxId, nb;\n  tCur = iTime;\n  pxIv = ivec2 (fragCoord);\n  pxId = pxIv.x + 2 * nBallE.x * pxIv.y;\n  nb = nBallE.x * nBallE.y;\n  if (pxIv.x >= 2 * nBallE.x || pxId >= 2 * nb + 3) discard;\n  stDat = Loadv4 (vec2 (2, nBallE));\n  iv = pxIv;\n  if (iv.x >= nBallE.x) iv.x -= nBallE.x;\n  mId = iv.y * nBallE.x + iv.x;\n  if (iFrame <= 5) {\n    spLen = 1.1;\n    nStep = 0.;\n    if (mId < nb) Init (iv, r, v);\n  } else {\n    stDat = Loadv4 (vec2 (0, nBallE.y));\n    spLen = stDat.x;\n    nStep = stDat.y;\n    stDat = Loadv4 (vec2 (3, nBallE.y));\n    ++ nStep;\n    if (mId < nb) Step (iv, r, v);\n  }\n  if (pxId == 2 * nb + 1 || pxId == 2 * nb + 2) SheetLims ();\n  if (pxId < 2 * nb) stDat = vec4 (((pxIv.x >= nBallE.x) ? v : r), 0.);\n  else {\n    if (pxId == 2 * nb + 0) stDat = stDat = vec4 (spLen, nStep, 0., 0.);\n    else if (pxId == 2 * nb + 1) stDat = vec4 (pMin, 0.);\n    else if (pxId == 2 * nb + 2) stDat = vec4 (pMax, 0.);\n  }\n  Savev4 (vec2 (pxIv), stDat, fragColor, fragCoord);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// \"Flag From Down Under\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nfloat Fbm1 (float p);\nvec4 Loadv4 (vec2 vId);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst ivec2 nBallE = ivec2 (65, 33);\n\nvec3 pMin, pMax;\nivec2 idNeb[4], idNebD[4];\nfloat tCur, spLen, nStep;\nconst float pi = 3.14159;\n\nvec3 GetR (vec2 v)\n{\n  return Loadv4 (v).xyz;\n}\n\nvec3 GetV (vec2 v)\n{\n  return Loadv4 (vec2 (v.x + float (nBallE.x), v.y)).xyz;\n}\n\nvec3 SpringForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 dr, f;\n  ivec2 ivn;\n  float spLenD, fSpring, fSpringD, fDamp;\n  fSpring = 400.;\n  fDamp = 1.;\n  f = vec3 (0.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNeb[n];\n    if (ivn.y >= 0 && ivn.y < nBallE.y && ivn.x >= 0 && ivn.x < nBallE.x) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpring * (spLen - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  fSpringD = 3. * fSpring;\n  spLenD = spLen * sqrt(2.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNebD[n];\n    if (ivn.y >= 0 && ivn.y < nBallE.y && ivn.x >= 0 && ivn.x < nBallE.x) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpringD * (spLenD - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  return f;\n}\n\nvec3 BendForce (ivec2 iv, vec3 r)\n{\n  vec3 dr1, dr2, rt, f;\n  ivec2 ivd, ivp, ivm;\n  float s, c11, c22, c12, cd;\n  bool doInt;\n  f = vec3 (0.);\n  for (int nd = 0; nd < 2; nd ++) {\n    ivd = (nd == 0) ? ivec2 (1, 0) : ivec2 (0, 1);\n    for (int k = 0; k < 3; k ++) {\n      doInt = false;\n      if (nd == 0) {\n        if (k == 0 && iv.x > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.x < nBallE.x - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.x > 0 && iv.x < nBallE.x - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      } else {\n        if (k == 0 && iv.y > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.y < nBallE.y - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.y > 0 && iv.y < nBallE.y - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      }\n      if (doInt) {\n        if (k == 0) {\n          rt = GetR (vec2 (ivp));\n          dr1 = rt - GetR (vec2 (ivm));\n          dr2 = r - rt;\n          s = -1.;\n        } else if (k == 2) {\n          rt = GetR (vec2 (ivm));\n          dr1 = rt - r;\n          dr2 = GetR (vec2 (ivp)) - rt;\n          s = -1.;\n        } else {\n          dr1 = r - GetR (vec2 (ivm));\n          dr2 = GetR (vec2 (ivp)) - r;\n          s = 1.;\n        }\n        c11 = 1. / dot (dr1, dr1);\n        c12 = dot (dr1, dr2);\n        c22 = 1. / dot (dr2, dr2);\n        cd = sqrt (c11 * c22);\n        s *= cd * (c12 * cd - 1.);\n        if (k <= 1) f += s * (dr1 - c12 * c22 * dr2);\n        if (k >= 1) f += s * (c12 * c11 * dr1 - dr2);\n      }\n    }\n  }\n  return f;\n}\n\nvec3 PairForce (vec3 r)\n{\n  vec3 dr, f;\n  float rSep;\n  int nx, ny;\n  f = vec3 (0.);\n  nx = 0;\n  ny = 0;\n  for (int n = 0; n < nBallE.x * nBallE.y; n ++) {\n    dr = r - GetR (vec2 (nx, ny));\n    rSep = length (dr);\n    if (rSep > 0.01 && rSep < 1.) f += (1. / rSep - 1.) * dr;\n    if (++ nx == nBallE.x) {\n      nx = 0;\n      ++ ny;\n    }  \n  }\n  return f;\n}\n\nvec3 NormForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 f, n;\n  ivec2 e = ivec2 (1, 0);\n  f = vec3 (0.);\n  if (iv.y > 0 && iv.y < nBallE.y - 1 && iv.x > 0 && iv.x < nBallE.x - 1) {\n    n = normalize (cross (GetR (vec2 (iv + e.yx)) - GetR (vec2 (iv - e.yx)),\n       GetR (vec2 (iv + e)) - GetR (vec2 (iv - e))));\n    f = - dot (v, n) * n;\n  }\n  return f;\n}\n\nvoid IdNebs ()\n{\n  idNeb[0] = ivec2 (1, 0);\n  idNeb[1] = - idNeb[0];\n  idNeb[2] = ivec2 (0, 1);\n  idNeb[3] = - idNeb[2];\n  idNebD[0] = ivec2 (1, 1);\n  idNebD[1] = - idNebD[0];\n  idNebD[2] = ivec2 (1, -1);\n  idNebD[3] = - idNebD[2];\n}\n\nvoid Step (ivec2 iv, out vec3 r, out vec3 v)\n{\n  vec3 dr, f, wDir;\n  vec2 s;\n  float fOvlap, fBend, fGrav, fDamp, dt;\n  IdNebs ();\n  fOvlap = 1000.;\n  fBend = 50.;\n  fGrav = 0.25;\n  fDamp = 0.5;\n  wDir = vec3 (Rot2D (vec2 (-1., 0.), 0.7 * pi * (2. * Fbm1 (1.5 * tCur) - 1.)), 0.).xzy;\n  r = GetR (vec2 (iv));\n  v = GetV (vec2 (iv));\n  f = fOvlap * PairForce (r) + SpringForce (iv, r, v) + fBend * BendForce (iv, r) +\n     (1. + 8. * Fbm1 (tCur)) * NormForce (iv, r, wDir);\n  f -= fDamp * v;\n  f.y -= fGrav;\n  dt = 0.02;\n  if (iv.x != 0 || mod (float (iv.y), float ((nBallE.y - 1) / 8)) != 0. && iv.y != nBallE.y - 2) {\n    v += dt * f;\n    r += dt * v;\n  }\n}\n\nvoid Init (ivec2 iv, out vec3 r, out vec3 v)\n{\n  float fn;\n  for (int iy = 0; iy < nBallE.y; iy ++) {\n    for (int ix = 0; ix < nBallE.x; ix ++) {\n      if (iv.x == ix && iv.y == iy) {\n        r = vec3 (ix, iy, 0.);\n        r.xy -= 0.5 * (vec2 (nBallE.x, nBallE.y) - 1.);\n        r *= 0.97 * spLen;\n      }\n    }\n  }\n  fn = float (iv.y * nBallE.x + iv.x);\n  v = 1. * normalize (vec3 (Hashff (fn), Hashff (fn + 0.3), Hashff (fn + 0.6)) - 0.5);\n}\n\nvoid SheetLims ()\n{\n  vec3 p;\n  pMin = vec3 (1e6);\n  pMax = - pMin;\n  for (int iy = 0; iy < nBallE.y; iy ++) {\n    for (int ix = 0; ix < nBallE.x; ix ++) {\n      p = GetR (vec2 (ix, iy));\n      pMin = min (pMin, p);\n      pMax = max (pMax, p);\n    }\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat;\n  vec3 r, v;\n  ivec2 pxIv, iv;\n  int mId, pxId, nb;\n  tCur = iTime;\n  pxIv = ivec2 (fragCoord);\n  pxId = pxIv.x + 2 * nBallE.x * pxIv.y;\n  nb = nBallE.x * nBallE.y;\n  if (pxIv.x >= 2 * nBallE.x || pxId >= 2 * nb + 3) discard;\n  stDat = Loadv4 (vec2 (2, nBallE));\n  iv = pxIv;\n  if (iv.x >= nBallE.x) iv.x -= nBallE.x;\n  mId = iv.y * nBallE.x + iv.x;\n  if (iFrame <= 5) {\n    spLen = 1.1;\n    nStep = 0.;\n    if (mId < nb) Init (iv, r, v);\n  } else {\n    stDat = Loadv4 (vec2 (0, nBallE.y));\n    spLen = stDat.x;\n    nStep = stDat.y;\n    stDat = Loadv4 (vec2 (3, nBallE.y));\n    ++ nStep;\n    if (mId < nb) Step (iv, r, v);\n  }\n  if (pxId == 2 * nb + 1 || pxId == 2 * nb + 2) SheetLims ();\n  if (pxId < 2 * nb) stDat = vec4 (((pxIv.x >= nBallE.x) ? v : r), 0.);\n  else {\n    if (pxId == 2 * nb + 0) stDat = stDat = vec4 (spLen, nStep, 0., 0.);\n    else if (pxId == 2 * nb + 1) stDat = vec4 (pMin, 0.);\n    else if (pxId == 2 * nb + 2) stDat = vec4 (pMax, 0.);\n  }\n  Savev4 (vec2 (pxIv), stDat, fragColor, fragCoord);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// \"Flag From Down Under\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nfloat Fbm1 (float p);\nvec4 Loadv4 (vec2 vId);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst ivec2 nBallE = ivec2 (65, 33);\n\nvec3 pMin, pMax;\nivec2 idNeb[4], idNebD[4];\nfloat tCur, spLen, nStep;\nconst float pi = 3.14159;\n\nvec3 GetR (vec2 v)\n{\n  return Loadv4 (v).xyz;\n}\n\nvec3 GetV (vec2 v)\n{\n  return Loadv4 (vec2 (v.x + float (nBallE.x), v.y)).xyz;\n}\n\nvec3 SpringForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 dr, f;\n  ivec2 ivn;\n  float spLenD, fSpring, fSpringD, fDamp;\n  fSpring = 400.;\n  fDamp = 1.;\n  f = vec3 (0.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNeb[n];\n    if (ivn.y >= 0 && ivn.y < nBallE.y && ivn.x >= 0 && ivn.x < nBallE.x) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpring * (spLen - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  fSpringD = 3. * fSpring;\n  spLenD = spLen * sqrt(2.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNebD[n];\n    if (ivn.y >= 0 && ivn.y < nBallE.y && ivn.x >= 0 && ivn.x < nBallE.x) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpringD * (spLenD - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  return f;\n}\n\nvec3 BendForce (ivec2 iv, vec3 r)\n{\n  vec3 dr1, dr2, rt, f;\n  ivec2 ivd, ivp, ivm;\n  float s, c11, c22, c12, cd;\n  bool doInt;\n  f = vec3 (0.);\n  for (int nd = 0; nd < 2; nd ++) {\n    ivd = (nd == 0) ? ivec2 (1, 0) : ivec2 (0, 1);\n    for (int k = 0; k < 3; k ++) {\n      doInt = false;\n      if (nd == 0) {\n        if (k == 0 && iv.x > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.x < nBallE.x - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.x > 0 && iv.x < nBallE.x - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      } else {\n        if (k == 0 && iv.y > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.y < nBallE.y - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.y > 0 && iv.y < nBallE.y - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      }\n      if (doInt) {\n        if (k == 0) {\n          rt = GetR (vec2 (ivp));\n          dr1 = rt - GetR (vec2 (ivm));\n          dr2 = r - rt;\n          s = -1.;\n        } else if (k == 2) {\n          rt = GetR (vec2 (ivm));\n          dr1 = rt - r;\n          dr2 = GetR (vec2 (ivp)) - rt;\n          s = -1.;\n        } else {\n          dr1 = r - GetR (vec2 (ivm));\n          dr2 = GetR (vec2 (ivp)) - r;\n          s = 1.;\n        }\n        c11 = 1. / dot (dr1, dr1);\n        c12 = dot (dr1, dr2);\n        c22 = 1. / dot (dr2, dr2);\n        cd = sqrt (c11 * c22);\n        s *= cd * (c12 * cd - 1.);\n        if (k <= 1) f += s * (dr1 - c12 * c22 * dr2);\n        if (k >= 1) f += s * (c12 * c11 * dr1 - dr2);\n      }\n    }\n  }\n  return f;\n}\n\nvec3 PairForce (vec3 r)\n{\n  vec3 dr, f;\n  float rSep;\n  int nx, ny;\n  f = vec3 (0.);\n  nx = 0;\n  ny = 0;\n  for (int n = 0; n < nBallE.x * nBallE.y; n ++) {\n    dr = r - GetR (vec2 (nx, ny));\n    rSep = length (dr);\n    if (rSep > 0.01 && rSep < 1.) f += (1. / rSep - 1.) * dr;\n    if (++ nx == nBallE.x) {\n      nx = 0;\n      ++ ny;\n    }  \n  }\n  return f;\n}\n\nvec3 NormForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 f, n;\n  ivec2 e = ivec2 (1, 0);\n  f = vec3 (0.);\n  if (iv.y > 0 && iv.y < nBallE.y - 1 && iv.x > 0 && iv.x < nBallE.x - 1) {\n    n = normalize (cross (GetR (vec2 (iv + e.yx)) - GetR (vec2 (iv - e.yx)),\n       GetR (vec2 (iv + e)) - GetR (vec2 (iv - e))));\n    f = - dot (v, n) * n;\n  }\n  return f;\n}\n\nvoid IdNebs ()\n{\n  idNeb[0] = ivec2 (1, 0);\n  idNeb[1] = - idNeb[0];\n  idNeb[2] = ivec2 (0, 1);\n  idNeb[3] = - idNeb[2];\n  idNebD[0] = ivec2 (1, 1);\n  idNebD[1] = - idNebD[0];\n  idNebD[2] = ivec2 (1, -1);\n  idNebD[3] = - idNebD[2];\n}\n\nvoid Step (ivec2 iv, out vec3 r, out vec3 v)\n{\n  vec3 dr, f, wDir;\n  vec2 s;\n  float fOvlap, fBend, fGrav, fDamp, dt;\n  IdNebs ();\n  fOvlap = 1000.;\n  fBend = 50.;\n  fGrav = 0.25;\n  fDamp = 0.5;\n  wDir = vec3 (Rot2D (vec2 (-1., 0.), 0.7 * pi * (2. * Fbm1 (1.5 * tCur) - 1.)), 0.).xzy;\n  r = GetR (vec2 (iv));\n  v = GetV (vec2 (iv));\n  f = fOvlap * PairForce (r) + SpringForce (iv, r, v) + fBend * BendForce (iv, r) +\n     (1. + 8. * Fbm1 (tCur)) * NormForce (iv, r, wDir);\n  f -= fDamp * v;\n  f.y -= fGrav;\n  dt = 0.02;\n  if (iv.x != 0 || mod (float (iv.y), float ((nBallE.y - 1) / 8)) != 0. && iv.y != nBallE.y - 2) {\n    v += dt * f;\n    r += dt * v;\n  }\n}\n\nvoid Init (ivec2 iv, out vec3 r, out vec3 v)\n{\n  float fn;\n  for (int iy = 0; iy < nBallE.y; iy ++) {\n    for (int ix = 0; ix < nBallE.x; ix ++) {\n      if (iv.x == ix && iv.y == iy) {\n        r = vec3 (ix, iy, 0.);\n        r.xy -= 0.5 * (vec2 (nBallE.x, nBallE.y) - 1.);\n        r *= 0.97 * spLen;\n      }\n    }\n  }\n  fn = float (iv.y * nBallE.x + iv.x);\n  v = 1. * normalize (vec3 (Hashff (fn), Hashff (fn + 0.3), Hashff (fn + 0.6)) - 0.5);\n}\n\nvoid SheetLims ()\n{\n  vec3 p;\n  pMin = vec3 (1e6);\n  pMax = - pMin;\n  for (int iy = 0; iy < nBallE.y; iy ++) {\n    for (int ix = 0; ix < nBallE.x; ix ++) {\n      p = GetR (vec2 (ix, iy));\n      pMin = min (pMin, p);\n      pMax = max (pMax, p);\n    }\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat;\n  vec3 r, v;\n  ivec2 pxIv, iv;\n  int mId, pxId, nb;\n  tCur = iTime;\n  pxIv = ivec2 (fragCoord);\n  pxId = pxIv.x + 2 * nBallE.x * pxIv.y;\n  nb = nBallE.x * nBallE.y;\n  if (pxIv.x >= 2 * nBallE.x || pxId >= 2 * nb + 3) discard;\n  stDat = Loadv4 (vec2 (2, nBallE));\n  iv = pxIv;\n  if (iv.x >= nBallE.x) iv.x -= nBallE.x;\n  mId = iv.y * nBallE.x + iv.x;\n  if (iFrame <= 5) {\n    spLen = 1.1;\n    nStep = 0.;\n    if (mId < nb) Init (iv, r, v);\n  } else {\n    stDat = Loadv4 (vec2 (0, nBallE.y));\n    spLen = stDat.x;\n    nStep = stDat.y;\n    stDat = Loadv4 (vec2 (3, nBallE.y));\n    ++ nStep;\n    if (mId < nb) Step (iv, r, v);\n  }\n  if (pxId == 2 * nb + 1 || pxId == 2 * nb + 2) SheetLims ();\n  if (pxId < 2 * nb) stDat = vec4 (((pxIv.x >= nBallE.x) ? v : r), 0.);\n  else {\n    if (pxId == 2 * nb + 0) stDat = stDat = vec4 (spLen, nStep, 0., 0.);\n    else if (pxId == 2 * nb + 1) stDat = vec4 (pMin, 0.);\n    else if (pxId == 2 * nb + 2) stDat = vec4 (pMax, 0.);\n  }\n  Savev4 (vec2 (pxIv), stDat, fragColor, fragCoord);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// \"Flag From Down Under\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nfloat Fbm1 (float p);\nvec4 Loadv4 (vec2 vId);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst ivec2 nBallE = ivec2 (65, 33);\n\nvec3 pMin, pMax;\nivec2 idNeb[4], idNebD[4];\nfloat tCur, spLen, nStep;\nconst float pi = 3.14159;\n\nvec3 GetR (vec2 v)\n{\n  return Loadv4 (v).xyz;\n}\n\nvec3 GetV (vec2 v)\n{\n  return Loadv4 (vec2 (v.x + float (nBallE.x), v.y)).xyz;\n}\n\nvec3 SpringForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 dr, f;\n  ivec2 ivn;\n  float spLenD, fSpring, fSpringD, fDamp;\n  fSpring = 400.;\n  fDamp = 1.;\n  f = vec3 (0.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNeb[n];\n    if (ivn.y >= 0 && ivn.y < nBallE.y && ivn.x >= 0 && ivn.x < nBallE.x) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpring * (spLen - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  fSpringD = 3. * fSpring;\n  spLenD = spLen * sqrt(2.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNebD[n];\n    if (ivn.y >= 0 && ivn.y < nBallE.y && ivn.x >= 0 && ivn.x < nBallE.x) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpringD * (spLenD - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  return f;\n}\n\nvec3 BendForce (ivec2 iv, vec3 r)\n{\n  vec3 dr1, dr2, rt, f;\n  ivec2 ivd, ivp, ivm;\n  float s, c11, c22, c12, cd;\n  bool doInt;\n  f = vec3 (0.);\n  for (int nd = 0; nd < 2; nd ++) {\n    ivd = (nd == 0) ? ivec2 (1, 0) : ivec2 (0, 1);\n    for (int k = 0; k < 3; k ++) {\n      doInt = false;\n      if (nd == 0) {\n        if (k == 0 && iv.x > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.x < nBallE.x - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.x > 0 && iv.x < nBallE.x - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      } else {\n        if (k == 0 && iv.y > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.y < nBallE.y - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.y > 0 && iv.y < nBallE.y - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      }\n      if (doInt) {\n        if (k == 0) {\n          rt = GetR (vec2 (ivp));\n          dr1 = rt - GetR (vec2 (ivm));\n          dr2 = r - rt;\n          s = -1.;\n        } else if (k == 2) {\n          rt = GetR (vec2 (ivm));\n          dr1 = rt - r;\n          dr2 = GetR (vec2 (ivp)) - rt;\n          s = -1.;\n        } else {\n          dr1 = r - GetR (vec2 (ivm));\n          dr2 = GetR (vec2 (ivp)) - r;\n          s = 1.;\n        }\n        c11 = 1. / dot (dr1, dr1);\n        c12 = dot (dr1, dr2);\n        c22 = 1. / dot (dr2, dr2);\n        cd = sqrt (c11 * c22);\n        s *= cd * (c12 * cd - 1.);\n        if (k <= 1) f += s * (dr1 - c12 * c22 * dr2);\n        if (k >= 1) f += s * (c12 * c11 * dr1 - dr2);\n      }\n    }\n  }\n  return f;\n}\n\nvec3 PairForce (vec3 r)\n{\n  vec3 dr, f;\n  float rSep;\n  int nx, ny;\n  f = vec3 (0.);\n  nx = 0;\n  ny = 0;\n  for (int n = 0; n < nBallE.x * nBallE.y; n ++) {\n    dr = r - GetR (vec2 (nx, ny));\n    rSep = length (dr);\n    if (rSep > 0.01 && rSep < 1.) f += (1. / rSep - 1.) * dr;\n    if (++ nx == nBallE.x) {\n      nx = 0;\n      ++ ny;\n    }  \n  }\n  return f;\n}\n\nvec3 NormForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 f, n;\n  ivec2 e = ivec2 (1, 0);\n  f = vec3 (0.);\n  if (iv.y > 0 && iv.y < nBallE.y - 1 && iv.x > 0 && iv.x < nBallE.x - 1) {\n    n = normalize (cross (GetR (vec2 (iv + e.yx)) - GetR (vec2 (iv - e.yx)),\n       GetR (vec2 (iv + e)) - GetR (vec2 (iv - e))));\n    f = - dot (v, n) * n;\n  }\n  return f;\n}\n\nvoid IdNebs ()\n{\n  idNeb[0] = ivec2 (1, 0);\n  idNeb[1] = - idNeb[0];\n  idNeb[2] = ivec2 (0, 1);\n  idNeb[3] = - idNeb[2];\n  idNebD[0] = ivec2 (1, 1);\n  idNebD[1] = - idNebD[0];\n  idNebD[2] = ivec2 (1, -1);\n  idNebD[3] = - idNebD[2];\n}\n\nvoid Step (ivec2 iv, out vec3 r, out vec3 v)\n{\n  vec3 dr, f, wDir;\n  vec2 s;\n  float fOvlap, fBend, fGrav, fDamp, dt;\n  IdNebs ();\n  fOvlap = 1000.;\n  fBend = 50.;\n  fGrav = 0.25;\n  fDamp = 0.5;\n  wDir = vec3 (Rot2D (vec2 (-1., 0.), 0.7 * pi * (2. * Fbm1 (1.5 * tCur) - 1.)), 0.).xzy;\n  r = GetR (vec2 (iv));\n  v = GetV (vec2 (iv));\n  f = fOvlap * PairForce (r) + SpringForce (iv, r, v) + fBend * BendForce (iv, r) +\n     (1. + 8. * Fbm1 (tCur)) * NormForce (iv, r, wDir);\n  f -= fDamp * v;\n  f.y -= fGrav;\n  dt = 0.02;\n  if (iv.x != 0 || mod (float (iv.y), float ((nBallE.y - 1) / 8)) != 0. && iv.y != nBallE.y - 2) {\n    v += dt * f;\n    r += dt * v;\n  }\n}\n\nvoid Init (ivec2 iv, out vec3 r, out vec3 v)\n{\n  float fn;\n  for (int iy = 0; iy < nBallE.y; iy ++) {\n    for (int ix = 0; ix < nBallE.x; ix ++) {\n      if (iv.x == ix && iv.y == iy) {\n        r = vec3 (ix, iy, 0.);\n        r.xy -= 0.5 * (vec2 (nBallE.x, nBallE.y) - 1.);\n        r *= 0.97 * spLen;\n      }\n    }\n  }\n  fn = float (iv.y * nBallE.x + iv.x);\n  v = 1. * normalize (vec3 (Hashff (fn), Hashff (fn + 0.3), Hashff (fn + 0.6)) - 0.5);\n}\n\nvoid SheetLims ()\n{\n  vec3 p;\n  pMin = vec3 (1e6);\n  pMax = - pMin;\n  for (int iy = 0; iy < nBallE.y; iy ++) {\n    for (int ix = 0; ix < nBallE.x; ix ++) {\n      p = GetR (vec2 (ix, iy));\n      pMin = min (pMin, p);\n      pMax = max (pMax, p);\n    }\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat;\n  vec3 r, v;\n  ivec2 pxIv, iv;\n  int mId, pxId, nb;\n  tCur = iTime;\n  pxIv = ivec2 (fragCoord);\n  pxId = pxIv.x + 2 * nBallE.x * pxIv.y;\n  nb = nBallE.x * nBallE.y;\n  if (pxIv.x >= 2 * nBallE.x || pxId >= 2 * nb + 3) discard;\n  stDat = Loadv4 (vec2 (2, nBallE));\n  iv = pxIv;\n  if (iv.x >= nBallE.x) iv.x -= nBallE.x;\n  mId = iv.y * nBallE.x + iv.x;\n  if (iFrame <= 5) {\n    spLen = 1.1;\n    nStep = 0.;\n    if (mId < nb) Init (iv, r, v);\n  } else {\n    stDat = Loadv4 (vec2 (0, nBallE.y));\n    spLen = stDat.x;\n    nStep = stDat.y;\n    stDat = Loadv4 (vec2 (3, nBallE.y));\n    ++ nStep;\n    if (mId < nb) Step (iv, r, v);\n  }\n  if (pxId == 2 * nb + 1 || pxId == 2 * nb + 2) SheetLims ();\n  if (pxId < 2 * nb) stDat = vec4 (((pxIv.x >= nBallE.x) ? v : r), 0.);\n  else {\n    if (pxId == 2 * nb + 0) stDat = stDat = vec4 (spLen, nStep, 0., 0.);\n    else if (pxId == 2 * nb + 1) stDat = vec4 (pMin, 0.);\n    else if (pxId == 2 * nb + 2) stDat = vec4 (pMax, 0.);\n  }\n  Savev4 (vec2 (pxIv), stDat, fragColor, fragCoord);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}