{
    "Shader": {
        "info": {
            "date": "1706773389",
            "description": "Realistic clouds with crude mouse control and sunset.",
            "flags": 32,
            "hasliked": 0,
            "id": "XcjXWy",
            "likes": 30,
            "name": "PBR CLOUDS",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "clouds",
                "cloud",
                "volumetric",
                "atmosphere",
                "scatter",
                "mie"
            ],
            "usePreview": 0,
            "username": "El_Sargo",
            "viewed": 716
        },
        "renderpass": [
            {
                "code": "// PBR clouds by El_Sargo\n// Aims to be quite realistic, required way to much tweaking.\n// Won't run propperly if the resolution is too low.\n// Use mouse to controll the sun, ( yes I know the atmosphere code is rubish )\nvoid mainImage(out vec4 o, in vec2 i){\n    vec2 uv = i/iResolution.xy;\n    vec3 col = texture(iChannel0,uv).rgb;\n    col *= smoothstep(.9,0.4,length(uv-0.5));\n    o = vec4( col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Storage buffer for 3D voronoise\n\n#define SCALE 10.\n\nvoid mainImage( out vec4 O, in vec2 I ) {\n    vec2 uv = I/iResolution.xy;\n    ivec2 ir = ivec2(iResolution.x,0);\n    if (ivec2(I.x+1.0,I.y) == ir) {\n        O = iResolution.xxxx; \n    } else if ( iResolution.x != texelFetch(iChannel0,ir-ivec2(1,0),0).x ){\n        float horizontal_slices = floor( iResolution.x / SIZE );\n        float vertical_slices = floor( iResolution.y / SIZE );\n        vec2 slice_coord = fc_to_slice_coord(I);\n        slice_coord -= 1./SIZE;\n        slice_coord /= SIZE/(SIZE+2.0);\n        float slice_base_layer = id_to_slice_layer(fc_to_slice_id(I),horizontal_slices, vertical_slices);\n        vec3 repetition = vec3(1.0);\n        float r = PeriodicalCellularNoise(\n            vec3(slice_coord,slice_base_layer),\n            SCALE,repetition\n         ) + PeriodicalCellularNoise(\n            vec3(slice_coord,slice_base_layer),\n            SCALE*N_SCALE,repetition\n         ) / w_f;\n        float g = PeriodicalCellularNoise(\n            vec3(slice_coord,slice_base_layer+1./SIZE),\n            SCALE,repetition\n         ) + PeriodicalCellularNoise(\n            vec3(slice_coord,slice_base_layer+1./SIZE),\n            SCALE*N_SCALE,repetition\n         ) / w_f;\n        float b = PeriodicalCellularNoise(\n            vec3(slice_coord,slice_base_layer+2./SIZE),\n            SCALE,repetition\n         ) + PeriodicalCellularNoise(\n            vec3(slice_coord,slice_base_layer+2./SIZE),\n            SCALE*N_SCALE,repetition\n         ) / w_f;\n         float a = PeriodicalCellularNoise(\n            vec3(slice_coord,slice_base_layer+3./SIZE),\n            SCALE,repetition\n         ) + PeriodicalCellularNoise(\n            vec3(slice_coord,slice_base_layer+3./SIZE),\n            SCALE*N_SCALE,repetition\n         ) / w_f;\n            \n        O = vec4( r,g,b,a );\n        \n    } else {\n        O = texture(iChannel0,I/iResolution.xy);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "vec2 getMouse(){\n    if (iMouse.z > 0.5) {\n       return iMouse.xy/iResolution.xy;\n    } else {\n        return vec2(0.6,1.7);\n    }\n}\n\n#define SAMPLEW(x) (sample_tex(x*1.+vec3(0.005),iChannel2,floor( iResolution.x / SIZE ),iResolution.xy))\n\nfloat erode(vec3 x, int octaves) {\n   float time = iTime + 190.0;\n   float y = (length(x)-CLOUD_BASE)/(CLOUD_TOP-CLOUD_BASE+0.11);\n   \n   float f = N_SCALE;\n     x += 0.001*time;    \n     x *= 0.05 * f + 0.;\n    vec3 p = x * .8;\n    float c = .5,\n     a = .5,\n     vfbm = 0.0,\n     k = -1.0,\n     r = 0.0,\n     s = 0.0;\n     \n     float worley = SAMPLEW(x)*c;\n     x += PI;\n     k = -k;\n     float wfbm = 0.;\n    \n    for (int i=0;i<octaves;i++){\n        k = -k;\n        wfbm += SAMPLEW(x) * c;\n        r += (1.0 + c) * c;\n        c *= w_f;\n        x *= f;\n        \n    }\n    for (int i=0;i<10;i++){\n        k = -k;\n        vfbm += t3x(iChannel0,p).x * a;\n        s += a;\n        p *= 2.0;\n        a *= 0.7;\n    }\n    wfbm = 1.-wfbm/r;\n    vfbm = abs(vfbm/s-0.5)*2.0;\n    worley = 1. - worley / (1.0 + w_f);\n    float pwfbm = vfbm * ( 1.0 - worley) + worley;\n    pwfbm = mix(pwfbm,wfbm*2.,y);\n    float erosion = (pwfbm - wfbm + 1. - y*0.2) / (2.0 - wfbm) ;\n    \n    return -.9+erosion;\n}\n\n\nfloat h(vec3 p){ \n    float y = length(p);\n    return .15-abs(-0.003+y-CLOUD_BASE);\n}\n\n\nvec3 getSky(vec3 ro, vec3 rd, vec3 sun, vec2 uv){\n    float rds = dot(sun, rd);\n    vec3 sky = get_sky(rd,ro,sun);\n    vec3 sunset = get_sky(sun,ro,sun);\n    \n    vec3 amb = get_sky(normalize(ro),ro,sun)*1.0;\n    \n    vec2 i = shell_intersect(ro,rd,CLOUD_BASE,CLOUD_TOP);\n    float start = i.x;\n    \n    float end = i.y;\n    float dj = 0.001;\n    float ext = 1.0;\n    float j=start-+texture(iChannel1,uv+iTime).x*dj*1.;\n    float dm = 10000.0;\n    float prevd = 0.;\n    float d = 0.;\n\tfloat g = 0.;\n    int occ = 5;\n    \n    float AT = .5;\n    float AAT = .8;\n    vec3 mask = (1.-exp(-start*vec3(1,2,4)*AT))*AAT*sunset;\n\tvec3 ccol = mask;\n    \n    float dd = 0.0;\n\tfor (; j<end;j+=dj){\n        vec3 s = (rd*j+ro);\n        float height_coef =  h(s);\n        \n        mask = exp(-j*vec3(4,2,1)*AT)*sunset;\n        ccol += ((exp(-(j-dj)*vec3(1,2,4)*AT)-exp(-j*vec3(1,2,4)*AT)))*AAT*exp(-ext*g);\n        if (  height_coef < 0.0) {\n            j += max(0.,-height_coef*0.1);\n            continue;\n        }\n\n        prevd = d;\n        d =  (height_coef + erode(s,occ)) * dm;\n       \n        float dens = intLUT(prevd,d)*dj ;\n      \n        if (dens > 0.) {\n            float dy = 0.001;\n            vec2 ede = sphIntersect(\n                s,\n                sun,\n                vec3(0,0,0),\n                CLOUD_TOP\n            );\n\n            float \n              pdd=d,\n              sdd = 0.0,\n              Y=dy;\n            \n            for (;Y<min(max(0.,ede.y),.2);Y+=dy){\n                vec3 p = s+sun*Y;\n            \n                float hc = h(p);\n                if ( hc < -0. ) {\n                    break;\n                }\n                pdd = sdd;\n                int pppp;\n                sdd =  (hc + erode(p,occ)) * dm;\n\n                float sdens = intLUT(pdd,sdd)*dy;\n            \n                dd += sdens;\n                dy += 0.001;\n            }\n        \n            float su = mo_scat(dd,1.0,ext);\n\n            ccol += \n            mask\n            *vec3(1,0.8,.6)\n            *dens\n            *su\n            *mo_scat(g,rds,ext)\n            *50.;\n        \n        } \n        g += max(0.,dens);\n        if (g > 2.) {\n          break;\n        }\n    }\n        \n    float eee = exp(-g*ext);\n    return mix(\n        ccol ,\n        ccol + (1.-exp(-2.0*end*vec3(1,2,4)*AT))*AAT*exp(-ext*g) , \n        eee\n    );\n}\n\nvoid mainImage( out vec4 fragColor , in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col;\n    vec2 mou = getMouse();\n    float mx = -mou.x*10.;\n    float my = mou.y*4.;\n    vec3 sun = normalize(vec3(sin(mx),sin(my-0.3)*2.,cos(mx)));\n    #ifdef HALF_RESOLUTION\n    if (max(uv.x,uv.y) <= 0.5) {\n        uv *= 2.0;\n        float dx = float(iFrame % 2)-0.5;\n        float dy = float((iFrame / 2 )% 2)-0.5;\n        uv += 0.5*vec2(dFdx(uv.x)*dx,dFdy(uv.y)*dy);\n    #endif\n    vec2 nuv = (uv-0.5)*vec2(1.,iResolution.y/iResolution.x);\n    \n    vec3 ro = vec3(-0.05,EARTH_RAD,0.0);\n    \n    vec3 rd = normalize(vec3(nuv, -0.7));\n    rd.yz *= rot(.45);\n    rd.xz *= rot(-1.7);\n   \n    col = getSky(ro, rd, sun,uv);\n    #ifdef HALF_RESOLUTION\n    }\n    #endif\n    fragColor = vec4(col,1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "volume",
                        "id": 40,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Decompress hrr and apply taa\nvoid mainImage( out vec4 fragColor, in vec2 f ) {\n    vec2 uv = f/iResolution.xy;\n    #ifdef HALF_RESOLUTION\n        vec2 u = uv/2.0;\n        vec2 d = vec2(dFdx(u.x),dFdy(u.y));\n        int k = int(f.x) % 2 + (int(f.y)%2)*2;\n        if (k == iFrame % 4){\n            vec3 col = texelFetch(iChannel0,ivec2(f*0.5),0).rgb;\n            vec3 prev = texelFetch(iChannel1,ivec2(f),0).rgb;\n            col /= 8.;\n            col = aces_tonemap(col);\n            fragColor = vec4(mix(col, prev,.5),1.0);\n        } else {\n            fragColor = texelFetch(iChannel1,ivec2(f),0);\n        }\n\n    #else\n            vec3 col = texelFetch(iChannel0,ivec2(f),0).rgb;\n            col /= 8.;\n            col = aces_tonemap(col);\n            vec3 prev = texelFetch(iChannel1,ivec2(f),0).rgb;\n            \n            fragColor = vec4(mix(col, prev,.5),1.0);\n    #endif \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define HALF_RESOLUTION\nconst float CLOUD_TOP = 63.79,\n            CLOUD_BASE = 63.78,\n            EARTH_RAD = 63.71,\n            N_SCALE = 2.5, // I got this number from measuring a cauliflower\n            PI = 3.14159265359,\n            AtRad = 64.3,\n            directScatterCoef = .055,\n            inDirectScatterCoef = .03,\n            sunCoef = .1,\n            w_f = 0.6;\n \nconst vec3 rgbScatter = vec3(1,2,4);\n\n\nfloat  intLUT(float a,float b) {\n    if ( a > 0.0 && b <= 0.0 ) {\n        return a*a / (2.0*a-2.0*b);\n    } else if ( a <= 0.0 && b > 0.0) {\n        return -b*b / ( 2.0 * (a-b));\n    } else {\n        return max(0.,a+b/2.);\n    }\n}\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra ) {\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nvec2 shell_intersect(vec3 ro, vec3 rd, float a, float b){\n\n    vec2 inner = sphIntersect(\n        ro,\n        rd,\n        vec3(0,0,0),\n        a  \n    );\n    vec2 outer = sphIntersect(\n        ro,\n        rd,\n        vec3(0,0,0),\n        b \n    );\n    float l = length(ro);\n    if (l < a) {\n        return vec2(inner.y,outer.y);\n    } else if (l < b) {\n        if (inner.x > -0.5) {\n            return vec2(0.0, inner.x);\n        } else {\n            return vec2(0.0,outer.y);\n        }\n    } else {\n        if (outer.x > -0.5) {\n            if (inner.x > -0.5) {\n                return vec2(outer.x,inner.x);\n            } else {\n                return vec2(outer.x,outer.y);\n            }\n        } else {\n            return vec2(-1);\n        }\n    }\n}\n\nvec3 get_sky(vec3 rd, vec3 pos, vec3 sun){\n    //Distances, proportaional to the real world\n    vec2 i = max(vec2(0.),sphIntersect(pos, rd, vec3(0), AtRad));\n    float atDist = i.y-i.x;    \n    i = max(vec2(0.),sphIntersect(pos, sun, vec3(0), AtRad));\n    float snDist = i.y-i.x-1.1;\n    \n    float rds = dot(sun, rd);\n    float ssc = (abs(rds)*0.5+0.5);\n    vec3 tra = normalize(sun-rd);\n    vec2 jab = vec2(\n    max(tra.x, max(tra.y, tra.z)),\n    min(tra.x, max(tra.y, tra.z))\n    );\n    float fla = pow(abs(sin(atan(jab.x,jab.y)*40.)), 100.)*.001;\n\n    vec3 light = vec3(smoothstep(0.999, .9999, rds))*1.;\n         light += atDist * (1.-abs(rd.y)) * ssc*0.2;\n         light += 2.*(1.-exp(-rgbScatter*atDist*inDirectScatterCoef*(atDist*5.*.5+.5)));\n         light *= exp(\n             -rgbScatter*\n             (atDist*directScatterCoef+snDist*sunCoef)\n         );\n         \n     return 10.*light;\n}\n\nmat2 rot(float a){\n    float s=sin(a),c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat h_gr(float g, float c) {\n    return \n      (1.0 / (4.0 * PI))\n      *\n      ((1.0 - g*g) / pow(1.0 + g*g - 2.0 * g * c, 1.5));\n}\n\nfloat dlgh( float g, float c, float k) {\n    return mix(h_gr(g,c),h_gr(-g,c),k);\n}\n\n\nfloat mo_scat(float d, float mu, float ext) {\n    float \n      at = 0.2,\n      co = 0.4,\n      pa = 0.1,\n    \n      a = 1.0,\n      b = 1.0,\n      c = 1.0,\n      g = 0.85,\n      \n      l = 0.0;\n    \n    const int so = 4;\n    \n    for (int i=0;i<so;i++) {\n        float ph = dlgh(c * 0.6, mu, .3);\n        \n        float be = exp(-d * a * ext);\n        \n        l += b * ph * be;\n        \n        a *= at;\n        b *= co;\n        c *= (1.0 - pa);\n    }\n    \n    return l;\n    \n}\n\n// https://www.shadertoy.com/view/XsfGDn\nvec4 t3x( sampler3D sam, vec3 uv ) {\n    float textureResolution = float(textureSize(sam,0).x);\n    uv = uv*textureResolution + 0.5;\n    vec3 iuv = floor( uv );\n    vec3 fuv = fract( uv );\n    uv = iuv + fuv*fuv*(3.0-2.0*fuv);\n    uv = (uv - 0.5)/textureResolution;\n    return texture( sam, uv );\n}\n#define ACTUAL_SIZE 64.0\n#define SIZE (ACTUAL_SIZE+2.0)\nvec2 layer_to_slice_id( float z_layer, float horizontal_slices ) {\n    z_layer = floor( z_layer / 3.0 );\n    float x_offset = mod( z_layer, horizontal_slices );\n    float y_offset = ( z_layer - x_offset ) / horizontal_slices;\n    return vec2( x_offset, y_offset );\n}\n\nfloat id_to_slice_layer( vec2 slice_id, float horizontal_slices, float vertical_slices ){\n    return mod(( slice_id.y * horizontal_slices + slice_id.x ) * 3., horizontal_slices*horizontal_slices) /SIZE ;\n}\n\nvec2 fc_to_slice_coord( vec2 fc ) {\n    return mod( fc, SIZE ) / SIZE;\n}\n\nvec2 fc_to_slice_id( vec2 fc ) {\n    return ( fc - mod( fc, SIZE ) ) / SIZE;\n}\n\nfloat sample_tex( vec3 p, sampler2D sam, float horizontal_slices, vec2 res) {\n    vec3 s = mod( p, 1.0 );\n    float z = s.y * SIZE;\n    vec2 w = fwidth(p.xz)*2.;\n    s.xz *= SIZE/(SIZE+2.0);\n    s.xz += 1./SIZE;\n    \n    float blend = mod( z, 3.0 );\n    int blend_id = int( blend );\n    float blend_factor = fract( blend );\n    vec2 id = layer_to_slice_id( z, horizontal_slices );\n    vec2 fc = ( id + s.xz ) * SIZE;\n    vec2 uv = fc / res;\n    vec4 data = texture(sam, uv,0.0);\n    float a,b;\n    if ( blend_id == 0 ) {\n        a = data.r;\n        b = data.g;\n    } else if ( blend_id == 1 ) {\n        a = data.g;\n        b = data.b;\n        \n    } else if ( blend_id == 2 ) {\n        a = data.b;\n        b = data.a;\n    }\n    return mix(a,b,blend_factor);\n}\n\nvec3 aces_tonemap(vec3 color) {\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n}\n\n/////////////////////////////////////////////////////////\n// Noise                                               //\n/////////////////////////////////////////////////////////\n\n\n#define wrap(x, _min, _max) (_min + mod(_max - _min + mod(x - _min, _max - _min), _max - _min))\n\nfloat Repeat(float t, float len) {\n    //return wrap(t, 0., len);\n    return clamp(t - floor(t / len) * len, 0., len);\n}\nvec2 Repeat(vec2 t, vec2 size) {\n    return vec2(Repeat(t.x, size.x), Repeat(t.y, size.y));\n}\n\nvec3 Repeat(vec3 t, vec3 size) {\n    return vec3(\n        Repeat(t.x, size.x),\n        Repeat(t.y, size.y),\n        Repeat(t.z, size.z)\n    );\n}\n\n// RNG\nuint WangHash(uint n)\n{\n    // https://gist.github.com/badboy/6267743#hash-function-construction-principles\n    // Wang hash: this has the property that none of the outputs will\n    // collide with each other, which is important for the purposes of\n    // seeding a random number generator.  This was verified empirically\n    // by checking all 2^32 uints.\n    n = (n ^ 61u) ^ (n >> 16);\n    n *= 9u;\n    n = n ^ (n >> 4);\n    n *= 0x27d4eb2du;\n    n = n ^ (n >> 15);\n\n    return n;\n}\n\nuint NextState(uint state) {\n    state ^= state << 13;\n    state ^= state >> 17;\n    state ^= state << 5;\n    return state;\n}\n\nfloat NextFloat(inout uint state) {\n    state = NextState(state);\n    int n = int(state % 1000u);\n    float t = float(n) / 1000.;   \n    return t;\n}\n\nvec3 NextVec3(inout uint state) {\n    float x = NextFloat(state);\n    float y = NextFloat(state);\n    float z = NextFloat(state);\n\n    return vec3(x, y, z);\n}\n\n\n//Convert functions from on https://www.shadertoy.com/view/XddXW7\n\nfloat Convert2DTo1D(vec2 p, vec2 s) {\n    //p = Repeat(p, s);\n    p = mod(p, s);\n    return floor(p.y) * s.x + p.x;\n}\n\nvec2 Convert1DTo2D(float p, vec2 size) {\n    float x = mod(p, size.x);\n    float y = (p - x) / size.x + 0.5;\n    return vec2(x, y);\n}\n\nfloat Convert3DTo1D(vec3 p, vec3 size) {\n    p = mod(p, size);\n    return floor(p.z) * size.x * size.y + floor(p.y) * size.x + p.x;\n}\n\nvec3 Convert1DTo3D(float p, vec3 size) {\n    float x = mod(p, size.x);\n    float y = mod((p - x) / size.x, size.y);\n    float z = (p - x - floor(y) * size.x) / (size.x * size.y);\n    return vec3(x, y + 0.5, z + 0.5);\n}\n\nfloat PeriodicalCellularNoise(vec3 p, float scale, vec3 size) {\n    p *= scale;\n    vec3 mainCell = floor(p);\n\n    float minDist = 999999.;\n\n    for (int x = -1; x <= 1; x++)\n    for (int y = -1; y <= 1; y++)\n    for (int z = -1; z <= 1; z++)\n    {\n        vec3 cellIndex = mainCell + vec3(x, y, z);\n        \n        vec3 repeatCellIndex = Repeat(cellIndex, size * scale);\n        uint seed = uint(5. + repeatCellIndex.x * 11. + repeatCellIndex.y * 17. + repeatCellIndex.z * 13.);\n        uint state = WangHash(seed);\n        \n        vec3 cellPoint = cellIndex + NextVec3(state);\n        vec3 dif = p - cellPoint;\n        float dist = dot(dif,dif);\n        minDist = min(minDist, dist);\n    }\n\n    return sqrt(minDist);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}