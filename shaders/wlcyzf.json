{
    "Shader": {
        "info": {
            "date": "1609612924",
            "description": "Implementation of the light casters described in this LearnOpenGL tutorial: https://learnopengl.com/Lighting/Light-casters",
            "flags": 0,
            "hasliked": 0,
            "id": "wlcyzf",
            "likes": 10,
            "name": "Common Light Casters",
            "published": 3,
            "tags": [
                "3d",
                "lights",
                "cg",
                "lightcasters"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 219
        },
        "renderpass": [
            {
                "code": "const float INV_SQRT_3 = 0.577350269189626;\n\nconst float RADIANS_30 = 0.523598775598299;\nconst float RADIANS_55 = 0.959931088596881;\n\nconst float COS_10 = 0.984807753012208;\nconst float COS_30 = 0.866025403784439;\n\nconst float SIN_25 = 0.422618261740699;\nconst float COS_25 = 0.90630778703665;\n\nstruct Material {\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float gloss;\n};\n\nstruct DirectionalLight {\n    vec3 direction;\n    vec3 color;\n};\n\nstruct PointLight {\n    vec3 position;\n    vec3 color;\n    float Kc; // Constant attenuation term\n    float Kl; // Linear attenuation term\n    float Kq; // Quadratic attenuation term\n};\n\nstruct SpotLight {\n    vec3 position;\n    vec3 direction;\n    vec3 color;\n    float innerCutoff; // Cosine of inner cutoff angle\n    float outerCutoff; // Cosine of outer cutoff angle\n};\n\n// Rather tedious redefinitions but I couldn't find a general way to define them :(\nvec3 shadeDirectional(in vec3 p, in vec3 n, in Material m, in vec3 v, in DirectionalLight l) {\n    vec3 Ia = l.color * m.ambient;\n\n    float diff = max(0.0, dot(n, -l.direction));\n    vec3 Id = l.color * m.diffuse * diff;\n\n    vec3 r = reflect(-l.direction, n);\n    float spec = max(0.0, dot(r, v));\n    spec = min(1.0, pow(spec, m.gloss));\n    vec3 Is = l.color * m.specular * spec;\n\n    return Ia + Id + Is;\n}\n\nvec3 shadePoint(in vec3 p, in vec3 n, in Material m, in vec3 v, in PointLight l) {\n    vec3 Ia = l.color * m.ambient;\n\n    vec3 ld = l.position - p;\n    float d = length(ld);\n    ld /= d;\n\n    float diff = max(0.0, dot(n, ld));\n    vec3 Id = l.color * m.diffuse * diff;\n\n    vec3 r = reflect(ld, n);\n    float spec = max(0.0, dot(r, v));\n    spec = min(1.0, pow(spec, m.gloss));\n    vec3 Is = l.color * m.specular * spec;\n\n    float att = 1.0 / (l.Kc + l.Kl * d + l.Kq * d * d);\n\n    return Ia + (Id + Is) * att;\n}\n\nvec3 shadeSpot(in vec3 p, in vec3 n, in Material m, in vec3 v, in SpotLight l) {\n    vec3 Ia = l.color * m.ambient;\n\n    vec3 ld = l.position - p;\n    float d = length(ld);\n    ld /= d;\n\n    float diff = max(0.0, dot(n, ld));\n    vec3 Id = l.color * m.diffuse * diff;\n\n    vec3 r = reflect(ld, n);\n    float spec = max(0.0, dot(r, v));\n    spec = min(1.0, pow(spec, m.gloss));\n    vec3 Is = l.color * m.specular * spec;\n\n    float theta = dot(-ld, l.direction);\n    float att = clamp((theta - l.outerCutoff) / (l.innerCutoff - l.outerCutoff), 0.0, 1.0);\n\n    return Ia + (Id + Is) * att;\n}\n\nmat2 Rotate(in float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\n// Solid angle SDF Inigo Quilez's 3D distance functions article (https://iquilezles.org/articles/distfunctions):\nfloat sdSolidAngle(vec3 p, in vec2 c, float ra) {\n    vec2 q = vec2(length(p.xz), p.y);\n    float l = length(q) - ra;\n    float m = length(q - c * clamp(dot(q, c), 0.0, ra));\n    return max(l, m * sign(c.y * q.x - c.x * q.y));\n}\n\nfloat mapScene(in vec3 p) {\n    vec3 q = abs(p) - 2.5;\n    float box1 = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n    box1 = max(abs(box1) - 0.05, p.z - 2.0);\n\n    p.xz *= Rotate(RADIANS_30);\n    p -= vec3(0.25, -1.0, -2.0);\n    q = abs(p) - vec3(0.75, 1.5, 0.75);\n    float box2 = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n\n    p -= vec3(0.8, -0.7, 2.0);\n    p.xz *= Rotate(-RADIANS_55);\n    q = abs(p) - 0.8;\n    float box3 = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n\n    p.y -= 1.3;\n    float sphere1 = length(p) - 0.5;\n\n    p -= vec3(-2.0, -1.0, 1.5);\n    float sphere2 = length(p) - 1.0;\n\n    return min(box1, min(box2, min(box3, min(sphere1, sphere2))));\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapScene(p + vec3(0.001, 0.0, 0.0)) - mapScene(p - vec3(0.001, 0.0, 0.0)),\n                          mapScene(p + vec3(0.0, 0.001, 0.0)) - mapScene(p - vec3(0.0, 0.001, 0.0)),\n                          mapScene(p + vec3(0.0, 0.0, 0.001)) - mapScene(p - vec3(0.0, 0.0, 0.001))));\n}\n\n// Soft shadow technique from Inigo Quilez's article on soft shadows (https://iquilezles.org/articles/rmshadows):\nfloat shadowDirectional(in vec3 p, in vec3 n, in float k, in float tmax, in DirectionalLight l) {\n    p += n * 0.002;\n\n    float res = 1.0;\n    float t = 0.0;\n    for(int i=0; i < 50; i++) {\n        float d = mapScene(p - l.direction * t);\n        if (abs(d) < 0.001) {\n            return 0.0;\n        }\n\n        if (t > tmax) {\n            break;\n        }\n\n        res = min(res, k * d / t);\n        t += d;\n    }\n\n    return res;\n}\n\nfloat shadowPoint(in vec3 p, in vec3 n, in float k, in PointLight l) {\n    p += n * 0.002;\n\n    vec3 ld = l.position - p;\n    float dtl = length(ld);\n    ld /= dtl;\n\n    float res = 1.0;\n    float t = 0.0;\n    for(int i=0; i < 50; i++) {\n        float d = mapScene(p + ld * t) * 0.994; // ?\n        if (abs(d) < 0.001) {\n            return 0.0;\n        }\n\n        if (t > dtl) {\n            break;\n        }\n\n        res = min(res, k * d / t);\n        t += d;\n    }\n\n    return res;\n}\n\nfloat shadowSpot(in vec3 p, in vec3 n, in float k, in SpotLight l) {\n    p += n * 0.002;\n\n    vec3 ld = l.position - p;\n    float dtl = length(ld);\n    ld /= dtl;\n\n    float res = 1.0;\n    float t = 0.0;\n    for(int i=0; i < 50; i++) {\n        float d = mapScene(p + ld * t);\n        if(abs(d) < 0.001) {\n            return 0.0;\n        }\n\n        if (t > dtl - 0.3) { // ?\n            break;\n        }\n\n        res = min(res, k * d / t);\n        t += d;\n    }\n\n    return res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    Material sceneMaterial = Material(vec3(0.0, 0.0, 0.0),\n                                      vec3(0.5, 0.5, 0.5),\n                                      vec3(0.5, 0.5, 0.5), 4.0);\n\n    DirectionalLight light1 = DirectionalLight(vec3(INV_SQRT_3, -INV_SQRT_3, -INV_SQRT_3),\n                                               vec3(0.45, 0.45, 0.75));\n\n    PointLight light2 = PointLight(vec3(0.3, -0.725, -0.2),\n                                   vec3(1.0, 0.8, 0.0), 1.0, 0.0, 0.06);\n\n    float sec = fract(iTime * 0.5);\n    light2.position.y += 8.0 * (sec - sec * sec);\n\n    SpotLight light3 = SpotLight(vec3(0.0, 2.4, 0.0),\n                                 vec3(INV_SQRT_3, -INV_SQRT_3, INV_SQRT_3),\n                                 vec3(1.0, 0.0, 1.0), COS_10, COS_30);\n\n    light3.direction.xz *= Rotate(iTime);\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    vec3 p, n;\n    float t = 0.0, d;\n    bool hit = false;\n    for (int i=0; i < 150; i++) {\n        p = ro + rd * t;\n        d = mapScene(p);\n        if (abs(d) < 0.001) {\n            hit = true;\n            break;\n        }\n\n        vec3 lp1 = p - light2.position;\n        float ld1 = length(lp1) - 0.175;\n\n        vec3 lp2 = p - light3.position;\n        lp2.zx *= Rotate(atan(light3.direction.z, light3.direction.x));\n        lp2.yx *= Rotate(atan(light3.direction.y, length(light3.direction.xz)) - 1.570796326794897);\n\n        float ld2 = sdSolidAngle(lp2, vec2(SIN_25, COS_25), 0.3);\n\n        if (ld1 < 0.001) {\n            fragColor.rgb = light2.color;\n        }\n\n        if (ld2 < 0.001) {\n            fragColor.rgb = light3.color;\n        }\n\n        if (t > 20.0) {\n            break;\n        }\n\n        t += min(d, min(ld1, ld2));\n    }\n\n    if (hit) {\n        n = getNormal(p);\n\n        //float s1 = shadowDirectional(p, n, 64.0, 15.0, light1);\n        fragColor.rgb += shadeDirectional(p, n, sceneMaterial, rd, light1);// * s1;\n\n        float s2 = shadowPoint(p, n, 64.0, light2);\n        fragColor.rgb += shadePoint(p, n, sceneMaterial, rd, light2) * s2;\n\n        vec3 spotIllum = shadeSpot(p, n, sceneMaterial, rd, light3);\n        if (max(spotIllum.r, max(spotIllum.g, spotIllum.b)) > 0.0) {\n            float s3 = shadowSpot(p, n, 64.0, light3);\n            spotIllum *= s3;\n        }\n\n        fragColor.rgb += spotIllum;\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}