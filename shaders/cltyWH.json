{
    "Shader": {
        "info": {
            "date": "1699142159",
            "description": "Need an N-element analogue of \"mix\"?  Or, a soft version of \"max\"?  Here's softmaxmix! 2, 3, and 4 dimensional impls included. Alt. impls with handling of all-zero weights. indecision measures how \"confused\" softmaxmix is (click to viz)",
            "flags": 0,
            "hasliked": 0,
            "id": "cltyWH",
            "likes": 3,
            "name": "SoftMax-based Blending/Mixing",
            "published": 3,
            "tags": [
                "blending",
                "entropy",
                "mixing",
                "softmax"
            ],
            "usePreview": 0,
            "username": "kp1197",
            "viewed": 143
        },
        "renderpass": [
            {
                "code": "// visualization colors\n#define A_ texture(iChannel0, p).rgb\n#define B_ texture(iChannel1, p).rgb\n#define C_ texture(iChannel2, p).rgb\n#define D_ texture(iChannel3, p).rgb\n#define NULL_COLOR vec3(0.)\n#define PI 3.14159\n\n\n// concentration parameter - higher value results in less material 'bleeding'\n// if your weights are between 0.0 and 1.0 you shouldn't need to adjust\nconst float K = 80.;\n\n// if weights are between 0.0 and 1.0 you shouldn't need to adjust\nconst float NULL_WEIGHT = 5.;\n\n\n// mix between A and B by picking the max weight in `vec2 materials`, but a 'soft max' instead of max(...)\nvec3 softmaxmix_2(vec2 materials, vec3 A, vec3 B) {\n    vec2 softmaxed_materials = exp(K * materials) / dot(exp(K * materials),vec2(1.));\n    return softmaxed_materials.x * A + softmaxed_materials.y * B;\n}\n\n\n// implementation of softmax_mix_2 that falls back on a NULL material when all material influences are zero\nvec3 softmaxmix_2_(vec2 materials, vec3 A, vec3 B, vec3 NULL) {\n    vec3 mat_prime = vec3(K*materials.x, K*materials.y, NULL_WEIGHT);\n    vec3 softmaxed_materials = exp(mat_prime) / dot(exp(mat_prime),vec3(1.));\n    return softmaxed_materials.x * A + \n            softmaxed_materials.y * B +\n            softmaxed_materials.z * NULL;\n}\n\n// mixes between A, B and C by picking the max weight in `vec3 materials`, but a 'soft max' instead of max(...)\nvec3 softmaxmix_3(vec3 materials, vec3 A, vec3 B, vec3 C) {\n    vec3 softmaxed_materials = exp(K * materials) / dot(exp(K * materials),vec3(1.));\n    return softmaxed_materials.x * A + softmaxed_materials.y * B + softmaxed_materials.z * C;\n}\n\n// implementation of softmax_mix_3 that includes a NULL material when all material influences are zero\nvec3 softmaxmix_3_(vec3 materials, vec3 A, vec3 B, vec3 C, vec3 NULL) {\n    vec4 mat_prime = vec4(K*materials.x, K*materials.y, K*materials.z, NULL_WEIGHT);\n    vec4 softmaxed_materials = exp(mat_prime) / dot(exp(mat_prime),vec4(1.));\n    return softmaxed_materials.x * A + \n            softmaxed_materials.y * B +\n            softmaxed_materials.z * C + \n            softmaxed_materials.w * NULL;\n}\n\n// mixes between A, B, C and D by picking the max weight in `vec4 materials`, but a 'soft max' instead of max(...)\nvec3 softmaxmix_4(vec4 materials, vec3 A, vec3 B, vec3 C, vec3 D) {\n\tvec4 softmaxed_materials = exp(K * materials) / dot(exp(K * materials), vec4(1.));\n    return softmaxed_materials.x * A + softmaxed_materials.y * B + softmaxed_materials.z * C + softmaxed_materials.w * D;\n}\n\n// mixes between A, B, C and D by picking the max weight in `vec4 materials`, but a 'soft max' instead of max(...)\nvec3 softmaxmix_4_(vec4 materials, vec3 A, vec3 B, vec3 C, vec3 D, vec3 NULL) {\n\tfloat softmaxDenominator = exp(K * materials.x) + \n        exp(K * materials.y) + \n        exp(K * materials.z) + \n        exp(K * materials.w) + \n        exp(NULL_WEIGHT);\n\tfloat sm_a = exp(K * materials.x) / softmaxDenominator;\n\tfloat sm_b = exp(K * materials.y) / softmaxDenominator;\n\tfloat sm_c = exp(K * materials.z) / softmaxDenominator;\n\tfloat sm_d = exp(K * materials.w) / softmaxDenominator;\n\tfloat sm_null = exp(NULL_WEIGHT) / softmaxDenominator;\n    return sm_a * A + sm_b * B + sm_c * C + sm_d * D + sm_null * NULL;\n}\n\n// returns number indicating how 'unsure' the softmax is... i.e., if two infleunces are tied.\n// can work like a boundary detector.\nfloat indecision_2(vec2 materials) {\n    // softmax to turn weights/influences into a probability distribution\n    vec2 softmaxedMaterials = exp(K * materials) / dot(exp(K * materials), vec2(1.));\n    // normalized entropy: -sum_N(p * log(p)) / -log(1/N)\n    float normalized_entropy = dot(softmaxedMaterials, log(softmaxedMaterials)) / log(1./2.);\n\treturn normalized_entropy;\n}\n\n// implementation that falls back to a 'null material' when all weights are zero\nfloat indecision_2_(vec2 materials) {\n    // augment list of materials with the null material (meaning no material assigned)\n    vec3 mat_prime = vec3(K * materials.x, K * materials.y, NULL_WEIGHT);\n    // softmax to turn weights/influences into a probability distribution\n    vec3 softmaxedMaterials = exp(mat_prime) / dot(exp(mat_prime), vec3(1.));\n    // normalized entropy: -sum_N(p * log(p)) / -log(1/N)\n    float normalized_entropy = dot(softmaxedMaterials, log(softmaxedMaterials)) / log(1./3.);\n\treturn normalized_entropy;\n}\n\n\nfloat indecision_3(vec3 materials) {\n    // softmax to turn weights/influences into a probability distribution\n    vec3 softmaxedMaterials = exp(K * materials) / dot(exp(K * materials),vec3(1.));\n    // normalized entropy: -sum_N(p * log(p)) / -log(1/N)\n    float normalized_entropy = dot(softmaxedMaterials, log(softmaxedMaterials)) / log(1./3.);\n\treturn normalized_entropy;\n}\n\n\n// implementation that falls back to a 'null material' when all weights are zero\nfloat indecision_3_(vec3 materials) {\n    // augment list of materials with the null material (meaning no material assigned)\n    vec4 mat_prime = vec4(K * materials.x, K * materials.y, K * materials.z, NULL_WEIGHT);\n    // softmax to turn weights/influences into a probability distribution\n    vec4 softmaxedMaterials = exp(mat_prime) / dot(exp(mat_prime),vec4(1.));\n    // normalized entropy: -sum_N(p * log(p)) / -log(1/N)\n    float normalized_entropy = dot(softmaxedMaterials, log(softmaxedMaterials)) / log(1./4.);\n\treturn normalized_entropy;\n}\n\n\nfloat indecision_4(vec4 materials) {\n    // augment list of materials with the null material (meaning no material assigned)\n\tvec4 softmaxed_materials = exp(materials) / dot(exp(materials),vec4(1.));\n    // normalized entropy: -sum_N(p * log(p)) / -log(1/N)\n    float normalized_entropy = dot(softmaxed_materials, log(softmaxed_materials)) / log(1./4.);\n    return normalized_entropy;\n}\n\nfloat indecision_4_(vec4 materials) {\n    // augment list of materials with the null material (meaning no material assigned)\n\tfloat softmaxDenominator = exp(K * materials.x) + exp(K * materials.y) + exp(K * materials.z) + exp(K * materials.w) + exp(NULL_WEIGHT);\n\tfloat sm_a = exp(K * materials.x) / softmaxDenominator;\n\tfloat sm_b = exp(K * materials.y) / softmaxDenominator;\n\tfloat sm_c = exp(K * materials.z) / softmaxDenominator;\n\tfloat sm_d = exp(K * materials.w) / softmaxDenominator;\n\tfloat sm_null = exp(NULL_WEIGHT) / softmaxDenominator;\n    // normalized entropy: -sum_N(p * log(p)) / -log(1/N)\n    float normalized_entropy = (sm_a * log(sm_a) +\n\t\t\t\t\t sm_b * log(sm_b) +\n\t\t\t\t\t sm_c * log(sm_c) +\n\t\t\t\t\t sm_d * log(sm_d) +\n\t\t\t\t\t sm_null * log(sm_null)) / log(1./5.);\n    return normalized_entropy;\n}\n\n\n// https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat circle_a(vec2 p) {\n    float animate = 0.1 * abs(sin(iTime));\n\treturn smoothstep(-0.3, 0., -length(p - vec2(-0.15, -0.15) ));\n}\n\nfloat circle_b(vec2 p) {\n\treturn smoothstep(-0.3, 0., -length(p - vec2(0.0, 0.15) ));\n}\n\nfloat circle_c(vec2 p) {\n\treturn smoothstep(-0.3, 0., -length(p - vec2(0.15, -0.15) ));\n}\n\nfloat circle_d(vec2 p) {\n\treturn smoothstep(-0.3, 0., -length(p - vec2(0.0, 0.30)));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t\n\tvec2 p  = 2. * (fragCoord.xy/iResolution.xx - 0.5 * vec2(1.,iResolution.y/iResolution.x));\n\t\n\t// circles\n\tfloat a = 0.5*(circle_a(p));\n\tfloat b = 0.5*(circle_b(p));\n\tfloat c = 0.5*(circle_c(p));\n    float d = 0.5*(circle_d(p));\n\n    \n    // softmax blend\n    vec3 blend = softmaxmix_3_(vec3(a,b,c),A_,B_,C_,NULL_COLOR);\n    \n    // indecision / softmax boundaries\n    vec3 boundary = vec3(indecision_3_(vec3(a,b,c)));\n    \n    float swipe = mix(sin(iTime), 2.*(iMouse.x/iResolution.x - 0.5), float(iMouse.z > 0.));\n    \n    vec3 scene = mix(blend, boundary, smoothstep(swipe-0.05, swipe+0.05, p.x));\n    fragColor.rgb = scene;\n    fragColor.rgb += smoothstep(-0.01,0.0,-abs(p.x-swipe));\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}