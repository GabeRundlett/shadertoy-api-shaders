{
    "Shader": {
        "info": {
            "date": "1571055166",
            "description": "Inspired by stock image: https://www.shutterstock.com/pl/image-illustration/abstract-technological-background-made-different-shapes-310502144\n\n//License: CC BY 3.0\n//Author: Jan Mr√≥z (jaszunio15)",
            "flags": 32,
            "hasliked": 0,
            "id": "WsG3D3",
            "likes": 150,
            "name": "Futuristic 3D circle",
            "published": 3,
            "tags": [
                "3d",
                "circle",
                "ui",
                "neon",
                "futuristic"
            ],
            "usePreview": 1,
            "username": "jaszunio15",
            "viewed": 4197
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = blur(iChannel0, fragCoord, iResolution.xy);\n    col = smoothstep(-0.2, 0.7, col);\n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.14\n#define TWO_PI 6.28\n\n#define TIMESCALE 0.5\n\n#define BLUR_STRENGTH 2.0\n#define BLUR_RANGE 2.7\n\n#define UI_COLOR vec4(0.5, 0.8, 1.0, 1.0)\n\nfloat hash12(vec2 x)\n{\n \treturn fract(sin(dot(x, vec2(43.5287, 41.12871))) * 523.582);   \n}\n\nvec2 hash21(float x)\n{\n \treturn fract(sin(x * vec2(24.0181, 52.1984)) * 5081.4972);   \n}\n\nfloat hash11(float x)\n{\n \treturn fract(sin(x * 42.146291) * 4215.4827);   \n}\n\nvec2 hash22(vec2 x)\n{\n \treturn fract(sin(x * mat2x2(24.4372, 12.47864, 32.3874, 29.4873)) * 4762.832);  \n}\n\nmat2x2 rotationMatrix(in float angle)\n{\n \treturn mat2x2(-cos(angle), sin(angle), -sin(angle), -cos(angle));   \n}\n\n//Blur function\nvec4 blur(in sampler2D sampler, in vec2 fragCoord, in vec2 resolution)\n{\n    vec2 uv = fragCoord / resolution;\n    float blurStrength = distance(uv, vec2(0.5));\n    blurStrength = pow(blurStrength, BLUR_RANGE) * (resolution.x / 100.0) * BLUR_STRENGTH;\n    vec4 sum = vec4(0.0);\n    vec2 pixelSize = vec2(1.0) / resolution;\n\tfor (float x = -1.0; x <= 1.0; x += 1.0)\n    {\n     \tfor (float y = -1.0; y <= 1.0; y += 1.0)\n        {\n            sum += texture(sampler, uv + vec2(x, y) * pixelSize * blurStrength);\n        }\n    }\n\n    return sum / 9.0;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "float circle(in vec2 uv, in float radius, in float width)\n{\n    return smoothstep(width, width * 0.5, abs(radius - length(uv)));\n}\n\nfloat softCircle(in vec2 uv, in float radius, in float width)\n{\n    return smoothstep(width, 0.0, abs(radius - length(uv)));\n}\n\nfloat hardCircle(in vec2 uv, in float radius, in float width)\n{\n \treturn smoothstep(width, width * 0.99, abs(radius - length(uv)));   \n}\n\nfloat dottedCircle(in vec2 uv, in float circleRadius, in float dotRadius, float dotsCount)\n{\n \tfloat angle = atan(uv.y, uv.x);\n    angle /= TWO_PI;\n    angle += 0.5;\n    angle = round(angle * dotsCount) / dotsCount;\n    angle *= TWO_PI;\n    //angle *= round(angle / TWO_PI * dotsCount) * TWO_PI;\n    vec2 dotPoint = vec2(circleRadius, 0.0) * rotationMatrix(angle);\n    return smoothstep(dotRadius, dotRadius * 0.5, distance(dotPoint, uv));\n    \n    return angle;\n}\n\nfloat circularSector(vec2 uv, in float radius, in float width, in float cutAngle)\n{\n    float angle = atan(uv.y, uv.x) + PI;\n    float circ = circle(uv, radius, width);\n    return circ * smoothstep(cutAngle, cutAngle - 0.001, abs(angle - cutAngle));\n}\n\nfloat cutSector(in vec2 uv, in float cutAngle, in float offset)\n{\n \tfloat angle = atan(uv.y, uv.x) + PI + offset;\n    angle = mod(angle, TWO_PI);\n    return smoothstep(cutAngle, cutAngle - 0.0001, abs(angle - cutAngle));\n}\n\nfloat dashedCircle(vec2 uv, in float radius, in float width, in float density)\n{\n \tfloat angle = atan(uv.y, uv.x) + PI;\n    angle /= TWO_PI;\n    angle = fract(angle * density);\n    float circ = circle(uv, radius, width);\n    return circ * smoothstep(0.1, 0.11, abs(angle - 0.5));\n}\n\nfloat dottedGrid(vec2 uv, in vec2 gridSpaces, float dotRadius)\n{\n \tuv = mod(uv, gridSpaces) - gridSpaces * 0.5;\n    return smoothstep(dotRadius, 0.0, abs(length(uv) - dotRadius));\n}\n\nfloat lineGrid(vec2 uv, in vec2 gridSpaces, float lineWidth)\n{\n    uv = mod(uv, gridSpaces) - gridSpaces * 0.5;\n    float verticalLines = smoothstep(lineWidth, lineWidth * 0.5, abs(uv.x - lineWidth));\n    float horizontalLines = smoothstep(lineWidth, lineWidth * 0.5, abs(uv.y - lineWidth));\n    return verticalLines + horizontalLines;\n}\n\nfloat writings(vec2 uv, in float linesCount, in float maxLen, in float height, in float hash)\n{\n    float mul = \n        smoothstep(0.0, 0.01, uv.x) \n        * smoothstep(0.0, 0.01, uv.y)\n        * smoothstep(height, height - 0.001, uv.y);\n    \n    uv.y = clamp(uv.y, 0.0, height);\n    uv.y *= linesCount;\n    float len = hash11(floor(uv.y - linesCount) + hash) * maxLen;\n    return smoothstep(len, len * 0.5, uv.x) * hash12(uv) * mul * fract(uv.y);\n}\n\nfloat writingsGrid(vec2 uv, in vec2 gridSpace, in float scale)\n{\n \tuv /= gridSpace;\n    vec2 floorUV = floor(uv);\n    vec2 fractUV = fract(uv);\n    \n    fractUV -= hash22(floorUV) * (1.0 - (1.0 / scale)) * (sin(iTime * 0.6 * TIMESCALE + hash12(floorUV) * 12.0) * 0.5 + 0.5);\n    fractUV *= scale;\n    \n    float writing = writings(fractUV, 10.0 * hash12(floorUV) + 5.0, 1.0, hash12(floorUV + 0.1) * 0.6, 1.0);\n    \n    return writing;\n}\n\n\nvec3 uvToCameraPlanePoint(in vec2 uv)\n{\n \treturn vec3(uv.x, uv.y, 1.5 + sin(iTime * TIMESCALE * 0.3) * 0.2);   \n}\n\n//xy - plane uv\n//z - plane height\n//w - distance to plane\nvec4 raycastPlane(in vec3 rayOrigin, vec3 rayDirection, in float planeHeight)\n{\n \tfloat distanceToPlane = abs(rayOrigin.y - planeHeight);   \n    rayDirection /= rayDirection.y;\n    rayDirection *= distanceToPlane;\n    vec3 hitPoint = rayOrigin + rayDirection;\n    \n    return vec4(hitPoint.x, hitPoint.z, hitPoint.y, length(rayDirection));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.x;\n    float time = iTime * TIMESCALE;\n    float angleTime = iTime * 0.5 * TIMESCALE;\n    \n    float angleY = -time;\n    float angleX = -0.8 + sin(angleTime) * 0.3;\n    float angleZ = cos(time * 0.72) * 0.2;\n    mat3 rotation =\t  mat3(-cos(angleZ),  sin(angleZ), 0,\n                           -sin(angleZ), -cos(angleZ), 0,\n                           0, \t\t\t 0, \t\t  1)\n        \t\t\t* mat3(1, 0, \t\t\t0,\n                           0, -cos(angleX),  sin(angleX),\n                           0, -sin(angleX), -cos(angleX))\n        \t\t\t* mat3(-cos(angleY),  0, sin(angleY),\n                           0, \t\t\t 1, 0,\n                           -sin(angleY), 0, -cos(angleY));\n    \n    vec3 cameraPosition = vec3(sin(time), -3.1 - sin(angleTime) * 0.2, cos(time));\n    cameraPosition.xz *= 0.9 + sin(angleTime) * 0.4;\n    vec3 castPlanePoint = uvToCameraPlanePoint(uv);\n    castPlanePoint = castPlanePoint * rotation;\n    castPlanePoint += cameraPosition;\n    vec3 rayOrigin = vec3(cameraPosition);\n    vec3 rayDirection = normalize(castPlanePoint - cameraPosition);\n\n\tvec4 hitPoint = raycastPlane(rayOrigin, rayDirection, -4.0);\n    float dist = hitPoint.w;\n    float fog = smoothstep(5.0, 0.0, dist);\n    float dots = dottedGrid(hitPoint.xy, vec2(0.03), 0.001);\n    dots += hardCircle(hitPoint.xy, 0.3, 0.07 + 0.03 * sin(time * 0.6)) * cutSector(hitPoint.xy, 1.5 + cos(time * 0.4) * 2.0, time * 2.0) * 0.4;\n    \n    hitPoint = raycastPlane(rayOrigin, rayDirection, -4.02);\n    float lines = lineGrid(hitPoint.xy, vec2(0.4), 0.001) * 0.5;\n    lines += hardCircle(hitPoint.xy, 0.12, 0.02 + 0.01 * -sin(time * 0.6 + 2.0)) * cutSector(hitPoint.xy, 1.5 + cos(time * 1.4) * 2.0, -time * 0.8) * 0.4;\n    \n    hitPoint = raycastPlane(rayOrigin, rayDirection, -3.98);\n    float lines2 = lineGrid(hitPoint.xy + 0.14, vec2(0.8), 0.002) * 0.4;\n    \n    hitPoint = raycastPlane(rayOrigin, rayDirection, -3.97);\n    float dotCircle = dottedCircle(hitPoint.xy, 0.5, 0.003, 200.0) + dottedCircle(hitPoint.xy, 0.5, 0.006, 20.0) * cutSector(hitPoint.xy, 2.3, time * 4.0);\n    \n    hitPoint = raycastPlane(rayOrigin, rayDirection, -3.9);\n    float circle1 = circle(hitPoint.xy, 0.6, 0.003) * 0.4 + 0.4 * (dottedCircle(hitPoint.xy, 0.61, 0.003, 300.0) + dottedCircle(hitPoint.xy, 0.61, 0.006, 30.0)) * cutSector(hitPoint.xy, 1.0, -iTime * 0.1);\n    \n    hitPoint = raycastPlane(rayOrigin, rayDirection, -3.94);\n    float circle2 = circle(hitPoint.xy, 0.45, 0.003) * 0.3 + 0.3 * dottedCircle(hitPoint.xy, 0.46, 0.004, 250.0);\n        \n    hitPoint = raycastPlane(rayOrigin, rayDirection, -3.88);\n    float circle3 = circle(hitPoint.xy, 0.42, 0.003) * 0.4 + dottedCircle(hitPoint.xy, 0.42, 0.005, 20.0) * 0.8 * cutSector(hitPoint.xy, 1.0, time * 2.0);\n    \n    hitPoint = raycastPlane(rayOrigin, rayDirection, -3.8);\n    float circle4 = dashedCircle(hitPoint.xy, 0.38, 0.006, 10.0) * 0.8 * cutSector(hitPoint.xy, 1.0, -time * 0.6);\n   \tcircle4 += dashedCircle(hitPoint.xy, 0.3, 0.0045, 2.5 + sin(time * 2.0)) * cutSector(hitPoint.xy, 2.0, time * 0.28) * 0.7;\n     \n    hitPoint = raycastPlane(rayOrigin, rayDirection, -3.84);\n    float circle5 = circle(hitPoint.xy, 0.15, 0.003) * 0.4 + dottedCircle(hitPoint.xy, 0.2, 0.003, 100.0) * 0.8 * cutSector(hitPoint.xy, 0.5, cos(time * 0.2) * 10.0);\n    \n    hitPoint = raycastPlane(rayOrigin, rayDirection, -3.8);\n    circle5 += circle(hitPoint.xy, 0.1, 0.003) * 0.4 + dottedCircle(hitPoint.xy, 0.2, 0.003, 100.0) * 0.8 * cutSector(hitPoint.xy, 1.0, sin(time * 0.2 + 2.0) * 10.0);\n    \n    hitPoint = raycastPlane(rayOrigin, rayDirection, -4.0);\n    float writingGrid = writingsGrid(hitPoint.xy + time * 0.02, vec2(0.6, 0.6), 6.0);\n    \n    hitPoint = raycastPlane(rayOrigin, rayDirection, -3.8);\n    writingGrid += writingsGrid(hitPoint.xy - time * 0.02 + 20.0, vec2(1.0, 1.0), 6.0);\n    \n    hitPoint = raycastPlane(rayOrigin, rayDirection, -3.85);\n    float circle6 = circle(hitPoint.xy, 0.05, 0.0025) * 0.6 * cutSector(hitPoint.xy, 2.5 + sin(time * 0.67) * 0.5, time * 2.0); \n   \n        \n    float UIMerge = writingGrid + dots + lines + lines2 + dotCircle + circle1 + circle2 + circle3 + circle4 + circle5 + circle6;\n    UIMerge *= fog;\n    \n    \n    // Output to screen\n    fragColor = UI_COLOR * UIMerge;\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = blur(iChannel0, fragCoord, iResolution.xy);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = blur(iChannel0, fragCoord, iResolution.xy);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = blur(iChannel0, fragCoord, iResolution.xy);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}