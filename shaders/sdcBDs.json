{
    "Shader": {
        "info": {
            "date": "1657440549",
            "description": "Flying through a city using simple raycasting.\nThis is one of my favorite shaders that I added dithered motion blur to.\nUse the mouse button to turn off the motion blur.",
            "flags": 0,
            "hasliked": 0,
            "id": "sdcBDs",
            "likes": 40,
            "name": "City Flight (with motion blur)",
            "published": 3,
            "tags": [
                "raytracing",
                "sky",
                "city",
                "buildings"
            ],
            "usePreview": 0,
            "username": "GregRostami",
            "viewed": 979
        },
        "renderpass": [
            {
                "code": "// Fork of \"City Flight\" by athibaul. https://shadertoy.com/view/WstcRf\n// 2022-07-10 08:07:51\n\n// -----------\n// CITY FLIGHT\n// -----------\n// by Alexis THIBAULT\n//\n// Flying through a city using simple raymarching\n\n\n// This shader was inspired by the Disney Animation paper:\n//\n// Norman Moses Joseph, Brett Achorn, Sean D. Jenkins, and Hank Driskill.\n// Visualizing Building Interiors using Virtual Windows.\n// In ACM SIGGRAPH Asia 2014 Technical Briefs, December 2014.\n\n\n// Stuff that uses similar ideas\n// (marching a regular grid by raytracing the boxes, and\n//  putting stuff inside)\n//\n// \"Cubescape\" by iq\n// https://www.shadertoy.com/view/Msl3Rr\n\n\n// Update - adjusted the max number of iterations: it runs even faster now!\n//        - Use the \"volume\" noise texture instead of the 2D one in hash()\n//            (which is much more logical).\n//        - Added stars in the sky!\n\n\n// Should the windows be flashing?\n\n//Added motion blur with this line, and the \"Blue Noise\" texture in iChannel3:\n#define iTim (iTime + (iMouse.z>0. ? 0. : texelFetch(iChannel3,ivec2(fragCoord)%1024,0).r * iTimeDelta))\n\n#define PARTY_MODE 0\n\n\nvec2 boxIntersect(vec3 ro, vec3 rd, vec3 r, out vec3 normal, out vec3 normal2)\n{\n    // Compute intersection time t of ray ro+t*rd\n    // with a box of half-size r centered at 0.\n    ro *= sign(rd);\n    vec3 t1 = (-r-ro)/abs(rd);\n    vec3 t2 = (r-ro)/abs(rd);\n    float tmin = max(t1.x, max(t1.y, t1.z));\n    float tmax = min(t2.x, min(t2.y, t2.z));\n    normal = -sign(rd) * step(t1.yzx,t1.xyz) * step(t1.zxy, t1.xyz);\n    normal2 = -sign(rd) * step(t2.xyz,t2.yzx) * step(t2.xyz, t2.zxy);\n    if(tmax < tmin) return vec2(-1.);\n    return vec2(tmin, tmax);\n}\n\nvec3 hash(vec3 p)\n{\n    return textureLod(iChannel0, (floor(p)+0.5)*(1./32.), 0.).xyz;\n}\n\n#if 0\nvec3 sun = normalize(vec3(1.0, 1., 0.2));\nvec3 sunCol = vec3(1.,0.5,0.2);\nvec3 skyCol = vec3(0.4,0.65,1.0);\nvec3 horizonCol = vec3(0.6,0.7,0.8);\n#else\nvec3 sun = normalize(vec3(1.0, 1., 0.2));\nvec3 skyCol = vec3(0.01,0.02,0.07);\nvec3 horizonCol = vec3(0.002,0.005,0.02);\n#endif\n\nconst float T_MAX = 1000.;\nconst float FLOOR = -80.;\nconst float HEIGHT = 20.;\nconst vec3 blockSize = vec3(5.,5.,1000.);\n\nvec3 skyColor(vec3 rd)\n{\n    #if 0\n    vec3 col = skyCol;\n    vec3 horiz = mix(horizonCol, 2.5*sunCol, smoothstep(-1.,1.,dot(rd,sun)));\n    float horizHeight = 0.1*exp(-2.*(1.3-dot(sun, rd)));\n    col = mix(col, horiz, exp(-max(rd.z,0.)/horizHeight));\n    col *= exp(min(rd.z,0.)*15.);\n    #else\n    vec3 col = skyCol;\n    float horizHeight = 0.1;\n    col = mix(col, horizonCol, exp(-max(rd.z,0.)/horizHeight));\n    col *= exp(min(rd.z,0.)*15.);\n    #endif\n    return col;\n}\n\nvoid getCurrentBuilding(vec3 ro, out vec3 boxC,\n                        out vec3 buildingC, out vec3 buildingSize)\n{\n    boxC = 2.*blockSize*round(ro/(2.*blockSize));\n    buildingC = vec3(boxC.xy, -2.*HEIGHT) + vec3(2.,2.,0.)*(2.*hash(boxC.zxy)-1.);\n    vec2 maxSize = 4.5-abs(buildingC.xy-boxC.xy);\n    buildingSize = vec3(1,1,2.*HEIGHT) + vec3(maxSize.xy-1.,13.)*hash(boxC.yzx);\n}\n\n\nfloat sceneIntersect(vec3 ro, vec3 rd, out vec3 normal)\n{\n    float t = 0.;\n    float t0 = 0.;\n    vec3 boxC = vec3(0);\n    int i;\n    vec3 p;\n    const int ITER = 40;\n    vec3 buildingC, buildingSize;\n    vec3 _; // Dummy variable\n    for(i=0; i<ITER; i++)\n    {\n        // Intersect building in current box\n        getCurrentBuilding(ro, boxC, buildingC, buildingSize);\n    \tt = boxIntersect(ro-buildingC,\n                         rd, buildingSize, normal, _).x;\n        \n        // Intersect current box itself\n        float t1 = boxIntersect(ro-boxC, rd, blockSize, _, _).y;\n        \n        // Also intersect a floor plane and a sky plane\n        float tfloor = -(ro.z-FLOOR)/rd.z;\n        if(tfloor < 0.) tfloor = 1e5;\n        float tsky = -(ro.z - 20.)/rd.z;\n        if(tsky < 0.) tsky = 1e5;\n        \n        if(t > 0. && t < t1 && t < tfloor)\n        {\n            // We hit the building!\n        \t//p = ro+t*rd;\n            return t0+t;\n            break;\n        }\n        else if(tfloor > 0. && tfloor < t1)\n        {\n            // We hit the floor!\n            //p = ro+tfloor*rd;\n            return T_MAX;\n            normal = vec3(0,0,1);\n            return t0+tfloor;\n        }\n        else if(tsky > 0. && tsky < t1)\n        {\n            // We hit the ceiling!\n            return T_MAX;\n        }\n        // We hit nothing : march to the next cell\n        ro += (t1+0.001)*rd;\n        t0 += t1;\n        p = ro+t1*rd;\n        continue;\n    }\n    return T_MAX;\n}\n\nvoid getRoom(vec3 p, vec3 rd, out vec3 roomSize, out vec3 roomCenter,\n            out vec3 roomHash)\n{\n    \n    vec3 boxC, buildingC, buildingSize;\n    getCurrentBuilding(p, boxC, buildingC, buildingSize);\n\n    roomSize = buildingSize/(2.*round(buildingSize)+1.);\n    roomCenter = round((p-buildingC)/(2.*roomSize) + 0.1*rd)*2.*roomSize + buildingC;\n    roomHash = hash(roomCenter*10.);\n}\n\nvec3 someNoise(vec3 p)\n{\n    p *= 10.;\n    vec3 v = hash(p)*0.5;\n    p.xyz = p.yzx*1.62;\n    v += hash(p)*0.25;\n    p.xyz = p.yzx*1.62;\n    v += hash(p)*0.125;\n    return v;\n}\n\n\nvec3 computeEmission(vec3 p, vec3 rd, float t, vec3 normal,\n                    out float isInWindow)\n{\n\n    // Window emission depends on the ray direction...\n    // because we actually look at what's inside the room!\n    vec3 roomSize, roomCenter, roomHash;\n    getRoom(p, rd, roomSize, roomCenter, roomHash);\n    vec3 roomHash2 = hash(roomCenter.yzx);\n    vec3 q = abs(p-roomCenter);\n    vec3 inNormal, _;\n    vec2 inT = boxIntersect(p-roomCenter, rd, roomSize, _, inNormal);\n    vec3 roomP = p+inT.y*rd;\n    \n    float border = 0.1;\n    float muntins = roomHash2.z > 0.5 ? 0.01 : -0.1;\n    float w = t/(iResolution.y*dot(normal,-rd)); // A little anti-aliasing\n    isInWindow = (smoothstep(q.x-w, q.x+w, roomSize.x-border) * smoothstep(q.x+w, q.x-w, muntins)\n                + smoothstep(q.y-w, q.y+w, roomSize.y-border) * smoothstep(q.y+w, q.y-w, muntins))\n       \t\t    * smoothstep(q.z-w, q.z+w, roomSize.z-border) * smoothstep(q.z+w, q.z-w, muntins)\n                * step(-0.5,-normal.z);\n\n    #if PARTY_MODE\n    float thresh = 0.8 + 0.1*sin(6.28*iTim+6.28*roomHash.r);\n    float thresh2 = 0.85 + 0.05*sin(6.28*iTim+6.28*roomHash.g);\n    #else\n    float thresh=0.8, thresh2=0.85;\n    #endif\n    vec3 emission = vec3(1.,0.7,0.5)*smoothstep(thresh-0.1,thresh+0.2,roomHash.g)\n        + vec3(0.5,0.8,1.)*0.8*smoothstep(thresh2-0.1,thresh2+0.1,roomHash.b);\n    emission *= emission*3.0;\n\n    //emission = 0.5+0.5*inNormal;\n    //emission = (roomCenter - (ro+inT.y*rd));\n    vec3 noise = someNoise(roomP);\n    vec3 randomColor = mix(roomHash2, 1.-roomHash2.yzx, smoothstep(roomHash.x, roomHash.y,noise.rrr));\n    vec3 wallColor = dot(inNormal, 2.*roomHash-1.) > 0. ? vec3(1.0) : randomColor;\n    if(inNormal.z > 0.9)\n    {\n        // Floor is same color as the light, with some pattern\n        wallColor = emission*0.3;\n        vec3 floorP = roomHash2.y > 0.5 \n            ? vec3(roomP.x+roomP.y,roomP.x-roomP.y,roomP.z)*0.7\n            : roomP;\n        wallColor *= someNoise(floorP).rrr;\n    }\n    wallColor += 0.5;\n    \n    // Make ceiling not too bright\n    wallColor = mix(wallColor*2., vec3(0), 0.9*smoothstep(-roomSize.z, roomSize.z, roomP.z-roomCenter.z));\n    vec3 ligPos = roomCenter + 0.7*vec3(roomHash2.xy*2.-1.,1.)*roomSize;\n    float intensity = 0.5/dot(ligPos-roomP,ligPos-roomP);\n    vec3 insideLight = emission * clamp(dot(inNormal, normalize(ligPos-roomP)),0.,1.) * intensity * wallColor;\n    insideLight += 0.5*roomHash2*roomHash2*emission;\n    \n    // Some windows have \"curtains\"... but you can peek through :)\n    vec2 curtainW = roomSize.xy - 0.15;\n    float curtains = roomHash.x > 0.8 \n        ? 0.9*(smoothstep(q.x-w, q.x+w, curtainW.x) + smoothstep(q.y-w, q.y+w, curtainW.y))\n        : 0.0;\n    emission = mix(emission*(1.+roomHash2)*0.1, insideLight, 1.-curtains);\n    \n    emission *= isInWindow;\n\treturn emission;\n}\n\nvec3 raycast(vec3 ro, vec3 rd)\n{\n    vec3 normal, normal2;\n    float t = sceneIntersect(ro, rd, normal);\n    vec3 p = ro+t*rd;\n    // And after one bounce\n    vec3 ro2 = p + 0.01*normal, rd2 = reflect(rd, normal);\n    float t2 = sceneIntersect(ro2, rd2, normal2);\n    \n    //return (t < T_MAX) ? 0.5+0.5*normal : vec3(0);\n    \n    vec3 _; // Dummy variable\n    if(t < T_MAX)\n    {\n        // Let's do some shading!\n        float ao = 0.5+0.5*normal.z;\n        float darkVoid = smoothstep(FLOOR,0.,p.z);\n        ao *= darkVoid;\n        \n        float isInWindow, _;\n        vec3 emission = computeEmission(p, rd, t, normal, isInWindow);\n        vec3 emission2 = computeEmission(ro2+t2*rd2, rd2, t+t2, normal2, _);\n        emission2 = t2 < T_MAX ? emission2 : skyColor(rd2);\n        \n        vec3 roomSize, roomCenter, roomHash;\n        getRoom(p, rd, roomSize, roomCenter, roomHash);\n    \tvec3 surfCol = 0.4+0.5*smoothstep(0.5,0.9,roomHash.rrr)-0.2*isInWindow;\n        vec3 F0 = 0.04+vec3(0.04,0.1,0.2)*surfCol;\n        \n    \tvec3 fre = F0 + (1.-F0) * pow(clamp(1.-dot(-rd,normal),0.,1.),5.);\n        vec3 col = mix(emission, emission2, fre);\n        col = mix(vec3(0.), col, isInWindow);\n        //vec3 col = emission;\n        //col += surfCol* clamp(dot(normal, sun), 0., 1.) * sunCol  * darkVoid;\n        //col += surfCol* clamp(dot(normal, -rd), 0., 1.)  * darkVoid * 2./ t;\n        //col += surfCol*vec3(0.5,0.7,0.9) * 0.1 * (0.5+0.5*normal.z) * ao;\n        //col += surfCol* sunCol*sunCol * 0.1 * clamp(dot(normal.xy, -sun.xy), 0., 1.) * ao;\n        \n        col += surfCol * ao * 0.2 * (0.5-0.2*normal.z) \n            * smoothstep(10.0,-30.0,p.z) * vec3(1.,0.8,0.6);\n\t\t\n        col = mix(col, vec3(0.), 1.-exp(-t*0.003));\n        col = mix(col, skyColor(rd), 1.-exp(-t*0.01));\n        col *= exp(0.02*min(p.z,0.));\n        //col +=;\n        return col;\n    }\n    else\n    {\n        vec3 col = skyColor(rd);\n        // Stars\n        float stars = smoothstep(0.96,1.01,textureLod(iChannel1,(round(1.5*rd.yz/(rd.x+1.)*iResolution.y)+0.5)/256., 0.).r)\n            * smoothstep(0.0,1.0,textureLod(iChannel1,(rd.yz/(rd.x+1.)*450.)/256., 0.).r);\n        col += stars*stars*smoothstep(0.0,0.2,rd.z);\n        return col;\n    }\n}\n\nvec3 path(float t)\n{\n    //return vec3(20.*t, 20.0*sin(0.3*t), 5.0 - 2.*cos(0.5*t));\n    return vec3(20.*t, 5.+0.1*cos(0.5*t),10.*cos(0.5*t)*(1.-0.5*sin(0.1*t)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\t\n    //vec3 ro = vec3(-3.*cos(th),-3.*sin(th),2.0);\n    //vec3 target = vec3(0);\n    vec3 ro = path(iTim);\n    vec3 target = path(iTim+3.)+vec3(0.,20.*cos(0.3*iTim),-15.);\n    vec3 camFwd = normalize(target - ro);\n    vec3 camRight = normalize(cross(camFwd, vec3(0.3*cos(0.2*iTim),0,1))); // Camera tilts\n    vec3 camUp = cross(camRight, camFwd);\n    vec3 rd = normalize(camFwd + 0.7*(uv.x*camRight+uv.y*camUp));\n    \n    \n    vec3 col = raycast(ro, rd);\n    \n    // Vignette\n    col *= smoothstep(1.7,0.5,length(2.*fragCoord/iResolution.xy-1.));\n    // Tone mapping\n    col = mix(col, 1.-(4./27.)/(col*col), step(2./3.,col));\n    // Gamma correction\n    col = pow(col, vec3(0.45));\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "volume",
                        "id": 40,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}