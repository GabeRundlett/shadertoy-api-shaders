{
    "Shader": {
        "info": {
            "date": "1624909848",
            "description": "Inspired by this long exposure photograph by Martin Cann:\nhttps://twitter.com/MartinCann1/status/1408139994972278788",
            "flags": 0,
            "hasliked": 0,
            "id": "ftSGWt",
            "likes": 47,
            "name": "Sun Tracks",
            "published": 3,
            "tags": [
                "noise",
                "fbm",
                "oklab"
            ],
            "usePreview": 0,
            "username": "DrNoob",
            "viewed": 1230
        },
        "renderpass": [
            {
                "code": "// Author: Thomas Stehle\n// Title: Sun Tracks\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//\n// Inspired by this long exposure photograph by Martin Cann:\n// https://twitter.com/MartinCann1/status/1408139994972278788\n\n// Constants\nconst vec3 INNER = vec3(131, 118, 117) / 255.0;\nconst vec3 OUTER = vec3(  1,  34,  46) / 255.0;\nconst vec3 SUN   = vec3(224, 229, 180) / 255.0;\nconst vec3 GLOW  = vec3(247, 251, 238) / 255.0;\n\nconst int NLINES     = 100;\nconst float NLINES_F = float(NLINES);\n\n// 1D hash for 1D input by David Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash(in float p) {\n    p = fract(p * 0.011);\n    p *= p + 7.5;\n    p *= p + p;\n    return fract(p);\n}\n\n// 1D hash for 2D input by David Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash21(in vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * 0.13);\n    p3 += dot(p3, p3.yzx + 3.333);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// 1D hash for 3D input\nfloat hash31(in vec3 p) {\n    vec3 q = fract(p * 0.1031);\n    q += dot(q, q.yzx + 33.33);\n    return fract((q.x + q.y) * q.z);\n}\n\n// 2D value noise by Morgan McGuire\n// https://www.shadertoy.com/view/4dS3Wd\nfloat vnoise(in vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    // Four corners in 2D of a tile\n    float a = hash21(i);\n    float b = hash21(i + vec2(1.0, 0.0));\n    float c = hash21(i + vec2(0.0, 1.0));\n    float d = hash21(i + vec2(1.0, 1.0));\n\n    // Smooth interpolation (smoothstep without clamping)\n    vec2 u = f*f * (3.0 - 2.0*f);\n\n    // Mix 4 coorners\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// 2D Fractional Brownian motion based on value noise by Morgan McGuire\n// https://www.shadertoy.com/view/4dS3Wd\nfloat vfbm(in vec2 p) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\n    const int NOCTAVES = 5;\n    for (int i = 0; i < NOCTAVES; ++i) {\n        v += a * vnoise(p);\n        p = rot * p * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// OKLAB-based color mixing by iq\n// https://www.shadertoy.com/view/ttcyRS\nvec3 oklab_mix( vec3 colA, vec3 colB, float h ) {\n    // https://bottosson.github.io/posts/oklab\n    const mat3 kCONEtoLMS = mat3(\n         0.4121656120,  0.2118591070,  0.0883097947,\n         0.5362752080,  0.6807189584,  0.2818474174,\n         0.0514575653,  0.1074065790,  0.6302613616);\n    const mat3 kLMStoCONE = mat3(\n         4.0767245293, -1.2681437731, -0.0041119885,\n        -3.3072168827,  2.6093323231, -0.7034763098,\n         0.2307590544, -0.3411344290,  1.7068625689);\n    \n    // rgb to cone (arg of pow can't be negative)\n    vec3 lmsA = pow( kCONEtoLMS*colA, vec3(1.0/3.0) );\n    vec3 lmsB = pow( kCONEtoLMS*colB, vec3(1.0/3.0) );\n    \n    // lerp\n    vec3 lms = mix( lmsA, lmsB, h );\n    \n    // gain in the middle (no oaklab anymore, but looks better?)\n    // lms *= 1.0+0.2*h*(1.0-h);\n    \n    // cone to rgb\n    return kLMStoCONE*(lms*lms*lms);\n}\n\nfloat sdOrientedBox(in vec2 p, in vec2 a, in vec2 b, float th) {\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nvec2 distort(in vec2 p) {\n    vec2 q = 0.8 * p + vec2(-0.2, 0.2);\n    float amp = -0.4;\n    float freq = 1.0 + 4.0 * q.y;\n    float phase = 0.0;\n    return vec2(q.x, q.y + amp * sin(freq * q.x + phase));\n}\n\nfloat suntracks(in vec2 p) {\n    vec2 st = vec2(p.x, p.y * NLINES_F);\n    st.y = max(st.y, 0.1 * NLINES_F);\n    st.y = min(st.y, 0.55 * NLINES_F);\n    \n    vec2 gv = vec2(st.x, fract(st.y));\n    float id = floor(st.y);\n    int idx = int(id);\n    \n    float r1 = hash(13.1 * float(idx));\n    float r2 = hash(37.3 * float(idx));\n    \n    float speed = 0.25 + 0.25 * r2;\n    \n    const float W = 0.25;\n    float d = sdOrientedBox(gv, vec2(-1.0, 0.5), vec2(2.0, 0.5), W);\n    float n = vfbm(vec2(30.0 * (gv.x + id) - speed * iTime, 0.0));\n    d += 0.25 * r2 + smoothstep(0.55, 0.65, n);\n\n    return d;\n}\n\nfloat foreground(in vec2 p) {\n    vec2 q = vec2(p.x, p.y + 0.2 * vfbm(10.0 * p));\n    const float W = 0.25;\n    return sdOrientedBox(q, vec2(-1.0, 0.0), vec2(2.0, 0.0), W);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Coordinate normalization\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float ar = iResolution.x / iResolution.y;\n    uv.x *= ar;\n\n    // Background\n    float bg = pow(10.0 * length(0.15 * uv - vec2(0.075, 0.1)), 1.5);\n    vec3 col = oklab_mix(INNER, OUTER, clamp(bg, 0.0, 1.0));\n    \n    // Foreground\n    float fgd = foreground(uv);\n    fgd = smoothstep(0.15, 0.1, fgd);\n    col = mix(col, vec3(0.05), fgd);\n    \n    // Distort\n    vec2 p = distort(uv);\n    \n    // Fade out factors\n    float fade = smoothstep(0.75, 0.25, length(p - vec2(0.5))); // Fade out to the sides\n    \n    // Sun tracks\n    float td = suntracks(p);\n    td  = smoothstep(0.5, -0.5, td) * fade;\n    td *= smoothstep(0.05, 0.2, uv.y); // Additional fade out near bottom\n    col = mix(col, SUN, clamp(td, 0.0, 1.0));\n    \n    // Gas tracks\n    float n = vfbm(2.0 * p - vec2(0.15 * iTime, 0.0));\n    n *= (1.0 - fgd);\n    col = oklab_mix(col, SUN, pow(n, 3.0));\n    \n    // Glow\n    float gl = vnoise(2.0 + sin(1.5 * iTime) * p);\n    gl  = pow(gl, 2.0) * fade;\n    gl *= smoothstep(0.7, 0.4, p.y) * smoothstep(-0.1, 0.2, p.y); // Additional fade in sun space\n    gl *= smoothstep(0.05, 0.2, uv.y); // Additional fade in screen space\n    col = mix(col, GLOW, clamp(gl, 0.0, 1.0));\n    \n    // Add animated noise\n    float r = hash31(vec3(fragCoord.xy, fract(0.001 * iTime)));\n    col.rgb += 0.1 * vec3(r - 0.5);\n    \n    // Vignetting\n    // https://www.shadertoy.com/view/lsKSWR\n    vec2 st = uv * (vec2(1.0, ar) - uv.yx);\n    float vig = st.x * st.y * 10.0;\n    col *= pow(vig, 0.2);\n    \n    // Final color\n    fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}