{
    "Shader": {
        "info": {
            "date": "1426094744",
            "description": "mouse to look",
            "flags": 0,
            "hasliked": 0,
            "id": "ltfGDl",
            "likes": 2,
            "name": "Canyonlands",
            "published": 3,
            "tags": [
                "3d",
                "terrain"
            ],
            "usePreview": 0,
            "username": "rcread",
            "viewed": 168
        },
        "renderpass": [
            {
                "code": "// Created by randy read - rcread/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//\tborrowed and modified code from\n//\t\tiq's \"Elevated\" https://www.shadertoy.com/view/MdX3Rr\n//\t\tguil's \"Cheap sine noise\" https://www.shadertoy.com/view/MtfGDX\n\n//#define GUIL_NOISE 1\n//#define MIXTURE 1\n#define SMOOTH 1\n#define FASTER 1\n\n#ifdef FASTER\nconst int octave_cnt = 4;\nfloat octave_step = 3.5;\n#else\nconst int octave_cnt = 6;\nfloat octave_step = 2.;\n#endif\n\nconst int march_cnt = 300;\nfloat maxh = 5.5;\n\nvec4 SKY_BLUE = vec4( 0.53, 0.81, 0.92, 1.0 );\nvec4 BLUE = vec4( 0., 0., 1., 1.0 );\n\nconst mat2 m2 = mat2(.8,.6,-.6,.8);\n\nfloat guil_noise( vec2 p ) {\n\n    float res=0.;\n    float f=1.;\n\tfor( int i=0; i< 3; i++ ) \n\t{\t\t\n        p=m2*p*f+.6;     \n        f*=1.2;\n        res+=sin(p.x+sin(2.*p.y));\n\t}        \t\n\treturn res/3.;\n}\n\nfloat ss( float b, float t ) {\n    return abs( b / 2. - mod( t, b ) );\n}\nfloat my_noise( vec2 p ) {\n\tvec4 a = vec4( 7., 3., 5., 2. );\n\treturn .1 * dot( vec2( ss( a.x, p.x ), ss( a.y, p.y ) ), vec2( ss( a.z, p.y ), ss( a.w, p.x ) ) ) / .721 - .216;\n}\n\n#ifdef GUIL_NOISE\nfloat noise( vec2 p ) { return guil_noise( p ); }\n#else\nfloat noise( vec2 p ) { return my_noise( p ); }\n#endif\n\nfloat fbmabs( vec2 p ) {\n\tfloat f = .7, h = 0.;\n#ifdef MIXTURE\n\th = abs( guil_noise( ( p.yx + 3. ) * f + f ) ) / f;\n\tf *= octave_step;\n#else\n\th = abs( noise( ( p.yx + 3. ) * f + f ) ) / f;\n\th = +abs( noise( ( p.yx + vec2( 3., -3. ) ) * f + f ) ) / f;\n\th += abs( noise( ( p + 3. ) * f + f ) ) / f;\n#endif\n\tfor( int i = 0 ; i < octave_cnt ; i++ ) {\n\t\th += abs( noise( p * f + f ) ) / f;\n#ifdef SMOOTH\n\tp -= vec2( -.01, .08 ) * h;\n#endif\n\t\tf *= octave_step;\n\t}\n\treturn h;\n}\n\nfloat map( vec2 p ) {\n\treturn 1.5 * fbmabs( p );\n}\n\nvec3 nor( vec2 p ) {\n\tconst vec2 e = vec2( 0.002, 0.0 );\n\treturn normalize( vec3( map( p + e.xy ) - map( p - e.xy ), map( p + e.yx ) - map( p - e.yx ), -.2 ) );\n}\n\nvec4 raymarch( vec3 ro, vec3 rd ) {\n\tvec4 color;\n\tfloat t = 0.;\n\tvec3 p;\n\n\tfloat tmin = 0.0;\n\tfloat tmax = 2000.0;\n\tfloat tp = ( maxh - ro.y ) / rd.y;\n\tif( tp > 0.0 ) {\n\t\tif( ro.y > maxh ) tmin = max( tmin, tp );\t//\tif we're above the peaks, we start with top\n\t\telse\t\t\t  tmax = min( tmax, tp );\t//\tif we're below the peaks, we end with the top\n\t}\n\tfloat d = 0.;\n\tt = tmin;\n\tfor ( int i = 0 ; i < march_cnt ; i++ ) {\n\t\tp = ro + t * rd;\n\t\td = p.y - map( p.xz );\n\t\tif ( d < 0.002 * t || t > tmax  ) break;\n\t\tt += ( .2 + t * .0065 ) * d;\n\t}\n\n\tif ( t > tmax || ro.y > maxh && rd.y > 0. ) {\n\t\tcolor = mix( SKY_BLUE, BLUE, rd.y );\n\t} else {\n\t\tfloat r = 0.;\n\t\tvec3 light = normalize(vec3(4., 2., -1.));\n\n\t\tr = max( dot( nor( p.xz ), light ), 0.1 );\n\t\tfloat k = map( p.xz ) * .55;\n\t\tcolor = clamp( vec4( r*k*k, r*k, r*.8, 1.0 ), 0., 1. );\n\t}\n\treturn color;\n}\n\nvec3 mouse_look( vec2 pixel, vec2 mouse, vec2 resolution ) {\n\tvec2 p\t\t= pixel / resolution - .5;\t\t\t\t\t\t\t\t\t\t\t//\tpixel [-.5,.5]\n\tvec2 uv\t\t= 2. * mouse / resolution - 1.;\t\t\t\t\t\t\t\t\t\t//\t[-1,1]\n\tuv.x\t\t*= -3.14;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\t\n\tvec3 cam\t= normalize( vec3( sin( uv.x ), 2. * asin( uv.y\t ), cos( uv.x ) ) );\t//\tmouse decides camera direction\n\tvec3 right\t= normalize( cross( cam, vec3( 0., 1., 0. ) ) );\t\t\t\t\t//\tright anything horizontal and perpendicular to cam\n\tvec3 up\t\t= normalize( cross( right, cam ) );\t\t\t\t\t\t\t\t\t//\tup perpendicular to both cam and right\n\treturn normalize( cam + p.x * right + p.y * up );\t\t\t\t\t\t\t\t//\treturn pixel ray direction\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = iMouse.x <= .0 ? iResolution.xy / 2. : iMouse.xy;\n\tvec3 ro = vec3( -131. );\n\tvec3 rd = mouse_look( floor( gl_FragCoord.xy ), mouse, iResolution.xy );\n\n\tfloat t = iTime;\n\tvec3 dro = - vec3( -.2, 0., -.6 );\n\tro += dro * t;\n\tfloat h = 0.;\n\tconst float max_i = 20.;\n\tfor ( float i = -max_i ; i <= max_i ; i++ ) {\n\t\th += abs( max_i - i ) * min( maxh, map( ro.xz + i * 2e2 * dro.xz ) );\n\t}\n\th /= ( max_i * max_i );\n\tro.y = clamp( h, 1.5, maxh + .1 );\n\n\tfragColor = raymarch( ro, rd );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}