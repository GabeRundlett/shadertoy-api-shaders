{
    "Shader": {
        "info": {
            "date": "1647941701",
            "description": "Nine pyramids of the Giza pyramid complex.",
            "flags": 0,
            "hasliked": 0,
            "id": "ftXyDr",
            "likes": 26,
            "name": "Giza Necropolis - Sunrise",
            "published": 3,
            "tags": [
                "pyramids",
                "giza"
            ],
            "usePreview": 0,
            "username": "sandaruwan",
            "viewed": 526
        },
        "renderpass": [
            {
                "code": "/*---------------------------------------------\n\nGiza Necropolis, Sandaruwan Silva 2022\n\nNine pyramids of the Giza pyramid complex.\n\n1. Clouds and noise functions etc. based on Inigo Quilez's Rainforest\n   https://www.shadertoy.com/view/4ttSWf\n2. Dust storm roughly based on VoidChicken's The Rude Sandstorm \n   https://www.shadertoy.com/view/Mly3WG\n\n---------------------------------------------*/\n\nfloat sdSphere(in vec3 p, in float radius) {\n     return length(p) - radius;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdOctahedron(in vec3 p, in float s) {\n    p = abs(p);\n    return (p.x + p.y + p.z - s) * 0.57735027;\n}\n\nfloat sdOctahedronStepped(in vec3 p, in float s) {\n    p = abs(p);\n    return (p.x + floor(p.y * 15.0) / 15.0 + p.z - s) * 0.47735027;\n}\n\nfloat sdGiza(in vec3 p, in float s, in float dmg) {\n    p = abs(p);\n    float v = (p.x + p.y + p.z - s) * 0.57735027;\n    \n    p.y -= s + 0.25 - dmg;\n    \n    float b = sdBox(p, vec3(0.25));\n    v = max(v, -b);\n    return v;\n}\n\n// -- cloud generation -----------------------\n\nvec4 sky( in vec3 ro, in vec3 rd ) {\n    vec3 col = vec3(0.3, 0.4, 1.0) - rd.y * 0.7;\n    float t = (1000.0 - ro.y) / rd.y;\n\n    \n    if(t > 0.0) {\n        vec2 uv = (ro + t * rd).xz;\n        float cl = fbm_9(uv * 0.002 - iTime * 0.2);\n        float dl = smoothstep(-0.2, 0.6, cl);\n        col = mix(col, vec3(1.0), 0.12 * dl);\n    }\n    \n\treturn vec4(col, t);\n}\n\n// -- scene ----------------------------------\n\n// scene map\nvec3 map(in vec3 p) {\n    vec3 res = vec3(-1.0);\n    \n    vec3 offset = vec3(0.3, 0.0, -8.0);\n    vec3 offset2 = vec3(0.6, 0.0, -8.0);\n    \n    float d = 0.0;\n    \n    // noise values\n    float nv1 = noise(p * 0.25 + 2.1);\n    float nv2 = noise(p * 230.0 + 2.1);\n    float nv3 = noise(p * 12.5 + 2.1);\n    float nv4 = noise(vec3(p.x, p.y, 0.0) * 1.5 + 2.1);\n    float nv5 = noise(p * 49.5 + 2.1);\n    float nv6 = noise(vec3(p.x, p.y, 0.0) * 0.5 + 2.1);\n    \n    \n    // height map\n    float heightMap = nv1 * 0.5 + nv2 * 0.002;\n    float terrain = p.y + heightMap;\n    \n    // common values for pyramids\n    vec3 mainOffset = p * rotate_y(PI_4) + offset;\n    float mainNoise1 = nv3 * 0.02;\n    float mainNoise2 = nv4 * 0.07;\n    float mainNoiseTop = nv5 * 0.015;\n    \n    vec3 smallOffset = p * rotate_y(PI_4) + offset2;\n    \n    float ySin = smoothstep(0.93, 1.0, sin(p.y * 400.0)) * 0.01;\n    float xSin = smoothstep(0.94, 1.0, sin(p.x * 260.0)) * 0.005;\n    float zSin = smoothstep(0.94, 1.0, sin(p.z * 260.0)) * 0.005;\n    float sinComb = ySin + xSin + zSin;\n    \n    float ySinM1 = smoothstep(0.2, 1.0, sin(p.y * 200.)) * 0.007;\n    float xSinM1 = smoothstep(0.2, 1.0, sin(p.x * 200.)) * 0.005;\n    float zSinM1 = smoothstep(0.2, 1.0, sin(p.z * 200.)) * 0.005;\n    float sinMComb1 = ySinM1 + xSinM1 + zSinM1;\n    \n    float ySinM2 = smoothstep(0.2, 1.0, sin(p.y * 100.)) * 0.005;\n    float xSinM2 = smoothstep(0.2, 1.0, sin(p.x * 100.)) * 0.005;\n    float zSinM2 = smoothstep(0.2, 1.0, sin(p.z * 100.)) * 0.005;\n    float sinMComb2 = ySinM2 * 4.0 + xSinM2 + zSinM2;\n    \n    // pyramid of Menkaure, one in the front\n    float p1 = sdGiza(mainOffset + vec3(-3.0, 2.8, 1.0),\n        4.9 - sinMComb1 - mainNoise1 * 0.2 - nv5 * 0.01 - mainNoise2 * 0.2, 0.08);\n    \n    // pyramid of Khafre, one in the middle\n    float p2 = sdOctahedron(mainOffset + vec3(0.0, 2.0, 15.0),\n        7.5 - sinMComb2 - mainNoise1 - mainNoise2);\n    // pyramid top\n    float ptop = sdGiza(mainOffset + vec3(0.01, -4.0, 14.98),\n        1.58 - mainNoiseTop, 0.05);\n    ptop = max(ptop, -sdSphere(mainOffset + vec3(0.04, -1.8, 13.98), 2.8 + nv1 * 0.2 +  nv3 * 0.1));\n\n    // pyramid of Khufu, distant one\n    float p3 = sdGiza(mainOffset + vec3(0.0, 2.0, 30.0),\n        8.0 - sinMComb2 - mainNoise1 - mainNoise2, 0.2);\n\n    // queens' pyramids\n    float p4 = sdOctahedronStepped(smallOffset + vec3(-5.6, 0.47, -4.4),\n        0.58 - sinComb - nv5 * 0.02 - nv6 * 0.07);\n    float p5 = sdOctahedronStepped(smallOffset + vec3(-6.0, 0.37, -4.0),\n        0.58 - sinComb - nv5 * 0.02 - nv6 * 0.07);\n    float p6 = sdOctahedronStepped(smallOffset + vec3(-6.4, 0.34, -3.6),\n        0.58 - sinComb - nv5 * 0.02 - nv6 * 0.07);\n    \n    // remove algorithmic artifacts on the top\n    p5 = max(p5, -sdBox(smallOffset + vec3(-6.0, -0.3, -4.0), vec3(0.1)));\n    \n    // spheres to smoothen the pyramids\n    float s4 = sdSphere(p + vec3(5.2, 0.2, -12.3), 0.3);\n    float s5 = sdSphere(p + vec3(4.7, 0.1, -12.3), 0.22);\n    float s6 = sdSphere(p + vec3(4.2, 0.1, -12.3), 0.22);\n    \n    \n    // other pyramids in the complex\n    // represent them with just spheres since they're far away\n    float s7 = sdSphere(p + vec3(-22.2, -1.1, 11.0),\n        0.2 - ySin - xSin - zSin - nv5 * 0.01 - nv6 * 0.07);\n    float s8 = sdSphere(p + vec3(-22.2, -0.7, 13.0),\n        0.5 - ySin - xSin - zSin - nv5 * 0.01 - nv6 * 0.07);\n    float s9 = sdSphere(p + vec3(-22.2, -0.5, 15.0),\n        0.5 - ySin - xSin - zSin - nv5 * 0.01 - nv6 * 0.07);\n    \n    \n    d = min(terrain, p1);\n    d = min(d, p2);\n    d = min(d, ptop);\n    d = min(d, p3);\n    \n    d = opSmoothUnion(d, s7, 2.6);\n    d = opSmoothUnion(d, s8, 1.2);\n    d = opSmoothUnion(d, s9, 1.2);\n    \n    // add queens' pyramids\n    d = opSmoothUnion(opSmoothUnion(d, p4, 0.05), s4, 0.2);\n    d = opSmoothUnion(opSmoothUnion(d, p5, 0.05), s5, 0.2);\n    d = opSmoothUnion(opSmoothUnion(d, p6, 0.05), s6, 0.2);\n    \n    res.x = d;\n    return res;\n}\n\n// ray marching through terrain and objects\nvec3 trace(in vec3 ro, in vec3 rd) {\n    float tMax = 1000.0;\n    vec3  res  = vec3(-1.0);\n    vec3  last = vec3(0.0);\n    float t    = 0.0;\n\n    vec3 dust = vec3(1.0);\n    \n    for (int i = 0; i < 150; i++) {\n        vec3 pos = ro + t * rd;\n        vec3 hit = map(pos);\n        \n        if (abs(hit.x) < 0.0001 * t || t > tMax) break;\n\n        t += hit.x;\n        last = hit;\n\n        // add dust cloud\n        vec3 a = vec3(noise(pos + iTime * 0.13) + 0.1);\n        dust += a * sqrt(float(i)) * 1.0 *\n            pow(smoothstep(0.0, 1.0, clamp(float(i) / 15.0, 0.0, 1.0)), 1.0 / 2.5);\n    }\n    \n    if (t < tMax) {\n        res = vec3(t, last.yz);\n    }\n    \n    dust.x = clamp(dust.x, -200.0, 200.0);\n    res.y = dust.x * 0.001;\n    return res;\n}\n\n// calculate normals\nvec3 calcNormal(in vec3 p, in float t) {\n    vec3 n = vec3(0.0);\n    \n    for (int i = 0; i < 4; i++) {\n        vec3 e = 0.5773 * (2.0 * vec3((((i + 3) >> 1) & 1),\n            ((i >> 1) &1 ),(i & 1)) - 1.0);\n        n += e * map(p + e * 0.001 * t).x;\n    }\n    \n    return normalize(n);\n}\n\n// calculate ao\nfloat calcAO(in vec3 pos, in vec3 nor) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    \n    for(int i=0; i < 5; i++) {\n        float h = 0.001 + 0.15 * float(i) / 4.0;\n        float d = map(pos + h * nor).x;\n        occ += (h - d) * sca;\n        sca *= 0.95;\n    }\n    \n    return clamp(1.0 - 1.5 * occ, 0.0, 1.0);    \n}\n\n// camera/projection\nmat3 camera(in vec3 ro, in vec3 ta, float cr) {\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2  p    = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3  col  = vec3(0.0);\n    float time = iTime;\n    \n    // set up camera/projection\n    float an = -0.35;\n    float ra = 17.0;\n    float fl = 4.0;\n    vec3  ta = vec3(sin(time * 0.13 - 0.1) * 0.1,\n        cos(time * 0.1 - 4.0) * 0.05 + 0.1, 0.0);\n    vec3  ro = ta + vec3(ra * sin(an), 0.0, ra * cos(an));\n    mat3  ca = camera(ro, ta, 0.0);\n    vec3  rd = ca * normalize(vec3(p.x + 0.3, p.y + 0.4,fl));\n    \n    // ray marching\n    vec3 ray = trace(ro, rd);\n    float resT = 1000.;\n    \n    if (ray.x >= 0.0) {\n        float t   = ray.x;\n        vec3 pos  = ro + t * rd;\n        vec3 norm = calcNormal(pos, t);\n        \n        // prepare diffusion\n        float sun_dif = clamp(dot(norm, sun_direction), 0.0, 1.0);\n        vec3  sky_dir = normalize(vec3(0.0, 1.0, 0.0));\n        float sky_dif = clamp(dot(norm, sky_dir), 0.0, 1.0);\n        \n        // set up cheap shadows\n        float sun_sha = trace(pos + norm * 0.0001, sun_direction).x;\n        float dif = clamp(sun_dif, 0.0, 1.0);\n        \n        col += vec3(0.6, 0.4, 0.2) * dif * 1.29;\n        col += vec3(0.6, 0.4, 0.8) * sky_dif * 0.4;\n        col *= calcAO(pos, norm);\n        \n        if (sun_sha > 0.0) {\n            col *= 0.5;\n        }\n        \n        col += ray.y * vec3(1.0, 0.8, 0.4) * 0.6;\n        \n        col = fog(col, t);\n        col *= 0.5 + 0.5 * vec3(0.8, 0.3, 0.0);\n \n    } else {\n        vec4 sky_color = sky(ro, rd);\n        col = sky_color.rgb;\n        \n        col = fog(col, sky_color.a * 0.01);\n    }\n    \n\n    // gamma\n    col = pow(clamp(col * 1.1 - 0.04, 0.0, 1.0), vec3(0.4545));\n\n    // contrast\n    col = col * col * (3.0 - 2.0 * col);            \n\n    // add sun glare\n    float sun = clamp(dot(sun_direction, rd), 0.0, 1.0);\n    col += 0.75 * vec3(0.8, 0.4, 0.2) * sun * sun * sun;\n    \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.14159265359\n#define PI_4 0.78539816339\n\nconst vec3 sun_direction = normalize(vec3(0.8, 0.3, -0.6));\n\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\nconst mat3 m3i = mat3( 0.00, -0.80, -0.60,\n                       0.80,  0.36, -0.48,\n                       0.60, -0.48,  0.64 );\nconst mat2 m2  = mat2( 0.80,  0.60,\n                      -0.60,  0.80 );\nconst mat2 m2i = mat2( 0.80, -0.60,\n                       0.60,  0.80 );\n\nmat3 rotate_x(in float a) {\n    float sa = sin(a);\n    float ca = cos(a);\n    return mat3(vec3(1.0, 0.0, 0.0),\n        vec3(0.0, ca, sa), vec3(0.0, -sa, ca));\n}\n\nmat3 rotate_y(in float a) {\n    float sa = sin(a);\n    float ca = cos(a);\n    return mat3(vec3(ca, 0.0, sa),\n        vec3(0.0, 1.0, 0.0), vec3(-sa, 0.0, ca));\n}\n\nmat3 rotate_z(in float a) {\n    float sa = sin(a);\n    float ca = cos(a);\n    return mat3(vec3(ca, sa, 0.0),\n        vec3(-sa, ca, 0.0), vec3(0.0, 0.0, 1.0));\n}\n\nfloat opSmoothUnion(in float d1, in float d2, in float k ) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nvec3 fog(in vec3 col, float t) {\n    vec3 ext = exp2(-t * 0.0007 * vec3(2.0, 2.5, 4.0)); \n    return col * ext + (1.0 - ext) * vec3(0.75, 0.65, 0.58);\n}\n\nfloat hash1(float n) {\n    return fract(n * 17.0 * fract(n * 0.3183099));\n}\n\nfloat hash1(vec2 p) {\n    p  = 50.0 * fract(p * 0.3183099);\n    return fract(p.x * p.y * (p.x + p.y));\n}\n\nfloat noise(in vec3 x) {\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    vec3 u = w * w * w * (w * (w * 6.0 - 15.0) + 10.0);\n    float n = 1.0 * p.x + 317.0 * p.y + 157.0 * p.z;\n    \n    float a = hash1(n + 0.0);\n    float b = hash1(n + 1.0);\n    float c = hash1(n + 317.0);\n    float d = hash1(n + 318.0);\n    float e = hash1(n + 157.0);\n\tfloat f = hash1(n + 158.0);\n    float g = hash1(n + 474.0);\n    float h = hash1(n + 475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return -1.0 + 2.0 * (k0 + k1 * u.x + k2 * u.y +\n        k3 * u.z + k4 * u.x * u.y + k5 * u.y * u.z +\n        k6 * u.z * u.x + k7 * u.x * u.y * u.z);\n}\n\nfloat noise( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    vec2 u = w * w * w * (w * (w * 6.0 - 15.0) + 10.0);\n\n    float a = hash1(p + vec2(0, 0));\n    float b = hash1(p + vec2(1, 0));\n    float c = hash1(p + vec2(0, 1));\n    float d = hash1(p + vec2(1, 1));\n    \n    return -1.0 + 2.0 * (a + (b - a) * u.x +\n        (c - a) * u.y + (a - b - c + d) * u.x * u.y);\n}\n\nfloat fbm_9( in vec2 x ) {\n    float f = 1.9;\n    float s = 0.55;\n    float a = 0.0;\n    float b = 0.5;\n    \n    for(int i = 0; i < 9; i++) {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m2*x;\n    }\n\treturn a;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}