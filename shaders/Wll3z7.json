{
    "Shader": {
        "info": {
            "date": "1555939658",
            "description": "with each derivative, the graph-color red-shifts ;)\n violet   f(x)=0th derivative\n blue     f'(x)=1th derivative\n green   f''(x)=2th derivative\n orange f'''(x)=3th derivative\n\nf(x)=cos(cos(x))\n\nonly sin() and sin(sin(...))) for now!",
            "flags": 0,
            "hasliked": 0,
            "id": "Wll3z7",
            "likes": 2,
            "name": "AD27 sin(sin())dxÂ³ ",
            "published": 3,
            "tags": [
                "filter",
                "gradient",
                "vibrato",
                "ad",
                "phase",
                "automaticdifferentiation",
                "chainrule",
                "productrule",
                "curvaturejerk",
                "curvajerk",
                "drunkfluttershy"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 422
        },
        "renderpass": [
            {
                "code": "/*\na derivative of a function is the differential of a function\nf'(x)=f (x)dx\nf1(x)=f0(x)dx\nf2(x)=f1(x)dx\nf3(x)=f2(x)dx\n\nf1(x)==0, where f0(x) has a local maximum or local minimum at [x],\nblue   line is close to 0,where the violet line has a hill or valley\ngreen  line is close to 0,where the blue   line has a hill or valley\norange line is close to 0,where the green  line has a hill or valley\n(being close to 0 has utility in (iterative) root-solving)\n\nwith each derivative, the graph-color red-shifts ;)\n violet f0(x)=0th derivative :eg: value per coin of money over time  (focus on a point where this is >0 (,but also decreases))\n blue   f1(x)=1th derivative :eg: inflation/deflation (change of value of money over time) (fosus on a point whree this is <0)\n green  f2(x)=2th derivative :eg: rate at which the purchasing power of money decreases/increases  (acceleration of inflation == moneyValue)\n orange f3(x)=3th derivative :eg: \"the rate of increase of inflation is decreasing\" - Richard Nixxon == \"[orange line && blue line && green line] <0, violet line is barely >0 \"\n\nthis exemplifies the little utility that a 3rd derivative has \n, while without context of lower derivatives\n\nhttps://en.wikipedia.org/wiki/Third_derivative\n     jerk == rate at which acceleration changes\ncurvajerk == rate at which curvature    changes\n\n*/\n\n//AD,filter,phase,vibrato,gradient,curvaturejerk,curvajerk,chainrule,productrule,automaticdifferentiation,drunkfluttershy\n\n//child  AD32    : https://www.shadertoy.com/view/ttX3D8\n//child  AD29    : https://www.shadertoy.com/view/3llGDr\n//child  AD28    : https://www.shadertoy.com/view/Wts3Wr\n//self   AD27    : https://www.shadertoy.com/view/Wll3z7  (only cos() 3rd derivative)\n//parent baseline: https://www.shadertoy.com/view/WllGz7  (mostly empty canvas concept)\n//parent AD26    : https://www.shadertoy.com/view/MsffRs  (more complete set, ony 1 derivative)\n//parent AD25    : https://www.shadertoy.com/view/XdXfRl  (more complete set, ony 1 derivative)\n//parent fm-phase: https://www.shadertoy.com/view/tslSR8  (the phase-culpit of fm-synthesis)\n//parent         : all (analytic) [filter] shaders\n//parent         : all (analytic) [softshadow] shaders ???\n//\n//twitter images: https://twitter.com/ollj/status/1120622111767371777\n\n\n/*\nThis shader dares to implement/debug\na [derivatuve arithmetic] set for [automatic differentiation]\nbut it calculates not just one differential as one byproduct\n, but also the 2nd and 3rd derivative as 3 byproducts total\n3 derivatives make sense\n, because trigonometry functions have a loop of 4 or 2 differntials:\n\n//f    (x)=+sin(x)\n//f'   (x)=+cos(x)\n//f''  (x)=-sin(x)\n//f''' (x)=-cos(x)\n//f''''(x)=+sin(x)==f(x)\n\ncore plan here is to use\nhttps://www.integral-calculator.com\nto get ANTI-derivatives as far as needed and possible/practical\nand then get a series of derivatives with [automatic differentiation]\n, from a high enough ANTI-derivative to:\n- use 1 antiderivative for frequency-modulation (analytic phase)\n- use 2 or 3 anditerivatives for a good filter function\n- calculate fast/analytical derivatives is useful for [advanced spheretracking]\n- - think about what you could estimate from a fast+analytic curvature of a distancefield.\n- - this can extend into something like [drunk fluttershy marching]\n  , but it may not just move along the NORMAL/GRADIRNT\n  ,also use [radiusOf/Principal /gaussian curvature] and CURVAJERK\n\nI finally understand [automatic differentiation] (chain rule and product rule)\nwell enough to implement\n3rd derivative [automatic differentiation] of \ny=sin(sin(x))\ny=sin(sin(sin(x)))\ny=sin(sin(sin(sin(x))))\ny=sin(sin(sin(sin(...    (sin(x))...))))\nso far only for the sin() function, repediately applied.\nit is [spam of [automatic differentiation]]\nit is a start,a proof of concept and (lack of) utility\n\nThe 2nd derivative introduces the productRule\n,and the 3rd derivative adds more (recursive) productRules\n, to a point where these derivatives get recursively more excessive.\nA 4th derivative exceeds vec4 structure\nand the 3rd derivative already has quite limited utility\n, so i see no good reason ti implement \na 4th derivative automatic differentiation\n\nThis uses a lot of structure and monadic #define shorthands\nfrom the CommonTab\n, that construct a [derivative arithmetic] set \n  of [automatic differentiation].\nso just read the commonTab before reading further below:\n*/\n\n#define viewZoom 8.\n#define aA min(r.x,r.y)\n#define Aa (1./aA)\n#define fra(u)(u-.5*r.xy)*viewZoom/r.y \n\n#define ssaa(a) smoothstep(Aa,-Aa,a-.05)\n\n//example code for automatic differentiation of repeated cos()\nvec4 daTest0(float t){d0000 C=D0000(vec4(-t,1,0,0))//initial chainRuleSetup\n ;C=si(C)\n ;return V3(C);}\n\nvec4 daTest1(float t){d0000 C=D0000(vec4(-t,1,0,0))//initial chainRuleSetup\n ;C=si(C)\n ;C=si(C)\n ;return V3(C);}\n\nvec4 daTest2(float t){d0000 C=D0000(vec4(-t,1,0,0))//initial chainRuleSetup\n ;C=si(C)\n ;C=si(C)\n ;C=si(C)\n ;return V3(C);}\n\nvec4 daTest3(float t){d0000 C=D0000(vec4(-t,1,0,0))//initial chainRuleSetup\n ;C=si(C)\n ;C=si(C)\n ;C=si(C)\n ;C=si(C)\n ;return V3(C);}\n\nvec4 daTest4(float t){d0000 C=D0000(vec4(-t,1,0,0))//initial chainRuleSetup\n ;C=si(C)\n ;C=si(C)\n ;C=si(C)\n ;C=si(C)\n ;C=si(C)\n ;return V3(C);}\n\n//visualizaing demo:\nvec3 show(float t,vec2 u,vec3 r,vec4 m\n){\n ;t=u.x*2.\n ;vec4 c=daTest1(t)\n //c.xyzw store vec4(0,1,2,3)rd derivatives\n //\n //lazy 2d visualization with lazy compositing:\n ;c=c+u.y-vec4(0,1,2,3)*Aa*cos(iTime)*Aa\n //tiny .y offset over time, to distinguish identical results\n //makes sense here, because identical lines are quite likely\n ;c=abs(c)\n ;c=ssaa(c)//smoothstep\n \n ;//c.z+=c.x\n //;c=c.wzyx//invert order\n ;c.z+=(c.w+c.y)*.5//half-mix 2 colors for redGreen colorblindness\n ;c.y+=c.x   //fold .x\n ;c.w+=c.x*.5//fold .x\n ;//c.z+=c.w//shift all to violet\n     \n  ;c=c.wzyx//invert order\n ;//c.y+=c.w*.25//fold .w\n //pink    =0th derivative\n //blue    =1th derivative\n //green   =2th derivative\n //orange  =3th derivative\n ;return c.xyz;}\n\n//grid canvas for scale\nfloat grid(vec2 u,vec3 r\n){u=abs(u)\n ;u.x=min(u.x,u.y)\n ;u.x=ssaa(u.x)\n ;return u.x;}\nfloat canvas(vec2 u,vec3 r\n){return mix(grid(u,r),grid(fract(u-.5)-.5,r),.2);}\n\n\nvoid mainImage( out vec4 o, in vec2 u\n){vec4 m=iMouse\n ;if(m.z<=0.)m.xy=vec2(iResolution.xy*.5)\n ;vec3 r=iResolution\n  \n ;u.x-=(m.x-iResolution.x*.5)//*2. //mouse.x scrolls\n ;u=fra(u)\n ;u*=(1.-iResolution.y/m.y)//mouse.y zooms\n\n ;vec3 c=vec3(0)\n ;c=show(iTime,u,r,m)+canvas(u,r)*.5\n ;o = vec4(c,1);\n}\n\n/*\nmemos to self: \n- verb is \"differentiation\", there is no \"c\" glyph in this (except in its french variant)\n- - Babbage planned a [differencial engine] and this the \"c\" is a bad habbit in AD ever since.\n- [radius of curvature] != [gaussian curvature] //2nd derivative\n- - i assume this only gets worse for 3rd derivatives.\n/**/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n3rd derivative [Automatic differentiation]\nuses the [chain rule] (and [product rule] for [>1st derivative])\n, to calculate the derivative of an operation-list opA(opB(x)) as a byproduct\nto up to a 3rd derivative; f'''(x)\n\nhere opA =sin(x) and opB(x)=sin(x) ...\n, just because sin(x) is the only function\n,that i implemented for now (up to a 3rd derivative)\n/**/\n\n//indexing starts at 0\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n\n//define more [monadic function namespace]\nv0 ne(v0 a){return (a)*-1.;}\nv0 si(v0 a){return sin(a);}\nv0 co(v0 a){return cos(a);}\nv0 mu(v0 a,v0 b){return a*b;}\n\n//define a structure that implies automatic differentiation:\n//-type: [d**  ] <- implies automatic differentiation with at least 1 derivative\n//-type: [d*** ] <- implies automatic differentiation with at least 2 derivatives\n//-type: [d****] <- implies automatic differentiation with at least 3 derivatives\n//*=[0,1,2,3] == number of domains (indexing starts at 0)\n//by feeding a different type to the same [monadic function namespace]\n//.a accululates 0th derivative\n//.b accumulates 1th derivative\n//.c accumulates 2th derivative\n//.d accumulates 3th derivative\n//but not just over one tomain, but easily up to 3d. (and a bit into 4d)\n#define ST struct\nST d00{v0 a;v0 b;};ST d000{v0 a;v0 b;v0 c;};ST d0000{v0 a;v0 b;v0 c;v0 d;};\nST d11{v1 a;v1 b;};ST d111{v1 a;v1 b;v1 c;};ST d1111{v1 a;v1 b;v1 c;v0 d;};\nST d22{v2 a;v2 b;};ST d222{v2 a;v2 b;v2 c;};ST d2222{v2 a;v2 b;v2 c;v0 d;};\nST d33{v3 a;v3 b;};ST d333{v3 a;v3 b;v3 c;};ST d3333{v3 a;v3 b;v3 c;v0 d;};\n//restore funtionality (eg: swiveling) by explicit typecast:\nd0000 D0000(v3    a){return d0000(a.x,a.y,a.z,a.w);}\nv3       V3(d0000 a){return    v3(a.a,a.b,a.c,a.d);}\n//v3 D1bcd(d0000 a){return v3(1.,a.b,a.c,a.d);}//for a minifying concept\n\n//sin() and cos() derivatives are 4-cyclic.\n//d0000 siD(float a){return d0000(+si(a),+co(a),-si(a),-co(a));}\n//d0000 coD(float a){return d0000(+co(a),-si(a),-co(a),+si(a));}\n\n/*\n  chain rule:\n  (f(g(x)))dx = f'(g())*g'()\n\n  product rule (is subroutine of chainRule of higher derivatives than 1st derivative)\n  (f()*g())dx = f'()*g()+f()*g'()\n*/\n\n// [automatic differentiation] up to 3rd derivative of sin(d0000 a):\nd0000 si(d0000 a\n){return d0000(\n si(a.a)                      //0th derivative (function identity)\n,co(a.a)*a.b                  //1st dericative (common AD stuff as in [AD26] )\n,co(a.a)*a.c+a.b*-si(a.a)*a.b //2nd derivative (product rule of the above is a bit tricky)\n, \n+a.d*co(a.a)\n-a.b*(2.*a.c*si(a.a)\n+(a.b*a.b*co(a.a)\n     +a.c*si(a.a)))//3rd derivative (recursive product rule explosion!)\n);}\n\n/* //less crunched 3rd derivative\n+a.d*co(a.a)\n-a.b*a.c*si(a.a)\n-a.b*a.c*si(a.a)\n-a.b* ( a.b*co(a.a)*a.b\n           +si(a.a)*a.c)//3rd derivative (recursive product rule explosion!)\n*/\n\n//questions on how to get to the above function; \n//   d0000 si(d0000 a){}\n//are hopefully answered with the parent shader;\n//parent AD26    : https://www.shadertoy.com/view/MsffRs  (more complete set, ony 1 derivative)\n//and with the rightmost image of:\n//                 https://twitter.com/ollj/status/1120622111767371777",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}