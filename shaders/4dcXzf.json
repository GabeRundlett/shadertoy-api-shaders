{
    "Shader": {
        "info": {
            "date": "1460493651",
            "description": "Rendering an elliptic curve for cycling values of a and b.\n(OK, once in a great while you'll get a non-elliptic curve: when a = b = 0.)",
            "flags": 0,
            "hasliked": 0,
            "id": "4dcXzf",
            "likes": 5,
            "name": "Elliptic curve warmup",
            "published": 3,
            "tags": [
                "math",
                "function",
                "elliptic"
            ],
            "usePreview": 0,
            "username": "huttarl",
            "viewed": 811
        },
        "renderpass": [
            {
                "code": "// This is an exercise in preparation for another shader I'm working on,\n// https://www.shadertoy.com/view/lstXRj (not published yet).\n\n// See https://en.wikipedia.org/wiki/Elliptic_curve about elliptic curves.\n\n// HT to marius at https://www.shadertoy.com/view/Mt2Gzw, who already made a shader\n// with elliptic curves. I used his delta idea (adapted).\n\n// Idea: add sound. Maybe have two sounds, and the volume of one is\n// proportional to a, the other, to b.\n\n// Idea: make this 3D, a hill growing and spawning a blob.\n//   Maybe make it stereoscopic, and/or VR.\n\n// Idea from Jo Grace:\n//   a water surface spawning a droplet that comes out, then splashes back down.\n\nconst float PI = 3.14159;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (uv * 2. - 1.) * 5.; // center at origin and zoom out.\n    \n    // By keeping a's and b's cycles out of close sync, the idea is to\n    // cover a bigger variety of curve shapes over time.\n    float a = -0.5 - 8.5 * cos(iTime), b = 0.5 + 8.5 * cos(iTime * 0.71415);\n    \n\t// fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    float delta = -uv.y * uv.y + uv.x * uv.x * uv.x + a * uv.x + b;\n    float ad = abs(delta);\n\n    const float hueChange = 1.;\n    float r1 = sin(ad * hueChange + iTime) * 0.5 + 0.5;\n    float g1 = sin(ad * hueChange + iTime + PI * 2. / 3.) * 0.5 + 0.5;\n    float b1 = sin(ad * hueChange + iTime + PI * 4. / 3.) * 0.5 + 0.5;\n\n    // JG wanted rainbow colors.\n    // Rainbow on black:\n    // fragColor = vec4(r1, g1, b1, 1.0) * pow(0.8, ad*5.);\n    // Rainbow on white:\n    fragColor = mix(vec4(r1, g1, b1, 1.0), vec4(1.0), 1. - pow(0.2, ad));\n\n    // a little fancy coloring...\n    // fragColor = vec4(ad, pow(abs(delta), 0.16), pow(abs(delta), 0.1), 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}