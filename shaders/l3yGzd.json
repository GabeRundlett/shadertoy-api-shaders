{
    "Shader": {
        "info": {
            "date": "1718067051",
            "description": "Lets see what happens if we combine the two =)",
            "flags": 0,
            "hasliked": 0,
            "id": "l3yGzd",
            "likes": 16,
            "name": "line of your magic (flashback)",
            "published": 3,
            "tags": [
                "fractal",
                "magic",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "orblivius",
            "viewed": 468
        },
        "renderpass": [
            {
                "code": "// Fork of \"line of your magic\" by nayk. https://shadertoy.com/view/M3V3Rc\n// 2024-06-11 00:50:37\n\n/*originals \ncombination from many sources Iâ€™m just learning myself\nAt least someone somewhere has won, \njust as we will win. Where success accompanies all of you, \nsuccess accompanies that they do not fight with us\n\nMIT LICENSE\n/**\n\t\"fan/repeat\" - https://www.shadertoy.com/view/4ldXzf\n\t(c) 2018 bergi\n\t\n\tmodulo in space and time\n\n\tmore precisely, modulo applied to cartesian and polar coordinates\n    distorting \"an image\" consisting of lines and dots.\n\tparameters taken from hand-picked lists of various lengths\n\tusing time modulo pattern length.\n*/\n\n\n\n\n#define STEPS 150.0\n#define MDIST 150.0\n#define pi 3.1415926535\n#define iBeatAvg 0.5\n#define iBeatTHR 0.1\n#define iBPM 120.\n\n#define pmod(p,x) (mod(p,x)-0.5*(x))\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\n#define r(a) mat2 (cos(a + vec4(0,33, 11,0)));\n#define R(p, T) p.yx *= r(round((atan(p.y, p.x) + T) * 1.91) / 1.91 - T)\nvec3 glow = vec3(0);\n\n#define bpm ((iBeatAvg>=iBeatTHR) ? ((iBPM>0.)?120./iBPM:0.5):0.25)\nvec2 fan(in vec2 pos, in float q) \n{\n    q = q / 180. * 3.14159265;\n    float ang = atan(pos.x, pos.y),\n    len = length(pos.xy);\n    ang = mod(ang + q/2., q) - q/2.;\n    pos.xy = len * vec2(sin(ang), cos(ang));\n    return pos;\n}\n\n/** repeat the position in 'pos' every 'q' units */\nvec2 repeat(in vec2 pos, in vec2 q) \n{\n    pos.xy = mod(pos.xy + q/2., q) - q/2.;\n    return pos;\n}\n\n/** combination of fan and repeat calls, controlled by the 'scene' parameter. \n    scene is range 0 to 3*5*6*7*11-1\n*/\nvec2 fan_repeat(in vec2 uv, in int scene) \n{\n    uv = fan(uv, float[5](120., 90., 60., 45., 30.)[scene % 5]);\n    uv = repeat(uv, vec2(\n        float[3](2., 3., 4.)[scene%3],\n        float[7](1., 3., 5., 2., 4., 5., 2.)[scene%7]));\n    uv = fan(uv, float[11](120., 90., 60., 30., 45., 12.5, 120., 180., 60., 30., 45.)[scene % 11]);\n    uv = repeat(uv, vec2(\n        float[6](1., 3., 1., 4., 3., 5.)[scene%6],\n        float[5](1., 4., 1., 3., 2.)[scene%5]));\n    \n\treturn uv;\n}\n\n\n/** a dull image with some variation through 'scene' */\nvec3 img(in vec2 uv, in int scene)\n{\n    vec3 col = vec3(0.);\n    \n    vec3 c1 = vec3[3](\n        vec3(1., .7, .4), vec3(.4, .9, .3), vec3(.2, .5, 1.)\n    )[scene%3];\n    vec3 c2 = vec3[4](\n        vec3(.3, .5, .6), vec3(.4, .2, .3), vec3(.1, 1., .2), vec3(.2, .5, 1.)\n    )[scene%4];\n    vec3 c3 = vec3[5](\n        vec3(.9, .5, .1), vec3(.4, .9, .1), vec3(.1, .6, 1.), vec3(.9, .3, 1.), vec3(.5, .5, .5)\n    )[scene%5];\n    \n    float step1 = float[3](.01, .02, .1)[scene%3];\n    float step2 = float[4](.01, .02, 0.05, .1)[scene%4];\n    float step3 = float[5](.01, .02, 0.2, 0.03, .1)[scene%5];\n    float step4 = float[6](.01, .02, 0.03, 0.04, 0.05, .1)[scene%6];\n    \n    col += c1 * smoothstep(step2,0., length(uv.xy) - float[3](0., 0.1, .2)[scene%3]);\n    col += c1 * smoothstep(step1,0., abs(uv.y-.6)-0.02);\n    col += c2 * smoothstep(step4,0., abs(uv.x)-0.02);\n    col += c3 * smoothstep(step3,0., abs(uv.y-.3)-0.02);\n    \n    return col;\n}\n\n\nfloat box(vec3 p, vec3 b){\n    vec3 d = abs(p)-b;\n     d.xy*=rot(iTime);\n    return max(d.x,max(d.y,d.z));\n}\n\n\n\nvec2 pmodp(vec2 p, float x){\n    float a = atan(p.y,p.x);\n    a = mod(a-x/2.,x)-x/2.;\n    return vec2 (cos(a),sin(a))*length(p);\n}\nfloat vSeg(vec3 p, float h, float r){\n  p.y -= clamp(p.y, 0.0, h);\n   p.x *= clamp(p.x, 0.0, h);\n  return length(p)-r;\n}\n\nvec2 map(vec3 p){\n    vec2 a = vec2(1);\n    vec2 b = vec2(22);\n    vec3 po = p;\n    float t= iTime;\n   \n\n    //Log-polar mapping from\n    //https://www.osar.fr/notes/logspherical/\n    vec2 p2 = p.xz;\n    float r = length(p2);\n    p2 = vec2(log(r),atan(p2.y,p2.x));  \n    float scl = 12.0/pi;\n   \n    t*=0.065;\n    p2.y+=t;\n    float yoff = 0.5;\n\n \n   \n    p2 *= scl;\n   \n    vec2 id = vec2(floor((p2.x)/1.5)+0.5,floor(p2.y/1.5)+0.5);\n   ;\n    p2 = pmod(p2,1.5);\n\n \n   \n    float dSpd = 10.0;\n    float uSpd = 10.0;\n   \n    //apply up/down warp-in motion\n    float ring =smoothstep(6.0,9.0,id.x-t*scl*(2.0/3.0))*yoff*dSpd*floor(mod(id.x,2.0));\n          ring -= smoothstep(6.0,9.0,id.x-t*scl*(2.0/3.0))*yoff*uSpd*floor(mod(id.x+1.0,2.0));\n    p.y -= ring;\n   \n    float mul = r/(scl);\n   \n    vec3 p3 = vec3(p2.x, p.y/mul,p2.y);\n \n    //======BEGIN NON-DOMAIN WARPED SDF======  \n   \n    //Boxes\n    a.x = box(p3,vec3(0.6,0.6+0.15,0.6));\n    a.x = max(a.x,-box(p3,vec3(3.0*cos(iTime),0.3,0.3)));\n    //a.x-=0.1;\n   \n    //anti overstep artifact hidden stuff\n        vec3 d = abs(p3)-1.0;\n        float outerBox = max(d.x,d.z);    \n        if(length(po.xz)>0.1) a.x = min(-outerBox,a.x);\n   \n    //=======END NON-DOMAIN WARPED SDF=======\n    a.x*=mul;\n   \n    //if(length(po.xz)<0.3) a.x = 0.1;\n    a.x = max(a.x,(length(p.xz)-20.0));\n    a.x = max(a.x,-(length(p.xz)-0.3)); //this ended up being useless\n   \n    p = po;\n    //GLOWY BEAM THING\n    b.x = length(p.xz)-0.8-sin(p.y-t*10.0)*0.2-sin(p.y*0.3-t*20.0)*0.2-abs(p.y)*0.2;\n    glow+=vec3(0.529,0.400,1.000)*0.1/(0.1+b.x*b.x);\n   \n    a =(a.x<b.x)?a:b;\n   \n   \n    float alpha = atan(p.z,p.x);\n    p.y = abs(p.y)-9.0*cos(iTime);\n \n    p-=vec3(17,sin(alpha*3.0-t)*cos(iTime)*2.0,24.*cos(iTime));\n\n    p.y+=2.;\n     \n\n    b.y = 3.0*cos(iTime);\n    a =(a.x<b.x)?a:b;\n\n    return a;\n}\n\n\nvec3 norm(vec3 p, float s){\n    vec2 e= vec2(s,0);\n    return normalize(vec3(\n    map(p+e.xyy).x,map(p+e.yxy).x,\n    map(p+e.yyx).x)-vec3(map(p-e.xyy).x,\n    map(p-e.yxy).x,map(p-e.yyx).x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n \n    vec3 ro = vec3(10.,10.,-20.0);\n   ro.xz*=rot(iTime);\n    vec3 lk = vec3(0,1,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(1,1,0),f));\n    vec3 rd = normalize(f*0.7+uv.x*r+uv.y*cross(f,r));\n     r.yz*=rot(iTime);\n    float dO, shad;\n    bool hit = false;\n    vec2 d; vec3 p;\n    d.yx*=rot(iTime);\n    for(float i = 0.0; i<STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        dO+= d.x*0.85;\n       \n        if(abs(d.x)<0.005){\n            shad = i/STEPS;\n            hit = true;\n            break;\n        }\n        if(dO>MDIST){\n            dO = MDIST; break;\n        }\n    }\n    float i, t = 0.0, dd, k = iTime / 8.0;\n\n    vec4 O = vec4(0,0,0,1);\n    vec2 R = iResolution.xy;\n    vec3 pp;\n    vec2 F = fragCoord;\n\n    for (i = 0.0; i < 20.0; i++) {\n        pp = vec3(F + F - R, R.y);\n        pp = normalize(pp) * t;\n        pp.z -= 3.0;\n        pp.xz *= r(k + 0.1);\n        pp.zy *= r(k + k);\n        dd = length(pp)- sin(k + k) * .5 - 0.4;\n\n        pp.y += sin(pp.x * cos(k + k) + k * 4.0) * sin(k) * 0.3;\n        R(pp.xy, 0.0);\n        R(pp.xz, k);\n        pp.x = mod(pp.x + k * 8.0, 2.0) - 1.0;\n        t += dd = min(dd, length(pp.yz) - 0.03) * 0.5;\n\n        O += 0.01 * (cos(t - k + vec4(0, 1, 3, 0))) / (length(pp) - 0.02) + (0.025 + sin(k) * 0.01) / (0.8 + dd * 24.0);\n         }\n    if(hit){\n        vec3 n = norm(p,0.02);\n        float edge = length(n-norm(p,0.12))*min(1.0,length(p)*0.2);\n        //edge =smoothstep(0.,0.15,edge);\n       \n        if(d.y == 1.0) col = vec3(0.388);\n        if(d.y == 2.0) col = vec3(0.502,0.000,1.000);\n        if(d.y == 3.0) col = vec3(0.388);\n       \n        //Shamelessly stealing blackle's lighting techniques\n        float ao = smoothstep(-.1,.1,map(p+n*.1).x)*\n                   smoothstep(-.3,.3,map(p+n*.3).x)*\n                   smoothstep(-.7,.7,map(p+n*.7).x);\n        vec3 r = reflect(rd, n);\n        float diff = length(sin(n*3.)*.7+.3)/sqrt(3.);\n        float spec = length(sin(r*3.)*.5+.5)/sqrt(3.);\n        float fres = 1.-abs(dot(rd,n))*.95;\n        col = col*pow(diff,3.0) + pow(spec, 12.)*fres*vec3(0.463,0.490,0.898);\n        col*=ao;\n       \n        if(d.y == 1.0)col+=smoothstep(0.,0.1,edge)*vec3(0.188,0.804,0.910);\n        if(d.y == 3.0)col+=smoothstep(0.,0.15,edge)*vec3(0.659,0.188,0.910)*10.0;\n    }\n    O.rgb *=  O.rgb; //pow(O.rgb,vec3(1.8));\n\n    vec2 uvv = (fragCoord.xy - .5*iResolution.xy) / iResolution.y * 2.;\n\t    \n    uvv *= 5.;\n    \n    uvv = fan_repeat(uvv, int(iTime*3.*bpm));\n    vec3 col3 = img(uvv, int(iTime*6.*bpm));\n\n\n\n    col = mix(col,mix(vec3(0.075),vec3(0.),length(uv)),dO/MDIST);\n    col=col3*0.5*(hit?0.:1.)+col*(hit?.8:0.)+col*(-glow*.3)*(1.-O.a)+(glow+col)*O.rgb*(hit?1.:0.4);\n    fragColor = vec4(col,1.0);\n\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}