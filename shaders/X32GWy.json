{
    "Shader": {
        "info": {
            "date": "1708817128",
            "description": "Distance field to the Lemniscate of Bernoulli. I used the bisection method to estimate the root. Tried to do this exclusively in polar coords, but had to use cartesian for getting the sign. Anybody know how to fix slim blue line on x-axis?",
            "flags": 0,
            "hasliked": 0,
            "id": "X32GWy",
            "likes": 2,
            "name": "Lemniscate Bernoulli(bisection)",
            "published": 3,
            "tags": [
                "sdf",
                "lemniscate"
            ],
            "usePreview": 0,
            "username": "Mermersk",
            "viewed": 134
        },
        "renderpass": [
            {
                "code": "/*\n    Author: Mermersk (ic4ruz39@gmail.com)\n*/\n\n#define PI 3.1415926\n#define PI2 6.283186\n#define a (2.8 + sin(iTime*0.6)*0.5)\n\n//returns the distance for each angle to the lemniscate line-position. a controls the size of it.\nfloat basicLemniscate(float angle) {\n    float lemniR = a*a*cos(2.0*angle);\n    return lemniR;\n}\n\n//Polar distance formula, between 2 points:\nfloat polarDist(vec2 p1, vec2 p2) {\n    return sqrt(p1.x*p1.x + p2.x*p2.x - 2.0*p1.x*p2.x*cos(abs(p2.y - p1.y)));\n}\n\nfloat lemniD5(vec2 puv) {\n   \n   float bracket1 = 0.0;\n   //Its enough to check from 0 to 0.785. (We are only calculating for 1 quadrant(where x and y is +) all other quadrants are mirror of this)\n   float bracket2 = PI*0.25;\n   float midPoint = (bracket1 + bracket2) / 2.0;\n   \n   //Bisection method\n   for (int i = 0; i < 9; i++) {\n        //This is the derivative of polar distance formula where lemniscate equation is injected in for angle2. Found derivative via WolframAlpha.\n        float midPointVal = a*a*puv.x*(sin(puv.y + midPoint) - 3.0*sin(puv.y - 3.0*midPoint)) - 2.0*a*a*a*a*sin(4.0*midPoint);\n        \n        int gsign = midPointVal > 0.0 ? 1 : -1;\n        \n        if (gsign == 1) {\n            bracket2 = midPoint;\n        } else {\n            bracket1 = midPoint;\n        }\n        \n        midPoint = (bracket1 + bracket2) / 2.0;\n   }\n   \n   vec2 posOnLmeniscateClosest = vec2(basicLemniscate(midPoint), midPoint);\n   \n   float d = polarDist(posOnLmeniscateClosest, puv);\n   \n   //Give distance field the right sign, - inside and + outside. Donw know yet how to do this part in polar coordinates.\n   vec2 puvCart = vec2(puv.x * cos(puv.y), puv.x * sin(puv.y));\n   vec2 polcCart = vec2(posOnLmeniscateClosest.x * cos(posOnLmeniscateClosest.y), posOnLmeniscateClosest.x * sin(posOnLmeniscateClosest.y));\n   \n   /*\n       This is the vector from the lemniscate to some pixel position in cartesian where the distance is the smallest.\n       If its y component is negative, then it must be inside of the lemniscate bubble.\n   */\n   vec2 lemniscateToPos = puvCart - polcCart;\n   d = sign(lemniscateToPos.y) * d;\n   \n   return d;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv = (uv * 2.0) - 1.0;\n    \n    float ar = iResolution.x/iResolution.y;\n    \n    uv.x *= ar;\n    \n    uv *= 7.0;\n    \n    vec3 col = vec3(0.0);\n    \n    uv = vec2(abs(uv.x), abs(uv.y));\n    \n    vec2 polarUV = vec2(length(uv), atan(uv.y, uv.x));\n    \n    float d = lemniD5(polarUV);\n    \n    // Distance field coloring from IQ\n    col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.7 + 0.2*cos(30.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.15,abs(d)) );\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}