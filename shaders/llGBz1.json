{
    "Shader": {
        "info": {
            "date": "1541779910",
            "description": "a 2d slice of a 3d octree truchet",
            "flags": 0,
            "hasliked": 0,
            "id": "llGBz1",
            "likes": 14,
            "name": "octree truchet slice",
            "published": 3,
            "tags": [
                "2d",
                "truchet",
                "3dslice"
            ],
            "usePreview": 0,
            "username": "abje",
            "viewed": 625
        },
        "renderpass": [
            {
                "code": "//5 is maybe a little too much, 3 is fine\n#define limit 3.0\n\n#define HASHSCALE3 vec3(.6531, .5563, .7498)\n\n#define dot2(p) dot(p,p)\n\n//hash function in hash without sine by Dave_Hoskins\n//https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z*15.3023+0.434);\n}\n\n#define checktree(k)                        \\\nfor (j = 0.0; j < k; j++) {             \\\n    vec3 h = floor(r*exp2(j))*exp2(-j); \\\n    float rand = hash13(h+exp2(-j-1.0));\\\n    if (rand >= 0.5) {                 \\\n        break;                          \\\n    }                                   \\\n}\n\nfloat squarering(vec3 p, float size) {\n    vec2 q = vec2(abs(length(p.xy)-0.5),abs(p.z));\n    float len = length(max(q-size,0.0))+min(max(q.x,q.y)-size,0.0);\n    return len;\n}\n\nfloat truchet(vec3 p, int type) {\n    vec3 q = abs(p-0.5);\n\t\n    vec3 q2 = vec3(min(min(q.x,q.y),q.z),0,max(max(q.x,q.y),q.z));\n    q = min(q,q.yzx);\n    q2.y = max(max(q.x,q.y),q.z);\n\n    float inside = length(abs(q2.yz-vec2(0.0,0.5)))-0.1667;\n    float inside2 = length(abs(max(q2.yz-vec2(0.0,0.5),0.0)))-0.1667;\n    float outside = length(abs(q2.yz-vec2(0.5,0.5)))-0.3333;\n    \n    float len;\n    //len = min(len, squarering(p.xyz-vec3(0,0,0.5)));\n    //len = min(len, squarering(p.yzx-vec3(1,0,0.5)));\n    //len = min(len, squarering(p.zxy-vec3(1,1,0.5)));\n    if (type == 0) {\n        len = -outside;\n    } else if (type == 1) {\n        len = inside;\n    } else if (type == 2) {\n        len = inside2;\n    } else if (type == 3) {\n        float size = 0.1667-0.1+q2.z*0.2;\n        len = squarering(p.xyz-vec3(0,0,0.5),size)*0.9;\n        len = min(len, squarering(p.yzx-vec3(1,0,0.5),size)*0.9);\n        len = min(len, squarering(p.zxy-vec3(1,1,0.5),size)*0.9);\n    }\n    \n    \n    return len;\n}\n\nfloat map(vec3 p) {\n    \n    vec3 fp;\n    vec3 lp;\n    float len;\n    float i;\n    \n    //r is the truchet cell you want the random \n    vec3 r = p;\n    float j;\n    checktree(limit);\n    i = j;\n    float size = exp2(-i);\n    //the position in the bottom left corner of the truchet cell\n    fp = floor(p/size)*size;\n\n    //the local position on the truchet cell (always 0-1)\n    lp = fract(p/size);\n    \n    int type = int(hash13((fp+size*0.5)*vec3(0.93,0.89,1.23))*4.0);\n    len = truchet(lp,type)*size;\n    \n    while (i <= limit) {\n        //the position in the bottom left corner of the truchet cell\n        fp = floor(p/size)*size;\n        //the local position on the truchet cell (always 0-1)\n        lp = fract(p/size);\n        //check for the overlapping black dots\n        vec3 p2 = p/size;\n        vec3 fp2 = floor(p2-0.5);\n        for(int x = -0; x <= 1; x++) {\n            for(int y = -0; y <= 1; y++) {\n                for(int z = -0; z <= 1; z++) {\n                    r = (fp2+vec3(x,y,z))*size;\n                    //this branch doesn't do anything, but it skips the random() once\n                    if (r != fp)\n                    {\n                        checktree(i);\n\n                        if (i==j) {\n                            vec3 q = abs(p2-fp2-vec3(x,y,z)-0.5);\n                            \n                            vec3 q2 = vec3(min(min(q.x,q.y),q.z),0,max(max(q.x,q.y),q.z));\n                            q = min(q,q.yzx);\n                            q2.y = max(max(q.x,q.y),q.z);\n                            \n                            float outside = length(abs(q2.yz-vec2(0.5,0.5)))-0.3333;\n                            \n                            len = max(-outside*size,len);\n                        }\n                    }\n                }\n            }\n        }\n        size *= 0.5;\n        len *= -1.0;\n        i++;\n    }\n    return len;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord.xy*2.0-iResolution.xy)/iResolution.y;\n    \n    \n    fragColor = vec4(map(vec3(uv,iTime*0.1))*iResolution.y*0.5);\n    \n    fragColor = sqrt(fragColor);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}