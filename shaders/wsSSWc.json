{
    "Shader": {
        "info": {
            "date": "1555085229",
            "description": "Finds the nearest intersection between a ray and a rounded cube.",
            "flags": 0,
            "hasliked": 0,
            "id": "wsSSWc",
            "likes": 4,
            "name": "rounded cube intersection",
            "published": 3,
            "tags": [
                "raytracing",
                "roundedcube"
            ],
            "usePreview": 0,
            "username": "abje",
            "viewed": 738
        },
        "renderpass": [
            {
                "code": "#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\n#define FAR 1000.0\n\n#define antialiasing 16\n\nfloat seed = 0.0;\nvec2 fragUV = vec2(0.0);\nfloat rand() \n{\n\tfloat r = fract(sin(dot(fragUV, vec2(12.9898, 78.233)) + seed) * 43758.5453);\n\tseed++;\n    return r;    \n}\n\n//mask is 1.0/(ellipsoid size)\nvec2 ellipsoid(vec3 ro, vec3 rd, vec3 mask) {\n    mask = max(mask, 0.01);\n    \n    ro *= mask;\n    rd *= mask;\n    \n    float e = 1.0/dot(rd,rd);\n    float b = -dot(rd,ro)*e;\n    vec3 p = ro+rd*b;\n    float a = dot(p,p);\n    if (a > 1.0) return vec2(1000,999);\n    float c = sqrt((1.0-a)*e);\n    \n    return b+vec2(-c,c);\n}\n\n//box intersection from iq\n//https://www.shadertoy.com/view/ld23DV\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad) \n{\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n\tfloat tN = max(max( t1.x, t1.y ), t1.z);\n\tfloat tF = min(min( t2.x, t2.y ), t2.z);\n\n\treturn vec2(max(tN,0.0), tF);\n}\n\nfloat solve(vec2 l) {\n    if (l.x > l.y) l.x = FAR;\n    return l.x;\n}\n\nvec4 roundedcube(vec3 ro, vec3 rd, vec3 size, vec3 radius) {\n    \n    vec2 l = iBox(ro,rd,size+radius);\n    \n    if (l.x > l.y) return vec4(FAR,0,0,0);\n    \n    // inverted radius for the ellipsoid intersection\n    radius = 1.0/radius;\n    \n    vec3 p = ro+rd*l.x;\n\n    vec3 s = sign(p);\n    vec3 m = step(size,p*s);\n    m = m.yzx*m.zxy;\n    \n    float d = 0.0;\n    \n    vec3 cyl = ro-s*size;\n    \n    if (m.x > 0.5) {\n        l.x = max(l.x,solve(ellipsoid(cyl,rd,vec3(0,1,1)*radius)));\n    }\n    if (m.y > 0.5) {\n        l.x = max(l.x,solve(ellipsoid(cyl,rd,vec3(1,0,1)*radius)));\n    }\n    if (m.z > 0.5) {\n        l.x = max(l.x,solve(ellipsoid(cyl,rd,vec3(1,1,0)*radius)));\n    }\n\n    p = ro+rd*l.x;\n\n    s = sign(p);\n    if (all(lessThan(size,p*s)))\n        l.x = max(l.x,solve(ellipsoid(ro-s*size,rd,radius)));\n    \n    p = ro+rd*l.x;\n    \n    vec3 n = max(abs(p)-size,0.0)*radius*sign(p);\n    \n    return vec4(l.x,n);\n}\n\nvec3 background(vec3 n) {\n    float a = max(0.0,dot(n,normalize(vec3(0.4,-0.5,0.7))));\n    float b = max(0.0,dot(n,normalize(vec3(-0.8,0.2,0.4))));\n\n    vec3 col = vec3(a*vec3(0.8,1,0.4)+b*vec3(0.8,0.2,0.65));\n    col = max(col,vec3(0.1,0.4,0.2));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragUV = fragCoord / iResolution.xy;\n    seed = iTime;\n    \n    vec3 acc = vec3(0);\n    for (int aa = 0; aa < antialiasing+min(iFrame,0); aa++) {\n#if antialiasing==1\n        vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n#else\n        vec2 uv = ((fragCoord+vec2(rand(),rand()))*2.0-iResolution.xy)/iResolution.y;\n#endif\n\n        vec3 ro = vec3(0,0,-4);\n        vec3 rd = vec3(uv,1);\n\n        if (length(iMouse.xy) > 40.0) {\n            rd.yz *= rot(iMouse.y/iResolution.y*3.14-3.14*0.5);\n            rd.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n            ro.yz *= rot(iMouse.y/iResolution.y*3.14-3.14*0.5);\n            ro.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n        }\n\n        vec4 d = roundedcube(ro,rd,vec3(0.6+sin(iTime)*0.4,0.8+cos(iTime)*0.5,0.5),vec3(0.3,0.3,0.3));\n\n        vec3 col;\n\n        if (d.x < FAR) {\n            vec3 p = ro+rd*d.x;\n\n            vec3 n = d.yzw;\n\n            col = vec3(max(dot(n,normalize(vec3(1,1,-1))),0.1));\n\n            vec3 r = reflect(rd,n);\n\n            col += background(r)*0.12;\n        } else {\n\n            col = background(rd);\n        }\n        acc += col;\n    }\n    acc /= float(antialiasing);\n    fragColor = vec4(sqrt(acc),1);\n}\n\n/* old intersector\n\nvec2 roundedcube(vec3 ro, vec3 rd) {\n    vec3 ird = 1.0/rd;\n    \n    vec3 lens = -ro*ird;\n    \n    vec3 near = lens-abs(ird)*bound;\n    vec3 far = lens+abs(ird)*bound;\n    \n    vec2 res = vec2(max(max(max(near.x,near.y),near.z),0.0),\n                        min(min( far.x, far.y), far.z));\n    \n    vec2 d3 = vec2(10000.0,0.0);\n    \n    float d = res.x;\n    \n    if (d < res.y) {\n        vec3 p = ro+rd*d;\n        \n        vec3 q = abs(p);\n        vec3 f = step(size,q)*sign(p);\n        vec3 lens = -p*ird;\n        \n        vec3 a = max(lens+ird*size,-1.0);\n        a += step(0.0,-a)*10000.0;\n        vec3 b = max(lens-ird*size,-1.0);\n        b += step(0.0,-b)*10000.0;\n        \n        for (int i = 0; i < 7; i++) {\n            float d2 = d;\n            vec3 c = min(a,b);\n\n            vec3 m;\n            if (c.x < min(c.y,c.z)) {\n                m = vec3(1,0,0);\n            } else if (c.y < c.z) {\n                m = vec3(0,1,0);\n            } else {\n                m = vec3(0,0,1);\n            }\n\n            float l = dot(c,m);\n            \n            a -= l;\n            b -= l;\n            \n            if (dot(a,m) < dot(b,m)) {\n                a += m*10000.0;\n            } else {\n                b += m*10000.0;\n            }\n            \n            d = d + l;\n\n            vec2 s = max(ellipsoid((ro+rd*d2)-f*size,rd,abs(f)/radius),0.0);\n            \n            if (s.x < s.y) {\n                if (d2+s.x < d) {\n                \td3.x = min(d3.x, d2+s.x);\n                }\n                if (d2+s.y < d) {\n                    d3.y = max(d3.y, d2+s.y);\n                }\n            } else if (d > res.y) {\n                break;\n            }\n\n            \n            f += sign(rd)*m;\n        }\n        \n    }\n    \n    return d3;\n}*/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}