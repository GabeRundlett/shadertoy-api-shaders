{
    "Shader": {
        "info": {
            "date": "1633276530",
            "description": "This is a two-state cellular automata based on a hexagonal neighborhood and the B2/S34 rulestring that shows how to reference the previous frame of the same buffer to maintain state across generations.",
            "flags": 32,
            "hasliked": 0,
            "id": "fs3SD7",
            "likes": 4,
            "name": "cellular automata hexagonal life",
            "published": 3,
            "tags": [
                "hexagonal",
                "gameoflife",
                "cellularautomata",
                "rulestring"
            ],
            "usePreview": 0,
            "username": "remaindeer",
            "viewed": 379
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // output Buffer A\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define N   100.0\n#define P   0.45\n#define ON  0.75\n#define OFF 0.25\n\n#define cos30 cos(radians(30.0))\n#define sqrt3 sqrt(3.0)\n\n#define width 0.125\n\nfloat cross2(vec2 p, vec2 q)\n{\n    return p.x * q.y - p.y * q.x;\n}\n\nbool intri(vec2 uv, vec2 v1, vec2 v2, vec2 v3)\n{\n    // https://mathworld.wolfram.com/TriangleInterior.html\n    // http://www.sunshine2k.de/coding/java/pointInTriangle/pointInTriangle.html\n    vec2 w1 = v2 - v1;\n    vec2 w2 = v3 - v1;\n    float d = determinant(mat2(w1, w2));\n    // check for d â‰ˆ 0.0 ?\n    float s = determinant(mat2(uv - v1, w2)) / d;\n    float t = determinant(mat2(w1, uv - v2)) / d;\n    return s >= 0.0 && t >= 0.0 && (s + t) <= 1.0;\n}\n\nbool inreg(vec2 uv, vec2 c, float n, float R, float theta)\n{\n    // break-up regular polygon into triangles\n    float dt = radians(360.0 / n);\n    for (float i = 0.0, j = 1.0; i < n; i++, j++)\n    {\n        vec2 a = R * vec2(cos(dt * i + theta), sin(dt * i + theta)) + c;\n        vec2 b = R * vec2(cos(dt * j + theta), sin(dt * j + theta)) + c;\n        if (intri(uv, a, b, c))\n            return true;\n    }\n    return false;\n}\n\nfloat random (vec2 st)\n{\n    // https://thebookofshaders.com/10/\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    // default to time varying pixel color\n    vec3 col = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0, 2, 4));\n    // compute circular cell radius\n    float R = 1.0 / N;\n    float r = R * cos30;\n    // calculate central cell coordinate\n    //// hexagonal grid basis\n    vec2 hvec = vec2(2.0 * r, 0.0);\n    vec2 kvec = vec2(r, 1.5 * R);\n    float theta = 30.0;\n    mat2 b = mat2(hvec, kvec);\n    vec2 cell = b * round(inverse(b) * uv);\n    //// substract some radius to add width\n    R -= R * width;\n    bool inhex = inreg(uv, cell, 6.0, R, radians(theta));\n    //// adjust hex coordinate due to overlap\n    if (!inhex)\n        if (cross2(vec2(r, 0.5 * R), cell - uv) < 0.)\n            cell += (uv.x > cell.x) ? kvec : -hvec;\n        else\n            cell += (uv.x > cell.x) ? hvec : -kvec;\n    // update cell state if it contains the uv\n    if (inhex || inreg(uv, cell, 6.0, R, radians(theta))) {\n        if (iFrame < 60) {\n            // set random initial state\n            col = vec3(fract(random(iTime + cell * iTime)) <= P ? ON : OFF);\n        } else {\n            // get ON/OFF state of hexagonal neighborhood\n            int nw = int(texture(iChannel0, cell + vec2(-(1.0 * r), +(1.5 * R))).rgb == vec3(ON));\n            int ne = int(texture(iChannel0, cell + vec2(+(1.0 * r), +(1.5 * R))).rgb == vec3(ON));\n            int wc = int(texture(iChannel0, cell + vec2(-(2.0 * r), (0.000000))).rgb == vec3(ON));\n            int cc = int(texture(iChannel0, cell + vec2((0.000000), (0.000000))).rgb == vec3(ON));\n            int ec = int(texture(iChannel0, cell + vec2(+(2.0 * r), (0.000000))).rgb == vec3(ON));\n            int sw = int(texture(iChannel0, cell + vec2(-(1.0 * r), -(1.5 * R))).rgb == vec3(ON));\n            int se = int(texture(iChannel0, cell + vec2(+(1.0 * r), -(1.5 * R))).rgb == vec3(ON));\n            int n = nw + ne + wc + ec + sw + se;\n            // update state of current central cell\n            // https://www.conwaylife.com/wiki/Rulestring\n            // rule B2/S34\n            if (cc == 1) col = vec3((n == 3 || n == 4) ? ON : OFF);\n            else /*****/ col = vec3((n == 2) ? ON : OFF);\n        }\n    }\n    // output to screen\n    fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}