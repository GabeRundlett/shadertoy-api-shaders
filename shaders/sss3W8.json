{
    "Shader": {
        "info": {
            "date": "1615896383",
            "description": "from pjkarlik's question",
            "flags": 0,
            "hasliked": 0,
            "id": "sss3W8",
            "likes": 13,
            "name": "Bouncing Balls Example",
            "published": 3,
            "tags": [
                "balls",
                "parabola"
            ],
            "usePreview": 0,
            "username": "blackle",
            "viewed": 497
        },
        "renderpass": [
            {
                "code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nfloat box(vec2 p, vec4 b) {\n    p = abs(p-b.xy) - b.zw;\n    return length(max(p,0.))+min(0.,max(p.x,p.y));\n}\n\nfloat aa(float sdf) {\n    float pixelsize = 1./iResolution.y;\n    return smoothstep(-pixelsize, pixelsize, sdf);\n}\n\n//this function will return a position along a parabolic trajectory for a particular ball\n//that bounced off box1 and will end up on top of box2.\nvec2 ballPosForTime(float ballIdx, float bar, float t, vec4 box1, vec4 box2, float maxHeight, float ballSize) {\n    //to start, we generate random values between -1 and 1\n    float h1 = hash(ballIdx, bar+0.0);\n    float h2 = hash(ballIdx, bar+0.5);\n    float h3 = hash(ballIdx, bar+1.0);\n\n    maxHeight += box1.y;\n\n    //then we map those hash values to random points on our boxes\n    //the first point is the starting location of the ball, which will be\n    //on a random spot on the surface of the first box\n    float x1 = h1*(box1.z/2.)+box1.x;\n    float y1 = box1.y+box1.w+ballSize;\n\n    //the third, final point will be on a random spot on the surface\n    //of the second box\n    float x3 = h3*(box2.z/2.)+box2.x;\n    float y3 = box2.y+box2.w+ballSize;\n    \n    //the middle point, the point the ball passes between, will be the midpoint\n    //between the start and end points, and a little bit higher than the first box\n    float x2 = mix(x1, x3, .5);\n    float y2 = mix(y1, maxHeight, h2*.25+.75);\n    \n    //now we have three points that the ball must pass through, we can solve a system\n    //of linear equations to get a parabola that the ball can travel through\n    //that passes between all three points\n    vec3 column = vec3(x1, x2, x3);\n    mat3 system = mat3(column*column, column, vec3(1));\n    //these are our coefficients (a, b, c) for the formula a*x^2 + b*x + c\n    vec3 coeff = inverse(system) * vec3(y1, y2, y3);\n    \n    //we must map the time value to be between our start and end points\n    float x = mix(x1, x3, t);\n    float y = coeff.x*x*x + coeff.y*x + coeff.z;\n    \n    return vec2(x,y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    \n    //these define our boxes. the first 2 coords are the position,\n    //the second 2 coords are the dimensions\n    vec4 box0 = vec4( .25, .50, .2, .02);\n    vec4 box1 = vec4(-.25, .25, .2, .02);\n    vec4 box2 = vec4( .25, .00, .2, .02);\n    vec4 box3 = vec4(-.25,-.25, .2, .02);\n    vec4 box4 = vec4( .25,-.50, .2, .02);\n    float b1dist = box(uv, box1);\n    float b2dist = box(uv, box2);\n    float b3dist = box(uv, box3);\n    \n    //the bar is like a musical bar. it's how many times our cycle has repeated\n    float bar = floor(iTime);\n    //t is a number between 0 and 1 and is the time within the current cycle\n    float t = fract(iTime);\n    \n    float ballSize = 0.02;\n\n    //we need to find the position for all the balls on screen. this could be optimized\n    //by only finding the balls that could pass through the current uv coordinate\n    vec2 ballpos0 = ballPosForTime(0.-bar, bar, t, box0, box1, 0.2, ballSize);\n    float ball0dist = length(uv - ballpos0) - ballSize;\n\n    vec2 ballpos1 = ballPosForTime(1.-bar, bar, t, box1, box2, 0.2, ballSize);\n    float ball1dist = length(uv - ballpos1) - ballSize;\n\n    vec2 ballpos2 = ballPosForTime(2.-bar, bar, t, box2, box3, 0.2, ballSize);\n    float ball2dist = length(uv - ballpos2) - ballSize;\n\n    vec2 ballpos3 = ballPosForTime(3.-bar, bar, t, box3, box4, 0.2, ballSize);\n    float ball3dist = length(uv - ballpos3) - ballSize;\n    \n    float balls = min(min(ball0dist, ball3dist), min(ball1dist, ball2dist));\n    float boxes = min(b1dist, min(b2dist, b3dist));\n    float col = aa(min(boxes, balls));\n    fragColor = vec4(col);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}