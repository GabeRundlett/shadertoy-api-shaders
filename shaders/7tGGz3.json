{
    "Shader": {
        "info": {
            "date": "1638054809",
            "description": "Mouse: change strength of action (bottom left: base pose, top right: good walk).\n\nGraphs from Top to Bottom (dashed line shows strength of an action):\n- angles of left leg\n- angles of right leg\n- ankle.y of both legs\n- ankle.x of both legs",
            "flags": 0,
            "hasliked": 0,
            "id": "7tGGz3",
            "likes": 11,
            "name": "Walk 2d-n3 using Structs",
            "published": 3,
            "tags": [
                "mouse",
                "walk",
                "struct",
                "camtimer"
            ],
            "usePreview": 0,
            "username": "pyBlob",
            "viewed": 436
        },
        "renderpass": [
            {
                "code": "// Body Design and Base Animation by jorge2017a2: https://www.shadertoy.com/view/ftGGzy\n\nconst float     PI = radians(180.);\nconst float TWO_PI = 2. * PI;\n\nmat2 R(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    // https://iquilezles.org/articles/distfunctions2d\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp(dot(pa,ba) / dot(ba,ba), 0.0, 1.0);\n    return length(pa - ba*h);\n}\n\n\n//\n// Position structs\n//\n\nstruct XArm\n{\n    vec2 shoulder, elbow, hand;\n};\n\nstruct XLeg\n{\n    vec2 hip, knee, ankle, toe;\n};\n\nstruct XBody\n{\n    vec2 head;\n    XArm armLeft, armRight;\n    XLeg legLeft, legRight;\n};\n\nconst XArm xarm = XArm(\n    vec2(3, 12),\n    vec2(3, 9),\n    vec2(3, 6)\n);\n\nconst XLeg xleg = XLeg(\n    vec2(3, 8),\n    vec2(3, 5),\n    vec2(3, 2),\n    vec2(4, 2)\n);\n\nconst XBody xbody = XBody(\n    vec2(3, 13),\n    xarm, xarm,\n    xleg, xleg\n);\n\n\n//\n// Color structs\n//\n\nstruct ColArm\n{\n    vec3 upper, lower;\n};\n\nstruct ColLeg\n{\n    vec3 upper, lower, foot;\n};\n\nstruct ColBody\n{\n    vec3 head, spine;\n    ColArm armLeft, armRight;\n    ColLeg legLeft, legRight;\n};\n\nconst vec3 lightgreen = vec3(0,1,0);\nconst vec3 red = vec3(1,0,0);\nconst vec3 blue = vec3(0,0,1);\nconst vec3 pink = vec3(1,.3,.5);\nconst vec3 orange = vec3(1,.5,0);\nconst vec3 yellow = vec3(1,1,0);\nconst vec3 sky = vec3(.5,.7,1);\nconst vec3 water = vec3(.2,.7,1);\nconst vec3 gray = vec3(.5);\nconst vec3 black = vec3(0);\nconst vec3 white = vec3(1);\n\nconst ColBody colBody = ColBody(\n    sky, lightgreen,\n    ColArm(yellow, pink),\n    ColArm(lightgreen, orange),\n    ColLeg(lightgreen, pink, blue),\n    ColLeg(lightgreen, red, blue)\n);\n\n//\n// Drawing\n//\n\nvec3 drawOver(vec3 c, vec3 color, float r)\n{\n    float a = smoothstep(0., fwidth(r), r);\n    return mix(color, c, a);\n}\n\nvec3 drawGraph(vec3 c, vec2 uv, vec3 color, float y)\n{\n    y -= uv.y;\n    float a = smoothstep(0., fwidth(y), abs(y));\n    return mix(color, c, a);\n}\n\nvec3 drawDashed(vec3 c, vec2 uv, vec3 color, float y)\n{\n    y -= uv.y;\n    float a = smoothstep(0., fwidth(y), abs(y));\n\n    float dash = sin(uv.x/fwidth(uv.x)*TWO_PI/16.);\n    float b = smoothstep(0., fwidth(dash), dash);\n\n    return mix(color, c, max(a, b));\n}\n\nvec3 drawSegment(vec3 c, vec2 p, vec2 a, vec2 b, vec3 color, float radius)\n{\n    return drawOver(c, color, sdSegment(p, a, b) - radius);\n}\n\nconst float figureThickness = 0.04;\n\nvec3 drawArm(vec3 c, vec2 p, XArm xarm, ColArm colArm)\n{\n    c = drawSegment(c, p, xarm.shoulder, xarm.elbow, colArm.upper, figureThickness);\n    c = drawSegment(c, p, xarm.elbow   , xarm.hand , colArm.lower, figureThickness);\n    return c;\n}\n\nvec3 drawLeg(vec3 c, vec2 p, XLeg xleg, ColLeg colLeg)\n{\n    c = drawSegment(c, p, xleg.hip  , xleg.knee , colLeg.upper, figureThickness);\n    c = drawSegment(c, p, xleg.knee , xleg.ankle, colLeg.lower, figureThickness);\n    c = drawSegment(c, p, xleg.ankle, xleg.toe  , colLeg.foot , figureThickness);\n    return c;\n}\n\nvec3 drawCircle(vec3 c, vec2 p, vec2 center, float radius, vec3 color)\n{\n    return drawOver(c, color, distance(p, center) - radius);\n}\n\nvec3 drawBody(vec3 c, vec2 p, XBody xbody, ColBody colBody)\n{\n    c = drawArm(c, p, xbody.armLeft, colBody.armLeft);\n    c = drawLeg(c, p, xbody.legLeft, colBody.legLeft);\n    c = drawCircle(c, p, xbody.head, 0.5, colBody.head);\n    c = drawSegment(c, p, xbody.armLeft.shoulder, xbody.legLeft.hip, colBody.spine, figureThickness);\n    c = drawLeg(c, p, xbody.legRight, colBody.legRight);\n    c = drawArm(c, p, xbody.armRight, colBody.armRight);\n    return c;\n}\n\n\n//\n// Animation curves\n//\n\nvoid base_pose(out float ang1, out float ang2, out float ang3, float t, float r1, float r2, float r3)\n{\n    float t1, t2, t3;\n\n    t1=t;\n    t2=(1.0 + sin(t+PI));\n    t3=(1.0 + sin(t+PI));\n\n    ang1 = r1 * sin(t1);\n    ang2 = r2 * sin(t2);\n    ang3 = r3 * sin(t3);\n}\n\nvoid dont_trip_over(inout float f, inout float ang2, inout float ang3, float t)\n{\n    float lift = 1.2;\n    float drop = 4.7;\n    float b2 =  0.7;\n    float b3 = -0.9;\n\n    float phase = mod(t, TWO_PI);\n\n    // use this, to see where the action is active\n    // also helps with adjusting lift, drop, b2 and b3.\n    //if (lift < phase && phase < drop) ang2 += b2;\n    //if (lift < phase && phase < drop) ang3 += b3;\n\n    f *=\n      + smoothstep(lift, lift + 1.8, phase) // lift the leg smoothly\n      - smoothstep(drop - 1.5, drop, phase) // drop the leg smoothly\n      ;\n\n    // use this, to get the final smooth motion.\n    ang2 += b2 * f;\n    ang3 += b3 * f;\n}\n\nvoid horizontal_while_foot_on_ground(inout float f, inout float ang3, float t, float ang1, float ang2)\n{\n    float start = 4.7;\n    float duration = 2.8;\n\n    float phase = mod(t - start, TWO_PI);\n    \n    float angFlat = -ang1-ang2;\n\n    // use this, to see where the action is active\n    // also helps with adjusting start and duration.\n    //if (phase < duration) ang3 = angFlat-1.;\n\n    f *=\n      + smoothstep(0., 0.5, phase) // lift the leg smoothly\n      - smoothstep(duration - 1.2, duration, phase) // drop the leg smoothly\n      ;\n\n    // use this, to get the final smooth motion.\n    ang3 = mix(ang3, angFlat, f);\n}\n\n\n//\n// Action + Angle structs\n//\n\nstruct ActLeg\n{\n    float trip, ground;\n};\n\nstruct ActBody\n{\n    ActLeg legLeft, legRight;\n};\n\nstruct AngArm\n{\n    float shoulder, elbow;\n};\n\nstruct AngLeg\n{\n    float hip, knee, foot;\n    float fTrip, fGround;\n};\n\nstruct AngBody\n{\n    AngArm armLeft, armRight;\n    AngLeg legLeft, legRight;\n};\n\nAngLeg poseLeg(float t, ActLeg actLeg)\n{\n    float ang1, ang2, ang3;\n\n    base_pose(ang1, ang2, ang3, t, 0.6, 0.3, 0.2);\n    dont_trip_over(actLeg.trip, ang2, ang3, t);\n    horizontal_while_foot_on_ground(actLeg.ground, ang3, t, ang1, ang2);\n    \n    return AngLeg(ang1, ang2, ang3, actLeg.trip, actLeg.ground);\n}\n\nAngArm poseArm(float t)\n{\n    float ang1, ang2, ang3;\n\n    base_pose(ang1, ang2, ang3, t, 0.6, 0.2, 0.2);\n    \n    return AngArm(ang1, ang2);\n}\n\nAngBody poseBody(float t, ActBody actBody)\n{\n    return AngBody(\n        poseArm(t + .3                 ), poseArm(t + PI + .3                  ),\n        poseLeg(t     , actBody.legLeft), poseLeg(t + PI     , actBody.legRight)\n    );\n}\n\n\n//\n// Transforms\n//\n\nXArm bendArm(XArm xarm, AngArm angArm)\n{\n    vec2 v0 =                           xarm.shoulder;\n    vec2 v1 =              xarm.elbow - xarm.shoulder;\n    vec2 v2 = xarm.hand  - xarm.elbow                ;\n\n    vec2 q0 =                                          v0;\n    vec2 q1 = q0 + R(angArm.shoulder               ) * v1;\n    vec2 q2 = q1 + R(angArm.shoulder + angArm.elbow) * v2;\n\n    return XArm(q0, q1, q2);\n}\n\nXLeg bendLeg(XLeg xleg, AngLeg angLeg)\n{\n    vec2 v0 =                                      xleg.hip;\n    vec2 v1 =                          xleg.knee - xleg.hip;\n    vec2 v2 =             xleg.ankle - xleg.knee           ;\n    vec2 v3 = xleg.toe  - xleg.ankle                       ;\n\n    vec2 q0 =                                                  v0;\n    vec2 q1 = q0 + R(angLeg.hip                            ) * v1;\n    vec2 q2 = q1 + R(angLeg.hip + angLeg.knee              ) * v2;\n    vec2 q3 = q2 + R(angLeg.hip + angLeg.knee + angLeg.foot) * v3;\n\n    return XLeg(q0, q1, q2, q3);\n}\n\nXBody bendBody(XBody xbody, AngBody angBody)\n{\n    return XBody(\n        xbody.head,\n        bendArm(xbody.armLeft, angBody.armLeft),\n        bendArm(xbody.armRight, angBody.armRight),\n        bendLeg(xbody.legLeft, angBody.legLeft),\n        bendLeg(xbody.legRight, angBody.legRight)\n    );\n}\n\nfloat lowest_point_on_leg(XLeg xleg)\n{\n    return min(xleg.ankle, xleg.toe).y;\n}\n\nfloat lowest_point_on_body(XBody xbody)\n{\n    return min(lowest_point_on_leg(xbody.legLeft), lowest_point_on_leg(xbody.legRight));\n}\n\n//\n// Main\n//\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec3 col = gray;\n    \n    vec2 mouse = vec2(1);\n    if (iMouse.z > .5)\n        mouse = iMouse.xy / iResolution.xy;\n    \n    ActLeg actLeg = ActLeg(mouse.x, mouse.y);\n    ActBody actBody = ActBody(actLeg, actLeg);\n\n    float t = iTime;\n    AngBody angBody = poseBody(t, actBody);\n    XBody worldBody = bendBody(xbody, angBody);\n\n    // animation\n    {\n        float ground = lowest_point_on_body(worldBody);\n\n        vec2 uv = fragCoord / iResolution.y * 2.;\n        uv *= 7.;\n        uv -= vec2(2, 1. - ground);\n\n        col = drawBody(col, uv, worldBody, colBody);\n        col = drawSegment(col, uv - vec2(-0.8, ground), vec2(0, 0), vec2(6.5, 0), water, 0.08);\n    }\n    \n    // graphs\n    {\n        vec2 uv = (fragCoord + .5 - iResolution.xy / 2.) / iResolution.y * 2.;\n        uv -= vec2(.65, 0.);\n        uv /= 2.;\n\n        float t1 = uv.x * TWO_PI;\n        AngBody angBody1 = poseBody(t1, actBody);\n        XBody worldBody1 = bendBody(xbody, angBody1);\n        float ground1 = lowest_point_on_body(worldBody1);\n        \n        if (uv.x >= -.5 && uv.x <= +.5)\n        {\n            float phase = mod(t + PI, TWO_PI);\n            vec2 offset = vec2(.5, 0.);\n            vec2 scale = vec2(1. / TWO_PI, .1);\n\n            uv.y -= .35;\n            col = drawDashed(col, uv, colBody.legLeft.lower*.5, angBody1.legLeft.fTrip * .1);\n            col = drawDashed(col, uv, colBody.legLeft.foot*.5, angBody1.legLeft.fGround * .1);\n            col = drawGraph(col, uv, black, 0.);\n            col = drawGraph(col, uv, colBody.legLeft.upper, angBody1.legLeft.hip  * scale.y);\n            col = drawGraph(col, uv, colBody.legLeft.lower, angBody1.legLeft.knee * scale.y);\n            col = drawGraph(col, uv, colBody.legLeft.foot , angBody1.legLeft.foot * scale.y);\n\n            col = drawCircle(col, uv, vec2(phase, angBody.legLeft.hip )*scale-offset, .01, colBody.legLeft.upper);\n            col = drawCircle(col, uv, vec2(phase, angBody.legLeft.knee)*scale-offset, .01, colBody.legLeft.lower);\n            col = drawCircle(col, uv, vec2(phase, angBody.legLeft.foot)*scale-offset, .01, colBody.legLeft.foot );\n\n            uv.y += .25;\n            col = drawDashed(col, uv, colBody.legRight.lower*.5, angBody1.legRight.fTrip * .1);\n            col = drawDashed(col, uv, colBody.legRight.foot*.5, angBody1.legRight.fGround * .1);\n            col = drawGraph(col, uv, black, 0.);\n            col = drawGraph(col, uv, colBody.legRight.upper, angBody1.legRight.hip  * scale.y);\n            col = drawGraph(col, uv, colBody.legRight.lower, angBody1.legRight.knee * scale.y);\n            col = drawGraph(col, uv, colBody.legRight.foot , angBody1.legRight.foot * scale.y);\n\n            col = drawCircle(col, uv, vec2(phase, angBody.legRight.hip )*scale-offset, .01, colBody.legRight.upper);\n            col = drawCircle(col, uv, vec2(phase, angBody.legRight.knee)*scale-offset, .01, colBody.legRight.lower);\n            col = drawCircle(col, uv, vec2(phase, angBody.legRight.foot)*scale-offset, .01, colBody.legRight.foot );\n\n            uv.y += .25;\n            scale.y = .05;\n            col = drawDashed(col, uv, colBody.legLeft.lower*.5, angBody1.legLeft.fGround * .1);\n            col = drawDashed(col, uv, colBody.legRight.lower*.5, angBody1.legRight.fGround * .1);\n            col = drawGraph(col, uv, black, 0.);\n            col = drawGraph(col, uv, colBody.legLeft .lower, (worldBody1.legLeft .ankle.y-ground1) * scale.y);\n            col = drawGraph(col, uv, colBody.legRight.lower, (worldBody1.legRight.ankle.y-ground1) * scale.y);\n\n            col = drawCircle(col, uv, vec2(phase, worldBody1.legLeft .ankle.y-ground1)*scale-offset, .01, colBody.legLeft .lower);\n            col = drawCircle(col, uv, vec2(phase, worldBody1.legRight.ankle.y-ground1)*scale-offset, .01, colBody.legRight.lower);\n\n            uv.y += .25;\n            scale.y = .02;\n            col = drawGraph(col, uv, black, 0.);\n            col = drawGraph(col, uv, colBody.legLeft .lower, (worldBody1.legLeft .ankle.x) * scale.y);\n            col = drawGraph(col, uv, colBody.legRight.lower, (worldBody1.legRight.ankle.x) * scale.y);\n\n            col = drawCircle(col, uv, vec2(phase, worldBody1.legLeft .ankle.x)*scale-offset, .01, colBody.legLeft .lower);\n            col = drawCircle(col, uv, vec2(phase, worldBody1.legRight.ankle.x)*scale-offset, .01, colBody.legRight.lower);\n        }\n    }\n\n    fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}