{
    "Shader": {
        "info": {
            "date": "1415959692",
            "description": "Analytical antialiasing for raytraced spheres. Only one ray/sample per pixel is casted. This shader also uses analytical ambient occlusion and analytical soft shadows.",
            "flags": 0,
            "hasliked": 0,
            "id": "MsSSWV",
            "likes": 166,
            "name": "Sphere - antialias",
            "published": 3,
            "tags": [
                "3d",
                "sphere",
                "antialias",
                "analytical",
                "conetracing"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 13398
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright Â© 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//  https://www.youtube.com/c/InigoQuilez\n//  https://iquilezles.org/\n\n\n// Analytical antialiasing of raytraced spheres. Only one ray/sample per pixel is casted. \n// It handles inner edges too.\n//\n// Enable the NO_ANTIALIAS flag below to see the difference.\n//\n// Related info: https://iquilezles.org/articles/spherefunctions\n\n\n//#define NO_ANTIALIAS\n\n//-------------------------------------------------------------------------------------------\n\nvec3 sphNormal( in vec3 pos, in vec4 sph )\n{\n    return normalize(pos-sph.xyz);\n}\n\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\nfloat sphShadow( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    return step( min( -b, min( c, b*b - c ) ), 0.0 );\n}\n            \nvec2 sphDistances( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    float d = sqrt( max(0.0,sph.w*sph.w-h)) - sph.w;\n    return vec2( d, -b-sqrt(max(h,0.0)) );\n}\n\nfloat sphSoftShadow( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    float s = 1.0;\n    vec2 r = sphDistances( ro, rd, sph );\n    if( r.y>0.0 )\n        s = max(r.x,0.0)/r.y;\n    return s;\n}    \n            \nfloat sphOcclusion( in vec3 pos, in vec3 nor, in vec4 sph )\n{\n    vec3  r = sph.xyz - pos;\n    float l = length(r);\n    float d = dot(nor,r);\n    float res = d;\n\n    if( d<sph.w ) res = pow(clamp((d+sph.w)/(2.0*sph.w),0.0,1.0),1.5)*sph.w;\n    \n    return clamp( res*(sph.w*sph.w)/(l*l*l), 0.0, 1.0 );\n\n}\n\n//-------------------------------------------------------------------------------------------\n#define NUMSPHEREES 12\n\nvec4 sphere[NUMSPHEREES];\n\nfloat shadow( in vec3 ro, in vec3 rd )\n{\n\tfloat res = 1.0;\n\tfor( int i=0; i<NUMSPHEREES; i++ )\n        res = min( res, 8.0*sphSoftShadow(ro,rd,sphere[i]) );\n    return res;\t\t\t\t\t  \n}\n\nfloat occlusion( in vec3 pos, in vec3 nor )\n{\n\tfloat res = 1.0;\n\tfor( int i=0; i<NUMSPHEREES; i++ )\n\t    res *= 1.0 - sphOcclusion( pos, nor, sphere[i] ); \n    return res;\t\t\t\t\t  \n}\n\n#if NUMSPHEREES==12\nvoid swap( inout vec3 data[12], int i, int j ) { if( data[j].x > data[i].x ) { vec3 tm = data[i]; data[i] = data[j]; data[j] = tm; } }\n\n// https://bertdobbelaere.github.io/sorting_networks.html#N12L40D8\nvoid sort12( inout vec3 x[12] )\n{\n/*0*/ swap(x,0,8);swap(x,1,7);swap(x,2,6);swap(x,3,11);swap(x, 4,10);swap(x, 5, 9);\n/*1*/ swap(x,0,2);swap(x,1,4);swap(x,3,5);swap(x,6, 8);swap(x, 7,10);swap(x, 9,11);\n/*2*/ swap(x,0,1);swap(x,2,9);swap(x,4,7);swap(x,5, 6);swap(x,10,11);\n/*3*/ swap(x,1,3);swap(x,2,7);swap(x,4,9);swap(x,8,10);\n/*4*/ swap(x,0,1);swap(x,2,3);swap(x,4,5);swap(x,6, 7);swap(x, 8, 9);swap(x,10,11);\n/*5*/ swap(x,1,2);swap(x,3,5);swap(x,6,8);swap(x,9,10);\n/*6*/ swap(x,2,4);swap(x,3,6);swap(x,5,8);swap(x,7, 9);\n/*7*/ swap(x,1,2);swap(x,3,4);swap(x,5,6);swap(x,7, 8);swap(x, 9,10);\n}\n#endif\n\n//-------------------------------------------------------------------------------------------\n\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*43758.5453123); }\n\nvec3 shade( in vec3 rd, in vec3 pos, in vec3 nor, in float id, in vec4 sph )\n{\n    vec3 ref = reflect(rd,nor);\n    float occ = occlusion( pos, nor );\n    float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\n    \n    occ = occ*0.5 + 0.5*occ*occ;\n    vec3 lig = vec3(occ)*vec3(0.9,0.95,1.0);\n    lig *= 0.7 + 0.3*nor.y;\n    lig += 0.7*vec3(0.3,0.2,0.1)*fre*occ;\n    lig *= 0.9;\n\n    \n    lig += 0.7*smoothstep(-0.05,0.05,ref.y )*occ*shadow( pos, ref ) * (0.03+0.97*pow(fre,3.0));\n\n    return lig;\n}    \n\nvec3 trace( in vec3 ro, in vec3 rd, vec3 col, in float px )\n{\n#ifdef NO_ANTIALIAS\n\tfloat t = 1e20;\n\tfloat id  = -1.0;\n    vec4  obj = vec4(0.0);\n\tfor( int i=0; i<NUMSPHEREES; i++ )\n\t{\n\t\tvec4 sph = sphere[i];\n\t    float h = sphIntersect( ro, rd, sph ); \n\t\tif( h>0.0 && h<t ) \n\t\t{\n\t\t\tt = h;\n            obj = sph;\n\t\t\tid = float(i);\n\t\t}\n\t}\n\t\t\t\t\t\t  \n    if( id>-0.5 )\n    {\n\t\tvec3 pos = ro + t*rd;\n\t\tvec3 nor = sphNormal( pos, obj );\n        col = shade( rd, pos, nor, id, obj );\n    }\n\n#else\n\n    \n    // intersect spheres\n    vec3 tao[NUMSPHEREES];\n\tint num = 0;\n    for( int i=0; i<NUMSPHEREES; i++ )\n\t{\n\t\tvec4 sph = sphere[i];\n        vec2 dt = sphDistances( ro, rd, sph );\n        float d = dt.x;\n\t    float t = dt.y;\n        //if( t<0.0 ) continue; // skip stuff behind camera. If I enable it, I loose mipmapping\n        \n        float s = max( 0.0, d/t );\n        if( s < px ) // intersection, or close enough to an intersection\n        {\n            tao[num].x = t;                         // depth\n            tao[num].y = 1.0 - clamp(s/px,0.0,1.0); // pixel coverage\n            tao[num].z = float(i);                  // object id\n            num++;\n        }\n\t}\n\n    // sort intersections\n    #if NUMSPHEREES==12\n    sort12( tao );               // fast sorting network, 40 comps, 8 parallel layers\n    #else\n\tfor( int i=0; i<num-1; i++ ) // resort to bubble sort (66 comps?)\n    for( int j=i+1; j<num; j++ )\n    {\n        if( tao[j].x > tao[i].x )\n        {\n            vec3 tm = tao[i];\n            tao[i] = tao[j];\n            tao[j] = tm;\n        }\n\t}\n    #endif    \n    \n    // composite\n    float ot = tao[0].x;\n\tfor( int i=0; i<num; i++ )\n    {\n        float t   = tao[i].x;\n        float al  = tao[i].y;\n        float fid = tao[i].z;\n\n        if( (i+1)<num )\n        {\n            float tn = tao[i+1].x;\n        \tal *= clamp( 0.5 - 0.5*(tn-t)/(px*1.0), 0.0, 1.0 );\n        }\n        \n        vec4 sph = sphere[int(fid)];\n        vec3 pos = ro + t*rd;\n        vec3 nor = sphNormal( pos, sph );\n\n        vec3 tmpcol = shade( rd, pos, nor, fid, sph );\n        \n        col = mix( col, tmpcol.xyz, al );\n    }\n    \n#endif\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n    vec2 m = step(0.0001,iMouse.z) * iMouse.xy/iResolution.xy;\n\t\n    //-----------------------------------------------------\n    // animate\n    //-----------------------------------------------------\n\tfloat time = iTime*0.5;\n\t\n\tfloat an = 0.3*time - 7.0*m.x;\n\n\tfor( int i=0; i<NUMSPHEREES; i++ )\n\t{\n\t\tfloat id  = float(i);\n        float ra = pow(id/float(NUMSPHEREES-1),3.0);\n\t    vec3  pos = 1.0*cos( 6.2831*hash3(id*14.0) + 0.5*(1.0-0.7*ra)*hash3(id*7.0)*time );\n\t\tsphere[i] = vec4( pos, (0.3+0.6*ra) );\n    }\n\t\t\t\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    float le = 1.8;\n\tvec3 ro = vec3(2.5*sin(an),1.5*cos(0.5*an),2.5*cos(an));\n    vec3 ta = vec3(0.0,0.0,0.0);\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\tvec3 rd = normalize( p.x*uu + p.y*vv + le*ww );\n\n    float px = 1.0*(2.0/iResolution.y)*(1.0/le);\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\tvec3 col = vec3(0.02) + 0.02*rd.y;\n    \n    col = trace( ro, rd, col, px );\n    \n\n    //-----------------------------------------------------\n\t// postpro\n    //-----------------------------------------------------\n    \n    // gamme    \n    col = pow( col, vec3(0.4545) );\n\n    // vignetting    \n    col *= 0.2 + 0.8*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.15);\n\n    // dithering\n    col += (1.0/255.0)*hash3(q.x+13.0*q.y);\n    \n\tfragColor = vec4( col, 1.0 );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}