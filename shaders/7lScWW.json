{
    "Shader": {
        "info": {
            "date": "1649764971",
            "description": "Edge detection",
            "flags": 34,
            "hasliked": 0,
            "id": "7lScWW",
            "likes": 1,
            "name": "Edge statistics",
            "published": 3,
            "tags": [
                "edges"
            ],
            "usePreview": 0,
            "username": "vtimonen",
            "viewed": 382
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    fragColor = texture(iChannel0, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define THIS_CHANNEL     iChannel1\n#define CAMERA_CHANNEL   iChannel0\n\n#define CALC_MARGINAL  0.05\n#define PRINT_MARGINAL 0.15\n\n/* Frame variables */\n#define EDGE    0\n#define AVERAGE 1\n#define RADIUS  2\n\n/* Frame varible macros */\n#define SAVE(value)        fragColor = vec4(0.0, 0.0, 0.0, (value))\n#define LOAD(variable, x)  texelFetch(THIS_CHANNEL, ivec2((x), variable), 0).a\n\n/* Colors */\n#define LINE_COLOR  vec4(1.0, 0.0, 0.0, 0.2)\n#define GRAPH_COLOR vec4(0.0, 0.0, 1.0, 0.4)\n\n\n#define MATRIX_SIZE 5\nvec4 camera_value(float x, float y)\n{\n    int dx ,dy;\n    vec4 sum = vec4(0.0);\n    int count = 0;\n\n    for (dx = 0; dx < MATRIX_SIZE; dx++) {\n        for (dy = 0; dy < MATRIX_SIZE; dy++) {\n            sum += texture(CAMERA_CHANNEL, vec2(x + (float(dx) + 0.5) / iResolution.x, y + (float(dy) + 0.5) / iResolution.y));\n            count++;\n        }\n    }\n    \n\n    return sum / float(count);\n}\n\n#define EDGE_WINDOW_SIZE 8\nfloat find_edge(int x_int)\n{\n    float diff;\n    float x, y;\n    int i;\n\n    float pre_y;\n    float post_y;\n\n    vec3 pre_color_sum;\n    vec3 post_color_sum;\n\n\n    /* Calculate initial calues for sums */\n    x = float(x_int) / iResolution.x;\n   \n    /* Calculate initial sums */\n    pre_color_sum  = vec3(0.0);\n    post_color_sum = vec3(0.0);\n    for (i = EDGE_WINDOW_SIZE; i < EDGE_WINDOW_SIZE + EDGE_WINDOW_SIZE; i++) {\n        vec4 color;\n\n        /* Calculate pre average */\n        pre_y = 1.0 - float(i + 1) / iResolution.y;\n        color = camera_value(x, pre_y);\n        pre_color_sum += color.rgb;\n\n        /* Calculate post average */\n        post_y = 1.0 + float(i) / iResolution.y;\n        color = camera_value(x, post_y);\n        post_color_sum += color.rgb;\n    }\n\n    /* Find out edge */\n    int y_int;\n    for (y_int = int(iResolution.y) - (EDGE_WINDOW_SIZE + 1); y_int >= 0 ; y_int--) {\n        x = float(x_int) / iResolution.x;\n        y = float(y_int) / iResolution.y;\n\n        float edge_value;\n        vec4 color;\n        \n        /* Update pre/post sums */ \n        pre_y = float(y_int) / iResolution.y;\n        color = camera_value(x, pre_y);\n        pre_color_sum  -= color.rgb;\n        post_color_sum += color.rgb;\n\n        pre_y = float(y_int) / iResolution.y - float(EDGE_WINDOW_SIZE) / iResolution.y;\n        color = camera_value(x, pre_y);\n        pre_color_sum += color.rgb;\n\n        post_y = float(y_int) / iResolution.y + float(EDGE_WINDOW_SIZE) / iResolution.y;\n        color = camera_value(x, post_y);\n        post_color_sum -= color.rgb;\n\n\n#if 0\n        vec3 color_diff = abs(pre_color_sum - post_color_sum);\n        float diff = color_diff.r + color_diff.g + color_diff.b;\n#define DIFF_TRESHOLD (float(EDGE_WINDOW_SIZE) / 8.0)\n        if (diff > DIFF_TRESHOLD) {\n//            break;\n        }\n\n        if (color_diff.r > DIFF_TRESHOLD) {\n            break;\n        }\n        if (color_diff.g > DIFF_TRESHOLD) {\n            break;\n        }\n        if (color_diff.b > DIFF_TRESHOLD) {\n            break;\n        }\n#else\n        float pre_luma  = dot(pre_color_sum.rgb,  vec3(0.299, 0.587, 0.114));\n        float post_luma = dot(post_color_sum.rgb, vec3(0.299, 0.587, 0.114));\n        vec3 color_diff = abs(pre_color_sum - post_color_sum);\n        float diff = abs(pre_luma - post_luma);\n\n        if (diff > float(EDGE_WINDOW_SIZE) / 8.0) {\n            break;\n        }\n#endif\n    }\n\n    return float(y_int);\n}\n\n#define AVERAGE_WINDOW int(iResolution.x / 8.0)\n//#define AVERAGE_WINDOW 1\nfloat calc_average(int x)\n{\n    int i;\n    float sum = 0.0;\n    int count  = 0;\n    for (i = 0; i < AVERAGE_WINDOW; i += 1) {\n        sum += LOAD(EDGE, x + (i - AVERAGE_WINDOW/2));\n        count++;\n    }\n\n    /* Return average value */\n    return sum / float(count);\n}\n\n\n#define RADIUS_WINDOW   int(iResolution.x / 12.0)\n#define RADIUS_SPACING  int(iResolution.x / 40.0)\n#define RADIUS_SCALE    2.0\nfloat calc_radius(int x)\n{\n    vec2 first = vec2(float(x - RADIUS_WINDOW), LOAD(AVERAGE, x - RADIUS_WINDOW));\n    vec2 mid   = vec2(float(x),                 LOAD(AVERAGE, x));\n    vec2 last  = vec2(float(x + RADIUS_WINDOW), LOAD(AVERAGE, x + RADIUS_WINDOW));\n\n    float result = 0.0;\n    result += (first.y - mid.y) / (mid.x  - first.x);\n    result += (last.y  - mid.y) / (last.x - mid.x);\n\n    result = (last.x - first.x) / (result * 2.0);\n\n    if (result < 0.0) {\n        return -result * RADIUS_SCALE / iResolution.y;\n    }\n\n    return 10000.0;\n}\n\n\n#define CALC_FRAME_RATE 3\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    ivec2 ifragCoord = ivec2(fragCoord - 0.5);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    float mouse_x = iMouse.x/iResolution.x;\n    if (mouse_x > 0.5) {\n        /* Keep unchanged */\n        fragColor = texture(THIS_CHANNEL, uv);\n        return;\n    }\n\n    if (uv.x > CALC_MARGINAL && uv.x < 1.0 - CALC_MARGINAL) {\n\n        if (iFrame % CALC_FRAME_RATE == 0) {\n            /* Findout border place */\n            if (ifragCoord.y == EDGE) {\n                float y;\n\n                /* Detect border */\n                y = find_edge(ifragCoord.x);\n\n                /* Save border value */\n                SAVE(y);\n\n                return;\n            } \n\n            /* Calculate averages */\n            if (ifragCoord.y == AVERAGE) {\n                float average;\n\n                average = calc_average(ifragCoord.x);\n\n                /* Save average value */\n                SAVE(average);\n\n                return;\n            }\n\n            /* Calculate radius */\n            if (ifragCoord.y == RADIUS && (ifragCoord.x % RADIUS_SPACING) == 0) {\n                #define RADIUS_AVERAGE_WINDOW int(iResolution.x / 80.0)\n//                #define RADIUS_AVERAGE_WINDOW 1\n                int i;\n\n                float radius_sum = 0.0;\n                for (i = 0; i < RADIUS_AVERAGE_WINDOW; i++) {\n                    radius_sum += calc_radius(ifragCoord.x + (i - RADIUS_AVERAGE_WINDOW/2));\n                }\n\n                float radius;\n                radius = radius_sum / float(RADIUS_AVERAGE_WINDOW);\n                \n                /* Save average value */\n                SAVE(radius);\n\n                return;\n            }\n        }\n\n        if (ifragCoord.y == EDGE) {\n            /* Keep unchanged */\n            fragColor = texture(THIS_CHANNEL, uv);\n            return;\n        }\n        if (ifragCoord.y == AVERAGE) {\n            /* Keep unchanged */\n            fragColor = texture(THIS_CHANNEL, uv);\n            return;\n        }\n        if (ifragCoord.y == RADIUS && (ifragCoord.x % RADIUS_SPACING) == 0) {\n            /* Keep unchanged */\n            fragColor = texture(THIS_CHANNEL, uv);\n            return;\n        }\n\n        if (uv.x > PRINT_MARGINAL && uv.x < 1.0 - PRINT_MARGINAL) {\n            /* Print radius */\n            if ((ifragCoord.x % RADIUS_SPACING) == 0) {\n                /* Get border value */\n                int radius_y = int(LOAD(RADIUS, ifragCoord.x));\n                if (radius_y > ifragCoord.y) {\n                    fragColor = mix(GRAPH_COLOR, texture(CAMERA_CHANNEL, uv), GRAPH_COLOR.a);\n                    return;\n                }\n            }\n\n            /* Print edge */\n            int average_y = int(LOAD(AVERAGE, ifragCoord.x));\n            if (average_y > ifragCoord.y) {\n                if (average_y - ifragCoord.y > 7) {\n                    fragColor = texture(CAMERA_CHANNEL, uv);\n                } else {\n                    fragColor = mix(LINE_COLOR, texture(CAMERA_CHANNEL, uv), LINE_COLOR.a);\n                }\n                return;\n            }\n        }\n\n        fragColor = texture(CAMERA_CHANNEL, uv);\n    } else {\n        fragColor = texture(CAMERA_CHANNEL, uv);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "webcam",
                        "id": 31,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/webcam.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}