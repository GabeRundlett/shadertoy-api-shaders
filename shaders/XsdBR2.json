{
    "Shader": {
        "info": {
            "date": "1525952774",
            "description": "Based on the original \"Double Pendulum\", with new trajectory rendering (mouseable)",
            "flags": 32,
            "hasliked": 0,
            "id": "XsdBR2",
            "likes": 14,
            "name": "Double Pendulum Trajectory",
            "published": 3,
            "tags": [
                "mechanics",
                "chaos",
                "pendulum"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 719
        },
        "renderpass": [
            {
                "code": "// \"Double Pendulum Trajectory\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  The simplest mechanical system that exhibits deterministic chaos.\n\n  The two sliders on the left control the relative masses of the two bobs\n  and the arm lengths. The right sliders control the initial angular\n  velocities of the two arms. Each change restarts the simulation.\n\n  The trajectory of the end bob is shown as a continuous curve floating in space;\n  the color cycles and the curve fades with time.\n\n  Examine different parameter combinations to see the many kinds of behavior that\n  can occur.\n*/\n\n#define AA  0   // optional antialiasing\n\nfloat PrSphDf (vec3 p, float s);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nvec3 ShowWg (vec2 uv, vec2 canvas, vec3 col, vec4 slVal);\nvec4 LoadTx (vec2 uv);\nvec4 Loadv4 (ivec2 idVar);\nvec2 Rot2D (vec2 q, float a);\n\nvec3 ltDir, qnBlk;\nfloat rLen[2], bRad[2], pAng[2], dstFar;\nint idObj;\nconst float pi = 3.14159;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  q = p;\n  q.xy = Rot2D (q.xy, pAng[0]);\n  q.y -= - rLen[0];\n  d = PrCylDf (q.xzy, 0.03, rLen[0]);\n  DMIN (1);\n  q.yz -= vec2 (- rLen[0], -0.03);\n  d = PrSphDf (q, bRad[0]);\n  if (d < dMin) { dMin = d;  idObj = 2; }\n  q.xy = Rot2D (q.xy, pAng[1] - pAng[0]);\n  q.yz -= vec2 (- rLen[1], -0.03);\n  d = PrCylDf (q.xzy, 0.03, rLen[1]);\n  DMIN (1);\n  q.yz -= vec2 (- rLen[1], -0.03);\n  d = PrSphDf (q, bRad[1]);\n  DMIN (2);\n  q = p;  q.yz -= vec2 (-1.1 * (rLen[0] + rLen[1]) + 0.1, 0.5);\n  d = PrCapsDf (q.xzy, 0.15, 1.1 * (rLen[0] + rLen[1]));\n  DMIN (3);\n  q = p;  q.y -= - 2.15 * (rLen[0] + rLen[1]) - 0.1;\n  d = PrCylDf (q.xzy, 1., 0.1);\n  DMIN (3);\n  q = p;  q.z -= 0.25;\n  d = PrCapsDf (q, 0.1, 0.2);\n  DMIN (4);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0003 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat BlkHit (vec3 ro, vec3 rd, vec3 bSize)\n{\n  vec3 v, tm, tp;\n  float dMin, dn, df;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  v = ro / rd;\n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = max (max (tm.x, tm.y), tm.z);\n  df = min (min (tp.x, tp.y), tp.z);\n  dMin = dstFar;\n  if (df > 0. && dn < df) {\n    dMin = dn;\n    qnBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  }\n  return dMin;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 colT;\n  vec3 vn, col, ros;\n  float dstObj, dstBlk;\n  dstBlk = BlkHit (ro, rd, vec3 (4.5, 4.5, 0.002));\n  dstObj = ObjRay (ro, rd);\n  colT = vec4 (0.);\n  if (dstBlk < min (dstObj, dstFar)) {\n    ros = ro + rd * dstBlk;\n    vn = qnBlk;\n    if (abs (vn.z ) > 0.99 && length (ros.xy) < 4.5) {\n      colT = LoadTx (0.5 * ros.xy / 4.5 + 0.5);\n      colT.rgb =  colT.rgb * (0.3 + 0.7 * max (dot (vn, ltDir), 0.)) +\n         0.5 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 6.);\n    }\n  }\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    vn = ObjNf (ro);\n    if (idObj == 1) col = vec3 (0.9, 0.9, 1.);\n    else if (idObj == 2) col = vec3 (0.7, 0.7, 0.);\n    else if (idObj == 3) col = vec3 (0.5, 0.2, 0.1);\n    else if (idObj == 4) col = vec3 (0.7, 0.4, 0.3);\n    col = col * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n       0.1 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n  } else col = (1. - dot (rd.xy, rd.xy)) * vec3 (0.1, 0.2, 0.3);\n  col = mix (col, colT.rgb, colT.a);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat, slVal;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;;\n  float tCur, az, el, parmL, parmM, mFrac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dstFar = 30.;\n  stDat = Loadv4 (ivec2 (0, 0));\n  pAng[0] = stDat.x;\n  pAng[1] = stDat.y;\n  stDat = Loadv4 (ivec2 (2, 0));\n  el = stDat.z;\n  az = stDat.w + 0.2 * pi * sin (0.05 * 2. * pi * tCur);\n  slVal = Loadv4 (ivec2 (3, 0));\n  parmL = (slVal.x - 0.5) * ((slVal.x >= 0.5) ? 1. : 1. / 5.) * 8. + 1.;\n  parmM = (slVal.y - 0.5) * ((slVal.y >= 0.5) ? 1. : 1. / 5.) * 8. + 1.;\n  rLen[0] = 2. / (1. + parmL);\n  rLen[1] = 2. * parmL / (1. + parmL);\n  mFrac = parmM / (1. + parmM);\n  bRad[0] = 0.05 * (1. + 3. * sqrt (1. - mFrac));\n  bRad[1] = 0.05 * (1. + 3. * sqrt (mFrac));\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., -0.3, -15.);\n  ltDir = vuMat * normalize (vec3 (0., 0.3, -1.));\n  #if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 4.;\n#endif  \n  col = vec3 (0.);\n  for (float a = 0.; a < naa; a ++) {\n    rd = normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.71 / canvas.y, 0.),\n       0.5 * pi * (a + 0.5)), 3.2));\n    rd = vuMat * rd;\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  col = ShowWg (uv, canvas, col, slVal);\n  fragColor = vec4 (col, 1.);\n}\n\nvec3 ShowWg (vec2 uv, vec2 canvas, vec3 col, vec4 slVal)\n{\n  vec4 wgBx[4];\n  vec3 cc;\n  vec2 ut, ust;\n  float vW[4], asp;\n  asp = canvas.x / canvas.y;\n  wgBx[0] = vec4 (-0.42 * asp, 0., 0.012 * asp, 0.18);\n  wgBx[1] = vec4 (-0.35 * asp, 0., 0.012 * asp, 0.18);\n  wgBx[2] = vec4 ( 0.35 * asp, 0., 0.012 * asp, 0.18);\n  wgBx[3] = vec4 ( 0.42 * asp, 0., 0.012 * asp, 0.18);\n  vW[0] = slVal.x;\n  vW[1] = slVal.y;\n  vW[2] = slVal.z;\n  vW[3] = slVal.w;\n  for (int k = 0; k < 4; k ++) {\n    cc = (k < 2) ? vec3 (0.2, 1., 0.2) : vec3 (1., 0.2, 0.2);\n    ut = 0.5 * uv - wgBx[k].xy;\n    ust = abs (ut) - wgBx[k].zw * vec2 (0.7, 1.);\n    if (max (ust.x, ust.y) < 0.) {\n      if  (min (abs (ust.x), abs (ust.y)) * canvas.y < 2.) col = vec3 (1., 1., 0.);\n      else col = (mod (0.5 * ((0.5 * uv.y - wgBx[k].y) / wgBx[k].w - 0.99), 0.1) *\n         canvas.y < 6.) ? vec3 (1., 1., 0.) : vec3 (0.6);\n    }\n    ut.y -= (vW[k] - 0.5) * 2. * wgBx[k].w;\n    ut = abs (ut) * vec2 (1., 1.5);\n    if (max (abs (ut.x), abs (ut.y)) < 0.02 && max (ut.x, ut.y) > 0.013) col = cc;\n  }\n  return col;\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 LoadTx (vec2 uv)\n{\n  return texture (txBuf, uv);\n}\n\nvec4 Loadv4 (ivec2 idVar)\n{\n  return texture (txBuf, (vec2 (idVar) + 0.5) / txSize);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Double Pendulum Trajectory\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat SegDist (vec2 p, vec2 v1, vec2 v2);\nvec3 HsvToRgb (vec3 c);\nvec4 LoadTx (vec2 uv);\nvec4 Loadv4 (ivec2 idVar);\nvoid Savev4 (ivec2 idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nvec2 pPen, ppPen;\nfloat nStep, mFrac, rLen1, rLen2, delT;\nconst float pi = 3.14159;\n\nvec4 EvalRhs (vec4 s)\n{\n  vec4 f;\n  float sd, cd, s1, s2, t;\n  sd = sin (s.x - s.y);\n  cd = cos (s.x - s.y);\n  s1 = sin (s.x);\n  s2 = sin (s.y);\n  t = delT / (1. - mFrac * cd * cd);\n  f.x = s.z * delT;\n  f.y = s.w * delT;\n  f.z = t * ((mFrac * cd * s2 - s1) / rLen1 -\n     mFrac * sd * (cd * s.z * s.z + (rLen2 / rLen1) * s.w * s.w));\n  f.w = t * ((cd * s1 - s2) / rLen2 +\n     mFrac * cd * sd * s.w * s.w + (rLen1 / rLen2) * sd * s.z * s.z);\n  return f;\n}\n\nvoid Step (inout vec4 s)\n{\n  vec4 k1, k2, k3, k4;\n  k1 = EvalRhs (s);\n  k2 = EvalRhs (s + k1 / 2.);\n  k3 = EvalRhs (s + k2 / 2.);\n  k4 = EvalRhs (s + k3);\n  s += (k1 + k4) / 6. + (k2 + k3) / 3.;\n  s.xy = mod (s.xy + pi, 2. * pi) - pi;\n}\n\nfloat Eng (vec4 s)\n{\n  vec2 c;\n  c = cos (s.xy);\n  return 0.5 * ((1. - mFrac) * rLen1 * rLen1 * s.z * s.z + mFrac * (rLen1 * rLen1 * s.z * s.z +\n     rLen2 * rLen2 * s.w * s.w + 2. * rLen1 * rLen2 * cos (s.x - s.y) * s.z * s.w)) +\n     ((1. - mFrac) * rLen1 * (1. - c.x) + mFrac * (rLen1 * (1. - c.x) + rLen2 * (1. - c.y)));\n}\n\nvec4 ShowScene (vec2 uv, vec4 col)\n{\n  vec4 col4;\n  vec2 p;\n  p = 0.5 * 4.5 * (uv - 0.5);\n  col4 = (SegDist (p, ppPen, pPen) < 0.005) ? vec4 (HsvToRgb (vec3 (mod (0.0005 * nStep, 1.), 1., 1.)), 1.) :\n     mix (col, vec4 (0.), 0.0005);\n  col4 *= step (1./256., col4.a);\n  return col4;\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec2 TPoint (vec2 s)\n{\n  return - rLen1 * sin (vec2 (s.x + vec2 (0., 0.5 * pi))) - rLen2 * sin (vec2 (s.y + vec2 (0., 0.5 * pi)));\n}\n\n#define sqrt10 sqrt(10.)\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 wgBx[4], mPtr, mPtrP, stDat, slVal, s;\n  vec2 canvas, txSizeP, uvtx, ust, tPoint;\n  ivec2 iFrag;\n  float asp, vW, parmL, parmM, parmV1, parmV2, eTot, el, az;\n  int wgSel, wgReg, kSel;\n  bool doInit;\n\n  canvas = iResolution.xy;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  uvtx = fragCoord / txSize;\n  iFrag = ivec2 (fragCoord);\n  delT = 0.005 * sqrt10;\n  doInit = false;\n  wgReg = -2;\n  if (iFrame <= 5) {\n    parmL = 0.6;\n    parmM = 0.5;\n    parmV1 = -6. / sqrt10;\n    parmV2 = 6. / sqrt10;\n    slVal.x = 0.5 + (parmL - 1.) * ((parmL >= 1.) ? 1. : 5.) / 8.;\n    slVal.y = 0.5 + (parmM - 1.) * ((parmM >= 1.) ? 1. : 5.) / 8.;\n    slVal.z = 0.5 - parmV1 * sqrt10 / 20.;\n    slVal.w = 0.5 - parmV2 * sqrt10 / 20.;\n    mPtrP = mPtr;\n    txSizeP = txSize;\n    wgSel = -1;\n    doInit = true;\n  } else {\n    s = Loadv4 (ivec2 (0, 0));\n    stDat = Loadv4 (ivec2 (1, 0));\n    pPen = stDat.xy;\n    ppPen = stDat.zw;\n    stDat = Loadv4 (ivec2 (2, 0));\n    nStep = stDat.x;\n    txSizeP.x = stDat.y;\n    slVal = Loadv4 (ivec2 (3, 0));\n    stDat = Loadv4 (ivec2 (4, 0));\n    mPtrP = vec4 (stDat.xyz, 0.);\n    wgSel = int (stDat.w);\n  }\n  asp = canvas.x / canvas.y;\n  if (mPtr.z > 0.) {\n    wgBx[0] = vec4 (-0.42 * asp, 0., 0.012 * asp, 0.18);\n    wgBx[1] = vec4 (-0.35 * asp, 0., 0.012 * asp, 0.18);\n    wgBx[2] = vec4 ( 0.35 * asp, 0., 0.012 * asp, 0.18);\n    wgBx[3] = vec4 ( 0.42 * asp, 0., 0.012 * asp, 0.18);\n    for (int k = 0; k < 4; k ++) {\n      ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx[k].xy) - wgBx[k].zw;\n      if (max (ust.x, ust.y) < 0.) wgReg = k;\n    }\n    if (mPtrP.z <= 0.) wgSel = wgReg;\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n  }\n  el = 0.;\n  az = 0.;\n  if (wgSel < 0) {\n    if (mPtr.z > 0.) {\n      el +=  pi * mPtr.y;\n      az += 2. * pi * mPtr.x;\n    }\n  } else {\n    for (int k = 0; k < 4; k ++) {\n      if (wgSel == k) {\n        kSel = k;\n        vW = clamp (0.5 + 0.5 * (mPtr.y - wgBx[k].y) / wgBx[k].w, 0.01, 0.99);\n        break;\n      }\n    }\n    if      (kSel == 0) slVal.x = vW;\n    else if (kSel == 1) slVal.y = vW;\n    else if (kSel == 2) slVal.z = vW;\n    else if (kSel == 3) slVal.w = vW;\n    doInit = true;\n  }\n  if (txSize.x != txSizeP.x) doInit = true;\n  fragColor = doInit ? vec4 (0.) : ShowScene (uvtx, LoadTx (uvtx));\n  if (iFrag.y == 0 && iFrag.x <= 4) {\n    if (iFrag.x <= 2) {\n      parmL = (slVal.x - 0.5) * ((slVal.x >= 0.5) ? 1. : 1. / 5.) * 8. + 1.;\n      parmM = (slVal.y - 0.5) * ((slVal.y >= 0.5) ? 1. : 1. / 5.) * 8. + 1.;\n      parmV1 = - (slVal.z - 0.5) * 20. / sqrt10;\n      parmV2 = - (slVal.w - 0.5) * 20. / sqrt10;\n      rLen1 = 1. / (1. + parmL);\n      rLen2 = 1. - rLen1;\n      mFrac = parmM / (1. + parmM);\n      if (doInit) {\n        s = vec4 (0., 0., parmV1, parmV2);\n        nStep = 0.;\n        ppPen = TPoint (s.xy);\n        pPen = ppPen;\n      } else {\n        for (int k = 0; k < 4; k ++) {\n          Step (s);\n          ++ nStep;\n          tPoint = TPoint (s.xy);\n          if (length (tPoint - ppPen) > 0.05) break;\n        }\n        ppPen = pPen;\n        pPen = tPoint;\n      }\n      if (false) eTot = Eng (s);\n    }\n    if      (iFrag.x == 0) stDat = s;\n    else if (iFrag.x == 1) stDat = vec4 (pPen, ppPen);\n    else if (iFrag.x == 2) stDat = vec4 (nStep, txSize.x, el, az);\n    else if (iFrag.x == 3) stDat = slVal;\n    else if (iFrag.x == 4) stDat = vec4 (mPtr.xyz, float (wgSel));\n    Savev4 (iFrag, stDat, fragColor, fragCoord);\n  }\n}\n\nfloat SegDist (vec2 p, vec2 v1, vec2 v2)\n{\n  vec2 a, b;\n  float s;\n  a = p - v1;\n  b = v2 - v1;\n  s = length (b);\n  b = (s > 0.) ? b / s : vec2 (0.);\n  return length (a - clamp (dot (a, b), 0., s) * b);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nvec4 LoadTx (vec2 uv)\n{\n  return texture (txBuf, uv);\n}\n\nvec4 Loadv4 (ivec2 idVar)\n{\n  return texture (txBuf, (vec2 (idVar) + 0.5) / txSize);\n}\n\nvoid Savev4 (ivec2 idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  d = abs (fCoord - vec2 (idVar) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}