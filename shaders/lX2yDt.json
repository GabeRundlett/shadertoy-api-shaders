{
    "Shader": {
        "info": {
            "date": "1727895873",
            "description": "test 2",
            "flags": 32,
            "hasliked": 0,
            "id": "lX2yDt",
            "likes": 5,
            "name": "Fork Fork Space swairmi 655",
            "published": 3,
            "tags": [
                "2d",
                "space",
                "planet",
                "toon",
                "stylized"
            ],
            "usePreview": 1,
            "username": "swairmi",
            "viewed": 168
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 O, in vec2 I)\n{\n    // Normalized pixel coordinates\n    vec2 uv = I / iResolution.xy;\n    vec2 p = (2. * I - iResolution.xy) / iResolution.y;\n    \n    // Sample the planet from iChannel0, including alpha\n    vec4 color = texture(iChannel0, uv);\n\n    // Apply blur effects if needed (ensure they preserve alpha)\n    #if HW_PERFORMANCE != 0\n    vec4 blurredColor1 = blur(iChannel0, uv, iResolution.xy, 5.0);\n    vec4 blurredColor2 = blur(iChannel0, uv, iResolution.xy, 2.0);\n    color.rgb += blurredColor1.rgb * 0.2;\n    color.rgb += blurredColor2.rgb * 0.4;\n    #endif\n\n    // Apply vignette and other color adjustments\n    vec2 nuv = pow(uv * (1.0 - uv), vec2(0.3));\n    float vignette = clamp(nuv.x * nuv.y * 3.0, 0.0, 1.0);\n    color.rgb *= vignette;\n    color.rgb *= smoothstep(2.0, 0.8, length(p));\n\n    // Apply tonemapping and color adjustments\n    color.rgb = color.rgb * vec3(1.2, 1.2, 1.44);\n    color.rgb = pow(color.rgb * color.rgb, vec3(0.43));\n    color.rgb = aces_tonemap(color.rgb * 1.5);\n\n    // Multiply color by alpha to ensure background is black\n    color.rgb *= color.a;\n\n    // Output the color with its alpha channel\n    O = vec4(color.rgb, color.a);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Common functions\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 voronoi( in vec2 x )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tvec3 m = vec3( 8.0 );\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec2  o = hash22( n + g );\n        vec2  r = g - f + o;\n\t\tfloat d = dot( r, r );\n        if( d<m.x )\n            m = vec3( d, o );\n    }\n\n    return vec2( sqrt(m.x), m.y+m.z );\n}\n\nfloat smootherstep(float edge0, float edge1, float x)\n{\n  x = clamp((x - edge0)/(edge1 - edge0), 0.0, 1.0);\n  return x * x * x * (x * (x * 6.0 - 15.0) + 10.0);\n}\n\nfloat linear_map_range(float value, float fromMin, float fromMax, float toMin, float toMax)\n{\n  return toMin + ((value - fromMin) / (fromMax - fromMin)) * (toMax - toMin);\n}\n\nvec4 blur(sampler2D sampler, vec2 uv, vec2 scale, float sigma) {\n    vec4 O = vec4(0.0);\n    float samples = sigma * 4.0; \n    int LOD = max(0, int(log2(float(samples)))-2);\n    int sLOD = 1 << LOD;\n    int s = max(1, int(samples/float(sLOD)));\n    float sum = 0.0;\n\n    for (int i = 0; i < s*s; i++) {\n        vec2 d = vec2(float(i%s), float(i/s))*float(sLOD) - 0.5*float(samples);\n        vec2 dd = d / sigma;\n        float g = exp(-.5*dot(dd,dd))/(6.28318*sigma*sigma);\n        vec4 sampleColor = textureLod(sampler, uv + 1./scale * d, float(LOD));\n\n        // Weight the color by its alpha\n        float weight = g * sampleColor.a;\n        O.rgb += sampleColor.rgb * weight;\n        O.a += sampleColor.a * g;\n        sum += weight;\n    }\n\n    if (sum > 0.0) {\n        O.rgb /= sum;\n    } else {\n        O.rgb = vec3(0.0);\n    }\n    O.a /= samples * samples; // Normalize alpha\n\n    return O;\n}\n\nfloat value_noise_2d(vec2 coord, vec2 size, float seed) {\n\tvec2 o = floor(coord)+hash22(vec2(seed, 1.0-seed))+size;\n\tvec2 f = fract(coord);\n\tfloat p00 = hash12(mod(o, size));\n\tfloat p01 = hash12(mod(o + vec2(0.0, 1.0), size));\n\tfloat p10 = hash12(mod(o + vec2(1.0, 0.0), size));\n\tfloat p11 = hash12(mod(o + vec2(1.0, 1.0), size));\n\tvec2 t =  f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n\treturn mix(mix(p00, p10, t.x), mix(p01, p11, t.x), t.y);\n}\n\nfloat fbm(vec2 coord, float size, int octaves, float persistence, float seed) {\n\tfloat normalize_factor = 0.0;\n\tfloat value = 0.0;\n\tfloat scale = 1.0;\n\tfor (int i = 0; i < octaves; i++) {\n\t\tfloat noise = value_noise_2d(coord*size, vec2(size), seed);\n\t\tvalue += noise * scale;\n\t\tnormalize_factor += scale;\n\t\tsize *= 2.0;\n\t\tscale *= persistence;\n\t}\n\treturn value / normalize_factor;\n}\n\nvec3 aces_tonemap(vec3 color)\n{\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define ST smootherstep\n#define MR linear_map_range\n\n#if HW_PERFORMANCE == 0\n#define AA 1\n#else\n#define AA 2\n#endif\n\n#define WIDTH 3.\n\n#define TERRAIN_SEED 5.\n#define CLOUDS_SEED 10.\n\n#define TERRAIN_WARP_STRENGTH .2\n#define CLOUDS_WARP_STRENGTH .1\n\n#define TERRAIN_SCALE 4.\n#define CLOUDS_SCALE 10.\n\n#define CLOUDS_COVERAGE .35\n#define TERRAIN_COVERAGE .48\n\nfloat wn(vec2 p, float pp, float size, float s, float w)\n{\n    const int o = 5;\n    vec2 q = vec2(fbm(p,size,o,pp,s),fbm(p,size,o,pp,s+2.))-0.5;\n    return fbm(p+q*w,size,o,pp,s);\n}\n\nvoid mainImage(out vec4 O, in vec2 I)\n{\n    vec3 tot, col = vec3(0.);\n    vec2 ss = WIDTH / iResolution.xy / float(AA);\n    vec2 p = (2. * I - iResolution.xy) / iResolution.y * 1.7;\n\n    const vec2 off = vec2(.05, .01) * .5;\n    const vec2 dp = vec2(.7, .5);\n        \n    for (int x = 0; x++ < AA;)\n    for (int y = 0; y++ < AA;)\n    {   \n        vec2 uv = p;\n        uv += (vec2(float(x), float(y)) + vec2(.5)) * ss;\n\n        // sphere coords\n        float dduv = dot(uv, uv);\n        vec2 sp = uv / (sqrt(1.3 - dduv) + .85);\n        \n        float am = ST(1.32, 1.3, dduv);\n        sp *= am;\n\n        // mouse offset\n        vec2 spm = (iMouse.z > 0. ? sp + (-iMouse.xy / iResolution.xy * 3.) : sp);\n\n        // terrain noise\n        float t = floor(-.8 + wn(fract((spm * .5 + off * iTime)), .75, TERRAIN_SCALE, TERRAIN_SEED, TERRAIN_WARP_STRENGTH) * 32.) / 32.;\n\n        // clouds noise\n        float c = floor(wn(fract((spm * .45 + off * iTime)), .65, CLOUDS_SCALE, CLOUDS_SEED, CLOUDS_WARP_STRENGTH) * 24.) / 24.;\n\n        // clouds noise shadows\n        float cs = floor(wn(fract(((spm + vec2(.015)) * .45 + off * iTime)), .65, CLOUDS_SCALE, CLOUDS_SEED, CLOUDS_WARP_STRENGTH) * 24.) / 24.;\n\n        float cc = MR(CLOUDS_COVERAGE, 0., 1., -.25, .48);\n        c += cc;\n        cs += cc;\n\n        float tc = MR(TERRAIN_COVERAGE, 0., 1., -.5, .4);\n        t += tc;\n\n        // terrain colors\n        col = mix(vec3(.06, .25, .39), vec3(0, .09, .15), ST(.5, .3, t));\n        col = mix(col, vec3(0, .03, .05), ST(.32, .2, t));\n        col = mix(col, vec3(.85, .43, .25), ST(.42, .5, t));\n        col = mix(col, vec3(.15, .25, .04) * .8, ST(.48, .55, t));\n        col = mix(col, vec3(.1, .19, .1) * .5, ST(.55, .7, t));\n\n        // clouds\n        col = mix(col, col * .4, ST(0.45, .6, cs));\n        col = mix(col, vec3(1.), ST(0.5, .7, c));\n\n        // Background glow (transparent, no stars)\n        vec3 bgs = vec3(0.0, 0.0, 0.0);\n\n        // planet bg glow\n        float bgf = ST(0., 2.5, distance(uv, vec2(-.8)));\n        bgs = mix(bgs, bgs * 2.5 * vec3(1., 1.5, 1.), ST(4., -1., dduv) * bgf);\n        bgs = mix(bgs, bgs * 2.5 * vec3(1., 2.5, 2.), ST(2.5, -1., dduv) * bgf);\n\n        // planet\n        col = mix(bgs, col, ST(1.3, 1.25, dduv));\n\n        // shadows\n        col = mix(col, col * .1, ST(.9, 1.5, distance(sp, dp)));\n        col = mix(col, vec3(0.), ST(.5, 1.8, distance(sp, dp)));\n\n        // highlights\n        col = mix(col, col * 2., ST(1.2, .6, distance(sp, dp)));\n        col = mix(col, col * 2.8 * vec3(2., 1.2, .9), ST(.8, .15, distance(sp, dp)));\n\n        // atmosphere\n        col = mix(col, vec3(.1, .3, .6), ST(.6, 2.6, dduv) * am * bgf * 2.);\n        col = mix(col, vec3(.1, .7, 1.5) * 2., ST(1.1, 1.9, dduv) * am * bgf);\n\n        // outer glow\n        col = mix(col, vec3(.0, .3, 1.), ST(.2, -.6, abs(dduv - 1.32)) * bgf);\n        col = mix(col, vec3(.0, .45, .8), ST(.45, -1., abs(dduv - 1.32)) * bgf);\n\n        tot += col;\n    }\n\n    tot = tot / float(AA * AA);\n\n    // Set output color with transparency\n    O = vec4(tot, 1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}