{
    "Shader": {
        "info": {
            "date": "1725589414",
            "description": "Edits for fast evaluation.",
            "flags": 0,
            "hasliked": 0,
            "id": "4cjBWc",
            "likes": 9,
            "name": "Static Running Cubeman",
            "published": 3,
            "tags": [
                "animation",
                "walk"
            ],
            "usePreview": 0,
            "username": "pyBlob",
            "viewed": 103
        },
        "renderpass": [
            {
                "code": "// Static Running Cubeman.\n//\n// Improvements to \"Running Cubeman by triggthediscovery\":\n// - 60x faster\n// - Fixed lighting\n// - Shorter rotation\n// - Identity matrix is just mat3(1)\n// - Inverse of rotation is transpose, which is multiplying from the other side\n// - Cube only stores world transform\n// - Connect method for creating cube chains\n// - Move method for getting rid of joint cubes\n// - Named cubes\n// - Immediate raytracing hit evaluation (static = no dynamic array access)\n//\n// provided under CC0.\n\nstruct Hit {\n    vec3 col;\n    vec3 norm;\n    float dist;\n};\n\nstruct Cube {\n    vec3 pos;\n    vec3 size;\n    vec3 col;\n    mat3 rot;\n};\n\nCube move(Cube cube, vec3 pos, mat3 rot)\n{\n    cube.pos = cube.pos + pos * cube.rot;\n    cube.rot = rot * cube.rot;\n    return cube;\n}\n\nCube connect(vec3 pos, vec3 size, vec3 col, mat3 rot, Cube parent) {\n    parent.col = col;\n    parent.size = size;\n    return move(parent, pos, rot);\n}\n\nconst float min_dist = 1e-3;\nconst float max_dist = 1000.0;\n\nconst float ambient_light = 0.4;\n\nconst float floor_level = -2.0;\nconst float checkerboard = 4.0;\n\nHit best;\nvec3 ro;\nvec3 rd;\n\n// Calculates a ray intersection with an infinite\n// checkerboard which scrolls with time.\nvoid raytrace_floor()\n{\n    float dist = (ro.y - floor_level) / -rd.y;\n    if (dist > min_dist && dist < best.dist)\n    {\n        vec3 int_point = ro + rd * dist;\n\n        int_point.z += iTime * 6.07;\n\n        bool x_int = fract(int_point.x / checkerboard) < .5;\n        bool z_int = fract(int_point.z / checkerboard) < .5;\n\n        float fog = (clamp(pow(dist/30.0, 0.2)-0.65, 0.0, 0.5));\n\n        if (x_int != z_int)\n            best = Hit(vec3(fog), vec3(0,-1,0), dist);\n        else\n            best = Hit(vec3((1.0-fog)), vec3(0,-1,0), dist);\n    }\n}\n\nfloat boxIntersection(vec3 ro, vec3 rd, vec3 size, out vec3 normal)\n{\n    // https://iquilezles.org/articles/intersectors/\n    vec3 m = 1.0 / rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m * ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m) * size;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    if (tN > tF || tF < 0.0) return -1.; // no intersection\n    normal = (tN > 0.0) ? step(vec3(tN), t1) : step(t2, vec3(tF));\n    normal *= sign(rd);\n    return tN;\n}\n\n// Cube intersection with rotation.\nCube raytrace(Cube cube) {\n    vec3 normal;\n    float dist = boxIntersection(cube.rot * (ro - cube.pos), cube.rot * rd, cube.size, normal);\n\n    if (dist > min_dist && dist < best.dist)\n        best = Hit(cube.col, normal * cube.rot, dist);\n\n    return cube;\n}\n\n// Rotate around axis.\nmat3 rotations(vec3 v, float a) {\n    // https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula\n    mat3 K = mat3(0, -v.z, v.y, v.z, 0, -v.x, -v.y, v.x, 0);\n    return mat3(1) + K * sin(a) + K * K * (1. - cos(a));\n}\n\n// Complete raycast, to aid shadow calculations.\nHit raytrace(vec3 _ro, vec3 _rd) {\n    best = Hit(vec3(1), vec3(0), max_dist+1.0);\n    ro = _ro;\n    rd = _rd;\n    \n    float tim = iTime*5.0+1.0;\n\n    float torso_tilt = sin((tim*2.0)+3.0)/15.0+0.1;\n    float head_tilt = sin(((tim+0.2)*2.0)+3.0)/15.0+0.1;\n    \n    float u_leg = (sin(tim)/1.2)+3.1416;\n    float l_leg = u_leg/2.0 + cos(tim)/3.0;\n\n    float arm_swing = (sin((tim+0.8))/4.0)+3.1416;\n    float arm_twist = (sin((tim+0.8))/4.0);\n\n    float body_bob = sin((tim*2.0)+0.5)/8.0;\n\n    // Quick explanation, the general pattern here is connect, which\n    // initializes the cube, and places it relative to the parent.\n\n    // torso\n    Cube torso = raytrace(Cube(vec3(0.0, 0.5 + body_bob, 0.0), vec3(0.38,0.6,0.25), vec3(1.0, 0.5, 0.5),  rotations(vec3(1,0,0), torso_tilt)));\n\n    // right arm\n    Cube right_arm0 = raytrace(connect(vec3(0.55,0.4, 0.0), vec3(0.2, 0.2, 0.2), vec3(1.0, 0.5, 0.5), rotations(vec3(1,0,0), arm_swing+0.3), torso));\n    Cube right_arm1 = raytrace(connect(vec3(0,0.4,0),       vec3(0.13,0.4,0.13), vec3(1.0, 0.9, 0.7), rotations(vec3(0,1,0), -arm_twist   ), right_arm0));\n    Cube right_arm2 = raytrace(connect(vec3(0,0.4,0),       vec3(0.13,0.13,0.13),vec3(1.0, 0.9, 0.7), rotations(vec3(1,0,0), arm_swing+2.0), right_arm1));\n    Cube right_arm3 = raytrace(connect(vec3(0,0.4,0),       vec3(0.12,0.4,0.12), vec3(1.0, 0.9, 0.7), mat3(1)                              , right_arm2));\n\n    // left arm\n    Cube left_arm0 = raytrace(connect(vec3(-0.55,0.4,0.0), vec3(0.2, 0.2, 0.2), vec3(1.0, 0.5, 0.5), rotations(vec3(1,0,0), -arm_swing+0.3), torso));\n    Cube left_arm1 = raytrace(connect(vec3(0,0.4,0),       vec3(0.15,0.4,0.15), vec3(1.0, 0.9, 0.7), rotations(vec3(0,1,0), -arm_twist    ), left_arm0));\n    Cube left_arm2 = raytrace(connect(vec3(0,0.4,0),       vec3(0.13,0.13,0.13),vec3(1.0, 0.9, 0.7), rotations(vec3(1,0,0), -arm_swing+2.0), left_arm1));\n    Cube left_arm3 = raytrace(connect(vec3(0,0.4,0),       vec3(0.12,0.4,0.12), vec3(1.0, 0.9, 0.7), mat3(1), left_arm2));\n\n    // right leg\n    Cube right_leg0 = raytrace(connect(vec3(0.2,-0.5, 0.0), vec3(0.18,0.18,0.18),vec3(0.5, 0.5, 1.0), rotations(vec3(1,0,0), -u_leg-0.2), torso));\n    Cube right_leg1 = raytrace(connect(vec3(0,0.5,0),       vec3(0.18,0.5,0.18), vec3(0.5, 0.5, 1.0), mat3(1)                           , right_leg0));\n    Cube right_leg2 = raytrace(connect(vec3(0,0.5,0),       vec3(0.15,0.15,0.15),vec3(0.5, 0.5, 1.0), rotations(vec3(1,0,0), l_leg-1.0 ), right_leg1));\n    Cube right_leg3 = raytrace(connect(vec3(0,0.5,0),       vec3(0.15,0.5,0.15), vec3(0.5, 0.5, 1.0), mat3(1)                           , right_leg2));\n\n    // left leg\n    Cube left_leg0 = raytrace(connect(vec3(-0.2,-0.5, 0.0),vec3(0.18,0.18,0.18),vec3(0.5, 0.5, 1.0), rotations(vec3(1,0,0), u_leg-0.2 ), torso));\n    Cube left_leg1 = raytrace(connect(vec3(0,0.5,0),       vec3(0.18,0.5,0.18), vec3(0.5, 0.5, 1.0), mat3(1)                           , left_leg0));\n    Cube left_leg2 = raytrace(connect(vec3(0,0.5,0),       vec3(0.15,0.15,0.15),vec3(0.5, 0.5, 1.0), rotations(vec3(1,0,0), -l_leg+2.0), left_leg1));\n    Cube left_leg3 = raytrace(connect(vec3(0,0.5,0),       vec3(0.15,0.5,0.15), vec3(0.5, 0.5, 1.0), mat3(1)                           , left_leg2));\n\n    // head\n    Cube head = raytrace(connect(vec3(0, 1.0, 0),     vec3(0.25,0.3,0.25), vec3(1.0, 0.9, 0.7), rotations(vec3(1,0,0), -head_tilt), torso));\n\n    // neck\n    Cube neck = raytrace(connect(vec3(0, 0.5, 0),     vec3(0.15,0.5,0.15), vec3(1.0, 0.9, 0.7), mat3(1), torso));\n\n    raytrace_floor();\n\n    return best;\n}\n\nconst float gm_p = 1.5;\nconst float ch_p = 0.2;\n\nfloat gamma(float inp) {\n    return inp < ch_p ? inp * pow(ch_p, gm_p-1.0) : pow(inp, gm_p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord-(iResolution.xy/2.0);\n\n    uv /= iResolution.y;\n\n    float dist = 7.0;\n    float c_ang = (iTime + 4.5) / 2.0;\n\n    vec3 ro = vec3(sin(c_ang) * dist, 2.0, -(cos(c_ang) * dist));\n    vec3 rd = normalize(-ro);\n    vec3 light_dir = normalize(vec3(0.3, 0.6, 0.3));\n\n    float fov = 1.0;\n\n    mat3 lookat;\n    lookat[2] = rd;\n    lookat[0] = normalize(cross(vec3(0,1,0), lookat[2]));\n    lookat[1] = cross(lookat[2], lookat[0]);\n    \n    rd = lookat * normalize(vec3(uv.xy * fov, 1.0));\n\n    vec3 col = mix(vec3(0.7,0.8,1), vec3(0.5,0.6,1), uv.y);\n    \n    Hit main = raytrace(ro, rd);\n    if (main.dist < max_dist) {\n        vec3 hit_point = ro + rd * main.dist;\n\n        float light = ambient_light;\n\n        Hit sun = raytrace(hit_point, light_dir);\n        if (sun.dist > 100.0)\n            light += clamp(dot(main.norm, -light_dir), 0., 1.);\n\n        col = main.col * light;\n    }\n\n    col.x = gamma(col.x);\n    col.y = gamma(col.y);\n    col.z = gamma(col.z);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}