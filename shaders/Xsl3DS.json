{
    "Shader": {
        "info": {
            "date": "1474900006",
            "description": "Classic Whitted ray tracer, written for readability not performance.",
            "flags": 0,
            "hasliked": 0,
            "id": "Xsl3DS",
            "likes": 8,
            "name": "Ray Tracer",
            "published": 3,
            "tags": [
                "3d",
                "reflection",
                "ray",
                "refraction",
                "tracing",
                "tracer"
            ],
            "usePreview": 0,
            "username": "phagor",
            "viewed": 959
        },
        "renderpass": [
            {
                "code": "#ifdef GL_ES\nprecision highp float;\n#endif\n\nvec2 angle = vec2(0.0,0.0);\n\nconst vec3 eyePosition = vec3(0.0, 0.0, -3.0);\nconst float screenZ = -1.0;\nconst vec3 backgroundColour = vec3(0.0,0.0,0.1);\nconst float noIntersectionT = -1.0;\nconst float epsilon = 0.0001;\nconst int noBounces = 2;\nconst float distanceAttenuationPower = 0.2;\nconst float reflectionRefractionFactorLowerLimit = 0.1;\n\nstruct Ray {\n\tvec3 start;\n\tvec3 direction;\n};\n\t\nstruct Material {\n\tvec3 ambientColour;\n\tvec3 diffuseColour;\n\tvec3 specularColour;\n\tvec3 reflectedColour;\n\tvec3 refractedColour;\n\tfloat reflectiveness;\n\tfloat refractiveness;\n\tfloat shinyness;\n\tfloat refractiveIndex;\n};\n\t\nstruct Sphere {\n\tvec3 position;\n\tfloat radius;\n\tMaterial material;\n};\n\t\nstruct Plane {\n\tvec3 position;\n\tvec3 normal;\n\tfloat d;\n\tMaterial material1;\n\tMaterial material2;\n\tfloat squareSize;\n};\n\t\nstruct Cube {\n\tvec3 position;\n\tfloat size;\n\tMaterial material;\n};\n\t\nstruct Intersection {\n\tvec3 position;\n\tfloat t;\n\tvec3 normal;\n\tbool inside;\n\tMaterial material;\n};\n\t\nstruct Light {\n\tvec3 position;\n\tvec3 ambientColour;\n\tvec3 diffuseColour;\n\tvec3 specularColour;\n};\n\t\nMaterial defaultMaterial = \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.5,0.5,0.5), vec3(1.0,1.0,1.0), vec3(1.0,1.0,1.0), vec3(0.0,0.0,0.0), 0.0, 0.0, 40.0, 1.0 );\nMaterial redMaterial = \t\tMaterial ( vec3(0.0, 0.0, 0.0), vec3(1.0,0.0,0.0), vec3(1.0,1.0,1.0), vec3(1.0,1.0,1.0), vec3(0.0,0.0,0.0), 0.5, 0.0, 40.0, 1.0 );\nMaterial blueMaterial = \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0,0.0,1.0), vec3(1.0,1.0,1.0), vec3(1.0,1.0,1.0), vec3(0.0,0.0,0.0), 0.5, 0.0, 40.0, 1.0 );\nMaterial glassMaterial = \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0,0.0,0.0), vec3(1.0,1.0,1.0), vec3(0.0,0.0,0.0), vec3(1.0,1.0,1.0), 0.0, 1.0, 40.0, 1.5 );\nMaterial blackMaterial = \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.1,0.1,0.1), vec3(0.1,0.1,0.1), vec3(0.1,0.1,0.1), vec3(0.5,0.5,0.5), 0.1, 0.0, 1.0, 1.0 );\nMaterial whiteMaterial = \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.8,0.8,0.8), vec3(0.1,0.1,0.1), vec3(0.1,0.1,0.1), vec3(0.5,0.5,0.5), 0.1, 0.0, 1.0, 1.0 );\nMaterial mirrorMaterial = \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.2,0.2,0.2), vec3(1.0,1.0,1.0), vec3(1.0,1.0,1.0), vec3(0.0,0.0,0.0), 1.0, 0.0, 40.0, 1.0 );\n\nLight light = Light ( vec3(0.5, 0.5, -1.0), vec3(1.0,1.0,1.0), vec3(1.0,1.0,1.0), vec3(1.0,1.0,1.0) );\n\t\nbool intersectSphere(Ray ray, Sphere sphere, inout Intersection intersection) {\n\t\n\tfloat t0, t1, t;\n\t\n\tvec3 l = sphere.position - ray.start;\n\tfloat tca = dot(l, ray.direction);\n\tif ( tca < 0.0 )\n\t\treturn false;\n\tfloat d2 = dot (l, l) - (tca * tca);\n\tfloat r2 = sphere.radius*sphere.radius;\n\tif ( d2 > r2 )\n\t\treturn false;\n\tfloat thc = sqrt(r2 - d2);\n\tt0 = tca - thc;\n\tt1 = tca + thc;\n\t\t\n\tif ( t0 < 0.0 )\n\t\tt = t1;\n\telse if ( t1 < 0.0 )\n\t\tt = t0;\n\telse\n\t\tt = min(t0,t1);\n\t\t\t\n\tintersection.position = ray.start + t * ray.direction;\n\tintersection.t = t;\n\tintersection.normal = normalize ( intersection.position - sphere.position );\n\tintersection.material = sphere.material;\n\tintersection.inside = min(t0,t1) < epsilon && max(t0,t1) >= epsilon;\n\treturn true;\n}\n\nbool intersectPlane(Ray ray, Plane plane, inout Intersection intersection) {\n\n\tfloat t = - ( dot ( plane.normal, ray.start ) + length(plane.position) ) / ( dot ( plane.normal, ray.direction ) );\n\t\n\tif ( t < epsilon )\n\t\treturn false;\n\t\n\tintersection.position = ray.start + t * ray.direction;\n\tintersection.t = t;\n\tintersection.normal = plane.normal;\n\t\t\n\tvec3 p = mod ( intersection.position - plane.position - epsilon, plane.squareSize*2.0 );\n\tfloat s = plane.squareSize;\n\tfloat l = s;\n\tfloat h = s;\n\tif ( ( p.x < l && p.y < l && p.z < l ) ||\n\t     ( p.x > h && p.y < l && p.z > h ) ||\n\t     ( p.x < l && p.y > h && p.z > h ) ||\n\t     ( p.x > h && p.y > h && p.z < l ) )\n\t\tintersection.material = plane.material1;\n\telse\n\t\tintersection.material = plane.material2;\n\t\n\treturn true;\t\n}\n\nbool intersectCube(Ray ray, Cube cube, inout Intersection intersection) {\n\t\n\tvec3 minp = cube.position - cube.size/2.0;\n\tvec3 maxp = cube.position + cube.size/2.0;\n\t\n\tfloat tmin = (minp.x - ray.start.x) / ray.direction.x;\n\tfloat tmax = (maxp.x - ray.start.x) / ray.direction.x;\n\tif (tmin > tmax) { float s = tmin; tmin = tmax; tmax = s; }\n\tfloat tymin = (minp.y - ray.start.y) / ray.direction.y;\n\tfloat tymax = (maxp.y - ray.start.y) / ray.direction.y;\n\tif (tymin > tymax) { float s = tymin; tymin = tymax; tymax = s; }\n\tif ((tmin > tymax) || (tymin > tmax))\n\t\treturn false;\n\tif (tymin > tmin)\n\t\ttmin = tymin;\n\tif (tymax < tmax)\n\t\ttmax = tymax;\n\tfloat tzmin = (minp.z - ray.start.z) / ray.direction.z;\n\tfloat tzmax = (maxp.z - ray.start.z) / ray.direction.z;\n\tif (tzmin > tzmax) { float s = tzmin; tzmin = tzmax; tzmax = s; }\n\tif ((tmin > tzmax) || (tzmin > tmax))\n\t\treturn false;\n\tif (tzmin > tmin)\n\t\ttmin = tzmin;\n\tif (tzmax < tmax)\n\t\ttmax = tzmax;\n\t\n\tfloat t;\n\tif ( tmin < epsilon && tmax < epsilon )\n\t\treturn false;\n\tif ( tmin < epsilon )\n\t\tt = tmax;\n\telse if ( tmax < epsilon )\n\t\tt = tmin;\n\telse\n\t\tt = min(tmin, tmax);\n\t\t\n\tintersection.t = t;\n\tintersection.position = ray.start + t * ray.direction;\n\tintersection.material = cube.material;\n\tif ( tmin < epsilon && tmax > epsilon )\n\t\tintersection.inside = true;\n\t\n\tif ( abs(intersection.position.x - maxp.x) < epsilon )\n\t\tintersection.normal = vec3(1.0, 0.0,0.0);\n\telse if ( abs(intersection.position.x - minp.x) < epsilon )\n\t\tintersection.normal = vec3(-1.0,0.0,0.0);\n\telse if ( abs(intersection.position.y - maxp.y) < epsilon )\n\t\tintersection.normal = vec3(0.0,1.0,0.0);\n\telse if ( abs(intersection.position.y - minp.y ) < epsilon )\n\t\tintersection.normal = vec3(0.0,-1.0,0.0);\n\telse if ( abs(intersection.position.z - maxp.z ) < epsilon )\n\t\tintersection.normal = vec3(0.0,0.0,1.0);\n\telse\n\t\tintersection.normal = vec3(0.0,0.0,-1.0);\n\t\n\treturn true;\n}\n\nIntersection noIntersection () {\n\treturn Intersection(vec3(0.0,0.0,0.0),noIntersectionT,vec3(0.0,0.0,0.0),false,defaultMaterial);\n}\n\nbool hasIntersection(Intersection i) {\n\treturn i.t != noIntersectionT;\t\n}\n\n\nvec3 lighting(Ray ray, Intersection intersection, float shadowFactor) {\n\t\n\tvec3 colour = light.ambientColour * intersection.material.ambientColour;\n\n\tvec3 lightDir = normalize(light.position - intersection.position);\n\tvec3 eyeDir = normalize ( eyePosition - intersection.position );\n\tcolour += shadowFactor * light.diffuseColour * intersection.material.diffuseColour * max(dot(intersection.normal,lightDir), 0.0);\n\tvec3 reflected =  normalize ( reflect ( -lightDir, intersection.normal ) );\n\tcolour += shadowFactor * light.specularColour * intersection.material.specularColour * pow ( max ( dot(reflected, eyeDir), 0.0) , intersection.material.shinyness );\t\n\tcolour *= min ( 1.0/pow(length(intersection.position - ray.start), distanceAttenuationPower), 1.0);\n\n\treturn colour;\n}\n\nvoid intersection2(Ray ray, inout Intersection minIntersection) {\n\n\tIntersection intersection = noIntersection();\n\tSphere sphere;\n\t\t\n\tsphere = Sphere(vec3(-0.5,sin(iTime) + 0.5,0.5),0.4, redMaterial);\n\t\n\tif ( intersectSphere ( ray, sphere, intersection ) ) {\n\t\tif ( !hasIntersection(minIntersection) || intersection.t < minIntersection.t )\n\t\t\tminIntersection = intersection;\n\t}\n\t\n\tsphere = Sphere(vec3(0.5,cos(iTime) + 0.5,0.5),0.4, blueMaterial );\n\t\n\tif ( intersectSphere ( ray, sphere, intersection ) ) {\n\t\tif ( !hasIntersection(minIntersection) || intersection.t < minIntersection.t )\n\t\t\tminIntersection = intersection;\n\t}\n\t\n\tsphere = Sphere(vec3(0.0,0.0,-0.5),0.4, glassMaterial );\n\t\n\tif ( intersectSphere ( ray, sphere, intersection ) ) {\n\t\tif ( !hasIntersection(minIntersection) || intersection.t < minIntersection.t )\n\t\t\tminIntersection = intersection;\n\t}\n\tPlane plane;\n\t\n\tplane = Plane(vec3(0.0,-1.0,0.0), vec3(0.0,1.0,0.0), -1.0, blackMaterial, whiteMaterial, 1.0);\n\t\n\tif ( intersectPlane ( ray, plane, intersection ) ) {\n\t\tif ( !hasIntersection(minIntersection) || intersection.t < minIntersection.t )\n\t\t\tminIntersection = intersection;\n\t}\n\t\n\tPlane plane2 = Plane(vec3(0.0,0.0,10.0), vec3(0.0,0.0,-1.0), -10.0, blackMaterial, whiteMaterial, 1.0);\n\t\n\tif ( intersectPlane ( ray, plane2, intersection ) ) {\n\t\tif ( !hasIntersection(minIntersection) || intersection.t < minIntersection.t )\n\t\t\tminIntersection = intersection;\n\t}\n\t\n\tCube cube = Cube(vec3(0.8,-0.6,-0.7), 0.6, mirrorMaterial );\n\tif ( intersectCube ( ray, cube, intersection ) ) {\n\t\tif ( !hasIntersection(minIntersection) || intersection.t < minIntersection.t )\n\t\t\tminIntersection = intersection;\n\t}\n\t\n}\n\nconst int noSpheres = 4;\nSphere spheres[noSpheres];\nvec3 velocity[noSpheres];\nvec3 position[noSpheres];\n\nvoid intersection(Ray ray, inout Intersection minIntersection) {\n\n\tIntersection intersection = noIntersection();\n\tfloat r = 0.25;\n\tfloat fi;\n\tfor (int i=0; i<noSpheres; i++) {\n\t\tfi = float(i);\n\t\tposition[i] = vec3(sin(fi*1000.0),sin(fi*10000.0),sin(fi*100.0));\n\t\tspheres[i].radius = r;\n        if (mod(fi,2.0)==1.0) \n            spheres[i].material = blueMaterial;\n        else\n            spheres[i].material = redMaterial;\n        if ( mod(fi,4.0)==0.0 )\n\t\t\tspheres[i].material = glassMaterial;\n\t\t\n\t\tvelocity[i] = vec3(cos(fi*200.0+fi*400.0+500.0), cos(fi*400.0+fi*2000.0+500.0), cos(fi*600.0)) / 2.0;\n\t}\n\t\n\tvec3 p;\n\n\tfor (int i=0; i<noSpheres; i++) {\n\t\tp = position[i] + ( velocity[i] * iTime  );\n\t\t\n\t\tp = mod ( p, 4.0 ) - 2.0;\n\t\tif ( p.x > 1.0 )\n\t\t\tp.x = 2.0 - p.x;\n\t\tif ( p.y > 1.0 )\n\t\t\tp.y = 2.0 - p.y;\n\t\tif ( p.z > 1.0 )\n\t\t\tp.z = 2.0 - p.z;\n\t\tif ( p.x < -1.0 )\n\t\t\tp.x = -2.0 - p.x;\n\t\tif ( p.y < -1.0 )\n\t\t\tp.y = -2.0 - p.y;\n\t\tif ( p.z < -1.0 )\n\t\t\tp.z = -2.0 - p.z;\n\t\tspheres[i].position = p;\n\t\t\n\t\tif ( intersectSphere ( ray, spheres[i], intersection ) ) {\n\t\t\tif ( !hasIntersection(minIntersection) || intersection.t < minIntersection.t )\n\t\t\tminIntersection = intersection;\n\t\t}\n\t}\n\tPlane plane;\n\tfloat s = ( 1.0 + r*2.0 ) / 2.0;\n\t\n\tplane = Plane(vec3(0.0,-1.0 - r,0.0), vec3(0.0,1.0,0.0), -0.0, blackMaterial, whiteMaterial, s);\n\tif ( intersectPlane ( ray, plane, intersection ) ) {\n\t\tif ( !hasIntersection(minIntersection) || intersection.t < minIntersection.t )\n\t\t\tminIntersection = intersection;\n\t}\n\n\tplane = Plane(vec3(0.0,1.0 + r,0.0), vec3(0.0,-1.0,0.0), -0.0, blackMaterial, whiteMaterial, s);\n\tif ( intersectPlane ( ray, plane, intersection ) ) {\n\t\tif ( !hasIntersection(minIntersection) || intersection.t < minIntersection.t )\n\t\t\tminIntersection = intersection;\n\t}\t\n\n\tplane = Plane(vec3(-1.0 - r,0.0,0.0), vec3(1.0,0.0,0.0), -0.0, blackMaterial, whiteMaterial, s);\n\tif ( intersectPlane ( ray, plane, intersection ) ) {\n\t\tif ( !hasIntersection(minIntersection) || intersection.t < minIntersection.t )\n\t\t\tminIntersection = intersection;\n\t}\n\t\n\tplane = Plane(vec3(1.0 + r,0.0,0.0), vec3(-1.0,0.0,0.0), -0.0, blackMaterial, whiteMaterial, s);\n\tif ( intersectPlane ( ray, plane, intersection ) ) {\n\t\tif ( !hasIntersection(minIntersection) || intersection.t < minIntersection.t )\n\t\t\tminIntersection = intersection;\n\t}\n\n\tplane = Plane(vec3(0.0,0.0,1.0 + r), vec3(0.0,0.0,-1.0), -0.0, blackMaterial, whiteMaterial, s);\n\tif ( intersectPlane ( ray, plane, intersection ) ) {\n\t\tif ( !hasIntersection(minIntersection) || intersection.t < minIntersection.t )\n\t\t\tminIntersection = intersection;\n\t}\n\t\n}\n\t\nvec3 traceRay(Ray ray, inout Intersection minIntersection) {\n\n\tintersection2(ray, minIntersection);\n\t\n\tif ( hasIntersection(minIntersection) ) {\n\t\tRay shadowRay = Ray ( minIntersection.position + epsilon * minIntersection.normal, normalize(light.position - minIntersection.position) );\n\t\tIntersection shadowIntersection = noIntersection();\n\t\tintersection ( shadowRay, shadowIntersection );\n\t\tfloat shadowFactor = 1.0;\n\t\t\n\t\tif ( hasIntersection(shadowIntersection) && shadowIntersection.t < length(light.position - minIntersection.position) ) {\n\t\t\t//shadowFactor = 1.0 * shadowIntersection.material.refractiveness;\t\n\t\t\tshadowFactor = 0.8;\n\t\t}\n\n\t\treturn lighting ( ray, minIntersection, shadowFactor );\n\t}\n\telse\n\t\treturn backgroundColour;\n}\n\nRay myRefract(Ray ray, Intersection intersection) {\n\tfloat cosI = dot(ray.direction,intersection.normal);\n\tfloat n1,n2;\n\tRay refractedRay;\n\tif ( intersection.inside ) {\n\t\tn1 = intersection.material.refractiveIndex;\n\t\tn2 = 1.0;\n\t\tintersection.normal = -intersection.normal;\n\t}\n\telse {\n\t\tn2 = intersection.material.refractiveIndex;\n\t\tn1 = 1.0;\n\t\tcosI = -cosI;\n\t}\n\t\n\tfloat cosT = 1.0 - pow(n1/n2, 2.0) * (1.0 - pow(cosI, 2.0));\n\t\n\tif (cosT < 0.0) {\n\t\trefractedRay.direction = normalize ( reflect ( ray.direction, intersection.normal ) );\n\t\trefractedRay.start = intersection.position + (epsilon * intersection.normal);\n\t}\n\telse {\n\t\tcosT = sqrt(cosT);\n\t\trefractedRay.direction = normalize ( ray.direction * (n1/n2) + intersection.normal * ((n1/n2) * cosI - cosT) );\n\t\trefractedRay.start = intersection.position - (epsilon * intersection.normal);\n\t}\n\treturn refractedRay;\n}\n\nvec3 recurseRay(Ray ray) {\n\t\n\tvec3 colour = vec3(0.0,0.0,0.0);\n\tvec3 localColour;\n\tIntersection intersection = noIntersection();\n\t\n\tIntersection firstIntersection = noIntersection();\n\tcolour = traceRay ( ray, firstIntersection );\n\t\n\tif (hasIntersection(firstIntersection)) {\n\t\n\t\tfloat reflectionFactor = firstIntersection.material.reflectiveness;\n\t\t\n\t\tif ( reflectionFactor >= reflectionRefractionFactorLowerLimit ) {\n\t\t\t\n\t\t\tray.start = firstIntersection.position;\n\t\t\tray.direction = reflect ( ray.direction, firstIntersection.normal );\n\t\t\t\n\t\t\tfor (int i=0; i<noBounces; i++) {\n\t\t\t\tintersection = noIntersection();\n\t\t\t\tlocalColour = traceRay(ray, intersection);\n\t\t\t\tif ( hasIntersection(intersection) ) {\t\n\t\t\t\t\t\n\t\t\t\t\tcolour += reflectionFactor * localColour;\n\t\t\t\t\treflectionFactor *= intersection.material.reflectiveness;\n\t\t\t\t\tif ( reflectionFactor < reflectionRefractionFactorLowerLimit )\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tray.start = intersection.position;\n\t\t\t\t\tray.direction =  ( reflect ( ray.direction, intersection.normal ) );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcolour += reflectionFactor * backgroundColour;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\n\t\tfloat refractionFactor = firstIntersection.material.refractiveness;\n\t\t\n\t\tif ( refractionFactor >= reflectionRefractionFactorLowerLimit ) {\t\t\n\t\t\n\t\t\t/*\n\t\t\tvec3 refractedDirection = normalize ( refract ( ray.direction, firstIntersection.normal, firstIntersection.material.refractiveIndex ) );\n\t\t\tray.start = firstIntersection.position + epsilon * refractedDirection;\n\t\t\tray.direction = refractedDirection;\n\t\t\t*/\n\t\t\tray = myRefract(ray, firstIntersection);\n\t\t\t\n\t\t\tfor (int i=0; i<noBounces; i++) {\n\t\t\t\tintersection = noIntersection();\n\t\t\t\tlocalColour = traceRay(ray, intersection);\n\t\t\t\tif ( hasIntersection(intersection) ) {\t\n\t\t\n\t\t\t\t\tcolour += refractionFactor * localColour;\n\t\t\t\t\trefractionFactor *= intersection.material.refractiveness;\n\t\t\t\t\tif ( refractionFactor < reflectionRefractionFactorLowerLimit )\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tray = myRefract ( ray, intersection );\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcolour += refractionFactor * backgroundColour;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\treturn backgroundColour;\n\t\n\treturn colour;\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\t\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat sx = 0.6;\n\tfloat sy = 0.6;\n    if (iMouse.z>0.0)\n\t   \tangle = (iMouse.xy-iMouse.zw)/iResolution.xy;\n\tmat4 mx = rotationMatrix ( vec3(0.0,1.0,0.0), angle.x * sx );\n\tmat4 my = rotationMatrix ( vec3(1.0,0.0,0.0), angle.y * sy );\n\t\n\tfloat y = (fragCoord.y * 2.0)/iResolution.y - 1.0;\n\tfloat ratio = iResolution.x/iResolution.y;\n\tfloat x = ((fragCoord.x * 2.0)/iResolution.x - 1.0) * ratio;\n\tvec4 pixelPosition = vec4(x,y,screenZ,1.0) * mx * my;\n\tvec4 rotatedEyePosition = vec4(eyePosition,1.0) * mx * my;\n            \n\tRay ray = Ray(rotatedEyePosition.xyz, normalize(pixelPosition-rotatedEyePosition).xyz);\n    vec3 col = recurseRay(ray);\n    \n    //IQ\n    //col = pow(col, vec3(0.4545));\n    //col = pow(col, vec3(0.8,0.85,0.9));\n    //gamma correction\n    //col = pow(col, vec3(1.0/1.6));\n    \n\tfragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}