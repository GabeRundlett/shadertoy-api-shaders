{
    "Shader": {
        "info": {
            "date": "1536519619",
            "description": "Zoom into the Mandelbrot set...",
            "flags": 0,
            "hasliked": 0,
            "id": "MlGcDw",
            "likes": 5,
            "name": "Mandy!",
            "published": 3,
            "tags": [
                "mandelbrotfractal"
            ],
            "usePreview": 0,
            "username": "teraspora",
            "viewed": 662
        },
        "renderpass": [
            {
                "code": "// Mandelbrot Set in GLSL\n// Created by John Lynch - Sep 2018;\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst float PI = 3.141592653589793234;\nconst float SCALE_PER_FRAME = 1.003;\nconst vec4 white = vec4(1., 1., 1., 1.);\nconst vec4 black = vec4(0., 0., 0., 1.);\nconst vec4 orange = vec4(1.0, 0.4, 0., 1.);\nconst vec4 cyan = vec4(0., 0.4, 1.0, 1.);\nconst vec4 magenta = vec4(1.0, 0., 1.0, 1.);\nconst vec4 gold = vec4(1.0, 0.84, 0.66, 1.);\n\nvec4[] cols = vec4[](black, gold, black, gold, black, orange, black, white, black, orange, black);\nint numFirstColours = 12;\nbool modifiedColours = true;\n\nfloat aspectRatio;\nhighp vec2 zMin;    // corners of the region of the Complex plane we're looking at\nhighp vec2 zMax;\nhighp vec2 zSpan;\nhighp vec2 zIncr;\n\nconst float escapeRadius = 6.0;\nconst float escapeRadius2 = 36.0;\nfloat exponent = 2.;\nint maxIterations = 1024;\n\n// ==================================================================\n// Some functions adapted from Github - \n// https://github.com/tobspr/GLSL-Color-Spaces/blob/master/ColorSpaces.inc.glsl\n// - not tested!\n\nvec3 hue2rgb(float hue)\n{\n    float R = abs(hue * 6. - 3.) - 1.;\n    float G = 2. - abs(hue * 6. - 2.);\n    float B = 2. - abs(hue * 6. - 4.);\n    return clamp(vec3(R,G,B), 0., 1.);\n}\n\n// Converts a value from linear RGB to HCV (Hue, Chroma, Value)\nvec3 rgb2hcv(vec3 rgb) {\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 P = (rgb.g < rgb.b) ? vec4(rgb.bg, -1.0, 2.0/3.0) : vec4(rgb.gb, 0.0, -1.0/3.0);\n    vec4 Q = (rgb.r < P.x) ? vec4(P.xyw, rgb.r) : vec4(rgb.r, P.yzx);\n    float C = Q.x - min(Q.w, Q.y);\n    float H = abs((Q.w - Q.y) / (6. * C + 1.e-10) + Q.z);\n    return vec3(H, C, Q.x);\n}\n\n// Converts from HSL to linear RGB\nvec3 hsl2rgb(vec3 hsl) {\n    vec3 rgb = hue2rgb(hsl.x);\n    float C = (1. - abs(2. * hsl.z - 1.)) * hsl.y;\n    return (rgb - 0.5) * C + hsl.z;\n}\n\n// Converts from linear rgb to HSL\nvec3 rgb2hsl(vec3 rgb) {\n    vec3 HCV = rgb2hcv(rgb);\n    float L = HCV.z - HCV.y * 0.5;\n    float S = HCV.y / (1. - abs(L * 2. - 1.) + 1.e-10);\n    return vec3(HCV.x, S, L);\n}\n\n// ======================== USEFUL FUNCTIONS ========================\nvoid updateGeometryVars() {\n    zSpan = zMax - zMin;\n    zIncr = zSpan / iResolution.xy;\n}\n\nvec2 xyToPixel(vec2 z, vec2 zMin, vec2 zMax) {\n    return (z - zMin) / (zMax - zMin) * iResolution.xy;\n}\n\nvec2 pixelToXy(vec2 pixel, vec2 zMin, vec2 zMax) {\n    return pixel / iResolution.xy * (zMax - zMin) + zMin;\n}\n\nvoid scale(float factor) {\n    highp vec2 halfDiag = (zMax - zMin) / 2.0;\n    highp vec2 centre = zMin + halfDiag;\n    zMin = centre - halfDiag / factor;\n    zMax = centre + halfDiag / factor;\n    updateGeometryVars();\n}\n\n// some complex functions for later use...\nfloat modc(vec2 z) {\n    return length(z);\n}\n\nfloat arg(vec2 z) {\n    return atan(z.y, z.x);\n}\n\nvec2 polar(float r, float phi) {\n    return vec2(r * cos(phi), r * sin(phi));\n}\n\nvec2 boxFold(vec2 z, float fold) {\n    return vec2(z.x > fold ? 2. * fold - z.x : (z.x < -fold ? -2. * fold - z.x : z.x),\n                z.y > fold ? 2. * fold - z.y : (z.y < -fold ? -2. * fold - z.y : z.y));\n}\n\nvec2 ballFold(vec2 z, float r, float bigR) {\n    float zAbs = modc(z);\n    r = abs(r);\n    return zAbs < r ? z / (r * r) : (zAbs < abs(bigR)) ?\n            z / (zAbs * zAbs)\n            : z;\n}\n\n// ======================= The functions to iterate ======================\n\nhighp vec2 f0(vec2 z, vec2 w) {\n    return vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y) + w;\n}\n\n// ======================= The grindstone ================================\nfloat iterate(vec2 z) {\n    int numIts = 0;\n    float realIts = 0.;\n    vec2 z0 = z;\n    float zAbs = z.x * z.x + z.y * z.y;\n    float zAbsPrevious = zAbs;\n    while (numIts < maxIterations && zAbs < escapeRadius) {\n        numIts++;\n        // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n        z = f0(z, z0); // iterate the fn\n        // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n        zAbsPrevious = zAbs;\n        zAbs = z.x * z.x + z.y * z.y;\n    }\n    if (zAbs < escapeRadius) {\n        realIts = float(numIts + 1) - (log(log(zAbs + 1.) + 1.) / log(log(escapeRadius + 1.) + 1.));\n    }\n    else {\n        float far = max(exponent, log(zAbs) / log(zAbsPrevious));\n        realIts = float(numIts) - (log(log(zAbs)) - log(log(escapeRadius))) / log(far);\n    }\n    return ++realIts;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // I'd like to declare these three outside of this main method, but can't find a \n    // way to keep the compiler happy. :(\n    aspectRatio = iResolution.x / iResolution.y;\n    zMin = vec2(-1.2 * aspectRatio - 0.5035, -0.594);    // corners of the region of the Complex plane we're looking at\n    zMax = vec2(1.2 * aspectRatio - 0.5035, 1.806);\n        \n    scale(pow(SCALE_PER_FRAME, float(iFrame)));\n           \n    vec2 z = pixelToXy(fragCoord.xy, zMin, zMax);\n    float its = iterate(z);\n    float nfc = float(numFirstColours);\n    float colourMappingFactor = (nfc - 1.) / float(maxIterations); \n    \n    float colourIndex = modifiedColours ? mod(its, nfc) : mod(its * colourMappingFactor, nfc); // map iteration count to a colour\n    int firstColourIndex = int(floor(colourIndex));\n    float interpolationFactor = mod(colourIndex, 1.);\n    \n    // Slight precautionary hack!    Or let's call it clamping!\n    if (firstColourIndex >= numFirstColours) {\n        firstColourIndex = numFirstColours - 1;\n        interpolationFactor = 1.;\n    }    \n    if (firstColourIndex < 0) {\n        firstColourIndex = 0;\n    }\n\n    vec4 col = mix(cols[firstColourIndex], cols[int(mod(float(firstColourIndex + 1), float(cols.length())))], interpolationFactor);\n    if (iTime > 64.) {\n        col -= vec4(0.1, 0.1, 0.1, 0.00) * (iTime - 64.0);  // fade when losing resolution \n    }\n    \n    // =================== Change hue... =========================\n    vec3 c = rgb2hsl(col.rgb);\n    c.s = mod(c.s - iTime / 21., 1.0);\t// so hue rotates\n    col = vec4(hsl2rgb(c), 1.);    \n    // ===========================================================\n    \n    fragColor = col;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}