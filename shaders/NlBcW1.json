{
    "Shader": {
        "info": {
            "date": "1649579360",
            "description": "Ray Marching,Sphere Tracing",
            "flags": 0,
            "hasliked": 0,
            "id": "NlBcW1",
            "likes": 1,
            "name": "10-2 Simple RayMarching",
            "published": 3,
            "tags": [
                "raymarching",
                "mouse",
                "spheretracing"
            ],
            "usePreview": 0,
            "username": "ccc9527",
            "viewed": 249
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 100   //光线前进最大步数\n#define MAX_DIST 100.0  //最大距离100\n#define SURF_DIST 0.01  //点到物体最近的表面距离小于这个距离即理解为击中表面\n\n//球体sdf,sphere前三个参数是球心位置坐标,最后一个参数是半径\nfloat SphereSDF(vec3 p,vec4 sphere)\n{\n    return length(p-sphere.xyz)-sphere.w;\n}\n\n//胶囊体sdf,a/b是胶囊体两端半球的球心,r是半球的半径\nfloat CapsuleSDF(vec3 p,vec3 a,vec3 b,float r)\n{\n    vec3 ap = p-a;\n    vec3 ab = b-a;\n    \n    //ap在ab方向上的投影除以ab的长度,并截止到(0,1)之间,\n    //所以点a上面部分是c=a,点b下面的是c=b\n    //上面的部分离胶囊体最近距离是ap的距离减半径,下面同理\n    float t = dot(ab,ap)/dot(ab,ab);\n    t = clamp(t,0.0,1.0);\n    vec3 c = a+t*ab;\n    \n    return length(p-c)-r;\n}\n\n//环面sdf,a表示换面中心点位置,r.x表示大半径,r.y表示小半径\nfloat TorusSDF(vec3 p,vec3 a,vec2 r)\n{\n    //点p在xz平面内到中心点的距离减去大半径\n    float x = length(p.xz-a.xz)-r.x;\n    \n    //根据 点p在xz平面内到中心点的距离和y方向的距离 \n    //计算p到外环中间的距离,然后减去外环的半径\n    //得到点p距物体表面的最小值\n    return length(vec2(x,p.y-a.y))-r.y;\n}\n\n//box,盒子sdf(立方体或长方体),a表示盒子中心点坐标,size表示长宽高\nfloat BoxSDF(vec3 ap,vec3 size)\n{\n    return length(max(abs(ap)-size,0.0));\n}\n\n//Cylinder,圆柱sdf,类似胶囊体\nfloat CylinderSDF(vec3 p,vec3 a,vec3 b,float r)\n{\n    vec3 ap = p-a;\n    vec3 ab = b-a;\n    \n    float t = dot(ap,ab)/dot(ab,ab);   \n    vec3 c = a+t*ab;\n    \n    float d = length(p-c)-r;\n    float y = abs(t-0.5)-0.5;\n    y *= length(ab);\n    \n    float dist = length(max(vec2(d,y),0.0));\n    \n    return dist+min(max(d,y),0.0);\n}\n//输入角度,返回某个平面的旋转矩阵\nmat2 Rot(float t)\n{\n    float s = sin(t);\n    float c = cos(t);\n    return mat2(c,-s,s,c);\n}\n\n//获得每一步的距离,场景中只有一个平面和一个球\nfloat GetDist(vec3 p)\n{   \n    //Sphere,球,前三个参数是圆心位置,第四个是半径\n    vec4 sphere = vec4(-6,1,10,1);\n    \n    //胶囊体参数\n    vec3 a = vec3(-3.0,2.0,10.0);//胶囊体上半球的球心\n    vec3 b = vec3(-3.0,0.5,10.0);//胶囊体下半球的球心\n    float t = 0.5;    //两个球的半径\n    \n    //环面参数\n    vec3 a1 = vec3(0,1.0,10.0);//环面中心点位置坐标\n    vec2 r = vec2(1.0,0.3);//x表示大半径,y表示小半径\n    \n    //盒子参数\n    vec3 a2 = vec3(3.0,1.0,10.0);//立方体中心坐标\n    vec3 a2p = a2-p;\n    //a2p.xz *= Rot(iTime);\n    //a2p -= vec3(2,-1,0); //平移,translation\n    vec3 size = vec3(1);\n    \n    //圆柱体参数\n    vec3 a3 = vec3(6.0,2.0,10.0);\n    vec3 b3 = vec3(6.0,0.0,10.0);\n    float r3 = 0.5;\n    \n    //点p距离场景中各个物体的距离\n    float sphereDist = SphereSDF(p,sphere);//点p到球体的最小距离\n    float planeDist = p.y;//点p到屏幕的距离,片面位于y=0\n    float capsuleDist = CapsuleSDF(p,a,b,t);\n    float torusDist = TorusSDF(p,a1,r);\n    float boxDist = BoxSDF(a2p,size);\n    float cylinderDist = CylinderSDF(p,a3,b3,r3);\n    \n    //选出最小的距离,即每次前进的安全距离\n    float d = min(sphereDist,planeDist);\n    d = min(d,capsuleDist);\n    d = min(d,torusDist);\n    d = min(d,boxDist);\n    d = min(d,cylinderDist);\n    \n    return d;\n}\n//光线前进,计算每个方向上光线前进多少距离击中表面,即到物体表面的距离\nfloat RayMarching(vec3 ro,vec3 rd)\n{\n    float d0 = 0.0;\n    \n    for(int i=0;i<MAX_STEPS;i++)\n    {\n        vec3 p = ro+rd*d0;\n        float ds = GetDist(p);//获得每一次前进的距离\n        d0 += ds;\n        //前进总距离大于MAX_DIST认为是该方向击中不了物体,\n        //前进的距离小于SURF_DIST认为是击中物体表面\n        if(d0>MAX_DIST || ds<SURF_DIST) break;\n    }\n    \n    return d0;\n}\n//获得点p的法向量\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p);\n    vec2 e = vec2(0.001,0);\n    \n    vec3 normal = d-vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx)\n    );\n    \n    return normalize(normal);\n}\n\nfloat CalcAO(vec3 p,vec3 n)\n{\n    float res = 0.;\n    float scale = 1.;\n    for (int i=0;i<5;i++)\n    {\n        float h = 0.01+0.03*float(i);\n        float d = GetDist(p+n*h);\n        res += (h-d)*scale;\n        scale *= 0.95;\n        if (res > 0.35) break;\n    }\n    return clamp(1.-3.*res,0.,1.);\n}\n\n//获得点p的颜色,blinn-phong模型\nvec3 GetLight(vec3 p,vec3 ro)\n{\n    vec3 lightPos = vec3(3,5,5);//光源位置\n    vec3 lightCol = vec3(1.0);//光源颜色\n    lightPos.xz += vec2(sin(2.0*iTime),cos(2.0*iTime));\n    \n    //红宝石材质属性\n    vec3 k_a = vec3(0.1745,0.01175,0.01175);//环境反射率\n    vec3 k_d = vec3(0.61424,0.041362,0.04136);//漫反射率\n    vec3 k_s = vec3(0.727811,0.626959,0.626959);//镜面反射率\n    float shininess = 76.8;//高光指数\n    \n    vec3 lightDir = normalize(lightPos-p);//光向量\n    vec3 normal = GetNormal(p);//获得点p的法向量\n    \n    //环境光\n    vec3 ambient = k_a*0.5;\n    \n    //漫反射\n    float dif = clamp(dot(lightDir,normal),0.0,1.0);\n    vec3 diffuse = lightCol*k_d*dif;\n    \n    //高光\n    vec3 viewDir = normalize(ro-p);//视向量\n    vec3 halfDir = normalize(viewDir+lightDir);//半程向量\n    float spec = pow(max(dot(halfDir,normal),0.0),shininess);//高光系数\n    vec3 specular = lightCol*k_s*spec;//高光\n    \n    //阴影,将点p沿法线外移两个SURF_DIST的距离,然后在向光源的\n    //方向RayMarching计算距离,若距离小于光源点到p的距离\n    //那么说明点p到光源之间有物体遮挡,是阴影部位\n    vec3 p2 = p + normal*SURF_DIST*2.0;\n    float d = RayMarching(p2,lightDir);\n    if(d<length(lightPos-p)) return ambient;\n    \n    vec3 color = ambient+diffuse+specular;\n    \n    //计算ao\n    float ao = CalcAO(p,normal);\n    \n    return color*ao;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0.0);\n    \n    float time = iTime;\n    \n    vec3 ro = vec3(0.0,3.0,1.0);\n    //射线原点随鼠标移动距离进行旋转\n    ro.yz *= Rot(-mo.y+.4);\n    ro.xz *= Rot(-mo.x*6.2831);\n    vec3 rd = normalize(vec3(uv.x,uv.y,1.0));//射线方向\n    \n    float d = RayMarching(ro,rd);//获得每个rd方向上需要前进的距离\n    vec3 p = ro+rd*d;//根据前进距离和rd求得射线击中物体的点\n    \n    //blinn-phong光照模型\n    col = GetLight(p,ro);    \n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}