{
    "Shader": {
        "info": {
            "date": "1576791772",
            "description": "Convince me that this is a homology sphere. (mess with the mouse and arrow keys as well as 'A' and 'D')",
            "flags": 48,
            "hasliked": 0,
            "id": "WtcGRj",
            "likes": 6,
            "name": "Homology Sphere?",
            "published": 3,
            "tags": [
                "3d",
                "raymarch",
                "topology",
                "6d"
            ],
            "usePreview": 0,
            "username": "Ebanflo",
            "viewed": 488
        },
        "renderpass": [
            {
                "code": "/*\nAccording to wikipedia\nhttps://en.wikipedia.org/wiki/Homology_sphere#Construction\nThe link of the singularity of a Brieskorn variety\nhttps://en.wikipedia.org/wiki/Brieskorn_manifold\nhas the homology of a sphere.\n\nThis is a cross section of the intersection of a Brieskorn variety in 3\ncomplex variables with a 6-sphere; the keyboard allows you to change which\ncross section.\n\nI made this to try to understand why this object has the homology of a sphere.\nThis particular example should have the homology of a 3-sphere. That is, 1\nconnected component, 1 4D hollow hyper-volume, and no other cavities.\nI made this to try to understand why this is, but I still can't see it.\n\nI'm not sure if this is a proper SDF; I just extended the classic conversion\nof a real-valued function into an SDF to the complex setting by computing\nthe complex gradient of the polynomial analytically. It should still have\nthe topology of the actual variety, I think.\n*/\n#define far 30.0\n#define close 0.02\n#define steps 60\n#define light vec3(1)\n\n#define m iMouse.xy==vec2(0)?sin(vec2(0.1*iTime,0.1*iTime+1.57)):2.0*(2.0*iMouse.xy-iResolution.xy)/iResolution.y\n\n#define pretty_colors\n\n//all must be integers greater than 1\n//for the manifold to be a homology sphere, they must be coprime\nconst int exponents[] = int[](7, 8, 9);\n\nconst float radius = 10.0;\n\nvec2 polynomial(vec2 z[3]){\n    vec2 result = vec2(0);\n    for(int i = 0; i < 3; i++)\n        result += cpow(z[i], float(exponents[i]));\n    return result;\n}\n\nvec2[3] cgradient(vec2 z[3]){\n    vec2 result[3];\n    for(int i = 0; i < 3; i++)\n        result[i] = float(exponents[i])*cpow(z[i], float(exponents[i]) - 1.0);\n    return result;\n}\n\nvec3 calcNormal(vec2 z[3]){\n    vec2 grad[3] = cgradient(z);\n    return normalize(vec3(grad[0], grad[1].x));\n}\n\n//distance to the variety should be the magnitude of the polynomial\n//normalized by its complex gradient\nfloat sdVariety(vec2 z[3]){\n    vec2 poly = polynomial(z);\n    vec2 grad[3] = cgradient(z);\n    float lgrad = length(grad[0]) + length(grad[1]) + length(grad[2]);\n    return length(poly/lgrad);\n}\n\nfloat sdSphere(vec2 z[3]){\n    float d = 0.0;\n    for(int i = 0; i < 3; i++) d += dot(z[i], z[i]);\n    d = sqrt(d);\n    return d - radius;\n}\n\nvec3 render(vec3 ro, vec3 rd){\n    vec3 offset = texture(iChannel0, vec2(0.5)).rgb;\n    vec2[3] p = vec2[](ro.xy, vec2(ro.z, offset.x), offset.yz);\n    vec2[3] dir = vec2[](rd.xy, vec2(rd.z, 0), vec2(0));\n    float t = 0.0;\n    bool hit = false;\n    for(int i = 0; i < steps; i++){\n        float d = max(sdSphere(p), sdVariety(p));\n        if(d < close){hit = true; break;}\n        p = add(p, mul(d, dir));\n        t += d;\n        if(t > far) break;\n    }\n    if(hit){\n        vec3 color = 0.5 + 0.5*sin(6.0*offset + vec3(0.12453, 1.8374, 2.83894));\n        color = max(vec3(0.4), color);\n        vec3 normal = calcNormal(p);\n        #ifdef pretty_colors\n        return (0.5 + 0.5*normal)*color;\n        #else\n        return max(0.4, -dot(light, normal))*color;\n        #endif\n    }\n    else return vec3(0);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    vec2 xy = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0, 0, -3);\n    vec3 rd = normalize(vec3(xy, 2));\n    ro = r(ro, m);\n    rd = r(rd, m);\n    fragColor = vec4(render(ro, rd), 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec2[3] add(vec2[3] a, vec2[3] b){\n    for(int i = 0; i < 3; i++) a[i] += b[i];\n    return a;\n}\n\nvec2[3] mul(float s, vec2[3] v){\n    for(int i = 0; i < 3; i++) v[i] *= s;\n    return v;\n}\n\n//rodolphito's code----------------------------------\n\nvec3 r(vec3 v, vec2 r){\n    vec4 t = sin(vec4(r, r + 1.5707963268));\n    float g = dot(v.yz, t.yw);\n    return vec3(v.x * t.z - g * t.x,\n                v.y * t.w - v.z * t.y,\n                v.x * t.x + g * t.z);\n}\n\n//Complex+Quaternion+Octonion+Sedenion code\n//use with attribution (c) Rodol 2018\n//https://www.shadertoy.com/view/ldGyR3\n\nvec4 pi = vec4(0,2,4,8)*atan(1.0);\n\n// (1,i)\nvec2 creal(float a){return vec2(a,0);}\nfloat csl (vec2 z){return dot(z,z);}\nfloat cl  (vec2 z){return sqrt(csl(z));}\nfloat csil(vec2 z){return z.y*z.y;}\nfloat cil (vec2 z){return z.y;}\nfloat carg(vec2 z){return atan(cil(z),z.x);}\nvec2 cconj(vec2 z){z.x=-z.x;return-z;}\nvec2 cmul (vec2 z,float b){return z*b;}\nvec2 cmul (vec2 a,vec2 b){return mat2(a,-a.y,a.x)*b;}\nvec2 csqr (vec2 z){return vec2(z.x*z.x-z.y*z.y,2.0*z.y*z.x);}\nvec2 ccube(vec2 z){return vec2(z.x*z.x-3.0*z.y*z.y,3.0*z.x*z.x-z.y*z.y)*z;}\nvec2 cinv (vec2 z){return cconj(z)/csl(z);}\nvec2 cdiv (vec2 a,vec2 b){return cmul(a,cinv(b));}\nvec2 cexp (vec2 z){float l=cil(z);return sin(l+pi.yx)*exp(z.x);}\nvec2 clog (float x){return vec2(log(abs(x)),pi.z*step(0.0,x));}\nvec2 cpow (float a,vec2 z){float l=cil(z);return sin(l+pi.yx)*pow(a,z.x);}\nvec2 cpow (vec2 z,float n){return pow(csl(z),n*0.5)*sin(carg(z)*n+pi.yx);}\nvec2 cpow (vec2 a,vec2 b){return cmul(cpow(csl(a),0.5*b),cexp(carg(a)*b));}\n\n// (1,i,j,k)\nvec4 qreal(float a){return vec4(a,vec3(0));}\nfloat qsl (vec4 q){return dot(q,q);}\nfloat ql  (vec4 q){return sqrt(qsl(q));}\nfloat qsil(vec4 q){return dot(q.yzw,q.yzw);}\nfloat qil (vec4 q){return sqrt(qsil(q));}\nfloat qarg(vec4 q){return atan(qil(q),q.x);}\nvec4 qconj(vec4 q){q.x=-q.x;return-q;}\nvec3 qmul (vec4 q,vec3 v){return v+2.0*cross(cross(v,q.yzw)+q.x*v,q.yzw);}\nvec4 qmul (vec4 a,vec4 b){return vec4(a.x*b.x-dot(a.yzw,b.yzw),b.yzw*a.x+a.yzw*b.x+cross(a.yzw,b.yzw));}\nvec4 qsqr (vec4 q){return vec4(q.x*q.x-qsil(q),2.0*q.x*q.yzw);}\nvec4 qcube(vec4 q){float l=qsil(q);return q*vec2(3.0*q.x*q.x-l,q.x*q.x-3.0*l).yxxx;}\nvec4 qinv (vec4 q){return qconj(q)/qsl(q);}\nvec4 qdiv (vec4 a,vec4 b){return qmul(a,qinv(b));}\nvec4 qexp (vec4 q){float l=qil(q);vec2 z=sin(l+pi.xy)*exp(q.x);q*=z.x/l;q.x=z.y;return q;}\nvec4 qlog (float x){return vec4(log(abs(x)),step(0.0,x),vec2(0));}\nvec4 qpow (float a,vec4 q){float l=qil(q);vec2 z=sin(l+pi.xy)*pow(a,q.x);q*=z.x/l;q.x=z.y;return q;}\nvec4 qpow (vec4 q,float n){return pow(qsl(q),n*0.5)*sin(qarg(q)*n+pi.xy).yxxx;}\nvec4 qpow (vec4 a,vec4 b){return qmul(qpow(qsl(a),0.5*b),qexp(qarg(a)*b));}\n\n// (1,i,j,k,l,m,n,o)\nmat2x4 oreal(float a){return mat2x4(a,vec3(0),vec4(0));}\nfloat osl (mat2x4 o){return qsl(o[0])+qsl(o[1]);}\nfloat ol  (mat2x4 o){return sqrt(osl(o));}\nfloat osil(mat2x4 o){return qsil(o[0])+qsl(o[1]);}\nfloat oil (mat2x4 o){return sqrt(osil(o));}\nfloat oarg(mat2x4 o){return atan(oil(o),o[0].x);}\nmat2x4 oconj(mat2x4 o){o[0].x=-o[0].x;return-o;}\nmat2x4 omul (mat2x4 a,mat2x4 b){return mat2x4(qmul(a[0],b[0])-qmul(qconj(b[1]),a[1]),qmul(b[1],a[1])+qmul(a[1],qconj(b[0])));}\nmat2x4 osqr (mat2x4 o){return mat2x4(qsqr(o[0])-vec4(qsil(o[1]),vec3(0)),qsqr(o[1])+qmul(o[0],qconj(o[1])));}\n//mat2x4 ocube(mat2x4 o)\nmat2x4 oinv (mat2x4 o){return oconj(o)/osl(o);}\nmat2x4 odiv (mat2x4 a,mat2x4 b){return omul(a,oinv(b));}\nmat2x4 oexp (mat2x4 o){float l=oil(o);vec2 z=sin(l+pi.xy)*exp(o[0].x);o*=z.x/l;o[0].x=z.y;return o;}\nmat2x4 olog (float x){return mat2x4(log(abs(x)),step(0.0,x),vec2(0),vec4(0));}\nmat2x4 opow (float a,mat2x4 o){float l=oil(o);vec2 z=sin(l+pi.xy)*pow(a,o[0].x);o*=z.x/l;o[0].x=z.y;return o;}\nmat2x4 opow (mat2x4 o,float n){vec2 z=pow(osl(o),n*0.5)*sin(oarg(o)*n+pi.xy);return mat2x4(z.yxxx,z.xxxx);}\nmat2x4 opow (mat2x4 a,mat2x4 b){return omul(opow(osl(a),0.5*b),oexp(oarg(a)*b));}\n\n// (1,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w)\nmat4x4 sreal(float a){return mat4x4(a,vec3(0),vec4(0),vec4(0),vec4(0));}\nfloat ssl (mat4x4 s){return qsl(s[0])+qsl(s[1])+qsl(s[2])+qsl(s[3]);}\nfloat sl  (mat4x4 s){return sqrt(ssl(s));}\nfloat ssil(mat4x4 s){return qsil(s[0])+qsl(s[1])+qsl(s[2])+qsl(s[3]);}\nfloat sil (mat4x4 s){return sqrt(ssil(s));}\nfloat sarg(mat4x4 s){return atan(sil(s),s[0].x);}\nmat4x4 sconj(mat4x4 s){s[0].x=-s[0].x;return-s;}\nmat4x4 smul (mat4x4 a,mat4x4 b){mat2x4 c=omul(mat2x4(a[0],a[1]),mat2x4(b[0],b[1]))-omul(oconj(mat2x4(b[2],b[3])),mat2x4(a[2],a[3]));mat2x4 d=omul(mat2x4(b[2],b[3]),mat2x4(a[2],a[3]))+omul(mat2x4(a[2],a[3]),oconj(mat2x4(b[0],b[1])));return mat4x4(c[0],d[1],c[0],d[1]);}\nmat4x4 ssqr (mat4x4 s){mat2x4 a=osqr(mat2x4(s[0],s[1]))-mat2x4(osil(mat2x4(s[2],s[3])),vec3(0),vec4(0));mat2x4 b=osqr(mat2x4(s[2],s[3]))+omul(mat2x4(s[0],s[1]),oconj(mat2x4(s[2],s[3])));return mat4x4(a[0],a[1],b[0],b[1]);}\n//mat4x4 scube(mat4x4 s)\nmat4x4 sinv (mat4x4 s){return sconj(s)/ssl(s);}\nmat4x4 sdiv (mat4x4 a,mat4x4 b){return smul(a,sinv(b));}\nmat4x4 sexp (mat4x4 s){float l=sil(s);vec2 z=sin(l+pi.xy)*exp(s[0].x);s*=z.x/l;s[0].x=z.y;return s;}\nmat4x4 slog (float x){return mat4x4(log(abs(x)),step(0.0,x),vec2(0),vec4(0),vec4(0),vec4(0));}\nmat4x4 spow (float a,mat4x4 s){float l=sil(s);vec2 z=sin(l+pi.xy)*pow(a,s[0].x);s*=z.x/l;s[0].x=z.y;return s;}\nmat4x4 spow (mat4x4 s,float n){vec2 z=pow(ssl(s),n*0.5)*sin(sarg(s)*n+pi.xy);return mat4x4(z.yxxx,z.xxxx,z.xxxx,z.xxxx);}\nmat4x4 spow (mat4x4 a,mat4x4 b){return smul(spow(ssl(a),0.5*b),sexp(sarg(a)*b));}\n\nvec3 hsv2rgb(vec3 c){return (2.0-c.y-sin(c.x-pi.xzw/3.0)*c.y)*c.z*0.5;}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//store offset of 3-plane\n\n#define QWERTY\n\n#if defined(QWERTY)\n#define KEY_W texture(iChannel1,vec2(87.5/256.0,0.25)).x\n#define KEY_A texture(iChannel1,vec2(65.5/256.0,0.25)).x\n#define KEY_S texture(iChannel1,vec2(83.5/256.0,0.25)).x\n#define KEY_D texture(iChannel1,vec2(68.5/256.0,0.25)).x\n#define KEYLF texture(iChannel1,vec2(37.5/256.0,0.25)).x\n#define KEYUP texture(iChannel1,vec2(38.5/256.0,0.25)).x\n#define KEYRT texture(iChannel1,vec2(39.5/256.0,0.25)).x\n#define KEYDN texture(iChannel1,vec2(40.5/256.0,0.25)).x\n#else\n#define KEYLF texture(iChannel1,vec2(65.5/256.0,0.25)).x\n#define KEYUP texture(iChannel1,vec2(87.5/256.0,0.25)).x\n#define KEYRT texture(iChannel1,vec2(68.5/256.0,0.25)).x\n#define KEYDN texture(iChannel1,vec2(83.5/256.0,0.25)).x\n#define KEY_W texture(iChannel1,vec2(38.5/256.0,0.25)).x\n#define KEY_A texture(iChannel1,vec2(37.5/256.0,0.25)).x\n#define KEY_S texture(iChannel1,vec2(40.5/256.0,0.25)).x\n#define KEY_D texture(iChannel1,vec2(39.5/256.0,0.25)).x\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame < 10) fragColor = vec4(1.0, 0.8, -0.6, 1);\n    else {\n        vec2 uv = fragCoord/iResolution.xy;\n        fragColor = texture(iChannel0, uv);\n        fragColor.rgb += 0.02*vec3(KEY_D, KEYUP, KEYRT);\n        fragColor.rgb -= 0.02*vec3(KEY_A, KEYDN, KEYLF);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}