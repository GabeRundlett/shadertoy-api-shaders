{
    "Shader": {
        "info": {
            "date": "1485115206",
            "description": "Very much based on \"Pilot Waves\" by \"kaswan\". Works by far the best in fullscreen.",
            "flags": 48,
            "hasliked": 0,
            "id": "llVSzK",
            "likes": 6,
            "name": "Pilot Sand",
            "published": 3,
            "tags": [
                "dynamics"
            ],
            "usePreview": 0,
            "username": "alan2here",
            "viewed": 723
        },
        "renderpass": [
            {
                "code": "// Pilot Waves by kaswan\n// I made this game for Global Game Jam @Busan 2017\n//\n// Based on rory618's 2D wave sandbox https://www.shadertoy.com/view/MtdSR4\n// and used sprite encoding code in 4rknova's Sprite Encoding Tutorial https://www.shadertoy.com/view/XtlGzN\n\nconst vec2 txSourcePos  = vec2(31.0,1.0);\nconst vec2 txSourceState \t= vec2(31.0,3.0);\nconst vec2 txShowWall     = vec2(31.0,5.0);\nconst vec2 txAmplitude  = vec2(31.0,3.0);\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nfloat isInside( vec2 p, vec4 c ) { vec2 d = abs(p-0.5-c.xy-c.zw*0.5) - 0.5*c.zw - 0.5; return -max(d.x,d.y); }\n\nvec4 loadValue( in vec2 re )\n{\n    return texture( iChannel2, (0.5+re) / iChannelResolution[2].xy, -100.0 );\n}\n\nvoid storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\nvoid storeValue( in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 sourcePos = loadValue(txSourcePos);    \n    vec4 showWall = loadValue(txShowWall);    \n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 t = texture(iChannel0, uv);\n\t\n    if (showWall.x > 0.5 || iTime < 2.0){\n    \tfragColor = texture(iChannel3, t.yx * vec2(.04,.004)) + texture(iChannel1, uv);\n    }\n    else {\n\t\tfragColor = texture(iChannel3, t.yx * vec2(.04,.004));// + texture(iChannel1, uv);\n    }\n    \n    if (length(fragCoord - sourcePos.xy) < 5.0) {\n    \tfragColor = vec4(0.2, 0.5, 1.0, 1.0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const vec2 txSourcePos = vec2(31.0,1.0);\nconst vec2 txSourceState = vec2(31.0,3.0);\nconst vec2 txShowWall = vec2(31.0,5.0);\nconst vec2 txAmplitude = vec2(31.0,7.0);\n\nfloat isInside(vec2 p, vec2 c) {vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y);}\nfloat isInside(vec2 p, vec4 c) {vec2 d = abs(p-0.5-c.xy-c.zw*0.5) - 0.5*c.zw - 0.5; return -max(d.x,d.y); }\n\nvec4 loadValue(in vec2 re)\n{\n    return texture( iChannel2, (0.5+re) / iChannelResolution[2].xy, -100.0 );\n}\n\nvoid storeValue(in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\nvoid storeValue(in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = (isInside(fragCoord,re) > 0.0) ? va : fragColor;\n}\n\nbool checkWall(in vec2 re)\n{\n    bool value = false;\n    \n    if (texture( iChannel1, (0.5+re) / iChannelResolution[1].xy ).x > 0.5) value = true;\n    \n    return value;\n}\n\n////////////////////////////////////////////////////////////\nconst float KEY_SPACE = 32.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\n\nconst float KEY_M  = 77.5/256.0;\nconst float KEY_R  = 82.5/256.0;\nconst float KEY_S  = 83.5/256.0;\n\nbool keyIsDown( float key ) {\n    return texture( iChannel3, vec2(key,0.25) ).x > .5;\n}\n\n//vec4 sourcePos = vec4(iResolution.xy/2.0,0,0);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec4 sourcePos = loadValue(txSourcePos);    \n    vec4 sourceState = loadValue(txSourceState);    \n    vec4 showWall = loadValue(txShowWall);    \n    vec4 amplitude = loadValue(txAmplitude);  \n    \n    fragColor = vec4(0.0,0.0,1.0,1.0);\n\n    float speed = 2.0;\n    if ( keyIsDown(KEY_LEFT)) {\n        sourcePos.x -= speed;\n        if (checkWall(sourcePos.xy)) sourcePos.x += speed;\n    }\n    if ( keyIsDown(KEY_RIGHT)) {\n        sourcePos.x += speed;\n        if (checkWall(sourcePos.xy)) sourcePos.x -= speed;\n    }\n    if ( keyIsDown(KEY_UP)) {\n        sourcePos.y += speed;\n        if (checkWall(sourcePos.xy)) sourcePos.y -= speed;\n    }\n    if ( keyIsDown(KEY_DOWN)) {\n        sourcePos.y -= speed;\n        if (checkWall(sourcePos.xy)) sourcePos.y += speed;\n    }\n\n    sourceState.x = 20.0;\n    amplitude.x = 1.0;\n    \n    if (iFrame < 1) sourcePos.xy = iResolution.xy / 2.0;\n    \n    storeValue(txSourcePos, vec4(sourcePos), fragColor, fragCoord);\n    storeValue(txAmplitude, vec4(amplitude), fragColor, fragCoord);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define DISPLAY_GRID 0\n#define BACKGROUND   vec3(.0)\n\n#define _ 0. // Color Palette Index 0\n#define B 1. // Color Palette Index 1\n#define D 2. // Color Palette Index 2\n#define O 3. // Color Palette Index 3\n#define Q(i,a,b,c,d,e,f,g,h) if(y==i)m=(a+4.*(b+4.*(c+4.*(d+4.*(e+4.*(f+4.*(g+h*4.)))))));\n\nvec2 grid(vec2 p, vec2 sz)\n{\n    return floor(p * sz);\n}\n\n// Sprite\nvec3 MazeLeft(vec2 p, vec2 scale)\n{\n    vec3 res = BACKGROUND;\n\n    vec2 gv = grid(p, scale); // The grid guide\n    \n    if (gv.x >= 0. && gv.y >= 0. &&\n        gv.x <= 15. && gv.y <= 15.) {\n        \n        #if (DISPLAY_GRID == 1)\n        \tres = vec3(mod(gv.x + gv.y, 2.) * .05 + BACKGROUND);\n        #endif\n        \n        // Indexing is upside down.\n        int y = int(scale.y - gv.y - 5.);\n\n    \tfloat m = 0.;\n\t\tQ(4, B,B,B,B,B,B,B,B)\n\t\tQ(5, B,_,B,_,_,_,_,B)\n\t\tQ(6, B,_,B,_,_,_,_,B)\n\t\tQ(7, B,_,B,_,_,_,B,B)\n\t\tQ(8, B,_,B,_,_,_,B,_)\n\t\tQ(9, B,_,B,B,B,_,B,B)\n\t\tQ(10,B,_,B,_,_,_,_,B)\n\t\tQ(11,B,_,B,_,B,_,_,B)\n\t\tQ(12,_,_,_,_,B,_,_,_)\n        Q(13,B,B,B,B,B,B,B,B)\n        \n    \tfloat ldx = 15. - gv.x; // Calculate the left  bit index\n        float rdx = gv.x;       // Calculate the right bit index\n        float bit = 0.;\n        \n        //if (gv.x >= 8.)\tbit = mod(m / pow(4., ldx), 4.); // Decode\n        //else            bit = mod(m / pow(4., rdx), 4.); // Mirror\n        bit = mod(m / pow(4., rdx), 4.); // Decode\n    \tbit = floor(bit); // Sharpen    \n    \t\n        // Colorize\n        if (bit > 2.) res = vec3(.6471,.6471,.6471);\n        else if (bit > 1.) res = vec3(1.,0.8941176471,0.6745098039);\n        else if (bit > 0.) res = vec3(0.8549019608,0.4980392157, 0.1568627451);\n    }\n    \n    return res;\n}\n\n#define _lineSegment(a, b, c, d) lineSegment(fragColor, fragCoord, a, b, c, d);\n\nvoid lineSegment(inout vec4 fragColor, vec2 z, vec2 a, vec2 b, vec4 c,  float w){\n    float d = dot(z-mix(a, b, 0.5), b-a);\n    \n    if(abs(d) < dot(a-b, a-b)/2.0){\n    \td = length(cross( normalize(vec3(a-b, 0.0)), vec3(z-b, 0.0)));\n    } else {\n        d = min(length(z-b), length(z-a));\n    }\n    fragColor.xyz = mix(fragColor.xyz, c.xyz, c.w * clamp(w-d, 0.0, 1.0));\n}\n\nconst float KEY_SPACE = 32.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\n\nconst float KEY_W  = 87.5/256.0;\nconst float KEY_E  = 69.5/256.0;\n\nbool keyIsDown( float key ) {\n    return texture( iChannel3, vec2(key, 0.25) ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n    \n\tfragColor = texture(iChannel1, uv);\n    vec4 mo = texture(iChannel1, vec2(0));\n    if(iMouse.w > 0.0 && mo.w > 0.0 && length(mo.xy-iMouse.xy) > 3.0){\n    \tif ( keyIsDown(KEY_E)) {\n        \t_lineSegment(iMouse.xy, mo.xy, vec4(0,0,0,1), 5.0);\n        } else {\n        \t_lineSegment(iMouse.xy, mo.xy, vec4(1), 2.0);\n        }\n    }\n    \n    vec3 res = MazeLeft(uv - vec2(.52, .12), vec2(20.9));\n    //res += MazeRight(uv - vec2(.52, .12), vec2(20.9));\n    \n    \n    fragColor = vec4(res, 1.0);\n    \n    if ( keyIsDown(KEY_W)) {\n        fragColor *= 0.;\n    }\n    \n    if (length(fragCoord) < 1.0){\n        if(length(mo.xy - iMouse.xy) > 3.0){\n        \tfragColor = iMouse;\n        } else {\n            fragColor = vec4(mo.xy, iMouse.zw);\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const vec2 txSourcePos = vec2(31.0, 1.0);\nconst vec2 txSourceState = vec2(31.0, 3.0);\nconst vec2 txShowWall = vec2(31.0, 5.0);\nconst vec2 txAmplitude = vec2(31.0, 7.0);\n\nfloat isInside(vec2 p, vec2 c) {vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y);}\nfloat isInside(vec2 p, vec4 c) {vec2 d = abs(p-0.5-c.xy-c.zw*0.5) - 0.5*c.zw - 0.5; return -max(d.x,d.y);}\n\nvec4 loadValue(in vec2 re)\n{\n    return texture(iChannel2, (0.5+re) / iChannelResolution[2].xy, -100.0);\n}\n\nvoid storeValue(in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\nvoid storeValue(in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\n////////////////////////////////////////////////////////////\nconst float KEY_SPACE = 32.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\n\nconst float KEY_W  = 87.5/256.0;\nconst float KEY_R  = 82.5/256.0;\n\nbool keyIsDown( float key ) {\n    return texture( iChannel3, vec2(key,0.25) ).x > .5;\n}\n////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec4 sourcePos = loadValue(txSourcePos);    \n    vec4 sourceState = loadValue(txSourceState);    \n    vec4 amplitude = loadValue(txAmplitude);    \n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 l = texture(iChannel0, (fragCoord-vec2(1.,0))/iResolution.xy).xy;\n    vec2 r = texture(iChannel0, (fragCoord+vec2(1.,0))/iResolution.xy).xy;\n    vec2 u = texture(iChannel0, (fragCoord-vec2(0,1.))/iResolution.xy).xy;\n    vec2 d = texture(iChannel0, (fragCoord+vec2(0,1.))/iResolution.xy).xy;\n    \n    vec2 t = texture(iChannel0, uv).xy;\n        \n    t = mix(t,(l+r+u+d)/4.0, 0.01);\n        \n\tfloat DL = l.x-t.x;\n\tfloat DR = r.x-t.x;\n\tfloat DU = u.x-t.x;\n\tfloat DD = d.x-t.x; \n    t.y += (DL+DR+DU+DD)/4.0;\n    t.x += t.y;\n    \n    t = mix(t, vec2(1.0, 1.0), 0.5*exp(-0.2*length(fragCoord-sourcePos.xy)));\n    \n    if(fragCoord.x<1.0 || fragCoord.y<1.0 || fragCoord.x>iResolution.x-1.0 || fragCoord.y>iResolution.y-1.){\n        t *= 0.0;\n    }\n    \n    // wave decay\n    if (t.x <= 0.5) t.x = 0.2;\n    t.y *= 0.999;\n    \n    // Reset wave fields\n    if (keyIsDown(KEY_R)) {t *= 0.0;}\n    \n    // maze wall\n    t *= 1.0 - texture(iChannel1, uv).x;\n    \n    fragColor = vec4(t.x, t.y, 0,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}