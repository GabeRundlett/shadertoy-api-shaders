{
    "Shader": {
        "info": {
            "date": "1693934426",
            "description": "A GLSL port of a C path tracer I wrote a while back\nNew and \"improved\" version: https://www.shadertoy.com/view/mtSBDw",
            "flags": 48,
            "hasliked": 0,
            "id": "DlSfDz",
            "likes": 8,
            "name": "Path Tracing v1",
            "published": 3,
            "tags": [
                "raytracer",
                "sphere",
                "pathtracer"
            ],
            "usePreview": 0,
            "username": "FrederickAmpsUp",
            "viewed": 303
        },
        "renderpass": [
            {
                "code": "//#define RETRO\n\nvec3 nonlocalDenoise(vec2 fragTexCoord, sampler2D img, float sigma, int patchSize) {\n    vec2 texelSize = 1.0 / vec2(textureSize(img, 0));\n\n    vec3 centralColor = texture(img, fragTexCoord).rgb;\n    vec3 denoisedColor = vec3(0.0);\n\n    float totalWeight = 0.0;\n\n    for (int i = -patchSize; i <= patchSize; i++) {\n        for (int j = -patchSize; j <= patchSize; j++) {\n            vec2 offset = vec2(float(i), float(j)) * texelSize;\n            vec3 neighborColor = texture(img, fragTexCoord + offset).rgb;\n\n            // Compute the similarity between centralColor and neighborColor\n            float similarity = exp(-dot(centralColor - neighborColor, centralColor - neighborColor) / (2.0 * sigma * sigma));\n\n            denoisedColor += similarity * neighborColor;\n            totalWeight += similarity;\n        }\n    }\n\n    denoisedColor /= totalWeight;\n\n    return denoisedColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = round(fragCoord/iResolution.xy * 100.0) / 100.0;\n#ifndef RETRO\n    uv = fragCoord/iResolution.xy;\n#endif\n    vec4 texColor;\n    if (texture(iChannel2, vec2(32.0 / float(textureSize(iChannel2, 0).x), 0.0)).x == 0.0) {\n        texColor = vec4(nonlocalDenoise(uv, iChannel0, 0.1, 10), 1.0);\n    } else {\n        texColor = texture(iChannel0, uv);\n    }\n    \n    fragColor = texColor;\n    fragColor = vec4(flim(fragColor.rgb, 0.), 1.0);\n#ifdef RETRO\n    fragColor.r = round(fragColor.r * 8.0) / 8.0;\n    fragColor.g = round(fragColor.g * 8.0) / 8.0;\n    fragColor.b = round(fragColor.b * 4.0) / 4.0;\n#endif\n\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "struct Material {\n    vec3 color;\n    vec3 emission;\n    \n    float diffuse;\n};\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n    \n    Material mat;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\nstruct RayHit {\n    bool hit;\n\n    vec3 position;\n    vec3 normal;\n\n    Sphere object;\n};\n\n#define RAY_MISS RayHit (false, vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), Sphere(vec3(0.0), 0.0, Material(vec3(0.0),vec3(0.0),0.0)))\n#define MAX_BOUNCES 5\n\n#define DOF_BLUR 0.1\n\n#define DOF_DEPTH 1.0\n#define SCENE_SIZE  9\n\nSphere SCENE[SCENE_SIZE] = Sphere[SCENE_SIZE](\n    Sphere(vec3(0.5, -0.2, 1.0), 0.3, Material(vec3(1.0, 1.0, 1.0), vec3(0.0), 1.0)),\n    Sphere(vec3(-0.5, -0.2, 1.2), 0.3, Material(vec3(0.8, 0.8, 0.8), vec3(0.0), 0.0)),\n    Sphere(vec3(0.3, -0.2, 1.3), 0.3, Material(vec3(0.0, 0.0, 0.0), vec3(5.0, 5.0, 5.0), 0.5)),\n    Sphere(vec3(0.0, -9999.5, 0.0), 9999.0, Material(vec3(1.0, 1.0, 1.0), vec3(0.0), 1.0)),\n    Sphere(vec3(10000.0, 0.0, 0.0), 9999.0, Material(vec3(0.0, 0.0, 1.0), vec3(0.0), 0.5)),\n    Sphere(vec3(-10000.0, 0.0, 0.0), 9999.0, Material(vec3(0.0, 1.0, 0.0), vec3(0.0), 0.9)),\n    Sphere(vec3(0.0, 0.0, 10000.5), 9999.0, Material(vec3(1.0, 0.0, 0.0), vec3(0.0), 0.5)),\n    Sphere(vec3(0.0, 0.0, -10000.5), 9999.0, Material(vec3(1.0, 1.0, 1.0), vec3(0.0), 1.0)),\n    Sphere(vec3(0.0, 10000.0, 0.0), 9999.0, Material(vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 0.0), 1.0))\n);\n\n#define ANTIALIAS_BLUR 0.002\n\nfloat state = 0.0;\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453) * 2.0 - 1.0; }\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nfloat rand(vec3 co){ return rand(co.xy+rand(co.z)); }\n\n#define EYE vec3(0.0, 0.0, 0.2)\n\n\nRay camera_ray(vec2 uv, vec3 cam_dir) {\n    vec3 eye = vec3(EYE.x + rand(uv * float(++state)) * DOF_BLUR, EYE.y + rand(uv * float(++state)) * DOF_BLUR, EYE.z);\n    \n    vec3 screen_plane = vec3(uv + ANTIALIAS_BLUR * vec2(rand(uv * float(++state)),rand(uv * float(++state))), 1.0) + EYE;\n    vec3 focus_plane = screen_plane * DOF_DEPTH;\n    Ray ret = Ray( eye, normalize(focus_plane - eye) );\n    return ret;\n}\n\n\n/*\n\n * Generates a camera ray.\n * UV is normalized in the range [-1, 1].\n * Euler is the camera direction in radian euler angles.\n\n */\n/*\nvec3 project(vec2 uv, vec3 axis, vec3 angle) {\n    vec2 screen_center_xz = vec2(cos(angle.y), sin(angle.y));\n    float screen_center_dist_y_axis = cos(angle.x) + cos(angle.z);\n    screen_center_xz *= screen_center_dist_y_axis;\n\n    vec3 screen_center = normalize(vec3(screen_center_xz.x, sin(angle.x) + sin(angle.z), screen_center_xz.y));\n    return screen_center + vec3(uv, 0.0);\n}\n\nRay camera_ray(vec2 uv, vec3 euler) {\n    vec2 antialias_offset = vec2(rand(uv * float(++state)), rand(uv * float(++state))) * ANTIALIAS_BLUR;\n    uv += antialias_offset;\n    \n    vec3 eye = EYE;\n    \n    vec3 screen_pos = project(uv, eye, euler);\n    \n    Ray ret;\n    ret.origin = eye;\n    ret.direction = normalize(screen_pos - eye);\n    \n    return ret;\n}\n*/\nfloat intersect_sphere(Sphere obj, Ray r) {\n    vec3 oc = r.origin - obj.center;\n    if (length(oc) < obj.radius) return -1.0;\n    float a = dot(r.direction, r.direction);\n    float half_b = dot(oc, r.direction);\n    float c = dot(oc, oc) - obj.radius*obj.radius;\n    float discriminant = half_b*half_b - a*c;\n\n    if (discriminant < 0.0) {\n        return -1.0;\n    } else {\n        return (-half_b - sqrt(discriminant)) / a;\n    }\n}\n\nRayHit scene_intersect(Ray ray) {\n    float min_dist = float(1.0e38);\n\n    Sphere obj;\n    Sphere closest;\n    float dist;\n    for (uint i = uint(0); i < uint(SCENE_SIZE); ++i) {\n        obj = SCENE[i];\n        dist = intersect_sphere(obj, ray);\n\n        if (dist > 0.0 && dist < min_dist) {\n            min_dist = dist;\n            closest = obj;\n        }\n    }\n    if (min_dist == float(1.0e38)) return RAY_MISS;\n\n    vec3 position =  ray.origin + ray.direction * min_dist;\n    RayHit ret = RayHit( true, position, normalize(position - closest.center), closest );\n\n    return ret;\n}\n\nvec3 v_lerp(vec3 v1, vec3 v2, float t) {\n    return (v2 - v1) * t + v1;\n}\n\nvec3 rand_hemis_dir(vec3 dir) {\n    vec3 rand_dir = normalize(vec3(rand(dir * float(++state)), rand(dir * float(++state)), rand(dir * float(++state))));\n    return rand_dir * (sign(dot(dir, rand_dir)) * 2.0 - 1.0);\n}\n\nvoid init_state(float time) {\n    state = time;\n}\n\nfloat clip(float x, float a, float b) {\n    if (x < a) return a;\n    if (x > b) return b;\n               return x;\n}\n\n#define SUN vec3(1.0, 0.7, 1.0)\n\nvec3 sky_color(vec3 direction) {\n    vec3 sky_blue = vec3(0.380, 0.769, 0.961);\n\n    float sun = pow(clamp(dot(direction, normalize(SUN)), 0.0, 1.0), 500.0) * 100.0;\n    vec3 sunCol = vec3(sun, sun * 0.9, 0.0);\n\n    vec3 ret = sky_blue + sunCol;\n\n    return ret;\n}\n\n\nvec3 ray_shader(Ray ray, uint x, uint y) {\n    vec3 color = vec3(1.0);\n    vec3 light = vec3(0.0);\n\n    for (int bounce = 0; bounce < MAX_BOUNCES; ++bounce) {\n        RayHit intersect = scene_intersect(ray);\n        if (!intersect.hit) {\n            vec3 sky = sky_color(ray.direction);\n            light = light + sky * color;\n            break;\n        };\n\n        Material mat;\n        mat = intersect.object.mat;\n        \n        light = light + mat.emission * color;\n        color = color * mat.color;\n\n        ray.origin = intersect.position + intersect.normal * 0.001;\n        ray.direction = v_lerp(reflect(ray.direction, intersect.normal), normalize(intersect.normal + normalize(vec3(rand(float(++state)), rand(float(++state)), rand(float(++state))))), mat.diffuse);\n    }\n    return light;\n}\n\n#define flim(x,y) flim_transform(iChannel1,x,y)\n\n/***********************************\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  sRGB 2.2\n\nShadertoy Unit:\n  Common\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n  The common unit contains most of the code, and\n  receives gamut extension matrices from a buffer.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n  Minified by 01000001\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n***********************************/\n\n// Parameters\n\nconst float pe = 4.3; const vec3 fpff = vec3(1); const float fpffs = 0.;\nconst float egr = 1.05; const float egg = 1.12; const float egb = 1.045;\nconst float grr = .5; const float ggr = 2.; const float gbr = .1;\nconst float grm = 1.; const float ggm = 1.; const float gbm = 1.; const float flsi = -10.;\nconst float flsa = 22.; const float fsx = .44; const float fsy = .28;\nconst float fssx = .591; const float fssy = .779; const float fe = 6.;\nconst float fd = 5.; const vec3 pb = vec3(1); const float pfe = 6.;\nconst float pfd = 27.5; const float bp = -1.; const vec3 pff = vec3(1);\nconst float pffs = 0.; const float ms = 1.02;\nfloat wrap(float i, float s, float e){return s + mod(i - s, e - s);}\nfloat lerp(float a, float b, float t){return a + t * (b - a);}\nvec3 lerp(vec3 a, vec3 b, float t){return a + t * (b - a);}\nfloat mrc(float i, float is, float ie, float os, float oe){\n    float t = clamp((i - is) / (ie - is), 0., 1.);\n    float v = os + t * (oe - os);\n    return v; }\nvec3 rth(vec3 rgb){\n    float ca, ci, h, s, v, cd;\n    vec3 c;\n    ca = max(rgb[0], max(rgb[1], rgb[2]));\n    ci = min(rgb[0], min(rgb[1], rgb[2]));\n    cd = ca - ci;\n    v = ca;\n    if (ca != 0.) s = cd / ca;\n    else s = 0.0; h = 0.0;\n    if (s == 0.) h = 0.0; \n    else{\n        c = (vec3(ca) - rgb.xyz) / cd;\n\n        if (rgb.x == ca) h = c[2] - c[1];\n        else if (rgb.y == ca) h = 2.+ c[0] - c[2];\n        else h = 4.+ c[1] - c[0];\n        h /= 6.0;\n        if (h < 0.) h += 1.0; }\n    return vec3(h, s, v); }\nvec3 htr(vec3 hsv){\n    float i, f, p, q, t, h, s, v;\n    vec3 rgb;\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n    if (s == 0.) rgb = vec3(v, v, v);\n    else {\n        if (h == 1.) h = 0.0;\n        h *= 6.0;\n        i = floor(h);\n        f = h - i;\n        rgb = vec3(f, f, f);\n        p = v * (1.- s);\n        q = v * (1.- (s * f));\n        t = v * (1.- (s * (1.- f)));\n        if (i == 0.) rgb = vec3(v, t, p);\n        else if (i == 1.) rgb = vec3(q, v, p);\n        else if (i == 2.) rgb = vec3(p, v, t);\n        else if (i == 3.) rgb = vec3(p, q, v);\n        else if (i == 4.) rgb = vec3(t, p, v);\n        else rgb = vec3(v, p, q); }\n    return rgb; }\nvec3 bhs(vec3 col, float hue, float sat, float value){\n    vec3 hsv = rth(col);\n    hsv[0] = fract(hsv[0] + hue + 0.5);\n    hsv[1] = clamp(hsv[1] * sat, 0., 1.);\n    hsv[2] = hsv[2] * value;\n    return htr(hsv); }\nfloat rgb_avg(vec3 i){\n    return (i.x + i.y + i.z) / 3.0; }\nfloat rgb_sum(vec3 i){\n    return i.x + i.y + i.z; }\nfloat rgb_max(vec3 i){\n    return max(max(i.x, i.y), i.z); }\nfloat rgb_min(vec3 i){\n    return min(min(i.x, i.y), i.z); }\nvec3 uo(vec3 i, float bp, float wp){\n    float mono = rgb_avg(i);\n    float mono2 = mrc(mono, bp / 1000., 1.- (wp / 1000.), 0., 1.);\n    return i * (mono2 / mono); }\n// https://www.desmos.com/calculator/khkztixyeu\nfloat ss(float i, float tx, float ty, float sx, float sy){\n    i = clamp(i, 0., 1.);\n    tx = clamp(tx, 0., 1.);\n    ty = clamp(ty, 0., 1.);\n    sx = clamp(sx, 0., 1.);\n    sy = clamp(sy, 0., 1.);\n    float slope = (sy - ty) / (sx - tx);\n    if (i < tx){\n        float toe_pow = slope * tx / ty;\n        return ty * pow(i / tx, toe_pow); }\n    if (i < sx){\n        float intercept = ty - (slope * tx);\n        return slope * i + intercept; }\n    float shoulder_pow = -slope / (((sx - 1.) / pow(1.- sx, 2.)) * (1.- sy));\n    return (1.- pow(1.- (i - sx) / (1.- sx), shoulder_pow)) * (1.- sy) + sy; }\nfloat dmf(float mono, float max_density){\n    float offset = pow(2., flsi);\n    float fac = mrc(log2(mono + offset), flsi, flsa, 0., 1.);\n    fac = ss(fac, fsx, fsy, fssx, fssy);\n    fac *= max_density;\n    fac = pow(2., -fac);\n    return clamp(fac, 0., 1.); }\nvec3 cl(vec3 i, vec3 sensitivity_tone, vec3 dye_tone, float max_density){\n    vec3 sensitivity_tone_norm = sensitivity_tone / rgb_sum(sensitivity_tone);\n    vec3 dye_tone_norm = dye_tone / rgb_max(dye_tone);\n    float mono = dot(i, sensitivity_tone_norm);\n    float mixFac = dmf(mono, max_density);\n    return lerp(dye_tone_norm, vec3(1.), mixFac); }\nvec3 rgbd(vec3 i, float e, float max_density){\n    i *= pow(2., e);\n    vec3 result = cl(i, vec3(0, 0, 1), vec3(1, 1, 0), max_density);\n    result *= cl(i, vec3(0, 1, 0), vec3(1, 0, 1), max_density);\n    result *= cl(i, vec3(1, 0, 0), vec3(0, 1, 1), max_density);\n    return result; }\nvec3 emr(float ph, float s, float r, float m){\n    vec3 result = htr(vec3(wrap(ph + (r / 360.), 0., 1.), 1./ s, 1.));\n    result /= rgb_sum(result);\n    result *= m;\n    return result; }\nmat3 gem(float rs,float gs,float bs,float rr,float gr, float br, float rm, float gm, float bm){\n    mat3 m;\n    m[0] = emr(0., rs, rr, rm);\n    m[1] = emr(1./ 3., gs, gr, gm);\n    m[2] = emr(2./ 3., bs, br, bm);\n    return m; }\nvec3 nap(vec3 i, vec3 bex){\n    i = rgbd(i, fe, fd);\n    i *= bex;\n    i = rgbd(i, pfe, pfd);\n    return i; }\nbool flm(sampler2D mc, out mat3 em, out mat3 emi){\n    const float valid_w = 2.0;\n    vec4 row;\n    row = texelFetch(mc, ivec2(0, 0), 0);\n    if (row.w != valid_w)\n        return false;\n    em[0] = row.xyz;\n\n    row = texelFetch(mc, ivec2(1, 0), 0);\n    if (row.w != valid_w)\n        return false;\n    em[1] = row.xyz;\n\n    row = texelFetch(mc, ivec2(2, 0), 0);\n    if (row.w != valid_w)\n        return false;\n    em[2] = row.xyz;\n    row = texelFetch(mc, ivec2(3, 0), 0);\n    if (row.w != valid_w)\n        return false;\n    emi[0] = row.xyz;\n\n    row = texelFetch(mc, ivec2(4, 0), 0);\n    if (row.w != valid_w)\n        return false;\n    emi[1] = row.xyz;\n\n    row = texelFetch(mc, ivec2(5, 0), 0);\n    if (row.w != valid_w)\n        return false;\n    emi[2] = row.xyz;\n    return true; }\nvec3 flim_transform(sampler2D mc, vec3 i, float e){\n    i = max(i, 0.);\n    i *= pow(2., pe + e);\n    i = min(i, 5000.);\n    mat3 em, emi;\n    if (!flm(mc, em, emi)){ return vec3(1, 0, 1); }\n    vec3 bex = pb * em;\n    const float big = 10000000.0;\n    vec3 white_cap = nap(vec3(big, big, big), bex);\n    i = lerp(i, i * fpff, fpffs);\n    i *= em;\n    i = nap(i, bex);\n    i *= emi;\n    i = max(i, 0.);\n    i /= white_cap;\n    if (bp == -1.){\n        vec3 black_cap = nap(vec3(0.), bex);\n        black_cap /= white_cap;\n        i = uo(i, rgb_avg(black_cap) * 1000., 0.);\n    }else{ i = uo(i, bp, 0.); }\n    i = lerp(i, i * pff, pffs);\n    i = clamp(i, 0., 1.);\n    float mono = rgb_avg(i);\n    float mixFac = (mono < 0.5) ? mrc(mono, 0.05, 0.5, 0., 1.) : mrc(mono, 0.5, 0.95, 1., 0.);\n    i = lerp(i, bhs(i, 0.5, ms, 1.), mixFac);\n    i = clamp(i, 0., 1.);\n    i = pow(i, vec3(1./ 2.2));\n    return i; }\n\n/***********************************\n\nEnd of flim's implementation for Shadertoy Unit: Common\n\n***********************************/\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define SAMPLES float(100)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy) * 2.0 - 1.0;\n    \n    init_state(uv.x+2.0*uv.y+iTime);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //Ray cam = camera_ray(uv, normalize(vec3(iMouse.x, iMouse.y, 1.0)));\n    Ray cam = camera_ray(uv, vec3(0.0,3.141,0.0));\n    \n    vec3 col = vec3(0.0);\n    float i = 0.0;\n    while (i++ < SAMPLES)\n        col += ray_shader(cam, uint(fragCoord.x), uint(fragCoord.y));\n    \n    fragColor = mix(texture(iChannel0, (fragCoord/iResolution.xy)), vec4(col / SAMPLES, 1.0), 1.0 / float(iFrame + 1));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/***********************************\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  sRGB 2.2\n\nShadertoy Unit:\n  Buffer X\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n  The buffer unit performs a one-time calculation\n  of flim's gamut extension matrices.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n  Minified by 01000001\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n***********************************/\n\n// NOTE:\n// iChannel0 must be set to this buffer (self-feeding).\n\nvoid mainImage(out vec4 O, in vec2 U){\n    const float w = 2.0;\n    if (ivec2(U).x > 5 || ivec2(U).y > 0)\n        return;\n    vec4 p = texelFetch(iChannel0, ivec2(U), 0);\n    O = p;\n    bool n = (p.w != w) || (iTime == 0.0) || (iFrame < 1);\n    if (!n)\n        return;\n    mat3 e = gem(egr,egg,egb,grr,ggr,gbr,grm,ggm,gbm);\n    mat3 ei = inverse(e);\n    if (ivec2(U) == ivec2(0, 0)) {\n        O = vec4(e[0], w);\n    } if (ivec2(U) == ivec2(1, 0)) {\n        O = vec4(e[1], w);\n    } if (ivec2(U) == ivec2(2, 0)) {\n        O = vec4(e[2], w);\n    }\n    if (ivec2(U) == ivec2(3, 0)) {\n        O = vec4(ei[0], w);\n    } if (ivec2(U) == ivec2(4, 0)) {\n        O = vec4(ei[1], w);\n    } if (ivec2(U) == ivec2(5, 0)) {\n        O = vec4(ei[2], w);\n    }}\n\n/***********************************\n\nEnd of flim's implementation for Shadertoy Unit: Buffer X\n\n***********************************/\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}