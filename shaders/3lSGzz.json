{
    "Shader": {
        "info": {
            "date": "1558208040",
            "description": "ICorinthians15:2-3 By which also ye are saved, if ye keep in memory what I preached unto you, unless ye have believed in vain. For I delivered unto you first of all that which I also received, how that Christ died for our sins according to the scriptures.",
            "flags": 8,
            "hasliked": 0,
            "id": "3lSGzz",
            "likes": 1,
            "name": "Gospel Cross - Aleluya",
            "published": 3,
            "tags": [
                "raymarching",
                "jesus",
                "gospel",
                "bible"
            ],
            "usePreview": 0,
            "username": "loveJesus",
            "viewed": 607
        },
        "renderpass": [
            {
                "code": "// For God so loved the world, that He gave His only begotten Son\n// That all who believe in Him should not perish, but have everlasting life\nint strLen_aleluya = 44;\nint str_aleluya[44]; \n\nint numSpheres_aleluya = 3;\nvec4 spheres_aleluya[4];\nvec4 spheresRGB_aleluya[4];\nint numPlanes_aleluya = 0;\n\nint numLDists_aleluya = 6;\nfloat lDists_aleluya[6];\n\nint numLights_aleluya = 1;\nvec4 lights_aleluya[2];\nvec3 lcol_aleluya[2];\n\nint numCcyl_aleluya = 1;\nvec4 ccyl_aleluya[1];\nvec3 ccylr_aleluya[1];\nvec4 ccylRGB_aleluya[1];\n\nint numCaps_aleluya = 1;\nvec4 caps_aleluya[1];\nvec3 capsa_aleluya[1];\nvec3 capsb_aleluya[1];\nvec4 capsRGB_aleluya[1];\n\nbool setRGB_aleluya = false;\nvec4 curRGB_aleluya;\n\n\n#define maxDist_aleluya  100.0f\n#define cDist_aleluya  0.001f\n\nvoid clearLDists_aleluya() {\n    for(int aleluya = 0; aleluya < numLDists_aleluya; aleluya++) {\n      lDists_aleluya[aleluya] = maxDist_aleluya;   \n    }\n}\nbool noLDists_aleluya() {\n    for(int aleluya = 0; aleluya < numLDists_aleluya; aleluya++) {\n      if(lDists_aleluya[aleluya] >0.0f) return false;   \n    }\n    return true;\n    \n}\n// adapted from http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nvec3 rotation_aleluya(vec3 point, vec3 axis, float angle){\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    mat4 rot= mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,0.0,0.0,1.0);\n    return (rot*vec4(point,1.)).xyz;\n}\n\nfloat dSphere_aleluya(vec3 p_aleluya, vec4 curSphere_aleluya) {\n    float curDist_aleluya = distance(p_aleluya, curSphere_aleluya.xyz) - curSphere_aleluya.w;\n    return curDist_aleluya;\n}\n\nfloat dFloor_aleluya(vec3 p_aleluya) {\n    return p_aleluya.y+2.+(0.02*(cos(p_aleluya.z*35.)+cos(p_aleluya.x*10.)))-( mix(1.1,0.,clamp(distance(p_aleluya, vec3(0,0,-5.)) /19.,0.,1.))*(cos(((p_aleluya.z+5.)/1.)*.6)+cos(p_aleluya.x*0.7)));\n}\n\nfloat dCapsule_aleluya(vec3 np_aleluya, vec3 a_aleluya, vec3 b_aleluya, float r_aleluya) {\n    vec3 pa_aleluya = np_aleluya - a_aleluya, ba_aleluya = b_aleluya - a_aleluya;\n    float h_aleluya = clamp( dot(pa_aleluya,ba_aleluya)/dot(ba_aleluya,ba_aleluya), 0.0, 1.0 );\n    float curDist_aleluya =  length( pa_aleluya - ba_aleluya*h_aleluya ) - r_aleluya;\n    return curDist_aleluya;\n}\n\nfloat dCylinder_aleluya(vec3 np_aleluya, float h_aleluya) {\n    vec2 d_aleluya = abs(vec2(length(np_aleluya.xz),np_aleluya.y*0.12f)) - h_aleluya;\n    float curDist_aleluya = min(max(d_aleluya.x,d_aleluya.y),0.0) + length(max(d_aleluya,0.0));\n    return curDist_aleluya;\n}\n\nfloat newCDist_aleluya(float curDist_aleluya, float minDist_aleluya, int ldP_aleluya, vec4 rgb_aleluya) {\n    if(lDists_aleluya[ldP_aleluya] < 0.0f) return minDist_aleluya;\n    if(curDist_aleluya > lDists_aleluya[ldP_aleluya]) {\n        lDists_aleluya[ldP_aleluya] = -1.0f;\n        return minDist_aleluya;\n    }\n    \n    if(curDist_aleluya < minDist_aleluya) {\n        if (setRGB_aleluya) curRGB_aleluya = rgb_aleluya;\n        return curDist_aleluya;\n    }\n    return minDist_aleluya;\n    \n}\n// Thanks Jesus for Inigo Quilez @ https://iquilezles.org/articles/distfunctions\n\nfloat dist_aleluya( vec3 p_aleluya )\n{\n    int ldP_aleluya = 0;\n    \n    \n    //Floor dist, hallelujah \n    float minDist_aleluya = 100.0f;\n    \n    if(lDists_aleluya[ldP_aleluya] > 0.0f ) {        \n        float curDist_aleluya = dFloor_aleluya(p_aleluya); \n        vec4 rgb_aleluya = mix(vec4(0.2, 0.9, 0.3,1),vec4(1, 0.4, 0.3,1),sin(curDist_aleluya*.5)*0.5f+0.5f);\n        minDist_aleluya = newCDist_aleluya(curDist_aleluya, minDist_aleluya, ldP_aleluya, rgb_aleluya);\n        ldP_aleluya ++;\n    }\n    //Sphere dist, hallelujah\n    for(int aleluya = 0; aleluya < numSpheres_aleluya; aleluya++) {\n        if(lDists_aleluya[ldP_aleluya] > 0.0f ) {\n            vec4 curSphere_aleluya = spheres_aleluya[aleluya];\n            float curDist_aleluya = dSphere_aleluya(p_aleluya, curSphere_aleluya);\n            vec4 rgb_aleluya = spheresRGB_aleluya[aleluya];\n                ;\n            minDist_aleluya = newCDist_aleluya(curDist_aleluya, minDist_aleluya, ldP_aleluya, rgb_aleluya );\n        }\n        ldP_aleluya ++;\n    }\n    \n    \n    \n    //Capped cylinder distance, hallelujah\n    //float sdCappedCylinder( vec3 p, vec2 h )\n    for(int aleluya = 0; aleluya < numCcyl_aleluya; aleluya++) \n    {\n        if(lDists_aleluya[ldP_aleluya] > 0.0f ) {\n            vec3 np_aleluya = p_aleluya - ccyl_aleluya[aleluya].xyz;\n            float h_aleluya = ccyl_aleluya[aleluya].w;\n            float curDist_aleluya = dCylinder_aleluya(np_aleluya, h_aleluya);\n            vec4 rgb_aleluya = ccylRGB_aleluya[aleluya];\n            \n            minDist_aleluya = newCDist_aleluya(curDist_aleluya, minDist_aleluya, ldP_aleluya, rgb_aleluya);\n        }\n        ldP_aleluya ++;\n    }\n    \n    //float sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n    for(int aleluya = 0; aleluya < numCaps_aleluya; aleluya++) \n    {\n        if(lDists_aleluya[ldP_aleluya] > 0.0f) {\n            vec3 np_aleluya = p_aleluya - caps_aleluya[aleluya].xyz;\n            float r_aleluya = caps_aleluya[aleluya].w;\n            vec3 a_aleluya  = capsa_aleluya[aleluya];\n            vec3 b_aleluya  = capsb_aleluya[aleluya];            \n            vec4 rgb_aleluya = capsRGB_aleluya[aleluya];\n            \n            float curDist_aleluya =  dCapsule_aleluya( np_aleluya, a_aleluya, b_aleluya, r_aleluya);\n            minDist_aleluya = newCDist_aleluya(curDist_aleluya, minDist_aleluya, ldP_aleluya, rgb_aleluya);\n    \t}\n        ldP_aleluya ++;\n    }\n    \n    \n    return minDist_aleluya;\n}\n\nvec3 normal_aleluya( vec3 pos_aleluya ) {\n    vec2 swzl_aleluya = vec2(0.04f,0);\n    \n\tfloat x_aleluya = dist_aleluya(pos_aleluya + swzl_aleluya.xyy);\n    float y_aleluya = dist_aleluya(pos_aleluya + swzl_aleluya.yxy);\n    float z_aleluya = dist_aleluya(pos_aleluya + swzl_aleluya.yyx);\n    \n    return normalize(vec3(x_aleluya, y_aleluya, z_aleluya));\n}\n\n// dist, closest, numsteps - hallelujah\n#define max_steps_aleluya 180\nvec3 rayMarch_aleluya( vec3 pos_aleluya, vec3 d_aleluya, float dc_aleluya ) \n{\n    float ldist_aleluya=10000.0f;\n    float closest_aleluya = maxDist_aleluya;\n    int count_aleluya;\n    clearLDists_aleluya();\n    \n    for( count_aleluya = 0 ; count_aleluya < max_steps_aleluya; count_aleluya ++) {\n        float curDist_aleluya =  dist_aleluya(pos_aleluya);\n        if(curDist_aleluya < closest_aleluya) closest_aleluya = curDist_aleluya;\n        \n        if( noLDists_aleluya() || curDist_aleluya > maxDist_aleluya) {\n            return vec3(-1.0f,closest_aleluya, float(count_aleluya));\n        } else if(curDist_aleluya < cDist_aleluya) {\n            return vec3(dc_aleluya,closest_aleluya, float(count_aleluya));\n        } else {\n            pos_aleluya += d_aleluya * curDist_aleluya;\n            dc_aleluya += curDist_aleluya;\n        }\n        ldist_aleluya = curDist_aleluya;\n    }\n    return vec3(-1.0f,closest_aleluya, float(count_aleluya));\n}\n\n#define maxDepth_aleluya 2\nvec3 lNormal_aleluya;\nvec3 lPos_aleluya;\n\nvec4 calcCol_aleluya(vec3 pos_aleluya, vec3 d_aleluya) {\n    setRGB_aleluya = true;\n    vec3 rm3_aleluya = rayMarch_aleluya( pos_aleluya, d_aleluya, 0.0f );\n    float curDist_aleluya = rm3_aleluya.x;\n    if(curDist_aleluya < 0.0f) {\n        return vec4(-1.0f);\n    }\n    vec3 fpos_aleluya = pos_aleluya + d_aleluya * curDist_aleluya;  \n    float lDist_aleluya = curDist_aleluya;\n    vec3 n_aleluya = normal_aleluya(fpos_aleluya);\n    vec4 col_aleluya = vec4(0.0f);\n\n    //Do lighting, Hallelujah\n\n    for( int li_aleluya = 0; li_aleluya < numLights_aleluya; li_aleluya++) {\n        setRGB_aleluya = false;\n        vec4 l_aleluya = lights_aleluya[li_aleluya];\n        vec3 lseg_aleluya = l_aleluya.xyz - fpos_aleluya;\n        vec3 ldir_aleluya = normalize(lseg_aleluya);\n        float ldist_aleluya = distance(l_aleluya.xyz, fpos_aleluya);\n        vec3 rmd3_aleluya = rayMarch_aleluya( fpos_aleluya + ldir_aleluya * 0.1f, ldir_aleluya, 0.0f);\n        float rmd_aleluya = rmd3_aleluya.x;\n        \n        //Are we in shadow?\n        if( rmd_aleluya < 0.0f || rmd_aleluya >  ldist_aleluya ) {\n            col_aleluya += vec4(lcol_aleluya[li_aleluya] * \n                ( dot(n_aleluya, ldir_aleluya ) * l_aleluya.w ) * (rmd3_aleluya.y*150./maxDist_aleluya), 1);  \n        } \n\n    }\n    vec4 curCol_aleluya = clamp(col_aleluya * curRGB_aleluya, vec4(0.001), vec4(1.));\n    float mist_aleluya = clamp(lDist_aleluya,0.,80.);\n    lNormal_aleluya = n_aleluya;\n    lPos_aleluya = fpos_aleluya;\n  #if 1\n    vec4 mistMixed_aleluya =  mix( curCol_aleluya*((800.-rm3_aleluya.z)/100.f), vec4(1,.8,.31,1), (mist_aleluya/80.));\n    \n\n    vec3 nPost_aleluya = (pos_aleluya+vec3(25.)) ;\n    float accum_aleluya = 0.;\n    for(float iAleluya = 0.; iAleluya< lDist_aleluya; iAleluya++) {\n        vec3 npos2_aleluya = (nPost_aleluya + d_aleluya * iAleluya) /50.;\n        accum_aleluya += texture(iChannel1, npos2_aleluya).x *.02;\n        \n        \n    }\n    return mix(mistMixed_aleluya, vec4(.4,.4,.9,1), clamp(accum_aleluya,0.,1.));\n  #else\n    vec4 mistMixed_aleluya =  mix( curCol_aleluya*((800.-rm3_aleluya.z)/100.f), vec4(.4,.4,.8,1), (mist_aleluya/80.));\n    \n    return mistMixed_aleluya;\n  #endif\n   \n    \n    \n    \n    \n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;    \n    vec3 d_aleluya = rotation_aleluya( normalize( vec3(  uv - vec2(0.5f, 0.81f), -1.0f) ), vec3(0, 1, 0), iTime*.18f) ;\n    vec3 pos_aleluya = rotation_aleluya( vec3(0,4.4f,7.0f), vec3(0, 1, 0),iTime*.18f) - vec3(0,0,5.0f);\n    \n    //Define world - hallelujah\n    vec3 cvec_aleluya = vec3(0,0,-5);\n    spheres_aleluya[0] = vec4(rotation_aleluya(vec3(3.4f,3,0), vec3(0,1,0), -iTime*.18f) + cvec_aleluya, .9f);\n    spheres_aleluya[1] = vec4(rotation_aleluya(vec3(-1.42,2,-1), vec3(0,1,0), iTime*0.4f) + cvec_aleluya,0.7f);\n    spheres_aleluya[2] = vec4(rotation_aleluya(vec3(2.72,3.41,0), vec3(0,1,0), iTime*0.3f) + cvec_aleluya,0.41f);\n    spheres_aleluya[3] = vec4(rotation_aleluya(vec3(2.42,3.01,0.2), vec3(0,1,0), iTime*0.5f) + cvec_aleluya,0.81f);\n    spheresRGB_aleluya[0] = vec4(0.4f, 0.5f, 0.99f,0.7f);\n    spheresRGB_aleluya[1] = vec4(0.9f, 0.2f, 0.1f,0.5f);\n    spheresRGB_aleluya[2] = vec4(1.0f, 1.0f, 0.1f,0.9f);\n    spheresRGB_aleluya[3] = vec4(1.0f, 0.0f, 0.1f,0.88f);\n    \n    lights_aleluya[1] = vec4(rotation_aleluya(vec3(3.5,    6,  -0.5), vec3(0,1,0), iTime*0.28), 0.7f) - vec4(0,0,5,0);\n    lights_aleluya[0] = vec4(-4.8,7,  -3, 0.91f);\n    //lights_aleluya[2] = vec4(0,   8,  -4, 0.81f);\n    \n    lcol_aleluya[1] = vec3(1,1,0);\n    lcol_aleluya[0] = vec3(1,.971,.99);\n    //lcol_aleluya[2] = vec3(1,0,1);\n    \n    ccyl_aleluya[0] = vec4(0,2.53,-5,0.3f);\n    //ccyl_aleluya[1] = vec4(3,2,-5,0.52f);\n    ccylRGB_aleluya[0] = vec4(0.9f, 0.6f, 0.2f, 1.f);\n    \n    caps_aleluya[0] = vec4(0,0,0,0.3f);\n    capsa_aleluya[0] = vec3(1,3.75,-5);\n    capsb_aleluya[0] = vec3(-1,3.75,-5);\n    capsRGB_aleluya[0] = vec4(0.9f, 0.6f, 0.2f,1.f);\n\n\n    \n    vec4 col_aleluya = calcCol_aleluya(pos_aleluya, d_aleluya);\n   \n    if(col_aleluya.x>=0.0f && curRGB_aleluya.w< 0.99f) {\n    //Calculate reflections, Hallelujah\n        int r_aleluya;\n        int nDepth_aleluya = curRGB_aleluya.w < 0.92 ? maxDepth_aleluya : 1;\n        for(r_aleluya = 0; r_aleluya < maxDepth_aleluya; r_aleluya++ ) {\n            float oRef_aleluya = curRGB_aleluya.w;\n            vec3 rd_aleluya = d_aleluya - (2.0f * dot(lNormal_aleluya, d_aleluya) ) * lNormal_aleluya;\n            vec4 rCol_aleluya = calcCol_aleluya(lPos_aleluya + rd_aleluya*0.02f, rd_aleluya);\n            if(rCol_aleluya.x < 0.0f) {\n                col_aleluya = col_aleluya * oRef_aleluya + vec4(0.3, 0.3, 0.8,0.0f) * (1.0f - oRef_aleluya);\n                break;\n            }\n            \n            col_aleluya = col_aleluya * oRef_aleluya + rCol_aleluya * (1. - oRef_aleluya);\n        }\n    } else if(col_aleluya.x<0.0f){\n        col_aleluya = vec4(0.4, 0.4, 0.9,0.0f);\n    }\n    \n    //Light flares aleluya\n    \n    for(int lf_aleluya = 0; lf_aleluya < numLights_aleluya; lf_aleluya++) {\n        vec4 curLight_aleluya = lights_aleluya[lf_aleluya];\n        vec3 lSeg_aleluya = curLight_aleluya.xyz - pos_aleluya;\n        vec3 lDir_aleluya = normalize(lSeg_aleluya);\n        float lDt_aleluya = dot(lDir_aleluya, d_aleluya);\n        //If light isn't behind us\n        if(lDt_aleluya > 0.81) {\n            float ltDist_aleluya = distance( vec3(0.), lSeg_aleluya );\n            vec3 rml3_aleluya = rayMarch_aleluya( pos_aleluya , lDir_aleluya, 0.0f);\n            if(rml3_aleluya.x < ltDist_aleluya )  {\n                col_aleluya = vec4(mix(col_aleluya.xyz, lcol_aleluya[lf_aleluya], pow(lDt_aleluya,14.)*(1.-rml3_aleluya.y/(maxDist_aleluya*1.9))),1.);\n            }\n        }\n\n        \n    }\n str_aleluya[0]=0x466f7220;\nstr_aleluya[1]=0x476f6420;\nstr_aleluya[2]=0x736f206c;\nstr_aleluya[3]=0x6f766564;\nstr_aleluya[4]=0x20746865;\nstr_aleluya[5]=0x20776f72;\nstr_aleluya[6]=0x6c642c20;\nstr_aleluya[7]=0x74686174;\nstr_aleluya[8]=0x20486520;\nstr_aleluya[9]=0x67617665;\nstr_aleluya[10]=0x20486973;\nstr_aleluya[11]=0x206f6e6c;\nstr_aleluya[12]=0x79206265;\nstr_aleluya[13]=0x676f7474;\nstr_aleluya[14]=0x656e2053;\nstr_aleluya[15]=0x6f6e2c20;\nstr_aleluya[16]=0x74686174;\nstr_aleluya[17]=0x20616c6c;\nstr_aleluya[18]=0x2077686f;\nstr_aleluya[19]=0x2062656c;\nstr_aleluya[20]=0x69657665;\nstr_aleluya[21]=0x20696e20;\nstr_aleluya[22]=0x48696d20;\nstr_aleluya[23]=0x73686f75;\nstr_aleluya[24]=0x6c64206e;\nstr_aleluya[25]=0x6f742070;\nstr_aleluya[26]=0x65726973;\nstr_aleluya[27]=0x682c2062;\nstr_aleluya[28]=0x75742068;\nstr_aleluya[29]=0x61766520;\nstr_aleluya[30]=0x65766572;\nstr_aleluya[31]=0x6c617374;\nstr_aleluya[32]=0x696e6720;\nstr_aleluya[33]=0x6c696665;\nstr_aleluya[34]=0x2e205265;\nstr_aleluya[35]=0x70656e74;\nstr_aleluya[36]=0x20616e64;\nstr_aleluya[37]=0x2042656c;\nstr_aleluya[38]=0x69657665;\nstr_aleluya[39]=0x20696e20;\nstr_aleluya[40]=0x74686520;\nstr_aleluya[41]=0x676f6f64;\nstr_aleluya[42]=0x206e6577;\nstr_aleluya[43]=0x732e2020;\n\n    \n    \n    if( abs(uv.y -0.25f)<0.05f ) {\n        float yd_aleluya = (uv.y - 0.30f )*(10.0f/16.0f);\n    \tfloat cx_aleluya = (uv.x + iTime/4.0f) *(18.0/16.0f);\n        float xd_aleluya = (cx_aleluya*16.0f - floor(cx_aleluya*16.0f)) / 16.0f ;\n        \n        int chrl_aleluya = ( int( cx_aleluya * 16.0f )) % (strLen_aleluya * 4);\n        int chri_aleluya = chrl_aleluya >> 2;\n        int i_aleluya = str_aleluya[chri_aleluya];\n        int v_aleluya = (i_aleluya >> (24-((chrl_aleluya & 0x3) <<3))) & 0xff;\n        float xl_aleluya = xd_aleluya + (1.0f/16.0f) * float(v_aleluya & 0xf);\n        float yl_aleluya = yd_aleluya + 1.0f- (1.0/16.0f) * float(v_aleluya >> 4);\n        vec3 textCol_aleluya = clamp(vec4(texture(iChannel0, vec2(xl_aleluya,yl_aleluya))).xyz - vec3(0.2f),vec3(0),vec3(1));\n        \n        col_aleluya = col_aleluya + vec4( textCol_aleluya.x, textCol_aleluya.x, textCol_aleluya.x, 1)*1.1f;\n        \n    }\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col_aleluya) ;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "int str_aleluya[16];\nint numNotes_aleluya=16;\n\n\n#define NUMNOTES_ALELUYA 58\n\nvec2 mainSound( in int samp, float time )\n{\n\n    str_aleluya[0]=0xababacae;\n    str_aleluya[1]=0xaeacaba9;\n    str_aleluya[2]=0xa7a7a9ab;\n    str_aleluya[3]=0xbb99c9ab;\n    str_aleluya[4]=0xabacaeae;\n    str_aleluya[5]=0xacaba9a7;\n    str_aleluya[6]=0xa7a9abb9;\n    str_aleluya[7]=0x97c7a9a9;\n    str_aleluya[8]=0xaba7a99b;\n    str_aleluya[9]=0x9caba7a9;\n    str_aleluya[10]=0x9b9caba9;\n    str_aleluya[11]=0xa7a9c2ab;\n    str_aleluya[12]=0xabacaeae;\n    str_aleluya[13]=0xacaba9a7;\n    str_aleluya[14]=0xa7a9abb9;\n    str_aleluya[15]=0x97c70000;\n\n    \n    int noteptr_aleluya = 0;\n    int next_note_aleluya = 0;\n    int note_aleluya = 0;\n    \n    float noteDelt_aleluya = 0.0f;\n\n    float decay_aleluya;\n    float ofreq_aleluya;\n    float attack_aleluya;\n    \n    float t_aleluya = time - floor(time) + float(int(time) % 48);\n    float tLeft_aleluya = t_aleluya;\n    int aleluya = int(t_aleluya * 44100.0f);\n    \n    float spb_aleluya=0.5f;\n    \n    while(true) {\n        int noteI_aleluya = int(noteptr_aleluya / 4);\n        int noteD_aleluya = int(noteptr_aleluya) & 3;\n        note_aleluya  = str_aleluya[noteI_aleluya % numNotes_aleluya] >> (8 * (3-noteD_aleluya)) & 0xff;\n        \n        float noteDelta_aleluya = (note_aleluya >> 4) == 0xc ?  spb_aleluya*2.0f : (note_aleluya >> 4) == 0xa ? spb_aleluya : (note_aleluya >> 4) == 0xb ? (spb_aleluya* 3.0f/2.0f) : spb_aleluya / 2.0f;\n        //next_note_aleluya = (note_aleluya >> 4) == 0xc ?  44100 : (note_aleluya >> 4) == 0xa ? 44100/2 : (note_aleluya >> 4) == 0xb ? (44100/4)*3 : 44100/4;\n        if(noteDelta_aleluya > tLeft_aleluya) break;\n        noteptr_aleluya ++;\n        tLeft_aleluya -= noteDelta_aleluya;\n        \n        \n    }\n    ofreq_aleluya =  440.0f  * pow(2.0f, (1.0f/12.0f) * float((note_aleluya & 0xf) -9) )  * 3.1416f;\n        \n    //next_note_aleluya --;\n    \n    float freq_aleluya = 440.0f * pow(2.0f, (1.0f/12.0f) * float((note_aleluya & 0xf )-2) )  * 3.1416f  *2.0f;\n\tfloat freq2_aleluya = 440.0f * pow(2.0f, (1.0f/12.0f) * float((note_aleluya & 0xf )-5) )  * 3.1416f *2.0f;\n\n    float val_aleluya = (\n          (sin(t_aleluya * ofreq_aleluya ) + sign(cos(t_aleluya * freq_aleluya ))*0.3f + sin(t_aleluya * freq2_aleluya )) \n          * 0.25f //* ((sin(t_aleluya*16.0f) *0.3f) + 0.7f)\n    \n       ) *exp(-10.0*tLeft_aleluya);\n    val_aleluya += 0.4 * (sin(t_aleluya * 440.0f * 3.1416 / (2.5+(0.5f * sign(sin(t_aleluya*3.1415) )))) *  (0.3f+ ((0.25f + 0.25f *sin(t_aleluya * 3.1416))  *sign(sin(( t_aleluya)*3.1415*2.0f)))));\n    return vec2(val_aleluya, val_aleluya);\n    //unsigned char note_aleluya = notes_aleluya[((int) (t_aleluya * 2.0f) ) % NUMNOTES_ALELUYA];\n\n    // A 440 Hz wave that attenuates quickly overt time\n    //return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}