{
    "Shader": {
        "info": {
            "date": "1472694448",
            "description": "Trying to do some beat detection in Shadertoy, it's not perfect but it (kinda) works.",
            "flags": 36,
            "hasliked": 0,
            "id": "ltG3zR",
            "likes": 13,
            "name": "Beat Detection",
            "published": 3,
            "tags": [
                "sound",
                "beat",
                "fourier"
            ],
            "usePreview": 0,
            "username": "Klems",
            "viewed": 1574
        },
        "renderpass": [
            {
                "code": "const vec2 SPECTROGRAM_SIZE = vec2(256, 256);\n\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat deltaT(float y) {\n    y *= SPECTROGRAM_SIZE.y;\n    y /= iResolution.y;\n    return texture(iChannel1, vec2(0.0, y)).r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n\tvec2 spectrUV = fragCoord.xy / iResolution.xy;\n    spectrUV *= SPECTROGRAM_SIZE;\n    spectrUV /= iResolution.xy;\n\n    float mus1 = texture(iChannel0, spectrUV).r;\n    \n    mus1 *= 1.3;\n    mus1 *= mus1;\n    mus1 *= mus1;\n    mus1 = min(1.0, mus1);\n    \n\tfragColor.rgb = hsv2rgb(vec3(1.0-mus1, 1.0, mus1));\n    fragColor.a = 1.0;\n\t\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 10.0;\n    vec2 center = vec2(0.5, floor(uv.y) + 0.5);\n\n    float radius = deltaT(center.y / 10.0);\n    if (length(uv-center) < radius*0.7) fragColor.rgb = vec3(1);\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const vec2 SPECTROGRAM_SIZE = vec2(256, 256);\n\n// construct spectrogram\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if (fragCoord.x < SPECTROGRAM_SIZE.x && fragCoord.y < SPECTROGRAM_SIZE.y) {\n        if (fragCoord.x < 1.0) {\n            float y = fragCoord.y / SPECTROGRAM_SIZE.y;\n            y = y * 0.5 + 0.5;\n            y = pow(y, 9.2082);\n            float acc = 0.0;\n            float tot = 0.0;\n            // blur on Y by a fairly large amount\n            for (int x = -32 ; x <= 32 ; x++) {\n                float value = texture(iChannel1, vec2(y + float(x)*0.0005, 0.0)).r;\n                float mult = 1.0 / max(1.0, float(x));\n                acc += value*mult;\n                tot += mult;\n            }\n            fragColor = vec4(acc / tot);\n        } else {\n            // this will blur along X a little bit, not by much\n            vec2 uv = (fragCoord - vec2(iTimeDelta*60.0, 0.0)) / iResolution.xy;\n            fragColor = texture(iChannel0, uv);\n        }\n    } else {\n        fragColor = vec4(0);\n        discard;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "mic",
                        "id": 32,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/mic.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const vec2 SPECTROGRAM_SIZE = vec2(256, 256);\n\n#define PI 3.14159265359\n\n// custom comb filter\n// x is in seconds\n// frequency is in Hz\nfloat myFilter(float x, float frequency) {\n    float val = sin(x*frequency*(1.0*PI));\n    val = abs(val);\n    val *= val;\n    val *= val;\n    val *= val;\n    val *= val;\n    return val;\n}\n\n// find which BPM is the most prevalent in the spectrogram\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if (fragCoord.x < SPECTROGRAM_SIZE.x && fragCoord.y < SPECTROGRAM_SIZE.y) {\n        float frequency = fragCoord.x / 60.0; // 1 pixel is 1 BPM\n        float m = 0.0;\n        \n        for (int j = 0 ; j < 8 ; j++) {\n            // convolve the spectrogram with a comb filter\n            float acc = 0.0;\n            float tot = 0.0;\n            for (int i = 0 ; i < 256 ; i++) {\n                vec2 samplePos = vec2(float(i) + 0.5, fragCoord.y) / iResolution.xy;\n                float x = float(i) / 60.0;\n                float offset = float(j) / 8.0 * (1.0 / frequency);\n                float pick = texture(iChannel0, samplePos).r;\n                float mult = myFilter(x+offset, frequency);\n                acc += pick*mult;\n                tot += mult;\n            }\n\n            m = max(m, acc / tot);\n        }\n        \n        fragColor = vec4(m, 0, 0, 0);\n    } else {\n        fragColor = vec4(0);\n        discard;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const vec2 SPECTROGRAM_SIZE = vec2(256, 256);\n\n// find the BPM with the strongest energy signature then store it in x=0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if (fragCoord.x < 1.0 && fragCoord.y < SPECTROGRAM_SIZE.y) {\n\t\tfloat m = 0.0;\n        float res = 0.0;\n        \n        for (int i = 20 ; i < 256 ; i++) {\n            vec2 samplePos = vec2(float(i) + 0.5, fragCoord.y) / iResolution.xy;\n\t\t\tfloat bpm = texture(iChannel0, samplePos).r;\n            if (bpm > m) {\n                m = bpm;\n                res = float(i);\n            }\n        }\n\n        fragColor = vec4(res / 60.0, 0, 0, 0);\n    } else {\n        fragColor = vec4(0);\n        discard;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const vec2 SPECTROGRAM_SIZE = vec2(256, 256);\n\nfloat hz(float y) {\n    y *= SPECTROGRAM_SIZE.y;\n    y /= iResolution.y;\n    return texture(iChannel1, vec2(0.0, y)).r;\n}\n\n// keep track of the BPM indicator in a separate buffer\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if (fragCoord.x < 1.0 && fragCoord.y < SPECTROGRAM_SIZE.y && iFrame > 0) {\n        vec2 thisPos = fragCoord / iResolution.xy;\n        vec4 thisDat = texture(iChannel0, thisPos);\n        \n        float timer = thisDat.x;\n        timer += iTimeDelta;\n        \n        float period = 1.0 / hz(fragCoord.y / SPECTROGRAM_SIZE.y);\n        timer = mod(timer, period);\n        \n        thisDat.x = timer;\n        fragColor = thisDat;\n    } else {\n        fragColor = vec4(0);\n        discard;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buf D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}