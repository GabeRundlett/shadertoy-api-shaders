{
    "Shader": {
        "info": {
            "date": "1523305918",
            "description": "Inspired by @tdhooper !!",
            "flags": 0,
            "hasliked": 0,
            "id": "4sKcDy",
            "likes": 19,
            "name": "zooming tunnel gif",
            "published": 3,
            "tags": [
                "perfectloop"
            ],
            "usePreview": 0,
            "username": "macbooktall",
            "viewed": 824
        },
        "renderpass": [
            {
                "code": "#define MAXDIST 1150.\n#define GIFLENGTH 1.570795\n#define COL vec3(0.)\n\nstruct Ray {\n\tvec3 ro;\n    vec3 rd;\n};\n\n    vec2 map(vec3 pos);\n\n    \n// Functions by iq\n// --------------------------------------------------\n    \nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n    return d1.x < d2.x ? d1 : d2;\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n\nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec3 calcNormal(vec3 pos) \n{\n\tvec3 eps = vec3(0.001, 0.0, 0.0);\n                          \n    return normalize(\n        vec3(map(pos + eps).x - map(pos - eps).x,\n             map(pos + eps.yxz).x - map(pos - eps.yxz).x,\n             map(pos + eps.yzx).x - map(pos - eps.yzx).x ) \n    );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i = 0; i < 5; i++ )\n    {\n        float hr = 0.05*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= .95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );    \n}\n\n// --------------------------------------------------\n\n\nvec2 map(vec3 pos) {\n    \n    float l = length(pos);\n\tfloat sf = .5;\n\tconst int layers = 7;\n\tvec3 dir = vec3(0.,1.,0.);\n    vec2 dist = vec2(1e20,0.);\n   \n    pos.xy += vec2(sin(pos.z*3.14159*2.), cos(pos.z*3.14159*2.))*0.025;\n    \n    for (int i = layers+1; i > 0; i--)\n    {\n        // The normalized modulated time based on progress toward the GIFLENGTH define based on the current layer\n        float t = 1.-smoothstep(0.,1.,mod(iTime/float(layers) + (float(i)/float(layers))*GIFLENGTH, GIFLENGTH)/GIFLENGTH);\n \n        // The scale of the current cylinder\n        float s = pow(sf,1.+t*float(layers+1));\n        float radius = s;\n       \n        // Create a position that is offset\n        vec3 p = pos - dir*s;\n\n        // Repeat the z axis, dividing the space into cells relative to the current layer\n        p.z = mod(pos.z-s*2., s*4.) - s*2.;\n        \n        // Reduce the gap between the cylinders when it's rly small or rly big\n\t\ts += s*smoothstep(0.65, 1., 1.-t)*1.5;\n        s += s*smoothstep(0.45, 0.25, 1.-t)*2.;\n        \n        radius += cos(pos.z*3.14159*2.+iTime*4.+t)*0.0025;\n\t\t\t\n        float tunnelDist = sdCylinder(p, vec2(radius, s));\n        tunnelDist = opS(tunnelDist, sdCylinder(p, vec2(radius*1.1,s*0.9)));\n        dist = opU(dist, vec2(tunnelDist, 1.-t));\n    }\n    \n    return dist;\n}\n\nvec2 march(Ray ray) \n{\n    const int steps = 45;\n    const float prec = 0.001;\n    vec2 res = vec2(0.);\n    \n    for (int i = 0; i < steps; i++) \n    {        \n        vec2 s = map(ray.ro + ray.rd * res.x);\n        \n        if (res.x > MAXDIST || s.x < prec) \n        {\n        \tbreak;    \n        }\n        \n        res.x += s.x;\n        res.y = s.y;\n        \n    }\n   \n    return res;\n}\n\nvec3 render(Ray ray) \n{\n    vec3 col = COL;\n\tvec2 res = march(ray);\n   \n    if (res.x > MAXDIST) \n    {\n        return col;\n    }\n    \n    vec3 pos = ray.ro+res.x*ray.rd;\n    vec3 rd = normalize(ray.ro-pos);\n    vec3 nor = calcNormal(pos);\n    \n    // Color the surface based on what layer the ray intersects with\n    col = 1.-vec3(calcAO(pos, nor))*clamp(0.,1.,res.y);\n    col = mix(col, COL, clamp( 0., 1., res.x*0.5));\n   \treturn col;\n}\nmat3 camera(in vec3 ro, in vec3 rd, float rot) \n{\n\tvec3 forward = normalize(rd - ro);\n    vec3 worldUp = vec3(sin(rot), cos(rot), 0.0);\n    vec3 x = normalize(cross(forward, worldUp));\n    vec3 y = normalize(cross(x, forward));\n    return mat3(x, y, forward);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 camPos = vec3(0.,.15+sin(iTime*4.)*0.01, .22+cos(iTime*4.)*0.01);\n    vec3 camDir = camPos+vec3(0. + cos(iTime*4.)*0.01, -0.45 + sin(iTime*4.)*0.015, -1. );\n    mat3 cam = camera(camPos, camDir, 0.);\n    \n    vec3 rayDir = cam * normalize( vec3(uv, 1.5 ));\n    \n    Ray ray;\n    ray.ro = camPos;\n    ray.rd = rayDir;\n    \n    vec3 col = render(ray);\n    \n\tfragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}