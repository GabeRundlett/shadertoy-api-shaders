{
    "Shader": {
        "info": {
            "date": "1611298431",
            "description": "Fun with hexagonal tiling.",
            "flags": 0,
            "hasliked": 0,
            "id": "3lyczK",
            "likes": 14,
            "name": "Ripples in Hexagonal Tiling",
            "published": 3,
            "tags": [
                "ripples",
                "demo",
                "sine",
                "hue",
                "tiling",
                "hexagonal"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 266
        },
        "renderpass": [
            {
                "code": "// Hue to RGB function from Fabrice's shadertoyunofficial blog:\n#define hue2rgb(hue) 0.6 + 0.6 * cos(6.3 * hue + vec3(0.0, 23.0, 21.0))\n\n// Woah thats trippy!\n//#define PSYCHO_MODE\n\nstruct Surface {\n    float dist;\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float gloss;\n};\n\nfloat sdHexShape(in vec3 p, in float s) {\n    const vec2 n = normalize(vec2(1.0, sqrt(3.0)));\n    p = abs(p);\n    vec2 p2 = vec2(max(dot(p.xz, n), p.x), p.y);\n\n    #ifdef PSYCHO_MODE\n    return max(length(p.xz) - 1.0, abs(p.y - s) - s);\n    #else\n    return max(abs(p2.x - s), p2.y) - 0.1;//max(dot(p2, n), p2.x) - s;\n    #endif\n}\n\nSurface mapScene(in vec3 p) {\n    vec2 rep = vec2(2.0, 3.46); // 1.73 ~ sqrt(3)\n    vec2 hrep = 0.5 * rep;\n    vec2 a = mod(p.xz, rep) - hrep;\n    vec2 b = mod(p.xz - hrep, rep) - hrep;\n    vec2 hexUv = dot(a, a) < dot(b, b) ? a : b;\n    vec2 cellId = p.xz - hexUv;\n    p.xz = hexUv;\n\n    float oscPoint = 0.5;\n    float freq = 0.5;\n    float amp = 0.4;\n    #ifdef PSYCHO_MODE\n    oscPoint = 5.0;\n    freq = 0.25;\n    amp = 2.5;\n    #endif\n\n    float ripples = oscPoint + amp * sin(length(cellId) * freq - iTime * 4.0);\n    return Surface(sdHexShape(p, ripples) * 0.25, vec3(0.2, 0.0, 0.0), hue2rgb(ripples * freq), vec3(1.0), 8.0);\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy).dist - mapScene(p - e.xyy).dist,\n                          mapScene(p + e.yxy).dist - mapScene(p - e.yxy).dist,\n                          mapScene(p + e.yyx).dist - mapScene(p - e.yyx).dist));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    float camDist = 5.0;\n    #ifdef PSYCHO_MODE\n    camDist = 20.0;\n    #endif\n\n    vec3 ro = vec3(cos(iTime), 2.0 + sin(0.5 * iTime), cos(1.5 * iTime)) * camDist;\n\n    vec3 f = -normalize(ro);\n    vec3 r = normalize(vec3(-f.z, 0.0, f.x));\n    vec3 u = normalize(cross(r, f));\n    vec3 rd = normalize(f + uv.x * r + uv.y * u);\n\n    vec3 l = vec3(-0.58, 0.58, 0.58);\n\n    float time = 0.5 * iTime;\n    float c = cos(time), s = sin(time);\n    l.xz *= mat2(c, s, -s, c);\n\n    float t = 0.0;\n    for (int i=0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        Surface scene = mapScene(p);\n        if (scene.dist < 0.001) {\n            vec3 n = getNormal(p);\n            fragColor.rgb += scene.ambient;\n\n            float lambertian = max(0.0, dot(n, l));\n            fragColor.rgb += scene.diffuse * lambertian;\n\n            if (lambertian > 0.0) {\n                vec3 r = reflect(l, n);\n                float specAngle = max(0.0, dot(r, rd));\n                fragColor.rgb += scene.specular * max(0.0, pow(specAngle, scene.gloss));\n            }\n\n            break;\n        }\n\n        if (t > 100.0) {\n            break;\n        }\n\n        t += scene.dist;\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}