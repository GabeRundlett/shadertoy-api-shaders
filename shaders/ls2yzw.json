{
    "Shader": {
        "info": {
            "date": "1491429169",
            "description": "Getting some standard raymarching stuff happening.\n\nTheres a lot of unused code, the start of a tree based ray compositor.\n\nAt the moment im figuring out why the shadow umbras are glitching out at the edges. Any help would be greatly appreciated!",
            "flags": 0,
            "hasliked": 0,
            "id": "ls2yzw",
            "likes": 1,
            "name": "WIP:Spheres and Cones, rotating ",
            "published": 3,
            "tags": [
                "raymarching",
                "normals",
                "shadows",
                "compositing"
            ],
            "usePreview": 0,
            "username": "vsnchips",
            "viewed": 826
        },
        "renderpass": [
            {
                "code": "\n#define PI 3.1412\n#define MAXRAYNODES 2\n\n#define REFLECTCLIP 0.05\n#define ALPHACLIP 0.05\n#define SHADN 1024\n#define TREEN 16\n#define N 256\n#define MAXD 200\n\nconst int HALFRAYNODES = (MAXRAYNODES+1 /2);\n\nfloat iFade;\nint iFadeMode;\n//uniform float iTime;\n//uniform vec3 iMouse;\n//uniform vec2 iResolution;\n\nvec3 iCamLook;\nvec3 iCamPos;\nvec3 iWorldRotate;\nvec3 iSun;\n\nfloat iSphereRad = 1.;\n\nuniform vec3 hsvin;\n\nuniform float rad;\n\n#define iMarchFactor 0.4;\nfloat iTMFactor=0.2;\nfloat iResultDMult=0.8;\n\nfloat radius = 0.34;\nfloat iCubeScale;\nfloat iSphereScale = 0.2;\n\nuniform float iShapeCF;\nuniform float iShapeFade;\n\nfloat iModX = 1.;\nfloat iModY = 1.;\nfloat iModZ = 1.;\n\nfloat iDotSlide = 1.;\n\nuniform float iAperture;\n\n//////////////////////////\n//STRUCTS\n\n//////////////////////////\n\nstruct traceData{\n    vec3 r;\n    float l;\n    float t;\n    vec3 p;\n    vec3 myNormal;\n    int matId;\n    int surfId;\n    float alpha;\n    float reflectance;\n    vec3 radiance;\n\n} dtraceOut;\n\nstruct ray{\n    vec3 o;\n    vec3 r;\n    float a;\n} baseRay;\n\nstruct rayNode{\n    traceData myData;\n    int leftP;\n    int rightP; \n    float aperture;\n    vec3 result;\n    vec3 diffresult;\n    bool done;\n}rootNode;\n\nstruct light{\n    vec3 tint;\n    vec3 p;    \n} theSun;\n\nstruct material{\n    vec3 radiance;\n    vec3 diffuse;\n    vec3 refMult;\n    vec3 alphaMult;\n    float alpha;\n    float reflectance;\n}somethingness;\n\n\n                                                                    //fragment globals\n\n traceData dSphere;\n traceData dCubish;\n traceData dTexMarch;\n traceData dCone;\n\n vec3 wP;\n\n rayNode[MAXRAYNODES] rayTree;\n\n int rtQCursor;\n int rtCCursor;\n int rtCount;\n\nvec4 texCol0;\nvec2 fragCoord;\nvec2 vUv;\n\nmaterial mats[32];\n\nfloat scope=0.8;\nfloat pulsespeed = 0.2;\n\nvec3 origincam = vec3 (0.1,1.5,2.2);\n\nfloat camrotx = 0.;\nfloat camroty = 0.;\nfloat camrotz = 0.;\n\n//\n////\n// ADAPT\n////\n//\n\nvoid adapt(){\n    \n  //  fragCoord = vUV.st;\n  //  vUv = vUV.st;    \n   // texCol0 = texture2D(sTD2DInputs[0],fragCoord);\n}\n\n\n//\n///\n/////\n\n// VARIOUS MATH\n\n/////\n///\n//\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n//\n////\n////////\n////////////\n\n// COLOR, ANIMATION, UNIFORM INTERPRETATION\n\n////////////\n////////\n////\n//\n\n\n\n\nfloat deg60 = 1./6.;\n\n\nvec3 HSVfromRGB(vec3 incol){\n            \n            \n                float value = max(incol.r,max(incol.g,incol.b));\n                float grey = min(incol.r,min(incol.g,incol.b));\n                float sat = value - grey;           \n                float hue;\n                \n                \n                if (value == incol.r){\n                    if (grey == incol.b){\n                        hue = deg60*(incol.g-grey)/(value-grey);// sector 1     //orange reds\n                    } else {                                                \n                    hue = 1.-deg60*(incol.b-grey)/(value-grey);                 //magentas                                                                                  \n                    }   \n                }                       \n                if (value == incol.g){\n                    if (grey == incol.b){\n                        hue = 2.*deg60 - deg60*(incol.r-grey)/(value-grey);// sector 1      //yellow greens\n                    } else {\n                    hue = 2.*deg60+deg60*(incol.b-grey)/(value-grey);                   //turquoise, cyans\n                    }\n                }   \n                if (value == incol.b){\n                    if (grey == incol.r){\n                        hue = 4.*deg60 - deg60*(incol.g-grey)/(value-grey);// sector 1      //cyan blues\n                    } else {\n                    hue = 4.*deg60+deg60*(incol.r-grey)/(value-grey);                   //violet blues\n                    }\n                }   \n            \n            return vec3(hue,sat,value);\n\n        }\n\n\n            vec3 RGBfromHSV(vec3 hsv){\n            \n                float chroma, greylevel, X;\n                chroma = hsv.y*hsv.z;         // chroma and greylevel, two different relationships between saturation and value.\n                greylevel = hsv.z - hsv.y;  \n                \n                \n                float tH;           \n                \n                tH = hsv.x/deg60;\n                X = (1.-abs(mod(tH,2.)-1.));   // x lerps between greylevel and V\n                \n                vec3 tCol;\n                \n                \n                int sector = int(floor(tH));\n                /*/switch (sector){\n                //case 0: tCol = vec3(1.,X,0.); break;\n                //case 1: tCol = vec3(X,1.,0.); break;\n                case 2: tCol = vec3(0.1.,X); break; \n                case 3: tCol = vec3(0.,X,1.); break;\n                case 4: tCol = vec3(X,0.,1.); break;\n                case 5: tCol = vec3(1.,0.,X); break;*/\n                \n                if (sector == 0){tCol = vec3(1.,X,0.); }\n                else if (sector == 1){tCol = vec3(X,1.,0.); }\n                else if (sector == 2){tCol = vec3(0.,1.,X);}\n                else if (sector == 3){tCol = vec3(0.,X,1.);}\n                else if (sector == 4){tCol = vec3(X,0.,1.); }\n                else if (sector == 5){tCol = vec3(1.,0.,X);; }\n                \n                return chroma*tCol+greylevel;   // final color.\n                \n            }\n\n\n//\n////\n////////\n////////////\n\n//RayMarching Geometry\n\n////////////\n////////\n////\n//\n\n\n///////////////////// MAKE SOME SHAPES /////////////////////////////\n\n        ////    //   //   //  ||////     //////   /////////// \n     //    //  //   //  // || ||   //   //       //        //\n    //        //   //  //  || ||  //   //        //\n   ///////// ///////  /////|| ||///   ////////    ///////// \n   //     // //   //  //    || ||     //           /      //   \n    ////// //   //  //     || ||    //////////     ///////\n\n\n//////////////////////////////\n//      primitives           //\n//////////////////////////////\n\n\n//cubeything\n\ntraceData cubish (vec3 p, float size, float pw)\n{\n\n    traceData tout;\n    vec3 ftbish= vec3(pow(fract(p.x)*2.-1.,pw),pow(fract(p.y)*2.-1.,pw),pow(fract(p.z)*2.-1.,pw));\n    vec3 bish= vec3(pow(p.x,pw),pow(p.y,pw),pow(p.z,pw));\n    \n    tout.p = (ftbish);\n    tout.l = abs(length (tout.p) - size);\n    return tout;\n}\n\n\n\n\n\n                                                //sphere\ntraceData sphere (vec3 p,float rad){\n\ntraceData tout;\n\n//float lod1 = wP.x*wP.x+wP.y*wP.y+wP.z*wP.z - iSphereRad;\nfloat lod1 = 0.;\nif (lod1 > 0.1 ){  tout.l = lod1;}\nelse{\ntout.p = fract((2.*(p+.5))-1.)  -.5;\ntout.l = (length(tout.p) - rad)*0.8;\n}\nreturn tout;\n\n}\n\n\n\n                                        //sphere with modulus iteration\n\ntraceData modsphere (vec3 p, float rad){\n\ntraceData tout;\n\ntout.p = vec3(   mod(((2.*(p.x+.5))-1.),iModX)-.5*iModX ,  mod(((2.*(p.z+.5))-1.),iModY)-.5*iModY ,      mod(((2.*(p.y+.5))-1.),iModZ)-.5*iModZ);\ntout.l = length(tout.p) - rad;\nreturn tout;\n\n}\n\n\n// cone\nfloat ConeD(vec3 p, float h, float r){          // cone dist\n    \n//float lod1 = wP.x*wP.x+wP.y*wP.y+wP.z*wP.z - 2    ;\nfloat lod1 =0.;      \nif (lod1> 0.1 )  return lod1;\n    \n    mat2 rotation = rotate2d(ceil(p.y)*0.6);\n    //mat2 rotation = rotate2d(0.);\n\n    p=(fract(p));\n\tp-=0.5;\n\n    p.yz *= rotation;\n    \n    float pl = length(p.xy)/r;\n\n    return max((pl+(p.z)-0.5), -p.z);\n    }\n\n\n//////////////////////////////\n//      Geometric Glue      //\n//////////////////////////////\n\nvec3 lerpDotSpace(vec3 p, float t){\n\n    float dotp = dot(p,p);\n\n    p= vec3(mix(p.x,p.x/dotp,t),mix(p.y,p.y/dotp,t),mix(p.z,p.z/dotp,t));\n\n    p=mix(p,p/dotp,t);\n\n    return p;\n\n}\n\n// polynomial smooth \n\nfloat pSmoothMin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//\n///\n/////\n////////////////////////////////                                                // SCENE LAYOUT HAPPENS HERE\n//      map         Scene     ///////////////////////////        \n////////////////////////////////\n/////\n///\n//\n\n\n//traceData map(vec3 point){\n\nfloat map(vec3 point){\n\n\nwP = point + iCamPos;\n    \n        //shape finding functions:\n        dSphere = sphere(point*iSphereScale, 0.3);\n        dCone.l = ConeD(point,0.8,0.4);\n       return min(dSphere.l,dCone.l);\n       //return min(dSphere.l,point.z+20);\n}\n\ntraceData finalmap(vec3 point){\n    \n        //shape finding functions:\n        dSphere = sphere(point*iSphereScale, rad);\n\n        dCone.l = ConeD(point,0.4,0.2);\n\n        //dTexMarch.p = texture2D(sTD2DInputs[0],fract(point.xy*0.1)).rgb;\n        //dTexMarch.l=length(dTexMarch.p);\n\n        traceData fout;\n        //fout.l= pSmoothMin(dCone.l,dSphere.l,0.5);\n        fout.l= dSphere.l;\n        \n\n        float least = min(dCone.l,dSphere.l);\n       // return fout;\n       //return pSmoothMin(dCone.l,dSphere.l,0.1);\n       return fout;\n}\n\n\n////\n////////\n////////////\n\n// Normal finder\n\n////////////\n////////\n////\n\nvec3 getNorm( in vec3 pos )\n{\n    vec3 eps = vec3( 0.00001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy) - map(pos-eps.xyy),\n        map(pos+eps.yxy) - map(pos-eps.yxy),\n        map(pos+eps.yyx) - map(pos-eps.yyx) );\n    return normalize(nor);\n}\n\n////////////////////////////////\n//      trace functions        //\n////////////////////////////////\n\n\n traceData trace (vec3 o, vec3 r, float rad , int tN){ \n\n    traceData dtraceOut;\n\n    vec3 newpoint;\n    float t = 0.05;\n\n    for (int i = 0; i < tN; ++i) {                  // <-- trace iterator\n\n         newpoint = o + r * t;\n        //o = lerpDotSpace(o,iDotSlide);\n\n        if (t>float(MAXD)) break;\n        dtraceOut.l = map(newpoint);        \n        if (dtraceOut.l < 0.01 ) break;     \n\n        t += dtraceOut.l * iMarchFactor;\n    }\n\n dtraceOut.t = t;\n dtraceOut.surfId=1;\n dtraceOut.matId=dtraceOut.surfId;\n dtraceOut.myNormal = getNorm(newpoint);\ndtraceOut.matId = 0;\ndtraceOut.p = newpoint;\n\nreturn dtraceOut;\n}\n\n\n///////////////////////////////////////\n\n float shadeTrace (vec3 o, vec3 r, int pen, float maxT){ \n\n    float exp = 1.;\n\n    vec3 newpoint;\n    float t = 0.5;\n\n    float d;\n\n    int i;\n    for (t=0.05; t < maxT; i++ ) {                  // <-- trace iterator\n\n        //break;\n         newpoint = o + r * t;\n        //o = lerpDotSpace(o,iDotSlide);\n\n        //if (t>MAXD) break;\n        d = map(newpoint);        \n        if (d < 0.00001 ||  i >= SHADN){exp = 0.; break; }\n        \n        //t += d * 0.2 *iMarchFactor;\n        t += d;\n\n        exp = min(exp,d*(float(pen))/t);\n    }\nreturn exp;\n}\n\n\n///////////////////////////////////////\n\n\n\n\n\n//rootNode = rayTree[0];\n\nint i = 0;\nfloat thisalpha = 1.;\nfloat[MAXRAYNODES] alphaStack;\nint aStackH = 0;\n\n\nvoid shootRay(){\n    //while (!rayTree[0].done){   // mite break it\n    for (int bark = 0; bark < 128; bark ++){                                       // THIS is a RAY TREE\n                                                                // implemented iteratively with an array as a stack.        \n        if (i<HALFRAYNODES){\n\n            bool leftDone = (rayTree[i*2].done || thisalpha*mats[rayTree[i].myData.matId].alpha>ALPHACLIP);             // Do we need to blend?\n            bool rightDone = (rayTree[i*2+1].done || thisalpha*mats[rayTree[i].myData.matId].reflectance>REFLECTCLIP);          // Do we need to reflect?\n\n            if (leftDone && rightDone){                                                             // Ray Color Compositing\n            \n                rayTree[i].diffresult = vec3(0.3);   // TODO: Calculate Diffusion    //lighting calcs go here\n                traceData lightresult = trace(theSun.p,theSun.p-rayTree[i].myData.p,10.,SHADN);\n                rayTree[i].diffresult *= (1.-lightresult.l*80.3);\n\n                rayTree[i].result = (mix(rayTree[i*2].result,rayTree[i].diffresult*mats[rayTree[i].myData.matId].alphaMult,mats[rayTree[i].myData.matId].alpha) +        //Diffusion Blocks the background\n               \n                mats[rayTree[i].myData.matId].radiance +                                                                //Radiance is purely additive\n                rayTree[i*2+1].result*mats[rayTree[i].myData.matId].refMult);                                                            //As is reflectance.\n\n                 //rayTree[i].result = vec3(1,0.5,1);\n\n                rayTree[i].done = true;\n\n                i /=2;\n                //i =0;\n                thisalpha = alphaStack[i];      // Go to Parent // i *think * this'll work.\n            }\n\n        if (!leftDone){\n\n            while (  (i<HALFRAYNODES && thisalpha*rayTree[i].myData.alpha<ALPHACLIP)  ||     // alpha OR relection\n             (i<HALFRAYNODES && thisalpha*rayTree[i].myData.reflectance<REFLECTCLIP)       //  if this node isnt a heap yet\n\n            ){\n                if (i<HALFRAYNODES && !rayTree[i*2].done && thisalpha*rayTree[i].myData.alpha<ALPHACLIP){   // if left isnt a heap yet, \n                \n                    rayTree[i*2].myData = trace(rayTree[i].myData.p+rayTree[i].myData.r*0.0001,rayTree[i].myData.r,1.0,TREEN);    // march that same ray\n\n                    alphaStack[i] = thisalpha;                                              // save the alpha\n                    thisalpha *= mats[rayTree[i].myData.matId].alpha;                                             //multiply it for the next node\n                i = i*2;                                                                    // step over to the new point\n                continue;                                                                   // Check next Alpha\n                      }\n\n                if (i<HALFRAYNODES && !rayTree[i*2+1].done && thisalpha*rayTree[i].myData.reflectance<REFLECTCLIP){ // if left is a heap but right isnt a heap yet, \n                \n                    rayTree[i].myData.myNormal = getNorm(rayTree[i].myData.p);                  //get the Normal j.i.t                  \n                    vec3 reRay = reflect(rayTree[i].myData.r,rayTree[i].myData.myNormal);               // now we get the reflection\n                    rayTree[i*2+1].myData = trace(rayTree[i].myData.p+reRay*0.1,reRay,10.0,TREEN);    // march that reflection ray\n\n                    alphaStack[i] = thisalpha;                                              // save the alpha\n                    thisalpha *= mats[rayTree[i].myData.matId].alpha;                                             //multiply it for the next node\n                i = i*2;                                                                    // step over to the new point\n\n                      }      \n                }\n\n            //  if ()\n        }\n\n\n}\nelse {\nrayTree[i].done = true;\nrayTree[i].diffresult = vec3(0.8,0.3,0.01);\nrayTree[i].result = rayTree[i].diffresult + mats[rayTree[i].myData.matId].radiance; //radiate+expose\n\n}\n\nif (rayTree[0].done) break;\n\n}\n}\n\n\n/*void queueRay(ray newRay){\n    rayTree[rtQCursor] = newRay;\n    rtQCursor = (rtQCursor > 30) ? 0 : rtQCursor +1;\n\n}\n\ntraceData catchRay(ray newRay){\n    traceData notrace;\n    return notrace;\n}\n*/\n\n\n\n\n////\n////////\n////////////\n\n// Lighting\n\n////////////\n////////\n////\n\n\n\n//////// DEFINE MATERIALS ////////////                      //\\    /||\n                                                            // \\  / ||\nvoid defMats(){                                             //  \\/  ||         \n    material clay;\n    somethingness.radiance = vec3(0,0.0,0.5);\n    somethingness.diffuse = vec3(0.8,0.5,0.2);\n    somethingness.refMult = vec3(1,1,1);\n    somethingness.alphaMult = vec3(1,1,1);\n    somethingness.alpha = 0.9;\n    somethingness.reflectance = 0.3;\n    clay.radiance = vec3(0,0.0,0.8);\n    clay.diffuse = vec3(0.8,0.5,0.2);\n    clay.refMult = vec3(1,1,1);\n    clay.alphaMult = vec3(1,1,1);\n    clay.alpha = 1.;\n    clay.reflectance = 0.0;\n\nmats[0] = somethingness;\nmats[1] = clay;\n}\n\n\n\n//\n////\n/////\n// MAIN //\n/////\n////\n//\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n\n    adapt();\n    defMats();      //DEPRECATED\n    \n    \n    // copypaste TouchDesigner uniforms into local variables\n\n\niCamPos  = vec3(iTime*0.1);\n    iCamPos.z = 0.0011;\niWorldRotate = vec3(iTime*.1);\n    //\n\niSun = vec3(iTime*0.1+7.*sin(iTime*0.01));\niSun.z = 0.5;    \n\niCamLook  = iSun;\n    \n    theSun.p = iSun;\ntheSun.tint = vec3 (1.5,1.2,0.5);\n    \n    //update camera, size, transforms\n   origincam = iCamPos;\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.2 -1.0;\n   vec3 ray = normalize(vec3( uv,scope)); \n\n    /////////////////////Look At Target   /////////////////////\n   ray.xy *= mat2 (cos (iCamLook.z),-sin (iCamLook.z),sin (iCamLook.z),cos (iCamLook.z));\n   ray.yz *= mat2 (cos (iCamLook.x),-sin (iCamLook.x),sin (iCamLook.x),cos (iCamLook.x));\n   ray.xz *= mat2 (cos (iCamLook.y),-sin (iCamLook.y),sin (iCamLook.y),cos (iCamLook.y));      \n\n   vec3 normpos = normalize(origincam);\n    normpos = vec3(origincam.x,origincam.y,-origincam.z);\n\n   float camYrot = atan(normpos.x,normpos.z); \n   //float camYrot = atan(normpos.z,normpos.x); \n   normpos.xz *= mat2 (cos (camYrot), -sin (camYrot), sin (camYrot), cos (camYrot));  \n   float camXrot = atan(normpos.y,normpos.z);\n   //float camXrot = atan(normpos.z,normpos.y);\n   ray.yz *= mat2 (cos (camXrot), -sin (camXrot),sin (camXrot),cos (camXrot));\n   ray.xz *= mat2 (cos (camYrot), -sin (camYrot),sin (camYrot),cos (camYrot)); \n   ///////////////////////\n\n\n    rayTree[0].myData = trace(origincam,ray,0.,N);\n    rayTree[0].myData.myNormal = getNorm(rayTree[0].myData.p);\n\n\n    //shootRay();\n\n    vec3 sunRay = rayTree[0].myData.p-theSun.p;\n    float sunD = length(sunRay);\n    sunRay = normalize(sunRay);\n    sunRay = sunRay;\n\n    float fres = dot(rayTree[0].myData.myNormal, sunRay);\n   \n    float exposure = shadeTrace(theSun.p,sunRay,100,sunD-0.01);\n\n    vec3 sunvec = (theSun.p - origincam);\n    float looksun = dot(normalize(sunvec) , ray);\n   \n    //float sunpoint = step(length(sunvec),rayTree[0].myData.t)*looksun*looksun*looksun*0.5;  \n    float sunpoint = step(length(sunvec),rayTree[0].myData.t)*max(pow(looksun*300.-298.8,3.),0.);  \n    //float sunpoint = step(length(sunvec),rayTree[0].myData.t)*pow(max(3-sunD,0),3)*0.5;  \n\n    vec4 comp = vec4(1.-0.7*length(rayTree[0].myData.p))*0.+exposure;\n\n    //comp.rgb /= (-fres*1);\n    //comp.rgb -= (0.5/-fres*0.5);\n    \n    comp.rgb -= (1.+fres)*0.5;\n    //comp.rgb=vec3(-fres);\n    comp.rgb += vec3(rayTree[0].myData.myNormal*0.1);\n\n\n    comp.rgb = smoothstep(0.,1.,comp.rgb); //clip negative shadows;\n    //comp.rgb += looksun*0.1;\n    comp.rgb += max(1.5-sunD*3.,0.)*rayTree[0].myData.myNormal;\n\n    comp.rgb += vec3(rayTree[0].myData.myNormal*0.1);\n\n    comp.rgb += vec3(sunpoint);\n    fragColor = comp;    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}