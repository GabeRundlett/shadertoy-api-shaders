{
    "Shader": {
        "info": {
            "date": "1472712684",
            "description": "Colors created through NTSC artifacting on 4-bit patterns, similar to the Apple II's lo-res mode.\nLeft: Raw RGB input image (B/W in this case). Right: Image after modulation & demodulation.\n",
            "flags": 32,
            "hasliked": 0,
            "id": "llyGzR",
            "likes": 37,
            "name": "Apple II-Like Artifact Colors",
            "published": 3,
            "tags": [
                "ntsc",
                "composite",
                "artifact"
            ],
            "usePreview": 0,
            "username": "Flyguy",
            "viewed": 3877
        },
        "renderpass": [
            {
                "code": "//Composite color artifact simulator\n//Change Buf A to change the input image.\n\n#define HUE 0.0\n#define SATURATION 30.0\n#define BRIGHTNESS 1.0\n\n#define COMPOSITE 0 //Composite demodulated image\n#define RGB 1 //Raw RGB input image\n#define LUMA 2 //Luma component\n#define CHROMA 3 //Chroma component\n#define SIGNAL 4 //Modulated image\n#define SPLIT 5 //Left = Input RGB, Right = Output composite\n\n#define VIEW_MODE SPLIT\n\n#define F_COL (1.0 / 4.0)\n#define F_LUMA_LP (1.0 / 6.0)\n\n#define FIR_SIZE 29\n\nfloat pi = atan(1.0)*4.0;\nfloat tau = atan(1.0)*8.0;\n\nmat3 yiq2rgb = mat3(1.000, 1.000, 1.000,\n                    0.956,-0.272,-1.106,\n                    0.621,-0.647, 1.703);\n\n//Angle -> 2D rotation matrix \nmat2 rotate(float a)\n{\n    return mat2( cos(a), sin(a),\n                -sin(a), cos(a));\n}\n\n//Non-normalized texture sampling.\nvec4 sample2D(sampler2D sampler,vec2 resolution, vec2 uv)\n{\n    return texture(sampler, uv / resolution);\n}\n\nfloat sinc(float x)\n{\n\treturn (x == 0.0) ? 1.0 : sin(x*pi)/(x*pi);   \n}\n\n//https://en.wikipedia.org/wiki/Window_function\nfloat WindowBlackman(float a, int N, int i)\n{\n    float a0 = (1.0 - a) / 2.0;\n    float a1 = 0.5;\n    float a2 = a / 2.0;\n    \n    float wnd = a0;\n    wnd -= a1 * cos(2.0 * pi * (float(i) / float(N - 1)));\n    wnd += a2 * cos(4.0 * pi * (float(i) / float(N - 1)));\n    \n    return wnd;\n}\n\n//FIR lowpass filter \n//Fc = Cutoff freq., Fs = Sample freq., N = # of taps, i = Tap index\nfloat Lowpass(float Fc, float Fs, int N, int i)\n{    \n    float wc = (Fc/Fs);\n    \n    float wnd = WindowBlackman(0.16, N, i);\n    \n    return 2.0*wc * wnd * sinc(2.0*wc * float(i - N/2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float Fs = iResolution.x;\n    float Fcol = Fs * F_COL;\n    float Flumlp = Fs * F_LUMA_LP;\n    float n = floor(fragCoord.x);\n    \n\tvec2 uv = fragCoord.xy;\n    \n    float luma = sample2D(iChannel0, iResolution.xy, uv).r;\n    vec2 chroma = vec2(0);\n    \n    //Filtering out unwanted high freqency content from the chroma(IQ) signal.\n    for(int i = 0;i < FIR_SIZE;i++)\n    {\n        int tpidx = FIR_SIZE - i - 1;\n        float lp = Lowpass(Flumlp, Fs, FIR_SIZE, tpidx);\n        chroma += sample2D(iChannel0, iResolution.xy, uv - vec2(i - FIR_SIZE / 2, 0)).yz * lp;\n    }\n    \n    chroma *= rotate(tau * HUE);\n    \n    vec3 color = yiq2rgb * vec3(BRIGHTNESS * luma, chroma * SATURATION);\n    \n    #if(VIEW_MODE == COMPOSITE)\n    \tfragColor = vec4(color, 0);\n    \n    #elif(VIEW_MODE == RGB)\n   \t\tfragColor = texture(iChannel1, uv / iResolution.xy);\n    \n    #elif(VIEW_MODE == LUMA) \n    \tfragColor = vec4(luma);\n    \n    #elif(VIEW_MODE == CHROMA)\n    \tfragColor = vec4(40.0*chroma+0.5,0,0);\n    \n    #elif(VIEW_MODE == SIGNAL)\n    \tfragColor = 0.5 * texture(iChannel2, uv / iResolution.xy).rrrr+0.25;\n    \n    #elif(VIEW_MODE == SPLIT)\n    \tif(uv.x < iResolution.x/2.0)\n        {\n            fragColor = texture(iChannel1, uv / iResolution.xy);\n        }\n        else\n        {\n    \t\tfragColor = vec4(color, 0);\n        }\n    #endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Raw RGB input shader.\n//Paste any shader here.\n//Previous shader: https://www.shadertoy.com/view/4dt3RX\n\n//Apple II low-res like mode.\n//Input color is only 1-bit (black or white) in 4-bit patterns. \n//Colors emerge through artifacting.\n\nfloat pi = atan(1.0)*4.0;\n\nfloat extract_bit(float n, float b)\n{\n    if(b < 0.0 || b > 23.0){ return 0.0; }\n\treturn floor(mod(floor(float(n) / exp2(floor(b))),2.0));   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 cen = floor(iResolution.xy / 4.0 / 2.0);\n    vec2 uv = floor(fragCoord.xy / 4.0);\n    \n    vec2 offs = vec2(0);\n    float t = iTime;\n    \n    float idx = 0.0;\n    \n    offs = 20.0*vec2(cos(1.1 * t), sin(1.1 * t)) + cen;\n    idx = sin(pi * length(uv - offs) * 0.05);\n    \n    offs = 30.0*vec2(cos(-2.0 * t), sin(-2.3 * t)) + cen;\n    idx += sin(pi * length(uv - offs) * 0.08);\n    \n    offs = 40.0*vec2(cos(0.3 * t), sin(0.9 * t)) + cen;\n    idx += sin(pi * length(uv - offs) * 0.07);\n    \n    idx /= 3.0;\n    \n    idx = idx * 0.5 + 0.5;\n    idx *= 15.5;\n    idx = mod(floor(idx), 16.0);\n    \n    float bit = mod(floor(fragCoord.x), 4.0);\n    \n    fragColor = vec4(vec3(extract_bit(idx, bit)), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Modulator\n\n#define F_COL (1.0 / 4.0)\n\nfloat tau = atan(1.0)*8.0;\n\nmat3 rgb2yiq = mat3(0.299, 0.596, 0.211,\n                    0.587,-0.274,-0.523,\n                    0.114,-0.322, 0.312);\n\n//Complex oscillator, Fo = Oscillator freq., Fs = Sample freq., n = Sample index\nvec2 Oscillator(float Fo, float Fs, float n)\n{\n    float phase = (tau*Fo*floor(n))/Fs;\n    return vec2(cos(phase),sin(phase));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float Fs = iResolution.x;\n    float Fcol = Fs * F_COL;\n    float n = floor(fragCoord.x);\n    \n    vec3 cRGB = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    vec3 cYIQ = rgb2yiq * cRGB;\n    \n    vec2 cOsc = Oscillator(Fcol, Fs, n);\n    \n    float sig = cYIQ.x + dot(cOsc, cYIQ.yz);\n\n    fragColor = vec4(sig,0,0,0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Demodulator\n\n#define F_COL (1.0 / 4.0)\n#define F_LUMA_LP (1.0 / 6.0)\n#define F_COL_BW (1.0 / 50.0)\n\n#define FIR_SIZE 29\n\nfloat pi = atan(1.0)*4.0;\nfloat tau = atan(1.0)*8.0;\n\n//Non-normalized texture sampling.\nvec4 sample2D(sampler2D sampler,vec2 resolution, vec2 uv)\n{\n    return texture(sampler, uv / resolution);\n}\n\n//Complex multiply\nvec2 cmul(vec2 a, vec2 b)\n{\n   return vec2((a.x * b.x) - (a.y * b.y), (a.x * b.y) + (a.y * b.x));\n}\n\nfloat sinc(float x)\n{\n\treturn (x == 0.0) ? 1.0 : sin(x*pi)/(x*pi);   \n}\n\n//https://en.wikipedia.org/wiki/Window_function\nfloat WindowBlackman(float a, int N, int i)\n{\n    float a0 = (1.0 - a) / 2.0;\n    float a1 = 0.5;\n    float a2 = a / 2.0;\n    \n    float wnd = a0;\n    wnd -= a1 * cos(2.0 * pi * (float(i) / float(N - 1)));\n    wnd += a2 * cos(4.0 * pi * (float(i) / float(N - 1)));\n    \n    return wnd;\n}\n\n//FIR lowpass filter \n//Fc = Cutoff freq., Fs = Sample freq., N = # of taps, i = Tap index\nfloat Lowpass(float Fc, float Fs, int N, int i)\n{    \n    float wc = (Fc/Fs);\n    \n    float wnd = WindowBlackman(0.16, N, i);\n    \n    return 2.0*wc * wnd * sinc(2.0*wc * float(i - N/2));\n}\n\n//FIR bandpass filter \n//Fa/Fb = Low/High cutoff freq., Fs = Sample freq., N = # of taps, i = Tap index\nfloat Bandpass(float Fa, float Fb, float Fs, int N, int i)\n{    \n    float wa = (Fa/Fs);\n    float wb = (Fb/Fs);\n    \n    float wnd = WindowBlackman(0.16, N, i);\n    \n    return 2.0*(wb-wa) * wnd * (sinc(2.0*wb * float(i - N/2)) - sinc(2.0*wa * float(i - N/2)));\n}\n\n//Complex oscillator, Fo = Oscillator freq., Fs = Sample freq., n = Sample index\nvec2 Oscillator(float Fo, float Fs, float N)\n{\n    float phase = (tau*Fo*floor(N))/Fs;\n    return vec2(cos(phase),sin(phase));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float Fs = iResolution.x;\n    float Fcol = Fs * F_COL;\n    float Fcolbw = Fs * F_COL_BW;\n    float Flumlp = Fs * F_LUMA_LP;\n    float n = floor(fragCoord.x);\n    \n    float y_sig = 0.0;    \n    float iq_sig = 0.0;\n    \n    vec2 cOsc = Oscillator(Fcol, Fs, n);\n\t\n    n += float(FIR_SIZE)/2.0;\n    \n    //Separate luma(Y) & chroma(IQ) signals\n    for(int i = 0;i < FIR_SIZE;i++)\n    {\n        int tpidx = FIR_SIZE - i - 1;\n        float lp = Lowpass(Flumlp, Fs, FIR_SIZE, tpidx);\n        float bp = Bandpass(Fcol - Fcolbw, Fcol + Fcolbw, Fs, FIR_SIZE, tpidx);\n        \n        y_sig += sample2D(iChannel0, iResolution.xy, vec2(n - float(i), fragCoord.y)).r * lp;\n        iq_sig += sample2D(iChannel0, iResolution.xy, vec2(n - float(i), fragCoord.y)).r * bp;\n    }\n    \n    //Shift IQ signal down from Fcol to DC \n    vec2 iq_sig_mix = cmul(vec2(iq_sig, 0), cOsc);\n    \n    fragColor = vec4(y_sig, iq_sig_mix, 0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}