{
    "Shader": {
        "info": {
            "date": "1540812362",
            "description": "pause time and drag mouse.\nexplanations are in the source code on the right:\n\ndoesn't have to be a race car\nbut it is a ((relatively) aperiodic) [hash1to16] core, if you want it to.",
            "flags": 0,
            "hasliked": 0,
            "id": "Xt3BDB",
            "likes": 11,
            "name": "pqfm aperiodic hash1to16 rainbow",
            "published": 3,
            "tags": [
                "noise",
                "moire",
                "ring",
                "goldenratio",
                "aperiodic",
                "discrepancy",
                "galois",
                "ratio",
                "hash161",
                "tiltmann",
                "tutte",
                "quadraticfield",
                "pqfm",
                "pfqfpm"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 1325
        },
        "renderpass": [
            {
                "code": "//tags:\n////quadraticfield,noise, moire, ring, rainbow, rainbow, field, hash, aperiodic, golden, galois, ratio, hash161, tiltmann, tutte\n\n//backwards compatibility woth imouse.zw fix, that does more than just abs()\nvec4 iMouseZwFix(vec4 m,bool NewCoke\n ){if(m.z>0.){ //while mouse down\n    if(m.w>0.)return m;//mouse was clicked in THIS     iFrame \n    else m.w=-m.w      //mosue was clicked in previous iFrame\n    //remember, MouseDrag advances the iFrame Count, even while paused !!\n ;}else{if(!NewCoke||m.w>0.)return m.xyxy; //OPTIONAL onMouseUp (fold or whatever)\n    m.zw=-m.zw;}\n  return m;}\n\n//self; https://www.shadertoy.com/view/Xt3BDB\n//noise,moire,ring,rainbow,goldenratio,aperiodic,discrepancy,galois,ratio,hash161,tiltmann,tutte,quadraticfield,nancarrow\n\n// just like the golden ratio (angle) evades self occlusion\n// and returns a unique angle of floor(N)*(sqrt(5.)*.5+-.5) foreach floor(N)\n// this matrix of [quadratic fields] with unique primes as factors\n// should return unique vectors foreach floor(N)\n// The period should be (at least?) as high as the factor of ALL used primes multiplied together.\n// the \"+.5+-.5\" part of phi is just an offset+scalar, that cna be deferred.\n// this boils a pqfm down to pointer*primeB*sqrt(primeA)*(.5+-.5)\n// summing up multiple of those, that share no prime factors, extends the period to the prime-factor-period (given enough float precision).\n// this is easily done by outerproduct() and other matrix-folding operations.\n\n//we always scale by irrationals (quadratic fields with unique prime factors) over time\n//, to maximize period lengths way over the address space that we can traverse/address\n\n// while [cos()] generates a smoother gradient of (repeating) vector DERIVATIVES,\n// a [triangle or seesaw wave over time] generates more equidistribution,\n// and a [costasArray over time factor] would even do nonRepeating derivatives.\n\n//this is [aperiodic within your address space], as you can always include one of these prime factors:\n//:   https://primes.utm.edu/lists/2small/\n//and then you have modulo arithmetic of miultuple very large primes within your address space.\n//and much faster than a bijection of a mersenne twister (and its inversed twist function)\n//\n//related audio to listen to while reading this code:\n//   https://www.youtube.com/watch?v=g0gNoELvpPo&list=RDLFz2lCEkjFk&index=4\n//\n//For something very quantified and aperiodic, a [costas array] is your best bet\n//but these are computationally complex in the O(n*n*n...)ish realm, OR need a small lookUpTable.\n//\n//for a fast and precise hash with a long quantified period, goto:\n// https://en.wikipedia.org/wiki/Permuted_congruential_generator\n//\n//this shader is (semi-)apeariodic for type float\n//a structure that claims ignorance on quantification.\n//its super fast, but not precise at all (if your primes vary too much in size)\n//\n//planck constants will mess up your pseudo-infinitely precise models/reciprocals.\n//and in the end any model of any reality is quantified, it includes a floor() function\n//any other model would require infinite amounts of energy\n//, and easily calculate the last digt of pi, just to lead that one ad absurdum\n//you must assert a reality that is quantified \n//  over one that is not quantified, the later gets you into [cosmic-horror]-territory\n//- that is inherently unfalsifiable, and therefore irrelevant.\n//- that is easily evaded by realizing how irrelevant and paranoid (and machavellian) any cosmic horror is.\n//\n//you may enjoy a VERY long period, like one of a [bijective mersenne twister] of \n//  http://libraryofbabel.info/\n//  https://www.youtube.com/watch?v=ji8pInOuGzQ\n//but the mersenne twister is obsoleted anbd very easily outperformed by any:\n//:  https://en.wikipedia.org/wiki/Permuted_congruential_generator\n\n//add some rasterization, useful for fm-synthesis, as notes tend to have a start and an end:\n#define Rasterize\n\n//turn it into a [fract(sin(a*43758.54))] hash\n#define MakeItNoisy\n\n//c.rgb*=c.rgb  ; adds saturation, and a mirror symmetry at time=0\n//#define extremify\n\n//no white/black extremism, moderate to grey/red/green/blue; c.rgb=normalize(c.rgb)\n//#define nameNormalizedXYZ\n\n\n//seniBlackbody adds nameNormalizedXYZ, before doing extremify, and then once more does nameNormalizedXYZ\n//#define seniBlackbody\n\n//above modes can be quite obfuscating\n//, might want to disable them to see what the basic function is, without extras\n    \n\n//se,iBlackbody, implies extremify and nameNormalizedXYZ\n#ifdef seniBlackbody\n #ifndef extremify\n  #define extremify\n #endif\n #ifndef nameNormalizedXYZ\n  #define nameNormalizedXYZ\n #endif\n#endif\n\n\n//todo memo:\n//sin() is used for infinite differential (with a period of mod(d,4) differentials)\n//Anyone should add a mode that toggles between sin() and seesaw() base wave (and some mixes)\n//, just like fm-synth-instruments.\n\n\n/*\niMouse.x scrolls time*time*time (quadratically, to scroll further)\n, which is confusing with larger rasterization\niMouse.y scales  time (linearily) == scales wavelength\n, equivalent to zooming in (but rasterization is unaffected)\n\noscillations (with different wavelengths) over time modify\n- rasterizazion between \"pixel perfect) and \"large raster\" (iResolution normalized)\n- a mix() of dual-permutations , generating the sum/average of 2 cosines\n- a mix() noisy with notNoisy\n*/\n\n\n\n\n\n//simpleton explanation to what this wants to do is;\n//   https://www.youtube.com/watch?v=QOtuX0jL85Y\n//hits the corner, in a 2d rectangle, likely in a regular interval over time, within 4k pixels\n//the below code does the same, but in up to 16 dimensions\n//it only hits the corner at time=0, and NEVER again.\n//we only need 3 dimensions for an \"infinite non-repeating rainbow\" aka \"golden ratio rainbow\"\n\n//but this code generalizes that to values other than 1.61 && 0.61, quadratic vields that share not prime factors:\n//but this code seems to do similar things as   https://www.shadertoy.com/view/4dcGR7\n\n//challenge: approximate blackbody-radiation with the apm() function, within aperiodic()\n\n/*\nas far as i can tell, ALL aperiodic functions are iterative, or use irrational values.\n- to be apear aperiodic; irerative aperiodics need infinite itertions \n- , or an identity for its infinite series\n- , or iterations till epsilon is smaller than a fragmentWidth.\n- to be apear aperiodic; irrational values need an infinite amount of bits to represent them precisely\n- , or as many bits to reach 1./min(iResolution)-precision\n- , so you chose your precision by the numbers of bits of your space.\n\ni think the top (iterative kaleidoscope) approach is much slower \nthan the bottom (quadratic field scaling) approach\n\nConcept: \n- define a matrix of quadratic fields q=(sqrt(floor(a))*floor(b)-floor(c))/2.  (the /2 contextualizes integer quadratics to phi) \n- define a 2d matrix of quadratic fields subset q=(sqrt(floor(a))-floor(c))/2. //because sqrt(2)*.5 and sqrt(3)*.5 are useful for (nosie) lattices.\n- its poartial dotproduct-folds should get good fast apparently aperiodic sequences.\n- - simple exmsple is; .5+.5*cos(time*vec3(1.,(sqrt(5.)-vec2(1,-1))/2)) for a \"golden rainbow\"\n- - but it seems that this generalizes for all [quadratic fields]\n- - as long as their values [a,b] do not share prime factors.\n\nthis includes [primality] and [fermats last theorem], with [binomial coeffiients]\n, to make something as aperiodic as possible:\nhttps://en.wikipedia.org/wiki/Quadratic_field\nhttps://www.youtube.com/watch?v=MIxvZ6jwTuA    (phi and metallic ratios\nhttps://www.youtube.com/watch?v=SsVl7_R2MvI    (utility of quadratic fields (for primality) )\nhttps://www.youtube.com/watch?v=HvMSRWTE2mI    (aks-primality-test touches on NoverK and fermats last theorem)\nhttps://www.shadertoy.com/view/4sjfz1        (calculates NoverK(32,32) )\n\na\nhttps://en.wikipedia.org/wiki/Unique_factorization_domain\nof the\nhttps://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic\nof an\nhttps://en.wikipedia.org/wiki/Irreducible_ring\nwith a long [tiltman break]\nhttps://www.youtube.com/watch?v=-hrNWRtDr7Y\nhttps://billtuttememorial.org.uk/codebreaking/the-tiltman-break/\n*/\n\n//2d zoom\n#define ViewZoom 3.\n//divide by/aa for hairline drawing and sharp smoothstep()\n#define Aa (min(iResolution.x,iResolution.y)/ViewZoom)\n#define fra(u)(u-.5*iResolution.xy)*ViewZoom/iResolution.y//usually first function of mainImage(),not typecast.\n\n\n#define vec1 float\n#define pi acos(-1.)\n#define tau pi*2.\n//float tau=6.2831853071795864769252867665590057683943387987502116419;//trig definition can be better for smarter compilers.\n#define eul 2.7182818284590452353602874713526624977572470936999595749\n//eul=exp(1.)???\n//\"goldenRatio\"=phi+1=Phi :where: 1/phi=phi-1&&1/Phi=Phi-1\n//https://en.wikipedia.org/wiki/Golden_ratio\n#define phi (sqrt(5.)*.5-.5)\n//goldenRatio is great fun with fract(),good for hashes.\n#define Phi (sqrt(5.)*.5+.5)\n#define sat(x)clamp(x,0.,1.)\n#define dd(a)dot(a,a)\n#define u5(a)((a)*.5+.5)\n#define u2(a)((a)*2.-1.)\n//#define ss(a,u)smoothstep(a,-a,u)//bad namespace for this,more trouble than its worth\nvec1 suv(vec4 a){return dot(vec4(1),a);}vec1 suv(vec3 a){return dot(vec3(1),a);}vec1 suv(vec2 a){return a.x+a.y;}//sum of vector\n#define minx(a,b)mix(b,a,step(a.x,b.x))\n#define manx(a,b)mix(a,-b,step(a.x,-b.x))\n#define maxx(a,b)-minx(-a,-b)\n\n\n//there is no sqrt(mat4()) in opengl, What the hell?\nmat4 sq(mat4 a){return mat4(sqrt(a[0]),sqrt(a[1]),sqrt(a[2]),sqrt(a[3]));}\n//innerproduct(a,b) == dot(a,b) \n//outerproduct(c,d) == https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/outerProduct.xhtml\nmat4 apm(vec4 a,vec4 b\n){return sq(outerProduct(a,vec4(1)))//primes of comumns set \n           +outerProduct(vec4(1),b) //rows\n ;}\n//this if a and b contain only unique prime factors\n//apm() returns unique scalars of quadratic-fields of the form\n//b*sqrt(a)  ~= floor(b)*(sqrt(floor(a))*.5+-.5) \n//, where the [*.5+.5] scaling+ offset is optionally deferred/ommitted or replaced by trigonometry for better continuity)\n//[b] is just like a scalar, that acts like a hash-salt.\n//just like (*.5+-.5) is just like a scalar (and offset).\n\n//below is just an example for good inputs on the above (should not share prime factors)\nmat4 apm(){return apm(vec4(1,3,5,7),vec4(0,1,11,4294967295));}//+-4294967295 is largest 32bit signed int.\n//exmaple params, should not share prime factors, can also be 0 or 1\n//I included \"1\" on both vectors, to include 2.*Phi=2.*1.61\n//this one is basically a LUT with a lot of common lattices (scaled by *=2)\n//I included \"0\" to include all the roots, without offsets.\n\n//apm() functions as a (seed for) a hash with 1 input (time) \n//and 16 outputs , whos differentials (between any 2 of the 16 domains) never repeat (over input/time)\n//useful for a fract(sin(a)) hash, but here visualized as sin(a-fract(a)), for explicit raterization.\n\n//aperiodicOscillator() has an apparent periodicity with relative short period \n//- see where the sequence \"white to black\" repeats\n//but if you take a screenshot of 2 of these apparent periods you will notice\n//that there is a significant phase-shift trough them, ie they are NOT periodic!\nvec4 aperiodicOscillator(vec2 u\n){mat4 a=apm()\n ;u=fra(u)\n ;vec2 m=vec2(0)\n ;vec2 v=u//unscaled m for a mouse currsor in screenspace and unscaled context\n ;float t=iTime*.2\n ;vec4 mouse=iMouseZwFix(iMouse,true)\n ;if(iMouse.z>0.)m=fra(mouse.xy);else m=vec2(-cos(t),cos(t*1.61))*1.5*vec2(iResolution.x/iResolution.y,1)\n ;//i tries to do seesaw wave instead ofcos() but its scaling aint that easy, cos() has better derivative-continuity anyways.\n ;vec4 c=vec4(1) \n #ifdef Rasterize\n ;float rasster=mix(32.,1.,.5+.5*sin(iTime*.1*a[1][3]))\n ;u.x=floor(u.x*rasster*iResolution.x/256.)/rasster//optionally rasterize to [...(a-fract(a))]==[...(floor(a))]\n        //, to emphazite aperiodicity within a coarser raster.\n        //, with all its; https://www.shadertoy.com/results?query=moire\n        //   and all its; https://www.shadertoy.com/results?query=galois\n #endif\n ;float n=m.x*iResolution.x/800.//*iResolution.x\n ;if(m.y==0.)m.y=0.00001//lazy div0 evasion\n ;u.x=(u.x-n*n*n)/m.y//scroll mouse, with quadratic exponential difference.\n //play with the parameters of the matrix-pointers, it all should work similarily!\n //smaller numbers should address smaller \"primes\"\n ;c.x=sin(u.x*a[0][0])\n ;c.y=sin(u.x*a[0][1])\n ;c.z=sin(u.x*a[1][0])\n ;c.w=sin(u.x*a[1][1])//a hash161() would tap all 16 fields of a==mat4()\n #ifdef MakeItNoisy\n ;//c=      fract(c*43758.54)*2.-1.    //optionally turn into a fract(sin(...)) hash\n ;c=mix(fract(c*43758.54)*2.-1.,c,.5+.5*(cos(iTime/3.))) //..same. socillating over time\n     //43758=2*3*3*3*11*13*17, with offset +0.54 is famous for fract(sin(a)) hashing\n     \n #endif\n\n #ifdef seniBlackbody\n ;c.xyz=normalize(c.xyz*.5+.5)*2.-1.\n #endif\n #ifdef extremify\n ;c.xyz=c.xyz*c.xyz*2.-1.\n #endif\n #ifdef nameNormalizedXYZ\n ;c.xyz=normalize(c.xyz*.5+.5)*2.-1.\n #endif\n     \n\n     \n  /*\n  ;c.x=sin(u.x*a[0][0])\n ;c.y=sin(u.x*a[0][3])\n ;c.z=sin(u.x*a[3][0])//seems flatter here, must be 32bit interferrence with pow(2,32-1)\n ;c.w=sin(u.x*a[3][3])\n*/\n /* //sillier mixing (very different primes\n ;c.x=sin(u.x*a[1][0])\n ;c.y=sin(u.x*a[2][2])\n ;c.z=sin(u.x*a[0][2])\n ;c.w=sin(u.x*a[3][1])*/\n ;//c=  (c.xyzw-c.yzwx)*.5//optional permuted (scaled) differential of 2 curces.\n ;c=mix((c.xyzw+c.yzwx)*.5,c,.5+.5*cos(iTime)) //mix the above with NOT the above, over time\n ;if(abs(u.y)<.4*ViewZoom //upper view shows f(x) curve\n ){\n  ;c-=u.y\n  ;c=abs(c)\n  ;c-=.1\n  ;c=smoothstep(.1,-.1,c)\n ;}else{//lower view shoows \"rainbow gradient\"\n  ;c=c*.5+.5\n ;}\n  \n  ;//c.xy+=c.w*.3 //optionally folds .w to yellow\n ;c.xy+=smoothstep(.01,-.01,abs(length(v-m)-.1)-.02)\n ;return c;\n ;}\n\nvoid mainImage( out vec4 o, in vec2 u\n){o=aperiodicOscillator(u)\n ;}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}