{
    "Shader": {
        "info": {
            "date": "1474868162",
            "description": "Multinoise Pattern Which Makes Real Stuff",
            "flags": 0,
            "hasliked": 0,
            "id": "4tyGDm",
            "likes": 0,
            "name": "Noise Pattern",
            "published": 3,
            "tags": [
                "random",
                "multinoise"
            ],
            "usePreview": 0,
            "username": "Imsure1200q_1UWE130",
            "viewed": 595
        },
        "renderpass": [
            {
                "code": "float pi = asin(1.)*2.;\nstruct gather\n{\n    vec4 r4;\n    vec3 r3;\n    vec2 r2;\n};\nvec3 start(vec3 i)\n{\n    i += i * i;\n    float x = length(i.x)+i.y*i.z;\n    float y = length(i.y)+i.z*i.x;\n    float z = length(i.z)+i.x*i.y;\n    i = vec3(x,y,z);\n    return i;\n}\nfloat rand( vec2 p )\n{\n    return fract(sin(dot(p, vec2(127.1,311.7)))*43758.5453123);\n}\nfloat rand( vec3 p )\n{\n    return fract(sin(dot(p, vec3(127.1, 311.7, 496.3)))*43758.5453123);\n}\nfloat rand( vec4 p )\n{\n    return fract(sin(dot(p, vec4(127.1, 311.7, 496.3, 680.9)))*43758.5453123);\n}\nvec2 rvec2( vec2 p )\n{\n    vec2 res;\n    for(float i = 0.0; i < 2.0; i++)\n    {\n        float x = rand(vec2(p.x, i));\n        float y = rand(vec2(p.y, i));\n        res += vec2(x, y);\n    }\n    return res;\n}\nvec3 rvec3( vec3 p )\n{\n    vec3 res;\n    for(float i = 0.0; i < 3.0; i++)\n    {\n        float x = rand(vec2(p.x, i));\n        float y = rand(vec2(p.y, i));\n        float z = rand(vec2(p.z, i));\n        res += vec3(x, y, z);\n    }\n    return res;\n}\nvec4 rvec4( vec4 p )\n{\n    vec4 res;\n    for(float i = 0.0; i < 4.0; i++)\n    {\n        float x = rand(vec2(p.x, i));\n        float y = rand(vec2(p.y, i));\n        float z = rand(vec2(p.z, i));\n        float w = rand(vec2(p.w, i));\n        res += vec4(x, y, z, w);\n    }\n    return res;\n}\ngather stuff(vec4 x, vec3 y, vec2 z)\n{\n    vec4 x2 = rvec4(x);\n    vec3 y2 = rvec3(y);\n    vec2 z2 = rvec2(z);\n    return gather(x2, y2, z2);\n}\nfloat compile(gather p, vec3 col)\n{\n    vec4 a = p.r4;\n    vec3 b = p.r3;\n    vec2 c = p.r2;\n    vec4 a2 = a;\n    vec3 b2 = b;\n    vec2 c2 = c;\n    //compile color\n    a2.x -= b.x - c.x;\n    a2.y -= b.y - c.y;\n    a2.z -= b.z;\n    a2.w -= b.z;\n    \n    //compile object\n    b2.x -= c.x - a.x;\n    b2.y -= c.y - a.y;\n    b2.z -= a.z;\n    \n    //compile locaion\n    c2.x -= a.x - b.x;\n    c2.y -= a.y - b.y;\n    \n    //return the length of them.\n    return length((b2-vec3(a2.x+col.x,a2.y+col.y,a2.z+col.z))+vec3(c2, 1.0));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 IGR = vec4(length(uv*2.0-1.0)-1.0)-max(max(uv.x, fragCoord.x),max(uv.y, fragCoord.y));\n    vec3 IGF = start(normalize(vec3(uv, iResolution.z)));\n    vec2 IGC = uv / iResolution.xy;\n    gather arc = stuff(IGR, IGF, IGC);\n    float fog = compile(arc, vec3(length(uv*2.0-1.0)-1.0-cos(uv.y)));\n\tfragColor = vec4(sqrt(fog/32.0/length(sqrt(uv*2.0-1.0))));\n    fragColor += vec4((length(uv*2.0-1.0)-1.0)-(length(uv*2.0-1.0)-1.1));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}