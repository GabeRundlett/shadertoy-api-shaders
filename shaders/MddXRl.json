{
    "Shader": {
        "info": {
            "date": "1460997958",
            "description": "An extension of the well-known Game of Life cellular automata; see the source for details.",
            "flags": 32,
            "hasliked": 0,
            "id": "MddXRl",
            "likes": 16,
            "name": "Generalized Life",
            "published": 3,
            "tags": [
                "interactive",
                "cellularautomata"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 1996
        },
        "renderpass": [
            {
                "code": "// \"Generalized Life\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  An extension of the well-known \"Game of Life\" cellular automata. Here a much\n  larger set of neighbor cells (a 13x13 square) are examined to determine\n  whether a cell is born, stays alive, or dies.\n\n  The left pair of sliders set the lower and upper limits to the percentage of\n  living neighbors for which a cell is born. The right sliders determine the\n  living neighbor range for which a cell remains alive.\n\n  The pushbutton restarts the system in a random (50% alive) state (necessary\n  if all cells are dead). More interesting behavior generally appears if the sliders\n  are altered without restarting.\n\n  The cycling color shows when cells were born.\n\n  Size of cell array depends on display size.\n*/\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nfloat gSize;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, gSize), floor (fi / gSize)) + 0.5) /\n     txSize);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nfloat DigSeg (vec2 q)\n{\n  return (1. - smoothstep (0.13, 0.17, abs (q.x))) *\n     (1. - smoothstep (0.5, 0.57, abs (q.y)));\n}\n\nfloat ShowDig (vec2 q, int iv)\n{\n  float d;\n  int k, kk;\n  const vec2 vp = vec2 (0.5, 0.5), vm = vec2 (-0.5, 0.5), vo = vec2 (1., 0.);\n  if (iv < 5) {\n    if (iv == -1) k = 8;\n    else if (iv == 0) k = 119;\n    else if (iv == 1) k = 36;\n    else if (iv == 2) k = 93;\n    else if (iv == 3) k = 109;\n    else k = 46;\n  } else {\n    if (iv == 5) k = 107;\n    else if (iv == 6) k = 122;\n    else if (iv == 7) k = 37;\n    else if (iv == 8) k = 127;\n    else k = 47;\n  }\n  q = (q - 0.5) * vec2 (1.7, 2.3);\n  d = 0.;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.yx - vo);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.xy - vp);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.xy - vm);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.yx);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.xy + vm);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.xy + vp);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.yx + vo);\n  return d;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (min (q.x, q.y) >= 0. && max (q.x, q.y) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    nDig = (val > 0.) ? floor (max (log (val) / log (10.), 0.) + 0.001) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (sgn < 0.) {\n      if (idChar == mxChar - nDig - 1.) s = ShowDig (q, -1);\n      else ++ v;\n    }\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n\nvec3 ShowWg (vec2 uv, vec2 canvas, vec3 col, vec4 limVar)\n{\n  vec4 wgBx[5];\n  vec3 cc;\n  vec2 ut, ust;\n  float vW[4], asp;\n  asp = canvas.x / canvas.y;\n  wgBx[0] = vec4 (-0.45 * asp, 0., 0.012 * asp, 0.18);\n  wgBx[1] = vec4 (-0.35 * asp, 0., 0.012 * asp, 0.18);\n  wgBx[2] = vec4 ( 0.35 * asp, 0., 0.012 * asp, 0.18);\n  wgBx[3] = vec4 ( 0.45 * asp, 0., 0.012 * asp, 0.18);\n  wgBx[4] = vec4 ( 0.4 * asp, -0.4, 0.015 * asp, 0.);\n  vW[0] = limVar.x;\n  vW[1] = limVar.y;\n  vW[2] = limVar.z;\n  vW[3] = limVar.w;\n  for (int k = 0; k < 4; k ++) {\n    cc = (k < 2) ? vec3 (0.3, 0.3, 1.) : vec3 (1., 0.2, 0.2);\n    ut = 0.5 * uv - wgBx[k].xy;\n    ust = abs (ut) - wgBx[k].zw * vec2 (0.7, 1.);\n    if (max (ust.x, ust.y) < 0.) {\n      if  (min (abs (ust.x), abs (ust.y)) * canvas.y < 2.) col = vec3 (0.3);\n      else col = (mod (0.5 * ((0.5 * uv.y - wgBx[k].y) / wgBx[k].w - 0.99), 0.1) *\n         canvas.y < 6.) ? vec3 (1., 1., 0.) : vec3 (0.6);\n    }\n    ut.y -= (vW[k] - 0.5) * 2. * wgBx[k].w;\n    ut = abs (ut) * vec2 (1., 2.);\n    if (length (ut) < 0.03 && max (ut.x, ut.y) > 0.007) col = cc;\n    col = mix (col, cc, ShowInt (0.5 * uv - (wgBx[k].xy + wgBx[k].zw) * vec2 (1., -1.) -\n        vec2 (0.0045, -0.06), 0.028 * vec2 (asp, 1.), 2.,\n        clamp (floor (100. * vW[k]), 1., 99.)));\n  }\n  if (length (0.5 * uv - wgBx[4].xy) < wgBx[4].z) {\n    col = (length (0.5 * uv - wgBx[4].xy) < 0.7 * wgBx[4].z) ?\n       vec3 (1., 1., 0.) : vec3 (1., 0.2, 0.2);\n  }\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat, limVar;\n  vec3 col;\n  vec2 canvas, uv, ut, gPos;\n  float c;\n  int gSizeSq;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  gSize = (canvas.y > 512.) ? 512. : (canvas.y > 200.) ? 256. : 32.;\n  gSizeSq = int (gSize * gSize);\n  stDat = Loadv4 (0);\n  stDat = Loadv4 (1);\n  limVar.xy = stDat.zw;\n  stDat = Loadv4 (2);\n  limVar.zw = stDat.zw;\n  ut = abs (uv) - vec2 (1.);\n  if (max (ut.x, ut.y) > 0.) {\n    col = ShowWg (uv, canvas, vec3 (0.82), limVar);\n  } else {\n    gPos = floor (gSize * (0.5 * uv + 0.5));\n    c = Loadv4 (int (gSize * gPos.y + gPos.x)).x;\n    if (c >= 0.) col = HsvToRgb (vec3 (c, 0.8, 1.));\n    else col = vec3 (0.1);\n  }\n  fragColor = vec4 (col, 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Generalized Life\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 cLims;\nfloat tCur, gSize, fColr;\nconst float pi = 3.14159;\nconst float nebEdgeH = 6.;\n\nfloat Hashff (float p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (p) * cHashM);\n}\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, gSize), floor (fi / gSize)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  float fi = float (idVar);\n  vec2 d = abs (fCoord - vec2 (mod (fi, gSize), floor (fi / gSize)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n\nfloat Step (int sId)\n{\n  vec2 sv;\n  float c, cn, cSum, py;\n  c = Loadv4 (sId).x;\n  sv = vec2 (mod (float (sId), gSize), floor (float (sId) / gSize));\n  cSum = 0.;\n  for (float iy = - nebEdgeH; iy <= nebEdgeH; iy ++) {\n    py = gSize * mod (sv.y + iy, gSize);\n    for (float ix = - nebEdgeH; ix <= nebEdgeH; ix ++) {\n      if (Loadv4 (int (mod (sv.x + ix, gSize) + py)).x >= 0.) ++ cSum;\n    }\n  }\n  cn = c;\n  if (c < 0.) {\n    if (cSum >= cLims.x && cSum <= cLims.y) cn = fColr;\n  } else {\n    if (cSum < cLims.z || cSum > cLims.w) cn = -1.;\n  }\n  return cn;\n}\n\nfloat Init (int sId)\n{\n  return (Hashff (mod (17777.7 * float (sId + 10) + 999. * tCur,\n     2. * pi)) > 0.5) ? 0. : -1.;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 wgBx[5], stDat, mPtr, mPtrP, limVar;\n  vec2 iFrag, canvas, ust;\n  float asp, vW, c, nColr, nStep, stSkip;\n  int pxId, wgSel, wgReg, gSizeSq, kSel;\n  bool doInit;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  gSize = (canvas.y > 512.) ? 512. : (canvas.y > 200.) ? 256. : 32.;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + gSize * iFrag.y);\n  gSizeSq = int (gSize * gSize);\n  if (iFrag.x >= gSize || pxId >= gSizeSq) discard;\n  doInit = false;\n  wgSel = -1;\n  wgReg = -2;\n  if (iFrame <= 5) {\n    mPtrP = mPtr;\n    nColr = 16.;\n    limVar = vec4 (0.2, 0.4, 0.2, 0.4);\n    doInit = true;\n  } else {\n    stDat = Loadv4 (0);\n    nStep = stDat.y;\n    nColr = stDat.z;\n    wgSel = int (stDat.w);\n    stDat = Loadv4 (1);\n    limVar.xy = stDat.zw;\n    stDat = Loadv4 (2);\n    limVar.zw = stDat.zw;\n    stDat = Loadv4 (3);\n    mPtrP = vec4 (stDat.yzw, 0.);\n  }\n  asp = canvas.x / canvas.y;\n  if (mPtr.z > 0.) {\n    wgBx[0] = vec4 (-0.45 * asp, 0., 0.012 * asp, 0.18);\n    wgBx[1] = vec4 (-0.35 * asp, 0., 0.012 * asp, 0.18);\n    wgBx[2] = vec4 ( 0.35 * asp, 0., 0.012 * asp, 0.18);\n    wgBx[3] = vec4 ( 0.45 * asp, 0., 0.012 * asp, 0.18);\n    wgBx[4] = vec4 ( 0.4 * asp, -0.4, 0.015 * asp, 0.);\n    for (int k = 0; k < 4; k ++) {\n      ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx[k].xy) - wgBx[k].zw;\n      if (max (ust.x, ust.y) < 0.) wgReg = k;\n    }\n    if (length (mPtr.xy * vec2 (asp, 1.) - wgBx[4].xy) < wgBx[4].z) wgReg = 4;\n    if (mPtrP.z <= 0.) wgSel = wgReg;\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n  }\n  if (wgSel >= 0) {\n    if (wgSel < 4) {\n      for (int k = 0; k < 4; k ++) {\n        if (wgSel == k) {\n          kSel = k;\n          vW = clamp (0.5 + 0.5 * (mPtr.y - wgBx[k].y) / wgBx[k].w, 0.01, 0.99);\n          break;\n        }\n      }\n      if      (kSel == 0) limVar.x = min (vW, limVar.y);\n      else if (kSel == 1) limVar.y = max (vW, limVar.x);\n      else if (kSel == 2) limVar.z = min (vW, limVar.w);\n      else if (kSel == 3) limVar.w = max (vW, limVar.z);\n    } else if (wgSel == 4) doInit = (mPtrP.z <= 0.);\n  }\n  cLims = floor (limVar * (2. * nebEdgeH + 1.) * (2. * nebEdgeH + 1.));\n  stSkip = 6.;\n  fColr = mod (nStep / stSkip, nColr) / nColr;\n  if (doInit) {\n    nStep = 0.;\n    c = Init (pxId);\n  } else {\n    ++ nStep;\n    if (mod (nStep, stSkip) == 0.) c = Step (pxId);\n    else c = Loadv4 (pxId).x;\n  }\n  stDat = vec4 (c, 0., 0., 0.);\n  if      (pxId == 0) stDat.yzw = vec3 (nStep, nColr, float (wgSel));\n  else if (pxId == 1) stDat.yzw = vec3 (0., limVar.xy);\n  else if (pxId == 2) stDat.yzw = vec3 (0., limVar.zw);\n  else if (pxId == 3) stDat.yzw = mPtr.xyz;\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}