{
    "Shader": {
        "info": {
            "date": "1609407005",
            "description": "A raymarched ball :)",
            "flags": 0,
            "hasliked": 0,
            "id": "3l3yD7",
            "likes": 7,
            "name": "Layers ball",
            "published": 3,
            "tags": [
                "raymarching",
                "antialiasing",
                "mod"
            ],
            "usePreview": 0,
            "username": "z0rg",
            "viewed": 257
        },
        "renderpass": [
            {
                "code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n// I used to develop it on my smartphone with ShaderEditor app\n// I just tweaked it to add a bit of antialising\n\nvec4 ppoo = vec4(1.0,1.0,0.0,0.0);\nvec4 EPS = vec4(0.01,0.0,0.0,0.0);\nfloat PI = 3.1415927;\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c);}\n\n#define sat(a) clamp(a, 0., 1.)\n\nvec3  _repeat(vec3 p, vec3 sp)\n{\n  return mod(p,sp)-0.5*sp;\n}\n\nfloat sdf_sph(vec3 p, float r)\n{\n  return length(p)-r;\n}\n\nfloat sdf_rect(vec3 p, vec3 sz)\n{\n  vec3 diff = abs(p)-sz;\n  return max(diff.x, max(diff.y,diff.z));\n}\n\nvec3 lookAt(vec3 dir, vec2 uv)\n{\n  dir = normalize(dir);\n  vec3 right = cross(dir, ppoo.xzx);\n  vec3 up = cross(dir, right);\n\n  return dir+right*uv.x+up*uv.y;\n}\n\nfloat map(vec3 p)\n{\n  float s = sdf_sph(p,3.0);\n  float ss = sdf_sph(p,3.5);\n  p+= ppoo.zxz*sin(iTime*0.2)*4.0;\n  p= _repeat(p, vec3(2));\n  float tranche = max(sdf_rect(p, vec3(10,0.5,10)),ss);\n  return min(s,tranche);\n}\n\nvec3 normal(vec3 p)\n{\n  return vec3(map(p+EPS.xyy)-map(p-EPS.xyy),\n    map(p+EPS.yxy)-map(p-EPS.yxy),\n    map(p+EPS.yyx)-map(p-EPS.yyx));\n}\n\nvec3 rdr(vec2 uv)\n{\n  vec3 p;\n  int steps = 256;\n  float maxD = 20.0;\n  vec3 pos;\n  float totD;\n  float r = 10.0;\n  vec3 orig = vec3(0.0,r*cos(1.0),r*sin(1.0));\n  vec3 dir = lookAt(vec3(0.0)-orig,uv);\n  p = orig;\n  for (int i = 0; i< steps&&totD <maxD;++i)\n  {\n    float d = map(p);\n    p += dir*d;\n    totD += d;\n    if (d < EPS.x)\n    {\n      vec3 norm = normalize(normal(p));\n      float isFlat = dot(abs(norm),ppoo.zxz);\n      if (isFlat + EPS.x>1.0)\n         return vec3(0.93,0.11,0.78);//0.5*norm +0.5;\n      vec3 light = vec3(-5,10.0*sin(iTime),10);\n      vec3 ldir = normalize(light-p);\n      vec3 h = normalize(dir+ldir);\n      vec3 lcol = vec3(0.67,0.56,0.68)*2.0;\n      return vec3(0.1,0.1,0.15)+lcol*pow(sat(dot(ldir,norm)),95.0)+pow(sat(dot(norm,h)),2.0)*lcol;\n    }\n  }\n  return vec3(-1.0);\n}\n\nvec3 rdrMain(vec2 uv)\n{\n  vec2 ntouch = 0.5*vec2(sin(iTime*0.4),cos(iTime*0.3));\n  float factCirc = float(1.0-float(sat(length(uv-ntouch)*5.5)));\n  uv -= factCirc*normalize(uv)*pow(length(uv),0.1)*0.5;\n  uv *= 2.0;\n  vec3 col = rdr(uv);\n  float isScene = float(col.x < 0.0);\n  col = sat(col);\n  float lstp = PI*0.2;\n  float hlstp = lstp*0.5;\n  float lines = mod(atan(uv.y,uv.x)+iTime*0.3,lstp);\n  float coef = float(lines < hlstp);\n  vec3 colLines =pow(length(uv)*2.0,0.5)*mix(vec3(0.53,0.64,0.89), vec3(0.1),coef);\n  col = mix(col, colLines, isScene);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xx;\n  vec2 center = vec2(0.5)*iResolution.xy/iResolution.xx;\n  uv = uv - center;\n\n    vec3 col = rdrMain(uv);\n    \n        \n    float diff = pow(fwidth(col.z), .6);\n    //if (diff > 0.3) // No need to the shader is light enough to avoid it \n    { // Not so cheap antialiasing SSAA x4\n        //col = vec3(1.,0.,0.); // debug\n        vec2 off = vec2(1., -1.)/(iResolution.x*2.);\n        vec3 acc = col;\n        // To avoid too regular pattern yielding aliasing artifacts\n        mat2 rot = r2d(uv.y*5.); // a bit of value tweaking, appears to be working well\n        acc += rdrMain(uv-off.xx*rot);\n        acc += rdrMain(uv-off.xy*rot);\n        acc += rdrMain(uv-off.yy*rot);\n        acc += rdrMain(uv-off.yx*rot);\n        col = acc/5.;\n    }\n    \n  fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}