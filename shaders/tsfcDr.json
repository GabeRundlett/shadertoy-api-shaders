{
    "Shader": {
        "info": {
            "date": "1584549679",
            "description": "The Nine Point Circle and Euler Line",
            "flags": 0,
            "hasliked": 0,
            "id": "tsfcDr",
            "likes": 7,
            "name": "Nine Point Circle and Euler Line",
            "published": 3,
            "tags": [
                "circle",
                "eulerline",
                "ninepoint"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 394
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// The Nine Point Circle & Euler Line\n// Matthew Arcus, 2020.\n//\n// The feet of the altitudes, the midpoints between the orthocentre and the\n// vertices, and the midpoints of the sides, all lie on a circle.\n//\n// The centre of the nine-point circle, the circumcentre, the centroid and\n// the orthocentre are collinear and lie on the Euler line.\n//\n// Mouse controls vertex P of the triangle\n//\n////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////\n//\n// Geometric constructions\n//\n// Homogeneous coordinates used throughout (so the lines and points are\n// \"projective\"):\n// (x,y,z) represents the point (x/z,y/z) for z != 0\n// (x,y,0) represents a \"point at infinity\" which acts like a direction.\n// (a,b,c) represents the line ax + by + cz = 0\n// (0,0,c) represents the \"line at infinity\"\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// The line between two projective points, or the intersection of two\n// projective lines, is just their cross product.\nvec3 join(vec3 p, vec3 q) {\n  return cross(p,q);\n}\n\n// The midpoint between p and q (also conjugate with point at infinity)\nvec3 midpoint(vec3 p, vec3 q) {\n  return p*q.z + p.z*q;\n}\n\nfloat distance2(vec3 p, vec3 q) {\n  p /= p.z; q /= q.z;\n  return abs(dot(p-q,p-q));\n}\n\n// Perpendicular bisector (a line)\nvec3 bisector(vec3 p,vec3 q) {\n  // (p-r).(p-r) = (q-r).(q-r) // r equidistant from p and q\n  // pp - 2pr + rr = qq - 2qr + rr\n  // pp - qq = 2pr - 2qr\n  // 2r.(p-q) = pp - qq\n  p /= p.z; q /= q.z;\n  return vec3(2.0*(p.xy-q.xy),dot(q,q)-dot(p,p));\n}\n\n// Drop perpendicular from p onto line q.\nvec3 perpendicular(vec3 p, vec3 q) {\n  // (p + kq.xy).q = 0\n  // p.q + k(q.yx).q = 0\n  float k = dot(p,q)/dot(q.xy,q.xy);\n  return p - k*vec3(q.xy,0);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Distance functions\n////////////////////////////////////////////////////////////////////////////////\n\nfloat point(vec3 p, vec3 q) {\n  float pz = p.z, qz = q.z;\n  p *= qz; q *= pz;\n  return distance(p,q)/abs(p.z);\n}\n\nfloat line(vec3 p, vec3 q) {\n  return abs(dot(p,q)/(p.z*length(q.xy)));\n}\n\nfloat line(vec3 p, vec3 q, vec3 r) {\n  return line(p,join(q,r));\n}\n\nfloat segment(vec3 p, vec3 q, vec3 r) {\n  p /= p.z; q /= q.z; r /= r.z; // normalize\n  vec3 pa = p-q;\n  vec3 ba = r-q;\n  float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n  float d = length(pa-h*ba);\n  return d;\n}\n\nfloat conic(vec3 p, mat3 m) {\n  float s = dot(p,m*p);\n  vec3 ds = 2.0*m*p; // Gradient\n  return abs(s/(p.z*length(ds.xy))); // Normalize for Euclidean distance\n}\n\nfloat circle(vec3 p, vec4 c) {\n  // (x-a)^2 + (y-b)^2 = r^2\n  // x2 -2ax + a2 + y2 -2by + b2 -r2 = 0\n  vec3 q = c.xyz;\n  float r2 = c.w;\n  q /= q.z;\n  return conic(p,mat3(1,0,-q.x,\n                      0,1,-q.y,\n                     -q.x,-q.y,dot(q.xy,q.xy)-r2));\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Drawing functions\n////////////////////////////////////////////////////////////////////////////////\n\nvoid getmin(inout float d, inout int index, int i, float t) {\n  if (t < d) { d = t; index = i; }\n}\n\nvec3 colors[] =\n  vec3[](vec3(1,0,0),\n         vec3(1,1,0),\n         vec3(0,0,1),\n         vec3(0,1,0),\n         vec3(0,1,1),\n         vec3(0.8),\n         vec3(1,0,1),\n         vec3(1,1,1)\n         );\n\nvec3 getcol(int i) {\n  return colors[i];\n}\n\nvec3 diagram(vec3 p, vec3 P) {\n  vec3 pcol = vec3(0.3);\n  float lwidth = 0.005;\n  float dwidth = 1.5*fwidth(p.x/p.z);\n  float pwidth = 0.03;\n  // The triangle (P is parameter)\n  vec3 Q = vec3(-1.5,-0.5,1);\n  vec3 R = vec3(1,-1,1);\n  // Bisectors of the sides\n  vec3 bP = bisector(Q,R);\n  vec3 bQ = bisector(R,P);\n  vec3 bR = bisector(P,Q);\n  // Intersect at the circumcentre\n  vec3 O = join(bP,bQ);\n  // centre of the circumcircle.\n  vec4 C1 = vec4(O,distance2(O,P));\n  // The sides of the triangle\n  vec3 sP = join(Q,R);\n  vec3 sQ = join(R,P);\n  vec3 sR = join(P,Q);\n  // The altitudes\n  vec3 aP = perpendicular(P,sP);\n  vec3 aQ = perpendicular(Q,sQ);\n  vec3 aR = perpendicular(R,sR);\n  // orthocentre (intersection of altitudes).\n  vec3 H = join(join(P,aP),join(Q,aQ));\n  // The nine point centre..\n  vec3 C = join(bisector(aP,aQ),bisector(aQ,aR));\n  // ..and circle\n  vec4 C2 = vec4(C,distance2(C,aP));\n  // G is the centroid\n  vec3 mP = midpoint(Q,R); // Midpoint of side\n  vec3 mQ = midpoint(R,P);\n  vec3 mR = midpoint(P,Q);\n  vec3 G = join(join(P,mP),join(Q,mQ));\n\n  float d = 1e8;\n  int index = -1;\n  // Sides\n  getmin(d,index,0,line(p,P,Q));\n  getmin(d,index,0,line(p,Q,R));\n  getmin(d,index,0,line(p,P,R));\n  // Bisectors\n  getmin(d,index,1,line(p,bP));\n  getmin(d,index,1,line(p,bQ));\n  getmin(d,index,1,line(p,bR));\n  // Circumcircle and nine-point circle\n  getmin(d,index,2,circle(p,C1));\n  getmin(d,index,2,circle(p,C2));\n  // The altitudes\n  getmin(d,index,3,line(p,P,aP));\n  getmin(d,index,3,line(p,Q,aQ));\n  getmin(d,index,3,line(p,R,aR));\n  // The lines intersecting at the centroid\n  getmin(d,index,4,line(p,P,mP));\n  getmin(d,index,4,line(p,Q,mQ));\n  getmin(d,index,4,line(p,R,mR));\n\n  // The Euler line\n  getmin(d,index,5,segment(p,H,O));\n\n#if 0\n  // Orthic triangle\n  getmin(d,index,6,segment(p,aP,aQ));\n  getmin(d,index,6,segment(p,aQ,aR));\n  getmin(d,index,6,segment(p,aR,aP));\n#endif\n\n  //vec3 bgcolor = 0.1*vec3(0.75,0.25,1); //vec3(1,1,0.8);\n  vec3 col = vec3(1,1,0.8);  \n  col = mix(0.9*getcol(index),col,smoothstep(lwidth,lwidth+dwidth,d));\n  d = 1e8;\n  getmin(d,index,0,point(p,O));\n  getmin(d,index,0,point(p,H));\n\n  getmin(d,index,0,point(p,P));\n  getmin(d,index,0,point(p,Q));\n  getmin(d,index,0,point(p,R));\n\n  getmin(d,index,0,point(p,aP));\n  getmin(d,index,0,point(p,aQ));\n  getmin(d,index,0,point(p,aR));\n\n  getmin(d,index,0,point(p,join(sP,bP)));\n  getmin(d,index,0,point(p,join(sQ,bQ)));\n  getmin(d,index,0,point(p,join(sR,bR)));\n\n  getmin(d,index,0,point(p,midpoint(P,H)));\n  getmin(d,index,0,point(p,midpoint(Q,H)));\n  getmin(d,index,0,point(p,midpoint(R,H)));\n  \n  getmin(d,index,0,point(p,C));\n  getmin(d,index,0,point(p,G));\n\n  col = mix(pcol,col,smoothstep(pwidth,pwidth+dwidth,d));\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  float scale = 1.5;\n  vec3 p = vec3(scale*(2.0*fragCoord-iResolution.xy)/iResolution.y,1.0);\n  vec3 P = iMouse.x <= 0.0 ? vec3(1,1,1)\n    : vec3(scale*(2.0*iMouse.xy-iResolution.xy)/iResolution.y,1.0);\n  vec3 col = diagram(p,P);\n  fragColor = vec4(pow(col,vec3(0.4545)),1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}