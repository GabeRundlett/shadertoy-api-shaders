{
    "Shader": {
        "info": {
            "date": "1599832699",
            "description": "An overlapping quadtree structure with sorted elements.",
            "flags": 0,
            "hasliked": 0,
            "id": "wtjfDy",
            "likes": 44,
            "name": "Sorted Overlapping Quadtree",
            "published": 3,
            "tags": [
                "random",
                "sort",
                "overlay",
                "layers",
                "quadtree"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 1101
        },
        "renderpass": [
            {
                "code": "/*\n\n\tSorted Overlapping Quadtree\n\t---------------------------\n\n\tThis is a quadtree structure that allows for its cell objects to overlap\n\twith neighbors. The resultant objects have been given a height value, which\n\thave been sorted for rendering.\n\n\tTo be sure, there are easier ways to render random sized objects onto a \n    screen, but I wanted a way to test an overlapping quadtree structure that \n    I'll be using in a following example involving an extruded grid of packed \n    multiscaled pylons. Having said that, using this structure produces a \n    cleaner, packed, more evenly distributed look with fewer operations. An \n    overlapping quadtree also has other uses, like multiscaled Voronoi with \n    minimal taps.\n\n\tIn particular, I'm using the structure to render some closely packed \n    overlapping circles with a custom overlay function to give the impression of \n    transparent interiors. Years ago, I remember naively thinking that \n    transparent objects wouldn't require sorting, but unfortunately, overlaying\n\tcolor order matters. The custom overlay formula was made up on the spot to \n    produce a reasonable looking see-through effect, but it's not what anyone\n\twould describe as physically correct. By the way, you could save quite a \n    few calculations and leave things unsorted, but you'd lose that interesting \n\trandom height look.\n\n\tThe three levels here require a maximum of 27 taps (fewer, on average), on \n    account of the fact that the objects stray from their cell centers quite a \n    bit, which necessitates a 3x3 grid check for all three levels. However, with \n    range restrictions, it's possible to get away with 2x2 checks, for a maximum \n    of just 12 in total.\n\n\tSome may have also noticed that this is a little heavy on the rendering side\n\tof things, which is noticeable in fullscreen mode. Therefore, when I've got \n    some time, I'll find ways to cut that down.\n \n\n\tRelated examples:\n\n    // Here's a very basic non-overlapping quadtree example. Things are much \n    // easier, and almost trivial, when neighbors don't need to be considered.\n\tRandom Quadtree - Shane\n\thttps://www.shadertoy.com/view/llcBD7\n\n\n*/\n\n\n// Random cell object offsets: If you turn this off, you can see the\n// packed quadtree structure.\n#define RANDOM_OFFSET\n\n// A faster version with a maximum 12 taps for three levels. It's just what\n// you need for packed extruded objects contained within cells, but doesn't\n// provide enough random range for this example.\n//#define FASTER\n\n// Sort the cell objects in order of height. Of course, there's no rule that\n// says you have to sort the objects. If you comment this out, objects will\n// be added to the canvas in the same order they were added to the quadtree,\n// which will be in order of object size.\n#define SORT\n\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(113, 1)));\n    \n    //return fract(vec2(262144, 32768)*n);\n    \n    \n    // Animated.\n    p = fract(vec2(262144, 32768)*n); \n    // Note the \".35,\" insted of \".5\" that you'd expect to see. .\n    return sin(p*6.2831853 + iTime/2.)*.5 + .5;\n    \n}\n\n\n/*\nfloat sBoxS(in vec2 p, in vec2 b, in float rf){\n  \n  vec2 d = abs(p) - b + rf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rf;\n    \n}\n\nfloat sBox(in vec2 p, in vec2 b){\n\n  \n  vec2 d = abs(p) - b;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n*/\n\n// Getting the video texture. I've deliberately stretched it out to fit across the screen,\n// which means messing with the natural aspect ratio.\n//\n// By the way, it'd be nice to have a couple of naturally wider ratio videos to choose from. :)\n//\nvec3 getTex(sampler2D ch, vec2 p){\n    \n    // Strething things out so that the image fills up the window. You don't need to,\n    // but this looks better. I think the original video is in the oldschool 4 to 3\n    // format, whereas the canvas is along the order of 16 to 9, which we're used to.\n    // If using repeat textures, you'd comment the first line out.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(ch, p).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n// Height map value, which is just the pixel's greyscale value.\nfloat hm(in vec2 p){ return dot(getTex(iChannel0, p), vec3(.299, .587, .114)); }\n\n// Maximum array number.\n#define ANUM 32 \n\n// Total cell objects for the pass.\nint objN = 0;\n\n// The cell object structure: I try to avoid structures in \n// pixel shaders, but sometimes they're convenient.\nstruct obj{\n    \n    float dist; // Object distance.\n    float distSh; // Object shadow distance.\n    vec2 id; // Position based ID.\n    vec2 offs; // Cell offset.\n    float boxID; // Cell ID.\n    float height; // Cell height.\n    vec2 dim; // Cell dimensions.\n};\n\n\n// Global cell scale.\n#define GSCALE vec2(1./5.);\n\n// The quadtree function.\nobj[ANUM] blocks(vec2 q3, vec3 lp){\n    \n    \n    // Cell scale and dimension.\n    vec2 oDim = GSCALE;\n    vec2 dim = GSCALE; \n    \n    // Overall minimum distance. Not used here.\n    //float d = 1e5;\n    \n    \n    // An array or objects.\n    obj[ANUM] sq;\n    \n    // Reset the number of objects.\n    objN = 0;\n    \n    \n    // Chance that level one, two or three will be rendered:\n    //\n    // The final entry needs to fill in whatever cells are remaining, so needs to have a \n    // 100% chance of success. I'd rather not say how long it took me to figure that out. :D\n    vec3 rndTh = vec3(.333, .666, 1.01);\n    \n    \n    \n    for(int k=0; k<3; k++){\n \n        #ifdef FASTER\n        for(int j = 0; j<=1; j++){\n            for(int i = 0; i<=1; i++){\n                \n                // For the 12 tap (4-tap IJ loop), we need the \"-.5\" figure to center things.\n        \t    vec2 ip0 = q3.xy/dim + vec2(i, j) - .5;\n        #else\n        for(int j = -1; j<=1; j++){\n            for(int i = -1; i<=1; i++){\n                \n              \t// For the 27 tap (9-tap IJ loop), take it off the expression.\n        \t    vec2 ip0 = q3.xy/dim + vec2(i, j);\n        #endif\n                \n\n                // First level random subdivision.\n                vec3 rndIJ;\n                rndIJ[0] = hash21(floor(ip0));\n                if(rndIJ[0]>=rndTh[k]) continue;\n\n                // Second level random subdivision.\n                rndIJ[1] = hash21(floor(ip0/2.));\n                if(k==1 && rndIJ[1]<rndTh[0]) continue;\n\n                // Third level random subdivision.\n                rndIJ[2] = hash21(floor(ip0/4.));\n                if(k==2 && (rndIJ[1]<rndTh[1] || rndIJ[2]<rndTh[0])) continue;\n\n\n                // Local coordinates and cell ID.\n                vec2 p = q3.xy;\n                vec2 ip = floor(ip0) + .5;\n                p -= ip*dim; // Last term for 8 iterations.\n\n                // The cell's center position-based ID.\n                vec2 idi = ip*dim;\n\n              \n                #ifdef RANDOM_OFFSET\n                // Texture based object height.\n                float h = hm(idi);\n                h *= .15;\n                \n                #ifdef FASTER\n                vec2 offs = (hash22(idi + .63*dim) - .5)*dim*.3;\n                #else\n                vec2 offs = (hash22(idi + .41*dim) - .5)*dim*.5;\n                #endif\n                #else\n                vec2 offs = vec2(0);\n                 \n                float h = .15/2.; // Make the heights even.\n                #endif\n\n                \n\n                // Fake light direction vector calculation. It's not entirely correct,\n                // but produces the right effect.\n                vec2 ld = normalize(lp - vec3(idi + offs, 0)).xy;\n                \n                // Scaling factor, based on height.\n                float scF = 1./1. + (h*2. - .15)*1.;\n                #ifdef FASTER \n                scF *= 1.08;\n                ld *= .75;\n                #endif\n                \n                // Distance and distance shadow calculations.\n                float di2D = length(p - offs) - dim.x/2./scF;\n                \n                float di2DSSh = length(p - offs - -.03*ld) - dim.x/2./scF;\n\n \t\t\t\t// Boxes. I'll be using boxes for the 3D example.\n                //float di2D = sBoxS(p, dim/2. - .05*oDim.x, .1*oDim.x);\n                //float di2DSSh = sBoxS(p - vec2(-.03), dim/2. - .05*oDim.x, .1*oDim.x);\n\n\n                // For 3D and other things, you'd update on a closest basis, but\n                // in this case, we need to render them all.\n                //if(di2D<d){\n                //d = di2D;\n\n                // The quadtree cell ID.\n                #ifdef FASTER\n                float boxID = float(k*4 + j*2 + (1 - i));\n                #else\n                float boxID = float(k*9 + (j + 1)*3 + (2 - (i + 1)));\n                #endif\n\n\t\t\t\t// Fill in the object values.\n                sq[objN].dist = di2D;\n                sq[objN].distSh = di2DSSh;\n                sq[objN].id = idi;\n                sq[objN].offs = offs;\n                sq[objN].boxID = boxID;\n                sq[objN].height = h;\n                sq[objN].dim = dim;\n\n                // Increment the global object count.\n                objN++;\n                //}\n\n\n\n            }\n        }\n\n        // Cut the dimension in half for the next level.\n        dim /= 2.;\n        \n    }  \n    \n    // Return the object array.\n    return sq;\n    \n    \n}\n\n\n// float swap.\nvoid swap(inout float a, inout float b){ float tmp = a; a = b; b = tmp; }\n// float swap.\nvoid swap(inout int a, inout int b){ int tmp = a; a = b; b = tmp; }\n\n// Translating the camera about the XY plane.\nvec2 getCamTrans(float t){ return vec2(sin(t/16.)/16., t/8.); }\n\n// Rotating the camera about the XY plane.\nmat2 getCamRot(float t){\n    \n    //return rot2(0.);\n    return rot2(cos(t/8.)/16.);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    \n    // Aspect correct screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Scaling and translation.\n    float gSc = 1.;\n    \n    // Smoothing factor.\n    float sf = 1.5*gSc/iResolution.y;\n \n    // Depending on perspective; Moving the oject toward the bottom left, \n    // or the camera in the north east (top right) direction. \n    //vec2 p = uv*gSc - vec2(-.5, -1)*iTime/8.;\n    \n    // Rotating and moving the canvas. A 2D \"to\" and \"from\" setup would be better, but this\n    // will do for the purpose of the demonstration.\n    vec2 cam = getCamTrans(iTime); // Translation.\n    mat2 camRot = getCamRot(iTime); // Rotation.\n    // Extra 45 degred rotation to give a diamond grid appearance.\n    mat2 scrRot = rot2(0.);//rot2(3.14159/4.);\n    vec2 p = scrRot*(uv*gSc)*camRot + scrRot*cam;//rot2(3.14159/4.)*\n    \n    vec2 oP = p; // Save a copy.\n    \n    // Surface point and light position.\n    vec3 sp = vec3(p, 0); \n    vec3 lp = vec3(p - uv*gSc, -.35);\n    lp.xy += vec2(-.1, .15);\n    \n    // Using the quadtree structure to fill in the object array.\n    // Passing in the positino and light postion for shadows.\n    obj[ANUM] svObj = blocks(p, lp);\n     \n    // By the way, it's possible just to render the objects in the \n    // order that they're added to the list, but you'll lose the\n    // random ordered look. In this case, large objects would stay on \n    // the bottom and smaller would appear at the top.\n    \n    // Height and indices for sorting purposes.\n    int[ANUM] index;\n    float[ANUM] h;\n    for(int i = 0; i<objN; i++){\n        h[i] = svObj[i].height;\n        index[i] = i;\n    }\n   \n    #ifdef SORT\n    // Anyone who knows sorting will know this is not a fast sort,\n    // but it'll do. In fact, I remember reading somewhere that GPUs\n    // prefer straight forward things like this, rather than quick\n    // sorts, and so forth... but I'll leave that to the experts.\n    for(int i = 0; i<objN; i++){\n        for(int j = i + 1; j<objN; j++){\n            // Branchless swaps are possible, but I'm a little paranoid\n            // regarding precision issues.\n            if(h[i]<h[j]){ \n                swap(h[i], h[j]);\n                swap(index[i], index[j]);\n            }\n        }\n\t}\n    #endif\n    \n\n    // Background texture.\n    vec3 tx = texture(iChannel0, p).xyz; tx *= tx;\n    tx = smoothstep(0., .5, tx);\n    \n    // Background color.\n    vec3 col = vec3(.7, .5, .4)*1.2;\n    col *= mix(tx, col, .25);\n    \n    \n    // Fake light distance and attenuation.\n    float lDist = length(lp - sp);\n    float atten = 1./(1. + pow(lDist, 4.)*3.);\n    col *= atten;\n \n    for(int ii = 0; ii<objN; ii++){\n        \n        // Sorted index. Index sortings saves the extra hassle of\n        // object sorting.\n        int i = index[ii];\n        \n        // Some random numbers.\n        float rnd = hash21(svObj[i].id);\n        float rnd2 = hash21(svObj[i].id + .47);\n        float rnd3 = hash21(svObj[i].id + .73);\n         \n        // Fake 3D scaling factor. Closer object appear larger, so this is \n        // used for texture scaling.\n        float distF = 1. + (.15 - svObj[i].height*2.);\n        \n        // A color texture read.\n        vec3 tx2 = texture(iChannel1, svObj[i].id/distF).xyz; tx2 *= tx2;\n \t\t//tx2 = smoothstep(0., .5, tx2);\n        // Another texture read. \n        tx = texture(iChannel0, (p - (svObj[i].id + svObj[i].offs))/distF).xyz; tx *= tx;\n        tx = smoothstep(-.1, .5, tx);\n        \n        // Object color.\n        vec3 oCol = mix(tx, tx2, .25)*vec3(1, .7, .5)*1.35;\n         \n        // Circle distance and shadow.\n        float d = svObj[i].dist;\n        float dSh = svObj[i].distSh;\n        // Ring and corresponding ring shadow.\n        float rw = .012; // Ring width.\n        float ring = abs(d + rw/2.) - rw/2.;\n        float ringSh = abs(dSh + rw/2.) - rw/2.;\n        \n        // Subtle shading.\n        float sh = max(.9 - d/svObj[i].dim.x, 0.);\n        \n        sp = vec3(p.x, p.y + (.15 - svObj[i].height*2.), 0);\n        lDist = length(lp - sp);\n        atten = 1./(1. + pow(lDist, 4.)*3.);\n        \n        // Polar ring pattern.\n        vec2 q = p - svObj[i].id - svObj[i].offs;\n        float ang = atan(q.y, q.x);\n        #ifdef RANDOM_OFFSET\n        // Randomly rotate the pattern.\n        ang += (floor(rnd*2.) - .5)*iTime/2.*(rnd2*.5 + .5);\n        #endif\n        // Scale factor for the ring number. Smaller circles mean\n        // fewer polar lines.\n        #ifdef FASTER\n        float scF = floor(svObj[i].boxID/4.);\n        #else\n        float scF = floor(svObj[i].boxID/9.);\n        #endif\n        scF = exp2(scF); // Equivalent to: pow(2., scF);\n        float pat = abs(fract(ang/6.2831853*32./scF) - .5)*2. - .15;\n        pat = smoothstep(0., sf*32./scF, pat)*.65 + .35;\n        \n        \n       \n        vec3 shCol = (.5 + 6.*sh*oCol*atten);\n        vec3 shCol2 = (.75 + 3.*sh*oCol*atten);\n        // Blinking formula... One of many.\n        rnd3 = smoothstep(.75, .9, sin(rnd3*6.2831853 + iTime*2.)*.5 + .5);\n        shCol = mix(shCol2, shCol, rnd3);\n        // Perspex shadow... The idea is that the light would cast a colored\n        // light onto the ground... Maybe. None of this is important.\n       \n        vec3 gCol = col*shCol;\n        if(rnd2<.15) gCol = mix(gCol, gCol.zyx, .7);\n        //else if(rnd2<.25) gCol = mix(gCol, gCol.xzy, .7);\n        col = mix(col, gCol/2., (1. - smoothstep(0., sf, dSh + .004 + rw)));\n        \n        // Solid ring shadow.\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*5., ringSh))*.6);\n        \n        // The object ring itself.\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*5., ring))*.5);\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf, ring))*.9);\n        col = mix(col, oCol*1.35*atten*pat, (1. - smoothstep(0., sf, ring + .004))); \n        \n        \n        // The top perspex layer... or is it thin cellophane, or just a thin \n        // colored light shining across the rim? No idea, but I thought the \n        // transparent colored light provided visual interest. :)\n        gCol = col*shCol;\n        if(rnd2<.15) gCol = mix(gCol, gCol.zyx, .7);\n        //else if(rnd2<.25) gCol = mix(gCol, gCol.xzy, .7);\n        // \n        col = mix(col, gCol/2., (1. - smoothstep(0., sf, d + .004 + rw)));\n        \n  \n        \n    }\n    \n  \n    \n    \n    // Rough gamma correction and output.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}