{
    "Shader": {
        "info": {
            "date": "1539814617",
            "description": "Coded live on twitch stream in Bonzomatic, and tidied/ported to shadertoy.\nUnedited Bonzomatic shader here: [url]https://gist.github.com/willkirkby/bf15c44b09e3d9e5df833dbd1824ff0a[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "llcfW7",
            "likes": 21,
            "name": "[twitch] Implied Geometry",
            "published": 3,
            "tags": [
                "bw",
                "twitch"
            ],
            "usePreview": 0,
            "username": "yx",
            "viewed": 2106
        },
        "renderpass": [
            {
                "code": "#define CHROMA\n\n#define pi acos(-1.)\n#define tau (pi*2.)\n\nconst float SCROLL_SPEED = 1.;\nconst float SPIN_SPEED_H = 1.;\nconst float SPIN_SPEED_V = .1;\nconst float WIRE_THICKNESS = .03;\nconst float CUBE_SCALE = .66;\n\nfloat time;\nbool state;\n\nvec2 rotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\nfloat sdOctahedron(vec3 p, float r)\n{\n    p = abs(p);\n    float d = p.x + p.y + p.z - r;\n    return d / sqrt(3.);\n}\n\nfloat sdLine(vec3 p, vec3 a, vec3 b)\n{\n    float t = dot(p-a,b-a)/dot(b-a,b-a);\n    return distance(p,mix(a,b,t));\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    return sdLine(p,a,b)-r;\n}\n\nfloat sdCappedLine(vec3 p, vec3 a, vec3 b)\n{\n    float t = dot(p-a,b-a)/dot(b-a,b-a);\n    t = clamp(t,0.,1.);\n    return distance(p,mix(a,b,t));\n}\n\nfloat sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    return sdCappedLine(p,a,b)-r;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat sdBox(vec3 p, vec3 r)\n{\n    vec3 d = abs(p)-r;\n    return min(max(max(d.x,d.y),d.z),0.) + length(max(d,0.));\n}\n\nvec3 spin(vec3 p)\n{\n    p.xy = rotate(p.xy, time);\n    p.yz = rotate(p.yz, time);\n    p.zx = rotate(p.zx, time);\n    return p;\n}\n\nvec3 spin2(vec3 p)\n{\n    p.xy = rotate(p.xy, -time);\n    p.yz = rotate(p.yz, -time);\n    p.zx = rotate(p.zx, -time);\n    return p;\n}\n\nfloat scene(vec3 p)\n{\n    float d;\n    if (state)\n    {\n        d = min(\n            min(\n                sdOctahedron(spin2(p), .5),\n                sdCappedCylinder(abs(spin(p)),vec3(1,0,0),vec3(0,1,0),WIRE_THICKNESS)\n            ),\n            min(\n                sdCappedCylinder(abs(spin(p)),vec3(0,1,0),vec3(0,0,1),WIRE_THICKNESS),\n                sdCappedCylinder(abs(spin(p)),vec3(0,0,1),vec3(1,0,0),WIRE_THICKNESS)\n            )\n        );\n    }\n    else\n    {\n        d = min(\n            min(\n                sdBox(spin2(p), vec3(.5)*CUBE_SCALE),\n                sdCappedCylinder(abs(spin(p)),vec3(1,1,1)*CUBE_SCALE,vec3(0,1,1)*CUBE_SCALE,WIRE_THICKNESS)\n            ),\n            min(\n                sdCappedCylinder(abs(spin(p)),vec3(1,1,1)*CUBE_SCALE,vec3(1,0,1)*CUBE_SCALE,WIRE_THICKNESS),\n                sdCappedCylinder(abs(spin(p)),vec3(1,1,1)*CUBE_SCALE,vec3(1,1,0)*CUBE_SCALE,WIRE_THICKNESS)\n            )\n        );\n    }\n    return min(\n        d,\n        -sdSphere(p, 10.)\n    );\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n#ifdef CHROMA\n    for(int c=0;c<3;++c)\n    {\n        time = iTime + float(c)*.02;\n#else\n    {\n        time = iTime;\n#endif\n        float spinHTime = time * SPIN_SPEED_H;\n        float spinVTime = time * SPIN_SPEED_V;\n        float scrollTime = time * SCROLL_SPEED;\n        \n        vec3 perspcam = vec3(0,0,-2);\n        vec3 perspdir = normalize(vec3(uv,.8));\n\n        vec3 orthocam = vec3(uv*3.,-5.);\n        vec3 orthodir = vec3(0,0,1);\n\n        vec3 cam = mix(orthocam, perspcam, abs(sin(spinVTime)));\n        vec3 dir = mix(orthodir, perspdir, abs(sin(spinVTime)));\n\n        cam.yz = rotate(cam.yz, sin(spinVTime)*.9);\n        dir.yz = rotate(dir.yz, sin(spinVTime)*.9);\n\n        cam.xz = rotate(cam.xz, spinHTime);\n        dir.xz = rotate(dir.xz, spinHTime);\n\n        state = dir.y > 0.;\n\n        float t = 0.;\n        for(int i=0;i<100;++i)\n        {\n            float k = scene(cam+dir*t);\n            t+=k;\n            if (k<.001)\n                break;\n        }\n        vec3 h = cam+dir*t;\n        vec2 o = vec2(.001,0);\n        vec3 n = normalize(vec3(\n            scene(h+o.xyy)-scene(h-o.xyy),\n            scene(h+o.yxy)-scene(h-o.yxy),\n            scene(h+o.yyx)-scene(h-o.yyx)\n        ));\n\n        float th = .05;\n#ifdef CHROMA\n        out_color[c] = smoothstep(-th, th, sin(tau*h.y-scrollTime));\n#else\n        out_color = vec4(smoothstep(-th, th, sin(tau*h.y-scrollTime)));\n#endif\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}