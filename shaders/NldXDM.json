{
    "Shader": {
        "info": {
            "date": "1639234592",
            "description": "Here i have created a shader that splits the grid into infinite triangles that move around, to continue i would like to add subtriangles to the project as i believe that it would add a lot of life to the image.",
            "flags": 0,
            "hasliked": 0,
            "id": "NldXDM",
            "likes": 29,
            "name": "Triangle Image Effect",
            "published": 3,
            "tags": [
                "grid",
                "triangles",
                "colors",
                "imageprocessing",
                "random",
                "imageeffect",
                "interpolation",
                "colormixing"
            ],
            "usePreview": 1,
            "username": "Daizuukee",
            "viewed": 604
        },
        "renderpass": [
            {
                "code": "/*\nPARAMETERS FEEL FREE TO CHANGE\n*/\n\n//Difference between triangles -> 0 - 1\n#define multiplier 0.71\n//Amount of traingles on X axis\n#define zoom 20.\n\n//position of the camera (can be an animation, dont place below 0)\n#define position vec2(85,483);\n\n//Lighting\n//strength of the lights\n#define normals 0.25\n//Direction of the light\n#define light vec2(2,1)\n\n//Uncomment to use iCHannel0 as source for colors\n//#define colFromImage\n\n//colors (can be animated)\n//only apply when colFromImage is undefined\n#define color0 vec3(1.0, 0.0, 1.0)\n#define color1 vec3(0.2157, 0.0, 1.0)\n#define color2 vec3(0.502, 0.9686, 1.0)\n#define color3 vec3(0.702, 0.4235, 0.2353)\n#define BG vec3(1,1,1)\n//Strength of the colors to be aplied to the BG\n#define strength 0.71\n\n\n/*\nCODE BEGINS HERE\n*/\n\n\n//https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n\n//const uint k = 1103515245U;  // GLIB C\nconst uint k = 134775813U;   // Delphi and Turbo Pascal\n//const uint k = 1664525U;     // Numerical Recipes\nvec3 hash(uvec3 x)\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    return vec3(x)*(1.0/float(0xffffffffU)) * 2. - 1.;\n}\n\n\n\n\n\n#define lerp(from,to,x) (((to)-(from))*(x)+(from))\n#define map(from,to,fromX,toX,x) lerp((from),(to),((x)-(fromX))/((toX)-(fromX)))\n#define zFunc iTime\n//Gets the vertice at x,y with z time having passed\n//only value that is animated is z\nvec3 getVertice(vec3 pos) {\n    //give every tiangle a different time offset\n    float t = pos.z+hash(uvec3(pos.xy + 748.,0)).x;\n    //interpolate between current and next triangle position\n    vec3 a = hash(uvec3(pos.xy,floor(t))) * multiplier * 0.5 + 0.5;\n    vec3 b = hash(uvec3(pos.xy,ceil(t))) * multiplier * 0.5 + 0.5;\n    //make normals stronger\n    a.z *= normals;\n    b.z *= normals;\n    return lerp(a,b,fract(t));\n}\n\n//Gets the triangle that p will be in\n//x -> x quad\n//y -> y quad\n//z -> upper or lower triangle\n/*\nEach quad looks like this\neach + can be moved freely\n\n+----+\n|\\   |\n| \\  |\n|  \\ |\n|   \\|\n+----+\n\n*/\n\nuvec3 bindToTris(vec2 p) {\n    //current grid Tile\n    ivec2 floorP = ivec2(p);\n    //relative Position to Tile\n    vec2 modP = p-vec2(floorP);\n    //time\n    float z = zFunc;\n    //check in which quad we are relative to the middle of the current grid Tile\n    vec2 mid = getVertice(vec3(floorP,z)).xy;\n    ivec2 nextOffset = ivec2(mid.x < modP.x,mid.y < modP.y) * 2 - 1;\n\n    //check in which quad we are by looking if we are above/below and to the right/left of line between the dots\n    //that make up the current quad\n    vec2 yOff = getVertice(vec3(floorP.x, floorP.y + nextOffset.y, z)).xy;\n    vec2 xOff = getVertice(vec3(floorP.x + nextOffset.x, floorP.y, z)).xy;\n    float yLine = map(mid.x,yOff.x,mid.y,yOff.y+float(nextOffset.y),modP.y);\n    float xLine = map(mid.y,xOff.y,mid.x,xOff.x+float(nextOffset.x),modP.x);\n\n    ivec2 quad = ivec2(modP.x > yLine, modP.y > xLine);\n    \n    //check wether we are in the upper or lower triangle of the current quad\n    vec2 dOff0 = getVertice(vec3(floorP + quad + ivec2(-1, 0), z)).xy;\n    vec2 dOff1 = getVertice(vec3(floorP + quad + ivec2( 0,-1), z)).xy;\n\n    float dLine = map(dOff0.y+1.,dOff1.y,dOff0.x,dOff1.x+1.,modP.x+1.-float(quad.x))-1.+float(quad.y);\n    \n    //return the data for further use (mostly unusable as is)\n    return uvec3(quad+floorP,modP.y > dLine);\n}\n\n//returns the middle of the triangle given the data from bindToTris() and the height gradient\n\nvec4 getTriangle(uvec3 data) {\n    float z = zFunc;\n    int up = int(data.z);\n    //get all the different vertices\n    vec3 p1 = getVertice(vec3(vec2(data.xy)+vec2(0,-1),z)) + vec3(0,-1, 0);\n    vec3 p2 = getVertice(vec3(vec2(data.xy)+vec2(-1,0),z)) + vec3(-1, 0, 0);\n    vec3 p3 = getVertice(vec3(vec2(data.xy)+vec2(up-1,up-1),z)) + vec3(up-1,up-1,0);\n\n    //gradient from p1 to the other corners\n    vec3 gradient0 = p1-p2;\n    vec3 gradient1 = p1-p3;\n    vec3 g = cross(gradient0,gradient1);\n    //amount you need to move x and y to add 1 to z\n    g.xyz /= g.z;\n    \n    return vec4(((p1.xy+p2.xy+p3.xy)/3.)+vec2(data.xy),g.xy);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) {\n    vec2 uv=fragCoord/iResolution.xx;\n    uv *= zoom;\n    uv += position;\n    \n    //standardize everything\n    vec3 interpCol0 = color0;\n    vec3 interpCol1 = color1;\n    vec3 interpCol2 = color2;\n    vec3 interpCol3 = color3;\n    //get triangle under current pixel and immediately turn into usable data\n    vec4 Triangle = getTriangle(bindToTris(uv));\n    Triangle.xy -= position;\n    Triangle.xy /= zoom;\n\n    vec3 cur;\n\n#ifdef colFromImage\n    cur = texture(iChannel0,Triangle.xy).xyz;\n#else\n    //interpolate the colors\n    float l0 = clamp((1.-distance(Triangle.xy,vec2(0,0)))*strength,0.,1.);\n    float l1 = clamp((1.-distance(Triangle.xy,vec2(0,1)))*strength,0.,1.);\n    float l2 = clamp((1.-distance(Triangle.xy,vec2(1,0)))*strength,0.,1.);\n    float l3 = clamp((1.-distance(Triangle.xy,vec2(1,1)))*strength,0.,1.);\n    cur = lerp(BG,interpCol0,l0);\n    cur = lerp(cur,interpCol1,l1);\n    cur = lerp(cur,interpCol2,l2);\n    cur = lerp(cur,interpCol3,l3);\n#endif\n    //calculate lighting through dot product between lighting normal and triangle normal\n    cur *= dot(Triangle.zw,normalize(light))/2.+1.;\n\n    fragColor = vec4(cur,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}