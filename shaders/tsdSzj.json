{
    "Shader": {
        "info": {
            "date": "1572417068",
            "description": "This world is created with voxels based on IQ's integer hash function. ",
            "flags": 0,
            "hasliked": 0,
            "id": "tsdSzj",
            "likes": 8,
            "name": "Sub voxel rm test",
            "published": 3,
            "tags": [
                "raymarching",
                "voxels"
            ],
            "usePreview": 0,
            "username": "NLIBS",
            "viewed": 351
        },
        "renderpass": [
            {
                "code": "// IQ's integer hash function ---------------------------\nconst uint k = 1234543210U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n//-------------------------------------------------------\n\nfloat sphere(vec3 p, float r)\n{\n\treturn length(p)-r;\n}\n\nfloat shrub(vec3 p)\n{  \n    return length(vec3(mod(p.xz,1.)-.5,p.y+12.).xyz)-.5;\n}\n\nfloat cube(vec3 p)\n{\n    float h = length(p)-14.;\n    return min(max(-h,0.),max(abs(p.y-11.99)-.01,0.));    \n}\n\nfloat ray_box(vec3 ro, vec3 rd, float mint, float maxt)\n{\n\tfloat t = 0.;\n    for (int i = 0; (i<150 && t<maxt); i++) {\n    \tvec3 p = ro + rd * t;\n        float h = cube(p);\n        t += h;\n        if (h*1e5<mint+t) return t;\n    }\n    return -1.;\n}\n\nfloat ray_veg(vec3 ro, vec3 rd, float mint, float maxt) {\n\tfloat t = 0.;\n    for (int i = 0; (i<150 && t<maxt); i++) {\n        float h = shrub(ro + rd * t);\n        t += h;\n        if (h*1e5<mint+t) return t;\n    }\n    return -1.;\n}\n\nvec2 ray(vec3 ro, vec3 rd) {\n    float t = 0.;\n    float grid = 24.;\n    vec3 pr_stp = step(0., rd)*grid;\n    float dec = .3;\n    while(t<300.) {\n        vec3  p   = ro + rd*t,\n              ip  = floor((ro + rd*t)/grid)*grid,\n              dt  = (pr_stp + ip-p) / rd;\n    \tfloat dlt = max(min(min(dt.x,dt.y),dt.z),1e-3),\n              pr_hash = hash(uvec3(ip/grid+1e4)).x;\n        if (pr_hash<dec && ip.y<0.) {\n\t\t\tfloat t2 = ray_box(p-ip-grid*.5,rd,t,dlt);  \n            if (t2!=-1.) {\n\t\t\t\treturn vec2(t+t2,2); \n            }\n        } else if (ip.y<1.) {\n\t\t\tpr_hash = hash(uvec3((ip-vec3(0,1,0))/grid+1e4)).x;\n\t\t\tif (pr_hash<dec) {\n                float t2 = ray_veg(p-ip-grid*.5,rd,t,dlt);\n                if (t2!=-1.) {\n\t\t\t\t\treturn vec2(t+t2,3); \n                }\n            }\n\t\t\t\n        }\n    \tt += dlt;\n    }\n    return vec2(0);\n}\n\n\nvoid mainImage( out vec4 O, in vec2 U ) \n{\n    vec2 uv = (U-iResolution.xy*.5)/iResolution.y*2.;\n    \n    vec3 viewPos = vec3(0,36,iTime*20.),\n         rd = normalize(vec3(uv,-1.6)).xzy;\n    \n    vec2 hit = ray(viewPos,rd);\n    vec3 p = viewPos + rd*hit.x;\n    \n    vec3 col = vec3(0.);\n    if (hit.y>0.) {  \n        float grid = (3.-hit.y)*24.;    \n        vec3 ip = floor(p/grid)*grid;\n        vec3 fp = p-ip-grid*.5;\n        col = hash(uvec3(ip+1e4))*0.2+vec3(0,.3,0.);\n\n        col = 1.- exp(-col*exp((36.-hit.x)*.06));\n        col = pow(col.rgb, vec3(1./2.2));\n        vec3 noise = pow(texelFetch(iChannel0, ivec2(U)%1024, 0).rgb,vec3(1./2.2));\n        noise = (noise*2.-1.)*0.499*2.;\n        col += noise/256.;\n    }\n    O = col.xyzx;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}