{
    "Shader": {
        "info": {
            "date": "1468788417",
            "description": "Because there is no character limit anymore, a lot more spheres can be rendered.\nThis shader uses code of the [url=https://www.shadertoy.com/view/MdB3Dw]Analytical Motionblur 3D[/url] shader by Inigo and a grid to trace a lot of spheres.",
            "flags": 0,
            "hasliked": 0,
            "id": "Xlt3Dn",
            "likes": 81,
            "name": "[SH16B] Speed tracer",
            "published": 3,
            "tags": [
                "ray",
                "blur",
                "spheres",
                "motion",
                "analytic",
                "trace"
            ],
            "usePreview": 0,
            "username": "reinder",
            "viewed": 4940
        },
        "renderpass": [
            {
                "code": "// [SH16B] Speed tracer. Created by Reinder Nijhoff 2016\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n// @reindernijhoff\n// \n// https://www.shadertoy.com/view/Xlt3Dn\n//\n// This shader uses code of the Analytical Motionblur 3D shader by Inego and a grid to trace a lot of spheres.\n//\n\n#define RAYCASTSTEPS 30\n\n#define GRIDSIZE 10.\n#define GRIDSIZESMALL 7.\n#define MAXHEIGHT 30.\n#define SPEED 20.\n#define FPS 30.\n#define MAXDISTANCE 260.\n#define MAXSHADOWDISTANCE 20.\n\n#define time iTime\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n//\n// intersection functions\n//\n\nbool intersectPlane(const in vec3 ro, const in vec3 rd, const in float height, out float dist) {\t\n\tif (rd.y==0.0) {\n\t\treturn false;\n\t}\n\t\n\tfloat d = -(ro.y - height)/rd.y;\n\td = min(100000.0, d);\n\tif( d > 0. ) {\n\t\tdist = d;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n//\n// intersect a MOVING sphere\n//\n// see: Analytical Motionblur 3D\n//      https://www.shadertoy.com/view/MdB3Dw\n//\n// Created by inigo quilez - iq/2014\n//\nvec2 iSphere( const in vec3 ro, const in vec3 rd, const in vec4 sp, const in vec3 ve, out vec3 nor )\n{\n    float t = -1.0;\n\tfloat s = 0.0;\n\tnor = vec3(0.0);\n\t\n\tvec3  rc = ro - sp.xyz;\n\tfloat A = dot(rc,rd);\n\tfloat B = dot(rc,rc) - sp.w*sp.w;\n\tfloat C = dot(ve,ve);\n\tfloat D = dot(rc,ve);\n\tfloat E = dot(rd,ve);\n\tfloat aab = A*A - B;\n\tfloat eec = E*E - C;\n\tfloat aed = A*E - D;\n\tfloat k = aed*aed - eec*aab;\n\t\t\n\tif( k>0.0 )\n\t{\n\t\tk = sqrt(k);\n\t\tfloat hb = (aed - k)/eec;\n\t\tfloat ha = (aed + k)/eec;\n\t\t\n\t\tfloat ta = max( 0.0, ha );\n\t\tfloat tb = min( 1.0, hb );\n\t\t\n\t\tif( ta < tb )\n\t\t{\n            ta = 0.5*(ta+tb);\t\t\t\n            t = -(A-E*ta) - sqrt( (A-E*ta)*(A-E*ta) - (B+C*ta*ta-2.0*D*ta) );\n            nor = normalize( (ro+rd*t) - (sp.xyz+ta*ve ) );\n            s = 2.0*(tb - ta);\n\t\t}\n\t}\n\n\treturn vec2(t,s);\n}\n\n//\n// Shade\n//\n\nvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\nvec3 shade( const in float d, in vec3 col, const in float shadow, const in vec3 nor, const in vec3 ref, const in vec3 sky) {\n    float amb = max(0., 0.5+0.5*nor.y);\n    float dif = max(0., dot( normalize(nor), lig ) );\n    float spe = pow(clamp( dot(normalize(ref), lig ), 0.0, 1.0 ),16.0);\n\n    dif *= shadow;\n\n    vec3 lin = 1.20*dif*vec3(1.00,0.85,0.55);\n    lin += 0.50*amb*vec3(0.50,0.70,1.00);\n    col = col*lin;\n    col += spe*dif;\n    \n    // fog\n    col = mix( col, sky, smoothstep( MAXDISTANCE * .8, MAXDISTANCE, d ) );\n    \n\treturn col;\n}\n\n//\n// Scene\n//\n\nvoid getSphereOffset( const in vec2 grid, inout vec2 center ) {\n\tcenter = (hash22( grid ) - vec2(0.5) )*(GRIDSIZESMALL);\n}\n\nvoid getMovingSpherePosition( const in vec2 grid, const in vec2 sphereOffset, inout vec4 center, inout vec3 speed ) {\n\t// falling?\n\tfloat s = 0.1+hash12( grid );\n    \n\tfloat t = fract(14.*s + time/s*.3);\t\n\tfloat y =  s * MAXHEIGHT * abs( 4.*t*(1.-t) );\n    \n    speed = vec3(0, s * MAXHEIGHT * ( 8.*t - 4. ), 0 ) * (1./FPS);\n    \n\tvec2 offset = grid + sphereOffset;\n\t\n\tcenter = vec4(  offset.x + 0.5*GRIDSIZE, 1. + y, offset.y + 0.5*GRIDSIZE, 1. );\n}\n\nvoid getSpherePosition( const in vec2 grid, const in vec2 sphereOffset, inout vec4 center ) {\n\tvec2 offset = grid + sphereOffset;\n\tcenter = vec4( offset.x + 0.5*GRIDSIZE, 1., offset.y + 0.5*GRIDSIZE, 1. );\n}\n\nvec3 getSphereColor( vec2 grid ) {\n\tfloat m = hash12( grid.yx ) * 12.;\n    return vec3(1.-m*0.08, m*0.03, m*0.06);\n}\n\nvec3 render(const in vec3 ro, const in vec3 rd, const in vec3 cameraSpeed, const in mat3 rot ) {\n    vec3 nor, ref, speed;\n    \n\tfloat dist = MAXDISTANCE;\n\t\n\tvec3 sky = clamp( vec3(1,1.5,2.5)*(1.0-0.8*rd.y), vec3(0.), vec3(1.));\n\tvec3 colBackground, sphereSpeed, col = vec3(0.);\n    \n    vec4 sphereCenter;    \n\tvec3 pos = floor(ro/GRIDSIZE)*GRIDSIZE;\n\tvec2 offset;\n    \n\tif( intersectPlane( ro,  rd, 0., dist) ) {\n        vec3 interSectionPoint = ro + rd * dist;\n        \n        \n        // HMMMMM this is totaly fake. Hopefully I have enough time to find the analytic\n        // solution to get a motion blurred checkerboard\n        speed = rot * (interSectionPoint.xyz - ro) + cameraSpeed;   \n        \n        vec2 c1 = mod(interSectionPoint.xz * .25, vec2(2.));\n\t\t\n        float w = (abs( fract(c1.x*abs(rd.x)) -.5 ) + abs( fract(c1.y*abs(rd.y)) -.5 ));        \n\n        colBackground = mix(\n            mod(floor(c1.x) + floor(c1.y), 2.) < 1. ? vec3( 0.4 ) : vec3( .6 ),\n            vec3(.5), clamp( (w + .8) * .007 * length(speed.xz) * FPS , 0., 1.));\n            \n        // calculate shadow\n        float shadow = 0.;\n                \n        vec3 shadowStartPos = interSectionPoint - lig;\n        vec2 shadowGridPos = floor((ro + rd * dist).xz/GRIDSIZE);\n        \n        for( float x=-1.; x<=1.; x++) {\n            for( float y=-1.; y<=1.; y++) {\n                vec2 gridpos = (shadowGridPos+vec2(x,y))*GRIDSIZE;\n                getSphereOffset( gridpos, offset );\n\n                getMovingSpherePosition( gridpos, -offset, sphereCenter, sphereSpeed );\n\n                vec2 res = iSphere( shadowStartPos, lig, sphereCenter, sphereSpeed + cameraSpeed, nor );\n                if( res.x>0.0 )\n                {            \n                    shadow = clamp( shadow+mix(res.y,0., res.x/MAXSHADOWDISTANCE), 0., 1.);\n                }\n\n                getSpherePosition( gridpos, offset, sphereCenter );\n\n                res = iSphere( shadowStartPos, lig, sphereCenter, cameraSpeed, nor );\n                if( res.x>0.0 )\n                {            \n                    shadow = clamp( shadow+mix(res.y,0., res.x/MAXSHADOWDISTANCE), 0., 1.);\n                }\n            }\n        }\n                \n        ref = reflect( rd, vec3( 0., 1., 0. ) );\n        colBackground = shade( dist, colBackground, 1.-shadow, vec3( 0., 1., 0. ), ref, sky );            \n\t} else {\n\t\tcolBackground = sky;\n\t}\t\n\t\t\n\t// trace grid\n\tvec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd) * GRIDSIZE;\n\tvec3 dis = (pos-ro + 0.5  * GRIDSIZE + rs*0.5) * ri;\n\tvec3 mm = vec3(0.0);\n\t\t\n    float alpha = 1.;\n    \n\tfor( int i=0; i<RAYCASTSTEPS; i++ )\t{  \n        if( alpha < .01 ) break;\n        \n\t\tgetSphereOffset( pos.xz, offset );\n\t\t\n\t\tgetMovingSpherePosition( pos.xz, -offset, sphereCenter, sphereSpeed );\n\t\t        \n        speed = rot * (sphereCenter.xyz - ro) + sphereSpeed + cameraSpeed;\n        vec2 res = iSphere( ro, rd, sphereCenter, speed, nor );\n        if( res.x>0.0 )\n        {            \n       \t\tref = reflect( rd, nor );\n            vec3  lcol = shade( res.x, getSphereColor(-offset), 1., nor, ref, sky);\n            col += lcol * res.y * alpha;\n            alpha *= (1.-res.y);\n        }        \n                \n\t\tgetSpherePosition( pos.xz, offset, sphereCenter );\n        \n        speed = rot * (sphereCenter.xyz - ro) + cameraSpeed;        \n\t\tres = iSphere( ro, rd, sphereCenter, speed, nor );\n        if( res.x>0.0 )\n        {            \n       \t\tref = reflect( rd, nor );\n            vec3  lcol = shade( res.x, getSphereColor(-offset), 1., nor, ref, sky);\n            col += lcol * res.y * alpha;\n            alpha *= (1.-res.y);\n        }\n        \n\t\tmm = step(dis.xyz, dis.zyx);\n\t\tdis += mm * rs * ri;\n\t\tpos += mm * rs;\t\t\n\t}\t\n    \n    col += colBackground * alpha;\n    \n\treturn col;\n}\n\nvoid path( in float time, out vec3 ro, out vec3 ta ) {\n\tro = vec3( 16.0*cos(0.2+0.5*.4*time*1.5) * SPEED, 5.6+3.*sin(time), 16.0*sin(0.1+0.5*0.11*time*1.5) * SPEED);\n    time += 1.6;\n\tta = vec3( 16.0*cos(0.2+0.5*.4*time*1.5) * SPEED, -.1 + 2.*sin(time), 16.0*sin(0.1+0.5*0.11*time*1.5) * SPEED);\n}\n\nmat3 setCamera(in float time, out vec3 ro )\n{\n    vec3 ta;\n    \n    path(time, ro, ta);\n\tfloat roll = -0.15*sin(.732*time);\n    \n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(roll), cos(roll), 0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 q = fragCoord.xy/iResolution.xy;\n\tvec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\t\n\t// camera\t\n\tvec3 ro0, ro1, ta;\n    \n    mat3 ca0 = setCamera( time - 1./FPS, ro0 );\n\tvec3 rd0 = ca0 * normalize( vec3(p.xy,2.0) );\n\n    mat3 ca1 = setCamera( time, ro1 );\n\tvec3 rd1 = ca1 * normalize( vec3(p.xy,2.0) );\n\t        \n    mat3 rot = ca1 * mat3( ca0[0].x, ca0[1].x, ca0[2].x,\n                           ca0[0].y, ca0[1].y, ca0[2].y,\n                           ca0[0].z, ca0[1].z, ca0[2].z);\n    \n    rot -= mat3( 1,0,0, 0,1,0, 0,0,1);\n    \n\t// raytrace\t\n\tvec3 col = render(ro0, rd0, ro1-ro0, rot );\n\t\n\tcol = pow( col, vec3(0.5) );\n\t\n\tfragColor = vec4( col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}