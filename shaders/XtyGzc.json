{
    "Shader": {
        "info": {
            "date": "1476198765",
            "description": "A cave-like desert passageway.",
            "flags": 0,
            "hasliked": 0,
            "id": "XtyGzc",
            "likes": 184,
            "name": "Desert Passage",
            "published": 3,
            "tags": [
                "raymarch",
                "cellular",
                "tile",
                "cave",
                "rock",
                "desert",
                "passage"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 7665
        },
        "renderpass": [
            {
                "code": "/*\n\tDesert Passage\n\t--------------\n\n\tThis is a rendering of an ancient sandstone passageway, carved out over time on a planet... that \n\tslightly resembles a hastily-constructed, man-made set on the original Star Trek series, and where \n\tthe occasional rock hangs in mid air. Thankfully, I made up for it with some three-layer dust to \n\tgive it a bit more authenticity. :D\n\n\tI tend to favor abstract scenes, simply for the reason that so-called natural looking ones are harder \n\tto produce at decent frame rates... for me, anyway. With abstract scenes, I can use fake physics - or\n\tincorrect physics - then claim that I meant for it to be that way. :)\n\n\tAiekick's \"Weird Canyon\" was the inspiration for this. I liked his idea to carve out a solid object \n\twith Voronoi to create an \"Antelope Canyon\" like setting. The rendering style was influenced by \n\tDave Hoskins's \"Skin Peeler,\" which is based off of Nimitz's \"Xyptonjtroz\" example. Originally, I'd\n\thoped to emulate the look of IQ's \"Fractal Cave\" with cool streaming light shafts, but I thought I'd \n\tsave that for another time.\n\n\tThe scene is created by constructing a sinusoidal cave like mass, then carving out the surface with a\n\tcustom cellular algorithm that emulates Voronoi. It's pretty self explanatory and is contained in the\n\tdistance function. By the way, if you tried rendering the same scene using regular 3D Voronoi, your \n\tcircuits would fry.\n\n\tIn fact, this particular example makes usage of layering in order of aesthetic importance. Basically, \n\tthe larger, undulating base layers are raymarched -- preferably with cheap algorithms -- and the \n    finer details -- which tend to be more expensive -- are bump mapped.\n\t\n\n\tRelated examples:\n\n\t// Gorgeous rendering.\n\tFractal Cave - IQ\n\thttps://www.shadertoy.com/view/Xtt3Wn\n\n\t// A more abstract version.\n\tWeird Canyon - Aiekick\n\thttps://www.shadertoy.com/view/XtjSRm\n\n\t// One of my favorite simple coloring jobs.\n    Skin Peeler - Dave Hoskins\n    https://www.shadertoy.com/view/XtfSWX\n    Based on one of my all time favorites:\n    Xyptonjtroz - Nimitz\n\thttps://www.shadertoy.com/view/4ts3z2\n\n*/\n\n// The far plane. I'd like this to be larger, but the extra iterations required to render the \n// additional scenery starts to slow things down on my slower machine.\n#define FAR 80.\n\n\n// 2x2 matrix rotation. Angle vector, courtesy of Fabrice.\nmat2 rot2( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n// 1x1 and 3x1 hash functions.\nfloat hash( float n ){ return fract(cos(n)*45758.5453); }\nfloat hash( vec3 p ){ return fract(sin(dot(p, vec3(7, 157, 113)))*45758.5453); }\n\n\n// Draw the object on the repeat tile. In this case, a sphere. The result it squared, but that can\n// be taken into account after obtaining the minimum. See below.\nfloat drawObject(in vec3 p){ p = fract(p)-.5; return dot(p, p); }\n\n\n// Repeat cellular tile routine. The operation count is extremely low when compared to conventional\n// methods. No loops, no flooring, no hash calls, etc. Conceptually speaking, this is the fastest way \n// to produce a reasonable 3D cellular pattern... Although, there's one with three objects and no \n// rotation, but quality really suffers at that point. \nfloat cellTile(in vec3 p){\n    \n    // Draw four overlapping objects (spheres, in this case) at various positions throughout the tile.\n    vec4 d; \n    d.x = drawObject(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.y = drawObject(p - vec3(.39, .2, .11));\n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawObject(p - vec3(.62, .24, .06));\n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071;\n    d.w = drawObject(p - vec3(.2, .82, .64));\n\n    // Obtain the minimum, and you're done.\n    d.xy = min(d.xz, d.yw);\n        \n    return min(d.x, d.y)*2.66; // Scale between zero and one... roughly.\n}\n\n\n\n// The path is a 2D sinusoid that varies over time, which depends upon the frequencies and amplitudes.\nvec2 path(in float z){ return vec2(20.*sin(z * .04), 4.*cos(z * .09) + 3.*(sin(z*.025)  - 1.)); }\n\n\n// The triangle function that Shadertoy user Nimitz has used in various triangle noise demonstrations.\n// See Xyptonjtroz - Very cool.\n//vec3 tri(in vec3 x){return abs(fract(x)-.5);} // Triangle function.\n\n// The function used to perturb the walls of the passage structure: I came up with the tiled cellular\n// routine in order to raymarch something that resembled Voronoi. Regular 3D Voronoi is so intensive\n// that it's hard enough to bump map, let alone raymarch. Conceptually speaking, this algorithm is as\n// fast as you're going to get, yet it's still only good for one raymarching layer. The other cellular\n// layers (two more) have been bump mapped.\nfloat surfFunc(in vec3 p){\n    \n    float c = cellTile(p/6.); // Resembles a standard 3D Voronoi layer.\n    return mix(c, cos(c*6.283*2.)*.5 + .5, .125); // Mixing in a touch of sinusoidal variation.\n    \n    // Cheaper wall layering (although, not much), for comparison. \n    //p /= 2.;\n    //float c = dot(tri(p*.5 + tri(p*0.25).yzx), vec3(0.666));\n    //return mix(c, cos(c*6.283*1.5)*.5 + .5, .25);\n    \n    //p /= 5.;\n    //return dot(tri(p + tri(p.zxy)), vec3(0.666));\n\n}\n\n\n// IQ's smooth minium function. \nfloat smin(float a, float b , float s){\n    \n    float h = clamp( 0.5 + 0.5*(b-a)/s, 0. , 1.);\n    return mix(b, a, h) - h*(1.0-h)*s;\n}\n\n// Smooth maximum, based on IQ's smooth minimum.\nfloat smax(float a, float b, float s){\n    \n    float h = clamp( 0.5 + 0.5*(a-b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1.0-h)*s;\n}\n\n// The desert passage scene. Use a gyroid object as the passage-system base layer, carve it out\n// with the cellular function, put in a floor, then cap the whole thing off at roof height.\nfloat map(vec3 p){\n    \n\t// Surface function to perturb the walls.\n    float sf = surfFunc(p);\n\n    // A gyroid object to form the main passage base layer.\n    float cav = dot(cos(p*3.14159265/8.), sin(p.yzx*3.14159265/8.)) + 2.;\n    \n    // Mold everything around the path.\n    p.xy -= path(p.z);\n    \n    // The oval tunnel. Basically, a circle stretched along Y.\n    float tun = 1.5 - length(p.xy*vec2(1, .4));\n   \n    // Smoothly combining the tunnel with the passage base layer,\n    // then perturbing the walls.\n    tun = smax(tun, 1.-cav, 2.) + .75 + (.5-sf);\n    \n    float gr = p.y + 7. - cav*.5 + (.5-sf)*.5; // The ground.\n    float rf = p.y - 15.; // The roof cutoff point.\n    \n    // Smoothly combining the passage with the ground, and capping\n    // it off at roof height.\n    return smax(smin(tun, gr, .1), rf, 1.);\n \n \n}\n\n\n\n// Basic raymarcher. I haven't tweaked this yet. I think it needs it.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    float t = 0., h;\n    \n    for(int i=0; i<128; i++){\n    \n        h = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<0.002*(t*.25 + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        \n        t += h*.8;\n    }\n\n    return min(t, FAR);\n}\n\n\n// Tetrahedral normal - courtesy of IQ. I'm in saving mode, so the two \"map\" calls saved make\n// a difference. Also because of the random nature of the scene, the tetrahedral normal has the \n// same aesthetic effect as the regular - but more expensive - one, so it's an easy decision.\nvec3 normal(in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.001;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\n/*\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 normal(in vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n*/\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D t, in vec3 p, in vec3 n ){\n   \n    n = max(abs(n) - .2, .001); // The original is multiplied by \"7,\" but it feels slightly redundant.\n    n /= (n.x + n.y + n.z );  // Normalize.\n    // Three planes, weighted by their normals. Hence, tri-planar, I guess. :)\n\tp = (texture(t, p.yz)*n.x + texture(t, p.zx)*n.y + texture(t, p.xy)*n.z).xyz;\n    return p*p; // Rough sRGB to linear.\n}\n\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(in vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// Surface bump function: Cheap, but with decent visual impact. Of couse, \"cheap\" is a relative\n// term. This contains two 3D cellular functions and a 3D noise function. Thankfully, they're all\n// custom written and pretty quick.\nfloat bumpSurf3D( in vec3 p){\n\n    float bmp = cellTile(p/3.)*.8 + cellTile(p)*.2;\n    float ns = n3D(p*6. - bmp*6.);\n    \n    return mix(bmp, 1. - abs(ns-.333)/.667, .05);\n\n}\n\n// Standard function-based bump mapping function.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const vec2 e = vec2(0.001, 0);\n    float ref = bumpSurf3D(p);                 \n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy),\n                      bumpSurf3D(p - e.yxy),\n                      bumpSurf3D(p - e.yyx) )-ref)/e.x;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n// The iterations should be higher for proper accuracy, but in this case, I wanted less accuracy, just to leave\n// behind some subtle trails of light in the caves. They're fake, but they look a little like light streaming \n// through some openings... kind of.\nfloat softShadow(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\n\n    float shade = 1.0;\n    // Increase this and the shadows will be more accurate, but the wispy light trails in the caves will disappear.\n    // Plus more iterations slow things down, so it works out, in this case.\n    const int maxIterationsShad = 10; \n\n    // The \"start\" value, or minimum, should be set to something more than the stop-threshold, so as to avoid a collision with \n    // the surface the ray is setting out from. It doesn't matter how many times I write shadow code, I always seem to forget this.\n    // If adding shadows seems to make everything look dark, that tends to be the problem.\n    float dist = start;\n    float stepDist = end/float(maxIterationsShad);\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n        // End, or maximum, should be set to the distance from the light to surface point. If you go beyond that\n        // you may hit a surface not between the surface and the light.\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0., 1., k*h/dist));\n        \n        // What h combination you add to the distance depends on speed, accuracy, etc. To be honest, I find it impossible to find \n        // the perfect balance. Faster GPUs give you more options, because more shadow iterations always produce better results.\n        // Anyway, here's some posibilities. Which one you use, depends on the situation:\n        // +=max(h, 0.001), +=clamp( h, 0.01, 0.25 ), +=min( h, 0.1 ), +=stepDist, +=min(h, stepDist*2.), etc.\n        \n        // In this particular instance the light source is a long way away. However, we're only taking a few small steps\n        // toward the light and checking whether anything \"locally\" gets in the way. If a part of the scene a long distance away\n        // is between our hit point and the light source, it won't be accounted for. Technically that's not correct, but the local\n        // shadows give that illusion... kind of.\n        dist += clamp(h, .2, stepDist); // For this example only. Not to be trusted. :)\n        \n        // There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if (abs(h)<0.001 || dist > end) break; \n    }\n\n    // I usually add a bit to the final shade value, which lightens the shadow a bit. It's a preference thing. Really dark shadows \n    // look too brutal to me.\n    return min(max(shade, 0.) + .1, 1.); \n}\n\n\n\n\n\n// Ambient occlusion, for that self shadowed look. Based on the original by XT95. I love this \n// function. For a better version, and usage, refer to XT95's examples below:\n//\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\nfloat calculateAO( in vec3 p, in vec3 n)\n{\n\tfloat ao = 0.0, l;\n\tconst float nbIte = 6.0;\n    const float maxDist = 3.;\n\t//const float falloff = 0.9;\n    for(float i=1.; i< nbIte+.5; i++ ){\n    \n        l = (i*.66 + hash(i)*.34)/nbIte*maxDist;\n        \n        ao += (l - map( p + n*l ))/(1.+ l);// / pow(1.+l, falloff);\n    }\n\t\n    return clamp( 1.-ao/nbIte, 0., 1.);\n}\n\n\n// Just a single color. I debated over whether to include the sun, but the dust is there and I'm saving cycles.\nvec3 getSky(){ return vec3(2., 1.4, .7); }\n\n\n/////\n// Code block to produce three layers of fine dust. Not sophisticated at all.\n// If you'd like to see a much more sophisticated version, refer to Nitmitz's\n// Xyptonjtroz example. Incidently, I wrote this off the top of my head, but\n// I did have that example in mind when writing this.\nfloat trig3(in vec3 p){\n    p = cos(p*2. + (cos(p.yzx) + 1.)*1.57);// + iTime*1.\n    return dot(p, vec3(0.1666)) + 0.5;\n}\n\n// Basic low quality noise consisting of three layers of rotated, mutated \n// trigonometric functions. Needs work, but it's OK for this example.\nfloat trigNoise3D(in vec3 p){\n\n    // 3D transformation matrix.\n    const mat3 m3RotTheta = mat3(0.25, -0.866, 0.433, 0.9665, 0.25, -0.2455127, -0.058, 0.433, 0.899519 )*1.5;\n  \n\tfloat res = 0.;\n\n    float t = trig3(p*3.14159265);\n\tp += (t);\n    p = m3RotTheta*p;\n    //p = (p+0.7071)*1.5;\n    res += t;\n    \n    t = trig3(p*3.14159265); \n\tp += (t)*0.7071;\n    p = m3RotTheta*p;\n     //p = (p+0.7071)*1.5;\n    res += t*0.7071;\n\n    t = trig3(p*3.14159265);\n\tres += t*0.5;\n\t \n\treturn res/2.2071;\n}\n\n// Hash to return a scalar value from a 3D vector.\nfloat hash31(vec3 p){ return fract(sin(dot(p, vec3(127.1, 311.7, 74.7)))*43758.5453); }\n\n// Very few layers of cheap trigonometric noise to produce some subtle mist.\n// Start at the ray origin, then take four samples of noise between it\n// and the surface point. Apply some very simplistic lighting along the \n// way. It's not particularly well thought out, but it doesn't have to be.\nfloat getMist(in vec3 ro, in vec3 rd, in vec3 lp, in float t){\n\n    float mist = 0.;\n    ro += rd*t/3.; // Edge the ray a little forward to begin.\n\n    \n    for (int i = 0; i<3; i++){\n        // Lighting. Technically, a lot of these points would be\n        // shadowed, but we're ignoring that.\n        float sDi = length(lp-ro)/FAR; \n\t    float sAtt = 1./(1. + sDi*0.1 + sDi*sDi*0.01);\n\t    // Noise layer.\n        mist += trigNoise3D(ro/2.)*sAtt;//trigNoise3D\n        // Advance the starting point towards the hit point.\n        ro += rd*t/3.;\n    }\n    \n    // Add a little noise, then clamp, and we're done.\n    return clamp(mist/1.5 + hash31(ro)*0.1-0.05, 0., 1.);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\t\n\n\n\t\n\t// Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 ro = vec3(0, 0, iTime*8.); // Camera position, doubling as the ray origin.\n\tvec3 lookAt = ro + vec3(0, 0, .5);  // \"Look At\" position.\n \n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera and \"look at\" vectors down the tunnel. The \"path\" function is \n\t// synchronized with the distance function.\n\tro.xy += path(ro.z);\n\tlookAt.xy += path(lookAt.z);\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159265/2.5; // FOV - Field of view.\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(vec3(forward.z, 0, -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*u.x*right + FOV*u.y*up);\n    \n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    // Naturally, it's synchronized with the path in some kind of way.\n\trd.xy = rot2( path(lookAt.z).x/64. )*rd.xy;\n    \n\t\n    // Usually, you'd just make this a unit directional light, and be done with it, but I\n    // like some of the angular subtleties of point lights, so this is a point light a\n    // long distance away. Fake, and probably not advisable, but no one will notice.\n    vec3 lp = vec3(FAR*.5, FAR, FAR) + vec3(0, 0, ro.z);\n \n\n\t// Raymarching.\n    float t = trace(ro, rd);\n    \n   \n    // Sky. Only retrieving a single color this time.\n    vec3 sky = getSky();\n    \n    // The passage color. Can't remember why I set it to sky. I'm sure I had my reasons.\n    vec3 col = sky;\n    \n    // Surface point. \"t\" is clamped to the maximum distance, and I'm reusing it to render\n    // the mist, so that's why it's declared in an untidy postion outside the block below...\n    // It seemed like a good idea at the time. :)\n    vec3 sp = ro+t*rd; \n    \n    float pathHeight = sp.y-path(sp.z).y; // Path height line, of sorts.\n    \n    // If we've hit the ground, color it up.\n    if (t < FAR){\n    \n        \n        vec3 sn = normal( sp ); // Surface normal.\n        \n        // Light direction vector. From the sun to the surface point. We're not performing\n        // light distance attenuation, since it'll probably have minimal effect.\n        vec3 ld = lp-sp;\n        ld /= max(length(ld), 0.001); // Normalize the light direct vector.\n\n        \n        // Texture scale factor.        \n        const float tSize = 1./4.;\n        \n        // Function based bump mapping.\n        sn = doBumpMap(sp, sn, .75/(1. + t/FAR*.25));\n        \n        // Bump mapping with the pink sandstone texture to provide a bit of gritty detailing.\n        float bf = (pathHeight + 5. < 0.)?  .05: .025;\n        sn = doBumpMap(iChannel0, sp*tSize, sn, bf/(1. + t/FAR));\n        \n        \n        float shd = softShadow(sp, ld, 0.05, FAR, 8.); // Shadows.\n        float ao = calculateAO(sp, sn); // Ambient occlusion.\n        \n        float dif = max( dot( ld, sn ), 0.0); // Diffuse term.\n        float spe = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 5.); // Specular term.\n        float fre = clamp(1.0 + dot(rd, sn), 0.0, 1.0); // Fresnel reflection term.\n \n        // Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a sandstone consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.0);\n\t\tfloat fre2 = mix(.2, 1., Schlick);  //F0 = .2 - Hard clay... or close enough.\n       \n        // Overal global ambience. It's made up, but I figured a little occlusion (less ambient light\n        // in the corners, etc) and reflectance would be in amongst it... Sounds good, anyway. :)\n        float amb = ao*.125 + fre*fre2*.2;\n        \n        // Coloring the soil - based on depth. Based on a line from Dave Hoskins's \"Skin Peeler.\"\n        col = clamp(mix(vec3(1.152, 0.4275,.153), vec3(.225, 0.05985, 0.0153), -sn.y*.5 + pathHeight*.5 + 1.75), vec3(.9, 0.534375, 0.239), vec3(.9, .855, .765));\n        \n              \n        // Give the soil a bit of a sandstone texture.\n        col = smoothstep(-.5, 1., tex3D(iChannel0, sp*tSize, sn)*2.)*(col + vec3(.225, .21375, .19125));\n        \n        // Making the ground reflect just a little more to give the appearance of fine dust or sand...\n        // It's a work in progress. :)\n        col += smoothstep(0., 1., -pathHeight - 5.5)*fre*.25;\n \n        // A bit of sky reflection. Not really accurate, but I've been using fake physics since the 90s. :)\n        col += getSky()*fre*fre2; \n        \n        \n        \n        // Combining all the terms from above. Some diffuse, some specular - both of which are\n        // shadowed and occluded - plus some global ambience. Not entirely correct, but it's\n        // good enough for the purposes of this demonstation.        \n        col = (col*(dif + amb) + vec3(1)*fre2*spe)*shd*ao + amb*pow(col, vec3(2.));\n\n        \n    }\n    \n   \n    // Combine the scene with the sky using some cheap volumetric substance.\n\tfloat dust = getMist(ro, rd, lp, t)*(1.-clamp((pathHeight - 5.)*.125, 0., 1.));//(-rd.y + 1.);\n    sky = getSky()*mix(1., .75, dust);\n    col = mix(col, sky, min(t*t*1.5/FAR/FAR, 1.)); // Quadratic fade off. More subtle.\n    //col = mix(col, sky, min(t*.75/FAR, 1.)); // Linear fade. Much dustier. I kind of like it.\n\n    \n    // Standard way to do a square vignette. Note that the maxium value value occurs at \"pow(0.5, 4.) = 1./16,\" \n    // so you multiply by 16 to give it a zero to one range. This one has been toned down with a power\n    // term to give it more subtlety.\n    u = fragCoord/iResolution.xy;\n    col = min(col, 1.)*pow( 16.0*u.x*u.y*(1.0-u.x)*(1.0-u.y) , .125);\n \n    // Done.\n\tfragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}