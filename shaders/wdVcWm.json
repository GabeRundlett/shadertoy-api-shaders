{
    "Shader": {
        "info": {
            "date": "1603063471",
            "description": "Loosely Inspired by Nathan Riley. I believe a Ruby have more value than a credit card, at least for mine :)\nhttps://dribbble.com/shots/14236753-Letter-Card",
            "flags": 0,
            "hasliked": 0,
            "id": "wdVcWm",
            "likes": 43,
            "name": "Ruby in a crystal",
            "published": 3,
            "tags": [
                "raytracing",
                "refraction",
                "sphere",
                "box",
                "diffraction",
                "reproduction"
            ],
            "usePreview": 0,
            "username": "xjorma",
            "viewed": 1223
        },
        "renderpass": [
            {
                "code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n#if HW_PERFORMANCE==0\n#else\n#define AA\n#endif\n\n#define MAX_DIST\t\t5.\n#define PI              radians(180.)\n#define TAU             radians(360.)\n#define MAX_BOUNCES     7\n\n#define GAMMA\t\t\t0\n\nfloat map(in vec3 p, out vec3 absorb, out vec3 refcol)\n{\n    float id  = fDodecahedron(p, 0.8);\n    float od = fDodecahedron(p, 0.805);\t\t\t// Horrible hack, not very proud of this, but to fix that the proper way I have to rethink the render loop to handle inter material transition, also I am not sure how to make it work with ray matching. \n    float oi = fIcosahedron(p, 1.5);\n\n    float d = min(max(oi, -od), id);\n    if (d == id)\n    {\n        absorb = vec3(0, 1, 1) * 10.;\n        refcol = vec3(1,0.5,0.5);\n    }\n    else\n    {\n        absorb = vec3(0);\n        refcol = vec3(1);\n    }\n    return d;\n}\n\nvec3 getSkyColor(vec3 rd)\n{\n    vec3 col = texture(iChannel0, rd).rgb;\n    #if GAMMA\n    \tcol = pow(col, vec3(2.2));\n    #endif\n    return col;\n}\n\nvec3 normal(in vec3 pos)\n{\n    vec3\t_absorb;\n    vec3\t_refcolor;\n    vec2\teps = vec2(0.0001, 0);\n\tfloat\td = map(pos, _absorb, _refcolor);\n\treturn normalize(vec3(map(pos + eps.xyy, _absorb, _refcolor) - d, map(pos + eps.yxy, _absorb, _refcolor) - d, map(pos + eps.yyx, _absorb, _refcolor) - d));\n}\n\n\nfloat rayMarch(in float sgn, in vec3 ro, in vec3 rd, in float offT, out vec3 absorb, out vec3 refcolor)\n{\n  float t = offT;\n  for (int i = 0; i < 40; i++)\n  {\n    float h = sgn * map(ro + rd*t, absorb, refcolor);\n    if (h < 0.002 || t > MAX_DIST)\n        break;\n    t += h;\n  }\n  return t;\n}\n\n\nvec3 Render(in vec3 ro, in vec3 rd, in float cref)\n{\n    float sgn = 1.;\n    vec3  rel = vec3(1);\n    vec3  col = vec3(0);\n    float transp = 1.;\n    for(int i = 0; i < MAX_BOUNCES; i++)\n    {\n        vec3\tabsorb;\n        vec3\trefcolor;\n        float t = rayMarch(sgn, ro, rd, 0.02, absorb,refcolor);\n        if( t> MAX_DIST)\n        {\n            col += rel * getSkyColor(rd);\n            break;\n        }\n        vec3 rabs = mix(absorb, vec3(0), (sgn + 1.) / 2.);\n        vec3 beerlamb = exp(-rabs * t);\n        vec3 p = ro + rd * t;\n        vec3 n = sgn * normal(p);\n        vec3 refl = reflect(rd, n);\n        vec3 refr = refract(rd, n, cref);\n        //float fresnel = 1.0 - pow(dot(n, -rd), 2.);\n        float fresnel = pow(1.0 - abs(dot(n, rd)), 2.);\n        float reflectorFactor = mix (0.2, 1., fresnel);\n        float refractionFactor = mix (transp, 0., fresnel);\n     \n    \tcol += (1.0 - refractionFactor) * rel * beerlamb * getSkyColor(refl) * refcolor * reflectorFactor;\n    \trel *= refractionFactor * beerlamb;     \n        \n       \tro = p;     \n        if (refr == vec3(0.0))\n        {\n            rd = refl;\n        }\n        else\n        {\n            rd = refr; \n            sgn *= -1.;\n            cref = 1. / cref;\n        }        \n    }\n    return col;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\nvec3 desaturate(in vec3 c, in float a)\n{\n    float l = dot(c, vec3(1. / 3.));\n    return mix(c, vec3(l), a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 tot = vec3(0.0);\n        \n#ifdef AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n \n        // camera\n        \n        float theta\t= radians(360.)*(iMouse.x/iResolution.x-0.5) + iTime*.2;\n        float phi\t= radians(90.)*(iMouse.y/iResolution.y-0.5)-1.;\n        vec3 ro = 4.*vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        //vec3 ro = vec3(0.0,.2,4.0);\n        vec3 ta = vec3( 0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        //vec3 cd = ca[2];    \n        \n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        \n        vec3 col;\n        float cbase = 0.8;\n        float cvar = 0.02;\n        col.r = Render(ro , rd, cbase - cvar).r;\n        col.g = Render(ro , rd, cbase).g;\n        col.b = Render(ro , rd, cbase + cvar).b;\n        \n\n        tot += col;\n            \n#ifdef AA\n    }\n    tot /= 4.;\n#endif\n\n    #if GAMMA\n    \ttot = pow(tot, vec3(1. / 2.2));\n    #endif\n    \n    tot = desaturate(tot, -0.2);\n    tot = vignette(tot, fragCoord / iResolution.xy, 1.2);\n    \n\tfragColor = vec4( sqrt(tot), 1.0 );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define PHI (sqrt(5.)*0.5 + 0.5)\n\n#define GDFVector3 normalize(vec3(1, 1, 1 ))\n#define GDFVector4 normalize(vec3(-1, 1, 1))\n#define GDFVector5 normalize(vec3(1, -1, 1))\n#define GDFVector6 normalize(vec3(1, 1, -1))\n\n#define GDFVector7 normalize(vec3(0, 1, PHI+1.))\n#define GDFVector8 normalize(vec3(0, -1, PHI+1.))\n#define GDFVector9 normalize(vec3(PHI+1., 0, 1))\n#define GDFVector10 normalize(vec3(-PHI-1., 0, 1))\n#define GDFVector11 normalize(vec3(1, PHI+1., 0))\n#define GDFVector12 normalize(vec3(-1, PHI+1., 0))\n\n#define GDFVector13 normalize(vec3(0, PHI, 1))\n#define GDFVector14 normalize(vec3(0, -PHI, 1))\n#define GDFVector15 normalize(vec3(1, 0, PHI))\n#define GDFVector16 normalize(vec3(-1, 0, PHI))\n#define GDFVector17 normalize(vec3(PHI, 1, 0))\n#define GDFVector18 normalize(vec3(-PHI, 1, 0))\n\n#define fGDFBegin float d = 0.;\n#define fGDF(v) d = max(d, abs(dot(p, v)));\n#define fGDFEnd return d - r;\n\nfloat fDodecahedron(vec3 p, float r) {\n    fGDFBegin\n    fGDF(GDFVector13) fGDF(GDFVector14) fGDF(GDFVector15) fGDF(GDFVector16)\n    fGDF(GDFVector17) fGDF(GDFVector18)\n    fGDFEnd\n}\n\nfloat fIcosahedron(vec3 p, float r) {\n    fGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n    fGDF(GDFVector11) fGDF(GDFVector12)\n    fGDFEnd\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}