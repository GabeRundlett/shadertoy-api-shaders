{
    "Shader": {
        "info": {
            "date": "1517409459",
            "description": "Comparison of Linearly Transformed Cosines to bruteforce path tracing (explicit light sampling)",
            "flags": 32,
            "hasliked": 0,
            "id": "Xt2fWK",
            "likes": 9,
            "name": "Linearly Transformed Cosines (X)",
            "published": 3,
            "tags": [
                "ltc"
            ],
            "usePreview": 1,
            "username": "sergey_reznik",
            "viewed": 1549
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "struct Plane \n{\n    vec3 center;\n    vec3 s;\n    vec3 t;\n    vec2 dim;\n    int material;\n};\n    \nstruct Ray\n{\n    vec3 origin;\n\tvec3 direction;\n};\n    \nstruct Sphere\n{\n    vec3 center;\n    float radius;\n};\n    \nstruct Material\n{\n    vec3 color;\n    vec3 emissive;\n};\n    \nstruct Light\n{\n    int plane;\n};\n    \nconst float PI = 3.1415926;\nconst vec2 lightSize = vec2(0.468, 0.378);\n\nbool raySphereIntersection(in Ray r, in Sphere s, out float t, out vec3 i, out vec3 n, out int m)\n{\n    vec3 dv = s.center - r.origin;\n\tfloat b = dot(r.direction, dv);\n\tfloat d = b * b - dot(dv, dv) + s.radius * s.radius;\n    bool intersects = (d >= 0.0);\n    if (intersects)\n    {\n\t\tt = b - sqrt(d);\n        i = r.origin + t * r.direction;\n        n = normalize(i - s.center);\n        m = 0;\n    }\n\treturn intersects;\n}\n\nbool rayPlaneIntersection(in Ray r, in Plane p, out float t, out vec3 i, out vec3 n, out int m)\n{\n    vec3 planeNormal = normalize(cross(p.t, p.s));\n\tfloat d = dot(r.direction, planeNormal);\n    bool intersects = (d <= 0.0f);\n    if (intersects)\n    {\n        m = p.material;\n        n = planeNormal;\n    \tt = dot(planeNormal, p.center - r.origin) / d;\n        i = r.origin + r.direction * t;\n        float ds = dot(p.center - i, p.s);\n        float dt = dot(p.center - i, p.t);\n        intersects = (abs(ds) <= p.dim.x) && (abs(dt) <= p.dim.y);\n    }\n    return intersects;\n}\n\nconst vec3 cameraPostiion = vec3(0.0, 1.0, 3.5);\nconst vec3 cameraTarget = vec3(0.0, 1.0, 0.0);\nconst vec3 cameraUp = vec3(0.0, 1.0, 0.0);\n\n#define materialsCount 5\nMaterial materials[materialsCount];\n\n#define planesCount 6\nPlane planes[planesCount];\n\n#define lightsCount 1\nLight lights[lightsCount];\n\nvoid populateMaterials();\nvoid populatePlanes();\n\nvec3 shade(in vec3 position, in vec3 normal, in vec3 view, in int materialId);\nvec3 toLinear(in vec3 srgb);\nvec3 toSRGB(in vec3 linear);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(0.025, 0.05, 0.075, 1.0);\n    \n    populateMaterials();\n    populatePlanes();\n    \n\tvec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    vec3 w = normalize(cameraTarget - cameraPostiion);\n    vec3 u = normalize(cross(w, cameraUp));\n    vec3 v = normalize(cross(u, w));\n    \n    Ray primaryRay;\n    primaryRay.origin = cameraPostiion;\n    primaryRay.direction = normalize(p.x * u + p.y * v + 2.5 * w);\n    \n    vec3 intersectionPoint;\n    vec3 intersectionNormal;\n    float minIntersectionDistance = 1000000.0;\n    int materialIndex = 0;\n    int objectIndex = 0;\n    \n    bool intersectionOccured = false;\n    for (int i = 0; i < planesCount; ++i)\n    {\n\t    vec3 p;\n    \tvec3 n;\n        int m;\n    \tfloat t = 0.0;\n        if (rayPlaneIntersection(primaryRay, planes[i], t, p, n, m))\n        {\n            if (t < minIntersectionDistance)\n            {\n                objectIndex = i;\n                materialIndex = m;\n                minIntersectionDistance = t;\n                intersectionNormal = n;\n                intersectionPoint = p;\n                intersectionOccured = true;\n            }\n        }\n    }\n    \n    if (intersectionOccured == false)\n        return;\n    \n    bool hitLight = false;\n    for (int i = 0; i < lightsCount; ++i)\n    {\n        if (lights[i].plane == objectIndex)\n        {\n            hitLight = true;\n            break;\n        }\n            \n    }\n    \n    if (hitLight)\n    {\n        fragColor.xyz = materials[materialIndex].emissive;\n        return;\n    }\n    \n\tfragColor.xyz = toSRGB(shade(intersectionPoint, intersectionNormal, primaryRay.direction, materialIndex));\n}\n\nMaterial makeMaterial(in vec3 d, in vec3 e)\n{\n    Material m;\n    m.color = d;\n    m.emissive = e;\n    return m;\n}\n\nvoid populateMaterials()\n{\n\tfloat lightArea = lightSize.x * lightSize.y;\n    \n\tmaterials[0] = makeMaterial(vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 0.0));   \n\tmaterials[1] = makeMaterial(vec3(0.05, 1.0, 0.05), vec3(0.0, 0.0, 0.0));   \n\tmaterials[2] = makeMaterial(vec3(1.0, 0.05, 0.05), vec3(0.0, 0.0, 0.0));   \n\tmaterials[3] = makeMaterial(vec3(0.0, 0.0, 0.0), vec3(15.0, 15.0, 15.0));\n}\n\nPlane makePlane(in vec3 c, in vec3 s, in vec3 t, in vec2 d, in int m)\n{\n    Plane p;\n    p.center = c;\n    p.s = normalize(s);\n    p.t = normalize(t);\n    p.dim = d / 2.0;\n    p.material = m;\n    return p;\n}\n\nvoid populatePlanes()\n{\n    planes[0] = makePlane(vec3( 0.0,  0.0,  0.0), vec3( 1.0,  0.0, 0.0), vec3(0.0, 0.0, 1.0), vec2(2.0, 2.0), 0); // floor\n    planes[1] = makePlane(vec3( 0.0, +2.0,  0.0), vec3(-1.0,  0.0, 0.0), vec3(0.0, 0.0, 1.0), vec2(2.0, 2.0), 0); // ceil\n    planes[2] = makePlane(vec3( 0.0,  1.0, -1.0), vec3(-1.0,  0.0, 0.0), vec3(0.0, 1.0, 0.0), vec2(2.0, 2.0), 0); // back\n    planes[3] = makePlane(vec3( 1.0,  1.0,  0.0), vec3( 0.0,  1.0, 0.0), vec3(0.0, 0.0, 1.0), vec2(2.0, 2.0), 1); // right\n    planes[4] = makePlane(vec3(-1.0,  1.0,  0.0), vec3( 0.0, -1.0, 0.0), vec3(0.0, 0.0, 1.0), vec2(2.0, 2.0), 2); // left\n    planes[5] = makePlane(vec3( 0.0, +1.998, 0.0), vec3(-1.0,  0.0, 0.0), vec3(0.0, 0.0, 1.0), lightSize, 3); // light\n    \n    lights[0].plane = 5;\n}\n\n/*\n *\n * shading happens here\n *\n */\nvec3 toLinear(in vec3 srgb)\n{\n    return pow(srgb, vec3(2.2));\n}\n    \nvec3 toSRGB(in vec3 linear)\n{\n    return pow(linear, vec3(1.0/2.2));\n}\n\nfloat integrateLTC(in vec3 v1, in vec3 v2)\n{\n    float cosTheta = dot(v1, v2);\n    float theta = acos(cosTheta);    \n    return cross(v1, v2).z * ((theta > 0.001) ? theta / sin(theta) : 1.0);\n}\n\nvec3 mul(in mat3 m, in vec3 p)\n{\n    return m * p;\n}\n\nfloat evaluateLTC(in vec3 position, in vec3 normal, in vec3 view, in vec3 points[4])\n{\n    vec3 t1 = normalize(view - normal * dot(view, normal));\n    vec3 t2 = cross(normal, t1);\n\n    mat3 Minv = transpose(mat3(t1, t2, normal));\n\n    vec3 L[4];\n    L[0] = normalize(mul(Minv, points[0] - position));\n    L[1] = normalize(mul(Minv, points[1] - position));\n    L[2] = normalize(mul(Minv, points[2] - position));\n    L[3] = normalize(mul(Minv, points[3] - position));\n\n    float sum = 0.0;\n    sum += integrateLTC(L[0], L[1]);\n    sum += integrateLTC(L[1], L[2]);\n    sum += integrateLTC(L[2], L[3]);\n\tsum += integrateLTC(L[3], L[0]);\n    return max(0.0, sum); \n}\n\nvec3 sampleLight(in vec3 p[4], in vec4 rnd)\n{\n    vec3 pt = mix(p[0], p[1], rnd.x);\n    vec3 pb = mix(p[3], p[2], rnd.x);\n    return mix(pt, pb, rnd.y);\n}\n\nvec3 shade(in vec3 position, in vec3 normal, in vec3 view, in int materialId)\n{\n    vec4 rnd = texture(iChannel0, 100.0 * (normal.xy + position.y * view.yx - position.xz) + iTime);\n    \n\tfloat lightArea = lightSize.x * lightSize.y;\n    Plane lightPlane = planes[lights[0].plane];\n    Material lightMaterial = materials[lightPlane.material];\n    vec3 materialColor = materials[materialId].color;\n    vec3 lightColor = lightMaterial.emissive;\n    vec3 lightNormal = normalize(cross(lightPlane.s, lightPlane.t));\n    vec3 lightPoints[4];\n    lightPoints[0] = lightPlane.center + lightPlane.s * lightPlane.dim.x - lightPlane.t * lightPlane.dim.y;\n    lightPoints[1] = lightPlane.center + lightPlane.s * lightPlane.dim.x + lightPlane.t * lightPlane.dim.y;\n    lightPoints[2] = lightPlane.center - lightPlane.s * lightPlane.dim.x + lightPlane.t * lightPlane.dim.y;\n    lightPoints[3] = lightPlane.center - lightPlane.s * lightPlane.dim.x - lightPlane.t * lightPlane.dim.y;\n    \n    vec3 l = normalize(lightPlane.center - position);\n    float lambert = dot(normal, l) / PI;\n    \n    float ltc = evaluateLTC(position, normal, view, lightPoints) / (2.0 * PI);\n    \n    float bruteforced = 0.0;\n    const int samples = 500;\n    for (int i = 0; i < samples; ++i)\n    {\n        vec3 pl = sampleLight(lightPoints, rnd) - position;\n\t\tfloat DdotL = dot(pl, lightNormal);\n        float LdotN = dot(pl, normal);\n        if ((LdotN > 0.0) && (DdotL > 0.0))\n        {\n    \t    float distanceSquared = dot(pl, pl);\n            float distanceToPoint = sqrt(distanceSquared);\n            float pdf = distanceSquared / (DdotL / distanceToPoint * lightArea);\n            float bsdf = 1.0 / PI;\n        \tbruteforced += bsdf / pdf * (LdotN / distanceToPoint);\n        }\n    \trnd = texture(iChannel0, rnd.xz + 23.0 * rnd.yx);\n    }\n    bruteforced /= float(samples);\n    \n    return lightColor * materialColor * ltc; // abs(ltc - bruteforced);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}