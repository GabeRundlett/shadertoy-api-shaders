{
    "Shader": {
        "info": {
            "date": "1491795833",
            "description": "Fast circle-circle-tangent-distanceFunction:\nbranch-less version of https://www.shadertoy.com/view/4ld3WS   <- does not use ifb(a,b,c) substitution //for if(a<0.){return b;}else{return c;} ->\n#define ifb(a,b,c) (b+(c-b)*step(a,0.))",
            "flags": 0,
            "hasliked": 0,
            "id": "4sBcWh",
            "likes": 15,
            "name": "branchless circle-Tangents",
            "published": 3,
            "tags": [
                "2d",
                "atan",
                "branchless",
                "pill",
                "capsule",
                "tangent",
                "seesaw",
                "limb",
                "lever",
                "kinematic",
                "muscle",
                "bisymmetry",
                "tangentcapsule"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 1326
        },
        "renderpass": [
            {
                "code": "//https://www.shadertoy.com/view/4sBcWh this is a union of\n//https://www.shadertoy.com/view/MdfcRj   2% <- making branching code branchless.\n//https://www.shadertoy.com/view/4ld3WS  97% <- BRANCHING tangent to 2 circles:\n//                                        1% <- substitutions rot2()<-r2() && structure\n//a rounder version of this is \"earVagEgg()\" search for it!\n\n\n//calculate a circle-circle tangent with focus on efficiency, Seeaws visualize distance,\n//unifying 3 distance functions of; a tangential-line-segment and 2-circles; \n//into one TangentCapsule(). \n//http://mathworld.wolfram.com/Circle-CircleTangents.html\n//https://en.wikipedia.org/wiki/Tangent_lines_to_circles\n//\n//\"capsule\" is a geometrically better description than \"pill\"\n//\n//TangentCapsule() returns distance to a capsule with 2 radii.\n//\"tangent\"-> trickier than a trapezoid with 2 half circles on the parallel ends.\n//you can also describe it as a most-rounded-triangle, that usually converts linear to circular motion.\n//base function for limb/muscle/branch or steam-engine-lever like parts.\n//Kinematic objects usually have one thick and one thin round part with a tangent to transfer energy\n//...to keep angular momentum low at the thinner end that rotates around further.\n//For kinematic systems, The Large-circle-center is placed at (0,0) as far as TangentCapsule() LOCAL coordinates care.\n//TangentCapsule() only cares for the 1 positive tangent in 2d, you have to use/break symmetry to extrude or rotate this 2d shape:\n//rotate (2 dimensions of) input value p of TangentCapsule(p,vec3 scales) by doing: p.xy*=rot2(rotation_in_radians)\n//left circle h.x should always be larger than right circle h.y and not conpletely contain the right circle: h.z>h.x-h.y\n//because that defeats the purpose of the TangentCapsule() function by having no tangent\n//\n//by ollj, free use.\n\n//optional: show tangent intersections. You do not want this in your use case.\n#define debug_show_intersections\n\n//return a 2d rotation matrix set by rotation in radians\n//mat2 rot2(float r){float c=cos(r),s=sin(r);return mat2(c,s,-s,c);}\n//return matrix that mirrors on an axis that is rotated by [r*.5] radians\n#define r2(r) mat2(sin(r+vec4(1,0,0,-1)*asin(1.)))\n\nfloat at(float y,float x){ //I fail to use at() in line 63 instead of using atan(y,x)\n float a=atan(y/x),p=asin(1.);//ttherefore i reduced this atan2(y,x) to atan(y,x)\n //if(x>0.)\n     return    a;\n //if(y>0.)return  p-a;//atan2() unique case\n //if(y<0.)return -p-a;//atan2() unique case\n //        return  a-p; //overwriting the undefined (x=y=0) case with this one.\n}//unbranching atan2(y,x):see doc: https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/atan.xhtml\n//see branching of atan2():        https://en.wikipedia.org/wiki/Atan2\n\n//return f[x] of a SeeSaw curve with [w]avelength and [a]mplitude; returns range [0..amp]\n#define SeeSaw(x,w,a) (mod(x,w)*a)\n//set [a]mplitude = 1/[w]avelength\n#define SeeSaw2(x,w) SeeSaw(x,w,1./w)\n\n//sdline() is a subroutine for TangentCapsule(), it resolves a branching condition;\n//... Point [p] is either closest to one of the 2 circles, or closest to the tangent between the circles.\n//a and b are tangent intersection points.\n//sdline() calculates 2 lines that are orthogonal to a line trough a and b, and that goes trough a, or b.\n//this creates 3 endless lines in a \"H\"-shaped-formation. Point [p] is in one of the 3 areas. \n//sdline() tells the code after it, in what area of that \"H\"-shape [p] is.\n//\n//return signed distance of [p] to a line that goes trough [a] and is orthogonal to a line trough [a] and [b].\n//float sdlineOLD(vec2 p,vec2 a,vec2 b){mat2 m=r2(acos(-1.)-atan(b.x-a.x,b.y-a.y));p*=m;a*=m;return p.y-a.y;}\n//above is backup of optimiztion below\n#define vas vec2(0.,asin(1.))\nfloat sdline(vec2 p,vec2 a,vec2 b){vec2 c=b-a;\n vec2 m=vec2(sin(atan(c.x,c.y)+vas));return dot(p,m)-dot(a,m);}\n\n//...rotate p around (h.z,0,0) by -quaterRotation-atan(b.x,b.y) and only return .y\n//float qOLD(vec2 p,vec3 h,vec2 b){//should do the same as q(), using matrices for no good reason\n// vec2 c=(vec2(p.x-h.z,p.y)-b)*r2(-asin(1.)-atan(b.x,b.y));return c.y-h.y;}\n//above is backup of optimiztion below\nfloat q(vec2 p,vec3 h,vec2 b){\n return dot( p+vec2(-h.z,0.) , sin(at(-b.y,b.x)+vas) )-h.y;}\n\n//return circle-circle-intersection.x; r.x=circle.left.radius;r.y=circle.right.radius;r.z=circles-centers.distance\nfloat cci(vec3 r){float d=r.z*2.;r*=r;return(r.x-r.y+r.z)/d;}\n//does not check for non-intersecticn cases! intersection.y is not important here.\n\n//alias to make branching conditionals be calculated as non branching:\n#define ifb(a,b,c) (b+(c-b)*step(a,0.))\n//ifb(a,b,c) ::is \"identical\" to:: if(a<0.){return b;}else{return c;} ::but branchless:\n\n//return distace of p to cylinder with rounded caps;\nfloat TangentCapsule(vec2 p,vec3 h){h.x=max(h.x,h.y);//cheap safeguard enforces constrains\n//h.x=left radius, h.y=right radius; h.z distance.x between sphere centers  \n//h.x>=h.y>0.0 ! h.z>=h.x-h.y, else there is no tangent, and this function comes down to \"distance to 2 circles\".\n p.y=abs(p.y);//ALMOST optional: mirror symmetry on tangent.\n float s=h.x-h.y,i=cci(vec3(s,vec2(h.z*.5)));//this is why h.x>h.y!\n vec2 a=vec2(i,sqrt(s*s-i*i)),//a is the left boundary point between larger circle and cone. \n b=vec2(h.z,0)-a;//b is \"directional vector\"\n#ifdef debug_show_intersections\n vec2 n=normalize(vec2(b.y,-b.x));//very optional, even within this debugger.\n #define ap a-p-n*h.y)<.05)return 1.;\n if(length(ap if(length(b+ap//show tangent intersections for debug\n#endif\n #define ib ifb(-sdline(p,a\n float e=length(p-vec2(h.z,0))-h.y,f=length(p            )-h.x,\n      g=ib+b,a-b),e,q(p,h,b));\n return ib  ,a+b),f,g); \n}//if this is ugly, there is an if-branching variant here: https://www.shadertoy.com/view/4ld3WS\n                          \n#define res iResolution.xy\nvoid mainImage(out vec4 r,in vec2 i){r.a=1.;\n vec2 p=i.xy/min(res.x,res.y);//.xy screenPosition\n p-=vec2(.7,.5); p*=2.5;   //optional: view offset; view zoom;\n p*=r2(iTime);       //optional; rotation of view.\n float s=sin(iTime); //sinusoid over time\n float t=sin(199.+s*.3)+.5;//swivel over time for 3 color dimensions displaying 3 SDF\n #define sinP(t) (sin(t)*.5+.5) /*scaled sinusoid*/\n vec3 h=vec3(sinP(iTime*3.)*.4+.4,.3,1.2+s*.4);//h defines a cylinder with rounded top and bottom\n vec3 c=vec3(TangentCapsule(p,h));//TangentCapsule() function is demoed here\n //c.rgb stores the same float distance to a shape, 3 times, to be colored below:\n c.g=SeeSaw2(c.r          ,t);//green <- distance to whole thing (2 circles and tangent)\n c.b=SeeSaw2(length(p)-h.x,t);p.r-=h.z;//blue y- distance to left circle, radius h.x, center at (0,0)\n c*=1.-step(c.r,0.)*.9;//optional: negative distanance -> dark red.\n c.r=SeeSaw2(length(p)-h.y,t);//red <- distance to right circle, radius h.y center at (0,h.z)\n if(abs(c.g)<.04)c*=vec3(.5);//dark border line\n r.rgb=vec3(c);}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}