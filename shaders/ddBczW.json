{
    "Shader": {
        "info": {
            "date": "1687897670",
            "description": "Julia set test",
            "flags": 0,
            "hasliked": 0,
            "id": "ddBczW",
            "likes": 2,
            "name": "Test julia set",
            "published": 3,
            "tags": [
                "juliaset"
            ],
            "usePreview": 0,
            "username": "Elyades",
            "viewed": 150
        },
        "renderpass": [
            {
                "code": "float PI = 3.14159265358979323846;\nfloat TWOPI = 6.28318530718;\nfloat PIONTWO = 1.57079632679;\n\nfloat norm(vec2 uv)\n{\n    return(float(uv.x*uv.x + uv.y*uv.y));\n}\n\nfloat atan2(float y, float x)\n{\n    //this computes arctan(y/x)\n    float angle = atan(y,x);\n    if(angle < 0.0){angle+= TWOPI;}\n    return(angle);\n}\n\nvec2 exp2d(vec2 uv)\n{\n    return( exp(uv.x)*vec2(cos(uv.y),sin(uv.y)));\n}\n\n\n\nvec2 log2d(vec2 uv)\n{\n    return(vec2(log(length(uv)),atan2(uv.y,uv.x)));\n}\n\nvec2 power(vec2 uv, float n)\n{\n    float modulus = length(uv);\n    float angle = atan2(uv.y,uv.x);\n    angle *= n;\n    \n    return( exp(n*log(modulus))*vec2(cos(angle),sin(angle)));\n}\n\nvec2 times (vec2 z1, vec2 z2)\n{\n    return vec2(z1.x*z2.x - z1.y*z2.y , z1.x*z2.y + z1.y*z2.x);\n}\n\nvec2 oneoverz(vec2 uv)\n{\n    float squaremodulus = norm(uv);\n    return( vec2(uv.x/squaremodulus, -uv.y/squaremodulus) );\n}\n\nvec2 power2d(vec2 uv, vec2 z)\n{\n    \n    return( exp2d(times(vec2(log(length(uv)),atan2(uv.y,uv.x)),z) ) );\n}\n\nvec2 cos2d(vec2 uv)\n{\n    return(vec2(0.5*( exp2d(times(uv,vec2(0.0,1.0))) + exp2d(times(-uv,vec2(0.0,1.0))))));\n}\n\n\nvec2 sin2d(vec2 uv)\n{\n    return(times(0.5*( exp2d(times(uv,vec2(0.0,1.0))) - exp2d(times(-uv,vec2(0.0,1.0)))),vec2(0.0,1.0)));\n}\n\nvec2 function(vec2 uv,vec2 c)\n{    \n    vec2 result = tan(atan2(uv.y,uv.x))+c;\n    return result;\n}\n\nvec3 palette2( float t ) {\n    //by Inigo Quilez\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(1.0,1.0,1.0);\n    vec3 d = vec3(0.0,0.1,0.2);\n\n    return vec3(a + b*cos(6.28318530718*(c*(t) + d)));\n}\n\nvec3 palette5(float iteration)\n{\n    float value = 0.8;\n    vec3 a = vec3(value);\n    vec3 b = vec3(1.0-value);\n    vec3 c = vec3(2.0,1.0,1.0);\n    vec3 d = vec3(0.3,0.0,0.0);\n    \n    return (a + b*cos(TWOPI*(c*iteration + d)));\n}\n\nvec2 functionPolar(vec2 uv)\n{\n    float n = 3.0;\n    vec2 c = vec2(0.1,-0.8);\n    vec2 result;\n    result.x = pow(uv.x,n);\n    result.y = n*uv.y;\n    return result;\n}\n\nvec2 cartesianToPolar(vec2 uv)\n{\n    float r = length(uv);\n    float theta = atan(uv.y,uv.x);\n    return vec2(r,theta);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    //Offset\n    uv = uv - 0.5;\n    uv.x += 0.0;\n    \n    //Scale\n    uv *= 10.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n     //Choosing the Zoom\n    vec2 zoomPoint = vec2(-0.0,0.0);\n    \n    //Zoom\n    float zoomAmount = min(1.0,1.0/pow(max(iTime-3.0,1.0),3.0));\n    uv = uv*zoomAmount;\n    uv += zoomPoint;\n    \n    // Algorithm to color the pixel\n    float tol = pow(10.0,-6.0);\n    \n    \n    float DistanceToPrevious = 1.0;\n    float currentModulus = length(uv);\n    vec2 previousIteration;\n    int iterationAmount;\n    int testAmount = 1000;\n    \n    //vec2 c = 3.0*(iMouse.xy/iResolution.xy - 0.5);\n    vec2 c = uv;\n    \n    for (iterationAmount = 0; iterationAmount < testAmount; iterationAmount++)\n    {\n        previousIteration = uv;\n        uv = function(uv,c);\n        currentModulus = length(uv);\n        DistanceToPrevious = length(uv - previousIteration);\n        \n        if(DistanceToPrevious < tol){break;}\n        if(currentModulus > 3.0){break;}\n    }\n    \n    \n    \n    if(currentModulus < 3.0)\n    {\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n    }\n    \n    else\n    {\n            iterationAmount *= 5;\n            int periodFast = 5;\n            int residueFast = iterationAmount%periodFast;\n            float indexFast = float(residueFast)/float(periodFast);\n            vec3 colorFast = palette5(indexFast);\n            \n            int periodMedium = 20;\n            int residueMedium = iterationAmount%periodMedium;\n            float indexMedium = float(residueMedium)/float(periodMedium);\n            vec3 colorMedium = palette5(indexMedium);\n            \n            int periodSlow = 50;\n            int residueSlow = iterationAmount%periodSlow;\n            float indexSlow = float(residueSlow)/float(periodSlow);\n            vec3 colorSlow = palette5(indexSlow);\n           \n            float finalIndex = (indexSlow + indexMedium + indexFast)*0.333333333;\n            vec3 finalColor = (colorSlow + colorMedium + colorFast)*0.3333333333;\n            fragColor = vec4(finalColor,1.0);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}