{
    "Shader": {
        "info": {
            "date": "1643890479",
            "description": "Motivated by Escher's artwork \"three worlds\", try to combine spherical, Euclidean, hyperbolic geometry in one scene. See three worlds through the mirrors at the same time.",
            "flags": 0,
            "hasliked": 0,
            "id": "ss2cz3",
            "likes": 23,
            "name": "Neo three worlds",
            "published": 3,
            "tags": [
                "3d",
                "escher",
                "geometry",
                "tiling",
                "polyhedra",
                "hyperbolic",
                "wythoff"
            ],
            "usePreview": 1,
            "username": "neozhaoliang",
            "viewed": 605
        },
        "renderpass": [
            {
                "code": "vec3 get_floor_color(vec2 z) {\n    // Modify P, Q, R to change the tiling\n    const float P = 2.;\n    const float Q = 3.;\n    const float R = 7.;\n    const float cp = cos(PI / P), sp = sin(PI / P);\n    const vec2 mB = vec2(-cp, sp);\n    const float k1 = cos(PI / Q);\n    const float k2 = (cos(PI / R) + cp * k1) / sp;\n    const float rad = 1. / sqrt(k1 * k1 + k2 * k2 - 1.);\n    const vec2 cen = vec2(k1 * rad, k2 * rad);\n    const vec2 v0 = vec2(0, cen.y - sqrt(rad * rad - cen.x * cen.x));\n    const vec2 n_ = vec2(-mB.y, mB.x);\n    const float b_ = dot(cen, n_);\n    const float c_ = dot(cen, cen) - rad * rad;\n    const float k_ = b_ + sqrt(b_ * b_ - c_);\n    const vec2 m0 = k_ * n_;\n\n    vec2 p = square_to_disc(z);\n    vec2 invCtr = vec2(1);\n    float t = 1. / dot(p -invCtr, p - invCtr);\n    p = mix(invCtr, p, t);\n    p.x = -p.x;\n    p = rot2(iTime/12.)*p;\n\n    if (length(p) > 1.)\n        p /= dot(p, p);\n\n    float count = 0.;\n    for (int i = 0; i < MAX_TILING_REFLECTIONS; i++) {\n        if (p.x < 0.) {\n            p.x = -p.x;\n            count += 1.;\n        }\n        float k = dot(p, mB);\n        if (k < 0.) {\n            p -= 2. * k * mB;\n            count += 1.;\n        }\n        \n        float d = length(p - cen) - rad;\n        if (d < 0.) {\n            p -= cen;\n            p *= rad * rad / dot(p, p);\n            p += cen;\n            count += 1.;\n        }\n    }\n    \n    float ln = 1e5, ln2 = 1e5, pnt = 1e5;\n    ln = min(ln, lBox(p, vec2(0), v0, .007));    \n    ln = min(ln, lBox(p, vec2(0), m0, .007));\n    ln = min(ln, length(p - cen) - rad - 0.007);\n\n    ln2 = min(ln2, lBox(p, vec2(0), m0, .007));\n    pnt = min(pnt, length(p - v0)); \n    pnt = min(pnt, length(p - m0)); \n    \n    float sf = 2. / iResolution.y;\n    float rnd = smoothstep(.8, .97, sin(iTime*.5 + count)*.5 + .5);\n        \n    vec3 oCol = .55 + .45*cos(count * PI / 4. + vec3(0, 1, 2));\n    oCol = mix(oCol*.1, clamp(oCol*3.5, 0., 1.), rnd);\n     \n    float pat = smoothstep(0., .25, abs(fract(ln2*50. - .2) - .5)*2. -.2);\n   \n    float sh = clamp(.65 + ln/v0.y*4., 0., 1.);\n    vec3 col = min(oCol*(pat*.2 + .9)*sh, 1.);\n\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln));\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, -(ln - BlackRegionSize)));\n\n    pnt -= .032;\n    pnt = min(pnt, length(p) - .032);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, pnt));\n    \n    rnd = smoothstep(.8, .97, sin(iTime * 1.5)*.5 + .5);\n    vec3 blink = vec3(1.3, 0.25, 0.35);\n    blink = mix(blink * 0.5, blink * 2.2, rnd);\n    col = mix(col, blink, 1. - smoothstep(0., sf, pnt + .02));\n    return col;\n}\n\nvec3 get_ceil_color(vec2 p) {\n    const float P = 3.;\n    const float Q = 3.;\n    const float R = 3.;\n    const float cp = cos(PI / P), sp = sin(PI / P);\n    const float cq = cos(PI / Q), cr = cos(PI / R);\n    const vec2 mB = vec2(-cp, sp);\n    const vec3 mC = vec3(-cr, -(cq + cr * cp) / sp, 1.);\n    const vec2 v0 = vec2(0, -1./mC.y);\n    const float k_ = mB.x / mB.y;\n    const float x_ = 1. / (k_ * mC.y - mC.x);\n    const float y_ = -k_ * x_;\n    const vec2 m0 = vec2(x_, y_);\n    \n    p = rot2(iTime/12.)*p;\n\n    float count = 0.;\n    for (int i = 0; i < MAX_TILING_REFLECTIONS; i++) {\n        if (p.x < 0.) {\n            p.x = -p.x;\n            count += 1.;\n        }\n        float k = dot(p, mB);\n        if (k < 0.) {\n            p -= 2. * k * mB;\n            count += 1.;\n        }\n        \n        k = dot(vec3(p, 1.), mC);\n        if (k < 0.) {\n            p -= 2. * k * mC.xy;\n            count += 1.;\n        }\n    }\n    \n    float ln = 1e5, ln2 = 1e5, pnt = 1e5;\n    //ln = min(ln, lBox(p, vec2(0), v0, .05));    \n    //ln = min(ln, lBox(p, vec2(0), m0, .05));\n    ln = min(ln, lBox(p, v0, m0, .05));\n\n    ln2 = min(ln2, lBox(p, vec2(0), m0, .007));\n    pnt = min(pnt, length(p - v0)); \n    pnt = min(pnt, length(p - m0)); \n    \n    float sf = 2. / iResolution.y;\n    float rnd = smoothstep(.8, .97, sin(iTime + count * PI)*.5 + .5);\n        \n    vec3 oCol = .55 + .45*cos(count * PI / 8. + vec3(0, 1, 2)).yzx;\n    oCol = mix(oCol*.1, clamp(oCol*1.5, 0., 1.), rnd);\n     \n    float pat = smoothstep(0., .25, abs(fract(ln2*15. - .2) - .5)*2. -.2);\n   \n    float sh = clamp(.65 + ln/v0.y*4., 0., 1.);\n    vec3 col = min(oCol*(pat*.2 + .9)*sh, 1.);\n\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln));\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, -(ln - BlackRegionSize * 16.)));\n\n    pnt -= .15;\n    pnt = min(pnt, length(p) - .15);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, pnt));\n    \n    rnd = smoothstep(.4, .5, sin(iTime)*.5 + .5);\n    vec3 blink = vec3(1.3, 0.25, 0.35);\n    blink = mix(blink * 0.5, blink * 2.2, rnd);\n    col = mix(col, blink, 1. - smoothstep(0., sf, pnt + .02));\n    return col;\n}\n\n// distance to the four sides of mirrors \nfloat sdMirror(vec3 p) {\n    vec2 d = RoomSize.xz - abs(p.xz);\n    return min(d.x, d.y);\n}\n\n// the floor and the ceil\nfloat sdFloor(vec3 p) {\n    return RoomSize.y - abs(p.y);\n}\n\n// wood framework\nfloat sdRoomFrame(vec3 p) {\n    return sdBoxFrame(p, RoomSize, vec3(RoomFrameSize));\n}\n\nfloat sdMirrorFrame(vec3 p) {    \n    float d1 = sdBoxFrame(p, RoomSize, WindowFrameSize.xyy);\n    float d2 = sdBoxFrame(p, RoomSize, WindowFrameSize.yxy);\n    float d3 = sdBoxFrame(p, RoomSize, WindowFrameSize.yyx);\n    return min(d1, min(d2, d3));\n}\n\n// polyhedra with faces and edges\nvec2 sdPolyhedra(vec3 p) {\n    p *= RotObj;\n    p = fold_spherical(p);\n    p -= v0S;\n    float d1 = sdPolyhedraFaces(p);\n    float d2 = sdPolyhedraEdges(p);\n    float d = min(d1, d2);\n    float id = d1 < d2 ? 1. : 2.;\n    return vec2(d, id);\n}\n\nfloat sdScene(vec3 p) {\n    float d1 = sdMirror(p);\n    float d2 = sdFloor(p);\n    float d3 = sdRoomFrame(p);\n    float d4 = sdMirrorFrame(p);\n    float d5 = sdPolyhedra(p).x;\n    return min(d1, min(d2, min(d3, min(d4, d5))));\n}\n\nvec3 trace(vec3 pos, vec3 rd) {\n    float h = 1.0;\n    for (int i = 0; i < MAX_TRACE_STEPS; i++) {\n        if (h < PRECISION)\n            break;\n        h = sdScene(pos);\n        pos += rd * min(h, MAX_MARCH_STEP);\n    }\n    return pos;\n}\n\nfloat soft_shadow(vec3 pos, vec3 lp) {\n    const float softness = 16.;\n    const float shadowStartDistance = .1;\n    const int shadowLoopCount = 16;\n\n    vec3 ld = lp - pos;\n    float ldist = max(length(lp), 0.001);\n    ld /= ldist;\n    float epsilon = .001;\n    float t = shadowStartDistance;\n    float h = 1.;\n    float shade = 1.0;\n    for (int i=0; i < shadowLoopCount; i++ ) {\n        if (h < epsilon || t > ldist)\n            break;\n        h = sdScene(pos + ld * t);\n        shade = min(shade, smoothstep(0.0, 1.0, softness*h/t));\n        t += h;\n    }\n    return clamp(shade + 0.25, 0., 1.);\n}\n\nvec3 get_normal(vec3 p) {\n    const vec2 d = vec2(-1, 1) * .001;\n    return normalize(\n            sdScene(p + d.xxx)*d.xxx +\n            sdScene(p + d.yyx)*d.yyx +\n            sdScene(p + d.yxy)*d.yxy +\n            sdScene(p + d.xyy)*d.xyy);\n}\n\nstruct Light {\n    vec3 pos;\n    vec3 col;\n};\n\nLight lights[] = Light[] (\n    Light(vec3(2.5, 2.2, 2.5), vec3(1) * 5.),\n    Light(vec3(-1, -.5, -1), vec3(1)),\n    Light(vec3(-2.5,-1.9,-2.5), vec3(0, .3, 1))\n);\n\nvoid ray_bounce(in vec3 p,\n                in vec3 rd,\n                out vec3 diffuse,\n                out vec3 ref_dir,\n                out vec3 bounceTint,\n                in vec3 normal) {\n\n    vec3 bCol = vec3(0);\n    for( int i=0; i < lights.length(); i++ ) {\n        vec3 ld = lights[i].pos - p;\n        float ldist = max(length(ld), 0.001);\n        ld /= ldist;\n        float diff = max(0., dot(normal, ld));\n        float at = 1.5 / (1. + ldist * 0.3 + ldist * ldist * 0.1);\n        float sh = soft_shadow(p, lights[i].pos);\n        bCol += lights[i].col * sh * (.2 + diff) * at;\n    }\n    // ambient light\n    vec3 ao = vec3(.03,.05,.07);\n    // sample SDF to approximate occlusion\n    ao *= exp2(min(0., sdScene(p + normal * 0.3) / 0.3 - 1.));\n    ao *= exp2(min(0., sdScene(p + normal * .15) / .15 - 1.));\n    ao *= exp2(min(0., sdScene(p + normal * .07) / .07 - 1.));\n    bCol += ao;\n    \n    // https://www.shadertoy.com/view/tlBGR1\n    vec3 albedo = vec3(.3,.5,.6) * .4;\n    vec4 specLevel = vec4(0.9, 0.9, 0.9, 1);\n\n    float d1 = sdMirror(p);\n    float d2 = sdFloor(p);\n    float d3 = sdRoomFrame(p);\n    float d4 = sdMirrorFrame(p);\n    vec2 sdPoly = sdPolyhedra(p);\n    float d5 = sdPoly.x, id = sdPoly.y;\n    float d = min(d1, min(min(d2, d3), min(d4, d5)));\n    \n    if (d == d3) {  // room frame\n        albedo = vec3(.25);\n        specLevel = vec4(0.08);\n    }\n    else if (d == d4) {  // mirror border\n        albedo = vec3(0.01);\n        specLevel = vec4(0.2, 0.2, 0.2, 1.);\n    }\n    else if (d == d5) {  // polyhedra\n        if (id == 2.) {  // polyhedra edges\n            albedo = vec3(0.15, 0.3, 0.8);\n            specLevel = vec4(vec3(0.05), 1.);\n        }\n        else {  // polyhedra faces\n            specLevel = vec4(0.7);\n        }\n    }\n    else if (d == d2) {  // floor and ceil\n        vec2 uv = p.xz;\n        albedo = p.y < 0. ? get_floor_color(uv / (RoomSize.x - RoomFrameSize))\n                          : get_ceil_color(uv * 2.);\n        float ior = 1.33;\n        float schlick = pow((ior - 1.) / (ior + 1.), 2.);\n\t    specLevel = vec4(vec3(schlick), 1);\n    \tspecLevel *= mix(.2, .7, p.x);\n    \tnormal = normalize(normal + (texture(iChannel0, vec2(p.xz) /2.).rgb - .5) * .005);\n    }\n    \n    float fresnel = pow(dot(normal, rd) + 1., 5.);\n    vec3 spec = mix(specLevel.xyz, specLevel.www, fresnel);\n    \n    bounceTint = spec;\n    diffuse = albedo * (vec3(1) - spec) * bCol;\n    ref_dir = reflect(rd, normal);\n}\n\nvec3 get_ray_color(vec3 ro, vec3 rd) {\n    vec3 pos = ro;\n    vec3 tint = vec3(1);\n\n    vec3 col = vec3(0);\n    for (int i = 0; i < MAX_RAY_BOUNCES; i++) {\n        pos = trace(pos, rd);\n        vec3 normal = get_normal(pos);\n        vec3 bounceTint, diffuse;\n        ray_bounce(pos, rd, diffuse, rd, bounceTint, normal);\n        pos += normal * PRECISION * 2.;\n        col += diffuse * tint;\n        tint *= bounceTint;\n        if (length(tint) < .01)\n            break;\n    }\n    return col;\n}\n\nmat3 camera_matrix(vec3 eye, vec3 lookat, vec3 up) {\n    vec3 forward = normalize(lookat - eye);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    return mat3(right, up, -forward);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    init_spherical();\n\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 movement = vec2(iTime * 0.2, sin(iTime * 0.2) * 0.5);\n    vec3 eye = 2.5 * vec3(\n        cos(movement.x) * cos(movement.y),\n        0.5*sin(movement.y),\n        sin(movement.x) * cos(movement.y));\n    eye += vec3(1, 0.3, 1) * cos(vec3(0.75, 0.3, 0.2) * iTime);\n   \n    vec2 mouse = vec2(0);\n    if (iMouse.x > 0.) {\n        mouse = 2. * iMouse.xy / iResolution.y - 1.;\n        eye = rot_y(mouse.x) * rot_x(mouse.y) * eye;\n    }\n    vec3 lookat = vec3(0);\n    vec3 up = vec3(0, 1, 0);\n    mat3 M = camera_matrix(eye, lookat, up);\n    \n    vec3 ray = M * normalize(vec3(uv, -2.));\n    vec3 col = get_ray_color(eye, ray);\n    fragColor = vec4(clamp(sqrt(col), 0., 1.), 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI  3.141592654\n#define BlackRegionSize  0.03\n#define L2(x)  dot(x, x)\n#define RotObj  rot_x(iTime/2.)*rot_z(iTime/3.)\n#define PolyhedraEdgeSize  0.02\n#define PolyhedraFaceOffset  0.\n#define RoomSize  vec3(5, 2.5, 5)\n#define RoomFrameSize  0.5\n#define WindowFrameSize vec2(RoomFrameSize*1.2, 0)\n#define MAX_TILING_REFLECTIONS 12\n#define MAX_TRACE_STEPS  128\n#define MAX_RAY_BOUNCES  15\n#define PRECISION        1e-3\n#define MAX_MARCH_STEP   1.0\n\nconst vec3 pqr_wythoff = vec3(5, 2, 3);\nconst vec3 bary = vec3(1, 1, 1);\n\nmat3 matS, triS;\nvec3 v0S;\n\nvoid init_spherical() {\n    vec3 c = cos(PI / pqr_wythoff);\n    float sp = sin(PI / pqr_wythoff.x);\n    vec3 m1 = vec3(1, 0, 0);\n    vec3 m2 = vec3(-c.x, sp, 0);\n    float x3 = -c.z;\n    float y3 = -(c.y + c.x*c.z)/sp;\n    float z3 = sqrt(1.0 - x3*x3 - y3*y3);\n    vec3 m3 = vec3(x3, y3, z3);\n    matS = mat3(m1, m2, m3);\n    triS[0] = normalize(cross(m2, m3));\n    triS[1] = normalize(cross(m3, m1));\n    triS[2] = normalize(cross(m1, m2));\n    v0S = normalize(bary * inverse(matS));\n}\n\nvec3 fold_spherical(vec3 p) {\n    for (int i = 0; i < 5; i++)\n    for (int j = 0; j < 3; j++) {\n        p -= 2. * min(dot(p, matS[j]), 0.) * matS[j];\n    }\n    return p;\n}\n\nvec3 tex3D(sampler2D tex, in vec3 p, in vec3 n ) {\n    n = max(n * n, 0.001);\n    n /= (n.x + n.y + n.z ); \n\treturn (\n        texture(tex, p.yz) * n.x +\n        texture(tex, p.zx) * n.y +\n        texture(tex, p.xy) * n.z\n    ).xyz;\n}\n\nmat2 rot2(in float a) {\n    float c = cos(a), s = sin(a); return mat2(c, -s, s, c);\n}\n\nmat3 rot_x(in float t) {\n    float cx = cos(t), sx = sin(t);\n    return mat3(1., 0,  0, \n                0, cx, sx,\n                0, -sx, cx);\n}\n\nmat3 rot_y(in float t) {\n    float cy = cos(t), sy = sin(t);\n    return mat3(cy, 0, -sy,\n                0, 1., 0,\n                sy, 0, cy);\n}\n\nmat3 rot_z(in float t) {\n    float cz = cos(t), sz = sin(t);\n    return mat3(cz, -sz, 0.,\n                sz, cz, 0.,\n                0., 0., 1.);\n}\n\nfloat sBox(in vec2 p, in vec2 b) {\n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew) {\n    float ang = atan(b.y - a.y, b.x - a.x);\n    p = rot2(ang)*(p - mix(a, b, .5));\n\n    vec2 l = vec2(length(b - a), ew);\n    return sBox(p, (l + ew)/2.) ;\n}\n\n// https://www.shadertoy.com/view/3ljcRh\n// I changed e to vec3 so it works for non-uniform edge size\nfloat sdBoxFrame(vec3 p, vec3 b, vec3 e) {\n    p = abs(p) - b;\n    vec3 q = abs(p + e) - e;\n    return min(min(\n        length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n        length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n        length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdPolyhedraEdges(vec3 p) {\n    float d = 1e5;\n    for (int i = 0; i < 3; i++) {\n        d = min(d, L2(p - min(0., dot(p, matS[i])) * matS[i]));\n    }\n\treturn sqrt(d) - PolyhedraEdgeSize;\n}\n\nfloat sdPolyhedraFaces(vec3 p) {\n   return max(dot(p, triS[0]), max(dot(p, triS[1]), dot(p, triS[2]))) - PolyhedraFaceOffset;\n}\n\n//complex multiplication\nvec2 cMul(vec2 a, vec2 b) {\n\treturn vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\n// complex inverse \nvec2 cDiv( vec2 a, vec2 b ) {\n  float d = dot(b, b);\n  return vec2(dot(a, b), a.y*b.x - a.x*b.y ) / d;\n}\n\n// complex inverse \nvec2 cInv(vec2 a) {\n\treturn vec2(a.x, -a.y) / dot(a, a);\n}\n\n// code below taken from @mla's https://www.shadertoy.com/view/Mlsfzs\nvoid sncndn(float u, float k2,\n            out float sn, out float cn, out float dn) {\n    float emc = 1.0 - k2;\n    float a = 1.0, b, c;\n    const int N = 4;\n    float em[N], en[N];\n    dn = 1.0;\n    for (int i = 0; i < N; i++) {\n        em[i] = a;\n        emc = sqrt(emc);\n        en[i] = emc;\n        c = 0.5*(a + emc);\n        emc *= a;\n        a = c;\n    }\n\n    u = c*u;\n    sn = sin(u);\n    cn = cos(u);\n    if (sn != 0.0) {\n        a = cn / sn;\n        c *= a;\n        for(int i = N - 1; i >= 0; i--) {\n            b = em[i];\n            a *= c;\n            c *= dn;\n            dn = (en[i] + a) / (b + a);\n            a = c/b;\n        }\n        a = 1.0 / sqrt(c*c + 1.0);\n        if (sn < 0.0)\n            sn = -a;\n        else\n            sn = a;\n        cn = c * sn;\n    }\n}\n\nvec2 cn(vec2 z, float k2) {\n  float snu, cnu, dnu, snv, cnv, dnv;\n  sncndn(z.x, k2, snu, cnu, dnu);\n  sncndn(z.y, 1.0-k2, snv, cnv, dnv);\n  return vec2(cnu * cnv, -snu*dnu*snv*dnv) / (1. - dnu*dnu*snv*snv);\n}\n\nvec2 square_to_disc(vec2 z) {     \n    z = cDiv(z, vec2(1));\n    z -= vec2(1, 0);\n    z *= 1.854;\n    z = cn(z, 0.5);\n    z = cMul(z, vec2(0.70711));\n    return z;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}