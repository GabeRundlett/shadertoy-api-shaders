{
    "Shader": {
        "info": {
            "date": "1573335626",
            "description": "2D cloudscapes modeled after the clouds in Horizon Zero Dawn (see code description for more details). The lighting is just a fake 2d ray marched uv offset and is no way physically based, but still kinda looks better than having no lighting at all. ",
            "flags": 0,
            "hasliked": 0,
            "id": "WddSDr",
            "likes": 61,
            "name": "Horizon Zero Dawn Clouds 2D",
            "published": 3,
            "tags": [
                "noise",
                "clouds",
                "fbm",
                "perlin",
                "curl",
                "worley",
                "horizon"
            ],
            "usePreview": 0,
            "username": "piyushslayer",
            "viewed": 4039
        },
        "renderpass": [
            {
                "code": "/**\nI tried modeling clouds using perlin-worley noise as described by Andrew Schneider\nin the chapter Real-Time Volumetric Cloudscapes of GPU Pro 7. There are two types\nof worley fbm functions used, a low frequency one to model the cloud shapes, and\na high frequency one used to add finer details around the edges of the clouds. Finally,\na simple 2D ray march along the light direction to add some fake lighting and shadows\nto the cloudscapes.\n\nDrag around the sun with the mouse to see a change in the lighting.\n*/\n\n#define SAT(x) clamp(x, 0., 1.)\n\n#define CLOUD_COVERAGE 0.64\n#define CLOUD_DETAIL_COVERAGE .16\n#define CLOUD_SPEED 1.6\n#define CLOUD_DETAIL_SPEED 4.8\n#define CLOUD_AMBIENT .01\n\n// Hash functions by Dave_Hoskins\nfloat hash12(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * uvec2(1597334673U, 3812015801U);\n\tuint n = (q.x ^ q.y) * 1597334673U;\n\treturn float(n) * (1.0 / float(0xffffffffU));\n}\n\nvec2 hash22(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p))*uvec2(1597334673U, 3812015801U);\n\tq = (q.x ^ q.y) * uvec2(1597334673U, 3812015801U);\n\treturn vec2(q) * (1.0 / float(0xffffffffU));\n}\n\nfloat remap(float x, float a, float b, float c, float d)\n{\n    return (((x - a) / (b - a)) * (d - c)) + c;\n}\n\n// Noise function by morgan3d\nfloat perlinNoise(vec2 x) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n\tfloat a = hash12(i);\n    float b = hash12(i + vec2(1.0, 0.0));\n    float c = hash12(i + vec2(0.0, 1.0));\n    float d = hash12(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nvec2 curlNoise(vec2 uv)\n{\n    vec2 eps = vec2(0., 1.);\n    \n    float n1, n2, a, b;\n    n1 = perlinNoise(uv + eps);\n    n2 = perlinNoise(uv - eps);\n    a = (n1 - n2) / (2. * eps.y);\n    \n    n1 = perlinNoise(uv + eps.yx);\n    n2 = perlinNoise(uv - eps.yx);\n    b = (n1 - n2)/(2. * eps.y);\n    \n    return vec2(a, -b);\n}\n\nfloat worleyNoise(vec2 uv, float freq, float t, bool curl)\n{\n    uv *= freq;\n    uv += t + (curl ? curlNoise(uv*2.) : vec2(0.)); // exaggerate the curl noise a bit\n    \n    vec2 id = floor(uv);\n    vec2 gv = fract(uv);\n    \n    float minDist = 100.;\n    for (float y = -1.; y <= 1.; ++y)\n    {\n        for(float x = -1.; x <= 1.; ++x)\n        {\n            vec2 offset = vec2(x, y);\n            vec2 h = hash22(id + offset) * .8 + .1; // .1 - .9\n    \t\th += offset;\n            vec2 d = gv - h;\n           \tminDist = min(minDist, dot(d, d));\n        }\n    }\n    \n    return minDist;\n}\n\nfloat perlinFbm (vec2 uv, float freq, float t)\n{\n    uv *= freq;\n    uv += t;\n    float amp = .5;\n    float noise = 0.;\n    for (int i = 0; i < 8; ++i)\n    {\n        noise += amp * perlinNoise(uv);\n        uv *= 1.9;\n        amp *= .55;\n    }\n    return noise;\n}\n\n// Worley fbm inspired by Andrew Schneider's Real-Time Volumetric Cloudscapes\n// chapter in GPU Pro 7.\nvec4 worleyFbm(vec2 uv, float freq, float t, bool curl)\n{\n    // worley0 isn't used for high freq noise, so we can save a few ops here\n    float worley0 = 0.;\n    if (freq < 4.)\n    \tworley0 = 1. - worleyNoise(uv, freq * 1., t * 1., false);\n    float worley1 = 1. - worleyNoise(uv, freq * 2., t * 2., curl);\n    float worley2 = 1. - worleyNoise(uv, freq * 4., t * 4., curl);\n    float worley3 = 1. - worleyNoise(uv, freq * 8., t * 8., curl);\n    float worley4 = 1. - worleyNoise(uv, freq * 16., t * 16., curl);\n    \n    // Only generate fbm0 for low freq\n    float fbm0 = (freq > 4. ? 0. : worley0 * .625 + worley1 * .25 + worley2 * .125);\n    float fbm1 = worley1 * .625 + worley2 * .25 + worley3 * .125;\n    float fbm2 = worley2 * .625 + worley3 * .25 + worley4 * .125;\n    float fbm3 = worley3 * .75 + worley4 * .25;\n    return vec4(fbm0, fbm1, fbm2, fbm3);\n}\n\nfloat clouds(vec2 uv, float t)\n{\n    float coverage = hash12(vec2(uv.x * iResolution.y/iResolution.x, uv.y)) *\n        .1 + ((SAT(CLOUD_COVERAGE) * 1.6) * .5 + .5); // coverage between whatever value and 1.\n \tfloat pfbm = perlinFbm(uv, 2., t);\n    vec4 wfbmLowFreq = worleyFbm(uv, 1.6, t * CLOUD_SPEED, false); // low freq without curl\n    vec4 wfbmHighFreq = worleyFbm(uv, 8., t * CLOUD_DETAIL_SPEED, true); // high freq with curl\n    float perlinWorley = remap(abs(pfbm * 2. - 1.),\n                               1. - wfbmLowFreq.r, 1., 0., 1.);\n    perlinWorley = remap(perlinWorley, 1. - coverage, 1., 0., 1.) * coverage;\n    float worleyLowFreq = wfbmLowFreq.g * .625 + wfbmLowFreq.b * .25\n        + wfbmLowFreq.a * .125;\n    float worleyHighFreq = wfbmHighFreq.g * .625 + wfbmHighFreq.b * .25\n        + wfbmHighFreq.a * .125;\n    float c = remap(perlinWorley, (worleyLowFreq - 1.) * .64, 1., 0., 1.);\n    c = remap(c, worleyHighFreq * CLOUD_DETAIL_COVERAGE, 1., 0., 1.);\n    return max(0., c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.y;\n    float t = mod(iTime + 600., 7200.) * .03;\n    \n    // set up 2D ray march variables\n    vec2 marchDist = vec2(.35 * max(iResolution.x, iResolution.y)) / iResolution.xy;\n    const float steps = 10.;\n    float stepsInv = 1. / steps;\n    vec2 sunDir = normalize(m - uv) * marchDist * stepsInv;\n    vec2 marchUv = uv;\n    float cloudColor = 1.;\n    float cloudShape = clouds(uv, t);\n    \n    // 2D ray march lighting loop based on uncharted 4\n    for (float i = 0.; i < marchDist.x; i += marchDist.x * stepsInv)\n    {\n        marchUv += sunDir * i;\n   \t\tfloat c = clouds(marchUv, t);\n        cloudColor *= clamp(1. - c, 0., 1.);\n    }\n    \n    cloudColor += CLOUD_AMBIENT; // ambient\n    // beer's law + powder sugar\n    cloudColor = exp(-cloudColor) * (1. - exp(-cloudColor*2.)) * 2.;\n    cloudColor *= cloudShape;\n    \n    vec3 skyCol = mix(vec3(.1, .5, .9), vec3(.1, .1, .9), uv.y);\n    vec3 col = vec3(0.);\n    col = skyCol + cloudShape;\n  \tcol = mix(vec3(cloudColor) * 25., col, 1.-cloudShape);\n    float sun = .002 / pow(length(uv - m), 1.7);\n    col += (1. - smoothstep(.0, .4, cloudShape)) * sun;\n    fragColor = vec4(sqrt(col), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}