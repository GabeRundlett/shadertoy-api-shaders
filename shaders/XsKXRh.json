{
    "Shader": {
        "info": {
            "date": "1463149717",
            "description": "An underwater cellular lattice structure.",
            "flags": 0,
            "hasliked": 0,
            "id": "XsKXRh",
            "likes": 82,
            "name": "Cellular Lattice",
            "published": 3,
            "tags": [
                "voronoi",
                "cell",
                "tile",
                "gyroid",
                "lattice"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 5158
        },
        "renderpass": [
            {
                "code": "/*\n\n\tCellular Lattice\n\t----------------\n\n\tStill playing around with 3D cellular tiles.\n\n\tTraversing a cellular, coral-like structure through an alien ocean ... Is anyone buying that?\n    I don't know what it is either, but it looks grotesquely interesting. :)\n\n\tIn technical terms, it's an intertwined sinusoidal lattice structure (a mutated gyroid of sorts) \n\twith a prominent cellular surface attached.\n\n    The scene was mildly inspired by IQ's Leizex demo and Tomasz Dobrowolski's Suboceanic.\n\n\n\tCellular Tiled Tunnel 2 - Shane\n\thttps://www.shadertoy.com/view/MdtSRl\n\n\trgba leizex - Inigo Quilez\n\thttp://www.pouet.net/prod.php?which=51829\n\thttps://www.youtube.com/watch?v=eJBGj8ggCXU\n\thttps://iquilezles.org/prods/index.htm\n\n\tTomasz Dobrowolski - Suboceanic\n\thttp://www.pouet.net/prod.php?which=18343\n\n*/\n\n#define FAR 20.\n\n// Hash.\nfloat hash( float n ){ return fract(cos(n)*45758.5453); }\n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n\nvec3 camPath(in float t){ return vec3(sin(t * 0.45)*.75, cos(t * 0.75)*.75, t); }\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tpl( sampler2D t, in vec3 p, in vec3 n ){\n   \n    n = max(abs(n), 0.001);\n    n /= (n.x + n.y + n.z );  \n\tvec3 tx = (texture(t, p.yz)*n.x + texture(t, p.zx)*n.y + texture(t, p.xy)*n.z).xyz;\n    \n    return tx*tx;\n}\n\n// Akohdr's multitextured suggestion, with some small changes.\n#define t2D texture\nvec3 tpl4( sampler2D a, sampler2D b, \n           sampler2D c, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n), 0.001);\n    n /= (n.x + n.y + n.z );\n    \n    float h = dot(cos(p*6.), sin(p.yzx*6.));\n    \n\tvec3 tx  = (t2D(a, p.yz)*n.x + t2D(a, p.zx)*n.y + t2D(a, p.xy)*n.z).xyz; // Pink sandstone.\n\tvec3 tx2 = (t2D(b, p.yz)*n.x + t2D(b, p.zx)*n.y + t2D(b, p.xy)*n.z).xyz; // Sandstone.\n    vec3 tx3 = 1.-(t2D(c, p.yz)*n.x + t2D(c, p.zx)*n.y + t2D(c, p.xy)*n.z).zyx; // Pink coral.\n\n    tx = mix(tx*tx, tx2*tx2, h*.5 + .5);\n    \n    h = dot(sin(p*5.), cos(p.zxy*5.));\n    \n\ttx2 = mix(tx3*tx3, tx2*tx2, h*.5 + .5);\n    \n    return mix(tx, tx2, dot(sin(p*2.), sin(p.zxy*2.))*.5 + .5);\n}\n\nfloat drawObject(in vec3 p){\n    \n    // Anything that wraps the domain will work. The following looks pretty intereting.\n    p = cos(p*6.2831853) + 1.;\n    return dot(p, p);\n    \n}\n/*\n// Draw four warped spheres on a wrappable cube, and return the closest distance metric. Try to normalize\n// the result between zero and one.\nfloat cellTile(in vec3 p){\n    \n    vec4 d;\n    \n    // Draw four overlapping objects (spheres, in this case) at various positions throughout the tile.\n    d.x = drawObject(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.y = drawObject(p - vec3(.39, .2, .11));\n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawObject(p - vec3(.62, .24, .06));\n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071;\n    d.w = drawObject(p - vec3(.2, .82, .64));\n\n    d.xy = min(d.xy, d.zw); // Minimum distance determination.\n    \n    return 1.- min(d.x, d.y)*.166; // Normalize... roughly.\n    \n}\n*/\n\n// Fast, three tap version, but I feel four should be the minimum... Even so, this should give \n// a pretty convincing pattern, under the right circumstances.\nfloat cellTile(in vec3 p){\n    \n    vec3 d;\n    \n    // Draw three overlapping objects (spherical, in this case) at various positions throughout the tile.\n    d.x = drawObject(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.y = drawObject(p - vec3(.2, .82, .64));\n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawObject(p - vec3(.41, .06, .70));\n    \n    return 1.- min(min(d.x, d.y), d.z)*.1666; // Normalize... roughly.\n    \n}\n\n\n\n// A simple, cheap but visually effective sinusoid based lattice. The downside to building\n// a scene with transcendentals is the honing difficulty.\nfloat map(in vec3 p){\n    \n    float b = cellTile(p*3.); \n    //float b = cellTile(p + iTime/16.); // Animation.\n\n    // Offsetting the lattice around the camera path.\n    p.xy -= camPath(p.z).xy; \n\n    // Perturbing the surface slightly, prior to construction.\n    p += (sin(p*3.14159 - sin(p.zyx*3.14159)*3.14159*1.25))*.1;\n\n    // The main surface. A weird, molecular looking lattice.\n    float n = abs(dot(cos(p*3.14159), sin(p.yzx*3.14159)));\n\n    // Combining element to form the final structure.\n    return .45 - n*.33  - b*.1;\n    \n}\n\n \n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cao(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 1.5, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\n// Tetrahedral normal, courtesy of IQ.\nvec3 nr(in vec3 p)\n{  \n    vec2 e = vec2(-1, 1)*.001;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n    \n    float t = 0., h;\n    for(int i = 0; i < 128; i++){\n\n        h = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<0.0015*(t*.125 + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        t += (step(1., h)*.25 + .5)*h;\n        \n    }\n\n    return min(t, FAR);\n}\n\n// Shadows.\nfloat sha(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\n\n    float shade = 1.0;\n    const int shadIter = 24; \n\n    float dist = start;\n    //float stepDist = end/float(shadIter);\n\n    for (int i=0; i<shadIter; i++){\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n\n        dist += clamp(h, 0.02, 0.16);\n        \n        // There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if ((h)<0.001 || dist > end) break; \n    }\n    \n    return min(max(shade, 0.) + 0.3, 1.0); \n}\n\n\n// Surface bump function. Cheap, but with decent visual impact.\nfloat bumpSurf3D( in vec3 p){\n    \n    float vor = cellTile(p*27.);\n    \n    return pow(max(vor, 0.), 18.);\n\n}\n\n// Standard function-based bump mapping function.\nvec3 dbF(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const vec2 e = vec2(0.001, 0);\n    float ref = bumpSurf3D(p);                 \n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy),\n                      bumpSurf3D(p - e.yxy),\n                      bumpSurf3D(p - e.yyx) )-ref)/e.x;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 db( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tpl(tx, p - e.xyy, n), tpl(tx, p - e.yxy, n), tpl(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tpl(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n\t// Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n    \n    // Perturbing the screen coordinates to create the lamest underwater effect ever. :)\n    // Seriously, though, it's quite effective, all things considered.\n    u += sin(u*32. + cos(u.yx*16. + iTime*4.))*.0035;\n\n\t\n\t// Camera Setup.\n    vec3 o = camPath(iTime*.5); // Camera position, doubling as the ray origin.\n    vec3 lk = camPath(iTime*.5 + .1);  // \"Look At\" position.\n    vec3 l = camPath(iTime*.5 + 1.5) + vec3(.0, .0, 0.); // Light position, somewhere near the moving camera.\n\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/3.; // FOV - Field of view.\n    vec3 fwd = normalize(lk-o);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    vec3 up = cross(fwd, rgt);\n\n    // Unit direction ray.\n    vec3 r = normalize(fwd + FOV*(u.x*rgt + u.y*up));\n    // Lens distortion.\n    //vec3 r = fwd + FOV*(u.x*rgt + u.y*up);\n    //r = normalize(vec3(r.xy, (r.z - length(r.xy)*.5)));\n    \n    // Swiveling the camera from left to right when turning corners.\n    r.xy = rot2( camPath(lk.z).x/16. )*r.xy;\n \n    // Raymarch.\n    float t = trace(o, r);\n\n    // Initialize the scene color to zero.\n    vec3 col = vec3(0);\n    \n    // If the surface is hit, light it up.\n    if(t<FAR){\n    \n        // Position and normal.\n        vec3 p = o + r*t, n = nr(p);\n        \n        // Texture bump the normal.\n        float sz = 1./1.;\n        n = db(iChannel0, p*sz, n, .02/(1. + t/FAR));\n        \n        n = dbF(p*sz, n, .01);\n\n\n        l -= p; // Light to surface vector. Ie: Light direction vector.\n        float d = max(length(l), 0.001); // Light to surface distance.\n        l /= d; // Normalizing the light direction vector.\n        \n        // Ambient occlusion and shadowing.\n        float ao =  cao(p, n);\n        float sh = sha(p, l, 0.04, d, 4.);\n        \n        // Diffuse, specular, fresnel.\n        float di = max(dot(l, n), 0.);\n        float sp = pow(max( dot( reflect(r, n), l ), 0.0 ), 8.); // Specular term.\n        float fr = clamp(1.0 + dot(r, n), 0.0, 1.0); // Fresnel reflection term.\n        \n        // Texturing the surface with some tri-planar mapping..\n        vec3 tx = tpl(iChannel0, p*sz, n);\n        \n        // Texture variance: Akohdr's suggestion.\n        // Requires an additional sandstone texture in iChannel1, and the pink coral texture\n        // in iChannel2.\n        //vec3 tx = tpl4(iChannel0, iChannel1, iChannel2, p*sz, n);\n        \n        float c = dot(tx, vec3(0.299, 0.587, 0.114));\n        \n        tx += vec3(c*c*.8, c, c*c*.5)*fr;\n        \n\n\t\t// Very simple coloring. Fresnel and texture combination.\n        col = tx*(di + .1 + sp)+ tx*fr*2.;\n        col *= 1./(1. + d*.125 + d*d*.025)*ao*sh;\n\n        \n    }\n\n    // Mixing in a simple blue background.\n    vec3 bg = vec3(.5, .7, 1);\n    col = mix(clamp(col, 0., 1.), bg, smoothstep(0., FAR-5., t));\n    \n    // Half hearted gamma correction.\n    fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1.);\n    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}