{
    "Shader": {
        "info": {
            "date": "1501517986",
            "description": "Practical chaos.\n\nIf 1 picture = 1000 words, 1 video = 1000 pictures, 1 interactive demo = 1000 videos,\nthen this demo = many, many words.\n ",
            "flags": 32,
            "hasliked": 0,
            "id": "Md2Bz3",
            "likes": 10,
            "name": "[SH17C] Double Pendulum 2",
            "published": 3,
            "tags": [
                "dynamics",
                "chaos",
                "physics",
                "pendulum"
            ],
            "usePreview": 1,
            "username": "dr2",
            "viewed": 1015
        },
        "renderpass": [
            {
                "code": "// \"[SH17C] Double Pendulum 2\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Based on the original \"Double Pendulum\", with on-screen introduction\n// (https://www.shadertoy.com/view/4dGXRz)\n\n/*\n If you know the physics, simply write down the Lagrangian, extract the equations of\n motion, and solve them numerically (typically using Runge-Kutta). If you don't, have\n fun, get curious, and learn the physics; it can be worth the effort.\n*/\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrSphDf (vec3 p, float s);\nfloat PrCylDf (vec3 p, float r, float h);\nvec3 ShowWg (vec2 uv, vec2 canvas, vec3 col, vec4 slVal);\nvoid PxInit ();\nfloat PxPage (vec2 p);\nvec4 Loadv4 (int idVar);\nfloat Fbm2 (vec2 p);\nvec2 Rot2D (vec2 q, float a);\n\nvec3 vnBall, ltDir;\nfloat rLen[2], bRad[2], pAng[2], dstFar;\nint idObj;\nconst int ntPoint = 160;\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  q = p;\n  q.xy = Rot2D (q.xy, pAng[0]);\n  q.y -= - rLen[0];\n  d = PrCylDf (q.xzy, 0.03, rLen[0]);\n  if (d < dMin) { dMin = d;  idObj = 1; }\n  q.yz -= vec2 (- rLen[0], -0.03);\n  d = PrSphDf (q, bRad[0]);\n  if (d < dMin) { dMin = d;  idObj = 2; }\n  q.xy = Rot2D (q.xy, pAng[1] - pAng[0]);\n  q.yz -= vec2 (- rLen[1], -0.03);\n  d = PrCylDf (q.xzy, 0.03, rLen[1]);\n  if (d < dMin) { dMin = d;  idObj = 1; }\n  q.yz -= vec2 (- rLen[1], -0.03);\n  d = PrSphDf (q, bRad[1]);\n  if (d < dMin) { dMin = d;  idObj = 2; }\n  q = p;  q.yz -= vec2 (-1.1 * (rLen[0] + rLen[1]), 0.5);\n  d = PrBoxDf (q, vec3 (0.2, 1.15 * (rLen[0] + rLen[1]), 0.1));\n  if (d < dMin) { dMin = d;  idObj = 3; }\n  q = p;  q.y -= - 2.15 * (rLen[0] + rLen[1]) - 0.1;\n  d = PrBoxDf (q, vec3 (1., 0.1, 1.));\n  if (d < dMin) { dMin = d;  idObj = 3; }\n  q = p;  q.z -= 0.25;\n  d = PrCylDf (q, 0.1, 0.25);\n  if (d < dMin) { dMin = d;  idObj = 4; }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat TBallHit (vec3 ro, vec3 rd)\n{\n  vec3 p, v;\n  float b, d, w, dMin, sz;\n  dMin = dstFar;\n  sz = 0.05;\n  p.z = 0.;\n  for (int n = 0; n < ntPoint; n ++) {\n    p.xy = Loadv4 (4 + n).xy;\n    p.xy *= -4.;\n    v = ro - p;\n    b = dot (rd, v);\n    w = b * b + sz * sz - dot (v, v);\n    if (w >= 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) {\n        dMin = d;\n        vnBall = (v + d * rd) / sz;\n      }\n    }\n  }\n  return dMin;\n}\n\nvec3 WoodCol (vec3 p, vec3 n)\n{\n  p *= 4.;\n  float f = dot (vec3 (Fbm2 (p.zy * vec2 (1., 0.1)),\n     Fbm2 (p.zx * vec2 (1., 0.1)), Fbm2 (p.xy * vec2 (1., 0.1))), abs (n));\n  return 1.1 * mix (vec3 (0.8, 0.4, 0.2), vec3 (0.45, 0.25, 0.1), f);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, col;\n  float dstObj, dstBall;\n  dstBall = TBallHit (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  if (dstBall < min (dstObj, dstFar)) {\n    idObj = 5;\n    dstObj = dstBall;\n    vn = vnBall;\n  } else {\n    ro += rd * dstObj;\n    vn = ObjNf (ro);\n  }\n  if (dstObj < dstFar) {\n    if (idObj == 1) col = vec3 (0.9, 0.9, 1.);\n    else if (idObj == 2) col = vec3 (1., 1., 0.);\n    else if (idObj == 3) col = WoodCol (ro, vn);\n    else if (idObj == 4) col = vec3 (0.6, 0.6, 0.7);\n    else if (idObj == 5) col = vec3 (0.8, 0.6, 0.4);\n    col = col * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n       0.5 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 128.);\n  } else col = (1. - 2. * dot (rd.xy, rd.xy)) * vec3 (0.2, 0.3, 0.4);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat, slVal;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;;\n  float tCur, t, az, el, parmL, parmM, mFrac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  PxInit ();\n  dstFar = 30.;\n  stDat = Loadv4 (0);\n  el = stDat.z;\n  az = stDat.w;\n  stDat = Loadv4 (1);\n  pAng[0] = stDat.x;\n  pAng[1] = stDat.y;\n  slVal = Loadv4 (2);\n  parmL = (slVal.x - 0.5) * ((slVal.x >= 0.5) ? 1. : 1. / 5.) * 8. + 1.;\n  parmM = (slVal.y - 0.5) * ((slVal.y >= 0.5) ? 1. : 1. / 5.) * 8. + 1.;\n  rLen[0] = 2. / (1. + parmL);\n  rLen[1] = 2. * parmL / (1. + parmL);\n  mFrac = parmM / (1. + parmM);\n  bRad[0] = 0.05 * (1. + 3. * sqrt (1. - mFrac));\n  bRad[1] = 0.05 * (1. + 3. * sqrt (mFrac));\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n     mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, 3.));\n  ro = vuMat * vec3 (0., 0., -15.);\n  ltDir = vuMat * normalize (vec3 (1., 2., -1.));\n  col = ShowScene (ro, rd);\n  col = ShowWg (uv, canvas, col, slVal);\n  t = (canvas.x <= 400.) ? mod (tCur, 20.) : tCur;\n  if (t < 10.) {\n    col = mix (((PxPage (140. * uv) > 0.) ? vec3 (0., 0., 1.) : vec3 (0.8)), col, smoothstep (6., 10., t));\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nvec3 ShowWg (vec2 uv, vec2 canvas, vec3 col, vec4 slVal)\n{\n  vec4 wgBx[4];\n  vec3 cc;\n  vec2 ut, ust;\n  float vW[4], asp;\n  asp = canvas.x / canvas.y;\n  wgBx[0] = vec4 (-0.45 * asp, 0., 0.012 * asp, 0.18);\n  wgBx[1] = vec4 (-0.35 * asp, 0., 0.012 * asp, 0.18);\n  wgBx[2] = vec4 ( 0.35 * asp, 0., 0.012 * asp, 0.18);\n  wgBx[3] = vec4 ( 0.45 * asp, 0., 0.012 * asp, 0.18);\n  vW[0] = slVal.x;\n  vW[1] = slVal.y;\n  vW[2] = slVal.z;\n  vW[3] = slVal.w;\n  for (int k = 0; k < 4; k ++) {\n    cc = (k < 2) ? vec3 (0.2, 1., 0.2) : vec3 (1., 0.2, 0.2);\n    ut = 0.5 * uv - wgBx[k].xy;\n    ust = abs (ut) - wgBx[k].zw * vec2 (0.7, 1.);\n    if (max (ust.x, ust.y) < 0.) {\n      if  (min (abs (ust.x), abs (ust.y)) * canvas.y < 2.) col = vec3 (1., 1., 0.);\n      else col = (mod (0.5 * ((0.5 * uv.y - wgBx[k].y) / wgBx[k].w - 0.99), 0.1) *\n         canvas.y < 6.) ? vec3 (1., 1., 0.) : vec3 (0.6);\n    }\n    ut.y -= (vW[k] - 0.5) * 2. * wgBx[k].w;\n    ut = abs (ut) * vec2 (1., 2.);\n    if (length (ut) < 0.03 && max (ut.x, ut.y) > 0.01) col = cc;\n  }\n  return col;\n}\n\n/*\n Text derived from 8x12 Font shader by Flyguy (Mt2GWD)\n Glyph bitmaps generated from 8x12 font sheet\n   http://www.massmind.org/techref/datafile/charset/extractor/charset_extractor.htm\n*/\n\nvec4 glph[95];\nvec2 pCur, cPos, cSpace;\n\nconst int g_spc=0, g_exc=1, g_quo=2, g_hsh=3, g_dol=4, g_pct=5, g_amp=6, g_apo=7,\n   g_lbr=8, g_rbr=9, g_ast=10, g_crs=11, g_com=12, g_dsh=13, g_per=14, g_lsl=15, g_0=16,\n   g_1=17, g_2=18, g_3=19, g_4=20, g_5=21, g_6=22, g_7=23, g_8=24, g_9=25, g_col=26,\n   g_scl=27, g_les=28, g_equ=29, g_grt=30, g_que=31, g_ats=32, g_A=33, g_B=34, g_C=35,\n   g_D=36, g_E=37, g_F=38, g_G=39, g_H=40, g_I=41, g_J=42, g_K=43, g_L=44, g_M=45,\n   g_N=46, g_O=47, g_P=48, g_Q=49, g_R=50, g_S=51, g_T=52, g_U=53, g_V=54, g_W=55,\n   g_X=56, g_Y=57, g_Z=58, g_lsb=59, g_rsl=60, g_rsb=61, g_pow=62, g_usc=63, g_a=64,\n   g_b=65, g_c=66, g_d=67, g_e=68, g_f=69, g_g=70, g_h=71, g_i=72, g_j=73, g_k=74,\n   g_l=75, g_m=76, g_n=77, g_o=78, g_p=79, g_q=80, g_r=81, g_s=82, g_t=83, g_u=84,\n   g_v=85, g_w=86, g_x=87, g_y=88, g_z=89, g_lpa=90, g_bar=91, g_rpa=92, g_tid=93,\n   g_lar=94;\n\nfloat PxChar (vec4 c)\n{\n  vec2 p, cb;\n  float pOn, b;\n  p = ceil (pCur - cPos);\n  if (min (p.x, p.y) >= 1. && max (p.x - 8., p.y - 12.) < 1.) {\n    b = 8. * p.y - p.x;\n    cb = (b < 48.) ? ((b < 24.) ? vec2 (c.w, b) : vec2 (c.z, b - 24.)) :\n       ((b < 72.) ? vec2 (c.y, b - 48.) : vec2 (c.x, b - 72.));\n    pOn = mod (floor (cb.x / exp2 (cb.y)), 2.);\n  } else pOn = 0.;\n  cPos.x += cSpace.x;\n  return pOn;\n}\n\n#define G(g) tc += PxChar (glph[g])\n\n#define _A G(g_A);\n#define _B G(g_B);\n#define _C G(g_C);\n#define _D G(g_D);\n#define _E G(g_E);\n#define _F G(g_F);\n#define _G G(g_G);\n#define _H G(g_H);\n#define _I G(g_I);\n#define _J G(g_J);\n#define _K G(g_K);\n#define _L G(g_L);\n#define _M G(g_M);\n#define _N G(g_N);\n#define _O G(g_O);\n#define _P G(g_P);\n#define _Q G(g_Q);\n#define _R G(g_R);\n#define _S G(g_S);\n#define _T G(g_T);\n#define _U G(g_U);\n#define _V G(g_V);\n#define _W G(g_W);\n#define _X G(g_X);\n#define _Y G(g_Y);\n#define _Z G(g_Z);\n#define _a G(g_a);\n#define _b G(g_b);\n#define _c G(g_c);\n#define _d G(g_d);\n#define _e G(g_e);\n#define _f G(g_f);\n#define _g G(g_g);\n#define _h G(g_h);\n#define _i G(g_i);\n#define _j G(g_j);\n#define _k G(g_k);\n#define _l G(g_l);\n#define _m G(g_m);\n#define _n G(g_n);\n#define _o G(g_o);\n#define _p G(g_p);\n#define _q G(g_q);\n#define _r G(g_r);\n#define _s G(g_s);\n#define _t G(g_t);\n#define _u G(g_u);\n#define _v G(g_v);\n#define _w G(g_w);\n#define _x G(g_x);\n#define _y G(g_y);\n#define _z G(g_z);\n#define _0 G(g_0);\n#define _1 G(g_1);\n#define _2 G(g_2);\n#define _3 G(g_3);\n#define _4 G(g_4);\n#define _5 G(g_5);\n#define _6 G(g_6);\n#define _7 G(g_7);\n#define _8 G(g_8);\n#define _9 G(g_9);\n#define _spc G(g_spc);\n#define _per G(g_per);\n#define _com G(g_com);\n#define _nl cPos = floor (vec2 (-24., -- nLine) * cSpace);\n\n/*\n  The simplest mechanical system that exhibits\n  deterministic chaos.\n\n  The two sliders on the left control the relative\n  masses of the two bobs and the arm lengths.\n  The right sliders control the initial angular \n  velocities of the two arms.\n  Each change restarts the simulation.\n\n  The dots show the most recent segment of the \n  trajectory of the end bob.\n\n  Examine different parameter combinations to see \n  the kinds of behavior that can occur.\n*/\n\nfloat PxPage (vec2 p)\n{\n  float nLine;\n  nLine = 8.;\n  float tc;\n  pCur = p;\n  tc = 0.;\n  _nl _spc _spc _spc _spc _spc _spc _spc _spc _spc _spc _spc _spc _spc _D _o _u _b _l _e _spc  _P _e _n _d _u _l _u _m\n  _nl\n  _nl _T _h _e _spc _s _i _m _p _l _e _s _t _spc _m _e _c _h _a _n _i _c _a _l _spc _s _y _s _t _e _m _spc \n  _t _h _a _t _spc _e _x _h _i _b _i _t _s\n  _nl _d _e _t _e _r _m _i _n _i _s _t _i _c _spc _c _h _a _o _s _per\n\n  _nl\n  _nl _T _h _e _spc _t _w _o _spc _s _l _i _d _e _r _s _spc _o _n _spc _t _h _e _spc _l _e _f _t _spc \n  _c _o _n _t _r _o _l _spc _t _h _e _spc _r _e _l _a _t _i _v _e\n  _nl _m _a _s _s _e _s _spc _o _f _spc _t _h _e _spc _t _w _o _spc _b _o _b _s _spc _a _n _d _spc \n  _t _h _e _spc _a _r _m _spc _l _e _n _g _t _h _s _per\n\n  _nl _T _h _e _spc _r _i _g _h _t _spc _s _l _i _d _e _r _s _spc _c _o _n _t _r _o _l _spc _t _h _e _spc \n  _i _n _i _t _i _a _l _spc _a _n _g _u _l _a _r \n  _nl _v _e _l _o _c _i _t _i _e _s _spc _o _f _spc _t _h _e _spc _t _w _o _spc _a _r _m _s _per\n  _nl _E _a _c _h _spc _c _h _a _n _g _e _spc _r _e _s _t _a _r _t _s _spc _t _h _e _spc _s _i _m _u _l _a _t _i _o _n _per\n\n  _nl\n  _nl _T _h _e _spc _d _o _t _s _spc _s _h _o _w _spc _t _h _e _spc _m _o _s _t _spc _r _e _c _e _n _t _spc \n  _s _e _g _m _e _n _t _spc _o _f _spc _t _h _e \n  _nl _t _r _a _j _e _c _t _o _r _y _spc _o _f _spc _t _h _e _spc _e _n _d _spc _b _o _b _per\n\n  _nl\n  _nl _E _x _a _m _i _n _e  _spc _d _i _f _f _e _r _e _n _t _spc _p _a _r _a _m _e _t _e _r _spc \n  _c _o _m _b _i _n _a _t _i _o _n _s _spc _t _o _spc _s _e _e \n  _nl _t _h _e _spc _k _i _n _d _s _spc _o _f _spc _b _e _h _a _v _i _o _r _spc _t _h _a _t _spc \n  _c _a _n _spc _o _c _c _u _r _per\n\n  return tc;\n}\n\nvoid PxInit ()\n{\n  glph[g_spc] = vec4 (0x000000, 0x000000, 0x000000, 0x000000);\n  glph[g_exc] = vec4 (0x003078, 0x787830, 0x300030, 0x300000);\n  glph[g_quo] = vec4 (0x006666, 0x662400, 0x000000, 0x000000);\n  glph[g_hsh] = vec4 (0x006C6C, 0xFE6C6C, 0x6CFE6C, 0x6C0000);\n  glph[g_dol] = vec4 (0x30307C, 0xC0C078, 0x0C0CF8, 0x303000);\n  glph[g_pct] = vec4 (0x000000, 0xC4CC18, 0x3060CC, 0x8C0000);\n  glph[g_amp] = vec4 (0x0070D8, 0xD870FA, 0xDECCDC, 0x760000);\n  glph[g_apo] = vec4 (0x003030, 0x306000, 0x000000, 0x000000);\n  glph[g_lbr] = vec4 (0x000C18, 0x306060, 0x603018, 0x0C0000);\n  glph[g_rbr] = vec4 (0x006030, 0x180C0C, 0x0C1830, 0x600000);\n  glph[g_ast] = vec4 (0x000000, 0x663CFF, 0x3C6600, 0x000000);\n  glph[g_crs] = vec4 (0x000000, 0x18187E, 0x181800, 0x000000);\n  glph[g_com] = vec4 (0x000000, 0x000000, 0x000038, 0x386000);\n  glph[g_dsh] = vec4 (0x000000, 0x0000FE, 0x000000, 0x000000);\n  glph[g_per] = vec4 (0x000000, 0x000000, 0x000038, 0x380000);\n  glph[g_lsl] = vec4 (0x000002, 0x060C18, 0x3060C0, 0x800000);\n  glph[g_0]   = vec4 (0x007CC6, 0xD6D6D6, 0xD6D6C6, 0x7C0000);\n  glph[g_1]   = vec4 (0x001030, 0xF03030, 0x303030, 0xFC0000);\n  glph[g_2]   = vec4 (0x0078CC, 0xCC0C18, 0x3060CC, 0xFC0000);\n  glph[g_3]   = vec4 (0x0078CC, 0x0C0C38, 0x0C0CCC, 0x780000);\n  glph[g_4]   = vec4 (0x000C1C, 0x3C6CCC, 0xFE0C0C, 0x1E0000);\n  glph[g_5]   = vec4 (0x00FCC0, 0xC0C0F8, 0x0C0CCC, 0x780000);\n  glph[g_6]   = vec4 (0x003860, 0xC0C0F8, 0xCCCCCC, 0x780000);\n  glph[g_7]   = vec4 (0x00FEC6, 0xC6060C, 0x183030, 0x300000);\n  glph[g_8]   = vec4 (0x0078CC, 0xCCEC78, 0xDCCCCC, 0x780000);\n  glph[g_9]   = vec4 (0x0078CC, 0xCCCC7C, 0x181830, 0x700000);\n  glph[g_col] = vec4 (0x000000, 0x383800, 0x003838, 0x000000);\n  glph[g_scl] = vec4 (0x000000, 0x383800, 0x003838, 0x183000);\n  glph[g_les] = vec4 (0x000C18, 0x3060C0, 0x603018, 0x0C0000);\n  glph[g_equ] = vec4 (0x000000, 0x007E00, 0x7E0000, 0x000000);\n  glph[g_grt] = vec4 (0x006030, 0x180C06, 0x0C1830, 0x600000);\n  glph[g_que] = vec4 (0x0078CC, 0x0C1830, 0x300030, 0x300000);\n  glph[g_ats] = vec4 (0x007CC6, 0xC6DEDE, 0xDEC0C0, 0x7C0000);\n  glph[g_A]   = vec4 (0x003078, 0xCCCCCC, 0xFCCCCC, 0xCC0000);\n  glph[g_B]   = vec4 (0x00FC66, 0x66667C, 0x666666, 0xFC0000);\n  glph[g_C]   = vec4 (0x003C66, 0xC6C0C0, 0xC0C666, 0x3C0000);\n  glph[g_D]   = vec4 (0x00F86C, 0x666666, 0x66666C, 0xF80000);\n  glph[g_E]   = vec4 (0x00FE62, 0x60647C, 0x646062, 0xFE0000);\n  glph[g_F]   = vec4 (0x00FE66, 0x62647C, 0x646060, 0xF00000);\n  glph[g_G]   = vec4 (0x003C66, 0xC6C0C0, 0xCEC666, 0x3E0000);\n  glph[g_H]   = vec4 (0x00CCCC, 0xCCCCFC, 0xCCCCCC, 0xCC0000);\n  glph[g_I]   = vec4 (0x007830, 0x303030, 0x303030, 0x780000);\n  glph[g_J]   = vec4 (0x001E0C, 0x0C0C0C, 0xCCCCCC, 0x780000);\n  glph[g_K]   = vec4 (0x00E666, 0x6C6C78, 0x6C6C66, 0xE60000);\n  glph[g_L]   = vec4 (0x00F060, 0x606060, 0x626666, 0xFE0000);\n  glph[g_M]   = vec4 (0x00C6EE, 0xFEFED6, 0xC6C6C6, 0xC60000);\n  glph[g_N]   = vec4 (0x00C6C6, 0xE6F6FE, 0xDECEC6, 0xC60000);\n  glph[g_O]   = vec4 (0x00386C, 0xC6C6C6, 0xC6C66C, 0x380000);\n  glph[g_P]   = vec4 (0x00FC66, 0x66667C, 0x606060, 0xF00000);\n  glph[g_Q]   = vec4 (0x00386C, 0xC6C6C6, 0xCEDE7C, 0x0C1E00);\n  glph[g_R]   = vec4 (0x00FC66, 0x66667C, 0x6C6666, 0xE60000);\n  glph[g_S]   = vec4 (0x0078CC, 0xCCC070, 0x18CCCC, 0x780000);\n  glph[g_T]   = vec4 (0x00FCB4, 0x303030, 0x303030, 0x780000);\n  glph[g_U]   = vec4 (0x00CCCC, 0xCCCCCC, 0xCCCCCC, 0x780000);\n  glph[g_V]   = vec4 (0x00CCCC, 0xCCCCCC, 0xCCCC78, 0x300000);\n  glph[g_W]   = vec4 (0x00C6C6, 0xC6C6D6, 0xD66C6C, 0x6C0000);\n  glph[g_X]   = vec4 (0x00CCCC, 0xCC7830, 0x78CCCC, 0xCC0000);\n  glph[g_Y]   = vec4 (0x00CCCC, 0xCCCC78, 0x303030, 0x780000);\n  glph[g_Z]   = vec4 (0x00FECE, 0x981830, 0x6062C6, 0xFE0000);\n  glph[g_lsb] = vec4 (0x003C30, 0x303030, 0x303030, 0x3C0000);\n  glph[g_rsl] = vec4 (0x000080, 0xC06030, 0x180C06, 0x020000);\n  glph[g_rsb] = vec4 (0x003C0C, 0x0C0C0C, 0x0C0C0C, 0x3C0000);\n  glph[g_pow] = vec4 (0x10386C, 0xC60000, 0x000000, 0x000000);\n  glph[g_usc] = vec4 (0x000000, 0x000000, 0x000000, 0x00FF00);\n  glph[g_a]   = vec4 (0x000000, 0x00780C, 0x7CCCCC, 0x760000);\n  glph[g_b]   = vec4 (0x00E060, 0x607C66, 0x666666, 0xDC0000);\n  glph[g_c]   = vec4 (0x000000, 0x0078CC, 0xC0C0CC, 0x780000);\n  glph[g_d]   = vec4 (0x001C0C, 0x0C7CCC, 0xCCCCCC, 0x760000);\n  glph[g_e]   = vec4 (0x000000, 0x0078CC, 0xFCC0CC, 0x780000);\n  glph[g_f]   = vec4 (0x00386C, 0x6060F8, 0x606060, 0xF00000);\n  glph[g_g]   = vec4 (0x000000, 0x0076CC, 0xCCCC7C, 0x0CCC78);\n  glph[g_h]   = vec4 (0x00E060, 0x606C76, 0x666666, 0xE60000);\n  glph[g_i]   = vec4 (0x001818, 0x007818, 0x181818, 0x7E0000);\n  glph[g_j]   = vec4 (0x000C0C, 0x003C0C, 0x0C0C0C, 0xCCCC78);\n  glph[g_k]   = vec4 (0x00E060, 0x60666C, 0x786C66, 0xE60000);\n  glph[g_l]   = vec4 (0x007818, 0x181818, 0x181818, 0x7E0000);\n  glph[g_m]   = vec4 (0x000000, 0x00FCD6, 0xD6D6D6, 0xC60000);\n  glph[g_n]   = vec4 (0x000000, 0x00F8CC, 0xCCCCCC, 0xCC0000);\n  glph[g_o]   = vec4 (0x000000, 0x0078CC, 0xCCCCCC, 0x780000);\n  glph[g_p]   = vec4 (0x000000, 0x00DC66, 0x666666, 0x7C60F0);\n  glph[g_q]   = vec4 (0x000000, 0x0076CC, 0xCCCCCC, 0x7C0C1E);\n  glph[g_r]   = vec4 (0x000000, 0x00EC6E, 0x766060, 0xF00000);\n  glph[g_s]   = vec4 (0x000000, 0x0078CC, 0x6018CC, 0x780000);\n  glph[g_t]   = vec4 (0x000020, 0x60FC60, 0x60606C, 0x380000);\n  glph[g_u]   = vec4 (0x000000, 0x00CCCC, 0xCCCCCC, 0x760000);\n  glph[g_v]   = vec4 (0x000000, 0x00CCCC, 0xCCCC78, 0x300000);\n  glph[g_w]   = vec4 (0x000000, 0x00C6C6, 0xD6D66C, 0x6C0000);\n  glph[g_x]   = vec4 (0x000000, 0x00C66C, 0x38386C, 0xC60000);\n  glph[g_y]   = vec4 (0x000000, 0x006666, 0x66663C, 0x0C18F0);\n  glph[g_z]   = vec4 (0x000000, 0x00FC8C, 0x1860C4, 0xFC0000);\n  glph[g_lpa] = vec4 (0x001C30, 0x3060C0, 0x603030, 0x1C0000);\n  glph[g_bar] = vec4 (0x001818, 0x181800, 0x181818, 0x180000);\n  glph[g_rpa] = vec4 (0x00E030, 0x30180C, 0x183030, 0xE00000);\n  glph[g_tid] = vec4 (0x0073DA, 0xCE0000, 0x000000, 0x000000);\n  glph[g_lar] = vec4 (0x000000, 0x10386C, 0xC6C6FE, 0x000000);\n  cSpace = vec2 (8., 13.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"[SH17C] Double Pendulum 2\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nfloat nStep, mFrac, rLen1, rLen2, delT;\nconst int ntPoint = 160;\nconst float txRow = 128.;\nconst float pi = 3.14159;\n\nvec4 EvalRhs (vec4 s)\n{\n  vec4 f;\n  float sd, cd, s1, s2, t;\n  sd = sin (s.x - s.y);\n  cd = cos (s.x - s.y);\n  s1 = sin (s.x);\n  s2 = sin (s.y);\n  t = delT / (1. - mFrac * cd * cd);\n  f.x = s.z * delT;\n  f.y = s.w * delT;\n  f.z = t * ((mFrac * cd * s2 - s1) / rLen1 -\n     mFrac * sd * (cd * s.z * s.z + (rLen2 / rLen1) * s.w * s.w));\n  f.w = t * ((cd * s1 - s2) / rLen2 +\n     mFrac * cd * sd * s.w * s.w + (rLen1 / rLen2) * sd * s.z * s.z);\n  return f;\n}\n\nvoid Step (inout vec4 s)\n{\n  vec4 k1, k2, k3, k4;\n  k1 = EvalRhs (s);\n  k2 = EvalRhs (s + k1 / 2.);\n  k3 = EvalRhs (s + k2 / 2.);\n  k4 = EvalRhs (s + k3);\n  s += (k1 + k4) / 6. + (k2 + k3) / 3.;\n  s.xy = mod (s.xy + pi, 2. * pi) - pi;\n}\n\nfloat Eng (vec4 s)\n{\n  float c1, c2;\n  c1 = cos (s.x);\n  c2 = cos (s.y);\n  return 0.5 * ((1. - mFrac) * rLen1 * rLen1 * s.z * s.z + \n     mFrac * (rLen1 * rLen1 * s.z * s.z + rLen2 * rLen2 * s.w * s.w +\n     2. * rLen1 * rLen2 * cos (s.x - s.y) * s.z * s.w)) +\n     ((1. - mFrac) * rLen1 * (1. - c1) +\n     mFrac * (rLen1 * (1. - c1) + rLen2 * (1. - c2)));\n}\n\nvec2 TPoint (vec4 s)\n{\n  return rLen1 * vec2 (sin (s.x), cos (s.x)) +\n         rLen2 * vec2 (sin (s.y), cos (s.y));\n}\n\n#define R10 sqrt(10.)\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 wgBx[4], mPtr, mPtrP, stDat, slVal, r;\n  vec2 iFrag, canvas, ust, tPoint;\n  float asp, vW, parmL, parmM, parmV1, parmV2, eTot, el, az;\n  int pxId, wgSel, wgReg, kSel;\n  bool doInit;\n  canvas = iResolution.xy;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4 + ntPoint) discard;\n  delT = 0.005 * R10;\n  doInit = false;\n  wgReg = -2;\n  if (iFrame <= 5) {\n    parmL = 0.6;\n    parmM = 0.5;\n    parmV1 = -6. / R10;\n    parmV2 = 6. / R10;\n    slVal.x = 0.5 + (parmL - 1.) * ((parmL >= 1.) ? 1. : 5.) / 8.;\n    slVal.y = 0.5 + (parmM - 1.) * ((parmM >= 1.) ? 1. : 5.) / 8.;\n    slVal.z = 0.5 - parmV1 * R10 / 20.;\n    slVal.w = 0.5 - parmV2 * R10 / 20.;\n    mPtrP = mPtr;\n    wgSel = -1;\n    doInit = true;\n  } else {\n    nStep = Loadv4 (0).x;\n    r = Loadv4 (1);\n    slVal = Loadv4 (2);\n    stDat = Loadv4 (3);\n    mPtrP = vec4 (stDat.xyz, 0.);\n    wgSel = int (stDat.w);\n  }\n  asp = canvas.x / canvas.y;\n  if (mPtr.z > 0.) {\n    wgBx[0] = vec4 (-0.45 * asp, 0., 0.012 * asp, 0.18);\n    wgBx[1] = vec4 (-0.35 * asp, 0., 0.012 * asp, 0.18);\n    wgBx[2] = vec4 ( 0.35 * asp, 0., 0.012 * asp, 0.18);\n    wgBx[3] = vec4 ( 0.45 * asp, 0., 0.012 * asp, 0.18);\n    for (int k = 0; k < 4; k ++) {\n      ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx[k].xy) - wgBx[k].zw;\n      if (max (ust.x, ust.y) < 0.) wgReg = k;\n    }\n    if (mPtrP.z <= 0.) wgSel = wgReg;\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n  }\n  el = 0.;\n  az = 0.;\n  if (wgSel < 0) {\n    if (mPtr.z > 0.) {\n      el +=  pi * mPtr.y;\n      az += 2. * pi * mPtr.x;\n    }\n  } else {\n    for (int k = 0; k < 4; k ++) {\n      if (wgSel == k) {\n        kSel = k;\n        vW = clamp (0.5 + 0.5 * (mPtr.y - wgBx[k].y) / wgBx[k].w, 0.01, 0.99);\n        break;\n      }\n    }\n    if      (kSel == 0) slVal.x = vW;\n    else if (kSel == 1) slVal.y = vW;\n    else if (kSel == 2) slVal.z = vW;\n    else if (kSel == 3) slVal.w = vW;\n    doInit = true;\n  }\n  parmL = (slVal.x - 0.5) * ((slVal.x >= 0.5) ? 1. : 1. / 5.) * 8. + 1.;\n  parmM = (slVal.y - 0.5) * ((slVal.y >= 0.5) ? 1. : 1. / 5.) * 8. + 1.;\n  parmV1 = - (slVal.z - 0.5) * 20. / R10;\n  parmV2 = - (slVal.w - 0.5) * 20. / R10;\n  if (doInit) {\n    r = vec4 (0., 0., parmV1, parmV2);\n    nStep = 0.;\n  }\n  rLen1 = 1. / (1. + parmL);\n  rLen2 = 1. - rLen1;\n  mFrac = parmM / (1. + parmM);\n  if (! doInit && pxId <= 4) {\n    for (int k = 0; k < 2; k ++) Step (r);\n    ++ nStep;\n  }\n  eTot = Eng (r);\n  if (pxId == 4) tPoint = TPoint (r);\n  else if (pxId > 4) {\n    if (doInit) tPoint = vec2 (0.);\n    else {\n      if (mod (nStep, 3.) == 0.) tPoint = Loadv4 (pxId - 1).xy;\n      else tPoint = Loadv4 (pxId).xy;\n    }\n  }\n  if (pxId == 0) stDat = vec4 (nStep, eTot, el, az);\n  else if (pxId == 1) stDat = r;\n  else if (pxId == 2) stDat = slVal;\n  else if (pxId == 3) stDat = vec4 (mPtr.xyz, float (wgSel));\n  else stDat = vec4 (tPoint, 0., 0.);\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}