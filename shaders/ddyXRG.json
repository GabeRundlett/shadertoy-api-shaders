{
    "Shader": {
        "info": {
            "date": "1681236806",
            "description": "Inspired by Max Bill: 'Quinze variations sur un même thème', 1935-1938, with animations.\n\nThere is a disabled 6th variation which didn't turn out to have a good transition with any others, so it was scrapped.\n\nhttps://demozoo.org/graphics/322541/",
            "flags": 0,
            "hasliked": 0,
            "id": "ddyXRG",
            "likes": 16,
            "name": "Cinq variations sur 1 même thème",
            "published": 3,
            "tags": [
                "2d",
                "revision",
                "gif"
            ],
            "usePreview": 0,
            "username": "wungasaurus",
            "viewed": 278
        },
        "renderpass": [
            {
                "code": "// 'Cinq variations sur un même thème':\n//   Inspired by from Max Bill: Quinze variations sur un même thème, 1935-1938, with animations.\n// wungasaurus, Revision 2023, animated gif\n\nfloat noise(in vec2 uv) {\n    return fract(sin(dot(uv.xy ,vec2(123.18692, 895.2234))) * 19395.1791);\n}\n\nbool isBitSet( float x,  int bit) {\n    return (uint(round(x)) & (1u << bit)) != 0u;\n}\n\n// https://graphics.stanford.edu/%7Eseander/bithacks.html#CountBitsSetParallel\nint popcount(in float f)\n{\n    int i = int(f);\n    i = i - ((i >> 1) & 0x55555555);\n    i = (i & 0x33333333) + ((i >> 2) & 0x33333333);\n    i = (i + (i >> 4)) & 0x0F0F0F0F;\n    return (i * 0x01010101) >> 24;\n}\n\nfloat gain(float x, float k)\n{\n    float a = 0.5*pow(2.0*((x<0.5)?x:1.0-x), k);\n    return (x<0.5)?a:1.0-a;\n}\n\n// All SDFs from/based on https://iquilezles.org/articles/distfunctions2d/\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdRing(vec2 p, float r1, float r2) {\n    return abs(sdCircle(p, r1)) - r2;\n}\nfloat sdRingRing(vec2 p, float r1, float r2, float r3) {\n    return abs(sdRing(p, r1,  r2)) - r3;\n}\n\nfloat nGon(in int n, in vec2 p, in float r) {\n    // these 2 lines can be precomputed\n    float an = 6.2831853 / float(n);\n    float he = r * tan(0.5 * an);\n\n    // rotate to first sector\n    p = -p.yx; // if you want the corner to be up\n    float bn = an * floor((atan(p.y, p.x) + 0.5 * an) / an);\n    vec2 cs = vec2(cos(bn), sin(bn));\n    p = mat2(cs.x, -cs.y, cs.y, cs.x) * p;\n\n    // side of polygon\n    return length(p - vec2(r, clamp(p.y, -he, he))) * sign(p.x-r);\n}\n\nfloat ngon_ring(in int n, in vec2 p, in float r1, float r2) {\n    return abs(nGon(n, p, r1)) - r2;\n}\nfloat ngon_ringring(in int n, in vec2 p, in float r1, float r2, float r3) {\n    return abs(ngon_ring(n, p, r1, r2)) - r3;\n}\n\n// Classic 2D rotate.\nvec2 rotate( in vec2 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    return mat2(co,-si,si,co)*p;\n}\n\nfloat shapecomb(float res, in int fillbit, float m, float d0, float d1, float d2, float d3, float d4, float d5) {\n  float d = 0.;\n\n  // ok\n  // x 0 1 2 3 4 5\n  // 0   / + + + -    round    line\n  // 1     + + - -    angular  line\n  // 2       + - +    angular  fill\n  // 3         / /    round    fill\n  // 4           -    round    ring\n  // 5.               angular  ring\n\n  float ds[5] = float[](d0, d1, d2, d3, d4);\n\n    for (int i = 0; i < ds.length(); ++i) {\n        if (m <= float(i + 1)) {\n            d = mix(ds[i], ds[(i + 1) % ds.length()], m - float(i));\n            break;\n        }\n    }\n\n   if (d < 0.01) {\n      if(!isBitSet(res, fillbit))\n      res += float(1u<<fillbit);\n   }\n   return res;\n}\n\nfloat shape_1(in float res, in int fillbit, in vec2 uv, in float r1, in float r2, in float m) {\n  float d0 = sdRing(uv, r1+r2, r2);\n  float d3 = sdCircle(uv, r1+r2+.04);\n  float d2 = nGon(8, uv, r1);\n  float d1 = 10.*ngon_ring(8, uv, r1, 0.001);\n  float d4 = 20.*sdRingRing(uv, r1+r2, r2, 0.001);\n  float d5 = 20.*ngon_ringring(8, uv, r1, r2, 0.001);\n  return shapecomb(res, fillbit, m, d0, d1, d2, d3, d4, d5);\n}\n\nfloat shape_2(in float res, in int fillbit, in vec2 uv, in float r1, in float r2, in float m) {\n  float d0 = sdRing(uv, r1+r2, r2);\n  float d3 = sdCircle(uv, r1+r2+.04);\n  float d2 = nGon(7, uv, r1);\n  float d1 = 10.*ngon_ring(7, uv, r1, 0.001);\n  float d4 = 20.*sdRingRing(uv, r1+r2, r2, 0.001);\n  float d5 = 20.*ngon_ringring(7, uv, r1, r2, 0.001);\n  return shapecomb(res, fillbit, m, d0, d1, d2, d3, d4, d5);\n}\n\nfloat shape_3(in float res, in int fillbit, in vec2 uv, in float r1, in float r2, in float m) {\n  float d0 = sdRing(uv, r1+r2, r2);\n  float d3 = sdCircle(uv, r1+r2+.04);\n  float d2 = nGon(6, uv, r1);\n  float d1 = 10.*ngon_ring(6, uv, r1, 0.001);\n  float d4 = 20.*sdRingRing(uv, r1+r2, r2, 0.001);\n  float d5 = 20.*ngon_ringring(6, uv, r1, r2, 0.001);\n  return shapecomb(res, fillbit, m, d0, d1, d2, d3, d4, d5);\n}\n\nfloat shape_4(in float res, in int fillbit, in vec2 uv, in float r1, in float r2, in float m) {\n  float d0 = sdRing(uv, r1+r2, r2);\n  float d3 = sdCircle(uv, r1+r2+.04);\n  float d2 = nGon(5, uv, r1);\n  float d1 = 10.*ngon_ring(5, uv, r1, 0.001);\n  float d4 = 20.*sdRingRing(uv, r1+r2, r2, 0.001);\n  float d5 = 20.*ngon_ringring(5, uv, r1, r2, 0.001);\n  return shapecomb(res, fillbit, m, d0, d1, d2, d3, d4, d5);\n}\n\nfloat shape_5(in float res, in int fillbit, in vec2 uv, in float r1, in float r2, in float m) {\n  float d0 = sdRing(uv, r1+r2, r2);\n  float d3 = sdCircle(uv, r1+r2+.04);\n  float d2 = nGon(4, uv, r1);\n  float d1 = 10.*ngon_ring(4, uv, r1, 0.001);\n  float d4 = 20.*sdRingRing(uv, r1+r2, r2, 0.001);\n  float d5 = 20.*ngon_ringring(4, uv, r1, r2, 0.001);\n  return shapecomb(res, fillbit, m, d0, d1, d2, d3, d4, d5);\n}\n\nfloat shape_6(in float res, in int fillbit, in vec2 uv, in float r1, in float r2, in float m) {\n  float d0 = sdRing(uv, r1+r2, r2);\n  float d3 = sdCircle(uv, r1+r2+.04);\n  float d2 = nGon(3, uv, r1);\n  float d1 = 10.*ngon_ring(3, uv, r1, 0.001);\n  float d4 = 20.*sdRingRing(uv, r1+r2, r2, 0.001);\n  float d5 = 20.*ngon_ringring(3, uv, r1, r2*.5, 0.001);\n  return shapecomb(res, fillbit, m, d0, d1, d2, d3, d4, d5);\n}\n\nvec3 col_1 = vec3(109.,50.,116.)/vec3(255.);\nvec3 col_2 = vec3(179.,74.,43.)/vec3(255.);\nvec3 col_4 = vec3(66.,110.,58.)/vec3(255.);\nvec3 col_3 = vec3(55.,49.,93.)/vec3(255.);\nvec3 col_5 = vec3(161.,49.,41.)/vec3(255.);\nvec3 col_6 = vec3(252.,190.,60.)/vec3(255.);\nvec3 col_bg = vec3(244.,239.,224.)/vec3(255.);\nvec3 col_bg_dark = vec3(192.,191.,173.)/vec3(255.);\nvec3 col_intersect = vec3(37.,33.,30.)/vec3(255.);\n\nvec4  fC ( in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    p/=1.4;\n    //p+=vec2(.0, -.15);\n    p += vec2(0., -.03);\n\n//p/=4.;\n//p+=vec2(-.4,-.2);\n\n    vec3 col = col_bg;\n\n    float m = 0.;\n\n    float q =  mod(iTime/2., 5.);\n\n\n         if (q <= 1.) q = 0. + gain(q - 0., 6.);\n    else if (q <= 2.) q = 1. + gain(q - 1., 4.);\n    else if (q <= 3.) q = 2. + gain(q - 2., 5.);\n    else if (q <= 4.) q = 3. + gain(q - 3., 6.);\n    else if (q <= 5.) q = 4. + gain(q - 4., 5.);\n    else if (q <= 6.) q = 5. + gain(q - 5., 6.);\n\n    m = shape_1(m, 0, rotate(p + vec2(.0020, .0300), 0.000), 0.600, 0.014, q);\n    m = shape_2(m, 1, rotate(p + vec2(.0580, .0870), 0.110), 0.520, 0.015, q);\n    m = shape_3(m, 2, rotate(p + vec2(.1040, .0130), 0.560), 0.432, 0.014, q);\n    m = shape_4(m, 3, rotate(p + vec2(.0160, .0100), 0.350), 0.344, 0.020, q);\n    m = shape_5(m, 4, rotate(p + vec2(.0910, .0680), 0.665), 0.248, 0.024, q);\n    m = shape_6(m, 5, rotate(p + vec2(.0055, .0055), 2.235), 0.144, 0.050, q);\n\n    vec4 col_shapes = vec4(0.);\n    if (isBitSet(m, 0)) col_shapes = vec4(col_1, 1.);\n    if (isBitSet(m, 1)) col_shapes = vec4(col_2, 1.);\n    if (isBitSet(m, 2)) col_shapes = vec4(col_3, 1.);\n    if (isBitSet(m, 3)) col_shapes = vec4(col_4, 1.);\n    if (isBitSet(m, 4)) col_shapes = vec4(col_5, 1.);\n    if (isBitSet(m, 5)) col_shapes = vec4(col_6, 1.);\n\n    vec4 col_intersect_any = vec4(0.);\n    if (popcount(m) > 1)\n        col_intersect_any = vec4(col_intersect, 1.);\n\n    vec4 col_xor = vec4(0.);\n\n    if (isBitSet(m, 5) && !isBitSet(m, 4))\n        col_xor = vec4(col_bg, 1.);\n    if (isBitSet(m, 4) && !isBitSet(m, 3))\n        col_xor = vec4(col_bg, 1.);\n    if (isBitSet(m, 3) && !isBitSet(m, 2))\n        col_xor = vec4(col_bg, 1.);\n    if (isBitSet(m, 2) && !isBitSet(m, 1))\n        col_xor = vec4(col_bg, 1.);\n    if (isBitSet(m, 1) && !isBitSet(m, 0))\n        col_xor = vec4(col_bg, 1.);\n\n         if (q <= 1.) col_xor = vec4(0.);\n    else if (q <= 2.) col_xor = vec4(0.);\n    else if (q <= 3.) col_xor = vec4(col_xor.xyz, smoothstep(0., col_xor.w, q - 2.));\n    else if (q <= 4.) col_xor = vec4(col_xor.xyz, smoothstep(col_xor.w, 0., q - 3.));\n    else if (q <= 5.) col_xor = vec4(0.);\n    else if (q <= 6.) col_xor = vec4(0.);\n\n    vec3 bgcol[7] = vec3[](col_bg, col_bg, col_bg_dark, col_bg_dark, col_bg, col_bg, col_bg);\n\n    if (col_shapes.w > 0.) col = col_shapes.xyz;\n    else\n    {\n       for (int i = 0; i < bgcol.length(); ++i) {\n            if (q <= float(i + 1)) {\n                col = mix(bgcol[i], bgcol[(i + 1) % bgcol.length()], q - float(i)).xyz;\n                break;\n            }\n       }\n    }\n\n         if (q <= 1.) col = mix(col, col_intersect_any.xyz, col_intersect_any.w > 0. ? (1.-(q-0.)) : 0.);\n    else if (q <= 2.) col = mix(col, col_intersect_any.xyz, 0.);\n    else if (q <= 3.) col = mix(col, col_intersect_any.xyz, 0.);\n    else if (q <= 4.) col = mix(col, col_intersect_any.xyz, col_intersect_any.w > 0. ? (   (q-3.)) : 0.);\n    else if (q <= 5.) col = mix(col, col_intersect_any.xyz, col_intersect_any.w);\n    else if (q <= 6.) col = mix(col, col_intersect_any.xyz, col_intersect_any.w);\n\n    //col = mix(col, col_xor.xyz, col_xor.w);\n    //col += col_xor.xyz * col_xor.w;\n\n    return vec4(col, 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n\n    // Antialiasing from https://www.shadertoy.com/view/wtjfRV\n    float A = 8., s = 1./A, x, y;\n\n    for (x=-.5; x<.5; x+=s) for (y=-.5; y<.5; y+=s) fragColor += min ( fC(vec2(x,y)+fragCoord), 1.0);\n\n    fragColor /= A*A;\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    fragColor = vec4(fragColor.xyz + noise(p)/18.,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}