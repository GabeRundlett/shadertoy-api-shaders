{
    "Shader": {
        "info": {
            "date": "1693708940",
            "description": "I have little idea how Navier-Stokes works, but I do know that this is just a toy model. Trying to use my best numerical techniques and basic knowledge about weather to make something cool.",
            "flags": 32,
            "hasliked": 0,
            "id": "ml2fzR",
            "likes": 10,
            "name": "2D Weather Simulation",
            "published": 3,
            "tags": [
                "simulation",
                "fluid",
                "navier",
                "stokes"
            ],
            "usePreview": 0,
            "username": "Zi7ar21",
            "viewed": 333
        },
        "renderpass": [
            {
                "code": "// Fork of \"Navier-Stokes Fluid Simulation\" by Zi7ar21. https://shadertoy.com/view/flyfzw\n// 2023-09-03 02:02:40\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if(fragCoord.y > 0.5 * iResolution.y) {\n        fragColor = vec4(texelFetch(iChannel2, ivec2(fragCoord), 0).xxx, 1.0);\n        fragColor = vec4(abs(fragColor.rgb) * (fragColor.x > 0.0 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0)), 1.0);\n        //fragColor.rgb *= 2.0;\n    }\n    else {\n        fragColor = vec4(texelFetch(iChannel0, ivec2(fragCoord), 0).xyz, 1.0);\n    }\n\n    fragColor = vec4(texelFetch(iChannel0, ivec2(fragCoord), 0).xyz, 1.0);\n    fragColor = vec4(texelFetch(iChannel0, ivec2(fragCoord), 0).xyw, 1.0);\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0); fragColor = vec4(length(fragColor.xy), fragColor.z, fragColor.w, 1.0);\n\n    //fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    //fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    //fragColor = texelFetch(iChannel2, ivec2(fragCoord), 0);\n    //fragColor = texelFetch(iChannel3, ivec2(fragCoord), 0);\n\n    //fragColor = vec4(texelFetch(iChannel0, ivec2(fragCoord), 0).zzz, 1.0);\n    //fragColor = vec4(texelFetch(iChannel0, ivec2(fragCoord), 0).www, 1.0);\n    //fragColor = vec4(texelFetch(iChannel0, ivec2(fragCoord), 0).zww, 1.0);\n\n    //vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    //fragColor = vec4(vec3(fbm(10.0*uv)), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float dot2(vec2 v) { return dot(v,v); }\nfloat dot2(vec3 v) { return dot(v,v); }\nfloat dot2(vec4 v) { return dot(v,v); }\n\n// Do more pressure passes across multiple frames\n#define STEP_INTERVAL 4\n\nvec4 texelFetch_repeat(sampler2D _sampler, ivec2 _coord, int _lod) {\n    // no idea why the -1 is neccesary but the pressure is slightly wrong without it\n    // maybe textureSize() is wrong?\n    ivec2 _textureSize = textureSize(_sampler, _lod) - 1;\n\n    // :sob: in GLSL, the % operator is undefined if one or both input integers are negative\n    // so we blasphemously convert our integers to floats and back and use the float modulo\n    //_coord.x = int(mod(float(_coord.x), float(_textureSize.x)));\n    //_coord.y = int(mod(float(_coord.y), float(_textureSize.y)));\n    //return texelFetch(_sampler, _coord, _lod);\n\n    // fixed! https://www.alecjacobson.com/weblog/?p=1140\n    return texelFetch(_sampler, ((_coord % _textureSize) + _textureSize) % _textureSize, _lod);\n}\n\n// If defined, PCG will be used for Random Number Generation\n// http://www.pcg-random.org/\n//#define USE_PCG_RANDOM\n\n// ##### Constants #####\n\n/*\nhttps://float.exposed/\nhttp://www.mimirgames.com/articles/programming/digits-of-pi-needed-for-floating-point-numbers/\n*/\n\n/*\nIt's convenient to make constant floating-point variables with the best possible precision so you don't need to type them everywhere,\nand precomputing their inverses allows you to change division (which is slow) into multiplication e.g. x / PI = INV_PI * x\n*/\n\n//const float     PI = glm::uintBitsToFloat(0x40490FDBU); // Pi\n//const float INV_PI = glm::uintBitsToFloat(0x3EA2F983U); // 1 / Pi\n//const float     TAU = glm::uintBitsToFloat(0x40C90FDBU); // 2 * Pi = \"Tau\"\n//const float INV_TAU = glm::uintBitsToFloat(0x3E22F983U); // 1 / (2 * Pi)\n\nconst float     PI = 3.1415926535897932384626433832795028841971693993751058209749445923; // Pi\nconst float INV_PI = 0.3183098861837906715377675267450287240689192914809128974953346881; // 1 / Pi\n\nconst float     TAU = 6.2831853071795864769252867665590057683943387987502116419498891846; // 2 * Pi = \"Tau\"\nconst float INV_TAU = 0.1591549430918953357688837633725143620344596457404564487476673441; // 1 / (2 * Pi)\n\n// 2^32 (but slightly different, so 32-bit RNG doesn't ever reach 0.0 or 1.0)\n// I know I said \"C++11 lacks a real way to do this\" earlier but there's no real way to get the closest\n// but still *slightly* different float besides using hexadecimal\nconst float     RNG32_MAX = uintBitsToFloat(0x4F7FFFFFU); // Actual: 0x4F800000U\nconst float INV_RNG32_MAX = uintBitsToFloat(0x2F7FFFFFU); // Actual: 0x2F800000U\n\n// ##### Random Number Generator #####\n\n#ifdef USE_PCG_RANDOM\n// See michael0884's usage of PCG Random\n// https://www.shadertoy.com/view/wltcRS\n// https://www.shadertoy.com/view/WttyWX\n\nstruct rng_state_t {\n    uvec4 seed;\n};\n\nvoid init_rng(inout rng_state_t rng_state, vec2 pixel_coord, vec2 res, int frame_number) {\n    uvec2 coord = uvec2(pixel_coord);\n\n    rng_state.seed = uvec4(coord, uint(frame_number), coord.x + coord.y);\n\n    //rng_state.seed = uvec4(frame, frame * 15843, frame * 31 + 4566, frame * 2345 + 58585);\n}\n\n// http://www.pcg-random.org/\nuvec4 pcg4d(uvec4 v) {\n\tv = v * 0x0019660Du + 0x3C6EF35Fu;\n    v.x += v.y * v.w; v.y += v.z * v.x; v.z += v.x * v.y; v.w += v.y * v.z;\n    v = v ^ (v >> 16u);\n    v.x += v.y * v.w; v.y += v.z * v.x; v.z += v.x * v.y; v.w += v.y * v.z;\n\n    return v;\n}\n\nfloat rand(inout rng_state_t rng_state) {\n    rng_state.seed = pcg4d(rng_state.seed);\n\n    return INV_RNG32_MAX * float(rng_state.seed.x);\n}\n\nvec2 rand2(inout rng_state_t rng_state) {\n    rng_state.seed = pcg4d(rng_state.seed);\n\n    return INV_RNG32_MAX * vec2(rng_state.seed.xy);\n}\n\nvec3 rand3(inout rng_state_t rng_state) {\n    rng_state.seed = pcg4d(rng_state.seed);\n\n    return INV_RNG32_MAX * vec3(rng_state.seed.xyz);\n}\n\nvec4 rand4(inout rng_state_t rng_state) {\n    rng_state.seed = pcg4d(rng_state.seed);\n\n    return INV_RNG32_MAX * vec4(rng_state.seed);\n}\n#else\nstruct rng_state_t {\n    uint seed;\n};\n\nvoid init_rng(inout rng_state_t rng_state, vec2 pixel_coord, vec2 res, int frame_number) {\n    pixel_coord = floor(pixel_coord);\n\n    rng_state.seed = uint(frame_number) * uint(res.x * res.y) + uint(pixel_coord.x + res.x * pixel_coord.y) + 1u;\n}\n\n// Triple32 Hash: https://nullprogram.com/blog/2018/07/31/\n// this hash in particular is remarkable because it's a statistically perfect 32-bit integer hash (of this kind)\nuint triple32(uint x) {\n    x ^= x >> 17u;\n    x *= 0xED5AD4BBu;\n    x ^= x >> 11u;\n    x *= 0xAC4C1B51u;\n    x ^= x >> 15u;\n    x *= 0x31848BABu;\n    x ^= x >> 14u;\n    return x;\n}\n\nfloat rand(inout rng_state_t rng_state) {\n    rng_state.seed = triple32(rng_state.seed);\n\n    return INV_RNG32_MAX * float(rng_state.seed);\n}\n\nvec2 rand2(inout rng_state_t rng_state) {\n    vec2 v;\n    v.x = rand(rng_state);\n    v.y = rand(rng_state);\n    return v;\n}\n\nvec3 rand3(inout rng_state_t rng_state) {\n    vec3 v;\n    v.x = rand(rng_state);\n    v.y = rand(rng_state);\n    v.z = rand(rng_state);\n    return v;\n}\n\nvec4 rand4(inout rng_state_t rng_state) {\n    vec4 v;\n    v.x = rand(rng_state);\n    v.y = rand(rng_state);\n    v.z = rand(rng_state);\n    v.w = rand(rng_state);\n    return v;\n}\n#endif\n\nvec2 udir2(inout rng_state_t rng_state) {\n    float z = rand(rng_state);\n    float t = TAU * z;\n    float c = cos(t), s = sin(t);\n    return vec2(c, s);\n}\n\nvec3 udir3(inout rng_state_t rng_state) {\n    vec2 z = rand2(rng_state);\n    vec2 t = vec2(TAU * z.x, acos(2.0 * z.y - 1.0));\n    vec2 c = cos(t), s = sin(t);\n    return vec3(c.x * s.y, s.x * s.y, c.y);\n}\n\n// Box-Muller Transform\n// https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform\nvec2 nrand2(float sigma, vec2 mean, inout rng_state_t rng_state) {\n    vec2 z = rand2(rng_state);\n    return mean + sigma * sqrt(-2.0 * log(z.x   )) * vec2(cos(TAU * z.y), sin(TAU * z.y));\n}\n\nvec3 nrand3(float sigma, vec3 mean, inout rng_state_t rng_state) {\n    vec4 z = rand4(rng_state);\n    return mean + sigma * sqrt(-2.0 * log(z.xxy )) * vec3(cos(TAU * z.z), sin(TAU * z.z), cos(TAU * z.w));\n}\n\nvec4 nrand4(float sigma, vec4 mean, inout rng_state_t rng_state) {\n    vec4 z = rand4(rng_state);\n    return mean + sigma * sqrt(-2.0 * log(z.xxyy)) * vec4(cos(TAU * z.z), sin(TAU * z.z), cos(TAU * z.w), sin(TAU * z.w));\n}\n\nvec2 pixel_filter(vec2 coord, float width, rng_state_t rng_state) {\n    return coord + width * (rand2(rng_state) - 0.5); // box filter, uniform over entire pixel\n    //return nrand2(width, coord, rng_state); // normal filter, normal distribution\n}\n\n// psrdnoise: https://github.com/stegu/psrdnoise\n/* BEGIN SNIPPET */\nfloat mpsrdnoise(vec2 x, float alpha)\n{\n\tvec2 uv = vec2(x.x + x.y*0.5, x.y);\n\tvec2 i0 = floor(uv), f0 = fract(uv);\n\tfloat cmp = step(f0.y, f0.x);\n\tvec2 o1 = vec2(cmp, 1.0-cmp);\n\tvec2 i1 = i0 + o1, i2 = i0 + 1.0;\n\tvec2 v0 = vec2(i0.x - i0.y*0.5, i0.y);\n\tvec2 v1 = vec2(v0.x + o1.x - o1.y*0.5, v0.y + o1.y);\n\tvec2 v2 = vec2(v0.x + 0.5, v0.y + 1.0);\n\tvec2 x0 = x - v0, x1 = x - v1, x2 = x - v2;\n\tvec3 iu, iv, xw, yw;\n\n    xw = vec3(v0.x, v1.x, v2.x);\n    yw = vec3(v0.y, v1.y, v2.y);\n    iu = floor(xw + 0.5*yw + 0.5);\n    iv = floor(yw + 0.5);\n\n\t// Hash permutation carefully tuned to stay within the range\n\t// of exact representation of integers in a half-float.\n\t// Tons of mod() operations here, sadly.\n\tvec3 iu_m49 = mod(iu, 49.0);\n\tvec3 iv_m49 = mod(iv, 49.0);\n\tvec3 hashtemp = mod(14.0*iu_m49 + 2.0, 49.0);\n\thashtemp = mod(hashtemp*iu_m49 + iv_m49, 49.0);\n\tvec3 hash = mod(14.0*hashtemp + 4.0, 49.0);\n\thash = mod(hash*hashtemp, 49.0);\n\t\n\tvec3 psi = hash*0.1282282715750936015699038115624286891509048734438818702438752895 + alpha; // 0.1282283 is 2*pi/49\n\tvec3 gx = cos(psi); vec3 gy = sin(psi);\n\tvec2 g0 = vec2(gx.x, gy.x);\n\tvec2 g1 = vec2(gx.y, gy.y);\n\tvec2 g2 = vec2(gx.z, gy.z);\n\tvec3 w = 0.8 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2));\n\tw = max(w, 0.0); vec3 w2 = w*w; vec3 w4 = w2*w2;\n\tvec3 gdotx = vec3(dot(g0, x0), dot(g1, x1), dot(g2, x2));\n\tfloat n = dot(w4, gdotx);\n\t//vec3 w3 = w2*w; vec3 dw = -8.0*w3*gdotx;\n\t//vec2 dn0 = w4.x*g0 + dw.x*x0;\n\t//vec2 dn1 = w4.y*g1 + dw.y*x1;\n\t//vec2 dn2 = w4.z*g2 + dw.z*x2;\n\t//gradient = 10.9*(dn0 + dn1 + dn2);\n\treturn 10.9*n;\n}\n/* END SNIPPET */\n\nfloat fbm(vec2 x) {\n    return\n    0.5333333333333333 * mpsrdnoise(1.0 * x, 0.0)+\n    0.2666666666666667 * mpsrdnoise(2.0 * x, 1.0)+\n    0.1333333333333333 * mpsrdnoise(4.0 * x, 2.0)+\n    0.0666666666666667 * mpsrdnoise(8.0 * x, 3.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "vec4 texture_linear_clamp(sampler2D _sampler, vec2 _P) {\n    // texture() maps texels from ivec2(0) to ivec2(texture_size) to vec2(1.0 / texture_size) to vec2(1.0 - 1/texture_size)\n    // this maps texels from ivec2(0)\n\n    ivec2 _textureSize = textureSize(_sampler, 0).xy - ivec2(1, 1);\n\n    _P *= vec2(_textureSize);\n\n    vec2 _f = fract(_P);\n\n    vec4 _texel00 = texelFetch(_sampler, clamp(ivec2(_P) + ivec2(0, 0), ivec2(0), _textureSize), 0);\n    vec4 _texel10 = texelFetch(_sampler, clamp(ivec2(_P) + ivec2(1, 0), ivec2(0), _textureSize), 0);\n    vec4 _texel01 = texelFetch(_sampler, clamp(ivec2(_P) + ivec2(0, 1), ivec2(0), _textureSize), 0);\n    vec4 _texel11 = texelFetch(_sampler, clamp(ivec2(_P) + ivec2(1, 1), ivec2(0), _textureSize), 0);\n\n    return mix(mix(_texel00, _texel10, _f.x), mix(_texel01, _texel11, _f.x), _f.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    rng_state_t rng_state;\n\n    init_rng(rng_state, fragCoord, iResolution.xy, iFrame);\n\n    //fragCoord = floor(fragCoord);\n\n    if(iFrame < 1) {\n        //fragColor = vec4(texture(iChannel2, mod(fragCoord / 4096.0, 1.0)).xy - 0.5, texture(iChannel2, mod(fragCoord / 512.0, 1.0)).z, 0.0);\n        //fragColor.x += 0.5;\n        fragColor = vec4(1.0*(fragCoord.y/iResolution.y), 0.0, 0.8*(1.0 - (fragCoord.y / iResolution.y)), 0.0);\n\n        /*\n        if(fragCoord.y > 0.25 * iResolution.y && fragCoord.y < 0.75 * iResolution.y) {\n            fragColor.x += 1.0;\n            fragColor.z += 1.0;\n        }\n        else {\n            fragColor.x -= 1.0;\n            fragColor.z += 0.0;\n        }*/\n        \n        /*\n        if(fragCoord.x < 0.5 * iResolution.x) {\n            fragColor.x += 0.0;\n            fragColor.y += 1.0;\n            fragColor.z += 1.0;\n        }\n        else{\n            fragColor.x -= 0.0;\n            fragColor.y -= 1.0;\n            fragColor.z += 0.0;\n        }\n        */\n\n        //fragColor.xy += 0.1 * (texture(iChannel2, fragCoord / 512.0).xy - 0.5);\n        fragColor.xy += nrand2(0.1, vec2(0), rng_state);\n\n        if(fragCoord.y < 20.0*fbm(vec2(0.01*fragCoord.x,0.0))+20.0) {\n            fragColor = vec4(0.0, 0.0,\n            2.0-0.01*fragCoord.y,\n            max(1.0-fragCoord.y/30.0, 0.0));\n        }\n\n        return;\n    }\n\n    if((iFrame % STEP_INTERVAL) != 0) {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n        return;\n    }\n\n    //fragColor = texture_linear_clamp(iChannel1, mod(floor(fragCoord) / 255.0, 1.0));\n\n    const float h = 1.0;\n    //fragColor = texture(iChannel1, (fragCoord) / iResolution.xy);\n    //fragColor = texture(iChannel1, (fragCoord - (1.0 * fragColor.xy)) / iResolution.xy);\n    vec2 k1 = texelFetch(iChannel1, ivec2(fragCoord), 0).xy;\n    vec2 k2 = texture(iChannel1, (fragCoord - 0.5 * h * k1) / iResolution.xy).xy;\n    vec2 k3 = texture(iChannel1, (fragCoord - 0.5 * h * k2) / iResolution.xy).xy;\n    vec2 k4 = texture(iChannel1, (fragCoord - h * k3) / iResolution.xy).xy;\n    fragColor = texture(iChannel1, (fragCoord - (h/3.0*(0.5*k1+k2+k3+0.5*k4))) / iResolution.xy);\n    \n\n    // vorticy injection\n    //fragColor.xy += texelFetch(iChannel0, ivec2(fragCoord), 0).z*0.05*(texture(iChannel2, (fragCoord + vec2(69.0*sin(iTime * 123.0), 42.0*cos(iTime*456.0))) / 512.0).xy - 0.5);\n    fragColor.xy += nrand2(fragColor.z*0.00025, vec2(0), rng_state);\n\n    float temp_grad =\n     0.0035714285714285714285714285714285714285714285714285714285714286 * texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(0, 4), 0).z +\n    -0.0380952380952380952380952380952380952380952380952380952380952381 * texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(0, 3), 0).z +\n     0.2000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(0, 2), 0).z +\n    -0.8000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(0, 1), 0).z +\n     0.8000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(0, 1), 0).z +\n    -0.2000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(0, 2), 0).z +\n     0.0380952380952380952380952380952380952380952380952380952380952381 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(0, 3), 0).z +\n    -0.0035714285714285714285714285714285714285714285714285714285714286 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(0, 4), 0).z;\n\n    fragColor.y += h * ((0.2 * temp_grad) - 0.001);\n    //fragColor.y += h * 0.01 * fragColor.z;\n    //fragColor.y += 0.001;\n\n    vec2 uv = 2.0 * (fragCoord - 0.5 * iResolution.xy) / max(iResolution.x, iResolution.y);\n\n    //fragColor.x += h * 0.5 * exp(-dot2(50.0 * (vec2(-0.5, 0.0) - uv)));\n    //fragColor.z += h * 0.5 * exp(-dot2(50.0 * (vec2(-0.5, 0.0) - uv)));\n\n    if(fragCoord.y < 20.0*fbm(vec2(0.01*fragCoord.x,0.0))+20.0) {\n        fragColor = vec4(0.0, 0.0,\n        2.0-0.01*fragCoord.y,\n        max(1.0-fragCoord.y/30.0, 0.0));\n    }\n\n    if(iMouse.z > 0.1) fragColor.z += 0.2 * max(1.0 - 0.1 * length(iMouse.xy - fragCoord), 0.0);\n\n    //fragColor.z *= 0.998+0.002*(fragCoord.y/iResolution.y);\n\n    if(fragCoord.y > iResolution.y-3.0) fragColor = vec4(0.0);\n    if(fragCoord.y > iResolution.y-6.0) fragColor.z *= 0.99;\n\n    //fragColor.y*=0.999;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if((iFrame % STEP_INTERVAL) != 0) {\n        fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n\n        return;\n    }\n\n    /*\n    float x0 = texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(1, 0), 0).x;\n    float x1 = texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(1, 0), 0).x;\n    float y0 = texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(0, 1), 0).y;\n    float y1 = texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(0, 1), 0).y;\n\n    fragColor = vec4(0.5 * ((x1 - x0) + (y1 - y0)), 0.0, 0.0, 0.0); // divergence\n    */\n\n    /*\n    fragColor = vec4(\n     0.08333333333 * texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(2, 0), 0).x +\n    -0.66666666666 * texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(1, 0), 0).x +\n     0.66666666666 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(1, 0), 0).x +\n    -0.08333333333 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(2, 0), 0).x +\n     0.08333333333 * texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(0, 2), 0).y +\n    -0.66666666666 * texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(0, 1), 0).y +\n     0.66666666666 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(0, 1), 0).y +\n    -0.08333333333 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(0, 2), 0).y,\n    0.0, 0.0, 0.0); // divergence\n    */\n\n    fragColor = vec4(\n     0.0035714285714285714285714285714285714285714285714285714285714286 * texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(4, 0), 0).x +\n    -0.0380952380952380952380952380952380952380952380952380952380952381 * texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(3, 0), 0).x +\n     0.2000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(2, 0), 0).x +\n    -0.8000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(1, 0), 0).x +\n     0.8000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(1, 0), 0).x +\n    -0.2000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(2, 0), 0).x +\n     0.0380952380952380952380952380952380952380952380952380952380952381 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(3, 0), 0).x +\n    -0.0035714285714285714285714285714285714285714285714285714285714286 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(4, 0), 0).x +\n     0.0035714285714285714285714285714285714285714285714285714285714286 * texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(0, 4), 0).y +\n    -0.0380952380952380952380952380952380952380952380952380952380952381 * texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(0, 3), 0).y +\n     0.2000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(0, 2), 0).y +\n    -0.8000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(0, 1), 0).y +\n     0.8000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(0, 1), 0).y +\n    -0.2000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(0, 2), 0).y +\n     0.0380952380952380952380952380952380952380952380952380952380952381 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(0, 3), 0).y +\n    -0.0035714285714285714285714285714285714285714285714285714285714286 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(0, 4), 0).y,\n    0.0,\n    0.0,\n    0.0); // divergence\n\n    /*\n    fragColor = vec4(\n     1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(-1,  1), 0).x +\n     0.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 0,  1), 0).x +\n    -1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 1,  1), 0).x +\n    -2.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(-1,  0), 0).x +\n     0.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 0,  0), 0).x +\n    -2.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 1,  0), 0).x +\n     1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(-1, -1), 0).x +\n     0.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 0, -1), 0).x +\n    -1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 1, -1), 0).x+\n\n    -1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(-1,  1), 0).y +\n    -2.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 0,  1), 0).y +\n    -1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 1,  1), 0).y +\n     0.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(-1,  0), 0).y +\n     0.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 0,  0), 0).y +\n     0.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 1,  0), 0).y +\n     1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(-1, -1), 0).y +\n     2.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 0, -1), 0).y +\n     1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 1, -1), 0).y,\n     0.0,\n     0.0,\n     0.0);\n     */\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float divergence = texelFetch(iChannel1, ivec2(fragCoord), 0).x;\n\n    float x0 = texelFetch_repeat(iChannel2, ivec2(fragCoord) - ivec2(1, 0), 0).x;\n    float x1 = texelFetch_repeat(iChannel2, ivec2(fragCoord) + ivec2(1, 0), 0).x;\n    float y0 = texelFetch_repeat(iChannel2, ivec2(fragCoord) - ivec2(0, 1), 0).x;\n    float y1 = texelFetch_repeat(iChannel2, ivec2(fragCoord) + ivec2(0, 1), 0).x;\n\n    if(iFrame < 1) {\n        x0 = 0.0;\n        x1 = 0.0;\n        y0 = 0.0;\n        y1 = 0.0;\n    }\n\n   \tfragColor = vec4((x0 + x1 + y0 + y1 - divergence) * 0.25, 0.0, 0.0, 0.0);\n}\n*/\n\n/* */\n#define Pressure iChannel2\n#define Divergence iChannel1\nfloat ComputePressure4( vec2 fragCoord )\n{\n    float pressure = 0.0;\n    float divergence = 0.0;\n    \n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2(-4,  0), 0).x * 1.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2(-2,  0), 0).x * 16.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2(-3, -1), 0).x * 4.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2(-3,  1), 0).x * 4.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2( 0,  0), 0).x * 36.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2(-1, -1), 0).x * 24.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2(-1,  1), 0).x * 24.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2(-2, -2), 0).x * 6.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2(-2,  2), 0).x * 6.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2( 2,  0), 0).x * 16.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2( 1, -1), 0).x * 24.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2( 1,  1), 0).x * 24.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2( 0, -2), 0).x * 16.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2( 0,  2), 0).x * 16.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2(-1, -3), 0).x * 4.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2(-1,  3), 0).x * 4.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2( 4,  0), 0).x * 1.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2( 3, -1), 0).x * 4.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2( 3,  1), 0).x * 4.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2( 2, -2), 0).x * 6.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2( 2,  2), 0).x * 6.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2( 1, -3), 0).x * 4.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2( 1,  3), 0).x * 4.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2( 0, -4), 0).x * 1.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2( 0,  4), 0).x * 1.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2(-3,  0), 0).x * 1.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2(-1,  0), 0).x * 9.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2(-2, -1), 0).x * 3.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2(-2,  1), 0).x * 3.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2(-2,  0), 0).x * 4.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 1,  0), 0).x * 25.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 0, -1), 0).x * 25.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 0,  1), 0).x * 25.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 0,  0), 0).x * 16.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2(-1, -2), 0).x * 3.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2(-1, -1), 0).x * 8.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2(-1,  2), 0).x * 3.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2(-1,  1), 0).x * 8.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2(-1,  0), 0).x * 16.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 3,  0), 0).x * 1.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 2, -1), 0).x * 3.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 2,  1), 0).x * 3.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 2,  0), 0).x * 4.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 1, -2), 0).x * 3.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 1, -1), 0).x * 8.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 1,  2), 0).x * 3.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 1,  1), 0).x * 8.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 0, -3), 0).x * 1.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 0, -2), 0).x * 4.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 0,  3), 0).x * 1.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 0,  2), 0).x * 4.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 0,  0), 0).x * 64.0;\n\n    return (pressure - divergence) / 256.0;\n}\n/* */\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(ComputePressure4(fragCoord), 0.0, 0.0, 0.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    /*\n    float x0 = texelFetch_repeat(iChannel1, ivec2(fragCoord) - ivec2(1, 0), 0).x;\n    float x1 = texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(1, 0), 0).x;\n    float y0 = texelFetch_repeat(iChannel1, ivec2(fragCoord) - ivec2(0, 1), 0).x;\n    float y1 = texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(0, 1), 0).x;\n    vec2 pressure_gradient = 0.5 * (vec2(x1, y1) - vec2(x0, y0));\n    */\n    /*\n    vec2 pressure_gradient = vec2(\n     0.08333333333 * texelFetch_repeat(iChannel1, ivec2(fragCoord) - ivec2(2, 0), 0).x +\n    -0.66666666666 * texelFetch_repeat(iChannel1, ivec2(fragCoord) - ivec2(1, 0), 0).x +\n     0.66666666666 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(1, 0), 0).x +\n    -0.08333333333 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(2, 0), 0).x,\n     0.08333333333 * texelFetch_repeat(iChannel1, ivec2(fragCoord) - ivec2(0, 2), 0).x +\n    -0.66666666666 * texelFetch_repeat(iChannel1, ivec2(fragCoord) - ivec2(0, 1), 0).x +\n     0.66666666666 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(0, 1), 0).x +\n    -0.08333333333 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(0, 2), 0).x);\n    */\n\n    vec2 pressure_gradient = vec2(\n     0.0035714285714285714285714285714285714285714285714285714285714286 * texelFetch_repeat(iChannel1, ivec2(fragCoord) - ivec2(4, 0), 0).x +\n    -0.0380952380952380952380952380952380952380952380952380952380952381 * texelFetch_repeat(iChannel1, ivec2(fragCoord) - ivec2(3, 0), 0).x +\n     0.2000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel1, ivec2(fragCoord) - ivec2(2, 0), 0).x +\n    -0.8000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel1, ivec2(fragCoord) - ivec2(1, 0), 0).x +\n     0.8000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(1, 0), 0).x +\n    -0.2000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(2, 0), 0).x +\n     0.0380952380952380952380952380952380952380952380952380952380952381 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(3, 0), 0).x +\n    -0.0035714285714285714285714285714285714285714285714285714285714286 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(4, 0), 0).x,\n     0.0035714285714285714285714285714285714285714285714285714285714286 * texelFetch_repeat(iChannel1, ivec2(fragCoord) - ivec2(0, 4), 0).x +\n    -0.0380952380952380952380952380952380952380952380952380952380952381 * texelFetch_repeat(iChannel1, ivec2(fragCoord) - ivec2(0, 3), 0).x +\n     0.2000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel1, ivec2(fragCoord) - ivec2(0, 2), 0).x +\n    -0.8000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel1, ivec2(fragCoord) - ivec2(0, 1), 0).x +\n     0.8000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(0, 1), 0).x +\n    -0.2000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(0, 2), 0).x +\n     0.0380952380952380952380952380952380952380952380952380952380952381 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(0, 3), 0).x +\n    -0.0035714285714285714285714285714285714285714285714285714285714286 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(0, 4), 0).x);\n\n    /*\n    pressure_gradient = vec2(\n     1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(-1,  1), 0).x +\n     0.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 0,  1), 0).x +\n    -1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 1,  1), 0).x +\n    -2.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(-1,  0), 0).x +\n     0.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 0,  0), 0).x +\n    -2.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 1,  0), 0).x +\n     1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(-1, -1), 0).x +\n     0.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 0, -1), 0).x +\n    -1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 1, -1), 0).x,\n\n    -1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(-1,  1), 0).x +\n    -2.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 0,  1), 0).x +\n    -1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 1,  1), 0).x +\n     0.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(-1,  0), 0).x +\n     0.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 0,  0), 0).x +\n     0.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 1,  0), 0).x +\n     1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(-1, -1), 0).x +\n     2.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 0, -1), 0).x +\n     1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 1, -1), 0).x);\n    */\n\n    fragColor = vec4(texelFetch(iChannel0, ivec2(fragCoord), 0).xy - pressure_gradient, texelFetch(iChannel0, ivec2(fragCoord), 0).zw);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}