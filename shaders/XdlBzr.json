{
    "Shader": {
        "info": {
            "date": "1494650970",
            "description": "mouse does stuff.\nbetter while paused.\ndark=path\nbright=wall\n\nThis is just the the core of a \"Wunderkreis labyrinth\" which has only 1 node\nConvergent Minimalist Obfuscated labyrinths do not get more basic than such linear game design",
            "flags": 0,
            "hasliked": 0,
            "id": "XdlBzr",
            "likes": 5,
            "name": "spiral core wunderkreis",
            "published": 3,
            "tags": [
                "spiral",
                "trianglewave",
                "seesaw",
                "labyrinth",
                "wunderkreis",
                "choice",
                "node",
                "alrgory",
                "seesawwave"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 625
        },
        "renderpass": [
            {
                "code": "/*\nmouse does stuff\nbetter while paused.\nbright=wall\ndark =path\n\n----\n\nA \"wunderkreis labyrinth\" only has 1 node (crossroad), the \"outside\".\nA \"wunderkreis labyrinth\" can have multiple branches to its \"inside\".\nAll branches from its only node lead back to the same node.\n\nAs such, it is a very basic highly obfuscated and futile labyrinth\n...where coice does not matter.\n\nIt is an alegory to linear game design.\nA special property is that it has \na lot of parallel symmetry and convergence.\n\n-----\n\nthis is just the the CORE of a \"wunderkreis\" labyrinth \n\n parameters \n-[n]=number of periods= number of half_circle walls per half_circle\n-[o]=offset in number of periods bewteen the central wall ends.\n\n[o]=1 is most common.\nbut some nazka lines show that \n[o]>1 with more parallel lines have been famous in the past.\n\n---\n\nthis core_wunderkreis is extended by adding smaller caps,\nor another core_wunderkreis, to its open ends.\n\nA most common special \"wunderkreis\" \n...replaces all the large lower halfcircleRings \n...with 3 smaller halfcircleRings around 3 points\n...with the only 2 entrances between the 3 halfcircleRings.\n\nIt also most commonly warps the coordinate system \n...to get the entrances closer together.\n...to shift or fix the discontinuity in its second derivative.\n\n*/\n\n\nvec2 frame(vec2 u){u=u/iResolution.xy;u-=.5;\n u.x*=iResolution.x/iResolution.y;\n return u;}\n\n//golden angle ratio, to avoid interferrences of periods over time.\n#define phi (sqrt(5.)*.5-.5)\n//see https://en.wikipedia.org/wiki/Golden_angle\n//and think about [DFT]=[direct fourier transform] (in complex space).\n\n#define time iTime\n#define time1 (sin(time       )*.5+.5)\n#define time2 (sin(time*phi*2.)*.5+.5)\n\n#define snoothness time1*.5\n\n#define zoom (100.*time1+9.)\n\n//return triangle wave amp=1 period=1.\nfloat wTri(float x){x=fract(x);//get seesaw wave\n return abs(x*2.-1.);}//seesaw to triangle wave\n\n//return brightness of ripple of in distance [d] with [n] ripples within [r]\nfloat ripple(float d,float n,float r){\n d+=1.5;\n d=min(r,d);\n d=wTri(d);\n d=smoothstep(.5+snoothness,.5-snoothness,d);\n return d;}\n\n\nvoid mainImage(out vec4 O,in vec2 U){\n vec2 u=frame(U);\n u*=zoom;\n vec2 m=frame(iMouse.xy);\n float o=floor(-m.x    *zoom);\n float r=floor(1.-(m.y-.5)*zoom);\n float d;\n if (u.y>0.)d=ripple(length(u)   ,1.,r);\n else       d=ripple(length(u+vec2(o,0)),1.,r);\n //d.z+=mix(d.x,0.,time2);\n O=vec4(vec3(d),1);}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}