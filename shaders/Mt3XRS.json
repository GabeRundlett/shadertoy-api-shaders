{
    "Shader": {
        "info": {
            "date": "1480419509",
            "description": "Just a box with nice drawings... :) Nearly everything is generated by code.",
            "flags": 0,
            "hasliked": 0,
            "id": "Mt3XRS",
            "likes": 20,
            "name": "Chinese Box",
            "published": 3,
            "tags": [
                "procedural",
                "2d",
                "3d",
                "raymarching"
            ],
            "usePreview": 0,
            "username": "xbe",
            "viewed": 879
        },
        "renderpass": [
            {
                "code": "// Created by Xavier Benech - xbe/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Chinese box\n// Use \"chinese style\" 2D patterns to texture a box\n\n#define PI 3.141592654\n#define FAR 1000.\n#define DEG2RAD 3.141592654/180.\n\n#define CART2POLAR(x,y) vec2( sqrt(x*x + y*y), atan(y, x) )\n\n#define SHADE_NONE -1.\n#define SHADE_MAT 1.\n#define SHADE_GLOSSY_BOX 2.\n#define SHADE_GLOSSY_FLOOR 3.\n\n#define BOXCOLOR vec3(1.,0.1,0.02)\n\nconst vec3 LIGHTPOS0 = vec3(5.65, 4.5, 0.);\nconst vec3 LIGHTPOS1 = vec3(5.65*cos(2.*PI/3.), 4.5, 5.65*sin(2.*PI/3.));\nconst vec3 LIGHTPOS2 = vec3(5.65*cos(4.*PI/3.), 4.5, 5.65*sin(4.*PI/3.));\n\n////////////////////////////////////////////////////////////////////////////\n// Utils\n\nvec2 rotate(vec2 p, float a)\n{\n\treturn vec2(p.x * cos(a) + p.y * sin(a),\n\t\t\t\tp.y * cos(a) - p.x * sin(a));\n}\n\nvec3 rotateXZ(vec3 p, float a)\n{\n\treturn vec3(p.x * cos(a) + p.z * sin(a),\n                p.y,\n\t\t\t\tp.z * cos(a) - p.x * sin(a));\n}\n\nvec3 rotateXY(vec3 p, float a)\n{\n\treturn vec3(p.x * cos(a) + p.y * sin(a),\n                p.y * cos(a) - p.x * sin(a),\n                p.z);\n}\n\nvec3 rotateYZ(vec3 p, float a)\n{\n\treturn vec3(p.x,\n        \t\tp.y * cos(a) + p.z * sin(a),\n                p.z * cos(a) - p.y * sin(a));\n}\n\nmat4 rotationXYZ( float x, float y, float z )\n{\n    mat4 rotx = mat4(  1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, cos(x), -sin(x), 0.0,\n\t\t\t\t 0.0, sin(x), cos(x), 0.0,\n\t\t\t\t 0.0,   0.0,   0.0,   1.0 );\n    mat4 roty = mat4(  cos(y), 0.0, sin(y), 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t -sin(y), 0.0, cos(y), 0.0,\n\t\t\t\t 0.0,   0.0,   0.0,   1.0 );\n    mat4 rotz = mat4(  cos(z), -sin(z), 0.0, 0.0,\n\t\t\t\t sin(z), cos(z), 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t 0.0,   0.0,   0.0,   1.0 );\n\treturn rotz*roty*rotx;\n}\n\n////////////////////////////////////////////////////////////////////////////\n// DECORATIONS\n\nfloat circle(vec2 p, float r, float width)\n{\n    float d = 0.;\n    d += smoothstep(1., 0., width*abs(p.x - r));\n    return d;\n}\n\nfloat stripes(vec2 p, float a, float width)\n{\n    float d = 0.;\n    d += smoothstep(1., 0., width*abs(abs(p.y) - a));\n    return d;\n}\n\nfloat zebra(vec2 p, float width)\n{\n    float d = 0.;\n    d += smoothstep(1., 0., width*abs(p.x - p.y));\n    d += smoothstep(1., 0., width*abs(p.x + p.y));\n    return d;\n}\n\nfloat arc(vec2 p, float r, float a, float width)\n{\n    float d = 0.;\n    if (abs(p.y) < a) {\n\t    d += smoothstep(1., 0., width*abs(p.x - r));\n    }\n    return d;\n}\n\nfloat mirror(float x, float v, float width)\n{\n    float d = 0.;\n    d += smoothstep(1., 0., width*abs(x - v));\n    d += smoothstep(1., 0., width*abs(x - abs(v)));\n    d += smoothstep(1., 0., width*abs(abs(x) - v));\n    d += smoothstep(1., 0., width*abs(abs(x) - abs(v)));\n    return d;\n}\n\nfloat rose(vec2 p, float t, float width)\n{\n    const float a = 6.;\n    p.x *= 7. + 8. * t;\n    return mirror(p.x, sin(a * p.y), width);\n}\n\nfloat rose2(vec2 p, float t, float width)\n{\n    const float a = 6.;\n    p.x *= 7. + 8. * t;\n    return mirror(p.x, cos(a * p.y), width);\n}\n\nfloat fun(vec2 p, float t, float width)\n{\n    const float a = 6.;\n    p.x *= 7. + 8. * t;\n    return mirror(sin(a * p.x / PI), cos(a * p.y / PI), width);\n}\n\nfloat fun2(vec2 p, float t, float width)\n{\n    const float a = 6.;\n    p.x *= 7. + 8. * t;\n    return mirror(p.x, sin(a * p.y)+cos(a * p.y), width);\n}\n\nfloat spiral(vec2 p, float width)\n{\n    return mirror(p.x, 0.5 * p.y / PI, width);\n}\n\nfloat BoxLotus1(vec2 p)\n{\n    float res = 0.;\n    if (p.x < 0.7325) {\n\t    vec2 c;\n\t    vec2 f;\n        if (p.x < 0.25) {\n\t        c = vec2(0.25, PI / 4.);\n            f = mod(p, c) - 0.5 * c;\n            res += spiral(vec2(f.x, f.y), 192.);\n            res += spiral(vec2(0.9*f.x, f.y + 0.05), 192.);\n            res += spiral(vec2(0.8*f.x, f.y + 0.075), 192.);\n            res += spiral(vec2(0.7*f.x, f.y + 0.1), 192.);\n    \t}\n        if (p.x > 0.125 && p.x < 0.4) {\n            p.x *= 0.8;\n\t        c = vec2(0.25, PI / 4.);\n            f = mod(p, c) - 0.5 * c;\n            f.x *= 1.;\n            f.y *= 1.;\n            float d = 0.75;\n            res += fun2(vec2(f.x, f.y*f.y), d, 16.);\n            res += fun2(vec2(f.x + 0.01, f.y*f.y + 0.05), d, 16.);\n            res += fun2(vec2(f.x - 0.01, f.y*f.y + 0.05), d, 16.);\n            res += fun2(vec2(f.x + 0.02, f.y*f.y + 0.075), d, 16.);\n            res += fun2(vec2(f.x - 0.02, f.y*f.y + 0.075), d, 16.);\n    \t}\n    }\n    return res;\n}\n\nfloat BoxLotus2(vec2 p)\n{\n    float res = 0.;\n    vec2 c;\n    vec2 f;\n    if (p.x < 0.25) {\n        c = vec2(0.25, PI / 4.5);\n        f = mod(p, c) - 0.5 * c;\n        res += rose(vec2(f.x, f.y), 1., 12.);\n        res += rose(vec2(0.9*f.x, f.y + 0.05), 1., 12.);\n        res += rose(vec2(0.8*f.x, f.y + 0.075), 1., 12.);\n        res += rose(vec2(0.7*f.x, f.y + 0.1), 1., 12.);\n    }\n    if (p.x > 0.125 && p.x < 0.3) {\n        p.y += 1.247*PI;\n        c = vec2(0.25, PI / 4.5);\n        f = mod(p, c) - 0.5 * c;\n        f.x *= 1.0;\n        f.y *= 2.;\n        res += fun(vec2(f.x, f.y*f.y), -0.4, 32.);\n        res += fun(vec2(f.x + 0.01, f.y*f.y + 0.05), -0.4, 32.);\n        res += fun(vec2(f.x + 0.01, f.y*f.y - 0.05), -0.4, 32.);\n        res += fun(vec2(f.x + 0.02, f.y*f.y + 0.075), -0.4, 32.);\n        res += fun(vec2(f.x + 0.02, f.y*f.y - 0.075), -0.4, 32.);\n    }\n\tres += circle(p, 0.30, 192.);\n\tres += circle(p, 0.31, 192.);\n\tres += circle(p, 0.32, 192.);\n    return res;\n}\n\nfloat BoxLotus3(vec2 p)\n{\n    float res = 0.;\n    vec2 c;\n    vec2 f;\n    if (p.x < 0.25) {\n        c = vec2(0.25, PI / 5.);\n        f = mod(p, c) - 0.5 * c;\n        res += spiral(vec2(f.x, f.y), 192.);\n        res += spiral(vec2(0.9*f.x, f.y + 0.05), 192.);\n        res += spiral(vec2(0.8*f.x, f.y + 0.075), 192.);\n        res += spiral(vec2(0.7*f.x, f.y + 0.1), 192.);\n    }\n    if (p.x > 0.125 && p.x < 0.3) {\n        p.y += 1.01;\n        c = vec2(0.25, PI / 5.);\n        f = mod(p, c) - 0.5 * c;\n        f.x *= 1.25;\n        f.y *= 2.1;\n        res += fun(vec2(f.x, f.y*f.y), -0.4, 32.);\n        res += fun(vec2(f.x + 0.01, f.y*f.y + 0.05), -0.4, 32.);\n        res += fun(vec2(f.x + 0.01, f.y*f.y - 0.05), -0.4, 32.);\n        res += fun(vec2(f.x + 0.02, f.y*f.y + 0.075), -0.4, 32.);\n        res += fun(vec2(f.x + 0.02, f.y*f.y - 0.075), -0.4, 32.);\n    }\n\tres += circle(p, 0.30, 192.);\n\tres += circle(p, 0.31, 192.);\n    return res;\n}\n\nfloat BoxLotus4(vec2 p)\n{\n    float res = 0.;\n    vec2 c;\n    vec2 f;\n    if (p.x < 0.25) {\n        c = vec2(0.25, PI / 4.);\n        f = mod(p, c) - 0.5 * c;\n        res += rose(vec2(f.x, f.y), 0., 12.);\n        res += rose(vec2(f.x, f.y + 0.05), 0.1, 12.);\n        res += rose(vec2(f.x, f.y + 0.075), 0.2, 12.);\n        res += rose(vec2(f.x, f.y + 0.1), 0.3, 12.);\n    }\n\tres += circle(p, 0.26, 192.);\n\tres += circle(p, 0.27, 192.);\n\tres += circle(p, 0.28, 192.);\n    return res;\n}\n\nfloat BoxSideFB(vec2 c)\n{\n    vec2 cc = 1.5*c;\n    float res = BoxLotus1(CART2POLAR(cc.x, cc.y));\n    cc = 2.*c + vec2(1.1, 0.);\n    res += BoxLotus4(CART2POLAR(cc.x, cc.y));\n    cc = 2.*c + vec2(-1.1, 0.);\n    res += BoxLotus4(CART2POLAR(cc.x, cc.y));\n    return clamp(res, 0., 1.);\n}\n\nfloat BoxSideLR(vec2 c)\n{\n    vec2 cc = 1.5*c;\n    float res = BoxLotus1(CART2POLAR(cc.x, cc.y));\n    return clamp(res, 0., 1.);\n}\n\nfloat BoxCover(vec2 c)\n{\n    vec2 cc = 0.7*c;\n    float res = BoxLotus2(CART2POLAR(cc.x, cc.y));\n    cc = 1.66*c + vec2(1.15, 0.5);\n    res += BoxLotus3(CART2POLAR(cc.x, cc.y));\n    cc = 1.66*c + vec2(1.15, -0.5);\n    res += BoxLotus3(CART2POLAR(cc.x, cc.y));\n    cc = 1.66*c + vec2(-1.15, -0.5);\n    res += BoxLotus3(CART2POLAR(cc.x, cc.y));\n    cc = 1.66*c + vec2(-1.15, 0.5);\n    res += BoxLotus3(CART2POLAR(cc.x, cc.y));\n    return res;\n}\n\nfloat Table(vec2 c)\n{\n    float res = 0.;\n    vec2 p = CART2POLAR(c.x, c.y);\n    vec2 m;\n    vec2 f;\n\tp.x *= 1.01;\n\tres += circle(p, 0.125, 512.);\n    if (p.x > 0.125 && p.x < 0.25) {\n        m = vec2(0.25, PI / 10.);\n        f = mod(p, m) - 0.5 * m;\n        res += stripes(f, 0.125, 512.*p.x);\n    }\n\tres += circle(p, 0.25, 512.);\n    if (p.x > 0.125 && p.x < 0.5) {\n        m = vec2(0.25, PI / 5.);\n        f = mod(p, m) - 0.5 * m;\n        f.x *= 1.25;\n        f.y *= 2.;\n        res += fun(vec2(f.x, f.y*f.y), -0.4, 64.);\n        res += fun(vec2(f.x + 0.01, f.y*f.y + 0.05), -0.4, 64.);\n        res += fun(vec2(f.x + 0.01, f.y*f.y - 0.05), -0.4, 64.);\n        res += fun(vec2(f.x + 0.02, f.y*f.y + 0.075), -0.4, 64.);\n        res += fun(vec2(f.x + 0.02, f.y*f.y - 0.075), -0.4, 64.);\n    }\n    if (p.x > 0.25 && p.x < 0.5) {\n        vec2 pp = vec2(p.x*1.05, p.y);\n        m = vec2(0.25, PI / 10.);\n        f = mod(pp, m) - 0.5 * m;\n        f.x *= 3.4;\n        res += zebra(vec2(f.x, f.y), 96.);\n        res += zebra(vec2(f.x, f.y - 0.05), 96.);\n        res += zebra(vec2(f.x, f.y + 0.05), 96.);\n        res += zebra(vec2(f.x, f.y - 0.1), 96.);\n        res += zebra(vec2(f.x, f.y + 0.1), 96.);\n    }\n\tres += circle(p, 0.5, 128.);\n    return clamp(res, 0., 1.);\n}\n\n////////////////////////////////////////////////////////////////////////////\n// PRIMITIVES\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n////////////////////////////////////////////////////////////////////////////\n// OPERATORS\n\nvec2 opS( vec2 d1, vec2 d2 )\n{\n    return d1.x > -d2.x ? d1 : vec2(-d2.x, d2.y);\n}\n\nvec2 opI( vec2 d1, vec2 d2 )\n{\n     return d1.x > d2.x ? d1 : d2;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n    return d1.x < d2.x ? d1 : d2;\n}\n\n////////////////////////////////////////////////////////////////////////////\n// MODELS\n\nvec2 box(in vec3 pos)\n{\n    // cover\n    vec2 dc = vec2(FAR, 0.);\n    vec3 cpos = pos;\n    cpos.y -= 1.475;\n    cpos.z += 0.55;\n    cpos = rotateYZ(cpos, -DEG2RAD*60.);\n    dc = opU( dc, vec2( udRoundBox(cpos, vec3(1.5,0.1,1.0), 0.05), 4.));\n    dc = opI( dc, vec2( sdBox(cpos - vec3(0.,0.075,0.), vec3(1.6,0.1,1.1)), 1.));\n    dc = opS( dc, vec2( sdBox(cpos, vec3(1.475,0.1,.95)), 1.));\n\n    // base\n    vec2 db = vec2(FAR, 0.);\n    vec3 bpos = pos;\n    db = opU( db, vec2( udRoundBox(bpos, vec3(1.5,0.55,1.0), 0.05), 3.));\n    db = opI( db, vec2( sdBox(bpos + vec3(0.,0.05,0.), vec3(1.6,0.6,1.1)), 1.));\n    db = opU( db, vec2( sdBox(bpos - vec3(0.,0.1,0.), vec3(1.47,0.5,.95)), 1.));\n    db = opS( db, vec2( sdBox(bpos - vec3(0.,0.12,0.), vec3(1.45,0.6,.92)), 1.));\n\t\n    // joint\n    vec2 dj = vec2(FAR, 0.);\n    vec3 jpos = pos;\n    jpos.y -= 0.555;\n    jpos.z += 1.045;\n    jpos = rotateXY(jpos, -DEG2RAD*90.);\n    dj = opU(dj, vec2( sdCylinder( jpos, vec2(0.015,1.525)), 2.));\n    \n    return opU(dc, opU(db, dj));\n}\n\nvec2 lamp(in vec3 pos)\n{\n    vec2 d = vec2(FAR, 0.);\n    vec3 cpos = pos;\n    cpos = rotateXZ(cpos, DEG2RAD*45.);\n    float sd = sdCapsule(pos, vec3(0.,0.,0.), vec3(0.,1.,0.), 0.6);\n    d = opU(d, vec2( sd \n                    - 0.075*abs(sin(2.*PI*pos.x*pos.z))\n                    - 0.075*abs(sin(2.*PI*cpos.x*cpos.z)), 120.));\n    d = opU(d, vec2( sdCylinder( pos - vec3(0.,0.5,0.), vec2(0.45,1.1)), 121.));\n    d = opS(d, vec2( sdCylinder( pos - vec3(0.,0.5,0.), vec2(0.425,1.15)), 121.));\n    return d;\n}\n\nvec2 ground(in vec3 pos)\n{\n    vec2 d = vec2(FAR, 0.);\n\td = opU(d, vec2(sdCylinder(pos, vec2(5.5, 0.1)), 50.));\n    return d;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(FAR, 0.);\n \tvec3 cpos;\n    // Box\n    cpos = pos;\n    cpos.y -= 0.05;\n    cpos = rotateXZ(cpos, -DEG2RAD*90.);\n    res = opU(res, box(cpos));\n    \n    // Lamps\n    cpos = pos - LIGHTPOS0;\n    cpos.y += 0.5;\n    res = opU(res, lamp(cpos));\n    cpos = pos - LIGHTPOS1;\n    cpos.y += 0.5;\n    res = opU(res, lamp(cpos));\n    cpos = pos - LIGHTPOS2;\n    cpos.y += 0.5;\n    res = opU(res, lamp(cpos));\n\n    // Ground\n    cpos = pos + vec3(0., 0.68, 0.);\n    res = opU(res, ground(cpos));\n    \n    return res;\n}\n\n////////////////////////////////////////////////////////////////////////////\n// RENDER\n\nvec3 gray(vec3 c)\n{\n    return 0.333 * vec3(c.x+c.y+c.z);\n}\n\nfloat texBoxSides(vec3 pos, vec3 nor)\n{\n    if (abs(nor.x) > 0.) {\n        return BoxSideFB(0.5*pos.zy + vec2(0.,-0.02));\n    } else {\n        return BoxSideLR(0.5*pos.xy - vec2(0.,0.02));\n    }\n    return 0.;\n}\n\nfloat texBoxCover(vec3 pos, vec3 nor)\n{\n    if (nor.x < 0.) {\n        vec2 blending = abs( nor.xy );\n        blending = normalize(max(blending, 0.00001));\n        float b = (blending.x + blending.y);\n        blending /= vec2(b, b);\n        vec3 ppos = 0.6*pos + vec3(0.,-0.97,0.);\n        float xaxis = BoxCover( ppos.zy );\n        float yaxis = BoxCover( ppos.zx );\n        return xaxis * blending.x + xaxis * blending.y;\n    }\n    return 0.;\n}\n\nvec3 triPlanarTex(sampler2D sam, vec3 pos, vec3 nor)\n{\n    vec3 blending = abs( nor );\n    blending = normalize(max(blending, 0.00001));\n    float b = (blending.x + blending.y + blending.z);\n    blending /= vec3(b, b, b);\n    vec3 xaxis = texture( sam, pos.yz).xyz;\n    vec3 yaxis = texture( sam, pos.xz).xyz;\n    vec3 zaxis = texture( sam, pos.xy).xyz;\n    // blend the results of the 3 planar projections.\n    return xaxis * blending.x + xaxis * blending.y + zaxis * blending.z;\n}\n\nvec4 colorize(in vec3 pos, in vec3 nor, in float id)\n{\n    vec3 col;\n    float shader = SHADE_NONE;\n    if (id < 1.1) { \t\t// Box Inside\n        col = BOXCOLOR;\n        shader = SHADE_GLOSSY_BOX;\n    } else if (id < 2.1) { \t// Box Joint\n        col = vec3(0.95, 0.9, 0.1);\n        shader = SHADE_GLOSSY_BOX;\n    } else if (id < 3.1) {\t// Box Sides Decoration\n        col = BOXCOLOR * (1. - texBoxSides(pos, nor));\n        shader = SHADE_GLOSSY_BOX;\n    } else if (id < 4.1) {\t// Box Decoration\n        col = BOXCOLOR * (1. - texBoxCover(pos, nor));\n        shader = SHADE_GLOSSY_BOX;\n    } else if (id < 50.1) {\t// Floor\n        col = (1.-Table(0.0905*pos.xz)) * vec3(0.5) * texture(iChannel0, 0.1*pos.xz).rgb;\n        shader = SHADE_GLOSSY_FLOOR;\n    } else if (id < 120.1) {// Lamp paper\n        col = vec3(0.8, 0.4, 0.) - 0.5 * gray(triPlanarTex(iChannel1, pos, nor));\n        shader = SHADE_MAT;\n    } else if (id < 121.1) {// Lamp inside\n        if (pos.y > 3.575 && pos.y < 5.) {\n            col = vec3(1.);\n            shader = SHADE_MAT;\n        } else {\n            col = vec3(0.);\n            shader = SHADE_GLOSSY_BOX;\n        }\n    }\n    return vec4(col, shader);\n}\n\nvec4 castRay( in vec3 ro, in vec3 rd )\n{\n\tconst float tmin = 0.01;\n    const float tmax = 15.0;    \n\tconst float precis = 0.001;\n    float t = tmin;\n    float id = -1.0;\n    vec3 pos;\n    for( int i=0; i<60; i++ )\n    {\n        pos = ro+rd*t;\n\t    vec2 res = map( pos );\n        if( abs(res.x)<precis || t>tmax ) break;\n        t += res.x;\n\t    id = res.y;\n    }\n\n    if( t>tmax ) id=-1.0;\n    return vec4( pos, id );\n}\n\nfloat minDist( in vec3 ro, in vec3 rd, in vec3 refPos )\n{\n\tconst float tmin = 0.1;\n    const float tmax = 30.0;\n    float t = tmin;\n    float min = FAR;\n    float lastmin = FAR;\n    vec3 pos;\n    for( int i=0; i<20; i++ )\n    {\n        pos = ro+rd*t;\n        float d = distance(pos, refPos);\n        if( min > lastmin || t>tmax ) break;\n        t += d;\n        lastmin = min;\n        min = d;\n    }\n    return lastmin;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec2 eps = vec2( 0.001, 0.0 );\n    vec2 vx0 = map(pos+eps.xyy);\n    vec2 vx1 = map(pos-eps.xyy);\n    vec2 vy0 = map(pos+eps.yxy);\n    vec2 vy1 = map(pos-eps.yxy);\n    vec2 vz0 = map(pos+eps.yyx);\n    vec2 vz1 = map(pos-eps.yyx);\n    \n\tvec3 nor = vec3(\n\t    vx0.y == vx1.y ? vx0.x - vx1.x : 0.,\n\t    vy0.y == vy1.y ? vy0.x - vy1.x : 0.,\n\t    vz0.y == vz1.y ? vz0.x - vx1.x : 0.);\n\n    return normalize(nor);\n}\n\nvec3 shade(vec3 pos, vec3 nor, vec3 col, vec3 lightPos, vec3 lightColor)\n{\n\tfloat dist = distance(lightPos, vec3(pos));\n\tfloat att = 1.;//exp(-0.325*dist);\n    float cosine = dot(nor, normalize(lightPos-pos));\n    float ambient = clamp( 0.01+0.005*nor.y, 0.0, 1.0 );\n    float diffuse = 0.;\n    float specular = 0.;\n    if (cosine > 0.){\n        diffuse = att*cosine;\n    }\t\n    specular = att*pow(abs(cosine), 10.);\n\treturn col*ambient+col*diffuse*lightColor+col*specular*lightColor;\n}\n\nstruct Material {\n\tvec3  color;\t\t// diffuse color\n\tfloat n;\t\t\t// refraction index\n\tfloat roughness;\t// Cook-Torrance roughness\n\tfloat fresnel;\t\t// Cook-Torrance fresnel reflectance\n\tfloat density;\t\t// Cook-Torrance color density i.e. fraction of diffuse reflection\n};\n\nstruct Light {\n\tvec3 pos;\n\tvec3 color;\n};\n\n/// References:\n/// http://content.gpwiki.org/index.php/D3DBook:%28Lighting%29_Cook-Torrance\n/// http://ruh.li/GraphicsCookTorrance.html\nvec3 shadeCookTorrance( vec3 pos, vec3 nor, vec3 vd, Material mat, Light lig )\n{\n\tfloat roughness = mat.roughness;\n\tfloat F0 = mat.fresnel;\n\tfloat K = mat.density;\n\t//\n\tvec3 ld = normalize(lig.pos-pos);\n\tvec3 h = normalize(vd+ld);\n\tfloat NdotL = clamp( dot( nor, ld ),0.,1. );\n\tfloat NdotH = clamp( dot( nor, h ),0.,1. );\n\tfloat NdotV = clamp( dot( nor, vd ),0.,1. );\n\tfloat VdotH = clamp( dot( h, vd ),0.,1. );\n\tfloat rsq = roughness * roughness;\n\t\n\t// Geometric Attenuation\n\tfloat NH2   = 2. * NdotH / VdotH;\n\tfloat geo_b = (NH2 * NdotV );\n\tfloat geo_c = (NH2 * NdotL );\n\tfloat geo   = min( 1., min( geo_b, geo_c ) );\n\t\n\t// Roughness\n\t// Beckmann distribution function\n\tfloat r1 = 1. / ( 4. * rsq * pow(NdotH, 4.));\n\tfloat r2 = (NdotH * NdotH - 1.) / (rsq * NdotH * NdotH);\n\tfloat rough = r1 * exp(r2);\n\t\n\t// Fresnel\t\t\t\n\tfloat fres = pow( 1.0 - VdotH, 5. );\n\tfres *= ( 1.0 - F0 );\n\tfres += F0;\n\t\n\tvec3 spec = (NdotV * NdotL==0.) ? vec3(0.) : vec3 ( fres * geo * rough ) / ( NdotV * NdotL );\n\tvec3 res = NdotL * ( (1.-K)*spec + K*mat.color ) * lig.color;// * exp(-0.001*length(lig.pos-i.p));\n\treturn clamp(res, 0., 1.);\n}\n\nfloat occlusion( in vec3 pos, in Light lig )\n{\n    vec3 rd = normalize(lig.pos - pos);\n    vec4 res = castRay(pos+0.01*rd,rd);\n    return (res.w > 0.) && (res.w < 100.) ? 0. : 1.;\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    const vec3 lightColor = vec3(0.6, 0.2, 0.05);\n    Light lig0;\n    lig0.color = lightColor;\n    lig0.pos = LIGHTPOS0; //vec3(4., 4.5, 4.);\n    Light lig1;\n    lig1.color = lightColor;\n    lig1.pos = LIGHTPOS1; //vec3(-4., 4.5, 4.);\n    Light lig2;\n    lig2.color = lightColor;\n    lig2.pos = LIGHTPOS2; //vec3(-4., 4.5, -4.);\n    Light lig3;\n    lig3.color = lightColor;\n    lig3.pos = vec3(4., 4.5, -4.);\n    //\n    vec3 col = mix(vec3(0.01),vec3(0.025, 0.05, 0.1),abs(4.*rd.y));\n    vec4 res = castRay(ro,rd);\n    vec3 pos = res.xyz;\n\tfloat id = res.w;\n    if( id > 0. )\n    {\n        vec3 nor = calcNormal( pos );\n        vec4 material = colorize(pos, nor, id);\n        vec3 objCol = material.xyz;\n        float shader = material.w;\n        \n        col = vec3(0.);\n        \n       float occ0 = occlusion(pos, lig0);\n       float occ1 = occlusion(pos, lig1);\n       float occ2 = occlusion(pos, lig2);\n\n\t\t if (shader == SHADE_MAT) {\n            Material mat;\n            mat.color = objCol;\n            mat.n = 1.;\n            mat.fresnel = 0.95;\n            mat.roughness = 0.95;\n            mat.density = 0.9;\n            col += occ0 * shadeCookTorrance(pos, nor, -rd, mat, lig0);\n            col += occ1 * shadeCookTorrance(pos, nor, -rd, mat, lig1);\n            col += occ2 * shadeCookTorrance(pos, nor, -rd, mat, lig2);\n   \t\t} else if (shader == SHADE_GLOSSY_BOX) {\n            Material mat;\n            mat.color = objCol;\n            mat.n = 1.;\n            mat.fresnel = 0.95;\n            mat.roughness = 0.05;\n            mat.density = 0.95;\n            col += occ0 * shadeCookTorrance(pos, nor, -rd, mat, lig0);\n            col += occ1 * shadeCookTorrance(pos, nor, -rd, mat, lig1);\n            col += occ2 * shadeCookTorrance(pos, nor, -rd, mat, lig2);\n         \tcol += 0.2*lig0.color*clamp( dot( nor, normalize(vec3(-lig0.pos.x,0.0,-lig0.pos.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n         \tcol += 0.2*lig1.color*clamp( dot( nor, normalize(vec3(-lig1.pos.x,0.0,-lig1.pos.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n         \tcol += 0.2*lig2.color*clamp( dot( nor, normalize(vec3(-lig2.pos.x,0.0,-lig2.pos.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        } else if (shader == SHADE_GLOSSY_FLOOR) {\n            Material mat;\n            mat.color = objCol;\n            mat.n = 1.;\n            mat.fresnel = 0.95;\n            mat.roughness = 0.05;\n            mat.density = 0.95;\n            float pe = Table(0.0905*pos.xz) - Table(0.0905*(pos.xz+vec2(0.01,0.01)));\n            nor.xz -= 0.15*vec2(1.,1.)*pe;\n            nor = normalize(nor);\n            col += occ0 * shadeCookTorrance(pos, nor, -rd, mat, lig0);\n            col += occ1 * shadeCookTorrance(pos, nor, -rd, mat, lig1);\n            col += occ2 * shadeCookTorrance(pos, nor, -rd, mat, lig2);\n        }\n        col = clamp( col, 0., 1.);\n\t\tfloat amb = 0.1 * clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        col += 0.33*(occ0+occ1+occ2) * amb * objCol;\t\t\n    }\n    if ((id < 1.) || (id > 5.))\n    {\n        float d = min( distance(ro, LIGHTPOS0) > 4. ? minDist(ro, rd, LIGHTPOS0) : FAR,\n                      min( distance(ro, LIGHTPOS1) > 4. ? minDist(ro, rd, LIGHTPOS1) : FAR,\n                           distance(ro, LIGHTPOS2) > 4. ? minDist(ro, rd, LIGHTPOS2) : FAR));\n        if (d < 6.)\n        {\n            col += vec3(0.6, 0.4, 0.1) * exp(-0.75*d);\n        }\n    }\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    //\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 0.05*iTime;\n\n\t// camera\n    float a = sin(PI*time);\n    float b = cos(0.66*PI*time);\n    float d = 3.25 + b;\n    float h = 0.05;\n\tvec3 ro = vec3(d, h, d);\n    mat4 rot = rotationXYZ(0.5*PI*(a*a + mo.y), -2.*PI*time - 0.25*PI - 2.*PI*mo.x, 0.);\n    vec4 ro4 = rot * vec4(ro, 1.);\n    ro = ro4.xyz;\n\tvec3 ta = vec3( 0., 0.5, 0. );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = normalize(ca * normalize( vec3(p.xy,2.0) ));\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n    // gamma correction\n    col = pow( col, vec3(0.8) );\n\n    fragColor=vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}