{
    "Shader": {
        "info": {
            "date": "1549814952",
            "description": "raymarching a procedural ocean",
            "flags": 0,
            "hasliked": 0,
            "id": "3dS3WG",
            "likes": 5,
            "name": "simple 3d procedural ocean",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "raymarch",
                "ocean"
            ],
            "usePreview": 0,
            "username": "public_int_i",
            "viewed": 560
        },
        "renderpass": [
            {
                "code": "//Ethan Alexander Shulman 2019, made on livestream at twitch.tv/ethanshulman\n\n#define time iTime\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define lightDir normalize(vec3(.4,1,.2))\n#define light vec3(1,.9,.8)\n\n#define EPSILON 2e-2\n#define NORMAL_EPSILON 4e-2\n#define MIN_STEP 2e-2\n#define ITER 100\n\nvec4 hash(vec4 a) {\n\treturn fract(abs(sin(a.ywxz*766.345)+cos(normalize(a)*4972.92855))*2048.97435+abs(a.wxyz)*.2735);\n}\n\nvec4 background(vec3 rd) {\n    vec2 pc = rd.xz*(.5/(1.+abs(rd.y)));\n\t\n\tvec2 dp = pc*10.+cos((pc.yx-.5)*vec2(16,3)),\n        fp = floor(dp*.5),\n        rp = mod(dp,2.)-1.;\n\tfloat c = max(0.,(.9+.1*hash(fp.xyyx).x)-length(rp)*.8),\n\tm = 0.;\n\tfor (int i = 0; i < 3; i++) {\n\t\tm += max(0.,length(mod(abs(\n\t\tpc*(10.+float(i)*10.)+\n\t\tcos(float(i+2)/(1.+c*float(1+i))+abs(pc.yx-.5)*float(i*2+3)+float(i)*vec2(1.4,.6))*float(1+i*2)),\n\t\t2.)-1.));\n\t}\n\tc *= pow(m*.2,1./4.);\n\tc = pow(c,2.);\n\t\n\treturn mix(vec4(.1,.5,.9,1)+vec4(light,1)*4.*pow(max(0.,1.-length(rd-lightDir)),2.),vec4(1),c);\n}\n\nfloat twave(float v) {\n\tv = fract(abs(v));\n\treturn v*2.-max(0.,v*4.-2.);\n}\nfloat water(vec2 p) {\n\tfloat s = 0.;\n\tfor (int i = 2; i < 6; i++) {\n\t\tfloat fi = float(i);\n\t\ts += pow(twave((p*rot(fi*3.8263)).x/fi+fi*.673+time*.6/fi),1.5+fract(fi*2.864)*2.)*fi*.1;\n\t}\n\treturn s;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 rd = normalize(vec3((fragCoord*2.-iResolution.xy)/iResolution.x,1)),\n\t\trp = vec3(0,3.+sin(time*.22)*1.5,0),\n\t\torp = rp;\n\trd.xz *= rot(time*.1);\n\t\n\tint i;\n\tfor (i = 0; i < ITER; i++) {\n\t\tfloat yd = rp.y-water(rp.xz);\n\t\tif (yd < EPSILON) break;\n\t\trp += rd*max(MIN_STEP,yd);\n\t}\n\t\n\tvec4 bg = background(rd);\n\tif (i >= ITER) {\n\t\tfragColor = bg;\n\t} else {\n\t\trp -= rd*MIN_STEP*2.;\n\t\trp += rd*(rp.y-water(rp.xz));\n\t\tfloat bd = water(rp.xz);\n\t\tvec3 nrm = normalize(vec3(water(rp.xz+vec2(NORMAL_EPSILON,0))-bd,NORMAL_EPSILON,water(rp.xz+vec2(0,NORMAL_EPSILON))-bd)),\n\t\t\tdcol = vec3(.04,.15,.4),\n\t\t\tscol = vec3(.22,.5,.6)*pow((1.-max(0.,dot(rd,nrm))),2.);\n\t\tfloat dl = (.5+.5*dot(nrm,lightDir))*(.3+.7*pow(max(0.,dot(rd,nrm)),4.));\n\t\tfragColor = mix(vec4(dcol*light*dl+scol*background(reflect(rd,nrm)).xyz,1),\n\t\t\t\t\t\t\tbg,\n\t\t\t\t\t\t\tclamp(length(rp-orp)/50.-0.3,0.,1.));\n\t}\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}