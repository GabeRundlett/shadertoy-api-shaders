{
    "Shader": {
        "info": {
            "date": "1520822069",
            "description": "It's a clover.\n\nPlaying around with distance functions.\nhttps://www.shadertoy.com/view/XllGW4",
            "flags": 0,
            "hasliked": 0,
            "id": "XsKyRR",
            "likes": 5,
            "name": "Glass Clover",
            "published": 3,
            "tags": [
                "clover"
            ],
            "usePreview": 0,
            "username": "tachyonflux",
            "viewed": 869
        },
        "renderpass": [
            {
                "code": "#define AUTO_ROTATE     // uncomment to stop auto camera rotation\n//#define BACKGROUND_BLUE // uncomment for blue background, else cubemap background\n//#define VIEW_ZERO       // uncomment to default OpenGL look down z-axis view\n//#define VIEW_ISOMETRIC  // Nice isometric camera angle\n\n//#define LOW_Q // uncomment for low quality if your GPU is a potato\n\n#ifdef LOW_Q\n    #define MARCHSTEPS 25\n#else\n    #define MARCHSTEPS 50\n    #define AMBIENT_OCCLUSION\n    #define DOUBLE_SIDED_TRANSPARENCY\n#endif\n\n#define MAX_DIST 10.0\n\n#define SPECULAR\n//#define REFLECTIONS\n#define TRANSPARENCY\n#define SHADOWS\n#define FOG\n\n//#define DIRECTIONAL_LIGHT\n//#define DIRECTIONAL_LIGHT_FLARE\n\n#define PI 3.141592654\n\n#define kNt  -1.0 //no trans\n#define kTt   1.0 //yes trans\n#define kIt   0.0 //inverse trans\n\nconst float MATERIAL_1 = 1.0;\nconst float MATERIAL_2 = 2.0;\n/* */ float gMaterial  = MATERIAL_1;\n\n// TODO: Document these structure member fields!\n// rd Ray Direction\n// rl Ray Length\nstruct sRay   { vec3 ro ; vec3  rd ; float sd; float rl; };\nstruct sHit   { vec3 hp ; float hd ; vec3 oid; };\nstruct sSurf  { vec3 nor; vec3  ref; vec3 tra; };\nstruct sMat   { vec3 ctc; float frs; float smt; vec2 par; float trs; float fri; };\nstruct sShade { vec3 dfs; vec3  spc; };\nstruct sLight { vec3 rd ; vec3  col; };\n\n// __ Matrix functions __ _____________________________________\n\n    // Return 2x2 rotation matrix\n    // With vector swizzle/mask can use as a 3x3 xform\n    // For y, you need to invert \n    // angle in radians\n    // ========================================\n    mat2 Rot2(float a ) {\n        float c = cos( a );\n        float s = sin( a );\n        return mat2( c, -s, s, c );\n    }\n\n    // http://www.songho.ca/opengl/gl_anglestoaxes.html\n\n    // Return 4x4 rotation X matrix\n    // angle in radians\n    // ========================================\n    mat4 Rot4X(float a ) {\n        float c = cos( a );\n        float s = sin( a );\n        return mat4( 1, 0, 0, 0,\n                     0, c,-s, 0,\n                     0, s, c, 0,\n                     0, 0, 0, 1 );\n    }\n\n    // Return 4x4 rotation Y matrix\n    // angle in radians\n    // ========================================\n    mat4 Rot4Y(float a ) {\n        float c = cos( a );\n        float s = sin( a );\n        return mat4( c, 0, s, 0,\n                     0, 1, 0, 0,\n                    -s, 0, c, 0,\n                     0, 0, 0, 1 );\n    }\n\n    // Return 4x4 rotation Z matrix\n    // angle in radians\n    // ========================================\n    mat4 Rot4Z(float a ) {\n        float c = cos( a );\n        float s = sin( a );\n        return mat4(\n            c,-s, 0, 0,\n            s, c, 0, 0,\n            0, 0, 1, 0,\n            0, 0, 0, 1\n         );\n    }\n\n    // Translate is simply: p - d\n    // opTx will do transpose(m)\n    // p' = m*p\n    //    = [m0 m1 m2 m3 ][ p.x ]\n    //      [m4 m5 m6 m7 ][ p.y ]\n    //      [m8 m9 mA mB ][ p.z ]\n    //      [mC mD mE mF ][ 1.0 ]\n    // ========================================\n    mat4 Loc4( vec3 p ) {\n        p *= -1.;\n        return mat4(\n            1,  0,  0,  p.x,\n            0,  1,  0,  p.y,\n            0,  0,  1,  p.z,\n            0,  0,  0,  1\n        );\n    }\n\n\n    // if no support for GLSL 1.2+\n    //     #version 120\n    // ========================================\n    mat4 transposeM4(in mat4 m ) {\n        vec4 r0 = m[0];\n        vec4 r1 = m[1];\n        vec4 r2 = m[2];\n        vec4 r3 = m[3];\n\n        mat4 t = mat4(\n             vec4( r0.x, r1.x, r2.x, r3.x ),\n             vec4( r0.y, r1.y, r2.y, r3.y ),\n             vec4( r0.z, r1.z, r2.z, r3.z ),\n             vec4( r0.w, r1.w, r2.w, r3.w )\n        );\n        return t;\n    }\n\n\n// __ Smoothing functions _____________________________________\n\n    // Smooth Min\n    // https://iquilezles.org/articles/smin\n\n    // Min Polynomial\n    // ========================================\n    float sMinP( float a, float b, float k ) {\n        float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n        return mix( b, a, h ) - k*h*(1.0-h);\n    }\n\n    // Min Exponential\n    // ========================================\n    float sMinE( float a, float b, float k) {\n        float res = exp( -k*a ) + exp( -k*b );\n        return -log( res )/k;\n    }\n\n    // Min Power\n    // ========================================\n    float sMin( float a, float b, float k ) {\n        a = pow( a, k );\n        b = pow( b, k );\n        return pow( (a*b) / (a+b), 1.0/k );\n    }\n\n// __ Surface Primitives ____________________________\n\n    // Return max component x, y, or z\n    // ========================================\n    float maxcomp(in vec3 p ) {\n        return max(p.x,max(p.y,p.z));\n    }\n\n// Signed\n\n    // b.x = Width\n    // b.y = Height\n    // b.z = Depth\n    // Leave r=0 if radius not needed\n    // ========================================\n    float sdBox(vec3 p, vec3 b, float r) {\n        vec3 d = abs(p) - b;\n        return min(maxcomp(d),0.0) - r + length(max(d,0.0));\n        // Inlined maxcomp\n        //return min(max(d.x,max(d.y,d.z)),0.0) - r + length(max(d,0.0));\n    }\n\n    // ========================================\n    float sdCappedCylinder( vec3 p, vec2 h ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n\n    // ========================================\n    float sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n        vec3 pa = p - a, ba = b - a;\n        float h = clamp( dot(pa,ba) / dot(ba,ba), 0.0, 1.0 );\n        return length( pa - ba*h ) - r;\n    }\n\n    // c.x Width\n    // c.y Base Radius\n    // c.z Depth\n    // Note: c must be normalized\n    // ========================================\n    float sdCone( vec3 p, vec3 c) // TODO: do we need to use 'in' for all primitives?\n    {\n        // c.x = length\n        // c.y = base radius\n        //float q = length( p.xy );\n        //return dot( c, vec2( q, p.z ) ); // BUG in iq's docs -- laying on side\n\n        float q = length( p.xz );\n        return dot( c.xy, vec2( q, p.y ) );\n\n        // Alt. cone formula given in: ???\n        //vec2 q = vec2( length( p.xz ), p.y );\n        //float d1 = -p.y - c.z;\n        //float d2 = max( dot(q,c.xy), p.y );\n        //return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.0);\n    }\n\n    // ========================================\n    float sdCylinder( vec3 p, vec3 c ) {\n        return length(p.xz - c.xy) - c.z;\n    }\n\n    // n.xyz = point on plane\n    // n.w   = distance to plane\n    // Note: N must be normalized!\n    // ========================================\n    float sdPlane( vec3 p, vec4 n ) {\n        return dot( p, n.xyz ) + n.w;\n    }\n\n    // 4 sided pyramid\n    // h.x = base X\n    // h.y = height\n    // h.z = base Z (usually same as h.x)\n    // ========================================\n    float sdPyramid4( vec3 p, vec3 h ) {\n        p.xz = abs(p.xz);                   // Symmetrical about XY and ZY\n        vec3 n = normalize(h);\n        return sdPlane(p, vec4( n, 0.0 ) ); // cut off bottom\n    }\n\n    // ========================================\n    float sdSphere( vec3 p, float r ) {\n        return length(p) - r;\n    }\n\n    // ========================================\n    float sdSphere2( vec3 p, float r ) {\n        return abs(length(p) - r);\n    }\n\n    // ========================================\n    float sdTorus( vec3 p, vec2 t ) {\n        vec2 q = vec2(length(p.xy) - t.x, p.z);\n        return length(q) - t.y;\n    }\n\n    // TODO: document/derive magic number 0.866025\n    // ========================================\n    float sdTriPrism( vec3 p, vec2 h ) {\n        vec3 q = abs(p);\n        return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n    }\n\n// Unsigned\n\n    // Box\n    // ========================================\n    float udBox( vec3 p, vec3 b ) {\n        return length( max( abs(p) - b, 0.0 ) );\n    }\n\n    // Round Box\n    // ========================================\n    float udRoundBox(vec3 p, vec3 b, float r)\n    {\n        return length(max(abs(p) - b, 0.0))- r;\n    }\n\n// __ Distance Operations _____________________________________\n\n// Basic\n    // Op Union\n    // ========================================\n    float opU( float d1, float d2 ) {\n        return min( d1, d2 );\n    }\n\n    // Op Union\n    // ========================================\n    vec4 opU2( vec4 d1, vec4 d2 ) {\n        return min( d1, d2 );\n    }\n\n    // Op Union\n    // ========================================\n    vec4 opU( vec4 a, vec4 b ) {\n        return mix(a, b, step(b.x, a.x));\n    }\n\n    // Op Subtraction\n    // ========================================\n    float opS( float a, float b ) {\n        return max( -b, a ); // BUG in iq's docs: -a, b\n    }\n    // Op Subtraction\n    // ========================================\n    vec4 opS( vec4 a, vec4 b ) {\n        return max( -b, a );\n    }\n\n    // Op Intersection\n    // ========================================\n    float opI( float a, float b ) {\n        return max( a, b );\n    }\n\n    // Op Intersection\n    // ========================================\n    vec4 opI( vec4 a, vec4 b ) {\n        return max( a, b );\n    }\n\n// Advanced\n    // ========================================\n    float opBlend( float a, float b, float k ) {\n        return sMin( a, b, k );\n    }\n\n    // a angle\n    // ========================================\n    float displacement( vec3 p, float a ) {\n        return sin(a*p.x)*sin(a*p.y)*sin(a*p.z); // NOTE: Replace with your own!\n    }\n\n    // ========================================\n    float opDisplace( vec3 p, float d1, float d2 ) {\n        return d1 + d2;\n    }\n\n    // Op Union Translated\n    // ========================================\n    vec4 opUt( vec4 a, vec4 b, float fts ){\n        vec4 vScaled = vec4(b.x * (fts * 2.0 - 1.0), b.yzw);\n        return mix(a, vScaled, step(vScaled.x, a.x) * step(0.0, fts));\n    }\n\n\n// __ Domain Operations _______________________________________\n\n// NOTE: iq originally inlined the primitive inside the Domain operations. :-(\n// This implied that you would have needed to provide \n// a primitive with one of the sd*() functions above\n// since we can't have a generic pointer to a function!\n// However we have moved them back out to the caller\n// for clarity and flexibility without general loss of precision.\n\n// Basic\n\n    // Op Repetition\n    // ========================================\n    vec3 opRep( vec3 p, vec3 spacing ) {\n        return mod(p,spacing) - 0.5*spacing;\n    }\n\n// Deformations\n\n    // Op Twist X\n    // ========================================\n    vec3 opTwistX( vec3 p, float angle ) {\n        mat2 m = Rot2( angle * p.x );\n        return   vec3( m*p.yz, p.x );\n    }\n\n    // Op Twist Y\n    // ========================================\n    vec3 opTwistY( vec3 p, float angle ) {\n#if 0 // original\n        float c = cos( angle * p.y );\n        float s = sin( angle * p.y );\n        mat2  m = mat2( c, -s, s, c );\n        vec3  q = vec3( m*p.xz, p.y );\n        // return primitive(q); // BUG in iq's docs, should be: return q\n        return q;\n#else // cleaned up\n        mat2 m = Rot2( angle * p.y );\n        return   vec3( m*p.xz, p.y );\n#endif\n    }\n\n    // Op Twist Z\n    // ========================================\n    vec3 opTwistZ( vec3 p, float angle ) {\n        mat2 m = Rot2( angle * p.z );\n        return   vec3( m*p.xy, p.z );\n    }\n\n    // iq's bend X\n    // ========================================\n    vec3 opCheapBend( vec3 p, float angle ) {\n#if 0 // original // broken :-(\n        float c = cos( angle * p.y );\n        float s = sin( angle * p.y );\n        mat2  m = mat2( c, -s, s, c );\n        vec3  q = vec3( m*p.xy, p.z ); // BUG in iq's docs, should be: p.yx\n#else\n        mat2  m = Rot2( angle * p.y );\n        vec3  q = vec3( m*p.yx, p.z );\n#endif\n        return q;\n    }\n\n    // Op Cheap Bend X\n    // ========================================\n    vec3 opBendX( vec3 p, float angle ) {\n        mat2 m = Rot2( angle * p.y );\n        return   vec3( m*p.yx, p.z );\n    }\n\n    // Op Cheap Bend Y\n    // ========================================\n    vec3 opBendY( vec3 p, float angle ) {\n        mat2 m = Rot2( angle * p.z );\n        return   vec3( m*p.zy, p.x );\n    }\n\n    // Op Cheap Bend Z\n    // ========================================\n    vec3 opBendZ( vec3 p, float angle ) {\n        mat2 m = Rot2( angle * p.x );\n        return   vec3( m*p.xz, p.y );\n    }\n\n    // d = distance to move\n    // ========================================\n    vec3 opTrans( vec3 p, vec3 d ) {\n        return p - d;\n    }\n\n    // Note: m must already be inverted!\n    // TODO: invert(m) transpose(m)\n    // Op Rotation / Translation\n    // ========================================\n    vec3 opTx( vec3 p, mat4 m ) {   // BUG in iq's docs, should be q\n        return (transposeM4(m)*vec4(p,1.0)).xyz;\n    }\n\n    // Op Scale\n    // ========================================\n    float opScale( vec3 p, float s ) {\n        return sdBox( p/s, vec3(1.2,0.2,1.0), 0.01 ) * s; // TODO: FIXME: NOTE: replace with primative sd*()\n    }\n\n// The fun starts here!\n// ========================================\nfloat draw( vec3 p )\n{\n    vec3  q = p  ; // save original point\n    float d = 0.0; // distance function; default to no intersection\n\n    #define BOX_W  5.00\n    #define BOX_H  5.00\n    #define BOX_D  0.10\n    #define RADIUS 0.53\n    \n    p = q;\n    p.x -= 0.5;\n    p.y -= 0.5;\n    float d1 = sdSphere( p, RADIUS );\n    \n    p = q;\n    p.x += 0.5;\n    p.y -= 0.5;\n    float d2 = sdSphere( p, RADIUS );\n    \n    p = q;\n    p.x -= 0.5;\n    p.y += 0.5;\n    float d3 = sdSphere( p, RADIUS );\n    \n    p = q;\n    p.x += 0.5;\n    p.y += 0.5;\n    float d4 = sdSphere( p, RADIUS );\n    \n    p = q;\n    float d5 = sdSphere( p, RADIUS );\n    \n    p = q;\n    p.y += 1.00;\n    float c = cos(p.y);\n    float s = sin(p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  r = vec3(m*p.xy,p.z);\n    float d6 = sdBox( r, vec3(0.1,0.5,0.08), 0.0 );;\n    \n    float d7 = sdBox( p, vec3(BOX_W,BOX_H,BOX_D), 0.0 );\n    \n    d = opU( d1, d2 );\n    d = opU( d, d3 );\n    d = opU( d, d4 );\n    d = opU( d, d5 );\n    d = opU( d, d6 );\n    d = opI( d, d7 );\n    \n    return d;\n}\n\n// ========================================\nvec4 DE( vec3 hp, float fts ) {\n    vec4 vResult = vec4(MAX_DIST, -1.0, 0.0, 0.0);\n    vec4 vDist = vec4( draw(hp), MATERIAL_1, hp.xz);\n    vDist.y = gMaterial; // v0.42 draw may over-ride material\n    return opUt(vResult, vDist, fts);\n}\n\n\n// ========================================\nsMat getMaterial( sHit hitInfo ) {\n    sMat mat;\n    if(hitInfo.oid.x == MATERIAL_1) {\n        mat.frs = 0.1;\n        mat.smt = 1.0;\n        mat.trs = 1.0;\n        mat.fri = 0.75;\n        const float fExtinctionScale = 5.0;\n        vec3 tc = vec3(0.5,1.0,0.5);        //tex/col\n        mat.ctc = (vec3(1.0) - tc) * fExtinctionScale; \n    } else\n    if(hitInfo.oid.x == MATERIAL_2) {\n        mat.frs = 0.3;\n        mat.smt = 1.0;\n        mat.trs = 0.2;\n        mat.fri = 0.0;\n        mat.ctc = vec3(0.5,1.0,0.5);\n    }\n    return mat;\n}\n\n// ========================================\nvec3 getBackground( vec3 rd ) {\n#ifdef BACKGROUND_BLUE\n    const vec3  tc = vec3(0.65, 0.78, 1.0);\n    const vec3  cc = tc * 0.5;\n          float f  = clamp(rd.y, 0.0, 1.0);\n    return mix(cc, tc, f);\n#else\n    return texture(iChannel0, rd).xyz;\n#endif\n}\n\n// ========================================\nsLight getDirLight() {\n    sLight result;\n    result.rd  = normalize(vec3(-0.2, -0.3, 0.5));\n    result.col = vec3(8.0, 7.5, 7.0);\n    return result;\n}\n\n// ========================================\nvec3 getAmbient( vec3 nor ) {\n    return getBackground(nor);\n}\n\n// ========================================\nvec3 normal( vec3 p, float fts ) {\n    vec3 e = vec3(0.01,-0.01,0.0);\n    return normalize( vec3(\n        e.xyy*DE(p+e.xyy,fts).x +\n        e.yyx*DE(p+e.yyx,fts).x +\n        e.yxy*DE(p+e.yxy,fts).x +\n        e.xxx*DE(p+e.xxx,fts).x)\n    );\n}\n\n// ========================================\nvoid march( sRay ray, out sHit res, int maxIter, float fts ) {\n    res.hd = ray.sd;\n    res.oid.x = 0.0;\n\n    for( int i=0;i<=MARCHSTEPS;i++ ) {\n        res.hp = ray.ro + ray.rd * res.hd;\n        vec4 r = DE( res.hp, fts );\n        res.oid = r.yzw;\n        if((abs(r.x) <= 0.01) || (res.hd >= ray.rl) || (i > maxIter))\n            break;\n        res.hd = res.hd + r.x;\n    }\n    if(res.hd >= ray.rl) {\n        res.hd = MAX_DIST;\n        res.hp = ray.ro + ray.rd * res.hd;\n        res.oid.x = 0.0;\n    }\n}\n\n// ========================================\nfloat getShadow( vec3 hp, vec3 nor, vec3 lrd, float d ) {\n#ifdef SHADOWS\n    sRay ray;\n    ray.rd = lrd;\n    ray.ro = hp;\n    ray.sd = 0.05 / abs(dot(lrd, nor));\n    ray.rl = d - ray.sd;\n    sHit si;\n    march(ray, si, 32, kNt);\n    float s = step(0.0, si.hd) * step(d, si.hd );\n    return s;\n#else\n    return 1.0;\n#endif\n}\n\n// ========================================\nfloat getAmbientOcclusion( sHit hi, sSurf s ) {\n#ifdef AMBIENT_OCCLUSION\n    vec3 hp = hi.hp;\n    vec3 nor = s.nor;\n    float ao = 1.0;\n\n    float d = 0.0;\n    for( int i=0; i<=5; i++ ) {\n        d += 0.1;\n        vec4 r = DE(hp + nor * d, kNt);\n        ao *= 1.0 - max(0.0, (d - r.x) * 0.2 / d );\n    }\n    return ao;\n#else\n    return 1.0;\n#endif\n}\n\n// ========================================\nvec3 getFog( vec3 color, sRay ray, sHit hi ) {\n#ifdef FOG\n    float a = exp(hi.hd * - 0.05);\n    vec3 fog = getBackground(ray.rd);\n\n    #ifdef DIRECTIONAL_LIGHT_FLARE\n        sLight lig = getDirLight();\n        float f = clamp(dot(-lig.rd, ray.rd), 0.0, 1.0);\n        fog += lig.col * pow(f, 10.0);\n    #endif \n\n    color = mix(fog, color, a);\n#endif\n\n    return color;\n}\n\n// http://en.wikipedia.org/wiki/Schlick's_approximation\n// Anisotropic scattering Schlick phase function\n// \"Interactive Manycore Photon Mapping\"\n// See: https://www.scss.tcd.ie/publications/tech-reports/reports.11/TCD-CS-2011-04.pdf\n//\n// More complex empirically motivated phase functions are efficiently approximated by the Schluck function [BLS93].\n// ========================================\nfloat getSchlick(vec3 nor, vec3 v, float frs, float sf) {\n    float f = dot(nor, -v);\n    f = clamp((1.0 - f), 0.0, 1.0);\n    float fDotPow = pow(f, 5.0);\n    return frs + (1.0 - frs) * fDotPow * sf;\n}\n\n// http://en.wikipedia.org/wiki/Fresnel_equations\n// ========================================\nvec3 getFresnel( vec3 dif, vec3 spe, vec3 nor, vec3 v, sMat m ) {\n    float f = getSchlick(nor, v, m.frs, m.smt * 0.9 + 0.1);\n    return mix(dif, spe, f);\n}\n\n// ========================================\nfloat getPhong( vec3 ird, vec3 lrd, vec3 nor, float smt ) {\n    vec3  v  = normalize(lrd - ird);\n    float f  = max(0.0, dot(v, nor));\n    float sp = exp2(4.0 + 6.0 * smt);\n    float si = (sp + 2.0) * 0.125;\n    return pow(f, sp) * si;\n}\n\n// ========================================\nsShade setDirLight( sLight l, vec3 p, vec3 d, vec3 nor, sMat m ) {\n    sShade s;\n    vec3 lrd = -l.rd;\n    float sf = getShadow( p, nor, lrd, 8.0 );\n    vec3 il = l.col * sf * max(0.0, dot(lrd, nor));\n    s.dfs = il;\n    s.spc = getPhong( d, lrd, nor, m.smt ) * il;\n    return s;\n}\n\n// ========================================\nvec3 setColor( sRay ray, sHit hi, sSurf sc, sMat m ) {\n    vec3 color;\n    sShade s;\n    s.dfs = vec3(0.0);\n    s.spc = vec3(0.0);\n    float ao = getAmbientOcclusion(hi, sc);\n    vec3 al = getAmbient(sc.nor) * ao;\n    s.dfs += al;\n    s.spc += sc.ref;\n\n#ifdef DIRECTIONAL_LIGHT\n    sLight dl = getDirLight();\n    sShade sh = setDirLight(dl, hi.hp, ray.rd, sc.nor, m);\n    s.dfs += sh.dfs;\n    s.spc += sh.spc;\n#endif\n\n    vec3 dr = s.dfs * m.ctc;\n\n    dr = mix(dr, sc.tra, m.trs);\n\n#ifdef SPECULAR\n    color = getFresnel(dr , s.spc, sc.nor, ray.rd, m);\n#else\n    color = dr;\n#endif\n\n    return color;\n}\n\n// ========================================\nvec3 getColor( sRay ray ) {\n    sHit hi;\n    march(ray, hi, 32, kNt);\n    vec3 color;\n\n    if(hi.oid.x < 0.5) {\n        color = getBackground(ray.rd);\n    } else {\n        sSurf s;\n        s.nor  = normal(hi.hp, kNt);\n        sMat m = getMaterial( hi );\n        s.ref  = getBackground(reflect(ray.rd, s.nor));\n        m.trs  = 0.0;\n        color  = setColor(ray, hi, s, m);\n    }\n\n    color = getFog(color, ray, hi);\n    return color;\n}\n\n// ========================================\nvec3 getReflection( sRay ray, sHit hitInfo, sSurf s ) {\n#ifdef REFLECTIONS\n    sRay rRay;\n    rRay.rd = reflect(ray.rd, s.nor);\n    rRay.ro = hitInfo.hp;\n    rRay.rl = 16.0;\n    rRay.sd = 0.1 / abs(dot(rRay.rd, s.nor));\n    return getColor(rRay);\n#else\n    return getBackground(reflect(ray.rd, s.nor));\n#endif\n}\n\n// ========================================\nvec3 getTransparency( sRay ray, sHit hit, sSurf s, sMat m ) {\n#ifdef TRANSPARENCY\n    sRay rRay;\n    rRay.rd = refract(ray.rd, s.nor, m.fri);\n    rRay.ro = hit.hp;\n    rRay.rl = 16.0;\n    rRay.sd = 0.05 / abs(dot(rRay.rd, s.nor));\n\n    #ifdef DOUBLE_SIDED_TRANSPARENCY\n        sHit hit2;\n        march(rRay, hit2, 32, kIt);\n        vec3 nor = normal(hit2.hp, kIt);\n            sRay rRay2;\n            rRay2.rd = refract(rRay.rd, nor, 1.0 / m.fri);\n            rRay2.ro = hit2.hp;\n            rRay2.rl = 16.0;\n            rRay2.sd = 0.0;\n        float ed = hit2.hd;\n        vec3 color = getColor( rRay2 );\n    #else\n        vec3 color = getColor( rRay );\n        float ed = 0.5;\n    #endif\n\n    return color * clamp(exp(-(m.ctc * ed)),0.0,1.0);\n#else\n    return getBackground(reflect(ray.rd, s.nor));\n#endif\n}\n\n// ========================================\nvec3 getRayColor( sRay ray ) {\n    sHit i;\n    march(ray, i, MARCHSTEPS, kTt); //256\n\n    vec3 color;\n    if(i.oid.x < 0.5) {\n        color = getBackground(ray.rd);\n    } else  {\n        sSurf s;\n        s.nor  = normal(i.hp, kTt);\n        sMat m = getMaterial( i );\n        s.ref  = getReflection(ray, i, s);\n        if(m.trs > 0.0) s.tra = getTransparency(ray, i, s, m);\n        color  = setColor(ray, i, s, m);\n    }\n\n    getFog(color, ray, i); // BUG? Is this intentional that color is not updated??\n    return color;\n}\n\n// ========================================\nsRay setCameraRay( vec3 hp, vec3 i , vec2 fragCoord) {\n    float fRatio = iResolution.x / iResolution.y; // Aspect Ratio\n\n    vec3 f   = normalize(i - hp);\n    vec3 vUp = vec3(0.0, 1.0, 0.0);\n    vec2 vvc = 2.*fragCoord.xy/iResolution.xy-1.;\n    vvc.y /= fRatio;\n\n    sRay ray;\n    ray.ro = hp;\n    vec3 r = normalize(cross(f, vUp));\n    vUp    = cross(r, f);\n    ray.rd = normalize( r * vvc.x + vUp * vvc.y + f);\n    ray.sd = 0.0;\n    ray.rl = MAX_DIST;\n    return ray;\n}\n\n// ========================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 m = vec2(0.0); // Default OpenGL camera: Look down -z axis\n\n#ifdef VIEW_ISOMETRIC\n    m = vec2( 3.5, 1.0 ) / PI; // fake isoemetric\n#else\n  #ifdef VIEW_ZERO\n    // m.x = 0.0; // +z // h -> 0      =   0\n    // m.x =+1.0;; //-z // h -> PI     = 180\n    // m.x = 0.5; // +x // h -> PI  /2 =  90\n    // m.x =-0.5; // -x // h -> PI*3/2 = 270\n    //m.y = iMouse.y / iResolution.y; // uncomment to allow Y rotation\n  #else\n    m += 2.* iMouse.xy / iResolution.xy;\n    m.x += 1.;\n  #endif // ZERO\n#endif // ISOMETRIC\n\n    float nRotate = 0.0; // no rotation\n#ifdef AUTO_ROTATE\n    nRotate = iTime *0.05; // slow rotation\n#endif\n\n    //float h  = mix(0.0, PI , m.x - nRotate);\n    float h  = PI * (m.x - nRotate);\n    float e  = mix(0.0, 2.5, m.y                ); // eye\n    // Hold down mouse button to zoom out & rotate the camera!\n    float d  = mix(2.5, 2.5 + (iMouse.z > 0.0 ? 4.0 : 2.0), m.y); // eye distance\n\n    // ro RayOrigin\n    vec3 ro  = vec3(sin(h) * cos(e), sin(e), cos(h) * cos(e)) * d;\n    vec3 ta  = vec3(0.0, 0.0, 0.0);\n\n    sRay ray = setCameraRay( ta + ro, ta, fragCoord);\n    vec3 col = getRayColor( ray );\n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}