{
    "Shader": {
        "info": {
            "date": "1568831403",
            "description": "The best way to transform the normals of an object with an arbitrary transformation matrix it to use the adjoint, not the transpose of the inverse. See comments in the shader for more info.",
            "flags": 0,
            "hasliked": 0,
            "id": "3s33zj",
            "likes": 33,
            "name": "Adjoint",
            "published": 3,
            "tags": [
                "3d",
                "normal",
                "transformation",
                "adjoint"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 1778
        },
        "renderpass": [
            {
                "code": "// Inigo Quilez 2019\n\n// This shader shows how to use the adjoint matrix to\n// transform the normals of an object when the scale\n// is not uniform. The adjoint matrix is quicker to\n// compute than the traditional transpose(inverse(m)),\n// is more numerically stable, and does not break\n// when the matrix has negative determinant. The shader\n// uses spheres which have been deformed with non uniform\n// scales, to show the effect.\n\n// Compare methods:\n//\n// 0: n = adjoint(m)            --> correct\n// 1: n = transpose(inverse(m)) --> sometimes incorrect, and slow\n// 2: n = m                     --> always incorrect\n\n#define METHOD 0\n\n//===================================================\n\n// Use to transform normals with transformation of\n// arbitrary non-uniform scales (including negative)\n// and skewing. The code assumes the last column of m is \n// [0,0,0,1]. More info here:\n// https://github.com/graphitemaster/normals_revisited\n\nmat3 adjoint( in mat4 m )\n{\n    // 3 alternative ways to write the same thing\n    \n    return mat3(cross(m[1].xyz, m[2].xyz), \n                cross(m[2].xyz, m[0].xyz), \n                cross(m[0].xyz, m[1].xyz));\n                \n    return mat3( \n     m[1].yzx*m[2].zxy-m[1].zxy*m[2].yzx,\n     m[2].yzx*m[0].zxy-m[2].zxy*m[0].yzx,\n     m[0].yzx*m[1].zxy-m[0].zxy*m[1].yzx );\n\n    return mat3( \n     m[1][1]*m[2][2]-m[1][2]*m[2][1],\n     m[1][2]*m[2][0]-m[1][0]*m[2][2],\n     m[1][0]*m[2][1]-m[1][1]*m[2][0],\n     m[0][2]*m[2][1]-m[0][1]*m[2][2],\n\t m[0][0]*m[2][2]-m[0][2]*m[2][0],\n     m[0][1]*m[2][0]-m[0][0]*m[2][1],\n     m[0][1]*m[1][2]-m[0][2]*m[1][1],\n     m[0][2]*m[1][0]-m[0][0]*m[1][2],\n     m[0][0]*m[1][1]-m[0][1]*m[1][0] );\n}\n\n// sphere intersection\nfloat iSphere( in vec3 ro, in vec3 rd, in mat4 worldToObject )\n{\n\tvec3 roo = (worldToObject*vec4(ro,1.0)).xyz;\n    vec3 rdd = (worldToObject*vec4(rd,0.0)).xyz;\n    float a = dot( rdd, rdd );\n\tfloat b = dot( roo, rdd );\n\tfloat c = dot( roo, roo ) - 1.0;\n\tfloat h = b*b - a*c;\n\tif( h<0.0 ) return -1.0;\n\treturn (-b-sqrt(h))/a;\n}\n\n// sphere shadow\nfloat sSphere( in vec3 ro, in vec3 rd, in mat4 worldToObject )\n{\n\tvec3 roo = (worldToObject*vec4(ro,1.0)).xyz;\n    vec3 rdd = (worldToObject*vec4(rd,0.0)).xyz;\n    float a = dot( rdd, rdd );\n\tfloat b = dot( roo, rdd );\n\tfloat c = dot( roo, roo ) - 1.0;\n\tfloat h = b*b - a*c;\n\tif( h<0.0 ) return -1.0;\n    if( b<0.0 ) return  1.0;\n    return -sign(c);\n}\n\n//-----------------------------------------------------------------------------------------\n\nmat4 rotateAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( in vec3 v )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t v.x, v.y, v.z, 1.0 );\n}\n\nmat4 scale( in vec3 v )\n{\n    return mat4( v.x, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, v.y, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, v.z, 0.0,\n\t\t\t\t 0.0, 0.0, 0.0, 1.0 );\n}\n\n//-----------------------------------------------------------------------------------------\n\nmat4 getSphereToWorld( in int i, out bool isFlipped )\n{\n    float t = iTime*0.5;\n    vec3 fli = sign(sin(float(i)+vec3(1.0,2.0,3.0)));\n    mat4 rot = rotateAxisAngle( normalize(sin(float(11*i)+vec3(0.0,2.0,1.0))), 0.0+t*1.3 );\n    mat4 ros = rotateAxisAngle( normalize(sin(float( 7*i)+vec3(4.0,3.0,5.0))), 2.0+t*1.1 );\n    mat4 sca = scale( (0.3+0.25*sin(float(13*i)+vec3(0.0,1.0,4.0)+t*1.7))*fli );\n    mat4 tra = translate( vec3(0.0,0.5,0.0) + 0.5*sin(float(17*i)+vec3(2.0,5.0,3.0)+t*1.2) );\n    \n    isFlipped = (fli.x*fli.y*fli.z) < 0.0;\n    return ros * tra * sca * rot;\n}\n\nconst int kNumSpheres = 12;\n\nfloat shadow( in vec3 ro, in vec3 rd )\n{\n    for( int i=0; i<kNumSpheres; i++ )\n    {\n        bool tmp;\n        mat4 objectToWorld = getSphereToWorld( i, tmp );\n        mat4 worldToObject = inverse( objectToWorld );\n        if( sSphere( ro, rd, worldToObject ) > 0.0 )\n            return 0.0;\n    }\n    return 1.0;\n}\n\nvec3 shade( in vec3 ro, in vec3 rd, in float t, \n            in float oid, in vec3 wnor )\n{\n    vec3 lig = normalize(vec3(-0.8,0.4,0.1));\n    vec3 wpos = ro + t*rd;\n\n    // material\n    vec3  mate = vec3(0.18);\n    if( oid>1.5 ) mate = 0.18*(0.55+0.45*cos(7.0*oid+vec3(0.0,2.0,4.0)));\n\n    // lighting\n    vec3 hal = normalize( lig-rd );\n    float dif = clamp( dot(wnor,lig), 0.0, 1.0 );\n    float sha = shadow( wpos+0.01*wnor, lig );\n    float fre = clamp(1.0+dot(rd,wnor),0.0,1.0);\n    float spe = clamp(dot(wnor,hal),0.0,1.0);\n\n    // material * lighting\t\t\n    vec3 col = vec3(0.0);\n    col += 8.0*vec3(1.00,0.90,0.80)*dif*sha;\n    col += 2.0*vec3(0.10,0.20,0.30)*(0.6+0.4*wnor.y);\n    col += 1.0*vec3(0.10,0.10,0.10)*(0.5-0.5*wnor.y);\n    col += fre*(0.6+0.4*wnor.y);\n    col *= mate;\n    col += pow(spe,16.0)*dif*sha*(0.1+0.9*fre);\n\n    // fog\n    col = mix( col, vec3(0.7,0.8,1.0), 1.0-exp( -0.003*t*t ) );\n\n    return col;\n}\n        \n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2  // Set AA to 1 if your machine is too slow\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera movement\t\n\tfloat an = 0.4*iTime;\n\tvec3 ro = vec3( 2.5*cos(an), 0.7, 2.5*sin(an) );\n    vec3 ta = vec3( 0.0, 0.2, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n        // raytrace\n        float tmin = 1e10;\n        vec3  wnor = vec3(0.0);\n        float oid = 0.0;\n\n        // raytrace plane\n        float h = (-0.5-ro.y)/rd.y;\n        if( h>0.0 ) \n        { \n            tmin = h; \n            wnor = vec3(0.0,1.0,0.0); \n            vec3 wpos = ro+tmin*rd;\n            oid = 1.0;\n        }\n\n        // raytrace spheres\n        for( int i=0; i<kNumSpheres; i++ )\n        {\n            // location of sphere i\n            bool isFlipped = false;\n            mat4 objectToWorld = getSphereToWorld( i, isFlipped );\n            mat4 worldToObject = inverse( objectToWorld );\n\n            float res = iSphere( ro, rd, worldToObject );\n            if( res>0.0 && res<tmin )\n            {\n                tmin = res; \n                vec3 wpos = ro+tmin*rd;\n                vec3 opos = (worldToObject*vec4(wpos,1.0)).xyz;\n                vec3 onor = normalize(opos) *(isFlipped?-1.0:1.0);\n\n                #if METHOD==0 // CORRECT\n                wnor = normalize(adjoint(objectToWorld)*onor);\n                #endif\n                #if METHOD==1 // WRONG OFTEN\n                wnor = normalize((transpose(inverse(objectToWorld))*vec4(onor,0.0)).xyz);\n                #endif\n                #if METHOD==2 // WRONG ALWAYS\n                wnor = normalize((objectToWorld*vec4(onor,0.0)).xyz);\n                #endif\n\n                oid = 2.0 + float(i);\n            }\n        }\n\n        // shading/lighting\t\n        vec3 col = vec3(0.7,0.8,1.0);\n        if( oid>0.5 )\n        {\n            col = shade( ro, rd, tmin, oid, wnor );\n        }\n\n        col = pow( col, vec3(0.4545) );\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n\tfragColor = vec4( tot, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}