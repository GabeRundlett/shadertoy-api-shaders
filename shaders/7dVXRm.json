{
    "Shader": {
        "info": {
            "date": "1634454173",
            "description": "experiment with unpacking textures and doing tangent space normal mapping with SDFs. Not that special but this is the first time I've tried it. mainly just muddling through the way I'm used to shading meshes, but I think it turned out ok",
            "flags": 32,
            "hasliked": 0,
            "id": "7dVXRm",
            "likes": 9,
            "name": "You're tellin' me...?",
            "published": 3,
            "tags": [
                "sdf",
                "food",
                "lit"
            ],
            "usePreview": 0,
            "username": "Xibanya",
            "viewed": 504
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    fragColor = vec4(col.rgb, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define saturate(x) clamp(x, 0., 1.)\n#define ZOOM 0.35\n#define LIGHT_COLOR vec3(1.00, 0.85, 0.55)\n#define SHADOW_COLOR vec3(0.5294, 0.3569, 0.5804)\n#define EPS vec3(0.001, 0.0, 0.0)\n\n#define BOWL_COLOR  vec3(0.84,0.34,0.34)\n#define RICE_COLOR vec3(0.93,0.9,0.8)\n#define TABLE_COLOR vec3(0.5098, 0.3804, 0.298)\n#define SHRIMP vec3(1.0, 0.62, 0.5)\n\n// prototyped scene in https://stephaneginier.com/archive/editSDF/\n\n// Basic Bump Mapping\n// https://www.shadertoy.com/view/ld2GRh\nvec3 TangentNormal(sampler2D tex, vec2 coord)\n{\n    const float diff = 0.001;\n\t// Get the local difference of height along the X axis.\n\tfloat diffX = texture(tex, vec2(coord.x + diff, coord.y)).x\n\t\t-texture(tex, vec2(coord.x-diff, coord.y)).x;\n\t\n\t// Do the same along the Y axis.\n\tfloat diffY = texture(tex, vec2(coord.x, coord.y+diff)).x\n\t\t-texture(tex, vec2(coord.x, coord.y-diff) ).x;\n\n\tvec2 localDiff = vec2(diffX, diffY);\n\tlocalDiff *= -1.0;\n\tlocalDiff = (localDiff/2.0)+.5;\n\tfloat localDiffMag = length(localDiff);\n\tfloat z = sqrt(1.0 - pow(localDiffMag, 2.0));\n\treturn vec3(localDiff, z) * 2. - 1.;\n}\n\nfloat sdSphere(const in vec3 p, const in float s) {\n  return length(p) - s;\n}\nfloat sdTorus(const in vec3 p, const in vec2 t) {\n  return length(vec2(length(p.xz) - t.x, p.y)) - t.y;\n}\nfloat sdBox(const in vec3 p, const in vec4 b) {\n  vec3 d = abs(p) - b.xyz;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)) - b.w;\n}\n\nfloat sdEllipsoid(const in  vec3 p, const in vec3 r) {\n  return (length(p / r) - 1.0) * min(min(r.x, r.y), r.z);\n}\nfloat ShrimpDist(vec3 p) \n{   \n    p += vec3(0., -0.2, 0.);\n    vec3 pos = (mat4(\n        1.0,0.0,0.0,0.0,\n        0.0,1.0,0.0,0.0,\n        0.0,0.0,1.0,0.0,\n        0.0,0.0,0.0,1.0) * vec4(p, 1.0)).xyz;\n  float s = sdTorus(pos, vec2(0.33,0.15) * 0.5);  \n    s = max(s, \n    -sdSphere((mat4(\n        1.0,0.0,0.0,0.0,\n        0.0,1.0,0.0,0.0,\n        0.0,0.0,1.0,0.0,\n        0.0,0.0126,-0.22,1.0) * \n    vec4(p, 1.0)).xyz, 0.4 * 0.5));\ns = min(s, sdBox((mat4(\n    5.84,0.0,1.085,\n    0.0,0.0,5.94,0.0,0.0,\n    -1.085, 0.0,5.84,0.0,\n    1.750817894935608,0.0, -0.47,1.0) * \n    vec4(p, 1.0)).xyz + vec3(-0.7, 0., 0.), \n    vec4(0.2,0.24,0.91,0.84) * 0.5) * 0.17);\n\nvec3 tailPos = (mat4(\n    1.85,0.0,-0.64,0.0,\n    0.0,1.96,0.0,0.0,\n    0.64,0.0,1.85,0.0,\n    -0.74,0.0,-0.38,1.0) * \n    vec4(p, 1.0)).xyz + vec3(0.4, 0., 0.);\ns = min(s, sdEllipsoid(tailPos, \n    vec3(0.0353, 0.0863, 0.1725) * 2.));\n    return s;\n}\n\nfloat BowlDist(vec3 p)\n{\n  vec3 bowlPos = (mat4(\n        0.63,0.0,0.0,0.0,\n        0.0,0.63,0.0,0.0,\n        0.0,0.0,0.63,0.0,\n        0.0,-0.066,0.0,1.0) * \n      vec4(p, 1.0)).xyz;\n  float s = sdSphere(bowlPos, 0.4) * 1.59;\n  vec3 subTopPos = (mat4(\n    1.0,0.0,0.0,0.0,\n    0.0,1.0,0.0,0.0,\n    0.0,0.0,1.0,0.0,\n    0.0,-0.49,0.0,1.0) * \n    vec4(p, 1.0)).xyz;\n  vec3 innerPos = (mat4(\n    0.66,0.0,0.0,0.0,\n    0.0,0.66,0.0,0.0,\n    0.0,0.0,0.66,0.0,\n    0.0,-0.0625,0.0,1.0) * \n    vec4(p, 1.0)).xyz;\n  float negativeBowl = min(\n    sdBox(subTopPos, vec4(0.68,0.4,0.8,0.0)),\n    sdSphere(innerPos, 0.4) * 1.52\n  );   \n  s = max(s, -negativeBowl);\n  return s;\n}\n\nfloat RiceDist(vec3 p)\n{\n  vec3 ricePos = (mat4(\n    1.0,0.0,0.0,0.0,\n    0.0,1.0,0.0,0.0,\n    0.0,0.0,1.0,0.0,\n    0.0,0.125,0.0,1.0) * \n    vec4(p, 1.0)).xyz;\n  return sdEllipsoid(ricePos, vec3(0.57,0.27,0.56));\n}\n\nfloat TableDist(vec3 p)\n{\n  vec3 tablePos = (mat4(\n    1.0,0.0,0.0,0.0,\n    0.0,1.0,0.0,0.0,\n    0.0,0.0,1.0,0.0,\n    0.0,0.55,0.0,1.0) * \n    vec4(p, 1.0)).xyz;\n  float table = sdBox(tablePos, vec4(1.48,0.01,1.48,0.0));\n  return table;\n}\n\nfloat mapDistance(const in vec3 p, out vec3 normal, out vec3 col, \n    out float shiny) \n{\n  vec2 uvX = p.zy;\n  vec2 uvY = p.xz;\n  vec2 uvZ = p.xy;\n\n  float s = BowlDist(p);\n  col = BOWL_COLOR;\n  shiny = 1.5;\n\n  normal = normalize(vec3(\n      BowlDist(p + EPS.xyy) - BowlDist(p - EPS.xyy),\n      BowlDist(p + EPS.yxy) - BowlDist(p - EPS.yxy),\n      BowlDist(p + EPS.yyx) - BowlDist(p - EPS.yyx)));\n  vec3 tNormalX = TangentNormal(iChannel2, uvX * 0.25);\n  vec3 tNormalY = TangentNormal(iChannel2, uvY * 0.25);\n  vec3 tNormalZ = TangentNormal(iChannel2, uvZ * 0.25);\n  shiny *= pow(tNormalZ.x * 0.5 + 0.5, 0.05);\n  vec3 aSign = sign(normal);\n  \n  float rice = RiceDist(p);\n  vec3 riceNorm = normalize(vec3(\n      RiceDist(p + EPS.xyy) - RiceDist(p - EPS.xyy),\n      RiceDist(p + EPS.yxy) - RiceDist(p - EPS.yxy),\n      RiceDist(p + EPS.yyx) - RiceDist(p - EPS.yyx)));\n  tNormalX = s < rice? tNormalX : TangentNormal(iChannel1, uvX * 2.);\n  tNormalY = s < rice? tNormalY : TangentNormal(iChannel1, uvY * 2.);\n  tNormalZ = s < rice? tNormalZ : TangentNormal(iChannel1, uvZ * 2.);\n  float riceTex = (mat3(\n        texture(iChannel1, p.yz * vec2(4., 2.)).rgb,\n        texture(iChannel1, p.xz * vec2(4., 2.)).rgb,\n        texture(iChannel1, p.xy * vec2(4., 2.)).rgb\n        ) * abs(riceNorm)).r;\n  vec3 riceColor = smoothstep(-0.35, 0.8, riceTex) * RICE_COLOR;\n  aSign = s < rice? aSign : sign(riceNorm);\n  col = s < rice? col : riceColor;\n  normal = s < rice? normal : riceNorm;\n  shiny = s < rice? shiny : 0.;\n  s = min(s, rice);\n\n    float shrimp = ShrimpDist(p);\n    col = s < shrimp? col : SHRIMP;\n    vec3 shrimpNorm = normalize(vec3(\n      ShrimpDist(p + EPS.xyy) - ShrimpDist(p - EPS.xyy),\n      ShrimpDist(p + EPS.yxy) - ShrimpDist(p - EPS.yxy),\n      ShrimpDist(p + EPS.yyx) - ShrimpDist(p - EPS.yyx)));\n    tNormalX = s < shrimp? tNormalX : TangentNormal(iChannel3, uvX * 2.);\n    tNormalY = s < shrimp? tNormalY : TangentNormal(iChannel3, uvY * 2.);\n    tNormalZ = s < shrimp? tNormalZ : TangentNormal(iChannel3, uvZ * 2.);\n    normal = s < shrimp? normal : shrimpNorm;\n    shiny = s < shrimp? shiny : 0.15;\n    s = min(s, shrimp);\n\n  float table = TableDist(p);\n  vec3 tableNorm = normalize(vec3(\n      TableDist(p + EPS.xyy) - TableDist(p - EPS.xyy),\n      TableDist(p + EPS.yxy) - TableDist(p - EPS.yxy),\n      TableDist(p + EPS.yyx) - TableDist(p - EPS.yyx)));\n\n  vec3 tableTex = mat3(\n        texture(iChannel0, uvX * 0.5).rgb,\n        texture(iChannel0, uvY * 0.5).rgb,\n        texture(iChannel0, uvZ * 0.5).rgb\n        ) * abs(tableNorm);\n    \n    vec3 tableColor = mix(TABLE_COLOR * 0.65, TABLE_COLOR, tableTex.r);\n    col = s < table? col : tableColor;\n    \n    tNormalX = s < table? tNormalX : TangentNormal(iChannel0, uvX * 0.5);\n    tNormalY = s < table? tNormalY : TangentNormal(iChannel0, uvY * 0.5);\n    tNormalZ = s < table? tNormalZ : TangentNormal(iChannel0, uvZ * 0.5);\n\n    tNormalX.z *= aSign.x;\n    tNormalY.z *= aSign.y;\n    tNormalZ.z *= aSign.z;\n    normal = s < table? normal : tableNorm;\n\n  normal = normalize(\n    tNormalX.zyx * normal.x +\n    tNormalY.xzy * normal.y +\n    tNormalZ.xyz * normal.z +\n    normal\n  );\n  shiny = s < table? shiny : 1.;\n  s = min(s, table);\n  return s;\n}\n\nfloat JustScene(vec3 p)\n{\n  float s = min(BowlDist(p), RiceDist(p));\n  s = min(s, ShrimpDist(p));\n  return min(s, TableDist(p));\n}\n// packing glossiness into w of nrm\nvec4 CastRay(vec3 ro, vec3 rd, out vec4 nrm) \n{\n  float d = 1.0;\n  const float maxDist = 50.0;\n  const float minDist = 0.001;\n  vec3 col;\n  for(int i = 0; i < 150; i++) \n  {\n    float dist = mapDistance(ro + rd * d, \n        nrm.xyz, col, nrm.w);\n    if (dist < abs(minDist) || d > maxDist) break;\n    d += dist;\n  }\n  col = d > maxDist ? vec3(-1.0) : col;\n  return vec4(d, col);\n}\n\nfloat Attenuate(const in vec3 dir, const in vec3 rd) \n{\n  float d = 0.02;\n  float tmax = 2.5;\n  float precis = 0.001;\n  float res = 1.0;\n  for(int i = 0; i < 20; i++) \n  {\n    float dist = JustScene(dir + rd * d);\n    res = min(res, 20.0 * dist / d);\n    d += clamp(dist, 0.02, 0.10);\n    if (dist < precis || d > tmax) break;\n  }\n  return saturate(res);\n}\nvec4 Draw(const in vec3 dir, const in vec3 eyeVec) \n{\n  vec3 col;\n  float a = 0.;\n  vec4 nrm;\n  vec4 res = CastRay(dir, eyeVec, nrm);\n  if (res.y >= 0.0) \n  {\n    float shiny = nrm.w;\n    vec3 pos = dir + res.x * eyeVec;\n    vec3 lightDir = normalize(vec3(-0.6, 0.2, -0.4));\n    float atten = Attenuate(pos, lightDir);\n    vec3 albedo = res.yzw;\n    vec3 worldNormal = nrm.xyz;\n    vec3 refl = reflect(-lightDir, worldNormal);\n    float r = pow(max(dot(refl, -eyeVec), 0.), 1.5);\n    vec3 halfDir = normalize(lightDir - eyeVec);\n    float nDotH = smoothstep(0.7, 0.8, \n        dot(worldNormal, halfDir) * 0.5 + 0.5);\n    float nDotV = dot(worldNormal, -eyeVec) * 0.5 + 0.5;\n    float rimTerm = 1. - pow(nDotV, 2.);\n    // this is a hack, the hardened fresnel looks good\n    // on the bowl but bad on the table, and I'm\n    // writing 1. to shiny only if it is the table\n    if (shiny != 1.)\n    {    \n        rimTerm = smoothstep(0.5, 0.65, rimTerm);\n    }\n    float nDotL = (dot(worldNormal, lightDir) * 0.5 + 0.5) * atten;\n    nDotL = smoothstep(0.3, 0.5, nDotL);\n    vec3 diffuse = mix(SHADOW_COLOR, LIGHT_COLOR, nDotL);\n   \n    vec3 rim = rimTerm * diffuse * 0.75 * shiny;\n    vec3 specular = shiny * (nDotH + r) * LIGHT_COLOR * (albedo * 0.5);\n    col = albedo * (diffuse * 1.2 + rim);\n    col += specular;\n    a = 1.;\n  }\n  return vec4(saturate(col), a);\n}\n\nmat3 ViewMatrix(vec3 ro, vec3 ta)\n{\n  vec3 cw = normalize(ta - ro);\n  vec3 up = vec3(0., 1., 0.);\n  vec3 cu = normalize(cross(cw, up));\n  vec3 cv = normalize(cross(cu,cw) );\n  return mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec2 p = -1.0 + 2.0 * uv;\n  p.x *= iResolution.x / iResolution.y;\n  vec2 mo = iMouse.xy / iResolution.xy;\n  vec3 camRotation = ZOOM * vec3(\n      -5. * cos(mo.x), \n      0.5 + 3.0 * mo.y, \n      3.5);\n\n  if (iMouse.xy==vec2(0)) \n  {\n      camRotation = 0.45 * vec3(-3., 1., 2.5);\n  }\n\n  vec3 camPos = vec3(2.5, -1., -2.);\n\n  mat3 view = ViewMatrix(camRotation, camPos);\n  vec3 dir = view * normalize(vec3(p.xy, 2.0));\n  vec3 bg = mix(\n      vec3(0.4, 0.4, 0.5), \n      vec3(0.3, 0.1, 0.3), \n      dot(uv, vec2(0.7, 0.1)));\n  vec4 col = Draw(camRotation, dir);\n  fragColor = vec4(mix(bg, col.rgb, col.a), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 48,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}