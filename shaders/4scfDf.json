{
    "Shader": {
        "info": {
            "date": "1526962084",
            "description": "This is just a proof of technical feasibility, introducing time series to help color blindness recognize color.\nCurrently only applicable to protanopia.",
            "flags": 2,
            "hasliked": 0,
            "id": "4scfDf",
            "likes": 2,
            "name": "Colorblind Correction",
            "published": 3,
            "tags": [
                "color",
                "colorblind"
            ],
            "usePreview": 0,
            "username": "tioover",
            "viewed": 804
        },
        "renderpass": [
            {
                "code": "\n/*-----------------------------------------------------------.   \n/                     ColorBlind correction                   /\n'-----------------------------------------------------------*/\n// https://gist.github.com/jcdickinson/580b7fb5cc145cee8740\n// Daltonize (source http://www.daltonize.org/search/label/Daltonize)\n// http://mkweb.bcgsc.ca/colorblind/math.mhtml#page-container\n// Modified to simulate color blindness.\nvec4 colorblind_correction( vec4 col, float factor )\n{\n\t// RGB to LMS matrix conversion\n\tfloat L = (17.8824f * col.r) + (43.5161f * col.g) + (4.11935f * col.b);\n\tfloat M = (3.45565f * col.r) + (27.1554f * col.g) + (3.86714f * col.b);\n\tfloat S = (0.0299566f * col.r) + (0.184309f * col.g) + (1.46709f * col.b);\n    \n\t// Simulate color blindness\n    \n\t// #if ( COLORBLIND_MODE == 1) // Protanope - reds are greatly reduced (1% men)\n\t\tfloat l = 0.0f * L + 2.02344f * M + -2.52581f * S;\n\t\tfloat m = 0.0f * L + 1.0f * M + 0.0f * S;\n\t\tfloat s = 0.0f * L + 0.0f * M + 1.0f * S;\n\t// #endif\n    \n\t// #if ( COLORBLIND_MODE == 2) // Deuteranope - greens are greatly reduced (1% men)\n\t// \tfloat l = 1.0f * L + 0.0f * M + 0.0f * S;\n\t// \tfloat m = 0.494207f * L + 0.0f * M + 1.24827f * S;\n\t// \tfloat s = 0.0f * L + 0.0f * M + 1.0f * S;\n\t// #endif\n    \n\t// #if ( COLORBLIND_MODE == 3) // Tritanope - blues are greatly reduced (0.003% population)\n\t// \tfloat l = 1.0f * L + 0.0f * M + 0.0f * S;\n\t// \tfloat m = 0.0f * L + 1.0f * M + 0.0f * S;\n\t// \tfloat s = -0.395913f * L + 0.801109f * M + 0.0f * S;\n\t// #endif\n    \n\t// LMS to RGB matrix conversion\n\tvec4 error;\n\terror.r = (0.0809444479f * l) + (-0.130504409f * m) + (0.116721066f * s);\n\terror.g = (-0.0102485335f * l) + (0.0540193266f * m) + (-0.113614708f * s);\n\terror.b = (-0.000365296938f * l) + (-0.00412161469f * m) + (0.693511405f * s);\n\terror.a = 1.0;\n\n\t\n\t// Isolate invisible colors to color vision deficiency (calculate error matrix)\n\terror = (col - error);\n\t\n\t// Shift colors towards visible spectrum (apply error modifications)\n\tvec4 correction;\n\tcorrection.r = 0.0; // (error.r * 0.0) + (error.g * 0.0) + (error.b * 0.0);\n\tcorrection.g = (error.r * 0.7) + (error.g * 1.0); // + (error.b * 0.0);\n\tcorrection.b = (error.r * 0.7) + (error.b * 1.0); // + (error.g * 0.0);\n\t\n\t// Add compensation to original values\n\tcorrection = col + correction * factor;\n\tcorrection.a = col.a;\n\t\n\treturn correction.rgba;\n}\n\n\n// https://stackoverflow.com/a/17897228\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// https://www.shadertoy.com/view/XlSSRz\nfloat strip(vec4 texColor, vec2 fragCoord)\n{\n    float angle = 0.0; // A test engle for a texture.\n    float freq = 200.0; // Frequency across the screen.\n    float amp = 2.0; // Amplitude of texture. \n \tvec2 xy = fragCoord.xy / iResolution.xy;\n    \n    vec3 hsv = rgb2hsv(texColor.xyz);\n    angle = hsv.x * 3.14159;\n    \n     // quantize the angle so we get better areas of stripes.\n    angle = floor(angle * 10.0)/10.0;\n    float rotx = ((fragCoord.xy.x * cos(angle)) - (fragCoord.xy.y * sin(angle)))/iResolution.xy.x;\n    \n    amp = amp * hsv.y; // Increase mplitude for higher saturation.\n    \n    amp = clamp(amp,0.0,1.0);\n    // Set sinOffset to 0.5 to only decrease brightness.\n    // Set signOffset to 0.0 to balance the amplitude.\n    float sinOffset = 0.0;\n    float ampxy = 1.0 - (amp * (sinOffset + (0.5 * sin(rotx * freq * 2.0 * 3.14)))); \n    return ampxy;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec4 col = texture(iChannel0, uv);\n    vec3 hsv = rgb2hsv(col.xyz);\n    float c = 1.0;\n    vec4 correction = colorblind_correction(col, 1.0);\n    if (cos(uv.x * 1.0 + iTime * 6.0) > 0.96 && (hsv.x < 0.25 || hsv.x > 0.6667)) {\n        if (hsv.x > 0.084 && hsv.x < 0.6667f) {\n            fragColor = vec4(hsv2rgb(vec3(0.6667f, hsv.y, hsv.z)), 1.0);\n        } else {\n            fragColor = vec4(hsv2rgb(vec3(0.3333f, hsv.y, hsv.z)), 1.0);\n\n        }\n    } else if (hsv.x > 0.25 && hsv.x < 0.5834) {\n        // green\n        fragColor = correction * strip(col, fragCoord);\n    } else {\n        fragColor = correction;\n    }\n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "webcam",
                        "id": 31,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/webcam.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}