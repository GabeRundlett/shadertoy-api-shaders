{
    "Shader": {
        "info": {
            "date": "1516929370",
            "description": "Quick and dirty menger square with crummy AA. \n\nMouse x controls zooming centered at the bottom left corner",
            "flags": 0,
            "hasliked": 0,
            "id": "XlBBDG",
            "likes": 2,
            "name": "Menger Square Sketch.",
            "published": 3,
            "tags": [
                "2d",
                "fractal",
                "menger"
            ],
            "usePreview": 0,
            "username": "Glyph",
            "viewed": 584
        },
        "renderpass": [
            {
                "code": "#define ONETHIRD (1.0/3.0)\n#define BACKGROUND vec3(.012, .014, .013)\n\n#define MAXITERATIONS 18\n#define SUPERSAMPLE_ON\n\n// Smooth HSV to RGB conversion - Courtesy of IQ\nvec3 hsv2rgb_smooth( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat mengerSquare(in vec2 uv, in float pixsize){\n    \n    float val = 1.0;\n    float holesize = ONETHIRD;\n    \n    // Check if point is within 1/3 and 2/3 of the unit square then iteratively\n    // do the same for smaller sub squares. Exit's early if the size of the holes\n    // being checked is smaller than can be rendered/seen. \n    for(int itr = 0; itr < MAXITERATIONS && val >= .5 && pixsize <= holesize; itr++){\n        vec2 dblchk = step(vec2(ONETHIRD), uv) * step(uv, vec2(2.0*ONETHIRD));\n        val = 1.0-(dblchk.x * dblchk.y);\n        uv = fract(uv*3.0);\n        holesize*=ONETHIRD;\n    }\n    // Question: Does MAXITERATIONS matter? Assuming infinite zooming isn't \n    // allowed, does putting a maximum upper bound on the loop change anything\n    // in the way the code compiles or runs? \n    \n    return(val);\n}\n\n// Naive bit of supersampling to avoid rectangles and artifacts as things become small. \n#define SUPERSAMPLE(_UV, _PX){\\\n    float quartpix = (_PX)*.25;\\\n    vec2 pcuv = (uv) + (_PX)*.5;\\\n    float ssbl = mengerSquare(fract(pcuv-quartpix) , (_PX));\\\n    float sstr = mengerSquare(fract(pcuv+quartpix) , (_PX));\\\n    float ssbr = mengerSquare(fract(pcuv+vec2(quartpix, -quartpix)), (_PX));\\\n    float sstl = mengerSquare(fract(pcuv+vec2(-quartpix, quartpix)), (_PX));\\\n    fmask = (ssbl + sstr + ssbr + sstl)*.25;\\\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = (fragCoord / iResolution.y);\n    float pixsize = (1.0 / iResolution.y);\n    \n    // Get zoom from mouse and apply it. \n    float uvscalar = .000001 + pow(iMouse.x/iResolution.x, 2.0) * step(0.0, iMouse.z) + step(iMouse.z, 0.0);\n    uv *= uvscalar; pixsize *= uvscalar;\n    \n    // Coloring hue = sqrt(10 x distance along nearest axis) offset with time \n    float hue = sqrt( 10.0*max(abs(fract(uv.x)-.5),abs(fract(uv.y)-.5)))-iTime*.25;\n    vec3 mengerColor = hsv2rgb_smooth(vec3(hue, .4, .8));\n    \n    vec3 col; float fmask;\n#ifdef SUPERSAMPLE_ON\n    SUPERSAMPLE(uv, pixsize); \n#else\n    fmask = mengerSquare(fract(uv), pixsize);\n#endif\n    col = mix(BACKGROUND, mengerColor, fmask);\n    \n\tfragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}