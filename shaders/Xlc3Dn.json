{
    "Shader": {
        "info": {
            "date": "1468576136",
            "description": "multipass radial/zoom blur based on ryg's comments on pouet in 2008",
            "flags": 32,
            "hasliked": 0,
            "id": "Xlc3Dn",
            "likes": 12,
            "name": "multipass zoom/radial blur",
            "published": 3,
            "tags": [
                "blur",
                "zoom",
                "radial",
                "multipass"
            ],
            "usePreview": 0,
            "username": "seniltai",
            "viewed": 1025
        },
        "renderpass": [
            {
                "code": "#define STEPSIZE_SEQ 3.0\n\n// IDENTICAL CODE\n#define RADIAL 0\n#define STEPSIZE_CONFIG 0.12 * sin(iTime)\n#define STEPS 6.0\n#define STEPSIZE (((STEPSIZE_CONFIG) * pow(2.0, STEPSIZE_SEQ)) / STEPS)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 zoomUv = iMouse.xy/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvDelta = zoomUv- uv;\n    \n#if RADIAL == 1\n  \tuvDelta.xy = vec2(-uvDelta.y, uvDelta.x);\n#endif\n    \n    vec4 col = vec4(0.0, 0.0, 0.0, 0.0);\n    for(float i=0.0; i<STEPS; i += 1.0)\n    {\n    \tcol += texture(iChannel0, uv + (uvDelta * STEPSIZE * i) );\n    }\n    fragColor = col / STEPS;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// camera attributes\n// cameraDirection and cameraUp MUST be normalized\n// (ie. their length must be equal to 1)\nconst vec3 cameraPosition = vec3(0.0, 0.0, 5.0);\nconst vec3 cameraDirection = vec3(0.0, 0.0, -1.0);\nconst vec3 cameraUp = vec3(0.0, 1.0, 0.0);\n\n// ray computation vars\nconst float PI = 3.14159265359;\nconst float fov = 50.0;\nconst float fovx = PI * fov / 360.0;\n\n// epsilon-type values\nconst float S = 0.1;\nconst float EPSILON = 0.001;\n\n// const delta vectors for normal calculation\nconst vec3 deltax = vec3(S ,0, 0);\nconst vec3 deltay = vec3(0 ,S, 0);\nconst vec3 deltaz = vec3(0 ,0, S);\n\nfloat distanceToNearestSurface(vec3 p){\n    return length(p) - 1.0;\n}\n\n\n// better normal implementation with half the sample points\n// used in the blog post method\nvec3 computeSurfaceNormal(vec3 p){\n    float d = distanceToNearestSurface(p);\n    return normalize(vec3(\n        distanceToNearestSurface(p+deltax)-d,\n        distanceToNearestSurface(p+deltay)-d,\n        distanceToNearestSurface(p+deltaz)-d\n    ));\n}\n\n\n\nfloat computeLambert(vec3 p, vec3 n, vec3 l){\n    float ndotl = clamp(dot(normalize(l-p), n), 0.0, 1.0);\n    return pow(ndotl, 1.0/2.2);\t// dirty srgb\n}\n\nvec2 computeLatLong(vec3 n)\n{\n \treturn vec2(atan(n.y,sqrt(dot(n.xz, n.xz))), atan(n.z,n.x));\n}\n\nvec3 intersectWithWorld(vec3 p, vec3 dir){\n    float dist = 0.0;\n    float nearest = 0.0;\n    vec3 result = vec3(0.0);\n    for(int i = 0; i < 20; i++){\n        nearest = distanceToNearestSurface(p + dir*dist);\n        if(nearest < EPSILON){\n            vec3 hit = p+dir*dist;\n            vec3 light = vec3(100.0*sin(iTime), 30.0*cos(iTime), 50.0*cos(iTime));\n            vec3 normal = computeSurfaceNormal(hit);\n            vec2 latlon = computeLatLong(normal);\n            float lighting = computeLambert(hit, normal, light);\n            latlon.xy += iTime;\n            vec3 tex = texture(iChannel0, latlon).xyz;\n            vec3 texInv =  texture(iChannel1, latlon).xyz;\n            result =  pow(mix(tex, texInv, lighting), vec3(4.0))*4.0;\n            break;\n        }\n        dist += nearest;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n  \n    float fovy = fovx * iResolution.y/iResolution.x;\n    float ulen = tan(fovx);\n    float vlen = tan(fovy);\n\n    // generate the ray for this pixel\n    vec2 camUV = uv*2.0 - vec2(1.0, 1.0);\n    vec3 nright = normalize(cross(cameraUp, cameraDirection));\n    vec3 pixel = cameraPosition + cameraDirection + nright*camUV.x*ulen + cameraUp*camUV.y*vlen;\n    vec3 rayDirection = normalize(pixel - cameraPosition);\n    \n    vec3 pixelColour = intersectWithWorld(cameraPosition, rayDirection);\n    fragColor = vec4(pixelColour.xxx, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define STEPSIZE_SEQ 0.0\n\n// IDENTICAL CODE\n#define RADIAL 0\n#define STEPSIZE_CONFIG 0.12 * sin(iTime)\n#define STEPS 16.0\n#define STEPSIZE (((STEPSIZE_CONFIG) * pow(2.0, STEPSIZE_SEQ)) / STEPS)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 zoomUv = iMouse.xy/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvDelta = zoomUv- uv;\n    \n#if RADIAL == 1\n  \tuvDelta.xy = vec2(-uvDelta.y, uvDelta.x);\n#endif\n    \n    vec4 col = vec4(0.0, 0.0, 0.0, 0.0);\n    for(float i=0.0; i<STEPS; i += 1.0)\n    {\n    \tcol += texture(iChannel0, uv + (uvDelta * STEPSIZE * i) );\n    }\n    fragColor = col / STEPS;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define STEPSIZE_SEQ 1.0\n\n// IDENTICAL CODE\n#define RADIAL 0\n#define STEPSIZE_CONFIG 0.12 * sin(iTime)\n#define STEPS 6.0\n#define STEPSIZE (((STEPSIZE_CONFIG) * pow(2.0, STEPSIZE_SEQ)) / STEPS)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 zoomUv = iMouse.xy/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvDelta = zoomUv- uv;\n    \n#if RADIAL == 1\n  \tuvDelta.xy = vec2(-uvDelta.y, uvDelta.x);\n#endif\n    \n    vec4 col = vec4(0.0, 0.0, 0.0, 0.0);\n    for(float i=0.0; i<STEPS; i += 1.0)\n    {\n    \tcol += texture(iChannel0, uv + (uvDelta * STEPSIZE * i) );\n    }\n    fragColor = col / STEPS;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define STEPSIZE_SEQ 2.0\n\n// IDENTICAL CODE\n#define RADIAL 0\n#define STEPSIZE_CONFIG 0.12 * sin(iTime)\n#define STEPS 6.0\n#define STEPSIZE (((STEPSIZE_CONFIG) * pow(2.0, STEPSIZE_SEQ)) / STEPS)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 zoomUv = iMouse.xy/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvDelta = zoomUv- uv;\n    \n#if RADIAL == 1\n  \tuvDelta.xy = vec2(-uvDelta.y, uvDelta.x);\n#endif\n    \n    vec4 col = vec4(0.0, 0.0, 0.0, 0.0);\n    for(float i=0.0; i<STEPS; i += 1.0)\n    {\n    \tcol += texture(iChannel0, uv + (uvDelta * STEPSIZE * i) );\n    }\n    fragColor = col / STEPS;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}