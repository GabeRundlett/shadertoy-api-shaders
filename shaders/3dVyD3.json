{
    "Shader": {
        "info": {
            "date": "1603968797",
            "description": "pumpkin...pumpkin...pumpkin...",
            "flags": 40,
            "hasliked": 0,
            "id": "3dVyD3",
            "likes": 23,
            "name": "[â™ª]Pumpkin Rave",
            "published": 3,
            "tags": [
                "raymarching",
                "music",
                "halloween"
            ],
            "usePreview": 0,
            "username": "Catzpaw",
            "viewed": 1159
        },
        "renderpass": [
            {
                "code": "//---Pumpkin Rave\n// by Catzpaw 2020\n\n//Image:post effects\n\n//TEXTURE\nvec4 tx0(vec2 uv){\n    vec4 c=texture(iChannel0,uv);\n    c.g=texture(iChannel0,.99*(uv-.5)+.5).g;\n    c.r=texture(iChannel0,.98*(uv-.5)+.5).r;\n    return c;\n}\n\n//MAIN\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 uv=fragCoord/iResolution.xy;\n\t//DOF filter\n    vec2 fp=vec2(.5);\n    mat2 vel=rot(1.);\n    vec2 mul=vec2(0,iResolution.x/iResolution.y),ang=vec2(0,1)*mul;\n    vec4 acc=vec4(0,0,0,1),tgt=vec4(1),c=tx0(uv);\n    float foc=min(.6,tx0(fp).w),bok=abs(c.w-foc),rad=0.,dis=0.;\n    for(int j=ZERO;j<30;j++){\n        rad+=.03;\n        tgt=tx0(uv+ang*rad*.03);dis=tgt.w;tgt.w=1.;\n        acc+=(((dis<c.w)&&(abs(dis-foc)>=rad))||(bok>=rad))?tgt:vec4(0);\n        ang*=vel;\n    }\n    c.rgb+=acc.rgb;c/=acc.w;\n\n    //vignette\n    uv-=.5;uv.x*=mul.y;\n    c.rgb-=length(uv)*.3;\n    c.w=1.;\n    fragColor=c;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//---Pumpkin Rave\n// by Catzpaw 2020\n\n//Common:snippets\n\n#define ZERO min(0,iFrame)\n\nfloat hash(vec2 p){return fract(cos(p.x*400.)*199.7+cos(p.y*400.)*189.6);}\nmat2 rot(float a){float s=sin(a),c=cos(a);return mat2(c,s,-s,c);}\nvec3 hsv(float h,float s,float v){return ((clamp(abs(fract(h+vec3(0.,.666,.333))*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//---Pumpkin Rave\n// by Catzpaw 2020\n\n//Buffer A:animation\n\n#define ITER 96\n#define EPS 1e-4\n#define NEAR 0.5\n#define FAR 20.0\n\nvec2 fold(vec2 p,float s){float a=3.142/s-atan(p.x,p.y),n=6.283/s;p*=rot(floor(a/n)*n);return p;}\nfloat sminCubic(float a,float b,float k){float h=max(k-abs(a-b),0.)/k;return min(a,b)-h*h*h*k*(1./6.);}\nfloat sdTorus(vec3 p,vec2 t){return length(vec2(length(p.yz)-t.x,p.x))-t.y;}\nfloat sdCube(vec3 p){vec3 q=abs(p)-.5;return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.);}\nfloat sdCappedCylinder(vec3 p,float h,float r){vec2 d=abs(vec2(length(p.xz),p.y))-vec2(h,r);return min(max(d.x,d.y),0.)+length(max(d,0.));}\nfloat sdPumpkin(vec3 p){\n    p.xz=fold(p.xz,16.);\n    return sminCubic(sdTorus(p+vec3(0,0,-0.5),vec2(0.9,0.6)),\n        sdCappedCylinder(p+vec3(0,-1.6,-0.1),.1,.2+p.z*.1),.3);\n}\nfloat sdEyes(vec3 p){\n\tp.x=abs(p.x);p.z*=.25;\n    p+=vec3(-.8,-.5,.9);\n    p.xz*=rot(1.);p.xy*=rot(-.1);\n    return sdCube(p);\n}\nfloat sdMouth(vec3 p){\n\tp.x=abs(p.x);p.y*=2.5;\n    p+=vec3(-.3,1.2,1.9);\n    p.xz*=rot(-1.);p.yz*=rot(1.1);\n    return sdCube(p);\n}\nvec3 mapTrans(vec3 p){\n    float h=hash(floor(p.xz*.25));\n    p.xz=mod(p.xz,4.)-2.;\n    p.y-=abs(sin(h+iTime*7.069));\n    p.xz*=rot(h*10.+sin(h+iTime*5.585));\n    p.yz*=rot(h*.5);\n\treturn p;\n}\nfloat map(vec3 p){\n    p=mapTrans(p);\n\treturn max(-sdMouth(p),max(-sdEyes(p),sdPumpkin(p)));\n}\nvec2 material(vec3 p){\n    p=mapTrans(p);\n    p.y*=1.26;\n    return vec2(step(.5+length(p),2.4),length(p.xz));\n}\n\nconst vec2 e=vec2(EPS,-EPS);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 ro=vec3(8,10,3),rd=vec3(uv,1),ld=normalize(vec3(0,1,0.5));\n    ro.xz+=vec2(30,0)*rot(iTime*.17);\n    ro.xz+=vec2(10,0)*rot(-iTime*.37);\n    rd.yz*=rot(-.9);\n    rd.xz*=rot(iTime*.2);\n    float t=NEAR;\n    vec3 p=ro;\n    for(int i=ZERO;i<ITER;i++){\n    \tp=ro+rd*t;\n        float d=map(p);\n    \tif(abs(d)<EPS||t>FAR)break;\n        t+=step(d,.7)*d+d*.1;\n    }\n    vec3 n=normalize(e.xxx*map(p+e.xxx)+e.xyy*map(p+e.xyy)+e.yxy*map(p+e.yxy)+e.yyx*map(p+e.yyx));\n    vec2 m=material(p);\n    vec3 c=hsv(.2-smoothstep(0.3,0.5,m.y)*.15,.7,.9);\n    float s=step(0.,p.y);\n    float v=s*pow(clamp(dot(n,ld),0.,1.),2.);\n    c*=v;\n    c+=pow(clamp(dot(n,ld),0.,1.),40.);\n    ld.xy*=rot(iTime*1.3);\n\tc+=s*hsv(iTime*2.51,.9,.3)*dot(n,ld);\n    ld.yz*=rot(iTime*3.3);\n\tc+=s*hsv(iTime*.31,.5,.3)*dot(n,ld);\n    c+=vec3(1,1,0.5)*m.x*(.9+hash(uv.xy+iTime));\n\n    fragColor = vec4(c,t/FAR);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//---Pumpkin Rave\n// by Catzpaw 2020\n\n//Sound:music\n\n//---Scale Sequencer 2 by Catzpaw 2020\n//https://www.shadertoy.com/view/3tVGz3\n\n//SETUP\nconst float base =432.;\t//A tuning (Hz)\nconst float bpm  =135.;\t//beats per minute\nconst float steps=240.;\t//block length\nconst float start=1.;   //start count (beats)\nconst float fade =10.;  //fade out time (sec)\nconst float sec  =180.; //performance time (includes fade out time and start count)\nconst float gateseed=92.;\nconst float noteseed=40.;\nconst int chord3=2; //3rd tone(default:2)\nconst int chord5=4; //5th tone(default:4)\n\n//SCALE\nint key=4; //0:C 1:C+ 2:D 3:D+ 4:E 5:F 6:F+ ... 11:B\nint scale=1;\nconst uint[12] scl=uint[](\n    0xcb975420u, //0:major\n    0xca875320u, //1:natural minor\n    0xcb875320u, //2:harmonic minor\n    0xcb975320u, //3:melodic minor\n    0xa9765320u, //4:blues octatonic\n    0xa9764310u, //5:blues diminished octatonic\n    0xc9974420u, //6:major pentatonic (to heptatonic)\n    0xca775530u, //7:minor pentatonic (to heptatonic)\n    0xcb775540u, //8:ryukyu pentatonic (to heptatonic)\n    0xcb755420u, //9:ryukyu hexatonic (to heptatonic)\n    0xba875410u, //10:maqam hijaz octatonic\n    0xba876320u);//11:gypsy minor octatonic\nint scalenote(int y){\n    return y<0?-999:key+((int(scl[scale])>>(y&7)*4)&15);\n}\n\n//PATTERN\n// melodic:range(4),rest(4),seed1(12),seed2(12)\n// percussive:note(2x16)\nconst uint[32] pat=uint[](\n    0x37000000u,0x37011171u,0x47012172u,0x37011773u,  //00-   melody\n    0x37054394u,0x37054c95u,0x44226166u,0x34617167u,\n    0x34028168u,0x34019119u,0x4401a11au,0x3440417cu,  //  -0B\n    0x31001434u,0x31001491u,0x31001022u,0x31001022u,  //0C-0F backing\n    0x18510520u,0x18510530u,0x18510540u,0x18510550u,  //10-13 chord\n    0x42111112u,0x42222223u,0x42333334u,0x42444445u,  //14-17 bass\n    0x313aa13au,0x513aa186u,0x323a323au,0x5556a186u,  //18-1B sd+hh\n    0x91e121e1u,0x55e121e5u,0x4db18db1u,0x55919d55u); //1C-1F bd+conga\n\n//SEQUENCE\n// speed(4),degree1(4),pattern1(8),division(4),degree2(4),pattern2(8)\n// speed    0:0.5x 1:1x 2:2x 3:4x\n// degree   0:mute 1:I  2:II 3:III 4:IV 5:V 6:VI 7:VII\n// division 0-f ... timing to switch pattern1 to pattern2 (0:only pattern2)\nconst uint[16] seq1=uint[]( //snare+hihat\n    0x11000118u,0x11000118u,0x11000118u,0x11188119u,\n    0x11000118u,0x11000118u,0x11000119u,0x1100011bu,\n    0x11000118u,0x11000118u,0x11000118u,0x11188119u,\n    0x11000118u,0x11000118u,0x11000119u,0x1100011bu);\nconst uint[16] seq2=uint[]( //bassdrum+conga\n    0x1100011eu,0x1100011eu,0x1100011eu,0x111ee11fu,\n    0x1100011eu,0x1100011eu,0x1100011eu,0x111e811fu,\n    0x1100011eu,0x1100011eu,0x1100011eu,0x111e811fu,\n    0x1100011eu,0x1100011eu,0x1100011eu,0x1100011fu);\nconst uint[16] seq3=uint[]( //bass\n    0x01000414u,0x01000114u,0x01000514u,0x01000116u,\n    0x01000114u,0x01000414u,0x01000514u,0x01000717u,\n    0x01000615u,0x01000415u,0x01000515u,0x01000116u,\n    0x01000615u,0x01000415u,0x01000515u,0x01000717u);\nconst uint[16] seq4=uint[]( //chord\n    0x11000410u,0x11000110u,0x11000510u,0x11000112u,\n    0x11000410u,0x11000110u,0x11000510u,0x11000713u,\n    0x11000610u,0x11000410u,0x11000510u,0x11000112u,\n    0x11000610u,0x11000410u,0x11000510u,0x11000713u);\nconst uint[16] seq5=uint[]( //backing\n    0x0100040cu,0x0100010cu,0x0100050cu,0x090d810eu,\n    0x0100040cu,0x0100010cu,0x0100050cu,0x010d870fu,\n    0x0100060du,0x0100040cu,0x0100050du,0x070d810eu,\n    0x0100060du,0x0100040cu,0x0100050du,0x010d870fu);\nconst uint[16] seq6=uint[]( //melody\n    0x11000401u,0x11000102u,0x11000503u,0x11000104u,\n    0x11000401u,0x11000102u,0x11000503u,0x11000705u,\n    0x11000606u,0x11000407u,0x11000508u,0x11000109u,\n    0x11000606u,0x11000407u,0x1100050Au,0x1100070Bu);\n\n//BIT OPERATION\nint imod(int x,int y){return int(x-y*(x/y));}\nint imod(uint x,uint y){return int(x-y*(x/y));}\nint get12(uint b,int l){return int(b>>l*4)&4095;}\nint get8(uint b,int l){return int(b>>l*4)&255;}\nint get4(uint b,int l){return int(b>>l*4)&15;}\nint get2(uint b,int l){return int(b>>l*2)&3;}\n\n//NES SOUND GENERATORS(without DPCM)\nfloat osc_duty(float x,float d){return fract(x)<d?1.:-1.;}\nfloat osc_tri4(float x){return abs(floor(fract(x)*15.9999)/7.5-1.);}\nconst float[16] nt=float[](2.,4.,8.,16.,32.,48.,64.,80.,101.,127.,190.,254.,381.,508.,1017.,2034.);\nfloat osc_nesnoise(float x,int i){return fract(sin(floor(x*1789772.5/nt[i])*179.2)*204.8);}\n\n//WAVETABLE OSC(namco C30/N163)\n//sound0:flute  ADFF DA75 4456 9ABB A852 0025\n//sound1:brass  BFED ED93 0378 78CF C621 2104\n//sound2:organ  87D7 F7F7 D7A7 8582 8080 8287\n//sound3:piano  BEFF EBA9 9998 7666 6541 0014\n//sound4:harpsi BDEF 000F EDB9 6421 0fff 0124\n//sound5:bass   0033 2266 0033 CCFF 99DD CCFF\n//sound6:octsqr 0000 00AA AAAA 5555 55FF FFFF\n//sound7:octsaw 0123 4567 89AB 4567 89AB CDEF\nconst uint[24] wt=uint[](\n    0x000bb8bau,0x100de7fdu,0x203efdefu,0x303ff7dfu,0x4020efedu,0x5020b7dau,0x6a60af97u,0x7a6f9735u,\n    0x8a0e9d04u,0x9a0d9734u,0xaa3b9a75u,0xba398786u,0x45c67879u,0x55c4658au,0x65f268cbu,0x75f162fbu,\n    0x859068cau,0x959f5068u,0xafdf4825u,0xbfdf1012u,0xcfc00820u,0xdfc10210u,0xeff21802u,0xfff44745u);\nfloat osc_c30(float x,int i){return(float((wt[int(mod(x*24.,24.))]>>(i*4))&15u)/15.-.5);}\n\n//AMP\n//  vec3 p( drive, pressure, volume)\nvec2 amp(vec2 i,vec3 p){return clamp(sign(i)*pow(abs(i*p.x),vec2(1./p.y)),-1.,1.)*p.z;}\n\n//FREQUENCY FROM MIDI NOTE NUMBER\nfloat freq(float n){return pow(2.,(n-69.)/12.)*base;}\n\n//ENVELOPE\nfloat env_d(float x,float d){return max(0.,1.-x/max(d,1e-4));}\n\n//CHIPTUNE INSTRUMENTS (freq,time)\nconst float detune =.0025;\nvec2 dutybass(float f,float x){return vec2(osc_duty(f*(.5+detune),.5),osc_duty(f*(.5-detune),.5))*env_d(x,.5);}\nvec2 tri4bass(float f,float x){return vec2(osc_tri4(f*(.5+detune)),osc_tri4(f*(.5-detune)));}\nvec2 tri4lead(float f,float x){return vec2(osc_tri4(f*(1.-detune)),osc_tri4(f*(1.+detune)));}\nvec2 c30bass(float f,float x){return vec2(osc_c30(f*(1.+detune),5),osc_c30(f*(1.-detune),5))*env_d(x,.5);}\nvec2 c30chord(float f,float x){return vec2(osc_c30(f*(1.-detune),6),osc_c30(f*(1.+detune),6));}\nvec2 c30bell(float f,float x){return vec2(osc_c30(f*(1.-detune),1),osc_c30(f*(1.+detune),1))*env_d(x,.6);}\nvec2 c30lead(float f,float x){return vec2(osc_c30(f*(1.-detune),2),osc_c30(f*(1.+detune),2))*env_d(x,.5);}\n\n//CHIPTUNE PERCUSSION (time)\nfloat nessd(float x){return osc_nesnoise(x,11)*env_d(x,.2);}\nfloat neshh(float x,float d){return osc_nesnoise(x,0)*env_d(x,d);}\nfloat nesbd(float x){return osc_duty(3./(x*.5+.1),.5)*env_d(x,.2);}\nfloat neslc(float x){return osc_duty(10./(x*.3+.1),.25)*env_d(x,.05);}\nfloat neshc(float x){return osc_duty(12./(x*.3+.1),.25)*env_d(x,.05);}\n\n//GET PATTERN FROM SEQUENCE\nfloat mp=0.; //note length multiplier(from speed)\nint   dg=0;  //degree now playing\nuint  pt=0u;  //pattern now playing\nint   st=0;  //step now playing\nbool getpattern(float t,uint sq){\n    // speed(4),degree1(4),pattern1(8),division(4),degree2(4),pattern2(8)\n    mp=pow(2.,float(get4(sq,7)-1))*16.;\n    st=int(mod(t*bpm*mp/steps,16.));\n    bool di=int(mod(t*bpm*16./steps,16.))<get4(sq,3);\n    dg=di?get4(sq,6):get4(sq,2);\n    pt=di?pat[get8(sq,4)]:pat[get8(sq,0)];\n    return dg==0?false:true;\n}\n\n//GET NOTE FROM PATTERN\nint notegen(int s,int s1,int s2){\n    return fract(sin(float(s+s1)+float(s1*20)*gateseed)*50.)<(float(get4(pt,6))*.0625)?-1:\n    imod(int(abs(sin(float(s+s1+s*s2)*noteseed)*float(s2))),get4(pt,7));\n}\nvec4 getnote(float t,float l){\n    // melodic:range(4),rest(4),seed1(12),seed2(12)\n    int s1=get12(pt,3),s2=get12(pt,0),n=notegen(st,s1,s2);\n    float x=mod(t,l/mp);\n    if((st>=1)&&(n<0)){n=notegen(st-1,s1,s2);x+=l/mp;}\n    n+=n<0?0:dg-1;\n    return (dg<1)||(n<0)?vec4(x,-1,-1,-1):vec4(x,scalenote(n),scalenote(n+chord3),scalenote(n+chord5));\n}\nvec4 getgate(float t,float l){\n    // percussive:note(2x16)\n    int n=get2(pt,st);\n    float x=mod(t,l/mp);\n    if((st>=1)&&(n==0)){n=get2(pt,st-1);x+=l/mp;}\n    return dg<1?vec4(x,-1,-1,-1):vec4(x,n,n,n);\n}\n\n//RENDERER\nvec2 track1(float t,float l,int s){//TRACK 1 NES noise snaredrum,closehh,openhh\n    vec2 o=vec2(0);\n    getpattern(t,seq1[imod(s,16)]);\n    vec4 n=getgate(t,l);\n    o+=(n.y==1.)?nessd(n.x)*.8:0.;\n    o+=(n.y==2.)?neshh(n.x,.08)*.4:0.;\n    o+=(n.y==3.)?neshh(n.x,.2)*.5:0.;\n    return o;\n}\nvec2 track2(float t,float l,int s){//TRACK 2 NES sqr bassdrum,lowconga,highconga\n    vec2 o=vec2(0);\n    getpattern(t,seq2[imod(s,16)]);\n    vec4 n=getgate(t,l);\n    o+=(n.y==1.)?nesbd(n.x)*.6:0.;\n    o+=(n.y==2.)?neslc(n.x)*.3:0.;\n    o+=(n.y==3.)?neshc(n.x)*.3:0.;\n    return o;\n}\nvec2 track3(float t,float l,int s){//TRACK 3 NES sqr bass\n    vec2 o=vec2(0);\n    getpattern(t,seq3[imod(s,16)]);\n    vec4 n=getnote(t,l);\n    o+=(n.y>=0.)?dutybass(freq(n.y+36.)*n.x,n.x)*.35:vec2(0);\n    return o;\n}\nvec2 track4(float t,float l,int s){//TRACK 4 N163 chord\n    vec2 o=vec2(0);\n    getpattern(t,seq4[imod(s,16)]);\n    vec4 n=getnote(t,l);\n    o+=(n.y>=0.)?c30chord(freq(n.y+60.03)*n.x,n.x)*.25:vec2(0);\n    o+=(n.y>=0.)?c30chord(freq(n.z+60.02)*n.x,n.x)*.25:vec2(0);\n    o+=(n.y>=0.)?c30chord(freq(n.w+60.01)*n.x,n.x)*.25:vec2(0);\n    return o;\n}\nvec2 track5(float t,float l,int s){//TRACK 5 N163 backing\n    vec2 o=vec2(0);\n    getpattern(t,seq5[imod(s,16)]);\n    vec4 n=getnote(t,l);\n    o+=(n.y>=0.)?c30bell(freq(n.y+72.05)*n.x,n.x)*.3:vec2(0);\n    return o;\n}\nvec2 track6(float t,float l,int s){//TRACK 6 N163 & NES tri melody\n    vec2 o=vec2(0);\n    getpattern(t,seq6[imod(s,16)]);\n    vec4 n=getnote(t,l);\n    o+=(n.y>=0.)?c30lead(freq(n.y+48.05)*n.x,n.x)*.6+tri4lead(freq(n.y+60.)*n.x,n.x)*.6:vec2(0);\n    return o;\n}\nvoid render(float t,float l,inout vec2 o,bool e){\n    float c=0.;       //render target\n    int   s=int(t/l); //sequence number now playing\n    vec4  n=vec4(0);  //chord info x:gate yzw:notes\n    o+=e?track1(t,l,s):vec2(0); //TRACK 1 snaredrum,closehh,openhh\n    o+=  track2(t,l,s);         //TRACK 2 bassdrum,lowconga,hiconga\n    o+=e?track3(t,l,s):vec2(0); //TRACK 3 bass\n    o+=  track4(t,l,s);         //TRACK 4 chord\n    o+=  track5(t,l,s);         //TRACK 5 backing\n    o+=  track6(t,l,s);         //TRACK 6 melody\n}\n\n//MASTER SECTION\n#define MASTER_DRIVE    0.4\n#define MASTER_PRESSURE 1.0\n#define DELAY_REPEAT    5\n#define DELAY_WET       0.3\n#define DELAY_FEEDBACK  0.9\n#define DELAY_TIME      0.2\nfloat mvol=0.; //for indicator\nvec2 mainSound( in int samp,float time){\n    float l=steps/bpm,vol=1.,d=DELAY_WET,r=DELAY_TIME;\n    vec2 o=vec2(0);\n    if(time>sec-fade){vol=(sec-min(time,sec))/fade;}\n    time-=start*60./bpm;\n    if(time<0.)return o;\n    render(time,l,o,true);\n    for(int i=0;i<DELAY_REPEAT;i++){\n        time-=r;\n        if(time<0.)continue;\n        vec2 a=vec2(0);\n        render(time,l,a,false);\n        d*=DELAY_FEEDBACK;\n        r+=DELAY_TIME;\n        o+=a*d;\n    }\n    mvol=vol;\n    return amp(o,vec3(MASTER_DRIVE,MASTER_PRESSURE,vol));\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}