{
    "Shader": {
        "info": {
            "date": "1664979702",
            "description": "combination of newton's method for z^3-1 and good ol' z^2+c makes very pleasing black and white figures,  CLICK and DRAG the MOUSE to take over  control yourself.  Uncomment the #define to see where mipmap LOD2==LOD0 ",
            "flags": 32,
            "hasliked": 0,
            "id": "slGfRc",
            "likes": 6,
            "name": "inside out newton",
            "published": 3,
            "tags": [
                "julia",
                "newton"
            ],
            "usePreview": 0,
            "username": "pb",
            "viewed": 240
        },
        "renderpass": [
            {
                "code": "//philip.bertani@gmail.com\n//CLICK and DRAG the MOUSE - see Buffer A\n//still need this blur to smoooth out the edges\n\nfloat[] gkhs = float[] (\n        0.000002,0.000212,0.000922,0.000212,0.000002,\n        0.000212,0.024745,0.107391,0.024745,0.000212,\n        0.000922,0.107391,0.466066,0.107391,0.000922,\n        0.000212,0.024745,0.107391,0.024745,0.000212,\n        0.000002,0.000212,0.000922,0.000212,0.000002 );\n        \n//#define SEE_LOD0_LOD2      \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )  \n//seems like mipmap level 1 does just a good job as this averaging loop\n//actually not - need to do more to make mipmap work out\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    //size of one texel in iChannel0\n    vec2 texel = 1./iResolution.xy;\n    vec4 total_color = vec4(0);\n    \n    vec4 currentPixelLOD0 = texture(iChannel0,uv,0.);\n    if ( currentPixelLOD0!=texture(iChannel0,uv,2.) ) {\n      for (int i=0;i<5;i++){\n        float fi = float(i)-2.;\n        for (int j=0;j<5;j++){ \n            float fj = float(j)-2.;\n            vec4 color = texture(iChannel0, \n                uv + vec2( texel.x*fi,texel.y*fj ) , 0. );\n            total_color += color * gkhs[i*5 + j];\n        }\n      }    \n    }\n    else { \n#ifdef SEE_LOD0_LOD2 \n            total_color = vec4(1.,0.,0.,1.); \n#else            \n            total_color = currentPixelLOD0;\n#endif\n     }\n    fragColor = sqrt(total_color);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//philip.bertani@gmail.com\n//Newton's method for z^3-1 combined with regular julia set for z^2+c\n#define too_small 1e-6\n#define Infinity 1e4\nvec2 newtonjulia(vec2 z, vec2 c, float wgt) {  //mix of newton's method and z^2+c\n  vec2 zz = z; float xy = z.x*z.y; zz*=zz; \n  vec2 julia = vec2(zz.x-zz.y, 2.*xy) ;\n  xy*=xy;  //need xy^2 \n  zz*=zz;  //need x^4 and y^4\n  float modz2 = max( zz.x+zz.y+2.*xy, too_small);\n  //following is z - (z^3-1)/3z^2 all multiplied out using complex numbers  \n  vec2 newt = vec2( 2.*(zz.x*z.x + 2.*z.x*xy + z.x*zz.y) + c.x*julia.y ,\n                    2.*(zz.y*z.y + 2.*z.y*xy + z.y*zz.x) + c.x*julia.x   );\n  newt /= (3.*modz2);\n  julia += c;  //we needed julia without the c in newt first\n  return wgt*newt + (1.-wgt)*julia;   \n}\nvoid mainImage( out vec4 rgba, in vec2 uv )\n{\n  uv = (2.*uv - iResolution.xy)/iResolution.y;\n  vec2 mm = (2.*iMouse.xy - iResolution.xy)/iResolution.y;\n  if ( iMouse.w==0. ) { mm.x=-.5;mm.y=-.4*(1.-sin((iTime+22.)/5.));}\n  vec2 c = mm*3.; c.x=.1+c.x/100.;\n  vec2 z=(uv)*4000., newz=vec2(0); \n  float modz = max(z.x*z.x+z.y*z.y,too_small); \n  z /= modz; //invert in unit circle\n  float escape_value=0., wgt=1.03;  //change wgt around to get more variations\n  for (float i=0.; i<27.; i++){\n    newz = newtonjulia(z,c,wgt);\n    if (dot(newz,newz)>Infinity) { escape_value=i; break;}\n    z=newz;\n  }\n  vec2 lz = vec2(0);\n  if ( escape_value == 0. ) lz = cos(log(abs(newz)));\n  if ( dot(lz,lz) > .5 ) rgba=vec4(1.); else rgba = vec4(0.);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}