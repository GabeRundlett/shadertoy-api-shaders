{
    "Shader": {
        "info": {
            "date": "1579298405",
            "description": "Code is messy,  might clean it up later.\n\nWent for a tech-y vibe with this one, ended up kind-of Shane-ish.\n\n\n",
            "flags": 0,
            "hasliked": 0,
            "id": "3tG3RK",
            "likes": 15,
            "name": "Day 29 - Dwarf Train",
            "published": 3,
            "tags": [
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 584
        },
        "renderpass": [
            {
                "code": "#define mx (200.*iMouse.x/iResolution.x)\n#define dmin(a, b) a.x < b.x ? a : b\n#define dmax(a, b) a.x > b.x ? a : b \n#define pmod(p, x) mod(p, x) - x*0.5\n\nfloat r11c(float x){return texture(iChannel0, vec2(x, x*12.5)).x;}\n\nvec2 offsetTunnel(float z){\n    vec2 t = vec2(\n        sin(z*0.1)*2.,\n        cos(z*0.1)*2.\n    );\n    t.y -= 0.;\n\treturn t;\n}\n\n#define szTunnel 1.\n\n#define szLamp 0.08\n#define lenLamp 0.24\nvec2 sdLamp(vec3 p){\n\tvec2 d = vec2(sdCapsule( p, vec3(0,0,lenLamp), vec3(0.0), szLamp ), 2.); \n    \n    return d;\n} \n\n#define modDist 10.\n\nvec3 centerPipes = vec3(0);\nvec3 centerTunnel = vec3(0);\n\n\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e7);\n\n    p.xy -= offsetTunnel(p.z);\n    \n    // --- TUNN --- //\n    \n    centerTunnel = p;\n    d = dmin(d, vec2(-(length(p.xy) - szTunnel), 0.));\n    \n    \n    \n    vec3 q = p;\n    q.x = abs(q.x);\n    q.y = abs(q.y);\n    //p.y -= szTunnel;\n    \n    q.xy -= vec2(cos(0.5),sin(0.5))*szTunnel;\n    \n    \n    \n    \n    // --- PIPES --- //\n    \n    centerPipes = q;\n    d = dmin(d, vec2((length(q.xy) - 0.1), 1.));\n    \n    q.z = pmod(q.z,1.);\n    d = dmin(d, vec2(max((length(q.xy) - 0.12), -abs(q.z) + 0.3 ), 1.));\n\t\n    \n    // --- LAMP --- //\n    float id = floor(p.z/modDist);\n    p.z = pmod(p.z, modDist);\n    q = p;\n    q.y -= szTunnel*1.;\n    q.z += lenLamp*1.;\n    //q.z -= 1.;\n    //d = dmin(d, sdLamp(q));\n    d = dmin(d, vec2(sdCapsule( q, vec3(0,0,lenLamp), vec3(0.0), szLamp ), 2.));\n    //q.y += 0.9;\n    q.z -= szLamp*3.;\n    \n    float z = q.z;\n    \n    q.z = pmod(q.z, 0.14); \n    \n    q.y -= smoothstep(0., 0.8, pow(length(z*0.29)*4.5, 3.)); // function drawing\n    q.yz *= rot(0.5*pi);\n\n    // lamp thingie\n    d = dmin(d, vec2(0.61*sdTorus(q, vec2(0.10,0.015)), 4.));\n    // --- FLOOR --- //\n    float offsFloor = szTunnel*0.76;\n    p.y += offsFloor;\n    d = dmin(d, vec2(p.y , 0.));\n    \n    // --- TRAIN --- //\n    float offsTrain = szTunnel*0.25;\n    q = p;\n    p.x = abs(p.x);\n    p.x -= offsTrain*1.3;\n    \n    p.y -= 0.1;\n    vec3 i = abs(p);\n    i -= 0.01;\n    float sm = length(max(i.y,0.0)) + min(max(i.x,max(i.y,i.z)),0.1) - 0.1;\n    //d = dmin(d, vec2(sm, 5.));\n    d = dmin(d, vec2(max(abs(p.y) - 0.04, abs(p.x) - 0.04), 5.));\n    \n    q.z = pmod(q.z, 0.5);\n    q.y += 0.05;\n\td = dmin(d, vec2(max(abs(q.y) - 0.1, max(abs(q.z) - 0.1, abs(q.x) - 0.54)) , 4.));\n    \n    \n    d.x *= 0.9;\n\treturn d;\n}\nvec3 pLamp;\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique )\n{\n    technique = 1;\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<212; i++ )\n    {\n        vec2 d = map( ro + rd*t );\n        \n        //d.x -= texture(iChannel3, vec2(float(i))).x*0.002;\n\t\tfloat h = d.x;\n\t\t//h *=  0.7*exp(-h*2.);\n        //h *= 1. - exp(-h*0.01)*0.6;\n        //h *= 0.3 + exp(-length((ro.y + rd.y*t) - abs(pLamp.y))*20.)*0.7; // TODO: fix this so it's faster\n        \n        \n        if (d.y == 2. ) {\n            h += 0.3;\n        }\n        \n        // traditional technique\n        if( technique==0 )\n        {\n        \tres = min( res, 10.0*h/t );\n        }\n        // improved technique\n        else\n        {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n            float y = h*h/(2.0*ph);\n            float di = sqrt(h*h-y*y);\n            res = min( res, 10.*di/max(0.,t-y) );\n            ph = h;\n        \n\n        }\n        \n        t += h;\n        \n        if( res<0.005 || t>tmax ) break;\n          \n    }\n    //res *= 5.4;\n    return clamp( res, .0, 1.0 );\n}\n\n\n\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.0005, 0.);\n    return normalize(\n    \tmap(p).x - vec3(\n        \tmap(p - t.xyy).x,\n        \tmap(p - t.yxy).x,\n        \tmap(p - t.yyx).x\n        )\n    );\n}\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n\tvec3 right = normalize(cross(vec3(0,1,0), dir));\n\tvec3 up = normalize(cross(dir, right));\n\treturn dir + right*uv.x + up*uv.y;\n}\n\nvec3 colLight = vec3(0.6,0.34,0.22)*2.2;\n\nvec3 glow = vec3(0);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0,0,-0.);\n    ro.z += iTime*5. + mx;\n    ro.xy += offsetTunnel(ro.z);\n    \n    vec3 lookAt = ro + vec3(0,0,9);\n    lookAt.xy += offsetTunnel(lookAt.z);\n    \n    vec3 rd = getRd(ro, lookAt, uv);\n    vec3 p = ro; float t = 0.;vec2 d; vec3 l = vec3(0); bool didHit = false; float att = 0.;\n    for(int i = 0; i < 270; i++){\n    \td = map(p);\n        if (d.y == 2.  ){\n        \tglow += exp(-d.x*4.);\n        }\n        \n        if(d.x < 0.001){\n            didHit = true;\n            float id = floor(p.z/modDist);\n            pLamp = vec3(0,szTunnel*1.,id*modDist + modDist*0.5 );\n            pLamp.xy += offsetTunnel(pLamp.z);\n            //pLamp.y += 0.001;\n            att = 1.5/(length(p-pLamp),length(p-pLamp));\n            \n           \n\t\t\tvec3 n = getNormal(p);\n            l = normalize(pLamp - p);\n\t\t\tvec3 h = normalize(l - rd);\n            float diff = max(dot(n,l),0.);\n            float fres = pow(1. - max(dot(n,-rd),0.), 5.);\n            float spec = max(dot(n,h),0.);\n        \t//spec = pow(spec,4.);\n            float q = atan(p.y, p.x); // polar coords\n                \n            //q /= tau;\n            q *= 1.;\n            \n            if (d.y == 0. || d.y == 1.){\n                vec3 tex;\n                if (d.y == 0.){\n                \ttex = tex3D(iChannel1, p*0.7,n).xyz;\n                } else {\n                    p.xy *= rot(p.z*0.2);\n                \ttex = tex3D(iChannel2, p*5.,n).xyz;\n                    tex = pow(tex, vec3(0.7));\n                    tex.gb *= 1.2;\n                    tex *= 0.1;\n                }\n                n.z += pow(tex.x*1.6, 4.)*0.2;\n                diff = max(dot(n,l),0.);\n                fres = pow(1. - max(dot(n,-rd),0.), 2.);\n                spec = max(dot(n,h),0.);\n                spec = pow(spec, 2.);\n                col += mix(tex*diff*colLight*fres,tex*fres*spec*colLight,0.8 - length(tex.rg)*0.8) * (att);\n                \n            } else if (d.y == 2. || d.y == 3.){\n            \t//col += fres*diff;\n                //col += diff;\n            \t//col += mix(diff,fres*spec,0.9) * (att);\n                col = colLight*pow(1. , 2.)*att;\n            } else if (d.y == 4.){\n                vec3 tex = tex3D(iChannel1, p*0.7,n).xyz;\n                \n                tex.x *= 1.;\n                tex.y *= 0.54;\n                tex.z *= 0.4;\n                tex.x = tex.y;\n            \t\n            \tcol += mix(tex*diff*colLight,tex*fres*spec*colLight,0.1 + min(tex.r*1., 1.)) * (att);\n            } else if (d.y == 5.){\n                //vec3 tex = texture(ichanne, -n).xyz;\n                vec3 tex = tex3D(iChannel1, p*0.7,n).xyz;\n                \n                tex.x *= 1.;\n                tex.y *= 1.;\n                tex.z *= 1.;\n                tex.x = tex.y;\n                tex.y = tex.x;\n            \t\n                col += mix(tex*diff*colLight,tex*fres*pow(spec, 1.5)*colLight,0.9) *att;\n            \t//col += * (att);\n            \n            }\n            \n            \n        \tbreak;\n        }\n        \n        t += d.x;\n        p = ro + rd*t;\n    }\n    \n    float shad = calcSoftshadow(p, l, 0.01, 100., 0 );\n    col *= shad*att;\n\t\n    \n    col *= 4.;\n    //col *= 3.;\n    \n    col += glow*0.004*colLight;\n    //col -= glow*0.5*colLight*(1. - att);\n    \n    col = pow(col, vec3(0.45));\n    col *= 1.5;\n    //col = smoothstep(0.,0.6,col);\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 48,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define c0 iChannel0 \n#define c1 iChannel1 \n#define c2 iChannel2 \n#define c3 iChannel3 \n\n#define T(c, uv) texture(c, uv)\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n// thx to iq\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n   \n    n = max((abs(n) - .2)*7., .001);\n    n /= (n.x + n.y + n.z );  \n    \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    \n    return p*p;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}