{
    "Shader": {
        "info": {
            "date": "1593400877",
            "description": "Heart SDF\n\n",
            "flags": 0,
            "hasliked": 0,
            "id": "ttfcDl",
            "likes": 1,
            "name": "SDF Heart",
            "published": 3,
            "tags": [
                "sdf",
                "heart"
            ],
            "usePreview": 0,
            "username": "ianwall",
            "viewed": 352
        },
        "renderpass": [
            {
                "code": "float sdCircle( in vec2 p, in float r ) \n{\n    return length(p)-r;\n}\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p);\n\n    float h = clamp( (-2.0*ndot(q,b) + ndot(b,b) )/dot(b,b), -1.0, 1.0 );\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    d *= sign( q.x*b.y + q.y*b.x - b.x*b.y );\n    \n\treturn d;\n}\n\n// sca is the sin/cos of the orientation\n// scb is the sin/cos of the aperture\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb )\n{\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n#define PI 3.1415926\nfloat sdHeart(in vec2 p, in float radius) {\n\tfloat offset = 3.0-2.0*sqrt(2.0);\n\tfloat extra = 0.05;\n\tvec2 center = vec2(0.0, offset+extra);\n    float r = 1.0-center.y;\n    \n    // Construct the heart in normalized coordinates where radius of inner circle is 1.0\n\tvec2 _p = (p/radius)*r+center;\n    \n    float br = sqrt(2.0)/2.0;\n    float d = sdRhombus( _p, vec2(1.0) );\n\tfloat dc1 = sdCircle( _p-vec2(0.5, 0.5), br );\n\tfloat dc2 = sdCircle( _p-vec2(-0.5, 0.5), br );\n\n/*\n\tif(dc1 < 0.0 && d < 0.0)\n        d = min(d, -sdArc(_p-vec2(0.5, 0.5), vec2(sin(3.0*PI/4.0), cos(3.0*PI/4.0)), vec2(sin(PI/2.0), cos(PI/2.0)), br, 0.0));\n    else\n        d = min(d, dc1);\n                      \n    if(dc2 < 0.0 && d < 0.0)\n        d = min(d, -sdArc(_p-vec2(-0.5, 0.5), vec2(sin(PI/4.0), cos(PI/4.0)), vec2(sin(PI/2.0), cos(PI/2.0)), br, 0.0));\n    else\n        d = min(d, dc2);\n*/\n\n    d = min(min(d,dc1),dc2);\n\tif(_p.y < 0.0) d += 1.5*abs(_p.x)*abs(_p.y)*abs(_p.y)*r*r\n        ; // pull the sides of the heart inward\n\n    // Fix scaling\n    return d*radius/r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\tp /= 0.75;\n\t\n    float radius = 0.7 + 0.1*sin(10.0*iTime);\n    float d = sdHeart(p, radius);\n    \n    vec3 col = sign(-d)*vec3(1.0,0.0,0.0);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.010,abs(d)));\n\n    //col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.010,abs(sdCircle(p, 0.01))));\n    //col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.010,abs(sdCircle(p, radius))));\n    //col *= 0.8 + 0.2*cos(128.0*abs(d));\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}