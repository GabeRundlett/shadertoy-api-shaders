{
    "Shader": {
        "info": {
            "date": "1362517016",
            "description": "Simulates Chromatic Aberration by linearly interpolating blur-weights from red to green to blue.\nOriginal idea by Kusma: https://github.com/kusma/vlee/blob/master/data/postprocess.fx",
            "flags": 0,
            "hasliked": 0,
            "id": "XssGz8",
            "likes": 148,
            "name": "post: Barrel Blur Chroma",
            "published": 3,
            "tags": [
                "chroma",
                "blur",
                "filter",
                "post",
                "abberation"
            ],
            "usePreview": 1,
            "username": "hornet",
            "viewed": 13426
        },
        "renderpass": [
            {
                "code": "// To the extent possible under law,\n// the author has waived all copyright and related or neighboring rights to this work.\n\nfloat remap01( float t, float a, float b ) {\n\treturn clamp( (t - a) / (b - a), 0.0, 1.0 );\n}\nvec2 remap01( vec2 t, vec2 a, vec2 b ) {\n\treturn clamp( (t - a) / (b - a), 0.0, 1.0 );\n}\n\n//float linterp( float t ) {\n//\treturn clamp( 1.0 - abs( 2.0*t - 1.0 ), 0.0, 1.0 );\n//\n\n\n//note: input [0;1]\nvec3 spectrum_offset_rgb( float t )\n{\n    //note: optimisation from https://twitter.com/Stubbesaurus/status/818847844790575104\n    //t = 3.0 * t - 0.5;\n\t//vec3 ret = clamp( vec3(1.0-t, 1.0-abs(t-1.0), t-1.0), 0.0, 1.0);\n    float t0 = 3.0 * t - 1.5;\n\tvec3 ret = clamp( vec3( -t0, 1.0-abs(t0), t0), 0.0, 1.0);\n\n    //note: old crappy code\n\t//vec3 ret;\n\t//float lo = step(t,0.5);\n\t//float hi = 1.0-lo;\n\t//float w = linterp( remap( t, 1.0/6.0, 5.0/6.0 ) );\n\t//ret = vec3(lo,1.0,hi) * vec3(1.0-w, w, 1.0-w);\n    \n    //ret = pow( ret, vec3(1.0/2.2) );\n    //ret = smoothstep( vec3(0.0), vec3(1.0), ret );\n    return ret;\n}\n\nconst float gamma = 2.2;\nvec3 lin2srgb( vec3 c )\n{\n    return pow( c, vec3(gamma) );\n}\nvec3 srgb2lin( vec3 c )\n{\n    return pow( c, vec3(1.0/gamma));\n}\n\n\nvec3 yCgCo2rgb(vec3 ycc)\n{\n    float R = ycc.x - ycc.y + ycc.z;\n\tfloat G = ycc.x + ycc.y;\n\tfloat B = ycc.x - ycc.y - ycc.z;\n    return vec3(R,G,B);\n}\n\nvec3 spectrum_offset_ycgco( float t )\n{\n\t//vec3 ygo = vec3( 1.0, 1.5*t, 0.0 ); //green-pink\n    //vec3 ygo = vec3( 1.0, -1.5*t, 0.0 ); //green-purple\n    vec3 ygo = vec3( 1.0, 0.0, -1.25*t ); //cyan-orange\n    //vec3 ygo = vec3( 1.0, 0.0, 1.5*t ); //brownyello-blue\n    return yCgCo2rgb( ygo );\n}\n\nvec3 yuv2rgb( vec3 yuv )\n{\n    vec3 rgb;\n    rgb.r = yuv.x + yuv.z * 1.13983;\n    rgb.g = yuv.x + dot( vec2(-0.39465, -0.58060), yuv.yz );\n    rgb.b = yuv.x + yuv.y * 2.03211;\n    return rgb;\n}\n\n\n// ====\n\n//note: from https://www.shadertoy.com/view/XslGz8\nvec2 radialdistort(vec2 coord, vec2 amt)\n{\n\tvec2 cc = coord - 0.5;\n\treturn coord + 2.0 * cc * amt;\n}\n\n// Given a vec2 in [-1,+1], generate a texture coord in [0,+1]\nvec2 barrelDistortion( vec2 p, vec2 amt )\n{\n    p = 2.0 * p - 1.0;\n\n    /*\n    const float maxBarrelPower = 5.0;\n\t//note: http://glsl.heroku.com/e#3290.7 , copied from Little Grasshopper\n    float theta  = atan(p.y, p.x);\n    vec2 radius = vec2( length(p) );\n    radius = pow(radius, 1.0 + maxBarrelPower * amt);\n    p.x = radius.x * cos(theta);\n    p.y = radius.y * sin(theta);\n\n\t/*/\n    // much faster version\n    //const float maxBarrelPower = 5.0;\n    //float radius = length(p);\n    float maxBarrelPower = sqrt(5.0);\n    float radius = dot(p,p); //faster but doesn't match above accurately\n    p *= pow(vec2(radius), maxBarrelPower * amt);\n\t/* */\n\n    return p * 0.5 + 0.5;\n}\n\n//note: from https://www.shadertoy.com/view/MlSXR3\nvec2 brownConradyDistortion(vec2 uv, float dist)\n{\n    uv = uv * 2.0 - 1.0;\n    // positive values of K1 give barrel distortion, negative give pincushion\n    float barrelDistortion1 = 0.1 * dist; // K1 in text books\n    float barrelDistortion2 = -0.025 * dist; // K2 in text books\n\n    float r2 = dot(uv,uv);\n    uv *= 1.0 + barrelDistortion1 * r2 + barrelDistortion2 * r2 * r2;\n    //uv *= 1.0 + barrelDistortion1 * r2;\n    \n    // tangential distortion (due to off center lens elements)\n    // is not modeled in this function, but if it was, the terms would go here\n    return uv * 0.5 + 0.5;\n}\n\nvec2 distort( vec2 uv, float t, vec2 min_distort, vec2 max_distort )\n{\n    vec2 dist = mix( min_distort, max_distort, t );\n    //return radialdistort( uv, 2.0 * dist );\n    //return barrelDistortion( uv, 1.75 * dist ); //distortion at center\n    return brownConradyDistortion( uv, 75.0 * dist.x );\n}\n\n// ====\n\nvec3 spectrum_offset_yuv( float t )\n{\n\t//vec3 yuv = vec3( 1.0, 3.0*t, 0.0 ); //purple-green\n    //vec3 yuv = vec3( 1.0, 0.0, 2.0*t ); //purple-green\n    vec3 yuv = vec3( 1.0, 0.0, -1.0*t ); //cyan-orange\n    //vec3 yuv = vec3( 1.0, -0.75*t, 0.0 ); //brownyello-blue\n    return yuv2rgb( yuv );\n}\n\nvec3 spectrum_offset( float t )\n{\n  \treturn spectrum_offset_rgb( t );\n   \t//return srgb2lin( spectrum_offset_rgb( t ) );\n    //return lin2srgb( spectrum_offset_rgb( t ) );\n\n    //return spectrum_offset_ycgco( t );\n    //return spectrum_offset_yuv( t );\n}\n\n// ====\n\n/*\nfloat nrand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n*/\n\nvec3 render( vec2 uv )\n{\n    #define DEBUG\n    #if defined( DEBUG )\n    if ( uv.x > 0.7 && uv.y > 0.7 )\n    {\n        float d = length( vec2(0.77)- uv );\n        d = min( d, length( vec2(0.82)- uv ) );\n        d = min( d, length( vec2(0.875)- uv ) );      \n        return vec3( step( d, 0.025) );\n    }\n    #endif\n    \n    return srgb2lin(texture( iChannel0, uv ).rgb );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n\n    if ( uv.x > 0.7 &&  uv.y < 0.2 )\n    {\n        vec2 luv = remap01( uv, vec2(0.7,0.0), vec2(1.0, 0.175) );\n        vec3 c;\n        c.r = step( luv.x, 1.0/3.0);\n        c.g = step( 1.0/3.0, luv.x )*step(luv.x, 2.0/3.0);\n        c.b = step( 2.0/3.0, luv.x );\n        c *= 0.4;\n        \n        vec3 rgb = spectrum_offset_rgb( luv.x );\n        c += step( abs(rgb-luv.yyy), vec3(0.0125) );\n\n        if ( uv.y > 0.20125 )\n        {\n            c = spectrum_offset( luv.x );\n            if ( uv.y < 0.21 )\n                c = vec3(0.0);\n                \n        }\n        \n        fragColor.rgb = c;\n        \n        if ( uv.y > 0.175 )\n            fragColor.rgb = rgb;\n        \n        return;\n    }\n    \n    const float MAX_DIST_PX = 50.0;\n    float max_distort_px = MAX_DIST_PX * (1.0-iMouse.x/iResolution.x);\n\tvec2 max_distort = vec2(max_distort_px) / iResolution.xy;\n    vec2 min_distort = 0.5 * max_distort;\n\n    //vec2 oversiz = vec2(1.0);\n    vec2 oversiz = distort( vec2(1.0), 1.0, min_distort, max_distort );\n    uv = remap01( uv, 1.0-oversiz, oversiz );\n    \n    //debug oversiz\n    //vec2 distuv = distort( uv, 1.0, max_distort );\n    //if ( abs(distuv.x-0.5)>0.5 || abs(distuv.y-0.5)>0.5)\n    //{\n    //    fragColor = vec4( 1.0, 0.0, 0.0, 1.0 ); return;\n    //}\n    \n    const int num_iter = 7;\n    const float stepsiz = 1.0 / (float(num_iter)-1.0);\n    float rnd = fract(1.61803398875*float(iFrame)+texture(iChannel1, fragCoord.xy/vec2(textureSize(iChannel1,0)), -10.0 ).x ); //nrand( uv + fract(iTime) );\n    float t = rnd * stepsiz;\n\n    vec3 sumcol = vec3(0.0);\n\tvec3 sumw = vec3(0.0);\n\tfor ( int i=0; i<num_iter; ++i )\n\t{\n\t\tvec3 w = spectrum_offset( t );\n\t\tsumw += w;\n        vec2 uvd = distort(uv, t, min_distort, max_distort ); //TODO: move out of loop\n\t\tsumcol += w * render( uvd );\n        t += stepsiz;\n\t}\n    sumcol.rgb /= sumw;\n    \n    vec3 outcol = sumcol.rgb;\n    outcol = lin2srgb( outcol );\n    outcol += rnd/255.0;\n    \n\tfragColor = vec4( outcol, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 11,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}