{
    "Shader": {
        "info": {
            "date": "1585765665",
            "description": "banana",
            "flags": 40,
            "hasliked": 0,
            "id": "wssyDX",
            "likes": 29,
            "name": "[sound] Heliostasis",
            "published": 3,
            "tags": [
                "sound",
                "music",
                "diffusion",
                "feedback"
            ],
            "usePreview": 1,
            "username": "jeyko",
            "viewed": 766
        },
        "renderpass": [
            {
                "code": "// check out wyatt, Flexi and michael's shaders to learn how to do buffer feedback stuff :) \n\n// i don't like the last chord\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    fragColor = (sin(fragColor*5. + vec4(-3.4,0.1,-0.2,0.4) + sin(iTime)*0.1));\n    fragColor = smoothstep(0.,0.7,fragColor );\n    \n    fragColor *= 1. - dot(uv,uv)*0.7;\n    fragColor = max(fragColor, 0.);\n    fragColor = pow(fragColor, vec4(0.45454));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\nvec2 noise(vec2 id){\n    float r = fract(sin(id.y*21422.125)*31455.31531);\n    float rb = fract(sin(id.x*21422.125)*31455.31531);\n    return vec2(r, rb);\n}\n\nvec3 get( vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(0);\n\n    #define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\n    \n    vec2 id = floor(uv*1000.);\n    \n    //vec2 n = noise(vec2(id.x + iTime*0.00001,id.y - iTime*0.000000));\n    vec2 n = noise(vec2(id.x + iTime*0.00001,id.y - iTime*0.000000));\n    \n    //col += pal(-0., 3., vec3(0.8,8.9,4.3), 1. + id.x *20. + n.y*2000.,0.9 + id.y*20.4 + n.x*20. + iTime);\n    //col += pal(-0., 3., vec3(0.8,8.9,4.3), 1. + sin(id.x *20.) + sin(n.y*2000.),0.9 + id.y*20.4 + n.x*20. + iTime);\n    col += pal(-0., 5., vec3(4.8,2.9,9.3), 4. + sin(id.x *20.) + sin(n.y*2000.),0.9 + id.y*20.4 + n.x*20. + iTime);\n    \n    \n    //col = smoothstep(0.,1.,col);\n    \n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n \n    vec2 cuv = fragCoord/iResolution.xy;   \n    \n    vec3 col = vec3(0);\n    \n    vec3 g = get(fragCoord);\n  \n    vec2 nc = fragCoord/iResolution.xy - 0.*(0. + length(uv)*2.)*normalize(uv)/iResolution.xy*iTimeDelta;\n\t    \n\tvec2 st = 30./iResolution.xy;\n    \n    vec2 lc = nc;\n    vec4 u = texture(iChannel1, lc + vec2(0,st.y) );\n    vec4 d = texture(iChannel1, lc + vec2(0,-st.y) );\n    vec4 l = texture(iChannel1, lc + vec2(-st.x,0) );\n    vec4 r = texture(iChannel1, lc + vec2(st.x,0) );\n    \n    vec2 grb = (vec2( r.b - l.b, u.b - d.b));\n    vec2 gr = normalize(vec2( r.r - l.r, u.r - d.r));\n    #define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n    \n    gr *= rot(3.14/4.);\n    grb *= rot(3.14/8./8.);\n    //ddb *= rot(3.14/2. - 3. - sin(iTime)*0.5 - 0.1);\n    \n    nc += grb*st*2.9;\n    //nc += grb*st*2.9*iTimeDelta*100.;\n    //nc -= gr*st*0.;\n    \n    if(iFrame > 0)\n    \tcol = mix(g, texture(iChannel1,nc).xyz, 0.999);\n    if(iFrame == 0)\n        col = vec3(0);\n\n    if(iMouse.z > 0.){\n    \t//C = mix(C, vec4(1,1,1,1)*(sin(Q.xyyx*4.2))*1., mouse );\n        float mouse = smoothstep(0.1,0.001,length(iMouse.xy/iResolution.x - fragCoord/iResolution.x));\n        \n        col = mix(col, vec3(0.),mouse*0.07);\n    }\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "float gT;\n    float sc;\nfloat note(float note, float octave){ \n\treturn 27.5*exp2(((octave*12. ) + note )/12.);//pow(2., );\n}\n\nvec4 r11(float x){return texture(iChannel0,vec2(x)/256.);}\nvec2 hash22(vec2 p)   \n{\n    p  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n    return fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\nvec2 hash22a(vec2 p){\n    p *= 2000.;\n\treturn texture(iChannel0, vec2((p + 1./floor(p/256.)))/256.).xz;\n}\n\nvec2 noise(float t)\n{\n    return hash22(vec2(t, t * 1.423)) * 2.0 - 1.0;\n}\n\nvec2 lpnoise(float t, float fq)\n{\n    t *= fq;\n\n    float ft = fract(t);\n    float tn = t - ft;\n    ft = smoothstep(0.0, 1.0, ft);\n\n    vec2 n0 = noise(floor(tn + 0.0) / fq);\n    vec2 n1 = noise(floor(tn + 1.0) / fq);\n\n    return mix(n0, n1, ft);\n}\n\n#define bitreduction(s,amt) s = sign(s) * floor(abs(s)/amt)*amt\n#define sampleratereduction(t, amt) t = floor(t/(amt))*(amt)\n#define smoothify(s, amt) mix(s,sign(s)*smoothstep(0.0,1.,abs(s)), amt)\n#define clampify(s, amt) clamp(s*amt,-1.,1.)/amt\nvec2[8] N;\n\n\n\nvec2 kick(float t, inout float sc){\n\tinit;\n\t\n    sampleratereduction(t, 0.000006);\n    \n    float md = beat/4.;\n    float pl = 16.;\n    t = mod(t, md*pl);\n    float idx = floor(t/md);\n    t = mod(t, md);\n    \n    float env = exp(-t*40.7);\n    s += sin((exp2(-t*80.1)*340. + 60.)*tt )*env;\n    \n    s = mix(s,sin(s*2.)*1., 0.5);\n    \n    \n    //bitreduction(s, 0.001);\n    \n    //s = sign(s)*smoothstep(0.,1.,abs(s));\n    \n    \n    s = clamp(s,-1., 1.);\n    \n    \n    float att = float(pattK[int(idx)]);\n    s *= att;\n    sc = 1. - pow(env, 0.15)*att;\n    sc = smoothstep(0.,1.,sc);\n    ret;\n}\n\nvec2 snare(float t){\n\tinit;\n    \n    \n    float md = beat;\n    float pl = 8.;\n    t = mod(t, md*pl);\n    float idx = floor(t/md);\n    t = mod(t, md);\n    \n    float env = exp2(-t*70.);\n    \n    vec2 n =lpnoise(t,10000.5);\n    vec2 nb =lpnoise(t,20000.5);\n    float f = 400.+ 500.*exp2(-t*80.)+ n.x*6.5 ;\n    \n    \n    s += sin(f*tt + n.x*0.25 + nb.x*0.5*exp(-t*20.))*env;\n    s += sin(f*tt*4. + n.x*0.25 + nb.x*4.2*exp(-t*10.))*pow(env, 0.8)*0.03;\n    \n    s += (n + nb)*0.1*exp(-t*15.);\n    \n    s = smoothify(s, 0.1);\n    \n    s *= float(pattS[int(idx)]);\n    ret;\n}\n\nvec2 lead(float t){\n\tinit;\n\t\n    float to;\n    vec2 nn = N[0];\n    nn += N[1]*0.9;\n    nn += N[5]*0.45;\n    nn += N[7]*0.1;\n    \n    \n    vec2 id;\n    float r = bar;\n    \n    t = mod(t, r*float(chordCnt));\n    \n    id.x = floor(t/r);\n    \n    t = mod(t,bar);\n    float reps = 32./16.;\n    id.y = floor(t/(bar/reps));\n    \n    id.y = mod(id.y, 4.);\n    \n    t = mod(t,bar/reps);\n    \t\n\n    \n    if (gT > msr*2.)\n    \tsampleratereduction(t, (1.2*1./iSampleRate));\n    \n    float amt = 0.9;\n    float env = exp(-t*0.2);\n    \n    \n    \n\tfloat n = chords[int(id.x)][int(id.y)];\n    \n    \n    float oct = 5.;\n    s += sin( note(n, oct) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 )*env;\n    s += sin( note(n, oct) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 + nn*amt)*env;\n    s -= sin( note(n, oct) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 )*env;\n    \n    \n    \n    bitreduction(s, 0.1);\n    s *= float(pattL[int(id.y)]);\n    \n    \n    s *= 1.;\n    ret;\n}\n\n\nvec2 leadb(float t){\n\tinit;\n\t\n    float to;\n    vec2 nn = N[0];\n    \n    \n    vec2 id;\n    float r = bar;\n    t = mod(t, r*float(chordCnt));\n    \n    id.x = floor(t/r);\n    \n    float att = float(pattL[int( mod(floor(t/(bar/(32./8.))), 8.) )]);\n    t = mod(t,bar);\n    float reps = 32./2.;\n    id.y = floor(t/(bar/reps));\n    \n    id.y = mod(id.y, 4.);\n    \n    t = mod(t,bar/reps);\n    \t\n\n    //sampleratereduction(t, (1.2*1./iSampleRate));\n    \n    float amt = 0.1;\n    float env = exp(-t*0.2);\n    \n    \n    \n\tfloat n = chords[int(id.x)][int(id.y)];\n    \n    \n    float oct = 5.;\n    s += sin( note(n, oct) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 )*env;\n    s += sin( note(n, oct) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 + nn*amt)*env;\n    s -= sin( note(n, oct) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 )*env;\n    \n    \n    \n    //bitreduction(s, 0.7);\n    s *= 1. - att;\n    \n    s = smoothify(s, 0.9);\n    s = smoothify(s, 0.9);\n    s = smoothify(s, 0.9);\n    \n    s *= 0.05;\n    ret;\n}\n\nvec2 leadc(float t){\n\tinit;\n\t\n    float to;\n    vec2 nn = N[0];\n    \n    \n    vec2 id;\n    float r = bar;\n    t = mod(t, r*float(chordCnt));\n    \n    id.x = floor(t/r);\n    \n    float att = float(pattL[int( mod(floor(t/(bar/(32./8.))), 8.) )]);\n    t = mod(t,bar);\n    float reps = 32./2.;\n    id.y = floor(t/(bar/reps));\n    \n    id.y = mod(id.y, 4.);\n    \n    t = mod(t,bar/reps);\n    \t\n\n    if (gT > msr*2.)\n    \tsampleratereduction(t, (1.2*1./iSampleRate));\n    \n    float amt = 0.1;\n    float env = exp(-t*0.2);\n    \n    \n    \n\tfloat n = chords[int(id.x)][int(id.y)];\n    \n    \n    float oct = 4.;\n    s += sin( note(n, oct) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 )*env;\n    s += sin( note(n, oct) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 + nn*amt)*env;\n    s -= sin( note(n, oct) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 )*env;\n    \n    \n    \n    if (gT > msr*2.)\n    \tbitreduction(s, 0.7);\n    s *= 1. - att;\n    \n    \n    s *= 0.1;\n    ret;\n}\n\n\n\n\n\n\nvec2 tri(float t,float f){\n    return vec2(abs(fract(f*t) - 0.5));\n}\n\nvec2 bass(float t){\n\tinit;\n\t\n    float to;\n    \n    \t\n    vec2 id;\n    float r = bar;\n    t = mod(t, r*4.);\n    \n    id.x = floor(t/r);\n    \n    t = mod(t,r);\n    float reps = 1.;\n    id.y = floor(t/(bar/reps));\n    \n    id.y = mod(id.y, 4.);\n    \n    t = mod(t,bar/reps);\n    \n    \n    sampleratereduction(t, (10./iSampleRate)*(1.1 + sin(t)));\n    sampleratereduction(t, (20./iSampleRate)*0.1);\n    \n    float env = exp(-t*0.04);\n    \n\tfloat n = chords[int(id.x)][int(id.y)];\n    \n    //n += floor(id.y/4.)*12.;\n    \n    s += sin( note(n, 1.) *tt \n             +sin(note(n, 4.) *tt + \n             \t+sin(note(n, 2.) *tt)*exp(-t*0.2)*0.1 \n                 \n                 )*exp(-t*0.5)*0.4\n             +sin(note(n, 1.) *tt + \n             \t+sin(note(n, 10.) *tt)*exp(-t*0.2)*0.\n                 )*exp(-t*0.5)*0.4\n            )*env;\n    \n    \n    s *= 1.;\n    \n    vec2 oS = s;\n    \n    bitreduction(s, (0.2 + sin(gT)*0.1));\n    \n    s = mix(oS, s, 0.6);\n    \n    \n    s = sin(s*2.5);\n    \n    s = smoothify(s, 1.);\n    s = smoothify(s, 1.);\n    s = smoothify(s, 1.);\n    s = smoothify(s, 1.);\n    //s = mix(s,sqrt(abs(s)*1.)*sign(s)*1., 1. );\n    \n    s *= 0.7*0.6; // what is maths\n    ret;\n}\n\n\n\nvec2 chord(float t){\n\tinit;\n    \n    \n    float r = bar;\n    t = mod(t, r*float(chordCnt));\n    int id = int(floor(t/r));\n    \n    //sampleratereduction(t, (1./iSampleRate));\n    sampleratereduction(t, 0.00003);\n    \n    vec2 nn = N[1];\n    nn += N[2]*0.9;\n    nn += N[7]*0.45;\n    \n    nn *= 0.01*sin(t);\n    float m = 1.;\n    float width = 15.;\n    s += sin( note(chords[id][1], 4.) *tt + nn.x*1.)*0.5;\n    s += sin( note(chords[id][1], 4.) *tt + nn.x*1.)*0.5;\n    float oct = 3.;\n    for(float i = 0.; i < 4.; i++){\n        float a = (1. + i/2.);\n    \t//s += sin( note(chords[id].x, 3.) *tt + nn.x)*m;\n    \ts.x += sin( note(chords[id].x, oct) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].y, oct) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].z, oct) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].w, oct) *tt*a + nn.x)*m;\n    \ts.y += sin( note(chords[id].x, oct) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].y, oct) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].z, oct) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].w, oct) *tt*a + nn.y + width)*m;\n    \tm *= 0.5;\n    }\n    \n    //bitreduction(s, 0.01);\n    \n    s *= 0.03;\n    s = sin(s*3.);\n    //s /= 2.;\n    //s = sin(s);\n\tret;\n}\n\n\n\n\nvec2 cguit(float t){\n\tinit;\n    \n    \n    float r = bar;\n    t = mod(t, r*float(chordCnt));\n    int id = int(floor(t/r));\n    \n    \n    float rb = bar/8.;\n    float env = exp(-mod(t, rb)*2.)*float(pattG[int(mod(floor(t/rb*2.), r*4.))]);\n    \n    //sampleratereduction(t, (1./iSampleRate));\n    //sampleratereduction(t, (2./iSampleRate));\n    if(gT < msr*6.)\n    \tsampleratereduction(t, 0.0005);\n    \n    vec2 nn = N[0];\n    nn += N[1]*0.9;\n    nn += N[3]*0.45;\n    \n    nn *= 0.01*sin(t);\n    float m = 1.;\n    float width = 15.;\n    s += sin( note(chords[id][1], 3.) *tt + nn.x*1.);\n    s += sin( note(chords[id][1], 3.) *tt + nn.x*1.);\n    float oct = 3.;  \n    for(float i = 0.; i < 5. ; i++){\n        float a = (1. + i/1.);\n    \t//s += sin( note(chords[id].x, 3.) *tt + nn.x)*m;\n    \ts.x += sin( note(chords[id].x, oct) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].y, oct) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].z, oct) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].w, oct) *tt*a + nn.x)*m;\n    \ts.y += sin( note(chords[id].x, oct) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].y, oct) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].z, oct) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].w, oct) *tt*a + nn.y + width)*m;\n    \tm *= 0.75;\n    }\n    s *= env;\n    if(gT < msr*4.)\n    \tbitreduction(s, 0.4);\n    \n    s *= 0.04;\n    //s = sin(s*3.);\n    //s /= 2.;\n    //s = sin(s);\n\tret;\n}\n\n\nvec2 hats(float t){\n\tinit;\n\t\n    float r = hbeat;\n    t = mod(t + 0., r);\n    \n    float o = offsH[int(mod(floor(t/hbeat), 7.))]*r;\n    t -= o;\n    \n    \n    sampleratereduction(t, 1./iSampleRate);\n    vec2 nn = N[0] + N[1]  + N[2] + N[3]  ;\n    \n    float amt = 0.1;\n    float env = exp(-t*7.4);\n    //float f =  sin((12000. )*tt)*exp(-t*0.4)*0.215 +sin((3000. )*tt)*exp(-t*2.)*0.5 + ( 2000. + exp(-t*60.)*100.)*tt +lpnoise(t, 200500.).x*1.;\n    float f =  sin((11000. )*tt)*exp(-t*0.4)*0.215 +sin((3000. )*tt)*exp(-t*2.)*0.5 + ( 3000. + exp(-t*60.)*100.)*tt +lpnoise(t, 2500.).x*1.;\n    s += sin( f )*env;\n    s += amt*sin( f + nn )*env;\n    s -= amt*sin( f )*env;\n    \n    bitreduction(s, 0.7);\n    s *= 1.;\n    s *= min(floor(t) + 1., 1.);\n    ret;\n}\nvec2 hatsb (float t){\n\tinit;\n\t\n    t = mod(t + 0., hbeat/2.);\n    \n\n    vec2 nn = N[0] + N[4]*0.87  + N[2]*0.6 + N[3]*0.5  ;\n    \n    float amt = 0.5;\n    float env = exp(-t*10.);\n    float f =  sin(\n        (7000. )*tt)*exp(-t*0.4)*0.215 \n        +sin((4000. )*tt)*exp(-t*2.)*0.5 \n        + ( 1250. + exp(-t*60.)*100.)*tt +N[6].x*1.;\n    s += sin( f )*env;\n    s += amt*sin( f + nn )*env;\n    s -= amt*sin( f )*env;\n    \n    \n    s *= 0.08;\n    ret;\n}\n\nvec2 crash(float t){\n\tinit;\n\t\n    t = mod(t + 0., msr/2.);\n    \n    vec2 nn = N[1];\n    \n    float amt = 2.;\n    float env = exp(-t*0.2);\n    float f =  sin(\n        (2000. )*tt)*exp(-t*0.4)*0.215 \n        +sin((4000. )*tt)*exp(-t*2.)*0.5 \n        + ( 1250. + exp(-t*60.)*100.)*tt +lpnoise(t, 200500.).x*1.;\n    s += sin( f )*env;\n    s += amt*sin( f + nn )*env;\n    s -= amt*sin( f )*env;\n    \n    \n    s *= 0.9;\n    bitreduction(s, 0.9);\n    \n    s *= 0.4;\n    ret;\n}\n\nvec2 cReverb(float t){\n\tinit;\n    \n    //sampleratereduction(t, (8.2*1./iSampleRate));\n    \n    \n    float iters = 100.;\n    float size = 150.;\n    \n    if(gT > msr *8.)\n        iters *= 4.;\n    \n    for(float i = 0.; i < iters ; i++ ){\n        float att = smoothstep(1.,0.9,i/iters);\n    \t//s += lead(t - size*i/iSampleRate + 10000.2*N[int(mod(i,7.))].x/iSampleRate )*(pow(sc,0.9))*att;\n        float m = size*i/iSampleRate + noise(i).x*100./iSampleRate;\n        s += lead(t + m )*(pow(sc,0.9))*att*0.05;\n        s += leadb(t + m);\n        s += hats(t + m)*(0.2 + pow(sc,1.4))*0.001;\n    }\n    s /= iters;\n    s *= 3.;\n    \n    if (gT > msr*2.)\n    \ts = mix(s,s * (pow(sc,0.9)), 0.5);\n    //bitreduction(s, 0.0001);\n    \n    ret;\n}\n\n\nvoid initKickPatt(float t){\n\t\n    float r = beat/4.;\n    \n    float id = floor(t/r);\n    \n    \n    for(int i = 0; i < 16; i++){\n        \n        vec4 r = r11(id + float(i));\n        \n    \tpattK[i] = r.x < probK[i];\n        \n    }\n}\n\n\nvoid initNoise(float t){\n\t\t\n    N[0] = lpnoise(t, 400.);\n    N[1] = lpnoise(t, 500.);\n    N[2] = lpnoise(t, 700.);\n    N[3] = lpnoise(t, 1000.);\n    N[4] = lpnoise(t, 1400.);\n    N[5] = lpnoise(t, 1900.);\n    N[6] = lpnoise(t, 2500.);\n    N[7] = lpnoise(t, 5500.); \n    \n}\nvec2 mainSound( in int samp, float t )\n{\n    t += OFFS;\n    gT = t;\n    //t += msr*4.;\n    vec2 s= vec2(0);\n    \n    initKickPatt(t);\n    initNoise(t);\n\n    \n    vec2 k = kick(t,sc)*1.;\n    vec2 sn = snare(t);\n    \n    vec2 ha = hats(t)*(0.2 + pow(sc,1.4))*0.01;\n    vec2 hb = hatsb(t)*0.7;\n    \n    vec2 drums = k + sn*1. + ha*3. ;\n    //drums *= 0.5;\n    drums = sin(drums*1.2);\n    //drums = smoothify(drums, 0.2);\n    //vec2 hb= hatsb(t)*(pow(sc,4.4))*0.1;\n    vec2 bass = bass(t)*(pow(sc,1.))*0.3;\n    vec2 c = chord(t)*(pow(sc,1.))*0.4;\n    vec2 cguit = cguit(t)*(pow(sc,1.))*0.5;\n    //vec2 l = lead(t)*(pow(sc,0.9))*0.4;\n    //vec2 lb = leadb(t)*(pow(sc,0.9))*0.4;\n    //vec2 lc = leadc(t)*(pow(sc,0.9))*0.4;\n\t//vec2 cr = crash(t);\n    \n    vec2 rev = cReverb(t);\n    vec2 lb = leadb(t)*(pow(sc,0.9))*1.5;\n    vec2 cr = crash(t)*(pow(sc,0.9))*0.1;\n    \n    if(t > msr*8.){\n    \tt = mod(t,msr*2.*4.) + msr*8.;\n    }\n\t\n    if(t < msr*2.){\n    \ts += rev*4.;\n    \ts += lb;\n        if(t > msr*1.){\n    \t\ts += cr;\n        }\n    } else if(t < msr*4.) {\n    \ts += lb;\n\t\ts += hb;\n        s += c;\n        if(t > msr*3.){\n            s += k;\n        \ts += cguit;\n            s -= c;\n        \ts += rev*3.;\n        }\n    }else if(t < msr*6.) {\n    \ts += drums;\n        s += bass;\n\t\ts += rev*3.;\n        if(t > msr*5.){\n        \ts += hb;\n        }\n    }else if(t < msr*8.) {\n        s += cr;\n    \ts += drums;\n        s += bass;\n\t\ts += rev*3.;\n        s += cguit*1.7;\n    }else if(t < msr*10.) {\n        s += cr;\n    \ts += drums;\n        s += bass;\n        s += lb;\n\t\ts += rev*3.;\n        s += cguit;\n    }else if(t < msr*12.) {\n        s += cr;\n        s += c;\n    \ts += drums;\n        s += bass;\n        s += lb;\n\t\t//s += rev*3.;\n        s += cguit;\n    }\n    \n    \n    s *= 0.9;\n    \n    s = smoothify(s, 0.3);\n    s = smoothify(s, 0.1);\n    \n    s = clampify(s, 1.7);\n    \n    \n    s *= 0.5;\n    \n    return s;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "#define PI acos(-1.)\n\n#define T true\n#define F false\n\n#define init vec2 s = vec2(0)\n#define ret return s\n#define bpm (170.)\n\n#define tick (60./bpm)\n\n#define beat (tick)\n#define bar  (beat*4.)\n#define hbar  (bar/2.)\n#define msr  bar*4.\n#define hbeat tick/2.\n#define qbeat tick/4.\n\n\n\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define TT (tau*t)\n#define tt (tau*t)\n\n#define S vec2 s = vec2(0);\n#define E return s;\n\n#define OFFS (msr*1.)*0.\n\n//float[] probK = float[16](0.1,0.9,0.1,0.9,0.4,0.9,0.1,0.3,0.9,0.4,0.9,0.,0.9,0.1,0.4,0.5);\nfloat[] probK = float[16](0.9,0.1,0.1,0.2,0.,0.1,0.1,0.2,0.9,0.2,0.4,0.2,0.2,0.9,0.4,0.5);\nbool[] pattK = bool[16](F,F,F,T,F,T,T,F,T,F,F,T,F,T,T,F);\nbool[] pattL = bool[16](T,F,T,F,T,F,T,F,T,F,F,T,F,T,T,F);\nbool[] pattS = bool[8](F,T,F,T,F,T,F,T);\nbool[] pattG = bool[8](F,T,F,F,T,F,T,T);\n\n\nfloat[] offsH = float[8](0.02,0.1,0.1,0.02,0.29,0.1,0.0,0.02); \n\n\nfloat[] notesLB = float[8](2.,1.,0.,2.,0.,2.,0.,3.);\nint[] notesB = int[8](0,1,2,3,0,1,2,3);\n\nconst float scale = -4.;\n\nconst vec4 cmin9 = vec4(0.,3.,10.,14.) + scale;\n\nconst vec4 cmin510 = vec4(0.,7.,10.,12.) + scale;\nconst vec4 cmin7 = vec4(0.,3.,7.,10.) + scale;\nconst vec4 cmin73 = vec4(0.,7.,10.,3.) + scale;\nconst vec4 cmin11 = vec4(0.,10.,14.,17.) + scale;\nconst vec4 cmaj9 = vec4(0.,4.,7.,14.) + scale;\nconst vec4 cmaj7 = vec4(0.,4.,7.,11.) + scale;\nconst vec4 cmaj14 = vec4(0.,4.,11.,12. + 7.) + scale;\nconst vec4 cmaj7f15 = vec4(0.,4.,6.,11.) + scale;\nconst vec4 cmaj7d = vec4(0.,4.,7.,10.) + scale;\nconst vec4 cmin7maj = vec4(0.,3.,7.,11.) + scale;\n\nconst int chordCnt = 8;\n\n\nvec4[] chords = vec4[chordCnt](\n    cmin510,\n    cmin73 + 1.,\n    cmaj9 - 1.,\n    cmaj14 - 3.,\n    cmin11,\n    cmaj14 + 1. - 7.,\n    cmaj7 - 1.,\n    cmaj7 - 5.\n);\n\nvec4[] chordsbb = vec4[chordCnt](\n    cmin11,\n    cmaj14 + 2. - 7.,\n    cmin7 - 2.,\n    cmaj7 + 1.,\n    cmaj14 - 3.,\n    cmaj7f15 + 3.,\n    cmin9 + 2. - 4.,\n    cmaj7f15 - 4.\n);\n\nvec4[] chordsb = vec4[chordCnt](\n    cmin9,\n    cmaj7 + 1.,\n    cmaj7f15 - 2.,\n    cmaj7 - 3.,\n    cmaj14 - 2.,\n    cmaj7f15 + 3.,\n    cmaj9 - 1.,\n    cmaj7f15 - 4.\n);\nvec4[] chordsa = vec4[chordCnt](\n    cmin9,\n    cmaj7f15 - 2.,\n    cmaj9 - 3.,\n    cmin7maj - 5.,\n    cmaj14 - 2.,\n    cmaj7f15 + 3.,\n    cmaj9 - 1.,\n    cmaj7f15 - 2.\n);\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}