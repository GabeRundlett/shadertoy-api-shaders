{
    "Shader": {
        "info": {
            "date": "1608869596",
            "description": "I asked my brother for something to make and he said star of bethlehem",
            "flags": 0,
            "hasliked": 0,
            "id": "wldcWr",
            "likes": 28,
            "name": "Shader try of Star of Bethlehem",
            "published": 3,
            "tags": [
                "noise",
                "terrain",
                "stars",
                "starfield",
                "human"
            ],
            "usePreview": 0,
            "username": "TheNosiriN",
            "viewed": 998
        },
        "renderpass": [
            {
                "code": "#define PI 3.142\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n\nmat2 rotate(float angle)\n{\n\tangle *= PI / 180.0;\n    float s = sin(angle), c = cos(angle);\n    return mat2( c, -s, s, c );\n}\n\n\n\nfloat hash21(vec2 p)\n{\n \tp = fract( p*vec2(123.34, 456.21) );\n    p += dot(p, p+45.32);\n    return fract(p.x*p.y);\n}\n\nvec3 hash23( vec2 co )\n{\n   vec3 a = fract( cos( co.x*8.3e-3 + co.y )*vec3(1.3e5, 4.7e5, 2.9e5) );\n   vec3 b = fract( sin( co.x*0.3e-3 + co.y )*vec3(8.1e5, 1.0e5, 0.1e5) );\n   vec3 c = mix(a, b, 0.5);\n   return c;\n}\n\n\n\n\nfloat star(vec2 uv, float time, float flare)\n{\n\tfloat d = length(uv);\n    float m = (max(0.2, abs(sin(time))) * 0.02) / d;\n    \n    float rays = max(0., 1.-abs(uv.x*uv.y*1000.));\n    m += rays*flare;\n    uv *= rotate(45.0);\n    rays = max(0., 1.-abs(uv.x*uv.y*1000.));\n    m += rays*0.5*flare;\n    \n    m *= smoothstep(1.0, 0.2, d);\n    \n    return m;\n}\n\n\n\nfloat starFieldMin(vec2 p)\n{\n    vec3 rnd = hash23(p * iResolution.x);\n    float intensity = pow((1.+sin((iTime+27.0)*rnd.x))*.5, 7.) ;\n    return max(rnd.x * pow(rnd.y,7.) * intensity, 0.);\n\n}\n\n\nvec3 starField(vec2 uv)\n{\n    vec3 col = vec3(0);\n    \n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    \n    for (int x=-1; x<=1; x++){\n        for (int y=-1; y<=1; y++)\n        {\n            vec2 offset = vec2(x, y);\n            \n            float n = hash21(id + offset);\n            float size = min(0.25, fract(n*1234.567) + 0.1);\n            float star = star(gv - offset - (vec2(n, fract(n*100.0)) - 0.5), iTime*fract(n*135.246), smoothstep(.9, 1., size)*.6);\n            \n            col += star * size;\n        }\n    }\n    \n    return col;\n}\n\n\n\n\nfloat wave(vec2 p)\n{\n    return 1.0-abs( p.y+sin(p.x) );\n}\n\n\nfloat terrain(vec2 uv)\n{\n    float d = 0.0;\n    float x = uv.x*2.0, f = 0.8, a = 0.05;\n    for (int p=0; p<5; p++){\n        d += sin(x * f) * a;\n        f *= 2.0;\n        a *= 0.5;\n    }\n    d = abs(d);\n    return sign((uv.y+d)-0.1);\n}\n\n\n\n\nconst vec3 purple = vec3(0.318,0.192,0.369);\nconst vec3 green = vec3(0.41, 0.86, 0.6);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/min(iResolution.x, iResolution.y);\n    vec2 uvS = fragCoord.xy/iResolution.xy;\n    \n    vec2 uvR = uv * rotate(mod(iTime*0.4, 360.0));\n    //uvR.y += iTime*0.01;\n    \n    vec3 color;\n    \n    color += (starField(uvR*50.0)) + starFieldMin(uv)*2.0;\n    \n    float mStar = pow(star(uv-vec2(1.3, 0.7), 1.0, smoothstep(0.2, 1.0, 0.45)*.6), 1.0);\n    color += mStar*0.8 * vec3(0.702,1.000,0.941);\n    \n    color += purple * pow(\n        wave(vec2(-uvS.x*2.0 + 1.8, (uv.y-0.7) * 1.5)),\n        3.0\n    );\n    \n    vec3 sky = pow(\n        mix(\n            green, purple, \n            saturate(pow(uvS.y-0.03, 0.5) * (uvS.x+0.7) * (1.0-uvS.x+0.5))\n        ), vec3(3.0)\n    ) * 2.0;\n    color += sky;\n    \n    \n    color *= terrain(uv);\n    \n    uv.x -= 0.5;\n    uv.y -= 0.03;\n    color *= Humanoid(uv*9.0, 1.0);\n    \n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Cheap 2D Humanoid SDF for dropping into scenes to add a sense of scale.\n// Hazel Quantock 2018\n// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. http://creativecommons.org/licenses/by-nc-sa/4.0/\n// https://www.shadertoy.com/view/4scBWN\nfloat RoundMax( float a, float b, float r )\n{\n    a += r; b += r;\n    \n    float f = ( a > 0. && b > 0. ) ? sqrt(a*a+b*b) : max(a,b);\n    \n    return f - r;\n}\n\nfloat RoundMin( float a, float b, float r )\n{\n    return -RoundMax(-a,-b,r);\n}\n\n// Humanoid, feet placed at <0,0>, with height of ~1.8 units on y\nfloat Humanoid( in vec2 uv, in float phase )\n{\n    #define Rand(idx) fract(phase*pow(1.618,float(idx)))\n    float n3 = sin((uv.y-uv.x*.7)*11.+phase)*.014; // \"pose\"\n    float n0 = sin((uv.y+uv.x*1.1)*23.+phase*2.)*.007;\n    float n1 = sin((uv.y-uv.x*.8)*37.+phase*4.)*.004;\n    float n2 = sin((uv.y+uv.x*.9)*71.+phase*8.)*.002;\n    //uv.x += n0+n1+n2; uv.y += -n0+n1-n2;\n    \n    float head = length((uv-vec2(0,1.65))/vec2(1,1.2))-.15/1.2;\n    float neck = length(uv-vec2(0,1.5))-.05;\n    float torso = abs(uv.x)-.25;\n    //torso += .2*(1.-cos((uv.y-1.)*3.));\n    //torso = RoundMax( torso, abs(uv.y-1.1)-.4, .2*(uv.y-.7)/.8 );\n    torso = RoundMax( torso, uv.y-1.5, .2 );\n    torso = RoundMax( torso, -(uv.y-.5-.4*Rand(3)), .0 );\n\n    float f = RoundMin(head,neck,.04);\n    f = RoundMin(f,torso,.02);\n    \n    float leg =\n        Rand(1) < .3 ?\n        abs(uv.x)-.1-.1*uv.y : // legs together\n    \tabs(abs(uv.x+(uv.y-.8)*.1*cos(phase*3.))-.15+.1*uv.y)-.05-.04*Rand(4)-.07*uv.y; // legs apart\n    leg = max( leg, uv.y-1. );\n    \n    f = RoundMin(f,leg,.2*Rand(2));\n    \n    f += (-n0+n1+n2+n3)*(.1+.9*uv.y/1.6);\n    \n    float sdf = max( f, -uv.y );\n    return .5+.5*sdf/(abs(sdf)+.002);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}