{
    "Shader": {
        "info": {
            "date": "1361362085",
            "description": "Old ray-marched fireball, it looks like I accidentally removed this!\n\nhttp://http.download.nvidia.com/developer/presentations/2005/GDC/Sponsored_Day/GDC_2005_VolumeRenderingForGames.pdf",
            "flags": 0,
            "hasliked": 0,
            "id": "4ssGzn",
            "likes": 140,
            "name": "Fire2",
            "published": 3,
            "tags": [
                "3d",
                "volume",
                "raymarch"
            ],
            "usePreview": 1,
            "username": "simesgreen",
            "viewed": 15266
        },
        "renderpass": [
            {
                "code": "// ray marched fireball\n// sgreen\nconst int _VolumeSteps = 128;\nconst float _StepSize = 0.02; \nconst float _Density = 0.2;\n\nconst float _SphereRadius = 1.0;\nconst float _NoiseFreq = 2.0;\nconst float _NoiseAmp = 1.0;\nconst vec3 _NoiseAnim = vec3(0, -1, 0);\n\n// iq's nice integer-less noise function\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv+0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z )*2.0-1.0;\n}\n\nfloat fbm( vec3 p )\n{\n    float f = 0.0;\n    float amp = 0.5;\n    for(int i=0; i<4; i++)\n    {\n        //f += abs(noise(p)) * amp;\n        f += noise(p) * amp;\n        p *= 2.03;\n        amp *= 0.5;\n\t}\n    return f;\n}\n\nvec2 rotate(vec2 v, float angle)\n{\n    return v * mat2(cos(angle),sin(angle),-sin(angle),cos(angle));\n}\n\n// returns signed distance to surface\nfloat distanceFunc(vec3 p)\n{\t\n\n\t// distance to sphere\n    float d = length(p) - _SphereRadius;\n\t// offset distance with noise\n\td += fbm(p*_NoiseFreq + _NoiseAnim*iTime) * _NoiseAmp;\n\treturn d;\n}\n\n// shade a point based on distance\nvec4 shade(float d)\n{\t\n    if (d >= 0.0 && d < 0.2) return (mix(vec4(3, 3, 3, 1), vec4(1, 1, 0, 1), d / 0.2));\n\tif (d >= 0.2 && d < 0.4) return (mix(vec4(1, 1, 0, 1), vec4(1, 0, 0, 1), (d - 0.2) / 0.2));\n\tif (d >= 0.4 && d < 0.6) return (mix(vec4(1, 0, 0, 1), vec4(0, 0, 0, 0), (d - 0.4) / 0.2));    \n    if (d >= 0.6 && d < 0.8) return (mix(vec4(0, 0, 0, 0), vec4(0, .5, 1, 0.2), (d - 0.6) / 0.2));\n    if (d >= 0.8 && d < 1.0) return (mix(vec4(0, .5, 1, .2), vec4(0, 0, 0, 0), (d - 0.8) / 0.2));            \n    return vec4(0.0, 0.0, 0.0, 0.0);\n}\n\n// procedural volume\n// maps position to color\nvec4 volumeFunc(vec3 p)\n{\n    //p.xz = rotate(p.xz, p.y*2.0 + iTime);\t// firestorm\n\tfloat d = distanceFunc(p);\n\treturn shade(d);\n}\n\n// ray march volume from front to back\n// returns color\nvec4 rayMarch(vec3 rayOrigin, vec3 rayStep, out vec3 pos)\n{\n\tvec4 sum = vec4(0, 0, 0, 0);\n\tpos = rayOrigin;\n\tfor(int i=0; i<_VolumeSteps; i++) {\n\t\tvec4 col = volumeFunc(pos);\n\t\tcol.a *= _Density;\n\t\t// pre-multiply alpha\n\t\tcol.rgb *= col.a;\n\t\tsum = sum + col*(1.0 - sum.a);\t\n\t\tpos += rayStep;\n\t}\n\treturn sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy / iResolution.xy)*2.0-1.0;\n    p.x *= iResolution.x/ iResolution.y;\n\t\n    float rotx = (iMouse.y / iResolution.y)*4.0;\n    float roty = -(iMouse.x / iResolution.x)*4.0;\n\n    float zoom = 4.0;\n\n    // camera\n    vec3 ro = zoom*normalize(vec3(cos(roty), cos(rotx), sin(roty)));\n    vec3 ww = normalize(vec3(0.0,0.0,0.0) - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    ro += rd*2.0;\n\t\n    // volume render\n    vec3 hitPos;\n    vec4 col = rayMarch(ro, rd*_StepSize, hitPos);\n\n    fragColor = col;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}