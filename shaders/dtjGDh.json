{
    "Shader": {
        "info": {
            "date": "1673773519",
            "description": "This took me way too long lmao",
            "flags": 0,
            "hasliked": 0,
            "id": "dtjGDh",
            "likes": 19,
            "name": "Shooting Stars Decoded",
            "published": 3,
            "tags": [
                "stars",
                "notgolf"
            ],
            "usePreview": 0,
            "username": "JB_0x0003",
            "viewed": 437
        },
        "renderpass": [
            {
                "code": "/*\n    De-codegolfed version of a shader by XorDev\n    Intended to make it easier to see what's going on \n    and help steal some of his non-codegolf techniques.\n    \n    Was fun to figure out how this works!\n    Original: https://www.shadertoy.com/view/ctXGRn\n*/\n    \n    \n/////////////////// Orignal's Text /////////////////////\n//\n//  I got hit with inspiration for the concept of shooting stars.\n//  This is what I came up with.\n//  \n//  Tweet: twitter.com/XorDev/status/1604218610737680385\n//  Twigl: t.co/i7nkUWIpD8\n//  <300 chars playlist: shadertoy.com/playlist/fXlGDN\n//  \n///////////////////////////////////////////////////////\n\nvoid mainImage(out vec4 outColor, vec2 fragCoord)\n{\n    //Clear fragcolor\n    outColor *= 0.;\n    vec2 st = fragCoord.xy / iResolution.y;\n    //increase perceived horizontal resolution\n    //has the effect of horizontally squishing the screen\n    \n    //Line dimensions (box)\n    //distance from this is used to calculate value.\n    vec2 b = vec2(0,.2);\n    //Rotation matrix\n    mat2 rotation;\n    \n    float dist;\n    \n    //per loop \n    vec2 loopST;\n    //Original Code was meant to iterate 20 times, but actually iterates 21 times\n    //because i++ returns the previous value of i and not it's new value\n    for(float i=.9; i<21.0 ;++i){\n        //Rotate for each iteration. The rotation of 33 and 11 radians are there to \n        //appoximate sin and negative sin. 33 approximately equals 10.5 pi.\n        //11 approximately equals 3.5pi. These are equivalent to 0.6 and 1.5 pi, respectively.\n        //These offsets when applied to cosine make its output equivalent to sin and negative sin, respectively.\n        //it's a reflected rotation so that when it's applied twice, it will be reflected normaly.\n        rotation = mat2(cos(i + vec4(0,33,11,0)));\n        //Scale the underlying space.\n        //This step is the reason why there's a second variable for the in loop position.\n        loopST = st * (i) * .1 ;\n        // Translate downwards overtime\n        loopST.y += iTime * (0.2);\n        //Turn the points into rotated squares\n        loopST =(fract((loopST)*rotation)-.5);\n        //Rotate again so that the local down direction is equal to the global down direction\n        //removing this causes every line to be rotated semi-randomly\n        loopST = rotation * loopST;\n        //determines distance between closest point inside the line and the current point.\n        //used to create color falloff.\n        dist = distance(clamp(loopST,-b,b),loopST);\n        outColor += 0.001/dist\n                //Multiply the addition by his favorite color palette :)\n                //All values are always above 0 here, so it creates a lot of bloom\n                    * (cos(loopST.y/.1 +vec4(0,1,2,3))+1.0);\n        \n        \n        //uncomment this line to see the underlying squares and the colors the lines are being multiplied by.\n        //outColor = cos(loopST.y /.1 + vec4(0,1,2,3))+1.;\n        \n        \n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}