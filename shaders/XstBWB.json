{
    "Shader": {
        "info": {
            "date": "1526588103",
            "description": "deforming a plane by a reaction diffusion fed by an optical flow on a video",
            "flags": 32,
            "hasliked": 0,
            "id": "XstBWB",
            "likes": 17,
            "name": "Thing_8",
            "published": 3,
            "tags": [
                "raymarching",
                "reactiondiffusion",
                "opticalflow"
            ],
            "usePreview": 0,
            "username": "balkhan",
            "viewed": 1387
        },
        "renderpass": [
            {
                "code": "#define SHOW_DIFUSION 0\n#define SHOW_OPTICAL_FLOW 1\n#define SHOW_RAYMARCHED_SCENE 2\n#define I_MAX\t350\n#define E\t\t0.00001\n\n//#define BALL\n#define SHOW SHOW_RAYMARCHED_SCENE\n\nvec3\tcam(vec2 u);\nfloat\tmap(vec3 p);\nfloat\tmylength(vec3 p);\nfloat\tmylength(vec2 p);\nvoid\trotate(inout vec2 v, float angle);\nvec3\th;\nvec4\tcol;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy;\n    vec2 uv = (fragCoord.xy - R*.5)/R.yy;\n\th = vec3(.0,.0,.0);\n    vec4\ttex = (texture(iChannel0, uv.xy ).xyzy*1.);\n    \n    col = vec4(.0,.0,.0, 1.);\n    \n    vec3 pos = vec3(.0, .0, -20.);\n    vec3 dir = cam(uv);\n    vec3 p;\n    vec2 dist = vec2(.0, .0);\n    for (float i = .0 ; i < 100.; i++)\n    {\n        p = pos + dist.y * dir;\n        dist.x = map(p);\n        dist.y += dist.x;\n        if (dist.x < E || dist.y > 150.)\n            break;\n    }\n\th*=.251;\n\n  \t#if (SHOW == SHOW_DIFUSION)\n\tcol = texture(iChannel0, fragCoord/R);\n    #elif SHOW == SHOW_OPTICAL_FLOW\n    col = texture(iChannel1, fragCoord/R);\n    #elif SHOW == SHOW_RAYMARCHED_SCENE\n\tcol.xyz = h;\n    #endif\n\tfragColor.xyz = col.xyz;\n}\n\nfloat map(vec3 p)\n{\n    float mind = 1e5;\n    \n    vec2 tcd;\n    p.z += -15.;\n    rotate(p.xz, -.4+sin(iTime*.5)*.25);\n    rotate(p.zy, 5.4+iTime*.0);\n    rotate(p.xz, 1.+iTime*.0+3.4);\n    \n    vec3 np = normalize(p);\n    tcd.x = p.x*(9./iChannelResolution[0].x )+.5;\n    tcd.y = p.y*(9./iChannelResolution[0].y )+.5;//tcd = np.yx;\n    #ifdef BALL\n    rotate(np.xz, 1.5);\n    tcd.x = .5+atan(np.z, np.x)/6.28;\n\ttcd.y = .5-asin(np.y)/3.14;\n    #endif\n    tcd = mix(tcd, floor(tcd*300.)/(300.), .5+.5*sin(iTime+(p.x+p.y)*.5) );\n    float to = .1*( texture(iChannel0, tcd).x*1.);\n    \n    #ifdef BALL\n    mind = min(mind, length(p)-10.+to*10.);\n    mind = max(mind, -(length(p)-8.5-to*10. ) );\n    #else\n    mind = max(p.z-.5, -p.z-.5)-to*10.;\n    mind = max(mind, abs(p.x)-16.+.0*-10000.0/iChannelResolution[0].x);\n    mind = max(mind, abs(p.y)-16.+.0*-10000.0/iChannelResolution[0].x);\n    #endif\n    h += 1.*vec3(.45, .5, .4)*1./max(.1, mind*mind*1. + 15.);\n    float mint = max(mind, .01);\n    h -= 1.*vec3(.05, .40, .50)*1./max(.00001, mint*mint*1000.001 + 20.);\n    \n    return mind*.421;\n}\n\nvec3 cam(vec2 u)\n{\n    vec3 up = vec3(.0, 1., .0);\n    vec3 ri = vec3(1., 0., .0);\n    vec3 fw = vec3(.0, 0., 1.);\n\treturn normalize(up*u.x + ri*u.y + fw);\n}\n\nfloat mylength(vec3 p) {return max(max(abs(p.x), abs(p.y)), abs(p.z));}\nfloat mylength(vec2 p) {return max(abs(p.x), abs(p.y) );}\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec2\t_TexelSize;\nfloat\t_Scale;\nfloat\t_Tresh;\n\n#define FEED_DEFAULT .0550\n#define KILL_DEFAULT .0620\n\n#define FEED_MITOSIS .0367\n#define KILL_MITOSIS .0649\n\nvec2\tlaplacian_convolution(sampler2D tex, vec2 uv, vec2 texsize)\n{\n\tvec2\tret = vec2(0.);\n    \n    if (uv.x == 0. || uv.y == 0. || uv.x== 1. || uv.y ==1.)\n        return (ret);\n    ret += texture(tex, vec2(uv.x , uv.y) ).xy * -1.;\n    \n    ret += texture(tex, vec2(uv.x -texsize.x, uv.y) ).xy * (.2);\n    ret += texture(tex, vec2(uv.x +texsize.x, uv.y) ).xy * (.2);\n    ret += texture(tex, vec2(uv.x , uv.y -texsize.y) ).xy * (.2);\n    ret += texture(tex, vec2(uv.x , uv.y +texsize.y) ).xy * (.2);\n    \n    ret += texture(tex, vec2(uv.x -texsize.x, uv.y -texsize.y) ).xy * (.05);\n    ret += texture(tex, vec2(uv.x +texsize.x, uv.y -texsize.y) ).xy * (.05);\n    ret += texture(tex, vec2(uv.x +texsize.x, uv.y +texsize.y) ).xy * (.05);\n    ret += texture(tex, vec2(uv.x -texsize.x, uv.y +texsize.y) ).xy * (.05);\n    return (ret);\n}\n\nvec4 gradient(sampler2D tex, vec2 uv, vec2 offset)\n{\n        return (texture(tex, uv + offset)) - (texture(tex, uv - offset));\n}\n\nvec4 optical_flow(vec2 f)\n{\n    if (f.x == 0.0 || f.y == 0.0\n        || f.x >= iChannelResolution[1].x || f.y >= iChannelResolution[1].y)\n        discard;\n    _TexelSize = 1./iChannelResolution[0].xy;\n    vec2 uv =    f /iChannelResolution[1].xy;\n\tvec4 current = texture(iChannel0, uv);\n    _TexelSize = 1./iChannelResolution[1].xy;\n    uv = (f - .0*iChannelResolution[1].xy)/iChannelResolution[1].xy;\n\tvec4 prev = texture(iChannel1, uv);\n    _TexelSize = 1./iChannelResolution[0].xy;\n    vec2 dx = vec2(_TexelSize.x, 0);\n    vec2 dy = vec2(0, _TexelSize.y);\n    _TexelSize = 1./iChannelResolution[1].xy;\n    vec2 ddx = vec2(_TexelSize.x, 0);\n    vec2 ddy = vec2(0, _TexelSize.y);\n\n    float\tkey = ( (current.y) < length(current.xz) ) ? 1. : .0;\n    current *= key;\n    \n    vec4 diff = (current - prev);\n\n    vec4 gx = gradient(iChannel1, uv, ddx) + gradient(iChannel0, uv, dx);\n    vec4 gy = gradient(iChannel1, uv, ddy) + gradient(iChannel0, uv, dy);\n\n    vec4 gmag = sqrt( abs(gx * gx + gy * gy) + 1.000);\n    vec4 invGmag = 1.0 / gmag;\n    vec4 vx = diff * (gx * invGmag);\n    vec4 vy = diff * (gy * invGmag);\n\n    vec2 flow = vec2(0, 0);\n    const float inv3 = 0.33333;\n    flow.x = (vx.x + vx.y + vx.z) * inv3;\n    flow.y = (vy.x + vy.y + vy.z) * inv3;\n\n    float w = length(flow);\n    float nw = (w - _Tresh) / (1.0 - _Tresh);\n    flow = mix(vec2(0., 0.), normalize(flow) * nw * _Scale , 1.*step(_Tresh, w));\n    return vec4(clamp(flow, .0, 1.) , 0., 1.);\n}\n\nvoid mainImage( out vec4 o, in vec2 f )\n{\n    vec2 R = iChannelResolution[0].xy;\n    _TexelSize = 1./R;\n    _Scale = 1.;\n    _Tresh = .003075;\n    o = optical_flow(f);\n    o.z -= iTimeDelta;\n    o.z += o.y;\n    o*= step(_Tresh, length(o) )*1.42;\n    //o*=.0;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 36,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define FEED_DEFAULT .01 // .0025 // .01 //.01003550\n#define KILL_DEFAULT .04 // .014 // .03 //.040620\n\n#define FEED_MITOSIS .0367\n#define KILL_MITOSIS .0649\n\nvec2\tlaplacian_convolution(sampler2D tex, vec2 uv, vec2 texsize)\n{\n\tvec2\tret = vec2(0.);\n    \n    //if (uv.x == 0. || uv.y == 0. || uv.x== 1. || uv.y ==1.)\n    //    return (ret);\n    ret += texture(tex, vec2(uv.x , uv.y) ).xy * -1.;\n    \n    ret += texture(tex, vec2(uv.x -texsize.x, uv.y) ).xy * (.2);\n    ret += texture(tex, vec2(uv.x +texsize.x, uv.y) ).xy * (.2);\n    ret += texture(tex, vec2(uv.x , uv.y -texsize.y) ).xy * (.2);\n    ret += texture(tex, vec2(uv.x , uv.y +texsize.y) ).xy * (.2);\n    \n    ret += texture(tex, vec2(uv.x -texsize.x, uv.y -texsize.y) ).xy * (.05);\n    ret += texture(tex, vec2(uv.x +texsize.x, uv.y -texsize.y) ).xy * (.05);\n    ret += texture(tex, vec2(uv.x +texsize.x, uv.y +texsize.y) ).xy * (.05);\n    ret += texture(tex, vec2(uv.x -texsize.x, uv.y +texsize.y) ).xy * (.05);\n    return (ret);\n}\n\nvec2 do_life(sampler2D tex, vec2 uv, vec2 texsize)\n{\n\tvec2 ret = vec2(.0);\n    \n    if (uv.x == 0. || uv.y == 0. || uv.x== 1. || uv.y ==1.)\n        return (ret);\n    ret += texture(tex, vec2(uv.x , uv.y) ).xy * 1.;\n    vec2 sum = vec2(.0);\n    \n    sum += texture(tex, vec2(uv.x -texsize.x, uv.y) ).xy;\n    sum += texture(tex, vec2(uv.x +texsize.x, uv.y) ).xy;\n    sum += texture(tex, vec2(uv.x , uv.y -texsize.y) ).xy;\n    sum += texture(tex, vec2(uv.x , uv.y +texsize.y) ).xy;\n    sum += texture(tex, vec2(uv.x -texsize.x, uv.y -texsize.y) ).xy;\n    sum += texture(tex, vec2(uv.x +texsize.x, uv.y -texsize.y) ).xy;\n    sum += texture(tex, vec2(uv.x +texsize.x, uv.y +texsize.y) ).xy;\n    sum += texture(tex, vec2(uv.x -texsize.x, uv.y +texsize.y) ).xy;\n    //sum -= laplacian_convolution(tex, uv, texsize).xy*2.;\n    if (ret.x > .0) // alive\n    {\n    \tif (sum.x >= 2. && sum.x <=3.)\n        {\n            ret.x = 1.;\n            ret.y = 1.;\n        }\n        else\n        {\n            ret.x = .0;\n            ret.y = .0;\n        }\n    }\n    else if (ret.x <= .0)\n    {\n        if (sum.x == 3.)\n        {\n            ret.x = 1.;\n            ret.y = 1.;\n        }\n        else\n        {\n            ret.x = .0;\n            ret.y = .0;\n        }\n    }\n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy) / iResolution.xy;\n    vec2 texsize = 1./iResolution.xy;\n    vec4\tret = texture(iChannel1, uv);\n    \n    vec2\tab = ret.xy;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    if (  iMouse.z > 0.0 &&\n        mouse.x <= abs(uv.x+.005) && mouse.x >= abs(uv.x-.005) &&\n        mouse.y <= abs(uv.y+.005) && mouse.y >= abs(uv.y-.005) )\n    {\n\t    fragColor.x += 1.;\n    \tab.y+=1.;\n\t}\n    if (iTime < 2.)\n    {\n\t\tab.x = 1.;\n\t    ab.y = 1.0;\n    }\n    fragColor *= .0;\n    for (float i = .0; i < 1.; i++)\n    {//ab*=.995;\n      ab.x += texture(iChannel0, uv).x;\n      ab.y += texture(iChannel0, uv).y;\n     fragColor.x += clamp(ab.x + (1. * (-.0*1.*laplacian_convolution(iChannel0, uv, texsize).x+1.*laplacian_convolution(iChannel1, (uv.xy*200.)/200., texsize*1.+texsize*i*.1).x) - ab.x * ab.y * ab.y + FEED_DEFAULT * (1. - ab.x) ) ,0.,1.);\n     fragColor.y += clamp(ab.y + (.5 * (-.0*1.*laplacian_convolution(iChannel0, uv, texsize).y+1.*laplacian_convolution(iChannel1, (uv.xy*200.)/200., texsize*1.+texsize*i*.1).y) + ab.x * ab.y * ab.y - (FEED_DEFAULT + KILL_DEFAULT) * ab.y ),0.,1.);\n     uv *= 1.;\n     texsize *= 1.;\n     //fragColor.xy = do_life(iChannel1, uv, texsize);\n     //fragColor.xy += .0125*do_life(iChannel1, floor(uv*1000.)/1000., texsize*1.).xy;\n     if (  iMouse.z > 0.0 &&\n        mouse.x <= abs(uv.x+.005) && mouse.x >= abs(uv.x-.005) &&\n        mouse.y <= abs(uv.y+.005) && mouse.y >= abs(uv.y-.005) )\n\t    fragColor.x = 1.;\n     //fragColor.x = max(fragColor.x, length(texture(iChannel0, uv).xy)*1.);\n     //fragColor.x -= .00000001;\n         fragColor.xy = clamp(fragColor.xy, .0, 1.);\n    }\n    fragColor/=1.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}