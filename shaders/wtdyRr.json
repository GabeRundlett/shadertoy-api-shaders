{
    "Shader": {
        "info": {
            "date": "1608415987",
            "description": "potato",
            "flags": 32,
            "hasliked": 0,
            "id": "wtdyRr",
            "likes": 10,
            "name": "Day 366 [ One Year ]",
            "published": 3,
            "tags": [
                "mdtmjvm"
            ],
            "usePreview": 1,
            "username": "jeyko",
            "viewed": 505
        },
        "renderpass": [
            {
                "code": "#define v2Resolution (iResolution.xy)\n#define T iTime\n#define dmin(a,b) a.x < b.x ? a : b\n\n#define planetSz 20.\n#define pi acos(-1.)\n#define pmod(p,a) mod(p - 0.5*a,a) - 0.5*a\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n\n// From https://github.com/armory3d/armory/blob/master/Shaders/std/tonemap.glsl\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\n\nvec2 ouv = vec2(0);\n  \nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n  vec3 dir = normalize(lookAt - ro);\n  vec3 right = normalize(cross(vec3(0,1,0),dir));\n  vec3 up = normalize(cross(dir,right));\n  return normalize(dir + right*uv.x + up*uv.y);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nfloat hash13(vec3 p3){\n    p3 = fract((p3)*0.1031);\n    p3 += dot(p3, p3.yzx  + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat valueNoise(vec3 uv,float pw){\n    vec3 id = floor(uv);\n    vec3 fd = fract(uv);\n    fd = smoothstep(0.,1., fd);\n    \n    fd = pow(fd,vec3(pw));\n    \n    float ibl = hash13(id + vec3(0,-1,0));\n    float ibr = hash13(id + vec3(1,-1,0));\n    float itl = hash13(id + vec3(0));\n    float itr = hash13(id + vec3(1,0,0));\n    \n    \n    float jbl = hash13(id + vec3(0,-1,1));\n    float jbr = hash13(id + vec3(1,-1,1));\n    float jtl = hash13(id + vec3(0,0, 1));\n    float jtr = hash13(id + vec3(1,0, 1));\n    \n    \n    float ibot = mix(ibl, ibr, fd.x); \n    float iup = mix(itl, itr, fd.x);\n    float jbot = mix(jbl, jbr, fd.x);\n    float jup = mix(jtl, jtr, fd.x);\n    \n    float i = mix(ibot, iup, fd.y);\n    float j = mix(jbot, jup, fd.y);\n    \n    return mix(i, j, fd.z); \n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\n\nfloat fa, fb, fc, fd;\n\nfloat fbm(vec3 p){\n\n    vec3 op = p;\n    float n = 0.;\n    p *= 0.25;\n    p.y += T*0.01;\n    fa = valueNoise(p,4.); \n    \n    p.y += fa*(1. + sin(op.z)*.8);\n    \n    fb = valueNoise(p*2.,1.);\n    \n    \n    fd = valueNoise(p*29.8,1.);\n    \n    fc = valueNoise(p*4.2,1.);\n    \n    \n\n    n = fa*1. + fb*0.55 + fc*0.244 + fd*0.046*(0. - fa) /*fa*/;// + valueNoise(op*5.8,1.)*0.0;\n    \n    n -= pow(\n      smoothstep( \n        0.,\n        1.,\n        valueNoise(p*0.1 + fb*0.05,3.)*1.5\n        )\n      ,2.2\n      )\n      *8.;\n  \n    n*= 0.6;\n\n\treturn n;\n}\n\n\nfloat sdCraters(vec3 _p, float md, float s){\n  vec4 p = vec4(_p,1.);\n  p.yw *= rot(0.4);\n  p = abs(p);\n  p.xz *= rot(0.4);\n  p = abs(p);\n  \n  p.xy *= rot(2.4);\n  p = abs(p);\n  \n  p.yz *= rot(.2);\n  p = pmod(p,md);\n  return length(p) - s;\n}\n\n#define xor(a,b,c) min(max(a,-(b)), max(-(a) + c,b))\n\n  #define pump(x,a) (floor(x) + pow(fract(x),a))\n\nfloat sdCube (vec4 p, vec4 s){p = abs(p) - s; return max(p.x, max(p.y, max(p.z, p.w)));}\nfloat sdCube (vec3 p, vec3 s){p = abs(p) - s; return max(p.x, max(p.y, p.z));}\nfloat sdPlane(vec3 p){\n    float d = 10e6;\n    \n    float s = 0.4;\n    \n    p /= s;\n    vec4 pp = vec4(p,1);\n    \n    d = sdCube(p,vec3(0.31));\n\n    for(int i = 0; i < 2; i++){\n            \n        float pmp = pump(T*0.2,4.);\n        pp.wz *= rot((0.25 + pmp*0.25 )*pi);\n        \n        pp.yz *= rot((0.25)*pi);\n        pp.xw *= rot((0.25 - pmp*0.5)*pi);\n        pp = abs(pp) - 0.1 ;\n        vec4 ppq = pp;\n        float doth = sdCube(ppq,vec4(0.922));\n        d = xor(d,doth,0.24);\n    }\n\n    d *= s;\n    \n    return d;\n}\n\nvec2 map(vec3 p){\n  vec2 d = vec2(10e5);\n  \n  vec3 pp = p;\n  \n  pp.y -= planetSz + 0.1;\n  \n  pp.y += sin(T)*0.01;\n  \n  #define tilt(x) sin(x + cos(x*0.4) - sin(x*0.2))\n  float tilt = tilt(T); \n  pp.x += tilt(T)*.5;\n  \n  \n  pp.z -= 3. + sin(pump(T*0.3,2.)*pi + pi/2.) + sin(T)*0.2;\n  \n  \n  float dTilt = (tilt(T + 0.1) - tilt(T + 0.))/0.1; \n  \n  pp.xy *= rot( -dTilt*0.2);\n  //pp *= rot();\n  float plane = sdPlane(pp);\n  \n  d = dmin(d,vec2(plane, 2.));\n  \n  \n  p.x += sin(T*0.2);\n  \n  p.yz *= rot((T*0.04));\n  \n  //p.z += sin(T*0.2)*2.;\n  float planet = length(p) - planetSz;\n  \n  \n  float craters = sdCraters(p + vec3(.4,0.3,0.4), 3., 1.1);\n  float cratersb = sdCraters(p + +vec3(1.4,0.3,0.4), 2.4,0.21);\n  float cratersc = sdCraters(p*10., 6.4,0.06)/10.;\n  \n  \n  planet = opSmoothSubtraction( -planet, -craters, 0.24);\n  planet = opSmoothSubtraction( -planet, -cratersb, 0.34);\n  planet = opSmoothSubtraction( -planet, -cratersc, 0.15);\n  planet -= fbm(p*10.1)*.06;\n  d = dmin(d,vec2(planet, 1.));\n  \n  \n  \n  \n  //d = dmin(d,vec2(craters, 1.));\n  \n  \n  \n  d.x *= 0.45;\n  return d;\n}\n\n\n//#define shortCompile min(iResolution.x,0.)\n#define shortCompile 0.\nvec3 getNormal(vec3 p){\n  vec2 t = vec2(0.03,0.);\n  return normalize(map(p).x - vec3(\n    map(p - t.xyy).x,\n    map(p - t.yxy).x,\n    map(p - t.yyx).x\n  ));\n  }\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt + shortCompile; )\n    {\n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}  \n  \nvoid mainImage(out vec4 C,in vec2 U)\n{\n\n  vec2 uv = vec2(U.x / iResolution.x, U.y / iResolution.y);\n  vec2 camOffs = vec2(sin(T*0.3),cos(T*0.5))*0.06;\n  uv += camOffs + vec2(iMouse.xy/iResolution.y)*0.04 - 0.02;\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  ouv = uv;\n  vec3 col = vec3(0);\n\n  vec3 ro = vec3(0);\n  //ro.z -= 2.;\n  \n  ro.y += planetSz + 1.5;\n  \n  //ro.x += sin(T*0.2);\n  \n  //ro.yz *= rot(T*0.2);\n  \n  //ro.z += sin(T*0.2)*2.;\n  vec3 lookAt = ro + vec3(0,-0.5,1);\n  \n  vec3 rd = getRd(ro, lookAt, uv);\n  \n  //rd.xy *= rot(-0.05);\n  float rdmod = sin(T*0.2)*0.125*pi/4.;\n  \n  //rd.yz *= rot( rdmod );\n  \n  vec3 p = ro;\n  bool hit = false;\n  \n  float iters = 200.;\n  float t = 0.;\n  vec2 d;\n  for(float i =0.; i < iters+ shortCompile; i++){\n    d = map(p);\n    \n      \n    if(d.x < 0.005 ){\n      hit = true;\n      break;\n    } else if(t > 15.){\n      break;\n    }\n    \n  \n    //p = ro + rd * (t += d.x) *max(1.,4.*i/iters);\n    p = ro + rd * (t += d.x)*max(1.,1.*i/iters);\n  \n  }\n  \n  vec3 fp = ro;\n  vec3 accumFog = vec3(0);\n  for(float i =0.; i < 16.+ shortCompile; i++){\n    float f = valueNoise(fp*.08 - T - fa*0.0,1.);\n    accumFog += f;\n    if(map(p).x < 0.0 ){\n      break;\n    } \n    fp += rd * 4.8;\n  }\n  vec3 lDir = normalize(vec3(0.8,-0.3,1.5));\n  vec3 lCol = vec3(1.4,0.4,0.41)*1.;\n  \n  \n  vec3 fogCol = vec3(0.4,0.2,0.15)*1.5;\n  \n  // darken fog\n  fogCol = mix(fogCol*vec3(1.,0.8,0.9)*0.1,fogCol,smoothstep(0.,1.,(length(p) - planetSz + 2.)*0.2+ t*0.16) );\n  if (hit){\n    vec3 n = getNormal(p);\n    vec3 hf = reflect(-lDir,n);\n    float diff = max(dot(n,lDir),0.);\n    float spec = pow(max(dot(-rd,hf),0.),32.);\n    float fres = pow(1. - max(dot(rd,-n),0.),5.);\n    \n    vec3 albedo = vec3(1,0.3,0.04)*0.4;\n    vec3 rockCol = vec3(0.2,0.4,0.34)*0.15;\n    albedo = mix(albedo, rockCol,pow(smoothstep(0.,1.,fb*fa), 2.));\n    \n    \n    if(d.y == 1.){\n        col += albedo + (spec*0.04  + fres*0.4) *( fogCol + lCol);\n    } else {\n        albedo = vec3(0.1,0.1,0.1);\n        col += albedo + (spec*0.74  + fres*0.9) *( fogCol + lCol);\n    }\n    \n    #define ao(a) smoothstep(0.,1.,map(p + n*a).x/a)\n    \n    float aoFact = ao(0.8)*ao(1.1)*ao(5.1)*3. + 0.575;\n    col *= aoFact;\n    \n    col *= mix(1.,softshadow( p, reflect(rd,n), 0.1, 5.,1.)*4.,0.6);\n    \n    col *= diff + lCol*0. + fogCol*0.25;\n  }\n  \n\n  col = mix(col,fogCol, smoothstep(0.,1.,t*(0.1  +accumFog/16.*0.2) - 0.51));\n\n  vec3 atmoCol = vec3(0.5,0.9,0.9);\n  //col += accumFog/16.*fogCol;\n  uv.y -= 0.3;\n  uv *= 1. - dot(uv,uv)*0.6;\n  uv.y += 0.3;\n  //vec3 atmoUpperCol = mix(vec3(0.5,0.6,0.9)*0.1,vec3(0.5,0.6,0.2)*1.4,smoothstep(0.,1.,(uv.y - 0.2)*2.));\n  vec3 atmoUpperCol = mix(vec3(0.5,0.6,0.9)*0.1,vec3(0.5,0.6,0.9)*0.1,smoothstep(0.,1.,(uv.y - 0.2)*2.));\n  \n\n  float sunModulator = sin(T + cos(T));\n    \n  float sunr = 0.998;\n\n  //rd.xz*=rot(sin(T*0.2)*0.02);\n  float sun = smoothstep(sunr,sunr*1.004,dot(lDir,rd));\n    //sun = 1. - sun;\n  vec3 sunCol = mix(lCol,lCol*vec3(1,1,0.4),1.-sun);  \n\n  vec3 sunColToAdd = sun*sunCol*3.*(2. + 2.*(1.-sunModulator) );\n\n  sunr = 0.921;\n\n  sun = smoothstep(sunr,sunr*4.,dot(lDir,rd));\n  sunColToAdd  += sun*sunCol*(52. + 17.*sunModulator*(4. + atmoCol));\n\n  vec2 sunPosUV = vec2(0.545,0.27);\n\n  sunColToAdd  += smoothstep(sunr,sunr*8.,dot(lDir,rd))*sunCol*12.;\n\n  vec2 suv = ouv - sunPosUV;\n\n  suv = abs(suv);\n\n  vec3 sunRays = 0.4*sunCol * smoothstep(0.035*(1. + smoothstep(1.,0.,abs(suv.x)) ) ,0.,abs(suv.y))*smoothstep(0.5,0.,abs(suv.x));\n    \n  for(float i = 0.; i < 24.; i++){\n      suv *= rot(pi/24.);\n      sunRays += .1* (sunCol) * smoothstep(0.04 + sin(i*4.)*0.01,0.,abs(suv.y))*smoothstep(0.2 + sin(i*8.)*0.1,0.,abs(suv.x));\n  }   \n  suv = ouv;\n  \n  suv -= sunPosUV;\n  \n  vec3 flares = vec3(0);\n  vec2 toMid = sunPosUV - camOffs*1.5;\n  vec2 dirToMid = -normalize(toMid);\n  float lenToMid = length(toMid);\n  \n  for(float i = 0.; i < 12.; i++){\n      suv -= 2.*lenToMid*dirToMid/12.;\n      float dfl = length(suv) - (0.1 + 0.1*sin(i*5.))*0.5;\n      dfl *= 0.5;\n      vec3 flare = 0.01*(sunCol)*smoothstep(0.02,0.,dfl);\n      flare += 0.003*(sunCol*sunCol)*smoothstep(0.01,0.,abs(dfl - dFdx(ouv.x)));\n      flares += flare*abs(sin(i*10.));\n  }   \n  \n  \n  \n  if (!hit){\n    \n    rd.yz *= rot(0.5*pi);\n    vec3 pC = vec3(length(rd), atan(rd.y,rd.x),0);\n    pC.z = acos(rd.z/pC.x);\n    \n    rd.yz *= rot(-0.5*pi);\n    \n    pC.yz*=rot(sin(T*0.2)*0.02);\n    \n    vec3 stars = vec3(0);\n    \n    float pw = 110.;\n    stars += pow(valueNoise(pC*72.,1.),pw);\n    stars += pow(valueNoise((pC + 4.)*102.,1.),pw); \n    stars += pow(valueNoise((pC + 14.)*102.,1.),pw);\n    stars += pow(valueNoise((pC + 12.)*102.,1.),pw);    \n    // stars += pow(valueNoise((pC + 4.)*12.,1.),1.1);    \n    \n    \n    float vn = valueNoise(uv.xyy + T,1.)*0.3;\n    \n    float ma = smoothstep(0.,1.,((uv.y)*1.9  + 0.07 - vn ));\n    float mab = smoothstep(0.,1.,((uv.y)*4.2 - 0.3   ));\n    \n    fogCol *= 1. + sin(uv.xyx + T)*0.1;\n    atmoCol *= 1. + sin(ouv.xyx + T)*0.1;\n    \n    \n    col = mix(fogCol,mix(atmoCol,stars + atmoUpperCol,mab),ma);\n      \n    //col = mix(col,(fogCol + lCol)*0.5 + fogCol*lCol , 1.*smoothstep(0.,1.,(uv.x*1.3 + 0.4)*(1.2 - ma)));\n     \n          \n    \n    //col += fract(pC.yxz*10.);\n    \n\n      \n  }\n  col += sunRays*smoothstep(sunr,sunr*1.004,dot(lDir,rd));\n\n  col += sunColToAdd;\n  col += flares;\n  \n  // lighrays\n  \n\n  col += texture(iChannel1,U/iResolution.xy).xyz*1.*(fogCol);\n  // gamma correction\n  //col = mix(col,smoothstep(0.,1.,col*1.),0.6);\n\n  col = mix(col,acesFilm(col),0.5);\n  col = pow(max(col,0.),vec3(0.454545));  col *= 1. - dot(ouv,ouv*0.2)*3.;\n  C = vec4(col,1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// Lens Dir\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\nvoid mainImage( out vec4 C, in vec2 U )\n{\n  vec2 uv = vec2(U / iResolution.y);\n  \n  vec3 sunCol = vec3(1);\n  \n  if(iFrame < 10){\n      for(float i = 0.; i < 42.; i++){\n          vec2 pos = hash33(vec3(i)).xy*vec2(iResolution.xy / iResolution.y);\n          float dfl = length(uv - pos) - (0.1 + 0.1*sin(i*5.))*0.5;\n          dfl *= 0.5;\n          vec3 flare = 0.01*(sunCol)*smoothstep(0.03,0.,dfl);\n          flare += 0.003*(sunCol*sunCol)*smoothstep(0.04,0.,abs(dfl - dFdx(uv.x)));\n          C += flare.xyzz*abs(sin(i*10.));\n      }\n  } else {\n    \n      C = texture(iChannel0,U/iResolution.xy);\n  }\n  \n  \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}