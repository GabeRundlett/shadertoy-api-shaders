{
    "Shader": {
        "info": {
            "date": "1410747241",
            "description": "An attempt to make demoscene production in Shadertoy",
            "flags": 8,
            "hasliked": 0,
            "id": "4sSSWz",
            "likes": 256,
            "name": "starDust",
            "published": 3,
            "tags": [
                "sound",
                "intro",
                "demoscene",
                "303"
            ],
            "usePreview": 0,
            "username": "and",
            "viewed": 16342
        },
        "renderpass": [
            {
                "code": "// starDust - shadertoy intro\r\n// Created by Dmitry Andreev - and'2014\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n#define SPEED           (1.7)\r\n#define WARMUP_TIME     (2.0)\r\n\r\n// Shadertoy's sound is a bit out of sync every time you run it :(\r\n#define SOUND_OFFSET    (-0.0)\r\n\r\nfloat saturate(float x)\r\n{\r\n    return clamp(x, 0.0, 1.0);\r\n}\r\n\r\nfloat isectPlane(vec3 n, float d, vec3 org, vec3 dir)\r\n{\r\n    float t = -(dot(org, n) + d) / dot(dir, n);\r\n\r\n    return t;\r\n}\r\n\r\nfloat drawLogo(in vec2 fragCoord)\r\n{\r\n    float res = max(iResolution.x, iResolution.y);\r\n    vec2  pos = vec2(floor((fragCoord.xy / res) * 128.0));\r\n\r\n    float val = 0.0;\r\n\r\n    // AND'14 bitmap\r\n    if (pos.y == 2.0) val = 4873761.5;\r\n    if (pos.y == 3.0) val = 8049199.5;\r\n    if (pos.y == 4.0) val = 2839721.5;\r\n    if (pos.y == 5.0) val = 1726633.5;\r\n    if (pos.x >125.0) val = 0.0;\r\n\r\n    float bit = floor(val * exp2(pos.x - 125.0));\r\n\r\n    return bit != floor(bit / 2.0) * 2.0 ? 1.0 : 0.0;\r\n}\r\n\r\nvec3 drawEffect(vec2 coord, float time)\r\n{\r\n    vec3 clr = vec3(0.0);\r\n    const float far_dist = 10000.0;\r\n\r\n    float mtime = SOUND_OFFSET + time * 2.0 / SPEED;\r\n    vec2 uv = coord.xy / iResolution.xy;\r\n\r\n    vec3 org = vec3(0.0);\r\n    vec3 dir = vec3(uv.xy * 2.0 - 1.0, 1.0);\r\n\r\n    // Animate tilt\r\n    float ang = sin(time * 0.2) * 0.2;\r\n    vec3 odir = dir;\r\n    dir.x = cos(ang) * odir.x + sin(ang) * odir.y;\r\n    dir.y = sin(ang) * odir.x - cos(ang) * odir.y;\r\n\r\n    // Animate FOV and aspect ratio\r\n    dir.x *= 1.5 + 0.5 * sin(time * 0.125);\r\n    dir.y *= 1.5 + 0.5 * cos(time * 0.25 + 0.5);\r\n\r\n    // Animate view direction\r\n    dir.x += 0.25 * sin(time * 0.3);\r\n    dir.y += 0.25 * sin(time * 0.7);\r\n\r\n    // Bend it like this\r\n    dir.xy = mix(vec2(dir.x + 0.2 * cos(dir.y) - 0.1, dir.y), dir.xy,\r\n        smoothstep(0.0, 1.0, saturate(0.5 * abs(mtime - 50.0))));\r\n\r\n    // Bend it like that\r\n    dir.xy = mix(vec2(dir.x + 0.1 * sin(4.0 * (dir.x + time)), dir.y), dir.xy,\r\n        smoothstep(0.0, 1.0, saturate(0.5 * abs(mtime - 58.0))));\r\n\r\n    // Cycle between long blurry and short sharp particles\r\n    vec2 param = mix(vec2(60.0, 0.8), vec2(800.0, 3.0),\r\n        pow(0.5 + 0.5 * sin(time * 0.2), 2.0));\r\n\r\n    float lt = fract(mtime / 4.0) * 4.0;\r\n    vec2 mutes = vec2(0.0);\r\n    \r\n    if (mtime >= 32.0 && mtime < 48.0)\r\n    {\r\n        mutes = max(vec2(0.0), 1.0 - 4.0 * abs(lt - vec2(3.25, 3.50)));\r\n    }\r\n    \r\n    for (int k = 0; k < 2; k++)\r\n    for (int i = 0; i < 64; i++)\r\n    {\r\n        // Draw only few layers during prologue\r\n        if (mtime < 16.0 && i >= 16) break;\r\n\r\n        vec3 pn = vec3(k > 0 ? -1.0 : 1.0, 0.0, 0.0);\r\n        float t = isectPlane(pn, 100.0 + float(i) * 20.0, org, dir);\r\n\r\n        if (t <= 0.0 || t >= far_dist) continue;\r\n\r\n        vec3 p = org + dir * t;\r\n        vec3 vdir = normalize(-p);\r\n\r\n        // Create particle lanes by quantizing position\r\n        vec3 pp = ceil(p / 100.0) * 100.0;\r\n\r\n        // Pseudo-random variables\r\n        float n = pp.y + float(i) + float(k) * 123.0;\r\n        float q = fract(sin(n * 123.456) * 234.345);\r\n        float q2= fract(sin(n * 234.123) * 345.234);\r\n\r\n        q = sin(p.z * 0.0003 + 1.0 * time * (0.25 + 0.75 * q2) + q * 12.0);\r\n\r\n        // Smooth particle edges out\r\n        q = saturate(q * param.x - param.x + 1.0) * param.y;\r\n        q *= saturate(4.0 - 8.0 * abs(-50.0 + pp.y - p.y) / 100.0);\r\n\r\n        // Fade out based on distance\r\n        q *= 1.0 - saturate(pow(t / far_dist, 5.0));\r\n\r\n        // Fade out based on view angle\r\n        float fn = 1.0 - pow(1.0 - dot(vdir, pn), 2.0);\r\n        q *= 2.0 * smoothstep(0.0, 1.0, fn);\r\n\r\n        // Flash fade left or right plane\r\n        q *= 1.0 - 0.9 * (k == 0 ? mutes.x : mutes.y);\r\n\r\n        // Cycle palettes\r\n        const vec3 orange = vec3(1.0, 0.7, 0.4);\r\n        const vec3 blue   = vec3(0.4, 0.7, 1.0);\r\n        clr += q * mix(orange, blue, 0.5 + 0.5 * sin(time * 0.5 + q2));\r\n\r\n        // Flash some particles in sync with bass drum\r\n        float population = mtime < 16.0 ? 0.0 : 0.97;\r\n\r\n        if (mtime >= 8.0 && q2 > population)\r\n        {\r\n            float a = mtime >= 62.0 ? 8.0 : 1.0;\r\n            float b = mtime <  16.0 ? 2.0 : a;\r\n\r\n            clr += q * (mtime < 16.0 ? 2.0 : 8.0)\r\n                * max(0.0, fract(-mtime * b) * 2.0 - 1.0);\r\n        }\r\n    }\r\n\r\n    clr *= 0.2;\r\n\r\n    // Cycle gammas\r\n    clr.r = pow(clr.r, 0.75 + 0.35 * sin(time * 0.5));\r\n    clr.b = pow(clr.b, 0.75 - 0.35 * sin(time * 0.5));\r\n\r\n    // Initial fade-in\r\n    clr *= pow(min(mtime / 4.0, 1.0), 2.0);\r\n\r\n    // Fade-out shortly after initial fade-in right before drums kick in\r\n    if (mtime < 8.0) clr *= 1.0 - saturate((mtime - 5.0) / 3.0);\r\n\r\n    // Flash horizon in sync with snare drum\r\n    if (mtime >= 15.0)\r\n    {\r\n        float h = normalize(dir).x;\r\n        clr *= 1.0 + 2.0 * pow(saturate(1.0 - abs(h)), 8.0)\r\n            * max(0.0, fract(-mtime + 0.5) * 4.0 - 3.0);\r\n    }\r\n\r\n    // The end\r\n    if (mtime >= 64.0) clr = vec3(0.0);\r\n\r\n    // Initial flash\r\n    if (mtime >= 16.0) clr += max(0.0, 1.0 - (mtime-16.0) * 1.0);\r\n\r\n    // Final flash\r\n    if (mtime >= 64.0) clr += max(0.0, 1.0 - (mtime-64.0) * 0.5) * vec3(0.8,0.9,1.0);\r\n\r\n    // Desaturate prologue\r\n    if (mtime < 16.0) clr = mix( vec3(dot(clr, vec3(0.33))), clr, min(1.0, mtime / 32.0));\r\n\r\n    // Vignette in linear space (looks better)\r\n    clr *= clr;\r\n    clr *= 1.4;\r\n    clr *= 1.0 - 1.5 * dot(uv - 0.5, uv - 0.5);\r\n    clr = sqrt(max(vec3(0.0), clr));\r\n\r\n    return clr;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    float time = max(0.0, iTime - WARMUP_TIME);\r\n    vec3  clr = vec3(0.0);\r\n\r\n    clr = drawEffect(fragCoord.xy, time);\r\n    clr = mix(clr, vec3(0.8, 0.9, 1.0), 0.3 * drawLogo(fragCoord));\r\n\r\n    fragColor = vec4(clr, 0.0);\r\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            },
            {
                "code": "// starDust - shadertoy intro\n// Created by Dmitry Andreev - and'2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define SPEED           (1.7)\n#define WARMUP_TIME     (2.0)\n\n#define PATLEN          (iSampleRate * SPEED)\n#define DELAY           (3.0 * PATLEN / 16.0)\n#define MASTER_VOLUME   (0.75)\n#define IIR_COUNT       (32)\n#define DO_DELAY        (1)\n\n#define PI              (3.1415)\n#define TWOPI           (6.2832)\n\n// Sound track data\n\n#define PAT_BEGIN int ph = p / 4; int pl = p - 4 * ph; if (false) {}\n#define PAT(idx, a,b,c,d, e,f,g,h, i,j,k,l, m,n,o,q) else if (pat==idx) { ivec4 v = ph < 2 ? (ph == 0 ? ivec4(a,b,c,d) : ivec4(e,f,g,h)) : (ph == 2 ? ivec4(i,j,k,l) : ivec4(m,n,o,q)); return pl < 2 ? (pl == 0 ? v.x : v.y) : (pl == 2 ? v.z : v.w); }\n#define PAT_END return 0;\n\nint drum_pat(int pat, int p)\n{\n    if (p==0 || p==4 || p==8 || p==12) return 1;\n    else return 0;\n}\n\nint snare_pat(int pat, int p)\n{\n    if (p==4 || p==12 || p==14 || p==15) return 1;\n    else return 0;\n}\n\nint bass_pat(int pat, int p)\n{\n    PAT_BEGIN\n    PAT(0,  16,  0, 28,  0, 16,  0, 28,  0, 16,  0, 28,  0, 16,  0, 28,  0)\n    PAT(1,  14,  0, 26,  0, 14,  0, 26,  0, 14,  0, 26,  0, 14,  0, 26,  0)\n    PAT(2,  12,  0, 24,  0, 12,  0, 24,  0, 12,  0, 24,  0, 12,  0, 24,  0)\n    PAT_END\n}\n\nint bass_seq(int p)\n{\n    if (p==0 || p==4 || p==8 || p==9 || p==12 || p==13) return 0;\n    else if (p==1 || p==3 || p==5 || p==7) return 1;\n    else return 2;\n}\n\nint lead_pat(int pat, int p)\n{\n    PAT_BEGIN\n    PAT(0,  24, 50, 24, 24, 48, 55, 24, 48, 50, 24, 55, 50, 24, 50, 24, 48)\n    PAT(1,  28, 52, 28, 28, 50, 55, 28, 50, 52, 28, 55, 52, 28, 52, 28, 50)\n    PAT(2,  26, 54, 26, 26, 50, 57, 26, 50, 52, 26, 64, 55, 26, 52, 26, 50)\n    PAT(3,  24, 52, 24, 24, 48, 55, 24, 48, 52, 24, 55, 52, 24, 52, 24, 48)\n    PAT_END\n}\n\nint lead_seq(int p)\n{\n    if (p==10 || p==11 || p==14 || p==15) return 0;\n    else if (p==1 || p==3 || p==5 || p==7) return 2;\n    else if (p==2 || p==6) return 3;\n    else return 1;\n}\n\n// Synth utilities\n\nfloat note2Freq(int note)\n{\n    if (note == 0) return 0.0;\n\n    return 16.35 * pow(1.059463, float(note));\n}\n\nfloat limit(float wave)\n{\n    return clamp(wave, -1.0, 1.0);\n}\n\nvec2 limit(vec2 wave)\n{\n    return clamp(wave, vec2(-1.0), vec2(1.0));\n}\n\nvec2 compress(vec2 wave, float env)\n{\n    return wave * clamp(env, 0.0, 1.0);\n}\n\nint imod(int x, int y)\n{\n    return x - (x / y) * y;\n}\n\n// Waveforms\n\nfloat saw(float phi)\n{\n    return (phi - floor(phi)) * 2.0 - 1.0;\n}\n\nfloat square(float phi)\n{\n    return sin(TWOPI * phi) > 0.0 ? 1.0 : -1.0;\n}\n\nfloat noise(float phi)\n{\n    return fract(sin(phi * 0.011753) * 122.3762) * 2.0 - 1.0;\n}\n\n// Sequencer that converts global sample position into\n// internal pattern positions and basic note envelopes\n\nstruct SequencerState\n{\n    float i;\n    float q;\n    int   p;\n    int   seqpos;\n    float env;\n    float env_mv;\n    float env2;\n};\n\nSequencerState initSequencer(float i)\n{\n    SequencerState s;\n\n    s.i = i;\n    s.q = 16.0 * fract(i / PATLEN);\n    s.p = int(s.q);\n    s.seqpos = int(i / PATLEN);\n\n    // envelopes\n    s.env = max(0.0, 1.0 - s.q + float(s.p));\n    s.env2 = s.env * s.env;\n    s.env_mv = s.env * 0.125;\n\n    return s;\n}\n\n// Infinite impulse response (IIR) filter\n//  note that this exact filter was used in all of AND 64k and 4k intros\n\nstruct Resonator\n{\n    float pos;\n    float vel;\n};\n\nResonator initResonator(void)\n{\n    Resonator r;\n\n    r.pos = 0.0;\n    r.vel = 0.0;\n\n    return r;\n}\n\nResonator updateResonator(Resonator r, float rfrq, float ramp, float x)\n{\n    float fx = cos(rfrq * TWOPI / iSampleRate);\n    float fx_m = fx - 1.0;\n    float fx_m3 = fx_m * fx_m * fx_m;\n    float c = 2.0 - fx - fx;\n    float v = (1.41 * sqrt(-fx_m3) + ramp * fx_m) / (ramp * fx_m);\n\n    r.vel += (x - r.pos) * c;\n    r.pos += r.vel;\n    r.vel *= v;\n\n    return r;\n}\n\nstruct Mixer\n{\n    vec2  lead;\n    float lead_fq;\n    vec2  bass;\n    vec2  hihat;\n    vec2  snare;\n    vec2  drum;\n    vec2  crash;\n};\n\nvec2 synthWave(float i, Mixer m)\n{\n    vec2 wave = vec2(0.0);\n    SequencerState s = initSequencer(i);\n\n    if (s.seqpos < 32)\n    {\n        float phi;\n        int   note;\n\n        note = lead_pat(lead_seq(imod(s.seqpos, 16)), s.p);\n        float nfrq = note2Freq(note);\n\n        // Lead\n        if (nfrq > 0.0)\n        {\n            Resonator r = initResonator();\n\n            for (int n = IIR_COUNT; n >= 0; n--)\n            {\n                float ii = i - float(n);\n                SequencerState s = initSequencer(ii);\n\n                float phi = s.env_mv * nfrq;\n                float val = sqrt(s.env) * saw(phi);\n                val = limit(val * 5.0);\n\n                float rfrq = m.lead_fq * (32.0 * s.env * phi\n                    + 2900.0 + 2400.0 * cos(0.25 * PI * ii / PATLEN));\n\n                if (s.seqpos < 4 || s.seqpos >= 31) rfrq *= 0.25;\n\n                r = updateResonator(r, rfrq, 8.0, val);\n            }\n\n            wave = m.lead * vec2(r.pos);\n            wave = limit(wave * 3.0);\n        }\n\n        // Bass\n        note = bass_pat(bass_seq(imod(s.seqpos, 16)), s.p);\n        if (s.seqpos >= 4 && note > 0)\n        {\n            wave = compress(wave, 2.5 - s.env * 2.0);\n\n            phi = s.env * note2Freq(note) * 0.0625;\n            float bass_wave = s.env * (square(phi) + square(phi * 1.001));\n\n            wave += m.bass * vec2(bass_wave);\n        }\n\n        // Hi-hat\n        if (s.seqpos >= 8)\n        {\n            float env = imod(s.p, 4) == 2 ?\n                2.0 * sqrt(s.env) // open\n                : 1.3 * s.env2 ;  // closed\n\n            wave += m.hihat * 0.7 * env * (noise(i + 0.1) + 0.3 * sin(80.0 * i));\n        }\n\n        // Snare drum\n        if (s.seqpos >= 7)\n        {\n            float env = pow(s.env, 0.7);\n\n            wave += m.snare * 0.9 * env * (1.5 * noise(i) + 0.3 * sin(100.0 * i))\n                * (s.seqpos >= 31 ? 1.0 : float(snare_pat(0, s.p)));\n        }\n\n        // Bass drum\n        if (s.seqpos >= 4)\n        {\n            if (drum_pat(0, s.p) > 0 || s.seqpos >= 31)\n            {\n                wave = compress(wave, 1.5 - s.env * 0.8);\n\n                wave += m.drum * (\n                            sin( 50.0 * s.env + 0.33)\n                    + 2.0 * sin(100.0 * s.env2)\n                    + 1.6 * sin(150.0 * pow(s.env2, 32.0)));\n            }\n        }\n    }\n    else\n    {\n        // Crash cymbal\n        float env = pow( max(0.0, 1.0 - 0.25 * ((i / PATLEN) - 32.0)), 20.0);\n        i = floor(i / 4.0) * 4.0;\n        wave += m.crash * env * (noise(i) + 0.3 * sin(10.0 * i));\n    }\n\n    wave = limit(wave * 0.2);\n\n    return wave;\n}\n\nvec2 mainSound( in int samp,float time)\n{\n    time = max(0.0, time - WARMUP_TIME);\n    float i = time * iSampleRate;\n\n    Mixer m;\n    m.lead  = vec2(0.9, 0.4);\n    m.lead_fq = 1.0;\n    m.bass  = vec2(0.8, 1.0);\n    m.hihat = vec2(0.5, 1.0);\n    m.snare = vec2(1.0, 1.0);\n    m.drum  = vec2(1.0, 0.9);\n    m.crash = vec2(1.5, 1.5);\n\n    vec2 wave = synthWave(i, m);\n\n    #if DO_DELAY\n    if (i >= DELAY && (i / PATLEN) < 32.0)\n    {\n        m.lead  = vec2(0.3, 0.6);\n        m.lead_fq = 0.8;\n        m.bass  = vec2(0.5, 0.2);\n        m.hihat = vec2(0.8, 0.3);\n        m.snare = vec2(0.3, 0.3);\n        m.drum  = vec2(0.2, 0.4);\n        m.crash = vec2(0.0, 0.0);\n\n        wave += synthWave(i - DELAY, m);\n    }\n    #endif\n\n    wave = limit(wave * MASTER_VOLUME);\n\n    return wave;\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}