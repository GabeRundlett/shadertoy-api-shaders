{
    "Shader": {
        "info": {
            "date": "1581427948",
            "description": "Seems different to https://www.shadertoy.com/view/3ttXW7 i think it should be more accurate, but also i think its not.\n(define PATH CALCULATION MODE to 1 to see the other way (which should be less acurate?))\ndefine eyes for 3d view\nmouse to look arround",
            "flags": 0,
            "hasliked": 0,
            "id": "ttcXzX",
            "likes": 1,
            "name": "Black Hole Render (my approach)",
            "published": 3,
            "tags": [
                "blackhole",
                "raypath"
            ],
            "usePreview": 0,
            "username": "Txoka",
            "viewed": 520
        },
        "renderpass": [
            {
                "code": "#define R iResolution\n//#define eyes\n\n#define PATH_CALCULATION_MODE 0\n\nconst float march_step_size=0.1;\nconst float eps=1e-5;\nconst int STEPS=128;\n\nstruct ray{\n\tvec3 ro;\n    vec3 rd;\n};\n\n//gravitational lens force\nvec4 glf(vec3 p,vec3 lens_pos,float lens_size){\n    p-=lens_pos;\n    return vec4(-normalize(p)/dot(p,p),-1./length(p))*lens_size;\n}\n\n//all forces (you can add more gravitational lenses)\nvec4 map(vec3 p){\n    vec4 n=glf(p,vec3(0),0.4);//vec4(force (vec3), potential (float))\n\t//n+=glf(p,vec3(4.*cos(iTime*.3),0.,4.*sin(iTime*.3)),0.3);\n    return n;\n}\n\nvoid march(inout ray r){\n    for(int i=0;i<STEPS;i++){\n    \tvec4 m=map(r.ro);\n        float step_size=march_step_size/(eps-m.w);\n        #if PATH_CALCULATION_MODE==0\n        r.rd=normalize(r.rd+step_size*m.xyz);\n        #else\n        r.rd=normalize(r.rd+0.1*m.xyz);\n        #endif\n        r.ro+=r.rd*step_size;\n        if(m.w>-0.01)break;\n    }\n}\n\nconst float pi=4.*atan(1.);\nvoid mainImage(out vec4 Q, in vec2 U){\n    vec3 uv = vec3((U*2.-R.xy)/R.y,1);\n    vec2 m=(iMouse.xy*2.-R.xy)/R.xy;\n    m*=vec2(1,0.5)*pi;\n    //if(iMouse.z<=0.)m=vec2(-iTime/3.,0.05);\n    if(length(iMouse.xy)==0.)m=vec2(0);\n    \n    #ifdef eyes\n    vec3 ro=vec3(-0.2,0,0);\n    if(uv.x<0.)ro.x=0.2;\n    uv.xy+=ro.xy*5.;\n    #else\n    vec3 ro=vec3(0,0,0);\n    #endif\n    \n    ro.yz*=mat2(cos(m.y),-sin(m.y),sin(m.y),cos(m.y));\n    ro.xz*=mat2(cos(m.x),-sin(m.x),sin(m.x),cos(m.x));\n    uv.yz*=mat2(cos(m.y),-sin(m.y),sin(m.y),cos(m.y));\n    uv.xz*=mat2(cos(m.x),-sin(m.x),sin(m.x),cos(m.x));\n    \n    vec3 pos=vec3(0,0,sin(iTime/10.*pi/4.)*5.);\n    ray r=ray(ro-pos,normalize(uv-ro));\n    \n    march(r);\n    float potential=map(r.ro).w;\n    Q=texture(iChannel0,r.rd)/(1.-potential);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}