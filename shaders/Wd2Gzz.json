{
    "Shader": {
        "info": {
            "date": "1548096681",
            "description": "Flying through the upper atmosphere of a gas giant. Rendered at half resolution with volumetric cone tracing. Click the screen to look around.",
            "flags": 32,
            "hasliked": 0,
            "id": "Wd2Gzz",
            "likes": 41,
            "name": "Gas Giant Flyby",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "volume",
                "raymarch",
                "cloud",
                "space"
            ],
            "usePreview": 0,
            "username": "Klems",
            "viewed": 1305
        },
        "renderpass": [
            {
                "code": "\n// Buffer A shader runs the volumetric rendering at half the resolution.\n// Image shader reconstructs the frame and apply tonemapping/gamma/dithering.\n// The cloud landscape is a repeated distance field deformed with texture based noise.\n// Outside the shape, the cone can raymarch and skip empty space very quickly.\n// Inside the shape, we raymarch and accumulate opacity along a cone.\n// We break when the accumulated opacity is close to 1 or when we hit the sky.\n// Filtered value noise (through 3D textures) is used for opacity/coloring.\n\n// Lighting is done by taking the derivative of the opacity/distance field in the\n// direction of the light source. During lightning, the direction is blended\n// toward the closest lightning bolt.\n// https://iquilezles.org/articles/derivative\n\n// Fog is tweaked from iq formula taken from here.\n// https://iquilezles.org/articles/fog\n\n// from https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit( in vec3 v ) {\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvec3 ACESFitted( in vec3 color ) {\n    color = color * ACESInputMat;\n    color = RRTAndODTFit(color);\n    color = color * ACESOutputMat;\n    color = clamp(color, 0.0, 1.0);\n    return color;\n}\n\n// Dave_Hoskins hash\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nvec3 hash33( in vec3 p3 ){\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n// checkerboard reconstruction and tonemapping\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // render at half resolution (checkerboard rendering)\n    vec2 ch = vec2( step(mod(fragCoord.x + fragCoord.y, 2.0), 0.5), 0 );\n    vec4 a = texelFetch(iChannel0, ivec2( (fragCoord+ch.xy) * vec2(0.5,1) ), 0);\n    vec4 b = texelFetch(iChannel0, ivec2( (fragCoord+ch.yx) * vec2(0.5,1) ), 0);\n    vec4 c = texelFetch(iChannel0, ivec2( (fragCoord-ch.xy) * vec2(0.5,1) ), 0);\n    vec4 d = texelFetch(iChannel0, ivec2( (fragCoord-ch.yx) * vec2(0.5,1) ), 0);\n    fragColor = (a+b+c+d)*0.25;\n    \n    // exposition\n    fragColor.rgb *= 1.4;\n    // vignette\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    fragColor.rgb *= (1.0-dot(uv,uv)*0.1);\n    // tonemapping\n    fragColor.rgb = ACESFitted(fragColor.rgb);\n    // gamma correction\n    fragColor.rgb = pow( fragColor.rgb, vec3(1.0/2.2) );\n    // dithering\n    fragColor.rgb += (hash33(vec3(fragCoord, iFrame))-0.5)*0.03;\n    \n    fragColor.a = 1.0;\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define PI 3.14159265359\n#define rot(a) mat2(cos(a+PI*vec4(0,1.5,0.5,0)))\n\n#define MARCH_EPS 0.1\n#define MARCH_MIN_STEP 0.02\n#define MARCH_STEPS 300\n#define FOV (PI*0.7)\n\n#define BACKGROUND vec3(0.25, 0.37, 0.4)\n#define COLOR_SUN vec3(0.8, 0.7, 0.5)\nconst vec3 sunDir = normalize(vec3(-1, 6, 3));\nfloat time = 0.0;\nfloat yCamera = 0.0;\n\n// Dave_Hoskins hash\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nfloat hash11( in float p ) {\n\tvec3 p3 = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash33( in vec3 p3 ){\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n// raytrace a plane, used for the rings\nfloat raytracePlane(in vec3 from, in vec3 dir,\n                    in vec3 planePos, in vec3 planeNormal ) {\n    float originDist = -dot(planePos, planeNormal);\n    float t = -(dot(planeNormal, from)+originDist)/dot(planeNormal, dir);\n    if ( t > 0.0 )\n        return t;\n    return -1.0;\n}\n\n// iq's smin\nfloat smin( in float d1, in float d2, in float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// iq's smax\nfloat smax( in float d1, in float d2, in float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n// smooth abs from above\n/*float smoothAbs( in float x, in float k ) {\n    float h = clamp( 0.5 + x/k, 0.0, 1.0 );\n    return mix( -x, x, h ) + k*h*(1.0-h);\n}*/\n\n// return center of hex tile\n/*vec2 hexCenter( in vec2 p ) {\n    #define HEX vec2(1, 1.73205080757)\n    vec2 centerA = (floor(p.xy*HEX)+0.5)/HEX;\n    vec2 centerB = (floor((p.xy+HEX*0.5)*HEX)+0.5)/HEX-HEX*0.5;\n    vec2 a = p.xy-centerA.xy; vec2 b = p.xy-centerB.xy;\n    return dot(a,a)<dot(b,b) ? centerA : centerB;\n}*/\n\n// noise with smooth derivative\nvec4 snoise( in vec3 x, const in float lod ) {\n    float dim = 32.0 / exp2(lod);\n    x = x * dim;\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    x = (p+f+0.5) / dim;\n    return textureLod(iChannel0, x, lod);\n}\n\n// filtered noise\nvec4 noise( in vec3 x, in float freq, in float r ) {\n    x *= (1.0/32.0) * freq;\n    float lod = log2(r*freq+1.0);\n    return textureLod(iChannel0, x, lod);\n}\n\n// fog color\nvec3 getFog( in vec3 dir ) {\n    float d = dot(dir, sunDir) * 0.5 + 0.5;\n    d *= d; d *= d; d *= d;\n    return mix(BACKGROUND, COLOR_SUN, d);\n}\n\n// iq's analytical fog\nfloat getFog( in vec3 rgb, in float dist, in vec3 rayOri, in vec3 rayDir ) {\n    const float c = 0.3;\n    const float b = 1.0;\n    float fogAmount = c * exp(-rayOri.z*b) * (1.0-exp( -dist*rayDir.z*b ))/rayDir.z;\n    fogAmount = 1.0 - exp(-fogAmount*1.0);\n    return min(fogAmount, 1.0);\n}\n\n// wrap tunnel around camera\nvec3 cameraPath( in float y ) {\n    return vec3(12.75 - sin(y*0.1312 - time*0.2)*3.0, y, 1.0 - sin(y*0.1)*1.0);\n}\n\n// return thunder for this location\nvec4 getThunder( in float y ) {\n    float cell = floor(y*0.1)+0.5;\n    float rnd = hash11(cell);\n    float per = (rnd*4.0+1.5);\n    float frac = fract((time + rnd)/per);\n    float ti = floor((time + rnd)/per);\n    float alpha = smoothstep(0.0, 0.03, frac);\n    alpha *= smoothstep(0.2, 0.05, frac);\n    // return thunder strength in w\n    vec3 pos = vec3(cameraPath(cell/0.1).xy, -3.0 + hash11(ti)*1.0);\n    return vec4(pos, alpha);\n}\n\n// sample the procedural field inside a sphere\nfloat map( in vec3 p, in float r, out vec4 color ) {\n    \n    // curve the world a tiny bit around the camera\n    float l = abs(yCamera - p.y);\n    p.z += l*l*0.00005;\n    \n    // bounding box optimisation\n    vec2 inBB = vec2(abs(p.x), 35.0 - p.z);\n    float bb = -inBB.y;\n    bb = max(bb, inBB.x-80.0);\n    if (bb > 1.0) {\n\t\tcolor = vec4(-1);\n        return bb;\n    }\n    \n    vec3 camera = cameraPath(p.y);\n    float tunnel = 0.3 - length(p.xz-camera.xz);\n    float dist = p.z+100.0;\n\t\n    // keep position and scale\n    vec4 pf = vec4(p, 0.01);\n    pf.xyz *= pf.w;\n    // add some perturbation\n    float q = sin(pf.x*14.331)*1.0 + sin(p.y*0.1312-time*0.2)*1.5 + sin(pf.y*9.312)*0.3;\n    // keep tornados uv\n    vec4 inTorn = pf;\n    \n    for (float i = 0.99 ; i < 5.0 ; i += 1.0) {\n        if (i < 3.0) {\n        \tpf.xyz += (snoise(pf.xyz*vec3(2.124, 2.2314, 10.347), 2.0).xyz-0.5)*0.06;\n        }\n        \n        pf *= 4.5 - i*0.25;\n        pf.x = abs(pf.x) - 0.5 + q*0.07;\n        pf.y = abs(fract(pf.y)-0.5);\n        vec4 potTorn = pf - vec4(2,0,0,0);\n        \n        // rounded corner\n        float d = length(max(vec2(1.5, -0.5)-pf.xz*vec2(1,-1)*rot(0.15),0.0))-0.1;\n        // rounded cylinder\n        float m = sin(pf.z*50.0)*0.01 + sin(pf.z*q*2.0)*0.1;\n        float dd = length(min(vec2(0.4 + m,0.9)-(vec2(length(potTorn.xy),pf.z)),0.0))-0.1;\n        \n        d = smin(d, dd, 0.1 + i*0.1) / pf.w;\n        \n        if (d < dist) inTorn = potTorn;\n        dist = smin(d, dist, 0.015);\n    }\n    \n    // add lightning\n    vec4 thu = getThunder(p.y);\n    vec3 inThun = p-thu.xyz;\n    vec2 th = vec2(length(inThun.xz)-1.5 + sin(atan(inThun.x, inThun.z) * 12.0 +\n                                               time*12.0)*0.03, inThun.y);\n    float d = length(th)-0.15*(thu.w)+0.1;\n    if (d < 0.0) {\n        color = vec4(10);\n        return 0.0;\n    }\n    \n    dist = smax(dist, tunnel, 0.2);\n    dist = min(dist, d);\n    \n    if (dist > r) {\n        color = vec4(0);\n        return dist;\n    }\n\t\n    pf.xyz /= pf.w;\n    vec3 pp = vec3(pf.x, p.y, pf.z);\n    pp.y -= time*0.5;\n    pp.y *= 0.5;\n    pp.zx *= rot(2.4412);\n    pp.yz *= rot(0.2317);\n    float alpha = noise(pp, 0.35, r*2.0).y*0.75;\n    pp.xy *= rot(1.3187);\n    pp.zy *= rot(0.2317);\n    alpha += noise(pp, 1.5, r*2.0).y*0.5;\n    pp.yx *= rot(4.5187);\n    pp.zy *= rot(3.8317);\n    alpha += noise(pp, 8.5, r*2.0).y*0.7;\n    \n    alpha *= alpha;\n    alpha *= alpha;\n    alpha = atan(1.0 * alpha) / (0.5 * PI);\n    alpha *= alpha;\n    alpha *= 8.0;\n    alpha *= 1.0 - exp(dist*1.0*pow(inTorn.w, 1.5));\n    alpha = min(alpha, 1.0);\n    \n    float col = pf.z-inTorn.z*10.0;\n    col = sin(col*0.6) + sin(col*0.5) + sin(col*0.4);\n    col = col * 0.2 + 0.5;\n    color.rgb = vec3( sin(col * vec3(3, 4, 5)) * 0.5 + 0.5 );\n    color.a = alpha;\n    color.a *= smoothstep(r, -r, dist);\n    color = clamp(color, 0.0, 1.0);\n    \n    return dist;\n}\n\n// return sun and rings\nvec3 getBack( in vec3 dir ) {\n    float d = dot(dir, sunDir);\n    \n    vec3 fog = getFog(dir);\n    vec3 base = mix(fog*0.1, fog*0.8, smoothstep(0.8, 0.0, dir.z));\n    \n    base += exp((d-1.0)*5000.0) * COLOR_SUN * 10.0;\n    base += exp((d-1.0)*400.0) * COLOR_SUN * 2.0;\n    \n    float planeDist = raytracePlane(vec3(0, 0, 1), dir, vec3(0),\n                                    normalize(vec3(-9, -1.8, 2)));\n    if (planeDist > 0.0) {\n        vec3 p = vec3(0, 0, 1) + dir*planeDist;\n        \n        float l = length(p);\n        float s = smoothstep( 0.66, 0.55, abs(l-2.0) );\n        s += smoothstep( 0.01, 0.00, abs(l-1.33) );\n        s = min(s, 1.0);\n        float r = texture(iChannel0, vec3(0, 0, l*0.3)).r*0.5;\n        r += texture(iChannel0, vec3(0, 0, l*2.0)).r*0.85;\n        vec3 col = vec3( sin(r * 0.9 * vec3(3, 4, 5)) * 0.5 + 0.5 );\n        col = mix(col, vec3(1), 0.7);\n        float al = texture(iChannel0, vec3(0, 0, l*0.8)).r;\n        al = smoothstep(0.2, 0.8, al);\n        float m = smoothstep( 0.2, 0.0, abs(l-2.9) )*0.7;\n        base = mix(base, col*vec3(1.0, 0.9, 0.6), s*al + m);\n    }\n    \n    base = mix(base, fog, smoothstep(0.1, 0.0, dir.z));\n    \n    return base;\n}\n\n// volumetric rendering at half resolution, in linear space\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // render at half resolution (checkerboard rendering)\n    if (fragCoord.x > iResolution.x * 0.5) {\n        fragColor = vec4(0);\n        return;\n    } else {\n    \tfragCoord.x = floor(fragCoord.x) * 2.0 + mod(fragCoord.y, 2.0);\n    }\n    \n    \n    vec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.x;\n    float fovScale = tan(FOV*0.5);\n\tvec3 dir = (vec3(uv.x*fovScale, 1.0, uv.y*fovScale));\n\tdir.y += exp(length(uv)*2.0) * 0.1;\n    dir = normalize(dir);\n    \n\tvec2 mouse = vec2(0);\n    if (iMouse.z > 0.5) {\n        mouse = (iMouse.xy-iMouse.zw)*0.01;\n    }\n    \n    // get random values\n    vec3 dither = hash33(vec3(fragCoord, iFrame));\n    // add motion blur\n    time = iTime + dither.y * (1.0/60.0);\n    // camera position\n    yCamera = time*2.0 - 25.0;\n    vec3 from = cameraPath(yCamera);\n    vec3 target = cameraPath(yCamera+0.1);\n    vec3 targetDir = normalize(target-from);\n    dir.yz *= rot(-asin(targetDir.z));\n    dir.xy *= rot(atan(targetDir.x, targetDir.y));\n    dir.yz *= rot(-mouse.y + 0.1);\n    dir.xy *= rot(mouse.x);\n    \n    // sine of the pixel angle\n    float sinPix = sin(FOV/iResolution.x*0.5)*2.0;\n    // accumulate color front to back\n    vec4 acc = vec4(0, 0, 0, 1);\n    \n    vec4 dummy = vec4(0);\n    float d = map(from, 0.0, dummy);\n    float totdist = max(MARCH_MIN_STEP, d)*dither.x*1.0;\n    vec4 fog = vec4(getFog(dir), 0);\n    vec3 offset = (hash33(vec3(0, 0, iFrame))-0.5)*0.4;\n    \n    for (int i = min(0, iFrame) ; i < MARCH_STEPS ; i++) {\n        \n        // sample the field here\n        vec3 p = from + totdist * dir;\n        float r = max(MARCH_MIN_STEP*0.5, sinPix*totdist);\n        vec4 color = vec4(0);\n        float d = map(p, r, color);\n        \n        if (color.a < -0.5) {\n            totdist = 9e9;\n            break;\n        } else if (d > r) {\n            // away from the surface, skip\n            totdist += max(MARCH_MIN_STEP, d*0.9);\n        } else {\n            \n            bool arc = color.a > 5.0;\n            \n            // blend sample point toward sun/lightning\n            vec4 thun = getThunder(p.y);\n            vec3 inThun = thun.xyz-p + offset;\n            float lenThun = length(inThun);\n            float len = smoothstep(4.0, 0.5, lenThun);\n            vec3 sampDir = normalize(mix(sunDir, inThun/lenThun, thun.w*len*len));\n            \n            // get another sample and run lighting\n            vec3 samp = p + sampDir*MARCH_EPS;\n            vec4 colorD = vec4(0);\n            float dD = map(samp, r, colorD);\n            vec2 derivV = vec2(color.a-colorD.a, dD-d)/MARCH_EPS;\n            float deriv = mix(derivV.x, derivV.y,\n                              (1.0-thun.w*len)*smoothstep(4.0, 0.0, abs(d)));\n            \n            // ad hoc formula for lighting\n            deriv = atan(6.0 * deriv) / (0.5 * PI) * 0.5 + 0.5;\n            deriv *= deriv;\n            deriv = mix(deriv, 1.0, smoothstep(3.5, 0.0, lenThun)*thun.w);\n            \n            color.rgb *= mix(deriv, 1.0, thun.w*len)*COLOR_SUN;\n            color.rgb += exp(-lenThun*7.0+8.0)*thun.w*1000.0 * vec3(0.3, 0.6, 0.8);\n            \n            // apply fog\n            fog.a = getFog( color.rgb, totdist, from, dir );\n            color.rgb = mix(color.rgb, fog.rgb, fog.a);\n            \n            // inside the surface, enable cone-tracing\n            color.a = 1.0 - pow(1.0 - color.a, r*20.0);\n            // overwrite for lightning\n            if (arc) color = vec4(vec3(3), 1);\n            color.a *= smoothstep(r, -r, d);\n            \n            // accumulate color\n            acc.rgb += acc.a * (color.a*color.rgb);\n        \tacc.a *= (1.0 - color.a);\n            \n            // we can break if the accumulated alpha is 1\n            if ( acc.a < 0.01 ) break;\n            \n            // go forward\n            totdist += r*2.0;\n        }\n    }\n    \n    // add volumetric rendering on top of the background\n    vec3 back = getBack(dir);\n    fog.a = getFog( back, totdist, from, dir);\n    back.rgb = mix(back.rgb, fog.rgb, fog.a);\n    fragColor.rgb = acc.a*back+acc.rgb;\n    fragColor.rgb = max(fragColor.rgb, 0.0);\n    \n    fragColor.a = 1.0;\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "volume",
                        "id": 40,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}