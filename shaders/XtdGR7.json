{
    "Shader": {
        "info": {
            "date": "1468734524",
            "description": "Music: https://soundcloud.com/rrlewis2/ott-hello-my-name-is",
            "flags": 64,
            "hasliked": 0,
            "id": "XtdGR7",
            "likes": 282,
            "name": "[SH16B] WIP: Warp Tunnel",
            "published": 3,
            "tags": [
                "sh16b"
            ],
            "usePreview": 1,
            "username": "stubbe",
            "viewed": 75780
        },
        "renderpass": [
            {
                "code": "const float PI = 3.1415926535;\nconst float SPEED = 10.0;\nconst float ARMS = 3.0;\nconst vec2 EPSILON = vec2(0, .005);\n\nconst vec3 sunDir = vec3(-0.363696,0.581914,0.727393);//normalize(vec3(-.5,.8,1));\nconst vec3 sunColor = vec3(3,2,1);\n\nfloat time;\nfloat z_offset;\nfloat tunnelShake;\n\nvec2 rotate(vec2 p, float a)\n{\n    return vec2(cos(a)*p.x + sin(a)*p.y, -sin(a)*p.x + cos(a)*p.y);\n}\n\nfloat Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n    return -1.0+2.0*mix( rg.x, rg.y, f.z );\n}\n\nfloat Map3( in vec3 p )\n{\n    vec3 q = p;\n    float f;\n    f  = 0.50000*Noise( q ); q = q*2.02;\n    f += 0.25000*Noise( q ); q = q*2.03;\n    f += 0.12500*Noise( q ); q = q*2.01;\n    return f;\n}\n\nfloat Map5( in vec3 p )\n{\n    vec3 q = p;\n    float f;\n    f  = 0.50000*Noise( q ); q = q*2.02;\n    f += 0.25000*Noise( q ); q = q*2.03;\n    f += 0.12500*Noise( q ); q = q*2.01;\n    f += 0.06250*Noise( q ); q = q*2.02;\n    f += 0.03125*Noise( q );\n    return f;\n}\n\nmat4 LookAt(vec3 pos, vec3 target, vec3 up)\n{\n    vec3 dir = normalize(target - pos);\n    vec3 x = normalize(cross(dir, up));\n    vec3 y = cross(x, dir);\n    return mat4(vec4(x, 0), vec4(y, 0), vec4(dir, 0), vec4(pos, 1));\n}\n\nvec2 TunnelCenter(float z)\n{\n    return vec2(sin(z*.17)*.4,sin(z*.1+4.))*3. * tunnelShake;\n}\n\nfloat GetAngle(vec3 pos)\n{\n    return atan(pos.y,pos.x) - pos.z*.25 + time*3.7 + sin(time)*.2;\n}\n\n\nvec3 Fresnel(vec3 R0, vec3 normal, vec3 viewDir)\n{\n    float NdotV = max(0., dot(normal, viewDir));\n    return R0 + (vec3(1.0) - R0) * pow(1.0 - NdotV, 5.0);\n}\n\nfloat Map(vec3 pos)\n{\n    pos.z -= z_offset;\n    pos.xy -= TunnelCenter(pos.z);\n    float fft = textureLod( iChannel3, vec2(0.5,0.15), 0.0).x;\n    float angle = GetAngle(pos);\n    float r = sin(pos.z*.1)*0.5 + 3. + Map5(pos)*.3 + fft * 2.0 + sin(angle*ARMS)*.3;\n    //r += texture( iChannel3, vec2(fract(pos.z*.1),0.0) ).x;\n    return length(pos.xy) - r;\n}\n\nvec3 Normal(vec3 pos)\n{\n    vec2 e = vec2(0, .05);\n    return normalize(vec3(Map(pos + e.yxx), Map(pos + e.xyx), Map(pos + e.xxy)) - Map(pos));\n}\n\nfloat IntersectPlanets(vec3 pos, vec3 dir, out vec3 normal, out float max_d, out int type)\n{\n    const float PLANET_CYCLE = 25.0;\n    const int PLANET_PASSES = 3;\n    float best_dist = 1e10;\n    bool hit = false;\n    max_d = -1e10;\n    for(int i = 0; i < PLANET_PASSES; i++)\n    {\n        int tp = i;\n        if(tp >= 3) tp-=3;\n        float time2 = time + 15.5*float(i);\n        float planetRound = floor(time2 / PLANET_CYCLE);\n        float planetPos = time2 - planetRound * PLANET_CYCLE;\n        float planetAngle = planetRound * 23.1;\n        float planetDistance =  (tp==0) ? 20. :\n        \t\t\t\t\t\t(tp==1) ? 13. :\n        \t\t\t\t\t\t13.;\n        vec3 sphereCenter = vec3(cos(planetAngle)*planetDistance,sin(planetAngle)*planetDistance,(PLANET_CYCLE- planetPos)*10.);\n        vec3 delta = pos - sphereCenter;\n        float sphereRadius = \t(tp==0) ? 13. :\n        \t\t\t\t\t\t(tp==1) ? 7. :\n        \t\t\t\t\t\t7.;\n    \n        float B = dot(dir, delta);\n        float C = dot(delta, delta) - sphereRadius * sphereRadius;\n        float D = B*B - C;\n        \n        if(D >= 0.0)\n        {\n            float t = -B - sqrt(D);\n            if(t >= 0. && t < best_dist)\n            {\n                vec3 spherePos = pos + t * dir;\n                normal = normalize(spherePos - sphereCenter);\n                best_dist = t;\n                type = tp;\n                hit = true;\n            }\n        }\n        max_d = max(max_d, D);\n    }\n    return hit ? best_dist : -1.;\n}\n\nfloat EarthHeight(vec3 pos)\n{\n    vec2 coord = vec2(acos(pos.y)/(2.0*PI), atan(pos.x, pos.z)/(2.0*PI));\n    vec3 te = texture( iChannel2, coord ).rgb + texture( iChannel2, coord*3.0 ).rgb * .3;\n    float landLerp = smoothstep( 0.45, 0.5, te.x);\n    vec3 albedo = mix( vec3(0.1, 0.2, 0.45), (vec3(0.055, 0.275, 0.0275) + 0.45*te + te*te*0.5*texture( iChannel2, 2.0*coord.xy ).xyz)*0.4, landLerp );\n    return length(pos) - albedo.x*.015;\n}\n\nvec3 BackgroundInner(vec3 pos, vec3 dir, bool enableSun, out bool sphereHit, out vec3 spherePos, out vec3 sphereNormal, out vec3 reflectivity)\n{\n    vec3 nebulaPos = dir.yxz;\n    float v = Map5(nebulaPos*1.3 + Map5(nebulaPos*0.5)*3.0) + .1;\n    v = max(v, 0.);\n    \n    vec3 color = v*mix(vec3(1.,.2,2), vec3(2,.2,10), clamp(Map3(dir*1.3),0.,1.)) + 0.1;\n    \n    vec2 uv = vec2(acos(dir.x), atan(dir.y,dir.z));\n    \n    vec3 a = texture( iChannel1, uv*1.5).rgb;\n    \n    vec3 b = texture( iChannel1, uv*0.4).rgb;\n    \n    color *= (a * b) * 4.;\n    color += pow(texture(iChannel1, uv*1.0).rgb, vec3(4.0)) * 0.5;\n    if(enableSun)\n    {\n        float sunDot = max(0., dot(dir, sunDir));\n        color += (pow(sunDot, 8.0)*.03 + pow(sunDot, 512.0)) * 5. * sunColor;\n    }\n\n    sphereHit = false;\n    reflectivity = vec3(0);\n    float max_d;\n    int type;\n    float t = IntersectPlanets(pos, dir, sphereNormal, max_d, type);\n    if(t >= 0.0)\n    {\n        spherePos = pos + t * dir;\n        vec2 coord = vec2(acos(sphereNormal.y)/(2.0*PI), atan(sphereNormal.x, sphereNormal.z)/(2.0*PI));\n        float time_offset = time*.04;\n        coord.y += time_offset;\n\n        if(type == 0)\n        {\n            float offset = texture( iChannel2, coord ).r * .005;\n            vec3 lookup = sphereNormal;\n            lookup.xy = rotate(lookup.xy, time_offset*2.0*PI);\n            float height = Map5(lookup*4.)*.5+.8;//texture( iChannel2, coord + vec2(offset)).r;\n            height = pow(min(height, 1.),8.);\n            vec3 fire = (texture( iChannel2, coord*5. + time*.02).rgb +\n                         texture( iChannel2, coord*1. + time*.006).rgb\n\n                        ) * vec3(3,1,1) * .5;\n\n            vec3 albedo = texture( iChannel2, coord + vec2(offset)).rgb * .25 -\n                          texture( iChannel2, coord*7.0).rgb * .1;\n            color = albedo * max(0., dot(sphereNormal, sunDir)) * sunColor + fire * pow(1.0-height,16.);\n        }\n        else if(type == 2)\n        {\n            vec3 te = texture( iChannel2, coord ).rgb + texture( iChannel2, coord*3.0 ).rgb * .3;\n        \n            float offset = 0.0 + texture( iChannel2, coord).x*.003;\n            vec3 albedo = (texture( iChannel2, coord*vec2(.4,0)+vec2(offset,0) ).rgb-.5)*.7 + .4;\n            albedo += texture( iChannel2, coord*1.0).rgb * .2;\n            albedo += texture( iChannel2, coord*16.0).rgb * .075;\n            color = albedo * max(0., dot(sphereNormal, sunDir)) * sunColor;\n        }\n        else if(type == 1)\n        {\n            vec3 te = texture( iChannel2, coord ).rgb + texture( iChannel2, coord*3.0 ).rgb * .3;\n\n            vec3 bumpedNormal = normalize(vec3(EarthHeight(sphereNormal + EPSILON.yxx), EarthHeight(sphereNormal + EPSILON.xyx), EarthHeight(sphereNormal + EPSILON.xxy)) - EarthHeight(sphereNormal));\n            sphereNormal = bumpedNormal;\n            float landLerp = smoothstep( 0.45, 0.5, te.x);\n            vec3 albedo = mix( vec3(0.1, 0.2, 0.45), (vec3(0.055, 0.275, 0.0275) + 0.45*te + te*te*0.5*texture( iChannel2, 2.0*coord.xy ).xyz)*0.4, landLerp );\n            float specPower = mix(2048., 32., landLerp);\n            float q = (  texture( iChannel2, coord+vec2(0,time*.02) ).x +\n                            texture( iChannel2, coord*2.0+vec2(0,time*.013) ).x) * .5;\n\n            float skyLerp = smoothstep( 0.4, 0.8, q);\n            reflectivity = mix(vec3(0.1), vec3(0.0), skyLerp);\n\n            float NdotL = max(0., dot(sphereNormal, sunDir));\n            vec3 opaque = albedo * NdotL * sunColor;\n            color = opaque + pow(max(0., dot(bumpedNormal, normalize(-dir + sunDir))), specPower) * (specPower + 8.0) / (8.0 * PI) * sunColor * reflectivity;\n\n            vec3 sky = vec3(0.9) * NdotL * sunColor;\n            color = mix( color, sky, skyLerp);        \n        }\n\n        sphereHit = true;\n    }\n    \n    return color;\n}\n    \nvec3 Background(vec3 pos, vec3 dir)\n{\n    dir = normalize(dir);\n    \n    bool sphereHit;\n    vec3 spherePos;\n    vec3 sphereNormal;\n    vec3 reflectivity;\n    vec3 color = BackgroundInner(pos, dir, true, sphereHit, spherePos, sphereNormal, reflectivity);\n    if(sphereHit)\n    {\n        vec3 R = Fresnel(reflectivity, sphereNormal, -dir);\n\n        vec3 reflectionDir = reflect(dir,sphereNormal);\n        bool dummyHit;\n        vec3 dummyPos;\n        vec3 dummyNormal;\n        color += (BackgroundInner(spherePos + sphereNormal*.01, reflectionDir, false, dummyHit, dummyPos, dummyNormal, reflectivity)*(1.0-R)+vec3(1,2,3)*.075)*R*sunColor;\n    }\n    \n    return color;\n}\n\n\nvec3 LensFlare(vec2 x)\n{\n    x = abs(x);\n    float e = 1.5;\n    float d = pow(pow(x.x*.5, e) + pow(x.y*3., e), 1./e);\n    \n    vec3 c = vec3(exp(-2.5*d))*sunColor*(.3+sin(x.y*iResolution.y*2.)*.01) * .5;\n    c += vec3(exp(-dot(d,d)))*sunColor*.05;\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    time = iTime;\n    vec3 camPos = vec3(0);\n    z_offset = time*SPEED;\n \n    float introFade = min(time*.05, 1.0);\n    \n    float camZoom = 3.0 - introFade*2.0;\n    \n    tunnelShake = introFade;\n    camPos.xy += TunnelCenter(camPos.z-z_offset)*.5;\n    vec3 camTarget = vec3(0,0,5);\n    camTarget.xy += TunnelCenter(camTarget.z-z_offset)*.5;\n    //camTarget = vec3(3,0,5);\n    camTarget = mix(vec3(3,0,5), camTarget, introFade);\n    \n    float camAngle = sin(time*.3) + time*.1;\n    vec3 camUp = vec3(sin(camAngle),cos(camAngle),0);\n\n    mat4 viewToWorld = LookAt(camPos, camTarget, camUp);\n    vec2 uv2 = (fragCoord - .5*iResolution.xy) / (iResolution.y * camZoom);\n    vec3 eyeDir = (viewToWorld * normalize(vec4(uv2, 1, 0))).xyz;\n    \n    float t = 0.0;\n    vec3 p = camPos;\n    float iterationCount = 0.0;\n    for(int i = 0; i < 70; i++)\n    {\n        float dist = Map(p);\n        \n        t += dist;\n        p += dist*eyeDir;\n        iterationCount++;\n        if(abs(dist) < .001) break;\n    }\n    \n    \n    vec3 normal = Normal(p);\n    vec3 refraction = refract(normalize(eyeDir), normal, 1.012);\n    vec3 reflection = reflect(-normalize(eyeDir), normal);\n    vec3 halfDir = normalize(sunDir - eyeDir);\n    vec2 circlePos = p.xy - TunnelCenter(p.z - z_offset);\n    float angle = atan(circlePos.y,circlePos.x);\n    \n    float z = p.z - z_offset;\n    \n    vec3 R = Fresnel(vec3(0.0), normal, -eyeDir);\n    //vec3 c = mix(vec3(2,1,1),vec3(1,1,2),sin(p.z*.1)*.5+.5);\n    vec3 c = vec3(1);\n    vec3 outColor = Background(p, refraction)*(vec3(1.0) - R)*c + Background(p, -reflection)*R;\n    \n    float fft = texture( iChannel3, vec2(0.2,0.25) ).x;\n    fft = max(.0, fft - .5);\n    \n    float tunnelDist = length(p - camPos);\n    outColor = outColor * exp(-tunnelDist*.05) + (1.0-exp(-tunnelDist*.05))*vec3(2,1,3)*(.1+fft*.6);\n    \n    outColor += sqrt(iterationCount)*.005;\n    \n    vec3 sunPos = (vec4(sunDir, 0) * viewToWorld).xyz;\n    vec2 sunUV = sunPos.xy / sunPos.z;\n\n    float vignette = uv.x * (1.0-uv.x) * uv.y * (1.0-uv.y) * 32. * 0.75 + 0.25;\n    outColor *= vignette;\n    \n    vec3 sphereNormal;\n    float max_d;\n    int type;\n    float planet_t = IntersectPlanets(camPos, sunDir, sphereNormal, max_d, type);\n    float lensIntensity = clamp(1.0 - max_d*.02, 0.0, 1.0);\n    \n    outColor += LensFlare(uv2 - sunUV) * lensIntensity;\n    outColor += LensFlare(uv2 + sunUV) * .4 * lensIntensity;\n\n    outColor = clamp(outColor, 0.0, 1.0);\n    outColor *= vec3(sqrt(min(time*.2, 1.0)));\n    fragColor = vec4( outColor, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "musicstream",
                        "id": 4023,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/rrlewis2/ott-hello-my-name-is"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}