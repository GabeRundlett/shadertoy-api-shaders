{
    "Shader": {
        "info": {
            "date": "1720966832",
            "description": "[A] Draw Wall \n[R,G,B] Draw Light ( !Must Near Walls! )\n[C] Clear\n[V] Clear All\n[I] Res Init All\nDebug:\n[1] Light  and Wall\n[2]\n[3] SDF\n[4] \nTry {Sky}\nSky integral formula [url=/view/NttSW7]by Mathis[/url]",
            "flags": 48,
            "hasliked": 0,
            "id": "4fsyR7",
            "likes": 1,
            "name": "ElectroLight",
            "published": 3,
            "tags": [
                "mouse",
                "interactive",
                "sdf",
                "global",
                "illumination",
                "light",
                "electro",
                "electro",
                "tracing",
                "drawing",
                "trace",
                "path",
                "radiance",
                "cascade"
            ],
            "usePreview": 0,
            "username": "vec2",
            "viewed": 180
        },
        "renderpass": [
            {
                "code": "vec4 post(vec4 x, float k) {\nx=(2.0 / 3.141592653589793) * atan(k * x);\n//x=smoothstep(0.0,1.0,x);\n return x;\n}\nvoid mainImage( out vec4 C, in vec2 D )\n{\nC=vec4(0.0,0.0,0.0,0.0);\n\n\n\n\nif(key(49))C =texelFetch(iChannel0,ivec2(D),0)*0.1+texelFetch(iChannel0,ivec2(D),0).w*0.2;\nelse if(key(50))C.x =mod( sdfElectro(D-iResolution.xy*0.5,iResolution.y*0.3) *0.1,1.0)+0.3*sign(sdfElectro(D-iResolution.xy*0.5,iResolution.y*0.3) );\nelse if(key(51))C.x =mod( sqrt(texelFetch(iChannel1,ivec2(D),0).z)*0.1,1.0);\nelse if(key(52))C =texelFetch(iChannel2,ivec2(D),0);\nelse C = post( texelFetch(iChannel2,ivec2(D),0) ,1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\nvoid Draw(out vec4 C, const vec2 D, vec4 Mouse, vec4 Color, float size)\n{\n    if(length(Mouse.xy - D.xy) < size && Mouse.z > 0.0)\n    {\n        C += Color;\n    }\n    if(length(Mouse.xy - D.xy) < size + 5.0 && Mouse.z > 0.0)\n    {\n        C += Color * vec4(1., 1., 1., 0.);\n    }\n}\n\nvoid mainImage(out vec4 C, in vec2 D)\n{\n    C = texelFetch(iChannel0, ivec2(D), 0);\n    vec4 Mouse = iMouse;\n    vec4 Color;\n    float size = DrawingSize;\n     if(texelFetch(iChannel1, ivec2(86, 0), 0).x > 0.5){C =vec4(0.0);return;}\n       // if(texelFetch(iChannel1,ivec2(32,0),0).x>0.5)Color = vec4(1.0,0.0,0.0,0.0);//space\n    if(texelFetch(iChannel1, ivec2(82, 0), 0).x > 0.5)\n        Color = vec4(1.0, 0.0, 0.0, 0.0); //r\n    else if(texelFetch(iChannel1, ivec2(71, 0), 0).x > 0.5)\n        Color = vec4(0.0, 1.0, 0.0, 0.0); //g\n    else if(texelFetch(iChannel1, ivec2(66, 0), 0).x > 0.5)\n        Color = vec4(0.0, 0.0, 1.0, 0.0); //b\n    else if(texelFetch(iChannel1, ivec2(65, 0), 0).x > 0.5)\n        Color = vec4(0.0, 0.0, 0.0, 1.0); //a\n    else if(texelFetch(iChannel1, ivec2(67, 0), 0).x > 0.5)\n    {\n        Color = vec4(-1.0, -1.0, -1.0, -1.0);\n        size *= 2.0;\n    } //c\n    else\n        Mouse.z = -1.0;\n\n\n    if(iMouse.xy == vec2(-1110.0))\n    {\n        \n        float iTime = iTime * 3.0;\n        float t = iTime * 0.5;\n        Mouse.xy = vec2(\n            cos(3.14159 * t) + sin(0.72834 * t + 0.3),\n            sin(2.781374 * t + 3.47912) + cos(t)\n        ) * 0.25 + 0.5;\n        Mouse.xy *= R.xy;\n        Mouse.z = 1.0;\n        Color.xyz = cos(iTime + vec3(0, 2, 4));\n        Color.w = 1.0;\n        size = (cos(iTime * 0.1) + 2.0) * 10.0;\n        if(((iFrame / 30) & 1) == 1)\n        {\n            Color = vec4(-2.0);\n            size *= 2.0;\n        }\n        if(((iFrame / 60) & 1) == 1)\n        {\n            Color.xyz = vec3(-1.0);\n        }\n        Draw(C, D, Mouse, Color, size);\n        C = clamp(C, 0.0, 2.0);\n         \n    }\n    if(iFrame == 0||texelFetch(iChannel1, ivec2(73, 0), 0).x > 0.5)\n    {\n   \n    //    if(abs(sdfBox(D - R.xy * 0.5, R.xy * 0.5 - 10.0)) < 2.0)C = vec4(0.0, 0.0, 0.0, 1.0);\n      //  if(sdfBox(D - R.xy * 0.5, R.xy * vec2(0.2, 0.005)) < 0.0)C = vec4(0.0, 0.0, 0.0, 1.0);\n      //  if(sdfBox(D - R.xy * 0.5, R.xy * vec2(0.005, 0.3)) < 0.0)C = vec4(0.0, 0.0, 0.0, 1.0);\n        if(sdfBox(D - R.xy * vec2(0.89, 0.05+0.1 ), R.xy * vec2(0.009, 0.2/3.0)) < 0.0)C += vec4(6.0, 0.0, 0.0, 0.0);\n        if(sdfBox(D - R.xy * vec2(0.89, 0.05+0.2 ), R.xy * vec2(0.009, 0.2/3.0)) < 0.0)C += vec4(0.0, 6.0, 0.0, 0.0);\n        if(sdfBox(D - R.xy * vec2(0.89, 0.05+0.3 ), R.xy * vec2(0.009, 0.2/3.0)) < 0.0)C += vec4(0.0, 0.0, 6.0, 0.0);\n        if(sdfBox(D - R.xy * vec2(0.903, 0.25), R.xy * vec2(0.009, 0.2)) < 0.0)C += vec4(0.0, 0.0, 0.0, 1.0);\n        if(sdfBox(D - R.xy * vec2(0.803, 0.25), R.x * vec2(0.02, 0.02)) < 0.0)C += vec4(0.0, 0.0, 0.0, 1.0);\n        if(sdfBox(D - R.xy * vec2(0.8, 0.75), R.x * vec2(0.1, 0.1)) < 0.0)C = vec4(0.0, 0.0, 0.0, 1.0);\n        if(sdfBox(D - R.xy * vec2(0.79, 0.75), R.x * vec2(0.1, 0.09)) < 0.0)C = vec4(0.0, 2.0, 0.0, 0.0);\n        if(sdfElectro(D - R.xy * vec2(0.34, 0.50), R.x * 0.17) < 0.0)C = vec4(0.0, 0.0, 0.0, 1.0);\n        if(sdfSphere(D - R.xy * vec2(0.34, 0.50), R.x * 0.05) < 0.0)C.xyz += vec3(0.2, 0.0, 2.0)*3.0;\n        if(sdfSphere(D - R.xy * vec2(0.34, 0.50), R.x * 0.16) < 0.0)C.xyz += vec3(1.0, 0.0, 2.0)*0.2;\n        if(abs(sdfSphere(D - R.xy * vec2(0.34, 0.50), R.x * 0.17)) < R.x * 0.01)C.xyz += vec3(0.3, 0.0, 2);\n        \n    }\n    \n    Draw(C, D, Mouse, Color, size);\n\n    C = max(C, 0.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n\nconst ivec2 offsets[] = ivec2[](\n    ivec2(-1,0), ivec2(1,0), ivec2(0,-1), ivec2(0,1),\n    ivec2(-1,1), ivec2(1,-1), ivec2(-1,-1), ivec2(1,1)\n);\n\nbool isOccupied(const ivec2 pos) {\n    return texelFetch(iChannel0, pos, 0).w > 0.5;\n}\n\nvoid mainImage(out vec4 color, in vec2 uv) {\n    if(iFrame%Debugsteptime!=0){color=texelFetch(iChannel1, ivec2(uv), 0);return;}\n    int iFrame=iFrame/Debugsteptime;\n\n    vec4 nearest = texelFetch(iChannel1, ivec2(uv), 0);\n    if (iFrame % lod ==0) {\n    color.w = sqrt(nearest.z);       \n    }else color.w =nearest.w;\n    \n    if (isOccupied(ivec2(uv)) && (iFrame%lod==0 || ShowAllFrame==1)) \n    {\n        color.xyz = vec3(uv, 0.0);\n        return;\n    }\n\n    if (iFrame == 0) \n    {\n        color.xyz = vec3(-1.0);\n        return;\n    }\n\n    \n    for (int i = 0; i < 8; ++i) {\n#ifdef UsePow2 \n        int step = 1 << (lod - 1 - (iFrame) % lod);\n#else\n        int step = int(pow(3.0,float(lod - 1 -(iFrame) % lod)));\n#endif\n        ivec2 pos = ivec2(uv) + offsets[i] * step;\n        if (!(pos.x >= 0 && pos.y >= 0 && pos.x < int(iResolution.x) && pos.y < int(iResolution.y))) continue;\n\n        vec4 candidate = texelFetch(iChannel1, pos, 0);\n        candidate.z = dot(candidate.xy - uv, candidate.xy - uv);\n        if (texelFetch(iChannel1,ivec2(candidate.xy),0).xy==candidate.xy&& (candidate.z < nearest.z || nearest.z < 0.0)) {\n            nearest = candidate;\n        }\n    }\n\n    if (!isOccupied(ivec2(nearest.xy))&& (iFrame%lod==0 || ShowAllFrame==1)) {\n        color.xyz = vec3(-1.0);\n        return;\n    }\n    color.xyz = nearest.xyz;\n \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Buffer:[A] the color[xyz] wall[w]\n// Buffer:[B] the MinDistancePixel[xy] DistanceSquare[z] Distance[w]\n// Buffer:[C] the Light[xyz]  \n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n\n\n\n\nconst float DrawingSize=12.;\nconst float angleStep = 1.0 / 16.0;\n#define ShowAllFrame 0\n#define Sky (0)\n\nconst int Debugsteptime=1;//30;\n\n// use pow 2 or pow 3\n//#define UsePow2\nconst int lod = 7;//2^10=1024\n\n#define LightSmooth (16.0)\n#define key(k) (texelFetch(iChannel3,ivec2(k,0),0).x>0.5)\n float hash1(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n float hash1(float p)\n{\n    return hash1(vec2(p, 0));\n}\n float hash1(vec4 p4)\n{\n    p4 = fract(p4 * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy + 33.33);\n    return fract((p4.x + p4.y) * (p4.z + p4.w));\n}\n#define R iResolution\n\nfloat sdfBox(vec2 p, vec2 b)\n{\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\nfloat sdfLine(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\nfloat sdCircleArcTriangle(vec2 p, vec2 v1, vec2 v2, float r)\n{\n    float len = length(p);\n    float2 cp=(v1+v2)*0.5;\n    float le=length(cp);\n    return max(len-r, -dot(p,(cp)/le)+le );        \n}\nfloat sdCircleArcTriangle(vec2 p, vec2 a/*angle*/, float r)\n{\n    float2 v1 = float2(cos(a.x),sin(a.x))*r; \n    float2 v2 = float2(cos(a.y),sin(a.y))*r; \n    return sdCircleArcTriangle(p,v1,v2,r);        \n}\nfloat2 ComplexMul(const float2 z1, const float2 z2)\n{\n    return float2(\n        z1.x * z2.x - z1.y * z2.y,\n        z1.x * z2.y + z1.y * z2.x\n    );\n}\n\nfloat sdfSphere(float2 p, float r)\n{          \n    return length(p) - r;\n}\n#define PI2 2.0*3.141592653589793\n#define add(d,s) d=min(d,s)\n#define sub(d,s) d=max(d,-s)\n//雷标 by https://www.bilibili.com/video/BV1kqhieGE3H\nfloat sdfElectro(float2 p, float r) {\n    float d = uintBitsToFloat(0x7f7fffffu);\n    float d1 = uintBitsToFloat(0x7f7fffffu);\n    d = sdfSphere(p, r * 0.46 / 2.0);\n    for (float i = 0.0; i < PI2; i += PI2 / 3.0) {\n        float2 v = float2(cos(i), sin(i)) * r;\n        sub(d, sdfSphere(p - ComplexMul(v, float2(0.23, 0.398371685740842)), r * 0.388371685740842));\n    }\n    for (float i = 0.0; i < PI2; i += PI2 / 3.0) {\n        float2 v = float2(cos(i), sin(i)) * r;\n        add(d1, sdfSphere(p, r));\n        sub(d1, sdfSphere(p - ComplexMul(v, float2(-0.46, 0.0)), r * 1.171049240405192));\n        sub(d1, sdfSphere(p - ComplexMul(v, float2(0.193301270189222, -0.234807621135332)), r * 0.840177040641766));\n        float d2 = uintBitsToFloat(0x7f7fffffu);\n        add(d2, sdfSphere(p - ComplexMul(v, float2(0.236602540378444, 0.209807621135332)), r * 0.579721443061983));\n        sub(d2, sdfSphere(p - ComplexMul(v, float2(0.186698729810778, 0.423371685740842)), r * 0.415580291234265));\n        sub(d2, sdfSphere(p - ComplexMul(v, float2(0.193301270189222, -0.234807621135332)), r * 0.227658190923347));\n        sub(d2, sdfSphere(p - ComplexMul(v, float2(-1.0, 0.0)), r * 1.23));\n        add(d1, d2);\n        d = min(d, d1);\n    }\n    return d;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "const float PI = 3.1415927;\nvec3 integrateSkyRadiance_(vec2 angle) {\n    // Sky radiance helper function\n    float a1 = angle[1];\n    float a0 = angle[0];\n    \n    // Sky integral formula taken from\n    // Analytic Direct Illumination - Mathis\n    // https://www.shadertoy.com/view/NttSW7\n    const vec3 SkyColor = vec3(0.2,0.5,1.);\n    const vec3 SunColor = vec3(1.,0.7,0.1)*10.;\n    const float SunA = 2.0;\n    const float SunS = 64.0;\n    const float SSunS = sqrt(SunS);\n    const float ISSunS = 1./SSunS;\n    vec3 SI = SkyColor*(a1-a0-0.5*(cos(a1)-cos(a0)));\n    SI += SunColor*(atan(SSunS*(SunA-a0))-atan(SSunS*(SunA-a1)))*ISSunS;\n    return SI / 6.0;\n}\n\nvec3 integrateSkyRadiance(vec2 angle) {\n    // Integrate the radiance from the sky over an interval of directions\n    if (angle[1] < 2.0 * PI) {\n        return integrateSkyRadiance_(angle);\n    }\n    \n    return\n        integrateSkyRadiance_(vec2(angle[0], 2.0 * PI)) +\n        integrateSkyRadiance_(vec2(0.0, angle[1] - 2.0 * PI));\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvec4 traceRay(const vec2 origin, const vec2 direction) {\n    float depth = 0.0;\n    for (int i = 0; i < 32; i++) {\n        vec2 pos = origin + direction * depth;\n        float dist = texture(iChannel1, pos / iResolution.xy).w;\n        depth += dist;\n        if (dist < 2.0) {\n            vec3 color = texelFetch(iChannel2, ivec2(pos+direction*1.1  ), 0).xyz *1.5;\n            color += texelFetch(iChannel0, ivec2(pos-direction *5.0), 0).xyz * 0.8;\n            return vec4(color, depth);\n        }\n#if Sky\n        if(!(all(lessThan(vec2(0.0,0.0),pos))&&all(lessThan( pos,iResolution.xy))))\n        {\n         //Sky\n        return  vec4(vec3(10.0*pow(max( dot(direction,vec2(-0.74935529040989,0.662168142343551)),0.0),145.0)) ,10.0)+vec4(2.0*-integrateSkyRadiance(vec2(atan(direction.y,direction.x)+0.4,atan(direction.y,direction.x)-1.0)),10.0);\n        }\n#endif\n    }\n    return vec4(-1.0, -1.0, -1.0, -1.0); // HLSL need it\n}\nfloat randangle(in vec2 fragCoord)\n{\n \nreturn mod(texelFetch(iChannel3,ivec2(fragCoord)%textureSize(iChannel3,0),0).x+float(iFrame)*sqrt(2.0),1.0);\n// return hash1(vec4(vec2(fragCoord), iFrame, 0.0));\n//return float((iFrame*1)%int(LightSmooth))/LightSmooth;\n}\n#define PI 3.141592653589793\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n\n   \n    for (float angle = randangle(fragCoord)* PI * (angleStep) * 2.0; angle < PI * 2.0; angle += PI * (angleStep) * 2.0) {\n        vec2 dir = vec2(cos(angle), sin(angle));\n        vec4 hit = traceRay(fragCoord, dir);\n        if (hit.w > 0.0) {\n            result.xyz += hit.xyz * angleStep ;//* (exp(-hit.w * 0.00001));\n        }\n    }\n   \n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor *=1.0- 1.0/LightSmooth;\n    fragColor += result * 1.0/LightSmooth;\n    // fragColor.xyz = fragColor.xyz * 2.0 - smoothstep(0.0, 1.0, fragColor.xyz);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}