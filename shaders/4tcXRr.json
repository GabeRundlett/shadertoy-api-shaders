{
    "Shader": {
        "info": {
            "date": "1477599524",
            "description": "A weird alien core, using raymarching. Click to turn around. \nTry changing the texture, there are interesting patterns to find...",
            "flags": 0,
            "hasliked": 0,
            "id": "4tcXRr",
            "likes": 133,
            "name": "Alien Core",
            "published": 3,
            "tags": [
                "raymarching",
                "sphere",
                "abstract",
                "wtf",
                "dirtycode"
            ],
            "usePreview": 1,
            "username": "glkt",
            "viewed": 5701
        },
        "renderpass": [
            {
                "code": "// GLKITTY 2016.\n\nvec3 rotateY(vec3 v, float t){\n    float cost = cos(t); float sint = sin(t);\n    return vec3(v.x * cost + v.z * sint, v.y, -v.x * sint + v.z * cost);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat noise(vec3 p){\n    \n    float t = iTime;\n    vec3 np = normalize(p);\n    \n    // kind of bi-planar mapping\n    float a = texture(iChannel0,t/20.+np.xy).x;      \n    float b = texture(iChannel0,t/20.+.77+np.yz).x;\n    \n    a = mix(a,.5,abs(np.x));\n    b = mix(b,.5,abs(np.z));\n    \n    float noise = a+b-.4;    \n    noise = mix(noise,.5,abs(np.y)/2.);\n        \n    return noise;\n}\n\nfloat map(vec3 p){\n    \n    // spheres\n    float d = (-1.*length(p)+3.)+1.5*noise(p);    \n    d = min(d, (length(p)-1.5)+1.5*noise(p) );  \n    \n    // links\n    float m = 1.5; float s = .03;    \n    d = smin(d, max( abs(p.x)-s, abs(p.y+p.z*.2)-.07 ) , m);          \n    d = smin(d, max( abs(p.z)-s, abs(p.x+p.y/2.)-.07 ), m );    \n    d = smin(d, max( abs(p.z-p.y*.4)-s, abs(p.x-p.y*.2)-.07 ), m );    \n    d = smin(d, max( abs(p.z*.2-p.y)-s, abs(p.x+p.z)-.07 ), m );    \n    d = smin(d, max( abs(p.z*-.2+p.y)-s, abs(-p.x+p.z)-.07 ), m );\n    \n    return d;\n}\n\nfloat color( vec3 p){\n   return 0.; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // Ray from UV\n\tvec2 uv = fragCoord.xy * 2.0 / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 ray = normalize(vec3(1.*uv.x,1.*uv.y,1.));\n    \n    // Color    \n    vec3 color = vec3(0);    \n    const int rayCount = 1024;\n    \n    // Raymarching\n    float t = 0.;\n    for (int r = 1; r <= rayCount; r++)\n    {\n        // Ray Position\n        vec3 p = vec3(0,0,-3.) + ray * t;        \n        \n        // Rotation \n       \tp = rotateY(p, iMouse.x/iResolution.x * 2.* 3.14);  \n        p = rotateY(p,iTime/3.);\n        \n        // Deformation \n    \tfloat mask = max(0.,(1.-length(p/3.)));\n    \tp = rotateY(p,mask*sin(iTime/2.)*1.2);        \n        p.y += sin(iTime+p.x)*mask*.5;\n        p *= 1.1+(sin(iTime/2.)*mask*.3);\n\n        // distance\n        float d =  map(p);   \n        \n        //color\n        if(d<0.01 || r == rayCount )\n        {                 \n            \n            float iter = float(r) / float(rayCount);\n            float ao = (1.-iter);\n            ao*=ao;\n            ao = 1.-ao;\n                        \n            float mask = max(0.,(1.-length(p/2.)));            \n            mask *= abs(sin(iTime*-1.5+length(p)+p.x)-.2);            \n            color += 2.*vec3(.1,1.,.8) * max(0.,(noise(p)*4.-2.6)) * mask;            \n            color += vec3(.1,.5,.6) * ao * 6.;            \n            color += vec3(.27,.2,.4)*(t/8.);\n                       \n            color *= 2.;\n            color -= .15;\n                        \n            break;          \n        }\n        \n        // march along ray\n        t +=  d *.5;        \n    }\n    \n    // vignetting effect by Ippokratis\n    // https://www.shadertoy.com/view/lsKSWR\n    uv = fragCoord.xy / iResolution.xy;\n    uv *=  1.0 - uv.yx; \n    float vig = uv.x*uv.y * 20.0;    \n    vig = pow(vig, 0.25);        \n    color *= vig;\n    \n    //color adjustement\n    color.y *= .8;\n    color.x *= 1.5;\n    \n\tfragColor = vec4(color, 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 48,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}