{
    "Shader": {
        "info": {
            "date": "1637505335",
            "description": "It's getting a little more complicated.",
            "flags": 0,
            "hasliked": 0,
            "id": "ftKGWz",
            "likes": 34,
            "name": "truchet on truchet",
            "published": 3,
            "tags": [
                "trunchet"
            ],
            "usePreview": 0,
            "username": "IWBTShyGuy",
            "viewed": 598
        },
        "renderpass": [
            {
                "code": "// Copyright Â© 2021 IWBTShyGuy\n// Attribution 4.0 International (CC BY 4.0)\n\n/* ---------------- 2D trachet ---------------- */\nconst float TILE_SIZE = 1.0 / 30.0;\n\n#define rotate2D(t) mat2(cos(t), sin(t), -sin(t), cos(t))\n\nconst float THICKNESS = 0.06;\nfloat tile0(in vec2 uv) {\n    float c0 = abs(1.0 / 6.0 - length(vec2(0.0, 0.5) - uv));\n    float c1 = abs(1.0 / 6.0 - length(vec2(1.0, 0.5) - uv));\n    float c2 = abs(uv.x - 1.0 / 3.0);\n    float c3 = abs(uv.x - 2.0 / 3.0);\n\n    return min(min(min(c0, c1), c2), c3);\n}\n\nfloat tile1(in vec2 uv) {\n    float c0 = abs(1.0 / 3.0 - length(uv));\n    float c1 = abs(1.0 / 3.0 - length(vec2(1, 0) - uv));\n    float c2 = abs(1.0 / 3.0 - length(vec2(0, 1) - uv));\n    float c3 = abs(1.0 / 3.0 - length(1.0 - uv));\n\n    return min(min(min(c0, c1), c2), c3);\n}\n\nfloat tile2(in vec2 uv) {\n    float c0 = abs(1.0 / 3.0 - length(uv));\n    float c1 = abs(2.0 / 3.0 - length(uv));\n    float c2 = abs(1.0 / 3.0 - length(1.0 - uv));\n    float c3 = abs(2.0 / 3.0 - length(1.0 - uv));\n\n    return min(min(min(c0, c1), c2), c3);\n}\n\nvoid trachet2D(out vec4 fragColor, in vec2 uv0, in float gen) {\n    vec2 uv = fract(uv0 / TILE_SIZE);\n    vec2 rand = hash22(floor((uv0 + gen) / TILE_SIZE) * 1.32);\n    float theta = floor(rand.x * 4.0) * PI / 2.0;\n    uv = rotate2D(theta) * (uv - 0.5) + 0.5;\n\n    float d = rand.y < 1.0 / 3.0 ? tile0(uv) :\n    rand.y < 2.0 / 3.0 ? tile1(uv) : tile2(uv);\n    float w = fwidth(d);\n    float c = smoothstep(w, -w, d - THICKNESS);\n\n    fragColor = vec4(c, c, c, 1);\n}\n\n/* ---------------- 3D trachet ---------------- */\nconst float FAR = 12.0;\n\n#define rotate3D(n, t) mat3( \\\n    cos(t) + n.x * n.x * (1.0 - cos(t)), \\\n    n.x * n.y * (1.0 - cos(t)) + n.z * sin(t), \\\n    n.z * n.x * (1.0 - cos(t)) - n.y * sin(t), \\\n    n.x * n.y * (1.0 - cos(t)) - n.z * sin(t), \\\n    cos(t) + n.y * n.y * (1.0 - cos(t)), \\\n    n.y * n.z * (1.0 - cos(t)) + n.x * sin(t), \\\n    n.z * n.x * (1.0 - cos(t)) + n.y * sin(t), \\\n    n.y * n.z * (1.0 - cos(t)) - n.x * sin(t), \\\n    cos(t) + n.z * n.z * (1.0 - cos(t))  \\\n)\n\nconst mat3 T0 = rotate3D(normalize(vec3(0, 1, -1)), PI);\nconst mat3 T1 = rotate3D(normalize(vec3(1, 0, 1)), PI);\nconst mat3 T2 = rotate3D(normalize(vec3(0, 1, 1)), PI);\n\n// hexahedron group\nconst mat3[] S = mat3[](\n    mat3(1, 0, 0, 0, 1, 0, 0, 0, 1),\n    T2,\n    T1,\n    T2 * T1,\n    T1 * T2,\n    T2 * T1 * T2,\n    T0,\n    T2 * T0,\n    T1 * T0,\n    T2 * T1 * T0,\n    T1 * T2 * T0,\n    T2 * T1 * T2 * T0,\n    T0 * T1,\n    T2 * T0 * T1,\n    T1 * T0 * T1,\n    T2 * T1 * T0 * T1,\n    T1 * T2 * T0 * T1,\n    T2 * T1 * T2 * T0 * T1,\n    T0 * T1 * T2,\n    T2 * T0 * T1 * T2,\n    T1 * T0 * T1 * T2,\n    T2 * T1 * T0 * T1 * T2,\n    T1 * T2 * T0 * T1 * T2,\n    T2 * T1 * T2 * T0 * T1 * T2\n);\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = abs(vec2(length(p.zx) - t.x, p.y)) - t.y;\n    return length(max(q, 0.0)) + min(max(q.x,q.y),0.0);\n}\n\nvec2 textureTorus(vec3 p, vec2 t) {\n    float a = length(p.zx) - t.x;\n    vec2 n = normalize(p.zx);\n    float u = asin(abs(n.y)) * 2.0 / PI;\n    float b = (1.0 + sign(abs(a) - t.y * 0.999)) * 0.5;\n    float v = (1.0 - b) * (1.0 + a / t.y) * 0.5\n        + b * (1.0 + p.y / t.y) * 0.5;\n    return vec2(u, v);\n}\n\nvec3 normalTorus(vec3 p, vec2 t) {\n    float a = length(p.zx) - t.x;\n    vec2 n = normalize(p.zx);\n    float b = (1.0 + sign(abs(a) - t.y * 0.999)) * 0.5;\n    return b * sign(a) * vec3(n.y, 0, n.x)\n        + (1.0 - b) * sign(p.y) * vec3(0, 1, 0);\n}\n\nfloat sdCylinder(vec3 p, float t) {\n    vec2 q = abs(p.xy - 0.5) - t;\n    return length(max(q, 0.0)) + min(max(q.x,q.y),0.0);\n}\n\nvec2 textureCylinder(vec3 p, float t) {\n    vec2 q = p.xy - 0.5;\n    float u = p.z;\n    float s = (1.0 + sign(abs(q.x) - t * 0.999)) * 0.5;\n    float v = s * (1.0 + q.y / t) * 0.5 + (1.0 - s) * (1.0 + q.x / t) * 0.5;\n    return vec2(u, v);\n}\n\nvec3 normalCylinder(vec3 p, float t) {\n    vec2 q = p.xy - 0.5;\n    t = (1.0 + sign(abs(q.x) - t * 0.999)) * 0.5;\n    return t * sign(q.x) * vec3(1, 0, 0)\n        + (1.0 - t) * sign(q.y) * vec3(0, 1, 0);\n}\n\nfloat sdist(in vec3 p, in vec3 q, out int shape, out uint index) {\n    float rand = hash13(floor(p + q));\n    index = uint(rand * 24.0);\n    p = fract(p);\n    p = S[index] * (p - 0.5) + 0.5;\n    float dist = sdTorus((p - vec3(0, 0, 0.5)).yzx, vec2(0.5, 0.05));\n    shape = 0;\n    float dist1 = sdTorus((p - vec3(1, 1, 0.5)).yzx, vec2(0.5, 0.05));\n    if (dist > dist1) {\n        dist = dist1;\n        shape = 1;\n    }\n    dist1 = sdCylinder(p, 0.05);\n    if (dist > dist1) {\n        dist = dist1;\n        shape = 2;\n    }\n    return dist;\n}\n\nvoid calcTextureNormal(in vec3 p, in vec3 q, in int shape, in uint index, out vec2 uv, out vec3 normal) {\n    float rand = hash13(floor(p + q));\n    index = uint(rand * 24.0);\n    p = fract(p);\n    p = S[index] * (p - 0.5) + 0.5;\n    if (shape == 0) {\n        uv = textureTorus((p - vec3(0, 0, 0.5)).yzx, vec2(0.5, 0.05));\n        normal = normalTorus((p - vec3(0, 0, 0.5)).yzx, vec2(0.5, 0.05)).zxy;\n    } else if (shape == 1) {\n        uv = textureTorus((p - vec3(1, 1, 0.5)).yzx, vec2(0.5, 0.05));\n        normal = normalTorus((p - vec3(1, 1, 0.5)).yzx, vec2(0.5, 0.05)).zxy;\n    } else {\n        uv = textureCylinder(p, 0.05);\n        normal = normalCylinder(p, 0.05);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 theta = vec2(0.15, 0.25) * iTime;\n    theta.y = sin(theta.y);\n    Camera camera = newCamera(\n        vec3(0, 0, -iTime * 0.5),\n        vec3(cos(theta.x) * cos(theta.y), sin(theta.y), sin(theta.x) * cos(theta.y)),\n        vec3(0, 1, 0),\n        PI / 4.0,\n        iResolution.x / iResolution.y\n    );\n    Ray ray = cameraRay(camera, fragCoord / iResolution.xy);\n\n    vec3 p = fract(ray.origin);\n    vec3 q = floor(ray.origin);\n    int shape;\n    uint index;\n    for (int i = 0; i < 100; i++) {\n        float dist = sdist(p, q, shape, index);\n        if (dist < 0.00001) break;\n        p += dist * ray.direction;\n    }\n    \n    float c = 0.0;\n    float rDist = length(p - fract(ray.origin));\n    vec4 trachet = vec4(0);\n    if (rDist < FAR) {\n        vec2 uv;\n        vec3 normal;\n        calcTextureNormal(p, q, shape, index, uv, normal);\n        normal = transpose(S[index]) * normal;\n        c = -dot(normal, ray.direction);\n        vec3 q0 = mod(floor(p + q) * 13.0, 3000.0);\n        trachet2D(trachet, vec2(uv.x, uv.y / 10.0), q0.x + q0.y * 2.0 + q0.z * 3.0);\n        \n        // fog by Shane (comment)\n        c /= (1. + rDist*rDist*.5);\n        c = mix(c, 0.0, smoothstep(0.0, 1.0, rDist / FAR));\n    }\t\n    \n    fragColor = vec4(pow(c * trachet.xyz, vec3(0.4545)), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float PI = 3.141592653;\n\nstruct Camera {\n    vec3 position;\n    vec3 direction;\n    vec3 up_direction; // not require dot(direction, up_direction) == 0\n    float fov;\n    float aspect; // x / y\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nCamera newCamera(vec3 position, vec3 direction, vec3 up_direction, float fov, float aspect) {\n    Camera camera;\n    camera.position = position;\n    camera.direction = direction;\n    camera.up_direction = up_direction;\n    camera.fov = fov;\n    camera.aspect = aspect;\n    return camera;\n}\n\n// perspective camera ray, uv = fragCoord / iResolution.xy\n// cf: https://qiita.com/aa_debdeb/items/301dfc54788f1219b554\nRay cameraRay(in Camera camera, in vec2 uv) {\n    uv = uv * 2.0 - 1.0;\n    float radian = camera.fov;\n    float h = tan(radian * 0.5);\n    float w = h * camera.aspect;\n    vec3 right = normalize(cross(camera.direction, camera.up_direction));\n    vec3 up = normalize(cross(right, camera.direction));\n    vec3 direction = normalize(right * w * uv.x + up * h * uv.y + camera.direction);\n    Ray ray;\n    ray.origin = camera.position;\n    ray.direction = direction;\n    return ray;\n}\n\n\n// Hash without Sine https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}