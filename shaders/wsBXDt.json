{
    "Shader": {
        "info": {
            "date": "1555417901",
            "description": "Creating a distance field value for a random tiled pattern, then applying image software layering techniques to produce a raised-looking hand drawn image.",
            "flags": 0,
            "hasliked": 0,
            "id": "wsBXDt",
            "likes": 47,
            "name": "Random Tiled Pattern",
            "published": 3,
            "tags": [
                "random",
                "truchet",
                "pattern",
                "tile",
                "photoshop",
                "layer"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 2563
        },
        "renderpass": [
            {
                "code": "/*\n\n\tRandom Tiled Pattern\n\t--------------------\n\n\tCreating a distance field value for a random tiled pattern, then applying standard image \n\tsoftware layering techniques to produce a raised-looking hand drawn image.\n\n\tI used to love playing around with Photoshop, but haven't used it since Adobe moved to the \n    subscription model, which the 90s internet user in me isn't comfortable with. Regardless, \n\tI still like to apply Photoshop layering principles in Shadertoy.\n\n\tMost of the techniques used in this example employ common sense: Create a 2D vector field, \n    then render various layers over the top of one another. For instance, a black field shape \n\tfollowed by a slightly thinner colored one will give the appearance of a colored vector \n\timage with a dark stroke line, and so forth. Render a faded shape with an offset position \n\tonto the background prior to rendering the other layers, and you have yourself a shadow, \n\tetc.\n\t\n\tThe pattern itself is nothing special, but I like the way it looks. The most common square\n\tTruchet tile consists of a couple of arc lines. This one is constructed via a few more arc \n\tlines in each tile, whilst still maintaining rotational symmetry. You can see a similar \n\texample in the paper \"Truchet Tiles Revisited,\" which I've provided a link to below. \n\tHowever, uncommenting the \"SHOW_GRID\" define should give you a fair idea.\n\n \tI went for a kind of grungey hand drawn style... Probably not to everyone's taste, but with \n\ta bit of imagination, all kinds of styles are possible. Just for fun, and to keep Dr2 happy, \n\tI produced my own texture, which is just a mixture of noise and color. I coded this in the \n\t800 by 450 window on a 17 inch laptop, but have tried to keep it looking similar in other \n\tscreen settings.\n\n\n\n\tPattern based on an image in the following paper:\n\n\tTruchet Tiles Revisited - Robert J. Krawczyk\n\thttp://mypages.iit.edu/~krawczyk/rjkisama11.pdf\n\n\n\n\n*/\n\n// Show the square grid markings, which enables the viewer to see the individual tiles.\n//#define SHOW_GRID\n\n\n// Shorthand.\n#define sstep(sf, d) (1. - smoothstep(0., sf, d))\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's standard vec2 to float hash formula.\nfloat hash21(vec2 p){\n \n    float n = dot(p, vec2(127.183, 157.927));\n    return fract(sin(n)*43758.5453);\n}\n\n\n// Cheap and nasty 2D smooth noise function with inbuilt hash function -- based on IQ's \n// original. Very trimmed down. In fact, I probably went a little overboard. I think it \n// might also degrade with large time values.\nfloat n2D(vec2 p) {\n\n\tvec2 i = floor(p); p -= i; p *= p*(3. - p*2.);  \n    \n\treturn dot(mat2(fract(sin(vec4(0, 1, 113, 114) + dot(i, vec2(1, 113)))*43758.5453))*\n                vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n\n}\n\n// FBM -- 4 accumulated noise layers of modulated amplitudes and frequencies.\nfloat fbm(vec2 p){ return n2D(p)*.533 + n2D(p*2.)*.267 + n2D(p*4.)*.133 + n2D(p*8.)*.067; }\n\n\n// Distance field for the grid tile.\nfloat TilePattern(vec2 p){\n    \n     \n    vec2 ip = floor(p); // Cell ID.\n    p -= ip + .5; // Cell's local position. Range [vec2(-.5), vec2(.5)].\n    \n     \n    // Using the cell ID to generate a unique random number.\n    float rnd = hash21(ip);\n    float rnd2 = hash21(ip + 27.93);\n    //float rnd3 = hash21(ip + 57.75);\n     \n    // Random tile rotation.\n    float iRnd = floor(rnd*4.);\n    p = rot2(iRnd*3.14159/2.)*p;\n    // Random tile flipping.\n    //p.y *= (rnd>.5)? -1. : 1.;\n    \n    \n    // Rendering the arcs onto the tile.\n    //\n    float d = 1e5, d1 = 1e5, d2 = 1e5, d3 = 1e5, l;\n    \n   \n    // Three top left arcs.\n    l = length(p - vec2(-.5, .5));\n    d1 = abs(l - .25);\n    d2 = abs(l - .5);\n    d3 = abs(l - .75);\n    if(rnd2>.33) d3 = abs(length(p - vec2(.125, .5)) - .125);\n    \n    d = min(min(d1, d2), d3);\n    \n    // Two small arcs on the bottom right.\n    d1 = 1e5;//abs(length(p - vec2(.5, .5)) - .25);\n    //if(rnd3>.35) d1 = 1e5;//\n    d2 = abs(length(p - vec2(.5, .125)) - .125);\n    d3 = abs(length(p - vec2(.5, -.5)) - .25);\n    d = min(d, min(d1, min(d2, d3))); \n    \n    \n    // Three bottom left arcs.\n    l = length(p + .5);\n    d = max(d, -(l - .75)); // Outer mask.\n    \n    // Equivalent to the block below:\n    //\n    //d1 = abs(l - .75);\n    //d2 = abs(l - .5);\n    //d3 = abs(l - .25);\n    //d = min(d, min(min(d1, d2), d3));\n\t//\n    d1 = abs(l - .5);\n    d1 = min(d1, abs(d1 - .25));\n    d = min(d, d1);\n    \n    \n    // Arc width. \n    d -= .0625;\n    \n \n    // Return the distance field value for the grid tile.\n    return d; \n    \n}\n\n\n// Smooth fract function.\nfloat sFract(float x, float sf){\n    \n    x = fract(x);\n    return min(x, (1. - x)*x*sf);\n    \n}\n\n\n// The grungey texture -- Kind of modelled off of the metallic Shadertoy texture,\n// but not really. Most of it was made up on the spot, so probably isn't worth \n// commenting. However, for the most part, is just a mixture of colors using \n// noise variables.\nvec3 GrungeTex(vec2 p){\n    \n \t// Some fBm noise.\n    //float c = n2D(p*4.)*.66 + n2D(p*8.)*.34;\n    float c = n2D(p*3.)*.57 + n2D(p*7.)*.28 + n2D(p*15.)*.15;\n   \n    // Noisey bluish red color mix.\n    vec3 col = mix(vec3(.25, .1, .02), vec3(.35, .5, .65), c);\n    // Running slightly stretched fine noise over the top.\n    col *= n2D(p*vec2(150., 350.))*.5 + .5; \n    \n    // Using a smooth fract formula to provide some splotchiness... Is that a word? :)\n    col = mix(col, col*vec3(.75, .95, 1.2), sFract(c*4., 12.));\n    col = mix(col, col*vec3(1.2, 1, .8)*.8, sFract(c*5. + .35, 12.)*.5);\n    \n    // More noise and fract tweaking.\n    c = n2D(p*8. + .5)*.7 + n2D(p*18. + .5)*.3;\n    c = c*.7 + sFract(c*5., 16.)*.3;\n    col = mix(col*.6, col*1.4, c);\n    \n    // Clamping to a zero to one range.\n    return clamp(col, 0., 1.);\n    \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n\n    // Aspect correct screen coordinates. Setting a minumum resolution on the\n    // fullscreen setting in an attempt to keep things relatively crisp.\n    float res = min(iResolution.y, 750.);\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/res;\n    \n    // Scaling and translation.\n    vec2 p = uv*4. + vec2(1, 0)*iTime;\n    // Optional rotation, if you'd prefer.\n    //vec2 p = rot2(3.14159/6.)*uv*4. + vec2(1, 0)*iTime;\n    // Flockaroo's rotozoom suggestion, if that's more your speed. :)\n    //vec2 p = rot2(sin(iTime/4.)*3.14159)*uv*(4.5 + 1.5*sin(iTime/4.)) + vec2(0, 1)*iTime;\n    \n    \n    // Taking a few distance field readings.    \n    vec2 eps = vec2(4, 6)/iResolution.y;\n    float d = TilePattern(p); // Initial field value.\n    float d2 = TilePattern(p + eps); // Slight sample distance, for highlighting,.\n    float dS = TilePattern(p + eps*3.); // Larger distance, for shadows.\n    \n    // Calculating the sample difference.    \n    float b = smoothstep(0., 15./450., d - .015);\n    float b2 = smoothstep(0., 15./450., d2 - .015);\n    \n    // Bump value for the warm highlight (above), and the cool one (below).\n    float bump = max(b2 - b, 0.)/length(eps);\n    float bump2 = max(b - b2, 0.)/length(eps);\n    \n \n    \n    // Smoothing factor, based on resolution.\n    float sf = 5./iResolution.y;\n     \n    // The grungey texture.\n    vec3 tx = GrungeTex(p/4. + .5);\n    tx = smoothstep(0., .5, tx);\n    \n     \n    // Background texture.\n    vec3 bg = tx*vec3(.85, .68, .51);\n   \n    // Initiate the image color to the background.\n    vec3 col = bg;\n    \n    \n\n    // Displaying the grid, in order to see the individual grid tiles.\n    #ifdef SHOW_GRID\n    vec2 q = abs(fract(p) - .5);\n\tfloat gw = .0275;\n    float grid = (max(q.x, q.y) - .5 + gw);\n    col = mix(col, vec3(0), (smoothstep(0., sf*4., grid - gw + gw*2.))*.75);\n    col = mix(col, bg*2., (smoothstep(0., sf, grid - gw + gw/2.)));\n    #endif\n    \n     \n    // Sometimes, more detail can help, but in this case, it's a bit much, I think. :)\n    //float dP = TilePattern(p*5.);\n    //col = mix(col, min(bg*2.5, 1.), sstep(sf*15., dP + .01)); // Pattern.\n    //col = mix(col, bg/4., sstep(sf*5., dP + .03)); // Pattern.\n     \n    \n    // TILE RENDERING.\n    \n    // Drop shadow -- blurred and slighly faded onto the background.\n    col = mix(col, vec3(0), sstep(sf*4., dS - .02)*.75); // Shadow.\n    \n    // Blurred line -- subtle, and not entirely necessary, but it's there.\n    col = mix(col, vec3(0), sstep(sf*8., d)*.35);\n    \n    // Dark edge line -- stroke.\n    col = mix(col, vec3(0), sstep(sf, d));\n     \n    \n    // Pattern color -- just a brightly colored version of the background.   \n    vec3 pCol = vec3(2.5, .75, .25)*tx;\n    // Uncomment this, if blue's more your thing.\n    //pCol = pCol.zyx*1.2;\n    \n  \n    // Apply the pattern color. Decrease the pattern width by the edge line width.\n    col = mix(col, pCol, sstep(sf, d + .025));\n     \n    \n    // Use some noise to mix the colors from orange to pink. Uncomment to see what it does.\n    col = mix(col, col.xzy, smoothstep(.3, 1., fbm(p*.85))*.7);\n    \n    // Applying the warm sunlight bump value to the image, on the opposite side to the shadow.\n    col = col + (vec3(1, .2, .1)*(bump*.01 + bump*bump*.003));\n    // Applying the cool bump value to the image, on the shadow side.\n    col = col + col*(vec3(1, .2, .1).zyx*(bump2*.01 + bump2*bump2*.003));   \n \n    \n    // Uncomment this to see the grungey texture on its own. Yeah, it's pretty basic,\n    // so it won't be winning any awards, but it's suitable enough for this example. :)\n    //col = tx;\n\n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}