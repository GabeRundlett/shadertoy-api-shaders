{
    "Shader": {
        "info": {
            "date": "1689048256",
            "description": "Inspired by this video by Nils Berglund:\n\nhttps://www.youtube.com/watch?v=pN-gi_omIVE\n\nDemonstration of the concept of a pair of parabolic reflectors. These might be a pair of satellite dishes pointed towards each other.\n\n* mouse: emit wave\n* space: reset",
            "flags": 48,
            "hasliked": 0,
            "id": "DdffzB",
            "likes": 30,
            "name": "Parabolic Reflectors",
            "published": 3,
            "tags": [
                "2d",
                "reflection",
                "wave",
                "simulation",
                "parabolic",
                "reflector"
            ],
            "usePreview": 0,
            "username": "fenix",
            "viewed": 363
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Inspired by this video by Nils Berglund:\n//\n//      https://www.youtube.com/watch?v=pN-gi_omIVE\n//\n//  Demonstration of the concept of a pair of parabolic reflectors. These might be a\n//  pair of satellite dishes pointed towards each other.\n//  \n//  Waves are emitted at the focal point of the left reflector, and form a non-dispersing\n//  linear wavefront that travels from left to right. The coherence of this beam allows\n//  a signal to be transmitted great distances.\n//\n//  Notice how the higher-energy colors, yellow and especially reds, only appear briefly\n//  when first emanating from the left. After bouncing off the reflector (or not), while\n//  travelling across the screen, the wave is mostly blue and green. Only after it\n//  bounces off the far reflector and the wave converes into the opposite focal point do\n//  the yellows and reds appear again. This would allow a detector placed at the right\n//  focal point to recieve a signal transmitted from the left focal point.\n//\n//  The exterior boundaries are supposed to be absorbing, and they do a decent job, but\n//  there is still a small reflection. If anyone knows what I have wrong I would be very\n//  grateful for advice. Fighting with BOUND_GAMMA and the absorbing walls was the biggest\n//  challenge in making this shader, other than making sure it works comparably in multiple\n//  resolutions.\n//\n//  Click the mouse to emit a circular wave. Suggested experiments: You can emit a wave\n//  from the right focal point to transmit a coherent wave back to the left. Also, what\n//  happens if you emit a wave near, but not on a focal poiint, for example slightly\n//  above, below, or to the left or right. Space to reset once it gets too busy.\n//\n//  If it's going too fast, I noticed you can easily slow it down to x.25 by just setting\n//  Buffer A's iChannel0 to Buffer A to defeat the A->B->C->D->A loop.\n//\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    // get wave height\n    O = texelFetch(iChannel0, ivec2(u), 0);\n    O = sin(O.x * 500. * vec4(2, 4, 6, 0)); // colorize\n    O *= O;\n    \n    vec2 R = iResolution.xy, p = (u - .5 * R) / R.y;\n    \n    // draw parabolas\n    O = mix(O, vec4(1), smoothstep(3. / R.y + .003, .003, abs(map(p) + .003)));\n    \n    // draw foci\n    O = mix(O, vec4(1), .3 * smoothstep(.01 + 3. / R.y, .01, distance(p, vec2(FOCUS_DIST, 0))));\n    O = mix(O, vec4(1), .3 * smoothstep(.01 + 3. / R.y, .01, distance(p, vec2(-FOCUS_DIST, 0))));\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 O, vec2 u)\n{\n    updateBuffer(O, u, iResolution.xy, iFrame, iMouse, iChannel0, iChannel3, true); // true for last parameter => update state, emit waves\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define U(u) texelFetch(prevBuffer, ivec2(u), 0) //\nconst float FOCUS_DIST = .45;\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdParabola( in vec2 pos, in float k )\n{\n    if (pos.x == 0.) pos.x = .01; // fix for horizontal line (bug?)\n    pos.x = abs(pos.x);\n    float ik = 1.0/k;\n    float p = ik*(pos.y - 0.5*ik)/3.0;\n    float q = 0.25*ik*ik*pos.x;\n    float h = q*q - p*p*p;\n    float r = sqrt(abs(h));\n    float x = (h>0.0) ? \n        pow(q+r,1.0/3.0) - pow(abs(q-r),1.0/3.0)*sign(r-q) :\n        2.0*cos(atan(r,q)/3.0)*sqrt(p);\n    return length(pos-vec2(x,k*x*x)) * sign(pos.x-x);\n}\n\nfloat map(vec2 p)\n{\n    p.x = -abs(p.x);\n\n    float d = -sdParabola(p.yx + vec2(.0, .7), 1.);\n    d = max(d, abs(p.y) - .3);\n    return d;\n}\n\n#define keyClick(ascii)   ( texelFetch(keyBuffer,ivec2(ascii,1),0).x > 0.)\n\n#define KEY_SPACE 32\n\nconst float BOUND_GAMMA = .01; // damping factor for boundary\n\nfloat initWave(vec2 u, vec2 c, vec2 R)\n{\n    vec2 delta = u - c;\n    float d2 = dot(delta, delta);\n\n    return 1e-6 * R.x * cos(sqrt(d2 * .0001)) / (1. + d2 * .2);\n}\n\nvoid updateBuffer(out vec4 O, vec2 u, vec2 R, int iFrame, vec4 iMouse, sampler2D prevBuffer, sampler2D keyBuffer, bool addWaves)\n{\n    vec2 o = vec2(1, 0),\n         p = (u - .5 * R) / R.y;\n\n    vec4 state = texelFetch(prevBuffer, ivec2(0), 0);\n    \n    // handle persistent state\n    if (ivec2(u) == ivec2(0))\n    {\n        if (iFrame == 0 ||\n            state.w != R.x * R.y ||\n            keyClick(KEY_SPACE))\n        {\n            O = vec4(0);\n            O.w = R.x * R.y;\n            return;\n        }\n        \n        O = state;\n        \n        // timing is relative to horizontal dimension, to allow first bounce to complete before next wave encroaches\n        if (addWaves && ++O.z > R.y / 1.5)\n            O.z = 0.;\n        \n        return;\n    }\n    \n    if (iFrame == 0 ||\n        state.w != R.x * R.y ||\n        keyClick(KEY_SPACE))\n    {\n        // init\n        O = vec4(0);\n        return;\n    }\n    else\n    {\n        const float C = .5; // Courant\n\n        O = U(u).xxyy; // copies the current value from x to y coordinate to record new previous, put current previous into z for us to use\n\n        if (int(u.y) < 5)\n            O.x = O.x - C * (O.x - U(u + o.yx).x) - BOUND_GAMMA*(O.x-O.z); // absorbing bottom boundary\n        else if (int(u.y) == int(R.y) - 1)\n            O.x = O.x - C * (O.x - U(u - o.yx).x) - BOUND_GAMMA*(O.x-O.z); // absorbing top boundary\n        else if (int(u.x) == 0)\n            O.x = O.x - C * (O - U(u + o)).x - BOUND_GAMMA*(O.x-O.z); // absorbing left boundary\n        else if (int(u.x) == int(R.x) - 1)\n            O.x = O.x - C * (O - U(u - o)).x - BOUND_GAMMA*(O.x-O.z); // absorbing right boundary\n        else\n            O.x = -O.z + 2.*O.x + C*(U(u + o) + U(u - o) + U(u + o.yx) + U(u - o.yx) - 4. * O).x; // apply wave equation\n    }\n\n    if (addWaves)\n    {\n        // add disturbance at left focal point\n        if (state.z < 1. || iFrame == 0)\n            O.y += initWave(u, vec2(-FOCUS_DIST, 0) * R.y + .5 * R.xy, R);\n\n        // add disturbance for mouse click\n        if (iMouse.z > 0. && iMouse.w > 0.)\n            O.y += initWave(u, iMouse.xy, R);\n    }\n\n    // parabola boundary (reflecting)\n    if (map(p) < 0.) O = vec4(0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 O, vec2 u)\n{\n    updateBuffer(O, u, iResolution.xy, iFrame, iMouse, iChannel0, iChannel3, false);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 O, vec2 u)\n{\n    updateBuffer(O, u, iResolution.xy, iFrame, iMouse, iChannel0, iChannel3, false);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 O, vec2 u)\n{\n    updateBuffer(O, u, iResolution.xy, iFrame, iMouse, iChannel0, iChannel3, false);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}