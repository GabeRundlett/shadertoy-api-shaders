{
    "Shader": {
        "info": {
            "date": "1625939958",
            "description": "UV-mapped hexagonal tiling on an icosahedron, See: https://en.wikipedia.org/wiki/Goldberg_polyhedron\n\nInstead of mesh tessellation this shader uses voronoi cells.\nThis way the performance is independent of the number of tiles.",
            "flags": 0,
            "hasliked": 0,
            "id": "NsSSRW",
            "likes": 6,
            "name": "Class I Goldberg Polyhedron ",
            "published": 3,
            "tags": [
                "uv",
                "sphere",
                "hexagon",
                "tile",
                "polyhedron"
            ],
            "usePreview": 0,
            "username": "Lichtso",
            "viewed": 363
        },
        "renderpass": [
            {
                "code": "const float M_PI = radians(180.0);\nconst float icosahedron_radius_by_edge_length = sin(M_PI*2.0/5.0);\nconst float inversesqrt5 = inversesqrt(5.0);\nconst vec3 ICOSAHEDRON_VERTICES[12] = vec3[](\n    vec3(0.0, -1.0, 0.0),\n    vec3(-0.27639320492744446, -inversesqrt5, -0.8506507873535156),\n    vec3(-0.8944271802902222, -inversesqrt5, -1.6430361299034693e-16),\n    vec3(-0.27639320492744446, -inversesqrt5, 0.8506507873535156),\n    vec3(0.7236068248748779, -inversesqrt5, 0.525731086730957),\n    vec3(0.7236068248748779, -inversesqrt5, -0.525731086730957),\n    vec3(0.27639320492744446, inversesqrt5, -0.8506507873535156),\n    vec3(-0.7236068248748779, inversesqrt5, -0.525731086730957),\n    vec3(-0.7236068248748779, inversesqrt5, 0.525731086730957),\n    vec3(0.27639320492744446, inversesqrt5, 0.8506507873535156),\n    vec3(0.8944271802902222, inversesqrt5, 1.6430361299034693e-16),\n    vec3(0.0, 1.0, 0.0)\n);\n\nconst float blending_region = 0.65;\nconst float planet_radius = 9.0;\n\nbool side_of_half_plane(vec3 direction, int pole_index_a, int pole_index_b) {\n    vec3 aux_a = cross(ICOSAHEDRON_VERTICES[pole_index_a], ICOSAHEDRON_VERTICES[pole_index_b]);\n    return dot(direction, aux_a) > 0.0;\n}\n\nfloat line_sphere_intersection(vec3 origin, vec3 direction, float radius, out vec3 intersections[2]) {\n    float a = dot(direction, direction);\n    float b = -dot(direction, origin);\n    float c = dot(origin, origin) - radius*radius;\n    float d = (b*b)-a*c;\n    if(d < 0.0)\n        return -1.0;\n    d = sqrt(d);\n    direction /= a;\n    intersections[0] = origin+direction*(b-d);\n    intersections[1] = origin+direction*(b+d);\n    return b-d;\n}\n\n/*vec3 bary_to_cart(vec3 barycentric, ivec3 pole_indices) {\n    barycentric = sin(sin(barycentric));\n    mat3 mat = mat3(\n        ICOSAHEDRON_VERTICES[pole_indices[0]],\n        ICOSAHEDRON_VERTICES[pole_indices[1]],\n        ICOSAHEDRON_VERTICES[pole_indices[2]]\n    );\n    return normalize(mat*barycentric);\n}\n\nvec3 cart_to_bary(vec3 direction, ivec3 pole_indices) {\n    vec3 barycentric = vec3(0.0);\n    for(int i = 0; i < 3; ++i)\n        barycentric[i] = dot(cross(ICOSAHEDRON_VERTICES[pole_indices[(i+1)%3]], ICOSAHEDRON_VERTICES[pole_indices[(i+2)%3]]), direction);\n    barycentric = asin(asin(barycentric));\n    return barycentric/dot(barycentric, vec3(1.0));\n}*/\n\nvec3 cart_to_bary(vec3 direction, ivec3 pole_indices) {\n    vec3 bary;\n    for(int i = 0; i < 3; ++i) {\n        vec3 b = ICOSAHEDRON_VERTICES[pole_indices[(i+1)%3]];\n        vec3 c = ICOSAHEDRON_VERTICES[pole_indices[(i+2)%3]];\n        float numerator = dot(direction, cross(b, c));\n        float denominator = 1.0+inversesqrt5+dot(direction, b)+dot(direction, c);\n        bary[i] = 10.0/M_PI*atan(numerator, denominator);\n    }\n    bary /= dot(vec3(1.0), bary);\n    return bary;\n}\n\nvec3 bary_to_cart(vec3 barycentric, ivec3 pole_indices) {\n    vec4 planes[3];\n    for(int i = 0; i < 3; ++i) {\n        vec3 b = ICOSAHEDRON_VERTICES[pole_indices[(i+1)%3]];\n        vec3 c = ICOSAHEDRON_VERTICES[pole_indices[(i+2)%3]];\n        float tangent = tan(M_PI/10.0*barycentric[i]);\n        planes[i].x = tangent*(1.0+inversesqrt5);\n        planes[i].yzw = cross(b, c)-tangent*(b+c);\n    }\n    vec3 l_g0 = planes[0].x * planes[1].yzw - planes[0].yzw * planes[1].x;\n    vec3 l_g1 = planes[0].z * vec3(planes[1].w, 0.0, -planes[1].y) + planes[0].w * vec3(-planes[1].z, planes[1].y, 0.0) + planes[0].y * vec3(0.0, -planes[1].w, planes[1].z);\n    vec4 p = l_g0.y * vec4(0.0, -planes[2].w, 0.0, planes[2].y) + l_g0.z * vec4(0.0, planes[2].z, -planes[2].y, 0.0) + l_g1.y * vec4(planes[2].z, 0.0, -planes[2].x, 0.0) + l_g1.z * vec4(planes[2].w, 0.0, 0.0, -planes[2].x) + vec4(l_g1.x, -l_g1.x, l_g0.x, -l_g0.x) * planes[2].yxwz;\n    return -p.yzw/p.x;\n}\n\nvec2 bary_to_texcoord(vec3 barycentric) {\n    return vec2(0.5)+0.75*vec2(barycentric.z, (barycentric.x-barycentric.y)/sqrt(3.0));\n}\n\nfloat checker_texture(vec2 texcoord) {\n    vec2 repeated = mod(texcoord, vec2(1.0));\n    vec2 chequer = smoothstep(0.4, 0.5, repeated) * smoothstep(1.0, 0.95, repeated);\n    return abs(1.0-chequer.x-chequer.y);\n}\n\nfloat stripe_texture(float texcoord) {\n    return abs(mod(texcoord, 1.0)-0.5)*2.0;\n}\n\nconst vec3 color_palette[3] = vec3[3](\n    vec3(0.7, 0.7, 0.3),\n    vec3(0.0, 0.6, 0.0),\n    vec3(0.2, 0.6, 0.8)\n);\nvec3 color_of_cell(ivec3 cell) {\n    int residue_class = (cell.x + cell.y * 2) % 3;\n    return color_palette[residue_class];\n}\n\n/*bool is_cell_patched(int gp_index, int triangle_longitude, int triangle_latitude, ivec3 cell) {\n    if(triangle_longitude == 1 || triangle_longitude == 2) {\n        return cell.z == 0\n            || (triangle_longitude == 2 && cell.y == 0)\n            || (triangle_longitude == 1 && cell.x == 0);\n    } else {\n        return (cell.y == 0 && cell.z < gp_index)\n            || (triangle_latitude > 0 && cell.z == gp_index);\n    }\n}*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    int gp_index = int(planet_radius/icosahedron_radius_by_edge_length);\n    \n    // Ray tracing of the sphere\n    vec3 view_ray_origin = vec3(0.0, 0.0, planet_radius*10.0);\n    vec3 view_ray_hit = vec3(fragCoord/iResolution.xy*2.0-vec2(1.0), 0.0);\n    view_ray_hit.x *= iResolution.x/iResolution.y;\n    view_ray_hit.xy *= planet_radius*1.2;\n    vec3 view_ray_direction = normalize(view_ray_hit-view_ray_origin);\n\n    vec3 intersections[2];\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    if(line_sphere_intersection(view_ray_origin, view_ray_direction, planet_radius, intersections) < 0.0)\n        return;\n    vec3 surface_normal = normalize(intersections[0]);\n    \n    float rotate_y = (iMouse.x/iResolution.x-0.5+iTime*0.02)*M_PI*2.0;\n    float rotate_x = (iMouse.y/iResolution.y-0.5)*M_PI;\n    surface_normal = (mat4(\n        cos(rotate_y), 0.0, sin(rotate_y), 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        -sin(rotate_y), 0.0, cos(rotate_y), 0.0,\n        0.0, 0.0, 0.0, 1.0\n    )*mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, cos(rotate_x), sin(rotate_x), 0.0,\n        0.0, -sin(rotate_x), cos(rotate_x), 0.0,\n        0.0, 0.0, 0.0, 1.0\n    )*vec4(surface_normal, 1.0)).xyz;\n\n    vec3 spherical = surface_normal;\n    ivec3 pole_indices;\n    int triangle_longitude;\n    int triangle_latitude;\n    {\n        // Icosahedron triangles\n        float longitude = 1.0-acos(spherical[1])/M_PI;\n        float latitude = atan(spherical[0], spherical[2])/M_PI;\n        int triangle_latitude_south = int(mod((2.9+latitude)*2.5, 5.0));\n        int triangle_latitude_north = int(mod((3.1+latitude)*2.5, 5.0));\n        if(side_of_half_plane(spherical, 1+(triangle_latitude_south+1)%5, 1+triangle_latitude_south)) {\n            pole_indices = ivec3(1+(triangle_latitude_south+1)%5, 1+triangle_latitude_south, 0);\n            triangle_longitude = 0;\n            triangle_latitude = triangle_latitude_south;\n        } else if(side_of_half_plane(spherical, 6+triangle_latitude_north, 6+(triangle_latitude_north+1)%5)) {\n            pole_indices = ivec3(6+triangle_latitude_north, 6+(triangle_latitude_north+1)%5, 11);\n            triangle_longitude = 3;\n            triangle_latitude = triangle_latitude_north;\n        } else if(side_of_half_plane(spherical, 6+triangle_latitude_north, 1+triangle_latitude_north) &&\n                  side_of_half_plane(spherical, 1+triangle_latitude_north, 6+(triangle_latitude_north+1)%5)) {\n            pole_indices = ivec3(6+(triangle_latitude_north+1)%5, 6+triangle_latitude_north, 1+triangle_latitude_north);\n            triangle_longitude = 2;\n            triangle_latitude = triangle_latitude_north;\n        } else {\n            pole_indices = ivec3(1+triangle_latitude_south, 1+(triangle_latitude_south+1)%5, 6+(triangle_latitude_south+1)%5);\n            triangle_longitude = 1;\n            triangle_latitude = triangle_latitude_south;\n        }\n    }\n    \n    vec3 barycentric = cart_to_bary(spherical, pole_indices);\n    vec2 orig_texcoord = bary_to_texcoord((triangle_longitude%2 == 1) ? -barycentric : barycentric);\n    ivec3 cell;\n    ivec3 neighbors[3];\n    vec3 blending_weights = vec3(0.0);\n    {\n        // Barycentric rounding\n        ivec3 rounded = ivec3(barycentric*float(gp_index));\n        int step_dir = (rounded.x+rounded.y+rounded.z)%2 == gp_index%2 ? 1 : -1;\n        ivec3 center = rounded*3+ivec3(3+step_dir)/2;\n        float distance_to_edge = 10000.0;\n\n        // Voronoi cells\n        for(int i = 0; i < 3; ++i) {\n            ivec3 neighbor = ivec3(step_dir);\n            neighbor[i] *= -2;\n            neighbor += center;\n            neighbor /= 3;\n            neighbors[i] = neighbor;\n            vec3 diff = (bary_to_cart(vec3(neighbor)/float(gp_index), pole_indices)-spherical)*float(gp_index);\n            blending_weights[i] = dot(diff, diff);\n            if(distance_to_edge > blending_weights[i]) {\n                distance_to_edge = blending_weights[i];\n                cell = neighbor;\n            }\n        }\n        blending_weights = smoothstep(vec3(blending_region), vec3(0.0), blending_weights);\n        blending_weights /= dot(vec3(1.0), blending_weights);\n    }\n\n    // Patch triangle edges\n    if(triangle_longitude == 2 && cell.y == 0 && cell.z > 0) {\n        cell.xz = cell.zx;\n        barycentric = vec3(1.0-barycentric.x, -barycentric.y, 1.0-barycentric.z);\n        triangle_longitude = 1; // 3-triangle_longitude;\n    } else if(triangle_longitude == 1 && cell.x == 0 && cell.z > 0) {\n        cell.yz = cell.zy;\n        barycentric = vec3(-barycentric.x, 1.0-barycentric.y, 1.0-barycentric.z);\n        triangle_latitude = (triangle_latitude+1)%5;\n        triangle_longitude = 2; // 3-triangle_longitude;\n    }\n    if(cell.z == 0) {\n        cell.yx = cell.xy;\n        barycentric = vec3(1.0-barycentric.x, 1.0-barycentric.y, -barycentric.z);\n        triangle_longitude = triangle_longitude*3-3;\n    }\n    if(triangle_longitude == 0) {\n        if(cell.y == 0 && cell.z < gp_index) {\n            cell.yx = cell.xy;\n            barycentric = vec3(-barycentric.y, 1.0-barycentric.z, 1.0-barycentric.x);\n            triangle_latitude = (triangle_latitude+1)%5; // (triangle_latitude+1+triangle_longitude)%5;\n        } else if(triangle_latitude > 0 && cell.z == gp_index) {\n            for(int i = 5; i > triangle_latitude; --i)\n                barycentric = vec3(-barycentric.y, 1.0-barycentric.z, 1.0-barycentric.x);\n            triangle_latitude = 0;\n        }\n    } else if(triangle_longitude == 3) {\n        if(cell.x == 0 && cell.z < gp_index) {\n            cell.yx = cell.xy;\n            barycentric = vec3(1.0-barycentric.z, -barycentric.x, 1.0-barycentric.y);\n            triangle_latitude = (triangle_latitude+1)%5; // (triangle_latitude+4-triangle_longitude)%5;\n        } else if(triangle_latitude > 0 && cell.z == gp_index) {\n            for(int i = 5; i > triangle_latitude; --i)\n                barycentric = vec3(1.0-barycentric.z, -barycentric.x, 1.0-barycentric.y);\n            triangle_latitude = 0;\n        }\n    }\n    \n    // Texture Coordinates\n    vec2 patched_texcoord = bary_to_texcoord((triangle_longitude%2 == 1) ? -barycentric : barycentric);\n    \n    // Texture\n    // fragColor.rgb = barycentric;\n    // ivec2 rectified_coords = triangle_longitude%2 == 1 ? ivec2(gp_index)-cell.xy : cell.xy;\n    // rectified_coords += gp_index*ivec2(triangle_latitude, triangle_longitude/2);\n    // fragColor.r = float(triangle_latitude)/5.0;\n    // fragColor.g = float(triangle_longitude)/4.0;\n    // fragColor.rgb = vec3(rectified_coords, 0.0)/float(5*gp_index);\n    // fragColor.rgb = vec3(cell)/float(gp_index)*0.8+vec3(0.2);\n    for(int i = 0; i < 3; ++i) {\n        vec3 color = color_of_cell(neighbors[i]);\n        color *= 0.9+0.1*checker_texture(patched_texcoord*40.0);\n        fragColor.rgb += color*color*blending_weights[i];\n    }\n    fragColor.rgb = sqrt(fragColor.rgb);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}