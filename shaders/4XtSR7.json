{
    "Shader": {
        "info": {
            "date": "1718825033",
            "description": "Menger sponge with a reflecting marble",
            "flags": 0,
            "hasliked": 0,
            "id": "4XtSR7",
            "likes": 4,
            "name": "Ã‰ponge de Menger",
            "published": 3,
            "tags": [
                "raymarching",
                "reflection",
                "menger",
                "sponge"
            ],
            "usePreview": 0,
            "username": "Docteur_Raton",
            "viewed": 67
        },
        "renderpass": [
            {
                "code": "// https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  \n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdBox2D(vec2 p, vec2 b)\n{\n    vec2 d = abs(p)-b;\n    \n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCross(vec3 p, float width)\n{\n    float da = sdBox2D(p.xy,vec2(width));\n    float db = sdBox2D(p.yz,vec2(width));\n    float dc = sdBox2D(p.zx,vec2(width));\n    \n    return min(da,min(db,dc));\n}\n\nfloat sdAxisX(vec3 p, float width)\n{\n    return abs(length(p.yz) - width);\n}\n\nfloat sdAxisY(vec3 p, float width)\n{\n    return abs(length(p.xz) - width);\n}\n\nfloat sdAxisZ(vec3 p, float width)\n{\n    return abs(length(p.xy) - width);\n}\n\nfloat sdSphere(vec3 p, float radius)\n{\n    return length(p) - radius;\n}\n\nmat2 rot(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    \n    return mat2(c, -s, s, c);\n}\n\nfloat map(vec3 p, out int closest)\n{\n    float axesWidth = .01;\n    float axisX = sdAxisX(p, axesWidth);\n    float axisY = sdAxisY(p, axesWidth);\n    float axisZ = sdAxisZ(p, axesWidth);\n    float box = sdBox(p, vec3(.5));\n    float numIterations = 7.;\n    box = max(box, -sdCross(p, 1. / (2. * 3.)));\n    for (float s = 9.; s < pow(3., numIterations + 1.); s *= 3.)\n    {\n        float offset = 1. / s;\n        vec3 q = mod(p + offset / 2., offset) - offset / 2.;\n        box = max(box, -sdCross(q, 1. / (6. * s)));\n    }\n    float sphere = sdSphere(p, .05);\n    float d = min(box, sphere);\n    if (d == axisX)\n        closest = 0;\n    else if (d == axisY)\n        closest = 1;\n    else if (d == axisZ)\n        closest = 2;\n    else if (d == box)\n        closest = 3;\n    else if (d == sphere)\n        closest = 4;\n    \n    return d;\n}\n\n// https://iquilezles.org/articles/palettes/\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 warmPalette(float t)\n{\n    // http://dev.thi.ng/gradients/\n    vec3 a = vec3(0.938, 0.328, 0.718);\n    vec3 b = vec3(0.659, 0.438, 0.628);\n    vec3 c = vec3(0.445, 0.445, 0.17);\n    vec3 d = vec3(2.538, 2.478, 0.228);\n    \n    return palette(t, a, b, c, d);\n}\n\n// https://blog.maximeheckel.com/posts/painting-with-math-a-gentle-study-of-raymarching/\nvec3 getNormal(vec3 p)\n{\n    vec2 e = vec2(.01, 0);\n    int tmp = 0;\n    vec3 n = map(p, tmp) - vec3(\n        map(p-e.xyy, tmp),\n        map(p-e.yxy, tmp),\n        map(p-e.yyx, tmp));\n\n    return normalize(n);\n}\n\nvec3 march(vec2 uv)\n{\n    vec3 ro = vec3(0., 0., -.1);\n    vec3 rd = normalize(vec3(uv, 1.));\n    float phase = .25 * iTime;\n    rd.xz *= rot(-2. * (iMouse.x / iResolution.x - .5));\n    rd.yz *= rot(-2. * (iMouse.y / iResolution.y - .5));\n    ro.xz *= rot(phase);\n    rd.xz *= rot(phase);\n    vec3 p = ro;\n    float i;\n    float numIterations = 300.;\n    for (i = 0.; i < numIterations; ++i)\n    {\n        int closest;\n        float d = map(p, closest);\n        if (d > 100.)\n        {\n            break;\n        }\n        if (d > 0.00005)\n        {\n            p += 0.5 * d * rd;\n            continue;\n        }\n        switch (closest)\n        {\n        case 0:\n            return vec3(1., 0., 0.);\n        case 1:\n            return vec3(0., 1., 0.);\n        case 2:\n            return vec3(0., 0., 1.);\n        case 3:\n            return warmPalette(1.5 - 6. * (i / numIterations)) / 1.5;\n        case 4:\n            vec3 normal = getNormal(p);\n            if (dot(rd, normal) < 0.)\n                rd = reflect(rd, normal);\n            p += d * rd;\n        }\n    }\n    \n    return warmPalette(.1 * (1. + rd.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy)/iResolution.y;\n    vec3 col = march(uv);\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}