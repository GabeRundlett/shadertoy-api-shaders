{
    "Shader": {
        "info": {
            "date": "1718761238",
            "description": "Colorized Mandelbrot",
            "flags": 48,
            "hasliked": 0,
            "id": "XXcSRM",
            "likes": 4,
            "name": "PseudoElectric",
            "published": 3,
            "tags": [
                "mandelbrot"
            ],
            "usePreview": 1,
            "username": "kosalos",
            "viewed": 118
        },
        "renderpass": [
            {
                "code": "/*\nKey Commands:\n<Up,Dn Arrows> : select widget focus. PgUp,PgDn hop by 5 entries.\n<Lt,Rt Arrows> : alter value of focused widget\n<0>   : focused value -> 0.0\n<E>   : animate just focused value (A,Z affect amount)\n<X>   : toggle animation\n<Spc> : reset\n\nDrag mouse on X axis to alter focused widget value.\nNote: mouse X affects focused value, mouse Y affects next entry\n\nAccelerated changes while holding down arrow keys or moving the mouse:\nHold down <A> for change Amount * 0.1\nHold down <Z> for change Amount * 10.\nHold down both <A><Z> for change Amount * 50.\n \nShape design:           https://fractalforums.org/code-snippets-fragments/74/pseudo-buddha/5085/msg37104#new\nText display:           https://www.shadertoy.com/view/mdsSD7\nKeyboard:               https://www.shadertoy.com/view/lsXGzf\nJavascript rendition:   https://openprocessing.org/sketch/2151338\n\n*/\n\nvec3 data[PDATA_ADDR_COUNT]; // copy of storage data for animation and drawing\n\n#define qiterations     data[0].x\n#define qzoom           data[0].y\n#define qpanx           data[0].z\n#define qpany           data[1].x\n#define qsubframe       data[1].y\n#define qpower          data[1].z\n#define qinitialpower   data[2].x\n#define qbright         data[2].y\n#define qcontrast       data[2].z\n#define qr              data[3].x\n#define qg              data[3].y\n#define qb              data[3].z\n#define qswizzle        data[4].x\n#define qinvert         data[4].y\n\n#define focus           data[5].x\n#define displayCount    data[5].y\n#define animationEnable data[5].z\n\n// --------------------------------------------------------\n\nconst ivec2[] legends = ivec2[](\n    cI,ct,ce,cr,ca,ct,ce,c0,\n    cZ,co,co,cm,c0,c0,c0,c0,\n    cP,ca,cn,cX,c0,c0,c0,c0,\n    cP,ca,cn,cY,c0,c0,c0,c0,\n    cS,cu,cb,cf,cr,ca,cm,ce,\n    cP,co,cw,ce,cr,c0,c0,c0,\n    cI,cn,ci,ct,ci,ca,cl,cP,\n    cB,cr,ci,cg,ch,ct,c0,c0,\n    cC,co,cn,ct,cr,ca,cs,ct,\n    cC,co,cl,co,cr,cR,c0,c0,\n    cC,co,cl,co,cr,cG,c0,c0,\n    cC,co,cl,co,cr,cB,c0,c0,\n    cS,cw,ci,cz,cz,cl,ce,c0,\n    cI,cn,cv,ce,cr,ct,c0,c0);\n\nvoid displayData(inout vec4 fragColor, in vec2 fragCoord) {\n    if(fragCoord.x > iResolution.x * 0.35) return; // no printing in that region\n    if(fragCoord.y < iResolution.y * 0.95) return;\n\n    Font f;\n    setFont(f,iChannelResolution[3].xy / vec2(16, 16),iChannelResolution[3].xy);\n\n    TextCursor t;\n    const vec2 charScale = vec2(30,30);\n    t.startPos = vec2(0, iResolution.y);\n    t.coord = ivec2(0.);\n    t.font = f;\n    t.color = vec4(1.);\n    t.charSize = charScale;\n    t.charSpace = vec2(0.7, 1) * charScale;\n    t.pageWidth = int(iResolution.x / t.charSize.x);\n    t.fragCoord = fragCoord;\n    \n    int ifocus = int(focus); \n    int index = ifocus / 3;\n    int field = ifocus % 3;\n\n    printInt(ifocus+1,t);\n    printChar(cSp,t);\n    \n    int legendIndex = ifocus * 8;\n    for(int i=0;i<8;++i) {\n        ivec2 chr = legends[legendIndex+i];\n        if(chr == c0) break;\n        printChar(chr,t);\n    }\n    \n    bool isInteger = pData[ifocus].delta == INTEGER || pData[ifocus].delta == SLOWINTEGER;\n    \n    printChar(cSp,t);\n    printFloat(data[index][field], t,isInteger ? 0 : 4);\n    drawText(t, iChannel3, fragColor);\n}\n\n// animation routines ----------------------------------------\n\nvoid cycleValue(int focusIndex,float deviation, float speed) {\n    float ratio = 1.0 + cos(iTime * speed);  // 0 ... 2\n    \n    int index = focusIndex / 3;\n    int field = focusIndex % 3;\n    \n    data[index][field] = clamp(data[index][field] -deviation + deviation * ratio, pData[focusIndex].vmin, pData[focusIndex].vmax);\n}\n\nvoid alterparams() {\n    float amt = 0.03;\n\n    cycleValue(1, 0.02, 0.1 );\n    cycleValue(5, 0.05, 0.2 );\n    cycleValue(6, 1.,   0.3 );\n    cycleValue(9, 1.,   0.3 );\n    cycleValue(10, 1.,   0.4 );\n    cycleValue(11, 1.,   0.5 );\n}\n\nvoid animate() {\n    if(animationEnable == 0.) return;\n    alterparams();\n}\n\n// --------------------------------------------------------\n\nvec2 complexPower(vec2 value, float power) {\n    float rr = value.x * value.x + value.y * value.y; // radius squared\n    if(rr == 0.0) return vec2(0.0001,0.0001);\n    \n    float p1 = pow(rr, power / 2.0);\n    float arg = atan(value.y, value.x);\n    return vec2(cos(power * arg) * p1, sin(power * arg) * p1);\n}\n\nfloat p(vec2 z, vec2 c, int n) {\n    vec2 v = vec2(0);\n    \n    for(int i=0;i<150;i++) {\n        if(i >= n) break;\n        v = complexPower(v, 2.0) + z;\n    }\n\n    return log(dot(v+z,v+z));\n}    \n    \n// --------------------------------------------------------\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    const float bailout = 4.0;\n    \n    for(int i=0;i<PDATA_ADDR_COUNT;++i)  // get copy of storage data\n        data[i] = fetchData(iChannel0, storeAddr[i]).xyz;\n    animate();                           // optionally alter some of the values\n    \n    float zoomY = qzoom * iResolution.y / iResolution.x; // square aspect ratio\n    vec2 uv = fragCoord / iResolution.xy;  // pixel coord mapped 0...1\n    \n    // pixel value panned and zoomed\n    vec2 z = vec2(0.);\n\tvec2 cc = vec2((uv.x - 0.5) * qzoom - qpanx, (uv.y - 0.5) * zoomY - qpany);    \n    \n    float val = bailout;\n    float va2 = 0.0;\n    int iterate = int(qiterations);\n    int isubframe = int(qsubframe);\n    float d = abs(p(z,cc,isubframe)-1.0);\n\n    for(int i=0;i<iterate;i++) {\n        z = complexPower(z,qpower) + cc;\n        if (length(z) > bailout) break;\n\n        if (d < val) val = d;\n        d = abs(p(z, cc,isubframe) - qinitialpower);\n        va2 += 0.5*log(d);\n    }\n\n    val += va2 * 0.01;\n\n    float offset = 1.0 - val;\n    float r = qbright + qr * offset * offset;\n    float g = qbright + qg * val * val;\n    float b = qbright + qb * 2.0 * offset * val;\n\n    r = 0.5 + (r - 0.5) * qcontrast;\n    g = 0.5 + (g - 0.5) * qcontrast;\n    b = 0.5 + (b - 0.5) * qcontrast;\n    \n\tfor(int i = 0;i < int(qswizzle);++i) {\n\t\tfloat t = r;\n\t\tr = g;\n\t\tg = b;\n\t\tb = t;\n\t}\n\n\tif(qinvert > 0.5) {\n\t\tr = 1.0 - r;\n\t\tg = 1.0 - g;\n\t\tb = 1.0 - b;\n\t}\n        \n    fragColor = vec4(r,g,b, 1.0);\n\n    if(displayCount > 0.) \n        displayData(fragColor,fragCoord);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const int maxStringLength = 8;\nconst ivec2 cNl    = ivec2(-1, -1);\nconst ivec2 cSp    = ivec2( 0, 13);\nconst ivec2 cPlus  = ivec2(11, 13);\nconst ivec2 cMinus = ivec2(13, 13);\nconst ivec2 cDot   = ivec2(14, 13);\n\nconst ivec2[10] Digits = ivec2[10]\n(\n    ivec2(0, 12), ivec2(1, 12), ivec2(2, 12), ivec2(3, 12), ivec2(4, 12),\n    ivec2(5, 12), ivec2(6, 12), ivec2(7, 12), ivec2(8, 12), ivec2(9, 12)\n);\n#define chd(name, index) const ivec2 name = Digits[index];\nchd(c0,  0) chd(c1,  1) chd(c2,  2) chd(c3,  3) chd(c4,  4)\nchd(c5,  5) chd(c6,  6) chd(c7,  7) chd(c8,  8) chd(c9,  9)\n\nconst ivec2[26] Uppercase = ivec2[26]\n(\n    ivec2( 1, 11), ivec2( 2, 11), ivec2( 3, 11), ivec2( 4, 11), ivec2( 5, 11),\n    ivec2( 6, 11), ivec2( 7, 11), ivec2( 8, 11), ivec2( 9, 11), ivec2(10, 11),\n    ivec2(11, 11), ivec2(12, 11), ivec2(13, 11), ivec2(14, 11), ivec2(15, 11),\n    ivec2( 0, 10), ivec2( 1, 10), ivec2( 2, 10), ivec2( 3, 10), ivec2( 4, 10),\n    ivec2( 5, 10), ivec2( 6, 10), ivec2( 7, 10), ivec2( 8, 10), ivec2( 9, 10),\n    ivec2(10, 10)\n);\n#define chu(name, index) const ivec2 name = Uppercase[index];\nchu(cA,  0) chu(cB,  1) chu(cC,  2) chu(cD,  3) chu(cE,  4)\nchu(cF,  5) chu(cG,  6) chu(cH,  7) chu(cI,  8) chu(cJ,  9)\nchu(cK, 10) chu(cL, 11) chu(cM, 12) chu(cN, 13) chu(cO, 14)\nchu(cP, 15) chu(cQ, 16) chu(cR, 17) chu(cS, 18) chu(cT, 19)\nchu(cU, 20) chu(cV, 21) chu(cW, 22) chu(cX, 23) chu(cY, 24)\nchu(cZ, 25)\n\nconst ivec2[26] Lowercase = ivec2[26]\n(\n    ivec2( 1,  9), ivec2( 2,  9), ivec2( 3,  9), ivec2( 4,  9), ivec2( 5,  9),\n    ivec2( 6,  9), ivec2( 7,  9), ivec2( 8,  9), ivec2( 9,  9), ivec2(10,  9),\n    ivec2(11,  9), ivec2(12,  9), ivec2(13,  9), ivec2(14,  9), ivec2(15,  9),\n    ivec2( 0,  8), ivec2( 1,  8), ivec2( 2,  8), ivec2( 3,  8), ivec2( 4,  8),\n    ivec2( 5,  8), ivec2( 6,  8), ivec2( 7,  8), ivec2( 8,  8), ivec2( 9,  8),\n    ivec2(10,  8)\n);\n#define chl(name, index) const ivec2 name = Lowercase[index];\nchl(ca,  0) chl(cb,  1) chl(cc,  2) chl(cd,  3) chl(ce,  4)\nchl(cf,  5) chl(cg,  6) chl(ch,  7) chl(ci,  8) chl(cj,  9)\nchl(ck, 10) chl(cl, 11) chl(cm, 12) chl(cn, 13) chl(co, 14)\nchl(cp, 15) chl(cq, 16) chl(cr, 17) chl(cs, 18) chl(ct, 19)\nchl(cu, 20) chl(cv, 21) chl(cw, 22) chl(cx, 23) chl(cy, 24)\nchl(cz, 25)\n\nstruct String {\n    int count;\n    ivec2[maxStringLength] chars;\n};\n\n\n// ========================================================================\n// visit: https://www.shadertoy.com/view/mdsSD7\n// This code is released into the public domain.\n// If you need a license instead, consider this CC0, MIT or BSD licensed, take your pick.\n\n// If you want to print numbers larger than 32 digits, increase maxStringLength\n\n#define setString(string, n, contents)\\\n{\\\n    ivec2[n] _s_ = ivec2[n] contents ;\\\n    for(int _i_ = 0; _i_ < min(maxStringLength, n); _i_++)\\\n    {\\\n        string.chars[_i_] = _s_[_i_];\\\n    }\\\n    string.count = n;\\\n}\n#define declString(string, n, contents)\\\nString string;\\\n{\\\n    ivec2[n] _s_ = ivec2[n] contents ;\\\n    for(int _i_ = 0; _i_ < min(maxStringLength, n); _i_++)\\\n    {\\\n        string.chars[_i_] = _s_[_i_];\\\n    }\\\n    string.count = n;\\\n}\n\nstruct Font {\n    vec2 texSize;\n    vec2 charSize;\n    vec2 ct;\n};\n\n#define setFont(ff,c,t) ff.charSize = c; ff.texSize = t; ff.ct = c/t;\n\nstruct TextCursor {\n    vec2 startPos;\n    ivec2 coord;\n    Font font;\n    vec4 color;\n    vec2 charSize;\n    vec2 charSpace;\n    int pageWidth;\n    vec2 fragCoord;\n    vec2 outUV;\n    vec4 outColor;\n};\n\nvec4 getFontCharRect(in Font f, ivec2 char) {\n    return vec4(char, char+ivec2(1)) * f.ct.xyxy;\n}\n\nvec4 getCharScreenRect(in TextCursor t)\n{\n    vec2 leftTop = t.startPos + t.charSpace * vec2(t.coord.x, -t.coord.y);\n    vec2 rightBottom = leftTop + t.charSize * vec2(1, -1);\n    \n    return vec4(leftTop.x, rightBottom.y, rightBottom.x, leftTop.y);\n}\n\nvoid updateOutUV(ivec2 char, inout TextCursor t) {\n    vec4 fontRect = getFontCharRect(t.font, char);\n    vec4 screenRect = getCharScreenRect(t);\n    vec2 screenRectUV = (t.fragCoord - screenRect.xy) / (screenRect.zw - screenRect.xy);\n    \n    if(clamp(screenRectUV, vec2(0), vec2(1)) != screenRectUV) return;\n    \n    t.outUV = screenRectUV * (fontRect.zw - fontRect.xy) + fontRect.xy;\n    t.outColor = t.color;\n}\n\nvoid incrementCursor(inout TextCursor t)\n{\n    t.coord.x += 1;\n    if(t.coord.x >= t.pageWidth)\n    {\n        t.coord.x = 0;\n        t.coord.y += 1;\n    }\n}\n\nvoid newlineCursor(inout TextCursor t)\n{\n    t.coord.x = 0;\n    t.coord.y += 1;\n}\n\nvoid printChar(ivec2 char, inout TextCursor t)\n{\n    if(char == cNl)\n    {\n        newlineCursor(t);\n        return;\n    }\n    \n    updateOutUV(char, t);\n    incrementCursor(t);\n}\n\nvoid printString(String s, inout TextCursor t)\n{\n    for(int i = 0; i < min(s.count, maxStringLength); i++)\n    {\n        printChar(s.chars[i], t);\n    }\n}\n\n/*\nvoid blend(vec4 src, inout vec4 dest)\n{\n    dest.rgb = mix(dest.rgb, src.rgb, src.a);\n    dest.a = mix(dest.a, 1.0, src.a);\n}\n\nvoid printLine(String s, inout TextCursor t)\n{\n    for(int i = 0; i < min(s.count, maxStringLength); i++)\n    {\n        printChar(s.chars[i], t);\n    }\n    printChar(cNl, t);\n}\n*/\nvoid printInt(int val, inout TextCursor t) {\n    if(val < 0)\n    {\n        printChar(cMinus, t);\n        val = -val;\n    }\n    \n    int[maxStringLength] digits;\n    int count = 0;\n    \n    for(;;)  {\n        digits[count++] = val % 10;\n        \n        if(count >= maxStringLength)\n            break;\n        \n        val /= 10;\n        \n        if(val == 0)\n            break;\n    }\n    \n    for(int i = count-1; i >= 0; i--)\n        printChar(Digits[digits[i]], t);\n}\n\n\nvoid printFloat(float val, inout TextCursor t,int fractCount) {\n    if(val < 0.0) {\n        printChar(cMinus, t);\n        val = -val;\n    }\n    \n    int[maxStringLength] digits;\n    int count = 0;\n    \n    int iVal = int(val);\n    val -= float(iVal);\n    \n    for(;;) {\n        digits[count++] = iVal % 10;\n        \n        if(count >= maxStringLength)\n            break;\n        \n        iVal /= 10;\n        \n        if(iVal == 0)\n            break;\n    }\n    \n    for(int i = count-1; i >= 0; i--)\n        printChar(Digits[digits[i]], t);\n    \n    if(fractCount == 0)  return;\n    printChar(cDot, t);\n        \n    for(int i = 0; i < fractCount; i++) {\n        val *= 10.0;\n        \n        int digit = int(val);\n        val -= float(digit);\n        \n        printChar(Digits[digit], t);\n        \n        if(val <= 0.0)\n            break;\n    }\n}\n\nvoid drawText(TextCursor t, sampler2D fontTexture, inout vec4 fragColor) {\n    fragColor = t.outColor;\n    if(texture(fontTexture, t.outUV).r < 0.2)\n        fragColor = vec4(0.4,0.4,0.4,10.);\n/*\n    fragColor = vec4(0.);\n    if(texture(fontTexture, t.outUV).r < 0.2)\n        fragColor = t.outColor;\n*/\n}\n\n// =====================================================================================\n// =====================================================================================\n\nstruct ParamData {\n    float start,vmin,vmax,delta;\n};\n\n#define INTEGER 1.\n#define SLOWINTEGER 0.9\n#define UNUSED  999.\n#define UNUSEDP ParamData(0.,0.,0.,0.)\n\nconst ParamData[] pData = ParamData[](\n    //  0 p0 ---------------\n    ParamData(36.,5.,200.,INTEGER ),        // iterations\n    ParamData(0.0861, 0.0001, 200.0, 0.001), // zoom\n    ParamData(-0.403, -10., 10., 0.001 ),      // pan x\n    //  3 p1 ---------------\n    ParamData(-0.2333, -10., 10., 0.001 ),     // pan y\n    ParamData( 6., 1., 10., SLOWINTEGER ),   // subframe\n    ParamData(2.0, 0.5, 8., 0.0001 ),        // power\n    //  6 p2 ---------------\n    ParamData(0.6232, -10., 50., 0.02 ),     // init power\n    ParamData(0.2597, -0.5, 1., 0.01 ),      // Brightness\n    ParamData(2.0499, 0.1, 5., 0.01 ),       // Contrast\n    //  9 p3 ---------------\n    ParamData(1., 0., 1., 0.01 ),            // color R\n    ParamData(1., 0., 1., 0.01 ),            // color G\n    ParamData(1., 0., 1., 0.01 ),            // color B\n    // 12 p4 ---------------\n    ParamData(1., 0., 2., SLOWINTEGER ),     // swizzle\n    ParamData(1., 0., 1., INTEGER ),         // invert\n    UNUSEDP, \n    // 15 p5 ---------------\n    UNUSEDP,  // focus\n    UNUSEDP,  // displayCount\n    UNUSEDP   // animationFlag\n);\n\nconst int UI_SIZE = 14;  // #fields user interface\n\nconst ivec2 P0_ADDR =  ivec2( 0, 0);\nconst ivec2 P1_ADDR =  ivec2( 1, 0);\nconst ivec2 P2_ADDR =  ivec2( 2, 0);\nconst ivec2 P3_ADDR =  ivec2( 3, 0);\nconst ivec2 P4_ADDR =  ivec2( 4, 0);\nconst ivec2 P5_ADDR =  ivec2( 5, 0);\nconst int PDATA_ADDR_COUNT = 6;\n\n#define FOCUS_ADDR P5_ADDR\n\nconst ivec2[] storeAddr = ivec2[](P0_ADDR,P1_ADDR,P2_ADDR,P3_ADDR,P4_ADDR,P5_ADDR);\n\n#define fetchData(buf, addr) texelFetch(buf, addr, 0)\n#define storeDataAddr(buf_pos, addr) ivec2(buf_pos) == addr\n#define storeData(buf_pos, addr,data) if(ivec2(buf_pos) == addr) fragColor = data\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\nvoid initializeStorage(inout vec4 fragColor,vec2 fragCoord) {\n    if (storeDataAddr(fragCoord, FOCUS_ADDR)) fragColor.xyz = vec3(0.);\n    \n    int pIndex = 0;\n    for(int i=0;i<PDATA_ADDR_COUNT;++i) {\n        if(storeDataAddr(fragCoord, storeAddr[i])) {\n            fragColor.xyz = vec3(0.);\n            if(pIndex+0 < UI_SIZE) fragColor.x = pData[pIndex+0].start;\n            if(pIndex+1 < UI_SIZE) fragColor.y = pData[pIndex+1].start;\n            if(pIndex+2 < UI_SIZE) fragColor.z = pData[pIndex+2].start;\n        }\n        \n        pIndex += 3;\n    }\n}\n\n// --------------------------------------------------------\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_SHIFT = 16;\nconst int KEY_CTRL  = 17;\nconst int KEY_ALT   = 18;\nconst int KEY_PGUP  = 33;\nconst int KEY_PGDN  = 34;\n\nbool keyClick(int ascii) {\n\treturn (texture(iChannel1,vec2((.5+float(ascii))/256.,0.25)).x > 0.);\n}\n\nbool getKeyState(int keyCode){\n    return bool(texelFetch(iChannel1, ivec2(keyCode,0), 0).x != 0.);\n}\n\nbool getKeyClick(int keyCode){\n    return bool(texelFetch(iChannel1, ivec2(keyCode,1), 0).x != 0.);\n}\n\nvoid acceleratedValue(inout float value) {\n    bool aKey = getKeyState(65);\n    bool zKey = getKeyState(90);\n    \n    if(aKey && zKey) value *= 50.; else\n    if(aKey) value *= 0.1; else\n    if(zKey) value *= 10.0;    \n}\n\n// --------------------------------------------------------\n\nbool alterFocusedVariable(int focus,int axis,inout vec3[PDATA_ADDR_COUNT] memory) {\n    if(focus > UI_SIZE-1) return false;\n    float changeAmount = 0.;\n    int focusIndex = focus / 3;  // memory index\n    int focusField = focus % 3;  // x,y,z field within\n\n    if(getKeyClick(48)) {  // '0' sets value to 0.\n        memory[focusIndex][focusField] = 0.;\n        changeAmount = 1.;   // so function returns true\n    }\n    else {\n        if(getKeyState(69)) { // 'E'\n            changeAmount = sin(iTime) * 0.25;\n        }\n        else {\n            if(axis == 0) { // arrow keys affect only focused variable \n            \n                if(pData[focus].delta == SLOWINTEGER) { \n                    if(getKeyClick(KEY_LEFT))  changeAmount = -pData[focus].delta; else\n                    if(getKeyClick(KEY_RIGHT)) changeAmount = +pData[focus].delta;\n                } else {\n                    if(getKeyState(KEY_LEFT))  changeAmount = -pData[focus].delta; else\n                    if(getKeyState(KEY_RIGHT)) changeAmount = +pData[focus].delta;\n                }\n            }\n\n            // mouse affects focused variable and also next one --------------\n            if(iMouse.z > 0.0) { // left mouse button down\n                vec2 delta = (iMouse.xy - abs(iMouse.zw)) * 0.01 * pData[focus].delta;\n                if(axis == 0) changeAmount = delta.x;\n                if(axis == 1) changeAmount = delta.y;\n             }\n        }\n\n        if(changeAmount != 0.) {\n            acceleratedValue(changeAmount);\n            memory[focusIndex][focusField] += changeAmount;\n        }\n    }\n       \n    memory[focusIndex][focusField] = clamp(memory[focusIndex][focusField],pData[focus].vmin,pData[focus].vmax);\n    \n    return changeAmount != 0.;\n}\n\n// --------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if(fragCoord.x > 20.0 || fragCoord.y > 1.0) return; // skip unused storage locations\n    \n    if(iFrame < 10 || keyClick(32)) {  // reset settings on coldstart or <Spc> keypress\n        initializeStorage(fragColor, fragCoord);\n        return; \n    }\n    \n    // ==========================================================       \n    // keyboard & mouse alter focused data (mouse also affects next entry) ---------\n    vec3[PDATA_ADDR_COUNT] memory; \n           \n    // fetch current values\n    for(int i=0;i<PDATA_ADDR_COUNT;++i)\n        if (storeDataAddr(fragCoord, storeAddr[i])) \n            memory[i] = fetchData(iChannel0, storeAddr[i]).xyz;\n\n    bool resetDisplayCount = false; \n    int focus = int(fetchData(iChannel0, FOCUS_ADDR).x);\n\n    if(alterFocusedVariable(focus,  0,memory)) resetDisplayCount = true;\n    if(alterFocusedVariable(focus+1,1,memory)) resetDisplayCount = true;\n    \n    // output possibly altered values\n    for(int i=0;i<PDATA_ADDR_COUNT;++i)\n        if (storeDataAddr(fragCoord, storeAddr[i])) \n            fragColor.xyz = memory[i];\n    // ==========================================================       \n\n    // alter focus.  update displayCount. toggle animationEnable --------\n    if (storeDataAddr(fragCoord, FOCUS_ADDR)) {\n        fragColor = fetchData(iChannel0, FOCUS_ADDR);\n        float focusChange = 0.;\n        if(getKeyClick(KEY_UP))   focusChange = -1.;\n        if(getKeyClick(KEY_DOWN)) focusChange = +1.;\n        if(getKeyClick(KEY_PGUP)) focusChange = -5.;\n        if(getKeyClick(KEY_PGDN)) focusChange = +5.;\n\n        if(focusChange != 0.) {\n        \n            //skip past UNUSED rows\n            while(true) {\n                fragColor.x += focusChange;\n                if(fragColor.x < 0.0) fragColor.x = float(UI_SIZE-1);\n                if(fragColor.x >= float(UI_SIZE)) fragColor.x = 0.0;\n                \n                if(pData[int(fragColor.x)].start != UNUSED) break;\n            }\n            \n            resetDisplayCount = true; \n        }\n        \n        if(resetDisplayCount) fragColor.y = iFrameRate; else\n        if(--fragColor.y < 0.0) fragColor.y = 0.0;  // so widget display times out \n        \n        bool kx = getKeyClick(88); // 'X'  animationEnable\n        if(kx) fragColor.z = (fragColor.z == 0.) ? 1. : 0.;\n    }   \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}