{
    "Shader": {
        "info": {
            "date": "1612476326",
            "description": "Alien mineral stones and creatures",
            "flags": 32,
            "hasliked": 0,
            "id": "wttBzM",
            "likes": 38,
            "name": "4D Wild Kifs",
            "published": 3,
            "tags": [
                "fractal",
                "ifs",
                "4d",
                "kifs"
            ],
            "usePreview": 0,
            "username": "iapafoto",
            "viewed": 921
        },
        "renderpass": [
            {
                "code": "#define AA\n#define iTime (iTime + cos(.75*iTime)-17.)\nvoid mainImage( out vec4 O, in vec2 U ) { \n    O = texture(iChannel0, U/iResolution.xy);\n\n#ifdef AA\n    if (O.w < DIST_MAX) {\n        vec4 T;         \n        for (float x=-.3; x<.4; x+=.6) {              \n            for (float y=-.3; y<.4; y+=.6) {  \n                mainImage2(T, U+vec2(x,y), iResolution.xy, iMouse.xy, iTime);  \n                O += T;\n            }\n        }\n        O /= 5.;\n    }\n#endif\n\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by sebastien durand - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// ----------------------------\n// based on [wyatt] kaleidoscope iterative function - https://www.shadertoy.com/view/MdKyRw\n// ----------------------------\n\n\n// Kifs paremeters\n#define ITER 17\n#define SCALE .766\n#define ADD -.75*vec4(3.,-.075,0.,2.3)\n\n\n// Ray Marching parameters\n#define RAY_STEP 100\n#define DIST_MAX 5.5\n\nmat4 rot1, mRot;\nvec4 closest = vec4(999.,0,0,0);\n\n// 4D adaptation of Kif fractal\nvec4 map(vec4 p) {\n    vec4 ot = vec4(0);\n    float t = .09;\n    for (int i = 0; i < ITER; i++) {\n        t = t*SCALE;\n        p += t*ADD;      \n        p.wxyz *= mRot;\n        p = abs(p) - t;\n        ot += p/t;\n    }\n    return vec4((length(p)-2.*t),         // Distance\n                4.*ot.xwz/(pow(abs(ot.y),1.7)+.01)); // Color (4th Dimension give electric colors tuch !!!)\n}\n\nvec4 castRay(vec4 ro, vec4 rd) {\n\tconst float precis = .005;\n    float h = precis*2., t = 1.;\n\tvec4 res;\n    closest = vec4(999.,0,0,0);\n    for (int i=0; i<RAY_STEP; i++ ) {\n        if (abs(h)<precis || t>DIST_MAX) break;\n        t += h;\n        res = map( ro+rd*t );\n        h = res.x;\n        if (h < closest.x) // get closest for halo\n            closest.x = h;\n        closest.yzw += res.yzw; // halo color\n    }\n    return vec4( t, res.yzw );\n}\n\nfloat softshadow(vec4 ro, vec4 rd, float mint) {\n\tfloat res = 1.,\n          h,t = mint;\n    for( int i=0; i<16; i++ ) {\n        h = map( ro + rd*t ).x;\n        res = min( res, 7.*h/t );\n        t += .028;\n    }\n    return clamp( res-.6, .0, 1. );\n}\n\nvec4 calcNormal(vec4 p) {\n    const vec2 e = vec2( 1e-3, 0.);\n\treturn normalize(vec4(\n\t    map(p+e.xyyy).x - map(p-e.xyyy).x,\n\t    map(p+e.yxyy).x - map(p-e.yxyy).x,\n\t    map(p+e.yyxy).x - map(p-e.yyxy).x,\n\t\tmap(p+e.yyyx).x - map(p-e.yyyx).x\n\t));\n}\n\nfloat calcAO(vec4 p, vec4 n ){\n\tfloat dd, hr, ao = 0., k = 1.;\n    vec4 pos; \n    for( int aoi=0; aoi<5; aoi++ ) {\n        hr = .01 + .05*float(aoi);\n        pos =  n * hr + p;\n        ao += -(map(pos).x-hr)*k;\n        k *= .75;\n    }\n    return clamp( 1. - 4.*ao, 0., 1. );\n}\n\nvec3 render(vec4 ro, vec4 rd , vec3 backColor, out float d, vec4 lig){ \n    vec3 col;\n    vec4 res = castRay(ro,rd);\n    float t = res.x;\n\tvec3 uvw = .85*res.yzw;\n    \n    if (t<DIST_MAX) {\n        vec4 pos = ro + t*rd,\n             nor = calcNormal( pos );\n\n\t\tcol = vec3(.4) + .6*abs(uvw);\n\t\t\n        float ao = calcAO( pos, nor ); ao*=ao;\n        float dif = clamp( dot( nor, lig ), 0., 1. ),\n              bac = clamp( dot( nor, normalize(vec4(-lig.x,0.,-lig.z,0.))), 0., 1. )*clamp(1.-pos.y,0.,1.);\n\n\t\tfloat sh = 1.;\n\t\tif (dif>.02) { \n            sh = softshadow( pos, lig, .025); \n            dif *= sh; \n        }\n\n\t\tvec3 brdf =  .1*vec3(.10,.11,.13)*ao;\n             brdf += .2*bac*vec3(.15)*ao;\n             brdf += .8*dif*vec3(1,.9,.7);\n\n\t\tfloat pp = clamp( dot( reflect(rd,nor), lig ), 0., 1. ),\n              spe = sh*pow(pp,16.),\n              fre = ao*pow( clamp(1.+dot(nor,rd),0.,1.), 2. );\n\n\t\tcol = col*brdf + 2.*(.5+.5*col)*spe + .4*fre*(.6+.4*col);\n\t\n    } else {\n        col = mix(backColor, clamp(.004*closest.yzw,0.,1.), smoothstep(.42,0.,pow(closest.x,.4)));\n    }\n    \n    d = t;\n\treturn vec3( clamp(col,0.,1.) );\n}\n\n// Rotation Matrix to apply to 4D objects\nmat4 Rot4(float a, float b, float c) {        \n    float c1 = cos(a), s1 = sin(a), \n          c2 = cos(b), s2 = sin(b), \n          c3 = cos(c), s3 = sin(c);\t\n    return mat4(c2,  s2*s3,   0, -s2*c3,   \n                 0,  c1*c3, -s1,  c1*s3,\n                 0,  c3*s1,  c1,  s1*s3,\n                s2, -c2*s3,   0,  c2*c3);\n}\n\n\nvoid mainImage2(out vec4 fragColor, vec2 fragCoord, vec2 R, vec2 M, float iTime ) {\n\n    vec2 q = fragCoord.xy/R.xy;\n    vec2 p = -1.0+2.0*q;\n    p.x *= R.x/R.y;\n    \n    // Noisy background\n    float h = dot(vec3(q,1.),vec3(127.1,311.7,758.5453123));\t\n\tvec3 colorSum = .75*(vec3(.0512) + .05*fract(sin(h)*43758.5453123));\n    \n    float d = 999.;\n    if (length(p)<.92) {\n        \n        vec2 mo = M.xy/R.xy;\t \n        float time = .5*iTime;\n        // Rotations\n        mRot = Rot4(.1*time, .351*time+2., .232*time+1.3);\n        rot1 = Rot4((iTime-3.)/2.031, 1.+(iTime-3.)/2.1, .1*iTime);\n        \n        // Camera (real cam4D definition available at: https://www.shadertoy.com/view/4tX3Rn)\n        vec4\n            ro = vec4(3.2*cos(.24*iTime + 6.*mo.x+ 1.), 1.5 + 2.*mo.y, 3.2*sin(.24*iTime+ 6.*mo.x+1.),0),\n            ta = vec4(0),\n            cw = normalize( ta-ro ),\n            cp = vec4(0,1,0,0),\n            cu = normalize(vec4(cross(cw.xyz,cp.xyz),0)),\n            cv = normalize(vec4(cross(cu.xyz,cw.xyz),0)),\n            rd = normalize( p.x*cu + p.y*cv + 2.5*cw ),\n            light = normalize(-cw*.5-cu+cv+.5*cp);\n\t\t\n        // Rotation of 4D scene\n        ro *= rot1;\n    \trd *= rot1;\n        light *= rot1;\n        \n        // Render\n\t\tcolorSum = render( ro, rd, colorSum, d, light);\n    }\n    \n    // Post process\n    vec3 col = pow(colorSum.xyz,vec3(.56));\n    col *= pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y), .5);    \n\tfragColor = vec4(col, d);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define iTime (iTime + cos(.75*iTime)-17.)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    mainImage2(fragColor, fragCoord, iResolution.xy, iMouse.xy, iTime);  \n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}