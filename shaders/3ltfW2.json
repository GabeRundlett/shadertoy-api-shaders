{
    "Shader": {
        "info": {
            "date": "1613491136",
            "description": "A classic Apple Watch clock face.",
            "flags": 0,
            "hasliked": 0,
            "id": "3ltfW2",
            "likes": 10,
            "name": "Apple Watch Clock",
            "published": 3,
            "tags": [
                "2d",
                "time",
                "clock"
            ],
            "usePreview": 0,
            "username": "moranzcw",
            "viewed": 457
        },
        "renderpass": [
            {
                "code": "// Apple Watch Clock - by moranzcw - 2021\n// Email: moranzcw@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define PI 3.14159265359\n#define ScaleWidth 0.04\n#define ClockSize 0.7\n\n#define HoursScaleWidth 0.015\n#define MinutesScaleWidth 0.004\n\n#define HourHandColor vec3(1.0)\n#define HourHandCoreSize 0.025\n#define HourHandLength1 0.1\n#define HourHandWidth1 0.005\n#define HourHandLength2 0.25\n#define HourHandWidth2 0.02\n\n#define MinuteHandColor vec3(1.0)\n#define MinuteHandCoreSize 0.025\n#define MinuteHandLength1 0.1\n#define MinuteHandWidth1 0.005\n#define MinuteHandLength2 0.5\n#define MinuteHandWidth2 0.02\n\n#define SecondHandColor vec3(0.961, 0.633, 0.332)\n#define SecondHandCoreSize 0.02\n#define SecondHandLength 0.7\n#define SecondHandWidth 0.0035\n\n#define PixelWidth 1.0/iResolution.y\n\nvec3 line(vec2 coord, vec2 p1, vec2 p2, float width, vec3 color)\n{\n    vec2 v1 = coord - p1;\n    vec2 v2 = p2 - p1;\n    float j1 = dot(v1, v2);\n    \n    vec2 v3 = coord - p2;\n    vec2 v4 = p1 - p2;\n    float j2 = dot(v3, v4);\n    \n    float len;\n    if( j1 > 0.0 && j2 > 0.0)\n    {\n        vec2 nv2 = normalize(v2);\n        len = length(v1 - dot(v1, nv2) * nv2);\n    }\n    else\n    {\n        len = min(length(v1),length(v3));\n    }\n    return color * smoothstep(width + 2.0*PixelWidth, width, len);\n}\n\nvec3 clockScale(vec2 coord)\n{\n    vec3 color;\n    \n    //\n    float l = length(coord);\n    float onRing = step(ClockSize-ScaleWidth, l) - step(ClockSize, l);\n    \n    //\n    float angle = atan(coord.y/coord.x);\n    float d1 = mod(angle, PI/6.0);\n    float d2 = d1 - PI/6.0;\n    float onHoursScale = step(-HoursScaleWidth,d1) - step(HoursScaleWidth,d1);\n    onHoursScale += step(-HoursScaleWidth,d2) - step(HoursScaleWidth,d2);\n    \n    // \n    float d3 = mod(angle, PI/30.0);\n    float d4 = d3 - PI/30.0;\n    float onMinutesScale = step(-MinutesScaleWidth,d3) - smoothstep(MinutesScaleWidth,MinutesScaleWidth+0.003,d3);\n    onMinutesScale += smoothstep(-MinutesScaleWidth-0.003, -MinutesScaleWidth,d4) - step(MinutesScaleWidth,d4);\n    \n    color += vec3(1.0) * onRing * onHoursScale;\n    color += vec3(0.6) * onRing * onMinutesScale;\n    return color;\n}\n\nvec3 hourHand(vec2 coord)\n{\n    vec3 color;\n    color += HourHandColor * smoothstep(HourHandCoreSize + PixelWidth, HourHandCoreSize, length(coord));\n    \n    float angle = 2.0 * PI * (iDate.w / 43200.0);\n    vec2 direction = vec2(sin(angle), cos(angle));\n    vec2 p1 = vec2(0.0);\n    vec2 p2 = direction * HourHandLength1;\n    color = max(color, line(coord, p1, p2, HourHandWidth1, HourHandColor));\n    p1 = direction * HourHandLength1;\n    p2 = p1 + direction * HourHandLength2;\n    color = max(color, line(coord, p1, p2, HourHandWidth2, HourHandColor));\n    \n    return color;\n}\n\nvec3 minuteHand(vec2 coord)\n{\n    vec3 color;\n    color += MinuteHandColor * smoothstep(MinuteHandCoreSize + PixelWidth, MinuteHandCoreSize, length(coord));\n    \n    float angle = 2.0 * PI * mod(iDate.w / 60.0, 60.0) / 60.0;\n    vec2 direction = vec2(sin(angle), cos(angle));\n    vec2 p1 = vec2(0.0);\n    vec2 p2 = direction * MinuteHandLength1;\n    color = max(color, line(coord, p1, p2, MinuteHandWidth1, MinuteHandColor));\n    p1 = direction * MinuteHandLength1;\n    p2 = p1 + direction * MinuteHandLength2;\n    color = max(color, line(coord, p1, p2, MinuteHandWidth2, MinuteHandColor));\n    \n    return color;\n}\n\nvec3 secondHand(vec2 coord)\n{\n    vec3 color;\n    color += SecondHandColor * smoothstep(SecondHandCoreSize + PixelWidth, SecondHandCoreSize, length(coord));\n    \n    float angle = 2.0 * PI * mod(iDate.w, 60.0) / 60.0;\n    vec2 direction = vec2(sin(angle), cos(angle));\n    vec2 p1 = direction * SecondHandLength;\n    vec2 p2 = -direction * 0.15 * SecondHandLength;\n    color = max(color, line(coord, p1, p2, SecondHandWidth, SecondHandColor));\n    \n    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 coord = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    \n    vec3 color;\n    vec3 temp;\n    temp = clockScale(coord);\n    color = step(1e-3, temp) * temp + step(length(temp), 1e-3) * color;\n    \n    temp = hourHand(coord);\n    color = step(1e-3, temp) * temp + step(length(temp), 1e-3) * color;\n    \n    temp = minuteHand(coord);\n    color = step(1e-3, temp) * temp + step(length(temp), 1e-3) * color;\n    \n    temp = secondHand(coord);\n    color = step(1e-3, temp) * temp + step(length(temp), 1e-3) * color;\n\n    float d = smoothstep(MinuteHandCoreSize*0.5 + PixelWidth, MinuteHandCoreSize*0.5, length(coord));\n    color = vec3(0.0) * d + color * (1.0-d);\n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}