{
    "Shader": {
        "info": {
            "date": "1497218968",
            "description": "A cephalopod mollusc with eight sucker-bearing arms, a soft sac-like body, strong beak-like jaws, and no internal shell.",
            "flags": 0,
            "hasliked": 0,
            "id": "MdsBz2",
            "likes": 87,
            "name": "Octopus",
            "published": 3,
            "tags": [
                "sdf",
                "water",
                "bokeh",
                "octopus",
                "tentacle",
                "predator"
            ],
            "usePreview": 1,
            "username": "knarkowicz",
            "viewed": 2610
        },
        "renderpass": [
            {
                "code": "const float MATH_PI = float( 3.14159265359 );\n\nfloat saturate( float x )\n{\n    return clamp( x, 0.0, 1.0 );\n}\n\nfloat Smooth( float x )\n{\n\treturn smoothstep( 0.0, 1.0, saturate( x ) );   \n}\n\nfloat Sphere( vec3 p, float s )\n{\n\treturn length( p ) - s;\n}\n\nfloat Capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat Union( float a, float b )\n{\n    return min( a, b );\n}\n\nfloat UnionRound( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5 * ( b - a ) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * ( 1.0 - h );\n}\n\nfloat SubstractRound( float a, float b, float r ) \n{\n\tvec2 u = max( vec2( r + a, r - b ), vec2( 0.0, 0.0 ) );\n\treturn min( -r, max( a, -b ) ) + length( u );\n}\n\nfloat Displace( float scale, float ampl, vec3 p )\n{\n    p *= ampl;\n\treturn scale * sin( p.x ) * sin( p.y ) * sin( p.z );\n}\n\nfloat RepeatAngle( inout vec2 p, float n ) \n{\n\tfloat angle = 2.0 * MATH_PI / n;\n\tfloat a = atan( p.y, p.x ) + angle / 2.0;\n\tfloat r = length( p );\n\tfloat c = floor( a / angle );\n\ta = mod( a, angle ) - angle / 2.;\n\tp = vec2( cos( a ), sin( a ) ) * r;\n\treturn c;\n}\n\nvoid Rotate( inout vec2 p, float a ) \n{\n    p = cos( a ) * p + sin( a ) * vec2( p.y, -p.x );\n}\n\nfloat Tentacle( vec3 p )\n{    \n    p.y += 0.3;\n    \n    float scale = 1.0 - 2.5 * saturate( abs( p.y ) * 0.25 );    \n    \n    p.x = abs( p.x );\n    \n    p -= vec3( 1.0, -0.5, 0.0 );\n    Rotate( p.xy, 0.4 * MATH_PI );\n    p.x -= sin( p.y * 5.0 + iTime * 1.6 ) * 0.05;\n    \n    vec3 t = p;    \n    \n    float ret = Capsule( p, vec3( 0.0, -1000.0, 0.0 ), vec3( 0.0, 1000.0, 0.0 ), 0.25 * scale );\n\n    p.z = abs( p.z );\n    p.y = mod( p.y + 0.08, 0.16 ) - 0.08;\n    p.z -= 0.12 * scale;\n    float tent = Capsule( p, vec3( 0.0, 0.0, 0.0 ), vec3( -0.4 * scale, 0.0, 0.0 ), 0.1 * scale );\n    \n    float pores = Sphere( p - vec3( -0.4 * scale, 0.0, 0.0 ), mix( 0.04, 0.1, scale ) );\n    tent = SubstractRound( tent, pores, 0.01 );\n  \n    ret = UnionRound( ret, tent, 0.05 * scale );\n    ret += textureLod( iChannel0, vec2( t.xy * 0.5 ), 0. ).x * 0.01;\n    \n    return ret;\n}\n\nfloat Scene( vec3 p )\n{   \n    p.z += cos( p.y * 0.2 + iTime ) * 0.11;\n    p.x += sin( p.y * 5.0 + iTime ) * 0.05;    \n    p.y += sin( iTime * 0.51 ) * 0.1;\n    \n    Rotate( p.yz, 0.45 + sin( iTime * 0.53 ) * 0.11 );\n    Rotate( p.xz, 0.12 + sin( iTime * 0.79 ) * 0.09 );\n    \n    vec3 t = p;\n    RepeatAngle( t.xz, 8.0 );\n    float ret = Tentacle( t );\n\n    p.z += 0.2;\n    p.x += 0.2;\n        \n    float body = Sphere( p - vec3( -0.0, -0.3, 0.0 ), 0.6 );\n    \n    t = p;    \n    t.x *= 1.0 - t.y * 0.4;\n    body = UnionRound( body, Sphere( t - vec3( -0.2, 0.5, 0.4 ), 0.8 ), 0.3 ); \n    \n    body += Displace( 0.02, 10.0, p );\n    body += textureLod( iChannel0, vec2( p.xy * 0.5 ), 0. ).x * 0.01;\n   \n    ret = UnionRound( ret, body, 0.05 );   \n    \n    ret = SubstractRound( ret, Sphere( p - vec3( 0.1, -1.0, 0.2 ), 0.4 ), 0.1 );        \n    \n\treturn ret;\n}\n\nfloat CastRay( in vec3 ro, in vec3 rd )\n{\n    const float maxd = 10.0;\n    \n\tfloat h = 1.0;\n    float t = 0.0;\n   \n    for ( int i = 0; i < 50; ++i )\n    {\n        if ( h < 0.001 || t > maxd ) \n        {\n            break;\n        }\n        \n\t    h = Scene( ro + rd * t );\n        t += h;\n    }\n\n    if ( t > maxd )\n    {\n        t = -1.0;\n    }\n\t\n    return t;\n}\n\nvec3 SceneNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 normal = vec3(\n\t    Scene( pos + eps.xyy ) - Scene( pos - eps.xyy ),\n\t    Scene( pos + eps.yxy ) - Scene( pos - eps.yxy ),\n\t    Scene( pos + eps.yyx ) - Scene( pos - eps.yyx ) );\n\treturn normalize( normal );\n}\n\nvec3 WaterKeyColor  = vec3( 0.09, 0.92, 0.98 );\nvec3 WaterFillColor = vec3( 0.1, 0.06, 0.28 );\n\nvec3 Water( vec3 rayDir )\n{\n    Rotate( rayDir.xy, -0.2 ); \n    vec3 color = mix( WaterKeyColor, WaterFillColor, Smooth( -1.2 * rayDir.y + 0.6 ) );\n    return color;\n}\n\nfloat Circle( vec2 p, float r )\n{\n    return ( length( p / r ) - 1.0 ) * r;\n}\n\nvoid BokehLayer( inout vec3 color, vec2 p, vec3 c, float radius )   \n{    \n    float wrap = 350.0;    \n    if ( mod( floor( p.y / wrap + 0.5 ), 2.0 ) == 0.0 )\n    {\n        p.x += wrap * 0.5;\n    }    \n    \n    vec2 p2 = mod( p + 0.5 * wrap, wrap ) - 0.5 * wrap;\n    float sdf = Circle( p2, radius );\n    color += c * ( 1.0 - Smooth( sdf * 0.01 ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n\tp.x *= iResolution.x / iResolution.y;\n\n    vec3 rayOrigin\t= vec3( -0.5, -0.5, -4.0 );\n\tvec3 rayDir \t= normalize( vec3( p.xy, 2.0 ) ); \n\n    vec3 background = Water( rayDir );\n      \n    p *= 400.0;\n    Rotate( p, -0.2 );  \n    BokehLayer( background, p + vec2( 125.0, -120.0 * iTime ), vec3( 0.1 ), 0.5 );\n    BokehLayer( background, p * 1.5 + vec2( 546.0, -80.0 * iTime ), vec3( 0.07 ), 0.25 ); \n    BokehLayer( background, p * 2.3 + vec2( 45.0, -50.0 * iTime ), vec3( 0.03 ), 0.1 ); \n\n    vec3 color = background;\n\tfloat t = CastRay( rayOrigin, rayDir );\n    if ( t > 0.0 )\n    {        \n        vec3 pos = rayOrigin + t * rayDir;\n        vec3 normal = SceneNormal( pos );\n        \n        float specOcc = Smooth( 0.5 * length( pos - vec3( -0.1, -1.2, -0.2 ) ) );\n\n  \n        vec3 c0\t= vec3( 0.95, 0.99, 0.43 );\n        vec3 c1\t= vec3( 0.67, 0.1, 0.05 );\n        vec3 c2\t= WaterFillColor;\n        vec3 baseColor = normal.y > 0.0 ? mix( c1, c0, saturate( normal.y ) ) : mix( c1, c2, saturate( -normal.y ) );\n                \n        vec3 reflVec = reflect( rayDir, normal );        \n        float fresnel = saturate( pow( 1.2 + dot( rayDir, normal ), 5.0 ) );\n        color = 0.8 * baseColor + 0.6 * Water( reflVec ) * mix( 0.04, 1.0, fresnel * specOcc );\n\n        float transparency = Smooth( 0.9 + dot( rayDir, normal ) );\n        color = mix( color, background, transparency * specOcc );\n    }\n    \n    float vignette = q.x * q.y * ( 1.0 - q.x ) * ( 1.0 - q.y );\n    vignette = saturate( pow( 32.0 * vignette, 0.05 ) );\n    color *= vignette;\n        \n    fragColor = vec4( color, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}