{
    "Shader": {
        "info": {
            "date": "1531607494",
            "description": "prototype for scene used in \"Digiverse\"\n\n    https://www.youtube.com/watch?v=p5p_qWKrKj0\n    http://www.pouet.net/prod.php?which=76719\n\n\n",
            "flags": 32,
            "hasliked": 0,
            "id": "MdcBz8",
            "likes": 32,
            "name": "Digiverse - cube",
            "published": 3,
            "tags": [
                "livecodpatu"
            ],
            "usePreview": 0,
            "username": "patu",
            "viewed": 965
        },
        "renderpass": [
            {
                "code": "/* \n\n\tDigiverse - cube \n\n\t\n\tCube from \"Digiverse\" (demoscene producion)\n\t\n    https://www.youtube.com/watch?v=p5p_qWKrKj0\n    http://www.pouet.net/prod.php?which=76719\n\n\n\thttp://bit.ly/shadertoy-plugin\n    https://github.com/patuwwy/ShaderToy-Notifier\n\n*/\n\n\n/// fake DOF + Bloom\nconst vec3 W = vec3(0.2125, 0.7154, 0.0721) * 2.;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 \n        buff = texelFetch(iChannel0, ivec2(fragCoord), 0),\n        mipm = textureLod(iChannel0, uv, 4.),\n        blur = textureLod(iChannel0, uv, 2.);\n    \n    float dof = pow(buff.a + .1, 9.);\n    \n\tfragColor = mix(buff, blur, clamp(dof, 0., 1.));\n    \n    vec4 bm = dot(normalize(mipm.rgb), W) >\n        dot(normalize(buff.rgb), W) ? mipm : buff;                      \n    \n    fragColor += pow(bm * dot(bm.rgb, W) * 2., vec4(2.1)) * 1.5;\n    \n    fragColor = pow(fragColor, 1./vec4(1.1)) - pow(length(uv - .5) * 1.3, 6.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#pragma optimize(off);\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\nvec2 uv;\nfloat snoise(vec2 p) {\n\tvec2 f = fract(p);\n\tp = floor(p);\n\tfloat v = p.x + p.y * 1e3;\n\tvec4 r = vec4(v, v + 1., v + 1e3, v + 1001.);\n\tr = fract(1e5 * sin(r * .001));\n\tf = f * f * (3. - f - f);\n\treturn 2. * (mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y)) - 1.;\n}\n\nfloat vmax(vec2 v) {return max(v.x, v.y);}\nfloat hash(float x) {return fract(sin(x * 4341.1) * 3123.8);}\nvoid pR(inout vec2 p, float a) { p = cos(a)*p + sin(a)*vec2(p.y, -p.x); }\nfloat smin( float a, float b, float k ) { return -log( exp( -k*a ) + exp( -k*b ) ) / k; }\n\nfloat sdBox( vec3 p, vec3 b ) { b = abs(p) - b; return min(max(b.x, max(b.y, b.z)), 0.) + length(max(b, 0.)); }\n#define sphere(p, r) (length(p)-r)\n\nfloat fCross(vec3 p, vec3 size) {\n    float obj = sdBox(p, size);\n    obj = min(obj, sdBox(p, size.zxy));\n    obj = min(obj, sdBox(p, size.yzx));               \n               return obj;\n}\n\nfloat crate(vec3 p, float d) {\n\tfloat sdf = max(-sdBox(p, vec3(11., d, d)), sdBox(p, vec3(10.)));\n    \n    sdf = max(-sdBox(p.zyx, vec3(11., d, d)), sdf);\n    sdf = max(-sdBox(p.yxz, vec3(11., d, d)), sdf);\n    return sdf;   \n}\n\nfloat map(vec3 p) {\n    \n    vec3 op = p, op2 = p;;\n    float ti = iTime * .3;\n    \n    float room = max(0., -sdBox(p, vec3(43.)));\n    \n    float a = sdBox(p + vec3(0., 31., 0.), vec3(22., 20., 22.)) + .2;\n    \n    p.y += snoise(vec2(ti)) * 6.;    \n    \n    pR(p.xy, ti);\n    pR(p.yz, ti + snoise(vec2(ti)) * 2.);\n    \n    float sdf = sdBox(p, vec3(7.)) + .2;\n    \n    vec3 p3 = p;\n    \n    pR(p.xz, PI/4.);\n    \n    p = op;\n    \n    sdf = smin(sdf, a, snoise((p.xy + p.yz) * .4) * .2  + .4 );\n    \n    sdf = min(room, sdf);\n    \n    return sdf * .95;\n}\n\nfloat trace(vec3 ro, vec3 rd) {\n    float d, s = .9, i = 0.;   \n    do { d = map(ro + rd * s); s += d; i++;} while (d > .09 && d < 154. && i < 60.);\n    return s;    \n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax) {\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; \n    \n    for( int i=0; i<32; i++ ) {\n\t\tfloat \n            h = map( ro + rd*t ),\n        \ty = h*h/(2.0*ph),\n        \td = sqrt(h*h-y*y);\n        \n        res = min( res, 10.*d / max(0.,t-y) );\n        ph = h;        \n        t += h;        \n        if( res < .0001 || t>tmax ) break;\n        \n    }\n    return clamp( res, .8, 1. );\n}\n\nvec3 randomSphereDir(vec2 rnd)\n{\n\tfloat \n        s = rnd.x * PI * 2.,\n\t\tt = rnd.y * 2. -1.;\n    \n\treturn vec3(sin(s), cos(s), t) / sqrt(1. + t * t);\n}\n\nvec3 randomHemisphereDir(vec3 dir, float i) {\n\tvec3 v = randomSphereDir( vec2(hash(i + 1.), hash(i + 2.)) );\n\treturn v * sign(dot(v, dir));\n}\n\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff )\n{\n\tconst int nbIte = 8;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv; \n\tfloat ao = 0.;\n    \n    for( int i=0; i<nbIte; i++ ) {\n        float l = hash(float(i)) * maxDist;\n        vec3 rd = normalize(n+randomHemisphereDir(n, l)*rad) * l;\n        ao += (l - max(map( p + rd ), 0.)) / maxDist * falloff;\n    }\n\t\n    return clamp(1. -ao * nbIteInv, 0.8, 1.);\n}\n\n#define EP 0.001\nvec3 normals(vec3 pos) {float d = map(pos);\treturn normalize(vec3(map(pos+vec3(EP,0,0))-d, map(pos+vec3(0,EP,0))-d, map(pos+vec3(0,0,EP))-d));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tuv = fragCoord.xy / iResolution.xy - .5;\n\n    vec3 \n        vuv = normalize(vec3(0., 1., 0.3)),\n    \teyePosition = vec3(sin(iMouse.x / 300.) * 0., 1.,  cos(iMouse.x / 300.) * 0.);\n    \n    float ti = iTime * .3;\n    \n    eyePosition += vec3(\n        sin(ti) * 40.,\n        0.,\n        cos(ti) * 40.\n    );    \n    \n    vec3\n        vrp = vec3(0.),\n    \tvpn = normalize(vrp - eyePosition),\n    \tu = normalize(cross(vuv, vpn)),\n    \tv = cross(vpn, u),\n    \tvcv = (eyePosition + vpn),\n    \tscrCoord = (vcv + uv.x * u * iResolution.x/iResolution.y + uv.y * v),\n    \tviewDirection = normalize(scrCoord - eyePosition);   \n    \n    \n    vec3 ro = eyePosition;\n    vec3 rd = viewDirection;\n    vec4 c, oc = vec4(0.);\n    \n    vec3 LIGHT = vec3(10., 0., 10.);\n    float initialDist = 1e10;\n    \n    LIGHT = vec3(sin(iTime) * 30., 0., cos(iTime) * 30.);\n    \n    float alpha = 0.;\n    vec3 nLight = normalize(LIGHT);\n    vec3 ihit;\n    for (int bounce = 0; bounce < 2; bounce++) {\n        \n        float march;\n        if (bounce == 0) {\n            march = trace(ro, rd);\n            initialDist = march;\n            ihit = ro + rd* march;\n            alpha = march / 140.;\n            oc = vec4(0.4);\n            \n        } else {\n            ro = ihit;\n            rd = normalize(rd);\n            ro += rd * .3;\n            march = trace(ro, rd);\n        }        \n        \n        if (march < 195.) {\n            ro += rd * march;\n            vec3 n = normals(ro);\n            \n            c.rgb = vec3(.0, 0., .6);    \n            \n            if (abs(n.x) > .9) c += vec4(1., .5, 0., 0.) * ceil(fract(ro.z * .04 - ti) - .5) * 3.;\n            if ((n.y) < -.9) c += vec4(1., 0., 0., 0.) * ceil(fract(ro.z * .04 - ti) - .5) * 3.;\n            \n            c *= pow(abs(snoise(n.xz * 3.) * 1.1), 13.) * 10.;\n            c += pow(max(0., dot(n, nLight)), 5.) * 2.5;\n            c = mix(vec4(0.0), c, (1.-(march/ 125.)) * .5);\n            \n            c *= ambientOcclusion(ro, n, 5.2, 11.2);\n            c *= calcSoftshadow(ro, nLight, 12.01, 4.1);\n                        \n            c += max(0., pow(dot(rd, nLight) * 1.0, 5.)) * .1;\n          \n            oc = mix(oc, c, .25);\n            \n            rd = reflect(rd, n);\n            \n            \n            rd = normalize(rd);\n            \n            ro += rd * .1;\n            alpha += .1;\n            \n        } \n       \n    }\n    \n    oc += max(0., pow(dot(rd, nLight) * 1.01, 12.));\n    oc = pow(abs(oc), 1. / vec4(1.75)) * .45;\n    \n    float flareDist = 1e9, camFlareDist= 1e9;\n    vec3 flareCol = vec3(0.), flareCol_B = vec3(0.);\n    ti = 0.;\n    \n    for (float k = 0.; k < 128.; k++) {\n        if (flareCol.r > 1.) break;\n        if (flareCol_B.r > 1.) break;\n        \n        vec3 flarePos = \n            vec3(\n                sin(k / 32.) * 35.,\n                -6.-cos(k / 6. - ti / 33.) * sin(k - k * 0.1 + sin(ti / 13.) * 2.) * 22. + 7.,\n                cos( ti /  14. + k / 12.) * 35. * (sin(ti * .2+ k) / 2. + .8)\n            );\n\t\tif (dot(normalize(flarePos), viewDirection) > 1.4) continue;\n        flareDist = min(distance(ihit, flarePos), flareDist); \n        camFlareDist = min(distance(eyePosition, flarePos), camFlareDist);\n        \n        const vec3 FLARE_COL = vec3(1.0, 0., .5);\n        \n        if (initialDist > distance(flarePos, eyePosition)) {\n           flareCol_B += 3.* FLARE_COL * pow(max(0., dot(normalize(-eyePosition + flarePos) * 1., viewDirection)), 450.) * .04;\n           flareCol_B += 3.* FLARE_COL * pow(max(0., dot(normalize(-ro + flarePos) * 0.99, rd) * 1.0), 350.);\n           flareCol += FLARE_COL.rrb * pow(pow(max(0., dot(normalize(-eyePosition + flarePos), viewDirection) * 1.0), 1e6 - distance(ro, flarePos) * 50.) / distance(ro, flarePos) * 100., 5.) * abs(sin(ti + k));\n        }\n        \n    }\n    \n    flareCol += flareCol_B;\n    flareCol = abs(flareCol) ;\n    \n    \n    oc.rgb += min(vec3(1.), flareCol) * smoothstep(3., 9., iTime) * 3.;\n    \n    fragColor = max(\n        vec4(0.), \n        vec4(\n            vec3((oc * 1. - length(uv / 12.)) + hash(rd.x / uv.y + mod(iTime, 1.)) * .01)  / initialDist * 20., alpha)\n    \t);\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    \n    vec4 pre = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    fragColor = mix(fragColor, pre, min(.9, length(pre / 2.)));\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}