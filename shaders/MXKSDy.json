{
    "Shader": {
        "info": {
            "date": "1720512663",
            "description": "A different approach to the chaos game algorithm (executing it in reverse without a PRNG / stochastic process, making it suitable for GPU computation).",
            "flags": 0,
            "hasliked": 0,
            "id": "MXKSDy",
            "likes": 6,
            "name": "Reverse Chaos Game (Demo)",
            "published": 3,
            "tags": [
                "chaosgame"
            ],
            "usePreview": 0,
            "username": "sanblu",
            "viewed": 105
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265359\n#define FLT_MAX 3.402823466e+38\n#define CENTER vec2(0.5, 0.5)\n#define MAX_N 6\n\n// Note: This is the shader demoing a number of visualization approaches to the \"reverse chaos game\" algorithm. \n// For a more basic demonstration of the algorithm see: https://www.shadertoy.com/view/43yXDK\n\n/*\n --- REVERSE CHAOS GAME ---\n \n -- Background --\n \n Initially I just wanted to implement the classic chaos game (https://en.wikipedia.org/wiki/Chaos_game),\n but doing so with a decent quality and efficiently on a GPU turned out infeasible.\n (It's a stochastic process that involves creating a height-map requiring atomic adds.)\n Before giving up I had one more thought: Shouldn't it be possible to just start with a specific pixel and then play the chaos game backwards?\n That basically just means: Take the current point and a vertex and just double the distance to get a new point.)\n I was expecting that I would then have to do some sort of \"probabilistic backtracking\" (similar to the chaos game), but things turned out much simpler:\n In order to stay within the main polygon as long as possible, you always have have to pick the vertex that is closest to the current point. Nice, no PRNG needed!\n \n The resulting images (sierpinski triangle etc.) looked identical to those of the chaos game.\n Also playing with the \"cut factor\" (0.5/2.0 by default) worked the same way and with identical results just as in the classic chaos game approach.\n The last missing piece were the chaos game \"restriction rules\": At first, when I added them they just seemed to work out of the box.\n But then I noticed that depending on the cut factor some of the rules would lead to an image that looks \"truncated\".\n I have not yet figured out how to resolve that, if you have a hint/idea, please let me know.\n \n -- Algorithm --\n \n See reverseChaosGame(..) function below with comments.\n \n -- Restriction Rules --\n \n As mentioned above, the algorithm seems to give aesthetic results only for a subset of restriction rules (I have hard-coded those in the arrays below).\n To see an example of a rule that does not work -> uncomment line 69.\n \n -- Visualization --\n \n There are endless ways to visualize the algorithm's results, polygon distance as used here is just one example.\n See a number of examples here: https://www.shadertoy.com/view/MXKSDy\n \n -- Help! :) --\n \n If you happen to have some knowledge related to the chaos game / fractals / IFS, I'm very thankful for any comments that give me some context:\n Is the approach I'm taking here a common approach? Is there a specific name (other than \"chaos game\") for that approach?\n I'm pretty sure it's not something new I'm doing here, but I'm also wondering why I have not seen this approach being described before, especially when searching for ways to execute the chaos game on a GPU in parallel.\n \n*/\n\n\n// hand-picked set of rules for each type of polygon\n// for some background see e.g. https://community.wolfram.com/groups/-/m/t/1025180\nconst int AESTHETIC_RULES_N3[2] = int[2](6, 7);\nconst int AESTHETIC_RULES_N4[5] = int[5](5, 10, 11, 14, 15);\nconst int AESTHETIC_RULES_N5[6] = int[6](12, 13, 18, 19, 30, 31);\nconst int AESTHETIC_RULES_N6[13] = int[13](9, 20, 21, 28, 29, 34, 35, 42, 43, 54, 55, 62, 63);\n\n\n// https://www.pcg-random.org/\n// http://www.jcgt.org/published/0009/03/02/\nuint pcg1d(in uint v)\n{\n    uint state = v * 747796405u + 2891336453u;\n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    return (word >> 22u) ^ word;\n}\n\n// https://iquilezles.org/articles/palettes\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdPolygon( in vec2[MAX_N] v, in vec2 p, in int n )\n{\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i = 0, j = n - 1; i < n; j = i, i++ )\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w = p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n        if( all(c) || all(not(c)) ) s*=-1.0;  \n    }\n    return s*sqrt(d);\n}\n\nvec2[MAX_N] polygonVertices(in int n) {\n    vec2[MAX_N] vertices;\n    float angleIncrement = 2.0 * PI / float(n);\n    for (int i = 0; i < n; i++) {\n        float angle = 0.5 * PI + angleIncrement * float(i) + iTime * 0.1;\n        vertices[i] = vec2(0.5 + 0.5 * cos(angle), 0.5 + 0.5 * sin(angle));\n    }\n    return vertices;\n}\n\nbool getBit(in int value, in int bitPosition) {\n    return (value & (1 << bitPosition)) != 0;\n}\n\nbool checkRule(in int prevVertex, in int newVertex, in int n, in int rule) {\n    if (prevVertex < 0 || rule < 0) {\n        return true;\n    }\n    int vertexModuloOffset = (prevVertex - newVertex + n) % n;\n    return getBit(rule, vertexModuloOffset);\n}\n\nfloat initValue(in int style) {\n    return (style == 3 || style == 4) ? -FLT_MAX : FLT_MAX;\n}\n\nfloat iterateValue(in int style, in vec2 p, in float prevValue, in float minDist, in float maxDist, in int n, in vec2 vertices[MAX_N]) {\n    switch(style) {\n        case 0:\n            return min(prevValue, sdPolygon(vertices, p, n));\n        case 1:\n        case 2:\n            return min(prevValue, minDist);\n        case 3:\n            return max(prevValue, minDist);\n        case 4:\n            return max(prevValue, maxDist);\n        case 5:\n            return min(prevValue, maxDist);\n        case 6:\n            vec2 z = p * 2.0 - 1.0;\n            return min(prevValue, abs(dot(z,z) - 0.1));\n        case 7:\n            return min(prevValue, abs(sdPolygon(vertices, p, n)));\n        case 8:\n            return min(prevValue, distance(p, CENTER));\n    }\n}\n\nfloat finalizeValue(in int style, in vec2 p, in float value) {\n    switch(style) {\n        case 0:\n            return 1.0 - pow(abs(value) * 2.0, 1.0);\n        case 1:\n            return 1.0 - length((p - CENTER) * value);\n        case 2:\n            return 1.0 - value * 2.0;\n        case 3:\n            return 1.0 - value * 0.5;\n        case 4:\n            return 1.0 - pow(value, 4.0);\n        case 5:\n            return 1.0 - pow(value, 3.0);\n        case 6:\n            return 1.0 - pow(value * 2.0, 0.25);\n        case 7:\n            return 1.0 - pow(value, 0.25);\n        case 8:\n            return 1.0 - value;\n    }\n}\n\n// main algorithm: I call it the \"reverse chaos game\", it's very similar to the \"chaos game\" but in reverse\n// - step 1) initially, we define a polygon with N vertices\n// - step 2) for each pixel we start with an initial point P (= the pixel coordinates)\n// - step 3) determine the vertex V of the polygon that is closest to P\n//           optional: exclude certain vertices based on a predefined rule (e.g. exclude the vertex that was chosen in the previous iteration)\n// - step 4) double the distance between P and V (in the direction of V) -> this leads to a new point P\n// - repeat 3) 4) for a predefined number of iterations\n// - step 5) assign brightness value to the pixel with which we started, based on the processed iterations and/or the resulting final point P\n//           (the possibilities are almost endless, examples: a) length of final P b) minimum distance across all iterations c) distance of final P to polygon ...)\nfloat reverseChaosGame(in vec2 uv, in int n, in float cutFactor, in int iterations, in int rule, in int style) {\n\n    int prevVertexIndex = -1;\n    vec2[MAX_N] vertices = polygonVertices(n);\n    float reverseCutFactor = 1.0 / (1.0 - cutFactor);\n    float value = initValue(style);\n    \n    vec2 p = uv;\n\n    for (int i = 0; i < iterations; i++) {\n\n        float minDist = FLT_MAX;\n        float maxDist = -FLT_MAX;\n        int closestVertexIndex = -1;\n        for (int j = 0; j < n; j++) {\n            if (!checkRule(prevVertexIndex, j, n, rule)) {\n                continue;\n            }\n\n            float dist = distance(p, vertices[j]);\n            if (dist < minDist) {\n                minDist = dist;\n                closestVertexIndex = j;                \n            }\n            if (dist > maxDist) {\n                maxDist = dist;\n            }\n        }\n        \n        vec2 closestVertex = vertices[closestVertexIndex];\n\n        // reverse rule of the chaos game (expansion instead of contraction)\n        p = closestVertex + reverseCutFactor * (p - closestVertex);\n        \n        value = iterateValue(style, p, value, minDist, maxDist, n, vertices);       \n        \n        prevVertexIndex = closestVertexIndex;\n    }\n    \n    return finalizeValue(style, p, value);\n}\n\n\nfloat randomReverseChaosGame(in vec2 uv, in uint seed) {\n\n    uint rnd1 = pcg1d(seed);\n    uint rnd2 = pcg1d(rnd1);\n    uint rnd3 = pcg1d(rnd2);\n    uint rnd4 = pcg1d(rnd3);\n    uint rnd5 = pcg1d(rnd4);\n    \n    int n = int(3u + rnd1 % 4u);\n    if (n == 3) {\n        // reduce chance to encounter triangles (because they have less variation than the other polygons) \n        n = int(3u + rnd5 % 4u);        \n    }\n    float cutFactor = (0.35 + 0.15 * (cos(iTime * 0.5) * 0.5 + 0.5));\n    int iterations = int(6u + rnd2 % 8u);\n    int style = int(rnd3 % 9u);\n    \n    int rule;\n    switch(n) {\n        case 3: rule = AESTHETIC_RULES_N3[int(rnd4 % 2u)]; break;\n        case 4: rule = AESTHETIC_RULES_N4[int(rnd4 % 5u)]; break;\n        case 5: rule = AESTHETIC_RULES_N5[int(rnd4 % 6u)]; break;\n        case 6: rule = AESTHETIC_RULES_N6[int(rnd4 % 13u)]; break;\n    }    \n\n    return reverseChaosGame(uv, n, cutFactor, iterations, rule, style);\n}\n\n// to demonstrate the wide range of outputs, we continuously create random \"reverse chaos game\" configurations and fade them into each other\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // center coordinates and correct aspect ratio\n    float aspectRatio = iResolution.x/iResolution.y;\n    uv.x = uv.x * aspectRatio - (aspectRatio - 1.0) * 0.5;\n    \n    float weight = cos(iTime * 2.0) * 0.5 + 0.5;\n    \n    uint rootSeed = 1337u;\n    uint seed1 = rootSeed + uint(iTime / PI);\n    uint seed2 = rootSeed * 7u + uint((iTime + PI * 0.5) / PI);\n    \n    float value1 = randomReverseChaosGame(uv, seed1);\n    float value2 = randomReverseChaosGame(uv, seed2);\n    \n    float valueMixed = clamp(mix(value1, value2, weight), 0.0, 1.0);\n    \n    vec3 col = pal(valueMixed, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.20) );\n    fragColor = vec4(col, 1.0);            \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}