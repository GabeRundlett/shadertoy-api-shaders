{
    "Shader": {
        "info": {
            "date": "1565336999",
            "description": "Trying to follow: [url]https://hal.inria.fr/inria-00596050/document[/url]",
            "flags": 32,
            "hasliked": 0,
            "id": "WtBXzw",
            "likes": 6,
            "name": "Navier-Stokes-Simple",
            "published": 3,
            "tags": [
                "2d",
                "fluid",
                "field",
                "vector",
                "cfd",
                "navier",
                "stokes"
            ],
            "usePreview": 0,
            "username": "felipunkerito",
            "viewed": 818
        },
        "renderpass": [
            {
                "code": "// By Felipe Gutierrez aka felipunkerito\n// Creative commons CC-BY-NC-ND\n\nfloat bumpFunc(vec2 p){ \n\n\treturn texture( iChannel0, p ).w; // Range: [0, 1]\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 tex = texture( iChannel0, uv );\n    \n    #ifdef BUMP\n    \n    vec3 sp = vec3(uv, 0); // Surface posion. Hit point, if you prefer. Essentially, a screen at the origin.\n    vec3 rd = normalize(vec3(uv, 1.)); // Unit direction vector. From the origin to the screen plane.\n    vec3 lp = vec3(0.9, 1.5, -5.0); // Light position - Back from the screen.\n\tvec3 sn = vec3(0., 0., -1); // Plane normal. Z pointing toward the viewer.\n    \n    vec2 eps = vec2(4./iResolution.y, 0.);\n    \n    float f = bumpFunc(sp.xy); // Sample value multiplied by the amplitude.\n    float fx = bumpFunc(sp.xy-eps.xy); // Same for the nearby sample in the X-direction.\n    float fy = bumpFunc(sp.xy-eps.yx); // Same for the nearby sample in the Y-direction.\n   \n \t// Controls how much the bump is accentuated.\n\tconst float bumpFactor = 0.1;\n    \n    // Using the above to determine the dx and dy function gradients.\n    fx = (fx-f)/eps.x; // Change in X\n    fy = (fy-f)/eps.x; // Change in Y.\n    sn = normalize( sn + vec3(fx, fy, 0)*bumpFactor );           \n   \n    \n    // LIGHTING\n    //\n\t// Determine the light direction vector, calculate its distance, then normalize it.\n\tvec3 ld = lp - sp;\n\tfloat lDist = max(length(ld), 0.001);\n\tld /= lDist;\n\n    // Light attenuation.    \n    float atten = 1./(1.0 + lDist*lDist*0.15);\n\t//float atten = min(1./(lDist*lDist*1.), 1.);\n    \n    // Using the bump function, \"f,\" to darken the crevices. Completely optional, but I\n    // find it gives extra depth.\n    atten *= f*.9 + .1; // Or... f*f*.7 + .3; //  pow(f, .75); // etc.\n\n\t\n\n\t// Diffuse value.\n\tfloat diff = max(dot(sn, ld), 0.);  \n    // Enhancing the diffuse value a bit. Made up.\n    diff = pow(diff, 4.)*0.66 + pow(diff, 8.)*0.34; \n    // Specular highlighting.\n    float spec = pow(max(dot( reflect(-ld, sn), -rd), 0.), 12.); \n \n    vec3 col = (tex.rgb * (diff*vec3(1, .97, .92)*2. + 0.5) + vec3(1., .6, .2)*spec*2.)*atten;\n    tex.rgb = col;\n    \n    #endif\n    \n    #ifdef RANDOMCOLOURS\n    \n    \ttex = vec4( mix( tex.rgb * ColourForce, tex.rgb, tex.z ), 1 );\n    \n    #else\n    \n    \t/*tex = vec4( mix( vec3( 0.2, 0, 0.0125 ), \n                         mix( vec3( 0.01, 0.0, 0.1 ), \n                              mix( vec3( 0.025, 0.01, 0.0125 ), \n                                   vec3( 0.05, 0, 0.075 ), \n                                   tex.z ), \n                              -tex.z ),\n                          tex.z ), \n                   1 );*/\n    \n    \ttex = vec4( mix( vec3( 0, 0, 0.1 ), vec3( 10, 1, 0.3 ), tex.z ), 1 );\n    \n    \t//tex = vec4( mix( tex.rgb * ColourForce, tex.rgb, -tex.z ), 1 );\n    \n    #endif\n    \n    if( uv.y < 0.01 || uv.x < 0.01 || uv.x > 0.99 || uv.y > 0.99 ) tex *= 0.0;\n    \n    fragColor = pow( tex, vec4( 0.4545 ) );\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec4 forc( vec2 uv, vec2 p, vec2 mou )\n{\n    \n    vec4 col = vec4( 0 ), colO = vec4( 0 );\n    \n    float tim = iTime * Time;\n    \n    #ifdef RANDOMCOLOURS\n    \n        colO = vec4( noise( uv + tim ), noise( uv + tim + 1.0 ), \n                     noise( uv + tim + 2.0 ), 1 );\n\n    #else\n\n        colO += 1.0;\n    \n    #endif\n    \n    #ifdef GRID\n    \n        if( iFrame < 30 )\n        {\n\n            if( mod( max( uv.x, 0.01 ), 0.02 ) > 0.005  ) \n            {\n\n                col += 0.1;\n\n\n            }\n\n            else \n            {\n\n                col -= 0.1;\n\n            }\n\n        }\n    \n    ColourForce = -ColourForce;\n    \n    #endif\n    \n    #ifdef AUTO\n    \n    if( iMouse.z < 0.5 && cir( p, auto( iTime ), siz ) > 0.05 )\n            \n        col += ColourForce * colO;\n\n   \n    #endif\n    \n    if( iMouse.z > 0.5 && cir( p, mou, siz ) > 0.05 )\n            \n        col += ColourForce * colO;\n    \n    \n    return col;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec2 p = fragCoord / iResolution.y;\n    vec2 mou = iMouse.xy / iResolution.y;\n    \n    vec4 sim = textureLod( iChannel1, uv, 0.0 );\n    \n    uv -= dt * iTimeDelta * sim.xy;\n    \n    vec4 self = textureLod( iChannel0, uv, 0.0 ) + forc( uv, p, mou ) * sim.z;\n    \n    fragColor = self;\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// https://www.youtube.com/watch?v=TxxZ8gkGNAc\nfloat cur( vec2 uv, vec2 Step )\n{\n    \n    float FR = textureLod( iChannel0, uv + vec2( Step.x, 0 ), 0.0 ).x;\n    float FL = textureLod( iChannel0, uv - vec2( Step.x, 0 ), 0.0 ).x;\n    float FT = textureLod( iChannel0, uv + vec2( 0, Step.y ), 0.0 ).y;\n    float FD = textureLod( iChannel0, uv - vec2( 0, Step.y ), 0.0 ).y;\n    \n    float UdX = ( FR - FL ) * 0.5;\n    float UdY = ( FT - FD ) * 0.5;\n    \n    return UdX + UdY; \n}\n\nvec2 vor( vec2 uv, vec2 Step )\n{\n\n    vec2 dir = vec2( 0 );\n    dir.x = ( cur( uv - vec2( 0, Step.y ), Step ) ) - ( cur( uv + vec2( 0, Step.y ), Step ) );\n    dir.y = ( cur( uv + vec2( Step.x, 0 ), Step ) ) - ( cur( uv - vec2( Step.x, 0 ), Step ) );\n    \n    dir = normalize( dir );\n    \n    return dir;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec2 p = fragCoord / iResolution.y;\n    vec2 mou = iMouse.xy / iResolution.y;\n    \n    vec2 cScale = vec2( 0.5 );\n    \n    vec2 Step = 1.0 / iResolution.xy;\n    \n    float S = K / dt;\n    \n    vec4 FC = textureLod( iChannel0, uv, 0.0 );\n    vec3 FR = textureLod( iChannel0, uv + vec2( Step.x, 0 ), 0.0 ).xyz;\n    vec3 FL = textureLod( iChannel0, uv - vec2( Step.x, 0 ), 0.0 ).xyz;\n    vec3 FT = textureLod( iChannel0, uv + vec2( 0, Step.y ), 0.0 ).xyz;\n    vec3 FD = textureLod( iChannel0, uv - vec2( 0, Step.y ), 0.0 ).xyz;\n    \n    vec3 UdX = ( FR - FL ) * 0.5;\n    vec3 UdY = ( FT - FD ) * 0.5;\n    \n    float Udiv = UdX.x + UdY.y; \n        \n    vec2 DdX = vec2( UdX.z, UdY.z );\n    \n    // Solve for density.\n    FC.z -= dt * dot( vec3( DdX, Udiv ), FC.xyz );\n    \n    // Stability.\n    FC.z = clamp( FC.z, 0.5, .99 );\n    \n    // Solve for velocity.\n    vec2 PdX = S * DdX;\n    vec2 Laplacian = FR.xy + FL.xy + FT.xy + FD.xy - 4.0 * FC.xy;\n    vec2 ViscocityForce = Viscocity * Laplacian;\n    \n    // Semi-Lagrangian advection.\n    vec2 Was = uv - dt * FC.xy * vor( uv, Step ) * FC.w * Step;\n    FC.xy = textureLod( iChannel0, Was, 0.0 ).xy;\n    \n    // Forces.\n    vec2 ExternalForce = vec2( 0 );\n    ExternalForce += textureLod( iChannel1, uv, 0.0 ).xy * ForceVector;\n    vec2 dir = vor( Was, Step );\n    \n    // Vorticity confinement.\n    FC.w = cur( uv, Step );\n    if( length( dir ) > 0.0 )\n        \n        FC.xy += dt * Vorticity * dir * FC.w;\n    \n    FC.xy += dt * ( ViscocityForce - PdX + ExternalForce );\n    \n    if( uv.y < 0.01 || uv.x < 0.01 || uv.x > 0.99 || uv.y > 0.99 ) FC.xy *= 0.0;\n    \n    fragColor = FC;\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define AUTO \n#define GRID\n#define RANDOMCOLOURS\n#define BUMP\n\n// Bump mapping by Shane, thanks!\n\nconst float siz = 0.025;\nconst float dx = 0.5;\nconst float dt = dx * dx * 0.5;\nfloat ColourForce = 1.0;\nconst float ForceVector = 25.0;\nconst float Viscocity = 0.3;\nconst float Vorticity = 4.0;\nconst float K = 0.2;\nconst float Time = 0.7;\nconst float BumpPower = 0.10150138;\nconst float BumpFactor = 0.0066746245;\n\nfloat hash( vec2 a )\n{\n\n    return fract( sin( a.x * 3433.8 + a.y * 3843.98 ) * 45933.8 );\n\n}\n\nfloat noise( vec2 uv )\n{\n    \n    vec2 lv = fract( uv );\n    lv = lv * lv * ( 3.0 - 2.0 * lv );\n    vec2 id = floor( uv );\n    \n    float bl = hash( id );\n    float br = hash( id + vec2( 1, 0 ) );\n    float b = mix( bl, br, lv.x );\n    \n    float tl = hash( id + vec2( 0, 1 ) );\n    float tr = hash( id + vec2( 1 ) );\n    float t = mix( tl, tr, lv.x );\n    \n    float c = mix( b, t, lv.y );\n    \n    return c;\n\n}\n\nvec2 auto( float time )\n{\n\n    return vec2( 0.9 + sin( time * Time ) * 0.45, 0.5 - cos( time * Time ) * 0.45 ) + 0.1 * vec2( noise( vec2( 10.0 * time * Time ) ), noise( vec2( 8.0 * time * Time ) ) );\n\n} \n\n\nfloat dis( vec2 uv, vec2 mou )\n{\n\n    return length( uv - mou );\n\n}\n\nfloat cir( vec2 uv, vec2 mou, float r )\n{\n\n    float o = smoothstep( r, r - 0.05, dis( uv, mou ) );\n    \n    return o;\n\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 p = fragCoord / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 mou = iMouse.xy / iResolution.y;\n    vec2 last = textureLod( iChannel0, uv, 0.0 ).zw;\n    \n    vec2 acc = vec2( 0 );\n    \n    #ifdef AUTO\n    if( iMouse.z < 0.5 ) \n    \n        mou = auto( iTime );\n    \n    #endif\n    \n    vec2 vel = mou - last;\n    \n    if( length( vel ) < 0.1 && cir( p, mou, siz ) > 0.05 )\n    \n    \tacc += vel;\n    \n    fragColor = vec4( acc, mou );\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}