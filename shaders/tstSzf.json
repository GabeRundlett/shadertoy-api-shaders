{
    "Shader": {
        "info": {
            "date": "1572544714",
            "description": "TIL KIFS",
            "flags": 0,
            "hasliked": 0,
            "id": "tstSzf",
            "likes": 8,
            "name": "Shadertober 28 Veggies -jaburns",
            "published": 3,
            "tags": [
                "fractal",
                "raymarch"
            ],
            "usePreview": 0,
            "username": "jaburns",
            "viewed": 402
        },
        "renderpass": [
            {
                "code": "#define EPS          0.01\n#define PRECISION    0.6\n#define ITERATIONS 120\n#define PI           3.14159265358979\n\n#define COLORA (vec3(151, 203, 169) / 255.)\n#define COLORB (vec3(254, 255, 223) / 255.)\n#define COLORC (.3*vec3(102, 139, 164) / 255.)\n#define COLORD (.1*vec3(102, 139, 164) / 255.)\n\nmat2 rot( float theta )\n{\n    float c = cos( theta );\n    float s = sin( theta );\n    return mat2( c, s, -s, c );\n}\n\nfloat KIFS( vec3 p, float t )\n{\n    float scale = 1.;\n    for( int i = 0; i < 12;  ++i )\n    {\n        vec3 n = normalize(vec3(cos(t), sin(1.1*t), 0));\n        p -= n*2.*min(0.,dot(n, p));\n        p.x -= .2;\n        vec3 n1 = normalize(vec3(1, cos(1.7*t), sin(1.3*t)));\n        p -= n1*2.*max(0.,dot(n1, p));\n        p = abs(p);    \n        p *= 2.;\n        scale *= 2.;\n        p -= vec3( 2., 2., 2. );\n    }    \n    return (length(p-vec3(1.,.5,1.1))-.5) / scale;\n}\n\nvec3 getOffset( vec3 coord )\n{\n    float lookup = 91.*coord.x + 11.*coord.y + 31.*coord.z;\n    return 1.*vec3(\n        sin(149.*lookup+97.),\n        sin(177.*lookup+13.),\n        sin(457.*lookup+11.)\n    );\n}\n\nvec4 map( vec3 p )\n{\n    const float c = 5.;\n    vec3 coord = floor((p + c)/(2.*c));\n    p += getOffset(coord);\n    \n    p.xy *= rot( (coord.y + coord.z) * PI / 2. );\n    p.yz *= rot( (coord.z + coord.x) * PI / 2. );\n    p.zx *= rot( (coord.x + coord.y) * PI / 2. );\n    \n    vec3 q = mod( p + c, 2.*c ) - c;\n    vec3 flipper = (2.*mod(coord,2.)) - 1.;\n    q.x *= -flipper.x;\n    \n    float t = .2*(iTime + dot(coord, vec3(1)));\n    return vec4( flipper, KIFS( q, t ));\n}\n\nstruct March\n{\n    vec3 pos;\n    float dist;\n    vec3 coord;\n    float ao;\n};\n\nMarch march( vec3 ro, vec3 rd )\n{\n    vec4 dist;\n\tfloat totalDist = 0.0;\n    \n    int i;\n    for( i = 0; i < ITERATIONS; ++i )\n    {\n        dist = map( ro );\n        if( dist.w < EPS || totalDist > 200. ) break;\n        totalDist += PRECISION * dist.w;\n        ro += PRECISION * rd * dist.w;\n    }\n    \n    return March( ro, dist.w < EPS ? totalDist : -1.0, dist.xyz, float(i) / 90. );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(3.*iTime,5.,5.*iTime);\n    vec3 rd = normalize(vec3(uv, 1));\n    \n    rd.xy *= rot( .11*iTime );\n    rd.yz *= rot( .07*iTime );\n    rd.zx *= rot( .05*iTime );\n    \n    March m = march( ro, rd );\n    \n    float lightness = 0.;\n    vec3 color = COLORC;\n    \n    if( m.dist >= 0.0 ) {\n        float fog = exp( -.02*m.dist );\n        lightness = fog * (1. - m.ao);\n        \n        vec3 coord01 = m.coord * .5 + .5;\n        color = mix(COLORA, COLORB, mod(dot(coord01,vec3(1)), 2.));\n        \n        vec3 shadow = mix(COLORD, COLORC, 1. - fog);\n        color = mix( shadow, color, lightness );        \n    }\n\n    fragColor = vec4(color,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}