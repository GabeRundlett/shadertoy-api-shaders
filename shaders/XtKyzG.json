{
    "Shader": {
        "info": {
            "date": "1536787770",
            "description": "Coded live on twitch stream in Bonzomatic, and tidied/ported to shadertoy.\nUnedited Bonzomatic shader here: [url]https://gist.github.com/willkirkby/8f020ed8403817eae07014c14f7bfb61[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "XtKyzG",
            "likes": 36,
            "name": "[twitch] GameCube",
            "published": 3,
            "tags": [
                "loop",
                "gamecube"
            ],
            "usePreview": 0,
            "username": "yx",
            "viewed": 1755
        },
        "renderpass": [
            {
                "code": "#define ORTHO 1\n#define SPIN 0\n\n#define NUM 3.\n\n#define iTime (iTime * 6.0)\n#define iLoopedTime (mod(iTime, NUM * 2.))\n#define iLoopedTime2 (mod(iTime / (NUM * 2.), 3.))\n\n#define pi (acos(-1.))\n#define tau (pi * 2.)\n#define halfPi (pi * .5)\n\nvec2 rotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox2( vec2 p, vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdSpinningBox(vec3 p)\n{\n    if (iLoopedTime < NUM)\n    {\n        p.x -= NUM;\n        p.z -= floor(iLoopedTime);\n        p.zy = rotate(p.zy, fract(iTime)*halfPi);\n    }\n    else\n    {\n        p.x += floor(iLoopedTime-NUM-NUM+1.);\n        p.z -= NUM;\n        p.xy = rotate(p.xy, (1.-fract(iTime))*halfPi);\n    }\n    return sdBox(p+vec3(.5,-.5,.5), vec3(.4)) - .1;\n}\n\nfloat sdFloor(vec3 p)\n{\n    return sdBox(p+vec3(-NUM,NUM,-NUM)*.5, vec3(NUM * .5));\n}\n\nfloat scene(vec3 p)\n{\n    return min(\n        sdFloor(p),\n        sdSpinningBox(p)\n    );\n}\n\nfloat cellMask(vec2 p)\n{\n    return smoothstep(.0, -.1, sdBox2(p-.5,vec2(.37)) - .1 );\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 cam = vec3(0,0,-5);\n    vec3 dir = normalize(vec3(uv,1));\n\n    #if ORTHO\n    cam = vec3(uv*7.,-5);\n    dir = vec3(0,0,1);\n    #endif\n\n    dir.xy = rotate(dir.xy, -floor(iLoopedTime2) * tau / 3.);\n    cam.xy = rotate(cam.xy, -floor(iLoopedTime2) * tau / 3.);\n\n    #if SPIN\n    dir.xy = rotate(dir.xy, (iLoopedTime2 - .5) * tau / 3.);\n    cam.xy = rotate(cam.xy, (iLoopedTime2 - .5) * tau / 3.);\n    #endif\n\n    cam.yz = rotate(cam.yz, atan(1.,sqrt(2.)));\n    dir.yz = rotate(dir.yz, atan(1.,sqrt(2.)));\n\n    cam.xz = rotate(cam.xz, -pi/4.);\n    dir.xz = rotate(dir.xz, -pi/4.);\n\n    float t = 0.;\n    for(int i=0;i<100;++i)\n    {\n        t += scene(cam+dir*t);\n    }\n    vec3 h = cam+dir*t;\n\n    vec2 o = vec2(.01,0);\n    vec3 n = normalize(vec3(\n        scene(h+o.xyy)-scene(h-o.xyy),\n        scene(h+o.yxy)-scene(h-o.yxy),\n        scene(h+o.yyx)-scene(h-o.yyx)\n    ));\n\n    bool isCube = h.y > .001;\n    if (isCube)\n    {\n        n.xz = -n.xz;\n        if (iLoopedTime2 >= 2.)\n        {\n            n = n.zxy;\n        }\n        else if (iLoopedTime2 >= 1.)\n        {\n            n = n.yzx;\n        }\n\n        n.xz = -n.xz;\n\n        vec3 light = normalize(vec3(-4,5,-2));\n        out_color = vec4(pow(dot(n,light), 4.)) + vec4(.15,.1,.4,1);\n    }\n    else\n    {\n        float side = 0.;\n        if (n.x < -.5)\n        {\n            h = h.zxy;\n            h.z = -h.z;\n            side = 1.;\n        }\n        if (n.z < -.5)\n        {\n            h = h.yzx;\n            h.x = -h.x;\n            side = 2.;\n        }\n        vec2 cell = vec2(floor(h.xz));\n        if (max(cell.x,cell.y)==NUM-1. && cell.x >= 0. && cell.y >= 0.)\n        {\n            float mask = cellMask(fract(h.xz));\n\n            float intensity = NUM + cell.y - cell.x;\n\n            intensity /= (NUM*2.);\n\n            intensity = (side+intensity) / 3.;\n\n            intensity = fract(intensity - fract(iLoopedTime2) / 3.);\n\n            intensity = intensity * intensity * 3.5;\n\n            out_color = vec4(mask * intensity) * vec4(.15,.1,.4,1);\n        }\n        else\n        {\n            out_color = vec4(0);\n        }\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}