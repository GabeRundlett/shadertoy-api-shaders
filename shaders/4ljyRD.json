{
    "Shader": {
        "info": {
            "date": "1507675062",
            "description": "Line Integral Convolution (LIC) - Flow Flield Viz\n\nLowPass Convolution along the Streamlines of a Flow Field.\nThe Streamlines are created by following the flow field \nusing verlet integration.",
            "flags": 32,
            "hasliked": 0,
            "id": "4ljyRD",
            "likes": 16,
            "name": "Flow Field LIC",
            "published": 3,
            "tags": [
                "gaussblur",
                "lineintegralconvolution",
                "lic",
                "flowfield"
            ],
            "usePreview": 0,
            "username": "Thomas_Diewald",
            "viewed": 1356
        },
        "renderpass": [
            {
                "code": "//\n// author: Thomas Diewald, (c) 2017\n//\n// Line Integral Convolution (LIC) - Flow Flield Viz\n//\n// LowPass Convolution along the Streamlines of a Flow Field.\n// The Streamlines are created by following the flow field \n// using verlet integration.\n//\n//\n// MIT-License\n//\n\n\n#define NUM_SAMPLES 30\n\n#define TRACE_FORWARD 1\n#define TRACE_BACKWARD 1\n#define APPLY_EXP_SHADING 1\n\n\n\nfloat acc_mult = 1.0; // timestep\nfloat vel_mult = 1.0; // damping\n\nvec2  acc_minmax = vec2(0.0, 1.0);\nvec2  vel_minmax = vec2(0.0, 1.0);\n\nfloat intensity_mult = 2.0; \nfloat intensity_exp = 2.0;\n\n\n\nvec2 FRAG_COORD    = vec2(0.0); // frag location [0 - iResolution]\nvec2 FRAG_COORD_N  = vec2(0.0); // frag location [0 - 1]\n\n\n// 0 1\n// 2 3\nvec4 col0 = vec4(1.0, 1.0, 1.0, 1.0);\nvec4 col1 = vec4(1.0, 0.5, 0.0, 1.0);\nvec4 col2 = vec4(0.0, 0.5, 1.0, 1.0);\nvec4 col3 = vec4(1.0, 1.0, 1.0, 1.0);\n\n// bilinear color interpolation\nvec4 getCol(vec2 mm){\n  return mix(mix(col0, col1, mm.x), mix(col2, col3, mm.x), mm.y);\n}\n\n// color * texture\nvec4 getBaseColor(vec2 posn){\n  return getCol(1.0 - posn) * texture(iChannel1, posn).x;  \n}\n\n\n// clamp the length of a vector\nvoid limitLength(inout vec2 vel, in vec2 lohi){\n  float vel_len = length(vel);\n  if(vel_len <= lohi.x){\n    vel *= 0.0;\n  } else {\n    vel *= clamp(vel_len - lohi.x, 0.0, lohi.y) / vel_len;\n  }\n}\n\n\n// LIC - Line Integral Convolution\n// just a fancy name for averaging colors at the vertexpositions of a streamline\nvoid traceStream(inout vec4 samples_sum, inout float weights_sum, in float acc_mult_dir){\n\n  // start position\n  vec4 pos = FRAG_COORD_N.xyxy;\n  float weight = 1.0;\n  for(int i = 0; i < NUM_SAMPLES; i++){\n    // acceleration, velocity\n    vec2 acc = texture(iChannel0, pos.xy).xy;\n    vec2 vel = (pos.xy - pos.zw) * iChannelResolution[0].xy;\n    // clamp \n    limitLength(acc, acc_minmax);\n    limitLength(vel, vel_minmax); \n    // update position, verlet integration\n    pos.zw = pos.xy;\n    pos.xy += (vel * vel_mult + acc * acc_mult_dir) / iChannelResolution[0].xy;\n    // integrate\n#if (APPLY_EXP_SHADING == 1)\n    weight = pow(length(acc), intensity_exp);\n#endif\n    samples_sum += getBaseColor(pos.xy) * weight;\n    weights_sum += 1.0;\n  }\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  // making this shader-global\n  FRAG_COORD   = fragCoord;\n  FRAG_COORD_N = fragCoord / iResolution.xy;\n    \n  // colored encoding of the flow field\n  // for debugging only \n  vec2 vel = texelFetch(iChannel0, ivec2(fragCoord), 0).xy;\n  float r = 0.5 * (1.0 + vel.x);\n  float g = 0.5 * (1.0 + vel.y);\n  float b = 0.5 * (2.0 - (r + g));\n  vec4 col_flow = vec4(r, g, b, 1.0);\n\n    \n  // LIC - Streamline Integration\n  vec4  samples_sum = vec4(0.0);\n  float weights_sum = 0.0;\n\n#if (TRACE_BACKWARD == 1)\n  traceStream(samples_sum, weights_sum, -acc_mult);\n#endif\n\n#if (TRACE_FORWARD == 1)\n  traceStream(samples_sum, weights_sum, +acc_mult);\n#endif\n\n  vec4 col_lic = intensity_mult * samples_sum / weights_sum;\n    \n    \n  //fragColor = col_flow;\n  //fragColor = getBaseColor(FRAG_COORD_N);\n  fragColor = col_lic;\n    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//\n// author: Thomas Diewald, (c) 2017\n//\n// Line Integral Convolution (LIC) - Flow Flield Viz\n//\n// LowPass Convolution along the Streamlines of a Flow Field.\n// The Streamlines are created by following the flow field \n// using verlet integration.\n//\n//\n// MIT-License\n//\n\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\n#define MAX_DIST 1.0\n#define TSMOOTH 1.0\n\n\n// rotate a vector by angle 'a'\nvec2 rotVec(in vec2 v, in float a){\n  float ca = cos(a);\n  float sa = sin(a);\n  return vec2(ca*v.x - sa*v.y, sa*v.x + ca*v.y);\n}\n\n\n//\n// Flow Field - Sobel Filter\n//\n// Horiz-Gradient    Vert-Gradient          \n// +1  0 -1          +1 +2 +1  \n// +2  0 -2           0  0  0\n// +1  0 -1          -1 -2 -1\n//\nvec2 computeFlow(in vec2 fragCoord){\n  vec2 fragn = fragCoord.xy / iResolution.xy;\n  \n  ivec2 pC = ivec2(fragn *  iChannelResolution[1].xy * 0.30);\n  \n  vec4 cC  = texelFetch      (iChannel1, pC, 0);\n  vec4 cT  = texelFetchOffset(iChannel1, pC, 0, ivec2( 0,+1));\n  vec4 cB  = texelFetchOffset(iChannel1, pC, 0, ivec2( 0,-1));\n  vec4 cL  = texelFetchOffset(iChannel1, pC, 0, ivec2(-1, 0));\n  vec4 cR  = texelFetchOffset(iChannel1, pC, 0, ivec2(+1, 0));\n  vec4 cTL = texelFetchOffset(iChannel1, pC, 0, ivec2(-1,+1));\n  vec4 cTR = texelFetchOffset(iChannel1, pC, 0, ivec2(+1,+1));\n  vec4 cBL = texelFetchOffset(iChannel1, pC, 0, ivec2(-1,-1));\n  vec4 cBR = texelFetchOffset(iChannel1, pC, 0, ivec2(+1,-1));\n    \n  vec4 dh = vec4(0);\n  vec4 dv = vec4(0);\n  \n  dh += cTL * +1.0;   dh += cTR * -1.0;\n  dh +=  cL * +2.0;   dh +=  cR * -2.0;\n  dh += cBL * +1.0;   dh += cBR * -1.0;\n\n  dv += cTL * +1.0;   dv += cBL * -1.0;\n  dv += cT  * +2.0;   dv += cB  * -2.0;\n  dv += cTR * +1.0;   dv += cBR * -1.0;\n  \n  vec2 flow = vec2(dh.x, dv.x);\n  \n  //float len = length(flow);\n  //if(len > 0.0) flow /= len;\n    \n  return flow;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float speed = 0.01;\n    //float anim1 = sin(float(iFrame) * speed * 1.0) * 0.5 + 0.5;\n    float anim2 = (float(iFrame) * speed * 2.0);\n    \n    // add new velocity to the one from the previous pass\n    vec2 flow = texelFetch(iChannel0, ivec2(fragCoord.xy), 0).xy * TSMOOTH;\n    \n    if(iFrame == 0){\n      flow = computeFlow(fragCoord) * 30.0;\n    } else {\n      flow += computeFlow(fragCoord) * 0.05; // just add a bit\n    }\n    \n\n\tvec2 fragn = fragCoord.xy / iResolution.xx;\n    vec4 mousn = iMouse / iResolution.xxxx;\n\n    vec2 flow_new = (fragn-mousn.xy);\n    \n\tflow_new = mix(flow_new * 20.0, vec2(0.0), smoothstep(0.00,0.150, length(flow_new)));\n    \n    flow += 0.5 * rotVec(flow_new, anim2 * PI);\n    \n    float flow_len = length(flow);\n    if(flow_len > MAX_DIST){\n      flow *= MAX_DIST / flow_len;\n    }\n    \n\tfragColor = vec4(flow, 0.0, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// gaussian blur\n//\n// 1 2 1\n// 2 4 2\n// 1 2 1\n\n\n// convolution based on comment from FabriceNeyret2\nmat3 K = mat3( 1,2,1, \n               2,4,2, \n               1,2,1 ) / 16.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    ivec2 P = ivec2(fragCoord);\n    \n    for (int k=0; k<9; k++) \n    {\n        ivec2 D = ivec2(k%3,k/3);\n        fragColor += K[D.y][D.x] * texelFetch(iChannel0, P+(D-1), 0);\n    }    \n}\n\n\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    ivec2 pC = ivec2(fragCoord.xy);\n    \n    vec4 cC  = texelFetch(iChannel0, pC, 0);\n    vec4 cT  = texelFetchOffset(iChannel0, pC, 0, ivec2( 0,+1));\n    vec4 cB  = texelFetchOffset(iChannel0, pC, 0, ivec2( 0,-1));\n    vec4 cL  = texelFetchOffset(iChannel0, pC, 0, ivec2(-1, 0));\n    vec4 cR  = texelFetchOffset(iChannel0, pC, 0, ivec2(+1, 0));\n    vec4 cTL = texelFetchOffset(iChannel0, pC, 0, ivec2(-1,+1));\n    vec4 cTR = texelFetchOffset(iChannel0, pC, 0, ivec2(+1,+1));\n    vec4 cBL = texelFetchOffset(iChannel0, pC, 0, ivec2(-1,-1));\n    vec4 cBR = texelFetchOffset(iChannel0, pC, 0, ivec2(+1,-1));\n    \n\n    fragColor = ( cTL * 1.0 + cT * 2.0 + cTR * 1.0 + \n                  cL  * 2.0 + cC * 4.0 + cR  * 2.0+ \n                  cBL * 1.0 + cB * 2.0 + cBR * 1.0) / 16.0;\n        \n\n   \n}\n*/",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}