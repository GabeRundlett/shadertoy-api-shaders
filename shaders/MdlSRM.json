{
    "Shader": {
        "info": {
            "date": "1398595351",
            "description": "A menger spone..",
            "flags": 0,
            "hasliked": 0,
            "id": "MdlSRM",
            "likes": 60,
            "name": "KIFS",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "fractal",
                "kifs"
            ],
            "usePreview": 0,
            "username": "EvilRyu",
            "viewed": 7033
        },
        "renderpass": [
            {
                "code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Try KIFS...\n\n void ry(inout vec3 p, float a){  \n \tfloat c,s;vec3 q=p;  \n  \tc = cos(a); s = sin(a);  \n  \tp.x = c * q.x + s * q.z;  \n  \tp.z = -s * q.x + c * q.z; \n }  \n void rx(inout vec3 p, float a){  \n \tfloat c,s;vec3 q=p;  \n  \tc = cos(a); s = sin(a);  \n  \tp.y = c * q.y - s * q.z;  \n  \tp.z = s * q.y + c * q.z; \n }  \n\n void rz(inout vec3 p, float a){  \n \tfloat c,s;vec3 q=p;  \n  \tc = cos(a); s = sin(a);  \n  \tp.x = c * q.x - s * q.y;  \n  \tp.y = s * q.x + c * q.y; \n }  \nfloat plane(vec3 p, float y) {\n    return length(vec3(p.x, y, p.z) - p);\n}\n\n// folding hex from nimitz: https://www.shadertoy.com/view/XtdGDB\nvec2 fold(vec2 p)\n{\n    p.xy = abs(p.xy);\n    const vec2 pl1 = vec2(-0.5, 0.8657);\n    const vec2 pl2 = vec2(-0.8657, 0.4);\n    p -= pl1*2.*min(0., dot(p, pl1));\n    p -= pl2*2.*min(0., dot(p, pl2));\n    return p;\n}\n\nvec3 mat=vec3(0.0);\nbool bcolor = false;\n\nfloat menger_spone(in vec3 z0){\n\tvec4 z=vec4(z0,1.0);\n    vec3 offset = vec3(0.785,1.1,0.46);\n    float scale = 2.46;\n\tfor (int n = 0; n < 4; n++) {\n\t\tz = abs(z);\n\t\tif (z.x<z.y)z.xy = z.yx;\n\t\tif (z.x<z.z)z.xz = z.zx;\n\t\tif (z.y<z.z)z.yz = z.zy;\n\t\tz = z*scale;\n\t\tz.xyz -= offset*(scale-1.0);\n       \tif(bcolor && n==2)\n            mat+=vec3(0.5)+sin(z.xyz)*vec3(1.0, 0.24, 0.245);\n\t\tif(z.z<-0.5*offset.z*(scale-1.0))\n            z.z+=offset.z*(scale-1.0);\n\t}\n\treturn (length(max(abs(z.xyz)-vec3(1.0),0.0))-0.05)/z.w;\n}\n\n vec3 f(vec3 p){ \n     ry(p,iTime*0.4);\n     float d1 = plane(p, -0.8);\n     p.xz = fold(p.xz);\n\n     float d2 = menger_spone(p);\n     if(d1 < d2)\n     {\n         return vec3(d1, 0.0, 0.0);\n     }\n     else\n     {\n         return vec3(d2, 1.0, 0.0);\n     } \n } \n\n float ao(vec3 p, vec3 n){ \n \tfloat ao=0.0,sca=1.0; \n \tfor(float i=0.0;i<20.0;++i){ \n \t\tfloat hr=0.05+0.015*i*i; \n \t\tao+=(hr-f(n*hr+p).x)*sca; \n \t\tsca*=0.75; \n \t} \n \treturn 1.0-clamp(ao,0.0,1.0); \n } \n\n\nfloat rand(vec2 t){\n\treturn fract(sin(dot(t*0.123,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat softshadow(vec3 ro, vec3 rd, float k ){ \n     float s=1.0,h=0.0; \n     float t = 0.01;\n     for(int i=0; i < 50; ++i){ \n         h=f(ro+rd*t).x; \n         if(h<0.001){s=0.0;break;} \n         s=min(s, k*h/t); \n         t+=abs(h);\n     } \n     return clamp(s*0.9+0.1, 0.0, 1.0); \n} \n vec3 nor(vec3 p){ \n \tvec3 e=vec3(0.0001,0.0,0.0); \n \treturn normalize(vec3(f(p+e.xyy).x-f(p-e.xyy).x, \n \t\t\t\t\t\t  f(p+e.yxy).x-f(p-e.yxy).x, \n \t\t\t\t\t\t  f(p+e.yyx).x-f(p-e.yyx).x)); \n } \n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    float t = 0.0;\n    vec3 res = vec3(-1.0);\n\tvec3 h = vec3(1.0);\n    for( int i=0; i<64; i++ )\n    {\n\t\tif( h.x<0.003 || t>30.0 ){\n\t\t}else {\n        \th = f(ro + rd*t);\n        \tres = vec3(t,h.yz);\n        \tt += abs(h.x);\n\t\t}\n    }\n\tif( t>30.0 ) res=vec3(-1.0);\n    return res;\n}\n\n void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n { \n    vec2 q=fragCoord.xy/iResolution.xy; \n \tvec2 uv = -1.0 + 2.0*q; \n \tuv.x*=iResolution.x/iResolution.y; \n\n    vec3 ta = vec3(0,0.08,0.);\n    vec3 ro = vec3(1., 1.4, -3.);\n \tvec3 cf = normalize(ta-ro); \n    vec3 cs = normalize(cross(cf,vec3(0.0,1.0,0.0))); \n    vec3 cu = normalize(cross(cs,cf)); \n \tvec3 rd = normalize(uv.x*cs + uv.y*cu + 2.8*cf);  // transform from view to world\n\n    vec3 sundir = normalize(vec3(3., 5.,-2.8)); \n    vec3 sun = vec3(1.64, 1.27, 0.99); \n    vec3 skycolor = vec3(0.6, 1.5, 1.0); \n\n\tvec3 bg = exp(uv.y-1.0)*vec3(0.5, 0.9, 1.5);\n\n    float sc=clamp(dot(sundir, rd), 0.0, 1.0); \n    vec3 col=bg+vec3(1.0,0.8,0.4)*pow(sc,50.0); \n\n\n    float t=0.0;\n    vec3 p=ro; \n\t \n\tvec3 res = intersect(ro, rd);\n\t if(res.x > 0.0){\n\t\t   p = ro + res.x * rd;\n           bcolor = true;\n           mat=vec3(0.0);\n           vec3 n=nor(p);\n           mat/=6.0;\n           bcolor = false;\n           float occ = ao(p, n); \n           float shadow = softshadow(p, sundir, 50.0);\n\n           float dif = max(0.0, dot(n, sundir)); \n           float sky = 0.6 + 0.4 * max(0.0, dot(n, vec3(0.0, 1.0, 0.0))); \n \t\t   float bac = max(0.3 + 0.7 * dot(vec3(-sundir.x, -1.0, -sundir.z), n), 0.0); \n           float spe = max(0.0, pow(clamp(dot(sundir, reflect(rd, n)), 0.0, 1.0), 20.0)); \n\n           vec3 lin = 5.5 * sun * dif; \n           lin += 0.8 * bac * sun * occ; \n           lin += 0.6 * sky * skycolor * occ; \n           lin += 2.0 * spe * occ; \n\n           col = shadow * lin *(vec3(0.6, 0.8, 0.9)*(1.0-res.y)+mat*res.y) *  0.2; \n \t\t   col = mix(col,bg, 1.0-exp(-0.003*res.x*res.x)); \n    } \t\n    // post\n    col=pow(clamp(col,0.0,1.0),vec3(0.45)); \n    col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n    col=mix(col, vec3(dot(col, vec3(0.33))), -1.);  // satuation\n    col*=0.5+0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.8);  // vigneting\n \tfragColor.xyz = col; \n }",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}