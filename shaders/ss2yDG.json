{
    "Shader": {
        "info": {
            "date": "1644033034",
            "description": "twist ladder",
            "flags": 0,
            "hasliked": 0,
            "id": "ss2yDG",
            "likes": 10,
            "name": "twist ladder",
            "published": 3,
            "tags": [
                "twistladder"
            ],
            "usePreview": 0,
            "username": "jorge2017a2",
            "viewed": 255
        },
        "renderpass": [
            {
                "code": "//----------image\n//por jorge2017a2-\n#define MAX_STEPS 100\n#define MAX_DIST 120.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\n//ref Iq\n///https://www.shadertoy.com/view/7tKSWt\n/// corregido por........ pyBlob\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\n///https://www.shadertoy.com/view/7tKSWt\nfloat sdStairs( in vec2 p, in vec2 wh, in float n )\n{\n    // base\n    vec2 ba = wh*n;\n    float d = min(dot2(p-vec2(clamp(p.x,0.0,ba.x),0.0)), \n                  dot2(p-vec2(ba.x,clamp(p.y,0.0,ba.y))) );\n    float s = sign(max(-p.y,p.x-ba.x) );\n\n    // steps repetition\n#if 1\n    float dia = length(wh);\n    p = mat2(wh.x,-wh.y, wh.y,wh.x)*p/dia;\n    float lid = clamp(round(p.x/dia),0.0,n-1.0);\n    p.x = p.x - lid*dia;\n    p = mat2(wh.x, wh.y,-wh.y,wh.x)*p/dia;\n#else\n    float dia2 = dot(wh,wh);\n    p = mat2(wh.x,-wh.y,wh.y,wh.x)*p;\n    float lid = clamp(round(p.x/dia2),0.0,n-1.0);\n    p.x = p.x - lid*dia2;\n    p = mat2(wh.x,wh.y,-wh.y,wh.x)*p/dia2;\n#endif    \n\n    // single step\n    float hh = wh.y/2.0;\n    p.y -= hh;\n    \n    if( p.y>hh*sign(p.x) ) s=1.0;\n    p = (lid<0.5 || p.x>0.0) ? p : -p;\n\n    d = min( d, dot2(p-vec2(0.0,clamp(p.y,-hh,hh))) );\n    d = min( d, dot2(p-vec2(clamp(p.x,0.0,wh.x),hh)) );\n    \n    return sqrt(d)*s;\n}\n\n\nfloat opScaleEscalera(vec2 p, vec2 med, float num )\n{\n    float s=0.25;\n    float d1= sdStairs( p/s, med, num )*s;\n    return d1;\n}\n\n///modificado y reparacion por..... pyBlob,\nfloat opBlock(float d2, float z, float r)\n{\n    float d1 = abs(z) - r;\n    return length(max(vec2(d1, d2), 0.)) + min(max(d1, d2), 0.);\n}\n\n///modificado y reparacion por..... pyBlob,\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 p0=p;\n\t   \n    float planeDist1 = p.y+5.0;  //piso inf\n    float planeDist2 = 45.0-p.y;  //piso sup\n    float planeDist3 = p.x+30.0; //pared izq\n    float planeDist4 = 30.0-p.x;  //pared der\n    float planeDist5 = -p.z+60.0;  //pared frente\n    float planeDist6 = p.z+60.0;  //pared atras\n    \n    res = opU3(res, vec3(planeDist1,100.0,-7.0));\n    res = opU3(res, vec3(planeDist2,100.0,-7.0));\n    res = opU3(res, vec3(planeDist3,100.0,-7.0));\n    res = opU3(res, vec3(planeDist4,100.0,-7.0));\n    \n    p.y = p.y-5.0;\n    \n    vec3 p1 = p; // sup\n    p1.z = opRep1D(p1.z, 30.0);\n\n    vec3 p2 = p; // inf\n    p2.z -= 15.;\n    // opRep only works correctly, when the repeated object is symmetric around the middle of the repetition.\n    // If you want to offset the bottom stairs, the repetition should be separate for top/bottom stairs.\n    p2.z = opRep1D(p2.z, 30.0);\n    \n    float da2 = opScaleEscalera(p1.xy-vec2(7.0,-10.0), vec2(10.0,10.0), 10.0 );\n    float dinter1 = opBlock(da2, p1.z, 5.);\n    res = opU3(res, vec3(dinter1,101.0,-1.0));\n    \n    float db2 = opScaleEscalera(vec2(-p1.x,p1.y)-vec2(7.0,-10.0), vec2(10.0,10.0), 10.0 );\n    float dinter2 = opBlock(db2, p1.z, 5.);\n    res = opU3(res, vec3(dinter2,101.0,-1.0));\n    \n    float dc2 = opScaleEscalera(vec2(-p2.x,-p2.y)-vec2(8.0,-40.0), vec2(10.0,10.0), 10.0 );\n    float dinter3 = opBlock(dc2, p2.z, 5.);\n    res = opU3(res, vec3(dinter3,101.0,-1.0));\n    \n    float dd2 = opScaleEscalera(vec2(p2.x,-p2.y)-vec2(8.0,-40.0), vec2(10.0,10.0), 10.0 );\n    float dinter4 = opBlock(dd2, p2.z, 5.);\n    res = opU3(res, vec3(dinter4,101.0,-1.0));\n\n    return res;\n}\n\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n        float hr = 0.01 + float(i) * 0.5 / 4.0;\n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    float occ = occlusion(hit, norm);\n    \n   float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);\n    vec3 color = col*(dif+.35 +vec3(.35,.45,.5)*spe) + vec3(.7,.9,1)*spe*spe;\n    color*=occ;\n    return color;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); return col; }\n    if (i==101 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); return col*vec3(1.0,0.5,0.5); }\n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    return colobj;\n}\n\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43; \n    d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,d)*light_color1;\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,d)*light_color2;\n   \n        col= result;\n         // Exponential distance fog\n        col = mix(col, 0.8 * vec3(0.7, 0.8, 1.0), 0.5 - exp2(-0.0011 * d *d ));\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/5.0 ;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*10.0,360.0);\n    itime=t;\n    \n\tlight_pos1= vec3(0.0, 60.0, -25.0 ); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(0.0, 60.0, 50.0 ); light_color2 =vec3( 1.0,1.0,1.0 );   \n   vec3 ro=vec3(0.0,20.0,0.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   rd= rotate_y(rd, radians(t));\n   rd= rotate_z(rd, radians(t));\n   vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//----------common\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}