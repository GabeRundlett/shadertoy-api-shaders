{
    "Shader": {
        "info": {
            "date": "1556480452",
            "description": "Trying to raymarch a somewhat complex scene. And some cel-shading. :)\n\nUse the mouse to control the camera.",
            "flags": 0,
            "hasliked": 0,
            "id": "wtXGDM",
            "likes": 8,
            "name": "Ride to Heaven",
            "published": 3,
            "tags": [
                "raymarching",
                "celshading",
                "toonshading"
            ],
            "usePreview": 0,
            "username": "MadEqua",
            "viewed": 590
        },
        "renderpass": [
            {
                "code": "#define MAT_RAILS 0\n#define MAT_BARS 1\n#define MAT_CART 2\n#define MAT_TERRAIN 3\n#define MAT_CART_BOLTS 4\n#define MAT_RAIL_BOLTS 5\n#define MAT_EDGE 6\n#define MAT_TREE 7\n\n#define PRIMARY_STEPS 256\n#define SHADOW_STEPS 32\n\n#define EPSILON 0.001\n#define MAX_DIST 1750.\n\n#define CEL_SHADES 6.\n#define EDGE_THICKNESS 0.01\n#define EDGE_MAX_DIST 1000.\n\nfloat time;\n\nstruct Light {\n    vec3 dir;\n    vec3 diffColor;\n    vec3 specColor;\n};\n\nstruct Material {\n    vec3 diffColor;\n    vec3 specColor;\n    float shininess;\n};\n\nstruct ScenePoint {\n    int materialId; //Material of closest object\n    float d; //Distance to closest object\n    float t; //Distance on ray that generated this point\n};\n\nLight lights[3];\nMaterial materials[8];\n\n\nfloat rand(float v) {\n    return fract(sin(v) * 5364.54367);\n}\n\nfloat rand(vec2 p) {\n    return fract(sin(dot(p.xy, vec2(12.9898, 78.233))) * 47851.5453123);\n}\n\nfloat noise(vec2 p){\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    float a = rand(i);\n    float b = rand(i + vec2(1., 0.));  \n    float c = rand(i + vec2(0., 1.)); \n    float d = rand(i + vec2(1., 1.)); \n    \n    float ab = mix(a, b, smoothstep(0., 1., f.x));\n    float cd = mix(c, d, smoothstep(0., 1., f.x));\n    return mix(ab, cd, smoothstep(0., 1., f.y));\n}\n\nfloat fbm(vec3 p) {\n    float v = 0.;\n    float amplitude = .5;\n    float freq = 0.;\n    \n    for(int i = 0; i < 2; ++i) {\n        v += amplitude * noise(p.xz);\n        p *= 2.;\n        amplitude *= .5;\n    }\n    return v;\n}\n\nvec3 cam2world(vec3 v, vec3 pos, vec3 lookAt) {\n    vec3 z = normalize(lookAt - pos);\n    vec3 y = vec3(0, 1, 0);\n    vec3 x = normalize(cross(z, y));\n    y = normalize(cross(x, z));\n    mat3 m = mat3(x, y, z);\n    return normalize(m * v);\n}\n\nfloat sphere(vec3 p, float r) {\n     return length(p) - r;\n}\n\nfloat box(vec3 p, vec3 b)  {\n    vec3 d = abs(p) - b;\n    return length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\nfloat roundBox(vec3 p, vec3 b, float r) {\n    vec3 d = abs(p) - b;\n    return length(max(d, 0.)) - r + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\nfloat plane(vec3 p, vec3 n, float d)  {\n    return dot(p, n) - d;\n}\n\nfloat roundCone( vec3 p, float r1, float r2, float h) {\n    vec2 q = vec2(length(p.xz), p.y);\n    float b = (r1 - r2) / h;\n    float a = sqrt(1.0 - b * b);\n    float k = dot(q, vec2(-b, a));\n    if(k < 0.) return length(q) - r1;\n    if(k > a * h) return length(q - vec2(0., h)) - r2;\n    return dot(q, vec2(a, b) ) - r1;\n}\n\nvec3 repeat(vec3 p, vec3 period) {\n    return mod(p, period) - .5 * period;\n}\n\nfloat smoothUnion(float v1, float v2, float k) {\n    float h = clamp(.5 + .5 * (v2 - v1) / k, 0., 1.);\n    return mix(v2, v1, h) - k * h * (1. - h); \n}\n\nfloat hills(float z) {\n    z -= time;\n    return sin(z / 128.) * cos(z / 64.) * 6.;\n}\n\nvec3 sky(vec3 originalColor, float dist, vec3 rd) {\n    const vec3 SKY_COLOR = vec3(.2, .4, 1.);\n    \n    vec3 sunDir = -lights[0].dir;\n    float skyAmmount = smoothstep(5., 25., dist) * (1. - exp(-dist * 0.012));\n    float sunAmmount = max(dot(rd, sunDir), 0.);\n\n    vec3 diff = sunDir - rd;\n    float rays = smoothstep(-1., 1., sin(atan(diff.y, diff.x) * 8. + time * .3)) * .35;\n    rays *= step(MAX_DIST * .5, dist);\n    rays = min(rays, length(diff * .3));\n\n    vec3 skyCol = mix(SKY_COLOR, lights[0].diffColor, pow(sunAmmount, 50.) + rays);\n    return mix(originalColor, skyCol, skyAmmount);\n}\n\nScenePoint scene(vec3 p) {\n    ScenePoint result;\n\n    p.y -= hills(p.z);\n\n    //Rails\n    vec3 xMirrorP = p;\n    xMirrorP.x = abs(xMirrorP.x);\n\n    float rails = box(xMirrorP - vec3(1.5, 0., 0.), vec3(.12, .2, 999.));\n    rails = max(rails, -box(xMirrorP - vec3(1.4, 0., 0.), vec3(.06, .15, 999.)));\n    result.materialId = MAT_RAILS;\n    result.d = rails;\n    \n    //Bars\n    vec3 scrollP = p;\n    scrollP.z = scrollP.z - time;\n    \n    vec3 repeatedP = scrollP;\n    repeatedP.z = repeat(repeatedP, vec3(1, 1, 2)).z;\n    \n    vec3 xMirrorRepP = repeatedP;\n    xMirrorRepP.x = abs(xMirrorRepP.x);\n    \n    repeatedP.x += rand(floor(scrollP.z + .5)) * .5 - .25;\n    float bars = box(repeatedP - vec3(0, -.4, 0), vec3(2.4, .18, .2));\n    if(bars < result.d) {\n        result.materialId = MAT_BARS;\n        result.d = bars;\n    }\n\n    //Bar bolts\n    float bolts = sphere(xMirrorRepP - vec3(1.44, -.15, 0.1), .05);\n    if(bolts < result.d) {\n        result.materialId = MAT_RAIL_BOLTS;\n        result.d = bolts;\n    }\n    \n    //Cart\n    const float cartZ = 19.4;\n    float cart = roundBox(p - vec3(0., .8, cartZ), vec3(1.2, 1., 1.), .15);\n    cart = max(cart, -roundBox(p - vec3(0., 1., cartZ), vec3(.9, 1., .7), .1));\n    cart = max(cart, -roundBox(p - vec3(0., 1., cartZ), vec3(1., .65, .65), .16));\n    cart = min(cart, box(p - vec3(0., 1., cartZ - 0.84), vec3(.75, .5, .05)));\n    if(cart < result.d) {\n        result.materialId = MAT_CART;\n        result.d = cart;\n    }\n\n    //Cart bolts\n    vec3 cartBoltsP = p;\n    cartBoltsP.x *= step(-1.1, cartBoltsP.x) * step(cartBoltsP.x, 1.1);\n    cartBoltsP.x = repeat(cartBoltsP, vec3(.25, 1., 1.)).x;\n    float cartBolts = sphere(cartBoltsP - vec3(0., 1.83, cartZ - .76), .02);\n\n    vec3 cartBoltsP2 = p;\n    cartBoltsP2.x = abs(cartBoltsP2.x);\n    cartBoltsP2.y = abs(cartBoltsP2.y - 1.05);\n    cartBolts = min(cartBolts, sphere(cartBoltsP2 - vec3(0.63, .35, cartZ - .76), .02));\n    if(cartBolts < result.d) {\n        result.materialId = MAT_CART_BOLTS;\n        result.d = cartBolts;\n    }\n\n    //Terrain\n    vec3 terrP = scrollP;\n    float ridge = smoothstep(2., 10., terrP.x) + smoothstep(-2., -10., terrP.x);\n    terrP.y -= ridge * (sin(terrP.z * .02) * 2. + 8.);\n\n    terrP.x -= sin(terrP.z * .65) * 2.;\n    terrP.y -= fbm(terrP) * (ridge + .3);\n\n    float terr = plane(terrP, vec3(0., 1., 0.), -.45);\n    if(terr < result.d) {\n        result.materialId = MAT_TERRAIN;\n        result.d = smoothUnion(result.d, terr, .05);\n\n        float n = noise(vec2(p.x, terrP.z) * 1.2);\n        vec3 c = mix(vec3(.1, .9, .15), vec3(0., .85, .2), smoothstep(.3, .5, n));\n        materials[MAT_TERRAIN].diffColor = mix(vec3(.6, .35, .33), c, pow(ridge, .4));\n    }\n\n    //Trees\n    vec3 treeP = vec3(p.x, terrP.y, scrollP.z);\n    treeP.x = abs(treeP.x);\n    treeP -= vec3(11.5, 2.9, 0.);\n\n    const float cells = 27.;\n    treeP.z = repeat(treeP, vec3(1., 1., cells)).z;\n    vec2 id = floor(vec2(step(p.x, .0), scrollP.z / cells));\n\n    float r = rand(id);\n    float r2 = rand(id + vec2(12.23, 42.25));\n    float r3 = rand(id - vec2(76.432, 980.543));\n\n    float tree = roundCone(treeP, (r + .3) * 2.5, (r2 + .45) * 1.4, (r3 + .4) * 3.2);\n    if(tree < result.d) {\n        result.materialId = MAT_TREE;\n        result.d = tree;\n        materials[MAT_TREE].diffColor = mix(vec3(.8, .3, .15), vec3(.15, .95, .15), r2);\n    }\n    tree = min(tree, box(treeP - vec3(0., -2., 0.), vec3(.2, 2., .2)));\n    if(tree < result.d) {\n        result.materialId = MAT_BARS;\n        result.d = tree;\n    }\n    \n    return result;\n}\n\nbool rm(int steps, vec3 ro, vec3 rd, out ScenePoint sp) {\n    float t = 0.;\n    float minD = 99999.;\n    \n    for(int i = 0; i < steps && t < MAX_DIST; ++i) {\n        vec3 p = ro + rd * t;\n        sp = scene(p);\n        sp.t = t;\n        if(sp.d < EPSILON)\n            return true;\n        \n        //Edge detection\n        minD = min(sp.d, minD);\n        if(sp.d > minD && minD < EDGE_THICKNESS * (1. - (t / EDGE_MAX_DIST))) {\n            sp.materialId = MAT_EDGE;\n            return true;\n        }\n        \n        t += sp.d;\n    }\n    return false;\n}\n\nvec3 normal(vec3 p, ScenePoint sp) {\n    vec2 e = vec2(EPSILON, 0.);\n    //float d = scene(p).d;\n    float x = scene(p - e.xyy).d;\n    float y = scene(p - e.yxy).d;\n    float z = scene(p - e.yyx).d;\n    return normalize(vec3(sp.d) - vec3(x, y, z));\n}\n\nvec3 shade(vec3 cameraPos, vec3 rd, ScenePoint sp) {\n    if(sp.materialId == MAT_EDGE) {\n        vec3 c = materials[MAT_EDGE].diffColor;\n        return mix(c, c * .01, smoothstep(.0, 1., sp.d / EDGE_THICKNESS));\n    }\n    \n    vec3 albedo = materials[sp.materialId].diffColor;\n    vec3 specular = materials[sp.materialId].specColor;\n    float shininess = materials[sp.materialId].shininess;\n    \n    vec3 p = cameraPos + rd * sp.t;\n    vec3 N = normal(p, sp);\n    vec3 V = normalize(cameraPos - p);\n    \n    vec3 sum = vec3(0);\n    for(int i = 0; i < 3; ++i) {\n    \n        vec3 L = -lights[i].dir;\n        vec3 H = normalize(V + L);\n    \n        float difFactor = max(0., dot(L, N));\n        difFactor = ceil(difFactor * CEL_SHADES) / CEL_SHADES;\n    \n        float specFactor = pow(max(0., dot(H, N)), shininess);\n        specFactor = ceil(specFactor * CEL_SHADES) / CEL_SHADES;\n        \n        sum += lights[i].diffColor * albedo * difFactor +\n            lights[i].specColor * specular * specFactor;\n    }\n    \n    ScenePoint shadowSp;\n    bool hit = rm(SHADOW_STEPS, p + N * (EDGE_THICKNESS + EPSILON), -lights[0].dir, shadowSp);\n    if(hit) {\n        sum *= vec3(.8);\n    }\n    return sum;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n     time = iTime * 8.;\n\n    //Sun Key\n    lights[0].dir = normalize(vec3(0., -.05, 1.));\n    lights[0].diffColor = vec3(.95, .95, .9);\n    lights[0].specColor = vec3(1.);\n    //Sun Fill\n    lights[1].dir = normalize(vec3(1., -1., -.6));\n    lights[1].diffColor = vec3(.7, .6, .6);\n    lights[1].specColor = vec3(0.);\n    //Sun Fill\n    lights[2].dir = normalize(vec3(-1., -1., -.6));\n    lights[2].diffColor = vec3(.7, .6, .6);\n    lights[2].specColor = vec3(0.);\n\n    materials[MAT_RAILS].diffColor = vec3(.1, .1, .05);\n    materials[MAT_RAILS].specColor = vec3(.7);\n    materials[MAT_RAILS].shininess = 10.;\n\n    materials[MAT_BARS].diffColor = vec3(.1, .077, .05);\n    materials[MAT_BARS].specColor = vec3(0.);\n    materials[MAT_BARS].shininess = 1.;\n\n    materials[MAT_CART].diffColor = vec3(.9, .55, .25);\n    materials[MAT_CART].specColor = vec3(.7);\n    materials[MAT_CART].shininess = 20.;\n\n    //materials[MAT_TERRAIN].diffColor = vec3(0.); Dynamically generated\n    materials[MAT_TERRAIN].specColor = vec3(0.);\n    materials[MAT_TERRAIN].shininess = 1.;\n\n    materials[MAT_CART_BOLTS].diffColor = vec3(.5, .35, .21);\n    materials[MAT_CART_BOLTS].specColor = vec3(.2);\n    materials[MAT_CART_BOLTS].shininess = 20.;\n\n    materials[MAT_RAIL_BOLTS].diffColor = vec3(.05, .05, .05);\n    materials[MAT_RAIL_BOLTS].specColor = vec3(.7);\n    materials[MAT_RAIL_BOLTS].shininess = 10.;\n\n    materials[MAT_EDGE].diffColor = vec3(0.1);\n    materials[MAT_EDGE].specColor = vec3(.0);\n    materials[MAT_EDGE].shininess = 1.;\n\n    //materials[MAT_TREE].diffColor = vec3(.0); Dynamically generated\n    materials[MAT_TREE].specColor = vec3(.0);\n    materials[MAT_TREE].shininess = 1.;\n\n    vec2 uv = (gl_FragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n\n    vec3 cameraPos = vec3(0., 2.5 + hills(19.1), 20.);   \n    vec3 lookAt = vec3(sin(time * .05) * 1.3, 0.5, 0.);\n    if(iMouse.z > .0)\n    \tlookAt.xy = vec2(15., 25.) * ((iMouse.xy / iResolution.xy) - vec2(.5));\n    \n    vec3 rd = cam2world(vec3(uv, 1.5), cameraPos, lookAt); \n\n    ScenePoint sp;\n    vec3 col = vec3(.4);\n\n    bool hit = rm(PRIMARY_STEPS, cameraPos, rd, sp);\n    if(hit) {\n        col = shade(cameraPos, rd, sp);\n    }\n\n    col = sky(col, sp.t, rd);\n\n    col = pow(col, vec3(1. / 2.2));\n    fragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}