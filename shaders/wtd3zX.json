{
    "Shader": {
        "info": {
            "date": "1577110180",
            "description": "MDTMJVM = Middecembertomidjanuaryvember\nCheck out the other days at https://github.com/wrightwriter/Middecembertomidjanuaryvember\n\nCoding daily at http://twitch.tv/wwrighter",
            "flags": 8,
            "hasliked": 0,
            "id": "wtd3zX",
            "likes": 19,
            "name": "[music][twitch] Day 5 of MDTMJVM",
            "published": 3,
            "tags": [
                "sound",
                "music",
                "ifs",
                "reverb"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 1018
        },
        "renderpass": [
            {
                "code": "// Inspired by nusan!\n// He has really good IFS and refraction techniques.\n// Check him out https://www.shadertoy.com/user/nusan\n\n#define dmin(a, b) (a.x < b.x) ? a : b\nvec3 ACESFilm( vec3 x )\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return max(vec3(.0), min(vec3(1.0), (x*(a*x+b))/(x*(c*x+d)+e) ) );\n}\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv) {\n  vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n  vec3 up = normalize(cross(dir, right));\n  \n  return dir*1. + right*uv.x*0.3 + up*uv.y*0.3;\n}\n\nfloat sdObjA(vec3 p, float r){  \n  p.y *= 0.5;\n  p = abs(p);\n  p -= r;\n  float d = max(p.x, p.y);\n  d = max(d, p.z);\n  d = max(d, dot(p + 0.2, normalize(vec3(1))));\n  return d;\n}\n\nfloat sdCube(vec3 p, vec3 r){\n  p = abs(p);\n  p -= r;\n  float d = max(p.x, p.y);\n  return max(d, p.z);\n}\n\n#define rot(x) mat2(cos(x), -sin(x), sin(x), cos(x))\n#define pi acos(-1.)\nvec2 sdMainGeom(vec3 p) {\n    vec2 d = vec2(10e3);\n    d = dmin(d, vec2(sdObjA(p, 0.5), 1.));\n    //d = dmin(d, vec2(sdObjA(p - vec3(0,1,0), 0.5), 3.));\n    p = abs(p);\n    p -= 0.5;\n    p.xz *= rot(0.25*pi);\n    d = dmin(d, vec2(sdCube(p, vec3(0.1,2.,0.1)), 2.));\n  \n  d.x *= 0.5;\n  return d;\n}\n\nfloat mpow(float a, float b) {\n  for(float i = 0.; i < b; i++) {\n      a = a * a;\n  }\n  return a;\n}\n\nfloat timeMod() {\n  float t = iTime * 0.2;\n  return floor(t) + smoothstep(0.,1.,fract(t));\n}\n#define dmod(p, x) mod(p, x) - x*0.5\n\nvec2 map(vec3 p){\n  vec2 d = vec2(10e3);\n  \n\n  \n  float tMod = mpow(sin(iTime*0.2),5.);\n  \n  for (float i = 0.; i < 7.; i++) {\n    p.x -= 2. + ( smoothstep(1.,0.,iTime*0.1) * 5.  ) ; // TODO: smoothstep this from beggining of shader\n    \n    p.y -= 0.7;\n    \n    p.xy *= rot(0.6*pi + timeMod());\n    p.zy *= rot(0.3*pi );\n    p = abs(p);\n    \n  }\n  \n  \n  d = dmin(d, sdMainGeom(p));\n \n  return d;\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 t= vec2(0.001, 0.);\n  return normalize(map(p).x - vec3(\n    map(p - t.xyy).x,\n    map(p - t.yxy).x,\n    map(p - t.yyx).x\n  ));\n}\n#define spectra(x, t) (0.5 + 0.2*sin(vec3(0.5,0.8,0.7)*t + x) )\n\n#define zoom 46.\n#define rotSpeed 0.2\n\nfloat random( vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.1);\n}\n\nfloat noise(vec2 p) {\n\tvec2 i = ceil(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3. - 2. * f);\n   \tfloat a = random(i);\n    float b = random(i + vec2(1., 0.));\n    float c = random(i + vec2(0., 1.));\n    float d = random(i + vec2(1., 1.));\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\nfloat fbm(in vec2 p) { \n\tfloat s = .0;\n\tfloat m = .0;\n\tfloat a = .5;\t\n\tfor(int i = 0; i < 5; i++) {\n\t\ts += a * noise(p);\n\t\tm += a;\n\t\ta *= .5;\n\t\tp *= 2.;\n\t}\n\treturn s / m;\n}\n\nvec3 carToPol(vec3 p) { // learned this here -- https://www.shadertoy.com/view/WsSXWm\n    float r = length(p);\n    float the = acos(p.z/r);\n    float phi = atan(p.y,p.x);\n    return vec3(r,the,phi);\n}\n\n\nvec4 render(vec2 uv) {\n  vec3 col = vec3 (0);\n  \n  vec3 ro = vec3(sin( sin( iTime*rotSpeed)*pi/2. -2. )*zoom,sin(iTime + cos(iTime)),cos(sin(iTime*rotSpeed)*pi/2. -2. )*zoom);\n  vec3 lookAt = vec3(0);\n  vec3 rd = getRd(ro, lookAt, uv);\n  \n  vec3 glow = vec3(0);\n  float t = 0.;\n  vec3 p = ro; \n  float side = 1.;  // thanks nusan for refraction logic! \n  \n  float bounces = 0.;\n  \n  float colStrength = 1.;\n  \n  for (int i = 0; i < 220; i++) {\n      vec2 d = map(p);\n      d.x *= side;\n    \n      glow += spectra(d.x, 13. + sin(iTime) * 4.)*0.6;\n      if (d.x < 0.001) {\n        vec3 n = getNormal(p)*side;\n        vec3 posLightA = vec3(0,3.,-4);\n        vec3 colLightA = vec3(0.3,0.5,0.9);\n        vec3 posLightB = vec3(0,-4.,3);\n        vec3 colLightB = vec3(0.5,0.7,0.9);\n        \n        vec3 lA = normalize(posLightA - p);\n        vec3 lB = normalize(posLightB - p);\n        vec3 hA = normalize(lA - rd);\n        vec3 hB = normalize(lB - rd);\n        \n        float diffA = max(dot(lA, n), 0.);\n        float diffB = max(dot(lB, n), 0.);\n        \n        float specA = max(dot(n,hA), 0.);\n        float specB = max(dot(n,hB), 0.);\n        \n        float fres = pow(1. - max(dot(n, -rd),0.), 5.);\n        \n        vec3 colA = diffA * colLightA;\n        vec3 colB = diffB * colLightB;\n        //col = vec3(1);\n        \n        \n        if (d.y == 1.) {\n         \n          col += (colA + colB)*glow*colStrength*fres  + fres*0.1;\n          \n          //col += fres * glow * 0.1*colStrength;\n          \n          colStrength *= 0.9;\n          \n          rd = refract(rd, n, 1. + 0.01*n.y);\n          \n          d.x = 0.6;\n            \n          side *= -1.;\n          bounces += 1.;\n           \n          \n        } else if (d.y == 2.) {\n          \n          \n          //col += (colA + colB*0.1)*glow*colStrength + fres*0.6;\n          \n          col += fres*(colA + colB) + colA*0.8;\n          \n          rd = reflect(rd, n);\n          \n          d.x = 0.2;\n          colStrength *= 0.4;\n          \n          bounces += 1.;\n        }else if (d.y == 3.) {\n         \n          col += (colA + colB)*glow*colStrength * vec3(0.9,0.9,0.2) + fres*0.1;\n          \n          colStrength *= 0.6;\n          \n          rd = refract(rd, n, 1. + 0.0);\n          \n          d.x = 0.6;\n            \n          side *= -1.;\n          bounces += 1.;\n        \n        \n        \n      }\n        \n        if (bounces > 5.) break;\n        //break;\n        //break; \n      }\n      \n      if (length(p) > 50.) {\n        rd.yz *= rot(0.5*pi);    \n        \n        vec3 pPolar = carToPol(rd);\n        \n        float fA = fbm(pPolar.yz*6.);\n        vec3 fB = fbm(pPolar.yz*6. + fA*6. + iTime*0.1) * spectra(fA, 90.);\n        \n        col += fB* colStrength*0.1;\n        \n        //col = vec3(0);\n        break; \n      }\n    col += glow*0.00006;\n    t += d.x;\n    p = ro + rd * t;\n  }\n  \n  \n  //col += smoothstep(0.,1., pow(t.x - 54., 7.)) * vec3(0.8,0.3,0.7);\n  col *= 0.2;\n  col = ACESFilm(col);\n  col = pow(col, vec3(0.44));\n  return vec4(col, 0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec4 col = render(uv);\n\n    fragColor = vec4(col);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define pi acos(-1.)\n#define tau (2.*pi)\n\n#define tempo 120.\n#define hbeat ((60./tempo)/1.)\n#define qnote (hbeat/2.)\n#define beat  (hbeat*2.)\n#define qbeat  (beat/4.)\n#define measure  (hbeat*2.)\n\n\nfloat note(float note, float octave){\n\treturn 27.5*pow(2., ((octave*12.) + note )/12.);\n}\nfloat noise( vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.1);\n}\nfloat random(float st){\n\treturn fract(sin(st*42151.5524124));\n}\nfloat rand(float t) {\n\treturn fract(sin(t*3211251.325235325));\n}\n\nvec2 makeAmb(float t) {\n\tvec2 s = vec2(0);\n\n    float freqA = note(9., 0.);\n    float freqB = note(9., 1.);\n    float freqC = note(9. + 7., 1.);\n    float scale = 1.;\n    float iters = 6.;\n    for (float i = 0.; i < iters; i++) {\n    \n        s.x += sin(tau*t*freqA    )*scale * 0.5;\n        s.x += sin(tau*t*freqB    )*scale * 0.2;\n        s.x += sin(tau*t*freqC  + smoothstep(0.,1.,sin(t) * noise(vec2(t))*0.5)  )*scale * 0.4;\n    \tfreqA *= 2.002 +random(i)*0.3 + sin(t + i)*0.002;\n    \tfreqC *= 2.002 +random(i)*0.3 + sin(t + i)*0.002;\n    \tfreqB *= 1.501;\n        scale *= 0.2 + smoothstep(0.,1., t*0.2)*0.3 + cos(t * 0.2)*0.1;\n    }\n    s.y = s.x;\n    \n    return s;\n}\n\nvec2 makeKick(float t) {\n    vec2 s = vec2(0);\n    float r = random( mod(floor(t/ hbeat), 26.));\n    float rB = random( mod(floor((t + 4.)/ hbeat), 26.));\n    \n    \n    if (rB < 0.25) {\n        r *= 4.;\n\t\tr = floor(r);\n        r += 1.;\n        float offs = hbeat * 1./r;\n        if (offs == hbeat) {\n        \toffs -= hbeat/4.;\n        }\n        t = mod(t + offs, hbeat);\n\n        float env = exp(-t*10.);\n        \ts.x += sin( (140. * env+ 10. ) *tau*t) * env ;\n        \ts.x += sin( (240. * env+ 10. ) *tau*t) * env ;\n\t\n    \t//s.x += sin( (random(t)) *tau*t) * env*2. ;\n        \n        s.x = clamp(s.x*1.6,-1., 1.);\n\n        \n        s.y = s.x;\n    \n    }\n    return s;\n}\n\nfloat arp(float t, float r, float scale) {\n\tfloat n = 0. ;\n    //float r = random( mod( floor(t/period), 50.));\n    r *= 7.;\n    r = floor(r);\n    (r == 0.) ? n = note(9., 2.) :\n    (r == 1.) ? n = note(9. - 8., 2.) :\n    (r == 2.) ? n = note(9. - 5., 2.) :\n    (r == 3.) ? n = note(9. - 6., 2.) :\n    (r == 4.) ? n = note(9. + 1., 2.) :\n    (r == 5.) ? n = note(9. + 3., 2.) :\n    (r == 6.) ? n = note(9. + 3. - 12., 2.) :\n    (r == 7.) ? n = note(9., 1.) : 0.;\n    //);\n    return n;\n}\n\nvec2 makeBells(float t) {\n    vec2 s = vec2(0);\n    float r = random( mod(floor(t/ hbeat), 26.) + 4.);\n    float rC = r;\n    float rB = random( mod(floor((t + 4.)/ hbeat) + 4., 26.));\n    \n    \n    if (rB < 0.04) {\n        r *= 4.;\n\t\tr = floor(r);\n        r += 1.;\n        float offs = hbeat * 1./r;\n        if (offs == hbeat) {\n        \toffs -= hbeat/4.;\n        }\n        t = mod(t + offs, hbeat);\n\n        float env = exp(-t*15.);\n        \n        float freq = (arp(t,rC, 1.)) ; \n        float scale = 1.;\n        float iters = 3.;\n    \tfor (float i = 0.; i < iters; i++) {\n       \t\ts.x += sin(freq *tau*t) * env * scale ;\n            \n            freq *= 2.01;\n            scale *= 0.8;\n        }\n\t\t//s.x /= iters;\n    \t//s.x += sin( (random(t)) *tau*t) * env*2. ;\n        \n        //s.x = clamp(s.x*1.6,-1., 1.);\n\n        \n        s.y = s.x;\n    \n    }\n    return s;\n}\n\nvec2 echoChannel(float t) {\n\tvec2 s = vec2(0);\n\n    float fb = 0.55, tm = qbeat*1.5, cf = 0.9, ct = tm;\n    // tap 1 \n    s += makeAmb(t) * cf; cf *= fb; \n    // tap 2\n    s += makeAmb(t - ct) * cf; cf *= fb; ct += tm;\n    // tap 3\n    s += makeAmb(t - ct) * cf; cf *= fb; ct += tm;\n    // tap 4\n    s += makeAmb(t - ct) * cf; cf *= fb; ct += tm;\n    // tap 5\n    s += makeAmb(t - ct) * cf; cf *= fb; ct += tm;\n    \n    return s;\n}\nvec2 echoChannelB(float t) {\n\tvec2 s = vec2(0);\n\n    float fb = 0.15, tm = qbeat*1.5, cf = 0.9, ct = tm;\n    // tap 1 \n    s += makeBells(t) * cf; cf *= fb; \n    // tap 2\n    s += makeBells(t - ct) * cf; cf *= fb; ct += tm;\n    // tap 3\n    s += makeBells(t - ct) * cf; cf *= fb; ct += tm;\n    // tap 4\n    s += makeBells(t - ct) * cf; cf *= fb; ct += tm;\n    // tap 5\n    s += makeBells(t - ct) * cf; cf *= fb; ct += tm;\n    \n    return s;\n}\nvec2 reverbChannelB(float t) {\n\tvec2 s = vec2(0);\n    \n    vec2 reverb = vec2(0);\n    float st = 0.02; float iters = 200.;\n    for (float i = 0.; i < iters; i++) {\n    \treverb += ((makeBells(t - i*st + random(i)*0.02))/iters) *(1. - i/iters) ;\n    }\n    reverb *= 2.;\n    s += makeBells(t)*0.1;\n    s += reverb*1.5;\n    s *= 2.;\n\treturn s;\n}\n\n\nvec2 mainSound( in int samp, float time )\n{\n    vec2 s = vec2(0);\n     \n    \n    s += echoChannel(time);\n    s += echoChannel(time + sin(time*0.2)*0.04);\n    s += echoChannel(time + cos(time*0.6)*0.02);\n    s += echoChannel(time*0.5 + cos(time*0.34)*0.1);\n    \n    s += makeKick(time)*1.4;\n\n    s += reverbChannelB(time)*10.;\n    \n    s *= 0.2;\n    \n    s = clamp(s, vec2(-1.), vec2(1.));\n    \n    s *= smoothstep(0.,1., time*0.6);\n    \n    return s;\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}