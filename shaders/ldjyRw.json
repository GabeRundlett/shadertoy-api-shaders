{
    "Shader": {
        "info": {
            "date": "1491416585",
            "description": "With High Performance GPU",
            "flags": 97,
            "hasliked": 0,
            "id": "ldjyRw",
            "likes": 1,
            "name": "Raycasting 3D Music",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "cube"
            ],
            "usePreview": 0,
            "username": "hopskotchrainbow",
            "viewed": 690
        },
        "renderpass": [
            {
                "code": "#define pi 3.14152865\n\n#define eps 0.00125\n#define edge 0.000125\n#define shading 0.00012\n#define ev vec3(shading, 0.0, 0.0)\n\n#define time iTime\n\nstruct bit3d_shape\n{\n\tvec3 diffuse;\n\tvec3 ambient;\n\tvec3 glowcolor;\n\tfloat glow;\n\tfloat surface;\n\tvec3 specular;\n\tfloat specPower;\n\tint portal;\n\tfloat ambientOcclusion;\n\tfloat reflection;\n\tbool stepk;\n};\nstruct bit3d_coordinate\n{\n\tvec3 position;\n\tint portal;\n};\n\nstruct bit3d_Ray\n{\n\tvec3 origin;\n\tvec3 direction;\n\tint maxIterations;\n\tint iters;\n\tfloat dist;\n\tbit3d_coordinate coord;\n\tbit3d_shape target;\n\tbool hit;\n\tvec3 normal;\n\tbool inside;\n};\n\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat iqnoise( in vec2 x, float u, float v )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\t\t\n\tfloat k = 1.0+63.0*pow(1.0-v,4.0);\n\t\n\tfloat va = 0.0;\n\tfloat wt = 0.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) );\n\t\tvec3 o = hash3( p + g )*vec3(u,u,1.0);\n\t\tvec2 r = g - f + o.xy;\n\t\tfloat d = dot(r,r);\n\t\tfloat ww = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );\n\t\tva += o.z*ww;\n\t\twt += ww;\n    }\n\t\n    return va/wt;\n}\n\nfloat checkerboard(vec2 v) {\n    float z = 0.;\n    if ((fract(v.x)<=0.5)!=(fract(v.y)<=0.5)) {\n        z = 1.0;\n    }\n    return z;\n}\nfloat checkerboard(vec3 v) {\n    float z = 0.;\n    if ((checkerboard(v.xy)<=0.5)!=(fract(v.z)<=0.5)) {\n        z = 1.0;\n    }\n    return z;\n}\n\n// Official HSV to RGB conversion\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n// Smooth HSV to RGB conversion\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 rgb2hsv( in vec3 c)\n{\n    vec4 k = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);\n    vec4 p = mix(vec4(c.zy, k.wz), vec4(c.yz, k.xy), (c.z<c.y) ? 1.0 : 0.0);\n    vec4 q = mix(vec4(p.xyw, c.x), vec4(c.x, p.yzx), (p.x<c.x) ? 1.0 : 0.0);\n    float d = q.x - min(q.w, q.y);\n    return vec3(abs(q.z + (q.w - q.y) / (6.0*d+eps)), d / (q.x+eps), q.x);\n}\n\nfloat direction(vec2 uv) {\n\tfloat a = atan(uv.x,uv.y)/radians(360.0);\n\ta += 0.5;\n\treturn a*360.0;\n}\n\nvoid rotate(inout vec2 uv, float angle) {\n\tfloat rad = radians(angle);\n\tuv = vec2(uv.x*cos(rad)-uv.y*sin(rad),\n\t\tuv.x*sin(rad)+uv.y*cos(rad));\n}\n\nvec2 direction(vec3 v)\n{\n\treturn vec2(\n\t\tdirection(v.xz)+180.0,\n\t\tdirection(vec2(\n\t\t\tlength(v.xz),\n\t\t\tv.y\n\t\t))+90.0\n\t);\n}\n\nvoid rotate(inout vec3 v, vec3 angle) {\n\trotate(v.zy, angle.x);\n\trotate(v.xz, angle.y);\n\trotate(v.xy, angle.z);\n}\n\nvec3 spherical(vec2 angle) {\n    vec2 rad = radians(angle-vec2(180.0,90.0));\n    return vec3(\n        sin(rad.x)*sin(rad.y),\n        cos(rad.y),\n        cos(rad.x)*sin(rad.y)\n    );\n}\n\n// union\nbit3d_shape op_union(bit3d_shape primary, bit3d_shape secondary) {\n\tbit3d_shape shape3d = primary;\n\tif (secondary.surface < primary.surface) shape3d = secondary;\n\treturn shape3d;\n}\n\n// intersection\nfloat op_intersect(float primary, float secondary) {\n\treturn max(primary, secondary);\n}\n\n// mixing\nfloat op_mix(float primary, float secondary, float factor) {\n\tfloat h = clamp((primary-secondary)/factor+1.0,0.0,1.0);\n\tfloat j = mix(primary, secondary, pow(h,3.0));\n\treturn j;\n}\n\n// subtraction\nfloat op_subtract(float primary, float secondary) {\n\treturn max(primary, -secondary);\n}\n\n// sphere\nfloat sphere(vec3 l, vec3 size) {\n\tvec3 sqf = sqrt(size);\n\tvec3 m = l/(sqf);\n\tif (length(m) > 1.0)\n\t{\n\t\tm = normalize(m);\n\t}\n\tm *= sqf;\n\treturn length(l-m);\n}\n\n// box\nfloat box(vec3 l, vec3 size) {\n\tvec3 m = clamp(l, -size/2.0,size/2.0);\n\treturn distance(l, m);\n}\n\n// cylinder\nfloat cylinder(vec3 l, vec2 scale, float bottom, float top) {\n\tvec2 scf = l.xz/scale;\n\tif (length(scf) >= 1.0) scf = normalize(scf);\n\tfloat coDist = distance(l.xz, scf*scale);\n\tfloat cg = max(l.y-bottom, top-l.y);\n\treturn max(cg, coDist);\n}\n\n\nvec3 path(float k, int id) {\n\tvec2 nv = vec2(cos(k*0.7),sin(k*0.7))*0.6;\n\treturn vec3(nv,k*1.3);\n}\n\nvec3 pathdir(float k, int id) {\n\treturn normalize(path(k+eps, id)-path(k, id));\n}\n\nvoid forward(inout vec3 point, vec3 target) {\n\tvec2 dh = direction(target);\n\trotate(point, -vec3(dh.yx,0.0));\n}\n\nvoid forward(inout vec3 point, vec3 target, float inverse3) {\n\tvec2 dh = direction(target);\n\trotate(point, -vec3(mix(dh.yx,-dh.yx,inverse3),0.0));\n}\n\nfloat capsphere(vec3 h, float radius) {\n\tvec2 orig = h.xy;\n\tif (length(orig) >= radius) {\n\t\torig = normalize(orig)*radius;\n\t}\n\treturn length(vec3(h.xy-orig.xy,h.z));\n}\n\nfloat speed(float k, int id) {\n\treturn distance(path(k,id),path(k+eps,id))/eps;\n}\n\nfloat crossh(vec3 p) {\n\tfloat m = max(max(abs(p.x),abs(p.y)),abs(p.z));\n\tfloat n = min(min(abs(p.x),abs(p.y)),abs(p.z));\n\tfloat d = (abs(p.x)+abs(p.y)+abs(p.z))/3.0;\n\treturn min(abs(n-m)+d/length(p),n);\n}\n\nfloat bone(vec3 p) {\n    float d = length(p.zy)-0.1;\n    d = op_subtract(d, 0.8-abs(p.x));\n    d = min(length(p-vec3(0.8,0.1,0.))-0.1,d);\n    d = min(length(p-vec3(0.8,-0.1,0.))-0.1,d);\n    d = min(length(p-vec3(-0.8,0.1,0.))-0.1,d);\n    d = min(length(p-vec3(-0.0,0.1,0.))-0.1,d);\n    return d;\n}\n\nvoid scene(\n\tinout bit3d_shape shape,\n\tbit3d_coordinate coord\n)\n{\n\tshape.diffuse = vec3(0.11,0.5,0.89);\n\tshape.ambient = vec3(0.0);\n\tshape.specular = vec3(0.2);\n\tshape.specPower = 5.0;\n\tshape.stepk = false;\n\tshape.reflection = 0.0;\n\tshape.ambientOcclusion = 0.45;\n\tvec3 mp = coord.position-vec3(0.0,0.,1.0);\n    rotate(mp, vec3(iTime*45.0));\n    float gb = box(mp, vec3(0.3,0.25,0.75));\n    if (coord.portal == 0) {\n        shape.surface = gb;\n    }\n}\n\nfloat scenef(bit3d_coordinate l) {\n\tbit3d_shape shape;\n\tshape.portal = l.portal;\n\tscene(shape, l);\n\treturn shape.surface;\n}         \n\nbit3d_coordinate cadd(bit3d_coordinate v, vec3 n) {\n\tbit3d_coordinate a;\n\ta.portal = v.portal;\n\ta.position = v.position+n;\n\treturn a;\n}\n\nvec3 bit3d_normal(bit3d_coordinate l) {\n\treturn normalize(vec3(\n\t\tscenef(cadd(l, ev.xyz))-scenef(cadd(l,0.0-ev.xyz)),\n\t\tscenef(cadd(l, ev.yxz))-scenef(cadd(l,0.0-ev.yxz)),\n\t\tscenef(cadd(l, ev.zyx))-scenef(cadd(l,0.0-ev.zyx))\n\t));\n}\n\nvoid fire(inout bit3d_Ray ray, int firstPortal) {\n\tray.coord.position = ray.origin;\n\tvec3 d = normalize(ray.direction);\n\tbit3d_coordinate coord = ray.coord;\n\tcoord.position = ray.origin;\n\tcoord.portal = firstPortal;\n\tbit3d_shape shape = ray.target;\n\tray.hit = false;\n\tray.iters = 0;\n\tray.dist = 0.0;\n\tray.inside = true;\n\tshape.portal = firstPortal;\n\tray.maxIterations = max(ray.maxIterations, 256);\n\twhile (ray.iters < ray.maxIterations && ray.dist < length(ray.direction)) {\n\t\tray.iters += 1;\n\t\tfloat zh = shape.surface;\n\t\tbool kh = shape.stepk;\n\t\tint pl = shape.portal;\n\t\tscene(shape, coord);\n\t if (ray.dist > edge) ray.inside = false;\n\t \tif (shape.surface <= edge && shape.portal == coord.portal) {\n\t\t \tray.hit = true;\n\t\t \tray.normal = bit3d_normal(coord);\n\t\t \tbreak;\n\t\t }\n\t\tfloat hy = max(shape.surface,0.0);\n\t\tif (kh) {hy = 0.075;}\n\t\tcoord.position += d*hy;\n\t \tcoord.portal = shape.portal;\n\t\tray.dist += hy;\n\t}\n\tray.target = shape;\n\tray.coord = coord;\n}\n\nint unroll(int i) {\n    float maxf = float(i);\n    maxf = min(maxf*(iFrameRate/30.0), 1.0);\n    return int(maxf);\n}\n\nbit3d_Ray rayof(vec3 o, vec3 t, int mi) {\n\tbit3d_Ray r;\n\tr.origin = o;\n\tr.direction = t;\n\tr.maxIterations = unroll(8);\n\treturn r;\n}\n\nvec3 LightPosition(bit3d_Ray r) {\n    bit3d_Ray rayh = rayof(vec3(0.0), vec3(vec2(.0), 0.25)*1.0, 4);\n    fire(rayh, 0);\n    vec3 v = vec3(0.0);\n    if (rayh.hit) {\n        v = r.coord.position-r.normal*0.02;\n    }\n    return v;\n}\n\nvec4 materialColor(bit3d_Ray ray) {\n\tvec3 lightpos = LightPosition(ray);\n\tvec4 m = vec4(0.0);\n\tif (ray.hit) {\n\t\tbit3d_shape target = ray.target;\n\t\tvec3 vn = normalize(ray.direction);\n\t\tvec3 im = lightpos;\n\t\tvec3 vm = normalize(ray.coord.position-im);\n\t\tvec3 vi = normalize(vm-im);\n\t\tvec3 h = normalize(ray.coord.position-lightpos);\n\t\tbit3d_Ray hray = rayof(ray.coord.position-h*edge*2.,h*(length(ray.direction)-ray.dist),ray.maxIterations-ray.iters);\n\t\tfloat byshade = 1.0;\n\t\tfloat diffuse = dot(ray.normal, vi)*byshade;\n\t\tdiffuse = pow(clamp(diffuse+target.ambientOcclusion, target.ambientOcclusion, 1.0),1.0);\n\t\tfloat specm = pow(max(dot(vi, ray.normal),0.0),target.specPower);\n\t\tm.a = clamp(1.0-(pow(float(ray.iters)/float(ray.maxIterations),0.2)*pow(distance(ray.coord.position,ray.origin)/length(ray.direction)*24.0,0.01)),0.0,1.0);\n\t\tm.a *= 1.0-(ray.dist/length(ray.direction));\n\t\tm.rgb = mix(target.ambient+mix(target.diffuse*diffuse,target.diffuse+target.specular,specm),target.glowcolor, target.glow*(1.0-diffuse));\n\t}\n\tm.rgb = clamp(m.rgb, 0.0, 1.0);\n\treturn m;\n}\n\nvoid blend(inout vec4 fragColor, vec4 c) {\n\tfragColor.rgb = mix(fragColor.rgb, c.rgb, c.a);\n\tfragColor.a = max(fragColor.a, c.a);\n}\n\nvoid blend(\n\tsampler2D sampler,\n    vec2 fragCoord,\n    inout vec4 fragColor,\n\tvec2 origin,\n\tvec2 size,\n\tfloat rotation,\n\tfloat alpha\n) {\n vec2 c = fragCoord.xy-origin;\n c /= size;\n rotate(c, rotation);\n c += 0.5;\n if (c.x>= 0.0 && c.y >= 0.0 && c.x < 1.0 && c.y < 1.0) {\n \tvec4 t = texture(sampler, c);\n \tt.a *= alpha;\n \tblend(fragColor, t);\n }\n}\n\nvoid blend(inout vec4 fragColor, bit3d_Ray ray) {\n\tvec4 color = materialColor(ray);\n\tbit3d_Ray refl = ray;\n\tint iei = ray.iters;\n\twhile (iei > 0) {\n\t\tfloat rh = refl.target.reflection;\n\t\tint iters = refl.iters;\n\t\tif ((!ray.hit) || rh <= 0.0) break;\n\t\tfloat gz = length(refl.direction)-refl.dist;\n\t\trefl.origin = refl.coord.position;\n\t\trefl.direction = reflect(normalize(refl.direction), refl.normal)*gz;\n\t\trefl.maxIterations = ray.maxIterations;\n\t\trefl.origin += normalize(refl.direction)*(edge+shading);\n\t\tfire(refl, refl.coord.portal);\n\t\tiei -= iters;\n\t\tvec4 c2 = materialColor(refl);\n\t\tcolor.rgb = mix(color.rgb, c2.rgb, rh);\n\t\tcolor.a = mix(color.a,color.a*c2.a,rh);\n\t}\n\tblend(fragColor, color);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n    vec3 b = vec3(0.,0.,1.);\n    vec3 o = vec3(0.0);\n    vec3 unv = normalize(rd)*64.0;\n    rotate(unv, vec3(direction(b),0.0));\n    bit3d_Ray ray = rayof(o, unv, 32);\n    fire(ray, 0);\n    vec4 c = vec4(vec3(0.0),1.0);\n    blend(c, ray);\n    vec3 m = mix(vec3(0.0), c.rgb, c.a);\n\tfragColor = vec4(m,1.0);\n}\n\nvoid mainDepth( out float fragDepth, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy - iResolution.xy / 2.0;\n    uv /= max(iResolution.x,iResolution.y);\n    vec2 uv2 = fragCoord.xy/iResolution.xy;\n    vec3 b = vec3(0.,0.,1.);\n    vec3 o = vec3(0.0);\n    vec3 sph = spherical(uv*180.0);\n    vec3 unv = vec3(sph)*12.0;\n    rotate(unv, vec3(direction(b),0.0));\n    bit3d_Ray ray = rayof(o, unv, 8);\n    fire(ray, 0);\n    fragDepth = (ray.dist/length(ray.direction))*(float(ray.iters)/float(ray.maxIterations));\n}\n\nvec3 mainLayer( in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy - iResolution.xy / 2.0;\n    uv /= max(iResolution.x,iResolution.y);\n    vec2 uv2 = fragCoord.xy/iResolution.xy;\n    vec2 mxy = iMouse.xy-iResolution.xy/2.0;\n    mxy /= max(iResolution.x,iResolution.y);\n    vec3 b = vec3(-mxy,0.6);\n    vec3 o = vec3(0.0);\n    vec3 sph = spherical(uv*180.0);\n    vec3 unv = vec3(uv,0.4)*32.0;\n    rotate(unv, vec3(direction(b).yx,0.0));\n    bit3d_Ray ray = rayof(o, unv, 4);\n    fire(ray, 0);\n    vec4 c = vec4(texture(iChannel1, uv2).rgb,1.0);\n    blend(c, ray);\n    if (ray.inside) {\n        blend(c, vec4(1.0));\n    }\n\tvec3 m = mix(vec3(1.0), c.rgb, c.a);\n\treturn m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 middle = mainLayer(fragCoord);\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec4 t = textureLod(iChannel0, vec2(uv.x, 0.), 0.0);\n    vec4 t2 = textureLod(iChannel0, uv, 0.0);\n    if (abs(uv.y-t.a) <= 0.01) {\n        middle = t2.rba;\n    }\n\tfragColor = vec4(middle,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec4 ir = vec4(\n        texture(iChannel0, vec2(uv.x,0.0)).r,\n        texture(iChannel0, vec2(uv.x,0.25)).r,\n        texture(iChannel0, vec2(uv.x,0.5)).r,\n        texture(iChannel0, vec2(uv.x,0.75)).r\n    );\n    if (fragCoord.y > 1.0) {\n        ir = texture(iChannel1,uv-vec2(0,1.0/iResolution.y));\n    }\n    fragColor = ir;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 7909,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/feexofficial/skrillex-voltage-feex-remix"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}