{
    "Shader": {
        "info": {
            "date": "1462313426",
            "description": "Couldn't Resist",
            "flags": 112,
            "hasliked": 0,
            "id": "4dGSzR",
            "likes": 2,
            "name": "Couldn't Resist",
            "published": 3,
            "tags": [
                "couldntresist"
            ],
            "usePreview": 0,
            "username": "vox",
            "viewed": 597
        },
        "renderpass": [
            {
                "code": "#define t2D(o) texture(iChannel0, uv-o/res)\n\n#define plane(p, n) 1. - abs(dot(p, n))*res.y\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS .001\n\n#define time ((saw(float(__LINE__))*.001+1.0)*iTime)\n#define saw(x) (acos(cos(x))/PI)\n#define stair floor\n#define jag fract\n\nfloat cross( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\n// given a point p and a quad defined by four points {a,b,c,d}, return the bilinear\n// coordinates of p in the quad. Returns (-1,-1) if the point is outside of the quad.\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = cross( g, f );\n    float k1 = cross( e, f ) + cross( h, g );\n    float k0 = cross( h, e );\n    \n    float w = k1*k1 - 4.0*k0*k2;\n\n    w = sqrt(abs( w ));\n    \n    float v1 = ((-k1 - w)/(2.0*k2));\n    float v2 = ((-k1 + w)/(2.0*k2));\n    float u1 = ((h.x - f.x*v1)/(e.x + g.x*v1));\n    float u2 = ((h.x - f.x*v2)/(e.x + g.x*v2));\n    bool  b1a = v1>0.0 && v1<1.0;\n    bool  b1b = u1>0.0 && u1<1.0;\n    bool  b2a = v2>0.0 && v2<1.0;\n    bool  b2b = u2>0.0 && u2<1.0;\n    \n\n    vec2 res = vec2(min(abs(u1), abs(u2)), min(abs(v1), abs(v2)));\n    return saw(res*1.0*PI);\n}\n\n\nvec2 SinCos( const in float x )\n{\n\treturn vec2(sin(x), cos(x));\n}\nvec3 RotateZ( const in vec3 vPos, const in vec2 vSinCos )\n{\n\treturn vec3( vSinCos.y * vPos.x + vSinCos.x * vPos.y, -vSinCos.x * vPos.x + vSinCos.y * vPos.y, vPos.z);\n}\n      \nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n\treturn RotateZ( vPos, SinCos(fAngle) );\n}\nvec2 RotateZ( const in vec2 vPos, const in float fAngle )\n{\n\treturn RotateZ( vec3(vPos, 0.0), SinCos(fAngle) ).xy;\n}\nmat4 RotateZ( const in mat4 vPos, const in float fAngle )\n{\n\treturn mat4(RotateZ( vec3(vPos[0].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[1].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[2].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[3].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0);\n}\nmat4 translate( const in mat4 vPos, vec2 offset )\n{\n\treturn mat4(vPos[0].xy+offset, 0.0, 0.0,\n                vPos[1].xy+offset, 0.0, 0.0,\n                vPos[2].xy+offset, 0.0, 0.0,\n                vPos[3].xy+offset, 0.0, 0.0);\n} \nmat4 scale( const in mat4 vPos, vec2 factor )\n{\n\treturn mat4(vPos[0].xy*factor, 0.0, 0.0,\n                vPos[1].xy*factor, 0.0, 0.0,\n                vPos[2].xy*factor, 0.0, 0.0,\n                vPos[3].xy*factor, 0.0, 0.0);\n} \nvec2 tree(vec2 uv)\n{\n    \n    uv = uv*2.0-1.0;\n    \n    mat4 square = mat4(EPS, EPS, 0.0, 0.0,\n                       1.0-EPS, EPS, 0.0, 0.0,\n                       1.0-EPS, 1.0-EPS, 0.0, 0.0,\n                       0.0, 1.0-EPS, 0.0, 0.0);\n    \n    float size =  .5;\n    \n    square = translate(square, vec2(-.5));\n    square = scale(square, vec2(2.0));\n    square = RotateZ(square, PI/6.0+sin(iTime)*.1);\n    square = scale(square, vec2(.75));\n    square = translate(square, vec2(.5, 0.0));\n    \n    \n    vec2 uv1 = invBilinear(uv, square[0].xy, square[1].xy, square[2].xy, square[3].xy);\n    square = scale(square, vec2(-1.0, 1.0));\n    vec2 uv2 = invBilinear(uv, square[0].xy, square[1].xy, square[2].xy, square[3].xy);\n    if(uv.x >= 0.0)\n    \treturn uv1;\n    if(uv.x < 0.0)\n    \treturn uv2;\n    else\n    \treturn uv*.5+.5;\n}\n\n\nfloat square(vec2 uv, float iteration)\n{\n\tif(abs(abs(saw(uv.x*(1.5+sin(iTime*.654321))*PI+iTime*.7654321)*2.0-1.0)-abs(uv.y)) < .5)\n\t\treturn (1.0-abs(abs(saw(uv.x*(1.5+sin(iTime*.654321))*PI+iTime*.7654321)*2.0-1.0)-abs(uv.y))/.5)*uv.x;\n\telse\n\t\treturn (0.0);\n}\n\n\nvec2 spiral(vec2 uv)\n{\n    float turns = 4.0+saw(time/4.0)*4.0;\n    float r = pow(log(length(uv)+1.), .75);\n    float theta = atan(uv.y, uv.x)*turns-r*PI;\n    return vec2(saw(r*PI+theta/turns+iTime*.2), saw(theta/turns+iTime*.1));\n}\n\nvec3 phase(float map)\n{\n    return vec3(saw(map),\n                saw(4.0*PI/3.0+map),\n                saw(2.0*PI/3.0+map));\n}\n\nfloat get_max(){\n  // find max offset (there is probably a better way)\n  float jmax = 0.0;\n  float jmaxf=0.0;\n  float jf=0.0;\n  float ja;\n  for (int j=0;j<200;j++){\n    jf = jf+0.005;\n    ja = texture( iChannel0, vec2(jf,0.75)).x;\n    if ( ja>jmaxf) {jmax = jf;jmaxf = ja;}\n  }\n  return jmax;\n}\n\nfloat wavelet( vec2 uv )\n{\n  float px = 2.0*(uv.x-0.5);\n  float py = 2.0*(uv.y-0.5);\n\n  float dx = uv.x;\n  float dy = uv.y;\n\n  // alternative mappings\n  dx = abs(uv.x-0.5)*3.0;\n  //dx =1.0*atan(abs(py),px)/(3.14159*2.0);\n  //dy =2.0*sqrt( px*px + py*py );\n\t\n  const float pi2 = 3.14159*2.0;\n\n  // my wavelet \n  //float width = 1.0-dy; \n  //float width = (1.0-sqrt(dy)); // focus a little more on higher frequencies\n  float width = 1.0-(pow(dy,(1.0/4.0) )); // focus a lot more on higher frequencies\n  const float nperiods = 4.0; //num full periods in wavelet\n  const int numsteps = 256; // more than 100 crashes nvidia windows (would love to know why)\n  const float stepsize = 1.0/float(numsteps);\n  \n  float accr = 0.0;\n\n  float si_max=0.0;\n#ifdef OFFSET_ON\n    si_max=get_max();\n#endif\n    \n  // x is in 'wavelet packet space'\n  for (float x=-1.0; x<1.0; x+=stepsize){\n\t\n\t// the wave in the wavelet \n    float yr = sin((dx+x*nperiods*pi2)); \n    \n    // get a sample - center at uv.x, offset by width*x\n    float si = dx + width*x;\n\n      si+=si_max;\n\n\t  if (si>0.0 || si<1.0){\n        \n\t\t// take sample and scale it to -1.0 -> +1.0\n\t\tfloat s = 2.0*( texture( iChannel1, vec2(si,0.75)).x - 0.5 + (12.5/256.0) ); \n         \t\n\t\t// multiply sample with the wave in the wavelet\n\t    float sr=yr*s;\n         \n\t    // apply packet 'window'\n        float w = 1.0-abs(x);\n\t    sr*=w;\n\n\t\t// accumulate\n        accr+=sr;\n \t  }\n  }\n\n  float y=accr*accr/PI; //; //0.0*abs(accr)/accn;\n \n  return clamp(y, 0.0, 1.0)*saw(y+time+py*PI)*PI;\n\n \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 res = iResolution.xy;\n    vec2 uv = fragCoord / res;\n    vec2 p = fragCoord / res.y;\n    vec3 o = vec3(1., -1., 0.);\n    vec2 uv0 = uv.xy;\n    \n    float map = 0.0;\n    \n    float lambda = 4.0;\n    \n    float scale = 2.0*PI;\n\tconst int max_iterations =16;\n    \n    vec2 dirs[4];\n    dirs[0] = o.xz; dirs[1] = o.yz; dirs[2] = o.zx; dirs[3] = o.zy;\n    \n    // current position\n    vec2 pos = t2D(o.zz).rg;\n    \n    float c, w = 0.;\n    \n    // cell gradient\n\tc = 2. * length(p-pos/res.y);\n    \n    // cell walls\n    for(int i=0; i<4; i++) {\n        vec2 iPos = t2D(dirs[i]).rg;\n        if(pos!=iPos)\n            w = max(w, plane(p-mix(pos, iPos, .5)/res.y, normalize(pos-iPos)));\n    }\n    \n   \tuv = (p-pos/res.y)*.125+.125;\n    \n    \n    for(int i = 0; i <= max_iterations; i++)\n    {\n    \tfloat iteration = PI*(float(i)/(float(max_iterations) ));\n        scale = 2.0;//pow(amplitude, length(uv0*2.0-1.0)/sqrt(2.0)*sin(time*GR/2.0+float(i)-1.0));\n        //if(i == 0) uv.xy = (uv.xy*2.0-1.0)*vec2(iResolution.x/iResolution.y, 1.0)*.5+.5;\n        //    uv.xy += .125*vec2(sin(time/PI), cos(time/2.0*GR));\n        uv.xy = tree(uv.xy);\n        map += square(uv.xy, float(i));\n    }\n    \n    float map2 = 0.0;\n    /*\n    noise = 1.0;\n    for(int i = 0; i < max_iterations; i++)\n    {\n        uv.xy *= scale;\n        uv.xy -= scale/2.0;\n        if(i == 0)\n            uv.x *= iResolution.x/iResolution.y;\n        uv.xy = normalize(uv.xy)*log(length(uv.xy)+1.0);\n        uv = spiral(uv);\n        map2 += uv.g*noise;\n        \n        noise *= clamp(.95-fwidth(map2), 0.0, 1.0);\n    }\n    */\n    \n    \n    \n    \n    fragColor.rg = uv.rg;//saw(uv.zw);//saw(uv.zw*PI);\n    \n    w = wavelet(uv.xy);\n    map += w;\n    \n    fragColor.b = 0.0;\n    fragColor.a = 1.0;\n    //fragColor = vec4(noise);\n    fragColor.rgb = w*phase(map+time);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 2947,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/desertdwellers/crossing-beyond-govinda-remix"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float Key_R = 82.5 / 256.;\nconst float Key_X = 88.5 / 256.;\nconst float Key_Space = 32.5 / 256.;\n\n#define t2D(o) texture(iChannel0, uv-o/res)\n#define isKeyHeld(key) texture(iChannel3, vec2(key, .2)).r > 0.\n#define dataAt(x) texture(iChannel0, vec2(x+.5, .5)/res)\n\n// hash without sine\n// https://www.shadertoy.com/view/4djSRW\n#define MOD3 vec3(443.8975,397.2973, 491.1871)\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 res = iResolution.xy;\n    vec2 fc = fragCoord;\n\tvec2 uv = fc / res;\n    vec3 o = vec3(1., -1., 0.);\n    \n    vec2 dirs[8];\n    dirs[0] = o.xz; dirs[1] = o.yz; dirs[2] = o.zx; dirs[3] = o.zy;\n    dirs[4] = o.xx; dirs[5] = o.yx; dirs[6] = o.xy; dirs[7] = o.yy;\n    \n    vec2 pos = t2D(o.zz).rg;\n    vec2 sPos = dataAt(2.).ba;\n    vec2 mOld = dataAt(0.).ba;\n    float isMHeld = dataAt(1.).b;\n    \n    for(int i=0; i<8; i++) {\n        // neighbor's stored position\n        vec2 iPos = t2D(dirs[i]).rg;\n        \n        // if circle produced by neighbor is less than the current one, take its position\n        if(length(fc-iPos) < length(fc-pos))\n            pos = iPos;\n    }\n    \n    if(iMouse.z>0.) {\n        // cell position under mouse\n        vec2 posUnderMouse = texture(iChannel0, iMouse.xy/res).rg;\n        \n        // remove cell\n        if(isKeyHeld(Key_X)) {\n\t\t\tif(pos==posUnderMouse)\n                pos = vec2(-10000.);\n        }\n        else\n            // move cell\n            if(isKeyHeld(Key_Space)) {\n                // mouse button is held\n                if(isMHeld==1.) {\n                    // update cell position\n                    if(sPos==pos)\n                    \tpos += iMouse.xy - mOld;\n                    \n                    // update temporary position\n                    sPos += iMouse.xy - mOld;\n                    \n                    // stamp new position into buffer (for faster movement)\n                    if(length(fc-sPos)<length(fc-pos))\n                        pos = sPos;\n                }\n                // mouse button is clicked but not held\n                else\n                    // set temporary position when mouse is first clicked\n                \tsPos = posUnderMouse;\n            }\n        \telse\n                // add cell\n                if(length(fc-iMouse.xy)<length(fc-pos))\n                   pos = iMouse.xy;\n            \n\t\tisMHeld = 1.;\n    }\n    else\n        isMHeld = 0.;\n    \n    mOld = iMouse.xy;\n        \n    // initialize values first frame\n    if(iFrame==0) {\n        if(pow(length(fc/res.y-vec2(.5*res.x/res.y, 0.)), 32.)>hash12(uv))\n            pos = fc;\n        else\n            pos = vec2(-10000.);\n        isMHeld = 0.;\n    }\n    \n    // clear stored positions when R is pressed\n\tif(isKeyHeld(Key_R))\n        pos = vec2(-10000.);\n    \n    // save cell position(s)\n    fragColor.rg = pos;\n    \n    // save old mouse position\n    if(floor(fc)==o.zz)\n        fragColor.ba = mOld;\n    else\n        // save button held state\n    \tif(floor(fc)==o.xz)\n            fragColor.b = isMHeld;\n        else\n            // save temporary, moving cell position\n            if(floor(fc)==vec2(2., 0.))\n                fragColor.ba = sPos;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}