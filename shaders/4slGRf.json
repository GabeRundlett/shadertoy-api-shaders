{
    "Shader": {
        "info": {
            "date": "1375932572",
            "description": "Navigating on the surface of the moon.",
            "flags": 0,
            "hasliked": 0,
            "id": "4slGRf",
            "likes": 50,
            "name": "Moon Surface",
            "published": 3,
            "tags": [
                "raymarching",
                "terrain",
                "moon"
            ],
            "usePreview": 0,
            "username": "4rknova",
            "viewed": 4063
        },
        "renderpass": [
            {
                "code": "// by Nikos Papadopoulos, 4rknova / 2013\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define EPS\t\t.001\n#define PI\t\t3.14159265359\n#define RADIAN\t180. / PI\n#define SPEED\tiTime * 1.2\n\nfloat hash(in float n) { return fract(sin(n)*43758.5453123); }\n\n\nfloat hash(vec2 p)\n{\n    return fract(sin(dot(p,vec2(127.1,311.7))) * 43758.5453123);\n}\n\nfloat noise(vec2 p)\n{\n    vec2 i = floor(p), f = fract(p); \n\tf *= f*(3.-2.*f);\n    \n    vec2 c = vec2(0,1);\n    \n    return mix(mix(hash(i + c.xx), \n                   hash(i + c.yx), f.x),\n               mix(hash(i + c.xy), \n                   hash(i + c.yy), f.x), f.y);\n}\n\nfloat fbm(in vec2 p)\n{\n\treturn\t.5000 * noise(p)\n\t\t   +.2500 * noise(p * 2.)\n\t\t   +.1250 * noise(p * 4.)\n\t\t   +.0625 * noise(p * 8.);\n}\n\nfloat dst(vec3 p)\n{\n\treturn dot(vec3(p.x, p.y + .45 * fbm(p.zx), p.z), vec3(0.,1.,0.));\t\n}\n\nvec3 nrm(vec3 p, float d)\n{\n\treturn normalize(\n\t\t\tvec3(dst(vec3(p.x + EPS, p.y, p.z)),\n    \t\t\t dst(vec3(p.x, p.y + EPS, p.z)),\n    \t\t\t dst(vec3(p.x, p.y, p.z + EPS))) - d);\n}\n\nbool rmarch(vec3 ro, vec3 rd, out vec3 p, out vec3 n)\n{\n\tp = ro;\n\tvec3 pos = p;\n\tfloat d = 1.;\n\n\tfor (int i = 0; i < 64; i++) {\n\t\td = dst(pos);\n\n\t\tif (d < EPS) {\n\t\t\tp = pos;\n\t\t\tbreak;\n\t\t}\n\t\tpos += d * rd;\n\t}\n\t\n\tn = nrm(p, d);\n\treturn d < EPS;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 uvn = (2. * uv - 1.)\n\t\t\t * vec2(iResolution.x / iResolution.y, 1.);\n\t\n\tif (abs(EPS + uvn.y) >= .7) { \n\t\tfragColor = vec4(vec3(0.),1.);\n\t\treturn;\n\t}\n\n\tvec3 cu = vec3(0.,1.,0.);\n\tvec3 cp = vec3(0., 1.1 + fbm(vec2(iTime)) * .2, SPEED);\n\tvec3 ct = vec3(1.5 * sin(iTime), \n\t\t\t\t   -8. + cos(iTime) + fbm(cp.xz) * 5., 15. + SPEED);\n\t\t\n\tvec3 ro = cp,\n\t\t rd = normalize(vec3(uvn, 1. / tan(30. * RADIAN)));\n\t\n\tvec3 cd = ct - cp,\n\t\t rz = normalize(cd),\n\t\t rx = normalize(cross(rz, cu)),\n\t\t ry = normalize(cross(rx, rz));\n\n\trd = normalize(mat3(rx, ry, rz) * rd);\n\n\tvec3 sp, sn;\n\tvec3 col = (rmarch(ro, rd, sp, sn) ?\n\t\t  vec3(.6) * dot(sn, normalize(vec3(cp.x, cp.y + .5, cp.z) - sp))\n\t\t: vec3(0.));\n\t\n    float noise = hash((hash(uv.x) + uv.y) * iTime) * .25;\n\tcol += noise;\n\tcol *= 1.9 * smoothstep(length(uv * .5 - .25), .8, .4);\n\tcol *= smoothstep(EPS, 3.5, iTime);\n\tfragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}