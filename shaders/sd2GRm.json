{
    "Shader": {
        "info": {
            "date": "1617267117",
            "description": "Twisting space with quaternions (& performing the Dirac belt trick).\n\nMouse to rotate.",
            "flags": 0,
            "hasliked": 0,
            "id": "sd2GRm",
            "likes": 31,
            "name": "Quaternion Twister",
            "published": 3,
            "tags": [
                "twister",
                "quaternion",
                "interpolation"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 820
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Quaternion Twister, Matthew Arcus, mla, 2020\n//\n// Divide space into a series of concentric spheres, centred on the\n// origin, apply to each sphere a rotation that varies smoothly with\n// radial distance. This defines a path in the space of unit quaternions,\n// which is the hypersphere. Now vary the path smoothly over time,\n// giving a smooth bijective distortion of space with no discontinuities.\n//\n// In the code, vec4(x,y,z,w) represents quaternion w+ix+jy+kz, and\n// we go from no rotation (w=1) at r >= 1, to a steady rotation in the\n// xw plane at the origin. The path in between is mapped to a circular\n// path on the hypersphere (in the xyw subspace in fact) giving a smooth\n// transition of paths as the central rotation varies & gives a nice\n// demonstration of \"Dirac's belt trick\".\n//\n// Useful video from Jason Hise: https://youtu.be/zAvaCPmgdf0\n// Some of the maths: https://arxiv.org/abs/1001.1778\n//\n////////////////////////////////////////////////////////////////////////////////\n\n#if HW_PERFORMANCE==0\nconst int AA = 1;\n#else\nconst int AA = 2;\n#endif\n\nint Q = 3, R = 5; // Symmetry group\nfloat lradius = 0.025,pradius = 0.2; // Line and point radius\nfloat PI = 3.1415927;\n\nfloat eyedist = 2.0;  // Eye is at (0,0,eyedist);\nvec3 light = vec3(0,1,2); //Position of light\n\n// Raymarching configuration.\nint maxsteps = 200;\nfloat precis = 1e-4; \nfloat lfactor = 0.2; // \"Lipschitz adjustment factor\"\n\n// R3 rotation of p with quaternion q\nvec3 qrot(vec3 p, vec4 q) {\n  return p + 2.0*cross(q.xyz,cross(q.xyz,p)+q.w*p);\n}\n\nfloat segment(vec3 p, vec3 q, vec3 r) {\n  p -= q; r -= q; // q is origin\n  float h = clamp(dot(p,r)/dot(r,r),0.0,1.0);\n  return length(p-h*r);\n}\n\nvec3 A,B,C,a,b,c;\n\nvoid init(int Q, int R) {\n  // Setup folding planes\n  //float p = PI/float(P);\n  float q = PI/float(Q);\n  float r = PI/float(R);\n  A = vec3(1,0,0);\n  // A.B = -cos(p)\n  //B = vec3(-cos(p),sin(p),0);\n  B = vec3(0,1,0);\n  // A.C = -cos(r)\n  float x = -cos(r);\n  // B.C = -cos(q) = cos(p)cos(r) + y sin(p)\n  float y = -cos(q);\n  // |C| = 1\n  float z = sqrt(1.0-x*x-y*y);\n  C = vec3(x,y,z);\n  a = normalize(cross(B,C));\n  b = normalize(cross(C,A));\n  c = normalize(cross(A,B));\n}\n\nint NFOLDS = 8;\nvec3 fold(vec3 pos) {\n  // We want to know the number of actual reflections made\n  // so keep track of that in flips.\n  for (int i = 0; i < NFOLDS; i++) {\n    pos.xy = abs(pos.xy);\n    float k = dot(pos,C);\n    if (k > 0.0) break;\n    pos -= 2.0*k*C;\n  }\n  return pos;\n}\n\nfloat de(vec3 p, out int type) {\n  float t = 0.2*iTime;\n  vec4 quat = vec4(sin(PI*t),0,0,cos(PI*t)); // Central rotation\n\n  // Interpolation etc. done in quaternion space ie. on the hypersphere\n  float s = max(0.0,1.0-(length(p)-pradius)/(1.0-pradius)); // Distance to central sphere\n  s = 0.5-0.5*cos(PI*s); // Circle distance to line distance\n  quat = mix(vec4(0,0,0,1),quat,s); // Interpolate\n  quat.y = sqrt(max(0.0,(1.0-dot(quat,quat)))); // Project to sphere along y\n  if (mod(t,4.0) > 2.0) quat.y = -quat.y; // Change hemisphere\n  p = qrot(p,quat); // Apply rotation\n  vec3 p0 = p;\n  p = fold(p);\n\n  float d = 1e8, d0;\n  d0 = segment(p,vec3(0),a)-lradius;\n  if (d0 < d) { type = 1; d = d0; }\n  d0 = segment(p,vec3(0),b)-lradius;\n  if (d0 < d) { type = 2; d = d0; }\n  d0 = segment(p,vec3(0),c)-lradius;\n  if (d0 < d) { type = 3; d = d0; }\n  d0 = length(p)-pradius;\n  if (d0 < d) { type = 4; d = d0; }\n  d *= lfactor; // Attenuate distance estimate\n  d = max(d,length(p0)-1.1);\n  return d;\n}\n\nfloat de(vec3 p) {\n  int type;\n  return de(p,type);\n}\n\nfloat maxdist = 10.0;\nfloat march(vec3 q, vec3 r) {\n  float t = 0.0;\n\n  // Start from intersection with sphere.\n  float R = 1.0+lradius;\n  float B = dot(q,r), C = dot(q,q)-R*R;\n  float D = B*B - C;\n  // No intersection, so give up.\n  if (D < 0.0) return -1.0;\n  D = sqrt(D);\n  float t0 = -B-D;\n  maxdist = -B+D; // nice idea from iq\n  // If t0 < 0, then we are inside sphere\n  if (t0 > 0.0) t = t0;\n  \n  for (int i = 0; i < maxsteps; i++) {\n    vec3 p = q+t*r;\n    float d = de(p);\n    if (abs(d) < precis) return t; // Close enough to the surface.\n    t += d;\n    if (t > maxdist) break;\n  }\n  return -1.0;\n}\n\n// Get the normal of the surface at point p.\nvec3 getnormal(vec3 p) {\n  float eps = 0.001;\n  vec2 e = vec2(eps,0);\n  return normalize(vec3(de(p + e.xyy) - de(p - e.xyy),\n                        de(p + e.yxy) - de(p - e.yxy),\n                        de(p + e.yyx) - de(p - e.yyx)));\n}\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\n// Rotate according to mouse position\nvec3 transformframe(vec3 p) {\n  if (iMouse.x > 0.0) {\n    // Full range of rotation across the screen.\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  p.zx = rotate(p.zx,0.25*PI);\n  p.xy = rotate(p.xy,0.25*PI);\n  return p;\n}\n\nvec3 getbasecolor(int type) {\n  if (type == 1) return vec3(1,1,0);\n  if (type == 2) return vec3(0,1,0);\n  if (type == 3) return vec3(0,0,1);\n  if (type == 4) return vec3(1,0,0);\n  return vec3(0.75,1,0.75);\n}\n\nvec3 getbackground(vec3 r) {\n  return mix(vec3(1),pow(r,vec3(2)),0.5); // Colourful fun\n  return vec3(0,0,0.1); // The more sober option.\n}\n\nvec3 raycolor(vec3 q, vec3 r) {\n  float t = march(q,r);\n  if (t < 0.0) return getbackground(r);\n  // Get the surface point that has been hit,\n  vec3 p = q+t*r;\n  // and the normal at that point.\n  vec3 normal = getnormal(p);\n\n  // Call de again to find what we've hit.\n  int type;\n  de(p,type);\n  \n  // Apply lighting. This is a basic \"Lambertian\" model.\n  vec3 lightdir = normalize(light-p);\n  vec3 color = mix(vec3(1),getbasecolor(type),0.6);\n  float ambient = 0.3;\n  float diffuse = 0.7*clamp(dot(normal,lightdir),0.0,1.0);\n  color *= ambient+ diffuse;\n  return color;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n  init(Q,R);\n  maxdist = eyedist + 1.0;\n  vec3 eye = vec3(0,0,eyedist);\n  eye = transformframe(eye);\n  light = transformframe(light);\n  vec3 col = vec3(0);\n  for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n      vec2 z = (2.0*(fragCoord+vec2(i,j)/float(AA))-iResolution.xy)/iResolution.y;\n      vec3 ray = vec3(z,-2);\n      ray = transformframe(ray);\n      ray = normalize(ray);\n      col += raycolor(eye,ray);\n    }\n  }\n  col /= float(AA*AA);\n  col = pow(col,vec3(0.4545)); // Gamma\n  fragColor = vec4(col,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}