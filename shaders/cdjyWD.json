{
    "Shader": {
        "info": {
            "date": "1687952119",
            "description": "Code is a total mess, inspired by the last few episodes of https://www.twitch.tv/highrollersdnd",
            "flags": 32,
            "hasliked": 0,
            "id": "cdjyWD",
            "likes": 18,
            "name": "Hadar",
            "published": 3,
            "tags": [
                "space",
                "planet",
                "volumetric",
                "glow",
                "stars",
                "nebula",
                "flare"
            ],
            "usePreview": 0,
            "username": "Dragonpeak",
            "viewed": 537
        },
        "renderpass": [
            {
                "code": "vec3 toneMap(vec3 x) \n{\n    //implementation from https://www.shadertoy.com/view/WdjSW3\n    const vec3 L_white = vec3(4.0);\n    return (x * (1.0 + x / (L_white * L_white))) / (1.0 + x);\n}\nfloat flare(vec2 p, vec2 flarePos)\n{// simple lens flare \n    vec2 op = p;\n    p-=flarePos;\n    float t = atan(p.y, p.x);\n\n    float col = 0.;\n    col += pow(1./length(p)*.02, 3.)-noise2D(vec2(t*16.,0.))*.08;\n    col += (1./length(p*vec2(.05,1.))*.05);\n    col += (1./length(p*vec2(1.,.1))*.02);\n    \n    col = max(pow(col, 4.),0.)*.1;\n    int ghosts = 4;\n    for(int i = -ghosts; i < ghosts; i++)\n    {\n        if(i==1)continue;\n        col += clamp(pow(1./distance(op*float(i), flarePos)*.1, 8.), 0., 1.);\n    }\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy/iResolution.xy);\n    vec2 screenPos = (fragCoord.xy/iResolution.x*2.-1.)+vec2(0,iResolution.y/iResolution.x)*.75;\n\n    vec4 col = textureLod(iChannel0, uv,0.);\n    col.y = textureLod(iChannel0, ((uv*2.-1.)*.995)*.5+.5,0.).y;\n    col.z = textureLod(iChannel0, ((uv*2.-1.)*.99)*.5+.5,0.).z;\n    const vec2 FLARE_POS = vec2(-.35,.14);\n    vec3 flareG = clamp(texture(iChannel0, FLARE_POS*.5+.5).xyz-.05, 0.001, 1.)*.1*vec3(1.,.1,.1);\n    \n    flareG = toneMap(flare(screenPos, FLARE_POS)*mix(flareG, flareG.xxx, .001));//scale flare colour by the point on the image it is over\n    col.xyz = toneMap(col.xyz*vec3(1.000,0.761,0.682));\n    col.xyz += clamp(flareG, vec3(0), vec3(1))*.9;\n    vec3 bloom = vec3(0);\n    for(int i = -BLUR_SAMPLES; i <= BLUR_SAMPLES; i++ )\n    {//y part of blur for bloom\n        bloom.xyz+=textureLod(iChannel1, (fragCoord+vec2(0,i*3))/iResolution.xy, 2.).xyz*gaussian(float(i)/float(BLUR_SAMPLES), 1., 0., .1);\n    }\n    bloom/=float(BLUR_SAMPLES*2);\n    col.xyz += toneMap(mix(bloom, bloom.xxx, .07))*.05;\n    col*=1.-length(uv*2.-1.)*.75;\n\n\n    fragColor = vec4(pow(col.xyz, vec3(1./2.2)),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const vec3 PLANET_POS = vec3(-.05,.25,.0);\nconst float PLANET_R = .08;\nconst vec3 PLANET2_POS = vec3(.26,.4,-.32);\nconst float PLANET2_R = .13;\nconst float FAR = 1.;\nconst vec3 CAMERA_POS = vec3(.2,.5, -0.2);\nconst vec3 CAMERA_DIR = vec3(.1,-1,.2); \nconst float FOCAL_LEN = .7;\nconst float RENDER_SCALE = .6;\nconst int BLUR_SAMPLES = 12;\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n//https://iquilezles.org/articles/distfunctions/\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\nstruct Ray\n{\n    vec3 origin;\n    vec3 dir;\n};\nfloat gaussian(float x, float a, float b, float c)\n{\n    return a*exp(-(pow(x-b,2.)/pow(2.*c,2.)));\n}\nRay constructViewRay(vec2 screen_pos, vec3 pos, vec3 look_dir, vec3 up, float len)\n{\n    Ray r = Ray(pos, vec3(0));\n    \n    vec3 side = cross(up, look_dir);\n    vec3 cam_up = cross(look_dir,side);\n    \n    r.dir = normalize(side*screen_pos.x+cam_up*screen_pos.y+look_dir*len);\n    \n    return r;\n}\nvec2 raySphere( Ray r, float ra)\n{\n    // edited from https://iquilezles.org/articles/intersectors\n    \n     float b = dot( r.origin, r.dir );\n     float c = dot( r.origin, r.origin ) - ra*ra;\n     float h = b*b - c;\n     if( h<0.0 ) return vec2(FAR);\n     h = sqrt( h );\n     return vec2( -b-h, -b+h );\n\n}\nvec3 screenShake(float t)\n{\n    return vec3(sin(t*27.12)*.001,sin(t*27.12+.863)*.001,-cos(t*27.12+.163)*.001)*.04*sin(t);\n}\nuvec2 pcg2d(uvec2 v)\n{\n    //from https://www.shadertoy.com/view/XlGcRh\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    return v;\n}\nuvec3 pcg3d(uvec3 v) \n{\n    //from https://www.shadertoy.com/view/XlGcRh\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    v ^= v >> 16u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    return v;\n}\nvec2 rand2D(vec2 v)\n{\n    return vec2(pcg2d(uvec2(v)))/float(0xffffffffu);\n}\nvec3 rand3D(vec3 v)\n{\n    return vec3(pcg3d(uvec3(v)))/float(0xffffffffu);\n}\n\nfloat voro3D(vec3 pos, out vec3 point)\n{\n    vec3 cell = floor(pos);\n    float dist = 99.;\n    for (int x = -1; x <= 1; x++)\n    {\n        for (int y = -1; y <= 1; y++)\n        {\n            for (int z = -1; z <= 1; z++)\n            {\n                vec3 pic = rand3D(abs(cell+vec3(x,y,z)))+cell+vec3(x,y,z);\n                float cd = dot(pos-pic, pos-pic);\n                point = (cd < dist) ? pic : point;\n                dist = min(dist, cd);\n            }\n        }\n    }\n    return (dist);\n}\nfloat voro2D(vec2 pos, out vec2 point)\n{\n    vec2 cell = floor(pos);\n    float dist = 99.;\n    for (int x = -1; x <= 1; x++)\n    {\n        for (int y = -1; y <= 1; y++)\n        {\n\n            vec2 pic = rand2D(abs(cell+vec2(x,y)))+cell+vec2(x,y);\n            float cd = dot(pos-pic, pos-pic);\n            point = (cd < dist) ? pic : point;\n            dist = min(dist, cd);\n            \n        }\n    }\n    return (dist);\n}\nfloat noise2D(vec2 p)\n{\n    vec2 ap = abs(p);\n    vec2 fr = fract(ap);\n    fr = fr * fr * (3. - 2. * fr);\n    \n    float a = rand2D(ap).x;\n    float b = rand2D(ap+vec2(1,0)).x;\n    float c = rand2D(ap+vec2(0,1)).x;\n    float d = rand2D(ap+vec2(1)).x;\n\n    float v = mix(mix(a,b, fr.x),mix(c,d,fr.x), fr.y);\n    \n    return v;\n}\nvec3 noise3D(vec3 p)\n{\n    vec3 ap = abs(p);\n    vec3 fr = fract(ap);\n    fr = fr * fr * (3. - 2. * fr);\n    \n    vec3 a = rand3D(ap);\n    vec3 b = rand3D(ap+vec3(1,0,0));\n    vec3 c = rand3D(ap+vec3(0,1,0));\n    vec3 d = rand3D(ap+vec3(1,1,0));\n    \n    vec3 e = rand3D(ap+vec3(0,0,1));\n    vec3 f = rand3D(ap+vec3(1,0,1));\n    vec3 g = rand3D(ap+vec3(0,1,1));\n    vec3 h = rand3D(ap+vec3(1,1,1));\n\n    vec3 v = mix(mix(mix(a,b, fr.x),mix(c,d,fr.x), fr.y), mix(mix(e,f, fr.x),mix(g,h,fr.x), fr.y), fr.z);\n    \n    return v;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\nconst float STEP_SIZE = .005;\nconst float LIGHT_FAR = .5;\nconst float LIGHT_STEP_SIZE = .15;\n//draw the nebula using mostly normal volumetric raymarching\nfloat nebulaeDens(vec3 pos)\n{//the density is based of a domain warped fbm voronoi noise, with the warping using standard value noise and varied over time\n    vec3 p;\n    float d = 0.;\n    float sc = 9.;\n    float am = 1.;\n    float lp = 1.-length(pos);\n    if(lp<0.)return 0.;\n    float t = .8*(max(sin(iTime*.02),0.)*(sin(iTime*.1)*3.+cos(iTime*1.)*.2)+iTime*.3)+211.;\n    pos += (noise3D(pos*4.-t*.01)*2.-1.)*.4;\n    for(int i = 0; i < 6; i++)\n    {\n        d+=pow(voro3D(pos*sc+float(i)*351.25+vec3(t)*sc*.01, p), 3.)*am;\n        if(d<.01)break;\n        am*=.9;\n        sc*=1.4;\n    }\n    d*=clamp(sdCapsule(pos, CAMERA_POS, CAMERA_POS*.3, .4), -1.,0.)+1.;\n    return max(pow(d*clamp(lp, 0., 1.), 4.)*2000.,0.);\n}\nfloat marchLight(Ray r)\n{//standard light marching\n    float d = .001;\n    float trans = 1.;\n    while(d < LIGHT_FAR)\n    {\n        d += LIGHT_STEP_SIZE;\n        vec3 pos = r.origin+r.dir*d;\n        float dens = nebulaeDens(pos)*LIGHT_STEP_SIZE;\n        trans*=exp(-dens);\n        if(trans<.5)\n        {\n            trans = 0.;break;\n        }\n    }\n    return trans;\n}\nvec4 march(Ray r)\n{//march the density, the middle of the nebulae also pushes and pulls on the light ray, with the strength varying over time. if we get to close to the \"event horizon\" then we colour it black and exit\n    float d = .001;\n    float trans = 1.;\n    vec3 col = vec3(0);\n    float far = min(FAR, raySphere(Ray(r.origin-PLANET_POS, r.dir), PLANET_R).x);//use planet 1 as our max dist if we hit it\n    while(d < far)\n    {\n        d += STEP_SIZE;\n        vec3 pos = r.origin+r.dir*d;\n        float dens = nebulaeDens(pos)*STEP_SIZE;\n        float lp = length(pos);\n        r.dir = normalize(r.dir+normalize(pos)*max(1./lp,0.)*(sin(iTime*.2)*.1*STEP_SIZE));\n        trans*=exp(-dens);\n        if(lp < .02)\n        {\n            trans = 0.;\n            col = vec3(0);\n            break;\n        }\n        if(dens > .01)\n        {\n            Ray lr = Ray(pos, normalize(-pos));\n            float pdist = raySphere(Ray(lr.origin-PLANET_POS, lr.dir), PLANET_R).x;\n            float light = (pdist<FAR) ? 0. : marchLight(lr)/(4.*(lp*lp));\n            col += (3.*vec3(1.,.01,.01)*max(0., light) + vec3(0,0,.1))*trans*dens;\n        }\n        if(trans<.1)\n        {\n            trans = 0.;break;\n        }\n    }\n    return vec4(max(col, vec3(0)),trans);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1);\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    fragCoord/=RENDER_SCALE;\n    if(fragCoord.x > iResolution.x || fragCoord.y > iResolution.y)return;\n    vec2 screenPos = ((fragCoord.xy)/iResolution.x*2.-1.)+vec2(0,iResolution.y/iResolution.x)*.75;\n\n\n    Ray viewRay = constructViewRay(screenPos, CAMERA_POS+screenShake(iTime), normalize(CAMERA_DIR), vec3(0,0,1), FOCAL_LEN);\n    vec2 planet2 = raySphere(Ray(viewRay.origin-PLANET2_POS, viewRay.dir), PLANET2_R);// planet 2 acts as a cutout, so we don't need to render as much\n    if(planet2.x < FAR)return;\n    viewRay.origin+=viewRay.dir*(texture(iChannel0, screenPos+iTime*10.3127).x*2.-1.)*STEP_SIZE*.5;\n    vec4 col = vec4(march(viewRay)/2.);\n    vec4 last = texture(iChannel1, uv).rgba;\n    fragColor = vec4(col*.4+last*.6);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// stars, planets and the ships\n\nvec3 stars(vec2 pos)\n{\n    vec2 p;\n    float stars = voro2D(pos*3200.,p);\n    return vec3(smoothstep(.98,.997,1.-stars));\n}\n\nvec3 shadePlanet(Ray r, vec2 planet)// planet is just a noisy sphere with a bit of manipulation based on the thickness at that point\n{\n      \n    vec3 nrm = r.origin-PLANET_POS+r.dir*planet.x;\n    nrm = normalize(nrm+(noise3D(nrm*600.).xxx*2.-1.)*0.02);\n    float light = dot(nrm, -normalize(r.origin+r.dir*planet.x));\n    light+=1.-((planet.y-planet.x)/PLANET_R);\n    vec3 lCol = vec3(1.000,0.067,0.067)*max(light,0.)*80. + vec3(.01); \n    return lCol;\n}\nvec3 shadePlanet2(Ray r, vec2 planet)\n{\n    //mostly as above just different noise and rotated\n    vec3 nrm = r.origin-PLANET_POS+r.dir*planet.x;\n    float rot = .8;\n    float cr = cos(rot);\n    float sr = sin(rot);\n    nrm = mat3(vec3(cr,0,sr),vec3(0,1,0), vec3(-sr,0,cr))*nrm;\n    vec3 noise = (noise3D(nrm*vec3(20.,20.,500.)+iTime*.01).xxx*2.-1.)+(noise3D(nrm*vec3(100.,100.,2000.)+iTime*.1).xxx*2.-1.)*0.5+(noise3D(nrm*vec3(500.,500.,3000.)+iTime*.1).xxx*2.-1.)*0.25;\n    nrm = normalize(nrm-noise*.2);\n    float light = dot(nrm, -normalize(r.origin+r.dir*planet.x+vec3(-.3,-1.8,2.8)));\n    light+=1.-((planet.y-planet.x)/PLANET_R);\n    vec3 lCol = vec3(0.784,0.098,0.098)*pow(max(light,0.),4.)*100. + vec3(.02); \n    return lCol*mix(vec3(0.149,0.529,0.714), vec3(0.345,0.290,0.216), noise.x);\n}\n\n\nfloat distShip(vec3 pos, float to)\n{\n    //the ships are sdf lines with some domain warping based on sin and distance to shape them and make them move\n    const vec3 A =vec3(0.4,-.3,-.1)+CAMERA_POS;\n    const vec3 B =vec3(0.3,-1,-.02)+CAMERA_POS;\n    float dist = distance(A,pos)-distance(B,pos);\n    pos.x += sin(dist+iTime+to)*.01;\n    pos.z += sin(dist+312.15+iTime+to)*.01;\n    pos.x += sin(dist*12.+iTime*8.+to)*.03*(1.-clamp(dist+.7,0.,1.));\n    \n    float d = sdCapsule(pos, A, B, .04*((dist+.2))*(1.-clamp(dist*2.,0.,1.)));\n    return d;\n}\nfloat distShipScene(vec3 pos)\n{\n    float d = distShip(pos,0.);\n    d = min(d,distShip(pos+vec3(.1,-.3*sin(iTime),.2),.123));\n    d = min(d,distShip(pos+vec3(-.2,.1*cos(iTime),.2),.81));\n    \n    return d;\n}\n\nvec3 marchShip(Ray r)\n{//standard sdf march\n    float dep = .01;\n    float i = 0.;\n    while (dep < FAR)\n    {\n        float dist = distShipScene(r.origin+r.dir*dep);\n        if(dist<.002)break;\n        dep+=dist*.2;\n        i+=.1;\n    }\n    return vec3(0.239,0.639,0.812)*pow(i*.1+float(dep<FAR), 6.)*3.;\n}\nvec3 drawNearStars(vec2 pos, float nebW)\n{//draw several layers of stars at differnt scales and have them be effected more of less by nebulas dens, so it looks like they are partly behind it. \n    vec3 star =vec3(0);\n    pos.x*=.1;\n    for(int i = 0; i < 3; i++)\n    {\n        vec2 p;\n        nebW-=.1;\n        star+=smoothstep(.995, 1., pow(1.-voro2D(pos*5.*float(i*2+1),p), 12.))*clamp(nebW+.1,0.,1.);\n    }\n    return vec3(0.871,0.757,0.494)*star*20.;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screenPos = (fragCoord.xy/iResolution.x*2.-1.)+vec2(0,iResolution.y/iResolution.x)*.75;\n\n\n    Ray viewRay = constructViewRay(screenPos, CAMERA_POS+screenShake(iTime), normalize(CAMERA_DIR), vec3(0,0,1), FOCAL_LEN);\n    vec2 uv = (fragCoord.xy/iResolution.xy);\n    vec3 bg = stars(uv);\n    vec2 planet = raySphere(Ray(viewRay.origin-PLANET_POS, viewRay.dir), PLANET_R);\n    vec2 planet2 = raySphere(Ray(viewRay.origin-PLANET2_POS, viewRay.dir), PLANET2_R);\n    \n    bg = (planet.x<FAR) ? shadePlanet(viewRay, planet) : bg;\n    bg = (planet2.x<FAR) ? shadePlanet2(viewRay, planet2) : bg;\n    \n    vec3 ship = marchShip(viewRay);\n\n    vec4 nebulae = texture(iChannel0, uv*RENDER_SCALE);\n    \n    vec3 col = mix(nebulae.xyz, bg, nebulae.a);\n    col += drawNearStars(screenPos, nebulae.w)*float(planet2.x >= FAR);\n    col += vec3(ship);\n    \n    fragColor = vec4(col.xyz,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//x part of gaussian blur for bloom\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    for(int i = -BLUR_SAMPLES; i <= BLUR_SAMPLES; i++ )\n    {\n        fragColor.xyz+=min(pow(textureLod(iChannel0, (fragCoord+vec2(i*3,0))/iResolution.xy, 2.).xyz, vec3(3.)),vec3(100000))*gaussian(float(i)/float(BLUR_SAMPLES), 1., 0., .2);\n    }\n    fragColor/=float(BLUR_SAMPLES*2);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}