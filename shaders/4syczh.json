{
    "Shader": {
        "info": {
            "date": "1528384582",
            "description": "I used this shadertoy to generate some of the diagrams for my Digital Dragons 2018 talk.\nhttps://research.activision.com/t5/Publications/HDR-in-Call-of-Duty/ba-p/10744846\n\nWASD + mouse to fly camera\n\nSee also https://www.shadertoy.com/view/XsGcR1",
            "flags": 48,
            "hasliked": 0,
            "id": "4syczh",
            "likes": 15,
            "name": "Slide Generic Scene",
            "published": 3,
            "tags": [
                "scene"
            ],
            "usePreview": 0,
            "username": "P_Malin",
            "viewed": 1183
        },
        "renderpass": [
            {
                "code": "// Generic Scene\n// https://www.shadertoy.com/view/4syczh\n// @P_Malin\n\n// I used this shadertoy to generate some of the diagrams for my Digital Dragons 2018 talk.\n// https://research.activision.com/t5/Publications/HDR-in-Call-of-Duty/ba-p/10744846\n\n// change the CUBE_LUT and GENERIC_SCENE and camera defines in Buf A to change scene\n\n//    _____                               _____                                _ _   _             \n//   |_   _|                             / ____|                              (_) | (_)            \n//     | |  _ __ ___   __ _  __ _  ___  | |     ___  _ __ ___  _ __   ___  ___ _| |_ _  ___  _ __  \n//     | | | '_ ` _ \\ / _` |/ _` |/ _ \\ | |    / _ \\| '_ ` _ \\| '_ \\ / _ \\/ __| | __| |/ _ \\| '_ \\ \n//    _| |_| | | | | | (_| | (_| |  __/ | |___| (_) | | | | | | |_) | (_) \\__ \\ | |_| | (_) | | | |\n//   |_____|_| |_| |_|\\__,_|\\__, |\\___|  \\_____\\___/|_| |_| |_| .__/ \\___/|___/_|\\__|_|\\___/|_| |_|\n//                           __/ |                            | |                                  \n//                          |___/                             |_|                                  \n\n///////////////////////////////////////////////\n\nvec3 Tonemap( vec3 x )\n{\n    float a = 0.010;\n    float b = 0.132;\n    float c = 0.010;\n    float d = 0.163;\n    float e = 0.101;\n\n    return ( x * ( a * x + b ) ) / ( x * ( c * x + d ) + e );\n}\n\n\nvec3 ApplyGrain( vec2 vUV, vec3 col, float amount )\n{\n    float h = hash13( vec3(vUV, iTime) );\n    \n    col *= (h * 2.0 - 1.0) * amount + (1.0f -amount);\n    \n    return col;\n}\n\n\nfloat GetVignetting( const in vec2 vUV, float fScale, float fPower, float fStrength )\n{\n\tvec2 vOffset = (vUV - 0.5) * sqrt(2.0) * fScale;\n\t\n\tfloat fDist = max( 0.0, 1.0 - length( vOffset ) );\n    \n\tfloat fShade = 1.0 - pow( fDist, fPower );\n    \n    fShade = 1.0 - fShade * fStrength;\n\n\treturn fShade;\n}\n\nvec3 ColorGrade( vec3 vColor )\n{\n    vec3 vHue = vec3(1.0, .7, .2);\n    \n    vec3 vGamma = 1.0 + vHue * 0.6;\n    vec3 vGain = vec3(.9) + vHue * vHue * 8.0;\n    \n    vColor *= 1.5;\n    \n    float fMaxLum = 100.0;\n    vColor /= fMaxLum;\n    vColor = pow( vColor, vGamma );\n    vColor *= vGain;\n    vColor *= fMaxLum;  \n    return vColor;\n}\n\nvec3 SampleImage( vec2 vUV, int image )\n{\n    if ( image >= 0 )\n    {\n        vUV.x *= 0.5;\n    }\n    \n    if (image > 0 )\n    {\n        vUV.x += 0.5;\n    }\n    \n\tvec4 vImageSample = textureLod( iChannel0, vUV, 0.0 ).rgba;\n\n    return vImageSample.rgb;\n}\n\nvec2 DistortUV( vec2 vUV, float f )\n{\n    vUV -= 0.5;\n\n    float fScale = 0.0075;\n    \n    float r1 = 1. + f * fScale;\n    \n    vec3 v = vec3(vUV, sqrt( r1 * r1 - dot(vUV, vUV) ) );\n    \n    v = normalize(v);\n    vUV = v.xy;\n    \n    \n    vUV += 0.5;\n    \n    return vUV;\n}\n\nvec3 SampleImage2( vec2 vUV, vec2 vScreen, int image )\n{\n    vec3 a = SampleImage( DistortUV( vUV, 1.0 ), image );\n    vec3 b = SampleImage( DistortUV( vUV, 0.0 ), image );\n    vec3 c = SampleImage( DistortUV( vUV, -1.0 ), image );\n    \n    vec3 vResult = vec3(0);\n    \n    vec3 wa = vec3(1., .5, .1);\n    vec3 wb = vec3(.5, 1., .5);\n    vec3 wc = vec3(.1, .5, 1.);\n    \n    vResult += a * wa;\n    vResult += b * wb;\n    vResult += c * wc;\n    \n    vResult /= wa + wb + wc;\n    \n    return vResult;\n}\n\n\nvoid Process( out vec4 fragColor, vec2 vUV, vec2 vScreen, int image )\n{\n    vec3 vResult = SampleImage2( vUV, vScreen, image );\n    \n    //vResult = texelFetch( iChannel0, ivec2( fragCoord.xy ), 0 ).rgb;\n    \n    float fShade = GetVignetting( vUV, 0.7, 2.0, 0.7 );\n    \n    vResult *= fShade;\n    \n    //if ( vUV.x > sin(iTime)*0.5+0.5 )\n    {\n    \tvResult = ColorGrade( vResult );\n    }\n    \n\tvResult = ApplyGrain( vUV, vResult, 0.15 );             \n        \n    vResult = vResult * 0.75;\n    vResult = Tonemap( vResult );\n    fragColor.rgb = vResult;\n    fragColor.a = 1.0;    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vUV = fragCoord.xy / iResolution.xy;\n    \n    Process( fragColor, vUV, vUV, -1 );       \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI \t\t3.141592654\n#define TAU \t(PI * 2.0f)\n\n//  _   _           _       _____                 _   _                 \n// | | | | __ _ ___| |__   |  ___|   _ _ __   ___| |_(_) ___  _ __  ___ \n// | |_| |/ _` / __| '_ \\  | |_ | | | | '_ \\ / __| __| |/ _ \\| '_ \\/ __|\n// |  _  | (_| \\__ \\ | | | |  _|| |_| | | | | (__| |_| | (_) | | | \\__ \\\n// |_| |_|\\__,_|___/_| |_| |_|   \\__,_|_| |_|\\___|\\__|_|\\___/|_| |_|___/\n//                                                                      \n\n// From: Hash without Sine by Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n//#define HASHSCALE1 .1031\n//#define HASHSCALE3 vec3(.1031, .1030, .0973)\n//#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n#define HASHSCALE1 443.8975\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\nfloat SmoothNoise(in vec2 o) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\t//float n = p.x + p.y*57.0;\n\n\tfloat a = hash12(p);\n\tfloat b = hash12(p+vec2(1,0));\n\tfloat c = hash12(p+vec2(0,1));\n\tfloat d = hash12(p+vec2(1,1));\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n    return res;\n}\n\nfloat FBM( vec2 p, float ps ) {\n\tfloat f = 0.0;\n    float tot = 0.0;\n    float a = 1.0;\n    for( int i=0; i<3; i++)\n    {\n        f += SmoothNoise( p ) * a;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f / tot;\n}\n\n//  ____        _          ____  _                             \n// |  _ \\  __ _| |_ __ _  / ___|| |_ ___  _ __ __ _  __ _  ___ \n// | | | |/ _` | __/ _` | \\___ \\| __/ _ \\| '__/ _` |/ _` |/ _ \\\n// | |_| | (_| | || (_| |  ___) | || (_) | | | (_| | (_| |  __/\n// |____/ \\__,_|\\__\\__,_| |____/ \\__\\___/|_|  \\__,_|\\__, |\\___|\n//                                                  |___/      \n//\n\nvec4 LoadVec4( sampler2D sampler, in ivec2 vAddr )\n{\n    return texelFetch( sampler, vAddr, 0 );\n}\n\nvec3 LoadVec3( sampler2D sampler, in ivec2 vAddr )\n{\n    return LoadVec4( sampler, vAddr ).xyz;\n}\n\nbool AtAddress( ivec2 p, ivec2 c ) { return all( equal( p, c ) ); }\n\nvoid StoreVec4( in ivec2 vAddr, in vec4 vValue, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in ivec2 vAddr, in vec3 vValue, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n//\n//  ____       _        _   _             \n// |  _ \\ ___ | |_ __ _| |_(_) ___  _ __  \n// | |_) / _ \\| __/ _` | __| |/ _ \\| '_ \\ \n// |  _ < (_) | || (_| | |_| | (_) | | | |\n// |_| \\_\\___/ \\__\\__,_|\\__|_|\\___/|_| |_|\n//                                        \n//\n\nvec3 RotateX( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n    \n    vec3 vResult = vec3( vPos.x, c * vPos.y + s * vPos.z, -s * vPos.y + c * vPos.z);\n    \n    return vResult;\n}\n\nvec3 RotateY( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n    \n    vec3 vResult = vec3( c * vPos.x + s * vPos.z, vPos.y, -s * vPos.x + c * vPos.z);\n    \n    return vResult;\n}\n\nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n    \n    vec3 vResult = vec3( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y, vPos.z);\n    \n    return vResult;\n}\n\n\n//   ___              _                  _             \n//  / _ \\ _   _  __ _| |_ ___ _ __ _ __ (_) ___  _ __  \n// | | | | | | |/ _` | __/ _ \\ '__| '_ \\| |/ _ \\| '_ \\ \n// | |_| | |_| | (_| | ||  __/ |  | | | | | (_) | | | |\n//  \\__\\_\\\\__,_|\\__,_|\\__\\___|_|  |_| |_|_|\\___/|_| |_|\n//                                                     \n//\n\nvec4 QuatMul(const in vec4 lhs, const in vec4 rhs) \n{\n      return vec4( lhs.y*rhs.z - lhs.z*rhs.y + lhs.x*rhs.w + lhs.w*rhs.x,\n                   lhs.z*rhs.x - lhs.x*rhs.z + lhs.y*rhs.w + lhs.w*rhs.y,\n                   lhs.x*rhs.y - lhs.y*rhs.x + lhs.z*rhs.w + lhs.w*rhs.z,\n                   lhs.w*rhs.w - lhs.x*rhs.x - lhs.y*rhs.y - lhs.z*rhs.z);\n}\n\nvec4 QuatFromAxisAngle( vec3 vAxis, float fAngle )\n{\n\treturn vec4( normalize(vAxis) * sin(fAngle), cos(fAngle) );    \n}\n\nvec4 QuatFromVec3( vec3 vRot )\n{\n    float l = length( vRot );\n    if ( l <= 0.0 )\n    {\n        return vec4( 0.0, 0.0, 0.0, 1.0 );\n    }\n    return QuatFromAxisAngle( vRot, l );\n}\n\nmat3 QuatToMat3( const in vec4 q )\n{\n\tvec4 qSq = q * q;\n\tfloat xy2 = q.x * q.y * 2.0;\n\tfloat xz2 = q.x * q.z * 2.0;\n\tfloat yz2 = q.y * q.z * 2.0;\n\tfloat wx2 = q.w * q.x * 2.0;\n\tfloat wy2 = q.w * q.y * 2.0;\n\tfloat wz2 = q.w * q.z * 2.0;\n \n\treturn mat3 (\t\n     qSq.w + qSq.x - qSq.y - qSq.z, xy2 - wz2, xz2 + wy2,\n     xy2 + wz2, qSq.w - qSq.x + qSq.y - qSq.z, yz2 - wx2,\n     xz2 - wy2, yz2 + wx2, qSq.w - qSq.x - qSq.y + qSq.z );\n}\n\nvec3 QuatMul( vec3 v, vec4 q )\n{\n    // TODO Validate vs other quat code\n    vec3 t = 2.0 * cross(q.xyz, v);\n\treturn v + q.w * t + cross(q.xyz, t);\n}\n\n//\n//  _  __          _                         _ \n// | |/ /___ _   _| |__   ___   __ _ _ __ __| |\n// | ' // _ \\ | | | '_ \\ / _ \\ / _` | '__/ _` |\n// | . \\  __/ |_| | |_) | (_) | (_| | | | (_| |\n// |_|\\_\\___|\\__, |_.__/ \\___/ \\__,_|_|  \\__,_|\n//           |___/                             \n//\n\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\nconst int KEY_COMMA = 188;\nconst int KEY_PER   = 190;\n\nconst int KEY_1 = \t49;\nconst int KEY_2 = \t50;\nconst int KEY_3 = \t51;\nconst int KEY_ENTER = 13;\nconst int KEY_SHIFT = 16;\nconst int KEY_CTRL  = 17;\nconst int KEY_ALT   = 18;\nconst int KEY_TAB\t= 9;\n\nbool Key_IsPressed( sampler2D samp, int key)\n{\n    return texelFetch( samp, ivec2(key, 0), 0 ).x > 0.0;    \n}\n\nbool Key_IsToggled(sampler2D samp, int key)\n{\n    return texelFetch( samp, ivec2(key, 2), 0 ).x > 0.0;    \n}\n\n\n//\n//   ____                               \n//  / ___|__ _ _ __ ___   ___ _ __ __ _ \n// | |   / _` | '_ ` _ \\ / _ \\ '__/ _` |\n// | |__| (_| | | | | | |  __/ | | (_| |\n//  \\____\\__,_|_| |_| |_|\\___|_|  \\__,_|\n//                                      \n\n\nstruct CameraState\n{\n    vec3 vPos;\n    vec3 vTarget;\n    vec3 vUp;\n    float fFov;\n    vec2 vJitter;\n    float fPlaneInFocus;\n};\n    \nvoid Cam_LoadState( out CameraState cam, sampler2D sampler, ivec2 addr )\n{\n    vec4 vPos = LoadVec4( sampler, addr + ivec2(0,0) );\n    cam.vPos = vPos.xyz;\n    vec4 targetFov = LoadVec4( sampler, addr + ivec2(1,0) );\n    cam.vTarget = targetFov.xyz;\n    cam.fFov = targetFov.w;\n    vec4 vUp = LoadVec4( sampler, addr + ivec2(2,0) );\n    cam.vUp = vUp.xyz;\n    \n    vec4 jitterDof = LoadVec4( sampler, addr + ivec2(3,0) );\n    cam.vJitter = jitterDof.xy;\n    cam.fPlaneInFocus = jitterDof.z;\n}\n\nvoid Cam_StoreState( ivec2 addr, const in CameraState cam, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    StoreVec4( addr + ivec2(0,0), vec4( cam.vPos, 0 ), fragColor, fragCoord );\n    StoreVec4( addr + ivec2(1,0), vec4( cam.vTarget, cam.fFov ), fragColor, fragCoord );    \n    StoreVec4( addr + ivec2(2,0), vec4( cam.vUp, 0 ), fragColor, fragCoord );    \n    StoreVec4( addr + ivec2(3,0), vec4( cam.vJitter, cam.fPlaneInFocus, 0 ), fragColor, fragCoord );    \n}\n\nmat3 Cam_GetWorldToCameraRotMatrix( const CameraState cameraState )\n{\n    vec3 vForward = normalize( cameraState.vTarget - cameraState.vPos );\n\tvec3 vRight = normalize( cross( cameraState.vUp, vForward) );\n\tvec3 vUp = normalize( cross(vForward, vRight) );\n    \n    return mat3( vRight, vUp, vForward );\n}\n\nvec2 Cam_GetViewCoordFromUV( vec2 vUV, float fAspectRatio )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= fAspectRatio;\n\n\treturn vWindow;\t\n}\n\nvoid Cam_GetCameraRay( const vec2 vUV, const float fAspectRatio, const CameraState cam, out vec3 vRayOrigin, out vec3 vRayDir )\n{\n    vec2 vView = Cam_GetViewCoordFromUV( vUV, fAspectRatio );\n    vRayOrigin = cam.vPos;\n    float fPerspDist = 1.0 / tan( radians( cam.fFov ) );\n    vRayDir = normalize( Cam_GetWorldToCameraRotMatrix( cam ) * vec3( vView, fPerspDist ) );\n}\n\n// fAspectRatio = iResolution.x / iResolution.y;\nvec2 Cam_GetUVFromWindowCoord( const in vec2 vWindow, float fAspectRatio )\n{\n    vec2 vScaledWindow = vWindow;\n    vScaledWindow.x /= fAspectRatio;\n\n    return (vScaledWindow * 0.5 + 0.5);\n}\n\nvec2 Cam_WorldToWindowCoord(const in vec3 vWorldPos, const in CameraState cameraState )\n{\n    vec3 vOffset = vWorldPos - cameraState.vPos;\n    vec3 vCameraLocal;\n\n    vCameraLocal = vOffset * Cam_GetWorldToCameraRotMatrix( cameraState );\n\t\n    vec2 vWindowPos = vCameraLocal.xy / (vCameraLocal.z * tan( radians( cameraState.fFov ) ));\n    \n    return vWindowPos;\n}\n\nfloat EncodeDepthAndObject( float depth, int objectId )\n{\n    //depth = max( 0.0, depth );\n    //objectId = max( 0, objectId + 1 );\n    //return exp2(-depth) + float(objectId);\n    return depth;\n}\n\nfloat DecodeDepthAndObjectId( float value, out int objectId )\n{\n    objectId = 0;\n    return max(0.0, value);\n    //objectId = int( floor( value ) ) - 1; \n    //return abs( -log2(fract(value)) );\n}\n\n\n\n\n///////////////////////////\n// Font\n///////////////////////////\n\n// Font printing based on https://www.shadertoy.com/view/ldfcDr\n\n#define AUTO_FONT_SPACING\n//#define HANDLE_EOL\n#define HANDLE_PRINT_STYLES\n\n// Font characters\nconst uint\n   \t// HTML Entity Names\n    \n    _SP = 0x20u,\t\t// ' '\n    _EXCL = 0x21u, \t\t// '!' \n    _QUOT = 0x22u, \t\t// '\"'\n    _NUM = 0x23u,  \t\t// '#'\n    _DOLLAR = 0x24u, \t// '$'\n    _PERCNT = 0x25u, \t// '%'\n    _AMP = 0x26u, \t\t// '&'\n    _APOS = 0x27u,\t\t// '''    \n    _LPAR = 0x28u, \t\t// '('\n    _RPAR= 0x29u, \t\t// ')'\n    _AST = 0x2Au,\t\t// '*'\n    _PLUS = 0x2Bu,\t\t// '+'\n    _COMMA = 0x2Cu,\t\t// ','    \n    _MINUS = 0x2Du,\t\t// '-'\n    _PERIOD = 0x2Eu,\t// '.'\n    _SOL = 0x2Fu,\t\t// '/' \n\n    _0 = 0x30u, _1 = 0x31u, _2 = 0x32u, _3 = 0x33u, _4 = 0x34u, \n    _5 = 0x35u, _6 = 0x36u, _7 = 0x37u, _8 = 0x38u, _9 = 0x39u, \n\n    _COLON = 0x3Au,\t\t// ':' \n    _SEMI = 0x3Bu,\t\t// ';' \n    _LT = 0x3Cu,\t\t// '<' \n    _EQUALS = 0x3Du,\t// '=' \n    _GT = 0x3Eu,\t\t// '>' \n    _QUEST = 0x3Fu,\t\t// '?' \n    _COMAT = 0x40u,\t\t// '@' \n    \n    _A = 0x41u, _B = 0x42u, _C = 0x43u, _D = 0x44u, _E = 0x45u, \n    _F = 0x46u, _G = 0x47u, _H = 0x48u, _I = 0x49u, _J = 0x4Au,\n    _K = 0x4Bu, _L = 0x4Cu, _M = 0x4Du, _N = 0x4Eu, _O = 0x4Fu,\n    _P = 0x50u, _Q = 0x51u, _R = 0x52u, _S = 0x53u, _T = 0x54u,\n    _U = 0x55u, _V = 0x56u, _W = 0x57u, _X = 0x58u, _Y = 0x59u,\n    _Z = 0x5Au,\n\n    _LSQB = 0x5Bu,\t\t// '[' \n    _BSOL = 0x5Cu,\t\t// '\\'\n    _RSQB = 0x5Du,\t\t// ']' \n    _CIRC = 0x5Eu,\t\t// '^' \n    _LOWBAR = 0x5Fu,\t// '_' \n    _GRAVE = 0x60u,\t\t// '`' \n    \n    _a = 0x61u, _b = 0x62u, _c = 0x63u, _d = 0x64u, _e = 0x65u,\n    _f = 0x66u, _g = 0x67u, _h = 0x68u, _i = 0x69u, _j = 0x6Au,\n    _k = 0x6Bu, _l = 0x6Cu, _m = 0x6Du, _n = 0x6Eu, _o = 0x6Fu,\n    _p = 0x70u, _q = 0x71u, _r = 0x72u, _s = 0x73u, _t = 0x74u,\n    _u = 0x75u, _v = 0x76u, _w = 0x77u, _x = 0x78u, _y = 0x79u,\n    _z = 0x7Au\n\n\t,_LCUB = 0x7Bu\t\t// '{'\n    ,_VERBAR = 0x7Cu\t// '|'\n    ,_RCUB = 0x7Du\t\t// '}'\n    ,_TILDE = 0x7Eu\t\t// '~'\n    \n#ifdef HANDLE_EOL       \n    ,_EOL = 0x1000u \t// End of Line - Carriage Return & Line Feed    \n#endif    \n#ifdef HANDLE_PRINT_STYLES    \n    ,_BOLDON = 0x1001u\t// Special\n    ,_BOLDOFF = 0x1002u\t// Special\n    ,_ITALON = 0x1003u\t// Special\n    ,_ITALOFF = 0x1004u\t// Special    \n#endif    \n;\n\n\nvec4 SampleCharacterTex( sampler2D sFontSampler, uint iChar, vec2 vCharUV )\n{\n    uvec2 iChPos = uvec2( iChar % 16u, iChar / 16u );\n    vec2 vUV = (vec2(iChPos) + vCharUV) / 16.0f;\n    return textureLod( sFontSampler, vUV, 0.0 );\n}\n    \nvec4 SampleCharacter( sampler2D sFontSampler, uint iChar, vec2 vCharUV )\n{\n    uvec2 iChPos = uvec2( iChar % 16u, iChar / 16u );\n    vec2 vClampedCharUV = clamp(vCharUV, vec2(0.01), vec2(0.99));\n    vec2 vUV = (vec2(iChPos) + vClampedCharUV) / 16.0f;\n\n    vec4 vSample;\n    \n    float l = length( (vClampedCharUV - vCharUV) );\n\n    // Skip texture sample when not in character boundary\n    // Ok unless we have big font weight\n    if ( l > 0.01f )\n    {\n        vSample.rgb = vec3(0);\n\t\tvSample.w = 2000000.0; \n    }\n    else\n    {\n\t\tvSample = textureLod( sFontSampler, vUV, 0.0 );    \n        vSample.gb = vSample.gb * 2.0f - 1.0f;\n        vSample.a -= 0.5f + 1.0/256.0;    \n    }\n        \n    return vSample;\n}\n\n\nstruct CharExtents\n{\n    float left;\n    float width;\n};\n    \n// Auto font spacing adapted from Klems shader: https://www.shadertoy.com/view/MsfyDN\nfloat CharVerticalPos( sampler2D sFontSampler, uint iChar, vec2 vUV ) \n{\n    vec4 vSample = SampleCharacterTex(sFontSampler, iChar, vUV);\n    float dist = vSample.a - (127.0/255.0);\n    dist *= vSample.g * 2.0 - 1.0;\n    return vUV.x - dist;\n}\n\nCharExtents GetCharExtents( sampler2D sFontSampler, uint iChar )\n{\n    CharExtents result;\n\n    result.left = CharVerticalPos( sFontSampler, iChar, vec2(0.02, 0.5) );\n    float right = CharVerticalPos( sFontSampler, iChar, vec2(0.98, 0.5) );\n    result.width = right - result.left;\n    \n    if ( iChar == _SP )\n    {\n        result.left = 0.3f;\n        result.width = 0.4f;\n    }\n    return result;\n}\n\nstruct PrintState\n{\n    vec2 vPixelPos;\n    \n    vec2 vLayoutStart;\n    // print position\n    vec2 vCursorPos;\n    vec2 vPixelSize;\n\n#ifdef HANDLE_EOL\n    bool EOL;\n#endif\n\n    // result\n    float fDistance;\n};    \n\nvoid MoveTo( inout PrintState state, vec2 vPos )\n{\n    state.vLayoutStart = vPos;\n    state.vCursorPos = vPos;\n#ifdef HANDLE_EOL\n    state.EOL = false;\n#endif\n}\n\nvoid ClearPrintResult( inout PrintState state )\n{\n    state.fDistance = 1000000.0;   \n}\n\nPrintState PrintState_InitCanvas( vec2 vCoords, vec2 vPixelSize )\n{\n    PrintState state;\n    state.vPixelPos = vCoords;\n    state.vPixelSize = vPixelSize;\n    \n    MoveTo( state, vec2(0) );\n\n    ClearPrintResult( state );\n    \n    return state;\n}\n\nstruct LayoutStyle\n{\n    vec2 vSize;\n    float fLineGap;\n    float fAdvancement;\n#ifdef HANDLE_PRINT_STYLES    \n    bool bItalic;\n    bool bBold;  \n#endif    \n};\n    \nLayoutStyle LayoutStyle_Default()\n{\n    LayoutStyle style;\n    style.vSize = vec2(24.0f, 32.0f);    \n    style.fLineGap = 0.1f;\n    style.fAdvancement = 0.1f;\n#ifdef HANDLE_PRINT_STYLES    \n    style.bItalic = false;\n    style.bBold = false;       \n#endif    \n    return style;\n}\n\nstruct RenderStyle\n{\n    vec3 vFontColor;\n    float fFontWeight;   \n};\n\nRenderStyle RenderStyle_Default( vec3 vFontColor )\n{\n    RenderStyle style;\n    style.vFontColor = vFontColor;\n    style.fFontWeight = 0.0f;  \n    return style;\n}\n\nconst float g_fFontDescent = 0.15f;\nconst float g_fFontAscent = 0.65f;\n\nvoid PrintEndCurrentLine( inout PrintState state, const LayoutStyle style )\n{\n    // Apply CR\n    state.vCursorPos.x = state.vLayoutStart.x;\n    \n    // advance Y position to bottom of descender based on current font size.\n\tstate.vCursorPos.y += style.vSize.y * g_fFontDescent;    \n}\n\nvoid PrintBeginNextLine( inout PrintState state, const LayoutStyle style )\n{\n    // move Y position to baseline based on current font size\n\tstate.vCursorPos.y += style.vSize.y * (g_fFontAscent + style.fLineGap);\n}\n\n#ifdef HANDLE_EOL\nvoid PrintEOL( inout PrintState state, const LayoutStyle style )\n{\n    if ( state.EOL )\n    {\n        PrintBeginNextLine( state, style );\n    }\n    PrintEndCurrentLine( state, style );\n    state.EOL = true;\n}\n#endif\n\nvoid PrintCh( inout PrintState state, inout LayoutStyle style, sampler2D sFontSampler, const uint iChar )\n{\n#ifdef HANDLE_EOL\n    if ( iChar == _EOL )\n    {\n        PrintEOL( state, style );\n        return;\n    }\n    else\n#endif\n#ifdef HANDLE_PRINT_STYLES            \n    if ( iChar == _BOLDON )\n    {\n        style.bBold = true;\n        return;\n    }\n    else\n    if ( iChar == _BOLDOFF )\n    {\n        style.bBold = false;\n        return;\n    }\n    else\n    if ( iChar == _ITALON )\n    {\n        style.bItalic = true;\n        return;\n    }\n    else\n    if ( iChar == _ITALOFF )\n    {\n        style.bItalic = false;\n        return;\n    }\n#endif\n    \n#ifdef HANDLE_EOL\n    if ( state.EOL )\n    {\n        PrintBeginNextLine( state, style );\n\t\tstate.EOL = false;\n    }\n#endif\n    \n    vec2 vUV = ((state.vPixelPos - state.vCursorPos) / style.vSize);\n\n    /*if ( (vUV.y > -0.1) && (vUV.y < 0.1) && (abs(vUV.x) < 0.02 || abs(vUV.x - CharWidth(iChar)) < 0.02) )\n    {\n        state.fDistance = -10.0;\n    }*/\n    \n\tCharExtents extents = GetCharExtents( sFontSampler, iChar );    \n    vUV.y += 0.8f; // Move baseline\n    vUV.x += extents.left - style.fAdvancement;\n    \n#ifdef HANDLE_PRINT_STYLES    \n    if ( style.bItalic )\n    {\n    \tvUV.x += (1.0 - vUV.y) * -0.4f;\n    }\n#endif\n    \n    vec3 v = SampleCharacter( sFontSampler, iChar, vUV ).agb;\n\n#ifdef HANDLE_PRINT_STYLES    \n    if ( style.bBold )\n    {\n    \tv.x -= 0.025f;\n    }\n#endif    \n    \n    if ( v.x < state.fDistance )\n    {\n        state.fDistance = v.x;       \n    }\n    \n    state.vCursorPos.x += style.vSize.x * (extents.width + style.fAdvancement);\n}\n\n\n/*Rect GetFontRect( PrintState state, LayoutStyle style, bool initialLineOffset )\n{\n    Rect rect;\n    \n    rect.vPos = state.vLayoutStart;\n    if ( initialLineOffset )\n    {\n    \trect.vPos.y += style.vSize.y * (style.fLineGap + g_fFontAscent);\n    }\n\trect.vPos.y -= style.vSize.y * (g_fFontAscent);\n    rect.vSize.x = state.vCursorPos.x - state.vLayoutStart.x;\n    rect.vSize.y = style.vSize.y * ( g_fFontAscent + g_fFontDescent );\n    \n    return rect;\n}*/\n\nfloat GetFontBlend( PrintState state, LayoutStyle style, float size )\n{\n    float fFeatherDist = 1.0f * length(state.vPixelSize / style.vSize);    \n    float f = clamp( (size-state.fDistance + fFeatherDist * 0.5f) / fFeatherDist, 0.0, 1.0);\n    return f;\n}\n\nvoid RenderFont( PrintState state, LayoutStyle style, RenderStyle renderStyle, inout vec3 color )\n{   \n    float f = GetFontBlend( state, style, renderStyle.fFontWeight );\n\n    vec3 vCol = renderStyle.vFontColor;\n    \n    color.rgb = mix( color.rgb, vCol, f);    \n}\n\n// Font print helpers\n\n// need to find a way to do this from common\nint NO_UNROLL(int X) { return X; }\nuint NO_UNROLLU(uint X) { return X; }\n\n#define ARRAY_PRINT( STATE, STYLE, SAMPLER, CHAR_ARRAY ) { for (int i=0; i< NO_UNROLL( CHAR_ARRAY.length() ); i++) PrintCh( STATE, STYLE, SAMPLER, CHAR_ARRAY[i] ); }\n\nvoid Print( inout PrintState state, LayoutStyle style, sampler2D sFontSampler, uint value )\n{\n\tuint place = 1000000000u;\n\n    bool leadingZeros = true;\n    while( place > NO_UNROLLU( 0u ) )\n    {\n        uint digit = (value / place) % 10u;\n        if ( place == 1u || digit != 0u )\n        {\n            leadingZeros = false;\n        }\n        \n        if (!leadingZeros)\n        {\n            PrintCh( state, style, sFontSampler, _0 + digit );\n        }\n        place = place / 10u;\n    }    \n}\n\nvoid Print( inout PrintState state, LayoutStyle style, sampler2D sFontSampler, int value )\n{\n    if ( value < 0 )\n    {\n        PrintCh( state, style, sFontSampler, _MINUS );\n        value = -value;\n    }\n\n    Print ( state, style, sFontSampler, uint(value) );    \n}\n\nvoid Print( inout PrintState state, LayoutStyle style, sampler2D sFontSampler, float value, int decimalPlaces )\n{\n    if ( value < 0.0f )\n    {\n        PrintCh( state, style, sFontSampler, _MINUS );\n    }\n    value = abs(value);\n    \n    int placeIndex = 10;\n    \n    bool leadingZeros = true;\n    while( placeIndex >= NO_UNROLL( -decimalPlaces ) )\n    {\n        float place = pow(10.0f, float(placeIndex) );\n        float digitValue = floor( value / place );\n        value -= digitValue * place;\n        \n        \n        uint digit = min( uint( digitValue ), 9u );\n        \n        if ( placeIndex == -1 )\n        {\n            PrintCh( state, style, sFontSampler, _PERIOD );\n        }\n        \n        if ( placeIndex == 0 || digit != 0u )\n        {\n            leadingZeros = false;\n        }        \n        \n        if ( !leadingZeros )\n        {\n        \tPrintCh( state, style, sFontSampler, _0 + digit );\n        }\n                \n        placeIndex--;\n    }\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//     _____                       _____                _           _             \n//    / ____|                     |  __ \\              | |         (_)            \n//   | (___   ___ ___ _ __   ___  | |__) |___ _ __   __| | ___ _ __ _ _ __   __ _ \n//    \\___ \\ / __/ _ \\ '_ \\ / _ \\ |  _  // _ \\ '_ \\ / _` |/ _ \\ '__| | '_ \\ / _` |\n//    ____) | (_|  __/ | | |  __/ | | \\ \\  __/ | | | (_| |  __/ |  | | | | | (_| |\n//   |_____/ \\___\\___|_| |_|\\___| |_|  \\_\\___|_| |_|\\__,_|\\___|_|  |_|_| |_|\\__, |\n//                                                                           __/ |\n//                                                                          |___/ \n\n#define FLY_CAM_INVERT_Y 1\n\n#define ENABLE_TAA_JITTER 1\n\n#define kMaxTraceDist 1000.0\n#define kFarDist 1100.0\n\n#define iChannelCurr \t\tiChannel0\n#define iChannelKeyboard \tiChannel3\n\n#define DRAW_CAMERA 1\n#define CAMERA_B\n\n#define CUBE_LUT \t\t0\n#define GENERIC_SCENE \t1\n\n\n//    _____ _          ____                \n//   |  ___| |_   _   / ___|__ _ _ __ ___  \n//   | |_  | | | | | | |   / _` | '_ ` _ \\ \n//   |  _| | | |_| | | |__| (_| | | | | | |\n//   |_|   |_|\\__, |  \\____\\__,_|_| |_| |_|\n//            |___/                        \n//\n\nstruct FlyCamState\n{\n    vec3 vPos;\n    vec3 vAngles;\n    vec4 vPrevMouse;\n};\n\nvoid FlyCam_LoadState( out FlyCamState flyCam, sampler2D sampler, ivec2 addr )\n{\n    vec4 vPos = LoadVec4( sampler, addr + ivec2(0,0) );\n    flyCam.vPos = vPos.xyz;\n    vec4 vAngles = LoadVec4( sampler, addr + ivec2(1,0) );\n    flyCam.vAngles = vAngles.xyz;\n    vec4 vPrevMouse = LoadVec4( sampler, addr + ivec2(2,0) );    \n    flyCam.vPrevMouse = vPrevMouse;\n}\n\nvoid FlyCam_StoreState( ivec2 addr, const in FlyCamState flyCam, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    StoreVec4( addr + ivec2(0,0), vec4( flyCam.vPos, 0 ), fragColor, fragCoord );\n    StoreVec4( addr + ivec2(1,0), vec4( flyCam.vAngles, 0 ), fragColor, fragCoord );\n    StoreVec4( addr + ivec2(2,0), vec4( iMouse ), fragColor, fragCoord );\n}\n\nvoid FlyCam_GetAxes( FlyCamState flyCam, out vec3 vRight, out vec3 vUp, out vec3 vForwards )\n{\n    vec3 vAngles = flyCam.vAngles;\n    mat3 rotX = mat3(1.0, 0.0, 0.0, \n                     0.0, cos(vAngles.x), sin(vAngles.x), \n                     0.0, -sin(vAngles.x), cos(vAngles.x));\n    \n    mat3 rotY = mat3(cos(vAngles.y), 0.0, -sin(vAngles.y), \n                     0.0, 1.0, 0.0, \n                     sin(vAngles.y), 0.0, cos(vAngles.y));    \n\n    mat3 rotZ = mat3(cos(vAngles.z), sin(vAngles.z), 0.0,\n                     -sin(vAngles.z), cos(vAngles.z), 0.0,\n                     0.0, 0.0, 1.0 );\n    \n    \n    mat3 m = rotY * rotX * rotZ;\n    \n    vRight = m[0];\n    vUp = m[1];\n    vForwards = m[2];\n}\n\nbool FlyCam_Update( inout FlyCamState flyCam, vec3 vStartPos, vec3 vStartAngles )\n{    \n    //float fMoveSpeed = 0.01;\n    float fMoveSpeed = iTimeDelta * 0.5;\n    float fRotateSpeed = 3.0;\n    \n    \n    if ( Key_IsPressed( iChannelKeyboard, KEY_SHIFT ) )\n    {\n        fMoveSpeed *= 4.0;\n    }\n    \n    if ( iFrame == 0 )\n    {\n        flyCam.vPos = vStartPos;\n        flyCam.vAngles = vStartAngles;\n        flyCam.vPrevMouse = iMouse;\n    }\n      \n    vec3 vMove = vec3(0.0);\n        \n    if ( Key_IsPressed( iChannelKeyboard, KEY_W ) )\n    {\n        vMove.z += fMoveSpeed;\n    }\n    if ( Key_IsPressed( iChannelKeyboard, KEY_S ) )\n    {\n        vMove.z -= fMoveSpeed;\n    }\n\n    if ( Key_IsPressed( iChannelKeyboard, KEY_A ) )\n    {\n        vMove.x -= fMoveSpeed;\n    }\n    if ( Key_IsPressed( iChannelKeyboard, KEY_D ) )\n    {\n        vMove.x += fMoveSpeed;\n    }\n    \n    vec3 vForwards, vRight, vUp;\n    FlyCam_GetAxes( flyCam, vRight, vUp, vForwards );\n        \n    flyCam.vPos += vRight * vMove.x + vForwards * vMove.z;\n    \n    vec3 vRotate = vec3(0);\n    \n    bool bMouseDown = iMouse.z > 0.0;\n    bool bMouseWasDown = flyCam.vPrevMouse.z > 0.0;\n    \n    if ( bMouseDown && bMouseWasDown )\n    {\n    \tvRotate.yx += ((iMouse.xy - flyCam.vPrevMouse.xy) / iResolution.xy) * fRotateSpeed;\n    }\n    \n#if FLY_CAM_INVERT_Y    \n    vRotate.x *= -1.0;\n#endif    \n    \n    if ( Key_IsPressed( iChannelKeyboard, KEY_E ) )\n    {\n        vRotate.z -= fRotateSpeed * 0.01;\n    }\n    if ( Key_IsPressed( iChannelKeyboard, KEY_Q ) )\n    {\n        vRotate.z += fRotateSpeed * 0.01;\n    }\n        \n\tflyCam.vAngles += vRotate;\n    \n    flyCam.vAngles.x = clamp( flyCam.vAngles.x, -PI * .5, PI * .5 );\n    \n    if ( iFrame < 5 || length(vMove) > 0.0 || length( vRotate ) > 0.0 )\n    {\n        return true;\n    }\n\n    return false;\n}\n\n// PDF\n\nfloat SpecParamFromGloss( float gloss )\n{\n    float PB_GGX_MAX_SPEC_POWER=32.0;\n\tfloat exponent = pow( 2.0f, gloss * PB_GGX_MAX_SPEC_POWER );\n\treturn 2.0f  / ( 2.0f + exponent ); // matches alpha^2 for GGX physically-based shader\n}\n\n\nfloat GGX_D( float NdotH , float alpha2 )\n{\n\tfloat denom = ( NdotH * NdotH ) * ( alpha2 - 1.0f ) + 1.0f;\n\treturn alpha2 / ( denom * denom );\t\n}\n\n\nfloat GGX_PDF( const float NdotH, const in float alpha2 )\n{\n\t//const float LdotH = NdotH;\n\t//return GGX_D( NdotH, alpha2 ) * NdotH  / (4.0f * PI * LdotH);\n\n\t// simplified as NdotH == LdotH\n\treturn GGX_D( NdotH, alpha2 ) / (4.0f * PI);\n}\n\n// Z is preserved, Y may be modified to make matrix orthogonal\nmat3 OrthoNormalMatrixFromZY( vec3 zDirIn, vec3 yHintDir )\n{\n\tvec3 xDir = normalize( cross( zDirIn, yHintDir ) );\n\tvec3 yDir = normalize( cross( xDir, zDirIn ) );\n\tvec3 zDir = normalize( zDirIn );\n\n\tmat3 result = mat3( xDir, yDir, zDir );\n\t\t\n\treturn result;\n}\n\n\nmat3 OrthoNormalMatrixFromZ( vec3 zDir )\n{\n\tif ( abs( zDir.y ) < 0.999f )\n\t{\n\t\tvec3 yAxis = vec3( 0.0f, 1.0f, 0.0f );\n\t\treturn OrthoNormalMatrixFromZY( zDir, yAxis );\n\t}\n\telse\n\t{\n\t\tvec3 xAxis = vec3( 1.0f, 0.0f, 0.0f );\n\t\treturn OrthoNormalMatrixFromZY( zDir, xAxis );\n\t}\n}\n\nvec3 SphericalToCartesianDirection( vec2 spherical )\n{\n\tfloat theta = spherical.x;\n\tfloat phi = spherical.y;\n\tfloat sinTheta = sin( theta );\n\n\treturn vec3( cos( phi ) * sinTheta, sin( phi ) * sinTheta, cos( theta ) );\n}\n\n// Transform from a uniform 2D 0->1 sample space to a spherical co-ordiante with a probability distribution that represents important GGX half-angle vector locations\nvec2 ImportanceSampleGGXTransform( const vec2 uniformSamplePos, const in float alpha2 )\n{\n\t// [Karis2013]  Real Shading in Unreal Engine 4\n\t// http://blog.tobias-franke.eu/2014/03/30/notes_on_importance_sampling.html\n\n\tfloat theta = acos( sqrt( (1.0f - uniformSamplePos.y) /\n\t\t\t\t\t\t\t( (alpha2 - 1.0f) * uniformSamplePos.y + 1.0f )\n\t\t\t\t\t\t\t) );\n\n\tfloat phi = 2.0f * PI * uniformSamplePos.x;\n\n\treturn vec2( theta, phi );\n}\n\n// Transform from a uniform 2D 0->1 sample space to a direction vector with a probability distribution that represents important GGX half-angle vector locations\nvec3 ImportanceSampleGGX( vec2 uniformSamplePos, vec3 N, float alpha2 )\n{\n\tvec2 sphereSamplePos = ImportanceSampleGGXTransform( uniformSamplePos, alpha2 );\n\n\tvec3 specSpaceH = SphericalToCartesianDirection( sphereSamplePos );\n\t\n\tmat3 specToCubeMat = OrthoNormalMatrixFromZ( N );\n\n\treturn specToCubeMat * specSpaceH;\n}\n\n\n\n//    ____                      \n//   / ___|  ___ ___ _ __   ___ \n//   \\___ \\ / __/ _ \\ '_ \\ / _ \\\n//    ___) | (_|  __/ | | |  __/\n//   |____/ \\___\\___|_| |_|\\___|\n//                              \n\nfloat GetSceneTime()\n{\n    //return iTime;\n    return 1.0;\n}\n\nstruct SceneResult\n{\n\tfloat fDist;\n\tint iObjectId;\n    vec3 vUVW;\n};\n    \nSceneResult Scene_Union( SceneResult a, SceneResult b )\n{\n    if ( b.fDist < a.fDist )\n    {\n        return b;\n    }\n    return a;\n}\n\n    \nSceneResult Scene_Subtract( SceneResult a, SceneResult b )\n{\n    if ( a.fDist < -b.fDist )\n    {\n        b.fDist = -b.fDist;\n        return b;\n    }\n    \n    return a;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nSceneResult Scene_SmoothSubtract( SceneResult a, SceneResult b, float k )\n{    \n    float fA = a.fDist;\n    float fB = -b.fDist;        \n    \n    float fC = -smin( -fA, -fB, k );\n    \n    a.fDist = fC;\n    b.fDist = fC;\n    \n    if ( fA < (fB + k) )\n    {        \n        return b;\n    }\n    \n    return a;\n}\n\nSceneResult Scene_GetDistance( vec3 vPos );    \n\nvec3 Scene_GetNormal(const in vec3 vPos)\n{\n    const float fDelta = 0.0001;\n    vec2 e = vec2( -1, 1 );\n    \n    vec3 vNormal = \n        Scene_GetDistance( e.yxx * fDelta + vPos ).fDist * e.yxx + \n        Scene_GetDistance( e.xxy * fDelta + vPos ).fDist * e.xxy + \n        Scene_GetDistance( e.xyx * fDelta + vPos ).fDist * e.xyx + \n        Scene_GetDistance( e.yyy * fDelta + vPos ).fDist * e.yyy;\n    \n    return normalize( vNormal );\n}    \n    \nSceneResult Scene_Trace( const in vec3 vRayOrigin, const in vec3 vRayDir, float minDist, float maxDist )\n{\t\n    SceneResult result;\n    result.fDist = 0.0;\n    result.vUVW = vec3(0.0);\n    result.iObjectId = -1;\n    \n\tfloat t = minDist;\n\tconst int kRaymarchMaxIter = 256;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\t\t\n        float epsilon = 0.0001 * t;\n\t\tresult = Scene_GetDistance( vRayOrigin + vRayDir * t );\n        if ( abs(result.fDist) < epsilon )\n\t\t{\n\t\t\tbreak;\n\t\t}\n                        \n        if ( t > maxDist )\n        {\n            result.iObjectId = -1;\n\t        t = maxDist;\n            break;\n        }       \n        \n        if ( result.fDist > 1.0 )\n        {\n            result.iObjectId = -1;            \n        }    \n        \n        t += result.fDist;        \n\t}\n    \n    result.fDist = t;\n\n\n    return result;\n}    \n\nfloat Scene_TraceShadow( const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fMinDist, const in float fLightDist )\n{\n    //return 1.0;\n    //return ( Scene_Trace( vRayOrigin, vRayDir, 0.1, fLightDist ).fDist < fLightDist ? 0.0 : 1.0;\n    \n\tfloat res = 1.0;\n    float t = fMinDist;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = Scene_GetDistance( vRayOrigin + vRayDir * t ).fDist;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.0001 || t>fLightDist ) break;\n    }\n    return clamp( res, 0.0, 1.0 );    \n}\n\nfloat Scene_GetAmbientOcclusion( const in vec3 vPos, const in vec3 vDir )\n{\n    float fOcclusion = 0.0;\n    float fScale = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float fOffsetDist = 0.001 + 0.1*float(i)/4.0;\n        vec3 vAOPos = vDir * fOffsetDist + vPos;\n        float fDist = Scene_GetDistance( vAOPos ).fDist;\n        fOcclusion += (fOffsetDist - fDist) * fScale;\n        fScale *= 0.4;\n    }\n    \n    return clamp( 1.0 - 30.0*fOcclusion, 0.0, 1.0 );\n}\n\n//    _     _       _     _   _             \n//   | |   (_) __ _| |__ | |_(_)_ __   __ _ \n//   | |   | |/ _` | '_ \\| __| | '_ \\ / _` |\n//   | |___| | (_| | | | | |_| | | | | (_| |\n//   |_____|_|\\__, |_| |_|\\__|_|_| |_|\\__, |\n//            |___/                   |___/ \n//                                          \n    \nstruct SurfaceInfo\n{\n    vec3 vPos;\n    vec3 vNormal;\n    vec3 vBumpNormal;    \n    vec3 vAlbedo;\n    vec3 vR0;\n    float fGloss;\n    vec3 vEmissive;\n};\n    \nSurfaceInfo Scene_GetSurfaceInfo( const in vec3 vRayOrigin,  const in vec3 vRayDir, SceneResult traceResult );\n\nstruct SurfaceLighting\n{\n    vec3 vDiffuse;\n    vec3 vSpecular;\n};\n    \nSurfaceLighting Scene_GetSurfaceLighting( const in vec3 vRayDir, in SurfaceInfo surfaceInfo );\n\nfloat Light_GIV( float dotNV, float k)\n{\n\treturn 1.0 / ((dotNV + 0.0001) * (1.0 - k)+k);\n}\n\nfloat AlphaSqrFromGloss( const in float gloss )\n{\n\tfloat MAX_SPEC = 10.0;\n\treturn 2.0f  / ( 2.0f + exp2( gloss * MAX_SPEC) );\n}\n\nvoid Light_Add(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\n\tfloat fNDotL = clamp(dot(vLightDir, surface.vBumpNormal), 0.0, 1.0);\n\t\n\tlighting.vDiffuse += vLightColour * fNDotL;\n    \n\tvec3 vH = normalize( -vViewDir + vLightDir );\n\tfloat fNdotV = clamp(dot(-vViewDir, surface.vBumpNormal), 0.0, 1.0);\n\tfloat fNdotH = clamp(dot(surface.vBumpNormal, vH), 0.0, 1.0);\n    \n\t// D\n\n\tfloat alphaSqr = AlphaSqrFromGloss( surface.fGloss );\n    float alpha = sqrt( alphaSqr );\n\tfloat denom = fNdotH * fNdotH * (alphaSqr - 1.0) + 1.0;\n\tfloat d = alphaSqr / (PI * denom * denom);\n\n\tfloat k = alpha / 2.0;\n\tfloat vis = Light_GIV(fNDotL, k) * Light_GIV(fNdotV, k);\n\n\tfloat fSpecularIntensity = d * vis * fNDotL;    \n\tlighting.vSpecular += vLightColour * fSpecularIntensity;    \n}\n\nvoid Light_AddPoint(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightPos, const vec3 vLightColour)\n{    \n    vec3 vPos = surface.vPos;\n\tvec3 vToLight = vLightPos - vPos;\t\n    \n\tvec3 vLightDir = normalize(vToLight);\n\tfloat fDistance2 = dot(vToLight, vToLight);\n\tfloat fAttenuation = 100.0 / (fDistance2);\n\t\n\tfloat fShadowFactor = Scene_TraceShadow( surface.vPos, vLightDir, 0.1, length(vToLight) );\n\t\n\tLight_Add( lighting, surface, vViewDir, vLightDir, vLightColour * fShadowFactor * fAttenuation);\n}\n\nfloat Light_SpotFactor( vec3 vLightDir, vec3 vSpotDir, float fSpotInnerAngle, float fSpotOuterAngle )   \n{\n    float fSpotDot = dot( vLightDir, -vSpotDir );\n    \n    float fTheta = acos(fSpotDot);\n\n    float fAngularAttenuation = clamp( (fTheta - fSpotOuterAngle) / (fSpotInnerAngle - fSpotOuterAngle), 0.0, 1.0 );\n    \n    float fShapeT = fTheta / fSpotOuterAngle;\n    fShapeT = fShapeT * fShapeT * fShapeT;\n    float fShape = (sin( (1.0 - fShapeT) * 10.0));\n    fShape = fShape * fShape * (fShapeT) + (1.0 - fShapeT);\n    \n    //return fShape;\n    return fAngularAttenuation * fShape;\n}\n    \n\nvoid Light_AddSpot( inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const vec3 vLightPos, const vec3 vSpotDir, float fSpotInnerAngle, float fSpotOuterAngle, vec3 vLightColour )\n{\n    vec3 vPos = surface.vPos;\n\tvec3 vToLight = vLightPos - vPos;\t\n    \n\tvec3 vLightDir = normalize(vToLight);\n\tfloat fDistance2 = dot(vToLight, vToLight);\n\tfloat fAttenuation = 100.0 / (fDistance2);\n\t\n\tfloat fShadowFactor = Scene_TraceShadow( surface.vPos, vLightDir, 0.1, length(vToLight) );\n    \n    fShadowFactor *= Light_SpotFactor( vLightDir, vSpotDir, fSpotInnerAngle, fSpotOuterAngle );\n\t\n\tLight_Add( lighting, surface, vViewDir, vLightDir, vLightColour * fShadowFactor * fAttenuation);    \n}\n\nvoid Light_AddDirectional(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\t\n\tfloat fAttenuation = 1.0;\n\tfloat fShadowFactor = Scene_TraceShadow( surface.vPos, vLightDir, 0.1, 10.0 );\n\t\n\tLight_Add( lighting, surface, vViewDir, vLightDir, vLightColour * fShadowFactor * fAttenuation);\n}\n\nvec3 Light_GetFresnel( vec3 vView, vec3 vNormal, vec3 vR0, float fGloss )\n{\n    float NdotV = max( 0.0, dot( vView, vNormal ) );\n\n    return vR0 + (vec3(1.0) - vR0) * pow( 1.0 - NdotV, 5.0 ) * pow( fGloss, 20.0 );\n}\n\nvoid Env_AddPointLightFlare(inout vec3 vEmissiveGlow, const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fIntersectDistance, const in vec3 vLightPos, const in vec3 vLightColour)\n{\n    vec3 vToLight = vLightPos - vRayOrigin;\n    float fPointDot = dot(vToLight, vRayDir);\n    fPointDot = clamp(fPointDot, 0.0, fIntersectDistance);\n\n    vec3 vClosestPoint = vRayOrigin + vRayDir * fPointDot;\n    float fDist = length(vClosestPoint - vLightPos);\n\tvEmissiveGlow += sqrt(vLightColour * 0.05 / (fDist * fDist));\n}\n\nvec3 Env_GetDirectionalLightFlare(const in vec3 vRayDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\n\tfloat fDirDot = clamp(dot(vLightDir, vRayDir) * 0.5 + 0.5, 0.0, 1.0);\n\t//float kSpreadPower = 5.0;\n\t//return vLightColour * pow(fDirDot, kSpreadPower) * 0.25;\n    \n    return exp2( vLightColour * fDirDot * 0.1);\n}\n\n//    ____                _           _             \n//   |  _ \\ ___ _ __   __| | ___ _ __(_)_ __   __ _ \n//   | |_) / _ \\ '_ \\ / _` |/ _ \\ '__| | '_ \\ / _` |\n//   |  _ <  __/ | | | (_| |  __/ |  | | | | | (_| |\n//   |_| \\_\\___|_| |_|\\__,_|\\___|_|  |_|_| |_|\\__, |\n//                                            |___/ \n//                                                  \n\nvec4 Env_GetSkyColor( vec3 vViewPos, vec3 vViewDir, bool bDrawSun );\nvec3 Env_ApplyAtmosphere( const in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist );\nvec3 FX_Apply( in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist);\n\nvec4 Scene_GetColorAndDepth( vec3 vRayOrigin, vec3 vRayDir )\n{\n\tvec3 vResultColor = vec3(0.0);\n            \n\tSceneResult firstTraceResult;\n    \n    float fStartDist = 0.0f;\n    float fMaxDist = kMaxTraceDist;\n    \n    vec3 vRemaining = vec3(1.0);\n    \n\tfor( int iPassIndex=0; iPassIndex < 3; iPassIndex++ )\n    {\n    \tSceneResult traceResult = Scene_Trace( vRayOrigin, vRayDir, fStartDist, fMaxDist );\n\n        if ( iPassIndex == 0 )\n        {\n            firstTraceResult = traceResult;\n        }\n        \n        vec3 vColor = vec3(0);\n        vec3 vReflectAmount = vec3(0);\n        \n\t\tif( traceResult.iObjectId < 0 )\n\t\t{\n            bool bDrawSun = (iPassIndex == 0);\n            vColor = Env_GetSkyColor( vRayOrigin, vRayDir, bDrawSun ).rgb;\n            float fDist = abs(length(vRayDir.xz) * 20.0 / vRayDir.y);\n\t\t\tvColor = Env_ApplyAtmosphere( vColor, vRayOrigin, vRayDir, fDist );\n        }\n        else\n        {\n            \n            SurfaceInfo surfaceInfo = Scene_GetSurfaceInfo( vRayOrigin, vRayDir, traceResult );\n            SurfaceLighting surfaceLighting = Scene_GetSurfaceLighting( vRayDir, surfaceInfo );\n                \n            // calculate reflectance (Fresnel)\n\t\t\tvReflectAmount = Light_GetFresnel( -vRayDir, surfaceInfo.vBumpNormal, surfaceInfo.vR0, surfaceInfo.fGloss );\n\t\t\t\n\t\t\tvColor = (surfaceInfo.vAlbedo * surfaceLighting.vDiffuse + surfaceInfo.vEmissive) * (vec3(1.0) - vReflectAmount); \n            \n            vec3 vReflectRayOrigin = surfaceInfo.vPos;\n                        \n            vec3 vReflectRayDir = normalize( reflect( vRayDir, surfaceInfo.vBumpNormal ) );\n\n            \n            {\n                float alpha2 = SpecParamFromGloss(surfaceInfo.fGloss);\n                \n                vec2 vRand = hash23( vRayOrigin + vRayDir + iTime );\n\n                vec3 N = surfaceInfo.vBumpNormal;\n                vec3 V = -vRayDir;\n                vec3 H = ImportanceSampleGGX( vRand, N, alpha2 );        \n\n\t\t\t\tvReflectRayDir = reflect( -V, H );                \n            }\n\t\t\t\n            \n            \n            fStartDist = 0.001 / max(0.0000001,abs(dot( vReflectRayDir, surfaceInfo.vNormal ))); \n\n            vColor += surfaceLighting.vSpecular * vReflectAmount;            \n\n\t\t\tvColor = Env_ApplyAtmosphere( vColor, vRayOrigin, vRayDir, traceResult.fDist );\n\t\t\tvColor = FX_Apply( vColor, vRayOrigin, vRayDir, traceResult.fDist );\n            \n            vRayOrigin = vReflectRayOrigin;\n            vRayDir = vReflectRayDir;\n        }\n        \n        vResultColor += vColor * vRemaining;\n        vRemaining *= vReflectAmount;        \n    }\n \n    return vec4( vResultColor, EncodeDepthAndObject( firstTraceResult.fDist, firstTraceResult.iObjectId ) );\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n//    ____                        ____                      _       _   _             \n//   / ___|  ___ ___ _ __   ___  |  _ \\  ___  ___  ___ _ __(_)_ __ | |_(_) ___  _ __  \n//   \\___ \\ / __/ _ \\ '_ \\ / _ \\ | | | |/ _ \\/ __|/ __| '__| | '_ \\| __| |/ _ \\| '_ \\ \n//    ___) | (_|  __/ | | |  __/ | |_| |  __/\\__ \\ (__| |  | | |_) | |_| | (_) | | | |\n//   |____/ \\___\\___|_| |_|\\___| |____/ \\___||___/\\___|_|  |_| .__/ \\__|_|\\___/|_| |_|\n//                                                           |_|                      \n//\n\n// Materials\n\nint MAT_DEFAULT = 0,\n    MAT_GRASS = 1,\n    MAT_CAMERA_BODY = 2,\n    MAT_CAMERA_LENS = 3,\n    MAT_CAMERA_BARREL = 4,\n    MAT_CHROME = 5,\n    MAT_COLOR = 6;\n\n\n\nSurfaceInfo Scene_GetSurfaceInfo( const in vec3 vRayOrigin,  const in vec3 vRayDir, SceneResult traceResult )\n{\n    SurfaceInfo surfaceInfo;\n    \n    surfaceInfo.vPos = vRayOrigin + vRayDir * (traceResult.fDist);\n    \n    surfaceInfo.vNormal = Scene_GetNormal( surfaceInfo.vPos ); \n    surfaceInfo.vBumpNormal = surfaceInfo.vNormal;\n    surfaceInfo.vAlbedo = vec3(1.0);\n    surfaceInfo.vR0 = vec3( 0.02 );\n    surfaceInfo.fGloss = 1.0;\n    surfaceInfo.vEmissive = vec3( 0.0 );\n        \n    if ( traceResult.iObjectId == MAT_DEFAULT )\n    {\n        surfaceInfo.vAlbedo = vec3(0.75, 0.75, 0.75); \n\t    surfaceInfo.fGloss = 0.9;\n    \tsurfaceInfo.vR0 = vec3( 0.02 );\n    }\n\n    if ( traceResult.iObjectId == MAT_COLOR )\n    {\n        surfaceInfo.vAlbedo = traceResult.vUVW.xyz; \n\t    surfaceInfo.fGloss = 0.2;\n    \tsurfaceInfo.vR0 = vec3( 0.01 );\n    }\n    \n    if ( traceResult.iObjectId == MAT_GRASS )\n    {\n        surfaceInfo.vAlbedo = vec3(0.15, 0.3, 0.02); \n        \n        //float fShade = textureLod( iChannel1, traceResult.vUVW.zx * 0.5, 0.0 ).r;\n        float fShade = FBM( traceResult.vUVW.zx * 4.0, 0.9 );\n                \n        fShade = sqrt( 1.0 - fShade ) * 0.5 + 0.5;\n        \n        float fPattern = FBM( traceResult.vUVW.zx * vec2(.1,3) * 4.0, 0.8 );\n        //float fPattern = textureLod( iChannel1, traceResult.vUVW.zx * vec2(.1,3), 0.0 ).r;\n        \n        fShade *= 0.5 + 0.5 * fPattern;\n                \n        surfaceInfo.vAlbedo *= fShade;\n\t    surfaceInfo.fGloss = 0.7 * fShade;\n    \tsurfaceInfo.vR0 = vec3( 0.02 );\n    }\n    \n    if ( traceResult.iObjectId == MAT_CAMERA_BODY )\n    {        \n        surfaceInfo.vAlbedo = vec3( 0.03 );                \n        \n#ifdef CAMERA_B\n        surfaceInfo.vAlbedo = vec3( 0.05 ); \n#endif        \n\t\tsurfaceInfo.fGloss = 0.8;\n    \tsurfaceInfo.vR0 = vec3( 0.02 );        \n    }\n    \n    if ( traceResult.iObjectId == MAT_CAMERA_LENS )\n    {\n        surfaceInfo.vAlbedo = vec3( 0.05 ); \n\t    surfaceInfo.fGloss = 0.95;\n    \tsurfaceInfo.vR0 = vec3( 0.1 );        \n    }    \n\n    if ( traceResult.iObjectId == MAT_CAMERA_BARREL )\n    {\n        surfaceInfo.vAlbedo = vec3( 0.02 ); \n\t    surfaceInfo.fGloss = 0.1;\n    \tsurfaceInfo.vR0 = vec3( 0.02 );        \n    }    \n\n    if ( traceResult.iObjectId == MAT_CHROME )\n    {\n        surfaceInfo.vAlbedo = vec3( 0.02 ); \n\t    surfaceInfo.fGloss = 0.5;\n    \tsurfaceInfo.vR0 = vec3( 0.9 );        \n    }   \n    \n#if DRAW_CAMERA    \n    if ( traceResult.iObjectId == MAT_CAMERA_BODY )\n    {        \n        LayoutStyle style = LayoutStyle_Default();\n        RenderStyle renderStyle = RenderStyle_Default( vec3(0.2, 0.2, 0.5) );\n\n        vec2 vPrintUV = traceResult.vUVW.zy;//traceResult.vUVW.yz;\n        vPrintUV.x = 1.0f - vPrintUV.x;\n        vPrintUV.y = 1.0f - vPrintUV.y;\n        PrintState state = PrintState_InitCanvas( vPrintUV, vec2(0.001f) );\n        \n        //style.vSize = vec2(0.03, 0.05);\n        style.vSize = vec2(0.08, 0.08);\n\n        vec2 vPos = vec2(0.895, -0.025 );\n        MoveTo( state, vec2(vPos.x, 1.0 - vPos.y ) );\n\n#ifdef CAMERA_B        \n        uint str[] = uint[] ( _C, _a, _m, _SP, _B );\n#else\n        uint str[] = uint[] ( _C, _a, _m, _SP, _A );\n#endif\n        \n        ARRAY_PRINT( state, style, iChannel2, str );   \n        RenderFont( state, style, renderStyle, surfaceInfo.vAlbedo );\n        \n        \n    }\n#endif    \n    \n        \n    return surfaceInfo;\n}\n\n// Scene Description\n\n\n// https://www.shadertoy.com/view/Xds3zN\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n#if 1\n    // distance bound\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n#else\n    // correct distance\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n#endif\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1-r2)/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nvec3 DomainRotateSymmetry( vec3 vPos, const in float fSteps )\n{\n\tfloat angle = atan( vPos.x, vPos.z );\n\t\n\tfloat fScale = fSteps / (PI * 2.0);\n\tfloat steppedAngle = (floor(angle * fScale + 0.5)) / fScale;\n\t\n\tfloat s = sin(-steppedAngle);\n\tfloat c = cos(-steppedAngle);\n\t\n\tvec3 vResult = vec3( c * vPos.x + s * vPos.z, \n\t\t\t     vPos.y,\n\t\t\t     -s * vPos.x + c * vPos.z);\n\t\n\treturn vResult;\n}\n\n\nSceneResult Scene_GetDistanceCamera( vec3 vPos )\n{\n    SceneResult result;\n    \n    vec3 vBodySize = vec3(0.08, 0.1, 0.2);\n    float fBevel = 0.01;\n#ifdef CAMERA_B\n    vBodySize.z *= 0.8;\n    fBevel = 0.002;\n#endif\n    \n    \n    \n    float fD1 = udRoundBox( vPos, vBodySize, fBevel);\n\n    \n    vec3 vEyePiecePos = vec3(0,0.05, - vBodySize.z -0.03);\n    float fD2 = udRoundBox( vPos - vEyePiecePos, vec3(0.04, 0.02, 0.02), 0.01);\n    float fD3 = udRoundBox( vPos - vEyePiecePos - vec3(0,0,-0.03), vec3(0.04, 0.02, 0.02) - 0.005, 0.01);\n    \n    SceneResult lensResult;\n    lensResult.fDist = fD3;\n    lensResult.iObjectId = MAT_CAMERA_LENS;\n    lensResult.vUVW = vPos;\n    \n    \n    result.fDist = min( fD1, fD2 );\n\n    // side bit\n    \n    vec3 vSideBitSize = vec3(0.01, 0.07, 0.1);\n    vec3 vTopBitSize = vec3(0.05, 0.025, 0.025);\n    vec3 vTopBitOffset = vec3(0.0,0,0.1);\n    \n#ifdef CAMERA_B\n    vSideBitSize.y *= 0.7;\n    vSideBitSize.z *= 1.1;\n\n    vTopBitSize = vec3(0.05, 0.025, 0.05);\n    vTopBitOffset = vec3(0.0,0,-0.1);    \n#endif    \n    float fD4 = udRoundBox( vPos - vec3(vBodySize.x,0,0), vSideBitSize, fBevel * 2.0);    \n    result.fDist = min( result.fDist, fD4 );\n\n    // top bit\n    float fTop = udRoundBox( vPos - vec3(0,vBodySize.y,0)-vTopBitOffset, vTopBitSize, fBevel * 2.0);    \n    result.fDist = min( result.fDist, fTop );\n    \n    result.vUVW = vPos;\n\tresult.iObjectId = MAT_CAMERA_BODY;\n\n    vec3 vBarrelDomain = (vPos - vec3(0,0,vBodySize.z)).xzy;\n    float fD5 = sdCylinder( vBarrelDomain, vec2(0.06, 0.1) );\n    result.fDist = min( result.fDist, fD5 );\n    float fD6 = sdCylinder( vBarrelDomain - vec3(0,0.1,0), vec2(0.08, 0.05) );\n    \n#ifndef CAMERA_B\n    fD6 = sdConeSection( vBarrelDomain - vec3(0,0.1,0), 0.05, 0.07, 0.09 );\n#endif\n    \n    result.fDist = min( result.fDist, fD6 );\n\n    // tripod etc.\n    float fT1 = sdCylinder( vPos - vec3(0,-0.1,0), vec2(0.03, 0.2) );\n    result.fDist = min( result.fDist, fT1 );\n\n    float fT2 = sdCylinder( vPos - vec3(0,-0.2,0), vec2(0.05, 0.01) );\n    result.fDist = min( result.fDist, fT2 );\n\n    vec3 vLegDomain = vPos - vec3(0,-0.25,0 );\n    vLegDomain = DomainRotateSymmetry( vLegDomain, 3.0 );\n    float fL1 = sdCapsule( vLegDomain, vec3(0), vec3(0, -1, 0.4), 0.01 );            \n    result.fDist = min( result.fDist, fL1 );\n    \n    result = Scene_Subtract( result, lensResult );\n    \n#ifndef CAMERA_B    \n    if ( vPos.z >= 0.249 )\n    {\n        result.iObjectId = MAT_CAMERA_BARREL;\n    }\n#endif\n    \n    if ( vPos.y < -0.3 )\n    {\n         result.iObjectId = MAT_CHROME;\n    }\n    \n    \n    return result;\n}\n\n\n\n#if CUBE_LUT\n\nSceneResult Scene_GetDistance( vec3 vPos )\n{\n    SceneResult result;\n    \n    float fScale = 1.0 / 31.0;\n    \n    vec3 vCubeDomain = vPos / fScale;\n    \n    vec3 vCubeIndex = floor( vCubeDomain );\n    vCubeIndex = clamp( vCubeIndex, vec3(0.0), vec3(31.0) );\n    vCubeDomain = vCubeDomain - vCubeIndex;\n    vCubeDomain -= 0.5;\n    \n    vec3 vDistCube = abs(vCubeDomain) - 0.4;\n    \n    float fDistCube = max( vDistCube.x, max( vDistCube.y, vDistCube.z ) );\n    \n\n    result.fDist = fDistCube * fScale; \n    result.vUVW = vCubeIndex / 31.0;\n    result.vUVW = result.vUVW * result.vUVW;\n\tresult.iObjectId = MAT_COLOR;\n    \n    SceneResult resultAxis;\n\n    float d1 = length( vPos.xz + 0.02) - 0.01;\n    d1 = max( d1, -vPos.y );\n    d1 = max( d1, vPos.y - 1.2);\n    float d2 = length( vPos.yz + 0.02) - 0.01;\n    d2 = max( d2, -vPos.x );\n    d2 = max( d2, vPos.x - 1.2);\n    float d3 = length( vPos.xy + 0.02) - 0.01;\n    d3 = max( d3, -vPos.z );\n    d3 = max( d3, vPos.z - 1.2);\n    \n    resultAxis.fDist =  min( d1, min( d2, d3 ) );\n    resultAxis.vUVW = vec3(0);\n\tresultAxis.iObjectId = MAT_CAMERA_BODY;\n    \n    result = Scene_Union( result, resultAxis );    \n    \n    return result;\n}\n\n\n#endif\n\n#if GENERIC_SCENE\n    \nSceneResult Scene_GetDistance( vec3 vPos )\n{\n    SceneResult result;\n\n    float fFloorDist = vPos.y;\n    \n    vec2 vUV = vPos.xz - 100.0;\n    vUV.x *= 0.8;\n    \n    float fFreq = 0.125;\n    float fAmp = 2.0;\n    for ( int i=0; i<3; i++ )\n    {\n    \tfFloorDist += (sin( vUV.x * fFreq ) + sin( vUV.y * fFreq)) * fAmp;\n        fFreq *= 2.0;\n        fAmp *= 0.25;\n    }\n    \n    result.fDist = fFloorDist; \n    result.vUVW = vPos;\n\tresult.iObjectId = MAT_GRASS;\n    \n#if DRAW_CAMERA    \n    SceneResult resultCamera = Scene_GetDistanceCamera( vec3( -vPos.z, vPos.y, -vPos.x) );\n    \n    result = Scene_Union( result, resultCamera );\n#endif    \n    \n    return result;\n}\n\n#endif\n\n\n// Scene Lighting\n\n#if CUBE_LUT\nvec3 g_vSunDir = normalize(vec3(0.3, 0.4, 0.5));\nvec3 g_vSunColor = vec3(1, 1, 1) * 2.0;\nvec3 g_vAmbientColor = vec3(5.0);\n#else\nvec3 g_vSunDir = normalize(vec3(0.3, 0.4, -0.5));\nvec3 g_vSunColor = vec3(1, 0.95, 0.8) * 10.0;\nvec3 g_vAmbientColor = vec3(0.5, 0.6, 1.0) * 1.0;\n#endif\n\nfloat Env_GetCloudCover( vec2 vCloudUV );\n\nSurfaceLighting Scene_GetSurfaceLighting( const in vec3 vViewDir, in SurfaceInfo surfaceInfo )\n{\n    SurfaceLighting surfaceLighting;\n    \n    surfaceLighting.vDiffuse = vec3(0.0);\n    surfaceLighting.vSpecular = vec3(0.0);    \n    \n    float fCloudCover = Env_GetCloudCover( -surfaceInfo.vPos.xz * 0.0003 );\n    \n    fCloudCover = clamp( 1.0 - fCloudCover / 2.0, 0.0, 1.0);\n    \n    Light_AddDirectional( surfaceLighting, surfaceInfo, vViewDir, g_vSunDir, g_vSunColor * fCloudCover );\n    \n    //vec3 vSpotPos, vSpotTarget;\n    //GetSpotState(vSpotPos, vSpotTarget);\n    //vec3 vSpotDir = normalize( vSpotTarget - vSpotPos );\n    \n    //vec3 vLightCol = GetSpotColor();\n    \n    //Light_AddSpot( surfaceLighting, surfaceInfo, vViewDir, vSpotPos, vSpotDir, radians(10.0), radians(60.0), vLightCol * 0.02 );\n    //Light_AddPoint( surfaceLighting, surfaceInfo, vViewDir, vSpotPos, vLightCol * 0.001 );\n    \n    float fAO = Scene_GetAmbientOcclusion( surfaceInfo.vPos, surfaceInfo.vNormal );\n    // AO\n    surfaceLighting.vDiffuse += fAO * (surfaceInfo.vBumpNormal.y * 0.5 + 0.5) * g_vAmbientColor;\n    \n    return surfaceLighting;\n}\n\n// Environment\n\nvec3 Env_GetSkyGradient( vec3 vViewPos, vec3 vViewDir )\n{\n    vec3 vSkyA = vec3(0.001,0.2,1);\n    vec3 vSkyB = vec3(0.01,0.2,1);\n    \n    float fSkyBlend = clamp( vViewDir.y, 0.0, 1.0 );\n    \n    return mix( vSkyA, vSkyB, fSkyBlend ) * 1.5;\n}\n\nfloat Env_GetCloudCover( vec2 vCloudUV )\n{\n\tvCloudUV += GetSceneTime() * 0.01;\n    \n\tvec3 vCloud = 1.0 - textureLod(iChannel1, vCloudUV, 0.0).rgb;    \n\t\n\tfloat fBlend = vCloud.r;\n    \n    float fCover = 0.2;\n    \n    fBlend = clamp( (fBlend - fCover) / (1.0 - fCover), 0.0, 1.0);\n    \n    fBlend = fBlend * fBlend * 3.0;\n    \n    return fBlend;\n}\n\nvec4 Env_GetSkyColor( vec3 vViewPos, vec3 vViewDir, bool drawSun )\n{\n    \n#if CUBE_LUT\n    float i = 50.0;\n    return vec4(i, i, i, kFarDist);\n#endif    \n\tvec4 vResult = vec4( 0.0, 0.0, 0.0, kFarDist );\n   \n    vResult.rgb = Env_GetSkyGradient( vViewPos, vViewDir );\n    \n    \n#if 0\n    vec3 vEnvMap = textureLod( iChannel1, vViewDir.zyx, 0.0 ).rgb;\n    vEnvMap = vEnvMap * vEnvMap;\n    float kEnvmapExposure = 0.999;\n    vResult.rgb = -log2(1.0 - vEnvMap * kEnvmapExposure);\n\n#endif\n    \n    // Sun\n    if ( drawSun )\n    {\n    \tfloat NdotV = dot( g_vSunDir, vViewDir );\n    \tvResult.rgb += smoothstep( cos(radians(.7)), cos(radians(.5)), NdotV ) * g_vSunColor * 5000.0;\n    }\n\n\t// Cloud\n\tvec2 vCloudUV = 0.02 * vViewDir.xz / -vViewDir.y;\n\tfloat fBlend = Env_GetCloudCover( vCloudUV );\n\tvResult.rgb = vResult.rgb * clamp(1.0 - fBlend, 0.0, 1.0) + fBlend;\n    \n    return vResult;\t\n}\n\nfloat Env_GetFogFactor(const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist )\n{    \n\tfloat kFogDensity = 0.0001;\n\treturn exp(fDist * -kFogDensity);\t\n}\n\nvec3 Env_GetFogColor( vec3 vPos, vec3 vDir)\n{    \n\treturn Env_GetSkyGradient( vPos, vDir );//vec3(0.5, 0.45, 0.4) * 2.0;\t\t\n}\n\nfloat Env_GetSunFogFactor(const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist )\n{    \n\tfloat kFogDensity = 0.01;\n\treturn exp(fDist * -kFogDensity);\t\n}\n\nvec3 Env_ApplyAtmosphere( const in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist )\n{\n    //return vColor;\n    vec3 vResult = vColor;\n    \n    \n\tfloat fFogFactor = Env_GetFogFactor( vRayOrigin, vRayDir, fDist );\n\tvec3 vFogColor = Env_GetFogColor( vRayOrigin, vRayDir );\t\n    vResult = mix( vFogColor, vResult, fFogFactor );\n\n    vec3 vSunFlare = Env_GetDirectionalLightFlare( vRayDir, g_vSunDir, g_vSunColor );\n    \n    float fSunFogFactor = Env_GetSunFogFactor( vRayOrigin, vRayDir, fDist );\n    \n    vResult += vSunFlare * (1.0 -  fSunFogFactor);\n\t//Env_AddDirectionalLightFlareToFog( vFogColor, vRayDir, g_vSunDir, g_vSunColor * 1.0);    \n    \n    return vResult;\t    \n}\n\n\nvec3 FX_Apply( in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist)\n{    \n    return vColor;\n}\n\n\nvec4 MainCommon( vec3 vRayOrigin, vec3 vRayDir )\n{\n\tvec4 vColorLinAndDepth = Scene_GetColorAndDepth( vRayOrigin, vRayDir );    \n    vColorLinAndDepth.rgb = max( vColorLinAndDepth.rgb, vec3(0.0) );\n    \n    vec4 vFragColor = vColorLinAndDepth;\n    \n    float fExposure = 2.0f;\n    \n    vFragColor.rgb *= fExposure;\n    \n    vFragColor.a = vColorLinAndDepth.w;\n    \n    return vFragColor;\n}\n\n\nvoid mainImage( out vec4 vFragColor, in vec2 vFragCoord )\n{\n    vec2 vUV = vFragCoord.xy / iResolution.xy; \n\n    FlyCamState flyCam;\n    \n    FlyCam_LoadState( flyCam, iChannelCurr, ivec2(4,0) );\n        \n\tbool bMoved = FlyCam_Update( flyCam, vec3(0.0, 0.2, 0.0), vec3(-0.1, 4.5, 0.1) );\n    \n    CameraState cam;\n\n#if 1\n    vec3 vForwards, vRight, vUp;\n    FlyCam_GetAxes( flyCam, vRight, vUp, vForwards );\n    \n    cam.vPos = flyCam.vPos;\n    cam.vTarget = flyCam.vPos + vForwards;\n    cam.vUp = vUp;\n    cam.fFov = 25.0;\n    cam.fPlaneInFocus = 1.0;\n    \n    SceneResult focusTrace = Scene_Trace( flyCam.vPos, vForwards, 0.0, 100.0 );\n    cam.fPlaneInFocus = min( focusTrace.fDist, 3.0);\n#endif\n    \n#ifdef ENABLE_TAA_JITTER\n    cam.vJitter = hash21( fract( iTime ) ) - 0.5f;\n#endif\n    \n    float fAspectRatio = iResolution.x / iResolution.y;            \n    \n    vec3 vRayOrigin, vRayDir;\n    vec2 vJitterUV = vUV + cam.vJitter / iResolution.xy;\n    Cam_GetCameraRay( vJitterUV, fAspectRatio, cam, vRayOrigin, vRayDir );\n \n    float fHitDist = 0.0f;\n    vFragColor = MainCommon( vRayOrigin, vRayDir );    \n    \n    if ( !bMoved )\n    {\n\t    vec3 vPrev = texelFetch( iChannel0, ivec2( vFragCoord.xy ), 0 ).rgb;\n\t    vFragColor.rgb = mix( vPrev, vFragColor.rgb, 0.01 );\n    }\n    \n    FlyCam_StoreState( ivec2(4,0), flyCam, vFragColor, ivec2(vFragCoord.xy) );\n\tCam_StoreState( ivec2(0), cam, vFragColor, ivec2(vFragCoord.xy) );    \n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}