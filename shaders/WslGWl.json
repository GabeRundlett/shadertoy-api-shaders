{
    "Shader": {
        "info": {
            "date": "1549787641",
            "description": "Cloud raymarching sample. This is cloned from https://www.shadertoy.com/view/lss3zr\n\nI also post an article of detail of this post.\nhttps://qiita.com/edo_m18/items/cbba0cc4e33a5aa3be55",
            "flags": 0,
            "hasliked": 0,
            "id": "WslGWl",
            "likes": 174,
            "name": "Cloud raymarching",
            "published": 3,
            "tags": [
                "raymarching",
                "cloud",
                "cineshader"
            ],
            "usePreview": 1,
            "username": "edo_m18",
            "viewed": 277017
        },
        "renderpass": [
            {
                "code": "// ------------------------------------------\n//\n// This post cloned from \"https://www.shadertoy.com/view/lss3zr\"\n//\n// I also refer this blog post below.\n// https://shaderbits.com/blog/creating-volumetric-ray-marcher\n//\n// This post is to learn how to cloud raymarching is working.\n//\n// ------------------------------------------\n\n#define USE_LIGHT 0\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64);\n\nfloat hash(float n)\n{\n    return fract(sin(n) * 43758.5453);\n}\n\n///\n/// Noise function\n///\nfloat noise(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    \n    f = f * f * (3.0 - 2.0 * f);\n    \n    float n = p.x + p.y * 57.0 + 113.0 * p.z;\n    \n    float res = mix(mix(mix(hash(n +   0.0), hash(n +   1.0), f.x),\n                        mix(hash(n +  57.0), hash(n +  58.0), f.x), f.y),\n                    mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n                        mix(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z);\n    return res;\n}\n\n///\n/// Fractal Brownian motion.\n///\n/// Refer to:\n/// EN: https://thebookofshaders.com/13/\n/// JP: https://thebookofshaders.com/13/?lan=jp\n///\nfloat fbm(vec3 p)\n{\n    float f;\n    f  = 0.5000 * noise(p); p = m * p * 2.02;\n    f += 0.2500 * noise(p); p = m * p * 2.03;\n    f += 0.1250 * noise(p);\n    return f;\n}\n\n//////////////////////////////////////////////////\n\n///\n/// Sphere distance function.\n///\n/// But this function return inverse value.\n/// Normal dist function is like below.\n/// \n/// return length(pos) - 0.1;\n///\n/// Because this function is used for density.\n///\nfloat scene(in vec3 pos)\n{\n    return 0.1 - length(pos) * 0.05 + fbm(pos * 0.3);\n}\n\n///\n/// Get normal of the cloud.\n///\nvec3 getNormal(in vec3 p)\n{\n    const float e = 0.01;\n    return normalize(vec3(scene(vec3(p.x + e, p.y, p.z)) - scene(vec3(p.x - e, p.y, p.z)),\n                          scene(vec3(p.x, p.y + e, p.z)) - scene(vec3(p.x, p.y - e, p.z)),\n                          scene(vec3(p.x, p.y, p.z + e)) - scene(vec3(p.x, p.y, p.z - e))));\n}\n\n///\n/// Create a camera pose control matrix.\n///\nmat3 camera(vec3 ro, vec3 ta)\n{\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(0.0, 1.0, 0.0);\n    vec3 cu = cross(cw, cp);\n    vec3 cv = cross(cu, cw);\n    return mat3(cu, cv, cw);\n}\n\n///\n/// Main function.\n///\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec2 mo = vec2(iTime * 0.1, cos(iTime * 0.25) * 3.0);\n    \n    // Camera\n    float camDist = 25.0;\n    \n    // target\n    vec3 ta = vec3(0.0, 1.0, 0.0);\n    \n    // Ray origin\n    //vec3 ori = vec3(sin(iTime) * camDist, 0, cos(iTime) * camDist);\n    vec3 ro = camDist * normalize(vec3(cos(2.75 - 3.0 * mo.x), 0.7 - 1.0 * (mo.y - 1.0), sin(2.75 - 3.0 * mo.x)));\n    \n    float targetDepth = 1.3;\n    \n    // Camera pose.\n    mat3 c = camera(ro, ta);\n    vec3 dir = c * normalize(vec3(uv, targetDepth));\n    \n    // For raymarching const values.\n    const int sampleCount = 64;\n    const int sampleLightCount = 6;\n    const float eps = 0.01;\n    \n    // Raymarching step settings.\n    float zMax = 40.0;\n    float zstep = zMax / float(sampleCount);\n    \n    float zMaxl = 20.0;\n    float zstepl = zMaxl / float(sampleLightCount);\n    \n    // Easy access to the ray origin\n    vec3 p = ro;\n    \n    // Transmittance\n    float T = 1.0;\n    \n    // Substantially transparency parameter.\n    float absorption = 100.0;\n    \n    // Light Direction\n    vec3 sun_direction = normalize(vec3(1.0, 0.0, 0.0));\n    \n    // Result of culcration\n    vec4 color = vec4(0.0);\n    \n    for (int i = 0; i < sampleCount; i++)\n    {\n        // Using distance function for density.\n        // So the function not normal value.\n        // Please check it out on the function comment.\n        float density = scene(p);\n        \n        // The density over 0.0 then start cloud ray marching.\n        // Why? because the function will return negative value normally.\n        // But if ray is into the cloud, the function will return positive value.\n        if (density > 0.0)\n        {\n            // Let's start cloud ray marching!\n            \n            // why density sub by sampleCount?\n            // This mean integral for each sampling points.\n            float tmp = density / float(sampleCount);\n            \n            T *= 1.0 - (tmp * absorption);\n            \n            // Return if transmittance under 0.01. \n            // Because the ray is almost absorbed.\n            if (T <= 0.01)\n            {\n                break;\n            }\n            \n            #if USE_LIGHT == 1\n            // Light scattering\n            \n            // Transmittance for Light\n            float Tl = 1.0;\n            \n            // Start light scattering with raymarching.\n            \n            // Raymarching position for the light.\n            vec3 lp = p;\n            \n            // Iteration of sampling light.\n            for (int j = 0; j < sampleLightCount; j++)\n            {\n                float densityLight = scene(lp);\n                \n                // If densityLight is over 0.0, the ray is stil in the cloud.\n                if (densityLight > 0.0)\n                {\n                    float tmpl = densityLight / float(sampleCount);\n                    Tl *= 1.0 - (tmpl * absorption);\n                }\n                \n                if (Tl <= 0.01)\n                {\n                    break;\n                }\n                \n                // Step to next position.\n                lp += sun_direction * zstepl;\n            }\n            #endif\n            \n            // Add ambient + light scattering color\n            float opaity = 50.0;\n            float k = opaity * tmp * T;\n            vec4 cloudColor = vec4(1.0);\n            vec4 col1 = cloudColor * k;\n            \n            #if USE_LIGHT == 1\n            float opacityl = 30.0;\n            float kl = opacityl * tmp * T * Tl;\n            vec4 lightColor = vec4(1.0, 0.7, 0.9, 1.0);\n            vec4 col2 = lightColor * kl;\n            #else\n            vec4 col2 = vec4(0.0);\n            #endif\n            \n            color += col1 + col2;\n        }\n        \n        p += dir * zstep;\n    }\n    \n    vec3 bg = mix(vec3(0.3, 0.1, 0.8), vec3(0.7, 0.7, 1.0), 1.0 - (uv.y + 1.0) * 0.5);\n    color.rgb += bg;\n    \n\tfragColor = color;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}