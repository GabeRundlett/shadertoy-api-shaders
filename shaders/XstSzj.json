{
    "Shader": {
        "info": {
            "date": "1460308401",
            "description": "Just came across this https://en.wikipedia.org/wiki/Wireworld and it made me a nice sunday afternoon.\nSelect brush from top bar, cross to move view, lens to zoom, cyan fader to change processing speed.\nRewind to init with clocks of various lengths\n\n",
            "flags": 32,
            "hasliked": 0,
            "id": "XstSzj",
            "likes": 40,
            "name": "Wireworld CA",
            "published": 3,
            "tags": [
                "automata",
                "cellular",
                "automaton"
            ],
            "usePreview": 0,
            "username": "bergi",
            "viewed": 1545
        },
        "renderpass": [
            {
                "code": "/** Wireworld Cellular Automaton\n\tLicense Creative Commons NonCommercial Share-Alike 3.0 Unported\n\t(cc) 2016, Stefan Berke\n\n\tOrange cells are wire,\n\tBlue cells are electron heads, \n\tReds a are electron tails.\n\t\n\tTransition rule:\n\t\thead becomes tail,\n\t\ttail becomes wire,\n\t\twire becomes head if 1 or 2 neighbours are heads\n\n\tThe CA can process arbitrary logic functions\n\tand is generally easier to program for than the Game of Life ;)\n\n\tTop bar:\n\t\tSelect brush 1-4, \n \t\tcross to move view, lens to zoom,\n\t\tcyan bar to change processing speed\n\t\n*/\n\n// wireworld states\n#define S_EMPTY 0\n#define S_HEAD  1\n#define S_TAIL  2\n#define S_WIRE  3\n#define STATE(s) int(s.x+.5)\n#define SET_STATE(s, S) s.x = float(S)\nvec4 wwmap(in ivec2 p)\n{\n    vec2 r = iChannelResolution[0].xy;\n    if (p.x < 0 || p.y < 0 ||\n        p.x >= int(r.x) || p.y >= int(r.y))\n        return vec4(S_EMPTY,0,0,0);\n    return texture(iChannel0, (vec2(p)+1.5) / r);\n}\n\n// current tool: 0-3 = wireworld state brush, >=4 = T_...\n#define G_TOOL      0\n#define G_MDOWN     1\n#define G_MPOS      2\n#define G_POS       3\n#define G_ZOOM      4\n#define G_DRAG_POS  5\n#define G_DRAG_ZOOM 6\n#define G_ZEROBRUSH 7\n#define G_SPEED\t\t8\n#define G_LTIME  \t9\n#define T_MOVE    4\n#define T_ZOOM    5\nvec4 guistate(in int s) \n{ return texture(iChannel0, (vec2(float(s),0.)+.5)/iChannelResolution[0].xy); }\n\n\n// wireworld colors\nvec3 wwcolor(in vec4 s)\n{\n    vec3 c = vec3(0.);\n    if (STATE(s) == S_HEAD)\n        c = vec3(.3,.5,1.);\n    else if (STATE(s) == S_TAIL)\n        c = vec3(1.,.2,.1);\n    else if (STATE(s) == S_WIRE)\n        c = vec3(1.,.6,.2);\n    return c;\n}\n\n\nvoid drawMenu(inout vec4 fragColor, in vec2 uv)\n{\n    if (uv.y < .9) return;\n    uv.y -= .9; uv /= .1;\n    \n    fragColor.xyz *= .2;\n    fragColor.xyz += .4;\n    \n    // current-tool frame\n    float frame = max(0., 1.-abs(uv.x-.5 - guistate(G_TOOL).x));\n    fragColor.xyz += .6*frame;\n    \n    // state-brushes\n\tif (uv.x > 0. && uv.x < 4.)\n    \tfragColor.xyz = mix(fragColor.xyz, .2+.8*wwcolor(vec4(floor(uv.x),0,0,0))\n                         , smoothstep(.5,.3, length(mod(uv,1.)-.5)));\n    uv.x -= 4.; \n    // move tool\n    if (uv.x > 0. && uv.x < 1.)\n    \tfragColor.xyz += smoothstep(.1,.0, \n\t\t\tmin(abs(uv.x-.5), abs(uv.y-.5)));\n    uv.x -= 1.;\n    // zoom tool\n    if (uv.x > 0. && uv.x < 1.)\n    {\n        float l = length(uv-vec2(.6))-.35;\n        if (uv.x<.5 && uv.y<.5)\n        \tl = min(l, abs(uv.x-uv.y)-.03);\n        fragColor.xyz += smoothstep(.1,.0, max(l,-l));\n    }\n    \n    uv.x -= 1.;\n    // speed bar\n    if (uv.x > 0. && uv.x < 4.)\n    {\n        fragColor.xyz += .3;\n        fragColor.xyz += smoothstep(0.1,0., uv.x/4. - guistate(G_SPEED).x)\n            \t\t\t*( vec3(.4,.8,1) - fragColor.xyz);\n\t}\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    float zoom = guistate(G_ZOOM).x;\n    // cells\n    vec2 p = uv*zoom + guistate(G_POS).xy;\n    vec4 s = wwmap(ivec2(p));\n\tfragColor = vec4(wwcolor(s),1.);\n    // grid\n    fragColor.xyz += 0.18*smoothstep(min(.3, zoom/90.), 0., \n                                     min(abs(mod(p.x+.5,1.)-.5),abs(mod(p.y+0.5,1.)-.5)));\n    \n    //fragColor.xy += texture(iChannel0, uv/50.).xy/4.;\n    drawMenu(fragColor, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/** Wireworld Cellular Automaton\n\tLicense Creative Commons NonCommercial Share-Alike 3.0 Unported\n\t(cc) 2016, Stefan Berke\n\n\tOrange cells are wire,\n\tBlue cells are electron heads, \n\tReds a are electron tails.\n\t\n\tTransition rule:\n\t\thead becomes tail,\n\t\ttail becomes wire,\n\t\twire becomes head if 1 or 2 neighbours are heads\n\n\tThe CA can process arbitrary logic functions\n\tand is generally easier to program for than the Game of Life ;)\n\n\tTop bar:\n\t\tSelect brush 1-4, \n\t\tcross to move view, lens to zoom,\n\t\tcyan bar to change processing speed\n\t\n*/\n\n// wireworld states\n#define S_EMPTY 0\n#define S_HEAD  1\n#define S_TAIL  2\n#define S_WIRE  3\n#define STATE(s) int(s.x+.5)\n#define SET_STATE(s, S) s.x = float(S)\nvec4 wwmap(in ivec2 p)\n{\n    vec2 r = iChannelResolution[0].xy;\n    if (p.x < 0 || p.y < 0 ||\n        p.x >= int(r.x) || p.y >= int(r.y))\n        return vec4(S_EMPTY,0,0,0);\n    return texture(iChannel0, (vec2(p)+1.5) / r);\n}\n\n// current tool: 0-3 = wireworld state brush, >=4 = T_...\n#define G_TOOL      0\n#define G_MDOWN     1\n#define G_MPOS      2\n#define G_POS       3\n#define G_ZOOM      4\n#define G_DRAG_POS  5\n#define G_DRAG_ZOOM 6\n#define G_ZEROBRUSH 7\n#define G_SPEED\t\t8\n#define G_LTIME  \t9\n#define T_MOVE    4\n#define T_ZOOM    5\nvec4 guistate(in int s) \n{ return texture(iChannel0, (vec2(float(s),0.)+.5)/iChannelResolution[0].xy); }\n\n\n\n\nvec4 wwtransition(in ivec2 p)\n{\n    ivec3 e = ivec3(1,0,-1);\n    // current state\n    vec4 s = wwmap(p), n[8];\n    // moor neighbourhood\n    n[0] = wwmap(p+e.zz); n[1] = wwmap(p+e.yz); n[2] = wwmap(p+e.xz);\n\tn[3] = wwmap(p+e.zy);                       n[4] = wwmap(p+e.xy);\n    n[5] = wwmap(p+e.zx); n[6] = wwmap(p+e.yx); n[7] = wwmap(p+e.xx);\n    \n\tif (STATE(s) == S_EMPTY)\n    {\n    }\n\telse if (STATE(s) == S_HEAD)\n    {\n    \tSET_STATE(s, S_TAIL);    \n    }\n\telse if (STATE(s) == S_TAIL)\n    {\n    \tSET_STATE(s, S_WIRE);    \n    }\n\telse //if (STATE(s) == S_WIRE)\n    {\n        int num = 0;\n        for (int i=0; i<8; ++i) { if (STATE(n[i]) == S_HEAD) { ++num; if (num > 2) break; } }\n        if (num == 1 || num == 2)\n    \t\tSET_STATE(s, S_HEAD);    \n    }\n    \n    return s;\n}\n\nfloat hash1(in vec2 p) { return fract(sin(dot(p,vec2(11.,17.)))*(74293.3+11.23*p.y+p.x)); }\n\n// paints a clock cycle with clock-length len+3\nint wwclock(in vec2 pf, in int len)\n{\n    ivec2 p = ivec2(pf);\n    int s = S_EMPTY;\n    if (p.x > 0 && p.x < len-1)\n    {\n        if (p.y == 0 || p.y == 2)\n            s = S_WIRE;\n    }\n    else if (p.x < len && p.y == 1) \n        s = S_WIRE;\n\tif (p.y == 0)\n    {\n        if (p.x == 1) s = S_TAIL;\n        if (p.x == 2) s = S_HEAD;\n    }\n    return s;\n}\n\n// initialize map\nvec4 wwinit(in vec2 p)\n{\n    vec4 s = vec4(0.);\n        \n    vec2 sed = floor(p/13.) + 90.*sin(iDate.zw);\n    \n    // random circuits\n    SET_STATE(s, wwclock(mod(p, vec2(13.)), 4+int(hash1(sed*1.1)*7.) ));\n   \t// horiz. wires\n    if (  int(mod(p.y, 13.)) > 3\n       && int(mod(p.y, 26.)) < 8\n       && int(mod(p.y, 2.)) == 0) \n    \tSET_STATE(s, S_WIRE);\n    if (s.x < 1.)\n\tSET_STATE(s, hash1(sed)*.0);\n\n#if 0   \n    // randomize    \n    sed = p + sin(iDate.wz);\n    if (hash1(sed+.3) < .08) \n        SET_STATE(s, S_WIRE);\n    if (hash1(sed+1.1) < .002)\n        SET_STATE(s, S_HEAD);\n#endif\n\n    return s;\n}\n\n\n// if selected brush should be flipped to empty when starting\n// to draw on state\nbool shouldEmpty(in int state, in int tool)\n{\n    return \n           (state == tool)\n        || (tool == S_WIRE && state != S_EMPTY);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = floor(fragCoord-1.);\n    vec2 mp = floor((iMouse.xy-1.)/iResolution.y*guistate(G_ZOOM).x + guistate(G_POS).xy);\n    bool mDown = iMouse.z > .5;\n\n    // catch single click\n    bool mClick = false;\n    if (mDown && guistate(G_MDOWN).x < .5)\n        mClick = true;\n\n    // process gui states\n    if (p.y < 0.)\n    {\n        // save-gui-state helper \n\t\t#define STORE_GUI_STATE(S, V) if (int(fragCoord.x) == S) fragColor.x = float(V)\n\t\t#define STORE_GUI_STATE2(S, V) if (int(fragCoord.x) == S) fragColor.xy = V\n\n        // reset\n        if (iFrame == 0)\n        {\n            fragColor = vec4(0.);\n            STORE_GUI_STATE(G_SPEED, .1);\n            STORE_GUI_STATE2(G_POS, iResolution.xy/2.);\n            STORE_GUI_STATE(G_TOOL, S_WIRE);\n            STORE_GUI_STATE(G_ZOOM, 30.);\n            return;\n        }\n        \n        fragColor = guistate(int(fragCoord.x));\n        int tool = int(guistate(G_TOOL).x+.5); // current tool\n        vec2 muv = iMouse.xy / iResolution.y; // mouse pos\n\n        // mouse down state\n        STORE_GUI_STATE(G_MDOWN, mDown ? 1. : 0.);\n        // clear zero-brush\n        if (!mDown)\n            STORE_GUI_STATE(G_ZEROBRUSH, 0);\n        // last transition time\n        if (iTime >= guistate(G_LTIME).x + guistate(G_SPEED).x)\n            STORE_GUI_STATE(G_LTIME, iTime);        \n        \n        // tool-bar\n        if ((mDown || mClick) && muv.y > .9)\n        {\n            muv.y -= .9; muv /= .1;\n            int gs = int(muv.x);\n            // set brush/tool\n            if (mClick && gs < 6)\n                STORE_GUI_STATE(G_TOOL, gs);\n            // set speed\n            if (gs >= 6 && gs <= 9) \n                STORE_GUI_STATE(G_SPEED, (muv.x-6.)/4.);\n\t\t\treturn;            \n        }\n        // flip brush when non-empty\n        if (tool > S_EMPTY && tool <= S_WIRE && mClick)\n        {\n            if (shouldEmpty(STATE(wwmap(ivec2(mp))), tool))\n            {\n                STORE_GUI_STATE(G_ZEROBRUSH, 1);\n            }\n        }\n        // move screen\n        if (tool == T_MOVE)\n        {\n            if (mClick)\n            {\n            \tSTORE_GUI_STATE2(G_MPOS, muv);\n                STORE_GUI_STATE2(G_DRAG_POS, guistate(G_POS).xy);\n            }\n\t\t\telse if (mDown)\n            {\n\t\t\t\tSTORE_GUI_STATE2(G_POS, guistate(G_DRAG_POS).xy \n                                 \t\t+ 30. * (guistate(G_MPOS).xy - muv));\n            }\n        }\n        // zoom screen\n        if (tool == T_ZOOM)\n        {\n            if (mClick)\n            {\n            \tSTORE_GUI_STATE2(G_MPOS, muv);\n                STORE_GUI_STATE(G_DRAG_ZOOM, guistate(G_ZOOM).x);\n            }\n\t\t\telse if (mDown)\n            {\n\t\t\t\tSTORE_GUI_STATE(G_ZOOM, max(1., guistate(G_DRAG_ZOOM).x \n                                 \t\t+ 300. * (guistate(G_MPOS).y - muv.y)));\n            }\n            \n        }\n\n        \n\t\treturn;\n    }\n    \n    // map processing\n    \n    if (iFrame == 0)\n        fragColor = wwinit(p);\n    else\n    {\n        // copy or process\n        if (iTime < guistate(G_LTIME).x + guistate(G_SPEED).x)\n            fragColor = wwmap(ivec2(p));\n        else\n        \tfragColor = wwtransition(ivec2(p));\n        \n        // paint\n        if (mDown && ivec2(p) == ivec2(mp) && iMouse.y/iResolution.y < .9)\n        {\n            int state = STATE(guistate(G_TOOL));\n            if (state <= S_WIRE) \n            {\n\t\t\t\tif (guistate(G_ZEROBRUSH).x > 0.\n                   || (mClick && shouldEmpty(STATE(fragColor), state)))\n                \tstate = S_EMPTY;\n            \tSET_STATE(fragColor, state);\n            }\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}