{
    "Shader": {
        "info": {
            "date": "1554961290",
            "description": "iMouse.x sets smoothness k of the kaleidoscope mirrors\n\nkaleidoscopic smin() is simpler and can be faster/prettier than expected, but it lacks context (molten trees are not ideal)\n\nsee image tab",
            "flags": 0,
            "hasliked": 0,
            "id": "Ws2SDK",
            "likes": 28,
            "name": "melt sKIFS smooth paperCity",
            "published": 3,
            "tags": [
                "kaleidoscope",
                "snow",
                "smin",
                "melting",
                "continuity",
                "almostidentity",
                "kerning",
                "snooth",
                "skifs",
                "sabs"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 1206
        },
        "renderpass": [
            {
                "code": "//self  : https://www.shadertoy.com/view/Ws2SDK\n//parent: https://www.shadertoy.com/view/3dSXD1\n\n/*\niMouse.x sets smoothness k of the kaleidoscope mirrors\n\nissue:\n- kifs tend to show their mirror axes too easily\n- , and these are a lot of c1-discontinuities, sharp corners.\n- the symmetry of these mirror axes can be hidden in polar distortion\n- , but it still begs to be smoothened.\n\nNuSan, 2019-03-27\n@ollj Also I found another way to remove discontinuity\n, instead of x=abs(x), use x=smin(x,-x,-5); \nBut I'm not sure it would be great for buildings with sharps edges.\n\nthis sure lacks a lot of context, it smooths everything the same way\n- large and small walls\n- roofs and trees\n- distant and nearby things.\nand that may not be the ideal approach, it needs more scaling context.\n- it can be made faster\n\nThis shader replaces a lot of abs() with ab() or ab2()\n, where ab(a) is smoothAbs(), used for the kifs mirrroring\n, and ab() is optionally used for other abs()-contexts within ab2();\n*/\n\n#define ab2(a) abs(a)\n//#define ab2(a) ab(a)  //ab() all the ab2(), is significantly slower\n//all abs() is replaced by ab2()\n//,except the kifs-abs() is ab()\n//,and; spheretrackingEscapeTime(),Gamma(),skyTexture() \n//...have unchanged abs()\n\n//(c< 0)?a:b  == less(a,b,c) == mix(a,b,step(0.,c))\n#define less(a,b,c)      mix(a,b,step(0.,c))\n\n#define sabs(x,k) less((.5/k)*x*x+k*.5,abs(x),abs(x)-k)\n\n/*  \n//expanded sabs()\nfloat sabs(float x,float k//BigWIngs, 2019-03-30: [You could also try smooth abs;]\n){float b=abs(x)   \n ;return less((.5/k)*x*x+k*.5,abs(x) ,abs(x) -k)\n //;return b<k?(.5/k)*x*x+k*.5:b\n ;}\nvec2 sabs(vec2 x,vec2 k//BigWIngs, 2019-03-30: [You could also try smooth abs;]\n){vec2 b=abs(x)\n ;return less((.5/k)*x*x+k*.5,b,b-k)\n //;return b<k?(.5/k)*x*x+k*.5:b\n ;}\nvec3 sabs(vec3 x,vec3 k//BigWIngs, 2019-03-30: [You could also try smooth abs;]\n){vec3 b=abs(x)\n  ;return less((.5/k)*x*x+k*.5,b,b-k)\n //;return b<k?(.5/k)*x*x+k*.5:b\n ;}\n*/\n\n//ab() is a toggling wrapper that skips the non-smin-ed part to return linear\n//it is abstracted into a dimension-less definition to reduce repeetition\n//may replace skt by sk, to ignore all inactive-mouse-simulation\n//make k=smoothing-range depend on iMouse.x\n#define sk (9.*(1.-iMouse.x/iResolution.x))\n//#define sk .5  //static sk to debug\n//#define sk 5.  //static sk debug\n//overwrite sk by a cos() IF mouse is inactive\n#define aball(t) ab(t a){;float skt=sk abcond abscale abend\n#define abcond  ;if (iMouse.z<0.)\n#define abscale skt=(cos(iTime)*.5+.5)*10.\n#define abend  ;if(skt<.175)return abs(a);return sabs(a,skt);}\nfloat aball(float)\nvec2  aball(vec2)\nvec3  aball(vec3)\n\n\n/*\nparent comment:\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can lower the MARCH_STEPS and SHADOW_STEPS if too slow\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/PaperCity.glsl\nInspired by https://www.shadertoy.com/view/tsjGRG\n*/\n\n#define MARCH_STEPS 60\n#define SHADOW_STEPS 10\n\n#define time iTime\n#define PI acos(-1.)\n\n//distance field functions are explained on;\n//http://mercury.sexy/hg_sdf\n//https://iquilezles.org/www/index.htm\n\n//this implements iterative root solving via sphere-tracking\n//to calculate the distance from camera to surface along a ray.\n\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,s,-s,c);}\n\nfloat box(vec3 p, vec3 s\n){vec3 ap=ab2(p)-s\n ;//return length(max(vec3(0),ap)) + min(0, max(ap.x,max(ap.y,ap.z)))\n ;return max(ap.x,max(ap.y,ap.z));}\n\nfloat tri(vec3 p, vec3 s\n){p.y=-p.y\n ;p.xz=ab2(p.xz)\n ;return max(max(-p.y-s.y, dot(p.xy,vec2(0.7))-s.x), p.z-s.z);}\n\nfloat cone(vec3 p, float a, float b\n){return max(length(p.xz)-p.y*a, p.y-b);}\n\nvec3 rep(vec3 p, vec3 s){return (fract(p/s+0.5)-0.5)*s;}\nvec2 rep(vec2 p, vec2 s){return (fract(p/s+0.5)-0.5)*s;}\nfloat rep(float p, float s){return (fract(p/s+0.5)-0.5)*s;}\n\n//above is more general library, below is more specific CSG composites:\n\nfloat house(vec3 p, float s\n){float t=tri(p+vec3(0,3,0)*s, vec3(1,1,3.5)*s)\n ;t = min(t, box(p, vec3(2,2,3)*s))\n ;return t;}\n\nfloat minitower(vec3 p\n){p.y+=5.\n ;vec3 p2 = p\n ;if(ab2(p2.x)<ab2(p2.z)) p2.xz=p2.zx\n ;float t = min(house(p+vec3(0,3,0),0.5), house(p2, 1.0))\n ;t = min(t, house(p-vec3(0,5,0),1.5))\n ;return t;}\n\nfloat tower(vec3 p\n){p.y+=15.0\n ;vec3 p2 = p\n ;if(ab2(p2.x)<ab2(p2.z)) p2.xz=p2.zx\n ;float t = min(house(p+vec3(0,3,0),0.5), house(p2, 1.0))\n ;t = min(t, house(p-vec3(0,5,0),1.5))\n ;p2.x -= sign(p2.x)*5.0\n ;p2.x = ab2(p2.x)\n ;p2.z = ab2(p2.z)\n ;t = min(t, house(p2.zyx-vec3(2,8,2),0.3))\n ;t = min(t, house(p2-vec3(0,12,0),1.5))\n ;return t;}\n\nfloat wall(vec3 p\n){p.x -= cos(p.z*0.1)*2.0\n ;p.x -= sin(p.z*0.03)*3.0\n ;vec3 rp=p\n ;rp.z = rep(rp.z, 5.0)\n ;float w = box(rp+vec3(0,1,0), vec3(2,1,50))\n ;rp.x = ab2(rp.x)-2.0\n ;float m = box(rp-vec3(0,2,0), vec3(0.25,5,1.6))\n ;return min(w, m);}\n\nfloat field(vec3 p\n){vec3 p2 = p\n ;if(ab2(p2.x)<ab2(p2.z)) p2.xz=p2.zx\n ;float tmp = box(p2, vec3(5,5,5));\n  float f = max(ab2(tmp-4.0), -p.y-2.0);\n  f=min(f, box(p, vec3(7,0.5,7)));\n  \n  vec3 p3 = p;\n  p3.xz=rep(p3.xz, vec2(2.5));\n  \n  float a = box(p3, vec3(0.2,2,0.2));\n  a = min(a, cone(p3+vec3(0,4,0), 0.3,3.0));\n  f=min(f, max(a,tmp-3.8));\n  \n  return f;\n}\n\nfloat village(vec3 p\n){\n  vec3 p2=p;\n  p2.xz = ab2(p2.xz);\n  float w = wall(p);\n  p2.xz -= 23.0;\n  float t=tower(p2);\n  vec3 p3 = p;\n  p3.z = p3.z-4.5*sign(p.x);\n  p3.x = ab2(p3.x)-25.0;\n  float f=field(p3);\n  \n  float res = t;\n  res = min(res, w);\n  res = min(res, f);\n  \n /*\n  p2.xz*=rot(0.3);\n  res = min(res, house(p2+vec3(13,0,0), 1));\n  p2.xz*=rot(0.6);\n  res = min(res, house(p2+vec3(18,1,-2.5), 1.5));\n  */\n  p.z = p.z+10.0*sign(p.x);\n  p.x = -ab2(p.x);\n  res = min(res, minitower(p+vec3(29,1,0)));\n  \n  return res;\n}\n\nfloat map(vec3 p\n){float t1=sin(length(p.xz)*0.009)//distort\n ;float s=12.0\n ;for(int i=0; i<6; ++i//kifs iterations\n ){p.xz=ab(p.xz)-s//kifs mirror axis is always ab() smoothened\n  ;p.xz *= rot(0.55+t1+float(i)*0.34)//kifs rotation\n  ;s/=.85//kifs scale\n  ;}\n ;p.x+=3.\n ;return min(village(p),-p.y);}\n\nfloat getao(vec3 p, vec3 n, float dist) {\n  return clamp(map(p+n*dist)/dist, 0.0, 1.0);\n}\n\nfloat noise(vec2 p\n){\n  vec2 ip=floor(p);\n  p=smoothstep(0.0,1.0,fract(p));\n  vec2 st=vec2(67,137);\n  vec2 v=dot(ip,st)+vec2(0,st.y);\n  vec2 val=mix(fract(sin(v)*9875.565), fract(sin(v+st.x)*9875.565), p.x);\n  return mix(val.x,val.y,p.y);\n}\n\nfloat fractal(vec2 p\n){float d=0.5\n ;float v=0.0\n ;for(int i=0; i<5; ++i\n ){v+=noise(p/d)*d\n  ;d *= 0.5\n  ;}\n ;return v;}\n\nvec3 sky(vec3 r, vec3 l\n){float v=pow(max(dot(r,l),0.0),3.0)\n //sky texture UV abs() is not smoothened\n ;vec2 sphereuv = vec2(abs(atan(r.z,r.x))+time*0.03,atan(r.y,length(r.xz)))\n ;float skyn = fractal(sphereuv*vec2(5,10))\n ;float skyn2 = fractal(sphereuv*vec2(5,10)*0.3-vec2(time*0.06,0))\n ;skyn2=smoothstep(0.3,0.7,skyn2)\n ;vec3 blue = mix(vec3(0.5,0.5,0.8), vec3(0.0), skyn2*skyn)\n ;return mix(blue*0.2, vec3(1,0.7,0.4)*(skyn2*0.8+0.2), v);}\n\nvec3 sky2(vec3 r, vec3 l\n){float v=pow(max(dot(r,l),0.0),3.0)\n ;vec3 blue = vec3(0.5,0.5,0.8)\n ;return mix(blue*0.2, vec3(1,0.7,0.4), v);}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord\n){vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  float t2=time+10.0;\n  vec3 s=vec3(0,0,-100);\n  s.yz *= rot(sin(t2*0.3)*0.2+0.5);\n  s.xz *= rot(t2*0.2);\n  vec3 t=vec3(0,30,60);\n  t.yz *= rot(sin(t2)*0.3-0.2);\n  t.xz *= rot(t2*0.32)\n  ;vec3 cz=normalize(t-s)\n  ;vec3 cx=normalize(cross(cz,vec3(0,1,0)))\n  ;vec3 cy=normalize(cross(cz,cx))\n  ;//vec3 r=normalize(vec3(-uv, 0.7))\n  ;vec3 r=normalize(uv.x*cx+uv.y*cy+cz*0.7)\n  ;vec3 p=s\n  ;float dd=0.\n  ;for(int i=0; i<MARCH_STEPS; ++i//spheretracking loop\n  ){float d=map(p)\n   ;if(abs(d)<0.001) break//rootSolveEscapeTime is not smoothened\n   ;if(dd>500.0) {dd=500.0; break;}\n   ;p+=d*r*0.8\n   ;dd+=d;}\n  //shade point at distance dd:\n  ;float fog=1.-clamp(dd/500.0,0.,1.)\n  ;vec3 col=vec3(0)\n  ;vec2 off=vec2(0.01,0)\n  ;vec3 n=normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)))\n  ;float ao=(getao(p, n, 12.0) * 0.5 + 0.5) * (getao(p, n, 2.0) * 0.3 + 0.7) * (getao(p, n, 0.5) * 0.8 + 0.2)\n  ;vec3 l=normalize(vec3(-1,-2,-2.5))\n  ;float f = pow(1.0-abs(dot(n,r)), 3.0);//gamma is not smoothened\n  \n  ;float shad=1.\n  ;vec3 sp=p+n*.5-r*.2//light source (here its parallel global illumination)\n  ;for(int i=0; i<SHADOW_STEPS; ++i//shadow loop\n  ){float d=map(sp)\n   ;if(d<0.2){shad = 0.0;break;}\n   ;sp+=d*l*3.0;}\n  \n  col += max(0.0,dot(n,l)) * fog * vec3(1,0.7,0.4) * 1.5 * mix(0.0, ao*0.5+0.5, shad);\n  col += (-n.y*0.5+0.5) * ao * fog * vec3(0.5,0.5,0.8) * 0.5;\n  col += sky2(reflect(r,n), l)*f*10.0*fog * (0.5+0.5*shad);\n  col += sky(r, l) * pow(dd*0.01,1.4);\n  //col = vec3(shad);//incomment tor high contrast shadow\n  col = 1.0-exp(-col*2.5);\n  col = pow(col, vec3(2.3));\n  col = pow(col, vec3(0.4545));\n  col.g+=.07; //tint green to differentiate from parent.\n  fragColor = vec4(col, 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}