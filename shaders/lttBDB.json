{
    "Shader": {
        "info": {
            "date": "1540980321",
            "description": "Antother variation of Klem's shader [url]https://www.shadertoy.com/view/XlcfRs[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "lttBDB",
            "likes": 61,
            "name": "Fluffy Things",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "raymarching",
                "distancefield",
                "sdf"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 3424
        },
        "renderpass": [
            {
                "code": "// Copyright Inigo Quilez, 2018 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\n\nmat3 makeBase( in vec3 w )\n{\n\tfloat k = inversesqrt(1.0-w.y*w.y);\n    return mat3( vec3(-w.z,0.0,w.x)*k, \n                 vec3(-w.x*w.y,1.0-w.y*w.y,-w.y*w.z)*k,\n                 w);\n}\n\n// https://iquilezles.org/articles/intersectors\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in float rad )\n{\n\tfloat b = dot( ro, rd );\n\tfloat c = dot( ro, ro ) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n    h = sqrt(h);\n\treturn vec2(-b-h,-b+h);\n}\n\n// modified Keinert et al's inverse Spherical Fibonacci Mapping\nvec4 inverseSF( in vec3 p, in float n )\n{\n    const float PI = 3.14159265359;\n\tconst float PHI = 1.61803398875;\n\n    float phi = min(atan(p.y,p.x),PI);\n    float k   = max(floor(log(n*PI*sqrt(5.0)*(1.-p.z*p.z))/log(PHI+1.)),2.0);\n    float Fk  = pow(PHI,k)/sqrt(5.0);\n    vec2  F   = vec2(round(Fk),round(Fk*PHI));\n    vec2  G   = PI*(fract((F+1.0)*PHI)-(PHI-1.0));    \n    \n    mat2 iB = mat2(F.y,-F.x,G.y,-G.x)/(F.y*G.x-F.x*G.y);\n    vec2 c = floor(iB*0.5*vec2(phi,n*p.z-n+1.0));\n\n    float ma = 0.0;\n    vec4 res = vec4(0);\n    for( int s=0; s<4; s++ )\n    {\n        vec2 uv = vec2(s&1,s>>1);\n        float i = dot(F,uv+c);\n        float phi = 2.0*PI*fract(i*PHI);\n        float cT = 1.0 - (2.0*i+1.0)/n;\n        float sT = sqrt(1.0-cT*cT);\n        vec3 q = vec3(cos(phi)*sT, sin(phi)*sT,cT);\n        float a = dot(p,q);\n        if (a > ma)\n        {\n            ma = a;\n            res.xyz = q;\n            res.w = i;\n        }\n    }\n    return res;\n}\n\nfloat map( in vec3 p, out vec4 color, const in bool doColor )\n{\n    float lp = length(p);\n    float dmin = lp-1.0;\n    \n    \n    float pp = 0.5+0.5*sin(60.0*lp); pp *= pp; pp *= pp; pp *= pp; pp *= pp;\n    dmin = min(dmin,p.y+1.0+0.02*pp);\n    \n    \n\n    color = vec4(0.4,0.5,0.3,1.0)*0.9;\n    \n    float s = 1.0;\n    \n    //dmin = min( dmin,lp-2.15 );\n    \n    for( int i=0; i<2; i++ )\n    {\n        float h = float(i)/float(2-1);\n        \n        // Trick. Do not check the 2x2 neighbors, just snap to the\n        // closest point. This is wrong and produces discontinuities\n        // in the march, but it's okeish for the purposes of this shader\n        vec4 fibo = inverseSF(normalize(p), 65.0+35.0*h);\n        \n        // snap\n        p -= fibo.xyz;\n        \n        // orient to surface\n        p *= makeBase(normalize( fibo.xyz + 0.08*sin(fibo.y + 2.0*iTime + vec3(0.0,2.0,4.0))));\n\n        // scale\n        float scale = 7.0 + 3.0*sin(111.0*fibo.w);\n        if( i==0 ) scale += 4.0*(1.0-smoothstep(-0.5,-0.4,fibo.y));\n        scale *= 1.0 + 3.0*smoothstep(0.9,1.0,cos(0.25*iTime + fibo.w*141.7));\n        p *= scale;\n        \n        // translate and deform\n        p.z -= 2.3 + length(p.xy)*1.1*abs(sin(fibo.w*212.1));\n\n        //-----\n        \n        s *= scale;\n\t\t// distance to line segment/capsule \n        float d = length( p - vec3(0.0,0.0,clamp(p.z,-6.0,0.0)) ) - 0.1;\n        d /= s;\n\n        if( d<dmin )\n        {\n            if( doColor )\n            {\n                color.w *= smoothstep(0.0, 5.0/s, dmin-d);\n                if( i==0 ) color = vec4(0.4,0.5,0.4,1.0);\n                color.xyz += 0.3*(1.0-0.45*h)*sin(fibo.w*211.0+vec3(0.0,1.0,2.0));\n                color.xyz = max(color.xyz,0.0);\n            }\n            dmin = d;\n        }\n        else\n        {\n          color.w *= 0.4*(0.1 + 0.9*smoothstep(0.0, 1.0/s, d-dmin));\n        }\n    }\n    \n    return dmin;\n}\n\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in float ep )\n{\n    vec4 kk;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep, kk, false ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep, kk, false ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep, kk, false ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep, kk, false ) );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmax, const float k )\n{\n    vec2 bound = sphIntersect( ro, rd, 2.15 );\n    tmax = min(tmax,bound.y);\n    \n\tfloat res = 1.0;\n    float t = 0.0;\n    //float t = max(0.0,bound.x);\n    for( int i=0; i<45; i++ )\n    {\n    \tvec4 kk;\n\t\tfloat h = map( ro + rd*t, kk, false );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.20 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float an = (iTime-10.0)*0.05 - 0.4;\n    \n    // camera\t\n    vec3 ro = vec3( 4.5*sin(an), 0.0, 4.5*cos(an) );\n    vec3 ta = vec3( 0.0, 0.2, 0.0 );\n    // camera-to-world transformation\n    mat3 ca = makeBase( normalize(ta-ro) );\n    \n    // render    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    // ray direction\n    vec3 rd = ca * normalize( vec3(p.xy,2.3) );\n\n    // background\n    vec3 bak = vec3(0.1,0.14,0.18)*1.2 + 0.15*rd.y;\n\n    vec4 col = vec4(0.0);\n\n    // bounding volume\n    vec2 bound = sphIntersect( ro, rd, 2.15 );\n    if( bound.x>0.0 )\n    {\n        // raymarch\n        vec4 kk;\n        float t = bound.x;\n        for( int i=0; i<350; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            \n            // evaluate distance\n            vec4 mate;\n            float h = map(pos,mate,true);\n\n            // color contribution            \n            float px = t*0.012;\n            if( h<px )\n            {\n                // surface normal                \n                vec3 nor = calcNormal(pos, px*0.5);\n\n                // start lighting                \n                vec3 lcol = vec3(0.0);\n\n                // key ligh\n                {\n                    //dif\n                    vec3 lig = normalize(vec3(1.0,1.0 ,0.7));\n                    float dif = clamp(0.5+0.5*dot(nor,lig),0.0,1.0);\n                    float sha = calcSoftshadow( pos+0.01*lig, lig, 2.0, 6.0 );\n                    lcol += mate.xyz*dif*vec3(3.0,0.7,0.5)*1.2*vec3(sha,sha*0.3+0.7*sha*sha,sha*sha);\n                    // spec\n                    vec3 hal = normalize(lig-rd);\n                    float spe = clamp( dot(nor,hal), 0.0, 1.0 );\n                    float fre = clamp( dot(-rd,lig), 0.0, 1.0 );\n                    fre = 0.05 + 0.95*pow(fre,5.0);\n                    spe *= spe; spe *= spe;\n                    col += 1.0*spe*dif*sha*fre*mate.w;\n                }\n\n                // back light\n                {\n                    vec3 lig = normalize(vec3(-1.0,0.0,0.0));\n                    float dif = clamp(0.5+0.5*dot(nor,lig),0.0,1.0);\n                    lcol += mate.rgb*dif*vec3(1.0,0.9,0.6)*0.06*mate.w;\n                }\n\n                // dome light\n                {\n                    float dif = clamp(0.3+0.7*nor.y,0.0,1.0);\n                    lcol += mate.xyz*dif*1.0*vec3(0.1,0.2,0.4)*mate.w*(0.2+0.8*mate.w);\n                }\n\n                // fake sss\n                {\n                    float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\n                    lcol += 0.8*vec3(1.0,0.3,0.2)*mate.xyz*mate.xyz*fre*fre*mate.w;\n                    //lcol += 0.2*mate.xyz*mate.xyz*fre*fre*mate.w;\n                }\n\n                // grade\n                lcol = 0.85*pow( lcol, vec3(0.75,0.9,1.0) );\n            \n\n                // composite front to back\n                float al = clamp(1.0-h/px,0.0,1.0);\n                lcol.rgb *= al;\n    \t\t\tcol = col + vec4(lcol,al)*(1.0-col.a);\n                if( col.a>0.995 || abs(h)<0.0001 ) break;\n            }\n\n\n            // march ray            \n            t += h*0.5;\n            if( t>bound.y ) break;\n            //if( col.a>0.995 || abs(h)<0.0001 || t>bound.y ) break;\n        }\n    }\n\n\n    // composite with background    \n    vec3 tot = bak*(1.0-col.w) + col.xyz;\n\n    // gain\n    tot *= 0.7 + 0.3*smoothstep( 0.0, 15.0, abs(iTime-25.0) );\n    \n    // gamma\n    tot = pow( tot, vec3(0.4545) );\n\n\n    // vignetting\n \tvec2 q = fragCoord/iResolution.xy;\n    tot *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2 );\n\n    // output    \n    fragColor = vec4( tot, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}