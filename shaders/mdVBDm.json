{
    "Shader": {
        "info": {
            "date": "1698305981",
            "description": "𝐑𝐨𝐭𝐚𝐭𝐞= 𝐀𝐫𝐫𝐨𝐰𝐊𝐞𝐲𝐬 || 𝐃𝐫𝐚𝐠𝐌𝐨𝐮𝐬𝐞 +𝐖𝐑 (=roll) \n𝐒𝐭𝐫𝐚𝐟𝐞= 𝐄𝐒𝐃𝐅                                 +𝐓𝐆 (=upDown)  \nhttps://www.shadertoy.com/view/DsKBDw\nwith quaternion-camera of\nhttps://www.shadertoy.com/view/wtdyRs",
            "flags": 48,
            "hasliked": 0,
            "id": "mdVBDm",
            "likes": 6,
            "name": "┣┳┻┫ꓕTiles+Quaternion_cam",
            "published": 3,
            "tags": [
                "fly",
                "quaternioncamera"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 241
        },
        "renderpass": [
            {
                "code": "//drag mouse for quaternion rotation\n//arrow keys to accellerate and roll\n\n//grandparent bezierPatch  : https://www.shadertoy.com/view/XsjSDt\n//grandparent flyQuaternion: https://www.shadertoy.com/view/MldczM\n//parent                   : https://www.shadertoy.com/view/ttjSzw\n//self                     : https://www.shadertoy.com/view/wlSyzd\n\n//A triangular cubic bezier patch, bound by 6 CV-heights, \n//is tranceable analytically with good performance and precision\n//for no good reason i never bothered to fix the camera of /XsjSDt, till now\n//and i notice that this shader sucks if the camera is inside the bezier-triangle-prism.\n\n//it works fine, as long as the patch is not too planar\n//any near-planar bezierPatch has a too small determinant which diminishes precision too much.\n//the first few milliseconds of this demo are near-planar\n\n//it works fine as long as the camera is not inside the bounding-prism (incl min&&max height) \n//of the bezier patch\n\n//But if the camera is inside the bezierPrism, the roots are in the wrong order. \n//and it seems to treat roots behind the camera as if they are infront of the camera??\n\n\n//BUT it always renders 2 patches, and their distance to each other is the distance of the camera to vec3(0)\n//, as if they are mirror images.\n//and they intersect when the camera is close to it.\n//, and they appear to swap places when you move over one of them.\n//and then you may confuse it for its mirror image.\n//unless you have the original inside its AABV\n\n//the open question here is, how to remove the mirror image solution?\n\n\n\nfloat segment(vec2 P, vec2 A, vec2 B){ \n    vec2 g=B-A;\n    vec2 h=P-A;\n    return length(h-g*clamp(dot(g,h)/dot(g,g),0.,1.));}\n\n#define fra(u)(u-.5*iResolution.xy)/iResolution.y\n\nvec4 drawDragVector(vec2 u){\n  if (iMouse.z<0.)return vec4(0);\n  vec2 a=fra(abs(iMouse.xy));\n  vec2 b=fra(abs(iMouse.zw));\n  //float r=smoothstep(.01,0.,abs(length(b-u)-.02));//ring\n  float r=min(   segment(u,a,b   )//line segment\n             ,abs(length(b-u)-.02)//ring\n             );\n  r=smoothstep(.01,0.,r)*.3;//thickness, transparency\n  return vec4(r);}//premultiplied for porterDuff\n\nvoid mainImage(out vec4 o, in vec2 u){\n //o=mainImage2(o,u);                         //mainIimage is in THIS channel\n o=texture(iChannel2,u/iResolution.xy, -100.);//mainIimage is in Ichannel2\n o=sat(o);//may need to clamp for an overlayd line\n //o+=drawDragVector(u/iResolution.xy*iResolution.x);//almost sufficient for a white line overlay\n o=pdOver(drawDragVector(fra(u)),o);//proper porter duff overlay.\n}\n\n//everything is in BuffA and common\n\n\n/*\n//Volumetric fractal explorer \n\n//Features:\n//Multiple light sources(importance sampled)\n//Anisotripic scattering\n//Multibounce scattering\n//Approximate volumetric reprojection for temporal denoising\nvoid mainImage(out vec4 c,vec2 p\n){c=texture(iChannel0,p/iR.xy)\n ;c=1.07*tanh(pow(c/c.w,vec4(.6)))//this gamma correction is important\n ;}\n \n//MIT License\n//Copyright 2020 Mykhailo Moroz\n//Permission is hereby granted,free of charge,to any person obtaining a copy of this software and associated documentation files (the \"Software\"),to deal in the Software without restriction,including without limitation the rights to use,copy,modify,merge,publish,distribute,sublicense,and/or sell copies of the Software,and to permit persons to whom the Software is furnished to do so,subject to the following conditions:\n//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n//THE SOFTWARE IS PROVIDED \"AS IS\",WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED,INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,DAMAGES OR OTHER LIABILITY,WHETHER IN AN ACTION OF CONTRACT,TORT OR OTHERWISE,ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//assume as \"Do whatever you want\" License\n*/",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Camera Controller (quaternion 2022-02)\n//also contains the non-quaternion camera controller (toggle is [camType] in commontab):\n\n//lots of paramerets for this exist in the commontab\n\n/*\nto enable camera-to-object collisions\n, the normals() and setting() distance field (and all its subroutines)\nneed to either be duplicated into the camera-movement buffer\n, OR moved into the common-tab\nThis may be too excessive and it tends to cause WAY too many namespace conflicts to be worth it.\n\nthis is its own fragment-buffer-tab  \njust for convenience + simplicity + compatibility (quick copying of whole buffers)\n\ninstead, it could just overlay its 4 bottom left pixel\nof in the actual image of another buffer (ccopying from another image-tab)\nwhich sure makes enabling-of-collisions much simpler (no duped code needed in that case)\n*/\n\n// // simpler camera, can not roll of https://www.shadertoy.com/view/wttyDX\n// // #define noRollCam     0\n// // quaternion cam,              of https://www.shadertoy.com/view/wtdyRs\n// // #define quaternionCam 1\n// // \n// // #define camType quaternionCam\n\n//note. for cvollision to work, this function needs df() and normal() functions\n//added to collide with a distanceField bacl along a surface normal\n//they are commented out in THIS shader\n\n//full alphabet + arrows\nconst int keyLe=37,keyUp=38,keyRi=39,keyDn=40\n,keyA=65,keyB=66,keyC=67,keyD=68,keyE=69,keyF=70,keyG=71,keyH=72,keyI=73,keyJ=74,keyK=75,keyL=76,keyM=77,keyN=78,keyO=79,keyP=80,keyQ=81,keyR=82,keyS=83,keyT=84,keyU=85,keyV=86,keyW=87,keyX=88,keyY=89,keyZ=90;\n\n//Keyboard constants (ESDF/arrows+TG+MouseDrag)\n//esdf is mor comparible than wasd (especially with french layout)\n//modify inputs by changing the ivec3() below (keys are defined in CommonTab)\nconst ivec3 klp=ivec3(keyF ,keyT ,keyE).zxy//right ,up  ,front      ==+linear strave\n           ,kln=ivec3(keyS ,keyG ,keyD).zxy//left  ,down,back       ==-linear strave\n           //... above .zxy swivel is a porting artefact\n           ,kap=ivec3(keyLe,keyUp,keyR) //kPitchLeft ,kJawUp  ,kRollRight ==+angular rotate\n           ,kan=ivec3(keyRi,keyDn,keyW);//kPitchRight,kJawDown,kRollLeft  ==-angular rotate\n\n//constant code:\nbool key(int k){return texelFetch(iChannel3,ivec2(k,0),0).x>0.5;}\nfloat kg(int k){return texelFetch(iChannel3,ivec2(k,0),0).x;}\nvec3 ks(ivec3 a){return vec3(kg(a.x),kg(a.y),kg(a.z));}//key input subroutine\nvec3 drag(vec3 r,vec3 a,float d){return (r+a*iTimeDelta)*(1.-d*iTimeDelta);}\n\n#if (camType==0) \nvec4 cp0( //non quaternion camera\n){if(iFrame<1)return posStart;\n ;vec4 v=get(camP1)\n ;if(length(v.xyz)>0.1)return vec4(0);\n ;//if(w>0.)c.xyz+=0.1*vec3(sin(iTime),cos(iTime),0.)*speed\n ;return vec4(get(camP0).xyz+v.xyz*abs(v.w),0);}\n#else\nvec4 cp0( //quaternion camers\n//return camera linear Position.xyz (.w is unused)\n){if (iFrame<1)return posStart;\n ;vec3 r=get(camP0).xyz\n ;if(PHYSICS_RADIUS>-99.){// gating to skip the colision calculation that is likely disabled anyways.\n  //include the function that estimates the surface normal of the df() function above this \n  //to push the camera away, alogn the surfaceNormal to avoid collisions\n  //then remove the commentingPut line / * below and you have some physics\n  //, use constants to set scaling.\n  /*\n  ;float d=PHYSICS_RADIUS\n  ;d-=length(-df(r.xyz)) //include df() as distance field function here to collide the dcamera\n  //;if (d>0.)r.xyz+=vec3(0.,0,PHYSICS_REPEL)//push up workaround that works without normal()\n  ;if (d>0.)r.xyz+=normal(r)*d*PHYSICS_REPEL //push camera away, alons surface normal.\n  //optional collision , needs normal() of the df()\n\n  /**/ \n  //collisions need the df() and its normal() function to be also here, or shared in commontab.\n ;}\n ;return vec4(r+(q2m(get(camA0),vec3(0))\n               *vec4(get(camP1).xyz,0)).xyz*iTimeDelta,0);}\n#endif\n\n#if (camType==0) \nvec4 cp1(  //non quaternion camera\n//return camera linear velocity.xyz a vec3 with speed.w as scalart, unaffected by change-of-direction\n){vec4 c=get(camP1)\n ;if(iFrame<1)c.w=CAMERA_SPEED\n ;if(key(keyQ))c.w*=1.01\n ;if(key(keyE))c.w*=0.99\n ;mat3 camera=getCam(get(camA0).xy)\n ;c.w=-sign(c.w)\n ;float s=abs(c.w)*iTimeDelta*.1\n ;if(key(keyUp)||key(keyE))c+=vec4( camera[0]*s,0)\n ;if(key(keyDn)||key(keyD))c+=vec4(-camera[0]*s,0)\n ;if(key(keyRi)||key(keyF))c+=vec4( camera[1]*s,0)\n ;if(key(keyLe)||key(keyS))c+=vec4(-camera[1]*s,0)\n ;c.xyz*=.8 \n ;return c;}\n#else   \n  //quaternion camera\nvec4 cp1(//return camera linear velocity.xyz (.w is unused)\n){return vec4(drag(get(camP1).xyz,LIN_ACCE*(ks(klp)-ks(kln)),LIN_DRAG),0);}\n#endif\n \nconst vec4 rotStart=vec4(-.27,.5,0,0)*pi;\n#if (camType==0) \nvec4 ca0( //non quaternion camera\n){if(iFrame<1)return rotStart\n ;vec4 c=get(camA0)\n ;c.xy=c.xy+c.zw*MOUSE_SENSITIVITY\n ;c.y=clamp(c.y,pi*.01,pi*.99)\n ;c.zw+=vec2(-1,1)*get(camA1).xy\n ;c.zw*=.6\n ;return c;} \n#else \n//quaternion camera\nvec4 ca0(//return camera angular Position.xyz (quaternion)\n){if (iTime < 0.1)return aa2q(vec3(0,0,1),-2.75)\n ;return normalize(qq2q(eYPR2q(iTimeDelta*get(camA1).zxy),get(camA0)));}\n#endif\n\n#if (camType==0) \n //non quaternion camera\nvec4 ca1(//mouse angularVelocity (just a mouse.xyxy doubleBuffer)\n){if(iFrame<1)return vec4(0,0,iM.xy)\n ;vec4 c=get(camA1)\n ;return vec4((length(iM.zw-iM.xy)>10.)?iM.xy-c.zw:vec2(0),iM.xy);}\n#else\n  //quaternion camera\nvec4 ca1(//return camera angular velocity.xyzw (quaternion)\n){vec3 a=ks(kap)-ks(kan)\n ;if(sign(iMouse.z)==1.)a.xy+=MOUSE_SENSITIVITY*(iM.xy-abs(iM.zw))/iR.xy;\n ;a=clamp(a,-1.,1.)\n ;a=a.yzx\n ;return vec4(drag(get(camA1).xyz,a*ANG_ACCE,ANG_DRAG)\n ,0.);}\n#endif\n\n//keyL and keyP may be used to position 2 seperate light sources \n//at the current camera position, when the key L/P is pressed\nvec4 lightPos(float q,int k,vec4 d\n){if(iFrame<1)return d\n ;vec4 c=get(q)\n ;if(key(k))c.xyz=get(camP0).xyz+vec3(LIGHT_RADIUS*1.3);\n ;return c;}\n \nvec4 cam4(float u//4 buffers for CameraControl\n){if(u<2.){if(u==camP0)return cp0();return ca0();}\n ;         if(u==camP1)return cp1();return ca1();}\n\n//2 buffers for 2 movable light sources\nvec4 switchcase(float u\n){u=floor(u)//essential\n ;if(u<4.)return cam4(u);\n ;if(u==camP0p)return get(camP0)//memorize previous pos\n ;if(u==camA0p)return get(camA0)//memorize previous angle\n ;if(u==li0P0)return lightPos(u,keyL,vec4(.2,.9,0,0))\n ;if(u==li1P0)return lightPos(u,keyP,vec4(-.9,0,0,0))\n ;return vec4(0);}\n\nvoid mainImage(out vec4 c,vec2 u\n){if(!(u.y<0.||u.x<NBuffB))discard\n ;c=switchcase(u.x);}\n \n ",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//2022-02 union of \n//https://www.shadertoy.com/view/wlSyzd (quadratic bezier triangle   2022-01)\n//https://www.shadertoy.com/view/wl3yDs (reproject volume quaternion 2022-02)\n//mostly to improve camera controls\n\n//tags:\n//traceQuadratic,bezierPatch,Quaternioncamera,fly,aabv,bspline,bpatch,pqfm\n\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n#define vec1 float\nstruct v22{vec3 a,b;};//for 2 domains(density/distance field)\n\n//way too common subroutine shorthands:\n#define pi acos(-1.)\n#define dd(a) dot(a,a)\n#define sat(a) clamp(a,0.,1.)\n#define u2(u) ((u)*2.-1.)\n#define iR iResolution\n#define iM iMouse\nvec3 ma0(vec3 a){return max(a,0.);}\nfloat mu(vec2 a){return a.x*a.y;}float mu(vec3 a){return a.x*a.y*a.z;}\nfloat su(vec2 a){return a.x-a.y;}float su(vec3 a){return a.x+a.y-a.z;}\nfloat ad(vec2 a){return a.x+a.y;}float ad(vec3 a){return a.x+a.y+a.z;}\n//2d rotation matrix from angle(deg)\nmat2 rot(float ang){return mat2(cos(ang),sin(ang),-sin(ang),cos(ang));}\n//return smallest angle between 2 vectors\nfloat AngleBetween(vec3 a,vec3 b){;return acos(dot(a,b)/(length(a)*length(b)));}\n\n\n\n\n\n\n//----- START  of parameters and common functions for camera controls\n//\n//simpler camera, can not roll of https://www.shadertoy.com/view/wttyDX\n#define noRollCam     0\n//\n//quaternion cam,              of https://www.shadertoy.com/view/wtdyRs\n#define quaternionCam 1\n//\n//\n//temporal-Reprojection appears initialize wrongly with quaternionCam (must reset time)\n//\n#define camType quaternionCam\n//[noRoll] camera is worse than [quaternionCam]\n//- does not allow for roll (and thus it never gridlocks)\n//- camAng1 is just a doubleBuffered iMouse.xy (is not true angularVelocity, but has similar effect)\n//- camPos1 (posaition derivative) has a confused .w factor (maxVelocity, but it changes)\n//\n//global buffereB Addresses for camera controls/properties\n//eg: use get(camP1).xyz to get camera position\n//all positions are vec3.xyz\n//all rotations are vec4.xyzw quaternions (stored (very close to) normalized) (for the quaternion camera)\n//all rotations are vec2.xy   jaw+roll    for the non-quaternion camera\nconst float //values must count up from 9, and NBuffB muzst be the last+largest.\n camP0=0.//camera position (0th derivative/time)\n,camA0=1.//camera rotation (0th derivative/time)\n,camP1=2.//camera position (1th derivative/time) == camera velocity\n,camA1=3.//camera rotation (1th derivative/time) == camera momentum\n,li0P0=4.//light0 position\n,li1P0=5.//light1 position\n,camP0p=6.//camera position of previous frame\n,camA0p=7.//camera rotation of previous frame\n,NBuffB=8.//max address count (for Bounding Volume)\n;//\n//camera starting position\nconst vec4 posStart=vec4(-19,19,9,1);\n//\n#if (camType==0) \n #define CAMERA_SPEED .05\n const float MOUSE_SENSITIVITY=.2/60.;\n#else\n const vec2 MOUSE_SENSITIVITY = vec2(-1.,1.)*9.;\n const float\n // if (camera is closer than PHYSICS_RADIUS) apply pushing force PHYSICS_REPEL along surface-normal.\n  //set to -100. to skip collisions\n  //=.01 is reasonable for the mandelbulb distanceField\n  PHYSICS_RADIUS=.0000001 //-100.\n ,PHYSICS_REPEL=1.//normal(cameraPosition)*PHYSICS_REPEL= how much colisions push the camera away. \n                  //no normalize() happens outside of normal(), which you may add or remove\n                  //depending on how good your df is andOr how your collisions handle deformed fields.\n ,LIN_ACCE=4.5//linear accelleration\n ,ANG_ACCE=2.//angular accelleration\n ,LIN_DRAG=1.//linear  drag/friction\n ,ANG_DRAG=2.//angular drag/friction\n;\n\n\n#endif\n//#endif\n//\n//radius of lightSource sphere\n#define LIGHT_RADIUS .01\n//\n#define get(i)texelFetch(iChannel2,ivec2(i,0),0)\nvec4 get2(ivec2 a,sampler2D b){return texelFetch(b,a,0);}\nvec4 get2(float a,sampler2D b){return texelFetch(b,ivec2(a,0),0);}\nvec4 get2(int   a,sampler2D b){return texelFetch(b,ivec2(a,0),0);}\n//----- end of parameters and common functions for camera controls\n\n\n//--- quaternionRotation math (updated 2021-Jan-7) //https://www.shadertoy.com/view/4tSyRz\n//\n//essential for the quaternion-camera.\n//\n//ANY rotations in 3d are non-commutative!\n//\n//matrix rotations are just bulky, memory wasting\n//EulerRotations almost certainly fail to rotate over the SHORTEST path.\n//EulerRotations almost certainly will gimbalLock and get stuck along one axis\n//QuaternionRotations are superior here.\n//-> we only use EulerRorations for simple input devices (keyboard input)\n//-> we convert to quaternions, buffered as vec4.\nvec4 qid(){return vec4(0,0,0,1);}//quaternion Identity\n//\n//---quaternion & AxisAngle (==quaternion multiplication)\n//\n//return quaternion from Axis[a] and Angle[r]\nvec4 aa2q(vec3 a,float r){vec2 g=vec2(sin(r),cos(r))*.5;return normalize(vec4(a*g.x,g.y));}\n//return AxisAngle of NORMALIZED quaternion input\nvec4 q2aa(vec4 q){return vec4(q.xyz/sqrt(1.0-q.w*q.w),acos(q.w)*2.);}//assumed q is normalized coverts to axis&angle\n//return q2, rotated by q1, order matters (is non commutative) : (aka quaternion multiplication == AxisAngleRotation)\nvec4 qq2q(vec4 q1, vec4 q2){return vec4(q1.xyz*q2.w+q2.xyz*q1.w+cross(q1.xyz,q2.xyz),(q1.w*q2.w)-dot(q1.xyz,q2.xyz));}\n//extension to qq2q(), scaled by sensitivity [f] (==quaternion ANGULAR equivalent to slerp() )\nvec4 qq2qLerp(vec4 a, vec4 b, float f//jonathanBlow wrote many documents about better alternatives.\n){float d=dot(a,b),t=acos(abs(d)),o=(1./sin(t));return normalize(a*sin(t*(1.0-f))*o*sign(d)+b*sin(t*f)*o);}\n//doing qq2q() multiple times, you need to normalize() the quaternion, to fix rounding errors.\n//how often you do this is up to you.\n//normalize q (assuming length(q) is already close to 1, we can skip whe sqrt()\nvec4 qn(vec4 q//){return q/dd(q) //not as wortksafe, division is slow.\n){float w=dot(q,q);return w==1.?q:.5*(3.-w)*q;}//worksafe and faster: https://www.shadertoy.com/view/llySRh\n//return normalize(q) //unnecessary, as long as lenght(q) is close to 1.\n\n//qexp() qlog() qpow() seem useful for fractals.\nvec4 qexp(vec4 v\n){float a=dot(v.xyz,v.xyz)\n ;if (a<1e-7) return vec4(0,0,0,1)\n ;a=.5*sqrt(a)\n ;return vec4(cos(a),v.xyz*(sin(a)*.5/a));}\nvec4 qlog(vec4 q\n){float l=length(q.xyz),s=2.*atan(l/q.w)/l\n ;return vec4(q.xyz*2.*atan(l/q.w)/l,l);}//bug in qexp, final quat constructor args reversed.\nvec4 wpow(vec4 a,vec4 b){return qexp(qlog(a)*b);}//or something like that\nvec4 qrev(vec4 q){q.w=-q.w;return q;}// conjugate quaternion\n// untested, just tossed together to demo qlog,qexp instead of porting original lol - probably backward\n/*vec4 qq2qLerpBAD(vec4 a, vec4 b, float i){\n    //ERROR; will go around the wrong long-angle hyper-geodesic half-the-time, needs bit of work\n   ;if (dot(a, b) < 0.) b.w = -b.w; // should help\n    return qq2q(a,qexp(qlog(qq2q(qrev(a),b))*i));}//from https://www.shadertoy.com/view/ssGSDm\n*/\n//\n//not sure about more use-cases pf qexp() qlog() qpow()\n//\n//return quaternion, that is the shortest rotation, between looking to [a before], and looking to [b after] the rotation.\nvec4 qBetween(vec3 a,vec3 b//http://wiki.secondlife.com/wiki/LlRotBetween\n){float v=sqrt(dd(a)*dd(b));if(v==0.)return qid();v=dot(a,b)/v\n ;vec3 c=a.yzx*b.zxy-a.zxy*b.yzx/v;float d=dd(c)\n ;if(d!=0.){float s=(v>-0.707107) ? 1.+v : d/(1.+sqrt(1.-d));return vec4(c,s)/sqrt(d+s*s);}\n ;if(v>0.)return qid()\n ;float m=length(a.xy);return (m!=0.) ? vec4(a.y,-a.x,0,0)/m : vec4(1,0,0,0);\n ;}//Written by Moon Metty, optimized by Strife Onizuka (faster version, without trigonometry)\nvec4 qBetween2(vec3 a,vec3 b){if(a==b)return qid();return aa2q(cross(a,b),AngleBetween(a,b));}//qBetween() with less code, but has some slower or less precise cases.\n//return inverse of quaternion\nvec4 qinv(vec4 q){return vec4(-q.xyz,q.w)/dd(q);}\n//return VECTOR p, rotated by quaterion q;\nvec3 qv2v(vec4 q,vec3 p){return qq2q(q,qq2q(vec4(p,.0),qinv(q))).xyz;}\n//return [v]vector, rotated by [b] around v2(0)\nv2 r(v3 b,v2 v){\n//return qv2v(b*vec4(1,1,1,-1),v);//somehow this is not identical, fuck it all!\nv2 t=2.*cross(b.xyz, v);return v+b.w*t+cross(b.xyz,t);}//return r(q,r(v3(v,.0),qinv(q))).xyz\n//\n//qv2v()  with swapped inputs\n//return quaterion P (as vector), as if it i rotated by VECTOR p (asif it is a quaternion)\nvec3 vq2v(vec3 p,vec4 q){return qq2q(qinv(q),qq2q(vec4(p,0.0),q)).xyz;}\nvec3 vq2v(vec4 a,vec3 b){return qv2v(a,b);}//in case of namespace confuction\nvec3 qv2v(vec3 a,vec4 b){return vq2v(a,b);}//in case of namespace confuction\n//\n//---quaternion & matrix (second to last in list, because they are bulky)\n//\n//return mat3 of (normalized) [q]uaternion (rotation matrix without translation)\n//uncomment notWorkSafeForNoGoodReason, to break the matrix on some opengl implementations.\n//#define notWorkSafeForNoGoodReason\n//or use mat4 quat_to_transform() (without the translation part) of /WsGfWm\nmat3 q2m(vec4 q //https://www.shadertoy.com/view/WsGfWm\n){vec3 a=vec3(-1,1,0)\n ;mat3 m=mat3(.5)+mat3(q.xzy*a.zxy,q.zyx*a.yzx,q.yxz*a)*q.w\n //above is necessary for compatibility, see /wtdyRs\n +matrixCompMult(outerProduct(q.xyz,q.xyz),1.-mat3(1))//3 unnecessary multy by 0.\n ;q*=q//<-everythig except the main diagonal\n ;m-=mat3(q.y+q.z,0,0,0,q.x+q.z,0,0,0,q.x+q.y)//<- only the main diagonal\n ;return m*2.;}//this *2 scalar may not need to be internal\n//\n//return q2m() as mat4, with [t]ranslation\nmat4 q2m(vec4 q,vec3 t //studying https://www.shadertoy.com/view/WsGfWm\n){mat3 m=q2m(q);return mat4(m[0],0,m[1],0,m[2],0,t,0);}//*=2,and add tranlation\n//return rotation matrix sub of mat4\nmat3 m42Rot(mat4 a){return mat3(a[0].xyz,a[1].xyz,a[2].xyz);}\n#define m2f(a,b) m[a][b]-m[b][a]\nvec4 m2q(mat3 m//return quaternion of orthogonal matrix (with determinant==1., or else quaternionm will not be normalized)\n){float q=2.*sqrt(abs(1.+m[0][0]+m[1][1]+m[2][2]))//http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n ;return vec4(vec3(m2f(2,1),m2f(0,1),m2f(1,0))/q/4.,q);}\n//\n//---quaternion+ EulerRot (last in list, because they are the worst)\n//\n//eulerRot2Quaternion and back \n//- not elegant, not fast\n//- and theres 6 arbitiary, incompatible and non commutative permutatuions of [yaw opitch roll] order\n//BUT, your keyboard inputs are most likely Euler-rotations, so we have to chose one:\n//wikipedia does (jaw pitch roll) order: of a plane taking of;\n//; (jaw)   first    steers like a car\n//, (pitch) secondly the nose pulls up\n//, (roll)  lastly   and in the air to roll\n//\n//above function is used here, but it lacks an inverse, unlike below other order:\n//\nfloat at2e(vec2 a){a*=2.;return atan(a.x,1.-a.y);}\n//return quaternion of Euler[yaw,pitch,roll]     //this one needs to be phased out\n//float mu(vec3 a){return a.x*a.y*a.z;}\nvec4 eYPR2q(vec3 o){o*=.5;vec3 s=sin(o);o=cos(o)\n//https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles#Source_code\n ;vec4 a=vec4(s.xz,o.xz);return  a.yyww*a.zxxz*o.y+a.wwyy*a.xzzx*s.y*vec4(-1,1,-1,1);}\nvec4 eYPR2q(vec2 o){o*=.5;vec2 s=sin(o);o=cos(o)\n ;vec4 a=vec4(s.x,0.,o.x,0.);return  a.yyww*a.zxxz*o.y+a.wwyy*a.xzzx*s.y*vec4(-1,1,-1,1);}\n//return Euler[yaw,pitch,roll]  of quaternion \nvec3 q2eYPR(vec4 q){vec3 r=vec3(0,2.*(q.w*q.y-q.z*q.x),0)\n ;return vec3(at2e(vec2(dot(q.wx,q.zy),dd(q.yz)))          //yaw   (z-axis rotation)\n             //at2e(vec2(q.w*q.z+q.x*q.y,q.y*q.y+q.z*q.z)) //yaw   (z-axis rotation)\n              ,(abs(r.y)>=1.)?r.y=sign(r.y)*pi*.5:asin(r.y)//pitch (y-axis rotation) (worksaved asin())\n              ,at2e(vec2(dot(q.wy,q.xz),dd(q.xy))))        //roll  (x-axis rotation)\n            //,at2e(vec2(q.w*q.x+q.y*q.z,q.x*q.x+q.y*q.y)))//roll  (x-axis rotation)\n ;}//<-untested function\n/*\n//these EulerOrders are being phased out:\n//return quaternion of Euler [pitch, yaw, roll]  //this one needs to be phased out\nvec4 ePYR2q(vec3 o){//return eYPR2q(o.zyx)\n;o*=.5;vec3 s=sin(o);o=cos(o);vec4 a=vec4(s.xy,o.xy)//https://www.shadertoy.com/view/4tSyRz\n ;return a.xyxz*a.wzyw*o.z+a.yxzx*a.zwwy*s.z*vec4(1,-1,1,-1);}\n//return quaternion of EulerRotation [around axes in (Z,Y,X)==(roll,pitch,yaw) order]\nvec4 eRPY2q(vec3 c){c*=.5;vec3 s=sin(c);c=cos(c)//http://wiki.secondlife.com/wiki/LlEuler2Rot\n ;return qq2q(qq2q(vec4(0,0,s.z,c.z),vec4(0,s.y,0,c.y)),vec4(s.x,0,0,c.x));}\n/**/\n\n//from https://www.shadertoy.com/view/wlSyzd\nv3 qlookat(v2 v){return aa2q(v2(-v.y,v.x,0.0),acos(v.z/length(v)));}//point in direction v\nv2 vmulq(v2 p, v3 q){return qq2q(qinv(q),qq2q(v3(p,0.0),q)).xyz;}//inverse rotation\n//---end__ quaternion\n\n\n\n\n\n\n//load and save, originally from iq, modified\nv0 isInside(v1 p,v1 c){v1 d=abs(p-.5-c)-.5;return -max(d.x,d.y);}\n/*v3 load(int re){return texture(iChannel0,(.5+v1(re,.0))/iChannelResolution[0].xy,-100.);}\nvoid store(in int re, in v3 va, inout v3 o, in v1 u\n){if(isInside(u,v1(re,0))>.0)o=va;}//o=(isInside(u,v1(re,0))>.0)?va:o;}\n*/\n\n//#define u2(a)(a*2.-1.)\n#define u5(a)(a*.5+.5)\n//perpendicular dot()used for line intersections.\n#define dotp(a,b)dot(v1(-a.y,a.x),b)\nv0 suv(v1 a){return a.x+a.y;}\nv0 miv(v1 a){return min(a.y,a.x);}\nv0 miv(v2 a){return min(a.z,miv(a.xy));}\nv0 miv(v3 a){return min(miv(a.zw),miv(a.xy));}//return min domain of vector.\n#define mav(a)-miv(-a)\n#define sat(a)clamp(a,0.,1.)\nv3 minx(v3 a,v3 b){return mix(b,a,step(a.x,b.x));}//return the v3 with the smaller .x\n\nv0 suv(v2 a){return a.x+a.y+a.z;}\n//v0 ad(v1 a){return a.x+a.y;}\n//v0 mu(v1 a){return a.x*a.y;} \n\n#define rs3 sqrt(3.)\n#define rs5 sqrt(5.)\n#define phi u4(rs5)\n#define Phi u5(rs5)\n//(reciprocal) [skewConstant] arithmetic:   [rs*]==[reciprocal square of *]\n// ske==.36602540378;//==sqrt(3.)*.5-.5\n//#define   ske u4(rs3)\n//reSke=.21132486540;//==(sqrt(3.)*.5-.5)/sqrt(3.)==.5-.5/sqrt(3.)\n//#define reSke u4(rs3)/rs3\n//enter [0.366025] or [.2113248654] in search engines and be amazed by peoplewho use values without knowing them\n//v1   skew(v1 u){return u+ad(u)*ske;}\n//v1 unskew(v1 u){return u-ad(u)*reSke;}\nv0 det2d(v1 a,v1 b){return a.x*b.y-a.y*b.x;}//2d determinant(mat2(a,b))-=perpendicular dotproduct\n\n//instead of doing imouse.zw=abs(imouse.zw) iMouseZwFix only changes sign when needed.\nvec4 iMouseZwFix(vec4 m,bool NewCoke\n ){if(m.z>0.){ //while mouse down\n    if(m.w>0.)return m;//mouse was clicked in THIS     iFrame \n    else m.w=-m.w      //mosue was clicked in previous iFrame\n    //remember, MouseDrag advances the iFrame Count, even while paused !!\n ;}else{if(!NewCoke||m.w>0.)return m.xyxy; //OPTIONAL onMouseUp (fold or whatever)\n    m.zw=-m.zw;}\n  return m;}\n  \n//checkerboard of https://www.shadertoy.com/view/4lySzc\nv0 board(v2 p){p=floor(p*2.);return mod(p.x+p.y+p.z,2.);}\nv0 board(v1 p){p=floor(p*2.);return mod(p.x+p.y,2.);}\n\n//a matrix of quadraticFields, that share no prime factors, is a fast and simple hash.\nmat3 opop(v2 a,v2 b){return outerProduct(a,v2(1))\n                           +outerProduct(  v2(1),b);}\nmat3 pqfmA(){return opop((v2(2,7,5)),sqrt(v2(13,21,17)));}\n//matrix of quadratic fields with unique prime factors to maximize period length\n//also has the neat effect of all starting at null, which tends to be (near) a special (coplanar) case\n// that we can then skip over and safely assert to not reorrur anytime soon.\n//maybe see https://www.shadertoy.com/results?query=pqfm\n\n//random number (permuted congruential generator)\nuvec4 s0,s1;//internal RNG state \nivec2 pixel;//internal RNG state \nvoid rng_initialize(vec2 p,int frame\n){pixel=ivec2(p)\n ;s0=uvec4(p,uint(frame),uint(p.x)+uint(p.y))//white noise seed\n ;s1=uvec4(frame,frame*15843,frame*31+4566,frame*2345+58585)//blue noise seed\n ;}\nuvec4 pcg4d(uvec4 v//https://www.pcg-random.org/\n){v=v*1664525u+1013904223u\n ;v.x+=v.y*v.w;v.y+=v.z*v.x;v.z+=v.x*v.y;v.w+=v.y*v.z\n ;v=v ^ (v>>16u)\n ;v.x+=v.y*v.w;v.y+=v.z*v.x;v.z+=v.x*v.y;v.w+=v.y*v.z\n ;return v;}\n//float rand(){return float(pcg4d(s0).x)/float(0xffffffffu);}\nvec2 rand2(){return  vec2(pcg4d(s0).xy)/float(0xffffffffu);}\n//vec3 rand3(){return  vec3(pcg4d(s0).xyz)/float(0xffffffffu);}\nvec4 rand4(){return  vec4(pcg4d(s0))/float(0xffffffffu);}\nivec2 shift2(//random blue noise sampling pos\n){return (pixel+ivec2(pcg4d(s1).xy%0x0fffffffu))%1024;}\nvec3 udir(//uniformly spherically distributed\n){vec2 rng=rand2()\n ;vec2 r=vec2(2.*pi*rng.x,acos(2.*rng.y-1.))\n ;vec4 c=vec4(cos(r),sin(r))\n ;return vec3(c.xz*c.ww,c.y);}\nfloat HenyeyGreenstein(float g,float costh\n){return (1.-g*g)/(4.*pi*pow(1.0+g*g-2.0*g*costh,3./2.));}\n \nfloat sdBox(vec3 p,vec3 b\n){vec3 q=abs(p)-b\n ;return length(max(q,0.0))+min(max(q.x,max(q.y,q.z)),0.);}\n\n//subroutines of   https://www.shadertoy.com/view/XlVyDK\n#define le(a) sqrt(dd(a))\n#define co(a) cos(a)\n#define si(a) sin(a)\n//real and imaginary parts for polar z\nfloat arg(vec2 a){return atan(a.y,a.x);}\nvec2 c2p(vec2 a){return vec2(arg(a),le(a));}\nvec2 p2c(vec2 a){return vec2(co(a.x),si(a.x))*a.y;}\nfloat real(vec2 z){return p2c(z).x;return z.s*co(z.t);}\nfloat imag(vec2 z){return p2c(z).y;return z.s*si(z.t);}\n#define pMOD(d,e) d e(inout d a,d b){d c=floor((a/b)+.5);a=(fract((a/b)+.5)-.5)*b;return c;}\npMOD(vec1,pmod)pMOD(vec2,pmod)pMOD(vec3,pmod)pMOD(vec4,pmod)//repetitive only for less repetitive legacy namespace support.\nvec1 pModMirror1(inout vec1 p,vec1 s){float c=pmod(p,s);p*=u2(mod(c,2.));return c;}\nvec2 pModMirror1(inout vec2 p,vec2 s){vec2 c=pmod(p,s);p*=u2(mod(c,2.));return c;}\nfloat pModInterval1(inout float p,float s,float b,float x){float c=pmod(p,s);if(c>x){p+=s*(c-x);c=x;}if(c<b){p+=s*(c-b);c=b;}return c;}\nfloat pModSingle1(inout float p,float s){float c=floor((p/s)+.5);p=mix(p,(fract((p/s)+.5)-.5)*s,step(p,0.));return c;}\nfloat pModPolar(inout vec2 p,float t\n){vec2 q=c2p(p)\n ;float v=pi/t\n ;q.x+=v//offset by half-axis\n ;float c=floor(q.x*.5*v)\n ;q.x=mod(q.x,2.*v)-v\n ;p=p2c(q)\n ;if(abs(c)>=t*.5)c=abs(c)\n ;return c;}\nvec2 pModGrid2(inout vec2 p,vec2 size\n){vec2 c=floor((p+size*.5)/size)\n ;p=mod(p+size*.5,size)-size*.5;p*=mod(c,2.)*2.-vec2(1);p-=size*.5\n ;if(p.x>p.y)p.xy=p.yx;return floor(c*.5)\n ;}\n\n\nvec3 repeat(vec3 u){//return u;\n ;vec3 v=pmod(u,vec3(2.8));return u\n ;}\n\n//- distance Field\n\n/*\n//mandelbulb fractal\nvec3 pq(vec2 a){return vec3(a.x*a.x,a.x*a.y,a.y*a.y);}\nfloat pow7(float a){float b=a*a;float c=b*b;return a*b*c;}\n//mandelbulb.core \n//o.x=distance, o.yzw are for orbittrap memory\n//w.xyz=uv    ,w.w=dd(uv)\nvoid mandelCore(inout vec4 o,inout vec4 w,vec3 u\n){o.x=8.*sqrt(pow7(w.w))*o.x+1.\n ;vec3 w2=w.xyz*w.xyz,w4=w2*w2\n ,e=vec3(ad(w2.xz)\n        ,ad(w4)-6.*dot(w2.zx,w2.yy)+2.*mu(w2.xy)\n        ,su(w2.zxy))\n ;w.xyz=u+vec3( 64.*mu(w.xyz)*su(w2.xz)*ad(pq(w2.xz)*vec3(1,-6,1))\n              ,-16.*w2.y*mu(e.xzz)+e.y*e.y\n              ,-8.*w.y*(dd(w4.xz)+mu(w2.xz)*(-28.*w4.x+70.*mu(w2.xz)-28.*w4.z)))\n              *(vec3(0,1,0)+vec3(1,0,1)*e.z*e.y*inversesqrt(pow7(e.x)))\n ;w.w=dd(w.xyz);}\nvec4 mandelBulbO(vec3 u//return distance.x,orbittrap.yzw\n){vec4 w=vec4(u,dd(u)),o=vec4(1)\n ;for(int i=0;i<5;i++\n ){if(w.w>1.2)break\n  ;mandelCore(o,w,u)\n  ;o.yzw=min(abs(w.xyz)*1.2,o.yzw);}\n ;o.x=0.25*log(w.w)*sqrt(w.w)/o.x;return o;}\nfloat mandelBulb(vec3 u//return distance.x,orbittrap.yzw\n){vec4 w=vec4(u,dd(u)),o=vec4(1)\n ;for(int i=0;i<5;i++\n ){if(w.w>1.2)break\n  ;mandelCore(o,w,u)\n  ;o.yzw=min(abs(w.xyz)*1.2,o.yzw);}\n ;return 0.25*log(w.w)*sqrt(w.w)/o.x;}\n\n//float df (vec3 u){u=repeat(u);return mandelBulb (u);}\n//vec4  dfo(vec3 u){u=repeat(u);return mandelBulbO(u);}\n\n\nvec3 normal(in vec3 p\n){vec2 e=vec2(-1,1)*.001\n ;return normalize(e.yxx*df(p+e.yxx)+e.xxy*df(p+e.xxy)\n                  +e.xyx*df(p+e.xyx)+e.yyy*df(p+e.yyy));}\n*/\n\n\n//damn, this is a fisheye cam that is just as complex.\n//in short i fail\n\n//getRayDir() lookAtCamera is 3* normalize(cross()), it seems to be a lazy and slow camera.\n//quatrernion alternatives exist:\n//https://www.shadertoy.com/view/wl3yDs\n//commontab has quaternion functions:\nvec3 getCam(vec3 ro, vec3 lookAt, vec2 uv\n){/*\n ;vec3 f = normalize(lookAt - ro)\n ,r = normalize(cross(vec3(0, 1, 0), f))\n ;return normalize(f + r * uv.x + cross(f, r) * uv.y);/**/\n ;\n ;vec4 quatUv=eYPR2q(vec3(uv,0.).zxy)//fragCoord.xy/iResolution*2.-1.) //uv.y not scaled by AspectRatio?\n ;lookAt=normalize(lookAt-ro)\n ;vec3 rayDirection=qv2v(quatUv,lookAt)*vec3(1,-1,1)\n ;return rayDirection;}\n /**/\n\nmat3 getCam(vec2 a// phi.x,theta.y\n){vec3 x_dir=vec3(cos(a.x)*sin(a.y),sin(a.x)*sin(a.y),cos(a.y))\n ;vec3 y_dir=normalize(cross(x_dir,vec3(0,0,1)))\n ;vec3 z_dir=normalize(cross(x_dir,y_dir))\n ;return mat3(x_dir,y_dir,z_dir);}\n\nmat3 getCam(sampler2D s//buffer is a quaternion\n){return q2m(get2(camA0,s));}\n\n\n//https://en.wikipedia.org/wiki/Alpha_compositing\n//https://doc.qt.io/archives/qq/qq17-compositionmodes.html \n//from   https://www.shadertoy.com/view/wdsSWS\n//.w=0 is fully transparent, .W=1 is fully visible\n//iff(you want to keep an alpha channel after a composition) you must premultiplay all inputs wioth their alpha;\n//; a.xyz*=a.w\n//; b.xyz*=b.w\n//and the outputs of these functions will be already_premultiplied.\n//\n//else if(you to one last pdOver a nontransparent background) you must NOT premultiply the backbround!\n//pdver without premultiplied alpha, note that nonstransparent red+nontransparent green = nontransparendt yellow.\n//vec4 pdo(vec4 a,vec4 b){return vec4((a.xyz*a.w+b.xyz*b.w)/(a.xyz+b.w*(1.-a.w)),,a.w+b.w*(1.-a.w));}\n//these functions are with premultiplied alpha (better performance, easy to buffer)\n//\n//GENERAL alpha composition:  named after porterDuff\n//see https://en.wikipedia.org/wiki/Alpha_compositing\n//    https://doc.qt.io/archives/qq/qq17-compositionmodes.html\n//.w=0 is fully transparent, .W=1 is fully visible\n//inputs should be x=sat(x), or you likely get [color inverted hazes], this version is still not haze-free?\n//\n//on premultiplication:\n//iff (you want to keep an alpha channel after a composition)  !!!!\n//You must FIRST premultiplay all inputs with their alpha.w :  !!!!\n//; a.xyz*=a.w                                                 !!!!\n//; b.xyz*=b.w                                                 !!!!\n//on general [premultiply], you may want to watch              !!!!\n//https://www.youtube.com/watch?v=XobSAXZaKJ8                  !!!!\n//\n//IFF you can discard the alpha channel after a SINGLE composition\n//, you may also skip the premultiply-multiplication in some cases.\n\n//ut() is a subroutine for alpha compositing:\n//#define ut(a,b) (a*(1.-b))   //this one liner is a lot less worksafe!\nvec4 ut(vec4 a,vec1 b){return a*(1.-b);}\nvec3 ut(vec3 a,vec1 b){return a*(1.-b);}\nvec2 ut(vec2 a,vec1 b){return a*(1.-b);}\nvec1 ut(vec1 a,vec1 b){return a*(1.-b);}\n//below are the 5 alpha compositions:\nvec4 pdOut (vec4 a,vec4 b){return ut(b,a.w);}\nvec4 pdOver(vec4 a,vec4 b){return ut(b,a.w)+a;}\nvec4 pdAtop(vec4 a,vec4 b){return ut(b,a.w)+(a*b.w);}\nvec4 pdXor (vec4 a,vec4 b){return ut(b,a.w)+vec4(ut(a,b.w));}\nvec4 pdIn  (vec4 a,vec4 b){return vec4(a.xyz*b.w,1);}//pdIn() is just multiplication, note swapped AB case here\n//the above ommits the variant that returns 0 and a&b-inoput-swapped functions to half function/count\n//the above ommits 2 functions, that return a or b, for simplicity\n//end of basic part of alpha compositing (yep, thats ALL there is to it)\n//\n//start of extended alpha compositing \n//...adds interpolation+generalization to compositing (interpolating different types of compositing)\n//The below allows you to MIX(a,b,c) between any 2 or 4 types of alpha compositing, by the parameter [c]\n//pf() does unify all 5 pd-compositions (above) into 1 parametric function\n//pf() was a silly idea of smoothly cyling between 5 compositions\n//pf() was quickly obsoleted by pf()\n//pdOverAtop() and pdOutXor() are interpolating subroutines for pf()\n#define pdOverAtop(a,b,c) a*mix(b,1.,c)\n#define pdOutXor(a,b,c) mix(ut(a,b),vec3(0),c)\n//pf() has c set how we interpolate; c is range [0..4] and whole-bumber-c causes a [mix(a,b,0.)==a] result\n#define Over 0. //[c range 0..1 => over..atop]\n#define Atop 1. //[c range 1..2 => atop..out]\n#define Out  2. //[c range 2..3 =>  out..Xor]\n#define Xor  3. //[c range 3..4 =>  xor..In]\n#define In   4.\n//the ability to interpolate is just a side effect of using mix() to generalize.\n//pf() may actually only work well for c=floor(c) its not tested well.\nvec3 pf(vec4 a,float c,vec4 b\n){if(c>3.)return a.xyz*b.w//pdIn is just multiplication.\n ;vec3 d=vec3(0);d=mix(pdOverAtop(a.xyz,b.w,c),pdOutXor(a.xyz,b.w,c-2.),step(2.,c));return d+ut(b.xyz,a.w) ;}\n//\n//pd() makes more sense than pf() for demoing interpolation of compositing\n//pd() does bilinear interpolatin over c.xy, as in https://www.shadertoy.com/view/wdsSWS\n//top    left  = Over\n//top    right = Xor\n//bottom left  = Atop\n//bottom right = Out \nvec4 pd(vec4 a,vec2 c,vec4 b){c.x=sat(c.x)//clamping c.x to ensure bounds.\n ;return mix(a*mix(b.w,1.,c.y),ut(a,b.w)*c.y,c.x)+ut(b,a.w);}\n/**/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//buffC.start\n//ichannel0=self\n//ichannel1=keyIn\n\n//this buffer has its own shitty cameraControls\n//, to be replaced by the camera control of BuffB\n\n/*\nbezier patch analytic: https://www.shadertoy.com/view/4tSyRz\n- single page, less duped code. trutural sorting \n- less globals, more object oriented.\n- more defines\n- larger render distance.\n- establishing [tiny namespace convention]\n- - mostly in scene()\n- - distance field is called gd() and gd1()for colors (resolves fractal G-buffer stuff?)\nparent: https://www.shadertoy.com/view/lsd3Dl\n  Rocket City by eiffie (although there are no rockets \n   and there is little if any esemblance to a city this is what eiffie called it)\n  eiffie just wanted to make a reusable flight control \n   but then messed that up with collision detection.\n*/\n\n//Cartesian to barycentric(relative to spline verts)\nv2 CartToBary(v1 c,v1 p1,v1 p2,v1 p3\n){c-=p1;v1 a=p2-p1,b=p3-p1,d=v1(dot(c,b),dot(c,a))\n ;v2 r=v2(dd(a),dd(b),dot(a,b))\n ;r=v2(0.,det2d(r.yz,d),det2d(r.xz,d.yx))/det2d(r.yz,r.zx)\n ;return v2(1.-r.y-r.z,r.yz);}\n\n//quaternions q()<->creation r()<->rotaition\n//use like matrix multiplication, see https://www.shadertoy.com/view/lstSRM\n//normalize quaternion: true for quaternions <-> nornamoze(q)=q/length(q)==q/length(q*q)=q/dot(q,q)\n//v3 qid(){return v3(0,0,0,1);}//NULL_ROTATION\n//v3 qinv(v3 q){return v3(-q.xyz,q.w)/dd(q);}//inverse quaternion\nv3 q(v2 o){o*=0.5;v2 s=sin(o),c=cos(o) //quaternion from pitch,yaw,roll (in that order):\n          ;return v3(s.x*c.y*c.z+s.y*c.x*s.z,s.y*c.x*c.z-s.x*c.y*s.z\n,s.x*s.y*c.z+s.z*c.x*c.y, c.x*c.y*c.z-s.x*s.y*s.z);}\nv3 q(v3 q){return q/dd(q);} //normalize quaternion (may be needed after every 5th rotation)\n//return quaternin of [axis]&{angle] rotation\n//v3 q(v2 axis, v0 angle){angle*=.5;return v3(axis*sin(angle),cos(angle));}\n//return [r]rotation, rotated by [b]\n//v3 r(v3 b,v3 r){return v3(b.w*r.xyz+r.w*b.xyz+cross(b.xyz,r.xyz),b.w*r.w-dot(b.xyz,r.xyz));}\n//return p, rotated by b, AROUND c (center) instead of around v2(0) (offset rotation)\n//v2 r(v3 b,v2 p,v2 c){return r(b,p+c)-c;}\n//return shortest rotation fro+\n//get rotation from a to b (around v2(0), has higher precision for small angles: Written by Moon Metty, optimized by Strife Onizuka\n\n\n//trace AABV-box 3d,2d,1d, all worksave, reciprocal direction replaces a lot of branching and epsilon nonsense\n//is more precise the closer length(direction) is to 1\n//returns: .x if box is hit, .y=far root, .y=near root.\n//rayorigin,raydirection,lowcorner,highcorner\n//worksaving, if(one domain of raiDir ==0) this is a simpler special case with one less domain.\n#define TABV(a,b) if(d.a==0.)return abv(d.b,l.b,h.b)\nv2 abv(v0 d,v0 l,v0 h//rayDirection,lowCornerMinusRayorigin,highcornerMinusRayorigin\n){if(d==0.)return v2(0)//directionless ray is not a ray\n ;d=1./d;l=l*d;h=h*d\n ;d=min(h,l);h=max(h,l);return v2(v0(h>max(d,0.)),h,d);}\nv2 abv(v1 d,v1 l,v1 h//rayDirection,lowCornerMinusRayorigin,highcornerMinusRayorigin\n){TABV(x,y);TABV(y,x);d=1./d;l=l*d;h=h*d\n ;v0 o=mav(min(h,l))\n ;h.x=miv(max(h,l))\n ;return v2(v0(h.x>max(o,0.)),h.x,o);}\nv2 abv(v2 d,v2 l,v2 h//rayDirection,lowCornerMinusRayorigin,highcornerMinusRayorigin\n){TABV(x,yz);TABV(y,xz);TABV(z,xy);d=1./d;l=l*d;h=h*d\n ;v2 o=min(h,l)\n ;h=max(h,l)\n ;o.xy=max(o.xx,o.yz);o.z=mav(o.xy)\n ;o.xy=min(h.xx,h.yz);o.x=miv(o.xy)\n ;return v2(v0(o.x>max(o.z,0.)),o.x,o.z);}\n#define aabv(o,d,l,h) abv(d,l-o,h-o)\n\nv2 triangleNornal(v2 a,v2 b,v2 c){return cross(a-b,a-c);}//normal of triangle of 3 pointsi is cross() of any 2 sides.\n\n//LineSegmentAB+RayUD intersection\nv1 LineISect(v1 a,v1 b,v1 u,v1 d\n){vec4 c=vec4(b.y-a.y,a.x-b.x,d.y-u.y,u.x-d.x)\n ;u=v1(dot(c.zw,u),det2d(c.xy,c.zw))\n ;if(u.y==0.)return v1(0)//parralel lines do not intersect.\n ;c*=v3(u.xx,vec2(dot(c.xy,a)))\n ;return (c.wx-c.yz)/u.y;}\n\n/* //explicit version for compatibility where bvec4 is not a defined type.\nbool altm(v1 a,v3 b){\n ;v3 c=v3(a,b.zw)\n ;b=v3(b.xy,a)\n ;if(c.x<b.x)return true;\n ;if(c.y<b.y)return true;\n ;if(c.z<b.z)return true;\n ;if(c.w<b.w)return true;\n ;return false\n ;//return any(lessThan(v3(a,b.zw),v3(b.xy,a)))\n ;}*/\n\n\n/*\n//grandparent backup version to check errors\nv1 v2VertA = v1( 0.0, 4.0 ); \nv1 v2VertB = v1(-4.0,-4.0 );\nv1 v2VertC = v1( 4.0,-4.0 );\n#define D_BIAS 0.0001\nv2 CartToBary( v1 v2Cart ){\n    v1 w0 = v2VertB - v2VertA;\n    v1 w1 = v2VertC - v2VertA;\n    v1 w2 = v2Cart - v2VertA;\n    v0 d00 = dot(w0, w0);\n    v0 d01 = dot(w0, w1);\n    v0 d11 = dot(w1, w1);\n    v0 d20 = dot(w2, w0);\n    v0 d21 = dot(w2, w1);\n    v0 denom = d00 * d11 - d01 * d01;\n    v2 v3Bary;\n    v3Bary.y = (d11 * d20 - d01 * d21) / denom;\n    v3Bary.z = (d00 * d21 - d01 * d20) / denom;\n    v3Bary.x = 1.0 - v3Bary.y - v3Bary.z;\n    return v3Bary;}\nv3 BezierTriISect( const v2 v3CameraPos, const v2 v3LookDir, v2 CP_2, v2 CP_0 ){\n    v1 v2LookPt = v3CameraPos.xy + v3LookDir.xy;\n    //This is a hacky brute-force way of finding limits of triangle bounding retion.  \n    // I will probably re-write this with a better approach.\n    v1 v2PosA = LineISect( v2VertA, v2VertB, v3CameraPos.xy, v2LookPt );\n    v1 v2PosB = LineISect( v2VertB, v2VertC, v3CameraPos.xy, v2LookPt );\n    v1 v2PosC = LineISect( v2VertC, v2VertA, v3CameraPos.xy, v2LookPt );\n    v1 v2MinA = v1( min( v2VertA.x, v2VertB.x ), min( v2VertA.y, v2VertB.y ) ) - D_BIAS;\n    v1 v2MinB = v1( min( v2VertB.x, v2VertC.x ), min( v2VertB.y, v2VertC.y ) ) - D_BIAS;\n    v1 v2MinC = v1( min( v2VertC.x, v2VertA.x ), min( v2VertC.y, v2VertA.y ) ) - D_BIAS;\n    v1 v2MaxA = v1( max( v2VertA.x, v2VertB.x ), max( v2VertA.y, v2VertB.y ) ) + D_BIAS;\n    v1 v2MaxB = v1( max( v2VertB.x, v2VertC.x ), max( v2VertB.y, v2VertC.y ) ) + D_BIAS;\n    v1 v2MaxC = v1( max( v2VertC.x, v2VertA.x ), max( v2VertC.y, v2VertA.y ) ) + D_BIAS;\n    bool bAValid = \n        v2PosA.x >= v2MinA.x && v2PosA.x <= v2MaxA.x && \n        v2PosA.y >= v2MinA.y && v2PosA.y <= v2MaxA.y;\n    bool bBValid =\n        v2PosB.x >= v2MinB.x && v2PosB.x <= v2MaxB.x &&\n        v2PosB.y >= v2MinB.y && v2PosB.y <= v2MaxB.y;    \n    bool bCValid =\n        v2PosC.x >= v2MinC.x && v2PosC.x <= v2MaxC.x && \n        v2PosC.y >= v2MinC.y && v2PosC.y <= v2MaxC.y;\n    v0 fCamDistA = (v2PosA.x - v3CameraPos.x) / v3LookDir.x;\n    v0 fCamDistB = (v2PosB.x - v3CameraPos.x) / v3LookDir.x;\n    v0 fCamDistC = (v2PosC.x - v3CameraPos.x) / v3LookDir.x;\n    \n    v2 v3Start, v3End;\n    if( bAValid && bBValid )    {\n        v3Start = v3CameraPos + v3LookDir * min( fCamDistA, fCamDistB );\n        v3End = v3CameraPos + v3LookDir * max( fCamDistA, fCamDistB );\n    }else if( bBValid && bCValid )    {\n        v3Start = v3CameraPos + v3LookDir * min( fCamDistB, fCamDistC );\n        v3End = v3CameraPos + v3LookDir * max( fCamDistB, fCamDistC );\n    }else if( bCValid && bAValid )    {\n        v3Start = v3CameraPos + v3LookDir * min( fCamDistC, fCamDistA );\n        v3End = v3CameraPos + v3LookDir * max( fCamDistC, fCamDistA );\n    }else{       return v3( 0.0, 0.0, 0.0, 2.0 );    }       //no intersection!\n    v2 S = CartToBary( v3Start.xy );\n    v2 E = CartToBary( v3End.xy );\n    //Plug in eye ray and solve variables for root finding.\n    v2 ES = E - S;\n    v0 fA = dot( ES * ES, CP_2 ) + 2.0*dot( v2(ES.y*ES.z, ES.x*ES.z, ES.x*ES.y), CP_0 );\n    v0 fB = - (v3End.z - v3Start.z) + 2.0*( \n        dot( ES*S, CP_2 ) + \n        dot( v2((ES.y*S.z + ES.z*S.y), (ES.x*S.z + ES.z*S.x), (ES.x*S.y + ES.y*S.x)), CP_0 ) );\n    v0 fC = - v3Start.z + dot( S*S, CP_2 ) +\n    \t2.0*dot( v2(S.y*S.z,S.x*S.z,S.x*S.y), CP_0 );    \n    //Actual root finding\n    v0 fRoot = fB*fB - 4.0*fA*fC;\n    if( fRoot >= 0.0 )    {\n        v0 fRootA = (-fB + sqrt( fRoot ) ) /( 2.0 * fA );\n        v0 fRootB = (-fB - sqrt( fRoot ) ) /( 2.0 * fA );        \n        if( fRootA >= 0.0 && fRootA <= 1.0 )        {\n            if( fRootB >= 0.0 )                fRootA = min( fRootB, fRootA );\n            return v3( S + fRootA*ES, fRootA );        }\n        if( fRootB >= 0.0 && fRootB <= 1.0 )            return v3( S + fRootB*ES, fRootB );    }    \n    return v3(0.0, 0.0, 0.0, 2.0);}/**/\n\n//by @JJcoolkl,crunched by ollj\n//analytical intersection of RAY [u,d]=[origin,direction] \n//and quadratic-bezier triangular-patch(6 CV-heights)\n//in:\n//c1,c0 6 CW heights (orthogonal to triangle plane)\n//p1,p2,p3 corners of base triangle\n//res=resolution.x (screen width in oixel)\n//out:\n//.xyz returns intersection\n//.w   returns if it hits (.w<=1 means it hit a surface)\n//inout:\n//cd is a debug color, used to show the bounding volume, and 3 cases within that volume.\nv3 BezierTriISect(const v2 u,const v2 d,v2 c1,v2 c0,v1 p1,v1 p2,v1 p3,v0 res,inout v2 cd\n){\n ;//return BezierTriISect(u,d,c1,c0) //reference to grandparent version, to compare if i introduced an error, or found a grandpparent error\n ;v1 L=u.xy-d.xy\n ,a=LineISect(p1,p2,u.xy,L)//project ray onto the triangle, within its ray+triangle intersections\n ,b=LineISect(p2,p3,u.xy,L)\n ,c=LineISect(p3,p1,u.xy,L)//three 2d intersections\n //\n //sicne eror hairlines are always lines, the error seems to be in the projected triangle 2d intersection.\n //\n //g+bA, h+bB, o+bC distinguish 3 ways to slice a triangle in two, in respect to its corners \n #define Mm(a,b,c)min(a.c,b.c)\n #define MM(a,b,c)max(a.c,b.c)\n #define mmm(a,b)v3(Mm(a,b,x),Mm(a,b,y),MM(a,b,x),MM(a,b,y))+q\n ;v3 q=v3(-1,-1,1,1)*.001/res//tiny epsilon accounts for precision loss. this seals the seam between 2 planes in screenspace\n //;v3 q=v3(-1,-1,1,1)*4./res//just to visualize the screenspace seam\n ,g=mmm(p1,p2),h=mmm(p2,p3),o=mmm(p3,p1)\n #define altm(a,b)any(lessThan(v3(a,b.zw),v3(b.xy,a)))\n ;bool bA=altm(a.xy,g),bB=altm(b.xy,h)\n ;v2 f,e=(v2(a.x,b.x,c.x)-u.x)/d.x//e stores 3 lengths.x of raystart.x to intersections.x, we care more for the shorter ones here.\n ;cd=v2(.7,0,0);//initially assume intersection with 1/3 sides of a \"triangle prism\"\n ;       if(  bA||bB ){bool bC=altm(c.xy,o)//restructured,1/3 of all cases skips the calculation of cB (remains default assumed case above)\n  ;      if(!(bB||bC)){e=e.yzx;cd=cd.yzx//intersection with 1/3 sides of a \"triangle prism\"\n  ;}else if(!(bA||bC)){e=e.zxy;cd=cd.zxy//intersection with 1/3 sides of a \"triangle prism\"\n ;}else{cd=cd.yyy;return v3(0,0,0,2);}}//no intersection with prism\n ;f=u+d*miv(e.xy);v2 S=CartToBary(f.xy,p1,p2,p3)//barycentric projection root solving black magic\n ;e=u+d*mav(e.xy);v2 E=CartToBary(e.xy,p1,p2,p3)-S//Plug in eye ray and solve variables for root finding.\n ;o=v3(0,f.z-e.z,dot(S*S,c1)-f.z,0)\n   +v3(dot(E*E,c1)+dot(E.yxx*E.zzy,c0)*2.\n      ,dot(E*S,c1)+dot(v2(dot(E.yz,S.zy),dot(E.xz,S.zx),(E.x*S.y+E.y*S.x)),c0)//i smell a cross()\n      ,dot(v2(S.y*S.z,S.x*S.z,S.x*S.y),c0),0)*2.//3 root solving factors; .x is the scalar to baricentric range[0..1]\n ;o.z=o.y*o.y-2.*o.x*o.z\n ;if(o.z>=0.&&o.x!=0.//worksafing\n ){a=(v1(1.,-1.)*sqrt(o.z)-o.y)/o.x;//[a] stores 2 distances to two roots, scaled to a [0..1] barycentric range., a.x may not be within that range, meaning theres less than 2 roots.\n  ;if(abs(a.x-.5)<.5\n  ){if(a.y>0.) a.x=miv(a); //a.xy may not be within that [0..1]range, meaning theres less than 2 roots, we hope theres one root.\n   ;return v3(S+a.x*E,a.x);}\n  ;if(abs(a.y-.5)<=.5){cd+=v2(0,.3,.3);return v3(S+a.y*E,a.y)//;if(a.y>=0.&&a.y<=1.)\n  ;}};return v3(0,0,0,2);}//no intersection\n\n\n//above function has triangle normal fixed to v2(0,0,+11), all corners have .z==0.\n//below version rotates the whole set around p1 to set the triangle normal to v2(0,0,1)\nv3 BezierTriISect(v2 u,v2 d,v2 c1,v2 c0,v2 p1,v2 p2,v2 p3,v0 res,inout v2 cd\n){v2 n=normalize(triangleNornal(p1,p2,p3))\n ;v3 b=qBetween(n,v2(0,0,1))\n ;//we rotate everything around p1, and then move it by -p1.z, to make all p*.z values ==0.\n ;v2 s=v2(0,0,p1.z);\n \n// ;u =r(b,u ,p1)-s\n// ;d =r(b,d ,p1)-s\n// ;p2=r(b,p2,p1)-s\n// ;p3=r(b,p3,p1)-s\n ;return BezierTriISect(u,d,c1,c0,p1.xy,p2.xy,p3.xy,res,cd);}\n//this transform seems to be false.\n\n\n//--- all above code used to be in a commontab\n\n\nv2 BezierTriangle_Quadratic_Normal(const v2 u,const v2 a,const v2 b,v2 p1,v2 p2,v2 p3//get normal(2nd derivative)of quadradicBezier triangularPatch\n){v2 n=triangleNornal(p1,p2,p3)\n ;v3 c=qBetween(n,v2(0,0,1))\n ;//we rotate everything around p1, and then move it by -p1.z, to make all p*.z values ==0.\n ;//v2 s=v2(0,0,p1.z);\n ;//p2=r(c,p2,p1)-s\n ;//p3=r(c,p3,p1)-s\n ;return normalize(cross(v2(p1.xy-p2.xy,suv(u*v2(a.x-b.z,b.z-a.y,b.y-b.x)))\n                        ,v2(p1.xy-p3.xy,suv(u*v2(a.x-b.y,b.z-b.x,b.y-a.z)))));}\n\nv3 ComputeBezierColor(v2 u,v2 d,v2 a,v2 b,v2 p1,v2 p2,v2 p3,v0 res,inout v2 cd//get color based on bezier tri intersection+lighting\n){v3 v4ISect=BezierTriISect(u,d,a,b,p1.xy,p2.xy,p3.xy,res,cd)//analytical intersection of ray [u,d] and triangular quadratic-bezier patch(6 CV-heights [a,b])\n ;v2 c=v2(0)\n ;//v4iSect form may be return v3(S+a.y*E,a.y)\n //where S and E are baricentric.xyz and a.x (or a.y) are the closest root.\n ;//we basically only care for the .w parameter\n ;if(v4ISect.w<2.\n ){v2 n=BezierTriangle_Quadratic_Normal(v4ISect.xyz,a,b,p1,p2,p3)//analytical first derivative\n  ;c=n*.5+.5\n  ;if(board(v4ISect.xyz*9.)>0.)c.z=1.-c.z//barycentric checkerboard\n  ;return v3(c,1);}return v3(0);}\n\n//controls (i may have swapped left and right here, do not overthing this one)\n#define LEFT_ARROW 39\n#define RIGHT_ARROW 37  \n#define UP_ARROW 38\n#define DOWN_ARROW 40\n\n#define THRUST 0.1*iTimeDelta\n#define ROLL 1.0*iTimeDelta\n#define ROTATE 4.0*iTimeDelta\n//collision epsilon\n#define TOO_CLOSE 0.01\n//should scale with movement speed\n//return signed distane of[p] to a surface. (relict for collision detection of flyCamera.\nv0 gd(v2 u){return 999.;}//never collide\n\n//bool KeyDown(in int key){return (texture(iChannel1,v1((v0(key)+0.5)/256.0, 0.25)).x>0.0);}\nv0 key(in int key){return texture(iChannel1,v1((v0(key)+0.5)/256.0, 0.25)).x;}\n\n/*\n//namespace convention\n[o]RayOrigin\n[d]RayDirection\n[c]color, to be returned\n[f]FragmentSpaceScaling, to blur rasterization, against moire;a=smoothstep(s,-s,a);\n[t]TimeTraveled (implies division by speed of light) == distance to camera \n[g]gradient, signed distance to surface.\n*/\n\nv0 sp(v2 u,v2 d,vec4 s//draw CV as transparent spheres,with simple projection;radius scaled by distance to camera.//cameraPos,Sphere\n){u-=s.xyz;v0 a=dot(d,u);u.x=length(u);s.w+=.0001;u.y=s.w*s.w;return sat(mix(0.,1.,(a*a-(u.x*u.x)+u.y)/(u.y-s.w*s.w)));}\nv0 ComputeOverlay(v2 u,v2 d,v2 a,v2 b,v2 p1,v2 p2,v2 p3\n ){v2 n=normalize(triangleNornal(p1,p2,p3))\n  ;return sp(u,d,v3(p1+n*a.x,.2))\n         +sp(u,d,v3(p2+n*a.y,.2))      \n         +sp(u,d,v3(p3+n*a.z,.2))      \n         +sp(u,d,v3((p1+p2)*.5+n*b.x,.2))\n         +sp(u,d,v3((p3+p1)*.5+n*b.y,.2))\n         +sp(u,d,v3((p2+p3)*.5+n*b.z,.2));}//paint 6 CVs\n\n//lots of min max for an aabv\nv0 doAABV(v2 v,v2 d,v2 p1,v2 p2,v2 p3,v2 a,v2 b){\n     ;v2 n=normalize(triangleNornal(p1,p2,p3))\n// ;v3 q=RotBetween(n,v2(0,0,1))\n/*\n ;v2 s=v2(0,0,p1.z);\n ;p2=r(q,p2,p1)-s\n ;p3=r(q,p3,p1)-s\n/**/ \n ;v2 cv1=p1+n*a.x,cv12=(p1+p2)*.5+n*b.x\n ;v2 cv2=p2+n*a.y,cv23=(p3+p3)*.5+n*b.y\n ;v2 cv3=p3+n*a.z,cv31=(p3+p1)*.5+n*b.z\n #define muchm(a,b,c) v0 b=a(a(a(cv1.c,cv2.c),a(cv3.c,cv12.c)),a(cv23.c,cv31.c))\n ;muchm(min,x,x);muchm(max,X,x)\n ;muchm(min,y,y);muchm(max,Y,y)\n ;muchm(min,z,z);muchm(max,Z,z)     \n ;v2 aa=aabv(v,d,v2(x,y,z),v2(X,Y,Z))\n ;if(aa.x<1.)return 0.//outside of AABV\n ;return 1.;}\n\nv2 bezierPatch(v2 v,v2 d,v2 p1,v2 p2,v2 p3){//position,direction, trianglecorners \n ;v3 o=v3(0);\n ;mat3 pq=pqfmA()//matrix of different quadratic fields, to be most aperiodic\n ;pq=pq*(iTime*.2+.001)//.001 to skip the coplanar case at iTime==0 (with tiny determinant). dare to get closer to it, its quite the precision-mess where it gets too planar (but not quite planar)\n ;v2 a=cos(pq[0]),b=cos(pq[2])\n ;//a=v2(0,1,2)\n ;//b=v2(0,1,2)\n ;a*=9.\n ;b*=9.\n ;v2 cd=v2(0)\n //the line below is completely optional, and may not even be worth computing\n //as it is only an AxisAlignedBoundingVolume for culling.\n ;if(doAABV(v,d,p1,p2,p3,a,b)==0.\n ){\n  ;return v2(.5)//if(ray misses AABV)return grey!\n ;}\n ;//a*=0.0;b*=0.0 //known bug debug enforcing case: planar case has determinant of 0 special case!\n ;v3 c=ComputeBezierColor(v,d,a,b,p1,p2,p3,iResolution.x,cd)\n ;c=mix(v3(.5,.5,.5,1.),c,c.a)//lazy alpha compositioning\n ;if(c.xyz==v2(.5))c.xyz=mix(c.xyz,cd,.2)//debug color output\n ;o=mix(c,v3(.7,.7,.7,1),ComputeOverlay(v,d,a,b,p1,p2,p3))\n ;return o.xyz;\n;}\n \nv2 scene(v2 o,v2 d\n){v2 //3 corners.xyx of a triangle\n//, that the bezier patch is pklaced above and below of\n//all ControllVectors only move in the .z direction.\n p1=v2(-4,0,0)\n,p2=v2(4,0,0)\n,p3=v2(0,sqrt(3.)/3.*4.*4.,0);//.z==0. for simplicity/debugging\n ;return bezierPatch(o,d,p1,p2,p3)\n ;}//origin,direction\n\n\n//below code copied from https://www.shadertoy.com/view/DsKBDw\n//and then slowly modified to replace the camera, and to understand it more (compacting/aliasing...)\n \n// https://www.shadertoy.com/view/DsKBDw asymmetric blocks with portals reflections, 2023 by jt\n// based on https://www.shadertoy.com/view/msVfzw asymmetric blocks with portals 3d\n// Added reflections and stairs to https://www.shadertoy.com/view/msVfzw asymmetric blocks with portals 3d.\n// Thanks to Shane for suggesting the DDA-plugin / snap-to-voxel method & for the asymmetric blocks idea!\n\n// tags: 3d, random, reflections, t, blocks, portal, double, door, passage, connection, alternating, irregular, asymmetric\n\n// The MIT License\n// Copyright (c) 2023 Jakob Thomsen\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// For correct ambient occlusion sample 2x2x2 voxels (slow!)\n//#define HIGH_QUALITY XXX CURRENTLY BROKEN DUE TO APPROXIMATE SDF AT PORTALS XXX\n\nfloat hash12(vec2 p){ // https://www.shadertoy.com/view/4djSRW Hash without Sine by Dave_Hoskins\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);}\n\nvec2 hash22(vec2 p){ // https://www.shadertoy.com/view/4djSRW Hash without Sine by Dave_Hoskins\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);}\n\nvec3 hash32(vec2 p){ // https://www.shadertoy.com/view/4djSRW Hash without Sine by Dave_Hoskins\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);}\n\nvec3 hash33(vec3 p3){ // https://www.shadertoy.com/view/4djSRW Hash without Sine by Dave_Hoskins\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);}\n\nstruct block{\n    vec4 center;\n    vec4 extent;\n    ivec2 id;\n    ivec2 id0;\n    ivec2 id1;\n    bool flag;};\n\nblock empty_block(){return block(vec4(0), vec4(0), ivec2(0), ivec2(0), ivec2(0), false);}\n\n#define block_offset 0.2\n#define wall_size 0.02\n\nfloat block_hash(ivec2 t, int x, int y, bool choose, bool mirror){\n    ivec2 d = (mirror?ivec2(y, x):ivec2(x, y));\n    //vec2 r = fract(hash22(vec2(t+d)))+vec2(d); // [0,1]\n    vec2 r = mix(vec2(block_offset), vec2(1.0 - block_offset), fract(hash22(vec2(t+d))))+vec2(d); // [constrained]\n    return choose?r.y:r.x;}\n\n// Inspired by https://www.shadertoy.com/view/Ws3GRs Asymmetric Blocks by Shane.\n// Checkerboard tiling of alternating (horizontal vs. vertical) (double-T-) crossings.\n// Returns minimum, maximum, id.\n// Compactified using implicit matrix transpose & deferred hash calls.\n//(NOTE: inlining the hash-function and using out parameters instead of block structure\n//       could be used to turn this into a stand-alone function.)\nblock blocks_layout(ivec2 tile, vec2 local){ // https://www.shadertoy.com/view/dstfzf asymmetric blocks compactified f by jt\n    //bool flip = (tile.x % 2) != (tile.y % 2); // XXX breaks on windows XXX\n    bool flip = (tile.x & 1) != (tile.y & 1); // alternate direction of double T crossings: vertical or horizontal\n    //flip = !flip; // \"dual\" pattern (i.e. T-crossings flipped)\n\n    // layout (NOTE: matrix notation upside down compared to coordinate system!)\n    // NW N NE\n    //  W C E\n    // SW S SE\n    // transposed (NOTE: matrix notation upside down compared to coordinate system!)\n    // SE W NE\n    //  N C S\n    // SW E NW\n    if(flip){ // horizontal line goes through: swap vertical with horizontal\n        // swap components\n        local = local.yx;}\n    // vertical line goes through (on flip transpose for horizontal line)\n    //                 c\n    //   +-+---------+---+-------+\n    //   | |         |   |       |\n    //   | |         |   #-------+ d\n    // d +-#-#-------+---M       |\n    //   |   |       |   |       |\n    //   +---+-------+---+-------+\n    //   |   |       |   |       |\n    //   |   m-------+---#---#---+\n    //   +---#       |       |   |\n    //   |   |       |       |   |\n    //   +---+-------+-------+---+\n    float c = block_hash(tile, 0, 0,  flip, flip); // offset of central line\n    int x = 1-int(local.x < c); // [0,1]\n    int X = 2*x-1; // [-1,+1]\n    float d = block_hash(tile,+X, 0, !flip, flip); // offset of branching line\n    float e = block_hash(tile,-X, 0,!flip, flip); // offset of branching line\n    int y = 1-int(local.y < d); // [0,1]\n    int Y = 2*y-1; // [-1,+1]\n    vec4 vv0 =\n        vec4 (\n            // primary corner in (0,0) tile\n            c,d,\n            // secondary corner in (0,0) tile\n            c,e);\n    vec4 vv1 = vec4(\n            // primary corner in (X,Y) tile\n            block_hash(tile,X,Y, flip, flip),\n            block_hash(tile,0,Y,!flip, flip),\n            // secondary corner in (X,Y) tile\n            block_hash(tile,2*X,Y, flip, flip),\n            block_hash(tile,0,Y,!flip, flip) );\n\n    if(flip) tile = tile.yx;\n    vv0 += vec2(tile).xyxy;\n    vv1 += vec2(tile).xyxy;\n    ivec2 id = tile + ivec2(x,y);\n    ivec2 id0 = tile + ivec2(1-x,1-int(local.y < e));\n    ivec2 id1 = tile + ivec2(1-x,1-int(local.y < e));\n\n    if(flip)    { // horizontal line goes through: unswap vertical with horizontal\n        vv0 = vv0.yxwz;\n        vv1 = vv1.yxwz;\n        id = id.yx;\n        id0 = id0.yx;\n        id1 = id1.yx;}\n\n    bool flag = vv0.y > vv1.y;\n    // using abs in conversion to center-extend fixes order of min/max corners\n    return block((vv0+vv1)/2.0, abs(vv0-vv1)/2.0, id, id0, id1, flag);}\n\n\nmat3 yaw_pitch_roll(float yaw, float pitch, float roll){\n    mat3 R = mat3(vec3(cos(yaw), sin(yaw), 0.0), vec3(-sin(yaw), cos(yaw), 0.0), vec3(0.0, 0.0, 1.0));\n    mat3 S = mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, cos(pitch), sin(pitch)), vec3(0.0, -sin(pitch), cos(pitch)));\n    mat3 T = mat3(vec3(cos(roll), 0.0, sin(roll)), vec3(0.0, 1.0, 0.0), vec3(-sin(roll), 0.0, cos(roll)));\n    return R * S * T;}\n\nfloat halfspace(vec3 p){return p.z + 1.0;}\n\nfloat sphere(vec3 p, float r){    return length(p) - r;}\n\nfloat approx_crossing(vec3 p, float r)\n{//return sphere(p, r);\n    return max(length(p.xz)-r, length(p.yz)-r);\n}\n\nfloat box(vec2 p, vec2 s){ // adapted from https://iquilezles.org/articles/distfunctions/\n    vec2 d = abs(p) - s;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));}\n\nfloat box(vec3 p, vec3 s){ // adapted from https://iquilezles.org/articles/distfunctions/\n    vec3 d = abs(p) - s;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));}\n\nfloat box(vec3 p, vec3 p0, vec3 p1){\n    return box(p-(p1+p0)/2.0, abs(p1-p0)/2.0);}\n\nfloat box(vec2 p, vec2 p0, vec2 p1, float r){ // min-max box with rounded corner\n    return box(p-(p1+p0)/2.0, abs(p1-p0)/2.0-r)-r;}\n\nfloat box(vec3 p, vec3 p0, vec3 p1, float r){ // min-max box with rounded corner\n    float d = box(p.xy, p0.xy, p1.xy, r);\n    vec2 w = vec2(d, abs(p.z-(p1.z+p0.z)/2.0) - (p1.z-p0.z)/2.0);\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));}\n\nfloat dot2( in vec2 v ){return dot(v,v);}\n\nfloat cone(vec3 p, float h, float r1, float r2){ // adapted from https://iquilezles.org/articles/distfunctions/\n    vec2 q = vec2(length(p.xy), p.z);\n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );}\n\n/*\nfloat cylinder(vec3 p, vec2 s){ // adapted from https://iquilezles.org/articles/distfunctions/\n    vec2 d = abs(vec2(length(p.xy),p.z)) - s;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));}\n*/\nfloat cylinder(vec3 p, float r, float h){ // adapted from https://iquilezles.org/articles/distfunctions/\n    vec2 d = abs(vec2(length(p.xy),p.z)) - vec2(r,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));}\n\nfloat frame(vec2 p, vec2 s, float t){\n    return max(box(p, s),-box(p, s-t));}\n\nfloat frame(vec3 p, vec3 s, float t){\n    float d = frame(p.xy, s.xy, t);\n    // extrude https://iquilezles.org/articles/distfunctions/\n    vec2 w = vec2(d, abs(p.z) - s.z);\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));}\n\nfloat vmax(vec2 v){return max(v.x, v.y);}\n\nvoid pR45(inout vec2 p){p = (p + vec2(p.y, -p.x))*sqrt(0.5);}\n\nfloat pMod1(inout float p, float size){\n    float halfsize = size*0.5;\n    float c = floor((p + halfsize)/size);\n    p = mod(p + halfsize, size) - halfsize;\n    return c;}\n\n// https://www.shadertoy.com/view/Xs3GRB HG SDF in WebGL by tomkh,\n// implementation of http://mercury.sexy/hg_sdf/\nfloat fOpUnionStairs(float a, float b, float r, float n){\n    float d = min(a, b);\n    vec2 p = vec2(a, b);\n    pR45(p);\n    p = p.yx - vec2((r-r/n)*0.5*sqrt(2.));\n    p.x += 0.5*sqrt(2.)*r/n;\n    float x = r*sqrt(2.)/n;\n    pMod1(p.x, x);\n    d = min(d, p.y);\n    pR45(p);\n    return min(d, vmax(p -vec2(0.5*r/n)));}\n\n#define dd(a) dot(a,a)\n/*\nfloat make_cylinder_grid(vec3 l, float r){\n  return sqrt(min(\n            min(dd(l.xz-vec2(1.0,0))-r,dd(l.xz-vec2(0.0,0))-r),\n            min(dd(l.yz-vec2(1.0,0))-r,dd(l.yz-vec2(0.0,0))-r)));}\n    \n/*\n    float d =min(\n            min(length(l.xz-vec2(1.0,0))-r,length(l.xz-vec2(0.0,0))-r),\n            min(length(l.yz-vec2(1.0,0))-r,length(l.yz-vec2(0.0,0))-r)        );\n    return d;}\n /**/\n\n/*\nfloat make_cuboid_grid(vec3 l, float r, float s){\n    float d =min(\n            min(box(l.xz-vec2(1.0,0),vec2(r,s)), box(l.xz-vec2(0.0,0),vec2(r,s))),\n            min(box(l.yz-vec2(1.0,0),vec2(r,s)), box(l.yz-vec2(0.0,0),vec2(r,s)))        );\n    return d;} /**/\n\n#define EPSILON 0.001\n#define DIST_MAX 50.0\n#define ITER_MAX 200u\n\nstruct result{\n    float dist;\n    vec4 color_specular;\n    bool flag;};\n\nresult combine(result a, result b){\n    if(a.dist < b.dist) return a;\n    return b;}\nresult remove(result a, result b){\n    if(a.dist > -b.dist) return a;\n    return result(-b.dist, b.color_specular, b.flag);}\n\nvec3 colorize(ivec2 id){\n    vec3 color = hash32(vec2(id));\n    if(((id.x^id.y)&1)==0)\n        color = 1.0 - color;\n    vec3 n = vec3(1,1,1);\n    color -= 0.5*dot(color,n)*n/dot(n,n); // remove part of component along diagonal\n    return color;}\n\nresult map(ivec2 v, vec3 l){ // unit grid: voxel = float(position), local = fract(position)\n    result res = result(DIST_MAX, vec4(vec3(1), 0), false);\n    block b = blocks_layout(v.xy, l.xy);\n    float h = 0.2;\n    //float h = 0.2+0.1 * hash12(vec2(b.id));\n    //float h0 = 0.1 * hash12(vec2(b.id0));\n    //float h1 = 0.1 * hash12(vec2(b.id1));\n    res = combine(res, result(frame(vec3(v,0)+l-vec3(b.center.xy,0), vec3(b.extent.xy-wall_size,h), wall_size), vec4(colorize(b.id), 0), false));\n    res = combine(res, result(frame(vec3(v,0)+l-vec3(b.center.xy,0), vec3(b.extent.xy,h/* *0.9*/), wall_size), vec4(vec3(1), 0), false));\n    vec2 vv0 = b.center.xy - b.extent.xy - vec2(v);\n    vec2 vv1 = b.center.xy + b.extent.xy - vec2(v);\n    vec2 w0 = b.center.zw - b.extent.zw - vec2(v);\n    vec2 w1 = b.center.zw + b.extent.zw - vec2(v);\n    //res = combine(res, result(cylinder(vec3(v,0)+l-vec3(b.center.xy,0), 0.25*min(b.extent.x, b.extent.y), h), vec4(vec3(1),0), false));\n    //res = combine(res, result(cylinder(vec3(v,0)+l-vec3(b.center.xy,0), 0.25*min(b.extent.x, b.extent.y)+0.05, 0.01), vec4(vec3(0.25),0), false));\n    \n/*\n    float cyl =\n        min\n        (\n            min\n            (\n                cylinder(l-vec3(v0.xy,0), h, 0.1),\n                cylinder(l-vec3(v1.xy,0), h, 0.1)\n            ),\n            min\n            (\n                cylinder(l-vec3(v0.x, v1.y,0), h, 0.1),\n                cylinder(l-vec3(v1.x, v0.y,0), h, 0.1)\n            )\n        );\n    res.dist = min(res.dist, cyl);\n*/\n    //if(true){{\n    if(!b.flag){{\n            vec3 c = vec3(vv1.x+w1.x,vv0.y+w0.y,0/*+h*/)/2.0;\n            vec3 e = abs(vec3(vv1.x-w1.x,vv0.y-w0.y,-h))/2.0 - wall_size;\n            //res = combine(res, result(box(l, vec3(vv1.x+2.0*wall_size,vv0.y+wall_size,0), vec3(w1.x-2.0*wall_size, w0.y-wall_size, 0.25)), colorize(b.id0)));\n            //res = combine(res, result(sphere(l-c, max(e.x,e.y)), colorize(b.id0)));\n            // remove wall at portal\n            //res.dist = max(res.dist,-box(l, vec3(vv1.x+2.0*wall_size,vv0.y+wall_size,0), vec3(w1.x-2.0*wall_size, w0.y-wall_size, 0.25)));\n            res = remove(res, result(approx_crossing(l-c, max(e.x,e.y)-wall_size), vec4(vec3(1),0), false));\n        }{\n            vec3 c = vec3(vv0.x+w0.x,vv0.y+w0.y,0/*+h*/)/2.0;\n            vec3 e = abs(vec3(vv0.x-w0.x,vv0.y-w0.y,-h))/2.0 - wall_size;\n\n            //res = combine(res, result(box(l, vec3(vv1.x+2.0*wall_size,vv0.y+wall_size,0), vec3(w1.x-2.0*wall_size, w0.y-wall_size, 0.25)), colorize(b.id0)));\n            //res = combine(res, result(sphere(l-c, max(e.x,e.y)), colorize(b.id0)));\n            // remove wall at portal\n            //res.dist = max(res.dist,-box(l, vec3(vv1.x+2.0*wall_size,vv0.y+wall_size,0), vec3(w1.x-2.0*wall_size, w0.y-wall_size, 0.25)));\n            res = remove(res, result(approx_crossing(l-c, max(e.x,e.y)-wall_size), vec4(vec3(1),0), false));\n    }}else{{\n            vec3 c = vec3(vv0.x+w0.x,vv1.y+w1.y,0/*+h*/)/2.0;\n            vec3 e = abs(vec3(vv0.x-w0.x,vv1.y-w1.y,-h))/2.0 - wall_size;\n\n            //res = combine(res, result(box(l, vec3(vv0.x-2.0*wall_size,vv1.y-wall_size,0), vec3(w0.x+2.0*wall_size, w1.y+wall_size, 0.25)), colorize(b.id0)));\n            // remove wall at portal\n            //res.dist = max(res.dist,-box(l, vec3(vv0.x-2.0*wall_size,vv1.y-wall_size,0), vec3(w0.x+2.0*wall_size, w1.y+wall_size, 0.25)));\n            res = remove(res, result(approx_crossing(l-c, max(e.x,e.y)-wall_size), vec4(vec3(1),0), false));\n        }{\n            vec3 c = vec3(vv1.x+w1.x,vv1.y+w1.y,0/*+h*/)/2.0;\n            vec3 e = abs(vec3(vv1.x-w1.x,vv1.y-w1.y,-h))/2.0 - wall_size;\n            //res = combine(res, result(box(l, vec3(v0.x-2.0*wall_size,v1.y-wall_size,0), vec3(w0.x+2.0*wall_size, w1.y+wall_size, 0.25)), colorize(b.id0)));\n            // remove wall at portal\n            //res.dist = max(res.dist,-box(l, vec3(v0.x-2.0*wall_size,v1.y-wall_size,0), vec3(w0.x+2.0*wall_size, w1.y+wall_size, 0.25)));\n            res = remove(res, result(approx_crossing(l-c, max(e.x,e.y)-wall_size), vec4(vec3(1),0), false));\n    }}\n    //res = remove(res, result(make_cylinder_grid(l-vec3(0,0,h), 0.1), vec4(vec3(1),0), false));\n    //res = remove(res, result(make_cylinder_grid(l-vec3(0,0,h), 0.1), vec4(vec3(1),0), false));\n    //res = combine(res, result(make_cuboid_grid(l-vec3(0,0,h*0.6), 0.05, 0.005), vec4(vec3(0.25),0), false));\n    //res = combine(res, result(l.z, vec3(1))); // floor\n    float f = l.z; // floor\n    float cone_south = cone(vec3(v,0)+l-vec3(b.center.x,b.center.y-b.extent.y,0.0), h-0.0001, .0, h/4.0);\n    float cone_north = cone(vec3(v,0)+l-vec3(b.center.x,b.center.y+b.extent.y,0.0), h-0.0001, .0, h/4.0);\n    float cone_west = cone(vec3(v,0)+l-vec3(b.center.x-b.extent.x,b.center.y,0.0), h-0.0001, .0, h/4.0);\n    float cone_east = cone(vec3(v,0)+l-vec3(b.center.x+b.extent.x,b.center.y,0.0), h-0.0001, .0, h/4.0);\n    //res.dist = min(res.dist, cone0);\n    f = fOpUnionStairs(f, min(min(cone_south, cone_east), min(cone_north, cone_west)), h, 10.0);\n    res = combine(res, result(f, vec4(1.-colorize(b.id), 1), true)); // floor\n    return res;}\n    \n#ifdef HIGH_QUALITY\n//for correct AO, we must sample 2x2x2 voxels, much slower\nresult map(vec3 p){\n    // I think kastorp originally suggested to sample only 2x2x2 instead of 3x3x3, thanks!\n    result d = result(DIST_MAX, vec4(vec3(0),0), false);\n    ivec2 s = ivec2(step(0.5, fract(p.xy)));\n    ivec2 o;\n    for(o.y = s.y-1; o.y < s.y+1; o.y++)\n        for(o.x = s.x-1; o.x < s.x+1; o.x++){\n            result r = map(ivec2(floor(p.xy))+o, vec3(fract(p.xy), p.z)-vec3(o,0));\n            if(r.dist < d.dist)\n                d = r;\n    }return d;}\n#else\n//much less taps \nresult map(vec3 p){return map(ivec2(floor(p.xy)), vec3(fract(p.xy), p.z));}\n#endif\n\n// https://iquilezles.org/articles/normalsSDF tetrahedron normals\nvec3 normal(vec3 p){\n    const float h = EPSILON;\n    const vec2 k = vec2(1,-1);\n    return normalize(k.xyy*map(p + k.xyy*h).dist +\n                     k.yyx*map(p + k.yyx*h).dist +\n                     k.yxy*map(p + k.yxy*h).dist +\n                     k.xxx*map(p + k.xxx*h).dist);}\n\n// NOTE: Apparently sign fails on some systems! Thanks to spalmer for debugging this!\n// WORKAROUND FOR COMPILER ERROR on some systems\nvec2 sgn(vec2 v){return step(vec2(0), v) * 2.0 - 1.0;}\n\nresult trace(vec3 ro, vec3 rd, float t0, float t1){ // ray-march sdf handling discontinuities between voxels  (jt)\n    result h;\n    uint i;\n    float t;\n    for(t = t0, i = 0u; t < t1 && i < ITER_MAX; i++) { // finite loop originally suggested by pyBlob to avoid stalling if ray parallel to surface just above EPSILON\n        vec3 p = ro + rd * t;\n        h = map(p);\n        if(h.dist < EPSILON)return result(t, h.color_specular, h.flag);\n\n        // NOTE: An extra step per block, use if sdf discontinuous between blocks\n        //       Could make this conditional by prefixing sth. like if(block_changed) // suggested by spalmer\n        // constrain step to blocks (voxel-snap ray-march plugin by jt, thanks to Shane for the idea!)\n        {\n            block b = blocks_layout(ivec2(floor(p.xy)), fract(p.xy));\n            // NOTE: assuming unit grid\n            // sgn(rd)*extent are the block walls in ray direction, fract(p) - center is position relative to center of block\n            //vec2 sd = (sgn(rd.xy)*b.extent.xy - (fract(p.xy) - (b.center.xy-floor(p.xy))))/rd.xy; // distances to block sides / walls\n            vec2 sd = (sgn(rd.xy)*b.extent.xy - p.xy + b.center.xy)/rd.xy; // distances to block sides / walls\n            vec2 n = step(sd.xy, sd.yx); // component true if corresponding wall is nearest (at most one component true) NOTE: originally I used lessThanEqual, min from fb39ca4/kzy then switched to step, min by iq\n            float skip = dot(sd, n) + EPSILON; // distance to next block: sum up all components, weighted by the nearest flag (assuming only one component is true this selects the nearest component)\n            h.dist = min(h.dist, skip); // constrain step to at most next block to handle sdf discontinuities between voxels\n        }t += h.dist;}\n    return result(t, h.color_specular, h.flag);} \n    // stop on running out of iterations\n    //return result(t1, vec4(0), false); // pass on running out of iterations\n\n\n// NOTE: Don't forget to add +normal*EPSILON to the starting position\n//       to avoid artifacts caused by getting stuck in the surface\n//       due to starting at distance < EPSILON from the surface.\n//       (normal could be calculated here but that would most likely be redundant)\n//       Thanks to spalmer for pointing that out.\nfloat shadow(vec3 ro, vec3 rd, float t0, float t1){\n    return trace(ro, rd, t0, t1).dist < t1 ? 0.0 : 1.0;}\n\n// https://iquilezles.org/articles/rmshadows\nfloat softshadow(vec3 ro, in vec3 rd, float t0, float t1, float k){\n    float res = 1.0;\n    float ph = 1e20;\n    uint i;\n    float t;\n    for(t = t0, i = 0u; t < t1 && i < ITER_MAX; i++)    {\n        float h = map(ro + rd*t).dist;\n        if( h < EPSILON )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }return res;}\n\n// https://www.shadertoy.com/view/Xds3zN raymarching primitives\nfloat calcAO( in vec3 pos, in vec3 nor ){\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ ){\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).dist;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;}\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );}\n\nfloat checker(vec2 p){\n    return step(0.0, sin(p.x*pi)*sin(p.y*pi));}\n\nfloat checker(vec3 p){\n    return step(0.0, sin(p.x*pi)*sin(p.y*pi)*sin(p.z*pi));}\n\nvec3 material(vec3 p){\n    //return vec3(1.0-pow(0.5+0.5*sin(p.z*pi*10.0), 50.0))\n    return vec3(1.0)\n    //return mix(vec3(0.25), vec3(0.75), checker(p*2.0+0.5))\n;}\n\nvec3 sky(vec3 lightdir, vec3 d){// no particular meaning - just tweaked until it looks skyish\n    float v = 0.5*abs(d.z)+0.5;\n    return vec3(pow(1.0-v,2.0),1.0-v,v);}\n\n\nfloat sun(vec3 lightdir, vec3 rd){// sun with halo\n    float d = max(0.0, dot(rd, lightdir));\n    return smoothstep(0.998, 0.999, d) + exp(-pow((1.0-d)*500.0, 2.0));} \n\n\nvec3 pass(vec3 ro, vec3 rd, result r){\n    vec3 lightdir = normalize(vec3(3.0, 2.0, 1.0));\n    //vec3 sky_color = mix(vec3(0.2,0.5,0.5),vec3(0,0,1),abs(-rd.z));\n    //vec3 sky_color = mix(vec3(0.2,0.5,0.5),vec3(0,0,0.5),sqrt(abs(rd.z)));\n    vec3 sky_color = sky(lightdir, rd);\n    sky_color += sun(lightdir, rd);\n    vec3 color = vec3(1);\n    if(r.dist < DIST_MAX){\n        color *= r.color_specular.xyz;\n        vec3 dst = ro + rd * r.dist;\n        vec3 n = normal(dst);\n        //color *= (n * 0.5 + 0.5);\n        //color *= material(dst);\n        vec3 ambient = vec3(0.4);\n        float brightness = max(dot(lightdir, n), 0.0);\n        if(brightness > 0.0)\n            brightness *= shadow(ro + rd * r.dist + n * 0.01, lightdir, 0.0, DIST_MAX);\n            //brightness *= softshadow(ro + rd * dist + n * 0.01, lightdir, 0.0, DIST_MAX, 20.0);\n        color *= (ambient * calcAO(dst, n) + brightness);\n\n        if(brightness > 0.0){\n            float specular = pow(max(0.0, dot(n, normalize(-rd + lightdir))), 250.0);\n            color += specular * r.color_specular.w;}\n\n        vec3 fog_color = sky_color;\n        color = mix(fog_color, vec3(color), exp(-pow(r.dist/20.0, 2.0))); // fog\n    }else{\n        color *= sky_color;\n    }return color;}\n\nfloat grey(vec3 color){return dot(color, vec3(1.0/3.0));}\n\nvoid scene2(vec3 ro, vec3 rd, inout vec4 fragColor){\n    result res = trace(ro, rd, 0.0, DIST_MAX);\n    vec3 color = pass(ro, rd, res);\n    if(res.dist < DIST_MAX && res.flag){\n        //color = vec3(1);\n        ro.z = -ro.z;       // reflect camera position\n        rd.z = -rd.z;        // reflect view direction\n        res = trace(ro, rd, res.dist+0.01, DIST_MAX);\n        vec3 reflection = pass(ro, rd, res);\n        //color *= reflection; // clear\n        //color = mix(color, reflection, 0.5); // muddy (light)\n        color *= mix(vec3(1), reflection, 0.5); // muddy (dark)\n        //color += reflection; // additive\n        //color *= grey(pass(ro, rd, res)); // unrealistic\n    }\n    color = tanh(color); // roll-off overly bright colors\n    fragColor = vec4(color, 1);\n    fragColor = sqrt(fragColor);} // approximate gamma\n\n\n//#define     noQuaterionCam_Use_DsKBDw_instead\n\n#ifdef        noQuaterionCam_Use_DsKBDw_instead\n//https://www.shadertoy.com/view/DsKBDw , modified to remain functional as \n//mainImage() instead of mainImage2()\n//while using a subroutine to work merged with quaternionCameras of\n//https://www.shadertoy.com/view/wtdyRs (oldest)\n//https://www.shadertoy.com/view/DsKBDw (newer)\nvoid mainImage(out vec4 fragColor, vec2 I){\n    bool demo = all(lessThan(iMouse.xy, vec2(10.0)));\n    vec2 R = iResolution.xy;\n    I = (2.0 * I - R) / R.y; // concise scaling thanks to Fabrice\n    //I = (4.0 * floor(I * 0.5) + 2.0 - R) / R.y; // integrated pixelize (speedup & looks cool) thanks to spalmer\n    float yaw = 2.0 * pi * float(iMouse.x) / float(R.x);\n    float pitch = pi - pi / 2.0 * float(iMouse.y) / float(R.y);\n    yaw = !demo ? yaw : 2.0 * pi * fract(iTime * 0.01);\n    pitch = !demo ? pitch : 4.0/3.0 * pi / 2.0;\n    vec3 ro = vec3(0.0, 0.0,-2.5);\n    vec3 rd = normalize(vec3(I.xy, 2.0));\n    mat3 M = yaw_pitch_roll(yaw, pitch, 0.0);\n    ro = M * ro;\n    rd = M * rd;\n    ro.z += 0.0;\n    \n    scene2(ro,rd,fragColor);}\n    /*\n    result res = trace(ro, rd, 0.0, DIST_MAX);\n    vec3 color = pass(ro, rd, res);\n    if(res.dist < DIST_MAX && res.flag){\n        //color = vec3(1);\n        ro.z = -ro.z;       // reflect camera position\n        rd.z = -rd.z;        // reflect view direction\n        res = trace(ro, rd, res.dist+0.01, DIST_MAX);\n        vec3 reflection = pass(ro, rd, res);\n        //color *= reflection; // clear\n        //color = mix(color, reflection, 0.5); // muddy (light)\n        color *= mix(vec3(1), reflection, 0.5); // muddy (dark)\n        //color += reflection; // additive\n        //color *= grey(pass(ro, rd, res)); // unrealistic\n    }\n    color = tanh(color); // roll-off overly bright colors\n    fragColor = vec4(color, 1);\n    fragColor = sqrt(fragColor);} // approximate gamma*/\n\n#else\n\n//quaternion camera control canvas\nconst float FOV=1.;\nvoid mainImage(out v3 O,v1 U\n){vec4 q=get(camA0) //get camera rotation as quaternion\n ;mat3 cam=q2m(q)   //camera matrix from camera quaternion.\n ;vec2 uv=(U-0.5*iResolution.xy)/iResolution.y //scale uv to range [-1..1]\n ;vec3 rd=normalize(cam*vec3(1.,FOV*uv))//rayDirection for uv from camera matrix \n ;vec3 ro=get(camP0).xyz\n \n //alternative scene of parent shader https://www.shadertoy.com/view/DsKBDw\n //kept here as example on how to modiy a shader to fit in here.\n //;O=v3(scene(ro,rd),1);//tracing a triangle,bend up+down by 3 sides, that are flat-triangle-orthogonal quadratic-beziers.\n //;return;\n \n //make a scene(rayorigin,raydirection) or scene2(rayorigin,raydirection,fragColor) function\n //that returns a fragment color for uv.xy[-1..1] \n ;vec4 fragColor=vec4(1);\n scene2(get(camP0).xyz,rd,fragColor);\n O.xyz=fragColor.xyz;\n ;} \n \n#endif",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}