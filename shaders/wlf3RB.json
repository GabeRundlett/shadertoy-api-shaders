{
    "Shader": {
        "info": {
            "date": "1556719165",
            "description": "a more compatible version of\nhttps://www.shadertoy.com/view/Xd2fzR\nto run on older webgl+phones+GameMaster (whatever only supports GLES100)",
            "flags": 32,
            "hasliked": 0,
            "id": "wlf3RB",
            "likes": 10,
            "name": "compatible5 reprojection",
            "published": 3,
            "tags": [
                "3d",
                "gi",
                "pathtracing",
                "reprojection",
                "compatibility",
                "taa",
                "compatible",
                "version",
                "gles300"
            ],
            "usePreview": 1,
            "username": "ollj",
            "viewed": 1254
        },
        "renderpass": [
            {
                "code": "// Created by inigo quilez - iq/2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\nvec4 tf0(vec2 b,vec3 r){return tf(iChannel0,b,r);}\nvec4 tf1(vec2 b,vec3 r){return tf(iChannel1,b,r);}\nvec4 tf2(vec2 b,vec3 r){return tf(iChannel2,b,r);}\nvec4 tf3(vec2 b,vec3 r){return tf(iChannel3,b,r);}\n\nvoid mainImage(out vec4 o,vec2 u\n){\n ;\n ;//int a=13%7;//classic line to test that you are NOT in webgl2 more,\n ;\n ;vec3 c=tf0(u,iResolution.xyz).xyz\n ;float g=dot(c,vec3(.3333))// burn highlights\n ;c=mix(c,vec3(g),min(g*.15,1.))\n ;c=pow(c,vec3(.4545))// gamma\n ;c=1.15*pow(c,vec3(.9,.95,1.))+vec3(1,1,0)*-.04 // instafilter\n ;//vignete    \n ;vec2 q=u/iResolution.xy\n ;c*= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n ;o=vec4(c,1);}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// almost entirely \n// Created by inigo quilez - iq/2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// made more compativle by ollj\n// [compatible v4]\n\n/*\nmade (more) gles100 compatible\n(i hope i did not forget anything important)\n\n- all lops are complete forLoops\n- all loops have constant max iteration count\n- no ivec*\n- no bitwise operands\n- dualFunctionEd\n- - no texelFetch() \n- - no silly Array stuff \n- - int sign(int a)\n- - int abs(int a)\n- did not add tons of global runtime variables ;)\n- did not add [/*\"] after [#]\n- A lot of code looks 15 years dumber now.\n\n*/\n\n\n#define NUMBOXES 22\n\nvec4 tf0(vec2 b,vec3 r){return tf(iChannel0,b,r);}\nvec4 tf1(vec2 b,vec3 r){return tf(iChannel1,b,r);}\nvec4 tf2(vec2 b,vec3 r){return tf(iChannel2,b,r);}\nvec4 tf3(vec2 b,vec3 r){return tf(iChannel3,b,r);}\n\n//#if 1\n#if VER <300\n//7 are manually placed\nvec3 size7(int i\n){if(i==1)return vec3(10.5,0.1,10.5)\n ;if(i==3)return vec3(10.5,7.5, 0.1)\n ;if(i==5)return vec3(10.5,7.5, 0.1)\n ;if(i==7)return vec3( 0.1,7.5,10.5)\n ;if(i==9)return vec3( 0.1,7.5,10.5)\n ;if(i==11)return vec3( 4.0,0.1,10.5)\n ;return         vec3( 4.0,0.1,10.5);}\nvec3 pos7(int i){\n ;if(i==0)return vec3( 0)\n ;if(i==2)return vec3(  0, 0,-10)\n ;if(i==4)return vec3(  0, 0, 10)\n ;if(i==6)return vec3( 10, 0,  0)\n ;if(i==8)return vec3(-10, 0,  0)\n ;if(i==10)return vec3( -7,-7,  0)\n ;return  vec3(  7,-7,  0);}\nvoid getLocation(int i, out mat4 resMat, out vec3 resSiz\n){if(i<7\n ){resMat = translate( pos7(i*2))\n  ;resSiz = size7(i*2+1)\n ;}else{\n  ;resMat = rotationAxisAngle(vec3(0.3,0.4,0.5)*1.41421, -float(i*13))* translate(vec3(0.0,-2.5,0.0)-vec3(5.0,2.0,5.0)*sin(vec3(i*43,i*23,i*137)));\n  ;resSiz = vec3(1.1,1.6,0.08);}}\n\n#else\n//7 are manually placed\nconst vec3 possiz[14] = vec3[14](\n    vec3(  0, 0,  0), vec3(10.5,0.1,10.5),\n    vec3(  0, 0,-10), vec3(10.5,7.5, 0.1),\n    vec3(  0, 0, 10), vec3(10.5,7.5, 0.1),\n    vec3( 10, 0,  0), vec3( 0.1,7.5,10.5),\n    vec3(-10, 0,  0), vec3( 0.1,7.5,10.5),\n    vec3( -7,-7,  0), vec3( 4.0,0.1,10.5),\n    vec3(  7,-7,  0), vec3( 4.0,0.1,10.5));\nvoid getLocation(int id, out mat4 resMat, out vec3 resSiz\n){if(id<7\n ){resMat = translate( possiz[2*id+0] )\n  ;resSiz = possiz[2*id+1]\n ;}else{\n  ;resMat = rotationAxisAngle(vec3(0.3,0.4,0.5)*1.41421, -float(id*13))* translate(vec3(0.0,-2.5,0.0)-vec3(5.0,2.0,5.0)*sin(vec3(id*43,id*23,id*137)));\n  ;resSiz = vec3(1.1,1.6,0.08);}}\n#endif\n\nfloat fhash1(float n \n){float a=(sqrt(5.)*.5+.5) //golden ratio is sufficient here.\n ;a=n*a\n ;a=abs(a)\n ;return fract(a);}\n\n    \nint ihash1(int n \n){//return 0\n /*\n ;float a=(sqrt(5.)*.5+.5)//golden ratio is NOT good here\n ;a*float(n)*a\n ;return int(fract(a)*pow(2.,22.))\n /**/\n ;float f=float(n)\n ;f =f*pow(2.,13.)// (n << 13) \n //f=f^ n  //not good/compatible/fast, but also really not essential.\n ;n=int(f)\n ;n=n*(n*n* 15731+789221)+1376312589 \n ;n=abs(n)\n ;return n//its a hack, but its close enough to the original.\n /**/\n ;}\n\n//hash2() is completely taken apart, or replaced by a fibonaciSphere\n\n#define cs(a) vec2(cos(a),sin(a))\n#define sr1m(a) sqrt(1.-(a)*(a))\n//return point[k] of a fibonacciSphere with [n] equidistributed points\n//divides by [n] and squares the result, [n] should not be too large, or we lose too much precision\nvec3 fibSphereKthOfNpoints(float k,float n  //0<=k<=n!=0 ;k-bounds are implied geometrically.\n){if(n==0.)n=1.//worksafe\n ;float x=((k*2.+1.)/n)-1.\n ;return vec3(cs(k*pi*(3.-sqrt(5.)))*sr1m(x),x);//poles of HairyBallProblem are along x-axis!\n ;}//https://stackoverflow.com/questions/9600801/evenly-distributing-n-points-on-a-sphere/44164075#44164075\nvec3 uniformVector(int seed\n){const float points=pow(2.,22.)  //[machineEpsilon]=pow(2.,-23)\n ;float f=fhash1(float(seed))\n ;return fibSphereKthOfNpoints(mod(f,points),points);}\n\n//the last remaining hash2() subroutine call is deconstructzed in here:\nvec3 cosineDirection(int seed, in vec3 nor\n){seed=seed*7+11\n ;int n=int(seed)    \n ;float f=float(n)*pow(2.,13.)\n ;//n = int(f)^n //original integer hash used a mask, but thats slow in glES100, and its fine without mask.\n ;n=n*(n*n*15731+789221)+1376312589\n ;int nx=n*n\n ;int ny=n*n*16807\n ;nx=abs(nx)\n ;ny=abs(nx)\n ;vec2 r=vec2(nx,ny)\n  ;r=r/float(0x7fffffff)\n    //;vec2 r = hash2( seed);\n    // by fizzer: http://www.amietia.com/lambertnotangent.html\n    ;float a = 6.2831853 * r.y;\n    float u = 2.0*r.x - 1.0;\n    return normalize( nor + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );\n}\n\nfloat iBox(vec3 ro,vec3 rd,mat4 txx,vec3 rad\n){// convert from ray to box space\n ;vec3 rdd = (txx*vec4(rd,0.0)).xyz\n ;vec3 roo = (txx*vec4(ro,1.0)).xyz\n ;// ray-box intersection in box space\n ;vec3 m = 1.0/rdd\n ;vec3 n = m*roo\n ;vec3 k = abs(m)*rad\n ;vec3 t1 = -n - k\n ;vec3 t2 = -n + k\n ;float tN = max( max( t1.x, t1.y ), t1.z )\n ;float tF = min( min( t2.x, t2.y ), t2.z )\n ;if( tN > tF || tF < 0.0) tN = -1.0\n ;return tN;}\n\n// returns normal, st and face\nvoid nBox(vec3 o,vec3 d,mat4 txx,mat4 txi,vec3 rad//rayorigin,raydirection\n         ,out vec3 outNor,out vec2 outST,out int outFaceID\n){// convert from ray to box space\n ;vec3 rdd=(txx*vec4(d,0.0)).xyz\n ;vec3 roo=(txx*vec4(o,1.0)).xyz\n ;// intersect and select\n ;vec3 s=-sign(rdd)\n ;vec3 t=(-roo+s*rad)/rdd\n ;// compute normal in world space\n ;      if(t.x>t.y&&t.x>t.z){outNor=txi[0].xyz*s.x;outST=roo.yz+rdd.yz*t.x;outFaceID=int(1+int(s.x))/2 // 0, 1\n ;}else if(t.y>t.z)         {outNor=txi[1].xyz*s.y;outST=roo.zx+rdd.zx*t.y;outFaceID=int(5+int(s.y))/2 // 2, 3 \n ;}else                     {outNor=txi[2].xyz*s.z;outST=roo.xy+rdd.xy*t.z;outFaceID=int(9+int(s.z))/2 // 4, 5 \n ;}}\n\n\n\n\n\n\nfloat castRay( in vec3 ro, in vec3 rd, out vec3 oNor, out vec2 oUV, out int oID\n){float tmi = 1e20\n ;mat4  cma\n ;vec3  csi\n ;int  cin = 0xffffffff\n ;for( int i=0; i<NUMBOXES; i++   //es100 safe\n ){mat4 ma; vec3 si; getLocation(i, ma, si)\n  ;float res = iBox( ro, rd, ma, si )\n  ;if( res>0.0 && res<tmi\n  ){cma = ma\n   ;csi = si\n   ;cin = i\n   ;tmi = res\n ;}}\n ;int resID\n ;nBox( ro, rd, cma, inverse(cma), csi, oNor, oUV, resID )\n ;oID = cin*6 + resID\n ;return (cin==0xffffffff) ? -1.0 : tmi;}\n\nfloat castShadowRay(vec3 ro,vec3 rd\n){for( int i=0; i<NUMBOXES; i++ //es100 safe\n ){mat4 ma; vec3 si; getLocation(i, ma, si)\n  ;if(iBox(ro,rd,ma,si)>0.)return 0.;}\n ;return 1.;}\n\nmat3 setCamera(vec3 o,vec3 d, float t//origin,target,time\n){d=normalize(d-o)\n ;o=normalize(cross(d,vec3(sin(t),cos(t),0.)))\n ;return mat3(o,cross(o,d),-d);}\n\nvec3 sphereMap(vec3 d){return vec3(.3,.4,1.2);}    \n\nvoid light1(inout vec3 iColor,vec3 pos,vec3 nor,vec3 rd,vec3 tex,int k,int bounce, int sa,float epsilon){\n   ;vec3 sunCol =  vec3(1.7,0.8,0.6)*10.0; \n   ;vec3 sunDir = normalize(vec3(0.5,0.9,-0.2));\n   ;vec3 ssundir = normalize(sunDir+.01*uniformVector(sa + 11 + 45*(bounce+11*k)))\n   ;float sunDif =  max(0.0, dot(ssundir, nor))\n   ;float sunSha = 1.0; if( sunDif > 0.00001 ) sunSha = castShadowRay( pos + nor*epsilon, ssundir)\n   ;iColor += sunCol * sunDif * sunSha\n   ;vec3 h = normalize( sunDir - rd )\n   ;float shl = 0.04 + 0.96*pow( 1.0-clamp(dot(h,-rd),0.0,1.0), 5.0 )\n   ;float spe = tex.x*30.0*pow( clamp( dot( nor, h ), 0.0, 1.0 ), 24.0*tex.x )\n   ;iColor += spe * shl * sunCol * sunSha * sunDif\n   ;}\nvoid light2(inout vec3 iColor,vec3 pos,vec3 nor,vec3 rd,vec3 tex,int sa,int k,int bounce,float epsilon){\n//;for( int i=min(0,iFrame); i<2; i++ //not es100 safe\n ;for( int i=0;i<2;i++// es100 safe\n ){//if(iFrame>1)break//i see no difference in this es100 save line\n  ;vec3 skyPoint=cosineDirection((sa+7*int(iFrame)+47*(k)+13*int(i)+bounce*92),nor)\n  ;float skySha = castShadowRay( pos + nor*epsilon, skyPoint)\n  ;vec3  skyCol = sphereMap(skyPoint)\n  ;iColor += skyCol * skySha / 2.0\n  ;vec3 h = normalize( skyPoint - rd )\n  ;float shl=.04+.96*pow( 1.0-clamp(dot(h,-rd),0.0,1.0), 5.0 )\n  ;float spe=tex.x*250.*pow( clamp( dot( nor, h ), 0.0, 1.0 ), 24.0*tex.x )\n  ;iColor+=spe*shl*skyCol*skySha/2.;};}\n\nvec4 render( in vec3 ro, in vec3 rd, int sa, out int oID\n){const float epsilon = 0.001\n ;vec3 colorMask = vec3(1.0)\n ;vec3 accumulatedColor = vec3(0.0)\n ;vec3 oro = ro\n ;vec3 ord = rd\n ;oID = NUMBOXES+10\n ;float fdis = 0.\n ;const int numRays = 4\n ;for( int k=0; k<numRays; k++ //es100 safe\n ){ro=oro\n  ;rd=ord\n  ;colorMask = vec3(1.0)\n  ;for(int bounce=0;bounce<3;bounce++ //es100 safe // bounces of GI\n  ){vec3 nor\n   ;vec2 st\n   ;int id\n   ;float t=castRay( ro, rd, nor, st, id )\n   ;if( t < 0.\n   ){if( k==0 && bounce==0\n    ){accumulatedColor=sphereMap(rd)*float(numRays)*pi\n     ;oID=NUMBOXES+10\n     ;fdis = 1000.\n    ;}break;}\n   ;int obj = id/6\n   ;vec3 pos = ro + rd*t\n   ;if(k==0&&bounce==0){fdis=t;oID =id;}\n   ;int kid=id/6\n   ;vec3 surfaceColor=vec3(.4)\n   ;vec3 tex = texture(iChannel3, st.yx*0.3 ).xyz\n   ;if( kid>=1 && kid<=4) tex = texture( iChannel2, st*0.2 ).xyz*vec3(0.7,0.8,0.8)\n   ;surfaceColor *= tex\n   ;//direct lighitng\n   ;colorMask *= surfaceColor\n   ;vec3 iColor=vec3(0)\n   #if 1\n   ;light1(iColor,pos,nor,rd,tex,sa,k,bounce,epsilon)\n   #endif\n   #if 1\n   ;light2(iColor,pos,nor,rd,tex,sa,k,bounce,epsilon)\n   #endif\n   ;accumulatedColor += colorMask * iColor\n   ;// calculate new ray\n   ;float isDif = 0.8\n   ;if(fhash1(float(sa + 1 + 7*bounce + 91*k + 31*int(iFrame))) < isDif\n   ){rd = cosineDirection((76 + 73*(bounce+5*k) + sa + 17*int(iFrame)), nor)\n   ;}else{\n    ;float glossiness = 0.4\n    ;rd = normalize(reflect(rd, nor)) + uniformVector(sa + 111 + 65*(bounce+7*k)+87*int(iFrame)) * glossiness\n    ;}\n   ;ro = pos + epsilon*nor;}}\n ;accumulatedColor /= float(numRays)\n ;return vec4( clamp(accumulatedColor,0.,10.),fdis );}\n\nvec3 getVofM(mat3 a,int b){//return a[b]\n ;if(b==2)return a[2]\n ;if(b==1)return a[1]\n ;return a[0];}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord\n){vec3 r=iResolution.xyz\n ;vec2 off=vec2(0)\n ;//off=(hash2(int(iFrame))-.5)*5.\n ;vec2 p = (2.*(fragCoord+off)-r.xy)/r.y\n ;int sa = ihash1( int(iFrame)*11 + int(fragCoord.x) + int(fragCoord.y)*113 )\n ;float time = -2.0 + (iTime-10.0)*0.03    // camera movement\n ;float cr = 0.1*cos(0.1)\n ;vec3 ro = vec3(8.0*cos(time), 1.0, 8.0*sin(time) )\n ;vec3 ta = vec3(0.0,3.0,0.0)\n ;float fl = 1.8\n ;mat3 cam = setCamera( ro, ta, cr )\n ;vec3 rd = normalize( cam * vec3(p,-fl) )\n ;int id\n ;vec4 ren=render(ro,rd,sa,id)\n ;vec3 c=ren.xyz\n ;float t=ren.w\n ;// reproject from previous frame and average\n ;mat4 oldCam=mat4(tf1(vec2(0,0),r)\n                  ,tf1(vec2(1,0),r)\n                  ,tf1(vec2(2,0),r),0,0,0,1)\n ;vec4 wpos=vec4(ro + rd*t,1.0)    // world space\n ;vec3 cpos=(wpos*oldCam).xyz;  // camera space note inverse multiply\n ;vec2 npos=-fl * cpos.xy / cpos.z  // ndc space\n ;vec2 spos=.5+.5*npos*vec2(r.y/r.x,1.)   // screen space\n ;spos-=off/r.xy //undo dither\n ;vec2 rpos = spos * r.xy - .5// raster space\n ;vec2 ipos=vec2(floor(rpos))\n ;if( (ipos.y>0. || ipos.x>2.) && iFrame>0\n ){// blend pixel color history\n  #if 1\n  ;vec2 fuv=rpos-vec2(ipos)\n  ;vec4 odata1=tf1(ipos,r)\n  ;vec4 odata2=tf1(ipos+vec2(1,0),r)\n  ;vec4 odata3=tf1(ipos+vec2(0,1),r)\n  ;vec4 odata4=tf1(ipos+vec2(1.),r)\n  ;vec4 ocol=vec4(0)\n  ;int n=0\n  ;if(id==int(odata1.w)){ocol+=vec4(odata1.xyz,1.)*(1.-fuv.x)*(1.-fuv.y);n++;}\n  ;if(id==int(odata2.w)){ocol+=vec4(odata2.xyz,1.)*(   fuv.x)*(1.-fuv.y);n++;}\n  ;if(id==int(odata3.w)){ocol+=vec4(odata3.xyz,1.)*(1.-fuv.x)*(   fuv.y);n++;}\n  ;if(id==int(odata4.w)){ocol+=vec4(odata4.xyz,1.)*(   fuv.x)*(   fuv.y);n++;}\n  ;if(n>2)c=mix(max(ocol.xyz/ocol.w,0.),c,.1\n );else   c=mix(textureLod(iChannel1, spos,0.).xyz,c,.3)\n  #else\n  ;col=mix(textureLod(iChannel1,spos,0.).xyz,col,.1)\n  #endif\n  ;}\n ;vec2 ifc = vec2(floor(fragCoord))\n ;vec3 s=getVofM(cam,int(vec2(floor(fragCoord)).x))\n ;if( ifc.y==0. && ifc.x<=2.)fragColor=vec4(s,-dot(s,ro))\n ;else                       fragColor=vec4(c,id);}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//[compatible library v5] to explicitly declare and thus emulate webGl2.0==glEs300 within webGl1.0==glEs100\n\n#define pi acos(-1.)\n\n//WebGl runs in 2 main modes:\n//webgl , which usually means glES100, close to opengl1.0\n//webgl2, which usually means glES300, close to opengl3.0\n//__VERSION__ is runtime reserved namespace that points at a unique integer ID\n//functions known to be glES300 exclusive, trying to port to older versions:\n\n//for a global manual override\n//cannot define any namespace with dual undersore, -> fatal error\n#define VER __VERSION__\n\n//#define VER 100  //webGl1==openGlEs100\n//#define VER 300  //webGl2==openGlES300\n//there may be some smaller values, labeled experimental\n//therefore we only care if (VER <300)\n\n#if VER <300\n// % (integer modulo operand) is glES300 exclusive\n//, i made other shaders on emulating/comparing/impribing modulo on Webgl.\n//usually it is (with low precision) good enough to just use type float modulo instead of type int modulo\n//the typecasting may slow this down a bit, but should not be significant.\n\n//outerproduct is glES300 exclusive\nmat3 outerProduct(vec3 a,vec3 b){return mat3(a*b.x\n                                            ,a*b.y\n                                            ,a*b.z);}//i may have swapped a and b wrongly here.\n//mat3 outerProduct(in vec3 a, in vec3 b){return mat3(a * b[0], a * b[1], a * b[2]);} //seems to be correct: /view/7dVXzw\n\n//sign(int) is gles300 exclusive\nint sign(int a){return int(sign(float(a)));}\n\n//abs(int) is gles300 exclusive (type float is not gles300 exclusive)\n int abs(int a){return (a)*sign(a);}\n\n #define round(x) floor((x)+.5)\n #define trunc(x) round(abs(x))*sign(x)\n //round() and trunc() seem to be fine if trunc() is false, its likely a floor(). too.\n #define isnan(x) (!(x==x))\n //NaN is an implementation-mess anyways, \n //todo: isinf() exists in ES300, tricky to define for ES100, skipped for now\n //float isinf(float x)(return (abs(x)>=zFar);} //proposal\n #define sinh(x) (exp(x)-exp(-x))*.5\n #define cosh(x) (exp(x)+exp(-x))*.5\n #define tanh(x) ((exp(x)-exp(-x))/(exp(x)+exp(-x)))\n\n//gles300 has bloaty matrix functions, inverse(mat4) is rarely needed.\n //transpose() may already be sufficiently backwards compatible, see\n //https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/transpose.xhtml\n //mat2 transpose(mat2 m){return mat2(m[0].x,m[1].x              ,m[0].y,m[1].y);}\n //mat3 transpose(mat3 m){return mat3(m[0].x,m[1].x,m[2].x       ,m[0].y,m[1].y,m[2].y       ,m[0].z,m[1].z,m[2].z);}\n //mat3 transpose(mat4 m){return mat4(m[0].x,m[1].x,m[2].x,m[3].x,m[0].y,m[1].y,m[2].y,m[3].y,m[0].z,m[1].z,m[2].z,m[3].z,m[0].w,m[1].w,m[2].w,m[3].w);}\n //above transpose() are untested (and likely unneeded)\n //non-square-matrices have a (very backwards compatible) transpose() function defined for them.\nfloat determinant(mat2 m){return m[0][0]*m[1][1]-m[0][1]*m[1][0];}\nfloat determinant(mat3 m){\n//return dot(cross(m[0],m[1]),m[2]);//dot(cross()) only works for mat3, and is computationally wasteful\n //below is likely faster than dot(cross)), as below automatically skips all 0s.\n return m[0][0]*det(mat2(m[1][1],m[1][2],m[2][1],m[2][2]))\n       -m[1][0]*det(mat2(m[0][1],m[0][2],m[2][1],m[2][2]))\n       +m[2][0]*det(mat2(m[0][1],m[0][2],m[1][1],m[1][2]));\n       //opengl mat is [column][row]\n :} // barely tested   :  https://www.youtube.com/watch?v=eYjSu_xXUUQ\n //https://www.shadertoy.com/view/XXXXz7   is a neat ue case\n \nfloat determinant(mat4 m //mat4 determinan() recursion explodes.\n ){float b00=m[0][0]*m[1][1]-m[0][1]*m[1][0],b01=m[0][0]*m[1][2]-m[0][2]*m[1][0]\n  ,b02=m[0][0]*m[1][3]-m[0][3]*m[1][0],b03=m[0][1]*m[1][2]-m[0][2]*m[1][1]\n  ,b04=m[0][1]*m[1][3]-m[0][3]*m[1][1],b05=m[0][2]*m[1][3]-m[0][3]*m[1][2]\n  ,b06=m[2][0]*m[3][1]-m[2][1]*m[3][0],b07=m[2][0]*m[3][2]-m[2][2]*m[3][0]\n  ,b08=m[2][0]*m[3][3]-m[2][3]*m[3][0],b09=m[2][1]*m[3][2]-m[2][2]*m[3][1]\n  ,b10=m[2][1]*m[3][3]-m[2][3]*m[3][1],b11=m[2][2]*m[3][3]-m[2][3]*m[3][2]\n  ;return b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06;}\n//mat2 mat3 mat4 inversions \nwdi(a,b){return a/b;} //is defined below (Worksafe-DIvision wrapper, not yet worksafe)\n//may include almostidentity() to make it truly worksafe\nmat2 inverse(mat2 m){return wdi(mat2(m[1][1],-m[0][1],-m[1][0],m[0][0]),determinant(m));}//mat2 det doesnt compress much\n//  mat3 inversions: //https://www.shadertoy.com/view/4dlGDl\n\n//to get a mat3 inverse mat3, calculating the inverse-transpose) is a lot less code.\nmat3 inverse_transpose(mat3 m){mat3 a;\n\ta[0]=cross(m[1],m[2]);a[1]=cross(m[2],m[0]);a[2]=cross(m[0],m[1]);\t\n\tfloat det=dot(a[2],m[2]);\n\treturn a * (1./det);}\nmat3 inverse(mat3 m){return transpose(inverse_transpose(m));}\nmat3 adjoint_transpose(mat3 m){mat3 a;\n\ta[0]=cross(m[1],m[2]);a[1]=cross(m[2],m[0]);a[2]=cross(m[0],m[1]);\t\n\treturn a;}\n \n/*\n mat4 inverse(mat4 m){float \n   i0 = m[1].y*m[2].z*m[3].w-m[1].y*m[2].w*m[3].z-m[2].y*m[1].z*m[3].w+m[2].y*m[1].w*m[3].z+m[3].y*m[1].z*m[2].w-m[3].y*m[1].w*m[2].z\n  ,i4 =-m[1].x*m[2].z*m[3].w+m[1].x*m[2].w*m[3].z+m[2].x*m[1].z*m[3].w-m[2].x*m[1].w*m[3].z-m[3].x*m[1].z*m[2].w+m[3].x*m[1].w*m[2].z\n  ,i8 = m[1].x*m[2].y*m[3].w-m[1].x*m[2].w*m[3].y-m[2].x*m[1].y*m[3].w+m[2].x*m[1].w*m[3].y+m[3].x*m[1].y*m[2].w-m[3].x*m[1].w*m[2].y\n  ,i12=-m[1].x*m[2].y*m[3].z+m[1].x*m[2].z*m[3].y+m[2].x*m[1].y*m[3].z-m[2].x*m[1].z*m[3].y-m[3].x*m[1].y*m[2].z+m[3].x*m[1].z*m[2].y\n  ,i1 =-m[0].y*m[2].z*m[3].w+m[0].y*m[2].w*m[3].z+m[2].y*m[0].z*m[3].w-m[2].y*m[0].w*m[3].z-m[3].y*m[0].z*m[2].w+m[3].y*m[0].w*m[2].z\n  ,i5 = m[0].x*m[2].z*m[3].w-m[0].x*m[2].w*m[3].z-m[2].x*m[0].z*m[3].w+m[2].x*m[0].w*m[3].z+m[3].x*m[0].z*m[2].w-m[3].x*m[0].w*m[2].z\n  ,i9 =-m[0].x*m[2].y*m[3].w+m[0].x*m[2].w*m[3].y+m[2].x*m[0].y*m[3].w-m[2].x*m[0].w*m[3].y-m[3].x*m[0].y*m[2].w+m[3].x*m[0].w*m[2].y\n  ,i13= m[0].x*m[2].y*m[3].z-m[0].x*m[2].z*m[3].y-m[2].x*m[0].y*m[3].z+m[2].x*m[0].z*m[3].y+m[3].x*m[0].y*m[2].z-m[3].x*m[0].z*m[2].y\n  ,i2 = m[0].y*m[1].z*m[3].w-m[0].y*m[1].w*m[3].z-m[1].y*m[0].z*m[3].w+m[1].y*m[0].w*m[3].z+m[3].y*m[0].z*m[1].w-m[3].y*m[0].w*m[1].z\n  ,i6 =-m[0].x*m[1].z*m[3].w+m[0].x*m[1].w*m[3].z+m[1].x*m[0].z*m[3].w-m[1].x*m[0].w*m[3].z-m[3].x*m[0].z*m[1].w+m[3].x*m[0].w*m[1].z\n  ,i10= m[0].x*m[1].y*m[3].w-m[0].x*m[1].w*m[3].y-m[1].x*m[0].y*m[3].w+m[1].x*m[0].w*m[3].y+m[3].x*m[0].y*m[1].w-m[3].x*m[0].w*m[1].y\n  ,i14=-m[0].x*m[1].y*m[3].z+m[0].x*m[1].z*m[3].y+m[1].x*m[0].y*m[3].z-m[1].x*m[0].z*m[3].y-m[3].x*m[0].y*m[1].z+m[3].x*m[0].z*m[1].y\n  ,i3 =-m[0].y*m[1].z*m[2].w+m[0].y*m[1].w*m[2].z+m[1].y*m[0].z*m[2].w-m[1].y*m[0].w*m[2].z-m[2].y*m[0].z*m[1].w+m[2].y*m[0].w*m[1].z\n  ,i7 = m[0].x*m[1].z*m[2].w-m[0].x*m[1].w*m[2].z-m[1].x*m[0].z*m[2].w+m[1].x*m[0].w*m[2].z+m[2].x*m[0].z*m[1].w-m[2].x*m[0].w*m[1].z\n  ,i11=-m[0].x*m[1].y*m[2].w+m[0].x*m[1].w*m[2].y+m[1].x*m[0].y*m[2].w-m[1].x*m[0].w*m[2].y-m[2].x*m[0].y*m[1].w+m[2].x*m[0].w*m[1].y\n  ,i15= m[0].x*m[1].y*m[2].z-m[0].x*m[1].z*m[2].y-m[1].x*m[0].y*m[2].z+m[1].x*m[0].z*m[2].y+m[2].x*m[0].y*m[1].z-m[2].x*m[0].z*m[1].y\n  ;return wdi(mat4(i0,i1,i2,i3,i4,i5,i6,i7,i8,i9,i10,i11,i12,i13,i14,i15)\n  ,(m[0].x*i0+m[0].y*i4+m[0].z*i8+m[0].w*i12));}//mat3 det compresses a bit more\n/**/ \n//detemrinant() and inverse() are cc-license from pilibs boilerplate of inogoQuilez (included in shadertoy, but only as javascript for webVR)\n\n//texelFetch() uses gles300 exclusive ivec2, substituting with texture(,(vec2()*.5)/iResolution.xy)\nvec4 tf(sampler2D a,vec2 b,vec3 r){return texture(a,(b+.5)/r.xy) ;}\n#else\nvec4 tf(sampler2D a,vec2 b,vec3 r){return texelFetch(a,ivec2(b),0) ;}\n#endif\n\n//below trig-functions are not in es300 and not in es100\n#define coth(x) ((exp(x)+exp(-x))/(exp(x)-exp(-x)))\n//sech() is not defined for glES300, so its the same mess in all versions.\n#define sech(x) wdi(1.,cosh(x))\n#define atanh(x) .5*log(wdi(1.+x,1.-x))\n#define asinh(x) wlo(x+wsq(x*x+1.))\n#define asech(x) wlo((1.+wsq(1.-x*x))/x)\n#define acoth(x) .5*wlo((x+1.)/(x-1.))\n#define acosh(x) wlo(x+wsq(x*x-1.))\n#define acsch(x) wlo((1.+wsq(1.+x*x))/x)\n\n\nmat4 rotationAxisAngle(vec3 v,float r//axis,angle\n){float s=sin(r),c=cos(r);return \n  mat4(mat3(c)\n      +outerProduct(v,v)*(1.-c)\n      +mat3(0,-v.z,v.yz,0,-v.xy,v.x,0)*s)\n +mat4(1)-mat4(mat3(1));}\n\nmat4 translate(vec3 t){mat4 m=mat4(1);m[3]=vec4(t.xyz,1);return m;}\n\n\n\n\n\n\n//all code below if an older shader \n//,that was about a lot of OTHER compatibility issues.\n\n\n\n\n\n\n\n\n\n\n\n\n//[compatible v3]  //https://www.shadertoy.com/view/3lf3z8\n//proposed namespaces to make webgl2 code more backwards compatible to Webgl.\n//webGL_es300 emulation in webgl_es100\n\n//turns out shadertoy does emulate a lot of gles300 in gles100, but some things are arbitiarily skipped\n//mat2 transpose() and all the trigonometry is missing.\n\n//pre-defined common canvas:\n\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n#define i0 int\n#define i1 ivec2\n#define i2 ivec3\n#define i3 ivec4\n#define vec1 float\n#define ivec1 int\n#define turm v0 t,v1 u,v2 r,v3 m //for prototypes and audiovisual fm synthesis (time,uv,resolution.xyz,mouse)\n\n#define pi acos(-1.)\n#define tau pi*2.\n//float tau=6.2831853071795864769252867665590057683943387987502116419;//trig definition can be better for smarter compilers.\n#define eul 2.7182818284590452353602874713526624977572470936999595749\n//eul=exp(1.)???\n//goldenRatio=phi+1=Phi :where: 1/phi=phi-1&&1/Phi=Phi-1\n//https://en.wikipedia.org/wiki/Golden_ratio\n#define phi (sqrt(5.)*.5-.5)\n#define Phi (sqrt(5.)*.5+.5)\n#define sat(x)clamp(x,0.,1.)\n#define dd(a)dot(a,a)\n#define u5(a)((a)*.5+.5)\n#define u2(a)((a)*2.-1.)\n\n//2d zoom\n#define viewZoom 5.\n#define fra(u)((u-.5*r.xy)*viewZoom/r.y)\n//divide by /Aa for hairline drawing and sharp smoothstep()\n#define Aa (min(r.x,r.y)/viewZoom)\n\n//#define ss(a,u)smoothstep(a,-a,u)//bad namespace for this,more trouble than its worth\nvec1 ad(vec4 a){return dot(vec4(1),a);}vec1 ad(vec3 a){return dot(vec3(1),a);}vec1 ad(vec2 a){return a.x+a.y;}v0 ad(v0 a){return a;}//sum of vector\n#define minx(a,b)mix(b,a,step(a.x,b.x))\n#define manx(a,b)mix(a,-b,step(a.x,-b.x))\n#define maxx(a,b)-minx(-a,-b)\n\n\n//---monadic inequality bounds:\n#define BoundOr(a,b,c) (abs(b-.5*a)*2. c a)\n#define BoundAnd(a,b,c) (a c abs(b-.5*a)*2. ) \n//has usecase examples:\n//(0.<a&&a<b) === boundAnd(a,b,<) === boundOr (a,b,>=) === (0.>=a||a>=b)\n//(0.>a||a>b) === boundOr (a,b,>) === boundAnd(a,b,<=) === (0.<=a&&a<=b)\n//\n//above is useful to measure 2x as many bounds at once (culling context frame)\n//below is useful to mix multiple cases (branchlessing)\n//unifying these 2 can be tricky.\n//\n//these branchless comparators compare [c] with [0.0] to return [a]==true or [b]==false;\n//see: https://www.reddit.com/r/askmath/comments/6aag2g/simplifying_stepa00step00a/\n//(c> 0)?a:b\n#define greater(a,b,c)   mix(a,b,step(c,0.))\n//(c< 0)?a:b\n#define less(a,b,c)      mix(a,b,step(0.,c))\n//(c==0)?a:b\n#define equals(a,b,c)    mix(b,a,step(c,0.)+step(0.,c)-1.)\n////#define equalsA(a,b,c) mix(b,a,(sign(c)+sign(-c))*.5)//here you can NOT substitute sign(-c) for=sign(c),because that implies a [signed null]!\n//----------- mirror symmetry mirror==swap outputs--------------------\n//(c!=0)?a:b\n#define unequal(a,b,c)   mix(a,b,step(c,0.)+step(0.,c)-1.)\n//(a>=0)?a:b   \"unless   \"=not less  ==greater OR equal\n#define unless(a,b,c)    mix(b,a,step(0.,c))\n//(c<=0)?a:b   \"ungreater\"=not greater==less    OR equal\n#define ungreater(a,b,c) mix(b,a,step(c,0.))\n\nvec1 mx(vec1 a,vec1 b,vec1 c){return mix(a,vec1(b),c);}\nvec2 mx(vec2 a,vec1 b,vec2 c){return mix(a,vec2(b),c);}\nvec3 mx(vec3 a,vec1 b,vec3 c){return mix(a,vec3(b),c);}\nvec4 mx(vec4 a,vec1 b,vec4 c){return mix(a,vec4(b),c);}\n\n//---- worksafing\n//address space is limited, some asymptotic cases are undefined\n//they may have inconsistent outcomes (NaN handling) crash on runtime or cause fatal compiler error\n//  a/0.\n//sqrt(-1.)  == pow(-1.,.5)\n//log(0.)   log2(0.)\n//log(-1.)  log2(-1.)\n//pow(0.,0.)\n//mod(a,63.)\n//(-1%-2)     //integer modulo with negative inputs is a hot mess.\n#define zFar 16777216.\n//pow(2.,24)=16777216. is asserted to be a worksafe range, where type [32bit float] still maps to type [int]\n//BUT this ignores NaN and inf, and sign bit complements\n//nonetheless, if you want compatibility, that is, some bitwise operants in webglES100\n//main utility is a zBuffer, that QUICKLY gets compressed to 24 bit integer range.\n//16777216. is a significant limit (or half of that value)\n//replace all division with a wrapper, that optionally can be made worksafe\nv0 wdi(v0 a,v0 b){if(b==0.)return 0.;return a/b;}//type float of type independent worksave division\nv1 wdi(v1 a,v1 b){return a/b;}//actually not too sure how to best define this\nv2 wdi(v2 a,v2 b){return a/b;}//actually not too sure how to best define this\nv3 wdi(v3 a,v3 b){return a/b;}//actually not too sure how to best define this\ni0 wdi(i0 a,i0 b){if(b==0 )return 0 ;return a/b;}//type int   of type independent worksave division\ni1 wdi(i1 a,i1 b){return a/b;}//actually not too sure how to best define this\ni2 wdi(i2 a,i2 b){return a/b;}//actually not too sure how to best define this\ni3 wdi(i3 a,i3 b){return a/b;}//actually not too sure how to best define this\n//i sure can not mix(step()) the above\nmat2 wdi(mat2 a,mat2 b){return a/b;}\nmat2 wdi(mat2 a,vec1 b){return a/b;}\nmat3 wdi(mat3 a,mat3 b){return a/b;}\nmat3 wdi(mat3 a,vec1 b){return a/b;}\nmat4 wdi(mat4 a,mat4 b){return a/b;}\nmat4 wdi(mat4 a,vec1 b){return a/b;}\n//replace all sqrt()  with a wrapper, that optionally can be made worksafe\n#define wsq(a) sqrt(abs(a))\n//replace log() with a wrapper, that optionally can be made worksafe //is oblivious about log(0)\n#define wlo(c){return mx(log(abs(c)),zFar,step(c,0.));}\n//pow(0.,0.) is a bitch to worksafe! //todo.\n\n\nvec3 testEs300trig(vec2 u,vec3 r\n){vec4 c=vec4(sinh(u.x),cosh(u.x),tanh(u.x),coth(u.x)\n )-u.y\n ;float a=1./Aa\n ;c=smoothstep(a,-a,abs(c)-a)\n ;c.xy+=c.w\n ;return c.xyz;}\n\n\n//---- a much better modulo:\n\n\n\n//i found WAY too many shortcomings in the default mod() of ALL webgl versions\n//integer modulo is bad for negative inputs, just way too mabiguous\n//float modulo has significant precision issues, that are ambiguous for mod(a,63.)\n//for the sake of compatibility, this defines explicit bitwise and modulo operands:\n\nint   imod(int   a, int   b){return a-(      wdi(a,b) *b);}//explicit integer modulo \nfloat fmod(float a, float b){return a-(floor(wdi(a,b))*b);}//explicit float  modulo \n//above 2 definitions are a decent start, but not a perfect fit to [%] or mod() for very small or negative inputs.\n//logically     a%b = a-(a/b)*b\n//realistically a%b with negative [a] or negative [b] are literally unpredictable\n//because they are not strictly defined by opengl (there are 4 amboiguous cases)\n//this is already solved in more detail in another shader.\n\n//below goes into more detail and proposes a mo() function;\n//- that is very identical modulo in any environment\n//  to a point where it should make no difference what environment you emulate\n//- and that works with type int ant type float in the same way\n//  unlike the opengl modulo functions, which are just a hot mess\n// and that overlaps nicely with mod()\n//\n//admittingly far from perfrct, but a big step in a good direction.\n\n//mo(a,b) includes a pseudo-integer modulo [%] , that runs fine in opengl_es100, and uses the same mo(a,b) namespace for pseudo-float modulo()\n//[a] is a period that fractures [a]\n//it is [pseudo] as in\n//- for positive inputs, behaves identical to [mod(a,b)/b] or [float(int(a)%int(b)+.5)/b]\n//- for negative inputs, behaves better (continues the period into negative space) (works fine for negative intervals)\n//- is optionally well defined for b=0\n//- is unaffected for cases where you scale [a] and [b] by a [quadraticField] like; a*=[phi=1.61] b*=[phi=1.61]\n//- - that is, it behaves differently when irrational numbers scale it; it remains a constant period over x, regardness of any irrational scaling!\n//- - compare that with a less predictable yellow line, that fractures by phi-scalings and it only periodic over its .y domain.\n//mod(a,b)-.5=a%b=a-floor(b/a)*a is explicit type independent modulo in interval [b] (div before mult!)\n//we define arrays functions to be less type dependent and more aware of asymptotes\nv0 fl(v0 a     ){return floor(a)              ;}//type float of type independent floor()\ni0 fl(i0 a     ){return       a               ;}//type int   of type independent floor() (tautological namespace)\n#define   ne(a) -(a)                       //negation may be a different operand on different input types (eg complex numbers or chain rule structure)\n#define fmad(a,b,c) ((a)*(b)+(c))          //a lot of hardware is optimized for fmad()\n#define emod(a,b,c) fmad(ne(a),b,c)        //emod() is fmad() with negated [a]\n#define   mo(a,b)  (emod(fl(wdi(a,b)),b,a))//mo(a,b)=(a)-(fl((a)/(b))*(b)) //div before mult! fl() is only relevant for type float\n//note, you might need an offset of +.5 or -.5\n\n\n//thats it, use mo(a,b) instead of mod(a,b), and compare them\n//then replace mo(a,b) [a and b] with integers, and compare it with float(a%b)\n//we do all that in the code below, spoiler, there is a +.5 offset involved, and irrationalNumberScaling is always fun\n\n#define plusOffset \n//plusOffset is a bad idea , is a bad offset          , approaches/evades an asymptote poorly with a bad identity crysis\n#undef  plusOffset \n//no plusoofset is a good idea , is a more intuitive offset, faces an asymptote with consistency\n\n//#define ScalebyGolden \n//scale by golden ratios, stir up some shit\n\n//set what opengl version we want to try [100,300], will become pretentVersion=min(pretentVersion,__VERSION__)\n#define pretentVersion 300 \n\n//needed to compare with [%] which only exists if __VERSION__>=300\n//functions have a unique shape in them to tell you what function you execute (1 circle or 4 circles)\n#if (__VERSION__<pretentVersion)\n  //compileTime min(), modify pretentVersion, __VERSION__ is readOnly\n #undef pretentVersion\n #define pretentVersion __VERSION__\n#endif\n//to have a choice to run whatever you can run\n\n//moWebgl2test() tests mo()=[mod(a,b),floor(a%b+.5)] for [a>0,b>0] is opengl __VERSION__ independent (and float()-typecasting (type independent))\n//modulo with negative inputs must always be tested, most assertions are false assumptions here.\n//this section shows how pathethic  [a%b] performs for [a<0 || b<0] (left screen half, iMouse.x in left screen half)\n//this sectioncan demo how pathethic mod(a,b) erforms for [a==b==63.]\n#if (pretentVersion<300)\nv3 moWebgl2test(turm\n){//we run on Webgl1, the older version of webgl, that likely runs on most modern smartphones\n ;v0 a=63.    //do [a%b, mod(a,m)]\n ;a=u.x-r.x/2.//2d screenspace shows more than 1 [a] in 1 view, screenSpaceCenter sets a=0\n ;v0 b=3.    //period\n ;b=m.x-r.x/2.//mouse.x sets period, screenSpaceCenter==0\n #ifdef ScalebyGolden\n ;a*=sqrt(5.)*.5+.5//plusOffset means we can scale by Phi, and only the blue line is least affected\n ;b*=sqrt(5.)*.5+.5//plusOffset means we can scale by Phi, and only the blue line is least affected\n //;b*=sqrt(5.)*.5-.5//we can scale by Phi, but not by phi, phi is a terrible idea here, unless we also define plusOffset\n //;a*=sqrt(5.)*.5-.5//we can scale by Phi, but not by phi, phi is a terrible idea here, unless we also define plusOffset\n #endif\n ;//remove above line and be amazed how [mo(63.,63.) != mod(63.,63.) ] , even for b>0.\n ;//b=0.;asymptotic div0 test , uncommenting this line may cause a [compileTime parserError]:[div0 syntax error]\n #ifdef plusOffset\n ;v0 w=(mod(a,b)              )/b //pink   lines are shit,known to fail for mod(63.,63.),because people are idiots.\n ;v0 o=(v0( mo(  a,    b ))   )/b //purple lines are good\n ;v0 n=(v0(mo(i0(a),i0(b)))+.5)/b //yellow lines are good (except for the +.5 offset) and for negative values, well lets just do the [else]:\n #else\n //the -.5 offset is possibly a better choice in the long run?\n ;v0 w=(mod(a,b)           -.5)/b //pink   lines are shit\n ;v0 o=(v0(mo(   a,    b ))-.5)/b //purple lines are good\n ;v0 n=(v0(mo(i0(a),i0(b)))   )/b //yellow lines are good (well its the pointSymmetric mopdulo), offset a bit in negative a, accounting for [[year 0]]\n #endif \n ;u=fra(u)\n ;vec4 s=vec4(dd((u.xy)),w,o,n) // (dd((u.xy)) draws 1 circle to indicate opengl1\n ;s.x=sqrt(s.x)-.1\n ;s-=vec4(.2,u.yyy)\n ;v0 aA=1./(Aa)\n ;s=-(abs(s)-aA)//optional draw as lines\n ;s=step(-aA,s)\n ;//s=smoothstep(-aA,aA,s)//alternative smoothstep border.y\n ;s.xy+=s.w;s.xy*=.5\n ;s=s.yxzw\n ;return vec4(s.xyz,1);}\n#else\nv3 moWebgl2test(turm\n){//we run on Webgl2, the newer version of webgl, that may not be supported in hardware/settings\n ;v0 a=63.    //do [a%b, mod(a,m)]\n ;a=u.x-r.x/2.//2d screenspace shows more than 1 [a] in 1 view, screenSpaceCenter sets a=0\n ;v0 b=3.    //period\n ;b=m.x-r.x/2.//mouse.x sets period, screenSpaceCenter==0\n #ifdef ScalebyGolden\n ;a*=sqrt(5.)*.5+.5//plusOffset means we can scale by Phi, and only the blue/green lines are least affected\n ;b*=sqrt(5.)*.5+.5//plusOffset means we can scale by Phi, and only the blue/green lines are least affected\n //;b*=sqrt(5.)*.5-.5//we can scale by phi, only useful while we have NOT defined plusOffset\n //;a*=sqrt(5.)*.5-.5//we can scale by phi, only useful while we have NOT defined plusOffset\n #endif\n ;//b=0.;asymptotic div0 test , uncommenting this line may cause a [compileTime parserError]:[div0 syntax error]\n #ifdef plusOffset\n ;v0 w=mod(a,b)            /b //pink   lines are shit  ,known to fail for mod(63.,63.),because people are idiots.\n ;v0 o=v0((mo(a,b)))       /b //purple lines are good\n ;v0 n=(v0(i0(a)%i0(b))+.5)/b //yellow lines are shit\n #else\n ;v0 w=(   mod(a,b)    -.5)/b //pink   lines are shit  ,known to fail for mod(63.,63.),because people are idiots.\n ;v0 o=(v0((mo(a,b)))  -.5)/b //purple lines are good\n ;v0 n=(v0(i0(a)%i0(b))   )/b //yellow lines are shit\n #endif\n ;//n=((a)%(b))... haves so badly, you just should NEVER use it\n ;//- fails for negative inputs\n ;//- openGl_es300=webgl2 only, may be faster, but is likely nor worth because worst of all:\n ;//- shows a FATAL compiler error for [b==int(0.)] [compileTime parserError]:[div0 syntax error]\n ;//since we divide [w,o,n] with 0, we expect an asymptote for small b\n ;//- while this is interestring, lets not get too confused by it\n ;//n and w overlap nicely, except for negative inputs\n ;//o and w overlap nicely, for all cases\n ;//n and o overlap nicely, \n ;u=fra(u)\n ;vec4 s=vec4(dd(abs(u.xy)-.5),w,o,n) // (dd(abs(u.xy)-.5) draws 4 circles to indicate opengl2\n ;s.x=sqrt(s.x)-.1\n ;s-=vec4(.2,u.yyy)\n ;v0 aA=1./(Aa)\n ;s=-(abs(s)-aA)//optional draw as lines\n ;s=step(-aA,s)\n ;s=s.yxzw\n ;//s=smoothstep(-aA,aA,s)//alternative smoothstep border.y\n ;s.xy+=s.w;s.xy*=.5\n ;return vec4(s.xyz,1);}\n#endif\n\n\n\n\n//-----bitwise on glES100:\n//untested, currently in RequestForComments stage:\n\n//logic of bitwise operands on type float eems to be IDENTICAL/complement to [culling]-subroutines ?\n//(see bitXORm4() below)\n//bitWise AND  <-> min()\n//bitWise OR   <-> max()\n//in the long run [compatibility] is likely becoming a subset of [cull] (but not a subset of [CSG])\n//for large scale optimization/compatibility it all comes down to (frustrum) culling.\n//\n//csg (fuzzy logic) boolean is DIFFERENT; is best expressed with max(a,b)==-min(-a,-b)\n//eucliteanDistanctZOPoint here [adds +1 negation] to all logic, so [CSG] is the negative/complement of [cull]\n//quite common namespace of:  https://www.shadertoy.com/view/Xsc3WX\nfloat csgNEG(float x){return -x;}//{return csgN(x,x);}\nfloat csgAND(float a,float b){return max(a,b);}//AND=NOT(NAND(A,B))\nfloat csgN(float a,float b){return -max(a,b);}//NAND\nfloat csgOR (float a,float b){return -max(-a,-b);}//OR=NAND(NOT(A),NOT(B))\nfloat csgXOR(float a,float b){float o=-max(a,b);return -max(-max(a,o),-max(b,o));}\nfloat csgSUB(float a,float b){return -max(a,-b);}//SUB=AND(A,NOT(B))=NOT(NAND(A,NOT(B)))\n//XOR=NAND(NAND(A,NAND(A,B)),NAND(B,NAND(A,B)))\n\n//intBitsToFloat() uintBitsToFloat() (and their pseudo-inverses) are glES300 exclusive.\n//due to NaN ambiguity, they can only be püseudo-inverse, and only bijectively address 30 of 32 bits.\n//getting half-decently substituting bitwise functions for type float is a tricky mess:\n//exp2(b) == pow(2.,b) is asserted to be true, where exp2() is likely faster AND more precise.\n\n//https://www.shadertoy.com/view/Mt2GWD | https://www.shadertoy.com/view/lsK3D1\n//return [0{{1] of bit b[0..23] from (whole number) float [a]=floor(A); //assert 23 bit base of ieee32bit float\nfloat getBit(float a,float b){return floor(mod(floor(a/exp2(floor(b))),2.));}\n//https://www.shadertoy.com/view/Xsc3WX\n//assert a=floor(A) b=floor(B), return [b]-th bit of [a], range [0||1]  domain of b is shifted to [-1..22], it includes a signBit as 24th bit!\nfloat getBit24(float a,float b){return getBit(a,clamp(b,-1.,22.));} //worksafe clamping\n//we can only get 24 base-bits (+1 sign bit) of a 32 bit float, getting 30 bit of it requires other (less compatible) command; intBitsToFloat()\n\n//mod() is not to be trusted:\n//float getBit0(float a){return floor(a/1.-floor(a*.5/1.)*2.);}\n//float getBit1(float a){return floor(a/2.-floor(a*.5/2.)*2.);}\n//float getBit2(float a){return floor(a/4.-floor(a*.5/4.)*2.);}\n//float getBit3(float a){return floor(a/8.-floor(a*.5/8.)*2.);}\n//above is 4 seperate bits explicitly, below is (up to) any 4 bits at once. \n//below getBits4() generalizes all the above \n//\n//a=floor(A); b=pow(2.,floor(vec4(B,C,D,E)))  //or less domains\n//return  range[0..1] of [A] after masking and shifting by single bit masks (B,C,D,E)\n#define getBits4(a,b) floor(((a)/(b))-(floor((a)*.5/(b))*2.))\n//works, because getBits4() returns a vector, that we can min() max() foreach domain!\n//bitAND(a,b,c) return a&b&(c.x+c.y+c.z+c.w)\n//return bitwise AND of 4bits of [a] and [b], masked by [c]\n//bitANDm4(float a,float b,vec4 c){c*=vec4(equal(getBits4(a,c),getBits4(b,c)));return c.x+c.y+c.z+c.w;}\nfloat bitAND(float a,float b,vec4 c//assert a=floor(A) b=floor(B) c=exp2(floor(C))\n){c*=min(getBits4(a,c),getBits4(b,c));return c.x+c.y+c.z+c.w;}//AND is min()\nfloat bitAND(float a,float b,vec3 c//assert a=floor(A) b=floor(B) c=exp2(floor(C))\n){c*=min(getBits4(a,c),getBits4(b,c));return c.x+c.y+c.z;}//AND is min()\nfloat bitAND(float a,float b,vec2 c//assert a=floor(A) b=floor(B) c=exp2(floor(C))\n){c*=min(getBits4(a,c),getBits4(b,c));return c.x+c.y;}//AND is min()\nfloat bitAND(float a,float b,float c//assert a=floor(A) b=floor(B) c=exp2(floor(C))\n){return c*min(getBits4(a,c),getBits4(b,c));}//AND is min()\n//bitOR(a,b,c) return (a|b)&(c.x+c.y+c.z+c.w)\n//return bitwise OR of 4bits of [a] and [b], masked by [c]\nfloat bitOR(float a,float b,vec4 c//assert a=floor(A) b=floor(B) c=exp2(floor(C))\n){c*=max(getBits4(a,c),getBits4(b,c));return c.x+c.y+c.z+c.w;}//OR is max()\nfloat bitOR(float a,float b,vec3 c//assert a=floor(A) b=floor(B) c=exp2(floor(C))\n){c*=max(getBits4(a,c),getBits4(b,c));return c.x+c.y+c.z;}//OR is max()\nfloat bitOR(float a,float b,vec2 c//assert a=floor(A) b=floor(B) c=exp2(floor(C))\n){c*=max(getBits4(a,c),getBits4(b,c));return c.x+c.y;}//OR is max()\nfloat bitOR(float a,float b,float c//assert a=floor(A) b=floor(B) c=exp2(floor(C))\n){return c*max(getBits4(a,c),getBits4(b,c));}//OR is max()\n//instead of notEqual, can use something like csgXOR(), except its complement!\n//bitXOR(a,b,c) return (a^b)&(c.x+c.y+c.z+c.w)\n//return bitwise XOR of 4bits of [a] and [b], masked by [c]\nfloat bitXOR(float a,float b,vec4 c//assert a=floor(A) b=floor(B) c=exp2(floor(C))\n){c*=vec4(notEqual(getBits4(a,c),getBits4(b,c)));return c.x+c.y+c.z+c.w;}\nfloat bitXOR(float a,float b,vec3 c\n){c*=vec3(notEqual(getBits4(a,c),getBits4(b,c)));return c.x+c.y+c.z;}\nfloat bitXOR(float a,float b,vec2 c\n){c*=vec2(notEqual(getBits4(a,c),getBits4(b,c)));return c.x+c.y;}\nfloat bitXOR(float a,float b,float c\n){return c*float(getBits4(a,c)!=getBits4(b,c));}\n//return bitwiseAND of [a] and [b], masked by 4 smallest bits==[15]==pow(2,4)-1\nfloat bitANDmask15(float a,float b//assert a=floor(A) b=floor(B)\n){return bitAND(a,b,vec4(1,2,4,8));}\n//return bitwiseAND of [a] and [b], masked by 8 smallest bits==[255]==pow(2,8)-1\nfloat bitANDmask255(float a,float b\n){return bitAND(a,b,vec4(1,2,4,8))+bitAND(a,b,vec4(1,2,4,8)*16.);}\n//return bitwiseAND of [a] and [b], masked by 16 smallest bits==[65535]==pow(2,16)-1\nfloat bitANDmask65535(float a,float b\n){return bitAND(a,b,vec4(1,2,4,8)     )+bitAND(a,b,vec4(1,2,4,8)*16.)\n         +bitAND(a,b,vec4(1,2,4,8)*256.)+bitAND(a,b,vec4(1,2,4,8)*4096.);}\n//return bitwiseAND of [a] and [b], masked by 24 smallest bits==[16777215]==pow(2,24)-1\nfloat bitANDmask16777215(float a,float b\n){return bitAND(a,b,vec4(1,2,4,8)        )+bitAND(a,b,vec4(1,2,4,8)*16.)\n         +bitAND(a,b,vec4(1,2,4,8)*256.  )+bitAND(a,b,vec4(1,2,4,8)*4096.)\n         +bitAND(a,b,vec4(1,2,4,8)*65536.)+bitAND(a,b,vec4(1,2,4,8)*1048576.);}\n//return bitwiseOR of [a] and [b], masked by 24 smallest bits==[16777215]==pow(2,24)-1\nfloat bitORmask16777215(float a,float b\n){return bitOR(a,b,vec4(1,2,4,8)      )+bitOR(a,b,vec4(1,2,4,8)*16.)\n         +bitOR(a,b,vec4(1,2,4,8)*256. )+bitOR(a,b,vec4(1,2,4,8)*4096.)\n         +bitOR(a,b,vec4(1,2,4,8)*65536.)+bitOR(a,b,vec4(1,2,4,8)*1048576.);}\n//return bitwiseXOR of [a] and [b], masked by 23 smallest bits==[8388607]==pow(2,23)-1\nfloat bitXORmask8388607(float a,float b\n){return bitXOR(a,b,vec4(1,2,4,8)      )+bitXOR(a,b,vec4(1,2,4,8)*16.)\n         +bitXOR(a,b,vec4(1,2,4,8)*256. )+bitXOR(a,b,vec4(1,2,4,8)*4096.)\n         +bitXOR(a,b,vec4(1,2,4,8)*65536.)+bitXOR(a,b,vec3(1,2,4)*1048576.);}\n         //note the last vec3() parameter lacks its *8\n\n\n\n//bitwise shift type float [x>>n], only shifts whole part; assert a=floor(x) n=floor(n)\n//float shiftsByN(float x,float n){return floor(x/pow(2.,n));}//dumb origin\n//when it comes to shifting/rotation (by negative values), some contexts have ambiguous definitions.\n//well, this definition uses exp2() it doesnt get more common than that?\n\nfloat shift(float x,float n){return x*exp2(n);}\n//a << b == a*exp2(b)\n//a >> b == a/exp2(b)\n//above 2 are precise, log2()|exp2() losslessly directly read mantissa|exponent\nfloat bitOp(float a,float b,float o//assert a,b,o=floor(a,b,0); a,b domains[0..1]; o domain[0..15]\n){return bitXORmask8388607((8./exp2(a))/exp2(2.*b),o);} //return (((8>>a)>>(2*b))&o;\n/**/\n//-----\n\n\n/*\n//test all\nvoid mainImage( out vec4 o, in vec2 u\n){vec3 r=iResolution\n #if (__VERSION__ >=300)\n  ;int oo=4%6                 //es300 only, workarounds are tricky\n  ;float aa=intBitsToFloat(1) //es300 only, workarounds are tricky\n #endif\n ;bvec4 bb=bvec4(true,false,false,true)//es100\n ;vec4 m=iMouse\n ;o=moWebgl2test(iTime,u,iResolution,iMouse)*.5\n ;u=fra(u)\n ;m.xy=fra(m.xy)\n ;float c=length(u-m.xy)\n ;vec2 d=vec2(round(u.x),trunc(u.x))\n ;d.x=length(vec2(d.x,u.y)-m.xy)\n ;d.y=length(vec2(d.y,u.y)-m.xy)\n ;float a=1./Aa\n ;c=1.-(a,-a,abs(c))\n ;d=1.-(a,-a,abs(d))\n ;o.xyz=max(o.xyz,vec3(c,d))\n ;o.xyz=max(o.xyz,testEs300trig(u,r))\n ;}\n*/\n\n\n\n\n\n\n\n//self: https://www.shadertoy.com/view/3lf3z8\n\n//round,modulo,inverse,trigonometry,bitwise,determinant,cosh,tanh,version,compatibility,sinh,trunc,mobile,tablet\n\n//this shader triesto emulate webgl2 in webgl1\n//this has many shortcomings and issues.\n\n\n//i do not dare to test bitwise operands for now.\n\n/*\nvoid mainImage( out vec4 o, in vec2 u\n){vec3 r=iResolution\n #if (__VERSION__ >=300)\n  ;int oo=4%6                 //es300 only, workarounds are tricky\n  ;float aa=intBitsToFloat(1) //es300 only, workarounds are tricky\n #endif\n ;bvec4 bb=bvec4(true,false,false,true)//es100\n ;vec4 m=iMouse\n ;o=moWebgl2test(iTime,u,iResolution,iMouse)*.5 //compatible integer modulo test\n ;u=fra(u)\n ;m.xy=fra(m.xy)\n ;float c=length(u-m.xy)\n ;vec2 d=vec2(round(u.x),trunc(u.x))\n ;d.x=length(vec2(d.x,u.y)-m.xy)\n ;d.y=length(vec2(d.y,u.y)-m.xy)\n ;float a=1./Aa\n ;c=1.-(a,-a,abs(c))\n ;d=1.-(a,-a,abs(d))\n ;o.xyz=max(o.xyz,vec3(c,d))\n ;o.xyz=max(o.xyz,testEs300trig(u,r))\n ;}*/\n/**/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}