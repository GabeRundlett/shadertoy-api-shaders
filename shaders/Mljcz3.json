{
    "Shader": {
        "info": {
            "date": "1509802151",
            "description": "fork of\nhttps://www.shadertoy.com/view/XdtSRn\ncould this easily do gravity waves?",
            "flags": 32,
            "hasliked": 0,
            "id": "Mljcz3",
            "likes": 9,
            "name": "LightVolume LPV",
            "published": 3,
            "tags": [
                "illumination",
                "bounce",
                "occlusion",
                "spherical",
                "harmonics",
                "radiosity",
                "lpv"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 1340
        },
        "renderpass": [
            {
                "code": "/*\nsign 3d light proparagting voxels\n\nself  : https://www.shadertoy.com/view/Mljcz3\nparent: https://www.shadertoy.com/view/XdtSRn\nshoulders of giants:\n\nalso helpful for reference:\nLight Propagation Volumes - Annotations, Andreas Kirsch (2010)\nhttp://blog.blackhc.net/wp-content/uploads/2010/07/lpv-annotations.pdf\nhttp://data.blog.blackhc.net/2010/07/lpv-annotations.pdf\n\n*/\n\nvec2 min2(vec2 a, vec2 b){return mix(a,b,step(b.x,a.x));}\nvec2 max2(vec2 a, vec2 b){return mix(b,a,step(b.x,a.x));}\n\nfloat miv(vec2 a){return min(a.x,a.y);}\nfloat miv(vec3 a){return min(a.z,min(a.x,a.y));}\nfloat miv(vec4 a){return min(miv(a.xy),miv(a.zw));}\n\nfloat sdBox(vec3 p,vec3 b)\n{vec3 d=abs(p)-b;return min(-miv(-d),0.)+length(max(d,.0));}\nvec2 box3(vec3 p){\n;vec2   d=vec2(sdBox(p-vec3(0,0, 2.2),vec3(2,4,.3)),2.)\n;d=min2(d,vec2(sdBox(p-vec3(0,0,-2.2),vec3(2,4,.3)),3.))\n;d=min2(d,vec2(sdBox(p-vec3(-2.2,0,0),vec3(.3,4,2)),1.));\n;return d;}\nvec2 boxCut(vec3 p){\n;vec2 d=box3(p),q=vec2(sdBox(p-vec3(-1,0,1),vec3(.5,1,.5)),1.)\n;q=max2(q,vec2(-sdBox(p-vec3(-.5,.5,.5),vec3(.5,.7,.5)),3.))\n;return min2(d,q);}\nvec2 napkinRing(vec3 p)\n{vec2 q=vec2( length(p-vec3(0,0,-.8))-1.,1.)\n;vec2 d=vec2(-length(p.xz-vec2(.0,-.8))+.5,2.);\n;return max2(d,q);}\nfloat sdTorus(vec3 p,vec2 t)\n{vec2 q=vec2(length(p.xz)-t.x,p.y)\n;return length(q)-t.y;}\nvec2 doModel( vec3 p )\n{vec2 d=vec2(p.y+1.,4.)//plane\n;d=min2(d,napkinRing(p))\n;d=min2(d,boxCut(p));\n;d=min2(d,vec2(sdTorus(p.yxz-vec3(-.5+sin(iTime*.25),1.4,.5),vec2(1,.3)),1.))\n//;d = max2(d, vec2(p.y, 1.0));//slice to debug  \n;return d;}\n\nconst vec3 lpvsize=vec3(32.);\nconst float numvoxels=lpvsize.x*lpvsize.y*lpvsize.z;\n\nvec2 unpackfragcoord2 (float p, vec2 s)\n{float x=mod(p,s.x);return vec2(x,(p-x)/s.x+.5);}\nfloat packfragcoord3(vec3 p,vec3 s)\n{return floor(p.z)*s.x*s.y+floor(p.y)*s.x+p.x;}\n\n\nvec4 fetch(vec3 p,float c){p=clamp(p,vec3(.5),lpvsize-.5)\n;float d=packfragcoord3(p,lpvsize)+c*numvoxels\n;return texture(iChannel0,unpackfragcoord2(d,iChannelResolution[0].xy)/iChannelResolution[0].xy);    }\n\nvec4 sample_lpv_trilin(vec3 p,float c)\n{p=clamp(p*lpvsize-.5,vec3(.5),lpvsize-.5)\n;vec3 w=fract(p),q=1.-w\n;vec2 e=vec2(0,1),h=vec2(q.x,w.x)\n;vec4 k=vec4(h*q.y,h*w.y)\n,s=k*q.z,t=k*w.z\n,p000=fetch(p+e.xxx,c)\n,p001=fetch(p+e.xxy,c)\n,p010=fetch(p+e.xyx,c)\n,p011=fetch(p+e.xyy,c)\n,p100=fetch(p+e.yxx,c)\n,p101=fetch(p+e.yxy,c)\n,p110=fetch(p+e.yyx,c)\n,p111=fetch(p+e.yyy,c)\n;return p000*s.x+p100*s.y+p010*s.z+p110*s.w\n       +p001*t.x+p101*t.y+p011*t.z+p111*t.w;}\n\nvec4 sh_project(vec3 n){return vec4(n,.57735026918963);}\n\nfloat sh_dot(vec4 a,vec4 b){return max(dot(a,b),0.);}\n\n// 3 / (4 * pi)\nconst float m3div4pi=.23873241463784;\nfloat sh_flux(float d) {\n\treturn d * m3div4pi;\n}\n\n#ifndef M_DIVPI\n#define M_DIVPI 0.3183098861837907\n#endif\n\nfloat sh_shade(vec4 vL, vec4 vN){return sh_flux(sh_dot(vL,vN))*M_DIVPI;}\n\n#define SHSharpness 1.0 // 2.0\nvec4 sh_irradiance_probe(vec4 v)\n{const float sh_c0=(2.-SHSharpness)*1.\n,sh_c1=SHSharpness*2./3.\n;return vec4(v.xyz*sh_c1,v.w*sh_c0);}\n\nfloat shade_probe(vec4 a,vec4 n)\n{return sh_shade(sh_irradiance_probe(a),n);}\n\nvoid doCamera(out vec3 u,out vec3 t)\n{float a=1.5+sin(iTime*.37)*.4\n;u=vec3(4.5*sin(a),2.0,4.5*cos(a))\n;t=vec3(0);}\n\nvec4 doMaterial(vec3 u)\n{float k = doModel(u).y\n;vec3 c=vec3(0)\n;c=mix(c,vec3(1.,1.,1.),float(k==1.))\n;c=mix(c,vec3(1.,.2,.1),float(k==2.))\n;c=mix(c,vec3(.1,.3,1.),float(k==3.))\n;c=mix(c,vec3(.3,.4,.1),float(k==4.))//green floor is different from parent\n;c=mix(c,vec3(.4,1.,.1),float(k==5.))\n;return vec4(c,0);}\n\n// Light\nvec3 doLighting(vec3 u,vec3 n,vec3 m)\n{u=((u-vec3(0,1,0))/2.5)*.5+.5;vec4 d=sh_project(-n)\n;return m*vec3(shade_probe(sample_lpv_trilin(u,0.),d)\n              ,shade_probe(sample_lpv_trilin(u,1.),d)\n              ,shade_probe(sample_lpv_trilin(u,2.),d));}\n\nfloat calcIntersection(vec3 u,vec3 t)\n{const float maxd = 20.0,eps=.001\n;float h=eps*2.,d=.0,r=-1.\n;for( int i=0; i<90; i++\n){if( h<eps||d>maxd)break\n ;h=doModel(u+t*d).x\n ;d+=h;}\n;if(d<maxd)r=d\n;return r;}\n\n//4-sample normal is bad, unless your geometry is only quadratic.\nvec3 calcNormal(vec3 u)\n{const float e=.002\n;const mat3 m=mat3(1)*2.-1.,n=m*e;return normalize\n(m[0]*doModel(u+n[0]).x\n+m[1]*doModel(u+n[1]).x\n+m[2]*doModel(u+n[2]).x\n+doModel(u+e).x);}\n\n//naive camera\nmat3 calcLookAtMatrix( in vec3 u, in vec3 t, in float roll )\n{vec3 w=normalize(t-u)\n;u=normalize(cross(w,vec3(sin(roll),cos(roll),.0)))\n;return mat3(u,normalize(cross(u,w)),w);}\n\nvec3 ff_filmic_gamma3(vec3 x)\n{x=max(vec3(0),x-.004);return (x*(x*6.2+.5))/(x*(x*6.2+1.7)+.06);}\n\nvoid mainImage( out vec4 o,vec2 u)\n{vec2 p=(-iResolution.xy+2.*u.xy)/iResolution.y\n,m=iMouse.xy/iResolution.xy\n;vec3 v,t\n;doCamera(v,t)\n;t=normalize(calcLookAtMatrix(v,t,.0)*vec3(p.xy,2.));//lens length=2.0\n;vec3 c=vec3(0)//background color\n;float w=calcIntersection(v,t)\n;if(w>-.5\n){v+=w*t\n ;c=doLighting(v,calcNormal(v),doMaterial(v).rgb)\n;}\n;c=ff_filmic_gamma3(c)//pow( clamp(c,0.0,1.0), vec3(0.4545) )\n;o=vec4(c,1);}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// geometry volume (stores occlusion coefficients)\n\n///////////////////\n\nvec2 min2(vec2 a, vec2 b){return mix(a,b,step(b.x,a.x));}\nvec2 max2(vec2 a, vec2 b){return mix(b,a,step(b.x,a.x));}\n\nfloat miv(vec2 a){return min(a.x,a.y);}\nfloat miv(vec3 a){return min(a.z,min(a.x,a.y));}\nfloat miv(vec4 a){return min(miv(a.xy),miv(a.zw));}\n\nfloat sdBox(vec3 p,vec3 b)\n{vec3 d=abs(p)-b;return min(-miv(-d),0.)+length(max(d,.0));}\nvec2 box3(vec3 p){\n;vec2   d=vec2(sdBox(p-vec3(0,0, 2.2),vec3(2,4,.3)),2.)\n;d=min2(d,vec2(sdBox(p-vec3(0,0,-2.2),vec3(2,4,.3)),3.))\n;d=min2(d,vec2(sdBox(p-vec3(-2.2,0,0),vec3(.3,4,2)),1.));\n;return d;}\nvec2 boxCut(vec3 p){\n;vec2 d=box3(p),q=vec2(sdBox(p-vec3(-1,0,1),vec3(.5,1,.5)),1.)\n;q=max2(q,vec2(-sdBox(p-vec3(-.5,.5,.5),vec3(.5,.7,.5)),3.))\n;return min2(d,q);}\nvec2 napkinRing(vec3 p)\n{vec2 q=vec2( length(p-vec3(0,0,-.8))-1.,1.)\n;vec2 d=vec2(-length(p.xz-vec2(.0,-.8))+.5,2.);\n;return max2(d,q);}\nfloat sdTorus(vec3 p,vec2 t)\n{vec2 q=vec2(length(p.xz)-t.x,p.y)\n;return length(q)-t.y;}\nvec2 doModel( vec3 p )\n{vec2 d=vec2(p.y+1.,4.)//plane\n;d=min2(d,napkinRing(p))\n;d=min2(d,boxCut(p));\n;d=min2(d,vec2(sdTorus(p.yxz-vec3(-.5+sin(iTime*.25),1.4,.5),vec2(1,.3)),1.))\n//;d = max2(d, vec2(p.y, 1.0));//slice to debug  \n;return d;}\n\n//4-sample normal is bad, unless your geometry is only quadratic.\nvec3 calcNormal(vec3 u)\n{const float e=.002\n;const mat3 m=mat3(1)*2.-1.,n=m*e;return normalize\n(m[0]*doModel(u+n[0]).x\n+m[1]*doModel(u+n[1]).x\n+m[2]*doModel(u+n[2]).x\n+doModel(u+e).x);}\n\n///////////////////\n\nfloat packfragcoord2(vec2 p,vec2 s){\n return floor(p.y)*s.x+p.x;}\nvec3 unpackfragcoord3(float p, vec3 s)\n{float x=mod(p,s.x)\n;float y=mod((p-x)/s.x,s.y)\n;float z=(p-x-floor(y)*s.x)/(s.x*s.y)\n;return vec3(x,y+.5,z+.5);}\n\nconst float s3=sqrt(3.);\nconst float pi=acos(-1.);\n\nvec4 sh_project(vec3 n){return vec4(n,s3/3.);}\n\nconst vec3 lpvs=vec3(32.0);\n\nvoid mainImage(out vec4 o,vec2 u)\n{float v=packfragcoord2(u.xy,iResolution.xy)\n;if(v<(lpvs.x*lpvs.y*lpvs.z)\n){vec3 u=unpackfragcoord3(v,lpvs)\n ;vec3 w=(u-.5)*5./lpvs-2.5+vec3(0,1,0)\n ;float r=s3/lpvs.x\n ;float d=doModel(w).x\n ;if (d>r)o=vec4(0)\n ;else    o=sh_project(calcNormal(w))*(1.-max(d,.0)/r)\n;}\n else o=vec4(0);}",
                "description": "",
                "inputs": [],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// geometry volume (stores occlusion coefficients)\n\n///////////////////\n\nvec2 min2(vec2 a, vec2 b){return mix(a,b,step(b.x,a.x));}\nvec2 max2(vec2 a, vec2 b){return mix(b,a,step(b.x,a.x));}\n\nfloat miv(vec2 a){return min(a.x,a.y);}\nfloat miv(vec3 a){return min(a.z,min(a.x,a.y));}\nfloat miv(vec4 a){return min(miv(a.xy),miv(a.zw));}\n\nfloat sdBox(vec3 p,vec3 b)\n{vec3 d=abs(p)-b;return min(-miv(-d),0.)+length(max(d,.0));}\nvec2 box3(vec3 p){\n;vec2   d=vec2(sdBox(p-vec3(0,0, 2.2),vec3(2,4,.3)),2.)\n;d=min2(d,vec2(sdBox(p-vec3(0,0,-2.2),vec3(2,4,.3)),3.))\n;d=min2(d,vec2(sdBox(p-vec3(-2.2,0,0),vec3(.3,4,2)),1.));\n;return d;}\nvec2 boxCut(vec3 p){\n;vec2 d=box3(p),q=vec2(sdBox(p-vec3(-1,0,1),vec3(.5,1,.5)),1.)\n;q=max2(q,vec2(-sdBox(p-vec3(-.5,.5,.5),vec3(.5,.7,.5)),3.))\n;return min2(d,q);}\nvec2 napkinRing(vec3 p)\n{vec2 q=vec2( length(p-vec3(0,0,-.8))-1.,1.)\n;vec2 d=vec2(-length(p.xz-vec2(.0,-.8))+.5,2.);\n;return max2(d,q);}\nfloat sdTorus(vec3 p,vec2 t)\n{vec2 q=vec2(length(p.xz)-t.x,p.y)\n;return length(q)-t.y;}\nvec2 doModel( vec3 p )\n{vec2 d=vec2(p.y+1.,4.)//plane\n;d=min2(d,napkinRing(p))\n;d=min2(d,boxCut(p));\n;d=min2(d,vec2(sdTorus(p.yxz-vec3(-.5+sin(iTime*.25),1.4,.5),vec2(1,.3)),1.))\n//;d = max2(d, vec2(p.y, 1.0));//slice to debug  \n;return d;}\n\nvec4 doMaterial(in vec3 pos){vec3 c=vec3(0) \n;float k = doModel(pos).y\n;c=mix(c,vec3(1)         ,float(k==1.))\n;c=mix(c,vec3(1,.2,0.1)  ,float(k==2.))\n;c=mix(c,vec3(.1,.3,1.0) ,float(k==3.))\n;c=mix(c,vec3(.3,.15,0.1),float(k==4.))\n;c=mix(c,vec3(.4,1.0,0.1),float(k==5.))\n    //bool color mixer\n    //should not be linear\n    //should be a tree!\n;return vec4(c,0);}\n\n///////////////////\n\nconst vec3 lpvs= vec3(32.0);\n\nfloat packfragcoord2(vec2 p,vec2 s){\n return floor(p.y)*s.x+p.x;}\nvec3 unpackfragcoord3(float p, vec3 s)\n{float x=mod(p,s.x)\n;float y=mod((p-x)/s.x,s.y)\n;float z=(p-x-floor(y)*s.x)/(s.x*s.y)\n;return vec3(x,y+.5,z+.5);}\n\nvoid mainImage(out vec4 o,in vec2 u)\n{float v=packfragcoord2(u.xy,iResolution.xy)\n;if(v<(lpvs.x*lpvs.y*lpvs.z)\n){vec3 pos=unpackfragcoord3(v,lpvs)\n ;vec3 w=(pos-0.5)*5./lpvs-2.5+vec3(0,1,0)\n ;o=doMaterial(w);\n}else o=vec4(0);}",
                "description": "",
                "inputs": [],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// iterative light propagation, one step per frame\n\n//faster but worse branch\n//#define doOlljBranch\n\n\n#define USE_LPV_OCCLUSION 1\n#define USE_LPV_BOUNCE 1\n\n///////////////////\n\nconst vec3 lpvsize = vec3(32.0);\nconst float numvoxels = lpvsize.x * lpvsize.y * lpvsize.z;\n\nvec2 unpackfragcoord2 (float p, vec2 s)\n{float x=mod(p,s.x);\n;return vec2(x,(p-x)/s.x+.5);}\nfloat packfragcoord3(vec3 p,vec3 s){return \n floor(p.z)*s.x*s.y\n+floor(p.y)*s.x+p.x;\n}\n\nfloat packfragcoord2(vec2 p,vec2 s){\n return floor(p.y)*s.x+p.x;}\nvec3 unpackfragcoord3(float p, vec3 s)\n{float x=mod(p,s.x)\n;float y=mod((p-x)/s.x,s.y)\n;float z=(p-x-floor(y)*s.x)/(s.x*s.y)\n;return vec3(x,y+.5,z+.5);}\n\nfloat mav(vec3 a){return max(a.x,max(a.y,a.z));}\n\nvec4 fetch_gv(vec3 p){    \n//* if(any(lessThan(vec2(-mav(-p),.5)  ,vec2(.5,mav(p))  )))    return vec4(0);\n float s=mav(p); \n float a=0.5;\n float b=(lpvsize.x-.5);\n #ifdef doOlljBranch\n  float ba=(lpvsize.x-1.)*1.5;//(a-b)*1.5;\n  //ba-=2.5;//nope still just different.\n  if(s>ba)return vec4(0);\n  //if(abs(s-.5*(b+-a)>b-a)\n #else\n  //above and below shpould be identical but is only nearly identical\n  //not sure if precision error or logic error.    \n  if(any(lessThan(vec2(b,s),vec2(s,a) )))return vec4(0);\n  //if(b<s||s<a)return vec4(0);\n  //if((min(p.x,min(p.y,p.z)) < 0.5) || (max(p.x,max(p.y,p.z)) > (lpvsize.x - 0.5)))return vec4(0.0);\n #endif\n  float posidx = packfragcoord3(p, lpvsize);\n  vec2 uv = unpackfragcoord2(posidx, iChannelResolution[0].xy) / iChannelResolution[0].xy;\n  return texture(iChannel0, uv);\n}\n\nfloat chanel;\nvec3 cmix;\n\nfloat fetch_av(vec3 p) {\n    if ((min(p.x,min(p.y,p.z)) < 0.5) || (max(p.x,max(p.y,p.z)) > (lpvsize.x - 0.5)))\n        return 0.0;\n    float posidx = packfragcoord3(p, lpvsize);\n    vec2 uv = unpackfragcoord2(posidx, iChannelResolution[1].xy) / iChannelResolution[1].xy;\n    return dot(texture(iChannel1, uv).rgb, cmix);\n}\n\nvec4 fetch_lpv(vec3 p) {\n    if ((min(p.x,min(p.y,p.z)) < 0.5) || (max(p.x,max(p.y,p.z)) > (lpvsize.x - 0.5)))\n        return vec4(0.0);\n    float posidx = packfragcoord3(p, lpvsize) + chanel * numvoxels;\n    vec2 uv = unpackfragcoord2(posidx, iChannelResolution[2].xy) / iChannelResolution[2].xy;\n    return texture(iChannel2, uv);\n}\n\n//#if USE_LPV_OCCLUSION || USE_LPV_BOUNCE\nvec4 gv4[6];\nvec4 gv[8];\n//#if USE_LPV_BOUNCE\nfloat bc4[6];\nfloat bc[8];\n//#endif // USE_LPV_BOUNCE\n//#endif // USE_LPV_OCCLUSION || USE_LPV_BOUNCE\n\nvec4 sh_project(vec3 n){return vec4(n,.57735026918963);}\n\nfloat dotm0(vec4 a, vec4 b){return max(dot(a,b),0.);}\n\n// 3 / (4 * pi)\nconst float m3div4pi = 0.23873241463784;\nfloat sh_flux(float d) {\n\treturn d * m3div4pi;\n}\nvec4 sh_flux(vec4 d) {\n\treturn d * m3div4pi;\n}\n\n#define SHSharpness 1.0 // 2.0\nvec4 sh_irradiance_probe(vec4 v) {\n    const float sh_c0 = (2.0 - SHSharpness) * 1.0;\n    const float sh_c1 = SHSharpness * 2.0 / 3.0;\n    return vec4(v.xyz * sh_c1, v.w * sh_c0);\n}\n\n//what the hell is this? \n//\n//angle = (4.0*atan(sqrt(11.)/33.));\nconst float solid_angle_front=.4006696846462392*m3div4pi;\n//angle = (-pi/3.+2.*atan(sqrt(11.)*3./11.0));\nconst float solid_angle_side =.4234313544367392*m3div4pi;\n// 6 * (solid_angle_side * 4 + solid_angle_front) = 4 * PI\n\nvec4 af(vec4 g,ivec2 b,int j,int face_dim,vec3 p,vec3 o,\n                vec4 f,vec4 v,float c)\n{if(b.x==j)return vec4(0)\n;o=normalize(o)\n;float s\n;if(b.y==face_dim)s=solid_angle_front\n;else             s=solid_angle_side\n//;solid_angle=(ii.y == face_dim)?solid_angle_front:solid_angle_side;\n;vec4 im=sh_project(-o)\n;vec4 ou=sh_project( o)\n#if USE_LPV_OCCLUSION\n ;float of=1.-dotm0(f,ou)//asserting that of is range [0..1] (for normlized inputs?)\n#else\n ;float of=1.\n#endif\n;of*=dotm0(g,ou)*s\n;vec4 a=ou*of\n#if USE_LPV_BOUNCE\n ;float r=of*dotm0(v,im)//dotm0>=0;  of>=0; therefore r>=0 ;if(r>0.)\n ;a+=v*c*r\n#endif    \n;return a;}\n    \nvec4 sample_neighbors(int i,int d,vec3 p, vec3 o, vec4 f)\n{vec3 e=vec3(-.5,.5,.0)\n;ivec2 b=ivec2(i,d)\n;vec4 g=fetch_lpv(p+o)\n;return \n af(g,b,0,2,p,e.zzx-o,f,gv4[0],bc4[0])\n+af(g,b,1,2,p,e.zzy-o,f,gv4[1],bc4[1])\n+af(g,b,2,1,p,e.zxz-o,f,gv4[2],bc4[2])\n+af(g,b,3,1,p,e.zyz-o,f,gv4[3],bc4[3])\n+af(g,b,4,0,p,e.xzz-o,f,gv4[4],bc4[4])\n+af(g,b,5,0,p,e.yzz-o,f,gv4[5],bc4[5])\n;}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float posidx = packfragcoord2(fragCoord.xy, iResolution.xy);\n   \n    chanel = floor(posidx / numvoxels);\n    posidx -= chanel * numvoxels;\n    cmix = vec3(\n        float(chanel == 0.0),\n        float(chanel == 1.0),\n        float(chanel == 2.0));\n    if ((iFrame != 0) && (posidx < numvoxels)) {\n\t    vec3 pos = unpackfragcoord3(posidx,lpvsize);\n        vec3 tpos = pos / lpvsize;\n        // 28.0\n        if ((floor(pos.y) == (lpvsize.y - 10.0)) && ((length(tpos.xz - 0.5) - 0.3) < 0.0)) {\n\t\t   \tfloat lightcolor = dot(cmix,vec3(1.0,1.0,1.0));\n        \tfragColor = sh_project(vec3(0.0,-1.0,0.0)) * 50.0 * lightcolor;\n        } else {\n            vec4 shsumcoeffs = vec4(0.0);\n            vec3 e = vec3(-1.0,1.0,0.0);\n            \n            #if USE_LPV_OCCLUSION || USE_LPV_BOUNCE\n            vec2 w = vec2(0.0,1.0);\n            gv[0] = fetch_gv(pos + w.xxx);\n            gv[1] = fetch_gv(pos + w.xxy);\n            gv[2] = fetch_gv(pos + w.xyx);\n            gv[3] = fetch_gv(pos + w.xyy);\n            gv[4] = fetch_gv(pos + w.yxx);\n            gv[5] = fetch_gv(pos + w.yxy);\n            gv[6] = fetch_gv(pos + w.yyx);\n            gv[7] = fetch_gv(pos + w.yyy);\n\n            #if USE_LPV_BOUNCE\n            bc[0] = fetch_av(pos + w.xxx);\n            bc[1] = fetch_av(pos + w.xxy);\n            bc[2] = fetch_av(pos + w.xyx);\n            bc[3] = fetch_av(pos + w.xyy);\n            bc[4] = fetch_av(pos + w.yxx);\n            bc[5] = fetch_av(pos + w.yxy);\n            bc[6] = fetch_av(pos + w.yyx);\n            bc[7] = fetch_av(pos + w.yyy);\n            #endif    \n\n            gv4[0] = (gv[0]+gv[1]+gv[2]+gv[3])*0.25;\n            gv4[1] = (gv[4]+gv[5]+gv[6]+gv[7])*0.25;\n            gv4[2] = (gv[0]+gv[4]+gv[1]+gv[5])*0.25;\n            gv4[3] = (gv[2]+gv[6]+gv[3]+gv[7])*0.25;\n            gv4[4] = (gv[0]+gv[2]+gv[4]+gv[6])*0.25;\n            gv4[5] = (gv[1]+gv[3]+gv[5]+gv[7])*0.25;\n\n            #if USE_LPV_BOUNCE\n            bc4[0] = (bc[0]+bc[1]+bc[2]+bc[3])*0.25;\n            bc4[1] = (bc[4]+bc[5]+bc[6]+bc[7])*0.25;\n            bc4[2] = (bc[0]+bc[4]+bc[1]+bc[5])*0.25;\n            bc4[3] = (bc[2]+bc[6]+bc[3]+bc[7])*0.25;\n            bc4[4] = (bc[0]+bc[2]+bc[4]+bc[6])*0.25;\n            bc4[5] = (bc[1]+bc[3]+bc[5]+bc[7])*0.25;\n            #endif\n\n            #endif // USE_LPV_OCCLUSION || USE_LPV_BOUNCE \n            \n            \n            shsumcoeffs += sample_neighbors(0, 2, pos, e.zzx, gv4[0]);\n            shsumcoeffs += sample_neighbors(1, 2, pos, e.zzy, gv4[1]);\n            shsumcoeffs += sample_neighbors(2, 1, pos, e.zxz, gv4[2]);\n            shsumcoeffs += sample_neighbors(3, 1, pos, e.zyz, gv4[3]);\n            shsumcoeffs += sample_neighbors(4, 0, pos, e.xzz, gv4[4]);\n            shsumcoeffs += sample_neighbors(5, 0, pos, e.yzz, gv4[5]);\n        \n            fragColor = shsumcoeffs;\n        }\n    } else {\n        fragColor = vec4(0.0,0.0,0.0,0.0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}