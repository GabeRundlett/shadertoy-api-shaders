{
    "Shader": {
        "info": {
            "date": "1535237964",
            "description": "Path tracer",
            "flags": 32,
            "hasliked": 0,
            "id": "4ttyWs",
            "likes": 1,
            "name": "Path_tracer",
            "published": 3,
            "tags": [
                "pathtracer"
            ],
            "usePreview": 0,
            "username": "SmartPointer",
            "viewed": 575
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 c = texture(iChannel0, uv);\n    fragColor = vec4(pow(c.xyz / c.w, vec3(0.4545)), 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\tTODO:\n    - Dielectrics\n    - DOF\n    - Boxes\n    - Disks\n    - Rectangles\n*/\n\n// Constants\n// -------------------------------------------------------------------------\n\nconst int NUM_BOUNCES = 6;\nconst int NUM_SPHERES = 3;\nconst int NUM_PLANES = 5;\nconst int NUM_MATERIALS = 7;\nconst int NUM_SAMPLES = 3;\nconst float PI = 3.14159265359;\n\nconst int MAT_TYPE_LAMBERTIAN = 0;\nconst int MAT_TYPE_METAL = 1;\n\n\n// Structs\n// -------------------------------------------------------------------------\n\nstruct Ray {\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct Sphere {\n    vec3 pos;\n    float radius;\n    int materialIndex;\n};\n    \nstruct Plane {\n\tvec3 pos;\n    vec3 normal;\n    int materialIndex;\n};\n\nstruct Material {\n    vec3 albedo;\n    float emission;\n    float roughness;\n    int type;\n};\n\nstruct HitInfo {\n\tvec3 pos;\n    vec3 normal;\n    float t;\n    int materialIndex;\n};\n\n\n// Scene definition\n// -------------------------------------------------------------------------\n\nMaterial materials[NUM_MATERIALS] = Material[] (\n    Material(\t// right sphere\n        vec3(1.0),\n        1.0,\n        0.0,\n        MAT_TYPE_LAMBERTIAN\n    ),\n    Material(\t// light\n        vec3(1.0),\n        0.0,\n        0.0,\n        MAT_TYPE_LAMBERTIAN\n    ),\n    \n    // plane materials\n    Material(\n        vec3(1.0),\n        0.0,\n        0.0,\n        MAT_TYPE_LAMBERTIAN\n    ),\n    Material(\t// left wall\n        vec3(0.0, 1.0, 0.0),\n        1.0,\n        0.0,\n        MAT_TYPE_LAMBERTIAN\n    ),\n    Material(\t// right wall\n        vec3(1.0, 0.0, 0.0),\n        1.0,\n        0.0,\n        MAT_TYPE_LAMBERTIAN\n    ),\n    \n    Material(\t// left sphere\n        vec3(1.0, 1.0, 0.0),\n        0.0,\n        10.0,\n        MAT_TYPE_METAL\n    ),\n\tMaterial(\t// back wall\n        vec3(1.0),\n        0.0,\n        300.0,\n        MAT_TYPE_METAL\n    )\n);\n\nSphere spheres[NUM_SPHERES] = Sphere[] (\n    Sphere(\t\t// light\n        vec3(0.0, 0.1, -0.15),\n        0.06,\n        1\n    ),\n    Sphere(\n        vec3(0.3, 0.1, 0.0),\n        0.08,\n        0\n    ),\n    Sphere(\n        vec3(-0.27, -0.1, 0.0),\n        0.12,\n        5\n    )\n);\n\nPlane planes[NUM_PLANES] = Plane[] (\n    Plane(\t// right\n        vec3(0.4, 0.0, 0.0),\n        vec3(-1.0, 0.0, 0.0),\n        4\n    ),\n    Plane(\t// left\n        vec3(-0.4, 0.0, 0.0),\n        vec3(1.0, 0.0, 0.0),\n        3\n    ),\n    Plane(\t// bottom\n        vec3(0.0, -0.2, 0.0),\n        vec3(0.0, 1.0, 0.0),\n        2\n    ),\n    Plane(\t// top\n        vec3(0.0, 0.2, 0.0),\n        vec3(0.0, -1.0, 0.0),\n        2\n    ),\n    Plane(\t// front\n        vec3(0.0, 0.01, 0.2),\n        vec3(0.0, 0.0, -1.0),\n        6\n    )\n);\n\nvec3 lightPos = vec3(1.0, 0.0, 0.0);\nvec3 lightColor = vec3(1.0);\nfloat lightStrength = 2.0;\nvec3 backgroundColor = vec3(1.0);\n\n\n// Random number generation\n// -------------------------------------------------------------------------\n\n// http://reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\n// http://www.burtleburtle.net/bob/hash/integer.html\nuint wangHash(uint seed) {\n    seed = (seed ^ uint(61)) ^ (seed >> 16);\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nuint randCounter = 0u;\nuint randSeed;\nfloat nextFloat() {\n    randCounter += 10u;\n    return float(wangHash(randSeed + randCounter)) / 4294967296.0;\t// / 2^32\n}\n\nvec3 getRandomHemisphereDir(vec3 normal) {\n    float e = 0.0;\n    \n    float u1 = nextFloat();\n    float u2 = nextFloat();\n    float cosPhi = cos(2.0 * PI * u1);\n    float sinPhi = sin(2.0 * PI * u1);\n    float cosTheta = pow((1.0 - u2), 1.0 / (e + 1.0));\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n    \n    float x = sinTheta * cosPhi;\n    float y = sinTheta * sinPhi;\n    float z = cosTheta;\n    \n    vec3 w = normal;\n    vec3 u = normalize(cross((abs(w.x) > 0.1 ? vec3(0.0, 1.0, 0.0) : vec3(1.0, 0.0, 0.0)), w));\n    vec3 v = cross(w, u);\n    \n    return u * x + v * y + w * z;\n}\n\nvec3 getRandomHemisphereDir(vec3 basisNormal, vec3 surfaceNormal, float e) {\n    float u1 = nextFloat();\n    float u2 = nextFloat();\n    float cosPhi = cos(2.0 * PI * u1);\n    float sinPhi = sin(2.0 * PI * u1);\n    float cosTheta = pow((1.0 - u2), 1.0 / (e + 1.0));\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n    \n    float x = sinTheta * cosPhi;\n    float y = sinTheta * sinPhi;\n    float z = cosTheta;\n    \n    vec3 w = basisNormal;\n    vec3 u = normalize(cross((abs(w.x) > 0.1 ? vec3(0.0, 1.0, 0.0) : vec3(1.0, 0.0, 0.0)), w));\n    vec3 v = cross(w, u);\n    \n    vec3 dir = u * x + v * y + w * z;\n    if (dot(dir, surfaceNormal) < 0.0) {\t// dir is below the surface\n        dir = -u * x - v * y + w * z;\n    }\n    \n    return dir;\n}\n\n\n// Geometry intersection\n// -------------------------------------------------------------------------\n\nbool intersectSphere(Sphere sphere, Ray ray, out HitInfo hitInfo) {\n    bool hit = false;\n    vec3 v = sphere.pos - ray.pos;\n    float b = dot(v, ray.dir);\n    float c = dot(v, v) - sphere.radius * sphere.radius;\n    float disc = b * b - c;\n    \n    if (disc < 0.0) {\n        return false;\n    }\n    \n    disc = sqrt(disc);\n    \n    hitInfo.t = b - disc;\n    if (hitInfo.t <= 0.0) {\n        hitInfo.t = b + disc;\n        if (hitInfo.t <= 0.0) {\n            return false;\n        }\n    }\n    \n    hitInfo.pos = ray.pos + ray.dir * hitInfo.t;\n    hitInfo.normal = normalize(hitInfo.pos - sphere.pos);\n    return true;\n}\n\n// write ray as: l_0 + l * t = p\n// write plane as: dot(p - p_0, n) = 0, where p is a point on the plane\n// combine: dot(l_0 + l * t - p_0, n) = 0\n// solve for t: dot(l * t, n) + dot(l_0 - p_0, n) = 0\n// t * dot(l, n) = -dot(l_0 - p_0, n)\n// t = -dot(l_0 - p_0, n) / dot(l, n)\nbool intersectPlane(Plane plane, Ray ray, out HitInfo hitInfo) {\n    float t = -dot(ray.pos - plane.pos, plane.normal) / dot(ray.dir, plane.normal);\n    if (t > 0.0) {\n        hitInfo.t = t;\n        hitInfo.pos = ray.pos + ray.dir * hitInfo.t;\n        hitInfo.normal = plane.normal;\n        return true;\n    }\n    \n    return false;\n}\n\nbool intersectScene(Ray ray, out HitInfo hitInfo) {\n    hitInfo.t = 1e10;\n\n    int hitSphere = -1;\n    for (int k = 0; k < NUM_SPHERES; k++) {\n        HitInfo hitInfoTemp;\n        if (intersectSphere(spheres[k], ray, hitInfoTemp)) {\n            if (hitInfoTemp.t < hitInfo.t) {\n                hitSphere = k;\n                hitInfo = hitInfoTemp;\n                hitInfo.materialIndex = spheres[hitSphere].materialIndex;\n            }\n        }\n    }\n    int hitPlane = -1;\n    for (int k = 0; k < NUM_PLANES; k++) {\n        HitInfo hitInfoTemp;\n        if (intersectPlane(planes[k], ray, hitInfoTemp)) {\n            if (hitInfoTemp.t < hitInfo.t) {\n                hitPlane = k;\n                hitInfo = hitInfoTemp;\n                hitInfo.materialIndex = planes[hitPlane].materialIndex;\n            }\n        }\n    }\n    \n    return hitSphere > -1 || hitPlane > -1;\n}\n\nbool traceShadowRay(Ray ray) {\n    for (int k = 0; k < NUM_SPHERES; k++) {\n        HitInfo hitInfoTemp;\n        if (intersectSphere(spheres[k], ray, hitInfoTemp)) {\n            return true;\n        }\n    }\n    for (int k = 0; k < NUM_PLANES; k++) {\n        HitInfo hitInfoTemp;\n        if (intersectPlane(planes[k], ray, hitInfoTemp)) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\n\n// Main code\n// -------------------------------------------------------------------------\n\nvec3 trace(Ray ray) {\n    vec3 color = vec3(0.0);\n    vec3 throughput = vec3(1.0);\n    \n    int i = 0;\n    for (i = 0; i < NUM_BOUNCES; i++) {\n        HitInfo hitInfo;\n        if (intersectScene(ray, hitInfo)) {\n            Material material = materials[hitInfo.materialIndex];\n            color += throughput * material.albedo * material.emission;\n            \n            if (material.type == MAT_TYPE_LAMBERTIAN) {\n                ray.dir = getRandomHemisphereDir(hitInfo.normal);\n            } else if (material.type == MAT_TYPE_METAL) {\n                ray.dir = getRandomHemisphereDir(normalize(reflect(ray.dir, hitInfo.normal)), hitInfo.normal, material.roughness);\n            }\n            ray.pos = hitInfo.pos + ray.dir * 0.0001;\n            \n            throughput *= material.albedo * dot(ray.dir, hitInfo.normal);\n        } else {\n            color += backgroundColor * throughput;\n            break;\n        }\n    }\n    \n    return color / float(1.0f);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    randSeed = uint(fragCoord.y * iResolution.x + fragCoord.x) * (uint(iTime * 1000.0));\n    \n    Ray ray;\n    ray.pos = vec3(0.0, 0.0, -1.0);\n    \n    vec3 newColor = vec3(0.0);\n    for (int i = 0; i < NUM_SAMPLES; i++) {\n        ray.dir = normalize(vec3(\n            (fragCoord - iResolution.xy * 0.5 + vec2(nextFloat(), nextFloat())) / iResolution.x,\n            1.0\n        ));\n    \tnewColor += trace(ray);\n    }\n    newColor /= float(NUM_SAMPLES);\n    \n    vec4 color = texture(iChannel0, uv);\n    if (iMouse.z > 0.0) {\n        color = vec4(0.0);\n    }\n    newColor += color.xyz;\n    \n    fragColor = vec4(newColor, color.w + 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}