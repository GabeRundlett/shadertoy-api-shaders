{
    "Shader": {
        "info": {
            "date": "1708198257",
            "description": "some kind of interesting structure !",
            "flags": 0,
            "hasliked": 0,
            "id": "4XjGRh",
            "likes": 21,
            "name": "sdf architecture 1",
            "published": 3,
            "tags": [
                "sdf"
            ],
            "usePreview": 0,
            "username": "sympou",
            "viewed": 204
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415926535\n\n#define maxDist 10.\n#define maxIter 100\n\nfloat rayMarch( vec3 ro, vec3 rd, float tMax ) {\n\n    float t = 0.;\n    int i = 0;\n\n    while ( i < maxIter && t < tMax ) {\n\n        float r = abs( getDist( ro + rd*t ) );\n\n        if ( r <= t*0.001 ) break;\n        t += r;\n        i ++;\n    }\n    \n    return t;\n}\n\nvec3 distance_field_normal(vec3 pos) {\n    vec2 eps = vec2(0.0001,0.0);\n    float nx = getDist(pos + eps.xyy);\n    float ny = getDist(pos + eps.yxy);\n    float nz = getDist(pos + eps.yyx);\n    return normalize(vec3(nx, ny, nz) - getDist(pos));\n}\n\nvec3 render( vec3 ro, vec3 rd ) {\n\n    const vec3 flrCol  = vec3(.75 );\n    const vec3 objCol  = vec3( .8 );\n    const vec3 skyCol  = vec3( .2, .5, 1. );\n    const vec3 skyCol2 = skyCol*0.35 + 0.65;\n\t\n    //        \n    \n    float floorDist = - ro.z / rd.z;\n    float maxDist2  = (floorDist>0.) ? min(maxDist, floorDist) : maxDist;\n    float objDist   = rayMarch( ro, rd, maxDist2 );\n            \n    if ( floorDist < 0. && objDist > maxDist2 ) {\n    \n        //sky\n        float sun   = rd.z;\n        float horiz = pow(max(1.-abs(rd.z),0.),25.0);\n        float light = sun + horiz - horiz * sun ;\n        return sqrt(mix(skyCol, skyCol2, light));\n        \n    } \n\n    vec3 hit, nor, col;\n    float specularity, closestDist;\n\n    if (objDist < maxDist2 && (floorDist < 0. || objDist < floorDist) ) {\n\n        //object\n        hit = ro + rd*objDist;\n        nor = distance_field_normal(hit);\n        col = objCol;\n        specularity = 0.25;\n        closestDist = objDist;            \n\n    } else {\n\n        //floor\n        hit = ro + rd*floorDist;\n        nor = vec3(0.,0.,1.);\n        col = flrCol;\n        specularity = 0.;\n        closestDist = floorDist;\n\n    }\n\n    float diffuse  = max(nor.z*0.475 + 0.525, 0.0);\n    float specular = pow( max( -2.*nor.z*dot(rd, nor) + rd.z, 0.0), 5.0);\n\n    vec3 finalCol = ( col + specular*specularity ) * diffuse ;\n\n    finalCol *= ao(hit, nor);\n\n    finalCol = mix(skyCol2, finalCol, exp(-closestDist*0.005));\n    \n    return sqrt(finalCol);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 p = (2.0*fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec2 m = (2.0*iMouse.xy    - iResolution.xy) / iResolution.y;\n    \n    float ang1 = iTime*0.2 - m.x*2.;\n    float ang2 = - PI*0.525;// -m.y - PI*0.27;\n    \n    vec2 cs1  = vec2(cos(ang1),sin(ang1));\n    vec2 cs2  = vec2(cos(ang2),sin(ang2));\n    mat2 rot1 = mat2(cs1.yxx,-cs1.y);\n    mat2 rot2 = mat2(cs2.yxx,-cs2.y);\n   \n    vec3 ro = vec3( 0., 3.5, 0.0 );\n\tvec3 rd = normalize( vec3(p,-2.0) ).xzy;\n\n    rd.yz *= rot2;\n    ro.yz *= rot2;\n    \n    ro.z += 1.05;\n    \n    rd.xy *= rot1;\n    ro.xy *= rot1;\n    \n    ////\n    \n    vec3 finalCol = render( ro, rd );\n            \n    fragColor = vec4( finalCol, 1.);\n      \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// first two functions from https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec2 p, vec2 b ) {\n    vec2 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\nfloat sdEllipsoid( vec3 p, vec3 r ) {\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n// inspired by this project :\n// https://www.shadertoy.com/view/ftySRt\n// i wondered if it could be extended to 3D,\n// so i included a z parameter, and it worked :)\n// (the sdf is not exact)\nfloat getDist(vec3 p) {\n\n    const float TAU = 6.28318530718;\n    const vec2 cs1 = vec2( 0.30901699437, 0.9510565163); // cos(pi/2.5), sin(pi/2.5)\n    const vec2 cs2 = vec2(-0.80901699437, 0.5877852522); //-cos(pi/5),   sin(pi/5)\n    \n    p.z -= 0.075;\n    float pz = p.z  * 0.5;\n    vec2  p1 = p.xy * cs1;\n    vec2  p2 = p.xy * cs2;\n        \n    vec2 dir = vec2( cos((p.x + pz) * TAU), 0. );\n \n    dir += cos((p1.x + p1.y + pz) * TAU) * cs1;\n    dir += cos((p2.x + p2.y + pz) * TAU) * cs2;\n    dir += cos((p1.x - p1.y + pz) * TAU) * vec2(cs1.x,-cs1.y);\n    dir += cos((p2.x - p2.y + pz) * TAU) * vec2(cs2.x,-cs2.y);\n\n    dir *= 0.2;\n         \n    float val = sdBox( dir, vec2(0.05) )*0.3;\n    //float val = length(dir)*0.3 - 0.015;\n    \n    //\n    \n    // bounding ellipsoid\n    float sphVal = sdEllipsoid(p,vec3(1.25,1.25,2.5));\n           \n    return max(val, sphVal);\n}\n\nfloat getDistAndFloor(vec3 p) {\n    return min(getDist(p),p.z);\n}\n\n//custom ambient occlusion\nfloat ao(vec3 p, vec3 n) {\n    float range = 0.025;\n    float res  = clamp(getDistAndFloor(p + n*range   ) / range       , 0., 0.5) * 0.5\n               + clamp(getDistAndFloor(p + n*range*2.) / range * 0.5 , 0., 0.5) * 0.3\n               + clamp(getDistAndFloor(p + n*range*4.) / range * 0.25, 0., 0.5) * 0.2;\n    \n    return (res*1.5 + 0.25) * min(0.5+0.5*length(p-vec3(0.,0.,0.5)), 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}