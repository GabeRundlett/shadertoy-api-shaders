{
    "Shader": {
        "info": {
            "date": "1595954921",
            "description": "Chapter 5 - The Book of Shaders - Shaping Functions\n\nA gallery of shaping functions where each function generates:\n\n- Black to white gradient based on the x position of each pixel.\n- 2D x/y graph of the function.\n- The easing movement of an orange circle.",
            "flags": 0,
            "hasliked": 0,
            "id": "WlfBzH",
            "likes": 4,
            "name": "Shaping Gallery - TBOS 5.1",
            "published": 3,
            "tags": [
                "sdf",
                "text",
                "bitmap",
                "graph",
                "plot",
                "smoothstep",
                "gallery",
                "shaping"
            ],
            "usePreview": 0,
            "username": "stungeye",
            "viewed": 441
        },
        "renderpass": [
            {
                "code": "// Working Through The Book of Shaders\n// Chapter 05 - Shaping Functions - https://thebookofshaders.com/05/\n// 5.1 - Shaping Function Gallery - Details: https://shader-journey.netlify.app/docs/5-shaping-functions\n\n#define PI 3.1415926535897\n#define DISPLAY_TIME_IN_SECONDS 6.\n#define NUMBER_OF_FUNCTIONS 8\n\n// Bitmap text rendering from: https://www.shadertoy.com/view/4dtGD2\n// Also see: https://www.shadertoy.com/view/4s3fzl\n\n#define _f float\nconst lowp _f CH_A    = _f(0x69f99), CH_B    = _f(0x79797), CH_C    = _f(0xe111e),\n              CH_D    = _f(0x79997), CH_E    = _f(0xf171f), CH_F    = _f(0xf1711),\n              CH_G    = _f(0xe1d96), CH_H    = _f(0x99f99), CH_I    = _f(0xf444f),\n              CH_J    = _f(0x88996), CH_K    = _f(0x95159), CH_L    = _f(0x1111f),\n              CH_M    = _f(0x9f999), CH_N    = _f(0x9bd99), CH_O    = _f(0x69996),\n              CH_P    = _f(0x79971), CH_Q    = _f(0x69b5a), CH_R    = _f(0x79759),\n              CH_S    = _f(0xe1687), CH_T    = _f(0xf4444), CH_U    = _f(0x99996),\n              CH_V    = _f(0x999a4), CH_W    = _f(0x999f9), CH_X    = _f(0x99699),\n              CH_Y    = _f(0x99e8e), CH_Z    = _f(0xf843f), CH_0    = _f(0x6bd96),\n              CH_1    = _f(0x46444), CH_2    = _f(0x6942f), CH_3    = _f(0x69496),\n              CH_4    = _f(0x99f88), CH_5    = _f(0xf1687), CH_6    = _f(0x61796),\n              CH_7    = _f(0xf8421), CH_8    = _f(0x69696), CH_9    = _f(0x69e84),\n              CH_APST = _f(0x66400), CH_PI   = _f(0x0faa9), CH_UNDS = _f(0x0000f),\n              CH_HYPH = _f(0x00600), CH_TILD = _f(0x0a500), CH_PLUS = _f(0x02720),\n              CH_EQUL = _f(0x0f0f0), CH_SLSH = _f(0x08421), CH_EXCL = _f(0x33303),\n              CH_QUES = _f(0x69404), CH_COMM = _f(0x00032), CH_FSTP = _f(0x00002),\n              CH_QUOT = _f(0x55000), CH_BLNK = _f(0x00000), CH_COLN = _f(0x00202),\n              CH_LPAR = _f(0x42224), CH_RPAR = _f(0x24442), CH_END  = _f(0x99999);\n\n// Returns the status of a bit in a bitmap. See above URL for more details.\nfloat getBit( in float map, in float index )\n{\n    return mod( floor( map*exp2(-index) ), 2.0 );\n}\n\n// Draws a character from it's bitmap. See above URL for more details.\nfloat drawChar( in float char, in vec2 pos, in vec2 size, in vec2 uv )\n{\n    uv = (uv - pos) / size;\n    float res = step(0.0,min(uv.x,uv.y)) - step(1.0,max(uv.x,uv.y));\n    uv *= vec2(4,6);\n    res *= getBit(char, 4.0*floor(uv.y) + floor(uv.x));\n    return clamp(res,0.,1.);\n}\n\n// Given an array of bitmap floats, draw out the characters.\nfloat textArray(in vec2 uv, in float[20] string) {\n    const float spacing = 0.08;\n    const vec2 charSize = vec2(spacing * .8, spacing * .8);\n    vec2 charPos = vec2(0.07, 0.88);\n\n    float chr = 0.0;\n\n    for (int i = 0; i < 20; i++) {\n        chr += drawChar( string[i], charPos, charSize, uv);\n        charPos.x += spacing;\n    }\n\n    return chr;\n}\n\n// Which function are we currently displaying? Index from 0 to NUMBER_OF_FUNCTIONS-1\nint functionIndexBasedOnTime() {\n    return int(mod(iTime / DISPLAY_TIME_IN_SECONDS, float(NUMBER_OF_FUNCTIONS)));\n}\n\n// Pick and apply the indexed function.\nfloat pickFunction(float x) {\n    float y;\n    int index = functionIndexBasedOnTime();\n\n    if (index == 0) {                // sin(pi/2 * x)\n        y = sin(.5 * PI * x);\n    } else if (index == 1) {         // 1/2 + (sin(2 * pi * x) / 2)\n        y = sin(x * 2. * PI);\n        y = .5 * y + .5;\n    } else if (index == 2) {         // abs(sin(2 * pi * x))\n        y = abs(sin(2. * PI * x));\n    } else if (index == 3) {         // 1/2 + (tan((pi * x) - pi/2) / 10)\n        y = tan(x * PI - (.5 * PI));\n        y = .1 * y + .5;\n\n        // Don't antialias the infinity that lies just beyond 0 and 1.\n        if (x < 0.) { y = 0.0; }\n        if (x > 1.) { y = 100.; }\n    } else if (index == 4) {         // x^5\n        y = pow(x, 5.);\n    } else if (index == 5) {         // smoothstep(0.1, 0.9, x)\n        y = smoothstep(.1, .9, x);\n    } else if (index == 6) {         // smoothstep(0.4, 0.5, x) - smoothstep(0.5, 0.6, x)\n        y = smoothstep(.4, .5, x) - smoothstep(0.5, 0.6, x);\n    } else if (index == 7) {         // Found: https://www.shadertoy.com/view/3sKSWc\n        float time = mod(iTime, 100.);\n        x *= 5.;\n        y = sin(x * sin(time * .2)) * sin(6. * x + cos(time * time * .001)) * .5  + .5;\n    }\n\n    return y;\n}\n\n// Pick and display the text rendering of the indexed function.\nfloat pickText( in vec2 uv )\n{\n    float s[20];\n    int index = functionIndexBasedOnTime();\n    \n   const float array[3] = float[3](2.5, 7.0, 1.5);\n\n    // This code was originally written targeting WebGL, which is OpenGL 2.x, so doesn't include array constructors.\n    // So instead we have a fixed size array that we \"fill up\" with text by indexing each character.\n    // On ShaderToy this code could be refactored to use array constructors. It would be much more concise.\n    \n    if (index == 0) {          // sin(pi/2 * x)\n        s[0] = CH_S;\n        s[1] = CH_I;\n        s[2] = CH_N;\n        s[3] = CH_LPAR;\n        s[4] = CH_PI;\n        s[5] = CH_SLSH;\n        s[6] = CH_2;\n        s[7] = CH_X;\n        s[8] = CH_RPAR;\n    } if (index == 1) {        // 1/2 + (sin(2 * pi * x) / 2)\n        s[0] = CH_1;\n        s[1] = CH_SLSH;\n        s[2] = CH_2;\n        s[3] = CH_PLUS;\n        s[4] = CH_S;\n        s[5] = CH_I;\n        s[6] = CH_N;\n        s[7] = CH_LPAR;\n        s[8] = CH_2;\n        s[9] = CH_PI;\n        s[10] = CH_X;\n        s[11] = CH_RPAR;\n        s[12] = CH_SLSH;\n        s[13] = CH_2;\n    } else if (index == 2) {   // abs(sin(2 * pi * x))\n        s[0] = CH_A;\n        s[1] = CH_B;\n        s[2] = CH_S;\n        s[3] = CH_LPAR;\n        s[4] = CH_S;\n        s[5] = CH_I;\n        s[6] = CH_N;\n        s[7] = CH_LPAR;\n        s[8] = CH_2;\n        s[9] = CH_PI;\n        s[10] = CH_X;\n        s[11] = CH_RPAR;\n        s[12] = CH_RPAR;\n    }  else if (index == 3) {   // 1/2 + (tan((pi * x) - pi/2) / 10)\n        s[0] = CH_1;\n        s[1] = CH_SLSH;\n        s[2] = CH_2;\n        s[3] = CH_PLUS;\n        s[4] = CH_T;\n        s[5] = CH_A;\n        s[6] = CH_N;\n        s[7] = CH_LPAR;\n        s[8] = CH_PI;\n        s[9] = CH_X;\n        s[10] = CH_HYPH;\n        s[11] = CH_PI;\n        s[12] = CH_SLSH;\n        s[13] = CH_2;\n        s[14] = CH_RPAR;\n        s[15] = CH_SLSH;\n        s[16] = CH_1;\n        s[17] = CH_0;\n    } else if (index == 4) {   // x^5\n        s[0] = CH_P;\n        s[1] = CH_O;\n        s[2] = CH_W;\n        s[3] = CH_LPAR;\n        s[4] = CH_X;\n        s[5] = CH_COMM;\n        s[6] = CH_5;\n        s[7] = CH_RPAR;\n    } else if (index == 5) {   // smoothstep(0.1, 0.9, x)\n        s[0] = CH_S;\n        s[1] = CH_M;\n        s[2] = CH_O;\n        s[3] = CH_O;\n        s[4] = CH_T;\n        s[5] = CH_H;\n        s[6] = CH_S;\n        s[7] = CH_T;\n        s[8] = CH_E;\n        s[9] = CH_P;\n    } else if (index == 6) {   // // smoothstep(0.4, 0.5, x) - smoothstep(0.5, 0.6, x)\n        s[0] = CH_QUOT;\n        s[1] = CH_S;\n        s[2] = CH_M;\n        s[3] = CH_O;\n        s[4] = CH_O;\n        s[5] = CH_T;\n        s[6] = CH_H;\n        s[7] = CH_L;\n        s[8] = CH_I;\n        s[9] = CH_N;\n        s[10] = CH_E;\n        s[11] = CH_QUOT;\n    } else if (index == 7) {   // See pickFunction above. :)\n        s[0] = CH_S;\n        s[1] = CH_E;\n        s[2] = CH_E;\n        s[3] = CH_BLNK;\n        s[4] = CH_S;\n        s[5] = CH_O;\n        s[6] = CH_U;\n        s[7] = CH_R;\n        s[8] = CH_C;\n        s[9] = CH_E;\n        s[10] = CH_BLNK;\n        s[11] = CH_COLN;\n        s[12] = CH_RPAR;\n    }\n    \n    return textArray(uv, s);\n\n}\n\n// Used for smooth function plotting see: https://www.shadertoy.com/view/3sKSWc\nfloat distanceToLineSegment(vec2 p0, vec2 p1, vec2 p) {\n    float distanceP0 = length(p0 - p);\n    float distanceP1 = length(p1 - p);\n    float l2 =pow(length(p0 - p1), 2.);\n    float t = max(0., min(1., dot(p - p0, p1 - p0) / l2));\n    vec2 projection = p0 + t * (p1 - p0);\n    float distanceToProjection = length(projection - p);\n\n    return min(min(distanceP0, distanceP1), distanceToProjection);\n}\n\n// Used for smooth function plotting see: https://www.shadertoy.com/view/3sKSWc\nfloat distanceToFunction(vec2 p, float xDelta) {\n    float result = 100.;\n\n    for (float i = -3.; i < 3.; i += 1.) {\n        vec2 q = p;\n        q.x += xDelta * i;\n\n        vec2 p0 = vec2(q.x, pickFunction(q.x));\n        vec2 p1 = vec2(q.x + xDelta, pickFunction(q.x + xDelta));\n        result = min(result, distanceToLineSegment(p0, p1, p));\n    }\n\n    return result;\n}\n\n// Used for smooth function plotting see: https://www.shadertoy.com/view/3sKSWc\nfloat plotIt(vec2 st, float pct){ // (st = texture coordinates) (pct = % from 0.0 to 1.0)\n  float width = 4.;\n  float distanceToPlot = distanceToFunction(st, 1. / iResolution.x);\n  return smoothstep(0., width, width - distanceToPlot * iResolution.y);\n}\n\n// Draws a progress bar along the bottom of the texture.\nfloat progressBar(vec2 st) {\n    float width = 0.01;\n    float seconds = mod(iTime, DISPLAY_TIME_IN_SECONDS) / DISPLAY_TIME_IN_SECONDS;\n\n    return float(st.y < width && st.x < seconds);\n}\n\n// Signed distance circle with an offset. See: https://www.shadertoy.com/view/3ltSW2\nfloat sdCircle(vec2 p, float r, vec2 offset)\n{\n    p.xy -= offset.xy;                      // Position the circle with an x/y offset.\n    p.y *= iResolution.y / iResolution.x;   // Unskew circle based on aspect ratio.\n    return (1. - sign(length(p) - r)) / 2.; // Are we inside (1) or outside (0) the circle?\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  // Colours for our various on-screen components.\n  const vec3 plotColour = vec3(0.46, 0.37, 0.74);\n  const vec3 textColour = vec3(.9, .15, .3);\n  const vec3 progressColour = vec3(0., .33, .58);\n  const vec3 circleColour = vec3(0.850,0.591,0.227);\n\n  vec2 st = fragCoord.xy / iResolution.xy; // Normalize texture coords from 0.0 to 1.0.\n  vec2 tt = fragCoord / iResolution.y;     // Normalize based only on y resolution for text.\n\n  float y = pickFunction(st.x);     // Pick and calculate a function.\n  float text = pickText(tt);        // Pick and create the bitmapped text and offset shadow.\n  float textShadow = pickText(tt + vec2(-.004, .005));\n  float progress = progressBar(st); // Render the progress bar.\n  float plot = plotIt(st, y);       // Smooth plot the function.\n\n  // Plot the circle easing it's position by the selected function across three second intervals.\n  float circle = sdCircle(st, 0.04, vec2(pickFunction(mod(iTime, 3.) / 3.)));\n\n  float gradient  = min(y, 1.0);      // Black to white background gradient.\n        gradient *= (1. - plot);      // Remove gradient \"below\" where plot will be drawn.\n        gradient *= (1. - text);      // Remove gradient \"below\" where text will be drawn.\n        gradient *= (1. - textShadow);// Remove gradient to leave a text shadow.\n        gradient *= (1. - progress);  // Remove gradient \"below\" where the progress bar will be drawn.\n        gradient *= (1. - circle);    // Remove gradient \"below\" where the circle will be drawn.\n        gradient  = max(gradient, 0.0); // Negative values become zero.\n\n  // Putting everything together with colours.\n  vec3 colour = vec3(gradient)\n                 + vec3(plot) * plotColour\n                 + vec3(text) * textColour\n                 + vec3(progress) * progressColour\n                 + vec3(circle) * circleColour;\n\n  fragColor = vec4(colour, 1.);  // Set pixel colour.\n}\n\n\n// Kyle Geske - stungeye.com - Unlicense 2020 - https://unlicense.org\n// This is free and unencumbered software released into the public domain",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}