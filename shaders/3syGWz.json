{
    "Shader": {
        "info": {
            "date": "1569960150",
            "description": "This is a implementation of the \"Ray Tracing in one weekend\" done in real time.\n\n60 fps with a GTX 1070Ti and 20 rays per pixel!",
            "flags": 0,
            "hasliked": 0,
            "id": "3syGWz",
            "likes": 1,
            "name": "Raytraced rolling metalic balls",
            "published": 3,
            "tags": [
                "raytracing",
                "realtime",
                "relfection",
                "metalic"
            ],
            "usePreview": 0,
            "username": "Cewein",
            "viewed": 465
        },
        "renderpass": [
            {
                "code": "#define FLT_MAX 3.402823466e+38\nconst float PI  = 3.14159265359;\nconst float PHI = 1.61803398875;\n\nstruct ray {\n    vec3 A;\n    vec3 B;\n};\n    \nstruct hitRecord {\n    float t;\n    vec3 p;\n    vec3 normal;\n    int mat;\n    vec3 color;\n};\n\nstruct sphere \n{\n    vec3 center;\n    float radius;\n    int mat;\n    vec3 color;\n};\n    \nstruct hitableList {\n    sphere[4] sList;\n    int size;\n};\n\nstruct camera {\n    vec3 llc;\n    vec3 h;\n    vec3 v;\n    vec3 o;\n};\n        \n           \nvec3 origin(ray r) {return r.A; }\nvec3 direction(ray r) {return r.B; }\nvec3 pointAtParameter(ray r, float t) { return r.A + t*r.B; }\n\nbool hitSphere(in ray r, float tmin, float tmax, inout hitRecord rec, sphere s)\n{\n    vec3 oc = origin(r) - s.center;\n    float a = dot(direction(r),direction(r));\n    float b = dot(oc, direction(r));\n    float c = dot(oc,oc)-s.radius*s.radius;\n    float d = b*b - a*c;\n    if (d > 0.) \n    {\n        float temp = (-b - sqrt(b*b-a*c))/a;\n        if(temp < tmax && temp > tmin)\n        {\n            rec.t = temp;\n            rec.p = pointAtParameter(r,rec.t);\n            rec.normal = (rec.p - s.center) / s.radius;\n            rec.mat = s.mat;\n            rec.color = s.color;\n            return true;\n        }\n        temp = (-b + sqrt(b*b-a*c))/a;\n        if(temp < tmax && temp > tmin)\n        {\n            rec.t = temp;\n            rec.p = pointAtParameter(r,rec.t);\n            rec.normal = (rec.p - s.center) / s.radius;\n            rec.mat = s.mat;\n            rec.color = s.color;\n            return true;\n        }\n    }\n    return false;\n}\n\nbool hit(in ray r, float tmin, float tmax, inout hitRecord rec, hitableList list)\n{\n    hitRecord tempRec;\n    bool hitAny = false;\n    float closestSoFar = tmax;\n    for(int i = 0; i < list.size; i++)\n    {\n        if(hitSphere(r,tmin, closestSoFar,tempRec, list.sList[i]))\n        {\n            hitAny = true;\n            closestSoFar = tempRec.t;\n            rec = tempRec;\n        }\n    }\n    return hitAny;\n}\n\nray getRay(float u, float v, camera cam) { return ray(cam.o,cam.llc + u*cam.h + v*cam.v); }\n\nfloat random (vec2 st) {\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(st.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nvec3 randInUnitSphere(vec2 st) {\n    float phi = random(st.yx) * 2.0 * 3.14159265;\n    float theta = random(st.xy) * 3.14169265;\n    \n    return vec3(cos(phi) * sin(theta), cos(theta), sin(phi) * sin(theta));\n}\n              \nvec3 color(ray r, hitableList list, vec2 st)\n{\n    hitRecord rec;\n    vec3 unitDirection;\n    float t;\n    \n    vec3 att = vec3(1.);\n    \n    int bounceSize = 10;\n    int bounce = 0;\n    \n    while(hit(r, 0.001, FLT_MAX, rec, list) && bounce < bounceSize)\n    {\n        unitDirection = normalize(direction(r));\n        if(rec.mat == 0)\n        {\n            vec3 target = rec.p + rec.normal + randInUnitSphere(st);\n            r = ray(rec.p, target-rec.p);\n            att *= rec.color;\n        }\n        if(rec.mat == 1)\n        {\n            vec3 reflected =reflect(normalize(direction(r)), rec.normal);\n            r = ray(rec.p, reflected);\n            att *= rec.color; // if  att *= rec.color * 50; then the shpere become a light source o_O\n        }\n        if(rec.mat == 2)\n        {\n            float refractiveIndex = 1.5;\n            vec3 reflracted = refract(unitDirection, rec.normal, 1.0/ refractiveIndex);\n            r = ray(rec.p, reflracted);\n        }\n        bounce++;\n    }\n    \n    unitDirection = normalize(direction(r));\n    t =  (unitDirection.y + 1.);\n    return att * (t*vec3(0.6,0.8,1.)*texture( iChannel0, unitDirection ).xyz);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = fragCoord/iResolution.xy;\n    camera cam;\n    cam.llc = vec3(-2.,-1.,-1.);\n    cam.h = vec3(4.,0.,0.);\n    cam.v = vec3(0.,2.25,0.);\n    cam.o = vec3(0.);\n    \n    hitableList list;\n    list.size = 4;\n    list.sList = sphere[4](\n        sphere(vec3(0.,0.,-1.5),0.5,0,vec3(0.8,0.3,0.3)),\n        sphere(vec3(-1.,.0,-1.5 + sin(iTime)),0.5,1,vec3(0.8,0.8,0.8)),\n        sphere(vec3(1.,.0,-1.5+ cos(iTime)),0.5,1,vec3(0.8,0.6,0.2)),\n        sphere(vec3(0.,-100.5,-1.),100.,0,vec3(0.8,0.8,0.0))\n    );\n\n    ray r = getRay(st.x, st.y, cam);\n    vec3 col = vec3(0.);\n    \n    float sizeBlending = 20.;\n    \n    for( float x = 0.; x < sizeBlending; x++)\n    {\n        col += color(r,list,st + x + iTime);\n        //col += color(r,list,st + x);\n    }\n    \n    col = col / sizeBlending;\n    col = sqrt(col);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}