{
    "Shader": {
        "info": {
            "date": "1648994766",
            "description": "Using a tailored Voronoi algorithm to precalculate a greeble-like displacement map, then raymarching it in realtime -- or in simpler terms, raymarching a custom texture. :)",
            "flags": 0,
            "hasliked": 0,
            "id": "NllyWf",
            "likes": 82,
            "name": "Voronoi Greeble Displacement",
            "published": 3,
            "tags": [
                "raymarching",
                "voronoi",
                "displacement",
                "map",
                "pattern",
                "block",
                "greeble"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 1360
        },
        "renderpass": [
            {
                "code": "/*\n\n    Voronoi Greeble Displacement\n    ----------------------------\n\n\tUsing a tailored Voronoi algorithm to precalculate a greeble-like displacement \n    map, then raymarching it in realtime -- or in simpler terms, raymarching a custom \n    texture. :)\n    \n    At present, creating a texture on a buffer for usage in a 3D scene is not what I'd \n    call ideal. If you require proof, search Shadertoy and you won't find a great deal \n    of examples, especially those of the wrapped variety. Having said that, considering \n    the benefits involved, I'm still a little surprised that there aren't more \n    precalculated texture examples than there are.\n    \n    Your two choices are either using a buffer with variable rectangular dimensions, or \n    loading in all six faces of the cube map, then rendering to one or more of the six \n    fixed size faces. In my case, I prefer the latter, which is the lesser of the two \n    evils. I've been told that most GPUs aren't affected too much by the cube map memory \n    requirements, so I'll take people's word for it, but my common sense tells me that \n    using just one fixed size 1024 by 1024 buffer would be a way better use of machine \n    resources... However, I'm not an expert on machine architecture, so who knows.\n    \n    Anyway, the obvious benefit is precalculation. The following scene -- if you can\n    call it that -- involves nothing more than a single raymarched texture. Calculating\n    the 2D displacement function in realtime inside the raymarching loop would be \n    prohibitively expensive.\n    \n    In regard to the texture creation itself, it's just a variation on a Voronoi algorithm.\n    Because it was calculated just the once at startup, I was able to tweak things at\n    my leisure. This is just a very basic example to show that it's possible to raymarch\n    more than simple noise and Voronoi. I'm leading up to more interesting scenes. There\n    are a few defines in the \"Common\" and \"Image\" tab to look at, for anyone interested.\n    \n    \n\n    \n\n\tRelated exmaples:\n    \n\t// As mentioned, there aren't too many precalculated displacement\n    // map examples utilizing the cube map, but here's one.\n    Alien Plain - fizzer \n\thttps://www.shadertoy.com/view/wdGXzy \n    \n    // Awesome precalculated texture example. TekF has a few that are\n    // worth looking at.\n    Sedimentary Erosion - TekF\n    https://www.shadertoy.com/view/tt2Szh\n    \n    // Using a variable sized buffer to precalculate a height field.\n    Mucous Membrane HeightField - tholzer\n    https://www.shadertoy.com/view/4l3fWn\n\n\n*/\n\n\n// Show the displacement map in its 3D setting in more detail.\n//#define MAP_DETAIL\n\n// Just the displacement map on its own. Actually, this is a bump mapped\n// version. The texture map itself is quite mundane. The MAP_DETAIL option\n// above will need to be commented out for this to work.\n//#define DISPLACEMENT_MAP\n\n// Gold material... Gold and silver would look nice. Maybe next time. :)\n//#define GOLD\n\n// Grayscale, for that artsy look.\n//#define GRAYSCALE\n\n\n\n// Max ray distance.\n#define FAR 20.\n\n// No forced unroll.\n#define ZERO min(0, iFrame)\n\n\n\n// Scene object ID to separate the mesh object from the terrain.\nfloat objID;\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){ \n    \n    n = max(abs(n) - .2, .001); // max(abs(n), 0.001), etc.\n    //n /= dot(n, vec3(.8)); \n    n /= length(n);\n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n// Smooth cube map face 2D texture blend.\nfloat getTex(vec3 q){\n    \n    // Scaling.\n    vec2 p = q.xy/4.;\n    \n    // Cube map texture coordinate conversion.\n    p *= cubemapRes;\n    vec2 ip = floor(p); p -= ip;\n    vec2 uv = fract((ip + .5)/cubemapRes) - .5;\n    \n    // 2D neighboring texels stored in each of the four texture channels.\n    vec4 p4 = texture(iChannel2, vec3(-.5, uv.yx)); \n    \n    // Linearly interpolate.\n    return mix(mix(p4.x, p4.y, p.x), mix(p4.z, p4.w, p.x), p.y);\n\n}\n\n\n\n// The extruded image.\nfloat map(vec3 p){\n    \n    \n    // Plane warp.\n    //p.z -= (dot(p.x, p.x))*.0125;\n   \n    // The Voronoi greeble displacement value.\n    float pat = getTex(p);\n    \n    // A second layer. Too much for this example.\n    //float pat2 = getTex(p*2.);\n    //pat = mix(pat, pat2, 1./4.);\n    \n     // Floor.\n    float fl = -p.z;// + 1.;\n    \n    // Applying the displacement map.\n    fl -= pat*.5;\n    \n    \n\n    // Overall object ID. Just the one, so redundant here,\n    // but there are usually more.\n    objID = 0.;\n    \n    // Just the floor.\n    return  fl;\n \n}\n\n \n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = min(iFrame, 0); i<128; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        //t += i<32? d*.75 : d; \n        t += d*.7; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p) {\n\t\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 32; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .2); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 3., occ = 0.;\n    for( int i = ZERO; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        //if(d>1e8) break; // Fake break.\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n    \n}\n\n// Slightly modified version of Nimitz's curve function. The tetrahedral and normal six\n// tap versions are in there. If four taps gives you what you want, then that'd be the\n// one to use.\n//\n// I think it's based on a discrete finite difference approximation to the continuous\n// Laplace differential operator? Either way, it gives you the curvature of a surface, \n// which is pretty handy. I used it to do a bit of fake shadowing.\n//\n// Original usage (I think?) - Cheap curvature: https://www.shadertoy.com/view/Xts3WM\n// Other usage: Xyptonjtroz: https://www.shadertoy.com/view/4ts3z2\n//\n// spr: sample spread, amp: amplitude, offs: offset.\nfloat curve(in vec3 p, in float spr, in float amp, in float offs){\n\n    float d = map(p);\n    \n    spr /= 450.;\n    \n    #if 0\n    // Tetrahedral.\n    vec2 e = vec2(-spr, spr); // Example: ef = .25;\n    float d1 = map(p + e.yxx), d2 = map(p + e.xxy);\n    float d3 = map(p + e.xyx), d4 = map(p + e.yyy);\n    return clamp((d1 + d2 + d3 + d4 - d*4.)/e.y/2.*amp + offs + .5, 0., 1.);\n    #else  \n    // Cubic.\n    vec2 e = vec2(spr, 0); // Example: ef = .5;\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n    return clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*6.)/e.x/2.*amp + offs + .5, 0., 1.);\n    \n    //d *=2.;\n    //return 1. - smoothstep(-.05, .05, (abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d))/e.x/2.*amp + offs + .0);\n    #endif\n\n}\n\n/*\n// A global value to record the distance from the camera to the hit point. It's used to tone\n// down the sand height values that are further away. If you don't do this, really bad\n// Moire artifacts will arise. By the way, you should always avoid globals, if you can, but\n// I didn't want to pass an extra variable through a bunch of different functions.\nfloat gT;\n\n// Surface bump function..\nfloat bumpSurf3D(in vec3 p){\n    \n    \n    \n    float ns = getTex(p);\n    \n    \n    // A surprizingly simple and efficient hack to get rid of the super annoying Moire pattern \n    // formed in the distance. Simply lessen the value when it's further away. Most people would\n    // figure this out pretty quickly, but it took far too long before it hit me. :)\n    return ns;///(1. + gT*gT*.015);\n    \n\n}\n\n// Standard function-based bump mapping routine: This is the cheaper four tap version. There's\n// a six tap version (samples taken from either side of each axis), but this works well enough.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    // Larger sample distances give a less defined bump, but can sometimes lessen the aliasing.\n    const vec2 e = vec2(0.001, 0); \n    \n    // Gradient vector: vec3(df/dx, df/dy, df/dz);\n    float ref = bumpSurf3D(p);\n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy),\n                      bumpSurf3D(p - e.yxy),\n                      bumpSurf3D(p - e.yyx)) - ref)/e.x; \n    \n    \n    // Six tap version, for comparisson. No discernible visual difference, in a lot of cases.\n    //vec3 grad = vec3(bumpSurf3D(p - e.xyy) - bumpSurf3D(p + e.xyy),\n    //                 bumpSurf3D(p - e.yxy) - bumpSurf3D(p + e.yxy),\n    //                 bumpSurf3D(p - e.yyx) - bumpSurf3D(p + e.yyx))/e.x*.5;\n    \n       \n    // Adjusting the tangent vector so that it's perpendicular to the normal. It's some kind \n    // of orthogonal space fix using the Gram-Schmidt process, or something to that effect.\n    grad -= nor*dot(nor, grad);          \n         \n    // Applying the gradient vector to the normal. Larger bump factors make things more bumpy.\n    return normalize(nor + grad*bumpfactor);\n\t\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Aspect correct screen coordinates. Translation and scale is all that\n    // \n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 ro = vec3(cos(iTime/4.)*1.5, iTime/1.5, -1.5); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(cos(iTime/4.)*.05, cos(iTime/2.)*.025  + .1, .25); // \"Look At\" position.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(.5, 1, .75);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.333; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro); // Forward.\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); // Right. \n    // \"right\" and \"forward\" are perpendicular normals, so the result is normalized.\n    vec3 up = cross(fwd, rgt); // Up.\n\n    // rd - Ray direction.\n    vec3 rd = mat3(rgt, up, fwd)*normalize(vec3(uv, 1./FOV - dot(uv, uv)*.05));\n    // Equivalent to:\n    //vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    \n    // Swiveling the camera about the XY-plane.\n\trd.xy *= rot2(-sin(iTime/4.)/2. );\n\n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n\n    // Object ID.\n    float svObjID = objID;\n  \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp);\n        \n        \n        //sn = doBumpMap(sp, sn, .05);///(1. + t*t/FAR/FAR*.25)\n        \n          \n        // Obtaining the texel color. \n\t    vec3 texCol;   \n\n        // The extruded grid.\n        if(svObjID<.5){\n            \n \n            // Surface texture.\n            vec3 txP = sp;\n            txP.xy *= rot2(3.14159/6.);\n            vec3 tx = tex3D(iChannel0, txP, sn);\n            \n            // Texture application.\n            texCol = .025 + tx/2.;\n            \n            #ifdef GOLD\n            // Gold material.\n            texCol *= vec3(1.4, .85, .4);\n            #endif\n             \n            // Extra texture shading. Not used.\n            //float shade = getTex(sp)*.9 + .1;\n            // texCol *= shade;\n\n        }\n        else {\n            \n            // The background. Not used here.\n            texCol = vec3(0);\n        }\n       \n    \t\n    \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        // Light attenuation, based on the distances above.\n\t    float atten = smoothstep(.1, .5, 1./(1. + lDist*lDist*.35))*1.;\n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 16.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n        //sh = min(sh + ao*.25, 1.);\n        \n        // spr: sample spread, amp: amplitude, offs: offset.\n\t\tfloat spr = 4., amp = 1.25, offs = -.25;\n        float crv = curve(sp, spr, amp, offs)*.95 + .05;\n\t    \n\t    \n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        diff = pow(diff, 32.)*4.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 8.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(1. - abs(dot(sn, rd))*.5, 0., 1.), 2.);\n        \n        // Half vector.\n        vec3 hv = normalize(rd + ld);\n        // Specular Blinn Phong. The last term is highlight power related.\n        float specBF = pow(max(dot(hv, sn), 0.), 6.);\n   \n        \n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Feel free to look up\n        // the \"science,\" but it essentially takes that annoying central shine out. How\n        // much you take out depends on the material, which is controlled by the material\n        // constant.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat freS = mix(.2, 1., Schlick);  //F0 = .2 - Glass... or close enough.        \n        \n        // Using the curvature to color the texture a bit.\n        //texCol *= mix(vec3(.0, .1, .2), vec3(.9, .8, .8)/2., crv)*2.;//*.125 + .125;\n      \n        //texCol *= clamp(sp.z + .5, 0., 1.);\n        // Combining the above terms to procude the final color.\n        col = texCol*(diff*sh + .25);\n        //col *= 2.;\n        // The specular term: Instead of putting in two different colored lights, which\n        // requires two expensive shadow runs, I'm using a cheap trick involving partitioning \n        // the specular color with repect to which side of the ray it's sitting on. Not science, \n        // but no one will notice, and those who do won't care. :)\n        vec3 specCol = mix(vec3(1, .4, .2), vec3(1, .4, .2).xzy, smoothstep(0., .3, -rd.y + .3));\n        specCol = mix(vec3(1, .4, .2), vec3(1, .4, .2).zyx, smoothstep(0., .3, -rd.x*2.));\n        specCol *= texCol*8.;\n        //col += specCol*spec*freS*2.*sh; \n        col += specCol*pow(spec, 8.)*freS*32.*sh; \n \n        // Cube map reflection. Not as cool as a second pass, but it works here.\n        vec3 refCol = texture(iChannel1, reflect(rd, sn)).xyz; refCol *= refCol;\n        col += col*refCol*6.;\n        // Specular Blinn Phong.\n        //col += specBF*refCol*4.;\n        \n        // Shading.\n        col *= ao*atten*crv;\n        \n        // Greyscale value, just in case people switch to the Britney video, etc.\n        // Stylistically, the example works better with color. The Britney video\n        // looks OK, but I'm more of a Shirley Jones kind of guy. :)\n        #ifdef GRAYSCALE\n        col = vec3(1)*dot(col, vec3(.299, .587, .114));\n        #endif\n        \n        #ifdef MAP_DETAIL\n        // Also used for debugging purposes.\n        col = vec3(crv*(sh*.9 + .1)); // ao, sh, etc.\n        #endif\n          \n\t\n\t}\n    \n\n    // Just the displacement map on its own. Actually, this is a bump mapped\n    // version. The texture map itself is quite mundane, which you can see \n    // if you set \"b2\" to 1.\n    #ifdef DISPLACEMENT_MAP\n    float b = getTex(vec3(uv*4. - iTime/4., 0));\n    float b2 = getTex(vec3(uv*4. - iTime/4. - normalize(vec2(1, 2))/cubemapRes.x, 0));\n    b2 = max(b2 - b, 0.)*cubemapRes.x;\n    col = b*vec3(1)*(b2*.85 + .15);\n    #endif      \n    \n    // Rought gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// It can be a bit fiddly filling all four channels in at once, but thankfully, this is\n// all calculated at startup. The idea is to put the function you wish to use in the\n// middle of the loop here, instead of writing it out four times over.\nvec4 funcFace0(vec3 p){\n   \n    \n    vec4 col;\n    \n    vec3 q = p;\n    \n    for(int i = 0; i<4; i++){\n        \n        // Texture coordinates for this iteration.\n        q.xy = mod(floor(p.xy*cubemapRes) + vec2(i&1, i>>1), cubemapRes)/cubemapRes;\n        \n        // Subtle, wrapped noise perturbation. Like everything added to the texture,\n        // texture offsets need to be wrapped as well.\n        gSc = vec3(32);\n        float ns = n3DT(q*gSc);\n        float ns2 = n3DT(q*gSc + .35);\n        gSc = vec3(16.);\n        ns = mix(ns, n3DT(q*gSc), 1./3.);\n        ns2 = mix(ns, n3DT(q*gSc + .35), 1./3.);\n        q.xy += (vec2(ns, ns2) - .5)*.0025;\n\n        \n        // Wrapped multilayer tertiary order Voronoi.\n        gSc = vec3(8);\n        #ifdef RAND_ROT\n        vec3 rotF = vec3(.03); // Rotation factor - Range: [0, 1].\n        #else\n        vec3 rotF = vec3(0);\n        #endif\n        //vec3 sc = vec3(1, 1, 2);\n        vec3 sc = vec3(1, 1, 1);\n        int rowOffset = 0;\n        vec3 v = Voronoi(q*gSc, sc, rotF, 1./1., rowOffset, 1);\n     \n        \n        #if VARIATION == 0\n        float vor = abs(v.x - .05);\n        #elif VARIATION == 1\n        float vor = abs(v.y - .15);\n        #elif VARIATION == 2\n        float vor = abs(v.z - v.y - v.x);\n        #else \n        float vor = abs((v.y - clamp(.15 - v.z - v.x, 0., .25)) - .15);\n        #endif\n   \n        #ifdef CORRUGATE\n        // Adding subtle corrugation. It looks interesting, but not for this example.\n        vor = mix(vor, floor(vor*31.999)/31., .15);\n        #endif\n        \n        vor = min(vor*1.35, 1.); // Increasing the slope and capping for a beveled effect.\n        \n        float sf = .4; // Fine edge smoothing.\n        \n        #ifdef LINES\n        // Adding some cell border detail.\n        vor = mix(vor, smoothstep(-sf, sf, (max(1. - vor*42./gSc.x, 0.) - 1./2.)), .15);//\n        #endif\n        \n        //if(hash33(vIP).x>.5) vor = abs(.5-vor);//abs(fract(v.x) - .5)*2.;   \n\n        \n        col[i] = vor;\n        \n        \n        \n        sf = .1;\n        gSc = vec3(128);//\n        rotF = vec3(.03);\n        //vec3 sc = vec3(1, 1, 2);\n        // Putting the height from above into the Z slot.\n        sc = vec3(1, 1, 1);//vor*.25 + .75\n        rowOffset = 1;\n        v = Voronoi(q*gSc, sc, rotF, 1./4., rowOffset, 1);\n        \n        vor = abs(v.x - .2);\n \n        float v2 = mix(min(vor*1.5, 1.), smoothstep(-sf*1., sf*1., (max(1. - vor*64./gSc.x, 0.) - 1./2.)), .15);\n        col[i] = mix(col[i], vor, 1./96.);// - col[i]\n        //col[i] = ov;\n \n        \n    }\n    \n    // Return the four function values -- One for each channel.\n    return col;\n    \n}\n\n\n// Cube mapping - Adapted from one of Fizzer's routines. \nint CubeFaceCoords(vec3 p){\n\n    // Elegant cubic space stepping trick, as seen in many voxel related examples.\n    vec3 f = abs(p); f = step(f.zxy, f)*step(f.yzx, f); \n    \n    ivec3 idF = ivec3(p.x<.0? 0 : 1, p.y<.0? 2 : 3, p.z<0.? 4 : 5);\n    \n    return f.x>.5? idF.x : f.y>.5? idF.y : idF.z; \n}\n\n\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir){\n    \n    \n    // UV coordinates.\n    //\n    // For whatever reason (which I'd love expained), the Y coordinates flip each\n    // frame if I don't negate the coordinates here -- I'm assuming this is internal, \n    // a VFlip thing, or there's something I'm missing. If there are experts out there, \n    // any feedback would be welcome. :)\n    vec2 uv = fract(fragCoord/iResolution.y*vec2(1, -1));\n    \n    // Adapting one of Fizzer's old cube mapping routines to obtain the cube face ID \n    // from the ray direction vector.\n    int faceID = CubeFaceCoords(rayDir);\n  \n  \n    // Pixel storage.\n    vec4 col = vec4(0);\n    \n    // Precalculation flag: GPUs are annoying. Sometimes, they'll will calculate\n    // both the \"if\" and \"else\" statements every time. The \"if\" part here is extremely\n    // expensive, so we don't want that. The solution is to not have an \"if-else\"\n    // statement at all.\n    int preCalc = 0;\n    \n\n    // Initial conditions -- Performed upon initiation.\n    //if(abs(tx(iChannel0, uv, 5).w - iResolution.y)>.001){\n    //if(iFrame<1){\n    //\n    // Great hack, by IQ, to ensure that this loads either on the first frame, or in the\n    // event that the texture hasn't loaded (this happens a lot), wait, then do it...\n    // Well kind of. Either way, it works. It's quite clever, which means that it's something \n    // I never would have considered. :)\n    if(textureSize(iChannel0,0).x<2 || iFrame<1){\n        \n        // This is part of an ugly hack that attempts to force the GPU compiler\n        // to not unroll the Voronoi loops. Not sure if it'll work, but I'm \n        // trying it anyway, in the hope to get compiler times down on some\n        // machines. For the record, this takes about 3 seconds to compile on \n        // my machine.\n        frame0 = iFrame;\n        \n \n        \n        \n        // Fill the first cube face with a custom 3D function.\n        if(faceID==0){\n            \n            //vec3 p = convert2DTo3D(uv);      \n            vec3 p = vec3(uv, 0);      \n            \n            col = funcFace0(p);\n            //col = mix(col, 1.-funcFace0(p*2.), 1./16.);\n            \n            preCalc = 1;\n           \n        }\n\n        /*\n        // Last channel on the last face: Used to store the current \n        // resolution to ensure loading... Yeah, it's wasteful and it\n        // slows things down, but until there's a reliable initiation\n        // variable, I guess it'll have to do. :)\n        if(faceID==5){\n            \n            col.w = iResolution.y;\n        }\n        */\n\n        \n    }\n    \n    \n    if(preCalc == 0 && faceID == 0){\n\n        if(faceID == 0) col = texture(iChannel0, vec3(-.5, uv.yx - .5));\n        //col = tx(iChannel0, uv, faceID);\n    }\n    \n    \n    // Update the cubemap faces.\n    fragColor = col;\n    \n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            },
            {
                "code": "// Displacement texture variations. A reset will be necessary for each change.\n// I.e., you'll need to hit the back button. \n// Variations: 0 through to 2\n#define VARIATION 3\n\n// Random texture object rotation. Hit the back button.\n//#define RAND_ROT\n\n// Add in pattern border line detail. Hit the back button.\n#define LINES\n\n\n// Adding a bit of corrugation. It's interesting, but not on by default.\n// Hit the back button.\n//#define CORRUGATE\n\n\n\n\n// The cubemap texture resultion.\n#define cubemapRes vec2(1024)\n\n// Relates to iFrame.\nint frame0 = 0;\n\n\n\n/* \n// Reading into one of the cube faces, according to the face ID. To save on cycles,\n// I'd hardcode the face you're after into all but the least costly of situations.\n// This particular function is used just once for an update in the \"CubeA\" tab.\n//\n// The four cube sides - Left, back, right, front.\n// NEGATIVE_X, POSITIVE_Z, POSITIVE_X, NEGATIVE_Z\n// vec3(-.5, uv.yx), vec3(uv, .5), vec3(.5, uv.y, -uv.x), vec3(-uv.x, uv.y, -.5).\n//\n// Bottom and top.\n// NEGATIVE_Y, POSITIVE_Y\n// vec3(uv.x, -.5, uv.y), vec3(uv.x, .5, -uv.y).\nvec4 tx(samplerCube tx, vec2 p, int id){    \n\n    vec4 rTx;\n    \n    vec2 uv = fract(p) - .5;\n    // It's important to snap to the pixel centers. The people complaining about\n    // seam line problems are probably not doing this.\n    //p = (floor(p*cubemapRes) + .5)/cubemapRes; \n    \n    vec3[6] fcP = vec3[6](vec3(-.5, uv.yx), vec3(.5, uv.y, -uv.x), vec3(uv.x, -.5, uv.y),\n                          vec3(uv.x, .5, -uv.y), vec3(-uv.x, uv.y, -.5), vec3(uv, .5));\n \n    \n    return texture(tx, fcP[id]);\n}\n*/\n\n\n// If you want things to wrap, you need a wrapping scale. It's not so important\n// here, because we're performing a wrapped blur. Wrapping is not much different\n// to regular mapping. You just need to put \"p = mod(p, gSc)\" in the hash function\n// for anything that's procedurally generated with random numbers. If you're using\n// a repeat texture, then that'll have to wrap too.\nvec3 gSc;\n\n\n// Fabrice's concise, 2D rotation formula.\n//mat2 rot2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n// Standard 2D rotation formula - Nimitz says it's faster, so that's good enough for me. :)\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n\n// 3x1 hash function.\n//float hash31(vec3 p){ return fract(sin(dot(p, vec3(21.471, 157.897, 113.243)))*45758.5453); }\n\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){\n    p = mod(p, gSc.xy);\n    return fract(sin(dot(p, vec2(27.609, 157.583)))*43758.5453); \n}\n\n\n// Dave Hoskins puts together some pretty reliable hash functions. This is \n// his unsigned integer based vec3 to vec3 version.\nvec3 hash33(vec3 p){\n\n    p = mod(p, gSc);\n    // Addendum: The float values cast to unsigned integers can be quite small,\n    // in this particular case, so I've increased them for greater randomization.\n    p *= vec3(9528.609, 7157.583, 7357.781);\n\tuvec3 q = uvec3(ivec3(p))*uvec3(1597334673U, 3812015801U, 2798796415U);\n\tq = (q.x^q.y^q.z)*uvec3(1597334673U, 3812015801U, 2798796415U);\n\treturn -1. + 2.*vec3(q)*(1./float(0xffffffffU));\n}\n\n \n/*\nvec3 hash33(vec3 p){\n\n    \n    //p = mod(p, gSc);\n    //float n = sin(dot(p, vec3(7, 157, 113)));    \n    //return fract(vec3(2097152, 262144, 32768)*n)*2. - 1.; \n    \n    // Dave's hash function. More reliable with large values, but will still eventually break down.\n    //\n    // Hash without Sine.\n    // Creative Commons Attribution-ShareAlike 4.0 International Public License.\n    // Created by David Hoskins.\n    // vec3 to vec3.\n    p = mod(p, gSc);\n\tp = fract(p*vec3(.10313, .10307, .09731));\n    p += dot(p, p.yxz + 19.1937);\n    p = fract((p.xxy + p.yxx)*p.zyx)*2. - 1.;\n    return p;\n   \n    \n    \n    // Note the \"mod\" call. Slower, but ensures accuracy with large time values.\n    //mat2  m = rot2(mod(iTime, 6.2831853));\t\n\t//p.xy = m * p.xy;//rotate gradient vector\n    //p.yz = m * p.yz;//rotate gradient vector\n    ////p.zx = m * p.zx;//rotate gradient vector\n\t//return p;\n    \n\n}\n*/\n \n\n// vec4 to vec4 hash.\nvec4 hash41T(vec4 p){\n    p = mod(p, vec4(gSc.x));\n    return fract(sin(p)*43758.5453);\n}\n\n// Compact, self-contained version of IQ's 3D value noise function.\nfloat n3DT(vec3 p){    \n    \n    // Square partioning.\n    // Local corner points and local coordinates.\n\tvec3 ip = floor(p); p -= ip;\n    \n    // Smoothing.\n    p = p*p*(3. - 2.*p); \n    //p *= p*p*(p*(p*6. - 15.) + 10.);\n    \n    \n    // Random vector.    \n\tconst vec3 s = vec3(27, 111, 57);\n    // Randomizing corner points.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n    // Interpolate X.\n    h = mix(hash41T(h), hash41T(h + s.x), p.x);\n    // Interpolate Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    // Interpolate Z.\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n/*\n// IQ's unsigned box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n\n// IQ's unsigned box formula.\nfloat sBoxS(in vec3 p, in vec3 b, in float sf){\n\n  return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n*/\n\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n   \n\n  vec2 d = abs(p) - b + sf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - sf;\n}\n\n// IQ's signed box formula.\nfloat sBoxS(in vec3 p, in vec3 b, in float sf){\n   \n\n  vec3 d = abs(p) - b + sf;\n  return min(max(max(d.x, d.y), d.z), 0.) + length(max(d, 0.)) - sf;\n}\n\n\n\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n/*\n// IQ's exponential-based smooth maximum function. Unlike the polynomial-based\n// smooth maximum, this one is associative and commutative.\nfloat smaxExp(float a, float b, float k){\n\n    float res = exp(k*a) + exp(k*b);\n    return log(res)/k;\n}\n*/\n\n// IQ's exponential-based smooth minimum function. Unlike the polynomial-based\n// smooth minimum, this one is associative and commutative.\nfloat sminExp(float a, float b, float k){\n\n    float res = exp(-k*a) + exp(-k*b);\n    return -log(res)/k;\n}\n\n// mat3 rotation... I did this in a hurry, but I think it's right. :)\nmat3 rot(vec3 ang){\n    \n    vec3 c = cos(ang), s = sin(ang);\n\n    return mat3(c.x*c.z - s.x*s.y*s.z, -s.x*c.y, -c.x*s.z - s.x*s.y*c.z,\n                c.x*s.y*s.z + s.x*c.z, c.x*c.y, c.x*s.y*c.z - s.x*s.z,\n                c.y*s.z, -s.y, c.y*c.z);\n    \n}\n\n\n\n/*\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    vec2 w = vec2(sdf, abs(pz) - h);\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n\n}\n\n// Signed distance to a regular hexagon -- using IQ's more exact method.\nfloat sdHexagon(in vec2 p, in float r){\n    \n  const vec3 k = vec3(-.8660254, .5, .57735); // pi/6: cos, sin, tan.\n\n  // X and Y reflection.\n  p = abs(p);\n  p -= 2.*min(dot(k.xy, p), 0.)*k.xy;\n    \n  // Polygon side.\n  return length(p - vec2(clamp(p.x, -k.z*r, k.z*r), r))*sign(p.y - r);\n    \n}\n\n*/\n\n// This is a variation on a regular 2-pass Voronoi traversal that produces a Voronoi\n// pattern based on the interior cell point to the nearest cell edge (as opposed\n// to the nearest offset point). It's a slight reworking of Tomkh's example, which\n// in turn, is based on IQ's original example. The links are below:\n//\n// On a side note, I have no idea whether a faster solution is possible, but when I\n// have time, I'm going to try to find one anyway.\n//\n// Voronoi distances - iq\n// https://www.shadertoy.com/view/ldl3W8\n//\n// Here's IQ's well written article that describes the process in more detail.\n// https://iquilezles.org/articles/voronoilines\n//\n// Faster Voronoi Edge Distance - tomkh\n// https://www.shadertoy.com/view/llG3zy\n//\n//\nvec3 cellID;\nint gIFrame;\n\nivec4 gID2;\n\n// Distance metric: Put whatever you want here.\nfloat distMetric(vec3 p, vec3 b, int id){\n    \n    \n    if(id==0){\n    \treturn (dot(p, p));///2.; // Sphere squared.\n    }\n    else {\n        \n        //float d2 = sBoxS(p.xy, b.xy/1., 0.);\n        //float d2 = sdHexagon(p.xy, min(b.x, b.y));\n        //return opExtrusion(d2, p.z, b.z/1.);\n        \n        //return sBoxS(p, b, .1);\n\n        \n        //return (dot(p, p)) - b.x*b.x;\n        //return length(p) - b.x; // Standard spherical Euclidean distance.\n\n        //return max(max(length(p.xy), length(p.yz)), length(p.xz)); // Cylinder cross.\n\n        //p = max(abs(p)*.8660254 + p.yzx*.5, -p);\n        //return max(max(p.x, p.y), p.z); // Triangular.\n\n        // Uncomment this for all metrics below.\n        p = abs(p) - b;\n        \n        \n        //p = (p + p.yzx)*.7071;\n        //return max(max(p.x, p.y), p.z); // Can't remember -- Diamond related. :)\n\n\n        return max(max(p.x, p.y), p.z); // Cube.\n        //return (p.x + p.y + p.z)*.5;//.57735; // Octahedron.\n        \n        \n        //p = (p - p.yzx);\n        //p = abs(p) - b;\n        //return max(max(p.x, p.y), p.z);\n        \n        \n        // Mixtures.\n        //return mix(max(max(p.x, p.y), p.z), length(p), .15);\n\n        //p = p*.8660254 + p.yzx*.5;\n        //return max(max(p.x, p.y), p.z); // Hex.\n/*\n        p = abs(p) - b;\n        float taper = (p.x + p.y + p.z)/3.*2.*.65 + .35; // Linear gradient of sorts.\n        //float taper = p.y + .5; // Original.\n        //taper = mix(taper, max(taper, .5), .35); // Flattening the sharp edge a bit.\n\n        p = abs(p)*2.;\n        //p = vec2(abs(p.x)*1.5, (p.y)*1.5 - .25)*2.; // Used with triangle.\n\n        float shape = max(max(p.x, p.y), p.z); // Square.\n        //float shape = max(p.x*.866025 - p.y*.5, p.y); // Triangle.\n        //float shape = max(p.x*.866025 + p.y*.5, p.y); // Hexagon.\n        //float shape = max(max(p.x, p.y), (p.x + p.y)*.7071); // Octagon.\n        //float shape = length(p); // Circle.\n        //float shape = dot(p, p); // Circle squared.\n\n\n        //shape = (shape - .125)/(1. - .125);\n        //shape = smoothstep(0., 1., shape);\n\n\n        //return shape;\n        return max(shape, taper);\n        */\n\n    }\n    \n}\n\nvec3 vIP;\n\n// 2D 3rd-order Voronoi: This is just a rehash of Fabrice Neyret's version, which is in\n// turn based on IQ's original. I've simplified it slightly, and tidied up the \"if\" statements.\n//\nvec3 Voronoi(in vec3 q, in vec3 sc, in vec3 rotF, float offsF, int rowOff, int id){\n    \n    \n\t//const vec3 sc = vec3(1, 2, 1);\n    gSc /= sc;\n \tvec3 d = vec3(1e5); // 1.4, etc.\n    \n    float r;\n    \n    const int n = 3;\n    // Widen or tighten the grid coverage, depending on the situation. Note the large \n    // spread. That's to cover the third order distances. In a lot of cases, (3x3x3) is enough,\n    // but in some, 729 taps (9x9x9), or even more, might be necessary.\n    //\n    // Either way, this is fine for static imagery, but needs to be reined in for realtime use.\n    for(int z = -n; z <= n; z++){ \n        for(int y = -n; y <= n; y++){ \n            for(int x =-n; x <= n; x++){\n\n                vec3 cntr = vec3(x, y, z) - floor(float(n)/2. + .001);\n                vec3 p = q;\n    \n                if(rowOff == 1){\n                    // Alternate 3D row offset -- Due to the cube's construction,\n                    // only one slice at a time will work... There might be a more\n                    // interesting way to shuffle things, but this'll do.\n                    if(mod(floor(p.z/sc.x - cntr.z), 2.)>.5){\n                        if(mod(floor(p.x/sc.x - cntr.x), 2.)<.5) p.y += sc.y/2.;\n                    }\n                    else if(mod(floor(p.y/sc.y - cntr.y), 2.)<.5) p.x += sc.x/2.;\n                }\n                \n                 \n\t\t\t\tvec3 ip = floor(p/sc - cntr) + .5; \n                p -= (ip)*sc;\n                //ip += cntr;\n                \n                // Random position and rotation vectors.\n                vec3 rndP = hash33(ip);\n                vec3 rndR = hash33(ip + 3.)*6.2831*rotF;\n\n                // Rotate.\n                p = rot(rndR)*p;\n                //p.xy *= rot2(rndR.x);\n                //p.yz *= rot2(rndR.y);\n                //p.zx *= rot2(rndR.z);\n               \n               \n                //rndP = floor(rndP*16.)/16.;\n                // Postional offset.\n                p -= rndP*offsF*sc;\n                \n                \n                // Scale -- Redundant here.\n\t\t\t\tvec3 b = sc/2.*vec3(1, 1, 1);//*(hash33(ip)*.5 + .5);\n                // Distance metric.\n                r = distMetric(p, b, id);\n                \n                if(r<d.x) vIP = ip;\n\n                // 1st, 2nd and 3rd nearest distance metrics.\n                d.z = max(d.x, max(d.y, min(d.z, r))); // 3rd.\n                d.y = max(d.x, min(d.y, r)); // 2nd.\n                d.x = min(d.x, r);//smin(d.x, r, .2); // Closest.\n                \n                // Redundant break in an attempt to ensure no unrolling.\n                // No idea whether it works or not.\n                if(d.x>1e5) break; \n\n            }\n        }\n    }\n\n    \n    return d;//min(d, 1.);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}