{
    "Shader": {
        "info": {
            "date": "1377741096",
            "description": "Random linear IFS fractal (4 affine transforms) inverted and twisted. Very noisy due to the low iteration count (rendering approach is brute force gathering). Some more info: [url]https://iquilezles.org/articles/ifsfractals/ifsfractals.htm[/url]",
            "flags": 32,
            "hasliked": 0,
            "id": "4dXGWS",
            "likes": 62,
            "name": "IFS - random",
            "published": 3,
            "tags": [
                "2d",
                "fractal",
                "ifs"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 5102
        },
        "renderpass": [
            {
                "code": "// Created by inigo quilez - iq/2013\n// I share this piece (art and code) here in Shadertoy and through its Public API, only for educational purposes. \n// You cannot use, sell, share or host this piece or modifications of it as part of your own commercial or non-commercial product, website or project.\n// You can share a link to it or an unmodified screenshot of it provided you attribute \"by Inigo Quilez, @iquilezles and iquilezles.org\". \n// If you are a teacher, lecturer, educator or similar and these conditions are too restrictive for your needs, please contact me and we'll work it out.\n\n// Random linear IFS fractal (4 affine transforms) inverted and\n// twisted. Very noisy due to the low iteration count (rendering\n// approach is brute force gathering).\n//\n// Some more information:\n// https://iquilezles.org/articles/ifsfractals/ifsfractals.htm\n//\n// Because WebGL cannot scatter data to a buffer, a gather approach\n// is used to colorize the pixels, which is millions of times slower\n// than it should. Because of that only a very few iterations are\n// performed, and the image is very noisy. So I used a temporal\n// accumulation trick to smooth the image out,but that introduces\n// blurring. You cannot have it all, not until we have scatter\n// operations in WebGL, that is.\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float r = texelFetch( iChannel0, ivec2(fragCoord), 0 ).w;\n    \n    float lod = pow(1.0-r,4.0)*5.0;\n    \n    vec3 col = textureLod( iChannel0, fragCoord/iResolution.xy, lod ).xyz;\n    \n    col *= 4.0/(1.0+4.0*col);\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by inigo quilez - iq/2013\n// I share this piece (art and code) here in Shadertoy and through its Public API, only for educational purposes. \n// You cannot use, sell, share or host this piece or modifications of it as part of your own commercial or non-commercial product, website or project.\n// You can share a link to it or an unmodified screenshot of it provided you attribute \"by Inigo Quilez, @iquilezles and iquilezles.org\". \n// If you are a teacher, lecturer, educator or similar and these conditions are too restrictive for your needs, please contact me and we'll work it out.\n\n\n// Random linear IFS fractal (4 affine transforms) inverted and\n// twisted. Very noisy due to the low iteration count (rendering\n// approach is brute force gathering).\n//\n// Some more information:\n// https://iquilezles.org/articles/ifsfractals/ifsfractals.htm[/url]\n//\n// Because WebGL cannot scatter data to a buffer, a gather approach\n// is used to colorize the pixels, which is millions of times slower\n// than it should. Because of that only a very few iterations are\n// performed, and the image is very noisy. So I used a temporal\n// accumulation trick to smooth the image out,but that introduces\n// blurring. You cannot have it all, not until we have scatter\n// operations in WebGL, that is.\n\n\n// oldschool rand() from Visual Studio\nint   seed = 1;\nvoid  srand(int s ) { seed = s; }\nint   rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\n// hash to initialize the random sequence (copied from Hugo Elias)\nint   hash( int n ) { n=(n<<13)^n; return n*(n*n*15731+789221)+1376312589; }\n\n// ensure determinant is less than 0.4\nmat3x2 fixDet( in mat3x2 m, out float w )\n{\n    mat2x2 r = mat2x2( m[0][0], m[0][1], m[1][0], m[1][1] );\n    w = abs(determinant(r));\n    if( w>0.4 )\n    {\n        float s = 0.4/w;\n        w *= s;\n        m[0][0] = r[0][0]*s;\n        m[0][1] = r[0][1]*s;\n        m[1][0] = r[1][0]*s;\n        m[1][1] = r[1][1]*s;\n    }\n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // init randoms\n    ivec2 q = ivec2(fragCoord);\n    srand( hash(q.x+hash(q.y+hash(iFrame))) );\n\n    // create ifs\n\tfloat t = 0.02*iTime;\n\n\tmat3x2 am = mat3x2( cos(t*1.71+0.18), cos(t*1.11+5.31), \n                        cos(t*1.31+3.18), cos(t*1.44+4.21),\n                        cos(-t*2.13+0.94), cos(-t*1.19+0.29) );\n                      \n\tmat3x2 bm = mat3x2( cos(-t*2.57+1.66), cos(t*1.08+0.74), \n                        cos(t*1.31+4.51), cos(t*1.23+1.29),\n                        cos(t*1.09+5.25), cos(t*1.27+1.77) );\n                        \n\tmat3x2 cm = mat3x2( cos(t*1.75+0.33), cos(t*1.74+5.12), \n                        cos(t*2.94+1.92), cos(t*2.58+2.36),\n                        cos(t*2.76+2.39), cos(t*2.35+2.04) );\n                        \n\tmat3x2 dm = mat3x2( cos(t*1.42+4.89), cos(t*1.14+1.94),\n                        cos(t*2.73+6.34), cos(-t*1.21+4.84),\n                        cos(-t*1.42+4.71), cos(t*2.81+3.51) );\n\n    // ensure all transformations are contracting, by checking\n    // the determinant and inverting the top 2x2 matrix if it\n    // is less than 1\n    \n    float ad, bd, cd, dd;\n    am = fixDet(am, ad);\n    bm = fixDet(bm, bd);\n    cm = fixDet(cm, cd);\n    dm = fixDet(dm, dd);\n\n    // compute probability for each transformation\n    float wa = (ad         ) / (ad+bd+cd+dd);\n    float wb = (ad+bd      ) / (ad+bd+cd+dd);\n    float wc = (ad+bd+cd   ) / (ad+bd+cd+dd);\n    float wd = (ad+bd+cd+dd) / (ad+bd+cd+dd);\n\n    // render ifs\n    float zoom = 0.5+0.5*sin(iTime*0.1);\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\tuv *= 3.0*exp2(-zoom);\n\n\n\tvec3  cola = vec3(0.0);\n\tvec3  colb = vec3(0.0);\n    float colw = 0.0;\n\tfloat cad = 0.0;\n\n    vec2 z = vec2( 0.0 );\n\tconst int num = 1024;\n\tfor( int i=0; i<num; i++ ) \n    {\n\t\tfloat p = frand();\n\n        // affine transform\n        cad *= 0.25;\n             if( p < wa ) { z = am*vec3(z,1.0); cad += 0.00; }\n        else if( p < wb ) { z = bm*vec3(z,1.0); cad += 0.25; }\n        else if( p < wc ) { z = cm*vec3(z,1.0); cad += 0.50; }\n        else              { z = dm*vec3(z,1.0); cad += 0.75; }\n\n        // non linear transform\n        float an = length(z)*0.25;\n        vec2 c = vec2( cos(an), sin(an) );\n        z = 2.0*mat2(c.x,c.y,-c.y,c.x)*z/dot(z,z);\n\n        // splat into screen\n        if( i>10 )\n\t\t{\n        vec3  co = 0.5 + 0.5*sin(1.5*cad + vec3(0.5,2.0,2.0)+2.0);\n        co.z += co.y*(1.0*sin(cad*3.0+3.0));\n        co = clamp(co,0.0,1.0);\n    \n        float d2 = dot(uv-z,uv-z)*4.0;\n        cola += co*exp2( -8192.0*d2 );\n        colb += co*exp2(  -128.0*d2 );\n        colw += exp2( -256.0*d2 );\n\t\t}\n\t}\n    cola/=float(num);\n    colb/=float(num);\n    colw/=float(num);\n    \n    // color\n    cola = 256.0*sqrt(cola);\n    colb =   2.0*sqrt(colb);\n    colw = 64.0*sqrt(colw);\n    vec3 col = cola + colb;\n    \n    // auto-gain\n    col *= 3.0/(1.0+col);\n    col = clamp(col,0.0,1.0);\n    colw = clamp(colw,0.0,1.0);\n   \n    vec4 old = texelFetch( iChannel0, ivec2(fragCoord), 0 );\n\n\tfragColor = mix( old, vec4(col,colw), 0.1 );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}