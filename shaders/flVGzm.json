{
    "Shader": {
        "info": {
            "date": "1637395168",
            "description": "Pythagorean Square Tiling 2: Electric Boogaloo\nA much simpler implementation, using two grids and computing the tile ID first",
            "flags": 0,
            "hasliked": 0,
            "id": "flVGzm",
            "likes": 33,
            "name": "Pythagorean Square Tiling 2",
            "published": 3,
            "tags": [
                "square",
                "tiling",
                "pythagorean"
            ],
            "usePreview": 0,
            "username": "gelami",
            "viewed": 687
        },
        "renderpass": [
            {
                "code": "\n// Pythagorean Square Tiling 2\n// https://www.shadertoy.com/view/flVGzm\n\n/*\n * The previous version was too large and messy for my liking,\n * then I realized using two grids of squares would be much easier to implement\n * I computed the tile ID first instead of the UV, which simplifies a lot of things\n * Then the UV is derived from the ID instead.\n */\n\n// Defines\n\n//#define SHOW_UV\n//#define SHOW_ID\n//#define ALT_ID\n\n//#define ALT_ROTATE\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // Angle of rotation\n    float a = mod(iTime * 0.8, TAU);\n    // Mod 2 of the quadrant of the angle\n    float q = mod(round(a / (TAU / 4.)), 2.);\n    \n    vec2 p = uv * 2.;\n    \n    #ifndef ALT_ROTATE\n    p *= rot2D(a);\n    #endif\n    \n    // First grid\n    vec2 p1 = fract(p) - 0.5;\n    // Get sign before inverse rotation\n    vec2 sp = sign(p1);\n    \n    // Second grid\n    vec2 p2 = (abs(p1) - 0.5) * sp;\n    \n    // Initial tile ID\n    vec2 id = (p - p1) * 2.;\n    \n    p1 *= rot2D(-a);\n    p2 *= rot2D(-a);\n    \n    // Sign after rotation\n    vec2 sp2 = sign(p1);\n    \n    // Size of the squares\n    vec2 s = abs(vec2(cos(a), sin(a))) * 0.5;\n    \n    // Distance to the two square grids + outside mask\n    vec3 d1 = sdBox(p1, s.x);\n    vec3 d2 = sdBox(p2, s.y);\n    \n    // Mask of which square is which\n    float m = q > 0.5 ? step(0., d1.x) : step(d2.x, 0.);\n    \n    // Tile ID stuff\n    // There probably a simpler way to do this\n    //   S1 = -1 |  1 | -1 |  1 |  1 | -1 |  1 | -1 |\n    // * S2 = -1 | -1 |  1 |  1 | -1 | -1 |  1 |  1 |\n    // ----------------------------------------------\n    //   SS =  1 | -1 | -1 |  1 | -1 |  1 |  1 | -1 |\n    float s1 = mod(ceil(abs((a - PI) / (PI / 4.))), 2.) * 2. - 1.;\n    float s2 = q * 2. - 1.;\n    float ss = s1 * s2 * 2.;\n    \n    id += sp * m;\n    \n    // Diagonals mask\n    float m2 = sat(sign(d1.x) + sign(d2.x));\n    \n    id += d1.yz * sp2 * ss * m2;\n    \n    // Alternative ID\n    #ifdef ALT_ID\n    id = floor(vec2(id.x + id.y, id.y - id.x) - m + .001);\n    #endif\n    \n    // Square size\n    float size = m < 0.5 ? s.x : s.y;\n    \n    // Get the square's coords from the tile ID\n    vec2 puv = (p-id*0.5) / size * rot2D(-a) * 0.5;\n    \n    // Distance inside square\n    vec2 dp = (0.5 - abs(puv)) * size;\n    float d = smin(dp.x, dp.y, .05);\n    \n    vec3 tex = texture(iChannel0, puv).rgb;\n    \n    float px = 1.0 / iResolution.y;\n    vec3 col = vec3(palette(hash12(id))) * smoothstep(1.0 * px, 6.0 * px, d);\n    \n    col *= tex;\n    \n    #ifdef SHOW_UV\n    col = vec3(puv + 0.5, 0);\n    #endif\n    #ifdef SHOW_ID\n    col = vec3(id, 0);\n    #endif\n    \n    // Exposure and tonemapping\n    col *= 2.;\n    col = max(col, vec3(0));\n    col = col / (1. + col);\n    // Gamma correction\n    col = pow(col, vec3(1./2.2));\n    \n    fragColor = vec4(col, 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define PI (acos(-1.))\n#define TAU (2.*PI)\n\n#define sat(x) clamp(x, 0., 1.)\n\nmat2 rot2D(float a)\n{\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\n// Cubic smin function\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max(k - abs(a - b), 0.0 ) / k;\n    return min(a, b) - h*h*h*k * (1.0 / 6.0);\n}\n\n// Chebyshev distance to box + outside mask \nvec3 sdBox( in vec2 p, in float b )\n{\n    vec2 d = abs(p)-b;\n    return vec3( max(d.x, d.y), step(vec2(0), d) );\n}\n\n// Cosine Color Palette\n// https://iquilezles.org/articles/palettes\nvec3 palette( float t )\n{\n    return 0.5 + 0.5*cos( TAU * (1. * t + vec3(.3, .2, .2)) );\n}\n\n\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n    p = p * 1.1213;\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}