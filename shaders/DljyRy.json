{
    "Shader": {
        "info": {
            "date": "1691940408",
            "description": "The Ising Model is a simple model of magnetic materials in which each cell (corresponding to an atom or molecule) has a value of either plus or minus 1, for the direction in which its magnetic field points.",
            "flags": 32,
            "hasliked": 0,
            "id": "DljyRy",
            "likes": 28,
            "name": "3D Ising Model",
            "published": 3,
            "tags": [
                "raymarching",
                "simulation",
                "volumetric",
                "cubemap",
                "physics",
                "cubemapa"
            ],
            "usePreview": 0,
            "username": "thepinkpanzer",
            "viewed": 395
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    vec4 bloom = texture(iChannel1, uv);\n    vec4 raw   = texture(iChannel0, uv);\n    fragColor  = tanh(0.9*bloom + 0.9*raw);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    int  dataPage;\n    vec3 worldPos = WorldPosFromCube(fragCoord, rayDir, dataPage);\n    if (dataPage == 1)\n    {\n        float currentSpin  = texture(iChannel0, rayDir).r;\n        float neighbourSum = texture(iChannel0, CubeFromWorldPos((worldPos+vec3( 1, 0, 0)), dataPage)).r\n                            +texture(iChannel0, CubeFromWorldPos((worldPos+vec3(-1, 0, 0)), dataPage)).r\n                            +texture(iChannel0, CubeFromWorldPos((worldPos+vec3( 0, 1, 0)), dataPage)).r\n                            +texture(iChannel0, CubeFromWorldPos((worldPos+vec3( 0,-1, 0)), dataPage)).r\n                            +texture(iChannel0, CubeFromWorldPos((worldPos+vec3( 0, 0, 1)), dataPage)).r\n                            +texture(iChannel0, CubeFromWorldPos((worldPos+vec3( 0, 0,-1)), dataPage)).r;\n        float energy       = J*neighbourSum*currentSpin + H*currentSpin;\n        float energy_flip  = 2.*energy;\n        float energy_rand  = Random(length(worldPos/54.12345 + vec3(1.65546, 0.654323, 0.73243)) + fract(iTime/13.));\n        float flip_rand    = Random(energy_rand);\n        if      (iFrame <= 5)\n        {\n            currentSpin  = sign(flip_rand*2.-1.);\n            if (Random(abs(flip_rand*2.-1.)) < IMPURITYDENSITY)\n            {\n                currentSpin = 0.;\n            }\n        }\n        else if ((exp(-max(0.,energy_flip/T)) > energy_rand) && (flip_rand < DT))\n        {\n            currentSpin *= -1.;\n        }\n        fragColor = vec4(vec3(currentSpin), neighbourSum*currentSpin);\n    }\n    else\n    {\n        fragColor = vec4(1,0,1,0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            },
            {
                "code": "// MARCHING\n#define STEPDIST    1./128.\n#define NUMSTEPS    100\n// BLOOM\n#define BLOOMRADIUS 30.\n#define BLOOMLOD 2.\n// COLORS AND LIGHTING\n#define ABSORPTIVITY 24.\n#define HAZE         0.02\n#define RED   vec4(0.1, 0.5, 1., 0.)\n#define BLUE  vec4( 1., 0.5,0.1, 0.)\n#define WHITE vec4( 1.,  1., 1., 0.)*160.\n// SIMULATION PARAMETERS\n// External field\n#define H  0.\n// Temperature (periodic flashing)\n#define T  (fract(iTime/20.) < 0.05 ? 10. : 2.)\n// Inter-atom alignment strength\n#define J  1.\n// Timestep per frame\n#define DT 0.2\n// Number of cells set to 0 (instead of Â±1)\n#define IMPURITYDENSITY 0.\n\nvec3 WorldPosFromCube(vec2 fragCoord, vec3 rayDir, out int dataPage)\n{\n    /*\n    Function to be used (primarily) in Cube A. Converts the fragCoord and ray direction\n    into world position, while storing the Data Page on the side.\n    \n    Note that while the cubemap has 6 faces, there are only 3 data pages as two faces\n    are required to fill out the 128x128x128 cube.\n    */\n    vec3 ard = abs(rayDir);\n    float m  = max(ard.x, max(ard.y, ard.z));\n    int bigCoord = int(fragCoord.x) + 1024*int(fragCoord.y);\n    if      (m ==  rayDir.x)\n    {\n        dataPage = 1;\n    }\n    else if (m ==  rayDir.y)\n    {\n        dataPage = 2;\n    }\n    else if (m ==  rayDir.z)\n    {\n        dataPage = 3;\n    }\n    else if (m == -rayDir.x)\n    {\n        dataPage = 1;\n        bigCoord+= 1024*1024;\n    }\n    else if (m == -rayDir.y)\n    {\n        dataPage = 2;\n        bigCoord+= 1024*1024;\n    }\n    else if (m == -rayDir.z)\n    {\n        dataPage = 3;\n        bigCoord+= 1024*1024;\n    }\n    int x = (bigCoord        )%128;\n    int y = (bigCoord/128    )%128;\n    int z = (bigCoord/128/128)%128; // % is unnecessary but why not\n    return (vec3(x,y,z));\n}\nvec3 RoundWorldPos(vec3 worldPos)\n{\n    worldPos += 0.5;\n    worldPos *= 128.;\n    worldPos  = floor(worldPos);\n    return worldPos;\n}\nvec3 CubeFromWorldPos(vec3 worldPos, int dataPage)\n{\n    /*\n    The inverse of WorldPosFromCube (well, kind of). Converts world position into the\n    ray direction needed to read that voxel (on that Data Page). Not exactly the inverse \n    of WorldPosFromCube in that WPFC uses the frag coords as primary input, while CFWP\n    spits out the ray direction.\n    \n    Note: worldPos is the **ROUNDED** world position.\n    */\n    worldPos = mod(worldPos, 128.);\n    worldPos = floor(worldPos);\n    if (worldPos.x > 127. || worldPos.y > 127. || worldPos.z > 127.\n     || worldPos.x < 0.   || worldPos.y < 0.   || worldPos.z < 0.  )\n    {\n        return vec3(0);\n    }\n    else\n    {\n        int bigCoord = ((int(worldPos.z)*128+int(worldPos.y))*128+int(worldPos.x));\n        bigCoord -= int(worldPos.z+1.) > 64 ?   1024*1024 : 0;\n        dataPage += int(worldPos.z+1.) > 64 ?           3 : 0;\n        dataPage -= 1;\n        vec3 rgVex[6] = vec3[6](vec3( 0, 0,-1),vec3( 1, 0, 0),vec3( 1, 0, 0),vec3( 0, 0, 1),vec3( 1, 0, 0),vec3(-1, 0, 0));\n        vec3 upVex[6] = vec3[6](vec3( 0,-1, 0),vec3( 0, 0, 1),vec3( 0,-1, 0),vec3( 0,-1, 0),vec3( 0, 0,-1),vec3( 0,-1, 0));\n        vec3 fwVex[6] = vec3[6](vec3( 1, 0, 0),vec3( 0, 1, 0),vec3( 0, 0, 1),vec3(-1, 0, 0),vec3( 0,-1, 0),vec3( 0, 0,-1));\n        vec2 uvs      = (vec2(bigCoord % 1024, (bigCoord/1024)%1024) + 0.5)/1024.;\n        uvs           = 2.*uvs - 1.;\n        vec3 rayDir   = (rgVex[dataPage]*uvs.x + upVex[dataPage]*uvs.y);\n        rayDir       += (fwVex[dataPage]);\n        return normalize(rayDir);\n    }\n}\nfloat Random(float seed)\n{\n    seed = fract(seed*(104.643 - seed) + 6.2341);\n    seed = fract(seed*( 42.123 - seed) + 2.8583);\n    seed = fract(seed*( 36.131 - seed) + 1.6235);\n    return seed;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define PI      3.1415926\n#define ROTFREQ 0.06\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 mouse  = (iMouse.xy == vec2(0) ? vec4(iResolution.x*(iTime*ROTFREQ), iResolution.y*0.3, 1., 0) : iMouse);\n    float theta = (mouse.x - iResolution.x / 2.) / iResolution.y * PI;\n    float phi   = (mouse.y - iResolution.y / 2.) / iResolution.y * PI*0.55;\n\n    // CAMERA\n    vec3 iCameraFwd     = vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));\n    vec3 iCameraUp      = vec3(-sin(theta)*sin(phi),cos(phi),-cos(theta)*sin(phi));\n    vec3 iCameraRight   = normalize(cross(iCameraUp, iCameraFwd));\n    \n    vec3 iCameraPosition      = -2.*iCameraFwd;\n    \n    float m = 1.2;\n    \n    // Anti-aliasing by randomly jittering the pixel\n    fragCoord += vec2(Random(fract(iTime) + dot(fragCoord, vec2(0.123, 0.215))), Random(fract(iTime) + dot(fragCoord, vec2(.053, 0.253))));\n    vec3 iViewDirection = iCameraFwd + ((fragCoord.x - iResolution.x/2.0) * iCameraRight + (fragCoord.y - iResolution.y/2.0) * iCameraUp) / iResolution.x * m;\n    iViewDirection      = normalize(iViewDirection);\n    \n    // SORTING FACES\n    float distXP =  (0.5-iCameraPosition.x)/iViewDirection.x;\n    float distYP =  (0.5-iCameraPosition.y)/iViewDirection.y;\n    float distZP =  (0.5-iCameraPosition.z)/iViewDirection.z;\n    \n    float distXM = (-0.5-iCameraPosition.x)/iViewDirection.x;\n    float distYM = (-0.5-iCameraPosition.y)/iViewDirection.y;\n    float distZM = (-0.5-iCameraPosition.z)/iViewDirection.z;\n    \n    vec3 faceList[6] = vec3[6]( vec3( 1,0,0), vec3(0, 1,0), vec3(0,0, 1),\n                                vec3(-1,0,0), vec3(0,-1,0), vec3(0,0,-1));\n\n    float distList[6] = float[6]( distXP, distYP, distZP,\n                                  distXM, distYM, distZM);\n    \n    for (int n = 0; n < 5; n++)\n    {\n        for (int i = 0; i < 5; i++)\n        {\n            if (distList[i] > distList[i+1])\n            {\n                vec3 c        = faceList[i];\n                faceList[i]   = faceList[i+1];\n                faceList[i+1] = c;\n                \n                float r       = distList[i];\n                distList[i]   = distList[i+1];\n                distList[i+1] = r;\n            }\n        }\n    }\n    \n    // MARCH!\n    fragColor   = vec4(0);\n    vec4 absorb = vec4(1);\n    if (length(faceList[0]+faceList[1]+faceList[2]) >= sqrt(3.))\n    {\n        vec3 pos = iCameraPosition + distList[2]*iViewDirection;\n        vec3 dir = refract(iViewDirection, faceList[2], 0.7);\n        for (int n = 0; n < NUMSTEPS; n++)\n        {\n            vec3 samplePos = pos + dir*STEPDIST*Random(pos.x + fract(iTime/13.));\n            vec4 sampleVal = texture(iChannel0, CubeFromWorldPos(RoundWorldPos(samplePos), 1));\n            vec4 color     = sampleVal.r > 0. ? RED : BLUE;\n            vec4 glow      = ((J > 0. ? (0.5 - sampleVal.a/12.) : (sampleVal.a/12. + 0.5))*WHITE + HAZE*ABSORPTIVITY)*STEPDIST;\n            absorb        *= exp(-color*ABSORPTIVITY*STEPDIST);\n            fragColor     += glow*absorb;\n            pos           += dir*STEPDIST;\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    for (float x = -BLOOMRADIUS; x < BLOOMRADIUS+1.; x++)\n    {\n        fragColor += exp(-(4.*x*x)/(BLOOMRADIUS*BLOOMRADIUS))*textureLod(iChannel0, (fragCoord + vec2(1,0)*(x*BLOOMLOD))/iResolution.xy, (BLOOMLOD));\n    }\n    fragColor /= BLOOMRADIUS;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    for (float x = -BLOOMRADIUS; x < BLOOMRADIUS+1.; x++)\n    {\n        fragColor += exp(-(4.*x*x)/(BLOOMRADIUS*BLOOMRADIUS))*textureLod(iChannel0, (fragCoord + vec2(0,1)*(x*BLOOMLOD))/iResolution.xy, (BLOOMLOD));\n    }\n    fragColor /= BLOOMRADIUS;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}