{
    "Shader": {
        "info": {
            "date": "1465088561",
            "description": "i'd call this my glsl firstie.\ncheck this out to see where part of the idea came from: https://www.gottz.de/analoguhr.htm\n\ni'm really new to glsl so please leave some usefull and aspiring comments",
            "flags": 0,
            "hasliked": 0,
            "id": "XdKXzy",
            "likes": 19,
            "name": "2d analog clock [wip]",
            "published": 3,
            "tags": [
                "2d",
                "time",
                "lines",
                "clock"
            ],
            "usePreview": 0,
            "username": "GottZ",
            "viewed": 1670
        },
        "renderpass": [
            {
                "code": "// this is my first try to actually use glsl almost from scratch\n// so far all i've done is learning by doing / reading glsl docs.\n// this is inspired by my non glsl â€žtimeâ€œ projects\n// especially this one: https://www.gottz.de/analoguhr.htm\n\n// i will most likely use a buffer in future to calculate the time\n// aswell as to draw the background of the clock only once.\n// tell me if thats a bad idea.\n\n// update:\n// screenshot: http://i.imgur.com/dF0nHDk.png\n// as soon as i think its in a usefull state i'll release the source\n// of that particular c++ application on github.\n// i hope sommeone might find it usefull :D\n\n#define PI 3.141592653589793238462643383\n\n// from https://www.shadertoy.com/view/4s3XDn <3\nfloat ln(vec2 p, vec2 a, vec2 b)\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\n// i think i should spend some time reading docs in order to minimize this.\n// hints apreciated\n// (Rotated LiNe)\nfloat rln(vec2 uv, float start, float end, float perc) {\n    float inp = perc * PI * 2.0;\n\tvec2 coord = vec2(sin(inp), cos(inp));\n    return ln(uv, coord * start, coord * end);\n}\n\n// i need this to have an alphachannel in the output\n// i intend to use an optimized version of this shader for a transparent desktop widget experiment\nvec4 mixer(vec4 c1, vec4 c2) {\n    // please tell me if you think this would boost performance.\n    // the time i implemented mix myself it sure did reduce\n    // the amount of operations but i'm not sure now\n    // if (c2.a <= 0.0) return c1;\n    // if (c2.a >= 1.0) return c2;\n    return vec4(mix(c1.rgb, c2.rgb, c2.a), c1.a + c2.a);\n    // in case you are curious how you could implement mix yourself:\n    // return vec4(c2.rgb * c2.a + c1.rgb * (1.0-c2.a), c1.a+c2.a);\n}\n    \nvec4 styleHandle(vec4 color, float px, float dist, vec3 handleColor, float width, float shadow) {\n    if (dist <= width + shadow) {\n        // lets draw the shadow\n        color = mixer(color, vec4(0.0, 0.0, 0.0,\n                                (1.0-pow(smoothstep(width, width + shadow, dist),0.2))*0.2));\n        // now lets draw the antialiased handle\n        color = mixer(color, vec4(handleColor, smoothstep(width, max(width - 3.0 * px, 0.0), dist)));\n    }\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 R = iResolution.xy;\n    // calculate the size of a pixel\n    float px = 1.0 / R.y;\n    // create percentages of the coordinate system\n    vec2 p = fragCoord.xy / R;\n    // center the scene and add perspective\n    vec2 uv = (2.0 * fragCoord - R) / min(R.x, R.y);\n    \n    /*vec2 uv = -1.0 + 2.0 * p.xy;\n    // lets add perspective for mobile device support\n    if (iResolution.x > iResolution.y)\n    \tuv.x *= iResolution.x / iResolution.y;\n    else\n        uv.y *= iResolution.y / iResolution.x;*/\n    \n    // lets scale the scene a bit down:\n    uv *= 1.1;\n    px *= 0.9;\n    \n    float width = 0.015;\n    float dist = 1.0;\n    float centerdist = length(uv);\n    \n    // static background to emulate the effect of the shaders alpha output channel\n    vec4 color = vec4(p,mix(1.0-p.x,0.0,p.y),1.0);\n    float lines = abs(fract((uv.x*0.5-uv.y+fract(iDate.w*0.02))*5.0) -0.5);\n    color.rgb *= smoothstep(0.2, 0.3, lines) * 0.03 + 0.6;\n    //color.rgb *= mod(uv.x-uv.y/*+fract(iDate.w*0.02)*/, 0.2) < 0.1 ? 0.5 : 0.48;\n    \n    // background of the clock\n    if (centerdist < 1.0 - width) color = mixer(color, vec4(vec3(0.5), 0.4*(1.8-length(uv))));\n    \n    float isRed = 1.0;\n \n    if (centerdist > 1.0 - 12.0 * width && centerdist <= 1.1) {\n        // minute bars\n        for (float i = 0.0; i <= 15.0; i += 1.0) {\n            if (mod(i, 5.0) == 0.0) {\n                dist = min(dist, rln(abs(uv), 1.0 - 10.0 * width, 1.0 - 2.0 * width, i / 60.0));\n                // draw first bar red\n                if (i == 0.0 && uv.y > 0.0) {\n                    isRed = dist;\n                    dist = smoothstep(width, max(width - 3.0 * px, 0.0), dist);\n                    color = mixer(color, vec4(1.0, 0.0, 0.0, dist));\n                    dist = 1.0;\n                }\n            }\n            else {\n                dist = min(dist, rln(abs(uv), 1.0 - 10.0 * width, 1.0 - 7.0 * width, i / 60.0));\n            }\n        }\n\n        // outline circle\n        dist = min(dist, abs(1.0-width-length(uv)));\n        // draw clock shadow\n        if (centerdist > 1.0)\n            color = mixer(color, vec4(0.0,0.0,0.0, 0.3*smoothstep(1.0 + width*2.0, 1.0, centerdist)));\n\n        // draw outline + minute bars in white\n\t\tcolor = mixer(color, vec4(0.0, 0.0, 0.0,\n\t\t\t(1.0 - pow(smoothstep(width, width + 0.02, min(isRed, dist)), 0.4))*0.2));\n\t\tcolor = mixer(color, vec4(vec3(1.0), smoothstep(width, max(width - 3.0 * px, 0.0), dist)));\n    }\n    \n    if (centerdist < 1.0) {\n        float time = (floor(iDate.w)+pow(fract(iDate.w),16.0));\n\n        // hour\n        color = styleHandle(color, px,\n                            rln(uv, -0.05, 0.5, time / 3600.0 / 12.0),\n                            vec3(1.0), 0.03, 0.02);\n\n        // minute\n        color = styleHandle(color, px,\n                            rln(uv, -0.075, 0.7, time / 3600.0),\n                            vec3(1.0), 0.02, 0.02);\n\n        // second\n        color = styleHandle(color, px,\n                            min(rln(uv, -0.1, 0.9, time / 60.0), length(uv)-0.01),\n                            vec3(1.0, 0.0, 0.0), 0.01, 0.02);\n    }\n    \n    \n    fragColor = color;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}