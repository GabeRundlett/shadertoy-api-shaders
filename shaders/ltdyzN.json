{
    "Shader": {
        "info": {
            "date": "1532070971",
            "description": "The first half of [url=http://hz.imslp.info/files/imglnks/usimg/2/2b/IMSLP20269-PMLP04611-Pachelbel_-_Kanon_und_Gigue.pdf]Pachelbel's Canon[/url]\n\nI redid the sequencing to (hopefully) avoid the compilation problems the last version had",
            "flags": 8,
            "hasliked": 0,
            "id": "ltdyzN",
            "likes": 10,
            "name": "Music - Pachelbel",
            "published": 3,
            "tags": [
                "sound",
                "music",
                "synthesis",
                "canon"
            ],
            "usePreview": 0,
            "username": "davidar",
            "viewed": 610
        },
        "renderpass": [
            {
                "code": "#define EPS 0.001\n\nfloat draw(float y, vec3 r, vec3 reps) {\n    float z = mix(r.x, r.y, r.z);\n    float dz = (mix(reps.x, reps.y, reps.z) - z) / EPS;\n    if (distance(r.x, r.y) > 5.5) {\n        return (distance(y, r.x) < 0.5) ? 1. - r.z\n             : (distance(y, r.y) < 0.5) ? r.z : 0.;\n    } else if (distance(y, z) / sqrt(1. + pow(0.1*dz, 2.)) < 0.5) {\n        return (y > max(r.x, r.y) + 0.5 || y < min(r.x, r.y) - 0.5) ? 0. : 1.;\n    } else {\n        return 0.;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = vec4(0,0,0,1);\n    vec2 uv = fragCoord/iResolution.xy;\n    float y = 45. * uv.y;\n    float t = 0.75 * iTime + 8. * uv.x - 4.;\n    if (t < 0.) return;\n    \n    float f = 0.;\n    f += draw(y, canon(t, 1), canon(t + EPS, 1));\n    f += draw(y, canon(t, 2), canon(t + EPS, 2));\n    f += draw(y, canon(t, 3), canon(t + EPS, 3));\n    f += draw(y, ostinato(t), ostinato(t + EPS));\n    f *= smoothstep(135., 125., t);\n    f = clamp(f, 0., 1.);\n    fragColor = vec4(0.6 * f * (1. + cos(2.*PI * smoothstep(6., 41., y) + vec3(0,23,21))), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.14159265359\n\nconst int[] dmajor = int[]\n    (  6,  8, 10, 11, 13, 15, 17\n    , 18, 20, 22, 23, 25, 27, 29\n    , 30, 32, 34, 35, 37, 39, 41\n    );\n\nconst int[] variations = int[](1, 2, 4, 2, 8, 1);\n\nconst int[] melody_data = int[](\n    0x98765456,\n    0x76543231,\n    0x02432021,0x0e043543,\n    0x201679b4,0x53420776,\n    0x7670f412,0x076569bc,0xa98a9876,0x54321321,\n    0x01234143,0x25434321,0x0e567654,0x32154543,\n    0x29887899,0xccbbccdd,\n    0x27665577,0x77777a8b,\n    0xbb9abb9a,0xb456789a,0x99789923,0x45434234,0x33543321,0x21012345,0x33545567,0x456789ab,\n    0x99789987,0x86789876,0x77567701,0x23212767,0x55765543,0x43234567,0x55767765,0x67876756,\n    0x76570001,\n    0x44243238\n);\n\nint melody(int i) {\n    int x = melody_data[i/8];\n    int nibble = 7 - (i % 8);\n    int note = (x >> (4 * nibble)) & 0xf;\n    note = ((note + 2) % 16) + 5;\n    return dmajor[note];\n}\n\nvec3 canon(float t, int part) {\n    int prevnote = -1;\n    int currnote = -1;\n    float trans = 0.;\n    \n    int idx = 0;\n    for (int v = 0; v < variations.length(); v++) {\n        float vstart = float(8 * part + 16 * v);\n        int i = clamp(int((t - vstart) * float(variations[v])), 0, 16 * variations[v] - 1);\n        float start = vstart + float(i) / float(variations[v]);\n        if (t < start) break;\n        prevnote = (i == 0) ? currnote : melody(idx + i - 1);\n        currnote = melody(idx + i);\n        trans = smoothstep(start, start + 0.5 / float(variations[v]), t);\n        idx += 16 * variations[v];\n    }\n    \n    float start = float(8 * part + 16 * variations.length());\n    if (t >= start) {\n        prevnote = currnote;\n        currnote = -1;\n        trans = smoothstep(start, start + 1., t);\n    }\n    \n    return vec3(prevnote, currnote, trans);\n}\n\nint progression(int i) {\n    // http://openmusictheory.com/popRockHarmony-pachelbel.html\n    return dmajor[(i % 2 == 0) ? max(7 - i, 3) : (11 - i) % 6];\n}\n\nvec3 ostinato(float t) {\n    bool loop = t > 4.;\n    t = mod(t, 8.);\n    return vec3(\n        (t >= 1.) ? progression(int(t) - 1)\n           : loop ? progression(7) : -1,\n        progression(int(t)),\n        smoothstep(floor(t), floor(t) + 0.5, t)\n    );\n}\n\n\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nvec2 hash22(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define ITERATIONS 30\n#define PITCH_SHIFT -4.\n\nfloat time;\n\nfloat stretchsine(float x, float a) { // from ZynAddSubFX\n    x = fract(x + 0.5) * 2. - 1.;\n    a = (a - 0.5) * 4.;\n    if (a > 0.) a *= 2.;\n    a = pow(3., a);\n    float b = pow(abs(x), a);\n    if (x < 0.) b = -b;\n    return -sin(b * PI);\n}\n\nfloat stretchsine_rev(float t, float a, float p1, float p2, float p3) {\n    p1 = (pow(2., p1 * 5.) - 1.) / 10.;\n    p3 = floor(pow(2., p3 * 5.) - 1.);\n    if (p3 < 1.) p3 = -1.;\n    t = t * p3 + sin((t + p2) * 2. * PI) * p1;\n    t = t - floor(t);\n    return stretchsine(t, a);\n}\n\nfloat sing(float n) {\n    if (n <= 0.) return 0.;\n    n += PITCH_SHIFT;\n    float f = 0.;\n    for (int i = 0; i < ITERATIONS; i++) {\n        float freq = 440. * pow(2., (n + hash22(vec2(n,i)).x/2. - 49.) / 12.);\n        float power = pow(10., -n/115.) / float(ITERATIONS);\n        power *= clamp((n + 15.)/100., 0., 1.);\n        vec2 r = hash22(vec2(freq,i));\n        f += 0.2 * sqrt(power) * stretchsine_rev(\n            (freq + 0.01 * r.x) * time + r.y, 0.5, 0.32, 0.5, 0.53);\n    }\n    return f;\n}\n\nfloat mixsound(vec3 r) {\n    return mix(sing(r.x), sing(r.y), r.z);\n}\n\nvec2 mainSound( in int samp,float t) {\n    time = t;\n    t = 0.75 * t - 1.;\n    if (t < 0.) return vec2(0);\n    float f = 0.;\n    f += mixsound(canon(t, 1));\n    f += mixsound(canon(t, 2));\n    f += mixsound(canon(t, 3));\n    f += mixsound(ostinato(t));\n    f *= smoothstep(135., 125., t);\n    return vec2(f);\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}