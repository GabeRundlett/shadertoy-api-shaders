{
    "Shader": {
        "info": {
            "date": "1507836534",
            "description": "fork of:\nhttps://www.shadertoy.com/view/XtGXWV\n\nimproved but still has a lot of redundancy in it.",
            "flags": 0,
            "hasliked": 0,
            "id": "4lBcRm",
            "likes": 24,
            "name": " Atmospheric spherical",
            "published": 3,
            "tags": [
                "sphere",
                "planet",
                "scattering",
                "spherical",
                "rayleigh",
                "atmospherics",
                "mie",
                "polat"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 1585
        },
        "renderpass": [
            {
                "code": "//ad 3d atmospheric scattering\n//self  : https://www.shadertoy.com/view/4lBcRm\n//parent: https://www.shadertoy.com/view/XtGXWV\n//looks like its very cobbled together, i cleaned it up a but\n//but a lot of it is still redundant.\n\nvec3 lightPosition0 = vec3(1,0,0);\n\n//this atmospheric scatttering is an O(n*O(m*2)) complexity nested loop\n#define iterScatteringOut  20.\n#define iterScatteringIn   20.\n\n//#define eps\t\t\t0.00001\n#define pi\t\t\t\tacos(-1.)\n//why would it need pi*4 ????\n#define pit4 \t\t\t12.566370614359172953850573533118\n\n//atmospheric scattering parameters\n#define PLANET_RADIUS     6.36\n#define ATMOSPHERE_RADIUS 6.42\n#define H0Rayleigh        .13333\n#define H0Mie             .02\n#define KRayleigh         vec3(.058,.135,.331)\n#define KMie              .21\n\n//lib.common\n#define dd(a) dot(a,a)\n#define u2(a) ((a)*2.-1.)\n#define u5(a) ((a)*.5+.5)\n\n//carthesian to sphere (and back)\nvec3 c2s(vec3 v){float r=length(v)\n;return vec3(r, atan(v.x,v.z),acos(v.y/r));}\nvec3 s2c(vec3 v)\n{return v.x*vec3(sin(v.z)*sin(v.y),cos(v.z),sin(v.z)*cos(v.y));}\n\n//ray sphere intersection\nvec2 rsiab(vec3 p, vec3 v){return vec2(dd(v),dot(p,v)*2.00001);}\n//2.00001 ommits left shift optimitation issues.\n//return closest intersection of ray and sphere\nvec3 irs(vec3 p,vec3 v,float r){;vec2 a=rsiab(p,v);\n;return p-v*(a.y+sqrt(a.y*a.y-4.*a.x*(dd(p)-r*r)))*.5/a.x;}\n//return distance to ray-sphere interection(s).\nfloat irsfd(vec3 p,vec3 v,float r){vec2 a=rsiab(p,v);\n;return -.5*(a.y+sqrt(a.y*a.y-4.*a.x*dd(p)-r*r))/a.x;}\nvec2 irsfd2(vec3 p,vec3 v,float r){vec2 a=rsiab(p,v);\n;return (vec2(-1,1)*sqrt(a.y*a.y-4.*a.x*(dd(p)-r*r))-a.y)*.5/a.x;}\n\n//scat() is an O(n*O(m*2)) complexity nested loop\n//scatS() is an inner loop of scat()\n//and it is iterated over twice\n//,which seems VERY inefficient and optimizable\n//as in, it interpolates over 2 loops\n// , instead of interpolating within the loop\nvec4 scatS(vec3 a,vec3 b,vec4 k,vec2 o)\n{vec3 s=(b-a)/iterScatteringOut,u=a+s*.5;vec2 r=vec2(0)\n;for(float i=.0;i<iterScatteringOut; ++i\n){float h=(length(u)-PLANET_RADIUS)/(ATMOSPHERE_RADIUS-PLANET_RADIUS)\n ;h=max(.0,h);r+=exp(-h/o);u+=s;\n}r*=length(s);return r.xxxy*k*pit4;}\n\n//a,b,k,h0,lightDir\nvec4 scat(vec3 a,vec3 b,vec4 k,vec2 o,vec3 d)\n{;vec3 s=(b-a)/iterScatteringIn,u=a+s*.5;float stepLength=length(s);\n;vec4 rr=vec4(0)\n;for(float i=.0;i<iterScatteringIn;++i\n){float h=(PLANET_RADIUS-length(u))/(ATMOSPHERE_RADIUS-PLANET_RADIUS)\n ;rr+=exp(-scatS(u,irs(u,-d,ATMOSPHERE_RADIUS),k,o)\n          -scatS(u,a                          ,k,o)\n         )*exp(min(.0,h)/o).xxxy;u+=s;\n}return rr*stepLength*k;}\n\nfloat RayleighPhase(float m){return (3./4.)*(1.+m*m);}\n\nfloat MiePhase(float m){const float g=-.99,h=g*g\n;return (3.*(1.-h)/(2.*(2.+h)))*(1.+m*m)/pow((1.+h-2.*g*m),3./2.);}\n\nvec3 tldg(vec3 l){float t=-.16+iTime\n;return normalize(vec3(l.x*cos(t)+l.y*sin(t)\n,l.x*(-sin(t))+l.y *cos(t),.0));}\n\nvec4 scatter(vec2 u){u.y=1.-u.y\n;vec3 s=vec3(1,(u.x*2.-1.)*pi,u.y*pi),d=s2c(s);s=vec3(.0,PLANET_RADIUS,.0)\n;return 10.*scat(s,s+d*irsfd2(s,d,ATMOSPHERE_RADIUS).y\n,vec4(KRayleigh,KMie),vec2(H0Rayleigh,H0Mie)\n,tldg(normalize(lightPosition0.xyz)));}\n\nfloat ratio(){return mix(iResolution.x/iResolution.y\n                        ,iResolution.y/iResolution.x\n                   ,step(iResolution.x,iResolution.y));}\n\nvoid mainImage( out vec4 o, in vec2 v )\n{vec2 u=v/iResolution.xy\n;u.y=1.-u.y\n;vec3 sphericalDirection=vec3(1,(u.x*2.-1.)*pi,u.y*pi)\n;vec3 d = s2c(sphericalDirection)\n;vec3 l=normalize(lightPosition0.xyz)//sunDirection\n;vec3 tld=tldg(l);\n;vec3 s=vec3(.0,PLANET_RADIUS, .0)\n;vec3 atmospherePos=s+d*irsfd2(s,d,ATMOSPHERE_RADIUS).y\n;const float fov=90.;//looks aas if this was cobbled from many souces. \n;vec2 w=u2((v+.5)/iResolution.xy)*vec2(ratio(),-1);    \n;vec2 p=w*tan(fov*pi/360.0);\n;vec3 rayOrigin=vec3(0); \n;vec3 rayDirection=normalize(vec3(p,-1)-rayOrigin)\n//above is equal to Vec3f(w,-1); \n;vec2 f=c2s(rayDirection).yz/pi;f.x=u5(f.x);\n;vec4 c=scatter(f);\n;float t=-.16 +iTime\n;vec3 sunPos=vec3(l.x*cos(t)+l.y*sin(t),-l.x*sin(t)+l.y*cos(t),.0)\n;float m=dot(d,-sunPos)      \n;o=vec4(c.xyz*RayleighPhase(m)+c.www*MiePhase(m),1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}