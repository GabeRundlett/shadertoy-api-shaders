{
    "Shader": {
        "info": {
            "date": "1504348746",
            "description": "this is an excessive response to a discussion on \"what makes better randomness\";\nhttps://www.shadertoy.com/view/ltB3zD\n\nThe problem is the bias within \"better\"; any test for randomness is automatically biased.",
            "flags": 0,
            "hasliked": 0,
            "id": "4llcWn",
            "likes": 7,
            "name": "precise pseudo random rants",
            "published": 3,
            "tags": [
                "tutorial",
                "random",
                "twister",
                "hash",
                "infinity",
                "pcg",
                "lcg",
                "mersenne"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 1989
        },
        "renderpass": [
            {
                "code": "//self: https://www.shadertoy.com/view/4llcWn\n\n//This shader mostly shows big LCG differences due to minor seed-precision differences.\n//Than it \"randomly\" rants A LOT about \"randomness\", being more about noise than hash.\n\nhighp float;//high precision is essential for better pseudo_randomness.\n\nconst float pi =acos(-1.)     ;//3.14; circle.circumference/circle.diameter\nconst float phi=sqrt(5.)*.5-.5;//0.61; phi-1=1/phi , smaller root.\nconst float Phi=sqrt(5.)*.5+.5;//1.61; Phi-1=1/Phi , larger  root.\nconst float fha=14142.1356237; //most famous arbitiary amplitude fora hash what uses cos()\n\n//based on: www.shadertoy.com/view/ltB3zD\n//But by Implying that a state differenciates hash from noise.\n//I cal \"Gold NOISE\" a misnomer, as h12gold*() is a stateless projecting hash, \n// and not noise with internal state. \n\n//maximum precision \"gold noise\", is \"better\" or \"worse\" depending on your bias==context.\nfloat h12goldM(vec2 coordinate,float seed){\n return fract(sin(dot(coordinate*seed,vec2(Phi,pi)))*fha);}\n//high precision \"gold noise\" , similar to from gold_noiseH()\n// but it has LESS apparent diagonal lines, as these get lost with lower precision.\nfloat h12goldH(vec2 coordinate,float seed){\nreturn fract(sin(dot(coordinate*seed, vec2(1.61803398875, \n                                           3.14159265359)))*fha);}\n//low precision \"gold noise\",(for short source code) is the \"oddball\" that still \"works\"\nfloat h12goldS(vec2 coordinate,float seed){\n return fract(sin(dot(coordinate*seed,vec2(1.61,3.14)))*14142.);}\n\n//h12gold*() functions do not contain modulo, therefore, with increasing abs(iTime), \n// precision of IEEE operations with iTime decreases.\n// Your randomness does not improve with lower precision (later timestamps), \n// but it just blurs and becomes less bijective over time.\n// Blur is anti-proportional to quality.\n// Blur != anti-aliasing\n// Blur == gradient of how bijective your functions are.\n//It appears more random, \n// but is actually a worse RNG, by having more bias, being less bijective, more blurry.\n// With more blur, lower precision, \n//  you get a bias in favor of values closer to the mean average value.\n//  which may look a lot like \"fake normal distribution\".\n\nvoid mainImage(out vec4 O,in vec2 U){vec2 u =U.xy/iResolution.xy;\n float SeedTime=iTime+fha;\n O=vec4(h12goldM(u,SeedTime),h12goldH(u,SeedTime),h12goldS(u,SeedTime),1);}\n\n\n\n//Incoming wall of pseudo-random text on randomness:\n\n\n/*\nI make a new shader when its too much code and not just a small modification. \nSubmitting small mods touches on plagiarism ans spam.\nEither way, this text requites editing and good structure, \n and shadertoy comments do not have that.\n\n\n-------\n\nWith limited bits to represent irrational (or even transcendental) values, \n which come down to calculating a recursive fraction with an accumulator ,\n pseudo_irrational_values are rationalized/heuristic estimations of irrationals;\nYou can know your epsilon to the irrational, \n and epsilon gets smaller in future implementations, \n just by using more bits to calculate sqrt(n).\nAny scaling or offset to [a pseudo_irrational_value*MULTscale+ADDoffset] \n further reduces precision, increasing epsilon, due to logarithmic IEEE_float bias, \n in favor of values close to 0.\n\nThere is money in a general proof that transcendental (or just irrational) numbers \n are (not) ideal random number generators;\nHow to proof that pi will NEVER repeat or NEVER be biased after one point, \n never contain one digit more often than another, in any numerical system. \nFor numerical bases (other than base 10) of irrationals, Pi in base-phi is fun:\n https://en.wikipedia.org/wiki/Golden_ratio_base\nPhi=sqrt(5.)*.5+-.5; and a modulo of phi \n (including integer modulo of 2 adjacent Fibonacci numbers) has the lowest discrepancy;\nhttps://blog.demofox.org/2017/05/29/when-random-numbers-are-too-random-low-discrepancy-sequences/\n which is a good ideal/property to have in a Linear Congruental Generator [LCG].\nA hash that uses sin() or cos() has high discrepancy (at its core), \n and may differ a lot on simpler mobile implementations, \n who tend to poorly estimate cosines with a low degree Taylor Polynomial.\nThis makes any hash/rng that includes cos() or sin() nearly useless \n on hardware that is optimized for energy efficiency, disregarding precision.\n (only demonstrated in this shader when you compare it between hardwares/setups)\n\nNewer CPUs are planned to contain (or at least utilize) specialized circuits, \n that may include quantum tunneling of a (broken) NAND-memory_SSD-relay \n and synchronization of a small internal (self tuning) atomic clock, \n as elements for better pseudo random number generators, \n by providing significantly less predictable seeds than a timestamp or prime.\n\n\n--- pseudo random ranting:\n\nEmphasizing on self referential recursion, you can now skip [this text] \n to [it's own example code and summary] at [it's end], \n assuming that [this whole text] is just random ASCII, \n and assuming that a [skip ahead] is what you want \n to get to the better bits of this text: \n\nThis reply is longer, because I just saw this long video on LCG+PCGs;\n https://www.youtube.com/watch?v=45Oet5qjlms\n and my mailbox shows some activity on\n https://www.shadertoy.com/view/ltB3zD \n so it is time to update it:\n\nWarning; the video starts with Extemely BAD RNGs;\n https://www.amazon.com/Million-Random-Digits-Normal-Deviates/dp/0833030477\n down to a book with millions of surprisingly biased and STATIC decimals \n (where \"99999\" occurs tzerop times within a million, expected to occur twice.)\n from a time before vacuum tube technology, still on sale today, still\n https://www.google.de/search?client=firefox-b&dcr=0&q=%2210097+32523+76520+13586+34673%22&oq=%2210097+32523+76520+13586+34673%22&gs_l=psy-ab.3...20662.23658.0.23776.6.6.0.0.0.0.370.969.0j4j0j1.5.0....0...1.1.64.psy-ab..1.0.0.AsprpfzFPbw\n referenced way too much. Hopefully only as a bad joke. \n It only goes uphill from there, while making fun at overly excessive and BAD methods, \n easily labeling the Mersenne Twister as \n \"pathetic, barely random and inefficient\", \n if only because it can be sniffed out as being a Twister, and inverses quite easily.\n\n---- Upgrades to simple pseudo random cores:\n\nurl=http://www.pcg-random.org/\n\nA LCG\n https://en.wikipedia.org/wiki/Linear_congruential_generator\n is a (usually) VERY SIMPLE pseudo random number generator, \n and even very simple ones are still widely in use; \n as they include; minstd_rand0; and; java.util.Random();\n\nYou can upgrade an [LCG] by realizing that the higher order bits \n are \"more random\" (less fractal-symmetric) \n than its (more fractal-ymmetric) lower order bits. \nAnd then using the higher order bits to bitwise rotate or or Xor, \n (doing any bijective/inversible projection of bits on all the other bits). \nThis extents an LCG to a [Permuting LCG]==[PCG]] \n that includes ANY POSSIBLE permutation of itself (recursively) over one whole period. \n\nYou can make an LCG (or its PCG extension) harder to predict, \n by extending that it only outputs an inverse integer fraction of its state; \nMost easily, it state is 32 bits, and it only outputs 16 bits of its state, \n and the highest order bits determine a small shift to best pseudo-randomize \n what section of the state is returned as output. \nIt than will contain every output [multiple times, and exactly equally often] \n within its period. \nIt than is less predictable for a whole period length, \n making it harder to exclude numbers who already appeared within the current period.\n\n\n----- On the extremes to infinity (and infinite precision of irrationals)\n\nThere is one VERY simple lesson when it comes to address space;\n randomness and \"infinity\", and that is the realization that\npow(2.,266.) > pow (10.,80.) are relevant upper boundary values, roughly equal to:\n- the number or cubic meters witin the visible universe.\n- the number or neutrons     witin the visible universe.\n- the number or electrons    witin the visible universe.\n- the most memory that the visible universe could address to instantiate \n and compute with, even if the [Speed Of Light] would NOT be a limit to computation.\n\nThat is, a larger address space will point into a void, \n outside of the visible universe, \n which becomes impractical on many more physical levels.\nAnd a Mersenne Twister does just that. \n which can be used to do \"party tricks\", best shown on;\n https://libraryofbabel.info/\n that mostly teach you that infinity is only an abstract model concept;\n https://www.youtube.com/watch?v=ji8pInOuGzQ\n that can not be instantiated, and that has no necessity to be instantiated.\nBut \"infinity\"  is still a useful model for cryptography \n or pseudo random number generators.\n\nThere is one slightly trickier lesson that \"true randomness\" does not exist. \n Only your lack of knowledge to predict anything exists, \n due to hidden information or causality and a maximum speed of information/light. \nYou either instantiate your whole address space, \n so that a pointer to a location equals the (bijective) content at that lovation, or not.\n And I prefer to assume a bijective model over a Chtulhu/Cosmic_Horror model.\nPhysical limits constrain how much instantiated address space you can observe.\n\"True randomness\" equals a longing to instantiate infinity \n AND not being able to observe all of it in a singular moment, \n which we already deconstructed as unfeasible,\n or at least unscientific, as it asserts anything wihout evidence for anything.\n\nThere is only finite (causal) stuff and there is only pseudo randomness. \nAnd I am pretty sure this also applies to quantum scales, \n waveform collapsing and holographic shells around black holes, \n that hold information hostage tll the black hole condenses enough \n to dissipate the information back.\nThough there is a lot of fame in generalizing proof for all that. \n\nEven the time domain may be finite, \n by slowing down over time to an asymptote that it can never reach. \nIf finite time slows down over time, \n how yould you be able to tell a difference? \nWhy care wether you are achilles's tortoise , \n having \"all the time in the universe\" \n to never reach achilles by achilless's measures, \n or just skipping past achilles by your own root-solving pace.\n\n\n\n\n---- Bottom lines:\n\n- A PCG boils down to a simple bitwise twister.\n- A PCG is small (in memory for seed and state) \n   and efficient (does not even have to do division/modulo operations, \n   which are slower, because they are not parallelizable).\n- The Fibonacci Sequene is ideal for [lowest discrepancy]; \n   choosing a prime that is close to a large Fibonacci value \n   might be a good seed == factor or divisor or summand for an LCG. (not sure here).\n- Pi is apparently great for random numbers, hard to prove, but also not too efficient.\n  as it relies on Euler complex number mulriplication (with a transcendental exponent).\n- [Xor and modulo break at 0 mod(a,0.) , being undefined.\n   A Xor/mod Twister can not have state==.0 or seed ==.0 . \n   A modulo zero state/seed points at ALL states/seeds at the same time. \n   url=https://www.google.com/search?q=mlp+mirror+pool&ie=utf-8&oe=utf-8gfe_rd=cr&dcr=0\n   XOR(a,0)==0; points back at itself. (yes, that mlp reference makes sense here, to me)\n\n\n\n--- In summary, code of a simple example for a 64 state LCG.PCG \n     that outputs 32 bit (to be harder to predict):\n*/\n\n/*\n//64 bit [LCG] == Linear Congruental (Pseud Random Numer) Generator;\n//Outputs 32 bits of its 64 bit state.\nuint64 state=INIT; //internal state if an LCG pseudo random number generator\nuint64 MULT=seed1,ADD=seed2; //seeds;\nuint32 PCGgenerate32of64(){\n   state=state*MULT+ADD;//twist state\n   uint8 SHIFT=31//shift small\n   return state>>SHIFT;//output shifted HALF of state\n}\n*/\n\n//---below is an extension of the above:\n\n/*\n//64 bit [PCG] == Permuting (Linear) Congruental (Pseud Random Numer) Generator;\n//Outputs 32 bits of its 64 bit state.\n//Its State's 3_highest_order_bits shift what 32 of the remaining 29 bits get returned.\n//This makes the state a dual number, permuting trough its whole LCG period.\nuint64 state=INIT; //internal state if an LCG pseudo random number generator\nuint64 MULT=seed1,ADD=seed2; //seeds;\nuint32 PCGgenerate32of64(){\n   state=state*MULT+ADD;//twist state\n   uint8 SHIFT=29-(state>>61));//calculate shift\n   return state>>SHIFT;//output shifted HALF of state\n}//passes [TestU01-BigCrush], \n//actually only needs 53 bits of state to pass [TestU01-BigCrush].\n*/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}