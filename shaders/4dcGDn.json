{
    "Shader": {
        "info": {
            "date": "1448853537",
            "description": "- normalized gabor using complexes.\n- uv local parameterizations by dual-Gabor: uncomment texture() or (a,a0) visualizations past line 134.",
            "flags": 16,
            "hasliked": 0,
            "id": "4dcGDn",
            "likes": 1,
            "name": "Gabor 5: normalized",
            "published": 3,
            "tags": [
                "complex",
                "gabor",
                "parameterization"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 349
        },
        "renderpass": [
            {
                "code": "// variant from https://www.shadertoy.com/view/XlsGDs\n\n#define NB 600.        // number or gabor blobs\nfloat SIZE   = 0.0566; // .22 size of gabor blobs\nfloat SPREAD = 0.;     // .5  angular variation\n\n// --- utilities ------------------------------\n\n#define PI     3.14159265358979\n#define ISQRT2 0.7071067811865\n\nbool keyToggle(int ascii) {\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\n}\n\nfloat gauss(float x,float s) {\n    return exp(-.5*(x*x)/(s*s)); \n}\nfloat gauss(vec2 v,float s) { return gauss(v.x,s)*gauss(v.y,s); }\n\nfloat rndi(float i, float j) {\n    return fract(1e5*sin(i+3.*j+0.567));\n}\n\nfloat BesselJ0(float x) {\n    x=abs(x); return (x>PI/2.) ? sqrt(2./(PI*x))*cos(x-PI/4.) : cos(x*ISQRT2);\n}\nfloat BesselJ1(float x) {\n    float s=sign(x); x=abs(x);\n    return (x>2.4) ? s*sqrt(2./(PI*x))*sin(x-PI/4.) : s*0.581865*sin(PI/2.*x/1.8411838);    \n}\n\n// --- complex Gabor ------------------------------\nvec2 Gabor(vec2 pos, float freq, float a) {\n    float t = (!keyToggle(64+20))? 0. : iTime; // 'T'\n    float g = gauss(pos,SIZE);\n    if (g < 1e-3) return vec2(0.);\n    vec2 dir = ISQRT2*(cos(a)*vec2(1.,1.)+ sin(a)*vec2(-1.,1.));\n  //vec2 dir = vec2( cos(a), sin(a) );\n    float phi = freq*dot(pos,dir) * 2.*PI - 10.*t;\n\n    #define CAS 1 // 1: normal   others: experiments\n#if CAS==1 // bilobe\n    return g*vec2(cos(phi),sin(phi));\n\n#elif CAS==2 // blob\n    a = 2.*PI*length(dir);\n    return - 2.*PI*SIZE*SIZE*gauss(a*SIZE,1.)*vec2(cos(-10.*t),sin(-10.*t));\n#elif CAS==3 // quadrilobe\n    dir = vec2(-dir.y,dir.x);\n    float phi2 = freq*dot(pos,dir) * 2.*PI - 10.*t;\n    return (g*vec2(cos(phi),sin(phi)) +g*vec2(cos(phi2),sin(phi2)))/2. ;\n#elif CAS==4 // 1/2 ring (sampled)\n    vec2 n=vec2(0.);\n    for (float a=0.; a<PI/2.; a+= PI/20.) {\n     \tdir = ISQRT2*(cos(a)*vec2(1.,1.)+ sin(a)*vec2(-1.,1.));\n    \tphi = freq*dot(pos,dir) * 2.*PI - 10.*t;\n        n += g*vec2(cos(phi),sin(phi));\n    }\n    return (n/10.);\n#elif CAS==5 // ring-cos\n    phi = freq*length(pos) * 2.*PI - 10.*t;\n    return g*vec2(cos(phi),sin(phi));\n#else // ring-Bessel\n    phi = freq*length(pos) * 2.*PI - 10.*t;\n    return vec2(BesselJ0(phi),BesselJ1(phi)); // where to put SIZE ?\n#endif\n}\n\n// --- complex Gabor noise = kernel * point distrib\nvec2 GaborNoise(vec2 uv, float freq, float dir) {\n    vec2 f=vec2(0.); float fa=0.;\n\tfor (float i=0.; i<NB; i++) { \n\t\tvec2 pos = vec2(1.8*rndi(i,0.),rndi(i,1.));\n        float a = dir + SPREAD *PI*(2.*i/NB-1.);\n\t\tf += Gabor(uv-pos, freq, a);\n\t}\n\treturn f *sqrt(200./NB); // /6.;\n}\n\n// ------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // --- controls \n    vec2 uv = fragCoord.xy / iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    float m = .5* iResolution.x / iResolution.y, // mid x\n          x = fragCoord.x / iResolution.x;\n\tfloat freq = mix(10., iResolution.x/10., mouse.x);\n    if (keyToggle(64+19)) SPREAD = mouse.y;      // 'S'\n    if (keyToggle(64+16)) SIZE *= .1;            // 'P'\n    // SIZE = mouse.y*.1; // for tuning kernel size. please then use NB=6000.\n\t    \n    // --- Gabor noise = kernel * point distrib\n    float dir = 0.;\n    // m=0.; dir = 6.28*x;                          // space-varying orientation: bend\n    // m=0.; dir = 6.28*sin(uv.x)*sin(uv.y);        // space-varying orientation: blobs\n    // dir = atan(uv.y-.5,uv.x-m)-3.14/4.; m=0.;    // space-varying orientation: circle\n\n    vec2 f  = GaborNoise(uv,freq,dir), f2 = vec2(0); \n    float l0 = length(f), l2, k=.5, a,a2;\n    \n#if 1 // correctly normalization of multi-lobes. Please select CAS=1 in Gabor()\n #define CAS2 1 // 0: passthrough -1: use as mapping  1 : quadrilobe 2 : multilobe\n    \n #if CAS2==1 // for quadrilobe: second bi-lobe\n    f2 = GaborNoise(uv,freq,dir+PI/2.);\n  //f2 = GaborNoise(uv,freq,dir+PI/4.+0.*PI); // non-orthogonal case\n    l2 = length(f2);\n\tf = f+f2; l0 = sqrt(l0*l0+l2*l2);  // correctly normalized quadri-lobe\n  //l0 = length(f);                    // for comparison\n #elif CAS2==2  // pseudo blue-noise ring\n    l0 *= l0;\n    float n=0.;\n    for(float a=0.; a<6.283/2.; a+=.6) { // try /1. or /2.\n        f2 = GaborNoise(uv,freq,a);\n     // m=0.; f2 = GaborNoise(uv,freq,6.28*pow(a/6.28*x,2.5)+3.14/4.); // space-varying iso-aniso\n        l2 = length(f2);\n        f += f2; l0 += l2*l2; n++;\n    }\n    f/=n; l0 = sqrt(l0)/n; // or not ?\n #elif CAS2==-1  // UV mapping vec2(f.y,f2.x)\n    f2 = GaborNoise(uv,freq,dir+.5*PI); // .05, .5\n #endif\n    \n    if (uv.x>m) f2 /= length(f2); // normalize f2 just in case (e.g. UV mapping)\n    a2 = atan(f2.y,f2.x); a2 = .5+.5*a2/3.1416;  // phase of complex noise. (norm should be 1)\n#endif\n    a = atan(f.y,f.x); a = .5+.5*a/3.1416;  // phase of complex noise. (norm should be 1)\n\n    \n    // --- Normalize and display Gabor noise\n   \n\tfloat b = (!keyToggle(64+19)) ? 1. : 1.-mouse.y; // 'S'\n    if (abs(uv.x-m)<.005) { fragColor=vec4(1,0,0,0); return; }\n    if ((uv.x<m)==!keyToggle(64+6)) f *= .5; else f /= mix(2.,l0,b); // 'P' <<< renormalization\n   \t//if(!keyToggle(64+26)) f.x=f.y;       // real vs complex Gabor\n    // fragColor = texture(iChannel0,vec2(f.y,f2.x));    return;    // texture(f1,f2)\n    \n    // fragColor = vec4(a);                                return;    // phase\n    // fragColor = vec4(pow((.5+.5*cos(6.283*a))*(.5+.5*cos(5.*6.283*a)),5.));  return;    // isoval(phase)\n    // fragColor = .5+.5*cos(vec4(1,5,5,0)*6.283*a);       return;    // isoval(phase)\n    // fragColor = .5+.5*cos(vec4(1,5,5,0)*6.283*a2);      return;    // isoval(phase2)\n    // fragColor =  texture(iChannel0,vec2(a));          return;    // texture1D(phase)\n\n    // fragColor = vec4(a,a2,0,1);                         return;    // (phase1,phase2)\n    // fragColor = vec4(pow(max((.5+.5*sin(1.*6.283*a)),(.5+.5*sin(1.*6.283*a2))),4.)); return;  // isoval(phase1,phase2)\n    // fragColor = texture(iChannel0,vec2(a,a2));        return;    // texture(phase1,phase2)\n    \n       fragColor = vec4(.5+.5*f.x,.5+.5*f.y,0.,1.);        return;    // classic (complex)\n    // fragColor = vec4(.5+.5*f.y);                        return;    // classic (real renormed)\n    // fragColor = vec4(length(f));                        return;    // energy (norm)\n    // fragColor = vec4(l0);                               return;    // complex angle\n    // fragColor = texture(iChannel0,f);                 return;    // texture(Re,Im)\n    // fragColor = vec4(smoothstep(0.,.3,abs(f.y-0.)));    return;    // isoval\n    // fragColor = vec4(fract(.5+.500*f.y));               return;    // check histogram\n    // fragColor = vec4(1,1,0,1) + vec4(-1,-1,1,1)*smoothstep(-.4,.4,f.y);     return; // LUT\n    // fragColor = vec4(1,1,0,1) + vec4(-1,-1,1,1)*smoothstep(1.,.4,abs(f.y)); return; // LUT(abs)\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}