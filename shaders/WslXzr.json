{
    "Shader": {
        "info": {
            "date": "1550502529",
            "description": "Reuleaux Triangles\nMusic by EnigmaCurry",
            "flags": 64,
            "hasliked": 0,
            "id": "WslXzr",
            "likes": 5,
            "name": "Shapes of Constant Width",
            "published": 3,
            "tags": [
                "transparency",
                "triangle",
                "geometry",
                "soundcloud",
                "reuleaux"
            ],
            "usePreview": 0,
            "username": "EnigmaCurry",
            "viewed": 964
        },
        "renderpass": [
            {
                "code": "/// Shapes of Constant Width - EnigmaCurry 2019\n/// See Mathologer for more about Reuleaux Triangles\n/// https://www.youtube.com/watch?v=-eQaF6OmWKw\n\n#define BORDER_PCT 0.2\n#define PI 3.14159\n\nfloat circle(in vec2 _p, in vec2 _center, in float _radius) {\n  vec2 dist = _p - _center;\n  return step(distance(_p, _center), _radius);\n}\n\nfloat line(in vec2 p, in vec2 p1, in vec2 p2, float width) {\n  vec2 d0 = p2 - p1;\n  vec2 d1 = p - p1;\n  return length(d1 - d0 * clamp(dot(d0, d1) / dot(d0, d0), 0., 1.)) * (1./width*8.);\n}\n\nvec2 rotateVec2(in vec2 v, in vec2 axis, in float angle) {\n  vec2 vprime = v - axis;\n  vec2 vrot = vec2(vprime.x * cos(angle) - vprime.y * sin(angle),\n                   vprime.y * cos(angle) + vprime.x * sin(angle));\n  return vrot + axis;\n}\n\nvec3 reuleauxTriangle(in vec2 _p, in vec2 _rotCenter, in float r) {\n  float fft = clamp(texture( iChannel0, vec2(0.1,0.1) ).x * 12., 0.2, 99999.);\n  vec2 top = vec2(_rotCenter.x, _rotCenter.y + (sqrt(3.)/2.) * r);\n  vec2 left = vec2(top.x-(r/2.), top.y-1. * (sqrt(3.)/2.) * r);\n  vec2 right = vec2(top.x+r/2., top.y-1. * (sqrt(3.)/2.) * r);\n  vec2 center = vec2(_rotCenter.x, _rotCenter.y + 0.333 * distance(_rotCenter, top));\n  /// Rotate triangle\n  float angle = 0.;\n  float tmod = mod(iTime, 60.);\n  float sigh = sin(iTime/110.) * cos(iTime*1.) * 4.;\n  float wave = sin(iTime/14.) * cos(iTime/6.) * 4.;\n  if (tmod < 15.) {\n    angle = sigh;\n  } else if (tmod < 30.) {\n    angle = mix(sigh, wave, (tmod - 15.) / 15.);\n  } else if (tmod < 45.) {\n    angle = wave;\n  } else if (tmod < 60.) {\n    angle = mix(wave, sigh, (tmod - 45.) / 15.);\n  }\n  top = rotateVec2(top, _rotCenter, angle);\n  left = rotateVec2(left, _rotCenter, angle);\n  right = rotateVec2(right, _rotCenter, angle);\n  center = rotateVec2(center, _rotCenter, angle);\n  /// Union of three circles:\n  float c1 = circle(_p, top, r);\n  float c2 = circle(_p, left, r);\n  float c3 = circle(_p, right, r);\n  float drot = distance(_p, _rotCenter);\n  float dtop = distance(_p, top);\n  float dleft = distance(_p, left);\n  float dright = distance(_p, right);\n  float dcenter = distance(_p, center);\n  float dthreshold = 0.008;\n  float dline1 = line(_p, top, left, 0.5);\n  float dline2 = line(_p, left, right, 0.5);\n  float dline3 = line(_p, right, top, 0.5);\n\n  vec3 color = vec3(0.);\n  if ( c1 > 0. && c2 > 0. && c3 > 0.){\n    float c = atan(cos((_p.x/_p.y) * abs(sin(iTime/14.)) * 13. + 3.) * 15.);\n    color = smoothstep(\n                      vec3(smoothstep(fft*-1.48, 1.48, fft*atan(cos(iTime/8.)*22.*sin(iTime/2.)))),\n                      vec3(1.0 - c, c, _p.x * c),\n                      vec3(smoothstep(-PI/4., PI/4.,atan(sin(iTime/3.))))\n                        - distance(_p, _rotCenter)\n                      );\n    if (drot < dthreshold) {\n      color = vec3(smoothstep(0.,.01,drot * smoothstep(-1.,1., sin(iTime/2.))),\n                   smoothstep(0.,.01,drot * smoothstep(-1.,1., sin(iTime/4.))),\n                   smoothstep(0.,.01,drot * smoothstep(-1.,1., sin(iTime/8.)))\n                   );\n    } else if (dtop < dthreshold || dleft < dthreshold || dright < dthreshold) {\n      color = vec3(0.8);\n    } else if (dcenter < dthreshold) {\n      color = vec3(smoothstep(0.,.01,dcenter * smoothstep(-1.,1., cos(0.01*fft*iTime/2.))),\n                   smoothstep(0.,.01,dcenter * smoothstep(-1.,1., cos(0.01*fft*iTime/4.))),\n                   smoothstep(0.,.01,dcenter * smoothstep(-1.,1., cos(0.01*fft*iTime/8.)))\n                   );\n    } else if (dline1 < dthreshold || dline2 < dthreshold || dline3 < dthreshold) {\n      color = vec3(smoothstep(-1., 0.1 * _p.x, atan(sin(iTime/4.))));\n    }\n  }\n\n  return color;\n}\n\nvec4 bgScene(in vec3 _color, in vec2 _p) {\n  float fft = clamp(texture( iChannel0, vec2(0.1,0.1) ).x * 12., 0.2, 99999.) / 16.;\n  fft /= sqrt(fft);\n  float c = atan(cos((_p.x/_p.y) * abs(sin(iTime/14.)) * 13. + 3.) * 15.);\n  if (_color == vec3(0.)) {\n    return vec4(vec3(0.1+fft * c, 0.1+fft*_p.y*c, 0.1+fft*_p.x * c), smoothstep(-1., 1., sin(iTime/12.)));\n  } else {\n    return vec4(_color, 1.);\n  }\n}\n\nvec3 tint(in vec3 color, in vec3 base, in float amount) {\n  if (base !=  vec3(0.)) {\n    return mix(base, color, amount);\n  } else {\n    return base;\n  }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy;\n  //Center and normalize zoom:\n  float zoom = smoothstep(-1., 1., sin(iTime/12.)) + 0.5;\n  vec2 p = (uv - 0.5) / zoom;\n  if (iResolution.x > iResolution.y) {\n    p.x *= iResolution.x/iResolution.y;\n  } else {\n    p.y *= iResolution.y/iResolution.x;\n  }\n  float width = 0.5;\n  float radius = width / 2.;\n  float tintAmount = smoothstep(-4.,8.,sin(iTime/2.));\n  vec3 color = tint(vec3(0.,1.,0.), reuleauxTriangle(p, vec2(0., 0.), radius), tintAmount);\n  color += tint(vec3(0.294,0.,0.50980), reuleauxTriangle(p, vec2(radius, 0.), radius), tintAmount);\n  color += tint(vec3(1.,0.64706,0.), reuleauxTriangle(p, vec2(-radius, 0.), radius), tintAmount);\n  color += tint(vec3(1.,0.,0.), reuleauxTriangle(p,\n                                                 vec2(-radius/2., (sqrt(3.)/2.) * radius),\n                                                 radius), tintAmount);\n  color += tint(vec3(0.,0.,1.), reuleauxTriangle(p,\n                            vec2(radius/2., (sqrt(3.)/2.) * radius),\n                                                 radius), tintAmount);\n  color += tint(vec3(1.,1.,0.), reuleauxTriangle(p,\n                            vec2(-radius/2., 0. - (sqrt(3.)/2.) * radius),\n                                                 radius), tintAmount);\n  color += tint(vec3(0.93333, 0.50980, 0.93333), reuleauxTriangle(p,\n                            vec2(radius/2., 0. - (sqrt(3.)/2.) * radius),\n                                                                        radius), tintAmount);\n\n  color += reuleauxTriangle(p, vec2(radius*2., 0.), radius);\n  color += reuleauxTriangle(p, vec2(-radius*2., 0.), radius);\n  color += reuleauxTriangle(p, vec2(-3.*radius/2., (sqrt(3.)/2.) * radius), radius);\n  color += reuleauxTriangle(p, vec2(3.*radius/2., (sqrt(3.)/2.) * radius), radius);\n  color += reuleauxTriangle(p, vec2(-3.*radius/2., -(sqrt(3.)/2.) * radius), radius);\n  color += reuleauxTriangle(p, vec2(3.*radius/2., -(sqrt(3.)/2.) * radius), radius);\n\n  color += reuleauxTriangle(p, vec2(radius, (sqrt(3.)/2.) * 2. * radius), radius);\n  color += reuleauxTriangle(p, vec2(0., (sqrt(3.)/2.) * 2. * radius), radius);\n  color += reuleauxTriangle(p, vec2(-radius, (sqrt(3.)/2.) * 2. * radius), radius);\n\n  color += reuleauxTriangle(p, vec2(radius, (sqrt(3.)/2.) * -2. * radius), radius);\n  color += reuleauxTriangle(p, vec2(0., (sqrt(3.)/2.) * -2. * radius), radius);\n  color += reuleauxTriangle(p, vec2(-radius, (sqrt(3.)/2.) * -2. * radius), radius);\n\n\n  fragColor = bgScene(color, p);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 17898,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/enigmacurry/dediameterizing-super-locution"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}