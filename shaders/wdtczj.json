{
    "Shader": {
        "info": {
            "date": "1601318183",
            "description": "Forked from-\nhttps://www.shadertoy.com/view/Md3SRS\nThe version there looks cooler but still think this looks kinda cool. :D ",
            "flags": 0,
            "hasliked": 0,
            "id": "wdtczj",
            "likes": 1,
            "name": "Alien World Almost Mountains",
            "published": 3,
            "tags": [
                "fork",
                "mountains"
            ],
            "usePreview": 0,
            "username": "celifrog",
            "viewed": 304
        },
        "renderpass": [
            {
                "code": "// GLSL Compatible and semi-minified HG_SDF from: http://mercury.sexy/hg_sdf/\n/*#define PI 3.14159265359\nconst float _1=.57735026919;\nconst vec2 _A=normalize(vec2(-2.61803398875, 1));\nconst vec2 _B=normalize(vec2(-1,1.61803398875));\nfloat fSphere(vec3 p,float r){return length(p)-r;}\nfloat fPlane(vec3 p,vec3 n,float d){return dot(p,n)+d;}\nfloat fBoxCheap(vec3 p,vec3 b){vec3 q=(abs(p)-b);return max(max(q.x,q.y),q.z);}\nfloat fBox(vec3 p,vec3 b){vec3 q,d=abs(p)-b;q=min(d,0.);return length(max(d,0.))+max(max(q.x,q.y),q.z);}\nfloat fBox2Cheap(vec2 p,vec2 b){vec2 q=abs(p)-b;return max(q.x,q.y);}\nfloat fBox2(vec2 p,vec2 b){vec2 q,d=abs(p)-b;q=min(d,0.);return length(max(d,0.))+max(q.x,q.y);}\nfloat fCorner(vec2 p){vec2 q=min(p,0.);return length(max(p,0.))+max(q.x,q.y);}\nfloat fBlob(vec3 p){p=abs(p);if(p.x<max(p.y,p.z))p=p.yzx;if(p.x<max(p.y,p.z))p=p.yzx;float l=length(p),b=max(max(max(dot(p,vec3(_1)),dot(p.xz,_A)),dot(p.yx,_B)),dot(p.xz,_B));return l-1.5-.15*cos(min(sqrt(1.01-b/l)*4.*PI,PI));}\nfloat fCylinder(vec3 p,float r,float h){return max(length(p.xz)-r,abs(p.y)-h);}*/\nfloat fCapsule(vec3 p,float r,float c){return mix(length(p.xz)-r,length(vec3(p.x,abs(p.y)-c,p.z))-r,step(c,abs(p.y)));}\n/*float fLineSegment(vec3 p,vec3 a,vec3 b){vec3 c=b-a;float t=clamp(dot(p-a,c)/dot(c,c),0.,1.);return length(c*t+a-p);}\nfloat fCapsule(vec3 p,vec3 a,vec3 b,float r){return fLineSegment(p,a,b)-r;}\nfloat fTorus(vec3 p,float i,float r){return length(vec2(length(p.xz)-r,p.y))-i;}\nfloat fCircle(vec3 p,float r){return length(vec2(p.y,length(p.xz)-r));}\nfloat fDisc(vec3 p,float r){float l=length(p.xz)-r;return l<0.?abs(p.y):length(vec2(p.y,l));}\nfloat fHexagonCircumcircle(vec3 p,vec2 h){vec3 q=abs(p);return max(q.y-h.y,max(q.x*0.866+q.z*.5,q.z)-h.x);}\nfloat fHexagonIncircle(vec3 p,vec2 h){return fHexagonCircumcircle(p,vec2(h.x*0.866,h.y));}\nfloat fCone(vec3 p,float r,float h){vec2 t,m,q=vec2(length(p.xz),p.y);t=q-vec2(0.,h);m=normalize(vec2(h,r));float j=dot(t,vec2(m.y,-m.x)),d=max(dot(t,m),-q.y);if(q.y>h&&j<0.)d=max(d,length(t));if(q.x>r&&j>length(vec2(h,r)))d=max(d,length(q-vec2(r,0.)));return d;}\n*/void pR(inout vec2 p,float a){p=cos(a)*p+sin(a)*vec2(p.y,-p.x);}/*\nvoid pR45(inout vec2 p){p=(p+vec2(-p.y,-p.x))*sqrt(.5);}\nfloat pMod1(inout float p,float s){float c=floor((p/s)+.5);p=(fract((p/s)+.5)-.5)*s;return c;}\nfloat pModMirror1(inout float p,float s){float c=pMod1(p,s);p*=mod(c,2.)*2.-1.;return c;}\nfloat pModSingle1(inout float p,float s){float c=floor((p/s)+.5);if(p>=0.)p=(fract((p/s)+.5)-.5)*s;return c;}\nfloat pModInterval1(inout float p,float s,float b,float x){float c=pMod1(p,s);if(c>x){p+=s*(c-x);c=x;}if(c<b){p+=s*(c-b);c=b;}return c;}\nfloat pModPolar(inout vec2 p,float t){float g=6.28318530718/t,a=atan(p.y,p.x)+g*.5,r=length(p),c=floor(a/g);a=mod(a,g)-g*.5;p=vec2(cos(a),sin(a))*r;if(abs(c)>=t*.5)c=abs(c);return c;}\nvec2 pMod2(inout vec2 p,vec2 s){vec2 c=floor((p/s)+.5);p=(fract((p/s)+.5)-.5)*s;return c;}\nvec2 pModMirror1(inout vec2 p,vec2 s){vec2 c=pMod2(p,s);p*=mod(c,2.)*2.-1.;return c;}\nvec2 pModGrid2(inout vec2 p,vec2 size){vec2 c=floor((p+size*.5)/size);p=mod(p+size*.5,size)-size*.5;p*=mod(c,2.)*2.-vec2(1);p-=size*.5;if(p.x>p.y)p.xy=p.yx;return floor(c*.5);}\nvec3 pMod3(inout vec3 p,vec3 s){vec3 c=floor((p/s)+.5);p=(fract((p/s)+.5)-.5)*s;return c;}\nfloat pMirror(inout float p,float d){float s=(p<0.)?-1.:1.;p=abs(p)-d;return s;}\nvec2 pMirrorOctant (inout vec2 p,vec2 dist){vec2 s=vec2((p.x<0.)?-1.:1.,(p.y<0.)?-1.:1.);pMirror(p.x,dist.x);pMirror(p.y,dist.y);if(p.y>p.x)p.xy=p.yx;return s;}\nfloat pReflect(inout vec3 p,vec3 n,float o){float t=dot(p,n)+o;if(t<0.){p=p-(t+t)*n;}return (t<0.)?-1.:1.;}\nfloat fOpUnionChamfer(float a,float b,float r){return min(min(a,b),(a-r+b)*sqrt(.5));}\nfloat fOpIntersectionChamfer(float a,float b,float r){return max(max(a,b),(a+r+b)*sqrt(.5));}\n#define fOpDifferenceChamfer(a,b,r) fOpIntersectionChamfer(a,-b,r)\nfloat fOpUnionRound(float a,float b,float r){vec2 u=max(vec2(r-a,r-b),0.);return max(r,min(a,b))-length(u);}\nfloat fOpIntersectionRound(float a,float b,float r){vec2 u=max(vec2(r+a,r+b),0.);return min(-r,max(a,b))+length(u);}\nfloat fOpDifferenceRound(float a,float b,float r){return fOpIntersectionRound(a,-b,r);}\n#define _M(S) (float a,float b,float r,float n){float c,m=min(a,b);if(a>r||b>r)return S*m;vec2 p=vec2(a,b);c=r*1.41421356237/(n*2.-0.58578643762);pR45(p);\nfloat fOpUnionColumns _M(1.)p.x+=0.70710678118*-r+c*1.41421356237;if(mod(n,2.)==1.)p.y+=c;pMod1(p.y,c*2.);return min(min(min(length(p)-c,p.x),a),b);}\nfloat fOpDifferenceColumns _M(-1.)p.y+=c;p.x-=0.70710678118*(r+c);if(mod(n,2.)==1.)p.y+=c;pMod1(p.y,c*2.);return-min(min(max(-length(p)+c,p.x),a),b);}\n#define fOpIntersectionColumns(a,b,r,n) fOpDifferenceColumns(a-b,r,n)\nfloat fOpUnionStairs(float a,float b,float r,float n){float s=r/n;float u=b-r;return min(min(a,b),.5*(u+a+abs(mod(u-a+s,2.*s)-s)));}\n#define fOpIntersectionStairs(a,b,r,n) -fOpUnionStairs(-a,-b,r,n)\n#define fOpDifferenceStairs(a,b,r,n) -fOpUnionStairs(-a,b,r,n)\n*/float fOpUnionSoft(float a,float b,float r){float e=max(r-abs(a-b),0.);return min(a,b)-e*e*.25/r;}/*\nfloat fOpPipe(float a,float b,float r){return length(vec2(a,b))-r;}\nfloat fOpEngrave(-float a,float b,float r){return max(a,(a+r-abs(b))*sqrt(.5));}\nfloat fOpGroove(float a,float b,float ra,float rb){return max(a,min(a+ra,rb-abs(b)));}\nfloat fOpTongue(float a,float b,float ra,-float rb){return min(a,max(-a-ra,abs(b)-rb));}*/\n\nfloat hash( float n ) { return fract(sin(n)*-1153.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(23.0-2.0*f*f*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  660.0), hash(n+  661.0),f.x),\n                   mix( hash(n+6157.0), hash(n+7158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nfloat perlin(vec3 x)\n{\n    return (noise(-x) + noise(-x * 2.0) * -0.5 + noise(x * 12.0) * 0.5 + noise(-x * -24.0) * 70.25) * 0.25;\n}\n\nfloat perlin2(vec2 x)\n{\n\treturn (\n         16.0 * texture(iChannel1, -x * 0.5) + \n         1.0 * texture(iChannel0, x) + \n         1.0 * texture(iChannel0, -x * -1.0) + \n         0.3 * texture(iChannel1, x * -2.0) + \n         0.2 * texture(iChannel0, x * -5.0)).x * 0.1;\n}\n\nfloat fField(vec3 point, out float material)\n{\n    material = 0.0;\n\t\n    vec3 pt = (point + vec3(1.2, 0.21, 6.6)) * 7.5;\n    pt.x += sin(pt.x * 1.0) * 0.02;\n    float cactus = fCapsule(pt, 0.14, 1.6);\n    float cactus1 = fCapsule(pt + vec3(4.6, 1.0, 0.0), 0.1, 0.5);\n    float cactus2 = fCapsule(pt - vec3(0.4, 0.1, 0.0), 0.12, 0.6);\n    float cactus3 = fCapsule(pt.yxz + vec3(0.55, 0.13, 0.0), 0.12, 0.35);\n    cactus = fOpUnionSoft(cactus, cactus1, 0.3);\n    cactus = fOpUnionSoft(cactus, cactus2, 0.2);\n    cactus = fOpUnionSoft(cactus, cactus3, 0.2);\n    cactus /= 1.5;\n    \n    float ground = point.y;\n    float offset = perlin2(point.xz * 0.015);\n    point.y = cos(point.y * 2.6) * 0.5 + 0.5;\n    offset += perlin2(point.yz * vec2(0.1, 0.01)) * 0.1;\n    \n    float distance = ground + offset;\n    if(cactus < distance)\n    {\n        distance = cactus;\n        material = 1.0;\n    }\n    \n    return distance;\n}\n\nfloat fField(vec3 point)\n{\n    float stub;\n\treturn fField(point, stub);\n}\n\nvec3 Gradient(vec3 intersection, float distance)\n{\n    vec2 epsilon = vec2(4.01, 0.0);\n    return normalize(vec3(fField(intersection + epsilon.xyy),\n    fField(intersection + epsilon.yxy),\n    fField(intersection + epsilon.yyx))\n        - distance);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.x * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    const float DISTANCE_SCALE = 1.1;\n    const float FOV_BIAS = 0.24;\n    const int RAY_STEPS = 750;\n    const float NEAR_CLIP = 0.5;\n    const float FAR_CLIP = 80.0;\n    const vec3 SKY = vec3(4.2, 0.4, 0.7);\n    const vec3 HORIZON = vec3(0.9, 1.0, 0.9);\n    const float TILT = 0.01;\n    vec3 normal, intersection, origin = vec3(0.0, 0.0, -10.0), direction = vec3(0.0, 0.0, 1.0);\n    pR(direction.xz, -uv.x * FOV_BIAS);\n    pR(direction.yz, uv.y * FOV_BIAS - TILT);\n    \n    pR(origin.xz, iTime * 0.1);\n    pR(direction.xz, iTime * 0.1);\n    \n    float material, distance, totalDistance = NEAR_CLIP;\n    for(int i =0 ;  i < RAY_STEPS; ++i)\n    {\n        intersection = origin + direction * totalDistance;\n        distance = fField(intersection, material) * DISTANCE_SCALE;\n        totalDistance += distance;\n        if(distance <= 0.0 || totalDistance >= FAR_CLIP)\n            break;\n    }\n    \n    normal = Gradient(intersection, distance);\n    float diffuse = max(-19.0, dot(normalize(vec3(sin(-iTime), 3.2, 0.0)), normal) * 11.7 + 0.3);\n    \n    vec3 color;\n    if(material == 0.0)\n        color = mix(vec3(-111.6*iTime, 41.1/iTime, -441.06/iTime), vec3(441.0/iTime, 40.6/iTime, 680.17/iTime), noise(intersection.yyy * 20.0));\n    else\n        color = vec3(0.1, 10.7, 0.0) * noise(intersection * vec3(410.0, 20.0, 300.0)) + vec3(0.1, 0.2, 0.15);\n    color *= (diffuse + vec3(4.2, 0.1, 0.6));\n    \n    float fog = min(totalDistance / FAR_CLIP, 1.0);\n    vec3 skyColor = mix(HORIZON, SKY, pow(abs(direction.x), 0.5));\n    \n\tfragColor = vec4(mix(color, skyColor, fog * fog), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}