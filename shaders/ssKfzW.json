{
    "Shader": {
        "info": {
            "date": "1658004804",
            "description": "* This is one of those things where you're supposed to cross your eyes. You'll see 3 copies of the shading...look at the middle one.\n* Mouse: draw\n* Space: reset fluid sim\n* CFD from flockaroo's single pass CFD https://www.shadertoy.com/view/MdKXRy",
            "flags": 48,
            "hasliked": 0,
            "id": "ssKfzW",
            "likes": 3,
            "name": "Magic Eye Drawing",
            "published": 3,
            "tags": [
                "stereogram",
                "cfd"
            ],
            "usePreview": 0,
            "username": "fenix",
            "viewed": 398
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Just a little shader exploring the possibility of interactive stereograms. Mouse is \n//  required to begin the 3D effect.\n//\n// ---------------------------------------------------------------------------------------\n\nconst vec2 WRAPS = vec2(6.0, 4.0); // May want to increase/decrease according to screen size\n#define DIVERGING 0 // Set to 1 if you uncross your eyes when viewing\n#define SHADING 1 // Kinda reinforces the 3D effect but it might get in the way for some people\n\n#if DIVERGING\nconst float DIRECTION = -1.0;\n#else\nconst float DIRECTION = 1.0;\n#endif\n\nconst float PI = 3.14159265359;\nconst float fov = 50.0;\nconst vec2 LIGHT_DIR = vec2(1.0, 1.0);\n\nconst float EPSILON = 0.01;\n\nconst vec2 deltaX = vec2(1.0, 0);\nconst vec2 deltaY = vec2(0, 1.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if SHADING\n    float dx1 = texture(iChannel1, (fragCoord + deltaX) / iResolution.xy).x -\n        texture(iChannel1, (fragCoord - deltaX) / iResolution.xy).x;\n    float dy1 = texture(iChannel1, (fragCoord + deltaY) / iResolution.xy).x -\n        texture(iChannel1, (fragCoord - deltaY) / iResolution.xy).x;\n        \n    float shadow1 = dot(LIGHT_DIR, vec2(dx1, dy1) * DIRECTION) * 0.3;\n\n    vec2 offsetCoord = fragCoord;\n    offsetCoord.x += iResolution.x / 6.0;\n    float dx2 = texture(iChannel1, (offsetCoord + deltaX) / iResolution.xy).x -\n        texture(iChannel1, (offsetCoord - deltaX) / iResolution.xy).x;\n    float dy2 = texture(iChannel1, (offsetCoord + deltaY) / iResolution.xy).x -\n        texture(iChannel1, (offsetCoord - deltaY) / iResolution.xy).x;\n        \n    float shadow2 = dot(LIGHT_DIR, vec2(dx2, dy2)) * 0.2;\n#else\n    const float shadow1 = 0.0;\n    const float shadow2 = 0.0;\n#endif\n\n    float height = texture(iChannel1, fragCoord/iResolution.xy).x;\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 backgroundUV = uv*WRAPS + vec2(height, 0.0) * 0.01 * DIRECTION;\n    backgroundUV.x = mod(backgroundUV.x, 1.0);\n    backgroundUV.y = mod(backgroundUV.y, 1.0);\n    vec2 vel = texture(iChannel0, backgroundUV).xy;\n\tfragColor = vec4(vel.x, sin(vel.x * 0.2) * 4.0, vel.y, 0.0).yxzw * 0.2 + vec4(shadow1 + shadow2);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// https://www.shadertoy.com/view/MdKXRy\n//\n// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n//\n// \"angRnd\" is the rotational randomness of the rotation-samples\n// \"posRnd\" is an additional error to the position of the samples (not really needed)\n// for higher numbers of \"RotNum\" \"angRnd\" can also be set to 0\n\n#define RotNum 3\n#define angRnd 1.0\n#define posRnd 0.0\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 m = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\n\nfloat hash(float seed) { return fract(sin(seed)*158.5453 ); }\nvec4 getRand4(float seed) { return vec4(hash(seed),hash(seed+123.21),hash(seed+234.32),hash(seed+453.54)); }\nvec4 randS(vec2 uv)\n{\n    //return getRand4(uv.y+uv.x*1234.567)-vec4(0.5);\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 uv, float sc)\n{\n    float ang2 = angRnd*randS(uv).x*ang;\n    vec2 p = vec2(cos(ang2),sin(ang2));\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        vec2 p2 = (p+posRnd*randS(uv+p*sc).xy)*sc;\n        vec2 v = texture(iChannel0,fract(uv+p2)).xy-vec2(0.5);\n        rot+=cross(vec3(v,0.0),vec3(p2,0.0)).z/dot(p2,p2);\n        p = m*p;\n    }\n    rot/=float(RotNum);\n    return rot;\n}\n\nvoid init( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    if (fragCoord.y < iResolution.y * 0.5)\n    {\n        fragColor.g += 5.0;\n    }\n    if (fragCoord.x < iResolution.x * 0.5)\n    {\n        fragColor.r += 5.0;\n    }\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / Res.xy;\n    vec2 scr=uv*2.0-vec2(1.0);\n    \n    float sc=1.0/max(Res.x,Res.y);\n    vec2 v=vec2(0);\n    for(int level=0;level<20;level++)\n    {\n        if ( sc > 0.7 ) break;\n        float ang2 = angRnd*ang*randS(uv).y;\n        vec2 p = vec2(cos(ang2),sin(ang2));\n        for(int i=0;i<RotNum;i++)\n        {\n            vec2 p2=p*sc;\n            float rot=getRot(uv+p2,sc);\n            //v+=cross(vec3(0,0,rot),vec3(p2,0.0)).xy;\n            v+=0.1*p2.yx*rot*vec2(-1,1); //maybe faster than above\n            p = m*p;\n        }\n      \tsc*=2.0;\n    }\n    \n    //v.y+=scr.y*0.1;\n    \n    //v.x+=(1.0-scr.y*scr.y)*0.8;\n    \n    //v/=float(RotNum)/3.0;\n    \n    fragColor=texture(iChannel0,fract(uv+v*3.0/Res.x));\n    \n    // add a little \"motor\" in the center\n    fragColor.xy += (0.01*scr.xy / (dot(scr,scr)/0.1+0.3));\n    \n    if(iFrame<=4 || keyDown(32)) init(fragColor,fragCoord);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\nfloat length2(vec2 a)\n{\n    return dot(a, a);\n}\n\nvoid renderBlob(in vec2 pos, in vec2 coord, inout float color)\n{\n    float dist2 = length2(pos - coord);\n    \n    float RADIUS = iResolution.x / 5.0;\n    color += min(1.0, RADIUS / dist2);   \n    color = min(10.0, color);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float color = texelFetch(iChannel0, ivec2(fragCoord), 0).x;\n    \n    //color = max(0.0, color - 0.01);\n    color *= 0.995;\n    \n    if (iMouse.z > 0.0) renderBlob(iMouse.xy, fragCoord, color);\n    \n    fragColor = vec4(color);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}