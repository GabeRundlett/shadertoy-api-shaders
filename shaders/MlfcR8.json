{
    "Shader": {
        "info": {
            "date": "1503348405",
            "description": "Click the mouse or press space to jump, try to get as far as possible without touching the walls. Taken from an Android app I made: \t\t[url]https://play.google.com/store/apps/details?id=se.oskarpedersen.tunnelrayjumper[/url]",
            "flags": 48,
            "hasliked": 0,
            "id": "MlfcR8",
            "likes": 7,
            "name": "Jumping Game",
            "published": 3,
            "tags": [
                "raymarching",
                "game",
                "volumetric"
            ],
            "usePreview": 0,
            "username": "rammoskar",
            "viewed": 730
        },
        "renderpass": [
            {
                "code": "vec2 pos;\nfloat jumpDecay;\n\nconst vec2 txPos = vec2(0.0,0.0);\nconst vec2 txScore = vec2(1.0,0.0);\n\nfloat SampleDigit(const in float n, const in vec2 vUV)\n{\n    if( abs(vUV.x-0.5)>0.5 || abs(vUV.y-0.5)>0.5 ) return 0.0;\n\n    // digit data by P_Malin (https://www.shadertoy.com/view/4sf3RN)\n    float data = 0.0;\n         if(n < 0.5) data = 7.0 + 5.0*16.0 + 5.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    else if(n < 1.5) data = 2.0 + 2.0*16.0 + 2.0*256.0 + 2.0*4096.0 + 2.0*65536.0;\n    else if(n < 2.5) data = 7.0 + 1.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 3.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 4.5) data = 4.0 + 7.0*16.0 + 5.0*256.0 + 1.0*4096.0 + 1.0*65536.0;\n    else if(n < 5.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n    else if(n < 6.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n    else if(n < 7.5) data = 4.0 + 4.0*16.0 + 4.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 8.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    else if(n < 9.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    \n    vec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n    float fIndex = vPixel.x + (vPixel.y * 4.0);\n    \n    return mod(floor(data / pow(2.0, fIndex)), 2.0);\n}\n\nfloat PrintInt( in vec2 uv, in float value )\n{\n    float res = 0.0;\n    float maxDigits = 1.0+ceil(.01+log2(value)/log2(10.0));\n    float digitID = floor(uv.x);\n    if( digitID>0.0 && digitID<maxDigits )\n    {\n        float digitVa = mod( floor( value/pow(10.0,maxDigits-1.0-digitID) ), 10.0 );\n        res = SampleDigit( digitVa, vec2(fract(uv.x), uv.y) );\n    }\n\n    return res;\n}\n\n\nfloat udRoundBox( vec3 p, vec3 b, float r ) {\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat boxTunnelSq( vec2 p, vec2 b )\n{\n  vec2 d = abs(p) - b;\n  return length(max(d,0.0));\n}\n\n\n#define EPS 0.01\nfloat map(vec3 p, vec3 rd) {\n    float s = 1.2;\n    p.x += 100.0;\n    p.y += 93.0;\n    p.z += 100.8;\n\n    vec3 q = mod(p, s) - s * 0.5;\n    vec3 n = vec3(floor(p / s));\n    float len = 10.0;\n    float noObs = floor(min(1.0, mod(n.x, len)));\n    float beginnersGap = 0.5 * (1.0 - noObs) * max(0.0, 2.0 - ((p.x - 100.0) / (len * s * 5.0)));\n    float h = noObs * 5.0;\n    vec3 np = vec3(n.x, n.y + (1.0 - noObs) * sin(4.0 + n.x * 2.0 / len) * 4.0, n.z);\n    float dis = boxTunnelSq(np.yz - vec2(100.0 / s), vec2(1.0 + h + beginnersGap, 1.0));\n    if (dis > 0.0) {\n        return udRoundBox(q , vec3(0.5), 0.1);\n\n    }\n    vec3 d = (s * 0.5 -  sign(rd)* q) / abs(rd);\n    return max(EPS, min(d.x, min(d.y, d.z)) + EPS);\n}\n\nvec4 roofLight(vec3 p) {\nfloat s = 1.2;\n\tp.xy += 0.6;\n\tvec3 n = vec3(floor(p / s));\n\tp.xy = mod(p.xy, s) - s * 0.5;\n\tp.z = abs(p.z) - 1.0;\n\n\tvec3 lightCol = normalize(0.5 + 0.45 * sin(n.x * vec3(0.015, 0.03, 0.045)));\n\tfloat ds = dot(p, p); \n\tvec3 point = jumpDecay * lightCol * 2.0/(ds);\n\treturn vec4(point, (ds)); \n}\n\n\n\nvoid addLightning(inout vec3 color, vec3 normal, vec3 p, vec3 ro, vec3 rd) {\n    ro.x -= 3.0;\n    vec3 delta = ro - p;\n    float disSq = dot(delta, delta);\n    vec3 invLight = normalize(delta);\n    float diffuse = max(0.0, dot(invLight, normal));\n    float k = max(0.0, dot(rd, reflect(invLight, normal)));\n    float spec =  pow(k, 10.0);\n    float str = 20.0/(0.1  + 0.1*disSq);\n    color = color * diffuse*roofLight(p).xyz;\n    color += spec*str*jumpDecay;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec3 rd = vec3(1.0);\n\tvec3 normal;\n    vec3 ep = vec3(0.01, 0, 0);\n    normal.x = map(p + ep.xyz, rd) - map(p - ep.xyz, rd);\n    normal.y = map(p + ep.yxz, rd) - map(p - ep.yxz, rd);\n    normal.z = map(p + ep.yzx, rd) - map(p - ep.yzx, rd);\n    return normalize(normal);\n\n}\n\n\n#define fogAmount 0.01\nvec3 raymarch(vec3 ro, vec3 rd) {\n    vec3 color = vec3(0.0);\n    vec3 p = ro;\n    vec3 scatteredLight = vec3(0.0);\n    float transmittance = 1.0;\n    for (float i = 0.0; i < 100.0; i += 1.0) {\n        float d = map(p, rd);\n\n        vec4 light = roofLight(p);\n        d = min(d, max(sqrt(light.w), 0.1)); \n        vec3 lightIntegrated = light.xyz - light.xyz * exp(-fogAmount * d); \n        scatteredLight += transmittance * lightIntegrated;\n        transmittance *= exp(-fogAmount * d); \n\n        if (d < EPS) {\n            color = abs(p.z) < 1.2 && mod(floor((p.x + 0.4) / 1.2) + 3.0, 10.0) < 1.0 ? vec3(0.9, 0.2, 0.2) : vec3(0.5);\n            addLightning(color, getNormal(p), p, ro, rd);\n            color = color * transmittance + scatteredLight;\n            break;\n        }\n        p += rd * d;\n    }\n    return color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 data    = texture( iChannel0, (txPos+0.5)/iChannelResolution[0].xy ).xyzw;\n    vec2 score    = texture( iChannel0, (txScore+0.5)/iChannelResolution[0].xy ).xy;\n    pos = data.xy;\n    jumpDecay = data.w;\n    vec2 uv = (fragCoord.xy / iResolution.xy);\n    uv.y *= 1.5;\n    vec3 ro = vec3(pos.x + 0.0, pos.y + 8.0, 0);\n    vec3 rd = normalize(vec3(1.0, uv.y - 0.5, uv.x - 0.5));\n\n    vec3 color = raymarch(ro, rd);\n\t\n    color = color / (color + vec3(1.0));\n    \n    float s = PrintInt( (uv - vec2(0.0, 1.4)) * 30.0, max(0.0, score.x) );\n    float h = PrintInt( (uv - vec2(0.0, 1.3)) * 30.0, max(0.0, score.y) );\n    color = mix( color, vec3(1.0,1.0,1.0), max(s, h) );\n    \n    fragColor = vec4(color, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Multipass system for shadertoy not used in app, taken from: https://www.shadertoy.com/view/MddGzf\n\nconst vec2 txPos = vec2(0.0, 0.0); // posx posy vely jumpDecay\nconst vec2 txScore = vec2(1.0, 0.0); // score hi\n\nconst float KEY_SPACE = 32.5/256.0;\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nfloat isInside( vec2 p, vec4 c ) { vec2 d = abs(p-0.5-c.xy-c.zw*0.5) - 0.5*c.zw - 0.5; return -max(d.x,d.y); }\n\n\nvec4 loadValue( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\nvoid storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\nvoid storeValue( in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r ) {\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat boxTunnelSq( vec2 p, vec2 b )\n{\n  vec2 d = abs(p) - b;\n  return length(max(d,0.0));\n}\n\n#define EPS 0.01\nfloat map(vec2 pxy) {\n    vec3 p = vec3(pxy.x, pxy.y, 0.1);\n    float s = 1.2;\n    p.x += 100.0;\n    p.y += 93.0;\n    p.z += 100.8;\n\n    vec3 q = mod(p, s) - s * 0.5;\n    vec3 n = vec3(floor(p / s));\n    float len = 10.0;\n    float noObs = floor(min(1.0, mod(n.x, len)));\n    float beginnersGap = 0.5 * (1.0 - noObs) * max(0.0, 2.0 - ((p.x - 100.0) / (len * s * 5.0)));\n    float h = noObs * 5.0;\n    vec3 np = vec3(n.x, n.y + (1.0 - noObs) * sin(4.0 + n.x * 2.0 / len) * 4.0, n.z);\n    float dis = boxTunnelSq(np.yz - vec2(100.0 / s), vec2(1.0 + h + beginnersGap, 1.0));\n    if (dis > 0.0) {\n        return udRoundBox(q , vec3(0.5), 0.1);\n\n    }\n    return 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if( fragCoord.x > 14.0 || fragCoord.y>14.0 ) discard;\n    \n    vec4 pos = loadValue( txPos ).xyzw;\n    vec2 score = loadValue( txScore ).xy;\n    \n    score.x += 1.0 / 60.0;\n    score.y = max(score.x, score.y);\n    \n    pos.x += 0.05;\n    pos.z -= 0.002;\n    if (iMouse.zw == iMouse.xy || texture( iChannel1, vec2(KEY_SPACE,0.25) ).x > 0.5) {\n    \tpos.z = 0.1f;\n        pos.w = 1.0;\n    }\n    pos.y += pos.z;\n    pos.w *= 0.96f;\n    \n    if (map(pos.xy + vec2(0.0, 8.0)) <= 0.0) {\n    \tpos.x = 0.0;\n        pos.y = 0.0;\n        pos.z = 0.0;\n        pos.w = 1.0;\n        score.x = 0.0;\n    }\n    \n    fragColor = vec4(0.0);\n    \n    storeValue( txPos, vec4(pos.x, pos.y, pos.z, pos.w), fragColor, fragCoord );\n    storeValue( txScore, vec4(score.x, score.y, 0.0, 0.0), fragColor, fragCoord );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}