{
    "Shader": {
        "info": {
            "date": "1458663827",
            "description": "You can select the number of lives and enemies in Buf A\n- Enter: Start game\n- Arrow up\n- Arrow down\nThe game is a miniaturized ship who has to enter the body of a human being who has been infected by an alien virus.\nGet the highest score as possible.",
            "flags": 112,
            "hasliked": 0,
            "id": "MscSDn",
            "likes": 4,
            "name": "Alien virus attack!",
            "published": 3,
            "tags": [
                "raymarching",
                "pgatr",
                "migjrv",
                "urjc",
                "gpart",
                "migrvj"
            ],
            "usePreview": 0,
            "username": "jcanadilla",
            "viewed": 1321
        },
        "renderpass": [
            {
                "code": "/*//////////////////////////////////////////////////////////////////////////\n// MÃSTER UNIVERSITARIO INFORMÃTICA GRÃFICA, REALIDAD VIRTUAL Y JUEGOS    //\n// PROCESADORES GRÃFICOS Y APLICACIONES EN TIEMPO REAL                    //\n// JUEGO EN UN SHADER - GAME IN A SHADER                                  //\n// AUTORES:                                                               //\n// - Javier CaÃ±adilla Casco                                               //\n// - Cristian RodrÃ­guez Bernal                                            //\n//                                                                        //\n//////////////////////////////////////////////////////////////////////////*/\n\n//////////////////////////////////////////////////////////////////////////*/\n//                          CONFIGURATION\n// Please, modify this values to increment hearts and enemies (More enemies down the FPS)\n// (Modify this values in Buf A and Image shaders)\n#define MAX_LIVES   3\n#define MAX_ENEMIES 5\n//////////////////////////////////////////////////////////////////////////*/\n\n#define MAT_CABIN   1.0\n#define MAT_WINGS   2.0\n#define MAT_MOTOR1  3.0\n#define MAT_MOTOR2  4.0\n#define MAT_MOTOR3  5.0\n\n#define ENEMY_1     10.0\n#define ENEMY_2     11.0\n#define ENEMY_3     12.0\n#define ENEMY_4     13.0\n\nconst vec2 txCounter        = vec2(0.0, 0.0);\nconst vec2 txLives          = vec2(0.0, 1.0);\n\nconst vec2 txPoints         = vec2(1.0, 0.0);\nconst vec2 txState          = vec2(2.0, 0.0);\nconst vec2 txObstacle       = vec2(3.0, 0.0);\nconst vec2 txSpaceShipPos   = vec2(4.0, 0.0);\n\nconst vec2 txEnemies        = vec2(5.0, 0.0);\n\n\n\nconst vec3 cameraOrigin = vec3(0.0, 0.0, 10.0);\nconst vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\nconst vec3 upDirection = vec3(0.0, 1.0, 0.0);\n\n\n\n/*****  PRINT TEXT:  *****/\n//Code from:  https://www.shadertoy.com/view/XsBSDm\nfloat g_cw = 15.; // char width in normalized units\nfloat g_ch = 30.; // char height in normalized units\n\nfloat g_cwb = .6; // character width buffer as a percentage of char width\nfloat g_chb = .5; // line buffer as a percentage of char height\n\n// vertical segment with the bottom of the segment being s\n// and having length d\nfloat vd( vec2 s, float d, vec2 uv ) {    \n    float t = (d * (uv.y - s.y)) / (d*d);\n    t = clamp(t, 0., 1.);\n    return .1 * length((s + t * vec2(0., d)) - uv);\n}\n\n// horizontal segment with the left of the segment being s\n// and having length d\nfloat hd( vec2 s, float d, vec2 uv ) {    \n    float t = (d * (uv.x - s.x)) / (d*d);\n    t = clamp(t, 0., 1.);\n    return .1 * length((s + t * vec2(d, 0.)) - uv);\n}\n\n// divide the experience into cells.\nvec2 mod_uv(vec2 uv) {\n    return vec2(mod(uv.x, g_cw * (1. + g_cwb)), \n                mod(uv.y, g_ch * (1. + g_chb)));\n}\n\n// ---------------------------------------------\n// ALPHABET\nfloat a(vec2 uv) {    \n    float r = vd(vec2(0.), g_ch * .9, uv);\n    r = min(r, hd(vec2(g_cw * .1, g_ch), g_cw * .8, uv));\n    r = min(r, vd(vec2(g_cw, 0.), g_ch * .9, uv));\n    r = min(r, hd(vec2(0., g_ch * .6), g_cw, uv));\n    return r;\n}\n\nfloat b(vec2 uv) {    \n    float r = vd(vec2(0.), g_ch, uv);\n    r = min(r, hd(vec2(.0, g_ch), g_cw, uv));\n    r = min(r, vd(vec2(g_cw, g_ch * .7), g_ch * .3, uv));\n    r = min(r, hd(vec2(0., g_ch * .6), g_cw * .8, uv));\n    r = min(r, vd(vec2(g_cw, 0.), g_ch * .5, uv));\n    r = min(r, hd(vec2(0.), g_cw, uv));\n    return r;\n}\n\nfloat c(vec2 uv) {    \n    float r = vd(vec2(0., g_ch * .1), g_ch * .8, uv);\n    r = min(r, hd(vec2(g_cw * .1, 0.), g_cw * .9, uv));\n    r = min(r, hd(vec2(g_cw * .1, g_ch), g_cw * .9, uv));\n    return r;\n}\n\nfloat d(vec2 uv) {    \n    float r = vd(vec2(0.), g_ch, uv);\n    r = min(r, vd(vec2(g_cw, g_ch * .1), g_ch * .8, uv));\n    r = min(r, hd(vec2(0.), g_cw * .9, uv));\n    r = min(r, hd(vec2(.0, g_ch), g_cw * .9, uv));\n    return r;\n}\n\nfloat e(vec2 uv) {    \n    float r = hd(vec2(.0, g_ch), g_cw, uv);\n    r = min(r, vd(vec2(0.), g_ch, uv));\n    r = min(r, hd(vec2(0.), g_cw, uv));\n    r = min(r, hd(vec2(0., g_ch * .6), g_cw * .8, uv));\n    return r;\n}\n\nfloat f(vec2 uv) {\n    float r = hd(vec2(0., g_ch), g_cw, uv);\n    r = min(r, vd(vec2(0.), g_ch, uv));\n    r = min(r, hd(vec2(0., g_ch * .6), g_cw * .8, uv));\n    return r;\n}\n\nfloat g(vec2 uv) {    \n    float r = hd(vec2(g_cw * .1, g_ch), g_cw * .8, uv);\n    r = min(r, vd(vec2(0., g_ch * .1), g_ch * .8, uv));\n    r = min(r, hd(vec2(g_cw * .1, 0.), g_cw * .8, uv));\n    r = min(r, vd(vec2(g_cw, .1 * g_ch), g_ch * .4, uv));\n    r = min(r, hd(vec2(g_cw * .5, g_ch * .6), g_cw * .4, uv));\n    return r;\n}\n\nfloat h(vec2 uv) {    \n    float r = vd(vec2(0.), g_ch, uv);\n    r = min(r, vd(vec2(g_cw, 0.), g_ch, uv));\n    r = min(r, hd(vec2(.0, g_ch * .6), g_cw, uv));\n    return r;\n}\nfloat i(vec2 uv) {    \n    float r = hd(vec2(0.), g_cw, uv);\n    r = min(r, vd(vec2(g_cw * .5, 0.), g_ch, uv));\n    r = min(r, hd(vec2(0., g_ch), g_cw, uv));\n    return r;\n}\n\nfloat j(vec2 uv) {    \n    float r = vd(vec2(g_cw, g_ch * .1), g_ch * .9, uv);\n    r = min(r, hd(vec2(g_cw * .1, 0.), g_cw * .8, uv));\n    r = min(r, vd(vec2(0., g_ch * .1), g_ch * .2, uv));\n    return r;\n}\n\nfloat k(vec2 uv) {    \n    float r = vd(vec2(0.), g_ch, uv);\n    r = min(r, vd(vec2(g_cw, g_ch*.7), g_ch * .3, uv));\n    r = min(r, vd(vec2(g_cw, 0.), g_ch * .5, uv));\n    r = min(r, hd(vec2(0., g_ch * .6), g_cw * .8, uv));\n    return r;\n}\n\nfloat l(vec2 uv) {    \n    float r = vd(vec2(0.), g_ch, uv);\n    r = min(r, hd(vec2(0.), g_cw, uv));\n    return r;\n}\n\nfloat m(vec2 uv) {    \n    float r = vd(vec2(0.), g_ch, uv);\n    r = min(r, vd(vec2(g_cw, 0.), g_ch, uv));\n    r = min(r, hd(vec2(0., g_ch), g_cw * .3, uv));\n    r = min(r, vd(vec2(g_cw * .5, g_ch * .6), .3 * g_ch, uv));\n    r = min(r, hd(vec2(g_cw * .7, g_ch), g_cw * .3, uv));\n    return r;\n}\n\nfloat n(vec2 uv) {    \n    float r = vd(vec2(0.), g_ch, uv);\n    r = min(r, vd(vec2(g_cw, 0.), g_ch, uv));    \n    r = min(r, vd(vec2(g_cw * .1, g_ch * .9), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .3, g_ch * .7), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .5, g_ch * .5), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .7, g_ch * .3), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .9, 0.), g_ch * .2, uv));\n    return r;\n}\n\nfloat o(vec2 uv){    \n    float r = vd(vec2(0., g_ch * .1), g_ch * .8, uv);\n    r = min(r, hd(vec2(g_cw * .1, g_ch), g_cw * .8, uv));\n    r = min(r, vd(vec2(g_cw, g_ch * .1), g_ch * .8, uv));\n    r = min(r, hd(vec2(g_cw * .1, 0.), g_cw * .8, uv));\n    return r;\n}\n\nfloat p(vec2 uv) {    \n    float r = vd(vec2(0.), g_ch, uv);\n    r = min(r, hd(vec2(0., g_ch), g_cw, uv));\n    r = min(r, vd(vec2(g_cw, g_ch * .7), g_ch * .3, uv));\n    r = min(r, hd(vec2(0., g_ch * .6), g_cw * .8, uv));\n    return r;\n}\nfloat q(vec2 uv) {    \n    float r = vd(vec2(0., g_ch * .1), g_ch * .8, uv);\n    r = min(r, hd(vec2(g_cw * .1, g_ch), g_cw * .8, uv));\n    r = min(r, vd(vec2(g_cw, g_ch * .1), g_ch * .8, uv));\n    r = min(r, hd(vec2(g_cw * .1, 0.), g_cw * .8, uv));    \n    r = min(r, vd(vec2(g_cw * .7, g_ch * -.05), g_cw * .4, uv));\n    return r;\n}\n\nfloat r(vec2 uv) {    \n    float r = vd(vec2(0.), g_ch, uv);\n    r = min(r, hd(vec2(.0, g_ch), g_cw, uv));\n    r = min(r, vd(vec2(g_cw, g_ch * .7), g_ch * .3, uv));\n    r = min(r, hd(vec2(0., g_ch * .6), g_cw * .8, uv));\n    r = min(r, vd(vec2(g_cw, 0.), g_ch * .5, uv));\n    return r;\n}\n\nfloat s(vec2 uv) {    \n    float r = hd(vec2(0.), g_cw * .9, uv);\n    r = min(r, vd(vec2(g_cw, g_ch * .1), g_ch * .4, uv));\n    r = min(r, hd(vec2(g_cw * .2, g_ch * .6), g_cw * .7, uv));\n    r = min(r, vd(vec2(0., g_ch * .7), g_ch * .2, uv));\n    r = min(r, hd(vec2(g_cw * .2, g_ch), g_cw * .8, uv));\n    return r;\n}\n\nfloat t(vec2 uv) {    \n    float r = hd(vec2(0., g_ch), g_cw, uv);\n    r = min(r, vd(vec2(g_cw * .5, 0.), g_ch, uv));\n    return r;\n}\n\nfloat u(vec2 uv) {    \n    float r = vd(vec2(0., g_ch * .1), g_ch * .9, uv);\n    r = min(r, hd(vec2(g_cw * .1, 0.), g_cw * .8, uv));\n    r = min(r, vd(vec2(g_cw, g_ch * .1), g_ch * .9, uv));\n    return r;\n}\n\nfloat v(vec2 uv) {    \n    float r = vd(vec2(0., g_ch * .5), g_ch * .5, uv);\n    r = min(r, vd(vec2(g_cw, g_ch * .5), g_ch * .5, uv));\n    r = min(r, vd(vec2(g_cw * .2, g_ch * .2), g_ch * .2, uv));\n    r = min(r, vd(vec2(g_cw * .8, g_ch * .2), g_ch * .2, uv));\n    r = min(r, vd(vec2(g_cw * .5, 0.), g_ch * .1, uv));\n    return r;\n}\n\nfloat w(vec2 uv) {    \n    float r = vd(vec2(0.), g_ch, uv);\n    r = min(r, vd(vec2(g_cw, 0.), g_ch, uv));\n    r = min(r, vd(vec2(g_cw * .5, g_ch * .1), g_ch * .3, uv));\n    r = min(r, hd(vec2(0.), g_cw * .3, uv));\n    r = min(r, hd(vec2(g_cw * .7, 0.), g_cw * .3, uv));\n    return r;\n}\n\nfloat x(vec2 uv) {    \n    float r = vd(vec2(0., g_ch * .9), g_ch * .1, uv);\n    r = min(r, vd(vec2(g_cw * .2, g_ch * .7), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .5, g_ch * .5), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .8, g_ch * .3), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw, 0.), g_ch * .2, uv));    \n    r = min(r, vd(vec2(g_cw, g_ch * .9), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .8, g_ch * .7), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .2, g_ch * .3), g_ch * .1, uv));    \n    r = min(r, vd(vec2(0.), g_ch * .2, uv));\n    \n    return r;\n}\n\nfloat y(vec2 uv) {    \n    float r = vd(vec2(0., g_ch * .8), g_ch * .2, uv);\n    r = min(r, vd(vec2(g_cw * .2, g_ch * .6), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .8, g_ch * .6), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw, g_ch * .8), g_ch * .2, uv));\n    r = min(r, vd(vec2(g_cw * .5, 0.), g_ch * .5, uv));\n    \n    return r;\n}\n\nfloat z(vec2 uv) {    \n    float r = hd(vec2(0., g_ch), g_cw, uv);\n    r = min(r, vd(vec2(g_cw * .9, g_ch * .9), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .7, g_ch * .7), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .5, g_ch * .5), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .3, g_ch * .3), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .1, g_ch * .1), g_ch * .1, uv));\n    r = min(r, hd(vec2(0.), g_cw, uv));\n    return r;\n}\n\n// ---------------------------------------------\n// MACROS\n\n#define A if (cs == idx) { tx = min(tx, a(uv)); } idx++;\n#define B if (cs == idx) { tx = min(tx, b(uv)); } idx++;\n#define C if (cs == idx) { tx = min(tx, c(uv)); } idx++;\n#define D if (cs == idx) { tx = min(tx, d(uv)); } idx++;\n#define E if (cs == idx) { tx = min(tx, e(uv)); } idx++;\n#define F if (cs == idx) { tx = min(tx, f(uv)); } idx++;\n#define G if (cs == idx) { tx = min(tx, g(uv)); } idx++;\n#define H if (cs == idx) { tx = min(tx, h(uv)); } idx++;\n#define I if (cs == idx) { tx = min(tx, i(uv)); } idx++;\n#define J if (cs == idx) { tx = min(tx, j(uv)); } idx++;\n#define K if (cs == idx) { tx = min(tx, k(uv)); } idx++;\n#define L if (cs == idx) { tx = min(tx, l(uv)); } idx++;\n#define M if (cs == idx) { tx = min(tx, m(uv)); } idx++;\n#define N if (cs == idx) { tx = min(tx, n(uv)); } idx++;\n#define O if (cs == idx) { tx = min(tx, o(uv)); } idx++;\n#define P if (cs == idx) { tx = min(tx, p(uv)); } idx++;\n#define Q if (cs == idx) { tx = min(tx, q(uv)); } idx++;\n#define R if (cs == idx) { tx = min(tx, r(uv)); } idx++;\n#define S if (cs == idx) { tx = min(tx, s(uv)); } idx++;\n#define T if (cs == idx) { tx = min(tx, t(uv)); } idx++;\n#define U if (cs == idx) { tx = min(tx, u(uv)); } idx++;\n#define V if (cs == idx) { tx = min(tx, v(uv)); } idx++;\n#define W if (cs == idx) { tx = min(tx, w(uv)); } idx++;\n#define X if (cs == idx) { tx = min(tx, x(uv)); } idx++;\n#define Y if (cs == idx) { tx = min(tx, y(uv)); } idx++;\n#define Z if (cs == idx) { tx = min(tx, z(uv)); } idx++;\n#define SP idx++;\n#define NL idx+=int(cc - mod(float(idx), cc));\n\n// ---------------------------------------------\n\n\n// Periodic saw tooth function that repeats with a period of \n// 4 and ranges from [-1, 1].  \n// The function starts out at 0 for x=0,\n//  raises to 1 for x=1,\n//  drops to 0 for x=2,\n//  continues to -1 for x=3,\n//  and then rises back to 0 for x=4\n// to complete the period\n\nvec3 drawText( in vec4 fragColor, in vec2 fragCoord ) {\n    float display_width = 1010.;\n    float cc = floor(display_width / (g_cw * (1. + g_cwb))); // character count per line\n    \n    vec2 uv = (fragCoord.xy) / iResolution.xx;\n    uv.y = iResolution.y/iResolution.x - uv.y;  // type from top to bottom, left to right   \n    uv *= display_width;\n\n    int cs = int(floor(uv.x / (g_cw * (1. + g_cwb))) + cc * floor(uv.y/(g_ch * (1. + g_chb))));\n\n    uv = mod_uv(uv);\n    uv.y = g_ch * (1. + g_chb) - uv.y; // paint the character from the bottom left corner\n    vec3 ccol = .35 * vec3(.1, .3, .2) * max(smoothstep(3., 0., uv.x), smoothstep(5., 0., uv.y));   \n    uv -= vec2(g_cw * g_cwb * .5, g_ch * g_chb * .5);\n    \n    float tx = 10000.;\n    int idx = 0;\n    \n    NL \n    NL \n    NL \n    NL \n    NL \n    NL \n    SP SP SP SP SP SP SP SP SP SP SP SP SP SP SP SP G A M E SP O V E R \n    NL\n        \n    vec3 tcol = vec3(.7, 1., .8) * smoothstep(.2, .0, tx);\n    \n    vec3 terminal_color = tcol;\n    \n    return terminal_color;\n}   \n\n\nvec3 drawText2( in vec4 fragColor, in vec2 fragCoord ) {\n    float display_width = 1010.;\n    float cc = floor(display_width / (g_cw * (1. + g_cwb))); // character count per line\n    \n    vec2 uv = (fragCoord.xy) / iResolution.xx;\n    uv.y = iResolution.y/iResolution.x - uv.y;  // type from top to bottom, left to right   \n    uv *= display_width;\n\n    int cs = int(floor(uv.x / (g_cw * (1. + g_cwb))) + cc * floor(uv.y/(g_ch * (1. + g_chb))));\n\n    uv = mod_uv(uv);\n    uv.y = g_ch * (1. + g_chb) - uv.y; // paint the character from the bottom left corner\n    vec3 ccol = .35 * vec3(.1, .3, .2) * max(smoothstep(3., 0., uv.x), smoothstep(5., 0., uv.y));   \n    uv -= vec2(g_cw * g_cwb * .5, g_ch * g_chb * .5);\n    \n    float tx = 10000.;\n    int idx = 0;\n    \n    NL \n    NL \n    NL \n    NL \n    NL \n    NL \n    SP SP SP SP SP SP SP SP SP SP SP P R E S S SP E N T E R SP T O SP S T A R T\n    NL\n    vec3 tcol = vec3(.7, 1., .8) * smoothstep(.2, .0, tx);\n    \n    vec3 terminal_color = tcol;\n    \n    return terminal_color;\n} \n\n\n\n/***** END PRINT TEXT *****/\n\n\n/***** PRINT DIGITS *****/\n//Code from IQ's shader: https://www.shadertoy.com/view/MddGzf\n\nfloat SampleDigit(const in float n, const in vec2 vUV) {\n    if( abs(vUV.x-0.5)>0.5 || abs(vUV.y-0.5)>0.5 ) return 0.0;\n\n    // digit data by P_Malin (https://www.shadertoy.com/view/4sf3RN)\n    float data = 0.0;\n         if(n < 0.5) data = 7.0 + 5.0*16.0 + 5.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    else if(n < 1.5) data = 2.0 + 2.0*16.0 + 2.0*256.0 + 2.0*4096.0 + 2.0*65536.0;\n    else if(n < 2.5) data = 7.0 + 1.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 3.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 4.5) data = 4.0 + 7.0*16.0 + 5.0*256.0 + 1.0*4096.0 + 1.0*65536.0;\n    else if(n < 5.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n    else if(n < 6.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n    else if(n < 7.5) data = 4.0 + 4.0*16.0 + 4.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 8.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    else if(n < 9.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    \n    vec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n    float fIndex = vPixel.x + (vPixel.y * 4.0);\n    \n    return mod(floor(data / pow(2.0, fIndex)), 2.0);\n}\n\nfloat PrintInt( in vec2 uv, in float value ) {\n    float res = 0.0;\n    float maxDigits = 1.0+ceil(.01+log2(value)/log2(10.0));\n    float digitID = floor(uv.x);\n    if( digitID>0.0 && digitID<maxDigits ) {\n        float digitVa = mod( floor( value/pow(10.0,maxDigits-1.0-digitID) ), 10.0 );\n        res = SampleDigit( digitVa, vec2(fract(uv.x), uv.y) );\n    }\n\n    return res;\n}\n\n// save/load code from IQ's shader: https://www.shadertoy.com/view/MddGzf\nvec4 loadValue( in vec2 re ) {\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\n//===============\n\n//Translate/Rotate code from: http://blog.ruslans.com/2015/01/raymarching-christmas-tree.html\nvec3 translate(vec3 p, vec3 d) {\n    return p - d;\n}\n\nvec2 rotate(vec2 p, float ang) {\n    float c = cos(ang), s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nvec2 translate2D(vec2 p, vec2 d) {\n    return p - d;\n}\n\n/** FIGURAS IQ **/\n//https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, float s ) {\n  return length(p)-s;\n}\n\nfloat udBox( vec3 p, vec3 b ) {\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r ) {\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )  {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCylinder( vec3 p, vec3 c ) {\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdPlane( vec3 p, vec4 n ) {\n  n = normalize(n);\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h ) {\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdCappedCone( in vec3 p, in vec3 c ) {\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n    vec2 w = v - q;\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n    vec2 d = max(qv,0.0)*qv/vv;\n    return sqrt( dot(w,w) - max(d.x,d.y) )* sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\n/** FIGURAS IQ **/\n\n/** OPERACIONES IQ **/\n//https://iquilezles.org/articles/distfunctions\n\nfloat opU(float d1, float d2) {\n    return min(d2, d1);\n}\n\nfloat opS( float d1, float d2 ) {\n    return max(-d1,d2);\n}\n\nfloat opI( float d1, float d2 ) {\n    return max(d1,d2);\n}\n\nfloat smin( float a, float b, float k ) {\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat opBlend( float f1, float f2, float k ) {\n    return smin( f1, f2, k);\n}\n\n/** END OPERACIONES IQ **/\n\n// SCENE OBJECTS\n\nfloat createSpaceShip(vec3 pos, out float cabin, out float wing, out float mot1, out float mot2, out float mot3){\n    \n    float result;\n    vec2 spaceShipPos = loadValue(txSpaceShipPos).xy;\n    float c = sdCapsule(pos, vec3(spaceShipPos.x, spaceShipPos.y, 0.0), vec3(spaceShipPos.x + 1.6, spaceShipPos.y, 0.0), 0.8);\n    \n    vec3 posPilot = pos;\n    posPilot.xz = rotate(posPilot.xz, 3.1416 * 0.450);\n    float c2 = sdCapsule(posPilot, vec3(-1.5, spaceShipPos.y-0.3, spaceShipPos.x + 2.1), vec3(-1.0, spaceShipPos.y-0.3, spaceShipPos.x + 1.80), 0.5);\n    \n    vec3 posCabin = pos;\n    posCabin.xz = rotate(posCabin.xz, 3.1416 * 0.450);\n    cabin = sdCapsule(posCabin, vec3(-1.5, spaceShipPos.y-0.3, spaceShipPos.x + 2.1), vec3(-1.0, spaceShipPos.y-0.3, spaceShipPos.x + 1.80), 0.5);\n\n    vec3 posWing = translate(pos,  vec3(spaceShipPos, 0.0) - vec3(-0.90, 0.0, -0.0));\n    posWing.yz = rotate(posWing.yz, 3.1416 * -0.45);\n    wing = udRoundBox(posWing, vec3(0.5, 1.50, 0.0), 0.2);\n        \n    mot1 = sdCapsule(pos, vec3(spaceShipPos.x - 1.2, spaceShipPos.y, 0.0),       vec3(spaceShipPos.x-0.80, spaceShipPos.y, 0.0), 0.2);\n    mot2 = sdCapsule(pos, vec3(spaceShipPos.x - 1.0, spaceShipPos.y-0.3, -0.20), vec3(spaceShipPos.x-0.80 , spaceShipPos.y-0.3, -0.20), 0.2);\n    mot3 = sdCapsule(pos, vec3(spaceShipPos.x - 0.9, spaceShipPos.y+0.1,  0.30), vec3(spaceShipPos.x-0.80 , spaceShipPos.y+0.1, 0.30), 0.2);\n        \n    result = opS(c2, c);\n    \n    return result;\n}\nfloat createFloorCeiling(vec3 pos){\n    float result;\n    \n    float box1  = sdBox(translate(pos, vec3(0.0, 9.0, 0.0)), vec3(iResolution.x, 3.0, 3.0*15.0));\n    float box2 = sdBox(translate(pos, vec3(0.0, -9.0, 0.0)), vec3(iResolution.x, 1.0, 1.0*15.0));\n                       \n    result = opU(box1, box2);\n\n    return result;\n}\n\nfloat createBackground(vec3 pos){\n \n    float result;\n    float back = sdBox(translate(pos, vec3(0.0, 0.0, -2.0)), vec3(iResolution.x, iResolution.y, 1.0));\n    result = back;\n    return result;\n    \n}\n\nvec2 createEnemy(vec3 pos, in vec2 texture) {\n    vec4 tex = loadValue(texture);\n    vec3 paux = translate(pos, tex.xyz);\n    paux.yz = rotate(paux.yz, -3.1416 * iTime);\n    float box = sdTorus(paux, vec2(0.5, 0.2));\n    return vec2(box, tex.w);\n}\n\n\n//Scene's objects mapping.\nvec2 mapObjects(in vec3 pos){\n    \n    float cabinPos, wingPos, motor1Pos, motor2Pos, motor3Pos;\n       \n    //Create Spaceship\n    vec2 spaceship = vec2(createSpaceShip(pos, cabinPos, wingPos, motor1Pos, motor2Pos, motor3Pos), 0.0);\n    vec2 result = spaceship;\n   \n    vec2 cabin  = vec2(cabinPos,  MAT_CABIN);\n    vec2 wing   = vec2(wingPos,   MAT_WINGS);\n    vec2 motor1 = vec2(motor1Pos, MAT_MOTOR1);\n    vec2 motor2 = vec2(motor2Pos, MAT_MOTOR2);\n    vec2 motor3 = vec2(motor3Pos, MAT_MOTOR3);\n        \n    if(cabin.x  < result.x) result = cabin;\n    if(wing.x   < result.x) result = wing;\n    if(motor1.x < result.x) result = motor1;\n    if(motor2.x < result.x) result = motor2;\n    if(motor3.x < result.x) result = motor3;\n    \n    //Create ceiling and floor\n    vec2 floorCeiling = vec2( createFloorCeiling(pos), 6.0);\n    if( floorCeiling.x < result.x) result = floorCeiling;\n    \n   \n    for(int id = 0; id < MAX_ENEMIES; id++) {\n        vec2 enemy = createEnemy(pos, vec2(txEnemies.x, float(id)));\n        if(enemy.x < result.x) result = enemy;\n    }\n    \n    //Create background\n    vec2 background = vec2 (createBackground(pos), 8.0);\n    if(background.x < result.x) result = background;\n    \n    return result;\n    \n}\n\n\n//Calculate the material's color with its matID\nvec4 calculateColor (in vec3 pos, in vec3 nor, float matID, vec2 uv){\n    vec4 colorMat = vec4(0.0);\n         if(matID < 0.5) colorMat = vec4(1.0, 0.0, 0.0, 0.0);\n    else if(matID < 1.5) colorMat = vec4(0.34, 0.98, 0.81, 0.0);                        //Cabin\n    else if(matID < 2.5) colorMat = vec4(1.0, 0.68, 0.0, 0.0);                          //Wings\n    else if(matID < 3.5) colorMat = vec4(141.0/255.0, 139.0/255.0, 136.0/255.0, 0.0);   //Motor1\n    else if(matID < 4.5) colorMat = vec4(105.0/255.0, 104.0/255.0, 102.0/255.0, 0.0);   //Motor2\n    else if(matID < 5.5) colorMat = vec4(154.0/255.0, 153.0/255.0, 149.0/255.0, 0.0);   //Motor3\n    else if(matID < 6.5) colorMat = vec4(vec3(texture(iChannel1, uv).rgb)*0.7, 0.0);\n    else if(matID < 7.5) colorMat = vec4(0.0, 1.0, 1.0, 0.0);\n    else if(matID < 8.5) colorMat = vec4(vec3(texture(iChannel1, uv).rgb), 0.0);\n    \n    else if(matID == ENEMY_1) {\n        colorMat = vec4(1.0);\n    }\n    else if(matID == ENEMY_2) {\n        colorMat = vec4(0.0, 0.5, 1.0, 1.0);\n    }\n    else if(matID == ENEMY_3) {\n        colorMat = vec4(0.0, 1.0, 0.5, 1.0);\n    }\n    else if(matID == ENEMY_4) {\n        colorMat = vec4(1.0, 0.0, 0.0, 1.0);\n    }\n        \n    else colorMat = vec4 (0.0);\n    return colorMat;\n}\n\n//Ambient occlussion, code from: https://www.shadertoy.com/view/Xds3zN\nfloat calculateAmbientOcclusion( in vec3 pos, in vec3 nor ) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for(int i = 0; i < 5; i++) {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = mapObjects( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n//Calculate normal, code from: http://blog.ruslans.com/2015/01/raymarching-christmas-tree.html\nconst float NORMAL_EPS = 0.001;\nvec3 calculateNormal(in vec3 p, const vec2 uv){\n    vec2 d = vec2(NORMAL_EPS, 0.0);\n    return normalize(vec3(mapObjects(p + d.xyy).x - mapObjects(p - d.xyy).x,\n                          mapObjects(p + d.yxy).x - mapObjects(p - d.yxy).x,\n                          mapObjects(p + d.yyx).x - mapObjects(p - d.yyx).x));\n}\n\n// Code from https://www.shadertoy.com/view/XsfGRn\nvoid drawLives(in vec2 p2, int hearts, out vec4 result) {\n    for(int i = 0; i < MAX_LIVES; i++) {\n        \n        if(i >= hearts) break;\n        \n        vec2 p = translate2D(p2, vec2(float(i)*2.0, 0.0));\n\n        // shape\n        float a = atan(p.x,p.y)/3.141593;\n        float r = length(p);\n        float h = abs(a);\n        float d = (13.0*h - 22.0*h*h + 10.0*h*h*h)/(6.0-5.0*h);\n\n        // color\n        float s = 1.0-0.5*clamp(r/d,0.0,1.0);\n        s = 0.75 + 0.75*p.x;\n        s *= 1.0-0.25*r;\n        s = 0.5 + 0.6*s;\n        s *= 0.5+0.5*pow( 1.0-clamp(r/d, 0.0, 1.0 ), 0.1 );\n        vec3 hcol = vec3(1.0,0.0,0.0)*s;\n\n        result.xyz = mix( result.xyz, hcol, smoothstep( -0.01, 0.01, d-r) );\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    float state = loadValue(txState).x;\n    int hearts = int(loadValue(txLives).x);\n    vec4 result;\n\n    \n    if(state == -2.0) {\n        result.xyz = mix(result.xyz, drawText2(fragColor, fragCoord), (0.5+0.5*sin(25.0*iTime)));  \n    } else {\n        \n        const int MAX_ITER = 200; // 100 is a safe number to use, it won't produce too many artifacts and still be quite fast\n        const float MAX_DIST = 40.0; // Make sure you change this if you have objects farther than 20 units away from the camera\n        const float EPSILON = 0.001; // At this distance we are close enough to the object that we have essentially hit it\n\n        vec3 cameraDir = normalize(cameraTarget - cameraOrigin);\n        vec3 cameraRight = normalize(cross(upDirection, cameraOrigin ));\n        vec3 cameraUp = cross(cameraDir, cameraRight);\n\n        vec2 uv = fragCoord.xy / iResolution.xy;\n        vec2 screenPos = -1.0 + 2.0 * gl_FragCoord.xy / iResolution.xy; // screenPos can range from -1 to 1\n        screenPos.x *= iResolution.x / iResolution.y; // Correct aspect ratio\n\n        //Calculating the ray direction is simple because we have camera direction\n        vec3 rayDir = normalize(cameraRight * screenPos.x + cameraUp * screenPos.y + cameraDir);\n\n        //Raymarching loop:\n        float t = 0.0;\n        vec3 pos = cameraOrigin;\n        float h = EPSILON * 2.0;\n        float mat = -1.0;\n        for(int i = 0; i < MAX_ITER; i++){\n            if(h < EPSILON || t > MAX_DIST) break;\n            t += h;\n            vec2 obj = mapObjects(cameraOrigin + rayDir * t); //Evaluate the distance at the current point\n            h  = obj.x;\n            mat = obj.y;\n            pos += h * rayDir; //Advance the point forwards in the ray direction by the distance\n            if(t>MAX_DIST) mat = -1.0;\n        }\n\n        //Lighting\n        if(mat > -0.5){\n            //Lighting code   \n            //Calculate normal:\n            vec3 ligh = normalize( vec3(-0.6, 0.7, -0.5) );\n            vec2 eps = vec2(0.0, EPSILON);\n\n            vec3 normal = calculateNormal(pos, uv);\n            vec3 reflection = reflect( rayDir, normal );\n            float occ = calculateAmbientOcclusion(pos, normal);\n            vec4 color = calculateColor(pos, normal, mat, uv);\n\n            float ambiental = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );\n            float diffuse = max(0.0, dot(-rayDir, normal));\n            float specular = pow(clamp( dot( reflection, ligh ), 0.0, 1.0 ),16.0);\n            \n\n            vec3 finalColor = vec3(0.7, 0.9, 1.0) +rayDir.y*0.8;\n            vec3 lin = vec3(0.0);\n            lin += 1.20*diffuse*vec3(1.00,1.0,0.55);\n            lin += 1.90*specular*vec3(1.00,1.0,0.55)*diffuse;\n            lin += 0.20*ambiental*vec3(0.50,0.70,1.00)*occ;\n\n            finalColor = finalColor*lin*color.xyz;\n\n            result = vec4(finalColor, 0.0);\n        } else  {\n            vec3 textura = texture(iChannel0, uv).rgb;\n            result = vec4(textura,1.0);\n        }    \n\n\n        //------------------------\n        // game over\n        //------------------------\n        if(loadValue(txState).x == 1.0) {\n            result.xyz = mix(result.xyz, drawText(fragColor, fragCoord), 1.5);   \n        }\n        result.xyz = mix( result.xyz, vec3(0.2,1.0,0.2), state * (0.5+0.5*sin(30.0*iTime)) );\n    \n        vec2 p2 = (20.0*fragCoord.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\n\n        p2 = translate2D(p2, vec2(0.0, 18.0));\n        drawLives(p2, hearts, result);\n        float points = loadValue(txPoints).x;\n        vec2 posCounter = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n        posCounter.x -= 2.75;\n        float f = PrintInt( (posCounter-vec2(-1.5,0.8))*10.0, points );\n        result.xyz = mix( result.xyz, vec3(1.0,1.0,1.0), f );\n        \n    }\n        \n    fragColor = result;\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "musicstream",
                        "id": 2542,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/theartax/artax-castle-of-8bits-vs"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*//////////////////////////////////////////////////////////////////////////\n// MÃSTER UNIVERSITARIO INFORMÃTICA GRÃFICA, REALIDAD VIRTUAL Y JUEGOS    //\n// PROCESADORES GRÃFICOS Y APLICACIONES EN TIEMPO REAL                    //\n// JUEGO EN UN SHADER - GAME IN A SHADER                                  //\n// AUTORES:                                                               //\n// - Javier CaÃ±adilla Casco                                               //\n// - Cristian RodrÃ­guez Bernal                                            //\n//                                                                        //\n//////////////////////////////////////////////////////////////////////////*/\n\n//////////////////////////////////////////////////////////////////////////*/\n//\t\t\t\t\t\t\tCONFIGURATION\n// Please, modify this values to increment hearts and enemies (More enemies down the FPS)\n// (Modify this values in Buf A and Image shaders)\n#define MAX_LIVES\t3\n#define MAX_ENEMIES 5\n//////////////////////////////////////////////////////////////////////////*/\n\n#define ENEMY_1     10.0\n#define ENEMY_2     11.0\n#define ENEMY_3     12.0\n#define ENEMY_4     13.0\n\nconst vec2 txCounter        = vec2(0.0, 0.0);\nconst vec2 txLives       \t= vec2(0.0, 1.0);\n\nconst vec2 txPoints         = vec2(1.0, 0.0);\nconst vec2 txState          = vec2(2.0, 0.0);\nconst vec2 txObstacle       = vec2(3.0, 0.0);\nconst vec2 txSpaceShipPos   = vec2(4.0, 0.0);\nconst vec2 txEnemies        = vec2(5.0, 0.0);\n\n\nconst float KEY_SPACE       = 32.5/256.0;\nconst float KEY_UP          = 38.5/256.0;\nconst float KEY_DOWN        = 40.5/256.0;\nconst float KEY_R           = 82.5 / 256.0;\nconst float KEY_RETURN      = 13.5 / 256.0;\n\n#define STATE_ON_MENU   -2.0\n#define STATE_ON_START  -1.0\n#define STATE_ON_GAME    0.0\n#define STATE_ON_OVER    1.0\n\n#define GAME_MENU       state.x == STATE_ON_MENU\n#define GAME_START      state.x == STATE_ON_START\n#define GAME_PLAY       state.x == STATE_ON_GAME\n#define GAME_FINISH     state.x == STATE_ON_OVER\n\n#define SPACESHIP_SIZE 3.6\n\n\nfloat i;\nbool collisionSpaceShipTramp(out vec2 spaceShipPos, out vec2 tramp);\nfloat new_pos();\nvoid resetEnemy(out vec4 enemy);\nfloat selectColor();\n    \n\n// HASH [0, 1]\nfloat Hash0_1( float n ) {\n    return fract( (1.0 + cos(n)) * 415.92653);\n}\n\n//============================================================\n\nfloat keyPress(float ascii) {\n    return texture(iChannel1, vec2((float(ascii))/256., 0.0)).x ;\n}\n\n// save/load code from IQ's shader: https://www.shadertoy.com/view/MddGzf\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nfloat isInside( vec2 p, vec4 c ) { vec2 d = abs(p-0.5-c.xy-c.zw*0.5) - 0.5*c.zw - 0.5; return -max(d.x,d.y); }\n\nvec4 loadValue( in vec2 re ) {\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\nvoid storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\nvoid storeValue( in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\n//===============\nfloat rand(vec2 p) {\n    return fract(sin(dot(p.xy ,vec2(12.9898,78.233))) * 83758.5453);\n}\n\nbool collisionSpaceShipTramp(out vec2 spaceShipPos, out vec2 tramp) {\n    if(spaceShipPos.y == tramp.y && (tramp.x < spaceShipPos.x + SPACESHIP_SIZE && tramp.x > spaceShipPos.x)) {\n        return true; \n    }\n    return false;\n}\n\nfloat rand3(float n){\n    return fract(cos(n*89.42)*343.42);\n}\n\nfloat new_pos() {\n    float pos = Hash0_1(iTime*i);\n    if(pos < 0.33) {\n        pos = 4.0;   \n    } else if(pos < 0.66) {\n        pos = 0.0;\n    } else {\n        pos = -4.0;          \n    }   \n    return pos;\n}\n\n\nfloat selectColor() {\n    float color = Hash0_1(iDate.w*i);\n    if(color < 0.25) {\n        color = ENEMY_1;   \n    } else if(color < 0.51) {\n    \tcolor = ENEMY_2;\n    } else if(color < 0.75) {\n        color = ENEMY_3;\n    } else {\n        color = ENEMY_4;          \n    }   \n    return color;\n}\n\nvoid resetEnemy(out vec4 enemy) {\n    enemy.x = 25.0*rand3(i*iTime*150.0)+23.0;\n    enemy.y = new_pos();\n    enemy.z = 0.0;\n    enemy.w = selectColor(); \n    i += 0.15;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Load values\n    float points = loadValue(txPoints).x;\n    vec4 state = loadValue(txState);\n    vec4 obstacle = loadValue(txObstacle);\n    vec4 spaceShipPos = loadValue(txSpaceShipPos);\n    \n    float lives = loadValue(txLives).x;\n    \n    vec4 enemies[MAX_ENEMIES];\n    for(int id = 0; id < MAX_ENEMIES; id++) {\n        enemies[id] =   loadValue(vec2(txEnemies.x, float(id)));\n    }\n    \n    i = loadValue(txCounter).x;\n    \n    // Reset game state on first frame\n    if(iFrame == 0) {\n        state = vec4(-2.0); \n        spaceShipPos = vec4(-10, 0.0, 0.0, 0.0);\n    }\n    \n    if(GAME_MENU) {\n        if(texture(iChannel1, vec2(KEY_RETURN, 0.25)).x == 1.0) {\n            state.x = STATE_ON_START;   \n        }\n    }\n    // state .0 => Reset game state\n    else if(GAME_START) {\n        state.x = 0.0;\n        state.y = 0.0;\n        obstacle = vec4(0.0);\n        spaceShipPos = vec4(-10.0, 0.0, 0.0, 0.0);\n        points = 0.0;\n        \n        for(int id = 0; id < MAX_ENEMIES; id++) {\n            enemies[id].x = 25.0*rand3(i*iTime*150.0)+23.0;\n            enemies[id].y = new_pos();\n            enemies[id].z = 0.0;\n            enemies[id].w = selectColor();\n            i += 0.15;\n        }\n        lives = float(MAX_LIVES);        \n    } \n    // state .1 => Playing\n    else if (GAME_PLAY) {\n        bool isDie = false;\n        \n        float moveUp    = texture( iChannel1, vec2(KEY_UP,0.25) ).x;\n        float moveDown  = texture( iChannel1, vec2(KEY_DOWN,0.25) ).x;\n        \n        float reset  = texture( iChannel1, vec2(KEY_R,0.25) ).x;\n        \n        \n        float div = points/25.0;\n        \n        spaceShipPos.x = -10.0;\n        if(moveUp == 1.0) {\n            spaceShipPos.y = -4.0;   \n        } else if(moveDown == 1.0) {\n            spaceShipPos.y = 4.0;   \n        } else {\n            spaceShipPos.y = 0.0;   \n        }\n        \n        if(i >= 5.87 && points > 10.0) {\n            i /= points;   \n        }\n        \n        for(int id = 0; id < MAX_ENEMIES; id++) {\n            enemies[id].x -= 0.1*div;\n            if(enemies[id].x < -23.0) {\n                resetEnemy(enemies[id]);\n            } else if(collisionSpaceShipTramp(spaceShipPos.xy, enemies[id].xy)) {\n                lives -= 1.0;\n                if(lives <= 0.0) {\n                \tisDie = true;\n                } else {\n                    resetEnemy(enemies[id]);\n                }\n                break;\n            }\n        }\n        \n        if(reset == 1.0 || isDie) {\n            state.x = 1.0;  \n        } else {\n            points += 0.1;\n        }\n        \n        \n    } else if (GAME_FINISH) {\n        if(texture(iChannel1, vec2(KEY_RETURN, 0.25)).x == 1.0) {\n            state.x = -1.0;   \n        }\n    }\n    \n    // Save values\n    fragColor = vec4(0.0);\n    storeValue(txPoints, vec4(points, 0.0, 0.0, 0.0), fragColor, fragCoord);\n    storeValue(txState, state, fragColor, fragCoord);\n    storeValue(txObstacle, obstacle, fragColor, fragCoord);\n    storeValue(txSpaceShipPos, spaceShipPos, fragColor, fragCoord);\n    storeValue(txLives, vec4(lives, vec3(0.0)), fragColor, fragCoord);\n    \n    for(int id = 0; id < MAX_ENEMIES; id++) {\n        storeValue(vec2(txEnemies.x, float(id)), enemies[id], fragColor, fragCoord);\n    }\n    \n    storeValue(txCounter, vec4(i, 0.0, 0.0, 0.0), fragColor, fragCoord);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*//////////////////////////////////////////////////////////////////////////\n// MÃSTER UNIVERSITARIO INFORMÃTICA GRÃFICA, REALIDAD VIRTUAL Y JUEGOS    //\n// PROCESADORES GRÃFICOS Y APLICACIONES EN TIEMPO REAL                    //\n// JUEGO EN UN SHADER - GAME IN A SHADER                                  //\n// AUTORES:                                                               //\n// - Javier CaÃ±adilla Casco                                               //\n// - Cristian RodrÃ­guez Bernal                                            //\n//                                                                        //\n//////////////////////////////////////////////////////////////////////////*/\n#define NUM_CELLS\t18.0\n#define TILES \t\t18.0\n\n#define VEL 0.5\n#define BG_COLOR vec3(0.2, 1.0, 0.8)\n#define MIX_BG 0.4\n#define CELL_COLOR vec3(0.0, 1.0, 0.0)\n\n#define THREE_D 1.0\n\nvec2 Hash2(vec2 p) {\n\tfloat r = 523.0*sin(dot(p, vec2(53.3158, 43.6143)));\n\treturn vec2(fract(25.1272 * r), fract(85.8456 * r));\n}\n\nfloat noise3D(vec3 p) {\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,12.7235))) * 43758.5453);\n}\n\nfloat create_cells2D(in vec2 p, in float numCells) {\n\tp *= numCells;\n\tfloat d = 1.0e10;\n\tfor (int xo = -1; xo <= 1; xo++) {\n\t\tfor (int yo = -1; yo <= 1; yo++) {\n\t\t\tvec2 tp = floor(p.xy) + vec2(xo, yo);\n\t\t\ttp = p.xy - tp - Hash2(mod(tp, numCells / TILES));\n\t\t\td = min(d, dot(tp, tp));\n\t\t}\n\t}\n\treturn sin(d);\n}\n\nfloat create_cells3D(in vec3 p, in float numCells) {\n\tp.xy *= numCells;\n\tfloat d = 1.0e10;\n    vec3 f = floor(p);\n    vec3 x = fract(p);\n\tfor (int xo = -1; xo <= 1; xo++) {\n\t\tfor (int yo = -1; yo <= 1; yo++) {\n\t\t\tfor (int zo = -1; zo <= 1; zo++) {\n                vec3 xyz = vec3(float(xo),float(yo),float(zo));\t// Position\n    \t\t\tvec3 tp = xyz + noise3D((xyz+f)/TILES) - x;\n\t\t\t\td = min(d, dot(tp, tp));\n            }\n\t\t}\n\t}\n\treturn sin(d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x += iTime/4.5;\n    #ifdef THREE_D\n\t\tfloat f = create_cells3D(vec3(uv, iDate.w*VEL), NUM_CELLS);\n    #else \n    \tfloat f = create_cells2D(uv, NUM_CELLS);\n    #endif\n    \n    vec3 col = vec3(1.0)*f*f;\n    \n    col = mix(col, BG_COLOR, MIX_BG);\t\t// Background\n    col = mix(col, CELL_COLOR, f);\t\t\t// Cells\n    \n\t/*vec2 pixel = 2.0 / iResolution.xy;\n\tuv *= 2.0;\n\tvec2 first = step(pixel, uv);\n\tuv  = step(fract(uv), pixel);\n\tcol = mix(col, vec3(1.0, 0.0, 0.0), (uv.x + uv.y) * first.x * first.y);*/\n    \n\tfragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}