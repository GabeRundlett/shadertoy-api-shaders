{
    "Shader": {
        "info": {
            "date": "1535177814",
            "description": "This was my first raymarched scene for a proc class I took some time ago. I decided to finish it. \nPlease forgive me for rendering this yellow demon to your screen.",
            "flags": 0,
            "hasliked": 0,
            "id": "XtyyRW",
            "likes": 34,
            "name": "Ugly yellow toddler",
            "published": 3,
            "tags": [
                "raymarching",
                "yellow",
                "minion",
                "demon"
            ],
            "usePreview": 0,
            "username": "mmerchante",
            "viewed": 932
        },
        "renderpass": [
            {
                "code": "// A minion shader.\n// This was my first raymarched scene for a proc class I took some time ago.\n// I never had the time to finish it, so here it is... clunky, unoptimized, etc. \n// No time for fanciness, I wanted to take it out of my system. Also removed the environment.\n\n#define MAX_STEPS 30\n#define MAX_STEPS_F float(MAX_STEPS)\n\n#define MAX_DISTANCE 30.0\n#define MIN_DISTANCE 20.0\n#define EPSILON .01\n#define EPSILON_NORMAL .01\n\n#define MATERIAL_MINION \t1\n#define MATERIAL_PANTS \t\t2\n#define MATERIAL_PLASTIC \t3\n#define MATERIAL_EYE\t\t4\n#define MATERIAL_METAL\t\t5\n\n// https://github.com/stackgl/glsl-smooth-min\nfloat smin(float a, float b, float k) \n{\n  float res = exp(-k * a) + exp(-k * b);\n  return -log(res) / k;\n}\n\n// All sdf functions from iq\nvec2 opU(vec2 d1, vec2 d2 )\n{\n    return d1.x < d2.x ? d1 : d2;\n}\n\nfloat sdSphere( vec3 p, float r )\n{\n\treturn length(p) - r;\n}\n\nfloat udBox(vec3 p, vec3 b)\n{\n\treturn length(max(abs(p) - b, 0.0));\n}\n\nfloat sdPlane( vec3 p)\n{\n\treturn p.y;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat pow8(float x)\n{\n\tx *= x; // xˆ2\n\tx *= x; // xˆ4\n\treturn x * x;\n}\n\nfloat length8(vec2 v)\n{\n\treturn pow(pow8(v.x) + pow8(v.y), .125);\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdTorus( vec3 p)\n{\n  vec2 q = vec2(length(p.xz)-1.0,p.y);\n  return length(q) - .2;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n\treturn length(max(abs(p) - b, 0.0)) - r;\n}\n\nfloat sdCappedCone( in vec3 p)\n{\n\tp.y -= .25;\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2(0.5773502691896258, -0.5773502691896258);\n    vec2 w = v - q;\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n    vec2 d = max(qv,0.0) * qv / vv;\n    return sqrt(max(dot(w,w) - max(d.x,d.y), .000000001) ) * sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat opUnion( float d1, float d2 )\n{\n    return min(d1, d2);\n}\n\nvec3 opCheapBend( vec3 p, float magnitude)\n{\n    float c = cos(magnitude * p.y);\n    float s = sin(magnitude * p.y);\n    mat2  m = mat2(c, -s, s, c);\n    vec3 q = vec3( m * p.xy, p.z);\n    return q;\n}\n\nfloat Pants(vec3 point)\n{\n    // Mirror\n    point.x = abs(point.x);\n    vec3 blendOffset = vec3(0.0, 1.5, 0.0);\n\tvec3 bendedPoint = opCheapBend(point - blendOffset, .15) + blendOffset;\n\t\n    float radius = 1.25;    \n\tfloat base = sdCapsule(point, vec3(0.0, .5, .0), vec3(0.0, 2.8, 0.0), radius);\n\tfloat hand1 = sdCapsule(bendedPoint, vec3(1.15, 1.25, 0.0), vec3(1.8, .65, 0.0), .135);\t\n    \n    float handBase = sdSphere(point - vec3(1., 0.1, 0.35), .3);\n    handBase = min(handBase, sdSphere(point - vec3(.85, 0.1, 0.5), .35));\n    \n    // Important for straps\n    base = smin(base, hand1, 5.0);\t\n    base = smin(base, handBase, 10.0);\n    \n    float baseLow = max(base, sdPlane(point - vec3(.0, .2 + abs(point.x*point.x) * -.2, .0)));\n    float baseHigh = max(base, udBox(point - vec3(0., 0.3, 0.0), vec3(.8, .4, 2.0)));\n    \n\tfloat foot = sdCapsule(point, vec3(0.45, -1.0, 0.0), vec3(0.35, 0.5, 0.0), .2);  \n    float dist = min(baseHigh, baseLow);\n    \n    // Smooth with itself\n    dist = smin(dist, dist, 30.0);\n    \n    // Smooth with feet\n    dist = smin(dist, foot, 10.0);\n    \n    vec3 strapOffset = vec3(1.5, .0, 0.0);\n    float strap = sdSphere(point - strapOffset, 1.55);\n    strap = max(strap, -sdSphere(point - strapOffset, 1.35));\n    strap = max(strap, base);\n    strap = max(strap, -baseHigh);\n    \n    return min(dist, strap);\n}\n\nfloat Glass(vec3 point)\n{\n   vec3 glassPoint = point - vec3(0.0, 2.5, 1.15);\t\n   glassPoint.z *= 1.6;\n   return sdSphere(glassPoint + vec3(0.0, 0.0, .25), .55);\t\n}\n\nfloat Metal(vec3 point)\n{    \n\tvec3 glassPoint = point - vec3(0.0, 2.5, 1.23);\t\n\tfloat glassBase = sdTorus82(glassPoint.xzy, vec2(.5, .1));\n    \n    \n    // Mirror\n    point.x = abs(point.x);\n    point -= vec3(.6, 0.0, 1.075);\n\tfloat detail = sdCapsule(point, vec3(0.0, 2.35, .0), vec3(0.0, 2.65, 0.0), .05);\n\n    return min(glassBase, detail);\n}\n\nfloat HandsPantsBelt(vec3 point)\n{\n    // Mirror\n    point.x = abs(point.x);\n\t\n    float handBase = sdSphere(point - vec3(1., 0.1, 0.35), .3);\n    handBase = min(handBase, sdSphere(point - vec3(.85, 0.05, 0.5), .35));\n    \n    // Boot\n    float boot = sdEllipsoid(opCheapBend(point, -.05) - vec3(.5, -1.1, .5), vec3(.35, .25, .3));        \n    boot = max(boot, -sdPlane(point - vec3(0.0, -1.1, 0.0)));\n    \n    // Belt\n    float radius = 1.2 * step(abs(point.y - 2.5), .175) * (1.0 + abs(sin((point.y - 2.5) * 2.14) * .1));\n\tfloat base = sdCapsule(point, vec3(0.0, .5, .0), vec3(0.0, 3.0, 0.0), radius);\n    \n    return min(base, min(boot, handBase));\n}\n\nfloat Body(vec3 point)\n{\n    vec3 original = point;\n    \n    // Mirror\n    point.x = abs(point.x);\n\t\n    vec3 blendOffset = vec3(0.0, 1.5, 0.0);\n\tvec3 bendedPoint = opCheapBend(point - blendOffset, .15) + blendOffset;\n\t\n    float radius = 1.15;\n\tfloat base = sdCapsule(point, vec3(0.0, .5, .0), vec3(0.0, 2.8, 0.0), radius);\n\tfloat hand = sdCapsule(bendedPoint, vec3(1.15, 1.25, 0.0), vec3(1.7, .65, 0.0), .135);\t    \n    hand = smin(hand, sdCapsule(bendedPoint, vec3(1.7, .62, 0.0), vec3(1.25, .2, .5), .11), 20.0);\n\t\n\tfloat dist = smin(base, hand, 12.0);\t\n    \n    original.y -= -pow(original.x, 2.0) * .35;\n    \n\tfloat mouth = sdEllipsoid(opCheapBend(original, .25) - vec3(.8, 1.2, 1.5), vec3(.5, .06, .9));\n\tdist = max(dist, -mouth);\n\treturn dist;\n}\n\nvoid evaluateSceneSDF(vec3 point, out float minDistance, out float hitMaterial)\n{\t\n\thitMaterial = 0.0;\n\tminDistance = MAX_DISTANCE;\n    \n    vec2 d = vec2(Body(point), MATERIAL_MINION);    \n    d = opU(d, vec2(HandsPantsBelt(point), MATERIAL_PLASTIC));\n  \td = opU(d, vec2(Pants(point), MATERIAL_PANTS));\n    d = opU(d, vec2(Metal(point), MATERIAL_METAL));\n    d = opU(d, vec2(Glass(point), MATERIAL_EYE));\n    \n    minDistance = d.x;\n    hitMaterial = d.y;\n}\n\nfloat sdf(vec3 p)\n{\n    float material = 0.0;\n    float d = MAX_DISTANCE;\n    evaluateSceneSDF(p, d, material);\n    return d;\n}\n\n// iq and Paul Malin, tetrahedron (https://iquilezles.org/articles/normalsSDF)\nvec3 sdfNormal(vec3 p, float epsilon)\n{\n    float h = epsilon; // or some other value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sdf(p + k.xyy*h) + \n                      k.yyx*sdf(p + k.yyx*h) + \n                      k.yxy*sdf(p + k.yxy*h) + \n                      k.xxx*sdf(p + k.xxx*h) );\n}\n\n#define AO_ITERATIONS 7\n#define AO_DELTA .12\n#define AO_DECAY .9\n#define AO_INTENSITY .07\n\nfloat ambientOcclusion(vec3 point, vec3 normal)\n{\n\tfloat ao = 0.0;\n\tfloat delta = AO_DELTA;\n\tfloat decay = 1.0;\n\n\tfor(int i = 0; i < AO_ITERATIONS; i++)\n\t{\n\t\tfloat d = float(i) * delta;\n\t\tdecay *= AO_DECAY;\n\t\tao += (d - sdf(point + normal * d)) / decay;\n\t}\n\n\treturn clamp(1.0 - ao * AO_INTENSITY, 0.0, 1.0);\n}\n\nvec3 GetBaseColor(vec3 pos, int material)\n{\n\tvec3 baseColor = vec3(.99, .85, .25);\n    \n    if(material == MATERIAL_PLASTIC)\n    {\n     \tbaseColor *= .1;   \n    }\n    else if(material == MATERIAL_PANTS)\n    {\n\t\tbaseColor = vec3(.25, .5, .7) * smoothstep(-1.3, .15, pos.y);\n    }\n    else if(material == MATERIAL_METAL)\n    {\n\t\tbaseColor = vec3((3.1 - pos.y * .92) * .8);\n    }\n    else if(material == MATERIAL_EYE)\n    {\n        vec2 eyeDispl = textureLod(iChannel1, vec2(iTime * .01), 0.0).rg;\n        pos.xy += pow(eyeDispl, vec2(3.0)) * .05;\n        \n        pos.y += smoothstep(0.999, 1.0, sin(iTime));\n        \n        float eyeHeight = 2.45;\n        float cut = smoothstep(eyeHeight, eyeHeight + .01, pos.y);        \n        float eyeMask = smoothstep(.15, .2, length(pos - vec3(0.0, 2.45, 1.3)));\n        \n        // Eehhh too late for an actual eye\n        vec3 eyeColor = mix(vec3(0.2, .1, .0), vec3(1.0), eyeMask);        \n        eyeColor += smoothstep(.09, .08, length(pos - vec3(0.05, 2.45, 1.3)));\n        \n\t\tbaseColor = mix(eyeColor, baseColor, cut);\n    }\n    \n    return baseColor;\n}\n\nvec3 GetEnvColor(vec3 pos, int material)\n{\n\tvec3 baseColor =  vec3(1.6, .8, .8);\n    \n    if(material == MATERIAL_PLASTIC)\n    {\n     \tbaseColor = vec3(1.0, .9, .9) * .6;\n    }\n    else if(material == MATERIAL_PANTS)\n    {\n\t\tbaseColor = vec3(.25, .5, .7);\n    }\n    else if(material == MATERIAL_METAL)\n    {\n\t\tbaseColor = vec3(1.0);\n    }\n    \n    return baseColor;\n}\n\nvec3 GetSpecularColor(vec3 pos, int material)\n{\n\tvec3 baseColor = vec3(.4, .7, .9);\n    \n    if(material == MATERIAL_PLASTIC)\n    {\n     \tbaseColor = vec3(.4, .7, .9) * .55;\n    }\n    \n    return baseColor;\n}\n\n\nvec3 Render(Ray ray, Intersection isect, vec2 uv)\n{\n    vec3 pos = ray.origin + ray.direction * isect.totalDistance;\n    \n    if(isect.sdf < EPSILON)\n    {\n        float mat = 0.0;\n        float dist = MAX_DISTANCE;\n        evaluateSceneSDF(pos, dist, mat);\n        \n        int material = int(mat);\n        \n        vec3 normal = sdfNormal(pos, EPSILON_NORMAL);\n        \n\t\tfloat lightIntensity = 1.5;\n        vec3 lightPosition = vec3(2., 10.0, 10.2);\n\t\tvec3 lightDirection = normalize(lightPosition - pos);\n                \n\t\tfloat diffuse = max(0.0, dot(normal, lightDirection));\n\t\tfloat sss = saturate((sdf(pos + normal * .1 + lightDirection * .1) ) / .175);\n\t\tsss = smoothstep(0.0, 1.0, sss);\n        \n\t\tvec3 H = normalize(lightDirection - ray.direction);\n\t\tfloat specular = pow(abs(dot(H, normal)), 10.0);\n\n\t\tfloat facingRatio = pow(1.0 - max(0.0, dot(normal, -ray.direction)), 2.5) * mix(.3, 1.1, sss);\n\n\t\tvec3 baseColor = GetBaseColor(pos, material);\n\t\tvec3 envColor = GetEnvColor(pos, material);\n\t\tvec3 coreColor = pow(baseColor, vec3(3.0));\n\t\tvec3 specularColor = GetSpecularColor(pos, material);\n\t\tvec3 ambient = envColor * envColor * .05 + coreColor * .1;\n        \n        vec3 resultColor = mix(baseColor*baseColor, coreColor*coreColor, saturate(1.0 - sss)) * (sss + diffuse * .2) * .5 * lightIntensity;\n        resultColor += specularColor * (specular * .3) + envColor * envColor * facingRatio;\n        resultColor += ambient * ambient * 3.0;\n        \n        if(material == MATERIAL_METAL)\n\t\t\tresultColor += texture(iChannel0, reflect(ray.direction, normal)).rgb;        \n\n        return pow(resultColor, vec3(.45454));\n    }\n    \n    // Cast to floor\n    pos = ray.origin + ray.direction * (-(ray.origin.y + 1.05) / ray.direction.y);\n    float ao = saturate(length(pos.xz) / 6.);\n    ao = smoothstep(-.2, 1.0, ao) * .35 + .65;\n    \n    // Contact occlusion, bend direction towards reflection\n    ao *= ambientOcclusion(pos, reflect(ray.direction, vec3(0.0, 1.0, 0.0)));\n    \n    float vignette = 1.0 - pow(length(uv) / 10., 2.0);\n    return vec3(.15, .175, .2) * vignette * vignette * 6.5 * ao;\n}\n\nIntersection Raymarch(Ray ray)\n{    \n    Intersection outData;\n    outData.sdf = 0.0;\n    outData.totalDistance = MIN_DISTANCE;\n        \n\tfor(int j = 0; j < MAX_STEPS; ++j)\n\t{\n        vec3 p = ray.origin + ray.direction * outData.totalDistance;\n\t\toutData.sdf = sdf(p);\n\t\toutData.totalDistance += outData.sdf;\n\n\t\tif(outData.sdf < EPSILON || outData.totalDistance > MAX_DISTANCE)\n            break;\n\t}\n    \n    return outData;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (-iResolution.xy + (fragCoord*2.0)) / iResolution.y;    \n    fragColor = vec4(0.0);\n    \n    if(abs(uv.y) > .75)\n        return;    \n    \n    Ray ray = GetCamera(uv, .18, iTime);\n    Intersection isect = Raymarch(ray);\n    vec3 color = Render(ray, isect, uv);\n\tfragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n\nvec3 Debug(float t)\n{\n    vec3 c = vec3(0.478, 0.500, 0.500);\n    c += .5 * cos(6.28318 * (vec3(0.688, 0.748, 0.748) * t + vec3(0.318, 0.588, 0.908)));\n    return clamp(c, vec3(0.0), vec3(1.0));\n}\n\nstruct Intersection\n{\n    float totalDistance;\n    float sdf;\n    int materialID;\n};\n\nstruct Ray\n{\n\tvec3 origin;\n    vec3 direction;\n};\n\nRay GetCamera(vec2 uv, float zoom, float time)\n{\n    vec3 target = vec3(0.0, 1.5, 0.0);\n    vec3 p = vec3(-5.0, 2.0, 25.0) + vec3(cos(time), 0.0, sin(time)) * .1;\n        \n    vec3 forward = normalize(target - p);\n    vec3 left = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(forward, left));\n\n    Ray ray;   \n    ray.origin = p;\n    ray.direction = normalize(forward - left * uv.x * zoom - up * uv.y * zoom);        \n    return ray;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}