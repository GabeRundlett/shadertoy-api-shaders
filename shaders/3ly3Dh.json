{
    "Shader": {
        "info": {
            "date": "1578758899",
            "description": "today's sketch is brought to you by a photo of a tapioca dessert.\n\nhttps://commons.wikimedia.org/wiki/File:Tapioca,_aka_boba.jpg\n\ncode commented nicely so read away~",
            "flags": 32,
            "hasliked": 0,
            "id": "3ly3Dh",
            "likes": 12,
            "name": "searching — sat.sketch #6",
            "published": 3,
            "tags": [
                "2d",
                "voronoi",
                "noise",
                "chromaticaberration",
                "blur",
                "lens",
                "lens",
                "fake",
                "dof",
                "cell",
                "perspective",
                "microscope",
                "grain",
                "aesthetic",
                "realistic"
            ],
            "usePreview": 0,
            "username": "szczm_",
            "viewed": 478
        },
        "renderpass": [
            {
                "code": "/*************************************\\\n\n searching — saturday sketch #6\n  — Matthias Scherba (szczm_)\n\n\n Today's sketch is brought to you by a photo of a tapioca dessert.\n\n https://commons.wikimedia.org/wiki/File:Tapioca,_aka_boba.jpg\n\n I wanted to do something along the lines of the photo above, but then it went\n totally sideways and I decided to do something different and, hopefully, unique.\n\n My additional goals were to use the derivative functions (and they're cool.)\n\n I wrote Voronoi without any external references on the first try, yay! \\o/\n\n Uses a hardware derivative reconstruction trick from Fabrice Neyret:\n https://www.shadertoy.com/view/3lt3DN\n\n\n This tab contains the post processing, all the other fun stuff is in other tabs:\n — Buffer A: Voronoi (nice, simple, naïve algorithm)\n — Buffer B: derivative trick (deriv. used for uniform line width)\n — Buffer C: final image\n — Image: YOU ARE HERE!\n \n\n Not signing out———\n\n\n\\***************************************************/\n\n\n#define PREVIOUS_BUFFER (iChannel0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec2 cuv = uv - 0.5;\n    cuv.x *= iResolution.x / iResolution.y;\n    \n    float t1 = iTime + sin(iTime * 1.3);\n    \n    vec3 color = vec3(0.0);\n    // float acc = 0.0;\n    \n    const int samples = 33;\n        \n    // More blur (and noise) the further off we go from the center\n    float offsetStrength = 0.001 + 0.007 * (length(cuv)) * (0.6 + 0.4 * sinf(t1));\n    \n    for (int i = 0; i < samples; i++) {\n        vec3 randomDirection = randomPointOnHemisphere(vec3(0.0, 0.0, 1.0), float(i));\n        \n        vec2 uvOffset = randomDirection.xy * offsetStrength;\n        // float gauss = exp(-2.0 * (1.0 - randomDirection.z));\n\n    \tvec3 col = texture(PREVIOUS_BUFFER, uv + uvOffset).rgb; // * gauss;\n        \n        // help this definitely isn't how you do chromatic abberation\n        int compId = i % 3;\n        color[compId] += col[compId];\n        \n        // color += col;\n        // acc += gauss;\n    }\n    \n    // color /= acc;\n    color /= float(samples) / 3.0;\n    \n    // Color correction\n    color = pow(color, vec3(0.85, 0.95, 1.1));\n    \n    // Subtle vi————gnette\n    color *= 1.0 - 0.5 * pow(offsetStrength * 50.0 + length(cuv) * 0.15, 2.0);\n    \n    // Grain\n    float lum = 1.0 - luminance(color);\n    color = mix(color, vec3(hash(uv * 10.0 + vec2(iTime, iTime + 1.0))), 0.13 * mix(lum, 1.0, offsetStrength * 25.0));\n    \n    fragColor = vec4(color, 1.0);\n}\n             \n#undef PREVIOUS_BUFFER",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Here I— I mean, we, generate the Voronoi. The algorithm is simple: remember\n// the distance to two closest cells, then use the difference. It works surprisingly\n// well, but will look ugly if you simply put that difference on the screen.\n//\n// Solution? \"Normalize\" the difference by dividing it by it's derivative! \\o/\n//\n// How did I come upon this solution? If you put the difference on the screen,\n// you see some cells having a widely spread gradient, and others not so much.\n// Gradient equals derivative.\n//\n// So no magic here, just a simple observation and then some intuition (:\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    const float cell_count = 40.0;\n    const float cell_speed = 0.005;\n        \n    float min1 = 10e6;\n    float min2 = 10e6;\n    \n    for (float i = 0.0; i < cell_count; i += 1.0)\n    {\n        float randomAngle = hash(i) * TAU;\n        \n        vec2 cellPosition = vec2(hash(i + cell_count), hash(i + cell_count * 2.0) + iTime * 0.125);\n        vec2 cellVelocity = vec2(cosf(randomAngle), sinf(randomAngle)) * cell_speed * iTime;\n        \n        cellPosition = mod(cellPosition + cellVelocity, vec2(1.0));\n        \n        cellPosition -= 0.5;\n        \n        cellPosition.y *= iResolution.x / iResolution.y;\n        // This line below makes it more center-centric :'\n        cellPosition *= exp(-1.5 * (1.0 - length(cellPosition)));\n        \n        cellPosition += 0.5;\n        \n        vec2 screenPosition = cellPosition * iResolution.xy;\n        float dist = distance(screenPosition, fragCoord);\n        \n        if (dist < min1) {\n            min2 = min1;\n            min1 = dist;\n        } else if (dist < min2) {\n            min2 = dist;\n        }\n    }\n    \n    // This is is. This is the whole voronoi.\n    \n    fragColor = vec4(min2 - min1);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Gotta fix those for my drivers...\n#define TAU 6.28318530718\nfloat sinf(float arg) { return sin(mod(arg, TAU)); }\nfloat cosf(float arg) { return cos(mod(arg, TAU)); }\n// ...there.\n\n\nfloat hash(float i) {\n    return fract(sinf(785172.9189*i) * 20412.021401);\n}\nfloat hash(vec2 i) {\n    return hash(dot(i, vec2(2154.9251, 9253.5219)));\n}\nfloat hash(vec3 i) {\n    return hash(dot(i, vec3(2154.9251, 9253.5219, 5021.2510)));\n}\n\n\nfloat luminance(vec3 col) {\n    return dot(col, vec3(0.299, 0.587, 0.114));\n}\n\n\nvec3 randomPointOnHemisphere(vec3 dir, float seed) {\n    float a = hash(seed);\n    float b = hash(seed + 1.0);\n    float c = hash(seed + 2.0);\n    \n    vec3 point = normalize(-1.0 + 2.0 * vec3(a, b, c));\n    \n    return point * sign(dot(dir, point));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// As mentioned in Buffer A, we need the derivative. One can get it for free by using\n// dFdx/dFdy/fwidth funcs, which is insanely useful since our \"function\" - iteration\n// through all points and finding the two closest ones - isn't really analytically\n// derivable.\n//\n// The problem is, derivative functions are 2x downsampled, so division results in\n// artifacts. So I'm using a trick that I was recommended on the ShaderToy Discord,\n// stolen from here:\n//\n// https://www.shadertoy.com/view/3lt3DN\n// \n// Thanks a lot, Fabrice Neyret! And to Orm for the recommendation! o/\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    float a = texture(iChannel0, U    /iResolution.xy).r,\n          b = texture(iChannel0,(U+1.)/iResolution.xy).r;\n    O.x = a;\n    O.y = fwidth(a);\n    O.z = b;\n    O.w = fwidth(b);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// This generates the \"final\" image right before the fancy post processing.\n\n#define NOISE_TEXTURE (iChannel1)\n#define PREVIOUS_BUFFER (iChannel0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    float t1 = iTime + sinf(iTime * 1.3 + sinf(iTime * 1.7)) * 0.3;\n    float t2 = iTime + sinf(iTime * 1.7 + sinf(iTime * 1.9));\n    \n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n    \n    // Everyone needs a bit of perspective.\n    vec3 ray = vec3(uv, 1.0);\n    ray = normalize(ray);\n    \n    vec2 shake = vec2(cosf(t1), sinf(t1)) * vec2(0.065, 0.032) * 1.5;\n    \n    uv = ray.xy;\n    uv += shake;\n    \n    // The wibbly-wobbly ripple effect.\n    vec2 noiseOrganic = 2.0 * texture(NOISE_TEXTURE, uv * vec2(0.2, 0.6) + hash(iTime)).rg - 1.0;\n    uv += noiseOrganic * mix(0.0015, 0.005, pow(max(cosf(t2), 0.0), 4.0));\n    \n    vec2 cuv = uv;\n    cuv -= shake * 0.5; // parallax! 1.0 is shake-independent, 0.0 is no parallax\n    cuv.x *= 0.95 * iResolution.x / iResolution.y;\n    \n    // \"bleh\" is \"size\" read by someone with a Scottish accent, backwards.\n    const float bleh = 0.45;\n    \n    float border = smoothstep(bleh + 0.045 + 2.0/iResolution.y, bleh + 0.045, length(cuv));\n    float borderInner = smoothstep(bleh + 0.03, bleh + 0.03 + 2.0/iResolution.y, length(cuv));\n    float borderInnerInner = smoothstep(bleh, bleh + 2.0/iResolution.y, length(cuv));\n    \n    // What? The \"lens\" actually make things smaller? Bad me, yeesh.\n    uv *= (2.0 - borderInner) / 2.;\n    \n    uv += 0.5;\n\n    float samples = texture(PREVIOUS_BUFFER, uv).r;\n\n    // This is also a part of the derivative trick…\n    vec2 f = mod(fragCoord -.5, 2.);\n\n    float v = texture(PREVIOUS_BUFFER, uv).y;\n    v = ( v + texture(PREVIOUS_BUFFER, (uv * iResolution.xy -(1.-f))/iResolution.xy).w ) / 2.;\n    // …and it ends here.\n    \n    /*const*/ float edge_width = 0.008 * iResolution.y;\n    \n    // Finally divide by the derivative. IT TOOK ONLY THREE BUFFERS :' )\n    samples /= v;\n    samples = smoothstep(edge_width * 0.5, edge_width, samples);\n    samples = mix(1.0 - samples, samples, borderInnerInner);\n        \n    float samplesFinal = 1.0 - mix(samples, 1.0, borderInnerInner * 0.92);\n    float borderFinal = border * borderInner;\n    \n    vec3 background_color = vec3(0.85) + 0.15 * textureLod(NOISE_TEXTURE, uv * vec2(1.7, 1.0), 4.0).rrr; // rrrrrrr > _>\n    vec3 foreground_color = vec3(0.85, 0.45, 0.45);\n    vec3 border_color = vec3(0.25);\n    \n    vec3 color = mix(background_color, foreground_color, samplesFinal);\n    color = mix(color, border_color, borderFinal);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n#undef NOISE_TEXTURE\n#undef PREVIOUS_BUFFER",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}