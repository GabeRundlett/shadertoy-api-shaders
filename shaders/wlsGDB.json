{
    "Shader": {
        "info": {
            "date": "1557567534",
            "description": "Demonstrates what a spinning solid disk which instantly vaporizes everywhere could look like.",
            "flags": 0,
            "hasliked": 0,
            "id": "wlsGDB",
            "likes": 3,
            "name": "Disc disintegration",
            "published": 3,
            "tags": [
                "fun",
                "disintegration"
            ],
            "usePreview": 0,
            "username": "qwert33",
            "viewed": 477
        },
        "renderpass": [
            {
                "code": "vec3 orange = vec3(1.,.5,0.);\n\nvec2 domsMouse;\n\nvec2 project(vec2 pixel) {\n    vec2 uv = pixel/iResolution.xy - vec2(0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv;\n}\n\nfloat animation_fraction() {\n    return 2.f+5.f*(mod(.05*iTime, 1.)*2.-1.);\n}\n//float animation_fraction = mod(.5*iTime, 1.);\n\n// Returns a unit-length vector at a given rotation.\n// Analogous to e^(-i*theta)\n// i.e. rotate (1,0) anticlockwise for theta radians. (+y means facing up)\nvec2 e(float theta) {\n    return vec2(cos(theta), sin(theta));\n}\n\nfloat circle(vec2 uv) {\n    //uv *= 2.;\n    if (length(uv)< 0.9) {\n        return 0.3;\n    }\n    if (length(uv)< 1.) {\n        return 1.;\n    }\n    return 0.;\n    return clamp(length(uv)-8., 0., 1.);\n    return bias(1.-(abs(length(uv) - 1. +.018) / .02), .8);\n}\nfloat row_of_circles(vec2 uv, float width) {\n    uv.x = mod(uv.x+width, 2.*width) - width;\n    return circle(uv);\n}\n\nfloat ring_of_circles(vec2 uv, float orbit_radius, float num_circles) {\n    \n    float theta = atan(uv.y, uv.x);\n    float t = animation_fraction();\n    vec2 shift;\n    if (t<0.f) {\n        shift = orbit_radius*e(t);\n    } else {\n        shift = vec2(orbit_radius, orbit_radius*t);\n    }\n     \n\tfloat c = atan(shift.y, shift.x);\n    c -= TAU/num_circles/2.f;\n\n    theta -= c;\n    theta = mod(theta, TAU/num_circles);\n    theta += c;\n    \n    uv = length(uv)*e(theta);\n    \n    vec2 after_shift2 = uv - shift;\n\t\n    \n    return circle(after_shift2);\n}\n\nfloat monochrome(vec2 uv) {\n    float acc = 0.f;\n    uv *= 4.f;\n    \n    acc += circle(uv*10.f);\n    acc += circle(uv);\n    //acc += ring_of_circles(uv, 2., 6.);\n    //acc += ring_of_circles(uv, 4., 12.);\n    //acc += ring_of_circles(uv, 6., 18.);\n    //acc += ring_of_circles(uv, 8., 24.);\n    \n    for (float i=1.f; i<20.f; i++) {\n        acc += ring_of_circles(uv, 2.f*i, 6.f*i);\n    }\n\treturn clamp(acc, 0., 1.);\n}\n\nfloat f(vec2 fragCoord) {\n    vec2 uv = project(fragCoord);\n    uv /= project(domsMouse.xy).xx;\n    return monochrome(uv);\n}\n// antialiasing\nfloat sampleSubpixel(vec2 pixels) {\n\tconst int size = 1; \n\tfloat disp = 1.0 / (float(size) + 2.0);\n\tfloat contrb = 0.0;\n\tfloat maxContrb = 0.0;\n\tfor (int j = -size; j <= size; j++) {\n\t\tfor (int i = -size; i <= size; i++) {\n\t\t\tcontrb += f(pixels + vec2(float(i) * (disp / 3.0), float(j) * disp));\n\t\t\tmaxContrb += 1.0;\n\t\t}\n\t}\n\treturn contrb / maxContrb;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    domsMouse = iMouse.xy;\n    if (iMouse.x == 0.) { domsMouse.x = iResolution.x * .5 + 30.; }\n    fragColor = vec4(orange * sampleSubpixel(fragCoord), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define TAU 6.28318530718\n#define PI TAU/2\n    \n// biases x to be closer to 0 or 1\n// can act like a parameterized smoothstep\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nfloat bias(float x, float b) {\n    x = clamp(x, 0., 1.);\n    b = -log2(1.0 - b);\n    return 1.0 - pow(1.0 - pow(x, 1./b), b);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}