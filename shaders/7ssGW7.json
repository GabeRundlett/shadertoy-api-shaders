{
    "Shader": {
        "info": {
            "date": "1616113478",
            "description": "More fun with springs! This time in 3D. Pull the vertices with the mouse.",
            "flags": 48,
            "hasliked": 0,
            "id": "7ssGW7",
            "likes": 39,
            "name": "Springy Icosahedron",
            "published": 3,
            "tags": [
                "3d",
                "simulation",
                "icosahedron",
                "physics",
                "spring",
                "softbody"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 740
        },
        "renderpass": [
            {
                "code": "Intersect iScene(in vec3 ro, in vec3 rd) {\n    Intersect scene = Intersect(false, -1.0, vec3(0.0), vec3(0.0));\n\n    // Intersect ground plane\n    float plane = iPlane(ro, rd, vec3(0.0, PLANE_HEIGHT, 0.0), vec3(0.0, 1.0, 0.0));\n    if (plane > 0.0) {\n        scene.hit = true;\n        scene.dist = plane;\n        scene.pos = ro + rd * plane;\n        scene.nor = nPlane(scene.pos, vec3(0.0, PLANE_HEIGHT, 0.0), vec3(0.0, 1.0, 0.0));\n    }\n\n    // Intersect vertices (joints)\n    for (int n=0; n < joints.length(); n++) {\n        vec3 joint = getJoint(n).pos;\n        float sphere = iSphere(ro, rd, joint, 0.15);\n        if (sphere > 0.0 && (scene.hit ? sphere < scene.dist : true)) {\n            scene.hit = true;\n            scene.dist = sphere;\n            scene.pos = ro + rd * sphere;\n            scene.nor = nSphere(scene.pos, joint, JOINT_SIZE);\n        }\n    }\n\n    // Intersect faces\n    for (int n=0; n < faces.length(); n++) {\n        vec3 a = getJoint(faces[n][0]).pos;\n        vec3 b = getJoint(faces[n][1]).pos;\n        vec3 c = getJoint(faces[n][2]).pos;\n        float triangle = iTriangle(ro, rd, a, b, c);\n        if (triangle > 0.0 && (scene.hit ? triangle < scene.dist : true)) {\n            scene.hit = true;\n            scene.dist = triangle;\n            scene.pos = ro + rd * triangle;\n            scene.nor = nTriangle(scene.pos, a, b, c);\n        }\n    }\n\n    return scene;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 ro = CAMERA_POS;\n    vec3 rd = normalize(vec3(uv, -FOCAL_LENGTH));\n\n    // Sky\n    fragColor = vec4(mix(vec3(0.25, 0.25, 1.0), vec3(1.0), 0.5 + 0.5 * rd.y), 1.0);\n\n    Intersect scene = iScene(ro, rd);\n    if (scene.hit) {\n        scene.nor *= sign(dot(scene.nor, -rd)); // Flip the normal towards the camera\n        vec3 light = normalize(vec3(-1.0, 1.0, 1.0));\n        fragColor.rgb = vec3(max(0.0, mix(dot(scene.nor, light), dot(scene.nor, -rd), 0.5)));\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Geometry (copied from https://people.sc.fsu.edu/~jburkardt/data/obj/icosahedron.obj)\nconst vec3[] joints = vec3[](\n    vec3(       0.0, -1.051462,  1.701302 ),\n    vec3(  1.701302,       0.0,  1.051462 ),\n    vec3(  1.701302,       0.0, -1.051462 ),\n    vec3( -1.701302,       0.0, -1.051462 ),\n    vec3( -1.701302,       0.0,  1.051462 ),\n    vec3( -1.051462,  1.701302,       0.0 ),\n    vec3(  1.051462,  1.701302,       0.0 ),\n    vec3(  1.051462, -1.701302,       0.0 ),\n    vec3( -1.051462, -1.701302,       0.0 ),\n    vec3(       0.0, -1.051462, -1.701302 ),\n    vec3(       0.0,  1.051462, -1.701302 ),\n    vec3(       0.0,  1.051462,  1.701302 )\n);\n\nconst ivec3[] faces = ivec3[](\n    ivec3(  1,  2,  6 ),\n    ivec3(  1,  7,  2 ),\n    ivec3(  3,  4,  5 ),\n    ivec3(  4,  3,  8 ),\n    ivec3(  6,  5, 11 ),\n    ivec3(  5,  6, 10 ),\n    ivec3(  9, 10,  2 ),\n    ivec3( 10,  9,  3 ),\n    ivec3(  7,  8,  9 ),\n    ivec3(  8,  7,  0 ),\n    ivec3( 11,  0,  1 ),\n    ivec3(  0, 11,  4 ),\n    ivec3(  6,  2, 10 ),\n    ivec3(  1,  6, 11 ),\n    ivec3(  3,  5, 10 ),\n    ivec3(  5,  4, 11 ),\n    ivec3(  2,  7,  9 ),\n    ivec3(  7,  1,  0 ),\n    ivec3(  3,  9,  8 ),\n    ivec3(  4,  8,  0 )\n);\n\n// Settings\n#define CAMERA_POS vec3(0.0, 0.0, 6.0)\n#define FOCAL_LENGTH 1.0\n\n#define JOINT_SIZE 0.15\n#define JOINT_MASS 10.0\n\n#define PLANE_HEIGHT -2.0\n\n#define GRAVITY 0.1\n#define SPRINGINESS 0.8\n#define DAMPING 0.99\n#define SPEED_LIMIT 0.5\n\n// Constants\n#define e 2.7182818285\n#define phi 1.6180339887\n#define pi 3.14159265359\n#define tau 6.28318530718\n#define rho 1.57079632679\n\n// Utilities\nstruct Joint {\n    vec3 pos;\n    vec3 vel;\n    float mass;\n};\n\n#define getJoint(id)                                  \\\n    Joint(texelFetch(iChannel0, ivec2(id, 0), 0).xyz, \\\n          texelFetch(iChannel0, ivec2(id, 1), 0).xyz, \\\n          JOINT_MASS)                                 \\\n\n// Intersectors\nstruct Intersect {\n    bool hit;\n    float dist;\n    vec3 pos;\n    vec3 nor;\n};\n\nfloat iPlane(in vec3 ro, in vec3 rd, in vec3 o, in vec3 n) {\n    float d = dot(rd, n);\n    if (d != 0.0) return dot(o - ro, n) / d;\n    return -1.0;\n}\n\n// Assumes the ray is outside the sphere\n// The other side is: (b - sqrt(discr)) / a * 0.5\nfloat iSphere(in vec3 ro, in vec3 rd, in vec3 o, in float r) {\n    ro -= o;\n\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(ro, rd);\n    float c = dot(ro, ro) - r * r;\n\n    float discr = b * b - 4.0 * a * c;\n    if (discr > 0.0) return -(sqrt(discr) + b) / a * 0.5;\n\n    return -1.0;\n}\n\n// Not as efficient as barycentric coordinates\n// BUT... it avoids having to introduce error margins\n// (though I guess square roots have errors of their own\n// so I guess its just a matter of elegance)\nfloat iTriangle(in vec3 ro, in vec3 rd, in vec3 a, in vec3 b, in vec3 c) {\n    ro -= a; b -= a; c -= a;\n    vec3 ba = normalize(b), cb = normalize(c - b), ac = normalize(-c);\n\n    vec3 n = cross(b, c);\n    float denom = dot(rd, n);\n    if (denom != 0.0) {\n        float t = -dot(ro, n) / denom;\n\n        vec3 p = ro + rd * t;\n        vec3 pa = normalize(p), pb = normalize(p - b), pc = normalize(p - c);\n\n        if (min(dot(pa, ba), dot(pa, -ac)) > dot(ba, -ac) &&\n            min(dot(pb, cb), dot(pb, -ba)) > dot(cb, -ba)) {\n            return t;\n        }\n    }\n\n    return -1.0;\n}\n\n// Normals\nvec3 nPlane(in vec3 p, in vec3 o, in vec3 n) {\n    return n; // For some weak polymorphism :P\n}\n\nvec3 nSphere(in vec3 p, in vec3 o, in float r) {\n    return (p - o) / r;\n}\n\nvec3 nTriangle(in vec3 p, in vec3 a, in vec3 b, in vec3 c) {\n    return normalize(cross(b - a, c - a));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 iFragCoord = ivec2(fragCoord);\n    fragColor = vec4(0.0);\n\n    // Simulation\n    if (iFragCoord.x < joints.length() && iFragCoord.y < 2) {\n        if (iFrame == 0) {\n            if (iFragCoord.y == 0) fragColor.xyz = joints[iFragCoord.x] - vec3(0.0, 0.0, 1.0);\n            if (iFragCoord.y == 1) {\n                vec3 joint = joints[iFragCoord.x];\n                fragColor.xyz = vec3(normalize(joint.zx) * vec2(-0.05, 0.05), 0.0) + vec3(0.0, 0.2, -0.05);\n            }\n        }\n\n        if (iFrame > 0) {\n            Joint joint1 = getJoint(iFragCoord.x);\n            vec3 startPos1 = joints[iFragCoord.x];\n\n            // Accumulate gravitational and spring forces\n            vec3 totalForce = vec3(0.0, -GRAVITY, 0.0);\n            for (int i=0; i < joints.length(); i++) {\n                if (i == iFragCoord.x) continue;\n                Joint joint2 = getJoint(i);\n                vec3 startPos2 = joints[int(float(i) + 0.5)]; // Why +0.5?\n\n                float restLength = distance(startPos1, startPos2);\n                vec3 force = normalize(joint2.pos - joint1.pos);\n                float extension = restLength - distance(joint2.pos, joint1.pos);\n                force *= -SPRINGINESS * extension;\n\n                totalForce += force;\n            }\n\n            // Update\n            joint1.vel += totalForce / joint1.mass;\n            joint1.pos += joint1.vel;\n            joint1.pos.y = max(joint1.pos.y, JOINT_SIZE + PLANE_HEIGHT);\n            joint1.vel *= DAMPING * sign(joint1.pos.y - PLANE_HEIGHT - JOINT_SIZE);\n\n            // Attract to mouse\n            if (iMouse.z > 0.0) {\n                vec2 mouse = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n                vec3 ro = CAMERA_POS;\n                vec3 rd = normalize(vec3(mouse, -FOCAL_LENGTH));\n\n                bool closest = true;\n                vec3 targetPos = ro + rd * iPlane(ro, rd, joint1.pos, vec3(0.0, 0.0, 1.0));\n                float targetDist = distance(joint1.pos, targetPos);\n                for (int n=0; n < joints.length(); n++) {\n                    if (n == iFragCoord.x) continue;\n                    vec3 joint2 = getJoint(n).pos;\n                    vec3 targetPos2 = ro + rd * iPlane(ro, rd, joint2, vec3(0.0, 0.0, 1.0));\n                    if (distance(joint2, targetPos2) < targetDist) {\n                        closest = false;\n                        break;\n                    }\n                }\n\n                if (closest) {\n                    joint1.vel = (targetPos - joint1.pos) * 0.5;\n                    joint1.vel = normalize(joint1.vel) * min(length(joint1.vel), SPEED_LIMIT);\n                }\n            }\n\n            // Store\n            if (iFragCoord.y == 0) fragColor.xyz = joint1.pos;\n            if (iFragCoord.y == 1) fragColor.xyz = joint1.vel;\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}