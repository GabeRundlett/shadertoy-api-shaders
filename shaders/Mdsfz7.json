{
    "Shader": {
        "info": {
            "date": "1495529903",
            "description": "Draws an explicit function of x, sampling in x neighbourhood. Focusing on decent looking output, see remarks in code comments. Oscilloscope thing version: https://www.shadertoy.com/view/4dfBWn",
            "flags": 0,
            "hasliked": 0,
            "id": "Mdsfz7",
            "likes": 18,
            "name": "Sampling function grapher",
            "published": 3,
            "tags": [
                "2d",
                "oscilloscope",
                "antialias",
                "graph"
            ],
            "usePreview": 0,
            "username": "grinist",
            "viewed": 1093
        },
        "renderpass": [
            {
                "code": "// Draws an explicit function of x. I was focusing on getting decent looking output\n// with constant line size and \"disconnected discontinuities\".\n// Remarks:\n// The naive sampling approach has its problems.\n// The drawing code and the function itself are coupled. At least sampling could be separated.\n// A good sampling step size depends on local function gradient and graph range.\n// Performance is proportional to line width, aa falloff and sample step; easy to\n// make it too heavy.\n// Connected line segments would be more performant, but would mask the discontinuity.\n// Aliasing on this looks funky. :)\n\n// The values below control the rendering, knock yourself out.\n#define AA_FALLOFF 1.0\t\t\t// AA falloff in pixels, must be > 0, affects all drawing\n#define GRID_WIDTH 0.1\t\t\t// grid line width in pixels, must be >= 0\n#define CURVE_WIDTH\t8.0\t\t\t// curve line width in pixels, must be >= 0\n\n#define FUNC_SAMPLE_STEP 0.2\t// function sample step size in pixels\n\nfloat pp; \t\t\t// pixel pitch in graph units\n\n// The function to be drawn\nfloat func(float x)\n{\n    float p = (x + iTime * 0.1) * 6.2832;\n    float f = 1.0 * sin(p);\n    f += 0.5 * sin(p * 3.0);\n    f += 0.25 * sin(p * 5.0 + iTime * 2.5);\n    f *= 0.5;\n    return 0.5 + step(-0.5, x) * step(x, 1.5) * f;\n}\n\n// AA falloff function, trying lerp instead of smoothstep.\nfloat aaStep(float a, float b, float x)\n{\n    // lerp step, make sure that a != b\n    return (clamp(x, a, b) - a) / (b - a);\n}\n\n// Alphablends color\nvoid blend(inout vec4 baseCol, vec4 color, float alpha)\n{\n    baseCol = vec4(mix(baseCol.rgb, color.rgb, alpha * color.a), 1.0);\n}\n\n// Draws a gridline every stepSize\nvoid drawGrid(inout vec4 baseCol, vec2 xy, float stepSize, vec4 gridCol)\n{\n\tfloat hlw = GRID_WIDTH * pp * 0.5;\n    float mul = 1.0 / stepSize;\n\tvec2 gf = abs(vec2(-0.5) + fract((xy + vec2(stepSize) * 0.5) * mul));\n\tfloat g = 1.0 - aaStep(hlw * mul, (hlw + pp * AA_FALLOFF) * mul, min(gf.x, gf.y));\n    blend(baseCol, gridCol, g);\n}\n\n// Draws a circle\nvoid drawCircle(inout vec4 baseCol, vec2 xy, vec2 center, float radius, vec4 color)\n{\n    float r = length(xy - center);\n    float c = 1.0 - aaStep(radius, radius + pp * AA_FALLOFF, r);\n    blend(baseCol, color, c);\n}\n\n// Draws explicit function of x defined in func(x)\nvoid drawFunc(inout vec4 baseCol, vec2 xy, vec4 curveCol)\n{\n    // samples the function around x neighborhood to get distance to curve\n    float hlw = CURVE_WIDTH * pp * 0.5;\n    \n    // cover line width and aa\n    float left = xy.x - hlw - pp * AA_FALLOFF;\n    float right = xy.x + hlw + pp * AA_FALLOFF;\n    float closest = 100000.0;\n    for (float x = left; x <= right; x+= pp * FUNC_SAMPLE_STEP)\n    {\n        vec2 diff = vec2(x, func(x)) - xy;\n        float dSqr = dot(diff, diff);\n        closest = min(dSqr, closest);\n    }\n    \n\tfloat c = 1.0 - aaStep(hlw, hlw + pp * AA_FALLOFF, sqrt(closest));\n\tblend(baseCol, curveCol, c);    \n}\n\nmat2 rotate2d(float angle)\n{\n    float sina = sin(angle);\n    float cosa = cos(angle);\n    return mat2(cosa, -sina,\n                sina, cosa);\n}\n\n// Finds the next smaller power of 10\nfloat findMagnitude(float range)\n{\n    float l10 = log(range) / log(10.0);\n    return pow(10.0, floor(l10));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // graph setup\n\tfloat aspect = iResolution.x / iResolution.y;\n    float z = 0.0;\n\t// comment out disable zoom:\n    z = sin(iTime * 0.3) * 3.1;\n    \n    float graphRange = 0.4 + pow(1.5, z * z * z);\n\tvec2 graphSize = vec2(aspect * graphRange, graphRange);\n\tvec2 graphPos = 0.5 - graphSize * 0.5;\t// center at (0.5, 0.5)\n\n    vec2 xy = graphPos + uv * graphSize;\t// xy = current graph coords\n    pp = graphSize.y / iResolution.y;\t\t// pp = pixel pitch in graph units\n    \n    // comment out to disable rotation:\n   \txy = rotate2d(sin(iTime * 0.2) * 0.2) * (xy - 0.5) + 0.5;\n\n    // background\n    float t = length(0.5 - uv) * 1.414;\n    t = t * t * t;\n\tvec4 col = mix(vec4(0.1, 0.25, 0.35, 1.0), vec4(0.0, 0.0, 0.0, 1.0), t);\n    \n\t// grid\n    float range = graphSize.y * 2.0;\n    float mag = findMagnitude(range);\n    float a = 1.0 - (range / mag * 0.1);\n    drawGrid(col, xy, mag, vec4(1.0, 1.0, 1.0, a));\n    //drawGrid(col, xy, mag, vec4(1.0, 1.0, 1.0, 0.2));\n    //drawGrid(col, xy, 0.1, vec4(1.0, 1.0, 1.0, 0.1));\n\t//drawGrid(col, xy, 0.5, vec4(1.0, 1.0, 1.0, 0.1));\n\t//drawGrid(col, xy, 1.0, vec4(1.0, 1.0, 1.0, 0.4));\n\n    // curve\n    vec4 cCol = vec4(0.0, 1.0, 0.7, 0.8);\n    drawFunc(col, xy, cCol);\n    \n\tfragColor = col;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}