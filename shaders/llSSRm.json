{
    "Shader": {
        "info": {
            "date": "1442406035",
            "description": "common functions ",
            "flags": 0,
            "hasliked": 0,
            "id": "llSSRm",
            "likes": 9,
            "name": "â™« InFX.1",
            "published": 3,
            "tags": [
                "raymarching",
                "demoeffect"
            ],
            "usePreview": 0,
            "username": "patu",
            "viewed": 652
        },
        "renderpass": [
            {
                "code": "const vec3 e = vec3(0.0, 0.0, 0.1);\nconst float maxd = 75.0;\nconst vec3 c = vec3(1.0);\nconst float PI = 3.14159265;\n\nvec2 d = vec2(0.1, 0.0);\nvec3 p;\n\nvec4 Color = vec4(0.0);\n\nvec2 hash( vec2 p ) {                       // rand in [-1,1]\n    p = vec2( dot(p,vec2(127.1,311.7)),\n              dot(p,vec2(269.5,183.3)) );\n    return -1. + 2.*fract(sin(p+20.)*53758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor((p)), f = fract((p));\n    vec2 u = f*f*(3.-2.*f);\n    return mix( mix( dot( hash( i + vec2(0.,0.) ), f - vec2(0.,0.) ), \n                     dot( hash( i + vec2(1.,0.) ), f - vec2(1.,0.) ), u.x),\n                mix( dot( hash( i + vec2(0.,1.) ), f - vec2(0.,1.) ), \n                     dot( hash( i + vec2(1.,1.) ), f - vec2(1.,1.) ), u.x), u.y);\n}\n\nmat3 xrotate(float t) {\n\treturn mat3(\n        \t\t1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t)\n    \t\t);\n}\n\nmat3 yrotate(float t) {\n\treturn mat3(\n        \t\tcos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t)\n    \t\t);\n}\n\nmat3 zrotate(float t) {\n    return mat3(\n        \t\tcos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0\n    \t\t);\n}\n\nmat3 fullRotate(vec3 r) { \n   return xrotate( r.x ) * yrotate( r.y ) * zrotate( r.z );\n}\n\nvec3 opRep( vec3 p, vec3 c ) {\n    return mod(p,c)-0.5*c;\n}\n\nfloat smin( float a, float b, float k ){\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n    \n}\nfloat opBlend( float d1, float d2 ) {\n    return smin( d1 , d2 , 0.7);    \n}\n\nfloat opS( float d1, float d2 ) {\n    return max(-d2,d1);\n}\nfloat opU( float d1, float d2 ) {\n    return min(d1,d2);\n}\n\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdCross( in vec3 p, float w ) {\n  float inf = 30.;\n  float da = sdBox(p.xyz,vec3(inf, w, w));\n  float db = sdBox(p.yzx,vec3(w, inf, w));\n  float dc = sdBox(p.zxy,vec3(w, w ,inf));\n  return min(da,min(db,dc));\n} \n\nvec2 distance_to_obj(in vec3 p) {\n    float t = iTime / 4.;\n    float w = 1.7 - length(p) / 20.;\n    float map = \n        opBlend(\n            sdCross(p * fullRotate(vec3(t, 0., t)), w),\n            sdCross(p * fullRotate(\n                vec3(\n                    -PI / 4. + t, 0., PI / 4. + t\n                )),\n                w\n            )\n        );\n    \n     \n    \n  return vec2(map, 1.);\n}\n\nvec3 opTwist( vec3 p, float r ) {\n    float  c = cos(r * p.y + r);\n    float  s = sin(r * p.y + r);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n\nfloat shadow( in vec3 ro, in vec3 rd, in float maxt)\n{\n\tfloat res = 3.0;\n    float dt = 0.04;\n    float t = .02;\n    for( int i=0; i < 32; i++ )\n    {       \n        float h = distance_to_obj(ro + rd * t).x;\n        if( h < 0.001 ) return 0.0;\n        res = min( res, maxt*h/t );\n        t += h;\n    }\n    return res;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 vPos = fragCoord.xy / iResolution.xy - 0.5;\n  float k = iTime/ 2.0;\n  bool dist = false;\n  float n = (ceil(noise(vec2(vPos.y + sin(k))) * 10.))/ 10.;\n  \n  if (abs(n) < 0.00000001) {\n      dist = true;\n      vPos.x += ceil(vPos.y * 8.) / 64.;\n  }\n    \n  // Camera setup.\n  vec3 vuv = vec3(0, sin(k), cos(k)); // Camera up vector.\n  vec3 prp = vec3(sin(k) * 40., 1. , cos(k) * -40.); //cam position\n  vec3 vrp = vec3(10., 0., 0.); //lat\n    \n  vec3 vpn = normalize(vrp - prp) ;\n  vec3 u = normalize(cross(vuv, vpn));\n  vec3 v = cross(vpn, u);\n  vec3 vcv = (prp + vpn);\n  vec3 scrCoord = (vcv + vPos.x * u * iResolution.x/iResolution.y + vPos.y * v);\n  vec3 scp = normalize(scrCoord - prp);\n  float glow = 0.;\n    \n  //\n  float f = .0;\n  float minDist= 1000.;\n  \n  for(int i = 0; i < 38; i++) {\n    if ((abs(d.x) < .005) || (f > maxd)) break;\n    \n    f += d.x;\n\n    p = prp + scp * f;\n    p = opTwist(p, 0.08 * sin(k)) * fullRotate(vec3(k * 1.2));\n    \n    //d = distance_to_obj(p);\n    d = distance_to_obj(p) / 1.2; // fixed glithces\n    \n    minDist = min(minDist, d.x * 4.);\n    glow = pow( 1. / minDist, 0.4);  \n  }\n  \n  if (f < maxd) {\n      Color = texture(iChannel0, p) / 2. + texture(iChannel0, -reflect(p, scp)) / 2.;\n      Color *= shadow( p, scp, 12.);\n  } else {\n       Color = texture(iChannel0, scp) - vec4(0.0, 0.2, 0.3, 0.);\n       if (dist) Color = vec4(Color.r);  \n       Color += glow * glow;\n  }  \n    \n  fragColor = Color; \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}