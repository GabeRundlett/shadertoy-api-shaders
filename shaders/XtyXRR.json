{
    "Shader": {
        "info": {
            "date": "1482487024",
            "description": "Particle transparency demo",
            "flags": 0,
            "hasliked": 0,
            "id": "XtyXRR",
            "likes": 0,
            "name": "Particle transparency demo",
            "published": 3,
            "tags": [
                "particletransparencydemo"
            ],
            "usePreview": 0,
            "username": "BiiG",
            "viewed": 577
        },
        "renderpass": [
            {
                "code": "//\n// Lit transluent particle system using ray marching and signed distance sphere\n// \n\nconst float kMinStep = 0.05;\n\nfloat SDToPlane ( in vec4 plane, in vec3 point )\n{    \n    \n    return dot (plane.xyz, point ) + plane.w;      \n}\n\nfloat SDToSphere( in vec4 sphere, in vec3 point )\n{    \n    vec3 vDelta = point - sphere.xyz;\n    return length ( vDelta ) - sphere.w;      \n}\n\nfloat smin( float a, float b )\n{\n    float k = 0.5;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sceneOpaque ( vec3 pos )\n{\n    float r;\n    \n    r = SDToPlane( vec4(0.0,1.0,-1.0,5.0), pos );\n        \n    const int nSphere = 11;\n    for ( int i = 0; i<nSphere; i++)\n    {\n        float angle = float( i ) / float(nSphere) * 3.14 * 2.0;\n        r = smin ( r, SDToSphere(vec4(cos(iTime*2.0 + angle)*2.0,sin(iTime*2.0 + angle) * 2.0,4.5,1.0+angle*float(i)*0.01), pos ) );\n    }\n    \n    r = smin ( r, SDToSphere(vec4(-cos(iTime*5.0)*0.5,-sin(iTime*7.0)*0.5,5.0,1.0), pos ) );\n    return smin ( r, SDToSphere(vec4(cos(iTime*3.0)*0.25,sin(iTime*3.0)*0.25,4.5,1.0), pos ) ); \n    \n}\n\nfloat sceneTransparent ( vec3 pos )\n{\n    float r;\n    \n    r = SDToSphere(vec4(0.5,1.0+cos(iTime),3.0,1.0), pos );        \n    r = r + smin ( SDToSphere(vec4(-0.5,0.0+cos(iTime*2.0),3.0,3.0), pos), 0.0);\n    r = r + smin ( SDToSphere(vec4(-0.0+sin(iTime*2.5),1.0+sin(iTime*3.0),2.0,1.0), pos), 0.0);    \n    r = r + smin ( SDToSphere(vec4(-0.5+cos(iTime*1.7),-1.0+cos(iTime*7.0),3.3,2.0), pos), 0.0);\n    r = r + smin ( SDToSphere(vec4(-0.25+sin(iTime*1.1),0.5+sin(iTime*8.0),2.7,1.0), pos), 0.0);    \n    r = r + smin ( SDToSphere(vec4(-1.0+sin(iTime*1.5),0.2+cos(iTime*1.5),3.2,2.0), pos), 0.0);\n    r = r + smin ( SDToSphere(vec4(-0.5+sin(iTime*0.23),0.0+cos(iTime*0.23),3.3,1.0), pos), 0.0);\n    r = r + smin ( SDToSphere(vec4(-0.25+sin(iTime*1.7),0.3+cos(iTime*1.7),3.4,1.0), pos), 0.0);\n    r = r + smin ( SDToSphere(vec4(0.25+sin(iTime*2.1),0.0+cos(iTime*2.1),3.5,9.0), pos), 0.0);\n       \n    return r;\n}\n\nvec3 SDToNormalTransparent( in vec3 pos )\n{    \n\tvec3 delta = vec3( 0.0001, 0.0, 0.0 );\n    vec3 normal;\n\t\n\tnormal.x = sceneTransparent(pos+delta.xyy) - sceneTransparent(pos-delta.xyy);\n\tnormal.y = sceneTransparent(pos+delta.yxy) - sceneTransparent(pos-delta.yxy);\n\tnormal.z = sceneTransparent(pos+delta.yyx) - sceneTransparent(pos-delta.yyx);\n    \n\treturn normalize(normal);\n}\n\nvec3 SDToNormal( in vec3 pos )\n{    \n\tvec3 delta = vec3( 0.0001, 0.0, 0.0 );\n    vec3 normal;\n\t\n\tnormal.x = sceneOpaque(pos+delta.xyy) - sceneOpaque(pos-delta.xyy);\n\tnormal.y = sceneOpaque(pos+delta.yxy) - sceneOpaque(pos-delta.yxy);\n\tnormal.z = sceneOpaque(pos+delta.yyx) - sceneOpaque(pos-delta.yyx);\n    \n\treturn normalize(normal);\n}\n\nvoid mainImage( out vec4 outColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 plane = vec4(0.0,1.0,-0.5,4.0);\n    plane.xyz = normalize(plane.xyz);\n    \n    vec4 pBackground = vec4(0.0,0.0,-1.0,20.0);\n    pBackground.xyz = normalize(pBackground.xyz);\n    \n    vec3 lightPos = vec3 ( 1.0, 3.0, 2.0 );    \n    \n    vec3 ViewPos = vec3 (sin(iTime)*1.0,1.0,cos(iTime)*2.0);\n    vec3 ray = vec3(uv*2.0-1.0,9.0);\n    ray.y += sin(iTime)*0.5;\n    ray = ray * vec3(16.0,9.0,1.0); // Aspect ratio\n    ray = normalize(ray);\n    \n    vec4 sum = vec4(0.0,0.0,0.0,0.0);    \n    const float nearPlane = 2.0;\n    const float farPlane  = 20.0;\n    vec3  orgRay = ray;\n    vec3  orgRayA = orgRay;\n    vec4  LightColor = vec4(1.0,0.7,0.5,1.0);\n    \n    \n    float rayStep = farPlane;\n    \n    const int kSteps = 16;\n    const float kfSteps = float(kSteps);\n    const float lightOneOverRange = 1.0 / 10.0; \n        \n    float signedDistance;\n    // Ray march opaque scene\n    for (int i=1; i<kSteps; i++ )\n    {\n        vec3 pos = ray + ViewPos;                     \n\n        signedDistance = sceneOpaque ( pos );               \n\n        pos = pos + orgRay * min(signedDistance,0.0);\n\n        // Compute lighting\n        vec3 normal = SDToNormal ( pos );\n        vec3 lightDir = normalize( lightPos - pos);\n        float attenuation = min ( length ( pos - lightPos ) * lightOneOverRange, 1.0 );\n        attenuation = 1.0 - attenuation * attenuation;\n        float diffuse = max ( dot ( normal, lightDir ) * attenuation, 0.1 ) ; \n\n        sum.rgba += (signedDistance<=0.0?1.0:0.0)*vec4(diffuse,diffuse,diffuse, 1.0)*LightColor;     \n\n        signedDistance = (signedDistance<=0.0)?1.0:signedDistance;\n        \n        float greyLevel = ( sin(pos.x*cos(pos.y)*5.0) + 1.0 );\n        \n        sum.rgb *= vec3 ( greyLevel,greyLevel,greyLevel );\n        \n        if ( sum.a>=1.0 ) break;       \n        \n        ray = ray + orgRay * max ( signedDistance*1.33, kMinStep );       \n    }\n        \n    vec3 pos = vec3(0.0,0.0,0.0);   \n    float start = sceneTransparent ( orgRay + ViewPos );    \n    float rayLen = length(ray)-start;       \n    vec4 sumA = vec4(0.0,0.0,0.0,0.0);\n    float lastd = 0.0;\n    \n    // Tansparent scene\n    for (int i=1; i<kSteps; i++ )\n    {\n        vec3 lightDir;\n        float ni = float(i)/kfSteps;\n        pos = normalize(ray) * ( start + ni * ni * rayLen ) + ViewPos;\n                \n        float d;\n        vec3 normal;\n        float lRange = 50.0;                \n        \n        d = sceneTransparent ( pos );\n         \n        normal = SDToNormalTransparent ( pos );\n        lightDir = normalize( lightPos - pos); \n\n        float att = min ( length ( pos - lightPos ) / lRange, 1.0 );\n        att = 1.0 - att * att;\n        \n        // Front lighting\n        float diffuse = max ( (dot ( normal, lightDir ) ) * att, 0.0 ) ;  \n        \n        // back lighting for fake transluency\n        diffuse += max ( -(dot ( normal, lightDir ) ) * att * 0.33, 0.0 ) ;  \n\n        float dd = abs ( min(d,0.0) - min(lastd,0.0)  );        \n        lastd = d;\n        \n        float density = 0.15;\n                \n        dd -= min((sumA.a-dd*density)*density,0.0);\n        \n        vec4 color = vec4(1.0,0.5,0.5,1.0);\n        sumA.rgba += vec4(dd*diffuse,dd*diffuse,dd*diffuse*uv.x, dd*density*uv.y) * color * LightColor; \n\n        if ( sumA.a >= 1.0 ) break;\n        \n        ray = ray + orgRay;         \n    }\n    \n    // Blend alpha colors\n    sum = sum*(1.0-sumA.a) + sumA*sumA.a;\n    \n\toutColor = vec4(sum);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}