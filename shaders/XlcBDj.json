{
    "Shader": {
        "info": {
            "date": "1540999661",
            "description": "see CommonTab\n\nfollowup is\nhttps://www.shadertoy.com/view/XlcBDj",
            "flags": 0,
            "hasliked": 0,
            "id": "XlcBDj",
            "likes": 7,
            "name": "starguitar 4",
            "published": 3,
            "tags": [
                "intersection",
                "synthesis",
                "aperiodic",
                "culling",
                "aabv",
                "starguitar",
                "quadraticfield",
                "hash41",
                "nancarrow"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 912
        },
        "renderpass": [
            {
                "code": "void mainImage(out ve3 o,ve1 u\n){o=entryImage(iTime,u,iResolution,iMouse)\n ;}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//self:   https://www.shadertoy.com/view/XlcBDj\n//parent: https://www.shadertoy.com/view/lldfDB\n//parent: https://www.shadertoy.com/view/MttfWB\n//intersection, synthesis, aperiodic, culling, aabv, starguitar, quadraticfield, hash41, nancarrow\n\n/*\ndrag mouse to set blue boxes\n- source is 2 blue boxes, that either\n- - contain another\n- - intersect\n- - are seperate\n- target is 1 yellow box; iff(not seperate) return AABV; else return box that is closer to uv.\n\n\niMouse.xz set centers of 2 boxes\niMouse.zw set 2 halfwidths of 2 boxes\ncan be represented as triangles (red and green)\n, where imouse.xy sets +one triangle top\n, where imouse.zw sets +one triangle top\nline intersections (2 o 3 yellow dots) equate box intersections\n//if (bottom intersection.y<=0) the boxes intersect ([<=] for closedInterval, [<] for openInterval boxes)\n//top intersection.xy sets an AABV upper bound of both boxes\n\nIt alway bugged me how to define midi sheets, but also as distance field.x\n, where a note stops and another note starts, often at the same moment\nthis is a min() of 2 notes, that may or may not be the same single long note.\nthe whole .y domain is only relevant for visualization here.\nin a \nhttps://www.shadertoy.com/results?query=starguitar\nshader the .y domain will be \"frequency\" or \"keyboard key\" == frequency, scaled by a note key using;\nhttps://www.shadertoy.com/view/4ttBD4\n*/\n\n/*\nassume uv.x to be time\nassume uv.y to be frequency (piano key id)\n\nblue is a usual distance field, for now only rectangles are defined with this the \"starguitar\" extension\n- bright blue  means negative distance to a box surface\n- bright green means \"-(green) more iTime till first note starts\" (it counts up)\n\ngreen or red only measure Distance.x\ngreen is the (negative) distance to the nearest box to the right.\nred   is the (negative) distance to the nearest box to the left.\n\nuv.xy taps one point in time for one freuency. if its blue, there is a note played at iTime.x\n- green == how long this note has been played (till iTime == now)\n- red   == how long till this note ends       (till iTime == now) //not needed for pluck/percussion instruments\n\nred and green are negated (!)\n- to avoid overlap, when using the same fract() or smin() functions as for \"blue\"\n- to make the inherent (parallel projection) frustrum culling debugging easier.\n\nand only an min() union is defined, that was tricky enough\n- any break between 2 notes will appear yellow (or black with negateRG)\n- , this the negative-color of the note in terms of duration.\nred and green are negated to use the same smin() function to make them visible\n, without overlapping too much.\n*/\n\n//invert redGreen\n//#define negateRG\n\n//alternative color sceme fallof; *=1.-log(abs())\n//#define showGradLog\n\n/*\n\"starguitar\" defines shapes, where .w is the usual distance field as in the hg_sdf collection\nwhile .xy define center and (half)length of a note\nthe min() max() mixing cases for this had to be debugged in here\nbecause there are multiple different ways to bound this.\n\na possible extension to this, with derivatives, may even generate\nhttps://www.youtube.com/watch?v=4t0jDUQ2aJ4\nhttps://www.youtube.com/watch?v=RIz3klPET3o\nhttps://www.youtube.com/watch?v=XJpVbUICUb4\nbut procedurally\n*/\n\n\n\n#define vec1 float\n#define pi acos(-1.)\n#define tau pi*2.\n//float tau=6.2831853071795864769252867665590057683943387987502116419;//trig definition can be better for smarter compilers.\n#define eul 2.7182818284590452353602874713526624977572470936999595749\n//eul=exp(1.)???\n//\"goldenRatio\"=phi+1=Phi :where: 1/phi=phi-1&&1/Phi=Phi-1\n//https://en.wikipedia.org/wiki/Golden_ratio\n#define phi (sqrt(5.)*.5-.5)\n//goldenRatio is great fun with fract(),good for hashes.\n#define Phi (sqrt(5.)*.5+.5)\n#define sat(x)clamp(x,0.,1.)\n#define dd(a)dot(a,a)\n#define u5(a)((a)*.5+.5)\n#define u2(a)((a)*2.-1.)\n//#define ss(a,u)smoothstep(a,-a,u)//bad namespace for this,more trouble than its worth\nvec1 suv(vec4 a){return dot(vec4(1),a);}vec1 suv(vec3 a){return dot(vec3(1),a);}vec1 suv(vec2 a){return a.x+a.y;}//sum of vector\n#define minx(a,b)mix(b,a,step(a.x,b.x))\n#define manx(a,b)mix(a,-b,step(a.x,-b.x))\n#define maxx(a,b)-minx(-a,-b)\n\n\n//2d zoom\n#define ViewZoom 8.\n//divide by/aa for hairline drawing and sharp smoothstep()\n#define Aa(r) (min(r.x,r.y)/ViewZoom)\n#define fra(t,u,r,m)(u-.5*r.xy)*ViewZoom/r.y\n\n//array indexing srarts at 0 within chinese remainders.\n#define ve0 float\n#define ve1 vec2\n#define ve2 vec3\n#define ve3 vec4\n\nve0 ma(ve1 a){return max(a.x,a.y);}\n\n#define inf 99999.\n\n/*\nve2 box(ve1 u,ve1 w\n){w=abs(w)//no negative width\n ;ve2 r=ve2(-inf,-inf,1)\n ;r.z =ma(abs(u)-w)\n  ;r.y=w.x\n  ;r.x=u.x//this is much different for other shapes, only for simple shapes its close to r.z\n ;return r;}\n\n//t is time.x, we ned that to be able to only return 1 of 2 boxes, the one that is cloder to t.\nvec3 misg(float t,vec3 a,vec3 b){//.x stores center.x , .y stores halfwidth.x  , .z stores a \"distance\"\n ;vec3 r=vec3(0)\n ;return r\n ;}\n\n\nvec3 masg(vec3 a,vec3 b){\n ;vec3 r=vec3(0)\n ;r.x=min(a.x,b.x)\n ;r.y=min(a.y,b.y)\n ;r.z=max(a.z,b.z)\n ;//if(r.x<r.y)r.z-r.z\n ;return r\n ;}\n\n\nvec3 composition(float t,vec2 u,vec3 r,vec4 m){\n ;vec3 c=vec3(0)\n ;c.xyz=box(u-m.xy,vec2(0.61))\n ;//c.xyz=box(u-m.xy,vec2(1.25,.5))\n ;//c.xyz=box(u-m.xy,vec2(.5))\n ;c.xyz=misg(u.x,c.xyz,box(u,vec2(1.61))  )\n ;//c.xyz=masg(c.xyz,box(u-m.xy,vec2(1.)))\n ;return c\n ;}\n/**/\n\nvec4 segmentToTriangle(float t,vec2 u,vec3 r,vec2 m){\n ;vec4 c=vec4(0)\n ;c.x=-u.x+u.y+m.x-m.y\n ;c.y=-u.x-u.y+m.x+m.y\n ;c.z=u.y\n ;c=abs(c)\n ;return c;}\n\n#define tiny 0.0001\n    \nvec2 gLLxX(vec2 A,vec2 B,vec2 C,vec2 D//get intersection of line[a,b] and line[c,d]\n){vec2 b=B-A,d=D-C,c=C-A\n ;float dotperp=b.x*d.y-b.y*d.x\n ;dotperp=max(abs(dotperp),tiny)*sign(dotperp)//jumps from -tiny to +tiny, lazy 0-avoidance, lines are never parallel!\n ;float t=(c.x*d.y-c.y*d.x)/dotperp\n ;return vec2(A.x+t*b.x,A.y+t*b.y);}//http://wiki.secondlife.com/wiki/Geometric\n//return distance to [wedge.rounded.circle],circle/IniniteLineSegment end at m.xy,the other line is horizontal.\n\n#define ls2(a,c) dd((a-(c*sat((dot(a,c)/dd(c))))))//sqared orthogonal projection ,ls()sub ,is squared distance\n#define ls(a,b,c) sqrt(ls2((a-b),(c-b)))//pointAdistance to (diagonal) lineSegment from B to C\n\nvec4 miNote(float t,vec2 u,vec3 r,vec4 m\n){vec4 c=vec4(0)\n ;if(m.x>m.z)m=m.zwxy\n ;vec4 n=m\n ;m.yw=abs(m.yw)//below code only allows for width>=0\n ;c=     segmentToTriangle(t,u,r,m.xy)\n ;vec4 d=segmentToTriangle(t,u,r,m.zw)\n ;c=min(c,d)-.1//this sets up an intersection-puzzle-solved below:\n ;//my intersection code is naive, as in, it takes lineSegmentEndpoints as input\n ;vec2 a0=vec2(m.x-m.y,0);vec2 a1=a0+vec2( 1,1);c.x=min(c.x,ls(u,a0,a1)-.2)//outer red\n ;vec2 a2=vec2(m.z+m.w,0);vec2 a3=a2+vec2(-1,1);c.y=min(c.y,ls(u,a2,a3)-.2)//outer green\n ;vec2 i=gLLxX(a0,a1,a2,a3)//outer intersection (upper yellow dot)     \n ;vec2 b0=vec2(m.z-m.w,0);vec2 b1=b0-vec2( 1,1);c.x=min(c.x,ls(u,b0,b1)-.2)//inner red\n ;vec2 b2=vec2(m.x+m.y,0);vec2 b3=b2-vec2(-1,1);c.y=min(c.y,ls(u,b2,b3)-.2)//inner green\n ;vec2 j=gLLxX(b0,b1,b2,b3)//outer intersection (lower yellow dot)\n ;c.w=        abs(length(u-m.zw)-.2)   //smallest yellow dot (mouse cursor, but swaps in a mirror symmetry)\n ;c.w=min(c.w,abs(length(u-i   )-.4)) //                   (higher intersection)\n ;c.w=min(c.w,abs(length(u-j   )-.6)) //largest yellow dot (lower intersection); iff(lower than 0) 2 seperate boxes\n ;//c.w=abs(c.w-.3)//increase width of dot on top of triangle\n\n ;c.z=min(c.z,abs(ma(abs(u-vec2(m.x,0)))-abs(m.y)))//left  blue box (optional source puzzle vis)\n ;c.z=min(c.z,abs(ma(abs(u-vec2(m.z,0)))-abs(m.w)))//right blue box (optional source puzzle vis)\n\n ;if(j.y<0.//iff (2 yellow boxes are seperate (open intervals) )\n ){\n  ;if(u.x<j.x)//smart split, we only calculate whats in view, messes with gradient.y, which we dont care for.\n              c.w=min(c.w,abs(ma(abs(u-vec2(m.x,0)))-abs(m.y)))//left  yellow box\n  ;else       c.w=min(c.w,abs(ma(abs(u-vec2(m.z,0)))-abs(m.w)))//right yellow box\n  ;c.w-=.05 //add yellow thickness\n ;}else{//else( 2 yellow boxes intersecting  (open intervals) (or one is inside the other))\n     ;if(max(i.y,j.y)<max(m.w,m.y) //iff (one box is completely inside the other) return larger box\n     ){m.xy=mix(m.xy,m.zw,step(m.y,m.w))\n       ;c.w=min(c.w,abs(ma(abs(u-vec2(m.x,0)))-abs(m.y)))\n     //else 2 boxes intersect, make AABV upper bound\n     ;}else c.w=min(c.w,abs(ma(abs(u-vec2(i.x,0)))-i.y))//combined yellow box\n    ;c.w-=.05 //add yellow thickness\n ;}\n //above 3 cases are sorted, meaning\n //, there is no transition traition from [non intersecting] to [one inside the other]\n //, ithout forst transitioning to [intersectiing]\n ;c.z-=.02//add blue   thickness\n ;return c\n ;}\n\nve3 entryImage(ve0 t,ve1 u,ve2 r,ve3 m){\n ;ve3 c=ve3(0,0,0,1)\n ;u   =fra(t,u   ,r,m)\n ;if(m.z>0.){\n  ;m.xy=fra(t,m.xy,r,m)\n  ;m.zw=fra(t,m.zw,r,m)\n ;}else{//iMouse is cos(hash41Aperiodic())\n   ;m=sqrt(vec4(5,11,3,13))-vec4(21,2,1,17) //QuadraticField: see: https://www.shadertoy.com/view/Xt3BDB\n   ;m=sin(m*t*.15)//time as seed for hash m.\n   ;//m=fract(m*4500.)//optional obfuscation\n   ;m.yw=m.yw*.5+.5//mirror symmetry on y=0\n   ;m*=ViewZoom*.4//view scale\n ;}\n\n ;c=miNote(t,u,r,m)\n    \n #ifdef negateRG\n ;c.xy=-c.xy\n #endif\n ;vec4 l=vec4(1)\n #ifdef showGradLog\n ;l=(1.-log(abs(c.xyzw*.4)))\n #endif\n ;c.x=mix(smoothstep(.01,-.01,c.x)*l.x,fract(c.x)*l.x,.3)\n ;c.y=mix(smoothstep(.01,-.01,c.y)*l.y,fract(c.y)*l.y,.3)\n ;c.z=mix(smoothstep(.01,-.01,c.z)*l.z,fract(c.z)*l.z,.2)\n ;c.w=mix(smoothstep(.01,-.01,c.w)*l.w,fract(c.w)*l.w,.1)\n \n ;//c.xy*=(1.-log(abs(c.xy)))//nah, just too confusing\n ;//c.y=0.\n     //;c.xy=vec2(0)\n ;c.xy=mix(c.xy,sat(c.ww),.7)\n ;c=sat(c)\n ;return c\n ;}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}