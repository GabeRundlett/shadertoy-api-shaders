{
    "Shader": {
        "info": {
            "date": "1500354639",
            "description": "An Apollonian structure.",
            "flags": 0,
            "hasliked": 0,
            "id": "4d2BW1",
            "likes": 88,
            "name": "[SH17A] Apollonian Structure",
            "published": 3,
            "tags": [
                "fractal",
                "raymarch",
                "apollonian",
                "minimal",
                "tweet"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 3135
        },
        "renderpass": [
            {
                "code": "/*\n\tApollonian Structure\n\t--------------------\n\n\tOverall, there's nothing particularly exciting about this shader, but I've \n\talways liked this structure, and thought it'd lend itself well to the two \n\ttweet environment.\n\n\tI couldn't afford shadows, AO, etc, so applied a bit of fakery to at least\n\tconvey that feel.\n\n\n*/\n\n// Apollonian based fractal: I couldn't find the original source, but it's\n// been around for a while. IQ has a really cool variation here: \n// Apollonian: https://www.shadertoy.com/view/4ds3zn\n//\n// I'm guessing the original was posted by someone on a fractal forum somewhere \n// at some stage.\n//\nfloat m(vec3 p){\n    \n    // Moving the scene itself forward, as opposed to the camera.\n    // IQ does it in one of his small examples.\n    p.z += iTime;\n    \n    // Loop counter and variables.\n    float i = 0., s = 1., k;\n\n\t// Repeat Apollonian distance field. It's just a few fractal related \n    // operations. Break up space, distort it, repeat, etc. More iterations\n    // would be nicer, but this function is called a hundred times, so I've\n    // used the minimum to give just enough intricate detail.\n    while(i++ < 6.) p *= k = 1.5/dot(p = mod(p - 1., 2.) - 1., p), s *= k;\n\t\t\n\t// Render numerous little spheres, spread out to fill in the \n    // repeat Apollonian lattice-like structure you see.\n    //\n    // Note the \".01\" at the end. Most people make do without it, but\n    // I like the tiny spheres to have a touch more volume, especially\n    // when using low iterations.\n    return length(p)/s - .01; \n    \n}\n\n\nvoid mainImage( out vec4 c, vec2 u)\n{\n    // Direction ray and origin. By the way, you could use \"o = d/d\" (Thanks, Fabrice),\n    // then do some shuffling around in the lighting calculation, but I didn't quite \n    // like the end result, so I'll leave it alone, for now anyway.\n    vec3 d = vec3(u/iResolution.y - .5, 1)/4., o = vec3(1, 1, 0);\n\n    // Initialize to zero.\n    c -= c;\n    \n    // Raymarching loop -- sans break, which always makes me cringe. :)\n    while(c.w++<1e2) o += m(o)*d;\n\n    \n    // Lame lighting - loosely based on directial derivative lighting and the \n    // way occlusion is performed, but mostly made up. It'd be nice to get rid \n    // of that \"1.1,\" but it's kind of necessary.  Note that \"o.z\" serves as  \n    // a rough distance estimate, and to give a slight volumetric light feel. \n    //c += (m(o - .01)*m(o - d)*4e1 + o.z*1.1 - 2.)/o.z;\n    // I stared at the line above for ages and got nothing. Fabrice looked at it\n    // instantly, and saw the obvious. :)\n    c += (m(o - .01)*m(o - d)*4e1 - 2.)/o.z + 1.1;\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}