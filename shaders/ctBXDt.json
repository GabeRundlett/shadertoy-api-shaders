{
    "Shader": {
        "info": {
            "date": "1676744286",
            "description": "an experiment with raytraced reflections and shadows,  use the mouse to move the light. Ray bounces increase over time",
            "flags": 8,
            "hasliked": 0,
            "id": "ctBXDt",
            "likes": 3,
            "name": "Newton's cradle",
            "published": 3,
            "tags": [
                "raytracing"
            ],
            "usePreview": 0,
            "username": "dphillip11",
            "viewed": 335
        },
        "renderpass": [
            {
                "code": "//number of light bounces\nint BOUNCES = 1;\nstruct cylinder\n{\n    vec3 centre;\n    vec3 axis;\n    float length;\n    float radius;\n};\n\nstruct Box\n{\n    vec3 centre;\n    vec3 size;\n};\n\n\n//////////////////////objects\n\n//collider ID's\nconst int NO_COL = -2;\nconst int GROUND = -1;\nconst int BALL[5] = int[5](0,1,2,3,4);\nconst int BASE = 5;\nconst int FRAME = 6;\nconst int PIPEJOINT = 7;\nconst int STRINGS = 8;\nconst int CUBEMAP = 9;\n\n\ncylinder frame[8] = cylinder[8](\n    //frame\n    cylinder(vec3(0., 8., 8.), vec3(1, 0, 0), 10., 0.25),\n    cylinder(vec3(0., 8., 2.), vec3(1, 0, 0), 10., 0.25),\n    cylinder(vec3(-5, 8., 5.), vec3(0, 0, 1), 6., 0.25),\n    cylinder(vec3(5, 8., 5.), vec3(0, 0, 1), 6., 0.25),\n    //legs\n    cylinder(vec3(-5, 4., 2.), vec3(0, 1, 0), 8., 0.25),\n    cylinder(vec3(-5, 4., 8.), vec3(0, 1, 0), 8., 0.25),\n    cylinder(vec3(5, 4., 2.), vec3(0, 1, 0), 8., 0.25),\n    cylinder(vec3(5, 4., 8.), vec3(0, 1, 0), 8., 0.25));\n    \ncylinder strings[10];\n   \nvec4 balls[5] = vec4[5](\n    //balls\n    vec4(-4., 2, 5, 1), \n    vec4(-2, 2, 5, 1), \n    vec4(0., 2, 5, 1), \n    vec4(2, 2, 5, 1), \n    vec4(4, 2, 5, 1));\n\nvec4 pipeJoints[4] = vec4[4](\n    //pipe joints\n    vec4(-5, 8, 2, 0.25), \n    vec4(5, 8, 2, 0.25), \n    vec4(-5, 8, 8,0.25), \n    vec4(5, 8, 8, 0.25));\n\nconst float MAP_SIZE = 20.;\nBox base = Box(vec3(0,0.25,5),vec3(11.25,0.5,7));\nBox cubeMap = Box(vec3(0,0,5),vec3(MAP_SIZE,90.,MAP_SIZE));\n\nvec3 ballColor[5] = vec3[5](vec3(1, 0, 0), vec3(0, 1, 0), vec3(0, 0, 0), vec3(0, 0, 1), vec3(1, 1, 0));\nvec3 frameColor = vec3(0.3, 0.3, 0.3);\nvec3 groundColor = vec3(0.3, 0.05, 0.4);\nvec3 skyColor = vec3(0.5, 0.8, 1);\nvec3 stringColor = vec3(0.4, 0.4, 0.4);\nvec3 baseColor = vec3(214., 141., 6.)/255.;\nvec3 cubeMapColor = vec3(0.1, 0.1, 0.1);\n\nstruct Camera\n{\n    vec3 pos;\n    vec3 target;\n    float depth;\n    vec3 up;\n    vec3 right;\n    vec3 forward;\n};\n\n\nCamera cam = Camera(vec3(1),vec3(0,5,3),0.7,vec3(0,1,0),vec3(1,0,0), vec3(0,0,1));\n\nvec3 light_pos;\nfloat reflectionDenominator = 150.;\nfloat shininess_ball = 128.;\nfloat shininess_frame = 90.;\nfloat shininess_base = 32.;\nfloat shininess_ground = 16.;\nfloat shininess_string = 5.;\nfloat shininess_cubeMap = 128.;\nfloat ambientIntensity = 0.3;\n\n\n\nstruct intersection {\n    int collider;\n    float distance;\n    vec3 normal;\n    vec3 point;\n    vec3 reflectDir;  \n};\n\nvoid GetGroundIntersection(vec3 ray_origin, vec3 ray_dir, inout intersection intx)\n{\n    //check intersection with ground, y=0\n    if (ray_origin.y > 0. && ray_dir.y < 0.)\n    {\n        float d = abs(ray_origin.y / ray_dir.y);\n        \n        if (d > 0. && (intx.collider == NO_COL || d < intx.distance))\n        {  \n            intx.collider = GROUND;\n            intx.distance = d;\n            intx.normal = vec3(0,1,0);\n        }\n    }\n}\n\nvoid GetSphereIntersection(vec3 ray_origin, vec3 ray_dir, vec4 sphere, inout intersection intx, int ID)\n{\n        //vector to sphere directly\n        vec3 sphere_dir = sphere.xyz - ray_origin;\n        //calculate projection along ray direction\n        float dotP = dot(sphere_dir, ray_dir);\n        //ignore spheres in opposite direction\n        if (dotP < 0.)\n            return;\n        vec3 ray_proj = dotP * ray_dir;\n        float ray_length = length(ray_proj);\n        vec3 ray_point = ray_proj + ray_origin;\n        //distance from line to centre\n        float d = length(sphere.xyz - ray_point);\n        if (d > sphere.w)\n            return;\n        //calculate sphere intersection, pythagoras\n        float overlap = sqrt(pow(sphere.w, 2.) - pow(d, 2.));\n        ray_length -= overlap;\n        if (ray_length < intx.distance || intx.collider == NO_COL)\n        {\n            intx.distance = ray_length;\n            intx.collider = ID;\n            intx.normal = normalize(ray_origin + ray_length * ray_dir - sphere.xyz);\n        }\n}\n\nvoid WorldSphereIntersections(vec3 ray_origin, vec3 ray_dir, inout intersection intx)\n{\n    for (int i = 0; i < balls.length(); i ++)\n    {\n          GetSphereIntersection(ray_origin, ray_dir, balls[i], intx, BALL[i]);     \n    }\n    for (int i = 0; i < pipeJoints.length(); i ++)\n    {\n          GetSphereIntersection(ray_origin, ray_dir, pipeJoints[i], intx, PIPEJOINT);     \n    }\n}\n\nvoid GetCubeMapIntersection(vec3 ray_origin, vec3 ray_dir, Box box, inout intersection intx, int ID)\n{\n\n     float dz = (sign(ray_dir.z) * MAP_SIZE - ray_origin.z + 5.) / ray_dir.z;\n     float dx = (sign(ray_dir.x) * MAP_SIZE - ray_origin.x) / ray_dir.x;\n     //throwing error when the second normal is set correctly\n     vec3 normal = dz > 0. && dz < dx ? vec3(0,0,-sign(ray_dir.z)): vec3(-1,0,0); \n     float d = min(abs(dz),abs(dx));   \n     if (d > 0. && (intx.collider == NO_COL || d < intx.distance))\n     {  \n        intx.collider = ID;\n        intx.distance = d;\n        intx.normal = normal;\n     }\n}\n\nvoid GetBoxIntersection(vec3 ray_origin, vec3 ray_dir, Box box, inout intersection intx, int ID)\n{\n    vec3 m = 1.0 / ray_dir;\n    vec3 n = m * (ray_origin - box.centre);\n    vec3 k = abs(m) * 0.5 * box.size;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n\n    if (tN > tF || tF < 0.0)\n        return;\n\n    vec3 oN = -sign(ray_dir) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);\n\n    if (tN > 0. && tN < intx.distance)\n    {\n        intx.distance = tN;\n        intx.normal = oN;\n        intx.collider = ID;\n    }\n\n}\n\nvoid WorldBoxIntersections(vec3 ray_origin, vec3 ray_dir, inout intersection intx)\n{\n    GetBoxIntersection(ray_origin, ray_dir, base, intx, BASE);\n    GetCubeMapIntersection(ray_origin, ray_dir, cubeMap, intx, CUBEMAP);  \n}\n    \nvoid GetCylinderIntersection(vec3 ray_origin, vec3 ray_dir, cylinder cyl, inout intersection intx, int ID)\n{\n   vec3 A = cyl.centre - cyl.axis * (cyl.length * 0.5);\n   vec3 OA = ray_origin - A;\n   float a = dot(ray_dir, ray_dir) -pow(dot(ray_dir, cyl.axis),2.);\n   float b = 2. * (dot(ray_dir,OA) - dot(ray_dir,cyl.axis) * dot(OA, cyl.axis));\n   float c = dot(OA,OA) - pow(dot(OA,cyl.axis),2.) - pow(cyl.radius,2.);\n   \n   float det = b*b - 4.*a*c;\n   if (det<0.)\n       return;\n   float t1 = (-b+sqrt(det))/(2.*a);\n   float t2 = (-b-sqrt(det))/(2.*a);\n   float distance = min(t1,t2);\n   vec3 t = ray_origin + distance * ray_dir;\n   vec3 At = t-A;\n   float axisPos = dot(At, cyl.axis);\n   if (axisPos > cyl.length || axisPos < 0.)\n      return;\n  \n   if (distance >= 0. && (distance < intx.distance || intx.collider == NO_COL))\n   {\n       intx.collider = ID;\n       intx.distance = distance;\n       vec3 point = ray_origin + ray_dir * distance;\n       vec3 c2p = point - cyl.centre;\n       vec3 normal = c2p - dot(c2p, cyl.axis) * cyl.axis;\n       intx.normal = normalize(normal);\n   }\n}\n\nvoid WorldCylinderIntersections(vec3 ray_origin, vec3 ray_dir, inout intersection intx)\n{\n    for (int i = 0; i < frame.length(); i ++)\n    {\n         GetCylinderIntersection(ray_origin, ray_dir, frame[i], intx, FRAME);\n    }\n    for (int i = 0; i < strings.length(); i ++)\n    {\n         GetCylinderIntersection(ray_origin, ray_dir, strings[i], intx, STRINGS);\n    }\n}\n\nintersection GetIntersection(vec3 ray_origin, vec3 ray_dir)\n{\n    intersection intx = intersection(NO_COL,0., vec3(0), vec3(0),vec3(0));\n    \n    GetGroundIntersection(ray_origin, ray_dir, intx);\n    \n    WorldSphereIntersections(ray_origin, ray_dir, intx);\n    \n    WorldBoxIntersections(ray_origin, ray_dir, intx);\n    \n    WorldCylinderIntersections(ray_origin, ray_dir, intx); \n    \n    intx.point = ray_origin + ray_dir * intx.distance;\n    intx.reflectDir = normalize(reflect(ray_dir, intx.normal));\n    \n    return intx;\n    \n}\n\nfloat GetLocalDiffuse(vec3 point, vec3 normal, vec3 ray_dir)\n{\n    vec3 light_dir = normalize(light_pos - point);\n    //check if light is obstructed\n    intersection incomingLight = GetIntersection(point, light_dir);\n    float obstructedModifier = 1.;\n    if (incomingLight.collider != NO_COL && incomingLight.collider != CUBEMAP)\n        obstructedModifier = 0.4;\n    //calculate diffuse value\n    float diffuseIntensity = 0.6 * max(dot(light_dir, normal), 0.);\n    return diffuseIntensity * obstructedModifier + ambientIntensity;\n}\n\n\n\nvec3 GetLocalColor(vec3 ray_dir, intersection intx, inout float multiplier)\n{\n\n    if (intx.collider == NO_COL)\n    {\n        return (0.3 + abs(ray_dir.z)) * skyColor;\n    }\n    \n    vec3 materialColor;\n    float reflectivity;\n    float shininess;\n    \n    if (intx.collider == GROUND)\n    {\n        vec3 col = 0.2 + 0.5*cos(iTime+intx.point.xzx/MAP_SIZE+vec3(0,2,4));\n        materialColor = col;\n        shininess = shininess_ground;\n    }\n    else if (intx.collider == FRAME || intx.collider == PIPEJOINT)\n    {\n        materialColor = frameColor;\n        shininess = shininess_frame;  \n    }\n    else if (intx.collider < BASE)\n    {\n        materialColor = ballColor[BALL[intx.collider]];\n        shininess = shininess_frame;  \n    }\n    else if (intx.collider == BASE)\n    {\n        materialColor = baseColor;\n        shininess = shininess_frame;  \n    }\n    else if (intx.collider == STRINGS)\n    {\n        materialColor = stringColor;;\n        shininess = shininess_string; \n    }\n     else if (intx.collider == CUBEMAP)\n    {\n        materialColor =  cubeMapColor * ((sin(iTime)+1.)*0.3)/(intx.point.y * 0.05);\n        shininess = shininess_cubeMap; \n    }\n    reflectivity = shininess/reflectionDenominator;\n    multiplier *= reflectivity;\n    //diffuse\n    vec3 diffuseColor = GetLocalDiffuse(intx.point, intx.normal, ray_dir) * materialColor;\n    //reflected\n    vec3 light_dir = normalize(light_pos - intx.point);\n    //specular\n    vec3 specular = pow(max(dot(light_dir, intx.reflectDir), 0.), shininess) * vec3(1);\n    \n    return diffuseColor + specular;\n\n}\n\n\nvoid TraverseLightPath(vec3 ray_dir, inout intersection intx, inout vec3 totalColor, inout float multiplier)\n{\n    totalColor += multiplier * GetLocalColor(ray_dir, intx, multiplier);\n    intx = GetIntersection(intx.point, intx.reflectDir);\n}\n\nvec3 GetColor(vec3 ray_origin, vec3 ray_dir)\n{\n    float multiplier = 1.;\n    vec3 totalColor = vec3(0);\n    intersection intx = GetIntersection(ray_origin, ray_dir);\n    \n    for (int i = 0; i < BOUNCES; i ++)\n    {\n        TraverseLightPath(ray_dir, intx, totalColor, multiplier);\n        ray_dir = intx.reflectDir;\n    }\n    totalColor = clamp(totalColor, vec3(0),vec3(1));\n    return totalColor;\n}\n\n\nvoid PositionBalls()\n{\n    float angle = 0.4 * sin(iTime * 3.);\n    //vertical and hoirizonatl components of rotated line\n    float xD1 = 6. * max(sin(angle),0.);\n    float xD2 = 6. * min(sin(angle),0.);\n    float yD1 = 6. - (6. * cos(min(angle,0.)));\n    float yD2 = 6. - (6. * cos(max(angle,0.)));\n    float xDiffs[5] = float[5](xD2, 0.3 * xD2,  0.,  0.3 * xD1 , xD1);\n    float yDiffs[5] = float[5](yD1, 0.3 * yD1,  0.,  0.3 * yD2 , yD2);\n    vec3 spacing = vec3(2,0,0);\n    //string length coefficient\n    float sC = 5./6.;\n    \n    vec3 topPos1 = vec3(-4., 7.75, 8.);\n    vec3 topPos2 = vec3(-4., 7.75, 2.);\n    \n    for(int i = 0; i < balls.length(); i++)\n    {\n        balls[i].xyz = vec3(-4. + xDiffs[i] + spacing.x * float(i), 2. + yDiffs[i], 5.);\n        \n        //calculate string positions\n        \n        vec3 bottomPos = vec3(-4. + 2. * float(i) + xDiffs[i] * sC, 3. + yDiffs[i] * sC, 5.);\n        vec3 position1 = (topPos1 + bottomPos) * 0.5;\n        vec3 axis1 = normalize(topPos1-bottomPos);\n        vec3 position2 = (topPos2 + bottomPos) * 0.5;\n        vec3 axis2 = normalize(topPos2-bottomPos);\n    \n        strings[2 * i] = cylinder(position1, axis1, 6., 0.02);\n        strings[2 * i + 1] = cylinder(position2, axis2, 6., 0.02);\n    \n        topPos1 += spacing;\n        topPos2  += spacing;\n    }\n   \n}\n\n\nvec3 GetRayDir(vec2 uv)\n{\n    vec3 rayScreenIntersection = vec3(cam.pos + uv.x * cam.right + uv.y * cam.up + cam.depth * cam.forward);\n    vec3 rayDir = normalize(rayScreenIntersection - cam.pos);\n    return rayDir;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    light_pos = vec3(15. * sin(iTime / 5.), 20., 5. + 15. * cos(iTime / 10.));\n    PositionBalls();\n    BOUNCES = int(1.5 * iTime/3.14) % 10 + 1;\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float iMousex = clamp(iMouse.x, - iResolution.x, iResolution.x);\n    float iMousey = clamp(iMouse.y, - iResolution.y, iResolution.y);\n    cam.pos = cam.target + vec3(10. * sin(iMousex / 100.), 15. * max(sin((1.57 * iMousey - 0.3 *iResolution.y)/iResolution.y),0.) , 10. * cos(iMouse.x/ 100.));\n\n    //align with camera\n    cam.forward = normalize(cam.target - cam.pos);\n    cam.right = normalize(cross(vec3(0., 1., 0.), cam.forward));\n    cam.up = normalize(cross(cam.forward, cam.right));\n    \n    vec3 raydir = GetRayDir(uv);\n    vec3 color = GetColor(cam.pos, raydir);\n\n    // Output to screen\n    fragColor = vec4(color, 01);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//borrowed from https://www.shadertoy.com/view/sdsXWr\nvec2 mainSound( int samp, float T )\n{\n    float \n        f = 3./3.14,\n        t = fract(T*f),\n        m = smoothstep(.01, 0., t),\n        w = cos(t*1e5);\n    return vec2( w*m );\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}