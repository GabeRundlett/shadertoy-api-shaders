{
    "Shader": {
        "info": {
            "date": "1620051524",
            "description": "I found this interesting variant of noise when I made my autodiff utilities.",
            "flags": 0,
            "hasliked": 0,
            "id": "sdjSDR",
            "likes": 7,
            "name": "FBM Waves",
            "published": 3,
            "tags": [
                "noise",
                "waves",
                "fbm"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 155
        },
        "renderpass": [
            {
                "code": "#define draw(d, c) color = mix(color, c, smoothstep(unit, 0.0, d))\n\nvec2 noise(in vec2 x) {\n    return fFract(367.436 * fCos(439.573 * x));\n}\n\nvec2 snoise(in vec2 x) {\n    return fMix(noise(fFloor(x)), noise(fCeil(x)), fSmoothstep(const2dual(0.0), const2dual(1.0), fFract(x)));\n}\n\nvec2 rollingNoise(in vec2 x, in float scale, in float roll, in int octaves) {\n    x /= scale;\n\n    vec2 value = const2dual(0.0);\n    float tscale = 0.0;\n    float nscale = 1.0;\n\n    for (int o=0; o < octaves; o++) {\n        value += snoise(x - const2dual(roll)) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n        x *= 2.0;\n    }\n\n    return value / tscale;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 8.0;\n    float unit = 16.0 / iResolution.y;\n\n    // Draw the function\n    vec2 y = rollingNoise(var2dual(uv.x), 3.0, iTime, 10) * 3.0;\n    float d = abs(uv.y - y.x) / sqrt(1.0 + y.y * y.y);\n\n    fragColor = vec4(smoothstep(unit, 0.0, d) + 0.25 * y.x);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec2 const2dual(in float x) {\n    return vec2(x, 0.0);\n}\n\nvec2 var2dual(in float x) {\n    return vec2(x, 1.0);\n}\n\nvec2 fMul(in vec2 a, in vec2 b) {\n    return vec2(a.x * b.x, a.x * b.y + a.y * b.x);\n}\n\nvec2 fDiv(in vec2 a, in vec2 b) {\n    return vec2(a.x / b.x, (b.x * a.y - a.x * b.y) / (b.x * b.x));\n}\n\nvec2 fSquare(in vec2 z) {\n    return vec2(z.x * z.x, 2.0 * z.x * z.y);\n}\n\nvec2 fCos(in vec2 z) {\n    return vec2(cos(z.x), -sin(z.x) * z.y);\n}\n\nvec2 fMin(in vec2 a, in vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nvec2 fMax(in vec2 a, in vec2 b) {\n    return a.x > b.x ? a : b;\n}\n\nvec2 fFloor(in vec2 z) {\n    return vec2(floor(z.x), 0.0);\n}\n\nvec2 fCeil(in vec2 z) {\n    return vec2(ceil(z.x), 0.0);\n}\n\nvec2 fFract(in vec2 z) {\n     return vec2(fract(z.x), z.y);\n}\n\nvec2 fClamp(in vec2 z, in vec2 edge0, in vec2 edge1) {\n    return fMax(edge0, fMin(edge1, z));\n}\n\nvec2 fSmoothstep(in vec2 edge0, in vec2 edge1, in vec2 z) {\n    z = fClamp(fDiv(z - edge0, edge1 - edge0), vec2(0.0), vec2(1.0, 0.0));\n    vec2 sq = fSquare(z);\n    return 3.0 * sq - 2.0 * fMul(sq, z);\n}\n\nvec2 fMix(in vec2 a, in vec2 b, in vec2 t) {\n    return a + fMul(b - a, t);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}