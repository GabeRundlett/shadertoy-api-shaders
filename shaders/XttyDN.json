{
    "Shader": {
        "info": {
            "date": "1532695700",
            "description": "impuse sets position, scale and offset of 2 glyphs of different color.\nleft half inverts some color parameters to show laplachians\n\nmixing glyphs with deferred sqrt() has its tricky parts.",
            "flags": 0,
            "hasliked": 0,
            "id": "XttyDN",
            "likes": 1,
            "name": "fast procedural glyph mixing",
            "published": 3,
            "tags": [
                "mix",
                "sqrt",
                "glyph",
                "deferred"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 496
        },
        "renderpass": [
            {
                "code": "\n//the shape is a placeholder for a glyph that has parametric circles/lines/width, as a placeholder for [any letter]\n//it has mirror symmetry to have dynamit width set easily.\n//it is measured twice, to aim for overlapping glyphs with different colors.\n//goal was to deferr the sqrt(), to do less sqrt, but in the end , vectorizing the sqrt is the best i could do.\n//the hart lesson here is that only with offset==0 yo can do min() before sqrt()\n//- i keep trying to delay the sqrt after the min()&max() but it results in [offset boolean algebra], likely unwanted overlapping/unions/intersections.\n\n//error, if 2 glyphs happen to have perfectly overapping segments, they have a [colring-dispute]\n//intersections are almost fine here, the dispute is the a [laplachian discontinuity]\n\n\n//2 lesons here; \n//- the min of an offset root must com eafter the a=abs(sqrt(a))-offset);ot it becomes [offset booean algebra]\n//- - cute but not wanted here.\n//if i want 2 glyphs in the same cell with 2 colors, i must to 2 times; root(vec2()); once for each offset.\n//there is no deferring of roots here, only vectrizing.\n\n#define ViewZoom 1.\n\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n\n\n#define fra(u)(u-.5*iResolution.xy)*ViewZoom/iResolution.y\nvec2 fra2(vec2 u){float r=iResolution.x/iResolution.y;u-=.5;u*=ViewZoom;u.x*=r;return u;}//fra2(u)=fra(u*iResolution)\n\n\n#define dd(a) dot(a,a)\n\nv0 mav(v1 a){return max(a.y,a.x);}v0 mav(v2 a){return max(a.z,mav(a.xy));}v0 mav(v3 a){return max(mav(a.zw),mav(a.xy));}\n#define miv(a)-mav(-a)\n\n//float analstretch(float a,float b){b*=.5;return sign(a-b)*max(abs(a-b)-b,0.);} //stretch() is only stretching to positive.\n#define stretch2(a,b)sign(a)*max(abs(a)-b,0.)\n#define stretch(a,b)stretch2(a-b*.5,b*.5)\n\n/*\nvec3 glyph(vec2 u,vec2 m){vec3 c=vec3(0)\n ;c.g=length(vec2(abs(u.x)-m.x-m.y,stretch(u.y,m.y)))\n ;c.b=length(vec2(stretch2(u.x,m.x),abs(u.y)-m.y))\n ;u.x=abs(u.x)-m.x//+m.y //thee +m.y makes the mirror symmetry weird\n ;c.r=abs(length(u)-m.y)\n //;c.x=miv(c);c=c.xxx//to greyscale\n ;return c;}*/\n \nvec2 glyph2(vec2 u,vec2 m){vec2 c=vec2(0)\n ;c.x=dd(vec2(abs(u.x)-m.x-m.y,stretch(u.y,m.y*3.)))\n ;c.y=dd(vec2(stretch(u.x,m.x),abs(u.y)-m.y))\n ;c.x=miv(c)\n ;u.x=abs(u.x)-m.x//+m.y //thee +m.y makes the mirror symmetry weird\n ;c.y=dd(u)\n ;return c;}\n\nvec2 glyph3(vec2 u,vec2 m){u.y-=m.y*3.-.4;u.x-=m.x*2.-.2;return glyph2(u,m);}//is the same shape as glyph2() but [a semitone higher] and offset for overlap.\nvec3 bilin(vec3 a,vec3 b,vec3 c,vec3 d,vec2 z){return mix(mix(a,b,z.x),mix(c,d,z.x),z.y);}\n\nvoid mainImage(out vec4 O,in vec2 u){\n ;u=fra(u)\n ;vec2 m=fra(iMouse.xy)\n //;vec2 n=fra(iMouse.zw) \n ;vec2 d=fract(u)\n ;vec3 c=vec3(1) \n ;m.y=abs(m.y)\n //;c=glyph(u,m)\n ;vec2 n=m;\n ;n.x=abs(n.x)\n ;vec2 e=glyph2(u,n)\n ;vec2 f=glyph3(u,n)//2 different glyph shapes, but with the same prameters/offsets/radii\n \n \n ;vec4 j=vec4(e,f);j.yz=j.zy\n ;j=sqrt(j) //at least we vectorized 4 sqrt's of 2 overlapping glyphs, while maintaining egment colorID\n ;j.zw=abs(j.zw-m.y)\n ;float d1=min(j.x,j.z)\n ;float d2=min(j.y,j.w)//2 distances as if they would be a special case ofthis generalization;\n ;vec2 gt=vec2(sign(d1-d2),sign(min(j.x,j.y)-min(j.z,j.w)))*.5+.5//gt is either (0,0);(0,1);(1,0);or(1,1), fot bilinear mixing.\n ;c.x=min(d1,d2);c=c.xxx\n ;vec2 i=vec2(-1,1)*sign(m.x)*.01\n ;c=smoothstep(i.x,i.y,c)\n ;c*=bilin(vec3(1,0,0),vec3(0,1,0),vec3(0,0,1),vec3(1,1,0),gt)\n\n ;O=vec4(c,1);}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}