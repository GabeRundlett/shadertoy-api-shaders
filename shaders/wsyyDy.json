{
    "Shader": {
        "info": {
            "date": "1603632622",
            "description": "Some quick experiment with an N octave fbm.",
            "flags": 0,
            "hasliked": 0,
            "id": "wsyyDy",
            "likes": 3,
            "name": "Noise test lab",
            "published": 3,
            "tags": [
                "noise"
            ],
            "usePreview": 0,
            "username": "Miestrode",
            "viewed": 399
        },
        "renderpass": [
            {
                "code": "#define ZOOM 1.0\n#define BOUND 1.0\n#define DARKNESS 1.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // zooming and positioning\n    vec2 uv = ( ( fragCoord/iResolution.xy + iTime / 4.0 )/ZOOM + 1.0 );\n\t\n    // coloring\n    vec3 col = vec3( wFbm( vec3( uv, iTime / 10.0 ), 2, 2 ) + BOUND)/ DARKNESS;\n\t\n    // tinting\n    col *= vec3( 0.7, 0.2, 0.4 );\n    col += 0.8;\n    \n    // Output to screen\n    fragColor = vec4( col ,1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// hashes by IQ\n\n// 1d, 2d and 3d hashing functions, used for generating random numbers.\n// based on coordinates in order to then generate terrain.\n// The hashing functions are a lower dimensional version\n// of the 3D variant.\nfloat hash( in float x )\n{\n    vec3 p = vec3( x, 1.0, 1.0 );\n    \n    p = 50.0*fract( p*0.3183099 + vec3( 0.71, 0.113, 0.419 ) );\n    return -1.0+2.0*fract( p.x*p.y*p.z*( p.x + p.y + p.z ) );\n}\n\n// Still the same exact thing, all of those could probably\n// be optimized for their respective dimension, but it\n// worked well enough.\nfloat hash( in vec2 x )\n{\n    vec3 p = vec3( x, 1.0 );\n    \n    p = 50.0*fract( p*0.3183099 + vec3( 0.71, 0.113, 0.419 ) );\n    return -1.0+2.0*fract( p.x*p.y*p.z*( p.x + p.y + p.z ) );\n}\n\n// The actual 3D version of the hashing function, those\n// will later be used for noise function.\nfloat hash( in vec3 x )\n{\n    vec3 p = x;\n    \n    p = 50.0*fract( p*0.3183099 + vec3( 0.71, 0.113, 0.419 ) );\n    return -1.0+2.0*fract( p.x*p.y*p.z*( p.x + p.y + p.z ) );\n}\n\n// 2D and 3D noise surface functions.\n// used for constructing fractional brownian motion surfaces.\nfloat noise( in vec2 x )\n{\n    vec3 p = vec3( floor(x), 0.0 );\n    vec3 w = vec3( fract(x), 0.0 );\n\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n\n    float a = hash( p + vec3( 0, 0, 0 ) );\n    float b = hash( p + vec3( 1, 0, 0 ) );\n    float c = hash( p + vec3( 0, 1, 0 ) );\n    float d = hash( p + vec3( 1, 1, 0 ) );\n    float e = hash( p + vec3( 0, 0, 1 ) );\n    float f = hash( p + vec3( 1, 0, 1 ) );\n    float g = hash( p + vec3( 0, 1, 1 ) );\n    float h = hash( p + vec3( 1, 1, 1 ) ); \n\n    float k0 =                               a;\n    float k1 =                           b - a;\n    float k2 =                           c - a;\n    float k3 =                           e - a;\n    float k4 =                   a - b - c + d;\n    float k5 =                   a - c - e + g;\n    float k6 =                   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return float( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n\n    float a = hash( p + vec3( 0, 0, 0 ) );\n    float b = hash( p + vec3( 1, 0, 0 ) );\n    float c = hash( p + vec3( 0, 1, 0 ) );\n    float d = hash( p + vec3( 1, 1, 0 ) );\n    float e = hash( p + vec3( 0, 0, 1 ) );\n    float f = hash( p + vec3( 1, 0, 1 ) );\n    float g = hash( p + vec3( 0, 1, 1 ) );\n    float h = hash( p + vec3( 1, 1, 1 ) ); \n\n    float k0 =                               a;\n    float k1 =                           b - a;\n    float k2 =                           c - a;\n    float k3 =                           e - a;\n    float k4 =                   a - b - c + d;\n    float k5 =                   a - c - e + g;\n    float k6 =                   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return float( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z) );\n}\n// analytic derivatives of the 2D and 3D surface noise functions.\n// used for assigning colors to terrain based on steepness.\nvec3 noiseD( in vec2 x )\n{\n    vec3 p = vec3( floor(x), 0.0 );\n    vec3 w = vec3( fract(x), 0.0 );\n\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du =   30.0*w*w*(w*(w-2.0)+1.0);\n\n    float a = hash( p + vec3( 0, 0, 0 ) );\n    float b = hash( p + vec3( 1, 0, 0 ) );\n    float c = hash( p + vec3( 0, 1, 0 ) );\n    float d = hash( p + vec3( 1, 1, 0 ) );\n    float e = hash( p + vec3( 0, 0, 1 ) );\n    float f = hash( p + vec3( 1, 0, 1 ) );\n    float g = hash( p + vec3( 0, 1, 1 ) );\n    float h = hash( p + vec3( 1, 1, 1 ) ); \n\n    float k0 =                               a;\n    float k1 =                           b - a;\n    float k2 =                           c - a;\n    float k3 =                           e - a;\n    float k4 =                   a - b - c + d;\n    float k5 =                   a - c - e + g;\n    float k6 =                   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec3(2.0* du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                                k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                            k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\n\nvec3 noiseD( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du =   30.0*w*w*(w*(w-2.0)+1.0);\n\n    float a = hash( p + vec3( 0, 0, 0 ) );\n    float b = hash( p + vec3( 1, 0, 0 ) );\n    float c = hash( p + vec3( 0, 1, 0 ) );\n    float d = hash( p + vec3( 1, 1, 0 ) );\n    float e = hash( p + vec3( 0, 0, 1 ) );\n    float f = hash( p + vec3( 1, 0, 1 ) );\n    float g = hash( p + vec3( 0, 1, 1 ) );\n    float h = hash( p + vec3( 1, 1, 1 ) ); \n\n    float k0 =                               a;\n    float k1 =                           b - a;\n    float k2 =                           c - a;\n    float k3 =                           e - a;\n    float k4 =                   a - b - c + d;\n    float k5 =                   a - c - e + g;\n    float k6 =                   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec3(2.0* du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                                k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                            k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\n\n// fractional brownian motion based noise modification with d octaves for 2D and 3D noise. \n// used for generating more realistic terrain.\nfloat fbm( in vec2 p, in int d )\n{\n    float n = 0.0;\n    \n    for( int i = 0; i < d; i++ )\n    {\n    \tn += pow( 1.5, -float( i ) )*noise( p*( pow( 2.14, float( i ) ) ) );\n    }\n    \n    return n;\n}\n\nfloat fbm( in vec3 p, in int d )\n{\n    float n = 0.0;\n    \n    for( int i = 0; i < d; i++ )\n    {\n    \tn += pow( 1.5, -float( i ) )*noise( p*( pow( 2.14, float( i ) ) ) );\n    }\n    \n    return n;\n}\n\n// fractional brownian motion based noise analytic derivative modification with d octaves for 2D and 3D noise/\n// used for getting the derivative of the realistic terrain.\nvec3 fbmD( in vec2 p, in int d )\n{\n    vec3 n = vec3(0.0);\n    \n    for( int i = 0; i < d; i++ )\n    {\n    \tn += pow( 1.5, -float( i ) )*noiseD( p*( pow( 2.14, float( i ) ) ) );\n    }\n    \n    return n;\n}\n\nvec3 fbmD( in vec3 p, in int d )\n{\n    vec3 n = vec3(0.0);\n    \n    for( int i = 0; i < d; i++ )\n    {\n    \tn += pow( 1.5, -float( i ) )*noiseD( p*( pow( 2.14, float( i ) ) ) );\n    }\n    \n    return n;\n}\n\n// warped fractional brownian motion surface.\n// works by re-entering input into the fbm.\nfloat wFbm( in vec2 p, in int w, in int d )\n{\n    vec2 x = vec2( fbm( p, d ), fbm( p*4.568934, d ) );\n    \n    for( int i = 0; i < w; i++ )\n    {\n    \tfloat t1 = 0.0;\n    \tfloat t2 = 0.0;\n        \n    \tt1 =          fbm( x, 1 );\n        t2 = fbm( x*4.568934, 1 );\n        \n        x = vec2( t1, t2 );\n    }\n    \n    return float( x );\n}\n\nfloat wFbm( in vec3 p, in int w, in int d )\n{\n    vec2 x = vec2( fbm( p, d ), fbm( p*4.568934, d ) );\n    \n    for( int i = 0; i < w; i++ )\n    {\n    \tfloat t1 = 0.0;\n    \tfloat t2 = 0.0;\n        \n    \tt1 =          fbm( vec3( x, 1.0 ), d );\n        t2 = fbm( vec3( x*4.568934, 1.0 ), d );\n        \n        x = vec2( t1, t2 );\n    }\n    \n    return float( x );\n}\n\nfloat wFbmD( in vec2 p, in int w, in int d )\n{\n    vec2 x = vec2( fbmD( p, d ).x, fbmD( p*4.568934, d ).y );\n    \n    for( int i = 0; i < w; i++ )\n    {\n    \tfloat t1 = 0.0;\n    \tfloat t2 = 0.0;\n        \n    \tt1 =          fbmD( x, 1 ).x;\n        t2 = fbmD( x*4.568934, 1 ).y;\n        \n        x = vec2( t1, t2 );\n    }\n    \n    return float( x );\n}\n\nfloat wFbmD( in vec3 p, in int w, in int d )\n{\n    vec2 x = vec2( fbmD( p, d ).x, fbmD( p*4.568934, d ).y );\n    \n    for( int i = 0; i < w; i++ )\n    {\n    \tfloat t1 = 0.0;\n    \tfloat t2 = 0.0;\n        \n    \tt1 =          fbmD( vec3( x, 1.0 ), d ).x;\n        t2 = fbmD( vec3( x*4.568934, 1.0 ), 1 ).y;\n        \n        x = vec2( t1, t2 );\n    }\n    \n    return float( x );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}