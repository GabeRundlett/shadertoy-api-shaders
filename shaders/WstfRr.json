{
    "Shader": {
        "info": {
            "date": "1604309595",
            "description": "Full screen recommended.",
            "flags": 9,
            "hasliked": 0,
            "id": "WstfRr",
            "likes": 43,
            "name": "[â™ª]Flythrough",
            "published": 3,
            "tags": [
                "raymarching",
                "music"
            ],
            "usePreview": 0,
            "username": "Catzpaw",
            "viewed": 1516
        },
        "renderpass": [
            {
                "code": "//--- Flythrough\n// by Catzpaw 2020\n\n#define ITER 192\n#define EPS 1e-5\n#define NEAR 0.0\n#define FAR 120.0\n\n// \"Log-Bisection Tracing\" by Nimitz\n// https://www.shadertoy.com/view/4sSXzD\nfloat trace(vec3 ro,vec3 rd,out float n){\n    float t=NEAR,lt=t;\n    vec3 p=ro+rd*t;\n    float d=map(p);\n    bool s=d>0.?true:false;\n    bool b=false;\n    for(int i=ZERO;i<ITER;i++){\n        if(abs(d)<EPS*t||t>FAR)break;            \n       \tif((d>0.)!=s){b=true;break;}\n        lt=t;\n        t+=d>.5?d*.5:log(abs(d)+1.);\n        p=ro+rd*t;\n       \td=map(p);\n       \tn+=.6;\n    }\n    if(b){\n        float m=0.;\n        p=ro+lt*rd;\n        s=map(p)>0.?true:false;;\n        for(int i=ZERO;i<6;i++){ \n            m=(lt+t)*.5;\n            p=ro+rd*m;\n            d=map(p);\n            if(abs(d)<EPS*t)break;\n            (d<0.)==s?t=m:lt=m;\n        }\n        t=(lt+t)*.5;\n    }\n    return t;\n}\n\n//MAIN\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv=(fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec3 rd=vec3(uv,-.4);\n\tfloat z=-(iTime+CUE)*2.2;\n\tvec3 ro=camPath(z);\n\tvec3 cr=normalize(camPath(z-2.5)-camPath(z-3.));\n\trd.xz*=rot(cr.x*1.8);\n\trd.yz*=rot(cr.y*1.5);\n\tfloat n=0.,v=trace(ro+vec3(0,-0.2,0),rd,n)/FAR;n/=float(ITER);\n\tfragColor=vec4(mix(hsv(1.-n,1.-n,v),vec3(1),n),v);\n}\n\n//VR\nvoid mainVR(out vec4 fragColor,in vec2 fragCoord,in vec3 fragRayOri,in vec3 fragRayDir){\n    vec2 uv=(fragCoord.xy-vec2(.25,.5)*iResolution.xy)/iResolution.y;\n\tfloat z=-(iTime+CUE)*2.2;\n    vec3 rd=fragRayDir;\n\tvec3 ro=camPath(z)+fragRayOri;\n\tvec3 cr=normalize(camPath(z-2.5)-camPath(z-3.));\n\trd.xz*=rot(cr.x*1.8);\n\trd.yz*=rot(cr.y*1.5);\n\tfloat n=0.,v=trace(ro+vec3(0,-0.2,0),rd,n)/FAR;n/=float(ITER);\n\tfragColor=vec4(mix(hsv(1.-n,1.-n,v),vec3(1),n),1);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//--- Flythrough\n// by Catzpaw 2020\n\n//Sound:music & SFX\n\nconst bool enableDroneSound=true;\nconst bool enableMusic=true;\n\n//---Scale Sequencer 2 by Catzpaw 2020\n//https://www.shadertoy.com/view/3tVGz3\n\n//SETUP\nconst float base =432.;\t//A tuning (Hz)\nconst float bpm  =135.;\t//beats per minute\nconst float steps=240.;\t//block length\nconst float start=8.;   //start count (beats)\nconst float fade =10.;  //fade out time (sec)\nconst float sec  =180.; //performance time (includes fade out time and start count)\nconst float gateseed=92.;\nconst float noteseed=31.;\nconst int chord3=2; //3rd tone(default:2)\nconst int chord5=4; //5th tone(default:4)\n\n//SCALE\nint key=4; //0:C 1:C+ 2:D 3:D+ 4:E 5:F 6:F+ ... 11:B\nint scale=10;\nconst uint[12] scl=uint[](\n    0xcb975420u, //0:major\n    0xca875320u, //1:natural minor\n    0xcb875320u, //2:harmonic minor\n    0xcb975320u, //3:melodic minor\n    0xa9765320u, //4:blues octatonic\n    0xa9764310u, //5:blues diminished octatonic\n    0xc9974420u, //6:major pentatonic (to heptatonic)\n    0xca775530u, //7:minor pentatonic (to heptatonic)\n    0xcb775540u, //8:ryukyu pentatonic (to heptatonic)\n    0xcb755420u, //9:ryukyu hexatonic (to heptatonic)\n    0xba875410u, //10:maqam hijaz octatonic\n    0xba876320u);//11:gypsy minor octatonic\nint scalenote(int y){\n    return y<0?-999:key+((int(scl[scale])>>(y&7)*4)&15);\n}\n\n//PATTERN\n// melodic:range(4),rest(4),seed1(12),seed2(12)\n// percussive:note(2x16)\nconst uint[32] pat=uint[](\n    0x37000000u,0x37011171u,0x47012172u,0x37011773u,  //00-   melody\n    0x37054394u,0x37054c95u,0x44226166u,0x34617167u,\n    0x34028168u,0x34019119u,0x4401a11au,0x3440417cu,  //  -0B\n    0x31001434u,0x31001491u,0x31001022u,0x31001022u,  //0C-0F backing\n    0x10000000u,0x10000000u,0x10000000u,0x10000000u,  //10-13 chord\n    0x180BA008u,0x10000000u,0x10000000u,0x10000000u,  //14-17 bass\n    0x150A150Au,0x10000000u,0x10000000u,0x10000000u,  //18-1B power sd\n    0xB9B9B9B9u,0xB9B9B9B9u,0xB9B9B9B9u,0xB9B9B9B9u); //1C-1F bd+hh\n\n//SEQUENCE\n// speed(4),degree1(4),pattern1(8),division(4),degree2(4),pattern2(8)\n// speed    0:0.5x 1:1x 2:2x 3:4x\n// degree   0:mute 1:I  2:II 3:III 4:IV 5:V 6:VI 7:VII\n// division 0-f ... timing to switch pattern1 to pattern2 (0:only pattern2)\nconst uint[16] seq1=uint[]( //snare+hihat\n    0x11000118u,0x11000118u,0x11000118u,0x11188118u,\n    0x11000118u,0x11000118u,0x11000118u,0x11000118u,\n    0x11000118u,0x11000118u,0x11000118u,0x11188118u,\n    0x11000118u,0x11000118u,0x11000118u,0x11000118u);\nconst uint[16] seq2=uint[]( //bassdrum+conga\n    0x1100011eu,0x1100011eu,0x1100011eu,0x111ee11fu,\n    0x1100011eu,0x1100011eu,0x1100011eu,0x111e811fu,\n    0x1100011eu,0x1100011eu,0x1100011eu,0x111e811fu,\n    0x1100011eu,0x1100011eu,0x1100011eu,0x1100011fu);\nconst uint[16] seq3=uint[]( //bass\n    0x11000114u,0x11000114u,0x11000114u,0x11000114u,\n    0x11000114u,0x11000114u,0x11000114u,0x11000114u,\n    0x11000114u,0x11000114u,0x11000114u,0x11000114u,\n    0x11000114u,0x11000114u,0x11000114u,0x11000114u);\nconst uint[16] seq4=uint[]( //chord\n    0x11000110u,0x11000510u,0x11000710u,0x11000312u,\n    0x11000110u,0x11000510u,0x11000210u,0x11000613u,\n    0x11000110u,0x11000510u,0x11000710u,0x11000312u,\n    0x11000110u,0x11000510u,0x11000210u,0x11000613u);\nconst uint[16] seq5=uint[]( //backing\n    0x1100010cu,0x1100050cu,0x1100070cu,0x130d830eu,\n    0x1100010cu,0x1100050cu,0x1100020cu,0x160d860fu,\n    0x1100010du,0x1100050cu,0x1100070du,0x130d830eu,\n    0x1100010du,0x1100050cu,0x1100020du,0x160d860fu);\nconst uint[16] seq6=uint[]( //melody\n    0x11000101u,0x11000502u,0x11000703u,0x11000304u,\n    0x11000101u,0x11000502u,0x11000203u,0x11000605u,\n    0x11000106u,0x11000507u,0x11000708u,0x11000309u,\n    0x11000106u,0x11000507u,0x1100020Au,0x1100060Bu);\n\n//BIT OPERATION\nint imod(int x,int y){return int(x-y*(x/y));}\nint imod(uint x,uint y){return int(x-y*(x/y));}\nint get12(uint b,int l){return int(b>>l*4)&4095;}\nint get8(uint b,int l){return int(b>>l*4)&255;}\nint get4(uint b,int l){return int(b>>l*4)&15;}\nint get2(uint b,int l){return int(b>>l*2)&3;}\n\n//NES SOUND GENERATORS(without DPCM)\nfloat osc_duty(float x,float d){return fract(x)<d?1.:-1.;}\nfloat osc_tri4(float x){return abs(floor(fract(x)*15.9999)/7.5-1.);}\nconst float[16] nt=float[](2.,4.,8.,16.,32.,48.,64.,80.,101.,127.,190.,254.,381.,508.,1017.,2034.);\nfloat osc_nesnoise(float x,int i){return fract(sin(floor(x*1789772.5/nt[i])*179.2)*204.8);}\n\n//WAVETABLE OSC(namco C30/N163)\n//sound0:flute  ADFF DA75 4456 9ABB A852 0025\n//sound1:brass  BFED ED93 0378 78CF C621 2104\n//sound2:organ  87D7 F7F7 D7A7 8582 8080 8287\n//sound3:piano  BEFF EBA9 9998 7666 6541 0014\n//sound4:harpsi BDEF 000F EDB9 6421 0fff 0124\n//sound5:bass   0033 2266 0033 CCFF 99DD CCFF\n//sound6:octsqr 0000 00AA AAAA 5555 55FF FFFF\n//sound7:octsaw 0123 4567 89AB 4567 89AB CDEF\nconst uint[24] wt=uint[](\n    0x000bb8bau,0x100de7fdu,0x203efdefu,0x303ff7dfu,0x4020efedu,0x5020b7dau,0x6a60af97u,0x7a6f9735u,\n    0x8a0e9d04u,0x9a0d9734u,0xaa3b9a75u,0xba398786u,0x45c67879u,0x55c4658au,0x65f268cbu,0x75f162fbu,\n    0x859068cau,0x959f5068u,0xafdf4825u,0xbfdf1012u,0xcfc00820u,0xdfc10210u,0xeff21802u,0xfff44745u);\nfloat osc_c30(float x,int i){return(float((wt[int(mod(x*24.,24.))]>>(i*4))&15u)/15.-.5);}\n\n//AMP\n//  vec3 p( drive, pressure, volume)\nvec2 amp(vec2 i,vec3 p){return clamp(sign(i)*pow(abs(i*p.x),vec2(1./p.y)),-1.,1.)*p.z;}\n\n//FREQUENCY FROM MIDI NOTE NUMBER\nfloat freq(float n){return pow(2.,(n-69.)/12.)*base;}\n\n//ENVELOPE\nfloat env_d(float x,float d){return max(0.,1.-x/max(d,1e-4));}\n\n//CHIPTUNE INSTRUMENTS (freq,time)\nconst float detune =.0025;\nvec2 dutybass(float f,float x){return vec2(osc_duty(f*(.5+detune),.5),osc_duty(f*(.5-detune),.5))*env_d(x,.5);}\nvec2 tri4bass(float f,float x){return vec2(osc_tri4(f*(.5+detune)),osc_tri4(f*(.5-detune)));}\nvec2 tri4lead(float f,float x){return vec2(osc_tri4(f*(1.-detune)),osc_tri4(f*(1.+detune)));}\nvec2 c30bass(float f,float x){return vec2(osc_c30(f*(1.+detune),5),osc_c30(f*(1.-detune),5))*env_d(x,.5);}\nvec2 c30chord(float f,float x){return vec2(osc_c30(f*(1.-detune),7),osc_c30(f*(1.+detune),7));}\nvec2 c30bell(float f,float x){return vec2(osc_c30(f*(1.-detune),1),osc_c30(f*(1.+detune),1))*env_d(x,.6);}\nvec2 c30lead(float f,float x){return vec2(osc_c30(f*(1.-detune),6),osc_c30(f*(1.+detune),6))*env_d(x,.5);}\n\n//CHIPTUNE PERCUSSION (time)\nfloat nessd(float x){return osc_nesnoise(x,11)*env_d(x,.2);}\nfloat neshh(float x,float d){return osc_nesnoise(x,0)*env_d(x,d);}\nfloat nesbd(float x){return osc_duty(3./(x*.5+.1),.5)*env_d(x,.2);}\nfloat neslc(float x){return osc_duty(10./(x*.3+.1),.25)*env_d(x,.05);}\nfloat neshc(float x){return osc_duty(12./(x*.3+.1),.25)*env_d(x,.05);}\n\n//\"FLYTHROUGH\" INSTRUMENTS\nfloat powersd(float x){return osc_nesnoise(x,11);}\nfloat lowsd(float x){return osc_nesnoise(x,13);}\n\n//GET PATTERN FROM SEQUENCE\nfloat mp=0.; //note length multiplier(from speed)\nint   dg=0;  //degree now playing\nuint  pt=0u;  //pattern now playing\nint   st=0;  //step now playing\nbool getpattern(float t,uint sq){\n    // speed(4),degree1(4),pattern1(8),division(4),degree2(4),pattern2(8)\n    mp=pow(2.,float(get4(sq,7)-1))*16.;\n    st=int(mod(t*bpm*mp/steps,16.));\n    bool di=int(mod(t*bpm*16./steps,16.))<get4(sq,3);\n    dg=di?get4(sq,6):get4(sq,2);\n    pt=di?pat[get8(sq,4)]:pat[get8(sq,0)];\n    return dg==0?false:true;\n}\n\n//GET NOTE FROM PATTERN\nint notegen(int s,int s1,int s2){\n    return fract(sin(float(s+s1)+float(s1*20)*gateseed)*50.)<(float(get4(pt,6))*.0625)?-1:\n    imod(int(abs(sin(float(s+s1+s*s2)*noteseed)*float(s2))),get4(pt,7));\n}\nvec4 getnote(float t,float l){\n    // melodic:range(4),rest(4),seed1(12),seed2(12)\n    int s1=get12(pt,3),s2=get12(pt,0),n=notegen(st,s1,s2);\n    float x=mod(t,l/mp);\n    if((st>=1)&&(n<0)){n=notegen(st-1,s1,s2);x+=l/mp;}\n    n+=n<0?0:dg-1;\n    return (dg<1)||(n<0)?vec4(x,-1,-1,-1):vec4(x,scalenote(n),scalenote(n+chord3),scalenote(n+chord5));\n}\nvec4 getgate(float t,float l){\n    // percussive:note(2x16)\n    int n=get2(pt,st);\n    float x=mod(t,l/mp);\n    if((st>=1)&&(n==0)){n=get2(pt,st-1);x+=l/mp;}\n    return dg<1?vec4(x,-1,-1,-1):vec4(x,n,n,n);\n}\n\n//RENDERER\nvec2 track1(float t,float l,int s){//TRACK 1 NES noise powersd,lowsd\n    vec2 o=vec2(0);\n    getpattern(t,seq1[imod(s,16)]);\n    vec4 n=getgate(t,l);\n    o+=(n.y==1.)?powersd(n.x)*.7:0.;\n    o+=(n.y==2.)?lowsd(n.x)*.3:0.;\n    o+=(n.y==3.)?neshh(n.x,.2)*.5:0.;\n    return o;\n}\nvec2 track2(float t,float l,int s){//TRACK 2 NES sqr bassdrum,closehh,openhh\n    vec2 o=vec2(0);\n    getpattern(t,seq2[imod(s,16)]);\n    vec4 n=getgate(t,l);\n    o+=(n.y==1.)?nesbd(n.x)*.6:0.;\n    o+=(n.y==2.)?neshh(n.x,.08)*.4:0.;\n    o+=(n.y==3.)?neshh(n.x,.2)*.5:0.;\n    return o;\n}\nvec2 track3(float t,float l,int s){//TRACK 3 NES sqr bass\n    vec2 o=vec2(0);\n    getpattern(t,seq3[imod(s,16)]);\n    vec4 n=getnote(t,l);\n    o+=(n.y>=0.)?dutybass(freq(n.y+36.)*n.x,n.x)*.35:vec2(0);\n    return o;\n}\nvec2 track4(float t,float l,int s){//TRACK 4 N163 chord\n    vec2 o=vec2(0);\n    getpattern(t,seq4[imod(s,16)]);\n    vec4 n=getnote(t,l);\n    o+=(n.y>=0.)?c30chord(freq(n.y+48.03)*n.x,n.x)*.3:vec2(0);\n    o+=(n.y>=0.)?c30chord(freq(n.z+48.02)*n.x,n.x)*.3:vec2(0);\n    o+=(n.y>=0.)?c30chord(freq(n.w+48.01)*n.x,n.x)*.3:vec2(0);\n    return o;\n}\nvec2 track5(float t,float l,int s){//TRACK 5 N163 synth\n    vec2 o=vec2(0);\n    getpattern(t,seq5[imod(s,16)]);\n    vec4 n=getnote(t,l);\n    o+=(n.y>=0.)?c30lead(freq(n.y+48.05)*n.x,n.x)*.2:vec2(0);\n    return o;\n}\nvec2 track6(float t,float l,int s){//TRACK 6 N163 bell\n    vec2 o=vec2(0);\n    getpattern(t,seq6[imod(s,16)]);\n    vec4 n=getnote(t,l);\n    o+=(n.y>=0.)?c30bell(freq(n.y+60.05)*n.x,n.x)*.3:vec2(0);\n    return o;\n}\nvoid render(float t,float l,inout vec2 o,bool e){\n    float c=0.;       //render target\n    int   s=int(t/l); //sequence number now playing\n    o+=  track1(t,l,s); //TRACK 1 snaredrum,closehh,openhh\n    o+=  track2(t,l,s); //TRACK 2 bassdrum,lowconga,hiconga\n    o+=  track3(t,l,s); //TRACK 3 bass\n    o+=  track4(t,l,s); //TRACK 4 chord\n    o+=  track5(t,l,s); //TRACK 5 backing\n    o+=  track6(t,l,s); //TRACK 6 melody\n}\n\n//DRONE SOUND\nvec2 drone(float x,float p,float s){\n    float fl=freq(70.01+s)*mod(x,.055),fr=freq(70.03+s)*mod(x,.054);\n    x=fract(x*5.)*.2;\n    float vl=.15-smoothstep(-1.,0.,p-1.)*.15,vr=smoothstep(0.,1.,p+1.)*.15;\n\treturn vec2((osc_duty(fl,.7)+osc_duty(fl*.5,.7)+osc_nesnoise(x,8))*vl,\n                (osc_duty(fr,.7)+osc_duty(fl*.5,.7)+osc_nesnoise(x,8))*vr);\n}\nvoid droneSound(float x,float t,inout vec2 o){\n    vec3 ro=camPath(t)+vec3(0,-.2,0),rd=vec3(0,0,-.5);\n\tvec3 cr=normalize(camPath(t-2.5)-camPath(t-3.));\n    float s=length(camPath(t-2.)-camPath(t-3.))*2.;\n    float d=0.;\n    //x=fract(x*8.)*.125;\n    o+=drone(x,0.,s);\n    vec3 sd=vec3(-.5,-.1,-.5);\n\tsd.xz*=rot(cr.x*1.8);\n\tsd.yz*=rot(cr.y*1.5);\n    d=abs(map(ro+sd)*10.);\n    o+=drone(x,-0.8,s+s)/max(d,1.);\n    sd=vec3(.5,-.1,-.5);\n\tsd.xz*=rot(cr.x*1.8);\n\tsd.yz*=rot(cr.y*1.5);\n    d=abs(map(ro+sd)*10.);\n    o+=drone(x,0.8,s+s)/max(d,1.);\n}\n\n//MASTER SECTION\n#define MASTER_DRIVE    0.4\n#define MASTER_PRESSURE 1.0\n#define DELAY_REPEAT    6\n#define DELAY_WET       0.4\n#define DELAY_FEEDBACK  0.8\n#define DELAY_TIME      0.15\nvec2 mainSound( in int samp,float time){\n    float l=steps/bpm,vol=1.,d=DELAY_WET,r=DELAY_TIME;\n    vec2 o=vec2(0);\n    if(time>sec-fade){vol=(sec-min(time,sec))/fade;}\n    if(enableDroneSound)droneSound(time,-(time+CUE)*2.2,o);\n    time-=start*60./bpm;\n    if(time>=0. && enableMusic){\n    \trender(time,l,o,true);\n    \tfor(int i=0;i<DELAY_REPEAT;i++){\n    \t    time-=r;\n    \t    if(time<0.)continue;\n    \t    vec2 a=vec2(0);\n    \t    render(time,l,a,false);\n    \t    d*=DELAY_FEEDBACK;\n    \t    r+=DELAY_TIME;\n    \t    o+=a*d;\n    \t}\n    }\n    return amp(o,vec3(MASTER_DRIVE,MASTER_PRESSURE,vol));\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "//--- Flythrough\n// by Catzpaw 2020\n\n//Common:scene SDF for Image & Sound\n\n#define CUE 0.\n\n#define OCT 4\n#define ZERO min(0,iFrame)\n\nmat2 rot(float a){float s=sin(a),c=cos(a);return mat2(c,s,-s,c);}\nvec3 hsv(float h,float s,float v){return ((clamp(abs(fract(h+vec3(0.,.666,.333))*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;}\nfloat sdCube(vec3 p,float s){p=abs(p)-s;return length(max(p,0.))+min(max(p.x,max(p.y,p.z)),0.)-.03;}\nfloat sdCubeField(vec3 p,float s,float i){p=mod(p,i)-i*.5;return sdCube(p,s);}\nfloat sdBeam(vec3 p,float s){p=abs(p)-s;return length(max(p.xy,0.))+min(max(p.x,p.y),0.)-.03;}\nvec3 camPath(float t){\n\treturn vec3(sin(t*.131)*5.+sin(t*.197)*5.+sin(t*.32)*3.,sin(t*.107)*4.+sin(t*.104)*4.+sin(t*.317)*3.,t);\n}\nfloat map(vec3 p){\n\tfloat d=0.,ld=0.,s=1.;\n\tfloat t=min(sdBeam(p-camPath(p.z),.5),sdBeam(p-camPath(p.z+60.),1.5));\n          t=min(t,sdBeam(p-camPath(p.z+280.),4.));\n\tld=max(-sdCubeField(p+15.,4.95,30.),d);\n\tfor(int i=0;i<OCT;i++){\n\t\tvec3 q=vec3(sin(s*180.)*50.,sin(s*190.)*50.,sin(s*154.)*50.);\n\t\td=max(-sdCubeField(p+q,s*.3,s),ld);\n\t\tld=d;s*=1.;p*=s*vec3(0.801,1.003,0.901);\n\t}\n\td=max(-t,d);\n\treturn d;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}