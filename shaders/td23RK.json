{
    "Shader": {
        "info": {
            "date": "1549401275",
            "description": "Just a basic raymarching loop with some shading and AO",
            "flags": 0,
            "hasliked": 0,
            "id": "td23RK",
            "likes": 3,
            "name": "Basic raymarching and AO",
            "published": 3,
            "tags": [
                "3d",
                "raymarching"
            ],
            "usePreview": 0,
            "username": "liamegan",
            "viewed": 519
        },
        "renderpass": [
            {
                "code": "  \n  // movement variables\n  vec3 movement = vec3(.0);\n  \n  const float clipNear = 0.;\n  const float clipFar = 64.;\n  \n  const int maxIterations = 256;\n  const float stopThreshold = 0.001;\n  const float stepScale = .7;\n  const float eps = 0.01;\n  \n  const vec3 clipColour = vec3(0.);\n  const vec3 fogColour = vec3(0.);\n  \n  const vec3 light1_colour = vec3(.8, .8, .85);\n  const vec3 light1_position = vec3(.3, .3, 1.);\n  const float light1_attenuation = 0.01;\n  const float scene_attenuation = 0.01;\n  \n  struct Surface {\n    int object_id;\n    float distance;\n    vec3 position;\n    vec3 colour;\n    float ambient;\n    float spec;\n  };\n  \n  // This function describes the world in distances from any given 3 dimensional point in space\n  float world(in vec3 position, inout int object_id) {\n    float z = position.z * .1;\n    float c = cos(z);\n    float s = sin(z);\n    position.xy *= mat2(c, -s, s, c);\n    vec3 pos = floor(position * 2.);\n    object_id = int(floor(pos.x + pos.y + pos.z));\n    position = mod(position, .5) - .25;\n    return length(position) - .12;\n  }\n  float world(in vec3 position) {\n    int dummy = 0;\n    return world(position, dummy);\n  }\n  \n  vec3 getObjectColour(int object_id) {\n    float modid = mod(float(object_id), 5.);\n    if(modid == 0.) {\n      return vec3(.3, 0.2, 0.5) * 2.;\n    } else if(modid == 1.) {\n      return vec3(.5, 0.5, 0.3) * 2.;\n    } else if(modid == 2.) {\n      return vec3(.5, 0.4, 0.5) * 2.;\n    } else if(modid == 3.) {\n      return vec3(.2, 0.5, 0.4) * 2.;\n    } else if(modid == 4.) {\n      return vec3(.2, 0.5, 0.2) * 2.;\n    }\n  }\n  \n  Surface getSurface(int object_id, float rayDepth, vec3 sp) {\n    return Surface(\n      object_id, \n      rayDepth, \n      sp, \n      getObjectColour(object_id), \n      .5, \n      100.);\n  }\n  \n  // The raymarch loop\n  Surface rayMarch(vec3 ro, vec3 rd, float start, float end) {\n    float sceneDist = 1e4;\n    float rayDepth = start;\n    int object_id = 0;\n    for(int i = 0; i < maxIterations; i++) {\n      sceneDist = world(ro + rd * rayDepth, object_id);\n      \n      if(sceneDist < stopThreshold || rayDepth > end) {\n        break;\n      }\n      \n      rayDepth += sceneDist * stepScale;\n    }\n    \n    return getSurface(object_id, rayDepth, ro + rd * rayDepth);\n  }\n  \n  // Calculated the normal of any given point in space. Intended to be cast from the point of a surface\n  vec3 calculate_normal(in vec3 position) {\n    vec3 grad = vec3(\n      world(vec3(position.x + eps, position.y, position.z)) - world(vec3(position.x - eps, position.y, position.z)),\n      world(vec3(position.x, position.y + eps, position.z)) - world(vec3(position.x, position.y - eps, position.z)),\n      world(vec3(position.x, position.y, position.z + eps)) - world(vec3(position.x, position.y, position.z - eps))\n    );\n    \n    return normalize(grad);\n  }\n  \n  // Original by IQ\n  float calculateAO(vec3 p, vec3 n)\n  {\n     const float AO_SAMPLES = 8.0;\n     float r = 0.0;\n     float w = 1.0;\n     for (float i=1.0; i<=AO_SAMPLES; i++)\n     {\n        float d0 = i * 0.15;\n        r += w * (d0 - world(p + n * d0));\n        w *= 0.5;\n     }\n     return 1.0-clamp(r,0.0,1.0);\n  }\n  \n  vec3 lighting(Surface surface_object, vec3 cam) {\n    \n    // start with black\n    vec3 sceneColour = vec3(0);\n    \n    // Surface normal\n    vec3 normal = calculate_normal(surface_object.position);\n    \n    // Light position\n    vec3 lp = light1_position + movement;\n    // Light direction\n    vec3 ld = lp - surface_object.position;\n    \n    // light attenuation\n    // For brightly lit scenes or global illumination (like sunlit), this can be limited to just normalizing the ld\n    float len = length( ld );\n    ld = normalize(ld);\n    float lightAtten = min( 1.0 / ( light1_attenuation*len ), 1.0 );\n    // lightAtten = 1.;\n    \n    // Scene values, mainly for fog\n    float sceneLength = length(cam - surface_object.position);\n    float sceneAttenuation = min( 1. / ( scene_attenuation * sceneLength * sceneLength ), 1. );\n    \n    // The surface's light reflection normal\n    vec3 reflection_normal = reflect(-ld, normal);\n    \n    // Ambient Occlusion\n    float ao = calculateAO(surface_object.position, normal);\n   // ao *= ao * ao;\n    // ao = 1.;\n    \n    // Object surface properties\n    float diffuse = max(0., dot(normal, ld));\n    float specular = max(0., dot( reflection_normal, normalize(cam - surface_object.position) ));\n    specular = pow(specular, surface_object.spec); // Ramping up the specular value to the specular power for a bit of shininess.\n    \n    // Bringing all of the lighting components together\n    sceneColour += ( surface_object.colour * (diffuse + surface_object.ambient) + specular ) * light1_colour * lightAtten * ao;\n    // adding fog\n    sceneColour = mix( sceneColour, fogColour, 1. - sceneAttenuation );\n    \n    // return vec3(ao);\n    return sceneColour;\n  }\n  \n  vec3 path(float z) {\n    return vec3(0,0,-5000.+z);\n  }\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.y, iResolution.x);\n    \n    float t = iTime * .2;\n    \n    // movement\n    movement = path(iTime);\n    \n    // Camera and look-at\n    vec3 cam = vec3(0,0,-1);\n    vec3 lookAt = vec3(sin(t)*.25,0,0);\n    \n    // add movement\n    lookAt += movement;\n    cam += movement;\n    \n    // Unit vectors\n    vec3 forward = normalize(lookAt - cam);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x));\n    vec3 up = normalize(cross(forward, right));\n    \n    // FOV\n    float FOV = .4;\n    \n    // Ray origin and ray direction\n    vec3 ro = cam;\n    vec3 rd = normalize(forward + FOV * uv.x * right + FOV * uv.y * up);\n    \n    float s = sin(t);\n    float c = cos(t);\n    rd.xy *= mat2(c, -s, s, c);\n    \n    // Ray marching\n    Surface objectSurface = rayMarch(ro, rd, clipNear, clipFar);\n    if(objectSurface.distance > clipFar) {\n      fragColor = vec4(clipColour, 1.);\n      return;\n    }\n    \n    vec3 sceneColour = lighting(objectSurface, cam);\n\n    // Output to screen\n    fragColor = vec4(sceneColour, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}