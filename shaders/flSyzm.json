{
    "Shader": {
        "info": {
            "date": "1649341771",
            "description": "Trying to throw random math at the screen in hope i  might learn something :)\n",
            "flags": 0,
            "hasliked": 0,
            "id": "flSyzm",
            "likes": 6,
            "name": "Things and colors.",
            "published": 3,
            "tags": [
                "grid",
                "colors",
                "orbit",
                "psy",
                "atoms"
            ],
            "usePreview": 0,
            "username": "fyisic123",
            "viewed": 329
        },
        "renderpass": [
            {
                "code": "#define hue(v) ( .6 + .6 * cos( 2.*PI*(v) + vec3(0,-2.*PI/3.,2.*PI/3.) ) )\n#define PI 3.14159265359\n#define RIPPLE_COUNT 5.\n#define TILE_COUNT 5.\n\n    \n    mat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat line(vec2 P, vec2 A, vec2 B, float r)\n{\n\tvec2 g = B - A;\n    float d = abs(dot(normalize(vec2(g.y, -g.x)), P - A));\n\treturn smoothstep(r, 0.5*r, d);\n}\n\nfloat hash12(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat getWaves(vec2 uv, float size, float speed)\n{\n    float l = length(uv);\n    return abs(sin(l * 100. + speed)) * smoothstep(size, 0.,l) * (0.5 + (0.5 *  (smoothstep(0.2*size, 0.0*size, abs(length(uv) - (size   * abs(sin(iTime))))))));\n}\n\n\nvec2 getOrbitPos(float v, float dist)\n{\n    return vec2(cos(v), sin(v)) * dist;\n}\nfloat getRings(vec2 uv, float r)\n{\n    float Speed = iTime * .2;\n    float P = 0.;\n    for(float i=0.; i <= RIPPLE_COUNT; i++)\n    {\n        float per = i / RIPPLE_COUNT;\n        float stage = fract(per + Speed);\n        float radius = r * stage;\n        \n        P += smoothstep(0.015,0., abs(length(uv)-radius)) * pow((1. - stage),3.5) * .5;\n    }\n    return P;\n}\nfloat getBall(vec2 uv, float scale, float orbitSpeed)\n{\n    \n    float P = smoothstep(0.1*scale, 0.01 * scale, abs(length(uv)-scale));    \n    float orbitScale =  scale  * .5;    \n    for(float i=0.; i <= 1.; i++)    \n        P += smoothstep(orbitScale, -0.6 * scale, length(uv - getOrbitPos(orbitSpeed + radians(180. * i), scale))) * 2.;        \n    orbitScale *= .5;    \n       \n    return P;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float T = iTime;\n    vec2 uv = (fragCoord.xy -.5 * iResolution.xy) /iResolution.y;        \n    uv *= Rot(dot(uv.x, uv.y) + T );\n    uv += vec2(sin(T * 0.1), 0);\n    uv *= TILE_COUNT + (TILE_COUNT * 0.1 * sin(T * 0.5));        \n    \n    vec2 gv = fract(uv) - .5;    \n    vec2 ID = floor(uv);          \n    vec3 col = vec3(0);                \n    float BG1 = pow(mod(fract(abs(gv.x) + T), abs(gv.y)), 1.8);\n    float BG2 = pow(abs(dot(sin(uv.x * 1.), cos(gv.y * 6.) * length(uv) * .075) ), 1.7);\n    float BG = mix(BG1, BG2, abs(sin(T * .2)));\n    float BGHue = pow(BG, .5) + (T * .1);\n    vec3 bgCol = hue(BGHue) * BG;  \n    col = mix(vec3(BG), bgCol, 0.6);  //  Desaturate        \n    float lines = 0.;\n    float orbitSpeed = T * 5.;\n    float P = 0.;\n    vec3 ballCol = vec3(0);\n    float w = 0.;\n    float waveSpeed = T *  34.;\n    for (int x = -1; x <= 1; x++)\n    {\n        for (int y = -1; y <= 1; y++)\n        {\n            vec2 offs = vec2(x,y);\n            vec2 oID = ID + offs;\n            float nID = hash12(oID); \n            \n            vec2 pos = gv -offs;\n            float Size = (mod(oID.x + oID.y, 2.) == 0.) ? .2 : 0.075;\n            float orbSpeed = (mod(floor(nID * 10000.), 2.) == 0.) ? orbitSpeed : -orbitSpeed;\n    \n            float nP = getBall(pos, Size, orbSpeed);\n            \n            ballCol += hue(nID) * nP;\n            P += nP;            \n            w += getWaves(pos, Size, waveSpeed);                                   \n            ballCol += hue(nID + 0.1) * getRings(pos, Size * 4.5);\n            lines += line(gv + 1., pos + 1.5  , vec2(1.), 0.03);\n\n            \n            \n        }\n    }\n    \n    col = mix(col , hue(BGHue + .001), lines * .1);\n    col = mix(col, vec3(1.), min(1. , max(0. , P- 1.)) );\n    col += ballCol;\n    col += (hue(length(gv)) * w);\n    \n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}