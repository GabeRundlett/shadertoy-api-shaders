{
    "Shader": {
        "info": {
            "date": "1574511609",
            "description": "I was playing with rayleigh scattering and accidentally used the wrong equation for calculating the coefficents whcih created the heat like effect. I ultimately distilled it into the add_burn function.  ",
            "flags": 0,
            "hasliked": 0,
            "id": "wsVXRV",
            "likes": 16,
            "name": "Hot touch spheres",
            "published": 3,
            "tags": [
                "raytracing",
                "effect",
                "scattering",
                "heat"
            ],
            "usePreview": 0,
            "username": "janiorca",
            "viewed": 525
        },
        "renderpass": [
            {
                "code": "const int num_spheres = 30;\n\nconst vec3 sun_dir = normalize( vec3( 1.0, 1.10, 1.0 ));\nconst float maximum_dist = 99999.0;\n\nfloat w_intersect_sphere( float max_t, vec3 ray_dir, vec3 origin, \n    vec3 sphere, float sphere_radius2, int idx_in, \n    out vec3 pos, out vec3 norm, out int idx ) {\n   // intersect with sphere \n    vec3 origToSphere = sphere - origin;\n    float tCA = dot( origToSphere, ray_dir);\n    if( tCA < 0.0 ) {\n        // ray center is towards back of ray. cant intsesect\n        return max_t;\n    } else \n    {\n        float dd = length(origToSphere);\n        float distToMidpoint2 = dd*dd-tCA*tCA;\n        if( distToMidpoint2 > sphere_radius2 ) {\n            return max_t;\n        } \n        else {\n            float thc = sqrt(sphere_radius2-distToMidpoint2);\n            float t0 = tCA - thc;           // entry \n            if( t0 < max_t ) {\n                pos = origin + t0*ray_dir;\n                norm = normalize( pos-sphere);\n                idx = idx_in;\n                return t0;\n            } else {\n                return max_t;\n            }\n        }\n    }\n}\n\n// For shadows we only care if there was intersection\nbool intersects_sphere( vec3 ray_dir, vec3 origin, vec3 sphere, float sphere_radius2 ) {\n   // intersect with sphere \n    vec3 origToSphere = sphere - origin;\n    float tCA = dot( origToSphere, ray_dir);\n    if( tCA < 0.0 ) {\n        // ray center is towards back of ray. cant intsesect\n        return false;\n    } else \n    {\n        float dd = length(origToSphere);\n        float distToMidpoint2 = dd*dd-tCA*tCA;\n        if( distToMidpoint2 > sphere_radius2 ) {\n            return false;\n        } \n        else {\n            return true;\n        }\n    }\n}\n\nfloat ground_plane_intersect( vec3 ray_dir, vec3 origin, float ground, out vec3 pos, out vec3 norm ) {\n    if( ray_dir.y >= 0.0 ) {\n        return maximum_dist;\n    }\n    float t = ( ground-origin.y ) /  ray_dir.y; \n    norm = vec3( 0.0, 1.0f, 0.0f );\n    pos = origin + ray_dir*t;\n    return t;\n}\n\nfloat fresnel( float n, vec3 normal, vec3 incident )\n{\n    // Schlick aproximation\n    float r0 = (1.0-n) / (1.0+n);\n    r0 *= r0;\n    float cosX = -dot(normal, incident);\n    float x = 1.0-cosX;\n    float ret = r0+(1.0-r0)*x*x*x*x*x;\n    return ret;\n}\n\nconst vec3 absorption_coeff  = vec3( 0.000005, 0.000015, 0.00027 )*15.0;\nconst vec3 scattering_coeff = vec3( 0.00015, 0.00015, 0.00027 )*15.0;\n\nvec3 extinction( float dist ) {\n    return      exp( -dist*( absorption_coeff + scattering_coeff ) );\n}\n\nvec3 add_burn( float dist ) {\n    vec3 burn = 4.0*vec3( 27.0, 4.0, 1.0 ) / pow( dist, 4.0 );\n    return burn;\n }\n\nvec3 in_scatter( float dist, float cos_angle ) {\n    float rayleigh_scatter = .0003 / 16.0*3.14159* ( 1.0 + cos_angle*cos_angle ); \n\n    vec3 rayleigh_coeff =         vec3( 1.0 / ( absorption_coeff.x + scattering_coeff.x ) * ( 1.0-exp( -dist*( scattering_coeff.x ) ) ),\n                                        1.0 / ( absorption_coeff.y + scattering_coeff.y ) * ( 1.0-exp( -dist*( scattering_coeff.y ) ) ),\n                                        1.0 / ( absorption_coeff.z + scattering_coeff.z ) * ( 1.0-exp( -dist*( scattering_coeff.z ) ) ) );\n\n    float mie_g = 0.476;\n    vec3 mie_scatter =  vec3( 0.0020, 0.0008, 0.0002 ) * ( 1.0 - mie_g )*( 1.0 - mie_g ) / ( 4.0 * 3.14159 * pow( ( 1.0 + mie_g*mie_g  - 2.0 * mie_g *cos_angle ), 1.5 ) ); \n    float mie_coeff = 20.0 / (  absorption_coeff.x + scattering_coeff.x ) \n                            * ( 1.0-exp( -dist*( scattering_coeff.x ) ) );\n    return rayleigh_scatter*rayleigh_coeff+mie_scatter*mie_coeff;\n }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 center = vec2( 0.5, 0.35 );\n    vec3 spheres[num_spheres];\n\n    float t = iTime*2.0;\n    float adjustedTime = (30.0*t - 45.0*cos(t) + cos(3.0*t) - 9.0* sin(2.0*t))/96.0;\n    adjustedTime += iTime*0.1;\n\n    float e = adjustedTime*0.0452 + 0.448661519;\n    float f = adjustedTime*0.032 + 0.6722;\n    float g = adjustedTime*0.0452 + 0.25389;\n\tfor( int  idx=0; idx < num_spheres; idx++ ) \n    {\n       vec3 spos  = vec3(sin( adjustedTime*0.1823+float(idx)*e )*0.417,\n                            sin( adjustedTime*0.6725+float(idx)*f)*0.35,\n                        sin( adjustedTime*0.135125+float(idx)*g)*0.42 );\n//         float fidx = float(idx);\n//        float fidx2 = fidx*fidx;\n//        vec3 spos = vec3( sin( fidx*0.21312 + adjustedTime * 0.151312 + 0.423 + fidx2*0.324), \n //           sin( fidx*0.17312 + adjustedTime * .372 + 0.4223+ fidx2*1.24 ),\n //           sin( fidx*0.2312 + adjustedTime * .255552 + 1.423+ fidx2*1.1324 )\n//        );\n        spos *= 30.0;\n        spheres[ idx ] = spos;\n    }\n    vec2 uv = fragCoord/iResolution.x;\n    float camera_dist = -35.0 + cos( adjustedTime / 2.0 )*10.0;\n    vec2 screen_pos_2d = 2.0*(uv - center);\n    vec3 screen_pos_3d = vec3( screen_pos_2d, camera_dist+1.0 );\n\n    float _angle = adjustedTime/3.0 + iTime*0.2;\n    mat3 rot_m = mat3( cos(_angle),0,  -sin( _angle ), \n                        0,          1,          0,\n                        sin(_angle), 0, cos(_angle) );\n\n    vec3 origin = rot_m*vec3( 0,0,camera_dist) ;\n    vec3 ray_dir = normalize(rot_m*screen_pos_3d - origin);\n\n    float contribution = 1.0;\n    vec3 final_color = vec3( 0,0,0);\n\n    for( int bounce =2; bounce >0 ; bounce -- ) {\n        vec3 new_ray_dir;\n        vec3 norm;\n        vec3 pos;\n        vec3 diffuseCol;\n        float refractive_index;\n        float reflectance = 0.0;\n        int final_idx = -1;\n        float current_t = maximum_dist;\n        float burn_coeff = 0.0;\n\n        current_t = ground_plane_intersect( ray_dir, origin , -20.0, pos, norm );\n        if( current_t <= maximum_dist ) {\n            refractive_index = 1.77;\n            diffuseCol = vec3( 0.05, 0.05, 0.05 );\n            if( ( ( int( pos.x/5.0) +int(pos.z/5.0) ) & 1 )== 1){\n                float d = ( pos.x*pos.x + pos.z*pos.z );\n                diffuseCol = mix( diffuseCol, vec3( 0.59, 0.6, 0.5 ),\n                     smoothstep( 8000.0, 4000.0, d ) );\n            } \n        } else {\n            diffuseCol = vec3( 1.0, 1.0, 0.0);\n        }\n\n        for( int idx=1; idx < num_spheres; idx++ ) {\n            vec3 vv = vec3( 0.0, 0.0, 0.0 )*float(idx);\n           current_t  =  w_intersect_sphere( current_t, ray_dir, origin, spheres[idx], 4.2*4.2, idx, \n               pos, norm, final_idx);\n        }\n        // workout out material properties\n        if( final_idx > 0 ) {\n            diffuseCol = vec3( 0.02, .02, 0.02 );\n            refractive_index = 1.3171;\n            reflectance = fresnel( refractive_index, norm, ray_dir);\n            new_ray_dir = reflect( ray_dir, norm );\n        }\n\n        vec3 point_color = vec3( 0, 0, 0 );\n\n        if( current_t >= maximum_dist ) {\n            point_color += in_scatter( current_t, dot( sun_dir,ray_dir) );\n            final_color += point_color * contribution;\n            break;\n        }\n\n        // light the point\n        for( int lt=0; lt<1; lt++ ) \n        {\n            // Is the light shadowed\n            bool in_shade = false;\n            for( int idx=1; idx < num_spheres; idx++ ) \n            {\n                if( intersects_sphere( sun_dir, pos, spheres[idx], 4.2*4.2 ) ) \n                {\n                    in_shade = true;\n                    break;\n                }\n            }\n            if( !in_shade)\n            {\n                vec3 reflectedLight = reflect( -sun_dir, norm );\n                vec3 toCamera = -ray_dir;\n                float diffuse = dot( sun_dir, norm );\n\n                vec3 halfway = normalize( toCamera + sun_dir );\n                float specular = pow( dot( norm, halfway ), 121.0 );\n            \n                specular = clamp( specular, 0.0, 1.0 );\n\n                vec3 fragDiffuse = diffuseCol * diffuse;\n                point_color += vec3(specular,specular,specular) + fragDiffuse;\n            } else {\n                point_color += diffuseCol* 0.02;\n            }\n        }\n        // attenuate\n        point_color *= extinction( current_t );\n        if( final_idx !=0 ) {\n            point_color += add_burn( current_t);\n\n        }\n        point_color += in_scatter( current_t, dot( sun_dir,ray_dir) );\n\n        final_color += point_color * contribution * ( 1.0 - reflectance );\n        contribution = contribution * reflectance;\n        ray_dir = new_ray_dir;\n        origin = pos;\n\n        if( final_idx == -1 ){\n            break;\n        }\n    }\n    vec3 fragFinal = pow( final_color, vec3(1.0 / 2.2) );\n    fragColor = vec4(fragFinal, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}