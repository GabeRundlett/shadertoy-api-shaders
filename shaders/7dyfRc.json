{
    "Shader": {
        "info": {
            "date": "1661264940",
            "description": "Attaching a double layered three pronged star weave to the triangle cells of a subdivided icosahedron.",
            "flags": 32,
            "hasliked": 0,
            "id": "7dyfRc",
            "likes": 79,
            "name": "Icosahedral Spiral Weave ",
            "published": 3,
            "tags": [
                "raymarching",
                "math",
                "star",
                "icosahedron",
                "spherical",
                "polyhedron",
                "weave"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 1008
        },
        "renderpass": [
            {
                "code": "/*\n\n    Icosahedral Spiral Weave\n    ------------------------    \n    \n    See Buffer A for an explanation.\n    \n\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Rendering the buffer.\n    \n    \n    // Retrieving the stored color.\n    vec4 col = texture(iChannel0, fragCoord/iResolution.xy);\n\n    // Rough gamma correction and screen presentation.\n    // \"col\" should already be above zero, but we're capping it anyway.\n    fragColor = sqrt(max(col, 0.));\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\n    Animated Icosahedral Weave\n    --------------------------\n    \n    This is a common polyhedral weave that you may have seen around. I'm not \n    sure what it's officially called, but it's some kind of double layered\n    three pronged star weave. They're normally precalculated using multiple \n    steps involving Beziers, etc, inside 3D applications like Blender, then \n    loaded into realtime applications after construction, but I thought it'd\n    be fun attempting to produce one in realtime on Shadertoy.\n    \n    I'm stating the obvious here, but pixel shader restrictions coupled with\n    realtime constraints meant that it was a bit difficult to produce the\n    equivalent of an elegantly lit static path traced image, or prerecorded\n    video. However, I employed a few cheap realtime tricks to at least convey \n    that feel.\n    \n    It would have been nice to make it better, faster, stronger, and all that, \n    but I ran out of time. There are definitely faster ways to render this \n    scene, but I figured I'd post it in its current form then try for something \n    nicer later. If I produced this with Bezier curves, it'd be a more \n    geometrically interesting looking object, but would also be way more \n    expensive.\n    \n    I put more effort into the background and color scheme than the icosahedral \n    sphere construction itself, which involved obtaining the nearest \n    icosahedral triangle face information, then using that to render two set of \n    three pronged arcs emminating from the center to offset midpoints.    \n    \n    For those of you experiencing ridiculous compile times, you have my apologies,\n    but it really is beyond my control. All I can say is, I miss the days when\n    everyone looked forward to compiler updates. :)\n\n\t\n    Other examples:\n    \n  \n    // In terms of aesthetics and sheer technical ability, this would\n    // have to be one of my favorites.\n    heavy metal squiggle orb - mattz\n    https://www.shadertoy.com/view/wsGfD3\n    \n    // The flat plane version.\n    Triangle Grid Spiral Weave - Shane\n    https://www.shadertoy.com/view/7syfWz\n\n\n*/\n \n\n// Max ray distance.\n#define FAR 20.\n\n\n// Scene object ID to separate the mesh object from the terrain.\nint objID;\nvec4 vID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n// IQ's vec3 to float hash.\nfloat hash31(in vec3 p){\n    return fract(sin(dot(p, vec3(91.537, 151.761, 72.453)))*435758.5453);\n}\n\n// 3D rotation via two axis rotations. I should probably drop in a\n// more concise 3D rotation formula from one of my other examples.\nvec3 rotObj(in vec3 p){\n   \n    p.xz *= rot2(iTime/3./2.);\n    p.yz *= rot2(iTime/6./3.); \n    \n    return p;\n    \n}\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){ \n    \n    n = max(abs(n) - .2, .001); // max(abs(n), 0.001), etc.\n    //n /= dot(n, vec3(.8)); \n    n /= length(n);\n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nvec2 smin(vec2 a, vec2 b, float k){\n\n   vec2 f = max(vec2(0), 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nvec2 smax(vec2 a, vec2 b, float k){\n    \n   vec2 f = max(vec2(0), 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n \n// IQ's box routine.\nfloat sBox(in vec2 p, in vec2 b, float r){\n\n  vec2 d = abs(p) - b + r;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - r;\n}\n\n\n/*\n// hash based 3d value noise\nvec4 hash41T(vec4 p){\n    \n    return fract(sin(p)*43758.5453);\n}\n\n// Compact, self-contained version of IQ's 3D value noise function.\nfloat n3DT(vec3 p){\n    \n\tconst vec3 s = vec3(27, 111, 57);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \n    //p *= p*p*(p*(p*6. - 15.) + 10.);\n    h = mix(hash41T(h), hash41T(h + s.x), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// Two layers of noise.\nfloat fBm(vec3 p){ return n3DT(p)*.57 + n3DT(p*2.)*.28 + n3DT(p*4.)*.15; }\n*/ \n\n/////////\n// A concatinated spherical coordinate to world coordinate conversion.\nvec3 sphericalToWorld(vec3 sphCoord){\n   \n    vec4 cs = vec4(cos(sphCoord.xy), sin(sphCoord.xy));\n    return vec3(cs.w*cs.x, cs.y, cs.w*cs.z)*sphCoord.z;\n}\n  \n\n// Useful polyhedron constants. \n#define PI 3.14159265359\n#define TAU 6.2831853\n#define PHI 1.618033988749895 \n\n//\n// Since all triangles are the same size, etc, any triangles on\n// a known icosahedron will do. The angles we need to determine are\n// the angle from the top point to one of the ones below, the top\n// point to the mid point below, and the angle from the top point\n// to the center (centroid) of the triangle.\nconst vec3 triV0 = normalize(vec3(-1, PHI,  0));\nconst vec3 triV1 = normalize(vec3(-PHI, 0,  1));//0,  1,  PHI\nconst vec3 triV2 = normalize(vec3(0,  1,  PHI));//0,  1,  PHI\nconst vec3 mid = normalize(mix(triV1, triV2, .5));\nconst vec3 cntr = normalize(triV0 + triV1 + triV2);\n\n// Angle between vectors: cos(a) = u.v/|u||v|. \n// U and V are normalized. Therefore, a = acos(u.v).\nconst float ang = acos(dot(triV0, triV1)); // Side length angle.\nconst float mAng = acos(dot(triV0, mid)); // Height angle.\nconst float cAng = acos(dot(triV0, cntr)); // Centroid angle.\n\n// The latitude (in radians) of each of the top and bottom blocks is\n// the angle between the top point (north pole) and one of the points below, \n// or the bottom point (south pole) and one of the ones above.\nconst float latBlock = ang;\nconst vec2 lat = vec2(cAng, mAng*2. - cAng);\n\n//\n\n// Returns the local world coordinates to the nearest triangle and the three\n// triangle vertices in spherical coordinates.\nvec3 getIcosTri(inout vec3 p, inout vec3[3] gVertID, const float rad){\n       \n \n    // Longitudinal scale.\n    const float scX = 5.;\n\n\n    // The sphere is broken up into two sections. The top section \n    // consists of the top row, and half the triangle in the middle\n    // row that sit directly below. The bottom section is the same,\n    // but on the bottome and rotated at PI/5 relative to the top. \n    // The half triangle rows perfectly mesh together to form the \n    // middle row or section.\n\n    // Top and bottom section coordinate systems.The bottom section is \n    // rotated by PI/5 about the equator.\n    vec3 q = p; // Top section coordinates.\n    //vec3 q2 = vec3(rot2(-PI/scX)*p.xz, p.y).xzy; // Bottom section coordinates.\n\n    // Converting to spherical coordinates.\n    // X: Longitudinal angle -- around XZ, in this case.\n    // Y: Latitudinal angle -- rotating around XY.\n    // Z: The radius, if you need it.\n\n    // Longitudinal angle for the top and bottom sections.\n    ////vec4 sph = mod(a + vec4(0, 0, PI/5., PI/5.), TAU);\n    vec4 sph = mod(atan(q.z, q.x) + vec4(0, 0, PI/5., PI/5.), TAU);\n    sph = mod((floor(sph*scX/TAU) + vec4(.5, .5, 0, 0))/scX*TAU, TAU);\n\n\n    float dist = 1e5;\n\n\n    // Top and bottom block latitudes for each of the four groups of triangle to test.\n    vec4 ayT4 = vec4(0, PI - latBlock, PI, latBlock);\n    vec4 ayB4 = vec4(latBlock, latBlock, PI - latBlock, PI - latBlock);\n    float ayT, ayB;\n\n    int id;\n\n    // Iterating through the four triangle group strips and determining the \n    // closest one via the closest central triangle point.\n    for(int i = 0; i<4; i++){\n\n\n        // Central vertex postion for this triangle.        \n        int j = i/2;\n        // The spherical coordinates of the central vertex point for this \n        // triangle. The middle mess is the lattitudes for each strip. In order,\n        // they are: lat[0], lat[1], PI - lat[0], PI - lat[1]. The longitudinal\n        // are just the polar coordinates. The bottom differ by PI/5. The final\n        // spherical coordinate ranges from the sphere core to the surface.\n        // On the surface, all distances are set to the radius.                \n        vec3 sc = vec3(sph[i], float(j)*PI - float(j*2 - 1)*lat[i%2], rad);\n \n        // Spherical to world, or cartesian, coordinates.\n        vec3 wc = sphericalToWorld(sc);\n\n\n        float vDist = length(q - wc);\n        if(vDist<dist){\n           dist = vDist;\n           ayT = ayT4[i]; // Top triangle vertex latitude.\n           ayB = ayB4[i]; // Bottom triangle vertex latitude.\n           id = i;\n        }\n\n\n    }\n\n\n    float ax = sph[id];\n    // Flip base vertex postions on two blocks for clockwise order.\n    float baseFlip = (id==0 || id==3)? 1. : -1.;\n\n    // The three vertices in spherical coordinates. I can't remember why\n    // I didn't convert these to world coordinates prior to returning, but\n    // I think it had to do with obtaining accurate IDs... or something. :)\n    gVertID[0] = vec3(ax, ayT, rad);\n    gVertID[1] = vec3(mod(ax - PI/5.*baseFlip, TAU), ayB, rad);\n    gVertID[2] = vec3(mod(ax + PI/5.*baseFlip, TAU), ayB, rad);\n\n    // Top and bottom poles have a longitudinal coordinate of zero.\n    if (id%2==0) gVertID[0].x = 0.;\n \n     \n    return q;\n}\n\n\n\n\n/////////\n// Nimitz's simple basis function. I'll take people's word for it that it\n// fails at the negative one Z point, so I've attempted to put in a hacky fix.\nmat3 basis(in vec3 n){\n    \n    float a = min(1./(1. + n.z), 1e6);\n    float b = -n.x*n.y*a;\n    return mat3(1. - n.x*n.x*a, b, n.x, b, 1. - n.y*n.y*a, n.y, -n.x, -n.y, n.z);\n}\n\n// Readjusting the points to the surface of the sphere in question. The function here\n// is the same as the one below, but that's not always the case.\nvec3 size(in vec3 p, in float rad){\n\n    //return p;\n    return normalize(p)*rad;\n}\n\nvec3 sSize(in vec3 p, in float rad){\n    \n    return normalize(p)*rad;\n}\n\n// Sphere position: A little redundant, in this case.\nvec3 sphPos = vec3(0);\n\n\n// Scene distance function.\nfloat map(vec3 p){\n    \n    \n    \n    // Rotate the sphere.\n    vec3 q = rotObj(p - sphPos);\n\n            \n    // Icosahedron vertices and vertex IDs for the current cell.\n    vec3[3] v, vertID;\n\n    // Obtaining the local cell coordinates and spherical coordinates\n    // for the icosahedron cell.\n    const float rad = .5;\n    vec3 lq = getIcosTri(q, vertID, rad);\n\n    vec3 vAng = vertID[0];//(vertID[0] + vertID[1] + vertID[2])/3.;\n\n    v[0] = sphericalToWorld(vertID[0]);//vec3(0, rad, 0);\n    v[1] = sphericalToWorld(vertID[1]);\n    v[2] = sphericalToWorld(vertID[2]);\n\n\n     // The cell center, which doubles as a cell ID,\n    // due to its uniqueness, which can be used for \n    // randomness, etc.\n    //vec3 id = (v[0] + v[1] + v[2])/3.;\n    vec3 tCntr = sSize(v[0] + v[1] + v[2], rad);\n\n\n     // Icosahedral cell boundary.\n    mat3 mEdge = mat3(cross(v[0], v[1]), cross(v[1], v[2]), cross(v[2], v[0]));\n    vec3 ep = abs(normalize(lq)*mEdge)/length(v[0] - v[1]);  \n    // Icosahedral triangle cell boundary. If you wanted the triangle, take the\n    // \"abs\" above away.\n    float line = min(min(ep.x, ep.y), ep.z);   \n\n\n    float mOffs = .5/((sin(iTime/2.)*.5 + .5)*16.75 + 1.25); // Edge mid point offset. Smaller means wider.\n    //float mOffs = .5/1.5;\n\n    // Edge mid points, edge tangents and exit and entry points.\n    vec3[3] mid, midA, midB;\n\n    // Resizing the mid points.\n    mid[0] = sSize(mix(v[0], v[1], .5), rad);\n    mid[1] = sSize(mix(v[1], v[2], .5), rad);\n    mid[2] = sSize(mix(v[2], v[0], .5), rad);\n\n\n\n    // Dividing the cell triangles into three regions.\n    vec3 quadSect;\n\n    for(int i = 0; i<3; i++){\n\n        int ip2 = (i + 2)%3;\n        // Sectioning off the triangle into three seperate quads.\n        float edg = dot((lq/rad), cross(tCntr, mid[i])/length(tCntr - mid[i]));\n        float edg2 = dot((lq/rad), cross(mid[ip2], tCntr)/length(mid[ip2] - tCntr));\n        quadSect[i] = min(edg, edg2); // Boundary for this region.\n\n    }\n\n    ////////////\n    ////////////\n    // Orthonormal basis calcultion.\n\n    mat3 mB = basis(normalize(tCntr));\n    vec3 qq = lq -  tCntr;\n    vec3 blq = mB*qq;\n\n    // Sizing the vertex points.\n    v[0] = size(mB*v[0], rad);\n    v[1] = size(mB*v[1], rad);\n    v[2] = size(mB*v[2], rad);\n\n\n    // The triangle cell center with sizing.\n    tCntr = sSize(v[0] + v[1] + v[2], rad);\n\n    \n    // Midpoints, and midpoint offsets.\n    for(int i = 0; i<3; i++){\n\n        int ip1 = (i + 1)%3;\n        int ip2 = (i + 2)%3;\n\n        // Edge midpoints.\n        mid[i] = size(mix(v[i], v[ip1], .5), rad);\n\n        // Edge entry points -- One on each side of the mid point.                \n        midA[i] = size(mix(v[i], v[ip1], .5 - mOffs), rad);\n        midB[i] = size(mix(v[i], v[ip1], .5 + mOffs), rad);\n\n    } \n\n\n    // Rendering the curves between entry and exit points. There are six\n    // alltogether.\n    float object = 1e5, bord = 1e5;\n\n    // Normalizing Z values. It's a bit hacky and needs improvement, but it'll do. \n    float minDist = length(tCntr.xy - mid[0].xy); // Center to shortest side.\n    float lnN = line/minDist;\n    float lnN2 = max(1. - length(blq.xy - tCntr.xy)/minDist*.8660254, 0.);\n    float lnNew = mix(lnN, lnN2, smoothstep(.1, .9, lnN));\n \n    float rA = length(midA[0].xy - tCntr.xy);\n    float rB = rA; //length(midB[0].xy - tCntr.xy); // Same distance.\n\n    float zOffs = .2; \n    \n    // Three pronged spirals. Unfortunately, animating the curves meant that I've had to \n    // render all three on the top and bottom, which is obviously slower. There are certain \n    // configurations that allow for repeat space tricks which are much faster, and I'll\n    // demonstrate that at some stage.\n    for(int i = 0; i<3; i++){\n\n            // The next index.\n            int ip1 = (i + 1)%3;\n           \n\n            // Top spiral prongs and borders.\n            float obj = length(blq.xy - midB[i].xy) - rA; // rA\n            vec2 oVec = vec2(obj, length(lq) - rad + lnNew*zOffs*rad);\n\n            // There are some subtleties that I sometimes forget about. When partitioning\n            // off an ofject, it should effectively be zero along the dimensions in which\n            // you're doing it. Otherwise, there will be inconsistancies across boundaries.\n            obj = sBox(oVec, vec2(.03*(1. + lnN*lnN), .025), .01) + .025;\n\n            float tObj = sBox(oVec, vec2(.03*(1. + lnN*lnN) + .02, .025 - .015), .005) + .025;\n            tObj = max(tObj, -quadSect[i]);\n            obj = max(obj, -quadSect[i]);\n\n            //if(obj<ln[0]) minI = i;\n            object = min(object, obj);\n            bord = min(bord, tObj);\n\n\n            // Top spiral and border.\n            obj = length(blq.xy - midA[i].xy) - rB; //rB\n            oVec = vec2(obj, length(lq) - rad - lnNew*zOffs*rad);\n            obj = sBox(oVec, vec2(.03*(1. + lnN*lnN), .025), .01) + .025;\n\n            tObj = sBox(oVec, vec2(.03*(1. + lnN*lnN) + .02, .025 - .015), .005) + .025;\n            tObj = max(tObj, -quadSect[ip1]);\n\n\n            //obj = max(obj, -(svObj - .02));\n            obj = max(obj, -quadSect[ip1]);\n            object = min(object, obj);\n            bord = min(bord, tObj);\n\n\n\n\n    }\n        \n    // Giving the spiral prongs and borders some thickness.\n    object -= .025;\n    bord -= .025;\n\n\n    // The top and bottom vertices.\n    /*\n    vec2 ve2;\n    vec2 oVec = vec2(length(blq.xy), blq.z - (zOffs*rad - .0075));\n    ve2.x = sBox(oVec, vec2(.025, .045), .015);\n    oVec.y = blq.z + (zOffs*rad - .0075);\n    ve2.y = sBox(oVec, vec2(.025, .045), .015);\n    // Vertices and border. They're using the same material, so it\n    // makes sense to group them together.\n    float vert = min(min(ve2.x, ve2.y), bord);\n    */\n    \n    // The top and bottom vertices -- Equivalent to above.\n    vec2 oVec = vec2(length(blq.xy), abs(blq.z) - (zOffs*rad - .0075));\n    float vert = sBox(oVec, vec2(.025, .045), .015);\n    //\n    // Vertices and border. They're using the same material, so it\n    // makes sense to group them together.\n    vert = min(vert, bord);\n    \n\n    //////////////////\n    // The background wall and wavy background.\n    //\n    // Using a large sphere to create a slightly curved back wall.\n    //float wall = -(length(p - sphPos - vec3(0, 0, -(48. - 3.))) - 48.);\n    // Flat plane back wall.\n    float wall = -p.z + 3.;\n    \n    // Perturbation.\n    p.xy += sin(p.xy*4.)*.1;\n    float px = p.x;\n    p.xy = rot2(-3.14159/4.)*p.xy;\n\n    // Subtle wall ridges to reflect the light in a more interesting way.\n    const float s = 1./2.;\n    float f = abs(fract(p.x/s) - .5)*2.;\n    wall -= f*.05 - .05;\n\n\n    // The repeate extruded wavy lines.\n    vec2 q2 = p.xy;\n    float ix = floor(q2.x/s) + .5;\n    q2.x -= ix*s;\n    q2 = vec2(q2.x, p.z - 3.);\n    //float tube = length(q2) - .05 - cos(px*4.)*.02; // Round tubes.\n    float tube = sBox(q2, vec2(.05 + cos(px*4.)*.0125, .1), .025); // Rounded square tubes.\n\n\n    ////////////////////////////////    \n\n    // Overall object ID -- There in one rundundant slot there.\n    vID = vec4(tube, wall, vert, object);\n\n    // Shortest distance.\n    return  min(min(tube, wall), min(vert, object));\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = min(iFrame, 0); i<80; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n\n        t += d*.7; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\t\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test \n    // machine anyway.\n    const int maxIterationsShad = 24; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 2., occ = 0.;\n    for( int i = min(0, iFrame); i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        if(occ>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Frame blend value for the sphere.\n    float fBlend = 0.;\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 lk = vec3(0, 0, 0); // Camera position, doubling as the ray origin.\n\tvec3 ro = lk + vec3(cos(iTime/3.)*.1 + .0, .25, -2);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(.25, .75, -1);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = .75; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x)); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    //vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n \t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    \n    // Object identification: For two objects only, this is overkill,\n    // but handy when using more.\n    objID = 0;\n    float obD = vID[0];\n    for(int i = 0; i<4; i++){ \n        if(vID[i]<obD){ obD = vID[i]; objID = i; }\n    }\n    \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n        \n            \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 8.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n       \n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n\t    \n\t     \n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat freS = mix(.2, 1., Schlick);  //F0 = .2 - Glass... or close enough.        \n        \n          \n        // Texel color. \n\t    vec3 texCol = vec3(0); \n        \n        \n        // Frame blending hack to mitigate alliasing on the sphere edges.\n        fBlend = 1. - smoothstep(-.2, .2, abs(dot(rd, sn)) - .2);\n        \n        // Specular reflection.\n        vec3 hv = normalize(-rd + ld); // Half vector.\n        vec3 ref = reflect(rd, sn); // Surface reflection.\n        vec3 refTx = texture(iChannel1, ref).xyz; refTx *= refTx; // Cube map.\n        float spRef = pow(max(dot(hv, sn), 0.), 16.); // Specular reflection.\n        vec3 rCol = spRef*refTx*1.; //smoothstep(.03, 1., spRef)  \n        \n        // Texturing position and normal.\n        vec3 txP = sp, txN = sn;\n\n\n        // Object patterns, coloring, etc.        \n        if(objID==0){ \n        \n            // The wavy background lines.\n            txP/= 2.;\n            txP.xy *= rot2(-3.14159/4.);\n             \n            texCol = vec3(.7, .3, .1);\n            texCol += rCol;\n            \n            // Metallic trick.\n            diff = pow(diff, 4.)*2.;\n           \n        }\n        else if(objID==1){ \n        \n           \n            //  The background itself.\n            txP /= 1.;\n            txP.xy = mix(txP.xy*1.5, txP.xy + sin(txP.xy*4. - vec2(0, iTime*0.))*.1, .35);\n            txP.xy *= rot2(-3.14159/4.);\n         \n             // Color and reflection.\n            texCol = vec3(.65);    \n            texCol += rCol*.25; \n\n        }\n        else if(objID==2){ \n        \n            // The icosahedral border trim and vertices.\n        \n            // Texture position and normal.\n            txP -= sphPos;\n\n            // Rotation to match the scene movement.\n            txP = rotObj(txP);\n            txN = rotObj(txN);\n\n\n\n            // Color and reflection.\n            texCol = vec3(.7, .3, .1); \n            texCol += rCol;\n\n            // Cheap metallic trick.\n            diff = pow(diff, 4.)*2.;\n\n        }\n        else { \n        \n            // Icosahedral color.\n        \n            // Texture position and normal.\n            txP = sp - sphPos;\n             \n            // Rotation to match the scene movement.\n            txP = rotObj(txP);\n            txN = rotObj(txN);\n             \n            \n             // Color and reflection.\n            \n            texCol = vec3(.85, .75, .57); // Pearl.\n            //texCol = vec3(.4, .15, .8); diff = pow(diff, 4.)*2.; // Purple.\n            //texCol = vec3(.5); diff = pow(diff, 4.)*2.; // Silver.\n            //texCol = vec3(.07); diff = pow(diff, 4.)*2.; // Graphite.\n            texCol += rCol;\n            \n            \n        }\n        \n\n        vec3 tx; \n        if(objID==1){ \n            // Background wood grain.\n            tx = tex3D(iChannel3, txP + .5, txN);\n            texCol *= tx*2. + .06;\n           \n        }\n        else { \n            // Metal and powder coat enamel.\n            tx = tex3D(iChannel2, txP + .5, txN);\n            texCol *= tx*2. + .3;\n        }\n        \n        // Debug frame blending region.\n        //texCol = mix(texCol, vec3(4, .2, .1), fBlend);\n    \t\n        //texCol = mix(texCol, vec3(dot(texCol, vec3(.299, .587, .114))), .1);\n        // Combining the above terms to procude the final color.\n        col = texCol*(diff*sh + .3 + vec3(1, .7, .4)*spec*freS*sh*2.);\n \n\n\n        // Shading.\n        col *= ao*atten;\n        \n       \n\t\n\t}\n    \n    // Background fog: Normally you wouldn't have it, but I accidently left it in\n    // and I don't want to reshade everything. :)\n    col = mix(col, vec3(0), smoothstep(0., .99, t/FAR));\n    \n    // Mix the previous frames in with no camera reprojection. It's OK, but full \n    // temporal blur will be experienced. By the way, the fringes of the sphere are\n    // blended more in a hacky attempt to reduce edge aliasing... It needs work. :)\n    vec4 preCol = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float blend = (iFrame < 2) ? 1. : 1./(1. + fBlend*8.); \n    fragColor = mix(preCol, vec4(clamp(col, 0., 1.), 1), blend);\n    \n    // No temporal blur, for comparison.\n    //fragColor = vec4(max(col, 0.), 1);\n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}