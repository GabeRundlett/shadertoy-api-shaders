{
    "Shader": {
        "info": {
            "date": "1486115382",
            "description": "Learning to do ray/triangle intersections faster, so made a spinning top and added some nice motion blur :)",
            "flags": 32,
            "hasliked": 0,
            "id": "llGSDD",
            "likes": 18,
            "name": "Mirrored spinning top",
            "published": 3,
            "tags": [
                "raytracing",
                "motionblur",
                "antialiasing",
                "caustics",
                "pathtracing"
            ],
            "usePreview": 1,
            "username": "psonice",
            "viewed": 1700
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//#define FIXEDFRAMETIME\n#define FRAMETIME 1./30.\n#define MAXRAYS 50\n#define MAXBOUNCES 5\n#define PI 3.142\n#define SQRT2 1.4143\n#define INF 100000.0\n#define BRIGHTNESS 0.5\n\n#define kZENITHCOLOUR vec4(0.3, 0.7, 1.0, 5.0)\n#define kNADIRCOLOUR vec4(0.7, 0.6, 0.4, 0.0)\n#define kHORIZONCOLOUR vec4(0.7,0.8,0.95,3.0)\n#define kSUNSIZE 0.3\n#define kSUNCOLOUR vec4(1.0, 0.9, 0.7, 10.0)\n\n#define R(p,a) p=cos(a)*p+sin(a)*vec2(-p.y,p.x);\n    \nstruct Ray {\n\tvec3 origin;\n\tvec3 dir;\n};\n\n// A camera. Has a position and a direction. \nstruct Camera {\n    vec3 pos;\n    Ray ray;\n};\n\nstruct Sphere {\n\tvec3 pos;\n\tfloat radius;\n};\n    \nstruct Box {\n\tvec3 mi;\n\tvec3 ma;\n};\n\nstruct Bounds {\n\tvec3 minimum;\n\tvec3 maximum;\n};\n\nstruct Plane {\n\tvec3 n; // normal\n\tfloat d; // distance from origin\n};\n        \nstruct Triangle {\n    vec3 v0, edgeA, edgeB, n;\n};\n\nstruct HitTest {\n\tfloat dist;\n    vec3 normal;\n\tvec3 val;\n};\n\nstruct SceneResult {\n\tfloat dist;\n    vec3 normal;\n    vec4 col;\n    float ref;\n    float gloss;\n};\n    \nfloat divergence;\n    \n#define NOHIT HitTest(INF, vec3(0), vec3(0.0))\n\nbool intersectBox(in Ray r, in Box b, inout HitTest test) {\n    vec3 size = b.ma - b.mi;\n    \n    vec3 dA = (r.origin - b.mi) / -r.dir;\n    vec3 dB = (r.origin - b.ma) / -r.dir;\n    \n    vec3 minD = min(dA, dB); // -\n    vec3 maxD = max(dA, dB); // +\n    \n    float tmin = minD.x;\n    float tmax = maxD.x;\n    \n    if (tmin > maxD.y || tmax < minD.y) return false;\n    \n    tmin = max(tmin, minD.y); //-\n    tmax = min(tmax, maxD.y); //+\n               \n    if (tmin > maxD.z || tmax < minD.z) return false;\n    \n    tmin = max(tmin, minD.z); //-\n    float insideScaling = sign(tmin);\n    \n    tmin = tmin <= 0.0 ? INF : tmin; //+\n    \n    tmax = min(tmax, maxD.z); //+\n    tmax = tmax < 0.0 ? INF : tmax; //+\n    float testVal = tmax;\n    float d = min(tmin, tmax);// tmax\n    \n    float f = step(0.0, -d);\n    d = d * (1.-f) + (f * INF);\n    if (d > test.dist) return false;\n    \n    dA -= d;\n    dB -= d;\n    \n    dA = step(vec3(0.001), abs(dA));\n    dB = step(vec3(0.001), abs(dB));\n    \n    vec3 n = dA + -dB;\n    \n    test.dist = d;\n    test.normal = n * insideScaling;\n    \n    return true;\n}\n\nbool intersectSphere(in Ray r, in Sphere s, inout HitTest test) {\n\tvec3 o = r.origin - s.pos;\n\tfloat v = dot(o, r.dir);\n\tif(v > 0.) return false;\n    \n\tfloat disc = (s.radius * s.radius) - (dot(o, o) - (v * v));\n\t\n\tif(disc < 0.) return false;\n\t\n    float q = sqrt(disc);\n\tfloat dist = length(o);\n    float d = dist-q;\n    \n    //float f = step(0.0, -d);\n    //d = d * (1.-f) + (f * INF);\n    if (d > test.dist) { return false; }\n    \n    test.dist = d;\n    test.normal = ((r.origin + (r.dir * d)) - s.pos) / s.radius;\n    return true;\n}\n\nbool intersectPlane(in Ray r, in Plane p, inout HitTest test) {\n    // Intersect plane\n    float a = dot(r.dir, p.n);\n    \n    float d = -(dot(r.origin, p.n) + p.d) / a;\n    \n    float f = step(0.0, -d);\n    d = d * (1.-f) + (f * INF);\n    \n    if (d < test.dist) {\n        test.dist = d;\n        test.normal = p.n * -sign(a);\n \t\treturn true;\n    }\n \treturn false;   \n}\n\nbool intersectTriangle(in Ray r, in Triangle t, inout HitTest test) {\n    \n    vec3 pvec = cross(r.dir, t.edgeB);\n    float det = dot(t.edgeA, pvec);\n    if ((det) < 0.001) return false;\n    \n    float iDet = 1./det;\n    \n    vec3 tvec = r.origin - t.v0;\n    float u = dot(tvec, pvec) * iDet;\n    float inside = step(0.0, u) * (1.-step(1.0, u));\n    \n    vec3 qvec = cross(tvec, t.edgeA);\n    float v = dot(r.dir, qvec) * iDet;\n    inside *= step(0.0, v) * (1. - step(1., u+v));\n    if (inside == 0.0) return false;\n    \n    float d = dot(t.edgeB, qvec) * iDet;\n    \n    float f = step(0.0, -d);\n    d = d * (1.-f) + (f * INF);    \n    if (d > test.dist) { return false; }\n    \n    test.dist = d;\n    test.normal = t.n * sign(det);//((s.n0 * u) + (s.n1 * v) + (s.n2 * (1. - (u + v)))) * -sign(a);\n    //test.val = vec3(u, v, 1. - (u+v));\n    \n    return true;\n}\n\nfloat nrand(in vec2 n) {\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nvec3 trand(in vec2 n) {\n    return texture(iChannel0, n).rgb;\n}\n\nvec4 skyCol(in Ray r) {\n // Declare a horizon and extremity (either zenith or nadir)\n   // return texture(iChannel1, r.dir);\n    return mix(vec4(0.7,0.8,1,0.3), vec4(1,0.9,0.8,1), r.dir.y);\n    vec4 base, extremity, texture;\n    float x = smoothstep(0.0,1.0,abs(r.dir.y));\n    \n    if (r.dir.y >= 0.0) {\n        // sky: fake as hell clouds\n    \tbase = mix(kHORIZONCOLOUR, kZENITHCOLOUR, x);\n        texture = vec4(1);\n        float cloudFactor = 0.0;\n        \n        vec2 coord = r.dir.xz / 8.0;\n        float scale = 1.0;\n        cloudFactor /= 1.5;\n        vec4 cloud = mix(vec4(0.4), vec4(1), cloudFactor);\n        base = mix(base, cloud, cloudFactor * r.dir.y * r.dir.y);\n        \n\t\t float sun = distance(r.dir, normalize(vec3(0.6,1., 0.3)));\n\t\t sun = 1. - smoothstep(kSUNSIZE, kSUNSIZE * 1.1, sun);\n        base.a *= 0.3;\n\t\t base = mix(base, kSUNCOLOUR , sun); //\n        \n    }\n    base.rgb *= base.a;\n    return base;\n}\n\nSceneResult intersectScene(in Ray r, in float t) {\n\tSceneResult s;\n\ts.ref = 0.0;\n\ts.gloss = 0.0;\n    \n    HitTest test = NOHIT;\n\t\n    if (intersectBox(r, Box(vec3(-20,0,-20), vec3(20,20,20)), test)) {\n\t\t// Room\n\t\tvec3 op = r.origin+r.dir*test.dist;\n\t\t\n\t\tfloat y = step(19.9, op.y);\n        vec2 chk = floor(op.xz*0.2);\n        chk = mod(chk, 2.0);\n        float st = step(0.1, op.y);\n        float c = st + mod(chk.x+chk.y, 2.) * (1. - st);\n        \n\t\ts.col.rgb = mix(vec3(0.8) * c, vec3(1., 0.95, 0.9), y);\n\t\ts.col.a = y*3.;     \n    }\n    \n    if (intersectSphere(r, Sphere(vec3(-8,6.0 + abs(sin(t*2.) * 6.),14), 6.0), test) ) {\n        // silver ball\n\t\ts.col = vec4(.4,.5,.8,0.0);\n\t\ts.gloss = 0.3;\n        s.ref = 0.0;\n    }\n    \n    Triangle tri;\n    float speed = sin(t*0.5) * 20.0;\n    vec3 v0 = vec3(0,0,0);\n    vec3 v1 = vec3(sin( speed), 1, cos( speed)) * 6.;\n    vec3 v2 = vec3(sin( speed + PI * 0.5), 1, cos( speed + PI * 0.5)) * 6.;\n    vec3 v3 = vec3(sin( speed + PI), 1, cos(speed + PI)) * 6.;\n    vec3 v4 = vec3(sin( speed + PI * 1.5), 1, cos( speed + PI * 1.5)) * 6.;\n    \n    vec3 edgeA = v1-v0;\n    vec3 edgeB = v2-v0;\n    vec3 edgeC = v3-v0;\n    vec3 edgeD = v4-v0;\n    \n\ttri.v0 = v0;\n    tri.edgeA = edgeB;\n    tri.edgeB = edgeA;\n    tri.n = normalize(cross(tri.edgeA, tri.edgeB));\n    \n    bool hitTri = false;\n    hitTri = hitTri || intersectTriangle(r, tri, test);\n    \n    tri.edgeA = edgeC;\n    tri.edgeB = edgeB;\n    tri.n = normalize(cross(tri.edgeA, tri.edgeB));\n    hitTri = hitTri || intersectTriangle(r, tri, test);\n    \n    tri.edgeA = edgeD;\n    tri.edgeB = edgeC;\n    tri.n = normalize(cross(tri.edgeA, tri.edgeB));\n    hitTri = hitTri || intersectTriangle(r, tri, test);\n    \n    tri.edgeA = edgeA;\n    tri.edgeB = edgeD;\n    tri.n = normalize(cross(tri.edgeA, tri.edgeB));\n    hitTri = hitTri || intersectTriangle(r, tri, test);\n    \n    // top\n    \n    edgeA = v2-v1;\n    edgeB = v4-v1;\n    edgeC = v2-v3;\n    edgeD = v4-v3;\n    \n    tri.v0 = v1;\n    tri.edgeA = edgeA;\n    tri.edgeB = edgeB;\n    tri.n = normalize(cross(tri.edgeA, tri.edgeB));\n    hitTri = hitTri || intersectTriangle(r, tri, test);\n    \n    tri.v0 = v3;\n    tri.edgeA = edgeD;\n    tri.edgeB = edgeC;\n    tri.n = normalize(cross(tri.edgeA, tri.edgeB));\n    hitTri = hitTri || intersectTriangle(r, tri, test);\n    \n    if (hitTri) {\n        // Triangle\n        s.col = vec4(.8,.5,.5,0);\n\t\ts.ref = 1.0;\n\t\ts.gloss = 0.0;\n    }\n    \n    if (intersectBox(r, Box(vec3(4,0,-4), vec3(20, 5, -14)), test)) {\n        // gold box\n        s.col = vec4(0.9, 0.9, 0.6, 0);\n        s.ref = 0.9;\n        s.gloss = 0.0;\n    }\n    s.dist = test.dist;\n    s.normal = test.normal;\n\t\n\treturn s;\n}\n\nvec4 traceScene(in Camera cam, vec2 seed, float lastB) {\n\tvec3 startPos = cam.pos;\n\tvec4 result = vec4(0);\n\n\tint maxI = int(float(MAXRAYS) * lastB);\n    float rayCount = 0.0;\n    float t = iTime;// - iTimeDelta;\n    \n#ifdef FIXEDFRAMETIME\n    float tStep = FRAMETIME / float(maxI);\n#else\n    float tStep = iTimeDelta / float(maxI);\n#endif\n\tfor (int i=0; i<MAXRAYS; i++) {\n\t\tif (i==maxI) break;\n\t\tRay r = cam.ray;\n        rayCount++;\n        t += tStep;\n\n        vec3 rr = (vec3(nrand(seed), nrand(seed.yx), nrand(seed.xx)) * 2. -1.) * divergence*2.0;\n        r.dir += rr;\n\t\tr.dir = normalize(r.dir);\n        \n\t\tvec4 impact = vec4(BRIGHTNESS);\n\t\tseed++;\n\n\t\tfor (int j=0; j<MAXBOUNCES; j++) {\n\t\t\tSceneResult test = intersectScene(r, t);\n#ifdef DEBUG\nreturn vec4((test.dist)) / 100.0;\n#endif\n\t\t\tif (test.col.a > 0.0) { \n\t\t\t\tresult += test.col * impact * test.col.a;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\t\n\t\t\timpact *= test.col;\n                \n\t\t\tr.origin += r.dir * test.dist;\n\t\t\t\t\n\t\t\tr.origin += test.normal * 0.1;\n                    \n            vec3 rs = r.origin + seed.x;\n\t\t\tvec3 random = vec3(\n\t\t\t\tnrand(rs.xy),\n\t\t\t\tnrand(rs.yz),\n\t\t\t\tnrand(rs.zx)\n\t\t\t)*2. - 1.;\n\t\t\t\t\n\t\t\tfloat fresnel = clamp(dot(r.dir, test.normal)+1.0, 0., 1.0) * test.gloss;\n\t\t\t\n\t\t\ttest.ref = mix(test.ref, 1.0, fresnel);\n            \n            vec3 matte = normalize(test.normal * SQRT2 + random);\n            \n\t\t\tvec3 refl = reflect(r.dir, test.normal);\n\t\t\tvec3 newDir = mix(\n\t\t\t\tmatte,\n\t\t\t\trefl,\n\t\t\t\ttest.ref\n\t\t\t);\n\t\t\tfloat s = step(fresnel, nrand(seed));\n\t\t\tr.dir = //newDir;\n\t\t\t\t\n\t\t\tnormalize(newDir * s + refl * (1.-s));\n            \n        }\n    }\n    return result / rayCount;// / (float(MAXRAYS));\n}\n\n// Sets up a camera at a position, pointing at a target.\n// uv = fragment position (-1..1) and fov is >0 (<1 is telephoto, 1 is standard, 2 is fisheye-like)\nCamera setupCam(in vec3 pos, in vec3 target, in float fov, in vec2 uv) {\n\t\t// cam setup\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = mouse * 2. - 0.5;\n   // R(pos.xz, mouse.x - 0.5);// + sin(iTime*0.5)*0.5);\n    // Create camera at pos\n\tCamera cam;\n    cam.pos = pos;\n    \n    // A ray too\n    Ray ray;\n    ray.origin = pos;\n    \n    // FOV is a simple affair...\n    uv *= fov;\n    \n    // Now we determine hte ray direction\n\tvec3 cw = normalize (target - pos );\n\tvec3 cp = vec3 (0.0, 1.0, 0.0);\n\tvec3 cu = normalize ( cross(cw,cp) );\n\tvec3 cv = normalize ( cross (cu,cw) );\n    \n\tray.dir = normalize ( uv.x*cu + uv.y*cv + 0.5 *cw);\n    \n    // Add the ray to the camera and our work here is done.\n\tcam.ray = ray;\n    \n    // Ray divergence\n    divergence = fov / iResolution.x;\n    //divergence = divergence + length(uv) * 0.01;\n\treturn cam;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   // t = iTime;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2. - 1.;\n    uv.y /= iResolution.x/iResolution.y;\n    Camera cam = setupCam(vec3(sin(iTime * 0.3) * 5. - 7.,sin(iTime * 0.4) * 5. + 7.,sin(iTime * 0.5) * 5. - 7.), vec3(0,5,0), 0.7, uv);\n        //Camera(vec3(0, 5, -10), normalize(vec3(uv, 1.0)));\n    \n    vec4 l = texture(iChannel0, fragCoord / iResolution.xy);\n    float ll = (l.r+l.g+l.b) / 3.0;\n    vec3 lc = l.rgb - ll;\n    \n    float bias = iMouse.z > 0.5 || iFrame == 0 ? 1.0 : max(0.2, 1.0 - max(l.r, max(l.g, l.b)));\n\n    vec4 c = traceScene(cam, uv + iTime, bias);// / bias;\n    float cl = (c.r+c.g+c.b) / 3.0;\n    vec3 cc = c.rgb - cl;\n    \n    float diff = length(cc-lc);\n    diff = max(diff*6., abs(cl-ll));\n   // diff = max(abs(c.x-l.x), max(abs(c.y-l.y), abs(c.z-l.z)));\n\n    fragColor = c;//mix(c, l,  clamp(1.-diff, 0.0, 0.97));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}