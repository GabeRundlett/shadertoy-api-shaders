{
    "Shader": {
        "info": {
            "date": "1658862487",
            "description": "// CC0: Second attempt to fake Wave Function Collapse\n// I watched Coding Challenge 171: Wave Function Collapse: https://www.youtube.com/watch?v=rI_y2GAlQFM\n// The algorithm AFAIK doesn't fit shader world that well.\n// But I thought I could fake it.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "7sGBDV",
            "likes": 25,
            "name": "Second Wave Function Collapser",
            "published": 3,
            "tags": [
                "2d"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 412
        },
        "renderpass": [
            {
                "code": "// CC0: Second attempt to fake Wave Function Collapse\n// I watched Coding Challenge 171: Wave Function Collapse: https://www.youtube.com/watch?v=rI_y2GAlQFM\n// The algorithm AFAIK doesn't fit shader world that well.\n// But I thought I could fake it.\n// So randomizing rotations of out a 6 shapes in all grid tiles that don't touch each other\n// Then in the connecting grid tiles I select a shape to match the surrounding randomized cells\n\n// I thought it was a bit interesting and a bit different from how I usually do when doing truchet patterns so I shared\n\n// See only the randomized tiles\n//#define RANDOMIZED_TILES_ONLY\n\n// See the debugging dots\n//#define DEBUG_DOTS\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nconst float linew = 0.02;\nconst float circle = 0.1;\n\nfloat halfPlane(vec2 p) {\n  float d0 = length(p);\n  float d1 = abs(p.x);\n  return p.y < 0.0 ? d0 : d1;\n}\n\nfloat cell0(vec2 p) {\n  float d0 = abs(p.x);\n  float d1 = abs(p.y);\n  float d2 = length(p)-circle;\n  float d = min(d0, d1);\n  d = min(d, d2);\n  d = max(d, -d2);\n  d -= linew;\n  return d;\n}\n\nfloat cell2_corner(vec2 p) {\n  float d0 = length(p-0.5)-0.5;\n  float d = d0;\n  d = abs(d);\n  d -= linew;\n  return d;\n}\n\nfloat cell2_line(vec2 p) {\n  float d0 = abs(p.y);\n  float d = d0;\n  d -= linew;\n  return d;\n}\n\nfloat cell1(vec2 p) {\n  float d0 = abs(p.x);\n  float d1 = abs(p.y);\n  float d2 = length(p)-circle;\n  float d = \n    p.x > 0.0\n    ? min(d0, d1)\n    : d0\n    ;\n  d = min(d, d2);\n  d = max(d, -d2);\n    \n  d -= linew;\n  return d;\n}\n\nfloat cell3(vec2 p) {\n  float d0 = halfPlane(p);\n  float d2 = length(p)-circle;\n  float d = d0;\n  d = min(d, d2);\n  d = max(d, -d2);\n  d -= linew;\n  return d;\n}\n\nfloat cell4(vec2 p) {\n  float d = length(p)-circle;\n  d = abs(d);\n  d -= linew;\n  return d;\n}\n\nconst int distribution[16] = int[](\n    0                   // cell0\n  , 1 , 1               // cell1\n  , 2 , 2 , 2 , 2 , 2   // cell2_corner\n  , 3 , 3 , 3 , 3 , 3   // cell2_line\n  , 4 , 4               // cell3\n  , 5                   // cell4\n  );\n\nvoid selector(vec2 cn, out int rot, out int shape) {\n  float h0 = hash(cn);\n  float h1 = fract(h0*8677.0);\n  rot   = int(floor(4.0*h1));\n  shape = distribution[int(floor(16.0*h0))];\n}\n\nconst bool open[6*4] = bool[](\n//  left    top     right   bottom\n    false , false , false , false   // cell0\n  , true  , false , false , false   // cell1\n  , true  , false , false , true    // cell2_corner\n  , false , true  , false , true    // cell2_line\n  , true  , false , true  , true    // cell3\n  , true  , true  , true  , true    // cell4\n  );\n\nbool isOpen(int off, vec2 cn) {\n  int rot;\n  int shape;\n  selector(cn, rot, shape);\n  int r = 0x3&(off+rot);\n  return open[shape*4+r];\n}\n\n\nfloat df(vec2 p) {\n  const mat2[4] rots = mat2[](ROT(0.0*TAU/4.0),ROT(1.0*TAU/4.0),ROT(2.0*TAU/4.0),ROT(3.0*TAU/4.0)); \n  vec2 cp = p-0.5;\n  vec2 cn = round(cp);\n  cp -= cn;\n  \n  if (mod(cn.x+cn.y, 2.0) == 0.0) {\n    int rot;\n    int shape;\n    selector(cn, rot, shape);\n    cp *= rots[rot];\n    switch(shape) {\n    case 0:\n       return cell0(cp);\n    case 1:\n      return cell1(cp);\n    case 2:\n      return cell2_corner(cp);\n    case 3:\n      return cell2_line(cp);\n    case 4:\n      return cell3(cp);\n    case 5:\n      return cell4(cp);\n   default:\n      return length(p);\n    }\n  } else {\n    float d = 1E6;\n\n    int ol = isOpen(2, cn+vec2(-1.0, 0.0)) ? 0 : 1;\n    int ot = isOpen(3, cn+vec2( 0.0, 1.0)) ? 0 : 2;\n    int or = isOpen(0, cn+vec2( 1.0, 0.0)) ? 0 : 4;\n    int ob = isOpen(1, cn+vec2( 0.0,-1.0)) ? 0 : 8;\n\n#ifdef DEBUG_DOTS\n    const float dbgw = 0.025;\n    // Debugging code\n    if (ol == 0) {\n      d = min(d, length(cp-4.0*dbgw*vec2(-1.0, 0.0))-dbgw);\n    }\n    if (ot == 0) {\n      d = min(d, length(cp-4.0*dbgw*vec2( 0.0, 1.0))-dbgw);\n    }\n    if (or == 0) {\n      d = min(d, length(cp-4.0*dbgw*vec2( 1.0, 0.0))-dbgw);\n    }\n    if (ob == 0) {\n      d = min(d, length(cp-4.0*dbgw*vec2( 0.0, -1.0))-dbgw);\n    }\n#endif\n\n    int sel = ol + ot + or + ob;\n    float ds = length(cp)-linew;\n\n#ifdef RANDOMIZED_TILES_ONLY\n\n#else\n    // Yikes, this would nice to find a neat little improvement too\n    switch(sel) {\n    case 0:\n      ds = cell4(cp);\n      break;\n    case 1:\n      ds = cell3(-cp.yx);\n      break;\n    case 2:\n      ds = cell3(cp);\n      break;\n    case 4:\n      ds = cell3(cp.yx);\n      break;\n    case 8:\n      ds = cell3(-cp);\n      break;\n    case 3:\n      ds = cell2_corner(vec2(cp.y, -cp.x));\n      break;\n    case 6:\n      ds = cell2_corner(cp);\n      break;\n    case 9:\n      ds = cell2_corner(-cp);\n      break;\n    case 12:\n      ds = cell2_corner(vec2(-cp.y, cp.x));\n      break;\n    case 5:\n      ds = cell2_line(cp);\n      break;\n    case 10:\n      ds = cell2_line(cp.yx);\n      break;\n    case 7:\n      ds = cell1(cp.yx);\n      break;\n    case 11:\n      ds = cell1(-cp);\n      break;\n    case 13:\n      ds = cell1(-cp.yx);\n      break;\n    case 14:\n      ds = cell1(cp);\n      break;\n    case 15:\n      ds = cell0(cp);\n      break;\n    default:\n      break;\n    }\n    d = min(d, ds);\n#endif    \n    return d;\n  }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n  float z = mix(0.25, 0.05, smoothstep(0.25, -0.25, cos(TIME*TAU/20.0)));\n  vec2 dp = p;\n  const float spd = 2.0;\n  const float r = 10.0;\n  dp /= z;\n  dp += r*sin(vec2(sqrt(0.5), 1.0)*TIME*spd/r);\n  float d = df(dp)*z;\n  vec3 col = vec3(0.01);\n  col = mix(col, vec3(0.5), smoothstep(aa, -aa, d));\n  col = sqrt(col);\n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}