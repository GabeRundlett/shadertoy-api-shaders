{
    "Shader": {
        "info": {
            "date": "1564365295",
            "description": "My attempt at recreating a procedural monster from this post : https://twitter.com/stvulture/status/1151920498336550912",
            "flags": 0,
            "hasliked": 0,
            "id": "WlsSD2",
            "likes": 4,
            "name": "Procedural monster - stvulture",
            "published": 3,
            "tags": [
                "sdf",
                "monster",
                "friend"
            ],
            "usePreview": 0,
            "username": "clepirelli",
            "viewed": 771
        },
        "renderpass": [
            {
                "code": "#define CLOSE_ENOUGH .001\n#define BLACK vec3(.1)\n#define WHITE vec3(1.0,.95,.95)\n#define YELLOW vec3(1.0,1.0,.0)\n\nstruct sdf_return\n{\n\tfloat sdf;\n    vec3 col;\n};\n\nstruct sphere\n{\n\tvec3 c;\n    float r;\n};\n    \nstruct ray\n{\n\tvec3 o;\n    vec3 d;\n};\n    \nstruct dirLight\n{\n\tvec3 d;\n    float i;\n};\n    \nconst int sphereCount = 11;\n    \nfloat sphDist(vec3 p, sphere s)\n{\n\treturn distance(p, s.c) - s.r;\n}\n\n//from iq : https://iquilezles.org/articles/distfunctions\nfloat dist_smooth( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat sdf(vec3 p, sphere[sphereCount] spheres)\n{\n    float sdist1 = sphDist(p, spheres[ 0]);\n    float sdist2 = sphDist(p, spheres[ 1]);\n    float sdist3 = sphDist(p, spheres[ 2]);\n    float sdist4 = sphDist(p, spheres[ 3]);\n    float sdist5 = sphDist(p, spheres[ 4]);\n    float sdist6 = sphDist(p, spheres[ 5]);\n    float sdist7 = sphDist(p, spheres[ 6]);\n    float sdist8 = sphDist(p, spheres[ 7]);\n    float sdist9 = sphDist(p, spheres[ 8]);\n    float sdist11= sphDist(p, spheres[10]);\n    \n    float body = dist_smooth(sdist1, sdist2, .1);\n    float leg1 = dist_smooth(dist_smooth(sdist3,sdist4,.15), sdist5, .1);\n    float leg2 = dist_smooth(dist_smooth(sdist6,sdist7,.15), sdist8, .1);\n\t\n    \n    \n    return min(min(min(dist_smooth(body, sdist9,.1), leg1),leg2),sdist11);\n}\n\nsdf_return scene(vec3 p, sphere[sphereCount] spheres)\n{\n    vec3 col = BLACK;\n    float body = sdf(p, spheres);\n    float eye = sphDist(p, spheres[9]);\n    if(eye < body) col = WHITE;\n    \n    return sdf_return(min(eye, body), col);\n}\n\n//from iq https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 p, sphere[sphereCount] spheres )\n{\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sdf( p + k.xyy*CLOSE_ENOUGH, spheres ) + \n                      k.yyx*sdf( p + k.yyx*CLOSE_ENOUGH, spheres ) + \n                      k.yxy*sdf( p + k.yxy*CLOSE_ENOUGH, spheres ) + \n                      k.xxx*sdf( p + k.xxx*CLOSE_ENOUGH, spheres ) );\n}\n\nconst int aa = 2;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    sphere spheres[sphereCount] = sphere[sphereCount]\n\t(\n\t\tsphere(vec3(.1,.2, .5)\t\t\t\t\t\t,.2\t\t),\t//BODY\n\t    sphere(vec3(.0,.0,.5)\t\t\t\t\t\t,.1\t\t),\t//BODY\n        sphere(vec3(.1,-.01, .45)\t\t\t\t\t,.02\t),\t//LEG1\n        sphere(vec3(.12,-.1, .45)\t\t\t\t\t,.017\t),\t//LEG1\n        sphere(vec3(.13,-.18, .45)\t\t\t\t\t,.014\t),\t//LEG1\n        sphere(vec3(-.01,-.01, .45)\t\t\t\t\t,.02\t),\t//LEG2\n        sphere(vec3(-.012,-.1, .45)\t\t\t\t\t,.017\t),\t//LEG2\n        sphere(vec3(-.013,-.18, .45)\t\t\t\t,.014\t),\t//LEG2\n        sphere(vec3(-.13+sin(iTime)*.01, -.04, .45)\t,.06\t), \t//HEAD\n        sphere(vec3(-.13+sin(iTime)*.01, -.04, .1)\t,.015\t), \t//EYE_WHITE\n        sphere(vec3(-.13+sin(iTime)*.01, -.04, .09)\t,.01\t) \t//EYE_BLACK\n\t);\n   \t\n    dirLight l = dirLight(normalize(vec3(1.0, 1.0, -.2)), 1.0);\n\t\n    vec3 total = vec3(.0);\n    for(int i = 0; i < aa; i++)\n    for(int j = 0; j < aa; j++)\n    {\n    \tvec2 uv = (fragCoord+vec2(float(i),float(j))/float(aa)-.5)/iResolution.xy - vec2(.5);\n        uv.x *= iResolution.x/iResolution.y;\n        \n    \n    \n    \tray r = ray(vec3(uv.x, uv.y, .0), normalize(vec3(uv.xy, 4.0)));\n    \t\n    \tvec3 col = YELLOW;\n    \t\n    \tfloat dist = .0;\n    \twhile(dist < 50.0)\n    \t{\n    \t    vec3 rp = r.o + r.d *dist;\n    \t    sdf_return ret = scene(rp, spheres);\n    \t    if(ret.sdf < CLOSE_ENOUGH)\n    \t    {\n    \t    \tvec3 n = calcNormal(rp,spheres);\n    \t        col = ret.col;\n    \t        if(col.r >.2) col *=2.0;\n\t\t\t\tcol *= (.15 + max(dot(l.d, n), .0)*.45 + pow(clamp(dot(reflect(r.d, n), r.d), .0, 1.0), 32.0)*.4) * l.i; \n    \t        break;\n    \t    }\n    \t    dist += ret.sdf;\n    \t}\n        total += col;\n    }\n    total /= float(aa*aa);\n    \n    fragColor = vec4(pow(total, vec3(1./2.2)),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}