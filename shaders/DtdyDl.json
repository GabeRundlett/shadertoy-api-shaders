{
    "Shader": {
        "info": {
            "date": "1699825886",
            "description": "Analytical derivatives of a few noise transformations.\n\nTop-left: numerical gradient.\nTop-right: analytical gradient.\nBottom: their difference (magnified).\nCenter: function value.",
            "flags": 0,
            "hasliked": 0,
            "id": "DtdyDl",
            "likes": 3,
            "name": "Examples of grad(f(noise(g(r))))",
            "published": 3,
            "tags": [
                "noise",
                "gradient",
                "derivative"
            ],
            "usePreview": 0,
            "username": "FordPerfect",
            "viewed": 193
        },
        "renderpass": [
            {
                "code": "// Public Domain under http://unlicense.org, see link for details.\n\n// iq described how to compute noise and its analytical derivatives\n// in the following articles:\n//     https://iquilezles.org/articles/morenoise/\n//     https://iquilezles.org/articles/gradientnoise/\n// and accompanied code:\n//     https://www.shadertoy.com/view/4dXBRH\n//     https://www.shadertoy.com/view/XdXBRH\n//     https://www.shadertoy.com/view/XsXfRH\n//     https://www.shadertoy.com/view/4dffRH\n// The first article states: \"If you implement a ridged Value Noise or\n// other variations you can also easily drive the right way to combine\n// the derivatives, unless you have a discontinuous shaping function like\n// a fabsf().\" (NOTE: ridged noise involves abs()).\n//\n// However, abs() and such are not a big obstacle (you do get garbage\n// at the actual discontinuity points, but that is often acceptable).\n//\n// Below are a few examples of computing derivatives for slightly more\n// involved cases.\n//\n// If you want to be more systematic, a simple automatic differentiation\n// framework (https://en.wikipedia.org/wiki/Automatic_differentiation),\n// operating on (Value,Gradient) pairs (sort of like N-dimensional dual\n// numbers), can probably be implemented in something like 100 lines of\n// GLSL code for 1D, 2D and 3D.\n\n// https://www.shadertoy.com/view/dllSW7\nuint hash(uint x)\n{\n    x^=x>>15;\n    x^=(x*x)|1u;\n    x^=x>>17;\n    x*=0x9E3779B9u;\n    x^=x>>13;\n    return x;\n}\n\nfloat rnd2i(ivec2 v)\n{\n    return float(int(hash(uint(v.x+65536*v.y))))*4.6566129e-10;\n}\n\n// 2D value noise. Gradient in xy, value in z.\nvec3 noise2d(vec2 v)\n{\n    ivec2 i=ivec2(floor(v)),e=ivec2(0,1);\n    v=fract(v);\n    float A=rnd2i(i+e.xx);\n    float B=rnd2i(i+e.yx);\n    float C=rnd2i(i+e.xy);\n    float D=rnd2i(i+e.yy);\n    vec2 d=30.0*v*v*(v*(v-2.0)+1.0);\n    v=v*v*v*(v*(v*6.0-15.0)+10.0);\n    return vec3(\n        vec2(mix(B-A,D-C,v.y),mix(C-A,D-B,v.x))*d,\n        mix(mix(A,B,v.x),mix(C,D,v.x),v.y));\n}\n\nvec3 f(vec2 v)\n{\n    vec3 ret=vec3(0.0),r=vec3(0);\n    if(true) // Affine argument transform.\n    {\n        float w=0.37;\n        mat2 A=5.0*mat2(0.7,0.8,-0.5,1.0);\n        vec2 b=vec2(1.3,3.7);\n        // See https://en.wikipedia.org/wiki/Chain_rule#General_rule:_Vector-valued_functions_with_multiple_inputs\n        r=w*noise2d(A*v+b);\n        r.xy=r.xy*A; // Multiply gradient with Jacobian.\n        ret+=r;\n    }\n    if(true) // Non-linear argument transform.\n    {\n        float w=0.73;\n        vec2 t=vec2(\n            exp(v.x)*v.y+cos(v.y),\n            sin(v.x)+v.y*v.y+7.0);\n        mat2 J=mat2( // Jacobian (NOTE: column-major!)\n            exp(v.x)*v.y,cos(v.x),\n            exp(v.x)-sin(v.y),2.0*v.y);\n        r=w*noise2d(t);\n        // See https://en.wikipedia.org/wiki/Chain_rule#General_rule:_Vector-valued_functions_with_multiple_inputs\n        r.xy=r.xy*J; // Multiply gradient with Jacobian.\n        ret+=r;\n    }\n    if(true) // Dependent argument transform.\n    {\n        float w=0.23;\n        mat2 A=7.0*mat2(0.4,-0.8,0.5,0.8);\n        vec2 B=vec2(0.8,0.7);\n        r=w*noise2d(A*v+B*ret.z);\n        r.xy=r.xy*A+dot(r.xy,B)*ret.xy;\n        ret+=r;\n    }\n    if(true) // Smooth result transform.\n    {\n        // z -> z*exp(-z)\n        ret=vec3(\n            (exp(-ret.z)-ret.z*exp(-ret.z))*ret.xy,\n            ret.z*exp(-ret.z));\n    }\n    if(true) // Non-smooth result transform.\n    {\n        // Abs and its derivative.\n        ret=ret.z<0.0?-ret:ret;\n    }\n    return ret;\n}\n\n// Analytical derivatives.\nvec2 da(vec2 v)\n{\n    return f(v).xy;\n}\n\n// Numerical derivatives.\nvec2 dn(vec2 v)\n{\n    vec2 e=vec2(0.0,1e-3);\n    //return (vec2(f(v+e.yx).z,f(v+e.xy).z)-f(v).z)/e.y;\n    return (vec2(f(v+e.yx).z,f(v+e.xy).z)-vec2(f(v-e.yx).z,f(v-e.xy).z))/(2.0*e.y);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 v=fragCoord/iResolution.y;\n    float t=(0.5+0.5*sin(0.25*iTime))*iResolution.x/iResolution.y;\n    vec3 col=vec3(0.5);\n    if(v.y>0.5)\n    {\n        if(v.x>t) col.xy+=0.5*da(v);\n        else      col.xy+=0.5*dn(v);\n        col=mix(col,vec3(cos(4e2*(v.x-t))),exp(-1e4*(v.x-t)*(v.x-t)));\n    }\n    else\n    {\n        col.xy+=25.0*(dn(v)-da(v));\n    }\n    col=mix(col,vec3(0.5)+0.5*f(v).z,smoothstep(0.41,0.39,distance(v,0.5*iResolution.xy/iResolution.y)));\n    col=mix(12.92*col,1.055*pow(col,vec3(1.0/2.4))-0.055,step(0.0031308,col)); // sRGB\n    fragColor=vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}