{
    "Shader": {
        "info": {
            "date": "1587271188",
            "description": "An attempt to recreate the portal from the game \"Snakebird\"",
            "flags": 0,
            "hasliked": 0,
            "id": "3djyWy",
            "likes": 9,
            "name": "Snakebird Portal Tribute",
            "published": 3,
            "tags": [
                "2d",
                "metaball",
                "portal"
            ],
            "usePreview": 0,
            "username": "fyrn",
            "viewed": 372
        },
        "renderpass": [
            {
                "code": "const int num_colors = 7;\nconst float threshold = 2.5;\nconst float threshold_aa = 0.1;\n\nconst vec3 colors[num_colors] = vec3[num_colors](\n    vec3(0.960,0.321,0.521),\n    vec3(1.000,0.572,0.321),\n    vec3(0.949,0.917,0.321),\n    vec3(0.403,1.000,0.407),\n    vec3(0.321,0.909,0.949),\n    vec3(0.376,0.627,1.000),\n    vec3(0.694,0.423,0.972)\n);\n\n#define TAU 6.28318530\n#define PI  3.14159265\n\nconst float tauToColorRange = float(num_colors) / TAU;\n\nfloat phi(const float r, const vec2 pos) {\n    if (pos.y >= 0.0) {\n    \treturn acos(pos.x / r);\n    }\n    return -acos(pos.x / r);\n}\n\nvec3 rainbow(const vec2 polar) {\n    // Scale\n    float x = polar.x * 4.0;\n\n    // Rotate\n  \tfloat y = polar.y + iTime;\n\n    int index = int(mod(x * 0.9 + y * tauToColorRange, float(num_colors)));\n    return colors[index];\n}\n\nvec3 metaball(float time, float theta, float start) {\n    float theta_2 = mod(theta + time, TAU);\n    vec2 angle_vec = vec2(sin(theta_2), cos(theta_2));\n    float scale = mod((theta / PI) + time / 2.0, 1.5);\n    angle_vec *= 1.5 - scale;\n    scale /= 32.0;\n    return vec3(angle_vec, start);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 pos)\n{\n    // Center\n    pos -= iResolution.xy / 2.0;\n    \n    // Normalize\n    vec2 normPos = pos * 2.0 / iResolution.xy;\n    // Normalize aspect ratio\n    float aspectRatio = iResolution.x / iResolution.y;\n    normPos.x *= aspectRatio;\n\n    // Convert to polar coordinates\n    vec2 polar;\n    polar.x = length(normPos);\n    polar.y = phi(polar.x, normPos);\n\n    // vec3(x, y, radius);\n    vec3 metaballs[] = vec3[](\n        vec3(0.000000000000, 0.0000000, 0.100),\n      \tvec3(metaball(iTime, 0.0000000, 0.001)),\n        vec3(metaball(iTime, PI * 1.00, 0.001)),\n        vec3(metaball(iTime, PI * 0.50, 0.001)),\n        vec3(metaball(iTime, PI * 1.50, 0.001)),\n        vec3(metaball(iTime, PI * 0.30, 0.001)),\n        vec3(metaball(iTime, PI * 0.60, 0.001)),\n        vec3(metaball(iTime, PI * 1.70, 0.001)),\n      \tvec3(metaball(iTime, PI * 1.10, 0.01)),\n        vec3(metaball(iTime, PI * 0.10, 0.001)),\n        vec3(metaball(iTime, PI * 0.20, 0.001)),\n        vec3(metaball(iTime, PI * 1.30, 0.001)),\n        vec3(metaball(iTime, PI * 0.13, 0.001)),\n        vec3(metaball(iTime, PI * 0.56, 0.001)),\n        vec3(metaball(iTime, PI * 0.70, 0.001))\n    );\n    \n    // Sum all metaball strengths\n\tfloat value = 0.0;\n    for (int i = 0; i < metaballs.length(); i += 1) {\n        value += metaballs[i].z / pow(distance(metaballs[i].xy, normPos), 3.0);\n    }\n    \n    // Color based on metaball strength and threshold\n    if (value > threshold) {\n    \tfragColor.xyz = rainbow(polar);\n    } else if (value > threshold - threshold_aa) {\n        float t = smoothstep(threshold, threshold - threshold_aa, value);\n    \tfragColor.xyz = mix(rainbow(polar), vec3(0.0), t);\n    } else {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}