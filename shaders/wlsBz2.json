{
    "Shader": {
        "info": {
            "date": "1597363180",
            "description": "The red curve is the unique C2-interpolating convolution kernel build from equally sized cubic pieces. \nred  : function value\nblue : 1st derivative (scaled)\ngreen: 2nd derivative (scaled)\n(light grey: normalized sinc)",
            "flags": 0,
            "hasliked": 0,
            "id": "wlsBz2",
            "likes": 7,
            "name": "C2-interpolating cubic Kernel",
            "published": 3,
            "tags": [
                "filter",
                "filtering",
                "convolution",
                "cubic",
                "interpolation",
                "continuous",
                "reconstruction",
                "c2"
            ],
            "usePreview": 0,
            "username": "TinyTexel",
            "viewed": 450
        },
        "renderpass": [
            {
                "code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\n\nThe red curve is the unique C2-interpolating convolution kernel build from equally sized cubic pieces. \nThe discrete kernel we get by evaluating its derivative (blue) at all integers allows us to compute C1 continuous derivatives from a\ndiscrete signal with equidistant samples. Therefore a piecewise cubic C2 continuous signal can be reconstructed from a \ngiven set of sample values and derivatives if the derivatives where computed from the sample values using the blue kernel.\n    \nUniquely mapping function values to derivatives this way does however mean that we lose the ability to represent signals of \ntwice the usual Nyquist frequency (which freely choosing the derivatives otherwise enables us to do).\n    \nOne interesting computer graphics related application for this kernel is terrain rendering where C1 discontinuities \nin the gradient of the reconstructed height field can manifest itself as visual artifacts in the shading.\n\n\nI originally derived this kernel on my own but afterwards discovered that (unsurprisingly) I was not the first one to do so.\n     \nMatt Timmermans has a very elegant and compact derivation + demo here:\nhttps://github.com/mtimmerm/IPythonNotebooks/blob/master/NaturalCubicSplines.ipynb\n   \nOn stackexchange Matt links to another derivation from 1971: \nhttps://projecteuclid.org/download/pdf_1/euclid.bams/1183533186 - ON EQUIDISTANT CUBIC SPLINE INTERPOLATION by I.J.Schoenberg\n(https://math.stackexchange.com/questions/1627074/is-there-a-name-for-this-piecewise-cubic-interpolation-kernel) \n\nI actually used a very similar approach to that of Schoenberg namely expressing the result as \nthe weighted sum of an infinite number of cubic BSplines which are itself already C2 continuous. \nI however failed to find a way to determine the formulas for the first and second order derivatives directly. \nWhat I ended up doing was fitting a partial sum to a larger number of data points. \nLooking at the resulting derivatives it seemed very likely that they follow an exponential decay. So I used that as my model. \nI found the free parameters by fitting the necessary number of data points and \nretroactively proved that the result is valid everywhere.\n\n\nRelated:\n- https://www.shadertoy.com/view/WtsBDH | practical application\n\n*/\n\nvec3 Curves(float x)\n{\n    float sn = x < 0.0 ? -1.0 : 1.0;\n    \n    x = abs(x);\n    \n    float x0 = floor(x);\n    \n    x = fract(x);\n    \n    float sgn = fract(x0 * 0.5) == 0.0 ? 1.0 : -1.0;\n    \n    // the derivatives at the start and end of the segment\n    vec2 d = vec2(sgn, -sgn) * 3.0 * exp2(-vec2(x0, x0 + 1.0) * log2(2.0 + sqrt(3.0)));\n        \n    vec2 y = vec2(0.0);\n    \n    if(x0 == 0.0)\n    {\n        y.x = 1.0;\n        d.x = 0.0;\n    }\n    \n    float a = y.x;\n    float b = d.x;\n    float c = -2.0*d.x-d.y+3.0*(-y.x+y.y);\n    float e = d.x+d.y+2.0*(y.x-y.y);\n    \n    float f0 = (a + x * (b + x * (    c + x *      e)));\n    float f1 =           b + x * (2.0*c + x * (3.0*e));\n    float f2 =                    2.0*c + x * (6.0*e);\n    \n    return vec3(f0, sn * f1, f2);    \n}\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n\tvec2 uv = uv0 - 0.5;\n    uv0 += 0.0;\n    \n    vec2 tex = uv0;\n    tex -= iResolution.y * 0.5;\n    tex /= iResolution.xx * 0.125;\n\n    tex *= 0.5;\n    \n\n    vec3 col = vec3(0.0);\n    \n\tcol = mix(vec3(1.0), vec3(0.9), Grid(tex.xy * 4.0, 0.0));        \n\tcol = mix(col, vec3(0.5), Grid(tex.xy * 1.0, 0.0));        \n\tcol = mix(col, vec3(0.125), Cross(tex.xy * 1.0, 0.)); \t\n    \n    \n    col = mix(col, vec3(0.0, 0.0, 0.0), Graph(sin(tex.x*Pi)/(tex.x*Pi) - tex.y, 3.0)*0.125);\n    \n    col = mix(col, vec3(0.0, 1.0, 0.0), Graph(Curves(tex.x).z*0.2 - tex.y, 0.5)*0.5);       \n    col = mix(col, vec3(0.0, 0.5, 1.0), Graph(Curves(tex.x).y*0.5 - tex.y, 0.5));       \n    col = mix(col, vec3(1.0, 0.0, 0.0), Graph(Curves(tex.x).x - tex.y, 0.5)); \n    \n    #if 1\n    vec2 s = (uv0/iResolution.xy*2.0-1.0);\n    s.x = 1.0-Pow2(s.x);    s.y = 1.0-Pow2(s.y);\n    col *= mix(1.0, 0.4, Pow2(1.0-sqrt(s.x*s.y)));\n    #endif\n    \n    outCol = vec4(GammaEncode(clamp01(col)), 1.0);    \n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define PixelCount iResolution.xy\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define rsqrt inversesqrt\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\nconst float Pi2  = Pi * 2.0;\nconst float RcpPi= 1.0 / Pi;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nfloat GammaEncode(float x) {return pow(x, 1.0 / 2.2);}\nvec2 GammaEncode(vec2 x) {return pow(x, vec2(1.0 / 2.2));}\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\nvec4 GammaEncode(vec4 x) {return pow(x, vec4(1.0 / 2.2));}\n\nfloat ddxyLen(float v) { return length(vec2(dFdx(v), dFdy(v))); }\nfloat ddxyRcpLen(float v) { return rsqrt( Pow2(dFdx(v)) + Pow2(dFdy(v)) ); }\n\n\nfloat rescale(float v) { return v * ddxyRcpLen(v); }\n\nfloat Graph(float f, float b)\n{\n    return clamp01(1.0 - (abs(rescale(f))-0.5-b)); \n}\n\n\nfloat Line(float u, float b) { return Graph(u, b); }\nfloat Lines(float u, float b) { return Graph(sin(u * Pi), b); }\n\nfloat Grid(vec2 uv, float b)\n{\n    float xl = Lines(uv.x, b);    \n    float yl = Lines(uv.y, b);\n\n    return max(xl, yl);\n}\n\nfloat Cross(vec2 uv, float b)\n{\n    float xl = Line(uv.x, b);    \n    float yl = Line(uv.y, b);\n\n    return max(xl, yl);\n}\n\nfloat Dot(vec2 sp, vec2 dp, float dr)\n{\n    float v = length(sp - dp) - dr;\n    \n    if(v > dr) return 0.0;\n    \n    v *= ddxyRcpLen(v);\n    v = 1.0 - clamp(v * 1.0, 0.0, 1.0);\n    \n    return v;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}