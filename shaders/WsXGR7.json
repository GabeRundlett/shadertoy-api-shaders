{
    "Shader": {
        "info": {
            "date": "1562390869",
            "description": "Practice based on iq's articles about terrain marching, noise, fogs --> \nThe result is just a place that I wanna go to in my dreams.\n\n",
            "flags": 0,
            "hasliked": 0,
            "id": "WsXGR7",
            "likes": 12,
            "name": "nowhere",
            "published": 3,
            "tags": [
                "terrain",
                "fbm",
                "fog"
            ],
            "usePreview": 0,
            "username": "zxxuan1001",
            "viewed": 709
        },
        "renderpass": [
            {
                "code": "/*\nhttps://iquilezles.org/articles/terrainmarching\nhttps://iquilezles.org/articles/morenoise\n*/\n\nconst vec3 PURPLE = vec3(1.0, 0.9, 1.0);//vec3(141.0, 0.0, 196.0)/255.0;\nconst vec3 PINK = vec3(0.5, 0.4, 0.4);//vec3(255.0,192.0,203.0)/255.0;\nconst vec3 WHITE = vec3(1.0);\nconst vec3 BLACK = vec3(0.0);\nconst vec3 SKY = vec3(0.0);\nconst vec3 MOON = vec3(1.0, 0.6, 0.0);\nconst vec3 BLUE = vec3(0.1,0.2,0.3);\nconst vec3 GREEN = vec3(0.1,0.2,0.3);\nconst vec3 EARTH = vec3(0.1);\nconst float PI = 3.1415926;\nconst float EPSILON = 0.0001;\nconst float SCALE = 0.01;\nconst float HEIGHT = 12.0;\nconst float MAX_DISTANCE = 400.0;\nconst int MAX_STEP = 40;\nconst int ITERATION = 8;\nconst float LUCUNARITY = 1.2;\n#define AA 1\n\nvec3 moonDir = normalize(vec3(7.0, 1.0, -5.0));\n\nfloat hash1(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * 0.013);\n    p3 += dot(p3, p3.yzx + 19.31);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise(in vec2 x) {\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    \n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    \n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n\n    float k0 = a;\n    float k1 = b - a;\n    float k2 = c - a;\n    float k4 = a - b - c + d;\n\n    return k0 + k1*u.x + k2*u.y + k4*u.x*u.y;\n}\n\nvec3 noised( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    \n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec2 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    \n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n\n    float k0 = a;\n    float k1 = b - a;\n    float k2 = c - a;\n    float k4 = a - b - c + d;\n\n    return vec3( -1.0 + 2.0 * (k0 + k1*u.x + k2*u.y + k4*u.x*u.y), \n                      2.0* du * vec2( k1 + k4*u.y,\n                                      k2 + k4*u.x ) );\n}\n\nconst mat2 m2 = mat2(1.2,  0.8, -0.8,  1.2);\nfloat fbm4(vec2 p) {\n    float amp = 1.0;\n    float h = 0.0;\n    for (int i = 0; i < ITERATION; i++) {\n        float n = noise(p);\n        h += amp * n;\n        amp *= 0.5;\n        p = m2 * p ;\n    }\n\treturn  h;\n}\n\n\nconst mat2 m = mat2(1.2, -0.6, 0.6, 1.2);\nvec4 fbmd4(vec2 v) {\n    \n    float amp = 1.0;\n    float f = 1.0 ;\n    float h = 0.0;\n    vec2 d = vec2(0.0);\n    for (int i = 0; i < ITERATION; i++) {\n        vec3 n = 1.0 - abs(noised(v * SCALE * f)); //noised(v * SCALE * f)\n        h += amp * n.x;\n        d += amp * n.yz * f;\n        amp *= 0.5;\n        f *= LUCUNARITY;\n        v = m * v;\n    }\n    h *= HEIGHT  ;\n\td *= HEIGHT * SCALE;\n\treturn vec4( h, normalize( vec3(-d.x,1.0,-d.y) ) );\n}\n\nvec4 terrainMap(vec3 v) {\n    vec4 terrain = fbmd4(v.xz - vec2(100.0, 0.0));\n    terrain.x += .02*noise(v.xz*0.8);\n    return terrain;\n}\n\n    \nvec4 sceneMap(vec3 v) {\n    return terrainMap(v);\n}\n\nvec3 getNormal(vec3 p )\n{\n    vec2 OFFSET = vec2(EPSILON, 0.0);\n    return normalize( vec3( sceneMap(p-OFFSET.xyy).x-sceneMap(p+OFFSET.xyy).x,\n                            1.0*EPSILON,\n                            sceneMap(p-OFFSET.yyx).x-sceneMap(p+OFFSET.yyx).x ) );\n}\nvec3 moon(vec3 ro, vec3 rd) {\n    float n1 = 0.3*noise(rd.xy * 20.0 - iTime);\n    float n2 = 0.3*noise(rd.xy * 10.0 - iTime);\n    float sdot = dot(rd, moonDir)*10.0;\n    float m1 = smoothstep(9.4, 9.75, sdot);\n    float col1 = pow(m1, 128.0);\n    float m2 = smoothstep(9.0+n1, 9.75, sdot);\n    float col2 = pow(m2, 64.0);\n    float m3 = smoothstep(8.2+n2, 9.7, sdot);\n    float col3 = pow(m3, 32.0);\n    float hole1 = (col2 -col1);\n    float hole2 = (col3 -col1);\n    vec3 rst = hole1*MOON*8.0 + hole2*BLUE*2.0;\n    return rst;\n}\n\n\nvec3 stars(vec2 p) {\n    float t = iTime * 0.1;\n    float n1 = hash1(p*0.1) ;\n    n1 *= pow(n1*n1, 680.0) ;\n    n1 *= sin(t*5.0 + p.x + sin(t*2.0 + p.y));\n    n1 = clamp(n1, 0.0, 1.0);\n    return n1 * vec3(1.0);\n}\n\nvec3 sky(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0.0);\n    vec3 v = ro + rd*MAX_DISTANCE;\n    float n1 = noise(v.xy * 0.001);\n    float n2 = noise(v.yx * 0.001);\n    vec3 skyCol = GREEN * 0.01;\n    col += mix(skyCol, GREEN, exp(-16.0*v.y/MAX_DISTANCE));\n    col += stars(v.xy);\n    col += moon(ro, rd);\n    return col;\n}\n\nvec4 castRay(vec3 ro, vec3 rd) {\n    vec4 re = vec4(-1.0);\n    float t = 0.0;\n    for( int i=0; i<MAX_STEP; i++ ){\n        vec3 p = ro + rd * t;\n        vec4 n = sceneMap(p);\n        float h = p.y - n.x;\n    \tre = vec4(t, n.yzw);\n        t += h*n.z; \n        if ((abs(h) < EPSILON) || t > MAX_DISTANCE) {\n            break;\n        } \n    }\n    \n    if (t > MAX_DISTANCE) {\n        re = vec4(-1.0);\n    }\n    return re;\n}\n\nvec3 getShading(vec3 ro, vec3 rd, vec3 p, vec3 normal, vec3 color) {\n    vec3 col = vec3(0.0);\n    vec3 lightDir = moonDir;\n    float moonAmount = max(dot(rd, lightDir), 0.0);\n    vec3 lightCol = mix( GREEN, MOON, pow(moonAmount, 2.0));\n    \n    vec3 viewDir = normalize(ro - p); \n    vec3 refDir = reflect(-lightDir, normal);\n    \n    vec3 ambCol = lightCol * 0.1;\n    float diff = max(dot(lightDir, normal), 0.0);\n    vec3 diffCol = lightCol * diff;\n    \n    float spec = pow(max(dot(refDir, viewDir), 0.0), 8.0);\n    vec3 speCol = lightCol * spec * 0.7;\n    \n    \n    \n    col = (speCol + diffCol) * color ;\n    return col;\n}\n\nvec3 getMaterial(vec3 ro, vec3 rd, vec3 p, vec3 normal) {\n    //vec3 col = texture(iChannel1, p.xz * 0.0051, - 100.0).xyz * 0.5;\n    vec3 col = vec3(0.3, 0.1, 0.1);\n    vec3 lightDir = moonDir;\n    //a bit of sprinkling\n    if (hash1(p.xz) > 0.995) {\n    \tcol += clamp(sin(iTime + p.x*p.z), 0.5, 1.0) * vec3(1.2);\n  \t}\n    \n    return col;\n}\n\nvec3 terrainColor(vec3 ro, vec3 rd, vec3 p, vec3 nor) {\n    vec3 col = vec3(0.0);\n    col = getMaterial(ro, rd, p, nor);\n    col = getShading(ro, rd, p, nor, col) ;\n    \n    return col;\n}\n\nvec3 fog(vec3 ro, vec3 rd, vec3 p, vec3 pixCol, float dis)\n{\n    vec3 lightDir = moonDir;\n    //base color and moonlight\n    vec3 fogCol = vec3(0.0);\n    float b  = 0.000005;\n    float fogAmount = 1.0 - exp( -dis*dis*b );\n    \n    float moonAmount = max(dot(rd, lightDir), 0.0);\n    vec3 mixFog = mix(GREEN, MOON*0.5, pow(moonAmount, 16.0));\n\tfogCol = mix( pixCol, mixFog, fogAmount );\n   \n    //adding density\n    float c = 0.001;\n    float b1 = 0.15;\n    float t = iTime ;\n    float v = 1.0;\n    vec3  denCol  = GREEN; \n    float density =  c * exp(-ro.y*b1) * (1.0 - exp(-dis*rd.y*b1 ))/(rd.y);\n    \n    float turb = fbm4(vec2(p.x*0.02+t*v, p.z*0.02+t*v));\n    density += 0.05*turb;\n    fogCol += mix( pixCol, denCol, density);\n    return fogCol;\n}\n\nmat3 getCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 render( in vec2 fragCoord)\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy ;\n    //uv -= 0.5; // translate to the center of the screen\n    uv.x *= iResolution.x / iResolution.y; // restore aspect ratio\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    mouse -= 0.5;\n    //define camera\n    vec3 ro = vec3 (cos(mouse.x * 6.28) * 10.0, 0.0, sin(mouse.x * 6.28) * 10.0);\n    vec3 ta = vec3 (0.0, 1.0, -2.0);\n    mat3 cam = getCamera(ro, ta, 0.0);\n\n    vec3 rd = normalize(cam * vec3(uv, 1.0));\n    \n    //draw scene\n   \tvec3 color = vec3(0.0);\n    vec4 hnor = castRay(ro, rd);\n    vec3 p = ro + rd * hnor.x;\n    \n    if (hnor.x > EPSILON) {\n        //vec3 nor = hnor.yzw + 0.01*hash1(p.xz * 5.0);\n        vec3 nor= getNormal(p) ;\n        color += terrainColor(ro, rd, p, nor);  \n        color = fog(ro, rd, p, color, hnor.x);\n    } else {\n        color += sky(ro, rd);\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pixCol = vec3(0.0);\n    vec2 offset = vec2(0.0);\n    \n#if AA>1\n    for (float y = 0.0; y < float(AA); ++y)\n    {\n        for (float x = 0.0; x < float(AA); ++x)\n        {\n            offset = -0.5 + vec2(x, y) / float(AA);\n\n        \tpixCol += render(fragCoord+offset);\n        }\n    }\n    pixCol /= float(AA*AA);\n#else\n    pixCol += render(fragCoord);\n#endif\n        \n    pixCol = pow( pixCol, vec3(1.0/2.2) );\n    \n    // Output to screen\n    fragColor = vec4(pixCol, 1.0);\n\t\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}