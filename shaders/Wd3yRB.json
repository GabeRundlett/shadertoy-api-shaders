{
    "Shader": {
        "info": {
            "date": "1650965662",
            "description": "Penguin Books paperbacks pattern\nCopied from: https://www.reddit.com/r/generative/comments/izhyms/tile_system_inspired_by_penguin_books_paperbacks/",
            "flags": 0,
            "hasliked": 0,
            "id": "Wd3yRB",
            "likes": 5,
            "name": "Penguin Books paperbacks pattern",
            "published": 3,
            "tags": [
                "wip",
                "pattern"
            ],
            "usePreview": 0,
            "username": "tutmann",
            "viewed": 241
        },
        "renderpass": [
            {
                "code": "const vec3 bg = vec3(1.0, 0.95, 0.88);\nconst vec3 fg = vec3(0.14, 0.14, 0.14);\nconst float lw = 0.05;\nconst float aa = 0.05;\n\nconst uint k = 1103515245U;  // GLIB C\nconst float pi2 = 1.57079632679;\n\nconst float num_tiles = 5.0;\nconst float translation = 0.03;\n\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvec2 rotate(in vec2 p, in float rot) {\n    return p * mat2(cos(rot),-sin(rot),sin(rot),cos(rot));\n}\n\n\n\nvec3 tile_cross(in vec2 pos) {\n    float col = min(abs(pos.x), abs(pos.y));\n \treturn mix(fg, bg, smoothstep(lw, lw+aa, col));    \n}\n\nvec3 tile_qcircle(in vec2 pos) {\n    float r1 = length(pos-vec2(1.));\n    float r2 = length(pos+vec2(1.));\n    float d = min(r1, r2);\n    d = abs(d-1.0);\n \treturn mix(fg, bg, smoothstep(lw, lw+aa, d));    \n}\n\nvec3 tile_qcircle_1full(in vec2 pos) {\n    float r1 = length(pos-vec2(1.));\n    float r2 = length(pos+vec2(1.));\n    float d = min(r1, r2);\n    d = abs(d-1.0);\n    d = min(d, step(1.0,r2));\n    d = smoothstep(lw, lw+aa, d);\n \treturn mix(fg, bg, d);    \n}\n\nvec3 tile(float id, vec2 p) {\n    int tile_type = int(id * 3.0);\n    vec3 col;\n    if (tile_type > 1) {\n        col = tile_qcircle_1full(p);\n    } else if (tile_type > 0) {\n        col = tile_qcircle(p);\n    } else {\n        col = tile_cross(p);\n    }\n    p = abs(p);\n//    col = min(col, smoothstep(1.0,0.99, max(p.x, p.y)));\n    return col;\n}\nconst float n_tiles = 2.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = (fragCoord / min(iResolution.x, iResolution.y) +  vec2(iTime * translation)) * num_tiles;\n    vec2 p = fract(pos) * 2.0 - 1.0;\n\n    vec3 tile_id = hash(uvec3(trunc(pos),0));\n    int tile_type = int(tile_id.x * n_tiles);\n    float rot = float(int(tile_id.y * 4.0)) * pi2;\n    \n    p = rotate(p, rot);\n    \n    vec3 col = tile(tile_id.x, p);\n\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}