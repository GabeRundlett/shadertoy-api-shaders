{
    "Shader": {
        "info": {
            "date": "1500050497",
            "description": "A naive implementation of the canny edge detector. \nThe unfinished step is to flood fill the edges and connect the dots.\nPress the mouse for comparison with fwidth.",
            "flags": 32,
            "hasliked": 0,
            "id": "Xly3DV",
            "likes": 7,
            "name": "Fast Canny Edge Detection",
            "published": 3,
            "tags": [
                "2d",
                "filter",
                "detection",
                "edge",
                "image",
                "gaussian",
                "outline",
                "canny"
            ],
            "usePreview": 1,
            "username": "starea",
            "viewed": 3787
        },
        "renderpass": [
            {
                "code": "#define A(X,Y) (tap(iChannel0,vec2(X,Y)))\n#define B(X,Y) (tap(iChannel1,vec2(X,Y)))\n#define C(X,Y) (tap(iChannel2,vec2(X,Y)))\n#define D(X,Y) (tap(iChannel3,vec2(X,Y)))\nvec3 tap(sampler2D tex,vec2 xy) { return texture(tex,xy).xyz; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = D(uv.x, uv.y); \n    //(min(fwidth(texture(iChannel0, fragCoord.xy / iResolution.xy))*7.0\n    if (iMouse.z > 0.0) col = vec3(pow( length(fwidth(texture(iChannel1, uv) * 7.0)), 2.0));\n\tfragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/** \n * Canny Edge Detection by Ruofei Du (DuRuofei.com)\n * Step 1A: Apply (Horizontal) Gaussian filter to smooth the image in order to remove the noise\n * Link to demo: https://www.shadertoy.com/view/Xly3DV\n * starea @ ShaderToy, License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. \n *\n * Reference: \n * [1] Canny, J., A Computational Approach To Edge Detection, IEEE Trans. Pattern Analysis and Machine Intelligence, 8(6):679–698, 1986.\n * [2] Canny edge detector, Wikipedia. https://en.wikipedia.org/wiki/Canny_edge_detector\n *\n * Related & Better Implementation:\n * [1] https://www.shadertoy.com/view/4ssXDS\n * [2] stduhpf's Canny filter (3pass): https://www.shadertoy.com/view/MsyXzt\nhttp://duruofei.com/Public/course/CMSC733/Du_Ruofei_PS1.pdf\n * \n **/\nconst int mSize = 5;\nconst int kSize = (mSize - 1) / 2;\nconst float sigma = 2.0;\nconst float GAMMA = 2.2; \nfloat kernel[mSize];\n\nfloat normpdf(in float x, in float sigma) {\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n    float Z = 0.0;\n    for (int j = 0; j <= kSize; ++j) {\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n\n    for (int j = 0; j < mSize; ++j) {\n        Z += kernel[j];\n    }\n\n    for (int i = -kSize; i <= kSize; ++i) {\n        col += kernel[kSize+i] * pow(\n                    texture(iChannel0, (fragCoord.xy+ vec2(float(i),0.0) ) / iResolution.xy).rgb\n                  , vec3(GAMMA));\n    }\n    \n    fragColor = vec4(pow(col / Z, vec3(1.0 / GAMMA)), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/** \n * Canny Edge Detection by Ruofei Du (DuRuofei.com)\n * Step 1B: Apply (Vertical) Gaussian filter to smooth the image in order to remove the noise\n *          Meanwhile, convert the smoothed image to gray scale\n * Link to demo: https://www.shadertoy.com/view/Xly3DV\n * starea @ ShaderToy, License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. \n *\n * Reference: \n * [1] Canny, J., A Computational Approach To Edge Detection, IEEE Trans. Pattern Analysis and Machine Intelligence, 8(6):679–698, 1986.\n * [2] Canny edge detector, Wikipedia. https://en.wikipedia.org/wiki/Canny_edge_detector\n *\n * Related & Better Implementation:\n * [1] stduhpf's Canny filter (3pass): https://www.shadertoy.com/view/MsyXzt\n **/\nconst int mSize = 5;\nconst int kSize = (mSize - 1) / 2;\nconst float sigma = 2.0;\nconst float GAMMA = 2.2; \nfloat kernel[mSize];\n\nfloat normpdf(in float x, in float sigma) {\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n    float Z = 0.0;\n    for (int j = 0; j <= kSize; ++j) {\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n\n    for (int j = 0; j < mSize; ++j) {\n        Z += kernel[j];\n    }\n\n    for (int i = -kSize; i <= kSize; ++i) {\n        col += kernel[kSize+i] * pow(\n                    texture(iChannel0, (fragCoord.xy+ vec2(0.0, float(i)) ) / iResolution.xy).rgb\n                  , vec3(GAMMA));\n    }\n    \n    col = pow(col / Z, vec3(1.0 / GAMMA));\n    float gray = dot(col, vec3(0.2126, 0.7152, 0.0722));\n    fragColor = vec4(vec3(gray), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/** \n * Canny Edge Detection by Ruofei Du (DuRuofei.com)\n * Step 2: Find the intensity gradients of the image\n * Link to demo: https://www.shadertoy.com/view/Xly3DV\n * starea @ ShaderToy, License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. \n *\n * Reference: \n * [1] Canny, J., A Computational Approach To Edge Detection, IEEE Trans. Pattern Analysis and Machine Intelligence, 8(6):679–698, 1986.\n * [2] Canny edge detector, Wikipedia. https://en.wikipedia.org/wiki/Canny_edge_detector\n *\n * Related & Better Implementation:\n * [1] stduhpf's Canny filter (3pass): https://www.shadertoy.com/view/MsyXzt\n **/\n#define A(X,Y) (tap(iChannel0,vec2(X,Y)))\nvec3 tap(sampler2D tex,vec2 xy) { return texture(tex,xy).xyz; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float dX = dFdx( texture(iChannel0, uv).r );\n    float dY = dFdy( texture(iChannel0, uv).r );\n    float magnitude = length(vec2(dX, dY)); \n    vec3 col = vec3(dX / magnitude, dY / magnitude, magnitude); \n\tfragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define A(X,Y) (tap(iChannel0,vec2(X,Y)))\nvec3 tap(sampler2D tex,vec2 xy) { return texture(tex,xy).xyz; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 dXdYMag = texture(iChannel0, uv).rgb;\n    \n    vec3 X = texture(iChannel0, uv + dXdYMag.xy ).rgb;\n    vec3 Y = texture(iChannel0, uv - dXdYMag.xy ).rgb;\n    \n    if (dXdYMag.z > 15.0 / 255.0 && dXdYMag.z > X.z && dXdYMag.z > Y.z) \n        fragColor = vec4(vec3(1.0), 1.0);\n    else\n\t    fragColor = vec4(vec3(0.0), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}