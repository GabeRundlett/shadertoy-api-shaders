{
    "Shader": {
        "info": {
            "date": "1609930702",
            "description": "Implementation of the triangle cut method for more closed-form importance sampling by Eric Heitz @Unity:\nhttps://eheitzresearch.wordpress.com/792-2/",
            "flags": 48,
            "hasliked": 0,
            "id": "WltcDj",
            "likes": 1,
            "name": "Triangle cut sampling",
            "published": 3,
            "tags": [
                "sampling"
            ],
            "usePreview": 0,
            "username": "webanck",
            "viewed": 306
        },
        "renderpass": [
            {
                "code": "/*\nShader by Antoine Webanck:\nhttps://webanck.fr/\n\nImplementation of the triangle cut method for more closed-form importance sampling by Eric Heitz @Unity:\nhttps://eheitzresearch.wordpress.com/792-2/\n\nInteractive keyboard controls:\n1-4: (disabled) toggle test cases with:\n  1: simple functions\n  2: truncated disk\n  4: torus\n  3: polar shape\nA: swap between 2D/alternative views depending on the test case\nSPACE: classical inverse CDF mapping\nD: (disabled) swap between standard/UV debug\nO: (disabled) swap between stretched orthogonal/orthonormal\nS: (disabled) swap between UV chessboard/UV samples (with distorsions in alternative views)\n*/\n\n/////////////////////////\n//INTERACTIVITY SWITCHS//\n/////////////////////////\n/*\nUncomment if needed but beware, INTERACTIVE_CASE is hard for Angle crosspiling on Windows!\nAs a result, the driver may crash trying to compile the shader.\nPrefer native OpenGL when possible, see here for more infos:\nhttps://shadertoyunofficial.wordpress.com/2016/07/22/compatibility-issues-in-shadertoy-webglsl/\n*/\n//#define INTERACTIVE_CASE\n#define INTERACTIVE_ALTERNATE_VISUALISATION\n#define INTERACTIVE_TRIANGLE_CUT\n//#define INTERACTIVE_DEBUG_UV_FIXPOINT\n//#define INTERACTIVE_ORTHONORMAL\n//#define INTERACTIVE_VISUALIZE_SAMPLES\n\n\n/////////////\n//CONSTANTS//\n/////////////\n//avoiding compiler unrolling nightmare\n//#define ZEROu uint(min(0, iFrame))\nconst uint ZEROu = 0u;\n\nconst vec3 WHITE = vec3(1.);\nconst vec3 BLACK = vec3(0.);\nconst vec3 GREY = vec3(0.5);\nconst vec3 RED = vec3(1., 0., 0.);\nconst vec3 GREEN = vec3(0., 1., 0.);\nconst vec3 BLUE = vec3(0., 0., 1.);\n\nconst float PI = 3.1415926535897932384626433832795;\n\n//Functions types.\nconst uint CONSTANT = 0u;\nconst uint LINEAR = 1u;\nconst uint QUADRATIC = 2u;\nconst uint DISK_AREA = 10u;\nconst uint DISK_AREA_APPROXIMATION = 11u;\nconst uint TORUS_AREA = 20u;\nconst uint TORUS_AREA_APPROXIMATION = 21u;\nconst uint POLAR_SHAPE_AREA = 30u;\nconst uint POLAR_SHAPE_AREA_APPROXIMATION = 31u;\n\n//Test cases types.\nconst uint SIMPLE_FUNCTIONS_CASE = 0u;\nconst uint TRUNCATED_DISK_CASE = 1u;\nconst uint TORUS_SURFACE_CASE = 2u;\nconst uint POLAR_SHAPE_CASE = 3u;\n\n\n//////////////\n//PARAMETERS//\n//////////////\n#ifndef INTERACTIVE_CASE\nconst\n#endif\nuint CASE = TORUS_SURFACE_CASE;\n\n#ifndef INTERACTIVE_ALTERNATE_VISUALISATION\nconst\n#endif\nbool ALTERNATIVE_VISUALISATION = false;\n\n#ifndef INTERACTIVE_TRIANGLE_CUT\nconst\n#endif\nbool TRIANGLE_CUT = true;\n\n#ifndef INTERACTIVE_ORTHONORMAL\nconst\n#endif\nbool ORTHONORMAL = false;\n\n#ifndef INTERACTIVE_DEBUG_UV_FIXPOINT\nconst\n#endif\nbool DEBUG_UV_FIXPOINT = false;\n\n#ifndef INTERACTIVE_VISUALIZE_SAMPLES\nconst\n#endif\nbool VISUALIZE_SAMPLES = false;\n\nconst uint GRID_SUBDIVISIONS = 8u;\nconst uint SAMPLES_NUMBER = 100u;\nconst float SAMPLES_RADIUS = 3.;\nconst uint SEARCH_SAMPLES = 25u;\n\nuint caseFunctions(const bool approximation)\n{\n\tswitch(CASE)\n\t{\n\t\tcase SIMPLE_FUNCTIONS_CASE: return (!approximation ? QUADRATIC : LINEAR);\n\t\tcase TRUNCATED_DISK_CASE: return (!approximation ? DISK_AREA : DISK_AREA_APPROXIMATION);\n\t\tcase TORUS_SURFACE_CASE: return (!approximation ? TORUS_AREA : TORUS_AREA_APPROXIMATION);\n\t\tcase POLAR_SHAPE_CASE: return (!approximation ? POLAR_SHAPE_AREA : POLAR_SHAPE_AREA_APPROXIMATION);\n\t}\n}\nuint caseFunction()\n{\n\treturn caseFunctions(false);\n}\nuint caseApproximateFunction()\n{\n\tconst bool APPROXIMATION = true;\n\treturn caseFunctions(APPROXIMATION);\n}\n\n\n///////////\n//SAMPLES//\n///////////\nvec3 randSeed = vec3(0.);\n//Hash functions by David Hoskins\nfloat hash13(vec3 p3)\n{\n\t#define HASHSCALE1 .1031\n\tp3  = fract(p3 * HASHSCALE1);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\nfloat uniformRand()\n{\n\trandSeed.y+=1.4675;\n\treturn hash13(randSeed);\n}\nvec2 getNextSample()\n{\n\tvec2 s;\n\ts.x = uniformRand();\n\ts.y = uniformRand();\n\treturn s;\n}\n\n\n//////////////\n//CASES WORK//\n//////////////\n\n//Simple Functions.\nconst bool DECREASING = true;\n\n//Truncated disk.\nconst float THETA_0 = 3./4.*PI;\nfloat diskArea(float theta)\n{\n\treturn theta - cos(theta)*sin(theta);\n}\nfloat diskAreaDerivative(float theta)\n{\n\treturn 2.*sin(theta)*sin(theta);\n}\nfloat diskAreaDerivativeDerivative(float theta)\n{\n\treturn 4.*sin(theta)*cos(theta);\n}\nfloat diskAreaApproximation(float theta)\n{\n\tif(theta <= 0.5*PI)\n\t\treturn theta*theta*theta/3.;\n\treturn PI*PI*PI/12. - (PI - theta)*(PI - theta)*(PI - theta)/3.;\n}\nfloat diskAreaApproximationDerivative(float theta)\n{\n\tif(theta <= 0.5*PI)\n\t\treturn theta*theta;\n\treturn (PI - theta)*(PI - theta);\n}\n\n//Torus surface.\nconst float TORUS_SKELETON_RADIUS = 1.;\nconst float TORUS_CIRCLE_RADIUS = 0.5;\nfloat torusAreaApproximationDerivative(const float theta)\n{\n\tfloat x = theta/PI;\n\tfloat cpr = TORUS_SKELETON_RADIUS + TORUS_CIRCLE_RADIUS;\n\tfloat cmr = TORUS_SKELETON_RADIUS - TORUS_CIRCLE_RADIUS;\n\treturn mix(cpr, cmr, x)/(TORUS_SKELETON_RADIUS*PI);\n}\nfloat torusAreaApproximation(const float theta)\n{\n\tfloat x = theta/PI;\n\tfloat cpr = TORUS_SKELETON_RADIUS + TORUS_CIRCLE_RADIUS;\n\treturn 1./(TORUS_SKELETON_RADIUS) * (cpr*x - TORUS_CIRCLE_RADIUS*x*x);\n}\nfloat sdTorus(const vec3 p, const vec2 t) //cf https://iquilezles.org/articles/distfunctions\n{\n\tvec2 q = vec2(length(p.xz) - t.x, p.y);\n\treturn length(q) - t.y;\n}\nbool sphereTraceTorus(const vec3 ro, const vec3 rd, out vec3 intersection)\n{\n\tintersection = vec3(0.);\n\tfloat t = 0.;\n\tfor(uint i = ZEROu; i < 100u; i++)\n\t{\n\t\tintersection = ro + t*rd;\n\t\tfloat sd = sdTorus(intersection, vec2(TORUS_SKELETON_RADIUS, TORUS_CIRCLE_RADIUS));\n\t\tif(sd <= 0.001) return true;\n\t\tt += sd;\n\t}\n\treturn false;\n}\n\n//Polar shape.\nfloat polarShapeRadius(const float theta)\n{\n\treturn 1. + cos(8.*theta)/8. + cos(16.*theta)/16.;\n}\nfloat polarShapeRadiusDerivative(const float theta)\n{\n\treturn -sin(8.*theta) - sin(16.*theta);\t\n}\nfloat polarShapeSquaredRadius(const float theta)\n{\n\tfloat c8 = cos(8.*theta);\n\tfloat c16 = cos(16.*theta);\n\treturn (256. + 64.*c8 + 32.*c16 + 4.*c8*c16 + 4.*c8*c8 + c16*c16)/256.;\n}\nfloat polarShapeDensity(const float theta)\n{\n\treturn 0.5 * polarShapeSquaredRadius(theta);\n}\nfloat polarShapeDensityDerivative(const float theta)\n{\n\treturn polarShapeRadiusDerivative(theta) * polarShapeRadius(theta);\n}\nfloat polarShapeArea(const float theta)\n{\n\tfloat s8 = sin(8.*theta);\n\tfloat s16 = sin(16.*theta);\n\tfloat s24 = sin(24.*theta);\n\tfloat s32 = sin(32.*theta);\n\treturn 0.5 * (49632.*theta + 1584.*s8 + 408.*s16 + 16.*s24 + 3.*s32)/49152.;\n}\n\n\n//////////////////////\n//FUNCTIONS WRAPPERS//\n//////////////////////\nfloat pdfMax(const uint type)\n{\n\tswitch(type)\n\t{\n\t\tcase CONSTANT: return 1.;\n\t\tcase LINEAR: return 2.;\n\t\tcase QUADRATIC: return 3.;\n\t\t\n\t\tcase DISK_AREA: return THETA_0 * 2./diskArea(THETA_0);\n\t\tcase DISK_AREA_APPROXIMATION: return THETA_0;\n\t\t\n\t\tcase TORUS_AREA: return PI * torusAreaApproximationDerivative(0.);\n\t\tcase TORUS_AREA_APPROXIMATION: return PI * torusAreaApproximationDerivative(0.);\n\t\t\n\t\tcase POLAR_SHAPE_AREA: return 2.*PI / polarShapeArea(2.*PI);\n\t\tcase POLAR_SHAPE_AREA_APPROXIMATION: return 1.;\n\t}\n\t\n\treturn 1.;\n}\n\nfloat pdf(const float x, const uint type)\n{\n\tswitch(CASE)\n\t{\n\t\tcase SIMPLE_FUNCTIONS_CASE:\n\t\t\tif(DECREASING) switch(type)\n\t\t\t{\n\t\t\t\tcase CONSTANT: return 1.;\n\t\t\t\tcase LINEAR: return 2.*(1. - x);\n\t\t\t\tcase QUADRATIC: return 3.*(1. - x)*(1. - x);\n\t\t\t}\n\t\t\tswitch(type)\n\t\t\t{\n\t\t\t\tcase CONSTANT: return 1.;\n\t\t\t\tcase LINEAR: return 2.*x;\n\t\t\t\tcase QUADRATIC: return 3.*x*x;\n\t\t\t}\n\t\tcase TRUNCATED_DISK_CASE:\n\t\t{\n\t\t\tfloat stretch = THETA_0;\n\t\t\tfloat theta = x * stretch;\n\t\t\tswitch(type)\n\t\t\t{\n\t\t\t\tcase DISK_AREA: return stretch * diskAreaDerivative(theta)/diskArea(THETA_0);\n\t\t\t\tcase DISK_AREA_APPROXIMATION: return stretch * diskAreaApproximationDerivative(theta)/diskAreaApproximation(THETA_0);\n\t\t\t}\n\t\t}\n\t\tcase TORUS_SURFACE_CASE:\n\t\t{\n\t\t\tfloat stretch = PI;\n\t\t\tfloat theta = x * stretch;\n\t\t\tswitch(type)\n\t\t\t{\n\t\t\t\tcase TORUS_AREA: return stretch * (TORUS_SKELETON_RADIUS + TORUS_CIRCLE_RADIUS*cos(theta))/(TORUS_SKELETON_RADIUS*PI);\n\t\t\t\tcase TORUS_AREA_APPROXIMATION: return stretch * torusAreaApproximationDerivative(theta)/torusAreaApproximation(PI);\n\t\t\t}\n\t\t}\n\t\tcase POLAR_SHAPE_CASE:\n\t\t{\n\t\t\tfloat stretch = 2.*PI;\n\t\t\tfloat theta = x * stretch;\n\t\t\tswitch(type)\n\t\t\t{\n\t\t\t\tcase POLAR_SHAPE_AREA: return stretch * polarShapeDensity(theta)/polarShapeArea(2.*PI);\n\t\t\t\tcase POLAR_SHAPE_AREA_APPROXIMATION: return 1.;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0.;\n}\nfloat derivative(const float x, const uint type)\n{\n\tswitch(CASE)\n\t{\n\t\tcase SIMPLE_FUNCTIONS_CASE:\n\t\t\tif(DECREASING) switch(type)\n\t\t\t{\n\t\t\t\tcase CONSTANT: return 0.;\n\t\t\t\tcase LINEAR: return -2.;\n\t\t\t\tcase QUADRATIC: return -6.*(1. - x);\n\t\t\t}\n\t\t\tswitch(type)\n\t\t\t{\n\t\t\t\tcase CONSTANT: return 0.;\n\t\t\t\tcase LINEAR: return 2.;\n\t\t\t\tcase QUADRATIC: return 6.*x;\n\t\t\t}\n\t\tcase TRUNCATED_DISK_CASE:\n\t\t{\n\t\t\tfloat stretch = THETA_0;\n\t\t\tfloat theta = x * stretch;\n\t\t\tswitch(type)\n\t\t\t{\n\t\t\t\tcase DISK_AREA: return stretch*stretch * diskAreaDerivativeDerivative(theta)/diskArea(THETA_0);\n\t\t\t\t//case DISK_AREA_APPROXIMATION:\n\t\t\t}\n\t\t}\n\t\tcase TORUS_SURFACE_CASE:\n\t\t{\n\t\t\tfloat stretch = PI;\n\t\t\tfloat theta = x * stretch;\n\t\t\tswitch(type)\n\t\t\t{\n\t\t\t\tcase TORUS_AREA: return stretch*stretch * -TORUS_CIRCLE_RADIUS*sin(theta)/(TORUS_SKELETON_RADIUS*PI);\n\t\t\t\t//case TORUS_AREA_APPROXIMATION:\n\t\t\t}\n\t\t}\n\t\tcase POLAR_SHAPE_CASE:\n\t\t{\n\t\t\tfloat stretch = 2.*PI;\n\t\t\tfloat theta = x * stretch;\n\t\t\tswitch(type)\n\t\t\t{\n\t\t\t\tcase POLAR_SHAPE_AREA: return stretch*stretch * polarShapeDensityDerivative(theta)/polarShapeArea(2.*PI);\n\t\t\t\t//case POLAR_SHAPE_AREA_APPROXIMATION:\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0.;\n}\nfloat cdf(const float x, const uint type)\n{\n\tswitch(CASE)\n\t{\n\t\tcase SIMPLE_FUNCTIONS_CASE:\n\t\t\tif(DECREASING) switch(type)\n\t\t\t{\n\t\t\t\tcase CONSTANT: return x;\n\t\t\t\tcase LINEAR: return x*(2. - x); //2.*x - x*x\n\t\t\t\tcase QUADRATIC: return x*(3. + x*(-3. + x)); //3.*x - 3.*x*x + x*x*x;\n\t\t\t}\n\t\t\tswitch(type)\n\t\t\t{\n\t\t\t\tcase CONSTANT: return x;\n\t\t\t\tcase LINEAR: return x*x;\n\t\t\t\tcase QUADRATIC: return x*x*x;\n\t\t\t}\n\t\tcase TRUNCATED_DISK_CASE:\n\t\t{\n\t\t\tfloat theta = x * THETA_0;\n\t\t\tswitch(type)\n\t\t\t{\n\t\t\t\tcase DISK_AREA: return diskArea(theta)/diskArea(THETA_0);\n\t\t\t\tcase DISK_AREA_APPROXIMATION: return diskAreaApproximation(theta)/diskAreaApproximation(THETA_0);\n\t\t\t}\n\t\t}\n\t\tcase TORUS_SURFACE_CASE:\n\t\t{\n\t\t\tfloat theta = x * PI;\n\t\t\tswitch(type)\n\t\t\t{\n\t\t\t\tcase TORUS_AREA: return (TORUS_SKELETON_RADIUS*theta + TORUS_CIRCLE_RADIUS*sin(theta))/(TORUS_SKELETON_RADIUS*PI);\n\t\t\t\tcase TORUS_AREA_APPROXIMATION: return torusAreaApproximation(theta);\n\t\t\t}\n\t\t}\n\t\tcase POLAR_SHAPE_CASE:\n\t\t{\n\t\t\tfloat theta = x * 2.*PI;\n\t\t\tswitch(type)\n\t\t\t{\n\t\t\t\tcase POLAR_SHAPE_AREA: return polarShapeArea(theta)/polarShapeArea(2.*PI);\n\t\t\t\tcase POLAR_SHAPE_AREA_APPROXIMATION: return x;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0.;\n}\nfloat inverse_cdf(const float u, const uint type)\n{\n\tswitch(CASE)\n\t{\n\t\tcase SIMPLE_FUNCTIONS_CASE:\n\t\t\tif(DECREASING) switch(type)\n\t\t\t{\n\t\t\t\tcase CONSTANT: return u;\n\t\t\t\tcase LINEAR: return 1. - sqrt(1. - u);\n\t\t\t\tcase QUADRATIC: return 1. - pow(1. - u, 1./3.);\n\t\t\t}\n\t\t\tswitch(type)\n\t\t\t{\n\t\t\t\tcase CONSTANT: return u;\n\t\t\t\tcase LINEAR: return sqrt(u);\n\t\t\t\tcase QUADRATIC: return pow(u, 1./3.);\n\t\t\t}\n\t\tcase TRUNCATED_DISK_CASE:\n\t\t\tswitch(type)\n\t\t\t{\n\t\t\t\t//case DISK_AREA:\n\t\t\t\tcase DISK_AREA_APPROXIMATION:\n\t\t\t\t{\n\t\t\t\t\tfloat theta;\n\t\t\t\t\tif(u < diskAreaApproximation(0.5*PI)/diskAreaApproximation(THETA_0))\n\t\t\t\t\t\ttheta = pow(3.*u*diskAreaApproximation(THETA_0), 1./3.);\n\t\t\t\t\telse\n\t\t\t\t\t\ttheta = PI - pow(0.25*PI*PI*PI - 3.*u*diskAreaApproximation(THETA_0), 1./3.);\n\t\t\t\t\treturn theta/THETA_0;\n\t\t\t\t}\n\t\t\t}\n\t\tcase POLAR_SHAPE_CASE:\n\t\t{\n\t\t\tswitch(type)\n\t\t\t{\n\t\t\t\t//case POLAR_SHAPE_AREA:\n\t\t\t\tcase POLAR_SHAPE_AREA_APPROXIMATION: return u;\n\t\t\t}\n\t\t}\n\t\tcase TORUS_SURFACE_CASE:\n\t\tswitch(type)\n\t\t{\n\t\t\t//case TORUS_AREA:\n\t\t\tcase TORUS_AREA_APPROXIMATION:\n\t\t\t{\n\t\t\t\tfloat cpr = TORUS_SKELETON_RADIUS + TORUS_CIRCLE_RADIUS;\n\t\t\t\tfloat cmr = TORUS_SKELETON_RADIUS - TORUS_CIRCLE_RADIUS;\n\t\t\t\treturn -0.5/TORUS_CIRCLE_RADIUS * (sqrt(cpr*cpr + u*(cmr*cmr - cpr*cpr)) - cpr);\n\t\t\t}\n\t\t}\n\t}\n\n\t//Binary search fallback.\n\tvec2 I = vec2(0., 1.);\n\tfor(uint i = ZEROu; i < SEARCH_SAMPLES; i++)\n\t{\n\t\tfloat x = 0.5 *(I[0] + I[1]);\n\t\tfloat uCandidate = cdf(x, type);\n\t\tif(uCandidate < u)\n\t\t\tI = vec2(x, I[1]);\n\t\telse\n\t\t\tI = vec2(I[0], x);\n\n\t\tif(I[1] - I[0] < 0.00001) break;\n\t}\n\n\treturn 0.5 *(I[0] + I[1]);\n}\n\n\n////////////////\n//TRIANGLE CUT//\n////////////////\n\n//Wrappers.\nfloat f(const float x)\n{\n\treturn pdf(x, caseFunction());\n}\nfloat F(const float x)\n{\n\treturn cdf(x, caseFunction());\n}\nfloat iF(const float u)\n{\n\treturn inverse_cdf(u, caseFunction());\n}\nfloat df(const float x)\n{\n\treturn derivative(x, caseFunction());\n}\nfloat g(const float x)\n{\n\treturn pdf(x, caseApproximateFunction());\n}\nfloat G(const float x)\n{\n\treturn cdf(x, caseApproximateFunction());\n}\nfloat iG(const float u)\n{\n\treturn inverse_cdf(u, caseApproximateFunction());\n}\n\n//Classical CDF parameterization.\nvec2 inverse_cdf_param(const vec2 uv)\n{\n\tfloat x = iF(uv[0]);\n\treturn vec2(x, uv[1]*f(x)); \n}\nvec2 cdf_param(const vec2 xy)\n{\n\treturn vec2(F(xy[0]), xy[1]/f(xy[0]));\n}\n\t\n//Triangle cut parameterization.\nvec2 trianglecut_param(const vec2 uv, out bool error)\n{\n\t// sample x_a with approximate PDF, Eq. (7)\n\tfloat x_a = iG(uv[0]);\n\t// eval functions at x_a\n\tfloat f_x_a = f(x_a);\n\tfloat F_x_a = F(x_a);\n\tfloat fprime_x_a = df(x_a);\n\tfloat y_a = f_x_a;\n\tfloat g_x_a = g(x_a);\n\t// compute x_b with triangle cut, Eq. (9)\n\tfloat x_b = x_a + 2.*(uv[0] - F_x_a)/f_x_a;\n\tfloat y_b = 0.;\n\t// compute infinitesimal thicknesses, Eq. (19) and (20)\n\tfloat w_a = f_x_a*f_x_a + 2.*(uv[0] - F_x_a)*fprime_x_a;\n\tfloat w_b = 2.*f_x_a*g_x_a - w_a;\n\t// sample thickness density, Eq. (22)\n\tfloat t = uv[1] * (w_a + w_b)/(w_b + sqrt(mix(w_b*w_b, w_a*w_a, uv[1]))); //t = iW(v)\n\t// interpolate (x_a,y_a) and (x_b,y_b), Eq. (23)\n\tvec2 xy = mix(vec2(x_b, y_b), vec2(x_a, y_a), t);\n\t\n\t//checking for conditions 1 and 2, Eq. (24) and (25)\n\tif(xy[1] > f(xy[0]) || w_a < 0. || w_b < 0.)\n\t{\n\t\terror = true;\n\t\treturn vec2(0.);\n\t}\n\terror = false;\n\treturn xy;\n}\n\n//Reversing the triangle cut parameterization.\nfloat eval_u_orientedArea(const vec2 xy, const float u)\n{\n\tconst float v = 1.;\n\t\t\n\t// sample x_a with approximate PDF, Eq. (7)\n\tfloat x_a = iG(u);\n\t// eval functions at x_a\n\tfloat f_x_a = f(x_a);\n\tfloat F_x_a = F(x_a);\n\t//float fprime_x_a = df(x_a);\n\tfloat y_a = f_x_a;\n\t//float g_x_a = g(x_a);\n\t// compute x_b with triangle cut, Eq. (9)\n\tfloat x_b = x_a + 2. * (u - F_x_a)/f_x_a;\n\tfloat y_b = 0.;\n\n\tvec2 a = vec2(x_a, y_a);\n\tvec2 b = vec2(x_b, y_b);\n\tvec2 ba = a - b;\n\tvec2 bp = xy - b;\n\n\tvec3 crossProduct = cross(vec3(ba, 0.), vec3(bp, 0.));\n\tfloat orientedArea = crossProduct.z;//length(crossProduct) * (crossProduct.z > 0. ? 1. : -1.);\n\t\n\treturn orientedArea;\n}\nfloat eval_u_binsearch(const vec2 xy)\n{\n\tvec2 I = vec2(0., 1.);\n\t\n\tfor(uint i = ZEROu; i < SEARCH_SAMPLES; i++)\n\t{\n\t\tfloat u = 0.5*(I[0] + I[1]);\n\t\tif(eval_u_orientedArea(xy, u) < 0.)\n\t\t\tI = vec2(u, I[1]);\n\t\telse\n\t\t\tI = vec2(I[0], u);\n\t\tif(I[1] - I[0] < 0.00001) break;\n\t}\n\t\n\treturn 0.5*(I[0] + I[1]);\n}\nvec2 inverse_trianglecut_param(const vec2 xy)\n{\n\tfloat u = eval_u_binsearch(xy);\n\t\n\tfloat x_a = iG(u);\n\t// eval functions at x_a\n\tfloat f_x_a = f(x_a);\n\tfloat F_x_a = F(x_a);\n\tfloat fprime_x_a = df(x_a);\n\tfloat y_a = f_x_a;\n\tfloat g_x_a = g(x_a);\n\t// compute x_b with triangle cut, Eq. (9)\n\tfloat x_b = x_a + 2. * (u - F_x_a)/f_x_a;\n\tfloat y_b = 0.;\n\t// compute infinitesimal thicknesses, Eq. (19) and (20)\n\tfloat w_a = f_x_a*f_x_a + 2. * (u - F_x_a) * fprime_x_a;\n\tfloat w_b = 2. * f_x_a * g_x_a - w_a;\n\t\n\tif(y_a == 0.) return vec2(u, 0.);\n\tfloat t = xy[1]/y_a;\n\tfloat v = (2.*w_b*t +(w_a - w_b)*t*t)/(w_a + w_b);\n\t\n\treturn vec2(u, v);\n}\n\n//Parameterization wrappers.\nvec2 parameterization(const vec2 uv, out bool error)\n{\n\terror = false;\n\t\n\tif(TRIANGLE_CUT) return trianglecut_param(uv, error);\n\treturn inverse_cdf_param(uv);\n}\nvec2 inverseParameterization(const vec2 xy)\n{\n\tif(TRIANGLE_CUT) return inverse_trianglecut_param(xy);\n\treturn cdf_param(xy);\n}\n\n\n/////////////\n//INTERFACE//\n/////////////\nvec2 fragCoordToScreenUV(const vec2 fragCoord)\n{\n\tif(ORTHONORMAL)\n\t\treturn fragCoord/iResolution.y;\n\telse\n\t\treturn fragCoord/iResolution.xy;\n}\nvec2 screenUVToXY(const vec2 screenUV)\n{\n\tif(ORTHONORMAL)\n\t\treturn screenUV*vec2(max(1., max(pdfMax(caseFunction()), pdfMax(caseApproximateFunction()))));\n\telse\n\t\treturn screenUV*vec2(1., max(pdfMax(caseFunction()), pdfMax(caseApproximateFunction())));\n}\nvec2 xyToFragCoord(const vec2 xy)\n{\n\tif(ORTHONORMAL)\n\t\treturn xy/vec2(max(1., max(pdfMax(caseFunction()), pdfMax(caseApproximateFunction()))))*iResolution.y;\n\telse\n\t\treturn xy/vec2(1., max(pdfMax(caseFunction()), pdfMax(caseApproximateFunction())))*iResolution.xy;\n}\n\nbool isValidUV(const vec2 uv)\n{\n\treturn all(greaterThanEqual(uv, vec2(0.))) && all(lessThanEqual(uv, vec2(1.)));\n}\nbool isBorderUV(const vec2 uv)\n{\n\treturn any(lessThan(abs(vec4(uv, uv - vec2(1.))), vec4(0.005)));\n}\nfloat isSampleUV(const vec2 uv)\n{\n\tfloat r = 0.;\n\t\n\t//In uv space.\n\t//float samplesRadius = SAMPLES_RADIUS/iResolution.y;\n\t//for(uint i = ZEROu; i < SAMPLES_NUMBER; i++)\n\t//{\n\t//\tvec2 v = uv - getNextSample();\n\t//\tfloat d2 = dot(v, v);\n\t//\t//if(d2 < samplesRadius*samplesRadius)\n\t//\t\t//return 1.;\n\t//\tr = max(r, smoothstep(samplesRadius*samplesRadius, 0., d2));\n\t//}\n\t\n\t//In screenspace.\n\tbool b;\n\tvec2 screenUV = xyToFragCoord(parameterization(uv, b));\n\tfor(uint i = ZEROu; i < SAMPLES_NUMBER; i++)\n\t{\n\t\tvec2 p = xyToFragCoord(parameterization(getNextSample(), b));\n\t\tvec2 v = screenUV - p;\n\t\tfloat d2 = dot(v, v);\n\t\t//if(d2 < SAMPLES_RADIUS*SAMPLES_RADIUS)\n\t\t\t//return 1.;\n\t\tr = max(r, smoothstep(SAMPLES_RADIUS*SAMPLES_RADIUS, 0., d2));\n\t}\n\t\n\treturn r;\n}\nvec3 uvColor(const vec2 uv)\n{\n\tif(!isValidUV(uv)) return RED;\n\n\tif(VISUALIZE_SAMPLES) return mix(WHITE, BLACK, isSampleUV(uv));\n\t\n\tuvec2 ij = uvec2(uv * float(GRID_SUBDIVISIONS));\n\tuint id = ij[0]*GRID_SUBDIVISIONS + ij[1];\n\t\n\t//Chessboard.\n\treturn ((id + ij[0]) % 2u == 0u ? WHITE : BLACK);\n}\nvec3 uvFixpointColor(const vec2 uv)\n{\n\tbool error = false;\n\tvec2 uvOut = inverseParameterization(parameterization(uv, error));\n\n\tif(error) return RED;\n\t\n\treturn uvColor(uvOut);\n}\nvoid initCamera(const vec2 screenUV, out vec3 ro, out vec3 rd)\n{\n\t// towards -Z\n\tro = vec3(0., 0., 1.);\n\tvec2 q = screenUV - 0.5;\n\trd = normalize(vec3(q, 0.) - ro);\n\n\tfloat a = 0.2;\n\tfloat b = -0.2;\n\tif(iMouse.xy != vec2(0.))\n\t{\n\t\tvec2 m = iMouse.xy/iResolution.xy - .5;\n\t\ta = m.x*PI*2.;\n\t\tb = m.y*PI;\n\t}\n\tvec3 camera = vec3(cos(b)*sin(a), sin(b), cos(b)*cos(a));\n\t//Z vector\n\tvec3 up = normalize(cross(cross(camera, vec3(0., 1., 0.)), camera));\n\t//Y vector\n\tvec3 x = normalize(cross(up, camera));\n\tmat3 view = mat3(x, up, camera);\n\n\tro = camera*4.;\n\trd = view*rd;\n}\nvec3 alternativeVisualisationColor(const vec2 screenUV)\n{\n\tswitch(CASE)\n\t{\n\t\t//case SIMPLE_FUNCTIONS_CASE:\n\t\tcase TRUNCATED_DISK_CASE:\n\t\t{\n\t\t\tvec2 xy = 2.*(screenUV - vec2(0.5));\n\t\t\t\n\t\t\tfloat r = length(xy);\n\t\t\tif(r > 1.) return GREY;\n\t\t\t\n\t\t\tfloat theta = 0.5*PI + asin(xy.x);\n\t\t\tif(theta > THETA_0) return GREY;\n\t\t\t\n\t\t\tfloat w = 0.5*(xy.y/sin(theta) + 1.);\n\t\t\tfloat wTilde = w * f(theta/THETA_0);\n\t\t\t\n\t\t\tvec2 p = vec2(theta/THETA_0, wTilde);\n\t\t\tvec2 uv = inverseParameterization(p);\n\t\t\treturn uvColor(uv);\n\t\t}\n\t\tcase TORUS_SURFACE_CASE:\n\t\t{\n\t\t\tvec3 ro;\n\t\t\tvec3 rd;\n\t\t\tinitCamera(screenUV, ro, rd);\n\t\t\t\n\t\t\tvec3 intersection;\n\t\t\tif(!sphereTraceTorus(ro, rd, intersection)) return GREY;\n\t\t\t\n\t\t\tfloat theta = atan(intersection.y, length(intersection.xz) - TORUS_SKELETON_RADIUS);\n\t\t\tfloat phi = PI + atan(intersection.z, intersection.x);\n\t\t\tfloat w = 0.5*phi/PI;\n\t\t\tfloat wTilde = w * f(theta/PI);\n\t\t\t\n\t\t\tfloat symTheta = abs(theta);\n\t\t\tvec2 uv = inverseParameterization(vec2(symTheta/PI, wTilde));\n        \n\t\t\tif(theta >= 0.)\n\t\t\t\tuv.x *= 0.5;\n\t\t\telse\n\t\t\t\tuv.x = 1. - 0.5*uv.x;\n\t\t\treturn uvColor(uv);\n\t\t}\n\t\tcase POLAR_SHAPE_CASE:\n\t\t{\n\t\t\tvec2 xy = 2.5*(screenUV - vec2(0.5));\n\t\t\t\n\t\t\tfloat r = length(xy);\n\t\t\tfloat theta = mod(atan(xy.y, xy.x), 2.*PI);\n\t\t\tif(r > polarShapeRadius(theta)) return GREY;\n\t\t\t\n\t\t\tfloat rMax = polarShapeRadius(theta);\n\t\t\tfloat w = r*r/(rMax*rMax);\n\t\t\tfloat wTilde = w * f(0.5*theta/PI);\n\t\t\t\n\t\t\tvec2 p = vec2(0.5*theta/PI, wTilde);\n\t\t\tvec2 uv = inverseParameterization(p);\n\t\t\treturn uvColor(uv);\n\t\t}\n\t}\n\t\t\n\treturn GREY;\n}\nvec3 graphColor(const vec2 fragCoord)\n{\n\t// Normalized pixel coordinates (from 0 to 1)\n\tvec2 screenUV = fragCoordToScreenUV(fragCoord);\n\t\n\tif(any(greaterThan(screenUV, vec2(1.)))) return GREY;\n\t\n\t//Visualizing fixpoint error on UV grid.\n\tif(DEBUG_UV_FIXPOINT) return uvFixpointColor(screenUV);\n\t\n\t//Alternative visualization.\n\tif(ALTERNATIVE_VISUALISATION) return alternativeVisualisationColor(screenUV);\n\t\n\tvec2 xy = screenUVToXY(screenUV);\n\n\t//Right background.\n\tif(xy.x > 1.) return GREY;\n\t\n\t//Printing g in green (or f in case of inverse CDF mapping).\n\tif(TRIANGLE_CUT && abs(g(xy.x) - xy.y) <= 0.005 || !TRIANGLE_CUT && abs(f(xy.x) - xy.y) <= 0.005)\n\t\treturn GREEN;\n\t\n\t//Printing background in grey.\n\tif(f(xy[0]) < xy[1]) return GREY;\n\t\n\t//Printing mapped UV.\n\tvec2 uv = inverseParameterization(xy);\n\n\tbool error = false;\n\tparameterization(uv, error);\n\tif(error) return RED;\n\t\n\treturn uvColor(uv);\n}\n\nconst uint KEY_SPACE = 32u;\nconst uint KEY_ALT = 18u;\nconst uint KEY_A = 65u;\nconst uint KEY_D = 68u;\nconst uint KEY_O = 79u;\nconst uint KEY_S = 83u;\nvoid interactiveInit(const vec2 fragCoord)\n{\n#ifdef INTERACTIVE_CASE\n\t//Test case according to keys \"1\" to \"4\".\n\tCASE = uint(texelFetch(iChannel1, ivec2(fragCoord), 0).x);\n#endif\n#ifdef INTERACTIVE_ALTERNATE_VISUALISATION\n\t//Alternative visualization according to key \"A\".\n\tALTERNATIVE_VISUALISATION = (texelFetch(iChannel0, ivec2(KEY_A, 2), 0).x == 1. ? !ALTERNATIVE_VISUALISATION : ALTERNATIVE_VISUALISATION);\n#endif\n#ifdef INTERACTIVE_TRIANGLE_CUT\n\t//Mapping method according to space bar.\n\tTRIANGLE_CUT = (texelFetch(iChannel0, ivec2(KEY_SPACE, 0), 0).x == 1. ? !TRIANGLE_CUT : TRIANGLE_CUT);\n#endif\n\n#ifdef INTERACTIVE_DEBUG_UV_FIXPOINT\n\t//Debug mode according to key \"D\".\n\tDEBUG_UV_FIXPOINT = (texelFetch(iChannel0, ivec2(KEY_D, 2), 0).x == 1. ? !DEBUG_UV_FIXPOINT : DEBUG_UV_FIXPOINT);\n#endif\n\n#ifdef INTERACTIVE_ORTHONORMAL\n\t//Orthonormal mode according to key \"O\".\n\tORTHONORMAL = (texelFetch(iChannel0, ivec2(KEY_O, 2), 0).x == 1. ? !ORTHONORMAL : ORTHONORMAL);\n#endif\n\n#ifdef INTERACTIVE_VISUALIZE_SAMPLES\n\t//Samples visualization according to key \"S\".\n\tVISUALIZE_SAMPLES = (texelFetch(iChannel0, ivec2(KEY_S, 2), 0).x == 1. ? !VISUALIZE_SAMPLES : VISUALIZE_SAMPLES);\n#endif\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n\tinteractiveInit(fragCoord);\n\t\n\tvec3 color = graphColor(fragCoord);\n\t\n\t// Output to screen\n\tfragColor = vec4(color, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Storing test case state according to last pressed key in \"1\" to \"4\".\n\nconst uint KEY_1 = 49u;\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    uint newCase = uint(texelFetch(iChannel1, ivec2(fragCoord), 0).x);\n    for(uint i = 0u; i < 4u; i++)\n    {\n        if(texelFetch(iChannel0, ivec2(KEY_1 + i, 1), 0).x > 0.)\n        {\n            newCase = i;\n            break;\n        }\n    }\n    fragColor = vec4(float(newCase), 0., 1., 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}