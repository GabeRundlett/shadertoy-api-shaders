{
    "Shader": {
        "info": {
            "date": "1597035263",
            "description": "blah",
            "flags": 32,
            "hasliked": 0,
            "id": "WssXDM",
            "likes": 1,
            "name": "Gunbara_ripple1",
            "published": 3,
            "tags": [
                "test",
                "gunbara"
            ],
            "usePreview": 0,
            "username": "Gunbara",
            "viewed": 260
        },
        "renderpass": [
            {
                "code": "// Metadata I gave to shadertoy.com\n//\tName: Gunbara_ripple1\n//\tTags: Gunbara, test\n//\tDescription: blah\n//\n// Formatting note:\n//\tWhitespace regex: \"/\t|([\t ]+$)/\"\n\n// See:\n//\thttps://vvvv.org/documentation/wave-simulation\n//\thttp://www.falstad.com/ripple/\n//\thttp://developer.download.nvidia.com/books/HTML/gpugems/gpugems_ch08.html\n//\thttps://bitbucket.org/timday/qtlab/src/5fec2348003d2935cc6cc767abaa5ea211a9d738/experiment/waves-qml-shader/waves.qml?at=default&fileviewer=file-view-default\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t// Color scheme: linear mapping\n/*\t{\n\t\tfloat intensity = curHeight(fragCoord);\n\t\tfragColor = vec4(intensity*0.5 + 0.5);\n\t} // */\n\n\t// Color scheme: logarithmic mapping\n\t{\n\t\t// Semi arbitrary values that look good\n\t\tconst float minLogRange = -8.0;\n\t\tconst float maxLogRange =  1.0;\n\t\tconst float lowestNonZero = 0.0; //exp2(minLogRange);\n\t\tfloat intensity =\n\t\t\t(\n\t\t\t\tlog2(\n\t\t\t\t\tabs(curHeight(fragCoord)) + lowestNonZero\n\t\t\t\t) - minLogRange\n\t\t\t)\n\t\t\t/ (maxLogRange-minLogRange)\n\t\t;\n\t\t//fragColor = vec4(intensity);\n\t\tif (curHeight(fragCoord) > 0.0) {  // we used absolute value in the log2(), show the original sign\n\t\t\tfragColor = intensity * vec4(1.0, 0.0, 1.0, 1.0);\n\t\t} else {\n\t\t\tfragColor = intensity * vec4(0.0, 1.0, 0.0, 1.0);\n\t\t}\n\t} // */\n\n\t// Color scheme check: highlight aliasing (out of range values) in final output image\n/*\t{\n\t\tfragColor.g =\n\t\t\t0.5*step(0.0,\n\t\t\t\tmin(min(fragColor.r, fragColor.g), fragColor.b)\n\t\t\t) +\n\t\t\t0.5*step(1.0,\n\t\t\t\tmax(max(fragColor.r, fragColor.g), fragColor.b)\n\t\t\t)\n\t\t;\n\t\t\t//fragColor.rb = vec2(0.0);\n\t} // */\n\n\t// Draw the wall\n\tif (isInside_doubleSlitWall(iResolution.xy, fragCoord)) {\n\t\tfragColor = vec4(1.0, 0.0, 1.0, 1.0);\n\t}\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t#define nextCurHeight fragColor.r\n\t#define nextLastHeight fragColor.g\n\n\t// Just save a copy of the previous height\n\tnextLastHeight = curHeight(fragCoord);\n\n\n\t////////////////////////////////////////\n\t// Initial values\n\t////////////////////////////////////////\n\n\tif (isFirstFrame) {\n\t\tnextCurHeight\n\t\t\t= 0.0\n\t\t\t\t//Shadertoy note: pixel coordinate = fragCoord-vec2(0.5)\n\t\t\t//\t+ 1.0*step(length(fragCoord - vec2(0.5, 0.5)), 0.99)  // single pixel at position 0,0\n\t\t\t//\t+ 1.0*step(length(fragCoord - vec2(3.5, 3.5)), 0.99)  // single pixel at position 3,3\n\t\t\t//\t+ 1.0*step(length(fragCoord - vec2(10.0, 5.0)), 1.00)  // small circle at position 9.5,4.5\n\t\t\t//\t+ 1.0*step(length(fragCoord - vec2(50.5, 30.5)), 3.00)\n\t\t\t\t+ 1.0*step(length(fragCoord - vec2(200.0, 100.0)), 10.00)\n\t\t\t\t\t+ -1.0*step(length(fragCoord - vec2(iResolution.x-200.0, 100.0)), 10.00)\n\t\t\t//\t+ 1.0*step(length(fragCoord - vec2(400.0, 200.0)), 50.00)\n\t\t;\n\t\tnextLastHeight = nextCurHeight;\n\t\treturn;\n\t}\n\n\n\t////////////////////////////////////////////////////////////\n\n\tconst float dampening = 1e-3; //1.0/32.0; //1e-2; // semi-arbitrary value, range = [0,1)\n\n\n\t////////////////////////////////////////\n\t// Blur\n\t////////////////////////////////////////\n\n/*\tnextCurHeight = (\n\t\t(\n\t\t\t+ curHeight(fragCoord + vec2(-1.0,  0.0))\n\t\t\t+ curHeight(fragCoord + vec2( 1.0,  0.0))\n\t\t\t+ curHeight(fragCoord + vec2( 0.0, -1.0))\n\t\t\t+ curHeight(fragCoord + vec2( 0.0,  1.0))\n\t\t) / 4.0\n\t) * (1.0-dampening); // */\n\n\n\t////////////////////////////////////////\n\t// Ripple\n\t////////////////////////////////////////\n\n\t////////////////////\n\n\t// Ripple (orig long lost algo from my high school days)\n/*\tnextCurHeight = (\n\t\t+ (\n\t\t\t+ curHeight(fragCoord + vec2(-1.0,  0.0))\n\t\t\t+ curHeight(fragCoord + vec2( 1.0,  0.0))\n\t\t\t+ curHeight(fragCoord + vec2( 0.0, -1.0))\n\t\t\t+ curHeight(fragCoord + vec2( 0.0,  1.0))\n\t\t) / 2.0\n\t\t- lastHeight(fragCoord + vec2( 0.0,  0.0))\n\t) * (1.0-dampening); // */\n\n\n\t////////////////////\n\n\t// Ripple (old 2019-03-05 - each color channel got it's own blur & wave height calcs)\n\tfloat directionToStaticEquilibrium = (\n\t\t+ curHeight(fragCoord + vec2(-1.0,  0.0))\n\t\t+ curHeight(fragCoord + vec2( 1.0,  0.0))\n\t\t+ curHeight(fragCoord + vec2( 0.0, -1.0))\n\t\t+ curHeight(fragCoord + vec2( 0.0,  1.0))\n\t) / 4.0\n\t- curHeight(fragCoord + vec2( 0.0,  0.0))\n\t;\n\tfloat curVelocity =\n\t\t+ curHeight (fragCoord + vec2( 0.0,  0.0))\n\t\t- lastHeight(fragCoord + vec2( 0.0,  0.0))\n\t;\n\tnextCurHeight = (\n\t\t+ curHeight (fragCoord + vec2( 0.0,  0.0))  // current position\n\t\t+ (1.0-0.01-0.0*dampening)* curVelocity  // velocity\n\t\t+ (1.0-0.00-0.0*dampening)* directionToStaticEquilibrium  // acceleration\n\t) ; //* (1.0-dampening); // */\n\n\n\t////////////////////\n\t// \"Solid\" objects\n\t////////////////////\n\n\t// Solid object (double slit)\n\tif (isInside_doubleSlitWall(iResolution.xy, fragCoord)) {\n\t\tnextCurHeight = 0.0;\n\t}\n\n\n\t////////////////////////////////////////////////////////////\n\n\t////////////////////////////////////////\n\t// Mouse clicks\n\t////////////////////////////////////////\n\n\tif (mouseButton1bool && (length(iMouse.xy-fragCoord) < 5.0)) {\n\t\t// old 2019-03-05 - each color channel got it's own blur & wave height calcs\n\t\t//fragColor = vec4(0.0, 1.0, -1.0, 1.0);\n\n\t\tnextCurHeight = (\n\t\t\t//1.0\n\t\t\t//step(fract(iTime*5.0), 0.5)\n\t\t\tstep(fract(float(iFrame)/20.0), 0.5)\n/* TODO - this works but is flakey\t\t\tstep(fract(\n\t\t\t\tiTime / (0.4 + 1.6 * fract(iTime/10.0))\n\t\t\t), 0.5)  // a \"chirp\" - PWM oscillator whose frequency changes linearly with time */\n\t\t)*2.0-1.0;\n\n\t\t//nextLastHeight = nextCurHeight;\n\t}\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "////////////////////////////////////////\n// Behavior controls\n////////////////////////////////////////\n\n////////////////////////////////////////\n// Names for buffers & channels\n////////////////////////////////////////\n\n//#define D_channelVal(D_channel, D_pos) texture(D_channel, (D_pos)/iResolution.xy)\n//\t#define D_channelVal(D_channel, D_pos) texture(D_channel, mod(D_pos,iResolution.xy)/iResolution.xy)\n\t// ^ This is the same as above (without the mod()) when the channel's \"wrap\" parameter is set to \"repeat\" in each area\n\t//\t(shadertoy.com was defaulting to \"clamp\" for renderbuffers)\n#define D_channelVal(D_channel, D_pos) texelFetch(D_channel, ivec2(mod(D_pos,iResolution.xy)), 0)\n\n#define curHeight(D_pos)  D_channelVal(iChannel0, D_pos).r\n#define lastHeight(D_pos) D_channelVal(iChannel0, D_pos).g  // stored in same buffer as curHeight()\n\n\n\t////////////////////\n\t// buffer render buffer ordering tests\n\t////////////////////\n\n\t// using a different buffer than curHeight() seems to cause some weird artifacts\n\t//#define lastHeight(D_pos) D_channelVal(iChannel1, D_pos).r\n\n\t// looks like those artifacts are indeed caused by lastHeight(...) being set to current instead of previous values\n\t//\t-> artifacts can be perfectly reproduced with this:\n\t//\t#define lastHeight(D_pos) curHeight(D_pos)\n\n\n////////////////////////////////////////\n// General Shadertoy macros\n////////////////////////////////////////\n\n#define isFirstFrame (iFrame == 0)\n\n// iMouse.z seem to return a random but positive number if the button is pressed\n#define mouseButton1 step(0.0, iMouse.z)\n#define mouseButton2 step(0.0, iMouse.w)\n#define mouseButton1bool (mouseButton1 == 1.0)\n#define mouseButton2bool (mouseButton2 == 1.0)\n\n\n////////////////////////////////////////\n// Utils\n////////////////////////////////////////\n\nbool isInside_doubleSlitWall(\n\tvec2 iResolution,  // grr - Shadertoy doesn't make this available as a global var for things in the common code\n\tvec2 fragCoord\n) {\n\tif ((iResolution.x*0.5-0.0 < fragCoord.x) && (fragCoord.x < iResolution.x*0.5+1.0)\n\t\t&& (false\n\t\t\t\t// 2 holes - 4 pixels wide and 4 pixels apart\n\t\t\t|| (iResolution.y*0.0+0.0 < fragCoord.y) && (fragCoord.y < iResolution.y*0.5-9.0)\n\t\t\t|| (iResolution.y*0.5-3.0 < fragCoord.y) && (fragCoord.y < iResolution.y*0.5+3.0)\n\t\t\t|| (iResolution.y*0.5+9.0 < fragCoord.y) && (fragCoord.y < iResolution.y*1.0-0.0) // */\n\n\t\t\t\t// 4 holes - 2 pixels wide and 2 pixels apart\n\t\t\t/*|| (iResolution.y*0.0+0.0 < fragCoord.y) && (fragCoord.y < iResolution.y*0.5-7.0)\n\t\t\t|| (iResolution.y*0.5-5.0 < fragCoord.y) && (fragCoord.y < iResolution.y*0.5-3.0)\n\t\t\t|| (iResolution.y*0.5-1.0 < fragCoord.y) && (fragCoord.y < iResolution.y*0.5+1.0)\n\t\t\t|| (iResolution.y*0.5+3.0 < fragCoord.y) && (fragCoord.y < iResolution.y*0.5+5.0)\n\t\t\t|| (iResolution.y*0.5+7.0 < fragCoord.y) && (fragCoord.y < iResolution.y*1.0-0.0) // */\n\t\t)\n\t) {\n\t\treturn true;\n\t}\n\treturn false;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}