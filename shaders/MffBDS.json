{
    "Shader": {
        "info": {
            "date": "1725049692",
            "description": "machine motion via heat transfer",
            "flags": 48,
            "hasliked": 0,
            "id": "MffBDS",
            "likes": 15,
            "name": "SteamEngine_Sim",
            "published": 3,
            "tags": [
                "steamenginesimulator"
            ],
            "usePreview": 0,
            "username": "kosalos",
            "viewed": 118
        },
        "renderpass": [
            {
                "code": "// -------------------------------------------\n// Press <Spc> to reset\n// -------------------------------------------\n\nfloat ptLineDistance(vec2 pt,vec2 lineP1,vec2 lineP2) {\n    vec2 ab = lineP2-lineP1;\n    vec2 be = pt-lineP2;     \n    if(dot(ab,be) > 0.) return length(be);\n\n    vec2 ae = pt-lineP1;\n    if(dot(ab,ae) < 0.) return length(ae); \n    return abs(ab.x * ae.y - ab.y * ae.x) / length(ab);\n}\n\nvoid drawLine(vec2 p1,vec2 p2, float width, vec3 color,inout vec4 O,vec2 I) {\n    float d = ptLineDistance(I,p1,p2);\n    \n //   if(d < 160.) O.xyz += 1./(d * 0.3); // glow\n\n    if(d < width) {\n        float d2 = ptLineDistance(I - vec2(-width * 0.5,width * 0.5),p1,p2);\n        O.xyz = color - vec3(d2 / (width * 2.5));\n    }\n    if(abs(d - width)< 1.) O.xyz = vec3(0.);\n}\n\nvoid drawCircle(vec2 pt, float radius, vec3 color,inout vec4 O,vec2 I) {\n    float d = length(I-pt);\n    \n  //  if(d < 160.) O.xyz += 1./(d * 0.2); // glow\n    \n    if(d < radius) {\n        float d2 = length(I - vec2(-radius * 0.3,radius * 0.3) - pt);\n        O.xyz = color - vec3(d2 / (radius * 3.5));\n    }\n   // if(abs(d - radius)< thickness) O.xyz = color; // vec3(0.);\n}\n\n// -------------------------------------------\n\nvoid mainImage(out vec4 O, in vec2 U) {\n    vec2 U2 = U / iResolution.xy;  // 0 ... 1\n    ivec2 I = ivec2(int(float(GRIDX) * U2.x),int(float(GRIDY) * U2.y));\n\n    vec4 cell = fetchData(iChannel0,I);\n    if(cell.w == WALL) O.xyz = WALL_COLOR;\n    if(cell.w == PISTON) O.xyz = PISTON_COLOR;\n    if(cell.w == SHAFT) O.xyz = SHAFT_COLOR;\n    if(cell.w == STEAM) {\n        cell.y = cell.x / MAX_TEMP;  // temperature as 0...1\n        if(cell.y > 0.1) cell.y -= random(U + iTime) * 0.04;  // add flickering to temperature display\n        \n        O.xyz = jetColorMap(cell.y);        \n    }\n    \n    // linkage ----------------------\n    getSettings(iChannel0);\n    if(qPiston == RESET) return;    \n    float gx = iResolution.x / float(GRIDX);\n    float gy = iResolution.y / float(GRIDY);\n    \n    float sbase = float(sc.x)+qPiston+0.5; // piston shaft\n    vec2 p1 = vec2(sbase * gx,float(sc.y+10) * gy);\n    vec2 p2 = p1 + vec2(-40. * gx, 0.);\n    int base = vc.x+1 + int((MAX_PISTON-qPiston) * valveXscale) + valveXoffset; // valve shaft\n    vec2 p3 = vec2(float(base) * gx,float(vc.y+4) * gy);\n    vec2 p4 = p3 + vec2(-30. * gx, 0.);\n    \n    drawLine(p1,p2,3.,SHAFT_COLOR,O,U);\n    drawLine(p3,p4,3.,SHAFT_COLOR,O,U);\n    drawLine(p2,p4,3.,SHAFT_COLOR,O,U);\n    \n    drawCircle(p2,15.,SHAFT_COLOR,O,U);\n    drawCircle(p4,15.,SHAFT_COLOR,O,U);\n    vec2 p5 = p2 + (p4-p2) * valveXscale;\n    drawCircle(p5,25.,SHAFT_COLOR,O,U);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define GRIDX  130 // cell grid size\n#define GRIDY  (GRIDX * 720 / 1280)\n\n#define qPiston    settings[0].x\n#define qOldPiston settings[0].y\n#define qDelta     settings[0].z\nconst int ADDR_COUNT =      1;\nconst ivec2 Q0 = ivec2( 0,GRIDY);\nconst ivec2[ADDR_COUNT] addrList = ivec2[](Q0);\n\nconst float WALL =    1.; // solid wall\nconst float PISTON =  2.; // piston, valve\nconst float STEAM =   3.; // open area for steam\nconst float SHAFT =   4.; // connecting rods\nconst float RESET =   0.;\n\nconst float MAX_TEMP = 1000.;\nconst float MIN_PISTON = 3.;\nconst float MAX_PISTON = 24.;\n\nconst vec3 WALL_COLOR = vec3(0.5);\nconst vec3 PISTON_COLOR = vec3(0.6,0.7,0.7);\nconst vec3 SHAFT_COLOR = vec3(0.5,0.6,0.6);\nconst vec3 COLD_STEAM = vec3(0.);\n\nconst ivec4 sc = ivec4(85,20,30,20);      // steam chest\nconst ivec4 vc = sc + ivec4(-3,35,6,-10); // valve chest\nconst float valveXscale = 0.6;\nconst int valveXoffset = 2;\nconst int valveWidth = 17;\n\n#define fetchData(buf, addr) texelFetch(buf, addr, 0)\n#define storeDataAddr(buf_pos, addr) ivec2(buf_pos) == addr\n\nvec3[ADDR_COUNT] settings;\n\nvoid getSettings(sampler2D channel) { \n    for(int i=0;i<ADDR_COUNT;++i)\n        settings[i] = texelFetch(channel, addrList[i],0).xyz;\n}\n\n// ----------------------------------------------------------\n\nbool keyClick(int ascii,sampler2D channel) {\n    return (texture(channel,vec2((.5+float(ascii))/256.,0.25)).x > 0.);\n}\n\nbool getKeyState(int keyCode,sampler2D channel) {\n   return bool(texelFetch(channel, ivec2(keyCode,0), 0).x != 0.);\n}\n   \nbool getKeyClick(int keyCode,sampler2D channel) {\n   return bool(texelFetch(channel, ivec2(keyCode,1), 0).x != 0.);\n}\n\n// ----------------------------------------------------------\n\nvec3 jetColorMap(float t) { // 0 ... 1\n    return clamp(vec3(1.5) - abs(4.0 * vec3(t) + vec3(-3., -2., -1.)), vec3(0.), vec3(1.));\n}\n\n// ----------------------------------------------------------\n// https://www.shadertoy.com/view/MtfGWM\n\nfloat random(vec2 c) { return fract(sin(dot(vec2(1.317 - c.x,19.753 + c.y),c))*413.7972); } // 0...1\n\n// ----------------------------------------------------------\n    \nvoid hline(int x1,int x2,int y,inout vec4 O, ivec2 I,float kind) {\n    ivec2 pt = ivec2(x1,y);\n    \n    for(int i=x1;i<=x2;++i) {\n        pt.x = i;\n        if(pt == I) {\n            O = vec4(0.,0.,0.,kind);\n            return;\n        }\n   }\n}\n\nvoid vline(int x,int y1,int y2,inout vec4 O, ivec2 I,float kind) {\n    ivec2 pt = ivec2(x,y1);\n    \n    for(int i=y1;i<=y2;++i) {\n        pt.y = i;\n        if(pt == I) {\n            O = vec4(0.,0.,0.,kind);\n            return;\n        }\n   }\n}\n\nvoid rectangle(int x1,int y1,int xs,int ys,inout vec4 O, ivec2 I,float kind) {\n    int x2 = x1 + xs, y2 = y1 + ys;\n    hline(x1,x2,y1,O,I,kind); hline(x1,x2,y2,O,I,kind);\n    vline(x1,y1,y2,O,I,kind); vline(x2,y1,y2,O,I,kind);\n}\n\nvoid rect(ivec4 v,inout vec4 O, ivec2 I,float kind) { // v = x,y,xs,ys\n    #define x1 v.x\n    #define y1 v.y\n    int x2 = x1 + v.z, y2 = y1 + v.w;\n    hline(x1,x2,y1,O,I,kind); hline(x1,x2,y2,O,I,kind);\n    vline(x1,y1,y2,O,I,kind); vline(x2,y1,y2,O,I,kind);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void saveSettings(inout vec4 O, in vec2 U) {\n    for(int i=0;i<ADDR_COUNT;++i)\n        if(storeDataAddr(U, addrList[i])) {\n            O.xyz = settings[i];\n            return;\n        }\n}\n\n// ----------------------------------------------------------\n\nconst ivec4 \n    t1 = sc + ivec4(8,24,-26,-9),   // s-v connections\n    t2 = t1 + ivec4(10,0,0,0),\n    t1b = sc + ivec4(0,20,-18,-16), // s-v connection jogs\n    t2b = sc + ivec4(18,20,-18,-16),\n    t3 = sc + ivec4(13,27,-26,-12), // outlet\n    t3b = t3 + ivec4(4,0,20,-4),    // outlet to edge\n    t4 = t3 + ivec4(0,18,0,17),      // inlet\n    o1 = t1 + ivec4(1,0,-2,0),      // erase connections between rectangles\n    o2 = t2 + ivec4(1,0,-3,0),\n    o2c = t2 + ivec4(2,0,-3,0),\n    o3 = t3 + ivec4(1,1,-2,-1),     // inlet\n    o4 = t4 + ivec4(1,0,-2,0),      // outlet\n    o1b = t1b + ivec4(1,1,-2,-2), \n    o1c = o1b + ivec4(0,-1,-8,0), \n    o2b = t2b + ivec4(1,1,-2,-2), \n    o2d = o2b + ivec4(8,-1,-8,-2), \n    o3b = o3 + ivec4(1,0,0,-5),\n    o3c = o3b + ivec4(24,0,0,0);\n\nconst ivec4[]\n    rList = ivec4[](sc,vc,t1,t2,t3,t4,t1b,t2b,t3b),\n    oList = ivec4[](o1,o1b,o1c,o2,o2b,o2c,o2d,o3,o3b,o3c,o4);\n\nvoid initializeCells(inout vec4 O, in vec2 U) {\n    ivec2 I = ivec2(U);\n    \n    if(I == Q0) {\n        qPiston = RESET;\n        qDelta = 0.0;\n        saveSettings(O,U);\n        return;\n    }\n    \n    if(I.x < GRIDX && I.y < GRIDY) {\n        O = vec4(0.,0.,0.,STEAM);    \n        for(int i=0;i<rList.length();++i) rect(rList[i],O,I,WALL);\n        for(int i=0;i<oList.length();++i) rect(oList[i],O,I,STEAM);\n    }\n}\n\n// ----------------------------------------------------------\n\nvoid updateSteamTemperature(inout vec4 O, ivec2 I) {\n    int count = 0;\n    float total = 0.,highest = 0.;\n    \n    for(int x=-1;x<=1;++x)\n        for(int y=-1;y<=1;++y) {\n            ivec2 adr = ivec2(I.x+x,I.y+y);\n            adr.x = min(max(adr.x,0),GRIDX-1);\n            adr.y = min(max(adr.y,0),GRIDY-1);\n    \n            vec4 O = fetchData(iChannel0,adr);\n            if(O.w == STEAM || O.w == SHAFT) {\n                count += 1;\n                total += O.x;        \n                highest = max(highest,O.x);\n            }\n        }\n        \n    if(count > 0) {\n        highest *= 0.9995; // cool off a little\n        O.x = (highest*150. + total) / float(count+150); // bias average temperature with highest reading\n    }\n}\n\n// ----------------------------------------------------------\n\nvoid mainImage(out vec4 O, in vec2 U) {\n    if(iFrame < 2 || keyClick(32,iChannel3)) {\n        initializeCells(O,U);\n        return;\n    }\n\n    ivec2 I = ivec2(U);\n    \n    getSettings(iChannel0);\n\n    // Piston position & movement -------------------\n    if(I == Q0) {               \n        qOldPiston = qPiston;\n        if(qPiston == RESET) \n            qPiston = 0.;\n        \n        // read temperature on both sides of piston\n        int base = sc.x+1 + int(qPiston);\n        vec4 t1 = fetchData(iChannel0,ivec2(base-2,sc.y+12));\n        vec4 t2 = fetchData(iChannel0,ivec2(base+3,sc.y+12));\n        qDelta = clamp(t1.x - t2.x,-1.,1.);        \n        qPiston = min(max(qPiston+qDelta,MIN_PISTON),MAX_PISTON);\n        \n        saveSettings(O,U);\n        return;\n    }    \n \n    if(I.x >= GRIDX || I.y >= GRIDY) return;    \n    O = fetchData(iChannel0,I);\n\n    // add hot steam to inlet pipe\n    if(I == o4.xy + ivec2(1,6)) {\n        O = vec4(MAX_TEMP,0.,0.,STEAM);\n        return;\n    }\n\n    // copy exhaust steam past the blocking steam tube\n    const ivec2 exhaustHopDst = o4.xy + ivec2(9,-16);\n    const ivec2 exhaustHopSrc = exhaustHopDst + ivec2(-6,0);\n    if(I == exhaustHopDst) {\n        O = fetchData(iChannel0,exhaustHopSrc);\n        return;\n    }\n\n    if(O.w == STEAM || O.w == SHAFT) {\n        updateSteamTemperature(O,I); // propagate temperature differences throughout steam regions    \n        O.x *= 0.995;                // steam cools down\n        if(I.x > 126) O.x *= 0.992;   // steam leaving exhaust pipe cools down even more \n    }\n\n    // piston and valve moved?\n    int deltaPiston = int(qPiston) - int(qOldPiston);\n    if(deltaPiston != 0) { // assume -1,0,1\n        // copy neighboring steam into cells vacated by piston\n        int base = sc.x+1 + int(qPiston);\n        int dstX = base + ((deltaPiston > 0) ? -1 : 2); // to this column\n        int srcX = dstX + ((deltaPiston > 0) ? -1 : 1); // copy these steam temperatures\n\n        if(I.x == dstX && I.y >= sc.y+1 && I.y < sc.y+sc.w) {  \n            vec4 src = fetchData(iChannel0,ivec2(srcX,I.y));\n            O = vec4(src.x,0.,0.,STEAM);\n        }\n\n        rectangle(base,sc.y+1,1,sc.w-2,O,I,PISTON); \n        \n        // valve -------------------------------------------\n        // copy neighboring steam into cells vacated by valve\n        base = vc.x+1 + int((MAX_PISTON-qPiston) * valveXscale) + valveXoffset;\n\n        dstX = base + ((deltaPiston < 0) ? -1 : valveWidth+2); // outer edges\n        srcX = dstX + ((deltaPiston < 0) ? -1 : 1);            \n        if(I.x == dstX && I.y >= vc.y+1 && I.y < vc.y+7) {  \n            vec4 src = fetchData(iChannel0,ivec2(srcX,I.y));\n            if(src.w == STEAM)\n                O = vec4(src.x,0.,0.,STEAM);\n        }            \n\n        dstX = base + ((deltaPiston < 0) ? 14 : 4); // inner edges \n        srcX = dstX + ((deltaPiston < 0) ? -1 : 1);            \n        if(I.x == dstX && I.y >= vc.y+1 && I.y < vc.y+5) {  \n            vec4 src = fetchData(iChannel0,ivec2(srcX,I.y));\n            if(src.w == STEAM)\n                O = vec4(src.x,0.,0.,STEAM);\n        }\n\n        rectangle(base,vc.y+5,valveWidth+1,1,O,I,PISTON); \n        rectangle(base,vc.y+1,2,4,O,I,PISTON); \n        rectangle(base+valveWidth-2,vc.y+1,2,4,O,I,PISTON); \n        rectangle(base+1,vc.y+1,2,4,O,I,PISTON); \n        rectangle(base+valveWidth-1,vc.y+1,2,4,O,I,PISTON); \n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}