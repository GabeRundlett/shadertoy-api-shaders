{
    "Shader": {
        "info": {
            "date": "1608065654",
            "description": "Sarti Dodecic, drawn with \"complex step\" - evaluate function for complex parameter f(x+ih) = f(x)+ihf'(h)+O(h^2)\nSimilar idea to using \"dual numbers\".\n\n[url]https://nhigham.com/2020/10/06/what-is-the-complex-step-approximation/[/url]",
            "flags": 48,
            "hasliked": 0,
            "id": "3sGfDc",
            "likes": 8,
            "name": "Sarti Dodecic with Complex Step",
            "published": 3,
            "tags": [
                "dualnumber",
                "sarti",
                "dodecic",
                "complexstep"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 493
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// The Sarti Dodecic Surface, raymarched using the implicit equation as SDF,\n// adjusted by the gradient, computed numerically either in the usual way,\n// or with an imaginary delta, or using dual numbers.\n//\n// Good explanation from Nick Higham:\n// https://nhigham.com/2020/10/06/what-is-the-complex-step-approximation/\n//\n// Fast it isn't, but the implicit function is quite complex.\n//\n// Matthew Arcus, mla, 2020.\n//\n// <mouse>: rotate\n// <up>/<down>: move in/out\n// <left>/<right>: fog distance or clip radius\n// c: clip at clipradius sphere\n// f: fog\n// i: apply inversion\n// l: light transform\n// r: autorotation\n// s: soft shadows\n//\n////////////////////////////////////////////////////////////////////////////////\n\nfloat AA = 1.0;\n\n#define COMPLEXSTEP\n//#define DUAL\n\nint maxsteps = 200;\nfloat maxdist = 25.0;\nfloat precis = 0.0005;\n\nbool dorotate = true; // Autorotate\nbool doclipradius = false;\nfloat clipradius = 3.75;\n\n// Definition of basic numeric type & multiplication.\n// Addition, subtraction & multiplication by a scalar\n// are the same as for float or vec2.\n#if !defined COMPLEXSTEP\n#define T float\nT cmul(T z, T w) { return z*w; }\n#else\n#define T vec2\nT cmul(T z, T w) {\n#if defined DUAL\n  return vec2(z.x*w.x,z.x*w.y+z.y*w.x); // Dual numbers\n#else\n  return vec2(z.x*w.x-z.y*w.y,z.x*w.y+z.y*w.x); // Complex numbers\n#endif\n}\n#endif\n\nT cmul(T z, T w, T v) {\n  return cmul(z,cmul(w,v));\n}\nT cmul(T z, T w, T u, T v) {\n  return cmul(cmul(z,w),cmul(u,v));\n}\n\n// I probably lifted this from Knighty's Fragmentarium shader.\nT sarti12(T x, T y, T z, T w){\n  T x2 = cmul(x,x), y2 = cmul(y,y), z2 = cmul(z,z), w2 = cmul(w,w);\n  T x4 = cmul(x2,x2), y4 = cmul(y2,y2), z4 = cmul(z2,z2), w4 = cmul(w2,w2);\n  T l1 = x4+y4+z4+w4;\n  T l2 = cmul(x2,y2)+cmul(z2,w2);\n  T l3 = cmul(x2,z2)+cmul(y2,w2);\n  T l4 = cmul(y2,z2)+cmul(x2,w2);\n  T l5 = cmul(cmul(x,y),cmul(z,w));\n  T s10 = cmul(l1,cmul(l2,l3)+cmul(l2,l4)+cmul(l3,l4));\n  T s11 = cmul(cmul(l1,l1),l2+l3+l4);\n  T s12=cmul(l1,cmul(l2,l2)+cmul(l3,l3)+cmul(l4,l4));\n  T s51=cmul(cmul(l5,l5),l2+l3+l4);\n  T s234=cmul(l2,l2,l2)+cmul(l3,l3,l3)+cmul(l4,l4,l4);\n  T s23p=cmul(l2,l2+l3,l3), s23m=cmul(l2,l2-l3,l3); \n  T s34p=cmul(l3,l3+l4,l4), s34m=cmul(l3,l3-l4,l4); \n  T s42p=cmul(l4,l4+l2,l2), s42m=cmul(l4,l4-l2,l2);\n  T Q12=x2+y2+z2+w2; Q12=cmul(Q12,Q12,Q12); Q12=cmul(Q12,Q12);\n  T S12=33.0*sqrt(5.0)*(s23m+s34m+s42m)+19.0*(s23p+s34p+s42p)+10.0*s234-14.0*s10+2.0*s11-6.0*s12-352.0*s51+336.0*cmul(l5,l5,l1)+48.0*cmul(l2,l3,l4);\n  return 22.0*Q12-243.0*S12;\n}\n\n// Another surface most excellent\n// The Kummer Surface. https://mathworld.wolfram.com/KummerSurface.html\nfloat mu2 = 1.0;\n\nT kummer(T x, T y, T z, T w) {\n  float K = 1.414213562;\n  T p = w-z-K*x;\n  T q = w-z+K*x;\n  T r = w+z+K*y;\n  T s = w+z-K*y;\n  T t = cmul(x,x)+cmul(y,y)+cmul(z,z)-mu2*cmul(w,w);\n  float lambda = (3.0*mu2-1.0)/(3.0-mu2);\n  return cmul(t,t) - lambda*cmul(cmul(p,q),cmul(r,s));\n}\n\nT surface(T x, T y, T z, T w){\n  //return kummer(x,y,z,w);\n  return sarti12(x,y,z,w);\n}\n\n#if defined COMPLEXSTEP\nvec4 complexstep(vec3 p) {\n  float h = 1e-20; // Note the tiny step size!\n  float x = p.x, y = p.y, z = p.z, w = 1.0;\n  vec2 tx = surface(vec2(x,h),vec2(y,0),vec2(z,0),vec2(1,0));\n  vec2 ty = surface(vec2(x,0),vec2(y,h),vec2(z,0),vec2(1,0));\n  vec2 tz = surface(vec2(x,0),vec2(y,0),vec2(z,h),vec2(1,0));\n  return vec4(vec3(tx.y,ty.y,tz.y)/h,tx.x);\n}\n#else\nfloat surface(vec3 p) {\n  return surface(p.x,p.y,p.z,1.0);\n}\n\nvec3 grad(vec3 p) {\n  float eps = 1e-3;\n  vec2 e = vec2(0,eps);\n  return vec3(surface(p+e.yxx)-surface(p-e.yxx),\n              surface(p+e.xyx)-surface(p-e.xyx),\n              surface(p+e.xxy)-surface(p-e.xxy))/(2.0*eps);\n}\n#endif\n\nbool doinvert = false;\nfloat eval(vec3 p, out vec3 n, out int type) {\n  float k = 1.0;\n  if (doinvert) {\n    k = 1.0/dot(p,p);\n    p *= k;\n  }\n#if !defined COMPLEXSTEP\n  n = grad(p);\n  float d = surface(p)/length(n); // Scaled distance\n#else\n  vec4 t = complexstep(p);\n  float d = t.w/length(t.xyz);\n  n = t.xyz;\n#endif\n  type = 0;\n  if (doclipradius && !doinvert) {\n    float d1 = length(p)-clipradius;\n    if (d1 > d) { type = 1; n = p; d = d1; }\n  }\n  return d/k;\n}\n\nfloat eval(vec3 p) { int type; vec3 n; return eval(p,n,type); }\n\nfloat march(vec3 ro, vec3 rd) {\n  float t = 0.1;\n  for(int i = 0; i < maxsteps; i++) {\n    //assert(i < 50);\n    vec3 p = ro + t*rd;\n    float d = eval(p);\n    //d = min(d,max(0.5,0.1*t));\n    //d *= 0.8;\n    //d /= (1.0+0.2*d);\n    float k = doinvert ? 0.5 : 1.0;\n    t += k*d;\n    if (t < 0.0 || t > maxdist || abs(d) < t*precis) break;\n  }\n  return t;\n}\n\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,-theta);\n    p.zx = rotate(p.zx,phi);\n  }\n  if (dorotate) {\n    p.xz = -rotate(p.xz,iTime*0.15);\n  }\n  return p;\n}\n\n// softshadow from iq.\nfloat softshadow(vec3 ro, vec3 rd, float mint, float tmax, float w) {\n  float t = mint;\n  float res = 1.0;\n  for (int i = 0; i < 200; i++) {\n    float h = eval(ro + t*rd);\n    res = min(res, h/(w*t));\n    t += clamp(h, 0.01*t, max(0.5,0.1*t));\n    if (res < -1.0 || t > tmax) break;\n  }\n  res = max(res,-1.0); // clamp to [-1,1]\n  res = 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep\n  return res;\n}\n\nvec2 octamap(vec3 p) {\n  // Like a cube map but to an octahedron.\n  // Each triangular face uses half the texture.\n  int parity = 0; //int(p.z < 0.0);\n  p = abs(p);\n  p /= dot(p,vec3(1)); // Plane x+y+z = 1\n  return parity == 0 ? p.xy : 1.0-p.yx; // Flip in x+y = 1\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  dorotate = !key(CHAR_R);\n  doclipradius = key(CHAR_C);\n  doinvert = key(CHAR_I);\n  float dscale = exp(0.1*float(keycount(KEY_RIGHT)-keycount(KEY_LEFT)));\n  maxdist *= dscale;\n  clipradius *= dscale;\n  float camera = 5.0;\n  camera *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  maxdist = max(maxdist,2.0*camera); // Ensure maxdist is sensible.\n  vec3 ro = vec3(0,0,-camera);\n  ro = transform(ro);\n  vec3 light = vec3(1,2,-3);\n  if (!key(CHAR_L)) light = transform(light);\n  vec3 aacol = vec3(0);\n  mu2 = 1.0/3.0+2.5-2.5*cos(0.2*iTime); // For Kummer surface\n  float time = iTime; // For inlining suppression\n  for (float i = 0.0; i < max(-time,AA); i++) {\n    for (float j = 0.0; j < max(-time,AA); j++) {\n      vec2 uv = (2.0*(fragCoord+vec2(i,j)/AA)-iResolution.xy)/iResolution.y;\n      vec3 rd = vec3(uv,2);\n      rd = transform(rd);\n      rd = normalize(rd);\n      int type = 0;\n      float t = march(ro,rd);\n      vec3 bgcol = vec3(0.01);\n      vec3 col = bgcol;\n      if (t > 0.0 && t < maxdist) {\n        vec3 p = ro+t*rd;\n        // Sharp edge between clip region and surface means\n        // sometimes we get the wrong normal.\n        vec3 n; int type;\n        eval(p,n,type); // Re-evaluate for normal and type\n        if (type == 1 && dot(p,rd) <= 0.0) n = p;\n        else if (type == 2 && p.x < 0.0) n = vec3(-1,0,0); //Huh?\n        n = normalize(n);\n        col = vec3(1);\n        //col = texture(iChannel0,octamap(n)).rgb;\n        //col *= dot(vec3(1),texture(iChannel0,octamap(n)).rgb);\n        if (type > 0) col = vec3(0.1);\n        float ambient = 0.1;\n        vec3 lightdir = normalize(light); // Light at infinity\n        float diffuse = max(0.0,dot(n,lightdir));\n        if (key(CHAR_S)) diffuse *= softshadow(p,lightdir,0.01,4.0*max(1.0,length(p)),0.1);\n        col *= ambient+diffuse;\n        float fog = key(CHAR_F) ? 0.0 : t/maxdist;\n        col = mix(col,bgcol,fog);\n      }\n      aacol += col;\n    }\n  }\n  aacol /= float(AA*AA);\n  aacol = pow(aacol,vec3(0.4545)); // gamma correction\n  if (check) aacol.r = 1.0;\n  fragColor = vec4(aacol,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n// Common\n////////////////////////////////////////////////////////////////////////////////\n\nbool check = false;\nvoid assert(bool b) {\n  if (!b) check = true;\n}\n\nconst float PI = 3.14159;\n\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n// Macros for use in \"common\" blocks.\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x);\n  int j = int(uv.y);\n  if ( iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (i == 0) {\n    float w1 = keystate(j,2).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      t.x++;\n    }\n  }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}