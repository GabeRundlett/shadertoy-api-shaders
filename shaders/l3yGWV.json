{
    "Shader": {
        "info": {
            "date": "1718282196",
            "description": "combination",
            "flags": 0,
            "hasliked": 0,
            "id": "l3yGWV",
            "likes": 4,
            "name": "starfield with fbm",
            "published": 3,
            "tags": [
                "fbm",
                "stars",
                "universe",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 317
        },
        "renderpass": [
            {
                "code": "/*originals  sources https://www.shadertoy.com/view/lfVXRc\nhttps://www.shadertoy.com/view/XlfGRj \nhttps://www.shadertoy.com/view/mtyGWy\nhttps://www.shadertoy.com/view/wdtczM\nyes, this is a converted star nest again, but it turned out damn beautiful */\n\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n#define time iTime\n#define resolution iResolution.xy\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t dot(p,vec2(175.,100.)) );\n\treturn -1.0 + 2.0*fract(sin(p)*45000.0);\n}\n\nfloat noise( in vec2 p )\n{\n\tconst float K1 = 0.36;\n\tconst float K2 = 0.22;\n\t\n\t\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n\tvec2 a = p - i + (i.x+i.y)*K2;\n\tvec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n\tvec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\t\n\tvec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\t\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\t\n\treturn dot( n, vec3(70.0) );\n}\n\nfloat fbm(vec2 uv)\n{\n\tfloat f;\n\tmat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tf  = 0.5000*noise( uv ); uv = m*uv;\n\tf += 0.2500*noise( uv ); uv = m*uv;\n\tf += 0.1250*noise( uv ); uv = m*uv;\n\tf += 0.0625*noise( uv ); uv = m*uv;\n\tf = 0.5 + 0.5*f;\n\t\n\treturn f;\n}\n\nmat2 rotate(float a)\n{\n\tfloat c = cos(a*a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n\n\nfloat field2(in vec3 p, float s) {\n\tfloat strength = 7. + .03 * log(1.e-6 + fract(sin(time*10.) * 4500.0));\n\tfloat accum = s*3.;\n\tfloat prev = 0.;\n\tfloat tw = 0.;\n\tfor (int i = 0; i < 12; ++i) {\n\t\tfloat mag = dot(p, p)*s;\n\t\tp = abs(p) / mag + vec3(-.9, -1.0, -1.);\n\t\tfloat w = exp(-float(i) / 9.);\n\t\taccum += w * exp(-strength * pow(abs(mag - prev), 2.2));\n\t\ttw += w;\n\t\tprev = mag;\n\t}\n\treturn max(0., 5. * accum / tw - .8);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,1.);\n\n\n\t//mouse rotation\n\t\n\tvec3 from=vec3(1.,.5,0.5);\n    \n  vec2 pos=(gl_FragCoord.xy/resolution.xy)*2.0-1.0;\n\tpos.x*=resolution.x/resolution.y;\n\t\n\tvec2 pos2=pos;\n\tpos2.y-=time*.10;\n vec4 o=fragColor;\n     vec2 F = fragCoord;\n\t\n\tfloat s=fbm(pos2);\n\t\n\tfloat f=field2(vec3(pos,1.0),s/1.275);\n\tvec2 R = iResolution.xy; \n    o-=o;\n    for(float d,t = iTime*.01, i = 0. ; i > -1.; i -= .06 )          \t\n    {   d = fract( i -3.*t );                                          \t\n        vec4 c = vec4( ( F - R *.5 ) / R.y *d ,i,0 ) * 28.;            \t\n        for (int j=0 ; j++ <27; )                                      \t\n            c.xzyw = abs( c / dot(c,c)                                 \t\n                    -vec4( 7.-.2*sin(t) , 6.3 , .7 , 1.-cos(t/.8))/7.);\t\n       o -= c * c.yzww  * d--*d  / vec4(1,4,1,1);                     \n    }\n\t\n\tvec3 color=vec3(f*0.1, f*f*0.2, f*f*f*0.79+-0.3);\n\n\t\n\t//volumetric rendering\n\tfloat s2=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5+o.xyz;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.)))+o.xyz; // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam;\n            p.xy*=mat2(cos(iTime*0.05),sin(iTime*0.05),-sin(iTime*0.05),cos(iTime*0.05));// the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.2-dm*f; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*f*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.01*f,1.);\t\n\t\n\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}