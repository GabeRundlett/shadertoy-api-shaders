{
    "Shader": {
        "info": {
            "date": "1548741216",
            "description": "PLAKAT JAPONSKI 1993 by Shingeo Fukuda\nReally loved this japansese design so i decided to give it a go in a shader.\nI would love to hear how i can make this concept faster. There has to be a better way of doing the clipping and limiting the color to 1 :/",
            "flags": 0,
            "hasliked": 0,
            "id": "3sjGDh",
            "likes": 5,
            "name": "Poster Recreation - Shingeo ",
            "published": 3,
            "tags": [
                "japaneseclipping"
            ],
            "usePreview": 0,
            "username": "anemolo",
            "viewed": 468
        },
        "renderpass": [
            {
                "code": "// Thanks to @FrabriceNeyret2 for all the help and code factoring :)\n\nvec2  size = vec2(.4,.25);\nconst float \n    border = .01,\n        PI = 3.14159265359;\n\n#define R             iResolution\n// Anti alisaing\n#define S(v)          smoothstep(2./R.y, 0., v)\n#define circle(U,r)   S( length(U)-(r) )\n#define rot(a)        mat2(cos(a),-sin(a), sin(a),cos(a))\n\nfloat box( vec2 U,  vec2 r){\n    U = S( abs(U) - .5*r );\n    return U.x*U.y;\n}\n\nvoid mainImage( out vec4 O, vec2 U ){\n    // Normalized Coords * square rotation from center of box aka actually rotating everything \n\tU = ( U/R.xy - .5) * rot (PI * sin(iTime / 8.) ); \n    \n    // M = mask;\n    // M.x = rect without border\n    // M.y = rect with border\n    vec2 M = vec2(0), D;\n    for (float t, i=0.; i<5.; i++) {\n        // Rotation from center of page\n        t = iTime + 2.*PI/5.*i;\n        D = .2 * vec2( sin(t), cos(t)*1.5 );\n        // A new box will only add if M.y has not been already set to white by previous boxes.\n        // Making it so M.x(which is smaller) does not add itself onto previous boxes borders\n        M += (1.-M.y)* vec2( box(U+D, size), box(U+D, size+border) );\n    }\n    \n    O = mix( vec4(1), vec4(.9,.3,.3,1) , circle(U,.27 ));\n\t// This mixes M.x with M.y where M.y has the squares as black and\n\t// and M.x has its square as white(mixed witht the circle)\n    // So when they add, the only part that is black in both is the border\n    // O = mix( vec4(1), O*M.x, M.y);\n    \n    // This other version does the same but instead M.x becones -1 to 0 and when multiplied my M.y\n    // Every black pixel which is now -1 that is outside M.y squares becomes 0\n    // And when adding +1. It becomes white.\n    // Basically, making everything outside M.y white\n    O = 1. + (O*M.x - 1.) * M.y;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}