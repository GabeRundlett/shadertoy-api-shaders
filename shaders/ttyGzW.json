{
    "Shader": {
        "info": {
            "date": "1579846331",
            "description": "- Infinite zoom into an Alexander horned sphere\n- Use mouse drag to move forward or back along the path",
            "flags": 32,
            "hasliked": 0,
            "id": "ttyGzW",
            "likes": 157,
            "name": "Alexander horned sphere zoom",
            "published": 3,
            "tags": [
                "recursive",
                "outlines",
                "topology",
                "alexanderhornedsphere"
            ],
            "usePreview": 0,
            "username": "tmst",
            "viewed": 5876
        },
        "renderpass": [
            {
                "code": "#define WO_0 (1.0/8.0)\n#define WO_1 (1.0/8.0)\n\n#define FOG_MIN 0.0\n#define FOG_MAX 1.0\n#define FOG_COLOR vec3(0.325, 0.3, 0.375)\n\nfloat isInInterval(float a, float b, float x) {\n    return step(a, x) * (1.0 - step(b, x));\n}\n\nvoid outlineCheck(in vec2 uv, in float weight, in float aBase, inout float n) {\n    vec4 data = textureLod(iChannel0, uv, 0.0);\n    float depth = data.a;\n\n    n += weight * (1.0 - isInInterval(aBase-0.004, aBase+0.004, depth));\n}\n\nfloat outline(in vec2 uv, in float aBase) {\n    vec2 uvPixel = 1.0/iResolution.xy;\n    float n = 0.0;\n\n    outlineCheck(uv + vec2( 1.0, 0.0)*uvPixel, WO_1, aBase, n);\n    outlineCheck(uv + vec2( 0.0, 1.0)*uvPixel, WO_1, aBase, n);\n    outlineCheck(uv + vec2( 0.0,-1.0)*uvPixel, WO_1, aBase, n);\n    outlineCheck(uv + vec2(-1.0, 0.0)*uvPixel, WO_1, aBase, n);\n\n    outlineCheck(uv + vec2( 1.0, 1.0)*uvPixel, WO_0, aBase, n);\n    outlineCheck(uv + vec2( 1.0,-1.0)*uvPixel, WO_0, aBase, n);\n    outlineCheck(uv + vec2(-1.0, 1.0)*uvPixel, WO_0, aBase, n);\n    outlineCheck(uv + vec2(-1.0,-1.0)*uvPixel, WO_0, aBase, n);\n\n    return n;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec4 data = textureLod(iChannel0, uv, 0.0);\n    float depth = data.a;\n\n    float fogAmount = pow(mix(FOG_MIN, FOG_MAX, depth), 3.0);\n    vec3 finalColor = mix(data.rgb, FOG_COLOR, fogAmount);\n\n    float outlineAmount = outline(uv, depth);\n    vec3 outlineColor = vec3(0.0);\n    finalColor = mix(finalColor, outlineColor, outlineAmount*0.8);\n\n    vec2 radv = uv - vec2(0.5);\n    float dCorner = length(radv);\n    float vignetteFactor = 1.0 - mix(0.0, 0.5, smoothstep(0.2, 0.707, dCorner));\n    finalColor *= vignetteFactor;\n\n    fragColor = vec4(finalColor, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define HALF_PI 1.570796326794896\n#define ONE_PI 3.141592653589793\n#define TWO_PI 6.283185307179586\n\n#define ID_3X3      mat3( 1., 0., 0.,   0., 1., 0.,   0., 0., 1.)\n#define ROT_X       mat3( 1., 0., 0.,   0., 0., 1.,   0.,-1., 0.)\n#define ROT_X_INV   mat3( 1., 0., 0.,   0., 0.,-1.,   0., 1., 0.)\n#define ROT_Y       mat3( 0., 0.,-1.,   0., 1., 0.,   1., 0., 0.)\n#define ROT_Y_INV   mat3( 0., 0., 1.,   0., 1., 0.,  -1., 0., 0.)\n#define ROT_Z       mat3( 0., 1., 0.,  -1., 0., 0.,   0., 0., 1.)\n#define ROT_Z_INV   mat3( 0.,-1., 0.,   1., 0., 0.,   0., 0., 1.)\n\n#define E1 vec3(1.0, 0.0, 0.0)\n#define E2 vec3(0.0, 1.0, 0.0)\n#define E3 vec3(0.0, 0.0, 1.0)\n\n#define TAN_HALF_FOVY 0.5773502691896257\n#define CAM_Z_NEAR 0.1\n#define CAM_Z_FAR 50.0\n\n#define MIN_DIST 0.005\n#define MAX_DIST 50.0\n#define GRAD_EPS 0.01\n\n#define MAX_BRANCH_DEPTH 18\n\n#define SPHERE_CENTER vec3(0.0)\n#define SPHERE_RADIUS 2.0\n#define SPHERE_BUFFER 0.1\n\n#define SUBSPHERE_ZOOM 2.75\n#define SUBSPHERE_RADIUS (SPHERE_RADIUS/SUBSPHERE_ZOOM)\n#define SUBSPHERE_CENTER_L vec3(-SUBSPHERE_RADIUS-0.001, 0.0, 0.0)\n#define SUBSPHERE_CENTER_R vec3( SUBSPHERE_RADIUS+0.001, 0.0, 0.0)\n\n#define Q_RADIUS (0.5*(SPHERE_RADIUS-SPHERE_BUFFER-2.0*SUBSPHERE_RADIUS)-0.001)\n\n// If we move to the \"left\" subsphere center infinitely many times, based on the\n// left subsphere transform (cf. makeTL) we end up at the following point:\n#define L_INF_X (SUBSPHERE_CENTER_L.x/(1.0+1.0/(SUBSPHERE_ZOOM*SUBSPHERE_ZOOM)))\n#define L_INF_POS vec3(L_INF_X, L_INF_X/SUBSPHERE_ZOOM, 0.0)\n\n// =============================================\n// Some generic helpers\n// =============================================\n\n// Find t so that mix(a,b,t) = x\nfloat unmix(float a, float b, float x) {\n    return (x - a)/(b - a);\n}\n\nfloat distsq(vec3 p, vec3 q) {\n    vec3 pq = q - p;\n    return dot(pq, pq);\n}\n\nmat4 getClipToWorld(float aspectWoverH, vec3 nvCamFw, vec3 nvCamFixedUp) {\n    mat4 clipToEye = mat4(\n        aspectWoverH * TAN_HALF_FOVY, 0.0, 0.0, 0.0,\n        0.0, TAN_HALF_FOVY, 0.0, 0.0,\n        0.0, 0.0,  0.0, (CAM_Z_NEAR - CAM_Z_FAR)/(2.0 * CAM_Z_NEAR * CAM_Z_FAR),\n        0.0, 0.0, -1.0, (CAM_Z_NEAR + CAM_Z_FAR)/(2.0 * CAM_Z_NEAR * CAM_Z_FAR)\n    );\n\n    vec3 nvCamRt = normalize(cross(nvCamFw, nvCamFixedUp));\n    vec3 nvCamUp = cross(nvCamRt, nvCamFw);\n    mat4 eyeToWorld = mat4(\n         nvCamRt, 0.0,\n         nvCamUp, 0.0,\n        -nvCamFw, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n\n    return eyeToWorld * clipToEye;\n}\n\nvoid computeLighting(\n    in float diffuseCoefficient,\n    in float specularCoefficient,\n    in float specularExponent,\n    in vec3 lightColor,\n    in vec3 texColor,\n    in vec3 nvNormal,\n    in vec3 nvFragToLight,\n    in vec3 nvFragToCam,\n    out vec3 litColor\n) {\n    float valDiffuse = max(0.0, dot(nvNormal, nvFragToLight));\n    valDiffuse *= diffuseCoefficient;\n\n    vec3 blinnH = normalize(nvFragToLight + nvFragToCam);\n    float valSpecular = pow(max(0.0, dot(nvNormal, blinnH)), specularExponent);\n    valSpecular *= specularCoefficient;\n\n    litColor = valDiffuse*texColor*lightColor + valSpecular*lightColor;\n}\n\nvoid sphereClip(\n    in vec3 center, in float radius,\n    in vec3 p, in vec3 v,\n    out vec2 tRange, out float didHit\n) {\n    // Solve quadratic in t: |p+tv - center|^2 = radius^2\n    // Or, |A+tB|^2 = 1, with A = (p-center)/radius, B = v/radius\n    // Solution: t = (-A.B +- sqrt(D))/|B|^2, D = (A.B)^2 + |B|^2 * (1-|A|^2).\n\n    vec3 A = (p - center) / radius;\n    vec3 B = v / radius;\n\n    float AA = dot(A,A);\n    float AB = dot(A,B);\n    float BB = dot(B,B);\n\n    float D = AB*AB + BB*(1.0 - AA);\n    float sqD = sqrt(abs(D));\n    didHit = 1.0 - step(D, 0.0);\n\n    float t0 = (-AB + sqD)/BB;\n    float t1 = (-AB - sqD)/BB;\n    tRange = vec2(min(t0,t1), max(t0,t1));\n}\n\n// =============================================\n// Recursive transform helpers\n// =============================================\n\n// Treats the bits of an integer as a stack, with\n// \"0\" meaning \"left branch\" and \"1\" meaning \"right branch\"\n\nvoid pushBranch(inout int branch, inout int branchDepth, int val) {\n    if (branchDepth == 0) {\n        branch = val;\n    } else {\n        branch = 2*branch + val;\n    }\n    branchDepth++;\n}\n\nint popBranch(inout int branch, inout int branchDepth) {\n    int b2 = branch % 2;\n    branch = (branch - b2) / 2;\n    branchDepth--;\n    return b2;\n}\n\nvoid makeTL(out mat3 transM, out mat3 transMInv, out vec3 transO) {\n    transM = SUBSPHERE_ZOOM*ROT_Z_INV;\n    transMInv = (1.0/SUBSPHERE_ZOOM)*ROT_Z;\n    transO = SUBSPHERE_CENTER_L;\n}\n\nvoid makeTR(out mat3 transM, out mat3 transMInv, out vec3 transO) {\n    transM = SUBSPHERE_ZOOM*ROT_X*ROT_Y;\n    transMInv = (1.0/SUBSPHERE_ZOOM)*ROT_Y_INV*ROT_X_INV;\n    transO = SUBSPHERE_CENTER_R;\n}\n\nvoid makeT(\n    in int branch, in int branchDepth,\n    out mat3 transM, out mat3 transMInv, out vec3 transO\n) {\n    transMInv = ID_3X3;\n    transM = ID_3X3;\n    transO = vec3(0.0);\n\n    int b = branch;\n    for (int i=0; i<branchDepth; i++) {\n        int b2 = b % 2;\n\n        mat3 curM;\n        mat3 curMInv;\n        vec3 curO;\n\n        if (b2 == 0) {\n            makeTL(curM, curMInv, curO);\n        } else {\n            makeTR(curM, curMInv, curO);\n        }\n\n        transM = transM * curM;\n        transMInv = curMInv * transMInv;\n        transO = curO + curMInv*transO;\n\n        b = (b - b2) / 2;\n    }\n}\n\n// =============================================\n// \"Object\" helpers\n// =============================================\n\n// circT maps circle in xy plane to desired circle:\n// i.e., mat3(\"zero angle direction\", \"90 degrees direction\", circ plane normal)\n// and circTInv is the transpose\n// uvAng is (theta,phi) where theta is 0 in the \"zero angle direction\"\nvoid cpCirc(\n    in vec3 circCenter, in float circRadius,\n    in mat3 circT, in mat3 circTInv, in vec3 p,\n    out vec3 cp, out vec2 uvAng\n) {\n    vec3 v = circTInv*(p - circCenter);\n\n    vec3 vProj = vec3(v.xy, 0.0);\n    float vProjLen = length(v.xy);\n    vec3 cpT = (circRadius/vProjLen)*vProj;\n\n    uvAng = vec2(\n        atan(v.y, v.x),\n        atan(v.z, vProjLen-circRadius)\n    );\n    cp = circT*cpT + circCenter;\n}\n\nvec3 cpTuple2(vec3 q0, vec3 q1, vec3 p) {\n    vec3 q = q0;\n    return mix(q, q1, step( distsq(p,q1), distsq(p,q) ));\n}\n\nfloat radiusMultiplier(vec2 uvAng, float maxAngle) {\n    float rt = abs(uvAng.s)/maxAngle;\n    return mix(1.0, 1.0/SUBSPHERE_ZOOM, smoothstep(0.4, 0.9, rt));\n}\n\nvec2 uvAng_to_uv(vec2 uvAng, float maxAngle) {\n    return vec2(\n        unmix(-maxAngle, maxAngle, uvAng.s),\n        unmix(-ONE_PI, ONE_PI, uvAng.t)\n    );\n}\n\nvoid sdBaseUV(in vec3 p, out vec3 uv, out float sd) {\n    // ---------------------------------------------------\n    // Basic geometry piece is a circle which hits 3 points:\n    // - (-x0,   0 ): Q_RADIUS from the left-most edge of main sphere\n    // - ( x1, +-y1): Top and bottom of right subsphere\n\n    const float x0 = SPHERE_RADIUS-SPHERE_BUFFER - Q_RADIUS;\n    const float x1 = SUBSPHERE_CENTER_R.x;\n    const float y1 = x0/SUBSPHERE_ZOOM;\n    float linkCenter = (x1-x0)/2.0 + (y1/2.0)*(1.0/(x0+x1)) * y1;\n    float linkRadius = x0 + linkCenter;\n    float maxAngle = atan(y1, -(x1 - linkCenter));\n    // ---------------------------------------------------\n\n    // \"Left\" link (in xz-plane):\n    vec3 cpL;\n    vec2 uvAngL;\n    cpCirc(\n        vec3(linkCenter,0.0,0.0), linkRadius,\n        mat3(-E1,E3,E2), mat3(-E1,E3,E2), p, cpL, uvAngL\n    );\n    float dsqL = distsq(p, cpL);\n\n    // \"Right\" link (in xy-plane):\n    vec3 cpR;\n    vec2 uvAngR;\n    cpCirc(\n        vec3(-linkCenter,0.0,0.0), linkRadius,\n        mat3(E1,E2,E3), mat3(E1,E2,E3), p, cpR, uvAngR\n    );\n    float dsqR = distsq(p, cpR);\n\n    // \"Parent\" link: right-link with inv. left-transform applied (or reverse!)\n    mat3 transLM;\n    mat3 transLMInv;\n    vec3 transLO;\n    makeTL(transLM, transLMInv, transLO);\n\n    vec3 pT = transLMInv*p + transLO;\n    vec3 cpP;\n    vec2 uvAngP;\n    cpCirc(\n        vec3(-linkCenter,0.0,0.0), linkRadius,\n        mat3(E1,E2,E3), mat3(E1,E2,E3), pT, cpP, uvAngP\n    );\n    float cull = step( maxAngle, abs(uvAngP.s) );\n    cpP = mix( cpP, cpTuple2(vec3(-x1,-y1,0.0), vec3(-x1,y1,0.0), pT), cull );\n    cpP = transLM*(cpP - transLO);\n    float dsqP = distsq(p, cpP);\n\n    float hitRadius = Q_RADIUS;\n    if (dsqP < dsqL && dsqP < dsqR) {\n        // NOTE: uv.p is used to correct the smoothBranchDepth elsewhere\n        uv = vec3(uvAng_to_uv(uvAngP, maxAngle), 1.0);\n        hitRadius *= SUBSPHERE_ZOOM;\n        sd = distance(p, cpP) - hitRadius * radiusMultiplier(uvAngP, maxAngle);\n    } else if (dsqL < dsqR) {\n        uv = vec3(uvAng_to_uv(uvAngL, maxAngle), 0.0);\n        sd = distance(p, cpL) - hitRadius * radiusMultiplier(uvAngL, maxAngle);\n    } else {\n        uv = vec3(uvAng_to_uv(uvAngR, maxAngle), 0.0);\n        sd = distance(p, cpR) - hitRadius * radiusMultiplier(uvAngR, maxAngle);\n    }\n}\n\nvoid objNormal(in vec3 p, out vec3 hitNormal) {\n    float fXA, fXB, fYA, fYB, fZA, fZB;\n    vec3 uv;\n\n    sdBaseUV(p - vec3(GRAD_EPS, 0.0, 0.0), uv, fXA);\n    sdBaseUV(p + vec3(GRAD_EPS, 0.0, 0.0), uv, fXB);\n    sdBaseUV(p - vec3(0.0, GRAD_EPS, 0.0), uv, fYA);\n    sdBaseUV(p + vec3(0.0, GRAD_EPS, 0.0), uv, fYB);\n    sdBaseUV(p - vec3(0.0, 0.0, GRAD_EPS), uv, fZA);\n    sdBaseUV(p + vec3(0.0, 0.0, GRAD_EPS), uv, fZB);\n\n    hitNormal = vec3(fXB-fXA, fYB-fYA, fZB-fZA);\n}\n\nvoid hitObject(\n    in vec3 p, in vec3 nv, in vec2 tRange,\n    out float didHit, out float tHit, out vec3 uvHit\n) {\n    didHit = 0.0;\n    vec3 curPos = p + tRange.s*nv;\n    tHit = tRange.s;\n\n    for (int i=0; i<50; i++) {\n        float tAdd;\n        sdBaseUV(curPos, uvHit, tAdd);\n\n        if (abs(tAdd) < MIN_DIST) {\n            didHit = 1.0;\n            break;\n        }\n\n        curPos += tAdd * nv;\n        tHit += tAdd;\n\n        if (tHit > tRange.t) {\n            break;\n        }\n    }\n}\n\n// =============================================\n// Recursive scene\n// =============================================\n\nfloat inInterval(float t, vec2 tRange) {\n    return step(tRange.s, t) * (1.0 - step(tRange.t, t));\n}\n\nvec2 minHitData(float t, vec2 minData, vec2 tRangeAllowed, float typeId) {\n    float doUse = inInterval(t, tRangeAllowed) * step(t, minData.x);\n    return mix( minData, vec2(t, typeId), doUse );\n}\n\nvoid march(\n    in vec3 p, in vec3 nv,\n    out float didHit, out vec3 hitPos,\n    out vec3 nvHitNormal, out vec3 hitUV, out int hitBranchDepth\n) {\n    // Update range for root sphere\n    vec2 tRangeRoot;\n    float didHitSphere;\n    sphereClip(SPHERE_CENTER, SPHERE_RADIUS, p, nv, tRangeRoot, didHitSphere);\n    if (didHitSphere < 0.5) {\n        didHit = 0.0;\n        return;\n    }\n\n    // transform is p \\mapsto M(p - O)\n    mat3 transMInv = ID_3X3;\n    mat3 transM = ID_3X3;\n    vec3 transO = vec3(0.0);\n\n    vec3 pTransRay = p;\n    vec3 nvTransRay = nv;\n    vec2 tRangeCur = tRangeRoot;\n\n    int branchDepth = 0;\n    int branch = -1;\n\n    for (int i=0; i<100; i++) { // TODO\n\n        vec2 hitData = vec2(tRangeCur.t, 0.0);\n\n        // Check object hit within sphere\n        float didHitObject;\n        float tHitObject;\n        vec3 uvHitObject;\n        hitObject(\n            pTransRay, nvTransRay, vec2(max(0.0, tRangeCur.s), tRangeCur.t),\n            didHitObject, tHitObject, uvHitObject\n        );\n        if (didHitObject > 0.5) {\n            hitData = minHitData(tHitObject, hitData, tRangeCur, 0.1);\n        }\n\n        // Check \"left\" subsphere hit\n        vec2 tRangeSubsphereL;\n        float didHitL;\n        sphereClip(\n            SUBSPHERE_CENTER_L, SUBSPHERE_RADIUS, pTransRay, nvTransRay,\n            tRangeSubsphereL, didHitL\n        );\n        if (branchDepth < MAX_BRANCH_DEPTH && didHitL > 0.5) {\n            hitData = minHitData(tRangeSubsphereL.s, hitData, tRangeCur, 0.2);\n        }\n\n        // Check \"right\" subsphere hit\n        vec2 tRangeSubsphereR;\n        float didHitR;\n        sphereClip(\n            SUBSPHERE_CENTER_R, SUBSPHERE_RADIUS, pTransRay, nvTransRay,\n            tRangeSubsphereR, didHitR\n        );\n        if (branchDepth < MAX_BRANCH_DEPTH && didHitR > 0.5) {\n            hitData = minHitData(tRangeSubsphereR.s, hitData, tRangeCur, 0.3);\n        }\n\n        if (hitData.y < 0.05) {\n\n            // Exiting sphere: \"pop\" transform to parent sphere\n\n            if (branchDepth == 0) {\n                break;\n            }\n            popBranch(branch, branchDepth);\n            makeT(branch, branchDepth, transM, transMInv, transO);\n\n            pTransRay = transM * (p - transO);\n            nvTransRay = normalize( transM * nv );\n\n            vec2 tRangeParent;\n            float didHitSphereParent;\n            sphereClip(\n                SPHERE_CENTER, SPHERE_RADIUS, pTransRay, nvTransRay,\n                tRangeParent, didHitSphereParent\n            );\n            tRangeCur = vec2(tRangeCur.t/SUBSPHERE_ZOOM, tRangeParent.t);\n\n        } else if (hitData.y < 0.15) {\n\n            // Hit object--done!\n\n            didHit = 1.0;\n            vec3 hitPosTrans = pTransRay + tHitObject*nvTransRay;\n            hitPos = transMInv*hitPosTrans + transO;\n\n            vec3 hitNormal;\n            objNormal(hitPosTrans, hitNormal);\n            nvHitNormal = normalize(transMInv*hitNormal);\n\n            hitUV = uvHitObject;\n            hitBranchDepth = branchDepth;\n\n            break;\n\n        } else if (hitData.y < 0.25) {\n\n            // Entered \"left\" subsphere; push transform and continue\n\n            pushBranch(branch, branchDepth, 0);\n            makeT(branch, branchDepth, transM, transMInv, transO);\n\n            pTransRay = transM * (p - transO);\n            nvTransRay = normalize( transM * nv );\n            tRangeCur = tRangeSubsphereL * SUBSPHERE_ZOOM;\n\n        } else if (hitData.y < 0.35) {\n\n            // Entered \"right\" subsphere; push transform and continue\n\n            pushBranch(branch, branchDepth, 1);\n            makeT(branch, branchDepth, transM, transMInv, transO);\n\n            pTransRay = transM * (p - transO);\n            nvTransRay = normalize( transM * nv );\n            tRangeCur = tRangeSubsphereR * SUBSPHERE_ZOOM;\n\n        }\n    }\n\n}\n\nvoid camConfig(\n    out float scfa,\n    out vec3 camPos,\n    out vec3 nvCamFw,\n    out vec3 nvCamFixedUp\n) {\n    float itAdj = iTime/3.0;\n    if (iMouse.z > 0.0) {\n        itAdj = 12.0*iMouse.y/iResolution.y;\n    }\n    float ft4 = fract(itAdj/4.0)*4.0;\n\n    // scfa is the scale factor at the current cam pos: how much things are\n    // scaled relative to the \"base object\" in the root/parent sphere\n    scfa = pow(1.0/SUBSPHERE_ZOOM, ft4+2.0);\n\n    float ct = cos(itAdj*HALF_PI);\n    float st = sin(itAdj*HALF_PI);\n\n    vec3 camOffset = normalize(vec3(1.0, 1.5*ct, 1.0));\n    camPos = L_INF_POS + camOffset*scfa;\n    nvCamFw = normalize(-camOffset);\n    nvCamFixedUp = normalize(vec3(cos(0.5*ct), 0.0, sin(0.5*ct)));\n}\n\nvec3 skybox(vec3 nvDir) {\n    float sep = -0.15;\n    float blend = 0.025;\n    return mix(\n        mix(vec3(1.0), vec3(0.8, 0.45, 0.25), unmix(-1.0, sep, nvDir.x)),\n        mix(vec3(1.0), vec3(0.7, 0.6, 1.0), unmix(sep, 1.0, nvDir.x)),\n        smoothstep(sep-blend, sep+blend, nvDir.x)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    float scfa;\n    vec3 camPos;\n    vec3 nvCamFw;\n    vec3 nvCamFixedUp;\n    camConfig(scfa, camPos, nvCamFw, nvCamFixedUp);\n\n    float aspectWoverH = iResolution.x/iResolution.y;\n    mat4 clipToWorld = getClipToWorld(aspectWoverH, nvCamFw, nvCamFixedUp);\n\n    vec4 vWorld = clipToWorld * vec4(uv*2.0 - 1.0, 1.0, 1.0);\n    vec3 nvCamDir = normalize(vWorld.xyz / vWorld.w);\n\n    vec4 color = vec4(1.0);\n\n    float didHit;\n    vec3 hitPos;\n    vec3 nvHitNormal;\n    vec3 hitUV;\n    int hitBranchDepth;\n    march(camPos, nvCamDir, didHit, hitPos, nvHitNormal, hitUV, hitBranchDepth);\n    if (didHit > 0.5) {\n\n        vec3 nvCamRt = normalize(cross(nvCamFw, nvCamFixedUp));\n        vec3 nvCamUp = normalize(cross(nvCamRt, nvCamFw));\n        vec3 lightPos = mix(camPos, L_INF_POS, 0.5);\n\n        float smoothBranchDepth = (\n            float(hitBranchDepth) + 2.0*abs(hitUV.s - 0.5) - hitUV.p\n        );\n        float ct = fract(smoothBranchDepth/4.0);\n        float ctt = fract(-0.2*iTime + smoothBranchDepth/4.0);\n        vec3 matColor = 0.5 + 0.5*vec3(\n            cos(TWO_PI * ct),\n            cos(TWO_PI * (ct - 1.0/3.0)),\n            cos(TWO_PI * (ct - 2.0/3.0))\n        );\n        float pulse = 1.0 - step(0.25+0.25*sin(iTime), abs(ctt-0.5));\n        matColor = mix(matColor, vec3(0.0), pulse);\n\n        vec3 nvFragToCam = normalize(camPos - hitPos);\n        vec3 nvFragToLight = normalize(lightPos - hitPos);\n\n        vec3 litColor;\n        computeLighting(\n            0.8, 1.0, 50.0,\n            vec3(1.0), matColor, nvHitNormal,\n            nvFragToLight,\n            nvFragToCam,\n            litColor\n        );\n\n        vec3 nvRefl = normalize(reflect( hitPos-camPos, nvHitNormal ));\n        vec3 skyColor = skybox(nvRefl);\n\n        vec3 finalColor = litColor;\n        finalColor += 0.4*skyColor; //reflective\n        finalColor += 0.25*matColor; //emissive\n        finalColor = clamp(finalColor, 0.0, 1.0);\n\n        float dScale = length(hitPos-camPos)/length(L_INF_POS-camPos);\n        float dVal = clamp( unmix(0.0, 20.0, dScale), 0.0, 1.0 );\n        float dA = 100.0; // higher gives more detail on nearer values\n        float finalDepth = log(dA*dVal+1.0)/log(dA+1.0);\n\n        color = vec4(finalColor, finalDepth);\n\n    }\n\n    fragColor = color;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}