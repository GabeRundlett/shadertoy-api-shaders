{
    "Shader": {
        "info": {
            "date": "1690215330",
            "description": "Simple performance Test for Tri-, Bi-, and Uni-planar mapping to see who is fastest. This repeats the function n times with different values to tank your fps, so you can see which is fastest.",
            "flags": 0,
            "hasliked": 0,
            "id": "cs2BD3",
            "likes": 4,
            "name": "PerfTest Uni, Bi, TriPlanar",
            "published": 3,
            "tags": [
                "test",
                "triplanar",
                "dither",
                "cubemap",
                "performance",
                "performance",
                "interpolation",
                "biplanar",
                "uniplanar"
            ],
            "usePreview": 0,
            "username": "gehtsiegarnixan",
            "viewed": 332
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright © 2023 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis performance test aims to compare planar mapping implementations. \n\nThe test works by measuring frames per second (FPS) on Shadertoy. To \nensure valid results, we repeat the test function with varying values, \naccumulating their results into a final image.\n\nSteps:\n- Increase REPEAT until the FPS are below your monitors refreshrate \n    (probably somewhere around 60-144 fps)\n- Modify TEST value to switch between test cases\n- The highest FPS indicates the fastest implementation\n- Congratulate yourself for doing SCIENCE\n*/\n\n// Number of repeats of the test, 1500 should be enough for RTX3080\n#define REPEAT 1\n\n// switch between the test cases\n// 0 = uniplanarIf using dithered deriviative Mips ~ 82 fps\n// 1 = uniplanarIf using deriviative Mips ~ 78 fps\n// 2 = uniplanarIf (use linear texture) ~ 132 fps\n// 3 = uniplanarLerp (use linear texture) ~ 105 fps\n// 4 = Biplanar  ~ 19 fps\n// 5 = Triplanar ~ 63 fps\n// 6 = Triplanar with Branching ~ 83 fps\n// 7 = Triplanar with Less Branching ~ 80 fps\n// 8 = Triplanar with Nested Branching ~ 78 fps\n// 9 = Triplanar with Nested Branching Broken mips ~ 110 fps\n#define TEST 6\n\n// shows the blend area\n//#define SHOWBLEND\n#define LINETHICKNESS 0.05\n\n// 1 for no contrast, higher values for more contrast\n#define CONTRAST 16.0 \n\n// one texture sample, uses dithering to make the edges smoother\nvec4 uniplanarIfDitheredMips( sampler2D sam, vec3 normal, vec3 position, vec2 fragCoord, float contrast) {    \n    vec2 uvX = position.yz;\n    vec2 uvY = position.zx;\n    vec2 uvZ = position.xy;\n\n    vec3 alpha = abs(normal); // Alpha Mask for blending\n    \n    alpha = smoothContrast(alpha, contrast); // increase contrast\n       \n    // static dither\n    float dither = InterleavedGradientNoise(fragCoord);\n    \n    // Apply float dither to three values of Alpha\n    float xDitherPart = alpha.x - dither;\n    float yDitherPart = alpha.y + xDitherPart;\n\n    // Mip caculation as the automatic ones don't work\n    vec3 duvwdx = dFdx( position );\n    vec3 duvwdy = dFdy( position );\n    \n    // uvs for derivatives Mips\n    vec2 duvdx; \n    vec2 duvdy; \n\n    // \"interpolate\" the UVs\n    vec2 uv;\n    if (xDitherPart >= 0.0 && yDitherPart >= 0.0) {\n        uv = uvX;\n        duvdx = duvwdx.yz; // how is this thing allowed?\n        duvdy = duvwdy.yz;\n    } else if (yDitherPart >= 0.0) {\n        uv = uvY;\n        duvdx = duvwdx.zx;\n        duvdy = duvwdy.zx;\t\n    } else {\n        uv = uvZ;\n        duvdx = duvwdx.xy;\n        duvdy = duvwdy.xy;\n    }\n    \n    // texture sample\n    vec4 col = textureGrad( sam, uv, duvdx, duvdy);\n    \n    #ifdef SHOWBLEND\n    float lineThickness = 0.05; // must be smaller than 0.1\n    vec3 mask = step(abs(alpha - 0.1), vec3(lineThickness));\n    return vec4(max(mask, col.xyz), col.w);\n    #else\n    return col;\n    #endif\n}\n\n// one texture sample, uses dithering to make the edges smoother\nvec4 uniplanarIfMips( sampler2D sam, vec3 normal, vec3 position, vec2 fragCoord, float contrast) {    \n    vec2 uvX = position.yz;\n    vec2 uvY = position.zx;\n    vec2 uvZ = position.xy;\n\n    vec3 alpha = abs(normal); // Alpha Mask for blending\n    \n    alpha = smoothContrast(alpha, contrast); // increase contrast\n       \n    // static dither\n    float dither = InterleavedGradientNoise(fragCoord);\n    \n    // Apply float dither to three values of Alpha\n    float xDitherPart = alpha.x - dither;\n    float yDitherPart = alpha.y + xDitherPart;\n\n    // \"interpolate\" the UVs\n    vec2 uv;\n    if (xDitherPart >= 0.0 && yDitherPart >= 0.0) {\n        uv = uvX;\n    } else if (yDitherPart >= 0.0) {\n        uv = uvY;\n    } else {\n        uv = uvZ;\n    }\n    \n    // Mip caculation as the automatic ones don't work\n    vec3 duvwdx = dFdx( position );\n    vec3 duvwdy = dFdy( position );\n    \n    // uvs for derivatives Mips\n    vec2 duvdx; \n    vec2 duvdy; \n    if (alpha.x>alpha.y && alpha.x>alpha.z) {\n        duvdx = duvwdx.yz;\n        duvdy = duvwdy.yz;\n    } else if (alpha.y>alpha.z) {\n        duvdx = duvwdx.zx;\n        duvdy = duvwdy.zx;\t\n    } else {\n        duvdx = duvwdx.xy;\n        duvdy = duvwdy.xy;\n    }  \n    \n    // texture sample\n    vec4 col = textureGrad( sam, uv, duvdx, duvdy);\n    \n    #ifdef SHOWBLEND\n    vec3 mask = step(abs(alpha - 0.1), vec3(LINETHICKNESS));\n    return vec4(max(mask, col.xyz), col.w);\n    #else\n    return col;\n    #endif\n}\n\n// one texture sample, uses dithering to make the edges smoother\nvec4 uniplanarIf( sampler2D sam, vec3 normal, vec3 position, vec2 fragCoord, float contrast) {    \n    vec2 uvX = position.yz;\n    vec2 uvY = position.zx;\n    vec2 uvZ = position.xy;\n\n    vec3 alpha = abs(normal); // Alpha Mask for blending\n    \n    alpha = smoothContrast(alpha, contrast); // increase contrast\n       \n    // static dither\n    float dither = InterleavedGradientNoise(fragCoord);\n    \n    // Apply float dither to three values of Alpha\n    float xDitherPart = alpha.x - dither;\n    float yDitherPart = alpha.y + xDitherPart;\n\n    // \"interpolate\" the UVs\n    vec2 uv;\n    if (xDitherPart >= 0.0 && yDitherPart >= 0.0) {\n        uv = uvX;\n    } else if (yDitherPart >= 0.0) {\n        uv = uvY;\n    } else {\n        uv = uvZ;\n    }\n    \n    vec4 col = texture( sam, uv);\n    \n    #ifdef SHOWBLEND\n    vec3 mask = step(abs(alpha - 0.1), vec3(LINETHICKNESS));\n    return vec4(max(mask, col.xyz), col.w);\n    #else\n    return col;\n    #endif\n}\n\n// one texture sample, uses dithering to make the edges smoother\nvec4 uniplanarLerp( sampler2D sam, vec3 normal, vec3 position, vec2 fragCoord, float contrast) {\n    vec3 alpha = abs(normal); // Alpha Mask for blending\n    \n    alpha = smoothContrast(alpha, contrast); // increase contrast\n    \n    // static dither\n    float dither = InterleavedGradientNoise(fragCoord);\n    \n    //apply float dither to three values of Alpha\n    float xDitherPart = alpha.x - dither;\n    float yDitherPart = step(0., alpha.y + xDitherPart);\n    float xDither = step(0., xDitherPart);\n    vec3 ditherAlpha = vec3(xDither, yDitherPart - xDither, 1.0 - yDitherPart);\n    \n    vec2 uvX = position.yz;\n    vec2 uvY = position.zx;\n    vec2 uvZ = position.xy;\n    \n    // interpolate (since we use bitmasks it is allowed for UVs)\n    vec2 uv = uvX * ditherAlpha.x + uvY * ditherAlpha.y + uvZ * ditherAlpha.z;\n    \n    vec4 col = texture( sam, uv);\n    \n    #ifdef SHOWBLEND\n    vec3 mask = step(abs(alpha - 0.1), vec3(LINETHICKNESS));\n    return vec4(max(mask, col.xyz), col.w);\n    #else\n    return col;\n    #endif\n}\n\n// IQ's Biplanar mapping implementation (https://www.shadertoy.com/view/ws3Bzf)\n// The MIT License\n// Copyright © 2020 Inigo Quilez\nvec4 biplanar( sampler2D sam, in vec3 p, in vec3 n, in float k ) {\n    // grab coord derivatives for texturing\n    vec3 dpdx = dFdx(p);\n    vec3 dpdy = dFdy(p);\n    n = abs(n);\n\n    // major axis (in x; yz are following axis)\n    ivec3 ma = (n.x>n.y && n.x>n.z) ? ivec3(0,1,2) :\n               (n.y>n.z)            ? ivec3(1,2,0) :\n                                      ivec3(2,0,1) ;\n    // minor axis (in x; yz are following axis)\n    ivec3 mi = (n.x<n.y && n.x<n.z) ? ivec3(0,1,2) :\n               (n.y<n.z)            ? ivec3(1,2,0) :\n                                      ivec3(2,0,1) ;\n        \n    // median axis (in x;  yz are following axis)\n    ivec3 me = ivec3(3) - mi - ma;\n    \n    // project+fetch\n    vec4 x = textureGrad( sam, vec2(   p[ma.y],   p[ma.z]), \n                               vec2(dpdx[ma.y],dpdx[ma.z]), \n                               vec2(dpdy[ma.y],dpdy[ma.z]) );\n    vec4 y = textureGrad( sam, vec2(   p[me.y],   p[me.z]), \n                               vec2(dpdx[me.y],dpdx[me.z]),\n                               vec2(dpdy[me.y],dpdy[me.z]) );\n    \n    // contrast\n    vec2 m = vec2(n[ma.x],n[me.x]);\n    // optional - add local support (prevents discontinuty)\n    m = clamp( (m-0.5773)/(1.0-0.5773), 0.0, 1.0 );\n    // transition control\n    m = pow( m, vec2(k/8.0) );\n    m = m / (m.x + m.y);\n    \n    // interpolate\n\tvec4 col = x*m.x + y*m.y;\n    \n    #ifdef SHOWBLEND\n    vec2 mask = step(abs(m - 0.1), vec2(LINETHICKNESS));\n    return vec4(max(mask, col.xy), col.zw);\n    #else\n    return col;\n    #endif\n}\n\n// IQ's Triplanar mapping implementation (https://www.shadertoy.com/view/MtsGWH)\n// The MIT License\n// Copyright © 2015 Inigo Quilez\nvec4 triplanar( in sampler2D s, in vec3 p, in vec3 n, in float k ) {\n    // project+fetch\n\tvec4 x = texture( s, p.yz );\n\tvec4 y = texture( s, p.zx );\n\tvec4 z = texture( s, p.xy );\n    \n    // and contrast\n    vec3 m = pow( abs(n), vec3(k) );\n    m = m / (m.x + m.y + m.z);\n    \n    // interpolate\n    vec4 col = (x*m.x + y*m.y + z*m.z);\n    \n    #ifdef SHOWBLEND\n    vec3 mask = step(abs(m - 0.1), vec3(LINETHICKNESS));\n    return vec4(max(mask, col.xyz), col.w);\n    #else\n    return col;\n    #endif\n}\n\n// Triplanar with branching, using 3,2,1 samples where possible. \n#define JUST_ABOVE_ZERO (1.0 / float(0xffffU))\n#define JUST_BELOW_ONE (1.0 - JUST_ABOVE_ZERO)\nvec4 branchingTriplanar( in sampler2D sam, in vec3 position, in vec3 normal, in float contrast ){\n    // Alpha Mask for blending\n    vec3 weights = abs(normal); \n    \n    // Normalize alpha to sum=1\n    weights = weights / (weights.x + weights.y + weights.z);\n    \n    // Apply contrast \n    weights = straightContrast(weights, contrast); // increase contrast    \n\n    // Coordinate projections\n    vec2 uvX = position.yz;\n    vec2 uvY = position.zx;\n    vec2 uvZ = position.xy;\n        \n    // Mip caculation as the automatic ones don't work\n    vec3 duvwdx = dFdx(position);\n    vec3 duvwdy = dFdy(position);\n    \n    // Partial Derivative Projection\n    vec2 duvdxX = duvwdx.yz; \n    vec2 duvdyX = duvwdy.yz;\n    vec2 duvdxY = duvwdx.zx; \n    vec2 duvdyY = duvwdy.zx;\n    vec2 duvdxZ = duvwdx.xy; \n    vec2 duvdyZ = duvwdy.xy;\n    \n    vec4 color;\n    if (weights.x > JUST_BELOW_ONE) {\n        // Sample X Side\n        color = textureGrad(sam, uvX, duvdxX, duvdyX);\n        \n    } else if (weights.y > JUST_BELOW_ONE) {\n        // Sample Y Side\n        color = textureGrad(sam, uvY, duvdxY, duvdyY);\n    \n    } else if (weights.z > JUST_BELOW_ONE) {\n        // Sample Z Side\n        color = textureGrad(sam, uvZ, duvdxZ, duvdyZ);\n        \n    } else if (weights.x < JUST_ABOVE_ZERO) {\n        // Samples YZ Side \n        vec4 colorY = textureGrad(sam, uvY, duvdxY, duvdyY);\n        vec4 colorZ = textureGrad(sam, uvZ, duvdxZ, duvdyZ);\n        \n        // Color interpolation\n        color = colorY * weights.y + \n                colorZ * weights.z;\n    \n    } else if (weights.y < JUST_ABOVE_ZERO) {\n        // Samples XZ Side\n        vec4 colorX = textureGrad(sam, uvX, duvdxX, duvdyX);\n        vec4 colorZ = textureGrad(sam, uvZ, duvdxZ, duvdyZ);\n        \n        // Color interpolation\n        color = colorX * weights.x +\n                colorZ * weights.z;\n    \n    } else if (weights.z < JUST_ABOVE_ZERO) {\n        // Samples XY Side\n        vec4 colorX = textureGrad(sam, uvX, duvdxX, duvdyX);\n        vec4 colorY = textureGrad(sam, uvY, duvdxY, duvdyY);\n\n        // Color interpolation\n        color = colorX * weights.x + \n                colorY * weights.y;\n        \n    } else {\n       // Samples all 3 \n        vec4 colorX = textureGrad(sam, uvX, duvdxX, duvdyX);\n        vec4 colorY = textureGrad(sam, uvY, duvdxY, duvdyY);\n        vec4 colorZ = textureGrad(sam, uvZ, duvdxZ, duvdyZ);\n\n        // Color interpolation\n        color = colorX * weights.x + \n                colorY * weights.y + \n                colorZ * weights.z;\n    }\n        \n    #ifdef SHOWBLEND\n        vec3 mask = step(abs(weights - 0.1), vec3(LINETHICKNESS));\n        return vec4(max(mask, color.xyz), color.w);\n    #else\n        return color;\n    #endif\n}\n\n// Triplanar with branching where a samples is 100% and 3 samples otherwise\n#define JUST_ABOVE_ZERO (1.0 / float(0xffffU))\n#define JUST_BELOW_ONE (1.0 - JUST_ABOVE_ZERO)\nvec4 lessBanchingTriplanar( in sampler2D sam, in vec3 position, in vec3 normal, in float contrast ){\n    // Alpha Mask for blending\n    vec3 weights = abs(normal); \n    \n    // Normalize alpha to sum=1\n    weights = weights / (weights.x + weights.y + weights.z);\n    \n    // Apply contrast \n    weights = straightContrast(weights, contrast); // increase contrast    \n\n    // Coordinate projections\n    vec2 uvX = position.yz;\n    vec2 uvY = position.zx;\n    vec2 uvZ = position.xy;\n    \n    // Mip caculation as the automatic ones don't work\n    vec3 duvwdx = dFdx(position);\n    vec3 duvwdy = dFdy(position);\n    \n    // Partial Derivative Projection\n    vec2 duvdxX = duvwdx.yz; \n    vec2 duvdyX = duvwdy.yz;\n    vec2 duvdxY = duvwdx.zx; \n    vec2 duvdyY = duvwdy.zx;\n    vec2 duvdxZ = duvwdx.xy; \n    vec2 duvdyZ = duvwdy.xy;\n    \n    vec4 color;\n    if (weights.x > JUST_BELOW_ONE) {\n        // Sample X Side\n        color = textureGrad(sam, uvX, duvdxX, duvdyX);\n        \n    } else if (weights.y > JUST_BELOW_ONE) {\n        // Sample Y Side\n        color = textureGrad(sam, uvY, duvdxY, duvdyY);\n    \n    } else if (weights.z > JUST_BELOW_ONE) {\n        // Sample Z Side\n        color = textureGrad(sam, uvZ, duvdxZ, duvdyZ);\n        \n    } else {\n        // Samples all 3 \n        vec4 colorX = textureGrad(sam, uvX, duvdxX, duvdyX);\n        vec4 colorY = textureGrad(sam, uvY, duvdxY, duvdyY);\n        vec4 colorZ = textureGrad(sam, uvZ, duvdxZ, duvdyZ);\n\n        // Color interpolation\n        color = colorX * weights.x + \n                colorY * weights.y + \n                colorZ * weights.z;\n    }\n        \n    #ifdef SHOWBLEND\n        vec3 mask = step(abs(weights - 0.1), vec3(LINETHICKNESS));\n        return vec4(max(mask, color.xyz), color.w);\n    #else\n        return color;\n    #endif\n}\n\n// Triplanar with nested branching, using texture grad to fix edges\nvec4 NestedBranchingTriplanar( in sampler2D sam, in vec3 position, in vec3 normal, in float contrast ){\n    // Alpha Mask for blending\n    vec3 weights = abs(normal); \n    \n    // Normalize alpha to sum=1\n    weights = weights / (weights.x + weights.y + weights.z);\n    \n    // Apply contrast \n    weights = straightContrast(weights, contrast); // increase contrast    \n    \n    // Coordinate projections\n    vec2 uvX = position.yz;\n    vec2 uvY = position.zx;\n    vec2 uvZ = position.xy;\n    \n    // Mip caculation as the automatic ones don't work\n    vec3 duvwdx = dFdx(position);\n    vec3 duvwdy = dFdy(position);\n    \n    // Partial Derivative Projection\n    vec2 duvdxX = duvwdx.yz; \n    vec2 duvdyX = duvwdy.yz;\n    vec2 duvdxY = duvwdx.zx; \n    vec2 duvdyY = duvwdy.zx;\n    vec2 duvdxZ = duvwdx.xy; \n    vec2 duvdyZ = duvwdy.xy;\n    \n    // Precalculate boolean statments for branchnig\n    bool sampleX = weights.x > JUST_BELOW_ONE;\n    bool sampleY = weights.y > JUST_BELOW_ONE;\n    bool sampleZ = weights.z > JUST_BELOW_ONE;\n    bool sampleYZ = weights.x < JUST_ABOVE_ZERO;\n    bool sampleXZ = weights.y < JUST_ABOVE_ZERO;\n    bool sampleXY = weights.z < JUST_ABOVE_ZERO;\n    \n    vec4 color;\n    if (sampleX || sampleY || sampleZ) {\n        // In case just one is visible\n        // Find roughly the largest UVs\n        vec2 uvSingle;\n        vec2 ddxSingle;\n        vec2 ddySingle;\n        if (sampleX) {\n            // X Side\n            uvSingle = uvX;\n            ddxSingle = duvdxX;\n            ddySingle = duvdyX;\n\n        } else if (sampleY) {\n            // Y Side\n            uvSingle = uvY;\n            ddxSingle = duvdxY;\n            ddySingle = duvdyY;\n\n        } else {\n            // Z Side\n            uvSingle = uvZ;\n            ddxSingle = duvdxZ;\n            ddySingle = duvdyZ;\n        }\n    \n        // sample Single\n        color = textureGrad(sam, uvSingle, ddxSingle, ddySingle);\n        \n    } else if (sampleYZ || sampleXZ || sampleXY) {\n        // In Case two values are Blending         \n        vec2 uvDoubleA;\n        vec2 uvDoubleB;\n        vec2 ddxDoubleA;\n        vec2 ddyDoubleA;\n        vec2 ddxDoubleB;\n        vec2 ddyDoubleB;\n        vec2 weightsDouble;\n        if (sampleYZ) {\n            // YZ Side\n            uvDoubleA = uvY;\n            ddxDoubleA = duvdxY;\n            ddyDoubleA = duvdyY;\n            \n            uvDoubleB = uvZ; \n            ddxDoubleB = duvdxZ;\n            ddyDoubleB = duvdyZ;\n\n            weightsDouble = vec2(weights.y, weights.z);\n\n        } else if (sampleXZ) {\n            // XZ Side\n            uvDoubleA = uvX;\n            ddxDoubleA = duvdxX;\n            ddyDoubleA = duvdyX;\n            \n            uvDoubleB = uvZ;\n            ddxDoubleB = duvdxZ;\n            ddyDoubleB = duvdyZ;\n\n            weightsDouble = vec2(weights.x, weights.z);\n\n        } else {\n            //  XY Side\n            uvDoubleA = uvX;\n            ddxDoubleA = duvdxX;\n            ddyDoubleA = duvdyX;\n            \n            uvDoubleB = uvY;   \n            ddxDoubleB = duvdxY;\n            ddyDoubleB = duvdyY;\n            \n            weightsDouble = vec2(weights.x, weights.y);\n        }\n        \n        // Samples 2 Sides\n        vec4 colorX = textureGrad(sam, uvDoubleA, ddxDoubleA, ddyDoubleA);\n        vec4 colorY = textureGrad(sam, uvDoubleB, ddxDoubleB, ddyDoubleB);\n        \n        // Color interpolation\n        color = colorX * weightsDouble.x + \n                colorY * weightsDouble.y;\n                \n    } else {\n        // Samples all 3 \n        vec4 colorX = textureGrad(sam, uvX, duvdxX, duvdyX);\n        vec4 colorY = textureGrad(sam, uvY, duvdxY, duvdyY);\n        vec4 colorZ = textureGrad(sam, uvZ, duvdxZ, duvdyZ);\n        \n        // Color interpolation\n        color = colorX * weights.x + \n                colorY * weights.y + \n                colorZ * weights.z;\n    } \n                                    \n    #ifdef SHOWBLEND\n        vec3 mask = step(abs(weights - 0.1), vec3(LINETHICKNESS));\n        return vec4(max(mask, color.xyz), color.w);\n    #else\n        return color;\n    #endif\n}\n\n// Triplanar with nested branching each should hide the Mip edges ... but branching creates new edges?\nvec4 FixNestedBranchingTriplanar( in sampler2D sam, in vec3 position, in vec3 normal, in float contrast ){\n    // Alpha Mask for blending\n    vec3 weightsO = abs(normal); \n    \n    // Normalize alpha to sum=1\n    weightsO = weightsO / (weightsO.x + weightsO.y + weightsO.z);\n    \n    // Apply contrast \n    vec3 weights = straightContrast(weightsO, contrast); // increase contrast    \n\n    // Coordinate projections\n    vec2 uvX = position.yz;\n    vec2 uvY = position.zx;\n    vec2 uvZ = position.xy;\n        \n    vec4 color;    \n    if (any(greaterThan(weights, vec3(JUST_BELOW_ONE)))) {\n        // In case just one is visible\n        // Find roughly the largest UVs\n        vec2 uvSingle;\n        if (weights.x > 0.5) {\n            // X Side\n            uvSingle = uvX;\n\n        } else if (weights.y > 0.5) {\n            // Y Side\n            uvSingle = uvY;\n\n        } else {\n            // Z Side\n            uvSingle = uvZ;\n        }\n    \n        // sample Single\n        color = texture(sam, uvSingle);\n        \n    } else if (any(greaterThan(vec3(JUST_ABOVE_ZERO), weights))) {\n        // In Case two values are Blending         \n        vec2 uvDoubleA;\n        vec2 uvDoubleB;\n        vec2 weightsDouble;\n        if (weightsO.x < weightsO.y && weightsO.x < weightsO.z) {\n            // YZ Side\n            uvDoubleA = uvY;\n            uvDoubleB = uvZ;   \n\n            weightsDouble = vec2(weights.y, weights.z);\n\n        } else if (weightsO.y < weightsO.z) {\n            // XZ Side\n            uvDoubleA = uvX;\n            uvDoubleB = uvZ; \n\n            weightsDouble = vec2(weights.x, weights.z);\n\n        } else {\n            //  XY Side\n            uvDoubleA = uvX;\n            uvDoubleB = uvY;   \n\n            weightsDouble = vec2(weights.x, weights.y);\n        }\n        \n        // Samples 2 Sides\n        vec4 colorX = texture(sam, uvDoubleA);\n        vec4 colorY = texture(sam, uvDoubleB);\n        \n        // Color interpolation\n        color = colorX * weightsDouble.x + \n                colorY * weightsDouble.y;\n                \n    } else {\n        // Samples all 3 \n        vec4 colorX = texture(sam, uvX);\n        vec4 colorY = texture(sam, uvY);\n        vec4 colorZ = texture(sam, uvZ);\n        \n        // Color interpolation\n        color = colorX * weights.x + \n                colorY * weights.y + \n                colorZ * weights.z;\n    } \n                                    \n    #ifdef SHOWBLEND\n        vec3 mask = step(abs(weights - 0.1), vec3(LINETHICKNESS));\n        return vec4(max(mask, color.xyz), color.w);\n    #else\n        return color;\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 dir = sphereNormals(uv);\n\n    // if you get around 144 fps use a higher repeat value\n    vec4 test;\n    for(int i=0; i<REPEAT; i++) {\n        float mut = (float(i)/float(REPEAT)); // permutation each iteration\n            \n        // use which ever you wish to test\n        #if TEST == 0\n            test += uniplanarIfDitheredMips(iChannel0, dir + mut, dir - mut, fragCoord + mut, CONTRAST);\n        #elif TEST == 1\n            test += uniplanarIfMips(iChannel0, dir + mut, dir - mut, fragCoord + mut, CONTRAST);\n        #elif TEST == 2\n            test += uniplanarIf(iChannel0, dir + mut, dir - mut, fragCoord + mut, CONTRAST);\n        #elif TEST == 3\n            test += uniplanarLerp(iChannel0, dir + mut, dir - mut, fragCoord + mut, CONTRAST);\n        #elif TEST == 4\n            test += biplanar(iChannel0, dir + mut, dir - mut, CONTRAST);\n        #elif TEST == 5\n            test += triplanar(iChannel0, dir + mut, dir - mut, CONTRAST);\n        #elif TEST == 6\n            test += branchingTriplanar(iChannel0, dir + mut, dir - mut, CONTRAST);\n        #elif TEST == 7\n            test += lessBanchingTriplanar(iChannel0, dir + mut, dir - mut, CONTRAST);\n        #elif TEST == 8\n            test += NestedBranchingTriplanar(iChannel0, dir + mut, dir - mut, CONTRAST);\n        #else\n            test += FixNestedBranchingTriplanar(iChannel0, dir + mut, dir - mut, CONTRAST);\n        #endif\n    }\n    \n    #if REPEAT > 1\n        // Ensure test vector stays in visible range\n        test = fract(test);\n    #endif\n\n    // Output to screen\n    fragColor = test;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.1415926536\n\n// sphere normals form morgan3d https://www.shadertoy.com/view/4dsGD2\nvec3 sphereNormals(vec2 uv) \n{\n    float theta = (1.0 - uv.y) * PI;\n\tfloat phi   = uv.x * PI * 2.0;\n    \n    float sinTheta = sin(theta);    \n    \n    // Equation from http://graphicscodex.com  [sphry]\n\tvec3 dir = vec3(sinTheta * sin(phi),\n                    cos(theta), \n                    sinTheta * cos(phi));\n    return dir;\n}\n\n// \"NEXT GENERATION POST PROCESSING IN CALL OF DUTY: ADVANCED WARFARE\"\n// https://advances.realtimerendering.com/s2014/index.html#_NEXT_GENERATION_POST\nfloat InterleavedGradientNoise( vec2 uv )\n{\n    const vec3 magic = vec3( 0.06711056, 0.00583715, 52.9829189 );\n    return fract( magic.z * fract( dot( uv, magic.xy ) ) );\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec3 smoothContrast(vec3 alpha, float contrast) {\n    // increase steepness using power\n    vec3 powAlpha = pow(alpha, vec3(contrast));\n    \n    // normalize back to precentage of 1\n    return powAlpha/(powAlpha.x + powAlpha.y + powAlpha.z);\n}\n\n// Linearly increases contrast of Alpha\n// See: https://www.desmos.com/calculator/hs1nsjb32q\nfloat straightContrast(float alpha, float contrast) {\n    return clamp(contrast * (alpha - 0.5) + 0.5, 0., 1.);\n}\n\n// Straight Contrast to 3 Barycentric Weights, oh the pain\n// See: https://www.desmos.com/calculator/n23ntt1nys\nvec3 straightContrast(vec3 weights, float contrast) {\n    // Offset of weights to move towards the center\n    // InverseStraightContrast(0)*(1/3)\n    float offset = (contrast-1.) / (6. * contrast);\n\n    // Merge the offset with the diagonal offsets\n    float offsetA = min(offset, min(weights.y, weights.z) * 0.5);\n    float offsetB = min(offset, min(weights.x, weights.z) * 0.5);\n\n    // Apply the contrast to the merged weights\n    float contrastA = straightContrast(weights.x + offsetA, contrast);\n    float contrastB = straightContrast(weights.y + offsetB, contrast);\n    // No proper calculation needed as sum(weights)=1\n    float contrastC = 1. - contrastA - contrastB; \n        \n    // merge into vector\n    return vec3(contrastA, contrastB, contrastC);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}