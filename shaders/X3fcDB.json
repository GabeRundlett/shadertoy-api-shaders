{
    "Shader": {
        "info": {
            "date": "1726774704",
            "description": "like algae or something, idk it looks cool",
            "flags": 0,
            "hasliked": 0,
            "id": "X3fcDB",
            "likes": 8,
            "name": "underwater Algae thinguies",
            "published": 3,
            "tags": [
                "sea",
                "algae"
            ],
            "usePreview": 0,
            "username": "Bagdaja",
            "viewed": 105
        },
        "renderpass": [
            {
                "code": "\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n\n// I got this from https://iquilezles.org/articles/palettes/ \n// and used \n// http://dev.thi.ng/gradients/\nvec3 grad( in float t)\n{\n    vec3 a = vec3(0.586, 0.778, 0.852);\n    vec3 b = vec3(0.780, 0.090, 0.992);\n    vec3 c = vec3(1.253, 0.752, 1.184);\n    vec3 d = vec3(1.562, 2.669, 1.422);\n\n    return a + b*cos( 6.283185*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float resProp = iResolution.x/iResolution.y;\n    \n    //normalize\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y; \n    \n    //how many ropes\n    const float thCount=89.;\n    \n    \n    float height = (0.5+uv.y*0.5);\n    \n    float str = 0.;\n    float dustStr = 0.;\n    vec3 threadCol;\n    vec3 dustCol;\n    \n    \n    for(float i=0.; i<thCount ;i+=1.0){\n    \n        float depth = 1.- i/thCount; \n        \n        //2 random values depending on the i\n        float randI = rand(vec2(i));\n        float randI2 = rand(vec2(randI));\n        \n        \n        float randFreqAu = 0.3+randI*0.6;\n        float fi1 = -uv.y+iTime*randFreqAu*0.23+i;\n        float fi2 = -uv.y+iTime*randFreqAu*0.335+i;\n\n        \n        \n        \n        float amp = (1.-depth) // the deeper the rope the lesser the amplitude, because the rope is smaller\n        \n        *(0.5-pow(uv.y,2.)) //the middle parts of the rope can oscilate even more, thus the amplitude is increased (test different heights, it's cool ;) )\n        \n        *0.8*(randI*cos(fi1)+(1.-randI)*-sin(fi2)); //the peaks of the sin+cos wave are reduced \n                                                    //(used the derivatives of the wave equation for that) \n        \n\n\n        float x = resProp*(randI*2.-1. ) //finding a random x coord depending on the resolution\n        \n        +(randI*sin(fi1)+(1.-randI)*cos(fi2))*amp; // the actual wave equation, multiplied by the amp\n        \n        \n        //str of the rope color\n        str = max(str,\n        pow(1.2-depth*0.6,2.) // the depth of the rope makes it more dark, simulating like shade and so\n        *smoothstep(0.,1.,1.-height) //the higher part of the image is also darkes\n        *smoothstep(0.97+depth*0.02,1.,1.-abs(uv.x-x)) // the first param of the smoothstep will make the deeper ropes thinner\n        );\n        \n        threadCol = str*grad(.5+0.5*sin(iTime*(depth+0.1)+depth)); //I get the color depending on the depth and the time\n            \n\n        dustStr = max(dustStr,\n        smoothstep(0.99,1.,1.-distance(uv,vec2((randI*2.-1.)*resProp+0.1*(randI*sin(randI*iTime)+(1.-randI)*cos(randI2*iTime)),mod(iTime*randI2*0.1+randI2,1.2)*2.-1.1)))\n        ); //this is just the random dust particles\n        \n        dustCol = dustStr*vec3(1.); \n    }\n        if(dustStr>str){\n            fragColor = vec4(dustCol,1.);\n            return;\n        }\n        fragColor.xy = threadCol.xy;\n        fragColor.z = threadCol.z+0.3;\n        return;\n   \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}