{
    "Shader": {
        "info": {
            "date": "1615824719",
            "description": "grid blend test",
            "flags": 0,
            "hasliked": 0,
            "id": "fsX3W8",
            "likes": 5,
            "name": "gridblend",
            "published": 3,
            "tags": [
                "grid",
                "blend",
                "hex",
                "tri"
            ],
            "usePreview": 0,
            "username": "Del",
            "viewed": 271
        },
        "renderpass": [
            {
                "code": "// Simple grids (SST)\n//\n// Feel free to optimize, golf and generally improve them :)\n//\n// Del - 15/03/2021\n//\n//\n// will it blend? er, not really\n\nvec4 HexGrid(vec2 uv, out vec2 id)\n{\n    uv *= mat2(1.1547,0.0,-0.5773503,1.0);\n    vec2 f = fract(uv);\n    float triid = 1.0;\n\tif((f.x+f.y) > 1.0)\n    {\n        f = 1.0 - f;\n     \ttriid = -1.0;\n    }\n    vec2 co = step(f.yx,f) * step(1.0-f.x-f.y,max(f.x,f.y));\n    id = floor(uv) + (triid < 0.0 ? 1.0 - co : co);\n    co = (f - co) * triid * mat2(0.866026,0.0,0.5,1.0);    \n    uv = abs(co);\n    return vec4(0.5-max(uv.y,abs(dot(vec2(0.866026,0.5),uv))),length(co),co);\n}\n\n// EquilateralTriangle distance\nfloat sdEqTri(in vec2 p)\n{\n    const float k = 1.7320508;//sqrt(3.0);\n    p.x = abs(p.x) - 0.5;\n    p.y = p.y + 0.5/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -1.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\n// triangle grid equiv\nvec4 TriGrid(vec2 uv, out vec2 id)\n{\n    const vec2 s = vec2(1, .8660254); // Sqrt (3)/2\n    uv /= s;\n    float ys = mod(floor(uv.y), 2.)*.5;\n    vec4 ipY = vec4(ys, 0, ys + .5, 0);\n    vec4 ip4 = floor(uv.xyxy + ipY) - ipY + .5; \n    vec4 p4 = fract(uv.xyxy - ipY) - .5;\n    float itri = (abs(p4.x)*2. + p4.y<.5)? 1. : -1.;\n    p4 = itri>0.? vec4(p4.xy*s, ip4.xy) : vec4(p4.zw*s, ip4.zw);  \n\n    vec2 ep = p4.xy;\n    ep.y = (ep.y + 0.14433766666667*itri) * itri;\n    float edge = sdEqTri(ep); // dist to edge\n    id = p4.zw;\n    id *= mat2(1.1547,0.0,-0.5773503,1.0); // adjust ID (optional)\n    p4.y+=0.14433766666667*itri;\n    return vec4(abs(edge),length(p4.xy),p4.xy);\n}\n\n// simple square grid equiv\nvec4 SquareGrid(vec2 uv, out vec2 id)\n{\n    vec2 fs =  fract(uv)-0.5;\n    id = floor(uv);\n    id *= mat2(1.1547,0.0,-0.5773503,1.0); // adjust ID (optional)\n    vec2 d = abs(fs)-0.5;\n    float edge = length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n    return vec4(abs(edge),length(fs),fs.xy);\n}\n\nfloat hbar(vec2 p, float nline, float t)\n{\n    return 0.5+sin((p.y*nline)+t)*0.5;\n}\n\n\n#define\tPI 3.14159\n#define\tTAU 6.28318\n// out: 0->val->0\nfloat SmoothTri2(float t, float val)\n{\n    return val * (1.0-(0.5+cos(t*TAU)*0.5));\n}\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float xx = ((fragCoord.x-.5*iResolution.x) / iResolution.x)+0.5;\n\n    // dirty grid blend!\n    vec2 id,id2;\n    vec4 h,h2;\n\t\n    //h = SquareGrid(uv*8.0, id2);\n\tuv *= rot(t*0.1);\n    h2 = HexGrid(uv*16.0, id2);\n    h = TriGrid(uv*8.0, id);\n\t\n\tfloat tt = SmoothTri2(fract(t*0.2),3.0)-1.0;\n\t\n\ttt = clamp(tt,0.0,1.0);\n\t\n\th = mix(h,h2,tt);\n\tid = mix(id,id2,tt);\n\t\n\n    vec3 bordercol = vec3(1.0,1.0,1.0);\n    vec3 shapecol = vec3(0.15,0.25,0.05);\n    \n    // just do a simple patterned shape tint based on cell IDs\n    float patternVal = .5; // 4.1\n    float cm = 1.0 + pow(abs(sin(length(id)*patternVal + t*0.65)), 4.0);\t// pulse mult\n    cm *= 1.0 + (hbar(h.zw,100.0,t*12.0)*0.1);\t\t\t\t\t// bars mult\n    shapecol *= cm;\n    \n    // Output to screen\n    vec3 finalcol = mix(bordercol,shapecol, smoothstep(0.0,0.035,h.x)); // edge\n    finalcol = mix(bordercol,finalcol, smoothstep(0.0,0.065,h.y));  // centre\n    \n    // vignetting\n    uv = fragCoord/iResolution.xy;\n\tfinalcol *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n\n    //finalcol = vec3(h.zw,0.0); // just show cell uv\n    \n    // divider lines\n    //float div = (1.0-max( step(abs(xx-0.33),0.0025),step(abs(xx-0.66),0.0025)));\n    fragColor = vec4(finalcol ,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}