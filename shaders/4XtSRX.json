{
    "Shader": {
        "info": {
            "date": "1719398242",
            "description": "A whole new flag for people who identify as queer coders.\nThe flag is based on the progress rainbow pride flag, with the addition of a rotating RGB coloured cube on the right hand side. \nDone for #WCCChallenge",
            "flags": 0,
            "hasliked": 0,
            "id": "4XtSRX",
            "likes": 16,
            "name": "Queer coder flag",
            "published": 3,
            "tags": [
                "raymarching",
                "flag",
                "queer",
                "lgbtq"
            ],
            "usePreview": 0,
            "username": "Alie",
            "viewed": 332
        },
        "renderpass": [
            {
                "code": "// Quick and dirty 2d rotation function\n#define r2d(p,a) p = cos(a) * p + sin(a) * vec2(-p.y, p.x)\n// A small value, used in various places\n#define Eps 0.001\n// The light direction\n#define LightDir normalize(vec3(2,2,-1))\n\n// Distance function for a box at the origin\nfloat boxDist(vec3 p, vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)),0.0);\n}\n\n// Distance function. Returns distance, uv coords for flag\nvec3 df(vec3 p) {\n    // Add some ripples, it's just a bunch of moving sin waves\n    p.z += sin(p.x * 4. - iTime + \n        sin(p.y * 3. - iTime + \n            sin(p.x * 7. - iTime * 1.7 + \n                sin(p.y * 9. + iTime * 2.1 +\n                    sin(p.x * 13. - iTime * 2.3)\n                    ) / 3.))) / 10.;\n    return vec3(\n        boxDist(p, vec3(1, .7, Eps)) * .5,\n        p.xy\n    );\n}\n\n// Get surface normals\nvec3 norm(vec3 p) {\n    vec2 e = vec2(Eps, 0.);\n    return normalize(vec3(\n        df(p + e.xyy).x - df(p - e.xyy).x,\n        df(p + e.yxy).x - df(p - e.yxy).x,\n        df(p + e.yyx).x - df(p - e.yyx).x\n    ));\n}\n\n// Lighting\nfloat shade(vec3 p, vec2 uv) {\n    // Get normals\n    vec3 n = norm(p);\n    // Get \"cloth texture\" by adding 2 copies of the texture in iChannel0\n    // These are stretched vertically, the 2nd copy is rotated 90 to get cloth\n    float tex = texture(iChannel0, uv * 4.).r * .5 + .5;\n    vec3 nTex = (\n        texture(iChannel0, uv * vec2(2., .05)).rgb +\n        texture(iChannel0, uv.yx * vec2(2., .05)).rgb\n    ) - 1.;\n    \n    // Add the cloth to the normal to add a 'cloth normal map'\n    n = normalize(n + nTex / 10.);\n    // Simple lighting\n    return (dot(n, LightDir)) * .5 + .5;\n}\n\n// Flag colour\nvec3 color(vec2 uv) {\n    // Map the UVs to 0..1\n    uv = (-uv / vec2(2, 1.4)) + .5;\n    \n    // Vertical stripe colors\n    const vec3 vCols[6] = vec3[6](\n        vec3(1,0,0),\n        vec3(1,.5,0),\n        vec3(1,1,0),\n        vec3(0,1,0),\n        vec3(.2,.2,1),\n        vec3(.7,0,.7)\n        );\n    // Vertical stripe index\n    int vStripe = int(uv.y * 6.);\n    // Set the color for the vertical stripe\n    vec3 col = vCols[vStripe];\n    \n    //mirror y about centre\n    uv.y = abs(uv.y - .5);\n    // Subtract y from x and offset to get the triangle shape\n    uv.x -= uv.y + .5;\n    \n    // If x is positive we're inside the triangle\n    if (uv.x > 0.0) {\n        // Triangle colours\n        const vec3 dCols[5] = vec3[5](\n            vec3(0),\n            vec3(.34, .2, .08),\n            vec3(.4, .8, 1),\n            vec3(1, .65, .75),\n            vec3(1)\n        );\n        // Diagonal stripe index\n        int dStripe = min(int(uv.x * 11.), 4);\n        // Apply the colour\n        col = dCols[dStripe];\n    }\n    return col;\n}\n\n// Traces the cube, and replaces the colour if the ray hits\nvoid traceCube(vec2 uv, inout vec3 col) {\n    // Only trace the cube if we're on the right side of the flag\n    if (uv.x > 0.) {\n        // Offset the uv so the origin is on the right of the flag\n        uv.x -= .5;\n        // Ray origin is based on the UVs, because we're doing parallel\n        //  projection not perspective.\n        vec3 p = vec3(uv * 2., -3);\n        // Rays all go the same way ofc\n        vec3 dir = vec3(0,0,1);\n        \n        // Rotate both position and direction by the same amount\n        //  This spins the cube in place\n        r2d(p.xz, iTime * .8324 + .5);\n        r2d(dir.xz, iTime * .8324 + .5);\n        r2d(p.xy, iTime * .7326 + .5);\n        r2d(dir.xy, iTime * .7326 + .5);\n        \n        // The ray intersects the cube twice, get both\n        vec3 a = (vec3(-.5) -p) / dir, // vec3(-.5) is half a cube of size 1\n        b = (vec3(.5) - p) / dir, // the other half of the cube\n        \n        // Sort them to get the furthest and nearest intersection\n        far = max(a, b), // furthest\n        near = min(a, b); // nearest\n        \n        float fPlane = min(far.x, min(far.y, far.z)), // furthest plane\n        nPlane = max(near.x, max(near.y, near.z)); // nearest plane\n        \n        // If nearest is further than furthest, there's no intersection, exit\n        // Also exit if the cube is behind us\n        if (nPlane >= fPlane || nPlane<0.) return;\n        \n        // Get the normals for the cube. I can't remember offhand how i did this lol\n        vec3 norm = normalize(step(Eps, abs(a - nPlane)) - step(Eps, abs(b - nPlane))) * sign(nPlane);\n        \n        // Color is based on normals, abs() to make them always positive\n        col = abs(norm);\n    }\n}\n\n\n// Raymarch the flag\nvec3 rm(vec3 p, vec3 dir) {\n    // 100 iterations (reduce to speed up, increase to reduce artefacts)\n    for (int i=0; i<100; i++) {\n        // Get the distance + flag UVs for the current point in space\n        vec3 d = df(p);\n        \n        // if the point is very close to the surface, assume we hit it\n        if (d.x < Eps) {\n            // Get the flag colour from the UVs\n            vec3 col = color(d.yz);\n            // Trace the cube and replace the color if we hit it\n            traceCube(d.yz, col);\n            // Apply shading and return the final colour\n            return col * shade(p, d.yz);\n        }\n        \n        // We didn't hit, it's safe to move forward along the ray\n        p += dir * d.x;\n    }\n    \n    // Ray didn't hit, return sky colour\n    return mix(vec3(.5,.5,1), vec3(0,0,1), pow(abs(dir.y)+0.01, 2.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized uv coordinates (from -1 to 1, adjusted for aspect ratio)\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.yy;\n    \n    // Camera position\n    vec3 p = vec3(0,0,-2),\n    \n    // Ray direction based on uv so rays spread out\n    d = normalize(vec3(uv, 2));\n    \n    // Rotate both position and direction by the same amount\n    //  This spins the flag in place\n    r2d(p.yz, sin(iTime / 2.)/2.);\n    r2d(d.yz, sin(iTime / 2.)/2.);\n    r2d(p.xz, iTime / 3.);\n    r2d(d.xz, iTime / 3.);\n\n    // Raymarch to get the pixel colour\n    vec3 col = rm(p, d);\n    // Apply some gamma so it looks nicer\n    col = pow(col, vec3(.7));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}