{
    "Shader": {
        "info": {
            "date": "1609535662",
            "description": "Perlin Noise",
            "flags": 0,
            "hasliked": 0,
            "id": "tltczj",
            "likes": 0,
            "name": "Dan's Perlin Noise",
            "published": 3,
            "tags": [
                "noise",
                "perlinnoise",
                "perlin",
                "random"
            ],
            "usePreview": 0,
            "username": "danielsturk",
            "viewed": 129
        },
        "renderpass": [
            {
                "code": "const float perlinSize = 15.; // how many unique tiles to generate in the x/y direction\nconst float repeat = 2.; // useful for checking that the wrapping math is correct\nconst float fixedRes = 512.; // zero to turn off the red area\nconst int numSamples = int(log2(fixedRes / perlinSize / repeat)); // smallest sample distance will be greater than the size of a single pixel\nfloat seed = .52161251235;\n\nfloat rand(float x) {\n    float y = x;\n    y = y * 1.5215126221 + .6123541255;\n    y = fract(y) * (x * 4.6214215621 + .9621412541);\n    y = y * 5.5215126221 + .7123251262;\n    return fract(y);\n}\n\nfloat rand(vec2 x) {\n    return rand(rand(x.x) * 15915.5621453213213 + x.y * 5.12451254521432145);\n}\n\nfloat perlinLayer(vec2 uv, float uvScale, float seed) {\n    uv *= uvScale;\n    vec2 cell0 = floor(uv);\n    vec2 cell1 = cell0 + vec2(1.);\n    vec2 t = uv - cell0;\n    \n    cell0 = mod(cell0, uvScale * perlinSize);\n    cell1 = mod(cell1, uvScale * perlinSize);\n    \n    float x0y0 = rand(rand(vec2(cell0.x, cell0.y)) + seed);\n    float x1y0 = rand(rand(vec2(cell1.x, cell0.y)) + seed);\n    float x0y1 = rand(rand(vec2(cell0.x, cell1.y)) + seed);\n    float x1y1 = rand(rand(vec2(cell1.x, cell1.y)) + seed);\n    \n    float y0 = mix(x0y0, x1y0, t.x);\n    float y1 = mix(x0y1, x1y1, t.x);\n    return mix(y0, y1, t.y);\n}\n\nfloat perlinNoise2D(vec2 uv, float seed) {\n    const bool threshold = false;\n    const bool scaled = true; // minimize high frequency values?\n    \n    float final = 0.;\n    float weight = 0.;\n    float uvScale = 1.;\n    float invUvScale = 1.;\n    for(int i = 0; i < numSamples; i++) {\n        float val = (perlinLayer(uv, uvScale, seed * 417.321125 + float(i)) - .5);\n        if(scaled) {\n            final += val * invUvScale;\n            weight += invUvScale;\n        } else {\n            final += val;\n            weight++;\n        }\n        uvScale *= 2.;\n        invUvScale *= .5;\n    }\n    final /= weight;\n    \n    return threshold ? (final > 0. ? 1. : 0.) : (final + .5);\n}\n\n// https://stackoverflow.com/questions/2353211/hsl-to-rgb-color-conversion\nfloat hue2rgb(float p, float q, float t){\n    if(t < 0.) t += 1.;\n    if(t > 1.) t -= 1.;\n    if(t < 1./6.) return p + (q - p) * 6. * t;\n    if(t < 1./2.) return q;\n    if(t < 2./3.) return p + (q - p) * (2./3. - t) * 6.;\n    return p;\n}  \nvec3 hslToRgb(float h, float s, float l){\n    vec3 c;\n\n    if(s == 0.){\n        c.r = c.g = c.b = l;\n    } else {\n\n        float q = l < 0.5 ? l * (1. + s) : l + s - l * s;\n        float p = 2. * l - q;\n        c.r = hue2rgb(p, q, h + 1./3.);\n        c.g = hue2rgb(p, q, h);\n        c.b = hue2rgb(p, q, h - 1./3.);\n    }\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv;\n    if(fixedRes == 0.) {\n        uv = fragCoord / iResolution.xy;\n        uv -= .5;\n        uv.x *= iResolution.x / iResolution.y;\n    } else {\n        uv = fragCoord / fixedRes;\n        if(any(greaterThan(uv, vec2(2, 1)))) {\n            fragColor = vec4(1., 0., 0., 1.);\n            return;\n        }\n    }\n    uv *= perlinSize * repeat;\n    \n    vec3 c;\n    if(uv.x > perlinSize * repeat) {\n        // pattern on the right\n        uv.x -= perlinSize * repeat;\n        uv.xy += vec2(\n            perlinNoise2D(uv, seed + 441.),\n            perlinNoise2D(uv, seed + 281.)\n        );\n        // uv += (vec2(perlinNoise2D(uv, seed + 4.), perlinNoise2D(uv, seed + 6.)) - .5) * sin(iTime) * 10.;\n        float val = smoothstep(0., 1., perlinNoise2D(uv, seed + 2.));\n        c = hslToRgb(fract(val), 1., .5);\n    } else {\n        // basic pattern on the left\n        float val = smoothstep(0., 1., perlinNoise2D(uv, seed + 2.));\n        c = vec3(val);\n    }\n    \n    fragColor = vec4(c, 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}