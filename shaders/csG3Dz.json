{
    "Shader": {
        "info": {
            "date": "1679646214",
            "description": "I changed the clouds rendering and added some godrays.\nUse mouse X to change camera angle.",
            "flags": 0,
            "hasliked": 0,
            "id": "csG3Dz",
            "likes": 14,
            "name": "Countryside in Autumn 3",
            "published": 3,
            "tags": [
                "clouds",
                "grass",
                "tree"
            ],
            "usePreview": 0,
            "username": "guil",
            "viewed": 347
        },
        "renderpass": [
            {
                "code": "\nfloat ma1=5.,ma2=1e3;\n\n\n// Signed distance field function.\nfloat field(vec3 p)\n{\n    float ter = -fbm(.2*p.xz+2.)*.3; // Ground\n    ma2=p.y-ter;\n    p.y-=ter;\n    float d=max(ma2,p.y);\n    \n    if(length(p)<10.)p.xz = mod(p.xz+3.,5.)-2.;// Multiply trees\n      \n    float s=1.,s1=s,g=1.4,g1=1.4;\n       \n    mat2 m1 = r2D(2.1);\n    mat2 m2 = r2D(1.15);\n    mat2 m3 = r2D(-.1);\n\n    int j=7;\n    float h=4.;\n    float scale=.7;\n    p/=scale;\n    \n    // Evaluate the tree \n    d=min(d,scale*max(p.y-h,max(-p.y,length(p.xz)-.1/(p.y+.7)))/s);// trunc \n    for(int k=0;k<int(h);k++){\n      vec3 q=p;\n      s=s1;\n      // Evaluate the tree branches\n      for(int i=0;i<j;\n        q.x=abs(q.x),\n        q.z=(i==0)?q.z:abs(q.z), \n        q.y-=1.,\n        q.xz *= m2,\n        q.xy *= m1,\n        q.xz *= m3,\n        q*=g,\n        s*=g,\n        d=min(d,scale*max(q.y-1.,max(-q.y,length(q.xz)-.1/(q.y+.7)))/s),\n        ++i);\n      // Leaves\n      q.y-=1.;      \n      float l = (length(q*vec3(.6,.3,1.))-.3)/s;\n      if(l<d)ma1=max(0.,l), d=l;      \n      // return to trunc\n      p.y-=1.6;\n      p.xz *= -m1,\n      s1*=g1;\n      p*=g1;\n      j -=1;\n      }\n    return d;\n}\n\nconst vec3 sundir = normalize( vec3(-.3,.5,-1.) );\nconst vec3 suncol = vec3(1.,.8,.5);\nconst float low = 5.;\nconst float high = 8.;\n\nfloat cloud(in vec3 p) {\n\tfloat e=max(low-p.y,0.)+max(p.y-high,0.)-.3;\n    p.z += .2*iTime;\n    e += fbm3(p,iTime);\n    return .5*e;\n}\n\nvec3 sky( in vec3 ro, in vec3 rd ,in vec2 res)\n{ \n    // background sky : modified from IQ clouds        \n    float sun = max( dot(sundir,rd), 0.0);    \n    vec3 col = vec3(0.6,0.6,0.78) - abs(rd.y)*0.5*vec3(1.0,0.4,.05); \n    float k = res.x, c = res.y;\n    col += suncol*pow( sun, 500.0 )*(1.-10.*c); \n    // clouds           \n    if(c>.0)\n       col *= 1.-.5*c,\n       col += 3.*(.5+k)*c*suncol,\n       col += 2.*vec3(0.2,0.08,0.04)*pow( sun, 3.0 )*k;    \n    // godrays\n    float sh = 1., t, d;    \n    vec3 q = ro+20.*rd;\n    for(int i=0; i<20; ++i)    \n        t = max((1.+low-q.y)/(.5+rd.y), 0.),\n        d = cloud(q+sundir*t),\n        sh = min(sh,1./(1.+exp(-d))),        \n        q += rd*.6;    \n    col += .7*pow((sh-1.)*sun,2.)*suncol;    \n    return col;\n}\n\n\nvec3 fields( in vec3 ro, in vec3 rd ,in float t)\n{\n     \n     vec3 col;\n    // Colourise ground, branch/trunk, or cherry blossom.\n    \n    vec3 p=ro+rd*t;\n    col =vec3(.75,.6,.4)/1.5;//wood\n    col.rgb +=fbm1(p.zy*.9,0.)/6.;\n    if(ma1<2e-3)col=vec3(1.,.5,.1);//red leaves\n    if(ma2<1e-2||t>12.)//grass\n        col =vec3(.6,1.,.6)/3.,\n        col.rg +=fbm1(p.xz,iTime)/8.;             \n    \n    // Lighting.\n    float d =field(p);\n    float e=1e-2;\n    float d2=field(ro+rd*t+sundir*e);\n    float l=max(0.,(d2-d)/e);\n\n    float d3=field(ro+rd*t+vec3(0,1,0)*e);\n    float l2=max(0.,.5+.5*(d3-d)/e);\n\n    p=ro+rd*(t-1e-3);\n\n    // Directional shadow.\n    t=.1;\n    float sh=1.;\n    for(int i=0;i<30;++i)\n    {\n        d=field(p+sundir*t);\n        sh=min(sh,50.*d+0.3);\n        if(d<1e-4)break;\n        t+=d;\n    }\n\n    col *=1.5*sh*(.2+.8*l)*vec3(1.,1.,.9)*.7+l2*vec3(.85,.85,1.)*.4;\n    return col;\n    \n}\n\nvec3 raycast( in vec3 ro, vec3 rd )\n{\n    float t = 4.,e,e1,f,de=0.,df,d,c=1.,dt=.2,r=1.;\n    vec3 col= vec3(0.),p,skycol;\n    for( int i=0; i<64; i++ )\n\t{                \n        p = ro+t*rd;\n        e = cloud(p), f=field(p),             \n        d = min(f,max(e,.05));\n        t += .9*d;\n        if(e<.001)\n            e1 = cloud(p + dt*sundir),\n            de += max(e1-e,-.0)/dt/(1.+ exp(-32.*e1));\n        c *= 1./(1.+ exp(-32.*e));        \t\n    }\n    skycol = sky(ro,rd,vec2(.1*de,(1.-c)*.1));        \n    if(f>.5)return skycol;\n    col = fields( ro, rd, t);\n    float maxd = 30.;    \n    col = mix(col, skycol, smoothstep(.4, .99, min(t, maxd)/maxd));\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy -.5;\n    uv.x*=iResolution.x/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    float zoom=.8;\n   \n    // Set up camera and primary ray.\n    vec3 ro=1.*vec3(sin(3.0*m.x),0.*m.y+2.,cos(3.0*m.x));\n    vec3 rd=normalize(vec3(uv.xy,zoom));\n    vec3 target=vec3(0,2.,0);\n\n    vec3 w=normalize(target-ro);\n    vec3 u=normalize(cross(w,vec3(0,1,0)));\n    vec3 v=normalize(cross(w,-u));\n\n    rd=mat3(u,v,w)*rd;       \n    \n    fragColor.rgb=clamp(raycast(ro,rd),0.,1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nmat3 m3 = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 ); \n\nmat2 r2D(float a)\n{\n\tfloat si = sin(a);\n\tfloat co = cos(a);\n\treturn mat2(si, co, -co, si);\n}\n\nfloat fbm(vec2 p)//ground\n{\n    float s=.3;\n    mat2 m = r2D(1.);\n    vec2 r= vec2(0.5);\n    for(int i=0;i<7;i++)r+=sin(p), p=m*(p*s+.2*r+.1),s*=1.6;\n    return (r.x+r.y)*.8 - 2.;\n}\n\nfloat fbm1(vec2 p, float t)//grass\n{\n    float s=2.;\n    mat2 m = r2D(1.);\n    vec2 r= vec2(0.);\n    for(int i=0;i<8;i++)r+=(sin(p.yx+.5+.1*t))/s, p=m*p*s+cos(r.yx*s), s*=1.02;\n    return (r.x+r.y)/s;\n}\n\n\nfloat fbm3(vec3 p, float t)//clouds\n{\n    float s=1., r= -4.;\n    p += 4.*cos(.07*p)+5.*sin(.05*p.zyx+1.);\n    p.xz *=.7;\n    vec3 n = vec3(1);\n    for(int i=0;i<8;i++)\n        p = m3*p.zxy,      \n        n+=.8*cos(p*s+.02*t), \n        r+=abs(dot(sin(p*s+n.zxy-1.)/s,vec3(1.))),\n        s*=-1.9;       \n    return -r;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}