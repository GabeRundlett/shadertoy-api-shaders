{
    "Shader": {
        "info": {
            "date": "1584474715",
            "description": "Just mountains",
            "flags": 0,
            "hasliked": 0,
            "id": "3slyz7",
            "likes": 4,
            "name": "Mountains somewhere in space",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "raymarching",
                "distancefield",
                "sdf",
                "mountains"
            ],
            "usePreview": 0,
            "username": "artemvang",
            "viewed": 330
        },
        "renderpass": [
            {
                "code": "const int MAX_MARCHING_STEPS = 256;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 500.0;\nconst float EPSILON = 0.00001;\n\n\nfloat random(vec2 st) {\n    return fract(sin(dot(st, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\n\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n    \n    float a = random(i + vec2(0,0));\n    float b = random(i + vec2(1,0));\n    float c = random(i + vec2(0,1));\n    float d = random(i + vec2(1,1));\n\n    return a + (b-a)*u.x + (c-a)*u.y + (a - b - c + d)*u.x*u.y;\n}\n\nfloat fbm(vec2 st, int octaves) {\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for (int i=0; i<octaves; i++) {\n        float n = noise(st);\n        a += b*n;\n        b *= s;\n        st *= f;\n    }\n\treturn a;\n}\n\n\nfloat sceneSDF(vec3 samplePoint) {\n    return samplePoint.y + fbm(samplePoint.xz, 6);\n}\n\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection) {\n    float dist = 0.001;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 pos = eye + dist * marchingDirection;\n        float d = sceneSDF(pos);\n        if (d < EPSILON) {\n            break;\n        }\n        \n        dist += d*0.4;\n        \n        if (dist >= MAX_DIST) {\n            dist = MAX_DIST;\n            break;\n        }\n    }\n    \n    return dist;\n}\n\n\nfloat softShadow(vec3 eye, vec3 marchingDirection, float max_dist, float w) {\n    float dist = 0.001;\n    float s = 1.0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 pos = eye + dist * marchingDirection;\n        float d = sceneSDF(pos);\n        s = min( s, 0.5+0.5*d/(w*dist) );\n        if( s < 0.0 ) break;\n        dist += d*0.4;   \n    }\n    \n    s = max(s,0.0);\n    \n    return s*s*(3.0-2.0*s);\n}\n   \n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nvec3 estimateNormal(vec3 p) {\n    const float h = 0.0001;\n    #define ZERO (min(iFrame,0)) // non-constant zero\n    vec3 n = vec3(0.0);\n    for(int i = ZERO; i < 4; i++) {\n        vec3 e = 0.5773 * (2.0 * vec3((((i+3)>>1)&1), ((i>>1)&1), (i&1)) - 1.0);\n        n += e * sceneSDF(p + e * h);\n    }\n    return normalize(n);\n}\n\n\nfloat sigmoid(float x) {\n    return 1.0 / (1.0 + exp(-x));\n}\n\n\nvec3 phongIllumination(vec3 eye, vec3 worldDir, float dist) {\n    const vec3 ambientLight = vec3(0.5);\n    vec3 color = ambientLight * 0.2;\n    \n    vec3 diffuseColor = vec3(41., 31., 2.) / 255.;\n    \n\tconst vec3 lightPos = vec3(-10000.0, 10000.0, 0.0);\n    const float lightIntensity = 0.6;\n    \n    vec3 p = eye + worldDir * dist;\n    \n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    \n    float dotLN = dot(L, N);\n    \n    if (dotLN < 0.0) {\n        return color;\n    }\n    \n    diffuseColor = mix(vec3(0.8), diffuseColor, max(N.y, 0.0));\n    \n    float top = sigmoid((p.y + 0.4) * 20.);\n    diffuseColor = mix(diffuseColor, vec3(1.5), top);\n    \n    float shadowMul = softShadow(lightPos, normalize(p - lightPos), length(lightPos - p), .5);\n    color = mix(lightIntensity * (diffuseColor * dotLN), color, shadowMul);\n    return color;\n}\n\nvec3 applyFog(vec3 rgb, vec3 rayOri, vec3 rayDir, float dist) {\n    float fogAmount = 1.0-exp(-dist * .03);\n    vec3  fogColor  = vec3(0.7,0.7,0.65);\n    vec3 foggedColor = mix(rgb, fogColor, fogAmount);\n    \n    float y_dist = max((rayOri + rayDir * dist).y + 1.0, 0.);\n    fogAmount = exp(-y_dist * 5. );\n    foggedColor = mix(foggedColor, vec3(0.7,0.7,0.7), fogAmount);\n    \n    return foggedColor;\n}\n\n\nmat3 viewMatrix(vec3 eye, vec3 lookAt, vec3 up) {\n    vec3 f = normalize(lookAt);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse;\n    if(length(iMouse.xy) >= 1.0) mouse = (2.0 * iMouse.xy - iResolution.xy) / iResolution.xy;\n    else mouse = vec2(0.0);\n    \n\tvec3 viewDir = rayDirection(90.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, .1, iTime * 0.5);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(mouse.x * 3.14 * 4., mouse.y * 3.14 * 4., -1.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = normalize(viewToWorld * viewDir);\n    \n    float dist = shortestDistanceToSurface(eye, worldDir);\n    \n    if (dist >= MAX_DIST - EPSILON) {\n        fragColor = vec4(.7, .7, .65, 1.);\n\t\treturn;\n    }\n    \n    vec3 p = eye + dist * worldDir;\n    \n    vec3 color = phongIllumination(eye, worldDir, dist);\n    \n    //color = applyFog(color, eye, worldDir, dist);\n    \n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}