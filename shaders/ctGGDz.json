{
    "Shader": {
        "info": {
            "date": "1683796791",
            "description": "port of excellent https://twitter.com/kamoshika_vrc/status/1656260144840478720 by @kamoshika\n\nUnrolled and explicited",
            "flags": 0,
            "hasliked": 0,
            "id": "ctGGDz",
            "likes": 32,
            "name": "zoomed maze in 3D",
            "published": 3,
            "tags": [
                "maze"
            ],
            "usePreview": 0,
            "username": "skal",
            "viewed": 463
        },
        "renderpass": [
            {
                "code": "/*\nhttps://twitter.com/kamoshika_vrc/status/1656260144840478720\nfloat i,c=15./PI,d=c,g;\nfor(;i++<99.&&d>1e-4;g+=d){\n  vec3 P=normalize(vec3(FC.xy-r*.5,-r.y))*rotate3D(.9,FC.wzz)*g;\n  P.yz+=1.;\n  vec2 I=ceil(P.xz=vec2(log(d=length(P.xz))-t,atan(P.z,P.x))*c);\n  P.xz-=I;\n  d=max(P.y,(.4-abs(fract((fsnoise(I)<.5?-P.z:P.z)-P.x)-.5))*.7*d/c);\n}\no+=9./i;\n*/\n\nvec3 axis_rotation(vec3 P, vec3 Axis, float angle) {\n  Axis = normalize(Axis);\n  return mix(Axis * dot(P, Axis), P, cos(angle)) + sin(angle) * cross(P, Axis);\n}\n\nfloat fsnoise(vec2 v) {\n  return fract(sin(dot(v, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec3 uv = normalize(vec3(fragCoord.xy - 0.5 * iResolution.xy, -iResolution.y));\n  vec3 dir = axis_rotation(uv, vec3(2.,1.,1.), .9);  // view direction\n  vec3 Po = vec3(0., 1., 1.);  // view origin\n  float wall_thickness = 0.4;\n  float scale = 4.0;\n  float luminosity = 0.5;\n  float steps = 0., distance = 0.;\n  while (++steps < 99.) {\n    vec3 P = Po + dir * distance;\n    float l = length(P.xz);\n    // https://www.osar.fr/notes/logspherical/\n    // switch to 'polar' log-spherical coordinates\n    P.xz = vec2(log(l) - iTime, atan(P.z, P.x)) * scale;\n    vec2 I = ceil(P.xz);   // integer part = cell ID\n    P.xz -= I;  // fractional part\n    // the 'maze' itself:\n    float v = abs(fract((fsnoise(I) < .5 ? -P.z : P.z) - P.x) - .5);\n    v = (wall_thickness - v) * luminosity * l / scale;\n    // here, walls are infinitely high, so we cut them with the plane P.y\n    l = max(P.y, v);\n    // advance the marching\n    distance += l;\n    if (l < 1e-4) break;\n  }\n  fragColor = vec4(10. / steps);  // divide by steps => ~AO\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}