{
    "Shader": {
        "info": {
            "date": "1636674047",
            "description": "This is how Christmas trees are made :-)",
            "flags": 32,
            "hasliked": 0,
            "id": "Ntd3WS",
            "likes": 22,
            "name": "Growing forest",
            "published": 3,
            "tags": [
                "christmas",
                "tree",
                "forest",
                "feedback",
                "buffer",
                "pine"
            ],
            "usePreview": 0,
            "username": "hamtarodeluxe",
            "viewed": 398
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 dc = uv - 0.5;\n    dc.x *= iResolution.x/iResolution.y;\n    vec3 col = texture(iChannel0, uv).rgb;\n    col.rgb *=  1./pow((pow(sqrt(dot(dc * 2., dc * 2.)*.4),2.)+1.),3.);\n    fragColor = vec4(pow(col,vec3(0.45)),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.1459f\n#define RAYMARCHSTEPS 20\n#define SAMPLECOUNT 1024\n\nvec3 fibonacci(int i, int samples, float from, float to, float rot)\n{\n    float phi = 2.3999;\n    float y = 1. - (float(i) / (float(samples) - 1.));\n    y = mix(from, to, y);\n    float radius = sqrt(1. - y * y);\n    float theta = phi * float(i) +rot;\n    float x = cos(theta) * radius;\n    float z = sin(theta) * radius;\n    \n    return vec3(x,y,z);\n}\n\n// Caspule, from IQ's website\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    b += a;\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba) / dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - mix(r*1., 0.5*r, h);\n}\n\nvec3 pFromTime(float time)\n{\n    time /= 60.;\n    time *=0.7;\n    return 0.3*vec3(0.5*sin(time), 0., 0.5*cos(time));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 dc = uv - 0.5;\n    dc.x *= iResolution.x/iResolution.y;\n        \n    // Camera (orthographic)\n    vec3 ro = 5.*vec3(1.5, 1.5, 3.);\n    vec3 lookAt = vec3(0., 0.5, 0.);\n    vec3 up = vec3 (0, 1, 0);\n    vec3 fw = normalize(lookAt-ro);\n    vec3 rd = fw;\n    vec3 right = normalize(cross(fw, up));\n    up = normalize(cross(right,fw));  \n    float cameraScale = 2.5;\n    ro = ro + (up*dc.y + right*dc.x) * cameraScale;\n    \n    // Init. col\n    vec4 col = vec4(0.1, 0.1, 0.1, 1000.0f);\n    vec3 sky = vec3(0.15,0.23,0.5)*0.5;\n    col.rgb = sky;\n    \n    // Vertical pan\n    vec2 oldUv = uv;\n    float texHeight = 1./iResolution.y;\n    float dy = 0.0019f;\n    dy = max(texHeight, floor(dy/texHeight)*texHeight);\n    uv.y += dy;\n    vec4 colOld = texture(iChannel0, uv);\n    // colOld.a != 0. to clear when no info.\n    if (iFrame != 0 && uv.y<1.0f && colOld.a != 0.)\n    {\n        col = colOld;\n    }\n    \n    // Raymarching\n    float t = 0.;\n    bool hasHit = false;\n    vec3 p;\n    float l;\n    vec3 iSecObjPos = vec3(0.);\n    float objID = 0.;\n    int nObj = 20;\n    float minD = 99.;\n    vec3 closestP;\n    float isecU;\n    float frame = float(iFrame);\n    for (int i = 0; i < RAYMARCHSTEPS; i++)\n    {\n        p = ro + rd*t;\n        \n        float d = 99.;\n        for (int j = 0; j < nObj; j++)\n        {\n            uint sampleI = uint((iFrame + j*(SAMPLECOUNT / nObj)) % SAMPLECOUNT);\n            \n            float u = float(sampleI)/ float(SAMPLECOUNT);\n            \n            vec3 root = fibonacci(j, nObj,0.,1.0,0.)*vec3(2.,.6,2.) + (1.-(pow(min(frame/(300.), 1.), 0.5)*u))*vec3(0.,-2.5,0.);\n            root += vec3(0.,0.6,0.);\n            vec3 objectPos = root + pFromTime(frame + float(j)*500.);\n            vec3 objectPosPrev = root + pFromTime(frame-1. + float(j)*500.);\n            float rot = 3.14*float(j)/float(nObj);\n            vec3 L = normalize(fibonacci(SAMPLECOUNT-int(sampleI), SAMPLECOUNT, 0.4+sin(float(j)*500.)*0.2, 0.9,rot));\n            l = mix(1.1, 0.08, u);\n            \n            vec3 y = normalize((objectPosPrev - vec3(0., dy*cameraScale*2., 0.)) - objectPos);\n            vec3 x = cross(y, vec3(1.,0.,0.));\n            vec3 z = cross(x,y);\n            x = cross(z,y);\n            L =  mat3(x,y,z) * L;\n            \n            // Trunk?\n            /*\n            if (u <0.5)\n                L*=0.2;\n            */\n            d = min(d, sdCapsule(p, objectPos, l*L, 0.02f));\n\n\n            minD = min(d, minD);\n            \n            if (d < 0.0001)\n            {\n                isecU = u;\n                iSecObjPos = objectPos;\n                objID = float(j);\n                hasHit = true;\n                break; \n            }\n        }\n        t+=d;\n    }\n        \n    // Shading\n    \n    // Outline\n    if (!hasHit && col.a >= 99.)\n    {\n        float o = smoothstep(0.014,0.019, minD);\n        col.rgb = mix(sky*0.65, col.rgb, o);  \n    }    \n    // Surface\n    if (hasHit && t < col.a)\n    {\n        col.rgb = vec3(0.8*pow(sin(float(iFrame)*3.),2.), 0.7*cos(float(iFrame)*5.5), sin(objID*2.0f));\n        col.rgb = cross(col.rgb, normalize(iSecObjPos));\n        col.rgb = col.rgb * 0.5f + 0.5f;        \n        float uu = min(max((isecU- 0.8)/0.2, 0.),1.);        \n        col.rgb = mix(col.rgb, vec3(1./1.6), uu);\n        col.rgb = col.rgb*pow(length(p.rgb-iSecObjPos)/l, mix(5.,1., uu ))+ 0.05*col.rgb ;\n        float f = max(0., (t-17.));\n        col.rgb = vec3(1.6)*mix(sky*0.7, vec3(col.rgb), exp(-f*0.15));\n        col.a = t;\n    }\n\n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}