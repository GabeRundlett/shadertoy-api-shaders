{
    "Shader": {
        "info": {
            "date": "1634251327",
            "description": "Uses Newtons Method to create Fractals, z^5 = 1",
            "flags": 0,
            "hasliked": 0,
            "id": "NscXWf",
            "likes": 5,
            "name": "Newton_Fractals",
            "published": 3,
            "tags": [
                "newtonsmethod"
            ],
            "usePreview": 0,
            "username": "Hitthesurf",
            "viewed": 237
        },
        "renderpass": [
            {
                "code": "const float h = 0.0001;\nconst int max_iter = 60;\n\nvec2 cjg(in vec2 c) {\n    //Complex conjugate\n\treturn vec2(c.x, -c.y);\n}\n\nvec2 cmul(in vec2 a, in vec2 b) {\n\n    //Complex multiple\n\treturn vec2(a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y);\n}\n\nvec2 cinv(in vec2 a){\n    //Complex inverse, returns 1/a\n    return vec2(a.x,-a.y)/(a.x*a.x+a.y*a.y);\n}\n\nvec2 csin(in vec2 z){\n    return vec2(sin(z.x)*cosh(z.y),cos(z.x)*sinh(z.y));\n}\n\nvec2 ccosh(in vec2 z) {\n    return vec2(cosh(z.x)*cos(z.y), sinh(z.x)*sin(z.y));\n}\n\nvec2 cpow(in vec2 z, in int p){\n    //cpow is slower than using cmul multiple times\n    vec2 zeta = vec2(1.,0.);\n    for (int i = 0; i<10;i++)\n    {\n        if (i<p){zeta = cmul(z,zeta);}\n    }\n    return zeta;\n\n}\n\nfloat cmpxmodsquared(in vec2 a)\n{\n    return (a.x*a.x+a.y*a.y);\n}\n\n\nvec2 f(vec2 z)\n{\n    //return cmul(cmul(z,z),cmul(cmul(z,z),z))-vec2(1.,0.);\n    //return csin(0.5*(z-vec2(3.,0.)))-vec2(0.5,0.);\n    return cpow(z,8)+15.*cpow(z,5)-vec2(16.,0.)+csin(z);\n    //return ccosh(z)-vec2(1.,0.);\n    //return (cpow(z,3)-2.*z+vec2(2.,0.));\n}\n\nvec2 f_p(vec2 z)\n{\n    return (f(z+vec2(h,0.0))-f(z))/h;\n\n}\n\n/*\nvec2 f_p(vec2 z)\n{\n    return 3.*cmul(z,z);\n}\n*/\n\nvec3 Newtons_Method(vec2 z_0)\n{\n    vec2 z = z_0;\n    int counter = 0;\n    for (int i = 0; i <max_iter; i++) \n    {\n            z = z - cmul(cinv(f_p(z)),f(z));\n            if (cmpxmodsquared(f(z)) > h)\n            {\n                counter ++;\n            }\n    }\n    return vec3(z, float(counter));\n    //counter iterations until convergence\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    //Normalises x between -1 and 1\n    vec2 uv = 3.*(fragCoord-0.5*iResolution.xy)/iResolution.x + vec2(0.,0.);\n    \n    \n    // Normalized y pixel coordinates (from -1 to 1)\n    //vec2 uv = 2.*(fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 outputNM = Newtons_Method(uv);\n    float b_ratio =1. - outputNM.z/float(max_iter);  //Brightness ratio\n    vec2 col = outputNM.xy;\n    col = normalize(col);\n    // Output to screen\n    fragColor = b_ratio*vec4(col,-col.x,1.0); //Make sure no +- reals with same imag\n    //fragColor = vec4(col,-col.y,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}