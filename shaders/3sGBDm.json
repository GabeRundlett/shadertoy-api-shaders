{
    "Shader": {
        "info": {
            "date": "1614427130",
            "description": "A simulation of an n-gon rolling along an undulating surface.",
            "flags": 0,
            "hasliked": 0,
            "id": "3sGBDm",
            "likes": 65,
            "name": "Rolling Polygon",
            "published": 3,
            "tags": [
                "collision",
                "terrain",
                "square",
                "physics",
                "polygon",
                "ngon",
                "roll",
                "rigid"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 1014
        },
        "renderpass": [
            {
                "code": "/*\n\n\tRolling Polygon\n\t---------------\n\n\tThis is yet another shader that has been sitting in my account for too \n    long. I was going to code a rolling polyhedron on terrain, but it'd been \n    a while since I'd applied collision-based physics, rigid body or otherwise, \n    so I decided to quickly code up a 2D n-gon rolling across an undulating 1D \n    noisy surface. It took me longer than the five minutes I expected it to \n    take, and that was without applying proper physical forces... The math and \n    physics student in me would be disappointed in what I've become. :D\n    \n    Even so, the idea is very simple: The lowest vertex is always in contact \n    with the ground, so determine which vertex it is and its distance from the \n    contact surface, then use it to offset all vertices... You could use repeat \n    polar coordinates to do this. However, I wanted to test the mid points \n    between vertices to gain a little more ground contact collision accuracy. \n    Plus, I also wanted infrastructure that could deal with haphazard shapes.\n    \n    Anyway, this example is not that important, and the code was rushed. I've \n    also added a heap of window dressing. Everything works, but there'd be \n    cleaner ways to do what I'm doing here, so you can ignore most of it. \n    Having said that, there isn't a great deal of code featuring rolling 2D \n    polygons along an undulating surface, so at least this is a start. :)\n    \n\n\n    Other examples:\n    \n    // Much... much more difficult terrain collision, and far more interesting, \n    // but still based on similar principles. By the way, Dr2 has dozens more\n    // collision based examples worth looking at.\n    Leaping Snakes 2 - dr2\n    https://www.shadertoy.com/view/3lBXWV\n\t\n\n*/\n\n\n// Number of Polygon vertices:\n// Positive integers ranging from 2 to about 8 will work.\n// 2 (just a line) looks a bit odd, but is interesting.\n// Also, the speeds below may need adjusting.\n#define VERTICES 5\n\n\n// Polygon speed and rotation speed -- Technically, the forward motion should be\n// based mostly on the rotation speed, but I'm fudging things a little.\nfloat speed = .4;\n// Higher rotational speeds simulate spinning on the surface... Kind of. :)\nfloat rotSpeed = .42;\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n \n\n// I searched Shadertoy for a robust regular polygon routine and came across\n// the following example:\n//\n// Regular Polygon SDF - BasmanovDaniil\n// https://www.shadertoy.com/view/MtScRG\n//\n// To use the functions in more intensive scenes, some optimization would be\n// necessary, but I've left them in their original form to show the working.\n\nfloat Polygon(vec2 p, float vertices, float radius){\n\n    float segmentAngle = 6.2831853/vertices;\n    \n    float angleRadians = atan(p.x, p.y);\n    float repeat = mod(angleRadians, segmentAngle) - segmentAngle/2.;\n    float inradius = radius*cos(segmentAngle/2.);\n    float circle = length(p);\n    float x = sin(repeat)*circle;\n    float y = cos(repeat)*circle - inradius;\n\n    float inside = min(y, 0.);\n    float corner = radius*sin(segmentAngle/2.);\n    float outside = length(vec2(max(abs(x) - corner, 0.0), y))*step(0.0, y);\n    return inside + outside;\n}\n\n\n\n// Cheap and nasty 2D smooth noise function with inbuilt hash function -- based on IQ's \n// original. Very trimmed down. In fact, I probably went a little overboard. I think it \n// might also degrade with large time values.\nfloat n2D(vec2 p) {\n\n\tvec2 i = floor(p); p -= i; p *= p*(3. - p*2.); // p *= p*p*(p*(p*6. - 15.) + 10.); //\n    \n\treturn dot(mat2(fract(sin(vec4(0, 1, 113, 114) + dot(i, vec2(1, 113)))*43758.5453))*\n                vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n\n}\n\n\nfloat height(vec2 p){\n    \n    \n    p.x += iTime*speed;\n    p *= 3.;\n    float ns = n2D(p)*.57 + n2D(p*2.)*.28 + n2D(p*4.)*.15;\n    //float ns = n2D(p)*.67 + n2D(p*2.)*.33;\n    return (mix(ns, smoothstep(.25, 1., ns), .5) - .5)*.25;\n}\n\n// The map function. Just two layers of gradient noise. Way more interesting\n// functions are possible, but we're keeping things simple.\nfloat map(vec2 p){\n\n    float ns = height(vec2(p.x, 0.));\n    float ter = p.y + ns + .075;\n    \n    return ter;\n  \n}\n\n\n\n// 2D derivative function.\nvec2 getNormal(in vec2 p, float m) {\n\t\n    vec2 e = vec2(.001, 0);\n    \n    // Four extra samples. Slightly better, but not really needed here.\n\t//return (vec2(map(p + e.xy, i) - map(p - e.xy, i), map(p + e.yx, i) - map(p - e.yx, i)))/e.x*.7071;\n\n    // Three samples, but only two extra sample calculations. \n    return vec2(m - map(p - e.xy), m - map(p - e.yx))/e.x*1.4142;\n}\n\n\n\n// A hatch-like algorithm, or a stipple... or some kind of textured pattern.\nfloat doHatch(vec2 p){\n    \n    float res = iResolution.y;\n    \n    // Produce the pattern.\n    \n    \n        \n    \n        // The pattern is physically based, so needs to factor in screen resolution.\n        p *= res/16.;\n    \n    \t// Just a hack to deal with large \"p\" values as time progresses.\n    \tp = mod(p, 64.);\n\n        // Random looking diagonal hatch lines.\n        float hatch = clamp(sin((p.x - p.y)*3.14159*200.)*2. + .5, 0., 1.); // Diagonal lines.\n\n        // Slight randomization of the diagonal lines, but the trick is to do it with\n        // tiny squares instead of pixels.\n        float hRnd = hash21(floor(p*6.) + .73);\n        if(hRnd>.66) hatch = hRnd;  \n\n\n        hatch = hatch*.2 + .8;\n        \n\n        return hatch;\n    \n}\n\n\n\n// The polygon line pattern.\nfloat linePattern(vec2 p, vec2 a, vec2 b){\n  \n    // Determine the angle between the vertical 12 o'clock vector and the edge\n    // we wish to decorate (put lines on), then rotate \"p\" by that angle prior\n    // to decorating. Simple.\n    vec2 v1 = vec2(0, 1);\n    vec2 v2 = (b - a); \n \n    // Angle between vectors.\n    //float ang = acos(dot(v1, v2)/(length(v1)*length(v2))); // In general.\n    float ang = acos(v2.y/length(v2)); // Trimed down.\n    p = rot2(ang)*p; // Putting the angle slightly past 90 degrees is optional.\n\n    float ln = doHatch(p);//clamp(cos(p.x*96.*6.2831)*.35 + .95, 0., 1.);\n\n    return ln;// *clamp(sin(p.y*96.*6.2831)*.35 + .95, 0., 1.); // Ridges.\n \n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Coordinates.\n    float res = min(iResolution.y, 800.);\n    vec2 uv = (fragCoord - iResolution.xy*.5)/res;\n    \n    // Scaling, translation, etc.\n    vec2 p = uv - vec2(.25, 0);\n    \n    // Keep a copy.\n    vec2 oP = p;\n\n    // Smoothing factor.\n    float sf = 1./iResolution.y;\n    \n    // Number of Polygon vertices:\n    // Positive integers ranging from 2 to about 8 will work.\n    // 2 (just a line) looks a bit odd, but is interesting.\n    const int sNum = VERTICES;\n    const float fsNum = float(sNum);\n    \n    \n    // Gradient at the center of the shape.\n    float grad = (map(vec2(.03, 0)) - map(vec2(-.03, 0)));\n\n    // Rotating time, based on vertice number.\n    float t = fract(iTime*min(mix(fsNum, 5., .5), 6.)*rotSpeed);\n    t = pow(t, .8);\n    t *= 6.283185/fsNum;\n    t -= sign(grad)*grad*grad*4.;\n   \n    \n    // Emulating friction -- very badly. :)\n    p.xy += vec2(-.5, 1.5)*(cos(t*fsNum - 1.57*.5)*.5 + .5)*.005;\n \n    \n    // Various distance field values, etc.\n    float d = 1e5, vert = d, vert2 = d, poly = d, ln = d, gP = d, ico = d, ico2 = d;\n    \n    // Polygon side length and vertex size.\n    float l = .18;\n    float pSz = .015;\n    \n    \n    // Point and transformed point holders.\n    vec2[sNum] pnt;\n    vec2[sNum] tPnt;\n    \n    // Create the points, then rotate them.\n    for(int i = 0; i<sNum; i++){\n        \n        pnt[i] = rot2(6.283185/fsNum*float(i))*vec2(0, 1./sqrt(2.))*l;\n        tPnt[i] = rot2(t)*pnt[i];\n    }\n    \n    // Line pattern.\n    float sLinePat = linePattern(p - vec2(-iTime*speed*1.2, 0), vec2(1, 1), vec2(1, -1));\n    \n    // Bottom dashed line:\n    float xOffs = -.15 - .25;//-.35\n    float yOffs = -.43;\n    if(res>500.) yOffs -= .1;\n    float g = abs(p.y - yOffs + .018) - .0025;\n    vec2 q = mod(p + vec2(iTime*speed, 0), 1./32.) - .5/32.;\n    float dash = abs(q.x) - .2/32.;\n    g = max(g, -dash);\n    \n\n    // Find the minimum vertex point height, since that will be the vertex\n    // in contact with the ground.\n    int lvert = 0;\n    for(int i = 0; i<sNum; i++){ \n        \n        if(tPnt[i].y<gP) {\n            gP = tPnt[i].y;\n            lvert = i;\n        }\n\n    }\n    // Adjust every transformed point by the minimum. \n    for(int i = 0; i<sNum; i++) tPnt[i].y -= gP - yOffs;\n   \n    // Keeping a copy for the ground based polygon below. Normally, this \n    // wouldn't be necessary.\n    float gP2 = gP;\n\n    \n    // Previous and next vertex numbers.\n    int lvertp = int(mod(float(lvert) + 1., fsNum));\n    int lvertn = int(mod(float(lvert) - 1., fsNum));\n    \n    // Number of midpoints between successive vertices. We test these against\n    // the terrain also. More contact points mean more accurate collision.\n    const int midPoints = 2;\n    \n    gP = 1e5;\n    \n    for(int i = 0; i<sNum; i++){ \n        \n        // Terrain height.\n        float h = map(vec2(tPnt[i].x, 0));\n        \n        // If the current vertex plus height is lowest, it becomes the new lowest point.\n        if(tPnt[i].y + h<gP) {\n            gP = tPnt[i].y + h;\n        }\n        \n        // Add the vertex point to the overall distance field.\n        vert2 = min(vert2, length(p - tPnt[i]*.16/.18 - vec2(xOffs, .115*yOffs)) - pSz);\n        \n        // Get the next vertex point index.\n        int inext = (i + sNum - 1)%sNum;\n        \n        // Check the midpoints between the current and next point, the perform a\n        // collision check with the terrain.\n        for(int j = 0; j<midPoints; j++){\n            \n            // Current midpoint... Hmm, midpoint was probably a poor choice of \n            // word, since there can be more than one... Pretend that I mean, waypoint. :)\n            vec2 mid = mix(tPnt[i], tPnt[inext], float(j + 1)/float(midPoints + 1));\n            float hmid = map(vec2(mid.x, 0)); // Midpoint height.\n\n            // If the current midpoint plus height is lowest, it becomes the new lowest point.\n            if(mid.y + hmid<gP) {\n                gP = mid.y + hmid;\n            }\n            \n            // Add the midpointto the overall distance field.\n            vert2 = min(vert2, length(p - mid*.16/.18 - vec2(xOffs, .115*yOffs)) - pSz*.5);\n             \n             \n        }\n    } \n \n   \n \n    \n    ///////////////////\n    \n    // Terrain calculations.\n    \n    float ter = map(p);\n    vec2 n = getNormal(p, ter);\n    float len = length(n);\n   \n    vec2 p2 = p*vec2(1, -1) - vec2(75.3, -.3);\n    float ter2 = map(p2); \n    vec2 n2 = getNormal(p2, ter2);\n    float len2 = length(n2);\n \n    \n    // Polygon contruction.\n    q = rot2(-t)*(p - vec2(0, -gP  - (gP2 - yOffs)));\n    poly = Polygon(q, fsNum, l/sqrt(2.)); \n    poly = max(poly, -(poly + .06)); // Hole.\n   \n    \n    // Polygon line pattern. \n    float t2 = (iTime*rotSpeed*(4.));\n    t2 *= 6.283185/4.;\n    vec2 qp = rot2(-t2)*(p - vec2(0, -gP  - (gP2 - yOffs)));\n    float patPoly = clamp(sin((qp.y)*6.283185*50.*sqrt(2.))*.5 + 1., 0., 1.);\n    //\n    vec2 qq = rot2(-t2)*(p - vec2(0, -gP  - (gP2 - yOffs)));\n    //qq = (rot2(-t2))*(p - vec2(0, -gP  - (gP2 - yOffs)));\n    patPoly = linePattern(qq, pnt[0], pnt[1]);\n    \n\n    \n    // Polygon vertices.\n    q = rot2(6.283185/2./fsNum)*q;\n    float a = atan(q.x, q.y);\n    float ia = (floor(a*fsNum/6.283185) + .5)/fsNum;\n    q = rot2(-ia*6.283185)*q;\n    q.y -= l/sqrt(2.);\n    // \n    vert = min(vert, length(q) - pSz);\n    \n    \n    // Terrain overlay line pattern.\n    float pat = linePattern(p - vec2(-iTime*speed, 0), vec2(1, 1), vec2(1, -1));\n    \n    // Dashes.\n    q = p;\n    q.x = mod(q.x + iTime*speed, 1./36.) - .5/36.;\n    q.y -= -map(vec2(p.x, 0));//-gP - (gP2 - yOffs);\n    // Rotating by the half the tangent. Normally, you'd use the whole tangent, but\n    // I wanted to rotate the lines toward the curve, but not all the way, for \n    // aesthetic purposes.\n    q = rot2(atan(-n.x, n.y)/2.)*q;\n    dash = abs(q.x) - .2/36.;\n    \n    q = p2;\n    q.x = mod(q.x + iTime*speed, 1./36.) - .5/36.;\n    q.y -= -map(vec2(p2.x, 0));//-gP - (gP2 - yOffs);\n    // Rotating by the half the tangent. Normally, you'd use the whole tangent, but\n    // I wanted to rotate the lines toward the curve, but not all the way, for \n    // aesthetic purposes.\n    q = rot2(atan(-n2.x, n2.y)/2.)*q;\n    float dash2 = abs(q.x) - .2/36.;\n    \n    \n    // Noise texture.\n    q = (p - vec2(-iTime*speed, 0));\n    q *= vec2(2, 4. + ter)*32.;\n    float ns = n2D(q)*.57 + n2D(q*2.)*.28 + n2D(q*4.)*.15;\n    vec3 tx = vec3(1);//*(smoothstep(0., .1, ns - .5)*.1 + .9);\n\n\n \n    // Tunnel background.\n    vec3 col = vec3(1, .92, .75)*.8;\n    col *= sLinePat;\n    \n    // Resolution shadow factor.\n    float shF = res/450.;\n   \n    // Top terrain overlay.    \n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*length(n2)*8.*shF, ter2 - length(n2)*.00))*.3);    \n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*length(n2), max(ter2, -dash2))));//vec3(.7, .8, .5)\n    col = mix(col, vec3(1, .94, .78)*pat*tx, (1. - smoothstep(0., sf*length(n2), ter2 + length(n2)*.005)));\n    \n    // Bottom terrain overlay.\n    float sh = clamp(clamp(sin(ter*250. - 3.14159) + .9, 0., 1.), 0., 1.);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*length(n)*8.*shF, ter - length(n)*.00))*.3);    \n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*length(n), max(ter, -dash))));//vec3(.7, .8, .5)\n    col = mix(col, vec3(1, .94, .78)*pat*tx, (1. - smoothstep(0., sf*length(n), ter + length(n)*.005)));\n   \n    \n   \n    // Polygon lines.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8.*shF, min(poly, vert - .003) - .004))*.3);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, poly - .004));\n    col = mix(col, vec3(1, .97, .92)*patPoly, 1. - smoothstep(0., sf, poly + .004));\n\n    // Bottom straight faded line.\n    float fade = min(abs(uv.x - (xOffs + .25)), 1.);\n    col = mix(col, mix(col, vec3(0), 1. - smoothstep(0., .15, fade - .3)), (1. - smoothstep(0., sf, g)));\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln));\n   \n    // Polygon vertices.\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, vert - .003));\n    col = mix(col, mix(vec3(1, .8, .42), vec3(.8, 1, .35)*1.3, .4), 1. - smoothstep(0., sf, vert + .003));\n\n    // Bottom polygon vertices.\n    vec3 bg = col;\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, vert2 - .003));  \n    col = mix(col, mix(vec3(1, .8, .42), vec3(.8, 1, .35)*1.3, .2), 1. - smoothstep(0., sf, vert2 + .003));  \n    \n    \n    // Render some border objects to frame things a little bit.\n    //\n    // Border sights: The background corners looked a little empty, so I threw \n    // these in to balance things out... Not sure if it worked, but it's done now. :)\n    vec2 b = vec2(iResolution.x/iResolution.y, 1) - .1;\n    q = (uv*2.);\n    q.x = abs(q.x);\n    q.y = -q.y;\n    float bord = max(q.x - b.x, q.y - b.y);\n    bord = max(bord, -(bord + .11));\n    bord = max(bord, -min(q.x - b.x + .22, q.y - b.y + .22));\n    //bord = max(bord, -(bord + .02));\n\n    \n    // Render the border sight... edge things, or whatever they are.\n    float falloff = 1./res;\n    col = mix(col, vec3(0), (1. - smoothstep(0., falloff*12.*shF, bord ))*.35);\n    col = mix(col, vec3(0), (1. - smoothstep(0., falloff, bord))*.7);\n    col = mix(col, bg*1., (1. - smoothstep(0., falloff, bord + .01)));\n    col = mix(col, vec3(0), (1. - smoothstep(0., falloff, bord + .035)));\n    col = mix(col, bg*1.3, (1. - smoothstep(0., falloff, bord + .044)));    \n    ////\n     \n    // Very subtle sepia tone with a sprinkling of noise, just to even things up a bit more.\n    p.xy += iTime*speed*vec2(1, .0);\n    col *= vec3(1.03, 1, .97);\n    // Noise, with custom frequency and amplitude distribution.\n    col *= ((n2D(p*16.)*.4 + n2D(p*36.)*.25 + n2D(p*80.)*.2 + n2D(p*180.)*.15)*.2 + .9);\n    \n    // Failed color experiment.\n    //col = mix(col, col.zyx, uv.y*.5);\n  \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*(1. - uv.x)*(1. - uv.y)*uv.x*uv.y, 1./16.)*1.05;\n\n    // Output to screen\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}