{
    "Shader": {
        "info": {
            "date": "1634597569",
            "description": "Geometry is generated from a single texture and should go on forever with no obvious repetition.\nAutopilot can be disabled. It also has adjustable parameters in Buffer A.\nAA and other options in Common tab.\nKeyboard and mouse control: WASD + shift ",
            "flags": 48,
            "hasliked": 0,
            "id": "7dKXDz",
            "likes": 17,
            "name": "Cavern Explorer mf",
            "published": 3,
            "tags": [
                "procedural",
                "heightmap",
                "autopilot"
            ],
            "usePreview": 0,
            "username": "milkfat",
            "viewed": 433
        },
        "renderpass": [
            {
                "code": "\nvoid mainImage( out vec4 F, in vec2 C )\n{\n    F=texelFetch(iChannel0,ivec2(C-.5),0);\n    //if(distance(C,texelFetch(iChannel1,ivec2(6,0),0).zw)<10.0)F=vec4(1);  //navigation dot\n    //F=vec4(texelFetch(iChannel0,ivec2(C-.5),0).w/1000.0);                 //depth map\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//inputs and navigation\n\n#define SPEED 50.0          //travel speed\n#define DIVISOR 10.0        //rate of turning (low numbers = fast, high numbers = slow) \n#define SMOOTHING 221.0     //the number of frames over which to smooth our navigation choices\n#define DAMPENING .25        //the amount of dampening, avoids bouncing back and forth\n#define CENTER_WEIGHT 1.0   //navigation preference toward the center of the screen\n#define DISTANCE_WEIGHT 2.0 //navigation preference toward far away pixels\n\n\n#define NAVIGATION_GRID 30 //grid density to sample the scene for navigation: lower numbers = jittery, higher numbers = smooth\n\n\nvoid mainImage( out vec4 F, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord-.5);\n    if(coord.x>8||coord.y>0)return;\n    \n    //(0,0).xy  = mouse click position\n    //(1,0).xy  = mouse down position\n    //(2,0).xyz = camera position\n    //(3,0).xy  = camera click angle\n    //(4,0).xy  = camera current angles\n    //(5,0).xyz  = camera direction\n    //(6,0).xyz  = furthest pixel\n    //(7,0).xyz  = amount to move next frame\n    //(8,0).x  = center pixel distance\n    vec4 mc   = texelFetch(iChannel0,ivec2(0,0),0);\n    vec4 md   = texelFetch(iChannel0,ivec2(1,0),0);\n    vec3 pos  = texelFetch(iChannel0,ivec2(2,0),0).xyz;\n    vec2 ang  = texelFetch(iChannel0,ivec2(3,0),0).xy;\n    vec2 angb = texelFetch(iChannel0,ivec2(4,0),0).xy;\n    vec3 dir  = vec3(0,0,1);\n    vec2 aim  = texelFetch(iChannel0,ivec2(6,0),0).xy;\n    float cdist  = texelFetch(iChannel0,ivec2(8,0),0).x;\n#ifndef DISABLE_AUTOPILOT\n    float move  = texelFetch(iChannel0,ivec2(7,0),0).x;\n    ang+=aim;\n#else\n    float move = 0.0;\n#endif\n    \n\n    if(iFrame==1){\n        F=vec4(0);\n        F=coord==ivec2(5,0)?vec4(0,0,1,0):F;  //initial direction\n        F=coord==ivec2(3,0)?vec4(hash(iTimeDelta*.97137)*2.0-1.0,hash(iTimeDelta)-.5,0,0):F;  //initial direction\n        F=coord==ivec2(2,0)?vec4(-10,3,-32,0):F; //initial position\n        \n        return;\n    }\n    \n    if(iMouse.w>0.)\n    {\n        mc = iMouse;\n        ang+=angb;\n        angb = vec2(0);\n    }\n    vec2 rot = -ang-angb;\n    if(iMouse.z>0.)\n    {\n        md = iMouse;\n        angb=(iMouse.xy-mc.xy)/iResolution.xy;\n    }\n    \n    dir.yz = rotate(dir.yz,rot.y*3.14159);\n    dir.xz = rotate(dir.xz,rot.x*3.14159);\n    \n    \n    if(coord==ivec2(0,0))F=mc;\n    if(coord==ivec2(1,0))F=md;\n    if(coord==ivec2(2,0))\n    {\n        float shift = texelFetch(iChannel1,ivec2(16,0),0).x > 0.?4.0:1.0;\n        if(texelFetch(iChannel1,ivec2(87,0),0).x > 0.)pos+=dir*shift;\n        pos+=dir*move*iTimeDelta*SPEED;\n        if(texelFetch(iChannel1,ivec2(83,0),0).x > 0.)pos-=dir*shift;\n        vec3 dirr = vec3(1,0,0);\n        dirr.yz = rotate(dirr.yz,rot.y*3.14159);\n        dirr.xz = rotate(dirr.xz,rot.x*3.14159);\n        if(texelFetch(iChannel1,ivec2(68,0),0).x > 0.)pos+=dirr*shift;\n        if(texelFetch(iChannel1,ivec2(65,0),0).x > 0.)pos-=dirr*shift;\n        float up = texelFetch(iChannel1,ivec2(32,0),0).x > 0.?1.0:0.0;\n        float down = texelFetch(iChannel1,ivec2(67,0),0).x > 0.?1.0:0.0;\n        pos.y+=up;\n        pos.y-=down;\n        F.xyz = pos;\n    }\n    \n    int samps = 0;\n    \n    if(coord==ivec2(6,0))samps=NAVIGATION_GRID;\n    \n    vec4 pix = vec4(0);\n    \n    vec2 accum = vec2(0);\n    float cnt = 0.0;\n    float min_d = 1000.0;\n    float avg = 0.0;\n    float cnt2 = 0.0;\n    \n\n    //sample the scene depth (alpha channel) for navigation\n    for(int y = 0; y < samps; y++)\n    {\n        for(int x = 0; x < samps; x++)\n        {\n            cnt2++;\n            ivec2 c = ivec2(x*int(iResolution.x)/samps,y*int(iResolution.y)/samps);\n            vec2 c2 = vec2(c);\n            vec4 tpix = texelFetch(iChannel2,c,0);\n            //weight the farthest pixels more highly than close\n            float adj = pow(tpix.w/VIEW_DISTANCE,DISTANCE_WEIGHT);\n            \n            avg+=tpix.w;\n            //weight the center of the screen more highly than the edges\n            float cent = pow(1.0-(distance(c2,iResolution.xy*.5)/iResolution.x*.5),CENTER_WEIGHT);\n            adj*=cent;\n            cnt+=adj;\n            accum+=c2*adj;\n            min_d=min(min_d,tpix.w);\n            if(tpix.w>pix.w)\n            {\n                pix.xy = c2;\n                pix.w = tpix.w;\n            }\n      }\n    }\n    avg/=cnt2;\n    accum/=cnt;\n    float frame_mult = iTimeDelta*60.0;\n    aim=aim*(SMOOTHING-frame_mult)+frame_mult*(accum.xy-iResolution.xy*.5)/(avg*DIVISOR);\n    aim/=(SMOOTHING-frame_mult);\n    aim*=1.0-DAMPENING;\n\n    \n    //limit camera up/down angle to avoid ending upside down \n    float ty = min(max(ang.y+angb.y,-.5),.5);\n    ang.y += ty-(ang.y+angb.y);\n    \n    if(coord==ivec2(3,0))F.xy=ang;\n    if(coord==ivec2(4,0))F.xy=angb;\n    if(coord==ivec2(5,0))F.xyz=dir;\n    if(coord==ivec2(6,0))F=vec4(aim.xy,accum.xy); //adjust our direction\n    if(coord==ivec2(8,0))F=texelFetch(iChannel2,ivec2(iResolution.xy*.5),0);\n    \n#ifndef DISABLE_AUTOPILOT\n    //slow down before running into something\n    float mv = texelFetch(iChannel2,ivec2(iResolution.xy*.5),0).w;\n    mv = clamp((mv-10.0)/50.0,0.0,1.0);\n    if(coord==ivec2(7,0))F=vec4(min(mv,move+mv*.01));\n#endif\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//render\n\n#define LIGHTBULB (cam+dir*DYNAMIC_LIGHT_Z*clamp((texelFetch(iChannel3,ivec2(8,0),0).w-10.0)/DYNAMIC_LIGHT_Z,0.0,1.0))\n#define u vec2(.1,0)\n\n\nfloat scene(vec3 p)\n{\n\n    //heightmap\n    float h = texture(iChannel0,fract((p.xz+vec2(p.z*.1,0))*.03)).r;\n    float h2 = texture(iChannel0,fract(p.xz*.0007+vec2(p.y*.00015,0.0))).r;\n    float h3 = texture(iChannel0,fract(p.yz*.0007+vec2(.01,p.x*.00005))).r;\n    float h4 = texture(iChannel0,fract(p.xy*.0007+vec2(0.0,p.z*.00007))).r;    \n\n    //ground\n    float d =  (h2+h3+h4)-h/50.;\n\n    return (d*60.-58.8);\n}\n\nvec4 render_pixel(vec2 C)\n{\n    vec4 F = vec4(0);\n    vec3 p = texelFetch(iChannel3,ivec2(2,0),0).xyz;\n    vec3 ps = normalize(vec3(C,iResolution.x*FOV));\n    vec3 cam = p;\n    vec3 dir  = texelFetch(iChannel3,ivec2(5,0),0).xyz;\n    vec2 ang  = texelFetch(iChannel3,ivec2(3,0),0).xy + texelFetch(iChannel3,ivec2(4,0),0).xy + texelFetch(iChannel3,ivec2(6,0),0).xy;\n\n    ps.yz=rotate(ps.yz,-ang.y*3.14159);\n    ps.xz=rotate(ps.xz,-ang.x*3.14159);\n    \n    float min_d = 100000.0;\n    float travel = 0.0;\n    float cnt = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        cnt++;\n        float d = scene(p);\n        if(d<0.0)d*=.3;             //limit our backtracking (for super tall heightmap)\n        d=sign(d)*min(abs(d),15.0); //limit max distance\n        min_d = min(min_d,d);\n        p+=d*ps;   //limit our travel to a fraction of distance\n        travel+=d;\n        if(abs(d)<.01 ||travel > VIEW_DISTANCE)break;\n    }\n\n    vec3 norm = normalize(vec3(scene(p+u.xyy)-scene(p-u.xyy), scene(p+u.yxy)-scene(p-u.yxy), scene(p+u.yyx)-scene(p-u.yyx)));\n    \n#ifdef DYNAMIC_LIGHTING\n    int id3 = 0;\n    float travel2 = 0.0;\n    float cnt2 = 0.0;\n    vec3 p2 = p;\n    vec3 ps2 = normalize(LIGHTBULB-p2);\n    p2+=ps2*3.;\n    float min_d2 = 10000.0;\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        cnt2++;\n        float d = scene(p2);\n        float db = d;\n        d = min(d,distance(p2,LIGHTBULB)-2.0);\n        id3 = (d==db)?id3:2;\n        min_d2 = id3==0?min(d,min_d2):min_d2;\n        if(d<0.0)d*=.3;             //limit our backtracking (for super tall heightmap)\n        d=sign(d)*min(abs(d),15.0); //limit max distance\n        p2+=d*ps2*((id3==0)?.8:1.0);   //limit our travel to a fraction of distance\n        travel2+=d*((id3==0)?.8:1.0);\n        if(abs(d)<.01 ||travel2 > VIEW_DISTANCE)break;\n    }\n#endif\n\n    //3d texture\n    vec4 tex0a = pow(texture(iChannel1,p.xz*.02),vec4(2.2));\n    vec4 tex0b = pow(texture(iChannel1,p.yz*.02),vec4(2.2));\n    vec4 tex0c = pow(texture(iChannel1,p.xy*.02),vec4(2.2));\n    vec4 tex0 = abs(norm.x)*tex0b+abs(norm.y)*tex0a+abs(norm.z)*tex0c;\n    \n    //blend textures together\n    float v = clamp((p.y+20.0)/5.0,0.0,1.0);\n    vec4 tex = tex0*v+tex0*(1.0-v);\n    float v2 = clamp((p.y-2.0)/15.0,0.0,1.0);\n    //tex = tex*(1.0-v2)+tex2*v2;\n\n    float bri = clamp(dot(norm, normalize(cam+LIGHT-p)),0.,1.);\n    bri = pow(bri,2.);\n    float ld = 1.0-distance(p,cam+LIGHT)/VIEW_DISTANCE;\n    ld=ld*ld*ld;\n    \n    if(min_d < .01) F=tex;\n    \n#ifndef DYNAMIC_LIGHTING\n    F*=bri*ld*2.0;\n    F*=1.0-travel/VIEW_DISTANCE;\n#else\n    if(id3==2)\n    {    \n        float bri = clamp(dot(norm, normalize(LIGHTBULB-p)),0.,1.);\n        bri = pow(bri,2.);\n        float bri2 = 1.0-clamp((SOFT_LIGHT-min_d2)/SOFT_LIGHT,0.0,1.0);\n        float ld = clamp(1.0-distance(p,LIGHTBULB)/BRIGHT,0.0,1.0);\n        ld=ld*ld*ld;\n        F.xyz=F.xyz*bri*ld*2.0*bri2+F.xyz*.00;\n    } else {F.xyz*=.00;}\n#endif\n\n    F.w=travel;\n    return F;\n}\n\nvoid mainImage( out vec4 F, in vec2 C )\n{\n    const int ss = max(AA,1);\n\n    \n    F=vec4(0);\n    C-=iResolution.xy*.5;\n\n    for(int y = 0; y < ss; y++) //super sampling\n    {\n        for(int x = 0; x < ss; x++)\n        {\n            F+=render_pixel(C+vec2(float(x)/float(ss),float(y)/float(ss)));\n        }\n    }\n    \n    F/=float(ss*ss);\n    F.xyz=pow(F.xyz,vec3(1.0/2.2));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n\n//#define DISABLE_AUTOPILOT  //disables automatic navigation\n\n#define AA 1                 //amount of super sampling AA\n#define FOV .4\n#define VIEW_DISTANCE 1000.0 //max render distance\n#define LIGHT vec3(0,1,3)    //position of static light source relative to the camera\n#define MAX_STEPS 200        //max number of marching steps\n\n\n//#define DYNAMIC_LIGHTING   //enables dynamic lighting, experimental\n#define DYNAMIC_LIGHT_Z 50.0 //distance of dynamic light source in front of the camera\n#define BRIGHT 1050.0        //dynamic light distance\n#define SOFT_LIGHT 2.0       //shadow softness\n\n\n\nfloat hash(float p) {\n   // p=isnan(p)?0.0:p;\n    p=fract(p*.917331);\n    uint b = uint(p*123456.7);\n\tb += 0x9e3779b9u;\n\tb ^= b >> 15;\n\tb *= 0x85ebca6bu;\n\tb ^= b >> 13;\n\tb *= 0xc2b2ae3du;\n\tb ^= b >> 16;\n\treturn fract(abs(float(b)/1000000.0));\n}\n\nvec2 rotate(vec2 p, float a) {return vec2 (cos(a)*p.x - sin(a)*p.y, sin(a)*p.x + cos(a)*p.y);}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}