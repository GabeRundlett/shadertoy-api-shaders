{
    "Shader": {
        "info": {
            "date": "1394722879",
            "description": "C: toggles greyscale vs colors\nG: toggles grid vs dots\nD: toggles deformations vs displacement\nS: toggles stereo (horiz displ only) vs radial disp\nM: mark central dots\nSPACE: toggles mouse tune center or color\n#define NB : number of dots vertically",
            "flags": 16,
            "hasliked": 0,
            "id": "ls2GWc",
            "likes": 28,
            "name": "disparity4",
            "published": 3,
            "tags": [
                "illusion",
                "autostereogram",
                "stereovision"
            ],
            "usePreview": 1,
            "username": "FabriceNeyret2",
            "viewed": 3822
        },
        "renderpass": [
            {
                "code": "const float PI=3.1415927;\n\n#define NB 40.    // 25.\n#define radius .3 // .4   max: 0.5\n\nbool keyToggle(int ascii) {\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\n}\n\n// === draw a circle (p,r) ===\n\nfloat circle(vec2 p, float r) {\n\t\n\tif (keyToggle(71)) { p = p/r - 1.; r = p.x*p.y;\t} \n\telse\t\t\t     r = length(p)/r - 1.;\n\n\treturn step(0.,r);\n\t// return smoothstep(-.03,.03,r);\n}\n\n// === defines distortion ===\n\n#define POLYNOMIAL 1\n#if POLYNOMIAL\n//const float P0=0.,P01=1.,P02=-1.; // P=x-xÂ² (0,0) / (.5,1/4) \\ (1,0)\n\tconst float P0=0.,P01=-0.5,P02=0.5;\n\tconst float R=.5;\t// resize the curve to [0,R]\n\tfloat F(float x) { return P0 + (P01/R)*x + (P02/(R*R))*x*x; }\n#else\n\tconst float R=PI/4.;\n\tfloat F(float x) { return .25*sin(-4.*x); }\n#endif\n\n// === scalar direct and reverse transforms ===\n\nfloat f(float x) {\n\tfloat sx= sign(x), ax = abs(x); // We force odd symmetry => P0=0\n\tif (ax > R) return x;\n\tfloat dx = F(ax);\n\treturn x + sx*dx; \n}\n\nfloat invf(float x) {\n\tfloat sx= sign(x), ax = abs(x); // We force odd symmetry => P0=0\n\tif (ax > R) return x;\n\n#if POLYNOMIAL\n\t// resize the curve to [0,R]\n# if 0\n\tfloat B =.5*(1.+(P01/R))*(R*R/P02); // a=1, b/2, c\n\tfloat C =  (P0-ax)   *(R*R/P02);\n\treturn sx*(-B + sign(B)*sqrt(B*B-C));  // -b' +- sqrt(b'2-c)\n# else\n\tfloat B = .5*(1.+ (P01/R))*(R*R/P02) + ax; // a=1, -b/2, c\n\tfloat C = (P0 +ax*(P01/R))*(R*R/P02) + ax*ax;\n\tfloat dx = B - sign(B)*sqrt(B*B-C);  // -b' +- sqrt(b'2-c)\n\treturn x - sx*dx;\n# endif\n#endif\n}\n\n// === vectorial direct and reverse transforms ===\n\nvec2 disp(vec2 p, vec2 c) { // distorsion centre c size r\n\tfloat l=length(p-c);\n\tif (keyToggle(83)) // horizontal displacement only \n\t\treturn c + (p-c)/l*vec2(f(l),l);\n\telse\n\t\treturn c + (p-c)/l*f(l); // radial displacement\n}\nvec2 invdisp(vec2 p, vec2 c) { // inverse distorsion\n\tfloat l=length(p-c);\n\tif (keyToggle(83))   // horizontal displacement only \n\t\treturn c + (p-c)/l*vec2(invf(l),l);\n\telse\n\t\treturn c + (p-c)/l*invf(l); // radial displacement\n}\n\n/// === draw a distorted pattern ===\n\nfloat stiples(vec2 p, vec2 center, float n) {\n\tvec2 c, p2 = disp(p,center); \n\tn *= .5;               // because domain range = [-1,1]\n\tp2 = n*p2+.5;\n\tif (keyToggle(68)) { // --- distorsion mode --- \n\t    p2 = fract(p2)/n; // pos relative to a tile\n\t    c = vec2(.5/n);     \n\t} else {             // --- displacement mode --- \n\t\tc = floor(p2)/n;\n\t\tc = invdisp(c,center);\n\t\tp2 = p;\n\t}\n//  return texture(iChannel0,.5*(1.+p2)).r;\n\n\t\n\treturn circle(p2-c,radius/n);\n}\n\n// === main loop ===\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat t = iTime;\n    vec2 uv = 2.*(fragCoord.xy/iResolution.y - vec2(.9,.5));\n\tvec2 center = vec2(0.);\n\tvec4 m = iMouse/iResolution.y;\n\tif (!keyToggle(32)) {\n\t\tif (m.x+m.y==0.) m.xy = vec2(.9001,.5);\n\t\tcenter = 2.*(m.xy- vec2(.9,.5));\n\t\tm.xy = vec2(0.);\n\t}\n\tif ((m.z<0.) || (m.x+m.y==0.)) m.y=.8;\n\t\n\tfloat v; vec3 col;\n#if 1\n\tv = stiples(uv,center,NB);\n\tbool grey=keyToggle(67);\n\tif (keyToggle(77) && (floor(.25*NB*disp(uv,center) +.25)/NB==vec2(0.)))\n\t\tgrey = !grey;\n\t\n\tif (grey) col = vec3(v);\n\telse\t  col = mix(vec3(1.,0.,0.),m.y*vec3(0.,1.,0.),v);\n#else  // --- display control curves\n\tv =      f(uv.x )-uv.y; col.r = smoothstep(.03,-.03,abs(v));\n\tv =   invf(uv.x) -uv.y; col.g = smoothstep(.03,-.03,abs(v));\n\tv = f(invf(uv.x))-uv.y; col.b = smoothstep(.03,-.03,abs(v));\n#endif\t\n\t\n\tfragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}