{
    "Shader": {
        "info": {
            "date": "1486297634",
            "description": "SVG viewer.    Copy-Paste-adapt your SVG data: see comments \nslow GPU: decrease N.\n\nStill some glitches due to ambiguity of distance sign in exterior fans at angles > 90°\n\nNB: 3260 chars: 1700 for data 1560 for code.",
            "flags": 0,
            "hasliked": 0,
            "id": "MlVSWc",
            "likes": 26,
            "name": "svg viewer / nVidia logo",
            "published": 3,
            "tags": [
                "bezier",
                "logo",
                "svg",
                "nvidia"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 1775
        },
        "renderpass": [
            {
                "code": "// see improved version here: https://www.shadertoy.com/view/ldXyRn\n// === SVG Player ====      short spec: https://www.w3.org/TR/2008/REC-SVGTiny12-20081222/paths.html\n\n#define N 20.  // splines discretization. Lower it on slow GPUs\n// absolute main SVG commands\n#define M(x,y)             x0 = _x = x;   y0 = _y = y;\n#define L(x,y)             d = smin(d, line(uv, vec2(_x,_y), vec2(x,y)) ); _x=x,_y=y;\n#define C(x1,y1,x2,y2,x,y) d = smin(d, bezier(uv, vec2(_x,_y), vec2(x1,y1),vec2(x2,y2), vec2(x,y)) ); _x=x,_y=y; \n#define H(x)               d = smin(d, line(uv, vec2(_x,_y), vec2(x,_y)) ); _x=x;\n#define V(y)               d = smin(d, line(uv, vec2(_x,_y), vec2(_x,y)) ); _y=y;\n#define Z                  d = smin(d, line(uv, vec2(_x,_y), vec2(x0,y0)) );\n// relative main SVG commands\n#define m(x,y)             M(_x+x,_y+y)\n#define l(x,y)             L(_x+x,_y+y)\n#define c(x1,y1,x2,y2,x,y) C(_x+x1,_y+y1,_x+x2,_y+y2,_x+x,_y+y)\n#define h(x)               H(_x+x)\n#define v(y)               V(_y+y)\n#define z                  Z\n\n#define style(f,c,d)       fill=f; dir=d; COL= mod(vec4((c)/65536,(c)/256,c,1),256.)/255.;\n#define path(cmd)          d = 1e38; cmd; if (fill>0.) z; draw(d,O);\n                                          // auto z for sign desambiguation at end of loop. Variant:store d0,h0 and redo a last smin.\nfloat bezier(vec2,vec2,vec2,vec2,vec2);\nfloat line(vec2,vec2,vec2);\nvoid  draw(float,inout vec4);\nconst float FILL=1., CONTOUR=0., DIR=1., INDIR=-1.;\nvec4 COL = vec4(0); float fill=FILL, dir=DIR, contrast=1.;  // style state\n\n// smin: min of |dist| keeping signed distance.\n// smin0() is for easy cases (i.e. along splines)\n// smin() deals with ambiguous distance sign in the exterior fan for angles > 90°\n#define smin0(a,b)  abs(_b=b) < abs(a) ? _b : a  \n#define smin(a,b)   abs(_b=b) < abs(a)+1e-2 ? abs(abs(_b)-abs(a))<1e-2 ? dh1<dh2 ? _b:a: _b : a\nfloat _b, dh2=1e38, dh1, d = 1e38;\n\n// === SVG drawing ===============================================================\nvoid SVG(vec2 uv, inout vec4 O) \n{\n    float _x, _y, x0, y0; // d = 1e38; // min dist must be global for sign desambiguation\n    uv *= 400.;                        // scaling\n    contrast = 1.;\n\n// Copy-paste your SVG pathes here.  Slight adaptations : \n//  - add () around command params and  comma between points, \n//  - split polylines and polybéziers into sets of 1 vs 3 pairs of coordinates\n//  - path( style( FILL/CONTOUR, color(hexa), DIR/INDIR )\n//          commands \n//        )    \n\n// nvidia logo from https://upload.wikimedia.org/wikipedia/fr/4/47/Nvidia_%28logo%29.svg\n\n    path( style(FILL,0x74b71b,DIR)              // left exterior arc\n        M( 82.2115,102.414  )\n        C( 82.2115,102.414, 104.7155,69.211, 149.6485,65.777 )\n        L( 149.6485,53.73   )\n        C( 99.8795,57.727, 56.7818,99.879,  56.7818,99.879   )\n        C( 56.7818,99.879, 81.1915,170.445, 149.6485,176.906 )\n        L( 149.6485,164.102 )\n        C( 99.4105,157.781, 82.2115,102.414, 82.2115,102.414 ) \n        z\n    )\n  \n    path( style(FILL,0x74b71b,INDIR)            // left interior arc\n    \tM( 149.6485,138.637 )\n    \tL( 149.6485,150.363 )\n    \tC( 111.6805,143.594, 101.1415,104.125, 101.1415,104.125 )\n    \tC( 101.1415,104.125, 119.3715,83.93,   149.6485,80.656  )\n    \tL( 149.6485,93.523  )\n    \tC( 149.6255,93.523, 149.6095,93.516,  149.5905,93.516   )\n    \tC( 133.6995,91.609, 121.2855,106.453,  121.2855,106.453 )\n    \tC( 121.2855,106.453, 128.2425,131.445, 149.6485,138.637 ) \n    )\n\n    path( style(FILL,0x74b71b,DIR)              // right main plate\n    \tM( 149.6485,31.512  )\n    \tL( 149.6485,53.73   )\n    \tC( 151.1095,53.617,  152.5705,53.523,  154.0395,53.473  )\n    \tC( 210.6215,51.566,  247.4885,99.879,  247.4885,99.879  )\n    \tC( 247.4885,99.879,  205.1455,151.367, 161.0315,151.367 )\n    \tC( 156.9885,151.367, 153.2035,150.992, 149.6485,150.363 )\n    \tL( 149.6485,164.102 )\n    \tC( 152.6885,164.488, 155.8405,164.715, 159.1295,164.715 )\n    \tC( 200.1805,164.715, 229.8675,143.75,  258.6135,118.937 )\n    \tC( 263.3795,122.754, 282.8915,132.039, 286.9025,136.105 )\n    \tC( 259.5705,158.988, 195.8715,177.434, 159.7585,177.434 )\n    \tC( 156.2775,177.434, 152.9345,177.223, 149.6485,176.906 )\n    \tL( 149.6485,196.211 )\n    \tL( 305.6805,196.211 )\n    \tL( 305.6805,31.512  )\n    \t//L( 149.6485,31.512  )  // useless + cause a glitch with z\n    \tz\n    )\n\n    path( style(FILL,0x74b71b,INDIR)            // right interior arc\n    \tM( 149.6485,80.656  )\n    \tL( 149.6485,65.777  )\n    \tC( 151.0945,65.676, 152.5515,65.598, 154.0395,65.551     )\n    \tC( 194.7275,64.273, 221.4225,100.516, 221.4225,100.516   )\n    \tC( 221.4225,100.516, 192.5905,140.559, 161.6765,140.559  )\n    \tC( 157.2275,140.559, 153.2385,139.844, 149.6485,138.637  )\n    \tL( 149.6485,93.523  )\n    \tC( 165.4885,95.437, 168.6765,102.434, 178.1995,118.309   )\n    \tL( 199.3795,100.449 )\n    \tC( 199.3795,100.449, 183.9185,80.172, 157.8555,80.172    )\n    \tC( 155.0205,80.172, 152.3095,80.371, 149.6485,80.656     ) \n    )\n\n}\n\n// --- spline interpolation ( inspired from revers https://www.shadertoy.com/view/MlGSz3 )\nvec2 interpolate(vec2 G1, vec2 G2, vec2 G3, vec2 G4, float t)\n{\n    vec2 A = G4-G1 + 3.*(G2-G3),\n         B = 3.*(G1-2.*G2+G3),\n         C = 3.*(G2-G1),\n         D = G1;\n    return t * (t * (t * A + B) + C) + D;\n}\n\nfloat line(vec2 p, vec2 a, vec2 b) \n{\n\tvec2 pa = p - a, ba = b - a;\n\tfloat l = dot(ba, ba),\n         h0 = dot(pa, ba) / l,                     // parameterization of proj on line\n          h = clamp(h0 , 0., 1.);                  // parameterization of proj on segment\n    //if (l<1e-6) return 1e38;                     // degenerated line\n    dh2 = dh1, dh1 = abs(h-h0)*length(ba);         // how much beyond (for sign desambiguation)\n\tvec2 d = pa - ba * h;                          // distance vector to segment\n    float s = pa.y*ba.x > pa.x*ba.y  ? 1. : -1.;   // sign: -1 on the left\n\treturn dir*s*dot(d,d); //length(d);            // optimization by deferring sqrt\n}\n\nfloat bezier( vec2 uv, vec2 A, vec2 B, vec2 C, vec2 D)    \n{\n    //float d = 1e5;                               // for correct sign desambiguation with prev\n    vec2 p = A;\n    for (float t = 1.; t <= N; t++) {\n        vec2 q = interpolate(A, B, C, D, t/N);\n        float l = line(uv, p, q);\n        d = t==1. ? smin (d, l ) : smin0(d, l );   // t==1 :  same thing\n\t\tp = q;\n\t}\n\treturn d;\n}\n\nvoid draw(float d, inout vec4 O) \n{\n    float s = sign(d);\n    d = min(sqrt(abs(d*contrast)),1.);             // optimization by deferring sqrt here\n    if (fill>0.) { if (s<0.) O = mix(O, COL, d); } // paint inside only\n        else                 O = mix(COL, O, d);\n}\n\nvoid mainImage(out vec4 O, vec2 U) \n{\n    O = vec4(1);\n    vec2 R = iResolution.xy;\n    U.y = R.y-U.y; U /= R.x;\n\tSVG( U, O );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}