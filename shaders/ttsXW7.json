{
    "Shader": {
        "info": {
            "date": "1563721036",
            "description": "Using the standard 2-edge Wang tile concept -- along with some basic layering techniques -- to create a system of pipes, rendered in an oldschool faux 3D style.",
            "flags": 0,
            "hasliked": 0,
            "id": "ttsXW7",
            "likes": 51,
            "name": "Random Pipe System",
            "published": 3,
            "tags": [
                "2d",
                "effect",
                "edge",
                "tile",
                "wang",
                "layer",
                "pipe"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 1350
        },
        "renderpass": [
            {
                "code": "/*\n\n\n\tRandom Pipe System\n\t------------------\n\n\tUsing the standard 2-edge Wang tile concept -- along with some basic layering \n\ttechniques -- to create a system of pipes, rendered in an oldschool faux 3D \n\tstyle. I'm not sure if this a rendering of wall pipes, or an overhead camera\n\tsweep of floor pipes. :)\n\n\tI put together a simple pipe system based on Truchet concepts a while back,\n\twhich still looks interesting, but it lacks the variable density randomness\n\tthat Wang tile techniques provide.\n\n\tSince this was a effectively an upgrade on an earlier example, I wanted to \n\timprove the visuals. Not always, but that often involves more effort, which\n\ttranslates to more code. Therefore, this is not the most readable example.\n\tHowever, I went to the trouble of providing a very basic version to accompany\n\tthis. I've provided a link below, for anyone who doesn't wish to decode the \n\thaphazard logical mess to follow. :)\n\n\tI intend to produce a 3D single layered version of this, but thought it'd be \n\tfun to put together a fake isometric-looking one first. Believe it or not, the\n\t3D equivalent will be a lot easier to produce, but will probably require some \n\tdistance field tweaking to keep the frame rate up.\n\n\n\n    Simplified pipe version:\n\n\tSimple Wang Tile Example - Shane\n\thttps://www.shadertoy.com/view/ttXSzX\n\n\t\n\tOther examples:\n\n    // Put together ages ago. Demofox was doing it before it was cool. :D\n\tWang Tiling 2D - demofox \n\thttps://www.shadertoy.com/view/MssSWs\n\n\t// Like all his examples, it's concise and stylish. I put together one of these\n\t// and the 2-corner version a while back, which I'll put up at some stage.\n\t2-edge Wang Tiles - srtuss\n\thttps://www.shadertoy.com/view/Wds3z7\n\n    // This one incorporates a few concepts.\n\tDouble Simplex Wang Weave - Shane\n\thttps://www.shadertoy.com/view/tl2GWz\n\n\n\tWang tile resources:\n\n    // Possibly the best Wang tile resource on the net. \n\thttp://www.cr31.co.uk/stagecast/wang/intro.html\n\n\n*/\n\n\n \n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// Dave Hoskins's vec2 to float hash.\n// You can find the details here:\n//\n// Hash without Sine - Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash21(vec2 p){ \n    \n    //  2 in, 1 out. \n\tvec3 p3  = fract(vec3(p.xyx)*.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n    \n    // An annoying, but necessary, hack for systems with less sin\n    // function accuracy. If anyone knows a way around it, feel \n    // free to let me know.\n    //p = floor(p*1048576.)/1048576.;\n    //return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); \n}\n\n// Cheap and nasty 2D smooth noise function with inbuilt hash function -- based on IQ's \n// original. Very trimmed down. In fact, I probably went a little overboard. I think it \n// might also degrade with large time values.\nfloat n2D(vec2 p) {\n\n\tvec2 i = floor(p); p -= i; p *= p*(3. - p*2.); // p *= p*p*(p*(p*6. - 15.) + 10.); //\n    \n\treturn dot(mat2(fract(sin(vec4(0, 1, 113, 114) + dot(i, vec2(1, 113)))*43758.5453))*\n                vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n\n}\n\n\n// Texture function.\nvec3 doTex(vec2 p){\n    \n    vec3 tx = texture(iChannel0, p).xyz; // sRGB texture read.\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n    \n\n// Use the unique edge point IDs to produce a Wang tile ID for the tile.\nfloat edges(vec2 ip, vec2[4] ep, float rnd){\n    \n    // Starting from the left and heading clockwise, generate a unique random number\n    // for each edge, then test it against a threshold. If it is above that threshold,\n    // flag that edge and use some standard bit encoding to produce an ID for that tile.\n    // For a 2-edge system, there will be sixteen combinations in total, each of which\n    // are represented by a four bit binary string encoded into integer form.\n    //\n    // For instance, a tile with an ID of 5 will convert to the binary string \"0101,\"\n    // which will indicate that you need to construct a tile that uses the first (left)\n    // edge midpoint and the third (right) edge midpoint. What is constructed is up to \n    // the individual. Since this is a simple example, we'll simply render a line from \n    // the left edge to the right edge. If it were diagonal edges, we could render a\n    // curved edge, and so forth.\n    //\n    // Since tiles share edges, you're guaranteed that neighboring tiles will connect.\n    //\n    // For a much better explanation that will usually include images, look up two-edge \n    // Wang tiles on the net. There are many references out there, but I prefer the \n    // explanation provided here:\n    //\n    // 2-edge Wang Tiles\n    // http://www.cr31.co.uk/stagecast/wang/2edge.html\n    \n    // Initial ID: Trivial, and converts to a binary string of \"0000,\" which indicates\n    // the cell has no edge points, or an empty tile.\n    float id = 0.;\n    \n    \n    // Note: exp2(i) = pow(2., i).\n    for(int i = 0; i<4; i++) id += hash21(ip + ep[i])>rnd? exp2(float(i)) : 0.;\n    \n    /* \n    // The above line is equivalent to the following:\n    vec4 e;\n    for(int i = 0; i<4; i++) e[i] = hash21(ip + ep[i]);\n    \n    if(e.x>rnd) id += 1.; // Left edge.\n    if(e.y>rnd) id += 2.; // Top edge.\n    if(e.z>rnd) id += 4.; // Right edge.\n    if(e.w>rnd) id += 8.; // Bottom edge.\n\t*/ \n    \n    return id; // Range [0-15] inclusive.\n    \n}\n\n\n// vec4 swap.\n//void swap(inout vec2 a, inout vec2 b){ vec2 tmp = a; a = b; b = tmp; }\n\n // Unsigned distance to the segment joining \"a\" and \"b\".\nfloat distLine(vec2 a, vec2 b){\n    \n\tb = a - b;\n\tfloat h = clamp(dot(a, b)/dot(b, b), 0., 1.);\n    return length(a - b*h);\n}\n\n\n// IQ's signed box formula.\nfloat sBox(vec2 p, vec2 b, float r){\n  \n  // Just outside lines.\n  //p = max(abs(p) - b + r, 0.);\n  //return length(p) - r;\n\n  // Inside and outside lines.\n  vec2 d = abs(p) - b + r;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - r;\n}\n\n\n// A stretched leaf for the grid nodule.\nfloat leaf(vec2 p, float a){\n    \n    p *= rot2(6.2831*a); // Rotate.\n    p.y = max(abs(p.y) - .125, 0.); // Elongate.\n\n    return (length(p) + abs(p.x))/1.4142; // Leaf.\n}\n\n// The grid pattern. Just two overlapping grids of rotated\n// leaves, rendered 90 degrees to one another. \nfloat gridPat(vec2 p, vec2 ip){\n    \n    //if(mod(ip.x + ip.y , 2.)>.5) p.x = -p.x;;\n    \n    // Scale the grid, and offset it by half.\n    p = p*5. - .5;\n    \n    // Leaf one.\n    vec2 q = p, iq = floor(q); q -= iq + .5;\n    float d = leaf(q, 1./8.) - .1;\n    \n    // Leaf two.\n    q = p + vec2(.5, .5), iq = floor(q); q -= iq + .5;\n    float d2 = leaf(q, -1./8.) - .1;\n    \n    /*\n    // Not rendering on the edges.\n    if(iq.x==-3.) d2 = 1e5;\n    if(iq.x==2.) d2 = 1e5;\n    if(iq.y==-3.) d2 = 1e5;\n    if(iq.y==2.) d2 = 1e5;\n    */\n    \n    return min(d, d2); // Combine the leaves.\n    \n}\n\n// Random tap rendering in the three and four end-point cells.\nfloat doTap(int iNum, int bend, vec2 ip){\n   \n    // Checker pattern, so that the taps never sit next\n    // to one another.\n    float ch = mod(dot(ip, vec2(1)), 2.);\n    return (iNum>=3 && bend==0 && hash21(ip + 5.)>.7 && ch>.5)? 1. : 0.;\n    //return (iNum>=3 && bend==0 && ch>.5)? 1. : 0.;\n    \n}\n\n// Random guage rendering in the straight two end-point cells.\nfloat doGuage(int iNum, int bend, vec2 ip){\n   \n    // Checker pattern, so that the guages never sit next\n    // to one another.\n    float ch = mod(dot(ip, vec2(1)), 2.);\n    return (iNum==2 && bend==0 && hash21(ip + 173.)>.5 && ch>.5)? 1. : 0.;\n    \n}\n\n// vec4 swap.\n//void swap(inout vec2 a, inout vec2 b){ vec2 tmp = a; a = b; b = tmp; }\n\n\n// Distance field-related struct: Containers are handy, but I try to avoid them in\n// shaders for readability sake. However, there were too many variables I wanted \n// to return from the function to avoid its usage.\nstruct ds{\n    \n    float grid; // Grid.\n    float pat; // Grid pattern.\n    \n    float ln; // Pipe line.\n    float ep; // End point sleaves.\n    // Three circles: The round central point for the single end-point\n    // cells, the taps, and the guages.\n    vec3 ci; \n    \n    //float id; // Wang tile ID. Not used here.\n    vec2 ip; // Unique grid ID.\n    \n    int iNum; // Tile end-point number. Range: [0-4].\n    int bend; // Pipes can either be straight or curved.\n    \n};\n\nds wang(vec2 p){\n\n    // The stuct to hold the Wang tile information to return for rendering. \n    ds di;\n\n   \n    di.ip = floor(p); // Grid ID.\n    p -= di.ip + .5; // Local coordinates.\n    \n    vec2 q = p; // Local variable holding variable.\n    \n    // Grid pattern. This was calculated here, because I'd originally wanted to \n    // bump map it, but I changed my mind later.\n    di.pat = gridPat(q, di.ip);\n    \n    // The grid squares.\n    q = abs(p);\n    di.grid = abs(max(q.x, q.y) - .5) - .01;\n    \n    \n    // Wang tile construction.\n    \n    // Four edge midpoints: Clockwise from the left.\n    vec2[4] eps = vec2[4](vec2(-.5, 0), vec2(0, .5), vec2(.5, 0), vec2(0, -.5));\n    vec2[4] cp = eps; // Holding points.\n    \n    // Get the Wang tile ID. The random number effects the density of the pipe\n    // distribution.\n    const float rnd = .45;\n    float id = edges(di.ip, eps, rnd);\n    \n    // Decode each binary digit.\n    vec4 bits = mod(floor(id/vec4(1, 2, 4, 8)), 2.);\n    \n    di.iNum = 0; // Edge point index.\n    \n    for(int i = 0; i<4; i++){\n        // If the edge bit is flagged, add an end point to the array, whilst \n        // increasing the array index. By the way, we could combine more of \n        // these steps in the \"edges\" function, but I wanted to show the encode \n        // and decode process.\n        if(bits[i]>.5) cp[di.iNum++] = eps[i]; \n        \n    }\n    \n    \n    di.ep = 1e5; //  Midpoint end-point sleeves.\n    di.ln = 1e5; // The pipes themselves.\n    di.ci = vec3(1e5); // The footers, taps and guages.\n    \n    const float lw = .16; // Pipe line width.\n \n    \n    // Edge point joins and the boxes to represent the pipes.\n    vec2 join = vec2(lw*.6, lw + .025);\n    vec2 boxLine = vec2(.25 + lw, lw);\n    \n\n    \n    q = p; // Set \"q\" to the cell's local coordinates.\n    \n    // Is the tile going to contain a curved pipe?\n    di.bend = 0;\n    if(di.iNum==2 && length(cp[0] - cp[1])<.99) di.bend = 1; // Points on diagonal or vertical.\n    // Four end point tiles can contain a cross pipe, or two curved pipes, which can be\n    // randomly rotated as well.\n    if(di.iNum==4 && hash21(di.ip + 7.)>.5){\n        // Randomly orient some of the pipe pairs the opposite way for more variation.\n        if(hash21(di.ip + 27.)>.5) q.y = -q.y; // swap(cp[1], cp[3]);\n        di.bend = 1;\n    }\n    \n    for(int i = 0; i<4; i++){\n        if(bits[i]>.5){\n            di.ep = min(di.ep, sBox(q - eps[i], join, .035));\n            if(di.bend==0) di.ln = min(di.ln, sBox(q - eps[i]/2., boxLine, lw));\n        }\n        \n        // Because we're heading clockwise, we need to reorient the the joins, etc.\n        join = join.yx;\n        boxLine = boxLine.yx;\n    } \n    \n    // If necessary, construct one curved pipe between two end-points, or two\n    // if there are four end-points.\n    if(di.bend==1){\n        \n        vec2 pnt;\n        float rf = di.iNum==2? .3 : .4; // Sharper bends for just one curved pipe.\n        pnt.x = abs(cp[0].x)>abs(cp[1].x)? cp[0].x : cp[1].x;\n        pnt.y = abs(cp[0].y)>abs(cp[1].y)? cp[0].y : cp[1].y;\n        //ln = min(ln, abs(length(q - pnt) - .5) - lw);\n        di.ln = min(di.ln, abs(sBox(q - pnt, vec2(.5), rf)) - lw);\n        \n        if(di.iNum==4){ // The second curved pipe, if applicable.\n            pnt.x = abs(cp[2].x)>abs(cp[3].x)? cp[2].x : cp[3].x;\n            pnt.y = abs(cp[2].y)>abs(cp[3].y)? cp[2].y : cp[3].y;\n            //ln = min(ln, abs(length(q - pnt) - .5) - lw);\n            di.ln = min(di.ln, abs(sBox(q - pnt, vec2(.5), rf)) - lw);\n        }\n\n    }    \n    \n    // Construct the pipe footers at the center of the single end-point tiles.\n    if(di.iNum==1) di.ci.x = min(di.ci.x, length(q) - lw - .095);\n    \n    // Tap... at some of the junctions? It seems like a pipe system thing to do. :D\n    if(doTap(di.iNum, di.bend, di.ip)>.5){\n       \n        \n        // Randomly oriented, to show they've been turned.\n        q = rot2(3.14159*hash21(di.ip + 9.))*p;\n       \n        // The main body of the tap.\n        di.ci.y = min(di.ci.y, length(q) - .24);\n        \n        // Tap nodules, spread around in a hexagonal fashion.\n        //\n        // Standard repeat polar cells.\n     \tconst float rad = .22;\n    \tconst float aNum = 6.;\n    \tfloat a = atan(q.y, q.x);\n        float ia = floor(a/6.283*aNum) + .5; // .5 to center cell.\n        q = rot2(ia*6.283/aNum)*q;\n        q.x -= rad;\n        \n        float s = sBox(q, vec2(.08, .08), .06);\n        di.ci.y = min(di.ci.y, s);\n  \n    }\n    \n    // Putting a pressure guage, or something like that, on some of the straight pipes.\n    if(doGuage(di.iNum, di.bend, di.ip)>.5){\n        \n        di.ci.z = min(di.ci.z, length(q) - .3);\n \n    }\n    \n    // Return the distance field-related struct.\n    return di;\n    \n}\n\n\n// Shorthand for this particular expression, which gets used a lot.\n#define ss(a, b) 1. - smoothstep(0., a, b)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Aspect correct screen coordinates. Setting a minumum resolution on the\n    // fullscreen setting in an attempt to keep things relatively crisp.\n    float iRes = min(800., iResolution.y);\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iRes;\n    \n    // Scaling and translation.\n    const float gSc = 6.;\n    vec2 p = uv*gSc - vec2(-iTime, cos(iTime/8.)*2.);\n    \n    // Smoothing factor, based on resolution and scaling factor.\n    float sf = 1./iRes*gSc;\n    \n    // Taking some Wang tile samples, for rendering.\n    vec2 e = vec2(.015, .03);\n    float le = length(e);\n    \n    ds di = wang(p); // Standard sample.\n    ds di2 = wang(p - e); // Near offset for highlight calulations.\n    ds dis = wang(p + 5.333*e); // Opposite, larger offset for shadows.\n    \n    \n    ds diHi; // Holding container for highlight calculations.\n\n    // Background texture.\n    vec3 txPat = doTex(p/gSc + e);\n    // Scene color, pipe color and end-point sleeve color.\n    vec3 col = txPat*2.*vec3(1, .85, .7);\n    vec3 lCol = vec3(1, .7, .4)*mix(vec3(1), txPat*3., .5);\n    vec3 sCol = vec3(1, .6, .3);\n\n    \n    \n    vec3 tCol = col; // Temporary holding color.\n    \n    // Background grid pattern.\n    //col = mix(col, vec3(0), (ss(sf*6.*4.,  max(di.pat - .02*6., -(di.grid - .07))))*.5);\n    //col = mix(col, vec3(0), (ss(sf*6.,  max(di.pat - .02*6., -(di.grid - .07))))*.75);\n    //col = mix(col, tCol*2., (ss(sf*6., max(di.pat, -(di.grid - .07))))*.7);\n    col = mix(col, vec3(0), (ss(sf*6.*4., di.pat - .02*6.))*.5);\n    col = mix(col, vec3(0), (ss(sf*6.,  di.pat - .02*6.))*.75);\n    col = mix(col, tCol*2., (ss(sf*6., di.pat))*.7);\n    \n    // The grid.    \n    diHi.grid = max(smoothstep(0., sf*4., di2.grid - .005) - \n                smoothstep(0., sf*4., di.grid - .005), 0.)/le*.015;\n    col += diHi.grid;\n    col = mix(col, vec3(0), (ss(sf*4., di.grid - .02))*.5);\n    col = mix(col, vec3(0), (ss(sf, di.grid)));\n    //col = mix(col, vec3(0), ss(sf, abs(di.grid - .07) - .01));\n    \n    // The drop shadow consists of all the combined major elements. We\n    // take the minimum of all, then render the blurred silhouette onto\n    // ground layer. Without it, this example would really lack depth.\n    // Comment the shadow layer out, and you'll see what I mean.\n    float shadow = min(min(min(dis.ci.x, dis.ci.y), dis.ci.z), dis.ln);\n    shadow = min(shadow, dis.ep);\n    col = mix(col, vec3(0), (ss(sf*8., shadow - .02))*.6);\n    \n    // Pipe footers, at the center of the single end-point tiles.\n    col = mix(col, vec3(0), (ss(sf*4., di.ci.x - .02))*.5);\n    col = mix(col, vec3(0), ss(sf, di.ci.x));\n    col = mix(col, lCol, ss(sf, di.ci.x + .03));\n    col = mix(col, vec3(0), ss(sf, abs(di.ci.x + .06) - .01));\n    \n    \n    // Pipes with fake AO and highlights.\n    vec3 txLn = doTex(p/gSc);\n    txLn *= vec3(1, .85, .7);\n    float pat2 = clamp(cos(di.ln*6.2831*24.) + .75, 0., 1.)*.2 + .9;\n    float sh = max(.35 - (di.ln + .03)*12., 0.);\n    diHi.ln = max(di.ln - di2.ln, 0.)/le;\n    col = mix(col, vec3(0), (ss(sf*4., di.ln - .04))*.5);\n    col = mix(col, vec3(0), ss(sf, di.ln));\n    col = mix(col, txLn*(diHi.ln + sh*sh*.25 + .25)*pat2, ss(sf, di.ln + .025));\n    col = mix(col, col*2., (ss(sf*4., di2.ln + .125))*.8);\n    //col = mix(col, vec3(0), ss(sf, abs(di.ln + .12) - .01));\n    \n    \n    // Pipe joins, with fake AO and highlights.\n    sh = max(.05 - (di.ln + .02)*12., 0.);\n    //diHi.ep = max(di.ep - di2.ep, 0.)/le;\n    col = mix(col, vec3(0), (ss(sf*4., di.ep - .02))*.5);\n    col = mix(col, vec3(0), ss(sf, di.ep));\n    col = mix(col, sCol*(diHi.ln*diHi.ln + sh*sh*.5 + .25)/2., ss(sf, di.ep + .025));\n    col = mix(col, col*3., (ss(sf*4., max(di.ep, di2.ln + .125)))*.8);\n    //col = mix(col, vec3(0), (ss(sf, abs(di.ep + .04) - .01))*.75);\n    col = mix(col, vec3(0), ss(sf, max(di.ep, di.grid)));\n\n     \n    // Flow tap, or whatever it's called. :)\n    if(doTap(di.iNum, di.bend, di.ip)>.5){\n        \n        vec2 q = fract(p) - .5;\n        \n        // The main tap background.\n        diHi.ci.y = max(di.ci.y - di2.ci.y, 0.)/length(e);\n        sh = max(.75 - - di.ci.y*4., 0.);\n        col = mix(col, vec3(0), (ss(sf*4., di.ci.y - .04))*.5);\n        col = mix(col, vec3(0), ss(sf, di.ci.y));\n        col = mix(col, lCol*(diHi.ci.y + sh*sh*.1 + .5), ss(sf, di.ci.y + .03));\n         \n        // Extra rings.\n        col = mix(col, vec3(1), (ss(sf, abs(length(q) - .12) - .02))*.2);\n        col = mix(col, vec3(0), ss(sf, abs(di.ci.y + .16) - .015));\n        col = mix(col, vec3(0), ss(sf, length(q) - .03));\n\n        // Subtle highlights.\n        col = mix(col, col*2., (ss(sf*4., di.ci.y + .125))*.7);\n        col = mix(col, vec3(0), ss(sf, abs(di.ci.y + .08) - .01));\n        \n        \n    }\n    \n    // Guage, or dial. A lot of it is made up on the spot, with a touch of common sense thrown in. :)\n    // There'd be more efficient ways to get this done, but not too many pixels are effected, plus\n    // this isn't a taxing example to begin with.\n    if(doGuage(di.iNum, di.bend, di.ip)>.5) {\n        \n        // Local coordinates.\n        vec2 q = fract(p) - .5;\n\n        // Backface with a bit of highlighting.\n        diHi.ci.z = max(di.ci.z - di2.ci.z, 0.)/length(e);\n        sh = max(.75 - di.ci.z*4., 0.);\n        col = mix(col, vec3(0), (ss(sf*4., di.ci.z - .04))*.5);\n        col = mix(col, vec3(0), ss(sf, di.ci.z));\n        col = mix(col, lCol*(diHi.ci.z + sh*sh*.1 + .5), ss(sf, di.ci.z + .03));\n        \n        \n        // More rings in the center.\n    \tcol = mix(col, col*1.6, ss(sf*4., di.ci.z + .125));\n    \tcol = mix(col, vec3(0), ss(sf, abs(di.ci.z + .08) - .01));\n       \n        col = mix(col, vec3(0), (ss(sf, length(q) - .08))*.5);\n        col = mix(col, vec3(0), ss(sf, abs(length(q) - .1) - .01));\n        col = mix(col, vec3(0), ss(sf, length(q) - .05));\n        \n        \n        // Constructing the red indicator at a random angle, and providing some animation,\n        q = rot2(6.2831*hash21(di.ip + 31.) + (hash21(di.ip + 19.)*.8 + .2)*sin(iTime))*q;\n        float ind = distLine(q - vec2(0, -.005), q - vec2(0, .16)) - .0025;\n        \n        // Constructing the clock-like markings on the dial using standard repeat polar\n        // coordinates.\n        q = fract(p) - .5;\n    \tconst float rad = .16;\n    \tconst float aNum = 12.;\n        q = rot2(3.14159/aNum)*q;\n    \tfloat a = atan(q.y, q.x);\n        float ia = floor(a/6.283*aNum) + .5; // .5 to center cell.\n        ia = ia*6.283/aNum;\n        q = rot2(ia)*q;\n        q.x -= rad;\n        \n        // Markings.\n        float mark = sBox(q, vec2(.025, .015), 0.);\n        col = mix(col, vec3(.5), ss(sf, mark - .015));\n        col = mix(col, vec3(0), ss(sf, mark));\n        \n        // Indicator.        \n        col = mix(col, vec3(0), ss(sf, ind - .025));\n        col = mix(col, vec3(.5, 0, 0), ss(sf, ind));\n        \n        \n    }\n \n    \n    // Very subtle sepia tone with a sprinkling of noise, just to even things up a bit more.\n    col *= vec3(1.1, 1, .9)*(n2D(p*64.)*.8 + .6);\n  \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*(1. - uv.x)*(1. - uv.y)*uv.x*uv.y, 1./16.)*1.05;\n    \n    // Rough gamma correction before presenting to the screen.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}