{
    "Shader": {
        "info": {
            "date": "1689663452",
            "description": "Use mouse to drag the transition.",
            "flags": 0,
            "hasliked": 0,
            "id": "mdSfD1",
            "likes": 8,
            "name": "Image Transition Perlin Noise",
            "published": 3,
            "tags": [
                "transition"
            ],
            "usePreview": 0,
            "username": "alphardex",
            "viewed": 351
        },
        "renderpass": [
            {
                "code": "//\n// GLSL textureless classic 3D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x)\n{\n    return x-floor(x*(1./289.))*289.;\n}\n\nvec4 mod289(vec4 x)\n{\n    return x-floor(x*(1./289.))*289.;\n}\n\nvec4 permute(vec4 x)\n{\n    return mod289(((x*34.)+1.)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159-.85373472095314*r;\n}\n\nvec3 fade(vec3 t){\n    return t*t*t*(t*(t*6.-15.)+10.);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n    vec3 Pi0=floor(P);// Integer part for indexing\n    vec3 Pi1=Pi0+vec3(1.);// Integer part + 1\n    Pi0=mod289(Pi0);\n    Pi1=mod289(Pi1);\n    vec3 Pf0=fract(P);// Fractional part for interpolation\n    vec3 Pf1=Pf0-vec3(1.);// Fractional part - 1.0\n    vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);\n    vec4 iy=vec4(Pi0.yy,Pi1.yy);\n    vec4 iz0=Pi0.zzzz;\n    vec4 iz1=Pi1.zzzz;\n    \n    vec4 ixy=permute(permute(ix)+iy);\n    vec4 ixy0=permute(ixy+iz0);\n    vec4 ixy1=permute(ixy+iz1);\n    \n    vec4 gx0=ixy0*(1./7.);\n    vec4 gy0=fract(floor(gx0)*(1./7.))-.5;\n    gx0=fract(gx0);\n    vec4 gz0=vec4(.5)-abs(gx0)-abs(gy0);\n    vec4 sz0=step(gz0,vec4(0.));\n    gx0-=sz0*(step(0.,gx0)-.5);\n    gy0-=sz0*(step(0.,gy0)-.5);\n    \n    vec4 gx1=ixy1*(1./7.);\n    vec4 gy1=fract(floor(gx1)*(1./7.))-.5;\n    gx1=fract(gx1);\n    vec4 gz1=vec4(.5)-abs(gx1)-abs(gy1);\n    vec4 sz1=step(gz1,vec4(0.));\n    gx1-=sz1*(step(0.,gx1)-.5);\n    gy1-=sz1*(step(0.,gy1)-.5);\n    \n    vec3 g000=vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100=vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010=vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110=vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001=vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101=vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011=vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111=vec3(gx1.w,gy1.w,gz1.w);\n    \n    vec4 norm0=taylorInvSqrt(vec4(dot(g000,g000),dot(g010,g010),dot(g100,g100),dot(g110,g110)));\n    g000*=norm0.x;\n    g010*=norm0.y;\n    g100*=norm0.z;\n    g110*=norm0.w;\n    vec4 norm1=taylorInvSqrt(vec4(dot(g001,g001),dot(g011,g011),dot(g101,g101),dot(g111,g111)));\n    g001*=norm1.x;\n    g011*=norm1.y;\n    g101*=norm1.z;\n    g111*=norm1.w;\n    \n    float n000=dot(g000,Pf0);\n    float n100=dot(g100,vec3(Pf1.x,Pf0.yz));\n    float n010=dot(g010,vec3(Pf0.x,Pf1.y,Pf0.z));\n    float n110=dot(g110,vec3(Pf1.xy,Pf0.z));\n    float n001=dot(g001,vec3(Pf0.xy,Pf1.z));\n    float n101=dot(g101,vec3(Pf1.x,Pf0.y,Pf1.z));\n    float n011=dot(g011,vec3(Pf0.x,Pf1.yz));\n    float n111=dot(g111,Pf1);\n    \n    vec3 fade_xyz=fade(Pf0);\n    vec4 n_z=mix(vec4(n000,n100,n010,n110),vec4(n001,n101,n011,n111),fade_xyz.z);\n    vec2 n_yz=mix(n_z.xy,n_z.zw,fade_xyz.y);\n    float n_xyz=mix(n_yz.x,n_yz.y,fade_xyz.x);\n    return 2.2*n_xyz;\n}\n\nvec4 getFromColor(vec2 uv){\n    return texture(iChannel0,uv);\n}\n\nvec4 getToColor(vec2 uv){\n    return texture(iChannel1,uv);\n}\n\nfloat sdCircle(vec2 p,float r)\n{\n    return length(p)-r;\n}\n\nvec4 transition(vec2 uv){\n    float progress=iMouse.x/iResolution.x;\n    float ratio=iResolution.x/iResolution.y;\n    \n    vec2 p=uv;\n    p-=.5;\n    p.x*=ratio;\n    \n    float noise=cnoise(vec3(p*10.,0.));\n    float pr=progress+noise*.1;\n    \n    float d=sdCircle(p,pr*sqrt(2.));\n    float c=smoothstep(-.1,-.05,d);\n    \n    return mix(getFromColor(uv),getToColor(uv),1.-c);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 uv=fragCoord/iResolution.xy;\n    \n    vec4 col=transition(uv);\n    \n    fragColor=col;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}