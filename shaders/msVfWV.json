{
    "Shader": {
        "info": {
            "date": "1698715374",
            "description": "Hash thingy",
            "flags": 0,
            "hasliked": 0,
            "id": "msVfWV",
            "likes": 3,
            "name": "Into the TV",
            "published": 3,
            "tags": [
                "fractals",
                "hash"
            ],
            "usePreview": 0,
            "username": "ElSolem",
            "viewed": 63
        },
        "renderpass": [
            {
                "code": "/*************************************************************************************************\n * Mark Jarzynski and Marc Olano, Hash Functions for GPU Rendering, \n * Journal of Computer Graphics Techniques (JCGT), vol. 9, no. 3, 21-38, 2020\n * Available online http://jcgt.org/published/0009/03/02/\n * \n * Each block visualized 1 bit of hash from bit 0 in the lower left to bit 31 in the upper right.\n * Some hashes do not generate data in all bits, the bits without data are black.\n * \n * For each one dimensional hash there are 2 examples, linear and nested, both have 2-dimensional\n * inputs (UV coords) and only a single output. For the three and four dimensional hashes we\n * combine x and y in different ways for z and w, though in 3D space you would ideally use z as \n * the third input. Constants are sometimes acceptable depending on the hash. For multi-byte\n * hashes only the two dimensional input varation is used an example here. The source code for\n * all of the variations can be found in the Common tab as well as in the full paper.\n * \n * Comment out the return statements in the hash() function to change the hash.\n * Comment out the #defines for BITPLANE and GRID to visualize the hash itself.\n * Comment out the #define COLOR to see the hash in grayscale (only uses x in multi-dimentionsal hashes)\n * \n */\n\n#define BITPLANE\t// Visualize the bitplanes\n#define ANIMATE\t\t// Animate the bits\n#define COLOR\t    // Visualize 3D COLOR\n#define GRID\t\t// Display a grid to seperate the bitplanes\n\nuvec3 hash(vec2 s)\n{\t\n    /*\tUncomment the hash you want to visualize.\n\n\t\tNote that most of these examples the hash is only given 2 inputs unless the hash requires more.\n\t\tBut Common includes 1 through 4 input variations of the hash if they exist.\n\n\t\tYou should play around with different seeds/different number of inputs.\n\t\t\n\t\tAvailable hashes:\n\t\n\t\tbbs, city, esgtsa, fast, hashwithoutsine, hybridtaus, \n\t\tign, iqint1, iqint2, iqint3, jkiss32, lcg, md5, murmur3,\n\t\tpcg, pcg2d, pcg3d, pcg3d16, pcg4d, pseudo, ranlim32,\n\t\tsuperfast, tea2, tea3, tea4, tea5, trig, wang,\n\t\txorshift128, xorshift32, xxhash32\n\t*/    \n    \n    uvec4 u = uvec4(s, uint(s.x) ^ uint(s.y), uint(s.x) + uint(s.y)); // Play with different values for 3rd and 4th params. Some hashes are okay with constants, most aren't.\n    \n    //return uvec3(bbs(seed(u.xy)));\n\t//return uvec3(bbs(bbs(u.x) + u.y));\n    //return uvec3(city(u.xy));\n    //return uvec3(esgtsa(seed(u.xy)));\n    //return uvec3(esgtsa(esgtsa(u.x) + u.y));\n    //return uvec3(fast(s) * float(0xffffffffu));\n    //return uvec3(hashwithoutsine32(s) * float(0xffffffffu));\n    //return uvec3(hybridtaus(u));\n    //return uvec3(ign(s) * float(0xffffffffu));\n    //return uvec3(iqint1(seed(u.xy)));\n    //return uvec3(iqint1(iqint1(u.x) + u.y));\n    //return iqint2(u.xyz);\n    //return uvec3(iqint3(u.xy));\n    //return uvec3(jkiss32(u.xy));\n    //return uvec3(lcg(seed(u.xy)));\n    //return uvec3(lcg(lcg(u.x) + u.y));\n    //return md5(u).xyz;\n    //return uvec3(murmur3(u.xy));\n    //return uvec3(pcg(seed(u.xy)));\n    //return uvec3(pcg(pcg(u.x) + u.y));\n    //return uvec3(pcg2d(u.xy), 0u);\n    return pcg3d(u.xyz);\n    //return pcg3d16(u.xyz);\n    //return pcg4d(u).xyz;\n    //return uvec3(pseudo(s) * float(0xffffffffu));\n    //return uvec3(ranlim32(seed(u.xy)));\n    //return uvec3(ranlim32(ranlim32(u.x) + u.y));\n    //return uvec3(superfast(seed(u.xy)));\n    //return uvec3(superfast(superfast(u.x) + u.y));\n    //return uvec3(tea(2, u.xy), 0u);\n    //return uvec3(tea(3, u.xy), 0u);\n    //return uvec3(tea(4, u.xy), 0u);\n    //return uvec3(tea(5, u.xy), 0u);\n    //return uvec3(trig(s) * float(0xffffffffu));\n    //return uvec3(wang(seed(u.xy)));\n    //return uvec3(wang(wang(u.x) + u.y));\n    //return uvec3(xorshift128(u));\n    //return uvec3(xorshift32(seed(u.xy)));\n    //return uvec3(xorshift32(xorshift32(u.x) + u.y));\n    //return uvec3(xxhash32(u.xy)); \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Convert pixel coordinates to a normalized range (-1 to 1)\n    vec2 p = (2.0*fragCoord-iResolution.xy)/min(iResolution.y,iResolution.x);\n\n    // Calculate the value of xy using your equation\n    float xy = p.x / p.y;\n\n    // Define a threshold for plotting the point\n    float threshold = 2.; // Adjust this value as needed // air: 1.0, water: 1.33, glass: 1.5, diamond: 2.4\n\n    // Check if xy is within the threshold to plot the point\n    if (abs(xy) < abs(threshold))\n    {\n            // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    }\n    else\n    {\n    // Thanks to \"hash: visualising bitplanes\" by hornet https://www.shadertoy.com/view/lt2yDm\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uint bit = uint(8.0 * uv.x) + 8u * uint(4.0 * uv.y);\n\n#ifdef BITPLANE\n    vec2 seed = mod(fragCoord, vec2(iResolution.x/8.0, iResolution.y/4.0));\n#else\n    vec2 seed = fragCoord;\n#endif\n    \n#ifdef ANIMATE\n    seed += 100.0 * iTime;\n#endif\n    \n    uvec3 hash = hash(seed);\n    \n#ifdef BITPLANE\n#ifdef COLOR\n    fragColor = vec4((hash >> bit) & 1u, 1.0);\n#else\n    fragColor = vec4(vec3(float((hash >> bit) & 1u)), 1.0);\n#endif\n#else\n#ifdef COLOR\n    fragColor = vec4(vec3(hash) * (1.0/float(0xffffffffu)), 1.0);\n#else\n    fragColor = vec4(vec3(float(hash) * (1.0/float(0xffffffffu))), 1.0);\n#endif\n#endif\n    \n#ifdef GRID\n    fragColor *= step( 10.0/iResolution.x, 1.0-abs(2.0*fract(8.0*uv.x)-1.0));\n    fragColor *= step( 10.0/iResolution.y, 1.0-abs(2.0*fract(4.0*uv.y)-1.0));\n#endif\n    }\n}\n\n// https://www.shadertoy.com/view/dsVBRd - Set as default cause if you aren't careful it can turn into flash\n\n// Needed to test this further so used the shader from this link\n// and this one\n// https://www.shadertoy.com/view/Mdt3Df\n\n// You can put any? into the if-else blocks. If you change the origin from 0 to any number the view because bigger/wider\n\n// https://www.shadertoy.com/view/dsyBDy - double mod by Xor",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// commonly used constants\n#define c1 0xcc9e2d51u\n#define c2 0x1b873593u\n\n// Helper Functions\nuint rotl(uint x, uint r)\n{\n\treturn (x << r) | (x >> (32u - r));\n}\n\nuint rotr(uint x, uint r)\n{\n\treturn (x >> r) | (x << (32u - r));\n}\n\nuint fmix(uint h)\n{\n    h ^= h >> 16;\n    h *= 0x85ebca6bu;\n    h ^= h >> 13;\n    h *= 0xc2b2ae35u;\n    h ^= h >> 16;\n    return h;\n}\n\nuint mur(uint a, uint h) {\n    // Helper from Murmur3 for combining two 32-bit values.\n    a *= c1;\n    a = rotr(a, 17u);\n    a *= c2;\n    h ^= a;\n    h = rotr(h, 19u);\n    return h * 5u + 0xe6546b64u;\n}\n\nuint bswap32(uint x) {\n    return (((x & 0x000000ffu) << 24) |\n            ((x & 0x0000ff00u) <<  8) |\n            ((x & 0x00ff0000u) >>  8) |\n            ((x & 0xff000000u) >> 24));\n}\n\nuint taus(uint z, int s1, int s2, int s3, uint m)\n{\n\tuint b = (((z << s1) ^ z) >> s2);\n    return (((z & m) << s3) ^ b);\n}\n\n\n\n// convert 2D seed to 1D\n// 2 imad\nuint seed(uvec2 p) {\n    return 19u * p.x + 47u * p.y + 101u;\n}\n\n// convert 3D seed to 1D\nuint seed(uvec3 p) {\n    return 19u * p.x + 47u * p.y + 101u * p.z + 131u;\n}\n\n// convert 4D seed to 1D\nuint seed(uvec4 p) {\n\treturn 19u * p.x + 47u * p.y + 101u * p.z + 131u * p.w + 173u;\n}\n\n\n\n\n/**********************************************************************\n * Hashes\n **********************************************************************/\n\n// BBS-inspired hash\n//  - Olano, Modified Noise for Evaluation on Graphics Hardware, GH 2005\nuint bbs(uint v) {\n    v = v % 65521u;\n    v = (v * v) % 65521u;\n    v = (v * v) % 65521u;\n    return v;\n}\n\n\n\n// CityHash32, adapted from Hash32Len0to4 in https://github.com/google/cityhash\nuint city(uint s)\n{\n    uint len = 4u;\n\tuint b = 0u;\n    uint c = 9u;\n\n    for (uint i = 0u; i < len; i++) {\n    \tuint v = (s >> (i * 8u)) & 0xffu;\n        b = b * c1 + v;\n        c ^= b;\n    }\n\n    return fmix(mur(b, mur(len, c)));\n}\n\n// CityHash32, adapted from Hash32Len5to12 in https://github.com/google/cityhash\nuint city(uvec2 s)\n{\n    uint len = 8u;\n    uint a = len, b = len * 5u, c = 9u, d = b;\n\n    a += bswap32(s.x);\n    b += bswap32(s.y);\n    c += bswap32(s.y);\n\n    return fmix(mur(c, mur(b, mur(a, d))));\n}\n\n// CityHash32, adapted from Hash32Len5to12 in https://github.com/google/cityhash\nuint city(uvec3 s)\n{\n    uint len = 12u;\n    uint a = len, b = len * 5u, c = 9u, d = b;\n\n    a += bswap32(s.x);\n    b += bswap32(s.z);\n    c += bswap32(s.y);\n\n    return fmix(mur(c, mur(b, mur(a, d))));\n}\n\n// CityHash32, adapted from Hash32Len12to24 in https://github.com/google/cityhash\nuint city(uvec4 s)\n{\n    uint len = 16u;\n    uint a = bswap32(s.w);\n    uint b = bswap32(s.y);\n    uint c = bswap32(s.z);\n    uint d = bswap32(s.z);\n    uint e = bswap32(s.x);\n    uint f = bswap32(s.w);\n    uint h = len;\n\n    return fmix(mur(f, mur(e, mur(d, mur(c, mur(b, mur(a, h)))))));\n}\n\n\n\n// Schechter and Bridson hash \n// https://www.cs.ubc.ca/~rbridson/docs/schechter-sca08-turbulence.pdf\nuint esgtsa(uint s)\n{\n    s = (s ^ 2747636419u) * 2654435769u;// % 4294967296u;\n    s = (s ^ (s >> 16u)) * 2654435769u;// % 4294967296u;\n    s = (s ^ (s >> 16u)) * 2654435769u;// % 4294967296u;\n    return s;\n}\n\n\n\n// UE4's RandFast function\n// https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Shaders/Private/Random.ush\nfloat fast(vec2 v)\n{\n    v = (1./4320.) * v + vec2(0.25,0.);\n    float state = fract( dot( v * v, vec2(3571)));\n    return fract( state * state * (3571. * 2.));\n}\n\n\n\n\n// Hash without Sine\n// https://www.shadertoy.com/view/4djSRW\nfloat hashwithoutsine11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hashwithoutsine12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hashwithoutsine13(vec3 p3)\n{\n    p3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hashwithoutsine21(float p)\n{\n\tvec3 p3 = fract(vec3(p,p,p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hashwithoutsine22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hashwithoutsine23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hashwithoutsine31(float p)\n{\n   vec3 p3 = fract(vec3(p,p,p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 hashwithoutsine32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 hashwithoutsine33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec4 hashwithoutsine41(float p)\n{\n\tvec4 p4 = fract(vec4(p,p,p,p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec4 hashwithoutsine42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec4 hashwithoutsine43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec4 hashwithoutsine44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\n// Hybrid Taus\n// https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch37.html\nuint hybridtaus(uvec4 z)\n{\n    z.x = taus(z.x, 13, 19, 12, 0xfffffffeu);\n    z.y = taus(z.y, 2, 25, 4, 0xfffffff8u);\n    z.z = taus(z.z, 3, 11, 17, 0xfffffff0u);\n    z.w = z.w * 1664525u + 1013904223u;\n\n    return z.x ^ z.y ^ z.z ^ z.w;\n}\n\n// Interleaved Gradient Noise\n//  - Jimenez, Next Generation Post Processing in Call of Duty: Advanced Warfare\n//    Advances in Real-time Rendering, SIGGRAPH 2014\nfloat ign(vec2 v)\n{\n    vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);\n    return fract(magic.z * fract(dot(v, magic.xy)));\n}\n\n\n\n// Integer Hash - I\n// - Inigo Quilez, Integer Hash - I, 2017\n//   https://www.shadertoy.com/view/llGSzw\nuint iqint1(uint n)\n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n\n    return n;\n}\n\n// Integer Hash - II\n// - Inigo Quilez, Integer Hash - II, 2017\n//   https://www.shadertoy.com/view/XlXcW4\nuvec3 iqint2(uvec3 x)\n{\n    const uint k = 1103515245u;\n\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n\n    return x;\n}\n\n// Integer Hash - III\n// - Inigo Quilez, Integer Hash - III, 2017\n//   https://www.shadertoy.com/view/4tXyWN\nuint iqint3(uvec2 x)\n{\n    uvec2 q = 1103515245U * ( (x>>1U) ^ (x.yx   ) );\n    uint  n = 1103515245U * ( (q.x  ) ^ (q.y>>3U) );\n\n    return n;\n}\n\n\n\nuint jkiss32(uvec2 p)\n{\n    uint x=p.x;//123456789;\n    uint y=p.y;//234567891;\n\n    uint z=345678912u,w=456789123u,c=0u;\n    int t;\n    y ^= (y<<5); y ^= (y>>7); y ^= (y<<22);\n    t = int(z+w+c); z = w; c = uint(t < 0); w = uint(t&2147483647);\n    x += 1411392427u;\n    return x + y + w;\n}\n\n\n\n// linear congruential generator\nuint lcg(uint p)\n{\n    return p * 1664525u + 1013904223u;\n}\n\n\n\n// MD5GPU\n// https://www.microsoft.com/en-us/research/wp-content/uploads/2007/10/tr-2007-141.pdf\n#define A0 0x67452301u\n#define B0 0xefcdab89u\n#define C0 0x98badcfeu\n#define D0 0x10325476u\n\nuint F(uvec3 v) { return (v.x & v.y) | (~v.x & v.z); }\nuint G(uvec3 v) { return (v.x & v.z) | (v.y & ~v.z); }\nuint H(uvec3 v) { return v.x ^ v.y ^ v.z; }\nuint I(uvec3 v) { return v.y ^ (v.x | ~v.z); }\n\nvoid FF(inout uvec4 v, inout uvec4 rotate, uint x, uint ac)\n{\n    v.x = v.y + rotl(v.x + F(v.yzw) + x + ac, rotate.x);\n\n    rotate = rotate.yzwx;\n    v = v.yzwx;\n}\n\nvoid GG(inout uvec4 v, inout uvec4 rotate, uint x, uint ac)\n{\n    v.x = v.y + rotl(v.x + G(v.yzw) + x + ac, rotate.x);\n\n    rotate = rotate.yzwx;\n    v = v.yzwx;\n}\n\nvoid HH(inout uvec4 v, inout uvec4 rotate, uint x, uint ac)\n{\n    v.x = v.y + rotl(v.x + H(v.yzw) + x + ac, rotate.x);\n\n    rotate = rotate.yzwx;\n    v = v.yzwx;\n}\n\nvoid II(inout uvec4 v, inout uvec4 rotate, uint x, uint ac)\n{\n    v.x = v.y + rotl(v.x + I(v.yzw) + x + ac, rotate.x);\n\n    rotate = rotate.yzwx;\n    v = v.yzwx;\n}\n\nuint K(uint i)\n{\n    return uint(abs(sin(float(i)+1.)) * float(0xffffffffu));\n}\n\nuvec4 md5(uvec4 u)\n{\n    uvec4 digest = uvec4(A0, B0, C0, D0);\n    uvec4 r, v = digest;\n    uint i = 0u;\n\n\tuint M[16];\n\tM[0] = u.x; M[1] = u.y;\tM[2] = u.z;\tM[3] = u.w;\n\tM[4] = 0u; M[5] = 0u; M[6] = 0u; M[7] = 0u; M[8] = 0u;\n\tM[9] = 0u; M[10] = 0u; M[11] = 0u; M[12] = 0u; M[13] = 0u;\n\tM[14] = 0u; M[15] = 0u;\n\n    r = uvec4(7, 12, 17, 22);\n    FF(v, r, M[0], K(i++));\n    FF(v, r, M[1], K(i++));\n    FF(v, r, M[2], K(i++));\n    FF(v, r, M[3], K(i++));\n    FF(v, r, M[4], K(i++));\n    FF(v, r, M[5], K(i++));\n    FF(v, r, M[6], K(i++));\n    FF(v, r, M[7], K(i++));\n    FF(v, r, M[8], K(i++));\n    FF(v, r, M[9], K(i++));\n    FF(v, r, M[10], K(i++));\n    FF(v, r, M[11], K(i++));\n    FF(v, r, M[12], K(i++));\n    FF(v, r, M[13], K(i++));\n    FF(v, r, M[14], K(i++));\n    FF(v, r, M[15], K(i++));\n\n    r = uvec4(5, 9, 14, 20);\n    GG(v, r, M[1], K(i++));\n    GG(v, r, M[6], K(i++));\n    GG(v, r, M[11], K(i++));\n    GG(v, r, M[0], K(i++));\n    GG(v, r, M[5], K(i++));\n    GG(v, r, M[10], K(i++));\n    GG(v, r, M[15], K(i++));\n    GG(v, r, M[4], K(i++));\n    GG(v, r, M[9], K(i++));\n    GG(v, r, M[14], K(i++));\n    GG(v, r, M[3], K(i++));\n    GG(v, r, M[8], K(i++));\n    GG(v, r, M[13], K(i++));\n    GG(v, r, M[2], K(i++));\n    GG(v, r, M[7], K(i++));\n    GG(v, r, M[12], K(i++));\n\n    r = uvec4(4, 11, 16, 23);\n    HH(v, r, M[5], K(i++));\n    HH(v, r, M[8], K(i++));\n    HH(v, r, M[11], K(i++));\n    HH(v, r, M[14], K(i++));\n    HH(v, r, M[1], K(i++));\n    HH(v, r, M[4], K(i++));\n    HH(v, r, M[7], K(i++));\n    HH(v, r, M[10], K(i++));\n    HH(v, r, M[13], K(i++));\n    HH(v, r, M[0], K(i++));\n    HH(v, r, M[3], K(i++));\n    HH(v, r, M[6], K(i++));\n    HH(v, r, M[9], K(i++));\n    HH(v, r, M[12], K(i++));\n    HH(v, r, M[15], K(i++));\n    HH(v, r, M[2], K(i++));\n\n    r = uvec4(6, 10, 15, 21);\n    II(v, r, M[0], K(i++));\n    II(v, r, M[7], K(i++));\n    II(v, r, M[14], K(i++));\n    II(v, r, M[5], K(i++));\n    II(v, r, M[12], K(i++));\n    II(v, r, M[3], K(i++));\n    II(v, r, M[10], K(i++));\n    II(v, r, M[1], K(i++));\n    II(v, r, M[8], K(i++));\n    II(v, r, M[15], K(i++));\n    II(v, r, M[6], K(i++));\n    II(v, r, M[13], K(i++));\n    II(v, r, M[4], K(i++));\n    II(v, r, M[11], K(i++));\n    II(v, r, M[2], K(i++));\n    II(v, r, M[9], K(i++));\n\n    return digest + v;\n}\n\n\n\n// Adapted from MurmurHash3_x86_32 from https://github.com/aappleby/smhasher\nuint murmur3(uint seed)\n{\n    uint h = 0u;\n    uint k = seed;\n\n    k *= c1;\n    k = rotl(k,15u);\n    k *= c2;\n\n    h ^= k;\n    h = rotl(h,13u);\n    h = h*5u+0xe6546b64u;\n\n    h ^= 4u;\n\n    return fmix(h);\n}\n\n// Adapted from MurmurHash3_x86_32 from https://github.com/aappleby/smhasher\nuint murmur3(uvec2 seed)\n{\n    uint h = 0u;\n    uint k = seed.x;\n\n    k *= c1;\n    k = rotl(k,15u);\n    k *= c2;\n\n    h ^= k;\n    h = rotl(h,13u);\n    h = h*5u+0xe6546b64u;\n\n    k = seed.y;\n\n    k *= c1;\n    k = rotl(k,15u);\n    k *= c2;\n\n    h ^= k;\n    h = rotl(h,13u);\n    h = h*5u+0xe6546b64u;\n\n    h ^= 8u;\n\n    return fmix(h);\n}\n\n// Adapted from MurmurHash3_x86_32 from https://github.com/aappleby/smhasher\nuint murmur3(uvec3 seed)\n{\n    uint h = 0u;\n    uint k = seed.x;\n\n    k *= c1;\n    k = rotl(k,15u);\n    k *= c2;\n\n    h ^= k;\n    h = rotl(h,13u);\n    h = h*5u+0xe6546b64u;\n\n    k = seed.y;\n\n    k *= c1;\n    k = rotl(k,15u);\n    k *= c2;\n\n    h ^= k;\n    h = rotl(h,13u);\n    h = h*5u+0xe6546b64u;\n\n    k = seed.z;\n\n    k *= c1;\n    k = rotl(k,15u);\n    k *= c2;\n\n    h ^= k;\n    h = rotl(h,13u);\n    h = h*5u+0xe6546b64u;\n\n    h ^= 12u;\n\n    return fmix(h);\n}\n\n// Adapted from MurmurHash3_x86_32 from https://github.com/aappleby/smhasher\nuint murmur3(uvec4 seed)\n{\n    uint h = 0u;\n    uint k = seed.x;\n\n    k *= c1;\n    k = rotl(k,15u);\n    k *= c2;\n\n    h ^= k;\n    h = rotl(h,13u);\n    h = h*5u+0xe6546b64u;\n\n    k = seed.y;\n\n    k *= c1;\n    k = rotl(k,15u);\n    k *= c2;\n\n    h ^= k;\n    h = rotl(h,13u);\n    h = h*5u+0xe6546b64u;\n\n    k = seed.z;\n\n    k *= c1;\n    k = rotl(k,15u);\n    k *= c2;\n\n    h ^= k;\n    h = rotl(h,13u);\n    h = h*5u+0xe6546b64u;\n\n    k = seed.w;\n\n    k *= c1;\n    k = rotl(k,15u);\n    k *= c2;\n\n    h ^= k;\n    h = rotl(h,13u);\n    h = h*5u+0xe6546b64u;\n\n    h ^= 16u;\n\n    return fmix(h);\n}\n\n// https://www.pcg-random.org/\nuint pcg(uint v)\n{\n\tuint state = v * 747796405u + 2891336453u;\n\tuint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n\treturn (word >> 22u) ^ word;\n}\n\n\n\nuvec2 pcg2d(uvec2 v)\n{\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    return v;\n}\n\n// http://www.jcgt.org/published/0009/03/02/\nuvec3 pcg3d(uvec3 v) {\n\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    v ^= v >> 16u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    return v;\n}\n\n// http://www.jcgt.org/published/0009/03/02/\nuvec3 pcg3d16(uvec3 v)\n{\n    v = v * 12829u + 47989u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n\tv >>= 16u;\n\n    return v;\n}\n\n// http://www.jcgt.org/published/0009/03/02/\nuvec4 pcg4d(uvec4 v)\n{\n    v = v * 1664525u + 1013904223u;\n    \n    v.x += v.y*v.w;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    v.w += v.y*v.z;\n    \n    v ^= v >> 16u;\n    \n    v.x += v.y*v.w;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    v.w += v.y*v.z;\n    \n    return v;\n}\n\n\n\n// UE4's PseudoRandom function\n// https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Shaders/Private/Random.ush\nfloat pseudo(vec2 v) {\n    v = fract(v/128.)*128. + vec2(-64.340622, -72.465622);\n    return fract(dot(v.xyx * v.xyy, vec3(20.390625, 60.703125, 2.4281209)));\n}\n\n\n\n// Numerical Recipies 3rd Edition\nuint ranlim32(uint j){\n    uint u, v, w1, w2, x, y;\n\n    v = 2244614371U;\n    w1 = 521288629U;\n    w2 = 362436069U;\n\n    u = j ^ v;\n\n    u = u * 2891336453U + 1640531513U;\n    v ^= v >> 13; v ^= v << 17; v ^= v >> 5;\n    w1 = 33378u * (w1 & 0xffffu) + (w1 >> 16);\n    w2 = 57225u * (w2 & 0xffffu) + (w2 >> 16);\n\n    v = u;\n\n    u = u * 2891336453U + 1640531513U;\n    v ^= v >> 13; v ^= v << 17; v ^= v >> 5;\n    w1 = 33378u * (w1 & 0xffffu) + (w1 >> 16);\n    w2 = 57225u * (w2 & 0xffffu) + (w2 >> 16);\n\n    x = u ^ (u << 9); x ^= x >> 17; x ^= x << 6;\n    y = w1 ^ (w1 << 17); y ^= y >> 15; y ^= y << 5;\n\n    return (x + v) ^ (y + w2);\n}\n\n\n\n// SuperFastHash, adapated from http://www.azillionmonkeys.com/qed/hash.html\nuint superfast(uint data)\n{\n\tuint hash = 4u, tmp;\n\n    hash += data & 0xffffu;\n    tmp = (((data >> 16) & 0xffffu) << 11) ^ hash;\n    hash = (hash << 16) ^ tmp;\n    hash += hash >> 11;\n\n    /* Force \"avalanching\" of final 127 bits */\n    hash ^= hash << 3;\n    hash += hash >> 5;\n    hash ^= hash << 4;\n    hash += hash >> 17;\n    hash ^= hash << 25;\n    hash += hash >> 6;\n\n    return hash;\n}\n\n\n// SuperFastHash, adapated from http://www.azillionmonkeys.com/qed/hash.html\nuint superfast(uvec2 data)\n{\n    uint hash = 8u, tmp;\n\n    hash += data.x & 0xffffu;\n    tmp = (((data.x >> 16) & 0xffffu) << 11) ^ hash;\n    hash = (hash << 16) ^ tmp;\n    hash += hash >> 11;\n\n    hash += data.y & 0xffffu;\n    tmp = (((data.y >> 16) & 0xffffu) << 11) ^ hash;\n    hash = (hash << 16) ^ tmp;\n    hash += hash >> 11;\n\n    /* Force \"avalanching\" of final 127 bits */\n    hash ^= hash << 3;\n    hash += hash >> 5;\n    hash ^= hash << 4;\n    hash += hash >> 17;\n    hash ^= hash << 25;\n    hash += hash >> 6;\n\n    return hash;\n}\n\n// SuperFastHash, adapated from http://www.azillionmonkeys.com/qed/hash.html\nuint superfast(uvec3 data)\n{\n    uint hash = 8u, tmp;\n\n    hash += data.x & 0xffffu;\n    tmp = (((data.x >> 16) & 0xffffu) << 11) ^ hash;\n    hash = (hash << 16) ^ tmp;\n    hash += hash >> 11;\n\n    hash += data.y & 0xffffu;\n    tmp = (((data.y >> 16) & 0xffffu) << 11) ^ hash;\n    hash = (hash << 16) ^ tmp;\n    hash += hash >> 11;\n\n    hash += data.z & 0xffffu;\n    tmp = (((data.z >> 16) & 0xffffu) << 11) ^ hash;\n    hash = (hash << 16) ^ tmp;\n    hash += hash >> 11;\n\n    /* Force \"avalanching\" of final 127 bits */\n    hash ^= hash << 3;\n    hash += hash >> 5;\n    hash ^= hash << 4;\n    hash += hash >> 17;\n    hash ^= hash << 25;\n    hash += hash >> 6;\n\n    return hash;\n}\n\n// SuperFastHash, adapated from http://www.azillionmonkeys.com/qed/hash.html\nuint superfast(uvec4 data)\n{\n    uint hash = 8u, tmp;\n\n    hash += data.x & 0xffffu;\n    tmp = (((data.x >> 16) & 0xffffu) << 11) ^ hash;\n    hash = (hash << 16) ^ tmp;\n    hash += hash >> 11;\n\n    hash += data.y & 0xffffu;\n    tmp = (((data.y >> 16) & 0xffffu) << 11) ^ hash;\n    hash = (hash << 16) ^ tmp;\n    hash += hash >> 11;\n\n    hash += data.z & 0xffffu;\n    tmp = (((data.z >> 16) & 0xffffu) << 11) ^ hash;\n    hash = (hash << 16) ^ tmp;\n    hash += hash >> 11;\n\n    hash += data.w & 0xffffu;\n    tmp = (((data.w >> 16) & 0xffffu) << 11) ^ hash;\n    hash = (hash << 16) ^ tmp;\n    hash += hash >> 11;\n\n    /* Force \"avalanching\" of final 127 bits */\n    hash ^= hash << 3;\n    hash += hash >> 5;\n    hash ^= hash << 4;\n    hash += hash >> 17;\n    hash ^= hash << 25;\n    hash += hash >> 6;\n\n    return hash;\n}\n\n\n\n// Tiny Encryption Algorithm\n//  - Zafar et al., GPU random numbers via the tiny encryption algorithm, HPG 2010\nuvec2 tea(int tea, uvec2 p) {\n    uint s = 0u;\n\n    for( int i = 0; i < tea; i++) {\n        s += 0x9E3779B9u;\n        p.x += (p.y<<4u)^(p.y+s)^(p.y>>5u);\n        p.y += (p.x<<4u)^(p.x+s)^(p.x>>5u);\n    }\n    return p.xy;\n}\n\n\n\n// common GLSL hash\n//  - Rey, On generating random numbers, with help of y= [(a+x)sin(bx)] mod 1,\n//    22nd European Meeting of Statisticians and the 7th Vilnius Conference on\n//    Probability Theory and Mathematical Statistics, August 1998\n/*\nuvec2 trig(uvec2 p) {\n    return uvec2(float(0xffffff)*fract(43757.5453*sin(dot(vec2(p),vec2(12.9898,78.233)))));\n}\n*/\nfloat trig(vec2 p)\n{\n    return fract(43757.5453*sin(dot(p, vec2(12.9898,78.233))));\n}\n\n\n\n// Wang hash, described on http://burtleburtle.net/bob/hash/integer.html\n// original page by Thomas Wang 404\nuint wang(uint v)\n{\n    v = (v ^ 61u) ^ (v >> 16u);\n    v *= 9u;\n    v ^= v >> 4u;\n    v *= 0x27d4eb2du;\n    v ^= v >> 15u;\n    return v;\n}\n\n\n\n// 128-bit xorshift\n//  - Marsaglia, Xorshift RNGs, Journal of Statistical Software, v8n14, 2003\nuint xorshift128(uvec4 v)\n{\n    v.w ^= v.w << 11u;\n    v.w ^= v.w >> 8u;\n    v = v.wxyz;\n    v.x ^= v.y;\n    v.x ^= v.y >> 19u;\n    return v.x;\n}\n\n\n\n// 32-bit xorshift\n//  - Marsaglia, Xorshift RNGs, Journal of Statistical Software, v8n14, 2003\nuint xorshift32(uint v)\n{\n    v ^= v << 13u;\n    v ^= v >> 17u;\n    v ^= v << 5u;\n    return v;\n}\n\n\n\n// xxhash (https://github.com/Cyan4973/xxHash)\n//   From https://www.shadertoy.com/view/Xt3cDn\nuint xxhash32(uint p)\n{\n\tconst uint PRIME32_2 = 2246822519U, PRIME32_3 = 3266489917U;\n\tconst uint PRIME32_4 = 668265263U, PRIME32_5 = 374761393U;\n\tuint h32 = p + PRIME32_5;\n\th32 = PRIME32_4*((h32 << 17) | (h32 >> (32 - 17)));\n    h32 = PRIME32_2*(h32^(h32 >> 15));\n    h32 = PRIME32_3*(h32^(h32 >> 13));\n    return h32^(h32 >> 16);\n}\n\nuint xxhash32(uvec2 p)\n{\n    const uint PRIME32_2 = 2246822519U, PRIME32_3 = 3266489917U;\n\tconst uint PRIME32_4 = 668265263U, PRIME32_5 = 374761393U;\n    uint h32 = p.y + PRIME32_5 + p.x*PRIME32_3;\n    h32 = PRIME32_4*((h32 << 17) | (h32 >> (32 - 17)));\n    h32 = PRIME32_2*(h32^(h32 >> 15));\n    h32 = PRIME32_3*(h32^(h32 >> 13));\n    return h32^(h32 >> 16);\n}\n\nuint xxhash32(uvec3 p)\n{\n    const uint PRIME32_2 = 2246822519U, PRIME32_3 = 3266489917U;\n\tconst uint PRIME32_4 = 668265263U, PRIME32_5 = 374761393U;\n\tuint h32 =  p.z + PRIME32_5 + p.x*PRIME32_3;\n\th32 = PRIME32_4*((h32 << 17) | (h32 >> (32 - 17)));\n\th32 += p.y * PRIME32_3;\n\th32 = PRIME32_4*((h32 << 17) | (h32 >> (32 - 17)));\n    h32 = PRIME32_2*(h32^(h32 >> 15));\n    h32 = PRIME32_3*(h32^(h32 >> 13));\n    return h32^(h32 >> 16);\n}\n\nuint xxhash32(uvec4 p)\n{\n    const uint PRIME32_2 = 2246822519U, PRIME32_3 = 3266489917U;\n\tconst uint PRIME32_4 = 668265263U, PRIME32_5 = 374761393U;\n\tuint h32 =  p.w + PRIME32_5 + p.x*PRIME32_3;\n\th32 = PRIME32_4*((h32 << 17) | (h32 >> (32 - 17)));\n\th32 += p.y * PRIME32_3;\n\th32 = PRIME32_4*((h32 << 17) | (h32 >> (32 - 17)));\n\th32 += p.z * PRIME32_3;\n\th32 = PRIME32_4*((h32 << 17) | (h32 >> (32 - 17)));\n    h32 = PRIME32_2*(h32^(h32 >> 15));\n    h32 = PRIME32_3*(h32^(h32 >> 13));\n    return h32^(h32 >> 16);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}