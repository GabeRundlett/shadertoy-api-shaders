{
    "Shader": {
        "info": {
            "date": "1543351421",
            "description": "Rotations in 4-space generated by sequence of reflections. Apply \"random\" sequence of symmetry operations to fundamental reqion, then build up a quaternion pair for the complete rotation from individual reflections.\n\nSee code for controls.",
            "flags": 48,
            "hasliked": 0,
            "id": "ltKfzV",
            "likes": 16,
            "name": "4-space rotations",
            "published": 3,
            "tags": [
                "rotations",
                "reflections",
                "quaternions",
                "polytope",
                "4space",
                "slerp"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 1288
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Created by Matthew Arcus, 2018.\n//\n// Rotations in 4-dimensional space, generated from successive reflections,\n// represented as quaternions.\n//\n// Generate a rotational symmetry of a polytope, construct the quaternion pair\n// representing it, then apply slerp.\n//\n// Different symmetry groups can be specified at compilation.\n//\n// <mouse>: rotates\n// <UP>,<DOWN>: zoom in and out.\n// 1-4: activate/deactive mirrors P,Q,R,S\n// 'r': R3 rotation\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// \"Quadriplanar coordinates\", ie. distance to mirror planes.\nconst vec4 defaultquad = vec4(1,1,1,1);\n//const vec4 defaultquad = vec4(1,0,0,0);\nconst float rotationtime = 2.0; // Time to do rotation.a\nconst float pausetime = 1.0; // Time to pause after rotation\nconst int starttime = 0;\n\nconst float linescale = 1.5; // Modify to change line width\nconst float camera = 6.0;\n\n#define POINTWIDTH 0.04\n#define EDGEWIDTH 0.02\n// Raymarching parameters\n#define MAXDIST 20.0\n#define NSTEPS 200\n#define MAXSTEP 0.5\n#define FFACTOR 0.75\n#define PRECISION 0.001\n\n#if 0\n// Linear Coxeter diagrams:\n//  A B C   -- dihedral\n// o-o-o-o  -- the graph\n// P Q R S  -- mirror planes\n//\n// Convert to 6 dihedral angles:\n// angles = (A,B,2,2,2,C)\n\n// Given mirror planes PQRS, angles are PQ,QR,RP,PS,QS,RS\n#if 1\n// Hypertetrahedron\n// The Omnitruncated form represents the Cayley Graph of S5\nconst int PQ = 3, QR = 3, RS = 3;\nconst int NFOLDS = 4;\n#elif 1\n// Hypercube\nconst int PQ = 4, QR = 3, RS = 3;\nconst int NFOLDS = 4;\n#elif 0\n// Prism\nconst int PQ = 5, QR = 3, RS = 2;\nconst int NFOLDS = 6;\n#elif 0\n// Duoprism\nconst int PQ = 3, QR = 2, RS = 4;\nconst int NFOLDS = 6;\n#elif 0\n// 24-cell\nconst int PQ = 3, QR = 4, RS = 3;\nconst int NFOLDS = 6;\n#else\n// 120- & 600-cell\nconst int PQ = 5, QR = 3, RS = 3;\nconst int NFOLDS = 16;\n#endif\n// Common values\nconst int PS = 2, QS = 2, RP = 2;\n#else\n// D4 - our only non-linear Coxeter diagram\nconst int PQ = 3, QR = 3, RS = 2;\nconst int PS = 2, QS = 3, RP = 2;\nconst int NFOLDS = 4;\n#endif\n\n#define PI 3.141592654\n\nint alert = 0;\nvoid assert(int k, bool test) {\n  if (!test) alert = k;\n}\nvoid assert(bool test) {\n  if (!test) alert = -1;\n}\n\n// Approximate equality, mainly used for assertion checks.\nbool eq(float a, float b) {\n  return abs(a-b) < 1e-4;\n}\n\nbool eq(vec3 a, vec3 b) {\n  return eq(a.x,b.x) && eq(a.y,b.y) && eq(a.z,b.z);\n}\n\nbool eq(vec4 a, vec4 b) {\n  return eq(a.x,b.x) && eq(a.y,b.y) && eq(a.z,b.z) && eq(a.w,b.w);\n}\n\n// Quaternion multiplication\n\n// (p+P)(q+Q) = pq + pQ + qP + PQ\nvec4 qmul(vec4 p, vec4 q) {\n  vec3 P = p.xyz, Q = q.xyz;\n  return vec4(p.w*Q+q.w*P+cross(P,Q),p.w*q.w-dot(P,Q));\n}\n\nvec4 qconj(vec4 p) {\n  return vec4(-p.xyz,p.w);\n}\n\nvec4 qpow1 (vec4 q, float t) {\n  if (q == vec4(0,0,0,1)) return vec4(0,0,0,1);\n  float l = length(q.xyz);\n  float phi = atan(l,q.w);\n  vec3 n = q.xyz/l;\n  return normalize(vec4(sin(t*phi)*n,cos(t*phi)));\n}\n\nvec4 qinv(vec4 p) {\n  return qconj(p)/dot(p,p);\n}\n\nvec4 qdiv(vec4 p, vec4 q) {\n  return qmul(p,qinv(q));\n}\n\nvec4 qabs(vec4 p) {\n  // Convert to quaternion with q.w >= 0\n  return p.w >= 0.0 ? p : -p;\n}\n\n// Reflect x in plane orthogonal to p (unnormalized)\nvec4 applyreflection(vec4 p, vec4 x) {\n  return -qmul(p,qmul(qconj(x),p))/dot(p,p);\n}\n\n// Rotate x in by quaternions p and q (normalized)\nvec4 applyrotation(vec4 p, vec4 x, vec4 q) {\n  return qmul(p,qmul(x,q));\n}\n\n// Dihedral angle between two faces with normals n,m\n// Assume the normals are pointing inwards\nfloat dihedral(vec4 n, vec4 m) {\n  return PI - acos(dot(n,m));\n}\n\nfloat facecosine(int x) {\n  return -cos(PI/float(x));\n}\n\n// Stereographic projection\nvec3 stereographic(vec4 p4) {\n  float k = 1.0/(1.0+p4.w);\n  return k*p4.xyz;\n}\n\n// And the inverse, which is what we really need.\nvec4 istereographic(vec3 p, out float k) {\n  k = 2.0/(1.0+dot(p,p));\n  return vec4(k*p,k-1.0);\n}\n\nvec4 closest(vec4 p, vec4 a, vec4 b) {\n  // Find closest point on line through a and b\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h,0.0,1.0);\n  return a + h*b;\n}\n\n// Spherical distance from p to q (on a great circle)\nfloat dist(vec4 p, vec4 q) {\n#if 1\n  return length(p-q);\n#else\n  return acos(clamp(dot(p,q),-1.0,1.0));\n#endif\n}\n\n// Spherical distance from p to line (great circle) through q and r\n// This is an approximation, but seems good enough for now\nfloat dist(vec4 p, vec4 q, vec4 r) {\n#if 1\n  return dist(p,normalize(closest(p,q,r)));\n#else  \n  mat2 m = inverse(mat2(dot(q,q),dot(q,r),dot(q,r),dot(r,r)));\n  vec2 ab = m*vec2(dot(p,q),dot(p,r));\n  // p1 in plane of q,r, on hypersphere\n  ab = max(ab,0.0); // Clip to segment\n  vec4 p1 = normalize(ab[0]*q + ab[1]*r);\n  // And return the distance to the closest point.\n  return dist(p,p1);\n#endif\n}\n\n// Spherical interpolation between (0,0,0,1) and p\nvec4 slerp(vec4 p, float t) {\n  if (p == vec4(0,0,0,1)) return p;\n  if (p.w < 0.0) p = -p; // Use shortest path\n  //assert(1,p.w >= 0.0);\n  float alpha = acos(p.w); // Might be inaccurate for small angles\n  float theta = t*alpha;\n  vec4 r = vec4(sin(theta)*p.xyz,cos(theta)*sin(alpha));\n  return normalize(r);\n}\n\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nbool tryorthogonal(vec4 p, vec4 q, mat2 m, vec4 r, out vec4 result) {\n  // Find component of r orthogonal to p and q\n  // Return indication of size of result\n  vec2 a = m*vec2(dot(r,p),dot(r,q));\n  result = r - a[0]*p - a[1]*q;\n  return dot(result,result) > 1e-3;\n}\n\nvec4 findorthogonal(vec4 p, vec4 q) {\n  //assert(false);\n  // Find a 4-vector orthogonal to p and q\n  // In 3-space we could use cross product\n  // In 4-space try 3 different directions\n  // There must be a nice GA solution to this.\n  // Or maybe reduced row echelon -> null space basis?\n  mat2 m = inverse(mat2(dot(p,p),dot(p,q),\n                        dot(p,q),dot(q,q)));\n  vec4 result;\n  if (tryorthogonal(p,q,m,vec4(1,0,0,0),result)) return result;\n  else if (tryorthogonal(p,q,m,vec4(0,1,0,0),result)) return result;\n  else if (tryorthogonal(p,q,m,vec4(0,0,1,0),result)) return result;\n  else assert(3,false);\n  return vec4(0);\n}\n\n// Find 4-rotation that take p0 to p1 and q0 to q2 (note name of q2)\n// left and right are set to normalized quaternions such that\n// x -> pxq is the rotation\nvoid rotate4(vec4 p0, vec4 p1, vec4 q0, vec4 q2,\n             out vec4 left, out vec4 right) {\n  assert(1,eq(length(p0),length(p1)));\n  assert(1,eq(length(q0),length(q2)));\n  if (eq(p0,p1)) {\n    if (eq(q0,q2)) {\n      // Nothing to do\n      left = vec4(0,0,0,1);\n      right = vec4(0,0,0,1);\n      return;\n    }\n    // Swap if p0 == p1 and q0 != q1\n    vec4 t = p0; p0 = q0; q0 = t;\n    t = p1; p1 = q2; q2 = t;\n  }\n  // Find quaternion map from p0->p1\n  vec4 s = p0-p1;\n  assert(2,eq(p1,applyreflection(s,p0)));\n\n  // New position for q0\n  vec4 q1 = applyreflection(s,q0);\n  vec4 t = !eq(q1,q2)? q1-q2: findorthogonal(p1,q2);\n  assert(1,eq(p1,applyreflection(t,p1)));\n  assert(1,eq(q2,applyreflection(t,q1)));\n  // Applying unnormalized rotations is troublesome.\n  left = normalize(qmul(t,qconj(s)));\n  right = normalize(qmul(qconj(s),t));\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// GLOBAL VARIABLES\n////////////////////////////////////////////////////////////////////////////////\n\nvec4 P = vec4(0), Q = vec4(0), R = vec4(0), S = vec4(0); // Mirror planes\nvec4 p = vec4(0), q = vec4(0), r = vec4(0), s = vec4(0); // Vertices of fundamental tetrahedron\nvec4 point = vec4(0);// Wythoff point\nvec4 ppoint = vec4(0),qpoint = vec4(0); // Projection of point on faces, normalized.\nvec4 rpoint = vec4(0),spoint = vec4(0);\nvec4 qleft = vec4(0), qright = vec4(0); // Quaternions for the 4-rotation\n\nint tryreflect(inout vec4 p, vec4 q) {\n  float t = dot(p,q);\n  if (t >= 0.0) return 0;\n  p -= 2.0*t*q;\n  return 1;\n}\n\n// Reflect in hyperplanes until in fundamental region\nvec4 fold(vec4 p) {\n  for (int i = 0; i < NFOLDS; i++) {\n    // P is always x = 0\n    p.x = abs(p.x);\n    int k = tryreflect(p,Q);\n    k += tryreflect(p,R);\n    k += tryreflect(p,S);\n    if (k == 0) break;\n  }\n  return p;\n}\n\nvoid solveangles(vec4 quad) {\n  // Convert parameters to face angle cosines\n  float A = facecosine(PQ);\n  float B = facecosine(QR);\n  float C = facecosine(RP);\n  float D = facecosine(PS);\n  float E = facecosine(QS);\n  float F = facecosine(RS);\n  // Now construct 4 mirror planes satisfying those constraints\n  P = vec4(1,0,0,0);\n  // Q = [a,b,0,0], P.Q = A\n  float a = A;\n  assert(1,a*a < 1.0);\n  float b = sqrt(1.0 - a*a);\n  Q = vec4(a,b,0,0);\n  // R = [c,d,e,0]\n  // R.P = C = c\n  // Q.R = B = ac + bd\n  float c = C, d = (B-a*c)/b;\n  assert(1,c*c + d*d < 1.0);\n  float e = sqrt(1.0 - c*c - d*d);\n  R = vec4(c,d,e,0);\n\n  // We have 3 simultaneous equations for the final vector S\n  // Solve the easy way with a matrix inverse to find its 3-component.\n  mat3 m3 = inverse(transpose(mat3(P.xyz,Q.xyz,R.xyz)));\n  vec3 S3 = m3*vec3(D,E,F);\n\n  // We might have dot(u,u) = 1, in which case the fundamental region\n  // is 3 dimensional and we have an infinite 3d honeycomb. We don't\n  // do honeycombs here so exclude this case.\n  assert(1,dot(S3,S3) < 1.0-1e-4);\n\n  // Finally, set S.w to give S unit length\n  S = vec4(S3, sqrt(1.0 - dot(S3,S3)));\n  // Always check your workings\n  assert(1,eq(dihedral(P,Q),PI/float(PQ)));\n  assert(1,eq(dihedral(Q,R),PI/float(QR)));\n  assert(1,eq(dihedral(R,P),PI/float(RP)));\n  assert(1,eq(dihedral(P,S),PI/float(PS)));\n  assert(1,eq(dihedral(Q,S),PI/float(QS)));\n  assert(1,eq(dihedral(R,S),PI/float(RS)));\n\n  // Now find the 4 corners of the tetrahedron\n  mat4 m = inverse(transpose(mat4(P,Q,R,S)));\n  p = normalize(m[0]);\n  q = normalize(m[1]);\n  r = normalize(m[2]);\n  s = normalize(m[3]);\n\n  assert(1,eq(fold(p),p));\n  assert(1,eq(fold(q),q));\n  assert(1,eq(fold(r),r));\n  assert(1,eq(fold(s),s));\n\n  // Now I want to solve the \"quadriplanar\" equations:\n  // given vec4(x,y,z,w), find p with:\n  // p.P = x, p.Q = y, p.R = z, p.S = w\n  // but this is just given by m.\n  point = normalize(m*quad); // The Wythoff point\n  // These are the projections of the Wythoff point on\n  // the cell walls, normalized to the sphere, and used\n  // for drawing.\n  ppoint = normalize(point - dot(point,P)*P);\n  qpoint = normalize(point - dot(point,Q)*Q);\n  rpoint = normalize(point - dot(point,R)*R);\n  spoint = normalize(point - dot(point,S)*S);\n}\n\n// Apply a sequence of reflections determined\n// by seed, which should be even.\nvec4 randomfold(vec4 p, int seed) {\n  for (int i = 0; i < 1000; i++) {\n    if (i == 2*NFOLDS) break;\n    int side = seed & 3;\n    seed >>= 2;\n    // Shortcut: P is always x = 0\n    //if (side == 0) p -= 2.0*dot(p,P))*P;\n    if (side == 0) p.x = -p.x;\n    else if (side == 1) p -= 2.0*dot(p,Q)*Q;\n    else if (side == 2) p -= 2.0*dot(p,R)*R;\n    else p -= 2.0*dot(p,S)*S;\n  }\n  return p;\n}\n\n// Map a 3-point to a 4-point in the fundamental region\n// k is scale factor\nvec4 map(vec3 pos, out float k) {\n  vec4 p4 = istereographic(pos,k);\n  p4 = applyrotation(qleft,p4,qright);\n  p4 = fold(p4);\n  return p4;\n}\n\nfloat eval(vec3 pos) {\n  // Point and edge width\n  float pwidth = POINTWIDTH*linescale;\n  float ewidth = EDGEWIDTH*linescale;\n\n  float k;\n  vec4 p4 = map(pos,k);\n  float d = 1e8;\n\n  d = min(d,dist(p4,point)-pwidth);\n\n  d = min(d,dist(p4,point,ppoint)-ewidth);\n  d = min(d,dist(p4,point,qpoint)-ewidth);\n  d = min(d,dist(p4,point,rpoint)-ewidth);\n  d = min(d,dist(p4,point,spoint)-ewidth);\n  return d/k;\n}\n\nvec3 calcNormal(vec3 p, float t) {\n  float eps = 0.002; // Scale for ray length?\n  vec2 e = vec2(eps, 0.0);\n  return normalize(vec3(eval(p + e.xyy) - eval(p - e.xyy),\n                        eval(p + e.yxy) - eval(p - e.yxy),\n                        eval(p + e.yyx) - eval(p - e.yyx)));\n}\n\nfloat march(in vec3 ro, in vec3 rd) {\n  float t = 0.25;\n  for (int i = 0; i < NSTEPS; i++) {\n    //assert(i < 50);\n    vec3 p = ro + rd * t;\n    float d = eval(p);\n    d *= FFACTOR;       // Fudge factor\n    d = min(MAXSTEP,d); // Try and avoid overstepping\n    t += d;\n    if (d < t*PRECISION) return t;\n    if (t > MAXDIST) break;\n  }\n  return 1e8;\n}\n\nvec3 getcolor(vec3 pos) {\n  const float pwidth = POINTWIDTH*linescale;\n  const float ewidth = EDGEWIDTH*linescale;\n\n  float k;\n  vec4 p4 = map(pos,k);\n  float d0, d = 1e8;\n  int id = 0;\n\n  d0 = dist(p4,point)-pwidth;\n  if (d0 < d) { d = d0; id = 1; }\n  d0 = dist(p4,point,ppoint)-ewidth;\n  if (d0 < d) { d = d0; id = 2; }\n  d0 = dist(p4,point,qpoint)-ewidth;\n  if (d0 < d) { d = d0; id = 3; }\n  d0 = dist(p4,point,rpoint)-ewidth;\n  if (d0 < d) { d = d0; id = 4; }\n  d0 = dist(p4,point,spoint)-ewidth;\n  if (d0 < d) { d = d0; id = 5; }\n\n  if (id == 1) return vec3(0.02);\n  if (id == 2) return vec3(1,0,0);\n  if (id == 3) return vec3(0,1,0);\n  if (id == 4) return vec3(0,0,1);\n  if (id == 5) return vec3(1,1,0);\n  return vec3(0);\n}\n\nvoid makequaternions(int seed) {\n  // Generate new tetrahedron position\n  vec4 p1 = randomfold(p,seed);\n  vec4 q1 = randomfold(q,seed);\n  vec4 r1 = randomfold(r,seed);\n  vec4 s1 = randomfold(s,seed);\n  // Rotation 0 to shift p->p1,q->q1\n  vec4 left0,right0;\n  rotate4(p,p1,q,q1,left0,right0);\n  assert(3,eq(p1,applyrotation(left0,p,right0)));\n  assert(3,eq(q1,applyrotation(left0,q,right0)));\n\n  // Apply rotation 0 to r and s\n  vec4 r0 = applyrotation(left0,r,right0);\n  vec4 s0 = applyrotation(left0,s,right0);\n  assert(1,eq(distance(p1,r0),distance(p1,r1)));\n  assert(1,eq(distance(p1,s0),distance(p1,s1)));\n  assert(1,eq(distance(q1,r0),distance(q1,r1)));\n  assert(1,eq(distance(q1,s0),distance(q1,s1)));\n  // Rotation 1 to shift r0->r1, s0->s1\n  vec4 left1,right1;\n  rotate4(r0,r1,s0,s1,left1,right1);\n\n  // Combine for the full rotation, note order.\n  qleft = qmul(left1,left0);\n  qright = qmul(right0,right1);\n\n  // Not sure what we can do if one rotation is +ve\n  // and one is -ve.\n  if (qleft.w < 0.0 && qright.w < 0.0) {\n    qleft = -qleft;\n    qright = -qright;\n  }\n\n  // Check all this has worked\n  assert(4,eq(p1,applyrotation(qleft,p,qright)));\n  assert(4,eq(q1,applyrotation(qleft,q,qright)));\n  assert(4,eq(r1,applyrotation(qleft,r,qright)));\n  assert(4,eq(s1,applyrotation(qleft,s,qright)));\n\n  // Finally apply slerp for the current time\n  float t = mod(iTime,rotationtime+pausetime);\n  t = min(t/rotationtime,1.0);\n  qleft = slerp(qleft,t);\n  qright = slerp(qright,t);\n}\n\nvec3 transform(in vec3 p, bool dorotate) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,-theta);\n    p.zx = rotate(p.zx,phi);\n  }\n  if (dorotate) {\n    p.zx = rotate(p.zx,iTime * 0.2);\n  }\n  return p;\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.,1.);\n}\nvec3 ACESFilm2(vec3 color){\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec4 quad = vec4(float(!key(CHAR_0+1)),\n                   float(!key(CHAR_0+2)),\n                   float(!key(CHAR_0+3)),\n                   float(!key(CHAR_0+4)));\n\n  bool dorotate = key(CHAR_R);\n  // Changed this to const\n  //linescale = !key(CHAR_T) ? 1.0 : 2.0;\n  \n  solveangles(quad);\n  int seed = starttime + int((iTime+30.0)/(rotationtime+pausetime));\n  makequaternions(seed);\n  \n  vec2 screenpos = (2.0*fragCoord.xy - iResolution.xy) / iResolution.y;\n\n  vec3 ro = vec3(0,0,-camera);\n  ro.z *= 0.1*float(10+keycount(KEY_DOWN)-keycount(KEY_UP));\n  vec3 rd = vec3(screenpos,2.0);\n  vec3 li = vec3(0.5, 0.8, -3.0);\n\n  ro = transform(ro,dorotate);\n  rd = normalize(transform(rd,dorotate));\n  li = normalize(transform(li,dorotate));\n  float t = march(ro,rd);\n  vec3 color = vec3(0);\n  if (t < 1e8) {\n    vec3 pos = ro + t*rd;\n    vec3 n = calcNormal(pos,t);\n    color = 0.5*getcolor(pos);\n    float diffuse = clamp(dot(n, li), 0.0, 1.0);\n    color *= diffuse;\n    float specular = pow(max(0.0,dot(reflect(li,n),rd)),4.0);\n    color += 0.3*specular*vec3(1);\n  }\n  //if (fragCoord.x < 0.5*iResolution.x) color = ACESFilm2(color);\n  color = ACESFilm2(color);\n  //color = pow(color, vec3(0.4545));\n  if (!key(CHAR_A)) {\n    if (alert == -1) color.r = 1.0;\n    if (screenpos.y < -0.9) {\n      if (alert == 1) color = vec3(0,1,0);\n      else if (alert == 2) color = vec3(0,0,1);\n      else if (alert == 3) color = vec3(1,1,0);\n      else if (alert == 4) color = vec3(1,0,1);\n      else if (alert > 0) color = vec3(0,1,1);\n    }\n  }\n  fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define keystate(k,n) ( texelFetch(iChannel0,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n#if __VERSION__ < 300\n    t = vec4(0);\n#else\n    \n    int i = int(uv.x);\n    int j = int(uv.y);\n    if ( iFrame == 0 ) {\n        t = vec4(0);\n    } else {\n        t = texelFetch(iChannel1,ivec2(i,j),0); // Get current state   \n    }  \n    if (j == 0) {\n        float w1 = keystate(i,0).x;\n        if (w1 != 0.0) {\n            t.w = w1;\n            t.x++;\n        }\n    }     \n        \n#endif           \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_R = 82;\nconst int CHAR_T = 84;\nconst int CHAR_X = 88;\n\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\n#define key(code) (texelFetch(iChannel0, ivec2((code),2),0).x != 0.0)\n#define store(i,j) (texelFetch(iChannel1, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}