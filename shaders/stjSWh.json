{
    "Shader": {
        "info": {
            "date": "1627622177",
            "description": "This is another shader for Sableraph's weekly creative coding challenge, the theme was \"textile\". \n\nAt first I felt a bit disappointed a different prompt wasn't picked but in the end I really like how this one turned out. ",
            "flags": 0,
            "hasliked": 0,
            "id": "stjSWh",
            "likes": 18,
            "name": "Magic Doormat Dispenser",
            "published": 3,
            "tags": [
                "3d",
                "raymarching"
            ],
            "usePreview": 0,
            "username": "Tater",
            "viewed": 426
        },
        "renderpass": [
            {
                "code": "#define STEPS 128.0\n#define MDIST 40.0\n#define pi 3.1415926535\n#define pmod(p,x) (mod(p,x)-0.5*(x))\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a));\n\n//box sdf\nfloat box(vec3 p, vec3 s){\n    vec3 d = abs(p)-s;\n    return max(d.x,max(d.y,d.z));\n}\n//iq's color palette function\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n//An interpolated sinwave with variable sample rate to give the carpets a low poly look\nfloat psin(float x, float b){\n    return sin(floor(b*x)/b)+(sin(floor(b*x+1.0)/b)-sin(floor(b*x)/b))*mod(b*x,1.0);\n}\n\nvec3 map(vec3 p){\n    vec3 a = vec3(0);\n    \n    float t = mod(iTime,9999.0);\n    \n    //scroll the y axis up all the time \n    p.y-=t-0.25;\n    \n    //id of y axis domain repition\n    float id = floor(p.y/1.0)+0.5;\n    \n    //x value to offset carpets so they fly left and right\n    float xoff =max(0.0,(id+t)*2.0);\n    xoff = xoff*xoff*sign(sin(id*pi));;\n    \n    //domain repition in the y axis\n    p.y = pmod(p.y,1.0);\n\n    //Add some low poly waves to the carpets\n    float sb = .7;\n    float wscl = 0.06;\n    p.y+=psin(p.x*4.0+id,sb)*wscl;\n    p.y-=psin(p.z*4.0+id,sb)*wscl;\n\n    //calculate box sdf\n    a.x = box(p-vec3(xoff,0,0),vec3(2,0.025,2));\n    \n    //pass some info to coloring code\n    a.y = id;\n    a.z = xoff;\n    \n    return a;\n}\n\nvec3 norm(vec3 p){\n    vec2 e = vec2(0.01,0);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\n//mirror function\nvoid mo(inout vec2 p){\n  if(p.y>p.x) p = p.yx;\n}\nvec2 kifs(vec2 uv,float id){\n    //some kifs and abs() duplication code\n    for(float i = 0.0; i< 9.0; i++){\n        uv = abs(uv)-0.7*i*(vec2((sin(id*0.15)),0.2*(cos(id*0.22))));\n        //Adjusting this rotation value gives some cool alternate designs\n        uv*=rot(pi/(2.0));\n        mo(uv);\n    }\n    uv = abs(uv)-0.5;\n    uv = abs(uv)-0.5;\n    uv = abs(uv)-0.5;\n    return uv;\n}\nfloat getRug(vec2 uv, float id){\n    vec3 col = vec3(0);\n    float a =0.0;\n    \n    //sometimes the result of the kifs will not give any pattern on the carpet\n    //to fix this I run the kifs 8 times with different initial conditions and xor\n    //all the patterns so you can't really tell when there are gaps.\n    //someone who is better at kifs could probably just fix the problem\n    \n    for(float i = 0.0; i <8.0; i++){\n        a = mix(a,1.0-a,smoothstep(0.21,0.19,box(vec3(kifs(uv,id+i*pi),0),vec3(0.2)))); \n    }\n    return float(a);\n}\n//radial mod (stole a flopine shader)\nvec2 moda (vec2 p, float per)\n{\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    a = mod(a-per/2.,per)-per/2.;\n    return vec2 (cos(a),sin(a))*l;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    float t = iTime;\n    float aa = 1.0/iResolution.y;\n    vec3 ro = vec3(0,3,-7);\n    vec3 rd = normalize(vec3(uv,1.0));\n    rd.yz*=rot(-0.4 );\n    vec3 p = ro;\n    vec3 d;\n    bool hit = false;\n    float dO;\n    //raymarch loop\n    for(float i = 0.0; i<STEPS; i++){\n        d = map(p);\n        dO+=min(0.75,d.x*0.8);\n        p = ro+rd*dO;\n        \n        if(abs(d.x)<0.001){\n            hit = true;\n            break;\n        }\n        if(dO>MDIST){break;}\n    }\n    \n    //if ray marcher hits something color it\n    if(hit){ \n        vec3 palc = 0.9*pal(d.y/3.0, vec3(0.3),vec3(0.5),vec3(1.7),vec3(0,0.33,0.66) );\n        float bright = mix(1.,1.,sin(d.y*pi)*0.5+0.5);\n        vec3 al = mix(palc,vec3(bright),getRug(vec2(p.x-d.z,p.z),d.y));\n\n        vec3 n = norm(p);\n        vec3 ld = normalize(vec3(0.2,1,1));\n        vec3 h = normalize(ld-rd);\n        float spec = pow(max(dot(n,h),0.0),20.0);\n        float fres = pow(1. - max(dot(n, -rd),0.), 5.);\n        float diff = max(dot(n, ld),0.);\n        \n\n        //some hacky soft shadows\n        float shadow = 1.0;\n        float md = 1.0;\n        vec3 sp = p + n * 0.5;\n        for(int i=0; i<10; ++i) {\n        \n          float d=map(sp).x;\n          \n          if(d>3.0) break; \n          sp+=min(d,0.4)*ld;\n          md = min(md, d);\n          if(md<0.5) shadow = md+0.5;\n          \n        }\n        //I still have no idea what I am doing with these lighting mixes\n        shadow = pow(shadow,1.75);\n        col = al;\n        col+=spec*0.3*shadow*vec3(1.000,0.831,0.439);\n        col+=fres*0.175*shadow*vec3(1.000,0.957,0.824);\n        col*=clamp(diff*vec3(1.000,0.957,0.824),0.2,1.0);\n        col*=clamp(shadow,0.0,1.0);\n    }\n    //if ray marcher didn't hit then render the background\n    else{\n        vec2 uvo = uv;\n        uv.y-=0.5;\n        uv.x-=0.7;\n\n        //orange/purple gradient\n        col = mix(vec3(0.976,0.502,0.243),vec3(0.420,0.259,1.000),min(length(uv)-0.4,1.2));\n\n        //big sun circle\n        float sun =smoothstep(length(uv)-aa,length(uv)+aa,0.3);\n        uv*=rot((floor(length(uv)/0.1)+0.5)-t*0.025);\n\n        //lots of little tiny rings\n        uv = moda(uv,0.3);\n        uv.x = pmod(uv.x,0.1);\n        float rs = 0.035/2.0;\n        sun += (smoothstep(length(uv)-aa,length(uv)+aa,rs)\n        -smoothstep(length(uv)-aa,length(uv)+aa,rs*0.5));\n        col+=min(sun,1.0);\n        \n        //Some sand dune thingys\n        uv = uvo;\n        uv.y+=sin(uv.x*12.0-t*0.4+5.0)*0.015;\n        col=mix(col,vec3(1.000,0.655,0.275),smoothstep(uv.y-aa,uv.y+aa,-0.25));\n        uv = uvo;\n        uv.y+=sin(uv.x*12.0-t+2.5)*0.015;\n        col=mix(col,vec3(0.957,0.584,0.357),smoothstep(uv.y-aa,uv.y+aa,-0.325));\n        uv = uvo;\n        uv.y+=sin(uv.x*12.0-t*1.8)*0.015;\n        col=mix(col,vec3(0.894,0.871,0.353),smoothstep(uv.y-aa,uv.y+aa,-0.4));\n        \n    }\n    //Gamma\n    col =sqrt(col);\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}