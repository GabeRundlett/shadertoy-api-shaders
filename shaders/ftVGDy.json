{
    "Shader": {
        "info": {
            "date": "1638269941",
            "description": "Beware of viruses bearing Greek letters (especially the Omicron)",
            "flags": 0,
            "hasliked": 0,
            "id": "ftVGDy",
            "likes": 14,
            "name": "Greek Variants",
            "published": 3,
            "tags": [
                "font",
                "cellmarch"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 505
        },
        "renderpass": [
            {
                "code": "// \"Greek Variants\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n Beware of viruses bearing Greek letters (especially the Omicron).\n \n Using the Greek characters included in otaviogood's \"SDF Texture Font\"; not\n following WHO naming guidelines.\n\n  No. 14 in \"Font\" series\n    \"Font3d\"               (ltsyRr)\n    \"Lorem Ipsum\"          (XlXyR8)\n    \"Historical Text\"      (4tXcRH)\n    \"Font Clock\"           (MlscR8)\n    \"Alphaville\"           (XtfczN)\n    \"Pi in the Sky\"        (4lfyR7)\n    \"Train Builder\"        (4tlcz7)\n    \"Twisted Time\"         (XlsyWH)\n    \"Alphawall\"            (MlXyWf)\n    \"Alphapolis\"           (4scyDj)\n    \"Pi Night\"             (WsXyR4)\n    \"Corona Time\"          (wsfcRX)\n    \"Facebook Time\"        (sscXRj)\n*/\n\n#define AA  1  // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat Minv3 (vec3 p);\nfloat SmoothMax (float a, float b, float r);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nmat3 StdVuMat (float el, float az);\nfloat FontTexDf (vec2 p, float id);\nfloat Hashfv2 (vec2 p);\nfloat Hashfv3 (vec3 p);\nvec3 Hashv3f (float p);\n\nvec3 cId, ltDir, obRot;\nvec2 obRotCs[3], fntSize, qnTex;\nfloat dstFar, tCur, gSize, vSpd, idTxt, qyHit;\nbool cOcc;\nconst float pi = 3.1415927;\n  \nfloat ObjDf (vec3 p)\n{\n  float d;\n  d = dstFar;\n  if (cOcc) {\n    p -= gSize * (cId + 0.5);\n    p.yz = Rot2Cs (p.yz, obRotCs[0]);\n    p.xz = Rot2Cs (p.xz, obRotCs[1]);\n    p.xy = Rot2Cs (p.xy, obRotCs[2]);\n    p.xz /= fntSize.x;\n    d = 0.5 * SmoothMax (max (fntSize.x * FontTexDf (p.xz + 0.5, idTxt),\n      PrBox2Df (p.xz, vec2 (0.35))), abs (p.y) - fntSize.y, 0.001);\n    qyHit = p.y;\n  }\n  return d;\n}\n\nvoid ObjState ()\n{\n  vec3 vRan;\n  float rNum;\n  int c;\n  vRan = Hashv3f (dot (cId, vec3 (31.1, 41.1, 51.1)) + 99.);\n  cOcc = (vRan.x * step (1.5, length (cId.xz)) > 0.2);\n  if (cOcc) {\n    obRot = (vRan - 0.5) * (tCur + 10.);\n    obRotCs[0] = sin (obRot.x + vec2 (0.5 * pi, 0.));\n    obRotCs[1] = sin (obRot.y + vec2 (0.5 * pi, 0.));\n    obRotCs[2] = sin (obRot.z + vec2 (0.5 * pi, 0.));\n    rNum = Hashfv3 (vec3 (31.1, 41.1, 51.1) * cId + 99.);\n    c = int (rNum * 20.3);\n    if (c < 16) c += 0x80;\n    else c = (c < 20) ? 0x6f : 0x1d;\n    idTxt = float (c);\n  }\n}\n\nvec3 ObjCell (vec3 p)\n{\n  cId.xz = floor (p.xz / gSize);\n  p.y += vSpd * (tCur + 10.) * (1. + Hashfv2 (cId.xz));\n  cId.y = floor (p.y / gSize);\n  return p;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, cIdP, rdi;\n  float dHit, d, eps;\n  eps = 0.001;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  rdi = 1. / rd;\n  cIdP = vec3 (-999.);\n  dHit = eps;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ObjCell (ro + dHit * rd);\n    if (cId != cIdP) {\n      ObjState ();\n      cIdP = cId;\n    }\n    d = ObjDf (p);\n    d = min (d, abs (Minv3 ((gSize * (cId + step (0., rd)) - p) * rdi)) + eps);\n    dHit += d;\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 BgCol (vec3 rd)\n{\n  float t, gd, b;\n  t = tCur * 1.5;\n  b = dot (vec2 (atan (rd.x, rd.z), 0.5 * pi - acos (rd.y)), vec2 (2., sin (rd.x)));\n  gd = clamp (sin (5. * b + t), 0., 1.) * clamp (sin (3.5 * b - t), 0., 1.) +\n     clamp (sin (21. * b - t), 0., 1.) * clamp (sin (17. * b + t), 0., 1.);\n  return mix (vec3 (0.35, 0.5, 1.), vec3 (0.1, 0.4, 0.3), 0.5 * (1. - rd.y)) *\n     (0.24 + 0.44 * (rd.y + 1.) * (rd.y + 1.)) * (1. + 0.15 * gd);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, bgCol, vn;\n  float dstObj, s;\n  gSize = 1.;\n  fntSize = vec2 (0.45, 0.02);\n  vSpd = 0.1;\n  bgCol = BgCol (rd);\n  col = bgCol;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    col = (idTxt == float (0x6f)) ? vec3 (0.9, 0.3, 0.3) : vec3 (0.8, 0.9, 0.5);\n    s = step (abs (qyHit), fntSize.y - 0.001);\n    col *= 1. - 0.6 * s;\n    vn = (s > 0.) ? normalize (vec3 (qnTex,\n       0.001 * sign (qyHit))).xzy : vec3 (0., sign (qyHit), 0.);\n    vn.xy = Rot2D (vn.xy, - obRot.z);\n    vn.xz = Rot2D (vn.xz, - obRot.y);\n    vn.yz = Rot2D (vn.yz, - obRot.x);\n    col *= 0.3 + 0.7 * max (dot (vn, ltDir), 0.);\n    col = mix (col, bgCol, smoothstep (0.5, 0.95, dstObj / dstFar));\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define txFnt iChannel0\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, sr, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.25 * pi;\n  el = 0.05 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.7 * pi * mPtr.y;\n  } else {\n    az += pi * sin (0.003 * pi * tCur);\n    el += 0.2 * pi * sin (0.002 * pi * tCur);\n  }\n  el = clamp (el, -0.3 * pi, 0.3 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vec3 (0.4);\n  zmFac = 3.;\n  dstFar = 20.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -2.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n#if 0   // (show full font texture instead)\n  col = (max (abs (uv.x), abs (uv.y)) < 1.) ? texture (txFnt, 0.5 * (uv + 1.)).rgb : vec3 (0.);\n#endif\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat FontTexDf (vec2 p, float id)\n{\n  vec3 tx;\n  float d;\n  tx = texture (txFnt, fract ((vec2 (mod (id, 16.),\n     15. - floor (id / 16.)) + fract (p)) * (1. / 16.))).gba - 0.5;\n  qnTex = vec2 (tx.r, - tx.g);\n  d = tx.b + 1. / 256.;\n  return d;\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec3 Hashv3f (float p)\n{\n  return fract (sin (p + vec3 (37., 39., 41.)) * cHashM);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}