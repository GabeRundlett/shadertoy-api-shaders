{
    "Shader": {
        "info": {
            "date": "1591289779",
            "description": "Cheshire Box Parkour - Result of improvised live code session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time:\nhttps://www.twitch.tv/evvvvil_",
            "flags": 0,
            "hasliked": 0,
            "id": "3tlyRr",
            "likes": 23,
            "name": "[TWITCH] Cheshire Box Parkour",
            "published": 3,
            "tags": [
                "fractal",
                "demoscene",
                "abstract",
                "glow",
                "alien",
                "bounce",
                "kifs",
                "trippy",
                "scifi",
                "world",
                "architecture",
                "network",
                "twitch",
                "improv"
            ],
            "usePreview": 1,
            "username": "evvvvil",
            "viewed": 814
        },
        "renderpass": [
            {
                "code": "// Cheshire Box Parkour - Result of an improvised live code session on Twitch\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time: \n// https://www.twitch.tv/evvvvil_\n\n// \"The Cheshire cat is probably on drugs, well, I know I am.\" - Lewis Carroll\n\nvec2 z,v,e=vec2(.0035,-.0035);float t,tt,bb,sbb,boxZ,boxR,g,gg;vec3 np,bp,pp,op,po,no,ld,al;//Global vars. About as boring as living in North-East of France (I should know I grew up there).\nfloat cx(vec3 p,vec3 r){return max(abs(length(p.yz)-r.x)-r.y,abs(p.x)-r.z);} //Hollow Tunbe primitive. My own primitive function, don't laugh, I'm not very good at Math but I'm better than you at skateboarding. (seriously though, wanna challenge me? game of skate? You're on broski)\nfloat bo(vec3 p,vec3 r){p=abs(p)-r;return max(max(p.x,p.y),p.z);} //Box Primitive. Someone elese's primitive function (told you I'm not very good at Math but I'm French so I'm good at stealing and showing off)\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}//Rotate function. Short and sweet, just like the perfect argument with your partner. It never fucking is though, here we are 5 hours later like two howler monkeys hurling bananas at eachother.\nvec4 texNoise(vec2 uv){ float f = 0.; f+=texture(iChannel0, uv*.125).r*.5; //Rough shadertoy approximation of the bonzomatic noise texture by yx - https://www.shadertoy.com/view/tdlXW4\n    f+=texture(iChannel0,uv*.25).r*.25;f+=texture(iChannel0,uv*.5).r*.125;f+=texture(iChannel0,uv*1.).r*.125;f=pow(f,1.2);return vec4(f*.45+.05);\n} \t\nvec2 fb( vec3 p, float s) //fb is \"fucking bit\" function that make base geometry for the more complex network / kifs made in mp\n{\n  p.yz*=r2(sin(p.x*.5)*.5);//Rotate everything along x axis\n  p=abs(p)-vec3(4,0,0); //Everything is abs symetry cloned along the x to create mroe geom\n  vec2 h,t=vec2(length(p)-1.8,6); //Big glowy spheres\n  g+=0.1/(0.1+t.x*t.x*20.); //Glow trick from Balkhan, push distance field of geom in vairable and add at the end (see last line)\n  h=vec2(length(abs(p.yz)-vec2(1.5))-.3,6);//4 GREY cylinders on sides\n  h.x=min(h.x,cx(p,vec3(2.2,.3,.2)));//hollow tube / ring around the big glowy spheres\n  h.x=max(h.x,abs(p.y)-1.4); //Cut grey sylinders and tube to reveal the blue ones underneath\n  t=t.x<h.x?t:h;  //Merge glowy sphere and all grey shapes above\n  h=vec2(length(abs(p.yz)-vec2(1.5))-.2,5); //Make 4 blue cylinders\n  h.x=min(h.x,cx(p,vec3(2.2,.3,.2))); //Add blue hollow tube / ring around glowy spheres\n  t=t.x<h.x?t:h;  //Add all blue shapes to rest of geometries\n  h=vec2(length(p.yz-vec2(1.6,2.0))-s*min(.02,.1*sin(-p.x*.2)),3); //RED thin tubes going up the columns the variable \"s\" is to hide / show them depending on kifs we are using\n  gg+=0.1/(0.1+h.x*h.x*(200.-190.*sin(p.x*.7-tt*4.-2.)))*s;//Glow the red fuckers with animated sweep along the y axis.\n  t=t.x<h.x?t:h; //Add red fuckers to rest of scene\n  return t;\n}\nvec2 road(vec3 p){ //Road make the black / glowy road like geometry AND the bouncing cheshire boxes\n  vec2 h,t=vec2(bo(abs(p)-vec3(1.15,2.,0.),vec3(.2,.1,100.)),3); //Dull box making dull road\n  h=vec2(bo(abs(p)-vec3(1.15,2.,0.),vec3(.05,.12,100.)),6); //Everybody loves a fucking glow on the road\n  g+=(.5+0.4*abs(sin(p.z*5.))*sbb)/(0.1+h.x*h.x*(400.-sin(p.z+1.57+boxZ)*399.*sbb)); //Make it glow again, reusing boxz position of boxes to align the glow, no real math fuckery here more of some gut feeling bullshit.\n  t=t.x<h.x?t:h;  //Merge dullbox and glow bit\n  vec3 flyPos=p+vec3(0,-.2-(bb),boxZ); //We make the actual box bouncing position in flyPos, I know lame variable name but hey I'm not the one actually called \"Kevin\", you are.\n  flyPos.xy=abs(flyPos.xy)-vec2(1.15,2.);  //Somehow abs symetry cloning of pos seemed a good idea. I don't know since writting this plenty neurones went down the bottle and I even forgot pet lizard name... Dr something? Dr Dre? no wait. Dr Drizzle, that's it. Anyways what are we talking about here?\n  flyPos.yz*=r2(sin(op.z)+boxR); //Just like throwing a soft dildo at your partner's face, the boxes nicely bend as they rotate in space with \"sin(op.z)\". Also they always land on the right face with mix(3.14,0.,fract(tt*2.))\n  h=vec2(bo(flyPos,min(fract(tt*.2),.1)*10.*vec3(.05,mix(.05,.15,bb),.05)),6);//Draw the actual cheshire boxes with mad position above\n  gg+=0.1/(0.1+h.x*h.x*75.); //Make em glow a bit but this time red for bit of contrast\n  t=t.x<h.x?t:h; //Add cheshire boxes to the rest of road\n  t.x/=.6; t.x*=.8; //Tweak distance field to avoid aritfact. I know not exactly elegant to have 2 calc in a row, but then I had 7 pints in a row last friday and despite wearing a fancy hat, it wasn't elegant either.\n  return t; \n}\nvec2 mp( vec3 p )\n{ \n  op=np=p; //op is original position and it is just here to remember how p was orginally before we start tweaking the fuck outta everything\n  np.z=mod(np.z+tt*2.,75.)-37.5;  //np is the more complex position based on p which we put in loop to make a KIFS (kaleidoscopic iteration funciton system)\n  for(int i=0;i<4;i++){ //Here is our KIFS loop, I used to call it \"pseudo fractal\" because I'm not a nerd but someone self-righteous showed me the virtuous jargon-filled path and now I call them KIFS and I'm ok being a self-righteous prick.\n    np.xz=abs(np.xz)-vec2(6,6); //Push out a bit each loop, sort of a \"reverse fucking\", if you don't think about it too long. Indulge me, it's the lockdown and I have to amuse myself.\n    np.xz*=r2(.7+sin(np.z*.2)*.3); //Yeah rotate bit and add sin(np.z) to break symetry along z.\n  }\n  vec2 h,t=fb(np,0.); t.x*=0.8; //Make first bunch of geometry with kifs above\n  h=vec2(p.y,6); //Make simple \"terrain\" with plane at 0, not eveything has to be fancy marble fucking columns, this isn't some crass nouveau-riche footballer's bachelor pad.\n  t=t.x<h.x?t:h; //merge terrain and 1st kifs\n  bp=np*.5; //Create new position bp based on np but twice bigger, to make bigger round of kifs\n  bp.xz*=r2(.785); //Rotate the fuckers a bit for good luck\n  bp.xz+=vec2(.5,-2.5); //And shift them into place so it';s snug  with the first round of kifs\n  h=fb(bp,0.); h.x/=.6; //Draw 2nd bigger bit of geom with kifs, and it is snug with first one\n  t=t.x<h.x?t:h; //Merge 2nd kifs with rest\n  h=road(bp); //Make da road and the bouncing cheshire boxes because shadertoy need more comedy\n  t=t.x<h.x?t:h; //Merge road and rest\n  bp=np*.5; //yeah yeah we do it again, dumb shit i know but don't care broh\n  bp.xy*=r2(1.57); //Rotate 180 to make it stand up, yeah we making oclumns basically\n  bp.xz-=vec2(1.,1.6); //Shift columns a bit make it snug with rest\n  h=fb(bp,1.); h.x/=.7; //Here we draw column with bp position above\n  t=t.x<h.x?t:h; //Merge columns with rest\n  pp=np; //PP is the position used for BLACK boxes on terrain, it is based on np so it's also a kifs\n  pp.xz=mod(pp.xz,2.)-1.;  //Make loads of em by doing a grid of em\n  h=vec2(bo(pp,vec3(.5,1.+2.*(.5+.5*sin(np.z*.5)),.5)),3); // Draw all those black boxes\n  h.x=max(h.x,-(length(bp.yz)-3.2)); //Remove black boxes that are too close to the blue / grey kifs geometry based on bp\n  h.x=max(h.x,-(length(np.yz)-4.8)); //Remove black boxes that are too close to the blue / grey kifs geometry based on np\n  t=t.x<h.x?t:h; //Merge black boxes with rest of scene\n  t.x*=.7; //Tweak distance field of everything to avoid artifact\n  return t;\n}\nvec2 tr( vec3 ro, vec3 rd) // main trace / raycast / raymarching loop function \n{\n  vec2 h,t= vec2(.1); //Near plane because when it all started the hipsters still lived in Norwich and they only wore tweed.\n  for(int i=0;i<128;i++){ //Main loop de loop \n    h=mp(ro+rd*t.x); //Marching forward like any good fascist army: without any care for culture theft. (get distance to geom)\n    if(h.x<.00001||t.x>40.) break;//Conditional break we hit something or gone too far. Don't let the bastards break you down!\n    t.x+=h.x;t.y=h.y; //Huge step forward and remember material id. Let me hold the bottle of gin while you count the colours.\n  }\n  if(t.x>40.) t.y=0.;//If we've gone too far then we stop, you know, like Alexander The Great did when he realised his wife was sexting some Turkish bloke. (10 points whoever gets the reference)\n  return t;\n}\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )//2 lines above are a = ambient occlusion and s = sub surface scattering\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1); //get UVs, nothing fancy, \n  tt=mod(iTime,62.82)+24.5;  //Time variable, modulo'ed to avoid ugly artifact. Imagine moduloing your timeline, you would become a cry baby straight after dying a bitter old man. Christ, that's some fucking life you've lived, Steve.\n  bb=abs(sin(tt*2.)); //bb is an animation variable used to move boxes\n  boxZ=mix(0.,6.7,fract(tt*.2)); //boxZ is the bouncing box z pos animation variable\n  boxR=mix(3.14,0.,fract(tt*2.)); //boxR is the bouncing box angle rotation animation variable\n  sbb=1.-smoothstep(0.,1.,bb);  //sbb is the reverse of bb but also smoothed / eased animation variable\n  vec3 ro=mix(vec3(1),vec3(-1,1.7,1),ceil(sin(tt*.4)))*vec3(cos(tt*.4+.1)*2.,7.,-10),//Ro=ray origin=camera position We build camera right here broski. Gotta be able to see, to peep through the keyhole.\n  cw=normalize(vec3(0)-ro),cu=normalize(cross(cw,vec3(0,1,0))),cv=normalize(cross(cu,cw)), //camera forward, left and up vector.\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo;//rd=ray direction (where the camera is pointing), co=final color, fo=fog color\n  ld=normalize(vec3(-.1,.5,-.3));//ld=light direction\n  co=fo=vec3(.1)-length(uv)*.1-rd.y*.1;//background is dark with vignette and small gradient along y, like a  horizon\n  z=tr(ro,rd);t=z.x; //Trace the trace in the loop de loop. Sow those fucking ray seeds and reap them fucking pixels.\n  if(z.y>0.){ //Yeah we hit something, unlike you trying to throw a spear at a pig. We wouldnt have survive the ice age with you and your nerdy mates.\n    po=ro+rd*t; //Get ray pos, know where you at, be where you is.\n    no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x); //Make some fucking normals. You do the maths while I count how many brain cells I lost during my mid 2000s raving haydays.\n    float tnoi=texNoise(np.xz*.5).r;\n    if(z.y==5.) {no+=tnoi*.4;no=normalize(no);al=vec3(.0,.3,1.)*(.5+.5*cos(bp*.5))+tnoi;} //defaulkt material is gradient of blue and green with some noi\n    if(z.y<5.) al=vec3(0); //material system if less than 5 make it black\n    if(z.y>5.) al=vec3(1); //material system if more than 5 make it white\n    float dif=max(0.,dot(no,ld)-tnoi), //Dumb as fuck diffuse lighting\n    fr=pow(1.+dot(no,rd),4.), //Fr=fresnel which adds background reflections on edges to composite geometry better\n    sp=pow(max(dot(reflect(-ld,no),-rd),0.),30.);//Sp=specular, stolen from shane\n    co=clamp(mix(sp+mix(vec3(.7),vec3(1),abs(rd))*al*(a(.1)*a(.3)+.2)*(dif+s(1.)),fo,min(fr,.5)),0.,1.);//Building the final lighting result, compressing the fuck outta everything above into an RGB shit sandwich    \n  }\n  co=mix(fo,co+g*.2*vec3(0.1,.2,.7)+gg*.1*mix(vec3(1.,.1,.0),vec3(.7,0.2,.1),.5+.5*sin(np.y*.5)),exp(-.0001*t*t*t)); //Fog soften things, but it won't stop your annoying uncle from thinking \"Bloody fiddling with bloody numbers, ain't gonna get you a job, son. Real graft is what ye need, wee man.\"(last sentence read with Scottish accent if you can)\n  fragColor = vec4(pow(co,vec3(.65)),1); //Add glow at the end. g & gg are red and blue glow global variables containg distance fields see lines 42,50,58\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}