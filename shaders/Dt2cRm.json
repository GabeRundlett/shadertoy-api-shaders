{
    "Shader": {
        "info": {
            "date": "1691596068",
            "description": "Holy cow it actually is tileable.\n\nRealized on the original (https://www.shadertoy.com/embed/dlSyzW) I could have just done #define SHOW_TILING. It also flashes a nice yellow. Might add that to some other stuff later.",
            "flags": 0,
            "hasliked": 0,
            "id": "Dt2cRm",
            "likes": 2,
            "name": "Tileable Water Fork",
            "published": 3,
            "tags": [
                "water",
                "caustic"
            ],
            "usePreview": 0,
            "username": "LeifMessinger",
            "viewed": 135
        },
        "renderpass": [
            {
                "code": "// Found this on shadertoy. He said it was tileable, so I tiled it using my function from here https://www.shadertoy.com/embed/dlSyzW\n// :)\n// by David Hoskins. https://www.shadertoy.com/view/MdlXz8\n// Original water turbulence effect by joltz0r\n\n#define TAU 6.28318530718\n#define MAX_ITER 5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tfloat time = iTime * .5+23.0;\n    // uv should be the 0-1 uv of texture...\n    \n    bool mouseInactive = iMouse.xy == vec2(0.0, 0.0);\n    //Tile size in pixels\n    vec2 tileSize = mouseInactive? (iResolution.xy/8.0): iMouse.xy;\n    \n    //This gets the coords, which is the fragCoord from [0.0, 0.0] to [1.0, 1.0] inside the tile\n    ivec2 tileIndex;\n    vec2 uv = tile(fragCoord, tileSize, tileIndex);\n    \n#ifdef SHOW_TILING\n\tvec2 p = mod(uv*TAU*2.0, TAU)-250.0;\n#else\n    vec2 p = mod(uv*TAU, TAU)-250.0;\n#endif\n\tvec2 i = vec2(p);\n\tfloat c = 1.0;\n\tfloat inten = .005;\n\n\tfor (int n = 0; n < MAX_ITER; n++) \n\t{\n\t\tfloat t = time * (1.0 - (3.5 / float(n+1)));\n\t\ti = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));\n\t\tc += 1.0/length(vec2(p.x / (sin(i.x+t)/inten),p.y / (cos(i.y+t)/inten)));\n\t}\n\tc /= float(MAX_ITER);\n\tc = 1.17-pow(c, 1.4);\n\tvec3 colour = vec3(pow(abs(c), 8.0));\n    colour = clamp(colour + vec3(0.0, 0.35, 0.5), 0.0, 1.0);\n    \n\tfragColor = vec4(colour, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Tiles coordinates\n//loopDistance is the xy size of a tile\n//the output is the coordinate from [0,1] with respect to its own tile\nvec2 tile(in vec2 coord, in vec2 loopDistance, out ivec2 tileIndex){\n    vec2 xy = coord/loopDistance; //This is the xy of one tile\n    vec2 coords = fract(xy); //Same as mod(x,1.0);\n    tileIndex = ivec2(trunc(xy));\n    return coords;\n}\n\nvec2 tile(in vec2 coord, in vec2 loopDistance){\n    ivec2 tileIndex; //We throw this away\n    return tile(coord, loopDistance, tileIndex);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}