{
    "Shader": {
        "info": {
            "date": "1669401098",
            "description": "It seems to produce a mystic energy... \n\nUse the mouse to change the time !",
            "flags": 96,
            "hasliked": 0,
            "id": "cslXRs",
            "likes": 63,
            "name": "Aldebaran's Sanctuary",
            "published": 3,
            "tags": [
                "raymarching",
                "terrain",
                "fbm",
                "fast",
                "lighting",
                "repetition",
                "polar",
                "snow",
                "scene",
                "alps",
                "realistic",
                "snowy",
                "moutains"
            ],
            "usePreview": 1,
            "username": "kishimisu",
            "viewed": 1599
        },
        "renderpass": [
            {
                "code": "/* \"Aldebaran's Sanctuary\" by @kishimisu (2022) - https://www.shadertoy.com/view/cslXRs\n\n   Switch to day/night mode with the mouse !\n   \n   This is the completion of my recent quest for fast fbm terrain generation. \n   Using various techniques that I listed in my shader demonstration\n   (https://www.shadertoy.com/view/msXSR2), I was able to get much better \n   performances that my previous realistic scene \"Lost Monoliths\" \n   (https://www.shadertoy.com/view/mdfSWr).\n   \n   However after finishing this scene I realized that I've made it more complex \n   than my previous one, so even if the terrain is calculated much faster it is\n   a bit demanding on the performances. (Even if it still runs 3x faster than\n   my previous one).\n   \n   I also tried to make reflective water, and it's one of these things that is really \n   beautiful for very few lines of code. Simply invert the ray y direction when it is \n   below a specific level, and add a bit of noise to its direction to simulate water \n   ripples. Terribly easy !\n   To make the water stand out nicely, the terrain close to the water gets darker to \n   simulate being wet. Also the color gets tinted with dark blue if the ray has been \n   reflected by the water.\n   \n   The space is repeated around the y axis, so there is only one pillar and one distant \n   monolith that are being checked at each step, and the trees are simple cones with \n   various offset, height, and colors. Finally, the terrain is made with 3 rings of\n   mountains that are more and more distance and high (see terrainH)\n*/\n\nvoid mainImage(out vec4 O, vec2 F) {    \n    vec3 col = texelFetch(iChannel0, ivec2(F-0.5), 0).rgb;\n    col *= pow(smoothstep(1., 0., length(F/iResolution.xy-.5)), .4);\n    O = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 30574,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/spiritualmoment/ultra-sleep-meditation-music-sleep-hypnosis-music-for-deep-sleep?in=billie-kihega/sets/billies-sleep-sounds"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define ALTERNATE_VIEWS 1 // Set to 0 to prevent camera from switching viewpoints\n\n#define MOTION_BLUR     10.\n#define MAX_ITERATIONS 100.\n#define MAX_DISTANCE   120.\n#define EPSILON        .001\n\n#define FBM_LAYERS  8\n#define FAST_LAYERS 4\n#define SHADOW_FBM_LAYERS 4\n#define RELAXATION  1.\n\n#define VOLUME_STEPS    20.\n#define VOLUME_DENSITY  .8\n#define VOLUME_LIGHT    0.7\n\n#define sunCycle (iMouse.z == 0. ? smoothstep(-2.,10.,iTime) : iMouse.x/iResolution.x*.9+.1)\n#define sunColor vec3(1.2,0.671,0.376)*(sunCycle*.9+.15)\n#define skyColor vec3(0.604,0.784,0.976)*(sunCycle*.9+.15)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define treeRep 24.\n\n// Value noise - https://www.shadertoy.com/view/lsf3WH\nfloat hash(vec2 p) {\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return fract( p.x*p.y*(p.x+p.y) );\n}\nfloat noise2( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\tvec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// https://shadertoyunofficial.wordpress.com/2019/01/02/\nvec3 hash33(vec3 p) {\n    return fract(cos((p)*mat3(127.1,311.7,74.7,269.5,183.3,246.1,113.5,271.9,124.6))*43758.5453123);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nvec3 hash32(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\nvec3 hash31(float p) {\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n// https://www.shadertoy.com/view/3ddGzn\nfloat noise3(vec3 p) {\n\tvec3 ip=floor(p), s=vec3(7, 157, 113);\n\tvec4 h=vec4(0, s.yz, s.y+s.z)+dot(ip, s);\n\tp-=ip; p=p*p*(3.-2.*p);\n\th=mix(fract(43758.5*sin(h)), fract(43758.5*sin(h+s.x)), p.x);\n\th.xy=mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\n// https://iquilezles.org/articles/fbm/\nfloat fbm3(vec3 p) { \n    p += vec3(iTime*.1, iTime*.1, 0.);\n    float f = 1.0, a = 1.0,\n          t = noise3(p);\n    for(int i=1; i<5; i++) {\n        t += a*noise3(f*p);\n        f *= 2.0; a *= .5;\n    }\n    return t;\n}\n\nfloat fastnoise2(vec2 p) {\n    return (sin(p.x)-cos(p.y))*.5+.5;\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k ) {\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*h/(6.0*k*k);\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCone(vec3 p) {\n    const vec2 c = vec2(0.198669, 0.980067);\n    vec2   q = vec2( length(p.xz), -p.y );\n    float  d = length(q-c*max(dot(q,c), 0.0));\n    return d * ((q.x*c.y-q.y*c.x<0.0)?-1.0:1.0) - .1;\n}\nfloat sdArc( in vec2 p, in float ra, float rb ) {\n    const vec2 sc = vec2(0.808496, -0.588501);\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n}\nfloat sdCircle(vec2 p, float ra, float rb) {\n    return abs(length(p) - ra) - rb;\n}\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\nfloat sdCylinder( vec3 p, float h, float r ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/boxfunctions/\nvec2 boxIntersection(in vec3 ro, in vec3 rd, in vec3 rad)  {\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0);\n    return vec2( tN, tF );\n}\n\n// Smarter fbm calculation - https://www.shadertoy.com/view/msXSR2\nfloat fbm(vec2 p, float h, int layers) {\n    float n = fastnoise2(p); \n    float a = 1.;\n    \n    for (int i = 0; i < layers; i++) {\n        if (h > n + a) break;\n        \n        p *= 2.; a *= .5;\n   \n        if (i < FAST_LAYERS) \n            n -= a*abs(fastnoise2(p)-n);\n        else                \n            n -= a*noise2(p);      \n    } \n    \n    return n;\n}\n\nfloat terrainH(vec3 p, int layers) {    \n    float mnt =  smoothstep(0., 1., -sdArc(vec2(p.z, -p.x - 4.), 6. , 1.));\n    mnt += 2.2 * smoothstep(0., 2., -sdCircle(p.xz - vec2(-4,0), 22., 5.)); \n    mnt += 4.  * smoothstep(0., 2., -sdCircle(p.xz - vec2(-4,0), 36., 5.));         \n    return fbm(p.xz*.5, p.y - mnt, layers) + mnt;\n}\n\nvec2 map(vec3 p, int layers, inout vec3 light) {\n    float l = length(p.xz);\n    // Terrain\n    float ground = 1e6;\n    if (p.y < 5.) {\n        float terrain = terrainH(p, layers);\n        ground  = p.y - terrain;\n    }\n    \n    // Trees\n    float trees = 1e6;\n    if (ground < 1.) {\n        float sm  = smoothstep(5.5, 6., l);\n        float rep = mix(treeRep, 10., sm);\n        vec3  fp  = fract(p*rep)-.5; \n        vec3  id  = floor(p*rep)+.5;\n        vec3  r   = hash32(id.xz);\n        float fh  = fbm(id.xz*.5/rep, p.y-.1, layers); \n\n        float h  = 3. + r.y*sm*.4;\n        vec3 off = vec3(1.,0.,1.)*r*.4*sm;\n        fp.y = (p.y - fh) * rep - h;\n        trees = (sdCone(fp - off) + smoothstep(.5, .9, noise2(p.xz))) / rep;  \n    }\n    \n    // Structures\n    float shape = 1e6, cables = 1e6;\n    if (l < 12.) {\n        vec3  sp  = p;\n        float an  = 6.283185 / 16.;\n        float aid = (round((atan(p.z, p.x)-an/2.)/an)*an)+an/2.;\n        vec3  rs  = hash31(aid);\n        sp.xz *= rot(-aid);\n\n        shape = sdBox(sp - vec3(8.5,0,0), vec3(.3,3.,.45));\n        float hole  = sdBox(sp - vec3(8.5,1.8,0), vec3(.35, .9, .3));\n        shape = smax(shape, -hole, .1);\n\n        float center = length(p+vec3(0,.2,0))-.35;\n        float doors = sdBox(sp + vec3(0,.2,0), vec3(.4, .25*(sin(iTime*.1)*.5+.5), .04));\n        center = smax(center, - doors, .03);\n        center = min(center, sdCylinder(sp - vec3(1,-.5,0), .04, .5+rs.z*.2 + sin(.2*iTime+aid*10.)*.06));\n        shape  = min(shape, center) - .01;\n\n        // These aren't real objects, their signed distance is always strictly positive. It's only\n        // captured in lighting as it increases the iteration count near these phantom cables.\n        sp.z = abs(sp.z);\n        cables = sdCapsule(sp, vec3(1,0,0), vec3(9,3,.4), -.01-smoothstep(0.4, 0.6, sunCycle));\n\n        // Lighting\n        vec3 lc = 0.06 * (vec3(.7,.7,1.) - rs*.2);\n        light += lc / (1. + pow(abs(hole), 1.4));\n        light += 1.5*lc * vec3(0.447,0.118,0.600) / (1. + pow(abs(center*5.), 1.4));\n        light += 1.5*lc * vec3(0.118,0.600,0.522) / (1. + pow(abs(doors*5.), 1.4));\n    }\n    \n    vec2 res = vec2(ground, 0.);\n    if (trees < res.x) res = vec2(trees, 1.);\n    if (shape < res.x) res = vec2(shape, 2.);\n    if (cables < res.x) res = vec2(cables,3.);\n    \n    return res; \n}\n\nvec3 ltmp;\nvec3 getNormal(vec3 p, float d) {\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize(e.xyy*map(p + e.xyy, FBM_LAYERS,ltmp).x + e.yyx*map(p + e.yyx, FBM_LAYERS,ltmp).x + \n\t\t\t\t\t e.yxy*map(p + e.yxy, FBM_LAYERS,ltmp).x + e.xxx*map(p + e.xxx, FBM_LAYERS,ltmp).x);\n}\n\nfloat getShadow(vec3 ro, vec3 rd, float maxt) {\n    float t = 0.1, res = 1., k = 10.;\n    for (float i = 0.; i < MAX_ITERATIONS*.7; i++) {\n        vec3 p = ro + t*rd;\n        float d = map(p, SHADOW_FBM_LAYERS,ltmp).x;\n        res = min(res, k*d/t);\n        t += d;\n        if (t > maxt) return res;\n        if (d < EPSILON) return 0.;\n    }\n    return 0.;\n}\n\nvec3 volumeColor(vec3 ro, vec3 rd, float near, float far, vec3 sunDir, vec3 col) {\n    vec3 vcol  = vec3(0.);\n    float mask = 1.;\n    float vstep = (far - near) / VOLUME_STEPS;\n    const float dh = 1./VOLUME_DENSITY;\n\n    for (float t = near, i = 0.; t <= far && i < VOLUME_STEPS; t += vstep, i++) {\n        vec3 p = ro + t*rd;\n        \n        float dens = fbm3(p/6.);\n        dens = smoothstep(dh, dh+1., dens);\n\n        float prev = mask;\n        mask *= exp(-dens * vstep * .3);\n        float absorbed = prev - mask;\n        \n        vec3 light = 1.5-vec3(smoothstep(dh, dh+.6, fbm3((p-sunDir*.1)/6.)));\n        vcol += vec3(.9,1.,.7) * sunColor * absorbed * vstep * light * VOLUME_LIGHT;          \n    }\n    \n    return col*mask + min(vcol, vec3(1.));\n}\n\nvoid initRayOriginAndDirection(vec2 uv, inout vec3 ro, inout vec3 rd) {\n    vec2 m = iMouse.z == 0. ? vec2(.5) : iMouse.xy/iResolution.xy*2.-1.; \n    float t = iTime*.1, tt = 0.;\n    ro = vec3(0., -.1 + cos(t*1.1)*.1, 3. + sin(t*1.2)*.3);\n#if ALTERNATE_VIEWS\n    tt = step(20., mod(iTime, 35.)); \n#endif\n    ro.yz *= rot(cos(t*1.15)*.05-mix(.5, .1, tt));\n    ro.zx *= rot(sin(t)*.3-mix(-1.2, 1.2, tt)); \n    vec3 f = normalize(vec3(cos(t)*.01,.5+cos(t)*.02,sin(t)*.015)-ro), r = normalize(cross(vec3(0,1,0), f));\n    rd = normalize(f + uv.x*r + uv.y*cross(f, r));\n}\n\nvoid mainImage(out vec4 O, in vec2 F) {\n    vec2 uv = (2.*F - iResolution.xy)/iResolution.y;\n    vec2 res;\n    vec3 ro, rd;\n\n    initRayOriginAndDirection(uv, ro, rd);\n    \n    bool hitWater = false;\n    float t   = 0., i;\n    vec3  p   = ro, \n        col   = skyColor, \n      light   = vec3(0.);  \n        \n    for (i = 0.; i < MAX_ITERATIONS; i++) {\n        res = map(p, hitWater ? 5 : FBM_LAYERS, light);\n        \n        if (p.y < -.33) {\n            // Reflect if ray hit water level\n            p.y += 2.*abs(p.y+.33);\n            rd.y = -rd.y;\n            rd = normalize(rd + (noise2(p.xz*80.+iTime*.2)-.5)*.06);\n            hitWater = true;\n        }\n        \n        float d = res.x > 0. ? res.x*.9 : res.x*.3;\n        t += d;\n        p += rd * d;\n\n        if (res.x < EPSILON*(1. + t*RELAXATION) || t > MAX_DISTANCE) break;\n    }\n    \n    float phi = 0.32 * 6.28, the = -0.00 * 3.14 + 1.27 + (1.-sunCycle)*.2;\n    vec3 lightDir = normalize(vec3(sin(the)*sin(phi), cos(the), sin(the)*cos(phi)));\n    \n    if (t < MAX_DISTANCE) {\n        // Hit object\n        float th = terrainH(p, FBM_LAYERS);\n        vec3  id = floor(p*treeRep)+.5;\n        vec3   r = hash32(id.xz);\n        vec3   n = getNormal(p - rd*EPSILON*4., t);\n        float sunLight    = max(.1, dot(n, lightDir));\n        float sunShadow   = max(.02, getShadow(p + n*EPSILON*4., lightDir, MAX_DISTANCE));\n        float skyLight    = max(.0, n.y);\n        float bounceLight = max(.0, dot(n, -lightDir));\n        float spec        = max(.0, dot((rd + n)/2., lightDir));\n\n        if (res.y == 0.) {\n            // Terrain\n            col = vec3(1.);\n            col *= .4+smoothstep(.55, .7, skyLight );\n            col *= .05 + 1.*sunColor * sunLight * sunShadow;\n        } else if (res.y == 1.) {\n            // Trees\n            col = mix(\n                vec3(.2,.6 + (r.y-.5)*.5,.4)*.25, \n                vec3(1.)   + (r.x-.5)*.5, \n                smoothstep(0., .13, p.y - th + t * .0) \n            );\n            col *= .25*(sunCycle+.1) + 1.*sunColor * sunLight * sunShadow;  \n        } else {\n            // Structures\n            col = 1. - texture(iChannel1, p.xy*4.).rrr*.4;\n            col *= .2 + 1.*sunColor * sunLight * sunShadow;\n        }\n        \n        col *= smoothstep(.2, .4, length(p + vec3(0,.2,0)));\n\n        col += 0.2*skyColor * skyLight;\n        col += 0.1*vec3(.4,.2,0.) * bounceLight;\n        col += 1.5*pow(spec, 4.)*sunCycle;\n    } \n    \n    // Clouds\n    vec2 hit = boxIntersection(ro - vec3(0, 8, 0), rd, vec3(200., 4., 200.));\n    if (hit.x >= 0. && hit.x < t) {\n        col = volumeColor(ro, rd, hit.x, min(hit.y, t), lightDir, col);\n        t = min(hit.x, t);\n    }\n    \n    // Water occlusion\n    if (hitWater) col *= vec3(.7,.7,.9);\n    col *= mix(0.4, 1., smoothstep(-.35, -.25, p.y));\n    \n    // Apply fog\n    vec3 fog = exp2(-t*0.07*vec3(1,1.8,4)); \n    col = mix(clamp(skyColor - vec3(1.,1.5,2.)*abs(rd.y)*.3, vec3(0.), vec3(1.)), col, fog);   \n    \n    // Color adjust\n    col = pow(col, vec3(.99,.88,.95));\n    col = smoothstep(vec3(0.04), vec3(1), col);\n    col = pow(col, vec3(.4545));\n    \n    // Night lighting\n    col += light * smoothstep(.8, 0., sunCycle);\n           \n    // Accumulate frames\n    vec3 ocol = texelFetch( iChannel0, ivec2(F-0.5), 0 ).xyz;\n    if(iFrame==0) ocol = col;\n    col = mix(ocol, col, 1./MOTION_BLUR);\n    O = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}