{
    "Shader": {
        "info": {
            "date": "1460953351",
            "description": "Fly around the solar system! Race through a space station! Don't crash.\n\nControls: \nWSAD or arrow keys: pitch and roll\nQ/E: yaw\nJ/K:decrease/increase throttle\nH: hold down for Fantastic Drive\nP: pause & show controls\n\n(click inside shader first)",
            "flags": 56,
            "hasliked": 0,
            "id": "4ddSzs",
            "likes": 9,
            "name": "Laika (#LOWREZJAM)",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "raymarching",
                "game",
                "space",
                "lowrezjam"
            ],
            "usePreview": 1,
            "username": "musurca",
            "viewed": 2136
        },
        "renderpass": [
            {
                "code": "/*\n   LAIKA -- by musurca\n\n   for #LOWREZJAM\n\n   A low-rez space flight simulator, inspired by Frontier: Elite, Chris Foss, \n   and reinder's \"Planet Shadertoy\" demo.\n\n   It's a work in progress -- comments welcome.\n\n   Thanks to iq, nimitz, P_Malin, reinder, and others for sharing their work here.\n   Procedural noise generation based on code by iq and nimitz. Multipass state framework\n   and input based on code by P_Malin. (Please let me know if I've forgotten to credit\n   anyone else.)\n\n   TO DO:\n\t-improve the gas planet & rings\n\t-figure out how to add more objects without WebGL crashing\n\t-handle atmosphere/transparency in a more robust way\n    -create more planets and populate them\n    -generate more activity -- mining operations, ships, etc.\n\t-make interactive sound when sound shader can read from multipass buffers\n\t-clean up/properly comment this code\n\n\n   License: Attribution-NonCommercial-ShareAlike 3.0 Unported\n*/\n\n/// MAIN BUFFER -- GUI AND POST-PROCESSING\n\n#define RES_X 114.0\n#define RES_Y 64.0\n\nvec2 addrGameState = vec2(0.0, 3.0);\n\nfloat gtime;\nfloat time_scale;\n\nvec4 LoadVec4( in vec2 vAddr )\n{\n    vec2 vUV = (vAddr + 0.5) / iChannelResolution[0].xy;\n    return texture( iChannel1, vUV, -100.0 );\n}\n\nvec3 LoadVec3( in vec2 vAddr )\n{\n    return LoadVec4( vAddr ).xyz;\n}\n\nvoid GameLoadState()\n{\n    vec3 state = LoadVec3(addrGameState);\n    \n \tgtime = state.x;\n    time_scale = state.y;\n}\n\nvec2 sCoord;\n\n#define PlotPoint(a,b) (clamp(1.0-(abs(float(a)-sCoord.x)+abs(float(b)-sCoord.y)),0.0,1.0))\n#define PP(a,b) PlotPoint(p.x-float(a),p.y-float(b))\n\n#define _A 1\n#define _B 2\n#define _C 3\n#define _D 4\n#define _E 5\n#define _F 6\n#define _G 7\n#define _H 8\n#define _I 9\n#define _J 10\n#define _K 11\n#define _L 12\n#define _M 13\n#define _N 14\n#define _O 15\n#define _P 16\n#define _Q 17\n#define _R 18\n#define _S 19\n#define _T 20\n#define _U 21\n#define _V 22\n#define _W 23\n#define _X 24\n#define _Y 25\n#define _Z 26\n#define _SLASH  27\n#define _PLUS   28\n#define _EXCLAM 29\n#define _HYPHEN 30\n\n#define COMP(c) cRet+=(1.0-sign(abs(float(chr-c))))*\n\nfloat DrawChar(in vec2 p, int chr)\n{\n\tfloat cRet = 0.;\n\n    COMP(_A) (PP(0,0) + PP(1,0) + PP(2,0) +\n              PP(0,1)           + PP(2,1) +\n              PP(0,2) + PP(1,2) + PP(2,2) +\n              PP(0,3)           + PP(2,3) +\n              PP(0,4)           + PP(2,4));\n    COMP(_B) (          PP(1,0) + PP(2,0) +\n              PP(0,1)           + PP(2,1) +\n              PP(0,2) + PP(1,2) + PP(2,2) +\n              PP(0,3)           + PP(2,3) +\n                        PP(1,4) + PP(2,4));\n    COMP(_C) (PP(0,0) + PP(1,0) + PP(2,0) +\n              PP(0,1)           + PP(2,1) +\n                                  PP(2,2) +\n              PP(0,3)           + PP(2,3) +\n              PP(0,4) + PP(1,4) + PP(2,4));\n    COMP(_D)  (          PP(1,0) + PP(2,0) +\n               PP(0,1)           + PP(2,1) +\n               PP(0,2)           + PP(2,2) +\n               PP(0,3)           + PP(2,3) +\n                         PP(1,4) + PP(2,4));\n    COMP(_E)  (PP(0,0) + PP(1,0) + PP(2,0) +\n                                   PP(2,1) +\n               PP(0,2) + PP(1,2) + PP(2,2) +\n                                   PP(2,3) +\n               PP(0,4) + PP(1,4) + PP(2,4));\n    COMP(_F)  (PP(0,0) + PP(1,0) + PP(2,0) +\n                                   PP(2,1) +\n                         PP(1,2) + PP(2,2) +\n                                   PP(2,3) +\n                                   PP(2,4));\n    COMP(_G)  (PP(0,0) + PP(1,0) + PP(2,0) +\n                                   PP(2,1) +\n               PP(0,2)           + PP(2,2) +\n               PP(0,3)           + PP(2,3) +\n               PP(0,4) + PP(1,4) + PP(2,4));\n    COMP(_H)  (PP(0,0)           + PP(2,0) +\n               PP(0,1)           + PP(2,1) +\n               PP(0,2) + PP(1,2) + PP(2,2) +\n               PP(0,3)           + PP(2,3) +\n               PP(0,4)           + PP(2,4));\n    COMP(_I)            (PP(1,0) +\n               \t\t     PP(1,1) +\n             \t\t\t PP(1,2) +\n               \t\t     PP(1,3) +\n               \t\t\t PP(1,4));\n    COMP(_J)  (PP(0,0) +\n               PP(0,1) +\t\n               PP(0,2) +\n               PP(0,3) +         + PP(2,3) +\t\n                       + PP(1,4));\n    COMP(_K)  (PP(0,0)           + PP(2,0) +\n               PP(0,1)           + PP(2,1) +\n                \t     PP(1,2) + PP(2,2) +\n               PP(0,3)           + PP(2,3) +\n               PP(0,4)           + PP(2,4));\n    COMP(_L)                     (PP(2,0) +\n               \t\t              PP(2,1) +\n             \t\t\t\t\t  PP(2,2) +\n               \t\t              PP(2,3) +\n               PP(0,4) + PP(1,4) + PP(2,4));\n    COMP(_M)  (PP(0,0)           + PP(2,0) +\n               PP(0,1) + PP(1,1) + PP(2,1) +\n               PP(0,2)           + PP(2,2) +\n               PP(0,3)           + PP(2,3) +\n               PP(0,4)           + PP(2,4));\n    COMP(_N)  (PP(0,0)           + PP(2,0) +\n               PP(0,1) + PP(1,1) + PP(2,1) +\n               PP(0,2) + PP(1,2) + PP(2,2) +\n               PP(0,3) + PP(1,3) + PP(2,3) +\n               PP(0,4)           + PP(2,4));\n    COMP(_O)  (PP(0,0) + PP(1,0) + PP(2,0) +\n               PP(0,1)           + PP(2,1) +\n               PP(0,2)           + PP(2,2) +\n               PP(0,3)           + PP(2,3) +\n               PP(0,4) + PP(1,4) + PP(2,4));\n    COMP(_P)            (PP(1,0) + PP(2,0) +\n               PP(0,1)           + PP(2,1) +\n                         PP(1,2) + PP(2,2) +\n                                   PP(2,3) +\n                                   PP(2,4));\n    COMP(_Q)  (PP(0,0) + PP(1,0) + PP(2,0) +\n               PP(0,1)           + PP(2,1) +\n               PP(0,2)           + PP(2,2) +\n                         PP(1,3) + PP(2,3) +\n               PP(0,4) + PP(1,4));\n    COMP(_R)  (PP(1,0) + PP(2,0) +\n               PP(0,1)           + PP(2,1) +\n                \t     PP(1,2) + PP(2,2) +\n               PP(0,3)           + PP(2,3) +\n               PP(0,4)           + PP(2,4));\n    COMP(_S)  (PP(0,0) + PP(1,0) +\n                                   PP(2,1) +\n                \t     PP(1,2) + \n               PP(0,3) + \n                         PP(1,4) + PP(2,4));\n    COMP(_T)  (PP(0,0) + PP(1,0) + PP(2,0) +\n               \t\t     PP(1,1) +\n             \t\t\t PP(1,2) +\n               \t\t     PP(1,3) +\n               \t\t\t PP(1,4));\n    COMP(_U)  (PP(0,0)           + PP(2,0) +\n               PP(0,1)           + PP(2,1) +\n               PP(0,2)           + PP(2,2) +\n               PP(0,3)           + PP(2,3) +\n               PP(0,4) + PP(1,4) + PP(2,4));\n    COMP(_V)  (PP(0,0)           + PP(2,0) +\n               PP(0,1)           + PP(2,1) +\n               PP(0,2)           + PP(2,2) +\n                         PP(1,3) +\n                         PP(1,4));\n    COMP(_W)  (PP(0,0)           + PP(2,0) +\n               PP(0,1)           + PP(2,1) +\n               PP(0,2)           + PP(2,2) +\n               PP(0,3) + PP(1,3) + PP(2,3) +\n               PP(0,4) + PP(1,4) + PP(2,4));\n    COMP(_X)  (PP(0,0)           + PP(2,0) +\n               PP(0,1)           + PP(2,1) +\n                \t     PP(1,2) +\n               PP(0,3)           + PP(2,3) +\n               PP(0,4)           + PP(2,4));\n    COMP(_Y)  (PP(0,0)           + PP(2,0) +\n               PP(0,1) + PP(1,1) + PP(2,1) +\n             \t\t\t PP(1,2) +\n               \t\t     PP(1,3) +\n               \t\t\t PP(1,4));\n    COMP(_Z)  (PP(0,0) + PP(1,0) + PP(2,0) +\n               PP(0,1) +\n                \t     PP(1,2) + \n                                   PP(2,3) +\n               PP(0,4) + PP(1,4) + PP(2,4));\n    \n   \treturn cRet;\n}\n\nfloat DrawSymbol(in vec2 p, int chr)\n{\n    float cRet = 0.;\n    \n    COMP(_SLASH) (PP(0,0) +\n                  PP(0,1) +\n                            PP(1,2) +\n                                      PP(2,3) + \n                                      PP(2,4));\n    \n    COMP(_PLUS)            (PP(1,1) +\n                  PP(0,2) + PP(1,2) + PP(2,2) +\n               \t\t        PP(1,3));\n    \n    COMP(_EXCLAM)       (PP(1,0) +\n               \t\t     PP(1,1) +\n             \t\t\t PP(1,2) +\n               \t\t     \n               \t\t\t PP(1,4));\n    \n    COMP(_HYPHEN) (PP(0,2) + PP(1,2) + PP(2,2));\n \n    return cRet;\n}\n\nfloat fRect(vec2 p,vec2 b){vec2 q=(abs(sCoord-p)-b);return 1.0-clamp(max(q.x,q.y), 0.0, 1.0);}\n\n#define WHITE vec3(1.0)\n#define GRAY  vec3(0.5)\n#define BLACK vec3(0.0)\n\n#define SETUP_UI float inPix = 0.;float hit = 0.;vec3 drawColor = BLACK; int charX, charY\n#define STR(a,b) charX = a; charY =b;\n#define C(a) hit+=DrawChar(vec2(charX, charY), a);charX+=4;\n#define S(a) hit+=DrawSymbol(vec2(charX, charY), a);charX+=4;\n#define SPACE charX+=4;\n#define COLOR(b) drawColor+=hit*b\n#define FADE_IN(start, end) hit*=(smoothstep(start, end, gtime))\n#define FADE_OUT(start, end) hit*=(1.0-smoothstep(start, end, gtime))\n#define PLOT(k) hit=k\n#define DRAW inPix+=hit;hit=0.0\n\nvec4 drawUI()\n{   \n  \tSETUP_UI;\n    \n    vec2 centerPt = vec2(floor(RES_X*0.5), floor(RES_Y*0.5));\n    \n    // Show controls\n    if(time_scale == 0.0 && iFrame > 0)\n    {\n        PLOT(fRect(centerPt, vec2(50, 25)));\n        COLOR(BLACK);\n        DRAW;    \n        PLOT(fRect(centerPt-vec2(0,26), vec2(51, 0)));\n        COLOR(GRAY);\n        DRAW;\n        PLOT(fRect(centerPt+vec2(0,26), vec2(51, 0)));\n        COLOR(WHITE);\n        DRAW;\n        PLOT(fRect(centerPt-vec2(51,0), vec2(0, 25)));\n        COLOR(WHITE);\n        DRAW;\n        PLOT(fRect(centerPt+vec2(51,0), vec2(0, 25)));\n        COLOR(GRAY);\n        DRAW;\n        \n        // CONTROLS\n        PLOT(fRect(centerPt+vec2(0,16), vec2(16, 0)));\n        COLOR(WHITE);\n        DRAW;\n        STR(44,54) C(_C)C(_O)C(_N)C(_T)C(_R)C(_O)C(_L)C(_S)\n        \n        // WSAD/ARROWS PITCH+ROLL\n        STR(11,43) C(_W)C(_S)C(_A)C(_D)S(_SLASH)C(_A)C(_R)C(_R)C(_O)C(_W)C(_S)\n        STR(69,43) C(_P)C(_I)C(_T)C(_C)C(_H)S(_PLUS)C(_R)C(_O)C(_L)C(_L)\n        \n        // Q+E YAW\n        STR(11,36) C(_Q)S(_PLUS)C(_E)\n        STR(69,36) C(_Y)C(_A)C(_W)\n        \n        // J+K THROTTLE\n        STR(11,29) C(_J)S(_PLUS)C(_K)\n        STR(69,29) C(_T)C(_H)C(_R)C(_O)C(_T)C(_T)C(_L)C(_E)\n        \n        // H FANTASTIC!\n        STR(11,22) C(_H)\n        STR(69,22) C(_F)C(_A)C(_N)C(_T)C(_A)C(_S)C(_T)C(_I)C(_C)S(_EXCLAM)\n        \n        // P UNPAUSE\n        STR(11,15) C(_P)\n        STR(69,15) C(_U)C(_N)C(_P)C(_A)C(_U)C(_S)C(_E)\n        \n        // DIVIDERS\n        STR(59,43) S(_HYPHEN)\n        STR(59,36) S(_HYPHEN)\n        STR(59,29) S(_HYPHEN)\n        STR(59,22) S(_HYPHEN)\n        STR(59,15) S(_HYPHEN)\n        COLOR(WHITE);\n        DRAW;\n    } else\n    {\n        // Logo\n        if(gtime < 16.0)\n        {\n            int logoX = int(RES_X)-18;\n            PLOT(fRect(vec2(logoX,4), vec2(10, 3)));\n            COLOR(BLACK);\n            FADE_IN(2.0, 3.0);\n            FADE_OUT(8.0, 10.0);\n            DRAW;\n\n            // LAIKA\n            STR(logoX-7,6) C(_L)C(_A)C(_I)C(_K)C(_A)\n            COLOR(WHITE);\n            FADE_IN(2.0, 3.0);\n            FADE_OUT(8.0, 10.0);\n            DRAW;\n            \n            PLOT(fRect(vec2(37,4), vec2(32, 3)));\n            COLOR(BLACK);\n            FADE_IN(10.0, 11.0);\n            FADE_OUT(14.0, 16.0);\n            DRAW;\n            \n\t\t\t// PRESS P FOR HELP\n            STR(8,6) C(_P)C(_R)C(_E)C(_S)C(_S) SPACE C(_P) SPACE C(_F)C(_O)C(_R) SPACE C(_H)C(_E)C(_L)C(_P)\n            COLOR(WHITE);\n            FADE_IN(10.0, 11.0);\n            FADE_OUT(14.0, 16.0);\n            DRAW;\n        }\n        \n    \t// Crosshairs\n    \tPLOT(PlotPoint(centerPt.x, centerPt.y+2.) + PlotPoint(centerPt.x, centerPt.y-2.) +\n        \t PlotPoint(centerPt.x+2., centerPt.y) + PlotPoint(centerPt.x-2., centerPt.y));\n    \tCOLOR(WHITE);\n    \tDRAW;\n    }\n    \n    return vec4(drawColor, inPix);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 iScaled = vec2(RES_X, RES_Y)*floor(iResolution.y/RES_Y);\n    vec2 offset = (iResolution.xy-iScaled)*0.5;\n    vec2 normFC = fragCoord-offset;\n    vec2 screenScale = vec2(RES_Y / iScaled.y);\n    \n    vec2 lrFC = normFC.xy*screenScale;\n    vec2 lrUV = lrFC / iChannelResolution[0].xy;\n    \n    sCoord = floor(lrFC);\n    \n    GameLoadState();\n    \n    vec4 uiCol = drawUI();\n    if(lrFC.x < 0. || lrFC.x >= RES_X || lrFC.y < 0. || lrFC.y >= RES_Y)\n    {\n        fragColor = vec4((uiCol.a*uiCol.rgb), 1.0);\n    } else\n    {\n        // Blend UI and canvas\n        vec3 canvasCol = texture(iChannel0, lrUV).rgb;\n        \n    \tfragColor = vec4(uiCol.a*uiCol.rgb + (1.-uiCol.a)*canvasCol.rgb, 1.0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/// BUFFER A -- INPUT, COLLISION, AND GAME LOGIC\n\n// Collision uses much smaller clip distance\n#define FAR_CLIP 50.0\n\n// Generic storage template\n// library courtesy of @P_Malin\n\n// Store  addresses and offsets to read data in pixel space\n// e.g.\n#define MEMSIZE_X 4.0\n#define MEMSIZE_Y 5.0\n\nvec2 addrSceneObjs = vec2 ( 0.0, 0.0 );\nvec2 offsetSOPos       = vec2(0.0, 0.0);\nvec2 offsetSOAttr      = vec2(1.0, 0.0);\nvec2 sizeSceneObj = vec2 ( 2.0, 0.0);\n\nvec2 addrCamera = vec2( 0.0, 1.0 );\nvec2 offsetCameraPos = vec2( 0.0, 0.0 );\nvec2 offsetCameraDir = vec2( 1.0, 0.0 );\nvec2 offsetCameraUp = vec2(  2.0, 0.0 );\nvec2 offsetCameraVel = vec2( 3.0, 0.0 );\n\nvec2 addrPrevCamera = vec2( 0.0, 2.0 );\n\nvec2 addrGameState = vec2(0.0, 3.0);\n\n//vec2 addrNextFreeSO = vec2(0.0, 3.0);\n\n#define MAX_SCENEOBJS 1\n\n// CONSTANTS\nfloat PI = acos(-1.0);\n\n/////////////////////////\n// Storage\n\nvec4 LoadVec4( in vec2 vAddr )\n{\n    vec2 vUV = (vAddr + 0.5) / iChannelResolution[0].xy;\n    return texture( iChannel0, vUV, -100.0 );\n}\n\nvec3 LoadVec3( in vec2 vAddr )\n{\n    return LoadVec4( vAddr ).xyz;\n}\n\nfloat IsInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\n\nvoid StoreVec4( in vec2 vAddr, in vec4 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    float comp = step(0.0, IsInside( fragCoord, vAddr ));\n    fragColor = comp*vValue + (1.0-comp)*fragColor;\n}\n\nvoid StoreVec3( in vec2 vAddr, in vec3 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n/////////////////////////\n// Rotation\n\nvec2 Rotate( const in vec2 vPos, const in float t )\n{\n    float s = sin(t);\n    float c = cos(t);\n    \n    return vec2( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y);\n}\n\nvec3 RotX( const in vec3 vPos, float t )\n{\n    vec3 result;\n    result.x = vPos.x;\n  \tresult.yz = Rotate( vPos.yz, t );\n    return result;\n}\n\nvec3 RotY( const in vec3 vPos, float t )\n{\n    vec3 result;\n    result.y = vPos.y;\n  \tresult.xz = Rotate( vPos.xz, t );\n    return result;\n}\n\nvec3 RotZ( const in vec3 vPos, float t )\n{\n    vec3 result;\n    result.z = vPos.z;\n  \tresult.xy = Rotate( vPos.xy, t );\n    return result;\n}\n\n/////////////////////////\n// Quaternions\n\nvec4 QuatMul(const in vec4 lhs, const in vec4 rhs) \n{\n      return vec4( lhs.y*rhs.z - lhs.z*rhs.y + lhs.x*rhs.w + lhs.w*rhs.x,\n                   lhs.z*rhs.x - lhs.x*rhs.z + lhs.y*rhs.w + lhs.w*rhs.y,\n                   lhs.x*rhs.y - lhs.y*rhs.x + lhs.z*rhs.w + lhs.w*rhs.z,\n                   lhs.w*rhs.w - lhs.x*rhs.x - lhs.y*rhs.y - lhs.z*rhs.z);\n}\n\nvec4 QuatFromAxisAngle( vec3 vAxis, float fAngle )\n{\n\treturn vec4( normalize(vAxis) * sin(fAngle), cos(fAngle) );    \n}\n\nvec4 QuatFromVec3( vec3 vRot )\n{\n    float l = length( vRot );\n    if ( l <= 0.0 )\n    {\n        return vec4( 0.0, 0.0, 0.0, 1.0 );\n    }\n    return QuatFromAxisAngle( vRot, l );\n}\n\nmat3 QuatToMat3( const in vec4 q )\n{\n\tvec4 qSq = q * q;\n\tfloat xy2 = q.x * q.y * 2.0;\n\tfloat xz2 = q.x * q.z * 2.0;\n\tfloat yz2 = q.y * q.z * 2.0;\n\tfloat wx2 = q.w * q.x * 2.0;\n\tfloat wy2 = q.w * q.y * 2.0;\n\tfloat wz2 = q.w * q.z * 2.0;\n \n\treturn mat3 (\t\n     qSq.w + qSq.x - qSq.y - qSq.z, xy2 - wz2, xz2 + wy2,\n     xy2 + wz2, qSq.w - qSq.x + qSq.y - qSq.z, yz2 - wx2,\n     xz2 - wy2, yz2 + wx2, qSq.w - qSq.x - qSq.y + qSq.z );\n}\n\nvec3 QuatMul( vec3 v, vec4 q )\n{\n    // TODO Validate vs other quat code\n    vec3 t = 2.0 * cross(q.xyz, v);\n\treturn v + q.w * t + cross(q.xyz, t);\n}\n\n\n/////////////////////////\n\n// Keyboard \n\n// Keyboard constants definition\nconst float KEY_SPACE = 32.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\nconst float KEY_A     = 65.5/256.0;\nconst float KEY_D     = 68.5/256.0;\nconst float KEY_E     = 69.5/256.0;\nconst float KEY_H     = 72.5/256.0;\nconst float KEY_J     = 74.5/256.0;\nconst float KEY_K     = 75.5/256.0;\nconst float KEY_P     = 80.5/256.0;\nconst float KEY_Q     = 81.5/256.0;\nconst float KEY_S     = 83.5/256.0;\nconst float KEY_W     = 87.5/256.0;\n\nbool KeyIsPressed(float key)\n{\n\treturn texture( iChannel1, vec2(key, 0.0) ).x > 0.0;\n}\n\nbool KeyIsToggled(float key)\n{\n\treturn texture( iChannel1, vec2(key, 1.0) ).x > 0.0;\n}\n\n/////////\n// CAMERA\nstruct Camera\n{\n    vec3 vPos;\n    vec3 vDir;\n    vec3 vUp;\n    vec3 vVel;\n};\n    \nCamera cam;\n\nvoid CameraLoadState( out Camera cam, in vec2 addr )\n{\n\tcam.vPos = LoadVec3( addr + offsetCameraPos );\n\tcam.vDir = LoadVec3( addr + offsetCameraDir );\n    cam.vUp =  LoadVec3( addr + offsetCameraUp );\n    cam.vVel = LoadVec3( addr + offsetCameraVel );\n}\n\nvoid CameraStoreState( Camera cam, in vec2 addr, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec3( addr + offsetCameraPos, cam.vPos, fragColor, fragCoord );\n    StoreVec3( addr + offsetCameraDir, cam.vDir, fragColor, fragCoord );\n    StoreVec3( addr + offsetCameraUp,  cam.vUp,  fragColor, fragCoord );\n    StoreVec3( addr + offsetCameraVel, cam.vVel, fragColor, fragCoord );\n}\n\n////////////\n// SCENE STATE\n\nfloat gtime;\nfloat time_scale;\nfloat input_state;\n\nvoid GameLoadState()\n{\n    vec3 state = LoadVec3(addrGameState);\n    \n \tgtime = state.x;\n    time_scale = state.y;\n    input_state = state.z;\n}\n\nvoid GameStoreState(inout vec4 fragColor, in vec2 fragCoord)\n{\n    StoreVec3( addrGameState, vec3(gtime, time_scale, input_state), fragColor, fragCoord );\n}\n\n#define STATE_NULL   0.\n#define STATE_ACTIVE 1.\n\nstruct SceneObject\n{\n    vec3 vPos;\n    //mat3 vTransform;\n    float vState;\n    float vMaterial;\n    float vDist;\n};\n    \nvoid SceneObjectLoadState( out SceneObject so, int objIndex )\n{\n    vec2 addr = addrSceneObjs + float(objIndex)*sizeSceneObj;\n    \n\tso.vPos = LoadVec3( addr + offsetSOPos );\n    \n    //LoadMat3(addr + offsetSOTransform, so.vTransform);\n\t\n    vec3 attr = LoadVec3 ( addr + offsetSOAttr );\n    \n    so.vState = attr.x;\n    so.vMaterial = attr.y;\n    so.vDist = attr.z;\n}\n\nvoid SceneObjectStoreState( SceneObject so, int objIndex, inout vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 addr = addrSceneObjs + float(objIndex)*sizeSceneObj;\n    \n    StoreVec3( addr + offsetSOPos, so.vPos, fragColor, fragCoord );\n    //StoreMat3( addr + offsetSOTransform, so.vTransform, fragColor, fragCoord );\n    StoreVec3( addr + offsetSOAttr, vec3(so.vState, so.vMaterial, so.vDist), fragColor, fragCoord );\n}\n\n\n// hg-sdf library\nconst float _1=.57735026919;\nvec2 _A=normalize(vec2(2.61803398875, 1));\nvec2 _B=normalize(vec2(1,1.61803398875));\nfloat fSphere(vec3 p,float r){return length(p)-r;}\nfloat fBoxCheap(vec3 p,vec3 b){vec3 q=(abs(p)-b);return max(max(q.x,q.y),q.z);}\nfloat fBox(vec3 p,vec3 b){vec3 q,d=abs(p)-b;q=min(d,0.);return length(max(d,0.))+max(max(q.x,q.y),q.z);}\nfloat fCylinder(vec3 p,float r,float h){return max(length(p.xz)-r,abs(p.y)-h);}\nfloat fCapsule(vec3 p,float r,float c){return mix(length(p.xz)-r,length(vec3(p.x,abs(p.y)-c,p.z))-r,step(c,abs(p.y)));}\nfloat fLineSegment(vec3 p,vec3 a,vec3 b){vec3 c=b-a;float t=clamp(dot(p-a,c)/dot(c,c),0.,1.);return length(c*t+a-p);}\nfloat fCapsule(vec3 p,vec3 a,vec3 b,float r){return fLineSegment(p,a,b)-r;}\nfloat fTorus(vec3 p,float i,float r){return length(vec2(length(p.xz)-r,p.y))-i;}\nfloat fCone(vec3 p,float r,float h){vec2 t,m,q=vec2(length(p.xz),p.y);t=q-vec2(0.,h);m=normalize(vec2(h,r));float j=dot(t,vec2(m.y,-m.x)),d=max(dot(t,m),-q.y);if(q.y>h&&j<0.)d=max(d,length(t));if(q.x>r&&j>length(vec2(h,r)))d=max(d,length(q-vec2(r,0.)));return d;}\nvoid pR(inout vec2 p,float a){p=cos(a)*p+sin(a)*vec2(p.y,-p.x);}\nvoid pR45(inout vec2 p){p=(p+vec2(p.y,-p.x))*sqrt(.5);}\nfloat pMod1(inout float p,float s){float c=floor((p/s)+.5);p=(fract((p/s)+.5)-.5)*s;return c;}\nfloat pModMirror1(inout float p,float s){float c=pMod1(p,s);p*=mod(c,2.)*2.-1.;return c;}\nfloat pModSingle1(inout float p,float s){float c=floor((p/s)+.5);if(p>=0.)p=(fract((p/s)+.5)-.5)*s;return c;}\nfloat pModInterval1(inout float p,float s,float b,float x){float c=pMod1(p,s);if(c>x){p+=s*(c-x);c=x;}if(c<b){p+=s*(c-b);c=b;}return c;}\nfloat pModPolar(inout vec2 p,float t){float g=6.28318530718/t,a=atan(p.y,p.x)+g*.5,r=length(p),c=floor(a/g);a=mod(a,g)-g*.5;p=vec2(cos(a),sin(a))*r;if(abs(c)>=t*.5)c=abs(c);return c;}\nvec2 pMod2(inout vec2 p,vec2 s){vec2 c=floor((p/s)+.5);p=(fract((p/s)+.5)-.5)*s;return c;}\nvec2 pModMirror1(inout vec2 p,vec2 s){vec2 c=pMod2(p,s);p*=mod(c,2.)*2.-1.;return c;}\nvec2 pModGrid2(inout vec2 p,vec2 size){vec2 c=floor((p+size*.5)/size);p=mod(p+size*.5,size)-size*.5;p*=mod(c,2.)*2.-vec2(1);p-=size*.5;if(p.x>p.y)p.xy=p.yx;return floor(c*.5);}\nvec3 pMod3(inout vec3 p,vec3 s){vec3 c=floor((p/s)+.5);p=(fract((p/s)+.5)-.5)*s;return c;}\n\n\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// A list of usefull distance function to simple primitives, and an example on how to \n// do some interesting boolean operations, repetition and displacement.\n//\n// More info here: https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\t\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  return max( length(p.xz)-h.x, abs(p.y)-h.y );\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n\treturn max( max( dot(q,c.xy), p.y), -p.y-c.z );\n}\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n  return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//----------------------------------------------------------------------\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\t//return (d1.x<d2.x) ? d1 : d2;\n    float comp = step(d1.x, d2.x);\n    return (comp*d1+(1.0-comp)*d2);\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nSceneObject scene[MAX_SCENEOBJS];\n\n#define MAT_BLDG     3.0\n#define MAT_PAD      2.0\n#define MAT_VESSEL   8.0\n#define MAT_SS      40.0\n#define MAT_L_RED   42.0\n#define MAT_L_GREEN 43.0\n#define MAT_GAS     69.0\n#define MAT_MOON    30.0\n#define MAT_RINGS   50.0\n\nvoid ResetScene(inout Camera c, inout vec4 fcol, in vec2 fcoord)\n{\n     c.vPos = vec3(0.0, 0.0, 0.0);\n     c.vDir = vec3(0.0, 0.0, 1.0);\n     c.vUp = vec3(0.0, 1.0, 0.0);\n     c.vVel = vec3(0.0);\n     //c.vRotVel = vec3(0.0);\n        \n     SceneObject so;\n     for(int i = 0; i < MAX_SCENEOBJS; i++)\n     {\n     \tso.vState = STATE_NULL;\n        SceneObjectStoreState(so, i, fcol, fcoord);\n     }\n    \n     // Initialize dynamic scene objects\n     \n     scene[0].vState = STATE_ACTIVE;\n     scene[0].vPos = vec3(0.0, 1.0, -2.0);\n     scene[0].vMaterial = MAT_VESSEL;\n     //SceneObjectStoreState(so, 0, fcol, fcoord);\n    \n     //StoreVec3(addrNextFreeSO, vec3(1), fcol, fcoord);\n    time_scale = 1.0;\n    input_state = 0.0;\n}\n\nvoid LoadScene(inout Camera c, inout vec4 fcol, in vec2 fcoord)\n{\n    Camera prevCam;\n    \n    // load old camera data\n    CameraLoadState( prevCam, addrCamera );\n\n    // store in addrPrevCamera\n    CameraStoreState( prevCam, addrPrevCamera, fcol, fcoord );\n    \n    c.vPos = prevCam.vPos;\n    c.vDir = prevCam.vDir;\n    c.vUp = prevCam.vUp;\n    c.vVel = prevCam.vVel;\n    //c.vRotVel = prevCam.vRotVel;\n        \n    SceneObject so;\n    for(int i = 0; i < MAX_SCENEOBJS; i++)\n    {\n    \tSceneObjectLoadState(so, i);\n        scene[i] = so;\n    }\n    \n    GameLoadState();\n}\n\nvoid StoreScene(inout Camera c, inout vec4 fcol, in vec2 fcoord)\n{\n    for(int i = 0; i < MAX_SCENEOBJS; i++)\n    {\n        SceneObjectStoreState(scene[i], i, fcol, fcoord);\n    }\n    \n    CameraStoreState( c, addrCamera, fcol, fcoord );\n    \n    GameStoreState(fcol, fcoord);\n}\n\n// CREDIT @TDM\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\n\n// CREDIT @nimitz\n//from iq, see: https://iquilezles.org/articles/morenoise\nmat2 m2 = mat2( 0.80,  0.60, -0.60,  0.80 );\nvec3 noised( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n\tfloat a = texture(iChannel2,(p+vec2(0.5,0.5))/256.0,-100.0).x;\n\tfloat b = texture(iChannel2,(p+vec2(1.5,0.5))/256.0,-100.0).x;\n\tfloat c = texture(iChannel2,(p+vec2(0.5,1.5))/256.0,-100.0).x;\n\tfloat d = texture(iChannel2,(p+vec2(1.5,1.5))/256.0,-100.0).x;\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\nfloat terrain( in vec2 p)\n{\n    float rz = 0.;\n    float z = 1.;\n\tvec2  d = vec2(0.0);\n    float scl = 2.95;\n    float zscl = -.4;\n    float zz = 5.;\n    for( int i=0; i<5; i++ )\n    {\n        vec3 n = noised(p);\n        d += pow(abs(n.yz),vec2(zz));\n        d -= smoothstep(-.5,1.5,n.yz);\n        zz -= 1.;\n        rz += z*n.x/(dot(d,d)+.85);\n        z *= zscl;\n        zscl *= .8;\n        p = m2*p*scl;\n    }\n    \n    rz /= smoothstep(1.5,-.5,rz)+.75;\n    return rz;\n}\n\nconst vec3 SS_POS        = vec3(75.0, 625.0, 100.0);\nconst vec3 MOON_POS      = vec3(0.0, 300., 0.);\nconst vec3 SAND_POS      = vec3(0.0, -501., 0.);\nconst vec3 GAS_POS      = vec3(-400.0, 400., 1500.);\nconst float GAS_RADIUS   = 600.0;\nconst float SAND_RADIUS  = 500.0;\nconst float MOON_RADIUS  = 100.0;\n\n// Utility for sampling a 2D noise domain to perturb a sphere seamlessly\nconst float mPT = 0.01;\nconst float cornerP = sqrt(0.333333);\n#define CM_SAMPLE(ps) vec3 pS = normalize(ps);vec3 p = abs(pS);sCoord1 = pS.yz;sWeights.x = clamp( (p.x - cornerP) / mPT, 0.0, 1.0);sCoord2 = pS.xz;sWeights.y = clamp( (p.y - cornerP) / mPT, 0.0, 1.0);sCoord3 = pS.xy;sWeights.z = clamp( (p.z - cornerP) / mPT, 0.0, 1.0)\n\n#define MOON_SCALE 3.1\n\nfloat sampleMoon(in vec3 pos)\n{\n    vec2 sCoord1, sCoord2, sCoord3;\n    vec3 sWeights;\n    vec3 samples = vec3(0.0);\n    \n    CM_SAMPLE(pos);\n    \n \tif(sWeights.x > 0.0)\n    {\n    \tsamples.x = terrain(10.*sCoord1);\n    }\n    if(sWeights.y > 0.0)\n    {\n        samples.y = terrain(10.*sCoord2);\n    }\n    if(sWeights.z > 0.0)\n    {\n        samples.z = terrain(10.*sCoord3);\n    }\n    \n    return MOON_SCALE*dot(samples, sWeights);\n}\n\n#define SAND_SCALE 4.0\n\nfloat sampleSand(in vec3 pos)\n{\n    vec2 sCoord1, sCoord2, sCoord3;\n    vec3 sWeights;\n    vec3 samples = vec3(0.0);\n    \n    CM_SAMPLE(pos);\n    \n    if(sWeights.x > 0.0)\n    {\n    \tsamples.x = SAND_SCALE*sea_octave(25.*sCoord1, 1.0);\n    }\n    if(sWeights.y > 0.0)\n    {\n        samples.y = SAND_SCALE*sea_octave(25.*sCoord2, 1.0);\n    }\n    if(sWeights.z > 0.0)\n    {\n        samples.z = SAND_SCALE*sea_octave(25.*sCoord3, 1.0);\n    }\n    \n    return dot(samples, sWeights);\n}\n\nfloat sqrdLength( in vec3 v )\n{\n    return v.x*v.x + v.y*v.y + v.z+v.z;\n}\n\nfloat LOD_Scale( in vec3 objPos, float minDist, float maxDist, float minLOD)\n{\n    float sqrdObjDist = sqrdLength(cam.vPos-objPos);\n    float sqrdMinDist = minDist*minDist;\n    float sqrdMaxDist = maxDist*maxDist;\n    \n    // 1.0 at max dist, 0.0 at min dist\n    float distScale = clamp((sqrdObjDist-sqrdMinDist) / (sqrdMaxDist-sqrdMinDist), 0.0, 1.0);\n \treturn minLOD*distScale-distScale+1.0;\n}\n\nvoid mapSpaceStation(in vec3 p, inout vec2 res)\n{\n    res = opU( res, vec2( sdTorus82(p, vec2(14.0, 1.0)), MAT_SS));\n    res = opU( res, vec2( opS( udRoundBox(p, vec3(3.0, 1.5, 3.0), 0.5), fBox(p, vec3(0.75, 3.0, 0.75)) ), MAT_SS));\n    res = opU( res, vec2( udRoundBox( RotZ(p -vec3(7.0, 0.0, 0.0), PI/2.0), vec3(0.75, 6.0, 0.75), 0.25 ), MAT_SS));\n    res = opU( res, vec2( udRoundBox( RotZ(p +vec3(7.0, 0.0, 0.0), PI/2.0), vec3(0.75, 6.0, 0.75), 0.25 ), MAT_SS));\n    res = opU( res, vec2( udRoundBox( RotZ(p +vec3(0.0, 0.0, 7.0), PI/2.0), vec3(0.75, 0.75, 6.0), 0.25 ), MAT_SS));\n    res = opU( res, vec2( udRoundBox( RotZ(p -vec3(0.0, 0.0, 7.0), PI/2.0), vec3(0.75, 0.75, 6.0), 0.25 ), MAT_SS));\n}\n\nvoid mapLandingPlatform(in vec3 p, inout vec2 res)\n{\n    // Landing platform\n    res = opU( res, vec2(sdCylinder(p-vec3(0, -3.0, 0.0), vec2(5.0, 1.0) ), MAT_PAD));\n     \n    // Landing field buildings\n    vec3 modPos = p;\n    pModPolar(modPos.xz, 7.);\n    modPos -= vec3(10., 0., 0.);\n    res = opU( res, vec2(fBox(modPos-vec3(0, -1., 0.), vec3(1., 5., 1.)), MAT_BLDG));\n}\n\n// TODO: collision LOD\nvec2 map( in vec3 pos )\n{ \n    vec3 objPos = pos-SAND_POS;\n    vec2 res = vec2( fSphere(objPos, SAND_RADIUS) + sampleSand(objPos), 46.9);\n    \n    objPos = pos-MOON_POS;\n    res = opU( res, vec2(fSphere(objPos, MOON_RADIUS) + sampleMoon(objPos), 30.0));\n    \n    // Gas planet has no collision\n    \n    // Space station\n   \tobjPos = RotY(pos-SAND_POS-RotZ(SS_POS, gtime*0.001), gtime*0.05);\n    mapSpaceStation(objPos, res);\n    \n    // Load dynamic scene objects\n    SceneObject so;\n    vec3 oP;\n    for(int i = 0; i < MAX_SCENEOBJS; ++i)\n    {\n        so = scene[i];\n        if(so.vState == STATE_ACTIVE)\n        {\n            oP = RotX(pos-so.vPos, PI/2.0);\n            res = opU(res, vec2(opS(smin(sdTriPrism(oP, vec2(0.75, 0.08)), fSphere(oP, 0.4), 0.1), sdTriPrism(oP-vec3(0.0, -0.8, 0.0), vec2(0.8, 0.2))), so.vMaterial));\n        }\n    }\n    \n    // Landing platform\n    mapLandingPlatform(pos, res);\n    \n    return res;\n}\n\nfloat nrand(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n#define MAX_SPEED 7.0\n#define MIN_SPEED 0.0\n#define ACCEL_RATE 0.85\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (( fragCoord.x > MEMSIZE_X ) || ( fragCoord.y > MEMSIZE_Y ) )\n    {\n        // Ignore outside of memory boundary\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n    \n    if(iFrame == 1) // Initial setup of scene state\n    {\n        ResetScene(cam, fragColor, fragCoord);\n        gtime = 0.0;\n    } else // Load scene state\n    {\n        LoadScene(cam, fragColor, fragCoord);\n    }\n    \n    float time_delta = iTimeDelta*time_scale;\n    float pitchAngle = 0.;\n    float rollAngle = 0.;\n    float yawAngle = 0.;\n    \n    // Toggle pause\n    if(KeyIsPressed(KEY_P))\n    {\n        input_state = clamp(input_state+0.5, 0.0, 1.0);\n        \n        if(input_state == 1.0)\n        {\n        \ttime_scale = (1.0-time_scale);\n        \tinput_state = 0.0;\n        }\n    }\n    input_state = input_state*pow(0.75, 3.*iTimeDelta);\n    \n    // Throttle\n    if(KeyIsPressed(KEY_K))\n    {\n        cam.vVel.x += ACCEL_RATE*time_delta;\n        \n        if(cam.vVel.x < MAX_SPEED)\n        {\n        \tpitchAngle += 0.2*time_delta*(nrand(vec2(gtime, iFrame)) - 0.5);\n        \trollAngle += 0.1*time_delta*(nrand(vec2(iFrame, gtime)) - 0.5);\n       \t\tyawAngle += 0.2*time_delta*(nrand(vec2(iFrame, 0.5*gtime)) - 0.5);\n        } else\n        {\n            cam.vVel.x = MAX_SPEED;\n        }\n    } else if(KeyIsPressed(KEY_J))\n    {\n        cam.vVel.x -= ACCEL_RATE*time_delta;\n        \n        if(cam.vVel.x > MIN_SPEED)\n        {\n        \tpitchAngle += 0.2*time_delta*(nrand(vec2(gtime, iFrame)) - 0.5);\n        \trollAngle += 0.1*time_delta*(nrand(vec2(iFrame, gtime)) - 0.5);\n       \t\tyawAngle += 0.2*time_delta*(nrand(vec2(iFrame, 0.5*gtime)) - 0.5);\n        } else\n        {\n            cam.vVel.x = MIN_SPEED;\n        }\n    }\n   \n    // Speed\n    if(KeyIsPressed(KEY_H))\n    {\n        cam.vVel.y += 1.5*time_delta; // Hyperdrive\n        cam.vVel.y = clamp(cam.vVel.y, 0.0, 2.0);\n        \n    \t// Cockpit jitter\n        pitchAngle += cam.vVel.y*0.5*time_delta*(nrand(vec2(gtime, iFrame)) - 0.5);\n        rollAngle += cam.vVel.y*0.5*time_delta*(nrand(vec2(iFrame, gtime)) - 0.5);\n        yawAngle += cam.vVel.y*0.75*time_delta*(nrand(vec2(iFrame, 0.5*gtime)) - 0.5);\n    } else\n    {\n        cam.vVel.y = cam.vVel.y*pow(0.75, 3.*time_delta); // Normal space\n        cam.vVel.y = step(0.05, cam.vVel.y)*cam.vVel.y;\n    }\n    \n    // Camera roll\n    if(KeyIsPressed(KEY_A) || KeyIsPressed(KEY_LEFT))\n    {\n        rollAngle -= time_delta;\n    } else if(KeyIsPressed(KEY_D) || KeyIsPressed(KEY_RIGHT))\n    {\n        rollAngle += time_delta;\n    }\n    \n    // Camera yaw\n    if(KeyIsPressed(KEY_Q))\n    {\n        yawAngle += 0.15*time_delta;\n    } else if(KeyIsPressed(KEY_E))\n    {\n        yawAngle -= 0.15*time_delta;\n    }\n    \n    // Apply yaw\n    vec4 q = QuatFromAxisAngle(cam.vUp, yawAngle);\n    vec3 newDir = QuatMul(cam.vDir, q);\n    cam.vDir = newDir;\n    \n    // Apply roll\n    q = QuatFromAxisAngle(cam.vDir, rollAngle);\n    vec3 newUp = QuatMul(cam.vUp, q);\n    cam.vUp = newUp;\n    vec3 vRight = cross(cam.vDir, cam.vUp);\n    \n    // Camera pitch\n    if(KeyIsPressed(KEY_W) || KeyIsPressed(KEY_UP))\n    {\n        pitchAngle -= time_delta*0.5;\n    } else if(KeyIsPressed(KEY_S) || KeyIsPressed(KEY_DOWN))\n    {\n        pitchAngle += time_delta*0.5;\n    }\n    \n    // Apply pitch\n    q = QuatFromAxisAngle(vRight, pitchAngle);\n    newDir = QuatMul(cam.vDir, q);\n    newUp = QuatMul(cam.vUp, q);\n    cam.vDir = newDir;\n    cam.vUp = newUp;\n    \n    // Camera movement\n    cam.vPos += cam.vDir*time_delta*( cam.vVel.y*30.0 + (1.0-cam.vVel.y)*cam.vVel.x );\n    \n    // Check for collision\n    vec2 collision = map(cam.vPos);\n    if(collision.x < 0.001)\n    {\n        ResetScene(cam, fragColor, fragCoord);\n    }\n    \n    // Update dynamic scene objects\n    SceneObject so;\n    for(int i = 0; i < MAX_SCENEOBJS; ++i)\n    {\n        so = scene[i];\n        if(so.vState == STATE_ACTIVE)\n        {\n            so.vPos.z += 0.8*time_delta;\n            scene[i].vPos = so.vPos;\n        }\n    }\n    \n    gtime += time_delta;\n    StoreScene( cam, fragColor, fragCoord );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/// BUFFER B -- G-BUFFER PASS\n\n#define RES_X 114.0\n#define RES_Y 64.0\n#define FAR_CLIP 8000.0\n\n#define MARCH_STEPS 200\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n\nconst float NORMAL_FOV = 80. * 3.14159 / 180.;\n\n// Generic storage template\n// library courtesy of @P_Malin\n\n// Store  addresses and offsets to read data in pixel space\n// e.g.\n\nvec2 addrSceneObjs = vec2 ( 0.0, 0.0 );\nvec2 offsetSOPos       = vec2(0.0, 0.0);\nvec2 offsetSOAttr      = vec2(1.0, 0.0);\nvec2 sizeSceneObj = vec2 ( 2.0, 0.0);\n\nvec2 addrCamera = vec2( 0.0, 1.0 );\nvec2 offsetCameraPos = vec2( 0.0, 0.0 );\nvec2 offsetCameraDir = vec2( 1.0, 0.0 );\nvec2 offsetCameraUp = vec2(  2.0, 0.0);\nvec2 offsetCameraVel = vec2( 3.0, 0.0 );\n\nvec2 addrPrevCamera = vec2( 0.0, 2.0 );\n\nvec2 addrGameState = vec2(0.0, 3.0);\n\n#define MAX_SCENEOBJS 1\n\n// CONSTANTS\nfloat PI = acos(-1.0);\n\n/////////////////////////\n// Storage\n\nvec4 LoadVec4( in vec2 vAddr )\n{\n    vec2 vUV = (vAddr + 0.5) / iChannelResolution[0].xy;\n    return texture( iChannel0, vUV, -100.0 );\n}\n\nvec3 LoadVec3( in vec2 vAddr )\n{\n    return LoadVec4( vAddr ).xyz;\n}\n\nfloat IsInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\n\n\n/////////\n// CAMERA\nstruct Camera\n{\n    vec3 vPos;\n    vec3 vDir;\n    vec3 vUp;\n    vec3 vVel;\n};\n\nvoid CameraLoadState( out Camera cam, in vec2 addr )\n{\n\tcam.vPos = LoadVec3( addr + offsetCameraPos );\n\tcam.vDir = LoadVec3( addr + offsetCameraDir );\n    cam.vUp =  LoadVec3( addr + offsetCameraUp );\n    cam.vVel = LoadVec3( addr + offsetCameraVel );\n}\n\nCamera cam;\nvec2 atmoRes;\n\n////////////\n// SCENE STATE\n\nfloat gtime;\nfloat time_scale;\n\nvoid GameLoadState()\n{\n    vec3 state = LoadVec3(addrGameState);\n    \n \tgtime = state.x;\n    time_scale = state.y;\n}\n\n#define STATE_NULL   0.\n#define STATE_ACTIVE 1.\n\nstruct SceneObject\n{\n    vec3 vPos;\n    float vState;\n    float vMaterial;\n    float vDist;\n};\n    \nvoid SceneObjectLoadState( out SceneObject so, int objIndex )\n{\n    vec2 addr = addrSceneObjs + float(objIndex)*sizeSceneObj;\n    \n\tso.vPos = LoadVec3( addr + offsetSOPos );\n    \t\n    vec3 attr = LoadVec3 ( addr + offsetSOAttr );\n    \n    so.vState = attr.x;\n    so.vMaterial = attr.y;\n    so.vDist = attr.z;\n}\n\n\n\n/////////////////////////\n// Rotation\n\nvec2 Rotate( const in vec2 vPos, const in float t )\n{\n    float s = sin(t);\n    float c = cos(t);\n    \n    return vec2( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y);\n}\n\nvec3 RotX( const in vec3 vPos, float t )\n{\n    vec3 result;\n    result.x = vPos.x;\n  \tresult.yz = Rotate( vPos.yz, t );\n    return result;\n}\n\nvec3 RotY( const in vec3 vPos, float t )\n{\n    vec3 result;\n    result.y = vPos.y;\n  \tresult.xz = Rotate( vPos.xz, t );\n    return result;\n}\n\nvec3 RotZ( const in vec3 vPos, float t )\n{\n    vec3 result;\n    result.z = vPos.z;\n  \tresult.xy = Rotate( vPos.xy, t );\n    return result;\n}\n\n/////////////////////////\n// Quaternions\n\nvec4 QuatMul(const in vec4 lhs, const in vec4 rhs) \n{\n      return vec4( lhs.y*rhs.z - lhs.z*rhs.y + lhs.x*rhs.w + lhs.w*rhs.x,\n                   lhs.z*rhs.x - lhs.x*rhs.z + lhs.y*rhs.w + lhs.w*rhs.y,\n                   lhs.x*rhs.y - lhs.y*rhs.x + lhs.z*rhs.w + lhs.w*rhs.z,\n                   lhs.w*rhs.w - lhs.x*rhs.x - lhs.y*rhs.y - lhs.z*rhs.z);\n}\n\nvec4 QuatFromAxisAngle( vec3 vAxis, float fAngle )\n{\n\treturn vec4( normalize(vAxis) * sin(fAngle), cos(fAngle) );    \n}\n\nvec4 QuatFromVec3( vec3 vRot )\n{\n    float l = length( vRot );\n    if ( l <= 0.0 )\n    {\n        return vec4( 0.0, 0.0, 0.0, 1.0 );\n    }\n    return QuatFromAxisAngle( vRot, l );\n}\n\nmat3 QuatToMat3( const in vec4 q )\n{\n\tvec4 qSq = q * q;\n\tfloat xy2 = q.x * q.y * 2.0;\n\tfloat xz2 = q.x * q.z * 2.0;\n\tfloat yz2 = q.y * q.z * 2.0;\n\tfloat wx2 = q.w * q.x * 2.0;\n\tfloat wy2 = q.w * q.y * 2.0;\n\tfloat wz2 = q.w * q.z * 2.0;\n \n\treturn mat3 (\t\n     qSq.w + qSq.x - qSq.y - qSq.z, xy2 - wz2, xz2 + wy2,\n     xy2 + wz2, qSq.w - qSq.x + qSq.y - qSq.z, yz2 - wx2,\n     xz2 - wy2, yz2 + wx2, qSq.w - qSq.x - qSq.y + qSq.z );\n}\n\nvec3 QuatMul( vec3 v, vec4 q )\n{\n    // TODO Validate vs other quat code\n    vec3 t = 2.0 * cross(q.xyz, v);\n\treturn v + q.w * t + cross(q.xyz, t);\n}\n\nconst float _1=.57735026919;\nvec2 _A=normalize(vec2(2.61803398875, 1));\nvec2 _B=normalize(vec2(1,1.61803398875));\nfloat fSphere(vec3 p,float r){return length(p)-r;}\nfloat fBoxCheap(vec3 p,vec3 b){vec3 q=(abs(p)-b);return max(max(q.x,q.y),q.z);}\nfloat fBox(vec3 p,vec3 b){vec3 q,d=abs(p)-b;q=min(d,0.);return length(max(d,0.))+max(max(q.x,q.y),q.z);}\nfloat fCylinder(vec3 p,float r,float h){return max(length(p.xz)-r,abs(p.y)-h);}\nfloat fCapsule(vec3 p,float r,float c){return mix(length(p.xz)-r,length(vec3(p.x,abs(p.y)-c,p.z))-r,step(c,abs(p.y)));}\nfloat fLineSegment(vec3 p,vec3 a,vec3 b){vec3 c=b-a;float t=clamp(dot(p-a,c)/dot(c,c),0.,1.);return length(c*t+a-p);}\nfloat fCapsule(vec3 p,vec3 a,vec3 b,float r){return fLineSegment(p,a,b)-r;}\nfloat fTorus(vec3 p,float i,float r){return length(vec2(length(p.xz)-r,p.y))-i;}\nfloat fCone(vec3 p,float r,float h){vec2 t,m,q=vec2(length(p.xz),p.y);t=q-vec2(0.,h);m=normalize(vec2(h,r));float j=dot(t,vec2(m.y,-m.x)),d=max(dot(t,m),-q.y);if(q.y>h&&j<0.)d=max(d,length(t));if(q.x>r&&j>length(vec2(h,r)))d=max(d,length(q-vec2(r,0.)));return d;}\nvoid pR(inout vec2 p,float a){p=cos(a)*p+sin(a)*vec2(p.y,-p.x);}\nvoid pR45(inout vec2 p){p=(p+vec2(p.y,-p.x))*sqrt(.5);}\nfloat pMod1(inout float p,float s){float c=floor((p/s)+.5);p=(fract((p/s)+.5)-.5)*s;return c;}\nfloat pModMirror1(inout float p,float s){float c=pMod1(p,s);p*=mod(c,2.)*2.-1.;return c;}\nfloat pModSingle1(inout float p,float s){float c=floor((p/s)+.5);if(p>=0.)p=(fract((p/s)+.5)-.5)*s;return c;}\nfloat pModInterval1(inout float p,float s,float b,float x){float c=pMod1(p,s);if(c>x){p+=s*(c-x);c=x;}if(c<b){p+=s*(c-b);c=b;}return c;}\nfloat pModPolar(inout vec2 p,float t){float g=6.28318530718/t,a=atan(p.y,p.x)+g*.5,r=length(p),c=floor(a/g);a=mod(a,g)-g*.5;p=vec2(cos(a),sin(a))*r;if(abs(c)>=t*.5)c=abs(c);return c;}\nvec2 pMod2(inout vec2 p,vec2 s){vec2 c=floor((p/s)+.5);p=(fract((p/s)+.5)-.5)*s;return c;}\nvec2 pModMirror1(inout vec2 p,vec2 s){vec2 c=pMod2(p,s);p*=mod(c,2.)*2.-1.;return c;}\nvec2 pModGrid2(inout vec2 p,vec2 size){vec2 c=floor((p+size*.5)/size);p=mod(p+size*.5,size)-size*.5;p*=mod(c,2.)*2.-vec2(1);p-=size*.5;if(p.x>p.y)p.xy=p.yx;return floor(c*.5);}\nvec3 pMod3(inout vec3 p,vec3 s){vec3 c=floor((p/s)+.5);p=(fract((p/s)+.5)-.5)*s;return c;}\n\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// A list of usefull distance function to simple primitives, and an example on how to \n// do some interesting boolean operations, repetition and displacement.\n//\n// More info here: https://iquilezles.org/articles/distfunctions\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  return max( length(p.xz)-h.x, abs(p.y)-h.y );\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n\treturn max( max( dot(q,c.xy), p.y), -p.y-c.z );\n}\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n  return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\nfloat sdCappedCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n    vec2 w = v - q;\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n    vec2 d = max(qv,0.0)*qv/vv;\n    return sqrt( dot(w,w) - max(d.x,d.y) )* sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\n//----------------------------------------------------------------------\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\t//return (d1.x<d2.x) ? d1 : d2;\n    float comp = step(d1.x, d2.x);\n    return (comp*d1+(1.0-comp)*d2);\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nSceneObject scene[MAX_SCENEOBJS];\n\n\n// CREDIT @TDM\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\n// CREDIT @nimitz\n//form iq, see: https://iquilezles.org/articles/morenoise\nmat2 m2 = mat2( 0.80,  0.60, -0.60,  0.80 );\nvec3 noised( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n\tfloat a = texture(iChannel2,(p+vec2(0.5,0.5))/256.0,-100.0).x;\n\tfloat b = texture(iChannel2,(p+vec2(1.5,0.5))/256.0,-100.0).x;\n\tfloat c = texture(iChannel2,(p+vec2(0.5,1.5))/256.0,-100.0).x;\n\tfloat d = texture(iChannel2,(p+vec2(1.5,1.5))/256.0,-100.0).x;\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\nfloat terrain( in vec2 p)\n{\n    float rz = 0.;\n    float z = 1.;\n\tvec2  d = vec2(0.0);\n    float scl = 2.95;\n    float zscl = -.4;\n    float zz = 5.;\n    for( int i=0; i<5; i++ )\n    {\n        vec3 n = noised(p);\n        d += pow(abs(n.yz),vec2(zz));\n        d -= smoothstep(-.5,1.5,n.yz);\n        zz -= 1.;\n        rz += z*n.x/(dot(d,d)+.85);\n        z *= zscl;\n        zscl *= .8;\n        p = m2*p*scl;\n    }\n    \n    rz /= smoothstep(1.5,-.5,rz)+.75;\n    return rz;\n}\n\n\n//----------------------------------------------------------------------\n\n\nconst vec3 SS_POS        = vec3(75.0, 625.0, 100.0);\nconst vec3 MOON_POS      = vec3(0.0, 300., 0.);\nconst vec3 SAND_POS      = vec3(0.0, -501., 0.);\nconst vec3 GAS_POS       = vec3(-400.0, 600., 1500.);\nconst float GAS_RADIUS   = 600.0;\nconst float SAND_RADIUS  = 500.0;\nconst float MOON_RADIUS  = 100.0;\n\n// Utility for sampling a 2D noise domain to perturb a sphere seamlessly\nconst float mPT = 0.05;\nconst float cornerP = sqrt(0.333333);\n#define CM_SAMPLE(ps) vec3 pS = normalize(ps);vec3 p = abs(pS);sCoord1 = pS.yz;sWeights.x = clamp( (p.x - cornerP) / mPT, 0.0, 1.0);sCoord2 = pS.xz;sWeights.y = clamp( (p.y - cornerP) / mPT, 0.0, 1.0);sCoord3 = pS.xy;sWeights.z = clamp( (p.z - cornerP) / mPT, 0.0, 1.0)\n\n#define MOON_SCALE 3.1\n\nfloat sampleMoon(in vec3 pos)\n{\n    vec2 sCoord1, sCoord2, sCoord3;\n    vec3 sWeights;\n    vec3 samples = vec3(0.0);\n    \n    CM_SAMPLE(pos);\n    \n \tif(sWeights.x > 0.0)\n    {\n    \tsamples.x = terrain(10.*sCoord1);\n    }\n    if(sWeights.y > 0.0)\n    {\n        samples.y = terrain(10.*sCoord2);\n    }\n    if(sWeights.z > 0.0)\n    {\n        samples.z = terrain(10.*sCoord3);\n    }\n    \n    return MOON_SCALE*dot(samples, sWeights);\n}\n\n#define SAND_SCALE 4.0\n\nfloat sampleSand(in vec3 pos)\n{\n    vec2 sCoord1, sCoord2, sCoord3;\n    vec3 sWeights;\n    vec3 samples = vec3(0.0);\n    \n    CM_SAMPLE(pos);\n    \n    if(sWeights.x > 0.0)\n    {\n    \tsamples.x = SAND_SCALE*sea_octave(25.*sCoord1, 1.0);\n    }\n    if(sWeights.y > 0.0)\n    {\n        samples.y = SAND_SCALE*sea_octave(25.*sCoord2, 1.0);\n    }\n    if(sWeights.z > 0.0)\n    {\n        samples.z = SAND_SCALE*sea_octave(25.*sCoord3, 1.0);\n    }\n    \n    return dot(samples, sWeights);\n}\n\nfloat sqrdLength( in vec3 v )\n{\n    return v.x*v.x + v.y*v.y + v.z+v.z;\n}\n\nfloat LOD_Scale( in vec3 objPos, float minDist, float maxDist, float minLOD)\n{\n    float sqrdObjDist = sqrdLength(cam.vPos-objPos);\n    float sqrdMinDist = minDist*minDist;\n    float sqrdMaxDist = maxDist*maxDist;\n    \n    // 1.0 at max dist, 0.0 at min dist\n    float distScale = clamp((sqrdObjDist-sqrdMinDist) / (sqrdMaxDist-sqrdMinDist), 0.0, 1.0);\n \treturn minLOD*distScale-distScale+1.0;\n}\n\n//  > 0 if there's an intersection\nfloat intSphere( in vec3 ro, in vec3 rd, in vec3 sp, in float rad )\n{\n    vec3  d = ro - sp;\n    float b = dot(rd,d);\n    float c = dot(d,d) - rad*rad;\n    float t = sign(b*b-c);\n    \n    // make t positive if |rd| == 0\n    return ( t + 2.0*( 1.0-abs(sign(b)) ) );\n}\n\n#define MAT_BLDG     3.0\n#define MAT_PAD      2.0\n#define MAT_VESSEL   8.0\n#define MAT_SS      40.0\n#define MAT_L_RED   42.0\n#define MAT_L_GREEN 43.0\n#define MAT_GAS     69.0\n#define MAT_MOON    30.0\n#define MAT_RINGS   50.0\n\nvoid mapSpaceStation(in vec3 p, inout vec2 res)\n{\n    res = opU( res, vec2( sdTorus82(p, vec2(14.0, 1.0)), MAT_SS));\n    res = opU( res, vec2( fSphere(p + vec3(1.0, 2.0, 0.0), 0.15), MAT_L_RED));\n    res = opU( res, vec2( fSphere(p + vec3(-1.0, 2.0, 0.0), 0.15), MAT_L_RED));\n    res = opU( res, vec2( fSphere(p + vec3(1.0, -2.0, 0.0), 0.15), MAT_L_GREEN));\n    res = opU( res, vec2( fSphere(p + vec3(-1.0, -2.0, 0.0), 0.15), MAT_L_GREEN));\n    res = opU( res, vec2( opS( udRoundBox(p, vec3(3.0, 1.5, 3.0), 0.5), fBox(p, vec3(0.75, 3.0, 0.75)) ), MAT_SS));\n    res = opU( res, vec2( udRoundBox( RotZ(p -vec3(7.0, 0.0, 0.0), PI/2.0), vec3(0.75, 6.0, 0.75), 0.25 ), MAT_SS));\n    res = opU( res, vec2( udRoundBox( RotZ(p +vec3(7.0, 0.0, 0.0), PI/2.0), vec3(0.75, 6.0, 0.75), 0.25 ), MAT_SS));\n    res = opU( res, vec2( udRoundBox( RotZ(p +vec3(0.0, 0.0, 7.0), PI/2.0), vec3(0.75, 0.75, 6.0), 0.25 ), MAT_SS));\n    res = opU( res, vec2( udRoundBox( RotZ(p -vec3(0.0, 0.0, 7.0), PI/2.0), vec3(0.75, 0.75, 6.0), 0.25 ), MAT_SS));\n}\n\nvoid mapLandingPlatform(in vec3 p, inout vec2 res)\n{\n    // Landing platform\n    res = opU( res, vec2(sdCylinder(p-vec3(0, -3.0, 0.0), vec2(5.0, 1.0) ), MAT_PAD));\n    res = opU( res, vec2(fSphere(p-vec3(-4.9, -2.0, 0.0), 0.15), MAT_L_GREEN));\n    res = opU( res, vec2(fSphere(p-vec3(4.9, -2.0, 0.0), 0.15), MAT_L_GREEN));\n    res = opU( res, vec2(fSphere(p-vec3(0.0, -2.0, 4.9), 0.15), MAT_L_GREEN));\n    res = opU( res, vec2(fSphere(p-vec3(0.0, -2.0, -4.9), 0.15), MAT_L_GREEN));\n     \n    // Landing field buildings\n    vec3 modPos = p;\n    pModPolar(modPos.xz, 7.);\n    modPos -= vec3(10., 0., 0.);\n    res = opU( res, vec2(fBox(modPos-vec3(0, -1., 0.), vec3(1., 5., 1.)), MAT_BLDG));\n}\n\nvec2 map( in vec3 pos, in vec3 rd )\n{ \n    float lodScale;\n    vec3 objPos;\n    vec2 res = vec2(FAR_CLIP, -1.0);\n    \n    if(intSphere(cam.vPos, rd, SAND_POS, SAND_RADIUS+SAND_SCALE) > 0.0)\n    {\n        objPos = pos-SAND_POS;\n        lodScale = LOD_Scale(SAND_POS, SAND_RADIUS+SAND_RADIUS*0.15, 1.25*SAND_RADIUS, 0.3);\n        res = vec2( fSphere(objPos, SAND_RADIUS) + lodScale*sampleSand(objPos), 46.9);\n    }\n    \n    if(intSphere(cam.vPos, rd, MOON_POS, MOON_RADIUS+MOON_SCALE) > 0.0)\n    {\n        objPos = pos-MOON_POS;\n        lodScale = LOD_Scale(MOON_POS, MOON_RADIUS+MOON_RADIUS*0.15, 1.5*MOON_RADIUS, 0.25);\n        res = opU( res, vec2(fSphere(objPos, MOON_RADIUS) + lodScale*sampleMoon(objPos), MAT_MOON));\n    }\n    \n    objPos = pos-GAS_POS;\n    res = opU( res, vec2(fSphere(objPos, GAS_RADIUS), MAT_GAS));\n \n    if((length(cam.vPos-SAND_POS) < (SAND_RADIUS+15.0)) || (length(cam.vPos-GAS_POS) < (GAS_RADIUS+15.0)))\n    {\n        // Draw fake rings if we're inside the desert planet's atmo\n        // this is a horrible hack and it looks bad. need to fix this.\n    \tres = opU( res, vec2(opS(sdCylinder(RotZ(RotX(objPos, -0.5), 0.2), vec2(GAS_RADIUS+500., 10.0)), sdSphere(objPos, GAS_RADIUS+100.)), MAT_RINGS));\n    }\n    \n    // Space station\n    objPos = RotY(pos-SAND_POS-RotZ(SS_POS, gtime*0.001), gtime*0.05);\n    mapSpaceStation(objPos, res);\n\n    // Load dynamic scene objects, i.e. other ships\n    SceneObject so;\n    vec3 oP;\n    for(int i = 0; i < MAX_SCENEOBJS; ++i)\n    {\n        so = scene[i];\n        if(so.vState == STATE_ACTIVE)\n        {\n            oP = RotX(pos-so.vPos, PI/2.0);\n            res = opU(res, vec2(opS(smin(sdTriPrism(oP, vec2(0.75, 0.08)), fSphere(oP, 0.4), 0.1), sdTriPrism(oP-vec3(0.0, -0.8, 0.0), vec2(0.8, 0.2))), so.vMaterial));\n        }\n    }\n    \n    // Your ship -- need to fix this\n    oP = RotX(pos-cam.vPos+cam.vDir+cam.vUp, PI/2.0);\n    res = opU(res, vec2(opS(sdTriPrism(oP, vec2(0.75, 0.08)), sdTriPrism(oP-vec3(0.0, -0.8, 0.0), vec2(0.8, 0.2))), so.vMaterial));\n   \n    mapLandingPlatform(pos, res);\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, in float maxd )\n{\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float t = 0.0;\n    float m = -1.0;\n    for( int i=0; i<MARCH_STEPS; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) break; // continue;\n        t += h;\n\t    vec2 res = map( ro+rd*t, rd );\n        h = res.x;\n\t    m = res.y;\n    }\n\n    if( t>maxd ) m=0.0;\n    return vec2( t, m );\n}\n\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 fakeRD = vec3(0.0);\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy, fakeRD).x - map(pos-eps.xyy, fakeRD).x,\n\t    map(pos+eps.yxy, fakeRD).x - map(pos-eps.yxy, fakeRD).x,\n\t    map(pos+eps.yyx, fakeRD).x - map(pos-eps.yyx, fakeRD).x );\n\treturn normalize(nor);\n}\n\n// modified from http://aras-p.info/texts/CompactNormalStorage.html\nvec2 N_To_Sph(in vec3 n)\n{\n\treturn (vec2(atan(n.y,n.x)/PI, n.z)+1.0)*0.5;\n}\n\nvec4 renderGBuffer( in vec3 ro, in vec3 rd )\n{ \n    vec4 g;\n    vec2 res = castRay(ro, rd, FAR_CLIP);\n    float t = res.x;\n\tfloat m = res.y;\n    \n    if(m > 0.0 )\n    {\n        vec2 polarNorm = N_To_Sph(calcNormal(ro + t*rd)); \n\n        g = vec4(t, polarNorm, m);\n    } else\n    {\n        g = vec4(0.0);\n    }\n \n\treturn g;\n}\n\nvoid LoadScene(inout vec4 fcol, in vec2 fcoord)\n{\n    CameraLoadState( cam, addrCamera );\n\n    SceneObject so;\n    for(int i = 0; i < MAX_SCENEOBJS; i++)\n    {\n    \tSceneObjectLoadState(so, i);\n        scene[i] = so;\n    }\n    \n    GameLoadState();\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.x < 0. || fragCoord.x >= RES_X || fragCoord.y < 0. || fragCoord.y >= RES_Y)\n    {\n        fragColor = vec4(0., 0., 0., 0.);\n        return;\n    }\n    \n    // Load scene data;\n\tLoadScene(fragColor, fragCoord);\n\n    // Hyperdrive camera\n    float hyperModX = 1.0 - pow(clamp(cam.vVel.y, 0., 0.45), 2.);\n    float hyperModY = 1.0 - pow(clamp(cam.vVel.y, 0., 0.25), 2.);\n    \n    // camera vectors\n    vec2 q = fragCoord.xy/vec2(RES_X, RES_Y);\n    vec2 p = -1.0+2.0*q;\n    p.x *= RES_X/RES_Y;\n\tvec3 cu = normalize( cross(cam.vDir,cam.vUp) );\n\tvec3 cv = normalize( cross(cu,cam.vDir) );\n\tvec3 rd = normalize( p.x*cu*hyperModX + p.y*cv*hyperModY + (NORMAL_FOV*cam.vDir));\n\n    fragColor = renderGBuffer( cam.vPos, rd );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/// SOUND BUFFER -- VERY CRUDE, OFF-KEY VERSION OF \"BLUE DANUBE\"\n\nfloat PI = acos(-1.0);\nfloat t;\n\n// note frequencies\nconst float E2\t=  82.41;\nconst float F2\t=  87.31;\nconst float G2 \t=  98.00;\nconst float GH2 = 103.83;\nconst float AH2 = 116.54;\nconst float C3 \t= 130.81;\nconst float CH3\t= 138.59;\nconst float D3 \t= 146.83;\nconst float DH3 = 155.56;\nconst float E3 \t= 164.81;\nconst float F3\t= 174.61;\nconst float FH3 = 185.00;\nconst float G3 \t= 196.00;\nconst float GH3 = 207.65;\nconst float A3 \t= 220.00;\nconst float AH3\t= 233.08;\nconst float B3 \t= 246.94;\nconst float C4 \t= 261.63;\nconst float D4  = 293.66;\nconst float DH4 = 311.13;\nconst float E4 \t= 329.63;\nconst float F4 \t= 349.23;\nconst float FH4 = 369.99;\nconst float G4 \t= 392.00;\nconst float GH4 = 415.30;\nconst float A4\t= 440.00;\nconst float AH4 = 466.16;\nconst float C5  = 523.25;\nconst float G5  = 783.99;\n\nvec2 triangleWave( float freq ) \n{\n    float f = fract( t*freq ) - 1.;\n    f /= (f >= 0.0 ? 1.0 : 0.0) - 1.;\n    return vec2(abs(f) * 2.0 - 1.0);\n}\n\nvec2 sawtoothWave( float freq ) \n{\n    float f = fract( t*freq ) - 1.;\n    f /= (f >= 0.0 ? 1.0 : 0.0) - 1.;\n    return vec2(f * 2.0 - 1.0);\n}\n\nvec2 squareWave( float freq )\n{\n    return vec2( sign(mod(floor(2.0*t*freq), 2.0) - 0.5) );\n}\n\nvec2 sineWave ( float freq )\n{\n    return vec2 ( sin(2.*PI*t*freq) );\n}\n\nvec2 noise ()\n{\n    return vec2(fract( sin( 123523.9898 * t ) * 43758.5453 ));\n}\n\nvec2 playSound(in vec2 audioFunc, float startTime, float duration, float attackTime, float decayTime)\n{\n    float curTime = t - startTime;\n    if(curTime < 0. || curTime > duration)\n    {\n        return vec2(0.);\n    }\n    \n    return smoothstep(0., attackTime, curTime)*audioFunc*(1.0-smoothstep(duration-decayTime, duration, curTime));\n}\n\n#define REST q+=0.5;\n#define W(a) sum += vec2(0.05)*playSound(sineWave(a), q, 0.5, 0.05, 0.05);q+=0.5;\n#define H(a) sum += vec2(0.05)*playSound(sineWave(a), q, 0.25, 0.05, 0.05);q+=0.5;\n\nvec2 mainSound( in int samp, float time )\n{\n    t = time;\n    \n    float q = 0.;\n    vec2 sum = vec2(0.);\n    \n    H(A3) W(A3) H(B3) H(C4) W(C4) REST H(A4) H(A4) REST  H(G4) H(G4)\n    \n    //return vec2(0.05)*playSound(sineWave(A4), 2., 2., 0.5, 0.5);\n    \n    return sum;\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 38
                    }
                ],
                "type": "sound"
            },
            {
                "code": "/// BUFFER C -- SOFT SHADOW PASS + NEBULA BG\n\n#define RES_X 114.0\n#define RES_Y 64.0\n#define FAR_CLIP 8000.0\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n\nconst float NORMAL_FOV = 80. * 3.14159 / 180.;\n\n// Generic storage template\n// library courtesy of @P_Malin\n\n// Store  addresses and offsets to read data in pixel space\n// e.g.\n\nvec2 addrSceneObjs = vec2 ( 0.0, 0.0 );\nvec2 offsetSOPos       = vec2(0.0, 0.0);\nvec2 offsetSOAttr      = vec2(1.0, 0.0);\nvec2 sizeSceneObj = vec2 ( 2.0, 0.0);\n\nvec2 addrCamera = vec2( 0.0, 1.0 );\nvec2 offsetCameraPos = vec2( 0.0, 0.0 );\nvec2 offsetCameraDir = vec2( 1.0, 0.0 );\nvec2 offsetCameraUp = vec2(  2.0, 0.0);\nvec2 offsetCameraVel = vec2( 3.0, 0.0 );\n\nvec2 addrPrevCamera = vec2( 0.0, 2.0 );\n\nvec2 addrGameState = vec2(0.0, 3.0);\n\n#define MAX_SCENEOBJS 1\n\n// CONSTANTS\nfloat PI = acos(-1.0);\n\n/////////////////////////\n// Storage\n\nvec4 LoadVec4( in vec2 vAddr )\n{\n    vec2 vUV = (vAddr + 0.5) / iChannelResolution[0].xy;\n    return texture( iChannel0, vUV, -100.0 );\n}\n\nvec3 LoadVec3( in vec2 vAddr )\n{\n    return LoadVec4( vAddr ).xyz;\n}\n\nfloat IsInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\n\n\n/////////\n// CAMERA\nstruct Camera\n{\n    vec3 vPos;\n    vec3 vDir;\n    vec3 vUp;\n    vec3 vVel;\n};\n\nvoid CameraLoadState( out Camera cam, in vec2 addr )\n{\n\tcam.vPos = LoadVec3( addr + offsetCameraPos );\n\tcam.vDir = LoadVec3( addr + offsetCameraDir );\n    cam.vUp =  LoadVec3( addr + offsetCameraUp );\n    cam.vVel = LoadVec3( addr + offsetCameraVel );\n}\n\nCamera cam;\nvec2 atmoRes;\n\n////////////\n// SCENE STATE\n\nfloat gtime;\nfloat time_scale;\n\nvoid GameLoadState()\n{\n    vec3 state = LoadVec3(addrGameState);\n    \n \tgtime = state.x;\n    time_scale = state.y;\n}\n\n#define STATE_NULL   0.\n#define STATE_ACTIVE 1.\n\nstruct SceneObject\n{\n    vec3 vPos;\n    float vState;\n    float vMaterial;\n    float vDist;\n};\n    \nvoid SceneObjectLoadState( out SceneObject so, int objIndex )\n{\n    vec2 addr = addrSceneObjs + float(objIndex)*sizeSceneObj;\n    \n\tso.vPos = LoadVec3( addr + offsetSOPos );\n    \t\n    vec3 attr = LoadVec3 ( addr + offsetSOAttr );\n    \n    so.vState = attr.x;\n    so.vMaterial = attr.y;\n    so.vDist = attr.z;\n}\n\n\n/////////////////////////\n// Rotation\n\nvec2 Rotate( const in vec2 vPos, const in float t )\n{\n    float s = sin(t);\n    float c = cos(t);\n    \n    return vec2( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y);\n}\n\nvec3 RotX( const in vec3 vPos, float t )\n{\n    vec3 result;\n    result.x = vPos.x;\n  \tresult.yz = Rotate( vPos.yz, t );\n    return result;\n}\n\nvec3 RotY( const in vec3 vPos, float t )\n{\n    vec3 result;\n    result.y = vPos.y;\n  \tresult.xz = Rotate( vPos.xz, t );\n    return result;\n}\n\nvec3 RotZ( const in vec3 vPos, float t )\n{\n    vec3 result;\n    result.z = vPos.z;\n  \tresult.xy = Rotate( vPos.xy, t );\n    return result;\n}\n\n/////////////////////////\n// Quaternions\n\nvec4 QuatMul(const in vec4 lhs, const in vec4 rhs) \n{\n      return vec4( lhs.y*rhs.z - lhs.z*rhs.y + lhs.x*rhs.w + lhs.w*rhs.x,\n                   lhs.z*rhs.x - lhs.x*rhs.z + lhs.y*rhs.w + lhs.w*rhs.y,\n                   lhs.x*rhs.y - lhs.y*rhs.x + lhs.z*rhs.w + lhs.w*rhs.z,\n                   lhs.w*rhs.w - lhs.x*rhs.x - lhs.y*rhs.y - lhs.z*rhs.z);\n}\n\nvec4 QuatFromAxisAngle( vec3 vAxis, float fAngle )\n{\n\treturn vec4( normalize(vAxis) * sin(fAngle), cos(fAngle) );    \n}\n\nvec4 QuatFromVec3( vec3 vRot )\n{\n    float l = length( vRot );\n    if ( l <= 0.0 )\n    {\n        return vec4( 0.0, 0.0, 0.0, 1.0 );\n    }\n    return QuatFromAxisAngle( vRot, l );\n}\n\nmat3 QuatToMat3( const in vec4 q )\n{\n\tvec4 qSq = q * q;\n\tfloat xy2 = q.x * q.y * 2.0;\n\tfloat xz2 = q.x * q.z * 2.0;\n\tfloat yz2 = q.y * q.z * 2.0;\n\tfloat wx2 = q.w * q.x * 2.0;\n\tfloat wy2 = q.w * q.y * 2.0;\n\tfloat wz2 = q.w * q.z * 2.0;\n \n\treturn mat3 (\t\n     qSq.w + qSq.x - qSq.y - qSq.z, xy2 - wz2, xz2 + wy2,\n     xy2 + wz2, qSq.w - qSq.x + qSq.y - qSq.z, yz2 - wx2,\n     xz2 - wy2, yz2 + wx2, qSq.w - qSq.x - qSq.y + qSq.z );\n}\n\nvec3 QuatMul( vec3 v, vec4 q )\n{\n    // TODO Validate vs other quat code\n    vec3 t = 2.0 * cross(q.xyz, v);\n\treturn v + q.w * t + cross(q.xyz, t);\n}\n\nconst float _1=.57735026919;\nvec2 _A=normalize(vec2(2.61803398875, 1));\nvec2 _B=normalize(vec2(1,1.61803398875));\nfloat fSphere(vec3 p,float r){return length(p)-r;}\nfloat fBoxCheap(vec3 p,vec3 b){vec3 q=(abs(p)-b);return max(max(q.x,q.y),q.z);}\nfloat fBox(vec3 p,vec3 b){vec3 q,d=abs(p)-b;q=min(d,0.);return length(max(d,0.))+max(max(q.x,q.y),q.z);}\nfloat fCylinder(vec3 p,float r,float h){return max(length(p.xz)-r,abs(p.y)-h);}\nfloat fCapsule(vec3 p,float r,float c){return mix(length(p.xz)-r,length(vec3(p.x,abs(p.y)-c,p.z))-r,step(c,abs(p.y)));}\nfloat fLineSegment(vec3 p,vec3 a,vec3 b){vec3 c=b-a;float t=clamp(dot(p-a,c)/dot(c,c),0.,1.);return length(c*t+a-p);}\nfloat fCapsule(vec3 p,vec3 a,vec3 b,float r){return fLineSegment(p,a,b)-r;}\nfloat fTorus(vec3 p,float i,float r){return length(vec2(length(p.xz)-r,p.y))-i;}\nfloat fCone(vec3 p,float r,float h){vec2 t,m,q=vec2(length(p.xz),p.y);t=q-vec2(0.,h);m=normalize(vec2(h,r));float j=dot(t,vec2(m.y,-m.x)),d=max(dot(t,m),-q.y);if(q.y>h&&j<0.)d=max(d,length(t));if(q.x>r&&j>length(vec2(h,r)))d=max(d,length(q-vec2(r,0.)));return d;}\nvoid pR(inout vec2 p,float a){p=cos(a)*p+sin(a)*vec2(p.y,-p.x);}\nvoid pR45(inout vec2 p){p=(p+vec2(p.y,-p.x))*sqrt(.5);}\nfloat pMod1(inout float p,float s){float c=floor((p/s)+.5);p=(fract((p/s)+.5)-.5)*s;return c;}\nfloat pModMirror1(inout float p,float s){float c=pMod1(p,s);p*=mod(c,2.)*2.-1.;return c;}\nfloat pModSingle1(inout float p,float s){float c=floor((p/s)+.5);if(p>=0.)p=(fract((p/s)+.5)-.5)*s;return c;}\nfloat pModInterval1(inout float p,float s,float b,float x){float c=pMod1(p,s);if(c>x){p+=s*(c-x);c=x;}if(c<b){p+=s*(c-b);c=b;}return c;}\nfloat pModPolar(inout vec2 p,float t){float g=6.28318530718/t,a=atan(p.y,p.x)+g*.5,r=length(p),c=floor(a/g);a=mod(a,g)-g*.5;p=vec2(cos(a),sin(a))*r;if(abs(c)>=t*.5)c=abs(c);return c;}\nvec2 pMod2(inout vec2 p,vec2 s){vec2 c=floor((p/s)+.5);p=(fract((p/s)+.5)-.5)*s;return c;}\nvec2 pModMirror1(inout vec2 p,vec2 s){vec2 c=pMod2(p,s);p*=mod(c,2.)*2.-1.;return c;}\nvec2 pModGrid2(inout vec2 p,vec2 size){vec2 c=floor((p+size*.5)/size);p=mod(p+size*.5,size)-size*.5;p*=mod(c,2.)*2.-vec2(1);p-=size*.5;if(p.x>p.y)p.xy=p.yx;return floor(c*.5);}\nvec3 pMod3(inout vec3 p,vec3 s){vec3 c=floor((p/s)+.5);p=(fract((p/s)+.5)-.5)*s;return c;}\n\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// A list of usefull distance function to simple primitives, and an example on how to \n// do some interesting boolean operations, repetition and displacement.\n//\n// More info here: https://iquilezles.org/articles/distfunctions\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  return max( length(p.xz)-h.x, abs(p.y)-h.y );\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n\treturn max( max( dot(q,c.xy), p.y), -p.y-c.z );\n}\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n  return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\nfloat sdCappedCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n    vec2 w = v - q;\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n    vec2 d = max(qv,0.0)*qv/vv;\n    return sqrt( dot(w,w) - max(d.x,d.y) )* sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\n//----------------------------------------------------------------------\n\nfloat smin( float a, float b, float k )\n{\n    float h = saturate( 0.5+0.5*(b-a)/k );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\t//return (d1.x<d2.x) ? d1 : d2;\n    float comp = step(d1.x, d2.x);\n    return (comp*d1+(1.0-comp)*d2);\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nSceneObject scene[MAX_SCENEOBJS];\n\n// CREDIT @TDM\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\n// CREDIT @nimitz\n//form iq, see: https://iquilezles.org/articles/morenoise\nmat2 m2 = mat2( 0.80,  0.60, -0.60,  0.80 );\nvec3 noised( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n\tfloat a = texture(iChannel2,(p+vec2(0.5,0.5))/256.0,-100.0).x;\n\tfloat b = texture(iChannel2,(p+vec2(1.5,0.5))/256.0,-100.0).x;\n\tfloat c = texture(iChannel2,(p+vec2(0.5,1.5))/256.0,-100.0).x;\n\tfloat d = texture(iChannel2,(p+vec2(1.5,1.5))/256.0,-100.0).x;\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\nfloat terrain( in vec2 p)\n{\n    float rz = 0.;\n    float z = 1.;\n\tvec2  d = vec2(0.0);\n    float scl = 2.95;\n    float zscl = -.4;\n    float zz = 5.;\n    for( int i=0; i<5; i++ )\n    {\n        vec3 n = noised(p);\n        d += pow(abs(n.yz),vec2(zz));\n        d -= smoothstep(-.5,1.5,n.yz);\n        zz -= 1.;\n        rz += z*n.x/(dot(d,d)+.85);\n        z *= zscl;\n        zscl *= .8;\n        p = m2*p*scl;\n    }\n    \n    rz /= smoothstep(1.5,-.5,rz)+.75;\n    return rz;\n}\n\n\n// Utility for sampling a 2D noise domain to perturb a sphere seamlessly\nconst float mPT = 0.05;\nconst float cornerP = sqrt(0.333333);\n#define CM_SAMPLE(ps) vec3 pS = normalize(ps);vec3 p = abs(pS);sCoord1 = pS.yz;sWeights.x = clamp( (p.x - cornerP) / mPT, 0.0, 1.0);sCoord2 = pS.xz;sWeights.y = clamp( (p.y - cornerP) / mPT, 0.0, 1.0);sCoord3 = pS.xy;sWeights.z = clamp( (p.z - cornerP) / mPT, 0.0, 1.0)\n\n#define MOON_SCALE 3.1\n\nfloat sampleMoon(in vec3 pos)\n{\n    vec2 sCoord1, sCoord2, sCoord3;\n    vec3 sWeights;\n    vec3 samples = vec3(0.0);\n    \n    CM_SAMPLE(pos);\n    \n \tif(sWeights.x > 0.0)\n    {\n    \tsamples.x = terrain(10.*sCoord1);\n    }\n    if(sWeights.y > 0.0)\n    {\n        samples.y = terrain(10.*sCoord2);\n    }\n    if(sWeights.z > 0.0)\n    {\n        samples.z = terrain(10.*sCoord3);\n    }\n    \n    return MOON_SCALE*dot(samples, sWeights);\n}\n\n#define SAND_SCALE 4.0\n\nfloat sampleSand(in vec3 pos)\n{\n    vec2 sCoord1, sCoord2, sCoord3;\n    vec3 sWeights;\n    vec3 samples = vec3(0.0);\n    \n    CM_SAMPLE(pos);\n    \n    if(sWeights.x > 0.0)\n    {\n    \tsamples.x = SAND_SCALE*sea_octave(25.*sCoord1, 1.0);\n    }\n    if(sWeights.y > 0.0)\n    {\n        samples.y = SAND_SCALE*sea_octave(25.*sCoord2, 1.0);\n    }\n    if(sWeights.z > 0.0)\n    {\n        samples.z = SAND_SCALE*sea_octave(25.*sCoord3, 1.0);\n    }\n    \n    return dot(samples, sWeights);\n}\n\nfloat sqrdLength( in vec3 v )\n{\n    return v.x*v.x + v.y*v.y + v.z+v.z;\n}\n\nfloat LOD_Scale( in vec3 objPos, float minDist, float maxDist, float minLOD)\n{\n    float sqrdObjDist = sqrdLength(cam.vPos-objPos);\n    float sqrdMinDist = minDist*minDist;\n    float sqrdMaxDist = maxDist*maxDist;\n    \n    // 1.0 at max dist, 0.0 at min dist\n    float distScale = clamp((sqrdObjDist-sqrdMinDist) / (sqrdMaxDist-sqrdMinDist), 0.0, 1.0);\n \treturn minLOD*distScale-distScale+1.0;\n}\n\n//----------------------------------------------------------------------\n\n\nconst vec3 SS_POS        = vec3(75.0, 625.0, 100.0);\nconst vec3 MOON_POS      = vec3(0.0, 300., 0.);\nconst vec3 SAND_POS      = vec3(0.0, -501., 0.);\nconst vec3 GAS_POS       = vec3(-400.0, 600., 1500.);\nconst float GAS_RADIUS   = 600.0;\nconst float SAND_RADIUS  = 500.0;\nconst float MOON_RADIUS  = 100.0;\n\n#define MAT_BLDG     3.0\n#define MAT_PAD      2.0\n#define MAT_VESSEL   8.0\n#define MAT_SS      40.0\n#define MAT_L_RED   42.0\n#define MAT_L_GREEN 43.0\n#define MAT_GAS     69.0\n#define MAT_MOON    30.0\n#define MAT_RINGS   50.0\n\nvoid mapSpaceStation(in vec3 p, inout vec2 res)\n{\n    res = opU( res, vec2( sdTorus82(p, vec2(14.0, 1.0)), MAT_SS));\n    res = opU( res, vec2( fSphere(p + vec3(1.0, 2.0, 0.0), 0.15), MAT_L_RED));\n    res = opU( res, vec2( fSphere(p + vec3(-1.0, 2.0, 0.0), 0.15), MAT_L_RED));\n    res = opU( res, vec2( fSphere(p + vec3(1.0, -2.0, 0.0), 0.15), MAT_L_GREEN));\n    res = opU( res, vec2( fSphere(p + vec3(-1.0, -2.0, 0.0), 0.15), MAT_L_GREEN));\n    res = opU( res, vec2( opS( udRoundBox(p, vec3(3.0, 1.5, 3.0), 0.5), fBox(p, vec3(0.75, 3.0, 0.75)) ), MAT_SS));\n    res = opU( res, vec2( udRoundBox( RotZ(p -vec3(7.0, 0.0, 0.0), PI/2.0), vec3(0.75, 6.0, 0.75), 0.25 ), MAT_SS));\n    res = opU( res, vec2( udRoundBox( RotZ(p +vec3(7.0, 0.0, 0.0), PI/2.0), vec3(0.75, 6.0, 0.75), 0.25 ), MAT_SS));\n    res = opU( res, vec2( udRoundBox( RotZ(p +vec3(0.0, 0.0, 7.0), PI/2.0), vec3(0.75, 0.75, 6.0), 0.25 ), MAT_SS));\n    res = opU( res, vec2( udRoundBox( RotZ(p -vec3(0.0, 0.0, 7.0), PI/2.0), vec3(0.75, 0.75, 6.0), 0.25 ), MAT_SS));\n}\n\nvoid mapLandingPlatform(in vec3 p, inout vec2 res)\n{\n    // Landing platform\n    res = opU( res, vec2(sdCylinder(p-vec3(0, -3.0, 0.0), vec2(5.0, 1.0) ), MAT_PAD));\n    res = opU( res, vec2(fSphere(p-vec3(-4.9, -2.0, 0.0), 0.15), MAT_L_GREEN));\n    res = opU( res, vec2(fSphere(p-vec3(4.9, -2.0, 0.0), 0.15), MAT_L_GREEN));\n    res = opU( res, vec2(fSphere(p-vec3(0.0, -2.0, 4.9), 0.15), MAT_L_GREEN));\n    res = opU( res, vec2(fSphere(p-vec3(0.0, -2.0, -4.9), 0.15), MAT_L_GREEN));\n     \n    // Landing field buildings\n    vec3 modPos = p;\n    pModPolar(modPos.xz, 7.);\n    modPos -= vec3(10., 0., 0.);\n    res = opU( res, vec2(fBox(modPos-vec3(0, -1., 0.), vec3(1., 5., 1.)), MAT_BLDG));\n}\n\nvec2 map( in vec3 pos )\n{ \n    float lodScale;\n    \n    vec3 objPos = pos-SAND_POS;\n    lodScale = LOD_Scale(SAND_POS, SAND_RADIUS+SAND_RADIUS*0.15, 1.25*SAND_RADIUS, 0.3);\n    vec2 res = vec2( fSphere(objPos, SAND_RADIUS) + lodScale*sampleSand(objPos), 46.9);\n    \n    objPos = pos-MOON_POS;\n    lodScale = LOD_Scale(MOON_POS, MOON_RADIUS+MOON_RADIUS*0.15, 1.5*MOON_RADIUS, 0.25);\n    res = opU( res, vec2(fSphere(objPos, MOON_RADIUS) + lodScale*sampleMoon(objPos), MAT_MOON));\n    \n    objPos = pos-GAS_POS;\n    res = opU( res, vec2(fSphere(objPos, GAS_RADIUS), MAT_GAS));\n    \n    if(atmoRes.y != MAT_RINGS)\n    {\n        // this is a horrible hack and it looks bad. need to fix this.\n    \tres = opU( res, vec2(opS(sdCylinder(RotZ(RotX(objPos, -0.5), 0.2), vec2(GAS_RADIUS+500., 10.0)), sdSphere(objPos, GAS_RADIUS+100.)), MAT_RINGS));\n    }\n    \n    // Space station\n    objPos = RotY(pos-SAND_POS-RotZ(SS_POS, gtime*0.001), gtime*0.05);\n    mapSpaceStation(objPos, res);\n\n    // Load dynamic scene objects, i.e. other ships\n    SceneObject so;\n    vec3 oP;\n    for(int i = 0; i < MAX_SCENEOBJS; ++i)\n    {\n        so = scene[i];\n        if(so.vState == STATE_ACTIVE)\n        {\n            oP = RotX(pos-so.vPos, PI/2.0);\n            res = opU(res, vec2(opS(smin(sdTriPrism(oP, vec2(0.75, 0.08)), fSphere(oP, 0.4), 0.1), sdTriPrism(oP-vec3(0.0, -0.8, 0.0), vec2(0.8, 0.2))), so.vMaterial));\n        }\n    }\n    \n    // Your ship -- need to fix this\n    oP = RotX(pos-cam.vPos+cam.vDir+cam.vUp, PI/2.0);\n    res = opU(res, vec2(opS(sdTriPrism(oP, vec2(0.75, 0.08)), sdTriPrism(oP-vec3(0.0, -0.8, 0.0), vec2(0.8, 0.2))), so.vMaterial));\n   \n    mapLandingPlatform(pos, res);\n    \n    return res;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<30; i++ )\n    {\n\t\tif( t<maxt )\n\t\t{\n        float h = map( ro + rd*t ).x;\n        res = min( res, k*h/t );\n        t += 0.2;\n\t\t}\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec2 mapAtmo( in vec3 pos )\n{\n    vec3 objPos;\n    vec2 res = vec2(FAR_CLIP, -1);\n    \n    if(length(cam.vPos-GAS_POS) > GAS_RADIUS+15.0)\n    {\n    \tobjPos = pos-SAND_POS;\n    \tres = opU(res, vec2( fSphere(objPos, SAND_RADIUS + 15.0), 30.0));\n    }\n    \n    if(length(cam.vPos-SAND_POS) > SAND_RADIUS + 15.0)\n    {\n    \tobjPos = pos-GAS_POS;\n    \tres = opU(res, vec2( fSphere(objPos, GAS_RADIUS + 15.0), 30.0));\n        if(length(cam.vPos-GAS_POS) > GAS_RADIUS+15.0)\n        {\n    \t\tres = opU(res, vec2(opS(sdCylinder(RotZ(RotX(objPos, -0.5), 0.2), vec2(GAS_RADIUS+500., 10.0)), sdSphere(objPos, GAS_RADIUS+100.)), MAT_RINGS));\n        }\n    }\n    return res;\n}\n\n\nvec3 calcAtmoNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    mapAtmo(pos+eps.xyy).x - mapAtmo(pos-eps.xyy).x,\n\t    mapAtmo(pos+eps.yxy).x - mapAtmo(pos-eps.yxy).x,\n\t    mapAtmo(pos+eps.yyx).x - mapAtmo(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\nvec2 castRayAtmo( in vec3 ro, in vec3 rd, in float maxd )\n{\n\tfloat precis = 0.01;\n    float h=precis*2.0;\n    float t = 0.0;\n    float m = -1.0;\n    for( int i=0; i<40; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) break; // continue;\n        t += h;\n\t    vec2 res = mapAtmo( ro+rd*t );\n        h = res.x;\n\t    m = res.y;\n    }\n\n    if( t>maxd ) m=-1.0;\n    return vec2( t, m );\n}\n\nfloat sampleNebula(in vec3 pos)\n{\n    vec3 p = normalize(pos);\n    vec3 a = abs(normalize(pos));\n    vec3 crd;\n    \n    if(a.x > a.y && a.x > a.z) crd= a.yzx;\n    else if(a.y > a.x && a.y > a.z) crd= a.xzy;\n    else crd= a.xyz;\n        \n    return texture(iChannel3, vec2(crd.x/crd.z, crd.y/crd.z)).r + (0.25*cam.vVel.y);\n}\n\n// modified from http://aras-p.info/texts/CompactNormalStorage.html\nvec3 Sph_To_N (in vec2 enc)\n{\n    vec2 ang = enc*2.0-1.0;\n    vec2 scth;\n    \n    scth.x = sin(ang.x*PI);\n    scth.y = cos(ang.x*PI);\n    \n    vec2 scphi = vec2(sqrt(1.0 - ang.y*ang.y), ang.y);\n    \n    return vec3(scth.y*scphi.x, scth.x*scphi.x, scphi.y);\n}\n\n#define MAX_FOG 0.85\n\nvec3 renderShadows( in vec4 gBuffer, in vec3 ro, in vec3 rd )\n{ \n    float sh = 1.0;\n    \n    float t = gBuffer.x;\n    float m = gBuffer.w;\n    \n    vec3 lig = normalize( vec3(-0.6, 0.7, -0.5) );\n    \n    if( m > 0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = Sph_To_N(gBuffer.yz);\n        \n        if(m != MAT_GAS)\n        {\n            bool unlit = false;\n            vec2 uv;\n            \n            if(m == MAT_RINGS || m == MAT_L_RED || m == MAT_L_GREEN)\n            {\n                unlit = true;\n            }\n            \n            if(!unlit)\n            {\n                float dif = saturate( dot( nor, lig ) );\n                if( dif>0.02 ) { sh = softshadow( pos, lig, 0.01, FAR_CLIP, 7.0 ); }\n            }\n        }\n\t}\n \n\treturn vec3( saturate(sh), sampleNebula(rd), 0.0 );\n}\n\nvoid LoadScene(inout vec4 fcol, in vec2 fcoord)\n{\n    CameraLoadState( cam, addrCamera );\n\n    SceneObject so;\n    for(int i = 0; i < MAX_SCENEOBJS; i++)\n    {\n    \tSceneObjectLoadState(so, i);\n        scene[i] = so;\n    }\n    \n    GameLoadState();\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.x < 0. || fragCoord.x >= RES_X || fragCoord.y < 0. || fragCoord.y >= RES_Y)\n    {\n        fragColor = vec4(0., 0., 0., 1.);\n        return;\n    }\n\n    vec4 gBuf = texture(iChannel1, fragCoord/iChannelResolution[1].xy);\n   \n    // Load scene data;\n\tLoadScene(fragColor, fragCoord);\n\n    // Hyperdrive camera\n    float hyperModX = 1.0 - pow(clamp(cam.vVel.y, 0., 0.45), 2.);\n    float hyperModY = 1.0 - pow(clamp(cam.vVel.y, 0., 0.25), 2.);\n    \n    // camera vectors\n    vec2 q = fragCoord.xy/vec2(RES_X, RES_Y);\n    vec2 p = -1.0+2.0*q;\n    p.x *= RES_X/RES_Y;\n\tvec3 cu = normalize( cross(cam.vDir,cam.vUp) );\n\tvec3 cv = normalize( cross(cu,cam.vDir) );\n\tvec3 rd = normalize( p.x*cu*hyperModX + p.y*cv*hyperModY + (NORMAL_FOV*cam.vDir));\n\t\n    vec3 col = renderShadows( gBuf, cam.vPos, rd );\n\n    fragColor=vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/// BUFFER D -- DEFERRED SHADING PASS\n\n#define RES_X 114.0\n#define RES_Y 64.0\n#define FAR_CLIP 8000.0\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n\nconst float NORMAL_FOV = 80. * 3.14159 / 180.;\n\n// Generic storage template\n// library courtesy of @P_Malin\n\n// Store  addresses and offsets to read data in pixel space\n// e.g.\n\nvec2 addrSceneObjs = vec2 ( 0.0, 0.0 );\nvec2 offsetSOPos       = vec2(0.0, 0.0);\nvec2 offsetSOAttr      = vec2(1.0, 0.0);\nvec2 sizeSceneObj = vec2 ( 2.0, 0.0);\n\nvec2 addrCamera = vec2( 0.0, 1.0 );\nvec2 offsetCameraPos = vec2( 0.0, 0.0 );\nvec2 offsetCameraDir = vec2( 1.0, 0.0 );\nvec2 offsetCameraUp = vec2(  2.0, 0.0);\nvec2 offsetCameraVel = vec2( 3.0, 0.0 );\n\nvec2 addrPrevCamera = vec2( 0.0, 2.0 );\n\nvec2 addrGameState = vec2(0.0, 3.0);\n\n#define MAX_SCENEOBJS 1\n\n// CONSTANTS\nfloat PI = acos(-1.0);\n\n/////////////////////////\n// Storage\n\nvec4 LoadVec4( in vec2 vAddr )\n{\n    vec2 vUV = (vAddr + 0.5) / iChannelResolution[0].xy;\n    return texture( iChannel0, vUV, -100.0 );\n}\n\nvec3 LoadVec3( in vec2 vAddr )\n{\n    return LoadVec4( vAddr ).xyz;\n}\n\nfloat IsInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\n\n\n/////////\n// CAMERA\nstruct Camera\n{\n    vec3 vPos;\n    vec3 vDir;\n    vec3 vUp;\n    vec3 vVel;\n};\n\nvoid CameraLoadState( out Camera cam, in vec2 addr )\n{\n\tcam.vPos = LoadVec3( addr + offsetCameraPos );\n\tcam.vDir = LoadVec3( addr + offsetCameraDir );\n    cam.vUp =  LoadVec3( addr + offsetCameraUp );\n    cam.vVel = LoadVec3( addr + offsetCameraVel );\n}\n\nCamera cam;\nvec2 atmoRes;\n\n////////////\n// SCENE STATE\n\nfloat gtime;\nfloat time_scale;\n\nvoid GameLoadState()\n{\n    vec3 state = LoadVec3(addrGameState);\n    \n \tgtime = state.x;\n    time_scale = state.y;\n}\n\n\n#define STATE_NULL   0.\n#define STATE_ACTIVE 1.\n\nstruct SceneObject\n{\n    vec3 vPos;\n    float vState;\n    float vMaterial;\n    float vDist;\n};\n    \nvoid SceneObjectLoadState( out SceneObject so, int objIndex )\n{\n    vec2 addr = addrSceneObjs + float(objIndex)*sizeSceneObj;\n    \n\tso.vPos = LoadVec3( addr + offsetSOPos );\n    \t\n    vec3 attr = LoadVec3 ( addr + offsetSOAttr );\n    \n    so.vState = attr.x;\n    so.vMaterial = attr.y;\n    so.vDist = attr.z;\n}\n\n\n/////////////////////////\n// Rotation\n\nvec2 Rotate( const in vec2 vPos, const in float t )\n{\n    float s = sin(t);\n    float c = cos(t);\n    \n    return vec2( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y);\n}\n\nvec3 RotX( const in vec3 vPos, float t )\n{\n    vec3 result;\n    result.x = vPos.x;\n  \tresult.yz = Rotate( vPos.yz, t );\n    return result;\n}\n\nvec3 RotY( const in vec3 vPos, float t )\n{\n    vec3 result;\n    result.y = vPos.y;\n  \tresult.xz = Rotate( vPos.xz, t );\n    return result;\n}\n\nvec3 RotZ( const in vec3 vPos, float t )\n{\n    vec3 result;\n    result.z = vPos.z;\n  \tresult.xy = Rotate( vPos.xy, t );\n    return result;\n}\n\nconst float _1=.57735026919;\nvec2 _A=normalize(vec2(2.61803398875, 1));\nvec2 _B=normalize(vec2(1,1.61803398875));\nfloat fSphere(vec3 p,float r){return length(p)-r;}\nfloat fBoxCheap(vec3 p,vec3 b){vec3 q=(abs(p)-b);return max(max(q.x,q.y),q.z);}\nfloat fBox(vec3 p,vec3 b){vec3 q,d=abs(p)-b;q=min(d,0.);return length(max(d,0.))+max(max(q.x,q.y),q.z);}\nfloat fCylinder(vec3 p,float r,float h){return max(length(p.xz)-r,abs(p.y)-h);}\nfloat fCapsule(vec3 p,float r,float c){return mix(length(p.xz)-r,length(vec3(p.x,abs(p.y)-c,p.z))-r,step(c,abs(p.y)));}\nfloat fLineSegment(vec3 p,vec3 a,vec3 b){vec3 c=b-a;float t=clamp(dot(p-a,c)/dot(c,c),0.,1.);return length(c*t+a-p);}\nfloat fCapsule(vec3 p,vec3 a,vec3 b,float r){return fLineSegment(p,a,b)-r;}\nfloat fTorus(vec3 p,float i,float r){return length(vec2(length(p.xz)-r,p.y))-i;}\nfloat fCone(vec3 p,float r,float h){vec2 t,m,q=vec2(length(p.xz),p.y);t=q-vec2(0.,h);m=normalize(vec2(h,r));float j=dot(t,vec2(m.y,-m.x)),d=max(dot(t,m),-q.y);if(q.y>h&&j<0.)d=max(d,length(t));if(q.x>r&&j>length(vec2(h,r)))d=max(d,length(q-vec2(r,0.)));return d;}\nvoid pR(inout vec2 p,float a){p=cos(a)*p+sin(a)*vec2(p.y,-p.x);}\nvoid pR45(inout vec2 p){p=(p+vec2(p.y,-p.x))*sqrt(.5);}\nfloat pMod1(inout float p,float s){float c=floor((p/s)+.5);p=(fract((p/s)+.5)-.5)*s;return c;}\nfloat pModMirror1(inout float p,float s){float c=pMod1(p,s);p*=mod(c,2.)*2.-1.;return c;}\nfloat pModSingle1(inout float p,float s){float c=floor((p/s)+.5);if(p>=0.)p=(fract((p/s)+.5)-.5)*s;return c;}\nfloat pModInterval1(inout float p,float s,float b,float x){float c=pMod1(p,s);if(c>x){p+=s*(c-x);c=x;}if(c<b){p+=s*(c-b);c=b;}return c;}\nfloat pModPolar(inout vec2 p,float t){float g=6.28318530718/t,a=atan(p.y,p.x)+g*.5,r=length(p),c=floor(a/g);a=mod(a,g)-g*.5;p=vec2(cos(a),sin(a))*r;if(abs(c)>=t*.5)c=abs(c);return c;}\nvec2 pMod2(inout vec2 p,vec2 s){vec2 c=floor((p/s)+.5);p=(fract((p/s)+.5)-.5)*s;return c;}\nvec2 pModMirror1(inout vec2 p,vec2 s){vec2 c=pMod2(p,s);p*=mod(c,2.)*2.-1.;return c;}\nvec2 pModGrid2(inout vec2 p,vec2 size){vec2 c=floor((p+size*.5)/size);p=mod(p+size*.5,size)-size*.5;p*=mod(c,2.)*2.-vec2(1);p-=size*.5;if(p.x>p.y)p.xy=p.yx;return floor(c*.5);}\nvec3 pMod3(inout vec3 p,vec3 s){vec3 c=floor((p/s)+.5);p=(fract((p/s)+.5)-.5)*s;return c;}\n\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// A list of usefull distance function to simple primitives, and an example on how to \n// do some interesting boolean operations, repetition and displacement.\n//\n// More info here: https://iquilezles.org/articles/distfunctions\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  return max( length(p.xz)-h.x, abs(p.y)-h.y );\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n\treturn max( max( dot(q,c.xy), p.y), -p.y-c.z );\n}\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n  return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\nfloat sdCappedCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n    vec2 w = v - q;\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n    vec2 d = max(qv,0.0)*qv/vv;\n    return sqrt( dot(w,w) - max(d.x,d.y) )* sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\n//----------------------------------------------------------------------\n\nfloat smin( float a, float b, float k )\n{\n    float h = saturate( 0.5+0.5*(b-a)/k );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\t//return (d1.x<d2.x) ? d1 : d2;\n    float comp = step(d1.x, d2.x);\n    return (comp*d1+(1.0-comp)*d2);\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nSceneObject scene[MAX_SCENEOBJS];\n\n// GAS FUNCTIONS\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel3, (uv+ 0.5)/256.0, -100.0 ).yx;\n\treturn -1.0+2.0*mix( rg.x, rg.y, f.z );\n}\n\nfloat map5( in vec3 p , float nScale)\n{\n\tvec3 q = p - vec3(0.0,0.0,0.0);//*gtime*0.01;\n\tfloat f;\n    f  = 0.50000*nScale*noise( q ); q = q*2.02;\n    f += 0.25000*nScale*noise( q ); q = q*2.03;\n    f += 0.12500*nScale*noise( q ); q = q*2.01;\n    f += 0.06250*nScale*noise( q ); q = q*2.02;\n    f += 0.03125*nScale*noise( q );\n\treturn saturate( 1.5 - p.y - 2.0 + 1.75*f );\n}\n\nconst vec3 SS_POS        = vec3(75.0, 625.0, 100.0);\nconst vec3 MOON_POS      = vec3(0.0, 300., 0.);\nconst vec3 SAND_POS      = vec3(0.0, -501., 0.);\nconst vec3 GAS_POS       = vec3(-400.0, 600., 1500.);\nconst float GAS_RADIUS   = 600.0;\nconst float SAND_RADIUS  = 500.0;\nconst float MOON_RADIUS  = 100.0;\n\n#define MAT_BLDG     3.0\n#define MAT_PAD      2.0\n#define MAT_VESSEL   8.0\n#define MAT_SS      40.0\n#define MAT_L_RED   42.0\n#define MAT_L_GREEN 43.0\n#define MAT_GAS     69.0\n#define MAT_MOON    30.0\n#define MAT_RINGS   50.0\n\n// modified from iq's cloud shader\nvec4 integrate( in vec4 sum, in float dif, in float den, in float t)\n{\n    // lighting\n    //vec3 lin = vec3(0.65,0.7,0.75)*1.4 + vec3(1.0, 0.6, 0.3)*dif;    \n    vec3 lin = vec3(0.6, 0.4, 0.3)*dif;\n    //vec4 col = vec4( mix( vec3(1.0,0.95,0.8), vec3(0.25,0.3,0.35), den ), den );\n    vec4 col = vec4( vec3(0.2,0.2,0.6), den );\n    col.xyz *= lin;\n    col.xyz = mix( col.xyz, vec3(0.0), 1.0-exp(-0.003*t*t) );\n    // front to back blending    \n    col.a *= 0.4;\n    col.rgb *= col.a;\n    return sum + col*(1.0-sum.a);\n}\n\nvec4 marchGas(in vec3 ro, in vec3 rd, in vec3 sundir, float maxDist) \n{\n    vec4 sumCol = vec4(0.0);\n    float t = 0.0;\n    \n    for(int i=0; i<30; i++) \n    { \n        t += max(0.5,0.2*t);\n        \n        vec3 pos = ro + t*rd; \n        if( t > maxDist || sumCol.a > 0.99 ) break; \n\n        float den = map5( 0.5*pos,2.0 );\n        den += map5( (pos+vec3(0.1, -60.0, 4.0)), 2.0);\n        den += map5( (pos+vec3(-0.1, -4.0, -0.2)), 2.0);\n        den += map5( (pos+vec3(-0.1, -6.0, -4.2)), 2.0);\n        den += map5( (pos+vec3(-0.1, -10.0, -4.2)), 2.0);\n\n        if( den>0.01 ) \n        { \n            float dif =  saturate((den - map5(0.5*pos+0.1*sundir, 2.0))/0.6); \n            \n            //sumCol.rgb += den*dif*vec3(0.6, 0.7, 0.4);\n            //sumCol.a += den;\n            sumCol = integrate( sumCol, dif, den, t); \n        } \n\n        //t += max(0.5,0.2*t); \n    }\n    \n    return sumCol;\n}\n\nvec2 mapAtmo( in vec3 pos )\n{\n    vec3 objPos;\n    vec2 res = vec2(FAR_CLIP, -1);\n    \n    if(length(cam.vPos-GAS_POS) > GAS_RADIUS+15.0)\n    {\n    \tobjPos = pos-SAND_POS;\n    \tres = opU(res, vec2( fSphere(objPos, SAND_RADIUS + 15.0), 30.0));\n    }\n    \n    if(length(cam.vPos-SAND_POS) > SAND_RADIUS + 15.0)\n    {\n    \tobjPos = pos-GAS_POS;\n    \tres = opU(res, vec2( fSphere(objPos, GAS_RADIUS + 15.0), 30.0));\n        if(length(cam.vPos-GAS_POS) > GAS_RADIUS+15.0)\n        {\n    \t\tres = opU(res, vec2(opS(sdCylinder(RotZ(RotX(objPos, -0.5), 0.2), vec2(GAS_RADIUS+500., 10.0)), sdSphere(objPos, GAS_RADIUS+100.)), MAT_RINGS));\n        }\n    }\n    return res;\n}\n\nvec3 calcAtmoNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    mapAtmo(pos+eps.xyy).x - mapAtmo(pos-eps.xyy).x,\n\t    mapAtmo(pos+eps.yxy).x - mapAtmo(pos-eps.yxy).x,\n\t    mapAtmo(pos+eps.yyx).x - mapAtmo(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\nvec2 castRayAtmo( in vec3 ro, in vec3 rd, in float maxd )\n{\n\tfloat precis = 0.01;\n    float h=precis*2.0;\n    float t = 0.0;\n    float m = -1.0;\n    for( int i=0; i<40; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) break; // continue;\n        t += h;\n\t    vec2 res = mapAtmo( ro+rd*t );\n        h = res.x;\n\t    m = res.y;\n    }\n\n    if( t>maxd ) m=-1.0;\n    return vec2( t, m );\n}\n\n//From Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nvec3 hash33(vec3 p)\n{\n    p = fract(p * vec3(443.8975,397.2973, 491.1871));\n    p += dot(p.zxy, p.yxz+19.27);\n    return fract(vec3(p.x * p.y, p.z*p.x, p.y*p.z));\n}\n\n// Modified from @Nimitz\nvec3 stars(in vec3 p)\n{\n    vec3 c = vec3(0.);\n    float res = 256.*0.8;\n    \n\tfor (float i=0.;i<3.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        vec3 id = floor(p*(.15*res));\n        vec2 rn = hash33(id).xy;\n        float c2 = 1.-smoothstep(0.,.6,length(q));\n        c2 *= step(rn.x,.0005+i*i*0.001);\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.25+0.75);\n        p *= 1.4;\n    }\n    return c*c*.7;\n}\n\n// \"elevated\" sun code plus disc\nvec3 sampleSun(in vec3 look, in vec3 light)\n{\n    float sd = saturate(dot(look,light));\n    vec3 retCol = vec3(0.9, 0.95, 0.8)*step(0.999, sd);\n    retCol += 0.25*vec3(1.0,0.7,0.4)*pow( sd,10.0 );\n    retCol += 0.25*vec3(1.0,0.8,0.6)*pow( sd,64.0 );\n    retCol += 0.2*vec3(1.0,0.8,0.6)*pow( sd,512.0 );\n    \n    return retCol;\n}\n\n// modified from http://aras-p.info/texts/CompactNormalStorage.html\nvec3 Sph_To_N (in vec2 enc)\n{\n    vec2 ang = enc*2.0-1.0;\n    vec2 scth;\n    \n    scth.x = sin(ang.x*PI);\n    scth.y = cos(ang.x*PI);\n    \n    vec2 scphi = vec2(sqrt(1.0 - ang.y*ang.y), ang.y);\n    \n    return vec3(scth.y*scphi.x, scth.x*scphi.x, scphi.y);\n}\n\n// RGB->Intensity\nvec3 RGB_2_III(vec3 p){ return vec3(p.x*0.299 + p.y*0.587 + p.z*0.114); } \n\n#define MAX_FOG 0.85\n\nconst vec3 COLOR_RED = vec3(1.0, 0.0, 0.0);\nconst vec3 COLOR_GREEN = vec3(0.0, 1.0, 0.0);\nconst vec3 COLOR_BLACK = vec3(0.0);\n\nvec3 render( in vec4 gBuffer, in vec3 ro, in vec3 rd, in vec2 sn )\n{ \n    vec3 col = vec3(0.0);\n    atmoRes = castRayAtmo(ro, rd, FAR_CLIP);\n    \n    float t = gBuffer.x;\n    float m = gBuffer.w;\n    \n    float r = sn.y;\n    \n    \n    vec3 lig = normalize( vec3(-0.6, 0.7, -0.5) );\n    bool unlit = false;\n    \n    if( m > 0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = Sph_To_N(gBuffer.yz);\n        \n        // Calculate intervening atmosphere\n        vec4 atmoColor = vec4(0.);\n        \n        if(atmoRes.x < FAR_CLIP)\n        {\n            float dist = abs(atmoRes.x);\n            vec3 baseAtmoColor;\n            \n            if(atmoRes.y == MAT_RINGS)\n            {\n                vec3 tPos = RotZ(RotX((ro+dist*rd)-GAS_POS, -0.5), 0.2);\n                \n                baseAtmoColor = vec3(0.6*abs(sin(0.03*(50.0+length(tPos)))));\n            } else\n            {   \n                baseAtmoColor = vec3(0.6) + 0.4*sin( vec3(0.05,0.08,0.10)*(atmoRes.y-1.0) );\n            }\n            \n        \tvec3 atmoNormal;\n            if(m==MAT_RINGS)\n            {\n               atmoNormal = calcAtmoNormal(ro+rd*dist);\n            } else\n            {\n               atmoNormal = normalize(vec3(1.0));//calcAtmoNormal(ro+rd*dist);\n            }\n                \n            float aT = t - dist;\n            if(atmoRes.x > 0.)\n            {\n                float aDot = saturate(1.0+dot(-rd, atmoNormal));\n                atmoColor = vec4(baseAtmoColor, aDot*aDot*clamp((aT*aT/5000.0), 0., MAX_FOG));\n            } else\n            {\n                aT = max(aT, t);\n                atmoColor = vec4(baseAtmoColor,  clamp((aT*aT/5000.0), 0., MAX_FOG));\n            }\n            \n\t\t\t// Combined half-lambert for fake scattering\n            float rDotL = (dot( atmoNormal, lig )*0.5+0.5)+(dot(rd, lig)*0.5+0.5);\n            float difL = pow(rDotL*0.5, 2.0);\n        \tatmoColor.a = difL*atmoColor.a;\n        }\n        \n        // Calculate material\n        if(m == MAT_GAS)\n        {\n            t = t*step(0.0, t);\n            pos = ro + t*rd;\n            \n            // Nebula field\n        \t//float r = gBuffer.y;//sampleNebula(rd);\n            //vec3 bgCol = (vec3(0., 0., pow(r, 6.))); // no stars\n            vec3 bgCol = vec3(0.0);\n            \n            // Less sun through the gas\n            float sundot = saturate(dot(rd,lig));\n        \tbgCol += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,10.0 );\n\t\t\tbgCol += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n            \n            vec4 gasCol = marchGas( (pos-GAS_POS)/ 50.0, rd, lig, (t+2.0*GAS_RADIUS)); \n            \n            col = (atmoColor.rgb*atmoColor.a) \n                  + (1.0-atmoColor.a)*(gasCol.a*gasCol.rgb \n                  + (1.0-gasCol.a)*bgCol);\n        } else\n        {\n            vec2 uv;\n            float cTr;\n            \n            if(m == MAT_RINGS)\n            {\n                vec3 tPos = RotZ(RotX(pos-GAS_POS, -0.5), 0.2);\n                unlit = true;\n                col += vec3(0.3*abs(sin(0.03*(50.0+length(tPos)))));\n                \n                // Nebula field\n        \t\tcol = (col*col.r) + (1.0-col.r)*vec3(0., 0., pow(r, 6.));\n            } else if(m == MAT_VESSEL)\n            {\n            \tvec3 tPos = pos-scene[0].vPos;\n                \n                uv = sign(mod(tPos.xy, vec2(0.5))-0.25);\n                \n                cTr = step(0.0, uv.y);\n                col += cTr*vec3(0.5, 0.5, 0.0) + (1.0-cTr)*vec3(0.2);\n            } else if(m == MAT_MOON)\n            {\n                col += vec3(0.65, 0.68, 0.7);\n            } else if(m == MAT_BLDG)\n            {\n                uv = fract(pos.xy);\n                \n\t\t\t\tcTr = step(0.5, uv.y);\n\t\t\t\tcol += cTr*vec3(0.2) + (1.0-cTr)*vec3(0.5, 0.5, 0.0);\n            } else if(m == MAT_PAD)\n            {\n                uv = pos.xz;\n                \n                float dist = (uv.x*uv.x + uv.y*uv.y);\n                \n                // (dist > 12.25 && dist < 16.0)\n                cTr = step(12.25, dist)*(1.0-step(16.0, dist));\n                col += cTr*vec3(0.6) + (1.0-cTr)*vec3(0.2);\n            } else if(m == MAT_SS)\n            {\n                vec3 tPos = RotY(pos-SAND_POS-RotZ(SS_POS, gtime*0.001), gtime*0.05);\n                \n                uv = fract(tPos.xz);\n                \n\t\t\t\tcol += (uv.x + uv.y < 1.0) ? vec3(0.3) : (abs(tPos.x) < 1.0 || abs(tPos.z) < 1.0) ? vec3(0.6, 0.5, 0.0) : vec3(0.2);\n            } else if(m== MAT_L_RED)\n            {\n                unlit = true;\n                nor = lig;\n                \n                cTr = step(0.75, mod(gtime, 4.0));\n                col += cTr*COLOR_BLACK + (1.0-cTr)*COLOR_RED;\n            } else if(m == MAT_L_GREEN)\n            {\n                unlit = true;\n                nor = lig;\n                \n                cTr = step(0.75, mod(gtime, 4.0));\n                col += cTr*COLOR_BLACK + (1.0-cTr)*COLOR_GREEN;\n            } else // default shader\n            {\n\t\t\t\tcol += vec3(0.6) + 0.4*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n            }\n            \n            if(!unlit)\n            {\n                // Standard shading (modified from IQ's code)\n                float ao = 0.5;\n\n                float amb = 0.0;\n                float dif = saturate( dot( nor, lig ) );\n                float bac = saturate( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))) )*saturate( 1.0-pos.y );\n\n                float sh = 1.0;\n                if( dif>0.02 ) { sh = sn.x; dif *= sh; }\n\n                vec3 brdf = vec3(0.0);\n                brdf += 0.20*amb*vec3(0.10,0.11,0.13)*ao;\n                brdf += 0.20*bac*vec3(0.15,0.15,0.15)*ao;\n                brdf += 1.20*dif*vec3(1.00,0.90,0.70);\n\n                float pp = saturate( dot( reflect(rd,nor), lig ) );\n                float spe = sh*pow(pp,16.0);\n                float fre = ao*pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n                col = col*brdf + vec3(0.2)*col*spe + 0.025*fre*(0.5+0.5*col);\n            }\n\n            float sundot = saturate(dot(rd,lig));\n            col += 0.3*vec3(1.0,0.8,0.4)*pow( sundot, 8.0 )*(1.0-exp(-0.002*t/250.0));\n        }\n\t\t\n        // Add atmospheric contribution\n        col += step(atmoRes.x, t)*((atmoColor.a*atmoColor.rgb) + (1.0-atmoColor.a)*col);\n\t} else\n    {\n        vec4 atmoCol = vec4(0.0);\n        vec2 atmoRes = castRayAtmo(ro, rd, FAR_CLIP);\n        if(atmoRes.x < FAR_CLIP)\n        {\n            if(atmoRes.y == MAT_RINGS)\n            {\n                vec3 tPos = RotZ(RotX((ro+abs(atmoRes.x)*rd)-GAS_POS, -0.5), 0.2);\n                \n                atmoCol.rgb = vec3(0.5*abs(sin(0.03*(50.0+length(tPos)))));\n            } else\n            {   \n            \tatmoCol.rgb = vec3(0.6) + 0.4*sin( vec3(0.05,0.08,0.10)*(atmoRes.y-1.0) );\n            }\n            \n            vec3 atmoNormal = calcAtmoNormal(ro+rd*abs(atmoRes.x));\n            \n            // Combined half-lambert for fake scattering\n            float rDotL = (dot( atmoNormal, lig )*0.5+0.5)+(dot(rd, lig)*0.5+0.5);\n            float dif = pow(rDotL*0.5, 2.0);\n            \n            float aDot;\n            \n        \tif(atmoRes.x < 0.0)\n            {\n            \tatmoCol.a = dif*MAX_FOG;\n            } else\n            {\n                atmoCol.a = saturate(1.0+dot(-rd, atmoNormal));\n                atmoCol.a = clamp(atmoCol.a*atmoCol.a*dif, 0.0, MAX_FOG);\n            }   \n        }\n        \n        // Nebula field\n        col = (atmoCol.rgb*atmoCol.a) + (1.0-atmoCol.a)*(stars(rd)+vec3(0., 0., pow(r, 6.)));\n        col += sampleSun(rd, lig);\n    }\n\n    // Transition to hyperspace\n    vec3 hCol = (vec3(1.0)-col);\n    hCol = mix(hCol, RGB_2_III(hCol), 0.8);\n    hCol = hCol*hCol;\n    col = mix(col, hCol, pow(saturate(cam.vVel.y), 3.));\n \n\treturn vec3( saturate(col) );\n}\n\nvoid LoadScene(inout vec4 fcol, in vec2 fcoord)\n{\n    CameraLoadState( cam, addrCamera );\n\n    SceneObject so;\n    for(int i = 0; i < MAX_SCENEOBJS; i++)\n    {\n    \tSceneObjectLoadState(so, i);\n        scene[i] = so;\n    }\n    \n    GameLoadState();\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.x < 0. || fragCoord.x >= RES_X || fragCoord.y < 0. || fragCoord.y >= RES_Y)\n    {\n        fragColor = vec4(0., 0., 0., 1.);\n        return;\n    }\n\n    vec4 gBuf = texture(iChannel1, fragCoord/iChannelResolution[1].xy, -100.0);\n    vec2 sh = texture(iChannel2, fragCoord/iChannelResolution[2].xy).rg;\n   \n    // Load scene data;\n\tLoadScene(fragColor, fragCoord);\n\n    // Hyperdrive camera\n    float hyperModX = 1.0 - pow(clamp(cam.vVel.y, 0., 0.45), 2.);\n    float hyperModY = 1.0 - pow(clamp(cam.vVel.y, 0., 0.25), 2.);\n    \n    // camera vectors\n    vec2 q = fragCoord.xy/vec2(RES_X, RES_Y);\n    vec2 p = -1.0+2.0*q;\n    p.x *= RES_X/RES_Y;\n\tvec3 cu = normalize( cross(cam.vDir,cam.vUp) );\n\tvec3 cv = normalize( cross(cu,cam.vDir) );\n\tvec3 rd = normalize( p.x*cu*hyperModX + p.y*cv*hyperModY + (NORMAL_FOV*cam.vDir));\n\t\n    vec3 col = render( gBuf, cam.vPos, rd, sh );\n\n\tcol = sqrt( col );\n\n    fragColor=vec4( col, 1.0 );\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}