{
    "Shader": {
        "info": {
            "date": "1508811016",
            "description": "A demonstration of image inpainting. The pixels masked by the two \"invisible\" objects are approximated using the last seen projection of the floor onto an ideal plane. Demonstrates artifacts arising from uneven ground.",
            "flags": 32,
            "hasliked": 0,
            "id": "XtjcWw",
            "likes": 2,
            "name": "AR Inpainting",
            "published": 3,
            "tags": [
                "3d",
                "shapes",
                "inpainting"
            ],
            "usePreview": 0,
            "username": "ShnitzelKiller",
            "viewed": 717
        },
        "renderpass": [
            {
                "code": "#define FDIST 1.\n\n/*\nThis is a method of deleting objects from a 3D scene by filling predictively.\nSomething similar might be useful in augmented reality, where modifications to the environment\nmight include removing objects while preserving the background somehow.\nHere, the background consists of the bumpy floor.\n\nThe method approximates the floor as a flat plane, and the pieces of background that are\nvisible to the camera are projected onto that plane. Then, the masked regions of the image\nare replaced with that planar approximation with the texture applied. The ground is very\nbumpy to emphasize the weird artifacts that result if the planar approximation is bad.\nBesides, if it worked perfectly there would be nothing to look at.\n\n*/\nvec3 unproject(in vec2 uv, in vec3 cameraPos, in vec3 cameraTarget) {\n    vec3 up = vec3(0, 0, 1);\n    vec3 w = normalize(cameraTarget - cameraPos);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = cross(u, w);\n    vec3 ray = normalize(w * FDIST + (uv.x - iResolution.x/2.) * u / iResolution.x + (uv.y - iResolution.y/2.) * v / iResolution.x);\n    ray = -ray / ray.z * cameraPos.z;\n    return cameraPos + ray;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 cameraPos = vec3(10. * sin(iTime / 2.14), 10. * cos(iTime / 2.14), 10);\n    vec3 pos = unproject(fragCoord, cameraPos, vec3(0, 0, 0));\n    vec2 uv = (pos.xy + vec2(15, 15)) / vec2(30, 30);\n    float blend = clamp(sin(iTime / 3.) +0.7, 0., 1.);\n\n    if (texture(iChannel1, fragCoord/iResolution.xy).x < 0.5) {\n        fragColor = mix(texture(iChannel0, fragCoord/iResolution.xy), texture(iChannel2, uv), blend);\n    } else {\n        \n        fragColor = texture(iChannel2, uv) * max(blend, 0.2) + (1.-blend) * texture(iChannel1, fragCoord/iResolution.xy).yzxw;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//this buffer is for rendering the floor\n\n#define FDIST 1.\n\nfloat floorsdf(vec3 pos) {\n    return pos.z - (sin(pos.x * 5.) + sin(pos.y * 5.)) * 0.1;// * sin(iTime / 10.);\n}\n\nvec4 raycast(in vec3 pos, in vec3 ray) {\n    \n    int i;\n    float currdepth = 0.;\n    for (i=0; i<13;i++) {\n        currdepth += floorsdf(pos + currdepth * ray)/1.5;\n    }\n    vec3 finalPos = pos + currdepth * ray;\n    float col = (mod(finalPos.x * finalPos.y, 5.)-2.5) * mod(finalPos.y, 5.) / 2. + 0.5;\n    float col2 = exp(pow(finalPos.z, 2.) * 20. - 3.);\n    return vec4((vec3(col * 0.5, 0.85-col*2.,0.5-col) + col2 * vec3(1., 1., 1.)) * exp(-length(finalPos.xy)/10.), 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord;\n    vec3 pos = vec3(10. * sin(iTime / 2.14), 10. * cos(iTime / 2.14), 10);\n    vec3 target = vec3(0.);\n    vec3 up = vec3(0, 0, 1);\n    vec3 w = normalize(target - pos);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = cross(u, w);\n    vec3 rd = normalize(w * FDIST + (uv.x - iResolution.x/2.) * u / iResolution.x + (uv.y - iResolution.y/2.) * v / iResolution.x);\n    \n    \n    vec4 col = raycast(pos, rd);\n\t\n    fragColor = vec4(col.xyz, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//this buffer renders the mask\n\n#define FDIST 1.\n#define WEIGHT 10.\nvec4 cubesdf(vec3 pos) {\n    float xp = pos.x - 3.;\n    float xm = 1. - pos.x;\n    float yp = pos.y - 1.;\n    float ym = -1. - pos.y;\n    float zp = pos.z - 4. + 1.*sin(iTime);\n    float zm = 2. -1.*sin(iTime) - pos.z;\n    vec3 norm = vec3(1, 0, 0) * exp(xp*WEIGHT) + vec3(-1, 0, 0) * exp(xm*WEIGHT) + vec3(0, 1, 0) * exp(yp*WEIGHT) + vec3(0, -1, 0) * exp(ym*WEIGHT) + vec3(0, 0, 1) * exp(zp*WEIGHT) + vec3(0, 0, -1) * exp(zm*WEIGHT);\n    float d = max(xp, xm);\n    d = max(d, yp);\n    d = max(d, ym);\n    d = max(d, zp);\n    d = max(d, zm);\n    return vec4(normalize(norm), d);\n}\n\nvec4 spheresdf(vec3 pos) {\n    vec3 center = vec3(-3, 0, 1.5);\n    float d = length(pos - center);\n    vec3 norm = (pos - center) / d;\n    return vec4(norm, d - 1.0);\n}\n\nvec4 totalsdf(vec3 pos) {\n    vec4 ds = spheresdf(pos);\n    vec4 dc = cubesdf(pos);\n    return vec4(normalize(ds.xyz * exp(-ds.w * WEIGHT) + dc.xyz * exp(-dc.w * WEIGHT)), min(ds.w, dc.w));\n}\n\nvec4 raycast(in vec2 uv, in vec3 pos, in vec3 target) {\n    vec3 up = vec3(0, 0, 1);\n    vec3 w = normalize(target - pos);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = cross(u, w);\n    vec3 ray = normalize(w * FDIST + (uv.x - iResolution.x/2.) * u / iResolution.x + (uv.y - iResolution.y/2.) * v / iResolution.x);\n    \n    int i;\n    float currdepth = 0.;\n    for (i=0; i<20;i++) {\n        currdepth += totalsdf(pos + currdepth * ray).w;\n    }\n    vec4 d;\n    if (abs((d = totalsdf(pos + currdepth * ray)).w) < 0.1) {\n        float xnorm = dot(u, d.xyz);\n        float ynorm = dot(v, d.xyz);\n        return vec4(1., xnorm/2.+0.5, ynorm/2.+0.5, 1.);\n    } else {\n        return vec4(0., 0., 0., 1.);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = raycast(fragCoord, vec3(10. * sin(iTime / 2.14), 10. * cos(iTime / 2.14), 10), vec3(0, 0, 0));\n\tfragColor = vec4(col.xyz, 1.0);\n    /*if (fragCoord.y < iResolution.y /2.) {\n        fragColor = vec4(1., 1., 1., 1.);\n    } else {\n        fragColor = vec4(0., 0., 0., 1.);\n    }*/\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//this buffer renders the floor texture\n#define FDIST 1.\n\nvec2 project(in vec3 pos, in vec3 cameraPos, in vec3 cameraTarget) {\n    vec3 up = vec3(0, 0, 1);\n    vec3 w = normalize(cameraTarget - cameraPos);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = cross(u, w);\n    float maxdim = max(iResolution.x, iResolution.y);\n    \n    vec3 ray = pos - cameraPos;\n    ray = ray / dot(ray, w) * FDIST;\n    float x = dot(ray, u) + 0.5;\n    float y = dot(ray, v) * iResolution.x / iResolution.y + 0.5;\n    return vec2(x, y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraPos = vec3(10. * sin(iTime / 2.14), 10. * cos(iTime / 2.14), 10);\n    vec3 pos = vec3(fragCoord / iResolution.xy * vec2(30, 30) - vec2(15, 15), 0);\n    vec2 newCoord = project(pos, cameraPos, vec3(0, 0, 0));\n    if (/*iFrame % 60 != 0 || */newCoord.x < 0. || newCoord.x > 1. || newCoord.y < 0. || newCoord.y > 1. || texture(iChannel1, newCoord).x > 0.5) {\n        fragColor = texture(iChannel2, fragCoord / iResolution.xy);\n    } else {\n    \tvec3 ray = cameraPos - pos;\n        float d = length(ray);\n        ray /= d;\n        float fac = ray.z / d; //cos(theta) / distance\n        vec4 currColor = texture(iChannel2, fragCoord / iResolution.xy);\n        if (currColor.w > fac) {\n            fragColor = currColor;\n        } else {\n            fragColor = vec4(texture(iChannel0, newCoord).xyz + fac*10., fac);\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}