{
    "Shader": {
        "info": {
            "date": "1715605628",
            "description": "Shader optimization kata. Public domain.\nTrying the cut and project method for aperiodic tilings.\nMy favourite is the blue projection from 6 dimensions. Does it have a name?",
            "flags": 0,
            "hasliked": 0,
            "id": "XccXW8",
            "likes": 35,
            "name": "2D patterns 2: aperiodic tilings",
            "published": 3,
            "tags": [
                "tiling",
                "penrose",
                "aperiodic",
                "ammannbeenker",
                "cutandproject"
            ],
            "usePreview": 0,
            "username": "rrrola",
            "viewed": 296
        },
        "renderpass": [
            {
                "code": "// Shader optimization kata. Public domain.\n\n// Trying the cut and project method for aperiodic tilings.\n// Tile substitution is better in practice,\n// but cut-and-project doesn't hardcode the layout\n// and I wanted to understand the math behind it.\n\n// 4D is Ammann–Beenker and 5D is Penrose/Robinson,\n// but my favourite is the blue projection from 6 dimensions.\n// Does it have a name?\n\n// References:\n\n// - \"Pěstujeme lineární algebru\" by Luboš Motl and Miloš Zahradník (in Czech), ch 10.1:\n//   https://matematika.cuni.cz/zahradnik-pla.html\n\n// - \"Ammann-Beenker\" by knighty (to double-check my math):\n//   https://www.shadertoy.com/view/MddfzH\n\n\n// We'll be projecting 2D faces of n-D cubes onto an angled 2D plane.\n// We need to check all possible face orientations (pairs of n-D axes).\n// Normally you would loop over indices (i.e. i=0, j=3),\n// but it's faster to select the axes directly (1,0,0,1).\n// It's also more friendly to GLSL compilers that don't like branches.\n\n// For each tile orientation, four neighboring tiles need to be tested.\n// I think there should be a way to check early\n// which of the four tiles may contain the pixel,\n// but couldn't figure it out (or prove it's impossible).\n\n\n// Functions missing in old GLSL versions (if you need those).\n/*\nfloat Round(float v) { return floor(v + .5); }\nvec2 Round(vec2 v)   { return floor(v + .5); }\nvec3 Round(vec3 v)   { return floor(v + .5); }\nvec4 Round(vec4 v)   { return floor(v + .5); }\nmat2 Inverse(mat2 m) {\n  float a = m[0].x, b = m[1].x,\n        c = m[0].y, d = m[1].y;\n  return mat2(d,-c, -b,a) / (a*d - b*c);\n}\n*/\n\nfloat lw = .04;  // line width\nfloat aa = 1.;  // antialiasing width (depends on resolution and zoom)\n\n// Rotate by d degrees. \nmat2 rot(float d) {\n  return mat2(cos(radians(d + vec4(0,-90,90,0))));\n}\n\n// A 5D|6D vector will be represented by a vec4 with an extra float|vec2.\n// Kinda wordy, but faster than a struct.\nfloat Dot(float a0,vec4 a, float b0,vec4 b) { return a0*b0 + dot(a,b); }\nfloat Dot(vec2 a0,vec4 a, vec2 b0,vec4 b) { return dot(a0,b0) + dot(a,b); }\n\n// We'll be projecting onto this 2D plane laid out in n-D space.\n// Its dual vectors are arranged in a regular 2n-gon:\n//   U = (1, cos(α), cos(2α) ... cos((n–1)α)),\n//   V = (0, sin(α), sin(2α) ... sin((n–1)α)),\n// where α = 360° / 2n.\n// The original n-D cubes are axis-aligned,\n// so their edges will be projected into the dual directions.\n\nconst float M4 = sqrt(2./4.);  // normalisation factor\nconst vec4 U4 = M4 * cos(radians(360./8.) * vec4(0,1,2,3));\nconst vec4 V4 = M4 * sin(radians(360./8.) * vec4(0,1,2,3));\n\nconst float M5 = sqrt(2./5.);\nconst float U50 = M5;\nconst vec4 U5   = M5 * cos(radians(360./10.) * vec4(1,2,3,4));\nconst float V50 = 0.;\nconst vec4 V5   = M5 * sin(radians(360./10.) * vec4(1,2,3,4));\n\nconst float M6 = sqrt(2./6.);\nconst vec2 U60 = M6 * cos(radians(360./12.) * vec2(0,1));\nconst vec4 U6  = M6 * cos(radians(360./12.) * vec4(2,3,4,5));\nconst vec2 V60 = M6 * sin(radians(360./12.) * vec2(0,1));\nconst vec4 V6  = M6 * sin(radians(360./12.) * vec4(2,3,4,5));\n\n\n// Project a point onto the 2D plane.\nvec2 proj(vec4 p) { return vec2(dot(p,U4), dot(p,V4)); }\nvec2 proj(float p0,vec4 p) { return vec2(Dot(p0,p,U50,U5), Dot(p0,p,V50,V5)); }\nvec2 proj(vec2 p0,vec4 p) { return vec2(Dot(p0,p,U60,U6), Dot(p0,p,V60,V6)); }\n\n\n//// 4D: Ammann–Beenker tiling\n\n// Test if a point 'p' lies in a tile.\n// Return the barycentric distance to the closest edge, or zero if it's outside.\n//   The vectors 'a' and 'b' are the tile orientation (each picks an n-D axis),\n//   the offset 's' selects one of the four neighbors with the same orientation\n//   and 'm' converts barycentric (AB) <-> projected (UV) coodinates.\nfloat tile4(vec4 p, mat2 m, vec2 s, vec4 a, vec4 b) {\n  // on the a,b axes we're exactly in the center of a cube (0.5)\n  // on the other axes, unproject the center point back to n-D space\n  vec2 q = s * m;\n  // round to find out in which n-D cube we are\n  // subtract from p to get position in cube: p[...] = -0.5..0.5\n  p -= (vec4(1)-a-b) * round(q.x*U4 + q.y*V4);\n  // project to UV, get barycentric distance to both edges (inside = positive)\n  vec2 f = .5 - abs(m * proj(p) - s);\n  return max(0., min(f.x, f.y));  // pick the closest one, zero outside\n}\n\n// Test if a point lies in the four neighboring tiles with the same 2D orientation.\n// Return the color multiplier (bright in the center, dark antialiased edges).\n//   The vectors 'a' and 'b' are the tile orientation (each picks an n-D axis).\nfloat t4(vec4 p, vec4 a, vec4 b) {\n  mat2 m = inverse(mat2(proj(a), proj(b)));  // barycentric (AB) <-> projected (UV)\n  vec2 r = round(vec2(dot(p,a), dot(p,b)));  // closest vertex on the (a,b) plane\n  vec2 s = vec2(.5, -.5);\n  float d = tile4(p,m,r+s.xx,a,b) +\n            tile4(p,m,r+s.xy,a,b) +\n            tile4(p,m,r+s.yx,a,b) +\n            tile4(p,m,r+s.yy,a,b);  // test four squares around the closest vertex\n\n  // highlight tile center\n  return d +\n    // tile edges: make them all the same width\n    smoothstep(lw-aa, lw+aa,\n      min(d / length(vec2(m[0].x, m[1].x)),\n          d / length(vec2(m[0].y, m[1].y))));\n}\n\n// Return the color of the 4D tiling.\nvec3 dim4(vec2 x) {\n  // rotate 22.5 degrees to make stars upright\n  mat2 R = rot(22.5);\n  float zoom = 5.;\n  vec2 screen = R * zoom * x;\n  aa = 1.5*zoom/iResolution.y;\n\n  // move upwards (= away from the center)\n  vec4 p = screen.x*U4 + screen.y*V4 - iTime*(R[1].x*U4 + R[1].y*V4);\n\n  vec2 u = vec2(0,1);\n  vec3 edge = vec3(.1,.06,.03);\n  vec3 c = edge;\n  \n  // try all 6 face orientations\n  c += (vec3(.9,.5,.1) - edge) * t4(p,u.yxxx,u.xyxx);\n  c += (vec3(.8,.3, 0) - edge) * t4(p,u.yxxx,u.xxyx);\n  c += (vec3(.6,.12,0) - edge) * t4(p,u.yxxx,u.xxxy);\n  c += (vec3(.4,.2,.1) - edge) * t4(p,u.xyxx,u.xxyx);\n  c += (vec3(.7,.4,.2) - edge) * t4(p,u.xyxx,u.xxxy);\n  c += (vec3(.6,.3,.1) - edge) * t4(p,u.xxyx,u.xxxy);\n  return c;\n}\n\n\n//// 5D: Penrose / Robinson tiling\n\nfloat tile5(float p0,vec4 p, mat2 m, vec2 s, float a0,vec4 a, float b0,vec4 b) {\n  vec2 q = s * m;\n  p0 -=    (1.-a0-b0) * round(q.x*U50 + q.y*V50);\n  p  -= (vec4(1)-a-b) * round(q.x*U5  + q.y*V5);\n  vec2 f = abs(m * proj(p0,p) - s);\n  return max(0., .5 - max(f.x, f.y));\n}\n\nfloat t5(float p0,vec4 p, float a0,vec4 a, float b0,vec4 b) {\n  mat2 m = inverse(mat2(proj(a0,a), proj(b0,b)));\n  vec2 r = round(vec2(Dot(p0,p,a0,a), Dot(p0,p,b0,b)));\n  vec2 s = vec2(.5, -.5);\n  float d = tile5(p0,p,m,r+s.xx,a0,a,b0,b) +\n            tile5(p0,p,m,r+s.xy,a0,a,b0,b) +\n            tile5(p0,p,m,r+s.yx,a0,a,b0,b) +\n            tile5(p0,p,m,r+s.yy,a0,a,b0,b);\n  return d + smoothstep(lw-aa, lw+aa,\n    min(d / length(vec2(m[0].x, m[1].x)),\n        d / length(vec2(m[0].y, m[1].y))));\n}\n\nvec3 dim5(vec2 x) {\n  mat2 R = rot(18. + 30.);\n  float zoom = 5.;\n  vec2 screen = R * zoom * x;\n  aa = 1.5*zoom/iResolution.y;\n  R = rot(-120.) * R;\n\n  float p0 = screen.x*U50 + screen.y*V50 - iTime*(R[1].x*U50 + R[1].y*V50);\n  vec4 p = screen.x*U5 + screen.y*V5 - iTime*(R[1].x*U5 + R[1].y*V5);\n\n  vec2 u = vec2(0,1);\n  vec3 edge = vec3(.04,.1,.04);\n  vec3 c = edge;\n  \n  // try all 10 face orientations\n  c += (vec3(.4,.9,.4) - edge) * t5(p0,p,u.y,u.xxxx,u.x,u.yxxx);\n  c += (vec3(.6,.7,.2) - edge) * t5(p0,p,u.y,u.xxxx,u.x,u.xyxx);\n  c += (vec3(.3,.5, 0) - edge) * t5(p0,p,u.y,u.xxxx,u.x,u.xxyx);\n  c += (vec3(.2,.3, 0) - edge) * t5(p0,p,u.y,u.xxxx,u.x,u.xxxy);\n  c += (vec3( 0,.3,.2) - edge) * t5(p0,p,u.x,u.yxxx,u.x,u.xyxx);\n  c += (vec3( 0,.5,.4) - edge) * t5(p0,p,u.x,u.yxxx,u.x,u.xxyx);\n  c += (vec3(.2,.7,.6) - edge) * t5(p0,p,u.x,u.yxxx,u.x,u.xxxy);\n  c += (vec3(.3,.6, 0) - edge) * t5(p0,p,u.x,u.xyxx,u.x,u.xxyx);\n  c += (vec3( 0,.4, 0) - edge) * t5(p0,p,u.x,u.xyxx,u.x,u.xxxy);\n  c += (vec3( 0,.6,.3) - edge) * t5(p0,p,u.x,u.xxyx,u.x,u.xxxy);\n  return c;\n}\n\n\n//// 6D\n\nfloat tile6(vec2 p0,vec4 p, mat2 m, vec2 s, vec2 a0,vec4 a, vec2 b0,vec4 b) {\n  vec2 q = s * m;\n  p0 -= (vec2(1)-a0-b0) * round(q.x*U60 + q.y*V60);\n  p  -=   (vec4(1)-a-b) * round(q.x*U6  + q.y*V6);\n  vec2 f = abs(m * proj(p0,p) - s);\n  return max(0., .5 - max(f.x, f.y));\n}\n\nfloat t6(vec2 p0,vec4 p, vec2 a0,vec4 a, vec2 b0,vec4 b) {\n  mat2 m = inverse(mat2(proj(a0,a), proj(b0,b)));\n  vec2 r = round(vec2(Dot(p0,p,a0,a), Dot(p0,p,b0,b)));\n  vec2 s = vec2(.5, -.5);\n  float d = tile6(p0,p,m,r+s.xx,a0,a,b0,b) +\n            tile6(p0,p,m,r+s.xy,a0,a,b0,b) +\n            tile6(p0,p,m,r+s.yx,a0,a,b0,b) +\n            tile6(p0,p,m,r+s.yy,a0,a,b0,b);\n  return d + smoothstep(lw-aa, lw+aa,\n    min(d / length(vec2(m[0].x, m[1].x)),\n        d / length(vec2(m[0].y, m[1].y))));\n}\n\nvec3 dim6(vec2 x) {\n  mat2 R = rot(15.);\n  float zoom = 5.;\n  vec2 screen = R * zoom * x;\n  aa = 1.5*zoom/iResolution.y;\n  R = rot(-240.) * R;\n\n  vec2 p0 = screen.x*U60 + screen.y*V60 - iTime*(R[1].x*U60 + R[1].y*V60);\n  vec4 p = screen.x*U6 + screen.y*V6 - iTime*(R[1].x*U6 + R[1].y*V6);\n\n  vec2 u = vec2(0,1);\n  vec3 edge = vec3(0,.07,.15);\n  vec3 c = edge;\n\n  // try all 15 face orientations\n  c += (vec3(.1,.7, 1) - edge) * t6(p0,p,u.yx,u.xxxx,u.xy,u.xxxx);\n  c += (vec3( 0,.6,.9) - edge) * t6(p0,p,u.yx,u.xxxx,u.xx,u.yxxx);\n  c += (vec3( 0,.4,.7) - edge) * t6(p0,p,u.yx,u.xxxx,u.xx,u.xyxx);\n  c += (vec3( 0,.2,.5) - edge) * t6(p0,p,u.yx,u.xxxx,u.xx,u.xxyx);\n  c += (vec3( 0,.1,.3) - edge) * t6(p0,p,u.yx,u.xxxx,u.xx,u.xxxy);\n  c += (vec3(.1,.45,1) - edge) * t6(p0,p,u.xy,u.xxxx,u.xx,u.yxxx);\n  c += (vec3( 0,.3,.8) - edge) * t6(p0,p,u.xy,u.xxxx,u.xx,u.xyxx);\n  c += (vec3( 0,.2,.6) - edge) * t6(p0,p,u.xy,u.xxxx,u.xx,u.xxyx);\n  c += (vec3( 0,.1,.4) - edge) * t6(p0,p,u.xy,u.xxxx,u.xx,u.xxxy);\n  c += (vec3(.3,.4,.9) - edge) * t6(p0,p,u.xx,u.yxxx,u.xx,u.xyxx);\n  c += (vec3(.2,.2,.6) - edge) * t6(p0,p,u.xx,u.yxxx,u.xx,u.xxyx);\n  c += (vec3(.1,.1,.4) - edge) * t6(p0,p,u.xx,u.yxxx,u.xx,u.xxxy);\n  c += (vec3(.1,.5,.5) - edge) * t6(p0,p,u.xx,u.xyxx,u.xx,u.xxyx);\n  c += (vec3( 0,.6,.7) - edge) * t6(p0,p,u.xx,u.xyxx,u.xx,u.xxxy);\n  c += (vec3( 0,.3,.4) - edge) * t6(p0,p,u.xx,u.xxyx,u.xx,u.xxxy);\n  return c;\n}\n\n\n// Draw all three tilings.\n\nvoid mainImage(out vec4 o, vec2 x) {\n  // y: -1..1, slowly rotate\n  vec2 p = rot(10.*iTime) * ((x+x-iResolution.xy) / iResolution.y);\n\n  // Find out in which triangular segment we are.\n  vec3 hex = vec3(.5, -.5, -.5*sqrt(3.));\n  vec3 q = vec3(p.x, dot(p,hex.xz), dot(p,hex.yz));  // triangular coords\n  vec3 c;   // inner color\n  float d;  // distance from boundary\n  if (q.y<0. && q.z<0.) {\n    c = dim4(p);\n    d = min(-q.y, -q.z);\n  }\n  else if (q.x>0.) {\n    c = dim5(p);\n    d = min(q.x, q.y);\n  }\n  else {\n    c = dim6(p);\n    d = min(-q.x, q.z);\n  }\n\n  c *= 2.5 / (2. + dot(p,p));  // vignette\n  aa = 1.5 / iResolution.y;\n  c = 1. - (1.-c) * smoothstep(.01-aa, .01+aa, d);  // white boundary\n  //c *= smoothstep(.01-aa, .01+aa, d);  // black boundary\n\n  o = vec4(sqrt(c),1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}