{
    "Shader": {
        "info": {
            "date": "1631639657",
            "description": "Based on wachel's [url=https://www.shadertoy.com/view/ltcGDl]desert terrain[/url], inspired by TekF's [url=https://www.shadertoy.com/view/ldfXzS]\"Wet Sand\" terrain[/url].",
            "flags": 0,
            "hasliked": 0,
            "id": "ssGGWw",
            "likes": 14,
            "name": "Wet beach sand",
            "published": 3,
            "tags": [
                "terrain",
                "sand",
                "dune",
                "beach"
            ],
            "usePreview": 0,
            "username": "jarble",
            "viewed": 569
        },
        "renderpass": [
            {
                "code": "//thank for https://www.shadertoy.com/view/MdX3Rr by iq\n\n#define PI 3.14159265359\n\n\n\nfloat noise(in vec2 uv)\n{\n    return sin(uv.x/2.)+cos(uv.y*2.);\n}\n\n\n#define OCTAVES 8\nfloat fbm(in vec2 uv,int octaves)\n{\n    //this function generates the terrain height\n    float value = 0.;\n    float amplitude = 1.;\n    float freq = .5;\n    float n1 = 0.;\n    for (int i = 0; i < octaves; i++)\n    {\n        n1 = (noise(uv * freq-n1)-n1);\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        value = abs(value-(n1) * amplitude);\n        \n        amplitude *= 1./3.;\n        \n        freq *= 2.;\n        \n        uv = uv.yx;\n        value *= .6+.1*noise(uv+n1*value);\n        \n        //value *= .9;\n\n}\n    \n    return value;\n}\n\nfloat fbm(in vec2 uv){\n    return fbm(uv,OCTAVES);\n}\nfloat terrainH( in vec2 p)\n{\n    p.x += iTime/2.;\n    return fbm(p*1.5)*1.5;\n}\n\nfloat softShadow(in vec3 ro, in vec3 rd )\n{\n    // real shadows\t\n    float res = 1.0;\n    float t = 0.1;\n\tfor( int i=0; i<40; i++ )\n\t{\n\t    vec3  p = ro + t*rd;\n        float h = p.y - terrainH( p.xz );\n\t\tres = min( res, 16.0*h/t );\n\t\tt += h;\n\t\tif( res<0.01 ||p.y>(200.0) ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\n\nfloat interesct( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\n{\n    float t = tmin;\n\tfor( int i=0; i<128; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n\t\tfloat h = pos.y - terrainH( pos.xz );\n\t\tif( h<(0.002*t) || t>tmax ) break;\n\t\tt += 0.5*h;\n\t}\n\treturn t;\n}\n\n\nvec3 calcNormal( in vec3 pos, float t )\n{\n    vec2  eps = vec2( 0.002*t, 0.0 );\n    return normalize( vec3( terrainH(pos.xz-eps.xy) - terrainH(pos.xz+eps.xy),\n                            2.0*eps.x,\n                            terrainH(pos.xz-eps.yx) - terrainH(pos.xz+eps.yx) ) );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{   \n    vec3 lightDir = normalize( vec3(-0.8,0.3,-0.3) );\n    vec3 lightColor = vec3(1.0);\n    vec3 sandColor = vec3(0.9,0.70,0.4);\n    vec3 ambientColor = vec3(0.5);\n\n    float tmin = 1.0;\n    float tmax = 30.0;\n    float t = interesct(ro,rd,tmin,tmax);\n\n    vec3 col;\n    if(t>tmax){\n        vec3 sky0 = vec3(0.8,0.7,0.5) * 1.2;\n        vec3 sky1 = vec3(0.4,0.6,0.8) * 1.2;\n        col = mix(sky0,sky1,pow(max(rd.y + 0.15,0.0),0.5));\n        col += vec3(pow(max(dot(rd,lightDir),0.0),50.0));\n    }\n    else{\n        vec3 pos = ro + t*rd;\n        \n        float shadow = softShadow(pos + lightDir *0.01,lightDir);\n        \n        vec3 normal = calcNormal( pos, t );\n        normal = normalize(normal + vec3(sin(pos.x * 100.0 + sin(pos.z * 31.0) + sin(pos.y) * 200.0) * 0.02,0,0));\n        vec3 viewDir = -rd;\n\n        float lambertian = max(dot(lightDir,normal), 0.0);\n\n        float shininess =  20.0;\n        vec3 halfDir = normalize(lightDir + viewDir);\n        float specAngle = max(dot(halfDir, normal), 0.0);\n        float specular1 = pow(specAngle, shininess);\n        float specular2 = pow(specAngle, shininess / 2.0) * noise(pos.xz * 10000.0) * 1.0f;// * pow(texture(iChannel0,pos.xz * 10.0).x,3.0);\n\n        vec3 diff = sandColor * lambertian * lightColor;\n        vec3 spec = (specular1 *0.3 + specular2 * 0.2) * lightColor;\n        vec3 ambient = ambientColor * sandColor;\n        col = shadow * (diff + spec) + ambient;\n\n    }\n    \n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 1./8.;\n    //float yaw = time;//iMouse.x * 0.05;\n    //float pitch = 1.2;//clamp(iMouse.y * 2.0 /iResolution.y,-PI * 0.5,PI * 0.5);\n    \n    float yaw;\n    float pitch;\n    \n    if(iMouse.x == 0.0 && iMouse.y == 0.0){\n    \tyaw = time;\n    \tpitch = 1.2;        \n    }\n    else{\n        yaw = iMouse.x * 0.05;\n    \tpitch = clamp(iMouse.y  * 2.0 /iResolution.y,-PI * 0.5,PI * 0.5);\n    }\n    \n    vec2 p0 = fragCoord.xy / iResolution.xy;\n    p0.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = 1.1*vec3(2.5*sin(0.25*yaw),2.5 * cos(pitch),2.5*cos(0.25*yaw));\n    vec3 ww = normalize(vec3(0.0) - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p0.x*uu + p0.y*vv + 2.5*ww );\n\n    vec3 col = render( vec3(time,1.8,0.0), rd );\n    \n    fragColor = vec4(col,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}