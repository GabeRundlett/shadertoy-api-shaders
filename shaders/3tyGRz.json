{
    "Shader": {
        "info": {
            "date": "1578866256",
            "description": "Based on Takashi Murakami spherical flower balls, with a planetary twist.\nInvolves an elaborate sphere mapping to tile pattern with minimal distortion and analitical (non-SDF-based) ray casting.\n\nMusic : Flower Dance - DJ Okawari\n",
            "flags": 64,
            "hasliked": 0,
            "id": "3tyGRz",
            "likes": 66,
            "name": "Marakami Galaxy",
            "published": 3,
            "tags": [
                "sphere",
                "flower",
                "mapping",
                "tracing",
                "planets"
            ],
            "usePreview": 1,
            "username": "PixelPhil",
            "viewed": 2984
        },
        "renderpass": [
            {
                "code": "// Murakami Galaxy by Philippe Desgranges\n// Email: Philippe.desgranges@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//\n// To follow up on my current obsession with Takashi Murakami (see: Infinite Murakami)\n// I wanted to give a tribute to his spherical flower patterns (put exemple here)\n// but instead of single compositions give it a infinite galaxy scale with a central flower/sun.\n// This idea ended up being quite challenging in many aspects and I learned a lot in the process of\n// bringing it to a reality, especially :\n//\n// Sphere parametrization : The first thing I did was to modify the fower pattern I did for Infinite\n// Murakami to map it onto a sphere. Of course, some pretty bad distortion around the poles due to\n// spherical texture mapping so I had to find a way to compensate for that by reparametrizing polar\n// coordinates. I wrapped my head around the problem for a couple of days (no pun intended) and ended\n// up finding a tiling scheme consising of mappin the sphere with meridian bands with variying number\n// of flowers to compensate for the horizontal stretch and some taper compensation.\n//\n// Fast Ray casting : The approach I first used was a classic SDF ray casting. My SDF was evaluating\n// 27 (3*3*3) adjacent cells (containing zero or one planet each). Empty space had to be traversed with\n// a lot of caution and it was full of hooks and crannies so it ended up being super slow, especially on\n// my laptop (6fps tops). I realized that because my geometry was qhite simple (a bunch of sphere in a grid)\n// I could just traverse the grid using a bresenham-like traching and just evaluate ray/sphere intersection\n// analytically along the way in crossed cells. It gave me 10X speedup which brough me an immense satisfaction.\n// \n// Anti-aliasing was also a challenge and, although the preview looks decent it is much better looking\n// in fullscreen.\n//\n// I think I'll move on from the Murakami theme for my next entries. I'm done for now :D\n//\n\n//#define MSAA // WANING: on some architecture this leads to long compile times\n\n#define MAX_DST 50.0\n#define sat(a) clamp(a,0.0,1.0)\n\nconst float pi = 3.1415926;\nconst float halfPi = pi * 0.5;\nconst float pi2 = pi * 2.0;\n\nconst float quadrant = pi / 6.0;\n\nconst float blackLevel = 0.3; // True black is too aggressive\n\n\n#define S(a,b,t) smoothstep(a,b,t)\n\n// Some hash function 2->1\nfloat N2(vec2 p)\n{\t// Dave Hoskins - https://www.shadertoy.com/view/4djSRW\n    p = mod(p, vec2(500.0));\n\tvec3 p3  = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// A 2d Noise used for the sun rays\nfloat Noise(vec2 uv)\n{\n    vec2 corner = floor(uv);\n\tfloat c00 = N2(corner + vec2(0.0, 0.0));\n\tfloat c01 = N2(corner + vec2(0.0, 1.0));\n\tfloat c11 = N2(corner + vec2(1.0, 1.0));\n\tfloat c10 = N2(corner + vec2(1.0, 0.0));\n    \n    vec2 diff = fract(uv);\n    \n    diff = diff * diff * (vec2(3) - vec2(2) * diff);\n    \n    return mix(mix(c00, c10, diff.x), mix(c01, c11, diff.x), diff.y);\n}\n\n// An ellipse signed distance function by iq\n// https://iquilezles.org/articles/ellipsedist\nfloat sdEllipse( in vec2 z, in vec2 ab )\n{\n    vec2 p = vec2(abs(z));\n    \n    if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l; float m2 = m*m;\n    float n = ab.y*p.y/l; float n2 = n*n;\n    float c = (m2 + n2 - 1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    \n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 closestPoint = vec2( ab.x*co, ab.y*si );\n\t\n    return length(closestPoint - p ) * sign(p.y-closestPoint.y);\n}\n\n\n// rotates pos to align the up vector towards up\nvec2 rotUp(vec2 pos, vec2 up)\n{\n    vec2 left = vec2(-up.y, up.x);\n    return left * pos.x + up * pos.y;\n}\n\n// The mouth is the intersection of two ellipses, I traced them in photoshop to\n// compute the right radii and offsets\nfloat mouthDst(vec2 uv)\n{\n    return max(sdEllipse(uv - vec2(0.0, -0.17), vec2(0.30, 0.2055)),\n               sdEllipse(uv - vec2(0.0,  0.07), vec2(0.14, 0.2055)));\n}\n\n// For the eye, I use simpler circle distance maths in a scales and rotated space\n// as I don't need an accurate distance function to create an outline\nvec4 eye(vec2 uv, vec2 up, vec2 spot1, vec2 spot2, float aa)\n{\n    uv = rotUp(uv, up);\n    uv.x *= 1.5;\n    \n    float len = length(uv);\n    float len2 = length(uv + spot1);// vec2(0.010, 0.025));\n    float len3 = length(uv + spot2);// vec2(-0.005, -0.017));\n    \n    vec4 eye;\n    \n    eye.a = S(0.04 + aa, 0.04 - aa, len);\n    \n    eye.rgb = vec3(S(0.014 + aa, 0.014 - aa, len2) + S(0.02 + aa, 0.02 - aa, len3) + blackLevel);\n    \n    return eye;\n}\n\nconst float cRatio = 1.0 / 255.0;\n\n// I wanted the color palette to be true to the 16 hue rainbow used\n// by Murakami but I didn't manage to reproduce the orange-yellow-green part\n// using simple maths so I defaulted to a palette. Then I realized I couldn't target\n// Webgl < 3.0 (Wich was one of my objectives) with array constructor so I decided\n// to build a function selecting the right color with a dichotomic approch in hope\n// that the compiler will make a decent job of optimizing all those branches.\nvec3 palette(float id)\n{\n\tif (id < 6.0)\n    {\n        //[0 - 5]\n        if (id < 3.0)\n        {   //[0 - 2]\n            if (id < 1.0) return vec3(181.0, 23.0, 118.0) * cRatio;\n            else if (id < 2.0) return vec3(225.0, 27.0, 104.0) * cRatio;\n            else return vec3(230.0, 40.0, 24.0) * cRatio;\n        }\n        else\n        {   //[3 - 5]\n            if (id < 4.0) return vec3(240.0, 110.0, 14.0) * cRatio;\n            else if (id < 5.0) return vec3(253.0, 195.0, 2.0) * cRatio;\n            else return vec3(253.0, 241.0, 121.0) * cRatio;\n        }\n    }\n    else\n    {   //[6 - 11]\n        if (id < 9.0)\n        {   //[6 - 8]\n            if (id < 7.0) return vec3(167.0, 202.0, 56.0) * cRatio;\n            else if (id < 8.0) return  vec3(0.0, 152.0, 69.0) * cRatio;\n            else return vec3(2.0, 170.0, 179.0) * cRatio;\n        }\n        else\n        {   //[9 - 11] The darker color are at the end to be avoided by mod\n            if (id < 10.0) return vec3(25.0, 186.0, 240.0) * cRatio;\n            else if (id < 11.0) return  vec3(0.0, 98.0, 171.0) * cRatio;\n            else return vec3(40.0, 49.0, 118.0) * cRatio;\n        }\n    }\n}\n\n\n// Adapted from BigWIngs\nvec4 N24(vec2 t) {\n    float n = mod(t.x * 458.0 + t.y * 127.3, 100.0);\n\treturn fract(sin(n*vec4(123., 1024., 1456., 264.))*vec4(6547., 345., 8799., 1564.));\n}\n\n// Drawing a Murakami flower from a random seed (how poetic)\nvec4 flower(vec2 uv, vec4 rnd, float scale, float aaScale, float petalAngle, out vec3 col, float eyesAA)\n{\n    \n    float rdScale = 1.0;\n    \n    scale *= rdScale; // The border thickness & AA is scale-independant\n    \n    uv.xy *= rdScale;\n    \n    float aa2 = aaScale * 5.0 / iResolution.x; // increase AA over disatnce and facing ratio\n    \n    float centerDst = length(uv);\n        \n    float edge; // Mask for the outline edge\n    \n    vec4 color = vec4(1.0, 1.0, 1.0, 1.0); // Underlying color\n   \n    \n    float thick = 0.002 * scale;\n    \n    float col1Id = mod((rnd.x + rnd.y) * 345.456, 10.0);\n    col = palette(col1Id); // return the 'main' color of the petals\n \n    \n    if (centerDst < 0.2)\n    {\n        //Face part\n        \n        float thres = 0.2 - thick;\n        \n        // inner part of edge circle surrounding the head\n        edge =  S(thres + aa2, thres - aa2, centerDst);\n        \n        float mouth = mouthDst(uv);\n        \n        // edge of the mouth\n        edge *= S(thick - aa2, thick + aa2, abs(mouth));\n        \n        // face color\n        float faceRnd = fract(rnd.x * 45.0 + rnd.y * 23.45);\n        if (faceRnd < 0.5) \n        {\n            // Flowers with classic yellow / red faces\n        \tcolor.rgb = (mouth < 0.0) ? vec3(1.0, 0.0, 0.0) : vec3(1.0, 1.0, 0.0); \n        }\n        else\n        {\n            // Flowers with white face / random color mouth\n            float colId = mod(faceRnd * 545.456, 11.0);\n            color.rgb = (mouth < 0.0) ? palette(colId) : vec3(1.0); \n        }\n        \n        // Eyes\n        vec4 eyeImg;\n        if (uv.x > 0.0)\n        {\n           eyeImg = eye(uv - vec2(0.075, 0.095), vec2(-0.7, 1.2),\n                       vec2(0.007, 0.025), vec2(-0.004, -0.019), aa2 * eyesAA);\n        }\n        else   \n        {\n           eyeImg = eye(uv - vec2(-0.075, 0.095), vec2(0.7, 1.2),\n                       vec2(0.024, 0.010), vec2(-0.016, -0.009), aa2 * eyesAA);\n        }\n\n        color.rgb = mix(color.rgb, eyeImg.rgb, eyeImg.a);\n        \n    }\n    else\n    {\n        float rot = petalAngle;\n        float angle = fract((atan(uv.x, uv.y) + rot) / pi2);\n    \n        float section = angle * 12.0;\n        float sectionId = floor(section);\n        \n        if (rnd.z < 0.1 && rnd.w < 0.1)\n        {\n           // Rainbow flower\n           color.rgb = palette(sectionId);//mod(sectionId + (rnd.x + rnd.y) * 345.456, 12.0));\n        }\n        else if (rnd.y > 0.05)\n        {\n           \n            //Alternating flower\n            if (mod(sectionId, 2.0) == 0.0)\n            {\n                // Color 1\n                color.rgb = col;\n            }\n            else if (rnd.x > 0.75)\n            {\n                // Color 2\n                float colId = mod((rnd.w + rnd.z) * 545.456, 11.0);\n                color.rgb = palette(colId);\n            }\n            // else, Color2 is white by default\n        }\n\t\t// else, fully white petals\n        \n        if (centerDst < 0.36)\n        {\n            //intermediate part, concentric bars\n            \n            float sectionX = fract(section);\n            float edgeDist = 0.5 - abs(sectionX - 0.5);\n            \n            edgeDist *= centerDst; // Untaper bar space so bars have constant thickness\n            \n            float aa = aaScale * 10.0 / iResolution.x;\n            float bar = thick * 1.7;\n            edge = S(bar - aa, bar + aa, edgeDist);\n\n            // outer part of edge circle surrounding the head\n            float thres = 0.2 + thick;\n            float head = S(thres - aa2, thres + aa2, centerDst);\n            edge *= head;\n        }\n        else\n        {\n            // Petal tips are actually ellipses, they could have been approximated them with\n            // circles but I didn't because I have OCD and I needed the ellipse SDF \n            // for the mouth anyways ;)\n            \n            // Angle to the center of the quadrant\n            float quadAngle = (sectionId + 0.5) * quadrant - rot + pi; \n\n            // Center of the ellipse\n            vec2 petalUp = vec2(-sin(quadAngle), -cos(quadAngle));\n            vec2 petalCenter = petalUp * 0.36;\n\n            // Rotation of the ellipse basis\n            vec2 petalSpace = rotUp(uv - petalCenter, petalUp);\n\n            // Signed distance function of the ellipse\n            float petalDst = sdEllipse(petalSpace, vec2(0.0944, 0.09));\n\n            //border edge and alpha mask\n            float borderIn = S(thick + aa2, thick - aa2, petalDst);\n            float borderOut = S(-thick + aa2, -thick - aa2, petalDst);\n\n            edge = (borderOut);\n            \n            color.a = borderIn;\n        }\n    }\n    \n    color.rgb = mix(vec3(blackLevel), color.rgb,edge);\n    \n    return color;\n}\n\nstruct planet\n{\n    vec3 center;\n    float radius;\n};\n\n// randomizes planet position & radius for a sector\nvoid GetPlanet(vec3 sector, out planet res)\n{\n   \tvec4 rnd = N24(vec2(sector.x + sector.z * 1.35, sector.y));\n    float rad = mix(0.0, 0.4, rnd.x * rnd.w);\n    res.radius = rad;\n    res.center = vec3(rad) + rnd.yzw * vec3(1.0 - 2.0 * rad); // the smaller the planet is, the more off center it can get without crossing border\n}\n\n\nfloat remap(float val, float min, float max)\n{\n    return sat((val - min) / (max - min));\n}\n\n// breaks down a band of UV coordinates on a sphere to a repetition of square-ish cells with minimal distortion\nvec2 ringUv(vec2 latLon, float angle, float centerLat)\n{\n    // latlon : latitude / longitude\n    // angle: horizontal angle covered by one rep of the pattern over the equator / angular height of the band\n    // centerLat : center latitude of the band\n    \n    \n    // Compute y coords by remapping latitude \n    float halfAngle = angle * 0.5;\n    float y = remap(latLon.y, centerLat - halfAngle,  centerLat + halfAngle);\n    \n    float centerRatio = cos(centerLat); // stretch of the horizontal arc of the pattern at the center of the \n   \t\t\t\t\t\t\t\t\t\t// band relative to the equator\n    \n    float centerAngle = angle / centerRatio; // local longitudianl angle to compensate for stretching at the center of the band. \n    \n    float nbSpots = floor(pi2 / centerAngle); // with new angle, how many pattern can we fit in the band?\n    float spotWidth = pi2 / nbSpots;          // and what angle would they cover (including spacing padding)?\n    \n    float cellX = fract(latLon.x / spotWidth); // what would be the u in the current cell then?\n                  \n                  \n    float x = (0.5 - cellX) * (spotWidth / centerAngle); // compensate for taper\n    x *= (cos(latLon.y) / centerRatio) * 0.5 + 0.5;\n    \n    vec2 uvs = vec2(x + 0.5, y);\n    return uvs;\n}\n\n\n// Computes the texture of the planet\nvec3 sphereColor(vec3 worldPos, float nDotV, float dist, float worldAngle)\n{    \n    // which planet are we talnikg about already?\n    // This is done way to much for final rendering, could be optimized out\n    planet p;\n\tvec3 sector = floor(worldPos);\n    GetPlanet(sector, p);\n\n    // Scale AA accourding to disatnce and facing ratio\n   \tfloat aaScale = 4.0 - nDotV * 3.8 + min(4.0, dist * dist * 0.025);\n    \n    // Find local position on the sphere\n    vec3 localPos = worldPos - (sector + p.center);\n    \n    // Random seed that will be used for the two flower layers\n    vec4 rnd = N24(vec2(sector.x, sector.y + sector.z * 23.4));\n    vec4 rnd2 = N24(rnd.xy * 5.0);\n    \n    // compensate for the world Z rotation so planets stay upright\n    localPos = (rotationZ(-worldAngle) * vec4(localPos, 0.0)).xyz;\n    // Planet rotation at random speed\n    localPos = (rotationY(iTime * (rnd.w - 0.5)) * vec4(localPos, 0.0)).xyz;\n   \n    \n    // Compute polar coordinates on the sphere\n    float lon = (atan(localPos.z, localPos.x)) + pi;  // 0.0 - 2 * pi\n    float lat  = (atan(length(localPos.xz), localPos.y)) - halfPi; //-halfPi <-> halfPi\n    \n    // Compute the number of flowers at the equator according to the size of the planet\n    float numAtEquator = floor(3.0 + p.radius * 15.0);\n    float angle = pi2 / numAtEquator; // an the angle they cover ath the equator\n    \n    vec3 col1;\n    vec3 col2;\n    \n    float petalAngle = rnd.w * 45.35 + iTime * 0.1;\n    \n    // Compute on layer of flower by dividing the sphere in horizontal bands of 'angle' height \n    float eq = (floor(lat / angle + 0.5)) * angle;\n    vec2 uvs = ringUv(vec2(lon + eq * rnd.y * 45.0, lat), angle, eq);\n    vec4 flPattern1 = flower((vec2(0.5) - uvs) * 0.95, rnd, 2.0, aaScale, petalAngle, col1, 0.8);\n    \n    \n    // Compute a second layer of flowers with bands offset by half angle\n    float eq2 = (floor(lat / angle) + 0.5) * angle;\n    vec2 uvs2 = ringUv(vec2(lon + eq2 * rnd.x * 33.0, lat), angle, eq2);\n    vec4 flPattern2 = flower((vec2(0.5) - uvs2) * 0.95, rnd2, 2.0, aaScale, petalAngle, col2, 0.8);\n    \n\n    // Compute flower with planar mapping on xz to cover the poles. \n    vec4 flPattern3 = flower(localPos.xz / p.radius, rnd2, 2.0, aaScale, petalAngle, col2, 0.8);\n    \n    float bg = (1.0 - nDotV);\n    vec3 bgCol = rnd2.y > 0.5 ? col1 : col2; // sphere background is the color of one of the layers\n    \n    vec3 col = bgCol; \n    \n    // mix the 3 layers of flowers together\n    col = mix(col, flPattern1.rgb, flPattern1.a);\n    col = mix(col, flPattern2.rgb, flPattern2.a);\n    col = mix(col, flPattern3.rgb, flPattern3.a);\n    \n    // add some bogus colored shading\n    \n    //Front lighting\n    //col *= mix(vec3(1.0), bgCol * 0.3, (bg * bg) * 0.8);\n\n    return col;\n}\n\n\n// Analytical nomral compoutation\n// Much faster and acuurate than SDF in my situation\nvec3 calcNormal( vec3 pos )\n{\n    // computes planet in sector\n    planet p;\n    vec3 sector = floor(pos);\n    GetPlanet(sector, p);\n    \n    // return vector \n    return normalize(pos - (sector + p.center));\n}\n\n\n// Lifted from Rye Terrell at https://gist.github.com/wwwtyro/beecc31d65d1004f5a9d\n// modified to compute coverage\nfloat raySphereIntersect(vec3 r0, vec3 rd, vec3 s0, float sr, out float coverage) {\n    // - r0: ray origin\n    // - rd: normalized ray direction\n    // - s0: sphere center\n    // - sr: sphere radius\n    // - Returns distance from r0 to first intersecion with sphere,\n    //   or MAX_DST if no intersection.\n    float a = dot(rd, rd);\n    vec3 s0_r0 = r0 - s0;\n    float b = 2.0 * dot(rd, s0_r0);\n    float c = dot(s0_r0, s0_r0) - (sr * sr);\n    \n    float inside = b*b - 4.0*a*c;\n    \n    if (inside < 0.0) {\n        return MAX_DST;\n    }\n    \n    float dst = (-b - sqrt((b*b) - 4.0*a*c))/(2.0*a);\n    \n    // This is a fallof around the edge used for AO\n    // chnage the magic value for a smoother border\n    coverage = S(inside, 0.0, 0.65 * sr * dst / iResolution.x);\n    \n    return dst;\n}\n\n// Computes the RGBA of a planet according to intersection result\nvec4 RenderPlanet(vec3 pos, float d, vec3 rayDir, float worldAngle, float coverage)\n{\n\tvec3 n = calcNormal(pos);\n        \n    float nDotV = abs(dot(n, rayDir));\n \n    float fog = sat((MAX_DST - d) * 0.1);\n    \n \n    // compute some rim lighting to kind of blend everything together\n    vec3 burn  = sat(mix(vec3(2.0, 2.0, 1.5), vec3(1.0, 0.4, 0.2), sat((MAX_DST - d) * 0.05) + nDotV) * 0.5);\n    \n    // Compute the flowery 'texture' on the planet\n    vec3 flowers = sphereColor(pos, nDotV, d, worldAngle);\n    \n    \n    // bogus lighting from the sun\n    vec3 lightPos = pos + vec3(-15.0, -20.0, 60.0);\n    float nDotL = sat(dot(n, normalize(lightPos - pos)) * 0.5 + 0.5);\n    flowers *= nDotL * 0.8 + 0.5;\n    \n    // fades the planets at the horizon\n    vec4 col;\n    col.rgb = flowers + burn;\n    \n    \n    col.a = fog * coverage;\n    \n    // Uncomment to debug coverage AA\n    //col.rgb = mix(vec3(0,1,0), col.rgb, coverage);\n    //col.a = fog;\n    \n    return col;\n}\n\n// Blends two colors front to back\nvec4 BlendFTB(vec4 frontPremul, vec4 backRGBA)\n{\n    vec4 res;\n    \n    res.rgb = backRGBA.rgb * (backRGBA.a * (1.0 - frontPremul.a)) + frontPremul.rgb;\n    res.a = 1.0 - ((1.0 - backRGBA.a) * (1.0 - frontPremul.a));\n    \n    return res;\n}\n\n// Finds the intersection of a ray with a planet in a given sector\n// The coverage is an small alpha falllof at the edge for AA\n// thanks iq for the recommendation\nfloat castPlanet(vec3 cell, vec3 pos, vec3 dir, out float coverage)\n{\n\tvec2 pp = cell.xy + cell.xy;\n    if (dot(pp.xy, pp.xy) < 1.5) return MAX_DST; // we leave a 'tunnel' empty along the z axis \n                \n \tplanet p;\n    \n    GetPlanet(cell, p);            \n    if (p.radius < 0.06) return MAX_DST; // cull planets that are too small\n    \n    // ray sphere intersection from the start position\n    \n    return raySphereIntersect(pos, dir,  cell + p.center, p.radius, coverage); \n}\n\n// Traverses the cells grid in a bresenham fashion and test ray/sphere intersection along the way\n// This appoach ended up being much faster than SDF for that 'simple' yet dense geometry\n//\n// Edit: now, this function also performs the accumulation of planet colors according to coverage\n// The colors are coputed with the RenderPlanet function, the ray is stopped when full opacity is\n// reached\nvec4 castRay(vec3 pos, vec3 dir, float maxDst, float worldAngle)\n{\n    // we assume we are traversing space facing Z\n    \n    vec3 dirZ = dir / dir.z; // direction vector that adavance a full cell along Z\n    \n    vec3 cell = floor(pos); // starting cell\n    \n    vec3 start = pos; // saves the start of the ray\n    pos -= fract(pos.z) * dirZ; // pulls back pos on the closes cell boundary behind\n   \n\n    float d = 0.0;\n    float dst;\n    \n    vec2 layers[20];\n    int num = 0;\n\n    float coverage;\n    float opacity = 1.0;\n\n    while (d < MAX_DST)\n    {\n\t\t// Check current cell\n        dst = castPlanet(cell, start, dir, coverage);\n        if (dst < MAX_DST)\n        {\n            // Blends the hit planet behind the previous ones according to coverage\n            //ColorFTB = BlendFTB(ColorFTB, RenderPlanet(start + dst * dir, dst, dir, worldAngle, coverage));\n            layers[num++] = vec2(dst, coverage);\n            opacity *= (1.0 - coverage);\n            if (opacity < 0.01) break;\n        }\n        \n        // Advances a step\n        pos += dirZ;\n        \n        //Compute next cell on y\n        vec3 newCell = floor(pos);\n        \n        bool a = false;\n        bool b = false;\n        float cornerDst = MAX_DST;\n        \n \t\t\n        if (cell.x != newCell.x) // have we crossed a cell diagonally on X ?\n        {\n            vec3 stepCell = vec3(newCell.x, cell.yz);\n\n            dst = castPlanet(stepCell, start, dir, coverage);\n        \tif (dst < cornerDst) cornerDst = dst;\n            a == true;\n        }\n        \n        if (cell.y != newCell.y)  // have we crossed a cell diagonally on Y ?\n        {\n            vec3 stepCell = vec3(cell.x, newCell.y, cell.z);\n\n            dst = castPlanet(stepCell, start, dir, coverage);\n        \tif (dst < cornerDst) cornerDst = dst;\n            b == true;\n        }\n        \n        if (a && b)  // have we crossed a cell diagonally on both X & Y?\n        {\n            vec3 stepCell = vec3(cell.xy, cell.z);\n\n            dst = castPlanet(stepCell, start, dir, coverage);\n        \tif (dst < cornerDst) cornerDst = dst;\n        }\n        \n        if (cornerDst < MAX_DST) // We have hit a planet in a corner intersection\n        {\n            // Blends the hit planet behind the previous ones according to coverage\n            //ColorFTB = BlendFTB(ColorFTB, RenderPlanet(start + cornerDst * dir, cornerDst, dir, worldAngle, coverage));\n            //if (ColorFTB.a > 0.99) return ColorFTB;\n            \n            layers[num++] = vec2(cornerDst, coverage);\n            opacity *= (1.0 - coverage);\n            if (opacity < 0.01) break;\n        }\n        \n        \n       \t// rinse / repeat\n        cell = newCell;\n        d += 1.0;\n    }\n    \n        \n    vec4 ColorFTB = vec4(0.0);\n    \n    for (int i = 0; i < num; i++)\n    {\n        vec2 layer = layers[i];\n        ColorFTB = BlendFTB(ColorFTB, RenderPlanet(start + layer.x * dir, layer.x, dir, worldAngle, layer.y));\n    }\n    \n    return ColorFTB;\n}\n\n\nvec3 render(vec3 camPos, vec3 rayDir, vec2 uv)\n{\n    vec3 col;\n    \n    // rotates the galaxy around the Z axis, \n    // this rotation will be compensated for when computing planet color so they stay upright\n    float worldAngle = iTime * 0.1;\n    rayDir = normalize((rotationZ(worldAngle) * vec4(rayDir, 0.0)).xyz);\n   \n    float coverage;\n    \n    // cast a ray in the planet field\n    vec4 planetCol = castRay(camPos, rayDir, MAX_DST, worldAngle);\n    \n\n    // Compute the central rainbow flower and solar god rays by samplin a 2D noise in polar coordinates\n\tvec3 dummyCol;\n    vec4 fl = flower(uv * 1.5, vec4(0.0, 0.0, 0.0, 0.0), 2.0, 0.5, iTime * 0.1, dummyCol, 2.0);\n   \tcol = fl.rgb;\n    \n    float a = atan(uv.x, uv.y);\n    float cdist = length(uv);\n    vec2 raysUvs = vec2(a * 20.0 + iTime * 0.5, cdist * 5.0 - iTime + a * 3.0);\n    vec3 rays = mix(vec3(2.0, 2.0, 1.5), vec3(1.0, 0.4, 0.2), cdist + Noise(raysUvs) * 0.3);\n \t\n    col = mix(rays, col, fl.a);\n    \n    col = col * (1.0 - planetCol.a) + planetCol.rgb;\n  \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv =(fragCoord - .5 * iResolution.xy) / iResolution.y;\n    uv *= 1.2;\n\n    // compute camera ray\n    vec3 camPos = vec3(0.5, 0.5, iTime * 0.5);\n    vec3 camDir = vec3(0.0, 0.0,  1.0);    \n    vec3 rayDir = camDir + vec3(uv * 0.13, 0.0);\n\n\t//vec3 nrmDir = normalize(rayDir);\n    \n    vec3 res = render(camPos, rayDir, uv).rgb;\n\t\n    #ifdef MSAA\n    if (iResolution.x < 850.0) // Added AA for the thumbnail\n    {\n        vec3 offset = vec3(0.05, 0.12, 0.0)  / iResolution.x;\n         \n        for (int i = 0; i < 4 + min(0,iFrame); i++)\n        {\n            res += render(camPos, rayDir + offset, uv).rgb;\n            offset.xy = vec2(-offset.y, offset.x);\n        }\n        res /= 5.0;\n    }\n    #endif\n\n    // Output to screen\n    fragColor = vec4(res.rgb,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 20815,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/nhan-y-doanh/flower-dance-dj-okawari"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "mat4 rotationX( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(1.0, 0,\t 0,\t0,\n\t\t\t \t0, \t c,\t-s,\t0,\n\t\t\t\t0, \t s,\t c,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat4 rotationY( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4( c, 0,\t s,\t0,\n\t\t\t \t 0,\t1.0, 0,\t0,\n\t\t\t\t-s,\t0,\t c,\t0,\n\t\t\t\t 0, 0,\t 0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(c, -s,\t0,\t0,\n\t\t\t \ts,\tc,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\t0,\t0,\t0,\t1);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}