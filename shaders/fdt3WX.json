{
    "Shader": {
        "info": {
            "date": "1630752072",
            "description": "tribute to https://iquilezles.org/articles/normalsSDF/normalsSDF.htm  ;-)\n( how to compute centered finite differences with only 4 fetches ).",
            "flags": 0,
            "hasliked": 0,
            "id": "fdt3WX",
            "likes": 4,
            "name": "tetrahedron in cube 2",
            "published": 3,
            "tags": [
                "raymarching",
                "short"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 295
        },
        "renderpass": [
            {
                "code": "// variant of https://shadertoy.com/view/7s33Df\n\n#define rot(a)    mat2( cos(a+vec4(0,11,33,0)) )              // rotation                  \n\nvoid mainImage(out vec4 O, vec2 U) {    \n    float t=9.,c,m=t; \n    vec3  R = iResolution,\n          D = normalize(vec3( U+U, -3.5*R.y ) - R ),          // ray direction\n          p = 7./R, q,a,                                      // marching point along ray \n       // M =  iMouse.xyz/R -.5;\n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(20,8,0)/1e2*cos(iTime+vec3(0,11,0));\n     \n    for ( O=vec4(1) ; O.x > 0. && t > .01 ; O-=.01 )\n        q = p,\n        q.yz *= rot( .5-6.*M.y),                              // rotations\n        q.xz *= rot( 2.-6.*M.x),\n        a = abs(q),\n        t = abs( c = max(a.x,max(a.y,a.z)) - 1.)-.01 ,        // cube\n        m = min(m,c),                                         // memo closest to cube\n#define A(x,y,z) dot(q,vec3(x,y,z))/sqrt(3.)\n#define D(x,y,z) min( abs(.9-A(x,y,z))-.15 , 1.3-A(x,y,z) ) \n        t = max(t, min(min(D(1,1,-1),D(1,-1,1)),min(D(-1,1,1),D(-1,-1,-1))) ), // tetrahedron strips\n        p += t*D;                                             // step forward = dist to obj          \n\n    if (t>c) O *= .7;\n    O.b += exp(-20.*m);  // transparent blue cube via ~glow\n}\n\n\n\n\n\n/* // smart AA https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n     // O.r++;                        // uncomment to see where the oversampling occurs\n    }\n} */",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}