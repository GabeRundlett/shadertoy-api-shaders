{
    "Shader": {
        "info": {
            "date": "1649857035",
            "description": "Generating a smooth packed rectangle distance field texture and corresponding position map, then applying it to the walls of a spiral tunnel.",
            "flags": 0,
            "hasliked": 0,
            "id": "slByDW",
            "likes": 47,
            "name": "Packed Rectangle Spiral Tunnel",
            "published": 3,
            "tags": [
                "procedural",
                "tunnel",
                "texture",
                "spiral",
                "rectangle",
                "bump",
                "tessellation",
                "packing",
                "partition",
                "gilbert"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 795
        },
        "renderpass": [
            {
                "code": "/*\n\n    Packed Rectangle Spiral Tunnel\n    ------------------------------\n    \n    There are two ways to code a packed rectangle texture. There is a relatively \n    simple way involving lines on a backbuffer, and an excrutiatingly annoying way \n    that involves rendering each rectangle's distance field. The line version, which \n    you can find a couple of examples of on Shadertoy looks pretty cool in its own \n    right. However, it's not useful for a lot of the things that I'd imagine people \n    would want them for, like individual rectangle coloring, height maps, bump \n    mapping, etc.\n\n\tI wouldn't say randomly packed rectangle textures are easy to code outside a \n    pixelshader environment, but it's a lot easier when you're not restricted by pixel \n    access order, that's for sure. There's also wrapping, linear interpolation, screen \n    size changes, etc, to consider, so you're probably wondering why anyone would bother.\n    \n    The simple answer is, they look cool, plus they're a pretty useful pattern to have\n    in your toolkit. Don't quote me on it, but I think I've heard this particular \n    arrangement referred to as an axis parallel Gilbert tessellation variant. This scene \n    doesn't quite do the pattern justice, but gives the general idea. I'm also hoping it \n    demonstrates that you're not restricted to in-house textures, or distance patterns \n    that you can code in realtime.\n    \n    The packed rectangle texture constuction is all you'll need to understand this, and\n    that's contained in the \"Cube A\" tab. To see the standalone texture, uncomment the\n    DISPLACEMENT_MAP define. Everything else involves simple, but lengthy, applications \n    of well known techniques, like bump mapping, coloring, lighting, etc.\n     \n    Anyway, this is yet another proof of concept, just to show that it's possible. I \n    have a couple of more interesting examples involving this. There are a few defines\n    to play around with in the \"Common\" and \"Image\" tabs for anyone interested. \n     \n\n\n\n\tRelated exmaples:\n    \n\t// Fabrice's worm textures are great if you haven't seen them.\n    // This is one of my favorite ones.\n    maze worms / graffitis 4  - FabriceNeyret2 \n    https://www.shadertoy.com/view/lsjyzw\n    \n    // A cheap trick I came up with ages ago to emulated\n    // random packed rectangle textrues.\n    Asymmetric Blocks - Shane\n    https://www.shadertoy.com/view/Ws3GRs\n    \n    // Another packed texture based on a common subdivision\n    // scheme. This one has rectangle information.\n    Box Divide ID - Shane\n    https://www.shadertoy.com/view/WlsSRs\n\n\n*/\n \n\n// Just the displacement map on its own. Actually, this is a bump mapped\n// version.\n//#define DISPLACEMENT_MAP\n\n// Color scheme - SPECTRUM PASTEL: 0, BROWN: 1, PURPLE: 2.\n#define COLOR 0\n\n// Put a bit of specular sheen on things. I've also raised the tiles\n// to show that there is a distance field involved.\n#define SHINY\n\n// Border demarcation scheme.\n// 0: No edges, 1: Side rails, 2: Squares, 3: Rails and squares. \n#define EDGES 1\n\n\n// Max ray distance.\n#define FAR 7.\n\n// No forced unroll.\n#define ZERO min(0, iFrame)\n\n\n\n// Scene object ID to separate the mesh object from the terrain.\nfloat objID;\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){ \n    \n    n = max(abs(n) - .2, .001); // max(abs(n), 0.001), etc.\n    //n /= dot(n, vec3(.8)); \n    n /= length(n);\n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n// Smooth cube map face 2D texture blend.\nfloat getTex1(samplerCube iCh, vec3 q){\n    \n    // Scaling.\n    vec2 p = q.xy/1.;\n    \n    // Cube map texture coordinate conversion.\n    p *= cubemapRes;\n    vec2 ip = floor(p); p -= ip;\n    vec2 uv = fract((ip + .5)/cubemapRes) - .5;\n    \n    // 2D neighboring texels stored in each of the four texture channels.\n    vec4 p4 = texture(iCh, vec3(.5, uv.y, -uv.x)); \n    \n    // Linearly interpolate.\n    return mix(mix(p4.x, p4.y, p.x), mix(p4.z, p4.w, p.x), p.y);\n\n}\n\nvec2 getUV(vec3 q){\n\n    // Scaling.\n    vec2 p = q.xy/1.;\n    \n    // Cube map texture coordinate conversion.\n    p *= cubemapRes;\n    vec2 ip = floor(p); //p -= ip;\n    vec2 uv = ((ip + .5)/cubemapRes);\n    \n    return uv;\n \n}\n\n\nfloat getDF(vec2 uv, vec4 rect){\n    \n    return max(abs(rect.x) - rect.z/2., abs(rect.y) - rect.w/2.);\n} \n\n/* \n// Smooth cube map face 2D texture blend.\nvec3 hm(vec3 q){\n    \n    // Smooth distance field.\n    float df = getTex1(iChannel2, q);\n    \n    // Rectangle center and dimensions.\n    vec2 uv = getUV(q);\n    vec4 tx = texture(iChannel2, vec3(-.5, fract(uv.yx) - .5)); \n\n    // Cube map wrapping.   \n    tx.zw = convert(tx.zw);\n    // Random color, used for the height.\n    float rnd = hash21(tx.xy + .5);\n    vec3 col = .5 + .45*cos(6.2831*rnd/1. + vec3(0, 1., 2));\n    \n    // Applying height information to the 2D distance field.\n    float sf = 16./1024.;\n    float rDf = df + sf/2.;\n    col = mix(vec3(0), col - rDf*4.*1., 1. - smoothstep(0., sf, rDf));\n    \n    return col;\n}\n*/\n\nmat2 twist(float y){\n   return rot2(y*.8);\n}\n\n// The extruded image.\nfloat map(vec3 p){\n\n    \n    // Twisting the scene along the Y direction.\n    p.xz *= twist(p.y);\n    \n    // The tunnel center... It's not offset, so this is kind of\n    // redundant, but it's usually helpful.\n    vec3 cntr = p;\n    \n    const float ew = 1./14.;\n    float sq = max(abs(cntr.x), abs(cntr.z)) - .5;// + 1.;\n    \n    // Inside of the square tube for the tunnel.\n    float tun = -sq;\n    \n    \n    #if EDGES > 0\n        // Divider.\n        float div = max(abs(sq + ew/2. + ew/8.) - (ew/2.), abs(mod(p.y, 1.) - 1./2.) - ew/2.);\n\n        // Moving the rails to the corners, then moving them in slightly.\n        vec2 q = abs(abs(p.xz) - .5 + ew/2. + ew/8.);\n        float rails = max(q.x, q.y) - (ew/2. - .006); \n        #if EDGES == 1\n        div = rails;//min(div, rails);\n        #elif EDGES >= 3\n        div = min(div, rails);\n        #endif\n    #else\n        float div = 1e5;\n    #endif\n    \n    // Doubling up.\n    //div = abs(div) - ew;\n    \n    // Wall UV direction. \n    vec3 uvw = abs(cntr.x)>abs(cntr.z)*1.? vec3(-1, 1, 1)*cntr.zyx : cntr;\n    \n    /*\n    // Distance field height application.\n    vec3 col = hm(uvw);\n    float val = dot(col, vec3(.299, .587, .114));\n    tun -= val*.02;\n    */\n \n    // Encasing boxes inside the rails: I hacked this together in a hurry, but\n    // it seems to work. It definitely needs a tidy up.\n    const float sc = 14.;\n    float dOffs = ew/8.*2./sc;\n    vec3 offs = vec3(0, .5/sc, 0); // The edge XZ has been moved in by .25/sc.\n    p = abs(mod(p + offs, 1./sc - vec3(dOffs, 0, dOffs)) - (1./sc - vec3(dOffs, 0, dOffs))/2.);\n    float cb = max(max(p.x, p.y), p.z) - .5/sc + .006;\n    div = min(div + .015, max(div, cb));\n \n    // Overall object ID. Either the tunnel or the repeat boxes.\n    objID = tun<div? 0. : 1.;\n    \n    // Just the floor.\n    return min(tun, div);\n \n}\n\n \n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;//max(.5-ro.z/rd.z, 0.)\n    \n    for(int i = min(iFrame, 0); i<128; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        //t += i<32? d*.75 : d; \n        t += d*.75; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p) {\n\t\n    const vec2 e = vec2(.001, 0);\n    \n    //vec3 n = normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n    //map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = ZERO; i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 32; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .15); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 3., occ = 0.;\n    for( int i = ZERO; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        //if(d>1e8) break; // Fake break.\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n    \n}\n\n\n\n// A global value to record the distance from the camera to the hit point. It's used to tone\n// down the height values that are further away, which can sometimes tone down annoying\n// Moire artifacts.\n//float gT;\n\n\n// Surface bump function..\nfloat bumpSurf3D(in vec3 p, in vec3 n){\n    \n     \n    \n    vec3 txP = p;\n    // The objects have been rotated in the distance function,\n    // so the normal needs to match... If I had a dollar for every time\n    // I've forgotten that... :)\n    vec3 txN = n;\n    txP.xz *= twist(txP.y);\n    txN.xz *= rot2(txN.y);\n\n    //vec2 uv = abs(txN.x)>.5? txP.zy : abs(txN.y)>.5? txP.xz : txP.xy;\n    //float faceID = abs(txN.x)>.5? 0. : abs(txN.y)>.5? 1. : 2.;\n    \n    vec3 uvw = abs(txP.x)>abs(txP.z)*1.? vec3(-1, 1, 1)*txP.zyx : txP;\n    \n    float df = getTex1(iChannel2, uvw);\n \n    float sf = 16./cubemapRes.x;\n   \n    #ifdef SHINY\n    float maxVal = max(1. - df/.1, 0.);\n    #else\n    const float maxVal = 1.;\n    #endif\n    float val = mix(0., maxVal, 1. - smoothstep(0., sf, (df + sf*.5)));//tx.x\n    \n    return val;///(1. + gT*gT*.5);\n\n}\n\n\n \n// Standard function-based bump mapping routine: This is the cheaper four tap version. There's\n// a six tap version (samples taken from either side of each axis), but this works well enough.\nvec3 doBumpMap(in vec3 p, in vec3 n, float bumpfactor){\n    \n    // Larger sample distances give a less defined bump, but can sometimes lessen the aliasing.\n    const vec2 e = vec2(1./cubemapRes.x, 0);  \n    \n    // This utter mess is to avoid longer compile times. It's kind of \n    // annoying that the compiler can't figure out that it shouldn't\n    // unroll loops containing large blocks of code.\n    mat4x3 p4 = mat4x3(p, p - e.xyy, p - e.yxy, p - e.yyx);\n    \n    vec4 b4;\n    for(int i = ZERO; i<4; i++){\n        b4[i] = bumpSurf3D(p4[i], n);\n        if(n.x>1e5) break; // Fake break to trick the compiler.\n    }\n    \n    // Gradient vector: vec3(df/dx, df/dy, df/dz);\n    vec3 grad = (b4.yzw - b4.x)/e.x; \n   \n    \n    // Six tap version, for comparisson. No discernible visual difference, in a lot of cases.\n    //vec3 grad = vec3(bumpSurf3D(p - e.xyy) - bumpSurf3D(p + e.xyy),\n    //                 bumpSurf3D(p - e.yxy) - bumpSurf3D(p + e.yxy),\n    //                 bumpSurf3D(p - e.yyx) - bumpSurf3D(p + e.yyx))/e.x*.5;\n    \n  \n    // Adjusting the tangent vector so that it's perpendicular to the normal. It's some kind \n    // of orthogonal space fix using the Gram-Schmidt process, or something to that effect.\n    grad -= n*dot(n, grad);          \n         \n    // Applying the gradient vector to the normal. Larger bump factors make things more bumpy.\n    return normalize(n + grad*bumpfactor);\n\t\n}\n\n\n// IQ's signed distance to a 2D triangle with a few lines\n// taken out to make a wedge... It's a less-than-clever \n// hack, but I'll find a better solution later.\nfloat wedge(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2){\n \n    vec2 e0 = p1 - p0, e1 = p2 - p1, e2 = p0 - p2;\n\n\tvec2 v0 = p - p0, v1 = p - p1, v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0, e0)/dot(e0, e0), 0., 1.);\n\tvec2 pq2 = v2 - e2*clamp( dot(v2, e2)/dot(e2, e2), 0., 1.);\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x);\n    vec2 d =min( vec2(dot(pq0, pq0), s*(v0.x*e0.y - v0.y*e0.x)),\n                       \n                       vec2(dot(pq2, pq2), s*(v2.x*e2.y - v2.y*e2.x)));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n// A quick hacky loading screen routine: I got a bit carried away. For \n// whatever reason, I decided that I wanted something that matched the \n// scene we were leading into... I probably should have stuck to \n// something simpler and more elegant.\nvec3 loadingScreen(vec2 uv, vec3 scBgnd){\n\n    // Cube map face two, which contains the smooth information.\n    //vec4 ldTex = texture(iChannel2, vec3(-.5, uv2.yx));\n    //float df = getTex1(iChannel2, vec3((uv), 0)); //ldTex.x>0.? 0. : 1.\n    //vec3 bgCol = vec3(df);\n\n    // Grid partitioning.\n    vec2 ldSc = vec2(24);\n    float sf = ldSc.x/iResolution.y;\n    vec2 ldP = uv*ldSc;\n    vec2 ldIP = floor(ldP);\n    ldP -= ldIP + .5;\n\n    \n    // Shape samples.\n    float ldSq = max(abs(ldP.x), abs(ldP.y)) - .5;\n    //float ldSq = length(ldP) - .48;\n    vec2 ld = normalize(vec2(-1, -2));\n    float ldSq2 = max(abs(ldP.x - ld.x*.001), abs(ldP.y - ld.y*.001)) - .5;\n    //float ldSq2 = length(ldP - ld.x*.001) - .48;\n    \n    //ldSq = abs(ldSq + .2) - .2;\n    //ldSq2 = abs(ldSq2 + .2) - .2;\n\n    // Bumped highlight value.\n    float b = max(ldSq2 - ldSq, 0.)/.001;\n    \n    \n\n    // Load time factor.\n    float ldTf = float(iFrame)/float(maxFrames);\n\n    if(abs(ldIP.x + .5)>ldSc.x/2.*iResolution.x/iResolution.y - 1.) ldSq = 1e5;\n    //if(abs(ldIP.x + .5)>ldSc.x/2. - 1.) ldSq = 1e5;\n    if(abs(ldIP.y + .5)>ldSc.y/2. - 1.) ldSq = 1e5;\n\n    //if(mod(ldIP.y - (ldSc.y - 1.), ldSc.y*2.)/(ldSc.y*2.)<ldSh) ldSq = 1e5;\n    float x = mod(ldIP.x*2. - (ldSc.x - 1.), ldSc.x*2.);\n    float y = mod(ldIP.y*2. - (ldSc.y - 1.), ldSc.y*2.);\n    float pos = y*ldSc.y + x;\n\n \n    //if(pos/(ldSc.y*ldSc.x*2.)<ldTf) ldSq = 1e5;\n    //if(pos/(ldSc.y*ldSc.x*2.)<-hash21B(ldIP) + ldTf*2.) ldSq = 1e5;\n    if(hash21B(ldIP + .45)<ldTf) ldSq = 1e5;\n    \n\n    vec3 ldSqCol = .5 + .45*cos(6.2831*hash21B(ldIP) + vec3(0, 1, 2));\n    ldSqCol = mix(ldSqCol, vec3(1), .1)*max(1.25 - dot(uv, uv), 0.);\n    \n  \n    // Background texture.\n    vec3 tx = texture(iChannel0, uv*2. + hash21B(ldIP + .35)).xyz; tx *= tx;\n    tx = .8 + tx*.4;\n    \n    vec3 ldCol = scBgnd;\n    //ldCol = mix(ldCol, ldCol*8., 1. - bgCol);\n\n    //ldCol = bgCol;\n    ldCol = mix(ldCol, vec3(0), (1. - smoothstep(0., sf*6., ldSq))*.25);\n    //ldCol = mix(ldCol, ldSqCol*1.5, 1. - smoothstep(0., sf, ldSq));\n    //ldCol = mix(ldCol, vec3(0), 1. - smoothstep(0., sf, ldSq + .075));\n    ldCol = mix(ldCol, ldSqCol*(.8 + b*.5), 1. - smoothstep(0., sf, ldSq + .1));\n    \n    \n    // Texture application.\n    ldCol *= tx;\n        \n\n    // Time arc calculations.\n    float arc = abs(length(uv) - .1) - .03;\n    //arc = abs(arc + .0125) - .0125;\n    // Loading angle.\n    float a = 6.2831*ldTf;\n    vec2[3] v; v[0] = vec2(0), v[1] = vec2(0, 1), v[2] = vec2(sin(a), cos(a));\n\n    // Cutting a wege from the arc. Terrible -- I should be using IQ's arc function. \n    float d = a>0.? wedge(uv, v[0], v[1], v[2]) : 1e5;\n    if(a>3.14159) d = min(-d, -uv.x);\n    arc = max(arc, -d);\n\n    //ldCol = scBgnd;\n \n \n    // Rendering the timing arc overlay.\n    sf /= ldSc.x;\n    vec3 svCol = ldCol;\n    ldCol = mix(ldCol, vec3(0), (1. - smoothstep(0., sf*12., arc))*.5);\n    ldCol = mix(ldCol, vec3(0), (1. - smoothstep(0., sf, arc))*.9);\n    ldCol = mix(ldCol, svCol*.5 + .5, (1. - smoothstep(0., sf, arc + .006)));\n    ldCol = mix(ldCol, ldCol*1.5, (1. - smoothstep(0., sf, arc + .0275)));\n    \n    // Loading screen color.\n    return ldCol;\n\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Aspect correct screen coordinates. Translation and scale is all that\n    // \n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // People get bored very quickly, so it's customary to show a loading\n    // screen during precalculations. You can make it as simple or as\n    // complicated as you want... I honestly don't know what I was going\n    // for when I started coding it, but a rushed ten minutes later there\n    // was a rotating bar sitting over a weird bumped pixel dissolve. At\n    // least it'll keep people amused. :)\n    vec3 scBgnd = vec3(.8, .6, 1)*.03*max(1.25 - dot(uv, uv), 0.);\n    if(iFrame<=maxFrames){\n\n        vec3 ldCol = loadingScreen(uv, scBgnd);\n        \n        fragColor = vec4(sqrt(max(ldCol, 0.)), 1.);\n        \n        return;\n    }\n\t\n    \n\t// Camera Setup.\n    float tm = iTime/2.;\n\tvec3 ro = vec3(.235, tm/1.5, .25); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(.02, .15, 0); // \"Look At\" position.\n    vec3 lp = ro + vec3(0, 1.25, .1);// Put it a bit in front of the camera. \n    #if EDGES > 1\n    lp.xz -= .1;\n    #endif\n    \n    ro.xz *= twist(-(ro.y + 2.*0.));\n    lk.xz *= twist(-(lk.y + 2.*0.));\n \tlp.xz *= twist(-(lk.y + 2.*0.));\n \n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro); // Forward.\n    //if(dot(fwd, vec3(fwd.z, 0, -fwd.x))==0.) fwd = normalize(fwd - vec3(0, 0, .00001));\n    vec3 rgt = normalize(cross(vec3(0, 1, 0), fwd));// Right. \n    // \"right\" and \"forward\" are perpendicular normals, so the result is normalized.\n    vec3 up = cross(fwd, rgt); // Up.\n    \n    // rd - Ray direction.\n    vec3 rd = mat3(rgt, up, fwd)*normalize(vec3(uv, 1./FOV - dot(uv, uv)*.25));\n    // Equivalent to:\n    //vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n \n    // Slight agitation of the camera about the XZ-plane.\n\t//rd.xz *= rot2(-cos(tm/2.)/2.);\n\n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n\n    // Object ID.\n    float svObjID = objID;\n    \n   \n  \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp);\n        \n        \n        if(svObjID<.5) sn = doBumpMap(sp, sn, .02);///(1. + t/FAR*1.)\n        \n          \n        // Obtaining the texel color. \n\t    vec3 texCol;   \n        \n        vec3 txP = sp;\n        vec3 txN = sn;\n\n        txP.xz *= twist(txP.y);\n        txN.xz *= twist(txP.y);\n        vec3 cntr = vec3(txP.xy, txP.z);\n        \n        vec3 tx = tex3D(iChannel0, txP*2., txN);\n        //vec3 tx = texture(iChannel0, txPat.xy).xyz; tx *= tx;\n        // Texture application.\n        tx = .75 + tx*.5;\n    \n\n\n        // The extruded grid.\n        if(svObjID<.5){\n            \n           vec3 uvw = abs(cntr.x)>abs(cntr.z)*1.? vec3(-1, 1, 1)*cntr.zyx : cntr;\n    \n            vec2 uv2 = fract(getUV(uvw)) - .5;\n            // Cube map face one, which contains the rectangle center and\n            // dimension information.\n            vec4 txPat = texture(iChannel2, vec3(-.5, uv2.yx));\n            // Cube map face two, which contains the smooth rectangle distance\n            // field information.\n            vec4 txPat2 = texture(iChannel2, vec3(.5, uv2.y, -uv2.x));\n            \n            // Taking care of cube map wrapping issues... It's one of the annoying\n            // downsides of using cube map faces.\n            txPat.zw = fract((floor(txPat.zw*cubemapRes) + .5)/cubemapRes);\n            vec2 cntr = txPat.zw; // Rectangle center.\n            \n            \n            float rnd = hash21(txPat.zw + .1);\n            float rnd2 = hash21(txPat.zw + .2);\n                \n            // Blinking light variable.    \n            float bl = smoothstep(.9, .95, sin(rnd2*6.2831 + iTime/2.)*.5 + .5);\n        \n            // Rectangle coloring.\n            #if COLOR == 0\n            vec3 tCol = .5 + .45*cos(6.2831*hash21(cntr) + vec3(0, 1, 2));\n            #elif COLOR == 1\n            vec3 tCol = .5 + .45*cos(6.2831*hash21(cntr)/4. + vec3(0, 1, 2)/1.5 + .5);\n            tCol = mix(tCol, tCol.zyx, step(.75, hash21(cntr + .51)));\n            #else\n            vec3 tCol = vec3(.15, .015, 1)*(hash21(cntr + .31) + .5);\n            tCol = mix(tCol, tCol.yxz, hash21(cntr + .51)*.25);\n            tCol = mix(tCol, tCol*4., bl);\n            #endif\n            \n            // Fine tuning then applying the texture.\n            tCol = mix(tCol*2., vec3(1), .25);\n            texCol = tCol*tx;//*(rnd*.8 + .2);//*(rnd*1.95 + .05);//tx*2.\n            \n            //if(svObjID>.5) texCol = mix(texCol, tx*2., .5);\n             \n            vec3 svCol = texCol;\n           \n            // Smooth rectangle distance field value.\n            //float val = bumpSurf3D(sp, sn);\n            float val = getTex1(iChannel2, uvw);\n            \n            // Smoothing factor.\n            float sf = 2./cubemapRes.x;\n            //float df = mix(0., 1., smoothstep(0., sf, (val + sf)));//tx.x\n\n            // Texture coloring overide, just to show it works with those too.\n            //texCol = texture(iChannel1, cntr).xyz; texCol *= texCol*3.;\n\n            texCol = mix(vec3(0), texCol, 1. - smoothstep(0., sf, val + sf));//.25-txPat.x/.1\n\n            /*\n            if(iFrame<maxFrames){\n\n                float df = getTex1(iChannel2, uvw); //ldTex.x>0.? 0. : 1.\n                vec3 bgCol = mix(vec3(.1), vec3(.5), df);\n                texCol = bgCol;\n\n            }\n            */\n            \n\n\n        }\n        else {\n \n             // Repeat cube objects along the rails, partitions, etc.\n            \n            // Repeat calculations. Not pretty, so they'll need a tidy up at some stage.\n            const float sc = 14.;\n            float ew = 1./sc;\n            float dOffs = ew/8.*2./sc;\n            vec3 offs = vec3(.0/sc, .5/sc, .0/sc); // The edge XZ has been moved in by .25/sc.\n            vec3 ip = txP;\n            ip = floor((ip + offs)/(1./sc - vec3(dOffs, 0, dOffs)));\n            txP = abs(mod(txP + offs, 1./sc - vec3(dOffs, 0, dOffs)) - (1./sc - vec3(dOffs, 0, dOffs))/2.);\n            \n            // Cube field.\n            float cb = min(min(max(txP.x, txP.y), max(txP.x, txP.z)), max(txP.y, txP.z));\n            cb -= (.5/sc);\n            \n            // Unique rand IDs for coloring, blinking, etc.\n            float rnd = hash31(ip);\n            float rnd2 = hash31(ip + .7);\n            \n            // Blinking.\n            float bl = smoothstep(.9, .95, sin(rnd2*6.2831 + iTime)*.5 + .5);\n            \n            // ID based colors.\n            #if COLOR == 0\n            vec3 tCol = .5 + .45*cos(6.2831*rnd + vec3(0, 1., 2));\n            #elif COLOR == 1\n            vec3 tCol = .5 + .45*cos(6.2831*rnd/4. + vec3(0, 1, 2)/1.5 + .5);\n            #else\n            vec3 tCol = vec3(.15, .015, 1);\n            tCol = mix(tCol, tCol.yxz, step(.75, hash31(ip + .51)));\n            tCol = mix(tCol, tCol*8., bl);//step(.8, hash21(txPat.xy + .5))\n            #endif\n            \n            // Color refinement and mild texturing.\n            tCol = mix(tCol*1., vec3(1), .25);\n            texCol = tCol*tx*2.;\n            \n            // Applying the colors to the cubes.\n            vec3 svCol = texCol;\n            #if COLOR < 2\n            vec3 cubeCol = tx*2.;\n            #else\n            vec3 cubeCol = tx/6.;\n            #endif\n            //\n            texCol = mix(vec3(0), cubeCol, 1. - smoothstep(0., .001, abs(cb) - .016));\n            texCol = mix(texCol, tCol, 1. - smoothstep(0., .001, (cb + .016 + .007)));\n        }\n       \n    \t\n    \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*lDist*.25);\n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 16.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n        //sh = min(sh + ao*.25, 1.);\n        \n   \n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n      \n        // Half vector.\n        vec3 hv = normalize(rd + ld);\n        // Specular Blinn Phong. The last term is highlight power related.\n        float specBF = pow(max(dot(hv, sn), 0.), 4.);\n        \n        // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(1. - abs(dot(sn, rd))*.5, 0., 1.), 32.);\n \n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Feel free to look up\n        // the \"science,\" but it essentially takes that annoying central shine out. How\n        // much you take out depends on the material, which is controlled by the material\n        // constant.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat freS = mix(.2, 1., Schlick);  //F0 = .2 - Glass... or close enough.        \n        \n \n        // Combining the above terms to procude the final color.\n        col = texCol*(diff*sh + .15);\n         \n        #ifdef SHINY\n        // If shininess is flagged, include the specular term.\n        col += spec*freS*8.*sh/(1. + t*t*.5); \n        #endif\n        \n        // Cube map reflection. When I first learned to code graphics, I loved shiny\n        // stuff and went really overboard with it. I still do, but thanks to maturity, \n        // I've learned to hold back on ocassion. :)\n        // Requires a cube map in \"iChannel3\".\n        //vec3 refCol = texture(iChannel3, reflect(rd, sn)).xyz; refCol *= refCol;\n        //col += col*refCol*sh*1.;\n\n        \n        // Shading.\n        col *= ao*atten;\n        \n        // Greyscale value, just in case people switch to the Britney video, etc.\n        // Stylistically, the example works better with color. The Britney video\n        // looks OK, but I'm more of a Shirley Jones kind of guy. :)\n        #ifdef GRAYSCALE\n        col = vec3(1)*dot(col, vec3(.299, .587, .114));\n        #endif\n        \n        #ifdef MAP_DETAIL\n        // Also used for debugging purposes.\n        col = vec3(crv*(sh*.9 + .1)); // ao, sh, etc.\n        #endif\n          \n\t\n\t}\n    \n    \n    // Applying fog.\n    vec3 fogCol = vec3(0);//mix(vec3(.4, .7, 1.2), vec3(.4, .7, 1.2).yxz, rd.y*.5 + .5)*4.;\n    col = mix(col, fogCol, smoothstep(0., .99, t/FAR));\n    \n\n    // Just the displacement map on its own. Actually, this is a bump mapped\n    // version. The texture map itself is quite mundane, which you can see \n    // if you set \"b2\" to 1.\n    #ifdef DISPLACEMENT_MAP\n \n    \n    // Scaling.\n    vec2 p2 = ((fragCoord)/iResolution.y) + iTime/24.;\n  \n    \n    // Cube map texture coordinate conversion.\n    p2 *= cubemapRes;\n    vec2 ip2 = floor(p2); p2 -= ip2;\n    vec2 uv2 = fract((ip2 + .5)/cubemapRes);\n\n            \n    // 2D neighboring texels stored in each of the four texture channels.\n    vec4 tx2 = texture(iChannel2, vec3(-.5, uv2.yx - .5)); \n    vec4 tx3 = texture(iChannel2, vec3(.5, uv.y - .5, -uv.x - .5)); \n   \n    if(iFrame<maxFrames){\n        // Line formation -- Not applicable when using a loading screen.\n        if(tx2.x>.001) col = vec3(.5);\n        else col = vec3(.1);\n    }\n    else { \n \n        vec4 rect = vec4(uv2 - tx2.zw, tx2.xy);//getRect(uv2, tx2);//\n\n        // Taking care of wrapping issues by snapping to the cube map face\n        // pixel positions... I get wrapping issues all the time simply \n        // because I forget to do this.\n        tx2.zw = fract((floor(tx2.zw*cubemapRes) + .5)/cubemapRes);\n\n        // Random rectangle coloring.\n        col = .5 + .45*cos(6.2831*(hash21(tx2.xy)) + vec3(0, 1, 2));\n        col = mix(col, vec3(1), .1);\n        // Background texture.\n        vec3 tx = texture(iChannel0, uv2*4.).xyz; tx *= tx;\n        tx = .8 + tx*.4;\n        col *= tx;\n        vec2 u = fragCoord/iResolution.xy;\n        col *= (pow(16.*u.x*u.y*(1.-u.x)*(1.-u.y), 0.125) + .1);\n        \n        // Texture coloring.\n        //col = texture(iChannel1, tx2.zw).xyz; col *= col*2.;\n        \n        float sf = 1./iResolution.y;\n       \n        // Rectangle distance evaluation. \n        float dff = max(abs(rect.x) - rect.z/2., abs(rect.y) - rect.w/2.);\n        vec2 lgt = normalize(vec2(1, 2))/450.;\n        // Offset rectangle calculation for highlighting purposes.\n        rect.xy += lgt;\n        float dff2 = max(abs(rect.x) - rect.z/2., abs(rect.y) - rect.w/2.);\n\n        // Bump calculation.\n        float b = max(dff2 - dff, 0.)*450.;//max(.25 - dff/.05, 0.);\n        \n        \n        // Rendering.\n        col = mix(vec3(0), col*(.5 + b*.8), 1. - smoothstep(0., sf, (dff + .003)));\n       \n        // Center circle.\n        //col = mix(col, vec3(0), 1. - smoothstep(0., sf, length(uv2 - tx2.zw) - .005));\n  \n    }\n    \n   \n     \n    #endif      \n\n\n    // 1.5 second fade-in (assuming 60 FPS) after precalculation.\n    if(iFrame>maxFrames) col = mix(col, scBgnd, max(float(maxFrames + 90 - iFrame), 0.)/90.);\n    \n    // Rought gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 2,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\n\nfloat getDF(vec2 uv, vec4 rect){\n    \n    // Rectangle.\n    return sBoxS(rect.xy, rect.zw/2., .0);\n    //return max(abs(rect.x) - rect.z/2., abs(rect.y) - rect.w/2.);\n    \n    // Circles -- One per rectangle.\n     //return length(rect.xy) - min(rect.z, rect.w)/2.;\n    \n    /*\n    // Circles -- Split into two amongst rectangles with more than\n    // a 2:1 ratio.\n    float d = 1e5;;\n    if(rect.z<rect.w){\n    \n       if(rect.z/rect.w<.5){\n       \n          d = length(rect.xy - vec2(0, -rect.w/4.)) - rect.z/2.;\n          d = min(d, length(rect.xy - vec2(0, rect.w/4.)) - rect.z/2.);\n       }\n       else d = length(rect.xy) - rect.z/2.;\n    }\n    else {\n    \n       if(rect.w/rect.z<.5){\n       \n          d = length(rect.xy - vec2(-rect.z/4., 0)) - rect.w/2.;\n          d = min(d, length(rect.xy - vec2(rect.z/4., 0)) - rect.w/2.);\n       }\n       else d = length(rect.xy) - rect.w/2.;\n    }\n    return d;\n    */\n    \n\n}\n \n\n\n// It can be a bit fiddly filling all four channels in at once, but thankfully, this is\n// all calculated at startup. The idea is to put the function you wish to use in the\n// middle of the loop here, instead of writing it out four times over.\nvec4 funcFace1(vec3 q3){\n   \n    \n    vec4 col = vec4(0);\n    \n    vec2 p;\n    \n    for(int i = 0; i<4; i++){\n        \n        // Texture coordinates for this iteration.\n        p = mod(floor(q3.xy*cubemapRes) + vec2(i&1, i>>1), cubemapRes)/cubemapRes;\n        \n        float df = 0.;\n        \n        if(iFrame == maxFrames){\n            \n            // Rectangle distance field.\n            vec4 tx = tx0(iChannel0, p);\n            tx = vec4(p - tx.zw, tx.xy);\n            df = getDF(p, tx);\n        }\n        /*\n        else {\n            // Lines only.\n            vec2 px = 1./cubemapRes;//iResolution.yy;\n            vec4 cTex = tx0(iChannel0, p);\n            df = 1.;\n            // One pixel width.\n            df = cTex.x>0.? 0. : df;\n            \n            // 2 pixel width... It's better to use the final\n            // field above to get lines only.\n            vec4 cTexL = tx0(iChannel0, (p - vec2(-px.x, 0)));\n            vec4 cTexR = tx0(iChannel0, (p - vec2(px.x, 0)));\n            vec4 cTexB = tx0(iChannel0, (p - vec2(0, -px.y)));\n            vec4 cTexT = tx0(iChannel0, (p - vec2(0, px.y)));\n            df = cTexL.x>0.?  0. : df;\n            df = cTexR.x>0.?  0. : df;\n            df = cTexB.x>0.?  0. : df;\n            df = cTexT.x>0.?  0. : df;\n             \n        }\n        */\n        \n        // Cyberjax's tip to avoid array related compiler annoyances.\n        col.x = df;\n        col = col.yzwx;\n        // The above is equivalent to the following:\n        //col[i] = df;\n        \n    }\n    \n    // Return the four function values -- One for each channel.\n    return col;\n    \n}\n\n\n// Snapping to cube map face 1024x1024 pixel position.\nvec2 conv(vec2 p){ return (floor(p*cubemapRes) + .5)/cubemapRes; }\n\n// The packed rectangle routine: Draw some random dots on the first frame,\n// which are flagged to move either horizontally or vertically. On the \n// next few frames, move them until they hit one of the other lines. After\n// that you'll have a texture full of rectangle borders, so for each pixel\n// not on the line, find the distance to all four rectangle boundaries, and\n// use that information to determine the rectangle center and dimensions.\n//\n// Kind of simple in theory, and annoying to implement, but all doable.\nvec4 funcFace0(vec3 q3){\n    \n      \n   \n    // Coordinates.\n    vec2 p = q3.xy; \n       \n    \n    // Texture samples, and neighboring samples to check for boundary conditions.\n    vec2 px = 1./cubemapRes; \n    vec4 cTex = tx0(iChannel0, p);\n    vec4 cTexL = tx0(iChannel0, (p - vec2(-px.x, 0)));\n    vec4 cTexR = tx0(iChannel0, (p - vec2(px.x, 0)));\n    vec4 cTexB = tx0(iChannel0, (p - vec2(0, -px.y)));\n    vec4 cTexT = tx0(iChannel0, (p - vec2(0, px.y)));\n    \n    vec4 rect = cTex;\n  \n   \n    if(textureSize(iChannel0,0).x<2 || iFrame<1){\n      \n        // On the first frame or before the texture has loaded, \n        //plot some random points.\n         \n        vec2 sc = gSc.xy; \n        \n       \n\n        float tOff = 0.;//hash21(fract(iDate.w)*vec2(1.87, 113.53));\n        vec2 ip = floor((p*sc)) + .5;\n        vec2 offs = vec2(hash21(ip + tOff + 3.), hash21(ip + tOff + 7.)) - .5;\n        \n        \n        // Random or heuristic direction:\n        // Direction: 0 (none), 1 (horizontal), or 2 (vertical).\n        // Modulo direction.\n        float rd = mod(floor(ip.x) + floor(ip.y), 2.)<.1? 2. : 1.;\n        #ifdef PSEUDO_RANDOM\n        // Pseudo-pandom direction.\n        if(hash21(ip + .27)<.5) rd = hash21(ip + .17)<.5? 2. : 1.; \n        #endif\n        \n        \n        //ip += offs*.75;\n        ip += floor(offs*5.999*.7)/5.;\n\n        vec2 pp = conv(p - (ip/sc));\n        \n        //float rn = step(.999, rnd3.z);\n        // For accuracy, it's important to have one pixel with lines...\n        // I think this is how you do it. Due to partitioning, this is \n        // necessary, but if you didn't have to worring about that, you'd\n        // simply flag a pixel as on or off.\n        float sq = (max(abs(pp.x), abs(pp.y))< px.y*.501)? 1. : 0.;\n     \n        // Direction: If we've hit an active pixel (see above), flag its\n        // direction as either horzontal or vertical. If not, flag it as\n        // inactive (set it to zero).\n        float dr = sq*rd;\n        \n        // Line ID. Either it's a line, or it's not.\n        float ln = -sq*2.;\n        \n        // Line direction and line ID.\n        rect.xy = vec2(dr, ln);\n       \n \n    }\n    else if(iFrame<maxFrames - 1){\n        \n        float dr = cTex.x; // Direction: 0 (none), 1 (horizontal), or 2 (vertical).\n        float ln = cTex.y; // Line point: Rendered or not.\n\n        // If the pixel has not been rendered, check to the left and right to see if there's\n        // a rendered horizontal pixel, and if so, mark it as a horizontal line pixel.\n        if(dr<.001 && (abs(cTexL.x - 1.)<.001 || abs(cTexR.x - 1.)<.001)){ dr = 1.; ln = -2.; }\n        // Same as above, but for the vertical.\n        if(dr<.001 && (abs(cTexB.x - 2.)<.001 || abs(cTexT.x - 2.)<.001)){ dr = 2.; ln = -2.; }\n        \n        rect.xy = vec2(dr, ln);\n    \n    }\n    else if(iFrame == maxFrames - 1){\n    \n        // If this is not a line pixel, calculate how far it is to the left\n        // and right borders, and also the top and bottom border distances.\n        // Use that information to calculate the rectangle center and dimensions.\n        \n        // Pixels with no line information are flagged as \"-2\" in the Y channel.\n        // I can't remember why I decided that, but it doesn't matter.\n        if(cTex.y>-1.){ \n\n            /////////////////////   \n            float dimL = 0.;\n            float dimR = 0.;\n            float dimB = 0.;\n            float dimT = 0.;\n           \n            // \"While\" loops would ensure that these run to completion,\n            // but I'd imagine the compiler would like these more. I \n            // doubt a rectangle would be larger than a quarter of the\n            // entire 1024 by 1024 texture size, so we should be OK.\n            #ifdef PSEUDO_RANDOM\n            // Longer rectangles are possible with this arrangement.\n            const int n = 384; \n            #else\n            const int n = 280;\n            #endif\n            \n            #define ONE min(1, iFrame)\n            for(int k = ONE; k<n; k++){            \n                float fk = float(k);\n                vec4 cTexL2 = tx0(iChannel0, p - vec2(-px.x, 0)*fk);\n                if(cTexL2.y>-1.) dimL += 1.;\n                else break;            \n            }\n\n            for(int k = ONE; k<n; k++){            \n                float fk = float(k);\n                vec4 cTexR2 = tx0(iChannel0, p - vec2(px.x, 0)*fk);\n                if(cTexR2.y>-1.) dimR += 1.;\n                else break;            \n            }\n\n            for(int k = ONE; k<n; k++){            \n                float fk = float(k);\n                vec4 cTexT2 = tx0(iChannel0, p - vec2(0, px.y)*fk);\n                if(cTexT2.y>-1.) dimT += 1.;\n                else break;\n\n            }            \n\n            for(int k = ONE; k<n; k++){            \n                float fk = float(k);\n                vec4 cTexB2 = tx0(iChannel0, p - vec2(0, -px.y)*fk);\n                if(cTexB2.y>-1.) dimB += 1.;\n                else break;\n            }\n\n\n            // Rectangle width and height.\n            float w = ((dimR + dimL + 1.)/cubemapRes.x);\n            float h = ((dimB + dimT + 1.)/cubemapRes.y);\n\n            // Rectangle center coordinates. And yes, I should have\n            // put these in the X and Y channels... I'll fix that\n            // later.\n            rect.z = p.x - (dimR/cubemapRes.x - w/2.);\n            rect.w = p.y + (dimB/cubemapRes.y - h/2.);\n            \n            //rect.z = conv(dim);\n            //rect.w = conv(df);\n \n            // Rectangle width and height.\n            rect.x = w;\n            rect.y = h;\n            \n            \n        }\n \n    } \n \n    // Rectangle dimenions (in XY) and center position (in ZW).\n    return rect; \n\n\n}\n\n// Cube mapping - Adapted from one of Fizzer's routines. \nint CubeFaceCoords(vec3 p){\n\n    // Elegant cubic space stepping trick, as seen in many voxel related examples.\n    vec3 f = abs(p); f = step(f.zxy, f)*step(f.yzx, f); \n    \n    ivec3 idF = ivec3(p.x<.0? 0 : 1, p.y<.0? 2 : 3, p.z<0.? 4 : 5);\n    \n    return f.x>.5? idF.x : f.y>.5? idF.y : idF.z; \n}\n\n\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir){\n    \n    \n    // UV coordinates.\n    //\n    // For whatever reason (which I'd love expained), the Y coordinates flip each\n    // frame if I don't negate the coordinates here -- I'm assuming this is internal, \n    // a VFlip thing, or there's something I'm missing. If there are experts out there, \n    // any feedback would be welcome. :)\n    vec2 uv = fract(fragCoord/iResolution.y*vec2(1, -1));\n    \n    // Adapting one of Fizzer's old cube mapping routines to obtain the cube face ID \n    // from the ray direction vector.\n    int faceID = CubeFaceCoords(rayDir);\n    \n    // We're only using one cube map face, so don't calculate any others...\n    // or give the annoying compiler a chance to calculate others.\n    if(faceID > 1) return;\n  \n  \n    // Pixel storage.\n    vec4 col = vec4(0);\n    \n    \n    \n    // Precalculation flag: GPUs are annoying. Sometimes, they'll will calculate\n    // both the \"if\" and \"else\" statements every time. The \"if\" part here is extremely\n    // expensive, so we don't want that. The solution is to not have an \"if-else\"\n    // statement at all.\n    int preCalc = 0;\n    \n\n    // Initial conditions -- Performed upon initiation.\n    //if(abs(tx(iChannel0, uv, 5).w - iResolution.y)>.001){\n    //if(iFrame<1){\n    //\n    // Great hack, by IQ, to ensure that this loads either on the first frame, or in the\n    // event that the texture hasn't loaded (this happens a lot), wait, then do it...\n    // Well kind of. Either way, it works. It's quite clever, which means that it's something \n    // I never would have considered. :)\n    if(textureSize(iChannel0,0).x<2 || iFrame<=maxFrames){\n        \n \n        \n        if(iFrame>maxFrames) return;\n        \n \n        \n        \n        // Fill the first cube face with a custom 3D function.\n        if(faceID==0){\n            \n            //vec3 p = convert2DTo3D(uv);      \n            vec3 p = vec3(uv, 0);      \n            \n            col = funcFace0(p);\n            //col = mix(col, 1.-funcFace0(p*2.), 1./16.);\n            \n            preCalc = 1;\n           \n        }\n        \n        \n        // Fill the first cube face with a custom 3D function.\n        if(faceID==1){\n            \n            //vec3 p = convert2DTo3D(uv);      \n            vec3 p = vec3(uv, 0);      \n            \n            col = funcFace1(p);\n            //col = mix(col, 1.-funcFace0(p*2.), 1./16.);\n            \n            preCalc = 1;\n           \n        }\n        \n\n        /*\n        // Last channel on the last face: Used to store the current \n        // resolution to ensure loading... Yeah, it's wasteful and it\n        // slows things down, but until there's a reliable initiation\n        // variable, I guess it'll have to do. :)\n        if(faceID==5){\n            \n            col.w = iResolution.y;\n        }\n        */\n\n        \n    }\n    \n   \n   \n    if(preCalc == 0 && faceID == 1){\n\n       col = tx1(iChannel0, uv);\n       //col = texture(iChannel0, vec3(-.5, uv.yx - .5));\n       //col = tx(iChannel0, uv, faceID);\n    }    \n    \n    if(preCalc == 0 && faceID == 0){\n\n       col = tx0(iChannel0, uv);\n       //col = texture(iChannel0, vec3(-.5, uv.yx - .5));\n       //col = tx(iChannel0, uv, faceID);\n    }\n    \n    \n    // Update the cubemap faces.\n    fragColor = col;\n    \n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            },
            {
                "code": "// Make the random horizontal and vertical line direction more random, \n// but not too much. Requires a reset -- Ie. Hit the back button.\n//#define PSEUDO_RANDOM\n\n\n// If you want things to wrap, you need a wrapping scale.  Wrapping is not much \n// different to regular mapping. You just need to put \"p = mod(p, gSc)\" in the hash \n// function for anything that's procedurally generated with random numbers. If you're \n// using a repeat texture, then that'll have to wrap too.\nvec3 gSc = vec3(16);\n\n// Maximum frames to perform the precalculation.\n#ifdef PSEUDO_RANDOM\nint maxFrames = 400;\n#else\nint maxFrames = 300;\n#endif\n\n// The cubemap texture resultion.\n#define cubemapRes vec2(1024)\n\n\n/* \n// Reading into one of the cube faces, according to the face ID. To save on cycles,\n// I'd hardcode the face you're after into all but the least costly of situations.\n// This particular function is used just once for an update in the \"CubeA\" tab.\n//\n// The four cube sides - Left, back, right, front.\n// NEGATIVE_X, POSITIVE_Z, POSITIVE_X, NEGATIVE_Z\n// vec3(-.5, uv.yx), vec3(uv, .5), vec3(.5, uv.y, -uv.x), vec3(-uv.x, uv.y, -.5).\n//\n// Bottom and top.\n// NEGATIVE_Y, POSITIVE_Y\n// vec3(uv.x, -.5, uv.y), vec3(uv.x, .5, -uv.y).\nvec4 tx(samplerCube iCh, vec2 p, int id){    \n\n    vec4 rTx;\n    \n    vec2 uv = fract(p) - .5;\n    // It's important to snap to the pixel centers. The people complaining about\n    // seam line problems are probably not doing this.\n    //p = (floor(p*cubemapRes) + .5)/cubemapRes; \n    \n    vec3[6] fcP = vec3[6](vec3(-.5, uv.yx), vec3(.5, uv.y, -uv.x), vec3(uv.x, -.5, uv.y),\n                          vec3(uv.x, .5, -uv.y), vec3(-uv.x, uv.y, -.5), vec3(uv, .5));\n \n    \n    return texture(iCh, fcP[id]);\n}\n*/\n\nvec2 convert(in vec2 p){\n    \n    /*\n    p *= cubemapRes;\n    vec2 ip = floor(p); p -= ip;\n    return fract((ip + .5)/cubemapRes) - .5;\n    */\n\n    return fract((floor(p*cubemapRes) + .5)/cubemapRes) - .5;\n}\n\nvec4 tx0(samplerCube iCh, vec2 p){\n\n    //p = fract(p);\n    //return texture(iCh, vec3(-.5, p.yx - .5));\n\n    vec2 uv = convert(p);\n    return texture(iCh, vec3(-.5, uv.yx));\n \n}\n\nvec4 tx1(samplerCube iCh, vec2 p){\n\n    vec2 uv = convert(p);\n    return texture(iCh, vec3(.5, uv.y, -uv.x));\n \n}\n\n\n// Fabrice's concise, 2D rotation formula.\n//mat2 rot2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n// Standard 2D rotation formula - Nimitz says it's faster, so that's good enough for me. :)\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n\n// 3x1 hash function.\n//float hash31(vec3 p){ return fract(sin(dot(p, vec3(21.471, 157.897, 113.243)))*45758.5453); }\n\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){\n    p = mod(p, gSc.xy);\n    return fract(sin(mod(dot(p, vec2(27.609, 157.583)), 6.2831589))*43758.5453); \n}\n\n// IQ's vec2 to float hash.\nfloat hash21B(vec2 p){\n    \n    return fract(sin(mod(dot(p, vec2(27.609, 157.583)), 6.2831589))*43758.5453); \n}\n\n// IQ's vec2 to float hash.\nfloat hash31(vec3 p){\n    p = mod(p, gSc);\n    return fract(sin(mod(dot(p, vec3(27.609, 137.583, 57.781)), 6.2831589))*43758.5453); \n}\n\n// IQ's vec2 to float hash.\nvec2 hash22(vec2 p){\n    p = mod(p, gSc.xy);\n    p = vec2(dot(p, vec2(27.609, 157.583)), dot(p, vec2(58.827, 17.443)));\n    return fract(sin(mod(p, 6.2831589))*43758.5453); \n} \n\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  vec2 d = abs(p) - b + sf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - sf;\n}\n\n/*\n// IQ's signed box formula.\nfloat sBoxS(in vec3 p, in vec3 b, in float sf){\n   \n\n  vec3 d = abs(p) - b + sf;\n  return min(max(max(d.x, d.y), d.z), 0.) + length(max(d, 0.)) - sf;\n}\n*/\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}