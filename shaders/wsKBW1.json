{
    "Shader": {
        "info": {
            "date": "1607445143",
            "description": "Draw aperiodic rhombus tiling using de Bruijn's algebraic approach.\n\"Aperiodic\" means the tiling has no translation symmetry.\nAdd some Escher style decorations to make it look impossible.\nQuality is better at full screen mode.",
            "flags": 0,
            "hasliked": 0,
            "id": "wsKBW1",
            "likes": 42,
            "name": " Impossible Aperiodic Tilings",
            "published": 3,
            "tags": [
                "escher",
                "tiling",
                "rhombus",
                "impossible",
                "aperiodic",
                "debruijn"
            ],
            "usePreview": 0,
            "username": "neozhaoliang",
            "viewed": 1793
        },
        "renderpass": [
            {
                "code": "/*\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nAperiodic tiling using de Bruijn's algebraic approach, Zhao Liang.\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThis shader was inspired by Greg Egan's JavaScript applet at\n\n    http://gregegan.net/APPLETS/02/02.html\n    \nThanks Greg for explaining his idea to me and the comments in his code.\nI also learned a lot from Shane's excellent examples.\n\nHere is a brief overview of the procedure used in this program,\nusing N=5 as an example.\n\n1. We choose the five fifth roots of unity as grid directions.\n   Each direction has a family of grid lines orthogonal to it,\n   with unit spacing between adjacent lines.\n\n2. We choose five real values to shift each grid along its direction.\n\n3. Any intersection point P of two grid lines can be identified by four\n   integers (r, s, kr, ks), where P is the intersection of the kr-th line\n   in the r-th grid and the ks-th line in the s-th grid. It must hold that\n   0 <= r < s < 5, and kr and ks can be any pair of integers.\n\n4. Each intersection point corresponds to a unique rhombus in the final tiling.\n   Note that this rhombus does not necessarily contain P, but rather a transformed\n   version of P.\n\n5. For each pixel uv, we perform a lengthy computation to determine which rhombus\n   its transformed position lies in.\n   \n6. We then color the rhombus according to its shape, position, ..., whatever you want.\n\n7. In addition, we draw a tunnel in each face and randomly flip the tunnel to create\n   some cubes that appear impossible. Note that this is different from Egan's applet,\n   where he carefully chose fixed flips for each rhombus to make every cube look\n   impossible. Our random flips only make some cubes look impossible.\n\nFor a detailed explanation of the procedure used in this program, please refer to\n\n    \"Algebraic theory of Penrose's non-periodic tilings of the plane\"\n\nby N.G. de Bruijn, or\n\n     \"Aperiodic Order, Volume 1\" by Baake M., Grimm U., and Penrose R.\n     \nPlease feel free to offer any suggestions.\n*/\n\n// If you want some cube faces are closed and draw a cross bar on them\n#define SOME_CLOSED_FACES\n\n// dimension of the grids, N=5 is the (generalized) Penrose pattern\nconst int N = 5;\n\n// control hole size\nconst float hs = 3.33;\n\n// N real numbers for the shifts of the grids.\nfloat[N] shifts;\n\n// directions of the grids, will be initialized later\nvec2[N] grids;\n\nstruct Rhombus\n{\n    // r, s for the r-th and s-th grids.\n    int r;\n    int s;\n\n    // kr, ks for the lines in the two grids\n    float kr;\n    float ks;\n\n    // center and vertices of the rhombus\n    vec2 cen;\n    vec2[4] verts;\n\n    // vertices of the tunnels, each tunnel contains two pieces.\n    vec2[4] inset1;\n    vec2[4] inset2;\n};\n\n#define PI 3.141592653\n\n// initialize the grid directions, for N = 5 they are the five fifth roots of unity\nvoid init_grids()\n{\n    float FN = float(N), theta; \n    for(int k = 0; k < N; k++)\n    {\n        theta = (N % 2 == 0) ? PI / FN * float(k) : PI / FN * float(k) * 2.;\n        grids[k] = vec2(cos(theta), sin(theta));\n        // for N=5 (0.2, 0.2, 0.2, 0.2, 0.2) gives the classical Penrose tiling.\n        // set all shifts to 0.5 will give the star pattern which has ten thin rhombus\n        // around a vertex hence is non-Penrose.\n        // shifts[k] = 0.5;\n        shifts[k] = 1./FN;\n    }\n}\n\n// distance from a 2d point p to a 2d segment (a, b)\nfloat dseg(vec2 p, vec2 a, vec2 b)\n{\n\tvec2 v = b - a;\n    p -= a;\n    float t = clamp(dot(p, v)/dot(v, v), 0., 1.);\n    return length(p - t * v);\n}\n\n// iq's hash function, for randomly flip the tunnels and open/closed faces\nfloat hash21(vec2 p)\n{\n    return fract(sin(dot(p, vec2(141.13, 289.97))) * 43758.5453);\n}\n\nfloat cross_prod(vec2 p, vec2 q)\n{\n    return p.x * q.y - p.y * q.x;\n}\n\n// signed distance function to a polygon using winding number\nfloat sdPoly4(in vec2 p, in vec2[4] verts)\n{\n    float d = dot(p - verts[0], p - verts[0]);\n    float s = 1.0;\n    for(int i = 0, j = 3; i < 4; j = i, i++)\n    {\n        vec2 e = verts[j] - verts[i];\n        vec2 w = p - verts[i];\n        vec2 b = w - e*clamp(dot(w, e)/dot(e, e), 0., 1.);\n        d = min(d, dot(b, b));\n\n        bvec3 cond = bvec3(p.y >= verts[i].y, p.y < verts[j].y, cross_prod(e, w) > 0.);\n        if (all(cond) || all(not(cond)))\n            s *= -1.0;            \n    }\n    return s * sqrt(d);\n}\n\n// project a vector p to the k-th grid, note each grid line is shifted so we need\n// to add the corresponding shifts.\nfloat project_point_grid(vec2 p, int k)\n{\n    return dot(p, grids[k]) + shifts[k];\n}\n\n// find the vertices of the rhombus corresponding to the intersection point P,\n// where P is the intersection of the kr-th line and ks-th line in the r/s grids.\nvoid solve_rhombus_verts(int r, int s, float kr, float ks, out vec2[4] verts)\n{\n    vec2 P = grids[r] * (ks - shifts[s]) - grids[s] * (kr - shifts[r]);\n    P = vec2(-P.y, P.x) / grids[s - r].y;\n    vec2 sum = kr * grids[r] + ks * grids[s];\n    for(int k = 0; k < N; k++)\n    {\n        if ((k != r) && (k != s))\n            sum += grids[k] * ceil(project_point_grid(P, k));\n    }\n    verts[0] = sum;\n    verts[1] = sum + grids[r];\n    verts[3] = sum + grids[s];\n    verts[2] = verts[1] + grids[s];\n}\n\n// this is the \"continous\" version of de Bruijn's transformation that maps a pixel\n// to its position in the tiling.\nvec2 debruijn_transform(vec2 p)\n{\n    vec2 sum = vec2(0.0);\n    for(int k = 0; k < N; k++)\n    {\n        sum += grids[k] * project_point_grid(p, k);\n    }\n    return sum;\n}\n\n// a bit lengthy computation to find after the transformation p --> q,\n// which rhombus q lies in. we simply iterate over all possible combinations:\n// for each pair 0 <= r < s < 5, we find (kr, ks) so that p lies in the (kr, kr+1)\n// strip in the r-th grid and (ks, ks+1) strip in the s-th grid, and check which of\n// the four rhombus (r, s, kr, ks), (r, s, kr, ks+1), (r, s, kr+1, ks), (r, s, kr+1, ks+1)\n// contains q.\n// Sadly due to float rounding errors, we have to search from (r, s, kr-1, ks-1).\nRhombus get_mapped_rhombus(vec2 p, out vec2 q)\n{\n    q = debruijn_transform(p);\n    Rhombus rb;\n    float kr, ks;\n    vec2[4] verts;\n    float[N] pindex;\n    for (int i = 0; i < N; i++)\n    {\n        pindex[i] = floor(project_point_grid(p, i));\n    }\n    for(int r = 0; r < N-1; r++)\n    {\n        for(int s = r+1; s < N; s++)\n        {\n            for(float dr = -1.; dr < 2.; dr += 1.0)\n            {\n                for(float ds = -1.; ds < dr+2.; ds += 1.0)\n                {\n                    kr = pindex[r] + dr;\n                    ks = pindex[s] + ds;\n                    solve_rhombus_verts(r, s, kr, ks, verts);\n                    if (sdPoly4(q, verts) < 0.)\n                    {\n                        rb.r = r, rb.s = s, rb.kr = kr, rb.ks = ks;\n                        rb.verts = verts;\n                        rb.cen = (verts[0] + verts[1] + verts[2] + verts[3]) / 4.0;\n                        return rb;\n                    }\n                }\n            }\n        }\n    }\n}\n\n// For each tunnel in the face, we want it to slant by a best-looking direction.\n// We simply choose a grid line direction that matches best with the diagonal line\n// of this face. This is proposed by Greg Egan.\nvec2 get_best_dir(int r, int s, vec2 v)\n{\n    float maxdot = 0.;\n    float inn = 0.;\n    vec2 result;\n    for(int k = 0; k < N; k++)\n    {\n        if ((k != r) && (k != s))\n        {\n            inn = dot(grids[k], v);\n            if (abs(inn) > maxdot)\n            {\n                maxdot = abs(inn);\n                result = (inn > 0.) ? grids[k] : -grids[k];\n            }\n        }\n    }\n    return result;\n}\n\n// Compute the vertices of the two pieces of the tunnel\nvoid get_tunnels(inout Rhombus rb)\n{\n    vec2 gr = grids[rb.r] / 2.;\n    vec2 gs = grids[rb.s] / 2.;\n    float cA = dot(gr, gs);\n    float sgn = sign(cA);\n    if (sgn == 0.0) sgn = sign(hash21(rb.cen) - 0.5);\n    vec2 xy = (-gr + sgn * gs) / 2.;\n    vec2 XY = get_best_dir(rb.r, rb.s, xy);\n\n    XY /= 7.0;\n\n    // the first piece\n    rb.inset1[0] = (gr - sgn * gs) / 2.;\n    rb.inset1[1] = rb.inset1[0] + XY;\n    rb.inset1[3] = (sgn * gr + gs) / 2.;\n    vec2 v1 = rb.inset1[0] + rb.inset1[3];\n    vec2 v2 = rb.inset1[3] - rb.inset1[0];\n    float t = cross_prod(XY, v2) / cross_prod(v1, v2);\n    rb.inset1[2] =  rb.inset1[3] + t * v1;\n    // the other piece. it shares two vertices with the first one.\n    rb.inset2[0] =  rb.inset1[0];\n    rb.inset2[1] =  rb.inset1[1];\n    rb.inset2[3] = -rb.inset1[3];\n\n    v1 = rb.inset2[0] + rb.inset2[3];\n    v2 = rb.inset2[3] - rb.inset2[0];\n    t = cross_prod(XY, v2) / cross_prod(v1, v2);\n    rb.inset2[2] = rb.inset2[3] + t * v1;\n}\n\nfloat getCross(vec2 p, Rhombus rb)\n{\n    vec2 vA = (rb.verts[0] + rb.cen) / 2.;\n    vec2 vB = (rb.verts[1] + rb.cen) / 2.;\n    vec2 vC = (rb.verts[2] + rb.cen) / 2.;\n    vec2 vD = (rb.verts[3] + rb.cen) / 2.;\n    float dcross = dseg(p, vA, vB);\n    dcross = min(dcross, dseg(p, vB, vC));\n    dcross = min(dcross, dseg(p, vC, vD));\n    dcross = min(dcross, dseg(p, vD, vA));\n    dcross = min(dcross, dseg(p, vA, vC));\n    dcross = min(dcross, dseg(p, vB, vD));\n    return dcross;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // zoom factor\n    float zoom = iResolution.y > 600. ? 4.5 : 3.2;\n    zoom *= 5. / float(N);\n    uv *= zoom;\n\n    float sf = 2. / clamp(iResolution.y, 300., 600.);\n\n    init_grids();\n    // p is transformed position of uv, vary its position by translating along\n    // a fixed direction.\n    vec2 p;\n    Rhombus rb = get_mapped_rhombus(uv + iTime*0.2, p);\n    get_tunnels(rb);\n\n    // relative position of the transformed position with respect to rhombus center\n    vec2 q = p - rb.cen;\n\n    // assign a random number to each face, we let this random number vary by time\n    // so the face can also vary its tunnel directions, openness, etc.\n    float rnd = hash21(rb.cen);\n    rnd = sin(rnd * 6.283 + iTime) * .5 + .5;\n\n    float blink = smoothstep(0.15, .3, rnd);\n    vec3 col = .5 + .45*cos(6.2831*rnd + vec3(0., 1., 2.) - .25);\n    vec3 col2 = .5 + .45*cos(6.2831*dot(rb.cen, vec2(1.)) + vec3(2., 3., 1.) - .25);\n    col = mix(col, pow(col*col2, vec3(.65))*2., .25); \n    col = mix(col, col2.yxz,  float(rb.r * rb.s) / float(N*N*2)*blink);\n    \n    // cA and sA are the cos/sin of the angle at vertice A\n    float cA = dot(grids[rb.r], grids[rb.s]);\n    float sA = sqrt(1. - cA * cA);\n\n    float dcen = dot(q, q) * .95;\n\n    if(rnd > .2)\n    {\n        q.xy = -q.xy; // randomly flip the tunnels to make some cubes look impossible\n        col *= max(1.25 - dcen, 0.);\n    }\n    else { col *= max(dcen + 0.55, 1.); }\n\n    // distance to the boundary of the face\n    float dface = sdPoly4(p, rb.verts);\n\n    // distance to the face border\n    float dborder = max(dface, -(dface + sf*4.));\n\n    // distance to the tunnel of the face\n    vec2 q1 = q * 4. / hs;\n    float dtunnel = min(sdPoly4(q1, rb.inset1), sdPoly4(q1, rb.inset2));\n\n    // distance to the hole of the face,\n    // we choose the size of the hole to half the width/height of the rhombus.\n    // note each rhombus has unit side length, so sA is twice the distance\n    // from the center to its four edges.\n    float dhole = dface + sA / hs;\n    \n    float dcross = 1e5;\n\n#ifdef SOME_CLOSED_FACES\n    // really dirty, maybe should put into a function\n    if(abs(rnd - 0.5) > .495)\n    {\n        dhole += 1e5; dtunnel += 1e5;\n        dcross = min(dcross, getCross(p, rb));\n    }\n#endif\n\n    // shade the tunnels by the type of the rhombus\n    float shade;\n\n    float id = floor(hash21(vec2(float(rb.r), float(rb.s))) * float(N));\n\n    // qd is our shading direction\n    int ind = cA >= 0. ? 0 : 1;\n    float qd = dot(q, rb.cen - rb.verts[ind]);\n    \n    shade = .7 -  smoothstep(-sf*2., sf*2., -sign(rnd - .5)*qd) * clamp(id/float(N), 0.2, 0.6);\n\n    // draw the face border, multiply a factor 0.9 makes the edge look more antialiased\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*2., dborder)) * 0.9);\n\n    // add a thin bounding box around the hole\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*4., abs(dface + sA/8.)))*.5);\n    \n    // draw the black hole\n    col = mix(col, vec3(0), (1. - smoothstep(-sf*2., sf*2., dhole)));\n    \n    // shade the tunnels\n    col = mix(col, vec3(1), (1. - smoothstep(-sf*4., 0., dtunnel-sf*4.)) * shade);\n    \n    // redraw the border of the hole to fix some tiny artifacts\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., abs(dhole))));\n    \n    // highlight the edges\n    col = mix(col, col * 1.5, (1. - smoothstep(sf*6., sf*12., dborder)) * .8);\n\n    // draw the crosses on solid faces\n    col = mix(col, vec3(0.), (1. - smoothstep(0., sf*6., dcross)) * .5);\n\n    // adjust luminance of faces by their types\n    col *= min(id / float(N) + .7, 1.);\n\n    // draw hatch lines on the face to add some decorate pattern.\n    // we get line direction first\n    vec2 diag = (rb.verts[0] - rb.cen);\n    float dd = cA < 0. ? dot(q, diag) : dot(q, vec2(-diag.y, diag.x));\n    \n    float hatch = clamp(sin(dd * 60. * PI) * 2. + .5, 0., 1.);\n    float hrnd = hash21(floor(q * 40.) + 0.73);\n    if (hrnd > 0.66) hatch = hrnd;\n\n    // we dont't want the hatch lines to show on top of the hole and tunnel\n    if (dtunnel < 0.0 || dhole < 0.0) hatch = 1.0;\n    col *= hatch *.25 + .75;\n\n    uv = fragCoord / iResolution.xy;\n    col *= pow(16. * uv.x * uv.y * (1. - uv.x) * (1. - uv.y), .125) * .75 + .25;\n    fragColor = vec4(sqrt(max(col, 0.0)), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}