{
    "Shader": {
        "info": {
            "date": "1612387223",
            "description": "https://en.wikipedia.org/wiki/The_Ciphers_of_the_Monks",
            "flags": 0,
            "hasliked": 0,
            "id": "Wl3fRM",
            "likes": 28,
            "name": "Ciphers of the Monks",
            "published": 3,
            "tags": [
                "digits"
            ],
            "usePreview": 0,
            "username": "bgolus",
            "viewed": 1489
        },
        "renderpass": [
            {
                "code": "float sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdCistercianNumberal(vec2 uv, int n, float s, float t)\n{    \n    vec2 absuv = abs(uv);\n    \n    float zero  = sdSegment(absuv, vec2( 0.0, s/2.), vec2( 0.0,-s/2.));  // center vertical line\n    \n    float one   = sdSegment(absuv, vec2( 0.0, s/2.), vec2( s/3., s/2.)); // horizontal line at end\n    float two   = sdSegment(absuv, vec2( 0.0, s/6.), vec2( s/3., s/6.)); // horizontal line 1/3 from end\n    float three = sdSegment(absuv, vec2( 0.0, s/2.), vec2( s/3., s/6.)); // diagonal line from end going in\n    float four  = sdSegment(absuv, vec2( 0.0, s/6.), vec2( s/3., s/2.)); // diagonal line 1/3 from end going out\n    float five  = min(one, four);                                        // one + four\n    float six   = sdSegment(absuv, vec2(s/3., s/2.), vec2( s/3., s/6.)); // 1/3 height vertical line to the side\n    float seven = min(one, six);                                         // one + six\n    float eight = min(two, six);                                         // two + six\n    float nine  = min(one, eight);                                       // one + two + six\n    \n    // top right is ones\n    // top left is tens\n    // bottom right is hundreds\n    // bottom left is thousands\n    int place = 1;\n    if (uv.x < 0.0)\n        place *= 10;\n    if (uv.y < 0.0)\n        place *= 100;\n    n = int(mod(float(n / place), 10.));\n    return min(zero, n==1?one:n==2?two:n==3?three:n==4?four:n==5?five:n==6?six:n==7?seven:n==8?eight:n==9?nine:zero) - t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float number = mod(iTime * 5., 9999.);\n    \n    float size = 0.5 * iResolution.y;\n    float thickness = 3.;\n    \n    float numDist = sdCistercianNumberal(uv*iResolution.y, int(floor(number)), size, thickness);\n    \n    // blend for animation\n    numDist = mix(numDist, sdCistercianNumberal(uv*iResolution.y, int(ceil(number)), size, thickness), smoothstep(0.5,1.,fract(number)));\n    \n    float col = smoothstep(-0.5, 0.5, numDist);\n    \n    float digits = PrintValue(uv * 10. + vec2(-0.1, 4.0), number, 1., 0.);\n    \n    col *= 1. - digits;\n\n    fragColor = vec4(vec3(col), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float DigitBin( const int x )\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue( vec2 vStringCoords, float fValue, float fMaxDigits, float fDecimalPlaces )\n{       \n    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;\n    \n    bool bNeg = ( fValue < 0.0 );\n\tfValue = abs(fValue);\n    \n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((bNeg) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n                float fReducedRangeValue = fValue;\n                if(fDigitIndex < 0.0) { fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0; }\n\t\t\t\tfloat fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n                fCharBin = DigitBin(int(floor(mod(fDigitValue, 10.0))));\n\t\t\t}\n        }\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}