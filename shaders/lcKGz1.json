{
    "Shader": {
        "info": {
            "date": "1712452586",
            "description": "Illustrates peaks with light pixels, valleys with dark pixels, each one pixel across, with antialiasing.",
            "flags": 32,
            "hasliked": 0,
            "id": "lcKGz1",
            "likes": 2,
            "name": "Peak and Valley Detector",
            "published": 3,
            "tags": [
                "edge",
                "aa",
                "canny"
            ],
            "usePreview": 0,
            "username": "Hatchling",
            "viewed": 129
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 c0 = texture(iChannel0, uv);\n    vec4 c1 = texture(iChannel1, uv);\n    c1 /= c1.a;\n    vec4 c2 = texture(iChannel2, uv);\n    vec4 c3 = texture(iChannel3, uv);\n    \n    \n    //fragColor = texture(iChannel1, uv) * pow(vec4(1)-fragColor, vec4(5.0));\n    \n    fragColor = c1.xyxy *(c0.zzzz)*0.5 + 0.5;// ;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "///////////////////////////////////////////////\n// HELPER FUNCTIONS\n///////////////////////////////////////////////\n\n// Constants ----------------------------------\n\nconst float Pi = 3.14159265358979;\nconst float Tau = Pi * 2.0;\nconst float InvPi = 1.0 / 3.14159265358979;\n\n// HLSL support -------------------------------\n\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n\n#define half  float\n#define half2 vec2\n#define half3 vec3\n#define half4 vec4\n\n#define fixed  float\n#define fixed2 vec2\n#define fixed3 vec3\n#define fixed4 vec4\n\n#define int2 ivec2\n#define int3 ivec3\n#define int4 ivec4\n\n#define bool2 bvec2\n#define bool3 bvec3\n#define bool4 bvec4\n\n#define lerp mix\n\n#define decl_saturate(type)            \\\ntype saturate(type x)                  \\\n{                                      \\\n    return clamp(x, type(0), type(1)); \\\n} \n\ndecl_saturate(float)\ndecl_saturate(vec2)\ndecl_saturate(vec3)\ndecl_saturate(vec4)\n\n// Boolean -------------------------------\n\nbool  isinf2(float v) { return isinf(v); } \nbvec2 isinf2(vec2 v)\n{\n    return bvec2\n    (\n        isinf(v.x),\n        isinf(v.y)\n    );\n}\nbvec3 isinf2(vec3 v)\n{\n    return bvec3\n    (\n        isinf(v.x),\n        isinf(v.y),\n        isinf(v.z)\n    );\n}\nbvec4 isinf2(vec4 v)\n{\n    return bvec4\n    (\n        isinf(v.x),\n        isinf(v.y),\n        isinf(v.z),\n        isinf(v.w)\n    );\n}\n\nbool  isnan2(float v) { return isnan(v); } \nbvec2 isnan2(vec2 v)\n{\n    return bvec2\n    (\n        isnan(v.x),\n        isnan(v.y)\n    );\n}\nbvec3 isnan2(vec3 v)\n{\n    return bvec3\n    (\n        isnan(v.x),\n        isnan(v.y),\n        isnan(v.z)\n    );\n}\nbvec4 isnan2(vec4 v)\n{\n    return bvec4\n    (\n        isnan(v.x),\n        isnan(v.y),\n        isnan(v.z),\n        isnan(v.w)\n    );\n}\n\nbool bnot(bool b) { return !b; }\nbvec2 bnot(bvec2 b) \n{ \n    return bvec2(!b.x, !b.y); \n}\nbvec3 bnot(bvec3 b) \n{ \n    return bvec3(!b.x, !b.y, !b.z); \n}\nbvec4 bnot(bvec4 b) \n{ \n    return bvec4(!b.x, !b.y, !b.z, !b.w); \n}\n\nbool band(bool a, bool b) { return a && b; }\nbvec2 band(bvec2 a, bvec2 b) \n{ \n    return bvec2\n    (\n        a.x && b.x,\n        a.y && b.y\n    ); \n}\nbvec3 band(bvec3 a, bvec3 b) \n{ \n    return bvec3\n    (\n        a.x && b.x,\n        a.y && b.y,\n        a.z && b.z\n    ); \n}\nbvec4 band(bvec4 a, bvec4 b) \n{ \n    return bvec4\n    (\n        a.x && b.x,\n        a.y && b.y,\n        a.z && b.z,\n        a.w && b.w\n    ); \n}\n\nbool bor(bool a, bool b) { return a || b; }\nbvec2 bor(bvec2 a, bvec2 b) \n{ \n    return bvec2\n    (\n        a.x || b.x,\n        a.y || b.y\n    ); \n}\nbvec3 bor(bvec3 a, bvec3 b) \n{ \n    return bvec3\n    (\n        a.x || b.x,\n        a.y || b.y,\n        a.z || b.z\n    ); \n}\nbvec4 bor(bvec4 a, bvec4 b) \n{ \n    return bvec4\n    (\n        a.x || b.x,\n        a.y || b.y,\n        a.z || b.z,\n        a.w || b.w\n    ); \n}\n\nbool bxor(bool a, bool b) { return a != b; }\nbvec2 bxor(bvec2 a, bvec2 b) \n{ \n    return bvec2\n    (\n        a.x != b.x,\n        a.y != b.y\n    ); \n}\nbvec3 bxor(bvec3 a, bvec3 b) \n{ \n    return bvec3\n    (\n        a.x != b.x,\n        a.y != b.y,\n        a.z != b.z\n    ); \n}\nbvec4 bxor(bvec4 a, bvec4 b) \n{ \n    return bvec4\n    (\n        a.x != b.x,\n        a.y != b.y,\n        a.z != b.z,\n        a.w != b.w\n    ); \n}\n\n#define decl_isfinite(retType, type) \\\nretType isfinite(type v)             \\\n{                                    \\\n    return band                      \\\n    (                                \\\n        bnot(isinf2(v)),             \\\n        bnot(isnan2(v))              \\\n    );                               \\\n} \ndecl_isfinite(bool, float)\ndecl_isfinite(bvec2, vec2)\ndecl_isfinite(bvec3, vec3)\ndecl_isfinite(bvec4, vec4)\n\nfloat select(bool s, float a, float b)\n{\n    return s ? a : b;\n}\n\nvec2 select(bvec2 s, vec2 a, vec2 b)\n{\n    return vec2\n    (\n        s.x ? a.x : b.x,\n        s.y ? a.y : b.y\n    );  \n}\n\nvec3 select(bvec3 s, vec3 a, vec3 b)\n{\n    return vec3\n    (\n        s.x ? a.x : b.x,\n        s.y ? a.y : b.y,\n        s.z ? a.z : b.z\n    );  \n}\n\nvec4 select(bvec4 s, vec4 a, vec4 b)\n{\n    return vec4\n    (\n        s.x ? a.x : b.x,\n        s.y ? a.y : b.y,\n        s.z ? a.z : b.z,\n        s.w ? a.w : b.w\n    );  \n}\n\n// Vector math -------------------\n\nfloat dot2(vec2 a, vec2 b) { return a.x * b.x + a.y * b.y; }\nfloat dot2(vec3 a, vec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nfloat dot2(vec4 a, vec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\nint dot2(ivec2 a, ivec2 b) { return a.x * b.x + a.y * b.y; }\nint dot2(ivec3 a, ivec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nint dot2(ivec4 a, ivec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\n\n#define decl_lengthSqr(retType, type) \\\nretType lengthSqr(type a)             \\\n{                                     \\\n    return dot2(a,a);                 \\\n}                                     \n\ndecl_lengthSqr(float, vec2)\ndecl_lengthSqr(float, vec3)\ndecl_lengthSqr(float, vec4)\ndecl_lengthSqr(int, ivec2)\ndecl_lengthSqr(int, ivec3)\ndecl_lengthSqr(int, ivec4)\n\n#define decl_distSqr(retType, type) \\\nretType distSqr(type a, type b)     \\\n{                                   \\\n    type diff = a-b;                \\\n    return lengthSqr(diff);         \\\n}                                   \n\ndecl_distSqr(float, vec2)\ndecl_distSqr(float, vec3)\ndecl_distSqr(float, vec4)\ndecl_distSqr(int, ivec2)\ndecl_distSqr(int, ivec3)\ndecl_distSqr(int, ivec4)\n\n// Borrowed from UnityEngine\n#define decl_safeNormalize(type)                 \\\ntype safeNormalize(type inVec)                   \\\n{                                                \\\n    float dp3 = max(0.001f, dot2(inVec, inVec)); \\\n    return inVec / sqrt(dp3);                    \\\n}\ndecl_safeNormalize(vec2)\ndecl_safeNormalize(vec3)\ndecl_safeNormalize(vec4)\n\n// Trig Math ----------------------\n\n#define decl_cosToTan(type)\\\ntype cosToTan(type cosine)\\\n{\\\n    return (sqrt(type(1.0)-cosine)*sqrt(cosine+type(1.0))) / cosine;\\\n}\ndecl_cosToTan(float)\ndecl_cosToTan(vec2)\ndecl_cosToTan(vec3)\ndecl_cosToTan(vec4)\n\n#define decl_tanToCos(type)\\\ntype tanToCos(type tangent)\\\n{\\\n    return type(1.0)/sqrt(tangent*tangent+type(1.0));\\\n}\ndecl_tanToCos(float)\ndecl_tanToCos(vec2)\ndecl_tanToCos(vec3)\ndecl_tanToCos(vec4)\n\n// Misc. math --------------------\n\n// I don't trust int(floor(x)).\n// So, for positive values:\n//\n// x = floor(x)\n//\n// Add 0.5 in case floor(x) rounded it to some floating point garbage like 23.99999\n// x += 0.5\n//\n// ix = int(x) // THEN cast to an int.\n//\n// Similar thing happens for negative values.\n#define decl_floorToInt(retType, type)              \\\nretType floorToInt(type a)                          \\\n{                                                   \\\n    return retType(floor(a) + sign(a) * type(0.5)); \\\n}                                                   \n\ndecl_floorToInt(int, float)\ndecl_floorToInt(ivec2, vec2)\ndecl_floorToInt(ivec3, vec3)\ndecl_floorToInt(ivec4, vec4)\n\n#define decl_invMix(type) \\\ntype invMix(type a, type b, type t) \\\n{                                   \\\n    type result = (t-a)/(b-a);      \\\n    return select(isfinite(result), result, type(0.5)); \\\n}\n\ndecl_invMix(float)\ndecl_invMix(vec2)\ndecl_invMix(vec3)\ndecl_invMix(vec4)\n\n#define invLerp invMix\n\n#define decl_square(type)\\\ntype square(type a)\\\n{\\\n    return a*a;\\\n}\n\ndecl_square(int)\ndecl_square(ivec2)\ndecl_square(ivec3)\ndecl_square(ivec4)\ndecl_square(float)\ndecl_square(vec2)\ndecl_square(vec3)\ndecl_square(vec4)\n\nhalf Pow5 (half x)\n{\n    return x*x * x*x * x;\n}\n\nhalf2 Pow5 (half2 x)\n{\n    return x*x * x*x * x;\n}\n\nhalf3 Pow5 (half3 x)\n{\n    return x*x * x*x * x;\n}\n\nhalf4 Pow5 (half4 x)\n{\n    return x*x * x*x * x;\n}\n\n// RNG ----------------------------------------\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\nvec2 uniform01ToGauss(vec2 value)\n{\n    float magnitude = sqrt(-2.0 * log(value.x));\n    \n    value.y *= 6.28318530718;\n    vec2 direction = vec2(cos(value.y),sin(value.y));\n    return magnitude * direction;\n}\n\nvec4 sampleRandom(sampler2D tex, vec2 fragCoord, inout uint rngState)\n{\n    fragCoord /= vec2(textureSize(tex, 0));\n    fragCoord += vec2\n    (\n        RandomFloat01(rngState),\n        RandomFloat01(rngState)\n    );\n    \n    return textureLod(tex, fragCoord, 0.0);\n}\n\nvec4 sampleBlueNoise(sampler2D blueNoiseTex, vec2 fragCoord, inout uint rngState)\n{\n    vec4 value = sampleRandom(blueNoiseTex, fragCoord, rngState);\n    \n    // The blue noise texture is limited to integer steps between\n    // 0 and 255 (inclusive).\n    // We need to add randomization to fill in the missing\n    // intermediate values.\n    value = mix(vec4(0.5 / 255.0), vec4(254.5 / 255.0), value);\n    value += \n    (\n        vec4\n        (\n            RandomFloat01(rngState), RandomFloat01(rngState),\n            RandomFloat01(rngState), RandomFloat01(rngState)\n        ) - 0.5\n    ) * (1.0 / 255.0);\n    \n    return value;\n}\n\n// Color -------------------------------\n\n#define decl_linearToGamma(type) \\\ntype linearToGamma(type v)       \\\n{                               \\\n    return pow(v, type(1.0 / 2.2));   \\\n}\n\ndecl_linearToGamma(float)\ndecl_linearToGamma(vec2)\ndecl_linearToGamma(vec3)\ndecl_linearToGamma(vec4)\n\n#define decl_gammaToLinear(type)    \\\ntype gammaToLinear(type v)          \\\n{                                   \\\n    return pow(v, type(2.2)); \\\n}\n\ndecl_gammaToLinear(float)\ndecl_gammaToLinear(vec2)\ndecl_gammaToLinear(vec3)\ndecl_gammaToLinear(vec4)\n\n// Credit: https://www.shadertoy.com/view/DsBGzy by sh1boot\nvec3 hsv2rgb(vec3 hsv) \n{\n    vec3 h3 = mod(6.0 * hsv.x + vec3(5.0, 3.0, 1.0), 6.0);\n    h3 = min(h3, 4.0 - h3);\n    h3 = clamp(h3, 0.0, 1.0);\n    return hsv.z - hsv.z * hsv.y * h3;\n}\n\n// Credit: https://www.shadertoy.com/view/DsBGzy by sh1boot\nvec3 palette(int i) \n{\n    float f = float(i);\n    float h =  mod(1.618033988749894848204586834 * f, 1.0);\n    float s = exp(-0.00025 * f) * 0.65 + 0.25;\n    float v = 1.0;\n    return hsv2rgb(vec3(h, s, v));\n}\n\nvec4 cube(samplerCube cube, vec2 uv)\n{\n    uv -= floor(uv);\n    uv = uv * 2.0 - 1.0;\n    \n    vec3 ray = vec3(uv, 1);\n    \n    return texture(cube, ray);\n}\n\nvec4 cubeFetch(samplerCube cube, ivec2 coord, int mip)\n{\n    vec2 uv = (vec2(coord) + vec2(0.5)) / vec2(textureSize(cube, mip));\n    //uv = clamp(uv, vec2(0), vec2(1));\n    uv -= floor(uv);\n    uv = uv * 2.0 - 1.0;\n    \n    vec3 ray = vec3(uv, 1);\n    \n    return textureLod(cube, ray, float(mip));\n}\n\nvec4 cubeLod(samplerCube cube, vec2 uv, float mip)\n{\n    //uv = clamp(uv, vec2(0), vec2(1));\n    uv -= floor(uv);\n    uv = uv * 2.0 - 1.0;\n    \n    vec3 ray = vec3(uv, 1);\n    \n    return textureLod(cube, ray, mip);\n}\n\nstruct quaternion\n{\n    vec4 value;\n};\n\nstruct bounds\n{\n    vec3 mini, maxi;\n};\n\nbool rayIntersectBounds\n(\n    bounds b, \n    vec3 rayOrig, \n    vec3 rayDir,\n    out vec3 nearHit,\n    out vec3 farHit\n)\n{\n    b.mini -= rayOrig;\n    b.maxi -= rayOrig;\n    \n    vec3 signs = sign(rayDir);\n    \n   \n    b.mini *= signs;\n    b.maxi *= signs;\n    rayDir *= signs;\n    \n    vec3 maxBounds = max((b.mini), (b.maxi));\n    \n    rayDir *= max(max(maxBounds.x, maxBounds.y),maxBounds.z) * 2.0; \n    \n    \n    \n    {\n        farHit = rayDir;\n        vec3 clamped = min(farHit, maxBounds);\n    \n        vec3 scale = max(vec3(0.0), clamped / farHit);\n        float minScale = min(min(scale.x, scale.y),scale.z); \n        farHit = (farHit * minScale) * signs + rayOrig;\n    }\n    \n    /*{\n        nearHit = -rayDir;\n        vec3 clamped = clamp(nearHit, b.mini, b.maxi);\n    \n        vec3 scale = abs(clamped / nearHit);\n        float minScale = max(max(scale.x, scale.y),scale.z); \n        nearHit = nearHit * minScale + rayOrig;\n    }*/\n    \n    nearHit = rayOrig;\n\n    return true;\n}\n\nquaternion mul(quaternion a, quaternion b)\n{\n    quaternion q;\n    q.value = vec4\n    (\n        a.value.wwww * b.value \n      + (a.value.xyzx * b.value.wwwx + a.value.yzxy * b.value.zxyy) * vec4(1.0, 1.0, 1.0, -1.0) \n      - a.value.zxyz * b.value.yzxz\n    );\n    return q;\n}\n\nvec3 mul(quaternion q, vec3 v)\n{\n    vec3 t = 2.0 * cross(q.value.xyz, v);\n    return v + vec3(q.value.w * t) + cross(q.value.xyz, t);\n}\n\nquaternion FromAngleAxis(vec3 angleAxis)\n{\n    float mag = length(angleAxis);\n    float halfAngle = mag * 0.5;\n    float scalar = sin(halfAngle) / max(mag, 0.00001);\n        \n    quaternion q;\n    q.value = vec4(angleAxis * scalar, cos(halfAngle));\n    return q;\n}\n\nquaternion FromToRotation(vec3 from, vec3 to)\n{\n    vec3 xyz = cross(from, to);\n    float w = sqrt(dot(from, from) * dot(to, to)) + dot(from, to);\n    vec4 value = vec4(xyz, w);\n    quaternion q;\n    q.value = normalize(value);\n    return q;\n}\n\nquaternion LookRotation(float3 forward, float3 up)\n{\n    quaternion q;\n    forward = safeNormalize(forward);\n    q = FromToRotation(vec3(0,0,1), forward);\n    up = up - dot(forward, up) * forward;\n    vec3 upFrom = mul(q, vec3(0,1,0));\n    q = mul(FromToRotation(upFrom, up), q);\n    return q;\n}\n\nvoid sincos(vec3 x, out vec3 s, out vec3 c)\n{\n    s = sin(x);\n    c = cos(x);\n}\n        \nquaternion EulerZXY(float3 xyz)\n{\n    vec3 s, c;\n    sincos(vec3(0.5) * xyz, s, c);\n\n    return quaternion\n    (\n        vec4(s.xyz, c.x) * c.yxxy * c.zzyz \n      + s.yxxy * s.zzyz * vec4(c.xyz, s.x) * vec4(1, -1, -1, 1)\n    );\n}\n\nmat4x4 RotationMatrix(quaternion q)\n{\n    float q0 = q.value.x;\n    float q1 = q.value.y;\n    float q2 = q.value.z;\n    float q3 = q.value.w;\n        \n    /*# First row of the rotation matrix\n    r00 = 2 * (q0 * q0 + q1 * q1) - 1\n    r01 = 2 * (q1 * q2 - q0 * q3)\n    r02 = 2 * (q1 * q3 + q0 * q2)\n     \n    # Second row of the rotation matrix\n    r10 = 2 * (q1 * q2 + q0 * q3)\n    r11 = 2 * (q0 * q0 + q2 * q2) - 1\n    r12 = 2 * (q2 * q3 - q0 * q1)\n     \n    # Third row of the rotation matrix\n    r20 = 2 * (q1 * q3 - q0 * q2)\n    r21 = 2 * (q2 * q3 + q0 * q1)\n    r22 = 2 * (q0 * q0 + q3 * q3) - 1*/\n        \n    float r00 = 2. * (q0 * q0 + q1 * q1) - 1.;\n    float r01 = 2. * (q1 * q2 - q0 * q3);\n    float r02 = 2. * (q1 * q3 + q0 * q2);\n                                        \n    float r10 = 2. * (q1 * q2 + q0 * q3);\n    float r11 = 2. * (q0 * q0 + q2 * q2) - 1.;\n    float r12 = 2. * (q2 * q3 - q0 * q1);\n                                         \n    float r20 = 2. * (q1 * q3 - q0 * q2);\n    float r21 = 2. * (q2 * q3 + q0 * q1);\n    float r22 = 2. * (q0 * q0 + q3 * q3) - 1.;\n                             \n    return mat4x4\n    (\n        mul(q, vec3(1,0,0)), 0,\n        mul(q, vec3(0,1,0)), 0,\n        mul(q, vec3(0,0,1)), 0,\n        0,   0,   0,   1\n    );\n}\n\nmat4x4 TRS(vec3 translation, quaternion rotation, vec3 scale)\n{\n    mat4x4 float3x = RotationMatrix(rotation);\n    return mat4x4\n    (\n        vec4(float3x[0] * scale.x), \n        vec4(float3x[1] * scale.y), \n        vec4(float3x[2] * scale.z), \n        vec4(translation, 1)\n    );\n}\n\n// Drawing helpers --------------------------------\n\nvoid blend(in vec4 src, inout vec4 dest)\n{\n    dest.rgb = mix(dest.rgb, src.rgb, src.a);\n    dest.a = mix(dest.a, 1.0, src.a);    \n}\n\nvoid drawCircle(vec2 center, vec2 frag, float radius, float lineWidth, vec4 lineColor, inout vec4 color)\n{\n    float distanceToEdge = abs(radius - distance(frag, center));\n\n    float circle = smoothstep\n    (\n        0.0, \n        1.0,\n        1.0 - (distanceToEdge / lineWidth) \n    );\n                \n    lineColor.a *= circle;\n    blend(lineColor, color);\n}\n\nvoid drawSDF(vec3 diff_dist, inout vec4 color)\n{\n    float d = diff_dist.z;\n    vec2 grad = diff_dist.xy/(d);\n    \n    vec3 c = normalize(vec3(grad,sign(d))) * 0.5 + 0.5;\n\tc *= 1. - exp2(-12. * abs(d));\n\tc *= .8 + .2 * cos(120.*d);\n\n    color.rgb = c;\n}\n\nvec3 unsignedValueToColor(float value)\n{\n    float valueLog = log2(value + 0.0625);\n    valueLog /= 16.0;\n    //value /= 1. + abs(valueLog);\n    valueLog = valueLog * 0.5 + 0.5;\n    \n    value *= 10.0;\n    value += 0.125;\n    value /= 1. + abs(value);\n    \n    return hsv2rgb(vec3(valueLog, 1, value));\n}\n\n// Font helpers ------------------------------\n#define FONTSAMPLERSIZE vec2(1024, 1024)\n#define FONTSAMPLERSIZEI ivec2(1024, 1024)\n#define FONTELEMENTCOUNT  vec2(16, 16)\n#define FONTELEMENTCOUNTI  ivec2(16, 16)\n#define FONTELEMENTSIZE  vec2(64, 64)\n#define FONTELEMENTSIZEI  ivec2(64, 64)\nvec4 sampleFontElement(sampler2D fontSampler, in vec2 fragCoord, in ivec2 element)\n{\n    vec2 samplerCoordMin = vec2(element * FONTELEMENTSIZEI); \n    vec2 samplerCoordMax = vec2(element * FONTELEMENTSIZEI + FONTELEMENTSIZEI); \n    \n    vec2 elementUV = (fragCoord - samplerCoordMin) / FONTELEMENTSIZE;\n    elementUV -= floor(elementUV);\n    \n    vec2 samplerCoord = mix(samplerCoordMin, samplerCoordMax, elementUV);\n    vec2 samplerUV = samplerCoord / FONTSAMPLERSIZE;\n    \n    return texture(fontSampler, samplerUV);\n}\n\nvec4 sampleFontElementColor(sampler2D fontSampler, in vec2 fragCoord, in ivec2 element, in vec4 color)\n{\n    float opacity = sampleFontElement(fontSampler, fragCoord, element).r;\n    \n    color.a *= opacity;\n    \n    return color;\n}\n\nvec3 getNoise(int iFrame)\n{\n    vec3 noise = vec3(0);\n\n    // Calculate oising over time.\n    vec3 temporalNoise;\n    {\n        // Use the golden ratio as it should land\n        // on all fractional values eventually.\n        temporalNoise = vec3(iFrame, iFrame+1, iFrame+2);\n        temporalNoise *= vec3(0.7548776662, 0.56984029, 0.618033988749);\n\n        // We floor this one early to prevent\n        // loss of precision when iFrame becomes large.\n        temporalNoise -= floor(noise);\n    }\n    noise += temporalNoise;\n\n    #ifdef SPATIAL_NOISE\n    // Add noising over space.\n    // (Currently disabled; messes up the\n    // gradient and especially the curvature\n    // of the resulting map.)\n    vec3 spatialNoise;\n    {\n        // Noise is added to vary the threshold\n        // per pixel to speed up apparent convergence,\n        // but the converged result shouldn't change.\n\n        vec2 noiseUV = fragCoord.xy / iChannelResolution[1].xy;\n        spatialNoise = texture(iChannel1, noiseUV).r;\n    }\n    noise += spatialNoise;\n    #endif\n\n    // Wrap values around from 0 to 1.\n    noise -= floor(noise);\n\n    // Center the sampling position offset\n    // to a range within -0.5 to +0.5.\n    noise.xy -= 0.5f;\n    \n    return noise;\n}\n\n// PBR Lighting ------------------------------\n// Borrowed from UnityEngine\nstruct MaterialMetallic\n{\n    fixed3 albedo;      // base (diffuse or specular) color\n    half metallic;      // 0=non-metal, 1=metal\n    half smoothness;    // 0=rough, 1=smooth\n};\n\nstruct Material\n{\n    vec3 albedo;\n    vec3 specColor;\n    float oneMinusReflectivity;\n    float smoothness;\n};\n\nstruct Light\n{\n    half3 color;\n    half3 dir;\n};\n\nstruct Indirect\n{\n    half3 diffuse;\n    half3 specular;\n};\n\nconst float4 dielectricSpec = float4(0.04, 0.04, 0.04, 1.0 - 0.04);\n\nhalf OneMinusReflectivityFromMetallic(half metallic)\n{\n    half oneMinusDielectricSpec = dielectricSpec.a;\n    return oneMinusDielectricSpec - metallic * oneMinusDielectricSpec;\n}\n\nhalf3 DiffuseAndSpecularFromMetallic (half3 albedo, half metallic, out half3 specColor, out half oneMinusReflectivity)\n{\n    specColor = lerp (dielectricSpec.rgb, albedo, metallic);\n    oneMinusReflectivity = OneMinusReflectivityFromMetallic(metallic);\n    return albedo * oneMinusReflectivity;\n}\n\nMaterial toMaterial(MaterialMetallic i)\n{\n    Material o;\n    \n    o.albedo = i.albedo;\n    o.smoothness = i.smoothness;\n    \n    half oneMinusReflectivity;\n    half3 specColor;\n    o.albedo = DiffuseAndSpecularFromMetallic (o.albedo, i.metallic, o.specColor, o.oneMinusReflectivity);\n    \n    return o;\n}\n\nfloat SmoothnessToPerceptualRoughness(float smoothness)\n{\n    return (1.0 - smoothness);\n}\n\n// Note: Disney diffuse must be multiply by diffuseAlbedo / PI. This is done outside of this function.\nhalf DisneyDiffuse(half NdotV, half NdotL, half LdotH, half perceptualRoughness)\n{\n    half fd90 = 0.5 + 2.0 * LdotH * LdotH * perceptualRoughness;\n    // Two schlick fresnel term\n    half lightScatter   = (1.0 + (fd90 - 1.0) * Pow5(1.0 - NdotL));\n    half viewScatter    = (1.0 + (fd90 - 1.0) * Pow5(1.0 - NdotV));\n\n    return lightScatter * viewScatter;\n}\n\nfloat PerceptualRoughnessToRoughness(float perceptualRoughness)\n{\n    return perceptualRoughness * perceptualRoughness;\n}\n\nfloat SmithJointGGXVisibilityTerm (float NdotL, float NdotV, float roughness)\n{\n    // Original formulation:\n    //  lambda_v    = (-1 + sqrt(a2 * (1 - NdotL2) / NdotL2 + 1)) * 0.5f;\n    //  lambda_l    = (-1 + sqrt(a2 * (1 - NdotV2) / NdotV2 + 1)) * 0.5f;\n    //  G           = 1 / (1 + lambda_v + lambda_l);\n\n    // Reorder code to be more optimal\n    half a          = roughness;\n    half a2         = a * a;\n\n    half lambdaV    = NdotL * sqrt((-NdotV * a2 + NdotV) * NdotV + a2);\n    half lambdaL    = NdotV * sqrt((-NdotL * a2 + NdotL) * NdotL + a2);\n\n    // Simplify visibility term: (2.0f * NdotL * NdotV) /  ((4.0f * NdotL * NdotV) * (lambda_v + lambda_l + 1e-5f));\n    return 0.5f / (lambdaV + lambdaL + 1e-5f);  // This function is not intended to be running on Mobile,\n                                                // therefore epsilon is smaller than can be represented by half\n}\n\nfloat GGXTerm (float NdotH, float roughness)\n{\n    float a2 = roughness * roughness;\n    float d = (NdotH * a2 - NdotH) * NdotH + 1.0f; // 2 mad\n    return InvPi * a2 / (d * d + 1e-7f); // This function is not intended to be running on Mobile,\n                                            // therefore epsilon is smaller than what can be represented by half\n}\n\nhalf3 FresnelTerm (half3 F0, half cosA)\n{\n    half t = Pow5 (1.0 - cosA);   // ala Schlick interpoliation\n    return F0 + (1.0-F0) * t;\n}\n\nhalf3 FresnelLerp (half3 F0, half3 F90, half cosA)\n{\n    half t = Pow5 (1.0 - cosA);   // ala Schlick interpoliation\n    return lerp (F0, F90, t);\n}\n\n\nhalf3 brdf (half3 albedo, half3 specColor, half oneMinusReflectivity, half smoothness,\n    float3 normal, float3 viewDir,\n    Light light, Indirect gi)\n{\n    float perceptualRoughness = SmoothnessToPerceptualRoughness (smoothness);\n    float3 halfDir = safeNormalize(float3(light.dir) + viewDir);\n\n    // The amount we shift the normal toward the view vector is defined by the dot product.\n    half shiftAmount = dot(normal, viewDir);\n    normal = shiftAmount < 0.0f ? normal + viewDir * (-shiftAmount + 1e-5f) : normal;\n    normal = normalize(normal);\n\n    float nv = saturate(dot(normal, viewDir)); // TODO: this saturate should no be necessary here\n\n    float nl = saturate(dot(normal, light.dir));\n    float nh = saturate(dot(normal, halfDir));\n\n    half lv = saturate(dot(light.dir, viewDir));\n    half lh = saturate(dot(light.dir, halfDir));\n\n    // Diffuse term\n    half diffuseTerm = DisneyDiffuse(nv, nl, lh, perceptualRoughness) * nl / 3.1415927;\n\n    // Specular term\n    float roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n    \n    // GGX with roughtness to 0 would mean no specular at all, using max(roughness, 0.002) here to match HDrenderloop roughtness remapping.\n    roughness = max(roughness, 0.002);\n    float V = SmithJointGGXVisibilityTerm (nl, nv, roughness);\n    float D = GGXTerm (nh, roughness);\n\n    float specularTerm = V*D; // Torrance-Sparrow model, Fresnel is applied later\n\n    // specularTerm * nl can be NaN on Metal in some cases, use max() to make sure it's a sane value\n    specularTerm = max(0.0, specularTerm * nl);\n\n    // surfaceReduction = Int D(NdotH) * NdotH * Id(NdotL>0) dH = 1/(roughness^2+1)\n    half surfaceReduction;\n    surfaceReduction = 1.0 / (roughness*roughness + 1.0);           // fade \\in [0.5;1]\n\n    // To provide true Lambert lighting, we need to be able to kill specular completely.\n    //specularTerm *= (specColor != vec3(0)) ? 1.0 : 0.0;\n\n    half grazingTerm = saturate(smoothness + (1.0-oneMinusReflectivity));\n    half3 color =   albedo * (gi.diffuse + light.color * diffuseTerm)\n                    + specularTerm * light.color * FresnelTerm (specColor, lh)\n                    + surfaceReduction * gi.specular * FresnelLerp (specColor, vec3(grazingTerm), nv)\n                    ;\n\n    return half3(color);\n}\n\nvec3 lighting(MaterialMetallic mat, vec3 normal, vec3 viewDir, Light light, Indirect indirect)\n{\n    Material m = toMaterial(mat);\n    \n    return brdf(m.albedo, m.specColor, m.oneMinusReflectivity, m.smoothness,\n    normal, viewDir, light, indirect);\n}\n\n// RAYTRACING -----------------------------\n// Taken from https://www.shadertoy.com/view/MtcXWr\n// Credit: Zavie\n\nstruct Ray\n{\n    vec3 origin;\t\n    vec3 direction;\t\t\n};\n\nstruct Hit\n{\n    float distance;\n    vec3 normal;\t\n};\nconst Hit noHit = Hit(1e10, vec3(0.));\n\nstruct Plane\n{\n    float offset;\n    vec3 normal;\n};\n\nstruct Sphere\n{\n\tfloat radius;\n    vec3 center;\n};\n\nstruct Cone\n{\n    float cosa;\t// cosine of half cone angle\n    float height;\n    float thickness;\n    vec3 origin;\n    vec3 axis;\n};\n\nstruct Capsule\n{\n    vec3 start;\n    vec3 end;\n    float startRadius;\n    float endRadius;\n};\n\nstruct HeightPlane\n{\n    mat4x4 localToWorld;\n    vec2 uvOffset;\n};\n\nvec3 getPoint(in Ray r, float dist)\n{\n    return r.origin + r.direction * dist;\n}\n\nvec3 getPoint(in Ray r, in Hit hit)\n{\n    return r.origin + r.direction * hit.distance;\n}\n\nbool swapIfCloser(inout Hit current, Hit candidate)\n{\n    if (candidate.distance < current.distance && candidate.distance >= 0.0)\n    {\n        current = candidate;\n        return true;\n    }\n    return false;\n}\n\nHit intersectPlane(Plane plane, Ray ray)\n{\n    float dotnd = -dot(plane.normal, ray.direction);\n    float heightAbovePlane = dot(ray.origin, plane.normal) - plane.offset;\n\n    float t = heightAbovePlane / dotnd;\n    //if(!(t >= 0.0))\n    //    return noHit;\n        \n    return Hit(t, plane.normal * sign(dotnd));\n}\n\nHit intersectSphere(Sphere sphere, Ray ray)\n{\n\tvec3 op = sphere.center - ray.origin;\n    float b = dot(op, ray.direction);\n    float det = b * b - dot(op, op) + sphere.radius * sphere.radius;\n    if (det < 0.) return noHit;\n\n    det = sqrt(det);\n    float t = b - det;\n    if (t < 0.) t = b + det;\n    if (t < 0.) return noHit;\n\n    return Hit(t, (ray.origin + t*ray.direction - sphere.center) / sphere.radius);\n}\n\nHit intersectCapsule(Capsule capsule, Ray ray)\n{\n    vec3 rayDirection = ray.direction;\n    vec3 relativeOrigin = ray.origin - capsule.start;\n    vec3 coneDirection = normalize(capsule.end - capsule.start);\n    float coneLength = distance(capsule.end, capsule.start);\n    float changeInRadiusWithLength = (capsule.endRadius - capsule.startRadius) / coneLength;\n    float whatever = 1.0 - square(changeInRadiusWithLength);\n    \n    if(whatever <= 0.0)\n    {\n    \tif(capsule.endRadius < capsule.startRadius)\n    \t{\n    \t\tSphere s = Sphere(capsule.startRadius, capsule.start);\n    \t\treturn intersectSphere(s, ray);    \n        }\n   \t\telse\n        {\n            Sphere s = Sphere(capsule.endRadius, capsule.end);\n            return intersectSphere(s, ray);   \n        } \n    }\n    \n    float sideB = sqrt(whatever);\n    float changeInThicknessWithLength = changeInRadiusWithLength / sideB;\n    \n    float radiusToThickness = changeInThicknessWithLength/changeInRadiusWithLength;\n    float startThickness = capsule.startRadius * radiusToThickness;\n    float endThickness = capsule.endRadius * radiusToThickness;\n    \n    if((coneLength+capsule.endRadius) < capsule.startRadius)\n    {\n    \tSphere s = Sphere(capsule.startRadius, capsule.start);\n    \treturn intersectSphere(s, ray);    \n    }\n    if((coneLength+capsule.startRadius) < capsule.endRadius)\n    {\n    \tSphere s = Sphere(capsule.endRadius, capsule.end);\n    \treturn intersectSphere(s, ray);    \n    }\n    \n    float c = lengthSqr(relativeOrigin)\n            - square(dot(relativeOrigin, coneDirection))\n            - square(dot(relativeOrigin, coneDirection*changeInThicknessWithLength))\n            - square(startThickness) \n            - 2.0*changeInThicknessWithLength*startThickness*dot(relativeOrigin, coneDirection);\n\n    float b = 2.0*dot(relativeOrigin, rayDirection)\n            - 2.0*dot(relativeOrigin, coneDirection)*dot(rayDirection, coneDirection)\n            - 2.0*dot(relativeOrigin, coneDirection*changeInThicknessWithLength)*dot(rayDirection, coneDirection*changeInThicknessWithLength)\n            - 2.0*changeInThicknessWithLength*startThickness*dot(rayDirection, coneDirection);\n\n    float a = 1.0\n            - square(dot(rayDirection, coneDirection))\n            - square(dot(rayDirection, coneDirection*changeInThicknessWithLength));\n        \n    float det = b*b - 4.*a*c;\n    if (det < 0.) return noHit;\n\n    det = sqrt(det);\n    float t1 = (-b - det) / (2. * a);\n    float t2 = (-b + det) / (2. * a);\n\n    float t = t1;\n    if (t < 0. || t2 > 0. && t2 < t) t = t2;\n    if (t < 0.) return noHit;\n    \n    vec3 relativeRayHit = ray.origin + t*ray.direction - capsule.start;\n    float actualDistanceOfPointAlongAxis = dot(relativeRayHit, coneDirection);\n    float distanceOfPointAlongAxis = actualDistanceOfPointAlongAxis;//square(fract(iTime * 0.25 / coneLength)) * coneLength;//dot(relativeRayHit, coneDirection);\n    \n    \n    float thicknessAtPoint = distanceOfPointAlongAxis * changeInThicknessWithLength + startThickness;\n    \n    Hit hit1;\n    \n    if(actualDistanceOfPointAlongAxis < distanceOfPointAlongAxis)\n    {\n    \thit1 = Hit(t*0.25, vec3(1));    \n    }\n    else\n    {\n    \thit1 = Hit(t, vec3(-1));  \n    }\n    \n    float distanceOfSphereAlongAxis = distanceOfPointAlongAxis + (thicknessAtPoint * changeInRadiusWithLength / sideB);\n    \n    distanceOfSphereAlongAxis = clamp(distanceOfSphereAlongAxis, 0.0, coneLength);\n\n    float sphereRadius = distanceOfSphereAlongAxis * changeInRadiusWithLength + capsule.startRadius;\n\n    Sphere s = Sphere(sphereRadius, capsule.start + coneDirection * distanceOfSphereAlongAxis);\n    \n    Hit hit2 = intersectSphere(s, ray);\n    hit2.distance *= 0.5;\n    swapIfCloser(hit1, hit2);\n    \n    return hit2;\n}\n\nHit intersectHeightPlane(HeightPlane plane, Ray ray, sampler2D heightMap, vec2 heightMapSize)\n{\n    Ray origRay = ray;\n    mat4x4 worldToLocal = inverse(plane.localToWorld);\n\n    ray.origin = (worldToLocal * vec4(ray.origin, 1)).xyz; \n    ray.direction = normalize((worldToLocal * vec4(ray.direction, 0)).xyz); \n\n    Plane maxPlane = Plane(-1.0, vec3(0,0,1));\n    Plane minPlane = Plane( 0.0, vec3(0,0,1));\n    \n    Hit maxHit = intersectPlane(maxPlane, ray);\n    Hit minHit = intersectPlane(minPlane, ray);\n    \n    \n    //if(maxHit == noHit || minHit == noHit)\n    //    return noHit;\n    \n    float nearDist = min(minHit.distance, maxHit.distance);\n    float farDist  = max(minHit.distance, maxHit.distance);\n    \n    if(farDist < 0.0)\n        return noHit;\n        \n    if(nearDist < 0.0)\n        nearDist = 0.0;\n        \n    //return maxHit;\n    \n    //vec3 nearHit = ray.origin + ray.direction * nearDist;\n    //vec3 farHit = ray.origin + ray.direction * farDist;\n    \n    vec3 hitPos;\n    \n    \n    bool hit = false;\n    float increment = max(0.00001, 0.0001 / abs(nearDist-farDist));\n    for(float i = 0.0; i <= 1.0; i += increment)\n    {\n        float marchDist = mix(nearDist, farDist, i);\n        hitPos = ray.origin + ray.direction * marchDist;\n        \n        vec2 uv = hitPos.xy;\n        float depth = textureLod(heightMap, uv + plane.uvOffset, 0.0).r*1.0 - 1.0;\n        \n        if(hitPos.z <= depth)\n        {\n            hitPos.z = depth;\n            farDist = marchDist;\n            hit = true;\n            break;\n        }\n        else\n        {\n            nearDist = marchDist;\n        }\n    }\n    \n    if(!hit) return noHit;\n    \n    farDist = (nearDist + farDist) * 0.5;\n    float stepSize = (farDist - nearDist) * 0.5;\n    for(int i = 0; i < 12; i++, stepSize *= 0.5)\n    {\n        hitPos = ray.origin + ray.direction * farDist;\n        \n        vec2 uv = hitPos.xy;\n        float depth = textureLod(heightMap, uv + plane.uvOffset, 0.0).r - 1.0;\n        \n        if(hitPos.z > depth)\n        {\n            nearDist = farDist;\n            farDist += stepSize;\n        }\n        else\n        {\n            hitPos.z = depth;\n            farDist -= stepSize;\n        }\n    }\n    \n    ray = origRay;\n    \n    const float sampleSpacing = 0.5;\n    vec4 uvOffset = vec4(-sampleSpacing, -sampleSpacing, sampleSpacing, sampleSpacing) / heightMapSize.xyxy;\n    \n    vec3 p00, p10, p01, p11;\n    p00 = vec3(hitPos.xy + uvOffset.xy, 0);\n    p10 = vec3(hitPos.xy + uvOffset.zy, 0);\n    p01 = vec3(hitPos.xy + uvOffset.xw, 0);\n    p11 = vec3(hitPos.xy + uvOffset.zw, 0);\n    \n    p00.z = textureLod(heightMap, p00.xy + plane.uvOffset, 0.0).r - 1.0;\n    p10.z = textureLod(heightMap, p10.xy + plane.uvOffset, 0.0).r - 1.0;\n    p01.z = textureLod(heightMap, p01.xy + plane.uvOffset, 0.0).r - 1.0;\n    p11.z = textureLod(heightMap, p11.xy + plane.uvOffset, 0.0).r - 1.0;\n    \n    p00 = (plane.localToWorld * vec4(p00, 1)).xyz;\n    p10 = (plane.localToWorld * vec4(p10, 1)).xyz;\n    p01 = (plane.localToWorld * vec4(p01, 1)).xyz;\n    p11 = (plane.localToWorld * vec4(p11, 1)).xyz;\n    \n    Hit outHit;\n    outHit.normal = cross(p11 - p00, p01 - p10);\n    \n    hitPos = (plane.localToWorld * vec4(hitPos, 1)).xyz; \n    outHit.normal = normalize(outHit.normal);\n    outHit.distance = dot(hitPos - ray.origin, ray.direction);\n    \n    return outHit;\n}\n\nvec2[4] getMSAACoords()\n{\n    float o1 = 0.25;\n    float o2 = 0.75;\n    vec2 msaa[4];\n    msaa[0] = vec2( o1,  o2);\n    msaa[1] = vec2( o2, -o1);\n    msaa[2] = vec2(-o1, -o2);\n    msaa[3] = vec2(-o2,  o1);\n    return msaa;\n}\n\nRay uvToRay(vec2 uv, float aspect, float zoom, vec2 offset)\n{\n    uv = uv * vec2(2.0) - 1.0;\n    uv.x *= aspect;\n    uv += offset;\n    return Ray(vec3(0), normalize(vec3(uv,zoom)));\n}\n\n#define render(color, scene, camtf, frag, res, zoom, msaa, count, data)\\\n{\\\n    color = vec3(0.);\\\n    vec2 r = res;\\\n    vec2 f = frag;\\\n    vec2 uv = f / r;\\\n    const int c = count;\\\n    vec2[c] m = msaa;\\\n    float weight = 1.0 / float(c);\\\n    for (int i = 0; i < c; ++i)\\\n    {\\\n        Ray r = uvToRay\\\n        (\\\n            uv,\\\n            r.x/r.y,\\\n            zoom,\\\n            m[i] / r.y\\\n        );\\\n        r = camtf(r,f,data);\\\n        color += scene(r,f,data);\\\n    }\\\n    color *= weight;\\\n}\nvec2 conv2(vec2 samples[9], float weights[9])\n{\n    vec2 result;\n    for(int i = 0; i < 9; i++)\n    {\n        result += samples[i] * weights[i];\n    }\n    \n    return result;\n}\nvec3 conv3(vec3 samples[9], float weights[9])\n{\n    vec3 result;\n    for(int i = 0; i < 9; i++)\n    {\n        result += samples[i] * weights[i];\n    }\n    \n    return result;\n}\n\nvec2 sqrtComplex(vec2 z) {\n    float magnitude = sqrt(z.x * z.x + z.y * z.y); // |z|\n    float x = sqrt((magnitude + z.x) / 2.0);\n    float y = z.y / (2.0 * x);\n    return vec2(x, y); // Returns one of the square roots\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Gradient\n\nvec4 getColor(vec2 uv)\n{\nreturn texture(iChannel0, uv);\n    return vec4(sin(length(uv-vec2(0.5f))*100.0)); //texture(iChannel0, uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 uvAndOffset = vec4(fragCoord,1,1) / iChannelResolution[0].xyxy;\n    \n    vec3 samples[9];\n    int i = 0;\n    for(int y = -1; y <= 1; y++)\n    for(int x = -1; x <= 1; x++)\n    {\n        samples[i] = getColor(uvAndOffset.xy + uvAndOffset.zw * vec2(x,y)).rgb;\n        i++;\n    }    \n    \n    const float hKern[9] = float[9]\n    (\n        -1. / 8., 0., 1. / 8.,\n        -2. / 8., 0., 2. / 8.,\n        -1. / 8., 0., 1. / 8.\n    );\n    \n    const float vKern[9] = float[9]\n    (\n         1. / 8., 2. / 8., 1. / 8.,\n         0., 0., 0.,\n        -1. / 8.,-2. / 8.,-1. / 8.\n    );\n\n    vec3 h = conv3(samples, hKern);\n    vec3 v = conv3(samples, vKern);\n    \n    vec2 vec = vec2( dot(h,vec3(1)), dot(v,vec3(1)) );\n     \n    fragColor = vec4(safeNormalize(vec), length(vec), 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "vec2 squareNormalized(vec2 x) {\n    float new_x = x.x * x.x - x.y * x.y;\n    float new_y = 2.0 * x.x * x.y;\n    return vec2(new_x, new_y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec4 uvAndOffset = vec4(fragCoord,1,1) / iChannelResolution[0].xyxy;\n    \n    vec2 samples[9];\n    int i = 0;\n    for(int y = -1; y <= 1; y++)\n    for(int x = -1; x <= 1; x++)\n    {\n        samples[i] = texture(iChannel0, uvAndOffset.xy + uvAndOffset.zw * vec2(x,y)).xy;\n        i++;\n    }    \n    \n    const float hKern[9] = float[9]\n    (\n        -1. / 8., 0., 1. / 8.,\n        -2. / 8., 0., 2. / 8.,\n        -1. / 8., 0., 1. / 8.\n    );\n    \n    const float vKern[9] = float[9]\n    (\n         1. / 8., 2. / 8., 1. / 8.,\n         0., 0., 0.,\n        -1. / 8.,-2. / 8.,-1. / 8.\n    );\n\n    vec2 h = conv2(samples, hKern);\n    vec2 v = conv2(samples, vKern);\n    \n    /*vec2 c  = texture(iChannel0, uvAndOffset.xy                               ).xy;\n    vec2 hp = texture(iChannel0, uvAndOffset.xy + uvAndOffset.zw * vec2( 1, 0)).xy;\n    vec2 hn = texture(iChannel0, uvAndOffset.xy + uvAndOffset.zw * vec2(-1, 0)).xy;\n    vec2 vp = texture(iChannel0, uvAndOffset.xy + uvAndOffset.zw * vec2( 0, 1)).xy;\n    vec2 vn = texture(iChannel0, uvAndOffset.xy + uvAndOffset.zw * vec2( 0,-1)).xy;\n     \n    vec2 h = hp-hn;\n    vec2 v = vp-vn;*/\n     \n    fragColor = vec4((squareNormalized(safeNormalize(samples[4].xy))), sqrt(dot(h,h) + dot(v,v)), 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define TECHNIQUE 1\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if TECHNIQUE == 0\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec2 dir = texture(iChannel0, uv).xy / iResolution.xy;\n    \n    float center = texture(iChannel0, uv).z;\n    float pos = texture(iChannel0, uv + dir).z;\n    float neg = texture(iChannel0, uv - dir).z;\n    \n    fragColor = vec4(vec3(max(0., center * 2. - pos - neg)), 1);\n#elif TECHNIQUE == 1    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 uvWithOffset = uv;\n    \n    uint rngState = uint\n    (\n        uint(iFrame) * uint(1973) \n    ) | uint(1);\n    \n    // Using time-varying blue noise as subpixel offsets \n    // will kill persistent moire patterns.\n    // If you modify the shader to accumulate,\n    // it'll converge on a nice image with no aliasing.\n    // (It uses gaussian windowing, not an ideal lowpass filter however.)\n    vec4 blueNoise = sampleBlueNoise(iChannel2, fragCoord, rngState);\n    uvWithOffset += uniform01ToGauss(blueNoise.xy) * 0.5 / iResolution.xy; \n    \n    vec2 dir = sqrtComplex(safeNormalize(texture(iChannel0, uvWithOffset).xy));\n    dir.x = -dir.x;\n    vec2 uvOffs = dir / iResolution.xy;\n    float center = texture(iChannel0, uvWithOffset).z;\n    float pos = texture(iChannel0, uvWithOffset + uvOffs).z;\n    float neg = texture(iChannel0, uvWithOffset - uvOffs).z;\n    \n    \n    vec2 posGrad = safeNormalize(texture(iChannel1, uvWithOffset + uvOffs).xy);\n    vec2 negGrad = safeNormalize(texture(iChannel1, uvWithOffset - uvOffs).xy);\n    \n    posGrad.x = -posGrad.x;\n    negGrad.x = -negGrad.x;\n    float posSign = dot(posGrad, dir);\n    float negSign = dot(negGrad, -dir);\n    \n    float val = (posSign + negSign) >= 0. ? 1. : -1.;\n    \n    \n    fragColor = texture(iChannel3, uv) + vec4(vec3(center > pos && center > neg ? val : 0.), 1);\n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}