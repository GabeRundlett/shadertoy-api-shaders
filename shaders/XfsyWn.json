{
    "Shader": {
        "info": {
            "date": "1721608522",
            "description": "Capture the satellite for repairs.  Green: Success.  Red: Damage.\nA S - rotate arm base.  Z X - rotate first arm segment.\nK L - rotate 2nd arm segment.  N M - rotate end arm segment.\nAlternating arm and bay camera views.\n",
            "flags": 48,
            "hasliked": 0,
            "id": "XfsyWn",
            "likes": 8,
            "name": "Space Shuttle Arm",
            "published": 3,
            "tags": [
                "game",
                "mechanics"
            ],
            "usePreview": 0,
            "username": "dray",
            "viewed": 129
        },
        "renderpass": [
            {
                "code": "/*\nJust a doodle I was thinking of.\nThis could be much better and I may improve it when I have time.\nEasy suggestions welcome - how do you fix the camera distortions ?\nNew for me: Multiple camera views. Some 3d rotation fun. Subtracting SDFs.\nI did segments like the arm on a Hercules Monochrome Card many years ago.\nThe buffer A is not working on IPhone for the angle control - but there is no keyboard anyway.\n*/\n\nfloat pow2(float x,int p2) { // power of power of 2\n  while ( p2-- > 0 ) x *= x;\n  return x;\n}\n\n#define max3(V) max((V).x,max((V).y,(V).z))\n\n// sdf of orthogonal box at 0, originally iq https://www.shadertoy.com/view/Xds3zN\nfloat sdBox( vec3 pt, vec3 box, float r )\n{\n    vec3 d = abs(pt) - box + r; // everything is symmetrical so just 3 sides need examination\n    return min(max3(d),.0) + length(max(d,.0)) - r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) // https://www.shadertoy.com/view/Xds3zN from iq\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n/*\nfloat sdCapsuleOrth( vec3 pt, vec3 orig, float len, float r ) // my own version of https://www.shadertoy.com/view/Xds3zN from iq\n{\n\tpt -= orig;\n    pt = abs(pt);\n    if ( pt.x > len ) pt.x -= len; else pt.y = 0.;\n\treturn length(pt) - r;\n}\n*/\n\nfloat sdSphere(vec3 pt,float r) {\n    return length(pt) - r;\n}\n\nvec3 light;\n\nmat3 rot_base;\nvec3 seg_a=vec3(0,-5,8);\nvec3 seg_b=vec3(0,6,0);\nvec3 seg_c=vec3(0,5,0);\nvec3 seg_d=vec3(0,1,0);\n\nvec3 sat=vec3(-6,3,6);\n\nvec2 Dist(vec3 pt) { // return distance to closest object and object\n\n  float dist = 10000.;\n  int id = 1;\n\n#define IF(DIST,ID) { float tmp = DIST; if ( tmp < dist ) dist = tmp, id = ID; }\n\n  // Ship\n  IF ( max( sdCapsule( pt, vec3(-10,-7,8), vec3(10,-7,8), 4. ), // ship\n            -sdBox( pt-vec3(0,-3,8), vec3(6,3,3.5), .0 ) ),  2 ) // bay\n  IF ( sdBox( pt-vec3(-7.5,-6,8), vec3(2), .0 ), 3 ) // stuff\n  IF ( sdBox( pt-vec3(-7,-6.6,8), vec3(2), .0 ), 5 ) // stuff\n  IF ( sdBox( pt-vec3(6,-6,8), vec3(1), .0 ), 3 ) // stuff\n\n  // Arm\n  IF( sdBox( rot_base*(pt-vec3(0,-6,8)), vec3(1,1,1), .3 ), 3 ) // base\n  IF( sdCapsule( pt, seg_a, seg_b, .2 ), 3 )\n  IF( sdCapsule( pt, seg_b, seg_c, .2 ), 3 )\n  IF( sdCapsule( pt, seg_c, seg_d, .2 ), 3 )\n\n  // Satellite\n  IF ( sdSphere( pt - sat, .5 ), 3 )\n  vec3 aa=vec3(-1,1,0);\n  IF ( sdCapsule( pt, sat+aa, sat-aa, .07 ), 4 )\n  aa=vec3(1,0,-1);\n  IF ( sdCapsule( pt, sat+aa, sat-aa, .07 ), 4 )\n  aa=vec3(1,1,0);\n  IF ( sdCapsule( pt, sat+aa, sat-aa, .07 ), 4 )\n\n  return vec2(dist,id);\n}\n\nvec4 March(vec3 beg,vec3 dir) { // return intersection point and object of ray\n  float dist = 0.;\n  vec3 pos;\n  for ( int stps = 0; stps < 300; ++stps ) {\n    pos = beg + dir * dist;\n    if ( pos.z < -30. || dist > 100. ) return vec4(pos,91.); // hit cameraman or space\n    vec2 obj = Dist( pos );\n    dist += obj.x;\n    if ( obj.x < .001 ) return vec4( pos, obj.y );\n  }\n  return vec4( pos, 90. );\n}\n\nvec3 Normal(vec3 pt) {\n  float dist = Dist(pt).x;\n  float delta = .001; // large delta gives rounded corners\n  vec3 norm = dist - vec3(\n    Dist(pt-vec3(delta, 0., 0.)).x, \n    Dist(pt-vec3( 0.,delta, 0.)).x, \n    Dist(pt-vec3( 0., 0.,delta)).x );\n  return normalize( norm );\n}\n\n#define MAT3xz(ANG) mat3( cos(ANG),0,sin(ANG), 0,1,0, -sin(ANG),0,cos(ANG) )\n//#define MAT3zy(ANG) mat3( 1,0,0, 0,cos(ANG),sin(ANG), 0,-sin(ANG),cos(ANG) )\n#define MAT3xy(ANG) mat3( cos(ANG),sin(ANG),0, -sin(ANG),cos(ANG),0, 0,0,1 )\n//#define MAT3un mat3(1,0,0, 0,1,0, 0,0,1)\n\n//#define ROTORG(V,O,R)  ((V)-(O))*R+(O) // rotate 3d around origin\n\nvec3 View(vec3 cam,vec3 camdir) {\n  camdir = normalize(camdir);\n  vec4 hit = March( cam, camdir );\n  int obj = int(hit.w);\n\n  light = vec3( 20., 20., -10.);\n\n  vec3 litdir = normalize( light - hit.xyz );\n  float difu = .7;\n\n  //vec4 shadow = obj <= -50 && abs(uv.x) < .7 ? March( hit.xyz+litdir*.01, litdir ) : vec4(100.);\n  //if ( shadow.w == 100. ) // light is not blocked\n  {\n    vec3 norm = Normal(hit.xyz);\n    difu = clamp( pow( dot( norm, litdir ), .25 ), difu, 1. );\n  }\n  \n  vec3 col = vec3(0.);\n  \n  if (obj == 2)\n    col = vec3(.8,.8,.8);\n  else if (obj == 3)\n    col = vec3(.8,.8,1.0);\n  else if (obj == 4)\n    col = vec3(.8,.8,.2);\n  else if (obj == 5)\n    col = vec3(.6,.8,.1);\n\n  col *= difu;\n  return col + ( vec3(pow2(difu,5)) - col ) * .5;\n}\n\nvec3 camdir(vec3 dir,vec3 uvz) {\n    vec3 cd = normalize(dir);\n    vec3 cr = normalize(cross(vec3(0,1,0), cd));\n    vec3 cu = normalize(cross(cd, cr));\n    return mat3(cr, cu, cd) * normalize(uvz);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // update positions\n  float ang_base, ang_1, ang_2, ang_3;\n  if (GETVAL(CHECK)==0.) { // buffer is not working\n      ang_base=0., ang_1=1.4, ang_2=-3., ang_3=1.;\n  } else {\n      ang_base=GETVAL(ANG_BASE), ang_1=GETVAL(ANG_1), ang_2=GETVAL(ANG_2), ang_3=GETVAL(ANG_3);\n  }\n  \n  rot_base = MAT3xz(ang_base);\n  mat3 rott = MAT3xy(ang_1) * rot_base;\n  seg_b = seg_a + vec3(0,6,0) * rott;\n  rott = MAT3xy(ang_2) * rott;\n  seg_c = seg_b + vec3(0,5,0) * rott;\n  rott = MAT3xy(ang_3) * rott;\n  seg_d = seg_c + vec3(0,1,0) * rott;\n\n  vec2 uv = (fragCoord.xy - iResolution.xy/2.) / min(iResolution.x,iResolution.y); // \n    \n  vec3 col;\n  \n  if ( uv.x > 0. && uv.y > 0. ) {  // upper right corner section\n    vec3 cam, dir; float zm, scl;\n    if (mod(iTime,4.)<2.) dir = seg_d-seg_c, cam = seg_d+dir*.2, zm=.2, scl=1.;\n    else  cam = vec3(8,-2,8), dir = sat-cam, zm=1., scl=1.;\n    float dist = sdSphere( seg_d - sat, .5 );\n    col = uv.x < .005 || uv.y < .005 ? \n      ( dist < 0. ? vec3(1,0,0) : dist < .1 ? vec3(0,1,0) : vec3(1) ) : \n      View( cam+dir*.1, camdir(dir,vec3((uv-.25)*scl, zm)) );\n  } else { // rest of screen\n    col = View( vec3( 2., .8, -8.) , vec3( uv, 1. ) );\n  }\n\n  fragColor = vec4( col, 1. );\n\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define keyDown(code)    ( texelFetch(iChannel1,ivec2(code,0),0).x > 0.)\n\n// https://www.shadertoy.com/view/llySRh\n#define cLEFT 37\n#define cUP 38\n#define cRIGHT 39\n#define cDOWN 40\n#define cPAGEUP 33\n#define cPAGEDOWN 34\n#define cEND 35\n#define cHOME 36\n#define cSHIFT 16\n#define cCTRL 17\n#define cALT 18\n\n// ASCII\n#define cSpace  32 //  \n#define cExcl 33 // !\n#define cDblQuote 34 // \"\n#define cSharp 35 // #\n#define cDollar 36 // $\n#define cPct 37 // %\n#define cAmp 38 // &\n#define cSngQuote 39 // '\n#define cLParen 40 // (\n#define cRParen 41 // )\n#define cAst 42 // *\n#define cPlus 43 // +\n#define cComma 44 // ,\n#define cMinus 45 // -\n#define cPeriod 46 // .\n#define cSlash 47 // /\n#define c0 48 // 0\n#define c1 49 // 1\n#define c2 50 // 2\n#define c3 51 // 3\n#define c4 52 // 4\n#define c5 53 // 5\n#define c6 54 // 6\n#define c7 55 // 7\n#define c8 56 // 8\n#define c9 57 // 9\n#define cColon 58 // :\n#define cSemiCol 59 // ;\n#define cLT 60 // <\n#define cEQ 61 // =\n#define cGT 62 // >\n#define cQuest 63 // ?\n#define cAt 64 // @\n#define cA 65 // A\n#define cB 66 // B\n#define cC 67 // C\n#define cD 68 // D\n#define cE 69 // E\n#define cF 70 // F\n#define cG 71 // G\n#define cH 72 // H\n#define cI 73 // I\n#define cJ 74 // J\n#define cK 75 // K\n#define cL 76 // L\n#define cM 77 // M\n#define cN 78 // N\n#define cO 79 // O\n#define cP 80 // P\n#define cQ 81 // Q\n#define cR 82 // R\n#define cS 83 // S\n#define cT 84 // T\n#define cU 85 // U\n#define cV 86 // V\n#define cW 87 // W\n#define cX 88 // X\n#define cY 89 // Y\n#define cZ 90 // Z\n#define cLBrack 91 // [\n#define cBkSlash 92 // \\\n#define cRBrack 93 // ]\n#define cHat 94 // ^\n#define cUnder 95 // _\n#define cBkQuote 96 // `\n#define ca 97 // a\n#define cb 98 // b\n#define cc 99 // c\n#define cd 100 // d\n#define ce 101 // e\n#define cf 102 // f\n#define cg 103 // g\n#define ch 104 // h\n#define ci 105 // i\n#define cj 106 // j\n#define ck 107 // k\n#define cl 108 // l\n#define cm 109 // m\n#define cn 110 // n\n#define co 111 // o\n#define cp 112 // p\n#define cq 113 // q\n#define cr 114 // r\n#define cs 115 // s\n#define ct 116 // t\n#define cu 117 // u\n#define cv 118 // v\n#define cw 119 // w\n#define cx 120 // x\n#define cy 121 // y\n#define cz 122 // z\n#define cLCurly 123 // {\n#define cBar 124 // |\n#define cRcurly 125 // }\n#define cTilde 126 // ~\n\n#define SPEED (iTimeDelta*.2)\n\nvoid mainImage( out vec4 O, in vec2 U ) {\n    ivec2 V=ivec2(U);\n    O = texelFetch(iChannel0, V, 0); // get state to refresh data\n    if (iFrame < 2) O=vec4(0);\n    if (V.x == CHECK)\n        O=vec4(1);\n    else if (V.x == ANG_BASE) { // looking at ANG_BASE value\n        if (keyDown(cA)) O.x += SPEED;\n        if (keyDown(cS)) O.x -= SPEED;\n        }\n    else if (V.x == ANG_1) { // looking at ANG_1 value\n        if (keyDown(cZ)) O.x += SPEED;\n        if (keyDown(cX)) O.x -= SPEED;\n        if(iFrame<2) O.x = 1.4;\n        O.x = clamp( O.x, -1.4, 1.4 );\n        }\n    else if (V.x == ANG_2) { // looking at ANG_2 value\n        if (keyDown(cK)) O.x += SPEED;\n        if (keyDown(cL)) O.x -= SPEED;\n        if(iFrame<2) O.x = -3.;\n        O.x = clamp( O.x, -3., .2 );\n        }\n    else if (V.x == ANG_3) { // looking at ANG_3 value\n        if (keyDown(cN)) O.x += SPEED;\n        if (keyDown(cM)) O.x -= SPEED;\n        if(iFrame<2) O.x = 1.;\n        O.x = clamp( O.x, -3., 3. );\n        }\n    O.w = 1.0;\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n#define GETVAL(NDX) texelFetch(iChannel0, ivec2(NDX,0), 0).x\n#define ANG_BASE  0\n#define ANG_1     1\n#define ANG_2     2\n#define ANG_3     3\n\n#define CHECK    30   // check if buffer is working at all\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}