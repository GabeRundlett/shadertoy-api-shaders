{
    "Shader": {
        "info": {
            "date": "1658975417",
            "description": "Attempting to make an outline of an object in one march.",
            "flags": 0,
            "hasliked": 0,
            "id": "fdGfDt",
            "likes": 1,
            "name": "Outline Shader attempt.",
            "published": 3,
            "tags": [
                "outline"
            ],
            "usePreview": 0,
            "username": "intrakits",
            "viewed": 274
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURFACE_DIST 0.01\n#define AA 1\n\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat dBox(vec3 p, vec3 s){\n    return length(max(abs(p)-s,0.));\n}\n\nvec2 colMin(vec2 res, vec2 obj){\n    res.x = min(obj.x,res.x);\n    if(obj.x == res.x){\n        res.y = obj.y;\n    }\n    return res;\n}\n\nvec2 GetDist(vec3 p){\n   vec2 res = vec2(p.y,1);\n   p.xz*=Rot(iTime);\n   p.xy*=Rot(iTime);\n   vec2 box = vec2(dBox(p, vec3(1,1,1)),2);\n   res = colMin(res,box);\n   return res;\n}\nvec2 RayMarch(vec3 ro, vec3 rd){\n    float width = .01;\n    // distance from origin\n    vec3 rd1 = rd+vec3(width,0,0);\n    vec3 rd2 = rd+vec3(-width,0,0);\n    vec3 rd3 = rd+vec3(0,width,0);\n    vec3 rd4 = rd+vec3(0,-width,0);\n    vec2 dO=vec2(0.,0.);\n    vec2 dO1=vec2(0.,0.);\n    vec2 dO2=vec2(0.,0.);\n    vec2 dO3=vec2(0.,0.);\n    vec2 dO4=vec2(0.,0.);\n    // march until max steps is achieved or object hit\n    for(int i=0; i <MAX_STEPS; i++){\n        // current point being evaluated\n        vec3 p = ro + dO.x*rd;\n        vec3 p1 = ro + dO1.x*rd1;\n        vec3 p2 = ro + dO2.x*rd2;\n        vec3 p3 = ro + dO3.x*rd3;\n        vec3 p4 = ro + dO4.x*rd4;\n        \n\n        // get distance to seam\n        vec2 ds = GetDist(p);\n        vec2 ds1 = GetDist(p1);\n        vec2 ds2 = GetDist(p2);\n        vec2 ds3 = GetDist(p3);\n        vec2 ds4 = GetDist(p4);\n        //move origin to new point\n        dO+=ds.x;\n        dO1+=ds1.x;\n        dO2+=ds2.x;\n        dO3+=ds3.x;\n        dO4+=ds4.x;\n        if(ds.y!=ds1.y||ds.y!=ds2.y||ds.y!=ds3.y||ds.y!=ds4.y){\n            dO.y=3.;\n        }\n        else if(ds.x < SURFACE_DIST){\n            dO.y = ds.y;\n            break;\n        }\n        else if( dO.x > MAX_DIST){\n            dO.y= -1.;\n            break;\n        }\n    }\n    return dO;\n}\nvec3 GetNormal(vec3 p){\n    //distance to point being analyzed\n    float d = GetDist(p).x;\n    \n    //distance to another point along the objects surface that is closeby\n    vec2 e = vec2(0.01,0);\n    \n    //slope between the two points\n    //note: swizzel is the .xxy or .yyx etc\n    vec3 n = d - vec3(\n         GetDist(p-e.xyy).x,\n         GetDist(p-e.yxy).x,\n         GetDist(p-e.yyx).x);\n         \n    return normalize(n);\n    \n}\nfloat GetLight(vec3 p){\n    //position of the light source\n    vec3 lightPos = vec3(4,5.,-3);\n    \n    lightPos.xz += vec2(sin(iTime),cos(iTime));\n    //light vector\n    vec3 l = normalize(lightPos-p);\n    \n    //normal of object\n    vec3 n = GetNormal(p);\n    \n    // dot product of the light vector and normal of the point\n    // will give us the amount of lighting to apply to the point\n    // dot() evaluates to values between -1 and 1, so we will clamp it\n    float diff = clamp(dot(n, l),0.,1.);\n    \n    // calculate if point should be a shadow:\n    // raymarch from point being calculated towards light source\n    // if hits surface of something else before the light,\n    // then it must be obstructed and thus is a shadow\n    // the slight offset \"p+n*SURFACE_DIST*1.1\" is needed to ensure the\n    // break condistions in the function are not met too early\n    float d = RayMarch(p+n*SURFACE_DIST*1.1,l).x;\n    if(d < length(lightPos-p)){\n        diff *= .1;\n    }\n    \n    return diff;\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 Render (inout vec3 ro, inout vec3 rd, inout float reflVal){\n//------------------\n    vec2 d = RayMarch(ro,rd);\n// position of point\n    // start at ray origin\n    // move d units in the ray direction\n    vec3 p = ro + rd *d.x;\n //get diffuse lighting\n    float diff = GetLight(p);\n    vec3 col = vec3(0);\n    col = vec3(diff);\n    \n    vec3 n = GetNormal(p);\n    vec3 r = reflect(rd, n);\n    vec3 refl = texture(iChannel0, r).rgb;\n    refl= refl*abs(n.y) + refl*abs(n.z) + refl*abs(n.x);\n    \n    if(d.y == 1.){\n        col *= vec3(1,0,0);\n        reflVal = 0.;\n    }\n    else if(d.y==2.){\n        col*=vec3(1);\n       \n       reflVal = 0.1;\n    }\n    else if(d.y==3.){\n        col=vec3(0,1,0);\n       \n       reflVal = 0.1;\n    }\n     ro = p+n*SURFACE_DIST*3.;\n     rd=r;\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    // origin is now (0,0)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n   \n    \n    //camera\n    //-----------------\n    // ray origin\n    //controls position\n    vec3 ta = vec3(0, 1,0);\n    vec3 ro = ta + vec3( 0, .5,-5.);\n    mat3 ca = setCamera( ro, ta,0.);\n//    vec3 ro = vec3(0,3,-5);\n\n    \n    //ray dir\n    //controls rotation\n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 pt = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 pt = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n    vec3 rd = ca * normalize( vec3(pt,2.5) );\n    \n    float reflVal = 1.;\n    vec3 col = Render(ro,rd,reflVal);\n    vec3 bounce = reflVal*Render(ro,rd,reflVal);\n    col += bounce;\n    /*vec3 bounce2 = reflVal*Render(ro,rd,reflVal);\n    col += bounce2;*/\n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}