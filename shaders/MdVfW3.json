{
    "Shader": {
        "info": {
            "date": "1531383678",
            "description": "Oren Nayar Diffuse Model\nHum...this is just I write a tutorial about how to accelerate GI calculate.\nOr you can drag the mouse rotate scene,:)",
            "flags": 32,
            "hasliked": 0,
            "id": "MdVfW3",
            "likes": 63,
            "name": "Super Fast GI(Oren Nayar)",
            "published": 3,
            "tags": [
                "gi",
                "fast",
                "mis",
                "orennayar",
                "orennayar",
                "russianroulette"
            ],
            "usePreview": 0,
            "username": "834144373",
            "viewed": 2725
        },
        "renderpass": [
            {
                "code": "/*\n\tSuper Fast GI(Oren Nayar) by 834144373\n\n\tLicense: CC3.0 BY-NC-SA\n\t\n\thum...it seems that the number 834... not friendly to read,\n\t\tor you can call me TNWX or 恬纳微晰,my really name is 祝元洪(YuanHong Zhu)\n\t\n\tAll details you can easy find on the \"common\" and \"BufA\"\n\n*/\n\n/*\n\tAnd you didn't read wrong words,more and more confidential\n\twill be coming soon\n*/\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec2 uv = U/R;\n    C = texture(iChannel0,uv);\n    \n    /*\n\t\tWe should must convert the linear RGB to gamma,\n\t\tAs my think,we do all path tracing light transport is base on the linear.\n    Note: Gamma is correct the luminance,\n\t\t human's eyes just interesting in the dark eara,\n\t\t so we must to bright the lower luminance. \n\n\t\t The simple gamma is pow(c,2.2),and the other screen with 1.8，2.4，2.6....\n\t\t but like my screen supports sRGB.\n\n\t\thum...and after class thinking,the screen already do the correct,why I must correct again? \n\t*/\n    \n    //C.rgb = pow(C.rgb,vec3(1./2.2));\n    /*\n\t\tThanks for mantra report the bug on linux.\n    \thum...I use wrong again with \"clamp()\" function in Linear2sRGB()\n\t*/\n\tC.rgb = Linear2sRGB(C.rgb);\n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define M_PI_F\t 3.14159274101257\n#define M_H_PI_F 1.5707963267948966\n#define M_2PI_F  6.2831853071795864 \n#define M_1_PI_F 0.3183098861837067\n#define INFINITY 1000000.0\n#define INFINITY_MIN 1.175494351e-38\n#define OFFSET_VALUE 0.00001\n#define R iResolution.xy\n\nstruct OrenNayarBsdf {\n\t//vec3 weight;\n    int id;\n    vec2 uv;\n    vec3 albedo;\n\t//float sample_weight;\n\tvec3 nDir;\n\tfloat roughness;\n\tfloat a;\n\tfloat b;\n};\n    \nfloat seed;\nfloat GetRandom(){return fract(sin(seed++)*43758.5453123);}    \n    \nvoid frisvad(in vec3 n, out vec3 f, out vec3 r){\n    if(n.z < -0.999999) {\n        f = vec3(0.,-1,0);\n        r = vec3(-1, 0, 0);\n    } else {\n    \tfloat a = 1./(1.+n.z);\n    \tfloat b = -n.x*n.y*a;\n    \tf = vec3(1. - n.x*n.x*a, b, -n.x);\n    \tr = vec3(b, 1. - n.y*n.y*a , -n.y);\n    }\n}\nmat3 CoordBase(vec3 n){\n\tvec3 x,y;\n    frisvad(n,x,y);\n    return mat3(x,y,n);\n}\nvec3 ToOtherSpaceCoord(mat3 otherSpaceCoord,vec3 vector){\n\treturn vector * otherSpaceCoord;\n}\nvec3 RotVector(mat3 otherSpaceCoord,vec3 vector){\n\treturn otherSpaceCoord * vector;\n}\n\n/* cosin weight */\nfloat GetCosWeightSpherePDF(in vec3 nDir,in vec3 wi){\n\tfloat pdf = 1.;\n    float costheta = max(0.,dot(nDir,wi));\n    pdf = costheta*M_1_PI_F;\n    return pdf;\n}\nvec3 sample_cos_hemisphere(in vec3 N,float x1, float x2,out float pdf){\n    float phi = M_2PI_F * x1;\n\tfloat r = sqrt(x2);\n\tx1 = r * cos(phi);\n\tx2 = r * sin(phi);\n\tvec3 T, B;\n\tfrisvad (N, T, B);\n\tfloat costheta = sqrt(max(1.0f - x1 * x1 - x2 * x2, 0.0));\n\tpdf = M_1_PI_F;\n\treturn x1 * T + x2 * B + costheta * N;\n}\n/* sample direction uniformly distributed in hemisphere */\nfloat GetUniformDiffusePDF(){\n    return 0.5 * M_1_PI_F;\n}\nvec3 sample_uniform_hemisphere(in vec3 N,float x1, float x2, out float pdf){\n\tfloat z = x1;\n\tfloat r = sqrt(max(0., 1. - z*z));\n\tfloat phi = M_2PI_F * x2;\n\tfloat x = r * cos(phi);\n\tfloat y = r * sin(phi);\n\tvec3 T, B;\n\tfrisvad (N, T, B);\n\tpdf = 0.5 * M_1_PI_F;\n    return x * T + y * B + z * N;\n}\n\nvoid BSDF_Oren_Nayar_Setup(inout OrenNayarBsdf bsdf){\n\tfloat sigma = bsdf.roughness;\n\tsigma = clamp(sigma,0.,1.);\n\tfloat div = 1. / (M_PI_F + ((3. * M_PI_F - 4.) / 6.) * sigma);\n\tbsdf.a = div;\n\tbsdf.b = sigma * div;\n}\n\n//BSDF Oren-Nayar evalution\nvec3 BSDF_Oren_Nayar_GetIntensity(OrenNayarBsdf bsdf,vec3 n,vec3 v,vec3 l){\n\tfloat nl = max(dot(n, l), 0.);\n\tfloat nv = max(dot(n, v), 0.);\n\tfloat t = max(dot(l, v),0.) - nl * nv;\n\tif(t > 0.)\n\t\tt /= max(nl, nv) + INFINITY_MIN;\n\tfloat is = nl * (bsdf.a + bsdf.b * 0.1);\n\treturn vec3(is);\n}\n\n\n//!!!!!! For BSDF light sample\nvec3 BSDF_Oren_Nayar_Sample(OrenNayarBsdf bsdf,vec3 Ng,vec3 vDir,float x1, float x2,out vec3 eval,out vec3 wi,out float pdf){\n\t//pre values\n    BSDF_Oren_Nayar_Setup(bsdf);\n    wi = sample_uniform_hemisphere(bsdf.nDir, x1, x2, pdf);\n\tif(dot(Ng, wi) > 0.){\n\t\teval = BSDF_Oren_Nayar_GetIntensity(bsdf, bsdf.nDir, vDir, wi);\n\t}\n\telse{\n\t\tpdf = 0.;\n\t\teval = vec3(0.);\n\t}\n\treturn eval;\n}\n//!!!!!! For Single Scatter Sample\nvec3 BSDF_Oren_Nayar_Eval_Reflect(OrenNayarBsdf bsdf, vec3 vDir, vec3 wi, float pdf){\n\tif(dot(bsdf.nDir, wi) > 0.) {\n\t\tpdf = 0.5 * M_1_PI_F;\n\t\treturn BSDF_Oren_Nayar_GetIntensity(bsdf, bsdf.nDir, vDir, wi);\n\t}\n\telse {\n\t\tpdf = 0.0f;\n\t\treturn vec3(0.);\n\t}\n}\n\n\n\n//------------Multiple Importance Sample Weight-----------\n/*\n\theuristic\n\there βis 2;so power of coeff\n*/\nfloat MISWeight(float a,float b){\n\tfloat a2 = a*a;\n\tfloat b2 = b*b;\n\treturn a2/(a2+b2);\n}\nfloat MISWeight(float coffe_a,float aPDF,float coffe_b,float bPDF){\n    return MISWeight(coffe_a * aPDF,coffe_b*bPDF);\n}\n\n/*\n\thttps://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ToneMapping.hlsl\n*/\nvec3 Linear2sRGB(vec3 color){\n    vec3 x = color * 12.92;\n    vec3 y = 1.055 * pow(clamp(color,0.,1.),vec3(0.4166667)) - 0.055;\n    vec3 clr = color;\n    clr.r = (color.r < 0.0031308) ? x.r : y.r;\n    clr.g = (color.g < 0.0031308) ? x.g : y.g;\n    clr.b = (color.b < 0.0031308) ? x.b : y.b;\n    return clr;\n}\nvec3 sRGB2Linear(vec3 color){\n    vec3 x = color / 12.92f;\n    vec3 y = pow(max((color+0.055f)/1.055, 0.0),vec3(2.4));\n    vec3 clr = color;\n    clr.r = color.r <= 0.04045 ? x.r : y.r;\n    clr.g = color.g <= 0.04045 ? x.g : y.g;\n    clr.b = color.b <= 0.04045 ? x.b : y.b;\n    return clr;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define GI_DEPTH 5\n\n/*\n\tif we use the \"Multiple Importance Sample\"\n\thttps://graphics.stanford.edu/courses/cs348b-03/papers/veach-chapter9.pdf\n\tcombine direct light sample and bsdf light sample\n*/\nconst bool UseMIS = true;\n/*\n\tSkylighting form skybox,as well as known the IBL \"Image Base Lighting\"\n\thum...but here no HDR,:)\n*/\nconst float SkyLightIntensity = 1.7;//1.7 up for bright,0.15 lower for weak lighting show AO\nconst float AreaLightIntersity = 10.;\n//------------------------------------Debug-----------------------------------\n//#define Linux //else for Windows system\n\n/*Scene Objects*/\n#define N_SPHERES 1\n#define N_QUADS 2\n#define N_BOXES 1\n\n/*Type*/\n#define LIGHT 0\n#define DIFF 1\n#define WOOD 10\n\n/*Material ID Name*/\n#define CenterSphere 0\n#define Floor 1\n#define AreLighing 2\n#define Cuboid 3\n\nconst vec3 LIGHTCOLOR = vec3(0.8,0.8,0.75);\nconst vec3 BACKGROUND_COL = vec3(0.336,0.336,0.336);\n\nconst vec3 ZERO = vec3(0.,0.,0.);\nconst vec3 ONE  = vec3(1.,1.,1.);\nconst vec3 UP   = vec3(0.,1.,0.);\n\n/* \n\thum...you can skip it,it's just intersection primary polygon,\n\tand you can easy find more free on public internet.:)\n*/\nstruct Ray { vec3 origin; vec3 direction; };\nstruct Sphere { float radius; vec3 position; vec3 emission; vec3 color; float roughness; int type; int id;};\nstruct Quad { vec3 normal; vec3 v0; vec3 v1; vec3 v2; vec3 v3; vec3 emission; vec3 color; float roughness; int type; int id;};\nstruct Box { vec3 minCorner; vec3 maxCorner; vec3 emission; vec3 color; float roughness; int type; int id;};\nstruct Intersection {vec3 surface;vec3 direction;float distance;vec2 uv; vec3 normal; vec3 emission; vec3 color; float roughness; int type; int id;};\n\nstruct Light{float radius;vec3 direction;vec3 emission;float radiance;float pdf;int type;};\nstruct Material{float id;vec2 uv;vec3 normal;vec3 specular;vec3 diffuse;float roughness;int type;}; \n\nSphere spheres[N_SPHERES];\nQuad quads[N_QUADS];\nBox boxes[N_BOXES];\n\nbool solveQuadratic(float A, float B, float C, out float t0, out float t1){\n\tfloat discrim = B*B-4.0*A*C;\n\tif ( discrim < 0.0 )\n        \treturn false;\n\tfloat rootDiscrim = sqrt(discrim);\n\tfloat Q = (B > 0.0) ? -0.5 * (B + rootDiscrim) : -0.5 * (B - rootDiscrim); \n\tfloat t_0 = Q / A; \n\tfloat t_1 = C / Q;\n\tt0 = min( t_0, t_1 );\n\tt1 = max( t_0, t_1 );\n\treturn true;\n}\nfloat SphereIntersect( float rad, vec3 pos, Ray ray ){\n\tfloat t = INFINITY;\n\tfloat t0, t1;\n\tvec3 L = ray.origin - pos;\n\tfloat a = dot( ray.direction, ray.direction );\n\tfloat b = 2.0 * dot( ray.direction, L );\n\tfloat c = dot( L, L ) - (rad * rad);\n\tif (!solveQuadratic( a, b, c, t0, t1))\n\t\treturn INFINITY;\n\tif ( t1 > 0.0 )\n\t\tt = t1;\n\tif ( t0 >= 0.0 )\n\t\tt = t0;\n\treturn t;\n}\nfloat QuadIntersect( vec3 v0, vec3 v1, vec3 v2, vec3 v3, vec3 normal, Ray r ){\n\tvec3 u, v, n;    // triangle vectors\n\tvec3 w0, w, x;   // ray and intersection vectors\n\tfloat rt, a, b;  // params to calc ray-plane intersect\n\t// get first triangle edge vectors and plane normal\n\tv = v2 - v0;\n\tu = v1 - v0; // switched u and v names to save calculation later below\n\t//n = cross(v, u); // switched u and v names to save calculation later below\n\tn = -normal; // can avoid cross product if normal is already known\n\tw0 = r.origin - v0;\n\ta = -dot(n,w0);\n\tb = dot(n, r.direction);\n\tif (b < 0.0001)   // ray is parallel to quad plane\n\t\treturn INFINITY;\n\t// get intersect point of ray with quad plane\n\trt = a / b;\n\tif (rt < 0.0)          // ray goes away from quad\n\t\treturn INFINITY;   // => no intersect\n\tx = r.origin + rt * r.direction; // intersect point of ray and plane\n\t// is x inside first Triangle?\n\tfloat uu, uv, vv, wu, wv, D;\n\tuu = dot(u,u);\n\tuv = dot(u,v);\n\tvv = dot(v,v);\n\tw = x - v0;\n\twu = dot(w,u);\n\twv = dot(w,v);\n\tD = 1.0 / (uv * uv - uu * vv);\n\t// get and test parametric coords\n\tfloat s, t;\n\ts = (uv * wv - vv * wu) * D;\n\tif (s >= 0.0 && s <= 1.0){\n\t\tt = (uv * wu - uu * wv) * D;\n\t\tif (t >= 0.0 && (s + t) <= 1.0){\n\t\t\treturn rt;\n\t\t}\n\t}\n\t// is x inside second Triangle?\n\tu = v3 - v0;\n\t///v = v2 - v0;  //optimization - already calculated above\n\tuu = dot(u,u);\n\tuv = dot(u,v);\n\t///vv = dot(v,v);//optimization - already calculated above\n\t///w = x - v0;   //optimization - already calculated above\n\twu = dot(w,u);\n\t///wv = dot(w,v);//optimization - already calculated above\n\tD = 1.0 / (uv * uv - uu * vv);\n\t// get and test parametric coords\n\ts = (uv * wv - vv * wu) * D;\n\tif (s >= 0.0 && s <= 1.0){\n\t\tt = (uv * wu - uu * wv) * D;\n\t\tif (t >= 0.0 && (s + t) <= 1.0){\n\t\t\treturn rt;\n\t\t}\n\t}\n\treturn INFINITY;\n}\nfloat BoxIntersect( vec3 minCorner, vec3 maxCorner, Ray r, out vec3 normal ){\n\tvec3 invDir = 1.0 / r.direction;\n\tvec3 tmin = (minCorner - r.origin) * invDir;\n\tvec3 tmax = (maxCorner - r.origin) * invDir;\n\tvec3 real_min = min(tmin, tmax);\n\tvec3 real_max = max(tmin, tmax);\n\tfloat minmax = min( min(real_max.x, real_max.y), real_max.z);\n\tfloat maxmin = max( max(real_min.x, real_min.y), real_min.z);\n\tif (minmax > maxmin){\n        if (maxmin > 0.0){ // if we are outside the box\n\t\t\tnormal = -sign(r.direction) * step(real_min.yzx, real_min) * step(real_min.zxy, real_min);\n\t\t\treturn maxmin;\t\n\t\t}\n        else if (minmax > 0.0){ // else if we are inside the box\n\t\t\tnormal = -sign(r.direction) * step(real_max, real_max.yzx) * step(real_max, real_max.zxy);\n\t\t\treturn minmax;\n\t\t}\n\t}\n\treturn INFINITY;\n}\n\nvoid SetupScene(){\n   \tspheres[0] = Sphere( 0.6, vec3(0., 0.3,-0.35),vec3(0.,0.,0.),vec3(1.,1.,1.), 1., DIFF,CenterSphere);\n    quads[0] = Quad(normalize(vec3(0.,-0.37,1.)),vec3(4.45624,2.70023,-16.2667), vec3(-4.45624,2.70023,-16.2667), vec3(-4.45624 ,11.247,-13.7397), vec3(4.45624,11.247,-13.7397), 2.*LIGHTCOLOR, vec3(1.),0.4, LIGHT,AreLighing);\n    quads[1] = Quad(vec3(0.,1.,0.),vec3(-300000,0.,-200000.), vec3(300000.,0.,-200000.), vec3(200000.,0.,200000.), vec3(-200000.,0.,200000.), vec3(0.,0.,0.), vec3(1.),0.05, DIFF,Floor);\n    boxes[0] =  Box(vec3(-0.7,1.,0.8),vec3(0.7,0.0,0.94), vec3(0.,0.,0.), vec3(0.,1.,0.), 0.1, DIFF,Cuboid);\n}\nfloat SceneIntersect( Ray r, inout Intersection intersec ){\n    float d = INFINITY;\t\n    float t = 0.;\n    vec3 normal = vec3(0.);\n    for(int i=0;i<spheres.length();i++){\n        t = SphereIntersect(spheres[i].radius,spheres[i].position,r);\n        if (t < d){\n            d = t;\n            intersec.normal = normalize((r.origin + r.direction * t) - spheres[i].position);\n            intersec.emission = spheres[i].emission;\n            intersec.color = spheres[i].color;\n            intersec.roughness = spheres[i].roughness;\n            intersec.type = spheres[i].type;\n            intersec.id = spheres[i].id;\n\t\t}\n    }\n    for(int i=0;i<quads.length();i++){\n        t = QuadIntersect( quads[i].v0, quads[i].v1, quads[i].v2, quads[i].v3, quads[i].normal, r );\n        if (t < d){\n        \td = t;\n            intersec.normal = normalize(quads[i].normal);\n            intersec.emission = quads[i].emission;\n            intersec.color = quads[i].color;\n            intersec.roughness = quads[i].roughness;\n            intersec.type = quads[i].type;\n            intersec.id = quads[i].id;\n        }\n    }\n    for(int i=0;i<boxes.length();i++){\n    \tt = BoxIntersect(boxes[0].minCorner,boxes[0].maxCorner,r,normal);\n        if(t < d){\n        \td = t;\n            intersec.normal = normalize(normal);\n            intersec.emission = boxes[i].emission;\n            intersec.color = boxes[i].color;\n            intersec.roughness = boxes[i].roughness;\n            intersec.type = boxes[i].type;\n        \tintersec.id = boxes[i].id;\n        }\n    }\n    \n    intersec.distance = d;\n    intersec.surface  = r.origin + r.direction * d + intersec.normal*0.00001;\n    return d;\n}\n\n/* \n\tAll feature materials infomation\n\tMaterial GetMaterial(Intersection _intersec){\n\tMaterial mat;\n    mat.type = _intersec.type;\n    mat.uv = _intersec.surface.xz*0.1 - 0.5;\n    mat.normal = _intersec.normal;\n   \n    mat.diffuse = sRGB2Linear(texture(iChannel1,mat.uv).rgb);\n    mat.specular = LIGHTCOLOR;\n    mat.roughness = _intersec.roughness;\n    return mat;\n}\n*/\n\nOrenNayarBsdf GetOrenNayarMaterial(Intersection _intersec){\n\tOrenNayarBsdf mat;\n    mat.id = _intersec.id;\n    mat.uv = fract(_intersec.surface.zx/4.-0.5);\n    if(mat.id == Floor)\n    \tmat.albedo = vec3(0.9,1.,0.);\n    else if(mat.id == Cuboid)\n        mat.albedo = vec3(0.4,1.,0.);\n    else if(mat.id == CenterSphere){\n        mat.uv.x = fract(atan(_intersec.surface.z+0.35,_intersec.surface.x)/M_2PI_F);\n        mat.uv.y = _intersec.surface.y+0.3;//(atan(abs(_intersec.surface.x),_intersec.surface.y-0.6))/M_PI_F;//_intersec.surface.y/1.2 + 0.;\n        mat.albedo = sRGB2Linear(texture(iChannel3,mat.uv).rgb);//clamp(vec3(mat.uv,0.),0.,1.);\n    }\n\tmat.nDir = _intersec.normal;\n\tmat.roughness = _intersec.roughness;\n    return mat;\n}\n\nvec3 GetLightIntensity(){\n\treturn AreaLightIntersity*LIGHTCOLOR;\n}\n\nfloat PDF_Area2Angle(float pdf,float dist,float costhe){\n    if(costhe > 0.)\n\t\treturn pdf*dist*dist/costhe;\n\treturn 0.;\n}\n\n/*\n\tJust for area lighting\n\tThe below simple diagrammatic is implement form my method,it descripts how \n\tO (a random point on the Area Surface) position is calculated;\n \n vec3 v0; vec3 v1; vec3 v2; vec3 v3\n       A\t\tB         C        D\n    v3------v2\n\t|\t O\t |\n\tv0------v1\n\tO = v0 + v0v1*X1 + v0v3*X2.       X1 and X2 is uniform random distribute.\n\n\tHere is descript the direct light sample,\n\twe intersect the area light surface within solid angle,\n\tand the solid angle is object surface direct to light ray set.\n\n\tThe fist pdf is on the Area Surface,we easy know every emit point on the Light Area\n\tis uniform distribute,the we can get the probability density is 1/S (S is area)\n\tbut we interesting on the solid angle pdf,so the convert is necessary.\n*/\nvec3 LightSample(vec3 p,float x1,float x2,out vec3 wo,out float dist,out float pdf){\n\tvec3 v0v1 = quads[0].v1 - quads[0].v0;\n    vec3 v0v3 = quads[0].v3 - quads[0].v0;\n    float width  = length(v0v1);\n    float height = length(v0v3);\n    vec3 O = quads[0].v0 + v0v1*x1 + v0v3*x2;\n    wo = O - p;\n    dist = length(wo);\n    wo = normalize(wo);\n    float costhe = dot(-wo,quads[0].normal);\n    pdf = PDF_Area2Angle(1./(width*height),dist,clamp(costhe,0.00001,1.));\n    return costhe>0. ? GetLightIntensity(): vec3(0.);\n}\n/*\n\tYep!if we catch the light ray is on the Area Lighing Surface,\n\twe get the solid angle pdf as same as the up.\n*/\nfloat GetLight_PDF(in Intersection intersecNow,in Intersection intersecNext){\n\tfloat pdf = 0.;\n    if(intersecNext.type == LIGHT){\n        vec3 v0v1 = quads[0].v1 - quads[0].v0;\n    \tvec3 v0v3 = quads[0].v3 - quads[0].v0;\n    \tfloat width  = length(v0v1);\n    \tfloat height = length(v0v3);\n        vec3 lDir = intersecNext.surface - intersecNow.surface;\n        float dist = length(lDir);\n        float costhe = dot(-lDir,quads[0].normal);\n        pdf = PDF_Area2Angle(1./(width*height),dist,costhe);\n    }\n    return pdf;\n}\n\n/*\n\tHum...just get wi (it called omiga) which is descript \n\ta ray that object surface to light.\n*/\nvec3 DirectLightSample(in Intersection intersecNow,out vec3 wi,out float pdf){\n\tvec3 Li = vec3(0.);\n    float x1 = GetRandom(),x2 = GetRandom();\n    float dist = INFINITY;\n    vec3 AssumeLi = LightSample(intersecNow.surface,x1,x2,wi,dist,pdf);\n    Ray shadowRay = Ray(intersecNow.surface,wi);\n    Intersection intersecNext;\n    SceneIntersect(shadowRay, intersecNext);\n    if(intersecNext.type == LIGHT){\n    \tLi = AssumeLi;\n    }\n    return Li;\n}\n/*\n\tI implement the BRDF Light Sample direct in Radiance() for clearly read.\n\tand just adopt a Oren Nayar diffuse model\n\tvec3 BRDFLightSample(in Intersection intersecNow,out Intersection intersecNext,out vec3 wi,out float pdf){\n\tvec3 Li = vec3(0.);\n    float x1 = GetRandom(),x2 = GetRandom();\n    wi = sample_uniform_hemisphere(intersecNow.normal,x1,x2,pdf);\n    Ray shadowRay = Ray(intersecNow.surface,wi);\n    SceneIntersect(shadowRay, intersecNext);\n    return Li;\n}\n*/\n\n/*\n\tGet Radiance all the path lighting\n*/\nvec3 Radiance(Ray ray){\n\tvec3 Lo = vec3(0.);\n    Intersection intersecNow;\n\tIntersection intersecNext;\n\tMaterial mat;\n    \n    float d = SceneIntersect(ray,intersecNow);\n    intersecNow.direction = ray.direction;\n    if(d == INFINITY){\n    \treturn texture(iChannel2,ray.direction).rgb*0.2;//BACKGROUND_COL;\n    }\n    else if(intersecNow.type == LIGHT){\n    \treturn texture(iChannel2,ray.direction).rgb*0.2;//BACKGROUND_COL;//GetLightIntensity();\n    }\n    \n    vec3 BSDFThroughout = vec3(1.);\n    vec3 DirectThroughout = vec3(1.);\n    for(int i=0;i<GI_DEPTH;i++){\n        float BSDF_pdf = 0.;\n        float Direct_pdf = 0.;\n        vec3 Li = vec3(0.);\n\t\tOrenNayarBsdf bsdf = GetOrenNayarMaterial(intersecNow);\n\t\tvec3 eval = vec3(0.);\n        /*\n\t\t  (Light Direct Sample) Calculate Direct Lighing and Indirect Lighing\n        */\n\t\t{\n            vec3 wi = vec3(0.);\n        \tLi = DirectLightSample(intersecNow,wi,Direct_pdf);\n            //intersecNow.normal = faceforward(-intersecNow.normal,wi,intersecNow.normal);\n            BSDF_Oren_Nayar_Setup(bsdf);\n            eval = BSDF_Oren_Nayar_GetIntensity(bsdf,intersecNow.normal,ray.direction,wi);\n            DirectThroughout *= bsdf.albedo;\n            \n            //use Multiple Importance sample\n            float Light_Weight = 1.;\n            if(UseMIS){\n            \tfloat bsdf_pdf = GetCosWeightSpherePDF(intersecNow.normal,wi);\n                Light_Weight = MISWeight(1.,Direct_pdf,1.,bsdf_pdf);\n            }\n            if(Direct_pdf > 0.){\n            \tLo += Li*DirectThroughout*eval*Light_Weight/Direct_pdf;\n            }\n            \n        }\n        \n        //(BRDF Sample) Calculate Direct Lighing and Indirect Lighing\n        {\n        \tfloat x1 = GetRandom(),x2 = GetRandom();\n            vec3 wi = sample_cos_hemisphere(intersecNow.normal,x1,x2,BSDF_pdf);\n           \tSceneIntersect(Ray(intersecNow.surface,wi),intersecNext);\n            \n            //use Multiple Importance sample\n            float BSDF_Weight = 1.0;\n            if(UseMIS){\n            \tfloat light_pdf = GetLight_PDF(intersecNow,intersecNext);\n                BSDF_Weight = MISWeight(1.,BSDF_pdf,1.5,light_pdf);\n            }\n            if(BSDF_pdf > 0.){\n            \tBSDFThroughout *= bsdf.albedo / BSDF_pdf;\n            }\n            /*\n\t\t\t\tuse Russian Roulette teminal \n            \tfor adapt very bright and very dark,\n\t\t\t\tAs one words for in short,elevate unbias,reduce noise.\n\t\t\t*/\n\t\t\tfloat probability = max(max(BSDFThroughout.x,BSDFThroughout.y),BSDFThroughout.z);\n            #ifdef Linux\n            \tif(probability > 0.){\n            \t\t//if(GetRandom() < probability)\n                    BSDFThroughout /= probability;\n                }\n            #else\n                if(any(greaterThan(BSDFThroughout,vec3(1.))) ){\n                    if(GetRandom() < probability)\n                        BSDFThroughout /= probability;\n                }\n            #endif\n\t\t\tif(intersecNext.distance == INFINITY){\n                Li = texture(iChannel2,wi).rgb*SkyLightIntensity;//BACKGROUND_COL;\n                eval = BSDF_Oren_Nayar_GetIntensity(bsdf,intersecNow.normal,ray.direction,wi);\n                Lo += Li * eval * BSDFThroughout * BSDF_Weight;\n                break;\n            }\n            else if(intersecNext.type == LIGHT){\n                Li = GetLightIntensity();\n                eval = BSDF_Oren_Nayar_GetIntensity(bsdf,intersecNow.normal,ray.direction,wi);\n                Lo += Li * eval * BSDFThroughout * BSDF_Weight;\n                break;\n            }\n        }\n        \n        //for next tracing path\n        intersecNow = intersecNext;\n        \n    }\n    return Lo;\n}\n\nconst vec2 FRAME_START_UV = vec2(0.,0.);\nvec4 readValues(vec2 xy){\n\treturn texture(iChannel0,(xy+0.5)/R);\n}\nmat3 CameraCoordBase(vec3 campos,vec3 lookAt,vec3 up){\n\tvec3 LookForward = normalize(lookAt - campos);\n    vec3 BaseRight = normalize(cross(LookForward,up));\n    vec3 BaseUp    = normalize(cross(BaseRight,LookForward));\n    mat3 mat = mat3(BaseRight,BaseUp,LookForward);\n\treturn mat;\n}\n\nvoid mainImage( out vec4 C, in vec2 U ){\n\tvec2 iU = U - 0.5;\n    seed = iTime*sin(iTime) + (U.x+R.x*U.y)/(R.y);\n    vec2 uv = (U+U-R)/R.y;\n    vec2 mousePos = readValues(FRAME_START_UV).yz;\n    if(iFrame <= 1){\n         mousePos = vec2(0.,R.y/2.);\n\t}\n    mousePos.y = max(mousePos.y,R.y*0.33);\n    mousePos = mousePos/R*10.;\n    vec3 pos = vec3(cos(mousePos.x),mousePos.y/2.-0.5,sin(mousePos.x));\n    \t pos.xz *= 2.5;\n    vec3 dir = normalize(vec3(uv,2.3));\n\tpos.xy += cos(GetRandom()*M_2PI_F+vec2(0.,M_H_PI_F))*(20.*GetRandom()/length(R));\n    dir = RotVector(CameraCoordBase(pos,vec3(0.,0.05,0.),vec3(0.,1.,0.)),dir);\n    dir = normalize(dir);\n    \n    SetupScene();\n    //vec2 dither = TriangularNoise2DShereRay(uv,iTime);\n    //pos += (RotVector(cameraSpace,vec3(dither,0.)))*0.004;\n    Ray ray = Ray(pos,dir);\n    vec3 col = Radiance(ray);\n    if(all(equal(iU,FRAME_START_UV))){\n        if(iFrame == 0){\n            C = vec4(1.,vec2(0.,R.y/2.),0.);\n        }\n        else{\n            if(iMouse.z > 1.){\n                vec2 mousePos_Before = readValues(FRAME_START_UV).yz;\n                C = vec4(1.,iMouse.xy,0.);\n                \n            }\n            else{\n                C = readValues(FRAME_START_UV);\n                ++C.r;\n            }\n        }\n    }\n    else{\n        if(iFrame == 0){\n        \tC = vec4(col.rgb,0.);\n        }\n        else{\n            vec4 Frame_data = readValues(FRAME_START_UV);\n            C = texture(iChannel0,U/R);\n            /*\n\t\t\t\t蒙特卡洛 积分(Monte Carlo Integration)\n\t\t\t\tthe math is: sum(x1+x2+x2+...+xn)/N     \n\t\t\t\tC = C*(1-1/n) + col *(1/n)    the n is ∈(1,N)\n\t\t\t*/\n            C = mix(C,vec4(col,1.),1./Frame_data.r);\n        }\n    }\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 14,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 27,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}