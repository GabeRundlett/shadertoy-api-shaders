{
    "Shader": {
        "info": {
            "date": "1570443052",
            "description": "practice\nraytracing in raytracing",
            "flags": 0,
            "hasliked": 0,
            "id": "WsG3zy",
            "likes": 5,
            "name": "synapse",
            "published": 3,
            "tags": [
                "spheretracing"
            ],
            "usePreview": 0,
            "username": "tono",
            "viewed": 439
        },
        "renderpass": [
            {
                "code": "#define M(x,y) mod(x,y)-y/2.\n#define time iTime\n\nconst float pi  =acos(-1.);\nconst float pi2 = pi *2.;\n\nstruct RayTrace{\n    vec3 cp;\n    vec3 rd;\n    vec3 cs;\n    vec3 cu;\n    vec3 cd;\n    vec2 p;\n    vec3 color;\n    vec3 normal;\n};\n\nmat2 rot(float a)\n{\n\tfloat s = sin(a),c = cos(a);\n\treturn mat2(s,c,-c,s);\n}\n\nvec2 fmod(vec2 p,float r)\n{\n\tfloat a = atan(p.x,p.y) + pi/r;\n\tfloat n = pi2/2.;\n\ta = floor(a/n)*n;\n\treturn p * rot(a);\n}\n\n\nfloat hash2(vec2 p)\n{\n\treturn fract(dot(sin(p.x),p.y) + 982.71);\n}\n\nfloat smin(float d1, float d2, float k){\n    float h = exp(-k * d1) + exp(-k * d2);\n    return -log(h) / k;\n}\n\t\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\t\nfloat dist(vec3 p)\n{\n\tvec3 pb = p;\n\tpb.yz = M(pb.yz,0.5);\n\t\n\t//pb.yz = fmod(pb.yz,10.);\n\tvec3 box1 = pb + vec3(3.,0.,0.);\n\tvec3 box2 = pb- vec3(3.,0.,0.);\n\tbox1.xy = fmod(box1.xy,3.);\n\t\n\t\n\tvec3 seed = floor(p/5.)*5.;\n\t//float id = hash3(seed);\n\tfloat finness = 2.5;\n\tvec2 id = floor(p.yz/finness)*finness;\n\tfloat speed = hash2(id) * 1000.;\n\t\n\tfloat timing = mod(time-speed,15.) - 7.5;\n\tvec3 d1p = p + vec3(timing,0.,0.);\n\td1p.yz = M(d1p.yz,2.5);\n\tvec3 boxSize = vec3(0.1,0.1,0.1);\n\tfloat s = length(p) - 0.01;\n\t\n    float datasize = 0.4;\n\tvec3 datasizes = vec3(datasize);\n    d1p.xy *= rot(time + speed/50.);\n    d1p.zy *= rot(time+speed);\n\tfloat data1 = sdBox(d1p,datasizes);\n\t\n    float delta = 0.17;\n    \n\tfloat rBox1 = sdRoundBox(box1,boxSize,0.2);\n\tfloat rBox2 = sdRoundBox(box2,boxSize,0.2);\n\tfloat wall = smin(rBox1,rBox2,0.5);\n\treturn smin(data1-delta,wall,1.5);\n\t//return rBox;\n}\n\nfloat dist2(vec3 p)\n{\n    //p.yx *= rot(2.);\n\tp.y = abs(p.y);\n\tp.z = M(p.z,3.);\n    p.xz *= rot(30.* sin(time/10.));\n    p.xz = fmod(p.xz,4.);\n\tp = M(p,3.);\n\tfloat s = sdBox(p,vec3(0.5));\n\t\n\t\n\treturn s;\n}\nvec3 getNormal(vec3 p)\n{\n\tvec3 d = vec3(0.001,0.,0.);\n\treturn normalize(vec3(\n\t\tdist(p + d) - dist(p - d),\n\t\tdist(p + d.yxz) - dist(p - d.yxz),\n\t\tdist(p + d.zyx) - dist(p - d.zyx)\n\t));\n}\n\n\n\nvec3 hsv(vec3 hsv)\n{\n\tfloat h = hsv.x;\n\tfloat s = hsv.y;\n\tfloat v = hsv.z;\n\treturn ((clamp(abs(fract(h+vec3(0,2,1)/3.)*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;\n}\n\nRayTrace raymarching2(RayTrace ri)\n{\n    RayTrace ro;\n\tro= ri;\n\tri.cp += -ri.cs * time;\n\tro.rd = normalize(vec3(ri.p.x * ri.cs + ri.cu * ri.p.y + ri.rd * 2.5));\n\t\n\tvec3 light = vec3(0.,1.,0.);\n    \tfloat  depth = 0.;\n\tvec3 normal = vec3(0.);\n\tfloat ac = 0.0;\n\tfor(int i = 0; i< 90 ; i++)\n\t{\n\t\tvec3 rp = ro.cp + ro.rd * depth;\n\t\tfloat d = dist2(rp);\n\t\td= max(0.001,abs(d));\n\t\tac += exp(-d * 3.);\t\n\t\tdepth += d;\n\t}\n\tro.normal = normal;\n\tfloat h = ac/500. * sin(time/10.);\n\tfloat s = ri.color.g*ac/100.;\n\tfloat v = ri.color.r/ac ;\n\tvec3 color = vec3(h,s,v);\n\tro.color = color;\n    return ro;\n}\n\t\nRayTrace raymarching(RayTrace ri)\n{\n    RayTrace ro;\n\tro = ri;\n\tro.p = vec2(-1.);\n\tvec3 light = vec3(0.,1.,0.);\n    \tfloat  depth = 0.;\n\tvec3 normal = vec3(0.);\n\t\n\tfor(int i = 0; i< 79 ; i++)\n\t{\n\t\tvec3 rp = ri.cp + ri.rd * depth;\n\t\tfloat d = dist(rp);\n\t\tif(d < 0.0001)\n\t\t{\n\t\t\tro.color = vec3(1.);\n\t\t\tnormal = getNormal(rp);\n\t\t\tro.p = (rp.zy + vec2(1.) )/2.;\n\t\t\tbreak;\n\t\t}\n        //if(d > 1.9){break;}\n\t\tdepth += d;\n\t}\n\tro.normal = abs(normal);\n\tro.color = ro.color * dot(normal,light);\n\tro.color = hsv(abs(normal));\n\tif(ro.p.x > 0.)\n\t{\n\t\tro = raymarching2(ro);\n\t}\n    return ro;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 p = ( fragCoord.xy *2. -  iResolution.xy )/min(iResolution.x,iResolution.y);\n\n\t  vec3 col = vec3(0.);\n    \n\t    RayTrace ro;\n\t    \n\t    vec3 cp = vec3(0.,0.,-5.);\n\t    vec3 cd = vec3(0.,0.,1.);\n\t    vec3 cu = vec3(0.,1.,0.);\n\t    vec3 cs = cross(cd , cu);\n\t\t\n\t   cd += vec3(0.,-0.1,0.);\n\t   cp += cd * time/2.;\n\t   cp += cu * 8. * sin(time/3.);\n\t\n\t    float target = 2.5;\n\t    vec3 rd = normalize(vec3(cd * target + cs * p.x + cu * p.y));\n\n\tro.cp = cp;\n\tro.rd = rd;\n\tro.cd = cd;\n\tro.p = p;\n\tro.color = col;\n\tro.normal = vec3(0.);\n\tRayTrace ri = raymarching(ro);\n\tfragColor = vec4( ri.color, 1.0 );\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}