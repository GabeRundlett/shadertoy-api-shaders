{
    "Shader": {
        "info": {
            "date": "1555271570",
            "description": "A selection of fonts generated from Shadertoy's font texture.\nThe RenderFont function has a comment explaining how to use it.",
            "flags": 0,
            "hasliked": 0,
            "id": "WdBXWd",
            "likes": 25,
            "name": "Fonts!",
            "published": 3,
            "tags": [
                "text",
                "font"
            ],
            "usePreview": 1,
            "username": "TekF",
            "viewed": 1472
        },
        "renderpass": [
            {
                "code": "// A selection of fonts generated from Shadertoy's font texture.\n// by Hazel Quantock 2019\n// This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. https://creativecommons.org/licenses/by-sa/4.0/\n\n\n// quality of font anti-aliasing - number of samples doubles with each level of quality\n#define AA_QUALITY 3\n\n// allow a little bleed between pixels - this looks more photographic, but blurrier\n#define AA_ROUND false\n#define AA_ROUND_RADIUS 0.7071\n\n\n// Font Definitions\nstruct Typeface\n{\n    vec2 scale;\n    vec2 padding;\n    vec2 bias;\n    float biasAngle;\n    float threshold;\n};\n\nconst Typeface Deco = Typeface( vec2(.6,.7), vec2(0), vec2(-.02,.025), 0., -.02 );\nconst Typeface Deco_Light = Typeface( vec2(.63,.7), vec2(-1,0), vec2(-.01,.04), 0., -.02 );\n\nconst Typeface Impactful = Typeface( vec2(.5,1), vec2(4,2), vec2(-.02,.01), 0., .01 );\n\nconst Typeface Elegant = Typeface( vec2(.6,.9), vec2(-2,0), vec2(.05,-.005), -1.04, -.022 );\nconst Typeface Elegant_Condensed = Typeface( vec2(.5,1.), vec2(0,1), vec2(.0,.1), -1., -.02 );\n\nconst Typeface Timely = Typeface( vec2(.6,.7), vec2(2,1), vec2(-.05,.0), -.5, -.02 );\nconst Typeface Timely_Light = Typeface( vec2(.6,.7), vec2(2,1), vec2(-.02,.02), -.5, -.01 );\nconst Typeface Timely_Heavy = Typeface( vec2(.8,.7), vec2(4,1), vec2(-.03,.02), 2.5, .01 );\n\nconst Typeface Neat = Typeface( vec2(.6,.7), vec2(-1,1), vec2(-.017,.02), -.3, -.02 );\n\nconst Typeface Comic = Typeface( vec2(.8,.7), vec2(2,1), vec2(-.05,.0), 1., -.02 );\nconst Typeface Comic_Title = Typeface( vec2(.6,.7), vec2(2,1), vec2(-.05,.0), 1., .0 );\n\nconst Typeface WildWest = Typeface( vec2(.9), vec2(2,0), vec2(-.05,.0), 0., -.02 );\nconst Typeface WildWest_Wide = Typeface( vec2(1,.7), vec2(0,2), vec2(.05,.0), 0., .02 );\n\nconst Typeface Gothic = Typeface( vec2(.9,.7), vec2(0,2), vec2(.05,.0), 1., .01 );\nconst Typeface Gothic_Light = Typeface( vec2(.9,.7), vec2(0,2), vec2(.05,.0), 1., -.01 );\nconst Typeface Gothic_Condensed = Typeface( vec2(.5,1.), vec2(0), vec2(.05,.0), -1.04, .02 );\nconst Typeface Gothic_Book = Typeface( vec2(.6,.7), vec2(0,2), vec2(.1,.0), 1., .0 );\n\nconst Typeface Haunted = Typeface( vec2(.75,.9), vec2(2,0), vec2(.0,.03), 0., .01 );\nconst Typeface Haunted_Condensed = Typeface( vec2(.5,1), vec2(4,0), vec2(-.02,.03), 0., .01 );\nconst Typeface Haunted_Script = Typeface( vec2(.6,.7), vec2(2,1), vec2(-.05,.05), .7, .0 );\n\n// Round-tipped font (actually not round in close-up)\nconst Typeface Round = Typeface( vec2(1), vec2(0,6), vec2(-.02,-.02), 0., -.01 );\nconst Typeface Round_Bold = Typeface( vec2(1), vec2(4,6), vec2(-.04,-.04), 0., -.01 );\n\n\n\nfloat RenderFont_NoAA\n    (\n        vec2 uv,\n        Typeface font,\n        uint text[8]\n    )\n{\n    // each char is in a 64x64 space, trim off the white boundary\n    vec2 charBottomLeft = vec2(18,3) - font.padding/2.;\n    vec2 charDims = vec2(28,52) + font.padding;\n\n    uv = uv/font.scale; //+vec2(iTime*200.,0);\n    \n    if ( uv.y < .0 || uv.y >= charDims.y ) return 1.;\n    \n    uint index = uint(uv.x/charDims.x);\n    ivec2 res = ivec2(iResolution.xy);\n    uint index4 = index/4u;\n\n    if ( index4 >= uint(text.length()) ) return 1.;\n    \n    uint char = ( text[index4] >> (8u*(index&3u)) )&0xffu;\n    \n    char = char^0xf0u; // flip the y coord\n    \n    uv.x = fract(uv.x/charDims.x)*charDims.x;\n    uv += vec2(ivec2(char&0xfu,char>>4u)) * iChannelResolution[0].xy/16.;\n    uv += charBottomLeft;\n                            \n    vec4 v = texture( iChannel0, uv/iChannelResolution[0].xy ) -.5;\n                            \n    vec2 bias = 2.*v.yz;\n    bias = bias*cos(font.biasAngle) + bias.yx*sin(font.biasAngle)*vec2(1,-1);\n    bias = pow(abs(bias),vec2(3));\n    \n    // view the SDF\n//    float f = v.w + dot( font.bias, bias ) - font.threshold; return .5+.5*f/(abs(f)+.04);\n    \n    return step( font.threshold, v.w + dot( font.bias, bias ) );\n}\n\n\n\n// RenderFont\n//\n// Output:\n//\t\tA linear brightness value where 0 = text, 1 = background.\n//\t\tI recommend applying a gamma curve before displaying.\n//\n// uv\n//\t\tRelative to the bottom left of the line of text, most fonts are about 40 units tall\n//\n// font\n//\t\tOne of the Typefaces defined earlier\n//\n// text\n//\t\tA line of text, encoded using my tool here: https://tekf.github.io/Misc-Tools/StringToHex.html\n//\t\tEach byte is 4-bit u, 4-bit v coord of a character in the font texture.\n//\nfloat RenderFont\n    (\n        vec2 uv,\n        Typeface font,\n\t\tuint text[8]\n    )\n{\n    const int numSamples = 1<<(AA_QUALITY);\n    \n    float sum = 0.;\n    vec2 duvdx = dFdx(uv);\n    vec2 duvdy = dFdy(uv);\n\n    // anti-alias the font\n    // this would be more efficient run per-character inside the font render function\n    // (the SDFs on some of the fonts are good enough that I could probably just soften the step function)\n    for ( int i=0; i < numSamples; i++ )\n    {\n        // ideal 2D quasirandom sequence from http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n        uvec2 quasi2 = uvec2(0xC13FA9A9u,0x91E10DA5u);\n        uint seed = uint(i);\n        //seed += uint(iFrame*numSamples); // randomize per frame - causes shimmering\n        //seed += uint(fragCoord.x)*quasi2.x+uint(fragCoord.y)*quasi2.y; // randomize per pixel - this looks bad at low sample counts (and at high counts it's less important)\n        vec2 jitter = vec2( quasi2 * seed ) / exp2(32.);\n\n        if ( AA_ROUND )\n        {\n            // circle of confusion slightly bigger than a pixel - should look more photographic\n            jitter.x *= 6.283185;\n            jitter = AA_ROUND_RADIUS*(1.-jitter.y*jitter.y)*vec2(cos(jitter.x),sin(jitter.x));\n        }\n        else\n        {\n            jitter -= .5;\n        }\n        \n        sum += RenderFont_NoAA( uv + jitter.x*duvdx + jitter.y*duvdy, font, text );\n    }\n   \n    return sum/float(numSamples);\n}\n\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord*360./iResolution.y;\n\n    // scroll and wrap the list of fonts\n    uv.y -= iTime*30. + 350.;\n    uv.y = fract( uv.y/1100. )*1100.-15.;\n// Bug: a visible seam appears at the wrap point if I draw Deco_Light, Timely_Heavy, Gothic_Light, Haunted, or Round\n// I can't work out how that's even possible\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Text encoded using my tool here: https://tekf.github.io/Misc-Tools/StringToHex.html\n\tfloat f = RenderFont( uv-vec2(0,1030), Deco, uint[]( 0x6f636544U, 0x212e2d20U, 0x6178453fU, 0x656c706dU, 0x74786554U, 0x33323130U, 0x37363534U, 0x20203938U ) );\n\tf = min(f,RenderFont( uv-vec2(0, 990), Deco_Light, uint[]( 0x6f636544U, 0x67694c5fU, 0x2d207468U, 0x453f212eU, 0x706d6178U, 0x6554656cU, 0x31307478U, 0x35343332U ) ));\n\tf = min(f,RenderFont( uv-vec2(0, 930), Impactful, uint[]( 0x61706d49U, 0x75667463U, 0x2e2d206cU, 0x78453f21U, 0x6c706d61U, 0x78655465U, 0x32313074U, 0x36353433U ) ));\n\tf = min(f,RenderFont( uv-vec2(0, 880), Elegant, uint[]( 0x67656c45U, 0x20746e61U, 0x3f212e2dU, 0x6d617845U, 0x54656c70U, 0x30747865U, 0x34333231U, 0x38373635U ) ));\n\tf = min(f,RenderFont( uv-vec2(0, 830), Elegant_Condensed, uint[]( 0x67656c45U, 0x5f746e61U, 0x646e6f43U, 0x65736e65U, 0x2e2d2064U, 0x78453f21U, 0x6c706d61U, 0x78655465U ) ));\n\tf = min(f,RenderFont( uv-vec2(0, 790), Timely, uint[]( 0x656d6954U, 0x2d20796cU, 0x453f212eU, 0x706d6178U, 0x6554656cU, 0x31307478U, 0x35343332U, 0x39383736U ) ));\n\tf = min(f,RenderFont( uv-vec2(0, 745), Timely_Light, uint[]( 0x656d6954U, 0x4c5f796cU, 0x74686769U, 0x212e2d20U, 0x6178453fU, 0x656c706dU, 0x74786554U, 0x33323130U ) ));\n\tf = min(f,RenderFont( uv-vec2(0, 700), Timely_Heavy, uint[]( 0x656d6954U, 0x485f796cU, 0x79766165U, 0x212e2d20U, 0x6178453fU, 0x656c706dU, 0x74786554U, 0x33323130U ) ));\n\tf = min(f,RenderFont( uv-vec2(0, 655), Neat, uint[]( 0x7461654eU, 0x212e2d20U, 0x6178453fU, 0x656c706dU, 0x74786554U, 0x33323130U, 0x37363534U, 0x20203938U ) ));\n\tf = min(f,RenderFont( uv-vec2(0, 610), Comic, uint[]( 0x696d6f43U, 0x2e2d2063U, 0x78453f21U, 0x6c706d61U, 0x78655465U, 0x32313074U, 0x36353433U, 0x20393837U ) ));\n\tf = min(f,RenderFont( uv-vec2(0, 565), Comic_Title, uint[]( 0x696d6f43U, 0x69545f63U, 0x20656c74U, 0x3f212e2dU, 0x6d617845U, 0x54656c70U, 0x30747865U, 0x34333231U ) ));\n\tf = min(f,RenderFont( uv-vec2(0, 505), WildWest, uint[]( 0x646c6957U, 0x74736557U, 0x212e2d20U, 0x6178453fU, 0x656c706dU, 0x74786554U, 0x33323130U, 0x37363534U ) ));\n\tf = min(f,RenderFont( uv-vec2(0, 460), WildWest_Wide, uint[]( 0x646c6957U, 0x74736557U, 0x6469575fU, 0x2e2d2065U, 0x78453f21U, 0x6c706d61U, 0x78655465U, 0x32313074U ) ));\n\tf = min(f,RenderFont( uv-vec2(0, 420), Gothic, uint[]( 0x68746f47U, 0x2d206369U, 0x453f212eU, 0x706d6178U, 0x6554656cU, 0x31307478U, 0x35343332U, 0x39383736U ) ));\n\tf = min(f,RenderFont( uv-vec2(0, 380), Gothic_Light, uint[]( 0x68746f47U, 0x4c5f6369U, 0x74686769U, 0x212e2d20U, 0x6178453fU, 0x656c706dU, 0x74786554U, 0x33323130U ) ));\n\tf = min(f,RenderFont( uv-vec2(0, 322), Gothic_Condensed, uint[]( 0x68746f47U, 0x435f6369U, 0x65646e6fU, 0x6465736eU, 0x212e2d20U, 0x6178453fU, 0x656c706dU, 0x74786554U ) ));\n\tf = min(f,RenderFont( uv-vec2(0, 280), Gothic_Book, uint[]( 0x68746f47U, 0x425f6369U, 0x206b6f6fU, 0x3f212e2dU, 0x6d617845U, 0x54656c70U, 0x30747865U, 0x34333231U ) ));\n\tf = min(f,RenderFont( uv-vec2(0, 230), Haunted, uint[]( 0x6e756148U, 0x20646574U, 0x3f212e2dU, 0x6d617845U, 0x54656c70U, 0x30747865U, 0x34333231U, 0x38373635U ) ));\n\tf = min(f,RenderFont( uv-vec2(0, 170), Haunted_Condensed, uint[]( 0x6e756148U, 0x5f646574U, 0x646e6f43U, 0x65736e65U, 0x2e2d2064U, 0x78453f21U, 0x6c706d61U, 0x78655465U ) ));\n\tf = min(f,RenderFont( uv-vec2(0, 125), Haunted_Script, uint[]( 0x6e756148U, 0x5f646574U, 0x69726353U, 0x2d207470U, 0x453f212eU, 0x706d6178U, 0x6554656cU, 0x31307478U ) ));\n\tf = min(f,RenderFont( uv-vec2(0,  60), Round, uint[]( 0x6e756f52U, 0x2e2d2064U, 0x78453f21U, 0x6c706d61U, 0x78655465U, 0x32313074U, 0x36353433U, 0x20393837U ) ));\n\tf = min(f,RenderFont( uv-vec2(0,   0), Round_Bold, uint[]( 0x6e756f52U, 0x6f425f64U, 0x2d20646cU, 0x453f212eU, 0x706d6178U, 0x6554656cU, 0x31307478U, 0x35343332U ) ));\n    \n    // Output to screen\n    fragColour.rgb = vec3( pow( f, 1./2.2 ) );\n    fragColour.a = 1.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}