{
    "Shader": {
        "info": {
            "date": "1631307685",
            "description": "Rough sketch (code not polished!).\nGood stuff is in BufferA, rest is just a bloom.\n\nattrib: \"clouds\" by Inigo Quilez\nhttps://www.shadertoy.com/view/XslGRr\n\nand \"6-Point Star Filter + Bloom\" by granito\n",
            "flags": 32,
            "hasliked": 0,
            "id": "sdGGDR",
            "likes": 37,
            "name": "waynoka oklahoma tornado, 1898",
            "published": 3,
            "tags": [
                "volume",
                "clouds",
                "iq",
                "tornado"
            ],
            "usePreview": 0,
            "username": "mxsage",
            "viewed": 1182
        },
        "renderpass": [
            {
                "code": "vec4 cubic(float x)\n{\n    float x2 = x * x;\n    float x3 = x2 * x;\n    vec4 w;\n    w.x =   -x3 + 3.0*x2 - 3.0*x + 1.0;\n    w.y =  3.0*x3 - 6.0*x2       + 4.0;\n    w.z = -3.0*x3 + 3.0*x2 + 3.0*x + 1.0;\n    w.w =  x3;\n    return w / 6.0;\n}\n\nvec4 BicubicTexture(in sampler2D tex, in vec2 coord)\n{\n\tvec2 resolution = iResolution.xy;\n\n\tcoord *= resolution;\n\n\tfloat fx = fract(coord.x);\n    float fy = fract(coord.y);\n    coord.x -= fx;\n    coord.y -= fy;\n\n    fx -= 0.5;\n    fy -= 0.5;\n\n    vec4 xcubic = cubic(fx);\n    vec4 ycubic = cubic(fy);\n\n    vec4 c = vec4(coord.x - 0.5, coord.x + 1.5, coord.y - 0.5, coord.y + 1.5);\n    vec4 s = vec4(xcubic.x + xcubic.y, xcubic.z + xcubic.w, ycubic.x + ycubic.y, ycubic.z + ycubic.w);\n    vec4 offset = c + vec4(xcubic.y, xcubic.w, ycubic.y, ycubic.w) / s;\n\n    vec4 sample0 = texture(tex, vec2(offset.x, offset.z) / resolution);\n    vec4 sample1 = texture(tex, vec2(offset.y, offset.z) / resolution);\n    vec4 sample2 = texture(tex, vec2(offset.x, offset.w) / resolution);\n    vec4 sample3 = texture(tex, vec2(offset.y, offset.w) / resolution);\n\n    float sx = s.x / (s.x + s.y);\n    float sy = s.z / (s.z + s.w);\n\n    return mix( mix(sample3, sample2, sx), mix(sample1, sample0, sx), sy);\n}\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nvec3 BloomFetch(vec2 coord)\n{\n \treturn BicubicTexture(iChannel3, coord).rgb;   \n}\n\nvec3 Grab(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord /= scale;\n    coord -= offset;\n\n    return BloomFetch(coord);\n}\n\nvec2 CalcOffset(float octave)\n{\n    vec2 offset = vec2(0.0);\n    \n    vec2 padding = vec2(10.0) / iResolution.xy;\n    \n    offset.x = -min(1.0, floor(octave / 3.0)) * (0.25 + padding.x);\n    \n    offset.y = -(1.0 - (1.0 / exp2(octave))) - padding.y * octave;\n\n\toffset.y += min(1.0, floor(octave / 3.0)) * 0.35;\n    \n \treturn offset;   \n}\n\nvec3 GetBloom(vec2 coord)\n{\n \tvec3 bloom = vec3(0.0);\n    \n    //Reconstruct bloom from multiple blurred images\n    bloom += Grab(coord, 1.0, vec2(CalcOffset(0.0))) * 0.01;\n    bloom += Grab(coord, 2.0, vec2(CalcOffset(1.0))) * 0.02;\n\tbloom += Grab(coord, 3.0, vec2(CalcOffset(2.0))) * 0.08;\n    bloom += Grab(coord, 4.0, vec2(CalcOffset(3.0))) * 0.16;\n    bloom += Grab(coord, 5.0, vec2(CalcOffset(4.0))) * 0.32;\n    bloom += Grab(coord, 6.0, vec2(CalcOffset(5.0))) * 0.64;\n    bloom += Grab(coord, 7.0, vec2(CalcOffset(6.0))) * 1.28;\n    bloom += Grab(coord, 8.0, vec2(CalcOffset(7.0))) * 2.56;\n\n\treturn bloom;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = ColorFetch(uv);\n    \n    color += GetBloom(uv) * 0.3;\n    color = vec3(color.x + color.y + color.z);\n    color /= 3.;\n        \n    fragColor = vec4(color, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define NOISE_METHOD 2\n\n\n\nfloat rand(vec2 coord)\n{\n    return saturate(fract(sin(dot(coord, vec2(12.9898, 78.223))) * 43758.5453));\n}\n\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\n\n\tvec2 uv = (p.xy+vec2(37.0,239.0)*p.z) + f.xy;\n    vec2 rg = textureLod(iChannel1,(uv+0.5)/256.0,0.0).yx;\n\treturn mix( rg.x, rg.y, f.z )*2.0-1.0;\n\n   \n}\nfloat ground(in vec3 p, int oct)\n{\n    float n = noise(p*vec3(1., 0., 1.)*.1+vec3(34., 24., 0.));\n    float edge = p.y+n - 2.3;\n    float density = 0.;\n    if (edge > 0. && p.z < 9. && p.z > 8.)\n    {\n        float interpAmount = 0.3;\n        float scale = 2.;\n        if (edge > -interpAmount)\n        {\n            scale = mix(0., scale, pow(edge / -interpAmount, .8));\n        }\n        density = clamp(scale, 0., 1.)+density;\n    }\n    return density;\n}\n\nfloat groundClouds(in vec3 p, int oct)\n{\n    if (p.y < 1.)\n    {\n        return 0.;\n    }\n    float n = noise(p*vec3(1., 0., 1.)*.1+vec3(34., 24., 0.));\n    float edge = p.y+n - 3.4;\n    \n    float moveSpeed = 0.4;\n\n    float f = 0.;\n    p.y += edge;\n    p.y -= 3.;\n    vec3 q = p - vec3(-1.0,0.4,0.3)*(iTime*-moveSpeed);\n    \n    float g = 0.5+0.5*noise( q*.75);\n\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.23;\n    f += 0.12500*noise( q ); q = q*2.41;\n    f += 0.06250*noise( q ); q = q*2.62;\n    f += 0.03125*noise( q ); \n    f = pow(f, .5);\n    f *= .9;\n     \n    return max(1.0*f + 0.23 + p.y, 0.);\n}\n\nfloat tornado(in vec3 p, int oct)\n{\n    float density = 0.;\n        // tornado density\n    vec3 center = vec3(3.4, -0.5, 8.);\n    float verticalT = clamp((-p.y + 4.)*.16, 0.0, 1.);\n    float distCone = distance(p.xz, center.xz)-.1;\n    if (distCone > 2.2)\n    {\n        return 0.;\n    }\n    float dist = distCone\n        - noise(p - vec3(0.1,1.0, 0.1) * (iTime*-0.2))*.15*clamp(verticalT, .4, 1.)\n        - noise(p*vec3(.3, .7, .3)*10.5 - vec3(0.3,1.2,0.5) * (iTime*-.7))*.05*clamp(verticalT, .8, 1.);\n    \n    float edge = dist - pow(verticalT, 2.3)*3.5;\n    if (edge < 0.)\n    {\n        float interpAmount = 0.4;\n        float scale = 4.;\n        if (edge > -interpAmount)\n        {\n            scale = mix(0., scale, pow(edge / -interpAmount, .8));\n        }\n        density = scale+density;\n        \n    }\n    \n    return density;\n}\n\nfloat cloudsSky( in vec3 p, int oct )\n{\n\n    float moveSpeed = .04;\n    p.y -= 1.3;\n\tvec3 q = p - vec3(0.0,1.0,1.1)*((339.+iTime)*-moveSpeed);\n    float g = 0.5+0.5*noise(q*.2);\n    \n    float f;\n    if (p.y < .6)\n    {\n        f  = 0.50000*noise( q ); q = q*2.02;\n        f += 0.25000*noise( q ); q = q*2.23;\n        f += 0.12500*noise( q ); q = q*2.41;\n        f += 0.06250*noise( q ); q = q*2.62;\n        f += 0.03125*noise( q ); \n\n        f = mix( f*0.1-0.75, f, g*g ) + 0.1;\n    }\n    \n    vec3 center = vec3(3.4, -0.5, 8.);\n    float dist = distance(p.xz, center.xz);\n    dist = pow(dist, .5);\n    float final= max(1.5*f - 0.5 - p.y + clamp(2.0 - dist, 0., 1.0), 0.);\n\n    float pastNado = clamp((12. - p.z)+p.x*.4, 0., 2.)*.5;\n    final = final*pastNado;\n\n    return final;\n}\n\nconst vec3 sundir = normalize( vec3(-.6,-.4,0.5) );\n\nconst int kDiv = 1; // make bigger for higher quality\n\nvec4 raymarch( in vec3 ro, in vec3 rd, in vec3 bgcol, in ivec2 px )\n{\n\n    // bounding planes\t\n    const float yb = -3.0;\n    const float yt =  4.0;\n    float tb = (yb-ro.y)/rd.y;\n    float tt = (yt-ro.y)/rd.t;\n\n    // find tigtest possible raymarching segment\n    float tmin, tmax;\n    if( ro.y>yt )\n    {\n        // above top plane\n        if( tt<0.0 ) return vec4(0.0); // early exit\n        tmin = tt;\n        tmax = tb;\n    }\n    else\n    {\n        // inside clouds slabs\n        tmin = 0.0;\n        tmax = 60.0;\n        if( tt>0.0 ) tmax = min( tmax, tt );\n        if( tb>0.0 ) tmax = min( tmax, tb );\n    }\n    \n    vec2 uv = vec2(px) / iResolution.xy;\n    float dither = rand(uv + sin(iTime * 1.0) );\n    // dithered near distance\n    float t = tmin + 0.1*dither;\n    \n    // raymarch loop\n\tvec4 sum = vec4(0.0);\n    \n    for( int i=0; i<190*kDiv; i++ )\n    {\n       // step size\n       float dt = max(0.05,0.02*t/float(kDiv));\n\n       int oct = 5 - int( log2(1.0+t*0.5) );\n       \n       // sample cloud\n       vec3 pos = ro + t*rd;\n       float den = cloudsSky(pos,oct);\n       float gc = groundClouds(pos, oct) + tornado(pos, oct);\n       if( den>0.01 || gc>0.01) // if inside\n       {\n           // do lighting\n           float dif = clamp((den - cloudsSky(pos+0.3*sundir,oct))/0.3, 0.0, 1.0 );\n           vec3  lin = vec3(0.65,0.65,0.75)*1.1 + 0.8*vec3(1.0,0.6,0.3)*dif;\n           vec4  col = vec4( mix( vec3(1.0,0.95,0.8), vec3(0.25,0.3,0.35), den ), den );\n           col.xyz *= lin;\n           // fog\n           col.xyz = mix(col.xyz,bgcol, 1.0-exp2(-0.075*t));\n           // composite front to back\n           col.xyz = mix(col.xyz, vec3(0.), gc);\n           col.w    = min(col.w*8.0*dt,1.0);\n           col.w += gc*.1;\n           col.rgb *= col.a;\n           sum += col*(1.0-sum.a);\n       }\n       // advance ray\n       t += dt;\n       // until far clip or full opacity\n       if( t>tmax || sum.a>0.99 ) break;\n    }\n\n    return clamp( sum, 0.0, 1.0 );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec4 render( in vec3 ro, in vec3 rd, in ivec2 px )\n{\n\n\tfloat sun = clamp( dot(sundir,rd), 0.0, 1.0 );\n\n    vec3 col = vec3(.9);\n    // background sky\n    //col = vec3(0.76,0.75,0.86);\n    //col -= 0.6*vec3(0.90,0.75,0.95)*rd.y;\n\tcol += 0.2*vec3(1.00,0.60,0.10)*pow( sun, 8.0 );\n    \n    // clouds    \n    vec4 res = raymarch( ro, rd, col, px );\n    col = col*(1.0-res.w) + res.xyz;\n\n    // sun glare    \n\tcol += 0.2*vec3(1.0,0.4,0.2)*pow( sun, 3.0 );\n\n    // tonemap\n    col = smoothstep(0.5,1.1,col);\n \n    return vec4( col, 1.0 );\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m =                iMouse.xy      /iResolution.xy;\n\n    // camera\n    vec3 ro = 4.0*normalize(vec3(sin(3.0*m.x), 3.*(m.y-.5), cos(3.0*m.x))) - vec3(0.0,0.1,0.0);\n\tro = vec3(3., 3., 3.);\n    vec3 ta = ro + vec3(0., -.7, 1.);\n    mat3 ca = setCamera( ro, ta, 3.11);\n    // ray\n    vec3 rd = ca * normalize( vec3(p.xy,1.1));\n    \n    vec4 c = render( ro, rd, ivec2(fragCoord-0.5) );\n    float v = (c.x+c.y+c.z)/3.;\n    \n    vec3 previous = texture(iChannel0, fragCoord.xy / iResolution.xy).rgb;\n\n    fragColor = vec4(mix(vec3(v), previous, .5), 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//First bloom pass, mipmap tree thing\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nvec3 Grab1(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = ColorFetch(coord);\n\n    return color;\n}\n\nvec3 Grab4(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = vec3(0.0);\n    float weights = 0.0;\n    \n    const int oversampling = 4;\n    \n    for (int i = 0; i < oversampling; i++)\n    {    \t    \n        for (int j = 0; j < oversampling; j++)\n        {\n\t\t\tvec2 off = (vec2(i, j) / iResolution.xy + vec2(0.0) / iResolution.xy) * scale / float(oversampling);\n            color += ColorFetch(coord + off);\n            \n\n            weights += 1.0;\n        }\n    }\n    \n    color /= weights;\n    \n    return color;\n}\n\nvec3 Grab8(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = vec3(0.0);\n    float weights = 0.0;\n    \n    const int oversampling = 8;\n    \n    for (int i = 0; i < oversampling; i++)\n    {    \t    \n        for (int j = 0; j < oversampling; j++)\n        {\n\t\t\tvec2 off = (vec2(i, j) / iResolution.xy + vec2(0.0) / iResolution.xy) * scale / float(oversampling);\n            color += ColorFetch(coord + off);\n            \n\n            weights += 1.0;\n        }\n    }\n    \n    color /= weights;\n    \n    return color;\n}\n\nvec3 Grab16(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = vec3(0.0);\n    float weights = 0.0;\n    \n    const int oversampling = 16;\n    \n    for (int i = 0; i < oversampling; i++)\n    {    \t    \n        for (int j = 0; j < oversampling; j++)\n        {\n\t\t\tvec2 off = (vec2(i, j) / iResolution.xy + vec2(0.0) / iResolution.xy) * scale / float(oversampling);\n            color += ColorFetch(coord + off);\n            \n\n            weights += 1.0;\n        }\n    }\n    \n    color /= weights;\n    \n    return color;\n}\n\nvec2 CalcOffset(float octave)\n{\n    vec2 offset = vec2(0.0);\n    \n    vec2 padding = vec2(10.0) / iResolution.xy;\n    \n    offset.x = -min(1.0, floor(octave / 3.0)) * (0.25 + padding.x);\n    \n    offset.y = -(1.0 - (1.0 / exp2(octave))) - padding.y * octave;\n\n\toffset.y += min(1.0, floor(octave / 3.0)) * 0.35;\n    \n \treturn offset;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    \n    vec3 color = vec3(0.0);\n    \n    /*\n    Create a mipmap tree thingy with padding to prevent leaking bloom\n   \t\n\tSince there's no mipmaps for the previous buffer and the reduction process has to be done in one pass,\n    oversampling is required for a proper result\n\t*/\n    color += Grab1(uv, 1.0, vec2(0.0,  0.0)   );\n    color += Grab4(uv, 2.0, vec2(CalcOffset(1.0))   );\n    color += Grab8(uv, 3.0, vec2(CalcOffset(2.0))   );\n    color += Grab16(uv, 4.0, vec2(CalcOffset(3.0))   );\n    color += Grab16(uv, 5.0, vec2(CalcOffset(4.0))   );\n    color += Grab16(uv, 6.0, vec2(CalcOffset(5.0))   );\n    color += Grab16(uv, 7.0, vec2(CalcOffset(6.0))   );\n    color += Grab16(uv, 8.0, vec2(CalcOffset(7.0))   );\n\n\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Horizontal gaussian blur leveraging hardware filtering for fewer texture lookups.\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nfloat weights[5];\nfloat offsets[5];\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \n    weights[0] = 0.19638062;\n    weights[1] = 0.29675293;\n    weights[2] = 0.09442139;\n    weights[3] = 0.01037598;\n    weights[4] = 0.00025940;\n    \n    offsets[0] = 0.00000000;\n    offsets[1] = 1.41176471;\n    offsets[2] = 3.29411765;\n    offsets[3] = 5.17647059;\n    offsets[4] = 7.05882353;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = vec3(0.0);\n    float weightSum = 0.0;\n    \n    if (uv.x < 0.52)\n    {\n        color += ColorFetch(uv) * weights[0];\n        weightSum += weights[0];\n\n        for(int i = 1; i < 5; i++)\n        {\n            vec2 offset = vec2(offsets[i]) / iResolution.xy;\n            vec3 tmpcol = vec3(0);\n            tmpcol += ColorFetch(uv + offset * vec2(0.5, 0.0)) * weights[i];\n            tmpcol += ColorFetch(uv - offset * vec2(0.5, 0.0)) * weights[i];\n            color += hsv2rgb( rgb2hsv(tmpcol) + vec3(0.,0.25,0.) ); //boost saturation\n            weightSum += weights[i] * 2.0;\n        }\n\n        color /= weightSum;\n    }\n\n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Vertical gaussian blur leveraging hardware filtering for fewer texture lookups.\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nfloat weights[5];\nfloat offsets[5];\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \n    weights[0] = 0.19638062;\n    weights[1] = 0.29675293;\n    weights[2] = 0.09442139;\n    weights[3] = 0.01037598;\n    weights[4] = 0.00025940;\n    \n    offsets[0] = 0.00000000;\n    offsets[1] = 1.41176471;\n    offsets[2] = 3.29411765;\n    offsets[3] = 5.17647059;\n    offsets[4] = 7.05882353;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = vec3(0.0);\n    float weightSum = 0.0;\n    \n    if (uv.x < 0.52)\n    {\n        color += ColorFetch(uv) * weights[0];\n        weightSum += weights[0];\n\n        for(int i = 1; i < 5; i++)\n        {\n            vec2 offset = vec2(offsets[i]) / iResolution.xy;\n            vec3 tmpcol = vec3(0);\n            tmpcol += ColorFetch(uv + offset * vec2(0.0, 0.5)) * weights[i];\n            tmpcol += ColorFetch(uv - offset * vec2(0.0, 0.5)) * weights[i];\n            color += hsv2rgb( rgb2hsv(tmpcol) + vec3(0.,0.25,0.) ); //boost saturation\n            weightSum += weights[i] * 2.0;\n        }\n\n        color /= weightSum;\n    }\n\n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "vec3 rgb2hsv(vec3 c)\n{\n    vec4 k = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, k.wz), vec4(c.gb, k.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 k = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + k.xyz) * 6.0 - k.www);\n    return c.z * mix(k.xxx, clamp(p - k.xxx, 0.0, 1.0), c.y);\n}\n\nfloat saturate(float x)\n{\n\treturn clamp(x, 0.,1.);\n}\n\nvec2 hash21(float p) //1 in 2 out hash function\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy) * 2. - 1.;\n\n}\n\nvec2 rotateUV(vec2 uv, float rotation)\n{\n    return vec2(\n        cos(rotation) * uv.x + sin(rotation) * uv.y,\n        cos(rotation) * uv.y - sin(rotation) * uv.x\n    );\n}\n\nfloat dist(vec3 a, vec3 b) { return abs(a.x - b.x) + abs(a.y - b.y) + abs(a.z - b.z); }\n\nvec3 saturate(vec3 x)\n{\n    return clamp(x, vec3(0.0), vec3(1.0));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}