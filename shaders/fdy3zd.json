{
    "Shader": {
        "info": {
            "date": "1631928143",
            "description": "This filter cannot be mouse enabled because ADSR values can't be accessed in any kind of buffer for on the fly processing. I've created animation functions in common and I'm calling them in Image and Sound. Sounds like Tycho lol",
            "flags": 8,
            "hasliked": 0,
            "id": "fdy3zd",
            "likes": 12,
            "name": "ADSR Filter Visual [Sound]",
            "published": 3,
            "tags": [
                "procedural",
                "2d",
                "sound",
                "music",
                "utils",
                "adsr"
            ],
            "usePreview": 0,
            "username": "Yusef28",
            "viewed": 409
        },
        "renderpass": [
            {
                "code": "///////////////////////////////////////////////\n//\n// Author:Yusef28\n// Start Date: 17-09-2021\n// Status: On Going\n// Topic: Audio Processing Start\n// Sources: Google ADSR or try FL studio \n\n\n#define line1Col vec3(0.,.2,1.)\n#define ringCol vec3(1.,.3,.3)\n#define letterCol vec3(0.0,0.4,1.)\n\nfloat distToLine(vec2 A, vec2 B, vec2 p){\n    \n    vec2 PA = p - A;\n    vec2 BA = B - A;\n    float d = dot(PA,BA);\n    float t = clamp(d/(length(BA)*length(BA)),0., 1.);//Vektorprodukt\n    vec2 normal = PA - BA*t;\n    return length(normal);\n\n}\n\nvec3 draw_line(vec2 A, vec2 B, vec2 uv, vec3 col){\n    return mix(col, line1Col, 1.0-smoothstep(0.01,0.02,\n    abs(distToLine(A, B, uv))));\n    \n}\n\nvec3 draw_point(vec2 Point, vec2 uv, vec3 col){\n    float f = 1.-smoothstep(0.01,0.012,\n    abs(length(uv-Point)-0.03));\n    col = mix(col, ringCol, f);\n    return col;\n    \n}\n\n// From oneshade\n// Modified version of font loader from https://www.shadertoy.com/view/ltcXzs\nvoid drawChar(inout vec3 color, in vec3 charColor, in vec2 p, in vec2 pos, in vec2 size, in int char) {\n    p = (p - pos) / size + 0.5;\n    if (all(lessThan(abs(p - 0.5), vec2(0.5)))) {\n        float val = textureGrad(iChannel1, p / 16.0 + \n        fract(vec2(char, 15 - char / 16) / 16.0), \n        dFdx(p / 16.0), dFdy(p / 16.0)).r;\n        \n        color = mix(color, charColor, val);\n    }\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5,0.5)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    vec2 st = uv;\n    //I'm only making an 8(*aspect)x8 grid, higher variables\n    //may end up with graphs completely outside it\n    uv += vec2(0.5,0.25);\n    uv*=8.;\n    //graph background\n    vec3 col = vec3(0.8);\n    col = mix(col,vec3(0.9),1.0-length(uv/8.));\n   // float specks = fract(sin(dot(uv,vec2(123.,16.)))*433413.);\n    \n    float tex = texture(iChannel0,st).x;\n    col = mix(col,vec3(0.7),tex);\n    \n    //small grid lines\n    vec2 lines = fract(uv*3.);\n    lines = smoothstep(0.45,0.5,abs(lines-0.5));\n    col = mix(col,vec3(0.7),lines.x);\n    col = mix(col,vec3(0.7),lines.y);\n    //larger grid lines\n    lines = fract(uv);\n    lines = smoothstep(0.45,0.5,abs(lines-0.5));\n    col = mix(col,vec3(0.3),lines.x);\n    col = mix(col,vec3(0.3),lines.y);\n    //axis lines\n    lines = smoothstep(0.02,0.025,abs(uv));\n    col = mix(col,vec3(0.,0.,0.0),1.0-lines.x);\n    col = mix(col,vec3(0.,0.,0.0),1.-lines.y);\n\n    //Animated ADSR Curve\n    vec2 Start = vec2(0.,0.);\n    vec2 A = vec2(0. + anim_Ax(iTime/2.), 1.);\n    vec2 D = vec2(0.4 + anim_Dx(iTime/2.), anim_Dy(iTime/4.));\n    vec2 S = vec2(0.8 + anim_Sx(iTime/2.), anim_Sy(iTime/2.));\n    vec2 R = vec2(1. + anim_Rx(iTime/2.), 0.);\n\n    float draw_scale = 1./4.;\n    st = uv-vec2(0.);\n    st *= draw_scale;\n    col = draw_line(Start,A,st,col);\n    col = draw_line(A,D,st,col);\n    col = draw_line(D,S,st,col);\n    col = draw_line(S,R,st,col);\n    \n    col = draw_point(Start,st,col);\n    col = draw_point(A,st,col);\n    col = draw_point(D,st,col);\n    col = draw_point(S,st,col);\n    col = draw_point(R,st,col);\n    \n    float time = iTime;//mod(iTime, 1.);\n    \n    //text rendering from oneshade\n    \n    //Render Word \"Attack\n  \n    vec2 word_start;\n    int word_attack_length = 6;\n    int word_attack[8];\n    vec2 letter_size = vec2(0.6);\n    \n    word_attack[0] = a;\n    word_attack[1] = t;\n    word_attack[2] = t;\n    word_attack[3] = a;\n    word_attack[4] = c;\n    word_attack[5] = k;\n    \n    word_start = A*4.+vec2(0.5,0.);\n    \n    for(int i = 0; i < word_attack_length; i++){\n        drawChar(col, letterCol, uv, word_start, letter_size,\n        word_attack[i]);\n        word_start += vec2(0.25,0.);\n    }\n    \n    //Render Word Decay\n    word_attack_length = 5;\n    //word_attack[5];\n    \n    word_attack[0] = d;\n    word_attack[1] = e;\n    word_attack[2] = c;\n    word_attack[3] = a;\n    word_attack[4] = y;\n\n    \n    word_start = D*4.+vec2(0.5,0.);\n    \n    for(int i = 0; i < word_attack_length; i++){\n        drawChar(col, letterCol, uv, word_start, letter_size,\n        word_attack[i]);\n        word_start += vec2(0.25,0.);\n    }\n\n    //Render Word Sustain\n    word_attack_length = 5;\n    //word_attack[5];\n    \n    word_attack[0] = s;\n    word_attack[1] = u;\n    word_attack[2] = s;\n    word_attack[3] = t;\n    word_attack[4] = n;\n\n    \n    word_start = S*4.+vec2(0.5,0.);\n    \n    for(int i = 0; i < word_attack_length; i++){\n        drawChar(col, letterCol, uv, word_start, letter_size,\n        word_attack[i]);\n        word_start += vec2(0.25,0.);\n    }\n    \n    //Render Word Sustain\n    word_attack_length = 7;\n    word_attack[7];\n    \n    word_attack[0] = r;\n    word_attack[1] = e;\n    word_attack[2] = l;\n    word_attack[3] = e;\n    word_attack[4] = a;\n    word_attack[5] = s;\n    word_attack[6] = e;\n    \n    \n    word_start = R*4.+vec2(0.5,0.);\n    \n    for(int i = 0; i < word_attack_length; i++){\n        drawChar(col, letterCol, uv, word_start, letter_size,\n        word_attack[i]);\n        word_start += vec2(0.25,0.);\n    }\n    \n    //vignette\n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    \n    vig = pow(vig, 0.15); // change pow for modifying the extend of the  vignette\n\n    // Output to screen\n    fragColor = vec4(col*vig,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 48,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [],
                "type": "image"
            },
            {
                "code": "\n\n// stereo sound output. x=left, y=right\nvec2 mainSound( in int samp, float time )\n{\n    \n    //ADSR Animation\n    vec2 Start = vec2(0.,0.);\n    vec2 A = vec2(0. + anim_Ax(time/2.), 1.);\n    vec2 D = vec2(0.4 + anim_Dx(time/2.), anim_Dy(time));\n    vec2 S = vec2(0.8 + anim_Sx(time/2.), anim_Sy(time));\n    vec2 R = vec2(1. + anim_Rx(time/2.), 0.);\n    \n    \n    float t = time;\n    time = mod(t, loop_length);\n\n    vec2 f = vec2(0.);\n    \n    f += adsrStab(time,freq_2,left_right,A,D,S,R);\n    f += adsrStab(time,freq_3,left_right,A,D,S,R);\n    f += adsrStab(time,freq_4,left_right,A,D,S,R);\n    f += adsrStab(time,freq_5,left_right,A,D,S,R);\n    \n    return f/16.;\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "#define left_right vec2(1.,1.)\n//c5\n#define freq_1 523.25 \n//e5\n#define freq_2 659.25\n//g5\n#define freq_3 783.99\n//b5\n#define freq_4 987.77\n//d5\n#define freq_5 1174.66\n\n//kick \n#define c2 65.41\n\n//highest frequency in a kick's\n//frequency adsr will be c3\n#define kick_freq_max 130.81\n\n\n#define scale_x .005\n#define squareNum 10.\n#define pi acos(-1.)\n#define two_pi pi*2.\n//for square waves\n#define L 0.5 \n\n//for sequencing\n#define note_length 1.\n#define loop_length 1.\n\n#define basicA vec2(0.001, 1.)\n#define basicD vec2(0.4, 0.3)\n#define basicS vec2(0.8, 0.3)\n#define basicR vec2(1.5, 0.)\n\n#define snareA vec2(0.0002, 1.)\n#define snareD vec2(0.12, 0.09)\n#define snareS vec2(0.3, 0.09)\n#define snareR vec2(0.7, 0.)\n\n#define brushA vec2(0.05, 0.6)\n#define brushD vec2(0.2, 0.1)\n#define brushS vec2(0.22, 0.05)\n#define brushR vec2(0.5, 0.)\n\n#define hatA vec2(0.001, 1.)\n#define hatD vec2(0.02, 0.5)\n#define hatS vec2(0.02, 0.4)\n#define hatR vec2(0.1, 0.)\n\n#define kNoiseA vec2(0.0002, 1.)\n#define kNoiseD vec2(0.03, 0.1)\n#define kNoiseS vec2(0.05, 0.1)\n#define kNoiseR vec2(0.06, 0.)\n\n#define kick_A vec2(0.0002, 1.)\n#define kick_D vec2(0.2, 0.)\n#define kick_S vec2(0.22, 0.)\n#define kick_R vec2(0.22, 0.)\n\n//kick frequency adsr\n#define kick_fA vec2(0.001, 1.)\n#define kick_fD vec2(0.2, 0.0)\n#define kick_fS vec2(0.22, 0.0)\n#define kick_fR vec2(0.22, 0.)\n\n#define stab_A vec2(0.0002, 1.)\n#define stab_D vec2(0.2, 0.1)\n#define stab_S vec2(0.22, 0.071)\n#define stab_R vec2(0.92, 0.)\n\n#define anim_Start 0.\n#define anim_Ax(t) clamp(sin(t),0.,.2)\n#define anim_Dx(t) clamp(sin(t*0.8 + 3.),.2,.4)\n#define anim_Sx(t) clamp(sin(t*0.9+2.),0.4,.7)\n#define anim_Rx(t) clamp(sin(t*1.1 + 1.),0.7,1.)\n\n#define anim_Dy(t) clamp(cos(t*0.9 + 1.5),.2,.9)\n#define anim_Sy(t) clamp(cos(t*0.95 + 5.5),.0,.2)\n\n//a lerb between arbitrary start and end times\nfloat generic_lerp(float tStart, \n                   float tEnd, \n                   float t,\n                   float valA,\n                   float valB){\n            \n           //as tEnd-t goes to tEnd-tEnd\n           //we move to zero\n           //the only thing we need is 1 at the start\n           //and at the start the value is (tEnd-tStart)\n           //so let's use (tEnd-tStart)\n           \n    return (valA*(tEnd-t))/(tEnd-tStart)\n    \n           //t-tStart is 0 at start\n           // (t-tStart)/(tEnd-tStart)\n           //is both null at start and 1 at end\n           //becayse t-tStart will go to exactly\n           //that distance beyond where it is (0).\n           \n         + (valB*(t-tStart)/(tEnd-tStart));\n}\n\n//an adsr filter with linear functions for each component\nfloat naiveADSR(float t, vec2 A, vec2 D, vec2 S, vec2 R){\n\n    vec2 Start = vec2(0.);\n    \n    float adsr= 0.;\n    if(t < A.x) \n        adsr = generic_lerp(Start.x,A.x,t,Start.y,A.y);\n    \n    else if(t < D.x)\n        adsr = generic_lerp(A.x,D.x,t,A.y,D.y);\n    \n    else if(t < S.x)\n        adsr = generic_lerp(D.x,S.x,t,D.y,S.y);\n        \n    else if(t < R.x)\n        adsr = generic_lerp(S.x,R.x,t,S.y,R.y);\n       \n    else adsr = 0.;\n             \n    return adsr;\n}\n\n//all these functions are written for stereo\n//meaning you can adjust the volume per ear from the \n//input \"lr\"\nvec2 stereoNoise(float t, float freq, vec2 lr){\n    float f = fract(sin(freq*t*234.)*43153.);\n    //float adsr = naiveADSR(t,snareA,snareD,snareS,snareR);\n    float adsr = naiveADSR(t,kNoiseA,kNoiseD,kNoiseS,kNoiseR);\n    return vec2(f*lr)*adsr;\n}\n\nvec2 stereoSin(float t, float freq, vec2 lr){\n    float adsr = naiveADSR(t,basicA,basicD,basicS,basicR);\n    return vec2(sin(freq*t*two_pi))*lr*adsr;\n}\n\nvec2 stereoStab(float t, float freq, vec2 lr){\n    float adsr = naiveADSR(t,stab_A,stab_D,stab_S,stab_R);\n    return vec2(sin(freq*t*two_pi*0.5))*lr*adsr;\n}\n\nvec2 adsrStab(float t, float freq, vec2 lr,\n              vec2 A, vec2 D, vec2 S, vec2 R){\n               \n    float adsr = naiveADSR(t, A, D, S, R);\n    return vec2(sin(freq*t*two_pi*0.5))*lr*adsr;\n}\n\nvec2 stereoKick(float t, float freq, vec2 lr){\n    float adsr = naiveADSR(t,kick_A,kick_D,kick_S,kick_R);\n    float freq_adsr = naiveADSR(t,kick_fA,kick_fD,kick_fS,kick_fR);\n    freq = (freq+freq_adsr*kick_freq_max)*0.6;\n    return vec2(sin(freq*t*two_pi))*lr*adsr;\n}\n\n//letters and numbers from oneshade\n\nconst int SPACE = 32;\nconst int Exclame = 33;\nconst int DOUBLE_QUOTE = 34;\nconst int HASHTAG = 35;\nconst int DOLLAR = 36;\nconst int PERCENT = 37;\nconst int AMPERSAND = 38;\nconst int SINGLE_QUOTE = 39;\nconst int OPEN_PARENTHESIS = 40;\nconst int CLOSE_PARENTHESIS = 41;\nconst int ASTERISK = 42;\nconst int PLUS = 43;\nconst int COMMA = 44;\nconst int HYPHEN = 45;\nconst int PERIOD = 46;\nconst int SLASH = 47;\nconst int ZERO = 48;\nconst int ONE = 49;\nconst int TWO = 50;\nconst int THREE = 51;\nconst int FOUR = 52;\nconst int FIVE = 53;\nconst int SIX = 54;\nconst int SEVEN = 55;\nconst int EIGHT = 56;\nconst int NINE = 57;\nconst int COLON = 58;\nconst int SEMICOLON = 59;\nconst int LESS_THAN = 60;\nconst int EQUAL = 61;\nconst int GREATER_THAN = 62;\nconst int QUESTION = 63;\nconst int AT = 64;\n\nconst int OPEN_BRACKET = 91;\nconst int BACKSLASH = 92;\nconst int CLOSE_BRACKET = 93;\nconst int CIRCUMFLEX = 94;\nconst int a = 97;\nconst int b = 98;\nconst int c = 99;\nconst int d = 100;\nconst int e = 101;\nconst int f = 102;\nconst int g = 103;\nconst int h = 104;\nconst int i = 105;\nconst int j = 106;\nconst int k = 107;\nconst int l = 108;\nconst int m = 109;\nconst int n = 110;\nconst int o = 111;\nconst int p = 112;\nconst int q = 113;\nconst int r = 114;\nconst int s = 115;\nconst int t = 116;\nconst int u = 117;\nconst int v = 118;\nconst int w = 119;\nconst int x = 120;\nconst int y = 121;\nconst int z = 122;\nconst int OPEN_BRACE = 123;\nconst int PIPE = 124;\nconst int CLOSE_BRACE = 125;\nconst int TILDE = 126;",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}