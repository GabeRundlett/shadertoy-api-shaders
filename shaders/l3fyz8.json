{
    "Shader": {
        "info": {
            "date": "1725830379",
            "description": "intersection of a ray and a lens",
            "flags": 48,
            "hasliked": 0,
            "id": "l3fyz8",
            "likes": 1,
            "name": "ray-lens intersection",
            "published": 3,
            "tags": [
                "3d",
                "intersector"
            ],
            "usePreview": 0,
            "username": "ArmandB",
            "viewed": 106
        },
        "renderpass": [
            {
                "code": "struct hit {\n    float t;\n    bool inside;\n    vec3 p;\n    vec3 n;\n};\n\nhit[2] sphere_intersect(Ray ray, vec3 origin, float radius) {\n    vec3 oc = ray.o - origin;\n    float b = dot(oc,ray.d);\n    float r2 = radius*radius;\n    vec3 fbd = oc - b * ray.d;\n    float d = r2 - dot(fbd, fbd);\n    if (d >= 0.0){\n        float t1 = -b - sqrt(d);\n        float t2 = -b + sqrt(d);\n        vec3 p1 = ray.o + t1*ray.d;\n        vec3 p2 = ray.o + t2*ray.d;\n        return hit[2](\n            hit((t1 >= 0.0 ? t1 : 1e20), false, p1, normalize(p1 - origin)),\n            hit((t2 >= 0.0 ? t2 : 1e20), true, p2, -normalize(p2 - origin))\n        );\n    } else {\n        return hit[2](\n            hit(1e20, false, vec3(0), vec3(0)), \n            hit(1e20, false, vec3(0), vec3(0))\n        );\n    }\n}\n\nhit trunc_cone_intersect(Ray ray, float p1, float p2, float l) {\n    float d = p1-p2;\n    float d2 = d*d;\n    float l2 = l*l;\n    float a = ray.d.z*ray.d.z*d2/l2 - dot(ray.d.xy,ray.d.xy);\n    float b = ray.d.z*d*(p1 - ray.o.z*d/l)/l + dot(ray.d.xy,ray.o.xy);\n    float c = p1*p1 - ray.o.z*(2.0*p1*d - ray.o.z*d2/l)/l - dot(ray.o.xy,ray.o.xy);\n    float det = b*b - a*c;\n    if (det >= 0.0){\n        float k = 1.0/sqrt(d2 + l2);\n        \n        float t1 = (b - sqrt(det))/a;\n        float t2 = (b + sqrt(det))/a;\n        vec3 i1 = ray.o + ray.d*t1;\n        vec3 i2 = ray.o + ray.d*t2;\n        \n        vec3 n1;\n        if (i1.z >= 0.0 && i1.z <= l){\n            vec2 h1 = i1.xy*l*k/length(i1.xy);\n            n1 = -vec3(h1,d*k);\n        } else {\n            t1 = 1e20;\n        }\n        \n        vec3 n2;\n        if (i2.z >= 0.0 && i2.z <= l){\n            vec2 h2 = i2.xy*l*k/length(i2.xy);\n            n2 = vec3(h2,d*k);\n        } else {\n            t2 = 1e20;\n        }\n        \n        t1 = (t1 >= 0.0 ? t1 : 1e20);\n        t2 = (t2 >= 0.0 ? t2 : 1e20);\n        \n        if (t1 < t2){\n            return hit(t1, true, i1, n1);\n        }\n        return hit(t2, false, i2, n2);\n    } else {\n        return hit(1e20, false, vec3(0), vec3(0));\n    }\n}\n\nhit min_hit(hit h1, hit h2){\n    if (h1.t < h2.t){\n        return h1;\n    }\n    return h2;\n}\n\nhit cap_intersect(Ray ray, float r, float p){\n    float p2 = p*p;\n    float j = sqrt(r*r - p*p);\n    float w = r - sign(r)*j;\n    hit[2] c = sphere_intersect(ray, vec3(0,0,-sign(r)*j), r);\n    float l1 = min(w,0.0);\n    float l2 = max(w,0.0);\n    c[0].t = (dot(c[0].p.xy,c[0].p.xy) <= p2 && c[0].p.z <= l2 && c[0].p.z >= l1) ? c[0].t : 1e20;\n    c[1].t = (dot(c[1].p.xy,c[1].p.xy) <= p2 && c[1].p.z <= l2 && c[1].p.z >= l1) ? c[1].t : 1e20;\n    return min_hit(c[0],c[1]);\n}\n\n// see preview: https://www.desmos.com/calculator/yzjnr4kc0t\nhit len_intersect(Ray ray, float r1, float r2, float p1, float p2, float l){\n    hit c = trunc_cone_intersect(ray, p1, p2, l);\n    hit s1 = cap_intersect(ray, -r1, p1);\n    s1.inside = s1.inside == (r1 > 0.0);\n    ray.o.z -= l;\n    hit s2 = cap_intersect(ray, r2, p2);\n    s2.inside = s2.inside == (r2 > 0.0);\n    return min_hit(min_hit(s1,s2),c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 position = texelFetch(iChannel0, ivec2(4,0),0).xyz;\n    vec3 rotation = vec3(texelFetch(iChannel0, ivec2(1,0),0).yx*vec2(-1,1),0)*sensitivity;\n    Camera cam = createCamera(fragCoord, iResolution.xy, position, rotation, cameraFrustum);\n\n    hit h;\n    float lir = 1.0;\n    for (int i = 0; i < 10 && (h = len_intersect(cam.ray, 8.0, 8.0, 4.0, 4.0, 1.0)).t != 1e20; i++){\n        if (i == 0) lir = h.inside ? 1.5 : 1.0;\n        float ir = h.inside ? 1.0 : 1.5;\n        vec3 refracted = refract(cam.ray.d, h.n, lir/ir);\n        if (refracted == vec3(0)){ // internal reflection\n            ir = h.inside ? 1.5 : 1.0;\n            cam.ray.d = reflect((h.inside ? 1.0 : -1.0)*h.n, cam.ray.d);\n        } else {\n            cam.ray.d = refracted;\n        }\n        cam.ray.o = h.p + h.n*0.0001;\n        lir = ir;\n    }\n\n    fragColor = texture(iChannel1,cam.ray.d);\n    \n    //hit h = len_intersect(cam.ray, -1.0, 4.0, 1.0, 1.0, 1.0);\n    //fragColor = h.inside ? vec4(1,0,0,1) : vec4(0,1,0,1);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.14159265\n#define cameraFrustum 0.7\n\nconst float sensitivity = 4.0;\nconst float moveSpeed = 0.1;\nconst float moveDamping = 0.7;\n\n//helpers\n\nmat3 rotationMatrix(vec3 a){\n    //calculate consts\n    float cx = cos(a.x);\n    float sx = sin(a.x);\n    float cy = cos(a.y);\n    float sy = sin(a.y);\n    float cz = cos(a.z);\n    float sz = sin(a.z);\n    //return matrix\n    return mat3(\n        cy*cz, sx*sy*cz - cx*sz, cx*sy*cz + sx*sz,\n        cy*sz, sx*sy*sz + cx*cz, cx*sy*sz - sx*cz,\n        -sy, sx*cy, cx*cy\n    );\n}\n\n//returns a point rotated in 3d (radians)\nvec3 rotate3d(vec3 point, vec3 angle, vec3 origin){ \n    point -= origin; //subtract pivot\n    point *= rotationMatrix(angle); //rotate point\n    point += origin; //add pivot\n    return point;\n}\n\nvec3 getSkyColor(vec3 dir){\n    vec3 skycol = vec3(0);\n    vec3 water = vec3(0.3,0.4,0.8);\n    vec3 sky = vec3(0,0.6,1);\n    vec3 haze = vec3(0.9,0.9,0.9);\n    if (dir.y < 0.0) {\n        skycol = mix(haze, water, clamp(-dir.y,0.0,1.0));\n    } else {\n        skycol = mix(haze, sky, clamp(dir.y,0.0,1.0));\n    }\n    return skycol;\n}\n\nstruct Ray {\n    vec3 o;\n    vec3 d;\n};\n\nstruct Camera {\n    vec3 position;\n    Ray ray;\n    vec2 uv;\n};\n\n//camera constructor\nCamera createCamera(vec2 fragCoord, vec2 resolution, vec3 cameraPos, vec3 camRot, float frustumLength){\n    vec3 uv = vec3((fragCoord - resolution*0.5)/resolution.y, frustumLength);\n    vec3 uvd = normalize(uv);\n    mat3 rotmat = rotationMatrix(camRot);\n    vec3 ro = uv*rotmat + cameraPos;\n    vec3 rd = uvd*rotmat;\n    return Camera(cameraPos, Ray(ro, rd), uv.xy);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "const int _w = 87;\nconst int _a = 65;\nconst int _s = 83;\nconst int _d = 68;\nconst int _space = 32;\nconst int _shift = 16;\nconst int _c = 67;\nconst int _v = 86;\n\nfloat keyPressed(int key){\n    return float(texelFetch(iChannel1, ivec2(key,0),0).x >= 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n    //rotation\n    if (floor(fragCoord) == vec2(1,0)) {\n        vec2 prevpos = texelFetch(iChannel0, ivec2(1,0), 0).zw; //previous dragged mouse pos\n        vec4 mp = texelFetch(iChannel0, ivec2(2,0), 0); //prev mouse pos\n        vec4 m = vec4(iMouse.xy/iResolution.xy,iMouse.zw/iResolution.xy); //current mouse pos\n        \n        if (iFrame <= 1){\n            col = vec2(0.0,0.0).xyxy;\n        } else {\n            //if mouse button up\n            if (m.z < 0.0 && mp.z >= 0.0){\n                col = texelFetch(iChannel0, ivec2(1,0), 0).xyxy;\n            } else if (m.z >= 0.0){\n                col = vec4(m.xy - abs(m.zw) + prevpos, prevpos);\n            } else {\n                col = texelFetch(iChannel0, ivec2(1,0), 0);\n            }\n        }\n        \n        if (col.y*sensitivity > PI/2.0){\n            col.y = PI/2.0/sensitivity;\n        }\n        if (col.y*sensitivity < -PI/2.0){\n            col.y = -PI/2.0/sensitivity;\n        }\n    }\n    //the last mouse position\n    if (floor(fragCoord) == vec2(2,0)) {\n        col = vec4(iMouse.xy/iResolution.xy,iMouse.zw/iResolution.xy);\n    }\n    \n    //velocity\n    if (floor(fragCoord) == vec2(3,0)){\n        vec3 velocity = texelFetch(iChannel0, ivec2(3,0), 0).xyz;\n        vec3 position = texelFetch(iChannel0, ivec2(4,0), 0).xyz;\n        vec2 forward = rotate3d(vec3(1,0,0),vec3(0,texelFetch(iChannel0, ivec2(1,0),0).x*sensitivity,0), vec3(0)).xz;\n        vec2 right = vec2(-forward.y,forward.x);\n        vec3 relative = vec3(keyPressed(_d)-keyPressed(_a), 0, keyPressed(_w)-keyPressed(_s));\n        float up = keyPressed(_space) - keyPressed(_shift);\n        vec3 move = vec3(relative.x*forward.x + relative.z*right.x, up, relative.x*forward.y + relative.z*right.y);\n        velocity = move != vec3(0) ? velocity*moveDamping + normalize(move)*moveSpeed : velocity*moveDamping;\n        \n        if (position.y < -1000.0){\n            velocity = vec3(0);\n        }\n        col.xyz = velocity;\n    }\n    \n    //position\n    if (floor(fragCoord) == vec2(4,0)){\n        vec3 velocity = texelFetch(iChannel0, ivec2(3,0), 0).xyz;\n        vec3 position = texelFetch(iChannel0, ivec2(4,0), 0).xyz;\n        position += velocity*iTimeDelta*60.0;\n        \n        if (position.y < -500.0){\n            position = vec3(0,24,0);\n        }\n        \n        if (iFrame == 0){\n            position = vec3(0,0,-15);\n        }\n        col.xyz = position;\n    }\n    \n    //resolution\n    if (floor(fragCoord) == vec2(5,0)){\n        col.xy = iResolution.xy;\n    }\n    //light direction\n    if (floor(fragCoord) == vec2(6,0)){\n        float t = texelFetch(iChannel0,ivec2(6,0),0).w;\n        if (iFrame == 0){\n            t = 0.5;\n        }\n        col.xyz = vec3(sin(t*PI*2.0),cos(t*PI*2.0),0);\n        col.w = t + (keyPressed(_c) - keyPressed(_v))*0.01;\n    }\n    \n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}