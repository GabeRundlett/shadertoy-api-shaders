{
    "Shader": {
        "info": {
            "date": "1709886259",
            "description": "Default Perslin noise in 3D and 2D, nothing special just for practise and for me to grab it for more interesting projects. ",
            "flags": 0,
            "hasliked": 0,
            "id": "MXB3DV",
            "likes": 3,
            "name": "Perlin Noise with Octaves",
            "published": 3,
            "tags": [
                "2d",
                "3d",
                "noise",
                "perlin",
                "octave"
            ],
            "usePreview": 0,
            "username": "gehtsiegarnixan",
            "viewed": 154
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright Â© 2024 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nI wanted to practise 2D (in Common) and 3D Perlin noise, so here it is. Nothing \nspecial or unique just Perlin with octaves for other shaders to do interesting \nstuff with it. \n\nSee also Voronoi noise implementation with cardinal tiling: \nhttps://www.shadertoy.com/view/lcBSRG\n\nOr have a look at cleaned up version of Alligator noise:\nhttps://www.shadertoy.com/view/4fX3D8\n*/\n\n// Size of the noise cells, value range 1-inf\n#define GRIDSIZE 8.0\n\n// Number of noise Layers, value range 1-inf\n#define OCTAVES 8\n\n// Scaling of successive octaves, value range 1-inf\n#define LACUNARITY 2.0\n\n// Amplitude reduction of each successive octave, value range 0-1\n#define PERSISTENCE 0.5\n\n// Enable repeating Tiling.\n#define TILING\n\n// Add lines for the grid outlines\n#define SHOWGRID\n\n// Function to generate 3D Perlin noise\nfloat perlin(vec3 position, uint gridsize, uvec3 seed) {\n    #ifdef TILING\n        // Modulo operation may have floating point errors with negative values,\n        // which can break tiling. This fix should be sufficient, hopefully ...\n        position = abs(position + 421.);\n    #endif\n\n    // Scale the position by the grid size\n    position *= float(gridsize);\n    \n    // Calculate the cell coordinates and fractional part\n    vec3 id = floor(position); // Integer coordinates\n    vec3 grid = position - id; // Fractional coordinates    \n    \n    // Sample noise at the corners   \n    float corners[8];\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 2; j++) {\n            for (int k = 0; k < 2; k++) {\n            \n                // Initalize current array index and offset\n                int index = 4*i + 2*j + k;                \n                vec3 offset = vec3(i,j,k);\n                \n                // Current cell coordinates with offset\n                vec3 cell = id + offset;\n\n                #ifdef TILING\n                    // This makes the noise repeat between positions 0 and 1\n                    cell = mod(cell, float(gridsize));\n                #endif\n\n                // Generate a random offset for the current cell\n                vec3 randomOffset = hash33(cell + vec3(seed)) *2.-1.;\n\n                // generate random gradient    \n                corners[index] = dot(grid - offset, randomOffset);\n            }\n        }\n    }   \n    \n    // generate smoother weight values\n    vec3 smoothGrid = smoothValue(grid); // for some contrast\n\n    float result = mix(mix(mix(corners[0], corners[1], smoothGrid.z), \n                           mix(corners[2], corners[3], smoothGrid.z), smoothGrid.y),\n                       mix(mix(corners[4], corners[5], smoothGrid.z), \n                           mix(corners[6], corners[7], smoothGrid.z), smoothGrid.y), smoothGrid.x);\n    \n    // rescale result to 0-1\n    return result *0.5+0.5;\n}\n\n// Noise with Octaves perlin 3D in this case\nfloat octaveNoise(vec3 position, float gridsize, int octaves, float lacunarity, float persistence) {\n    \n    // Initialize the variables    \n    // For amplitude math, see: https://www.desmos.com/calculator/xgqeepapwn\n    uvec3 seed = uvec3(659);\n    float amplitude = 1.0;\n    float amplitudeSum = 0.0;\n    float result = 0.0;\n    \n    // For each octave\n    for(int i = 0; i < octaves; ++i) {\n        // Sample noise and apply amplitude\n        result += perlin(position, uint(gridsize), seed) * amplitude;\n        \n        // Add up amplitude to normalize the result later\n        amplitudeSum += amplitude;\n        \n        // Increase frequency for the next octave\n        gridsize *= lacunarity;\n        \n        // Decrease amplitude for the next octave\n        amplitude *= persistence;\n        \n        // Change seed/offset noise so it is unique for the next octave\n        seed += uvec3(gridsize);\n    }\n    \n    // Normalize the result to the 0-1 range\n    result /= amplitudeSum;\n\n    return result;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Square UVs with (0.5,0.5) in the center\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y + 0.5; \n    \n    // If the mouse was not clicked, animate\n    float height;\n    float zoom;\n    if (iMouse.x > 0.0) {\n        // scale mouse coords to 0-1 range of screen\n        vec2 mouse = iMouse.xy / iResolution.xy;\n    \n        // Mouse controls zoom with steps\n        float zoomsteps = 15.0;\n        zoom = mix(1.75, 0.1, pow(floor(mouse.y * zoomsteps) / zoomsteps, 0.5));\n    \n        // Mouse controls the height of the noise slice\n        height = mix(-0.1, 1.1, mouse.x);\n    } else {\n        // Animated zoom\n        float zoomTime = iTime * 0.1;\n        zoom = mix(1.1, 0.5, -cos(zoomTime) * 0.5 + 0.5);\n    \n        // Animated height of the noise slice\n        height = iTime * 0.01;\n    } \n    \n    // Apply zoom on coordinates (0.5,0.5) point\n    uv = (uv - 0.5) * zoom + 0.5;\n    \n    // Generate position from UV and height\n    vec3 position = vec3(uv, height);\n        \n    // Sample noise\n    float noise = octaveNoise(position, GRIDSIZE, OCTAVES, LACUNARITY, PERSISTENCE);\n    \n    // Aristic increase of the variance, so the noise is not so gray\n    noise = smoothContrast(noise, 3.);\n    \n    // Apply colormap for better readability\n    vec3 color = YlGnBu_r(noise);\n\n    #ifdef SHOWGRID\n        // Add lines on the edges of the grid\n        float thickness = 0.01;\n        vec2 grid = abs(fract(uv) * 2.0 - 1.0);\n        color *= smoothstep(thickness*0.1, thickness, 1.-max(grid.x, grid.y));  \n    #endif\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// GENERIC FUNCTIONS ___________________________________________________\n\n// makes YlGnBu_r colormap with polynimal 6\nvec3 YlGnBu_r(float t) {\n    const vec3 c0 = vec3(0.016999,0.127718,0.329492);\n    const vec3 c1 = vec3(1.571728,0.025897,2.853610);\n    const vec3 c2 = vec3(-4.414197,5.924816,-11.635781);\n    const vec3 c3 = vec3(-12.438137,-8.086194,34.584365);\n    const vec3 c4 = vec3(67.131044,-2.929808,-58.635788);\n    const vec3 c5 = vec3(-82.372983,11.898509,47.184502);\n    const vec3 c6 = vec3(31.515446,-5.975157,-13.820580);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See: https://www.desmos.com/calculator/hs1nsjb32q\nfloat smoothContrast(float alpha, float contrast) {\n    // increase steepness using power\n    float powAlpha = pow(alpha, contrast);\n    float powInfAlpha = pow(1.-alpha, contrast);\n    \n    // normalize back to precentage of 1\n    return powAlpha/(powAlpha + powInfAlpha);\n}\n\n// Struct to hold the 8 weights for trilinear interpolation\nstruct triWeights {\n    float a;\n    float b;\n    float c;\n    float d;\n    float e;\n    float f;\n    float g;\n    float h;\n};\n\n// Make tiling trilinear weights\ntriWeights trilinearWeights(vec3 uvw) {\n    // Generate zigzag pattern\n    vec3 zigZag = abs(fract(uvw * 0.5) * 2.0 - 1.0);\n    \n    // Invert zigzag as a partial of the weights\n    vec3 infZigZag = 1.0 - zigZag;\n\n    // Generate alpha values (weights) for trilinear interpolation.\n    float a = zigZag.x * zigZag.y * zigZag.z;\n    float b = zigZag.x * zigZag.y * infZigZag.z;\n    float c = zigZag.x * infZigZag.y * zigZag.z;\n    float d = zigZag.x * infZigZag.y * infZigZag.z;\n    float e = infZigZag.x * zigZag.y * zigZag.z;\n    float f = infZigZag.x * zigZag.y * infZigZag.z;\n    float g = infZigZag.x * infZigZag.y * zigZag.z;\n    float h = infZigZag.x * infZigZag.y * infZigZag.z;\n    \n    // Combine weight/alpha values. \n    return triWeights(a, b, c, d, e, f, g, h);\n}\n\n// Make tiling bilinear weights\nvec4 bilinearWeights(vec2 uv) {\n    // Generate zigzag pattern\n    vec2 zigZag = abs(fract(uv * 0.5) * 2.0 - 1.0);\n    \n    // Invert zigzag as a partial of the weights\n    vec2 infZigZag = 1.0 - zigZag;\n\n    // Generate alpha values (weights) for bilinear interpolation.\n    float weightA = zigZag.x * zigZag.y;\n    float weightB = zigZag.x * infZigZag.y;\n    float weightC = infZigZag.x * zigZag.y;\n    float weightD = infZigZag.x * infZigZag.y;\n    \n    // Combine weight/alpha values. \n    return vec4(weightA, weightB, weightC, weightD);\n}\n\n// Simplified Smoothstep https://www.desmos.com/calculator/un0o21eokv\nvec2 smoothValue(vec2 x) {\n    x = clamp(x, 0.0, 1.0);\n    return x * x * (3.0 - 2.0 * x);\n}\n\n// Simplified Smoothstep\nvec3 smoothValue(vec3 x) {\n    x = clamp(x, 0.0, 1.0);\n    return x * x * (3.0 - 2.0 * x);\n}\n\n// HASH FUNCTIONS ____________________________________________________\n\n// 3 in 3 out hash from \n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\nvec3 hash33(vec3 p) {\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n\n// My customized hash which is faster than a texture lookup\n// inspired by David Hoskins https://www.shadertoy.com/view/XdGfRR\n#define VPRIME1 uvec2(3480082861U, 2420690917U)\n#define VPRIME2 uvec2(1317666547U, 2149110343U)\n#define SMALLESTFLOAT (1.0 / float(0xffffffffU))\nvec2 hash22(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * VPRIME1;\n\tq = (q.x & q.y) * VPRIME2;\n    return vec2(q) * SMALLESTFLOAT;\n}\n\n// PERLIN NOISE 2D ____________________________________________________\n\n// Helper Function for Perlin noise\nfloat rndGradient(vec2 grid, vec2 id, vec2 offset, uint gridsize, uvec2 seed) {\n\n    // Current cell coordinates\n    vec2 cell = id + offset;\n\n    #ifdef TILING\n        // This makes the noise repeat between positions 0 and 1\n        cell = mod(cell, float(gridsize));\n    #endif\n\n    // Generate a random offset for the current cell\n    vec2 randomOffset = hash22(cell + vec2(seed)) *2.-1.;\n    \n    // generate random gradient    \n    return dot(grid - offset, randomOffset);\n}\n\n// Function to generate Perlin 2D noise\nfloat perlin(vec2 position, uint gridsize, uvec2 seed) {\n\n    // Scale the position by the grid size\n    position *= float(gridsize);\n    \n    // Calculate the cell coordinates and fractional part\n    vec2 id = floor(position.xy); // Integer coordinates\n    vec2 grid = position.xy - id; // Fractional coordinates    \n    \n    // Sample noise at the corners\n    float a = rndGradient(grid, id, vec2(0,0), gridsize, seed);\n    float b = rndGradient(grid, id, vec2(0,1), gridsize, seed);\n    float c = rndGradient(grid, id, vec2(1,0), gridsize, seed);\n    float d = rndGradient(grid, id, vec2(1,1), gridsize, seed);\n    \n    // generate weight values\n    vec2 smoothCoords = smoothValue(grid); // for some contrast\n    vec4 weights = bilinearWeights(smoothCoords);\n    \n    // Bilinear interpolation between the corner values\n    float result = a * weights.x + b * weights.y + c * weights.z + d * weights.w;\n    \n    // rescale result to 0-1\n    return result *0.5+0.5;\n}\n\n// Noise with Octaves perline 2D in this case\nfloat octaveNoise(vec2 position, float gridsize, int octaves, float lacunarity, float persistence) {\n    \n    // Initialize the variables    \n    // For amplitude math, see: https://www.desmos.com/calculator/xgqeepapwn\n    uvec2 seed = uvec2(659);\n    float amplitude = 1.0;\n    float amplitudeSum = 0.0;\n    float result = 0.0;\n    \n    // For each octave\n    for(int i = 0; i < octaves; ++i) {\n        // Sample noise and apply amplitude\n        result += perlin(position, uint(gridsize), seed) * amplitude;\n        \n        // Add up amplitude to normalize the result later\n        amplitudeSum += amplitude;\n        \n        // Increase frequency for the next octave\n        gridsize *= lacunarity;\n        \n        // Decrease amplitude for the next octave\n        amplitude *= persistence;\n        \n        // Change seed/offset noise so it is unique for the next octave\n        seed += uvec2(gridsize);\n    }\n    \n    // Normalize the result to the 0-1 range\n    result /= amplitudeSum;\n\n    return result;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}