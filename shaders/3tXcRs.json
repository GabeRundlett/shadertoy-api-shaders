{
    "Shader": {
        "info": {
            "date": "1592737634",
            "description": "Using simplex noise to generate a trabecular structure (faster than voronoi based methods)\nstatic version: [url]https://www.shadertoy.com/view/WtXcRj[/url]\n2d version: [url]https://www.shadertoy.com/view/tlfczS[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "3tXcRs",
            "likes": 30,
            "name": "Simplex Trabeculae",
            "published": 3,
            "tags": [
                "simplex",
                "sponge",
                "cave",
                "trabeculum",
                "network"
            ],
            "usePreview": 1,
            "username": "izutionix",
            "viewed": 626
        },
        "renderpass": [
            {
                "code": "#define STEPS 256\n#define TMAX 100.\n#define PRECIS .0001\n\n#define r(a) mat2( cos(a), -sin(a), sin(a), cos(a) )\n\n#define shaded 0\n\nvec3 hash33(vec3 c, float r) {\n\tvec3 h = .5*normalize(fract(vec3(8., 1., 64.)*sin( dot(vec3(17., 59.4, 15.), c) )*32768.)-.5);\n    return mix(vec3(.4), h, r); // attenuate randomness (make sure everything on the path of the camera is not random)\n}\n\n/* 3d simplex noise from candycat's \"Noise Lab (3D)\" https://www.shadertoy.com/view/4sc3z2\nbased on the one by nikat: https://www.shadertoy.com/view/XsX3zB */\nvec4 simplex_noise(vec3 p, float r) {\n    \n    const float K1 = .333333333;\n    const float K2 = .166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n    \n    vec3 e = step(vec3(0.), d0 - d0.yzx);\n\tvec3 i1 = e * (1. - e.zxy);\n\tvec3 i2 = 1. - e.zxy * (1. - e);\n    \n    vec3 d1 = d0 - (i1 - 1. * K2);\n    vec3 d2 = d0 - (i2 - 2. * K2);\n    vec3 d3 = d0 - (1. - 3. * K2);\n    \n    vec4 h = max(.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i, r)), dot(d1, hash33(i + i1, r)), dot(d2, hash33(i + i2, r)), dot(d3, hash33(i + 1., r)));\n    \n    return 70.*n;\n}\n\n// see https://www.shadertoy.com/view/ttsyRB\nvec4 variations(vec4 n) {\n    vec4 an = abs(n);\n    vec4 s = vec4(\n        dot( n, vec4(1.) ),\n        dot( an,vec4(1.) ),\n        length(n),\n        max(max(max(an.x, an.y), an.z), an.w) );\n    \n    float t =.27;\n    \n    return vec4(\n\t\t// worms\n\t\tmax(0., 1.25*( s.y*t-abs(s.x) )/t),\n\t\t// cells (trabeculae)\n    \tpow( (1.+t)*( (1.-t)+(s.y-s.w/t)*t), 2.), //step( .7, (1.+t)*( (1.-t)+(s.y-s.w/t)*t) ),\n\t\t.75*s.y,\n    \t.5+.5*s.x);\n}\n\nfloat map(vec3 p) {\n    float c = smoothstep(0., 1., length(p.xy)-.1); // controls the randomness\n    p += vec3(-.65, .35, 44.85);\n    float s = 1.;\n    float n = variations( simplex_noise(p*s*.5, c) ).y;\n    n = .78-n;\n    n /= s*4.;\n    \n    return n;\n}\n\nfloat march(vec3 ro, vec3 rd) {\n\tfloat t = .01;\n    for(int i=0; i<STEPS; i++) {\n        float h = map(ro + rd * t);\n        t += h;\n        if(t>TMAX || abs(h)<PRECIS) break;\n    }\n    return t;\n}\n\nvec3 normal(vec3 p) {\n    vec2 e = vec2(.4, 0);\n    return normalize(\n        map(p) - vec3(\n        map(p-e.xyy),\n        map(p-e.yxy),\n        map(p-e.yyx)\n        ) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(0.); ro.z = iTime*.67;\n    vec3 rd = vec3(uv, .5);\n    \n    vec3 l = normalize( vec3(-3,2,1) );\n    \n    float fc = exp2( .5*dot(rd, l) )*.5;\n    \n\tfloat t = march(ro, rd);\n    vec3 p = ro + rd * t;\n    \n    float dif = 0.;\n#if shaded\n    vec3 n = normal(p);\n    dif = dot(n, l)*.5+.5;\n    dif *= .125;\n#endif\n    \n    float fog = pow(1.-.05/(t*.75+.5), 25.);\n    float v = mix(dif, fc, fog);\n    v *= v;\n    \n    vec3 col = 1.-vec3(.67, .45, .05);\n    col = pow(vec3(v), col*1.5 );\n    \n\t// subtle texture\n    col += .004*(texture(iChannel0, fragCoord*.001*r(.2)+.1).x-.5)\n          +.008*(texture(iChannel0, fragCoord*.002*r(.3)+.1).x-.5)\n          +.015*(texture(iChannel0, fragCoord*.004*r(.5)+.1).x-.5)\n          +.03 *(texture(iChannel0, fragCoord*.008*r(.7)+.1).x-.5);\n    \n    col = smoothstep(0., 1., 2.3*col);\n    \n    fragColor = vec4(col, 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}