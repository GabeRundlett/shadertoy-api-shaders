{
    "Shader": {
        "info": {
            "date": "1614119776",
            "description": "Made customizable functions for paired toruses. I made four pairs of toruses with blend function. ",
            "flags": 0,
            "hasliked": 0,
            "id": "tlVBRm",
            "likes": 0,
            "name": "Bouncy Castle Outerspace",
            "published": 3,
            "tags": [
                "raymarching",
                "template",
                "artofcode"
            ],
            "usePreview": 0,
            "username": "YitingLiu",
            "viewed": 247
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    return length(p-c)-r;\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    //t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdTorus(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat torus(vec3 p, vec2 offs, mat2 rotVal, float t, float merge){\n\n    //offs=vec2(1.5,.2);\n    \n    vec3 bp = p;\n    bp -= vec3(0,.75,3);\t\t// translation\n    \n    float y = -fract(t)*(fract(t)-1.)*merge;\t\t\t// repeating parabola\n    vec3 tp = p;\n    tp -= vec3(-5, .8+2.*y, -5.*(sin(t)*.5+.5));\t\t\t\t\t// translate\n   \n    float squash = 1.+smoothstep(.5, .25, y)*2.;// scale\n    tp.y *= squash;\n    tp = tp.xzy;\t\t\t\t\t\t\t\t// flip torus on its side\n   \n    vec3 tp2 = p;\n   \n    tp2 -= vec3(-3, .8+1.*y, -3.*(cos(t)*.5+.5));\t\t\t\t\t// translate\n    tp2.y *= squash;\n    tp2 = tp2.xyz;\t\t\t\t\t\t\t\t// flip torus on its side\n\n    tp.yz*=rotVal;\n    tp2.xy*=Rot(t);\n    float scale = sdTorus(tp, offs)/squash;\n    float scale2 = sdTorus(tp2, vec2(offs*(sin(t)*.5+1.)))/squash;\n    \n   // vec2 pairs = vec2(scale,scale2);\n        \n    float blendTorus = smin(\n        scale,\n        scale2,\n        .8\n    );\n    return blendTorus; \n\n}\n\nfloat mergeBoxes(vec3 p, vec3 offs, vec3 size1, vec3 size2, float strength, float t){\n    vec3 bp = p;\n    bp -= vec3(0,.75,3);\t\t// translation\n    bp.xz *= Rot(iTime);\t\t// rotation\n    float rotate = dBox(bp, vec3(.75));\n    \n    /**\n    offs=vec3(3,1.,-3);\n    size1 =vec3(.5,.8*sin(t),.5*cos(t));\n    size2 = vec3(.5,.2,1.);\n    **/\n    float blendBoxes = smin(\n        dBox(p-offs, size1),    \n        dBox(p-offs, size2),strength);\n        \n   return blendBoxes;\n}\n\nfloat subtract(vec3 p, vec3 s, vec3 offs){\n// -dBox(p-vec3(1.+sin(t)*.5,1,0), vec3(1,.5,2)), \n//offs vec3(0,1,0)\n    float subtract = max(\n        -dBox(p,s), \n        length(p-offs)-.8\n    );\n    \n    return subtract; \n}\n\n\n\nfloat GetDist(vec3 p) {\n    \n    float t = iTime;\n    \n    // ground plane\n    float pd = p.y;\n    float blendTorus = torus(p,vec2(2.,.5),Rot(t),t,1.);\n    float blendTorus2 = torus(p-.5,vec2(7.,.1),Rot(t*2.),t*.5,.7);\n    float blendTorus3 = torus(p-2.,vec2(5.,.2),Rot(sin(t)),t,1.);\n    float blendTorus4 = torus(p-3.,vec2(4.,.3),Rot(sin(t)),t,1.);\n    \n    //merging boxes in 90 degrees \n    vec3 offs=vec3(3,1.,-3), size1 =vec3(2.,.8*(sin(t)*.5+.5),2.*cos(t)), size2 = vec3(.5,2.,1.);\n    float strength = 1.; // 0 1 \n    float blendBoxes = mergeBoxes(p,offs, size1, size2,strength, t);\n    \n  \n   float subVal = subtract(p-vec3(3.+sin(t)*.5,2.,0.8), vec3(2.,.5,2),vec3(0,2.5,0));\n\n /**   // rotating box\n    vec3 bp = p;\n    bp -= vec3(0,.75,3);\t\t// translation\n    //bp.xz *= Rot(iTime);\t\t// rotation\n    float rotate = dBox(bp, vec3(.75));\n    \n    // jumping torus\n    float y = -fract(t)*(fract(t)-1.);\t\t\t// repeating parabola\n    vec3 tp = p;\n    tp -= vec3(-3, .8+1.*y, -3.*(sin(t)*.5+.5));\t\t\t\t\t// translate\n   \n    float squash = 1.+smoothstep(.5, .25, y)*.5;// scale\n    tp.y *= squash;\n    tp = tp.xzy;\t\t\t\t\t\t\t\t// flip torus on its side\n   \n   vec3 tp2 = p;\n   \n    tp2 -= vec3(-3, .8+1.*y, -3.*(cos(t)*.5+.5));\t\t\t\t\t// translate\n    tp2.y *= squash;\n    tp2 = tp2.xyz;\t\t\t\t\t\t\t\t// flip torus on its side\n\n    tp.yz*=Rot(t);\n    tp2.xy*=Rot(t);\n    float scale = sdTorus(tp, vec2(1.5, .2))/squash;\n    float scale2 = sdTorus(tp2, vec2(.5*(sin(t)*.5+2.), .1))/squash;\n    \n    float torus= sdTorus(p-vec3(sin(iTime)*.5-1.,2.,0.5), vec2(.5,.2));\n    float torus2 =sdTorus(p+vec3(sin(iTime)*.8-2.,0.,2.), vec2(.2*(sin(t)*.5+2.),.5));\n\n  \n    float morph2 = mix(\n        length(p-vec3(4,1,2))-1., \n        torus2,\n        sin(t)*.5+.5\n    );\n    \n    float morph3= mix(\n       torus2,\n       torus,\n        sin(t)*.5+.5\n    );\n  \n   \n    float morph = mix(\n        length(p-vec3(4,1,2))-1., \n        dBox(p-vec3(4,1,2), vec3(1,1,1)), \n        sin(t)*.5+.5\n    );\n    \n    float subtract = max(\n        -dBox(p-vec3(1.+sin(t)*.5,1,0), vec3(1,.5,2)), \n        length(p-vec3(0,1,0))-.8\n    );\n    \n    float intersect = max(\n        dBox(p-vec3(sin(iTime)*.5-3.,1,0), vec3(1,.5,2)), \n        length(p-vec3(-4,1,0))-1.\n    );\n    \n    float blend = smin(\n        length(p-vec3(1.,(sin(t)*.5+.5),-2))-(sin(t)*.5+.5)*.8-.2,\n        dBox(p-vec3(1,1,-2), vec3(.5,1.,.2*(sin(t)*.5+.6))),\n        .2\n    );\n    \n    float blendBoxes = smin(\n        dBox(p-vec3(3,1.,-3), vec3(.5,.8*sin(t),.5*cos(t))),    \n        dBox(p-vec3(3,1,-3), vec3(.5,.2,1.)),.2);\n      **/\n      \n  \n    \n    /**\n      float subtract = max(\n        -sdCapsule(p-vec3(1.+sin(t)*.5,1,0), vec3(1,.2,2),vec3(1,.25,2.),2.), \n        length(p-vec3(0,1,0))-.5\n    );\n    \n    **/\n   /*** \n    float morph = mix(\n        length(p-vec3(4,1,2))-1., \n        dBox(p-vec3(4,1,2), vec3(1,1,1)), \n        sin(t)*.5+.5\n    );\n    \n    float subtract = max(\n        -dBox(p-vec3(1.+sin(t)*.5,1,0), vec3(1,.5,2)), \n        length(p-vec3(0,1,0))-.8\n    );\n    \n    float intersect = max(\n        dBox(p-vec3(sin(iTime)*.5-3.,1,0), vec3(1,.5,2)), \n        length(p-vec3(-4,1,0))-1.\n    );\n    \n    float blend = smin(\n        length(p-vec3(3,1,-3))-.75,\n        length(p-vec3(3.+.5,1.5,-3))-.5,\n        .2\n    );\n    \n    **/\n    \n    \n    float d;\n //d=pd;\n    d=min(pd,blendTorus);\n   //d= min(morph, pd);\n   //d = min(d, subVal);\n   //d = min(d, intersect);\n   //d = min(d, rotate);\n   // d = min(d, scale2);\n   // d=min(d,blend);\n   // d=min(d,blendBoxes);\n    d = min(d, blendTorus);\n    d = min(d, blendTorus2);\n    d = min(d, blendTorus3);\n    d = min(d, blendTorus4);\n    d *= min(blendTorus, blendTorus4);\n    d /= min(blendTorus2, blendTorus3);\n   // d = mix(blendTorus, blendTorus4,pd*.8);\n    //d = 100.*(sin(d*.2)*.5+.5);\n\n    //d = min(d, blendTo2rus);\n\n   // d = min(d, blend);\n    \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = abs( GetDist(p) );\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(3, 5, 4);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(p.y<.01 && d<length(lightPos-p)) dif *= .5;\n    \n    return dif;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 8, -8);\n    \n    ro.yz *= Rot(-m.y+.4);\n    ro.xz *= Rot(iTime*.2-m.x*6.2831);\n    \n    vec3 rd = R(uv, ro, vec3(0,0,0), .7);\n\n    float d = RayMarch(ro, rd);\n    float gradient = rd.y+.5;\n    col=texture(iChannel0, 2.*rd.xy*Rot(iTime*0.05)).rgb;\n\n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \n    \tfloat dif = GetLight(p);\n\n    \tcol = vec3(dif);\n\n    }\n     col = pow(col, vec3(.4545));\t// gamma correction\n //adding filter \n     col -= mix(vec3((cos(iTime)*.5+.5),.5,.2)*max((cos(iTime)*.5+.5),.8),vec3(.8,.2,.3),rd.y);\n\n    col+=vec3(.2*gradient);\n\n\n   \n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}