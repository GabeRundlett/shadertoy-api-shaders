{
    "Shader": {
        "info": {
            "date": "1485542133",
            "description": "Distributing points on a sphere, without the bunching at the poles you get from spherical coordinates.\n\nMinimal version of the technique: [url]https://www.shadertoy.com/view/llGXWc[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "llVXRd",
            "likes": 525,
            "name": "Geodesic tiling",
            "published": 3,
            "tags": [
                "sphere",
                "hexagon",
                "tile",
                "geodesic"
            ],
            "usePreview": 1,
            "username": "tdhooper",
            "viewed": 34232
        },
        "renderpass": [
            {
                "code": "#define MODEL_ROTATION vec2(.3, .25)\n#define CAMERA_ROTATION vec2(.5, .5)\n\n// 0: Defaults\n// 1: Model\n// 2: Camera\n#define MOUSE_CONTROL 1\n\n//#define DEBUG\n\n// 1, 2, or 3\n//#define LOOP 1\n\n\n// --------------------------------------------------------\n// HG_SDF\n// https://www.shadertoy.com/view/Xs3GRB\n// --------------------------------------------------------\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n    float t = dot(p, planeNormal)+offset;\n    if (t < 0.) {\n        p = p - (2.*t)*planeNormal;\n    }\n    return sign(t);\n}\n\nfloat smax(float a, float b, float r) {\n    float m = max(a, b);\n    if ((-a < r) && (-b < r)) {\n        return max(m, -(r - sqrt((r+a)*(r+a) + (r+b)*(r+b))));\n    } else {\n        return m;\n    }\n}\n\n\n// --------------------------------------------------------\n// Icosahedron domain mirroring\n// Adapted from knighty https://www.shadertoy.com/view/MsKGzw\n// --------------------------------------------------------\n\n#define PI 3.14159265359\n\nvec3 facePlane;\nvec3 uPlane;\nvec3 vPlane;\n\nint Type=5;\nvec3 nc;\nvec3 pab;\nvec3 pbc;\nvec3 pca;\n\nvoid initIcosahedron() {//setup folding planes and vertex\n    float cospin=cos(PI/float(Type)), scospin=sqrt(0.75-cospin*cospin);\n    nc=vec3(-0.5,-cospin,scospin);//3rd folding plane. The two others are xz and yz planes\n    pbc=vec3(scospin,0.,0.5);//No normalization in order to have 'barycentric' coordinates work evenly\n    pca=vec3(0.,scospin,cospin);\n    pbc=normalize(pbc); pca=normalize(pca);//for slightly better DE. In reality it's not necesary to apply normalization :)\n\tpab=vec3(0,0,1);\n    \n    facePlane = pca;\n    uPlane = cross(vec3(1,0,0), facePlane);\n    vPlane = vec3(1,0,0);\n}\n\nvoid pModIcosahedron(inout vec3 p) {\n    p = abs(p);\n    pReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n    pReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n    pReflect(p, nc, 0.);\n}\n\n\n// --------------------------------------------------------\n// Triangle tiling\n// Adapted from mattz https://www.shadertoy.com/view/4d2GzV\n// --------------------------------------------------------\n\nconst float sqrt3 = 1.7320508075688772;\nconst float i3 = 0.5773502691896258;\n\nconst mat2 cart2hex = mat2(1, 0, i3, 2. * i3);\nconst mat2 hex2cart = mat2(1, 0, -.5, .5 * sqrt3);\n\n#define PHI (1.618033988749895)\n#define TAU 6.283185307179586\n\nstruct TriPoints {\n\tvec2 a;\n    vec2 b;\n    vec2 c;\n    vec2 center;\n    vec2 ab;\n    vec2 bc;\n    vec2 ca;\n};\n\nTriPoints closestTriPoints(vec2 p) {    \n    vec2 pTri = cart2hex * p;\n    vec2 pi = floor(pTri);\n    vec2 pf = fract(pTri);\n    \n    float split1 = step(pf.y, pf.x);\n    float split2 = step(pf.x, pf.y);\n    \n    vec2 a = vec2(split1, 1);\n    vec2 b = vec2(1, split2);\n    vec2 c = vec2(0, 0);\n\n    a += pi;\n    b += pi;\n    c += pi;\n\n    a = hex2cart * a;\n    b = hex2cart * b;\n    c = hex2cart * c;\n    \n    vec2 center = (a + b + c) / 3.;\n    \n\tvec2 ab = (a + b) / 2.;\n    vec2 bc = (b + c) / 2.;\n    vec2 ca = (c + a) / 2.;\n\n    return TriPoints(a, b, c, center, ab, bc, ca);\n}\n\n\n// --------------------------------------------------------\n// Geodesic tiling\n// --------------------------------------------------------\n\nstruct TriPoints3D {\n\tvec3 a;\n    vec3 b;\n    vec3 c;\n\tvec3 center;\n    vec3 ab;\n    vec3 bc;\n    vec3 ca;\n};\n\nvec3 intersection(vec3 n, vec3 planeNormal, float planeOffset) {\n    float denominator = dot(planeNormal, n);\n    float t = (dot(vec3(0), planeNormal ) + planeOffset) / -denominator;\n    return n * t;\n}\n\n//// Edge length of an icosahedron with an inscribed sphere of radius of 1\n//float edgeLength = 1. / ((sqrt(3.) / 12.) * (3. + sqrt(5.)));\n//// Inner radius of the icosahedron's face\n//float faceRadius = (1./6.) * sqrt(3.) * edgeLength;\nfloat faceRadius = 0.3819660112501051;\n\n// 2D coordinates on the icosahedron face\nvec2 icosahedronFaceCoordinates(vec3 p) {\n    vec3 pn = normalize(p);\n    vec3 i = intersection(pn, facePlane, -1.);\n    return vec2(dot(i, uPlane), dot(i, vPlane));\n}\n\n// Project 2D icosahedron face coordinates onto a sphere\nvec3 faceToSphere(vec2 facePoint) {\n\treturn normalize(facePlane + (uPlane * facePoint.x) + (vPlane * facePoint.y));\n}\n\nTriPoints3D geodesicTriPoints(vec3 p, float subdivisions) {\n    // Get 2D cartesian coordiantes on that face\n    vec2 uv = icosahedronFaceCoordinates(p);\n    \n    // Get points on the nearest triangle tile\n\tfloat uvScale = subdivisions / faceRadius / 2.;\n    TriPoints points = closestTriPoints(uv * uvScale);\n    \n    // Project 2D triangle coordinates onto a sphere \n    vec3 a = faceToSphere(points.a / uvScale);\n    vec3 b = faceToSphere(points.b / uvScale);\n    vec3 c = faceToSphere(points.c / uvScale);\n    vec3 center = faceToSphere(points.center / uvScale);\n    vec3 ab = faceToSphere(points.ab / uvScale);\n    vec3 bc = faceToSphere(points.bc / uvScale);\n    vec3 ca = faceToSphere(points.ca / uvScale);\n    \n    return TriPoints3D(a, b, c, center, ab, bc, ca);\n}\n\n\n// --------------------------------------------------------\n// Spectrum colour palette\n// IQ https://www.shadertoy.com/view/ll2GD3\n// --------------------------------------------------------\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n\n// --------------------------------------------------------\n// Model/Camera Rotation\n// --------------------------------------------------------\n\nmat3 sphericalMatrix(float theta, float phi) {\n    float cx = cos(theta);\n    float cy = cos(phi);\n    float sx = sin(theta);\n    float sy = sin(phi);\n    return mat3(\n        cy, -sy * -sx, -sy * cx,\n        0, cx, sx,\n        sy, cy * -sx, cy * cx\n    );\n}\n\nmat3 mouseRotation(bool enable, vec2 xy) {\n    if (enable) {\n        vec2 mouse = iMouse.xy / iResolution.xy;\n\n        if (mouse.x != 0. && mouse.y != 0.) {\n            xy.x = mouse.x;\n            xy.y = mouse.y;\n        }\n    }\n    float rx, ry;\n    \n    rx = (xy.y + .5) * PI;\n    ry = (-xy.x) * 2. * PI;\n    \n    return sphericalMatrix(rx, ry);\n}\n\nmat3 modelRotation() {\n    mat3 m = mouseRotation(MOUSE_CONTROL==1, MODEL_ROTATION);\n    return m;\n}\n\nmat3 cameraRotation() {\n    mat3 m = mouseRotation(MOUSE_CONTROL==2, CAMERA_ROTATION);\n    return m;\n}\n\n\n// --------------------------------------------------------\n// Animation \n// --------------------------------------------------------\n\nconst float SCENE_DURATION = 6.;\nconst float CROSSFADE_DURATION = 2.;\n\nfloat time;\n\nstruct HexSpec {\n    float roundTop;\n    float roundCorner;\n\tfloat height;\n    float thickness;\n    float gap;    \n};\n    \nHexSpec newHexSpec(float subdivisions) {\n\treturn HexSpec(\n        .05 / subdivisions,\n        .1 / subdivisions,\n        2.,\n        2.,\n        .005\n    );\n}\n    \n// Animation 1\n    \nfloat animSubdivisions1() {\n\treturn mix(2.4, 3.4, cos(time * PI) * .5 + .5);\n}\n\nHexSpec animHex1(vec3 hexCenter, float subdivisions) {\n    HexSpec spec = newHexSpec(subdivisions);\n    \n    float offset = time * 3. * PI;\n    offset -= subdivisions;\n    float blend = dot(hexCenter, pca);\n    blend = cos(blend * 30. + offset) * .5 + .5;\n    spec.height = mix(1.75, 2., blend);\n\n    spec.thickness = spec.height;\n\n    return spec;\n}\n\n// Animation 2\n\nfloat animSubdivisions2() {\n    return mix(1., 2.3, sin(time * PI/2.) * .5 + .5);\n}\n\nHexSpec animHex2(vec3 hexCenter, float subdivisions) {\n    HexSpec spec = newHexSpec(subdivisions);\n    \n    float blend = hexCenter.y;\n    spec.height = mix(1.6, 2., sin(blend * 10. + time * PI) * .5 + .5);\n    \n    spec.roundTop = .02 / subdivisions;\n    spec.roundCorner = .09 / subdivisions;\n    spec.thickness = spec.roundTop * 4.;\n    spec.gap = .01;\n\n    return spec;\n}\n\n// Animation 3\n\nfloat animSubdivisions3() {\n\treturn 5.;\n}\n\nHexSpec animHex3(vec3 hexCenter, float subdivisions) {\n    HexSpec spec = newHexSpec(subdivisions);\n    \n    float blend = acos(dot(hexCenter, pab)) * 10.;\n    blend = cos(blend + time * PI) * .5 + .5;\n    spec.gap = mix(.01, .4, blend) / subdivisions;\n\n    spec.thickness = spec.roundTop * 2.;\n\n\treturn spec;\n}\n\n// Transition between animations\n\nfloat sineInOut(float t) {\n  return -0.5 * (cos(PI * t) - 1.0);\n}\n\nfloat transitionValues(float a, float b, float c) {\n    #ifdef LOOP\n        #if LOOP == 1\n            return a;\n        #endif\n        #if LOOP == 2\n            return b;\n        #endif\n        #if LOOP == 3\n            return c;\n        #endif\n    #endif\n    float t = time / SCENE_DURATION;\n    float scene = floor(mod(t, 3.));\n    float blend = fract(t);\n    float delay = (SCENE_DURATION - CROSSFADE_DURATION) / SCENE_DURATION;\n    blend = max(blend - delay, 0.) / (1. - delay);\n    blend = sineInOut(blend);\n    float ab = mix(a, b, blend);\n    float bc = mix(b, c, blend);\n    float cd = mix(c, a, blend);\n    float result = mix(ab, bc, min(scene, 1.));\n    result = mix(result, cd, max(scene - 1., 0.));\n    return result;\n}\n \nHexSpec transitionHexSpecs(HexSpec a, HexSpec b, HexSpec c) {\n    float roundTop = transitionValues(a.roundTop, b.roundTop, c.roundTop);\n    float roundCorner = transitionValues(a.roundCorner, b.roundCorner, c.roundCorner);\n\tfloat height = transitionValues(a.height, b.height, c.height);\n    float thickness = transitionValues(a.thickness, b.thickness, c.thickness);\n    float gap = transitionValues(a.gap, b.gap, c.gap);\n\treturn HexSpec(roundTop, roundCorner, height, thickness, gap);\n}\n\n\n// --------------------------------------------------------\n// Modelling \n// --------------------------------------------------------\n\nconst vec3 FACE_COLOR = vec3(.9,.9,1.);\nconst vec3 BACK_COLOR = vec3(.1,.1,.15);\nconst vec3 BACKGROUND_COLOR = vec3(.0, .005, .03);\n\nstruct Model {\n    float dist;\n    vec3 albedo;\n    float glow;\n};\n\nModel hexModel(\n    vec3 p,\n    vec3 hexCenter,\n    vec3 edgeA,\n    vec3 edgeB,\n    HexSpec spec\n) {\n    float d;\n\n    float edgeADist = dot(p, edgeA) + spec.gap;\n    float edgeBDist = dot(p, edgeB) - spec.gap;\n    float edgeDist = smax(edgeADist, -edgeBDist, spec.roundCorner);\n\n    float outerDist = length(p) - spec.height;\n    d = smax(edgeDist, outerDist, spec.roundTop);\n\n    float innerDist = length(p) - spec.height + spec.thickness;\n    d = smax(d, -innerDist, spec.roundTop);\n    \n    vec3 color;\n\n    float faceBlend = (spec.height - length(p)) / spec.thickness;\n    faceBlend = clamp(faceBlend, 0., 1.);\n    color = mix(FACE_COLOR, BACK_COLOR, step(.5, faceBlend));\n    \n    vec3 edgeColor = spectrum(dot(hexCenter, pca) * 5. + length(p) + .8);    \n\tfloat edgeBlend = smoothstep(-.04, -.005, edgeDist);\n    color = mix(color, edgeColor, edgeBlend); \n\n    return Model(d, color, edgeBlend);\n}\n\n// checks to see which intersection is closer\nModel opU( Model m1, Model m2 ){\n    if (m1.dist < m2.dist) {\n        return m1;\n    } else {\n        return m2;\n    }\n}\n\nModel geodesicModel(vec3 p) {\n\n    pModIcosahedron(p);\n    \n    float subdivisions = transitionValues(\n        animSubdivisions1(),\n        animSubdivisions2(),\n        animSubdivisions3()\n   \t);\n\tTriPoints3D points = geodesicTriPoints(p, subdivisions);\n        \n\tvec3 edgeAB = normalize(cross(points.center, points.ab));\n\tvec3 edgeBC = normalize(cross(points.center, points.bc));\n    vec3 edgeCA = normalize(cross(points.center, points.ca));\n    \n    Model model, part;\n    HexSpec spec;\n\n\tspec = transitionHexSpecs(\n        animHex1(points.b, subdivisions),\n        animHex2(points.b, subdivisions),\n        animHex3(points.b, subdivisions)\n    );\n    part = hexModel(p, points.b, edgeAB, edgeBC, spec);\n    model = part;\n\n\tspec = transitionHexSpecs(\n        animHex1(points.c, subdivisions),\n        animHex2(points.c, subdivisions),\n        animHex3(points.c, subdivisions)\n    );\n    part = hexModel(p, points.c, edgeBC, edgeCA, spec);\n    model = opU(model, part);\n    \n\tspec = transitionHexSpecs(\n        animHex1(points.a, subdivisions),\n        animHex2(points.a, subdivisions),\n        animHex3(points.a, subdivisions)\n    );\n    part = hexModel(p, points.a, edgeCA, edgeAB, spec);\n    model = opU(model, part);\n    \n\treturn model;\n}\n\nModel map( vec3 p ){\n    mat3 m = modelRotation();\n    p *= m;  \n    #ifndef LOOP\n    \tpR(p.xz, time * PI/16.);\n    #endif\n    Model model = geodesicModel(p);\n    return model;\n}\n\n// --------------------------------------------------------\n// LIGHTING\n// Adapted from IQ https://www.shadertoy.com/view/Xds3zN\n// --------------------------------------------------------\n\nvec3 doLighting(Model model, vec3 pos, vec3 nor, vec3 ref, vec3 rd) {\n    vec3 lightPos = normalize(vec3(.5,.5,-1.));\n    vec3 backLightPos = normalize(vec3(-.5,-.3,1));\n    vec3 ambientPos = vec3(0,1,0);\n    \n    vec3  lig = lightPos;\n    float amb = clamp((dot(nor, ambientPos) + 1.) / 2., 0., 1.);\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float bac = pow(clamp(dot(nor, backLightPos), 0., 1.), 1.5);\n    float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n    \n    vec3 lin = vec3(0.0);\n    lin += 1.20 * dif * vec3(.9);\n    lin += 0.80 * amb * vec3(.5, .7, .8);\n    lin += 0.30 * bac * vec3(.25);\n    lin += 0.20 * fre * vec3(1);\n    \n    vec3 albedo = model.albedo;\n    vec3 col = mix(albedo * lin, albedo, model.glow);    \n\n    return col;\n}   \n\n\n// --------------------------------------------------------\n// Ray Marching\n// Adapted from cabbibo https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\nconst float MAX_TRACE_DISTANCE = 8.; // max trace distance\nconst float INTERSECTION_PRECISION = .001; // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\nconst float FUDGE_FACTOR = .9; // Default is 1, reduce to fix overshoots\n\nstruct CastRay {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n    float len;\n};\n\nstruct Hit {\n    Ray ray;\n    Model model;\n    vec3 pos;\n    bool isBackground;\n    vec3 normal;\n    vec3 color;\n};\n\nvec3 calcNormal( in vec3 pos ){\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).dist - map(pos-eps.xyy).dist,\n        map(pos+eps.yxy).dist - map(pos-eps.yxy).dist,\n        map(pos+eps.yyx).dist - map(pos-eps.yyx).dist );\n    return normalize(nor);\n}\n    \nHit raymarch(CastRay castRay){\n\n    float currentDist = INTERSECTION_PRECISION * 2.0;\n    Model model;\n    \n    Ray ray = Ray(castRay.origin, castRay.direction, 0.);\n\n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        if (currentDist < INTERSECTION_PRECISION || ray.len > MAX_TRACE_DISTANCE) {\n            break;\n        }\n        model = map(ray.origin + ray.direction * ray.len);\n        currentDist = model.dist;\n        ray.len += currentDist * FUDGE_FACTOR;\n    }\n    \n    bool isBackground = false;\n    vec3 pos = vec3(0);\n    vec3 normal = vec3(0);\n    vec3 color = vec3(0);\n    \n    if (ray.len > MAX_TRACE_DISTANCE) {\n        isBackground = true;\n    } else {\n        pos = ray.origin + ray.direction * ray.len;\n        normal = calcNormal(pos);\n    }\n\n    return Hit(ray, model, pos, isBackground, normal, color);\n}\n\n\n// --------------------------------------------------------\n// Rendering\n// --------------------------------------------------------\n\nvoid shadeSurface(inout Hit hit){\n    \n    vec3 color = BACKGROUND_COLOR;\n    \n    if (hit.isBackground) {\n        hit.color = color;\n        return;\n    }\n\n    vec3 ref = reflect(hit.ray.direction, hit.normal);\n\n    #ifdef DEBUG\n        color = hit.normal * 0.5 + 0.5;\n    #else \n        color = doLighting(\n            hit.model,\n            hit.pos,\n            hit.normal,\n            ref,\n            hit.ray.direction\n        );\n    #endif\n\n    hit.color = color;\n}\n\nvec3 render(Hit hit){\n    shadeSurface(hit);\n\treturn hit.color;\n}\n\n\n// --------------------------------------------------------\n// Camera\n// https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera(out vec3 camPos, out vec3 camTar, out float camRoll, in float time, in vec2 mouse) {\n    float dist = 5.5;\n    camRoll = 0.;\n    camTar = vec3(0,0,0);\n    camPos = vec3(0,0,-dist);\n    camPos *= cameraRotation();\n    camPos += camTar;\n}\n\n\n// --------------------------------------------------------\n// Gamma\n// https://www.shadertoy.com/view/Xds3zN\n// --------------------------------------------------------\n\nconst float GAMMA = 2.2;\n\nvec3 gamma(vec3 color, float g) {\n    return pow(color, vec3(g));\n}\n\nvec3 linearToScreen(vec3 linearRGB) {\n    return gamma(linearRGB, 1.0 / GAMMA);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime;\n\n    #ifdef LOOP\n        #if LOOP == 1\n            time = mod(time, 2.);   \n        #endif\n        #if LOOP == 2\n            time = mod(time, 4.);   \n        #endif\n        #if LOOP == 3\n            time = mod(time, 2.);\n    \t#endif\n    #endif\n    \n    initIcosahedron();\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    vec3 camPos = vec3( 0., 0., 2.);\n    vec3 camTar = vec3( 0. , 0. , 0. );\n    float camRoll = 0.;\n    \n    // camera movement\n    doCamera(camPos, camTar, camRoll, iTime, m);\n    \n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( camPos, camTar, camRoll );  // 0.0 is the camera roll\n    \n    // create view ray\n    vec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    Hit hit = raymarch(CastRay(camPos, rd));\n\n    vec3 color = render(hit);\n    \n    #ifndef DEBUG\n        color = linearToScreen(color);\n    #endif\n\n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}