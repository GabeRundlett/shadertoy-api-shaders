{
    "Shader": {
        "info": {
            "date": "1723028346",
            "description": " source https://glslsandbox.com/e#77378.2 https://glslsandbox.com/e#76551.0 https://glslsandbox.com/e#76773.1",
            "flags": 0,
            "hasliked": 0,
            "id": "lf2yDK",
            "likes": 4,
            "name": "cosmic space ",
            "published": 3,
            "tags": [
                "space",
                "cosmos",
                "universe"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 141
        },
        "renderpass": [
            {
                "code": "#define time iTime\n#define resolution iResolution.xy\n\nfloat aastep(float threshold, float value) {\n  #ifdef GL_OES_standard_derivatives\n    float afwidth = length(vec2(dFdx(value), dFdy(value))) * 0.70710678118654757;\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n  #else\n    return step(threshold, value);\n  #endif  \n}\n\n// Cellular noise (\"Worley noise\") in 2D in GLSL.\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details.\n\n// Permutation polynomial: (34x^2 + x) mod 289\nvec3 permute(vec3 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// Standard 3x3 search window for good F1 and F2 values\nvec2 cellular(vec2 P, float seed) {\n#define K 0.142857142857 // 1/7\n#define Ko 0.428571428571 // 3/7\n#define jitter 1.0 // Less gives more regular pattern\n\tvec2 Pi = mod(floor(P), 289.0);\n \tvec2 Pf = fract(P);\n\tvec3 oi = vec3(-1.0, 0.0, 1.0);\n\tvec3 of = vec3(-0.5, 0.5, 1.5);\n\tvec3 px = permute(Pi.x + oi);\n\tvec3 p = permute(px.x + Pi.y + oi); // p11, p12, p13\n\tvec3 ox = fract(p*K) - Ko;\n\tvec3 oy = mod(floor(p*K),7.0)*K - Ko;\n\tvec3 dx = Pf.x + 0.5 + jitter*ox;\n\tvec3 dy = Pf.y - of + jitter*oy;\n\tvec3 d1 = dx * dx + dy * dy; // d11, d12 and d13, squared\n\tp = permute(px.y + Pi.y + oi); // p21, p22, p23\n\tox = fract(p*K) - Ko;\n\toy = mod(floor(p*K),7.0)*K - Ko;\n\tdx = Pf.x - 0.5 + jitter*ox;\n\tdy = Pf.y - of + jitter*oy;\n\tvec3 d2 = dx * dx + dy * dy; // d21, d22 and d23, squared\n\tp = permute(px.z + Pi.y + oi); // p31, p32, p33\n\tox = fract(p*K) - Ko;\n\toy = mod(floor(p*K),7.0)*K - Ko;\n\tdx = Pf.x - 1.5 + jitter*ox;\n\tdy = Pf.y - of + jitter*oy;\n\tvec3 d3 = dx * dx + dy * dy; // d31, d32 and d33, squared\n\t// Sort out the two smallest distances (F1, F2)\n\tvec3 d1a = min(d1, d2);\n\td2 = max(d1, d2); // Swap to keep candidates for F2\n\td2 = min(d2, d3); // neither F1 nor F2 are now in d3\n\td1 = min(d1a, d2); // F1 is now in d1\n\td2 = max(d1a, d2); // Swap to keep candidates for F2\n\td1.xy = (d1.x < d1.y) ? d1.xy : d1.yx; // Swap if smaller\n\td1.xz = (d1.x < d1.z) ? d1.xz : d1.zx; // F1 is in d1.x\n\td1.yz = min(d1.yz, d2.yz); // F2 is now not in d2.yz\n\td1.y = min(d1.y, d1.z); // nor in  d1.z\n\td1.y = min(d1.y, d2.x); // F2 is in d1.y, we're done.\n\treturn sqrt(d1.xy);\n}\n\nfloat facets(vec2 F)\n{\n\treturn 0.1 + (F.y - F.x);\n}\n\nfloat blobs(vec2 F)\n{\n\treturn 1.0 - F.x * F.x;\n}\n\nfloat rings(vec2 F)\n{\n\treturn 1.0 - aastep(0.45, F.x) + aastep(0.55, F.x);\n}\n\nvec3 mod289(vec3 x)\n{\n        return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x)\n{\n        return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nfloat snoise(vec2 v)\n{\n        const vec4 C = vec4(0.211324865405187,  // (3.0 - sqrt(3.0)) / 6.0\n                            0.366025403784439,  // 0.5 * (sqrt(3.0) - 1.0)\n                            -0.577350269189626,  // -1.0 + 2.0 * C.x\n                            0.024390243902439);  // 1.0 / 41.0\n\n        // First corner\n        vec2 i = floor(v + dot(v, C.yy));\n        vec2 x0 = v - i + dot(i, C.xx);\n\n        // Other corners\n        vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n        vec4 x12 = x0.xyxy + C.xxzz;\n        x12.xy -= i1;\n\n        // Permutations\n        i = mod289(i);  // Avoid truncation effects in permutations\n        vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));\n        vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);\n        m = m * m;\n        m = m * m;\n\n        // Gradients\n        vec3 x = 2.0 * fract(p * C.www) - 1.0;\n        vec3 h = abs(x) - 0.5;\n        vec3 a0 = x - floor(x + 0.5);\n\n        // Normalize gradients implicitly by scaling m\n        m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);\n\n        // Compute final noise value at P\n        vec3 g;\n        g.x = a0.x * x0.x + h.x * x0.y;\n        g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n        return 130.0 * dot(m, g);\n}\n\nfloat fbm(vec2 st, float l, float r)\n{\n\n\tconst int octaves = 8;\n\t\n\tfloat sum = 0.0;\n\tfloat f = 0.5;\n\tfloat s = 1.0;\n\tfor (int i=0; i < octaves; ++i)\n\t{\n\t\tsum = sum + s * snoise(f * st);\n\t\ts = s * r;\n\t\tf = f * l;\n\t}\n\treturn sum;\n}\n\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K3 = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K3.wz), vec4(c.gb, K3.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K3 = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K3.xyz) * 6.0 - K3.www);\n    return c.z * mix(K3.xxx, clamp(p - K3.xxx, 0.0, 1.0), c.y);\n}\n\nmat3 rotX(float a) {\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat3(\n\t\t1, 0, 0,\n\t\t0, c, -s,\n\t\t0, s, c\n\t);\n}\nmat3 rotY(float a) {\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat3(\n\t\tc, 0, -s,\n\t\t0, 1, 0,\n\t\ts, 0, c\n\t);\n}\n\nfloat random(vec2 pos) {\n\treturn fract(sin(dot(pos.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat noise(vec2 pos) {\n\tvec2 i = floor(pos);\n\tvec2 f = fract(pos);\n\tfloat a = random(i + vec2(0.0, 0.0));\n\tfloat b = random(i + vec2(1.0, 0.0));\n\tfloat c = random(i + vec2(0.0, 1.0));\n\tfloat d = random(i + vec2(1.0, 1.0));\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n#define NUM_OCTAVES 16\nfloat fbm(vec2 pos) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100.0);\n\tmat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\n\tfor (int i=0; i<NUM_OCTAVES; i++) {\n\t\tv += a * noise(pos);\n\t\tpos = rot * pos * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nfloat hash( ivec3 p )    // this hash is not production ready, please\n{                        // replace this by something better\n\n    // 3D -> 1D\n    int n = p.x*3 + p.y*113 + p.z*311;\n\n    // 1D hash by Hugo Elias\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return float( n & ivec3(0x0fffffff))/float(0x0fffffff);\n}\n\nfloat noise( in vec3 x )\n{\n    ivec3 i = ivec3(floor(x));\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+ivec3(0,0,0)), \n                        hash(i+ivec3(1,0,0)),f.x),\n                   mix( hash(i+ivec3(0,1,0)), \n                        hash(i+ivec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+ivec3(0,0,1)), \n                        hash(i+ivec3(1,0,1)),f.x),\n                   mix( hash(i+ivec3(0,1,1)), \n                        hash(i+ivec3(1,1,1)),f.x),f.y),f.z);\n}\n\n#define R iResolution.xy\n// https://www.shadertoy.com/view/XsGfWV\nvec3 aces_tonemap(vec3 color){\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n}\n\nvec2 r(vec2 p, float a) { return p*mat2(cos(a), sin(a), -sin(a), cos(a)); }\nvec3 starfield(vec2 st)\n{\nst.x+=0.11*cos(iTime);\nst.y+=0.11*sin(iTime);\n\tvec2 F = cellular(st, time);\n\t\n\tfloat value;\n\tvalue = 1.0 - F.x;\n\t\n\tvalue = pow(value, 60.0 + snoise(st * 10.0) * 10.0);\n\tfloat alpha = F.y - 0.5;\n\treturn mix(vec3(1, 0.6, 0.6), vec3(0.6, 0.6, 1), alpha) * value;\n}\n\nvec3 starfield_fractal(vec2 st, float l, float r)\n{\n\tconst int octaves = 4;\n\t\n\tvec3 sum = vec3(0, 0, 0);\n\tfloat f = 0.5;\n\tfloat s = 1.0;\n\tfor (int i=0; i < octaves; ++i)\n\t{\n\t\tsum = sum + s * starfield(f * st);\n\t\ts = s * r;\n\t\tf = f * l;\n\t}\n\treturn sum;\n}\n#define iTime time\n\n#define time iTime\n#define resolution iResolution.xy\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 st = ((gl_FragCoord.xy / resolution.xy) * 4.0);\n\t\n    vec2 p = (gl_FragCoord.xy * 3.0 - resolution.xy) / min(resolution.x, resolution.y);\n    vec4 O= fragColor;\n    vec2 I= fragCoord;\n vec3 p2=iResolution,d = -.5*vec3(I+I-p2.xy,p2)/p2.x,c = d-d, i=c;\n    for(int x=0;x<25;++x) {\n        if (i.x>=1.) break;\n        p2 = c,\n        p2.z -= iTime+(i.x+=.01),\n        p2.xy *= mat2(sin((p2.z*=.1)+vec4(0,11,33,0)));\n        c += length(sin(p2.yx)+cos(p2.xz+iTime*0.1))*d;\n    }\n    O = vec4(1,0,5.5,9.)/length(c*3.1);\n    \n\tfloat t = 0.0, d3;\nvec2 uv = I/R;\n    vec2 p5 = (2.*I - R) / R.y * 1.5;\n    p5*=3.2;\n    float fp = pow(.5/length(pow(abs(r(p5,.43))\n        *vec2(2,1),vec2(.5))),4.5);\n       \n    p5 *= mat2(.0,-.5,-.4,0.2);    \n    vec3 pos = normalize(vec3(r(p5,-.4/length(p5)),.25));\n    pos.z -= iTime*0.1;\n    \n    vec3 q3 = 6.*pos;\n    float f3  = 0.5000*noise( q3 ); q3 = q3*2.;\n          f3 += 0.2500*noise( q3 ); q3 = q3*2.;\n          f3 += 0.1250*noise( q3 ); q3 = q3*2.;\n          f3 += 0.0625*noise( q3 );\n    \n    vec2 n3 = 0.5*uv*(1.-uv)*3.; float v = pow(n3.x*n3.y,.8);\n    \n    float fr = .6/length(p5);\n    f3 = smoothstep(-.4,2.,f3*f3) * fr*fr + fp;\n    \n    O = vec4(aces_tonemap(\n        pow(f3*f3 * vec3(2., .05, 1.5)*v,vec3(.45))*2.5),0);\n\tfloat time2 = 1.0 * iTime / 5.0;\n\n\tvec2 q = vec2(0.0);\n\tq.x = fbm(p + 0.00 * time2);\n\tq.y = fbm(p + vec2(1.0));\n\tvec2 r = vec2(0.0);\n\tr.x = fbm(p + 1.0 * q + vec2(3, 9.2) + 0.15 * time2);\n\tr.y = fbm(p + 1.0 * q + vec2(8.3, 2.8) + 0.126 * time2);\n\tfloat f = fbm(p + r);\n\tvec3 color = mix(\n\t\tvec3(-1.5, 0.23, 0.25),\n\t\tvec3(0.50, 0.07, 0.075),\n\t\tclamp((f * f) * 7.0, 1.0, 21.0)\n\t);\n\n\tcolor = mix(\n\t\tcolor,\n        vec3(1.1, 0.25, 0.9),\n\t\tclamp(length(q), 0.0, 5.0)\n\t);\n\n\n\tcolor = mix(\n\t\tcolor,\n\t\tvec3(0.7, 0.6, 1.9),\n\t\tclamp(length(r.x), 0.0, 0.9)\n\t);\n\t\n\tcolor = mix(\n\t\tcolor,\n\t\tvec3(1.6, 1.9, 0.5),\n\t\tclamp(length(r.y), 0.0, 0.5)\n\t);\n\t\n\n\tcolor = (f *f * f + 0.9 * f * f + 0.8 * f) * color * 0.5;\n\tvec3 hsv = rgb2hsv(color);\n\thsv.g = clamp(hsv.g * 1.5, 0.0, 1.0);\n\thsv.b = clamp(hsv.b * 1.3, 0.0, 1.0);\n\t\n\tcolor = hsv2rgb(hsv);\n\tvec3 star = starfield_fractal(st * 40.0, 1.4, 0.9);\n\t\n\tfloat n = fbm(st * 1.0, 2.0, 0.7);\n\tvec3 nebula = vec3(n) * 0.14;\n\tstar = star * (n * 0.7 + 1.2);\n\t\n        float n2 = fbm((st + vec2(132.0, 112.0)) * 1.5, 2.3, 0.6);\n\tvec3 nebula2 = mix(vec3(1, 0, 0), vec3(0.5, 1, 0.5), n2) * (n2 - 0.3) * 0.14;\n\t\n\tfragColor = vec4(nebula*color + clamp(star, 0.0, 1.0) + nebula2*color, 1.0)+O;\n    fragColor+= vec4(color*1., 5.0);\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}