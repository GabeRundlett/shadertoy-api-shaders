{
    "Shader": {
        "info": {
            "date": "1590167107",
            "description": "License CC0: Planet Shader\nI have been experimenting with space themed shaders",
            "flags": 0,
            "hasliked": 0,
            "id": "3d2fDw",
            "likes": 22,
            "name": "Planet Shader",
            "published": 3,
            "tags": [
                "raytracing",
                "space"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 812
        },
        "renderpass": [
            {
                "code": "// License CC0: Planet Shader\n//  I have been experimenting with space themed shaders\n#define PI           3.141592654\n#define TAU          (2.0*PI)\n\n#define TIME         (iTime)\n#define RESOLUTION   iResolution\n#define PERIOD       30.0\n#define PERIODS      4.0\n#define FADETIME     2.0\n#define TPERIOD      (mod(TIME, PERIOD))\n#define NPERIOD      (int(mod(TIME/PERIOD, PERIODS)))\n\nconst vec3  sunDirection = normalize(vec3(0.0, 0.1, -10.0));\nconst vec3  sunColor1    = vec3(1.0, 0.8, 0.8);\nconst vec3  sunColor2    = vec3(1.0, 0.8, 0.9);\nconst vec3  planetPos    = vec3(0.0);\nconst float planetRadii  = 10.0;\n\nvec3 tanh3(vec3 c) {\n  return vec3(tanh(c.x), tanh(c.y), tanh(c.z));\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nvec2 raySphere(vec3 ro, vec3 rd, vec3 center, float radius) {\n  vec3 m = ro - center.xyz;\n  float b = dot(m, rd);\n  float c = dot(m, m) - radius*radius;\n  if(c > 0.0 && b > 0.0) return vec2(-1.0, -1.0);\n  float discr = b * b - c;\n  if(discr < 0.0) return vec2(-1.0);\n  float normalMultiplier = 1.0;\n  float s = sqrt(discr);\n  float t0 = -b - s;\n  float t1 = -b + s;;\n  return vec2(t0, t1);\n}\n\nvec3 scaleCol(vec3 c, float s, float r) {\n  float o = sqrt(s/r);\n  float i = s/o;\n  return tanh3(c*i)*o;\n}\n\nvec3 skyColor(vec3 rd) {\n  float diff = max(dot(rd, sunDirection), 0.0);\n  vec3 col = vec3(0.0);\n  col += scaleCol(pow(diff, 4.0*200.0)*sunColor1, 8.0, 0.25);\n  col += scaleCol(pow(diff, 4.0*50.0)*sunColor2, 1.0, 0.25);\n  return col;\n}\n\nfloat psin(float a) {\n  return 0.5 + 0.5*sin(a);\n}\n\nfloat pcos(float a) {\n  return 0.5 + 0.5*cos(a);\n}\n\nfloat spow(float v, float p) {\n  return sign(v)*pow(abs(v), p);\n}\n\nvec4 rings(vec2 p) {\n  float pl = length(p);\n  float pdf = pl-22.0;\n  pdf = abs(pdf) - 3.0;\n  pdf = abs(pdf) - 2.0;\n  pdf = abs(pdf) - 1.0;\n  vec4 pcol = vec4(1.0);\n  pcol.xyz = mix(vec3(1.0, 0.8, 0.75), vec3(1.0, 1.0, 1.0), 0.5 - 0.5*cos(15.0*pl))*sunColor1;\n  pcol.xyz = pow(pcol.xyz, vec3(0.75));\n  pcol.w = psin(20.0*pl)*psin(14.0*pl)*psin(21.0*pl);\n  pcol.w *= 0.5*step(pdf, 0.0);\n  return pcol;\n}\n\nvec4 planet(vec3 ro, vec3 rd, vec3 skyCol, inout float pd) {\n  vec4 col = vec4(0.0);\n\n  vec2 si = raySphere(ro, rd, planetPos, planetRadii);\n  vec3 sp = ro + rd*si.x;\n  vec3 sn = normalize(sp - planetPos);\n  vec3 sr = reflect(rd, sn);\n  vec3 sref = skyColor(sr);\n  float sfres = pow(1.0-abs(dot(rd, sn)), 15.0);\n  float sdiff = max(dot(sunDirection, sn), 0.0);\n  float sf = (si.y - si.x)/(2.0*planetRadii);\n  float sl = (1.0-smoothstep(0.2, 0.7, sf));\n  vec3 sbeer = exp(-6.0*vec3(0.3, 0.25, 0.15)*sf)*sl;\n  float srayl = pow(1.0 - abs(dot(rd, sn)), 5.0);\n\n  float slo = atan(sp.z, sp.x);\n  float slat = PI*sp.y/planetRadii;\n  vec3 scol = vec3(0.8);\n\n  scol = mix(scol, vec3(0.7, 0.7, 0.8), pow(pcos(20.0*slat), 5.0));\n  scol = mix(scol, vec3(0.75, 0.7, 0.8), pow(pcos(14.0*slat), 20.0));\n  scol = mix(scol, vec3(0.2), pow(pcos(21.0*slat)*pcos(13.0*slat+1.0), 15.0));  \n  scol = tanh3(scol);\n  scol *= pow(sunColor1, vec3(0.66));  \n  scol += vec3(0.0, 0.0, srayl*0.5) ;\n\n  if (si.x < si.y) {\n    col.xyz = sfres*sref + pow(skyCol, vec3(0.85))*sbeer + scol*pow(sdiff, 0.75);\n    col.w = 1.0;\n    pd = si.x;\n  }\n\n  return col;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 skyCol = skyColor(rd);  \n  \n  vec4 col = vec4(skyCol, 1.0);\n  float cold = 10000.0;\n\n  vec4 pcol = planet(ro, rd, skyCol, cold);\n\n  col.xyz = mix(col.xyz, pcol.xyz, pcol.w);\n\n  float rsd = (0.0 - ro.y)/rd.y;\n  vec3 rsp = ro + rd*rsd;\n  vec4 rscol = rings(rsp.xz); \n  vec3 rsn = vec3(0.0, 1.0, 0.0);\n  \n  rscol.w = pow(rscol.w, 1.0*pow(abs(dot(rd, rsn)), 0.4));\n\n  vec2 psi = raySphere(rsp, sunDirection, planetPos, planetRadii);\n  rscol.xyz *= (1.0  - smoothstep(0.0, 1.0, (psi.y - psi.x)/(2.0*planetRadii)));\n  \n  col.xyz = mix(col.xyz, rscol.xyz, rscol.w*step(rsd, cold));\n  \n  return col.xyz;\n}\n\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvec3 fragment(vec3 ro, vec3 uu, vec3 vv, vec3 ww, vec2 p) {\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.5*ww);\n  vec3 col = render(ro, rd);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  float tperiod = TPERIOD;\n  int period = NPERIOD;\n  vec3 ro = vec3(0.0, 0.0, 52.0);\n  vec3 la = vec3(0.0, 0.0,0.0);\n  vec3 up = vec3(-0.0, 1.0, 0.0);\n\n  if (period == 0) {\n    ro = vec3(0.0, 0.0, 52.0);\n    ro.y += tperiod*15.0/PERIOD+2.0;\n    la = vec3(0.0, 0.0, -1000000.0);\n  } else if (period == 1) {\n    ro = vec3(00.0, 15.0, -50.0);\n    ro.y -= 10.0*tperiod/PERIOD;\n    rot(ro.xz,-2.0*tperiod/PERIOD-TAU/10.0);\n  } else if (period == 2) {\n    ro = vec3(0.0, 5.0, 30.0);\n    la = vec3(0.0, 0.0, -1000000.0);\n    ro.x += -10.0*tperiod/PERIOD;\n    ro.y += 17.0*tperiod/PERIOD;\n    ro.z += 90.0*tperiod/PERIOD;\n    up = vec3(-1.0, 1.0, 0.0);\n  } else if (period == 3) {\n    ro = vec3(00.0, 0.0, -25.0);\n    rot(ro.yz, 1.0-0.25*tperiod/PERIOD);\n    la = vec3(0.0, 0.0, 0.0);\n    up = vec3(-0.25, 1.0, 0.0);\n  }\n  \n  \n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = (cross(ww,uu));\n\n  float s = 2.0/RESOLUTION.y;\n\n  vec2 o1 = vec2(1.0/8.0, 3.0/8.0)*s;\n  vec2 o2 = vec2(-3.0/8.0, 1.0/8.0)*s;\n\n  vec3 col = vec3(0.0);\n\n  // https://blog.demofox.org/2015/04/23/4-rook-antialiasing-rgss/  \n  col += fragment(ro, uu, vv, ww, p+o1);\n  col += fragment(ro, uu, vv, ww, p-o1);\n  col += fragment(ro, uu, vv, ww, p+o2);\n  col += fragment(ro, uu, vv, ww, p-o2);\n  \n  col*=0.25;\n\n  col = postProcess(col, q);\n \n  float fadeIn = smoothstep(0.0, FADETIME, tperiod);\n  float fadeOut = 1.0 - smoothstep(PERIOD - FADETIME, PERIOD, tperiod);\n  col *= fadeIn;\n  col *= fadeOut;\n\n  fragColor = vec4(col, 1.0);\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}