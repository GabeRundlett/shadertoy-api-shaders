{
    "Shader": {
        "info": {
            "date": "1488723455",
            "description": "Basic primitives for direct ray-interception -faster than ray marching- and reflection (sphere, cone, cylinder, box)\nanimated maze using Truchet pattern algo (from book of shader)\n\nUSE MOUSE TO CHANGE THE MAX CAMERA TRAVEL.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "4slcRS",
            "likes": 30,
            "name": "Trip in Tron",
            "published": 3,
            "tags": [
                "3d",
                "raytracing",
                "primitives",
                "cone",
                "cylinder"
            ],
            "usePreview": 0,
            "username": "ocb",
            "viewed": 1362
        },
        "renderpass": [
            {
                "code": "// Author: ocb\n// Title: Trip in Tron\n// Checking basic primitives (sphere, cone, cylinder, 3D rect) in Ray Intercepting (direct calculation of ray impact on object)\n// The 2 solutions of shpere/ray interception is calculated to allow the inside view of sphere (use for the shock wave)\n// pulses are calculated in 3D using max distance inside the object (bottom of parabol).\n\n// Use mouse (clic and right/left) to change the max camera travel\n\n#define PI 3.141592653589793\n#define INFINI 1000000000.\n#define maxSph 3\n#define maxCone 2\n#define maxRec 2\n\n\n\nfloat random (in vec2 st,float time) { \t\t\t\t\t\t\n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123+time);\n}\n\n\n// from TheBookOfShader\nvec2 truchetPattern(in vec2 st, in float i){\n    \n    if (i > 0.75) {\n        st = vec2(1.) - st;\n    } else if (i > 0.5) {\n        st = vec2(1.0-st.x,st.y);\n    } else if (i > 0.25) {\n        st = 1.0-vec2(1.0-st.x,st.y);\n    }\n    return st;\n}\n\n// tower skin\nfloat dataFlow(vec2 o, vec2 dim, vec2 pos){\n    float taux = 0.;\n    vec2 p = pos - o;\n \n \tfloat i = floor( abs(p.x)/dim.x * 20.);\n    float f = fract( abs(p.x)/dim.x * 20.);\n    \n    taux =  step(.8*(sin(iTime*.1)+1.)/2.+.1, random(vec2(i,p.y/2000000.),iTime*.1))*step(.8,random(vec2(p.y/1000000.),1.))  *step(.1,f)*(1.-step(.9,f));\n    taux += smoothstep(.9,1.,p.x/dim.x)+(1.-smoothstep(.0,.1,p.x/dim.x)) ;    \n        \n    return taux;\n}\n\n\nfloat groundImpact(in vec3 pos,in float gndSurface, in vec3 N_ray){\n    float t = INFINI;\n    t = (gndSurface-pos.y)/N_ray.y;\n    \n    if (t <= 0.){\n        t = INFINI;\n    }\n    return t;\n}\n\n\nvec2 sphereImpact(in vec3 pos, in vec3 sphO, in float sphR, in vec3 N_ray){\n    \n    float t = INFINI;\n    float t1, t2;\n    vec3 delta = pos - sphO;\n    float dmin = 0.;\n    \n    // Sphere interception\n    // pre-calculation\n    float dot_delta_N_ray = dot(delta, N_ray);\n    float c = dot(delta,delta) - sphR*sphR;\n    \n    float discr = dot_delta_N_ray*dot_delta_N_ray - c;\n    \n    if (discr >= 0.){\n       \tfloat sqrt_discr = sqrt(discr);\n        t1= (-dot_delta_N_ray + sqrt_discr);\n        t2= (-dot_delta_N_ray - sqrt_discr);\n        t = min(t1,t2) ;\n        if (t <= 0.001){\n            t = max(t1,t2);\n            if (t <= 0.001) t = INFINI;\n        } \n    }\n        \n    dmin = abs(c - dot_delta_N_ray*dot_delta_N_ray)/sphR;\n    \n    return vec2(t, dmin);\n}\n\nfloat rectImpact(in vec3 pos, in vec3 recO, in vec3 recD, in vec3 N_ray, inout vec3 norm){\n    \n    float t = INFINI;\n    float t1,t2,t3;\n    float d1,d2,d3;\n\n    \n    \tif(recO.z+recD.z-pos.z<0.){\n        \tt1 = (recO.z+recD.z-pos.z)/N_ray.z;\n        \td1 = 1.;\n    \t}\n    \telse if(recO.z-pos.z>0.000){\n    \t\tt1 = (recO.z-pos.z)/N_ray.z;\n    \t\td1 = -1.;\n\t\t}\n    \telse{t1=-1.;}\n    \n    \tif(recO.y+recD.y-pos.y<0.){\n        \tt2 = (recO.y+recD.y-pos.y)/N_ray.y;\n        \td2 = 1.;\n    \t}\n    \telse if(recO.y-pos.y>0.){\n        \tt2 = (recO.y-pos.y)/N_ray.y;\n        \td2 = -1.;\n    \t}\n    \telse{t2=-1.;}\n\n    \tif(recO.x+recD.x-pos.x<0.){\n        \tt3 = (recO.x+recD.x-pos.x)/N_ray.x;\n        \td3 = 1.;\n    \t}\n    \telse if(recO.x-pos.x>0.){\n        \tt3 = (recO.x-pos.x)/N_ray.x;\n        \td3 = -1.;\n    \t}\n    \telse{t3=-1.;}\n\n\n    \tvec3 pos1 = pos + N_ray*t1;\n    \tvec3 pos2 = pos + N_ray*t2;\n    \tvec3 pos3 = pos + N_ray*t3;\n    \n    \tif(t1>0.001 && all(bvec2 (step(recO.xy,pos1.xy)*(1.-step(recO.xy+recD.xy,pos1.xy))))){\n        \tt = t1;\n        \tnorm = vec3 (0.,0.,d1);\n    \t}\n\t\telse\n    \tif(t2>0.001 && all(bvec2 (step(recO.xz,pos2.xz)*(1.-step(recO.xz+recD.xz,pos2.xz))))){\n        \tt = t2;\n        \tnorm = vec3 (0.,d2,0.);\n    \t}\n    \telse\n    \tif(t3>0.001 && all(bvec2 (step(recO.yz,pos3.yz)*(1.-step(recO.yz+recD.yz,pos3.yz))))){\n        \tt = t3;\n        \tnorm = vec3 (d3,0.,0.);\n    \t}\n    \n    return t;\n}\n\nvec2 cylinderImpact(in vec2 pos, in vec2 cylO, in float cylR, in vec2 N_ray){\n    float t=INFINI, minDist=0.;\n    vec2 delta = pos - cylO;\n\n    // circle interception\n    // pre-calculation\n    float dot_N_ray_Sq = dot(N_ray,N_ray);\n    float dot_delta_N_ray = dot(delta, N_ray);\n    float c = dot(delta,delta) - cylR*cylR;\n    \n    float discr = dot_delta_N_ray*dot_delta_N_ray - dot_N_ray_Sq*c;\n    \n    if (discr >= 0.){\n        float sqrt_discr = sqrt(discr);\n        t= min((-dot_delta_N_ray + sqrt_discr)/(dot_N_ray_Sq),\n        \t\t(-dot_delta_N_ray - sqrt_discr)/(dot_N_ray_Sq));\n        if (t < 0.001) t=INFINI;\n    }\n    \n    minDist = abs(c-dot_delta_N_ray*dot_delta_N_ray/dot_N_ray_Sq)/cylR;\n    \n\treturn vec2(t,minDist);\n}\n    \nvec2 coneImpact(in vec3 pos, in vec3 coneO, in float coneH, in float coneR, in vec3 N_ray){\n    float t = INFINI, minDist=INFINI;\n    vec3 delta = pos - coneO;\n    \n    float Dy = coneH - delta.y;\n    float r2 = coneR*coneR/(coneH*coneH);\n\t\n    // circle interception\n    // pre-calculation\n    float dot_N_ray_Sq_XZ = dot(N_ray.xz,N_ray.xz);\n    float dot_delta_N_ray_XZ = dot(delta.xz, N_ray.xz);\n    float c = dot(delta.xz,delta.xz) - r2*Dy*Dy;\n    float calc = dot_delta_N_ray_XZ + r2*Dy*N_ray.y;\n    \n    float discr = calc*calc - (dot_N_ray_Sq_XZ - r2*N_ray.y*N_ray.y) * c;\n    \n    if (discr >= 0.){\n        float sqrt_discr = sqrt(discr);\n        float t1 = (-calc + sqrt_discr)/(dot_N_ray_Sq_XZ - r2*N_ray.y*N_ray.y);\n        float t2 = (-calc - sqrt_discr)/(dot_N_ray_Sq_XZ - r2*N_ray.y*N_ray.y);\n       \n        if (t1 <= 0.001) t1 = INFINI;\n        else if (-N_ray.y*t1 + Dy < 0.) t1 = INFINI;\n        else if (-N_ray.y*t1 + Dy > coneH) t1 = INFINI;\n        \n        if (t2 <= 0.001) t2 = INFINI;\n        else if (-N_ray.y*t2 + Dy < 0.) t2 = INFINI;\n        else if (-N_ray.y*t2 + Dy > coneH) t2 = INFINI;\n        \n        t = min(t1,t2);  \n        if (t < INFINI) minDist = abs(c-calc*calc/(dot_N_ray_Sq_XZ - r2*N_ray.y*N_ray.y))/(coneR/coneH);\n    }\n    \n\treturn vec2(t,minDist);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy-.5;\n    st.x *= iResolution.x/iResolution.y;\n\n    // object def\n    \n    //sphere\n    vec3 sphO[maxSph];\n    float sphR[maxSph];\n    \n    sphO[0] = vec3(40.*sin(iTime*.45),5.*sin(iTime*.2)+30.,60.*cos(iTime*.3));\n    sphR[0] = 5.;\n    sphO[1] = vec3(50.*sin(iTime*.4),8.*sin(iTime*.3)+35.,50.*cos(iTime*.35));\n    sphR[1] = 4.;\n    sphO[2] = vec3(60.*sin(iTime*.35),5.*sin(iTime*.2)+40.,30.*cos(iTime*.4));\n    sphR[2] = 3.;\n    \n    //cube\n    vec3 recO[maxRec];\n    vec3 recD[maxRec];\n    vec3 normRect[maxRec];\n    \n    recO[0] = vec3(-20,0.,-20.);\n    recD[0] = vec3(5.,4000.,5.);\n    recO[1] = vec3(20,0.,20.);\n    recD[1] = vec3(5.,4000.,5.);\n    \n    //cylinder\n    vec3 XcylO = vec3(0.,10.,0.);\n    float XcylR = 1.;\n    vec3 ZcylO = vec3(0.,10.,0.);\n    float ZcylR = 1.;\n    \n    // sphere for impact\n    vec3 sphXO = XcylO;\n    float sphXR = 1000.*fract(iTime*.1);\n    \n    //cone\n    \n    vec3 coneO[maxCone];\n    float coneH[maxCone];\n    float coneR[maxCone];\n    \n    coneO[0] = vec3(20.,0.,-20.);\n    coneH[0] = 40.;\n    coneR[0] = 6.;\n    coneO[1] = vec3(-20.,0.,20.);\n    coneH[1] = 40.;\n    coneR[1] = 6.;\n    \n    \n    // camera target is switching from shere1 and cylinders crossing\n    vec3 camTarget = sphO[0]*(1.+sin(iTime*.2))/2. + XcylO*(1.+sin(iTime*.2+PI))/2.;\n    //vec3 camTarget = recO[0]+vec3(0.,0.,0.);\n    //vec3 camTarget = coneO[0]+ vec3(0.,20.,0.);\n    \n    int hitObj = -1000;\t// -1000 is Sky, -1 is Ground\n    \n    // camera def\n    float focal = 1.;\n    //rau, alpha, theta cam position\n    float rau = (1.-iMouse.x/iResolution.x)*500.*(sin(iTime/11.)+1.) + 10.,\n          alpha = -iTime/5.,\n          theta = (sin(iTime/7.)/2.+0.5)*(PI/2.-.3)+0.05;\n    \n    //float cosT = cos(theta), sinT = sin(theta), cosA = cos(alpha), sinA = sin(alpha);\t// pre-calculate  \n\t\n    // cam pos\n    vec3 screenPos = rau*vec3(-cos(theta)*sin(alpha),sin(theta),cos(theta)*cos(alpha)) + camTarget;\t\n    vec3 pos = screenPos;\n    \n    // 2 rotations. working. more elegant solution below (iq)\n\t//vec3 N_ray = normalize(vec3(st.x*cosA - (-st.y*sinT - focal*cosT)*sinA,\t\t\t\t// ray rotation\n    //                             st.y*cosT - focal*sinT,\n    //                             st.x*sinA + (-st.y*sinT - focal*cosT)*cosA));\n    \n    //screen coordinates\n\tvec3 ww = normalize( camTarget - screenPos );\n    vec3 uu = normalize(cross(ww,vec3(0.0,1.0,0.0)) ) ;\n    vec3 vv = cross(uu,ww);\n\t// create view ray\n\tvec3 N_ray = normalize( st.x*uu + st.y*vv + focal*ww );\n    \n    \n    float ground = 0.;\n    vec3 N_normPos = vec3(0.);\n    \n\n    vec3 color = vec3(.0);\n    \n    vec2 infoCone[maxCone];\n        infoCone[0] = vec2 (INFINI);\n        infoCone[1] = vec2 (INFINI);\n    \n    for (int rayNbr = 0; rayNbr <4; rayNbr++){\t\t// Max 4 reflects\n    \n    \tfloat t = INFINI; \t// parametric distance\n    \tfloat temp = INFINI;\n        // result infos for sphere, cylinder X and Z\n        // info contain t and max distance reach inside the obj.\n        vec2 infoS = vec2(INFINI);\n        vec2 infoX = vec2 (INFINI), infoZ = vec2 (INFINI);\n        \n        float explDist = 0.;\n        hitObj = -1000;\n    \n        // explosion sphere\n        \n        infoS = sphereImpact(pos, sphXO, sphXR, N_ray);\n    \tif(infoS.x<INFINI){\n            t = infoS.x;\n            hitObj = 50;\n            explDist = infoS.y;\n        }\n        \n    \t// sphere obj impact\n    \tfor (int i = 0; i<maxSph; i++){\n    \t\tinfoS = sphereImpact(pos, sphO[i], sphR[i], N_ray);\n    \t\tif(infoS.x<t){\n            \tt = infoS.x;\n            \thitObj = i;\n        \t}\n    \t}\n    \n        //rect  obj impact\n        for (int i = 0; i<maxRec; i++){\n        \ttemp = rectImpact(pos,recO[i], recD[i],N_ray, normRect[i]);\n        \tif(temp<t){\n            \tt = temp;\n             \thitObj = 10+i;\n            }\n        }\n        \n        infoX = cylinderImpact(pos.yz, XcylO.yz, XcylR, N_ray.yz);\n        if(infoX.x<t){\n            t = infoX.x;\n            hitObj = 20;\n        }\n        \n        infoZ = cylinderImpact(pos.xy, ZcylO.xy, ZcylR, N_ray.xy);\n        if(infoZ.x<t){\n            t = infoZ.x;\n            hitObj = 21;\n        }\n        \n        for (int i = 0; i<maxCone; i++){ \n        \tinfoCone[i] = coneImpact(pos, coneO[i], coneH[i], coneR[i], N_ray);\n        \tif(infoCone[i].x<t){\n                t = infoCone[i].x;\n                hitObj = 30+i;\n            }\n        }\n        \n        \n    \t// ground impact\n    \ttemp = groundImpact(pos, ground, N_ray );\n    \tif (temp<t){\n        \tt = temp;\n        \thitObj = -1;\n    \t}\n     \t\n        \n        \n        if (hitObj >= 0){\t// if Object hit, do raytrace again\n            \n            pos += t*N_ray;\t// with new pos\n            \t\t\t\t// and new ray (calculated below after finding Normal vec\n            \n            if (hitObj == 0) N_normPos = normalize(pos - sphO[0]);\n  \t\t\telse if (hitObj == 1) N_normPos = normalize(pos - sphO[1]);\n          \telse if (hitObj == 2) N_normPos = normalize(pos - sphO[2]);\n            \n            else if (hitObj == 10){\n                N_normPos = normRect[0];\n                if (bool(normRect[0].x)) color.gb += .3*dataFlow( recO[0].zy, recD[0].zy, pos.zy);\n                else color.gb += .3*dataFlow( recO[0].xy, recD[0].xy, pos.xy);\n                if (N_ray.y <0.) color.b += min(.2,-N_ray.y);\n                color.b += .2*(1.-smoothstep(0.,10.,pos.y));\n            }\n            else if (hitObj == 11){\n                N_normPos = normRect[1];\n            \tif (bool(normRect[1].x)) color.gb += .3*dataFlow( recO[1].zy, recD[1].zy, pos.zy);\n                else color.gb += .3*dataFlow( recO[1].xy, recD[1].xy, pos.xy);\n                if (N_ray.y <0.) color.b += min(.2,-N_ray.y);\n                color.b += .2*(1.-smoothstep(0.,10.,pos.y));\n            }\n            else if (hitObj == 20){\n                N_normPos = normalize(vec3(0.,pos.y-XcylO.y,pos.z-XcylO.z));\n                color.r += max(.0,pow(infoX.y,2.)-smoothstep(.0, .8, fract(iTime*.1+pos.x*0.00025)));\n                //color.r += min(1.,.05/infoX.y);\n            }\n            else if (hitObj == 21){\n                N_normPos = normalize(vec3(pos.x-ZcylO.x,pos.y-ZcylO.y,0.));\n                color.gb += step(.6,random(vec2(floor(iTime*10.+pos.z*0.1)),0.))*max(0.,infoZ.y-smoothstep(0., 1., fract(iTime*10.+pos.z*0.1)));\n                color.gb += min(1.,.1/infoZ.y);\n            } \n            \n            else if (hitObj == 30){\n                N_normPos = normalize(vec3(pos.x - coneO[0].x,\n                                           coneR[0]*coneR[0]/(coneH[0]*coneH[0])*(coneH[0] + coneO[0].y - pos.y),\n                                           pos.z-coneO[0].z));\n                if (infoCone[0].y != INFINI) color.b += .4*min(1.,30./pow(infoCone[0].y,2.));\n                color.b += .4*(1.-smoothstep(0.,10.,pos.y));\n                \n            }\n            else if (hitObj == 31){\n                N_normPos = normalize(vec3(pos.x - coneO[1].x,\n                                           coneR[1]*coneR[1]/(coneH[1]*coneH[1])*(coneH[1] + coneO[1].y - pos.y),\n                                           pos.z-coneO[1].z));\n\t\t\t\tif (infoCone[1].y != INFINI) color.b += .4*min(1.,30./pow(infoCone[1].y,2.));\n                color.b += .4*(1.-smoothstep(0.,10.,pos.y));\n            }\n            \n            else if (hitObj == 50){\n                color.r += .5*min(1.,10000./explDist/pos.y/pos.y)*min(.9, smoothstep(0.,1.,(1.-fract(iTime*.1))));\n            }\n            \n            if(hitObj != 50){\n            \tN_ray = reflect(N_ray,N_normPos);\t\t\t// and new ray\n        \t\t//color += vec3(.0,.05,.1);\n            }\n        }\n        \n        else if (hitObj == -1) {\n            pos += t*N_ray;\t\t// ground: stop ray trace\n            break;\n        }\n        else break;\t\t\t\t// Sky: stop raytrace\n    }\n    \n    if (hitObj >= 0){\t\t\t// if ray still bouncing between 2 spheres, ray must be finished\n    \tfloat t = groundImpact(pos, ground, N_ray );\t//consider no more objects\n    \tif (t == INFINI) hitObj = -1000;\t\t\t\t// ray finish in sky\n    \telse {\t\t\t\t\t\t\t\t\t\t\t// or on ground\n        \thitObj = -1;\n        \tpos += t*N_ray;\n    \t}\n    }\n    \n    if (hitObj == -1) {\t// ground hit\n        \n        vec2 ipos = floor(vec2(pos.x,pos.z)*.01);  // integer\n    \tvec2 fpos = fract(vec2(pos.x,pos.z)*.01);  // fraction\n\t\tvec2 tile = truchetPattern(fpos, random(ipos, iTime*.05));\t\t// generate Maze\n        vec2 tileXL = truchetPattern(fract(vec2(pos.x,pos.z)*.5), random( floor(vec2(pos.x,pos.z)*.5) , iTime*.1 ));\t\t// used for impact effect \n        \n        // Maze\t\t//min(1.,(-N_ray.y)*5.) = distance fog to limit aliasing\n        vec2 p = pos.xz+20.*iTime;\n    \tvec2 vapor = max(vec2(0.),1.+.3*sin(.03*p)+.2*sin(.1*p));\n        float v = vapor.x*vapor.y;\n        color.b += .3*v*min(1.,(-N_ray.y)*5.)*(smoothstep(tile.x-0.02*v,tile.x,tile.y) - smoothstep(tile.x,tile.x+0.02*v,tile.y));\n        color.b += v*min(1.,(-N_ray.y)*5.)*.005/(length(tile-fract(iTime+random(ipos,1.)))+.01);\t// Head on top of Truchet pattern\n        \n        color.b += .7*(1.-smoothstep(coneR[0],coneR[0]*3.,length(coneO[0].xz-pos.xz)))\n            \t\t\t*(smoothstep(tileXL.x-0.1,tileXL.x,tileXL.y)- smoothstep(tileXL.x,tileXL.x+0.1,tileXL.y));\n        color.b += .7*(1.-smoothstep(coneR[1],coneR[1]*3.,length(coneO[1].xz-pos.xz)))\n            \t\t\t*(smoothstep(tileXL.x-0.1,tileXL.x,tileXL.y)- smoothstep(tileXL.x,tileXL.x+0.1,tileXL.y));\n        \n        vec2 recC = recO[0].xz+recD[0].xz/2.;\n        color.b += .7*(1.-smoothstep(recD[0].x,recD[0].x*3.,abs(recC.x-pos.x)))*(1.-smoothstep(recD[0].z,recD[0].z*4.,abs(recC.y-pos.z)))\n            \t\t\t*(smoothstep(tileXL.x-0.1,tileXL.x,tileXL.y)- smoothstep(tileXL.x,tileXL.x+0.1,tileXL.y));\n        recC = recO[1].xz+recD[1].xz/2.;\n        color.b += .7*(1.-smoothstep(recD[1].x,recD[1].x*3.,abs(recC.x-pos.x)))*(1.-smoothstep(recD[1].z,recD[1].z*4.,abs(recC.y-pos.z)))\n            \t\t\t*(smoothstep(tileXL.x-0.1,tileXL.x,tileXL.y)- smoothstep(tileXL.x,tileXL.x+0.1,tileXL.y));\n        \n    \tcolor.r += .9* min(.9, smoothstep(.2,1.,(1.-fract(iTime*.1))*(.7*(smoothstep(tileXL.x-0.1,tileXL.x,tileXL.y)-\n              .7*smoothstep(tileXL.x,tileXL.x+0.1,tileXL.y))+.3*(1.-smoothstep(.0,.2,length(tileXL-fract(iTime*5.)))) )*(1.-smoothstep(0.,600000.*fract(iTime*.1), pos.x*pos.x+ pos.z*pos.z)) ));  //ground impact\n        \n        color.b += .2- min(.2,-N_ray.y);\n\t\n    }\n    if (hitObj == -1000) {\t\t// ray goes to the sky\n        color += vec3(max((N_ray.x+1.)/2.*(-4.*N_ray.y+1.)/2.,0.),.1*(1.-N_ray.y),.2*(1.-N_ray.y));\n        color += vec3(.0,.0,.1);\n    }\n    \n    fragColor = vec4(color,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}