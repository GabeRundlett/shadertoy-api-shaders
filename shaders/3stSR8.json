{
    "Shader": {
        "info": {
            "date": "1571421377",
            "description": "Celestial Julia Revolute",
            "flags": 32,
            "hasliked": 0,
            "id": "3stSR8",
            "likes": 30,
            "name": "Celestial Julia Revolute",
            "published": 3,
            "tags": [
                "julia",
                "revolute",
                "celestial"
            ],
            "usePreview": 1,
            "username": "aiekick",
            "viewed": 753
        },
        "renderpass": [
            {
                "code": "// Created by Stephane Cuillerdier - Aiekick/2019 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// use the celestial shader from http://glslsandbox.com/e#37771.0\n\n// other fractals :\n// https://www.shadertoy.com/view/WslXWr\n// https://www.shadertoy.com/view/WsXSRS\n// https://www.shadertoy.com/view/MtjczG\n// https://www.shadertoy.com/view/MtjyWm\n// https://www.shadertoy.com/view/4lScRy\n// https://www.shadertoy.com/view/lljyWm\n\n// fractal\nconst vec3 cx = vec3(0,0.55944,5);\nconst vec3 cy = vec3(0.41958,-0.06993,5);\nconst float fractalIter = 7.0;\nconst float sinCoef = 0.37063;\n\n// halo\nconst float haloCoef = 5.0;\nconst vec3 haloColor0 = vec3(0.166713,0.0306322,0.236607);\nconst vec3 haloColor1 = vec3(0.0752687,0.450893,0.00805165);\n\n// sss\nconst vec3 sssColor0 = vec3(0,0.601209,1);\nconst vec3 sssColor1 = vec3(1,0.99999,0.99999);\nconst float sssD = 0.055;\nconst float sssN = -0.2;\nconst float sssStep0 = 0.9;\nconst float sssStep1 = 0.1;\n\nconst vec3 ld = vec3(0.,1., .5);\n\nfloat t = 0.;\n\nvec2 m;\n\nfloat fullAtan(vec2 p)\n{\n    return step(0.0,-p.x)*3.1415926535 + sign(p.x) * atan(p.x, sign(p.x) * p.y);\n}\n\nfloat fractus(vec2 p, vec2 v)\n{\n\tvec2 z = p;\n    vec2 c = v;\n\tfloat k = 1., h = 1.0;    \n    for (float i=0.;i<fractalIter;i++)\n    {\n        h *= 4.*k;\n\t\tk = dot(z,z);\n        if(k > 4.) break;\n\t\tz = vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y) + c;\n    }\n    return sqrt(k/h)*log(k);\n}\n\nvec4 dfFractus(vec3 p)\n{\n\tfloat a = atan(p.x,p.z);\n\t//a = sin(a) * sinCoef; // axis y\n    \n    vec2 c = vec2(\n\t\tmix(cx.x, cx.y, sin(a * cx.z)),\n\t\tmix(cy.x, cy.y, sin(a * cy.z)));\n    \n    float path = length(p.xz) - 3.;\n    \n    vec2 rev = vec2(path, p.y);\n    float aa = a + iTime;\n    rev *= mat2(cos(aa),-sin(aa),sin(aa),cos(aa)); // rot near axis y\n\t\n\treturn vec4(fractus(rev, c) - 0.0, rev, 0);\n}\n\nfloat id = 0.0;\n\nvec4 df(vec3 p)\n{\n\tvec4 fr = dfFractus(p);\n\t\n\tfloat a = atan(p.x,p.z);\n\tfloat st = 6.28318/10.0;\n\tid = floor(a/st);\n\ta = mod(a, st) - st * 0.5;\n\tfloat d = length(p.xz);\n\tp.xz = vec2(cos(a),sin(a)) * d;\n\tp.x -= 3.0;\n\tvec4 sp = vec4(length(p) - 0.4,0,0,1);\n\tif (sp.x < fr.x)\n\t\treturn sp;\n\treturn fr;\n}\n\nvec3 nor( vec3 p, float prec )\n{\n    vec2 e = vec2( prec, 0. );\n    vec3 n = vec3(\n\t\tdf(p+e.xyy).x - df(p-e.xyy).x,\n\t\tdf(p+e.yxy).x - df(p-e.yxy).x,\n\t\tdf(p+e.yyx).x - df(p-e.yyx).x );\n    return normalize(n);\n}\n\n// from iq code\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<1; i++ )\n    {\n\t\tfloat h = df( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += h*.25;\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0., 1. );\n}\n\n// from iq code\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<10; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = df( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    m = iMouse.xy/iResolution.xy;\n    if (m.x == 0.) m.x = .1;\n    \n\tfragColor = vec4(1);\n\t\n\tvec2 g = fragCoord.xy;\n\tvec2 si = iResolution.xy;\n\tvec2 uv = (2.*g-si)/min(si.x, si.y);\n\t\n    float a = iTime * 0.2;\n\tvec3 ro = vec3(cos(a),0.5,sin(a)) * 7.;\n\tvec3 camUp = vec3(0,1,0);\n\tvec3 camOrg = vec3(0,-1.5,0);\n\t\n\tfloat fov = .6;\n\tvec3 axisZ = normalize(camOrg - ro);\n\tvec3 axisX = normalize(cross(camUp, axisZ));\n\tvec3 axisY = normalize(cross(axisZ, axisX));\n\tvec3 rd = normalize(axisZ + fov * uv.x * axisX + fov * uv.y * axisY);\n\t\n\tfloat s = 0.0;\n    float d = 0.0;\n\tfloat dMax = 30.;\n\tfloat count = 0.;\n    \n    // min(iFrame,0) => iq trick for fast shader compilation\n\tfor (int i=min(iFrame,0); i<500; i++)\n\t{\n\t\tif (abs(s)<d*d*1e-5 || d>dMax) break;\n        s = df(ro + rd * d).x;\n\t\td += s * 0.5;\n\t\tcount++;\n\t}\n\t\n    if (d<dMax)\n\t{\n\t\tvec3 p = ro + rd * d;\n        vec3 n = nor(p, 0.01);\n\t\tvec4 mat = df(p);\n        \n        vec3 tex = texture(iChannel1, mat.yz).rgb; // wood\n        \n\t\t// iq lighting\n\t\tfloat occ = calcAO( p, n );\n        float amb = clamp( 0.5+0.5*n.y, 0.0, 1.0 );\n        float dif = clamp( dot( n, ld ), 0.0, 1.0 ) * (df(p+n*1.16).x);\n        float spe = pow(clamp( dot( rd, ld ), 0.0, 1.0 ),16.0);\n        float sss = df(p + n*sssN).x/sssD;\n\t\n        dif *= softshadow( p, ld, 0.1, 2. );\n        \n        vec3 brdf = vec3(0.5) * tex;\n        brdf += 0.5*dif*tex;\n        brdf += 0.4*spe*dif;\n        brdf += 0.3*amb*vec3(0.50,0.70,1.00)*occ;\n\t\t\n\t\tif (mat.w > 0.5)\n\t\t{\n\t\t\tid = mod(id,2.0);\n\t\t\tvec3 c0 = id * haloColor0 * haloCoef * step(sss,0.1);\n\t\t\tvec3 c1 = --id * haloColor1 * haloCoef * step(sss,0.1);\n\t\t\t\n\t\t\tbrdf += c0;\n        \tbrdf += c1;\t\t\n\t\t}\n\n\t\tbrdf += mix(sssColor1,vec3(0), step(sss,sssStep1));\n\t\tbrdf += mix(sssColor0,vec3(0), step(1.0-sss,sssStep0));\n\t\t\t\n\t\tfragColor.rgb = brdf;\n\n\t\tvec3 cbm = getColorFromVirtualCubeMap(iChannel0, reflect(rd,n));\n\t\tfragColor.rgb = mix(brdf, cbm, 0.5);\n\t\t\n        fragColor.rgb = mix( fragColor.rgb, vec3(0), 1.0-exp( -0.01*d*d*count/150. ) ); \n\t}\n\telse\n\t{\n\t\tvec3 cbm = getColorFromVirtualCubeMap(iChannel0, rd);\n\t\tfragColor.rgb = cbm;\n\t}\n    \n    fragColor.rgb = sqrt(fragColor.rgb * fragColor.rgb * 0.8);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//from http://glslsandbox.com/e#37771.0\n\nfloat _time;\n\n#define iterations 14\n#define formuparam2 0.79\n \n#define volsteps 5\n#define stepsize 0.290\n \n#define zoom 0.900\n#define tile   0.850\n#define speed2  0.10\n \n#define brightness 0.003\n#define darkmatter 0.400\n#define distfading 0.560\n#define saturation 0.800\n\n#define transverseSpeed zoom*2.0\n#define cloud 0.11 \n \nfloat triangle(float x, float a) \n{ \n\tfloat output2 = 2.0*abs(  2.0*  ( (x/a) - floor( (x/a) + 0.5) ) ) - 1.0;\n\treturn output2;\n}\n \nfloat field(in vec3 p) \n{\t\n\tfloat strength = 7. + .03 * log(1.e-6 + fract(sin(_time) * 4373.11));\n\tfloat accum = 0.;\n\tfloat prev = 0.;\n\tfloat tw = 0.;\t\n\n\tfor (int i = 0; i < 6; ++i) \n\t{\n\t\tfloat mag = dot(p, p);\n\t\tp = abs(p) / mag + vec3(-.5, -.8 + 0.1*sin(_time*0.7 + 2.0), -1.1+0.3*cos(_time*0.3));\n\t\tfloat w = exp(-float(i) / 7.);\n\t\taccum += w * exp(-strength * pow(abs(mag - prev), 2.3));\n\t\ttw += w;\n\t\tprev = mag;\n\t}\n\t\n\treturn max(0., 5. * accum / tw - .7);\n}\n\nvec3 color(vec3 rd)\n{   \n    vec2 uv2 = 2. * gl_FragCoord.xy / iResolution.xy - 1.;\n\tvec2 uvs = uv2;\n\t\n\t_time = iTime * 0.05;\n\t\n\tfloat time2 = _time;               \n    float speed = speed2;\n    speed = .01 * cos(time2*0.02 + 3.1415926/4.0);          \n\t//speed = 0.0;\t\n    float formuparam = formuparam2;\n\t\n    //get coords and direction\t\n\tvec2 uv = uvs;\t\t       \n\t//mouse rotation\n\tfloat a_xz = 0.9;\n\tfloat a_yz = -.6;\n\tfloat a_xy = 0.9 + _time*0.08;\t\n\t\n\tmat2 rot_xz = mat2(cos(a_xz),sin(a_xz),-sin(a_xz),cos(a_xz));\t\n\tmat2 rot_yz = mat2(cos(a_yz),sin(a_yz),-sin(a_yz),cos(a_yz));\t\t\n\tmat2 rot_xy = mat2(cos(a_xy),sin(a_xy),-sin(a_xy),cos(a_xy));\n\t\n\tfloat v2 =1.0;\t\n\tvec3 dir=vec3(uv*zoom,1.); \n\tdir = rd;\n\t\t\n\tvec3 from=vec3(0.0, 0.0,0.0);                               \n    from.x -= 5.0*(1.0-1.0);\n    from.y -= 5.0*(1.0-0.7);\n               \n\tvec3 forward = vec3(0.,0.,1.);  \n\tfrom.x += transverseSpeed*(1.0)*cos(0.01*_time) + 0.001*_time;\n\tfrom.y += transverseSpeed*(1.0)*sin(0.01*_time) +0.001*_time;\n\tfrom.z += 0.003*_time;\t\n\t\n\tdir.xy*=rot_xy;\n\tforward.xy *= rot_xy;\n\tdir.xz*=rot_xz;\n\tforward.xz *= rot_xz;\t\n\tdir.yz*= rot_yz;\n\tforward.yz *= rot_yz;\n\t\n\tfrom.xy*=-rot_xy;\n\tfrom.xz*=rot_xz;\n\tfrom.yz*= rot_yz;\n\t \n\t//zoom\n\tfloat zooom = (time2-3311.)*speed;\n\tfrom += forward* zooom;\n\tfloat sampleShift = mod( zooom, stepsize );\n\t \n\tfloat zoffset = -sampleShift;\n\tsampleShift /= stepsize; // make from 0 to 1\n\t\n\t//volumetric rendering\n\tfloat s=0.24;\n\tfloat s3 = s + stepsize/2.0;\n\tvec3 v=vec3(0.);\n\tfloat t3 = 0.0;\t\n\t\n\tvec3 backCol2 = vec3(0.);\n\tfor (int r=0; r<volsteps; r++) \n\t{\n\t\tvec3 p2=from+(s+zoffset)*dir;// + vec3(0.,0.,zoffset);\n\t\tvec3 p3=from+(s3+zoffset)*dir;// + vec3(0.,0.,zoffset);\n\t\t\n\t\tp2 = abs(vec3(tile)-mod(p2,vec3(tile*2.))); // tiling fold\n\t\tp3 = abs(vec3(tile)-mod(p3,vec3(tile*2.))); // tiling fold\t\t\n\t\t#ifdef cloud\n\t\tt3 = field(p3);\n\t\t#endif\n\t\t\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) \n\t\t{\n\t\t\tp2=abs(p2)/dot(p2,p2)-formuparam; // the magic formula\n\t\t\t//p=abs(p)/max(dot(p,p),0.005)-formuparam; // another interesting way to reduce noise\n\t\t\tfloat D = abs(length(p2)-pa); // absolute sum of average change\n\t\t\ta += i > 7 ? min( 12., D) : D;\n\t\t\tpa=length(p2);\n\t\t}\n\t\t\n\t\t//float dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\t//if (r>3) fade*=1.-dm; // dark matter, don't render near\n\t\t// brightens stuff up a bit\n\t\tfloat s1 = s+zoffset;\n\t\t// need closed form expression for this, now that we shift samples\n\t\tfloat fade = pow(distfading,max(0.,float(r)-sampleShift));\t\t\n\t\t//t3 += fade;\t\t\n\t\tv+=fade;\n\t    //backCol2 -= fade;\n\n\t\t// fade out samples as they approach the camera\n\t\tif( r == 0 )\n\t\t\tfade *= (1. - (sampleShift));\n\t\t// fade in samples as they approach from the distance\n\t\tif( r == volsteps-1 )\n\t\t\tfade *= sampleShift;\n\t\tv+=vec3(s1,s1*s1,s1*s1*s1*s1)*a*brightness*fade; // coloring based on distance\n\t\t\n\t\tbackCol2 += mix(.4, 1., v2) * vec3(1.8 * t3 * t3 * t3, 1.4 * t3 * t3, t3) * fade;\n\n\t\t\n\t\ts+=stepsize;\n\t\ts3 += stepsize;\t\t\n\t}//фор\n\t\t       \n\tv=mix(vec3(length(v)),v,saturation); //color adjust\t\n\n\tvec4 forCol2 = vec4(v*.01,1.);\t\n\t#ifdef cloud\n\tbackCol2 *= cloud;\n\t#endif\t\n\tbackCol2.b *= -3.8;\n\tbackCol2.r *= 0.05;\t\n\t\n\tbackCol2.b = 1.5*mix(backCol2.g, backCol2.b, 0.1);\n\tbackCol2.g = -0.;\n\tbackCol2.bg = mix(backCol2.gb, backCol2.bg, 0.39*(cos(1.00) + 1.0));\t\n\t\n\treturn forCol2.rgb + backCol2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // from my shader : https://www.shadertoy.com/view/3l2SDR\n    const float _pi = radians(180.0);\n\tconst float _2pi = radians(360.0);\n\tconst float _dpi = radians(90.0);\n\n\tvec2 v = fragCoord / iResolution.xy;\n    \n\tfloat a = v.x * _2pi - _dpi;\n\tfloat b = v.y * _pi; \n    \n\t// sphere\n    vec3 rd = vec3(\n        sin(b) * cos(a),\n    \tcos(b),\n    \t-sin(b) * sin(a));\n\t\n    vec3 col = color(rd);\n\tfragColor = vec4(sqrt(col*col*2.),1);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// from my shader : https://www.shadertoy.com/view/3l2SDR\nvec3 getColorFromVirtualCubeMap(sampler2D sam, vec3 rd)\n{\n\tconst float _pi = radians(180.0);\n\tconst float _2pi = radians(360.0);\n\tconst float _dpi = radians(90.0);\n\n\tfloat theta = atan(rd.y,rd.x);\n    float r = length(rd);\n        \n    // correct spheric distortion for top and bottom faces\n    // instead of just atan(p.z,r)\n    float phi =  asin(rd.z/r);\n        \n    vec2 uv = 0.5 + vec2(theta / _2pi, -phi / _pi);\n\t\n\treturn texture(sam, uv).rgb;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}