{
    "Shader": {
        "info": {
            "date": "1410158200",
            "description": "I was trying to understand the math behind the \"apollonian\" fractal. I still don't intuitively get it, but I got caught up making tweaks to the algorithm and ended up with this.",
            "flags": 0,
            "hasliked": 0,
            "id": "XdjSzD",
            "likes": 70,
            "name": "Apollonian Fractures",
            "published": 3,
            "tags": [
                "fractal",
                "apollonian"
            ],
            "usePreview": 1,
            "username": "otaviogood",
            "viewed": 4353
        },
        "renderpass": [
            {
                "code": "/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n*/\n\n// noise functions\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nfloat mixP(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(3.0-2.0*a));\n}\nvec2 noise2dTex2(vec2 uv)\n{\n    vec2 fr = fract(uv);\n    vec2 smoothv = fr*fr*(3.0-2.0*fr);\n    vec2 fl = floor(uv);\n    uv = smoothv + fl;\n    return textureLod(iChannel0, (uv + 0.5)/iChannelResolution[0].xy, 0.0).xy;\t// use constant here instead?\n}\nconst vec2 zeroOne = vec2(0.0, 1.0);\nfloat noise2d(vec2 uv)\n{\n    vec2 fr = fract(uv.xy);\n    vec2 fl = floor(uv.xy);\n    float h00 = Hash2d(fl);\n    float h10 = Hash2d(fl + zeroOne.yx);\n    float h01 = Hash2d(fl + zeroOne);\n    float h11 = Hash2d(fl + zeroOne.yy);\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\n}\n\n\nfloat Fractal(vec2 p)\n{\n    vec2 pr = p;\n    float scale = 1.0;\n    float iter = 1.0;\n    for (int i = 0; i < 12; i++)\n    {\n        vec2 n2 = noise2dTex2(p*0.15*iter+iTime*1.925);\n        float nx = n2.x - 0.5;\n        float ny = n2.y;\n        pr += vec2(nx, ny)*0.0002*iter*iter*iter;\n        pr = fract(pr*0.5+0.5)*2.0 - 1.0;\n        float len = pow(dot(pr, pr), 1.0+nx*0.5);\n        float inv = 1.1/len;\n        pr *= inv;\n        scale *= inv;\n        iter += 1.0;\n    }\n    float b = abs(pr.x)*abs(pr.y)/scale;\n    return pow(b, 0.125)*0.95;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // center and scale the UV coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 0.94;\n\n    // do the magic\n    vec2 warp = normalize(uv) * (1.0-pow(length(uv), 0.45));\n    vec3 finalColor = vec3(Fractal(uv*2.0+1.0),\n                           Fractal(uv*2.0+37.0),\n                           Fractal((warp+0.5)*2.0+15.0));\n    finalColor = 1.0 - finalColor;\n    float circle = 1.0-length(uv*2.2);\n    float at = atan(uv.x, uv.y);\n    float aNoise = noise2d(vec2(at * 30.0, iTime));\n    aNoise = aNoise * 0.5 + 0.5;\n    finalColor *= pow(max(0.0, circle), 0.1)*2.0;\t// comment out this line to see the whole fractal.\n    finalColor *= 1.0 + pow(1.0 - abs(circle), 30.0);\t// colorful outer glow\n    finalColor += vec3(1.0, 0.3, 0.03)*3.0 * pow(1.0 - abs(circle), 100.0) * aNoise;\t// outer circle\n    float outer = (1.0 - pow(max(0.0, circle), 0.1)*2.0);\n    finalColor += vec3(1.,0.2,0.03)*0.4* max(0.0, outer*(1.0-length(uv)));\n    fragColor = vec4(finalColor, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}