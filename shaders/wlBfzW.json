{
    "Shader": {
        "info": {
            "date": "1598396806",
            "description": "Parametric procedural 3d-object, allowing smooth transitions between spheres, tori, torusknots, based on julia fractal.\nhttps://www.youtube.com/user/cyperquantus\nhttps://www.shadertoy.com/view/3stSR8 Stephane Cuillerdier - Aiekick/2019 (twitter:@aiekick)",
            "flags": 0,
            "hasliked": 0,
            "id": "wlBfzW",
            "likes": 15,
            "name": "two bubble rings",
            "published": 3,
            "tags": [
                "julia",
                "torus",
                "sphere",
                "knot"
            ],
            "usePreview": 1,
            "username": "cyperus",
            "viewed": 765
        },
        "renderpass": [
            {
                "code": "// Created by Patrik Colling - cyperus/2020 (https://www.youtube.com/user/cyperquantus)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Parametric procedural 3d-object allowing smooth transitions between \n// spheres, tori, torusknots.\n//\n\n#define AA\n\n#define PI 3.14159265359\n// Time modulation\n#define PIiTime PI * iTime\n#define sinTime02 sin(0.2*iTime)\n#define sinTime03 sin(0.3*iTime)\n#define sinTime05 sin(0.5*iTime)\n#define sinTime07 sin(0.7*iTime)\n\n// complex number transformations\n// z_out = za*zb\nvec2 cmul(vec2 za,vec2 zb){\n    return za*mat2(zb.x,-zb.y,zb.yx);\n    }\n// z*e^ia\nvec2 crot(vec2 z, float a){\n    return cmul(z, vec2(cos(a),sin(a)));\n    }\n// z_out = z^q\nvec2 cpowq(vec2 z, float q){\n    float r = pow(length(z), q); float a=q* atan(z.y,z.x); return vec2(r*cos(a),r*sin(a));\n    }\n// z_out = (z*e^ia)^p-x0    \nvec2 ctfr(vec2 z,float x0, float p, float a){\n\treturn cpowq( cmul(z, vec2(cos(-a),sin(-a))),p) - vec2(x0, 0.);\n    }\n\n// came\nmat3 camerabase(vec3 co, vec3 ct, vec3 cup){\n    // co\t: camera origin point in worldspace\n    // cup\t: camera up direction vector in worldspace\n    // ct\t: camera target point in worldspace\n\tvec3 cw = normalize(ct - co);\t\t// camera ponting direction\n\tvec3 cu = normalize(cross(cup, cw));// camera left right\n\tvec3 cv = normalize(cross(cw, cu));\t// camera down up\n    return mat3(cu,cv,cw); // return camera orhtogonal basis as matrix\n}\n\nvec3 cameraraydirection(vec2 uv, mat3 cam, float f){\n    // uv : Viewport coordinates\n    // cam : camera orhtogonal basis\n    // f : focal length zoom-in: abs(f) ==> 0., zoom-out: abs(f) ==> +inf.\n    return normalize(cam * vec3(f*uv,1.)); \n}\n\nvec4 df(vec3 p)\n{\t///// MetaTorus-transformation\n    \n    // component swizzling: openGL => math coordinatesystem notation.\n    p = p.zxy; //(z, x, y) => (x, y, z)\n    \n    //// (torus,sphere,2spheres)-transformation\n    // cylindrical coordinate system\n    float au = atan(p.y, p.x); // [-PI, +PI]\n    float rxy = length(p.xy); // [0., +inf]\n    // 3D => 2D-space: radial half plane in cylindrical coordinate system == half complex plane\n    vec2 z = vec2(rxy, p.z);\n    // julia, half complex plane => complex plane\n\tfloat shift0 = 1.4+(1.0+sinTime05); // [-inf, +inf]\n    z = cmul(z,z)- vec2(shift0, 0.); // realaxis-translation, fraction == 2 \n    \n    //// juliafractal-transformation\n\t/// julia fractal iteration 0\n    const float fracu1 = 3.0; // int in [1,2,3,..]\n    const float fracv1 = 2.0; // int in [1,2,3,..]\n    const float twist1 = 0.0; // int in [...,-1,0,+1,...]\n    // shiftX modulation with FourierSerie F(fracu1 * au)\n    float shift1\t= 2.0 * sinTime02 \t\t\t\t\t\t\t\t\t\t\t\t// 0. order \n        \t\t\t+ 0.5 * cos(1. * (fracu1 * au) + (0.5 * PIiTime) );\t\t\t\t// 1. order\n            \t\t//+ 0.25 * cos(2. * (fracu1 * au) + (0.5 +0.01 * PIiTime) ); \t// 2. order\n    // torsionX must meet knot condition.\n    float torsion1 = au * twist1 / fracv1 - 0.25 * PIiTime;\n    z = ctfr(z, shift1, fracv1,  torsion1); // realaxis-translation,fraction,rotation\n\t/// julia fractal iteration 1\n    const float fracu2 = 7.0;\n    const float fracv2 = 3.0;\n    const float twist2 = 5.0;    \n    float shift2 = 0.5 +1.4 * sinTime03 + 0.5 * cos(fracu2 * au +0.0- 0.02 * PIiTime);\n    float torsion2 = au * twist2 / fracv2 + 0.05 * PIiTime;\n    z = ctfr(z, shift2, fracv2, torsion2);\n    \n\t/// estimated ray-step-length\n\tfloat d = log(length(z)); // :( but it works!\n\treturn vec4(d , z, au * fracu1 * fracu2);\n}\n\nvec3 nor( vec3 p, float prec )\n{\n    vec2 e = vec2( prec, 0.0 );\n    vec3 n = vec3(\n\t\tdf(p+e.xyy).x - df(p-e.xyy).x,\n\t\tdf(p+e.yxy).x - df(p-e.yxy).x,\n\t\tdf(p+e.yyx).x - df(p-e.yyx).x );\n    return normalize(n);\n}\n\n// from iq code\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<1; i++ )\n    {\n\t\tfloat h = df( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += h*.25;\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0., 1. );\n}\n\n// from iq code\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    // antialeasing\n    for( int i=0; i<1; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = df( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n//--------------------------------------------------------------------------\n\n// Grab all sky information for a given ray from camera\n// from Dave Hoskins // https://www.shadertoy.com/view/Xsf3zX\nvec3 GetSky(in vec3 rd, in vec3 sunDir, in vec3 sunCol)\n{\n\tfloat sunAmount = max( dot( rd, sunDir), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\n\tvec3  sky = mix(vec3(.1, .2, .3), vec3(.32, .32, .92), v);\n\tsky = sky + sunCol * sunAmount * sunAmount * .25;\n\tsky = sky + sunCol * min(pow(sunAmount, 800.0)*1.5, .3);\n\treturn clamp(sky, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n#ifdef AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n    //// Pixel2Viewport-space\n    vec2 o = rook[n];\n    vec2 uv = (2.*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else //AA\n\tvec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n#endif //AA\n      \n    // mouse\n    vec2 m = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    //// camera, Viewport2World-space\n    m *= 0.49*PI; float aa = m.x; float ab = -m.y;\n    vec3 co = 4.*vec3( cos(ab)*sin(aa),sin(ab),cos(ab)*cos(aa)); // camera origin\n\tconst vec3 cup = vec3(0,1,0);\t    // camera up direction in Worldspace\n\tconst vec3 ct = vec3(0,0,0);\t    // camera target point in Worldspace\n\tmat3 cam = camerabase(co,ct,cup);   // cameradirection = cam[0];\n \n    const float f = 0.6;\n    vec3 rd =  cameraraydirection(uv,cam, f);\n    \n\t// ray marching\n    const float rayDistMax = 14.;\t// maximal ray distance length\n    const float rayiMax = 300.;\t\t// maximal ray marching iterations\n    const float rayF = 0.02;\t\t// ray step multiplier\n    const float rayEpsi = 0.0001;\n\tfloat rayStep = 1.; // ray step length\n    float rayDist = 0.; // ray distance length\n\tfor (float i=0.; i<rayiMax; i++){\n\t\tvec3 p = co + rd *rayDist; // point in 3D worldspace\t        \n\t\tif (abs(rayStep)<rayEpsi || rayDist>rayDistMax) break;\n\t\trayStep = df(p).x;\n\t\trayDist += rayStep * rayF;\t\n\t}\n    \n\t//// World2Color-space\n    const vec3 ld = vec3(0.,1.,.5); // ligth direction\n    const vec3 lc = vec3(0.4); // ligth color\n    vec3 col;\n    vec3 sky = GetSky(rd, ld, lc);\n\t\n\tif (rayDist<rayDistMax)  // intersection with object\n\t{\n        vec3 p = co + rd * rayDist;\t     \n\t\tvec3 n = nor(p, 0.001);\t// compute normale\n\t\tvec4 mat = df(p);\n        // uv-coords\n        vec2 mat_uv;\n        mat_uv.x = atan(mat[2],mat[1])/PI;\n        mat_uv.y = mat[3]/PI;\n        // texture color\n        const float smoothness = 0.05; // TODO: (2) Calculation inside df()?\n\t\tcol.rgb = vec3(smoothstep(-smoothness,smoothness,cos(PI*mat_uv.x)*cos(PI*mat_uv.y)));                             \n\t\t// lighting\n\t\tfloat occ = calcAO( p, n );\n        float amb = clamp( 0.5+0.5*n.y, 0.0, 1.0 );\n        float dif = clamp( dot( n, ld ), 0.0, 1.0 ) * (df(p+n*1.16).x);\n        float spe = pow(clamp( dot( rd, ld ), 0.0, 1.0 ),16.0);\n        float sss = df(p - n*0.001).x/0.01;\n        // shading\t\n        dif *= softshadow( p, ld, 0.1, 1. );\n        vec3 brdf = vec3(0.0);\n        brdf += 0.5*dif*vec3(1.00,0.90,0.60);\n        brdf += 0.5*spe*vec3(0.8,0.60,0.20)*dif;\n        brdf += 0.3*amb*vec3(0.40,0.60,0.40)*occ;\n        brdf += 0.4;\n        col.rgb *= brdf;\n        // fog\n        col.rgb = mix( col.rgb, sky, 1.0-exp( -0.02*rayDist*rayDist ) ); \n\t}\n\telse\n\t{// no intersection => background\n\t\tcol.rgb = sky;\n\t}\n    \n    tot += col;\n            \n#ifdef AA\n    }\n    tot /= 4.;\n#endif\n    // gamma correction\n\tfragColor = vec4( sqrt(0.4*tot), 1.0 );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}