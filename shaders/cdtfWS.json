{
    "Shader": {
        "info": {
            "date": "1698500050",
            "description": "A keyframe-based 3D textured cube animation rendered in realtime.",
            "flags": 32,
            "hasliked": 0,
            "id": "cdtfWS",
            "likes": 85,
            "name": "Cube Animation",
            "published": 3,
            "tags": [
                "raymarching",
                "cube",
                "map",
                "animation",
                "bump",
                "material",
                "traversal"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 1087
        },
        "renderpass": [
            {
                "code": "/*\n\n    Cube Animation\n    --------------\n\n    See \"Buffer A\" for an explanation.\n\n*/\n\n\n\n\n// Just a very basic depth of field routine -- I find a lot of it is\n// common sense. Basically, you store the scene distance from the camera \n// in the fourth channel, then use it to determine how blurry you want\n// your image to be at that particular distance.\n//\n// For instance, in this case, I want pixels that are 2.5 units away from \n// the camera to be in focus (not blurred) and for things to get more \n// blurry as you move away from that point -- aptly named the focal point \n// for non camera people. :)\n//\n// I based this on old code of mine, but adopted things that I found in \n// IQ and Nesvi7's examples, which you can find here:\n//\n// Ladybug - IQ\n// https://www.shadertoy.com/view/4tByz3\n//\n// Cube surface II - Nesvi7\n// https://www.shadertoy.com/view/Mty3DV\n//\nvec3 DpthFld(sampler2D iCh, vec2 uv){\n\t\n    // Focal point and circle of confusion.\n    const float focD = 2.6, coc = .6;\n    // Linear distance from either side of the focal point.\n    float l = abs(texture(iCh, uv).w - focD - coc) - coc;\n    // Using it to calculate the DOF.\n    float dof = clamp(l/coc, 0., 2.); \n    \n    // Combine samples. Samples with a larger DOF value are taken further \n    // away from the original point, and as such appear blurrier.\n    vec3 acc = vec3(0);\n\n    for(int i = 0; i<25; i++){\n        // Accumulate samples.\n        acc += texture(iCh, uv + (vec2(i/5, i%5) - 2.)/vec2(800, 450)*dof).xyz;\n        //acc.x *= dof/2.;\n    }\n\n    // Return the new variably blurred value.\n    return acc /= 25.;\n    // Visual debug representation of DOF value.\n    //return vec3(length(dof)*450./2.5);\n}\n\n\n// Standard 2D rotation formula.\n//mat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Screen oordinates.\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 col = DpthFld(iChannel0, uv).xyzz;\n\n    // Retrieving the stored color.\n    //vec4 col = texture(iChannel0, uv);\n\n    // Subtle vignette.\n    //col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , 1./32.);\n\n    // Rough gamma correction and screen presentation.\n    fragColor = pow(max(col, 0.), vec4(1./2.2)); \n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\n    Cube Animation\n    --------------\n    \n    As the title says, this is a cube animation. :) This is not a Blender \n    quality rendering by any stretch of the imagination, but it does at least \n    convey that feel. I probably wouldn't recommend the realtime pixelshader \n    environment for producing these kinds of animations, but I wanted to show \n    that it was possible.\n    \n    The code in this particular example looks a little overblown, partly due to\n    the amount of \"define\" options I included. However, most of it is just an \n    application of a series of rudimentary tasks. At its core, this is a bunch\n    of grid cells containing some decorated cubes that follow an animated \n    pattern sequence. The flat shaded non-textured version with no compiler \n    options is much, much shorter. In fact, I might post that later.\n    \n    Rolling a cube along a floor in a straight line is a simple enough exercise. \n    If you're comfortable with 3D rotations about pivot points and keyframing, \n    then rolling it through four quadrants of a square floor cell requires just \n    a little more effort. Starting from random quadrants and direction changes \n    add some extra code but is also easy... Then there's texturing; That last \n    bit can take your nice neat code and turn it into a difficult-to-follow mess. :)\n\n    \n    \n\n\tSimilar examples:\n   \n\t// There are not a lot of rolling textured dice examples on Shadertoy, \n    // but here's one. \n    Dice Leaping - Dr2\n    https://www.shadertoy.com/view/3st3WS\n    \n    // Byt3_m3chanic puts together a lot of interesting examples.\n    Dice Game | Die Die Die - byt3_m3chanic\n    https://www.shadertoy.com/view/Nl23Rw\n    \n    // A die following a 3D path. Needs an overhaul. :)\n    Marching Die - Shane\n\thttps://www.shadertoy.com/view/3sVBDd\n \n\n*/\n\n\n// Max ray distance.\n#define FAR 20.\n\n////// Variable Defines /////\n\n// Scene color - White: 0, Primary Colors: 1, Green: 2, Pink and Purple: 3.\n#define COLOR 1\n\n// Cube pattern curve type.\n// Circle: 0, Square: 1, Diamond: 2, Octagon: 3, Dodecahedron: 4.\n#define CTYPE 3\n\n// Floor pattern curve type.\n// Circle: 0, Square: 1, Diamond: 2, Octagon: 3, Dodecahedron: 4.\n#define CTYPE2 3\n\n\n// Pattern Offset: Zero or One. Other numbers won't work.\n#define OFFS 0. // Only \"0.\" or \"1.\" will work.\n\n// Reverse the pattern.\n//#define REVERSE\n\n// Subdide the square cells, or not.\n#define SUBDIV\n\n// Surface displacement: No displacement, resulting in flat surfaces, bump mapping, \n// which is cheaper, but not quite as effective as the real thing, or distance\n// based displacement, which is more expensive but more convincing. \n//\n// The default settings are a compromise. I've displaced the cube the expensive\n// way, and the floor the cheap way, since there wasn't a discernible difference.\n//\n// No displacement: 0, Bump map: 1, Distance map: 2\n#define SURF_DISP_CUBE 2\n#define SURF_DISP_FLOOR 1\n\n// Global scene object scale. Kind of redundant here, considering the\n// eventual scale I chose... All that extra work for nothing. :)\n#define GSCALE 1.\n\n/////////////////////\n\n\n// Scene object ID to separate the mesh object from the terrain.\nfloat svObjID, objID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n\n \n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21(vec2 f){\n\n    // The first line relates to ensuring that icosahedron vertex identification\n    // points snap to the exact same position in order to avoid hash inaccuracies.\n    uvec2 p = floatBitsToUint(f);\n    p = 1664525U*(p>>1U^p.yx);\n    return float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU);\n}\n\n// IQ's \"uint\" based uvec3 to float hash.\nfloat hash31(vec3 f){\n\n    uvec3 p = floatBitsToUint(f);\n    p = 1103515245U*((p >> 2U)^(p.yzx>>1U)^p.zxy);\n    uint h32 = 1103515245U*(((p.x)^(p.y>>3U))^(p.z>>6U));\n\n    uint n = h32^(h32 >> 16);\n    return float(n & uint(0x7fffffffU))/float(0x7fffffff);\n    \n}\n\n\n// Tri-Planar blending function: Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D tex, in vec3 p, in vec3 n){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. :)\n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n// Cube face texturing -- Hacked together quickly, but it'll work.\nvec3 texCube(sampler2D iCh, in vec3 p, in vec3 n){\n\n    \n    // Use the normal to determine the face. Z facing normals \n    // imply the XY plane, etc.\n    n = abs(n);\n    p.xy = n.x>.5? p.yz : n.y>.5? p.xz : p.xy; \n    \n    // Reusing \"p\" for the color read.\n    p = texture(iCh, p.xy).xyz;\n \n    // Rough conversion from sRGB to linear.\n    return p*p;\n\n}\n\n\n\n// Texture sample.\n//\nvec3 getTex(sampler2D iCh, vec2 p){\n    \n    // Strething things out so that the image fills up the window. You don't need to,\n    // but this looks better. I think the original video is in the oldschool 4 to 3\n    // format, whereas the canvas is along the order of 16 to 9, which we're used to.\n    // If using repeat textures, you'd comment the first line out.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(iCh, p/8.).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n// Height map value, which is just the pixel's greyscale value.\nfloat hm(in vec2 p, in vec3 sc){ \n    return sc.z/2.;\n    //return dot(getTex(iChannel0, p), vec3(.299, .587, .114)); \n}\n\n\n//////////\n// Cube mapping - Adapted from one of Fizzer's routines. \nvec4 cubeMap(vec3 p){\n\n    // Elegant cubic space stepping trick, as seen in many voxel related examples.\n    vec3 f = abs(p); f = step(f.zxy, f)*step(f.yzx, f); \n\n    /*\n    vec3 idF = step(0., p)*2. - 1.;\n    vec3 faceID = (idF + 1.)/2. + vec3(0, 2, 4);\n    */    \n    \n    // Integer version.\n    ivec3 idF = ivec3(step(0., p))*2 - 1;\n    ivec3 faceID = (idF + 1)/2 + ivec3(0, 2, 4);\n    \n    \n    return f.x>.5? vec4(p.yz/p.x, idF.x, faceID.x) : \n           f.y>.5? vec4(p.xz/p.y, idF.y, faceID.y) : vec4(p.xy/p.z, idF.z, faceID.z); \n}\n\nfloat dist(vec2 p, int type){\n\n    \n    if(type == 0) return length(p); // Circle.\n\n    p = abs(p);\n    if(type == 1) return max(p.x, p.y); // Square.\n    if(type == 2) return abs(p.x + p.y)*.7071; // Diamond.\n    if(type == 3) return max(max(p.x, p.y), abs(p.x + p.y)*.7071); // Octagon.\n    if(type == 4){    \n        // Dodecahedron.\n        vec2 p2 = p*.8660254 + p.yx*.5;\n        p = vec2(max(p2.x, p2.y), max(p.y, p.x));\n        return max(p.x, p.y);\n    }\n}\n\n// lev: Cube level. A value of 1 means its been subdivided.\nfloat getPat(vec2 p, vec2 sc, vec2 id, float fID, int type, int sm){\n   \n   //p *= 2.;\n   \n   //p *= GSCALE;  \n   \n \n   sc *= 2.;\n   //if(sm==0) sc /=2.;\n   \n   vec2 oID = floor(p/(sc/2.));\n   \n    \n   id = id + floor(p/(sc/2.))/2.;\n   p = mod(p, sc/2.) - sc/4.;\n   sc/=2.; \n   \n  \n   \n   id += fID/12.;\n    \n  \n   float rnd = hash21(id + .06);\n   if(rnd<.5) p = rot2(3.14159/2.)*p;\n\n   float tF = type == 2? .7071 : 1.;\n   float d = dist(p - sc/2., type) - sc.x/2.*tF;\n   d = min(d, dist(p + sc/2., type) - sc.x/2.*tF);\n   \n   //float d = abs(p.x + p.y)*.7071;\n   //float d = length(p - (vec2(hash21(id + .1), hash21(id + .2)) - .5)*sc/4.);\n   \n   if(mod(oID.x + oID.y, 2.)<.5) d = -d;\n   if(rnd<.5) d = -d;\n\n   \n   // Extra pattern flipping for the small cubes. The large has four Truchet\n   // blocks per face, so doesn't need this.\n   if(sm==1) if(mod(fID, 2.)==1.) d = -d;\n\n   return d;\n\n}\n/////////////////\n\n\n\n// IQ's 3D signed box formula: I tried saving calculations by using the unsigned one, and\n// couldn't figure out why the edges and a few other things weren't working. It was because\n// functions that rely on signs require signed distance fields... Who would have guessed? :D\nfloat sBoxS(vec3 p, vec3 b, float sf){\n\n  p = abs(p) - b + sf;\n  return min(max(p.x, max(p.y, p.z)), 0.) + length(max(p, 0.)) - sf;\n}\n\n\n\n// Subdivided rectangle grid.\nvec4 getGrid(vec2 p, inout vec2 sc){\n    \n    // Block offsets.\n    vec2 ipOffs = vec2(0);\n    // Row or column offset. Values like \"1/3\" would offset more\n    // haphazardly, but I wanted to maintain a little symmetry.\n    /*\n    const float offDst = .25; \n    if(mod(floor(p.y/sc.y), 2.)<.5){\n        p.x -= sc.x*offDst; // Row offset.\n        ipOffs.x += offDst;\n    }\n    */\n    /*\n    if(mod(floor(p.x/sc.x), 2.)<.5){\n        p.y -= sc.y*offDst; // Column offset.\n        ipOffs.y += offDst;\n    }\n    /*\n    float ii = floor(p.y/sc.y);\n    float offDst = mod(ii, 4.)/4.; \n    p.x -= sc.x*offDst; // Row offset.\n    ipOffs.x += offDst;\n    */\n    \n         \n    // Current block ID.\n    vec2 ip = floor(p/sc) + .5;\n    \n    #ifdef SUBDIV\n    // Random subdivision.\n    if(hash21(ip + .253)<.333){\n       sc /= 2.;\n       ip = floor(p/sc) + .5; \n    }\n    #endif\n    \n    // Local coordinates and cell ID.\n    return vec4(p - ip*sc, (ip + ipOffs)*sc);\n\n}\n\n// Global cell boundary distance variables.\nvec3 gDir; // Cell traversing direction.\nvec3 gRd; // Ray direction.\nfloat gCD; // Cell boundary distance.\n// Box dimension and local XY coordinates.\nvec3 svSc, gSc; \nvec3 svP, gP;\n\n\n\n// Global overall position matrix.\nmat3 svM3, m3;\n\n// Total running time, tmID, and time segment.\nfloat tmTotal, tmID, tmSeg;\n\nmat3 aM3[12];\n\n// Quater rotation matrices around the X and Y axes.\nconst float ca = cos(3.14159/2.), sa = sin(3.14159/2.);\nconst mat3 mRYZ = mat3(1, 0, 0, 0, ca, sa, 0, -sa, ca);\nconst mat3 mRXZ = mat3(ca, 0, sa, 0, 1, 0, -sa, 0, ca);   \nconst mat3 mRYZN = mat3(1, 0, 0, 0, ca, -sa, 0, sa, ca);\nconst mat3 mRXZN = mat3(ca, 0, -sa, 0, 1, 0, sa, 0, ca); \n\n\nvoid posMat(){\n    \n    // Indentity matrix;\n    m3 = mat3(1, 0, 0, 0, 1, 0, 0, 0, 1);\n\n    // All 12 starting position matrices. If you were looping from\n    // last position to first, you'd need the inverse matrices:\n    // \"m3 *= inverse(A), or m3 = m3*A\".\n    for(int i=0; i<=11; i++){\n          \n        int iM4 = i&3;\n        if(iM4==3) m3 *= mRXZ;\n        else if(iM4==2) m3 *= mRYZ;\n        else if(iM4==1) m3 *= mRXZN;\n        else if(iM4==0) m3 *= mRYZN;\n        \n        aM3[i] = m3;\n    } \n}\n\n\n\n \n// An extruded subdivided rectangular block grid. Use the grid cell's \n// center pixel to obtain a height value (read in from a height map), \n// then render a pylon at that height.\n\nvec4 blocks(vec3 q3){\n    \n \n    // Local coordinates.\n    vec2 p = q3.xy;\n\n\n    vec3 sc = vec3(GSCALE); // Scale.\n    // Local coordinates and cell ID.\n    vec4 p4 = getGrid(p, sc.xy); \n    p = p4.xy;\n    vec2 id = p4.zw;\n    \n    sc.z = sc.y;\n\n\n    // The distance from the current ray position to the cell boundary\n    // wall in the direction of the unit direction ray. This is different\n    // to the minimum wall distance, so you need to trace out instead\n    // of merely doing a box calculation. Anyway, the following are pretty \n    // standard cell by cell traversal calculations. The resultant cell\n    // distance, \"gCD\", is used by the \"trace\" and \"shadow\" functions to \n    // restrict the ray from overshooting, which in turn restricts artifacts.\n    vec3 rC = (gDir*sc - vec3(p, q3.z))/gRd;\n    //vec2 rC = (gDir.xy*sc.xy - p)/gRd.xy; // For 2D, this will work too.\n    \n    // Minimum of all distances, plus not allowing negative distances, which\n    // stops the ray from tracing backwards... I'm not entirely sure it's\n    // necessary here, but it stops artifacts from appearing with other \n    // non-rectangular grids.\n    //gCD = max(min(min(rC.x, rC.y), rC.z), 0.) + .0015;\n    gCD = max(min(rC.x, rC.y), 0.) + .0015; // Adding a touch to advance to the next cell.\n\n\n    // The extruded block height. See the height map function, above.\n    float h = hm(id, sc);\n    //h = (h*.975 + .025)*2.5;\n\n\n    // Change the prism rectangle scale just a touch to create some subtle\n    // visual randomness. You could comment this out if you prefer more order.\n    //sc.xy -= .05;//*(hash21(id)*.9 + .1);\n\n    // Lower box prism.\n    vec3 bxSc = sc/2. - .01;\n    vec3 q = vec3(p, q3.z + h/2.);\n    \n    vec3 svQ = q;\n    \n     \n    \n    // Keyframing: This breaks time into 12 equal segments lasting one second each.\n    // The time is also offset, depending on what cell the object is in.\n     \n    tmTotal = iTime + hash21(id + .17)*.25; // Moving slightly out of sync.\n    tmID = floor(tmTotal);\n    // Fractional time segment: Same as fract(tmTotal).\n    float fTm = tmTotal - tmID; // Range: [0. 1].\n    \n    tmSeg = mod(tmID + floor(hash21(id)*72.), 12.);//  + floor(hash21(grd.zw)*72.)\n\n    //posMat(tmSeg);\n    \n    // Using smoothstep to smoothly interpolate the time period between\n    // zero and one.\n    fTm = smoothstep(.25, .75, fTm);\n    \n    float ang;\n    \n    float reverse = hash21(id + .17)<.5? -1. : 1.;\n    \n    mat4x2 v = mat4x2(vec2(-1, 1), vec2(1), vec2(1, -1), vec2(-1));\n \n    // If traversing the quadrants in the reverse order, reverse the\n    // quadrant postions.\n    if(reverse<0.) v = mat4x2(vec2(-1, 1),  vec2(-1), vec2(1, -1), vec2(1));\n    \n \n    float tmSegM4 = mod(tmSeg, 4.);\n    \n    mat3 mA = mat3(1, 0, 0, 0, 1, 0, 0, 0, 1);\n       \n    for(int i=0; i<12; i++){\n     \n        if(tmSegM4 == float(i)){\n            \n            // Move to quadrant.\n            int j = i&3;\n            //int jp1 = (j + 1)&3;\n            q.xy -= v[j]*bxSc.xy/2.;\n\n            // The first rotation involves pivoting about the positive-Z, \n            // positive-X edge by 90 degrees in the counter clockwise direction.\n            ang = mix(0., -3.14159/2., fTm); // 90 degrees CCW.\n            vec2 piv = vec2(1); // Positive XZ edge.\n            if(j==1 || j==2){ ang = -ang; piv = vec2(-1, 1); }//piv = vec2(-1, 1);\n\n            // Reverse the angles, pivot points and XZ-YZ order, if going in reverse.\n            int YZFirst = 0;\n            if(reverse<0.){\n               piv.x = -piv.x;\n               ang = -ang;\n               YZFirst = 1;\n            }\n\n            // Pivot rotation matrix.\n            float cr = cos(ang), sr = sin(ang);\n            \n         \n            if((i&1)==YZFirst){\n                \n                // XZ pivot rotation matrix.\n                mA = mat3(cr, 0, sr, 0, 1, 0, -sr, 0, cr); \n            \n                // Left and right pivots. In particular, pivoting from quadrant\n                // zero to one, then back the other way from two to three.\n                //\n                q.xz -= piv*bxSc.xz/2.; // Move to the pivot point.\n                q = mA*q; // Rotation about the pivot point.\n                q.xz += piv*bxSc.xz/2.; // Move back to the center of rotationn.\n \n            \n            }\n            else {\n            \n                // YZ pivot rotation matrix.\n                mA = mat3(1, 0, 0, 0, cr, sr, 0, -sr, cr); \n            \n          \n                // Up and down pivots. In particular, pivoting from quadrant\n                // one to two, then back the other way from three to zero..\n                q.yz -= piv*bxSc.yz/2.;                  \n                q = mA*q;\n                q.yz += piv*bxSc.yz/2.;\n             \n            } \n \n            \n            break;\n        }\n    }\n\n    \n    // Set the global matrix to the correct position matrix.\n    // If we're reversing direction, reverse the indices... whilst\n    // accounting for the zero position staying the same... Sigh.\n    // I much prefer vertex\\UV, etc., pipelines when it comes to\n    // texturing. :)\n    int index = int(tmSeg);\n    m3 = reverse<0.? aM3[(12 - index)%12] : aM3[index];\n    \n    // Apply the precalculated position matrix to the current cell position.\n    q = m3*q;\n    \n    // Adding the pivot matrix to the stored position matrix. The pivot was \n    // already added to the position \"q\" above, but hasn't yet been added to\n    // the position matrix that is used for normal rotation.\n    m3 = m3*mA;\n \n    float d = sBoxS(q, bxSc/2., sqrt(bxSc.x)*.03);\n    /*\n    float ew = .02;\n    float edge = max(d, -sBoxS(q.xy, bxSc.xy/2. - ew, 0.));\n    edge = max(edge, -sBoxS(q.xz, bxSc.xz/2. - ew, 0.));\n    edge = max(edge, -sBoxS(q.yz, bxSc.yz/2. - ew, 0.));\n   \n    d += ew;\n    */\n    float edge = 1e5;\n\n \n    // Saving the box dimensions and local coordinates.\n    gSc = sc;//vec3(sc.xy, h);\n \n    gP = q;\n\n        \n   \n    // Return the distance, position-base ID and box ID.\n    return vec4(d, id, edge);\n}\n\n\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec4 svGID, gID;\n\n// The extruded image.\nfloat map(vec3 p){\n    \n    // Floor.\n    float fl = -p.z;\n\n    // The extruded blocks.\n    vec4 d4 = blocks(p);\n    gID = d4; // Individual block ID.\n    \n////////////// \n\n    // Using the Truchet pattern to displace the cube and\n    // floor surfaces.\n    \n    int type;\n    float tF, th, pat;\n    #if SURF_DISP_CUBE == 2\n    \n    vec3 txP = gP;\n\n    vec4 q3 = cubeMap(txP);\n    float faceID = q3.w;\n\n    type = CTYPE;\n    vec2 offs = vec2(.5*OFFS);\n    vec2 sc = gSc.xy/GSCALE;\n    int lev = 0;\n    if(gSc.x==GSCALE/2.){ offs += 1. + .5*OFFS; sc *= 4.; lev = 1; }\n    //else if(sc.x==GSCALE/4.){ sc *= 8.; lev = 2; }//offs += sc/2.; \n    pat = getPat(q3.xy + offs, sc, gID.yz, faceID, type, lev);\n\n    tF = type == 2? .7071 : 1.;\n    th = .1*tF;//*sc.x/GSCALE*2.5;\n    if(offs.x>.01) th *= 2.;\n    //if(lev==2) th *= 4.;\n    pat = min(pat + th*1.5, abs(pat - th) - th);\n    #ifndef REVERSE\n    pat = -pat;\n    #endif  \n\n    //d4.x -= smoothstep(0., .1, min((pat + th/4.)*2., th))*.01 - .005;\n    d4.x -= smoothstep(0., th, pat + th*.65)*.01 - .005;\n    //d4.x -= smoothstep(0., th, pat + th*.5)*.01 - .005;\n    \n    #endif\n/////////////////\n \n    #if SURF_DISP_FLOOR == 2\n    type = CTYPE2;\n            \n    vec2 scl = vec2(GSCALE/2.);\n    vec2 q = p.xy;\n    if(type==1) q += scl/4.; // Move the pattern half a small cell for squares.\n    vec2 ip = (floor(q/scl) + .5)*scl;\n    // Grid color squares.\n    vec2 ip2 = floor(q/scl*4. + .5);\n    // Grid local coordinates and ID.\n    vec4 grd = vec4(q - ip, ip);\n \n\n    pat = getPat(grd.xy, scl/2., grd.zw, 0., type, 0);\n    tF = type == 2? .7071 : 1.;\n    #ifdef REVERSE\n    th = .015*tF*GSCALE;\n    #else\n    th = .05*tF*GSCALE;\n    #endif\n    \n    pat = min(pat + th*1.5, abs(pat - th) - th);\n    #ifdef REVERSE\n    pat = -pat;\n    #endif\n    \n    fl -= smoothstep(0., th/2., pat + th/4.)*.005 - .0025;\n    //fl -= smoothstep(0., .1, min((pat + th/4.)*2., th))*.01 - .005;\n     \n    #endif\n    \n///////////////// \n    // Overall object ID.\n    objID = d4.x<d4.w && d4.x<fl? 0. : d4.w<fl? 1. : 2.;\n    \n    // Combining the floor with the extruded image\n    return  min(min(d4.x, d4.w), fl);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float d, t = 0.;//hash31(ro + rd)*.05;\n    \n    //vec2 dt = vec2(1e5, 0); // IQ's clever desparkling trick.\n    \n    // Set the global ray direction varibles -- Used to calculate\n    // the cell boundary distance inside the \"map\" function.\n    gDir = sign(rd)*.5;\n    gRd = rd; \n    \n    int i;\n    const int iMax = 128;\n    for (i = min(iFrame, 0); i<iMax; i++){ \n    \n        d = map(ro + rd*t);       \n        //dt = d<dt.x? vec2(d, dt.x) : dt; // Shuffle things along.\n        \n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, \n        // as \"t\" increases. It's a cheap trick that works in most situations.\n        if(abs(d)<.001 || t>FAR) break; \n        \n        //t += i<32? d*.75 : d; \n        t += min(d*.9, gCD); \n    }\n    \n    // If we've run through the entire loop and hit the far boundary, \n    // check to see that we haven't clipped an edge point along the way. \n    // Obvious... to IQ, but it never occurred to me. :)\n    //if(i>=iMax - 1) t = dt.y;\n\n    return min(t, FAR);\n}\n\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 normal(in vec3 p) {\n\t\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map\n    //                      map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with \n// limited iterations is impossible... However, I'd be very grateful if someone could \n// prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not always affordable. :)\n    const int maxIterationsShad = 64; \n    \n    ro += n*.0015; // Coincides with the hit condition in the \"trace\" function.\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n    \n    // Set the global ray direction varibles -- Used to calculate\n    // the cell boundary distance inside the \"map\" function.\n    gDir = sign(rd)*.5;\n    gRd = rd;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. \n    // Obviously, the lowest number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        \n        \n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), \n        // dist += clamp(h, .01, stepDist), etc.\n        t += clamp(min(d*.9, gCD), .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Shadow.\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 2., occ = 0.;\n    for(int i = 0; i<5; i++){\n    \n        float hr = float(i + 1)*.125/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);    \n    \n}\n\n\n// Surface bump function..\nfloat bumpSurf3D(in vec3 p, in vec3 n){\n\n    \n    \n    float bump = 0.;\n    \n    \n    #if SURF_DISP_CUBE == 1\n    if(svObjID==0.){\n        \n       \n        vec3 txP = p;   \n\n        vec4 q3 = cubeMap(txP);\n        float faceID = q3.w;\n\n        int type = CTYPE;\n        vec2 offs = vec2(.5*OFFS);\n        vec2 sc = svSc.xy/GSCALE;\n        int lev = 0;\n        if(gSc.x==GSCALE/2.){ offs += 1. + .5*OFFS; sc *= 4.; lev = 1; }\n        //else if(sc.x==GSCALE/4.){ sc *= 8.; lev = 2; }//offs += sc/2.; \n        float pat = getPat(q3.xy + offs, sc, svGID.yz, faceID, type, lev);\n\n        float tF = type == 2? .7071 : 1.;\n        float th = .1*tF;//*sc.x/GSCALE*2.5;\n        if(offs.x>.01) th *= 2.;\n        //if(lev==2) th *= 4.;\n        pat = min(pat + th*1.5, abs(pat - th) - th);\n        #ifndef REVERSE\n        pat = -pat;\n        #endif   \n        \n        \n        /*\n        map(p);\n        vec3 txP = gP;//p;   \n\n        vec4 q3 = cubeMap(txP);\n        float faceID = q3.w;\n\n        int type = CTYPE;\n        vec2 offs = vec2(.5*OFFS);\n        vec2 sc = gSc.xy/GSCALE;\n        int lev = 0;\n        if(gSc.x==GSCALE/2.){ offs += 1. + .5*OFFS; sc *= 4.; lev = 1; }\n        //else if(sc.x==GSCALE/4.){ sc *= 8.; lev = 2; }//offs += sc/2.; \n        float pat = getPat(q3.xy + offs, sc, gID.yz, faceID, type, lev);\n\n        float tF = type == 2? .7071 : 1.;\n        float th = .1*tF;//*sc.x/GSCALE*2.5;\n        if(offs.x>.01) th *= 2.;\n        //if(lev==2) th *= 4.;\n        pat = min(pat + th*1.5, abs(pat - th) - th);\n        #ifndef REVERSE\n        pat = -pat;\n        #endif \n        */\n\n \n        bump = smoothstep(0., th, pat + th*.65)*.01;\n        //bump = smoothstep(0., .1, min((pat + th/4.)*2., th));    \n    \n    \n    }\n    #endif\n    \n    #if SURF_DISP_FLOOR == 1\n    if(svObjID==2.){\n    \n        int type = CTYPE2;\n\n        vec2 scl = vec2(GSCALE/2.);\n        vec2 q = p.xy;\n        if(type==1) q += scl/4.; // Move the pattern half a small cell for squares.\n        vec2 ip = (floor(q/scl) + .5)*scl;\n        // Grid color squares.\n        vec2 ip2 = floor(q/scl*4. + .5);\n        // Grid local coordinates and ID.\n        vec4 grd = vec4(q - ip, ip);\n\n\n        float pat = getPat(grd.xy, scl/2., grd.zw, 0., type, 0);\n        float tF = type == 2? .7071 : 1.;\n        #ifdef REVERSE\n        float th = .015*tF*GSCALE;\n        #else\n        float th = .05*tF*GSCALE;\n        #endif\n\n        pat = min(pat + th*1.5, abs(pat - th) - th);\n        #ifdef REVERSE\n        pat = -pat;\n        #endif\n\n\n        bump = smoothstep(0., th/2., pat + th/4.)*.005;\n        //bump = smoothstep(0., .1, min((pat + th/4.)*2., th))*.01;\n    }\n    #endif\n    \n    return bump;\n\n}\n\n\n \n// Standard function-based bump mapping routine: This is the cheaper four tap version. \n// There's a six tap version (samples taken from either side of each axis), but this \n// works well enough.\nvec3 doBumpMap(in vec3 p, in vec3 n, float bumpfactor){\n    \n    // Larger sample distances give a less defined bump, but can sometimes lessen the \n    // aliasing.\n    const vec2 e = vec2(.001, 0);  \n    \n    // Bump mapping the moving cube surface requires some transformations\n    // prior to performing the calculations. It's annoying to code, but worth\n    // it, since it is way faster than displacing the surface inside the \n    // raymarched distance function.\n    vec3 v0 = e.xyy;\n    vec3 v1 = e.yxy;\n    vec3 v2 = e.yyx;\n    \n    if(svObjID==0.){\n       p = svP;\n       v0 = svM3*v0;\n       v1 = svM3*v1;\n       v2 = svM3*v2; \n       \n    } \n    \n    \n    \n    mat4x3 p4 = mat4x3(p, p - v0, p - v1, p - v2);\n    //mat4x3 p4 = mat4x3(p, p - e.xyy, p - e.yxy, p - e.yyx);\n    \n    // This utter mess is to avoid longer compile times. It's kind of \n    // annoying that the compiler can't figure out that it shouldn't\n    // unroll loops containing large blocks of code.\n \n    vec4 b4;\n    for(int i = min(iFrame, 0); i<4; i++){\n        b4[i] = bumpSurf3D(p4[i], n);\n        if(n.x>1e5) break; // Fake break to trick the compiler.\n    }\n    \n    // Gradient vector: vec3(df/dx, df/dy, df/dz);\n    vec3 grad = (b4.yzw - b4.x)/e.x; \n   \n    \n    // Six tap version, for comparisson. No discernible visual difference, in a lot of \n    //cases.\n    //vec3 grad = vec3(bumpSurf3D(p - e.xyy) - bumpSurf3D(p + e.xyy),\n    //                 bumpSurf3D(p - e.yxy) - bumpSurf3D(p + e.yxy),\n    //                 bumpSurf3D(p - e.yyx) - bumpSurf3D(p + e.yyx))/e.x*.5;\n    \n  \n    // Adjusting the tangent vector so that it's perpendicular to the normal. It's some \n    // kind of orthogonal space fix using the Gram-Schmidt process, or something to that \n    // effect.\n    grad -= n*dot(n, grad);          \n         \n    // Applying the gradient vector to the normal. Larger bump factors make things more \n    // bumpy.\n    return normalize(n + grad*bumpfactor);\n\t\n}\n\n///////////////////////////\n\n\n// Microfaceted normal distribution function.\nfloat D_GGX(float NoH, float roughness) {\n    float alpha = pow(roughness, 4.);\n    float b = (NoH*NoH*(alpha - 1.) + 1.);\n    return alpha/(3.14159265*b*b);\n}\n\n// Surface geometry function.\nfloat G1_GGX_Schlick(float NoV, float roughness) {\n    //float r = roughness; // original\n    float r = .5 + .5*roughness; // Disney remapping.\n    float k = (r*r)/2.;\n    float denom = NoV*(1. - k) + k;\n    return max(NoV, .001)/denom;\n}\n\nfloat G_Smith(float NoV, float NoL, float roughness) {\n    float g1_l = G1_GGX_Schlick(NoL, roughness);\n    float g1_v = G1_GGX_Schlick(NoV, roughness);\n    return g1_l*g1_v;\n}\n\n// Bidirectional Reflectance Distribution Function (BRDF). \n//\n// If you want a quick crash course in BRDF, see the following:\n// Microfacet BRDF: Theory and Implementation of Basic PBR Materials\n// https://www.youtube.com/watch?v=gya7x9H3mV0&t=730s\n//\nvec3 BRDF(vec3 col, vec3 n, vec3 l, vec3 v, \n          float type, float rough, float fresRef){\n     \n  vec3 h = normalize(v + l); // Half vector.\n\n  // Standard BRDF dot product calculations.\n  float nv = clamp(dot(n, v), 0., 1.);\n  float nl = clamp(dot(n, l), 0., 1.);\n  float nh = clamp(dot(n, h), 0., 1.);\n  float vh = clamp(dot(v, h), 0., 1.);  \n\n  \n  // Specular microfacet (Cook- Torrance) BRDF.\n  //\n  // F0 for dielectics in range [0., .16] \n  // Default FO is (.16 * .5^2) = .04\n  // Common Fresnel values, F(0), or F0 here.\n  // Water: .02, Plastic: .05, Glass: .08, Diamond: .17\n  // Copper: vec3(.95, .64, .54), Aluminium: vec3(.91, .92, .92), Gold: vec3(1, .71, .29),\n  // Silver: vec3(.95, .93, .88), Iron: vec3(.56, .57, .58).\n  vec3 f0 = vec3(.16*(fresRef*fresRef)); \n  // For metals, the base color is used for F0.\n  f0 = mix(f0, col, type);\n  vec3 F = f0 + (1. - f0)*pow(1. - vh, 5.);  // Fresnel-Schlick reflected light term.\n  // Microfacet distribution... Most dominant term.\n  float D = D_GGX(nh, rough); \n  // Geometry self shadowing term.\n  float G = G_Smith(nv, nl, rough); \n  // Combining the terms above.\n  vec3 spec = F*D*G/(4.*max(nv, .001));\n  \n  \n  // Diffuse calculations.\n  vec3 diff = vec3(nl);\n  diff *= 1. - F; // If not specular, use as diffuse (optional).\n  diff *= (1. - type); // No diffuse for metals.\n\n  \n  // Combining diffuse and specular.\n  // You could specify a specular color, multiply it by the base\n  // color, or multiply by a constant. It's up to you.\n  return (col*diff + spec*3.14159265);\n  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.    \n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 ro = vec3(iTime/4. - .5, 0, -3); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(.0, .1, .25);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positioning.\n    vec3 lp = ro + vec3(1.5, 2, 0);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/3.; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x ));\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    //vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    // Rotation.\n \trd.xy *= rot2(.2); \n    \n    /*    \n    // Mouse camera movement.\n    if(iMouse.z>1.){\n        rd.yz *= rot2(-.5*(iMouse.y - iResolution.y*.5)/iResolution.y*3.1459);  \n        rd.xz *= rot2(-.25*(iMouse.x - iResolution.x*.5)/iResolution.x*3.1459);\n    }\n    */\n \n    \n    // Calculate all 12 matrix positions.\n    posMat();\n \n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the block ID and object ID.\n    svGID = gID;\n    \n    // Scene object ID. Either the pylons or the floor.\n    svObjID = objID;\n    \n    // Saving the bloxk scale and local 2D base coordinates.\n    svSc = gSc;\n    svP = gP;\n\n    // Saving the 3D orientation matrix.\n    svM3 = m3;\n   \n    \n\t\n    // Initiate the scene color to black.\n    vec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = normal(sp);\n        \n        // Bump mapping the surface.\n        #if (SURF_DISP_CUBE == 1) || (SURF_DISP_FLOOR == 1)\n        sn = doBumpMap(sp, sn, 1.);\n        #endif\n        \n        // Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n        \n        \n                \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 16.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 2./(1. + lDist*.125);\n    \t\n        \n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd), 0.), 16.); \n           \n        // Obtaining the texel color. \n\t    vec3 objCol; \n        \n\n        // Combining the above terms to procude the final color.\n        float matType = 0.; // Dielectric.\n        float reflectance = .5;\n        float roughness = .5;\n        \n        //float toneF = .0; // Grey toning. Not used.\n        \n        vec3 shade = vec3(.9, .95, 1); // Metal color shading.\n\n        // The boxes and edging.\n        if(svObjID<1.5){\n            \n \n            \n            \n            // Texture and normal. The texture position has been saved from \n            // the distance field. The normal position also needs to be \n            // rotated to the correct position.\n            vec3 txP = svP;\n            vec3 txN = svM3*sn;\n\n            // Cubemap texturing.\n            vec4 q3 = cubeMap(txP);\n            float faceID = q3.w; // Face ID.\n            // Cube texture.\n            vec3 tx = texCube(iChannel1, txP*1. + .5*0., txN);\n \n\n            // Coloring.\n            float cRnd = hash21(svGID.yz);\n            #if COLOR == 2\n            vec3 lCol = .5 + .45*cos(6.2831589*cRnd/6. + vec3(0, 1, 2).yxz*1.1 + .5);\n            #else\n            vec3 lCol = .5 + .45*cos(6.2831589*cRnd/6. + vec3(0, 1, 2)*1.25);\n            #endif\n\n            // Random grid cell number.\n            cRnd = hash21(svGID.yz + .21);\n\n            // Alternate coloring.\n            #if COLOR == 3\n            lCol = lCol.xzy;\n            if(cRnd<.5) lCol = lCol.zyx;\n            #else\n            if(cRnd<.35) lCol = lCol.zyx;\n            #endif\n   \n       \n            \n            // Running a diffuse gradient effect over the result.\n            #if COLOR == 3\n            lCol = mix(lCol, lCol.xzy, spec*.1);\n            #else\n            lCol = mix(lCol, lCol.zyx, spec*.125);\n            #endif\n            \n            // White.\n            #if COLOR == 0\n            lCol = vec3(.9)*dot(lCol, vec3(.299, .587, .114));\n            #endif\n           \n            #if COLOR == 2 || COLOR == 3\n            lCol *= sqrt(lCol);\n            #else\n            lCol *= lCol*1.5; \n            #endif\n  \n            // Color tweaking.\n            lCol /= 1./3. + dot(lCol, vec3(.299, .587, .114));\n            lCol *= (tx*2. + .5)*1.5;\n            \n            \n            \n            // Edge coloring. Not used here.\n            //if(svObjID>.5) objCol = vec3(.1);\n                      \n \n            // Using the cube face coordinates to calculate the cube pattern.\n            int type = CTYPE;\n            vec2 offs = vec2(.5*OFFS);\n            vec2 sc = svSc.xy/GSCALE;\n            int lev = 0;\n            if(svSc.x==GSCALE/2.){ offs += 1. + .5*OFFS; sc *= 4.; lev = 1; }\n            //else if(sc.x==GSCALE/4.){ sc *= 8.; lev = 2; }//offs += sc/2.; \n            float pat = getPat(q3.xy + offs, sc, svGID.yz, faceID, type, lev);\n             \n            float oPat = pat;\n            float tF = type == 2? .7071 : 1.;\n            float th = .1*tF;//*sc.x/GSCALE*2.5;\n            if(offs.x>.01) th *= 2.;\n            //if(lev==2) th *= 4.;\n            pat = min(pat + th*1.5, abs(pat - th) - th);\n            //pat = min(pat + th*1.5, abs(pat - th) - th);\n            #ifndef REVERSE\n            pat = -pat;\n            #endif\n            \n            // Appling the colors, shade, pattern and lines. -- Standard stuff.\n            objCol = vec3(1)*shade;\n            objCol *= tx*2. + .05;\n  \n            // The metallic part of the pattern.\n            objCol = mix(objCol*.75, objCol*.375, 1. - smoothstep(0., .015, pat));\n            \n            // Grey factor - Not used here.\n            //objCol = mix(objCol, vec3(1)*dot(objCol, vec3(.299, .587, .114)), toneF);\n        \n            // Reverse pattern option.\n            #ifdef REVERSE\n            objCol = mix(objCol, lCol, 1. - smoothstep(0., .015, -oPat + th*2.));\n            #else\n            objCol = mix(objCol, lCol, 1. - smoothstep(0., .015, oPat + th*1.5));\n            #endif\n\n            // Dark lines.\n            objCol = mix(objCol, objCol*.25, \n                         1. - smoothstep(0., .015, abs(pat + .03) - .015));\n             \n             \n            // Metal or dielectric material, depending on the section of the\n            // pattern we're in.\n            matType = mix(1., 0.,  1. - smoothstep(0., .02, oPat + th*1.5));\n           \n             \n            // Roughness factor: More for the metal.\n            float rghF = mix(2.5, 1.,  1. - smoothstep(0., .02, oPat + th*1.5));\n            // Adding texture-based roughness.\n            roughness = min(dot(tx*rghF, vec3(.299, .587, .114)), 1.);\n            reflectance = .5; // Reflectance.\n            \n \n        }\n        else {\n            \n            // The dark floor in the background. Hidden behind the pylons, but\n            // you still need it.\n            vec2 txP = sp.xy;\n            vec3 tx = getTex(iChannel1, txP*4. + .5);\n\n\n            // Background floor pattern.\n            \n            int type = CTYPE2;\n            vec2 scl = vec2(GSCALE/2.);\n            vec2 q = sp.xy;\n            if(type==1) q += scl/4.; // Move the pattern half a small cell for squares.\n            vec2 ip = (floor(q/scl) + .5)*scl;\n            // Grid color squares.\n            vec2 ip2 = floor(q/scl*4. + .5);\n            // Grid local coordinates and ID.\n            vec4 grd = vec4(q - ip, ip);\n  \n\n\n            // Calculating the background pattern.\n            float pat = getPat(grd.xy, scl/2., grd.zw, 0., type, 0);\n            float oPat = pat;\n            float tF = type == 2? .7071 : 1.;\n            #ifdef REVERSE\n            float th = .015*tF*GSCALE;\n            #else\n            float th = .05*tF*GSCALE;\n            #endif\n            pat = min(pat + th*1.5, abs(pat - th) - th);\n            #ifdef REVERSE\n            pat = -pat;\n            #endif\n            \n            /*\n            // Colored markings. Didn't work.\n            vec3 lCol = .5 + .45*cos(6.2831589*hash21(ip2)/6. + vec3(0, 1, 2)*1.25);\n\n            float cRnd = hash21(ip2 + .21);\n            // if(cRnd<.35) lCol = lCol.zyx;\n            lCol /= 1./3. + dot(lCol, vec3(.299, .587, .114));\n            // Running a diffuse gradient effect over the result.\n            lCol = mix(lCol, lCol.zyx, spec*.125);\n           \n            lCol *= tx*2. + .5;\n            lCol *= lCol*3.;\n            */\n\n            // Coloring.\n            vec3 lCol = vec3(.75);\n            lCol *= (tx*2. + .05)*shade;\n           \n            // Metallic texturing and shading, depending on pattern region.\n            objCol = vec3(.5)*(tx*2. + .05)*shade;\n            objCol = mix(objCol*.75, objCol*.375, 1. - smoothstep(0., .005, pat));\n   \n            // Reverse pattern option.\n            #ifdef REVERSE\n            objCol = mix(objCol, lCol, 1. - smoothstep(0., .005, (abs(oPat - th) - th)));\n            #else\n            objCol = mix(objCol, lCol, 1. - smoothstep(0., .005, oPat + th*1.5));\n            #endif           \n            \n            // Dark edges.\n            objCol = mix(objCol, objCol*.25, \n                         1. - smoothstep(0., .005, abs(pat + .01) - .005));\n  \n            \n            // Grey factor - Not used here.\n            //objCol = mix(objCol, vec3(1)*dot(objCol, vec3(.299, .587, .114)), toneF);\n       \n       \n            // Material type, reflectance and texture-based roughness.\n            //matType = mix(1., 0.,  1. - smoothstep(0., .005, oPat + th*1.5));\n            matType = 1.;\n            reflectance = .5;\n            roughness = min(dot(tx*2.5, vec3(.299, .587, .114)), 1.);\n           \n        }\n        \n        \n            \n        \n         \n        // Cheap specular reflections. Requires loading the \"Forest\" cube map \n        // into \"iChannel3\".\n        float speR = pow(max(dot(normalize(ld - rd), sn), 0.), 5.);\n        vec3 rf = reflect(rd, sn); // Surface reflection.\n        vec3 rTx = texture(iChannel2, rf.xzy*vec3(1, -1, -1)).xyz; rTx *= rTx;\n        float rF = svObjID==2.? 2.: 4.;\n        objCol = objCol + (objCol)*speR*dot(rTx, vec3(.299, .587, .114))*rF;\n \n \n        // Ambient light.\n        // I wanted to use a little more than a constant for ambient light, but \n        // without having to resort to sophisticated methods, then I remembered \n        // Blackle's example, here:\n        // Quick Lighting Tech - blackle\n        // https://www.shadertoy.com/view/ttGfz1\n        float ambience = pow(length(sin(sn*2.)*.45 + .5)/sqrt(3.), 2.)*2.; // Studio.\n        //float ambience = length(sin(sn*2.)*.5 + .5)/sqrt(3.)*\n        //                  smoothstep(-1., 1., -sn.z); // Outdoor.\n\n        \n        // Cook-Torrance based lighting.\n        vec3 ct = BRDF(objCol, sn, ld, -rd, matType, roughness, reflectance);\n        \n        // Combining the ambient and microfaceted terms to form the final color:\n        // None of it is technically correct, but it does the job. Note the hacky \n        // ambient shadow term. Shadows on the microfaceted metal doesn't look \n        // right without it... If an expert out there knows of simple ways to \n        // improve this, feel free to let me know. :)\n        col = (objCol*ambience*(sh*.5 + .5) + ct*(sh));\n        \n        \n        // Shading.\n        col *= ao*atten;\n        \n         \n\t\n\t}\n    \n    \n    \n    // Applying fog: This fog begins at 90% towards the horizon.\n    col = mix(col, vec3(0), smoothstep(.25, .9, t/FAR));\n \n    // For all the toning formulae out there, this one liner -- based on \n    // Reinhart, does a really good job. The figure on the end (3, in this case) \n    // regulates the high tones. Obviously, the higher the number, the less\n    // dramatic the toning.\n    col /= (1. + col/3.);   \n    \n     \n    /*\n    vec4 prev = texture(iChannel0, fragCoord/iResolution.xy);\n    col = mix(col, prev.xyz, 1./2.);\n    t = mix(t, prev.w, 1./2.);\n    */ \n   \n \n    // Store to the buffer.\n    fragColor = vec4((max(col, 0.)), t);\n    \n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}