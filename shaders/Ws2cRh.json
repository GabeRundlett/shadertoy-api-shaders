{
    "Shader": {
        "info": {
            "date": "1586100203",
            "description": "An ellipse, constructed as an envelope of tangent lines.\n\nDual to: [url]https://www.shadertoy.com/view/tdSyDz[/url]\n\nMouse changes ellipse.",
            "flags": 0,
            "hasliked": 0,
            "id": "Ws2cRh",
            "likes": 16,
            "name": "Projective Conic Envelope",
            "published": 3,
            "tags": [
                "envelope",
                "conic",
                "projective",
                "loopless"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 586
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Projective Conic Envelope\n//\n// Copyright (c) Matthew Arcus, 2020\n// MIT License: https://opensource.org/licenses/MIT\n//\n// More projective magic - generate an ellipse as an envelope of lines.\n// In fact, we start with the ellipse and find a network of lines\n// enveloping it: at each point p, find tangents to the ellipse,\n// intersect these with a fixed axis at x = -3 - this will be the\n// source of the rays. From axis intersection point, map to a radial\n// parameter, then find closest displayed ray, map that back to the\n// axis and find the tangents from there & these are the lines that\n// actually get displayed.\n//\n// Mouse changes size and orientation of ellipse.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI =  3.141592654;\n\nvec3 join(vec3 p, vec3 q) {\n  // Return either intersection of lines p and q\n  // or line through points p and q, r = kp + jq\n  return cross(p,q);\n}\n\nfloat line(vec3 p, vec3 q) {\n  return abs(dot(p,q)/(p.z*length(q.xy)));\n}\n\n// Set tan1 and tan2 to the two tangents to conic X from point p.\n// Return false if no tangents (eg. inside an ellipse).\nbool tangents(vec3 p, mat3 X, out vec3 tan1, out vec3 tan2) {\n  vec3 polar = X*p; // Line between tangents\n  float a = polar.x, b = polar.y, c = polar.z;\n  // Two points on the polar line. Q is the nearest point to origin,\n  // R is at infinity, ie. is direction vector.\n  vec3 Q = vec3(a,b,-(a*a+b*b)/c);\n  vec3 R = vec3(-b,a,0);\n\n  // Find intersection of QR with conic, ie. dot(Q+kR,X*(Q+kR)) = 0\n  float A = dot(R,X*R), B = dot(Q,X*R), C = dot(Q,X*Q);\n  float D = B*B-A*C;\n  if (D < 0.0) return false;\n  D = sqrt(D);\n  float k1,k2;\n  if (B > 0.0) {\n    k1 = (-B-D)/A; k2 = C/(A*k1);\n  } else {\n    k2 = (-B+D)/A; k1 = C/(A*k2);\n  }\n  tan1 = join(p,Q+k1*R); tan2 = join(p,Q+k2*R);\n  return true;\n}\n\nvec3 hsv2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  float scale = 3.0;\n  float t = 0.2*iTime+PI/6.0;\n  float A = 0.25, B = 1.0;\n  if (iMouse.x > 0.0) {\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    t += PI*(m.y);\n    B = exp(-m.x);\n  }\n  float cost = cos(t), sint = sin(t);\n  // Conic matrix - conic is points p with pXp = 0\n  mat3 X = mat3(A,0,0,0,B,0,0,0,-1);\n  // Apply tranformation to conic matrix.\n  mat3 P = mat3(cost,sint,0, -sint,cost,0, 0,0,1);\n  X = transpose(P)*X*P;\n\n  vec3 p = vec3(scale*(2.0*fragCoord - iResolution.xy)/iResolution.y,1);\n\n  vec3 col = vec3(0);\n  \n  float lwidth0 = 0.0;\n  float lwidth1 = max(0.02,fwidth(p.x));\n\n  vec3 tan1,tan2,tan11,tan12,tan21,tan22;\n  if (tangents(p,X,tan1,tan2)) {\n    float N = 64.0;\n    vec3 axis = vec3(1,0,3);\n    float index1,index2;\n\n    vec3 p1 = join(tan1,axis);\n    float t1 = atan(p1.y/p1.z);\n    t1 += 0.1*iTime;\n    t1 *= N/PI; t1 = round(t1); index1 = t1; t1 *= PI/N;\n    t1 -= 0.1*iTime;\n    p1 = vec3(-3,tan(t1),1);\n    p1.y = sign(p1.y)*min(abs(p1.y),1e4); // Fix up silly values\n    if (tangents(p1,X,tan11,tan12)) {\n      vec3 c1 = hsv2rgb(vec3(index1/N,1,1));\n      float d = line(p,tan11);\n      col = mix(c1,col,smoothstep(lwidth0,lwidth1,d));\n      float tt = dot(normalize(tan2.xy),normalize(tan12.xy));\n      // Try not to get the wrong tangent here. There must be a better\n      // way of doing this.\n      if (abs(tt) < 0.99) {\n        d = line(p,tan12);\n        col = mix(c1,col,smoothstep(lwidth0,lwidth1,d));\n      }\n    }\n\n    vec3 p2 = join(tan2,axis);\n    float t2 = atan(p2.y/p2.z);\n    t2 += 0.1*iTime;\n    t2 *= N/PI; t2 = round(t2); index2 = t2; t2 *= PI/N;\n    t2 -= 0.1*iTime;\n    p2 = vec3(-3,tan(t2),1);\n    p2.y = sign(p2.y)*min(abs(p2.y),1e4); // Fix up silly values\n    if (tangents(p2,X,tan21,tan22)) {\n      vec3 c2 = hsv2rgb(vec3(index2/N,1,1));\n      float d = line(p,tan22);\n      col = mix(c2,col,smoothstep(lwidth0,lwidth1,d));\n      float tt = dot(normalize(tan1.xy),normalize(tan21.xy));\n      // Try not to get the wrong tangent here.\n      if (abs(tt) < 0.99) {\n        d = line(p,tan21);\n        col = mix(c2,col,smoothstep(lwidth0,lwidth1,d));\n      }\n    }\n  }\n  col = pow(col,vec3(0.4545));\n  fragColor = vec4(col,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}