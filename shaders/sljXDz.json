{
    "Shader": {
        "info": {
            "date": "1628410034",
            "description": "Was playing around with this over the past week but had some late night inspiration - Animated isometric truchet tile pattern, procedurally generated.",
            "flags": 32,
            "hasliked": 0,
            "id": "sljXDz",
            "likes": 42,
            "name": "Cards & Mirrors",
            "published": 3,
            "tags": [
                "raymarching",
                "crt",
                "truchet",
                "isometric",
                "cards"
            ],
            "usePreview": 1,
            "username": "byt3_m3chanic",
            "viewed": 926
        },
        "renderpass": [
            {
                "code": "/**                           _                                  \n                   _        _| |_          _                     \n     ___ ___ ___ _| |___   |   __|   _____|_|___ ___ ___ ___ ___ \n    |  _| .'|  _| . |_ -|  |   __|  |     | |  _|  _| . |  _|_ -|\n    |___|__,|_| |___|___|  |_   _|  |_|_|_|_|_| |_| |___|_| |___|\n                             |_|                                 \n                                                              \n    Cards and Mirrors \n    @byt3_m3chanic | 08/07/21\n\n    having some Isometric fun still and working with\n    a simple truchet tile pattern.\n\n    Shader in buffer tab/CRT effect in image tab\n\n    // thanks to //\n    \n    SDF shapes @iq\n    truchet and tile tricks @Shane\n    text @Fabrice\n    \n*/\n\n#define PI  3.14159265359\n\n// CRT effect adapted from online blog post. \n// https://babylonjs.medium.com/retro-crt-shader-a-post-processing-effect-study-1cb3f783afbc\n\nvec2 curvature = vec2(3.5,4.);\nvec2 remapUV(vec2 uv) {\n    uv = uv * 2. -1.;\n    vec2 offset = abs(uv.yx) / vec2(curvature.x, curvature.y);\n    uv = uv + uv * offset * offset;\n    uv = uv * .5 + .5;\n    return uv;\n}\n\nvec4 scanLine(float uv, float resolution, float opacity) {\n     float intensity = sin(uv * resolution * PI * 2.);\n     intensity = ((.5 * intensity) + .5) * .9 + .1;\n     return vec4(vec3(pow(intensity, opacity)), 1.);\n}\n\nvec4 vignette(vec2 uv, vec2 resolution, float opacity) {\n    float intensity = uv.x * uv.y * (1. - uv.x) * (1. - uv.y);\n    return vec4(vec3(clamp(pow((resolution.x / 4.) * intensity, opacity), 0.0, 1.)), 1.);\n}\n\nvec2 scanLineOpacity = vec2(.15);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {  \n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    uv=(uv*1.05)-vec2(.025,.025);\n    vec2 vuv = remapUV(uv);\n    \n    vec4 baseColor = texture(iChannel0, vuv);\n\n    baseColor *= vignette(vuv, iResolution.xy, .75);\n    baseColor *= scanLine(vuv.x, iResolution.y*.9, scanLineOpacity.x);\n    baseColor *= scanLine(vuv.y, iResolution.x*.9, scanLineOpacity.y);\n\n    if (vuv.x < 0.0 || vuv.y < 0.0 || vuv.x > 1.0 || vuv.y > 1.0){\n        baseColor = vec4(vec3(.0),0);\n    }\n\n    // looks better when gamma is in buffer to me..\n    // but saved just in case\n    //baseColor.rgb=pow(baseColor.rgb, vec3(.4545));\n    //baseColor=texture(iChannel0,fragCoord.xy/iResolution.xy);\n    \n    fragColor = baseColor;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define R iResolution\n#define M iMouse\n#define T iTime\n\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MIN_DIST .0001\n#define MAX_DIST 90.\n\n////////////////////////////////////////////////////////\n// Fabrice Neyret https://www.shadertoy.com/view/llySRh\n// text and font stuff\nint CAPS=0;\n#define spc  U.x-=.44;\n#define CR(c) spc O+= char(U,c);\nvec4 char(vec2 p, int c) {\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n// end text and font stuff\n////////////////////////////////////////////////////////\n\nfloat lsp(float begin, float end, float t) { return clamp((t - begin) / (end - begin), 0.0, 1.0); }\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p) { return fract(sin(dot(p,vec2(23.43,84.21)))*4832.3234); }\n\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n//@iq\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdHeart( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n//@iq\nfloat sdRBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n//@iq\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p);\n    float h = clamp((-2.0*ndot(q,b)+ndot(b,b))/dot(b,b),-1.0,1.0);\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( q.x*b.y + q.y*b.x - b.x*b.y );\n}\nvec3 hit,hitPoint,sto,gto;\nvec2 gid,sid;\nfloat time=0.,tmod=0.,ga1,ga2,ga3,ga4;\n\nconst vec2 sc = vec2(.2), hsc = .5/sc; \nconst float amt = 6.;\nconst float dbl = amt*2.;\n\nvec2 map(vec3 p) {\n    p.xy+=vec2(time,3.5);\n    vec2 res = vec2(1e5,0);\n    \n    vec2 id = floor(p.xz*sc) + .5;    \n    vec2 r = p.xz - id/sc;\n    vec3 q = vec3(r.x,p.y,r.y);\n\n    float rnd = hash21(id);\n    float dir = mod(id.x+id.y,2.)<.5? -1. : 1.;\n    if(rnd<.5) r.y *= -1.;\n    \n    vec2 d2 = vec2(length(r-hsc), length(r+hsc));  \n    float crv = abs(min(d2.x,d2.y)-hsc.x);\n\n    vec2 pp = d2.x<d2.y? vec2(r - hsc) : vec2(r + hsc);\n    pp *= rot(time*dir);\n    \n    float a = atan(pp.y, pp.x);\n    float ai = floor(dir*a/PI*dbl);\n    a = (floor(a/PI2*dbl) + .5)/dbl;\n    float ws = mod(ai,dbl);\n\n    vec2 qr = rot(-a*PI2)*pp; \n    qr.x -= hsc.x;\n\n    //moving blocks\n    vec3 npos = vec3(qr.x, p.y-1.5, qr.y);\n    float blox = box(npos,vec3(.65,.75,.01));\n    float blok = box(dir>0.?npos+vec3(0,0,.001):npos-vec3(0,0,.001),vec3(.65,.75,.01));\n    if(blox<res.x) {\n        res = vec2(blox,2.);\n        if(rnd<.5^^dir>0.) npos.x*=-1.;\n    \thit=npos;\n        gid=id;\n        gto=vec3(crv,ws,rnd);\n    }\n    if(blok<res.x) {\n        res = vec2(blok,5.);\n        //if(rnd<.5^^dir>0.) npos.x*=-1.;\n    \thit=npos;\n        gid=id;\n        gto=vec3(crv,ws,rnd);\n    }\n    //truchet track\n    vec3 tp = vec3(abs(crv)-.9,p.y,crv);\n    float bx = box(tp+vec3(0,.25,0), vec3(.2, .75,1.));\n    if(bx<res.x) {\n        res = vec2(bx, 3.);\n        hit=tp;\n        gid=id;\n        gto=vec3(crv,dir,rnd);\n    }\n    // floor\n    float d9 = p.y + .25;\n    if(d9<res.x) {\n        res = vec2(d9,1.);\n    \thit=p;\n        gid=id;\n        gto=vec3(crv,dir,rnd);\n    }\n\n    return res;\n}\n/**\nvec3 normal(vec3 p, float t)\n{\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n*/\n// Tetrahedron technique @Shane\nvec3 normal(vec3 p, float t)\n{\n    const vec2 h = vec2(1.,-1.)*.5773;\n    vec3 n = vec3(0);\n    vec3[4] e4 = vec3[4](h.xyy, h.yyx, h.yxy, h.xxx);\n    \n    for(int i = min(0, iFrame); i<4; i++){\n\t    n += e4[i]*map(p + e4[i]*t*MIN_DIST).x;\n        if(n.x>1e8) break; // Fake non-existing conditional break.\n    }\n    return normalize(n);\n}\n\nvec4 FC = vec4(0.961,0.718,0.718,0.);\n\nvec3 makeCard(vec3 p, float cardId)\n{\n    vec4 O;\n    vec3 h = vec3(1.);\n    float hs = hash21(vec2(cardId,8.));\n    \n    vec2 uv = p.xy+vec2(0,0);\n    \n    if(hs<.5){\n        float ht = sdHeart((uv*2.)+vec2(0,.65));\n        ht=smoothstep(.012,.01,ht);\n        h = mix(h,vec3(1,0,0),ht);\n    } else {\n        float ht = sdRhombus((uv*2.),vec2(.5,.75));\n        ht=smoothstep(.012,.01,ht);\n        h = mix(h,vec3(0,0,0),ht);\n    }\n    cardId=mod(cardId,9.);\n    float FontSize = .25;\n    vec2 U = p.xy/FontSize;\n    int ofs = 49;\n    U.xy-=vec2(.725,1.5);\n    CR(ofs+int(cardId));\n    U*=-1.;\n    U.xy-=vec2(1.925,3.);\n    CR(ofs+int(cardId));\n\n    float ck=smoothstep(.1,.7,O.x);\n    h = mix(h,(hs<.5)?vec3(1,0,0):vec3(0),ck);\n    \n    float cf = sdRBox(uv.xy,vec2(.575,.675),vec4(.01));\n    cf=abs(abs(cf)-.025)-.005;\n    vec2 pt = vec2(.415,.5);\n    float dts = min(length(uv.xy-pt)-.275,length(uv.xy+pt)-.275 ) ;\n    float pts = min(length(uv.xy-pt)-.175,length(uv.xy+pt)-.175 ) ;\n    pts=abs(abs(pts)-.025)-.005;\n    cf=max(cf,-dts);\n    \n    cf=min(cf,pts);\n    cf=smoothstep(.011,.01,cf);\n    h = mix(h,vec3(.1),cf);\n    \n    return h;\n}\nvec3 makeBack(vec3 p)\n{\n    vec3 h;\n    vec3 c = vec3(.59,0,0);\n    vec2 uv = p.xy*vec2(.55,.7);\n    float px = fwidth(R.x/PI);    \n    float cf = sdRBox(uv.xy,vec2(.3,.45),vec4(.01));\n    float pf=smoothstep(.01,.012,cf);\n    uv*=10.;\n    vec2 tuv = fract(uv)-.5;\n    vec2 tid = floor(uv);\n    float hs = hash21(tid);\n    if(hs>.5) tuv.x*=-1.;\n\n    vec2 d2 = vec2(length(tuv-.5), length(tuv+.5));\n    vec2 gx = d2.x<d2.y? vec2(tuv-.5) : vec2(tuv+.5);\n\n    float circle = length(gx)-.5;\n    circle=abs(circle)-.05;\n    circle=smoothstep(.03-px,px,circle);\n    \n    h = mix(h,vec3(1),circle);\n    h = mix(h,vec3(1),pf);\n    \n    cf=abs(abs(cf)-.001)-.005;\n    cf=smoothstep(.015,.012,cf);\n    h = mix(h,c,cf);\n    \n    return h;\n}\n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d) {\n\n    vec3 C = vec3(0);\n    float m = 0.;\n    vec3 p = ro;\n    for(int i=0;i<175;i++)\n    {\n        p = ro + rd * d;\n        vec2 ray = map(p);\n        if(abs(ray.x)<MIN_DIST*d||d>MAX_DIST)break;\n        d += ray.x * .75;\n        m  = ray.y;\n    } \n    hitPoint = hit;\n    sid = gid;\n    sto = gto;\n    \n    float alpha = 0.;\n    if(d<MAX_DIST)\n    {\n        vec3 n = normal(p,d);\n        vec3 lpos =  vec3(0,4,0);\n        vec3 l = normalize(lpos-p);\n\n        float diff = clamp(dot(n,l),0.,1.);\n        float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 5.);\n        fresnel = mix(.01, .7, fresnel);\n\n        float shdw = 1.0;\n        for( float t=.05; t < 16.; )\n        {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 16.*h/t);\n            t += h * .95;\n            if( shdw<MIN_DIST || t>32. ) break;\n        }\n        diff = mix(diff,diff*shdw,.75);\n\n        vec3 view = normalize(p - ro);\n        vec3 ret = reflect(normalize(lpos), n);\n        float spec =  0.5 * pow(max(dot(view, ret), 0.), 14.);\n\n        vec3 h = vec3(.5);\n        \n        if(m==1.) {\n            hitPoint*=sc.xxx;\n\n            vec3 h = vec3(0.3);\n            vec2 y = fract(hitPoint.xz*12.)-.5;\n            vec2 yy = fract(hitPoint.xz*6.)-.5;\n            \n            if(yy.x*yy.y>0.)h=vec3(0.969,0.969,0.969);\n            \n            float curve2 = smoothstep(.011,.01,abs(abs(abs(sto.x-1.25)-.075)-.075)-.025);\n            float curve = smoothstep(.011,.01,abs(sto.x-1.25)-.3);\n            float ht = (yy.x*yy.y>0.) ? \n                sdHeart((y*2.)+vec2(.0,.5)) : sdRhombus((y*2.),vec2(.5,.75));\n    \n            ht=smoothstep(.012,.01,ht);\n            h = mix(h,(yy.x*yy.y>0.)?vec3(.05):vec3(.7,0,0),ht);\n     \n            float path = smoothstep(.011,.01,sto.x-1.);\n            h=mix(h,vec3(.73),path);\n            \n            \n            h=mix(h,vec3(.9),curve);\n            h=mix(h,vec3(.5,.0,.0),curve2);\n            \n            C+=diff*h;\n            ref = vec3(path*.35)-fresnel;\n        }\n        \n        if(m==2.) {\n            h=makeCard(hitPoint,sto.y);\n            C+=h*diff+spec;\n            ref = h-fresnel;\n        }\n        if(m==5.) {\n            h=makeBack(hitPoint);\n            C+=h*diff+spec;\n            ref = h-fresnel;\n        }\n        if(m==3.) {\n            h=vec3(.03);\n            C+=h*diff+spec;\n            ref = vec3(.075)-fresnel;\n        }\n\n        ro = p+n*MIN_DIST;\n        rd = reflect(rd,n);\n    \n    }\n    \n    C = mix(FC.rgb,C,  exp(-(1e-6)*d*d*d)); \n    return vec4(C,alpha);\n}\n\nfloat zoom = 9.;\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    time = T*.25;\n    tmod = mod(time, 10.);\n    float t1 = lsp(4.0, 5.0, tmod);\n    float t2 = lsp(9.0, 10.0, tmod);\n    float t3 = lsp(1.0, 2.0, tmod);\n    float t4 = lsp(6.0, 7.0, tmod);\n    ga1 = ((t1-t2)*2.1)-1.1;\n    ga2 = (t3-t4)*45.;\n    //\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    \n    if(uv.x>ga1) zoom *= .65;\n    \n    vec3 ro = vec3(uv*zoom,-zoom);\n    vec3 rd = vec3(0,0,1.);\n\n    float x = M.xy == vec2(0) ? -45. : (M.x/R.x * 2. - 1.) * PI;\n    mat2 rx = rot(-0.78539816339);\n    mat2 ry = rot( (ga2*PI/180.));\n    ro.yz *= rx;\n    rd.yz *= rx;\n    ro.xz *= ry;\n    rd.xz *= ry;\n\n    vec3 C = vec3(0);\n    vec3 ref=vec3(0); \n    vec3 fil=vec3(1);\n    \n    float d =0.;\n    float numBounces = 2.;\n    \n    for(float i=0.; i<numBounces; i++) {\n        vec4 pass = render(ro, rd, ref, i==numBounces-1., d);\n        C += pass.rgb*fil;\n        fil*=ref;\n        // first bounce get fog distance as alpha\n        if(i==0.) FC = vec4(FC.rgb,exp(-(1e-5)*d*d*d));\n    }\n    \n    C = mix(C,FC.rgb,1.-FC.w);\n    if(uv.x+.002>ga1 && uv.x<ga1)C=vec3(1);\n    C = clamp(C,vec3(.02),vec3(1));\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}