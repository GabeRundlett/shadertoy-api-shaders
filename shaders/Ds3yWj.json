{
    "Shader": {
        "info": {
            "date": "1695623902",
            "description": "These particles are embued with the power of nyan cat, so they know how to assemble themselves into His likeness. Inspired by Pezzza's Work:\n\nhttps://youtu.be/watch?v=9IULfQH7E90\n\n*mouse: zoom*\n*alt: render shock direction field*\n*space: reset*\n",
            "flags": 48,
            "hasliked": 0,
            "id": "Ds3yWj",
            "likes": 54,
            "name": "Deterministic Nyan Particles",
            "published": 3,
            "tags": [
                "voronoi",
                "collision",
                "nyan",
                "simulation",
                "particles",
                "dynamics",
                "tracking",
                "physics",
                "sim",
                "determinism"
            ],
            "usePreview": 0,
            "username": "fenix",
            "viewed": 497
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Inspired by Pezzza's Work on YouTube:\n//\n//      https://www.youtube.com/watch?v=9IULfQH7E90\n//\n//  I always wanted to try one of those determistic effects, such as those ball sorters:\n//\n//      dr2's Magic Ball Sorter      https://shadertoy.com/view/tsGyDy\n//\n//  I thought Pezzza's Work's idea of using the determinism to assemble an image seemed\n//  smart. His simulation looks better than mine, but he has the luxury of iterations.\n//\n//  Of course the way this works is determinism: the simulation is the same every time\n//  it runs, so we only have to run it once to find out where each particle will end\n//  up. This is why there is no image on the first run: we don't know yet where the\n//  particles will go.\n//\n//  I had to reuse the shock direction idea to make the particles stable enough for this\n//  to work. So here's a proof of concept for the same idea with a verlet simulation. The\n//  shock direction modifies the collision stiffness, so that lower particles are less\n//  able to be moved by particles above them. Press alt to render the shock directions.\n//\n//      *mouse to zoom*\n//      *alt to render shock direction field*\n//      *space to reset*\n//\n//  Buffer A, B, and C perform particle simulation. Only A updates the particle neighbors.\n//  Buffer D computes screen-space voronoi for render.\n//\n// ---------------------------------------------------------------------------------------\n\nvoid renderParticle(fxParticle v, vec2 p, uint id, float sc, inout vec4 O)\n{\n    float e = 2. * sc / R.y;\n    float d = fxLinePointDist(v.pos, v.prev, p);\n    \n    vec3 color = v.color;\n    if (keyDown(KEY_ALT))\n        color *= sin(atan(abs(v.sd.y * .1), v.sd.x) + vec3(0, 11, 33));\n    O.xyz = mix(O.rgb, color, smoothstep(v.size + e, v.size - e, d));\n}\n\n// Character rendering from Shader Text for beginners by PrzemyslawZaworski:\n// https://www.shadertoy.com/view/4sBfRd\n#define C(c) O += char(U,64+c) ; U.x-=.5\n\n#define LF (U.y++)\n#define CR (U.x = (( uv.x - position.x)*64.0/FontSize))\n#define NL (CR,LF)\n\nvec4 char(vec2 p, int c) \n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel2, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) ).xxxx;\n}\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    computeMaxParticles();\n    vec2 p = (u - .5 * R) / R.y;\n    float sc = 1.;\n    \n    if (iMouse.z > 0.)\n    {\n        sc = .25; // mouse zoom\n        p.xy *= .25;\n        p.xy += .6 * (iMouse.xy - .5 * R) / R.y;\n    }\n    \n    uvec4 old = fxGetClosest(ivec2(p * R.y + .5 * R.xy));\n    fxState s = fxGetState();\n    O.rgb = BACK_COLOR;\n\n    // render particles\n    if ((!s.init || s.frame < CAPTURE_FRAME) && s.frame > 1)\n    {\n        for (int i = 0; i < 4; ++i)\n        {\n            uint id = old[i];\n            if (id == -1U || id >= g_MaxParticles) break;\n            fxParticle v = fxGetParticle(id);\n            renderParticle(v, p, id, sc, O);\n        }\n    }\n    \n    float d = sdScene(p, R);\n    O = mix(O, vec4(1), smoothstep(0., -1. / R.y, d)); // render border\n\n    if (s.init)\n    {\n        if (abs(p.x) < .4 && abs(p.y) < .1)\n        {\n            O *= .5; // render rectangle\n            const float FontSize = 4.;\n            const vec2 position = vec2(.31,.5 - FontSize / 128.0);\n            vec2 U = ( (p * R.y + .5 * R) / R - position)*64.0/FontSize;\n            C(16);C(12);C(5);C(1);C(19);C(5);C(-32);C(23);C(1);C(9);C(20); // \"PLEASE WAIT\"\n        }\n        \n        if (p.y < -.4 && p.x < ((float(s.frame) / float(CAPTURE_FRAME) - .5)) * R.x / R.y)\n            O *= .5; // progress bar\n    }\n    \n    O.a = 1.;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tParticle simulation\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 O, vec2 fragCoord )\n{\n    uvec2 ufc = uvec2(fragCoord);\n    \n    computeMaxParticles();\n    uint index = ufc.x + ufc.y * uint(R.x); // \"1D array\" index\n    uint id = index / NUM_PARTICLE_DATA_TYPES; // which particle\n    uint dataType = index - id * NUM_PARTICLE_DATA_TYPES; // which field of particle structure\n    if (id >= g_MaxParticles) return;\n    \n    fxParticle p = fxGetParticle(id);\n    fxState s = fxGetState();\n    \n    if (dataType >= POS)\n        O = updateParticle(s, p, id, dataType);\n    else\n        O = voronoiParticle(s, p, id, dataType);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tParticle simulation\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 O, vec2 fragCoord )\n{\n    uvec2 ufc = uvec2(fragCoord);\n    \n    computeMaxParticles();\n    uint index = ufc.x + ufc.y * uint(R.x); // \"1D array\" index\n    uint id = index / NUM_PARTICLE_DATA_TYPES; // which particle\n    uint dataType = index - id * NUM_PARTICLE_DATA_TYPES; // which field of particle structure\n    if (id >= g_MaxParticles) return;\n    \n    fxParticle p = fxGetParticle(id);\n    fxState s = fxGetState();\n    \n    if (dataType >= POS)\n        O = updateParticle(s, p, id, dataType);\n    else\n        O = voronoiParticle(s, p, id, dataType);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\nconst float PI = 3.141592653589793;\nconst int CAPTURE_FRAME = 1150; // what frame to trigger each particle to capture uv\nconst int RESET_FRAME = 2000; // how many frames before resetting on second+ runs\nconst vec3 BACK_COLOR = vec3(.6,.4,.6); // \nconst vec3 PAR_COLOR = BACK_COLOR + .2;\nconst uint IDEAL_MAX_PARTICLES = 6000U;\nconst float PARTICLE_SIZE = .005;\n\n#define R iResolution.xy\n\n// PERSISTENT STATE\n\nstruct fxState\n{\n    float res; // tracks resolution changes\n    int frame; // simulation frame\n    bool init; // first initialization run\n};\n\n#define fxGetState() fxGetStateImpl(iChannel1)\nfxState fxGetStateImpl(sampler2D sampler)\n{\n    vec4 data = texelFetch(sampler, ivec2(0), 0);\n    \n    fxState s;\n    s.res = data.x;\n    s.frame = floatBitsToInt(data.z);\n    s.init = data.w != 0.;\n    \n    return s;\n}\n\nvec4 fxPutState(fxState s)\n{\n    return vec4(s.res, 0, intBitsToFloat(s.frame), s.init ? 1 : 0);\n}\n\nbool fxIsStatePixel(vec2 u)\n{\n    return ivec2(u) == ivec2(0);\n}\n\n//returns the ids of the four closest particles from the input\n#define fxGetClosest(X) fxGetClosestImpl(iChannel1, X)\nuvec4 fxGetClosestImpl(sampler2D sampler, ivec2 xy)\n{\n    return floatBitsToUint(texelFetch(sampler, xy, 0));\n}\n\n// UTILITIES\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_ALT 18\n#define KEY_SPACE 32\n\nuvec4 hash(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nfloat length2(vec2 v) { return dot(v, v); }\nfloat sqr(float x) { return x * x; }\n\nfloat fxLinePointDist(vec2 a, vec2 b, vec2 p)\n{\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);// proj coord on line\n    return sqrt(length2(p - b * h)); // squared dist to segment\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdArc( in vec2 p, in vec2 sc, in float ra, float rb )\n{\n    // sc is the sin/cos of the arc's aperture\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n}\n\nmat2 rot2(float a)\n{\n    vec2 sc = vec2(sin(a), cos(a));\n    return mat2(sc.y, sc.x, -sc.x, sc.y);\n}\n\n// insert new particle at distance d_ with index i_ into i, d arrays, sorting by d\nvoid insertionSort(inout uvec4 i, inout vec4 d, uint i_, float d_)\n{\t\n    if(any(equal(uvec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = uvec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = uvec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = uvec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = uvec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\n// SCENE FUNCTIONS\n\n// scene (walls) signed distance field, for rendering and collision\nfloat sdScene(vec2 p, vec2 res)\n{\n    const float theta = 2.35;\n    const vec2 sc = vec2(sin(theta), cos(theta));\n    float d = sdArc((p * vec2(1, -1)), sc, 0.45, 0.01);\n    d = min(d, sdBox((p - vec2(-1.195, .794)) * rot2(-.5), vec2(1, .01)));\n    d = min(d, sdBox((p - vec2( 1.195, .794)) * rot2(.5), vec2(1, .01)));\n    return d;\n}\n\n// the outward normal of the scene at a point\nvec2 normScene(vec2 p, vec2 res)\n{\n\tconst vec2 d = vec2(.001, 0);\n    \n   \tfloat x1 = sdScene(p + d.xy, res); \n    float x0 = sdScene(p - d.xy, res); \n    float dx = x1 - x0;\n    \n    float y1 = sdScene(p + d.yx, res); \n    float y0 = sdScene(p - d.yx, res); \n    float dy = y1 - y0;\n    \n\treturn normalize(vec2(dx, dy));\n}\n\n// PARTICLE STRUCTURE\n\n#define UL_NEIGHBORS 0U\n#define UR_NEIGHBORS 1U\n#define LL_NEIGHBORS 2U\n#define LR_NEIGHBORS 3U\n#define POS 4U\n#define SDUV 5U\n#define COLOR 6U\n#define NUM_PARTICLE_DATA_TYPES 7U\n\nuint g_MaxParticles = 0U;\n\n// must be called in each buffer before g_MaxParticles is correct\n#define computeMaxParticles() computeMaxParticlesImpl(R)\nvoid computeMaxParticlesImpl(vec2 res)\n{\n    g_MaxParticles = min(IDEAL_MAX_PARTICLES, uint(res.x * res.y) / NUM_PARTICLE_DATA_TYPES);\n}\n\n//returns the location of the particle within the particle buffer corresponding with the input id \n#define fxLocFromID(X, Y) fxLocFromIDImpl(int(R.x), X, Y)\nivec2 fxLocFromIDImpl(uint width, uint id, uint dataType)\n{\n    uint index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2(index % width, index / width);\n}\n\nstruct fxParticle\n{\n    vec2 pos;     // position\n    vec2 prev;     // velocity\n    vec2 sd;      // shock direction\n    float size;\n    vec3 color;\n    vec2 uv;\n    \n    uvec4 nbs[4]; // neighbors\n};\n\n//get the particle corresponding to the input id\n#define fxGetParticle(X) fxGetParticleImpl(iChannel0, uint(R.x), X)\nfxParticle fxGetParticleImpl(sampler2D sampler, uint resolutionWidth, uint id)\n{\n    vec4 data0 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, UL_NEIGHBORS), 0);\n    vec4 data1 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, UR_NEIGHBORS), 0);\n    vec4 data2 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, LL_NEIGHBORS), 0);\n    vec4 data3 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, LR_NEIGHBORS), 0);\n    vec4 data4 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, POS), 0);\n    vec4 data5 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, SDUV), 0);\n    vec4 data6 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, COLOR), 0);\n\n    fxParticle p;\n    p.nbs[0] = floatBitsToUint(data0);\n    p.nbs[1] = floatBitsToUint(data1);\n    p.nbs[2] = floatBitsToUint(data2);\n    p.nbs[3] = floatBitsToUint(data3);\n    p.pos = data4.xy;\n    p.prev = data4.zw;\n    p.sd = data5.xy;\n    p.size = data6.w;\n    p.color = data6.xyz;\n    p.uv = data5.zw;\n    \n    return p;\n}\n\nvec4 fxSaveParticle(fxParticle p, uint dataType)\n{    \n    switch(dataType)\n    {\n    case UL_NEIGHBORS:\n        return uintBitsToFloat(p.nbs[0]);\n    case UR_NEIGHBORS:\n        return uintBitsToFloat(p.nbs[1]);\n    case LL_NEIGHBORS:\n        return uintBitsToFloat(p.nbs[2]);\n    case LR_NEIGHBORS:\n        return uintBitsToFloat(p.nbs[3]);\n    case POS:  \n        return vec4(p.pos, p.prev);\n    case SDUV:  \n        return vec4(p.sd, p.uv);\n    case COLOR:  \n        return vec4(p.color, p.size);\n    }\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataImpl(iChannel0, uint(R.x), X, Y)\nvec4 fxGetParticleDataImpl(sampler2D sampler, uint resolutionWidth, uint id, uint dataType)\n{\n    return texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, dataType), 0);\n}\n\n// PARTICLE SIM\n\nconst vec2 GRAVITY = vec2(0., -.00002);\nconst float COLLISION_STIFFNESS = .4;\nconst float SHOCK_STIFFNESS = 1.2; // reduces how much the shock direction affects the sim\nconst float MAX_SPEED = PARTICLE_SIZE * .9;\n\n// If not applied carefully, the shock direction can create the a situation where\n// the particles get shoved towards the center of a container. This hack biases\n// the shock direction towards vertical, ensuring we get smaller green and blue\n// areas and more red, and preventing particles from being shoved towards the center.\nconst vec2 SHOCK_BIAS = vec2(1, 1.1);\n\n#define updateParticle(A, B, C, D) updateParticleImpl(A, B, C, D, R, iChannel0)\nvec4 updateParticleImpl(fxState s, fxParticle p, uint id, uint dataType, vec2 res, sampler2D par)\n{\n    if (s.frame <= 0)\n    {\n        vec3 h1 = hash3((id) * uvec3(3, 6, 9));\n        //h1.x = pow(h1.x, 1.3);\n        h1 -= .5;\n        h1.y = h1.y * 6. + 3.5;\n        h1.x = h1.x * .8;\n        h1.x += sign(h1.x);\n\n        p.pos = h1.xy;\n        p.prev = p.pos;// - vec2(.003, -.003);\n        p.sd = vec2(0, 1);\n        p.size = PARTICLE_SIZE * (h1.z + 1.1);\n        if (s.init)\n        {\n            p.uv = vec2(0);\n            p.color = vec3(0);\n        }\n    }\n    else\n    {\n        vec2 vel = p.pos - p.prev;\n        p.prev = p.pos;\n        \n        float s2 = length2(vel);\n        if (s2 > MAX_SPEED * MAX_SPEED)\n            vel = MAX_SPEED * vel / sqrt(s2); // clamp velocity\n        if (p.pos.y > .5) vel *= .999; // damping up off the screen, so the particles don't fall too fast\n        p.pos = p.pos + vel + GRAVITY; // integrate position\n        \n        p.sd *= .5; // dissipate shock direction\n\n        vec2 nsd = p.sd; // new support direction\n        vec2 np = p.pos; // new particle position\n        for(int i = 0; i < 4; i++)\n        {\n            uvec4 nbs = p.nbs[i];\n            for (int j = 0; j < 4; ++j)\n            {\n                uint cid = nbs[j];\n                if(cid==id || cid == -1U || cid >= g_MaxParticles) continue;\n\n                fxParticle n = fxGetParticleImpl(par, uint(res.x), cid);\n\n                vec2 dp = np - n.pos; // delta position\n                float d2 = length2(dp) + PARTICLE_SIZE * 1e-4;\n\n                if (d2 < sqr(PARTICLE_SIZE * 15.))\n                {\n                    float d = sqrt(d2);\n                    vec2 dir = dp / d; // direction\n                    \n                    nsd += n.sd; // diffuse shock direction\n                    \n                    if (d2 < sqr(p.size + n.size))\n                    {\n                       // position correction (reduce when shock direction disagrees)\n                       float stf = COLLISION_STIFFNESS * (SHOCK_STIFFNESS + dot(dir, p.sd)) / SHOCK_STIFFNESS;\n                       np = mix(np, n.pos + (p.size + n.size) * dir, stf);\n                    }\n                }\n            }\n        }\n\n        // limit velocity from collision\n        vec2 cd = np - p.pos; // collision delta\n        float nv2 = length2(cd); // squared speed from collision\n        if (nv2 > sqr(PARTICLE_SIZE))\n            np = PARTICLE_SIZE * cd / sqrt(nv2) + p.pos;\n            \n        p.pos = np;\n        \n        float sd2 = length2(nsd);\n        if (sd2 > 1e-9)\n            p.sd = mix(p.sd, nsd * SHOCK_BIAS / sqrt(sd2), .9); // record new shock direction\n\n        // handle boundary\n        float ds = sdScene(p.pos, res);\n        if (ds < p.size * 2.)\n        {\n            vec2 n = normScene(p.pos, res);\n            p.sd = n; // seed shock direction\n            \n            if (ds < p.size) // collide with boundary\n                p.pos -= n * (ds - p.size);\n        }\n        \n        if (s.init && s.frame == CAPTURE_FRAME)\n            p.uv = (p.pos + .5) * vec2(.15, 1); // record resting position\n    }\n    \n    return fxSaveParticle(p, dataType);\n}\n\n// PARTICLE NEIGHBOR UPDATE\n\nbool iscoincidence(uvec4 bestIds, uint currentId, uint id)\n{\n    return id == -1U || id >= g_MaxParticles ||\n      \tid == currentId ||\n        any(equal(bestIds,uvec4(id)));\n}\n\nvoid sort0(sampler2D par, uint wd, inout uvec4 bestIds, inout vec4 bestDists, uint currentId, uint searchId, uint dataType, vec2 myPos)\n{\n    if(iscoincidence(bestIds, currentId, searchId)) return; //particle already sorted\n    \n    vec2 nbX = fxGetParticleDataImpl(par, wd, searchId, POS).xy; \n\n    vec2 dx = nbX - myPos;\n    uint dir = uint(2.*(atan(dx.y, dx.x)+PI)/PI); \n\n    if(dir != dataType) return; //not in this sector\n    \n    float t = length2(dx);\n    \n    insertionSort(bestIds, bestDists, searchId, t);\n}\n\n#define voronoiParticle(A, B, C, D) voronoiParticleImpl(iChannel0, iChannel1, R, A, B, C, D)\nvec4 voronoiParticleImpl(sampler2D par, sampler2D vor, vec2 res, fxState s, fxParticle p, uint id, uint dataType)\n{\n    uvec4 closest = fxGetClosestImpl(vor, ivec2(p.pos * res.y + .5 * res));\n    uvec4 bestIds = uvec4(-1);\n    vec4 bestDists = vec4(1e6);\n\n    if (s.frame > 0)\n    {\n        for (int i = 0; i < 4; ++i)\n        {\n            sort0(par, uint(res.x), bestIds, bestDists, id, p.nbs[0][i], dataType, p.pos);\n            sort0(par, uint(res.x), bestIds, bestDists, id, p.nbs[1][i], dataType, p.pos);\n            sort0(par, uint(res.x), bestIds, bestDists, id, p.nbs[2][i], dataType, p.pos);\n            sort0(par, uint(res.x), bestIds, bestDists, id, p.nbs[3][i], dataType, p.pos);\n            sort0(par, uint(res.x), bestIds, bestDists, id, closest[i], dataType, p.pos);\n        }\n\n        uint searchIterations = 4U;\n        for(uint k = 0U; k < searchIterations; k++)\n        {\n            //random hash. We should make sure that two pixels in the same frame never make the same hash!\n            float h = hash3(uvec3(id + k, id * k, k * uint(s.frame))).x;\n            //pick random id of particle\n            uint s = uint(mod(h*34534.0, float(g_MaxParticles)));\n            sort0(par, uint(res.x), bestIds, bestDists, id, s, dataType, p.pos);  //sort this\n        }\n    }\n    \n    return uintBitsToFloat(bestIds);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tParticle simulation\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 O, vec2 fragCoord )\n{\n    uvec2 ufc = uvec2(fragCoord);\n    \n    computeMaxParticles();\n    uint index = ufc.x + ufc.y * uint(R.x); // \"1D array\" index\n    uint id = index / NUM_PARTICLE_DATA_TYPES; // which particle\n    uint dataType = index - id * NUM_PARTICLE_DATA_TYPES; // which field of particle structure\n    if (id >= g_MaxParticles) return;\n    \n    fxParticle p = fxGetParticle(id);\n    fxState s = fxGetState();\n    \n    if (dataType >= POS)\n    {\n        O = updateParticle(s, p, id, dataType);\n        \n        if (dataType == COLOR)\n        {\n            // update particle color from uv\n            vec2 uv = p.uv;\n            if (s.frame > CAPTURE_FRAME)\n                uv.x += float(((s.frame - CAPTURE_FRAME) / 20) % 6) * .1559;\n            vec4 nyan = texture(iChannel2, uv, 0.);\n            O.rgb = mix(PAR_COLOR, nyan.rgb, nyan.a);\n        }\n    }\n    else\n        O = voronoiParticle(s, p, id, dataType);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 14,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tVoronoi tracking buffer and persistent state\n// ---------------------------------------------------------------------------------------\n\nvec4 voronoiScreen(fxState s, vec2 u);\nvec4 updateState(fxState s);\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    fxState s = fxGetState();\n    computeMaxParticles();\n\n    if (fxIsStatePixel(u))\n        O = updateState(s);\n    else\n        O = voronoiScreen(s, u);\n}\n\nvec4 updateState(fxState s)\n{\n    if (iFrame <= 0 || R.x * R.y != abs(s.res))\n    {\n        s.res = -R.x * R.y;\n        s.frame = -1;\n        s.init = true;\n    }\n    else\n    {\n        s.res = abs(s.res);\n        s.frame++;\n\n        if (s.init && s.frame == CAPTURE_FRAME + 1 ||\n            s.frame == RESET_FRAME)\n        {\n            s.init = false;\n            s.frame = -1;\n        }\n        else if (keyClick(KEY_SPACE))\n            s.frame = -1;\n    }\n\n    return fxPutState(s);\n}\n\n// find the squared distance from the screen position to a particular particle\nfloat distance2Particle(uint id, vec2 u)\n{\n    fxParticle v = fxGetParticle(id);\n    \n    return min(length2(v.pos - u), length2(v.prev - u));\n}\n\n// get all the existing neighbors of a cell and consider them as possible improvements for ourselves\nvoid sortNbs(uvec4 old, vec2 p, inout uvec4 new, inout vec4 dis)\n{\n    for (int j = 0; j < 4; j++)\n    {\n        uint id = old[j];\n        if (id == -1U || id >= g_MaxParticles) break;\n        float dis2 = distance2Particle(id, p);\n        insertionSort( new, dis, id, dis2 );\n    }\n}\n\nvec4 voronoiScreen(fxState s, vec2 u)\n{\n\tvec2 p = (u - .5 * R.xy) / R.y;\n    uvec4 new = uvec4(-1); // the four new closest particles\n    vec4 dis = vec4(1e6);  // the distances of the four newest particles\n\n    if (s.frame > 0)\n    {\n        uvec4 old = fxGetClosest(ivec2(u));\n                \n        sortNbs(old, p, new, dis); // start with our previous frame's values, and look up the distances\n        \n        int SEARCH_STEPS = int(2e4 / R.y);\n        const float SEARCH_RANGE = 20.;\n\n        for(int i = 0; i < SEARCH_STEPS; ++i)\n        {\n            vec2 h = hash3(uvec3(u, s.frame * 4 + i)).xy - .5;\n\n            sortNbs(fxGetClosest(ivec2(u + vec2(h * SEARCH_RANGE))), p, new, dis);\n        }\n\n        // random searching to kick start the process\n        float h = hash3(uvec3(u, s.frame)).x;\n        uint id = uint(h*float(g_MaxParticles));\n        insertionSort(new, dis, id, distance2Particle(id, p));\n    }\n    \n    return uintBitsToFloat(new);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}