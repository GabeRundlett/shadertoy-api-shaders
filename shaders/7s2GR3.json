{
    "Shader": {
        "info": {
            "date": "1617799280",
            "description": "Lone Planet and the Sun\n\nThe original code was generated by a tool I am working on, but should be readable.",
            "flags": 0,
            "hasliked": 0,
            "id": "7s2GR3",
            "likes": 18,
            "name": "Lone Planet and the Sun",
            "published": 3,
            "tags": [
                "planet",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "edubart",
            "viewed": 7817
        },
        "renderpass": [
            {
                "code": "/* Generated by Nelua 0.2.0-dev */\n/* Compile command: clang \"/home/bart/projects/nelua/nelua-lang/nelua_cache/demos/glsldemo.c\" -o \"/home/bart/projects/nelua/nelua-lang/nelua_cache/demos/glsldemo\" -Wall -fwrapv -g -lm */\n/* Compile hash: ajDYp5NtwWMYTraHttzrB2DfBzo */\n/* ------------------------------ DECLARATIONS ------------------------------ */\nvec3 vec_tovec3(float a);\nvec3 noise_vec3_yzx(vec3 self);\nvec3 noise_vec2_xyx(vec2 self);\nvec2 sincos(float x);\nfloat noise_hash1_2(vec2 v);\nfloat noise_hash1_3(vec3 v);\nfloat noise_noisemix3(float a1, float b1, float c1, float d1, float a2, float b2, float c2, float d2, vec3 f);\nfloat noise_noise_white_1(vec2 p);\nfloat noise_noise_value_1(vec3 p);\nfloat map(vec3 p);\nfloat ray_march(vec3 ro, vec3 rd);\nvec3 get_normal(vec3 p);\nfloat fbm3(vec3 p);\nvec3 planet_palette(float x);\nvec3 planet_color(vec3 p);\nvec3 shade(vec3 rd, vec3 p);\nvec3 perspective_camera(vec3 lookfrom, vec3 lookat, float tilt, float vfov, vec2 uv);\nfloat expstep(float x, float k);\nvec3 get_background(vec3 rd);\nvec3 color_tonemap_aces(vec3 col);\nvec3 color_saturate(vec3 col, float sat);\nvec3 color_tone_1(vec3 col, float gain, float lift, float invgamma);\nvec3 color_gamma_correction(vec3 col);\nvec3 vignette(vec3 col, vec2 coord, float strength, float amount);\nvec3 dither(vec3 col, vec2 coord, float amount);\nvec3 sun_glare(vec3 rd);\n/* ------------------------------ DEFINITIONS ------------------------------- */\nvec3 vec_tovec3(float a) {\n  return vec3(a, a, a);\n}\nvec3 noise_vec3_yzx(vec3 self) {\n  return vec3(self.y, self.z, self.x);\n}\nvec3 noise_vec2_xyx(vec2 self) {\n  return vec3(self.x, self.y, self.x);\n}\nvec2 sincos(float x) {\n  return vec2(sin(x), cos(x));\n}\nfloat noise_hash1_2(vec2 v) {\n  vec3 v3 = noise_vec2_xyx(v);\n  v3 = fract((v3 * 0.1031));\n  v3 = (v3 + dot(v3, (noise_vec3_yzx(v3) + 33.33)));\n  return fract(((v3.x + v3.y) * v3.z));\n}\nfloat noise_hash1_3(vec3 v) {\n  vec3 v3 = v;\n  v3 = fract((v3 * 0.1031));\n  v3 = (v3 + dot(v3, (noise_vec3_yzx(v3) + 33.33)));\n  return fract(((v3.x + v3.y) * v3.z));\n}\nfloat noise_noisemix3(float a1, float b1, float c1, float d1, float a2, float b2, float c2, float d2, vec3 f) {\n  vec3 u = ((f * f) * (3.0 - (2.0 * f)));\n  vec3 u1 = (1.0 - u);\n  return ((((((a1 * u1.x) + (b1 * u.x)) * u1.y) + (((c1 * u1.x) + (d1 * u.x)) * u.y)) * u1.z) + (((((a2 * u1.x) + (b2 * u.x)) * u1.y) + (((c2 * u1.x) + (d2 * u.x)) * u.y)) * u.z));\n}\nfloat noise_noise_white_1(vec2 p) {\n  return noise_hash1_2(p);\n}\nfloat noise_noise_value_1(vec3 p) {\n  vec3 i = floor(p);\n  vec3 f = fract(p);\n  vec3 j = (i + 1.0);\n  float a1 = noise_hash1_3(i);\n  float b1 = noise_hash1_3(vec3(j.x, i.y, i.z));\n  float c1 = noise_hash1_3(vec3(i.x, j.y, i.z));\n  float d1 = noise_hash1_3(vec3(j.x, j.y, i.z));\n  float a2 = noise_hash1_3(vec3(i.x, i.y, j.z));\n  float b2 = noise_hash1_3(vec3(j.x, i.y, j.z));\n  float c2 = noise_hash1_3(vec3(i.x, j.y, j.z));\n  float d2 = noise_hash1_3(j);\n  return noise_noisemix3(a1, b1, c1, d1, a2, b2, c2, d2, f);\n}\nfloat sphere_intersect(vec3 ro, vec3 rd, vec3 p, float r) {\n  vec3 oc = (ro - p);\n  float b = dot(oc, rd);\n  float c = (dot(oc, oc) - (r * r));\n  float h = ((b * b) - c);\n  if(h < 0.0) {\n    return -1.0f;\n  } else {\n    return ((-b) - sqrt(h));\n  }\n}\nfloat map(vec3 p) {\n  return (length(p) - 0.6);\n}\nfloat ray_march(vec3 ro, vec3 rd) {\n  float t = 0.0;\n  for(int i = 0; i < 128; i++) {\n    vec3 p = (ro + (t * rd));\n    float d = map(p);\n    if(d <= 0.0001) {\n      return t;\n    }\n    t = (t + d);\n    if(t > 10.0) {\n      return -1.0;\n    }\n  }\n  return -1.0;\n}\nfloat fbm3(vec3 p) {\n  float a = 1.0;\n  float t = 0.0;\n  t = (t + (a * noise_noise_value_1(p)));\n  a = (a * 0.5);\n  p = ((2.0 * p) + 100.0);\n  t = (t + (a * noise_noise_value_1(p)));\n  a = (a * 0.5);\n  p = ((2.0 * p) + 100.0);\n  t = (t + (a * noise_noise_value_1(p)));\n  a = (a * 0.5);\n  p = ((2.0 * p) + 100.0);\n  t = (t + (a * noise_noise_value_1(p)));\n  a = (a * 0.5);\n  p = ((2.0 * p) + 100.0);\n  t = (t + (a * noise_noise_value_1(p)));\n  a = (a * 0.5);\n  p = ((2.0 * p) + 100.0);\n  t = (t + (a * noise_noise_value_1(p)));\n  return t;\n}\nvec3 planet_palette(float x) {\n  vec3 col = vec3(0.1, 0.6, 0.9);\n  col = (col + (0.2 * sin(((6.28318531 * x) + vec3(0.3, 0.2, 0.1)))));\n  col = (col + (0.1 * sin(((14.4513262 * x) + vec3(0.1, 0.2, 0.3)))));\n  return col;\n}\nvec3 planet_color(vec3 p) {\n  p = (p * 2.0);\n  float t = iTime;\n  vec3 q = vec3((fbm3((p + (t * 0.03))) * 0.5), (fbm3(p) * 0.5), (fbm3((p + 33.33)) * 0.5));\n  vec3 r = vec3((fbm3(((p + q) + (t * 0.01))) * 0.5), (fbm3((p + q)) * 0.5), (fbm3(((p + q) + 33.33)) * 0.6));\n  float f = (fbm3(((p + (5.0 * r)) + (t * 0.02))) * 0.5);\n  vec3 col = planet_palette(r.y);\n  col = (col * ((clamp((f * f), 0.0, 1.0) * 0.9) + 0.1));\n  col = clamp(col, 0.0, 1.0);\n  return col;\n}\nvec3 shade(vec3 rd, vec3 p) {\n  vec3 normal = normalize(p);\n  float ambient_dif = 0.03;\n  vec3 dif = vec_tovec3(ambient_dif);\n  vec3 sun_dir = vec3(0.0, 0.0, 1.0);\n  vec3 sun_col = (vec3(1.0, 0.9, 0.9) * 4.0);\n  float sun_dif = clamp(((dot(normal, sun_dir) * 0.9) + 0.1), 0.0, 1.0);\n  dif = (dif + (sun_col * sun_dif));\n  vec3 mate = (planet_color(p) * 0.4);\n  vec3 col = (mate * dif);\n  float fres = clamp((1.0 + dot(normal, rd)), 0.0, 1.0);\n  float sun_fres = (fres * clamp(dot(rd, sun_dir), 0.0, 1.0));\n  col = (col * (1.0 - fres));\n  col = (col + ((pow(sun_fres, 8.0) * vec3(0.4, 0.3, 0.1)) * 5.0));\n  return col;\n}\nvec3 perspective_camera(vec3 lookfrom, vec3 lookat, float tilt, float vfov, vec2 uv) {\n  vec2 sc = sincos(tilt);\n  vec3 vup = normalize(vec3(sc.x, sc.y, 0.0));\n  vec3 w = normalize((lookat - lookfrom));\n  vec3 u = cross(w, vup);\n  vec3 v = cross(u, w);\n  float wf = (1.0 / tan(((vfov * 3.14159265) / 360.0)));\n  return normalize((((uv.x * u) + (uv.y * v)) + (wf * w)));\n}\nfloat expstep(float x, float k) {\n  return exp(((k * x) - k));\n}\nvec3 get_background(vec3 rd) {\n  vec3 sun_dir = vec3(0.0, 0.0, 1.0);\n  float sun_dif = dot(rd, sun_dir);\n  vec3 col = (vec3(1.0, 0.9, 0.9) * expstep(sun_dif, 600.0));\n  col = (col + (vec3(1.0, 1.0, 0.1) * expstep(sun_dif, 100.0)));\n  col = (col + (vec3(1.0, 0.7, 0.7) * expstep(sun_dif, 50.0)));\n  col = (col + (vec3(1.0, 0.6, 0.05) * expstep(sun_dif, 10.0)));\n  return col;\n}\nvec3 color_tonemap_aces(vec3 col) {\n  return clamp(((col * ((2.51 * col) + 0.03)) / ((col * ((2.43 * col) + 0.59)) + 0.14)), 0.0, 1.0);\n}\nvec3 color_saturate(vec3 col, float sat) {\n  float grey = dot(col, vec3(0.2125, 0.7154, 0.0721));\n  return (grey + (sat * (col - grey)));\n}\nvec3 color_tone_1(vec3 col, float gain, float lift, float invgamma) {\n  col = pow(col, vec_tovec3(invgamma));\n  return (((gain - lift) * col) + lift);\n}\nvec3 color_gamma_correction(vec3 col) {\n  return pow(col, vec_tovec3(0.454545455));\n}\nvec3 vignette(vec3 col, vec2 coord, float strength, float amount) {\n  return (col * ((1.0 - amount) + (amount * pow(((((16.0 * coord.x) * coord.y) * (1.0 - coord.x)) * (1.0 - coord.y)), strength))));\n}\nvec3 dither(vec3 col, vec2 coord, float amount) {\n  return clamp((col + (noise_noise_white_1(coord) * amount)), 0.0, 1.0);\n}\nvec3 sun_glare(vec3 rd) {\n  vec3 sun_dir = vec3(0.0, 0.0, 1.0);\n  vec3 glare_col = vec3(1.0, 0.6, 0.2);\n  return (glare_col * pow(max(dot(sun_dir, rd), 0.0), 2.0));\n}\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord) {\n  vec2 res = vec2(iResolution.x, iResolution.y);\n  vec2 mouse = vec2((iMouse.x / iResolution.x), (iMouse.y / iResolution.y));\n  vec2 coord = ((2.0 * (frag_coord - (res * 0.5))) / iResolution.y);\n  float theta = ((1.88495559 + (iTime * 0.2)) + (6.28318531 * mouse.x));\n  vec3 lookat = vec3(0.0, 0.0, 0.0);\n  vec2 sc = (sincos(theta) * 2.0);\n  vec3 ro = vec3(sc.x, 0.5, sc.y);\n  vec3 rd = perspective_camera(ro, lookat, 0.0, 50.0, coord);\n  float t = sphere_intersect(ro, rd, vec3(0.0, 0.0, 0.0), 0.6);\n  vec3 p = (ro + (rd * t));\n  vec3 col = get_background(rd);\n  float depth = 0.0;\n  if(t >= 0.0) {\n    col = shade(rd, p);\n  \tdepth = smoothstep(2.0, 2.0-0.6, t);\n  }\n  col = (col + (0.2 * sun_glare(rd)));\n  col = color_tonemap_aces(col);\n  col = color_tone_1(col, 1.7, 0.002, 1.2);\n  col = color_saturate(col, 0.9);\n  col = color_gamma_correction(col);\n  col = vignette(col, (frag_coord / res), 0.25, 0.7);\n  col = dither(col, frag_coord, 0.01);\n  frag_col = vec4(col.x, col.y, col.z, depth);\n}\n\n\n/** SHADERDATA\n{\n\t\"title\": \"Lone Planet and the Sun\",\n\t\"description\": \"A solitary blue planet in space\",\n\t\"model\": \"person\"\n}\n*/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}