{
    "Shader": {
        "info": {
            "date": "1639182866",
            "description": "(MOVE MOUSE TO SET S) this is the fractional julia for c = -2. The fractional iterate M[s] has a closed form. For other values of C there is no known closed form, and it is likely that there is none. Set the escape radius to 2 to see the regular julia.",
            "flags": 0,
            "hasliked": 0,
            "id": "7tKGDW",
            "likes": 12,
            "name": "closed fractional julia: c = -2",
            "published": 3,
            "tags": [
                "fractal",
                "julia",
                "fractional"
            ],
            "usePreview": 0,
            "username": "incription",
            "viewed": 262
        },
        "renderpass": [
            {
                "code": "#define ONE vec2(1., 0.)\n#define TWO vec2(2., 0.)\n\nfloat dot2(vec2 a) { return a.x * a.x + a.y * a.y; }\nvec2 c(float x){return vec2(x, 0.);}\nvec2 c_mul(vec2 a, vec2 b) {\n    return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);\n}\nvec2 c_div(vec2 a, vec2 b) {\n    return c_mul(a.yx,b.xy).yx/dot2(b);\n}\nvec2 c_exp(in vec2 a) {\n    float ea = exp(a.x);\n    float vl = a.y;\n    return ea * vec2( cos(vl), sin(vl) );\n}\nvec2 c_ln(in vec2 a) {\n    float ql = length(a);\n    return vec2( log(ql), atan(a.y, a.x));\n}\nvec2 c_pow(in vec2 a, in vec2 b) {\n    return c_exp(c_mul(c_ln(a), b));   \n}\nvec2 c_sqrt(vec2 a) {\n    return c_pow(a, c(.5));\n}\nvec2 c_cosh(vec2 a) {\n    return c_div( c_exp(a) + c_exp(-a), TWO);\n}\nvec2 c_acosh(vec2 z) {\n  return c_ln(z+c_mul(c_sqrt(z+vec2(1,0)),c_sqrt(z-vec2(1,0))));\n}\n\nvec2 Mint(vec2 x) { return c_mul(x, x) - TWO; }\n\nvec2 M(vec2 x, vec2 s) {\n    //float rt = 1.4142;\n    //vec2 sum = vec2(0);\n    //float[10] m = float[10](1., rt, -rt, rt - 2., 1., -rt, 1.-3./rt, rt-4., rt, -2.-rt);\n    //for(int i=0;i<5;i++){\n    //    float mult = m[i*2];\n    //    float power = m[i*2+1];\n    //    sum += c_mul( c(mult), c_pow( x, c(power)));\n    //}\n    //return sum;\n    //return c_mul(x, x) - c(2.);\n    //return c_mul( TWO, c_cosh( c_mul( TWO, c_acosh( c_div( x, TWO )))));\n    return c_mul( TWO, c_cosh( c_mul( c_pow(TWO, s), c_acosh( c_div( x, TWO )))));\n}\n\nfloat Miter(vec2 x, vec2 s, int iter) {\n    vec2 z = x; int i;\n    for(i=0;i<iter;i++) {\n        if(dot2(z) > 2000.) break; //iTime*100. -> ~2000 or 4.\n        z = M(z, s);\n    }\n    return float(i)/float(iter);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n    //uv *= iMouse.x/iResolution.x;\n    vec2 z = uv.xy * 4.;\n    vec2 s = 4. * (iMouse.xy/iResolution.xy - .5);\n    if (iMouse.xy==vec2(0)) s = vec2(.35-iTime/80., -2.63-iTime/60.);\n    int i = 100;\n    float iter = Miter(z, s, i);\n    \n    fragColor = vec4(vec3(iter), 0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}