{
    "Shader": {
        "info": {
            "date": "1580564919",
            "description": "Experiments with fields in 2D",
            "flags": 0,
            "hasliked": 0,
            "id": "wldXzN",
            "likes": 1,
            "name": "Field experiments",
            "published": 3,
            "tags": [
                "2d"
            ],
            "usePreview": 0,
            "username": "Shoseki",
            "viewed": 335
        },
        "renderpass": [
            {
                "code": "\nvec2 normalizeUV(vec2 fragCoord, vec3 iResolution) {\n    // Normalized pixel coordinates (from 0 to 1) taking into consideration resolution\n\tfloat minRes = iResolution.x;\n    if (iResolution.y < minRes) minRes = iResolution.y;\n    \n\treturn fragCoord.xy / minRes;\n}\nvec2 normalizeCenter(vec3 iResolution) {\n    float minRes = iResolution.x;\n    if (iResolution.y < minRes) minRes = iResolution.y;\n    return vec2((iResolution.x / minRes * 0.5), 0.5);\n}\n\n// Field 1 is to test generating a field centered, strength distance from center (animation to help visualize)\nfloat field(vec2 uv, vec2 centeruv, float iTime) {\n    vec2 uvOffset = vec2(uv.x - centeruv.x, uv.y - centeruv.y);\n    return (sqrt((uvOffset.x * uvOffset.x) + (uvOffset.y * uvOffset.y)) * 2.0) - (sin(iTime * 100.0 * 2.0 * 3.14159 / 360.0)/2.0);\n}\n// Field 2 is to test infinite xy field, pattern based on sin wave\nfloat field2(vec2 uv, vec2 centeruv, float iTime) {\n    return 0.50 - (sin(25.0 * uv.x + iTime) * sin(25.0 * uv.y + iTime)); \n}\n// Field 3 is to test morphing, manipulates position and feeds in second field\nfloat field3(vec2 uv, vec2 centeruv, float iTime) {\n    vec2 uvOffset = vec2(uv.x - centeruv.x, uv.y - centeruv.y);\n    \n    float l = (sqrt((uvOffset.x * uvOffset.x) + (uvOffset.y * uvOffset.y)) * 2.0);\n    float rotate = sin(iTime/50.0*l*3.14159*2.0);//cos(iTime);\n    \n    vec2 newUv = vec2(0.0, 0.0);\n    newUv.x = (uvOffset.x * cos(rotate)) - (uvOffset.y * sin(rotate));\n    newUv.y = (uvOffset.x * sin(rotate)) + (uvOffset.y * cos(rotate));\n    return field2(newUv, centeruv, iTime);\n}\n\nfloat modF(float value) {\n\tif (value < 0.0) value = - value;\n    return value;\n}\n\nfloat iso(float fieldValue, float desiredValue, float tolerance) {\n    float iso = 0.0;\n    float difference = desiredValue - fieldValue;\n    difference = modF(difference);\n    if (difference < tolerance) iso = 1.0- (difference/tolerance);\n    \n    return iso;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = normalizeUV(fragCoord, iResolution);\n    \n    vec2 centeruv = normalizeCenter(iResolution);\n    \n    float fieldValue = field3(uv, centeruv, iTime);\n    \n    float desiredValue =  1.0; // iTime / 10.0;\n    float tolerance = 0.25;\n    float isoValue = iso(fieldValue, desiredValue, tolerance);\n\n    float uniColour = 1.0;\n    \n    if (iMouse.z > 0.0) {\n     \tuniColour = isoValue;\n    }\n    else {\n        uniColour = fieldValue;\n        \n    }\n    // Output to screen\n    fragColor = vec4(uniColour, uniColour, uniColour, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}