{
    "Shader": {
        "info": {
            "date": "1520827824",
            "description": "More fun with the Hopf fibration vector field and gravitational lensing, check out <url=http://ebencowley.com/resources/docs/projects/anomaly.html>this version.[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "4dVcRR",
            "likes": 37,
            "name": "Magnetic Anomaly",
            "published": 3,
            "tags": [
                "fluid",
                "volumetric",
                "blackhole",
                "lensing"
            ],
            "usePreview": 0,
            "username": "Ebanflo",
            "viewed": 1525
        },
        "renderpass": [
            {
                "code": "//nebula params\n\n#define nebula\n\n#define marchingIters 20\n#define cloudBrightness 75.0\n#define rungeKuttaIters 5\n//vector field from https://en.wikipedia.org/wiki/Hopf_fibration#Fluid_mechanics\n#define A -75.75\n#define B 0.5\n\n//blackhole params\n\n#define blackhole\n#define lensing\n\n//4G/c^2 where G is the gravitational constant and c is the speed of light\n#define forGc2 2.970357293242085e-27\n#define blackholeMass 1e26\n#define blackholeRadius 0.5*forGc2*blackholeMass //Schwarschild radius\n\nconst float pi = 4.0*atan(1.0);\nconst float isqrt2 = inversesqrt(2.0);\n\nvec4 makeQuat(vec3 axis, float t){\n    t *= 0.5;\n    vec2 tr = sin(vec2(t, t + 0.5*pi));\n    return vec4(tr.x*normalize(axis), tr.y);\n}\n\nvec3 Rotate(vec4 q, vec3 v){\n    vec3 t = 2.*cross(q.xyz, v);\n    return v + q.w*t + cross(q.xyz, t);\n}\n\nvec3 r(vec3 v, vec2 r){\n    vec4 t = sin(vec4(r, r + 1.5707963268));\n    float g = dot(v.yz, t.yw);\n    return vec3(v.x * t.z - g * t.x,\n                v.y * t.w - v.z * t.y,\n                v.x * t.x + g * t.z);\n}\n\n//distance to inner ring of Hopf fibration (unit circle in xy pllane centered at origin)\nfloat dRing(vec3 p){return length(vec2(length(p.xy) - 1.0, p.y));}\n\nvec3 velocity(vec3 p){\n    float a = dRing(p);\n    float a2 = a*a;\n    float r = dot(p, p);\n    float ar = a2 + r;\n    return A*vec3(2.0*(-a*p.y + p.x*p.z), 2.0*(a*p.x - p.y*p.z), a - r)/(ar*ar);\n}\n\nfloat density(vec3 p){\n    float a = dRing(p);\n    return 3.0*B/(a*a + dot(p, p));\n}\n\nvec2 pressureAndDensity(vec3 p){\n    float d = density(p);\n    return vec2(-A*A*0.333333*d*d*d/(B*B), d);\n}\n\nvec2 logistic(vec2 v){\n    return vec2(16.0/(1.0 + 10.0*exp(-0.75*v.x)),\n                1.0/(1.0 + 10.0*exp(-1.95*v.y)));\n}\n\nvec3 gaussian(float x){\n    vec3 disp = x - vec3(0.3, 0.6, 0.9);\n    return exp(-16.0*disp*disp - 4.0);\n}\n\nvec3 makeColor(vec3 p){\n    vec2 pd = pressureAndDensity(p);\n    pd = logistic(pd);\n    return cloudBrightness*pd.y*gaussian(pd.x);\n}\n\nvec3 approxFlow(vec3 p, float t){\n    t /= float(rungeKuttaIters);\n    for(int i = 0; i < rungeKuttaIters; ++i) {\n        \tvec3 k1 = -velocity(p);\n        \tvec3 k2 = -velocity(p + 0.5*k1*t);\n        \tvec3 k3 = -velocity(p + 0.5*k2*t);\n\t        vec3 k4 = -velocity(p + k3*t);\n    \t    p += 0.161616*t*(k1 + 2.0*k2 + 2.0*k2 + k3);\n    }\n\t\n    return p;\n}\n\nvec3 interpolateColor(vec3 p){\n    float t1 = fract(0.5*iTime);\n    float t2 = fract(t1 + 0.5);\n    vec3 c1 = makeColor(approxFlow(p, t1 + 0.3));\n    vec3 c2 = makeColor(approxFlow(p, t2 + 0.3));\n    t1 = 2.0*abs(t1 - 0.5);\n    return mix(c1, c2, t1);\n}\n\nbool iBlackhole(vec3 ro, vec3 rd){\n    float loc = dot(rd, ro);\n    return loc*loc + 2.25*blackholeRadius*blackholeRadius > dot(ro, ro);\n}\n\nfloat dBlackholePlane(vec3 ro, vec3 rd, vec3 n){return -dot(ro, n)/dot(rd, n);}\n\nvec3 render(vec3 ro, vec3 rd){\n\n    vec3 nml = normalize(ro);\n\n    vec3 col = vec3(0);\n    bool hit = iBlackhole(ro, rd);\n    float plane = dBlackholePlane(ro, rd, nml);\n\n    float stepsize = 2.0*plane/float(marchingIters);\n\n    int fstIters = marchingIters/2;\n    #ifdef blackhole\n    if(hit) fstIters = marchingIters/2 - 1; //avoid rendering inside the blackhole\n    #endif\n\n    vec3 pos = ro + stepsize*rd;\n\n    #ifdef nebula\n    //march until the plane containing the blackhole center is reached\n\tfor(int n = 0; n < fstIters; n++){\n        col += interpolateColor(pos);\n        pos += stepsize*rd;\n    }\n    #endif\n    \n    #ifdef lensing\n    //then change direction\n    float r = length(pos);\n    vec3 axis = cross(pos, nml);\n    //angle of deflection is 4MG/(rc^2)\n    float angle = -forGc2*blackholeMass/r;\n    vec4 quaternion = makeQuat(axis, angle);\n    rd = Rotate(quaternion, rd);\n    #endif\n    \n    #ifdef blackhole\n    if(hit) return col;\n    #ifdef nebula\n    else {\n        for(int n = 0; n < marchingIters/2; n++){\n            col += interpolateColor(pos);\n\n            pos += stepsize*rd;\n        }\n    #endif\n    }\n    #else\n    for(int n = 0; n < marchingIters/2; n++){\n        col += interpolateColor(pos);\n        pos += stepsize*rd;\n    }\n    #endif\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    vec2 xy = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, -0.5*float(marchingIters)*blackholeRadius);\n    vec3 rd = normalize(vec3(xy, 2.5));\n    vec2 m = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n    m *= 2.0;\n    \n    rd = r(rd, m + 0.1*iTime);\n    ro = r(ro, m + 0.1*iTime);\n    fragColor.rgb = render(ro, rd);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}