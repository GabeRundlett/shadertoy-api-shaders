{
    "Shader": {
        "info": {
            "date": "1544809676",
            "description": "WIP.\nA mouse.x controlled lens to explore a signal, with high scale difference between the enveloppe and the sine.\n\nchallenge: having an antialiased curve when resolved, and the covered range where not resolve, all looking smooth.",
            "flags": 0,
            "hasliked": 0,
            "id": "3df3R8",
            "likes": 2,
            "name": "lens to explore signal",
            "published": 3,
            "tags": [
                "curve",
                "signal"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 461
        },
        "renderpass": [
            {
                "code": "// Fork of https://shadertoy.com/view/tdf3Rn 2018-12-14 17:20:39\n\nfloat F(float t) {\n    t = fract(t/2.)*2.;\n\treturn sin(440. * t * 6.28 )*exp(-6.*t);\n}\n\n//#define S(v) smoothstep( 1.5, 0., (v)/fwidth(v) )   \n#define S(v) smoothstep( 1.5*dp, 0., v )   \n    \nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, \n         D = vec2(0,R.y),\n         U = 2.* (2. * u - D ) / R.y,\n         M = 2.* (2. * iMouse.xy - D ) / R.y;\n    O -= O;\n    // -- auto-demo\n    if ( iMouse.xy == vec2(0) ) M.x = 3.+3.*sin(.1*iTime);\n    \n    float dp = 4./R.y,\n           m0 = 1e9, m1 = -m0, dm0 = m0, dm1 = -dm0,\n           z = U.x-M.x,\n           y, _y, dy;\n    \n    // --- lens\n    U.x -= z* (1.-.01) * smoothstep(2.,1.,abs(z));\n    //U.x -= z* (1.-.01) *(1.- exp(-1.*smoothstep(2.,1.,abs(z))))/(1.-exp(-1.));\n    dp = 2.*fwidth(U.x);\n    \n    // --- analyzing signal in the pixel column\n    for (float x=0.; x < dp ; x += 1e-5 ) {\n        _y = y; y = F(U.x+x);\n        if (x==0.) continue;\n        dy = y-_y;\n        m0 = min( m0, y );\n        m1 = max( m1, y );\n        dm0 = min( dm0, dy );\n        dm1 = max( dm1, dy );\n    }\n \n    y = (m0+m1)/2.;\n    float dm = (dm0+dm1)/2.;\n    \n    if ( dm1*dm0 > 0. ) { // --- resolved: draw antialiased curve\n     // z = U.y-y;\n     // vec2 T = vec2(dp,dm);\n     // O += S( abs(U.y-y) );\n     // dp=1., O += S( abs(U.y-y)/abs(dm) );\n     // dp=1., O += S( abs(U.y-y)/length(vec2(dFdx(U.y-y),dFdy(U.y-y))) );\n        dp=1., O += S( abs(U.y-y)/fwidth(U.y-y) );\n     // O += S ( .1*length( vec2(0,z) - z*dm/dot(T,T)*T ) );\n    }\n    else                  // --- not resolved: draw range\n        O += S( abs(U.y - (m0+m1)/2.) - (m1-m0)/2. );\n    \n    // interface ( to help figure the lens )\n    if (abs(U.y)>1.) O.g += .5+.5*sin(R.y/6.*U.x);\n    else             O.b += smoothstep(2.,1.,abs(z));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}