{
    "Shader": {
        "info": {
            "date": "1572576549",
            "description": "Simple reflections with some sort of fresnel effect",
            "flags": 0,
            "hasliked": 0,
            "id": "tdcSz2",
            "likes": 3,
            "name": "Jake's RayTracer Reflection test",
            "published": 3,
            "tags": [
                "reflection",
                "raytracer"
            ],
            "usePreview": 0,
            "username": "JakeLockey",
            "viewed": 246
        },
        "renderpass": [
            {
                "code": "vec3 pixCol = vec3(0.0,0.0,0.0);\n\nstruct Light{\n    vec3 pos;\n};\nLight light = Light(vec3(-5.0,0.0,10.0));\n    \nstruct Camera{\n    vec3 pos;\n    vec3 dir;\n};\nCamera Cam = Camera(vec3(-10.0,10.0,8.0),vec3(0.0,-1.0,-0.9));\n\nstruct Sphere{\n    vec3 pos;\n    float r;\n    vec3 col;\n};\nSphere S1 = Sphere(vec3(0.0,0.0,1.0),1.0,vec3(0.8,0.8,0.8));\nSphere S2 = Sphere(vec3(3.0,3.0,2.0),1.0,vec3(0.8,0.8,0.8));\nSphere S3 = Sphere(vec3(-3.0,-3.0,2.0),1.0,vec3(0.8,0.8,0.8));\n\nstruct Triangle{\n    vec3 Vert1;\n    vec3 Vert2;\n    vec3 Vert3;\n    vec3 col;\n};\nTriangle T1 = Triangle(vec3(5.0,5.0,-1.0), vec3(5.0,-5.0,-1.0), vec3(-5.0,5.0,-1.0), vec3(0.7,0.7,0.7));\nTriangle T2 = Triangle(vec3(5.0,-5.0,-1.0), vec3(-5.0,-5.0,-1.0), vec3(-5.0,5.0,-1.0), vec3(0.8,0.8,0.8));\nTriangle T3 = Triangle(vec3(-5.0,5.0,-1.0), vec3(5.0,-5.0,-1.0), vec3(5.0,5.0,-1.0), vec3(0.7,0.7,0.7));\nTriangle T4 = Triangle(vec3(-5.0,5.0,-1.0), vec3(-5.0,-5.0,-1.0), vec3(5.0,-5.0,-1.0), vec3(0.8,0.8,0.8));\n    \nstruct SceneObjects{\n    Sphere[3] spheres;\n    Triangle[4] triangles;\n};\nSceneObjects objects;\n\n\nvec3 checkCollide(vec3 Origin, vec3 rayDir){\n    float closestP = -1.0;\n    int objectNum = -1;\n    int SphereOrTriangle = -1;\n    for(int i = 0; i<objects.spheres.length(); i++){\n        Sphere tempS = objects.spheres[i];\n        \n        vec3 L = (tempS.pos-Origin);\n    \tfloat tca = dot(L,rayDir);\n    \n    \n    \tif(tca<=0.0){\n    \t   \tcontinue;\n    \t}\n        \n        float d = sqrt(abs(dot(L,L)-(tca*tca)));\n        \n        if(length(L)-tca<0.00000000001){\n            d=0.00000000001;\n        }\n    \n    \tif(d>=tempS.r){\n    \t    continue;\n    \t}\n    \n    \tfloat thc = sqrt((tempS.r*tempS.r)-(d*d));\n        float distToPoint= 0.0;\n        \n        if(abs(d)<=0.0){\n            \n        }\n        else{\n            distToPoint= tca-thc;\n        }\n    \t\n        \n        if(i==0||closestP==-1.0){\n            closestP = distToPoint;\n            SphereOrTriangle = 0;\n        \tobjectNum = i;\n        }\n        else if(distToPoint<closestP){\n            closestP = distToPoint;\n            SphereOrTriangle = 0;\n        \tobjectNum = i;\n        }\n    \t\n    }\n    \n    for(int i = 0; i<objects.triangles.length(); i++){\n        Triangle tempT = objects.triangles[i];\n        \n        vec3 normal = cross((tempT.Vert1-tempT.Vert2),(tempT.Vert1-tempT.Vert3));\n        \n        //Test if ray is parallel to plane \n        if(dot(rayDir,normal)<0.001){\n            continue;\n        }\n        \n        vec3 p0l0 = tempT.Vert1 - Origin;\n        \n        //Dist to Intersection Point on plane\n        float distToPoint = dot(p0l0,normal) / dot(rayDir,normal);\n        if(distToPoint<0.0){\n            continue;\n        }\n        \n        vec3 P = Origin + rayDir*distToPoint; //Point of intersection\n        \n        //Check to see if ray is within the triangle\n        vec3 C;\n        //edge 1\n        vec3 edge1 = tempT.Vert2 - tempT.Vert1;\n\t\tvec3 vp1 = P - tempT.Vert1;\n        C = cross(edge1,vp1);\n        if(dot(normal,C)<0.0){\n            continue;\n        }\n        //edge 2\n        vec3 edge2 = tempT.Vert3 - tempT.Vert2;\n\t\tvec3 vp2 = P - tempT.Vert2;\n        C = cross(edge2,vp2);\n        if(dot(normal,C)<0.0){\n            continue;\n        }\n        //edge 3\n        vec3 edge3 = tempT.Vert1 - tempT.Vert3;\n\t\tvec3 vp3 = P - tempT.Vert3;\n        C = cross(edge3,vp3);\n        if(dot(normal,C)<0.0){\n            continue;\n        }\n        \n        \n        \n        if(closestP==-1.0){\n            closestP = distToPoint;\n            SphereOrTriangle = 1;\n        \tobjectNum = i;\n        }\n        else if(distToPoint<closestP){\n            closestP = distToPoint;\n            SphereOrTriangle = 1;\n        \tobjectNum = i;\n        }\n        \n    }\n    \n    return vec3(closestP,SphereOrTriangle,objectNum);\n       \n}\nbool checkShadow(vec3 P){\n    vec3 ray = light.pos-P;\n    vec3 rayDir = ray/length(ray);\n    //P = P-(0.00001*rayDir);\n    \n    \n    float distToPoint = checkCollide(P,rayDir).x; //Checks collison to light\n    \n    //If the ray has collided, and it is closer than the light source\n    if(distToPoint!=-1.0 && length(ray)>distToPoint){ \n        return true;\n    }\n    return false;\n}\n\nvoid reflectRays(vec3 P, vec3 rayDir, vec3 n){\n    \n    //vec3 nextNorm = vec3(0.0,0.0,0.0);\n    //vec3 nextP = vec3(0.0,0.0,0.0);\n    \n    float angOfInc = -asin(abs(dot(n,rayDir)))-0.0;\n    float fresnel = pow(10.0,angOfInc);\n    \n    for(float refNum = 0.0; refNum<100.0; refNum+=1.0){\n        vec3 refRay = reflect(rayDir,n)/length(reflect(rayDir,n));\n        \n        vec3 Collision = checkCollide(P,refRay);\n        if(Collision.x>0.0){\n            if(int(Collision.y)==0){ //Sphere\n                Sphere tempS = objects.spheres[int(Collision.z)];\n                \n                P = P + (refRay*Collision.x);\n                n = (tempS.pos-P)/length(tempS.pos-P);\n                P = P + n*(0.00001);\n                //if(checkShadow(P)){ //Checks if in shadow\n            \t//\tpixCol = pixCol/3.0;\n        \t\t//}\n                \n                \n                pixCol = mix(pixCol,texture(iChannel1,vec3(n.x,-n.z,n.y)).xyz,fresnel);\n\t\t\t\t\n            }\n            if(int(Collision.y)==1){ //Triangle\n                Triangle tempT = objects.triangles[int(Collision.z)];\n                \n                P = P + (refRay*Collision.x);\n                n = cross((tempT.Vert1-tempT.Vert2),(tempT.Vert1-tempT.Vert3));\n                n = n/length(n);\n                P = P + n*(-0.00001);\n               \n                pixCol = mix(pixCol,tempT.col,fresnel);\n                //if(checkShadow(P)){ //Checks if in shadow\n            \t//\tpixCol = pixCol/3.0;\n        \t\t//}\n                //return;\n                \n            }\n            \n            \n            \n        }\n        else{\n            pixCol =  mix(pixCol,texture(iChannel0,vec3(refRay.x,refRay.z,refRay.y)).xyz,fresnel);\n            return;\n        }\n        rayDir = refRay;\n        angOfInc = -asin(abs(dot(n,refRay)))-0.0;\n        fresnel = pow(10.0,angOfInc)*fresnel;\n    }\n}\n\n\n\nvoid castRay(vec2 xy){\n    float ratio = Cam.dir.z/length(Cam.dir.xy);\n    vec3 VertPerp = vec3(-Cam.dir.x*ratio, -Cam.dir.y*ratio, length(Cam.dir.xy));\n    vec3 yComp = VertPerp * xy.y;\n    \n    vec3 HoriPerp = vec3(Cam.dir.y,-Cam.dir.x,0.0)/length(vec3(Cam.dir.y,-Cam.dir.x,0.0));\n    vec3 xComp = HoriPerp * xy.x;\n    \n    vec3 ray = (Cam.dir*3.0)+xComp+yComp;\n    vec3 rayDir = (ray/length(ray));\n    \n    vec3 Collision = checkCollide(Cam.pos,rayDir);\n    if(Collision.x>0.0){\n        if(int(Collision.y)==0){ //Sphere\n            Sphere tempS = objects.spheres[int(Collision.z)];\n            \n            vec3 P1 = Cam.pos + (rayDir*Collision.x);\n            vec3 normal = (tempS.pos-P1)/length(tempS.pos-P1);\n            P1 = P1 + normal*(0.00001);\n            \n        \tpixCol = texture(iChannel1,vec3(normal.x,-normal.z,normal.y)).xyz;\n            \n            //if(checkShadow(P1)){ //Checks if in shadow\n            //\tpixCol = pixCol/3.0;\n        \t//}\n            reflectRays(P1,rayDir,normal);\n        \t\n        }\n        if(int(Collision.y)==1){ //Triangle\n            Triangle tempT = objects.triangles[int(Collision.z)];\n            pixCol = tempT.col;\n            vec3 P1 = Cam.pos + (rayDir*Collision.x);\n            vec3 normal = cross((tempT.Vert1-tempT.Vert2),(tempT.Vert1-tempT.Vert3));\n            normal = normal/length(normal);\n            P1 = P1 + normal*(-0.00001);\n            //if(checkShadow(P1)){ //Checks if in shadow\n           \t//\tpixCol = pixCol/3.0;\n        \t//}\n            reflectRays(P1,rayDir,normal);\n        \t\n        }\n    }\n    else{\n        pixCol=texture(iChannel0,vec3(rayDir.x,rayDir.z,rayDir.y)).xyz;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 LookAt = vec3(0.0,0.0,1.0);\n    Cam.pos.x =\t12.0*cos(iTime/2.0);\n    Cam.pos.y = 12.0*sin(iTime/2.0);\n    Cam.dir = (LookAt-Cam.pos)/length(LookAt-Cam.pos);\n    \n    \n    \n    light.pos = vec3(75,0.0,75);\n    \n    \n    //light.pos = vec3(100.0*sin(iTime/5.0),0.0,100.0-abs(100.0*sin(iTime/5.0)));\n    //S2.pos = vec3(4.2*sin(iTime),4.2*cos(iTime),2.0);\n    //S3.pos = vec3(-4.2*sin(iTime),-4.2*cos(iTime),2.0);\n    \n    Sphere[3] spheres = Sphere[](S1,S2,S3);\n\tTriangle[4] triangles = Triangle[](T1,T2,T3,T4);\n    \n    \n    objects = SceneObjects(spheres,triangles);\n    \n    \n    vec2 xy = vec2((2.0*(iResolution.x/iResolution.y)) * fragCoord.x/iResolution.x - (iResolution.x/iResolution.y), 2.0 * fragCoord.y/iResolution.y - 1.0);\n    \n    vec3 col = vec3(0.0,0.0,0.0);\n    float AA = 4.0;\n    \n    for(float i = -0.5+(0.5/(AA/sqrt(AA))); i<0.5; i+=1.0/(AA/sqrt(AA))){\n        for(float j = -0.5+(0.5/(AA/sqrt(AA))); j<0.5; j+=1.0/(AA/sqrt(AA))){\n    \t\tcastRay(xy + vec2(i/iResolution.x,j/iResolution.y));\n    \t\tcol+=pixCol;\n        }\n    }\n\n  \t\n    col = col/AA;\n   \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            }
        ],
        "ver": "0.1"
    }
}