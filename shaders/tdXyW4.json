{
    "Shader": {
        "info": {
            "date": "1584782781",
            "description": "Check this page to see what is under the hood: https://github.com/ssloy/tinykaboom/wiki",
            "flags": 0,
            "hasliked": 0,
            "id": "tdXyW4",
            "likes": 9,
            "name": "tinykaboom tutorial",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "raymarching",
                "sdf",
                "tutorial",
                "animation"
            ],
            "usePreview": 0,
            "username": "haqreu",
            "viewed": 1052
        },
        "renderpass": [
            {
                "code": "uint[] jfig_bitfield = uint[]( 0x0u,0x0u,0x0u,0xf97800u,0x90900u,0xc91800u,0x890900u,0xf90900u,0x180u,0x0u,0x30e30e0u,0x4904900u,0x49e49e0u,0x4824820u,0x31e31e0u,0x0u,0x0u,0x0u );\nbool jfig(in uint x, in uint y) {\n    if (x>=32u || y>=18u) return false;\n    uint id = x + (17u-y)*32u;\n    return 0u != (jfig_bitfield[id/32u] & (1u << (id&31u)));\n}\n\nconst float sphere_radius   = 1.5;\nconst float noise_amplitude = 1.0;\n\nfloat hash(const float n) {\n    float x = sin(n)*43758.5453;\n    return x-floor(x);\n}\n\nfloat noise(in vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = x - p;\n    f = f * dot(f, vec3(3.0,3.0,3.0)-2.0*f);\n    float n = dot(p, vec3(1.0, 57.0, 113.0));\n    return mix(mix(mix(hash(n +  0.0), hash(n +  1.0), clamp(f.x,0.,1.)),\n                   mix(hash(n + 57.0), hash(n + 58.0), clamp(f.x,0.,1.)),\n                   clamp(f.y,0.,1.)),\n               mix(mix(hash(n + 113.0), hash(n + 114.0), clamp(f.x,0.,1.)),\n                   mix(hash(n + 170.0), hash(n + 171.0), clamp(f.x,0.,1.)),\n                   clamp(f.y,0.,1.)),\n               clamp(f.z,0.,1.));\n}\n\nvec3 rotate(in vec3 v) {\n    return vec3(dot(v, vec3( 0.0,  0.8,   0.6)),\n                dot(v, vec3(-0.8,  0.36, -0.48)),\n                dot(v, vec3(-0.6, -0.48,  0.64)));\n}\n\nfloat fractal_brownian_motion(in vec3 x) {\n    vec3 p = rotate(x);\n    float f = 0.0;\n    f += 0.5000*noise(p); p = p*2.32;\n    f += 0.2500*noise(p); p = p*3.03;\n    f += 0.1250*noise(p); p = p*2.61;\n    f += 0.0625*noise(p);\n    return f/0.9375;    \n}\n\nvec3 palette_fire(in float d) {\n    const vec3 yellow   = vec3(2.7, 2.3, 2.0); // note that the color is \"hot\", i.e. has components >1\n    const vec3 orange   = vec3(2.0, 1.6, 0.0);\n    const vec3 red      = vec3(1.5, 0.0, 0.0);\n    const vec3 darkgray = vec3(0.2, 0.2, 0.2);\n    const vec3 gray     = vec3(0.4, 0.4, 0.4);\n    float x = max(0.0, min(1.0, d));\n    if (x<.25f)\n        return mix(gray, darkgray, x*4.f);\n    else if (x<.5f)\n        return mix(darkgray, red, x*4.f-1.f);\n    else if (x<.75f)\n        return mix(red, orange, x*4.f-2.f);\n    return mix(orange, yellow, x*4.f-3.f);\n}\n\nfloat signed_distance(in vec3 p) {\n    float displacement = -fractal_brownian_motion(p*3.4 + vec3(0.1, 0.1, 0.1)*iTime)*noise_amplitude;\n    return length(p) - (sphere_radius + displacement) * (0.1 + 0.9*sin(mod(iTime*(2./3.1416), 3.1416/2.)));\n}\n\nbool sphere_trace(in vec3 orig, in vec3 dir, out vec3 pos) {\n    if (dot(orig,orig) - dot(orig,dir)*dot(orig,dir) > sphere_radius*sphere_radius)\n        return false;\n    pos = orig;\n    for(int i = 0; i < 128; i++) {\n        float d = signed_distance(pos);\n        if (d < 0.0) return true;\n        pos = pos + dir*max(d*0.1, 0.01);\n    }\n    return false;\n}\n\nvec3 distance_field_normal(in vec3 pos) {\n    const float eps = 0.1;\n    float d  = signed_distance(pos);\n    float nx = signed_distance(pos + vec3(eps, 0.0, 0.0)) - d;\n    float ny = signed_distance(pos + vec3(0.0, eps, 0.0)) - d;\n    float nz = signed_distance(pos + vec3(0.0, 0.0, eps)) - d;\n    return normalize(vec3(nx, ny, nz));\n}\n\nvec3 rotate_camera(in vec3 orig, in vec3 dir, in vec3 target) {\n    vec3 zAxis = normalize(orig - target);\n    vec3 xAxis = normalize(cross(vec3(0., 1., 0.), zAxis));\n\tvec3 yAxis = normalize(cross(zAxis, xAxis));\n   \tmat4 transform = mat4(vec4(xAxis, 0.), vec4(yAxis, 0.), vec4(zAxis, 0.), vec4(orig, 1.));\n    return (transform * vec4(dir, 0.)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    const float fov = 3.1416 / 3.;\n    vec2 uv = ( 2.*fragCoord - iResolution.xy ) / iResolution.y*tan(fov/2.); \n\n    vec3 orig = vec3(-sin(iTime)*3., 0., cos(iTime)*3.);\n    vec3 dir = normalize(vec3(uv, -1));\n\tdir = rotate_camera(orig, dir, vec3(0.));\n\n    vec3 hit;\n    if(sphere_trace(orig, dir, hit)) {\n        float noise_level = (sphere_radius - length(hit))/noise_amplitude;\n        vec3 light_dir = normalize((vec3(10.0, 10.0, 10.0) - hit));\n        float light_intensity = max(0.4, dot(light_dir, distance_field_normal(hit)));\n        fragColor = vec4(palette_fire(2.0*(-0.2+noise_level))*light_intensity, 1.0);\n    } else\n        fragColor = texture(iChannel0, dir);\n    vec2 coord = fragCoord/iResolution.xy*vec2(32u, 18u)*6.;\n    if (jfig(uint(coord.x), uint(coord.y)))\n        fragColor.xyz += vec3(.5);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 27,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}