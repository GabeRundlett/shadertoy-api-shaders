{
    "Shader": {
        "info": {
            "date": "1502438870",
            "description": "mouse.xy does things.\n\ni know there are reasonable specializations here, but i do not care, for now.",
            "flags": 0,
            "hasliked": 0,
            "id": "MsSfD3",
            "likes": 5,
            "name": "uneven T L corner, laplachian",
            "published": 3,
            "tags": [
                "t",
                "bisymmetry",
                "laplachian"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 932
        },
        "renderpass": [
            {
                "code": "//only one domain stretches, more values cancel out.\n#define mode 3\n\n//mode==0 iMouse.xy sets 2 straight lengths, distance to vec2(0)==1\n//mode==1 iMouse.y  sets 1 straight length , distance to vec2(0)==1\n//mode==2 iMouse.y  sets 1 straight length , distance to vec2(0)==mouse.y\n//mode==3 iMouse.y  sets 1 straight length , distance to vec2(0)==mouse.y\n\n//difference between mode2 and mode 3 is \n//the end end of the cane is at mouse position\n//mode2 is simpler, mode 3 is more intuitive\n\n/*\nAfter days of silly i learned a new trick:\n\nif(you have a min() somewhere:\n- that means there is a \"green line\"\n- ...where the distance to 2 impicit shapes is (almost) equal.\n- splitline() caculates that green line, it is a differential; a-b;\n- This differential can be used as a branch condiion. if(a-b>0.)\n- ... or with heuristics: if(abs(a-b)<epsilon)\n- This branch can be made branchless.\n- This usually does not reduce much, but it DOES reduce a little bit, \n- ...utilizing a bit more symmetry in jj()\n\n- It sure looks a lot more impressive than it really is.\n- but really, this has applications in trickier shapes\n- and shapes that are min() of more shared factors.\n\n- This goes towards an approach that might use more memory,\n- ... and that likely performs faster on newer hardware.\n*/\n\n\n#define frame(u) (u-.5*iResolution.xy)*25./iResolution.y\n\n//#define stretch(c,m) v=mix(v-m,mix(0.,v,step(v,0.)),step(v,m));\n//stretch      ; centric, most commonly used, therefore atomic\n#define mStretch(u,m) .5*(sign(u)*m-u)*((sign(abs(u)-m))+1.)\n//stretch nimus; positive values do not change\n#define mStretchM(u,m) mStretch((u*2.+m),m)*.5\n//vec2  mStretchM(vec2  u,vec2  m){m*=.5;u= u+m;return  mStretch(u,m);}\n//stretch plus ; negative values do not change\n#define mStretchP(u,m) mStretch((u*2.-m),m)*.5\n//based on #define analstretching(u,m) mix(u-m,mix(vec2(0.),u,step(u,vec2(0.))),step(u,m))\n//above is special case that can include the sat() generalization below +u.x;\n//a generalization of clamp(a,0.,1.); for m=vec2(1)\nfloat sat(float a,vec2 m){    \n a=.5*(sign(a)+m.x)*a+m.y;\n a=(sign(2.-a)+1.)*(a-2.)+2.; \n return a*.5;}\nfloat sat(float a){return sat(a,vec2(1));}//return clamp(a,0.,1.); \n\n\n#define dd(a) dot(a,a)\n/*\nfloat jj(vec2 u,vec4 m){\n if(u.x>0.&&u.y<0.)return abs(length(u)-1.);\n //lower right quadrant is much simpler, varrants the above shortcut\n //above length() is wrapped by abs(), can not simplify anyways.\n float a=mStretch((u.y*2.-m.y),m.y)*.5,//one     relevant shape remains\n b=mStretch((u.x*2.+m.x),m.x)*.5,      //another relevant shape remains\n s=sign(b*b+u.y*(u.y+2.)-a*a-u.x*(u.x-2.))+1.;//see splitline()\n //s==sign(difference between 2 squared distances to 2 shapes)+1.\n vec2 c=vec2(u.x-1.,a),d=vec2(b,u.y+1.);//2* shape distances.xy\n return length(d+.5*s*(c-d));} //length() is delayed till the end.\n//see https://www.shadertoy.com/view/XsSBDc\n//special case of jj() where m.x=0.;\nfloat jj1(vec2 u,vec4 m){\n if(u.x>0.&&u.y<0.)return abs(length(u)-1.);\n //lower right quadrant is much simpler, varrants the above shortcut\n //above length() is wrapped by abs(), can not simplify anyways.\n float a=mStretch((u.y*2.-m.y),m.y)*.5,//one     relevant shape remains    \n s=sign(u.y*(u.y+2.)-a*a+2.*u.x)+1.;//see splitline()\n vec2 c=vec2(u.x-1.,a),d=vec2(u.x,u.y+1.);//2* shape distances.xy\n return length(d+.5*s*(c-d));} //length() is delayed till the end.\n//m.x sets distance to vec2(0); m.y sets height;\nfloat jj2(vec2 u,vec4 m){\n if(u.x>0.&&u.y<0.)return abs(length(u)-m.x);\n float i=mStretch((u.y*2.-m.y),m.y)*.5;\n float a=dd(vec2(u.x-m.x,i)),b=dd(vec2(u.x,u.y+m.x));\n a-=b;return sqrt(b+.5*(1.-sign(a))*a);}//return sqrt(min(a,b))\n////see https://www.shadertoy.com/view/XsSBDc\n\n\n//splitline() visualizes a gree line \n//...where distances to 2 shapes is roughlty equal.\nfloat splitline(vec2 u,vec4 m){\n float a=dd(vec2(u.x-1.,mStretchP(u.y,m.y)));//one shape\n float b=dd(vec2(mStretchM(u.x,m.x),u.y+1.));//another shape\n return mStretchM(u.x,m.x)*mStretchM(u.x,m.x)+u.y*(u.y+2.) //squared distance\n       -mStretchP(u.y,m.y)*mStretchP(u.y,m.y)-u.x*(u.x-2.);}//minus squared distance\n\n//splitline1() is , splitline() special case where m.x=0;\n//...where distances to 2 shapes is roughlty equal.\nfloat splitline1(vec2 u,vec4 m){m=abs(m);//m.x=0.;\n float a=mStretch((u.y*2.-m.y),m.y)*.5;;//one shape\n return 2.*(u.y+u.x)+u.y*u.y-a*a;}\n*/\n\n#define modeT\n\nfloat TT(vec2 u,vec4 m){\n #ifdef modeT\n float a=dd(vec2(mStretch (u.x,m.x),u.y));\n #else\n float a=dd(vec2(mStretchM(u.x,m.x),u.y));\n #endif\n float b=dd(vec2(u.x,mStretchM(u.y,m.y)));\n //return sqrt(min(a,b));}\n a-=b;return sqrt(+b+.5*a*(1.-sign(a)));}\n\nfloat TTb(vec2 u,vec4 m){\n #ifdef modeT\n float a=dd(vec2(mStretch (u.x,m.x),u.y));\n #else\n float a=dd(vec2(mStretchM(u.x,m.x),u.y));\n #endif\n float b=dd(vec2(u.x,mStretchM(u.y,m.y)));\n float z=5.;\n return 1.-(abs(a-b))/length(m.xy);\n //if(abs(a-b)>1.) return 1.; return 0.;\n}\n\nfloat TT1(vec2 u,vec4 m){\n m.y=m.x;\n #ifdef modeT\n float a=dd(vec2(mStretch (u.x,m.x),u.y));\n #else\n float a=dd(vec2(mStretchM(u.x,m.x),u.y));\n #endif\n float b=dd(vec2(u.x,mStretchM(u.y,m.x)));\n //return sqrt(min(a,b));}\n a-=b;return sqrt(+b+.5*a*(1.-sign(a)));}\n\n\nvoid mainImage(out vec4 O,in vec2 U){\n vec2 u=frame(U); \n vec4 m=vec4(frame(iMouse.xy),frame(iMouse.zw));\n if(iMouse.z<0.)m.xy=(vec2(sin(iTime),cos(iTime*1.61))*.5+.5)*9.;\n u.y-=9.;\n m.y-=9.;\n m=abs(m);\n float r=TT(u,m);\n float g=TTb(u,m);//abs(splitline1(u,m));\n\n r=fract(r-.2);\n u.x=fract(u.x)*.3;\n g*=(sin(iTime*3.)*.5+.5);\n vec3 c=vec3(r,g,u.x);\n  \n O= vec4(c,1);\n}\n\n\n/*\nthe BISYMETRY PRINCIPLE: v2\n- In a quest to increase symmetry for performance and modular shaders. (in contextual biases)\n- - utilize  https://en.wikipedia.org/wiki/List_of_planar_symmetry_groups\n- - utilize linear-algebra-deformed mirror borders that define branches.\n- - Only write atomic special cases and transformations, \n- - ...to construct general functions from.\n- - Instead of writing a general function, \n- - ...to be fed with a lot of parameters set to 0 or 1 to turn them into \"special cases\"\n- - this way general functions can be made into special \"shortcut\" functions more easily.\n- - this way special functions can more easily be extended, generalized.\n...\n- it appears the \"ideal bisymmetrically optimized function looks something like this:\nfloat demo(vec2 u,vec4 m){//u= uv fragment position; m=iMouse.xyzw both likely transformed\n u.x=abs(u.x-1.); u.y=-u.y*.5; //symmetry modifiers are likely \"outsourced\"\n float a=sign(m.x-1.)+1.;\n float b=sign(m.y+1.)+u.x;\n float c=sign(m.z+m.x)-m.y;\n float c=-sign(m.z-u.x);\n //above are all sign-factors, below is the final binomial, both rarely are shared subroutines.\n return u.x*(a+b)*(c+2.)*d*0.5-u.y//the *.5 and -u-y can likely be \"outsourced\"\n}\n- how you transform binomials and branches depends on the bias from your context.\n- in general, it makes sense to delay sqrt() or length() as much as possible.\n- ... while also keeping brnches that are shortcuts \n- ... eg: usually abs(length()) begs to be a shortcut.\n...\n- this whole PRINCIPLE screams FRACTAL and SUPERPRIM ! \n- - https://www.shadertoy.com/results?query=superprim\n- this PRINCIPLE more easily delays sqrt() or length() till the end of a function, \"outsource\"able\n\nHOW TO\n- rearrange your branches so that sqrt() or length() is delayed as much as possible.\n- abs(length()) can not be delayed, therefore it may as well be treated as a shortcut.\n- ... meaning, if(your shape contains abs(length())) that branch stays as if() branch!\n- all other brahcnes usually end up being equally omplex trees of equally complex branches.\n- in that case, an openCL coders eyes open to reveal how to make long pipelines:\n- Substitute functions with identities to reveal their underlying bisymmetries.\n- - substitute max() to if()then() to mix(step)) to mix(sign()) to sums of sign()\n- - - for details on identities see - https://www.shadertoy.com/view/ldBfzc\n- - because there is often a lot of symmetry performance \"lost\" in if-branches, or max()=-min(-)\n- End up precalculating the specifics of a function, \n- Get a sum that you can easily modify \n- transform the sum into binominals of precalculated variabls, that make sense in the context.\n- - this is \"ultimate code golf\", as the best soluion depends on the functions context.\n- Modify underliing partial simple bisymmetries of the functions \"specifics\"\n- Bisymmetry turns out to be mostly about (mutually exclusive matrices of) Binimials.\n...\n- Using only fullRotation*N/24 , makes it more likely that terms cancel each other out.\n- if (symmetry) 2 symmetric subroutine-values tend to cancel factors out, \n- ... down to sign(a)*sign(a)=1.\n- Your function(s) turns into a \"family of bisymmetrical functions\" \n- ... that are more easily generalized or specialized.\n- ... that are more easily made work-save against undefineds like: \n- ... a=atan(0.,0.)*tan(acos(.0))*log2(0.)*pow(0,0)*a/0.\n*/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}