{
    "Shader": {
        "info": {
            "date": "1653248040",
            "description": "Black Hole",
            "flags": 0,
            "hasliked": 0,
            "id": "7ddyzn",
            "likes": 13,
            "name": "Black Hole - Spi3lot",
            "published": 3,
            "tags": [
                "space",
                "einstein",
                "newton",
                "hole",
                "horizon",
                "black",
                "relativity",
                "event",
                "theory",
                "general",
                "mass",
                "telescope",
                "m87",
                "sagittarius",
                "messier"
            ],
            "usePreview": 0,
            "username": "Spi3lot",
            "viewed": 398
        },
        "renderpass": [
            {
                "code": "// OUTDATED: Black hole - Curve light ray with REFRACTION -> distance/mass to the BH as eta (n1/n2)\n// CURRENT: Black hole - Curve light ray with normal of the black hole -> newton\n\n\n\n// CONSTANTS\n#define PI 3.1415926535\n#define TAU 2.0 * PI\n\n\n// RAY MARCHING SETTINGS\n#define EPSILON 0.001\n#define STEP_SIZE 0.1 * dS\n#define MAX_STEPS 10000\n#define MAX_DIST 1000.0\n\n#define ZOOM 1.0\n#define DISTANCE 7.0\n\n\n// BLACK HOLE SETTINGS\n#define CENTER vec3(0,0,0)\n#define RADIUS 0.8\n#define MASS 0.5\n\n#define ACCRETION_DISK_INNER_RADIUS 0.0\n#define ACCRETION_DISK_OUTER_RADIUS 4.0\n#define ACCRETION_DISK_SPEED 0.25\n\n#define GLOW\n#define TRANSLUCENT_ACCRETION_DISK\n#define MAX_ACCRETION_DISK_PENETRATIONS 10\n\n#define GRAVITATIONAL_LENSING\n\n\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdDisk(vec3 p)\n{\n    //float torus = sdTorus(p, vec2(2.6 * RADIUS, 25.0 * RADIUS));\n    float torus = sdTorus(p, vec2(ACCRETION_DISK_INNER_RADIUS, ACCRETION_DISK_OUTER_RADIUS));\n    float plane = abs(p.y);\n\n    return max(torus, plane);\n }\n\nfloat sdBlackHole(vec3 p)\n{\n    return length(p - CENTER) - RADIUS;\n}\n\nfloat GetDist(vec3 p)\n{\n    float disk = sdDisk(p);\n    float bhole = sdBlackHole(p);\n\n    return min(disk, bhole);\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p);\n    vec2 e = vec2(EPSILON, 0);\n\n    return normalize(d - vec3(GetDist(p - e.xyy),\n                              GetDist(p - e.yxy),\n                              GetDist(p - e.yyx)));\n}\n\n/*vec3 GetLight(vec3 p)\n{\n    return normalize(5.0 * vec3(cos(iTime),0,sin(iTime)) - p);\n}*/\n\nvec4 RayMarch(vec3 ro, inout vec3 rd, float side)\n{\n    vec3 p = ro;\n    float minDist = 1e20;\n    float traveled = 0.0;\n\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        float dS = side * GetDist(p);\n        traveled += STEP_SIZE;\n        \n        if (abs(dS) < minDist)\n            minDist = abs(dS);\n\n        if (abs(dS) <= EPSILON || traveled > MAX_DIST)\n            break;\n\n#ifdef GRAVITATIONAL_LENSING\n        vec3 d = p - CENTER;\n        float r = dot(d, d);\n        float bend = MASS / r;\n        vec3 n = d * inversesqrt(r);  // normalizing vector\n        rd = normalize(rd - n * (bend * STEP_SIZE));  // * STEP_SIZE means bend more when stepping further\n#endif\n        p += rd * STEP_SIZE;\n    }\n\n    return vec4(p, minDist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / min(iResolution.x, iResolution.y);\n    vec2 mouse;\n\n    if (iMouse.x == 0.0 && iMouse.y == 0.0)\n        mouse = vec2(0.5, 0.48);\n    else\n        mouse = iMouse.xy / iResolution.xy;\n\n    float yaw = mouse.x * TAU;\n    float pitch = mouse.y * PI;\n    vec4 cs = vec4(cos(yaw), sin(yaw), cos(pitch), sin(pitch));\n\n    vec3 ro = DISTANCE * cs.xzy * vec3(cs.w, 1, cs.w);\n    vec3 lookAt = CENTER,\n         f = normalize(lookAt - ro),\n         r = normalize(cross(f, vec3(0,1,0))),\n         u = cross(r, f),\n         c = ro + f * ZOOM,\n         i = c + r * uv.x + u * uv.y,\n         rd = normalize(i - ro);\n\n    vec3 col = vec3(0);\n    float j;\n    float iterations;\n\n#ifdef TRANSLUCENT_ACCRETION_DISK\n    iterations = float(MAX_ACCRETION_DISK_PENETRATIONS);\n#else\n    iterations = 1.;\n#endif\n\n    for (j = 0.; j < iterations; j++)\n    {\n        vec4 p_minDist = RayMarch(ro, rd, 1.0);\n        vec3 p = p_minDist.xyz;\n        //float minDist = p_minDist.w;\n        //col += 1e-7 * MAX_DIST / minDist;\n    \n        if (sdBlackHole(p) <= EPSILON)  // Light ray got swallowed by the black hole\n        {\n            //col = vec3(0,0,0);\n            break;\n        }\n        else if (sdDisk(p) <= EPSILON)  // Light ray is on the accretion disk\n        {\n            // Switching side of accretion disk\n            ro = p;\n            ro.y -= sign(p.y) * 2.0 * EPSILON;\n\n            float a = 0.5 + 0.5 * atan(p.z, p.x) / PI;\n            //float a = 0.5 * atan(p.z, p.x) / PI;\n            //float a = atan(p.z, p.x);\n            float d = 1.0 - sdBlackHole(p) / ACCRETION_DISK_OUTER_RADIUS;\n\n            //col += d * abs(1.0 + cos(a)) * vec3(1, 0.635, 0.475);\n            //col += 2.0 * d * /*d * */vec3(1, 0.635, 0.475);\n            //col += d * vec3(1, 0.635, 0.475);\n\n            //float motion = mod(iTime * ACCRETION_DISK_SPEED, 1.0);\n            float motion = iTime * ACCRETION_DISK_SPEED;\n            float u = a + motion/* * d*/;\n            float v = d;\n            //float v = d - motion;\n\n            vec3 tex = texture(iChannel0, vec2(u, v)).rgb;\n            float brightness = dot(tex, vec3(0.3, 0.6, 0.1));\n\n            //if (brightness > 0.25)\n            //{\n            col += exp2(-j) * 4.0 * d * brightness * vec3(1.0, 0.3, 0.0);\n        #ifdef GLOW\n            col += 2.0 * d * d;\n        #endif\n            //}\n        }\n        else\n        {\n            //col += texture(iChannel0, p.xy / MAX_DIST).rgb;\n            //col += texture(iChannel1, rd).rgb;\n            break;\n        }\n    }\n    \n    //col /= 0.25 * j;\n    //col += 0.8 - length(uv);\n    //col = pow(col, vec3(0.4545));\n    //col *= 1.25;\n    //col = clamp(col, 0.0, 1.0);\n    \n    fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}