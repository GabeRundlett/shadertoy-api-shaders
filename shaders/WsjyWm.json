{
    "Shader": {
        "info": {
            "date": "1586774850",
            "description": "License: CC0\nStar tunnel created while randomly coding while listening to 90s music\nCode is kind of crappy but I liked the visual result so I decided to share it.",
            "flags": 0,
            "hasliked": 0,
            "id": "WsjyWm",
            "likes": 52,
            "name": "Disco Star Tunnel",
            "published": 3,
            "tags": [
                "tunnel",
                "disco"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 1656
        },
        "renderpass": [
            {
                "code": "// License: CC0\n//  Star tunnel created while randomly coding while listening to 90s music\n//  Code is kind of crappy but I liked the visual result so I decided to share it.\n\n\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nvec2 offset(float time, float z) {\n  z *= 0.1*sqrt(0.5);\n  vec2 o = vec2(0.0);\n  vec2 r = vec2(2.0);\n  o += r*vec2(cos(z), sin((sqrt(0.5))*z + pow(0.5 + 0.5*sin(sqrt(0.25)*z),5.0)));\n  return o;\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nconst float smallRadii = pow(0.5, 6.0);\nconst float largeRadii = 1.0 + 2.0*smallRadii;\nconst float reps = float(int(largeRadii*TAU/(2.0*smallRadii)));\nconst float degree = TAU/reps;\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat star5(vec2 p, float r, float rf) {\n  const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n  const vec2 k2 = vec2(-k1.x,k1.y);\n  p.x = abs(p.x);\n  p -= 2.0*max(dot(k1,p),0.0)*k1;\n  p -= 2.0*max(dot(k2,p),0.0)*k2;\n  p.x = abs(p.x);\n  p.y -= r;\n  vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n  float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n  return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nvec3 df(vec2 p, int gi) {\n  float divend = 2.0*smallRadii + 0.5*pow(1.0 - cos(0.0), 2.0);\n  float dx = largeRadii - 0.5*divend;\n  vec2 op = p;\n  vec2 pp = toPolar(p);\n  float ny = pp.y;\n  pp.y +=-0.33*smallRadii*float(gi);\n  pp.x -= dx;\n  float nx = pp.x/divend;\n  pp.x = mod(pp.x, divend);\n  pp.x += dx;\n  float nny = mod1(pp.y, degree);\n  pp.y += PI/2.0;\n  p = toRect(pp);\n  \n  p -= vec2(0.0, largeRadii);\n  \n  float ymul = mod(nny, 2.0) > 0.0 ? 1.0 : -1.0;\n  float xmul = mod(float(int(nx)), 2.0) > 0.0 ? 1.0 : -1.0;\n  \n  rot(p, ymul*xmul*TIME*TAU/5.0);\n\n  float d = star5(p, smallRadii, 0.25);\n  float id = circle(op, largeRadii - smallRadii);\n  d = max(d, -id);\n\n  return vec3(d, nx, ny);\n}\n\nvec3 tunnelEffect(vec2 p) {\n  vec3 col = vec3(0.0);\n \n  float smoothPixel = 5.0/iResolution.x;\n \n  const vec3 baseCol = vec3(1.0);\n  const float zbase  = 10.0;\n  const float zdtime = 0.25;\n  const float zspeed = 10.0;\n  float gtime   = TIME*0.5;\n  float gz      = zspeed*gtime;\n  vec2 outerOff = offset(gtime, gz);\n  float fgtime  = mod(gtime, zdtime);\n  for (int i = 22; i >= -2; --i) {\n    int   gi      = i + int(gtime/zdtime);\n    float lz      = zspeed*(zdtime*float(i) - fgtime);\n    float zscale  = zbase/(zbase + lz);\n\n    float iz      = gz + lz;\n    vec2 innerOff = offset(gtime, iz);\n    \n    vec2 ip       = p + 0.5*zscale*(-innerOff + outerOff);\n    float ld      = length(ip)/zscale;\n\n    vec3 ddd      = df(ip/zscale, gi)*zscale;\n    float d       = ddd.x;    \n    vec3 scol = baseCol*vec3(0.6 + 0.4*sin(TAU*ddd.y*0.005 - 0.2*iz), pow(0.6 + 0.4*cos(-2.0*abs(ddd.z)-0.4*iz-0.5*gtime), 1.0), 0.8);\n    \n    float diff = exp(-0.0125*lz)*(1.0 - 1.0*tanh(pow(0.4*max(ld - largeRadii, 0.0), 2.0) + 3.0*smallRadii*max(ddd.y, 0.0)));\n    \n    vec4 icol = diff*vec4(scol, smoothstep(0.0, -smoothPixel, d));\n\n    icol.w += diff*diff*diff*0.75*clamp(1.0 - 30.0*d, 0.0, 1.0);\n    icol.w += tanh(0.125*0.125*lz)*0.5*ld*clamp(1.5 - ld, 0.0, 1.0);\n    \n    col = mix(col, icol.xyz, clamp(icol.w, 0.0, 1.0));\n  }\n \n \n  return col;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= iResolution.x/iResolution.y;\n  \n  vec3 col = tunnelEffect(p);\n \n  col = postProcess(col, q);\n \n  fragColor = vec4(col.xyz, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}