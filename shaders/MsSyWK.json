{
    "Shader": {
        "info": {
            "date": "1493800257",
            "description": "distance of point p.xy to\ny=fract(x) <-> dist=sawtooth(p)\n&\ny=mod(x,a)*b  <->  dist=sawtoothW(p,vec2(a,b))\n*U <-> unsigned, saves 1mult 2add.\n\nyou might be able to fix some discontinuities\nby subtracting the distance to sawtooth-functions from \"something\"",
            "flags": 0,
            "hasliked": 0,
            "id": "MsSyWK",
            "likes": 4,
            "name": "sawtooth mod() fract()",
            "published": 3,
            "tags": [
                "2d",
                "wave",
                "ocean",
                "mod",
                "distance",
                "fract",
                "sawtooth"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 648
        },
        "renderpass": [
            {
                "code": "//signed (& unsigned) distance from p.xy\n//to sawtooth function y=mod(x,a)*b;\n//hold left mouse button to set; mouse.x->a , mouse.y->b\n//\n//also has shortcut version to sawtooth function y=fract(x)=mod(x,1)*1;\n\n//set zoom and distance_between_lines (converging to surface).\n//#define zoom    (sin(iTime   )*.5+1.)\n#define zoom  1.\n\n#define dbl  (5.*sin(iTime*3.)+5.)\n//#define dfv   5.\n\n//sawShape.x=wavelength sawshape.y=amplitude range [0..sawShape.y]\n//#define sawShape vec2(1,2)\n#define sawShape vec2(sin(iTime)+2.,cos(iTime)+1.)\n\n//eightRotation.y=eightRotation.x=cos(3.14/4)=sin(3.14/4)=\n//...pow(2,1/2)/2=sqrt(2)/2=0.70710678118654752440084436210485\n#define p222 sqrt(0.5) \n//return p, rotated by 45deg\nvec2 pR45(in vec2 p){return (p+vec2(p.y,-p.x))*p222;}\n//return p, rotated by r;\n#define r(p,r) (cos(r)*p+sin(r)*vec2(-p.y,p.x))\n\n//the function y=fract(x)   \n//is a sawtooth with wavelength=amplitude=1\n//\n//the function y=mod(x,b)*c \n//is a sawtooth with wavelength=b, amplitude=c\n\n//distance to sawtooth with wavelength=amplitude=1 is simpler\n//than a parametric sawdooth with parametric wavelength.\n//below both are solved, for signed and unsidned values.\n\n//a core subroutine is; distance to an infinite-line-segment: ils()\n\n//return distance of (p) to ray that starts at (0,0) and has direction (0,-1);\nfloat ils(vec2 p){return mix(abs(p.y),length(p),step(0.,p.x));}\n//vertical utility of ils()\nfloat vert(vec2 p){p.x=fract(p.x);return ils(p.yx-vec2(1,0));}\n//45deg diagonal utility of ils()\nfloat diag(vec2 p){p.x=fract(p.x);p=pR45(p);\n return ils(p-vec2(sqrt(2.),0));}\n\n//tt1 and tt2 transform p from a point below the curve \n//to an identical point above the curve.\n//(as far as unsigned distance function to its curve is concerned) \n\n//if(p.y-fract(p.x)<0.){p=-p;p.y+=1.;}//<- is identical to [t1]\n#define tt1 p=mix(p,-p,t);p.y+=mix(0.,1.,t);\n#define tt11 float t=step(p.y-fract(p.x),0.);tt1\n//return unsigned distance to sawtooth-wave, wavelength=1, range.y=[0..1]\nfloat sawtoothU(vec2 p){tt11 return min(vert(p),diag(p));}\n\n//abive uses vert(p),diag(p);\n//below function does not use vert(p),diag(p), but its functions.\n\n//return distance to sawtooth-wave, wavelength=1, range.y=[0..1]\nfloat sawtooth(vec2 p){tt11\n p.x=fract(p.x);\n float vert=ils(p.yx-vec2(1,0));\n p=pR45(p);\n float diag=ils(p-vec2(sqrt(2.),0));\n return (1.-t*2.)*min(vert,diag);}\n\n//above 2 functions are special SHORT cases for below 2 functions as in:\n//sawtoothU(p)==sawtoothWU(p,vec2(1))\n//sawtooth (p)==sawtoothW (p,vec2(1))\n\n\nfloat diag2(vec2 p,vec2 w){\n return ils(r(p,-atan(w.y/w.x))-vec2(length(w),0));}\n\nfloat vert2(vec2 p,vec2 w){p.x=mod(p.x,w.x);\n return ils(p.yx-vec2(w.y,0));}\n\n//subroutine for sawtoothW*()\nfloat sawtooth2s(vec2 p,vec2 w){p.x+=w.x;\n float v=vert2(p,w),d=diag2(p,w),e=diag2(p-vec2(w.x,0),w);\n return min(min(d,e),v);}\n\n#define tt2 p.y-=mix(0.,w.y,t);p=mix(p,-p,t);\n#define tt2w p=vec2(mod(p.x,w.x),p.y);float t=step(p.y-p.x*w.y/w.x,0.);tt2\n//return unsigned distance of [p] to sawtooth[w] .x=wavelength .y=amplitude\nfloat sawtoothWU(vec2 p,vec2 w){tt2w return sawtooth2s(p,w);}\n\n//return distance of [p] to sawtooth[w] .x=wavelength .y=amplitude\nfloat sawtoothW(vec2 p,vec2 w){tt2w return (1.-t*2.)*sawtooth2s(p,w);}\n\n//subroutine for sawtoothW*()\nfloat sawtooth2s2(vec2 p,vec2 w){p.x+=w.x;\n float v=vert2(p,w),d=diag2(p,w),e=diag2(p-vec2(w.x,0),w);\n return min(min(d,e),v);}\nfloat sawtoothW2(vec2 p,vec2 w){tt2w return (1.-t*2.)*sawtooth2s2(p,w);}\n\nvec2 frame(vec2 u){u=u/iResolution.xy;u-=.5;\n u.x*=iResolution.x/iResolution.y;u*=5.;return u*zoom;}\nvec2 frame2(vec2 u){u=u/iResolution.xy;\n u.x*=iResolution.x/iResolution.y;u*=5.;return u*zoom;}\n\nvoid mainImage( out vec4 Out, in vec2 In ){\n vec2 u=frame(In);\n vec2 m=frame2(iMouse.xy);\n vec2 shape=sawShape;   \n if(iMouse.w>0.&&iMouse.x>0.)shape=m;\n\n float sawU=sawtoothWU(u,shape);\n float saw =sawtoothW(u,shape);\n //above is distance to y=mod(u,shape.x)*shape.y\n //overwrite to show a simpler special fract(u)=mod(u,1)*1 case:\n //saw  =sawtooth(u);\n //sawU =sawtoothU(u);\n \n float sawS=saw+.73;//makes a neat wave-shilouette.\n sawU=fract(sawU*dbl);\n saw =fract(saw *dbl);\n float green=sawU;//fract(diag(u)*5.);\n float blue =saw;//fract(vert(u)*5.);\n \n //green=.2*fract(length(u));\n //blue=1.-pow(fract(u.x)*fract(u.y),.3);//cheap coordinate system\n    \n //sawS shows some potential \n //...to make a good distance to something like a wave:\n sawS+=.01*(sin(u.x*20.-iTime*9.)+5.*cos(u.y*5.));//+octvaves.\n sawS=smoothstep(0.,.1,sawS);//sharper gradient\n green=sawS;\n \n //blue=+green;sawU=green;//only show \"ocean\"\n \n Out=vec4(sawU,green,blue,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}