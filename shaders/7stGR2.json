{
    "Shader": {
        "info": {
            "date": "1661175542",
            "description": "Aurora",
            "flags": 0,
            "hasliked": 0,
            "id": "7stGR2",
            "likes": 5,
            "name": "Aurora Borealis Test",
            "published": 3,
            "tags": [
                "test"
            ],
            "usePreview": 0,
            "username": "Khael",
            "viewed": 280
        },
        "renderpass": [
            {
                "code": "// Fonction de cercle qui nécessite 3 inputs, l'uv, le radius et la valeur du blur.\nfloat Circle(vec2 uv, vec2 p, float r, float blur) {\n\n    // Distance de l'UV ( au dessus de 1 la distance est clampé\n    float d = length(uv-p);\n    \n    //smoothstep r est le min, r-0.01 est le max, et d est la valeur de la source donc le cercle\n    float c = smoothstep(r, r-blur, d);\n    \n    return c;\n\n}\n\nfloat Band(float t, float start, float end, float blur){\n    float step1 = smoothstep(start-blur, start+blur, t);\n    float step2 = smoothstep(end+blur, end-blur, t);\n    \n    return step1*step2;\n}\n\nfloat Rect(vec2 uv, float left, float right, float bottom, float top, float blur){\n    float band1 = Band(uv.x, left, right, blur);\n    float band2 = Band(uv.y, bottom, top, blur);\n    \n    return band1 * band2;\n}\n    \n\nfloat Smiley(vec2 uv, vec2 p, float size){\n    \n    uv -= p; // translating coordinate system\n    uv /= size; //scaling coordinate system\n    float mask = Circle(uv, vec2(0.), .4, .01);\n\n    mask -= Circle(uv, vec2(-.12, .15), .07, .01);\n    mask -= Circle(uv, vec2(.12, .15), .07, .01);\n    \n    float mouth = Circle(uv, vec2(0.), .3, .01);\n    mouth -= Circle(uv, vec2(0., 0.1), .3, .01);\n    \n    mask -= mouth;\n    \n    return mask;\n}\n    //Lerp function\nfloat remap01(float a, float b, float t){\n    return (t-a) / (b-a); // Si t =a alors 0/0 = 0\n    //Si t = b alors 1/1=1\n}\n\nfloat remap(float a, float b, float c, float d, float t){\n    return remap01(a,b,t) * (d-c) + c;\n}\n\nvec3 yToRgb(float y)\n{    \n    float r, g, b;\n    \n    // functions where created based on the default linear equation\n    // f(x) = mx + b, where m is the slope and b the intersection point\n    // with the x axis f(0) = b ;)\n    // you can view the graph of the functions here: \n    // https://iquilezles.org/apps/graphtoy/?f3(x)=1-abs(x*2-1)&f4(x)=clamp(1-x*2,%200,%201)&f6(x)=clamp((x-0.5)*2,%200,%201)\n    \n    b = clamp(1.0-y*2.0, 0.0, 1.0);\n    g = 1.0-abs(y*2.0-1.0);\n    r = clamp((y-0.5)*2.0, 0.0, 1.0);\n    \n    return vec3(r, g, b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    float t = iTime;\n    \n    // Uv from -0.5 to 0.5\n    uv -= 0.5; \n    \n    // Calculate the x aspect ratio of the screen\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //float mask = Smiley(uv, vec2(0.), 1.);\n    float mask =.0;\n\n    //vec3 col = vec3(mouth);\n    float x = uv.x;\n    \n    float m = sin(t+x*8.)*.1;\n    float y = uv.y-m;\n    \n    \n    float blur = remap(-1., .5, .05, .25, x);\n    blur = pow(blur*4., 2.);\n    mask = Rect(vec2(x,y), -1., 1., -.1, .1, blur);\n    \n    vec3 rgb = vec3(yToRgb(-uv.x)); \n    vec3 col = pow( rgb, vec3(1./2.2)) * mask;\n    vec3 colormask = vec3(remap01(-0.3, 0.9, -uv.x));\n           \n    // Output to screen\n    fragColor = vec4(col ,1.0);\n    //fragColor = vec4( pow( rgb, vec3(1./2.2)) * colormask , 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}