{
    "Shader": {
        "info": {
            "date": "1537983302",
            "description": "Tracing a 4d Cornell (-esque) Box. Comes with checkboard floor, rough structure paint wall, three white boxes and a reflective sphere. And some fog. 4d structural paint sold separately.",
            "flags": 0,
            "hasliked": 0,
            "id": "4lKyWc",
            "likes": 20,
            "name": "4d Cornell Box",
            "published": 3,
            "tags": [
                "raytracing",
                "cornell"
            ],
            "usePreview": 0,
            "username": "JeroenDStout",
            "viewed": 1035
        },
        "renderpass": [
            {
                "code": "void tracePlanar( in float pos, in float dir, vec4 colour, vec4 normal,\n                  inout float setDist, inout vec4 setColour, inout vec4 setNormal )\n{\n    if (dir == 0.0)\n        return;\n    \n    float dist = pos / dir;\n    \n    if (dist > setDist)\n        return;\n    \n    setDist = dist;\n    setColour = colour;\n    setNormal = normal;\n}\n\nvoid traceSphere( in vec4 pos, in vec4 dir, float radius, vec4 colour, inout float setDist,\n                  inout vec4 setColour, inout vec4 setNormal)\n{\n    pos /= radius;\n    \n    float dirDot = -dot(dir, pos);\n    if (dirDot < 0.)\n\t\treturn;\n    \n    vec4  inPos = pos + dir * dirDot;\n    float inner = length(inPos);\n    \n    if (inner > 1.)\n        return;\n    \n    vec4  hit   = inPos - dir * sqrt(1. - inner * inner);\n    \n    float dist = length(pos - hit) * radius;\n    if (dist >= setDist)\n        return;\n    \n    setColour = colour;\n    setDist   = dist;\n    setNormal = normalize(hit);\n}\n\nvoid traceCube( in vec4 pos, in vec4 dir, mat4x4 align, vec4 cubDim, inout float setDist,\n                inout vec4 setColour, inout vec4 setNormal)\n{\n    vec4 relPos = pos * align;\n    vec4 relDir = dir * align;\n    \n    if (abs(relPos.x) > cubDim.x) {\n        vec4 tmpDir = relDir;\n        tmpDir.x *= -sign(relPos.x);\n        if (tmpDir.x > 0.) {\n            float travel = (abs(relPos.x) - cubDim.x) / tmpDir.x;\n            if (travel < setDist) {\n                vec4  chk    = abs(relPos + tmpDir * travel);\n                if (chk.y < cubDim.y && chk.z < cubDim.z && chk.w < cubDim.w) {\n                    setColour = vec4(1., 1., 1., 0.);\n                    setDist   = travel;\n                    setNormal = align[0] * sign(relPos.x);\n                    return;\n                }\n            }\n        }\n    }\n    if (abs(relPos.y) > cubDim.y) {\n        vec4 tmpDir = relDir;\n        tmpDir.y *= -sign(relPos.y);\n        if (tmpDir.y > 0.) {\n            float travel = (abs(relPos.y) - cubDim.y) / tmpDir.y;\n            if (travel < setDist) {\n                vec4  chk    = abs(relPos + tmpDir * travel);\n                if (chk.x < cubDim.x && chk.z < cubDim.z && chk.w < cubDim.w) {\n                    setColour = vec4(1., 1., 1., 0.);\n                    setDist   = travel;\n                    setNormal = align[1] * sign(relPos.y);\n                    return;\n                }\n            }\n        }\n    }\n    if (abs(relPos.z) > cubDim.z) {\n        vec4 tmpDir = relDir;\n        tmpDir.z *= -sign(relPos.z);\n        if (tmpDir.z > 0.) {\n            float travel = (abs(relPos.z) - cubDim.z) / tmpDir.z;\n            if (travel < setDist) {\n                vec4  chk    = abs(relPos + tmpDir * travel);\n                if (chk.x < cubDim.x && chk.y < cubDim.y && chk.w < cubDim.w) {\n                    setColour = vec4(1., 1., 1., 0.);\n                    setDist   = travel;\n                    setNormal = align[2] * sign(relPos.z);\n                    return;\n                }\n            }\n        }\n    }\n    if (abs(relPos.w) > cubDim.w) {\n        vec4 tmpDir = relDir;\n        tmpDir.w *= -sign(relPos.w);\n        if (tmpDir.w > 0.) {\n            float travel = (abs(relPos.w) - cubDim.w) / tmpDir.w;\n            if (travel < setDist) {\n                vec4  chk    = abs(relPos + tmpDir * travel);\n                if (chk.x < cubDim.x && chk.y < cubDim.y && chk.z < cubDim.z) {\n                    setColour = vec4(1., 1., 1., 0.);\n                    setDist   = travel;\n                    setNormal = align[3] * sign(relPos.w);\n                    return;\n                }\n            }\n        }\n    }\n}\n\nvoid traceObjects( inout vec4 pos, inout vec4 dir,\n                   inout float setDist, out vec4 colour, out vec4 normal, float time )\n{\n//    traceSphere(pos + vec4(0.5, 0.65, .3, .3), dir, .35, vec4(0.5, 0.,0.5, 1.0),\n//                setDist, colour, normal);\n    traceSphere(pos + vec4(-0.5, 0.6, -.2, .4), dir, .4, vec4(0.5, 0.5,0.5, 1.0),\n                setDist, colour, normal);\n//    traceSphere(pos + vec4(-0.15, 0.8, 0, 0), dir, .2, vec4(0.1, 0.,0.9, 1.0),\n//                setDist, colour, normal);\n    \n    mat4x4 cubeAngA, cubeAngB;\n    \n    float cubRot = 0.;\n    \n    cubeAngA[0] = vec4(cos(cubRot), 0., sin(cubRot), 0.);\n    cubeAngA[1] = vec4(0., 1., 0., 0.);\n    cubeAngA[2] = vec4(-sin(cubRot), 0., cos(cubRot), 0.);\n    cubeAngA[3] = vec4(0., 0., 0., 1.);\n    \n    cubRot = 0.6;\n    \n    cubeAngB[0] = vec4(cos(cubRot), 0., 0., sin(cubRot));\n    cubeAngB[1] = vec4(0., 1., 0., 0.);\n    cubeAngB[2] = vec4(0., 0., 1., 0.);\n    cubeAngB[3] = vec4(-sin(cubRot), 0., 0., cos(cubRot));\n    \n    traceCube(pos + vec4(0.6, 0.35, -0.35, 0.), dir, cubeAngA, vec4(.3, .7, .3, .2),\n              setDist, colour, normal);\n    \n    traceCube(pos + vec4(-0.6, 0.35, 0.35, 0.), dir, cubeAngB, vec4(.2, .7, .2, .3),\n              setDist, colour, normal);\n    \n    cubRot = 0.0;\n    \n    cubeAngB[0] = vec4(cos(cubRot), 0., 0., sin(cubRot));\n    cubeAngB[1] = vec4(0., 1., 0., 0.);\n    cubeAngB[2] = vec4(0., 0., 1., 0.);\n    cubeAngB[3] = vec4(-sin(cubRot), 0., 0., cos(cubRot));\n    \n    traceCube(pos + vec4(0.6, -0.35, 0.35, -0.75), dir, cubeAngB, vec4(.2, .2, .2, .25),\n              setDist, colour, normal);\n}\n\nvoid traceScene( inout vec4 pos, inout vec4 dir, out vec4 colour,\n                 out vec3 pureColour, out vec3 transfer, out vec3 atmos, out vec4 normal,\n                 float time, float noise )\n{    \n    float nxDist   = 99999.0;\n    vec4  nxColour = vec4(0., 0., 0., 0.);\n    vec4  nxNormal = vec4(0., 0., 0., 0.);\n    \n    if (dir.x < 0.) {\n        tracePlanar( pos.x+1., -dir.x, vec4(0.2, 0.9, 0.2, 0.0), vec4(1., 0., 0., 0.),\n                     nxDist, nxColour, nxNormal );\n    }\n    else {\n        tracePlanar( pos.x-1., -dir.x, vec4(0.9, 0.2, 0.2, 0.0), vec4(-1., 0., 0., 0.),\n                     nxDist, nxColour, nxNormal );\n    }\n    if (dir.y < 0.) {\n        tracePlanar( pos.y+1., -dir.y, vec4(0.8, 0.79, 0.78, 0.85), vec4(0., 1., 0., 0.),\n                     nxDist, nxColour, nxNormal );\n    }\n    else {\n        tracePlanar( pos.y-1., -dir.y, vec4(0.8, 0.79, 0.78, 0.0), vec4(0., -1., 0., 0),\n                     nxDist, nxColour, nxNormal );\n    }\n    if (dir.z < 0.) {\n        tracePlanar( pos.z+1., -dir.z, vec4(0.8, 0.79, 0.78, 0.0), vec4(0., 0., 1., 0.),\n                     nxDist, nxColour, nxNormal );\n    }\n    else {\n        tracePlanar( pos.z-1., -dir.z, vec4(0.8, 0.79, 0.78, 0.0), vec4(0., 0., -1., 0.),\n                     nxDist, nxColour, nxNormal );\n    }\n    if (dir.w < 0.) {\n        tracePlanar( pos.w+1., -dir.w, vec4(0.28, 0.29, 0.78, .5), vec4(0., 0., 0., 1.),\n                     nxDist, nxColour, nxNormal );\n    }\n    else {\n        tracePlanar( pos.w-1., -dir.w, vec4(0.9, 0.9, 0.0, 0.5), vec4(0., 0., 0., -1.),\n                     nxDist, nxColour, nxNormal );\n    }\n    \n    traceObjects(pos, dir, nxDist, nxColour, nxNormal, time); \n    \n    vec4 lightPos = vec4(0, 0.8, 0., -0.8);\n    \n    traceSphere(pos - lightPos, dir, .1, vec4(10., 10.0, 10.0, -1.0),\n                nxDist, nxColour, nxNormal);\n\n    pos += dir * nxDist;\n    \n    if (pos.y <= -0.99999) {\n        float check = (floor(mod(pos.x * 5., 2.)) == floor(mod(pos.z * 5., 2.))) ? 1. : 0.;\n        check = mod(pos.w * 5., 2.) < 1. ? (1. - check) : check;\n                      \n        nxColour.xyz *= vec3(0.2, 0.1, 0.05) * check + vec3(0.9, 0.87, 0.85) * (1. - check);\n        \n        nxColour.w *= 1. - (1. - check * 0.7);\n        \n        float tileA = mod((0.5 + pos.x) * 5., 1.);\n        float tileB = mod((0.5 + pos.z) * 5., 1.);\n        float tileC = mod((0.5 + pos.w) * 5., 1.);\n        \n        float fade  = max(0., 1. - (min(abs(0.5 - tileC), min(abs(0.5 - tileA), abs(0.5 - tileB)))) * 17.);\n        fade = min(1., fade * 4.);\n        \n        nxNormal.x -= (-.5 + tileA * 1.) * max(0., 1. - abs(0.5 - tileA) * 5.);\n        nxNormal.z -= (-.5 + tileB * 1.) * max(0., 1. - abs(0.5 - tileB) * 5.);\n        nxNormal.w -= (-.5 + tileC * 1.) * max(0., 1. - abs(0.5 - tileC) * 5.);\n        \n        nxColour = nxColour * (1. - fade) + vec4(0.9, 0.9, 0.9, .0) * fade;\n        \n        nxNormal = normalize(nxNormal);\n    }\n    if (pos.z <= -0.999999) {\n        //nxColour.xyz = vec3(999.);\n        \n        vec3 norm = texture(iChannel2, pos.xyw * 2.5).xyz;\n        \n        nxNormal.xyw += (-.5 + norm * .5);\n        nxNormal = normalize(nxNormal);\n    }\n    \n    vec4 lightDir = lightPos - pos;\n    float lightDist = length(lightDir);\n    lightDir /= lightDist;\n    float lightEff = max(0., dot(lightDir, nxNormal));\n    \n    float lightTstDist = 9999.;\n    vec4 dummy;\n    \n    vec4 ref = nxNormal * max(0., dot(nxNormal, dir));\n    ref += (dir - ref);\n    \n    float spec = pow(max(0., dot(ref, lightDir)), 1. - dot(nxNormal, dir) * 2.);\n    \n    traceObjects(pos, lightDir, lightTstDist, dummy, dummy, time);\n    if (lightTstDist < lightDist || dot(nxNormal, lightDir) < 0.0) {\n        lightEff *= 0.;\n        spec *= 0.;\n    }\n    \n    float atmosWeight = 1.;\n    \n    float atmosStep = (nxDist / 17.0);\n    float atmosNoise = noise / 17.0;\n    for (int i = 0; i < 16; i++) {\n        vec4 tmpPos = pos - dir * (float(i) * atmosStep) + atmosNoise;\n\n        lightDir = normalize(lightPos - tmpPos);\n\n        float lightTstDist = 9999.;\n        vec4 dummy;\n\n        traceObjects(tmpPos, lightDir, lightTstDist, dummy, dummy, time);\n        if (lightTstDist < lightDist) {\n            atmosWeight -= 1. / 16.;\n        }\n    }\n    \n    vec3 lighCol = vec3(8.0, 7.9, 6.6) * 3.;\n    \n    float lightAng = 0.5 - (0.4 * acos(lightDir.y) / 3.1415);\n    \n    lighCol *= texelFetch(iChannel1, ivec2(lightAng, .5), 0).xxx;\n    \n    pureColour = nxColour.xyz;\n    colour.xyz = pureColour * lightEff * pow(0.33, lightDist) * lighCol;\n    colour.xyz += lighCol * pow(0.33, lightDist) * spec * 1.;\n    colour.w = nxColour.w;\n    \n    if (nxColour.w < 0.) {\n        colour = vec4(lighCol.x, lighCol.y, lighCol.z, 0.);\n    }\n    \n    normal = nxNormal;\n    \n    //pureColour.x = 1. / nxDist;\n    \n    atmos    = 1. - pow(vec3(0.8, 0.85, 0.9), vec3(nxDist*2.));\n    transfer = pow(vec3(0.8, 0.85, 0.9), vec3(nxDist*2.));\n    \n    \n    atmos *= atmosWeight;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float noise = texelFetch(iChannel0, ivec2(mod(fragCoord.x + iTime * 1038., 256.), mod(fragCoord.y, 256.)), 0).x;\n\t\n    \n    vec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = (2.0 * uv - 1.0) * aspect * 0.5;\n    \n    \n    float rotRef = min(iTime * iTime * iTime * 0.1, iTime * .5) * 4.;\n    rotRef += sin(rotRef * 0.01) * 20.;\n    \n    float rotAs = sin(rotRef / 13.);\n    float rotAc = cos(rotRef / 13.);\n    float rotBs = cos(0. + rotRef / 27.);\n    float rotBc = sin(0. + rotRef / 27.);\n    float rotCs = sin(0.0 + rotRef / 11.);\n    float rotCc = cos(0.0 + rotRef / 11.);\n    float rotDs = sin(0.0 + rotRef / 23.);\n    float rotDc = cos(0.0 + rotRef / 23.);\n    float rotEs = sin(0.0 + rotRef / 37.);\n    float rotEc = cos(0.0 + rotRef / 37.);\n    \n    vec4  off   = vec4(sin(rotRef / 31.), sin(rotRef / 15.), sin(rotRef / 17.), sin(rotRef / 7.));\n    \n    mat4x4 cameraRotA = mat4x4( rotAs, 0, -rotAc, 0,\n                                0,     1,  0,     0,\n                                rotAc, 0,  rotAs, 0,\n                                0,     0,  0,     1  );\n    \n    mat4x4 cameraRotB = mat4x4( rotBs, -rotBc, 0, 0,\n                                rotBc, rotBs,  0, 0,\n                                0, 0,  1, 0,\n                                0, 0,  0, 1  );\n    \n    mat4x4 cameraRotC = mat4x4( rotCc, 0, 0, -rotCs,\n                                0,     1, 0, 0,\n                                0,     0, 1, 0,\n                                rotCs, 0, 0, rotCc  );\n    \n    mat4x4 cameraRotD = mat4x4( 1, 0, 0, 0,\n                                0, 1, 0, 0,\n                                0, 0, rotDc, -rotDs,\n                                0, 0, rotDs, rotDc  );\n    \n    mat4x4 cameraRotE = mat4x4( 1, 0, 0, 0,\n                                0, rotEc, 0, -rotEs,\n                                0, 0, 1, 0,\n                                0, rotEs, 0, rotEc  );\n    \n    mat4x4 cameraRot = cameraRotC * cameraRotB * cameraRotA * cameraRotD * cameraRotE;\n    \n    vec4 cameraFw    = vec4(1, 0, 0, 0) * cameraRot;\n    vec4 cameraUp    = vec4(0, 1, 0, 0) * cameraRot;\n    vec4 cameraRight = vec4(0, 0, 1, 0) * cameraRot;\n    vec4 camera4d    = vec4(0, 0, 0, 1) * cameraRot;\n    \n    cameraUp.x  = min(0.5, max(-0.5, cameraUp.x));\n    cameraUp.z  = min(0.5, max(-0.5, cameraUp.z));\n    cameraUp.y += 0.9;\n    cameraUp    = normalize(cameraUp);\n    \n    cameraFw    = normalize(cameraFw - cameraUp * dot(cameraUp, cameraFw));\n    cameraRight = normalize(cameraRight - cameraUp * dot(cameraUp, cameraRight));\n    cameraRight = normalize(cameraRight - cameraFw * dot(cameraFw, cameraRight));\n    \n    vec4 cameraPos   = (-cameraFw * 3.) + off * .2;\n \n    // Enable this to smear vaseline in the 4th dimension\n    //float noise4 = texelFetch(iChannel3, ivec2(mod(fragCoord.x, 256.), mod(fragCoord.y, 256.)), 0).x;\n    //cameraFw += camera4d * (-0.5 + noise4) * 0.1;\n    \n    // Sine wave trippy-maker\n    // cameraFw.w += sin(length(fragCoord - 200.0) * .01) * 0.4;\n    \n    vec4 cameraDir   = normalize(cameraFw + cameraRight * uv.x + cameraUp * uv.y);\n    \n    vec4 dummy;\n    float dist = 999999.;\n    mat4x4 id = mat4x4(1, 0, 0, 0,\n                       0, 1, 0, 0,\n                       0, 0, 1, 0,\n                       0, 0, 0, 1 );\n    \n    traceCube(cameraPos, cameraDir, id, vec4(1.1, 1.1, 1.1, 1.1),\n              dist, dummy, dummy);\n    cameraPos += cameraDir * dist;\n    \n    vec4 outColour   = vec4(0, 0, 0, 1);\n    vec4 normal\t\t = vec4(0, 0, 0, 0);\n    \n    vec3 addOpac     = vec3(1, 1, 1);\n    vec3 transfer;\n    vec3 atmos;\n    \n    int maxLoop = 15;\n    for (int i = 0; i < maxLoop; i++) {\n        vec4 addColour;\n        vec3 pureColour;\n        \n    \ttraceScene(cameraPos, cameraDir, addColour, pureColour, transfer, atmos, normal, iTime, noise);\n        \n        if (abs(cameraPos.x) > 1.01 || abs(cameraPos.y) > 1.01 ||\n            abs(cameraPos.z) > 1.01 || abs(cameraPos.w) > 1.01) {\n            float len = .5 / length(uv);\n            len += texture(iChannel2, vec3(uv.x, uv.y, iTime * 0.05)).x * 0.1;\n            outColour.x = pow(0.10, len);\n            outColour.y = pow(0.25, len);\n            outColour.z = pow(0.30, len);\n            outColour.xyz *= 0.5;\n            break;\n        }\n        \n        // Override reflectivity!\n        //addColour.w = .9;\n        \n        if (i+1 == maxLoop) {\n            addColour.w = 0.;\n        }\n        \n        outColour.xyz += atmos * addOpac.xyz;\n        addOpac *= transfer;\n        \n        if (addColour.w > 0.) {\n            addColour.w *= 0.4 + 0.6 * pow(max(0., 1. + dot(cameraDir, normal)), 0.5);\n            addColour.w = min(1., addColour.w);\n            \n            outColour.xyz += addColour.xyz * (1. - addColour.w) * addOpac.xyz;\n            addOpac *= addColour.w;\n            \n            cameraDir *= -1.;\n            normal *= -1.;\n            \n            vec4 mid = normal * dot(normal, cameraDir);\n            cameraDir = mid + (mid - cameraDir);\n            \n            addColour = vec4(0., 0., 0., 0.);\n            pureColour = vec3(0., 0., 0.);\n            \n            noise = texelFetch(iChannel0, ivec2(mod(fragCoord.x + noise * 13., 256.), mod(fragCoord.y + noise * 23., 256.)), 0).x;\n            \n            continue;\n        }\n        \n        outColour.xyz += addColour.xyz * addOpac.xyz;\n        break;\n    }\n    \n    fragColor.xyz = outColour.xyz;\n    fragColor.w = 1.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "volume",
                        "id": 40,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}