{
    "Shader": {
        "info": {
            "date": "1587306941",
            "description": "wanted to play around with polar coordinates and made this abstract Sci-Fi Tech Circle thingy\nthe bloom effect is shamelessly stolen from robobo1221 (https://www.shadertoy.com/view/lsBfRc)",
            "flags": 32,
            "hasliked": 0,
            "id": "WsScDK",
            "likes": 25,
            "name": "Cyber-Iris",
            "published": 3,
            "tags": [
                "2d",
                "polarcoordinates"
            ],
            "usePreview": 0,
            "username": "Zauwara",
            "viewed": 1287
        },
        "renderpass": [
            {
                "code": "#define colorRange 24.0\n\nvec3 jodieReinhardTonemap(vec3 c){\n    float l = dot(c, vec3(0.2126, 0.7152, 0.0722));\n    vec3 tc = c / (c + 1.0);\n\n    return mix(c / (l + 1.0), tc, tc);\n}\n\nvec3 bloomTile(float lod, vec2 offset, vec2 uv){\n    return texture(iChannel1, uv * exp2(-lod) + offset).rgb;\n}\n\nvec3 getBloom(vec2 uv){\n\n    vec3 blur = vec3(0.0);\n\n    blur = pow(bloomTile(2., vec2(0.0,0.0), uv),vec3(2.2))       \t   \t+ blur;\n    blur = pow(bloomTile(3., vec2(0.3,0.0), uv),vec3(2.2)) * 1.3        + blur;\n    blur = pow(bloomTile(4., vec2(0.0,0.3), uv),vec3(2.2)) * 1.6        + blur;\n    blur = pow(bloomTile(5., vec2(0.1,0.3), uv),vec3(2.2)) * 1.9 \t   \t+ blur;\n    blur = pow(bloomTile(6., vec2(0.2,0.3), uv),vec3(2.2)) * 2.2 \t   \t+ blur;\n\n    return blur * colorRange;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = pow(texture(iChannel0, uv).rgb * colorRange, vec3(2.2));\n    color = pow(color, vec3(2.2));\n    color += pow(getBloom(uv), vec3(2.2));\n    color = pow(color, vec3(1.0 / 2.2));\n    \n    color = jodieReinhardTonemap(color);\n    \n\tfragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float linstep(float x0, float x1, float xn)\n{\n\treturn max(min((xn - x0) / (x1 - x0), 1.), 0.);\n}\n\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define M_PI 3.1415926535897932384626433832795\n\nfloat timeScale = 0.2;\n\nvec3 mainColor = vec3(0.478431, 0.678431, 1.);\nvec3 secondaryColor = vec3(0.55, 0.0, 0.0);\n\n/*\n* Displays the sector of a ring based on:\n* \n* dist\t\t... distance to the center (/ radius)\n* width\t\t... width (along the radius)\n* apos\t\t... angular position (/ offset)\n* awidth\t... angular width (along the tangent)\n* puv\t\t... polar uv coordinates of the current fragment\n*\n* returns 1.0 if the given puv is part of the ringSector\n* returns 0.0 otherwise\n*/\nfloat ringSector(float dist, float width, float apos, float awidth, vec2 puv) {\n    \n    float ring = step(abs(puv.x - dist), width / 2.0);\n    \n    float sector = min(min(\n        abs(puv.y - mod(apos, 1.0)), \n    \tabs(puv.y - mod(apos, 1.0) - 1.0)), \n         abs(puv.y - mod(apos, 1.0) + 1.0));\n    sector = step(sector, awidth / 2.0);\n    \n    return ring * sector;\n}\n\n/*\n* Displays an array of ring sectors based on:\n* \n* dist\t\t... distance to the center (/ radius)\n* width\t\t... width (along the radius)\n* apos\t\t... angular position (/ offset)\n* awidth\t... angular width of the sector array (along the tangent)\n* segCount\t... how many ring sectors should be used to create the sector array\n* segWidth\t... the width of the individual ring sector (along the tangent; values between 0.0 and 1.0)\n* puv\t\t... polar uv coordinates of the current fragment\n*\n* returns 1.0 if the given puv is part of the sector array\n* returns 0.0 otherwise\n*/\nfloat ringSectors(float dist, float width, float apos, float awidth, int segCount, float segWidth, vec2 puv) {\n    float ret = 0.;\n    float sW = awidth / float(segCount);\n    float p = apos - float(segCount) / 2.0 * sW + sW/2.0;\n    \n    for(int i = 0; i < segCount; i++) {\n        ret += ringSector(dist, width, p + sW * float(i), sW * segWidth, puv);\n    }\n    \n    return ret;\n}\n\n/*\n* Displays an array of ring sectors with randomized angular position based on:\n* \n* dist\t\t... distance to the center (/ radius)\n* width\t\t... width (along the radius)\n* apos\t\t... angular position (/ offset)\n* awidth\t... the width of the individual ring segments (along the tangent)\n* segCount\t... how many ring sectors should randomly distributed\n* seed\t\t... seed used for the hash function\n* puv\t\t... polar uv coordinates of the current fragment\n*\n* returns 1.0 if the given puv is part of the randomized ring sectors\n* returns 0.0 otherwise\n*/\nfloat randSectors(float dist, float width, float apos, float awidth, int segCount, float seed, vec2 puv) {\n    float ret = 0.;\n    \n    for(int i = 0; i < segCount; i++) {\n        float rpos = hash11((float(i) + seed) * 10032.);\n        ret = max(ret, ringSector(dist, width, apos + rpos, awidth, puv));\n    }\n    \n    return ret;\n}\n\n/*\n* Displays a ring sector that incorporates two symmetrical slopes alongside the tangent based on:\n*\n* dist\t\t... distance to the center (/ radius)\n* w1\t\t... width of the sector before the slope (along the radius)\n* w2\t\t... width of the sector after the slope (along the radius)\n* apos\t\t... angular position (/ offset)\n* awidth\t... angular width (along the tangent)\n* t1\t\t... threshold 1 defines the relative start of the slope (value between 0.0 and 1.0)\n* t2\t\t... threshold 2 defines the relative end of the slope (value between 0.0 and 1.0)\n* innerC\t... set 1.0 so that the inner half of the sector gets drawn completely; set 0.0 otherwise \n* outerC\t... set 1.0 so that the outer half of the sector gets drawn completely; set 0.0 otherwise\n* puv\t\t... polar uv coordinates of the current fragment\n*\n* returns 1.0 if the given puv is part of the slanted sector\n* returns 0.0 otherwise\n*/\nfloat slantedSector(float dist, float w1, float w2, float apos, float awidth, float t1, float t2, float innerC, float outerC, vec2 puv) {\n    \n    float sector = min(min(\n        abs(puv.y - mod(apos, 1.0)), \n    \tabs(puv.y - mod(apos, 1.0) - 1.0)), \n         abs(puv.y - mod(apos, 1.0) + 1.0));\n    \n    float slopeProgress = linstep(t1 * awidth / 2., t2 * awidth / 2., sector);\n    \n    float ring = step(abs(puv.x - dist), mix(w2, w1, slopeProgress));\n    //float ring = step(abs(puv.x - dist), (slopeProgress * w1 + (1. - slopeProgress) * w2) / 2.0);\n    \n    // cover inner / outer half of ring\n    float w = max(w1, w2);\n    ring = max(ring, step(abs(puv.x - (dist + w / 2.)), w / 2.) * outerC);\n    ring = max(ring, step(abs(puv.x - (dist - w / 2.)), w / 2.) * innerC);\n    \n    sector = step(abs(sector), awidth / 2.0);\n    \n    return ring * sector;\n}\n\n/*\n* Displays a ring built from multiple slanted sectors based on:\n*\n* dist\t\t... distance to the center (/ radius)\n* w1\t\t... width of the sectors before the slope (along the radius)\n* w2\t\t... width of the sectors after the slope (along the radius)\n* apos\t\t... angular position (/ offset)\n* segCount\t... how many slanted sectors should be used to create the ring\n* t1\t\t... threshold 1 defines the relative start of the slope of each sector (value between 0.0 and 1.0)\n* t2\t\t... threshold 2 defines the relative end of the slope of each sector (value between 0.0 and 1.0)\n* innerC\t... set 1.0 so that the inner half of the ring gets drawn completely; set 0.0 otherwise \n* outerC\t... set 1.0 so that the outer half of the ring gets drawn completely; set 0.0 otherwise\n* puv\t\t... polar uv coordinates of the current fragment\n*\n*/\nfloat slantedRing(float dist, float w1, float w2, float apos, int segCount, float t1, float t2, float innerC, float outerC, vec2 puv) {\n    float ret = 0.;\n    \n    float segWidth = 1. / float(segCount);\n    \n    for(int i = 0; i < segCount; i++) {\n        ret += slantedSector(dist, w1, w2, apos + segWidth * float(i), segWidth, t1, t2, innerC, outerC, puv);\n    }\n    \n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv *= vec2(iResolution.x/iResolution.y, 1.0);\n    \n    // polar uv (x = radius, y = angle)\n    vec2 puv = vec2(length(uv), atan(uv.x, uv.y) / (M_PI * 2.0));\n    \n    \n    float t = iTime * timeScale;\n\t\n    float fill = 0.0;\n    float fill2 = 0.0;\n    \n    // inner\n    fill += ringSector(0.01, 0.004, t * 8., 0.4, puv);\n    fill += ringSector(0.006, 0.004, -t*4., 0.2, puv);\n    \n    // reactor\n    fill += ringSector(0.05, 0.025, -t, 0.575, puv);\n    fill += ringSector(0.05, 0.05, t * 0.5, 0.1, puv);\n    fill += ringSectors(0.05, 0.025, -t + 0.5, 0.4, 4, 0.8, puv);\n    fill += ringSector(0.05, 0.0125, 0., 1., puv);\n    \n    // train\n    fill += ringSectors(0.15, 0.01, -t, 0.25, 7, 0.7, puv);\n    \n    // trail\n    fill += ringSector(0.2, 0.015, t * 1.3, 0.15, puv);\n    fill += ringSector(0.2, 0.015, t * 1.3 + 0.1, 0.025, puv);\n\t\n\t// clock\n    fill += ringSectors(0.1, 0.02, t * 1.0, 1.0, 20, 0.1, puv);\n    fill += ringSectors(0.1, 0.03, t * 1.0 + 0.025, 1.0, 5, 0.025, puv);\n    \n    //stripes\n    fill += ringSectors(0.25, 0.005, t * 0.1, 0.3, 100, 0.5, puv);\n    \n    //shutter\n    /*\n    //float tj = max(min(-abs(mod(t * 6., 6.) - 3.) + 2., 1.), 0.);\n    //tj = pow(tj, 2.);\n    float tj = (sin(t * 5.) + 1.) /2.;\n    fill += ringSector(0.3, 0.01, 0.5 - tj * 0.08, 0.025, puv);\n    fill += ringSector(0.29, 0.002, 0.4 + tj * 0.025, 0.01, puv);\n    fill += ringSector(0.31, 0.002, 0.225 + tj * 0.2, 0.075, puv);\n\t*/\n    \n    // small gear\n    fill2 += slantedRing(0.35, 0.025, 0.0025, -t * 0.3, 3, 0.57, 0.6, 0., 1.,  puv);\n    //fill += ringSectors(0.38, 0.01, t * 0.02, 1., 100, 0.2, puv);\n    fill2 += slantedRing(0.395, 0.0125, 0.00125, t * 0.3, 6, 0.57, 0.6, 1., 0., puv);\n    \n    // barcode\n    fill += randSectors(0.45, 0.015, t * 0.1, 0.001, 50, 1., puv);\n    fill += randSectors(0.45, 0.015,-t * 0.1, 0.001, 50, 1.5, puv);\n    \n    // trinity\n    fill += ringSectors(0.550, 0.0025, -t * 0.9, 1.0, 3, 0.3, puv);\n    fill += ringSectors(0.560, 0.0025, -t * 0.9, 1.0, 3, 0.3, puv);\n    fill += ringSector(0.555, 0.0025, t * 2.4, 0.15, puv);\n    \n    // huge gear\n    float gt = t * 0.05;\n    fill += slantedRing(0.635, 0.01, 0., gt, 50, 0.4, 0.6, 0., 1., puv);\n    fill += slantedRing(0.675, 0.01, 0., gt, 5, 0.5, 0.55, 1., 0., puv);\n    fill += slantedRing(0.700, 0.01, 0., gt + 0.1, 5, 0.5, 0.55, 0., 1., puv);\n    fill += slantedRing(0.740, 0.01, 0., gt, 50, 0.4, 0.6, 1., 0., puv);\n    fill += ringSector(0.655, 0.02, gt, 1., puv);\n    fill += ringSector(0.720, 0.02, gt, 1., puv);\n    fill -= ringSectors(0.67, 0.0025, gt + 0.1, 1., 5, 0.4, puv);\n    fill -= ringSectors(0.705, 0.0025, gt, 1., 5, 0.4, puv);\n    fill -= ringSectors(0.63, 0.00125, gt, 1., 50, 0.3, puv);\n    fill -= ringSectors(0.745, 0.00125, gt, 1., 50, 0.3, puv);\n    \n    fragColor = vec4(mainColor * fill /5. + secondaryColor * fill2 /5., 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "vec3 makeBloom(float lod, vec2 offset, vec2 bCoord){\n    \n    vec2 pixelSize = 1.0 / vec2(iResolution.x, iResolution.y);\n\n    offset += pixelSize;\n\n    float lodFactor = exp2(lod);\n\n    vec3 bloom = vec3(0.0);\n    vec2 scale = lodFactor * pixelSize;\n\n    vec2 coord = (bCoord.xy-offset)*lodFactor;\n    float totalWeight = 0.0;\n\n    if (any(greaterThanEqual(abs(coord - 0.5), scale + 0.5)))\n        return vec3(0.0);\n\n    for (int i = -5; i < 5; i++) {\n        for (int j = -5; j < 5; j++) {\n\n            float wg = pow(1.0-length(vec2(i,j)) * 0.125,6.0);\n\n            bloom = pow(texture(iChannel0,vec2(i,j) * scale + lodFactor * pixelSize + coord, lod).rgb,vec3(2.2))*wg + bloom;\n            totalWeight += wg;\n\n        }\n    }\n\n    bloom /= totalWeight;\n\n    return bloom;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n\tvec3 blur = makeBloom(2.,vec2(0.0,0.0), uv);\n\t\tblur += makeBloom(3.,vec2(0.3,0.0), uv);\n\t\tblur += makeBloom(4.,vec2(0.0,0.3), uv);\n\t\tblur += makeBloom(5.,vec2(0.1,0.3), uv);\n\t\tblur += makeBloom(6.,vec2(0.2,0.3), uv);\n\n    fragColor = vec4(pow(blur, vec3(1.0 / 2.2)),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}