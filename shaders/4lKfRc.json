{
    "Shader": {
        "info": {
            "date": "1543443621",
            "description": "Raymarching displacement and morphing.",
            "flags": 0,
            "hasliked": 0,
            "id": "4lKfRc",
            "likes": 5,
            "name": "Bubbling displacement",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "anneka",
            "viewed": 576
        },
        "renderpass": [
            {
                "code": "const float phi = (1.+sqrt(5.))*.5;\n\nfloat rand(vec2 c){\n\treturn fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 eye() {\n    return vec3(.2, .5, 2.);\n}\n\nvec3 lookAt (vec3 from, vec3 target, vec2 uv) {\n    vec3 forward = normalize(target - from);\n    vec3 right = normalize(cross(forward, vec3(0,1,0)));\n    vec3 up = normalize(cross(forward, right));\n    return normalize(forward * .5 + uv.x * right + uv.y * up);\n}\n\nmat2 rotation(float angle) {\n    float c = cos(angle), s = sin(angle);\n    return mat2(c, s, -s, c);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdDodecahedron(vec3 p, float r)\n{\n    const vec3 n = normalize(vec3(phi,1,0));\n\n    p = abs(p/r);\n    float a = dot(p,n.xyz);\n    float b = dot(p,n.zxy);\n    float c = dot(p,n.yzx);\n    return (max(max(a,b),c)-n.x)*r;\n}\n\nfloat sdIcosahedron(vec3 p, float r)\n{\n    const float q = (sqrt(5.)+3.)/2.;\n\n    const vec3 n1 = normalize(vec3(q,1,0));\n    const vec3 n2 = vec3(sqrt(3.)/3.);\n\n    p = abs(p/r);\n    float a = dot(p, n1.xyz);\n    float b = dot(p, n1.zxy);\n    float c = dot(p, n1.yzx);\n    float d = dot(p, n2.xyz)-n1.x;\n    return max(max(max(a,b),c)-n1.x,d)*r; // turn into (...)/r  for weird refractive effects when you subtract this shape\n}\n\nfloat displace(float shape, vec3 p, float freq, float scale) {\n    float d = sin(freq*p.x)*sin(freq*p.y)*sin(freq*p.z);\n    return shape + scale*d;\n}\n\nfloat sdf(vec3 eye) {\n    mat2 rot = rotation(iTime*.1);\n    vec3 p = eye;\n    p.xy *= rot;\n    p.xz *= rot;\n    p.yz *= rot;\n        \n    float shape = min(\n            sdDodecahedron(p,.75),\n            sdIcosahedron(p.zyx,.75)\n        );\n    vec3 pos = eye;\n    float displacedShape = displace(shape, p, mix(20., 1., (sin(iTime)*.5 + .5)), .1);\n    \n    return mix(displacedShape, shape, (sin(iTime)*.5 + .5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv = (uv-.5) / 2.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec4 color = vec4(0.);\n\n    float shade = 0.;\n    float distTotal = 0.;\n\n    vec3 eye = eye();\n    vec3 target = vec3(0);\n    vec3 ray = lookAt(eye, target, uv);\n    const float count = 50.;\n\n    for (float i = count; i > 0.; --i) {\n\n        float dist = sdf(eye);\n\n        if (dist < .0001) {\n            shade = i/count;\n            break;\n        }\n\n        eye += ray * dist;\n        distTotal += dist;\n    }\n    \n    vec3 shadeColor = mix(vec3(0., 1., 0.), vec3(0., 0., 1.), (sin(iTime)*.5 + .5));\n\n\tcolor = vec4(vec3(pow(shade, 2.)) * shadeColor, 1.);\n    \n    color.rgb += rand(uv+vec2(iTime*.00001))*.15;\n   \n    fragColor = color;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}