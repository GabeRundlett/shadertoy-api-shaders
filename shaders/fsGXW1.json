{
    "Shader": {
        "info": {
            "date": "1634545700",
            "description": "another Sailor Moon-inspired background. Unlike in the previous shaders on this theme I've done, I came up with a way to procedurally generate the window patterns rather than place them by hand.",
            "flags": 32,
            "hasliked": 0,
            "id": "fsGXW1",
            "likes": 4,
            "name": "90s Anime Background 3",
            "published": 3,
            "tags": [
                "sdf",
                "night",
                "city",
                "90s",
                "anime",
                "skyline"
            ],
            "usePreview": 0,
            "username": "Xibanya",
            "viewed": 590
        },
        "renderpass": [
            {
                "code": "#define saturate(x) clamp(x, 0., 1.)\nfloat nrand(float x, float y) \n{\n    return fract(sin(dot(\n        vec2(x, y), vec2(12.9898, 78.233))) * \n        43758.5453); \n}\nfloat Luminance(vec3 col)\n{\n    return dot(col, vec3(0.2126729f,  0.7151522f, 0.0721750f));\n}\nvec3 Saturation(vec3 c, float sat)\n{\n    vec3 luma = vec3(Luminance(c));\n    return luma + vec3(sat) * (c - luma);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float jitter = nrand(uv.y, iTime / 20.) * 2. - 1.;\n    uv.x += jitter * step(0.0, abs(jitter)) * 0.00075;\n    \n    vec3 col = texture(iChannel0, uv).rgb;\n    col = Saturation(col, 1.3) * 1.1;\n    \n    vec2 texel = 1. / iResolution.xy;\n    float n = fract(cos(\n        (sin(uv.x / texel.x) * uv.y / texel.y + iTime * 0.01)\n        * 89.) * 343.4);\n\tcol = mix(col, saturate(min(col, n)), 0.15);\n    \n    float vignette = saturate(\n        pow(length(uv * 2. - 1.), 3.) * 0.25);\n    col = mix(col, col * vec3(0.05, 0.2, 0.45), vignette);\n    \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#ifdef GL_OES_standard_derivatives\n    #extension GL_OES_standard_derivatives : enable\n#endif\n#define XTILT 12.\n#define YTILT -90.\n#define FOV 65.\n#define MIN_DIST 0.005\n#define MAX_DIST 100.\n#define MAX_STEPS 75\n#define saturate(x) clamp(x, 0., 1.)\n#define EPS vec3(0.001, 0.0, 0.0)\n#define BGCOLOR vec3(0.0509804, 0.2078432, 0.454902)\n#define WINDOWCOLOR vec3(0.2196079, 0.5764706, 0.482353)\n#define FOG_COLOR vec3(0.1803922, 0.682353, 0.5215687)\n#define STREET_COLOR vec3(0.5255, 0.851, 0.9098)\n#define OUTLINE_COLOR vec3(0.2275, 0.2118, 0.2824)\n#define BGUPPER vec3(0.08235294, 0.5529412, 0.6235294)\n#define BGLOWER vec3(0.0627451, 0.3411765, 0.5176471)\n#define WINDOW_COLOR_0 vec3(0.07058824, 0.3882353, 0.4941177)\n#define WINDOW_COLOR_1 vec3(0.2039216, 1.192157, 0.9960784)\n#define WINDOW_COLOR_2 vec3(0.1960784, 1.262745, 0.9647059)\n#define WINDOW_COLOR_3 vec3(1.283019, 1.207728, 0.3086507)\n#define STAR_COLOR vec3(0.28, 0.28, 0.4)\n#define FOG_SMALL vec3(0.6901961, 0.5176471, 0.7098039)\n\n#define TOTAL_SCALES 5\n#define TOTAL_SIZES 5\n\n#define INIT_SCALES vec2[TOTAL_SCALES] scales; \\\n  scales[0] = vec2(16., 20.); \\\n  scales[1] = vec2(10., 25.); \\\n  scales[2] = vec2(20., 10.); \\\n  scales[3] = vec2(8., 12.); \\\n  scales[4] = vec2(16., 18.)\n\n#define INIT_SIZES vec2[TOTAL_SIZES] sizes; \\\n  sizes[0] = vec2(3., 1.); \\\n  sizes[1] = vec2(2., 2.); \\\n  sizes[2] = vec2(2.75, 1.25); \\\n  sizes[3] = vec2(2., 2.); \\\n  sizes[4] = vec2(2.75, 1.25)\n\n\n// Antialiased step\n// https://github.com/glslify/glsl-aastep\nfloat aastep(float threshold, float value) \n{\n    float afwidth = length(\n        vec2(dFdx(value), dFdy(value))) * 0.70710678118654757;\n    return smoothstep(\n        threshold - afwidth, threshold+afwidth, value); \n}\n/////////// FBM ///////////////\n// see: https://thebookofshaders.com/13/\nfloat FBMRandom(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) *\n                    43758.5453123);\n}\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat FBMNoise(in vec2 st)\n{\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = FBMRandom(i);\n    float b = FBMRandom(i + vec2(1.0, 0.0));\n    float c = FBMRandom(i + vec2(0.0, 1.0));\n    float d = FBMRandom(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n           (c - a) * u.y * (1.0 - u.x) +\n           (d - b) * u.x * u.y;\n}\nfloat FBM(vec2 st, float octaves)\n{\n    float value = 0.;\n    float amplitude = 0.5;\n    float frequency = 0.;\n    for (float i = 0.; i < octaves; i++)\n    {\n        value += amplitude * FBMNoise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\nvec3 WindowFBM(vec2 uv)\n{\n    vec2 st = uv * 2.;\n    float time = iTime * 0.2;\n    vec2 q = vec2(FBM(st + time, 8.), FBM(st + 1., 2.));\n    vec2 r = vec2(\n        FBM(st + q + vec2(1.7, 9.2) + 0.15 * time, 2.),\n        FBM(st + q + vec2(8.3, 2.8) + 0.126 * time, 2.)\n    );\n    float f = FBM(st + r, 8.);\n    float next = saturate((f * f) * 4.);\n    vec3 color = mix(WINDOW_COLOR_0, WINDOW_COLOR_1, next);\n    next =  saturate(length(q));\n    color = mix(color, WINDOW_COLOR_2, next);\n    next = saturate(length(r.x));\n    color = mix(color, WINDOW_COLOR_3, next);\n\n    float finalFactor = (f * f * f + 0.6 * f * f + 0.5 * f);\n    return mix(WINDOWCOLOR, color, saturate(finalFactor));\n}\n///////////////////////////////////////////\n// Perlin \n// see: https://thebookofshaders.com/11/\nfloat SmoothCos(float a, float b, float x)\n{\n    float f = (1. - cos(x * 3.1415927)) * 0.5;\n    return a * (1. - f) + b * f;\n}\n// params.x = precision, params.y = octaves\nfloat Perlin(vec2 uv, vec2 params)\n{\n    float p = 0.;\n    float t = params.x;\n    for (float i = 0.; i < params.y; i++)\n    {\n        float a = FBMRandom(vec2(floor(t * uv.x) / t, floor(t * uv.y) / t));\t   \n        float b = FBMRandom(vec2(ceil (t * uv.x) / t, floor(t * uv.y) / t));\t\t\n        float c = FBMRandom(vec2(floor(t * uv.x) / t, ceil (t * uv.y) / t));\t\t\n        float d = FBMRandom(vec2(ceil (t * uv.x) / t, ceil (t * uv.y) / t));\n        if ((ceil(t * uv.x) / t) == 1.)\n        {\n            b = FBMRandom(vec2(0., floor(t * uv.y) / t));\n            d = FBMRandom(vec2(0., ceil(t * uv.y) / t));\n        }\n        float coef1 = fract(t * uv.x);\n        float coef2 = fract(t * uv.y);\n        p += SmoothCos(\n                SmoothCos(a, b, coef1),\n                SmoothCos(c, d, coef1),\n                coef2\n                ) * (1. / pow(2., (i + 0.6)));\n        t *= 2.;\n    }\n    return p;\n}\nfloat sdCircle(vec2 p, float r)\n{\n    return length(p) - r;\n}\n/// triplanar uv functions from Catlike Coding\n// https://catlikecoding.com/unity/tutorials/advanced-rendering/triplanar-mapping/\nstruct TriplanarUV\n{\n\tvec2 x, y, z;\n};\nTriplanarUV GetTriplanarUV(vec3 pos, vec3 normal, float scale)\n{\n\tTriplanarUV triUV;\n\tvec3 p = pos * scale;\n\ttriUV.x = p.zy;\n\ttriUV.y = p.xz;\n\ttriUV.z = p.xy;\n\tif (normal.x < 0.) triUV.x.x = -triUV.x.x;\n\tif (normal.y < 0.) triUV.y.x = -triUV.y.x;\n\tif (normal.z >= 0.)\ttriUV.z.x = -triUV.z.x;\n\ttriUV.x.y += 0.5;\n\ttriUV.z.x += 0.5;\n\treturn triUV;\n}\nvec3 TriW(vec3 normal)\n{\n  vec3 triW = abs(normal);\nreturn triW / (triW.x + triW.y + triW.z);\n}\nfloat mirror( float p, float offset )\n{\n    p = abs( p );\n    p -= offset;\n    return p;\n}\nfloat sdBox(in vec2 p, in vec2 b)\n{\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\nfloat sdBox(const in vec3 p, const in vec4 b) \n{\n  vec3 d = abs(p) - b.xyz;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)) - b.w;\n}\n//https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat ClearWindows(vec2 uv, vec2 scale)\n{\n    float threshold = 0.6;\n    vec2 s2 = uv * scale;\n    float noise = hash12(floor(s2));\n    float square = step(threshold, noise);\n    return square;\n}\nfloat Grid(vec2 uv, vec2 scale)\n{\n    vec2 st = fract(uv) * scale;\n    vec2 fpos = fract(st);\n    vec2 ipos = floor(st);\n    float grid = saturate(sign(sdBox(fpos, vec2(0.9, .8))));\n    float borderRows = max(\n        step(scale.y - 1., ipos.y), \n        step(ipos.y, 0.));\n    float borderCols = max(\n        step(scale.x - 1., ipos.x),\n        step(ipos.x, 0.)\n    );\n    float borders = max(borderRows, borderCols);\n    grid = max(borders, grid);\n    grid = max(grid, ClearWindows(uv, scale));\n    return grid;\n}\nfloat Bubble(vec2 uv)\n{\n\tfloat circle = sdCircle(uv * 2. + vec2(-1.), .0005);\n\tcircle =  1. - saturate(circle);\n    float mask = aastep(0.01, circle);\n    return max(0., (1. - circle) * mask);\n}\nvec4 Bubbles(vec2 uv)\n{\n    uv.y *= iResolution.y / iResolution.x;\n    vec2 perlin = vec2(Perlin(uv, vec2(2., 6.)));\n    uv += perlin * 0.15;\n    \n    vec2 st = fract(uv + vec2(iTime * 0.012, -0.05)) * vec2(14., 14.);\n    vec2 fpos = fract(st);\n    vec2 ipos = floor(st);\n    float grid = Bubble(fpos);\n    grid *= min(step(mod(ipos.y - 2., 7.), 0.), \n        step(mod(ipos.x - 2., 5.), 0.)\n    );\n    \n    vec4 wcColor = vec4(2.6, 1.2, 1.7, 1.) * 0.35 * grid;\n    \n    st = fract(uv + vec2(iTime * 0.01, -0.02)) * vec2(12., 12.);\n    fpos = fract(st);\n    ipos = floor(st);\n    grid = Bubble(fpos);\n    grid *= min(step(mod(ipos.y - 2., 7.), 0.), \n        step(mod(ipos.x - 8., 5.), 0.)\n    );\n    wcColor = mix(wcColor, vec4(3.9, 2.9, 1.2, 1) * 0.35, grid);  \n    \n    st = fract(uv + vec2(-iTime * 0.01, 0.1)) * vec2(16., 16.);\n    fpos = fract(st);\n    ipos = floor(st);\n    grid = Bubble(fpos);\n    grid *= min(step(mod(ipos.y - 4., 14.), 0.), \n        step(mod(ipos.x - 5., 7.), 0.)\n    );\n    wcColor = mix(wcColor, vec4(3.9, 2.9, 1.2, 1)  * 0.35, grid); \n    \n    st = fract(uv +\n        vec2(iTime * 0.0175, 0.3)) * vec2(16., 16.);\n    fpos = fract(st);\n    ipos = floor(st);\n    grid = Bubble(fpos);\n    grid *= min(step(mod(ipos.y - 7., 14.), 0.), \n        step(mod(ipos.x - 5., 4.), 0.)\n    );\n    wcColor = mix(wcColor, vec4(1.9, 1.1, 2.6, 1) * 0.35, grid);\n    \n    return wcColor;\n}\nint WrappedType(float type)\n{\n  return int(mod(type, float(TOTAL_SCALES)));\n}\nvec2 GetScale(float type)\n{\n  INIT_SCALES;\n  return scales[WrappedType(type)];\n}\n\nfloat CubeDist(vec3 p, out float type)\n{\n  type = 0.;\n  INIT_SIZES;\n  vec2 size = sizes[int(type)];\n  float scene = sdBox(p + vec3(-1., size.x, 0.), vec4(1., size.y, .5, 0.));\n\n  size = sizes[3];\n  float c0 = sdBox(p + vec3(1., size.x, 0.), vec4(1., size.y, .5, 0.));\n  type = scene < c0? type : 3.;\n  scene = min(scene, c0);\n\n  size = sizes[1];\n  float c1 = sdBox(p + vec3(-3., size.x, 0.), vec4(1., size.y, .5, 0.));\n  type = scene < c1? type : 1.;\n  scene = min(scene, c1);\n\n  size = sizes[2];\n  float c2 = sdBox(p + vec3(-5., size.x, 0.), vec4(1., size.y, .5, 0.));\n  type = scene < c2? type : 2.;\n  scene = min(scene, c2);\n  \n  size = sizes[3];\n  float c3 = sdBox(p + vec3(-1., size.x, -4.), vec4(1., size.y, .5, 0.));\n  type = scene < c3? type : 3.;\n  scene = min(scene, c3);\n\n  size = sizes[0];\n  float c35 = sdBox(p + vec3(1., size.x, -4.), vec4(1., size.y, .5, 0.));\n  type = scene < c35? type : 0.;\n  scene = min(scene, c35);\n\n  size = sizes[4];\n  float c4 = sdBox(p + vec3(-3., size.x, -4.), vec4(1., size.y, .5, 0.));\n  type = scene < c4? type : 4.;\n  scene = min(scene, c4);\n\n  size = sizes[0];\n  float c5 = sdBox(p + vec3(-5., size.x, -4.), vec4(1., size.y, .5, 0.));\n  type = scene < c5? type : 5.;\n  scene = min(scene, c5);\n  return scene;\n}\nfloat CubeBack(vec3 p, out float type)\n{\n  type = 1.;\n  INIT_SIZES;\n  float scene = sdBox(p + vec3(-12., 2., -1.), vec4(1., 2., 1., 0.));\n  vec2 size = sizes[2];\n  float c2 = sdBox(p + vec3(-12., size.x, -3.), vec4(1., size.y, 1., 0.));\n  type = scene < c2? type : 2.;\n  scene = min(scene, c2);\n\n  size = sizes[3];\n  float c3 = sdBox(p + vec3(-12., size.x, -5.), vec4(1., size.y, 1., 0.));\n  type = scene < c3? type : 3.;\n  scene = min(scene, c3);\n\n  size = sizes[4];\n  float c4 = sdBox(p + vec3(-12., size.x - 0.25, 1.), \n    vec4(1., size.y + 0.26, 1., 0.));\n  type = scene < c4? type : 4.;\n  scene = min(scene, c4);\n  return scene;\n}\nfloat GetNormalDist(vec3 p)\n{\n  //only need to get normal for one box and use it for everything\n  // since we are just going to use flat uvs for the back boxes\n  float scene = sdBox(p + vec3(-2., 2., 0.), vec4(4., 2., .5, 0.));\n  return scene;\n}\nfloat GetScene(vec3 p, out vec3 col)\n{\n  vec2 uvX = p.zy;\n  vec2 uvY = p.xz;\n  vec2 uvZ = p.xy;\n  float type = 0.;\n  float scene = CubeDist(p, type);\n  int wType = WrappedType(type);\n \n  vec3 normal = normalize(vec3(\n      GetNormalDist(p + EPS.xyy) - GetNormalDist(p - EPS.xyy),\n      GetNormalDist(p + EPS.yxy) - GetNormalDist(p - EPS.yxy),\n      GetNormalDist(p + EPS.yyx) - GetNormalDist(p - EPS.yyx)));\n  \n  vec3 buildingColor = BGCOLOR;\n  vec2 scale = GetScale(type);\n  vec2 buildUV = uvZ * 0.5;\n  float blend = saturate(smoothstep(-0.5, 0.9, p.y + 3.));\n  vec3 fog = FOG_COLOR;\n  buildingColor = mix(fog, BGCOLOR, blend);\n \n  if (wType == 1 || wType == 3)\n  {\n    buildUV.y *= .5;\n  }\n  if (wType == 2 || wType == 4)\n  {\n    buildUV.y *= .75;\n    buildUV.y += 0.5;\n  }\n  float grid = Grid(buildUV, scale);\n  vec3 windowColor = mix(fog, WindowFBM(uvZ), blend);\n  vec3 facade = mix(windowColor, buildingColor, grid);\n  col = mat3(buildingColor, buildingColor, facade) * TriW(normal);\n\n  float backType = 0.;\n  float back = CubeBack(p, backType);\n  vec2 backUV = uvX * 0.5;\n  if (backType == 1. || backType == 3.)\n  {\n    backUV.y *= .5;\n  }\n  if (backType == 2.)\n  {\n    backUV.y *= .75;\n    backUV.y += 0.5;\n  }\n  if (backType == 4.)\n  {\n    backUV.y *= 0.6;\n    backUV.y += 1.25;\n  }\n  float backGrid = Grid(backUV, GetScale(backType));\n  vec3 backCol = mix(windowColor, buildingColor, backGrid);\n  col = scene < back? col : backCol;\n  scene = min(scene, back);\n \n  return scene;\n}\nfloat CastRay(vec3 pos, vec3 dir, out vec3 col) \n{\n  float d = MIN_DIST;\n  for(int i = 0; i < MAX_STEPS; i++) \n  {\n    float dist = GetScene(pos + dir * d, col);\n    if (d > MAX_DIST || d < MIN_DIST) break;\n    d += dist;\n  }\n  col = d > MAX_DIST ? vec3(-1.0) : col;\n  return d;\n}\n/////////////////////////////////////////////////////////\n// star functions adapted from \n// https://www.shadertoy.com/view/ssK3Dt by Scintoth\nfloat noiseFloat(vec2 p)\n{\n    p = fract(p * vec2(1000. * 0.21353, 1000. * 0.97019));\n    p = p + dot(p, p + 1000. * 0.54823);\n    return fract(p.x * p.y);\n}\nvec2 noiseVector(vec2 p)\n{\n    float n = noiseFloat(p);\n    return vec2(n, noiseFloat(p + n));\n}\nvec2 GetPos(vec2 id, vec2 offsets, float time)\n{\n    vec2 n = noiseVector(id + offsets) * 500. * \n        ((8000. + time) / (1000. * 50.));\n    return (sin(n) * 0.9) + offsets;\n}\nfloat Stars(vec2 uv, float time, float gain)\n{\n    uv -= 1.;\n    float m = 0.;\n    uv = uv * 10.;\n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    \n    vec2 p[9];\n    int n = 0;\n    for (float y = -1.; y <= 1.; y++)\n    {\n        for (float x = -1.; x <= 1.; x++)\n        {\n            p[n++] = GetPos(id, vec2(x, y), time);\n        }\n    }\n    for (int i=0; i < 9; i++)\n    {\n        vec2 j = (p[i] - gv) * 2.0;\n        float sparkle = 0.1/dot(j, j) * (gain / (8000.0 + time));\n        m = m + sparkle * (sin(((8000.0 + time)+p[i].x)* 0.5)*0.5 + 0.9);\n    }\n    return m;\n}\nfloat Voronoi(vec2 uv)\n{\n\tvec2 i = floor(uv);\n\tvec2 f = fract(uv);\n\n\tfloat d = 64.;\n\tfor(float y = -1.; y <= 1.; ++y)\n\t{\n\t\tfor (int x = -1; x <= 1; ++x)\n\t\t{\n\t\t\tvec2 b = vec2(x, y);\n            float vNoise = fract(sin(\n                dot(i + b, vec2(101.9364, 96.45418))\n                ) * 100000.0);\n\t\t\tvec2 c = b + vNoise - f;\n\t\t\td = min(d, dot(c, c));\n\t\t}\n\t}\n\treturn sqrt(d);\n}\nvec3 Background(vec2 uv)\n{\n  uv.y += 0.5;\n  float bgBlend = smoothstep(0.4, 0.6, uv.y);\n  bgBlend *= Voronoi(uv * vec2(2., 1.) + vec2(0.2, 0.05) * iTime);\n  vec3 col = mix(BGLOWER, BGUPPER * 1.5, saturate(bgBlend));\n  float stars = saturate(Stars(uv * 2., 0., 100.));\n  col = mix(col, STAR_COLOR * 5., stars);\n  col = mix(col, FOG_SMALL, step(uv.y, 0.35)); \n  return col;\n}\n\nmat3 ViewMatrix(vec3 ro, vec3 ta)\n{\n  vec3 cw = normalize(ta - ro);\n  vec3 up = vec3(0., 1., 0.);\n  vec3 cu = normalize(cross(cw, up));\n  vec3 cv = normalize(cross(cu,cw) );\n  return mat3(cu, cv, cw);\n}\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 uv) \n{\n    vec2 xy = uv - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\nvec3 RotateX(vec3 dir, float degrees)\n{\n    float angleX = radians(degrees);\n\tfloat c = cos(angleX);\n\tfloat s = sin(angleX);\n\tmat4 rotateXMatrix = mat4(1., 0., 0., 0.,\n\t\t0., c, -s, 0.,\n\t\t0., s, c, 0.,\n\t\t0., 0., 0., 1.);\n    return (vec4(dir, 1.) * rotateXMatrix).xyz;\n}\nvec3 RotateY(vec3 dir, float degrees)\n{\n    float angleY = radians(degrees);\n\tfloat c = cos(angleY);\n\tfloat s = sin(angleY);\n\tmat4 rotateYMatrix = mat4(\n        c, 0., s, 0.,\n\t\t0., 1., 0., 0.,\n\t\t-s, 0., c, 0.,\n\t\t0., 0., 0., 1.);\n    return (vec4(dir, 1.) * rotateYMatrix).xyz;\n}  \n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv = fragCoord.xy / iResolution.xy - .5;\n  uv.y *= iResolution.y / iResolution.x;\n\n  vec3 dir = rayDirection(FOV, iResolution.xy, fragCoord.xy);\n  vec2 m = iMouse.z > 0.? (iMouse.xy / iResolution.xy) * 5. : vec2(0.);\n  dir = RotateX(dir, XTILT);\n  dir = RotateY(dir, YTILT);\n  \n  vec3 p = vec3(-5.5 + m.y, -3.8, 2.);\n\n  vec3 bg = Background(uv);\n  vec3 col = vec3(-1.);\n  float d = CastRay(p, dir, col);\n  float y = fragCoord.y / iResolution.y;\n  col = col.r < 0. ? bg : col;\n\n  col = mix(FOG_SMALL, col, smoothstep(0.2, 0.75, y + 0.15));  \n  vec4 bubbles = Bubbles(fragCoord.xy / iResolution.xy);\n  col = mix(col, bubbles.rgb * 4., saturate(bubbles.a));\n  fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}