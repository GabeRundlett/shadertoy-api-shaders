{
    "Shader": {
        "info": {
            "date": "1700613570",
            "description": "To sync audio - stop/rewind/ then play\nHas a few changes and some flashing \n\nAll year long I'm going to just focus on truchet tiles and the likes!",
            "flags": 96,
            "hasliked": 0,
            "id": "ctVczG",
            "likes": 22,
            "name": "Year of Truchets #061",
            "published": 3,
            "tags": [
                "truchet",
                "twist",
                "neonblade"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 309
        },
        "renderpass": [
            {
                "code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #061\n    11/21/2023  @byt3_m3chanic\n    \n    Audio : MoonDeity - NEON BLADE \n*/\n\n#define PI  3.14159265359\nvec2 curvature = vec2(8.,12.);\n\nvec2 remapUV(vec2 uv) {\n    uv = uv * 2. -1.;\n    vec2 offset = abs(uv.yx) / vec2(curvature.x, curvature.y);\n    uv = uv + uv * offset * offset;\n    uv = uv * .5 + .5;\n    return uv;\n}\n\nvec4 scanLine(float uv, float resolution, float opacity) {\n     float intensity = sin(uv * resolution * PI * 2.);\n     intensity = ((.5 * intensity) + .5) * .9 + .1;\n     return vec4(vec3(pow(intensity, opacity)), 1.);\n}\n\nvec4 vignette(vec2 uv, vec2 resolution, float opacity) {\n    float intensity = uv.x * uv.y * (1. - uv.x) * (1. - uv.y);\n    return vec4(vec3(clamp(pow((resolution.x / 4.) * intensity, opacity), 0.0, 1.)), 1.);\n}\n\nvec2 scanLineOpacity = vec2(.275);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {  \n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    uv=(uv*1.05)-vec2(.025,.025);\n    vec2 vuv = remapUV(uv);\n    \n    vec4 baseColor = texture(iChannel0, vuv);\n\n    baseColor *= vignette(vuv, iResolution.xy, .75);\n    baseColor *= scanLine(vuv.x, iResolution.y*1.25, scanLineOpacity.x);\n    baseColor *= scanLine(vuv.y, iResolution.x*1.25, scanLineOpacity.y);\n\n    if (vuv.x < 0.0 || vuv.y < 0.0 || vuv.x > 1.0 || vuv.y > 1.0){\n        baseColor = vec4(vec3(.0),0);\n    }\n   \n    fragColor = vec4(baseColor.rgb,1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 35299,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/satosuguangst/neon-blade"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #060\n    11/18/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n    see all https://www.shadertoy.com/user/byt3_m3chanic/sort=newest\n\n    truchet pattern https://www.shadertoy.com/view/ddXyzH\n*/\n\n#define R   iResolution\n#define M   iMouse\n#define T   iTime\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MAX_DIST    100.\n#define MIN_DIST    .0001\n\nmat2 r45,r1,r2;\nvec3 hit,hitPoint;\nfloat tmod=0.,tspeed=0.,ga1=0.,ga2=0.,ga3=0.,ga4=0.;\n\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){return fract(sin(dot(p,vec2(23.43,84.21)))*4832.323); }\nfloat box(vec3 p, vec3 b) {vec3 q = abs(p) - b;return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);}\nfloat lsp(float b, float e, float t) { return clamp((t - b) / (e-b), 0., 1.); }\nfloat eoc(float t) { return (t = t - 1.) * t * t + 1.; }\n\n//@iq extrude & twist\nfloat opx(in float d, in float p, in float h){\n    vec2 w = vec2(d,abs(p)-h);\n  \treturn min(max(w.x, w.y),0.)+length(max(w,0.));\n}\nvec3 twist( in vec3 p ){\n    float fx = mix(0.,.065,ga1);\n    return vec3(rot((-fx)*p.z)*p.xy,p.z)/1.5;\n}\nvec2 ptile(vec2 uv, float wdx) {\n    vec4 uv1 = vec4(floor(uv),fract(uv)-.5);\n    vec2 id = uv1.xy, q = uv1.zw;\n    \n    float ck = mod(id.x+id.y,2.)*2.-1.;\n    float hs = hash21(id);\n    float wd = .125+.115*sin(uv.y*.25);\n\n    if(hs>.5) q *= rot(1.5707);\n    hs = fract(hs*575.913);\n    \n    vec2 p = length(q-.5)<length(q+.5)? q-.5 : q+.5;\n\n    // main pattern\n    float d = abs(length(p)-.5)-wd;\n    float c = min(length(q.x)-wd,length(q.y)-wd);\n    // alt patterns\n    if (hs>.85) d = c;\n    // accents\n    float b = length(abs(q)-.5)-.125;\n\n    return vec2(d,b);\n }\n\nvec2 map(vec3 pos){\n\n    vec2 res = vec2(1e5,0);\n\n    pos = twist(pos);\n    pos.z -= T*5.;\n\n    vec2 k = ptile(pos.xz*.5,.1);\n    float b = opx(k.x,abs(pos.y)-10., 5.)-.02;\n\n    if(b<res.x) {\n        res = vec2(b,2.);\n        hit = pos;\n    }\n\n    float ff = .5+.5*cos(pos.z*.3+T);\n          ff += .75+.75*sin(pos.x*.2+T*2.);\n          float fx = clamp((-.01)+(T*.04),.0,ff);\n    float c = opx(abs(k.y)-.005,abs(pos.y)-5.5, .12+fx)-.02;\n\n    if(c<res.x) {\n        res = vec2(c,3.);\n        hit = pos;\n    }\n    \n    return res;\n}\n\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd){\n\tfloat d = 0.,m = 0.;\n    for(int i=0;i<180;i++){\n    \tvec2 ray = map(ro + rd * d);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST) break;\n        d += i<42?ray.x*.4:ray.x;\n        m  = ray.y;\n    }\n\treturn vec2(d,m);\n}\n\nvec3 mclr1 = vec3(.9);\nvec3 mclr2 = vec3(.01);\nvec3 fog = vec3(.75);\n\nvoid mainImage( out vec4 O, in vec2 F )\n{   \n    r45 = rot(.7853981634);\n \n    tmod = mod(T,92.);\n    float t1 = lsp(10.0, 11.0, tmod);\n    float t2 = lsp(85.0, 86.0, tmod);\n    float t3 = lsp(66.0, 67.0, tmod);\n    float t4 = lsp(90.0, 91.0, tmod);\n    \n    ga1 = eoc(t1-t2);\n    ga1 = ga1*ga1*ga1;\n\n    ga2 = eoc(t3-t4);\n    ga2 = ga2*ga2*ga2;\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,0,2.5);\n    vec3 rd = normalize(vec3(uv,-1));\n\n    //camera\n    float x = M.xy==vec2(0) || M.z<0. ? .0 : (M.y / R.y * 2.2 - 1.1) * PI;\n    float y = M.xy==vec2(0) || M.z<0. ? .0 : (M.x / R.x * 2.2 - 1.1) * PI;\n    mat2 rx = rot(x), ry = rot(y);\n    \n    ro.yz *= rx, ro.xz *= ry;\n    rd.yz *= rx, rd.xz *= ry;\n\n    vec3 C = vec3(0);\n\n    vec2 ray = marcher(ro,rd);\n    float m = ray.y;\n    float d = ray.x;\n    hitPoint = hit;\n\n\n    mclr1=mix(vec3(.9),vec3(.95,0,0),ga2);\n    mclr2=mix(vec3(.95,0,0),vec3(.04),ga1);\n    \n    if(tmod>66.&&tmod<86.) {\n        fog = mod(T*1.5,1.) <.5? vec3(.1) : vec3(.95,0,0);\n    }else if(tmod>86.&&tmod<92.){\n        fog = mod(T*1.,1.) <.5? vec3(.95,0,0) : vec3(.95);\n    }else{\n        float ff = clamp((-.5)+(T*.04),.1,.95);\n        fog = mod(T*5.5,1.) <.5? vec3(.1) : vec3(ff);\n    }\n\n    if(d<MAX_DIST)\n    {\n        vec3 p = ro + rd * d,\n             n = normal(p,d);\n        vec3 lpos =vec3(-.5,.75,-15.),\n             l = normalize(lpos-p),\n             h = vec3(.5);\n        \n        float shdw = 1.,\n              diff = clamp(dot(n,l),0.,1.);\n              \n        for( float t=.1; t < 8.; ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 18.*h/t);\n            t += h;\n            if( shdw<MIN_DIST || t>8. ) break;\n        }\n\n        diff = mix(diff,diff*shdw,.75);\n\n        if(m==2.) h = mclr1;\n        if(m==3.) h = mclr2;\n\n        C = diff * h;\n    } \n    \n    float fde = clamp((-.1)+(T*.05),.0,1.);\n    C = mix(C,fog,1.-exp(-.000003*d*d*d));\n    C = pow(C*fde, vec3(.4545));\n    O = vec4(C,1.);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}