{
    "Shader": {
        "info": {
            "date": "1619563547",
            "description": "Another shader inspired by some lofi art.\nTry using the Abstract 3 Texture in Buffer A's iChannel0, or Lichen, actually you can try putting any texture on there see how it looks.",
            "flags": 32,
            "hasliked": 0,
            "id": "Nd2Szz",
            "likes": 51,
            "name": "Telesto Inpsired Cover Art",
            "published": 3,
            "tags": [
                "raymarching",
                "space",
                "planet",
                "lensflare",
                "lofi",
                "nft"
            ],
            "usePreview": 1,
            "username": "TheNosiriN",
            "viewed": 1199
        },
        "renderpass": [
            {
                "code": "// Made by: TheNosiriN\n// I wish I didn't use a texture in the end ._.\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define MARGIN //comment to remove annoying margins\n//#define LOW_QUALITY\n\n\n#define R (iResolution.xy)\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n\nconst float margin = 1.65;\nconst vec3 light = normalize(vec3(0.9,0.5,-1));\n\nfloat dot2(vec3 p){ return dot(p,p); }\n\n\n\n// Dave_Hoskins Hash: https://www.shadertoy.com/view/4djSRW\nvec2 hash21(float p){\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n//\n\n\n// Anamorphic lensflare 1: https://www.shadertoy.com/view/wlcyzj\nfloat sunflare(vec2 uv){\n    float ang = atan(uv.y, uv.x);\n\tfloat d = length(uv);\n    d = pow(d, 0.1);\n\tfloat f = 1.2/(length(uv)*25.0+1.2);\n\tf = pow(f, 2.0);\n\tf = f+f*(sin((ang+1.0/18.0)*12.0)*.1+d*.1+.8);\n    return f;\n}\nfloat anflare(vec2 uv, float intensity, float stretch, float brightness){\n    uv.x *= 1.0/(intensity*stretch);\n    uv.y *= 0.5;\n    return smoothstep(0.009, 0.0, length(uv))*brightness;\n}\n//\n\nmat2 rotate(float angle){\n\tangle *= 3.142 / 180.0;\n    float s = sin(angle), c = cos(angle);\n    return mat2( c, -s, s, c );\n}\n\nfloat smin(float a, float b, float k){\n    float h = max(k-abs(a-b), 0.0);\n    return min(a, b) - h*h*h/(6.0*k*k);\n}\n\nvec2 space(vec3 p){\n    float h = sin(p.x*0.05+cos(p.z*0.05))*10.;\n    float i, a=1.;\n    for (vec2 np=p.xz; i<3.; i++){\n        #ifdef LOW_QUALITY\n        float re = textureLod(iChannel0, np*0.002, 1.).r;\n        #else\n        float re = textureLod(iChannel0, np*0.002, 0.).r;\n        #endif\n        h += (re*2.-1.)*a*(h*0.4);\n        np = mat2(0.8,-0.6,0.6,0.8) * np * 2.;\n        a *= 0.5;\n    }\n\n    vec2 d = vec2(p.y+10.+h, 0);\n    \n    p -= vec3(0,-10,-30);\n    p.xy *= rotate(30.);\n    p.xz *= rotate(10.);\n    vec3 q = abs(p)-4.5;\n    float qr = max(q.x,max(q.y,q.z));\n    #ifndef LOW_QUALITY\n    qr -= dot2(textureLod(iChannel0, vec2(p.x,min(p.y,p.z))*0.04, 2.).rgb)*0.3;\n    #endif\n    d.x = smin(d.x, max(qr, -length(p)+6.), 2. );\n    d.x = min(d.x, length( p-vec3(0,-0.5,0) )-1.);\n    \n    d.x *= 0.3;\n    return d;\n}\n\nfloat planet(vec3 eye, vec3 dir){\n    float rad = 4.5;\n    float a = dot(dir, dir);\n    float b = 2.*dot(eye,dir);\n    float c = dot(eye,eye)-rad*rad;\n    float d = b*b-4.*a*c;\n\n    if(d<0.)return -1.;\n    return (-b-sqrt(d))/(2.*a);\n}\n\n\n\nvec3 screenray(vec3 eye, vec3 dir, float maxd){\n    float d, i; vec2 ind;\n    for (; i<100. && d<maxd; i++){\n        vec2 ind = space(eye + dir * d);\n        if (abs(ind.x) < 0.001 * d)break;\n        d += ind.x;\n    }\n    return vec3(d, ind.y, i/100.);\n}\n\n\nfloat shadowray(vec3 eye, vec3 dir, float maxd) {\n    float d, i, r=1., ph=1e10;\n    for(; i<100. && d<maxd; i++){\n     \tvec3 p = eye + dir * d;\n        float ind = space(p).x;\n        if (abs(ind) < 0.001 * d)return 0.;\n        \n        float y = ind*ind/(2.0*ph),\n        nd = sqrt(ind*ind-y*y);\n        r = min( r, 10.0*nd/max(0.0,d-y) );\n        \n        d += ind;\n    }\n\n    return r;\n}\n\n\n\n\nfloat shade(vec3 eye, float dist, float md, vec3 P, vec3 N){\n    float shading = saturate(dot(N, light)*0.5+0.25);\n    shading = mix(min(1.0,shading*3.0), shading, dot(normalize(eye), N));\n    if (shading >= 0.0){ shading *= shadowray(P,light,50.)+0.1; }\n\n    return saturate( (shading+0.1)+(dist/md)*0.1 );\n}\n\n\n\n/* Sometime later...\nfloat stars(vec2 uv){\n    float d, i;\n    for (; i<3.; i++){\n        d = \n    }\n    \n    return d;\n}*/\n\n\n\nfloat makePixel(vec2 C){\n    vec2 uv = (C-R*0.5)/R.y;\n    \n    vec3 eye = vec3(0,-1.5,10);\n    \n    vec3 f = normalize(vec3(3,-3,0) - eye),\n    s = normalize(cross(f, vec3(0,1,0))),\n    dir = (\n        mat4(vec4(s,0), vec4(cross(s, f),0), vec4(-f,0), vec4(1)) * \n        vec4(normalize(vec3(uv, -0.8)), 0)\n    ).xyz;\n    \n    \n    vec3 pdir = dir;\n    float pd = planet(eye-vec3(0,-2,-1), pdir);\n    \n    float md = 100.;\n    vec3 gdir = dir;\n    gdir.y += sin(uv.x*2.0+1.3)*0.1;\n    vec3 dist = screenray(eye, gdir, md);\n    \n    vec3 sdir = dir;\n    sdir.xz *= rotate(-22.);\n    sdir.yz *= rotate(-7.5);\n    vec2 uvs = sdir.xy;\n    \n    \n    float col;\n    \n    if (dist.x < md){\n        vec3 P = eye + gdir * dist.x,\n        ep = vec3(-4, 4, 0) * 0.001,\n        N = normalize(\n            space(P+ep.xyy).x * ep.xyy + \n            space(P+ep.yxy).x * ep.yxy + \n            space(P+ep.yyx).x * ep.yyx + \n            space(P+ep.xxx).x * ep.xxx\n        );\n        \n        col += shade(eye, dist.x, md, P, N);\n        \n    }else{\n        if (pd > -1.){\n            vec3 P = eye + pdir * pd;\n            vec3 N = normalize(P);\n            N = normalize(N + dot2(textureLod(iChannel0, P.xy*0.5, 1.).rgb));\n            \n            float sh = shade(eye, pd, md, P, N)*2.0-1.;\n            col = mix(col, 1.0, saturate(sh));\n        }else{\n            col += length(uvs) < 0.009 ? 1.0 : 0.0;\n        }\n    }\n    col = mix(col*0.4, col, saturate(1.0-pow(dist.z,3.0)*3.0));\n    \n    col += sqrt(sunflare(uvs));\n    float an = pow(anflare(uvs, 600.0, 0.5, 0.63), 4.0);\n    an += smoothstep(0.0025, 1.0, an)*10.0;\n    an *= smoothstep(0.0, 1.0, an);\n    col += an;\n    \n    return saturate(col);\n}\n\n\n\nvoid mainImage( out vec4 O, in vec2 C )\n{\n    if (C == vec2(0.5)){ O.a=R.x; return; }\n    if ( R.x!=texelFetch( iChannel1, ivec2(0), 0).a ){ O = vec4(0); return; }\n    \n    #ifdef MARGIN\n    float mR = min(R.x,R.y);\n    if (abs(C.x-R.x/2.) >= mR/margin){ O = vec4(0.0); return; }\n    if (abs(C.y-R.y/2.) >= mR/margin){ O = vec4(0.0); return; }\n    #endif\n    \n    \n    float col;\n    \n    col = (makePixel(C+hash21(float(iFrame))*1.5) + texture(iChannel1, C/R).r*50.)/51.;\n    \n    \n    // 1 channel, idk what to do with the rest\n    O = vec4(vec3(saturate(col)), 1.);\n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}