{
    "Shader": {
        "info": {
            "date": "1518799032",
            "description": "deep",
            "flags": 0,
            "hasliked": 0,
            "id": "Xs3yWN",
            "likes": 11,
            "name": "deep inside",
            "published": 3,
            "tags": [
                "deep"
            ],
            "usePreview": 0,
            "username": "Del",
            "viewed": 779
        },
        "renderpass": [
            {
                "code": "// Bloody Tunnel - Del - 16/02/2018 (modified water shader from somewhere on shadertoy)\n\n#define EULER 2.7182818284590452353602874\n#define IEULER 0.367879\n// its from here https://github.com/achlubek/venginenative/blob/master/shaders/include/WaterHeight.glsl \nfloat wave(vec2 uv, vec2 emitter, float speed, float phase, float timeshift)\n{\n\tfloat dst = distance(uv, emitter);\n    float time = iTime*0.1;\n\treturn pow(EULER, sin(dst * phase - (time + timeshift) * speed));\n}\nvec2 wavedrag(vec2 uv, vec2 emitter)\n{\n\treturn normalize(uv - emitter);\n}\n\n// Same, but mirror every second cell so they match at the boundaries\nfloat pModMirror1(inout float p, float size)\n{\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize,size) - halfsize;\n\tp *= mod(c, 2.0)*2.0 - 1.0;\n\treturn c;\n}\n\nfloat getwaves(vec2 position,float mirrorX,float mirrorY)\n{\n    float iter = 0.0;\n    float phase = 6.0;\n    float speed = 2.0;\n    float weight = 1.2;\n    float w = 0.0;\n    float ws = 0.0;\n    float iwaterspeed = 1.0;\n    \n    pModMirror1(position.x,mirrorX);\n    pModMirror1(position.y,mirrorY);\n    for(int i=0;i<20;i++)\t\t\t\t\t\t\t\t\t\t// crank this for more veins\n    {\n        vec2 p = vec2(sin(iter), cos(iter)) * 300.0;\n        float res = wave(position, p, speed, phase, 0.0) * IEULER;\n        float res2 = wave(position, p, speed, phase, 0.006) * IEULER;\n        position -= wavedrag(position, p) * (res - res2) * weight * 5.0 * iwaterspeed;\n        w += res * weight;\n        iter += 12.0;\n        ws += weight;\n        weight = mix(weight, 0.0, 0.12);\n        phase *= 1.2;\n        speed = pow(speed, 1.014);\n    }\n    return w / ws;\n}\n\n\n\nvec3 tunnel(vec2 p)\n{\n    float _d = length(p);\n    p.x += sin(p.x);\n    float wibble = 1.0-(0.1+sin(iTime+_d*_d*15.0)*0.1);\n    p.x *= wibble;\n    float offx = 0.1+sin(iTime*0.5)*0.05;\n    float offy = 0.1+cos(iTime*0.5)*0.1;\n    p.x += offx;\n    p.y += 0.1-offy;\n    \n    float a = atan(p.y,p.x);\n    float r = length(p);\n    vec2 uv = vec2( 0.13/r + 0.125*iTime, a/3.1415927 );\n    float w = getwaves(uv,128.0,1.0);\n    vec3 col = vec3( 1.0 - w*vec3(.88-w*.15,1.6,1.8)*1.0 );\n    col = clamp(col,0.0,1.0);\n    r = smoothstep(0.0,0.064,r);\n    col = mix(vec3(0.55,0.1,0.05),col,r*r);\n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ( fragCoord - 0.5* iResolution.xy ) / iResolution.y;\n    vec3 col = tunnel(uv*0.4);\n    \n    \n    // vignette\n    float rf = sqrt(dot(uv, uv)) * 0.666;\n    float rf2_1 = rf * rf + 1.0;\n    col *= 1.0 / (rf2_1 * rf2_1);\n    \n    \n    fragColor = vec4(col.xyz,1.0);\n    \n    \n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}