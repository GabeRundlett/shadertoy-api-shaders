{
    "Shader": {
        "info": {
            "date": "1581946032",
            "description": "Simple Raymarching test",
            "flags": 0,
            "hasliked": 0,
            "id": "3ttSWl",
            "likes": 3,
            "name": "Raymarching basic test",
            "published": 3,
            "tags": [
                "raymarchingtest"
            ],
            "usePreview": 0,
            "username": "xfennec",
            "viewed": 305
        },
        "renderpass": [
            {
                "code": "// based on Rémi Papillié's WebGL conference\n// https://www.youtube.com/watch?v=s6t0mJsgUKw\n\n// NOTE :\n// smooth-min (blending SDF)\n// https://iquilezles.org/articles/smin\n\n\nvec3 lightDir = normalize(vec3(-1.0, 1.0, -1.0));\n\n\nvec2 rotate(vec2 pos, float angle) {\n\tfloat c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, s, -s, c) * pos;\n}\n\n\nfloat opU(float d1, float d2)\n{\n\treturn min(d1,d2);\n}\n\nfloat map(vec3 pos) {\n    float dPlane = sdPlane(pos);\n\n    float dSphere = sdSphere(  pos + vec3( 3.0, -3.0,  0.0), 2.0);\n\n    vec3 posBox = pos + vec3(-3.0, -3.0,  0.0);\n    posBox.xy = rotate(posBox.xy, iTime);\n    posBox.xz = rotate(posBox.xz, iTime * 0.5);\n    float dBox = sdRoundBox(posBox, vec3(1.5, 1.5, 1.5), 0.3);\n    \n    float res = dPlane;\n    res = opU(res, dSphere);\n    res = opU(res, dBox);\n\treturn res;\n}\n\nvec3 computeNormal(vec3 pos) {\n    vec2 eps = vec2(0.01, 0.0);\n    return normalize(vec3(\n        map(pos + eps.xyy) - map(pos - eps.xyy),\n        map(pos + eps.yxy) - map(pos - eps.yxy),\n        map(pos + eps.yyx) - map(pos - eps.yyx)\n    ));\n}\n\nfloat diffuse(vec3 normal) {\n\t//return max(dot(normal, lightDir), 0.0);\n\treturn dot(normal, lightDir) * 0.5 + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // map uv from 0..1 to -1..1 (x will be scaled using viewport ratio)\n    uv -= 0.5;\n  \tuv /= vec2(iResolution.y / iResolution.x, 1);\n    \n    \n \tvec3 pos = vec3(\n        sin(iTime),\n        3.5 + cos(iTime * 0.4),\n        -10.0\n    );\n    vec3 dir = normalize(vec3(uv, 1.0));\n\n    vec3 color = vec3(0.0);\n    \n    for (int i = 0 ; i < 256 ; ++i) {\n        float d = map(pos);\n        if (d < 0.01) {\n            //color = fract(pos * 0.5);\n            color = 0.5+pos*0.1;\n            break;\n        }\n        if (pos.z > 100.0) {\n            break;\n        }\n        pos += d * dir;\n    }\n\n    \n    vec3 finalColor = color * diffuse(computeNormal(pos));\n        \n    // Output to screen\n    //fragColor = vec4(color, 1.0);\n    fragColor = vec4(finalColor, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// distance functions, inigo quilez\n// https://iquilezles.org/articles/distfunctions\n\nfloat sdPlane(vec3 pos) {\n    return pos.y;\n}\n\nfloat sdSphere(vec3 pos, float radius)\n{\n  return length(pos)-radius;\n}\n\nfloat sdRoundBox(vec3 pos, vec3 size, float radius)\n{\n  vec3 q = abs(pos) - (size - vec3(radius));\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - radius;\n}\n\nfloat sdBox(vec3 pos, vec3 size)\n{\n  vec3 q = abs(pos) - size;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\n\n// NOT USED (YET?)\n// https://www.shadertoy.com/view/Wtl3zN \n// adapted from http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nvec3 rotation(vec3 point, vec3 axis, float angle){\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    mat4 rot= mat4(\n    \toc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, 0.0,\n        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,oc * axis.y * axis.z - axis.x * s,  0.0,\n        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c, 0.0,\n        0.0,0.0,0.0,1.0);\n    return (rot*vec4(point,1.)).xyz;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}