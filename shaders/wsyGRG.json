{
    "Shader": {
        "info": {
            "date": "1570465191",
            "description": "Inktober, but with shaders",
            "flags": 0,
            "hasliked": 0,
            "id": "wsyGRG",
            "likes": 3,
            "name": "shadetober #06 (husky)",
            "published": 3,
            "tags": [
                "inktober",
                "shadertober",
                "shadetober",
                "inktober2019"
            ],
            "usePreview": 0,
            "username": "percentcer",
            "viewed": 400
        },
        "renderpass": [
            {
                "code": "// shapes from https://iquilezles.org/articles/distfunctions2d\n// Inktober struggles. I hate this one. -%\n\nfloat cro(in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\nmat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }\nfloat sdCircle( vec2 p, float r )\n{\n  return length(p) - r;\n}\n\n//----------------------------------------------------------------------\n// Distance to y(x) = a + b*cos(cx+d)\n//----------------------------------------------------------------------\nfloat udCos( in vec2 p, in float a, in float b, in float c, in float d )\n{\n    // convert all data to a primitive cosine wave\n    p = c*(p-vec2(d,a));\n\n    // reduce to principal half cycle\n    const float TPI = 6.28318530718;\n    p.x = mod( p.x, TPI); if( p.x>(0.5*TPI) ) p.x = TPI - p.x;\n\n    // find zero of derivative (minimize distance)\n    float xa = 0.0, xb = TPI;\n    for( int i=0; i<24; i++ ) // 24 bit precision\n    {\n        float x = 0.5*(xa+xb);\n        float y = x-p.x+b*c*sin(x)*(p.y-b*c*cos(x));\n        if( y<0.0 ) xa = x; else xb = x;\n    }\n    float x = 0.5*(xa+xb);\n    \n    // compute distance    \n    vec2 q = vec2(x,b*c*cos(x));\n    return length(p-q)/c;\n}\n\nfloat sdUnevenCapsule( in vec2 p, in vec2 pa, in vec2 pb, in float ra, in float rb )\n{\n    p  -= pa;\n    pb -= pa;\n    float h = dot(pb,pb);\n    vec2  q = vec2( dot(p,vec2(pb.y,-pb.x)), dot(p,pb) )/h;\n    \n    //-----------\n    \n    q.x = abs(q.x);\n    \n    float b = ra-rb;\n    vec2  c = vec2(sqrt(h-b*b),b);\n    \n    float k = cro(c,q);\n    float m = dot(c,q);\n    float n = dot(q,q);\n    \n         if( k < 0.0 ) return sqrt(h*(n            )) - ra;\n    else if( k > c.x ) return sqrt(h*(n+1.0-2.0*q.y)) - rb;\n                       return m                       - ra;\n}\n\nfloat sdVesica(vec2 p, float r, float d)\n{\n    p = abs(p);\n    float b = sqrt(r*r-d*d);\n    return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                             : length(p-vec2(-d,0.0))-r;\n}\n\n// sca is the sin/cos of the orientation\n// scb is the sin/cos of the aperture\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, float rb )\n{\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float tval = fract(iTime);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    p *= 2.;\n    \n    p += vec2(1.6, .5);\n    \n    // draw dog head\n    float dHead = sdUnevenCapsule(p, vec2(.2, .8), vec2(2.5, .3), .3, .9);\n    // draw dog jaw\n    float dJaw = sdUnevenCapsule(p, vec2(.4, -.1), vec2(2.5, -.1), .1, .5);\n    // draw dog tongue\n    float dTongue = 0.;\n    // draw dog ears\n    mat2 earrot = rot(-.3);\n    vec2 eartrans = vec2(-2.9, -1.2);\n    float dEar = sdVesica(earrot * (p + eartrans), 1., .7);\n    // draw dog teeth\n    \n    // draw dog eye\n    \n    // draw dog nose\n    \n    // draw dog body\n    \n       \n    float final = \n        sign(dEar)\n        + sign(dHead)\n        + sign(dJaw);\n    final /= 3.;\n\n    // Time varying pixel color\n    vec3 col = vec3(1., .3, .5);\n\n    float wavy = pow(dHead, 2.) * sin(dHead * 100. - iTime * 4.);\n    \n    // Output to screen\n    fragColor = vec4(vec3(final) * col + wavy,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}