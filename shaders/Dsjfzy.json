{
    "Shader": {
        "info": {
            "date": "1689854972",
            "description": "A convenient system for easily loading and storing state variables across frames/buffers without manually figuring out locations to load and store them in the buffers. More info in Common tab.",
            "flags": 32,
            "hasliked": 0,
            "id": "Dsjfzy",
            "likes": 7,
            "name": "State Variables",
            "published": 3,
            "tags": [
                "memory",
                "persistence",
                "variable",
                "persistent"
            ],
            "usePreview": 0,
            "username": "fad",
            "viewed": 215
        },
        "renderpass": [
            {
                "code": "// A convenient system for easily loading and storing state variables\n// across frames/buffers without manually figuring out locations to load\n// and store them in the buffers. More info in Common tab.\n// \n// In this example, a ball's position and velocity is tracked, with a\n// mouse click changing the velocity. Colour changes every bounce/click.\n\nuint PCGHash(uint seed) {\n    uint state = seed * 747796405u + 2891336453u;\n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    return (word >> 22u) ^ word;\n}\n\nfloat rand(uint seed) {\n    return float(PCGHash(seed)) / float(0xffffffffu);\n}\n\nfloat sdCircle(vec2 p, vec2 c, float r) {\n    return distance(p, c) - r;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    // Load the state variables\n    loadState();\n    \n    // Generate a random color based on how many times it's bounced\n    vec3 ballColor = vec3(\n        rand(numBounces * 3u + 0u),\n        rand(numBounces * 3u + 1u),\n        rand(numBounces * 3u + 2u)\n    );\n    \n    // Draw the ball\n    float d = sdCircle(fragCoord, position, radius);\n    fragColor.rgb = mix(ballColor, vec3(1.0), clamp(d + 0.5, 0.0, 1.0));\n    fragColor.a = 1.0;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Usage:\n// Add to the STATE #define below to declare a new state variable. State\n// variables are automatically loaded and stored across buffers/frames.\n// Simply call loadState() at the beginning of mainImage() to make the\n// state variables available for use as global variables, and call\n// storeState() at the end of mainImage() to save any modifications made\n// to the state variables*. Modifications to state variables must be\n// uniform across all shader invocations. loadState() loads state\n// variables from the texture set as iChannel0. storeState() stores\n// state variables in the alpha channel of the current buffer.\n//\n// *Modifications to state variables are not stored if they are done\n// inside of the Image buffer.\n//\n// All types are loaded and stored by casting from and to floats, so the\n// maximum safe integer is 2^24-1.\n\n#define STATE        \\\n    UINT(numBounces) \\\n    VEC2(position)   \\\n    VEC2(velocity)   \\\n    FLOAT(radius)    \\\n\n// Declare the global variables\n#define BOOL(name) bool name;\n#define BVEC2(name) bvec2 name;\n#define BVEC3(name) bvec3 name;\n#define BVEC4(name) bvec4 name;\n#define INT(name) int name;\n#define IVEC2(name) ivec2 name;\n#define IVEC3(name) ivec3 name;\n#define IVEC4(name) ivec4 name;\n#define UINT(name) uint name;\n#define UVEC2(name) uvec2 name;\n#define UVEC3(name) uvec3 name;\n#define UVEC4(name) uvec4 name;\n#define FLOAT(name) float name;\n#define VEC2(name) vec2 name;\n#define VEC3(name) vec3 name;\n#define VEC4(name) vec4 name;\nSTATE\n#undef BOOL\n#undef BVEC2\n#undef BVEC3\n#undef BVEC4\n#undef INT\n#undef IVEC2\n#undef IVEC3\n#undef IVEC4\n#undef UINT\n#undef UVEC2\n#undef UVEC3\n#undef UVEC4\n#undef FLOAT\n#undef VEC2\n#undef VEC3\n#undef VEC4\n\n#ifndef HW_PERFORMANCE\nuniform vec3 iResolution;\nuniform sampler2D iChannel0;\n#endif\n\n// Set the global variables to their appropriate values\nvoid loadState() {\n    int i = 0;\n    int w = textureSize(iChannel0, 0).x;\n    #define GET(i) texelFetch(iChannel0, ivec2(i % w, i / w), 0).a\n    #define BOOL(name) name = bool(GET(i)); i += 1;\n    #define BVEC2(name) BOOL(name.x) BOOL(name.y)\n    #define BVEC3(name) BVEC2(name.xy) BOOL(name.z)\n    #define BVEC4(name) BVEC3(name.xyz) BOOL(name.w)\n    #define INT(name) name = int(GET(i)); i += 1;\n    #define IVEC2(name) INT(name.x) INT(name.y)\n    #define IVEC3(name) IVEC2(name.xy) INT(name.z)\n    #define IVEC4(name) IVEC3(name.xyz) INT(name.w)\n    #define UINT(name) name = uint(GET(i)); i += 1;\n    #define UVEC2(name) UINT(name.x) UINT(name.y)\n    #define UVEC3(name) UVEC2(name.xy) UINT(name.z)\n    #define UVEC4(name) UVEC3(name.xyz) UINT(name.w)\n    #define FLOAT(name) name = GET(i); i += 1;\n    #define VEC2(name) FLOAT(name.x) FLOAT(name.y)\n    #define VEC3(name) VEC2(name.xy) FLOAT(name.z)\n    #define VEC4(name) VEC3(name.xyz) FLOAT(name.w)\n    STATE\n    #undef BOOL\n    #undef BVEC2\n    #undef BVEC3\n    #undef BVEC4\n    #undef INT\n    #undef IVEC2\n    #undef IVEC3\n    #undef IVEC4\n    #undef UINT\n    #undef UVEC2\n    #undef UVEC3\n    #undef UVEC4\n    #undef FLOAT\n    #undef VEC2\n    #undef VEC3\n    #undef VEC4\n    #undef GET\n}\n\n// Store the state variables in fragColor.a\nvoid storeState(inout vec4 fragColor, vec2 fragCoord) {\n    int i = int(fragCoord.x) + int(fragCoord.y) * int(iResolution.x);\n    int j = 0;\n    #define SET(j, v) if (i == j) fragColor.a = float(v)\n    #define BOOL(name) SET(j, name); j += 1;\n    #define BVEC2(name) BOOL(name.x) BOOL(name.y)\n    #define BVEC3(name) BVEC2(name.xy) BOOL(name.z)\n    #define BVEC4(name) BVEC3(name.xyz) BOOL(name.w)\n    #define INT(name) SET(j, name); j += 1;\n    #define IVEC2(name) INT(name.x) INT(name.y)\n    #define IVEC3(name) IVEC2(name.xy) INT(name.z)\n    #define IVEC4(name) IVEC3(name.xyz) INT(name.w)\n    #define UINT(name) SET(j, name); j += 1;\n    #define UVEC2(name) UINT(name.x) UINT(name.y)\n    #define UVEC3(name) UVEC2(name.xy) UINT(name.z)\n    #define UVEC4(name) UVEC3(name.xyz) UINT(name.w)\n    #define FLOAT(name) SET(j, name); j += 1;\n    #define VEC2(name) FLOAT(name.x) FLOAT(name.y)\n    #define VEC3(name) VEC2(name.xy) FLOAT(name.z)\n    #define VEC4(name) VEC3(name.xyz) FLOAT(name.w)\n    STATE\n    #undef BOOL\n    #undef BVEC2\n    #undef BVEC3\n    #undef BVEC4\n    #undef INT\n    #undef IVEC2\n    #undef IVEC3\n    #undef IVEC4\n    #undef UINT\n    #undef UVEC2\n    #undef UVEC3\n    #undef UVEC4\n    #undef FLOAT\n    #undef VEC2\n    #undef VEC3\n    #undef VEC4\n    #undef SET\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// This buffer simulates the ball\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    // Load state variables\n    loadState();\n    \n    // Initialize state variables on the first frame\n    if (iFrame == 0) {\n        numBounces = 0u;\n        position = 0.5 * iResolution.xy;\n        velocity = vec2(0.0);\n        radius = 0.1 * iResolution.y;\n    }\n    \n    // Change ball velocity if mouse was clicked\n    if (iMouse.w > 0.0) {\n        ++numBounces;\n        velocity = 4.0 * (iMouse.xy + 0.5 - position);\n    }\n    \n    // Apply gravity and update velocity and position\n    vec2 gravity = vec2(0.0, -4.0 * iResolution.y);\n    velocity += gravity * iTimeDelta;\n    position += velocity * iTimeDelta;\n    \n    // Collide ball with wall\n    vec2 clamped = clamp(\n        position,\n        vec2(radius),\n        iResolution.xy - radius\n    );\n    \n    if (position != clamped) {\n        ++numBounces;\n        velocity *= mix(\n            vec2(-0.9),\n            vec2(1.0),\n            equal(position, clamped)\n        );\n        position = clamped;\n    }\n    \n    // Store state variables\n    storeState(fragColor, fragCoord);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}