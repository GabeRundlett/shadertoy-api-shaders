{
    "Shader": {
        "info": {
            "date": "1702856401",
            "description": "Originally I wanted to exploit the fact that GPU cores are asynchronous and acquire randomness but the buffer is swapped each frame(which I didn't know) so I decided to implement GOL.\nInitialization is done with a \"random\" state per pixel.",
            "flags": 48,
            "hasliked": 0,
            "id": "XfXGz7",
            "likes": 5,
            "name": "GOL but it's RGB",
            "published": 3,
            "tags": [
                "visualization",
                "random"
            ],
            "usePreview": 0,
            "username": "rafa_br34",
            "viewed": 198
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 FragColor, in vec2 FragCoord) {\n    FragColor = READP_V4(C_StateBuffer, FragCoord) * vec4(1.0, 1.0, 1.0, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float Lives(float Neighbors, float Self) {\n    ///*\n    bool Lives = (\n        // Is alive and has 2 or 3 neighbors\n        (Self > 0.5 && (Neighbors == 2.0 || Neighbors == 3.0)) ||\n        // Or has 3 neighbors\n        (Neighbors == 3.0)\n    );\n    //*/\n    \n    /*\n    bool Lives = (\n        (Self > 0.5 && (Neighbors == 2.0 || Neighbors == 3.0 || Neighbors == 1.0)) ||\n        (Neighbors == 1.0 || Neighbors == 3.0)\n        \n    );\n    //*/\n    return Lives ? 1.0 : 0.0;\n}\n\n\n\nvoid mainImage(out vec4 FragColor, in vec2 FragCoord) {\n    #define N(DeltaX, DeltaY) round(READP_V4(C_StateBuffer, ivec2(FragCoord) + ivec2(DeltaX, DeltaY)))\n    \n    if (iFrame <= 1 || READP_V4(iChannel1, ivec2(32, 1)).x > 0.0) {\n        // Low entropy initialization\n        //uint S = RAND_STATE(FragCoord) * uint(iTimeDelta * float(0xFFFFFF)) * TIMESTAMP;\n        \n        // High entropy initialization\n        uint S = RAND_STATE(FragCoord); XORSHIFT32(S); S *= 0x9E3779B9u * TIMESTAMP; XORSHIFT32(S);\n        \n        \n        \n        FragColor = vec4(\n            FUI8((S >> 16) & 0xFFu),\n            FUI8((S >> 8) & 0xFFu),\n            FUI8((S >> 0) & 0xFFu),\n            1.0\n        );\n    }\n    else {\n        vec4 Self = N(0, 0);\n\n        \n        vec4 Neighbors = (\n            N(1,  1) + N(0,  1) + N(-1,  1) +\n            N(1,  0) +          + N(-1,  0) +\n            N(1, -1) + N(0, -1) + N(-1, -1)\n        );\n\n        FragColor = vec4(Lives(Neighbors.x, Self.x), Lives(Neighbors.y, Self.y), Lives(Neighbors.z, Self.z), 1.0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define C_StateBuffer iChannel0\n\n\n#define RESX uint(iResolution.x)\n#define RESY uint(iResolution.y)\n\n#define FLATTEN_V2(Width, Vector) ((Width) * (Vector).y + (Vector).x)\n\n#define READP_V4(Buffer, Position) texelFetch(Buffer, ivec2(Position), 0)\n#define READP_F32(Buffer, Position) READP_V4(Buffer, ivec2(Position) / 4)[FLATTEN_V2(2, ivec2(Position)) % 4]\n#define READP_U8(Buffer, Position) READP_F32(Buffer, ivec2(Position) / 4)[FLATTEN_V2(2, ivec2(Position)) % 4]\n\n#define TIMESTAMP ((uint(iDate.x) - 1970u) * 31557600u) + (uint(iDate.y) * 2629800u) + (uint(iDate.z - 1.0) * 86400u) + uint(iDate.w)\n\n#define READI_V4(Buffer, Index) READP_V4(Buffer, ivec2(uint(Index) % RESX, uint(Index) / RESX))\n#define READI_F32(Buffer, Index) READI_V4(Buffer, uint(Index) / 4u)[uint(Index) % 4u]\n#define READI_U8(Buffer, Index) (uint(READI_F32(Buffer, uint(Index) / 4u)) & (0xFFu << ((Index % 4u) * 8u))) >> ((Index % 4u) * 8u)\n\n#define RAND_STATE(Coord) ((RESX * uint(Coord.y) + uint(Coord.x) + 1u) * (uint(iFrame) + 1u))\n\n#define UI8(V) uint(int(V) % 256)\n#define FUI8(V) float(UI8(V)) / 255.0\n\n#define XORSHIFT32(S) S ^= (S << 13); S ^= (S >> 17); S ^= (S << 5);",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}