{
    "Shader": {
        "info": {
            "date": "1582531981",
            "description": "- A simple scene to test rendering of water with caustics (see Cube A for paper reference).\n- Drag mouse to add waves.  Hold 'space' to freeze the water.",
            "flags": 48,
            "hasliked": 0,
            "id": "ttdXRf",
            "likes": 84,
            "name": "Interactive fluid with caustics",
            "published": 3,
            "tags": [
                "wave",
                "water",
                "fluid",
                "abstract",
                "caustics"
            ],
            "usePreview": 0,
            "username": "tmst",
            "viewed": 1933
        },
        "renderpass": [
            {
                "code": "//#define DEBUG_OUTPUT\n\n#define W_0 0.05675675675\n#define W_1 0.1581081081\n#define W_2 0.03513513515\n\n#define BLUR_MAX_PCT 0.004\n\n#define VIGNETTE_INTENSITY 0.4\n\nvec3 blurSample(sampler2D tex, vec2 uv, float blurAmount) {\n    float pct = blurAmount*BLUR_MAX_PCT;\n    vec2 sampleRBase = vec2(1.0, iResolution.y/iResolution.x);\n    vec3 finalColor = vec3(0.0);\n\n    vec2 sampleR = pct * sampleRBase;\n    float ra = rand(uv)*PI_OVER_4;\n    float rs = sin(ra);\n    float rc = cos(ra);\n    finalColor += W_0 * textureLod(tex, uv + vec2( rc, rs)*sampleR, 0.0).rgb;\n    finalColor += W_0 * textureLod(tex, uv + vec2(-rs, rc)*sampleR, 0.0).rgb;\n    finalColor += W_0 * textureLod(tex, uv + vec2(-rc,-rs)*sampleR, 0.0).rgb;\n    finalColor += W_0 * textureLod(tex, uv + vec2( rs,-rc)*sampleR, 0.0).rgb;\n\n    sampleR = 2.0 * pct * sampleRBase;\n    ra += PI_OVER_4;\n    rs = sin(ra);\n    rc = cos(ra);\n    finalColor += W_1 * textureLod(tex, uv + vec2( rc, rs)*sampleR, 0.0).rgb;\n    finalColor += W_1 * textureLod(tex, uv + vec2(-rs, rc)*sampleR, 0.0).rgb;\n    finalColor += W_1 * textureLod(tex, uv + vec2(-rc,-rs)*sampleR, 0.0).rgb;\n    finalColor += W_1 * textureLod(tex, uv + vec2( rs,-rc)*sampleR, 0.0).rgb;\n\n    sampleR = 3.0 * pct * sampleRBase;\n    ra += PI_OVER_4;\n    rs = sin(ra);\n    rc = cos(ra);\n    finalColor += W_2 * textureLod(tex, uv + vec2( rc, rs)*sampleR, 0.0).rgb;\n    finalColor += W_2 * textureLod(tex, uv + vec2(-rs, rc)*sampleR, 0.0).rgb;\n    finalColor += W_2 * textureLod(tex, uv + vec2(-rc,-rs)*sampleR, 0.0).rgb;\n    finalColor += W_2 * textureLod(tex, uv + vec2( rs,-rc)*sampleR, 0.0).rgb;\n\n    return finalColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float blurAmount = textureLod(iChannel0, uv, 0.0).a;\n    vec3 blurColor = blurSample(iChannel0, uv, blurAmount);\n\n    float dCorner = length(uv - vec2(0.5)) * 1.414214;\n    float vignetteFactor = 1.0 - mix(0.0, VIGNETTE_INTENSITY, smoothstep(0.3, 0.9, dCorner));\n\n    fragColor = vec4(vignetteFactor*blurColor, 1.0);\n\n    #ifdef DEBUG_OUTPUT\n        vec2 r = uv * vec2(3.0, 2.0);\n        int page = 1 + int(floor(r.y))*3 + int(floor(r.x));\n        vec2 fragCoordDebug = fract(r) * vec2(1024.0);\n\n        vec4 debugColor = texture(iChannel1, vcubeFromFragCoord(page, fragCoordDebug));\n        float debugAlpha = 0.6;\n        fragColor = mix(fragColor, debugColor, debugAlpha);\n    #endif\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ================\n// Generic helpers\n// ================\n\n#define PI_OVER_2 1.570796326794896\n#define PI_OVER_4 0.7853981633974483\n\n// Find t so that mix(a,b,t) = x\nfloat unmix(float a, float b, float x) {\n    return (x - a)/(b - a);\n}\n\nfloat isInInterval(float a, float b, float x) {\n    return step(a, x) * (1.0 - step(b, x));\n}\n\nfloat rand(vec2 p) {\n    return fract(sin(dot(p,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat lensq(vec3 v) {\n    return dot(v, v);\n}\n\nfloat distsq(vec3 p, vec3 q) {\n    vec3 pq = q - p;\n    return dot(pq, pq);\n}\n\nfloat sdBox(vec3 boxCenter, vec3 boxRadii, vec3 p) {\n    vec3 q = boxRadii - abs(p - boxCenter);\n    return length(min(q, 0.0)) - max( min(min(q.x, q.y), q.z), 0.0 );\n}\n\nvec2 cpSeg2(vec2 q0, vec2 q1, vec2 p) {\n    vec2 vEdge = q1 - q0;\n    float t = dot(p - q0, vEdge) / dot(vEdge, vEdge);\n    return q0 + clamp(t, 0.0, 1.0)*vEdge;\n}\n\nfloat sdSeg2(vec2 q0, vec2 q1, vec2 p) {\n    vec2 x = cpSeg2(q0,q1, p);\n    return distance(x, p);\n}\n\nvoid materialShader(\n    in float diffuseCoefficient,\n    in float specularCoefficient,\n    in float specularExponent,\n    in vec3 lightColor,\n    in vec3 texColor,\n    in vec3 nvNormal,\n    in vec3 nvFragToLight,\n    in vec3 nvFragToCam,\n    out vec3 diffuseContribution,\n    out vec3 specularContribution\n) {\n    //compute diffuse intensity\n    float intensityDiffuse = clamp(dot(nvNormal, nvFragToLight), 0.0, 1.0);\n    intensityDiffuse *= diffuseCoefficient;\n\n    //compute specular intensity\n    vec3 blinnH = normalize(nvFragToLight + nvFragToCam);\n    float intensitySpecular = pow(clamp(dot(nvNormal, blinnH), 0.0, 1.0), specularExponent);\n    intensitySpecular *= specularCoefficient;\n\n    //output diffuse and specular values\n    diffuseContribution = intensityDiffuse * texColor * lightColor;\n    specularContribution = intensitySpecular * lightColor;\n}\n\n// Mouse input\n//---------------------------------------\n// Not a very good method but it's fine for this purpose\n\nvec2 packUVWithBool(vec2 uv, bool b) {\n    return vec2(uv.s, 0.4*uv.t + (b ? 0.5 : 0.0));\n}\n\nvoid unpackUVWithBool(in vec2 pack, out vec2 uv, out bool b) {\n    b = pack.t > 0.45;\n    uv = vec2(pack.s, 2.5*(pack.t - (b ? 0.5 : 0.0)));\n}\n//---------------------------------------\n\n// ========================\n// Scene helpers/constants\n// ========================\n\n#define POOL_SURFACE_WORLD_MIN vec3(-0.8, 0.0, -0.8)\n#define POOL_SURFACE_WORLD_MAX vec3( 0.8, 0.0,  0.8)\n#define POOL_SURFACE_CENTER (0.5*(POOL_SURFACE_WORLD_MIN+POOL_SURFACE_WORLD_MAX))\n#define POOL_BUMP_HEIGHT_WORLD 0.04\n#define POOL_DEPTH_WORLD 0.1\n\n#define IR_LIQUID 1.333\n#define IR_AIR 1.000\n\n#define TAN_HALF_FOVY 0.5773502691896257\n#define CAM_Z_NEAR 0.1\n#define CAM_Z_FAR 50.0\n\nmat4 getClipToWorld(vec3 iResolution, vec3 nvCamFw, vec3 nvCamFixedUp) {\n    float ratio = iResolution.x / iResolution.y;\n    mat4 clipToEye = mat4(\n        ratio * TAN_HALF_FOVY, 0.0, 0.0, 0.0,\n        0.0, TAN_HALF_FOVY, 0.0, 0.0,\n        0.0, 0.0,  0.0, (CAM_Z_NEAR - CAM_Z_FAR) / (2.0 * CAM_Z_NEAR * CAM_Z_FAR),\n        0.0, 0.0, -1.0, (CAM_Z_NEAR + CAM_Z_FAR) / (2.0 * CAM_Z_NEAR * CAM_Z_FAR)\n    );\n\n    vec3 nvCamRt = normalize(cross(nvCamFw, nvCamFixedUp));\n    vec3 nvCamUp = cross(nvCamRt, nvCamFw);\n    mat4 eyeToWorld = mat4(\n         nvCamRt, 0.0,\n         nvCamUp, 0.0,\n        -nvCamFw, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n\n    return eyeToWorld * clipToEye;\n}\n\nvoid sceneCamera(\n    in vec3 iResolution,\n    in vec2 fragCoord,\n    in float iTime,\n    out vec3 camPos,\n    out vec3 nvCamDir\n) {\n    float t = mod(iTime, 16.0);\n    float angS = smoothstep(1.,3.,t) + smoothstep(5.,7.,t) + smoothstep(9.,11.,t) + smoothstep(13.,15.,t);\n    float ang = 0.2 + angS*PI_OVER_2;\n    float radS = smoothstep(1.,3.,t) - smoothstep(9.,11.,t);\n    float rad = mix(0.6, 0.9, radS);\n    camPos = (rad+0.05*cos(iTime*0.5))*vec3(sin(ang), 0.5+0.05*sin(iTime*0.5), cos(ang));\n\n    vec3 camTarget = vec3(0.0);\n    vec3 nvCamFw = normalize(camTarget - camPos);\n\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 clip = vec4(uv * 2.0 - 1.0, 1.0, 1.0);\n\n    vec3 nvCamFixedUp = vec3(0.0, 1.0, 0.0);\n    vec4 world = getClipToWorld(iResolution, nvCamFw, nvCamFixedUp) * clip;\n    nvCamDir = normalize(world.xyz / world.w);\n}\n\nvec3 sceneLight(in float iTime) {\n    return vec3(6.0, 7.8, -6.0);\n}\n\n// ================================================\n// Cubemap helpers (treat as 6x1024x1024 textures)\n// ================================================\n\nvec2 wrapFragCoord(vec2 fragCoord) {\n    // Simulate wrap: mirror\n    return abs(1023.0 - mod(fragCoord + 1023.0, 2046.0));\n}\n\nvec3 vcubeFromFragCoord(int page, vec2 fragCoord)\n{\n    vec2 p = (wrapFragCoord(fragCoord) + 0.5)*(2.0/1024.0) - 1.0;\n\n    vec3 fv;\n    if (page == 1) {\n        fv = vec3(1.0, p);\n    } else if (page == 2) {\n        fv = -vec3(1.0, p);\n    } else if (page == 3) {\n        fv = vec3(p.x, 1.0, p.y);\n    } else if (page == 4) {\n        fv = -vec3(p.x, 1.0, p.y);\n    } else if (page == 5) {\n        fv = vec3(p, 1.0);\n    } else if (page == 6) {\n        fv = -vec3(p, 1.0);\n    }\n    return fv;\n}\n\nvoid fragCoordFromVCube(in vec3 vcube, out int page, out vec2 fragCoord)\n{\n    vec2 p;\n    if (abs(vcube.x) > abs(vcube.y) && abs(vcube.x) > abs(vcube.z)) {\n        if (vcube.x > 0.0) { page = 1; } else { page = 2; }\n        p = vcube.yz/vcube.x;\n    } else if (abs(vcube.y) > abs(vcube.z)) {\n        if (vcube.y > 0.0) { page = 3; } else { page = 4; }\n        p = vcube.xz/vcube.y;\n    } else {\n        if (vcube.z > 0.0) { page = 5; } else { page = 6; }\n        p = vcube.xy/vcube.z;\n    }\n\n    fragCoord = floor((0.5 + 0.5*p)*1024.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Description and references:\n// -------------------------------------------------------------------------------\n// This shader implements the method for rendering caustics described in [1].\n// Multiple render targets are replaced by writing to multiple cube faces.\n// - [1] \"Fast Real-time Caustics from height Fields\" (Yuksel, Keyser)\n// -------------------------------------------------------------------------------\n\n// Keyboard input description: https://www.shadertoy.com/view/lsXGzf\n#define KEY_SPACE 32\n\n// ================\n// Generic helpers\n// ================\n\nvec4 read(int page, vec2 fragCoord) {\n    return textureLod(iChannel0, vcubeFromFragCoord(page, fragCoord), 0.0);\n}\n\nvec2 getHeightData(vec2 fragCoord) {\n    return read(1, fragCoord).rg;\n}\n\nvec3 getSurfaceNormal(vec2 fragCoord) {\n    return 2.0*( read(2, fragCoord).xyz - 0.5 );\n}\n\n// ==============\n// Shallow water\n// ==============\n\n// Helpers for initial/reset value\n// ---------------------------------------\nfloat noise(in vec2 p) {\n    vec2 pi = floor(p);\n    vec2 pf = fract(p);\n\n    float r00 = rand(vec2(pi.x    ,pi.y    ));\n    float r10 = rand(vec2(pi.x+1.0,pi.y    ));\n    float r01 = rand(vec2(pi.x    ,pi.y+1.0));\n    float r11 = rand(vec2(pi.x+1.0,pi.y+1.0));\n\n    vec2 m = pf*pf*(3.0-2.0*pf);\n    return mix(mix(r00, r10, m.x), mix(r01, r11, m.x), m.y);\n}\n\nfloat fbm(vec2 uv) {\n    vec2 p = uv*32.0;\n\n    float v = noise(p);\n\n    p *= 0.5;\n    v = mix(v, noise(p), 0.5);\n\n    p *= 0.5;\n    v = mix(v, noise(p), 0.5);\n\n    return v;\n}\n// ---------------------------------------\n\nvoid writePage1(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 data0 = read(1, fragCoord);\n\n    vec2 h0 = data0.rg;\n    vec2 hXB = getHeightData( fragCoord + vec2(1.0,0.0) );\n    vec2 hXA = getHeightData( fragCoord - vec2(1.0,0.0) );\n    vec2 hZB = getHeightData( fragCoord - vec2(0.0,1.0) );\n    vec2 hZA = getHeightData( fragCoord + vec2(0.0,1.0) );\n\n    float hAvg = 0.25 * (hXB.s + hXA.s + hZB.s + hZA.s);\n    float hNew = mix(h0.t, hAvg, 2.0);\n\n    vec2 uv = fragCoord/vec2(1024.0);\n\n    // Mouse input\n    //---------------------------------------\n    vec2 packMouse0 = textureLod(iChannel2, vec2(0.0), 0.0).rg;\n    vec2 packMouse1 = data0.ba;\n\n    vec2 uvMouse0;\n    bool isMousePressed0;\n    unpackUVWithBool(packMouse0, uvMouse0, isMousePressed0);\n\n    vec2 uvMouse1;\n    bool isMousePressed1;\n    unpackUVWithBool(packMouse1, uvMouse1, isMousePressed1);\n\n    if (isMousePressed0 && isMousePressed1) {\n        float targetDistUV = sdSeg2(uvMouse0, uvMouse1, uv);\n\n        float bumpHeight = smoothstep(0.0, 0.03, targetDistUV);\n        hNew = max(hNew, 1.0-bumpHeight);\n    }\n    //---------------------------------------\n\n    // Damping\n    hNew = mix(hNew, 0.5, 0.003);\n\n    // Initial/reset value\n    if (iTime < 0.1) {\n        float a = fbm(uv*0.25)*6.28;\n        hNew = fbm( uv +  0.25*vec2(cos(a), sin(a)) );\n        hNew = smoothstep(0.4, 0.6, hNew);\n    }\n\n    // Clamp\n    hNew = clamp(hNew, 0.0, 1.0);\n\n    bool isSpacePressed = texelFetch(iChannel1, ivec2(KEY_SPACE,0), 0).x > 0.5;\n    fragColor = isSpacePressed ? data0 : vec4(hNew, h0.s, packMouse0);\n}\n\n// ====================\n// Pool surface normal\n// ====================\n\nvoid writePage2(out vec4 fragColor, in vec2 fragCoord)\n{\n    float hXB = getHeightData( fragCoord + vec2(1.0,0.0) ).r;\n    float hXA = getHeightData( fragCoord - vec2(1.0,0.0) ).r;\n    float hZB = getHeightData( fragCoord - vec2(0.0,1.0) ).r;\n    float hZA = getHeightData( fragCoord + vec2(0.0,1.0) ).r;\n\n    vec2 pixelWorldSize = (POOL_SURFACE_WORLD_MAX.xz - POOL_SURFACE_WORLD_MIN.xz) / 1024.0;\n    vec2 gradh = vec2(hXB-hXA, hZB-hZA) * POOL_BUMP_HEIGHT_WORLD / (2.0 * pixelWorldSize);\n    vec3 surfaceNormal = normalize(vec3(-gradh.s, 1.0, -gradh.t));\n\n    fragColor = vec4(0.5 + 0.5*surfaceNormal, 0.0);\n}\n\n// =================\n// Caustics Pass 1A\n// =================\n\nvec3 surfaceUVToWorld(vec2 uv) {\n    return vec3(\n        mix(POOL_SURFACE_WORLD_MIN.x, POOL_SURFACE_WORLD_MAX.x, uv.s),\n        mix(POOL_SURFACE_WORLD_MIN.y, POOL_SURFACE_WORLD_MAX.y, 0.5),\n        mix(POOL_SURFACE_WORLD_MAX.z, POOL_SURFACE_WORLD_MIN.z, uv.t)\n    );\n}\n\nvec2 surfaceWorldToUV(vec3 p) {\n    return vec2(\n        unmix(POOL_SURFACE_WORLD_MIN.x, POOL_SURFACE_WORLD_MAX.x, p.x),\n        unmix(POOL_SURFACE_WORLD_MAX.z, POOL_SURFACE_WORLD_MIN.z, p.z)\n    );\n}\n\nvoid causticPass1(out vec4 fragColor, in vec2 fragCoord, float yOffset)\n{\n    vec2 uv = fragCoord / vec2(1024.0);\n\n    vec3 poolWorldPos = surfaceUVToWorld(uv);\n    vec3 baseWorldPos = poolWorldPos - vec3(0.0, POOL_DEPTH_WORLD, 0.0);\n    vec3 lightWorldPos = sceneLight(iTime);\n\n    // \"Un-refract\" to compute the \"illumination center\" on the pool surface\n    // --------------------------------------------------------------------\n    // We want the surface point refracting lightWorldPos onto baseWorldPos.\n    // For IR ratios 0 and 1, easy to find--correct point is somewhere between.\n    // So we do a binary search between those two points.\n\n    vec3 eta0 = poolWorldPos;\n    vec3 eta1 = mix(baseWorldPos, lightWorldPos, unmix(baseWorldPos.y, lightWorldPos.y, POOL_SURFACE_CENTER.y));\n\n    vec3 vecOut0 = refract(normalize(eta0-lightWorldPos), vec3(0.0,1.0,0.0), IR_AIR/IR_LIQUID);\n    vec3 vecOutBase0 = eta0 - (POOL_DEPTH_WORLD/vecOut0.y)*vecOut0;\n    float dsq0 = 0.0;\n\n    vec3 vecOut1 = refract(normalize(eta1-lightWorldPos), vec3(0.0,1.0,0.0), IR_AIR/IR_LIQUID);\n    vec3 vecOutBase1 = eta1 - (POOL_DEPTH_WORLD/vecOut1.y)*vecOut1;\n    float dsq1 = lensq(vecOutBase0-vecOutBase1);\n\n    float dsqTarget = lensq(vecOutBase0-baseWorldPos);\n\n    float b0 = 0.0;\n    float b1 = 1.0;\n    for (int k=0; k<10; k++) {\n        float bStep = mix(b0, b1, 0.5);\n        vec3 test = mix(eta0, eta1, bStep);\n\n        vec3 vecOutTest = refract(normalize(test-lightWorldPos), vec3(0.0,1.0,0.0), IR_AIR/IR_LIQUID);\n        vec3 vecOutBaseTest = test - (POOL_DEPTH_WORLD/vecOutTest.y)*vecOutTest;\n        float dsqTest = lensq(vecOutBase0-vecOutBaseTest);\n\n        if (dsqTest < dsqTarget) {\n            b0 = bStep;\n        } else {\n            b1 = bStep;\n        }\n    }\n\n    vec3 icWorld = mix(eta0, eta1, mix(b0, b1, 0.5));\n    vec2 icUV = surfaceWorldToUV(icWorld);\n    vec2 icFragCoord = icUV * 1024.0;\n    // --------------------------------------------------------------------\n\n    vec4 finalResult = vec4(0.0);\n\n    vec2 pixelWorldSize = (POOL_SURFACE_WORLD_MAX.xz - POOL_SURFACE_WORLD_MIN.xz) / 1024.0;\n    for (int i=-3; i<=3; i++) {\n        vec2 sampleFragCoord = icFragCoord + vec2(float(i), 0.0);\n\n        // \"Straighten\" normal to make caustics less sensitive to gradients\n        vec3 nSurface = getSurfaceNormal(sampleFragCoord);\n        nSurface = normalize( mix(vec3(0.0,1.0,0.0), nSurface, 0.25) );\n\n        vec3 sampleWorld = icWorld + vec3(float(i)*pixelWorldSize.x, 0.0, 0.0);\n\n        vec3 vecOut = refract(normalize(sampleWorld-lightWorldPos), nSurface, IR_AIR/IR_LIQUID);\n        vec3 vecOutBase = sampleWorld - (POOL_DEPTH_WORLD/vecOut.y)*vecOut;\n\n        vec2 hitFragCoord = surfaceWorldToUV(vecOutBase) * 1024.0;\n        float ax = max(0.0, 1.0 - abs( fragCoord.x - hitFragCoord.x ));\n        finalResult += ax * vec4(\n            max(0.0, 1.0 - abs( fragCoord.y+( 0.0+yOffset) - hitFragCoord.y )),\n            max(0.0, 1.0 - abs( fragCoord.y+( 1.0+yOffset) - hitFragCoord.y )),\n            max(0.0, 1.0 - abs( fragCoord.y+( 2.0+yOffset) - hitFragCoord.y )),\n            max(0.0, 1.0 - abs( fragCoord.y+( 3.0+yOffset) - hitFragCoord.y ))\n        );\n    }\n\n    fragColor = finalResult;\n}\n\nvoid writePage3(out vec4 fragColor, in vec2 fragCoord) {\n    causticPass1(fragColor, fragCoord, 0.0);\n}\n\n// =================\n// Caustics Pass 1B\n// =================\n\nvoid writePage4(out vec4 fragColor, in vec2 fragCoord) {\n    causticPass1(fragColor, fragCoord, -3.0);\n}\n\n// ================\n// Caustics Pass 2\n// ================\n\nvoid writePage5(out vec4 fragColor, in vec2 fragCoord) {\n    float intensity = (\n        read(3, fragCoord                ).r +\n        read(3, fragCoord - vec2(0.0,1.0)).g +\n        read(3, fragCoord - vec2(0.0,2.0)).b +\n        read(3, fragCoord - vec2(0.0,3.0)).a +\n        read(4, fragCoord + vec2(0.0,3.0)).r +\n        read(4, fragCoord + vec2(0.0,2.0)).g +\n        read(4, fragCoord + vec2(0.0,1.0)).b\n    );\n    fragColor = vec4(clamp(0.5*intensity, 0.0, 1.0));\n}\n\n// =========================\n// Output depends on \"page\"\n// =========================\n\nvoid mainCubemap( out vec4 fragColor, in vec2 _fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    int page;\n    vec2 fragCoord;\n    fragCoordFromVCube(rayDir, page, fragCoord);\n\n    if (page == 1) {\n        writePage1(fragColor, fragCoord);\n    } else if (page == 2) {\n        writePage2(fragColor, fragCoord);\n    } else if (page == 3) {\n        writePage3(fragColor, fragCoord);\n    } else if (page == 4) {\n        writePage4(fragColor, fragCoord);\n    } else if (page == 5) {\n        writePage5(fragColor, fragCoord);\n    } else {\n        discard;\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            },
            {
                "code": "#define MIN_DIST 0.005\n#define MAX_DIST 50.0\n#define RAY_STEPS 40\n#define RAY_STEPS_SHADOW 20\n\n#define CAUSTICS_INTENSITY 0.5\n#define LIGHT_COLOR vec3(1.0)\n#define GEOMETRY_COLOR_ABOVE vec3(0.2)\n#define GEOMETRY_COLOR_BELOW vec3(0.7, 0.7, 0.7)\n#define LIQUID_COLOR vec3(0.3, 0.45, 0.375)\n#define VOLUMETRIC_MAX_DIST 0.35\n\n#define ID_NONE 0\n#define ID_POOL 1\n#define ID_GEOMETRY 2\n\n// ================\n// General helpers\n// ================\n\nfloat getHeight(vec2 uv) {\n    return texture(iChannel0, vcubeFromFragCoord(1, uv*1024.0)).g;\n}\n\nvec3 getNormal(vec2 uv) {\n    return 2.0 * (texture(iChannel0, vcubeFromFragCoord(2, uv*1024.0)).xyz - 0.5);\n}\n\nfloat getCaustic(vec2 uv) {\n    return texture(iChannel0, vcubeFromFragCoord(5, uv*1024.0)).x;\n}\n\nvoid getParallaxMaxOffsets(\n    in vec3 tangentS,\n    in vec3 tangentT,\n    in vec3 nvNormal,\n    in vec3 camToFrag,\n    in float depthMax,\n    out vec2 maxTexOffset,\n    out vec3 maxPosOffset\n){\n    // Scale camToFrag so that its depth into the surface == depthMax\n    float camDist = -dot(camToFrag, nvNormal);\n    maxPosOffset = (depthMax / camDist) * camToFrag;\n\n    // maxPosOffset = a*tangentS + b*tangentT + N <=> maxTexOffset = [a,b]\n    float dss = dot(tangentS, tangentS);\n    float dst = dot(tangentS, tangentT);\n    float dtt = dot(tangentT, tangentT);\n    float dcs = dot(maxPosOffset, tangentS);\n    float dct = dot(maxPosOffset, tangentT);\n    float invDet = 1.0 / (dss * dtt - dst * dst);\n    maxTexOffset = invDet * vec2(dtt*dcs - dst*dct, -dst*dcs + dss*dct);\n}\n\nfloat getParallaxDepthFactor(vec2 uvInitial, vec2 maxTexOffset, int steps) {\n    vec2 uvMax = uvInitial + maxTexOffset;\n    float dt = 1.0 / float(steps);\n\n    float tOld = 0.0, depthOld = 0.0;\n    float tCur = 0.0, depthCur = 0.0;\n\n    for(int i=0; i<=steps; ++i){\n        tOld = tCur;\n        tCur = float(i)*dt;\n\n        depthOld = depthCur;\n        depthCur = 1.0 - getHeight(mix(uvInitial, uvMax, tCur));\n\n        if(tCur > depthCur){\n            tCur = mix(tOld, tCur, unmix(depthOld-tOld, depthCur-tCur, 0.0));\n            break;\n        }\n    }\n\n    return tCur;\n}\n\n// ===========================\n// Scene geometry and shadows\n// ===========================\n\nvoid sdGeometry(in vec3 p, out float sd) {\n    float sdA = sdBox( vec3(0.0, -2.0*POOL_DEPTH_WORLD, 0.0), vec3(1.0, 2.0*POOL_DEPTH_WORLD + 0.01, 1.0), p );\n    float sdB1 = sdBox( vec3(0.0), vec3(0.8,     POOL_DEPTH_WORLD, 0.8), p );\n    float sdB2 = sdBox( vec3(0.0), vec3(0.3, 2.0*POOL_DEPTH_WORLD, 0.3), p );\n    sd = max(-min(sdB1, sdB2),sdA);\n}\n\nvec3 nvGeometryNormal(in vec3 p) {\n    float sdXA, sdXB, sdYA, sdYB, sdZA, sdZB;\n\n    const float eps = 1e-2;\n    sdGeometry(p - vec3(eps, 0.0, 0.0), sdXA);\n    sdGeometry(p + vec3(eps, 0.0, 0.0), sdXB);\n    sdGeometry(p - vec3(0.0, eps, 0.0), sdYA);\n    sdGeometry(p + vec3(0.0, eps, 0.0), sdYB);\n    sdGeometry(p - vec3(0.0, 0.0, eps), sdZA);\n    sdGeometry(p + vec3(0.0, 0.0, eps), sdZB);\n\n    return normalize(vec3(sdXB-sdXA, sdYB-sdYA, sdZB-sdZA));\n}\n\nvoid hitPool(in vec3 p, in vec3 nv, out int idHit, out vec3 pHit, out vec2 uvHit) {\n    float poolSurfaceY = mix(POOL_SURFACE_WORLD_MIN.y, POOL_SURFACE_WORLD_MAX.y, 0.5);\n\n    float t = (poolSurfaceY - p.y) / nv.y;\n    if (t < MIN_DIST) {\n        idHit = ID_NONE;\n        return;\n    }\n\n    pHit = p + t*nv;\n    uvHit = vec2(\n        unmix(POOL_SURFACE_WORLD_MIN.x, POOL_SURFACE_WORLD_MAX.x, pHit.x),\n        unmix(POOL_SURFACE_WORLD_MAX.z, POOL_SURFACE_WORLD_MIN.z, pHit.z)\n    );\n\n    float didHit = isInInterval(0.0, 1.0, uvHit.s) * isInInterval(0.0, 1.0, uvHit.t);\n    idHit = didHit < 0.5 ? ID_NONE : ID_POOL;\n}\n\nvoid hitScene(in vec3 p, in vec3 nv, out int idHit, out vec3 pHit) {\n    float travel = 0.0;\n    vec3 curPos = p;\n\n    for (int k = 0; k < RAY_STEPS; k++) {\n        float sdStep;\n        sdGeometry(curPos, sdStep);\n\n        if (abs(sdStep) < MIN_DIST) {\n            idHit = ID_GEOMETRY;\n            pHit = curPos;\n            return;\n        }\n\n        curPos += sdStep * nv;\n        travel += sdStep;\n        if (travel > MAX_DIST) {\n            break;\n        }\n    }\n\n    idHit = ID_NONE;\n    pHit = curPos;\n}\n\nfloat getShadowCoeff(in vec3 p, in vec3 nv) {\n    float tHit = 0.0;\n    vec3 curPos = p;\n    float shadowCoeff = 0.0;\n\n    for (int k = 0; k < RAY_STEPS_SHADOW; k++) {\n        float sdStep;\n        sdGeometry(curPos, sdStep);\n\n        float curLightPercent = abs(sdStep)/(0.1*tHit);\n        shadowCoeff = max(shadowCoeff, 1.0-curLightPercent);\n\n        if (abs(sdStep) < MIN_DIST) {\n            shadowCoeff = 1.0;\n            break;\n        }\n\n        curPos += sdStep * nv;\n        tHit += sdStep;\n        if (tHit > MAX_DIST) {\n            break;\n        }\n    }\n\n    return clamp(shadowCoeff, 0.0, 1.0);\n}\n\n// =========\n// Textures\n// =========\n\nvec3 skybox(in vec3 nv) {\n    return mix(0.5+0.5*normalize(nv), vec3(0.8, 0.7, 1.0), 0.7);\n}\n\nvoid texPool(\n    in vec3 camPos, in vec3 lightPos, in vec3 p,\n    out vec3 pBump, out float didHit,\n    out vec3 c, out vec3 nvRefl, out float coeffRefl, out vec3 nvRefract, out float coeffRefract\n) {\n    vec2 uv = vec2(\n        unmix(POOL_SURFACE_WORLD_MIN.x, POOL_SURFACE_WORLD_MAX.x, p.x),\n        unmix(POOL_SURFACE_WORLD_MAX.z, POOL_SURFACE_WORLD_MIN.z, p.z)\n    );\n\n    vec3 tangentS = vec3(POOL_SURFACE_WORLD_MAX.x-POOL_SURFACE_WORLD_MIN.x, 0.0, 0.0);\n    vec3 tangentT = vec3(0.0, 0.0, POOL_SURFACE_WORLD_MIN.z-POOL_SURFACE_WORLD_MAX.z);\n\n    // Parallax occlusion mapping: hit surface\n    vec2 maxTexOffset;\n    vec3 maxPosOffset;\n    getParallaxMaxOffsets(\n        tangentS,\n        tangentT,\n        vec3(0.0, 1.0, 0.0),\n        p - camPos,\n        POOL_BUMP_HEIGHT_WORLD,\n        maxTexOffset,\n        maxPosOffset\n    );\n\n    float depthPct = getParallaxDepthFactor(uv, maxTexOffset, 16);\n\n    vec2 uvBump = uv + depthPct*maxTexOffset;\n    vec3 posBump = p + depthPct*maxPosOffset;\n    vec3 nvBumpNormal = getNormal(uvBump);\n\n    // Output where (and if) the bumped surface got hit\n    pBump = posBump;\n    didHit = isInInterval(0.0, 1.0, uvBump.s) * isInInterval(0.0, 1.0, uvBump.t);\n\n    // Material for surface\n    vec3 nvBumpPosToCam = normalize(camPos - posBump);\n    vec3 nvBumpPosToLight = normalize(lightPos - posBump);\n\n    vec3 matSurface = vec3(1.0);\n    vec3 diffuse;\n    vec3 specular;\n    materialShader(\n        0.25, 0.75, 80.0,\n        LIGHT_COLOR, matSurface, nvBumpNormal,\n        nvBumpPosToLight,\n        nvBumpPosToCam,\n        diffuse,\n        specular\n    );\n    float shadowCoeff = getShadowCoeff(posBump + 0.005*nvBumpNormal, nvBumpPosToLight);\n    diffuse *= (1.0 - shadowCoeff);\n    specular *= (1.0 - shadowCoeff);\n\n    // Reflection data (Schlick approximation)\n    nvRefl = normalize(reflect(posBump-camPos, nvBumpNormal));\n\n    float r0 = pow((IR_LIQUID-IR_AIR)/(IR_LIQUID+IR_AIR), 2.0);\n    float cosHitAngle = dot(nvBumpNormal, nvBumpPosToCam);\n    coeffRefl = mix(r0, 1.0, pow(clamp(1.0 - cosHitAngle, 0.0, 1.0), 5.0));\n\n    // Refraction data\n    nvRefract = refract(-nvBumpPosToCam, nvBumpNormal, IR_AIR/IR_LIQUID);\n    coeffRefract = 0.9*(1.0 - coeffRefl);\n\n    // Base color to be blended with reflection/refraction\n    c = specular + (1.0 - (coeffRefl+coeffRefract))*diffuse;\n}\n\nvoid texGeometryBase(\n    in vec3 camPos, in vec3 lightPos, in vec3 matColor, in vec3 p,\n    out vec3 color, out float shadowCoeff\n) {\n    vec3 nvNormal = nvGeometryNormal(p);\n\n    vec3 nvPosToCam = normalize(camPos - p);\n    vec3 nvPosToLight = normalize(lightPos - p);\n\n    vec3 diffuse;\n    vec3 specular;\n    materialShader(\n        0.6, 0.9, 25.0,\n        LIGHT_COLOR, matColor, nvNormal,\n        nvPosToLight,\n        nvPosToCam,\n        diffuse,\n        specular\n    );\n    color = diffuse + specular;\n    shadowCoeff = getShadowCoeff(p + 0.005*nvNormal, nvPosToLight);\n}\n\nvec3 texGeometry(vec3 camPos, vec3 lightPos, vec3 p) {\n    vec3 c;\n    float shadowCoeff;\n    texGeometryBase(camPos, lightPos, GEOMETRY_COLOR_ABOVE, p, c, shadowCoeff);\n\n    return mix(c, vec3(0.0), shadowCoeff);\n}\n\nvec3 texGeometryUnderwater(vec3 camPos, vec3 lightPos, vec3 p) {\n    vec3 c;\n    float shadowCoeff;\n    texGeometryBase(camPos, lightPos, GEOMETRY_COLOR_BELOW, p, c, shadowCoeff);\n\n    // The caustics map assumes that p is POOL_DEPTH_WORLD below poolSurfaceY.\n    // In general, we need to shift it based on depth.\n    // --------------------------------------------------\n    float poolSurfaceY = mix(POOL_SURFACE_WORLD_MIN.y, POOL_SURFACE_WORLD_MAX.y, 0.5);\n\n    vec3 posToLight = lightPos - p;\n    float targetY = poolSurfaceY - POOL_DEPTH_WORLD;\n    vec3 pCorrected = p + ((targetY - p.y) / posToLight.y)*posToLight;\n\n    vec2 uvCaustic = vec2(\n        unmix(POOL_SURFACE_WORLD_MIN.x, POOL_SURFACE_WORLD_MAX.x, pCorrected.x),\n        unmix(POOL_SURFACE_WORLD_MAX.z, POOL_SURFACE_WORLD_MIN.z, pCorrected.z)\n    );\n    // --------------------------------------------------\n\n    float caustic = getCaustic(uvCaustic);\n    float causticShadow = CAUSTICS_INTENSITY*clamp(unmix(0.5, 0.0, caustic), 0.0, 1.0);\n    float causticHighlight = CAUSTICS_INTENSITY*clamp(unmix(0.5, 1.0, caustic), 0.0, 1.0);\n\n    c = mix(c, LIGHT_COLOR, causticHighlight);\n    c = mix(c, vec3(0.0), clamp(causticShadow + shadowCoeff, 0.0, 1.0));\n    return c;\n}\n\n// ====================================================\n// Final image\n// ====================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 camPos;\n    vec3 nvCamDir;\n    sceneCamera(iResolution, fragCoord, iTime, camPos, nvCamDir);\n    vec3 lightPos = sceneLight(iTime);\n\n    // Hit scene with signed distance field; hit pool exactly\n    // ----------------------------------------------------------\n    int idHitScene;\n    vec3 pHitScene;\n    hitScene(camPos, nvCamDir, idHitScene, pHitScene);\n\n    int idHitPool;\n    vec3 pHitPool;\n    vec2 uvHitPool;\n    hitPool(camPos, nvCamDir, idHitPool, pHitPool, uvHitPool);\n\n    // Combine the hit data for scene and flat pool surface\n    int idHit = idHitScene;\n    vec3 p = pHitScene;\n    if (idHitPool != ID_NONE && (idHit == ID_NONE || distsq(pHitPool, camPos) < distsq(p, camPos))) {\n        idHit = ID_POOL;\n        p = pHitPool;\n    }\n    // ----------------------------------------------------------\n\n    vec3 c = vec3(0.0);\n    if (idHit == ID_NONE) {\n        c = skybox(nvCamDir);\n    } else if (idHit == ID_GEOMETRY) {\n        c = texGeometry(camPos, lightPos, p);\n    } else if (idHit == ID_POOL) {\n        vec3 pBump;\n        float didHit;\n\n        vec3 cConst;\n\n        vec3 nvRefl;\n        float coeffRefl;\n\n        vec3 nvRefract;\n        float coeffRefract;\n\n        texPool(\n            camPos, lightPos, p,\n            pBump, didHit,\n            cConst, nvRefl, coeffRefl, nvRefract, coeffRefract\n        );\n\n        // Total miss (e.g. ray hitting surface near edge, with water low)\n        if (didHit < 0.5) {\n\n            if (idHitScene == ID_GEOMETRY) {\n                c = texGeometry(camPos, lightPos, pHitScene);\n            }\n\n        // Did actually hit the surface; blend refraction and reflection colors\n        } else {\n            // Refraction (just do geometry)\n            int idHit1;\n            vec3 p1;\n            hitScene(pBump, nvRefract, idHit1, p1);\n            vec3 cRefract = vec3(0.0);\n            if (idHit1 == ID_GEOMETRY) {\n                float volumetricAmount = clamp(unmix(0.0, VOLUMETRIC_MAX_DIST, distance(pBump, p1)), 0.0, 1.0);\n                cRefract = mix(\n                    texGeometryUnderwater(camPos, lightPos, p1),\n                    LIQUID_COLOR*LIGHT_COLOR,\n                    volumetricAmount\n                );\n            }\n\n            // Reflection (just do skybox)\n            vec3 cRefl = skybox(nvRefl);\n            c = clamp(cConst + coeffRefract*cRefract + coeffRefl*cRefl, 0.0, 1.0);\n        }\n    }\n\n    // Mouse input\n    //---------------------------------------\n    if (fragCoord.x < 1.0 && fragCoord.y < 1.0) {\n        vec2 packMouse = packUVWithBool(vec2(0.5), false);\n        if (iMouse.z > 0.0) {\n            vec3 camPosMouse;\n            vec3 nvCamDirMouse;\n            sceneCamera(iResolution, iMouse.xy, iTime, camPosMouse, nvCamDirMouse);\n\n            hitPool(camPosMouse, nvCamDirMouse, idHitPool, pHitPool, uvHitPool);\n            packMouse = packUVWithBool(clamp(uvHitPool, 0.0, 1.0), true);\n\n        }\n        c.rg = packMouse;\n    }\n    //---------------------------------------\n\n    vec3 focusPoint = POOL_SURFACE_CENTER;\n    float distFromFocus = distance(camPos, focusPoint);\n    float distFromFrag = distance(camPos, p);\n    float blurAmount = clamp(1.0*abs(distFromFocus-distFromFrag), 0.0, 1.0);\n\n    fragColor = vec4(c, blurAmount);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}