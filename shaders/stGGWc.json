{
    "Shader": {
        "info": {
            "date": "1638508653",
            "description": "Raymarching a triquadratic volume using segment tracing, gradient intervals and polynomial arithmetic. Takes a while to compile.",
            "flags": 0,
            "hasliked": 0,
            "id": "stGGWc",
            "likes": 17,
            "name": "Triquadratic Raymarching",
            "published": 3,
            "tags": [
                "marching",
                "triquadratic",
                "hextic"
            ],
            "usePreview": 0,
            "username": "paniq",
            "viewed": 656
        },
        "renderpass": [
            {
                "code": "\n// display iteration heatmap\n//#define SHOW_ITERATION_COST\n\n// evaluate tangent intervals from polynomial rather than interpolant\n#define FOLD_COEFFICIENTS\n// normalize t to 0..1\n#define NORMALIZE_RAY_RANGE\n// normalize t to -1..1\n#define CENTERED_RAY_RANGE\n// when FOLD_COEFFICIENTS is defined, use horner method to evaluate polynomial\n// not as much required when ray range is normalized and centered\n#define USE_HORNER_METHOD\n// undefine to only render frontface\n#define RENDER_BACKFACE\n\n// voxel coordinate in texture\n//const ivec3 patch_coord = ivec3(11);\nconst ivec3 patch_coord = ivec3(7,5,5);\n//const ivec3 patch_coord = ivec3(22,8,16);\n\nconst int max_iterations = 15;\nconst float sigma = 1e-4;\n\n#ifdef NORMALIZE_RAY_RANGE\n#ifdef CENTERED_RAY_RANGE\nconst float start_width = 1.0;\n#else\nconst float start_width = 0.5;\n#endif\n#else\n//const float start_width = 0.15;\nconst float start_width = 0.5;\n#endif\n\n//const float grow_rate = 1.4;\n//const float grow_rate = 1.618;\nconst float grow_rate = 2.0;\n\n//////////////////////////////////////////////////////////\n\n// https://en.wikipedia.org/wiki/Polynomial_arithmetic\n\nstruct poly1 { float c[2]; };\nstruct poly2 { float c[3]; };\nstruct poly3 { float c[4]; };\nstruct poly4 { float c[5]; };\nstruct poly5 { float c[6]; };\nstruct poly6 { float c[7]; };\n\nstruct poly1x3 { poly1 x; poly1 y; poly1 z; };\n\n#define DEFINE_PA_HORNER(T,N) \\\n    T pa_horner(T a, float x0) { \\\n        T c; \\\n        c.c[N] = a.c[N]; \\\n        for (int i = N-1; i >= 0; --i) { \\\n            c.c[i] = a.c[i] + c.c[i+1] * x0; \\\n        } \\\n        return c; \\\n    }\n\n#define DEFINE_PA_EVAL(T,N) \\\n    float pa_eval(T a, float x) { \\\n        float b = a.c[N]; \\\n        for (int i = N-1; i >= 0; --i) { \\\n            b = b*x + a.c[i]; \\\n        } \\\n        return b; \\\n    }\n\n#define DEFINE_PA_MIX(TINAB,TOUT,NOUT) \\\n    TOUT pa_mix(TINAB a, TINAB b, poly1 x) { \\\n        float x0 = x.c[0]; float x1 = x.c[1]; float ix0 = 1. - x0; \\\n        TOUT c; \\\n        for (int i = 0; i < NOUT; ++i) { \\\n            c.c[i] = a.c[i]*ix0 + b.c[i]*x0; \\\n        } \\\n        c.c[NOUT] = 0.; \\\n        for (int i = 0; i < NOUT; ++i) { \\\n            c.c[i+1] += (b.c[i] - a.c[i])*x1; \\\n        } \\\n        return c; \\\n    }\n\npoly1 poly(float c0, float c1) {\n    return poly1(float[](c0, c1));\n}\n\npoly1x3 poly(vec3 c0, vec3 c1) {\n    return poly1x3(poly(c0.x,c1.x),poly(c0.y,c1.y),poly(c0.z,c1.z));\n}\n\npoly1 pa_add(poly1 a, float b) {\n    return poly(a.c[0] + b, a.c[1]);\n}\n\npoly1 pa_mul(poly1 a, float b) {\n    return poly(a.c[0] * b, a.c[1] * b);\n}\n\npoly1x3 pa_add(poly1x3 a, float b) {\n    return poly1x3(pa_add(a.x, b),pa_add(a.y, b),pa_add(a.z, b));\n}\npoly1x3 pa_mul(poly1x3 a, float b) {\n    return poly1x3(pa_mul(a.x, b),pa_mul(a.y, b),pa_mul(a.z, b));\n}\n\npoly1 pa_mix(float a, float b, poly1 x) {\n    float x0 = x.c[0]; float x1 = x.c[1]; float ix0 = 1. - x0;\n    return poly(a*ix0 + b*x0, (b - a)*x1);\n}\n\nDEFINE_PA_MIX(poly1,poly2,2)\nDEFINE_PA_MIX(poly2,poly3,3)\nDEFINE_PA_MIX(poly3,poly4,4)\nDEFINE_PA_MIX(poly4,poly5,5)\nDEFINE_PA_MIX(poly5,poly6,6)\n\nDEFINE_PA_HORNER(poly6,6)\nDEFINE_PA_EVAL(poly6,6)\n\n//////////////////////////////////////////////////////////\n\n// GIA scalar for rays (1D)\nstruct gia1 {\n    // coefficients of f(x) = f0 + s*(f1 - f0)\n    // where s=[0..1]\n    float f0;\n    vec2 f1;\n};\n    \nstruct gia1x2 {\n    gia1 x;\n    gia1 y;\n};\n\nstruct gia1x3 {\n    gia1 x;\n    gia1 y;\n    gia1 z;\n};\n\n//////////////////////////////////////////////////////////\n\ngia1 gia_const(float x) {\n    return gia1(x, vec2(x));\n}\n\ngia1x3 gia_const(vec3 v) {\n    return gia1x3(gia_const(v.x), gia_const(v.y), gia_const(v.z));\n}\n\ngia1 gia_neg(gia1 x) {\n    return gia1(-x.f0, -x.f1.yx);\n}\n\nvec2 ia_sort(vec2 ia) {\n    return (ia.x > ia.y)?ia.yx:ia;\n}\n\nvec2 ia_merge(vec2 a, vec2 b) {\n    return vec2(min(a.x, b.x), max(a.y, b.y));\n}\n\ngia1 gia_add(gia1 a, gia1 b) {\n    return gia1(a.f0 + b.f0, a.f1 + b.f1);\n}\n\ngia1 gia_add(gia1 a, float b) {\n    return gia1(a.f0 + b, a.f1 + b);\n}\n\ngia1x3 gia_add(gia1x3 a, vec3 b) {\n    return gia1x3(gia_add(a.x, b.x), gia_add(a.y, b.y), gia_add(a.z, b.z));\n}\n\ngia1 gia_mul(gia1 a, gia1 b) {    \n\tfloat f0 = a.f0 * b.f0;\n    vec2 f1 = ia_merge(ia_sort(a.f1.x * b.f1), ia_sort(a.f1.y * b.f1));\n    vec2 ff0 = ia_sort(b.f0*a.f1) + ia_sort(a.f0*b.f1) - f0;\n    return gia1(f0, ia_merge(ff0, f1));\n}\n\ngia1 gia_mul(gia1 a, float b) {    \n    vec2 q = a.f1.xy * b;\n    return gia1(a.f0 * b, (b < 0.0)?q.yx:q);\n}\n\ngia1x3 gia_mul(gia1 a, vec3 b) {\n    return gia1x3(gia_mul(a, b.x), gia_mul(a, b.y), gia_mul(a, b.z));\n}\n\ngia1x3 gia_mul(gia1x3 a, vec3 b) {\n    return gia1x3(gia_mul(a.x, b.x), gia_mul(a.y, b.y), gia_mul(a.z, b.z));\n}\n\ngia1 gia_mix(float a, float b, gia1 x) {\n#if 1\n    return gia_add(gia_mul(x, b-a),a);\n#else\n    return gia_add(gia_mul(gia_add(gia_neg(x),1.0), a), gia_mul(x, b));\n#endif\n}\ngia1 gia_mix(gia1 a, gia1 b, gia1 x) {\n    return gia_add(gia_mul(gia_add(gia_neg(x),1.0), a), gia_mul(x, b));\n}\n\ngia1 pa_eval(poly6 a, gia1 x) {\n#ifdef USE_HORNER_METHOD\n    float x0 = x.f0;\n    a = pa_horner(a, x0);\n    gia1 y = gia_const(a.c[6]);\n    for (int i = 5; i >= 1; --i) {\n        y = gia_add(gia_mul(x,y), a.c[i]);\n    }\n    y = gia_add(gia_mul(y, gia_add(x, -x0)), a.c[0]);\n    return y;\n#else\n    gia1 y = gia_const(a.c[6]);\n    for (int i = 5; i >= 0; --i) {\n        y = gia_add(gia_mul(x,y), a.c[i]);\n    }\n    return y;\n#endif\n}\n\nfloat interpolate3x3x3(mat3 s[3], vec3 q) {\n    vec3 q0 = (q+1.0)/2.0;\n    vec3 q1 = q/2.0;\t\n\n    vec3 xf;\n    for (int x = 0; x < 3; ++x) {\n        vec3 yf;\n        for (int y = 0; y < 3; ++y) {\n            yf[y] = mix(mix(s[x][y][0], s[x][y][1], q0.z), mix(s[x][y][1], s[x][y][2], q1.z), q.z);\n        }\n        xf[x] = mix(mix(yf[0], yf[1], q0.y), mix(yf[1], yf[2], q1.y), q.y);\n    }    \n    return mix(mix(xf[0], xf[1], q0.x), mix(xf[1], xf[2], q1.x), q.x);    \n}\n\npoly6 interpolate3x3x3(mat3 s[3], poly1x3 q) {\n    poly1x3 q1 = pa_mul(q,1.0/2.0);\n    poly1x3 q0 = pa_add(q1,1.0/2.0);\n\n    poly4 xf[3];\n    for (int x = 0; x < 3; ++x) {\n        poly2 yf[3];\n        for (int y = 0; y < 3; ++y) {\n            yf[y] = pa_mix(pa_mix(s[x][y][0], s[x][y][1], q0.z), pa_mix(s[x][y][1], s[x][y][2], q1.z), q.z);\n        }\n        xf[x] = pa_mix(pa_mix(yf[0], yf[1], q0.y), pa_mix(yf[1], yf[2], q1.y), q.y);\n    }    \n    return pa_mix(pa_mix(xf[0], xf[1], q0.x), pa_mix(xf[1], xf[2], q1.x), q.x);    \n}\n\nvec3 interpolate3x3x3_normal(mat3 s[3], vec3 q) {\n    vec2 e = vec2(1e-3, 0.0);\n    return -normalize(vec3(\n        interpolate3x3x3(s, q + e.xyy) - interpolate3x3x3(s, q - e.xyy),\n        interpolate3x3x3(s, q + e.yxy) - interpolate3x3x3(s, q - e.yxy),\n        interpolate3x3x3(s, q + e.yyx) - interpolate3x3x3(s, q - e.yyx)));\n}\n\ngia1 gia_interpolate3x3x3(mat3 s[3], gia1x3 q) {\n    gia1x3 q0 = gia_mul(gia_add(q,vec3(1.0)),vec3(1.0/2.0));\n    gia1x3 q1 = gia_mul(q, vec3(1.0/2.0));\n\n    gia1 xf[3];\n    for (int x = 0; x < 3; ++x) {\n        gia1 yf[3];\n        for (int y = 0; y < 3; ++y) {\n            yf[y] = gia_mix(gia_mix(s[x][y][0], s[x][y][1], q0.z), gia_mix(s[x][y][1], s[x][y][2], q1.z), q.z);\n        }\n        xf[x] = gia_mix(gia_mix(yf[0], yf[1], q0.y), gia_mix(yf[1], yf[2], q1.y), q.y);\n    }    \n    return gia_mix(gia_mix(xf[0], xf[1], q0.x), gia_mix(xf[1], xf[2], q1.x), q.x);    \n}\n\nvoid fetch3x3x3(sampler3D channel, ivec3 t, out mat3 s[3]) {\n    ivec3 ires = textureSize(channel, 0);\n    ivec3 e = ivec3(-1, 0, 1);\n\n    ivec3 tx = (t.xxx + e + ires) % ires;\n    ivec3 ty = (t.yyy + e) % ires;\n    ivec3 tz = (t.zzz + e) % ires;\n\n    for (int x = 0; x < 3; ++x) {\n        for (int y = 0; y < 3; ++y) {\n            for (int z = 0; z < 3; ++z) {\n                s[x][y][z] = texelFetch(channel, ivec3(tx[x],ty[y],tz[z]), 0).x;\n            }\n        }\n    }\n}\n\nvec3 orient(vec3 d) {\n    d.yz = rotate(d.yz, radians(20.0));\n    d.xz = rotate(d.xz, radians(iTime*20.0));\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 ro = orient(vec3(0,0,-2.0));\n    vec3 rd = orient(normalize(vec3(uv, 2.0)));\n    \n    mat3 field[3];\n    fetch3x3x3(iChannel0, patch_coord, field);\n    \n    vec3 L = normalize(vec3(-1.0,1.0,-1.0));\n\n    vec3 col = pow(plasma(0.0),vec3(2.2));\n    vec2 range;\n    if (icube(ro, rd, range)) {\n        float t = max(range.x, 0.);\n        vec3 ro0 = ro;\n        #ifdef NORMALIZE_RAY_RANGE\n        ro = ro + rd*t;\n        t = (t - range.x) / (range.y - range.x);\n        rd = rd * (range.y - range.x);\n        #ifdef CENTERED_RAY_RANGE\n        t = t*2.0 - 1.0;\n        ro = ro + rd*0.5;\n        rd = rd*0.5;\n        range = vec2(-1.0, 1.0);\n        #else\n        range = vec2(0.0, 1.0);\n        #endif\n        #else\n        #endif\n        ro += 0.5;\n        #ifdef FOLD_COEFFICIENTS\n        poly6 poly_field = interpolate3x3x3(field, poly(ro, rd)); \n        #endif        \n        #ifdef FOLD_COEFFICIENTS\n        float w = pa_eval(poly_field, t);\n        #else\n        float w = interpolate3x3x3(field, ro + rd*t);\n        #endif\n        #ifndef RENDER_BACKFACE\n        if ((t == range.x) && (w < 0.5)) {\n            col = vec3(0.0);\n        } else\n        #endif\n        {\n            float h = start_width;\n            int steps = 0;\n            for (int i = 0; i < max_iterations; ++i) {\n                steps += 1;\n                #ifdef FOLD_COEFFICIENTS\n                gia1 w = pa_eval(poly_field, gia1(t, vec2(t + h)));\n                #else\n                gia1x3 p = gia_add(gia_mul(gia1(t, vec2(t + h)),rd),ro);\n                gia1 w = gia_interpolate3x3x3(field, p);\n                #endif\n                w = gia_add(w,-0.5);\n                if (abs(w.f0) < sigma) {\n                    vec3 p_t = (ro + rd*t);\n                    vec3 n = interpolate3x3x3_normal(field, p_t);\n                    bool backfacing = dot(rd, n) < 0.0;\n                    if (backfacing) {\n                        n = -n;\n                    }\n                    float a = max(0.0, dot(n, -L)*0.5+0.5);\n                    vec3 albedo = (p_t*0.5+0.5);\n                    #ifndef RENDER_BACKFACE\n                    if (backfacing) {\n                        albedo = vec3(0.0);\n                    }\n                    #endif\n                    col = albedo * (col * 0.5 + a);\n                    float d = max(0.0, dot(ro0,reflect(-L,n))-0.95);\n                    col += albedo*pow(d, 20.0);\n                    break;\n                }\n                float st = ((w.f0 > 0.0)?w.f1[0]:w.f1[1]) - w.f0;\n                float z = -h*w.f0 / st; // extrapolate possible root\n                float rd = (z < 0.0)?h:z;\n                float s = min(h, rd);\n                t += s;\n                if (t >= range.y) {\n                    // no root in interval\n                    break;     \n                }\n                h = grow_rate*s;\n            }            \n            #ifdef SHOW_ITERATION_COST\n            col = plasma(clamp(float(steps) / float(max_iterations),0.0,1.0));\n            #endif\n        }\n    }\n    #ifndef SHOW_ITERATION_COST\n    col *= 2.0;\n    col = ACESFitted(col);\n    // Output to screen\n    fragColor = vec4(pow(col,vec3(1.0/2.2)),1.0);\n    #else\n    fragColor = vec4(col,1.0);\n    #endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nbool icube(vec3 ro, vec3 rd, out vec2 range) {\n    vec3 stp = sign(rd) * 0.5;\n    vec3 p = -ro;\n    vec3 h0 = (p - stp) / rd;\n    vec3 h1 = (p + stp) / rd; \n    float near = max(h0.x,max(h0.y,h0.z));\n    float far = min(h1.x,min(h1.y,h1.z));\n    range = vec2(near, far);\n    return (near <= far) && (far >= 0.0);\n}\nvec2 rotate(vec2 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,s,-s,c) * p;\n}\n\n// from https://www.shadertoy.com/view/WlfXRN\nvec3 plasma(float t) {\n\n    const vec3 c0 = vec3(0.05873234392399702, 0.02333670892565664, 0.5433401826748754);\n    const vec3 c1 = vec3(2.176514634195958, 0.2383834171260182, 0.7539604599784036);\n    const vec3 c2 = vec3(-2.689460476458034, -7.455851135738909, 3.110799939717086);\n    const vec3 c3 = vec3(6.130348345893603, 42.3461881477227, -28.51885465332158);\n    const vec3 c4 = vec3(-11.10743619062271, -82.66631109428045, 60.13984767418263);\n    const vec3 c5 = vec3(10.02306557647065, 71.41361770095349, -54.07218655560067);\n    const vec3 c6 = vec3(-3.658713842777788, -22.93153465461149, 18.19190778539828);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n\n}\n\n\n// presentation related functions\n\n///////////////////////////////////////////////\n\n// ACES fitted\n// from https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\n\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v)\n{\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvec3 ACESFitted(vec3 color)\n{\n    color = color * ACESInputMat;\n\n    // Apply RRT and ODT\n    color = RRTAndODTFit(color);\n\n    color = color * ACESOutputMat;\n\n    // Clamp to [0, 1]\n    color = clamp(color, 0.0, 1.0);\n\n    return color;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}