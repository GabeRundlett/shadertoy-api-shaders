{
    "Shader": {
        "info": {
            "date": "1533814769",
            "description": "Fast Z-order or Morton code merge sort of particles. Merge sort is fast with binary search so log2 number of passes. Particle buffer is partitioned over last log2 physics iterations for pipelined sort.",
            "flags": 32,
            "hasliked": 0,
            "id": "Mtdyzs",
            "likes": 17,
            "name": "Z Particle Sort Pipeline",
            "published": 3,
            "tags": [
                "particles",
                "sort",
                "physics",
                "merge",
                "quadtree",
                "morton",
                "zorder",
                "bitonic"
            ],
            "usePreview": 0,
            "username": "emh",
            "viewed": 1270
        },
        "renderpass": [
            {
                "code": "#define condFetch(x) texelFetch(iChannel2, ivec2(x), 0)\n\nfloat textColor(vec3 bgColor) {\n  float r = bgColor.r * 255.0,\n        g = bgColor.g * 255.0,\n        b = bgColor.b * 255.0;\n  float yiq = (r * 299.0 + g * 587.0 + b * 114.0) / 1000.0;\n  return (yiq >= 128.0) ? 0.0 : 1.0;\n}\n\nvec2 vmin(vec2 v1, vec2 v2) {\n    return length(v1) < length(v2) ? v1 : v2;\n}\n\nstruct mRet {\n    int dIndex;\n    int Am;\n    vec4 v;\n    vec2 pos;\n};\n\nmRet getMD(int part, int m, vec2 res, vec2 pres) {\n    vec2 fc = vec2(fromLinear(m, res));\n    vec4 v = texelFetch(iChannel3, ivec2(fc), 0);\n    vec2 pos = part == 0 ? v.xy : v.zw;\n    int Am = toIndex(iChannel0, pos * pres, pres);\n    return mRet(m, Am, v, pos);\n}\n\nmRet getM(int part, int m, vec2 res, vec2 pres) {\n    vec2 fc = vec2(fromLinear(m, res));\n    vec4 v = condFetch(fc);\n    //int Am = toIndex(iChannel0, v.xy * pres, pres);\n    mRet ret2 = getMD(part, int(v[part]), res, pres);\n    vec4 v2 = ret2.v;\n    vec2 pos = part == 0 ? v2.xy : v2.zw;\n    int Am = toIndex(iChannel0, pos * pres, pres);\n    return mRet(int(v[part]), ret2.Am, v2, pos);\n}\n\n/*\nmRet getM(int m, vec2 res, vec2 pres) {\n    vec2 fc = vec2(fromLinear(m, res));\n    vec4 v = texelFetch(iChannel3, ivec2(fc), 0);\n    int Am = toIndex(iChannel0, v.xy * pres, pres);\n    return mRet(Am, v);\n}*/\n\nvoid indexPlay(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 col = vec3(0.0);\n    vec2 res = getRes(iResolution.xy);\n    vec2 uv = floor(fragCoord / iResolution.xy * res);\n    ivec2 div = maxDiv(res);\n    vec2 colorUV = fragCoord / iResolution.xy;\n    int n = int(res.x * res.y);\n    int m = int(iResolution.x * iResolution.y);\n    \n    vec4 color = vec4(colorUV, 0.5, 1.0);\n    fragColor = color;\n    int index2 = int((fragCoord.x + fragCoord.y * iResolution.x) * float(div.x) / (iResolution.x * iResolution.y));\n    index2 = (index2 + iFrame * 100) % div.x;\n    vec2 rfc = vec2(fromIndex(iChannel0, index2, res));\n    vec2 colorUV2 = rfc / res;\n    vec4 color2 = vec4(colorUV2, 0.5, 1.0);\n    fragColor = color2;\n    //return;\n    \n    //int index = toIndex(fragCoord, iResolution.xy, col);\n    int index = toIndexCol(uv, res, col);\n    //div.x = int(res.x * res.x);\n    int scaledIndex = int(float(index) / float(div.x) * iResolution.x * iResolution.y);\n    int scaledIndex2 = int(float(index + 1) / float(div.x) * iResolution.x * iResolution.y);\n    int revIndex = int(float(scaledIndex) * float(div.x) / (iResolution.x * iResolution.y));\n    vec2 fc = vec2(fromIndex(iChannel0, revIndex, res));\n    vec2 fc2 = vec2(fromIndex(iChannel0, revIndex + 1, res));\n    vec2 fc3 = vec2(fromIndex(iChannel0, revIndex + 2, res));\n    vec2 fc4 = vec2(fromIndex(iChannel0, revIndex + 3, res));\n    \n    vec2 fcy = uv;\n    //fcy.y = res.y - fcy.y;\n    vec2 mfc = vec2(ivec2(fcy) * div.y / ivec2(res));\n    vec2 error1 = abs(fc - mfc);\n    vec2 error2 = abs(fc2 - mfc);\n    vec2 error3 = abs(fc3 - mfc);\n    vec2 error4 = abs(fc4 - mfc);\n    vec2 error = vmin(error1, vmin(error2, vmin(error3, error4)));\n    float r = float(scaledIndex) / (iResolution.x * iResolution.y);\n    fragColor = vec4(r);\n    if (scaledIndex != scaledIndex2) {\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    }\n    //return;\n    \n    vec2 dfc = mod(fragCoord, iResolution.xy / float(div.y));\n    float b1 = print(dfc, float(error.x), 4, 0);\n    float b2 = print(dfc - vec2(50.0, 0.0), float(error.y), 4, 0);\n    fragColor = vec4(b1 + b2);\n    \n    //float b = print(mod(fragCoord, iResolution.xy / float(div.y)) * 1.0, float(index), 4, 0);\n    float b3 = print(fragCoord, float(div.x) / (iResolution.x * iResolution.y), 10, 3);\n    //col = vec3(float(int(col.r) ^ int(b)));\n    //b = float(int(uv.x + uv.y) % 2 ^ int(b));\n    fragColor = vec4(vec3(b3), 1.0);\n    fragColor = vec4(col, 1.0);\n    //fragColor = vec4(error.x, 0.0, error.y, 1.0);\n}\n\nvoid lookup(out vec4 fragColor, in vec2 fragCoord) { \n\tvec2 res2 = iResolution.xy;\n    int k = 5;\n    float mul = 4.0;\n    const float MAX = 1.0e10;\n    float rd = 0.0;\n    float mind = MAX;\n    vec2 powerOfTwoRes = getRes(res2);\n    vec2 colorUV = fragCoord / iResolution.xy;\n    vec3 color = vec3(1.0);\n    int minIndex = -1;\n    bool firstHalf = true;\n    mPartitionData pd = getPartitionData(iChannel3, fragCoord, res2);\n    \n    vec4 indexAndVelNearest = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    \n    for (int dx = -k; dx <= k; dx++) {\n        for (int dy = -k; dy <= k; dy++) {\n    //for (int r = 0; r < k; r++) {\n    //    for (int a = 0; a < k; a++) {\n    //        int dx = int(float(r) * cos(M_PI * 2.0 * float(a / k)));\n    //        int dy = int(float(r) * sin(M_PI * 2.0 * float(a / k))); \n            vec2 delta = vec2(dx, dy);\n            vec2 delta2 = vec2(sign(float(dx)) * exp2(abs(float(dx))), sign(float(dy)) * exp2(abs(float(dy))));\n            \n            vec4 indexAndVel = texelFetch(iChannel1, ivec2(fragCoord + mul * delta), 0);\n            //vec2 v = indexAndVel.zw;\n            //int i = int(indexAndVel.x);\n            //int j = int(indexAndVel.y);\n            \n            for (int part = 0; part < 2; part++) {\n                int i = int(indexAndVel[part]);\n                mRet iret = getM(part, i, res2, powerOfTwoRes);\n                vec2 newPos = iret.pos;\n                float d = distance(colorUV, newPos);\n                if (i >= 0 && d < mind) {\n                    minIndex = iret.dIndex;\n                    firstHalf = part == 0;\n                }\n                mind = i < 0 ? mind : min(d, mind);\n                float f = 0.00005  / d;\n                rd = i < 0 ? rd : (d < (float(k) / iResolution.x) ? f + rd : rd);\n                \n                if (i >= 0 && d < (float(k) * mul / iResolution.x) && i != int(indexAndVelNearest[part])) {\n                    //float particleSize = length(fragCoord / iResolution.xy - 0.5) * 5.0;\n                    float h = float(minIndex % pd.particlesPerPartition) / float(pd.particlesPerPartition);\n    \t\t\t\tcolor = hsv2rgb(vec3(h, 1.0, 1.0));\n                    color = mix(vec3(1.0), color, 100.0 * mind);\n                    fragColor += clamp(vec4(color, 1.0) * vec4(0.02 / (mind * 500.0)), 0.0, 1.0);\n                }\n            }\n            \n            /*\n            i = int(texelFetch(iChannel1, ivec2(fragCoord + mul * delta2), 0).x);\n        \td = distance(colorUV, getM(i, res2, powerOfTwoRes).v.xy);\n            mind = i < 0 ? mind : min(d, mind);\n            rd = i < 0 ? rd : d + rd;\n\t\t\t*/\n        }\n    }\n    //fragColor = rd == MAX ? vec4(0.0) : vec4(rd * 1000.0);\n    //fragColor = vec4(rd * 0.05);\n    //mind = mind > 0.01 ? 0.0 : mind;\n    //fragColor = vec4(mind * 500.0);\n    \n    float h = float(minIndex % pd.particlesPerPartition) / float(pd.particlesPerPartition);\n    //color = hsv2rgb(vec3(h, 1.0, 1.0));\n    \n    float size = minIndex >= 0 ? float(minIndex % 10 + 1) : 1.0;\n    \n    // inverse\n    float particleSize = length(fragCoord / iResolution.xy - 0.5) * 5.0;\n    //particleSize = 2.0 / size;\n    //particleSize = particleSize > 1.0 ? 1.0 : particleSize;\n    \n    //fragColor += clamp(vec4(color, 1.0) * vec4(1.0 / (mind * 500.0 * particleSize)), 0.0, 1.0);\n    fragColor += clamp(vec4(color, 1.0) * vec4(1.0 / (mind * 500.0)), 0.0, 1.0);\n    \n    //fragColor *= 1.0 * vec4(rd * 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) { \n    vec3 col = vec3(0.0);\n    vec2 pres = getRes(iResolution.xy);\n    vec2 uv = floor(fragCoord / iResolution.xy * pres);\n    ivec2 div = maxDiv(pres);\n    vec2 colorUV = fragCoord / iResolution.xy;\n    int n = int(pres.x * pres.y);\n    int m = int(iResolution.x * iResolution.y);\n    fragColor += print(fragCoord, float(n), 10, 0);\n    //return;\n    \n    /*\n    vec4 color3 = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    //color3.ba *= 0.0;\n    fragColor = vec4(float(toIndex(color3.xy * res, res)) / float(n)); //vec4(color3.xy / length(color3.xy), 0.0, 1.0);\n    //fragColor = color3 + vec4(0.0, 0.0, float(toIndex(color3.xy * res, res)) / float(n), 0.0);\n    fragColor = color3;\n    //return;\n    //fragColor = vec4(0.0, 0.0, color3.b, 1.0);\n    fragColor = vec4(color3.b, 0.0, 0.0, 1.0);\n    //return;\n    fragColor = \n        color3.a > 0.0\n        \t? \n        \t\tcolor3.b > 0.0\n        \t\t\t? vec4(0.0)\n        \t\t\t: vec4(1.0)\n        \t: vec4(color3.b, color3.b > 0.0 ? vec3(0.0) : vec3(length(color3.rg)));\n \t*/\n    \n    lookup(fragColor, fragCoord);\n    \n    vec2 tv = vec2(0.0);\n    /*\n    vec2 tv = fragCoord.xy / iResolution.x;\n    vec4 value =\n        texture(iChannel0, tv) /\n        \tvec4(\n                toIndexFull(iResolution.xy - 1.0, iResolution.xy),\n                iResolution.x,\n                iResolution.y,\n                1.0);\n    fragColor = vec4(value.x);\n    return;\n    tv = fragCoord.xy / iResolution.x;\n    fragColor = texture(iChannel2, tv);\n    return;\n\t*/\n    \n    //fragColor = texelFetch(iChannel3, ivec2(fragCoord), 0);\n    //return;\n    \n    vec2 res = iResolution.xy;\n    vec2 sz = vec2(0.3);\n    tv = fragCoord.xy / iResolution.x / sz;\n    vec2 tv2 = (fragCoord.xy + vec2(1.0, 0.0)) / iResolution.x / sz;\n    mPartitionData pd = getPartitionData(iChannel3, fragCoord, iResolution.xy);\n    if (tv.y < 1.0 && tv.x < 1.0) {\n        if (tv.x < 0.33) {\n            //vec4 value = texture(iChannel0, tv) / vec4((iResolution.x * iResolution.y), iResolution.x, iResolution.y, 1.0);\n            vec4 value = texture(iChannel0, tv);\n            //fragColor = value;\n            fragColor = vec4(float(int(value.x) % 1000) / 1000.0);\n        } else if (tv.x < 0.66) {\n            vec4 v41 = texture(iChannel2, tv);\n            vec4 v42 = texture(iChannel2, tv2);\n            mRet x = getM(0, int(v41.x), res, pres);\n            mRet y = getM(0, int(v42.x), res, pres);\n            fragColor = vec4(0.0);\n            fragColor = vec4((ivec4(v41) % pd.particlesPerPartition)) / float(pd.particlesPerPartition);\n            fragColor.r = float(x.Am < y.Am);\n        } else {\n            // upd2\n            fragColor = texelFetch(iChannel3, ivec2(tv * iResolution.xy), 0);\n            //fragColor = texture(iChannel3, tv);\n        }\n    } else {\n        if (fragCoord.x < iResolution.x * 1.0 / 3.0) {\n            \n        } else {\n            \n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "precision highp float;\nprecision highp int;\n\nconst int MAX_ITER = 12;\nconst int maxBin = 32;\nconst int vec4Count = 2;\n#define PART part\nconst float M_PI = 3.14159265358979323846264338327950288;\n\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nint getMaxPasses2(vec2 res) {\n    return int(ceil(log2(res.x * res.y)));\n}\n\nstruct mPartitionData {\n    int partitionCount;\n    int maxIndex;\n    int particlesPerPartition;\n    int index;\n    int partitionIndex;\n    int offset;\n    int pastIndex;\n    int futureIndex;\n    ivec2 futureCoord;\n    vec4 futureParticle;\n    bool overflow;\n};\n\nfloat hash( uvec2 x )\n{\n    uvec2 q = 1103515245U * ( (x>>1U) ^ (x.yx   ) );\n    uint  n = 1103515245U * ( (q.x  ) ^ (q.y>>3U) );\n    return float(n) * (1.0/float(0xffffffffU));\n}\n\nint D(vec2 p, float n) {\n    int i=int(p.y), b=int(exp2(floor(30.-p.x-n*3.)));\n    i = ( p.x<0.||p.x>3.? 0:\n    i==5? 972980223: i==4? 690407533: i==3? 704642687: i==2? 696556137:i==1? 972881535: 0 )/b;\n \treturn i-i/2*2;\n}\n\nint Dbg(vec2 p) {\n    int i = int(p.y);\n    return int(p.x >= -1.0 && p.x <= 4.0 && p.y >= -1.0 && p.y <= 7.0);\n}\n\n\nfloat print(vec2 i, float num, int digits, int decimals) {\n    /*\n    i /= 2.0;\n    int o = 0;\n    for (float n = float(digits - 1); n >= -float(decimals); n--) { \n        if ((i.x -= 4.0) < 3.0) {\n            // digit\n            o = D(i, floor(mod(num / pow(10.0, n), 10.0)));\n            break;\n        }\n    }\n    return float(o);\n\t*/\n    return 0.0;\n}\n\nvec2 printBG(vec2 i, float num, int digits, int decimals) {\n    /*\n    i /= 2.0;\n    int o = 0;\n    int bg = 0;\n    for (float n = float(digits - 1); n >= -float(decimals); n--) { \n        // background\n    \tbg += Dbg(i - vec2(4.0, 0.0));\n        if ((i.x -= 4.0) < 3.0) {\n            // digit\n            o = D(i, floor(mod(num / pow(10.0, n), 10.0)));\n            break;\n        }\n    }\n    return vec2(o, bg);\n\t*/\n    return vec2(0.0);\n}\n\nivec2 maxDiv(in vec2 resolution) {\n    ivec2 res = ivec2(resolution);\n    int div = 1;\n    int div2 = 1;\n    for (int i = 0; i < MAX_ITER; i++) {\n        res /= 2;\n        if (res.x == 0 && res.y == 0) break;\n        div *= 4;\n        div2 *= 2;\n    }\n    return ivec2(div, div2);\n}\n\nvec2 getRes(vec2 res) {\n    return vec2(exp2(ceil(log2(max(res.x, res.y)))));\n}\n\nint toIndexCol(in vec2 fragCoord, in vec2 resolution, inout vec3 col) {\n    int xl = int(fragCoord.x);\n    int yl = int(fragCoord.y);\n    ivec2 res = ivec2(resolution);\n    int div2 = 1;\n    /*\n    for (int i = 0; i < MAX_ITER; i++) {\n        res /= 2;\n        div2 *= 2;\n        if (res.x == 0 && res.y == 0) break;\n    }\n    res = ivec2(div2);\n\t*/\n    int index = 0;\n    int div = 1;\n    div2 = 1;\n    bool colorDone = false;\n    for (int i = 0; i < MAX_ITER; i++) {\n        ivec2 rest = res % 2;\n        res /= 2;\n        if (res.x == 0 && res.y == 0) break;\n        div *= 4;\n        div2 *= 2;\n        int x = int(xl >= res.x);\n        int y = int(yl >= res.y);\n        xl -= x * res.x;\n        yl -= y * res.y;\n        //res += x * rest.x;\n        //res += y * rest.y;\n        int thisIndex = y * 2 + x;\n        index = index * 4 + thisIndex;\n        \n        if (!colorDone) {\n            vec2 uv = vec2(xl, yl) / vec2(res);\n            vec2 center = vec2(0.5);\n            float d = distance(uv, center);\n            float r = float(d < 0.25);\n            bool border = d > 0.25 - 0.02 / float(div2) && d < 0.25;\n            if (border) {\n                colorDone = true;\n            } else {\n            \tcol = vec3(float(int(col) ^ int(r)));\n            }\n        }\n    }\n    //return res.x * res.y - index - 1;\n    return index;\n}\n\nint toIndexFull(in vec2 fragCoord, in vec2 resolution) {\n    vec3 col = vec3(0.0);\n    int index = toIndexCol(fragCoord, resolution, col);\n    //index += 1;\n    return index;\n}\n\nivec2 fromIndexFull(in int index, in vec2 resolution) {\n    //index -= 1;\n    ivec2 fc = ivec2(0);\n    int div = 1;\n    ivec2 div2 = ivec2(1);\n    ivec2 res = ivec2(resolution);\n    //index = res.x * res.y - index - 1;\n    for (int i = 0; i < MAX_ITER; i++) {\n        res /= 2;\n        //int rx = res.x % 2 == 0 ? 2 : 1;\n        //int ry = res.y % 2 == 0 ? 2 : 1;\n        \n        int thisIndex = index % 4;\n        fc.x += div2.x * (thisIndex % 2);\n        fc.y += div2.y * (thisIndex / 2);\n        index = index / 4;\n        \n        div2 *= 2;\n        if (index == 0) break;\n    }\n    return fc;\n}\n\nivec2 fromLinear(in int index, in vec2 resolution) {\n    //index -= 1;\n    return ivec2(index % int(resolution.x), index / int(resolution.x));\n}\n\nint toLinear(in vec2 fragCoord, in vec2 resolution) {\n    int index = int(fragCoord.x) + int(fragCoord.y) * int(resolution.x);\n    //index += 1;\n    return index;\n}\n\n#define toIndex(a, b, c) toIndex2(a, b, iResolution.xy, c)\nint toIndex2(in sampler2D channel, in vec2 fragCoord, in vec2 res, in vec2 pres) {\n    //return toIndexFull(fragCoord, getRes(resolution));\n    //vec2 pres = getRes(resolution);\n    ivec2 fc = ivec2(fragCoord / pres * res);\n    //ivec2 fc = ivec2(fragCoord);\n    vec4 index = texelFetch(channel, fc, 0);\n    //return int(index.x) * 0xFFFF + int(index.y);\n    return int(index.x);\n}\n\n#define fromIndex(a, b, c) fromIndex2(a, b, iResolution.xy, c)\nivec2 fromIndex2(in sampler2D channel, in int index, in vec2 res, in vec2 pres) {\n    //ivec2 fc = ivec2(vec2(fromLinear(index, pres)) / pres * res);\n    ivec2 fc = fromLinear(index, res);\n    return ivec2(texelFetch(channel, fc, 0).yz);\n}\n\nvec2 getPosition2(sampler2D channel, int index, vec2 res) {\n    ivec2 fc = fromLinear(index, res);\n    vec4 data = texelFetch(channel, fc, 0);\n    return fract(data.zw);\n}\n\nvec2 getPosition(sampler2D channel, int index, vec2 res) {\n    ivec2 fc = fromLinear(index, res);\n    vec4 data = texelFetch(channel, fc, 0);\n    return fract(data.xy);\n}\n\nvec4 updateParticle(in vec4 particle) {\n    vec2 v = particle.xy - particle.zw;\n    \n    vec2 pos = particle.xy;\n    vec2 dv = pos - 0.5;\n    float l = length(dv);\n    \n    vec2 a = -(dv / (0.001 + l)) * 0.00001 / (l * l + 1.1);\n    v += a;\n    \n    if (particle.x + v.x < 0.0 || particle.x + v.x >= 1.0) {\n        v.x = -v.x;\n    }\n    if (particle.y + v.y < 0.0 || particle.y + v.y >= 1.0) {\n        v.y = -v.y;\n    }\n    \n    float maxSpeed = 0.1;\n    v = length(v) > maxSpeed ? maxSpeed * v / length(v) : v;\n    \n    particle.zw = particle.xy;\n    particle.xy += v;\n        \n    return particle;\n}\n\nint maxLinear(vec2 res) {\n    return int(exp2(floor(log2(float(toLinear(res - 1.0, res))))));\n}\n\nbool isLinearValid(in int index, vec2 iResolution) {\n    vec2 res = iResolution.xy;\n    //return true;\n\treturn index < maxLinear(iResolution);\n}\n\nbool isValid(in vec2 fragCoord, vec2 iResolution) {\n    vec2 res = iResolution.xy;\n    return isLinearValid(toLinear(fragCoord, res), iResolution);\n}\n\nmPartitionData getPartitionData(sampler2D channel, vec2 fragCoord, vec2 res) {\n    mPartitionData mRet;\n    //int maxPasses = getMaxPasses(res);\n    //mRet.partitionCount = int(exp2(ceil(log2(float(maxPasses)))));\n    mRet.partitionCount = 16;\n    //mRet.maxIndex = toLinear(res - 1.0, res);\n    mRet.maxIndex = maxLinear(res);\n    mRet.particlesPerPartition = mRet.maxIndex / mRet.partitionCount;\n    mRet.index = toLinear(fragCoord, res);\n    mRet.partitionIndex = mRet.index / mRet.particlesPerPartition;\n    mRet.offset = mRet.index % mRet.particlesPerPartition;\n    mRet.futureIndex = mRet.index - mRet.particlesPerPartition;\n    mRet.futureCoord = fromLinear(mRet.futureIndex, res);\n    mRet.futureParticle = texelFetch(channel, mRet.futureCoord, 0);\n    mRet.pastIndex = mRet.index + mRet.particlesPerPartition;\n    mRet.overflow = mRet.index >= mRet.maxIndex;\n    //(mRet.partitionIndex - 1) * mRet.particlesPerPartition + mRet.offset;\n    \n    \n    return mRet;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Resources:\n// https://www.ics.uci.edu/~goodrich/pubs/skip-journal.pdf\n// Sorting with GPUs: A Survey: https://arxiv.org/pdf/1709.02520.pdf\n\n// Practice JavaScript implementation: http://jsbin.com/zeyiraw/\n\n// https://www.shadertoy.com/view/XlcGD8\n// https://developer.nvidia.com/gpugems/GPUGems2/gpugems2_chapter46.html\n// https://stackoverflow.com/questions/26093629/glsl-odd-even-merge-sort\n// https://bl.ocks.org/zz85/cafa1b8b3098b5a40e918487422d47f6\n\n//#define PART 0\n\nconst int MAX_INT = 0x8FFFFFFF;\nconst int count = 8;\nint A[count];\nvec4 B[count];\n\nvoid SWAP(int a, int b) {\n    //int small = min(A[a], A[b]);\n    //int big = max(A[a], A[b]);\n    \n    bool cmp = A[a] < A[b];\n    /*\n    if (cmp) {\n        int tmp = A[a];\n        A[a] = A[b];\n        A[b] = tmp;\n        vec4 tmp2 = B[a];\n        B[a] = B[b];\n        B[b] = tmp2;\n    }*/\n    \n    int small = cmp ? A[a] : A[b];\n    int big = cmp ? A[b] : A[a];\n    vec4 first = cmp ? B[a] : B[b];\n    vec4 second = cmp ? B[b] : B[a];\n    A[a] = small;\n    A[b] = big;\n    B[a] = first;\n    B[b] = second;\n\t\n}\n\nivec2 fromLinear2(in int index, in vec2 resolution, int mode) {\n    if (mode == 0) {\n    \treturn ivec2(index % int(resolution.x), index / int(resolution.x));\n    } else {\n        return ivec2(index / int(resolution.y), index % int(resolution.y));\n    }\n}\n\nint toLinear2(in vec2 fragCoord, in vec2 resolution, int mode) {\n    if (mode == 0) {\n    \treturn int(fragCoord.x) + int(fragCoord.y) * int(resolution.x);\n    } else {\n        return int(fragCoord.x) * int(resolution.y) + int(fragCoord.y);\n    }\n}\n\nvec4 sort8(int target) {\n    // Bitonic sort network from http://pages.ripco.net/~jgamble/nw.html\n    // http://jgamble.ripco.net/cgi-bin/nw.cgi?inputs=8&algorithm=batcher&output=macro\n\n    /*\n    for (int i = 0; i < count; i++) {\n        for (int j = i + 1; j < count; j++) {\n            SWAP(i, j);\n        }\n    }\n    for (int i = 0; i < count; i++) {\n        for (int j = i + 1; j < count; j++) {\n            SWAP(i, j);\n        }\n    }*/\n\n    SWAP(0, 4);\n\tSWAP(1, 5);\n\tSWAP(2, 6);\n\tSWAP(3, 7);\n\tSWAP(0, 2);\n\tSWAP(1, 3);\n\tSWAP(4, 6);\n\tSWAP(5, 7);\n\tSWAP(2, 4);\n\tSWAP(3, 5);\n\tSWAP(0, 1);\n\tSWAP(2, 3);\n\tSWAP(4, 5);\n\tSWAP(6, 7);\n\tSWAP(1, 4);\n\tSWAP(3, 6);\n\tSWAP(1, 2);\n\tSWAP(3, 4);\n\tSWAP(5, 6);\n    return B[target];\n}\n\nvoid sort16() {\n    SWAP(0, 1);\n    SWAP(2, 3);\n    SWAP(4, 5);\n    SWAP(6, 7);\n    SWAP(8, 9);\n    SWAP(10, 11);\n    SWAP(12, 13);\n    SWAP(14, 15);\n    SWAP(0, 2);\n    SWAP(4, 6);\n    SWAP(8, 10);\n    SWAP(12, 14);\n    SWAP(1, 3);\n    SWAP(5, 7);\n    SWAP(9, 11);\n    SWAP(13, 15);\n    SWAP(0, 4);\n    SWAP(8, 12);\n    SWAP(1, 5);\n    SWAP(9, 13);\n    SWAP(2, 6);\n    SWAP(10, 14);\n    SWAP(3, 7);\n    SWAP(11, 15);\n    SWAP(0, 8);\n    SWAP(1, 9);\n    SWAP(2, 10);\n    SWAP(3, 11);\n    SWAP(4, 12);\n    SWAP(5, 13);\n    SWAP(6, 14);\n    SWAP(7, 15);\n    SWAP(5, 10);\n    SWAP(6, 9);\n    SWAP(3, 12);\n    SWAP(13, 14);\n    SWAP(7, 11);\n    SWAP(1, 2);\n    SWAP(4, 8);\n    SWAP(1, 4);\n    SWAP(7, 13);\n    SWAP(2, 8);\n    SWAP(11, 14);\n    SWAP(2, 4);\n    SWAP(5, 6);\n    SWAP(9, 10);\n    SWAP(11, 13);\n    SWAP(3, 8);\n    SWAP(7, 12);\n    SWAP(6, 8);\n    SWAP(10, 12);\n    SWAP(3, 5);\n    SWAP(7, 9);\n    SWAP(3, 4);\n    SWAP(5, 6);\n    SWAP(7, 8);\n    SWAP(9, 10);\n    SWAP(11, 12);\n    SWAP(6, 7);\n    SWAP(8, 9);\n}\n\nbool compareTwo(int i, int j, vec4 a, vec4 b, int compare, vec2 res2) {\n    //toIndex(self.xy * res2, res2) < toIndex(self2.xy * res2, res2)\n    int ai = toIndex(iChannel3, a.xy * res2, res2);\n    int bi = toIndex(iChannel3, b.xy * res2, res2);\n    float l1 = length(a.xy);\n    float l2 = length(b.xy);\n    //return l1 * float(compare) < l2 * float(compare);\n    if (ai == bi) {\n        //return i * compare < j * compare;\n        if (l1 == l2) {\n            if (a.x == b.x) {\n        \t\treturn a.y * float(compare) < b.y * float(compare);\n            } else {\n                return a.x * float(compare) < b.x * float(compare);\n            }\n        } else {\n            return l1 * float(compare) < l2 * float(compare);\n        }\n    } else {\n    \treturn ai * compare < bi * compare;\n    }\n}\n\nvec4 getPartner(int i, vec2 fc, vec2 res, int TwoStage, int Pass_mod_Stage, int TwoStage_PmS_1, int Pass, int maxIndex, int mode) {\n    // my position within the range to merge\n    int j = int(i % TwoStage);\n\n    int compare = 0;\n\n    bool check1 = i + Pass > maxIndex;\n    bool check2 = i - Pass < 0;\n    bool check = check1 || check2;\n    check = false;\n    if ((j < Pass_mod_Stage) || (j > TwoStage_PmS_1) || check) {\n      // must copy -> compare with self\n      //return vec4(-1.0);\n      compare = 0;\n    } else {\n      // must sort\n      if (mod(float((j + Pass_mod_Stage) / Pass), 2.0) < 1.0) {\n        // we are on the left side -> compare with partner on the right\n        compare = check1 ? 0 : 1;\n      } else {\n        // we are on the right side -> compare with partner on the left\n        compare = check2 ? 0 : -1;\n      }\n    }\n\n    // get the partner\n    int adr = i + compare * Pass;\n    /*if (adr > maxIndex || adr < 0) {\n        return vec4(-1.0);\n    }*/\n    //adr = adr < 0 ? maxIndex - abs(adr % maxIndex) : adr % maxIndex;\n\n    ivec2 fc2 = fromLinear2(adr, res, mode);\n    compare = i < adr ? 1 : -1;\n    return vec4(adr, fc2, compare);\n}\n\nstruct mRet {\n    int Cm;\n    vec4 v;\n    bool valid;\n};\n\n//const int debugLen = 16;\nconst int debugLen = 8;\nconst int debugA[debugLen + 1] = int[debugLen + 1](0, 2, 4, 6, 1, 3, 5, 7, 8);\n//const int debugA[debugLen + 1] = int[debugLen + 1](0, 1, 4, 5, 2, 3, 6, 7, 8);\n//const int debugA[debugLen + 1] = int[debugLen + 1](0, 0, 0, 0, 1, 1, 1, 1, 8);\n//const int debugA[debugLen + 1] = int[debugLen + 1](0, 1, 2, 3, 4, 5, 6, 7, 8);\n//const int debugA[debugLen + 1] = int[debugLen + 1](4, 5, 6, 7, 0, 1, 2, 3, 8);\n//const int debugA[debugLen + 1] = int[debugLen + 1](8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7, 40);\n// pairs for m = 3:\n// 6 1\n// 4 3\n// 2 5\n// 0 7\nint debugT[debugLen];\nconst bool debug = false;\n\nmRet getMD(int part, int m, vec2 res, vec2 pres) {\n    /*if (debug) {\n        return mRet(debugA[m], vec4(debugA[m]), true);\n    }*/\n    vec2 fc = vec2(fromLinear2(m, res, 0));\n    vec4 v = texelFetch(iChannel2, ivec2(fc), 0);\n    vec2 pos = part == 0 ? v.xy : v.zw;\n    int Am = toIndex(iChannel3, pos * pres, pres);\n    int maxIndex = toLinear2(res - 1.0, res, 0);\n    bool valid = m >= 0 && m <= maxIndex && isLinearValid(m, res);\n    return mRet(Am, v, valid);\n}\n\nmRet getM(int m, vec2 res, vec2 pres) {\n    /*if (debug) {\n        return mRet(debugA[m], vec4(debugA[m]), true);\n    }*/\n    vec2 fc = vec2(fromLinear2(m, res, 0));\n    vec4 v = texelFetch(iChannel0, ivec2(fc), 0);\n    //int Am = toIndex(iChannel3, v.xy * pres, pres);\n    int Am = 0;\n    int maxIndex = toLinear2(res - 1.0, res, 0);\n    bool valid = m >= 0 && m <= maxIndex && isLinearValid(m, res);\n    mRet ret = mRet(Am, v, valid);\n    \n    //ret = getMD(int(v.z), res, pres);\n    //ret.v = v;\n    /*\n    int dIndex = int(v.z);\n    m = dIndex;\n    fc = vec2(fromLinear2(dIndex, res, 0));\n    vec4 v2 = texelFetch(iChannel2, ivec2(fc), 0);\n    Am = toIndex(iChannel3, v2.xy * pres, pres);\n    valid = m >= 0 && m <= maxIndex && isLinearValid(m, res);\n    ret = mRet(Am, v, valid);\n    ret = mRet(Am, vec4(v2.xy, v.z, 0.0), valid);\n\t*/\n    \n    return ret;\n}\n\nint toRange(int x, int n) {\n    return min(max(0, x), n - 1);\n}\n\n/*\nivec2 pairToRange(int a, int b, int n, int targetOffset) {\n    if (a < 0) {\n        b += -a;\n        a = 0;\n    }\n    if (b < 0) {\n        a += -b;\n        b = 0;\n    }\n    //a = min(max(0, a), n - 1);\n    //b =\n    return ivec2(a, b);\n}*/\n\nint extractIndex(vec4 v, int part) {\n    return int(v[PART]);\n}\n\nint getIndex(int part, mRet A, vec2 res, vec2 pres) {\n    vec4 v1 = getMD(part, extractIndex(A.v, part), res, pres).v;\n    vec2 pos = part == 0 ? v1.xy : v1.zw;\n    int Am = toIndex(iChannel3, pos * pres, pres);\n    return Am;\n}\n\nbool compare(int part, mRet A, mRet B, vec2 res, vec2 pres) {\n    vec4 v1 = getMD(part, extractIndex(A.v, part), res, pres).v;\n    vec4 v2 = getMD(part, extractIndex(B.v, part), res, pres).v;\n    vec2 pos1 = part == 0 ? v1.xy : v1.zw;\n    vec2 pos2 = part == 0 ? v2.xy : v2.zw;\n    int Am = toIndex(iChannel3, pos1 * pres, pres);\n    int Bm = toIndex(iChannel3, pos2 * pres, pres);\n    return Am < Bm;\n}\n\nbool cutValid(int part, int n1, int n2, int astart, int bstart, int to, int m2, int x, vec2 res, vec2 pres) {\n    int apos = m2 - 1;\n    bool aValid = apos >= 0 && apos < n1;\n    int bpos = to - m2 - 1;\n    bool bValid = bpos >= 0 && bpos < n2;\n\n    mRet Amret = getM(astart + apos, res, pres);\n    mRet Bmret = getM(bstart + bpos, res, pres);\n\n    int cv11 = getIndex(part, Amret, res, pres);\n    int cv12 = getIndex(part, Bmret, res, pres);\n    return (\n        aValid && bValid && apos >= 0 && bpos >= 0 ? max(cv11, cv12) <= x\n        : bValid && apos < 0 && bpos >= 0 ? cv12 <= x\n        : aValid && apos >= 0 && bpos < 0 ? cv11 <= x\n        : Amret.valid && Bmret.valid);\n}\n\nbool cutCValid(int part, int n1, int n2, int astart, int bstart, int to, int bm2, int x, vec2 res, vec2 pres) {\n    int apos = to - bm2 - 1;\n    int bpos = bm2 - 1;\n    bool aValid = apos >= 0 && apos < n1;\n    bool bValid = bpos >= 0 && bpos < n2;\n\n    mRet Amret = getM(astart + apos, res, pres);\n    mRet Bmret = getM(bstart + bpos, res, pres);\n\tint cvc11 = getIndex(part, Amret, res, pres);\n    int cvc12 = getIndex(part, Bmret, res, pres);\n    return (\n    \taValid && bValid && apos >= 0 && bpos >= 0 ? max(cvc11, cvc12) <= x\n        : bValid && apos < 0 && bpos >= 0 ? cvc12 <= x\n        : aValid && apos >= 0 && bpos < 0 ? cvc11 <= x\n        : Amret.valid && Bmret.valid);\n}\n\nmRet checkIndex(int part, int n1, int n2, int astart, int bstart, int to, int apos, vec2 res, vec2 pres) {\n    bool aValid = apos >= 0 && apos < n1;\n    int bpos = to - apos;\n    bool bValid = bpos >= 0 && bpos < n2;\n\n    mRet Amret = getM(astart + apos, res, pres);\n    mRet Bmret = getM(bstart + bpos, res, pres);\n\n    int candA = getIndex(part, Amret, res, pres);\n    bool candAv = cutValid(part, n1, n2, astart, bstart, to, apos, candA, res, pres) && aValid;\n    Amret.valid = Amret.valid && candAv;\n\n    int candB = getIndex(part, Bmret, res, pres);\n    bool candBv = cutCValid(part, n1, n2, astart, bstart, to, bpos, candB, res, pres) && bValid;\n    Bmret.valid = Bmret.valid && candBv;\n\n    if (candAv && candBv) {\n        if (candA < candB) {\n            return Amret;\n        } else {\n            return Bmret;\n        }\n    } else if (candAv) {\n        return Amret;\n    }\n    return Bmret;\n}\n\nmRet binarySearchForMergeSlim(\n    int part,\n    int targetOffset, int n1, int n2, vec2 pres, vec2 res,\n    in vec2 fragCoord, int astart, int bstart) {\n\n    int L1 = min(max(targetOffset + 1 - n1, 0), n1 - 1);\n    int R1 = min(targetOffset + 1, n1);\n    int L2 = min(max(targetOffset + 1 - n2, 0), n2 - 1);\n    int R2 = min(targetOffset + 1, n2);\n\n    int OL1 = L1;\n    int OR2 = R2;\n\n    int i = 0;\n\n    mRet ret;\n\n    bool bValid = true;\n\n    for (i = 0; i < maxBin && L1 < R1 && (L2 < R2 || !bValid); i++) {\n        int m = (L1 + R1) / 2 + (L1 + R1) % 2;\n        int bm = targetOffset - m;\n        int apos = m;\n        bool aValid = apos >= 0 && apos < n1;\n        int bpos = bm;\n        bValid = bpos >= 0 && bpos < n2;\n\n        mRet Amret = getM(astart + apos, res, pres);\n        aValid = aValid && Amret.valid;\n        mRet Bmret = getM(bstart + bpos, res, pres);\n        bValid = bValid && Bmret.valid;\n\n        int Am = getIndex(part, Amret, res, pres);\n        int Bm = getIndex(part, Bmret, res, pres);\n\n        bool comparison = compare(part, Amret, Bmret, res, pres) && aValid && bValid;\n        bool inUpperHalf = comparison;\n\n        // m + 1 to R1\n        L1 = inUpperHalf ? m : L1;\n        // L1 to m\n        R1 = !inUpperHalf ? m - 1 : R1;\n        // bm + 1 to R2\n        L2 = !inUpperHalf ? bm : L2;\n        // L2 to bm\n        R2 = inUpperHalf ? bm : R2;\n    }\n    mRet error = mRet(-1, vec4(-1.0), false);\n     \n    int apos = L1;\n    int bpos = targetOffset - L1;\n    bValid = bpos >= 0 && bpos < n2;\n\n    mRet AL1ret = getM(astart + apos, res, pres);\n    mRet BL1ret = getM(bstart + bpos, res, pres);\n    //return AL1ret;\n\n    // XXX: AL1ret and BL1ret should be valid I hope\n    int m2 = getIndex(part, AL1ret, res, pres) < getIndex(part, BL1ret, res, pres) && bValid ? L1 + 1 : L1;\n    int bm2 = OR2 - (m2 - OL1);\n    bool bm2Valid = bm2 >= 0 && bm2 < n2;\n    bool bm2Min1Valid = bm2 - 1 >= 0 && bm2 - 1 < n2;\n\n    int to = targetOffset;\n\n    mRet cand1 = checkIndex(part, n1, n2, astart, bstart, to, m2, res, pres);\n    mRet cand2 = checkIndex(part, n1, n2, astart, bstart, to, bm2, res, pres);\n    cand2.valid = cand2.valid && bm2Valid;\n    mRet cand3 = checkIndex(part, n1, n2, astart, bstart, to, m2 - 1, res, pres);\n    mRet cand4 = checkIndex(part, n1, n2, astart, bstart, to, bm2 - 1, res, pres);\n    cand4.valid = cand4.valid && bm2Min1Valid;\n\n    ret = cand1;\n    if (cand2.valid && (compare(part, cand2, ret, res, pres) || !ret.valid)) {\n        ret = cand2;\n    }\n    if (cand3.valid && (compare(part, cand3, ret, res, pres) || !ret.valid)) {\n        ret = cand3;\n    }\n    if (cand4.valid && (compare(part, cand4, ret, res, pres) || !ret.valid)) {\n        ret = cand4;\n    }\n    mRet AnMin1 = getM(astart + n1 - 1, res, pres);\n    mRet BtoMinN = getM(bstart + to - n1, res, pres);\n    mRet BnMin1 = getM(bstart + n2 - 1, res, pres);\n    mRet AtoMinN = getM(astart + to - n2, res, pres);\n    if (targetOffset >= n1 && compare(part, AnMin1, BtoMinN, res, pres) && BtoMinN.valid) {\n        ret = BtoMinN;\n    }\n    if (targetOffset >= n2 && compare(part, BnMin1, AtoMinN, res, pres) && AtoMinN.valid) {\n        ret = AtoMinN;\n    }\n    \n    if (i >= maxBin - 1) {\n        ret = error;\n    }\n    return ret;\n}\n\n\n\nmRet binarySearchForMerge(\n    int part,\n    int targetOffset, int n1, int n2, vec2 pres, vec2 res,\n    in vec2 fragCoord, int astart, int bstart, inout vec2 digits) {\n\n    int L1 = min(max(targetOffset + 1 - n1, 0), n1 - 1);\n    int R1 = min(targetOffset + 1, n1);\n    int L2 = min(max(targetOffset + 1 - n2, 0), n2 - 1);\n    int R2 = min(targetOffset + 1, n2);\n\n    int OL1 = L1;\n    int OR2 = R2;\n\n    int i = 0;\n\n    mRet ret;\n\n    float bx = -30.0;\n    float by = -15.0;\n    // Looking for m such that there are\n    // apos elements less than A[m] in A\n    // and bpos elements less than A[m] in B.\n    // For given m, how to count elements less than A[m] in A and B.\n    // For given m, decide whether there are more than targetOffset elements less than A[m] in A and B.\n    // For given m, is A[m] such an element that B[bpos] < A[m] and B[bpos + 1]\n\n    vec2 black = vec2(1.0, 0.0);\n    vec2 white = vec2(0.0);\n\n    bool bValid = true;\n\n    for (i = 0; i < maxBin && L1 < R1 && (L2 < R2 || !bValid); i++) {\n        int m = (L1 + R1) / 2 + (L1 + R1) % 2;\n        int bm = targetOffset - m;\n        int apos = m;\n        bool aValid = apos >= 0 && apos < n1;\n        int bpos = bm;\n        bValid = bpos >= 0 && bpos < n2;\n\n        mRet Amret = getM(astart + apos, res, pres);\n        aValid = aValid && Amret.valid;\n        mRet Bmret = getM(bstart + bpos, res, pres);\n        bValid = bValid && Bmret.valid;\n\n        float bline = -80.0;\n        bool showPos = true;\n        if (showPos) {\n        \tdigits += printBG(fragCoord + vec2(float(targetOffset) * bx, 1.0 * bline + float(i) * by), float(apos), 2, 0);\n        \tdigits += printBG(fragCoord + vec2(float(targetOffset) * bx, 2.0 * bline + float(i) * by), float(bpos), 2, 0);\n        }\n\n        int Am = getIndex(part, Amret, res, pres);\n        int Bm = getIndex(part, Bmret, res, pres);\n\n        digits += printBG(fragCoord + vec2(float(targetOffset) * bx, 3.0 * bline + float(i) * by), float(Am), 2, 0);\n        digits += printBG(fragCoord + vec2(float(targetOffset) * bx, 4.0 * bline + float(i) * by), float(Bm), 2, 0);\n\n        {\n            float dx = 40.0;\n            int a = L1;\n            int b = R1;\n            int c = L2;\n            int d = R2;\n\n            float sbx = 300.0;\n            float sbx2 = 550.0;\n            float sx = sbx + float(a) * dx;\n            float ex = sx + dx * float(b - a);\n            float sx2 = sbx2 + float(c) * dx;\n            float ex2 = sx2 + dx * float(d - c);\n            float hs = 20.0 + 55.0 * float(targetOffset);\n            float hy = 5.0;\n\n            // left, a range\n            digits +=\n                fragCoord.x >= sx &&\n                fragCoord.x <= ex &&\n                fragCoord.y >= hs + hy * float(i * 2) &&\n                fragCoord.y <= hs + hy * float(i * 2 + 1)\n                    ? black\n                    : white;\n            // right, b range\n            digits +=\n                fragCoord.x >= sx2 &&\n                fragCoord.x <= ex2 &&\n                fragCoord.y >= hs + hy * float(i * 2) &&\n                fragCoord.y <= hs + hy * float(i * 2 + 1)\n                    ? black\n                    : white;\n           \t// whole lines for compare\n            digits +=\n                fragCoord.x >= sbx &&\n                fragCoord.x <= sbx + dx * 8.0 &&\n                fragCoord.y >= 6.0 &&\n                fragCoord.y <= 8.0\n                    ? black\n                    : white;\n            digits +=\n                fragCoord.x >= sbx2 &&\n                fragCoord.x <= sbx2 + dx * 8.0 &&\n                fragCoord.y >= 6.0 &&\n                fragCoord.y <= 8.0\n                    ? black\n                    : white;\n        }\n\n        bool comparison = compare(part, Amret, Bmret, res, pres) && aValid && bValid;\n        bool inUpperHalf = comparison;\n\n        // m + 1 to R1\n        L1 = inUpperHalf ? m : L1;\n        // L1 to m\n        R1 = !inUpperHalf ? m - 1 : R1;\n        // bm + 1 to R2\n        L2 = !inUpperHalf ? bm : L2;\n        // L2 to bm\n        R2 = inUpperHalf ? bm : R2;\n    }\n    mRet error = mRet(-1, vec4(-1.0), false);\n    if (i >= maxBin - 1) {\n        ret = error;\n    } else {\n        int apos = L1;\n        int bpos = targetOffset - L1;\n        bValid = bpos >= 0 && bpos < n2;\n\n        mRet AL1ret = getM(astart + apos, res, pres);\n        mRet BL1ret = getM(bstart + bpos, res, pres);\n        //return AL1ret;\n\n        // XXX: AL1ret and BL1ret should be valid I hope\n        int m2 = getIndex(part, AL1ret, res, pres) < getIndex(part, BL1ret, res, pres) && bValid ? L1 + 1 : L1;\n        int bm2 = OR2 - (m2 - OL1);\n        bool bm2Valid = bm2 >= 0 && bm2 < n2;\n        bool bm2Min1Valid = bm2 - 1 >= 0 && bm2 - 1 < n2;\n\n        int to = targetOffset;\n\n        mRet cand1 = checkIndex(part, n1, n2, astart, bstart, to, m2, res, pres);\n        mRet cand2 = checkIndex(part, n1, n2, astart, bstart, to, bm2, res, pres);\n        cand2.valid = cand2.valid && bm2Valid;\n        mRet cand3 = checkIndex(part, n1, n2, astart, bstart, to, m2 - 1, res, pres);\n        mRet cand4 = checkIndex(part, n1, n2, astart, bstart, to, bm2 - 1, res, pres);\n        cand4.valid = cand4.valid && bm2Min1Valid;\n\n        ret = cand1;\n        if (cand2.valid && (compare(part, cand2, ret, res, pres) || !ret.valid)) {\n            ret = cand2;\n        }\n        if (cand3.valid && (compare(part, cand3, ret, res, pres) || !ret.valid)) {\n            ret = cand3;\n        }\n        if (cand4.valid && (compare(part, cand4, ret, res, pres) || !ret.valid)) {\n            ret = cand4;\n        }\n        mRet AnMin1 = getM(astart + n1 - 1, res, pres);\n        mRet BtoMinN = getM(bstart + to - n1, res, pres);\n        mRet BnMin1 = getM(bstart + n2 - 1, res, pres);\n        mRet AtoMinN = getM(astart + to - n2, res, pres);\n        if (targetOffset >= n1 && compare(part, AnMin1, BtoMinN, res, pres) && BtoMinN.valid) {\n            ret = BtoMinN;\n        }\n        if (targetOffset >= n2 && compare(part, BnMin1, AtoMinN, res, pres) && AtoMinN.valid) {\n            ret = AtoMinN;\n        }\n        //ret = cand4;\n        //ret.Am += 10 * int(ret.valid);\n    }\n    return ret;\n}\n\nvoid bitonicSortD(int part, inout vec4 fragColor, in int index) {\n\t//int index = toLinear2(fragCoord, iResolution.xy, 0);\n\n    vec2 res = iResolution.xy;\n    vec2 pres = getRes(res);\n\n    int target = index % count;\n\n    for (int i = 0; i < count; i++) {\n        int partner = index - target + i;\n        //partner = partner * vec4Count + PART;\n        mRet ret = getMD(part, partner, res, pres);\n        A[i] = ret.Cm; //getIndex(part, ret, res, pres);\n        // TODO: all parts\n        B[i] = vec4(partner);\n    }\n    //sort8();\n\n  \t//fragColor[PART] = B[target][PART];\n    fragColor[PART] = sort8(target)[PART];\n}\n\nstruct mcData {\n    int pass;\n    int n;\n    bool overflow;\n    int index;\n    int base;\n    int astart;\n    int bstart;\n    int targetOffset;\n    //int spart;\n};\n    \nmcData getMCData(int part, in vec2 fragCoord, mPartitionData pd) {\n    mcData ret;\n    // first partition is lookup, + 3 for bitonic kickstart\n    ret.pass = max(0, pd.partitionIndex - 1);\n    //ret.spart = (part + 1) % vec4Count;\n    ret.n = (1 << ret.pass);\n    ret.overflow = 2 * ret.n > pd.particlesPerPartition || pd.particlesPerPartition % ret.n != 0;\n    ret.index = pd.index - pd.particlesPerPartition;\n    ret.base = ret.index - ret.index % (2 * ret.n);\n    ret.astart = ret.base;\n    ret.bstart = ret.base + ret.n;\n    ret.targetOffset = ret.index - ret.base;\n    return ret;\n}\n\nint mergeColumns(inout vec4 fragColor, in vec2 fragCoord) {\n    vec2 res = iResolution.xy;\n    vec2 pres = getRes(res);\n    mPartitionData pd = getPartitionData(iChannel0, fragCoord, res);\n\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    bool overflow = false;\n    for (int part = 0; part < vec4Count; part++) {\n        mcData ret = getMCData(PART, fragCoord, pd);\n    \toverflow = overflow || ret.overflow;\n        fragColor[PART] = binarySearchForMergeSlim(\n            PART, ret.targetOffset, ret.n, ret.n,\n            pres, res, fragCoord, ret.astart, ret.bstart).v[PART];\n    }\n    if (pd.partitionIndex + 1 < pd.partitionCount) {\n        fragColor += float(pd.particlesPerPartition);\n    }\n    \n    if (overflow) {\n        fragColor = pd.futureParticle;\n        return -1;\n    }\n    \n    if (pd.partitionIndex == 0) {\n        for (int part = 0; part < vec4Count; part++) {\n            bitonicSortD(PART, fragColor, pd.index);\n        }\n        fragColor += float(pd.particlesPerPartition);\n    }\n\n    if (debug) {\n        vec2 digits = vec2(0.0);\n        float bx = -30.0;\n        float by = -15.0;\n        int n = debugLen / 2;\n        int astart = 0;\n        int bstart = n;\n        for (int i = 0; i < debugLen; i++) {\n            int targetOffset = i;\n            mRet a = binarySearchForMerge(0, targetOffset, n, n, pres, res, fragCoord, astart, bstart, digits);\n            int val = getIndex(0, a, res, pres);\n            if (val < 0) {\n                val = 99;\n            }\n            digits += printBG(fragCoord + vec2(float(i) * bx, by), float(val), 2, 0);\n        }\n        fragColor.ba += digits;\n        return -1;\n    }\n    return -1;\n}\n\nvoid oddEvenMergeSort(out vec4 fragColor, in vec2 fragCoord) {\n    // stage 0 has pass = 0\n    // stage 1 has pass = 1, pass = 0\n    // stage 2 has pass = 2, pass = 1, pass = 0\n    // ...\n    vec2 res = iResolution.xy;\n\n    //res = vec2(256.0);\n    vec2 res2 = getRes(res);\n    vec4 self = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    self.ba *= 0.0;\n    int mode = 0;\n    int maxIndex = toLinear2(res - 1.0, res, mode);\n    int fieldSize = int(res.x); //toLinear(res, res);\n    int logFieldsize = int(ceil(log2(float(fieldSize))));\n    int totalSteps = ((logFieldsize + logFieldsize) * (logFieldsize + logFieldsize + 1)) / 2;\n    int frame = iFrame;\n\n    /*\n    if (frame >= totalSteps) {\n        frame -= totalSteps;\n        mode = 1;\n    }*/\n\n    //frame = int(iTime) / 1;\n    //float b3 = print(fragCoord, float(totalSteps) / 60.0, 10, 2);\n    //self.b += b3;\n    {\n        vec2 fc = fragCoord;\n        int i = toLinear2(fc, res, mode);\n        int j = i + 1;\n        ivec2 fc2 = fromLinear2(j, res, mode);\n        //fc2 = ivec2(fc + vec2(hash(uvec2(fc)), -1.0));\n        fc2 = ivec2(fc + vec2(0.0, -1.0));\n        //fc2 = ivec2(fc + vec2(1.0, 0.0));\n        vec4 self2 = texelFetch(iChannel0, fc2, 0);\n    \t//self.b = float(length(self2.xy) < length(self.xy));\n        if (!(fragCoord.x >= res.x || fragCoord.y >= res.y)) {\n        \tself.b = float(compareTwo(i, j, self, self2, 1, res2));\n        }\n    }\n    if (frame >= totalSteps) {\n        fragColor = self;\n        return;\n    }\n\n    int pass = -1;\n    int stage = -1;\n    int loopI = 0;\n    for (loopI = 0; loopI < frame + 1; loopI++) {\n        pass--;\n        if (pass < 0) {\n            stage++;\n            pass = stage;\n        }\n    }\n\n    float byd = 15.0;\n    float by = -75.0;\n    float bx = -740.0;\n    vec2 digits = vec2(0.0);\n    digits += printBG(fragCoord + vec2(bx, by), float(pass), 5, 0);\n    by += byd;\n    digits += printBG(fragCoord + vec2(bx, by), float(stage), 5, 0);\n    by += byd;\n    digits += printBG(fragCoord + vec2(bx, by), float(loopI), 5, 0);\n    by += byd;\n    digits += printBG(fragCoord + vec2(bx, by), float(totalSteps), 5, 0);\n    by += byd;\n    digits += printBG(fragCoord + vec2(bx, by), float(logFieldsize), 5, 0);\n    self.ba += digits;\n\n    if (fragCoord.x >= res.x || fragCoord.y >= res.y) {\n        fragColor = vec4(0.0);\n        fragColor = self;\n        return;\n    }\n\n    int ppass = 1 << pass;\n    int pstage = 1 << stage;\n\n    int TwoStage = 2 * pstage;\n    int Pass_mod_Stage = ppass % pstage;\n    int TwoStage_PmS_1 = TwoStage - Pass_mod_Stage - 1;\n    int Pass = ppass;\n\n    int i = toLinear2(fragCoord, res, mode);\n    ivec4 ret = ivec4(getPartner(i, fragCoord, res, TwoStage, Pass_mod_Stage, TwoStage_PmS_1, Pass, maxIndex, mode));\n    int adr = ret.x;\n    ivec2 fc2 = ret.yz;\n    int compare = ret.w;\n\n    if (adr < 0 || fc2.x >= int(res.x) || fc2.y >= int(res.y)) {\n        fragColor = self;\n        return;\n    }\n\n    // double check that partner will mirror us\n    /*\n    ivec4 ret2 = ivec4(getPartner(toLinear(fc2, res), vec2(fc2), res, TwoStage, Pass_mod_Stage, TwoStage_PmS_1, Pass, maxIndex));\n    if (ret2.x < 0 || ret2.yz != ivec2(fragCoord) || ret2.w != -compare) {\n        fragColor = self;\n        return;\n    }*/\n\n    vec4 partner = texelFetch(iChannel0, fc2, 0);\n\n    // on the left it's a < operation; on the right it's a >= operation\n    //fragColor = (self.x * compare < partner.x * compare) ? self : partner;\n    fragColor = compareTwo(i, adr, self, partner, compare, res2) ? self : partner;\n    //fragColor = (length(self.xy) * float(compare) < length(partner.xy) * float(compare)) ? self : partner;\n}\n\nvoid bitonicSort(int part, out vec4 fragColor, in vec2 fragCoord) {\n\tint index = toLinear2(fragCoord, iResolution.xy, 0);\n\n    vec2 res = iResolution.xy;\n    vec2 pres = getRes(res);\n\n    int target = index % count;\n\n    int bucketSize = count;\n    for (int i = 0; i < count; i++) {\n        int partner = index - target + i;\n        mRet ret = getM(partner, res, pres);\n        A[i] = getIndex(part, ret, res, pres);\n        B[i] = ret.v;\n    }\n    //sort8();\n\n  \tfragColor[PART] = B[target][PART];\n}\n\nvoid bubbleSort(int part, out vec4 fragColor, in vec2 fragCoord, int frame) {\n    vec2 res = iResolution.xy;\n    vec2 pres = getRes(res);\n    int n = toLinear2(res - 1.0, res, 0);\n    int k = frame;\n    int index = toLinear2(fragCoord, res, 0);\n    // Examples:\n\n    // k % 2 == 0 && index % 2 == 0 => dir == 1\n    // k % 2 == 0 && index % 2 == 1 => dir == -1\n    // k % 2 == 1 && index % 2 == 0 => dir == -1\n    // k % 2 == 1 && index % 2 == 1 => dir == 1\n\n    // k == 0 && index == 0 => index + dir == 0 + 1 = 1\n    // k == 0 && index == 1 => index + dir == 1 - 1 = 0\n    // k == 0 && index == 2 => index + dir == 2 + 1 = 3\n    // k == 0 && index == 3 => index + dir == 3 - 1 = 2\n    // k == 0 && index == 4 => index + dir == 4 + 1 = 5\n    // k == 0 && index == 5 => index + dir == 5 - 1 = 4\n\n    // k == 1 && index == 0 => index + dir == 0 - 1 = -1\n    // k == 1 && index == 1 => index + dir == 1 + 1 = 2\n    // k == 1 && index == 2 => index + dir == 2 - 1 = 1\n    // k == 1 && index == 3 => index + dir == 3 + 1 = 4\n    // k == 1 && index == 4 => index + dir == 4 - 1 = 3\n    // k == 1 && index == 5 => index + dir == 5 + 1 = 6\n    int dir = index % 2 == k % 2 ? 1 : -1;\n    mRet aRet = getM(index, res, pres);\n    mRet bRet = getM(index + dir, res, pres);\n    //mRet aRet2 = getMD(int(aRet.v.z), res, pres);\n    //mRet bRet2 = getMD(int(bRet.v.z), res, pres);\n\n    // update\n    /*\n    aRet.v = updateParticle(aRet.v);\n    bRet.v = updateParticle(bRet.v);\n    aRet.Am = toIndex(aRet.v.xy * pres, pres);\n    bRet.Am = toIndex(bRet.v.xy * pres, pres);\n\t*/\n\n    if (index + dir < 0 || index + dir >= n || !isLinearValid(index + dir, res)) {\n        fragColor = aRet.v;\n    } else {\n        if (getIndex(part, aRet, res, pres) * dir < getIndex(part, bRet, res, pres) * dir) {\n            fragColor[PART] = aRet.v[PART];\n        } else {\n            fragColor[PART] = bRet.v[PART];\n        }\n    }\n}\n\nint runPasses(out vec4 fragColor, in vec2 fragCoord, int startFrame) {\n    int ret = mergeColumns(fragColor, fragCoord);\n\treturn ret;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    int ret = runPasses(fragColor, fragCoord, int(0));\n    /*\n    // https://www.shadertoy.com/view/MsVBWd\n    float startFrame = texelFetch(iChannel0, ivec2(0), 0).a;\n    if (iFrame == 0 || startFrame < 1.0) {\n        fragColor = vec4(0.0);\n        if (iChannelResolution[1].x > 0.0) {\n            if (fragCoord.x <= 1.0 && fragCoord.y <= 1.0) {\n            \tfragColor.a = 1.0 + float(iFrame);\n            }\n        }\n        return;\n    }\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    //oddEvenMergeSort(fragColor, fragCoord);\n    int ret = runPasses(fragColor, fragCoord, int(startFrame));\n\n    //fragColor.ba += printBG(fragCoord + vec2(-100.0, 0.0), float(startFrame), 5, 0);\n\n    if (fragCoord.x < 1.0 && fragCoord.y < 1.0) {\n        fragColor.a = startFrame;\n        //fragColor.b = float(ret);\n    }*/\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define condFetch(x) texelFetch(iChannel2, ivec2(x), 0)\n\nstruct mRet {\n    int dIndex;\n    int Am;\n    vec4 v;\n    vec2 pos;\n};\n\nmRet getMD(int part, int m, vec2 res, vec2 pres) {\n    vec2 fc = vec2(fromLinear(m, res));\n    vec4 v = texelFetch(iChannel3, ivec2(fc), 0);\n    vec2 pos = part == 0 ? v.xy : v.zw;\n    int Am = toIndex(iChannel0, pos * pres, pres);\n    return mRet(m, Am, v, pos);\n}\n\nfloat textColor(vec3 bgColor) {\n  float r = bgColor.r * 255.0,\n        g = bgColor.g * 255.0,\n        b = bgColor.b * 255.0;\n  float yiq = (r * 299.0 + g * 587.0 + b * 114.0) / 1000.0;\n  return (yiq >= 128.0) ? 0.0 : 1.0;\n}\n\nvec2 vmin(vec2 v1, vec2 v2) {\n    return length(v1) < length(v2) ? v1 : v2;\n}\n\nmRet getM(int part, int m, vec2 res, vec2 pres) {\n    vec2 fc = vec2(fromLinear(m, res));\n    vec4 v = condFetch(fc);\n    //int Am = toIndex(iChannel0, v.xy * pres, pres);\n    mRet ret2 = getMD(part, int(v[part]), res, pres);\n    vec4 v2 = ret2.v;\n    vec2 pos = part == 0 ? v2.xy : v2.zw;\n    int Am = toIndex(iChannel0, pos * pres, pres);\n    return mRet(int(v.x), ret2.Am, v2, pos);\n}\n\nint binarySearchLeftMost(int part, int T, vec2 pres, vec2 res, in vec2 fragCoord, out vec4 col) {\n    mPartitionData pd = getPartitionData(iChannel0, fragCoord, res);\n    int n = pd.particlesPerPartition;\n    int L = (pd.partitionCount - 1) * n;\n    int R = L + n;\n    \n    int bx = 0;\n    int by = 20;\n    int i = 0;\n    for (i = 0; i < maxBin && L < R; i++) {\n        int m = (L + R) / 2;\n        int Am = getM(part, m, res, pres).Am;\n        //col += print(fragCoord - vec2(0.0, by + i * 15), float(i), 3, 0);\n        //col += print(fragCoord - vec2(50.0, by + i * 15), float(m), 10, 0);\n        //col += print(fragCoord - vec2(150.0, by + i * 15), float(L), 10, 0);\n        //col += print(fragCoord - vec2(250.0, by + i * 15), float(R), 10, 0);\n        L = Am < T ? m + 1 : L;\n        R = Am >= T ? m : R;\n    }\n    //col += print(fragCoord - vec2(0.0, 0.0), float(T), 10, 0);\n    int ret = i < maxBin - 1 ? L : -1;\n    //col += print(fragCoord - vec2(bx + 100, 0.0), float(ret), 10, 0);\n    return ret;\n}\n\nint binarySearchRightMost(int part, int T, vec2 pres, vec2 res, in vec2 fragCoord, out vec4 col) {\n    mPartitionData pd = getPartitionData(iChannel0, fragCoord, res);\n    int n = pd.particlesPerPartition;\n    int L = (pd.partitionCount - 1) * n;\n    int R = L + n;\n    \n    \n    int bx = 400;\n    int by = 20;\n    int i = 0;\n    for (i = 0; i < maxBin && L < R; i++) {\n        int m = (L + R) / 2;\n        int Am = getM(part, m, res, pres).Am;\n        //col += print(fragCoord - vec2(bx + 0, by + i * 15), float(i), 3, 0);\n        //col += print(fragCoord - vec2(bx + 50, by + i * 15), float(m), 10, 0);\n        //col += print(fragCoord - vec2(bx + 150, by + i * 15), float(L), 10, 0);\n        //col += print(fragCoord - vec2(bx + 250, by + i * 15), float(R), 10, 0);\n        L = Am <= T ? m + 1 : L;\n        R = Am > T ? m : R;\n    }\n    //col += print(fragCoord - vec2(bx, 0.0), float(T), 10, 0);\n    int ret = i < maxBin - 1 ? L - 1 : -1;\n    //col += print(fragCoord - vec2(bx + 100, 0.0), float(ret), 10, 0);\n    return ret;\n}\n\nfloat doDistance(int part, in vec2 fragCoord, vec2 colorUV) {\n    vec2 res2 = iResolution.xy;\n    float t = 1.0; //(sin(iTime) + 1.0) / 2.0 + 0.1;\n    vec2 oc = fragCoord;\n    fragCoord = ((fragCoord / res2 - 0.5) * t + 0.5) * res2;\n    //vec2 res2 = vec2(256.0);\n    //vec3 col = vec3(0.0);\n    vec2 powerOfTwoRes = getRes(res2);\n    //vec2 res = res2;\n    vec2 uv = floor(fragCoord / res2 * powerOfTwoRes);\n    ivec2 div = maxDiv(powerOfTwoRes);\n    //vec2 colorUV = fragCoord / iResolution.xy;\n    int n = int(powerOfTwoRes.x * powerOfTwoRes.y);\n    int m = int(res2.x * res2.y);\n\n\t//fragColor *= 0.0;\n    int uvIndex = toIndex(iChannel0, uv, powerOfTwoRes);\n    //uvIndex = m / 2;\n    vec4 frcol = vec4(0.0);\n    int index3 = binarySearchLeftMost(part, uvIndex, powerOfTwoRes, res2, oc, frcol);\n    int index4 = binarySearchRightMost(part, uvIndex, powerOfTwoRes, res2, oc, frcol);\n\n    mRet mret = getM(part, index3, res2, powerOfTwoRes);\n    int foundIndex = mret.Am;\n    vec4 v = mret.v;\n    float d = distance(colorUV, mret.pos);\n \n    int j = 0;\n    int a = min(index3, index4);\n    int b = max(index3, index4);\n    int maxIter = 1;\n    int retIndex = -1;\n    for (int j = 0; j < maxIter; j++) {\n        int i = a + j - maxIter / 2;\n        mRet mret = getM(part, i, res2, powerOfTwoRes);\n        int foundIndex = mret.Am;\n        vec4 v = mret.v;\n        float d2 = distance(colorUV, mret.pos);\n        if (d2 < d) {\n            d = d2;\n            retIndex = i; //foundIndex;\n        }\n    }\n\n    return float(retIndex);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 col = vec3(0.0);\n    vec2 res2 = iResolution.xy;\n    vec2 res = getRes(iResolution.xy);\n    vec2 powerOfTwoRes = res;\n    vec2 uv = floor(fragCoord / iResolution.xy * res);\n    ivec2 div = maxDiv(res);\n    vec2 colorUV = fragCoord / iResolution.xy;\n    int n = int(res.x * res.y);\n    int m = int(iResolution.x * iResolution.y);\n    fragColor += print(fragCoord, float(n), 10, 0);\n    //return;\n\n    vec4 old = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    float oldIndex = old.x;\n    //float oldIndex2 = old.y;\n\n    for (int part = 0; part < vec4Count; part++) {\n        mRet mret1 = getM(part, int(oldIndex), res2, powerOfTwoRes);\n        float d2 = distance(colorUV, mret1.pos);\n        //mRet mret3 = getM(int(oldIndex2), res2, powerOfTwoRes);\n        //float d5 = distance(colorUV, mret3.v.xy);\n        //float d2 = min(d4, d5);\n        //float oldIndex = d4 < d5 ? oldIndex1 : oldIndex2;\n\n        float index = doDistance(part, fragCoord, colorUV);\n\n        mRet mret2 = getM(part, int(index), res2, powerOfTwoRes);\n        //int bufDIndex = int(mret2.v.z);\n        //mRet mret3 = getMD(bufDIndex, res2, powerOfTwoRes);\n\n        float d3 = distance(colorUV, mret2.pos);\n        //float d3 = distance(colorUV, mret2.v.xy);\n\n        index = d3 < d2 ? index : oldIndex;\n        //vec2 v = d3 < d2 ? mret2.v.xy - mret2.v.zw : old.zw;\n\n        fragColor[PART] = index; //vec4(index, 0.0, v);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy;\n    vec2 pres = getRes(res);\n    vec2 fc = fragCoord / res * pres;\n    //fc = fragCoord;\n    int index = toIndexFull(fc, pres);\n    \n    // TODO: maybe incorrect\n    vec2 revIndex = vec2(fromIndexFull(toLinear(fc, res), pres));\n    \n    //float startFrame = texelFetch(iChannel0, ivec2(0), 0).a;\n    \n    //fragColor = vec4(index / 0xFFFF, index % 0xFFFF, 0.0, 0.0);\n    fragColor = vec4(index, 0.0, 0.0, 0.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "vec2 transformPos(vec2 pos) {\n    pos = (pos - 0.5) * 4.0 + 0.5;\n    pos = mod(pos, 1.0);\n\t//pos = clamp(pos, 0.0, 1.0);\n    pos = vec2(0.5);\n    return pos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // https://www.shadertoy.com/view/MsVBWd\n    float startFrame = floor(texelFetch(iChannel0, ivec2(0), 0).a);\n    \n    vec2 res = iResolution.xy;\n    mPartitionData pd = getPartitionData(iChannel0, fragCoord, res);\n    \n    if (iFrame == 0 || startFrame < 1.0) {\n        fragColor = vec4(0.0);\n        if (iChannelResolution[2].x > 0.0) {\n        \t//fragColor.ba = vec2(0.0);\n            \n            if (pd.partitionIndex == 0) {\n                // position\n                vec2 fc = vec2(fromLinear(pd.index, res));\n            \tvec4 data = texture(iChannel2, fc / iResolution.xy);\n        \t\tfragColor.xy = transformPos(data.xy);\n                fragColor.zw = transformPos(data.zw);\n            } else {\n                // velocity\n                vec2 fc = vec2(fromLinear(pd.futureIndex, res));\n            \tvec4 data = texture(iChannel2, fc / iResolution.xy);\n                \n                vec2 pos = transformPos(data.xy);\n                vec2 vel = 10.0 * (data.zw - 0.5) / iResolution.xy;\n                float maxSpeed = 1.0;\n                vel = length(vel) > maxSpeed ? maxSpeed * vel / length(vel) : vel;\n                vec2 oldPos = pos - vel;\n            \tfragColor.xy = oldPos;\n                \n                pos = transformPos(data.zw);\n                vel = 10.0 * (data.xy - 0.5) / iResolution.xy;\n                vel = length(vel) > maxSpeed ? maxSpeed * vel / length(vel) : vel;\n                oldPos = pos - vel;\n            \tfragColor.zw = oldPos;\n            }\n            \n            if (pd.overflow) {\n                fragColor = vec4(0.0);\n            }\n            \n            if (fragCoord.x < 1.0 && fragCoord.y < 1.0) {\n            \tfragColor.a += 1.0 + float(iFrame);\n            }\n        }\n        return;\n    }\n    //fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    vec4 particle1 = vec4(0.0);\n    particle1.xy = getPosition(iChannel0, pd.index, res);\n    particle1.zw = getPosition(iChannel0, pd.pastIndex, res);\n    vec4 particle2 = vec4(0.0);\n    particle2.xy = getPosition2(iChannel0, pd.index, res);\n    particle2.zw = getPosition2(iChannel0, pd.pastIndex, res);\n    //fragColor = texture(iChannel2, fragCoord / iResolution.xy) + hash(uvec2(fragCoord) + uint(iFrame));\n    vec4 updatedParticle = vec4(updateParticle(particle1).xy, updateParticle(particle2).xy);\n    //newParticle = fragColor;\n\t\n    //newParticle = vec4(float(iFrame % 10) / 10.0);\n    fragColor = pd.partitionIndex == 0 ? updatedParticle : pd.futureParticle;\n    fragColor = pd.overflow ? vec4(0.0) : fragColor;\n    \n    //bubbleSort(fragColor, fragCoord, iFrame);\n    \n    \n    /*\n    bool sorted1 = texelFetch(iChannel1, ivec2(0), 0).b > 1.0;\n    int mp = getMaxPasses(iResolution.xy);\n    int frame = iFrame - int(startFrame);\n    if (sorted1 && isValid(fragCoord, iResolution.xy) && frame % (3 * mp) == mp) {\n        int index = int(texelFetch(iChannel1, ivec2(fragCoord), 0).z);\n       \tfragColor = texelFetch(iChannel0, ivec2(fromLinear(index, iResolution.xy)), 0);\n    }*/\n    \n    if (fragCoord.x < 1.0 && fragCoord.y < 1.0) {\n        fragColor.a = fract(fragColor.a) + startFrame;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}