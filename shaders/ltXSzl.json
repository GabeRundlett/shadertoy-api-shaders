{
    "Shader": {
        "info": {
            "date": "1438846486",
            "description": "An improvement of my last raytracer, which accomodates reflections and shadows. It uses seperate methods for detecting intersection and for shading, which gives it support for secondary rays, unlike doing both in one method.",
            "flags": 1,
            "hasliked": 0,
            "id": "ltXSzl",
            "likes": 7,
            "name": "Improved Raytracer",
            "published": 3,
            "tags": [
                "3d",
                "raytracer",
                "math",
                "sphere",
                "plane"
            ],
            "usePreview": 0,
            "username": "jackdavenport",
            "viewed": 1173
        },
        "renderpass": [
            {
                "code": "// Improved Raytracer\n// by Jack Davenport\n#define EPSILON 0.001\n\nstruct Ray \n{\n    vec3 origin;\n    vec3 direction;\n};\n    \nstruct RaycastHit \n{\n\tvec3 point;\n    vec3 normal;\n    float det;\n    int type;\n};\n    \nconst float ambientLight = 0.2;\nvec3 light1 = vec3(-4., 5., -6.);\n\nRaycastHit intersectSphere(vec3 position, float radius, const Ray ray) {\n    \n\tfloat a = dot(ray.direction, ray.direction);\n    float b = 2. * dot(ray.direction, ray.origin - position);\n    float c = dot(ray.origin - position, ray.origin - position) -(radius * radius);\n    float det = (b * b) - 4. * a * c;\n\n\tfloat lambda = (-b -sqrt(det)) / (2. * a);\n\tvec3 p = ray.origin + lambda * ray.direction;\n\tvec3 n = p - position;\n    \n    RaycastHit hit;\n    hit.point = p;\n    hit.normal = normalize(n);\n    hit.det = det;\n    hit.type = (det >= 0. && lambda >= 0.) ? 0 : -1;\n    //hit.type = det >= 0. ? 0 : -1;\n    \n    return hit;\n        \n}\n\nRaycastHit intersectPlane(vec3 position, vec3 normal, const Ray ray) {\n \n    //float num = position.y - dot(normal, ray.origin);\n\tfloat num = -dot(normal,ray.origin-position);\n    float denom = dot(normal, ray.direction);\n\tfloat t = num / denom;\n\t\t\t\n\tvec3 p = ray.origin + ray.direction * t;\t\t\n    \n    RaycastHit hit;\n    hit.point = p;\n    hit.normal = normal;\n    hit.det = t;\n    hit.type = t > 0. ? 1 : -1;\n    \n    return hit;\n    \n}\n    \nRaycastHit raycastScene(const Ray ray) {\n\n    RaycastHit sphere1 = intersectSphere(vec3(sin(iTime),0.,0.),.6,ray);\n    RaycastHit plane = intersectPlane(vec3(0., -.6, 0.), vec3(0.,1.,0.),ray);\n    \n    if(sphere1.type > -1) {\n     \n        return sphere1;\n        \n    }\n    \n    return plane;\n    \n}\n\nfloat random(float p) {\n  return fract(sin(p)*10000.);\n}\n\nfloat noise(vec4 p) {\n  return random(p.x + p.y + p.z + p.w) - .5;\n}\n\nvec3 lighting(const Ray ray, const RaycastHit hit) {\n \n    float diffuse = ambientLight;\n    vec3 l1 = light1 - hit.point;\n    \n    const int n = 30;\n    int h = 0;\n    \n    for(int s = 0; s < n; s++) {\n    \n        vec3 s1 = (light1 + noise(vec4(hit.point.xyz,iTime + float(s)))) - hit.point;\n    \n    \tRay shadow;\n    \tshadow.origin = hit.point + (s1 * 0.0001);\n    \tshadow.direction = s1;\n    \n    \tRaycastHit scene = raycastScene(shadow);\n        \n    \tif(scene.type < 0) {\n     \n        \th++;\n      \n    \t}\n        \n    }\n        \n    diffuse += max(dot(normalize(hit.normal),normalize(l1)),0.) * float(h) / float(n);\n    return vec3(diffuse);\n    //return vec3(scene.type + 1);\n    \n}\n\nvec3 specular(const Ray ray, const RaycastHit hit, float shininess) {\n    \n \tvec3 ret = vec3(0.,0.,0.);\n    vec3 l1 = light1 - hit.point;\n         \n    vec3 ref = reflect(ray.direction, hit.normal);\n   \tret += pow(max(dot(normalize(ref),normalize(l1)),0.),shininess);\n    \n    return ret;\n    \n}\n\nvec2 rot2D(vec2 p, float angle) {\n    \n    angle = radians(angle);\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    float x = p.x * c - p.y * s;\n    float y = p.x * s + p.y * c;\n    \n    return vec2(x,y);\n    \n}\n\nvec4 shadePlane(const Ray ray, const RaycastHit hit, vec4 clearColor) {\n \n    if(hit.type == 1) {\n     \n        float scale = 1.;\n        float u = hit.point.x;\n        float v = hit.point.z;\n        \n        //vec2 uv = rot2D(vec2(u,v),45. * sin(iTime));\n        //u = uv.x;\n        //v = uv.y;\n        \n        u = mod(u * scale, 1.);\n        v = mod(v * scale, 1.);\n        \n        vec3 diffuse = texture(iChannel1,vec2(u,v)).xyz;\n        \n        if((u > .5 || v > .5) && !(u > .5 && v > .5)) {\n         \n            diffuse /= 2.;\n            \n        }\n        \n   \t \tdiffuse *= lighting(ray, hit);\n        \n        //vec3 spec = vec3(1.);\n        //spec *= specular(ray, hit, 40.);\n\t\t//diffuse += spec;\n        \n    \treturn vec4(diffuse.xyz,1.);\n        \n    }\n    \n    return clearColor;\n    \n}\n\nvec4 shade(const Ray ray) {\n    \n   RaycastHit obj = raycastScene(ray);\n   vec4 clearColor = texture(iChannel0, ray.direction);\n   vec4 ret = clearColor;\n    \n   if(obj.type == 0) {\n     \n      Ray refRay;\n      refRay.origin = obj.point;\n      refRay.direction = reflect(ray.direction, obj.normal);\n       \n      vec3 diffuse = vec3(1.,0.,0.);\n      diffuse *= lighting(ray, obj);      \n      \n      vec3 spec = vec3(1.,1.,1.);\n      spec *= specular(ray, obj, 20.);\n      diffuse += spec;\n       \n      RaycastHit plane = raycastScene(refRay);\n      clearColor = texture(iChannel0, refRay.direction);\n       \n      vec3 reflection = shadePlane(ray, plane, clearColor).xyz;                 \n      ret = vec4(mix(diffuse, reflection,.3).xyz,1.);\n      \n       \n   } else if(obj.type == 1) {\n    \n       ret = shadePlane(ray, obj, clearColor);\n       \n   }\n     \n   return ret;\n        \n}\n\nvoid lightLogic() {\n\n    vec2 uv = iMouse.xy - iResolution.xy / 2.;\n    uv /= iResolution.y;\n    \n    if(iMouse.z > 0.) {\n\n        Ray ray;\n        ray.origin = vec3(0.,.35,-3.);\n        ray.direction = normalize(vec3(uv.x,uv.y-.3,1.));\n        \n        RaycastHit scene = raycastScene(ray);\n        \n        if(scene.type > -1) {\n         \n            light1 = scene.point;\n            return;\n            \n        }\n        \n    }\n     \n    light1 = vec3(-5., 5., -6.);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy - iResolution.xy / 2.;\n    uv /= iResolution.y;\n    \n    vec2 mouse = (iMouse.xy / iResolution.xy) * 2. - 1.;\n    \n    if(iMouse.z <= 0.) {\n     \n        mouse = vec2(0.,.6);\n        \n    }\n    \n\tRay ray = Ray(vec3(0.,.35,-3.),normalize(vec3(uv.x,uv.y-.3,1.)));\n   \tray.direction.yz = rot2D(ray.direction.yz,  90. * mouse.y);\n    ray.direction.xz = rot2D(ray.direction.xz, 35. * (1. - mouse.x));\n    \n    float s = sin(iTime);\n    //light1 = vec3(-5., 5., -6.);\n    \n    vec4 scene = shade(ray);\n    float flare = dot(ray.direction, normalize(light1));\n   \tscene += vec4(1.,1.,1.,.8) * pow(max(flare,0.),25.);\n    \n    lightLogic();\n    fragColor = scene; \n}\t\n\nvoid mainVR (out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir ) {\n \n    Ray ray;\n    ray.origin = fragRayOri - vec3(0.,0.,3.);\n    ray.direction = fragRayDir;\n    \n    fragColor = shade(ray);\n    \n    float flare = dot(ray.direction, normalize(light1));\n   \tfragColor += vec4(1.,1.,1.,.8) * pow(max(flare,0.),25.);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}