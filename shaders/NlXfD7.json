{
    "Shader": {
        "info": {
            "date": "1650956557",
            "description": "My attempt at making a semi realistic sky for cheap.",
            "flags": 0,
            "hasliked": 0,
            "id": "NlXfD7",
            "likes": 2,
            "name": "Phsicly inspired sky",
            "published": 3,
            "tags": [
                "3d",
                "sky",
                "atmosphere"
            ],
            "usePreview": 0,
            "username": "El_Sargo",
            "viewed": 355
        },
        "renderpass": [
            {
                "code": "const float Earth = 63.71;\nconst float AtRad = 64.01;\nconst float directScatterCoef = .055;\nconst float inDirectScatterCoef = .3;\nconst float sunCoef = .1;\nconst vec3 rgbScatter = vec3(1,2,4);\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nvec3 getSky(vec3 rd, vec3 pos, vec3 sun){\n//Distances, proportaional to the real world\n    float atDist = sphIntersect(pos, rd, vec3(0), AtRad).y;\n    float snDist = sphIntersect(pos, sun,vec3(0), AtRad).y-1.1;\n    \n    float rds = dot(sun, rd);\n    float ssc = (abs(rds)*0.5+0.5);\n    vec3 tra = normalize(sun-rd);\n    vec2 jab = vec2(\n    max(tra.x, max(tra.y, tra.z)),\n    min(tra.x, max(tra.y, tra.z))\n    );\n    float fla = pow(abs(sin(atan(jab.x,jab.y)*40.)), 100.)*.001;\n\n    vec3 light = vec3(smoothstep(0.999, .9999, rds))*2.;\n         light += atDist * (1.-abs(rd.y)) * ssc*0.2;\n         light += (1.-exp(-rgbScatter*atDist*inDirectScatterCoef*(atDist*5.*.5+.5)));\n         light *= exp(\n             -rgbScatter*\n             (atDist*directScatterCoef+snDist*sunCoef)\n         );\n         \n     return light;\n}\n\nmat2 rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nvec3 aces_tonemap(vec3 color){\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uc = (uv-0.5)*vec2(1,iResolution.y/iResolution.x);\n    vec3 rd = normalize(\n        vec3(uc, -.7)\n    );\n    rd.yz*=rot(.35);\n    \n    float m = iMouse.y / iResolution.y*5.+1.;\n    float f = iMouse.x / iResolution.x*10.+4.;\n\n    vec3 sun = vec3(0,0,1);\n    sun.yz *= rot(-m+.75);\n    sun.xz *= rot(-f+.75);\n    //sun.xz *=rot(1.5);\n\n\n    vec3 col;\n    vec3 ro = vec3(0,63.71002,0);\n    float EarthD = sphIntersect(ro, rd, vec3(0), Earth).x;\n    if (EarthD > -0.1){\n        vec3 p = ro+rd*EarthD;\n        vec3 nor = normalize(p);\n        vec3 ref = reflect(rd, nor);\n        float f = dot(rd,ref)*.25+.75;\n        col = getSky(ref, p, sun)*f*vec3(0.502,0.549,0.918);\n    } else\n        col = getSky(rd, ro, sun);\n\n    col = pow(col, vec3(2.4));\n    fragColor = vec4(aces_tonemap(col*2.), 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}