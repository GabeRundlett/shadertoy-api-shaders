{
    "Shader": {
        "info": {
            "date": "1550656209",
            "description": "Build and solve random \"perfect\" mazes (click upper right to restart, else automatic)",
            "flags": 32,
            "hasliked": 0,
            "id": "wdsXzH",
            "likes": 37,
            "name": "Maze Solver",
            "published": 3,
            "tags": [
                "maze"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 2391
        },
        "renderpass": [
            {
                "code": "// \"Maze Solver\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Build and solve random \"perfect\" mazes (click upper right to restart, else automatic).\n  Based on \"Maze Builder\"; solver fills in dead-end paths; path steps are then numbered.\n\n  More details:\n  \n  1) Wall placement: A perfect maze has a single solution; connected wall \n  sections are grown randomly starting at the outer boundary, with growth stopping \n  just before an intersection occurs. This guarantees tree-like connectivity \n  between all grid cells (no loops and no disconnected regions). The process (the \n  so-called ivy method) is trivially parallel. Additional non-random wall sections \n  can be used to increase path length.\n  \n  2) Dead-end path removal: A grid cell with three walls is a dead end. By \n  adding a fictitious wall to block off this cell the dead-end path becomes \n  shorter. Repeat until no dead ends remain; the result is the maze solution. This \n  is also done in parallel.\n  \n  3) Create the path: Once the cells in the path are known they must be numbered \n  sequentially to form a directional path. This requires marching along the path \n  between start and end cells, and is not easily done in parallel.\n*/\n\nvec3 HsvToRgb (vec3 c);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec4 Loadv4 (vec2 vId);\n\nvec2 canvas;\nfloat tCur;\nconst float pi = 3.14159;\n\nfloat WallDst (vec2 p, float a)\n{\n  p = 0.5 - ((a < 0.) ? vec2 (0.) : (fract ((a <= 1.) ? ((a == 0.) ? p : vec2 (- p.y, p.x)) :\n     ((a == 2.) ? - p : vec2 (p.y, - p.x)))));\n  return max (abs (p.x), abs (max (0., p.y)));\n}\n\nvec3 ShowScene (vec2 uv)\n{\n  vec4 cb;\n  vec3 col, gCol;\n  vec2 ut, utt, gSize, cEn, cEx, e, ee;\n  float ar, dw, nw, nStep, growLim, sFac, s, fPair, ph, dir, pathLen, spd;\n  gSize = Loadv4 (vec2 (0.)).zw;\n  growLim = Loadv4 (vec2 (1., 0.)).z;\n  nStep = Loadv4 (vec2 (1., 0.)).w;\n  cEn = Loadv4 (vec2 (2., 0.)).zw;\n  cEx = Loadv4 (vec2 (3., 0.)).zw;\n  pathLen = Loadv4 (vec2 (4., 0.)).z;\n  ut = uv * gSize + 0.001;\n  sFac = 2.5 * canvas.y / gSize.y;\n  gCol = vec3 (0.95, 0.95, 1.);\n  if (nStep < 2. * growLim) {\n    utt = fract (ut + 0.5);\n    gCol = mix (vec3 (0.5, 1., 0.5), gCol, smoothstep (1.5, 2.5, min (utt.x, utt.y) * sFac));\n  }\n  if (nStep < 2. * growLim) {\n    utt = floor (mod (ut - 0.5, gSize));\n    if (utt.x == cEn.x && utt.y == cEn.y || utt.x == cEx.x && utt.y == cEx.y)\n       gCol = mix (vec3 (0.3, 0.8, 0.3), gCol, smoothstep (14., 16.,\n          length (fract (ut + 0.5) - 0.5) * sFac));\n  }\n  utt = floor (ut);\n  ar = Loadv4 (utt).x;\n  dw = WallDst (ut, ar);\n  col = mix (vec3 (0.5, 0.5, 1.), gCol, smoothstep (4., 6., dw * sFac));\n  for (float ai = 0.; ai < 4.; ai ++) {\n    e = vec2 (0., 1.);\n    e = (ai < 2.) ? ((ai == 0.) ? e : e.yx) : ((ai == 2.) ? - e : - e.yx);\n    if (Loadv4 (utt - e).x == ai) dw = min (dw, WallDst (ut, mod (ai + 2., 4.)));\n  }\n  col = mix (vec3 (0.5, 0.5, 1.), gCol, smoothstep (4., 6., dw * sFac));\n  utt = fract (ut + 0.5) - 0.5;\n  nw = Loadv4 (floor (mod (ut - 0.5, gSize))).y;\n  if (nStep < 2. * growLim) {\n    if (nStep > growLim) col = mix (vec3 (0.7, 0.2, 0.2), col, \n       smoothstep (3., 5., max (abs (utt.x), abs (utt.y)) * sFac - nw));\n  } else if (nw > 0.) {\n    cb = mod (floor (nw / vec4 (1., 2., 4., 8.)), 2.);\n    if      (cb.x * cb.z > 0.) fPair = 0.;\n    else if (cb.y * cb.w > 0.) fPair = 1.;\n    else if (cb.x * cb.y > 0.) fPair = 2.;\n    else if (cb.y * cb.z > 0.) fPair = 3.;\n    else if (cb.z * cb.w > 0.) fPair = 4.;\n    else if (cb.w * cb.x > 0.) fPair = 5.;\n    if      (fPair == 0.) s = utt.x;\n    else if (fPair == 1.) s = utt.y;\n    else {\n      e = vec2 (0.5, -0.5);\n      if      (fPair == 2.) ee = e.xx;\n      else if (fPair == 3.) ee = e.xy;\n      else if (fPair == 4.) ee = e.yy;\n      else if (fPair == 5.) ee = e.yx;\n      utt -= ee;\n      s = length (utt) - 0.5;\n    }\n    s = abs (s) * sFac;\n    col = mix (vec3 (1., 1., 0.2), mix (vec3 (1., 0., 0.), col, smoothstep (13., 16., s)),\n       smoothstep (9., 12., s));\n    if (s < 12.) {\n      if (nw >= 32.) {\n        if (fPair > 1.) ph = -2. * atan (utt.y, - utt.x) / pi;\n        else ph = ((fPair == 0.) ? utt.y : utt.x) + 0.5;\n        dir = (mod (floor (nw / 16.), 2.) > 0.) ? -1. : 1.;\n        if (nStep >= 4. * growLim || pathLen > 0.) {\n          spd = 1.5;\n          ph += dir * (0.015 * s - spd * tCur);\n          col = HsvToRgb (vec3 (mod ((floor (nw / 32.) - spd * tCur) / max (pathLen / 4., 1.), 1.), 0.6, 1.));\n        }\n        col = mix (col, vec3 (0.3), SmoothBump (0.25, 0.75, 0.01, mod (ph, 1.))) *\n           (1. - smoothstep (10., 12., s));\n      }\n    }\n  }\n  utt = abs (ut - 0.5 * gSize) - 0.5 * gSize;\n  col = mix (col, vec3 (0.2, 0.2, 0.5), step (-0.45, max (utt.x, utt.y)));\n  if (pathLen == 0.) {\n    utt = Rot2D ((uv - 0.5) * vec2 (canvas.x / canvas.y, 1.), -2. * pi * mod (0.5 * tCur, 1.));\n    if (atan (utt.y, - utt.x) / pi < 0.7) col = mix (col, vec3 (0., 1., 0.),\n       0.2 * (1. - smoothstep (0.02, 0.03, abs (length (utt) - 0.3))));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  canvas = iResolution.xy;\n  tCur = iTime;\n  fragColor = vec4 (ShowScene (fragCoord / canvas), 1.);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Maze Solver\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat Hashff (float p);\nfloat Hashfv2 (vec2 p);\nvec4 Loadv4 (vec2 vId);\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  vec4 mPtr, fVal, cb, cbi, cbf;\n  vec2 canvas, iFrag, gSize, gSizeP, ev[4], cEn, cEx;\n  float tCur, nStep, growLim, growInt, ai, ar, nw, nwn, nb, h, dir, pathLen;\n  int kIn;\n  bool init;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  gSize = vec2 (16., 9.);\n  if (canvas.x >= 1600.) gSize *= 6.;\n  else if (canvas.x >= 800.) gSize *= 4.;\n  else if (canvas.x >= 400.) gSize *= 2.;\n  if (fragCoord.x >= gSize.x || fragCoord.y >= gSize.y) discard;\n  init = false;\n  if (iFrame <= 5 || mPtr.z > 0. && min (mPtr.x, mPtr.y) > 0.3) init = true;\n  else {\n    gSizeP = Loadv4 (vec2 (0.)).zw;\n    if (gSizeP.x != gSize.x || gSizeP.y != gSize.y) init = true;\n  }\n  iFrag = floor (fragCoord);\n  fVal = Loadv4 (iFrag);\n  ev[0] = vec2 (0., 1.);\n  ev[1] = vec2 (1., 0.);\n  ev[2] = vec2 (0., -1.);\n  ev[3] = vec2 (-1., 0.);\n  cbf = vec4 (1., 2., 4., 8.);\n  growInt = 1.;\n  if (init) {\n    growLim = floor (floor (2. * max (gSize.x, gSize.y)) / growInt) * growInt;\n  } else {\n    growLim = Loadv4 (vec2 (1., 0.)).z;\n    nStep = Loadv4 (vec2 (1., 0.)).w;\n    cEn = Loadv4 (vec2 (2., 0.)).zw;\n    cEx = Loadv4 (vec2 (3., 0.)).zw;\n    pathLen = Loadv4 (vec2 (4., 0.)).z;\n    init = (mod (nStep + 1., 2. * growLim + floor (2400. / growInt)) == 0.);\n  }\n  if (init) {\n    nStep = 0.;\n    pathLen = 0.;\n    ar = -1.;\n    cEn = vec2 (0., 1. + floor (4. * Hashff (tCur + 311.1)));\n    cEx = gSize - vec2 (2., 3. + floor (4. * Hashff (tCur + 411.1)));\n    if (iFrag.y == 0. && iFrag.x < gSize.x - 1.) ar = 1.;\n    else if (iFrag.x == gSize.x - 1. && iFrag.y < gSize.y - 1.) ar = 0.;\n    else if (iFrag.y == gSize.y - 1. && iFrag.x > 0.) ar = 3.;\n    else if (iFrag.x == 0. && iFrag.y > 0.) ar = 2.;\n    if (iFrag.x == cEn.x && iFrag.y > cEn.y) ar = 0.;\n    else if (iFrag.x > cEx.x && iFrag.y <= cEx.y) ar = 2.;\n    if (iFrag.y > 0. && iFrag.y < gSize.y - 1.) {\n      if (Hashff (tCur + 111.1) > 0.5 && iFrag.x == floor (gSize.x / 4.)) ar = 2.;\n      if (Hashff (tCur + 211.1) > 0.5 && iFrag.x == floor (3. * gSize.x / 4.)) ar = 0.;\n    }\n  } else {\n    ar = fVal.x;\n    if (mod (float (iFrame), growInt) == 0.) {\n      if (nStep < growLim && ar < 0.) {\n        dir = clamp (0.35 * (1. - 2. * Hashff (tCur + 13.1)), -0.22, 0.22);\n        h = Hashfv2 (iFrag + tCur + 1.1);\n        if (h < 0.25 - dir) ai = 0.;\n        else if (h < 0.5) ai = 1.;\n        else if (h < 0.75 - dir) ai = 2.;\n        else ai = 3.;\n        if (Hashfv2 (iFrag + tCur + 11.1) > 0.3) {\n          if (iFrag.y == 1.) {\n            if (ai == 2.) ai = 0.;\n          } else if (iFrag.y == gSize.y - 2.) {\n            if (ai == 0.) ai = 2.;\n          } else if (iFrag.x == 1.) {\n            if (ai == 3.) ai = 1.;\n          } else if (iFrag.x == gSize.x - 2.) {\n            if (ai == 1.) ai = 3.;\n          }\n        }\n        if (Loadv4 (iFrag + ((ai < 2.) ? ((ai == 0.) ? ev[0] : ev[1]) :\n           ((ai == 2.) ? ev[2] : ev[3]))).x >= 0.) ar = ai;\n      }\n      ++ nStep;\n    }\n  }\n  fVal.x = ar;\n  if (nStep < growLim) fVal.y = (iFrag.x <= gSize.x - 2. && iFrag.y <= gSize.y - 2.) ? -1. : 0.;\n  if (nStep > 2. * growLim) pathLen = floor (Loadv4 (cEx).y / 32.);\n  if (iFrag.x <= gSize.x - 2. && iFrag.y <= gSize.y - 2.) {\n    if (mod (float (iFrame), growInt) == 0.) {\n      cb = vec4 (0.);\n      ar = Loadv4 (iFrag).x;\n      cb.wz += vec2 ((ar == 0.) ? 1. : 0., (ar == 1.) ? 1. : 0.);\n      ar = Loadv4 (iFrag + ev[0]).x;\n      cb.wx += vec2 ((ar == 2.) ? 1. : 0., (ar == 1.) ? 1. : 0.);\n      ar = Loadv4 (iFrag + vec2 (1., 1.)).x;\n      cb.yx += vec2 ((ar == 2.) ? 1. : 0., (ar == 3.) ? 1. : 0.);\n      ar = Loadv4 (iFrag + ev[1]).x;\n      cb.yz += vec2 ((ar == 0.) ? 1. : 0., (ar == 3.) ? 1. : 0.);\n      nw = fVal.y;\n      if (nStep == growLim) {\n        nw = dot (cb, vec4 (1.));\n      } else if (nStep > growLim && nStep < 2. * growLim) {\n        if (nw < 3.) {\n          nb = 0.;\n          for (int k = 0; k < 4; k ++)\n             if ((cb[k] == 0.) && Loadv4 (mod (iFrag + ev[k], gSize)).y >= 3.) ++ nb;\n          if (nw + nb == 3.) nw = 4.;\n        } else nw = 4.;\n      } else if (nStep == 2. * growLim) {\n        if (nw < 3.) {\n          nw = 0.;\n          for (int k = 0; k < 4; k ++)\n             if ((cb[k] == 0.) && Loadv4 (mod (iFrag + ev[k], gSize)).y < 3.) nw += cbf[k];\n        } else nw = 0.;\n      } else if (nStep > 2. * growLim && nStep < 4. * growLim && pathLen == 0.) {\n        if (nw > 0. && nw < 32.) {\n          dir = 0.;\n          cbi = 1. / cbf;\n          cb = mod (floor (nw * cbi), 2.);\n          if (iFrag.x == cEn.x && iFrag.y == cEn.y) {\n            if (cb[2] > 0.) dir = 1.;\n            nw += 32.;\n          } else {\n            cbi = cbi.zwxy;\n            for (int k = 0; k < 4; k ++) {\n              if (nw < 32. && cb[k] > 0.) {\n                nwn = Loadv4 (mod (iFrag + ev[k], gSize)).y;\n                if ((nwn - 32.) * mod (floor (nwn * cbi[k]), 2.) > 0.) {\n                  nw += 32. * (floor (nwn / 32.) + 1.);\n                  kIn = k;\n                  break;\n                }\n              }\n            }\n            if (kIn == 0) {\n              if (cb[2] > 0. || cb[3] > 0.) dir = 1.;\n            } else if (kIn == 1) {\n              if (cb[3] > 0. || cb[0] > 0.) dir = 1.;\n            } else if (kIn == 2) {\n              if (cb[1] > 0.) dir = 1.;\n            } else if (kIn == 3) {\n              if (cb[2] > 0.) dir = 1.;\n            }\n          }\n          nw += 16. * (dir - mod (floor (nw / 16.), 2.));\n        }\n      }\n      fVal.y = nw;\n    }\n  }\n  if (iFrag.y == 0.) {\n    if      (iFrag.x == 0.) fVal.zw = gSize;\n    else if (iFrag.x == 1.) fVal.zw = vec2 (growLim, nStep);\n    else if (iFrag.x == 2.) fVal.zw = cEn;\n    else if (iFrag.x == 3.) fVal.zw = cEx;\n    else if (iFrag.x == 4.) fVal.z = pathLen;\n  }\n  fragColor = fVal;\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}