{
    "Shader": {
        "info": {
            "date": "1625703215",
            "description": ".Lot's of comments for this one.",
            "flags": 0,
            "hasliked": 0,
            "id": "slsSWH",
            "likes": 3,
            "name": "Hex Pattern y28",
            "published": 3,
            "tags": [
                "2d",
                "simple",
                "hexagon",
                "tiles"
            ],
            "usePreview": 0,
            "username": "Yusef28",
            "viewed": 297
        },
        "renderpass": [
            {
                "code": "/*\n\n*/\n\n\nfloat rnd(vec2 id){\n    return fract(sin(id.x*12.49 + id.y*78.99)*41235.32);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 u = 10.*fragCoord/iResolution.x;\n    \n    //the 30 60 90 triangle with sides 1, 2 and sqrt(3)\n    //sqrt(3) is 1.731: https://www.redblobgames.com/grids/hexagons/\n    vec2 s = vec2(1.,1.732);\n    \n    //we create two grids. Both have the dimentions of s.\n    //mod with s gives us the coordinates like fract does\n    vec2 a = mod(u,s)*2.-s;//stuff after mod just changes value not cell dimention\n    //floor of u/s gives us an id system that is strechted to the s dimentions\n    vec2 idA = floor(u/s);\n    //get a random value for each id for coloring if I wanted\n   // float A = rnd(idA);\n    \n    //we do the same again but with +s*0.5 so we move this system up\n    //diagonally by half the dimentions of s\n    vec2 b = mod(u+s*.5,s)*2.-s;//stuff after mod just changes value not cell dimention\n    vec2 idB = floor((u+s*.5)/s);\n    //I add +4 to give B some randomness\n   // float B = rnd(idB+4.);\n    \n    \n    //we take the lengths because a comparison for a given pixel\n    //between length (within a given grid rectangle) will tell us\n    //the coordinate system where the pixel is closest to 0.,0.\n    //this tells us then which system (and which hexagon) to use.\n    float la = length(a);\n    float lb = length(b);\n  //  float C = la < lb ? A*la : B*lb;\n    \n    //choose which hex system to use\n    u = la < lb ? a : b;\n    //we go a step further, get abs u so whatever we do\n    //in the top right quadrant will be mirrored in top left, bottom left,\n    //and bottom right\n    vec2 st = abs(u);\n    //what we do with this is get the dopt product.\n    //if you remove the max(st.x portion you get a diamond.\n    //This is percentage every pixel's vector (st) is aligned with\n    //the normalized dimention vector (s). and that vector being 1.,1.732\n    //is on a 60 degree angle already from the x axis. All these ratios\n    //act as distances since s is normalized, and that give us that diamond shape.\n    //on top of that max(st.x...) cut's things off whenever x > than the dot\n    //dot product. That gives us an even hex shape.\n    //(in the chosen system)\n    float q = max(st.x, dot(st,normalize(s)));\n    \n\n    //Then I jut add a color pallette\n\tfragColor = vec4(0.5+0.5*cos(vec3(1.,2.,4.)/10. + floor(q*8.) ), 1.);//vec4(1.0-floor(C*8.)/8.*.75);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}