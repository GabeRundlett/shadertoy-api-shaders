{
    "Shader": {
        "info": {
            "date": "1475851504",
            "description": "My first attempt at 3D graphics programming. Made for my first quarter project in my senior year high school programming class. Amateur programming all around; feedback much appreciated.",
            "flags": 0,
            "hasliked": 0,
            "id": "Mly3zc",
            "likes": 1,
            "name": "Stretchy Cuboid Lightup",
            "published": 3,
            "tags": [
                "raycasting",
                "beginner",
                "colorful",
                "cuboid"
            ],
            "usePreview": 0,
            "username": "jfuchs",
            "viewed": 714
        },
        "renderpass": [
            {
                "code": "//Made by Jonathan Fuchs, October 7th 2016\n//No copyright, so feel free to use this code wherever. Even if I don't expect anyone to.\n//Sorry if I got a bit silly with the comments.\n\n#define T iTime\n\nvec4 quatMultiply(vec4 q1, vec4 q2){\n    return vec4(q1.x*q2.x - dot(q1.yzw, q2.yzw), q1.yzw*q2.x + q2.yzw*q1.x + cross(q1.yzw, q2.yzw));\n}\n\nvec3 quatRotate(vec3 p, vec4 q){\n    return quatMultiply(quatMultiply(q, vec4(0, p)),vec4(q.x, -q.yzw)).yzw;\n}\n\n//Quaternion maths courtesy of http://www.3dgep.com/understanding-quaternions/\n\nvoid initPoints(out vec3[4] points, vec3 size, vec4 orientation){\n    //Four points are needed to define a cuboid.\n    points[0] = -size;\n    points[1] = vec3(size.x, -size.yz);\n    points[2] = vec3(-size.x, size.y, -size.z);\n    points[3] = vec3(-size.xy, size.z);\n    for(int i = 0; i < 4; i++){\n        points[i] = quatRotate(points[i], orientation);\n    }\n}\n\nvoid initFaces(out vec4[6] faces, vec3[4] points){\n    //Faces are planes defined by <a, b, c, d>, where ax + by + cz + d = 0.\n    //The boundaries of the faces are determined by the points.\n    vec3 normal = cross(points[1] - points[0], points[2] - points[0]);\n    faces[0] = vec4(normal, -dot(normal, points[0]));\n    faces[3] = vec4(faces[0].xyz, faces[0].w - dot(normal, points[3] - points[0]));\n    normal = cross(points[2] - points[0], points[3] - points[0]); \n    faces[1] = vec4(normal, -dot(normal, points[0]));\n    faces[4] = vec4(faces[1].xyz, faces[1].w - dot(normal, points[1] - points[0]));\n    normal = cross(points[3] - points[0], points[1] - points[0]); \n    faces[2] = vec4(normal, -dot(normal, points[0]));;\n    faces[5] = vec4(faces[2].xyz, faces[2].w - dot(normal, points[2] - points[0]));\n}\n\nvec4 background(){\n    //Lame shifting color background to fill up the rest of the screen.\n    vec4 backColor = vec4(1,1,1,1);\n    float t15 = mod(T, 15.0);\n    float t5 = mod(T, 5.0);\n    vec3 colorShift = vec3(cos(0.314*t5), sin(0.314*t5), 0);\n    if(t15 < 5.0) backColor -= colorShift.xyzz;\n    else if(t15 < 10.0) backColor -= colorShift.zxyz;\n    else backColor -= colorShift.yzxz;\n    backColor.xyz /= 4.0;\n    return backColor;\n}\n\nvec4 castRay(vec3 dir, vec3 points[4], vec4 faces[6], vec4 colors[6]){\n    //I opted for plain raycasting instead of raymarching because I thought it would improve perfomance.\n    //But I'm a terrible graphics programmer, so that didn't turn out to be the case. Oh well.\n    \n    vec3 u[6]; vec3 v[6];\n    //The components of the faces. There has to be a better way to do this...\n    u[0] = points[1] - points[0]; v[0] = points[2] - points[0];\n    u[1] = points[2] - points[0]; v[1] = points[3] - points[0];\n    u[2] = points[3] - points[0]; v[2] = points[1] - points[0];\n    u[3] = points[0] - points[1]; v[3] = points[0] - points[2];\n    u[4] = points[0] - points[2]; v[4] = points[0] - points[3]; \n    u[5] = points[0] - points[3]; v[5] = points[0] - points[1];\n    \n    const vec3 camera = vec3(0, 0, 5);\n    float minT = 1e20;\n    int bestFace = -1;\n    float bestA;\n    float bestB;\n    \n    for(int i = 0; i < 6; i++){ //Iterating over the faces.\n        float t = -(faces[i].w + dot(faces[i].xyz, camera))/(dot(faces[i].xyz, dir));\n        //The distance to the point of intersection with a face. I guess the formula works?\n        if(t < minT && t > 0.0){\n        \tvec3 p = camera + dir*t; //The actual point of intersection.\n        \tif(i < 3) p = p - points[0];\n        \telse p = p + points[0];\n            //...And adjusting it so that the following formulas will work.\n        \tfloat a = (p.x*v[i].y - p.y*v[i].x)/(u[i].x*v[i].y - u[i].y*v[i].x);\n        \tfloat b = (p.x*u[i].y - p.y*u[i].x)/(u[i].y*v[i].x - u[i].x*v[i].y);\n            //a and b are the distances along the face components to the point.\n            //I would use matrices here, but I don't know any linear algebra :(\n            if(a >= 0.0 && a < 1.0 && b >= 0.0 && b < 1.0){\n                //Checking to see if the point of intersection is actually on the face.\n                minT = t;\n            \tbestFace = i;\n                bestA = a;\n                bestB = b;\n            }\n        }      \n    }\n    //What do you mean, non-constant array indices aren't allowed? Guess there's this workaround...\n    for(int i = 0; i < 6; i++){\n        if(bestFace == i) return texture(iChannel0, vec2(bestA, bestB)) * colors[i];\n        //Finally returning the point on the face intersecting the ray.\n    }\n    return background();\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 size = vec3(1.0, 1.0, 1.0);\n    vec4 colors[6];\n\tcolors[0] = vec4(0.8,0.5,0.5,1); colors[1] = vec4(0.5,0.8,0.5,1); colors[2] = vec4(0.5,0.5,0.8,1);\n\tcolors[3] = vec4(0.5,0.8,0.8,1); colors[4] = vec4(0.8,0.5,0.8,1); colors[5] = vec4(0.8,0.8,0.5,1);\n    \n    \n    float t3 = mod(T, 3.0);\n    float t1 = mod(T, 1.0);\n\tvec2 deform = vec2(sin(3.14*t1)/2.0, -sin(3.14*t1)/3.0);\n    vec3 lightup = vec3(sin(3.14*t1)/5.0, -sin(3.14*t1)/2.0, 0);\n    //Performing the stretchy and light-up effects.\n    if(t3 < 1.0){\n        size += deform.yyx;\n        colors[0] += lightup.xyyz;\n        colors[3] += lightup.yxxz;\n    }\n    else if(t3 < 2.0){\n        size += deform.xyy;\n        colors[1] += lightup.yxyz;\n        colors[4] += lightup.xyxz;\n    }\n    else{\n        size += deform.yxy;\n        colors[2] += lightup.yyxz;\n        colors[5] += lightup.xxyz;\n    }\n    \n    float angle = T;\n    vec3 rotAxis = normalize(vec3(cos(T/3.0),sin(T/3.0),-sin(T/3.0))); //Chaotic rotation\n    vec4 rotQuat = vec4(cos(angle), sin(angle)*rotAxis);\n    \n    vec3 points[4];\n\tinitPoints(points, size, rotQuat); //Initializing points...\n    vec4 faces[6];\n    initFaces(faces, points); //Initializing faces...\n    vec2 fov = fragCoord.xy / iResolution.y;\n    fov = fov - vec2(iResolution.x/iResolution.y/2.0, 0.5); //Calculating field of view...\n    fragColor = castRay(vec3(fov, -1), points, faces, colors); //Done! :D\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}