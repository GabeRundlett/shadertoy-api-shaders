{
    "Shader": {
        "info": {
            "date": "1593592389",
            "description": "the 3D graph of the function:y=cos(x)*sin(z)",
            "flags": 0,
            "hasliked": 0,
            "id": "Wt2czR",
            "likes": 3,
            "name": "y=cos(x)*sin(z)",
            "published": 3,
            "tags": [
                "math",
                "graph",
                "function"
            ],
            "usePreview": 0,
            "username": "changjiu",
            "viewed": 277
        },
        "renderpass": [
            {
                "code": "\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 50.0;\nconst float EPSILON = 0.0001;\n\nvec3 rayDir;\n \nvec3 cameraPosition = vec3(0.0, 0.0, 5.0);\nvec3 cameraDir = vec3(0.0, 0.0, -1.0);\nvec3 cameraUp = vec3(0.0, 1.0, 0.0);\n\nmat4 getPerspectiveProjectMatrix(float fovy, float aspect, float near, float far){\n    mat4 projectMatrix;\n    \n\tfloat rd, s, ct;\n\n\n  \tfovy = 3.1415926 * fovy / 180.0 / 2.0;\n  \ts = sin(fovy);\n\n\n  \trd = 1.0 / (far - near);\n  \tct = cos(fovy) / s;\n\n\n      projectMatrix[0][0]  = ct / aspect;\n      projectMatrix[0][1]  = 0.0;\n      projectMatrix[0][2]  = 0.0;\n      projectMatrix[0][3]  = 0.0;\n\n      projectMatrix[1][0]  = 0.0;\n      projectMatrix[1][1]  = ct;\n      projectMatrix[1][2]  = 0.0;\n      projectMatrix[1][3]  = 0.0;\n\n      projectMatrix[2][0]  = 0.0;\n      projectMatrix[2][1]  = 0.0;\n      projectMatrix[2][2]  = -(far + near) * rd;\n      projectMatrix[2][3]  = -1.0;\n\n      projectMatrix[3][0]  = 0.0;\n      projectMatrix[3][1]  = 0.0;\n      projectMatrix[3][2]  = -2.0 * near * far * rd;\n      projectMatrix[3][3]  = 0.0;\n\n      return projectMatrix;\n\n}\n\nmat4 matTranslate(mat4 e, float x, float y, float z) {\n    \n  e[3][0] += e[0][0] * x + e[1][0] * y + e[2][0] * z;\n  e[3][1] += e[0][1] * x + e[1][1] * y + e[2][1] * z;\n  e[3][2] += e[0][2] * x + e[1][2] * y + e[2][2] * z;\n  e[3][3] += e[0][3] * x + e[1][3] * y + e[2][3] * z;\n    \n  return e;\n}\n\nmat4 getViewMatrix(float eyeX, float eyeY, float eyeZ, float centerX, float centerY, float centerZ, float upX, float upY, float upZ){\n    mat4 viewMatrix;\n    \n\tfloat fx, fy, fz, rlf, sx, sy, sz, rls, ux, uy, uz;\n\n\n  \t  fx = centerX - eyeX;\n      fy = centerY - eyeY;\n      fz = centerZ - eyeZ;\n\n      // Normalize f.\n      rlf = 1.0 / sqrt(fx*fx + fy*fy + fz*fz);\n      fx *= rlf;\n      fy *= rlf;\n      fz *= rlf;\n\n      // Calculate cross product of f and up.\n      sx = fy * upZ - fz * upY;\n      sy = fz * upX - fx * upZ;\n      sz = fx * upY - fy * upX;\n\n      // Normalize s.\n      rls = 1.0 / sqrt(sx*sx + sy*sy + sz*sz);\n      sx *= rls;\n      sy *= rls;\n      sz *= rls;\n\n      // Calculate cross product of s and f.\n      ux = sy * fz - sz * fy;\n      uy = sz * fx - sx * fz;\n      uz = sx * fy - sy * fx;\n\n\n      viewMatrix[0][0]  = sx;\n      viewMatrix[0][1]  = ux;\n      viewMatrix[0][2]  = -fx;\n      viewMatrix[0][3]  = 0.0;\n\n      viewMatrix[1][0]  = sy;\n      viewMatrix[1][1]  = uy;\n      viewMatrix[1][2]  = -fy;\n      viewMatrix[1][3]  = 0.0;\n\n      viewMatrix[2][0]  = sz;\n      viewMatrix[2][1]  = uz;\n      viewMatrix[2][2]  = -fz;\n      viewMatrix[2][3]  = 0.0;\n\n      viewMatrix[3][0]  = 0.0;\n      viewMatrix[3][1]  = 0.0;\n      viewMatrix[3][2]  = 0.0;\n      viewMatrix[3][3]  = 1.0;\n    \n      viewMatrix = matTranslate(viewMatrix, -eyeX, -eyeY, -eyeZ);\n\n      return viewMatrix;\n\n}\n\nvec3 applyMatrix4(vec3 v3, mat4 m4){\n\t\tfloat x = v3.x, y = v3.y, z = v3.z;\n\t\tfloat e[16];\n    \te[0] = m4[0][0];\n        e[1] = m4[0][1];\n        e[2] = m4[0][2];\n        e[3] = m4[0][3];\n    \n    \te[4] = m4[1][0];\n        e[5] = m4[1][1];\n        e[6] = m4[1][2];\n        e[7] = m4[1][3];\n    \n        e[8] = m4[2][0];\n        e[9] = m4[2][1];\n        e[10] = m4[2][2];\n        e[11] = m4[2][3];\n    \n    \te[12] = m4[3][0];\n        e[13] = m4[3][1];\n        e[14] = m4[3][2];\n        e[15] = m4[3][3];\n\n\t\tfloat w = 1. / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );\n\n\t\tv3.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;\n\t\tv3.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;\n\t\tv3.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;\n\n\t\treturn v3;\n}\n\nmat4 arrayToM4(float e[16]){\n    mat4 m4;\n    \n    m4[0][0]=e[0] ;\nm4[0][1]=e[1] ;\nm4[0][2]=e[2] ;\nm4[0][3]=e[3] ;\nm4[1][0]=e[4] ;\nm4[1][1]=e[5] ;\nm4[1][2]=e[6] ;\nm4[1][3]=e[7] ;\nm4[2][0]=e[8] ;\nm4[2][1]=e[9] ;\n m4[2][2]=e[10];\n m4[2][3]=e[11];\n m4[3][0]=e[12];\n m4[3][1]=e[13];\n m4[3][2]=e[14];\n m4[3][3]=e[15];\n    \n\treturn m4;\n}\n\nvec3 getCameraPosition(){\n\tvec3 cameraPosition;\n    cameraPosition.x = sin(0.5*iTime)*10.0;\n    cameraPosition.y = (sin(iTime)+1.0)*2.0;\n    cameraPosition.z = cos(0.5*iTime)*10.0;\n    \n    if(iMouse.z>0.){\n        float theta = -iMouse.x/iResolution.x*3.14159*2.0;\n        float y = 20.-iMouse.y/iResolution.y*20.0;\n        cameraPosition.x = sin(theta)*10.0;\n        cameraPosition.y = y;\n        cameraPosition.z = cos(theta)*10.0;\n    }\n    \n  \n    \n\treturn cameraPosition;\n}\n\nvec3 unproject(vec3 pointScreen){\n    \n    cameraPosition = getCameraPosition();\n\n    mat4 viewMatrix = getViewMatrix(cameraPosition.x, cameraPosition.y, cameraPosition.z, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);\n\n    mat4 projectMatrix  = getPerspectiveProjectMatrix(45.0, iResolution.x/iResolution.y, 1.0, 100.0);\n    \n    mat4 vpMatrix = projectMatrix * viewMatrix;\n    \n    mat4 VPmatrixInverse = inverse(vpMatrix);\n    \n\tvec3 pointV3 = applyMatrix4(pointScreen, VPmatrixInverse);\n\n    return pointV3;\n}\n\nvec3 getPointV3ByFragCoord(vec2 coord){\n    \n    vec3 pointScreen = vec3(coord.x, coord.y, 0.5);\n\tvec3 pointV3 = unproject(pointScreen);\n\n    return pointV3;\n}\n\nvec3 getRayDirByCoord(vec2 coord){\n\tvec3 pointV3 = getPointV3ByFragCoord(coord);\n    vec3 ray = pointV3 - cameraPosition;\n    return normalize(ray);\n}\n\n\nfloat funcSDF(vec3 p) {\n    \n    return p.y-cos(p.x)*sin(p.z);\n}\n\nfloat sceneSDF(vec3 p) {\n    //To prevent artefact, *0.8\n    float minDis2 = funcSDF(p)*0.8;\n    return minDis2;\n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n            \nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(10.0,5.0,3.0);\n    vec3 light1Intensity = vec3(1., 1., 1.);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 cood = vec2(( fragCoord.x / iResolution.x ) * 2. - 1., ( fragCoord.y / iResolution.y ) * 2. - 1.);\n    rayDir = getRayDirByCoord(cood);\n    \n    float dist = shortestDistanceToSurface(cameraPosition, rayDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        fragColor = vec4(0.1, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    vec3 p = cameraPosition + dist * rayDir;\n    \n    vec3 K_a = vec3(0.1, 0.1, 0.1);\n    vec3 K_d = vec3(0.3, 0.3, 0.3);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 1.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, cameraPosition);\n    \n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}