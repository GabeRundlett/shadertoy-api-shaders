{
    "Shader": {
        "info": {
            "date": "1637637825",
            "description": "it's fancy plaid, you dolt!",
            "flags": 0,
            "hasliked": 0,
            "id": "stVGDh",
            "likes": 2,
            "name": "eindacor_dynamic_plaid",
            "published": 3,
            "tags": [
                "plaid"
            ],
            "usePreview": 0,
            "username": "Eindacor_DS",
            "viewed": 170
        },
        "renderpass": [
            {
                "code": "\n#define PI 3.1415926\n#define ANTI_ALIAS .005\n\n\n// from https://www.shadertoy.com/view/4djSRW\nfloat hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat getNormalizedNonPeriodic(float seed) {\n    return (sin(2. * seed) + sin(PI * seed)+ 2.) / 4.;\n}\n\nfloat getNonPeriodic(float seed) {\n    return sin(2. * seed) + sin(PI * seed);\n}\n\nmat2x2 createRotationMatrix(float rotation) {\n    return mat2x2(\n        cos(rotation), -sin(rotation),\n        sin(rotation), cos(rotation)\n    );\n}\n\nvec4 getColorBlend(float timeScale, vec2 uv, float xHash, float xHashAA, float yHash, float yHashAA, float xBlend, float yBlend) {\n    vec2 xyFirst = vec2(\n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + xHash) + xHash), \n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + yHash) + yHash));\n    \n    vec2 xySecond = vec2(\n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + xHash) + xHash), \n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + yHash) + yHash));\n        \n    vec2 xyColor = xyFirst * xySecond;\n        \n    vec2 xAyFirst = vec2(\n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + xHashAA) + xHashAA), \n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + yHash) + yHash));\n        \n    vec2 xAySecond = vec2(\n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + xHashAA) + xHashAA), \n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + yHash) + yHash));\n        \n    vec2 xAyColor = xAyFirst * xAySecond;\n        \n    vec2 xyAFirst = vec2(\n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + xHash) + xHash), \n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + yHashAA) + yHashAA));\n    \n    vec2 xyASecond = vec2(\n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + xHash) + xHash), \n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + yHashAA) + yHashAA));\n        \n    vec2 xyAColor = xyAFirst * xyASecond;\n        \n    vec2 xAyAFirst = vec2(\n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + xHashAA) + xHashAA), \n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + yHashAA) + yHashAA));\n    \n    vec2 xAyASecond = vec2(\n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + xHashAA) + xHashAA), \n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + yHashAA) + yHashAA));\n        \n      \n    vec2 xAyAColor = xAyAFirst * xAyASecond;\n\n    vec2 xLower = mix(xAyAColor, xyAColor, xBlend);\n    vec2 xUpper = mix(xAyColor, xyColor, xBlend);\n    \n    vec2 finalBlend = mix(xLower, xUpper, yBlend);\n    \n    return vec4(finalBlend.x, finalBlend.y, getNormalizedNonPeriodic(iTime * timeScale + 200.), 1.);\n}\n\nvec4 getBWBlend(float timeScale, vec2 uv, float xHash, float xHashAA, float yHash, float yHashAA, float xBlend, float yBlend) {\n    vec2 xyFirst = vec2(\n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + xHash) + xHash), \n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + yHash) + yHash));\n    \n    vec2 xySecond = vec2(\n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + xHash) + xHash), \n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + yHash) + yHash));\n        \n    vec2 xyColor = xyFirst * xySecond;\n        \n    vec2 xAyFirst = vec2(\n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + xHashAA) + xHashAA), \n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + yHash) + yHash));\n        \n    vec2 xAySecond = vec2(\n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + xHashAA) + xHashAA), \n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + yHash) + yHash));\n        \n    vec2 xAyColor = xAyFirst * xAySecond;\n        \n    vec2 xyAFirst = vec2(\n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + xHash) + xHash), \n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + yHashAA) + yHashAA));\n    \n    vec2 xyASecond = vec2(\n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + xHash) + xHash), \n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + yHashAA) + yHashAA));\n        \n    vec2 xyAColor = xyAFirst * xyASecond;\n        \n    vec2 xAyAFirst = vec2(\n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + xHashAA) + xHashAA), \n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + yHashAA) + yHashAA));\n    \n    vec2 xAyASecond = vec2(\n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + xHashAA) + xHashAA), \n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + yHashAA) + yHashAA));\n        \n      \n    vec2 xAyAColor = xAyAFirst * xAyASecond;\n\n    vec2 xLower = mix(xAyAColor, xyAColor, xBlend);\n    vec2 xUpper = mix(xAyColor, xyColor, xBlend);\n    \n    vec2 finalBlend = mix(xLower, xUpper, yBlend);\n    \n    vec4 blended = vec4(finalBlend.x, finalBlend.y, getNormalizedNonPeriodic(iTime * timeScale + 200.), 1.);\n    return vec4(vec3(blended.x * blended.y), 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float aspectRatio = iResolution.x / iResolution.y;\n    \n    uv.x *= aspectRatio;\n    \n    mat2x2 rotationMatrix = createRotationMatrix(PI / 4.);\n    \n    uv.y += getNonPeriodic(iTime * .1 + uv.x) * .1 + 100.;\n    uv = uv * rotationMatrix;\n       \n    float gridSize = .01;\n\n    float xFloor = floor(uv.x / gridSize);\n    float xHash = hash(vec2(xFloor));\n    float xHashAA = hash(vec2(xFloor - 1.));\n    float xBlend = smoothstep(0., ANTI_ALIAS / gridSize, fract(uv.x / gridSize));\n    \n    float yFloor = floor(uv.y / gridSize);\n    float yHash = hash(vec2(yFloor));\n    float yHashAA = hash(vec2(yFloor - 1.));\n    float yBlend = smoothstep(0., ANTI_ALIAS / gridSize, fract(uv.y / gridSize));\n    \n    float timeScale = .15;\n    \n    fragColor = getColorBlend(timeScale, uv, xHash, xHashAA, yHash, yHashAA, xBlend, yBlend);\n    \n    vec2 trueUv = fragCoord/iResolution.xy;\n    if (iMouse.z > 1.) {\n    \n        float cursorDist = distance(vec2(trueUv.x * aspectRatio, trueUv.y), vec2(iMouse.x / iResolution.x * aspectRatio, iMouse.y / iResolution.y));\n        \n        float spotlightRadius = .4;\n        float spotlightFade = spotlightRadius * .5;\n        float cursorVal = smoothstep(spotlightRadius - spotlightFade, spotlightRadius + spotlightFade, cursorDist);\n             \n        vec4 spotlightColor = getBWBlend(timeScale, uv, xHash, xHashAA, yHash, yHashAA, xBlend, yBlend) * vec4(1.0, 0.5, 0., 1.);\n    \n        fragColor = mix(spotlightColor, fragColor, cursorVal * cursorVal);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}