{
    "Shader": {
        "info": {
            "date": "1694574459",
            "description": "Discoteq 3\nadded flim ( https://www.shadertoy.com/view/dd2yDz )",
            "flags": 32,
            "hasliked": 0,
            "id": "ctjfDc",
            "likes": 6,
            "name": "Fork Discoteq 3 (+ flim)",
            "published": 3,
            "tags": [
                "blur",
                "lines",
                "smoothstep",
                "sinusoidal",
                "beautiful",
                "discoteque"
            ],
            "usePreview": 0,
            "username": "beans_please",
            "viewed": 334
        },
        "renderpass": [
            {
                "code": "#define S smoothstep\n#define R iResolution.xy\n#define T iTime\n\nfloat c(vec2 u) { return  S( 5./R.y, 0., abs(length(u) - .25)); }\nfloat t (float s) { return .5 + sin(T * s) * .5; }\nmat2 r (float a) { return mat2(cos(a), sin(-a), sin(a), cos(a)); }\n\nvec3 render(vec2 I)\n{\n    vec2 u =(I-.5*R)/R.y*r(T*.3);\n    vec4 O = vec4(0);\n    for (float i = 0.; i < 1.; i += 1./50.) {\n        float n = cnoise(vec3(u * 2.5  + i * .3, .9 * T + i * 1.2));\n        float l = c(u + n * .14);\n        vec3 c = mix(vec3(t(.4), t(.8), t(3.)), vec3(t(.8), t(1.2), t(.5)), i);\n        O += vec4(l * c * .3, i);\n    }\n    return O.rgb;\n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    // Linear RGB\n    vec3 col = pow(render(I), vec3(2.2));\n\n    // Saturation\n    col = mix(vec3(dot(col, vec3(1. / 3.))), col, 1.2);\n\n    // flim\n    col = flim_transform(col, -.5, iChannel0);\n\n    // Output\n    O = vec4(col, 1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n//\tClassic Perlin 3D Noise \n//\tby Stefan Gustavson\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\n/***********************************\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  sRGB 2.2\n\nShadertoy Unit:\n  Common\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n  The common unit contains most of the code, and\n  receives gamut extension matrices from a buffer.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n***********************************/\n\n// Parameters\n\nconst float flim_pre_exposure = 4.3;\nconst vec3 flim_pre_formation_filter = vec3(1.0);\nconst float flim_pre_formation_filter_strength = 0.0;\n\nconst float flim_extended_gamut_red_scale = 1.05;\nconst float flim_extended_gamut_green_scale = 1.12;\nconst float flim_extended_gamut_blue_scale = 1.045;\nconst float flim_extended_gamut_red_rot = 0.5;\nconst float flim_extended_gamut_green_rot = 2.0;\nconst float flim_extended_gamut_blue_rot = 0.1;\nconst float flim_extended_gamut_red_mul = 1.0;\nconst float flim_extended_gamut_green_mul = 1.0;\nconst float flim_extended_gamut_blue_mul = 1.0;\n\nconst float flim_sigmoid_log2_min = -10.0;\nconst float flim_sigmoid_log2_max = 22.0;\nconst float flim_sigmoid_toe_x = 0.44;\nconst float flim_sigmoid_toe_y = 0.28;\nconst float flim_sigmoid_shoulder_x = 0.591;\nconst float flim_sigmoid_shoulder_y = 0.779;\n\nconst float flim_negative_film_exposure = 6.0;\nconst float flim_negative_film_density = 5.0;\n\nconst vec3 flim_print_backlight = vec3(1.0);\nconst float flim_print_film_exposure = 6.0;\nconst float flim_print_film_density = 27.5;\n\nconst float flim_black_point = -1.0; // -1 = auto\nconst vec3 flim_post_formation_filter = vec3(1.0);\nconst float flim_post_formation_filter_strength = 0.0;\nconst float flim_midtone_saturation = 1.02;\n\n// -------------------------------\n\nfloat wrap(float inp, float start, float end)\n{\n    return start + mod(inp - start, end - start);\n}\n\nfloat lerp(float a, float b, float t)\n{\n    return a + t * (b - a);\n}\n\nvec3 lerp(vec3 a, vec3 b, float t)\n{\n    return a + t * (b - a);\n}\n\nfloat map_range(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start);\n}\n\nfloat map_range_clamp(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    float t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0);\n    float v = out_start + t * (out_end - out_start);\n    return v;\n}\n\nvec3 blender_rgb_to_hsv(vec3 rgb)\n{\n    float cmax, cmin, h, s, v, cdelta;\n    vec3 c;\n\n    cmax = max(rgb[0], max(rgb[1], rgb[2]));\n    cmin = min(rgb[0], min(rgb[1], rgb[2]));\n    cdelta = cmax - cmin;\n\n    v = cmax;\n    if (cmax != 0.0)\n    {\n        s = cdelta / cmax;\n    }\n    else\n    {\n        s = 0.0;\n        h = 0.0;\n    }\n\n    if (s == 0.0)\n    {\n        h = 0.0;\n    }\n    else\n    {\n        c = (vec3(cmax) - rgb.xyz) / cdelta;\n\n        if (rgb.x == cmax)\n        {\n            h = c[2] - c[1];\n        }\n        else if (rgb.y == cmax)\n        {\n            h = 2.0 + c[0] - c[2];\n        }\n        else\n        {\n            h = 4.0 + c[1] - c[0];\n        }\n\n        h /= 6.0;\n\n        if (h < 0.0)\n        {\n            h += 1.0;\n        }\n    }\n\n    return vec3(h, s, v);\n}\n\nvec3 blender_hsv_to_rgb(vec3 hsv)\n{\n    float i, f, p, q, t, h, s, v;\n    vec3 rgb;\n\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n\n    if (s == 0.0)\n    {\n        rgb = vec3(v, v, v);\n    }\n    else\n    {\n        if (h == 1.0)\n        {\n            h = 0.0;\n        }\n\n        h *= 6.0;\n        i = floor(h);\n        f = h - i;\n        rgb = vec3(f, f, f);\n        p = v * (1.0 - s);\n        q = v * (1.0 - (s * f));\n        t = v * (1.0 - (s * (1.0 - f)));\n\n        if (i == 0.0)\n        {\n            rgb = vec3(v, t, p);\n        }\n        else if (i == 1.0)\n        {\n            rgb = vec3(q, v, p);\n        }\n        else if (i == 2.0)\n        {\n            rgb = vec3(p, v, t);\n        }\n        else if (i == 3.0)\n        {\n            rgb = vec3(p, q, v);\n        }\n        else if (i == 4.0)\n        {\n            rgb = vec3(t, p, v);\n        }\n        else\n        {\n            rgb = vec3(v, p, q);\n        }\n    }\n\n    return rgb;\n}\n\nvec3 blender_hue_sat(vec3 col, float hue, float sat, float value)\n{\n    vec3 hsv = blender_rgb_to_hsv(col);\n\n    hsv[0] = fract(hsv[0] + hue + 0.5);\n    hsv[1] = clamp(hsv[1] * sat, 0.0, 1.0);\n    hsv[2] = hsv[2] * value;\n\n    return blender_hsv_to_rgb(hsv);\n}\n\nfloat rgb_avg(vec3 inp)\n{\n    return (inp.x + inp.y + inp.z) / 3.0;\n}\n\nfloat rgb_sum(vec3 inp)\n{\n    return inp.x + inp.y + inp.z;\n}\n\nfloat rgb_max(vec3 inp)\n{\n    return max(max(inp.x, inp.y), inp.z);\n}\n\nfloat rgb_min(vec3 inp)\n{\n    return min(min(inp.x, inp.y), inp.z);\n}\n\nvec3 rgb_uniform_offset(vec3 inp, float black_point, float white_point)\n{\n    float mono = rgb_avg(inp);\n    float mono2 = map_range_clamp(mono, black_point / 1000.0, 1.0 - (white_point / 1000.0), 0.0, 1.0);\n    return inp * (mono2 / mono);\n}\n\nvec3 rgb_sweep(float hue)\n{\n    hue = wrap(hue * 360.0, 0.0, 360.0);\n\n    vec3 col = vec3(1, 0, 0);\n    col = mix(col, vec3(1, 1, 0), map_range_clamp(hue, 0.0, 60.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 1, 0), map_range_clamp(hue, 60.0, 120.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 1, 1), map_range_clamp(hue, 120.0, 180.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 0, 1), map_range_clamp(hue, 180.0, 240.0, 0.0, 1.0));\n    col = mix(col, vec3(1, 0, 1), map_range_clamp(hue, 240.0, 300.0, 0.0, 1.0));\n    col = mix(col, vec3(1, 0, 0), map_range_clamp(hue, 300.0, 360.0, 0.0, 1.0));\n    \n    return col;\n}\n\n// -------------------------------\n\nvec3 flim_rgb_sweep(vec2 uv0to1)\n{\n    float hue = 1.0 - uv0to1.y;\n    float exposure = map_range(uv0to1.x, 0.0, 1.0, -5.0, 10.0);\n    return rgb_sweep(hue) * pow(2.0, exposure);\n}\n\n// https://www.desmos.com/calculator/khkztixyeu\nfloat flim_super_sigmoid(float inp, float toe_x, float toe_y, float shoulder_x, float shoulder_y)\n{\n    // Clip\n    inp = clamp(inp, 0.0, 1.0);\n    toe_x = clamp(toe_x, 0.0, 1.0);\n    toe_y = clamp(toe_y, 0.0, 1.0);\n    shoulder_x = clamp(shoulder_x, 0.0, 1.0);\n    shoulder_y = clamp(shoulder_y, 0.0, 1.0);\n\n    // Calculate straight line slope\n    float slope = (shoulder_y - toe_y) / (shoulder_x - toe_x);\n\n    // Toe\n    if (inp < toe_x)\n    {\n        float toe_pow = slope * toe_x / toe_y;\n        return toe_y * pow(inp / toe_x, toe_pow);\n    }\n\n    // Straight line\n    if (inp < shoulder_x)\n    {\n        float intercept = toe_y - (slope * toe_x);\n        return slope * inp + intercept;\n    }\n\n    // Shoulder\n    float shoulder_pow = -slope / (((shoulder_x - 1.0) / pow(1.0 - shoulder_x, 2.0)) * (1.0 - shoulder_y));\n    return (1.0 - pow(1.0 - (inp - shoulder_x) / (1.0 - shoulder_x), shoulder_pow)) * (1.0 - shoulder_y) + shoulder_y;\n}\n\nfloat flim_dye_mix_factor(float mono, float max_density)\n{\n    // log2 and map range\n    float offset = pow(2.0, flim_sigmoid_log2_min);\n    float fac = map_range_clamp(log2(mono + offset), flim_sigmoid_log2_min, flim_sigmoid_log2_max, 0.0, 1.0);\n\n    // Calculate amount of exposure from 0 to 1\n    fac = flim_super_sigmoid(fac, flim_sigmoid_toe_x, flim_sigmoid_toe_y, flim_sigmoid_shoulder_x, flim_sigmoid_shoulder_y);\n\n    // Calculate dye density\n    fac *= max_density;\n\n    // Mix factor\n    fac = pow(2.0, -fac);\n\n    // Clip and return\n    return clamp(fac, 0.0, 1.0);\n}\n\nvec3 flim_rgb_color_layer(vec3 inp, vec3 sensitivity_tone, vec3 dye_tone, float max_density)\n{\n    // Normalize\n    vec3 sensitivity_tone_norm = sensitivity_tone / rgb_sum(sensitivity_tone);\n    vec3 dye_tone_norm = dye_tone / rgb_max(dye_tone);\n\n    // Dye mix factor\n    float mono = dot(inp, sensitivity_tone_norm);\n    float mixFac = flim_dye_mix_factor(mono, max_density);\n\n    // Dye mixing\n    return lerp(dye_tone_norm, vec3(1.0), mixFac);\n}\n\nvec3 flim_rgb_develop(vec3 inp, float exposure, float max_density)\n{\n    // Exposure\n    inp *= pow(2.0, exposure);\n\n    // Blue-sensitive layer\n    vec3 result = flim_rgb_color_layer(inp, vec3(0, 0, 1), vec3(1, 1, 0), max_density);\n\n    // Green-sensitive layer\n    result *= flim_rgb_color_layer(inp, vec3(0, 1, 0), vec3(1, 0, 1), max_density);\n\n    // Red-sensitive layer\n    result *= flim_rgb_color_layer(inp, vec3(1, 0, 0), vec3(0, 1, 1), max_density);\n\n    return result;\n}\n\nvec3 flim_gamut_extension_mat_row(float primary_hue, float scale, float rotate, float mul)\n{\n    vec3 result = blender_hsv_to_rgb(vec3(wrap(primary_hue + (rotate / 360.0), 0.0, 1.0), 1.0 / scale, 1.0));\n    result /= rgb_sum(result);\n    result *= mul;\n    return result;\n}\n\nmat3 flim_gamut_extension_mat(\n    float red_scale,\n    float green_scale,\n    float blue_scale,\n    float red_rot,\n    float green_rot,\n    float blue_rot,\n    float red_mul,\n    float green_mul,\n    float blue_mul\n)\n{\n    mat3 m;\n    m[0] = flim_gamut_extension_mat_row(0.0, red_scale, red_rot, red_mul);\n    m[1] = flim_gamut_extension_mat_row(1.0 / 3.0, green_scale, green_rot, green_mul);\n    m[2] = flim_gamut_extension_mat_row(2.0 / 3.0, blue_scale, blue_rot, blue_mul);\n    return m;\n}\n\nvec3 negative_and_print(vec3 inp, vec3 backlight_ext)\n{\n    // Develop Negative\n    inp = flim_rgb_develop(inp, flim_negative_film_exposure, flim_negative_film_density);\n\n    // Backlight\n    inp *= backlight_ext;\n\n    // Develop Print\n    inp = flim_rgb_develop(inp, flim_print_film_exposure, flim_print_film_density);\n\n    return inp;\n}\n\nbool flim_load_matrices(sampler2D matrix_ch, out mat3 extend_mat, out mat3 extend_mat_inv)\n{\n    // W == valid_w means the matrices have been calculated\n    // in the source buffer.\n    const float valid_w = 2.0;\n\n    vec4 row;\n\n    // extend_mat\n    {\n        row = texelFetch(matrix_ch, ivec2(0, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat[0] = row.xyz;\n\n        row = texelFetch(matrix_ch, ivec2(1, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat[1] = row.xyz;\n\n        row = texelFetch(matrix_ch, ivec2(2, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat[2] = row.xyz;\n    }\n\n    // extend_mat_inv\n    {\n        row = texelFetch(matrix_ch, ivec2(3, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat_inv[0] = row.xyz;\n\n        row = texelFetch(matrix_ch, ivec2(4, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat_inv[1] = row.xyz;\n\n        row = texelFetch(matrix_ch, ivec2(5, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat_inv[2] = row.xyz;\n    }\n\n    return true;\n}\n\n// -------------------------------\n\n// matrix_ch: Which channel provides the buffer\n// containing gamut extension matrices?\nvec3 flim_transform(vec3 inp, float exposure, sampler2D matrix_ch)\n{\n    // Eliminate negative values\n    inp = max(inp, 0.0);\n\n    // Pre-Exposure\n    inp *= pow(2.0, flim_pre_exposure + exposure);\n\n    // Clip very large values for float precision reasons\n    inp = min(inp, 5000.0);\n\n    // Gamut Extension Matrix (Linear BT.709)\n    mat3 extend_mat, extend_mat_inv;\n    if (!flim_load_matrices(matrix_ch, extend_mat, extend_mat_inv))\n    {\n        return vec3(1, 0, 1);\n    }\n\n    // Backlight (extended gamut)\n    vec3 backlight_ext = flim_print_backlight * extend_mat;\n\n    // Upper limit in the print (highlight cap)\n    const float big = 10000000.0;\n    vec3 white_cap = negative_and_print(vec3(big, big, big), backlight_ext);\n\n    // Pre-Formation Filter\n    inp = lerp(inp, inp * flim_pre_formation_filter, flim_pre_formation_filter_strength);\n\n    // Convert to extended gamut\n    inp *= extend_mat;\n\n    // Negative & Print\n    inp = negative_and_print(inp, backlight_ext);\n\n    // Convert from extended gamut\n    inp *= extend_mat_inv;\n\n    // Eliminate negative values\n    inp = max(inp, 0.0);\n\n    // White cap\n    inp /= white_cap;\n\n    // Black cap\n    if (flim_black_point == -1.0) // -1 = auto\n    {\n        vec3 black_cap = negative_and_print(vec3(0.0), backlight_ext);\n        black_cap /= white_cap;\n        inp = rgb_uniform_offset(inp, rgb_avg(black_cap) * 1000.0, 0.0);\n    }\n    else\n    {\n        inp = rgb_uniform_offset(inp, flim_black_point, 0.0);\n    }\n\n    // Post-Formation Filter\n    inp = lerp(inp, inp * flim_post_formation_filter, flim_post_formation_filter_strength);\n\n    // Clip\n    inp = clamp(inp, 0.0, 1.0);\n\n    // Midtone Saturation\n    float mono = rgb_avg(inp);\n    float mixFac = (mono < 0.5) ? map_range_clamp(mono, 0.05, 0.5, 0.0, 1.0) : map_range_clamp(mono, 0.5, 0.95, 1.0, 0.0);\n    inp = lerp(inp, blender_hue_sat(inp, 0.5, flim_midtone_saturation, 1.0), mixFac);\n\n    // Clip\n    inp = clamp(inp, 0.0, 1.0);\n\n    // OETF (Gamma 2.2)\n    inp = pow(inp, vec3(1.0 / 2.2));\n\n    return inp;\n}\n\n/***********************************\n\nEnd of flim's implementation for Shadertoy Unit: Common\n\n***********************************/\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "/***********************************\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  sRGB 2.2\n\nShadertoy Unit:\n  Buffer X\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n  The buffer unit performs a one-time calculation\n  of flim's gamut extension matrices.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n***********************************/\n\n// NOTE:\n// iChannel0 must be set to this buffer (self-feeding).\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // W == valid_w means the matrices have already been calculated.\n    const float valid_w = 2.0;\n\n    // We only care about the first 6 pixels\n    if (ivec2(fragCoord).x > 5 || ivec2(fragCoord).y > 0)\n        return;\n\n    // Previous frame's value\n    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = prev;\n\n    // Do we need to recalculate the matrices?\n    bool needToCalc = (prev.w != valid_w) || (iTime == 0.0) || (iFrame < 1);\n    if (!needToCalc)\n        return;\n\n    // (Re)calculate the matrices\n    mat3 extend_mat = flim_gamut_extension_mat(flim_extended_gamut_red_scale, flim_extended_gamut_green_scale, flim_extended_gamut_blue_scale, flim_extended_gamut_red_rot, flim_extended_gamut_green_rot, flim_extended_gamut_blue_rot, flim_extended_gamut_red_mul, flim_extended_gamut_green_mul, flim_extended_gamut_blue_mul);\n    mat3 extend_mat_inv = inverse(extend_mat);\n\n    // extend_mat\n    {\n        if (ivec2(fragCoord) == ivec2(0, 0))\n        {\n            fragColor = vec4(extend_mat[0], valid_w);\n        }\n        if (ivec2(fragCoord) == ivec2(1, 0))\n        {\n            fragColor = vec4(extend_mat[1], valid_w);\n        }\n        if (ivec2(fragCoord) == ivec2(2, 0))\n        {\n            fragColor = vec4(extend_mat[2], valid_w);\n        }\n    }\n\n    // extend_mat_inv\n    {\n        if (ivec2(fragCoord) == ivec2(3, 0))\n        {\n            fragColor = vec4(extend_mat_inv[0], valid_w);\n        }\n        if (ivec2(fragCoord) == ivec2(4, 0))\n        {\n            fragColor = vec4(extend_mat_inv[1], valid_w);\n        }\n        if (ivec2(fragCoord) == ivec2(5, 0))\n        {\n            fragColor = vec4(extend_mat_inv[2], valid_w);\n        }\n    }\n}\n\n/***********************************\n\nEnd of flim's implementation for Shadertoy Unit: Buffer X\n\n***********************************/\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}