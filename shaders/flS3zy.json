{
    "Shader": {
        "info": {
            "date": "1624096718",
            "description": "experimenting with atmospheric scattering.",
            "flags": 0,
            "hasliked": 0,
            "id": "flS3zy",
            "likes": 22,
            "name": "cloud in a bubble",
            "published": 3,
            "tags": [
                "raytracing",
                "cloud",
                "atmosphere"
            ],
            "usePreview": 0,
            "username": "bloodnok",
            "viewed": 828
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415927\n/*\n\t@geofftnz\n\n\tforking someone's raytraced sphere in order to do some material testing.\n    atmospheric scattering attempt.\n    \n    Basic idea:\n    Ray traced sphere, ray march through interior.\n    Accumulate Mie+Rayleigh scattering\n    Accumulate air and cloud density.\n    At each point on the primary ray march, do a secondary ray march towards the light source to calculate amount of light reaching point.\n    \n    Full of bugs & fudge factors.\n\n*/\n// atmospheric scattering specifics\n\n// Rayleigh absorbtion constant. Controls how different frequencies are scattered. Makes the sky blue.\nvec3 Kr = vec3(0.1287, 0.2698, 0.7216);\n\n// Mie scattering\nfloat miePhase = 0.9;\nfloat mieAmount = 0.01;\n\n// Rayleigh scattering\nfloat ralPhase = -0.01;\nfloat rayleighAmount = 0.9;  // how blue is your sky?\n\nfloat absorbCoeff = 0.7;  // how much the air absorbs light.\nfloat cloudScatter = 20.0;  // amount of omni-directional scatter off clouds.\nfloat cloudAbsorbFactor = 20.0;  // attenuation by clouds.\nfloat cloudMie = 100.0; // amount of Mie scattering by clouds\n\nfloat airDensityBase = 0.2;\n\nvec3 lightcol = vec3(10.0,9.0,8.0);\n\nvec4 sph1 = vec4 (0.0,0.0,0.0,1.0);\n\n\n\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand(vec3 co){\n    return fract(sin(dot(co.xyz ,vec3(12.9898,78.233,47.985))) * 43758.5453);\n}\n\n// credit: iq/rgba\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\n\n// credit: iq/rgba\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\n\nfloat fbm(in vec3 x)\n{\n\tfloat i = 1.0;\n\t\n\tfloat n = noise(x * i) / i; i *= 2.0;\n\tn+= noise(x * i) / i; i *= 2.0;\n\tn+= noise(x * i) / i; i *= 2.0;\n\tn+= noise(x * i) / i; i *= 2.0;\n\tn+= noise(x * i) / i; i *= 2.0;\n    n+= noise(x * i) / i; i *= 2.0;\n\n\treturn n;\n}\n\n//------------------------------------------------------------------------------\n// Colour space transform\n//------------------------------------------------------------------------------\n\n// https://en.wikipedia.org/wiki/Academy_Color_Encoding_System#Converting_ACES2065-1_RGB_values_to_CIE_XYZ_values\nvec3 RGBtoXYZ(vec3 col)\n{\n    const mat3 x = mat3(\n        \tvec3(0.9525523959,0.3439664498,0.0),\n        \tvec3(0,0.7281660966,0.0),\n        \tvec3(0.0000936786,-0.0721325464,1.0088251844)\n        );\n    return x * col;\n}\n\nvec3 XYZtoRGB(vec3 col)\n{\n    const mat3 x = mat3(\n        \tvec3(1.0498110175,-0.4959030231,0.0),\n        \tvec3(0.0,1.3733130458,0.0),\n        \tvec3(-0.0000974845,0.0982400361,0.9912520182)\n        );\n    return x * col;\n}\n\n\n//============================================================\n// credit: demofox https://www.shadertoy.com/view/4tyXDR\n#define OBJECT_REFLECTIVITY 0.0 // How reflective the object is. regardless of fresnel.\nfloat FresnelReflectAmount (float n1, float n2, vec3 normal, vec3 incident)\n{\n    // Schlick aproximation\n    float r0 = (n1-n2) / (n1+n2);\n    r0 *= r0;\n    float cosX = -dot(normal, incident);\n    if (n1 > n2)\n    {\n        float n = n1/n2;\n        float sinT2 = n*n*(1.0-cosX*cosX);\n        // Total internal reflection\n        if (sinT2 > 1.0)\n            return 1.0;\n        cosX = sqrt(1.0-sinT2);\n    }\n    float x = 1.0-cosX;\n    float ret = r0+(1.0-r0)*x*x*x*x*x;\n\n    // adjust reflect multiplier for object reflectivity\n    ret = (OBJECT_REFLECTIVITY + (1.0-OBJECT_REFLECTIVITY) * ret);\n    return ret;\n}\n\n\n\nfloat pointRayDistance(vec3 ro, vec3 rd, vec3 p)\n{\n\tvec3 u = p-ro;\n\tfloat cosvu = dot(rd,u);\n\tif (cosvu<0.0) return length(p-ro);\n\tvec3 puv = rd * (cosvu / length(rd));\n\tvec3 qq = ro + puv;\n\treturn length(p-qq);\n}\n\n// intersection through participating media (like atmospheres)\nstruct iMediaIntersection\n{\n    float tnear;   // first intersection\n    float tfar;    // last intersection\n    uint mnear;    // material first hit (atmosphere?)\n    uint mfar;     // material on second hit (atmosphere or ground)\n    vec3 nor;      // normal at first intersection\n};\n\n\n// intersect ray ro+rd with sphere sph, calculates both entry and exit points.\niMediaIntersection mSphere(in vec3 ro, in vec3 rd, in vec4 sph){\n\n    iMediaIntersection res;\n    res.tnear = -1.0;\n    res.tfar = -1.0;\n    res.mnear = 0u;\n    res.mfar = 0u;\n    \n    // sphere intersection\n\tfloat r = sph.w; //radius\n\tvec3 oc = ro - sph.xyz; //origin = position sphere\n\tfloat b = 2.0*dot(oc,rd);\n\tfloat c = dot(oc,oc)-r*r;\n\tfloat h = b*b - 4.0*c;\n    \n\tif (h >= 0.0)\n    {\n        float hsqrt = sqrt(h);\n        res.tnear = (-b - hsqrt) / 2.0;\n        res.mnear = 1u;  // atmospheric hit\n        \n        res.nor = normalize(ro + rd * res.tnear - sph.xyz);\n        \n        res.tfar = (-b + hsqrt)/2.0;\n        res.mfar = 1u;  // atmospheric exit\n    }\n\n    return res;\n}\n\n\n\nfloat iSphere (in vec3 ro, in vec3 rd, in vec4 sph){\n\t//a sphere centered at the origin has eq: |xyz| = r\n\t//meaning, |xyz|^2 = r^2, meaning <xyz,xyz> = r^2\n\t// now, xyz = ro + t*rd, therefore |ro|^2 + t^2 + 2<ro,rd>t - r^2 = 0\n\t// which is a quadratic equation. so\n\tfloat r = sph.w; //radius\n\tvec3 oc = ro - sph.xyz; //origin = position sphere\n\tfloat b = 2.0*dot(oc,rd);\n\tfloat c = dot(oc,oc)-r*r;\n\tfloat h = b*b - 4.0*c;\n\tif (h <0.0) return -1.0;\n\tfloat t = (-b - sqrt(h))/2.0;\n\treturn t;\n}\n\nfloat iSphere2 (in vec3 ro, in vec3 rd, in vec4 sph){\n\t//a sphere centered at the origin has eq: |xyz| = r\n\t//meaning, |xyz|^2 = r^2, meaning <xyz,xyz> = r^2\n\t// now, xyz = ro + t*rd, therefore |ro|^2 + t^2 + 2<ro,rd>t - r^2 = 0\n\t// which is a quadratic equation. so\n\tfloat r = sph.w; //radius\n\tvec3 oc = ro - sph.xyz; //origin = position sphere\n\tfloat b = 2.0*dot(oc,rd);\n\tfloat c = dot(oc,oc)-r*r;\n\tfloat h = b*b - 4.0*c;\n\tif (h <0.0) return -1.0;\n\tfloat t = (-b + sqrt(h))/2.0;\n\treturn t;\n}\n\nvec3 nSphere (in vec3 pos, in vec4 sph){\n\treturn (pos - sph.xyz) / sph.w;\n}\n\nfloat iPlane(in vec3 ro, in vec3 rd){\n\t//eq. of a plane, y=0 = ro.y + t*rd.y\n\treturn -ro.y/rd.y;\n}\n\nvec3 nPlane( in vec3 pos){\n\treturn vec3(0.0,1.0,0.0);\n}\n\n\nfloat intersect( in vec3 ro, in vec3 rd, out float resT){\n\tresT = 1000.0;\n\tfloat id = -1.0;\n\tfloat tsph = iSphere (ro, rd, sph1); //intersect with sphere\n\tfloat tpla = iPlane (ro,rd); //intersect with plane\n\tif (tsph > 0.0){\n\t\tid = 1.0;\n\t\tresT = tsph;\n\t}\n\tif (tpla > 0.0 && tpla < resT){\n\t\tid = 2.0;\n\t\tresT = tpla;\n\t}\n\treturn id;\n}\n\n\niMediaIntersection mediaIntersect( in vec3 ro, in vec3 rd){\n\n    iMediaIntersection res;\n    res.tnear = -1.0;\n    res.mnear = 0u;\n    res.tfar = -1.0;\n    res.mfar = 0u;\n    \n    iMediaIntersection res2 = mSphere(ro,rd,sph1);\n    res = res2;\n    \n    return res;\n}\n\n\n// mie/rayleigh phase - @pyalot http://codeflow.org/entries/2011/apr/13/advanced-webgl-part-2-sky-rendering/\n// sensible g: mie:0.97, ral:-0.01\nfloat phase(float alpha, float g){\n    float gg = g*g;\n    float a = 3.0*(1.0-gg);\n    float b = 2.0*(2.0+gg);\n    float c = 1.0+alpha*alpha;\n    float d = pow(1.0+gg-2.0*g*alpha, 1.5);\n    return (a/b)*(c/d);\n}\n\n// exponential absorbtion - @pyalot http://codeflow.org/entries/2011/apr/13/advanced-webgl-part-2-sky-rendering/\nvec3 absorb(float dist, vec3 col, float f)\n{\n    vec3 c = col;    \n    c *= (vec3(1.0) - pow(Kr, vec3(f / max(dist,0.0000000001))));\n    //c *= (vec3(1.0) - pow(vec3(0.05,0.7,0.9), vec3(f / max(dist*0.5,0.0000000001))));\n    //c *= (vec3(1.0) - pow(vec3(0.01,0.85,0.9), vec3(f / max(dist*0.1,0.0000000001))));\n    return c;\n}\n\nfloat cloudAbsorb(float cloud)\n{\n    return exp(-cloud * cloudAbsorbFactor);\n}\n\nfloat airDens(vec3 pos){\n    \n    //return 5.0 * exp(-7.0 * alt) * (1.0-alt);  // last factor is lies, but makes sure we end at 0.0 at edge of atmosphere\n    return airDensityBase;\n}\n\n// calculate cloud density\nfloat cloud(vec3 pos){\n\n    vec3 pos2 = pos - sph1.xyz;\n    float density = 1.0-smoothstep(0.2,0.9,dot(pos2,pos2));\n\n    pos += vec3(17.3,6.9,0.19) * iTime * 0.002;\n    \n    //return smoothstep(0.8,1.2,fbm(pos*2.0))*max(0.0,fbm(pos*2.0)-1.0);\n    return max(0.0,(fbm(pos*2.3)* density)-0.8);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    Kr = RGBtoXYZ(Kr);\n\n\tvec3 light = normalize( vec3(0.5,1.0,0.5));\n\t//uv are the pixel coordinates, from 0 to 1\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\tvec2 p = fragCoord.xy/iResolution.xy;\n\tp = -1.0 + 2.0*p;\n\tp.x *= iResolution.x/iResolution.y;\n\n\n    vec3 mse = iMouse.xyz;\n    if (mse.z <= 0.0){  // default view\n        mse.x = iResolution.x * 0.5;\n        mse.y = iResolution.y * 0.5;\n    }\n\n    // turn mouse into spherical coords\n\tvec2 nMouse = (mse.xy / iResolution.xy)* PI;\n\tfloat th = nMouse.y; \n\tfloat ph = -nMouse.x * 2.0;\n    \n   \n\n\t//vec3 ro = vec3(0.0,1.1,2.0); //camera position\n    vec3 ro;\n    float camdist = 2.0;\n\tro.x = sin(th) * cos(ph) * camdist;\n\tro.z = sin(th) * sin(ph) * camdist;\n\tro.y = cos(th) * camdist;\n\n\n\tvec3 lookAt = sph1.xyz;\n\tvec3 front = normalize(lookAt - ro);\n\tvec3 left = normalize(cross(vec3(0,1,0), front));\n\tvec3 up = normalize(cross(front, left));\n\tvec3 rd0 = normalize(front*1.5 + left*p.x + up*p.y); // rect vector\n\n    /*\n\tlight.x = sin(th) * cos(ph);\n\tlight.z = sin(th) * sin(ph);\n\tlight.y = -cos(th);\n\tlight = normalize(light);\n    */\n    light = normalize(vec3(1.0,1.0,1.0));\n\t\n    iMediaIntersection hit = mediaIntersect(ro,rd0);\n\n\tvec3 col = vec3(0.0);\n    float airDensity = 0.0;\n    float cloudDensity = 0.0;\n    float cloudAttenuation = 1.0;\n    \n\t\n\tif (hit.tnear > 0.0){\n    \n    \n\t\tvec3 pos = ro + hit.tnear*rd0;\t//hit position\n        \n        // calculate new ray direction based on refraction\n        vec3 rd = refract(rd0,hit.nor,1.0/1.05);\n        col = texture(iChannel0,rd).rgb * 0.25;\n    \n        if (hit.mnear == 1u){  // atmospheric hit\n        \n            // setup scattering            \n            float mie = phase(dot(rd,light),miePhase) * mieAmount; // relative amount of Mie scattering.\n            float rayleigh = phase(dot(rd,light),ralPhase) * rayleighAmount; // relative amount of Rayleigh scattering.\n                \n            // step through atmosphere, cast rays to lightsource to determine shadow.\n            float litDensity = 0.0;\n            float dt = (hit.tfar - hit.tnear) * 0.04;\n            float hh = hash(iTime + dot(rd+ro,vec3(12.65898,37.3516781,17.651651)));  // add a little noise to the start of the ray traversal so smooth out banding.\n            \n            vec3 mieAccum = vec3(0.0);\n            vec3 rayleighAccum = vec3(0.0);\n            vec3 cloudAccum = vec3(0.0); // scatter from clouds\n            vec3 totalInflux = vec3(0.0);\n            \n            // raymarch through sphere:\n            // - calculate cumulative absorption\n            // - calculate influx at each point\n            //   - raymarch towards sun & repeat above process.\n            \n            for(float t = hit.tnear + hh * 0.01; t<hit.tfar-0.00001; t+=dt){\n            \n                vec3 apos = ro + rd * t;  // position along atmosphere ray\n                \n                float stepCloudDensity = cloud(apos) * dt;\n                cloudDensity += stepCloudDensity; // total cloud density along path\n                                \n                float stepDensity = airDens(apos) * dt;  // calculates amount of air for this step\n                \n                airDensity += stepDensity;  // total air density from viewer to point\n                \n                //vec3 influx = lightcol;  // incoming light (todo: calculate this)\n                vec3 influx = vec3(0.0);\n                \n                // do another raycast towards the sun\n                float tsun = iSphere2(apos, light, sph1); // cast ray to sun, intersect with inner edge of sphere\n                float dtl = tsun * 0.1; // keep it rather chunky, don't want to bog down\n                float airToSun = 0.0;\n                float cloudToSun = 0.0;\n                float hh2 = hash(iTime + dot(apos,vec3(12.65898,37.3516781,17.651651)));\n\n                for (float tl = hh2 * 0.1; tl < tsun; tl += dtl){\n                    \n                    vec3 spos = apos + light * tl;\n                    cloudToSun += cloud(spos) * dtl;  // acumulate cloud density\n                    airToSun += airDens(spos) * dtl;\n                }\n                \n                influx = absorb(airToSun,lightcol,absorbCoeff) * cloudAbsorb(cloudToSun); \n                \n                cloudAttenuation = cloudAbsorb(cloudDensity); //1.0 / (1.0 + cloudDensity * cloudAbsorb);\n                \n                rayleighAccum += absorb(airDensity,influx * Kr * rayleigh * stepDensity,absorbCoeff) * cloudAttenuation;\n                \n                // mie from air + cloud\n                \n                //mieAccum += absorb(airDensity,influx * (cloudScatter*dt+mie) * stepCloudDensity,absorbCoeff) * cloudAttenuation;  // original              \n                //mieAccum += absorb(airDensity,influx * mie * ((cloudScatter*dt) + stepCloudDensity),absorbCoeff) * cloudAttenuation;  // broken?\n                mieAccum += absorb(airDensity,influx * (mie * (stepDensity + stepCloudDensity*cloudMie) + (cloudScatter*stepCloudDensity)),absorbCoeff) * cloudAttenuation;\n            }\n        \n            \n            col += mieAccum;\n            col += rayleighAccum;\n            \n            // sun disc\n            float mie_eye = phase(dot(rd,light),0.9995) * 0.001; // relative amount of Mie scattering.\n            col += absorb(airDensity,lightcol,absorbCoeff) * mie_eye * cloudAttenuation;\n            \n            // add some fresnel reflection\n            vec3 refl = reflect(rd,hit.nor);\n            float reflAmount = FresnelReflectAmount(1.0,1.5,hit.nor,rd);\n            col = col * (1.0-reflAmount) + texture(iChannel1,refl).rgb * reflAmount;\n            \n\n        }\n\n\t}else{\n        col = texture(iChannel0,rd0).rgb;\n        col += lightcol * phase(dot(rd0,light),0.9995) * 0.001; // relative amount of Mie scattering.\n\t}\n\n\n    // fake some sun glow (bloom / mie scattering in eye?)\n    //float mie_eye = phase(dot(rd0,light),0.9995) * 0.001; // relative amount of Mie scattering.\n    //col += absorb(airDensity,lightcol,absorbCoeff) * mie_eye * cloudAttenuation;\n    \n\n\n// reinhardt HDR tonemapping\n\tfloat whitelevel = 5.0;\n\tcol = (col  * (vec3(1.0) + (col / (whitelevel * whitelevel))  ) ) / (vec3(1.0) + col);\t\n\n// ACES to RGB\n    col = XYZtoRGB(col);\n\n// gamma\t\n\tcol = pow(col,vec3(1.0/2.0));\n\n\t\n\tfragColor = vec4(col,1.0);\n\t\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 27,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}