{
    "Shader": {
        "info": {
            "date": "1508844834",
            "description": "Applying a simple hexagonal tile trick to produce a faux 3D interlaced hexagonal grid pattern.",
            "flags": 0,
            "hasliked": 0,
            "id": "llfcWs",
            "likes": 60,
            "name": "Hexagonal Interlacing",
            "published": 3,
            "tags": [
                "hexagon",
                "pattern",
                "tile",
                "overlay",
                "weave",
                "faux"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 2229
        },
        "renderpass": [
            {
                "code": "/*\n\n\tHexagonal Interlacing\n\t---------------------\n\n    If you're interested in graphics, then I'll assume you've seen the countless faux \n\t3D interlaced-looking patterns on the internet. Recently, BigWings released a really \n\tcool hexagonal weave pattern, which was pieced together with a bunch of repeat  \n\thexagonal Truchet tiles constructed with combinations of overlapping arcs and \n\tlines -- I've provided a link below, for anyone who's interested.\n\n\tAnyway, this is a very basic interlaced hexagonal pattern, and is representative of \n\tmany other variations you come across on the net. I threw it together on the fly, \n    and without a great deal of forethought, so I wouldn't take the code too seriously. \n\tIt works fine and runs fine, but there'd be better ways to go about it.\n\n\tTo produce the pattern, set up a hexagonal grid, render a three pronged shape over\n\tanother three pronged shape rotated at 60 degrees, then randomly flip tiles. If you\n\tknow how to render a thick line over another, then it should be pretty simple.\n\n\tThe pattern has been rendered in an oldschool Photoshop vector-graphics style -- \n\tOverlays with contour lines, drop shadows, beveling, etc, and faux lighting. In case \n\tit isn't obvious, the lighting is completely fake. There's no physical lighting setup \n\twhatever, which means no diffuse calculations, attenuation, bumpmapping, etc.\n\n\tThat's three hexagon examples in row, so I'm a bit hexagoned out, but I'll put up a \n\tproper 3D example later. By the way, it'd be great to see other repeat patterns --\n\tinterlaced or otherwise -- produced on Shadertoy.\n\n\n\tOther interlaced pattern examples:\n\t\n\tHexagonal Truchet Weaving - BigWIngs\n\thttps://www.shadertoy.com/view/llByzz\n\n\t// Fabrice has a heap of overlapping tile examples that are fun to watch. This is\n\t// one of them.\n\tcanvas2 - FabriceNeyret2\n\thttps://www.shadertoy.com/view/4dSXWR\n\n\tStarter references:\n\n\t// You can't do a hexagonal grid example without referencing this. :) Very stylish.\n\tHexagons - distance - iq\n\thttps://www.shadertoy.com/view/Xd2GR3\n\n\n\t// Simpler hexagonal grid example that attempts to explain the grid setup used to produce \n\t// the pattern here.\n\t//\n\tMinimal Hexagonal Grid - Shane\n\thttps://www.shadertoy.com/view/Xljczw\n\n*/\n\n\n\n\n// Standard 2D rotation formula.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// Standard vec2 to float hash - Based on IQ's original.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(141.213, 289.847)))*43758.5453); }\n\n\n// Helper vector. If you're doing anything that involves regular triangles or hexagons, the\n// 30-60-90 triangle will be involved in some way, which has sides of 1, sqrt(3) and 2.\nconst vec2 s = vec2(3, 1.7320508);\n\n\n// The 2D hexagonal isosuface function: If you were to render a horizontal line and one that\n// slopes at 60 degrees, then combine them, you'd arrive at the following.\nfloat hex(in vec2 p){\n    \n    p = abs(p);\n    \n    // Below is equivalent to:\n    //return max(p.y*.5 + p.x*.866025, p.y); \n\n    return max(dot(p, s*.5), p.y); // Hexagon.\n    \n}\n\n// This function returns the hexagonal grid coordinate for the grid cell, and the corresponding \n// hexagon cell ID - in the form of the central hexagonal point. That's basically all you need to \n// produce a hexagonal grid.\n//\n// When working with 2D, I guess it's not that important to streamline this particular function.\n// However, if you need to raymarch a hexagonal grid, the number of operations tend to matter.\n// This one has minimal setup, one \"floor\" call, a couple of \"dot\" calls, a ternary operator, etc.\n// To use it to raymarch, you'd have to double up on everything - in order to deal with \n// overlapping fields from neighboring cells, so the fewer operations the better.\nvec4 getHex(vec2 p){\n    \n    // The hexagon centers: Two sets of repeat hexagons are required to fill in the space, and\n    // the two sets are stored in a \"vec4\" in order to group some calculations together. The hexagon\n    // center we'll eventually use will depend upon which is closest to the current point. Since \n    // the central hexagon point is unique, it doubles as the unique hexagon ID.\n    vec4 hC = floor(vec4(p, p - vec2(1.7320508, .866025))/s.xyxy) + .5;\n    \n    // Centering the coordinates with the hexagon centers above.\n    vec4 h = vec4(p - hC.xy*s, p - (hC.zw + .5)*s);\n    \n    // Nearest hexagon center (with respect to p) to the current point. In other words, when\n    // \"h.xy\" is zero, we're at the center. We're also returning the corresponding hexagon ID -\n    // in the form of the hexagonal central point. Note that a random constant has been added to \n    // \"hC.zw\" to further distinguish it from \"hC.xy.\"\n    //\n    // On a side note, I sometimes compare hex distances, but I noticed that Iomateron compared\n    // the Euclidian version, which seems neater, so I've adopted that.\n    return dot(h.xy, h.xy)<dot(h.zw, h.zw) ? vec4(h.xy, hC.xy) : vec4(h.zw, hC.zw + vec2(1.7320508, .866025));\n    \n    //hp = h.xy;\n    \n    //return vec4(h.zw, hex(h.xy), length(h.xy));\n    \n    \n}\n\n\n// The distance function. The simple things are oftne the best, so I'm using circles, but there\n// are countless variations to try, so I've left the rough working below, for anyone interested\n// in experimenting.\nfloat dist(vec2 p, float r){\n    \n    \n    return length(p) - r;\n    \n    //float c = length(p);\n    //return max(c, -c + 1.) - r;\n    \n    //p = r2(3.14159/4.)*p;\n    //float c = pow(dot(pow(abs(p), vec2(3)), vec2(1)), 1./3.);\n    //return c - r*.9;\n    \n    //p = r2(3.14159/4.)*p;\n    //float c = pow(dot(pow(abs(p), vec2(3)), vec2(1)), 1./3.);//length(p);\n    //return max(c, -c + .97) - r;\n\n    \n    //float c = length(p);\n    //p = abs(p);\n    //return mix(c, max(p.x*.866025 + p.y*.5, p.y), .35) - r*.95;\n    //return min(c, max(p.x, p.y) + .125) - r;\n    //p = r2(3.14159/24.)*p;\n    //return min(c, max(p.x, p.y) + .16) - r;\n    \n    //return max(c, -c + 1.) - r;\n    //p = r2(3.14159/6.)*p;\n    //return max(c, max(abs(p.x)*.866 - p.y*.5, p.y) + .25) - r;\n    \n    \n    //p = abs(p);\n    //return max(p.x*.866025 + p.y*.5, p.y) - r*.9;\n    //p = r2(3.14159/6.)*p;\n    //return max(max(p.x, p.y), (p.x + p.y)*.75) - r;\n    //return min(max(p.x, p.y), (p.x + p.y)*.7) - r*.7;\n    \n}\n\n///\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(41, 289)));\n    //return fract(vec2(262144, 32768)*n); \n    \n    // Animated.\n    p = fract(vec2(262144, 32768)*n); \n    // Note the \".333,\" insted of \".5\" that you'd expect to see. When edging, it can open \n    // up the cells ever so slightly for a more even spread. In fact, lower numbers work \n    // even better, but then the random movement would become too restricted. Zero would \n    // give you square cells.\n    return sin( p*6.2831853 + iTime)*.333 + .333; \n    //return sin( p*6.2831853 + iTime*2.)*(cos( p*6.2831853 + iTime*.5)*.3 + .5)*.45 + .5; \n    \n}\n\n// IQ's smooth minimum function.\nfloat smin(float a, float b, float k){\n\n    float h = clamp(.5 + .5*(b - a)/k, 0., 1.);\n    return mix(b, a, h) - k*h*(1. - h);\n}\n\n// IQ's exponential-based smooth minimum function. Unlike the polynomial-based\n// smooth minimum, this one is commutative.\nfloat sminExp(float a, float b, float k)\n{\n    float res = exp(-k*a) + exp(-k*b);\n    return -log(res)/k;\n}\n\n\n// 2D 2nd-order Voronoi: Obviously, this is just a rehash of IQ's original. I've tidied\n// up those if-statements. Since there's less writing, it should go faster. That's how \n// it works, right? :)\n//\n// This is exactly like a regular Voronoi function, with the exception of the smooth\n// distance metrics.\nfloat Voronoi(in vec2 p){\n    \n    // Partitioning the grid into unit squares and determining the fractional position.\n\tvec2 g = floor(p), o; p -= g;\n\t\n    // \"d.x\" and \"d.y\" represent the closest and second closest distances\n    // respectively, and \"d.z\" holds the distance comparison value.\n\tvec3 d = vec3(2); // 8., 2, 1.4, etc. \n    \n    // A 4x4 grid sample is required for the smooth minimum version.\n\tfor(int j = -1; j <= 2; j++){\n\t\tfor(int i = -1; i <= 2; i++){\n            \n\t\t\to = vec2(i, j); // Grid reference.\n             // Note the offset distance restriction in the hash function.\n            o += hash22(g + o) - p; // Current position to offset point vector.\n            \n            // Distance metric. Unfortunately, the Euclidean distance needs\n            // to be used for clean equidistant-looking cell border lines.\n            // Having said that, there might be a way around it, but this isn't\n            // a GPU intensive example, so I'm sure it'll be fine.\n\t\t\td.z = length(o); \n            \n            // Up until this point, it's been a regular Voronoi example. The only\n            // difference here is the the mild smooth minimum's to round things\n            // off a bit. Replace with regular mimimum functions and it goes back\n            // to a regular second order Voronoi example.\n            d.y = max(d.x, smin(d.y, d.z, .4)); // Second closest point with smoothing factor.\n            d.x = smin(d.x, d.z, .2); // Closest point with smoothing factor.\n            \n            // Based on IQ's suggestion - A commutative exponential-based smooth minimum.\n            // This algorithm is just an approximation, so it doesn't make much of a difference,\n            // but it's here anyway.\n            //d.y = max(d.x, sminExp(d.y, d.z, 10.)); // Second closest point with smoothing factor.\n            //d.x = sminExp(d.x, d.z, 20.); // Closest point with smoothing factor.\n\n                       \n\t\t}\n\t}    \n\t\n    // Return the regular second closest minus closest (F2 - F1) distance.\n    return d.y - d.x;\n    \n}\n\n////\n\n// Cheap and nasty 2D smooth noise function with inbuilt hash function - based on IQ's \n// original. Very trimmed down. In fact, I probably went a little overboard. I think it \n// might also degrade with large time values. I'll swap it for something more robust later.\nfloat n2D(vec2 p) {\n\n\tvec2 i = floor(p); p -= i; p *= p*(3. - p*2.);  \n    \n\treturn dot(mat2(fract(sin(vec4(0, 1, 113, 114) + dot(i, vec2(1, 113)))*43758.5453))*\n                vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n\n}\n\n// Approximating - very roughly - the metallic Shadertoy texture. I handcoded this to \n// keep algorithmic art purists - like Dr2 - happy. :)\nvec3 tex(in vec2 p){\n    \n    float ns = n2D(p)*.57 + n2D(p*2.)*.28 + n2D(p*4.)*.15;\n\n    // Some fBm noise based bluish red coloring.\n    vec3 n = mix(vec3(.33, .11, .022), vec3(.385, .55, .715), ns);\n    n *= mix(vec3(1, .9, .8), vec3(0, .1, .2), n2D(p*32.))*.6 + .4;\n    \n    //n =  n*.3 + min(n.zyx*vec3(1.3, .6, .2)*.75, 1.)*.7;\n    \n    return clamp(n, 0., 1.);\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Scaled, moving screen coordinates.\n    float res = clamp(iResolution.y, 300., 750.);\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/res*5.;\n    \n    // Movement.\n    uv += vec2(.5, .125)*iTime;\n    \n    // HEXAGONAL GRID CONVERSION.\n    //\n    // Obtain the hexagonal grid information.\n    vec4 hp = getHex(uv);\n    \n    // Distance from the pixel to the hexagonal center.\n    float cDist = length(hp.xy); \n    \n    // Random tile ID.\n    float rnd = fract(sin(dot(hp.zw, vec2(41.13, 289.97)))*43758.5453);\n    //rnd = mod(floor(hp.x + hp.y), 2.);\n    \n    \n    // Comment this out and you'll see two nontangled hexagonal grids.\n    if(rnd>.5) hp.x = -hp.x; // Has the same effect as rotating by 60 degrees.\n    \n    // Saving the grid coordinates in \"p\" to save some writing.\n    vec2 p = hp.xy;\n    \n    // TILE CONSTRUCTION.\n    //\n    // Creating the hexagonal tile. Partition the hexagon into three sections,\n    // then subtract circles from the edges. That will creat one three pronged\n    // fan looking object. Create another one rotated at 60 degrees to the \n    // other, then render one over the other. The weaving illusion is created \n    // when you randomly flip tiles.\n    //\n    // \n    // Three pronged object one.\n    float rad1 = 1.;\n    float rad2 = .66; // Hole radius.\n    //float rad2 = .525*(sin(iTime/2.)*.25 + 1.2); // Animated. Shows Truchet relationship.\n    \n    // Contruct three circular holes - equispaced around the hexagonal boundary.\n    const float aNum = 3.;\n    float ia = floor(atan(p.y, p.x)/6.283*aNum) + .5;\n    \n    p = r2(ia*6.283/aNum)*p; // Converting to polar coordinates: p.x = radius, p.y = angle.\n    p.x -= rad1; // Moving the radial coordinate out to the radius of the arc.\n    \n    // Mask and distance field.\n    float mask = dist(p, rad2);\n    float d = max(-mask, mask - .05);\n      \n   \n    // Three pronged object two.\n    p = hp.xy;\n    p = r2(-3.14159/3.)*p; // Rotate by 60 degrees.\n \n    ia = floor(atan(p.y, p.x)/6.283*aNum) + .5;\n    \n    p = r2(ia*6.283/aNum)*p; // Converting to polar coordinates: p.x = radius, p.y = angle.\n    p.x -= rad1; // Moving the radial coordinate out to the radius of the arc.\n    \n    // Mask and distance field for the second object. Note the extra mask step.\n    float mask2 = dist(p, rad2);\n    float d2 = max(-mask2, mask2 - .05);\n    d2 = max(d2, mask - .05);\n \n    // Overlapped shadow object. There'd be a few ways to go about it, but this'll do.\n    float sh  = cDist - .4;\n    sh = max(sh, smoothstep(0., .01, mask)); // Taking the top layer from the mask;\n    sh = max(sh, -mask);\n    \n    \n    // Combine the three pronged objects to for the  lattice.\n    d = min(d, d2);\n     \n    // The lattice mask. Constructed with the over and under lattices.\n    mask = max(mask, mask2);\n     \n    \n    // RENDERING.\n    //\n    // A concentric geometric pattern. Part science, part trial and error. \n    vec3 pat = mix(vec3(1), vec3(0), (1. - clamp(sin(cDist*3.14159*12.)*4. + 3.95, 0., 1.))*.7);\n    pat = min(pat, mix(vec3(1), vec3(0), (1. - clamp(sin(cDist*3.14159*12./3.)*4. + 3., 0., 1.))*.3));\n     \n    \n    // The background. Starting with the pattern above, then adding color and shadows.\n    vec3 bg = mix(vec3(1), vec3(0), pat);\n    vec3 red = mix(vec3(1, .1, .2), vec3(1, .2, .4), dot(sin(uv*3.14159 + cos(uv.yx*3.14159)*3.14159), vec2(.25)) + .5);\n    float shMsk = max(mask,  -mask - .075);\n    bg = mix(bg, vec3(0), (1. - smoothstep(0., .05, shMsk))*.75)*red*3.;\n    \n    bg += mix(vec3(1), red.yzx, .5)*bg*smoothstep(0., .3, Voronoi(uv*1.5 - vec2(1, .25)*iTime*.5) - .25)*3.;\n    \n    // Lamest lighting and environmental mapping ever. Applying a moving Voronoi pattern to the \n    // background. I've added a little more to the interweaved lattice object (further down) too.\n    // More light is being applied to the background to give the impression that it's somehow made\n    // of shinier stuff... That was the idea anyway. :)\n    float vor = Voronoi(uv*1.5 - vec2(1, .25)*iTime*.5);\n    bg += mix(vec3(1), red.yzx, .5)*bg*smoothstep(0., .05, vor - .25)*.5;\n    \n    \n    \n    // Lattice color with patterned decoration.\n    vec3 latCol = vec3(1)*pat;\n    \n    // A bit of whitish edging. I made a lot of this up as I went along.\n    latCol = mix(latCol, vec3(1), smoothstep(0., .05, -(d - .09))*.9);\n  \n    // Applying the overlayed lattice to the background, then applying some texturing. By the way,\n    // the texture is a very rough handcoded representation of the metallic texture on Shadertoy. \n    // I kept the example \"resource free\" to keep the algorithmic art purists - like Dr2 - happy. :)\n    vec3 tx = tex(uv*1.);\n    tx = smoothstep(0.05, .5, tx);\n    tx *= vec3(.8, 1, 1.2);\n    \n    vec3 col = mix(bg, latCol, smoothstep(0., .01, mask))*mix(tx, vec3(1.25), .5);\n    \n    \n    // Haphazard sinusoidal overlay to give the impression that some extra lighting is happening. \n    // No science - It's there to make the structure look more shiny. :)\n    col *= mix(vec3(1.1), vec3(.7), dot(sin(uv*3.14159 - cos(uv.yx*3.14159)*3.14159), vec2(.25)) + .5);\n   \n  \n    // More depth... thrown in as an afterthought. \n    col = mix(col, vec3(0), (1. - smoothstep(0., .2, d))*.35);\n\n    // Edge lines.\n    col = mix(col, vec3(cDist/32.), (1. - smoothstep(0., .01, d - .03))); // Edge line depth.\n    col = mix(col, vec3(.2), (1. - smoothstep(0., .01, d))*.9); // Edge lines.\n    col = mix(col, vec3(0), (1. - smoothstep(0., .05, d))*.35); // Softer structure shadows.\n  \n    \n \t// Using the distance field to add a bit of shine.\n    float shine = smoothstep(0., .075, d - .15);\n \tcol += col*vec3(.5, .7, 1)*shine*.5;        \n\n    \n    // Shadow for the overlapped sections to give a bit of fake depth.\n    col = mix(col, vec3(0), (1. - smoothstep(0., .5, sh))*.9); \n    \n    \n    \n    // Lamest lighting and environmental mapping ever. :)\n    col += mix(vec3(1), red.yzx, .5)*col*smoothstep(0., .35, vor - .25)*.5;\n    \n    \n\n     \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125);\n    // Colored variation.\n    //col = mix(pow(min(vec3(1.5, 1, 1).zyx*col, 1.), vec3(1, 3, 16)), col, \n             //pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125)); \n\n    \n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}