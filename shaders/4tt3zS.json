{
    "Shader": {
        "info": {
            "date": "1469996140",
            "description": "In a project, I'm generating normals from a heightmap, and the lighting looks pixellated at high magnification levels. I realized that the derivative function I was using doesn't work well with bilinear interpolation, but bicubic makes it much better. \n",
            "flags": 0,
            "hasliked": 0,
            "id": "4tt3zS",
            "likes": 9,
            "name": "Bicubic heightmap normals",
            "published": 3,
            "tags": [
                "bicubic",
                "texturefiltering"
            ],
            "usePreview": 0,
            "username": "kj12345",
            "viewed": 1414
        },
        "renderpass": [
            {
                "code": "vec4 cubic(float v) {\n    vec4 n = vec4(1.0, 2.0, 3.0, 4.0) - v;\n    vec4 s = n * n * n;\n    float x = s.x;\n    float y = s.y - 4.0 * s.x;\n    float z = s.z - 4.0 * s.y + 6.0 * s.x;\n    float w = 6.0 - x - y - z;\n    return vec4(x, y, z, w);\n}\n\n// http://stackoverflow.com/questions/13501081/efficient-bicubic-filtering-code-in-glsl\nvec4 filterf(sampler2D tex, vec2 uv, vec2 res) {\n    vec2 texcoord = uv * res;\n    texcoord -= vec2(0.5);\n    float fx = fract(texcoord.x);\n    float fy = fract(texcoord.y);\n    texcoord.x -= fx;\n    texcoord.y -= fy;\n\n    vec4 xcubic = cubic(fx);\n    vec4 ycubic = cubic(fy);\n\n    vec4 c = vec4(texcoord.x - 0.5, texcoord.x + 1.5, texcoord.y - 0.5, texcoord.y + 1.5);\n    vec4 s = vec4(xcubic.x + xcubic.y, xcubic.z + xcubic.w, ycubic.x + ycubic.y, ycubic.z + ycubic.w);\n    vec4 offset = c + vec4(xcubic.y, xcubic.w, ycubic.y, ycubic.w) / s;\n\n    vec4 sample0 = texture(tex, vec2(offset.x, offset.z) / res);\n    vec4 sample1 = texture(tex, vec2(offset.y, offset.z) / res);\n    vec4 sample2 = texture(tex, vec2(offset.x, offset.w) / res);\n    vec4 sample3 = texture(tex, vec2(offset.y, offset.w) / res);\n\n    float sx = s.x / (s.x + s.y);\n    float sy = s.z / (s.z + s.w);\n\n    return mix(\n        mix(sample3, sample2, sx),\n        mix(sample1, sample0, sx), sy);\n}\n\n// Based on https://docs.unrealengine.com/latest/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\nvec2 heightDerivative(vec2 texST, sampler2D map) {\n    vec2 TexDx = dFdx(texST);\n    vec2 TexDy = dFdy(texST);\n    vec2 STll = texST;\n    vec2 STlr = texST + TexDx;\n    vec2 STul = texST + TexDy;\n    float Hll = texture(map, STll).x;\n    float Hlr = texture(map, STlr).x;\n    float Hul = texture(map, STul).x;\n    float dBs = Hlr - Hll;\n    float dBt = Hul - Hll;\n    return vec2(dBs, dBt);\n}\n\n\nvec2 heightDerivativeBicubic(vec2 texST, sampler2D map, vec2 res) {\n    vec2 TexDx = dFdx(texST);\n    vec2 TexDy = dFdy(texST);\n    vec2 STll = texST;\n    vec2 STlr = texST + TexDx;\n    vec2 STul = texST + TexDy;\n    float Hll = filterf(map, STll, res).x;\n    float Hlr = filterf(map, STlr, res).x;\n    float Hul = filterf(map, STul, res).x;\n    float dBs = Hlr - Hll;\n    float dBt = Hul - Hll;\n    return vec2(dBs, dBt);\n}\n\nvec3 perturbNormal(vec3 surf_pos, vec3 surf_norm, vec2 dHdxy) {\n  // Calling derivatives per-component to address android bug:\n  // http://stackoverflow.com/questions/20272272/\n  vec3 vSigmaX = vec3(dFdx(surf_pos.x), dFdx(surf_pos.y), dFdx(surf_pos.z));\n  vec3 vSigmaY = vec3(dFdy(surf_pos.x), dFdy(surf_pos.y), dFdy(surf_pos.z));\n  vec3 vN = vec3(normalize(surf_norm)); // normalized\n  vec3 R1 = cross(vSigmaY, vN);\n  vec3 R2 = cross(vN, vSigmaX);\n\n  float fDet = dot(vSigmaX, R1);\n  vec3 vGrad = sign(fDet) * (dHdxy.x * R1 + dHdxy.y * R2);\n  return normalize(abs(fDet) * surf_norm - vGrad);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy / 6.0;\n    float time = fract(iTime / 5.0);\n    vec3 P = vec3(fragCoord.xy / iResolution.xy, 0.0);\n    vec3 N = vec3(0.0, 0.0, 1.0);\n    vec2 dHdxy;\n    if (time > 0.67) {\n      fragColor = texture(iChannel1, uv);\n    }\n    else if (time > 0.33) {\n      dHdxy = heightDerivativeBicubic(uv, iChannel0, iChannelResolution[0].xy);\n      fragColor = vec4(perturbNormal(P, N, dHdxy), 1.0);\n    }\n    else {\n      dHdxy = heightDerivative(uv, iChannel0);\n      fragColor = vec4(perturbNormal(P, N, dHdxy), 1.0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}