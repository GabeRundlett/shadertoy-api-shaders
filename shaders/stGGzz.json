{
    "Shader": {
        "info": {
            "date": "1638765001",
            "description": "Traveling through spinning kaleidocycles with a kaleidoscope sky. Variable number of tetrahedron pairs. Mouse to move/rotate.",
            "flags": 0,
            "hasliked": 0,
            "id": "stGGzz",
            "likes": 21,
            "name": "Kaleidocycles",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "mouse",
                "kaleidoscope",
                "tetrahedron",
                "kaleidocycle"
            ],
            "usePreview": 0,
            "username": "amhall",
            "viewed": 625
        },
        "renderpass": [
            {
                "code": "// A kaleidocycle is created by attaching an even number of tetrahedrons by their\n// edges in a ring. Try changing the number of tetrahedron pairs.\n// Created by Anthony Hall\n\n#define PAIRS 5\n#if PAIRS < 4\n#error\n#endif\n\nconst float pi = radians(180.0);\nconst float twoPi = radians(360.0);\nconst float radialSlice = twoPi / float(PAIRS);\n\nconst float maxDistance = 80.0;\nconst float epsilon = 0.004;\n\n// Many of these globals are set/modified in mainImage\nvec3 cameraPos = vec3(0.0);\nvec3 cameraDest = vec3(0.0, 0.0, -15.0); // z is relative to cameraPos\nconst float fov = radians(50.0); // FOV of y axis\n\n// Transforms the point evaluating the SDF\nmat4 sceneTransform = mat4(1.0);\n\n// Transforms actual points on the tetrahedron\nmat4 forwardTransform = mat4(1.0);\n\n// Must be strictly greater than 2sqrt6 (4.899)\nconst float zRepeat = 15.0;\n\nfloat time;\n\nfloat linestep(float a, float b, float x)\n{\n    return clamp((x - a) / (b - a), 0.0, 1.0);\n}\n\nmat2 rotate(float theta)\n{\n    vec2 cs = vec2(cos(theta), sin(theta));\n    return mat2(\n        cs.x, cs.y,\n        -cs.y, cs.x);\n}\n\nmat4 translate(vec3 offset)\n{\n    return mat4(\n        1, 0, 0, 0,\n        0, 1, 0, 0,\n        0, 0, 1, 0,\n        offset, 1);\n}\n\nmat4 xyRotate(float theta)\n{\n    vec2 cs = vec2(cos(theta), sin(theta));\n    return mat4(\n        cs.x, cs.y, 0, 0,\n        -cs.y, cs.x, 0, 0,\n        0, 0, 1, 0,\n        0, 0, 0, 1);\n}\n\nmat4 yzRotate(float theta)\n{\n    vec2 cs = vec2(cos(theta), sin(theta));\n    return mat4(\n        1, 0, 0, 0,\n        0, cs.x, cs.y, 0,\n        0, -cs.y, cs.x, 0,\n        0, 0, 0, 1);\n}\n\nmat4 xzRotate(float theta)\n{\n    vec2 cs = vec2(cos(theta), sin(theta));\n    return mat4(\n        cs.x, 0, cs.y, 0,\n        0, 1, 0, 0,\n        -cs.y, 0, cs.x, 0,\n        0, 0, 0, 1);\n}\n\n// Tetrahedron bound SDF by yx\n// https://www.shadertoy.com/view/Ws23zt\nfloat sdTetrahedron(vec3 p)\n{\n    return (max(\n        abs(p.x+p.y)-p.z,\n        abs(p.x-p.y)+p.z\n    )-1.)/sqrt(3.);\n}\n\n// This scene transforms space for a tetrahedron. The original tetrahedron is at the top\n// just right of the x axis\nfloat scene(vec3 point)\n{\n    // Repeat z regions\n    point.z = mod(point.z, zRepeat) - 0.5 * zRepeat;\n    \n    // Worst case distance for nearest neighboring z region\n    float bound = zRepeat - sqrt(6.0) - abs(point.z);\n    \n    // Duplicate radially\n    float r = length(point.xy);\n    float theta = atan(point.y, point.x);\n    theta = mod(theta - 0.5 * pi + 0.5 * radialSlice, radialSlice) - 0.5 * radialSlice;\n    point.xy = r * vec2(-sin(theta), cos(theta));\n    \n    // Fold in each radial region\n    point.x = abs(point.x);\n    \n    // Rotate/translate\n    point = (sceneTransform * vec4(point, 1.0)).xyz;\n    \n    return min(sdTetrahedron(point), bound);\n}\n\nvec3 estimateNormal(vec3 point, float distAtIntersect)\n{\n    const vec2 k = vec2(0.0, epsilon);\n\treturn normalize(vec3(\n        scene(point + k.yxx),\n        scene(point + k.xyx),\n        scene(point + k.xxy)) - distAtIntersect);\n}\n\n// Inspired by Inigo Quilez's procedural color palette method\n// https://iquilezles.org/articles/palettes\nvec3 palette(float t)\n{\n    return vec3(\n        0.3 + 0.3 * cos(t + 2.0),\n        0.5 + 0.5 * cos(t + 1.0),\n        0.8 + 0.2 *cos(t));\n}\n\n// Perpendicular distance to the edges of an equilateral triangle\nfloat pdTriangle(vec2 point)\n{\n    float r = length(point);\n    float theta = atan(point.y, point.x);\n    theta = mod(theta - pi / 6.0, twoPi / 3.0) + pi / 6.0;\n    return r * sin(theta);\n}\n\n// Makes a kaleidoscope of various triangles using distance functions. Perhaps it's\n// a bit bright/distracting but the glow coloring was my best color attempt\nvec3 sky(vec3 normal)\n{\n    // Maps the range [-1, 1] onto the sphere. Pretty wonky around the meridian\n    vec2 point = 2.0 * asin(normal.xy) / pi;\n    \n    // Duplicate radially\n    float r = length(point.xy);\n    float theta = atan(point.y, point.x);\n    theta = mod(theta - 0.5 * pi + 0.5 * radialSlice, radialSlice) - 0.5 * radialSlice;\n    point.xy = r * vec2(-sin(theta), cos(theta));\n    \n    // Fold in each radial region\n    point.x = abs(point.x);\n    \n    // Get the minimum distance to a bunch of shapes\n    float dist = 1e5;\n    \n    // First, 6 inscribed triangles that rotate, move a bit, and change size\n    float rotTheta = mod(0.2 * time, twoPi / 3.0) - pi / 3.0;\n    mat2 triRotate = rotate(rotTheta + pi / 3.0);\n    float inscribeScale = 0.5 / cos(rotTheta);\n    \n    vec2 triPoint = triRotate * (point - vec2(0.05 + 0.05 * cos(0.11 * time), 0.2));\n    float scale = 1.0;\n    float baseSize = 0.1 + 0.1 * cos(0.23 * time);\n    \n    for (int i = 0; i < 6; i++)\n    {\n        dist = min(dist, abs(pdTriangle(triPoint) - baseSize * scale));\n        scale *= inscribeScale;\n        triPoint = triRotate * triPoint;\n    }\n    \n    // Next, a triangle that \"radiates\" fading rings\n    triPoint = point;\n    triPoint.y = 0.5 - abs(triPoint.y - 0.5);\n    triPoint -= vec2(0.0, 0.35 + 0.05 * cos(0.212 * time));\n    triPoint.y = -triPoint.y;\n    dist = min(dist, abs(pdTriangle(triPoint)));\n    \n    float partialLevel = fract(0.333 * time);\n    float spacing = 0.075;\n    float radius = spacing * partialLevel;\n    \n    for (float i = 0.0; i < 4.0; i+= 1.0)\n    {\n        float level = i + partialLevel;\n        float extraDist = 0.01 * pow(level, 1.8);\n        dist = min(dist, abs(pdTriangle(triPoint) - radius) + extraDist);\n        radius += spacing;\n    }\n    \n    // Finally, collection of triangles by the meridian. This is mainly so that the\n    // reflection of the tetrahedrons will catch something interesting\n    triPoint = (point - vec2(0.15, 0.7)) * triRotate;\n    dist = min(dist, abs(pdTriangle(triPoint) - 0.05));\n    \n    float triR = length(triPoint);\n    float triTheta = atan(triPoint.x, triPoint.y);\n    triTheta = mod(triTheta, twoPi / 3.0) + pi / 6.0;\n    triPoint = triR * vec2(cos(triTheta), sin(triTheta));\n    triPoint -= vec2(0., 0.1);\n    dist = min(dist, abs(pdTriangle(triPoint) - 0.035));\n    \n    // Vary the glow intensity over time, with a slight wave effect\n    float intensity = 3.0 - sin(60.0 * point.y - 3.0 * time) * sin(2.22 * time) - cos(time);\n    return pow( vec3(linestep(1.0, 0.0, dist)), intensity * vec3(20.0, 50.0, 7.0));\n}\n\nvec3 shadeSurface(vec3 point, vec3 normal, vec3 incident)\n{\n    // Since the brightest parts of the sky are around +/- z, the lights are close to \n    // the axis. They are not exactly on the axis because this causes mirrored faces\n    // to have the exact same shading and it's too hard to distinguish them\n    const vec3 toLight1 = normalize(vec3(2, 1, 6));\n    const vec3 toLight2 = normalize(vec3(-2, 1, -6));\n    \n    float diffuse1 = max(dot(normal, toLight1), 0.0);\n    float diffuse2 = max(dot(normal, toLight2), 0.0);\n    \n    // Add a bit of ambient\n    float diffuse = 0.1 + 0.9 * (diffuse1 + diffuse2);\n    \n    // The \"specular\" lighting glows purple toward the lights. It can be thought of\n    // as an approximation of a very blurred version of the sky map\n    vec3 bisector1 = normalize(toLight1 - incident);\n    vec3 bisector2 = normalize(toLight2 - incident);\n    \n    // Linesteps make sure no specular reflection happens when the surface normal faces\n    // away from the light\n    float specular1 = dot(normal, bisector1) * linestep(0.0, 0.15, diffuse1);\n    float specular2 = dot(normal, bisector2) * linestep(0.0, 0.15, diffuse2);\n    \n    vec3 specular = pow(vec3((specular1 + specular2)), vec3(3.0, 6.0, 1.5));\n    \n    vec3 skyColor = sky(reflect(incident, normal));\n    vec3 surface = palette(atan(point.y, point.x) + 0.475 * point.z + 0.8 * time);\n    \n    // Gamma correct diffuse intensity\n    return min(0.9 * pow(diffuse, 1.0 / 2.2) * surface + 0.3 * specular  + 0.2 * skyColor, 1.0);\n}\n\n// Returns the result color of casting any ray\nvec3 castRay(vec3 rayOrigin, vec3 rayDir)\n{\n    vec3 skyColor = sky(rayDir);\n    vec3 color = skyColor;\n    vec3 point = rayOrigin;\n    float t;\n    \n    for (t = 0.0; t < maxDistance; point = rayOrigin + t*rayDir)\n    {\n     \tfloat dist = scene(point);\n        if (dist <= epsilon)\n        {\n            vec3 normal = estimateNormal(point, dist);\n            color = shadeSurface(point, normal, rayDir);\n        \tbreak;\n        }\n        t += dist;\n    }\n    // Fade into distance\n    float distFade = t / maxDistance;\n    distFade = linestep(0.4, 1.0, distFade);\n    return mix(color, skyColor, distFade);\n}\n\n//Rotates rays so that they point to the center from the camera\nmat3 rotateRay(vec3 camera, vec3 center, vec3 up)\n{\n    vec3 forward = normalize(center - camera);\n    vec3 right = normalize(cross(forward, up));\n    up = cross(right, forward);\n    return mat3(right, up, -forward);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Globals - time, mouse, rotation matrices\n    time = iTime;\n    \n    vec2 mouse = float(iMouse.z > 0.0) * vec2(\n        4.0 * iMouse.x / iResolution.x - 2.0,\n        iMouse.y / iResolution.y);\n    \n    // First, spin the tetrahedron around the x axis\n    mat4 spin = yzRotate(0.6 * time +  mouse.x);\n    \n    // Use the spin to figure out how much we need to rotate on the hinge\n    // in order to be facing the proper direction to connect with the neighbor\n    float thetaToNeighbor = -pi / float(PAIRS);\n    vec2 cs = vec2(cos(thetaToNeighbor), sin(thetaToNeighbor));\n    vec4 hingeDir = vec4(cs.x, cs.y, 0.0, 1.0);\n    hingeDir = spin * hingeDir;\n    float hingeTheta = atan(hingeDir.y, hingeDir.x);\n    \n    // Rotate on the hinge about (-1, 0, 0)\n    mat4 translate1 = translate(vec3(1, 0, 0));  \n    mat4 hingeRot = xyRotate(-hingeTheta);\n    mat4 translate2 = translate(vec3(-1, 0, 0));\n        \n    // Final correction\n    mat4 finalRot = yzRotate(0.25 * pi);\n    \n    forwardTransform = transpose(spin) \n        * transpose(hingeRot)\n        * translate1\n        * transpose(finalRot);\n    \n    // The last thing to do is figure out how much to raise the tetrahedron\n    // This is done by rotating one vertex and calculating its new offset from\n    // the plane bordering the radial neighbor\n    \n    vec2 vertexPos = ((forwardTransform) * vec4(1.0)).xy;\n    float yOffset = cs.x * vertexPos.x / cs.y + vertexPos.y;\n    \n    sceneTransform = finalRot\n        * translate2\n        * hingeRot\n        * translate1\n        * spin\n        * translate(vec3(-1, yOffset, 0));\n\n    cameraPos.z = -2.0 * time - 30.0 * mouse.y;  \n    \n    vec2 point = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\tvec3 rayDir = normalize(vec3(point * tan(fov/2.0), -1.0));\n    \n    // Since the camera is looking along the -z axis, we don't need full rotation matrices\n    // for the rays or up vector. If you want to change the camera destination, replace\n    // the following 2D rotation with the commented code\n    \n    rayDir.xy = rotate(0.05 * time) * rayDir.xy;\n    //vec3 up = vec3(sin(0.05 * time), cos(0.05 * time), 0.0);\n    //up = rotateRay(cameraPos, vec3(0, 0, cameraPos.z) + cameraDest, vec3(0, 1, 0) * up;\n    //rayDir = rotateRay(cameraPos, vec3(0, 0, cameraPos.z) + cameraDest, up) * rayDir;\n \n    fragColor = vec4(castRay(cameraPos, rayDir), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}