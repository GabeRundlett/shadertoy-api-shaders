{
    "Shader": {
        "info": {
            "date": "1723095958",
            "description": "https://glslsandbox.com/e#60085.0 https://www.shadertoy.com/view/MfByW3",
            "flags": 0,
            "hasliked": 0,
            "id": "lc2cW3",
            "likes": 1,
            "name": "fractal with rotation ",
            "published": 3,
            "tags": [
                "fractal"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 63
        },
        "renderpass": [
            {
                "code": "#define time iTime\n#define resolution iResolution.xy\n\n#define float2   vec2\n#define float3   vec3\n#define float4   vec4\n#define lerp     mix\n#define atan2    atan\n#define frac     fract\n#define fmod     mod\n#define float2x2 mat2     \n#define mul(a, b) a*b \n#define texSampl 1.\n#define Texture2DSample(iChannel0, texSampl, uv) texture(iChannel0, uv)\n#define ddx dFdx\n#define ddy dFdy\n#define saturate(oo) clamp(oo, 0.0, 1.0)\n//// end GLSL -> HLSL\n\n//// stuct for UE material custom node\n\n// struct Func {\n\nfloat rand(float2 n) {return frac(sin(dot(n, float2(12.9898, 78.233))) * 43758.5453);}\n\nfloat noise(float2 p) {\n    float2 i = floor(p), f = frac(p);\n    f = f*f*(3.-2.*f);\n    return lerp(lerp(rand(i), rand(i + float2(1.,0.)), f.x), lerp(rand(i + float2(0.,1.)), rand(i+float2(1.,1.)), f.x), f.y);\n}\n\nfloat fbm(float2 p) {\n    float v = 0., a = .5;\n    for (int i = 0; i < 5; i++) {v+=a*noise(p); p*=2.; a*=.5;}\n    return v;\n}\n\nfloat noiseImage(float2 uv) {return fbm(uv*10.);}\n\nfloat snoise(float3 uv, float res) {\n\tconst float3 s = float3(1e0, 1e2, 1e4);\n\tuv *= res;\n\tfloat3 uv0 = floor(fmod(uv, res))*s;\n\tfloat3 uv1 = floor(fmod(uv+float3(1.,1.,1.), res))*s;\n\tfloat3 f = frac(uv); f = f*f*(3.-2.*f);\n\tfloat4 v = float4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z, uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\n\tfloat4 r = frac(sin(v*1e-3)*1e5);\n\tfloat r0 = lerp(lerp(r.x, r.y, f.x), lerp(r.z, r.w, f.x), f.y);\n\tr = frac(sin((v + uv1.z - uv0.z)*1e-3)*1e5);\n\tfloat r1 = lerp(lerp(r.x, r.y, f.x), lerp(r.z, r.w, f.x), f.y);\n\treturn lerp(r0, r1, f.z)*2.-1.;\n}\n\nfloat res(float2 uv, float time) {\t\n    time *= 0.1;\n\tfloat aspect = 1.7, iColor = 1., brightness = .1, starSphere= 0.;\n    \n\tfloat radius\t= .24 + brightness*.2;\n\tfloat invRadius = 1./radius;\n\tfloat2 p \t\t= -.5 + uv;\n\tp.x *= aspect;\n\tfloat fade\t\t= pow(length(2.*p),.5);\n\tfloat fVal\t\t= 1.-fade;\n\tfloat angle\t\t= atan2( p.x, p.y )/3.14;\n\tfloat dist\t\t= length(p);\n\tfloat3 coord\t= float3(angle, dist, time*.1);\n    float corona\t= pow(fVal* max(1.1-fade,0.),2.)*50.;\n\tcorona\t\t\t+= pow(fVal*max(1.1-fade,0.),2.)*50.;\n\tcorona\t\t\t*= 1.2-abs( snoise( coord + float3(0.,-time*(.35+brightness*.001),time*.015),15.));\t\n\tfloat2 sp = -1.+2.* uv;\n\tsp.x *= aspect;\n\tsp *= ( 2. - brightness );\n  \tfloat r = dot(sp,sp);\n\tfloat f = (1.-sqrt(abs(1.-r)))/(r)+brightness*.5;\n\tif( dist < radius ){\n\t\tcorona *= pow(dist*invRadius,24.);\n  \t\tfloat2 newUv = sp*f;\n\t\tnewUv += float2(time,0.);\n\t\tfloat texSample\t= noiseImage(newUv);\n\t\tfloat uOff\t= (texSample * brightness*4.5+time);\n\t\tfloat2 starUV = newUv + float2(uOff, 0.);\n\t\tstarSphere\t= noiseImage(starUV);\n\t}\n    return f*(.75+brightness*.3)+starSphere*iColor*.3+corona*iColor;\n    }\n \nfloat shape(vec3 pos, float size) {\n\tpos = abs(pos);\n   \n\t\tfloat t = time*0.03;\n\n\t mat2 m = mat2(cos(t),-sin(t),sin(t),cos(t));\n\n\t\n\tvec3 pos2 = pos-size*.8;\n    pos2.xz *= m;\n\tpos2.xy *= m;\n\treturn max(dot(pos,vec3(1./sqrt(5.)))-size*.08, size-length(pos2));\n}\n\nfloat dist(vec3 pos) {\n\tfloat scale = 1.;\n\tfloat scalef = 0.4;\n\tfloat size = 1./(scalef*(1.+scalef));\n\t// size*(1 + scalef) = 1/scalef\n\tfloat t = time*.3;\n\n\t\n    mat2 m = mat2(cos(t),-sin(t),sin(t),cos(t));\npos.xz *= m;\n\tfloat result = shape(pos,scale*size);\n\t\n\tfor (int i = 0; i < 15; i++) {\n\t\tpos.yz *= m;\n        mat2 m = mat2(cos(t),-sin(t),sin(t),cos(t));\n\t\n\n\t\tpos = abs(pos);\n\t\tfloat a = max(max(pos.x,pos.y),pos.z);\n\t\tfloat b = min(min(pos.x,pos.x),pos.z);\n\t\tpos = vec3(a,pos.x+pos.y+pos.z-a-b,b);\n\t\tpos.x -= scale/scalef;\n\n\t\tscale *= scalef;\n\t\tresult = min(result, shape(pos, scale*size));\n\t}\n\t\n\treturn result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = ( gl_FragCoord.xy - resolution.xy*.5 )/resolution.y;\n\t\n\tvec3 pos = vec3(0,0,-10);\n\tvec3 dir = normalize(vec3(uv, 1.));\n  float t = iTime;\n  \n   \n\tfloat total = 0.;\n\tfloat gi = 0.;\n\tvec2 e = vec2(0.0005,0);\n\tvec3 color = vec3(0);\n\tvec3 pos0;\n\tfloat luma = 1.;\n\tfor (int i = 0; i < 112; i++) {\n\t\tfloat d = dist(pos);\n\t\tif (d > 1e3) break;\n\t\tif (d < 1e-3) {\n\t\t\tvec3 n = normalize(vec3(dist(pos+e.xyy),dist(pos+e.yxy),dist(pos+e.yyx))-d);\n\t\t\tif (dot(n,dir) < 0.) {\n\t\t\t\tdir = reflect(dir,n);\n\t\t\t\t//color += (n.zxy*.25+.5+dot(n,vec3(.1)))*luma;\n\t\t\t\tluma *= .55;\n\t\t\t}\n\t\t}\n\t\ttotal += d;\n\t\tgi += 1./(max(d,0.)+.03);\n\t\tpos += dir*d;\n\t}\n\n\tfloat d = dist(pos);\n\tvec3 n = normalize(vec3(dist(pos+e.xyy),dist(pos+e.yxy),dist(pos+e.yyx))-d);\n\t\n\t\n\tcolor += (-dir.xyz*.25+.5+dot(dir,vec3(.1)))*luma;\n\t\n\tfragColor = vec4( sqrt(color),1);\n fragColor+= vec4(res(uv+0.5, t)*vec4(.2,.5,1.,1.));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}