{
    "Shader": {
        "info": {
            "date": "1673100257",
            "description": "Fills triangles with textures. Depth corrected. 2^SIZE is how many times faster it gets.",
            "flags": 32,
            "hasliked": 0,
            "id": "clSGDz",
            "likes": 0,
            "name": "3D Tri Rasterizer",
            "published": 3,
            "tags": [
                "triangles"
            ],
            "usePreview": 0,
            "username": "raymarchingenthusiast",
            "viewed": 202
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord) {    \n    vec2 uv = (fragCoord/SIZE)/iResolution.xy;\n    fragColor = texture(iChannel0,uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define TriCount 6\n#define PI 3.14159265\n#define SIZE 2.5\n\nstruct Triangle {\n    vec3 a;\n    vec3 b;\n    vec3 c;\n};\n\nstruct TriDat {\n    Triangle Vp;\n    Triangle Vuv;\n    bool flipNorm;\n    int colMode;\n};\n\nvoid rotX(inout vec3 p, vec2 at) {\n    p.y = at.x*p.y-at.y*p.z;\n    p.z = at.y*p.y+at.x*p.z;\n}\n\nvoid rotY(inout vec3 p, vec2 at) {\n    p.x = at.y*p.z+at.x*p.x;\n    p.z = at.x*p.z-at.y*p.x;\n}\n\nvoid rotZ(inout vec3 p, vec2 at) {\n    p.x = at.x*p.x+at.y*p.y;\n    p.y = at.y*p.x-at.x*p.y;\n}\n\nvec3 crd(vec2 iMouse,vec2 uv) {\n    vec3 rd = normalize(vec3(uv,1.));\n    vec2 ra = PI*(vec2(0.,0.)-3.*iMouse);\n    rotY(rd,vec2(cos(ra.x),sin(ra.x)));\n    rotX(rd,vec2(cos(ra.y),sin(ra.y)));\n    //rd.y *= -1.;\n    return rd;\n}\n\nvoid SetTri(inout TriDat t[TriCount], int i,\n  vec3 v1,vec3 v2,vec3 v3,\n  vec2 uv1,vec2 uv2, vec2 uv3,\n  bool fn, int txtr) {\n    t[i] = TriDat(Triangle(v1,v2,v3),Triangle(vec3(uv1,1.),vec3(uv2,1.),vec3(uv3,1.)),fn,txtr);\n}\n\nvoid SetTriData(out TriDat t[TriCount],float iTime) {\n    SetTri(t,0,vec3(-1.,-1.,1.),vec3(-1.,2.,1.),vec3(2.,-1.,1.),vec2(0.,0.),vec2(0.,1.),vec2(1.,0.),false,0);\n    SetTri(t,1,vec3(2.,-1.,1.),vec3(2.,2.,1.),vec3(-1.,2.,1.),vec2(1.,0.),vec2(1.,1.),vec2(0.,1.),true,0);\n    SetTri(t,2,vec3(-1.,-1.,1.),vec3(-1.,2.,1.),vec3(-1.,-1.,4.),vec2(0.,0.),vec2(0.,1.),vec2(1.,0.),true,0);\n    SetTri(t,3,vec3(-1.,2.,1.),vec3(-1.,2.,4.),vec3(-1.,-1.,4.),vec2(0.,1.),vec2(1.,1.),vec2(1.,0.),true,0);\n    SetTri(t,4,vec3(2.,-1.,1.),vec3(2.,2.,1.),vec3(2.,-1.,4.),vec2(0.,0.),vec2(0.,1.),vec2(1.,0.),false,0);\n    SetTri(t,5,vec3(2.,2.,1.),vec3(2.,2.,4.),vec3(2.,-1.,4.),vec2(0.,1.),vec2(1.,1.),vec2(1.,0.),false,0);\n}\n\nvoid SplitTriDat(TriDat t[TriCount],out Triangle tp[TriCount],out Triangle tuv[TriCount]) {\n    for(int i = 0; i < TriCount; i++) {\n        tp[i] = t[i].Vp;\n        tuv[i] = t[i].Vuv;\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void RecalibTris(inout Triangle tso[TriCount], vec3 ro) {\n    for(int i = 0; i < TriCount; i++) {\n        vec3 a = vec3(tso[i].a.xy-.5,tso[i].a.z);\n        vec3 b = vec3(tso[i].b.xy-.5,tso[i].b.z);\n        vec3 c = vec3(tso[i].c.xy-.5,tso[i].c.z);\n        a -= ro;\n        b -= ro;\n        c -= ro;\n        tso[i] = Triangle(a,b,c);\n    }\n}\n\nvec3 CalcNorm(Triangle t) {\n    vec3 U = t.b-t.a;\n    vec3 V = t.c-t.a;\n    \n    vec3 n;\n    \n    n.x = U.y*V.z - U.z*V.y;\n    n.y = U.z*V.x - U.x*V.z;\n    n.z = U.x*V.y - U.y*V.x;\n    \n    return normalize(n);\n}\n\nvec2 CalcUv(vec2 p, Triangle tp, Triangle tuv, Triangle top, out vec3 pos, out float depth) {\n    float w1p1 = (tp.b.y-tp.c.y)*(p.x-tp.c.x)+(tp.c.x-tp.b.x)*(p.y-tp.c.y);\n    float w1p2 = (tp.b.y-tp.c.y)*(tp.a.x-tp.c.x)+(tp.c.x-tp.b.x)*(tp.a.y-tp.c.y);\n    float w1 = w1p1/w1p2;\n    \n    float w2p1 = (tp.c.y-tp.a.y)*(p.x-tp.c.x)+(tp.a.x-tp.c.x)*(p.y-tp.c.y);\n    float w2p2 = (tp.b.y-tp.c.y)*(tp.a.x-tp.c.x)+(tp.c.x-tp.b.x)*(tp.a.y-tp.c.y);\n    float w2 = w2p1/w2p2;\n    \n    float w3 = 1. - w1 - w2;\n    \n    //vec3 auv = w1*tuv.a + w2*tuv.b + w3*tuv.c;\n    vec3 puv = w1*tuv.a/tp.a.z + w2*tuv.b/tp.b.z + w3*tuv.c/tp.c.z;\n    vec4 p0a = vec4(top.a,1.);\n    vec4 p0b = vec4(top.b,1.);\n    vec4 p0c = vec4(top.c,1.);\n    vec4 p1 = w1*p0a/p0a.z + w2*p0b/p0b.z + w3*p0c/p0c.z;\n    vec2 z0a = vec2(tp.a.z,1.);\n    vec2 z0b = vec2(tp.b.z,1.);\n    vec2 z0c = vec2(tp.c.z,1.);\n    vec2 z1 = w1*z0a/z0a.x + w2*z0b/z0b.x + w3*z0c/z0c.x;\n    \n    depth = z1.x / z1.y;\n    pos = p1.xyz / p1.w;\n    return puv.xy / puv.z;\n}\n\nbool isInside(vec2 p, Triangle tri) {\n    float s = (tri.a.x-tri.c.x)*(p.y-tri.c.y)-(tri.a.y-tri.c.y)*(p.x-tri.c.x);\n    float t = (tri.b.x-tri.a.x)*(p.y-tri.a.y)-(tri.b.y-tri.a.y)*(p.x-tri.a.x);\n    \n    if((s<0.) != (t<0.) && s != 0. && t  != 0.) return false;\n    \n    float d = (tri.c.x-tri.b.x) * (p.y - tri.b.y) - (tri.c.y - tri.b.y) * (p.x - tri.b.x);\n    return d == 0. || (d<0.) == (s+t <= 0.);\n}\n\nvec3 projVert(in vec3 v, vec2 ra) {\n    rotY(v,vec2(cos(-ra.x),sin(-ra.x)));\n    rotX(v,vec2(cos(-ra.y),sin(-ra.y)));\n    return v;\n}\n\nTriangle Project(Triangle to,vec2 Mouse) {\n    vec2 ra = PI*(vec2(0.,0.)-3.*Mouse);\n    \n    vec3 a = projVert(to.a,ra);\n    \n    vec3 b = projVert(to.b,ra);\n    \n    vec3 c = projVert(to.c,ra);\n    \n    a.xy /= a.z;\n    b.xy /= b.z;\n    c.xy /= c.z;\n    return Triangle(a,b,c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord0 ) {    \nvec2 fragCoord = fragCoord0 * SIZE;\nvec2 iResolution1 = iResolution.xy;\nvec2 uv = fragCoord / iResolution1;\nvec2 uMouse = iMouse.xy * SIZE;\nuMouse /= SIZE;\nif(uv.x <= 1. && uv.y <= 1.) {\n    uv -= .5;\n    vec2 MOUSE = (uMouse/iResolution1)-.5;\n    if(uMouse == vec2(0.)) MOUSE = vec2(0.);\n    \n    TriDat tris[TriCount];\n    SetTriData(tris,iTime);\n    \n    \n    Triangle tos[TriCount];\n    Triangle uvs[TriCount];\n    \n    SplitTriDat(tris,tos,uvs);\n    \n    vec3 rd = crd(MOUSE,uv);\n    vec3 centrRd = crd(MOUSE,vec2(0.));\n    vec3 ro = vec3(.5,.5,-1.)-crd(MOUSE,vec2(0.))*8.;\n    //ro = vec3(0.,0.,-2.5);\n    RecalibTris(tos,ro);\n    vec3 ld = vec3(.5,.5,5.*sin(iTime)+1.);\n    \n    fragColor = vec4(0.,0.,.3,100.);\n    for(int i = 0; i < TriCount; i++) {\n        Triangle ts = Project(tos[i],MOUSE);\n        if(isInside(uv,ts)&& !(ts.a.z<=0.||ts.b.z<=0.||ts.c.z<=0.)) {\n            vec3 p;\n            float d;\n            vec2 textureUv = CalcUv(uv,ts,uvs[i],tos[i],p,d);\n            \n            vec3 col = texture(iChannel0,textureUv).xyz;\n            \n            vec3 n = CalcNorm(tos[i]);\n            if(tris[i].flipNorm) n *= -1.;\n            //if sign of n dot centrRd != -1. {proceed}\n            \n            float dif = clamp(dot(n,normalize(ld-p)),0.,1.)*.5+.5;\n            col *= dif;\n            vec3 h = normalize(rd+normalize(ld-p));\n            col += .5* dif * vec3(pow(clamp(dot(h,n),0.,1.),30.));\n            \n            if(d<fragColor.w) fragColor = vec4(col,d);\n            if(textureUv.x>1.||textureUv.x<0.||textureUv.y>1.||textureUv.y<0.) fragColor = vec4(.15,.15,3.,d);\n        }\n    }\n    //fragColor.xyz = rd;\n    fragColor.w = 1.;\n}}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}