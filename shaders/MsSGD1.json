{
    "Shader": {
        "info": {
            "date": "1387033764",
            "description": "Hand-drawn effect with hatching and edge detection! Drag the mouse around! Shadows got broken recently, so I removed them...",
            "flags": 0,
            "hasliked": 0,
            "id": "MsSGD1",
            "likes": 321,
            "name": "Hand-drawn Sketch",
            "published": 3,
            "tags": [
                "3d",
                "raymarch",
                "cartoon",
                "sketch",
                "pencil",
                "hand",
                "drawn",
                "paper",
                "hatch",
                "hatching"
            ],
            "usePreview": 1,
            "username": "HLorenzi",
            "viewed": 17993
        },
        "renderpass": [
            {
                "code": "// Hand-drawn Sketch Effect, by hlorenzi\n\n#define EDGE_WIDTH 0.15\n#define RAYMARCH_ITERATIONS 40\n#define SHADOW_ITERATIONS 50\n#define SHADOW_STEP 1.0\n#define SHADOW_SMOOTHNESS 256.0\n#define SHADOW_DARKNESS 0.75\n\n// Distance functions from iquilezles.org\nfloat fSubtraction(float a, float b) {return max(-a,b);}\nfloat fIntersection(float d1, float d2) {return max(d1,d2);}\nvoid fUnion(inout float d1, float d2) {d1 = min(d1,d2);}\nfloat pSphere(vec3 p, float s) {return length(p)-s;}\nfloat pRoundBox(vec3 p, vec3 b, float r) {return length(max(abs(p)-b,0.0))-r;}\nfloat pTorus(vec3 p, vec2 t) {vec2 q = vec2(length(p.xz)-t.x,p.y); return length(q)-t.y;}\nfloat pTorus2(vec3 p, vec2 t) {vec2 q = vec2(length(p.xy)-t.x,p.z); return length(q)-t.y;}\nfloat pCapsule(vec3 p, vec3 a, vec3 b, float r) {vec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 ); return length( pa - ba*h ) - r;}\n\nfloat distf(vec3 p)\n{\n\tfloat d = 100000.0;\n\t\n\tfUnion(d, pRoundBox(vec3(0,0,10) + p, vec3(21,21,1), 1.0));\n\tfUnion(d, pSphere(vec3(10,10,0) + p, 8.0));\n\tfUnion(d, pSphere(vec3(16,0,4) + p, 4.0));\n\tfUnion(d, pCapsule(p, vec3(10,10,12), vec3(15,15,-6.5), 1.5));\n\tfUnion(d, pCapsule(p, vec3(10,10,12), vec3(5,15,-6.5), 1.5));\n\tfUnion(d, pCapsule(p, vec3(10,10,12), vec3(10,5,-6.5), 1.5));\n\tfUnion(d, pTorus(vec3(15,-15,0) + p, vec2(6,2)));\n\tfUnion(d, pTorus2(vec3(10,-15,0) + p, vec2(6,2)));\n\tfUnion(d, pRoundBox(vec3(-10,10,-2) + p, vec3(1,1,9), 1.0));\n\tfUnion(d, pRoundBox(vec3(-10,10,-4) + p, vec3(0.5,6,0.5), 1.0));\n\tfUnion(d, pRoundBox(vec3(-10,10,2) + p, vec3(6,0.5,0.5), 1.0));\n\t\n\treturn d;\n}\n\n\nvec3 normal(vec3 p)\n{\n\tconst float eps = 0.01;\n\tfloat m;\n    vec3 n = vec3( (distf(vec3(p.x-eps,p.y,p.z)) - distf(vec3(p.x+eps,p.y,p.z))),\n                   (distf(vec3(p.x,p.y-eps,p.z)) - distf(vec3(p.x,p.y+eps,p.z))),\n                   (distf(vec3(p.x,p.y,p.z-eps)) - distf(vec3(p.x,p.y,p.z+eps)))\n\t\t\t\t );\n    return normalize(n);\n}\n\nvec4 raymarch(vec3 from, vec3 increment)\n{\n\tconst float maxDist = 200.0;\n\tconst float minDist = 0.001;\n\tconst int maxIter = RAYMARCH_ITERATIONS;\n\t\n\tfloat dist = 0.0;\n\t\n\tfloat lastDistEval = 1e10;\n\tfloat edge = 0.0;\n\t\n\tfor(int i = 0; i < maxIter; i++) {\n\t\tvec3 pos = (from + increment * dist);\n\t\tfloat distEval = distf(pos);\n\t\t\n\t\tif (lastDistEval < EDGE_WIDTH && distEval > lastDistEval + 0.001) {\n\t\t\tedge = 1.0;\n\t\t}\n\t\t\n\t\tif (distEval < minDist) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tdist += distEval;\n\t\tif (distEval < lastDistEval) lastDistEval = distEval;\n\t}\n\t\n\tfloat mat = 1.0;\n\tif (dist >= maxDist) mat = 0.0;\n\t\n\treturn vec4(dist, mat, edge, 0);\n}\n\nfloat shadow(vec3 from, vec3 increment)\n{\n\tconst float minDist = 1.0;\n\t\n\tfloat res = 1.0;\n\tfloat t = 1.0;\n\tfor(int i = 0; i < SHADOW_ITERATIONS; i++) {\n        float h = distf(from + increment * t);\n        if(h < minDist)\n            return 0.0;\n\t\t\n\t\tres = min(res, SHADOW_SMOOTHNESS * h / t);\n        t += SHADOW_STEP;\n    }\n    return res;\n}\n\nfloat rand(float x)\n{\n    return fract(sin(x) * 43758.5453);\n}\n\nfloat triangle(float x)\n{\n\treturn abs(1.0 - mod(abs(x), 2.0)) * 2.0 - 1.0;\n}\n\nfloat time;\nvec4 getPixel(vec2 p, vec3 from, vec3 increment, vec3 light)\n{\n\tvec4 c = raymarch(from, increment);\n\tvec3 hitPos = from + increment * c.x;\n\tvec3 normalDir = normal(hitPos);\n\t\n\t\n\tfloat diffuse = 1.0 + min(0.0, dot(normalDir, -light));\n\tfloat inshadow = 0.0;//(1.0 - shadow(hitPos, -light)) * SHADOW_DARKNESS;\n\t\n\tdiffuse = max(diffuse, inshadow);\n\t\n\tif (c.y == 0.0) diffuse = min(pow(length(p), 4.0) * 0.125,1.0);\n\t\n\t\n\tfloat xs = (rand(time * 6.6) * 0.1 + 0.9);\n\tfloat ys = (rand(time * 6.6) * 0.1 + 0.9);\n\tfloat hatching = max((clamp((sin(p.x * xs * (170.0 + rand(time) * 30.0) +\n\t\t\t\t\t\t\tp.y * ys * (110.0 + rand(time * 1.91) * 30.0)) * 0.5 + 0.5) -\n\t\t\t\t\t\t   \t\t(1.0 - diffuse), 0.0, 1.0)),\n\t\t\t\t\t\t (clamp((sin(p.x * xs * (-110.0 + rand(time * 4.74) * 30.0) +\n\t\t\t\t\t\t\tp.y * ys * (170.0 + rand(time * 3.91) * 30.0)) * 0.5 + 0.5) -\n\t\t\t\t\t\t   \t\t(1.0 - diffuse) - 0.4, 0.0, 1.0)));\n\t\n\tvec4 mCol = mix(vec4(1,0.9,0.8,1), vec4(1,0.9,0.8,1) * 0.5, hatching);\n\t\t\t\t\t\n\treturn mix(mCol,vec4(1,0.9,0.8,1) * 0.5,c.z);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\ttime = floor(iTime * 16.0) / 16.0;\n\t// pixel position\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 p = -1.0+2.0*q;\n\tp.x *= -iResolution.x/iResolution.y;\n\tp += vec2(triangle(p.y * rand(time) * 4.0) * rand(time * 1.9) * 0.015,\n\t\t\ttriangle(p.x * rand(time * 3.4) * 4.0) * rand(time * 2.1) * 0.015);\n\tp += vec2(rand(p.x * 3.1 + p.y * 8.7) * 0.01,\n\t\t\t  rand(p.x * 1.1 + p.y * 6.7) * 0.01);\n\t\n\t// mouse\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tvec2 m = iMouse.xy / iResolution.xy;\n\tif (iMouse.x == 0.0 && iMouse.y == 0.0) {\n\t\tm = vec2(time * 0.06 + 1.67, 0.78);\t\n\t}\n\tm = -1.0 + 2.0 * m;\n\tm *= vec2(4.0,-0.75);\n\tm.y += 0.75;\n\n\t// camera position\n\tfloat dist = 50.0;\n\tvec3 ta = vec3(0,0,0);\n\tvec3 ro = vec3(cos(m.x) * cos(m.y) * dist, sin(m.x) * cos(m.y) * dist, sin(m.y) * dist);\n\tvec3 light = vec3(cos(m.x - 2.27) * 50.0, sin(m.x - 2.27) * 50.0, -20.0);\n\t\n\t// camera direction\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 0.0, 1.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n\n\t// calculate color\n\tvec4 col = getPixel(p, ro, rd, normalize(light));\n    col = pow(col, vec4(1.0 / 2.2));\n    col = col * 1.8 - 0.8;\n\tfragColor = col;\n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}