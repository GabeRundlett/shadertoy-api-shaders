{
    "Shader": {
        "info": {
            "date": "1616636899",
            "description": "cloud",
            "flags": 32,
            "hasliked": 0,
            "id": "ssXGDX",
            "likes": 10,
            "name": "Better clouds 3",
            "published": 3,
            "tags": [
                "clouds"
            ],
            "usePreview": 1,
            "username": "MinimilisticBits",
            "viewed": 309
        },
        "renderpass": [
            {
                "code": "//NOT MY CODE///////////\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, fragCoord/iResolution.xy).xyz;\n    col = vec3(1.)-exp(-0.4*col);\n    vec3 a = vec3(0.3,0.7,0.7)-0.1;\n    col = mix(col, smoothstep(0.,1.,col),a);\n    col = ACESFilm(col);\n    col = pow(col, vec3(1./2.2));\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float pi = 3.14159;\nvec2 rot(vec2 a, float c){\nc *= pi/180.;\nfloat l = length(a);\na/=l;\nfloat ang = (a.y<0.0)?2.*pi-acos(a.x):acos(a.x);\nang += c;\nreturn vec2(l*cos(ang), l*sin(ang));\n}\n\nvec3 sky(vec3 d, vec3 ld){\nfloat thetas = dot(ld, vec3(0.,0.,1.));\nfloat theta = dot(d, vec3(0.,0.,1.));\n//if(theta < 0.0)return vec3(0.);\nfloat thetay = dot(d,ld);\nfloat y = acos(thetay);\nfloat taa = dot(-d, vec3(0.,0.,1.));\nfloat tay = dot(-d,ld);\nfloat Fred = (1.0 -1.32004*exp(0.14318/taa))*(1.0+5.30694*exp(-2.48062*y)+0.3167*tay*tay);\nfloat F2 = 1.0-(-0.523242)*(1.0+5.30694*exp(-2.48062*y)+0.3167*thetas*thetas);\nfloat Fblue = (1.0 + -0.27416*exp(-0.0668/taa))*(1.0+0.20388*exp(-1.68898*y)+0.04418*tay*tay);\nif(theta<0.03)return F2*F2*vec3(0.1,0.07,(thetas)*0.1);\n\nreturn 0.2*vec3((1.0 - thetas)*Fred, Fblue*0.4*max(ld.z,0.), Fblue) + F2*F2*vec3(0.1,0.07,(thetas)*0.1);\n}\n\n//NOT MY CODE////////////////////\nmat3 getOrthogonalBasis(vec3 direction){\n    direction = normalize(direction);\n    vec3 right = normalize(cross(vec3(0,1,0),direction));\n    vec3 up = normalize(cross(direction, right));\n    return mat3(right,up,direction);\n}\n\nfloat cyclicNoise(vec3 p){\n    float noise = 0.;\n    \n    // These are the variables. I renamed them from the original by nimitz\n    // So they are more similar to the terms used be other types of noise\n    float amp = 1.;\n    const float gain = 0.6;\n    const float lacunarity = 1.5;\n    const int octaves = 8;\n    \n    const float warp = 0.3;    \n    float warpTrk = 1.2 ;\n    const float warpTrkGain = 1.5;\n    \n    // Step 1: Get a simple arbitrary rotation, defined by the direction.\n    vec3 seed = vec3(-1,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n    \n        // Step 2: Do some domain warping, Similar to fbm. Optional.\n        \n        p += sin(p.zxy*warpTrk - 2.*warpTrk)*warp; \n    \n        // Step 3: Calculate a noise value. \n        // This works in a way vaguely similar to Perlin/Simplex noise,\n        // but instead of in a square/triangle lattice, it is done in a sine wave.\n        \n        noise += sin(dot(cos(p), sin(p.zxy )))*amp;\n        \n        // Step 4: Rotate and scale. \n        \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    \n    //#ifdef TURBULENT\n    //return 1. - abs(noise)*0.5;\n    //#else\n    return (noise*0.25 + 0.5);\n    //#endif\n}\n////////////////////////////////////\n\n\nfloat noise(vec3 uv){\nreturn fract(sin(uv.x*23. + uv.y*345.)*534432.*cos(uv.y*203. + uv.z*353.));\n}\n\nfloat noise2(vec3 uv){\nvec3 f = floor(uv);\nvec3 i = fract(uv);\ni = smoothstep(0.,1.,i);\nfloat a = noise(f);\nfloat b = noise(f+vec3(1.,0.,0.));\nfloat c = noise(f+vec3(0.,1.,0.));\nfloat d = noise(f+vec3(1.,1.,0.));\nfloat e = noise(f+vec3(0.,0.,1.));\nfloat f2 = noise(f+vec3(1.,0.,1.));\nfloat g = noise(f+vec3(0.,1.,1.));\nfloat h = noise(f+vec3(1.,1.,1.));\n\nfloat m1 =  mix(mix(a,b,i.x),mix(c,d,i.x),i.y);\nfloat m2 =  mix(mix(e,f2,i.x),mix(g,h,i.x),i.y);\nreturn mix(m1,m2,i.z);\n}\n\nfloat fbm2(vec3 uv){\nreturn noise2(uv)*0.5+noise2(uv*2.0)*0.25+noise2(uv*4.)*0.125+noise2(uv*8.)*0.0625;\n}\nfloat fbm(vec3 uv){\nreturn cyclicNoise(uv+cyclicNoise(uv));;\n}\n\n\nfloat Tr(float densityMultiplier, float collectedDensity){\nreturn exp(-collectedDensity*densityMultiplier);\n}\n\nfloat Powder(float densityMultiplier, float collectedDensity){\nreturn 1.0 - exp(-collectedDensity*densityMultiplier*2.0);\n}\n\nfloat phase(float r, float wave){\nreturn (2.0*3.14159*r)/wave;\n}\n\nfloat RayleighPhase(float theta){\nfloat a = 0.0596831036595;\nfloat b = (1.+theta*theta);\nreturn a*b;\n}\n\nfloat HenyeyGreensteinPhase(float g, float theta){\nfloat a = 1.0 - g*g;\nfloat b = 12.5663706144*pow(1.0+g*g-2.*g*theta,1.5);\nreturn a/b;\n}\n\nfloat SchlickApproximationPhase(float g, float theta){\nfloat k = 1.55*g-0.55*g*g*g;\nfloat a = 1.0 - k*k;\nfloat sub = 1.0 + k*theta;\nfloat b = 12.5663706144*sub*sub;\nreturn -(a/b);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n   \n    \n    vec2 uv = fragCoord/iResolution.xy;\n     \n    uv = uv * 2.0 - 1.0;\n    uv.x *= 1.3;\n    uv.y /= 1.3;\n    vec3 lig = normalize(vec3(0.2,1.,1.));\n    vec3 d = normalize(vec3(uv.x, 1.0, uv.y));\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    mouse = mouse * 2.0 - 1.0;\n    d.yz = rot(d.yz, mouse.y*90.);\n    d.xy = rot(d.xy, mouse.x*90.);\n   \n   vec2 ps = -1.0 + 2.0 * (fragCoord.xy) / iResolution.xy;\n    ps.x *= iResolution.x/iResolution.y;\n   \n   \n    vec3 p = vec3(0.,iTime*0.4,0.);\n    //vec3 col = sky(d, lig);\n    vec3 col = vec3(0.1,0.05,0.01);\n    const int iter = 183;\n    float shadow_dist = 50.;\n    float ss = 1.0/float(shadow_dist);\n    float trans = 1.;\n    float trans2 = 1.;\n    vec3 c;\n    vec3 normal;\n   \n    float accumdist = 0.;\n    float curdensity = 0.;\n    float transmittance = 1.;\n    vec3 tryTr = vec3(0.);\n    //float shadowstepsize = 1. / float(iter);\n\n    float density = 1.0;\n    //density *= ss;\n    vec3 lightenergy = vec3(0.);\n    vec3 lightpowder = vec3(0.);\n    float ShadowDensity = 3.0;\n    float PowderDensity = 6.0;\n    vec3 hitpos;\n   \n    float hm = HenyeyGreensteinPhase(0.5, dot(d,lig));\n    float rm;\n    float org;\n   \n    float minus = 0.5;\n    float mult = 2.2;\n   \n    //p+=d*2.;\n    float t1;\n    float t2;\n    // intersect2(vec3 p, vec3 d, vec3 sp, float w)\n   //ec2 i = rayBoxDst(vec3(0.,0.,0.2)-vec3(3.,3.,2.1), vec3(0.,0.,0.2)+vec3(3.,3.,2.), p, vec3(1.0)/d);\n   // if(i.x < i.y){\n         //vec3 end = p+d*i.y;\n        // p = vec3(0.);\n        // p.zx = rot(p.zx, iTime);\n        p.y += 16.2;\n        vec3 keeptrack = p;\n         bool hit_volume = false;\n         for(int i = 0; i < iter; i++){\n             float nos = fbm(p*mult);\n             if((nos - minus) > 0.01 && length(keeptrack-p) > 1.){\n               if(!hit_volume){\n                 // normal = normalize(nos.yzw);\n                  hit_volume = true;\n                  hitpos = p;\n                  org = max(nos-minus,0.);\n               }\n               \n               vec3 lpos = p;\n               float shadowdist = 0.;\n     \n               for (int s = 0; s < 5; s++)\n               {\n                  float lsample = fbm(lpos*mult)-minus;  \n                  shadowdist += max(lsample, 0.);\n                  lpos += lig*ss;\n               }\n               \n               transmittance += max(nos-minus,0.);\n               trans *= 1.0 - (max(nos-minus,0.));\n               lightenergy += vec3(Tr(0.5*ShadowDensity, shadowdist)\n               ,Tr(1.*ShadowDensity, shadowdist),\n               Tr(2.*ShadowDensity, shadowdist))*trans*max(nos-minus,0.);\n               lightpowder += vec3(Powder(0.5*PowderDensity, shadowdist)\n               ,Powder(1.*PowderDensity, shadowdist),\n               Powder(2.*PowderDensity, shadowdist))*trans*max(nos-minus,0.);\n               //lightenergy*=hm;\n               float g = abs(sin(iTime));\n               //hm += ;\n               //rm += RayleighPhase(dot(d,lig));\n             }\n             p+=d*ss;\n            // d = mix(normalize(randomHemisphereDirection(d,seed)), d, 0.99);\n             \n         }\n         tryTr = vec3(Tr(0.5, transmittance),\n         Tr(1., transmittance),\n         Tr(2., transmittance));\n         if(transmittance != 1.){\n         col = col*trans + lightenergy*lightpowder*3.;\n         }\n  //  }\n   \n   // col = ACESFilm(col);\n   // col = pow(col, vec3(1./1.4));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}