{
    "Shader": {
        "info": {
            "date": "1488998331",
            "description": "the first flower of this spring... at least in our part of the world... at least that we've seen...\n\nthis is my first attempt at making something organic-looking :)",
            "flags": 0,
            "hasliked": 0,
            "id": "4sfcz2",
            "likes": 26,
            "name": "Hepatica Transsilvanica",
            "published": 3,
            "tags": [
                "raymarching",
                "sdf",
                "flower",
                "nature",
                "spring"
            ],
            "usePreview": 0,
            "username": "s23b",
            "viewed": 1334
        },
        "renderpass": [
            {
                "code": "#define NOISY_PETALS 0\n#define SPEED .1\n#define FOV 2.7\n\n#define MAX_STEPS 100\n#define SHADOW_STEPS 100\n#define SHADOW_SOFTNESS 50.\n#define EPS .0001\n#define RENDER_DIST 5.\n#define AO_SAMPLES 5.\n#define AO_RANGE 20.\n#define LIGHT_COLOR vec3(1, .9, .8)\n\n#define PI 3.14159265359\n#define saturate(x) clamp(x, 0., 1.)\n\n// simple hash function\nfloat hash(vec3 uv) {\n    float f = fract(sin(dot(uv, vec3(.08123898, .0131233, .0432234))) * 1e5);\n    return f;\n}\n\n// 3d noise function (linear interpolation between hash of integer bounds)\nfloat noise(vec3 uv) {\n    vec3 fuv = floor(uv);\n    vec4 cell0 = vec4(\n        hash(fuv + vec3(0, 0, 0)),\n        hash(fuv + vec3(0, 1, 0)),\n        hash(fuv + vec3(1, 0, 0)),\n        hash(fuv + vec3(1, 1, 0))\n    );\n    vec2 axis0 = mix(cell0.xz, cell0.yw, fract(uv.y));\n    float val0 = mix(axis0.x, axis0.y, fract(uv.x));\n    vec4 cell1 = vec4(\n        hash(fuv + vec3(0, 0, 1)),\n        hash(fuv + vec3(0, 1, 1)),\n        hash(fuv + vec3(1, 0, 1)),\n        hash(fuv + vec3(1, 1, 1))\n    );\n    vec2 axis1 = mix(cell1.xz, cell1.yw, fract(uv.y));\n    float val1 = mix(axis1.x, axis1.y, fract(uv.x));\n    return mix(val0, val1, fract(uv.z));\n}\n\n// fractional brownian motion\nfloat fbm(vec3 uv) {\n    float f = 0.;\n    float r = 1.;\n    for (int i = 0; i < 4; ++i) {\n        f += noise((uv + 10.) * r) / (r *= 2.);\n    }\n    return f / (1. - 1. / r);\n}\n\n// rotate 2d space with given angle\nvoid tRotate(inout vec2 p, float angel) {\n    float s = sin(angel), c = cos(angel);\n\tp *= mat2(c, -s, s, c);\n}\n\n// divide 2d space into s chunks around the center\nvoid tFan(inout vec2 p, float s) {\n    float k = s / PI / 2.;\n    tRotate(p, -floor((atan(p.y, p.x)) * k + .5) / k);\n}\n\n// box distance\nfloat sdBox(vec3 p, vec3 r) {\n    p = abs(p) - r;\n\treturn min(max(p.x, max(p.y, p.z)), 0.) + length(max(p, 0.));\n}\n\n// sphere distance\nfloat sdSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n// cylinder distance r - radius, l - height\nfloat sdCylinder(vec3 p, float r, float l) {\n    p.xy = vec2(abs(p.y) - l, length(p.xz) - r);\n    return min(max(p.x, p.y), 0.) + length(max(p.xy, 0.));\n}\n\n// union\nfloat opU(float a, float b) {\n    return min(a, b);\n}\n\n// smooth union\nfloat opSU(float a, float b, float k)\n{\n    float h = clamp(.5 + .5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\n// one big petal distance\nfloat sdPetal(vec3 p) {\n    float h = .0;\n    float r = .02;\n    return opU(sdBox(p, vec3(.2, h, .2)), sdCylinder(p + vec3(.2, 0, .2), .4, h)) - r * (.8 - length(p.xz));\n}\n\n// distance to 3 of those petals\nfloat sd3Petals(vec3 p) {\n    tFan(p.xz, 3.);\n    p.z *= 1.5;\n    p.x -= .2;\n    tRotate(p.xz, -PI * 3. / 4.);\n    return sdPetal(p) / 2.;\n}\n\n// two layers of petals on top of each othere\nfloat sdAllPetals(vec3 p) {\n    #if NOISY_PETALS\n    vec3 q = p * 10. / length(p.xz * 5.);\n    p.y += fbm(q) * .1 - .05;\n    #endif\n    p.y -= .05;\n    float curve = dot(p.xz, p.xz) * 2.;\n    p.y -= (curve * exp(-curve)) * .5;\n    float d = sd3Petals(p);\n    tRotate(p.xz, PI / 3.);\n    p.y += .02;\n    d = opU(d, sd3Petals(p));\n    return d;\n}\n\n// distance to one of those little yellow things in the middle\nfloat sdStyle(vec3 p) {\n    return sdCylinder(p, 0., .2) - .015;\n}\n\n// all of those little yellow things together\nfloat sdPistil(vec3 p) {\n    tRotate(p.xz, -length(p.xz) * 4.);\n    float d = sdStyle(p);\n    tFan(p.xz, 6.);\n    tRotate(p.xy, .5);\n    d = opU(d, sdStyle(p));\n    tFan(p.xz, 6.);\n    tRotate(p.xy, .25);\n    d = opU(d, sdStyle(p));\n    return d;\n}\n\n// distance to one of those long tentacle things\nfloat sdFilament(vec3 p) {\n    float d = sdCylinder(p, 0., .4) - .005;\n    p.x = abs(p.x) - .015 + p.y * .1 -.04;\n    return opU(d, sdCylinder(p - vec3(0, .4, 0), .0, .02) - .015);\n}\n\n// distance to all of those long tentacle things\nfloat sdStamen(vec3 p) {\n    p.y -= dot(p, p) * .2;\n    tRotate(p.xz, p.y * .5 + .1);\n    tFan(p.xz, 6.);\n    tRotate(p.xy, .8);\n    tRotate(p.xz, PI / 3.);\n    tFan(p.xz, 3.);\n    tRotate(p.xy, .25);\n    float d = sdFilament(p);\n    return d;\n}\n\n// distance to one of those little petal like things at the base\nfloat sdSepal(vec3 p) {\n    float h = .0;\n    float r = .01;\n    return sdCylinder(p + vec3(.1, 0, .1), .2, h) - r;\n}\n\n// the base of the flower\nfloat sdSepals(vec3 p) {\n    tFan(p.xz, 3.);\n    p.z *= 2.;\n    p.x -= .2;\n    tRotate(p.xz, -PI * 3. / 4.);\n    return sdSepal(p) / 2.;\n}\n\n// distance to the base + the pedicel\nfloat sdPedicel(vec3 p) {\n    tRotate(p.xz, PI / 6.);\n    return opSU(sdSepals(p - vec3(0, dot(p.xz, p.xz) * .6, 0)), sdCylinder(p + vec3(0, 2, 0), .1, 2.), .1);\n}\n\n// distance to the skybox\nfloat sdSky(vec3 p) {\n    return - sdSphere(p, 3.);\n}\n\n// distance estimation of everything together\nfloat map(vec3 p) {\n    float d = sdAllPetals(p);\n    d = opU(d, sdPistil(p));\n    d = opU(d, sdStamen(p));\n    d = opU(d, sdPedicel(p));\n    return opU(d, sdSky(p));\n}\n\n// trace the scene from ro (origin) to rd (direction, normalized)\n// until hit or reached maxDist, outputs distance traveled and the number of steps\nfloat trace(vec3 ro, vec3 rd, float maxDist, out float steps) {\n    float total = 0.;\n    steps = 0.;\n    \n    for (int i = 0; i < MAX_STEPS; ++i) {\n        ++steps;\n        float d = map(ro + rd * total);\n        total += d;\n        if (d < EPS || maxDist < total) break;\n    }\n    \n    return total;\n}\n\n// get the soft shadow value\nfloat softShadow(vec3 ro, vec3 rd, float maxDist) {\n    float total = 0.;\n    float s = 1.;\n    \n    for (int i = 0; i < SHADOW_STEPS; ++i) {\n        float d = map(ro + rd * total);\n        if (d < EPS) {\n            s = 0.;\n            break;\n        }\n        if (maxDist < total) break;\n        s = min(s, SHADOW_SOFTNESS * d / total);\n        total += d;\n    }\n    \n    return s;\n}\n\n// calculate the normal vector\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(.0001, 0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n\t));\n}\n\n// ambient occlusion\nfloat calculateAO(vec3 p, vec3 n) {\n    \n    float r = 0., w = 1., d;\n    \n    for (float i = 1.; i <= AO_SAMPLES; i++){\n        d = i / AO_SAMPLES / AO_RANGE;\n        r += w * (d - map(p + n * d));\n        w *= .5;\n    }\n    \n    return 1.-saturate(r * AO_RANGE);\n}\n\n// use the distances to determine which material to use\nint getMaterial(vec3 p) {\n    int mat = -1;\n    float dist = 5.;\n    \n    float currentDist = sdSky(p);\n    if (currentDist < dist) {\n        dist = currentDist;\n        mat = 0;\n    }\n    currentDist = sdAllPetals(p);\n    if (currentDist < dist) {\n        dist = currentDist;\n        mat = 1;\n    }\n    currentDist = sdPistil(p);\n    if (currentDist < dist) {\n        dist = currentDist;\n        mat = 2;\n    }\n    currentDist = sdStamen(p);\n    if (currentDist < dist) {\n        dist = currentDist;\n        mat = 3;\n    }\n    currentDist = sdPedicel(p);\n    if (currentDist < dist) {\n        dist = currentDist;\n        mat = 4;\n    }\n    \n    return mat;\n}\n\n// texture function\nvec3 _texture(vec3 p, int mat) {\n    vec3 q = p * 10. / length(p.xz * 4.);\n    vec2 r = p.xz;\n    tFan(r, 6.);\n    r.y *= 2.;\n    float petalGrad = smoothstep(.2, .4, distance(r, vec2(.5, 0)));\n    \t\t// sky\n    vec3 t = (mat == 0) ? texture(iChannel0, p).rgb :\n    \t\t// petals\n    \t\t (mat == 1) ? vec3(.8, 1, 2.)\n                          - smoothstep(.0, .5, abs(.5 - fbm(q + fbm(q * 10.)))) * .5\n                          - fbm(q * 10.) * .5\n                          + dot(p.xz, p.xz) * .1\n                          - petalGrad * .4:\n    \t\t// pistils\n    \t\t (mat == 2) ? mix(vec3(2, 2, .7), vec3(5, 5, 3), smoothstep(.18, .25, length(p))) + fbm(p * 100.) * .1 :\n    \t\t// stamen\n    \t\t (mat == 3) ? mix(vec3(.7, .7, 2.), vec3(2, 1.5, 2), smoothstep(.35, .42, length(p))) : \n    \t\t// pedicel\n    \t\t (mat == 4) ? mix(vec3(.2, .3, .1), vec3(.3, .2, .1), smoothstep(.0, .8, fbm(p * vec3(20., 5., 20.) + fbm(p * 50.)))) * .5\n                 \t\t  - fbm(p * vec3(50, 100, 50) + fbm(p * 200.) * 5.) * .2 : vec3(0);\n    return (t);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // transform screen coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // transform mouse coordinates\n\tvec2 mouse = iMouse.xy / iResolution.xy * 2. - 1.;\n    mouse.x *= iResolution.x / iResolution.y;\n    mouse *= 10.;\n    \n    // set up camera position\n    vec3 ro =  vec3(0, 0, -2);\n    vec3 rd = normalize(vec3(uv, FOV));\n    \n    // set up light position\n    vec3 light = vec3(-2, .4, 0);\n    \n    // rotate the camera\n    vec2 rot = vec2(0);\n    float tRot = iTime + mouse.x;\n    rot = vec2(tRot * SPEED * PI, .7 + sin(tRot * SPEED * PI) * .3);\n    \n    tRotate(rd.yz, rot.y);\n    tRotate(rd.xz, rot.x);\n    tRotate(ro.yz, rot.y);\n    tRotate(ro.xz, rot.x);\n    \n    // march\n    float steps, dist = trace(ro, rd, RENDER_DIST, steps); \n    \n    // calculate hit point coordinates\n    vec3 p = ro + rd * dist;\n    \n    // calculate matetial\n    int mat = getMaterial(p);\n    \n    // calculate normal\n    vec3 normal = getNormal(p);\n    \n    // light direction\n    vec3 l = normalize(light - p);\n    \n    // calculate shadow\n    vec3 shadowStart = p + normal * EPS * 10.;\n    float shadowDistance = distance(shadowStart,light);\n    float shadow = (mat == 0) ? 1. : softShadow(shadowStart, l, shadowDistance);\n    \n    // ambient light\n    float ambient = .5;\n    \n    // diffuse light\n    float diffuse = max(0., dot(l, normal));\n    \n    // specular light\n    float specular = pow(max(0., dot(reflect(-l, normal), -rd)), 4.);\n    \n    // \"ambient occlusion\"\n    float ao = calculateAO(p, normal) * .5 + .5;\n    \n    // calculate texture\n    vec3 tex = _texture(p, mat);\n    \n    // add this all up\n    if (mat != 0)\n\t\tfragColor.rgb = (ao * tex * (ambient * (2. - LIGHT_COLOR) * .5 + (specular + diffuse) * shadow * LIGHT_COLOR));\n    else\n    \tfragColor.rgb = tex;\n    \n    // add the cheesy dreamy glow\n    fragColor += (steps / float(MAX_STEPS)) * (smoothstep(.0, 1., length(p)) + .5) * vec4(1., .9, .6, 1.);\n    \n    // gamma correction\n    fragColor = pow(fragColor, vec4(1. / 2.2));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 27,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}