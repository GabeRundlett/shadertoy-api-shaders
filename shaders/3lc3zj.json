{
    "Shader": {
        "info": {
            "date": "1576875874",
            "description": "An edge detection routine that does not 'leak' through walls as volumetric approaches typically do.\nThe basic idea is to, for a given point on the surface, check whether there exist other points in its vicinity that can only be observed indirectly.",
            "flags": 48,
            "hasliked": 0,
            "id": "3lc3zj",
            "likes": 12,
            "name": "Robust Edge Highlighting",
            "published": 3,
            "tags": [
                "edges"
            ],
            "usePreview": 0,
            "username": "TinyTexel",
            "viewed": 779
        },
        "renderpass": [
            {
                "code": "// CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n// To the extent possible under law, Mirko Salm has waived all copyrights and related or neighboring rights to this work.\n\n// https://twitter.com/Mirko_Salm\n\n/*\nAn edge detection routine that does not 'leak' through walls as volumetric approaches typically do.\nThe basic idea is to, for a given point on the surface, check whether there exist other points in its vicinity that can only be observed indirectly,\nf.i. points that lie around a corner:\n\npoint O <- point on the surface we want to shade\npoint A <- sampled point inside a sphere of radius mr that is centered at O\npoint B <- sampled point inside a sphere of radius mr that is centered at O\n\nbool OA <- is A visible from O\nbool OB <- is B visible from O\nbool AB <- is B visible from A\n\nshading_sample Result <- (AB and (OA xor OB)) ? 1 : 0\n\nsee BufferA for code\n\ncamera controls via mouse + shift key\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 tex = fragCoord.xy / iResolution.xy;\n    \n    vec3 col = textureLod(iChannel0, tex, 0.0).rgb;\n    \n    fragColor = vec4(GammaEncode(col), 0.0);\n    //fragColor = vec4(col, 0.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n// To the extent possible under law, Mirko Salm has waived all copyrights and related or neighboring rights to this work.\n\n// https://twitter.com/Mirko_Salm\n\n/*\nAn edge detection routine that does not 'leak' through walls as volumetric approaches typically do.\nThe basic idea is to, for a given point on the surface, check whether there exist other points in its vicinity that can only be observed indirectly,\nf.i. points that lie around a corner:\n\npoint O <- point on the surface we want to shade\npoint A <- sampled point inside a sphere of radius mr that is centered at O\npoint B <- sampled point inside a sphere of radius mr that is centered at O\n\nbool OA <- is A visible from O\nbool OB <- is B visible from O\nbool AB <- is B visible from A\n\nshading_sample Result <- (AB and (OA xor OB)) ? 1 : 0\n\n(see lines ~240)\n\ncamera controls via mouse + shift key\n*/\n\n////////////////////////////////////////////////////////////\n//--------------------------------------------------------//\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_SHIFT 0x10\n#define KEY_A 0x41\n#define KEY_D 0x44\n#define KEY_S 0x53\n#define KEY_W 0x57\n\n#define KeyBoard iChannel1\n\nfloat ReadKey(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 0), 0).x;}\n\n\n#define VarTex iChannel0\n#define OutCol outCol\n#define OutChannel w\n\n#define WriteVar(v, cx, cy) {if(uv.x == float(cx) && uv.y == float(cy)) OutCol.OutChannel = v;}\n#define WriteVar4(v, cx, cy) {WriteVar(v.x, cx, cy) WriteVar(v.y, cx, cy + 1) WriteVar(v.z, cx, cy + 2) WriteVar(v.w, cx, cy + 3)}\n\nfloat ReadVar(int cx, int cy) {return texelFetch(VarTex, ivec2(cx, cy), 0).OutChannel;}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n//--------------------------------------------------------//\n////////////////////////////////////////////////////////////\n\nbool mapX0(vec3 p, bool doOpenTop)\n{    \n    bool r;\n    \n    r =      (p.x >= -8.0 && p.x < 8.0);\n    r = r && (p.y >= -8.0 && p.y < 8.0);\n    r = r && (p.z >= -8.0 && p.z < 8.0);      \n    \n    if(doOpenTop) return r;\n    \n    {\n        bool a;\n        a =      (p.x >= -7.0 && p.x < 7.0);\n    \ta = a && (p.y >= -7.0 && p.y < 8.0);\n    \ta = a && (p.z >= -7.0 && p.z < 7.0); \n        \n        r = r && !a;\n    }\n    \n    {\n        bool a;\n        a =      (p.x >= -7.0 && p.x < 3.0);\n    \ta = a && (p.y >= -7.0 && p.y < 7.0);\n    \ta = a && (p.z == -3.0); \n        \n        r = r || a;\n    }\n    \n    {\n        bool a;\n        a =      (p.x >= -3.0 && p.x < 7.0);\n    \ta = a && (p.y >= -7.0 && p.y < 7.0);\n    \ta = a && (p.z == 3.0); \n        \n        r = r || a;\n    }\n    \n    {\n        bool a;\n        a =      (p.x >=  3.0 && p.x < 7.0);\n    \ta = a && (p.y >= -7.0 && p.y < 7.0);\n    \ta = a && (p.z == 7.0); \n        \n        r = r && !a;\n    }\n    \n    if(doOpenTop)\n    {\n        bool a;\n        a =      (p.x >= -7.0 && p.x < 7.0);\n    \ta = a && (p.y == 7.0);\n    \ta = a && (p.z >= -7.0 && p.z < -3.0); \n        \n        r = r && !a;\n    }\n    \n    return r;\n}\n\nbool mapX(vec3 p)\n{\n   //return mapX0(vec3(p.x, p.y, -p.z+7.0));\n   return mapX0(vec3(p.x, p.y,  p.z+8.0), true ) || \n          mapX0(vec3(p.x, p.y, -p.z+7.0), false);\n}\n\nbool map0(vec3 p)\n{\n    p += 0.5;\n    vec3 b = abs(p);\n    \n    bool r;\n    \n    r =      b.x < 4.0;\n    r = r && b.y < 4.0;\n    r = r && b.z < 4.0;\n    \n    r = r && (b.x > 2.0 || b.y > 2.0);\n    r = r && (b.z > 2.0 || b.y > 2.0);\n    r = r && (b.x > 2.0 || b.z > 2.0);    \n    \n    return r;\n}\n\nbool map1(vec3 p)\n{\n    float o = 2.0; \n    \n    return map0(p + vec3( -o, 0.0, 0.0)) != \n           map0(p + vec3(  o, 0.0, 0.0)) != \n           map0(p + vec3(0.0,  -o, 0.0)) != \n           map0(p + vec3(0.0,   o, 0.0)) != \n           map0(p + vec3(0.0, 0.0,  -o)) != \n           map0(p + vec3(0.0, 0.0,   o));\n}\n\n#define map mapX\n\n// slightly modified version of iq's DDA implementation: https://www.shadertoy.com/view/4dfGzs\nbool VoxelRayCast(vec3 ro, vec3 rd, /**/ out vec3 vp, out vec3 fm, out float t)\n{\n\tvec3 pos = floor(ro);\n\tvec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd);\n\tvec3 off = (-ro + (rs * 0.5 + 0.5)) * ri;\n\n\tvec3 mm = vec3(0.0);\n    \n\tif(map(pos)) { t = 0.0; fm = mm; vp = pos; return true; }\n    \n\tbool hit = false;\n\tfor(int i = 0; i < 128; i++) \n\t{        \n        vec3 dis = pos * ri + off;// re-comp dis every iter so we dont accu float errors\n\t\tmm = step(dis.xyz, dis.yzx) * (1.0 - step(dis.zxy, dis.xyz));\n        pos += mm * rs;\n        \n\t\tif(map(pos)) { hit = true; break; }\n\t}\n\t\n    // intersect the cube\t\n    vec3 mini = (pos - rs) * ri + off;   \n\tt = max(mini.x, max(mini.y, mini.z));\n\n\tfm = mm;\n\tvp = pos;\n\n\treturn hit;\n}\n\n\nbool Intersect_Scene(vec3 rp, vec3 rd, /**/ out float t, out vec3 n, out vec3 a)\n{\n    vec3 vp, fm;\n    bool hit = VoxelRayCast(rp, rd, /*out:*/ vp, fm, t);\n    \n    n = -fm * sign(rd);\n    a = vec3(1.0);\n    \n    return hit;\n}\n\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{     \n    vec2 uv = uv0.xy - 0.5;\n\tvec2 tex = uv0.xy / iResolution.xy;\n    vec2 tex21 = tex * 2.0 - vec2(1.0);\n    \n    vec4 mouseAccu  = ReadVar4(1, 0);\n    vec4 wasdAccu   = ReadVar4(2, 0);\n    float frameAccu = ReadVar (3, 0);\n\n\n    vec2 ang = vec2(-0. * Pi, -Pi * 0.5);\n    ang += mouseAccu.xy * 0.008;\n    \n    mat3 cmat;\n    {\n        float sinPhi   = sin(ang.x);\n        float cosPhi   = cos(ang.x);\n        float sinTheta = sin(ang.y);\n        float cosTheta = cos(ang.y);    \n\n        vec3 front = vec3(cosPhi * cosTheta, \n                                   sinTheta, \n                          sinPhi * cosTheta);\n\n        vec3 right = vec3(-sinPhi, 0.0, cosPhi);\n        \n        vec3 up    = vec3(-cosPhi * sinTheta,\n                                    cosTheta,\n                          -sinPhi * sinTheta);\n        \n        cmat = mat3(right, up, front);\n    }\n    \n    float cdist = exp2(4.5 + mouseAccu.w * 0.02);\n    vec3 cpos = -cmat[2] * cdist;\n    \n\n    float fId = frameAccu * 1.64683 + 0.84377;\n    \n    vec3 pxId  = vec3(frameAccu, uv); \n         pxId *= vec3( 0.76032, 1.47035, 0.92526); \n         pxId += vec3(-0.69060, 0.02293, 0.68109);\n    \n    uint hh = HashUInt(pxId, uvec3(0xB8D3E97Cu, 0x736D370Fu, 0xA7D00135u));\n    \n    vec2 tc;\n    {\n        vec2 off;\n        {\n            // filter kernel:\n        \tfloat h0 = Hash(fId, 0xAF609A13u);\n        \tfloat h1 = Hash(fId, 0xE0ABC868u);\n        \n        \t//off = vec2(h0, h1) * 0.5;\n        \toff = vec2(Sample_Triangle(h0), Sample_Triangle(h1));\n        }\n         \n        #if 0\n        {\n            // bloom kernel:\n        \tfloat h0 = HashFlt(hh, 0xE77CA8EFu);\n        \tfloat h1 = HashFlt(hh, 0x86AF71D2u);\n        \th1 = clamp01(h1 * 0.5 + 0.5);\n            \n        \toff += AngToVec(h0 * Pi) * Pow2(log2(1.0 - Pow2(h1))) * 0.25;\n        }\n        #endif\n        \n        tc = (uv0.xy + off - iResolution.xy * 0.5) / iResolution.xx;\n    }\n    \n    vec3 lpos;\n    {\n        // lens pos:\n        float h0 = HashFlt(hh, 0x27BB116Bu);\n        float h1 = HashFlt(hh, 0x11A95B42u);\n\t\th1 = clamp01(h1 * 0.5 + 0.5);\n\n        vec2 lpos0 = Sample_Disk(h0, h1) * 0.0;\n        \n        lpos = cmat * vec3(lpos0, 0.0);\n    }\n    \n\n    float focalLen = 0.4;// 0.5 * tan(Pi05 - fov * 0.5)\n    float S1 = max(18.0, cdist);// focus plane dist / focalLen\n    vec3 rdir = normalize(cmat * (vec3(tc, focalLen) * S1) - lpos); \n \n    \n    vec2 lightAng = vec2(Pi * 0.7, Pi * 0.1);\n    lightAng.x += (wasdAccu.y - wasdAccu.w) * 0.06; \n    lightAng.y += (wasdAccu.x - wasdAccu.z) * 0.04;    \n    \n    vec3 light0 = AngToVec(lightAng);\n    light0 = vec3(0.49292178644304296, 0.7169771439171534, 0.49292178644304296);\n    \n    vec3 light = light0;\n    {\n        float h0 = HashFlt(hh, 0x9E2355B4u);\n        float h1 = HashFlt(hh, 0xDC305E12u);\n        h1 = clamp01(h1 * 0.5 + 0.5);\n        \n        h1 = mix(0.999, 1.0, h1);\n        h1 = 1.0;\n        \n        light = Sample_Sphere(h0, h1, light);\n    }\n    \n    \n    vec3 pot = vec3(1.0);\n    vec3 col = vec3(0.0);\n    \n    float t; vec3 n; vec3 a;\n    vec3 pos = cpos + lpos;\n    vec3 dir = rdir;\n\n    vec2 tt; \n    float res = Intersect_Ray_Cube(pos, dir, vec3(8.0 + 1e-5, 8.0 + 1e-5, 16.0 + 1e-5), /*out:*/ tt);   \n    \n    if(res == 1.0)\n    {\n    \tpos += dir * tt.x;\n    }\n    \n    if(res != -1.0 && Intersect_Scene(pos, dir, /*out:*/ t, n, a))\n    {\n        vec3 p = pos + dir * t;        \n             p += n * 0.0001;\n        \n        float mr = 2.0;\n        \n        \n        float h0 = HashFlt(hh, 0x874C40D4u);\n        float h1 = HashFlt(hh, 0xF27BD7E1u);\n        float h2 = HashFlt(hh, 0x558C4DF8u);\n              h2 = clamp01(h2 * 0.5 + 0.5);\n        \n        float rA = pow(h2, 0.333333) * mr;\n        vec3 dirA = Sample_Sphere(h0, h1);\n        vec3 pA = p + dirA * rA;\n        \n        \n        bool OA = Intersect_Scene(p, dirA, /*out:*/ t, n, a);\n             OA = !OA || (t > rA);\n        \n        \n        float k0 = HashFlt(hh, 0x487324A9u);\n        float k1 = HashFlt(hh, 0x401E0AAFu);\n        float k2 = HashFlt(hh, 0xFE5C3938u);\n              k2 = clamp01(k2 * 0.5 + 0.5);\n        \n        float rB = pow(k2, 0.333333) * mr;\n        vec3 dirB = Sample_Sphere(k0, k1);\n        vec3 pB = p + dirB * rB;\n        \n        bool OB = Intersect_Scene(p, dirB, /*out:*/ t, n, a);\n             OB = !OB || (t > rB);\n        \n        \n        bool AB = Intersect_Scene(pA, normalize(pB - pA), /*out:*/ t, n, a);\n             AB = !AB || (t*t > dot(pB - pA, pB - pA));\n\n        col = vec3(AB && (OA != OB) ? 1.0 : 0.0);\n    }\n    \n    vec3 colLast = textureLod(iChannel0, tex, 0.0).rgb;\n    \n    col = mix(colLast, col, 1.0 / (frameAccu + 1.0));    \n    \n    outCol = vec4(col, 0.0);\n    \n    \n    {\n        // persistent state stuff:\n        vec4 iMouseLast     = ReadVar4(0, 0);\n        vec4 iMouseAccuLast = ReadVar4(1, 0);\n        vec4 wasdAccuLast   = ReadVar4(2, 0);\n        float frameAccuLast = ReadVar (3, 0);\n\n\n        bool shift = ReadKey(KEY_SHIFT) != 0.0;\n\n        float kW = ReadKey(KEY_W);\n        float kA = ReadKey(KEY_A);\n        float kS = ReadKey(KEY_S);\n        float kD = ReadKey(KEY_D);\n\n        float left  = ReadKey(KEY_LEFT);\n        float right = ReadKey(KEY_RIGHT);\n        float up    = ReadKey(KEY_UP);\n        float down  = ReadKey(KEY_DOWN);\n        \n        \n        bool anyK = false;\n        \n        anyK = anyK || iMouse.z > 0.0;\n        anyK = anyK || shift;\n        anyK = anyK || kW != 0.0;\n        anyK = anyK || kA != 0.0;\n        anyK = anyK || kS != 0.0;\n        anyK = anyK || kD != 0.0;\n        anyK = anyK || left  != 0.0;\n        anyK = anyK || right != 0.0;\n        anyK = anyK || up    != 0.0;\n        anyK = anyK || down  != 0.0;\n        \n        \n        frameAccuLast += 1.0;\n        if(anyK) frameAccuLast = 0.0;\n        \n\n        vec4 wasdAccu = wasdAccuLast;\n        wasdAccu += vec4(kW, kA, kS, kD);\n        wasdAccu += vec4(up, left, down, right);        \n\n        \n        vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n\n        bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n        vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n        vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n\n        vec4 iMouseAccu = iMouseAccuLast + vec4(mouseDelta2, mouseDelta3);\n\n        \n        WriteVar4(iMouse,        0, 0);\n        WriteVar4(iMouseAccu,    1, 0);\n        WriteVar4(wasdAccu,      2, 0);\n        WriteVar (frameAccuLast, 3, 0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// The MIT License\n// Copyright © 2019 Mirko Salm\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#define Frame float(iFrame)\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\nconst float RcpPi = 1.0 / Pi;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\n\nvec3 AngToVec(vec2 ang)\n{\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    return vec3(cosPhi * cosTheta, \n                         sinTheta, \n                sinPhi * cosTheta); \n}\n\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat GammaDecode(float x) {return pow(x,      2.2) ;}\nvec2  GammaDecode(vec2  x) {return pow(x, vec2(2.2));}\nvec3  GammaDecode(vec3  x) {return pow(x, vec3(2.2));}\nvec4  GammaDecode(vec4  x) {return pow(x, vec4(2.2));}\n\nfloat GammaEncode(float x) {return pow(x,      1.0 / 2.2) ;}\nvec2  GammaEncode(vec2  x) {return pow(x, vec2(1.0 / 2.2));}\nvec3  GammaEncode(vec3  x) {return pow(x, vec3(1.0 / 2.2));}\nvec4  GammaEncode(vec4  x) {return pow(x, vec4(1.0 / 2.2));}\n\n\n// single iteration of Bob Jenkins' One-At-A-Time hashing algorithm:\n//  http://www.burtleburtle.net/bob/hash/doobs.html\n// suggested by Spatial on stackoverflow:\n//  http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nuint BJXorShift(uint x) \n{\n    x += x << 10u;\n    x ^= x >>  6u;\n    x += x <<  3u;\n    x ^= x >> 11u;\n    x += x << 15u;\n\t\n    return x;\n}\n\n\n// xor-shift algorithm by George Marsaglia\n//  https://www.thecodingforums.com/threads/re-rngs-a-super-kiss.704080/\n// suggested by Nathan Reed:\n//  http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\nuint GMXorShift(uint x)\n{\n    x ^= x << 13u;\n    x ^= x >> 17u;\n    x ^= x <<  5u;\n    \n    return x;\n}\n\n// hashing algorithm by Thomas Wang \n//  http://www.burtleburtle.net/bob/hash/integer.html\n// suggested by Nathan Reed:\n//  http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\nuint WangHash(uint x)\n{\n    x  = (x ^ 61u) ^ (x >> 16u);\n    x *= 9u;\n    x ^= x >> 4u;\n    x *= 0x27d4eb2du;\n    x ^= x >> 15u;\n    \n    return x;\n}\n\n//#define Hash BJXorShift\n#define Hash WangHash\n//#define Hash GMXorShift\n\n// \"floatConstruct\"          | renamed to \"ConstructFloat\" here \n// By so-user Spatial        | http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n// used under CC BY-SA 3.0   | https://creativecommons.org/licenses/by-sa/3.0/             \n// reformatted and changed from original to extend interval from [0..1) to [-1..1) \n//-----------------------------------------------------------------------------------------\n// Constructs a float within interval [-1..1) using the low 23 bits + msb of an uint.\n// All zeroes yields -1.0, all ones yields the next smallest representable value below 1.0. \nfloat ConstructFloat(uint m) \n{\n\tfloat flt = uintBitsToFloat(m & 0x007FFFFFu | 0x3F800000u);// [1..2)\n    float sub = (m >> 31u) == 0u ? 2.0 : 1.0;\n    \n    return flt - sub;// [-1..1)             \n}\n\nvec2 ConstructFloat(uvec2 m) { return vec2(ConstructFloat(m.x), ConstructFloat(m.y)); }\nvec3 ConstructFloat(uvec3 m) { return vec3(ConstructFloat(m.xy), ConstructFloat(m.z)); }\nvec4 ConstructFloat(uvec4 m) { return vec4(ConstructFloat(m.xyz), ConstructFloat(m.w)); }\n\n\nuint Hash(uint  v, uint  r) { return Hash(v ^ r); }\nuint Hash(uvec2 v, uvec2 r) { return Hash(Hash(v.x , r.x ) ^ (v.y ^ r.y)); }\nuint Hash(uvec3 v, uvec3 r) { return Hash(Hash(v.xy, r.xy) ^ (v.z ^ r.z)); }\nuint Hash(uvec4 v, uvec4 r) { return Hash(Hash(v.xy, r.xy) ^ Hash(v.zw, r.zw)); }\n\n// Pseudo-random float value in interval [-1:1).\nfloat Hash(float v, uint  r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec2  v, uvec2 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec3  v, uvec3 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec4  v, uvec4 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\n\n\nfloat HashFlt(uint   v, uint  r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec2  v, uvec2 r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec3  v, uvec3 r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec4  v, uvec4 r) { return ConstructFloat(Hash(v, r)); }\n\nuint HashUInt(float v, uint  r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec2  v, uvec2 r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec3  v, uvec3 r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec4  v, uvec4 r) { return Hash(floatBitsToUint(v), r); }\n\n\nfloat Intersect_Ray_Cube(vec3 rp, vec3 rd, vec3 cth, out vec2 t)\n{\t\n\tvec3 m = 1.0 / -rd;\n\tvec3 o = If(lessThan(rd, vec3(0.0)), -cth, cth);\n\t\n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\tt.x = max(uf.x, max(uf.y, uf.z));\n\tt.y = min(ub.x, min(ub.y, ub.z));\n\t\n\tbool inside = t.x < 0.0 && t.y > 0.0;\n    \n\tif(inside) {return 0.0;}\n\t\n\treturn t.y < t.x ? -1.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\n/*\nSOURCE: \n\t\"Building an Orthonormal Basis from a 3D Unit Vector Without Normalization\"\n\t\thttp://orbit.dtu.dk/files/126824972/onb_frisvad_jgt2012_v2.pdf\n\t\t\n\t\"Building an Orthonormal Basis, Revisited\" \n\t\thttp://jcgt.org/published/0006/01/01/\n\t\n\t- modified for right-handedness here\n\t\nDESCR:\n\tConstructs a right-handed, orthonormal coordinate system from a given vector of unit length.\n\nIN:\n\tn  : normalized vector\n\t\nOUT:\n\tox\t: orthonormal vector\n\toz\t: orthonormal vector\n\t\nEXAMPLE:\n\tfloat3 ox, oz;\n\tOrthonormalBasis(N, OUT ox, oz);\n*/\nvoid OrthonormalBasisRH(vec3 n, out vec3 ox, out vec3 oz)\n{\n\tfloat sig = n.z < 0.0 ? 1.0 : -1.0;\n\t\n\tfloat a = 1.0 / (n.z - sig);\n\tfloat b = n.x * n.y * a;\n\t\n\tox = vec3(1.0 + sig * n.x * n.x * a, sig * b, sig * n.x);\n\toz = vec3(b, sig + n.y * n.y * a, n.y);\n}\n\n// s0 [-1..1], s1 [-1..1]\n// samples spherical cap for s1 [cosAng05..1]\n// samples hemisphere if s1 [0..1]\nvec3 Sample_Sphere(float s0, float s1)\n{\n    float ang = Pi * s0;\n    float s1p = sqrt(1.0 - s1*s1);\n    \n    return vec3(cos(ang) * s1p, \n                           s1 , \n                sin(ang) * s1p);\n}\n\n// s0 [-1..1], s1 [-1..1]\n// samples spherical cap for s1 [cosAng05..1]\nvec3 Sample_Sphere(float s0, float s1, vec3 normal)\n{\t \n    vec3 sph = Sample_Sphere(s0, s1);\n\n    vec3 ox, oz;\n    OrthonormalBasisRH(normal, ox, oz);\n\n    return (ox * sph.x) + (normal * sph.y) + (oz * sph.z);\n}\n\n// s0 [-1..1], s1 [-1..1]\nvec3 Sample_Hemisphere(float s0, float s1, vec3 normal)\n{\n    vec3 smpl = Sample_Sphere(s0, s1);\n\n    if(dot(smpl, normal) < 0.0)\n        return -smpl;\n    else\n        return smpl;\n}\n\n// s0 [-1..1], s1 [0..1]\nvec2 Sample_Disk(float s0, float s1)\n{\n    return vec2(cos(Pi * s0), sin(Pi * s0)) * sqrt(s1);\n}\n\n// s0 [-1..1], s1 [0..1]\nvec3 Sample_ClampedCosineLobe(float s0, float s1)\n{\t \n    vec2 d  = Sample_Disk(s0, s1);\n    float y = sqrt(clamp01(1.0 - s1));\n    \n    return vec3(d.x, y, d.y);\n}\n\n// s0 [-1..1], s1 [0..1]\nvec3 Sample_ClampedCosineLobe(float s0, float s1, vec3 normal)\n{\t \n    vec2 d  = Sample_Disk(s0, s1);\n    float y = sqrt(clamp01(1.0 - s1));\n\n    vec3 ox, oz;\n    OrthonormalBasisRH(normal, ox, oz);\n\n    return (ox * d.x) + (normal * y) + (oz * d.y);\n}\n\n// s [-1..1]\nfloat Sample_Triangle(float s) \n{ \n    float v = 1.0 - sqrt(abs(s));\n    \n    return s < 0.0 ? -v : v; \n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}