{
    "Shader": {
        "info": {
            "date": "1697162115",
            "description": "Not entirely happy with parts of this texture, but some bits look convincing\n",
            "flags": 32,
            "hasliked": 0,
            "id": "ds3fDN",
            "likes": 77,
            "name": "Skinbox",
            "published": 3,
            "tags": [
                "sss",
                "pathtrace",
                "skin"
            ],
            "usePreview": 0,
            "username": "tdhooper",
            "viewed": 1424
        },
        "renderpass": [
            {
                "code": "vec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec4 tex = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    vec3 col = tex.rgb / tex.a;\n\n    col = aces(col);\n    col = pow( col, vec3(1./2.2) );\n    \n    fragColor = vec4(col, 1);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define DOF\n\n// Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n    p += 1.61803398875; // fix artifacts when reseeding\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// iq https://www.shadertoy.com/view/tl23Rm\nvec2 rndunit2(vec2 seed ) {\n    vec2 h = seed * vec2(1,6.28318530718);\n    float phi = h.y;\n    float r = sqrt(h.x);\n\treturn r*vec2(sin(phi),cos(phi));\n}\n\n// HG_SDF\n// https://www.shadertoy.com/view/Xs3GRB\n\n#define PI 3.14159265359\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat smin(float a, float b, float k){\n    float f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\n\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nconst float sqrt3 = 1.7320508075688772;\n\n\n//========================================================\n// Modeling\n//========================================================\n\n\nstruct Material {\n    vec3 albedo;\n    float specular;\n    float roughness;\n    bool sss;\n};\n\nstruct Model {\n    float d;\n    vec3 uvw;\n    int id;\n    float understep;\n};\n\n\nMaterial shadeModel(float rlen, Model model, inout vec3 nor) {\n    vec3 skin = pow(vec3(0.890,0.769,0.710), vec3(2.2));\n    skin = mix(skin, vec3(.4,.5,.5), .25);\n    skin = mix(skin, vec3(1,1,0) * .5, .02);\n   \n    // seams\n    skin = mix(skin, skin * vec3(.8,0,0), model.uvw.y * .5);\n\n    \n    if (model.id == 1) {\n        return Material(skin, .005, .2, true);\n    }\n    \n    return Material(vec3(0.50,0.70,1.00) * .05, .02, .3, false);\n}\n\nfloat sin3(vec3 x) {\n    return sin(x.x) * sin(x.y) * sin(x.z);\n}\n\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\nfloat time = 0.;\n\nModel map2(vec3 p) {\n    vec3 uvw = vec3(0);\n\n    float scl = .85;\n\n    if (iMouse.x > 0.)\n    {\n        pR(p.yz, (.5 - iMouse.y / iResolution.y) * PI / 2.);\n        pR(p.xz, (.5 - iMouse.x / iResolution.x) * PI * 2.);\n    } else {  \n        //pR(p.yz, (.5 - .8) * PI / 2.);\n        //pR(p.xz, (.5 - .84) * PI * 2.);\n        pR(p.yz, (.5 - .25) * PI / 2.);\n        pR(p.xz, (.5 - .6) * PI * 2.);\n    }\n\n    float o = 0.;\n        \n    p /= scl;\n    \n    \n    float d = fBox(p, vec3(.4)) - .1;\n    \n    \n    vec3 pp = p;\n    \n    p = abs(p);\n    p.xy = p.x < p.y ? p.yx : p.xy;\n    p.xz = p.x < p.z ? p.zx : p.xz;\n    //d = smax(d, -(length(p.yz) - .35), .08);\n\n    \n    p.x -= 1.;\n    d = smax(d, -(length(p) - .6), .2);\n\n    \n    float thin = smoothstep(.3, .5, length(p.yz));\n\n    \n    p = pp;\n   // p -= sin(p * 20. + 1.3) * .03;\n    float cut = length(p) - .47;\n    d = smax(d, -cut, .005);\n    //d = cut;\n    \n    //d = smin(d, abs(p.x - .45) - .01, .1);\n    //d = smax(d, -(length(p.yz) - .1), .15);\n    \n    p = pp;\n    //d = smin(d, fBox(p, vec3(.43)), .05);\n    \n\n    \n    float sc = 3.;\n\n    vec3 p3 = p * 30.;\n    pR45(p3.xy);\n    pR45(p3.yz);\n    pR45(p3.zx);\n    p3 += sin3(p * 30.);\n\n    vec3 p2 = p;\n    pR45(p2.xy);\n    pR45(p2.yz);\n    pR45(p2.zx);\n    float l = 0.;\n\n    float spots = (pow(abs(sin3(p2 * 10.)), 10.));\n    l += spots * 12.; // spots\n    float spotMask = max(spots, smoothstep(.1, .4, spots));\n    spotMask *= thin;\n\n    p2 += sin3(p * 2. + .5) * 1.5;\n    \n    float seam = abs(sin3(p2 * 25.));\n    seam = min(seam, mix(1., abs(sin3(p2 * 75.)), .95));\n    float seamMask = seam;\n    uvw.y = (1. - pow(seamMask, .15)) * (1. - spotMask);\n    seam = (1. - pow(seam, .02)) * (1. - spotMask);\n    l -= seam * 20.; // seams\n    l *= -.005;\n\n    // wrinkles\n    float w = 0.;\n    w -= -(abs(sin3(p * 1. + sin(p3 * 5.) * 2.)) * 2. - 1.) * .5;\n    w += abs(sin3(p3 * 250. / 30.));\n    w *= .00001;\n    w *= pow(seamMask, .5) * (1. - spotMask * .5);\n\n    l *= thin;\n    //w *= mix(.2, 1., ss);\n    w *= thin;\n    //l *= 0.;\n\n    \n    float understep = 1.;\n        \n    if (abs(d) < .1) {\n        d += l;\n    }\n    \n    if (abs(d) < .01) {\n        d += w * 600.;\n    }\n    \n    //p.y += .028;\n    float d2 = p.y + .5;\n    \n    float lip = length(p - vec3(0,1.47,0)) - 2.2;\n    lip = smin(lip, (length(p - vec3(0,2.56,0)) - 3.2), .005);\n    d2 = smin(d2, -lip, .005);    \n    d2 = abs(d2) - .03;\n    d2 = smax(d2, length(p) - 1.3, .03);\n    \n    int id = 1;\n    \n    if (d2 < d) {\n        d = d2;\n        id = 2;\n        understep = 1.;\n    }\n    \n        d *= scl;\n\n\n    return Model(d, uvw, id, understep);\n}\n\nconst float boundRadius = .3;\n\nModel map(vec3 p) {\n    float sc = .25;\n    Model m = map2(p / sc);\n    m.d *= sc;\n\n    return m;\n}\n\n\n//========================================================\n// Rendering\n//========================================================\n\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float h = 0.0001;      // replace by an appropriate value\n    #define ZERO (min(iFrame,0)) // non-constant zero\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*h).d;\n    }\n    return normalize(n);\n}\n\n\nvec3 sunPos = normalize(vec3(-1,1,-.75)) * 100.;\nvec3 skyColor = vec3(0.50,0.70,1.00);\nvec3 sunColor = vec3(8.10,6.00,4.20) * 3. * .1;\n\nvec3 env(vec3 dir, bool includeSun) {\n   vec3 col = mix(vec3(.5,.7,1) * .0, vec3(.5,.7,1) * 1., smoothstep(-.2, .2, dir.y));\n   return col * .5;\n}\n\nstruct Hit {\n    Model model;\n    vec3 pos;\n};\n\nHit march(vec3 origin, vec3 rayDirection, float maxDist, float understep) {\n\n    vec3 rayPosition;\n    float rayLength, dist = 0.;\n    Model model;\n\n    for (int i = 0; i < 500; i++) {\n        rayPosition = origin + rayDirection * rayLength;\n        model = map(rayPosition);\n        rayLength += model.d * understep * model.understep;\n\n        if (model.d < .0002) break;\n\n        if (rayLength > maxDist || length(rayPosition) > (boundRadius + .001)) {\n            model.id = 0;\n            break;\n        }\n    }\n    return Hit(model, rayPosition);\n}\n\n\n// tracing/lighting setup from yx\n// https://www.shadertoy.com/view/ts2cWm\nvec3 ortho(vec3 a){\n    vec3 b=cross(vec3(-1,-1,.5),a);\n    // assume b is nonzero\n    return (b);\n}\n\n// re-borrowed from yx from\n// http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec3 getSampleBiased(vec3 dir, float power, vec2 seed) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = seed;\n\tr.x=r.x*2.*PI;\n\tr.y=pow(r.y,1.0/(power+1.0));\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\nvec3 getConeSample(vec3 dir, float extent, vec2 seed) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r =  seed;\n\tr.x=r.x*2.*PI;\n\tr.y=1.0-r.y*extent;\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\n// Walk on spheres subsurface scattering\n// inspired by blackle https://www.shadertoy.com/view/wsfBDB\nHit walkOnSpheres(vec3 origin, vec3 normal, float startdepth, inout vec2 seed) {\n    Model model;\n    \n    vec2 lastSeed = seed;\n    seed = hash22(seed);\n    normal = normalize(tan(vec3(seed.x, seed.y, lastSeed.x) * 2. - 1.));\n    \n    float understep = .4;\n    \n    model = map(origin - normal * startdepth);\n    origin -= normal * abs(model.d * understep);\n    \n    for (int v = 0; v < 256; v++) {\n        model = map(origin);\n\n        if (abs(model.d) < .0002) break;\n        \n        vec2 lastSeed = seed;\n        seed = hash22(seed);\n        vec3 dir = normalize(tan(vec3(seed.x, seed.y, lastSeed.x) * 2. - 1.));\n        \n        origin += dir * abs(model.d * understep);\n    }\n    return Hit(model, origin);\n}\n\nvec3 sampleDirect(Hit hit, vec3 nor, vec3 throughput, inout vec2 seed) {\n    vec3 col = vec3(0);\n    vec3 lightDir = (sunPos - hit.pos);\n    vec3 lightSampleDir = getConeSample(lightDir, .0005, seed);\n    seed = hash22(seed);\n    float diffuse = dot(nor, lightSampleDir);\n    vec3 shadowOrigin = hit.pos + nor * (.0002 / abs(dot(lightSampleDir, nor)));\n    if (diffuse > 0.) {\n        Hit sh = march(shadowOrigin, lightSampleDir, 1., 1.);\n        if (sh.model.id == 0) {\n            col += throughput * sunColor * diffuse;\n        }\n    }\n    return col;\n}\n\nfloat G1V(float dnv, float k){\n    return 1.0/(dnv*(1.0-k)+k);\n}\n\n// noby https://www.shadertoy.com/view/lllBDM\nfloat ggx(vec3 nor, vec3 rayDir, vec3 l, float rough, float f0){\n    float alpha = rough*rough;\n    vec3 h = normalize(-rayDir + l);\n    float dnl = clamp(dot(nor,l), 0.0, 1.0);\n    float dnv = clamp(dot(nor,rayDir), 0.0, 1.0);\n    float dnh = clamp(dot(nor,h), 0.0, 1.0);\n    float dlh = clamp(dot(l,h), 0.0, 1.0);\n    float f, d, vis;\n    float asqr = alpha*alpha;\n    const float pi = 3.14159;\n    float den = dnh*dnh*(asqr-1.0)+1.0;\n    d = asqr/(pi * den * den);\n    dlh = pow(1.0-dlh, 5.0);\n    f = f0 + (1.0-f0)*dlh;\n    float k = alpha/1.0;\n    vis = G1V(dnl, k)*G1V(dnv, k);\n    float spec = dnl * d * f * vis;\n    return spec;\n}\n\nvec3 sphereLight(vec3 lightPos, float radius, vec3 pos, vec3 rayDir, vec3 nor) {\n    vec3 L = (lightPos - pos);\n    vec3 ref = reflect(rayDir, nor);\n    vec3 centerToRay = dot(L, ref) * ref - L;\n    vec3 closestPoint = L + centerToRay * clamp(radius / length(centerToRay), 0., 1.);\n    return closestPoint;\n}\n\nvec3 sampleDirectSpec(Hit hit, vec3 rayDir, vec3 nor, float rough) {\n    vec3 lpos = sphereLight(sunPos, 5., hit.pos, rayDir, nor);\n    \n    vec3 lightDir = normalize(lpos - hit.pos);\n    vec3 h = normalize(rayDir + lightDir);\n    float specular = pow(clamp(dot(h, nor), 0., 1.), 64.0);\n\n    vec3 col = vec3(0);\n\n    float fresnel = pow(max(0., 1. + dot(nor, rayDir)), 5.);\n    specular = ggx(nor, rayDir, lightDir, rough, fresnel);\n\n    vec3 shadowOrigin = hit.pos + nor * (.0002 / abs(dot(lightDir, nor)));\n    if (specular > 0.) {\n        Hit sh = march(shadowOrigin, lightDir, 1., 1.);\n        if (sh.model.id == 0) {\n            col += sunColor * specular;\n        }\n    }\n    return col;\n}\n\n// origin sphere intersection\n// returns entry and exit distances from ray origin\nvec2 iSphere( in vec3 ro, in vec3 rd, float r )\n{\n\tvec3 oc = ro;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - r*r;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n\th = sqrt(h);\n\treturn vec2(-b-h, -b+h );\n}\n\n// main path tracing loop, based on yx's\n// https://www.shadertoy.com/view/ts2cWm\n// with a bit of demofox's\n// https://www.shadertoy.com/view/WsBBR3\nvec4 draw(vec2 fragCoord, int frame) {\n\n    vec2 p = (-iResolution.xy + 2.* fragCoord) / iResolution.y;\n    p /= 2.;\n   \n    vec2 seed = hash22(fragCoord + (float(frame)) * sqrt3);\n    \n    // jitter for antialiasing\n    p += 2. * (seed - .5) / iResolution.xy;\n\n    vec3 col = vec3(0);\n\n    float focalLength = 6.;\n    vec3 camPos = vec3(0,0,.4) * focalLength * 1.;\n    vec3 camTar = vec3(0,-.02,0);\n    \n    vec3 ww = normalize(camTar - camPos);\n    vec3 uu = normalize(cross(vec3(0,1,0),ww));\n    vec3 vv = normalize(cross(ww,uu));\n    mat3 camMat = mat3(-uu, vv, ww);\n    \n    vec3 rayDir = normalize(camMat * vec3(p.xy, focalLength));\n    vec3 origin = camPos;\n\n    #ifdef DOF\n    float fpd = .385 * focalLength;\n    vec3 fp = origin + rayDir * fpd;\n    origin = origin + camMat * vec3(rndunit2(seed), 0.) * .05;\n    rayDir = normalize(fp - origin);\n    #endif\n\n    Hit hit;\n    vec3 nor, ref;\n    Material material;\n    vec3 throughput = vec3(1);\n    vec3 bgCol = skyColor * .05;\n    bool doSpecular = true;\n\n    vec2 bound = iSphere(origin, rayDir, boundRadius);\n    if (bound.x < 0.) {\n    //\treturn vec4(bgCol, 1);\n    }\n    \n    const int MAX_BOUNCE = 2;\n    \n    origin += rayDir * bound.x;\n\n    for (int bounce = 0; bounce < MAX_BOUNCE; bounce++) {\n\n        hit = march(origin, rayDir, 100., 1.);\n   \n        if (hit.model.id == 0)\n        {\n            if (bounce > 0) {\n                col += env(rayDir, doSpecular) * throughput;\n            } else {\n                col = bgCol;\n            } \n            break;\n        }\n\n        nor = calcNormal(hit.pos);\n        material = shadeModel(distance(camPos, hit.pos), hit.model, nor);\n\n        // calculate whether we are going to do a diffuse or specular reflection ray \n        seed = hash22(seed);\n        doSpecular = hash12(seed) < material.specular;\n        \n        if (bounce == 0) { // fix fireflies from diffuse-bounce specular\n            col += sampleDirectSpec(hit, rayDir, nor, material.roughness) * throughput * material.specular;\n        }\n\n        bool doSSS = material.sss && bounce < 1 && ! doSpecular;\n        if (doSSS) {\n            seed = hash22(seed);\n            doSSS = hash12(seed) < .9;\n        }\n        \n        if ( ! doSpecular) {\n            throughput *= material.albedo;\n        }\n\n        if (doSSS) {\n            origin = hit.pos;\n            \n            seed = hash22(seed);\n            hit = walkOnSpheres(origin, nor, .015, seed);\n            nor = calcNormal(hit.pos);\n\n            float extinctionDist = distance(origin, hit.pos) * 20.;\n            vec3 extinctionCol = material.albedo;\n            extinctionCol = mix(mix(extinctionCol, vec3(0,0,1), .25), vec3(1,0,0), clamp(1. - extinctionDist, 0., 1.));\n            extinctionCol = vec3(1,0,0);\n            vec3 extinction = (1. - extinctionCol);\n            extinction = 1. / (1. + (extinction * extinctionDist));\t\n            extinction = clamp(extinction, vec3(0), vec3(1));\n            throughput *= extinction;\n            \n        }\n\n        // Calculate diffuse ray direction\n        seed = hash22(seed);\n        vec3 diffuseRayDir = getSampleBiased(nor, 1., seed);\n\n        if ( ! doSpecular)\n        {\n        \n            seed = hash22(seed);\n            col += sampleDirect(hit, nor, throughput, seed);\n            rayDir = diffuseRayDir;\n        }\n        else\n        {\n            // Calculate specular ray direction\n            vec3 specularRayDir = reflect(rayDir, nor);\n            rayDir = normalize(mix(specularRayDir, diffuseRayDir, material.roughness * material.roughness));\n        }\n\n        // offset from sufrace https://www.shadertoy.com/view/lsXGzH\n        origin = hit.pos + nor * (.0002 / abs(dot(rayDir, nor)));\n    }\n\n    return vec4(col, 1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 col = draw(fragCoord, iFrame);\n    if (iFrame > 0 && iMouse.z <= 0.) {\n        vec4 lastCol = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n        col += lastCol;\n    }\n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}