{
    "Shader": {
        "info": {
            "date": "1719373785",
            "description": "An intersection of two spheres with noise and sine displacement. Or an alien life form?\n",
            "flags": 32,
            "hasliked": 0,
            "id": "4XtXRf",
            "likes": 7,
            "name": "Blobby Thing",
            "published": 3,
            "tags": [
                "raymarching",
                "dof",
                "shadows"
            ],
            "usePreview": 0,
            "username": "LoneCactusMotel",
            "viewed": 142
        },
        "renderpass": [
            {
                "code": "vec2 uPixelSize = vec2(0.0, 0.0); //The size of a pixel: vec2(1.0/width, 1.0/height) \n\nconst float GOLDEN_ANGLE = 2.39996323; \nconst float MAX_BLUR_SIZE = 20.0; \nconst float RAD_SCALE = 1.0; // Smaller = nicer blur, larger = faster (was 0.5)\n\nvec3 depthOfField(vec2 texCoord, float focusPoint, float focusScale);\nfloat getBlurSize(float depth, float focusPoint, float focusScale);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    uPixelSize = 1.0 / iResolution.xy;\n    \n//    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n//    fragColor.rgb = vec3(fragColor.w)/-50.0; // show depth buffer\n\n    vec2 texCoord = fragCoord / iResolution.xy;\n    float focusPoint = 0.2 + 0.075*sin(-0.75+0.5*iTime);\n    float focusScale = 0.125;\n    \n    fragColor.rgb = depthOfField(texCoord, focusPoint, focusScale);\n    fragColor.w = 1.0;\n}\n\n// DOF algorithm found at\n// https://blog.voxagon.se/2018/05/04/bokeh-depth-of-field-in-single-pass.html\n\nfloat getBlurSize(float depth, float focusPoint, float focusScale)\n{\n\tfloat coc = clamp((1.0 / focusPoint - 1.0 / depth)*focusScale, -1.0, 1.0);\n\treturn abs(coc) * MAX_BLUR_SIZE;\n}\n\nvec3 depthOfField(vec2 texCoord, float focusPoint, float focusScale)\n{\n\tfloat centerDepth = texture(iChannel0, texCoord).w;\n\tfloat centerSize = getBlurSize(centerDepth, focusPoint, focusScale);\n\tvec3 color = texture(iChannel0, texCoord).rgb;\n\tfloat tot = 1.0;\n\tfloat radius = RAD_SCALE;\n\tfor (float ang = 0.0; radius<MAX_BLUR_SIZE; ang += GOLDEN_ANGLE)\n\t{\n\t\tvec2 tc = texCoord + vec2(cos(ang), sin(ang)) * uPixelSize * radius;\n\t\tvec3 sampleColor = texture(iChannel0, tc).rgb;\n\t\tfloat sampleDepth = texture(iChannel0, tc).w;\n\t\tfloat sampleSize = getBlurSize(sampleDepth, focusPoint, focusScale);\n\t\tif (sampleDepth > centerDepth)\n\t\t\tsampleSize = clamp(sampleSize, 0.0, centerSize*2.0);\n\t\tfloat m = smoothstep(radius-0.5, radius+0.5, sampleSize);\n\t\tcolor += mix(color/tot, sampleColor, m);\n\t\ttot += 1.0;   radius += RAD_SCALE/radius;\n\t}\n\treturn color /= tot;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec3 estimate_normal(vec3 p);\nvec4 shading(uint shading_type, vec3 p, vec3 n, vec3 l, vec3 v, vec3 c);\nvec4 phong_shading(vec3 p, vec3 n, vec3 l, vec3 v, vec3 c);\nvec4 gouraud_shading(vec3 p, vec3 n, vec3 l, vec3 c);\nfloat noise2(vec3 p);\nfloat noise(vec3 p);\nmat3 rotationY(float angle);\nvec4 background_color(vec2 uv);\nvec3 applyFog( in vec3  col, // color of pixel\n               in float t ); // distance to point\nvec3 applyFog2( in vec3  col,   // color of pixel\n                in float t,     // distance to point\n                in vec3  rd,    // camera to point\n                in vec3  lig ); // sun direction\nvec3 applyFog3( in vec3  col,  // color of pixel\n                in float t,    // distance to point\n                in vec3  ro,   // camera position\n                in vec3  rd ); // camera to point vector\n\n// \"enum\" for shading type\nconst uint PhongShading   = 0u;\nconst uint GouraudShading = 1u;\n\nstruct Probe {\n    vec3  pos;  // position\n    float dist; // distance to sdf surface\n    vec3  col;  // color\n    uint  shd;  // shading type\n};\n\nvec3 march_shadow_ray(vec3 light, vec3 probe);\n\nProbe opSmoothIntersection(Probe p1, Probe p2, float k);\nProbe sdf_min(Probe p1, Probe p2);\nProbe sdf_ground_plane(float height, Probe probe);\nProbe sdf_ground_sphere(vec3 sphere_center, float sphere_radius, Probe probe);\nProbe sdf_sin_sphere(vec3 sphere_center, float sphere_radius, Probe probe);\nProbe sdf_noisy_sphere(vec3 sphere_center, float sphere_radius, Probe probe);\n\nProbe sdf_scene(Probe probe)\n{\n    vec3 ground_color       = vec3(0.4, 0.7, 0.4);\n    vec3 sin_sphere_color   = vec3(0.0, 0.8, 0.8);\n    vec3 noisy_sphere_color = vec3(0.7, 0.7, 0.0);\n    \n    Probe ground_probe       = Probe(probe.pos, probe.dist, ground_color,       GouraudShading);\n    Probe sin_sphere_probe   = Probe(probe.pos, probe.dist, sin_sphere_color,   PhongShading);\n    Probe noisy_sphere_probe = Probe(probe.pos, probe.dist, noisy_sphere_color, PhongShading);\n    \n    vec3 sin_sphere_pos   = vec3(0.0,        sin(0.7*iTime), -8.200);\n    vec3 noisy_sphere_pos = vec3(sin(iTime), 0.0,            -8.200);\n    \n    return sdf_min(sdf_ground_plane(-1.5, ground_probe),\n                   opSmoothIntersection(sdf_sin_sphere(sin_sphere_pos, 1.0, sin_sphere_probe),\n                                        sdf_noisy_sphere(noisy_sphere_pos, 0.8000, noisy_sphere_probe),\n                                        0.5));\n}\n\n\n// Fragment function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = vec2((fragCoord.x - 0.5*iResolution.x)/iResolution.y , (fragCoord.y - 0.5*iResolution.y)/iResolution.y);\n\n\tfloat eps = 0.0015;\n    vec3 light = vec3(10.0*sin(0.125*iTime), 3.0, 10.0*cos(0.125*iTime));\n\tvec3 camera = vec3(0.0, 0.0, 4.0);\n\tvec3 pixel = vec3(uv, 0.0);\n\tvec3 ray = normalize(pixel-camera);\n\tProbe probe = Probe(camera, 2.0*eps, vec3(0.0, 0.0, 0.0), PhongShading); // was dist\n    \n    const float min_z = -50.0;\n    const int max_iterations = 500;\n\n    int final_its = max_iterations;\n    \n\tfor(int its=max_iterations; its>0; its-=1)\n\t{\n\t    final_its = its-1;\n\n\t\tprobe = sdf_scene(probe);\n\t\tprobe.pos = probe.pos + (probe.dist * ray);\n        if(probe.dist <= eps || probe.pos.z <= min_z)\n        {\n            break;\n        }\n\t}\n\n\tif (probe.dist <= eps)\n\t{\n\t\tvec3 normal = estimate_normal(probe.pos);\n\t\tvec3 color = probe.col;\n        \n        // March shadow ray from light to probe.pos\n        vec3 shadow_probe = march_shadow_ray(light, probe.pos);\n        if (distance(shadow_probe, probe.pos) <= 600.0 * eps) {\n            // Light shines directly on surface\n            fragColor = shading(probe.shd, probe.pos, normal, light, camera, color);\n        } else {\n            // Point on surface is in shadow\n            fragColor = vec4(0.05*color, 1.0);\n        }\n\t}\n\telse if(final_its <= 0)\n\t{\n\t\tfragColor = vec4(1, 1, 0, 1);\n\t}\n\telse if(probe.pos.z <= min_z)\n\t{\n        fragColor = background_color(fragCoord/iResolution.xy);\n\t}\n\telse\n\t{\n\t\tfragColor = vec4(1, 1, 1, 1);\n\t}\n    \n    // Save fragment depth in .w (0.0 ... 1.0)\n    fragColor.w = probe.pos.z / min_z;\n    \n    vec3 cameraToPoint = normalize(probe.pos-camera);\n    vec3 sunDirection = normalize(light-camera);\n    fragColor.rgb = applyFog2(fragColor.rgb,\n                              fragColor.w,\n                              cameraToPoint,\n                              sunDirection);\n//    fragColor.rgb = applyFog3(fragColor.rgb,\n//                              fragColor.w,\n//                              camera,\n//                              cameraToPoint);\n}\n\n\n// 3D noise function (source: Inigo Quilez)\nfloat noise(vec3 p)\n{\n\tvec3 ip=floor(p);\n    p-=ip;\n    vec3 s=vec3(7,157,113);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(3.-2.*p);\n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z);\n}\n\nfloat sin_displacement(vec3 p, float frequency)\n{\n\treturn sin(frequency*p.x)*sin(frequency*p.y)*sin(frequency*p.z);\n}\n\nProbe sdf_min(Probe p1, Probe p2)\n{\n    if(p1.dist <= p2.dist) {\n        return p1;\n    } else {\n        return p2;\n    }\n}\n\n// smooth intersection (source: Inigo Quilez) with added color blend\nProbe opSmoothIntersection(Probe p1, Probe p2, float k)\n{\n    float h = clamp( 0.5 - 0.5*(p2.dist-p1.dist)/k, 0.0, 1.0 );\n    vec4 col_dist = mix( vec4(p2.col, p2.dist), vec4(p1.col, p1.dist), h ) + k*h*(1.0-h);\n    return Probe(p1.pos, col_dist.w, col_dist.rgb, p1.shd); \n}\n\n\nProbe sdf_ground_plane(float height, Probe probe)\n{\n    float rot_angle = 33.0+0.5*iTime;\n    if (rot_angle >=360.0) {\n        rot_angle -+ 360.0;\n    }\n    rot_angle *= -1.0;\n    mat3 rot_mat = rotationY(radians(rot_angle));\n    vec3 noise_vec = rot_mat * vec3(probe.pos.x, 0.0, probe.pos.z);\n    \n    // add color variation\n    probe.col = probe.col \n                          - 0.633*noise(2.0*(noise_vec))\n                          + 0.33*noise(11.0*(noise_vec))\n                          - 0.23*noise(37.0*(noise_vec));\n                          \n    probe.dist = probe.pos.y - height\n                             - 0.4 * noise(2.0*(noise_vec))\n                             - 0.1 * noise(50.0*(noise_vec));\n                        \n\treturn probe;\n}\n\nProbe sdf_sin_sphere(vec3 sphere_center, float sphere_radius, Probe probe)\n{\n    probe.dist = distance(probe.pos, sphere_center) - sphere_radius + 0.05*sin_displacement(probe.pos, 20.0);\n    \n    return probe;\n}\n\nProbe sdf_noisy_sphere(vec3 sphere_center, float sphere_radius, Probe probe)\n{\n\tvec3 nrml = normalize(probe.pos-sphere_center);\n                 \n    probe.dist = distance(probe.pos, sphere_center)\n                     - sphere_radius\n                     - 0.5*noise(sphere_center+2.6*(nrml+vec3(0.2*iTime, 0.2*iTime, iTime)))\n                     - 0.025*noise(sphere_center+25.0*(nrml))\n                     - 0.005*noise(sphere_center+120.0*(nrml));\n    return probe;\n}\n\n\n\nvec3 estimate_normal(vec3 p) {\n\tfloat eps = 0.001;\n    \n    Probe probe1 = Probe(vec3(p.x + eps, p.y, p.z), 0.0, vec3(0.0), GouraudShading);\n\n    Probe probe2 = probe1;\n    probe2.pos = vec3(p.x - eps, p.y, p.z);\n    \n    Probe probe3 = probe1;\n    probe3.pos = vec3(p.x, p.y + eps, p.z);\n    \n    Probe probe4 = probe1;\n    probe4.pos = vec3(p.x, p.y - eps, p.z);\n    \n    Probe probe5 = probe1;\n    probe5.pos = vec3(p.x, p.y, p.z + eps);\n    \n    Probe probe6 = probe1;\n    probe6.pos = vec3(p.x, p.y, p.z - eps);\n    \n    return normalize(vec3(\n        sdf_scene(probe1).dist - sdf_scene(probe2).dist,\n        sdf_scene(probe3).dist - sdf_scene(probe4).dist,\n        sdf_scene(probe5).dist - sdf_scene(probe6).dist\n    ));\n}\n\n\n// shading_type: PhongShading or GouraudShading \n// p: point on surface\n// n: surface normal at p\n// l: position of light source\n// v: position of viewer\n// c: diffuse color\nvec4 shading(uint shading_type, vec3 p, vec3 n, vec3 l, vec3 v, vec3 c)\n{\n    if (shading_type == GouraudShading) {\n        return gouraud_shading(p, n, l, c);\n    } else {\n        return phong_shading(p, n, l, v, c);\n    }\n}\n\n// p: point on surface\n// n: surface normal at p\n// l: position of light source\n// v: position of viewer\n// c: diffuse color\nvec4 phong_shading(vec3 p, vec3 n, vec3 l, vec3 v, vec3 c)\n{\n\tvec3 light = normalize(l);\n\tvec3 r     = reflect(light, n);\n\tvec3 view  = normalize(v-p);\n\tfloat diffuse  = max(0.05, dot(light, n));\n\tfloat specular = max(0.0, dot(-r, view));\n\tvec3 color = diffuse * c + pow(specular, 40.0) * vec3(1, 1, 1);\n\treturn vec4(color, 1);\n}\n\n// p: point on surface\n// n: surface normal at p\n// l: position of light source\n// c: diffuse color\nvec4 gouraud_shading(vec3 p, vec3 n, vec3 l, vec3 c)\n{\n\tvec3 light = normalize(l);\n\tvec3 r     = reflect(light, n);\n\tfloat diffuse  = max(0.05, dot(light, n));\n\tvec3 color = diffuse * c;\n\treturn vec4(color, 1);\n}\n\nvec3 march_shadow_ray(vec3 light, vec3 surface_point)\n{\n\tfloat eps = 0.0015;\n\n    vec3 probe = light;\n    vec3 ray = normalize(surface_point - light);\n    float dist = 2.0 * eps;\n    \n    const float min_z = -50.0;\n    const int max_iterations = 500;\n\n    int final_its = max_iterations;\n    \n\tfor(int its=max_iterations; its>0; its-=1)\n\t{\n\t    final_its = its-1;\n\n\t\tdist = sdf_scene(Probe(probe, 0.0, vec3(0.0), GouraudShading)).dist;\n\t\tprobe = probe + (dist * ray);\n        if(dist <= eps || probe.z <= min_z)\n        {\n            break;\n        }\n\t}\n    return probe;\n}\n\nmat3 rotationY(float a)\n{\n    mat3 m = mat3(\n        cos(a), 0.0, -sin(a),\n        0.0,    1.0, 0.0,\n        sin(a), 0.0, cos(a)\n    );\n    return m;\n}\n\n\nvec4 background_color(vec2 uv)\n{\n    vec4 top_color = vec4(0.2, 0.6, 1.0, 1.0);\n    //vec4 bot_color = vec4(0.4, 0.4, 0.5, 1.0);\n    vec4 bot_color = vec4(0.4, 0.1, 0.2, 1.0);\n    vec4 bg_color = uv.y * top_color + (1.0-uv.y) * bot_color;\n    return bg_color;\n}\n\n// source: Inigo Quilez\nvec3 applyFog( in vec3  col, // color of pixel\n               in float t )  // distance to point\n{\n    float b = 0.75; // fog density\n    float fogAmount = 1.0 - exp(-t*b);\n    vec3  fogColor  = vec3(0.5,0.6,0.7);\n    return mix( col, fogColor, fogAmount );\n}\n\n// source: Inigo Quilez\nvec3 applyFog2( in vec3  col,   // color of pixel\n                in float t,     // distance to point\n                in vec3  rd,    // camera to point\n                in vec3  lig )  // sun direction\n{\n    float b = 2.50; // fog density\n    float fogAmount = 1.0 - exp(-t*b);\n    float sunAmount = max( dot(rd, lig), 0.0 );\n    vec3  fogColor  = mix( vec3(0.5,0.6,0.7), // blue\n                           vec3(1.0,0.9,0.7), // yellow\n                           pow(sunAmount,8.0) );\n    return mix( col, fogColor, fogAmount );\n}\n\n// source: Inigo Quilez\nvec3 applyFog3( in vec3  col,  // color of pixel\n                in float t,    // distance to point\n                in vec3  ro,   // camera position\n                in vec3  rd )  // camera to point vector\n{\n    float a = 1.0;\n    float b = 2.50;\n    float fogAmount = (a/b) * exp(-ro.y*b) * (1.0-exp(-t*rd.y*b))/rd.y;\n    vec3  fogColor  = vec3(0.5,0.6,0.7);\n    return mix( col, fogColor, fogAmount );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}