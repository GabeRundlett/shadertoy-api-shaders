{
    "Shader": {
        "info": {
            "date": "1612871388",
            "description": "A blue noise-like sampling pattern that uses 3 sub-samples per pixel.",
            "flags": 0,
            "hasliked": 0,
            "id": "3tdBWM",
            "likes": 5,
            "name": "Blue Noise via 3 Sub-Samples",
            "published": 3,
            "tags": [
                "noise",
                "antialiasing",
                "blue",
                "sampling",
                "aa"
            ],
            "usePreview": 0,
            "username": "TinyTexel",
            "viewed": 624
        },
        "renderpass": [
            {
                "code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\nA blue noise-like sampling pattern that uses 3 sub-samples per pixel.\n\nRelated:\n    https://www.shadertoy.com/view/WtdfWM - \"3 Sub-Samples Pattern Test\"     (sampling a checkerboard tunnel using the pattern)\n    https://www.shadertoy.com/view/WltfDM - \"3 Sub-Samples Pattern Spectrum\" (plot of the spectral response of the pattern)\n*/\n\nconst float Pi = 3.14159265359;\n\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\n\nfloat PlotDot(vec2 sp, vec2 dp, float dr)\n{\n    float v = length(sp - dp) - dr;\n    \n    v = smoothstep(1.0, 0.0, v * 16.0);\n    \n    return v;\n}\n\n// http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html\nuint WeylHash(uvec2 c) \n{\n    return ((c.x * 0x3504f333u) ^ (c.y * 0xf1bbcdcbu)) * 741103597u; \n}\n\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{\n    vec2 uv = uv0;\n\tvec2 tex = uv0.xy / iResolution.xy;\n    \n    bool flip = (uint(iFrame) & 1u) != 0u;\n\n    vec3 col = vec3(0.0);\n\n    vec2 uv2 = uv / 32.0;\n    vec2 uvf = fract(uv2);\n\n\n    uvec2 uvi = uvec2(floor(uv2));\n    if(((uvi.x ^ uvi.y) & 4u) == 0u) uvi   = uvi.yx;\n\tif(((uvi.x        ) & 4u) == 0u) uvi.x =-uvi.x;\n\n    // constants of the 1d and 2d Roberts sequences\n    const uint rPhi1  = 2654435761u;\n    const uint rPhi2a = 3242174893u;\n    const uint rPhi2b = 2447445397u;\n\n    float u = float((uvi.x * rPhi2a) + (uvi.y * rPhi2b)) * (1.0 / 4294967296.0);\n    uint  h = WeylHash(uvi);\n\n    //if(flip) u += 1.5;\n\n    float dots = 0.0;\n    \n  #if 1\n    for(float i = 0.0; i < 3.0; ++i) \n    {\n        float ang = (Pi*0.666667) * (i+u);\n        \n        vec2 off = vec2(cos(ang), sin(ang));\n        \n      #if 0\n        off *= 0.333333;\n      #elif 0\n        off *= i == 0.0 ? 0.4 : 0.333333;// break up repeating pattern a bit\n      #elif 0\n        off *= float(h+uint(i)*rPhi1) * (0.111111/4294967296.0) + 0.333333;\n      #else\n        off *= float(h+uint(i)*rPhi1) * (0.25/4294967296.0) + 0.25;\n      #endif\n      \n        dots += PlotDot(uvf, vec2(0.5) + off, 0.02); \n    }\n  #else\n    for(float i = 0.0; i < 2.0; ++i) \n    {\n        float ang = Pi * (i+u);\n        \n        vec2 off = vec2(cos(ang), sin(ang));\n\n        off *= 0.333333;\n\n        dots += PlotDot(uvf, vec2(0.5) + off, 0.02); \n    }\n  #endif\n    \n  #if 1\n    if(tex.x < 0.5)\n    {\n        bvec2 tl1 = greaterThan(fract(uv2 * 0.5), vec2(0.5));   \n    \n    \tif(tl1.x != tl1.y) col = vec3(0.03);\n    }\n  #endif\n    \n    col += vec3(dots);\n    \n\toutCol = vec4(GammaEncode(clamp(col, 0.0, 1.0)), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}