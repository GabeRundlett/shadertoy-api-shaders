{
    "Shader": {
        "info": {
            "date": "1506619264",
            "description": "Click and move to toss the bunny! If you hit his ear hard enough, it will break apart :)\n\nDISCLAIMER: Only virtual bunnies were harmed.\nI tried to replicate physics and wrote a mesh to SDF converter for the bunny & his physproxy.\n",
            "flags": 32,
            "hasliked": 0,
            "id": "XlfyzN",
            "likes": 69,
            "name": "Interactive Bunny Physics",
            "published": 3,
            "tags": [
                "sdf",
                "physics",
                "pbr",
                "rigidbody",
                "bunny",
                "impulse",
                "burley"
            ],
            "usePreview": 1,
            "username": "ThomasSchander",
            "viewed": 3339
        },
        "renderpass": [
            {
                "code": "vec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\n//#define NO_POST_PRO\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    \n#ifdef NO_POST_PRO\n    fragColor.xyz = pow(Tonemap_ACES(textureLod(iChannel0, q, 0.0).xyz), vec3(0.4545));\n    return;\n#endif\n    vec2 v = -1.0 + 2.0*q;\n    v.x *= iResolution.x/ iResolution.y;\n    \n    float vign = smoothstep(4.0, 0.6, length(v));\n    \n    vec2 centerToUv = q-vec2(0.5);\n\tvec3 aberr;\n    aberr.x = textureLod(iChannel0, vec2(0.5)+centerToUv*0.995,0.0).x; \n    aberr.y = textureLod(iChannel0, vec2(0.5)+centerToUv*0.997, 0.0).y;\n    aberr.z = textureLod(iChannel0, vec2(0.5)+centerToUv, 0.0).z;\n    float exposure = (1.0+0.1*sin(0.5*iTime)*sin(1.4*iTime));\n    fragColor = vec4(pow(Tonemap_ACES(exposure*vign*aberr), vec3(0.1+0.4545)), 1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Contains quaterion code from https://www.shadertoy.com/view/lsG3W3\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n#define saturate(x) clamp(x, 0.0, 1.0)\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nconst float txRow = 128.;\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n#define NUM_PHYS_SPHERES 15\nvec4 physProxy[] = vec4[](vec4(0.0336538, -0.213592, 0.0843372, 0.35474),\nvec4(-0.192308, -0.0970871, 0.0903615, 0.262483),\nvec4(-0.120192, 0.218447, -0.108434, 0.158823),\nvec4(-0.278846, 0.131068, 0.0361445, 0.169385),\nvec4(-0.0144231, 0.315534, -0.168675, 0.0801684),\nvec4(-0.341346, 0.106796, 0.222892, 0.156275),\nvec4(-0.192308, -0.354369, 0.253012, 0.126427),\nvec4(-0.225962, -0.373786, 0.0361445, 0.127061),\nvec4(0.317308, -0.315534, 0.108434, 0.146499),\nvec4(-0.25, -0.417476, 0.168675, 0.0725712),\nvec4(-0.0528846, 0.393204, -0.108434, 0.0474471),\nvec4(-0.110577, -0.42233, -0.162651, 0.0710944),\nvec4(-0.317308, 0.315534, -0.26506, 0.0679328),\nvec4(-0.307692, 0.349515, -0.379518, 0.0577368),\nvec4(-0.293269, 0.276699, -0.156627, 0.0891464));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat3 bunnyRotation = QtToRMat(Loadv4(0));\n    vec3 bunnyPos = Loadv4(3).xyz;\n    vec3 bunnyVelocity = Loadv4(4).xyz;\n    mat3 bunnyMomentum= QtToRMat(Loadv4(5));\n    vec4 motionVals = Loadv4(1);\n    \n    mat3 earRotation = QtToRMat(Loadv4(6));\n    vec3 earPos = Loadv4(7).xyz;\n    mat3 earMomentum= QtToRMat(Loadv4(8));\n    vec3 earVelocity = Loadv4(9).xyz;    \n\n    if(iFrame == 0)\n    {\n        bunnyRotation = mat3(1.0);\n        bunnyPos = vec3(0.0, 1.0, 0.0);\n        bunnyVelocity = vec3(0.0);\n        bunnyMomentum = mat3(1.0);\n        \n        earRotation = mat3(1.0);\n        earPos = vec3(0.0, 1.0, 0.0);\n        earVelocity = vec3(0.0);\n        earMomentum = mat3(1.0);\n        \n        const float MAX_EAR_HEALTH = 0.05;\n        motionVals = vec4(0.0, -MAX_EAR_HEALTH, 0.0, 0.0);\n    }   \n    \n    if(iMouse.z > 0.0)\n    {\n      \tbunnyVelocity.y += 0.4*iTimeDelta * (0.2+1.0*iMouse.y/iResolution.y - bunnyPos.y);        \n        bunnyVelocity.x += 0.2*iTimeDelta * (0.5-iMouse.x/iResolution.x - bunnyPos.x);\n        bunnyVelocity.z += 0.2*iTimeDelta * (-bunnyPos.z);\n    }\n    \n    bool showEar = motionVals.y < 0.0;\n          \n    const float RESTITUTION = 0.4;\n    vec3 surfaceNormal = vec3(0,1.0, 0.0);\n    float M = 2.0;\n    float invM = 1.0/M;\n    float R = 0.5;\n    float I = 2.0* M * R*R/5.0;//2mr*r / 5\n    float invI = 1.0/I; \n    vec3 earDelta = vec3(0.185, 0.8, 0.25)-vec3(0.5);\n    \n    const float GRAVITY = 0.06;    \n    bunnyVelocity.y -= iTimeDelta*GRAVITY;\n    \n    motionVals.x *= 0.2;\n    for(int i = 0; i < NUM_PHYS_SPHERES; i++)\n    {       \n        if(!showEar && (i >= 12))\n            continue;\n            \n        vec3 p0 = inverse(bunnyRotation)*(physProxy[i].xyz+vec3(0.0, 0.15, 0.0)) - vec3(0.0, physProxy[i].w, 0.0);       \n        float thisPenetration = -(bunnyPos.y + p0.y);\n        if(0.0 < thisPenetration)\n        {\n            vec3 hitPoint = p0;\n            vec3 p1 = inverse(bunnyMomentum)*hitPoint;\n        \tvec3 pVel = bunnyVelocity + (p1-hitPoint); \n            if(pVel.y < 0.0) // if moving into the surface\n            {                \n                vec3 rCrossN = cross(p0, surfaceNormal);\n                float thisImpulse = -(1.0+RESTITUTION)*dot(pVel, surfaceNormal)/(invM + invI*dot(rCrossN,rCrossN));                \n                bunnyVelocity += surfaceNormal*thisImpulse*invM;  \n            \tvec3 rotCross = invI*cross(hitPoint, thisImpulse*surfaceNormal);\n        \t\tbunnyMomentum = bunnyMomentum*rotationMatrix(rotCross, length(rotCross));\n                \n                motionVals.x = max(motionVals.x, thisImpulse);\n                if(motionVals.y < 0.0 && i >= 12)\n                {\n                    motionVals.y += max(0.0, abs(thisImpulse)-0.01);\n                    if(motionVals.y > 0.0) // Ear is gone\n                    {\n                    \tmotionVals.y = iTime;\n                    \tmotionVals.zw = p0.xz;\n                        \n                        earRotation = bunnyRotation;\n                        earPos = bunnyPos + inverse(bunnyRotation) * (earDelta+vec3(0.0, 0.15, 0.0));\n                        earMomentum = bunnyMomentum;\n                        earVelocity = bunnyVelocity;\n                        \n                        // Toss the ear a bit away from bunny\n                        earVelocity += vec3(0.0, 0.03, 0.0) + normalize(earPos-bunnyPos)*vec3(0.05, 0.0, 0.05);\n                    }\n                } \n#if 1 // Friction\n                vec3 fripVel = pVel * vec3(1.0, 0.0, 1.0);\n                float LfripVel = length(fripVel);\n                if(LfripVel > 0.0)\n                {\n                \tvec3 rCrossN = cross(p0, fripVel);\n               \t\t thisImpulse = -(0.9)*LfripVel/(invM + invI*dot(rCrossN,rCrossN));\n                \n                \tbunnyVelocity += fripVel*thisImpulse*invM;  \n            \t\tvec3 rotCross = invI*cross(hitPoint, thisImpulse*fripVel);\n        \t\t\tbunnyMomentum = bunnyMomentum*rotationMatrix(rotCross, length(rotCross));\n                }\n#endif                \n            }\n            bunnyPos.y += 0.6*max(0.0, thisPenetration - 0.001);\n        }\n    }\n    \n    bunnyVelocity *= pow(0.8, iTimeDelta); // Air friction\n    bunnyPos += bunnyVelocity;\n    bunnyRotation = bunnyRotation*bunnyMomentum;  \n    \n    if(!showEar)\n    {        \n        float M = 0.5;\n        float invMear = 1.0/M;\n    \tfloat R = 0.1;\n    \tfloat I = 2.0* M * R*R/5.0;//2mr*r / 5\n    \tfloat invIear = 1.0/I;        \n        earVelocity.y -= iTimeDelta*GRAVITY;\n        for(int i = 12; i < NUM_PHYS_SPHERES; i++)\n        {       \n            vec3 p0 = inverse(earRotation)*(physProxy[i].xyz-earDelta) - vec3(0.0, physProxy[i].w, 0.0);       \n            float thisPenetration = -(earPos.y + p0.y);\n            if(0.0 < thisPenetration)\n            {\n                vec3 hitPoint = p0;\n                vec3 p1 = inverse(earMomentum)*hitPoint;\n                vec3 pVel = earVelocity + (p1-hitPoint); \n                if(pVel.y < 0.0) // if moving into the surface\n                {                \n                    vec3 rCrossN = cross(p0, surfaceNormal);\n                    float thisImpulse = -(1.0+RESTITUTION)*dot(pVel, surfaceNormal)/(invMear + invIear*dot(rCrossN,rCrossN));                \n                    earVelocity += surfaceNormal*thisImpulse*invM;  \n                    vec3 rotCross = invI*cross(hitPoint, thisImpulse*surfaceNormal);\n                    earMomentum = earMomentum*rotationMatrix(rotCross, length(rotCross));         \n#if 1 // Friction\n                    vec3 fripVel = pVel * vec3(1.0, 0.0, 1.0);\n                    float LfripVel = length(fripVel);\n                    if(LfripVel > 0.0)\n                    {\n                        vec3 rCrossN = cross(p0, fripVel);\n                         thisImpulse = -LfripVel/(invMear + invIear*dot(rCrossN,rCrossN));\n\n                        earVelocity += fripVel*thisImpulse*invM;  \n                        vec3 rotCross = invI*cross(hitPoint, thisImpulse*fripVel);\n                        earMomentum = earMomentum*rotationMatrix(rotCross, length(rotCross));\n                    }\n#endif  \n                }\n                earPos.y += 0.6*max(0.0, thisPenetration - 0.001);\n            }\n        }  \n        \n        earVelocity *= pow(0.3, iTimeDelta); // Air friction\n    \tearPos += earVelocity;\n    \tearRotation = earRotation*earMomentum;\n    }   \n        \n    Savev4(0, RMatToQt(bunnyRotation), fragColor, fragCoord);\n    Savev4(1, motionVals, fragColor, fragCoord);\n    Savev4(3, vec4(bunnyPos, 1.0), fragColor, fragCoord);    \n    Savev4(5, RMatToQt(bunnyMomentum), fragColor, fragCoord);\n    Savev4(4, vec4(bunnyVelocity, 1.0), fragColor, fragCoord); \n    Savev4(6, RMatToQt(earRotation), fragColor, fragCoord);\n    Savev4(7, vec4(earPos, 1.0), fragColor, fragCoord);    \n    Savev4(8, RMatToQt(earMomentum), fragColor, fragCoord);\n    Savev4(9, vec4(earVelocity, 1.0), fragColor, fragCoord);\n \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define PI 3.14159265359\n\n#define DOF\n\n#define GORE_MODE\n\n// Contains quaterion code from https://www.shadertoy.com/view/lsG3W3\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nfloat randomSeed = 0.0;\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat floatRand()\n{\n\treturn fract(sin(randomSeed += 0.1)*43758.5453123);\n}\n\nvec2 floatRand2()\n{\n\treturn fract(sin(vec2(randomSeed+=0.1,randomSeed+=0.1))*vec2(43758.5453123,22578.1459123));\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n\nfloat sdPlane(in vec3 p) {\n    return p.y;\n}\n\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdTorus(in vec3 p, in vec2 t) {\n    return length(vec2(length(p.xz) - t.x, p.y)) - t.y;\n}\n\nvec2 opUnion(vec2 d1, vec2 d2) {\n    return d1.x < d2.x ? d1 : d2;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat combine(float a, float b)\n{\n    return smin(a,b, 0.07);\n}\n\nbool showEar = true;\n\n#define NUM_PHYS_SPHERES 15\nvec4 physProxy[] = vec4[](vec4(0.0336538, -0.213592, 0.0843372, 0.35474),\nvec4(-0.192308, -0.0970871, 0.0903615, 0.262483),\nvec4(-0.120192, 0.218447, -0.108434, 0.158823),\nvec4(-0.278846, 0.131068, 0.0361445, 0.169385),\nvec4(-0.0144231, 0.315534, -0.168675, 0.0801684),\nvec4(-0.341346, 0.106796, 0.222892, 0.156275),\nvec4(-0.192308, -0.354369, 0.253012, 0.126427),\nvec4(-0.225962, -0.373786, 0.0361445, 0.127061),\nvec4(0.317308, -0.315534, 0.108434, 0.146499),\nvec4(-0.25, -0.417476, 0.168675, 0.0725712),\nvec4(-0.0528846, 0.393204, -0.108434, 0.0474471),\nvec4(-0.110577, -0.42233, -0.162651, 0.0710944),\nvec4(-0.317308, 0.315534, -0.26506, 0.0679328),\nvec4(-0.307692, 0.349515, -0.379518, 0.0577368),\nvec4(-0.293269, 0.276699, -0.156627, 0.0891464));\n\nmat3 earRotation;\nvec3 earPos;\nmat3 earMomentum;\nvec3 earVelocity;  \n\nmat3 bunnyRotation;\nvec3 bunnyPos;\n\nvec3 earDelta = vec3(0.185, 0.8, 0.25);\n\nvec2 scene(in vec3 pO) {\n    vec3 p = pO;\n    vec2 sceneShape = vec2(sdPlane(p), 1.0);\n    p -= bunnyPos;\n    p = bunnyRotation*p;\n    float shape = 1e9;    \n    p.y -= 0.15;\n#if 1\n    p += vec3(0.5);    \n    shape = combine(shape, sdEllipsoid(p-vec3(0.579787, 0.326087, 0.587838), vec3(0.306784, 0.294628, 0.319604)));\n    shape = combine(shape, sdEllipsoid(p-vec3(0.212766, 0.478261, 0.614865), vec3(0.142153, 0.301739, 0.198772)));  \n    shape = combine(shape, sdEllipsoid(p-vec3(0.356383, 0.793478, 0.47973), vec3(0.0686655, 0.0734181, 0.049516)));\n    shape = combine(shape, sdEllipsoid(p-vec3(0.31383, 0.0652174, 0.75), vec3(0.121429, 0.043445, 0.111769)));\n    shape = combine(shape, sdEllipsoid(p-vec3(0.43617, 0.847826, 0.398649), vec3(0.0525406, 0.0724031, 0.0349506)));\n    shape = combine(shape, sdEllipsoid(p-vec3(0.164894, 0.597826, 0.662162), vec3(0.116986, 0.180009, 0.232665)));\n    shape = combine(shape, sdEllipsoid(p-vec3(0.531915, 0.277174, 0.290541), vec3(0.141038, 0.143824, 0.0819466)));\n    shape = combine(shape, sdEllipsoid(p-vec3(0.797872, 0.173913, 0.587838), vec3(0.152242, 0.124905, 0.157487)));  \n    shape = combine(shape, sdEllipsoid(p-vec3(0.521277, 0.0978261, 0.581081), vec3(0.305612, 0.0526198, 0.299388))); \n    shape = combine(shape, sdEllipsoid(p-vec3(0.462766, 0.0815217, 0.837838), vec3(0.068863, 0.0449702, 0.0720527)));\n    shape = combine(shape, sdEllipsoid(p-vec3(0.356383, 0.375, 0.47973), vec3(0.260118, 0.217964, 0.14091)));\n    shape = combine(shape, sdEllipsoid(p-vec3(0.5, 0.891304, 0.331081), vec3(0.0219774, 0.0667988, 0.0356658)));\n    shape = combine(shape, sdEllipsoid(p-vec3(0.287234, 0.73913, 0.533784), vec3(0.0541389, 0.0804187, 0.054103)));\n    shape = combine(shape, sdEllipsoid(p-vec3(0.579787, 0.277174, 0.878378), vec3(0.120201, 0.160738, 0.0550283)));\n    shape = combine(shape, sdEllipsoid(p-vec3(0.393617, 0.820652, 0.445946), vec3(0.0665282, 0.0758984, 0.0433889)));\n    shape = combine(shape, sdEllipsoid(p-vec3(0.0851064, 0.576087, 0.797297), vec3(0.0339068, 0.086274, 0.0683804))); \n        \n    if(!showEar)\n    {\n        p = pO;\n        p -= earPos;\n   \t \tp = earRotation*p;\n        p += earDelta;\n    }\n    \n    float earShape = 1e9;\n    earShape = combine(earShape, sdEllipsoid(p-vec3(0.18617, 0.88587, 0.101351), vec3(0.0194326, 0.0285867, 0.0526812)));\n    earShape = combine(earShape, sdEllipsoid(p-vec3(0.180851, 0.809783, 0.283784), vec3(0.0473297, 0.0466274, 0.0946735)));\n    earShape = combine(earShape, sdEllipsoid(p-vec3(0.196809, 0.815217, 0.168919), vec3(0.0283318, 0.0726224, 0.0925792)));\n    earShape = combine(earShape, sdEllipsoid(p-vec3(0.18617, 0.744565, 0.385135), vec3(0.0512605, 0.0493519, 0.184969))); \n    \n    \n    if(!showEar)\n    {     \n        shape = min(shape, earShape);\n    }\n    else\n    {\n        shape = combine(shape, earShape);\n    }\n           \n#else\n    for(int i = 0; i < 12; i++)\n    \tshape = min(shape, sdSphere(p-physProxy[i].xyz, physProxy[i].w));\n    if(!showEar)\n    {\n        p = pO;\n        p -= earPos;\n   \t \tp = earRotation*p;\n        p += earDelta-vec3(0.5);\n    }\n    for(int i = 12; i < NUM_PHYS_SPHERES; i++)\n    \tshape = min(shape, sdSphere(p-physProxy[i].xyz, physProxy[i].w));\n#endif\n\n    return opUnion(vec2(shape, 0.0), sceneShape);\n}\n\nfloat shadow(in vec3 origin, in vec3 direction) {\n    float hit = 1.0;\n    float t = 0.02;\n    \n    for (int i = 0; i < 1000; i++) {\n        vec2 h = scene(origin + direction * t);\n        if (h.x < 0.001) return 0.0;\n        t += h.x;\n        hit = min(hit, 15.0 * h.x / t);\n        if (t >= 4.0) break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n\nvec2 traceRay(in vec3 origin, in vec3 direction) {\n    float material = -1.0;\n\n    float t = 0.004;\n    \n    for (int i = 0; i < 1000; i++) {\n        vec2 hit = scene(origin + direction * t);\n        if (hit.x < 0.001 || t > 20.0) break;\n        t += hit.x;\n        material = hit.y;\n    }\n\n    if (t > 20.0) {\n        material = -1.0;\n    }\n\n    return vec2(t, material);\n}\n\nvec3 normal(in vec3 position) {\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          scene(position + epsilon.xyy).x - scene(position - epsilon.xyy).x,\n          scene(position + epsilon.yxy).x - scene(position - epsilon.yxy).x,\n          scene(position + epsilon.yyx).x - scene(position - epsilon.yyx).x);\n    return normalize(n);\n}\n\nfloat Diffuse_Burley( float linearRoughness, float NoV, float NoL, float VoH, float LoH)\n{\n\tfloat FD90 = 0.5 + 2.0 * VoH * VoH * linearRoughness;\n\tfloat FdV = 1.0 + (FD90 - 1.0) * exp2( (-5.55473 * NoV - 6.98316) * NoV );\n\tfloat FdL = 1.0 + (FD90 - 1.0) * exp2( (-5.55473 * NoL - 6.98316) * NoL );\n\tfloat epicNormalization = 1.0 - linearRoughness * 0.333;\n\treturn FdV * FdL * epicNormalization; // 1/PI * NoL must still be applied\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = scene( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nfloat HenyeyGreenstein(float mu, float inG)\n{\n\treturn (1.-inG * inG)/(pow(1.+inG*inG - 2.0 * inG*mu, 1.5)*4.0* PI);\n}\nfloat Schlick (in float f0 , in float f90 , in float cosT )\n{\n\treturn f0 + ( f90 - f0 ) * pow (1.0 - cosT , 5.0);\n}\nfloat Smith( float roughness, float NoV, float NoL )\n{\n\tfloat a = roughness*roughness;\n\tfloat a2 = a*a;\n\tfloat SmithV = NoL * (NoV * (1. - a2) + a2);\n\tfloat SmithL = NoV * (NoL * (1. - a2) + a2);\n\treturn 0.5/(SmithV + SmithL);\n}\n\nvec3 TangentToWorld( vec3 Vec, vec3 TangentZ )\n{\n\tvec3 UpVector = abs(TangentZ.z) < 0.999 ? vec3(0,0,1) : vec3(1,0,0);\n\tvec3 TangentX = normalize( cross( UpVector, TangentZ ) );\n\tvec3 TangentY = cross( TangentZ, TangentX );\n\treturn TangentX * Vec.x + TangentY * Vec.y + TangentZ * Vec.z;\n}\n\nfloat D_GGX( float roughness, float NoH )\n{\n\tfloat m = roughness * roughness;\n\tfloat m2 = m*m;\n\tfloat f = ( NoH * m2 - NoH ) * NoH + 1.;\n\treturn m2 / (f*f);\n}\n\nvec3 blinnImportanceSampling(vec2 sampling, float exponent)\n{\n\tfloat phi = 2.0 * PI * sampling.x;\n\tfloat cosTheta = pow(1.0-sampling.y, 1.0 / (exponent + 1.0));\n\tfloat sinTheta = sqrt(1. - cosTheta * cosTheta);\n\treturn vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\n}\n\nvec3 sunDirection = normalize(vec3(0.6, 0.7, -0.7));\nconst vec3 sky = vec3(0.6, 0.85, 1.0);\nvec3 background;\nvec3 sun = vec3(1.0, 0.9, 0.8);\n\nmat3 setCamera(in vec3 origin, in vec3 target) {\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(0.0, 1.0, 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}\n\nvec2 GetSequenceHalton(int i)\n{\n    i %= 8;\n\tvec2 result = vec2(0);\n\tivec2 base = ivec2(2, 3);\n\tvec2 f = vec2(1.0) / vec2(base);\n  ivec2 index = ivec2(i, i);\n  while (index.x > 0 || index.y > 0)\n  {\n\t\tresult = result + f * vec2(ivec2(index) % base);\n\t\tindex = index / base;\n\t\tf = f / vec2(base); \n\t}\n  return result;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    randomSeed = float(iFrame) + dot(fragCoord, vec2(12.245, 93.2125));\n    vec4 motionVals = Loadv4(1);\n    \n    earRotation = QtToRMat(Loadv4(6));\n    earPos = Loadv4(7).xyz;\n    bunnyRotation = QtToRMat(Loadv4(0));\n    bunnyPos = Loadv4(3).xyz; \n       \n    vec2 uv = fragCoord / vec2(iResolution.xy);\n    vec2 jitter = GetSequenceHalton(iFrame)-vec2(0.5);\n    vec2 p = -1.0 + 2.0 * (fragCoord.xy-jitter) / iResolution.xy;\n    p.x *= iResolution.x / iResolution.y;\n    \n    if(motionVals.y > 0.0)\n        showEar = false;\n    \n    if(uv.y < 0.01 && -motionVals.y/0.05 > uv.x)\n    {\n        fragColor = vec4(0.8, 0.7, 0.6, 0.0);\n        return;\n    }\n\n    vec3 origin = vec3(0.0, 0.8+sqrt(motionVals.x)*0.08, 0.0);\n    vec3 target = vec3(0.0, 0.2, 0.0);  \n    \n\tconst float camRad = 3.5;   \n    float rotParam = -sin(0.04*iTime);\n    origin.x += camRad * cos(3.6+rotParam);\n    origin.z += camRad * sin(3.6+rotParam);    \n    \n#ifdef DOF\n    vec3 t1 = cross(origin-target, vec3(0.0, 1.0, 0.0));\n    vec3 t2 = cross(origin-target, t1);\n    float MOBLUR_STRENGTH = 0.0018;\n    origin += MOBLUR_STRENGTH*(floatRand()-0.5) * t1;\n    origin += MOBLUR_STRENGTH*(floatRand()-0.5) * t2;\n#endif\n\n    mat3 toWorld = setCamera(origin, target);\n    vec3 direction = toWorld * normalize(vec3(p.xy, 2.2));\n\n    // Render scene\n    float distance = 0.0;\n    background = sky - direction.y * 1.0;\n\tbackground += 8.0*vec3(1.0, 0.4, 0.2)*HenyeyGreenstein(dot(sunDirection, direction), 0.9);\n    vec3 color = background;\n    vec2 hit = traceRay(origin, direction);\n\n    // We've hit something in the scene\n    if (hit.y != -1.0) {\n        vec3 position = origin + hit.x * direction;\n\n        vec3 v = normalize(-direction);\n        vec3 n = normal(position);         \n\n        vec3 baseColor = vec3(0.93, 0.86, 0.87);\n        vec3 skySpec = vec3(0.0);\n        float roughness = 0.9;\n        float ao = calcAO(position, n);\n        if (hit.y == 1.0)  {\n            baseColor = 0.5*pow(textureLod(iChannel1, 0.4*position.zx, 0.0).xyz, vec3(1.8));\n            float specExp = 160.0;\n            vec2 deltaBlood = position.xz-motionVals.zw;\n            float timeDelta = iTime - motionVals.y;\n            if(!showEar && 0.14-dot(deltaBlood,deltaBlood)+0.03*(1.0-exp(-0.18*timeDelta)) > baseColor.r)\n            {\n                baseColor = vec3(0.5, 0.5, 0.5);\n#ifdef GORE_MODE\n                baseColor = vec3(0.5, 0.02, 0.02);\n#endif\n                roughness = 0.01;\n                specExp = 50000.0;\n            }\n            else\n            {\n            \tn = normalize(n+0.1*(textureLod(iChannel2, 0.9*position.xz, 0.0).xyz-vec3(0.5)));            \n            \troughness = max(0.1, 1.0-2.6*baseColor.b);\n            }\n            vec3 h = (TangentToWorld(blinnImportanceSampling(floatRand2(), specExp), n));\n            float NoV = abs(dot(n, v)) + 1e-5;\n            vec3 l = reflect(-v, h);\n        \tfloat NoL = saturate(dot(n, l));\n        \tfloat NoH = saturate(dot(n, h));\n            vec2 specRay = traceRay(position, l);\n            skySpec = (specRay.y != -1.0) ? 0.6*vec3(saturate(1.0-exp(-2.0*specRay.x))) : sky;\n            skySpec *= Schlick(0.04, 1.0, NoV);\n            skySpec *= step(0.5, ao);\n        } \n        \n        vec3 l = sunDirection;\n        vec3 h = normalize(v + l);\n        float NoV = abs(dot(n, v)) + 1e-5;\n        float NoL = saturate(dot(n, l));\n        float NoH = saturate(dot(n, h));\n        float LoH = saturate(dot(l, h));\n        float VoH = saturate(dot(v, h));        \n        float attenuation = shadow(position, l);\n        color = baseColor.rgb * (sun*attenuation*Diffuse_Burley(roughness*roughness, NoV, NoL, VoH, LoH)*NoL + ao*(0.5+0.5*n.y)*0.8*sky + 0.1*sun * max(0.0, -n.y)*1.0*(1.0-exp(-3.0*position.y)));       \n        color += NoL*sun*attenuation * D_GGX(roughness, NoH)*Schlick(0.04, 1.0, NoV)*Smith(roughness, NoV, NoL);\n        color += skySpec;\n        distance = hit.x;\n    }    \n\t// Exponential distance fog\n    color = mix(background,color, exp(-0.15 * max(0.0, distance-4.0)));        \n\tcolor += 6.0*vec3(1.0, 0.4, 0.2)*HenyeyGreenstein(dot(sunDirection, direction), 0.95);\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\nivec2 offsets[8] = ivec2[8]( ivec2(-1,-1), ivec2(-1, 1), \n\tivec2(1, -1), ivec2(1, 1), \n\tivec2(1, 0), ivec2(0, -1), \n\tivec2(0, 1), ivec2(-1, 0));\n\nvec3 RGBToYCoCg( vec3 RGB )\n{\n\tfloat Y = dot(RGB, vec3(  1, 2,  1 )) * 0.25;\n\tfloat Co= dot(RGB, vec3(  2, 0, -2 )) * 0.25 + ( 0.5 * 256.0/255.0 );\n\tfloat Cg= dot(RGB, vec3( -1, 2, -1 )) * 0.25 + ( 0.5 * 256.0/255.0 );\n\treturn vec3(Y, Co, Cg);\n}\n\nvec3 YCoCgToRGB( vec3 YCoCg )\n{\n\tfloat Y= YCoCg.x;\n\tfloat Co= YCoCg.y - ( 0.5 * 256.0 / 255.0 );\n\tfloat Cg= YCoCg.z - ( 0.5 * 256.0 / 255.0 );\n\tfloat R= Y + Co-Cg;\n\tfloat G= Y + Cg;\n\tfloat B= Y - Co-Cg;\n\treturn vec3(R,G,B);\n}\n\n//#define NO_AA\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;    \n    vec3 new = RGBToYCoCg(textureLod(iChannel0, q, 0.0).xyz);\n    vec3 history = RGBToYCoCg(textureLod(iChannel1, q, 0.0).xyz);\n    \n    vec3 colorAvg = new;\n    vec3 colorVar = new*new;\n    \n    // Marco Salvi's Implementation (by Chris Wyman)\n    for(int i = 0; i < 8; i++)\n    {\n        vec3 fetch = RGBToYCoCg(texelFetch(iChannel0, ivec2(fragCoord.xy)+offsets[i], 0).xyz);\n        colorAvg += fetch;\n        colorVar += fetch*fetch;\n    }\n    colorAvg /= 9.0;\n    colorVar /= 9.0;\n    float gColorBoxSigma = 0.75;\n\tvec3 sigma = sqrt(max(vec3(0.0), colorVar - colorAvg*colorAvg));\n\tvec3 colorMin = colorAvg - gColorBoxSigma * sigma;\n\tvec3 colorMax = colorAvg + gColorBoxSigma * sigma;\n    \n    history = clamp(history, colorMin, colorMax);\n  \n\tfragColor = vec4(YCoCgToRGB(mix(new, history, 0.95)), 1.0);\n#ifdef NO_AA\n    fragColor = vec4(YCoCgToRGB(new), 1.0);\n#endif\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}