{
    "Shader": {
        "info": {
            "date": "1569903678",
            "description": "practice",
            "flags": 0,
            "hasliked": 0,
            "id": "WsV3Rw",
            "likes": 7,
            "name": "jelly",
            "published": 3,
            "tags": [
                "spheretracing"
            ],
            "usePreview": 0,
            "username": "tono",
            "viewed": 512
        },
        "renderpass": [
            {
                "code": "#define time iTime\nconst float pi = acos(-1.);\nconst float pi2 = pi * 2.;\n \nfloat hash(float n)\n{\n    return fract(sin(n)*731.1);\n}\n\nmat2 rot(float a)\n{\n\tfloat s = sin(a),c = cos(a);\n\treturn mat2(s,c,-c,s);\n}\n \nvec2 pmod(vec2 p, float n)\n{\n\tfloat a = atan(p.x,p.y) + pi/n;\n\tfloat r = pi2 / n;\n\treturn p * rot(r);\n}\n \nfloat box(vec3 p , float s)\n{\n\tp = abs(p) - s;\n\treturn max(max(p.z,p.y),p.x);\n}\n \nfloat dist(vec3 p)\n{\n\t\n\tfloat angle = exp(sin(time/15.));\n\tp = mod(p,3.) - 3./2.;\n\tfor(int I = 0 ; I < 3 ; I++)\n\t{\n\t\tp.x = abs(p.x) - 0.5;\n\t\tp.y = abs(p.y) - 0.7;\n\t\tp.xy *= rot(.3);\n\t\tp.yz *= rot(.1);\n\t}\n\tp.xz = pmod(p.xz,7.);\n\tfor(int I = 0 ; I < 3 ; I++)\n\t{\n\t\tp.x = abs(p.x) - 0.1;\n\t\tp.z = abs(p.z) - 0.7;\n\t\tp.zy *= rot(1. * sign(fract(time/3.1)-0.5));\n\t\tp.yz *= rot(1. * sign(fract(time)-0.5) );\n\t}\n\tfloat s = box(p,0.3);\n\treturn s;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = ( fragCoord.xy  *2.- iResolution.xy ) / min(iResolution.x,iResolution.y);\n \n\tvec3 color = vec3(0.);\n\t\n\tp *= rot(1.);\n\tvec3 cp = vec3(0.,0.,-14.);\n\tvec3 cd = vec3(0.,0.,1.);\n\tvec3 cu = cd.xzy;\n\tvec3 cs = cross(cd,cu);\n\t\n\tcp += cd * time/10.;\n\tcp += cu * (cos(time/20.) + sin(time / 40.)) *3. \n        + cs * clamp(sin(time/30.),-0.5,0.5) * 2. * 5.;\n\t\n    float t2 = floor(time*1.5);\n    float slideNoise = step(hash(t2),0.2);\n    cp += cs * slideNoise * 3.;\n    \n\tfloat target = 2.5;\n\tvec3 rd = normalize(vec3(cd * target + cs * p.x + p.y * cu));\n\t\n\t\n\tfloat ac = 0.;\n\tfloat depth = 0.0;\n\t\n\tfor(int I = 0; I < 70 ; I++)\n\t{\n\t\tvec3 rp = cp + rd * depth;\n\t\tfloat d = dist(rp);\n\t\t\n\t\td = max(abs(d),0.001);\n        if(abs(d) <=  0.002)\n        {\n            d = 0.001;\n            rd.xz *= rot(0.01);\n        }\n\t\tac += exp(-d * 3.);\n\t\t\n\t\tdepth += d;\n\t}\n\t\n\tfloat r = ac /150. * sign(fract(time/4.)-0.5) + ac/350.;\n\tfloat g = abs(cos(time/11.))/2.;\n\tfloat b =max(r - g,0.01);\n\t\t\n\tcolor = vec3(r,g,b) * 8. / depth;\n\tfragColor = vec4(color, 1.0 );\n \n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}