{
    "Shader": {
        "info": {
            "date": "1680105825",
            "description": "Click and move the mouse to stop the animation. (reset in lower left corner) \nShould run smooth on full screen.\n\nHave a nice flight =)",
            "flags": 0,
            "hasliked": 0,
            "id": "cddSR2",
            "likes": 24,
            "name": "Alien Planet Exploration",
            "published": 3,
            "tags": [
                "raymarching",
                "fractal",
                "alien",
                "fisheye"
            ],
            "usePreview": 0,
            "username": "derSchamane",
            "viewed": 476
        },
        "renderpass": [
            {
                "code": "//                = Alien Planet Exploration =         \n//               by  Maximilian Knape ·∑>| 2023            \n// -----------------------------------------------------------\n// This work is licensed under a Creative Commons Attribution-\n//        NonCommercial-ShareAlike 3.0 Unported License\n\n#define GAMMA 2.2\n#define FOV 120.\n#define FEYE .85\n\n#define MAX_STEPS 200\n#define STEP_FAC .8\n#define MAX_DIST 200.\n#define MIN_DIST .1\n\n#define GLOW_INT 1.0\n#define PP_ACES 0.5\n#define PP_CONT 0.2\n#define PP_VIGN 3.0\n#define AO_OCC 0.3\n#define AO_SCA 0.7\n\n#define iTime iTime*1.0\n#define PI 3.14159265\n#define TAU 6.28318531\n#define S(x,y,t) smoothstep(x,y,t)\n\nvec3 hsv2rgb_smooth(in vec3 c) //IQ\n{\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb);\n\treturn c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nmat2 Rot(in float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 posCol;\nvec2 Map(vec3 p)\n{    \n    if (p.y > 40. || p.y < 0.) return vec2(10., 0.);\n    \n    float scale = 1.2, k, r2, col = 0.;\n    vec3 op = p;\n    \n    for(float i = 0.; i < 7.; i++) \n    {\n        r2 = dot(p,p);\n        scale *= k = max(.1, 10. / r2);\n        p = vec3(2,4,.7) - abs(abs(p) * k - vec3(2,4,3));\n\n        col += length(op - p) / 140.; \n        op = p;\n    }\n\n    float sp = step(1.66, max(.1, 10. / r2));\n    col += sp / 1.6;\n\n    float b = 1. + (sp*sin(iTime*2. + p.y*3. + length(p)/3.)*.05); \n    float d = min(length(p.xz), p.y*b - 1.9) / scale;\n\n    posCol = p;\n\n    return vec2(d, col*sp);\n}\n\nfloat SurfDis(float depth) //Cone Marching \n{  \n    return depth * tan(FEYE*PI*FOV/360.) / iResolution.y;\n}\n\nvec3 Normal(in vec3 p, in float depth) //tetrahedron differences\n{\n    float h = SurfDis(depth);\n    vec2 k = vec2(1.,-1.);\n\n    return normalize(   k.xyy * Map(p + k.xyy * h).x + \n                        k.yyx * Map(p + k.yyx * h).x + \n                        k.yxy * Map(p + k.yxy * h).x + \n                        k.xxx * Map(p + k.xxx * h).x );\n}\n\nvec3 RayMarch(vec3 ro, vec3 rd) \n{\n    float col = 0.;\n\tfloat dO = MIN_DIST;\n    int steps = 0;\n    \n    for(int i = 0; i < MAX_STEPS; i++) \n    {\n        steps = i;\n        \n    \tvec3 p = ro + rd*dO;\n        vec2 dS = Map(p);\n        col = dS.y;\n        dO += dS.x * mix(STEP_FAC, 1., dO/MAX_DIST);\n        \n        if (dO > MAX_DIST || dS.x < SurfDis(dO)) break;\n    }\n    \n    return vec3(dO, steps, col);\n}\n\nfloat softshadow2( in vec3 ro, in vec3 rd, in float dis, float w)\n{\n    float res = 1.;\n    float t = .1;\n    float d = (MAX_DIST-dis)*.5;\n    \n    //the shadow \"problem\" - something IQ like\n    for(int i = 0; i < 24 && t < d; i++)\n    {\n        float h = Map(ro + t*rd).x;\n        res = min( res, h/(w*t));\n        t += clamp(log(h+1.), .01, 1.);\n        if( res < -1. || t > d) break;\n    }\n    \n    res = clamp(res*2., -1., 1.); //Smoothstep\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res);\n}\n\nfloat CalcAO(const in vec3 p, const in vec3 n) //iq\n{\n    float occ = AO_OCC;\n    float sca = AO_SCA;\n\n    for( int i = 0; i < 5 ; i++ )\n    {\n        float h = 0.001 + 0.150 * float(i) / 4.0;\n        float d = Map(p + h * n).x;\n        occ += (h - d) * sca;\n        sca *= 0.95;\n    }\n    return S(0.0, 1.0 , 1.0 - 1.5 * occ);    \n}\n\nconst vec3 ambCol = vec3(.01,.02,.05);\nconst vec3 sunCol = vec3(1., .8, .6);\nconst vec3 skyCol = vec3(.3, .5, 1.);\nconst float specExp = 15.;\n\nvec3 Sky(vec3 rd, vec3 lPos, float depth)\n{\n    float sun = 0.;\n\n    float gnd = smoothstep(-.2, .3, dot(vec3(0,1,0), rd));\n    vec3 col = mix((ambCol + skyCol + sunCol) / 8., skyCol, gnd);\n\n    if (gnd > 0.)\n    {\n        float dir = dot(normalize(lPos), rd)*.5+.5;\n        sun = depth >= 1. ? smoothstep(1. - 2e-4, 1., dir) : 0.;\n        sun += pow(dir, 10.) * pow(depth,.3)*.3;\n    }\n\n    return S(vec3(0), vec3(1), col + (sun * sunCol * gnd));\n}\n\n\nvec3 Shade(vec3 col, float mat, vec3 p, vec3 n, vec3 rd, vec3 lp, float dis) \n{\n\n    vec3    lidi = normalize(lp - p);\n    float   mafa = max(mat, .0),\n            amoc = CalcAO(p, n),\n            shad = softshadow2(p, normalize(lp), dis, .1),\n            diff = max(dot(n, lidi), 0.) * shad,\n            spec = pow(diff, max(1., specExp * mafa)),\n            refl = pow(max(0., dot(lidi, reflect(rd, n))), max(1., specExp * 3. * mafa)) * shad;\n\n    return  col * (amoc * ambCol +                                           //ambient\n                   (1. - mafa) * diff * sunCol +                             //diffuse\n                   mafa * (spec + refl) * sunCol +                           //specular\n                   max(-mat, 0.) * smoothstep(0., 1., amoc * amoc + .5));    //emission\n}\n\nvec4 PP(vec3 col, vec2 uv)\n{\n    col = mix(col, (col * (2.51 * col + 0.03)) / (col * (2.43 * col + 0.59) + 0.14), PP_ACES);\n    col = mix(col, S(vec3(0.), vec3(1.), col), PP_CONT);    \n    col *= S(PP_VIGN,-PP_VIGN/5., dot(uv,uv)); \n    col = pow(col, vec3(1) / GAMMA);\n    \n    return vec4(col, 1.);\n}\n\nvec3 R(in vec2 uv, in vec3 p, in vec3 l)\n{\n    float z = tan(((180. - FOV) * PI) / 360.);\n    vec3  f = normalize(l - p),\n          r = normalize(cross(vec3(0,1,0), f)),\n          u = cross(f,r),\n          c = p + f*z,\n          i = c + uv.x*r + uv.y*u,\n          d = normalize(i - p);\n    return d;\n}\n\nvec3 Path(float t, int ix)\n{\n    switch (ix)\n    {\n        case 0: return vec3(sin(t*2.)*30., 10.+cos(t*4.)*5., cos(t)*45.); //loop-ride A\n        case 1: return vec3(sin(t)*28., 11.+cos(t*4.)*5., sin(t*2.)*50.); //loop-ride B\n        case 2: return vec3(sin(t)*66., 9.+sin(t*6.-.05)*5., cos(t)*60.); //ring-ride\n    }\n    return vec3(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5*iResolution.xy) / iResolution.y;\n    vec2 fe = normalize(uv) * tan(sqrt(dot(uv,uv)) / FEYE) * (FEYE*FEYE);\n\tvec2 m = iMouse.xy / iResolution.xy;\n    float t = (iTime - sin(iTime/3.))/30.;\n    \n    if (length(m) <= 0.2) m = vec2(.5);\n    else t = m.x * TAU; //stop animation\n    int path = int(mod(t/PI + 1., 3.));\n    float fade = 1. - pow(abs(cos(t)), 1e3);\n\n    vec3 ro = Path(t, path);\n    vec3 rd = R(fe, ro, Path(t+.2, path));\n    \n    vec3 rmd = RayMarch(ro, rd);\n    \n    vec3 lPos = vec3(1,2,3)*1e2;\n    vec3 bg = Sky(rd, lPos, rmd.x/MAX_DIST);\n    vec3 col = skyCol;\n    vec3 p = vec3(0.);\n    float f = 0.;\n    float disFac = S(0., 1., pow(rmd.x / MAX_DIST, 1.2));\n    \n    if(rmd.x < MAX_DIST) \n    {\n        p = ro + rd * rmd.x;\n        vec3 n = Normal(p, rmd.x);\n        \n        float mat = rmd.z == 0. ? .9 : rmd.z < 0. ? rmd.z : .2;\n        col = hsv2rgb_smooth(vec3(fract(rmd.z + iTime/70.), 1. - abs(mat)/2., .8));\n       \n        if (rmd.z > 0.) //glow waves\n        {\n            f = S(1.-min(2.,p.y/10.), 1., sin((p.y - iTime)/2.));\n            f *= S(0., 1., dot(sin(posCol/2.), cos(p/2. + posCol/2.)));\n            mat = -f*(1.-disFac);\n            if (mat < 0.) col = mix(col, sin(col+length(p-posCol))*.5+.5, f);\n        }\n        \n        col = Shade(col, mat, p, n, rd, lPos, rmd.x);\n    }\n    \n    col = mix(col, bg, disFac);\n    col += pow(rmd.y / float(MAX_STEPS), 2.-f) * normalize(sunCol) * GLOW_INT;\n    \n    fragColor = PP(col*fade, uv);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}