{
    "Shader": {
        "info": {
            "date": "1491663774",
            "description": "Explosion effect. Basicly a volumetric torus. I hope it's not too slow, I tried to optimize.",
            "flags": 32,
            "hasliked": 0,
            "id": "4sByWz",
            "likes": 83,
            "name": "ExplosionEffect",
            "published": 3,
            "tags": [
                "explosion",
                "fire",
                "effect",
                "volumetric",
                "bloom",
                "smoke"
            ],
            "usePreview": 0,
            "username": "kuvkar",
            "viewed": 3598
        },
        "renderpass": [
            {
                "code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    vec4 c1 = texture(iChannel0, uv);\n    vec4 c2 = texture(iChannel1, uv);\n    fragColor = c1+c2;\n    fragColor.rgb *= mix(1.0, rand(uv)+rand(uv*.5), 0.05); \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/***\n * Explosion effect. A volumetric torus, where I rotate the sample positions in the torus \n   around it's radius.\n   \n   Finding nice looking colors was perhaps the most difficult part and took me a while.\n   In the end adding the bloom made this work colorwise.\n*/\n\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.0); rot[1] = vec3(sin(a), cos(a), 0.0); rot[2] = vec3(0.0, 0.0, 1.0); return rot; }\n\n#define PI 3.14159265358\n#define SAMPLE samplePos3D \nconst vec3 up =  vec3(0.0, 1.0, 0.01);\n\nfloat RADIUS = 0.;\nfloat THICKNESS = 0.0;\nfloat T = 0.0;\nfloat ROTATION_T = 0.0;\nfloat DECAY = .0;\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n// from IQ, various places where 3d noise is used.\n// Without smoothing, in hope to gain a bit of performance.\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel1, (uv+ 0.5)/256.0, 0. ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n\nfloat map(in vec3 rp)\n{\n    vec3 v =  cos(T*.15+rp*15.)+ sin(T*.25+rp*10.);\n    return sdTorus(rp, vec2(RADIUS, THICKNESS))-dot(v, v)*.005;\n}\n\nfloat mapLo(in vec3 rp)\n{\n    return sdTorus(rp, vec2(RADIUS, THICKNESS))*.005;\n}\n\n\n/////\n// rotates the volume inside the torus, to get the smoke rolling effect.\n/////\nmat3 rot;\nvec3 samplePos3D(in vec3 rp)\n{\n    vec3 fw = normalize(vec3(rp.x, 0.0, rp.z));\n    vec3 pIn = fw * RADIUS;\n    vec3 rt =  cross(fw, up);\n\n    vec3 localP = rp-pIn;\n    rot[0] = fw; rot[1] = up; rot[2] = rt;\n    localP = transpose(rot) * localP; \n    localP = rotz(-ROTATION_T) * localP;\n    localP = rot * localP;\n    return (localP+pIn);\n}\n\n// actual volume sampling\nfloat sampleVolume(in vec3 rp)\n{\n    float t = map(rp);\n    t = -smoothstep(0., -THICKNESS*.5, t);\n    float d = noise(SAMPLE(rp)*22.)*.8;\n    d += noise(SAMPLE(rp)*70.)*.4;\n    d += noise(SAMPLE(rp)*100.)*.2;\n    d += noise(SAMPLE(rp)*350.)*.45*d;\n    float density = clamp(-t, 0.0, 1.0)*d;\n    return clamp((density-0.4)/0.8, 0.0, 1.0);\n}\n\n// Palette for the effect\nvec3 heatToColor(float heat)\n{\n    vec3 col = mix(vec3(0.0), vec3(1., .3, .0),clamp(heat * 15. -2.,   0., 1.));\n    col = mix(col, vec3(1., 1., .6), clamp(heat * 15.1-4.,   0., 1.));\n    col = mix(col, vec3(1., .9, .8), clamp(heat * 190. - 60.,   0., 1.));\n    return col;\n}\n\nint STEPCOUNT = 0; // debug\nvoid trace(in vec3 rp, in vec3 rd, inout vec4 color)\n{\n    \n    bool hit = false;\n    vec3 ro = rp;\n    float dist = 0.0;\n    \n    for (int i = 0; i < 150; ++i)\n    {\n        dist = mapLo(rp);\n        if(dist < 0.0)\n        {\n            hit = true;\n            break;\n        }\n        rp += rd * max(dist, 0.01);\n        ++STEPCOUNT;\n        if(length(ro - rp) > 5.0) break;\n        \n    }\n    \n    vec4 col = vec4(.0);\n    for (int i = 0; i < 400; ++i)\n    {\n        float density = sampleVolume(rp);\n\t\tfloat dist = mapLo(rp);\n        ++STEPCOUNT;\n\n        if (dist < 0.0)\n        {\n            float heat = density;\n            heat = (heat)/(max(1.0, (T*.5)-.1));\n            vec3 dcol = heatToColor(heat);\n\n            float smoke = heat/.03;\n            if (smoke < 1.0)\n            {\n                dcol = vec3(smoke*.5);\n            }\n\n            float d = density * 0.024 * DECAY;\n            col.rgb = mix(col.rgb, dcol, (1.0-col.a)*d);\n            col.a += d;\n        }\n        if (dot(rp, rp) > 10.0) break;\n        if (rp.y < -0.2) break;\n        if (col.a >= 1.) break;\n        rp += rd*(.00075)*(1.0+max(dist*1000., 1.0));\n    }\n    \n    // contrast\n    col.rgb = smoothstep(0.0, .3, col.rgb);\n    // mixing with bg\n    col.a = smoothstep(0.0, 0.95, col.a);\n    color = mix(color, col, col.a);\n}\n\n\nmat3 lookat(vec3 from, vec3 to)\n{\n    vec3 f = normalize(to - from);\n    vec3 _tmpr = normalize(cross(f, vec3(0.0, 1.0, 0.0)));\n    vec3 u = normalize(cross(_tmpr, f));\n    vec3 r = normalize(cross(u, f));\n    return mat3(r, u, f);\n}\n\n\n// t = time, b = from, c = delta, d = duration\n// http://gizma.com/easing\nfloat easeOut(float t, float b, float c, float d)\n{\n\tt /= d;\n\treturn -c * t*(t-2.) + b;    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-iResolution.xy*.5) / iResolution.x;\n    vec2 im = iMouse.xy;\n    if (iMouse.z < 0.0)\n    {\n        im.y = 40.0;\n    }\n    \n    fragColor = vec4(.0);\n    /////////////\n    // animation\n    ////////////\n    T = mod(iTime, 4.5)*4.;\n    ROTATION_T = pow(T*.2, 1.2);\n    DECAY = 1.-smoothstep(7.0, 20., T);\n    \n    float expandTime = 2.;\n    float ease = easeOut(min(T, expandTime), 0.01, 1.0, expandTime);\n\tfloat r = clamp(ease, 0.0, 1.0)*.1;    \n    \n    RADIUS = r*1.2;\n    THICKNESS = r*2.;\n    RADIUS += T*.02;\n    //////////////////\n    // Camera work\n    /////////////////\n    vec3 rd = normalize(vec3(uv, 1.4));\n    vec3 rp = vec3(0.0, 0.0, -2.5);\n    \n    float camShakeX = smoothstep(2., .0, T)*sin(T*40.);\n    float camShakeY = smoothstep(2., .0, T)*cos(T*40.);\n    vec3 lookpos = vec3(camShakeX*.025, camShakeY*.025, 0.0);\n    rp.x += lookpos.x;\n    rp.y += lookpos.y;\n    \n    rp.y += 4.5*smoothstep(-.6, 1., im.y/iResolution.y);\n    rp = roty(im.x*.01) * rp;\n    rd = lookat(rp, lookpos) * rd;\n    \n    //////////////////////////////////////\n    // Ground shadowing, glow etc.\n    /////////////////////////////////////\n    float t = -(0.1 + dot(rp, up))/dot(rd, up);\n    if (t > 0.0)\n    {\n        fragColor=vec4(.4, .5, .6, .0)*.5;\n        vec3 rpp = rp+rd*t;\n        float dist = map(rpp);\n        float dist2 = map(rpp+vec3(-0.1, 0.0, 0.06));\n        \n        // fake shadow\n        dist2 *= 1.+0.5+0.5*dot(normalize(rpp), vec3(-1., 0.0, -.2))*2.8;\n        fragColor *= mix(1., texture(iChannel0, rpp.xz*.8).r, .15);\n        fragColor.rgb *= mix(1.0, smoothstep(-.0, .4, dist2), .97*smoothstep(-0.34, .3, DECAY));\n        \n        float TT = T*4.;\n        \n        fragColor.rgb += vec3(1., .6, .2)*smoothstep(.5, 1.6, (1./(dist+.4)))*1.*smoothstep(.2, 3.0, TT)*smoothstep(28.0, -15., TT);\n        fragColor.rgb += vec3(1.4, .4, .0)*smoothstep(.1, -0.2, dist)*.07*(smoothstep(0.5, 1.0, DECAY));\n    }\n    \n    // trace the ray to top of donut.\n    t = -(-THICKNESS + dot(rp, up))/dot(rd, up);\n\trp += rd*t;\n    trace(rp, rd, fragColor);\n    \n    fragColor.rgb = sqrt(fragColor.rgb);\n    fragColor.rgb *= smoothstep(0.7, 0.3, length(uv));\n    \n    //fragColor.rgb = vec3(float(STEPCOUNT)/400.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/**\n\tHorizontal blur for glow.. I felt lazy and didn't do the vertical pass as this looks good enough.\n\tSampling the texels from the corners boosts the blurring process with filtering.\n\t\n\treference: https://www.shadertoy.com/view/Xd33Rf by IQ\n*/\n\n//gaussian weights. \n// http://dev.theomader.com/gaussian-kernel-calculator/\nconst float [] weights = float [] (\t0.44198,\t0.27901);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 col = vec3(0.0);\n    vec2 offset = vec2(.5)/iResolution.xy;\n    for (int i = 0; i < 3; ++i)\n    {\n        int index = abs(i-1);\n        float w = weights[index];\n        vec2 uv = vec2(fragCoord.xy + vec2(float(index)+0.5, 0.5))/iResolution.xy;\n        vec3 cl = texture(iChannel0, uv).rgb;\n        \n        float f = smoothstep(0.1, .8, cl.r-cl.b);\n    \tcol += cl*w*f;\n    }\n    \n\tfragColor.rgb = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}