{
    "Shader": {
        "info": {
            "date": "1560218582",
            "description": "Inspired by https://www.instagram.com/p/Bxm4B4ZlS5h/ by monochromeandminimal",
            "flags": 1,
            "hasliked": 0,
            "id": "ttj3Ry",
            "likes": 11,
            "name": "HypnoSphere",
            "published": 3,
            "tags": [
                "sphere",
                "hypnotic",
                "minimalist"
            ],
            "usePreview": 0,
            "username": "xjorma",
            "viewed": 718
        },
        "renderpass": [
            {
                "code": "// Created by David Gallardo - xjorma/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n#define AA\n//#define CUBE\n\n\nfloat sinnoise(vec3 p,float t)\n{\n    \n     for (int i=0; i<2; i++)\n    \tp += cos( p.yzx*3. + vec3(t,1.6,1.6)) / 3.,\n        p += sin( p.yzx + t + vec3(1.6,t,1.6)) / 2.,\n        p *= 1.3;\n    \n    return sin(length(p));\n}\n\nfloat saturate(float c)\n{\n    return clamp(c,0.,1.);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nvec2 minVecSelect(vec2 a, vec2 b)\n{\n    return a.x<b.x?a:b;\n}\n\nvec2 map(in vec3 p)\n{\n#ifndef CUBE\n    float d = sdSphere(p,1.);\n#else\n    float d = sdBox(p,vec3(0.75));\n#endif\n    float n = sinnoise(p*2., iTime / 6. + 8.);\n\tfloat s = max(d,n/8.);\n    return minVecSelect(vec2(s, n),vec2(p.y + 1.1, 0));\n}\n\n\nvec3 calcNormal(vec3 p)\n{\n    const float h = 0.02;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy * map(p + k.xyy*h).x + \n                      k.yyx * map(p + k.yyx*h).x + \n                      k.yxy * map(p + k.yxy*h).x + \n                      k.xxx * map(p + k.xxx*h).x );\n}\n\n\nvec3 Render(vec3 ro,vec3 rd,vec3 cd,float dist)\n{\n    float t = 1.0;\n    float d;\n    float noise = 0.;\n    for( int i=0; i<1024; i++ )\n    {\n        vec3\tp = ro + t*rd;\n        vec2\th = map(p);\n        t += h.x*0.7;\n        d = dot(t*rd,cd);\n        noise = h.y;\n        if( abs(h.x)<0.0001 || d>dist ) break;\n    }\n\n    vec3 col = vec3(0.5);\n\n    if( d<dist )\n    {\n        vec3 light = vec3(0.,10.,2.);\n        vec3 p = ro + t*rd;\n        vec3 n = calcNormal(p);\n        vec3 v = normalize(ro-p);\n        vec3 l = normalize(light-p);\n        vec3 h = normalize(l+v);\n        \n        vec3 diffcol = vec3(mix(saturate(pow(abs(sin(noise*16.))*1.5,15.)) ,1.,0.3)); \n        vec3 speccol = vec3(1.,1.,1.);\n        vec3 ambcol = diffcol;\n        \n        col = saturate(dot(n,l)) * diffcol;\n        col+= pow(saturate(dot(n,h)),20.) * speccol;\n        col+= 0.2 * ambcol;\n    }\n    return col;\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n    fragColor = vec4(Render(ro/3. + vec3(0.0,.0,4.0),rd ,rd,14.) ,1);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 tot = vec3(0.0);\n        \n#ifdef AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n \n        // camera\n        \n        float theta\t= radians(360.)*(iMouse.x/iResolution.x-0.5) + iTime*.1;\n        float phi\t= radians(90.)*(iMouse.y/iResolution.y-0.5)-1.;\n        vec3 ro = 2.*vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        //vec3 ro = vec3(0.0,.2,4.0);\n        vec3 ta = vec3( 0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        //vec3 cd = ca[2];    \n        \n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        \n        vec3 col = Render(ro ,rd ,ca[2],12.);\n\n\t    tot += col;\n#ifdef AA\n    }\n    tot /= 4.;\n#endif\n\n\tfragColor = vec4( sqrt(tot), 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}