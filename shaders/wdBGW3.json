{
    "Shader": {
        "info": {
            "date": "1550098307",
            "description": "I stream shader creation every Wednesday at 9pm UK time, over at [url]https://twitch.tv/lunasorcery[/url]\nCome and watch a show!\n\nOr watch the VOD for this shader here: [url]https://www.twitch.tv/videos/380207883[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "wdBGW3",
            "likes": 53,
            "name": "[twitch] Door Warehouse",
            "published": 3,
            "tags": [
                "raymarcher",
                "livecoding",
                "twitch"
            ],
            "usePreview": 0,
            "username": "yx",
            "viewed": 1932
        },
        "renderpass": [
            {
                "code": "/*\n\tThis shader was created live on stream!\n\tYou can watch the VOD here: https://www.twitch.tv/videos/380207883\n\n\tI use the Bonzomatic tool by Gargaj/Conspiracy:\n\thttps://github.com/Gargaj/Bonzomatic\n\n\tWednesdays around 9pm UK time I stream at https://twitch.tv/lunasorcery\n\tCome and watch a show!\n\n\t~yx\n*/\n\n#define pi acos(-1.)\n\n\nvec2 rotate(vec2 a, float b)\n{\n    float c=cos(b);\n    float s=sin(b);\n    return vec2(\n        a.x*c-a.y*s,\n        a.x*s+a.y*c\n    );\n}\n\nfloat sdBox(vec3 p, vec3 r)\n{\n    p=abs(p)-r;\n    return max(max(p.x,p.y),p.z);\n}\n\nfloat sdBox(vec3 p, vec3 a, vec3 b)\n{\n    return sdBox(p-(a+b)/2.,abs(b-a)/2.);\n}\n\nfloat sdPlane(vec3 p, vec4 n)\n{\n    n.xyz = normalize(n.xyz);\n    return dot(vec4(p,1),n);\n}\n\nfloat sdCappedCylinder(vec3 p, vec4 r)\n{\n\n    return max(\n        length(p.xy-r.xy)-r.z,\n        abs(p.z)-r.w\n    );\n}\n\nfloat noise(vec3 p)\n{\n    return fract(sin(dot(p,vec3(13.43672,4.534782,21.43672)))*234.432);\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat sdChamferBox(vec3 p, vec3 r, float R)\n{\n    p=abs(p);\n    p=max(p,r-R);\n    return (dot(p-r,vec3(1))+R+R)/sqrt(3.);\n}\n\nint mat;\nvec3 cell;\n\nfloat sdDoor(vec3 p)\n{\n    float rail = sdBox(p, vec3(-.3,5.2,-10), vec3(.3,5.4,10));\n\n    float yoffs = 5.5;\n    p.y-=yoffs;\n    p.xy = rotate(p.xy, sin(iTime*4.+cell.z*10.)*.1);\n    p.y+=yoffs;\n\n    vec3 np = p;\n\n    float door = sdBox(p,vec3(2,4,.15));\n    p.xz = abs(p.xz);\n    p.z-=.2;\n    door=max(door, -sdChamferBox(p, vec3(1.4,3.4,.1), .2));\n    p.z+=.2;\n    if(noise(cell)>.5)\n        door = min(door, sdBox(p, vec3(-.1,3.5,0.03), vec3(.3,-3.5,.15)));\n    if(noise(cell+1.)>.5)\n        door = min(door, sdBox(p, vec3(-2,-.8,0.03), vec3(2,-.2,.15)));\n\n    float frame = sdBox(p, vec3(2,-4.2,-.3), vec3(2.4,4.1,.3));\n    frame = min(frame, sdBox(p, vec3(-.1, 4, -.3), vec3(2.4, 5., .3)));\n    frame = min(frame, sdBox(p, vec3(-.1, -4.4, -.3), vec3(2.4, -4, .3)));\n    frame = min(frame, sdBox(p, vec3(-.1, -4.55, -.2), vec3(.5, -4, .2)));\n    frame = min(frame, sdBox(p, vec3(1, -4.55, -.2), vec3(1.6, -4, .2)));\n\n    float frameMask = sdPlane(p, vec4(1,1,0,-4.7));\n    frameMask = max(frameMask, sdPlane(p, vec4(.2,1,0,-4.9)));\n    frameMask = max(frameMask, sdPlane(p, vec4(-.2,1,0,-4.4)));\n    frameMask = min(frameMask, sdPlane(p, vec4(2,1,0,-2.7)));\n\n    frame = max(frame, frameMask);\n    frame = min(frame, sdCappedCylinder(p, vec4(0,4.5,.3,.36)));\n    frame = min(frame, sdBox(p, vec3(.3, 5, -.3), vec3(.5,5.6,.3)));\n    frame = min(frame, sdBox(p, vec3(-.5, 5.4, -.3), vec3(.5,5.6,.3)));\n\n    frame = min(frame, sdSphere(np-vec3(1.5,-.5,.5), .25));\n\n    float light = sdCappedCylinder(p, vec4(0,4.5,.22,.42));\n\n    float dist = min(min(door,rail), min(frame, light));\n    if (door == dist) {\n        mat=1;\n    } else if (light == dist) {\n        mat=2;\n    } else {\n        mat=3;\n    }\n\n    return dist;\n}\n\nfloat scene(vec3 p)\n{\n    const vec3 cellsize = vec3(20, 18, 8);\n    p.xy += p.z*p.z*.002;\n    p.y -= iTime;\n    p.z -= sign(sin(p.x/cellsize.x*pi)*sin(p.y/cellsize.y*pi))*iTime*25.; // thanks, theartofcode\n    cell = floor(p/cellsize);\n    p = mod(p, cellsize)-cellsize*.5;\n    return sdDoor(p);\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 cam = vec3(0,2,15);\n    vec3 dir = normalize(vec3(uv,-1));\n\n    cam.yz = rotate(cam.yz, -.1);\n    dir.yz = rotate(dir.yz, -.1);\n\n    vec3 bg = vec3(.1,.15,.2);\n\n    float t = 0.;\n    float k = 0.;\n    for(int i=0;i<100;++i) {\n        k=scene(cam+dir*t);\n        t+=k;\n        if(k<.001)\n        {\n            vec3 h = cam+dir*t;\n            vec2 o=vec2(.02,0);\n            vec3 n= normalize(vec3(\n                scene(h+o.xyy)-scene(h-o.xyy),\n                scene(h+o.yxy)-scene(h-o.yxy),\n                scene(h+o.yyx)-scene(h-o.yyx)\n            ));\n\n            float light = dot(n,normalize(vec3(1,2,3)))*2.;\n\n            if (mat == 1)\n            {\n                vec3 color = vec3(\n                    noise(cell.xyz),\n                    noise(cell.yzx),\n                    noise(cell.zxy)\n                )*.8+.2;\n                out_color.rgb = vec3(light)*color;\n            }\n            else if (mat == 2)\n            {\n                out_color.rgb = light*vec3(1,.1,.1)*.7;\n            }\n            else\n            {\n                out_color.rgb = light*vec3(.5);\n            }\n\n            out_color.rgb = mix(bg, out_color.rgb, pow(.985, t-15.));\n\n            return;\n        }\n    }\n    out_color.rgb = bg;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}