{
    "Shader": {
        "info": {
            "date": "1601912039",
            "description": "Small & efficient RGB -> HSV and HSV -> RGB conversion functions for your shaders! Public domain/CC0. Original algorithms by Sam Hocevar, licensed under the WTFPL (which can be re-licensed however you want, e.g. to CC0!)",
            "flags": 0,
            "hasliked": 0,
            "id": "tstcDX",
            "likes": 4,
            "name": "One-liner RGB+HSV Converters",
            "published": 3,
            "tags": [
                "color",
                "rgb",
                "hsv",
                "conversion",
                "oneliner"
            ],
            "usePreview": 0,
            "username": "kowbell",
            "viewed": 380
        },
        "renderpass": [
            {
                "code": "/** \n * Public Domain drag-n-drop RGB <-> HSV converters for your shaders.\n * All you need are the two following one-liner functions!\n * You can even drop the preceeding comment with attribution\n * if you want!\n *\n * Non-minified, easier-to-read functions available\n * commented out below.\n *\n * These are both originally by Sam Hocevar \n * who has generously released these over the WTFPL, \n * which can be freely relicensed as CC0/Public Domain.\n * See https://stackoverflow.com/a/17897228/8940353\n * and http://www.wtfpl.net/faq/ (profanity warning)\n *\n * So, these are public domain! But please credit Mr. Hocevar\n * if you don't mind! Or link back to this shader so we can\n * credit Mr. Hocevar AND show folks the unminified source :)\n *\n * Check out my other handy one-liner shader utilities at\n * https://www.shadertoy.com/playlist/l323Wz\n */\n\n\n// Combined one-liner with signatures first & attrib link:\n/* shadertoy.com/view/tstcDX */ vec3 rgb2hsv(vec3 c); vec3 hsv2rgb(vec3 c); vec3 rgb2hsv(vec3 c){const vec4 K=vec4(0.,-1./3.,2./3.,-1.);vec4 p=mix(vec4(c.bg,K.wz),vec4(c.gb,K.xy),step(c.b,c.g));vec4 q=mix(vec4(p.xyw,c.r),vec4(c.r,p.yzx),step(p.x,c.r));float d=q.x-min(q.w,q.y);const float e=1.e-10;return vec3(abs(q.z+(q.w-q.y)/(6.*d+e)),d/(q.x+e),q.x);} vec3 hsv2rgb(vec3 c){const vec4 K=vec4(1.,2./3.,1./3.,3.);vec3 p=abs(fract(c.xxx+K.xyz)*6.-K.www);return c.z*mix(K.xxx,clamp(p-K.xxx,0.,1.),c.y);}\n\n\n\n// OR, Separate one-liners with attribution:\n/* RGB<->HSV Algorithms by Sam Hocevar. CC0. See https://www.shadertoy.com/view/tstcDX for more info. */\n//vec3 rgb2hsv(vec3 c){const vec4 K=vec4(0.,-1./3.,2./3.,-1.);vec4 p=mix(vec4(c.bg,K.wz),vec4(c.gb,K.xy),step(c.b,c.g));vec4 q=mix(vec4(p.xyw,c.r),vec4(c.r,p.yzx),step(p.x,c.r));float d=q.x-min(q.w,q.y);const float e=1.e-10;return vec3(abs(q.z+(q.w-q.y)/(6.*d+e)),d/(q.x+e),q.x);}\n//vec3 hsv2rgb(vec3 c){const vec4 K=vec4(1.,2./3.,1./3.,3.);vec3 p=abs(fract(c.xxx+K.xyz)*6.-K.www);return c.z*mix(K.xxx,clamp(p-K.xxx,0.,1.),c.y);}\n\n\n\n\n\n\n\n/** NON-MINIFIED VERSIONS ******************************************* */\n/*\nvec3 rgb2hsv(vec3 c)\n{\n    const vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    const float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n*/\n\n\n\n\n\n/** DEMO ******************************************* */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 mouse = iMouse.xy/iResolution.xy;\n    \n    float scaledTime = iTime * 0.1;\n    float time01 = mod(scaledTime, 1.);\n    \n    // vary hue over time,\n    // map saturation to mouse x,\n    // map value to mouse y\n    // Mouse values are inverted bc the first time you open this\n    // shader mouse will be at (0,0), and I don't want you to\n    // think this is broken ;)\n    vec3 col = hsv2rgb(vec3(time01, 1. - mouse.x, 1. - mouse.y));\n    \n    // Demonstrate that these functions inverse each other\n    // If you see a difference in the left & right halves of\n    // the intro, then the formulas are borked :(\n    if (uv.x > .5)\n    {\n        col = hsv2rgb(rgb2hsv(col));\n    }\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}