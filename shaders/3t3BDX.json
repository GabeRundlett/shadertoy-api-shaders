{
    "Shader": {
        "info": {
            "date": "1613528169",
            "description": "VERY messy code\nTried to convert a shape grammar from a class I took into a pattern generator (I have a version where the parameters are controlled by a midi controller)\nhttps://silsprod.files.wordpress.com/2021/02/gramaticas-ff.pdf",
            "flags": 0,
            "hasliked": 0,
            "id": "3t3BDX",
            "likes": 7,
            "name": "Weird 2d patterns",
            "published": 3,
            "tags": [
                "2d",
                "pattern",
                "shape",
                "grammar",
                "girih"
            ],
            "usePreview": 0,
            "username": "lousisx",
            "viewed": 354
        },
        "renderpass": [
            {
                "code": "#define TWO_PI 6.28318\n#define p_offset 0.\n\n////////   very messy, lots of unused code   //////////\n\n\nfloat sdLine (in vec2 p, in vec2 a, in vec2 b){ //line sdf\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n\treturn length (pa-ba*h);\n}\nvec2 pcart (in float r, in float a){          //polar to cartesian \n\treturn vec2(r*cos(a),r*sin(a));\n}\nvec2 cpol (in float x, in float y){           //cartesian to polar\n\treturn vec2(sqrt(pow(x,2.)+pow(y,2.)),atan(y/x));\n}\n//--------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = ( 2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tuv *= 3.; //zoom\n    \n    \n    //rotate 45'\n    float ks = sin(.8), kc = cos(.8);\n    mat2 m = mat2(-kc,ks,ks,kc);\n    //uv = m*uv;\n    \n    \n    //create and offset tiles\n\tfloat hh;\n    \n    if (p_offset == 1.){\n    hh = 0.895;\n\tuv.x += step(1.,mod(uv.y,2.)) *(hh/2.);\n\tuv.x  = mod(uv.x,hh);\n\tuv.y  = mod(uv.y,1.)-0.05;\n    }\n    else{\n    hh = 1.;\n\tuv.x  = mod(uv.x,2.);\n\tuv.y  = mod(uv.y,2.*hh);\n    }\n\tfloat ofs = 0.12;                //center offset\n\tfloat len = hh * 0.516 - ofs;    //length size\n    float div = 2. + iTime/5.;                 //division\n    float lnw = 0.05;              //line weight\n\tfloat ang;\n\tfloat sec;\n\tvec3  lin;\n    vec3  col;\n\tfloat mi = 1.; \n    \n    if (uv.x >=1.){uv.x = 2.-uv.x;}\n    if (uv.y >=1.){uv.y = 2.-uv.y;}\n    \n    for(float m = 0.; m < 2.; m++){        //mirror x coordinate\n        if(m == 1.){uv.x = hh - uv.x;}\n        for(float i = 0.; i < div; i++){   //radial array\n            sec = 6.28318/div;\n            ang = sec*i+sec/2.;\n    \n            vec2 a = pcart(ofs,ang); a += vec2(hh/2.,0.5);\n            \n            vec2 b = a + pcart(len*(1. + sin(iTime/2.)),ang + sec*1.50);\n            vec2 c = b + pcart(len*10.50,ang + sin(iTime)*1.6+.5);\n            \n            \n            // minimum sdf\n            mi = min(mi, sdLine(uv,a,b));\n            mi = min(mi, sdLine(uv,b,c));\n            //mi = min(mi, sdLine(uv,c,d));\n            //mi = min(mi, sdLine(uv,d,e));\n            //mi = min(mi, sdLine(uv,f,g));\n        }\n    }\n    \n    //col  = vec3(1.0) ;\n    col *= 0.3 + 0.4*smoothstep(mi,0.02,0.00);\n    col *= 1.0 + 0.2*smoothstep(mi,0.03,0.00);\n    col  = mix(col,vec3(1.0),1.0-smoothstep(0.0,lnw,abs(mi)));\n    \n\tfragColor = vec4(col, 1.0);\n}\n    ",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}