{
    "Shader": {
        "info": {
            "date": "1700115859",
            "description": "For the purposes of study, I derived all the SDFs and all but the torus ray-primitive intersection myself.  Idea: If ray intersection fails, SDF d += MAX_D --> less marching steps.",
            "flags": 0,
            "hasliked": 0,
            "id": "ctyyR1",
            "likes": 9,
            "name": "Study: Gyre and Gimble",
            "published": 3,
            "tags": [
                "scifi"
            ],
            "usePreview": 1,
            "username": "kp1197",
            "viewed": 241
        },
        "renderpass": [
            {
                "code": "\n\n// DONE! TODO: fix marching problems\n// DONE! TODO: camera controls\n// DONE! TODO: surface normals\n// DONE! TODO: distance fog\n// TODO: soft shadows\n// TODO: volumetric effects (crepuscular rays)\n\n\nmat4 rx1;\nmat4 rx2;\nmat4 rx3;\nmat4 rx4;\nmat4 rx5;\n\nmat4 tx1;\nmat4 tx2;\nmat4 tx3;\nmat4 tx4;\nmat4 tx5;\n\n// pre-compute transforms so we don't create them in an inner loop\nvoid initRxTx() {\n    \n    float t = iTime + 3.;\n    \n    // outermost ring\n    rx1 = IDENTITY;\n    tx1 = inverse(GLOBAL_TRANSLATION);\n    \n    // ring 2\n    mat4 rx = rotMatrix(0.,t,0.);\n    rx2 = rx * rx1;\n    tx2 = rx * tx1;\n    \n    // ring 3\n    rx = rotMatrix(t,0.,0.);\n    rx3 = rx * rx2;\n    tx3 = rx * tx2;   \n    \n    // ring 4\n    rx = rotMatrix(0.,t,0.);\n    rx4 = rx * rx3;\n    tx4 = rx * tx3;    \n    \n    // gyre/light\n    rx = rotMatrix(0., 5.*t, 0.);\n    rx5 = rx * rx4;\n    tx5 = rx * tx4;\n}\n\n// this map functions updates the material when a new closest primitive is found.\nfloat map(in vec3 ray, in vec4 globalP, in float d, inout vec4 currentMaterial, in float include_lights) {\n\n    vec4 globalRay = vec4(ray,1.);\n    \n    // transformation of p and ray into local transform space\n    vec4 localP   = tx1 * globalP;\n    vec4 localRay = rx1 * globalRay;\n    \n    float dRing;\n    vec4 ringMaterial;\n    \n    // outermost ring\n    localP   = tx2 * globalP;\n    localRay = rx2 * globalRay;\n    dRing = pRing(localP, vec2(4.,R2)) + MAX_D * pRingBounds(localRay.xyz, localP, vec2(4.,BOUNDSR2));\n    ringMaterial = vec4(localP.xyz, RING_MATERIAL);\n    d = matmin(d, dRing, currentMaterial, ringMaterial, include_lights);\n    \n    // ring 2\n    localP   = tx3 * globalP;\n    localRay = rx3 * globalRay;\n    dRing = pRing(localP, vec2(3.,R2)) + MAX_D * pRingBounds(localRay.xyz, localP, vec2(3.,BOUNDSR2));\n    ringMaterial = vec4(localP.xyz, RING_MATERIAL);\n    d = matmin(d, dRing, currentMaterial, ringMaterial, include_lights); \n    \n    // ring 3\n    localP   = tx4 * globalP;\n    localRay = rx4 * globalRay;\n    dRing = pRing(localP, vec2(2.,R2)) + MAX_D * pRingBounds(localRay.xyz, localP, vec2(2.,BOUNDSR2));\n    ringMaterial = vec4(localP.xyz, RING_MATERIAL);\n    d = matmin(d, dRing, currentMaterial, ringMaterial, include_lights);\n    \n    // ring 4\n    localP   = tx5 * globalP;\n    localRay = rx5 * globalRay;\n    dRing = pRing(localP, vec2(1.,R2)) + MAX_D * pRingBounds(localRay.xyz, localP, vec2(1.,BOUNDSR2));\n    ringMaterial = vec4(localP.xyz, RING_MATERIAL);\n    d = matmin(d, dRing, currentMaterial, ringMaterial, include_lights);    \n\n    // gyre\n    localP   = tx5 * globalP;\n    localRay = rx5 * globalRay;\n    float dSphere = pSphere(localP.xyz, GYRE_RADIUS) + MAX_D * pSphereBounds(localRay.xyz, localP, GYRE_RADIUS);\n    vec4 gyreMaterial = vec4(localP.xyz, GYRE_MATERIAL);\n    d = matmin(d, dSphere, currentMaterial, gyreMaterial, include_lights);\n\n    // floor\n    localP = globalP + vec4(0.,5.,0.,0.);\n    float dFloor = pPlane(localP) + MAX_D * pPlaneBounds(ray, localP);\n    vec4 floorMaterial = vec4(localP.xyz, FLOOR_MATERIAL);\n    d = matmin(d, dFloor, currentMaterial, floorMaterial, include_lights);  \n    \n    return d;\n}\n\n\nvec4 material_query(vec3 ray, inout vec4 globalP) {\n    \n    float currentD = MAX_D;\n    float totalD = 0.;\n    vec4 currentMaterial = vec4(globalP.xyz, SKY_MATERIAL);\n    float hit = 0.0;\n    \n    // raymarch\n    for (int i = 0; i < MAX_STEPS && currentD <= MAX_D; i++) {\n        \n        // uses out params to update the current object coords / material (vec4 currentMaterial) and current distance (float currentD)\n        currentD = map(ray, globalP, currentD, currentMaterial, 1.);\n        totalD += currentD;\n        \n        if (currentD < EPS) {\n            hit = 1.;\n            break;\n        }\n        \n        if (currentD > MAX_D) {\n            hit = 0.;\n            break;\n        }\n        \n        globalP += vec4(ray * currentD, 0.);\n    }\n    \n    // return position in local (object) coordinates and the material ID\n    return currentMaterial * vec4(1.,1.,1.,hit);\n}\n\n// SDF marches from light to object, checking if we can reach the object from the light\n// returns light surface local coordinates (xyz) and shadowing amount (w)\nfloat directIllumination(vec4 lightSurfacePos, vec4 objPos) {\n\n    // setup raymarch, heading from light to object\n    float currentD = MAX_D;\n    float totalD = 0.;\n    vec3 lightToObjectRay = normalize(objPos.xyz - lightSurfacePos.xyz);\n    \n    // SDF raymarch from light surface to objPos, breaking if close to objPos\n    vec4 _;    \n    for (int i = 0; i < MAX_STEPS && currentD <= MAX_D; i++) {\n        currentD = map(lightToObjectRay, lightSurfacePos, currentD, _, 0.);\n        totalD += currentD;\n        // we hit an object...\n        if (currentD < EPS) {\n            // if we made it back to the original object position, hurray, it's illuminated!\n            return step(length(lightSurfacePos.xyz - objPos.xyz), 5.*EPS);\n        }\n        if (totalD > MAX_D) {\n            return 0.;\n        }\n        lightSurfacePos += vec4(lightToObjectRay * currentD, 0.);\n    }\n    return 0.0;\n}\n\nvec3 calcCentralDifferencesNormal(vec3 ray, vec4 worldP) {\n    vec2 eps = vec2(EPS,0.);\n    vec4 _;\n    float dx1 = map(ray, worldP + eps.xyyy, MAX_D, _, 1.);\n    float dy1 = map(ray, worldP + eps.yxyy, MAX_D, _, 1.);\n    float dz1 = map(ray, worldP + eps.yyxy, MAX_D, _, 1.);\n    float dx2 = map(ray, worldP - eps.xyyy, MAX_D, _, 1.);\n    float dy2 = map(ray, worldP - eps.yxyy, MAX_D, _, 1.);\n    float dz2 = map(ray, worldP - eps.yyxy, MAX_D, _, 1.);\n    return normalize(vec3(dx1 - dx2, dy1 - dy2, dz1 - dz2)/(2.*eps.x));\n}\n\nvec3 getDiffuse(in vec4 result, in vec3 ray) { \n    // SKY\n    if (result.w < 0.5) {\n        return vec3(max(0.,ray.y));\n    }\n    // RING\n    else if (result.w < 1.5) {\n        return DIFFUSE_TERM * texture(iChannel0, result.xyz).xxx;\n    }\n    // LAND\n    else if (result.w < 2.5) {\n        return DIFFUSE_TERM * texture(iChannel2, result.xz).xyz;        \n    }\n    // LIGHT\n    else {\n        return pow(texture(iChannel1, result.xyz / LIGHT_COLOR_REPEAT).xyz, vec3(0.2));\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // standard uv\n    vec2 uv = 2.*(fragCoord/iResolution.xx - 0.5 * vec2(1.,iResolution.y/iResolution.x));    \n    \n    // camera setup\n    vec3 ray = normalize(vec3(uv, 1.));\n    vec4 worldP = vec4(0.,0.,0.,1.);\n    mat4 camTx = translationMatrix(SCENE_CENTER);\n    mat4 camRx = rotMatrix(0.,TAU * iMouse.x / iResolution.x - PI,0.);\n    ray    = (camRx * vec4(ray,1.)).xyz;\n    worldP = camTx * camRx * inverse(camTx) * worldP;\n    \n    // calculate matrices\n    initRxTx();\n    \n    // material query\n    vec4 result = material_query(ray, worldP);\n    \n    // start with diffuse\n    vec3 col = getDiffuse(result, ray);\n    \n    \n    // illumination query\n    vec3 lightToObjRay = normalize(worldP.xyz - SCENE_CENTER);\n    vec4 lightSurfacePos = vec4(GYRE_RADIUS * lightToObjRay + SCENE_CENTER,1.);\n    float lightDistance = length(worldP.xyz - lightSurfacePos.xyz);\n    float illuminated = directIllumination(lightSurfacePos, worldP);\n    \n    // normal\n    vec3 normal = calcCentralDifferencesNormal(ray, worldP);\n \n    \n    // illumination color - sample local coordinates of light object\n    vec4 lightMaterial;\n    map(vec3(0.), lightSurfacePos, MAX_D, lightMaterial, 1.);\n    vec3 lightColor = texture(iChannel1, lightMaterial.xyz / LIGHT_COLOR_REPEAT).xyz;\n    float falloff = pow(max(0.,LIGHT_RADIUS - lightDistance) / LIGHT_RADIUS,2.);\n    float shade = abs(dot(-lightToObjRay,normal.xyz));\n    float lightMask = (step(0.5, result.w) * step(result.w, 50.));\n    \n    \n    \n    // illuminate non-sky and non-light sources\n    col += lightMask * 0.6 * shade * falloff * illuminated * lightColor;\n    \n    // fake ambient lighting from floor\n    col += 0.05 * (dot(normal, vec3(0.,-1.,0.))) * lightColor;\n    \n    // gamma correction\n    col = pow(col, vec3(1.0/2.2));\n    \n    // fake distance fog\n    float objDist = length(worldP.xyz - SCENE_CENTER);\n    col *= 1. - objDist / MAX_D;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "volume",
                        "id": 40,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin"
                    },
                    {
                        "channel": 1,
                        "ctype": "volume",
                        "id": 40,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// math constants\n#define PI  3.14159\n#define TAU 6.28318\n\n// raymarching\n#define EPS 1e-2\n#define MAX_STEPS 30\n#define MAX_D 20.\n\n\n// materials\n#define SKY_MATERIAL 0.\n#define RING_MATERIAL 1.\n#define FLOOR_MATERIAL 2.\n#define GYRE_MATERIAL 99.\n\n// scene\n#define SCENE_CENTER vec3(1e-6,0.,10.)\n#define GLOBAL_TRANSLATION translationMatrix(SCENE_CENTER)\n#define GYRE_ROTATION rotMatrix(0., 0.25*iTime, 0.)\n#define LIGHT_COLOR_REPEAT 20.\n#define R2 0.5\n#define BOUNDSR2 R2*1.1\n#define GYRE_RADIUS (0.5 + 0.015 * sin(20.*iTime))\n#define LIGHT_RADIUS 10.\n\n// lighting\n#define DIFFUSE_TERM 0.05\n\nconst mat4 IDENTITY = mat4(1.,0.,0.,0.,  0.,1.,0.,0., 0.,0.,1.,0., 0.,0.,0.,1.);\n\nfloat pRing(in vec4 p, in vec2 spec) {\n    vec3 rimPoint = vec3(spec.x * normalize(p.xy), 0.);\n    return length(rimPoint - p.xyz) - spec.y;\n    //same results as IQ: return length( vec2(length(p.xy)-spec.x,p.z) )-spec.y;\n}\n\nfloat pSphere(in vec3 p, in float radius) {\n    return length(p) - radius;\n}\n\nfloat pPlane(in vec4 p) {\n    return p.y;\n}\n\n\n\n/* Does ray @ p intersect a plane @ vec3(0.) within radius units of vec3(0.)? */\nfloat pSphereBounds(in vec3 ray, in vec4 p, in float radius) {\n    vec3 N = ray; // ray is already normalized, and is already the plane's normal vector\n    float t = dot(N,-p.xyz) / dot(N,ray); // solve for t, parametric form of ray \n    vec3 I = p.xyz + t * ray; // calculate intersection with plane\n    return max(step(t,1e-9),step(radius-length(I),0.)); // return MAX_D if t <= 0.0 or I outside of radius in plane\n}\n\nfloat pPlaneBounds(in vec3 ray, in vec4 p) {\n    // if signs agree, no intersection (i.e.; p is below plane and ray is negative)\n    return step(-EPS, sign(p.y) * sign(ray.y));\n}\n\n// i gave in... quartic discriminant had numerical issues... ty IQ\nfloat iTorus( in vec3 ro, in vec3 rd, in vec2 tor )\n{\n    float po = 1.0;\n    \n    float Ra2 = tor.x*tor.x;\n    float ra2 = tor.y*tor.y;\n\t\n    float m = dot(ro,ro);\n    float n = dot(ro,rd);\n\n    // bounding sphere\n    {\n\tfloat h = n*n - m + (tor.x+tor.y)*(tor.x+tor.y);\n\tif( h<0.0 ) return -1.0;\n\t//float t = -n-sqrt(h); // could use this to compute intersections from ro+t*rd\n    }\n    \n\t// find quartic equation\n    float k = (m - ra2 - Ra2)/2.0;\n    float k3 = n;\n    float k2 = n*n + Ra2*rd.z*rd.z + k;\n    float k1 = k*n + Ra2*ro.z*rd.z;\n    float k0 = k*k + Ra2*ro.z*ro.z - Ra2*ra2;\n\t\n    #if 1\n    // prevent |c1| from being too close to zero\n    if( abs(k3*(k3*k3 - k2) + k1) < 0.01 )\n    {\n        po = -1.0;\n        float tmp=k1; k1=k3; k3=tmp;\n        k0 = 1.0/k0;\n        k1 = k1*k0;\n        k2 = k2*k0;\n        k3 = k3*k0;\n    }\n\t#endif\n\n    float c2 = 2.0*k2 - 3.0*k3*k3;\n    float c1 = k3*(k3*k3 - k2) + k1;\n    float c0 = k3*(k3*(-3.0*k3*k3 + 4.0*k2) - 8.0*k1) + 4.0*k0;\n\n    \n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n    \n    float Q = c2*c2 + c0;\n    float R = 3.0*c0*c2 - c2*c2*c2 - c1*c1;\n    \n\t\n    float h = R*R - Q*Q*Q;\n    float z = 0.0;\n    if( h < 0.0 )\n    {\n    \t// 4 intersections\n        float sQ = sqrt(Q);\n        z = 2.0*sQ*cos( acos(R/(sQ*Q)) / 3.0 );\n    }\n    else\n    {\n        // 2 intersections\n        float sQ = pow( sqrt(h) + abs(R), 1.0/3.0 );\n        z = sign(R)*abs( sQ + Q/sQ );\n    }\t\t\n    z = c2 - z;\n\t\n    float d1 = z   - 3.0*c2;\n    float d2 = z*z - 3.0*c0;\n    if( abs(d1) < 1.0e-4 )\n    {\n        if( d2 < 0.0 ) return -1.0;\n        d2 = sqrt(d2);\n    }\n    else\n    {\n        if( d1 < 0.0 ) return -1.0;\n        d1 = sqrt( d1/2.0 );\n        d2 = c1/d1;\n    }\n\n    //----------------------------------\n\t\n    float result = 1e20;\n\n    h = d1*d1 - z + d2;\n    if( h > 0.0 )\n    {\n        h = sqrt(h);\n        float t1 = -d1 - h - k3; t1 = (po<0.0)?2.0/t1:t1;\n        float t2 = -d1 + h - k3; t2 = (po<0.0)?2.0/t2:t2;\n        if( t1 > 0.0 ) result=t1; \n        if( t2 > 0.0 ) result=min(result,t2);\n    }\n\n    h = d1*d1 - z - d2;\n    if( h > 0.0 )\n    {\n        h = sqrt(h);\n        float t1 = d1 - h - k3;  t1 = (po<0.0)?2.0/t1:t1;\n        float t2 = d1 + h - k3;  t2 = (po<0.0)?2.0/t2:t2;\n        if( t1 > 0.0 ) result=min(result,t1);\n        if( t2 > 0.0 ) result=min(result,t2);\n    }\n\n    return result;\n}\n\nfloat pRingBounds(in vec3 ray, in vec4 p, in vec2 spec) {\n    float d = iTorus(p.xyz, ray, spec);\n    return step(d,0.);\n}\n\n\nmat4 rotMatrix(in float gamma, in float beta, in float alpha) {\n\n    float cos_alpha = cos(alpha);\n    float sin_alpha = sin(alpha);\n    float cos_beta = cos(beta);\n    float sin_beta = sin(beta);\n    float cos_gamma = cos(gamma);\n    float sin_gamma = sin(gamma);\n\n    return mat4( cos_alpha * cos_beta,  \\\n        cos_alpha * sin_beta * sin_gamma - sin_alpha * cos_gamma,\\\n        cos_alpha * sin_beta * cos_gamma + sin_alpha * sin_gamma,\\\n        0.,\\\n        sin_alpha * cos_beta,\\\n        sin_alpha * sin_beta * sin_gamma + cos_alpha * cos_gamma, \\\n        sin_alpha * sin_beta * cos_gamma - cos_alpha * sin_gamma, \\\n        0.,\\\n        -sin_beta, \\\n        cos_beta * sin_gamma, \\\n        cos_beta * cos_gamma,\\\n        0.,\\\n        0.,0.,0.,1.);\n}\n\nmat4 translationMatrix(in vec3 tx) {\n    return mat4(1.,0.,0.,0.,   0.,1.,0.,0., 0.,0.,1.,0., tx.x,tx.y,tx.z,1.);\n}\n\nfloat matmin(in float currentD, in float d, inout vec4 currentMaterial, in vec4 material, in float include_lights) {\n    d = d + (1.-include_lights) * step(50.,material.w) * MAX_D;\n    float signal = step(d, currentD);\n    currentMaterial = mix(currentMaterial, material, signal);\n    return min(currentD, d);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}