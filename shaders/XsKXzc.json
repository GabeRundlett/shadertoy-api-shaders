{
    "Shader": {
        "info": {
            "date": "1465911595",
            "description": "Constructing a basic fractal object with Knighty's Kaleidoscopic IFS procedure.",
            "flags": 0,
            "hasliked": 0,
            "id": "XsKXzc",
            "likes": 92,
            "name": "KIFS Flythrough",
            "published": 3,
            "tags": [
                "fractal",
                "kifs",
                "environment",
                "mapped"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 5835
        },
        "renderpass": [
            {
                "code": "/*\n\n    KIFS Flythrough\n    ---------------\n\n    After looking at Zackpudil's recent fractal shaders, I thought I'd put together something \n\tfractal in nature. It's nothing exciting, just the standard IFS stuff you see here and there. \n\tLike many examples, this particular one is based on Syntopia and Knighty's work.\n\n    The construction is pretty similar to that of an infinite sponge, but it has a bit of rotating, \n\tfolding, stretching, etc, thrown into the mix.\n\n    The blueish environmental lighting is experimental, and based on XT95s environment mapping in \n\this UI example. The idea is very simple: Instead of passing a reflective ray into a cubic \n\ttexture in cartesian form, convert it to its polar angles, then index into a 2D texture. The \n\tresults are abstract, and no substitute for the real thing, but not too bad, all things \n\tconsidered.\n\n\tThe comments are a little rushed, but I'll tidy them up later.\n\n\tExamples and references:\n\n    Menger Journey - Syntopia\n    https://www.shadertoy.com/view/Mdf3z7\n\n    // Explains the process in more detail.\n    Kaleidoscopic (escape time) IFS - Knighty\n    http://www.fractalforums.com/ifs-iterated-function-systems/kaleidoscopic-(escape-time-ifs)/\n\n    Ancient Generators - Zackpudil\n    https://www.shadertoy.com/view/4sGXzV\n\n*/\n\n#define FAR 40.\n\n// Wireframe version.\n//#define WIREFRAME\n\n\nfloat hash( float n ){ return fract(cos(n)*45758.5453); }\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. :)\n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n\n// IFS, or KIFS in particular. The following explains the process in more detail.\n//\n// Kaleidoscopic (escape time) IFS - Knighty\n// http://www.fractalforums.com/ifs-iterated-function-systems/kaleidoscopic-(escape-time-ifs)/\n//\n// Here's a quick, rushed expanation. Take an input point, and repeat it. After that, rotate\n// it, fold it, stretch and translate it about an offset point. Form an object with it and compare\n// it to the object formed in the repeat layer. Repeat ad infinitum...\n//\n// OK, that was a little vague, but it really is a pretty simple process. Playing around with the \n// code will give it more meaning. Change the rotation angles, iteration number, comment some\n// things out, etc. I'd also recommend reading Syntopia's blog. He explains things really well...\n// and there's so many pretty pictures. :)\n//\n// Syntopia - http://blog.hvidtfeldts.net/\n//\nfloat map(vec3 p){\n    \n    // I'm never sure whether I should take constant stuff like the following outside the function, \n    // or not. My 1990s CPU brain tells me outside, but it doesn't seem to make a difference to frame \n    // rate in this environment one way or the other, so I'll keep it where it looks tidy. If a GPU\n    // architecture\\compiler expert is out there, feel free to let me know.\n    \n    const vec3 offs = vec3(1, .75, .5); // Offset point.\n    const vec2 a = sin(vec2(0, 1.57079632) + 1.57/2.);\n    const mat2 m = mat2(a.y, -a.x, a);\n    const vec2 a2 = sin(vec2(0, 1.57079632) + 1.57/4.);\n    const mat2 m2 = mat2(a2.y, -a2.x, a2);\n    \n    const float s = 5.; // Scale factor.\n    \n    const float sz = .0355; // Box size.\n    #ifdef WIREFRAME\n    const float ew = .015; // Wireframe box edge width.\n    #endif\n    \n    float d = 1e5; // Distance.\n    \n    \n    p  = abs(fract(p*.5)*2. - 1.); // Standard spacial repetition.\n     \n    \n    float amp = 1./s; // Analogous to layer amplitude.\n    \n   \n    // With only two iterations, you could unroll this for more speed,\n    // but I'm leaving it this way for anyone who wants to try more\n    // iterations.\n    for(int i=0; i<2; i++){\n        \n        // Rotating.\n        p.xy = m*p.xy;\n        p.yz = m2*p.yz;\n        \n        p = abs(p);\n        //p = sqrt(p*p + .03);\n        //p = smin(p, -p, -.5); // Etc.\n        \n  \t\t// Folding about tetrahedral planes of symmetry... I think, or is it octahedral? \n        // I should know this stuff, but topology was many years ago for me. In fact, \n        // everything was years ago. :)\n\t\t// Branchless equivalent to: if (p.x<p.y) p.xy = p.yx;\n        p.xy += step(p.x, p.y)*(p.yx - p.xy);\n        p.xz += step(p.x, p.z)*(p.zx - p.xz);\n        p.yz += step(p.y, p.z)*(p.zy - p.yz);\n \n        // Stretching about an offset.\n\t\tp = p*s + offs*(1. - s);\n        \n\t\t// Branchless equivalent to:\n        // if( p.z < offs.z*(1. - s)*.5)  p.z -= offs.z*(1. - s);\n        p.z -= step(p.z, offs.z*(1. - s)*.5)*offs.z*(1. - s);\n        \n        // Loosely speaking, construct an object, and combine it with\n        // the object from the previous iteration. The object and\n        // comparison are a cube and minimum, but all kinds of \n        // combinations are possible.\n        p = abs(p);\n        vec3 q = p*amp;\n        //d = min(d, max(max(p.x, p.y), p.z)*amp - .035);\n        \n        // The object you draw is up to you. There are countless options.\n        float box = max(max(q.x, q.y), q.z) - sz;\n        //box = min(box, max(max(q.y, q.z) - sz*.33, q.x - sz*1.1));\n        //float box = max(length(q.yz) - sz*1.2, q.x - sz);\n        //float box = length(q) - sz; // A very spherical box. :)\n        #ifdef WIREFRAME\n        box = max(box, -(min(min(max(q.x, q.y), max(q.x, q.z)), max(q.y, q.z)) - sz + ew));\n        //box = max(box, -max(length(q.yz) - ew, q.x - sz - ew));\n        //box = max(box, -(max(length(q.yz - sz*.5) - ew*.35, q.x - sz - ew*.5)));\n        //box = max(box, -(max(q.y, q.z) - sz + ew));\n        #endif\n        // Vertices, of sorts.\n        //q = abs(q) - sz;\n        //box = min(box, length(q) - sz/3.);\n        d = min(d, box);\n        \n        \n        amp /= s; // Decrease the amplitude by the scaling factor.\n        \n    }\n \n \treturn d; // Return the distance.\n}\n\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 db( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    // Gradient vector, constructed with offset greyscale texture values.\n    //vec3 g = vec3( gr(tpl(tx, p - e.xyy, n)), gr(tpl(tx, p - e.yxy, n)), gr(tpl(tx, p - e.yyx, n)));\n    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m;\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n\n// Very basic raymarching equation.\nfloat trace(vec3 ro, vec3 rd){\n\n    \n    float t = 0.;//hash(dot(rd, vec3(7, 157, 113)))*0.01;\n    for(int i=0; i< 64; i++){\n        \n        float d = map(ro + rd*t);\n        if (d < 0.0025*(1. + t*.125) || t>FAR) break;\n        t += d*.75;\n    } \n    return t;\n}\n\n\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\n// Apart from being faster, it can produce a subtley different aesthetic to the 6 tap version, which I sometimes prefer.\nvec3 normal(in vec3 p){\n    \n    #ifdef WIREFRAME\n    // Sharper corners on the wireframe version.\n    vec2 e = vec2(0.002, -0.002); \n    #else\n    // Note the slightly increased sampling distance, to round off the edges a bit\n    // and to  alleviate artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.005, -0.005);\n    #endif\n    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n\n/*\n// Standard normal function.\nvec3 normal(in vec3 p) {\n\tconst vec2 e = vec2(0.005, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n*/\n\n\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calculateAO(in vec3 pos, in vec3 nor){\n\n\tfloat sca = 1.5, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing repeat objects - in a setting like this - with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 16; \n    \n    vec3 rd = (lp-ro); // Unnormalized direction ray.\n\n    float shade = 1.0;\n    float dist = 0.05;    \n    float end = max(length(rd), 0.001);\n    float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        //dist += min( h, stepDist ); // So many options here: dist += clamp( h, 0.0005, 0.2 ), etc.\n        dist += clamp(h, 0.02, 0.25);\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0.001 || dist > end) break; \n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing.\n    return min(max(shade, 0.) + 0.25, 1.0); \n}\n\n\n\n\n\n/////\n// Code block to produce some layers of smokey haze. Not sophisticated at all.\n// If you'd like to see a much more sophisticated version, refer to Nitmitz's\n// Xyptonjtroz example. Incidently, I wrote this off the top of my head, but\n// I did have that example in mind when writing this.\n\n// Hash to return a scalar value from a 3D vector.\nfloat hash31(vec3 p){ return fract(sin(dot(p, vec3(127.1, 311.7, 74.7)))*43758.5453); }\n\nfloat drawObject(in vec3 p){\n  \n    p = fract(p) - .5;    \n    return dot(p, p);\n}\n\n\nfloat cellTile(in vec3 p){\n    \n    // Draw four overlapping objects (spheres, in this case) at various positions throughout the tile.\n    vec4 v, d; \n    d.x = drawObject(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.y = drawObject(p - vec3(.39, .2, .11));\n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawObject(p - vec3(.62, .24, .06));\n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071;\n    d.w = drawObject(p - vec3(.2, .82, .64));\n\n    v.xy = min(d.xz, d.yw), v.z = min(max(d.x, d.y), max(d.z, d.w)), v.w = max(v.x, v.y); \n   \n    d.x =  min(v.z, v.w) - min(v.x, v.y); // Maximum minus second order, for that beveled Voronoi look. Range [0, 1].\n    //d.x =  min(v.x, v.y);\n        \n    return d.x*2.66; // Normalize... roughly.\n    \n}\n\n// Four layers of cheap cell tile noise to produce some subtle mist.\n// Start at the ray origin, then take four samples of noise between it\n// and the surface point. Apply some very simplistic lighting along the \n// way. It's not particularly well thought out, but it doesn't have to be.\nfloat getMist(in vec3 ro, in vec3 rd, in vec3 lp, in float t){\n\n    float mist = 0.;\n    ro += rd*t/64.; // Edge the ray a little forward to begin.\n    \n    for (int i = 0; i<8; i++){\n        // Lighting. Technically, a lot of these points would be\n        // shadowed, but we're ignoring that.\n        float sDi = length(lp-ro)/FAR; \n\t    float sAtt = min(1./(1. + sDi*0.25 + sDi*sDi*0.25), 1.);\n\t    // Noise layer.\n        //float n = trigNoise3D(ro/2.);//noise3D(ro/2.)*.66 + noise3D(ro/1.)*.34;\n        float n = cellTile(ro/1.);\n        mist += n*sAtt;//trigNoise3D\n        // Advance the starting point towards the hit point.\n        ro += rd*t/8.;\n    }\n    \n    // Add a little noise, then clamp, and we're done.\n    return clamp(mist/4. + hash31(ro)*0.2-0.1, 0., 1.);\n\n}\n\n\n//////\n// Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n// does give the impression that the surface is reflecting the surrounds in some way.\n//\n// Anyway, the idea is very simple. Obtain the reflected ray at the surface hit point, \n// convert the 3D ray coordinates (rd) to polar coordinates (the angular components) and \n// index into a repeat texture. It can be pretty convincing (in an abstract way) and\n// facilitates environment mapping without the need for a cube map, or a reflective pass.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 envMap(vec3 rd, vec3 n){\n    \n    //vec3 col2 = tex3D(iChannel1, rd/4., n).zyx;//*(1.-lod*.8)\n    //return smoothstep(.0, 1., col2*2.);\n    \n\n    // I got myself a little turned around here, but I think texture size\n    // manipulation has to be performed at this level, if you want the angular\n    // polar coordinates to wrap... Not sure though... It'll do. :)\n    rd /= 4.; \n    \n    vec2 uv = vec2(atan(rd.y, rd.x)/6.283, acos(rd.z)/3.14159);\n    uv = fract(uv);\n   \n    vec3 col = texture(iChannel1, uv).zyx;//*(1.-lod*.8)\n    return smoothstep(.1, 1., col*col*2.);\n    \n}\n\n\n/*\n// Pseudo environment mapping. Simlilar to above, but using tri-planar texturing for a more \n// even spread.\nvec3 envMap(vec3 rd, vec3 n){\n    \n    vec3 col = tex3D(iChannel1, rd/4., n).zyx;\n    return smoothstep(.1, 1., col*2.);\n}\n*/\n//////\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n    // Unit direction ray vector: Note the absence of a divide term. I came across\n    // this via a comment Shadertoy user \"coyote\" made. I'm pretty happy with this.\n    vec3 rd = (vec3(2.*fragCoord - iResolution.xy, iResolution.y));\n    \n    // Barrel distortion;\n    rd = normalize(vec3(rd.xy, sqrt(rd.z*rd.z - dot(rd.xy, rd.xy)*0.2)));\n\n    \n    // Rotating the ray with Fabrice's cost cuttting matrix. I'm still pretty happy with this also. :)\n    vec2 m = sin(vec2(1.57079632, 0) + iTime/4.);\n    rd.xy = rd.xy*mat2(m.xy, -m.y, m.x);\n    rd.xz = rd.xz*mat2(m.xy, -m.y, m.x);\n    \n    \n    // Ray origin, set off in the YZ direction. Note the \"0.5.\" It's an old lattice trick.\n    vec3 ro = vec3(0, 0, iTime);\n    vec3 lp = ro + vec3(0, .25, .65); // Light, near the ray origin.\n\n    // Set the scene color to black.\n    vec3 col = vec3(0);\n\n    \n    float t = trace(ro, rd); // Raymarch.\n    \n    // Surface hit, so light it up.\n    if(t<FAR){\n    \n        vec3 sp = ro + rd*t; // Surface position.\n        vec3 sn = normal(sp); // Surface normal.\n\n\n        const float sz = 1.5; // Texture size, or scale, if you prefer.\n\n        sn = db(iChannel0, sp*sz, sn, .004/(1. + t/FAR*.5)); // Texture bump.\n\n     \n\n        vec3 oCol = tex3D(iChannel0, sp*sz, sn); // Texture color at the surface point.\n        oCol = smoothstep(.0, .8, oCol);\n\n        float sh = softShadow(sp, lp, 16.); // Soft shadows.\n        float ao = calculateAO(sp, sn)*.5 + .5; // Self shadows. Not too much.\n\n        vec3 ld = lp - sp; // Light direction.\n        float lDist = max(length(ld), 0.001); // Light to surface distance.\n        ld /= lDist; // Normalizing the light direction vector.\n\n        float diff = max(dot(ld, sn), 0.); // Diffuse component.\n        float spec = pow(max(dot(reflect(-ld, sn), -rd), 0.), 12.); // Specular.\n\n        float atten = 1./(1. + lDist*.25 + lDist*lDist*.075); // Attenuation.\n\n        // Combining the elements above to light and color the scene. The\n        // specular component is exaggerated to give yellowy highlights.\n        // None of this mimicks real life. :)\n        col = oCol*(diff + vec3(.4, .25, .2) + vec3(1., .6, .2)*spec*8.);\n        \n        // Faux environmental mapping. Passing in the reflected ray.\n        col += (col*1. + .5)*envMap(reflect(rd, sn), sn);\n        \n        // Environment mapping with a cubic texture, for comparison.\n        //vec3 rfCol = texture(iChannel2, reflect(rd, sn)).xyz; // Forest scene.\n        //col += rfCol*rfCol*.5;\n\n\n        // Shading the scene color, clamping, and we're done.\n        col = min(col*atten*sh*ao, 1.);\n        \n        \n\n        //col = clamp(col + hash(dot(rd, vec3(7, 157, 113)))*0.1 - 0.05, 0., 1.);\n        \n    }\n    \n    \n    // Blend the scene and the background with some very basic, 8-layered smokey haze.\n    float mist = getMist(ro, rd, lp, t);\n    vec3 sky = mix(vec3(1, .75, .5), vec3(.35, .6, 1), dot(rd.yz, vec2(.5))*.5 + .5)*mix(1., .75, mist);\n    \n    // Mix the smokey haze with the object.\n    col = mix(sky, col, 1./(t*t/FAR/FAR*128. + 1.));\n\n    // Statistically unlikely 2.0 gamma correction, but it'll do. :)\n\tfragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}