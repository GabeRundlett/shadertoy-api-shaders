{
    "Shader": {
        "info": {
            "date": "1709285208",
            "description": "Kunai-wtih textures pure cringe",
            "flags": 32,
            "hasliked": 0,
            "id": "lXXXz4",
            "likes": 2,
            "name": "Kunai-with-textures",
            "published": 3,
            "tags": [
                "raymarching",
                "textures"
            ],
            "usePreview": 0,
            "username": "Arseny",
            "viewed": 133
        },
        "renderpass": [
            {
                "code": "// template copied form inigo quilez - iq/2019\n\n//   Step 1: https://www.shadertoy.com/view/ws3GD2\n\n#define PI (3.14159)\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdSphere( in vec3 p, in float r )\n{\n    return length(p)-r;\n}\n\nfloat sdOct(in vec3 p){\n    //vec3 n = normalize(vec3(1. / 3.));\n    return dot(vec3(0.57735), abs(p)) - 0.057735;\n    //return dot(vec3(1.), p) - r;\n}\n\nfloat sdTransOct(in vec3 p, in float a, in float b, in float h){\n    vec3 n = normalize(cross(vec3(a, 0, 0) - vec3(0, 0, b), vec3(0, h, 0) - vec3(0, 0, b)));\n    return dot(n, abs(p)) - a * n.x;\n}\n\nfloat sdKunaiSpear(in vec3 p, in float fl, in float bl, in float w, in float h, in float sh){\n    p.xy = abs(p.xy);\n    vec3 A = vec3(0, h, sh);\n    vec3 B = vec3(0, 0, fl);\n    vec3 C = vec3(w, 0, 0);\n    vec3 n = normalize(cross(B - A, C - A));\n    //float d1 = dot(n, p) - fl * n.z;\n    //float d1 = (p.z < fl) ? dot(n, p) - fl * n.z : 0.;\n    float d1 = dot(n, p) - fl * n.z;\n    vec3 D = vec3(0, 0, -bl);\n    n = normalize(cross(C - A, D - A));\n    //d1 = (p.z > -bl) ? max(d1, dot(n, p) + bl * n.z) : d1;\n    d1 = max(d1, dot(n, p) + bl * n.z);\n    d1 = (p.z < sh && p.z > -0.1) ? mix(d1, smin(d1, length(p.xy), 0.04), (sh - p.z) / bl) : d1;\n    return d1;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdKunaiHandle(in vec3 p, in float k, in float w, in float r){\n    p.yz = p.zy;\n    float y = p.y;\n    p.y = (y>0.&&y< k * w)?fract(p.y / w) * w - w / 2.:y - w / 2.;\n    p.y = (y>k * w)?y-k * w - w / 2.:p.y;\n    //if (y < 0.) return y;\n    return sdTorus(p, vec2(r, w));\n}\n\nvec2 sdKunai(in vec3 p, in float fl, in float bl, in float w, in float h, in float sh){\n    float d = sdTorus(p + vec3(0, 0, 0.25), vec2(0.04, 0.02));\n    d = min(d, sdKunaiSpear(p + vec3(0, 0, -0.1), 0.4, 0.1, 0.1, 0.03, 0.05));\n    int id = 0;\n    float handle = sdKunaiHandle(-p + vec3(0, 0, 0.01), 20., 0.01, 0.02);\n    if (d > handle) {\n        d = handle;\n        id = 1;\n    }\n    //d = min(d, sdKunai(p + vec3(0, 0, -0.1), 0.4, 0.1, 0.1, 0.03, 0.05));\n    return vec2(d, id);\n}\n\n//float sdTransOct(in vec3 p, in vec3\n\nvec2 map( in vec3 p, float time )\n{\n    //float d = sdOct( p * 1.1) / 1.1;\n    //float d = sdTransOct(p, 0.1, 0.3, 0.1);\n    //float d = sdKunai(p, 0.4, 0.1, 0.1, 0.03, 0.05);\n    //float d = sdTorus(p, vec2(0.2, 0.1));\n    //float d = sdKunaiHandle(-p + vec3(0, 0, 0.01), 20., 0.01, 0.02);\n    vec2 d = sdKunai(p + vec3(0, 0, -0.1), 0.4, 0.1, 0.1, 0.03, 0.05);\n    //d = min(d, sdKunai(p + vec3(0, 0, -0.1), 0.4, 0.1, 0.1, 0.03, 0.05));\n    //d = min(d, length(p.xy));\n    //float d = sdSphere( p, 0.1 );\n    return d;\n}\n\n#define ZERO min(iFrame,0)\n\nvec3 calcNormal( in vec3 pos, in float time )\n{\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e,time).x;\n    }\n    return normalize(n);\n}\n\nvec2 intersect( in vec3 ro, in vec3 rd, in float time )\n{\n    vec2 res = vec2(-1.0);\n    \n    float t = 0.001;\n    float tmax = 10.0;\n    for( int i=0; i<128 && t<tmax; i++ )\n    {\n        vec3 p = ro+t*rd;\n        vec2 h = map(p,time);\n        if( h.x<0.0001 ) { res=vec2(t, h.y); break; }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n       \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        float time = iTime;\n        //time = 0.;\n\n\t    // camera\t\n        float an = 6.2831*time/30.0;\n        vec3 ta = vec3( 0.0, 0.0, 0.0 );\n        vec3 ro = ta + vec3( 0.5*cos(an), 0.5, 0.5*sin(an) );\n        \n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        \n        // ray direction\n        float fl = 2.0;\n        vec3 rd = ca * normalize( vec3(p,fl) );\n\n        // background\n        vec3 col = vec3(1.0+rd.y)*0.03;\n        \n        // raymarch geometry\n        vec2 tuvw = intersect( ro, rd, time );\n        if( tuvw.x>0.0 )\n        {\n            // shading/lighting\t\n            vec3 pos = ro + tuvw.x*rd;\n            vec3 nor = calcNormal(pos, time);\n                        \n            col = 0.5 + 0.5*nor;\n               \n            vec2 proj = normalize(nor.xy);\n            float angle = atan(proj.y, proj.x) / PI + 0.5;\n            vec2 texCord = vec2(pos.z + 0.3, angle / 4.) * 3.;\n            if (tuvw.y > 0.5) {\n                vec4 tex = texture(iChannel0, texCord);\n                col = tex.xyz;\n            } else {          \n                texCord.x += time;\n                vec4 tex = texture(iChannel1, texCord / vec2(5., 1./6.));\n                col = tex.xyz;\n                col *= (tuvw.y + 1.) / 2.;\n            }\n        }\n        \n        \n        // gamma        \n\t    tot += pow(col,vec3(0.45) );\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n    fragColor = vec4( tot, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+10.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade(vec2 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec2 P)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289(Pi); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;  \n  g01 *= norm.y;  \n  g10 *= norm.z;  \n  g11 *= norm.w;  \n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Wood texture generation\n    float woodDensity = 5.0;\n    float woodScale = 10.0;\n    float woodNoise = cnoise(uv * woodDensity);\n    float woodPattern = (woodNoise + 1.0) * 0.5;\n    \n    // Wood color\n    vec3 woodColor = vec3(0.6, 0.3, 0.1) * 0.6;\n    \n    // Adding rings to the wood pattern\n    float rings = abs(fract(woodPattern * woodScale) - 0.5) * 2.0;\n    \n    // Final color with rings\n    vec3 finalColor = mix(woodColor, woodColor * 1.5, rings);\n    \n    fragColor = vec4(finalColor, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Create a steal-like texture effect\n    float noise = sin(uv.x * 4.0) * sin(uv.y * 3.0) * 0.1;\n    vec3 color = texture(iChannel0, uv + noise).rgb;\n    \n    fragColor = vec4(color, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}