{
    "Shader": {
        "info": {
            "date": "1598100358",
            "description": "\"Procgen Planet\" shader mod with the reference 3D Perlin noise function to avoid noise artifacts.",
            "flags": 0,
            "hasliked": 0,
            "id": "ttsBWl",
            "likes": 13,
            "name": " Procgen Planet mod",
            "published": 3,
            "tags": [
                "procedural",
                "noise",
                "fbm",
                "planet",
                "domainwarping",
                "procgen"
            ],
            "usePreview": 0,
            "username": "evgenys",
            "viewed": 971
        },
        "renderpass": [
            {
                "code": "// This is a fork of Procgen Planet from https://www.shadertoy.com/view/tltXWM .\n// The problem of Procgen Planet is that there are visible noise artifacts\n// (white dots randomly appearing).\n//\n// This fork uses the reference Perlin 3D function from https://mrl.nyu.edu/~perlin/noise/\n// which fixes the white flashes.\n//\n\nint[] perm = int[](\n    151,160,137,91,90,15,\n    131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n    190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n    88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n    77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n    102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n    135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n    5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n    223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n    129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n    251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n    49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n    138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,\n    151\n);\nint perm1plus(int i, int k) { return int(mod(float(perm[i]) + float(k), 256.)); }\n\nfloat Fade(float t) { return t * t * t * (t * (t * 6. - 15.) + 10.); }\n\nfloat Grad(int hash, float x, float y, float z) {\n    int h = hash & 15;\n    float u = h < 8 ? x : y;\n    float v = h < 4 ? y : (h == 12 || h == 14 ? x : z);\n    return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);\n}\n\nfloat Noise3D(vec3 val) {\n    vec3 v1 = floor(val);\n    vec3 v2 = fract(val);\n    int X = int(mod(v1.x, 256.));\n    int Y = int(mod(v1.y, 256.));\n    int Z = int(mod(v1.z, 256.));\n    float x = v2.x;\n    float y = v2.y;\n    float z = v2.z;\n    float u = Fade(x);\n    float v = Fade(y);\n    float w = Fade(z);\n    int A  = perm1plus(X, Y);\n    int B  = perm1plus(X+1, Y);\n    int AA = perm1plus(A, Z);\n    int BA = perm1plus(B, Z);\n    int AB = perm1plus(A+1, Z);\n    int BB = perm1plus(B+1, Z);\n\n    return mix(mix(mix(Grad(perm[AA  ], x, y   , z  ),  Grad(perm[BA  ], x-1., y   , z  ), u),\n                   mix(Grad(perm[AB  ], x, y-1., z  ),  Grad(perm[BB  ], x-1., y-1., z  ), u),\n                   v),\n               mix(mix(Grad(perm[AA+1], x, y   , z-1.), Grad(perm[BA+1], x-1., y   , z-1.), u),\n                   mix(Grad(perm[AB+1], x, y-1., z-1.), Grad(perm[BB+1], x-1., y-1., z-1.), u),\n                   v),\n               w);\n}\n\n// Noise functions and most of the implementation based on\n// https://www.shadertoy.com/view/4dS3Wd by Morgan McGuire @morgan3d!\n\n// see also\n// https://iquilezles.org/articles/warp\n// https://thebookofshaders.com/13/\n// for informations on fbm, noise, ...\n\n// please check out stuff like: https://www.shadertoy.com/view/lsGGDd\n// for more advanced planet lighting/clouds/...\n\n// Looking for a blue planet? Colors:\n// vec3 col_top = vec3(0.0, 0.5, 0.0);\n// vec3 col_bot = vec3(0.0, 1.0, 1.0);\n// vec3 col_mid1 = vec3(0.0, 1.0, 0.0);\n// vec3 col_mid2 = vec3(0.0, 0.0, 1.0);\n// vec3 col_mid3 = vec3(0.0, 0.0, 1.0);\n\n\n// number of octaves of fbm\n#define NUM_NOISE_OCTAVES 10\n// size of the planet\n#define PLANET_SIZE\t\t0.75\n// uncomment to use a simple sharpen filter\n// #define SHARPEN\n// simple and fast smoothing of outside border\n#define SMOOTH\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// Noise functions:\n//////////////////////////////////////////////////////////////////////////////////////\n\n// Precision-adjusted variations of https://www.shadertoy.com/view/4djSRW\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\n\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    float n = dot(i, step);\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n\t\t//v += a * noise(x);\n        v += a * (Noise3D(x) * .5 + .5);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n//////////////////////////////////////////////////////////////////////////////////////\n// Visualization:\n//////////////////////////////////////////////////////////////////////////////////////\n\nconst float pi          = 3.1415926535;\nconst float inf         = 9999999.9;\nfloat square(float x) { return x * x; }\nfloat infIfNegative(float x) { return (x >= 0.0) ? x : inf; }\n\n// C = sphere center, r = sphere radius, P = ray origin, w = ray direction\nfloat intersectSphere(vec3 C, float r, vec3 P, vec3 w) {\t\n\tvec3 v = P - C;\n\tfloat b = -dot(w, v);\n\tfloat c = dot(v, v) - square(r);\n\tfloat d = (square(b) - c);\n\tif (d < 0.0) { return inf; }\t\n\tfloat dsqrt = sqrt(d);\n\t\n\t// Choose the first positive intersection\n\treturn min(infIfNegative((b - dsqrt)), infIfNegative((b + dsqrt)));\n}\n\n// returns max of a single vec3\nfloat max3 (vec3 v) {\n  return max (max (v.x, v.y), v.z);\n}\n\nvec3 getColorForCoord(vec2 fragCoord) {\n    // (intermediate) results of fbm\n    vec3 q = vec3(0.0);\n    vec3 r = vec3(0.0);\n\tfloat v = 0.0;\n    vec3 color = vec3(0.0);\n\n    // planet rotation\n    float theta = iTime * 0.15;  \n    mat3 rot = mat3(\n        cos(theta), 0, sin(theta),\t// column 1\n        0, 1, 0,\t                // column 2\n        -sin(theta), 0, cos(theta)\t// column 3\n    );\n\n    // Ray-sphere\n    const float verticalFieldOfView = 25.0 * pi / 180.0;\n\n    // position of viewpoint (P) and ray of vision (w)\n    vec3 P = vec3(0.0, 0.0, 5.0);\n    vec3 w = normalize(vec3(fragCoord.xy - iResolution.xy * 0.5, (iResolution.y) / (-2.0 * tan(verticalFieldOfView / 2.0))));\n\n    // calculate intersect with sphere (along the \"line\" of w from P)\n    float t = intersectSphere(vec3(0, 0, 0), PLANET_SIZE, P, w);\n    \n    // calculate color for sphere/background\n    if (t < inf) {\n        // calculate point of intersection on the sphere\n        vec3 X = P + w*t;\n\n        // apply rotation matrix\n        X = rot*X;\n\n        // calculate fbm noise (3 steps)\n        q = vec3(fbm(X + 0.025*iTime), fbm(X), fbm(X));\n        r = vec3(fbm(X + 1.0*q + 0.01*iTime), fbm(X + q), fbm(X + q));\n        v = fbm(X + 5.0*r + iTime*0.005);\n    } else {\n        // ray missed the sphere\n\t\treturn vec3(0.0);\n    }\n    \n    // convert noise value into color\n    // three colors: top - mid - bottom (mid being constructed by three colors)\n    vec3 col_top = vec3(1.0, 1.0, 1.0);\n    vec3 col_bot = vec3(0.0, 0.0, 0.0);\n    vec3 col_mid1 = vec3(0.1, 0.2, 0.0);\n    vec3 col_mid2 = vec3(0.7, 0.4, 0.3);\n    vec3 col_mid3 = vec3(1.0, 0.4, 0.2);\n\n    // mix mid color based on intermediate results\n    vec3 col_mid = mix(col_mid1, col_mid2, clamp(r, 0.0, 1.0));\n    col_mid = mix(col_mid, col_mid3, clamp(q, 0.0, 1.0));\n    col_mid = col_mid;\n\n    // calculate pos (scaling betwen top and bot color) from v\n    float pos = v * 2.0 - 1.0;\n    color = mix(col_mid, col_top, clamp(pos, 0.0, 1.0));\n    color = mix(color, col_bot, clamp(-pos, 0.0, 1.0));\n\n    // clamp color to scale the highest r/g/b to 1.0\n    color = color / max3(color);\n      \n    // create output color, increase light > 0.5 (and add a bit to dark areas)\n    color = (clamp((0.4 * pow(v,3.) + pow(v,2.) + 0.5*v), 0.0, 1.0) * 0.9 + 0.1) * color;\n    \n    // apply diffuse lighting  \n    float diffuse = max(0.0, dot(P + w*t, vec3(1.0, sqrt(0.5), 1.0)));\n    float ambient = 0.1;\n    color *= clamp((diffuse + ambient), 0.0, 1.0);\n    \n#ifdef SMOOTH\n    // apply a smoothing to the outside\n    //color *= (P + w*t).z * 2.0;\n    color *= (P + w*t).z * 1.0;\n#endif    \n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n#ifdef SHARPEN \n    // use a simple sharpen filter (you could improve that immensely!\n    fragColor.rgb =\n        getColorForCoord(fragCoord) * 3. -\n        getColorForCoord(fragCoord + vec2(1.0, 0.0)) * 0.5 -\n        getColorForCoord(fragCoord + vec2(0.0, 1.0)) * 0.5 -\n        getColorForCoord(fragCoord - vec2(1.0, 0.0)) * 0.5 -\n        getColorForCoord(fragCoord - vec2(0.0, 1.0)) * 0.5;\n#else\n    // just use a single pass\n    fragColor.rgb = getColorForCoord(fragCoord);\n#endif\n    // gamma correction\n    fragColor.rgb = pow(fragColor.rgb, vec3(1./2.2));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}