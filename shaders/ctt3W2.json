{
    "Shader": {
        "info": {
            "date": "1683137679",
            "description": "ASCII art shader applied to a rotating donut rendered using ray marching.",
            "flags": 32,
            "hasliked": 0,
            "id": "ctt3W2",
            "likes": 6,
            "name": "ASCII art donut",
            "published": 3,
            "tags": [
                "raymarching",
                "ascii",
                "donut",
                "asciiart",
                "doughnut"
            ],
            "usePreview": 1,
            "username": "Sumsar86",
            "viewed": 291
        },
        "renderpass": [
            {
                "code": "#define getDisplayPos(pos,scale) PrintPosition((fragCoord-pos*iResolution.xy)/(scale*1920.0),pos,iResolution.xy,scale);\n#define WriteWord(word, style, p, font_tex, color)\\\n\tfor(int i = 0; i < word.length(); i++)\\\n        writeChar(word[i], style, 1.0, 0.0, p, font_tex, color);\n\nconst int\t_=32,                         // https://www.shadertoy.com/view/MdycDK\n\t\t\t_SHARP=35,\t\t// #\n\t\t\t_PERCENT=37,\t// %\n\t\t\t_ASTERISK=42,\t// *\n\t\t\t_PLUS=43,\t\t// +\n\t\t\t_MINUS=45,\t\t// -\n\t\t\t_DOT=46,\t\t// .\n    \t\t_COLON=58,\t\t// :\n    \t\t_EQ=61,\t\t\t// =\n    \t\t_AT=64;\t\t\t// @\n\nconst int[] gradient = int[](_AT, _PERCENT, _SHARP, _ASTERISK, _PLUS, _EQ, _MINUS, _COLON, _DOT, _);// @%#*+=-:. \n\nstruct PrintPosition\n{\n    vec2 uv,\n         pos,\n         R;\n    float scale;\n};\n\nstruct PrintStyle\n{\n    vec3 char_color,\n         outline_color;\n    float outline_size;\n};\n\nvoid writeChar(int char, PrintStyle style, float w, float x_offset, inout PrintPosition p, sampler2D font_tex, inout vec3 color)\n{\n    \t#define getFont(uv,char) texture(font_tex, (uv+vec2(char%16,15-char/16))/16.0)\n\t\tvec2 uv = p.uv;\n    \tuv.x += x_offset;\n    \tfloat outline_size = style.outline_size;\n    \tif(uv.x>0. && uv.x<w && uv.y>0. && uv.y<1.){\n            // We are inside the bbox, display the char\n            color = mix(color,style.outline_color,smoothstep(0.,-1./p.R.y,getFont(uv,char).a - outline_size-.5));\n            color = mix(color,style.char_color, getFont(uv,char).r);\n        }\n\t\tuv.x -= w; // move uv for next char\n    \tp.uv = uv;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    fragColor = vec4(0.0);\n\n    float downScaleValue = 20.0 * (2.0 * iResolution.x / 1920.0);\n    float scale = 1.0 / 1600.0 * downScaleValue;\n\n    vec4 color = vec4(0.0);\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 newFragCoord = floor(fragCoord / downScaleValue) * downScaleValue;\n    vec2 newUV = newFragCoord / iResolution.xy;\n\n    color = texelFetch(iChannel0, ivec2(newUV * iResolution.xy), 0);\n\n    \n    PrintPosition p;\n\n    p = getDisplayPos(newFragCoord / iResolution.xy, scale);\n\n    PrintStyle white_out_black = PrintStyle(color.xyz + (vec3(1.0) - color.xyz) * 0.4, vec3(0.0), 1.0);\n\n    int index = 9 - int(color.x * 10.0);\n    int[] char = int[](gradient[index]);\n    WriteWord(char, white_out_black, p, iChannel1, fragColor.xyz);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define WHITE vec3(1.0)\n#define BLACK vec3(0.0)\n\n\nstruct Torus\n{\n    vec3 dir;\n    vec3 pos;\n    float r;\n    float s;\n};\n\nTorus t1 = Torus(normalize(vec3(1.0, 0.5, 0.0)), vec3(0.0), 2.0, 1.0);\n\nvec3 lightPos = vec3(2.0, -5.0, 3.0);\n\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        c, 0, s, \n        0, 1, 0, \n        -s, 0, c\n    );\n}\n\nfloat torusSDF(in vec3 p)\n{\n    vec3 relativePos = p - t1.pos;\n    vec3 relPosProj = t1.r * normalize(relativePos - t1.dir * dot(relativePos, t1.dir));\n    return length(relPosProj - relativePos) - t1.s;\n}\n\nvec3 calculateNormal(in vec3 pos)\n{\n    const vec3 smallStep = vec3(0.001, 0.0, 0.0);\n\n    float gradientX = torusSDF(pos + smallStep.xyy) - torusSDF(pos - smallStep.xyy);\n    float gradientY = torusSDF(pos + smallStep.yxy) - torusSDF(pos - smallStep.yxy);\n    float gradientZ = torusSDF(pos + smallStep.yyx) - torusSDF(pos - smallStep.yyx);\n\n    vec3 normal = vec3(gradientX, gradientY, gradientZ);\n\n    return normalize(normal);\n}\n\nvec3 rayMarch(in vec3 rayOrigin, in vec3 rayDir)\n{\n    float totalDistTraveled = 0.0;\n    const int NUMBER_OF_STEPS = 256;\n    const float MINIMUM_HIT_DIST = 0.001;\n    const float MAXIMUM_TRACE_DIST = 10.0;\n    \n    for (int i = 0; i < NUMBER_OF_STEPS; ++i)\n    {\n        vec3 currentPos = rayOrigin + totalDistTraveled * rayDir;\n        float smallestDist = torusSDF(currentPos);\n        \n        if (smallestDist <= MINIMUM_HIT_DIST)\n        {\n            vec3 normal = calculateNormal(currentPos);\n            vec3 lightDir = normalize(currentPos - lightPos);\n            \n            float diffuseIntensity = max(0.05, dot(normal, lightDir));\n            \n            return vec3(1.0) * diffuseIntensity;\n        }\n            \n        if (totalDistTraveled >= MAXIMUM_TRACE_DIST)\n            break;\n            \n        totalDistTraveled += smallestDist;\n    }\n    \n    return BLACK;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    // convert from (0 to 1) to (-1 to 1)\n    uv = uv * 2.0 - 1.0;\n    // rescale\n    uv.x *= iResolution.x / iResolution.y;\n    \n    t1.dir *= rotateY(-iTime * 0.2);\n\n    vec3 rOrigin = vec3(0.0, 0.0, -5.0);\n    vec3 rDir = vec3(uv, 1.0);\n    vec3 col = rayMarch(rOrigin, rDir);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}