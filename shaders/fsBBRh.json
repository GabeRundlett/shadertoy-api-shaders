{
    "Shader": {
        "info": {
            "date": "1684124346",
            "description": "Page Curl Effect from shader https://www.shadertoy.com/view/XlX3RS displaced on Ball\nMouse control activated\na liitle bit slow for the moment",
            "flags": 32,
            "hasliked": 0,
            "id": "fsBBRh",
            "likes": 5,
            "name": "Lava page curl audio vis ball",
            "published": 3,
            "tags": [
                "curl",
                "effect",
                "ball",
                "page"
            ],
            "usePreview": 0,
            "username": "firebreathz",
            "viewed": 263
        },
        "renderpass": [
            {
                "code": "// Created by Stephane Cuillerdier - Aiekick/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n////////////////////////////////////////////////////////\n// page curl effect from my shader https://www.shadertoy.com/view/XlX3RS\nfloat curlExtent = 0.;\n    \nconst float minAmount = -0.16;\nconst float maxAmount = 1.3;\nconst float PI = 3.14159;\nconst float scale = 512.0;\nconst float sharpness = 3.0;\nvec4 bgColor;\n\nfloat amount;\nfloat cylinderCenter;\nfloat cylinderAngle;\nconst float cylinderRadius = 1. / PI / 2.0;\n\nvec3 hitPoint(float hitAngle, float yc, vec3 point, mat3 rrotation)\n{\n    float hitPoint = hitAngle / (2.0 * PI);\n    point.y = hitPoint;\n    return rrotation * point;\n}\n\nvec4 antiAlias(vec4 color1, vec4 color2, float dis)\n{\n    dis *= scale;\n    if (dis < 30.0) return color2;\n    if (dis > 20.0) return color1;\n    float dd = pow(1.0 - dis / 2.0, sharpness);\n    return ((color2 - color1) * dd) + color1;\n}\n\nfloat distanceToEdge(vec3 point)\n{\n    float dx = abs(point.x > 0.5 ? 1.0 - point.x : point.x);\n    float dy = abs(point.y > 0.5 ? 1.0 - point.y : point.y);\n    if (point.x < 0.0) dx = -point.x;\n    if (point.x > 1.0) dx = point.x - 1.0;\n    if (point.y < 0.0) dy = -point.y;\n    if (point.y > 1.0) dy = point.y - 1.0;\n    if ((point.x < 0.0 || point.x > 1.0) && (point.y < 0.0 || point.y > 1.0)) return sqrt(dx * dx + dy * dy);\n    return min(dx, dy);\n}\n\nvec4 seeThrough(float yc, vec2 p, mat3 rotation, mat3 rrotation)\n{\n    float hitAngle = PI - (acos(yc / cylinderRadius) - cylinderAngle);\n    vec3 point = hitPoint(hitAngle, yc, rotation * vec3(p, 1.0), rrotation);\n    if (yc <= 0.0 && (point.x < 0.0 || point.y < 0.0 || point.x > 1.0 || point.y > 1.0))\n        return bgColor;\n    if (yc > 0.0)\n        return textureLod(iChannel1, p, 0.0);\n    vec4 color = textureLod(iChannel1, point.xy, 0.0);\n    vec4 tcolor = vec4(0.0);\n    return antiAlias(color, tcolor, distanceToEdge(point));\n}\n\nvec4 seeThroughWithShadow(float yc, vec2 p, vec3 point, mat3 rotation, mat3 rrotation)\n{\n    float shadow = distanceToEdge(point) * 30.0;\n    shadow = (1.0 - shadow) / 3.0;\n    if (shadow < 0.0)\n        shadow = 0.0;\n    else\n        shadow *= amount;\n    vec4 shadowColor = seeThrough(yc, p, rotation, rrotation);\n    shadowColor.r -= shadow;\n    shadowColor.g -= shadow;\n    shadowColor.b -= shadow;\n    return shadowColor;\n}\n\nvec4 backside(float yc, vec3 point)\n{\n    vec4 color = textureLod(iChannel1, point.xy, 0.0);\n    float gray = (color.r + color.b + color.g) / 15.0;\n    gray += (8.0 / 10.0) * (pow(1.0 - abs(yc / cylinderRadius), 2.0 / 10.0) / 2.0 + (5.0 / 10.0));\n    color.rgb = vec3(gray);\n    return color;\n}\n\n/////////////////////////////////////////////\n\n//////2D FUNC TO MODIFY////////////////////\nvec3 effect(vec2 uv) \n{\n    uv/=8.;\n    uv+=0.5;\n    \n\tbgColor = textureLod(iChannel2, uv, 0.0).rgga;\n    \n    curlExtent = (sin((iTime)*0.3)*0.5+0.5);\n    \n    if (iMouse.z>0.) curlExtent = 1.-iMouse.y/iResolution.y;\n        \n\tamount = curlExtent * (maxAmount - minAmount) + minAmount;\n\tcylinderCenter = amount;\n\tcylinderAngle = 2.0 * PI * amount;\n\n    const float angle = 30.0 * PI / 180.0;\n    float c = cos(-angle);\n    float s = sin(-angle);\n    mat3 rotation = mat3(c, s, 0, -s, c, 0, 0.12, 0.258, 1);\n    c = cos(angle);\n    s = sin(angle);\n    mat3 rrotation = mat3(c, s, 0, -s, c, 0, 0.15, -0.5, 1);\n    vec3 point = rotation * vec3(uv, 1.0);\n    float yc = point.y - cylinderCenter;\n    vec4 color = vec4(1.0, 0.0, 0.0, 1.0);\n    if (yc < -cylinderRadius) // See through to background\n    {\n        color = bgColor;\n    } \n    else if (yc > cylinderRadius) // Flat surface\n    {\n        \n        color = textureLod(iChannel1, uv, 0.0);\n    } \n    else \n    {\n        float hitAngle = (acos(yc / cylinderRadius) + cylinderAngle) - PI;\n        float hitAngleMod = mod(hitAngle, 2.0 * PI);\n        if ((hitAngleMod > PI && amount < 0.5) || (hitAngleMod > PI/2.0 && amount < 0.0)) \n        {\n            color = seeThrough(yc, uv, rotation, rrotation);\n        } \n        else \n        {\n            point = hitPoint(hitAngle, yc, point, rrotation);\n            if (point.x < 0.0 || point.y < 0.0 || point.x > 1.0 || point.y > 1.0) \n            {\n                color = seeThroughWithShadow(yc, uv, point, rotation, rrotation);\n            } \n            else \n            {\n                color = backside(yc, point);\n                vec4 otherColor;\n                if (yc < 0.0) \n                {\n                    float shado = 1.0 - (sqrt(pow(point.x - 0.5, 2.0) + pow(point.y - 0.5, 2.0)) / 0.71);\n                    shado *= pow(-yc / cylinderRadius, 3.0);\n                    shado *= 0.5;\n                    otherColor = vec4(0.0, 0.0, 0.0, shado);\n                } \n                else \n                {\n                    otherColor = textureLod(iChannel1, uv, 0.0);\n                }\n                color = antiAlias(color, otherColor, cylinderRadius - abs(yc));\n            }\n        }\n    }\n    return color.rgb;\n}\n\n///////FRAMEWORK////////////////////////////////////\nvec4 displacement(vec3 p)\n{\n    vec3 col = effect(p.xz);\n    \n    col = clamp(col, vec3(0), vec3(1.));\n    \n    float dist = dot(col,vec3(0.1));\n    \n    return vec4(dist,col);\n}\n\n////////BASE OBJECTS///////////////////////\nfloat obox( vec3 p, vec3 b ){ return length(max(abs(p)-b,0.0));}\nfloat osphere( vec3 p, float r ){ return length(p)-r;}\n////////MAP////////////////////////////////\nvec4 map(vec3 p)\n{\n   \tvec4 disp = displacement(p);\n        \n    float y = 1. - smoothstep(0., 1., disp.x);\n    \n    float dist = osphere(p, +5.-y);\n    \n    return vec4(dist, disp.yzw);\n}\n\n///////////////////////////////////////////\n//FROM IQ Shader https://www.shadertoy.com/view/Xds3zN\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.1, 0., 0. );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n///////////////////////////////////////////\nfloat march(vec3 ro, vec3 rd, float rmPrec, float maxd, float mapPrec)\n{\n    float s = rmPrec;\n    float d = 0.;\n    float l = log(2.);\n    for(int i=0;i<60;i++)\n    {      \n        if (s<rmPrec||s>maxd) break;\n        s = map(ro+rd*d).x * l;\n        d += abs(s);\n    }\n    return d;\n}\n\n////////MAIN///////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //float time = iTime*0.3;\n    float cam_a = 0.; // angle z\n    \n    float cam_e = 5.52; // elevation\n    float cam_d = 1.88; // distance to origin axis\n   \t\n    vec3 camUp=vec3(0,1,0);//Change camere up vector here\n  \tvec3 camView=vec3(0,0,0); //Change camere view here\n  \tfloat li = 0.6; // light intensity\n    float prec = 0.00001; // ray marching precision\n    float maxd = 50.; // ray marching distance max\n    float refl_i = 0.45; // reflexion intensity\n    float refr_a = 0.7; // refraction angle\n    float refr_i = 0.8; // refraction intensity\n    float bii = 0.35; // bright init intensity\n    float marchPrecision = 0.8; // ray marching tolerance precision\n    \n    /////////////////////////////////////////////////////////\n    //if ( iMouse.z>0.) cam_e = iMouse.x/iResolution.x * 10.; // mouse x axis \n    //if ( iMouse.z>0.) cam_d = iMouse.y/iResolution.y * 50.; // mouse y axis \n    /////////////////////////////////////////////////////////\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. -1.;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    vec3 ro = vec3(-sin(cam_a)*cam_d, cam_e+1., cos(cam_a)*cam_d); //\n  \tvec3 rov = normalize(camView-ro);\n    vec3 u = normalize(cross(camUp,rov));\n  \tvec3 v = cross(rov,u);\n  \tvec3 rd = normalize(rov + uv.x*u + uv.y*v);\n    \n    float b = bii;\n    \n    float d = march(ro, rd, prec, maxd, marchPrecision);\n    \n    if (d<maxd)\n    {\n        vec2 e = vec2(-1., 1.)*0.005; \n    \tvec3 p = ro+rd*d;\n        vec3 n = calcNormal(p);\n        \n        b=li;\n        \n        vec3 reflRay = reflect(rd, n);\n\t\tvec3 refrRay = refract(rd, n, refr_a);\n        \n        vec3 cubeRefl = texture(iChannel0, reflRay).rgb * refl_i;\n        vec3 cubeRefr = texture(iChannel0, refrRay).rgb * refr_i;\n        \n        col = cubeRefl + cubeRefr + pow(b, 15.);\n        \n       \tfloat occ = calcAO( p, n );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*n.y, 0.0, 1.0 );\n        float dif = clamp( dot( n, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( n, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-p.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, reflRay.y );\n        float fre = pow( clamp(1.0+dot(n,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( reflRay, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( p, lig, 0.02, 2.5 );\n       \tdom *= softshadow( p, reflRay, 0.02, 2.5 );\n\n\t\tvec3 brdf = vec3(0.0);\n        brdf += 1.20*dif*vec3(1.00,0.90,0.60);\n\t\tbrdf += 1.20*spe*vec3(1.00,0.90,0.60)*dif;\n        brdf += 0.30*amb*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.40*dom*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        brdf += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tbrdf += 0.02;\n\t\tcol *= brdf;\n\n    \tcol = mix(col, map(p).yzw, 0.5);\n    }\n    else\n    {\n        col = texture(iChannel0, rd).rgb;\n    }\n    \n\tfragColor.rgb = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Up in flames\" by Martijn Steinrucken aka BigWings/CountFrolic - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n//\n// My upcoming tutorial on The Art of Code is called Playing with Gyroids \n// This is the result of playing with gyroids for a few hours ;)\n//\n// See common tab for tweakable values.\n\n\n\nfloat Gyroid(vec3 p, float scale, float bias, float thickness) {\n    p *= scale;\n    float d = abs(dot(sin(p), cos(p.yzx))+bias)-thickness;\n\treturn d/scale;\n}\n\nvec4 GetGyroids(vec3 p) {    \n    float t = iTime*.1;\n       \n    p.xy *= Rot(p.z*.3);\n    p.z += t;\n    \n    float g1 = Gyroid(p, 5., .4, .1);\n    float g2 = Gyroid(p, 17., .3, .1);\n    float g3 = Gyroid(p, 39., .3, .1);\n    float g4 = Gyroid(p, -7., .3, .1);\n    \n    return vec4(g1, g2, g3, g4);              \n}\n\nfloat GetDist(vec3 p) {\n\tfloat d = p.y;\n    p.x+=.33;\n    \n    float t = iTime*.1;\n    float scale = 20.;\n       \n    p.xy *= Rot(p.z*.3);\n    p.z += t;\n    \n    float g1 = Gyroid(p, 5., 1.4, .1);\n    float g2 = Gyroid(p, 17., .3, .1);\n    float g3 = Gyroid(p, 39., .3, .1);\n    float g4 = Gyroid(p, 89., .3, .1);\n    float g5 = Gyroid(p, 189., .3, .1);\n    float g6 = Gyroid(p, 289., .0, .1);\n    \n    d = g1*.7;\n    d -= g2*.3;\n    d += g3*.2;\n    d += g4*.1;\n    d += g5*g4*20.;\n    d += g6*.1;\n    \n   \tvec3 P = p;\n    P.xz = fract(P.xz)-.5;\n    vec2 id = floor(p.xz);\n    float n = Hash21(id);\n    //P = fract(P)-.5;\n    \n    \n    return d;              \n}\n\nfloat sdSpark(vec3 p) {\n    float t = iTime*.5;\n    \n    p.xz *= Rot(t*.1);\n    \n    vec3 id = floor(p);\n    p.xz = fract(p.xz)-.5;\n    \n    float n = Hash21(id.xz);\n    \n\tfloat z = fract(t+n)-.5;\n   \tz *= 10.;\n    \n    n *= 6.2832;\n    float size = .3+.2*sin(t*.1);\n    vec3 p1 = vec3(0, z-size*1., 0);\n    vec3 p2 = vec3(0, z+size*1., 0);\n    \n    p.x += sin(p.y*3.)*.1;\n    \n    float d = sdCapsule(p, p1, p2, size*.1);\n    \n    d = min(d, length(p.xz)+size*2.);\n    \n    return d;\n}\n\nvec2 SparkMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float dM=MAX_DIST;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = sdSpark(p);\n        if(dS<dM) dM = dS;\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return vec2(dO, dM);\n}\n\nvec3 GetSparkNormal(vec3 p) {\n\tfloat d = sdSpark(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        sdSpark(p-e.xyy),\n        sdSpark(p-e.yxy),\n        sdSpark(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float dM=MAX_DIST;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if(dS<dM) dM = dS;\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return vec2(dO, dM);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z, vec3 up) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(up, f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 GetPos(float t) {\n    float y = .6+cos(t)*.2;\n\treturn mix(vec3(-.3, y, t), vec3(2.2, y, t), (sin(t)*.5+.5)*1.);\n}\n\nvec3 Bg(vec3 rd) {\n    float b = -rd.y*.5+.5;\n\tvec3 col = vec3(.9, .6, .5)*b*4.;\n    \n    float a = atan(rd.x, rd.z);\n    \n    //col += sin(a*10.+iTime)*(1.-rd.y);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = (iMouse.xy-iResolution.xy*.5)/iResolution.xy;\n\tfloat t = iTime;\n   \n    vec2 heat=sin(vec2(.123, .234)*t*30.+uv*40.+vec2(0,t*10.));\n    //heat *= uv.y+.5;\n    float c = (sin(t*.1)*.5+.5);\n   \n    #ifndef ABSTRACT\n    c = .1;\n    #endif\n    \n   //c=.9;\n    uv += heat*.02*(c*c*c*c+.1);\n    \n    \n    vec3 ro = vec3(0, 0, .01);\n    ro.yz *= Rot(m.y*3.14*.25+.25);\n    ro.xz *= Rot(-m.x*6.2831+t*.1);\n   \n   // ro = GetPos(t*0.);\n    vec3 up = vec3(0,1,0);\n    //up.xy *= Rot(sin(t)*.4);\n    vec3 lookat = vec3(0,0,0);\n    \n    float zoom = mix(.7, 1.7, sin(t*.15)*.5+.5);\n    vec3 rd = R(uv, ro, lookat, zoom, up);\n\n    float d = RayMarch(ro, rd).x;\n    \n    vec3 bg = Bg(rd);\n    vec3 col = vec3(0.);\n\t\n    if(d<MAX_DIST) {\n        \n        vec3 p = ro + d*rd;\n        vec3 n = GetNormal(p);\n       \n        float dif = n.y*.5+.5;\n        \n        vec4 g = GetGyroids(p);\n        \n        col += dif;\n        col *= min(1., g.y*20.);\n        //col *= .1;\n        \n        float lava = S(.01-min(0., p.y*.1), -.01, g.y);\n        lava *= sin(g.z*100.+t)*.5+.5;\n       // lava += S(-.7, -1., n.y);\n        \n        \n        float flicker = Gyroid(p-vec3(0,t,0), 5., 0., .1);\n        flicker *= Gyroid(p-vec3(.2,.5,0)*t, 5., 0., .1);\n        \n        col *= sin(t*.2)*.5+.5; \n        col += flicker*10.*vec3(1., .4, .1);//*S(.01,.0, g.y);\n        \n        col += lava*vec3(1., .5, .1);\n        \n    }\n    col = mix(col, bg, S(0., 7., d));\n    \n    \n    float dSpark = SparkMarch(ro, rd).x;\n    \n    \n    if(dSpark<MAX_DIST && dSpark<d) {\n        //col += 1.;\n        \n        vec3 p = ro+rd*dSpark;\n        vec3 n = GetSparkNormal(p);\n        n = normalize(n*vec3(1,0,1));\n        \n        float f = max(0., dot(rd, -n));\n        float fade = 1.-pow(f, 5.);\n        fade = .05/fade;\n        fade *= S(.0, 1., f);\n        col += fade;\n        //col += 1.;\n    }\n    \n    \n    \n    fragColor = vec4(col,d);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// \"Up in flames\" by Martijn Steinrucken aka BigWings/CountFrolic - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n//\n// My upcoming tutorial on The Art of Code is called Playing with Gyroids \n// This is the result of playing with gyroids for a few hours ;)\n//\n// See common tab for tweakable values.\n\n// uncomment this for some extra periodic 2d fuckery ;)\n//#define ABSTRACT\n\n#define VIGNETTE 1.\n#define EXPOSURE 1.3\n#define DOF_SAMPLES 40\n\n#define MAX_STEPS 100\n#define MAX_DIST 7.\n#define SURF_DIST .001\n\n#define S(a, b, t) smoothstep(a, b, t)\n\n\nmat2 Rot(float a) {\n    float s=sin(a),c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\n// Dave Hoskins hash without sine\nfloat Hash21(vec2 p) {\n\tp = fract(p*vec2(123.23,234.34));\n    p += dot(p, p+87.);\n    return fract(p.x*p.y);\n}\n\nfloat Hash31(vec3 p) {\n\tp = fract(p*vec3(123.23,234.34,345.54));\n    p += dot(p, p+87.);\n    return fract(p.x*p.y*p.z);\n}\n\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// DOF function borrowed from XT95\nconst float GA =2.399; \nmat2 rot = mat2(cos(GA),sin(GA),-sin(GA),cos(GA));\nvec3 dof(sampler2D tex,vec2 uv,float rad, vec2 iResolution)\n{\n\tvec3 acc=vec3(0);\n    vec2 pixel=vec2(.003*iResolution.y/iResolution.x,.003),angle=vec2(0,rad);;\n    rad=1.;\n\tfor (int j=0;j<DOF_SAMPLES;j++)\n    {  \n        rad += 1./rad;\n\t    angle*=rot;\n        vec4 col=texture(tex,uv+pixel*(rad-1.)*angle);\n\t\tacc+=col.xyz;\n\t}\n\treturn acc/float(DOF_SAMPLES);\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define WAVES 8.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\n\tfloat time = iTime * 1.0;\n\t\n\tvec3 color = vec3(0.0);\n\n\tfor (float i=0.0; i<WAVES + 1.0; i++) {\n\t\tfloat freq = texture(iChannel0, vec2(i / WAVES, 0.0)).x * 7.0;\n\n\t\tvec2 p = vec2(uv);\n\n\t\tp.x += i * 0.04 + freq * 0.03;\n\t\tp.y += sin(p.x * 10.0 + time) * cos(p.x * 2.0) * freq * 0.2 * ((i + 1.0) / WAVES);\n\t\tfloat intensity = abs(0.01 / p.y) * clamp(freq, 0.35, 2.0);\n\t\tcolor += vec3(1.0 * intensity * (i / 5.0), 0.5 * intensity, 1.75 * intensity) * (3.0 / WAVES);\n\t}\n\n\tfragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 20,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}