{
    "Shader": {
        "info": {
            "date": "1491657560",
            "description": "Cubic bezier curve implicitization and distance approximation with intersections of two moving lines. See https://www.shadertoy.com/view/lsByRG for a more stripped down version (and sign computation).\nBest seen in fullscreen",
            "flags": 0,
            "hasliked": 0,
            "id": "XdjcDz",
            "likes": 9,
            "name": "Moving line cubic bezier",
            "published": 3,
            "tags": [
                "2d",
                "bezier",
                "cubic",
                "rational",
                "cubicbezier"
            ],
            "usePreview": 0,
            "username": "NinjaKoala",
            "viewed": 750
        },
        "renderpass": [
            {
                "code": "/*\n\tMy technique is mostly based on chapter 17 of\n\thttps://scholarsarchive.byu.edu/cgi/viewcontent.cgi?article=1000&context=facpub\n\n\tBut i've also used stuff from\n\thttp://140.129.20.249/~jmchen/ana/docs/resultant/implicitization-sederbeg.pdf\n\tand http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\n\t(see https://www.shadertoy.com/view/XsX3zf)\n*/\n\n#define MOVE_CONTROL_POINT\n//#define MOVE_LINES\n#define DRAW_LINES\n#define DRAW_APRROXIMATIONS\n//#define DRAW_CLAMPED\n//#define TAYLOR\n\nconst float zoom=1.;\n\nconst float num_lines=25.;\nconst float dot_size=.002;\n\nconst vec3 bg_col=vec3(1);\nconst vec3 bezier_col=vec3(0,0,1);\nconst vec3 taylor_col0=vec3(1,1,0);\nconst vec3 taylor_col1=vec3(1,0,1);\nconst vec3 point_col=vec3(0);\nconst vec3 line_col00=vec3(1,0,0);\nconst vec3 line_col01=vec3(.5,0,0);\nconst vec3 line_col10=vec3(0,1,0);\nconst vec3 line_col11=vec3(0,.5,0);\n\nconst float weight_p1=1.;\nconst float weight_p2=1.;\n\nfloat det(mat2 m){\n\treturn m[0][0]*m[1][1]-m[1][0]*m[0][1];\n}\n\n// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Credits to Doublefresh for hinting there\nint solve_quadric(vec3 coeffs, out vec2 roots){\n    float p, q, D;\n\n    // normal form: x^2 + px + q = 0\n\n    p = coeffs[1] / (2. * coeffs[0]);\n    q = coeffs[2] / coeffs[0];\n\n    D = p * p - q;\n\n    if (D < 0.){\n\t\treturn 0;\n    }\n    else if (D > 0.){\n\t\tfloat sqrt_D = sqrt(D);\n\n\t\troots[0] =   sqrt_D - p;\n\t\troots[1] = - sqrt_D - p;\n\t\treturn 2;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tfloat border=2./iResolution.x;\n\n\tvec2 uv=fragCoord.xy/iResolution.xy;\n\tuv-=.5;\n    uv.y*=iResolution.y/iResolution.x;\n\n\tvec2 mouse=iMouse.xy/iResolution.xy;\n\n\t#ifdef MOVE_CONTROL_POINT\n\tvec2 mouseuv=mouse-.5;\n    mouseuv.y*=iResolution.y/iResolution.x;\n\t#endif\n\n\tborder*=zoom;\n\tuv*=zoom;\n\n\tvec3 p0=vec3(-.3,-.1,1);\n\t#ifdef MOVE_CONTROL_POINT\n\tvec3 p1=weight_p1*vec3(mouseuv,1);\n\t#else\n\t//vec3 p1=weight_p1*vec3(-.1,-.2,1);//serpentine\n\tvec3 p1=weight_p1*vec3(-.4,-.05,1);//loop\n\t#endif\n\tvec3 p2=weight_p2*vec3(.1,.2,1);\n\tvec3 p3=vec3(.2,.15,1);\n\n\tfloat dis=1e38;\n\n\t//Control lines of quadratic bezier lines\n\t//The intersection of two of the three moving lines\n\t//at the same parameter value define the cubic bezier curve\n\tvec3 line00=3.*cross(p0,p1);\n\tvec3 line01=3.*cross(p0,p2);\n\tvec3 line02=cross(p0,p3);\n\n\tvec3 line10=line01;\n\tvec3 line11=cross(p0,p3)+9.*cross(p1,p2);\n\tvec3 line12=3.*cross(p1,p3);\n\n\tvec3 line20=line02;\n\tvec3 line21=line12;\n\tvec3 line22=3.*cross(p2,p3);\n\n\t#ifdef MOVE_LINES\n\t//float t1=tan((mouse.x-.5)*3.1416);//move from -inf to inf\n\tfloat t1=mouse.x;//move from 0 to 1\n\t#endif\n\n\t//Compute a linear moving line (line pencil) through elimination\n\t//The intersection of this and one of the quadratic moving lines\n\t//define the cubic bezier curve\n\tfloat pre_factor1=line20.z/line00.z;\n\tfloat pre_factor2=line20.z/line10.z;\n\n\tfloat sub_factor=(line20.x-pre_factor2*line10.x)/(pre_factor1*line00.x-pre_factor2*line10.x);\n\n\tfloat factor1=pre_factor1*sub_factor;\n\tfloat factor2=pre_factor2*(1.-sub_factor);\n\n\tvec3 line31=line21-factor1*line01-factor2*line11;\n\tvec3 line32=line22-factor1*line02-factor2*line12;\n\n\t//Compute signed distance of pixel coordinate to the control lines\n\tfloat l00=dot(vec3(uv,1),line00);\n\tfloat l01=dot(vec3(uv,1),line01);\n\tfloat l02=dot(vec3(uv,1),line02);\n\n\tfloat l31=dot(vec3(uv,1),line31);\n\tfloat l32=dot(vec3(uv,1),line32);\n\n\t//Compute the value of the resultant\n\t//of both line equations at the pixel coordinate\n\t//this is an implicit equation for the cubic bezier curve\n\t//(resultant is zero iff point lies on curve)\n\tvec2 a=vec2(l00,0);\n\tvec2 b=vec2(l01,l31);\n\tvec2 c=vec2(l02,l32);\n\n\tmat2 bezout=mat2(det(mat2(a,b)),det(mat2(a,c)),det(mat2(a,c)),det(mat2(b,c)));\n\n\t//Also compute the gradient of the resultant\n\tvec2 bezout_grad1=(line00.xy*b.y+a.x*line31.xy);\n\tvec2 bezout_grad2=(line00.xy*c.y+a.x*line32.xy);\n\tvec2 bezout_grad3=bezout_grad2;\n\tvec2 bezout_grad4=(line01.xy*c.y+b.x*line32.xy)-(line02.xy*b.y+c.x*line31.xy);\n\n\tfloat resultant=det(bezout);\n\tvec2 resultant_grad=(bezout_grad1*bezout[1][1]+bezout[0][0]*bezout_grad4)-(bezout_grad2*bezout[0][1]+bezout[1][0]*bezout_grad3);\n\n\t//Interestingly, i'm getting a kind of parasitic line in my resultant\n\t//the resultant is zero also if point lies on line00\n\t//This is not mentioned in Sederberg's script, so i am not entirely sure\n\t//if i'm doing something wrong\n\t//Anyway, i'm just dividing it out ;)\n\tvec2 gradient=(resultant_grad*l00-resultant*line00.xy)/(l00*l00);\n\tresultant/=l00;\n\n\t//Use the gradient to compute a point that's nearer to the curve\n\tvec2 nearest_point_global=uv-(resultant*gradient)/dot(gradient,gradient);\n\n\tfloat npgl31=dot(vec3(nearest_point_global,1),line31);\n\tfloat npgl32=dot(vec3(nearest_point_global,1),line32);\n\n\t//Get parameter value of this point by solving the linear line equation\n\tfloat parameter_global=npgl31/(npgl31-npgl32);\n\tparameter_global=clamp(parameter_global,0.,1.);\n\n\tvec3 clamped_point_global=((((-p0+3.*p1-3.*p2+p3)*parameter_global+(3.*p0-6.*p1+3.*p2))*parameter_global)+(-3.*p0+3.*p1))*parameter_global+p0;\n\tfloat bezier_dis=distance(uv,clamped_point_global.xy/clamped_point_global.z);\n\n\t//The double point is the intersection of the control lines\n\t//of the linear moving line\n\tvec3 double_point=cross(line31,line32);\n\n\t//Compute the parameter values at the double point\n\t//by solving the quadratic moving line equation\n\tfloat dpl00=dot(double_point,line00);\n\tfloat dpl01=dot(double_point,line01);\n\tfloat dpl02=dot(double_point,line02);\n\n\tvec3 dp_coeffs=vec3(dpl00-dpl01+dpl02,dpl01-2.*dpl00,dpl00);\n\tvec2 dp_rts;\n\n\tint n_dp=solve_quadric(dp_coeffs,dp_rts);\n\n\tvec2 taylor_resultant;\n\tmat2 taylor_grad;\n\tvec2 taylor_dis;\n\n\tif(n_dp!=0){ //Acnode or crunode?\n\t\tfor(int i=0;i<2;i++){\n\t\t\t//First compute the derivatives of the parametric cubic bezier curve at\n\t\t\t//both parameter values of the double point\n\t\t\tvec2 f=((((-p0.xy+3.*p1.xy-3.*p2.xy+p3.xy)*dp_rts[i]+(3.*p0.xy-6.*p1.xy+3.*p2.xy))*dp_rts[i])+(-3.*p0.xy+3.*p1.xy))*dp_rts[i]+p0.xy;\n\t\t\tvec2 f1=(3.*(-p0.xy+3.*p1.xy-3.*p2.xy+p3.xy)*dp_rts[i]+2.*(3.*p0.xy-6.*p1.xy+3.*p2.xy))*dp_rts[i]+(-3.*p0.xy+3.*p1.xy);\n\t\t\tvec2 f2=2.*(3.*(-p0.xy+3.*p1.xy-3.*p2.xy+p3.xy)*dp_rts[i]+(3.*p0.xy-6.*p1.xy+3.*p2.xy));\n\t\t\t#ifndef TAYLOR\n\t\t\tvec2 f3=6.*(-p0.xy+3.*p1.xy-3.*p2.xy+p3.xy);\n\t\t\t#endif\n\n\t\t\tfloat q=((((-p0.z+3.*p1.z-3.*p2.z+p3.z)*dp_rts[i]+(3.*p0.z-6.*p1.z+3.*p2.z))*dp_rts[i])+(-3.*p0.z+3.*p1.z))*dp_rts[i]+p0.z;\n\t\t\tfloat q1=(3.*(-p0.z+3.*p1.z-3.*p2.z+p3.z)*dp_rts[i]+2.*(3.*p0.z-6.*p1.z+3.*p2.z))*dp_rts[i]+(-3.*p0.z+3.*p1.z);\n\t\t\tfloat q2=2.*(3.*(-p0.z+3.*p1.z-3.*p2.z+p3.z)*dp_rts[i]+(3.*p0.z-6.*p1.z+3.*p2.z));\n\t\t\t#ifndef TAYLOR\n\t\t\tfloat q3=6.*(-p0.z+3.*p1.z-3.*p2.z+p3.z);\n\t\t\t#endif\n\n\t\t\t//Compute Taylor coefficients (at point 0)\n\t\t\tvec2 a0=f/q;\n\t\t\tvec2 a1=(f1-f*q1/q)/q;\n\t\t\tvec2 a2=(1./2.)*(((2.*f*q1*q1)/q-(2.*f1*q1+f*q2))/q+f2)/q;\n\t\t\t#ifndef TAYLOR\n\t\t\tvec2 a3=(1./6.)*((((-6.*f*q1*q1*q1)/q+(6.*f1*q1*q1+6.*f*q1*q2))/q+(-3.*f2*q1-f*q3-3.*f1*q2))/q+f3)/q;\n\t\t\t#endif\n\n\t\t\t//Padé approximation: Use Taylor coefficients to compute Padé coefficients\n\t\t\t//Padé is better for most curve's, but sometimes, especially for rational cubic curves\n\t\t\t//The Padé approximation itself (which is a conic section)\n\t\t\t//degenerates to two lines, then Taylor approximation is the better variant\n\t\t\t#ifndef TAYLOR\n\t\t\tfloat d0_tmp=1.;\n\t\t\tfloat d1_tmp=-dot(a2,a3)/(dot(a2,a2)-dot(a1,a3));\n\t\t\tfloat d2_tmp=dot(a3,a3)/(dot(a2,a2)-dot(a1,a3));\n\n\t\t\tvec2 c0=a0;\n\t\t\tvec2 c1=a1+a0*d1_tmp;\n\t\t\tvec2 c2=a2+a1*d1_tmp+a0*d2_tmp;\n\n\t\t\t//Resubstitution: The previous calculation assumed the Taylor base point was 0 (which it isn't)\n\t\t\tfloat d2=d2_tmp;\n\t\t\tfloat d1=d1_tmp-2.*dp_rts[i]*d2_tmp;\n\t\t\tfloat d0=d0_tmp+dp_rts[i]*(dp_rts[i]*d2_tmp-d1_tmp);\n\n\t\t\tvec2 qu=c2-d2*uv;\n\t\t\tvec2 li=c1-2.*dp_rts[i]*c2-d1*uv;\n\t\t\tvec2 co=c0+dp_rts[i]*(dp_rts[i]*c2-c1)-d0*uv;\n\t\t\t#else\n\t\t\tvec2 qu=a2;\n\t\t\tvec2 li=a1-2.*dp_rts[i]*a2;\n\t\t\tvec2 co=a0+dp_rts[i]*(dp_rts[i]*a2-a1)-uv;\n\t\t\t#endif\n\n\t\t\t//Implicitize the parametric approximation with the Bézout matrix\n\t\t\t//And compute it's gradient\n\t\t\tmat2 taylor_bezout=mat2(det(mat2(qu,li)),det(mat2(qu,co)),det(mat2(qu,co)),det(mat2(li,co)));\n\t\t\ttaylor_resultant[i]=det(taylor_bezout);\n\n\t\t\t#ifndef TAYLOR\n\t\t\tvec2 taylor_grad1=(vec2(-d2,0)*li.y+qu.x*vec2(0,-d1))-(vec2(-d1,0)*qu.y+li.x*vec2(0,-d2));\n\t\t\tvec2 taylor_grad2=(vec2(-d2,0)*co.y+qu.x*vec2(0,-d0))-(vec2(-d0,0)*qu.y+co.x*vec2(0,-d2));\n\t\t\tvec2 taylor_grad3=taylor_grad2;\n\t\t\tvec2 taylor_grad4=(vec2(-d1,0)*co.y+li.x*vec2(0,-d0))-(vec2(-d0,0)*li.y+co.x*vec2(0,-d1));\n\n\t\t\ttaylor_grad[i]=(taylor_grad1*taylor_bezout[1][1]+taylor_bezout[0][0]*taylor_grad4)-(taylor_grad2*taylor_bezout[0][1]+taylor_bezout[1][0]*taylor_grad3);\n\t\t\t#else\n\t\t\ttaylor_grad[i]=taylor_bezout[0][0]*(vec2(li.y,-li.x))-(vec2(qu.y,-qu.x)*taylor_bezout[0][1]+taylor_bezout[1][0]*vec2(qu.y,-qu.x));\n\t\t\t#endif\n\n\t\t\t//Now use this gradient to get a point that's more close to the curve (but on the approximation curve now)\n\t\t\tvec2 nearest_point_taylor=uv-(taylor_resultant[i]*taylor_grad[i])/dot(taylor_grad[i],taylor_grad[i]);\n\t\t\t\n\t\t\t#ifndef TAYLOR\n\t\t\tvec2 npt_qu=c2-d2*nearest_point_taylor;\n\t\t\tvec2 npt_li=c1-2.*dp_rts[i]*c2-d1*nearest_point_taylor;\n\t\t\tvec2 npt_co=c0+dp_rts[i]*(dp_rts[i]*c2-c1)-d0*nearest_point_taylor;\n\t\t\t#else\n\t\t\tvec2 npt_qu=a2;\n\t\t\tvec2 npt_li=a1-2.*dp_rts[i]*a2;\n\t\t\tvec2 npt_co=a0+dp_rts[i]*(dp_rts[i]*a2-a1)-nearest_point_taylor;\n\t\t\t#endif\n\n\t\t\t//Get the parameter value of the point computed above\n\t\t\t//I'm using curve inversion of the approximation curve\n\t\t\t//using some coefficients of the bezout matrix\n\t\t\tfloat parameter_taylor=-det(mat2(npt_qu,npt_co))/det(mat2(npt_qu,npt_li));\n\t\t\tparameter_taylor=clamp(parameter_taylor,0.,1.);\n\n\t\t\t//Compute point on original curve using the parameter at the point on the approximation curve\n\t\t\tvec3 clamped_point_taylor=((((-p0+3.*p1-3.*p2+p3)*parameter_taylor+(3.*p0-6.*p1+3.*p2))*parameter_taylor)+(-3.*p0+3.*p1))*parameter_taylor+p0;\n\t\t\ttaylor_dis[i]=distance(uv,clamped_point_taylor.xy/clamped_point_taylor.z);\n\t\t}\n\t}\n\n\t#ifdef MOVE_LINES\n\tvec3 moving_line0=(1.-t1)*(1.-t1)*line00+(1.-t1)*t1*line01+t1*t1*line02;\n\tvec3 moving_line1=mix(line31,line32,t1);\n\n\tvec3 int_point=cross(moving_line0,moving_line1);\n\t#endif\n\n\tvec3 color=bg_col;\n\n\t#ifdef DRAW_LINES\n\n\t//Solve the quadratic moving line at pixel coordinate\n\tvec3 coeffs=vec3(l00-l01+l02,l01-2.*l00,l00);\n\tvec2 roots;\n\n\tsolve_quadric(coeffs,roots);\n\n\t//Clamp and quantize the parameters of the moving line\n\troots=clamp(roots,vec2(0),vec2(1));\n\troots=floor(roots*(num_lines-1.)+.5)/(num_lines-1.);\n\n\t//Draw the quadratic moving lines at current parameter values\n\tvec3 moving_lineuv0=(1.-roots.x)*(1.-roots.x)*line00+(1.-roots.x)*roots.x*line01+roots.x*roots.x*line02;\n\tvec3 moving_lineuv1=(1.-roots.y)*(1.-roots.y)*line00+(1.-roots.y)*roots.y*line01+roots.y*roots.y*line02;\n\n\t//Solve the linear moving line at pixel coordinate\n\tfloat root=l31/(l31-l32);\n\n\t//Clamp and quantize the parameter of the moving line\n\troot=clamp(root,0.,1.);\n\troot=floor(root*(num_lines-1.)+.5)/(num_lines-1.);\n\n\tvec3 moving_lineuv2=mix(line31,line32,root);\n\n\t//Get 3 candidates for the nearest point\n\t//That is an intersection of two moving lines\n\t//at the same parameter\n\t//This is an approximation as can be seen when the dot's flatten out\n\tvec3 moving_lineuv3=mix(line31,line32,roots.x);\n\tvec3 moving_lineuv4=mix(line31,line32,roots.y);\n\tvec3 moving_lineuv5=(1.-root)*(1.-root)*line00+(1.-root)*root*line01+root*root*line02;\n\n\tvec3 int_point0=cross(moving_lineuv0,moving_lineuv3);\n\tvec3 int_point1=cross(moving_lineuv1,moving_lineuv4);\n\tvec3 int_point2=cross(moving_lineuv2,moving_lineuv5);\n\n\tvec3 line_col=mix(line_col00,line_col01,roots.x);\n\n\tmoving_lineuv0/=length(moving_lineuv0.xy);\n\tdis=min(dis,abs(dot(vec3(uv,1),moving_lineuv0)));\t\n\n\tcolor=mix(line_col,color,smoothstep(0.,border,dis));\n\tdis=1e38;\n\n\tline_col=mix(line_col00,line_col01,roots.y);\n\n\tmoving_lineuv1/=length(moving_lineuv1.xy);\n\tdis=min(dis,abs(dot(vec3(uv,1),moving_lineuv1)));\t\n\n\tcolor=mix(line_col,color,smoothstep(0.,border,dis));\n\tdis=1e38;\n\t#endif\n\n\t#ifdef MOVE_LINES\n\tmoving_line0/=length(moving_line0.xy);\n\tdis=min(dis,abs(dot(vec3(uv,1),moving_line0)));\t\n\n\tcolor=mix(line_col00,color,smoothstep(0.,border,dis));\n\tdis=1e38;\n\t#endif\n\n\t#ifdef MOVE_LINES\n\tmoving_line1/=length(moving_line1.xy);\n\tdis=min(dis,abs(dot(vec3(uv,1),moving_line1)));\t\n\n\tcolor=mix(line_col10,color,smoothstep(0.,border,dis));\n\tdis=1e38;\n\t#endif\n\n\t#ifdef DRAW_LINES\n\tmoving_lineuv2/=length(moving_lineuv2.xy);\n\tdis=min(dis,abs(dot(vec3(uv,1),moving_lineuv2)));\t\n\n\tline_col=mix(line_col10,line_col11,root);\n\n\tcolor=mix(line_col,color,smoothstep(0.,border,dis));\n\tdis=1e38;\n\t#endif\n\n\t#ifdef DRAW_CLAMPED\n\tif(n_dp!=0){\n\t\tif(bezier_dis<taylor_dis[0] && bezier_dis<taylor_dis[1]){\n\t\t\tcolor=mix(bezier_col,color,smoothstep(0.,border,bezier_dis));\n\t\t}\n\t\telse if(taylor_dis[0]<bezier_dis && taylor_dis[0]<taylor_dis[1]){\n\t\t\tcolor=mix(taylor_col0,color,smoothstep(0.,border,taylor_dis[0]));\n\t\t}\n\t\telse if(taylor_dis[1]<bezier_dis && taylor_dis[1]<taylor_dis[0]){\n\t\t\tcolor=mix(taylor_col1,color,smoothstep(0.,border,taylor_dis[1]));\n\t\t}\n\t}\n\telse{\n\t\tcolor=mix(bezier_col,color,smoothstep(0.,border,bezier_dis));\n\t}\n\t#else\n\tdis=min(dis,abs(resultant)/length(gradient));\n\tcolor=mix(bezier_col,color,smoothstep(0.,border,dis));\n\tdis=1e38;\n\t#endif\n\t\n\t#ifdef DRAW_APRROXIMATIONS\n\tif(n_dp!=0){\n\t\tdis=min(dis,abs(taylor_resultant[0])/length(taylor_grad[0]));\n\t\tcolor=mix(taylor_col0,color,smoothstep(0.,border,dis));\n\t\tdis=1e38;\n\n\t\tdis=min(dis,abs(taylor_resultant[1])/length(taylor_grad[1]));\n\t\tcolor=mix(taylor_col1,color,smoothstep(0.,border,dis));\n\t\tdis=1e38;\n\t}\n\t#endif\n\n\tdis=min(dis,distance(p0.xy/p0.z,uv)-dot_size);\n\tdis=min(dis,distance(p1.xy/p1.z,uv)-dot_size);\n\tdis=min(dis,distance(p2.xy/p2.z,uv)-dot_size);\n\tdis=min(dis,distance(p3.xy/p3.z,uv)-dot_size);\n\n\t#ifdef MOVE_LINES\n\tdis=min(dis,distance(int_point.xy/int_point.z,uv)-dot_size);\n\t#endif\n\n\t#ifdef DRAW_LINES\n\tdis=min(dis,distance(double_point.xy/double_point.z,uv)-dot_size);\n\n\tdis=min(dis,distance(int_point0.xy/int_point0.z,uv)-dot_size);\n\tdis=min(dis,distance(int_point1.xy/int_point1.z,uv)-dot_size);\n\tdis=min(dis,distance(int_point2.xy/int_point2.z,uv)-dot_size);\n\t#endif\n\n\tcolor=mix(point_col,color,smoothstep(0.,border,dis));\n\n\tfragColor=vec4(color,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}