{
    "Shader": {
        "info": {
            "date": "1611695537",
            "description": "marble tato",
            "flags": 0,
            "hasliked": 0,
            "id": "WlVcWy",
            "likes": 15,
            "name": "Day 406",
            "published": 3,
            "tags": [
                "art",
                "artdeco",
                "mdtmjvm",
                "deco"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 426
        },
        "renderpass": [
            {
                "code": "#define pi acos(-1.)\n#define tau (2.*pi)\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define dmin(a,b) a.x < b.x ? a : b\n#define preplim(g,c,l) g-c*clamp(round((g)/c),-l,l)\n#define xor(a,b,c) min(max(a,-b), max(-a,b + c))\n\n\n\nfloat pixSz;\n\n// Hex code from BigWings! He has a tutorial on them.\nfloat HexDist(vec2 p) {\n\tp = abs(p);\n    float c = dot(p, normalize(vec2(1,1.73)));\n    c = max(c, p.x);\n    return c;\n}\n\nvec4 HexCoords(vec2 uv, out vec2 gv) {\n\tvec2 r = vec2(1, 1.73);\n    vec2 h = r*.5;\n    vec2 a = mod(uv, r)-h;\n    vec2 b = mod(uv-h, r)-h;\n    gv = dot(a, a) < dot(b,b) ? a : b;\n    float x = atan(gv.x, gv.y);\n    float y = .5-HexDist(gv);\n    vec2 id = uv-gv;\n    return vec4(x, y, id.x,id.y);\n}\n\n\n//#define xor()\n\n\n#define ID_GOLD 1.\n#define ID_BLACK 0.\n\nfloat sdBox(vec2 p, vec2 s){\n    p = abs(p) - s; return max(p.x, p.y);\n}\n\n\nvoid map(vec2 p, out float dBase, out float dGold){\n    p.x *= 0.8;\n    \n    \n    //dBase = length(p) - 0.55;\n    \n    p.x += 0.;\n    dBase = sdBox(p*rot(0.25*pi),vec2(0.5));\n    \n    float sideW = 0.47;\n    dBase = max(dBase, abs(p.y) - sideW);\n    \n    dBase = min(dBase, max(abs(p.y) - sideW,p.x));\n    \n    //dBase =  pmodlim(dBase,0.1,0.1);\n    \n    \n    //dBase = dBase-c*clamp(round(dBase/c),-l,l);\n    \n    dGold = abs(preplim(dBase + 0.11,0.1,1.)) - 0.01;\n    \n    \n    //dGold = xor(dGold,max(abs(p.y) - 0.3,abs(p.x + 0.1) - 0.25),0.4);\n    \n    dGold = xor(dGold,max(abs(p.y) - 0.3,abs(p.x + 0.35) - 0.25),0.4);\n    \n    //dGold = xor(dGold,max(abs(length(p.x + p.y + 0.04) - .5) - 0.,abs(p.y + 0.) - 0.),0.);\n    \n    \n    ////float db = xor(dGold, abs(length(p) - 0.2) - 0.0);\n    \n    //db = \n    //dGold = xor(dGold, db );\n    \n    //dGold = min(dGold,db);\n\n}\n\n\nvec3 getNormalGolda(vec2 p){\n    vec2 e = vec2(0.,0.2);\n    float idklol = 0.;\n    float dG = 0.;\n    map(p,idklol,dG);\n    \n    const float normalAtt = .1;\n    \n    float dGA = 0.;\n    map(p + e.xy,idklol,dGA);\n    float dGB = 0.;\n    map(p + e.yx,idklol,dGB);\n    \n    \n    dG = smoothstep(normalAtt,0.,dG);\n    dGA = smoothstep(normalAtt,0.,dGA);\n    dGB = smoothstep(normalAtt,0.,dGB);\n    \n    return normalize(dG - vec3(0,0,1.) - vec3(dGA, dGB,0.)*1.);;\n}\n\n\nvec3 getNormalGold(vec2 p){\n    vec2 e = vec2(0.,0.02);\n    \n    float normalAtt = 0.02;\n    \n    float idklol = 0.;\n    float dGXa = 0.;\n    map(p + e.yx,idklol,dGXa);\n    float dGXb = 0.;\n    map(p - e.yx,idklol,dGXb);\n    \n    float dGYa = 0.;\n    map(p + e.xy,idklol,dGYa);\n    float dGYb = 0.;\n    map(p - e.xy,idklol,dGYb);\n    \n    \n    dGXa = smoothstep(normalAtt,0.,dGXa);\n    dGXb = smoothstep(normalAtt,0.,dGXb);\n    dGYa = smoothstep(normalAtt,0.,dGYa);\n    dGYb = smoothstep(normalAtt,0.,dGYb);\n    \n    vec2 deriv = vec2(dGXa - dGXb, dGYa - dGYb);\n    \n    return normalize( -vec3(0,0,1.) + vec3(deriv,0.)*1.);;\n}\nvec3 getNormalGoldB(vec2 p){\n    vec2 e = vec2(0.,0.05);\n    float idklol = 0.;\n    float dG = 0.;\n    map(p,idklol,dG);\n    \n    const float normalAtt = .05;\n    \n    float dGA = 0.;\n    map(p + e.xy,idklol,dGA);\n    float dGB = 0.;\n    map(p + e.yx,idklol,dGB);\n    \n    \n    dG = smoothstep(normalAtt,0.,dG);\n    dGA = smoothstep(normalAtt,0.,dGA);\n    dGB = smoothstep(normalAtt,0.,dGB);\n    \n    return normalize(dG - vec3(0,0,0.5) - vec3(dGA, dGB,0.)*1.);;\n}\n\nvec2 globalPos;\nvec2 guv;\nvoid getTile( vec2 p, out vec3 col, out float dBase, vec2 gv){\n    \n    vec2 d = vec2(10e5);\n    col -= col;\n    \n    float dGold;\n    \n    map(p,dBase,dGold);\n    \n    // globalPos and guv should be offset by the tile offs but eh \n    \n    vec3 goldCol = vec3(1,0.5,0.1);\n    vec3 marbleCol = vec3(0.00);\n    \n    \n    //const vec3 lDir = normalize(vec3(-1,2,-1.));\n    const vec3 lDir = normalize(vec3(-1,2,-1.));\n\n    float nA = cyclicNoise(vec3(globalPos,0. + iTime)*0.4, false, iTime*1.);\n    float nB = cyclicNoise(vec3(globalPos,6.)*20., true, iTime);\n    float nC = cyclicNoiseMarb(vec3(globalPos,6.)*10., false, 0.);\n    float nE = cyclicNoiseMarbB(vec3(globalPos,6.)*11. + 4., false, 0.);\n    \n    \n    dGold += nB*0.001 + nC*0.003;\n    // marble\n\n    //marbleCol += pow(max(nC,0.),4.)*mix(vec3(1.1,0.5,0.2),vec3(0.1,0.6,1.),smoothstep(0.,1.,pow(nC,5.1)));\n    vec3 marbles = pow(max(nC,0.),4.)*mix(vec3(1.1,0.5,0.2),vec3(0.1,0.6,1.),smoothstep(0.,1.,pow(nC,5.1)));\n    //vec3 marblesb = pow(max(nE,0.),8.)*mix(vec3(1.1,0.5,0.2),vec3(0.1,0.6,1.),smoothstep(0.,1.,pow(nE,9.1)));\n    vec3 marblesb = smoothstep(0.35,0.,nE + 0.2)*vec3(1);\n    \n    marbleCol += 0.075*marbles;\n\n    marbleCol += 0.45*marblesb;\n\n\n    // gold\n    vec3 goldNormal = getNormalGold(p);\n    goldCol = mix(goldCol,goldCol*goldCol,nB*0.75);\n    \n    goldNormal = normalize(goldNormal + nA*5.);\n    \n    goldCol = mix(goldCol,goldCol*16.*vec3(0.7,0.6,0.9) ,max(dot(goldNormal,lDir),0.));\n    //goldCol = mix(goldCol,goldCol*0. ,max(dot(getNormalGoldB(p),vec3(1,-0.4,-0.)),0.));\n    goldCol = mix(goldCol,goldCol*0.3*vec3(0.5,0.5,1) ,max(dot(getNormalGoldB(p),vec3(1,-0.4,-0.)),0.));\n    \n    \n    goldCol = mix(goldCol,goldCol*0.4*vec3(0.5,0.5,1),smoothstep(0.01,0.00,abs(dGold)));\n    \n    \n    \n    //marbleCol = mix(marbleCol,.05*vec3(0.7,0.6,0.9) ,max(dot(goldNormal,lDir),0.));\n\n    //marbleCol = mix(marbleCol,.15*vec3(0.7,0.6,0.9), smoothstep(1.,0.,dot(guv,guv)) );\n    vec2 mguv = guv + vec2(0,iTime*0.146);\n    marbleCol += pow(texture(iChannel0,mguv*2.5*rot(0.5*pi),1.).xyz,vec3(4.))*vec3(0.2,1.,1.)*0.1*smoothstep(1.,0.,dot(guv - 0.25,guv - 0.25))*(1. + marbles*4.) ;\n    \n    marbleCol *= smoothstep(0.,0.12,dGold);\n    \n    col = mix(col,marbleCol, smoothstep(pixSz,dBase,dBase));\n    \n    col = mix(col,goldCol, smoothstep(pixSz,0.,dGold));\n    \n    col = mix(col,col*0.05*vec3(0.2,0.2,3.),smoothstep(0.,0.7,-p.x*1.4));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    guv = uv;\n    \n    uv *= 4.;\n    \n    uv.y += iTime*0.5;\n    uv.y /= 0.8;\n    \n    globalPos = uv;\n    pixSz = dFdx(uv.x)*1.;\n    \n    uv *= rot(-0.5*pi);\n    vec2 gv;\n    vec4 hc = HexCoords(uv, gv);\n    /*\n    float d = map(gv);\n    col += smoothstep(pixSz,0.,abs(d));\n    */\n    for(float i = 0.; i < 7.; i++){\n        vec2 offs = vec2(0);\n        \n        float ioffs = 0.;\n        if(i < 3. ){\n            float offsIdx = tau*(i + ioffs)/6.;\n            offs = vec2(sin(offsIdx),cos(offsIdx))*0.5;\n        } else if( i == 3.) {\n        \n        } else if( i == 4. || i == 5.){\n            float offsIdx = tau*(i + ioffs - 1. + float(i == 5.)  )/6.;\n            offs = vec2(sin(offsIdx),cos(offsIdx))*0.5;\n        \n        } else if( i == 6.){\n            float offsIdx = tau*(i + ioffs - 2.)/6.;\n            offs = vec2(sin(offsIdx),cos(offsIdx))*0.5;\n        }\n        \n        vec4 hc = HexCoords(uv + offs, gv);\n        \n        float d; \n        vec3 tileCol;\n        getTile(gv - offs, tileCol, d, uv - offs);\n        \n        \n        col = mix( col, tileCol, smoothstep(pixSz,0.,d));\n        \n    }\n    \n    \n    //col += smoothstep(pixSz,0.,hc.y);\n        \n        \n    //float n = cyclicNoise(vec3(uv,1.), false, 0.);\n\n    \n    //col = clamp(col,0.,1.);\n    \n    col = max(col,0.);\n    col = mix(col,col*col*0.0,pow(smoothstep(0.,1.,dot(guv,guv)),0.5));\n\n    col *= vec3(1.,0.9,0.8);\n    col = pow(col,vec3(0.454545));\n    \n    fragColor = vec4(0);\n    fragColor.xyz = col.xyz;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": " \n\nmat3 getOrthogonalBasis(vec3 direction){\n    direction = normalize(direction);\n    vec3 right = normalize(cross(vec3(0,1,0),direction));\n    vec3 up = normalize(cross(direction, right));\n    return mat3(right,up,direction);\n}\n\n\nfloat cyclicNoise(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    float amp = 1.;\n    const float gain = 0.9;\n    const float lacunarity = 1.5;\n    const int octaves = 6;\n    \n    const float warp = 0.2;    \n    float warpTrk = 1.5 ;\n    const float warpTrkGain = .2;\n    \n    vec3 seed = vec3(-1,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk + vec3(0,-time*2.,0) - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\nfloat cyclicNoiseMarb(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    float amp = 1.;\n    const float gain = 0.6;\n    const float lacunarity = 1.75;\n    const int octaves = 9;\n    \n    const float warp = 0.7;    \n    float warpTrk = 2. ;\n    const float warpTrkGain = 1.09;\n    \n    vec3 seed = vec3(-5,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk + vec3(0,-time*2.,0) - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\nfloat cyclicNoiseMarbB(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    float amp = 1.;\n    const float gain = 0.6;\n    const float lacunarity = 1.75;\n    const int octaves = 5;\n    \n    const float warp = .9;\n    float warpTrk = 1. ;\n    const float warpTrkGain = 1.09;\n    \n    vec3 seed = vec3(-5,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk + vec3(0,-time*2.,0) - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}