{
    "Shader": {
        "info": {
            "date": "1693612466",
            "description": "The Squares will not intersect based on the rotations, but the square distance offset only functions as intended with small positive numbers.",
            "flags": 0,
            "hasliked": 0,
            "id": "ctjyRD",
            "likes": 4,
            "name": "Square_Spiral",
            "published": 3,
            "tags": [
                "spiral",
                "square"
            ],
            "usePreview": 0,
            "username": "2w435",
            "viewed": 148
        },
        "renderpass": [
            {
                "code": "#define TAU 6.28318530718\n#define SQRT2 1.41421356237\n\nconst float SQUARE_NUMBER_OVERHEAD = 4.0;\n\nfloat ManDist(vec2 uv) {\n    return abs(uv.x) + abs(uv.y);\n}\n\nfloat SquareSpiralMask(vec2 uv, float speed, float rotA, float rotB,\n                       int sqNo, float sqThick, float sqDistOffset)\n{\n    float mask = 1.0;\n    \n    // Calculated Angle between two adjecent Squares\n    float y = abs( 1.0 / float(sqNo) * (rotB - rotA) );\n    \n    // Factor by which the Side Length change due to the Rotation\n    float scaleFactor = 1.0 / ( SQRT2 * sin( (y + 0.125 * TAU)) );\n    \n    for (float j = -SQUARE_NUMBER_OVERHEAD; j < float(sqNo) + SQUARE_NUMBER_OVERHEAD; j++)\n    {\n        // Interploated value w/ Change over Time\n        float t = fract( iTime * speed);\n        float samp = (j + t) / float(sqNo);\n        \n        // Angle of the Square\n        float a = mix(rotB, rotA, samp);\n        \n        // Accommodates the Change in Side Length due to the Rotation\n        float sqDist = pow(scaleFactor, j);\n        sqDist = mix(              sqDist - sqDistOffset * j, \n                     scaleFactor * sqDist - sqDistOffset * (j + 1.0), t);\n       \n        // Rescales the side length to accommodate the Square Thickness\n        sqDist *= pow(1.0 - sqThick, j + t);\n        \n        // Creats rotated Distance Field\n        mat2 rot = mat2(vec2(cos(a), -sin(a)),vec2( sin(a), cos(a)));\n        float df = ManDist(rot * uv);\n        \n        df = abs(df - sqDist - (sqThick / 2.0));\n        \n        mask = min(mask, df);\n    }\n    \n    return smoothstep(sqThick, 0., mask);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.x;\n    \n    float mask1 = SquareSpiralMask(uv, 0.5, radians(45.0), -radians(90.), 17, 0.01, 0.03);\n    float mask2 = SquareSpiralMask(uv, -0.2, radians(36.),\n            -radians(18.) + radians(10.) * sin(iTime * 0.5), 3, 0.1, 0.2);\n    \n    mask1 = smoothstep(0.0, 1.0, length(uv * 3.0)) * mask1;\n    mask2 = smoothstep(0.0, 1.0, length(uv * 5.0)) * mask2;\n    \n    vec3 col = mask1 * vec3(0.2, 0.7, 0.5) + mask2 * vec3(0.6, 0.6, 0.6);\n    \n    fragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}