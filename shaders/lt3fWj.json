{
    "Shader": {
        "info": {
            "date": "1541028532",
            "description": "Coded live on twitch stream in Bonzomatic, and tidied/ported to shadertoy.\nUnedited Bonzomatic shader here: [url]https://gist.github.com/willkirkby/7afe42a8c8efb74ac33bb449e6941069[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "lt3fWj",
            "likes": 5,
            "name": "[twitch] Pumpkin",
            "published": 3,
            "tags": [
                "halloween",
                "pumpkin",
                "twitch"
            ],
            "usePreview": 0,
            "username": "yx",
            "viewed": 1869
        },
        "renderpass": [
            {
                "code": "#define PI (acos(-1.))\n\nvec2 rotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\n// http://mercury.sexy/hg_sdf/\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n    float angle = 2.*PI/repetitions;\n    float a = atan(p.y, p.x) + angle/2.;\n    float r = length(p);\n    float c = floor(a/angle);\n    a = mod(a,angle) - angle/2.;\n    p = vec2(cos(a), sin(a))*r;\n    // For an odd number of repetitions, fix cell index of the cell in -x direction\n    // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n    if (abs(c) >= (repetitions/2.)) c = abs(c);\n    return c;\n}\n\nfloat sdSphere(vec3 p, vec3 c, float r)\n{\n    return length(p-c)-r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nvec2 scene(vec3 p)\n{\n    float floorPlane = p.y + 1.;\n\n    vec3 rp = p;\n    pModPolar(rp.xz, 12.);\n    float sphere = length(rp*vec3(.9,1,1)-vec3(.3,0,0))-1.;\n\n    sphere = abs(sphere+.05)-.05;\n\n    vec3 mirrorP = p;\n    mirrorP.z = -abs(mirrorP.z);\n\n    // round eyes\n    vec3 mp = p;\n    mp.x = abs(mp.x);\n    float eye = sdSphere(mp, vec3(.3,.4,-1.2), .17);\n    sphere = max(sphere, -eye);\n\n    // curved mouth\n    float mouth1 = sdSphere(p, vec3(0,.6,-1), 1.);\n    float mouth2 = sdSphere(p, vec3(0,1.3,-1), 1.35);\n    sphere = max(sphere, -max(mouth1, -mouth2));\n\n    // angular eyes\n    sphere = max(sphere, -sdTriPrism(mp*vec3(1,-1,1)+vec3(-.25,.35,-1.), vec2(.2,1.1)));\n\n    // both noses\n    sphere = max(sphere, -sdTriPrism(mirrorP-vec3(0,.22,-1.), vec2(.1,1.1)));\n\n    // angular mouth\n    sphere = max(sphere, -sdTriPrism(mp*vec3(1,-1,1)+vec3(-.37,-.03,-1.), vec2(.16,1.1)));\n    sphere = max(sphere, -sdTriPrism(mp*vec3(1,-1,1)+vec3(-.2,-.04,-1.), vec2(.18,1.1)));\n    sphere = max(sphere, -sdTriPrism(mp*vec3(1,-1,1)+vec3(0,-.05,-1.), vec2(.2,1.1)));\n\n\n    floorPlane = -sdBox(p-vec3(0,1,0), vec3(6,2.5,6));\n\n    float stem = dot(vec4(rp,1),vec4(1,.1,0,-.2));\n    stem = max(stem, p.y-1.3);\n    stem = max(stem, -p.y+.95);\n\n    return vec2(\n        min(floorPlane,min(sphere,stem)),\n        floorPlane < sphere \n        ? 0\n        : sphere < stem\n        ? 1\n        : 2\n    );\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 cam = vec3(0,0,-5);\n    vec3 dir = normalize(vec3(uv,1));\n\n    cam.yz = rotate(cam.yz, .3+sin(iTime*.1)*.1);\n    dir.yz = rotate(dir.yz, .3+sin(iTime*.1)*.1);\n\n    cam.xz = rotate(cam.xz, iTime*.4);\n    dir.xz = rotate(dir.xz, iTime*.4);\n\n    float t = 0.;\n    for(int i=0;i<100;++i)\n    {\n        float k = scene(cam+dir*t).x;\n        t += k;\n        if (k<.001) break;\n    }\n    vec3 h = cam+dir*t;\n    vec2 o = vec2(0.001,0);\n    vec3 n = normalize(vec3(\n        scene(h+o.xyy).x-scene(h-o.xyy).x,\n        scene(h+o.yxy).x-scene(h-o.yxy).x,\n        scene(h+o.yyx).x-scene(h-o.yyx).x\n    ));\n    vec2 mat = scene(h);\n\n    vec3 candlePos = sin(iTime*vec3(\n        18.1,\n        15.6,\n        14.7\n    ))*.01;\n\n    if (mat.x > 1.)\n    {\n        // sky\n        out_color = vec4(0,0,0,1);\n    }\n    else if (mat.y == 0.)\n    {\n        // floor\n        float fakeLight = clamp(1.-length(h)*.12,0.,1.);\n        vec4 color = vec4(.2,0,.3,0);\n        vec3 fh = fract(h*.5+.501)-.5;\n        float checker = fh.x*fh.y*fh.z;\n        out_color = color*float(checker>0.) * fakeLight;\n    }\n    else if (mat.y == 1. || mat.y == 2.)\n    {\n        vec3 fakeN = n;\n        fakeN.xz = rotate(fakeN.xz, -iTime*.4);\n        // pumpkin\n        vec4 albedo = mat.y == 1. ? vec4(1,.5,0,0) : vec4(.1,.3,.1,1);\n        out_color = albedo * (fakeN.x*.5+.5);\n        out_color += pow(dot(fakeN,normalize(vec3(1,1,-1)))*.5+.5,20.)*.2;\n    }\n\n    out_color = clamp(out_color, 0.,1.);\n\n    bool occluded = false;\n    vec3 lightCheckDir = normalize(candlePos-h);\n    t=0.;\n    h += n *.01;\n    h *= .995;\n    float lowestK = 1e9;\n    for(int i=0;i<32&&!occluded;++i)\n    {\n        float k = scene(h+lightCheckDir*t).x;\n        t += k;\n        lowestK = min(k,lowestK);\n        if (k<0.001)\n            occluded=true;\n        else if (t > distance(candlePos, h))\n            break;\n            }\n\n    if(!occluded)\n        out_color += vec4(1,.9,.1,1) * .3 * smoothstep(0.,.02,lowestK);\n\n    //out_color = vec4(n*.5+.5,0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}