{
    "Shader": {
        "info": {
            "date": "1688762228",
            "description": "Refraction and depth",
            "flags": 0,
            "hasliked": 0,
            "id": "mdsBDN",
            "likes": 2,
            "name": "Archipelago v2",
            "published": 3,
            "tags": [
                "fractal",
                "raymarch",
                "refraction"
            ],
            "usePreview": 0,
            "username": "Moumouke",
            "viewed": 203
        },
        "renderpass": [
            {
                "code": "\nfloat hash1(vec2 p) {\n\tp = 57.0 * fract(p * 1.4142135623);\n\treturn fract(p.x * p.y);\n}\n\nvec3 noised(vec2 x) {\n\tvec2 p = floor(x);\n\tvec2 w = fract(x);\n\tvec2 s = vec2(1.0, 0.0);\n\n\tfloat a = hash1(p + s.yy);\n\tfloat b = hash1(p + s.xy);\n\tfloat c = hash1(p + s.yx);\n\tfloat d = hash1(p + s.xx);\n\n\tfloat k0 = a;\n\tfloat k1 = b - a;\n\tfloat k2 = c - a;\n\tfloat k4 = a - b - c + d;\n\n\treturn vec3( -1.0 + 2.0 * (a + (b - a) * w.x + (c - a) * w.y + (a - b - c + d) * w.x * w.y), 2.0 * vec2(k1 + k4 * w.y, k2 + k4 * w.x));\n}\n\nfloat c01(float p) {\n\treturn clamp(p, 0.0, 1.0);\n}\n\nconst mat2 ma = mat2(\n\t 0.8,  0.6,\n\t-0.6,  0.8\n);\n\nconst mat2 mai = mat2( 0.80, -0.60,\n                       0.60,  0.80 );\n\n// https://iquilezles.org/articles/fbm/\nvec3 fbmd(vec2 x) {\n\tfloat f = 1.9;\n\tfloat s = 0.55;\n\tfloat a = 0.0;\n\tfloat b = 0.5;\n    mat2  m = mat2(1.0,0.0,0.0,1.0);\n\tvec2 d = vec2(0.0);\n\tfor (int i = 0; i < 7; i++) {\n\t\tvec2 offset = vec2(1.0, 1.5) * float(i);\n\t\tvec3 n = noised(x );\n\t\ta += b * n.x;\n\t\td += b * m * n.yz;\n\t\tb *= s;\n\t\tx = f * ma * x;\n        m = f*mai*m;\n\n\t}\n\treturn vec3(a, d);\n}\n\n\nvec3 sdfPlaned(vec3 p) {\n    vec3 n = fbmd(p.xz * 0.8) ;\n\treturn vec3(p.y + n.x, n.yz);\n}\n\nvec3 minSdfd(in vec3 a, in vec3 b) {\n\treturn a.x < b.x ? a : b;\n}\n\nvec3 sdfd(vec3 p) {\n\tvec3 a = sdfPlaned(p + vec3(10.0, 2.0, 10.0));\n\tvec3 b = vec3(abs(p.y + 1.7), 0.,0.);\n\treturn minSdfd(a, b);\n}\n\nvec3 raymarchd(vec3 rayOrigin, vec3 rayDirection) {\n\tfloat distance = 0.0;\n\tfloat maxDistance = 50.0;\n\tfloat minHitDistance = 0.001;\n\n\n\tfor (int i = 0; i < 256; i++) {\n\t\tif (distance > maxDistance) break;\n\n\t\tvec3 pos = rayOrigin + rayDirection * distance;\n\n\t\tvec3 res = sdfd(pos);\n\n\t\tif (res.x < minHitDistance) return vec3(distance + res.x, res.y, res.z);\n\n\t\tdistance += res.x * 0.4;\n\t}\n\n\treturn vec3(-1.0);\n}\n\nfloat shadow(vec3 ro, vec3 rd, float mint, float tmax) {\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor (int i = 0; i < 256; i++) {\n\t\tfloat h = sdfd(ro + rd * t).x;\n\n\t\tif (t > tmax) return res;\n\t\tif (h < 0.001) return 0.0;\n\t\tres = min(res, 18.0 * h / t);\n\t\tt += h;\n\t}\n\treturn res;\n}\n\nvec3 directionalLight(\n\tvec3 rayDirection,\n\tvec3 normal,\n\tvec3 point,\n\tvec3 baseColor,\n\tvec3 lightDir,\n\tvec3 lightColor,\n\tfloat shininess\n) {\n\tlightDir = normalize(lightDir);\n\tvec3 hal = normalize(lightDir - rayDirection);\n\tfloat diffuse = dot(normal, lightDir);\n\tdiffuse = c01(diffuse);\n\tdiffuse *= shadow(point, lightDir, 0.02, 2.5);\n\n\tfloat pho = c01(pow(dot(normal, hal), shininess));\n\tfloat spe = pho * diffuse * 0.3;\n\n\treturn baseColor * 2.2 * diffuse * lightColor + 5.0 * spe * lightColor * 0.4;\n\n}\n\nvec3 lightning(float distance, vec3 col, vec3 point, vec3 rayDirection, vec3 rayOrigin, vec3 normal) {\n\tvec3 newColor = col;\n\n\tnewColor += directionalLight(rayDirection, normal, point, col, vec3(2.0, 2.0, 2.0), vec3(0.902, 0.902, 0.902), 64.0);\n\tnewColor += directionalLight(rayDirection, normal, point, col, vec3(0.0, 2.0, 2.0), vec3(0.8392, 0.8078, 0.3529), 64.0);\n\tnewColor += directionalLight(rayDirection, normal, point, col, vec3(-2.0, 2.0, -1.5), vec3(0.8863, 0.3608, 0.3608), 64.0);\n\n\treturn newColor / 4.0;\n}\n\nvec3 render(vec3 rayOrigin, vec3 rayDirection) {\n\tvec3 col = vec3(0.0);\n\n\tvec3 hit = raymarchd(rayOrigin, rayDirection);\n\n\tif (hit.x > 0.0) {\n\t\tvec3 p = rayOrigin + rayDirection * hit.x;\n\t\tvec3 n = normalize(vec3(hit.y, 1., hit.z));\n\t\tfloat l = smoothstep(0.6, .8, n.y);\n\t\tif (hit.y == 0. && hit.z == 0.) {\n\t\t\tcol = vec3(0.1882, 0.1882, 0.5216);\n\t\t\tvec3 refracted = refract(rayDirection, n, .9);\n\t\t\tvec3 h2 = raymarchd(p + refracted * 0.01, refracted);\n\t\t\tvec3 n2 = normalize(vec3(h2.y, 1., h2.z));\n\t\t\tfloat l2 = smoothstep(0.6, .8, n2.y);\n\t\t\tcol = vec3(0.1882, 0.1882, 0.5216) * .7;\n\t\t\tcol +=  l2 * vec3(0.0392, 0.1294, 0.3137);\n\t\t\tcol /= 2.;\n\t\t\tcol = lightning(hit.x, col, p, rayDirection, rayOrigin, n);\n\t\t\tvec3 depthColor = vec3(0.1882, 0.1882, 0.5216);\n\t\t\tcol = mix(col, depthColor, c01(0.4+pow(h2.x, 1.3)));\n\t\t\t\n\t\t\t\n\t\t} else {\n\t\t\tcol = vec3(0.0941, 0.0784, 0.0275) * (1.-l) + l * vec3(0.0588, 0.1176, 0.0471);\n\t\t\tcol = lightning(hit.x, col, p, rayDirection, rayOrigin, n);\n\t\t}\n\t}\n\n\treturn col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tfloat time = iTime / 25.0 * 1.5;\n\n\tfloat camspeed = 7.0;\n\tvec3 ta = vec3(0.0, .0, .0);\n\tvec3 ro = vec3(1.2 , .8, .0);\n\tvec3 t = -vec3(iTime, 0., iTime);\n\n\tta +=t;\n\tro +=t;\n\n\tvec3 cf = normalize(ta-ro);\n\tvec3 cs = normalize(cross(cf, vec3(sin(0.0), cos(0.0), 0.0)));\n\tvec3 cu = normalize(cross(cs, cf));\n\n\tvec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 rd = normalize(p.x * cs + p.y * cu + 2.5 * cf);\n\n\tvec3 col = render(ro, rd);\n\tcol = pow(col, vec3(1.0 / 2.2));\n\n\tfragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}