{
    "Shader": {
        "info": {
            "date": "1672946684",
            "description": "An audio-reactive scene that maps the frequencies of the input music \n   and the audio volume to different cells, colors, size and intensity!",
            "flags": 64,
            "hasliked": 0,
            "id": "Dtj3zW",
            "likes": 61,
            "name": "3D Audio Visualizer #2",
            "published": 3,
            "tags": [
                "raymarching",
                "sound",
                "visualization",
                "reactive",
                "music",
                "live",
                "neon"
            ],
            "usePreview": 0,
            "username": "kishimisu",
            "viewed": 1845
        },
        "renderpass": [
            {
                "code": "/* @kishimisu - 2023\n\n   This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License (https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)\n\n   An audio-reactive scene that maps the frequencies of the input music \n   and the audio volume to different cells, colors, size and intensity!\n\n   I've been struggling to complete this scene as I wanted to repeat\n   the space with random variations for each cell. There's a wonderful\n   tutorial by Blackle Mori explaining how to achieve this (https://www.youtube.com/watch?v=I8fmkLK1OKg) ,\n   however I'm using an accumulation technique for the lighting with a\n   fixed number of steps (30) which gets broken with this new technique.\n   \n   I decided to keep a reasonable random variation amount to prevent having \n   raymarching artifacts that are too visible. I couldn't get totally rid of them,\n   however with this kind of audio reactive scene it seems to be more acceptable\n   as there's a lot of rapid movements!\n*/\n\n#define light(d, att) 1. / (1.+pow(abs(d*att), 1.3))\n#define rot(a) mat2(cos(a + vec4(0,33,11,0)))\n\n/* Audio-related functions */\n#define getLevel(x) (texelFetch(iChannel0, ivec2(int(x*512.), 0), 0).r)\n#define logX(x,a,c) (1./(exp(-a*(x-c))+1.))\nfloat logisticAmp(float amp){\n   float c = .88, a = 20.;  \n   return (logX(amp, a, c) - logX(0.0, a, c)) / (logX(1.0, a, c) - logX(0.0, a, c));\n}\nfloat getPitch(float freq, float octave){\n   freq = pow(2., freq)   * 261.;\n   freq = pow(2., octave) * freq / 12000.;\n   return logisticAmp(getLevel(freq));\n}\nfloat getVol(float samples) {\n    float avg = 0.;\n    for (float i = 0.; i < samples; i++) avg += getLevel(i/samples);\n    return avg / samples;\n}\n/* ----------------------- */\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat hash13(vec3 p3) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv   = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 col = vec3(.1,.0,.14);\n    float vol = getVol(8.);\n    \n    vec3 ro = vec3(0, 8, 12)*(1. + vol*.3);\n    ro.zx *= rot(iTime*.4);    \n    vec3 f = normalize(-ro), r = normalize(cross(vec3(0,1,0), f));\n    vec3 rd = normalize(f + uv.x*r + uv.y*cross(f, r));\n    \n    float hasSound = 1.; if (iChannelTime[0] <= 0.) hasSound = .4;\n    \n    for (float i = 0., t = 0.; i < 30.; i++) {\n        vec3 p  = ro + t*rd;        \n        \n        vec2 cen = floor(p.xz) + .5;\n        vec3 id = abs(vec3(cen.x, 0, cen.y));\n        float d = length(id);\n        \n        float freq = smoothstep(0., 20., d)*3.*hasSound + hash13(id)*2.;\n        float pitch = getPitch(freq, .7);\n        \n        float v  = vol*smoothstep(2., 0., d);\n        float h  = d*.2*(1.+pitch*1.5) + v*2.;\n        float me = sdBox(p - vec3(cen.x, -50., cen.y), vec3(.3, 50. + h, .3)+pitch) - .05;\n        \n        col += mix(mix(vec3(.8,.2,.4), vec3(0,1,0), min(v*2.,1.)), vec3(.5,.3,1.2), smoothstep(10., 30., d))\n               *(cos(id)+1.5)\n               * (pitch * d*.08 + v)\n               * light(me, 20.) * (1. + vol*2.);\n        \n        t += me;\n    }\n    \n    fragColor = vec4(col,1.0);   \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 31826,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/user-696655073-435379126/voidcall"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}