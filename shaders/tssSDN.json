{
    "Shader": {
        "info": {
            "date": "1551331495",
            "description": "boxes",
            "flags": 0,
            "hasliked": 0,
            "id": "tssSDN",
            "likes": 23,
            "name": "Hopping Boxes",
            "published": 3,
            "tags": [
                "3d",
                "box"
            ],
            "usePreview": 0,
            "username": "kaneta",
            "viewed": 800
        },
        "renderpass": [
            {
                "code": "// distance function by iq\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nvec3 opRep(vec3 p, vec3 c)\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n#define PI 3.141592\n\nvec2 map(vec3 p)\n{\n    float c = 0.05;\n    vec2 id = floor(p.xz / c);\n\n    vec2 b = vec2(9999., 0.0);\n    vec3 pp = p;\n    float t = iTime;\n    pp.xz = mod(pp.xz, c) - 0.5*c;\n \tfloat v = sin(t) * 0.5 + 0.5;\n   \tvec3 bp = vec3(sin(t) * 3.0, v * 5.0, cos(t) * 3.0);\n    for (int i = 0; i < 5; i++) {\n        float y = float(i) * c * 2.0;\n    \tvec3 cp = vec3(id.x, -y, id.y);\n    \tfloat s = clamp(pow(5.0 / distance(bp, cp), -6.0), 0.0, 1.0);\n        float by = (1.0 - s) * -0.4;\n        b = opU(b, vec2(sdBox(pp + vec3(0.0, by + y, 0.0), vec3(c * s * smoothstep(-0.4, -0.3,  by) * 0.5)), 1.0));\n    }\n    return b;\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 normal( in vec3 pos, float eps )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*map( pos + e.xyy ).x +\n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x +\n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x +\n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nvec3 materialize(vec3 p, vec3 ray, float depth, vec2 mat)\n{\n    vec3 ret = vec3(0.0);\n    vec3 nor = normal(p, 0.0001);\n    if (depth > 2000.0) {\n    \tret = vec3(0.0);\n    } else if (mat.y == 1.0) {\n    \tvec2 id = floor(p.xz / 0.05);\n        if (id.x == 3.0 && id.y == 0.0 && p.y >= 0.0) {\n            ret = vec3(nor.y, 0.0, 0.0) + nor.z * 0.3;\n        } else {\n            ret = vec3(nor.y) + nor.z * 0.3;\n        }\n    }\n    return ret;\n}\n\nvec3 trace(vec3 ro, vec3 ray)\n{\n    float t = 1.3;\n    vec3 col = vec3(0.0);\n    vec3 p;\n    vec2 m;\n    vec3 rdi = 1.0 / ray;\n    for(int i = 0; i < 60; i++) {\n    \tp = ray * t + ro;\n        m = map(p);\n        if (m.x < 0.001) {\n            break;\n        }\n        // grid traverse technique\n        // https://qiita.com/ukeyshima/items/221b0384d39f521cad8f\n        t += min(min((step(0.0,ray.x)-mod(p.x, 0.05)) * rdi.x, (step(0.0,ray.z)-mod(p.z, 0.05))*rdi.z)+0.001,m.x);\n    }\n    return materialize(p, ray, t, m);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 ro = vec3(1.0, 1.0, 1.0);\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    vec3 ray = camera(ro, ta, 0.0) * normalize(vec3(p, 7.5));\n    \n    vec3 col = trace(ro, ray);\n    p = fragCoord.xy / iResolution.xy;\n    p *=  1.0 - p.yx;\n    float vig = p.x*p.y * 30.0;\n    vig = pow(vig, 0.1);\n    \n    fragColor = vec4(col * vig,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}