{
    "Shader": {
        "info": {
            "date": "1662639843",
            "description": "First shader - yay! :)\n\nThis is very much based on this older shader by @fizzer: https://www.shadertoy.com/view/4slGz7\n",
            "flags": 0,
            "hasliked": 0,
            "id": "NttBR8",
            "likes": 5,
            "name": "Room Test 1",
            "published": 3,
            "tags": [
                "test1",
                "room"
            ],
            "usePreview": 0,
            "username": "voysys",
            "viewed": 248
        },
        "renderpass": [
            {
                "code": "#define EPS vec2(1e-3, 0.0)\n#define ON  vec2(1.0, 0.0)\n\nvec2 t;\nfloat time;\n\nvec3 rotateX(float a, vec3 v) {\n    return vec3(v.x, cos(a) * v.y + sin(a) * v.z, cos(a) * v.z - sin(a) * v.y);\n}\n\nvec3 rotateY(float a, vec3 v) {\n    return vec3(cos(a) * v.x + sin(a) * v.z, v.y, cos(a) * v.z - sin(a) * v.x);\n}\n\nvec2 cubeInterval(vec3 ro, vec3 rd) {\n    vec3 slabs0 = (vec3(+1.0) - ro) / rd;\n    vec3 slabs1 = (vec3(-1.0) - ro) / rd;\n\n    vec3 mins = min(slabs0, slabs1);\n    vec3 maxs = max(slabs0, slabs1);\n\n    return vec2(max(max(mins.x, mins.y), mins.z), min(min(maxs.x, maxs.y), maxs.z));\n}\n\nfloat N(vec2 p) {\n    p = mod(p, vec2(101.0));\n    return fract(sin(p.x * 41784.0) + sin(p.y * 32424.0));\n}\n\nfloat smN2(vec2 p) {\n    vec2 fp = floor(p);\n    vec2 pf = smoothstep(0.0, 1.0, fract(p));\n\n    return mix(mix(N(fp), N(fp + ON), pf.x), mix(N(fp + ON.yx), N(fp + ON.xx), pf.x), pf.y);\n}\n\nfloat smN3(vec3 p) {\n    vec2 o = vec2(111.0);\n    return mix(\n        smN2(p.xy + floor(p.z) * o), smN2(p.xy + (floor(p.z) + 1.0) * o), smoothstep(0.0, 1.0, fract(p.z)));\n}\n\nfloat fbm3(vec3 p) {\n    float f = 0.0, x;\n    for (int i = 1; i <= 7; ++i) {\n        x = exp2(float(i));\n        f += (smN3(p * x) - 0.5) / x;\n    }\n    return f;\n}\n\n#define fbm2(g) fbm3(vec3(g, 0.0))\n\nfloat pulse(float e0, float e1, float x) {\n    return step(e0, x) - step(e1, x);\n}\n\nfloat beam(float x) {\n    x = clamp(x, 0.0, 1.0);\n    return smoothstep(0.7, 1.0, pow(1.0 - 2.0 * abs(x - 0.5), 0.02));\n}\n\nfloat beamShadow(float x) {\n    x = clamp(x + 0.1, 0.0, 0.5);\n    return smoothstep(0.7, 1.0, pow(1.0 - 2.0 * abs(x - 0.5), 0.1));\n}\n\nvec3 wood(vec2 p) {\n    p += vec2(200.0);\n    p.x *= 1.2;\n    p.y *= 0.6;\n    return vec3(0.4, 0.25, 0.1) * (1.0 + fbm2(p));\n}\n\nvec3 crate(vec3 o, vec2 p) {\n    float shadow = mix(0.5, 1.0, smoothstep(0.0, 0.2, o.y + 1.0));\n\n    float innercoord = fract(p.x * 3.0);\n    vec2 outercoord = abs(p) * 3.0 - vec2(2.0);\n    float acrosscoord = min(0.3, abs(dot(p, vec2(1.0)))) * 8.0 - 2.0;\n\n    float inner = beam(innercoord);\n\n    float outers0 = beamShadow(outercoord.y);\n    float outers1 = beamShadow(outercoord.x);\n\n    float outerm0 = beam(outercoord.y);\n    float outerm1 = beam(outercoord.x);\n\n    float acrosss0 = 1.0 - beamShadow(acrosscoord);\n    float acrossm0 = 1.0 - beam(acrosscoord);\n\n    o += vec3(1e-2);\n\n    float stain =\n        (smoothstep(0.95, 1.0, fbm3(mod(o, vec3(5.01)) * 0.5) + 0.8 + fbm3(mod(o, vec3(5.01)) * 4.0) * 0.4));\n\n    float v = inner * (1.0 - acrosss0) + acrossm0;\n\n    v = v * (1.0 - outers1) + outerm1;\n\n    vec3 innercol = wood(vec2(p.x * 3.0, p.y)) * 0.76;\n    vec3 acrosscol = wood(vec2(dot(p, vec2(1.0)) * 3.0, p.x * 2.0));\n    vec3 outer0col = wood(p.yx * vec2(4.0, 1.4)) * vec3(1.0, 1.0, 0.9);\n    vec3 outer1col = wood(p.xy * vec2(4.0, 1.4));\n\n    vec3 col = mix(innercol, acrosscol, acrossm0);\n\n    col = mix(col, outer1col, outerm1);\n    col = mix(col, outer0col, outerm0);\n\n    float f = mix(0.5, 1.0, (1.0 - pow(abs(p.x), 30.0)) * (1.0 - pow(abs(p.y), 30.0)));\n\n    return shadow * (v * (1.0 - outers0) + outerm0) * col * f * mix(vec3(1.0), vec3(0.8, 0.7, 0.5), stain);\n}\n\nbool gridSolidity1(vec3 rp) {\n    rp = floor(rp);\n    return rp.y < (N(rp.xz * 2.0) * 10.0 - 20.0 / (1.0 + abs(rp.x)));\n}\n\nfloat groundSolidity(vec2 p) {\n    return gridSolidity1(vec3(p.x, -2.0, p.y)) ? 1.0 : 0.0;\n}\n\nfloat groundShadow(vec2 p) {\n    vec2 fp = floor(p);\n    vec2 pf = smoothstep(0.0, 1.0, fract(p));\n\n    return mix(\n        mix(groundSolidity(fp), groundSolidity(fp + ON), pf.x),\n        mix(groundSolidity(fp + ON.yx), groundSolidity(fp + ON.xx), pf.x),\n        pf.y);\n}\n\nvec3 stone(vec2 p) {\n    p += vec2(200.0);\n    p.x *= 1.2;\n    p.y *= 0.6;\n    return vec3(0.5, 0.5, 0.51) * smoothstep(0.0, 0.9, 1.0 + fbm2(p));\n}\n\nvec3 stoneFloor(vec3 o, vec2 p) {\n    float shadow = 1.0 - groundShadow(o.xz * 2.0 - vec2(0.5));\n    return fbm2(p * 4.0) * 0.1 +\n           shadow * mix(0.6, 0.65, smoothstep(0.0, 0.1, fbm2(o.xz * 2.0))) * vec3(0.7, 0.7, 0.8);\n}\n\nvec3 wall(vec3 o, vec2 p) {\n    float f = mix(0.5, 1.0, (1.0 - pow(abs(p.x), 30.0)) * (1.0 - pow(abs(p.y), 30.0)));\n\n    if (o.y < -0.99)\n        return stoneFloor(o, p) * f * 0.7;\n\n    float innercoord = fract(p.x * 7.0);\n    vec2 outercoord = abs(p) * 3.0 - vec2(2.0);\n    float acrosscoord = min(0.3, abs(dot(p, vec2(1.0)))) * 8.0 - 2.0;\n\n    float inner = beam(innercoord);\n\n    float outers0 = beamShadow(outercoord.y);\n\n    float outerm0 = beam(outercoord.y);\n\n    float g = pow(clamp((-o.y - 0.5) * 2.0, 0.0, 1.0), 2.0);\n\n    float stain = (smoothstep(\n        0.95, 1.0, fbm3(mod(o, vec3(5.0)) * 4.0) + 0.8 + g + fbm3(mod(o, vec3(5.0)) * 16.0) * 0.6));\n\n    vec3 innercol = stone(vec2(p.x, p.y) * 2.0) * 0.76;\n    vec3 outer0col = stone(p.yx * vec2(4.0, 1.4)) * vec3(1.0, 1.0, 0.9);\n\n    vec3 col = mix(innercol, outer0col, outerm0);\n\n    float fray = smoothstep(0.0, 0.5, stain) - smoothstep(0.5, 1.0, stain);\n\n    return vec3(fray) * 0.2 * (1.0 - outerm0) +\n           (inner * (1.0 - outers0) + outerm0) * col * f *\n               mix(vec3(1.0), vec3(0.5, 0.4, 0.3), 0.5 * stain * (1.0 - outerm0));\n}\n\nvec2 cubeProject(vec3 v) {\n    vec3 av = abs(v);\n\n    if (av.x > av.y && av.x > av.z)\n        return v.yz / av.x;\n    else if (av.y > av.x && av.y > av.z)\n        return v.xz / av.y;\n    else\n        return v.xy / av.z;\n}\n\nbool gridSolidity0(vec3 rp) {\n    if (rp.x < 2.0 && rp.y < -2.0)\n        return true;\n\n    vec2 wc = fract(rp.xy * 0.4);\n\n    float wires = pulse(-0.17, -0.1, 3.6 - sin(wc.x * 3.14159 * 2.0 + rp.z * 123.0) - wc.y * 4.0);\n\n    wires += pulse(-0.3, -0.1, 11.4 - sin(wc.x * 3.14159 * 2.0 + rp.z * 23.0) - wc.y * 16.0);\n\n    return (length(floor(rp.xy)) > 3.0) || ((wires * step(fract(rp.z), 1e-3) * step(1.0, rp.y)) > 0.0);\n}\n\nbool traverseUniformGridStep(vec3 ro, vec3 rd, vec3 increment, inout vec3 intersection, out float t) {\n    t = min(intersection.x, min(intersection.y, intersection.z));\n    vec3 rp = ro + rd * t;\n\n    intersection +=\n        increment * step(intersection.xyz, intersection.yxy) * step(intersection.xyz, intersection.zzx);\n\n    return gridSolidity0(rp);\n}\n\nfloat traverseUniformGrid(vec3 ro, vec3 rd) {\n    ro *= 2.0;\n    rd *= 2.0;\n\n    vec3 increment = vec3(1.0) / rd;\n    vec3 intersection = ((floor(ro) + round(rd * 0.5 + vec3(0.5))) - ro) * increment;\n    float t;\n\n    increment = abs(increment);\n    ro += rd * 1e-3;\n\n    for (int i = 0; i < 30; ++i) {\n        if (traverseUniformGridStep(ro, rd, increment, intersection, t)) {\n            return t;\n        }\n    }\n\n    return 100.0;\n}\n\nfloat look(float x) {\n    float c = floor(x);\n    return smoothstep(0.5, 1.0, 1.0 - abs(fract(x) - 0.5) * 2.0) * step(0.2, cos(mod(c, 20.0) * 3.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    t = uv * 2.0 - vec2(1.0);\n    t.x *= iResolution.x / iResolution.y;\n    time = iTime;\n\n    // pos (moves forward over time)\n    vec3 cp = vec3(0.3, -0.7 + pow(0.5, 0.7) * 0.01, time * 0.2);\n\n    // directional basis vectors (singularity straight up and down)\n    vec3 cw = vec3(0.0, 0.0, -1.0); // look-at dir\n    vec3 cu = normalize(cross(cw, vec3(0.0, 1.0, 0.0)));\n    vec3 cv = normalize(cross(cu, cw));\n\n    // matrix with the directional basis vectors\n    mat3 rm = mat3(cu, cv, cw);\n\n    vec3 ro = cp;\n    vec3 rd = rm * vec3(t.xy * 0.3, -0.25);\n\n    float t = traverseUniformGrid(ro, rd);\n\n    vec3 rp = ro + rd * t;\n    vec2 cc = cubeProject(rp * 2.0 - (floor(rp * 2.0) + vec3(0.5)));\n\n    vec3 col0 = wall(rp, cc);\n    vec3 col1 = crate(rp, cc);\n\n    float order = gridSolidity0(rp * 2.0 + rd * 1e-3) ? 0.0 : 1.0;\n\n    float nearest = t;\n\n    vec3 l =\n        vec3(0.01) +\n        vec3(\n            pow(1.0 - smoothstep(\n                          0.04, (2.0 - rp.y) * 0.15, distance(fract(rp.xz * 0.6 + vec2(0.0)), vec2(0.5))),\n                2.0) *\n            1.0 * clamp(1.0 - rp.y, 0.0, 1.0));\n\n    l += 0.8 * vec3(1.1, 1.1, 0.8);\n\n    vec3 col =\n        mix(col0, col1, order) * mix(vec3(0.02, 0.03, 0.1) * (3.0 - rp.y) * 0.2, vec3(1.2, 1.2, 1.0), l);\n\n    float v = 1.0 - pow(distance(uv, vec2(0.5)), 2.0) * 0.5;\n\n#if 1\n    vec3 fog = vec3(0.2, 0.2, 0.2) * 0.1;\n    fragColor.rgb = 1.5 * mix(fog, col, exp(-nearest * nearest * 0.01)) * v;\n#else\n    fragColor.rgb = col;\n#endif\n\n    fragColor.rgb *= 1.2;\n\n    fragColor.rgb += vec3(N(fragCoord.xy) * 0.005);\n    fragColor.a = 1.0;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}