{
    "Shader": {
        "info": {
            "date": "1682971790",
            "description": "Ray traversal of an extruded flagstone/asymmetric tiling\nEach step of the traversal computes the position and size of the current tile which is used for the intersection\n\nMouse drag to look around\nDefines in Common",
            "flags": 32,
            "hasliked": 0,
            "id": "cltGRl",
            "likes": 28,
            "name": "Extruded Flagstone Tiling 3D",
            "published": 3,
            "tags": [
                "3d",
                "raytracing",
                "grid",
                "box",
                "aa",
                "tiling",
                "fxaa",
                "taa",
                "asymmetric",
                "flagstone"
            ],
            "usePreview": 0,
            "username": "gelami",
            "viewed": 947
        },
        "renderpass": [
            {
                "code": "\n// Extruded Flagstone Filing - gelami\n// https://www.shadertoy.com/view/cltGRl\n\n/*\n * Ray traversal of an extruded flagstone/asymmetric tiling\n * \n * Each step of the traversal computes the position and size\n * of the current tile which is used for the intersection\n * \n * Mouse drag to look around\n * Defines in Common\n * \n * Kind of a sequel from my previous shader:\n * Colorful Rectangular Pillars - gelami\n * https://www.shadertoy.com/view/dtcGzX\n *\n * The tiling setup is from my old shader here:\n * Straight Flagstone Tiles - gelami\n * https://www.shadertoy.com/view/7tKGRc\n * \n * Anti-aliasing uses my TAA shader with an added CAS pass for sharpening\n * \n * TAA implementation from\n * Temporal AA Study - gelami\n * https://www.shadertoy.com/view/DsfGWX\n * \n * CAS implementation from\n * AMD FidelityFX: CAS - goingdigital\n * https://www.shadertoy.com/view/ftsXzM\n * \n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col;\n    \n    #ifdef TAA\n    col = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    \n    // CAS implementation from\n    // AMD FidelityFX: CAS - goingdigital\n    // https://www.shadertoy.com/view/ftsXzM\n    #ifdef CAS\n    col = CAS_Pass(iChannel0, uv, iChannelResolution[0].xy).rgb;\n    #endif\n    \n    #else\n    col = texelFetch(iChannel1, ivec2(fragCoord), 0).rgb;\n    #endif\n    \n    //col = smoothstep(vec3(0), vec3(1), col);\n    //col = ACESFilm(col);\n    fragColor = vec4(linearTosRGB(col), 1);\n    fragColor += (dot(hash23(vec3(fragCoord, iTime)), vec2(1)) - 0.5) / 255.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define TAA\n#define CAS\n\n#define MOTION\n#define WARPING\n\n#define ROUNDED\n#define RADIUS 0.06\n\n#define MIN_HEIGHT 0.05\n#define MAX_HEIGHT 8.0\n\n#define STEPS 256\n#define MAX_DIST 180.\n#define EPS 1e-4\n\n#define PI (acos(-1.))\n#define TAU (PI*2.)\n\n// CAS implementation from\n// AMD FidelityFX: CAS - goingdigital\n// https://www.shadertoy.com/view/ftsXzM\n\n#define CAS_FACTOR 0.0\n\nvec3 CAS_Pass(sampler2D tex, vec2 uv, vec2 size)\n{\n    // CAS algorithm\n    vec3 col = texture(tex, uv).rgb;\n    \n    float max_g = col.y;\n    float min_g = col.y;\n    \n    vec4 uvoff = vec4(1,0,1,-1) / size.xxyy;\n    vec3 colw;\n    vec3 col1 = texture(tex, uv+uvoff.yw).xyz;\n    max_g = max(max_g, col1.y);\n    min_g = min(min_g, col1.y);\n    colw = col1;\n    \n    col1 = texture(tex, uv+uvoff.xy).xyz;\n    max_g = max(max_g, col1.y);\n    min_g = min(min_g, col1.y);\n    colw += col1;\n    \n    col1 = texture(tex, uv+uvoff.yz).xyz;\n    max_g = max(max_g, col1.y);\n    min_g = min(min_g, col1.y);\n    colw += col1;\n    \n    col1 = texture(tex, uv-uvoff.xy).xyz;\n    max_g = max(max_g, col1.y);\n    min_g = min(min_g, col1.y);\n    colw += col1;\n    \n    float d_min_g = min_g;\n    float d_max_g = 1.-max_g;\n    float A;\n    \n    if (d_max_g < d_min_g) {\n        A = d_max_g / max_g;\n    } else {\n        A = d_min_g / max_g;\n    }\n    \n    A = sqrt(A);\n    A *= mix(-.125, -.2, CAS_FACTOR);\n    vec3 col_out = (col + colw * A) / (1.+4.*A);\n    \n    return col_out;\n}\n\n// Rounded box ray-intersection\n// https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat roundedboxIntersect( in vec3 pos, in vec3 ro, in vec3 rd, in vec3 size, in float rad )\n{\n    vec3 s = sign(pos);\n    ro  *= s;\n    rd  *= s;\n    pos *= s;\n    \n    // Faces\n    pos -= size;\n    pos = max( pos.xyz, pos.yzx );\n    if( min(min(pos.x,pos.y),pos.z) < 0.0 ) return 0.0;\n\n    vec3 oc = ro - size;\n    vec3 dd = rd*rd;\n    vec3 oo = oc*oc;\n    vec3 od = oc*rd;\n    float ra2 = rad*rad;\n\n    float t = MAX_DIST;\n    \n    // Corner\n    {\n        float b = od.x + od.y + od.z;\n        float c = oo.x + oo.y + oo.z - ra2;\n        float h = b*b - c;\n        if( h>0.0 ) t = - b -sqrt(h);\n    }\n    \n    vec3 a = dd.yzx + dd.zxy;\n    vec3 b = od.yzx + od.zxy;\n    vec3 c = oo.yzx + oo.zxy - ra2;\n    vec3 h = b*b - a*c;\n    \n    // Edge X\n    if( h.x>0.0 )\n    {\n        float ht = (-b.x - sqrt(h.x)) / a.x;\n        if( ht>0.0 && ht<t && abs(ro.x+rd.x*ht)<size.x ) t = ht;\n    }\n    \n    // Edge Y\n    if( h.y>0.0 )\n    {\n        float ht = (-b.y - sqrt(h.y)) / a.y;\n        if( ht>0.0 && ht<t && abs(ro.y+rd.y*ht)<size.y ) t = ht;\n    }\n    \n    // Edge Z\n    if( h.z>0.0 )\n    {\n        float ht = (-b.z - sqrt(h.z)) / a.z;\n        if( ht>0.0 && ht<t && abs(ro.z+rd.z*ht)<size.z ) t = ht;\n    }\n    \n    return t;\n}\n\nvec3 roundedboxNormal( in vec3 pos, in vec3 siz, in float rad )\n{\n    return sign(pos)*normalize(max(abs(pos)-siz,0.0));\n}\n\nmat3 getCameraMatrix(vec3 ro, vec3 lo)\n{\n    vec3 cw = normalize(lo - ro);\n    vec3 cu = normalize(cross(cw, vec3(0, 1, 0)));\n    vec3 cv = cross(cu, cw);\n\n    return mat3(cu, cv, cw);\n}\n\nfloat safeacos(float x) { return acos(clamp(x, -1.0, 1.0)); }\n\nfloat saturate(float x) { return clamp(x, 0., 1.); }\nvec2 saturate(vec2 x) { return clamp(x, vec2(0), vec2(1)); }\nvec3 saturate(vec3 x) { return clamp(x, vec3(0), vec3(1)); }\n\nfloat sqr(float x) { return x*x; }\nvec2 sqr(vec2 x) { return x*x; }\nvec3 sqr(vec3 x) { return x*x; }\n\nmat2 rot2D(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n// https://iquilezles.org/articles/smin/\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\n// https://iquilezles.org/articles/palettes/\nvec3 palette(float t)\n{\n    return 0.5 - 0.5 * cos(TAU * (vec3(0.8, 0.9, 0.9) * t + vec3(0.25, .5, 0)));\n}\n\n// Hash without Sine\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n#define coprimes vec2(2,3)\nvec2 halton (vec2 s)\n{\n  vec4 a = vec4(1,1,0,0);\n  while (s.x > 0. && s.y > 0.)\n  {\n    a.xy = a.xy/coprimes;\n    a.zw += a.xy*mod(vec2(s),coprimes);\n    s = floor(s/coprimes);\n  }\n  return a.zw;\n}\n\n// Taken from https://www.shadertoy.com/view/MtVGWz\nvec4 SampleTextureCatmullRom(sampler2D tex, vec2 texSize, vec2 uv)\n{\n    // We're going to sample a a 4x4 grid of texels surrounding the target UV coordinate. We'll do this by rounding\n    // down the sample location to get the exact center of our \"starting\" texel. The starting texel will be at\n    // location [1, 1] in the grid, where [0, 0] is the top left corner.\n    vec2 samplePos = uv * texSize;\n    vec2 texPos1 = floor(samplePos - 0.5) + 0.5;\n\n    // Compute the fractional offset from our starting texel to our original sample location, which we'll\n    // feed into the Catmull-Rom spline function to get our filter weights.\n    vec2 f = samplePos - texPos1;\n\n    // Compute the Catmull-Rom weights using the fractional offset that we calculated earlier.\n    // These equations are pre-expanded based on our knowledge of where the texels will be located,\n    // which lets us avoid having to evaluate a piece-wise function.\n    vec2 w0 = f * ( -0.5 + f * (1.0 - 0.5*f));\n    vec2 w1 = 1.0 + f * f * (-2.5 + 1.5*f);\n    vec2 w2 = f * ( 0.5 + f * (2.0 - 1.5*f) );\n    vec2 w3 = f * f * (-0.5 + 0.5 * f);\n    \n    // Work out weighting factors and sampling offsets that will let us use bilinear filtering to\n    // simultaneously evaluate the middle 2 samples from the 4x4 grid.\n    vec2 w12 = w1 + w2;\n    vec2 offset12 = w2 / w12;\n\n    // Compute the final UV coordinates we'll use for sampling the texture\n    vec2 texPos0 = texPos1 - vec2(1.0);\n    vec2 texPos3 = texPos1 + vec2(2.0);\n    vec2 texPos12 = texPos1 + offset12;\n\n    texPos0 /= texSize;\n    texPos3 /= texSize;\n    texPos12 /= texSize;\n\n    vec4 result = vec4(0.0);\n    result += texture(tex, vec2(texPos0.x,  texPos0.y)) * w0.x * w0.y;\n    result += texture(tex, vec2(texPos12.x, texPos0.y)) * w12.x * w0.y;\n    result += texture(tex, vec2(texPos3.x,  texPos0.y)) * w3.x * w0.y;\n\n    result += texture(tex, vec2(texPos0.x,  texPos12.y)) * w0.x * w12.y;\n    result += texture(tex, vec2(texPos12.x, texPos12.y)) * w12.x * w12.y;\n    result += texture(tex, vec2(texPos3.x,  texPos12.y)) * w3.x * w12.y;\n\n    result += texture(tex, vec2(texPos0.x,  texPos3.y)) * w0.x * w3.y;\n    result += texture(tex, vec2(texPos12.x, texPos3.y)) * w12.x * w3.y;\n    result += texture(tex, vec2(texPos3.x,  texPos3.y)) * w3.x * w3.y;\n\n    return result;\n}\n\nvec2 getJitter(vec2 pos, int frame)\n{\n    pos = floor(pos);\n    return halton(vec2(frame%8+1)) - .5;\n}\n\nvec3 getLookAtPos(float time)\n{\n    return vec3(0, 6, time * 2.0);\n}\n\nfloat getHeightMotion(vec2 p, float time, sampler2D tex, vec2 size)\n{\n    float r = texture(tex, 0.2 * p / size).y;\n    return (saturate(sin((r + time * 0.5) * TAU)*0.8+0.5)-0.5)*0.2;\n}\n\nvec3 sRGBToLinear(vec3 col)\n{\n    return mix(pow((col + 0.055) / 1.055, vec3(2.4)), col / 12.92, lessThan(col, vec3(0.04045)));\n}\n\nvec3 linearTosRGB(vec3 col)\n{\n    return mix(1.055 * pow(col, vec3(1.0 / 2.4)) - 0.055, col * 12.92, lessThan(col, vec3(0.0031308)));\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 sp = ivec2(fragCoord);\n    \n    if (sp.x >= 2 || sp.y > 0)\n    {\n        fragColor = vec4(0, 0, 0, 1);\n        return;\n    }\n    \n    vec3 ro = vec3(0, 0, 18);\n    vec3 lo = getLookAtPos(iTime);\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    float ax = iMouse.z < 0. || iMouse.x == 0. ? -PI * .7 + iTime * .2 : -m.x * TAU;\n    float ay = iMouse.z < 0. || iMouse.y == 0. ? PI * 0.2 : -m.y * PI + PI * 0.5;\n    \n    ro.yz *= rot2D(ay);\n    ro.xz *= rot2D(ax);\n    ro += lo;\n    \n    if (sp.x == 0)\n        fragColor = vec4(ro, 1);\n    else if (sp.x == 1)\n        fragColor = texelFetch(iChannel0, ivec2(0, 0), 0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n// Fork of \"Gelami Raymarching Template\" by gelami. https://shadertoy.com/view/mslGRs\n// 2023-05-01 11:08:18\n\nfloat getHeight(vec2 p)\n{\n    float h = texture(iChannel0, 0.2 * p / iChannelResolution[0].xy).x;\n    return smoothstep(0.3, 0.8, h)*0.8+0.1;\n}\n\nfloat map(vec2 p)\n{\n    float h = getHeight(p);\n    \n    #ifdef MOTION\n    h += getHeightMotion(p, iTime, iChannel0, iChannelResolution[0].xy);\n    #endif\n    \n    return clamp(h * MAX_HEIGHT, MIN_HEIGHT, MAX_HEIGHT);\n}\n\n// \n// https://www.shadertoy.com/view/7tKGRc\nfloat randSpan( vec2 p )\n{\n    vec4 r = texelFetch(iChannel1, ivec2(mod(p, 256.0)), 0);\n    #ifdef WARPING\n    return (sin((iTime * 0.4 + r.x) * TAU)*0.5+0.5)*0.7+0.15;\n    #else\n    return r.x*0.7+0.15;\n    #endif\n}\n\n// Returns size and offset position\nvec4 getTile(vec2 id)\n{\n    bool ch = mod(id.x + id.y, 2.) > .5;\n    \n    // Get the random spans\n    float r00 = randSpan(id + vec2(0, 0));\n    float r10 = randSpan(id + vec2(1, 0));\n    float r01 = randSpan(id + vec2(0, 1));\n    float r11 = randSpan(id + vec2(1, 1));\n    \n    // Tile Size\n    vec2 s0 = ch ? vec2(r00, r10) : vec2(r01, r00);\n    vec2 s1 = ch ? vec2(r11, r01) : vec2(r10, r11);\n    vec2 s = 1. - s0 + s1;\n    \n    return vec4(s * 0.5, s0);\n}\n\nvec2 getTileID(vec2 p)\n{\n    vec2 fl = floor(p);\n    vec2 fr = p - fl;\n    \n    bool ch = mod(fl.x + fl.y, 2.) > .5;\n    \n    float r1 = randSpan(fl);\n    vec2 ax = ch ? fr.xy : fr.yx;\n    \n    float a1 = ax.x - r1;\n    float si = sign(a1);\n    vec2 o1 = ch ? vec2(si, 0) : vec2(0, si);\n    \n    float r2 = randSpan(fl + o1);\n    float a2 = ax.y - r2;\n    \n    vec2 st = step(vec2(0), vec2(a1, a2));\n    \n    // Tile ID\n    vec2 of = ch ? st.xy : st.yx;\n    vec2 id = fl + of - 1.;\n    \n    return floor(id);\n}\n\nbool trace(vec3 ro, vec3 rd, out float t, out vec2 tp, out vec3 normal)\n{\n    if ((ro.y > MAX_HEIGHT && rd.y > 0.0) || (ro.y < MIN_HEIGHT && rd.y > 0.0))\n        return false;\n    \n    tp = getTileID(ro.xz);\n    \n    //if (ro.y < map(tp))\n    //    return false;\n    \n    vec3 ird = 1.0 / rd;\n    vec3 srd = sign(rd);\n    vec3 ard = abs(ird);\n    \n    vec3 iro = ro * ird;\n    \n    t = MAX_DIST;\n    normal = vec3(-1);\n    \n    int i = 0;\n    for (; i < STEPS; i++)\n    {\n        float d = map(tp) * 0.5;\n        \n        vec4 tsp = getTile(tp);\n        \n        vec3 p = vec3(tp.x + tsp.z + tsp.x, d, tp.y + tsp.w + tsp.y);\n        vec3 s = vec3(tsp.x, d, tsp.y);\n        vec3 n = iro - p * ird;\n        vec3 k = ard * s;\n        \n        vec3 t1 = -n - k;\n        vec3 t2 = -n + k;\n        \n        float tN = max(max(t1.x, t1.y), t1.z);\n        float tF = min(min(t2.x, t2.y), t2.z);\n        \n        vec3 pos = ro + rd * (tN + EPS);\n        \n        if (pos.y > MAX_HEIGHT && rd.y > 0.0)\n            return false;\n        \n        if (tN < tF && tN >= 0.0)\n        {\n            if (tN > MAX_DIST)\n                return false;\n            \n            #ifndef ROUNDED\n            t = tN;\n            normal = -srd * step(t1.yzx, t1) * step(t1.zxy, t1);\n            return true;\n            \n            #else\n            \n            const float rad = RADIUS;\n            \n            if (d < MIN_HEIGHT + rad)\n            {\n                t = tN;\n                normal = -srd * step(t1.yzx, t1) * step(t1.zxy, t1);\n                return true;\n            }\n            \n            vec3 o = p;\n            vec3 rp = ro - o;\n            vec3 rs = max(s-rad, vec3(0));\n            float rt = roundedboxIntersect(pos - o, rp, rd, rs, rad);\n            if (rt != MAX_DIST)\n            {\n                t = rt == 0.0 ? tN : rt;\n                vec3 pos = rp + rd * t;\n                normal = normalize(roundedboxNormal(pos, rs, rad));\n                return true;\n            }\n            #endif\n        }\n        \n        float dt;\n        vec2 st;\n        if (t2.x <= t2.z)\n        {\n            dt = t2.x;\n            st = vec2(1, 0);\n        } else\n        {\n            dt = t2.z;\n            st = vec2(0, 1);\n        }\n        \n        // Hacky way to get next tile ID v_v\n        // Ideally you would only check the neighboring span\n        // to pick which one from the two neighbors to advance to\n        //tp = getTileID(ro.xz + rd.xz * (min(t2.x, t2.z) + 1e-3) + step(t2.xz, t2.zx) * srd.xz * 5e-3);\n        tp = getTileID(ro.xz + rd.xz * (dt + 1e-3) + st * srd.xz * 5e-3);\n        //tp += st * srd.xz;\n    }\n    \n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o = getJitter(fragCoord, iFrame);\n    vec2 ndc = (2. * (fragCoord + o) - iResolution.xy) / iResolution.y;\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 ro = texelFetch(iChannel3, ivec2(0, 0), 0).rgb;\n    vec3 lo = getLookAtPos(iTime);\n\n    mat3 cmat = getCameraMatrix(ro, lo);\n\n    vec3 rd = normalize(cmat * vec3(ndc, 2));\n\n    vec3 col = vec3(0);\n    \n    float t;\n    vec2 tp;\n    vec3 n;\n    bool hit = trace(ro, rd, t, tp, n);\n    \n    if (!hit) t = MAX_DIST;\n    \n    vec3 pos = ro + rd * t;\n    \n    vec3 ldir = normalize(vec3(1, 2, 0.9));\n    \n    float lt;\n    vec2 ltp;\n    vec3 ln;\n    bool lhit = trace(pos + n * EPS, ldir, lt, ltp, ln);\n    \n    float dif = max(dot(n, ldir), 0.0) * float(!lhit);\n    float bou = max(dot(-reflect(n, rd), ldir), 0.0);\n    \n    float r = getHeight(tp);\n    \n    col = palette(hash12(tp));\n    col *= vec3(1, 0.45, 0.08);\n    \n    float h = map(tp);\n    \n    vec3 bcol = vec3(1.2, 1, 0.8);\n    vec2 br = hash22(-tp.yx);\n    if (n.y == 0.0 && br.x < 0.1)\n    {\n        if (br.y < 0.5)\n        {\n            col = mix(col, bcol, step(fract(0.5 + (1.0-pos.y / h) * 1.2*ceil(r * MAX_HEIGHT)), 0.5));\n        } else\n        {\n            vec4 tsp = getTile(tp);\n            vec2 ww = 0.5 + 0.4999 * (pos.xz - tp - tsp.zw - tsp.xy) / tsp.xy;\n            ww = step(fract(ww * 2.0 - 0.25), vec2(0.5));\n            \n            col = mix(col, bcol, abs(n.x) > 0.5 ? ww.y : ww.x);\n        }\n    }\n    \n    col *= dot(abs(n), vec3(0.8, 1, 0.9));\n    col *= smoothstep(MIN_HEIGHT, MAX_HEIGHT*0.8, pos.y)*0.75+0.25;\n    \n    col *= dif + 0.15 + bou*0.15;\n    \n    vec3 ref = textureLod(iChannel2, reflect(rd, n), 2.0).rgb * palette(hash12(tp.yx));\n    ref *= vec3(1, 0.45, 0.08);\n    \n    float r0 = 0.05;\n    float fre = r0 + (1.0 - r0) * pow(1.0 - max(dot(-rd, n), 0.0), 5.0);\n    \n    col = mix(col, ref, fre * 0.8);\n    \n    vec3 sky = vec3(0.9, 0.6, 1);\n    \n    float fog = 1.0 - exp(-max(t - 30.0, 0.0) * 0.008);\n    col = mix(col, vec3(0.9, 0.6, 1), fog);\n    \n    col = mix(col, sky, smoothstep(MAX_DIST*0.9, MAX_DIST, t));\n    //if (t >= MAX_DIST)\n    //    col = rd;\n    \n    col = max(col, vec3(0));\n    col = col / (1. + col);\n    \n    fragColor = vec4(col, t);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n// TAA implementation from\n// Temporal AA Study - gelami\n// https://www.shadertoy.com/view/DsfGWX\n\n#if 0\n#define OFFSET_COUNT 8\n\nconst ivec2 off[OFFSET_COUNT] = ivec2[OFFSET_COUNT](\n    ivec2(-1, -1), ivec2(-1,  1), \n\tivec2( 1, -1), ivec2( 1,  1), \n\tivec2( 1,  0), ivec2( 0, -1), \n\tivec2( 0,  1), ivec2(-1,  0)\n);\n\n#else\n#define OFFSET_COUNT 4\n\nconst ivec2 off[OFFSET_COUNT] = ivec2[OFFSET_COUNT](\n \tivec2( 1,  0), ivec2( 0, -1), \n\tivec2( 0,  1), ivec2(-1,  0)\n);\n#endif\n\nvec3 RGBtoYCoCg(vec3 c)\n{\n    return mat3(0.25, 0.5, -0.25, 0.5, 0, 0.5, 0.25, -0.5, -0.25) * c;\n}\n\nvec3 YCoCgToRGB(vec3 c)\n{\n    return mat3(1, 1, 1, 1, 0, -1, -1, 1, -1) * c;\n}\n\n// From https://github.com/playdeadgames/temporal/blob/master/Assets/Shaders/TemporalReprojection.shader\nvec3 clipToAABB(in vec3 cOld, in vec3 cNew, in vec3 center, in vec3 halfSize)\n{\n// Clip towards AABB center\n#if 0\n    vec3 o = cOld - center;\n    vec3 v = o / halfSize;\n    vec3 a = abs(v);\n    float t = max(a.x, max(a.y, a.z));\n    \n    if (t > 1.)\n        return cNew + o / t;\n    else\n        return cOld;\n#else\n    vec3 r = cOld - cNew;\n    vec3 m = (center + halfSize) - cNew;\n    vec3 n = (center - halfSize) - cNew;\n    \n    if (r.x > m.x + EPS)\n\t\tr *= (m.x / r.x);\n\tif (r.y > m.y + EPS)\n\t\tr *= (m.y / r.y);\n\tif (r.z > m.z + EPS)\n\t\tr *= (m.z / r.z);\n\n\tif (r.x < n.x - EPS)\n\t\tr *= (n.x / r.x);\n\tif (r.y < n.y - EPS)\n\t\tr *= (n.y / r.y);\n\tif (r.z < n.z - EPS)\n\t\tr *= (n.z / r.z);\n\n\treturn cNew + r;\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float a = .1;\n    \n    ivec2 sp = ivec2(fragCoord);\n    \n    vec2 o = getJitter(fragCoord, iFrame);\n    \n    vec2 ndc = (2. * (fragCoord) - iResolution.xy) / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec4 curr = texture(iChannel0, (fragCoord - o) / iResolution.xy);\n\n    vec3 new = RGBtoYCoCg(curr.rgb);\n    \n    vec3 ro = texelFetch(iChannel2, ivec2(0, 0), 0).rgb;\n    vec3 pro = texelFetch(iChannel2, ivec2(1, 0), 0).rgb;\n    \n    vec3 lo = getLookAtPos(iTime);\n    vec3 plo = getLookAtPos(iTime - iTimeDelta);\n    \n    mat3 cmat = getCameraMatrix(ro, lo);\n    mat3 pmat = getCameraMatrix(pro, plo);\n\n    vec3 rd = normalize(cmat * vec3(ndc, 2));\n\n    vec3 p = ro + rd * curr.a;\n    \n    #ifdef MOTION\n    vec2 tp = floor(p.xz);\n    float h0 = getHeightMotion(tp, iTime, iChannel3, iChannelResolution[3].xy);\n    float h1 = getHeightMotion(tp, iTime - iTimeDelta, iChannel3, iChannelResolution[3].xy);\n    \n    p.y += (h1 - h0);\n    #endif\n    \n    vec3 cp = (p - pro) * pmat;\n    vec2 np = 2. * cp.xy / cp.z;\n    vec2 puv = np * vec2(iResolution.y / iResolution.x, 1) * .5 + .5;\n    \n    //vec4 hist = texture(iChannel1, puv);\n    vec4 hist = SampleTextureCatmullRom(iChannel1, iResolution.xy, puv);\n    \n    vec3 old = RGBtoYCoCg(hist.rgb);\n    \n    vec3 avg = new;\n    vec3 var = new * new;\n    \n    for (int i = 0; i < OFFSET_COUNT; i++)\n    {\n        vec3 tex = RGBtoYCoCg(texelFetch(iChannel0, sp + off[i], 0).rgb);\n    \n        avg += tex;\n        var += tex * tex;\n    }\n    avg /= float(OFFSET_COUNT + 1);\n    var /= float(OFFSET_COUNT + 1);\n\n    vec3 sig = sqrt(max(var - avg * avg, vec3(0)));\n    \n    const float g = 1.0;\n    vec3 cmin = avg - sig * g;\n    vec3 cmax = avg + sig * g;\n    \n    vec3 clip = clipToAABB(old, clamp(avg, cmin, cmax), avg, sig);\n    \n    vec3 col = iFrame != 0 ? mix(clip, new, a) : new;\n    \n    fragColor = vec4(saturate(YCoCgToRGB(col)), curr.a);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}