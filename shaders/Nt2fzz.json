{
    "Shader": {
        "info": {
            "date": "1651727560",
            "description": "it is so",
            "flags": 32,
            "hasliked": 0,
            "id": "Nt2fzz",
            "likes": 0,
            "name": "blur tests",
            "published": 3,
            "tags": [
                "hmmm"
            ],
            "usePreview": 0,
            "username": "vinvinvin",
            "viewed": 221
        },
        "renderpass": [
            {
                "code": "vec2 computeDistortedUV( vec2 uv, float k, float kcube ){\n    \n    vec2 t = uv - .5;\n    float r2 = t.x * t.x + t.y * t.y;\n\tfloat f = 0.;\n    \n    if( kcube == 0.0){\n        f = 1. + r2 * k;\n    }else{\n        f = 1. + r2 * ( k + kcube * sqrt( r2 ) );\n    }\n    \n    vec2 nUv = f * t + .5;\n\n    return nUv;\n    \n} \n\nfloat sat( float t )\n{\n\treturn clamp( t, 0.0, 1.0 );\n}\n\nfloat linterp( float t ) {\n\treturn sat( 1.0 - abs( 2.0*t - 1.0 ) );\n}\n\nfloat remap( float t, float a, float b ) {\n\treturn sat( (t - a) / (b - a) );\n}\n\nvec2 barrelDistortion(vec2 coord, float amt) {\n\tvec2 cc = coord - 0.5;\n\tfloat dist = dot(cc, cc);\n\treturn coord + cc * dist * amt;\n}\n\nvec4 spectrum_offset( float t ) {\n\tvec4 ret;\n\tfloat lo = step(t,0.5);\n\tfloat hi = 1.0-lo;\n\tfloat w = linterp( remap( t, 1.0/6.0, 5.0/6.0 ) );\n\tret = vec4(lo,1.0,hi, 1.) * vec4(1.0-w, w, 1.0-w, 1.);\n\n\treturn pow( ret, vec4(1.0/2.2) );\n}\n\n//Vignette parameters:\n\n//Inner radius\n#define inner .5\n//Outer radius\n#define outer 1.2\n//Vignette strength/intensity\n#define strength .3\n//Vignette roundness, higher = smoother, lower = sharper\n#define curvature .9\n//=============//\n // Final Blend //\n//=============//\n\nvoid mainImage(out vec4 color, vec2 coord) {\n\tvec2 uv = coord / iResolution.xy;\n    \n    vec4 original = texture(iChannel0, uv);\n    \n    uv = scale_uv(uv, vec2(RENDER_SCALE), vec2(0.5));\n    // vec4 blurred = texture(iChannel1, uv);\n    // blurred = pow(blurred, vec4(1.0 / GAMMA));\n        \n    float k = DISTORT_AMOUNT;\n    float kcube = 0.0;\n    \n    // float offset = .1 * sin( iTime * .5 );\n    \n    uv = ((uv - 0.5) * (1.0 - (ZOOM_AMOUNT))) + 0.5;\n    vec4 blurred = texture( iChannel1, computeDistortedUV( uv, k, kcube ) );\n        \n    const int num_iter = 12;\n    const float reci_num_iter_f = 1.0 / float(num_iter);\n    // We want to tone down the chromatic abberation on higher resolutions\n    float max_distort = 0.15 * TO_1_AMOUNT * (1120.0 / iResolution.x);\n    \n\tvec4 sumcol = vec4(0.0);\n\tvec4 sumw = vec4(0.0);\t\n\tfor ( int i=0; i<num_iter;++i )\n\t{\n\t\tfloat t = float(i) * reci_num_iter_f;\n\t\tvec4 w = spectrum_offset(t);\n\t\tsumw += w;\n\t\t// sumcol += w * texture( iChannel0, uv );\n        sumcol += w * texture( iChannel1, barrelDistortion(computeDistortedUV( uv, k, kcube ), .6 * max_distort*t ));\n\t}\t\n\tblurred = sumcol / sumw;\n    // blurred = pow(blurred, vec4(1.0 / (ADJUSTED_GAMMA * 2.5)));\n    blurred = pow(blurred, vec4(1.0 / ADJUSTED_GAMMA));\n    \n    color = mix(original, blurred, 1.0);\n\n    \n        \n    //Calculate edge curvature\n    vec2 curve = pow(abs(uv*2.-1.),vec2(1./curvature));\n    //Compute distance to edge\n    float edge = pow(length(curve),curvature);\n    //Compute vignette gradient and intensity\n    float vignette = 1.-strength*(TO_1_AMOUNT)*smoothstep(inner,outer,edge);\n    \n    //Add vignette to the resulting texture\n    color.rgb *= vignette;\n    //color = texture(iChannel2, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n    Doom 2016 does a fast real-time Bokeh\n    where the half-resolution framebuffer\n    is blurred with a circular average\n    (tapped fragments in a circular pattern,\n    no Gaussian used) and then a second blur\n    is performed where the colours are\n    blended with a colour \"max\" operation\n    (brightest RGB components kept).\n*/\n\n  //========//\n // Macros //\n//========//\n\n#define BLUR_AMOUNT (iMouse.z > 0.0 ? (iMouse.x / iResolution.x) * 5.0 : 1.8)\n#define DISTORT_AMOUNT (iMouse.z > 0.0 ? (iMouse.x / iResolution.x) * 0.0 : 0.0)\n#define ZOOM_AMOUNT (iMouse.z > 0.0 ? (iMouse.x / iResolution.x) * 0.05 : 0.05)\n#define TO_1_AMOUNT (iMouse.z > 0.0 ? (iMouse.x / iResolution.x) * 1.0 : 1.0)\n// #define BLUR_AMOUNT (iMouse.z > 0.0 ? (iMouse.x / iResolution.x) * 1.8 : 1.8)\n// #define DISTORT_AMOUNT (iMouse.z > 0.0 ? (iMouse.x / iResolution.x) * 1.0 : 1.2)\n// #define ZOOM_AMOUNT (iMouse.z > 0.0 ? (iMouse.x / iResolution.x) * 0.25 : 0.25)\n\n  //===========//\n // Constants //\n//===========//\n\nconst float PI = 3.14159;\nconst float GAMMA = 3.5;\n\n//#define ADJUSTED_GAMMA (iMouse.z > 0.0 ? GAMMA * (1.0 - (pow((iMouse.x / iResolution.x), 0.5) * 0.4)) : GAMMA)\n#define ADJUSTED_GAMMA GAMMA\n// We adjust the gamma on pass \nconst float PASS_2_GAMMA_DENOM = 0.2;\n// Make the effect of larger side swirls decrease with increased size\n#define SWIRL_SIZE_EXP (-0.9 * pow(max((3.0 - BLUR_AMOUNT) / 3.0, 0.0), 1.5))\n\n\nconst float RENDER_SCALE = 0.9;\n//const float BLUR_AMOUNT = 1.0;\n\nconst int BOX_BLUR_SAMPLES = 1;\nconst float BOKEH_ASPECT_RATIO = 1.25;\nconst vec2 BOX_BLUR_SCALE = vec2(2);\nconst vec2 BOX_BLUR_OFFSET = float(BOX_BLUR_SAMPLES / 2) * BOX_BLUR_SCALE;\nconst float BOX_BLUR_ACCUM = 1.0 / float(BOX_BLUR_SAMPLES);\n\n  //===========//\n // Functions //\n//===========//\n\nvec2 scale_uv(vec2 uv, vec2 scale, vec2 center) {\n    return (uv - center) * scale + center;\n}\n\nvec4 box_blur(sampler2D sp, vec2 uv, vec2 dir) {\n\tvec4 result = vec4(0.0);\n    uv -= dir * BOX_BLUR_OFFSET;\n    \n    for (int i = 0; i < BOX_BLUR_SAMPLES; ++i) {\n        result += texture(sp, uv);\n        uv += dir * BOX_BLUR_SCALE;\n    }\n    result *= vec4(BOX_BLUR_ACCUM);\n    \n    return result;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "vec2 computeDistortedUV( vec2 uv, float k, float kcube ){\n    \n    vec2 t = uv - .5;\n    float r2 = t.x * t.x + t.y * t.y;\n\tfloat f = 0.;\n    \n    if( kcube == 0.0){\n        f = 1. + r2 * k;\n    }else{\n        f = 1. + r2 * ( k + kcube * sqrt( r2 ) );\n    }\n    \n    vec2 nUv = f * t + .5;\n    nUv.y = 1. - nUv.y;\n \n    return nUv; \n}\n\n\n //===============//\n // Preprocessing //\n//===============//\n\nvoid mainImage(out vec4 color, vec2 coord) {\n\tvec2 ps = vec2(1) / iResolution.xy;\n    vec2 uv = coord * ps;\n    \n    uv = scale_uv(uv, vec2(1.0 / RENDER_SCALE), vec2(0.5));\n    \n\tcolor = texture( iChannel0, uv );\n    \n    // vec2 uv=(gl_FragCoord.xy/resolution.xy*.5)+.25;\n\n    \n    // vinhowe: threshold some highlights. a lot of this is just guessing and trying things.\n    \n    float luminance = 0.2126*color.r + 0.7152*color.g + 0.0722*color.b;\n    if (luminance > 0.8) {\n        color = mix(color, pow(color, 1.0 / vec4(1.4)), min(BLUR_AMOUNT / 0.8, 1.0));\n    }\n    color = pow(color, vec4(ADJUSTED_GAMMA));\n    \n   \n\n    // float mixValue = ZOOM_AMOUNT;\n    // color.rgb *= max(1.0 - mixValue, 0.0);\n    // color.rgb += vec3(0.1, 0.1, 0.1) * mixValue;\n    // color.rgb = min((color.rgb * (1.0 + (ZOOM_AMOUNT * 30.0))) + (ZOOM_AMOUNT * 0.1), vec3(1.0, 1.0, 1.0));\n    // color.rgb = mix(color.rgb, vec3(0.05, 0.05, 1.0), max(min(((0.5-uv.y) + 0.5)*ZOOM_AMOUNT, 1.0), 0.0));\n    // color.b *= 1.0 + (ZOOM_AMOUNT * 1.0);\n    // color.rgb += vec3(0.05, 0.05, 0.06) * ZOOM_AMOUNT;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "  //=================//\n // First Blur Pass //\n//=================//\n\nconst vec2 OFFSETS[] = vec2[](\n    vec2(0.0, 0.0),\n    vec2(1.5, 0.0),\n    vec2(0.46, 1.43),\n    vec2(-1.21, 0.88),\n    vec2(-1.21, -0.88),\n    vec2(0.46, -1.43),\n    vec2(3.0, 0.0),\n    vec2(2.43, 1.76),\n    vec2(0.93, 2.85),\n    vec2(-0.93, 2.85),\n    vec2(-2.43, 1.76),\n    vec2(-3.0, 0.0),\n    vec2(-2.43, -1.76),\n    vec2(-0.93, -2.85),\n    vec2(0.93, -2.85),\n    vec2(2.43, -1.76)\n);\n\nvec2 computeDistortedUV( vec2 uv, float k, float kcube ){\n    \n    vec2 t = uv - .5;\n    float r2 = t.x * t.x + t.y * t.y;\n\tfloat f = 0.;\n    \n    if( kcube == 0.0){\n        f = 1. + r2 * k;\n    }else{\n        f = 1. + r2 * ( k + kcube * sqrt( r2 ) );\n    }\n    \n    vec2 nUv = f * t + .5;\n \n    return nUv; \n}\n\nconst float SCALE = 1.0;\n\nvoid mainImage(out vec4 color, vec2 coord) {\n    vec2 ps = vec2(1) / iResolution.xy;\n    vec2 uv = coord * ps;\n    \n    //color = box_blur(iChannel0,BOKEH ASPECT_RATIO, 1/BOKEH ASPECT_RATIO) uv, vec2(ps.x, 0));\n    \n    color = vec4(0);\n    \n    for (int i = 0; i < OFFSETS.length(); ++i) {\n        // Make bokeh near the edges thinner\n        vec2 offsetWithRatio = OFFSETS[i] * vec2(1.0/BOKEH_ASPECT_RATIO, BOKEH_ASPECT_RATIO);\n        vec2 offset = offsetWithRatio * vec2(0.8*(pow(1.0 - (abs((uv.x) - 0.5) / 0.5), 0.5)) + 0.2, 1.0);\n        \n        float offsetLength = length(offset);\n        float offsetAngle = atan(offset.y, offset.x);\n        // Adding the offset here rounds things off a little bit\n        vec2 centerVec = (uv - abs(offset * ps * 4.0)) - 0.5;\n        float centerAngle = atan(centerVec.y, centerVec.x);\n\n        float centerDist = length(centerVec);\n        // float newAngle = (PI / 2.0) -offsetAngle - distortedOffsetAngle;\n        float newAngle = offsetAngle + centerAngle;\n        if (uv.x < 0.5) {\n            newAngle -= PI;\n        }\n        \n        // Bad approx for now\n        //float normalizedCenterDist = length(centerVec / ((iResolution.xy / length(iResolution)) * vec2(1.0, 0.8)));\n        float normalizedCenterDist = pow(abs(centerVec.x), 1.5) + pow(abs(centerVec.y), 9.0);\n        \n        // https://gist.github.com/shaunlebron/8832585\n        float maxAngle = PI * 2.0;\n        float da = mod((newAngle - offsetAngle), maxAngle);\n        float minLength = mod(2.0*da, maxAngle) - da;\n\n        //float interpAngle = ((minLength) * 1.0);\n        float interpAngle = offsetAngle + minLength * normalizedCenterDist;\n        vec2 adjustedOffset = vec2(cos(interpAngle), sin(interpAngle)) * offsetLength;\n        // vec2 adjustedOffset = mix(offset, vec2(cos(newAngle), sin(newAngle))*offsetLength, distortedLength*0.1);\n        \n        // adjustedOffset = offset;\n\n        color += texture(iChannel0, (coord + offset * SCALE * BLUR_AMOUNT * pow((1.0 - normalizedCenterDist/0.5), SWIRL_SIZE_EXP)) * ps);\n    }\n\tcolor /= float(OFFSETS.length());\n   \n    color = pow(color, vec4(ADJUSTED_GAMMA*PASS_2_GAMMA_DENOM));\n    color.a = 1.0;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "  //=================//\n // Second Blur Pass //\n//=================//\n\nconst vec2 OFFSETS[] = vec2[](    \n    vec2(0.0, 0.0),\n    vec2(0.5, 0.0),\n    vec2(0.15, 0.48),\n    vec2(-0.4, 0.29),\n    vec2(-0.4, -0.29),\n    vec2(0.15, -0.48),\n    vec2(1.0, 0.0),\n    vec2(0.81, 0.59),\n    vec2(0.31, 0.95),\n    vec2(-0.31, 0.95),\n    vec2(-0.81, 0.59),\n    vec2(-1.0, 0.0),\n    vec2(-0.81, -0.59),\n    vec2(-0.31, -0.95),\n    vec2(0.31, -0.95),\n    vec2(0.81, -0.59)\n);\nvec2 computeDistortedUV( vec2 uv, float k, float kcube ){\n    \n    vec2 t = uv - .5;\n    float r2 = t.x * t.x + t.y * t.y;\n\tfloat f = 0.;\n    \n    if( kcube == 0.0){\n        f = 1. + r2 * k;\n    }else{\n        f = 1. + r2 * ( k + kcube * sqrt( r2 ) );\n    }\n    \n    vec2 nUv = f * t + .5;\n \n    return nUv; \n}\n\nconst float SCALE = 0.8;\n\nvoid mainImage(out vec4 color, vec2 coord) {\n    vec2 ps = vec2(1) / iResolution.xy;\n    vec2 uv = coord * ps;\n    \n    //color = box_blur(iChannel0, uv, vec2(ps.x, 0));\n    \n    color = vec4(0);\n    \n    for (int i = 0; i < OFFSETS.length(); ++i) {\n        // Make bokeh near the edges thinner\n        vec2 offsetWithRatio = OFFSETS[i] * vec2(1.0/BOKEH_ASPECT_RATIO, BOKEH_ASPECT_RATIO);\n        vec2 offset = offsetWithRatio * vec2(0.8*(pow(1.0 - (abs((uv.x) - 0.5) / 0.5), 0.5)) + 0.2, 1.0);   \n       \n        float offsetLength = length(offset);\n        float offsetAngle = atan(offset.y, offset.x);\n        // Adding the offset here rounds things off a little bit\n        vec2 centerVec = (uv - (offset * ps * 4.0)) - 0.5;\n        float centerAngle = atan(centerVec.y, centerVec.x);\n\n        float centerDist = length(centerVec);\n        // float newAngle = (PI / 2.0) -offsetAngle - distortedOffsetAngle;\n        float newAngle = offsetAngle + centerAngle;\n        if (uv.x < 0.5) {\n            newAngle -= PI;\n        }\n        \n        // Bad approx for now\n        //float normalizedCenterDist = length(centerVec / ((iResolution.xy / length(iResolution)) * vec2(1.0, 0.8)));\nfloat normalizedCenterDist = pow(abs(centerVec.x), 1.5) + pow(abs(centerVec.y), 9.0);        \n        // https://gist.github.com/shaunlebron/8832585\n        float maxAngle = PI * 2.0;\n        float da = mod((newAngle - offsetAngle), maxAngle);\n        float minLength = mod(2.0*da, maxAngle) - da;\n\n        //float interpAngle = ((minLength) * 1.0);\n        float interpAngle = offsetAngle + minLength * normalizedCenterDist;\n        vec2 adjustedOffset = vec2(cos(interpAngle), sin(interpAngle)) * offsetLength;\n        // vec2 adjustedOffset = mix(offset, vec2(cos(newAngle), sin(newAngle))*offsetLength, distortedLength*0.1);\n        \n        // adjustedOffset = offset;\n\n        color += texture(iChannel0, (coord + adjustedOffset * SCALE * BLUR_AMOUNT * pow((1.01 - normalizedCenterDist/0.5), SWIRL_SIZE_EXP)) * ps);\n    }\n\tcolor /= float(OFFSETS.length());\n   \t\n    color.a = 1.0;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "  //==================//\n // Third Blur Pass //\n//==================//\n\nconst vec2 OFFSETS[] = vec2[](\n\tvec2(0, 2.2),\n    vec2(0, -2.2),\n    \n    vec2(0, 1.5),\n    vec2(0, -1.5),\n    \n    vec2(0, 0.9),\n    vec2(0, -0.9),\n    \n    vec2(0.4, 1.35),\n    vec2(-0.4, 1.35),   \n    vec2(0.4, -1.35),\n    vec2(-0.4, -1.35),\n    \n    vec2(0.8, 1.5),\n    vec2(-0.8, 1.5),   \n    vec2(0.8, -1.5),\n    vec2(-0.8, -1.5),\n    \n    vec2(0.6, 2),\n    vec2(-0.6, 2),\n    vec2(0.6, -2),\n    vec2(-0.6, -2),\n    \n\tvec2(1, 1),\n    vec2(-1, 1),\n    vec2(1, -1),\n    vec2(-1, -1),\n    \n    vec2(0.35, 0.6),\n    vec2(-0.35, 0.6),\n    vec2(0.35, -0.6),\n    vec2(-0.35, -0.6),\n    \n    vec2(0.7, 0.7),\n    vec2(-0.7, 0.7),\n    vec2(0.7, -0.7),\n    vec2(-0.7, -0.7),\n    \n    vec2(-1.1, 0.4),\n    vec2(1.1, 0.4),\n    vec2(-1.1, -0.4),\n    vec2(1.1, -0.4),\n    \n    vec2(-1.1, 0),\n    vec2(1.1, 0),\n    \n    vec2(-0.8, 0),\n    vec2(0.8, 0),\n    \n    vec2(-0.4, 0),\n    vec2(0.4, 0)\n);\n\nconst float SCALE = 1.0;\n\nvoid mainImage(out vec4 color, vec2 coord) {\n    vec2 ps = vec2(1) / iResolution.xy;\n    vec2 uv = coord * ps;\n    \n    //coord = scale_uv(coord, vec2(0.5), iResolution.xy * 0.5);\n    \n    color = vec4(0);\n    \n    for (int i = 0; i < OFFSETS.length(); ++i) {\n        vec2 c = coord;\n        vec2 offset = OFFSETS[i] * vec2(0.8*(pow(1.0 - (abs((uv.x) - 0.5) / 0.5), 0.5)) + 0.2, 1.0);   \n        float offsetLength = length(offset);\n        float offsetAngle = atan(offset.y, offset.x);\n        // Adding the offset here rounds things off a little bit\n        vec2 centerVec = (uv - (offset * ps * 4.0)) - 0.5;\n        float centerAngle = atan(centerVec.y, centerVec.x);\n\n        float centerDist = length(centerVec);\n        // float newAngle = (PI / 2.0) -offsetAngle - distortedOffsetAngle;\n        float newAngle = offsetAngle + centerAngle;\n        if (uv.x < 0.5) {\n            newAngle -= PI;\n        }\n        \n        // Bad approx for now\n        //float normalizedCenterDist = length(centerVec / ((iResolution.xy / length(iResolution)) * vec2(1.0, 0.8)));\n        float normalizedCenterDist = pow(abs(centerVec.x), 1.5) + pow(abs(centerVec.y), 9.0);        \n        // https://gist.github.com/shaunlebron/8832585\n        float maxAngle = PI * 2.0;\n        float da = mod((newAngle - offsetAngle), maxAngle);\n        float minLength = mod(2.0*da, maxAngle) - da;\n\n        //float interpAngle = ((minLength) * 1.0);\n        float interpAngle = offsetAngle + minLength * normalizedCenterDist * 2.0;\n        vec2 adjustedOffset = vec2(cos(interpAngle), sin(interpAngle)) * offsetLength;\n        c += adjustedOffset * SCALE * BLUR_AMOUNT * pow((1.01 - normalizedCenterDist/0.5), SWIRL_SIZE_EXP);\n        c *= ps;\n        color = max(color, pow(texture(iChannel0, c), vec4(1.0/(ADJUSTED_GAMMA*PASS_2_GAMMA_DENOM))));\n    }\n    \n    color.a = 1.0;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}