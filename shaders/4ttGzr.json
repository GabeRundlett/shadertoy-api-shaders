{
    "Shader": {
        "info": {
            "date": "1467738186",
            "description": "Saw P_Malin's approach of only using global variables to interface with the raymarching function so I decided to try and write my own. The shader itself is in buffer B, while buffer A is the reference shader and you can click to highlight differences.",
            "flags": 0,
            "hasliked": 0,
            "id": "4ttGzr",
            "likes": 1,
            "name": "[SH16A] [588] fb39ca4",
            "published": 3,
            "tags": [
                "sh16a"
            ],
            "usePreview": 0,
            "username": "fb39ca4",
            "viewed": 1381
        },
        "renderpass": [
            {
                "code": "/*fb39ca4's SH16A entry\n\n  This would have not been possible without support and collaboration from\n  coyote, P_Malin, knarkowicz, iq, Stubbe, reinder, and many others in the\n  Shadertoy community. Actually, this shader is P_Malin's and knarkowicz's\n  as well since we converged on the same thing with different variable\n  names. Best of luck to everyone competing in the next two weeks.\n*/\n\n#define V vec3(\n#define N normalize(V\n/*\np: Ray Position\nd: Ray Direction. Also temporarily used to calculate checkerboard.\nn: Normal\nc: (0,1,0) vector initially, then color\ng: iResolution initially, then Grid Position\nw: temporary for constructing camera matrix\no: Fragment Output Color. o.a used to calculate sphere color.\nr: Fragment Coordinate\n*/\nvoid mainImage(out vec4 o, vec2 r) {\n    //Initialize variables\n    vec3   p = V 2, .851, -2.87677), \n        c = V 1, 0, 0),\n        n = c,  \n        w = N.2 * n + p)),\n        d = N cross(w, n))),\n        g;\n    d = w = mat3(d, cross(d, w), w) * N 16, 9, 18 ) - V r / 60., 0 ) );\n    //Use these two lines instead to be compatible with all resolutions\n    //    g = iResolution;\n    //d = w = mat3(d, cross(d, w), w) * N.5*g.xy-r, g.y));\n    //Raymarch\n    for (int i = 0; i < 128; i++) \n        g = clamp(ceil(p - .5), -2., 2.),\n        g.x = .4 - .3 * fract(o.a = g.y * 2.5 + g.z * .5),                      \n        p -= i == 63 ? \n            d = mod(p, 2.) - 1.,\n            c = p.x > .1 ?\n                n = N p - g)), \n        \t\tc + c + .02 * V-8, 3, 6) * floor(o.a + 6.)\n            :\n                V.0 < d.y * d.z ? \n                \t.8 \n                :\n                \ttexture( iChannel0, .1 * p.yz).r) * smoothstep(0., .5, length(p - sign(g - g * c))),\n            d = N-7, 6, 5)),\n            d * .01\n        : d * min(length(p - g) - g, p).x;\n    //Shading and output\n    o.rgb = sqrt(\n        dot(n, -d) * V.9<p.x ) * (\n            pow(max(dot(reflect(w, n), d), 0.), 16.) + \n            c * V.6,.51,.33)\n        )\n        + c * ++n.x * V.5,.7,1) / 8.\n    );\n}\n\n//Experimented with some code to set the normal on the outside of the ternary statement, but setting the color was shorter in the end\n/*n = N(p.y > .01 ?\n\tc = c + c + .02 * V(3,-8,6) * floor(o.a / 2. + 6.),\n\tp - g \n: (\n\tc = V(r.x * r.y > 0. ? .8 : texture( iChannel0, .1*p.xz).r) * smoothstep(0., .5, length((p - sign(g)).xz)),\n\tn\n)),*/\n\n//Before refactoring into 1 loop\n\n/*#define M ); for (int i = 0; i < 64; i++) g = clamp(ceil(p - .5), -2., 2.), g.y = .4 - .3 * fract(o.a = g.x * 2.5 + g.z * .5), p -= d * min(length(p - g) - g, p).y; o.grb\n\nvoid mainImage(out vec4 o, vec2 r) {\n    V p = V(.851,2,-2.87677), n = V(0,1,0), w= N(.2*n + p), c = N(cross(w, n)), g = iResolution, d; \n    d = w = mat3(c, cross(w, c), w) * N(V(r - g.xy / 2., g.y)\n    \n    M = mod(p, 2.) - 1.;\n    c = p.y > .01 ? n+n + (n = N(p - g), .02 * V(3,-8,6) * floor(o.a + 6.))\n        : V(o.y * o.z > 0. ? .8 : texture( iChannel0, .1*p.xz).r)\n    \t\t* smoothstep(0., .5, length(p - sign(g - g * n)));\n   \n    p -= .01 * (d = N(V(6, -7, 5))\n\n    M = sqrt(\n    \tdot(n, -d)*V(p.y>2.)*(\n            pow(max(dot(reflect(w, n), d), 0.),16.) + \n            c*V(.51,.6,.33)\n        )\n        + c * ++n.y * V(7,5,10) / 80.\n    );\n\n}*/\n\n              \n//This is what the shader looked like when I first wrote it, before the agressive minification.\n/*\nvec3 rayPos, rayDir, normal, gridPos, rayU, rayV, rayW, color;\nfloat ambient, diffuse, specular, paletteIdx;\n\nvoid rayMarch() {\n    for (int i = 0; i < 64; i++) {\n        gridPos = clamp(floor(rayPos + .5), -2., 2.);\n        gridPos.y = mod(gridPos.x + gridPos.z, 2.) < .5 ? .4 : .25;\n        rayPos += rayDir * min(length(rayPos - gridPos) - gridPos.y, rayPos.y);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    \n    fragCoord = 2. * fragCoord / iResolution.xy - 1.;\n    fragCoord.x *= iResolution.x / iResolution.y;\n    rayPos = vec3(3.*cos(5.), 2., 3.*sin(5.));\n    rayW = normalize(-vec3(0,.2,0)-rayPos);\n    rayU = normalize(cross(rayW, vec3(0,1,0)));\n    rayV = cross(rayU, rayW);\n    rayDir = mat3(rayU, rayV, rayW) * normalize(vec3(fragCoord, 2.));\n    rayMarch();\n    normal = rayPos.y > .001 ? normalize(rayPos - gridPos) : vec3(0,1,0);    \n    rayW = rayDir;\n    paletteIdx = floor(gridPos.x*2.5+gridPos.z*.5+6.);\n    color = mod(floor(rayPos.x)+floor(rayPos.z), 2.) < 0.5 ? vec3(.4) : .5*texture( iChannel0, .1*rayPos.xz + vec2(37,17)/256.).yyy;\n    color *= smoothstep(0., .5, length(rayPos.xz - clamp(gridPos.xz, -1., 1.)));\n    color = rayPos.y > .01 ? vec3(1.-paletteIdx*.08,paletteIdx*.03,paletteIdx*.06) : color;\n    rayDir = normalize(vec3(-.6, .7, -.5));\n    rayPos += .1 * rayDir;\n    rayMarch();\n    ambient = clamp(.5+.5*normal.y, 0., 1.);\n    diffuse = clamp(dot(normal, rayDir), 0., 1.) * float(rayPos.y > 2.5);\n    specular =  pow(clamp( dot(normalize(reflect(rayW, normal)), rayDir), 0.0, 1.0 ),16.0);\n    color = specular*diffuse + color*(1.2*diffuse*vec3(1,.85,.55)+.5*ambient*vec3(.5,.7,1));\n    fragColor.rgb = sqrt(color);\n}\n*/",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}