{
    "Shader": {
        "info": {
            "date": "1712632614",
            "description": "Steel Spin by NuSan, PC 4k intro made for Novoque 2020",
            "flags": 32,
            "hasliked": 0,
            "id": "ssffW2",
            "likes": 6,
            "name": "Fork Sharp bloo firebreath 927",
            "published": 3,
            "tags": [
                "intro",
                "4k",
                "novoque"
            ],
            "usePreview": 0,
            "username": "firebreathz",
            "viewed": 142
        },
        "renderpass": [
            {
                "code": "// Fork of \"Fork Fork Sharp firebreath 969\" by firebreathz. https://shadertoy.com/view/7dBSDt\n// 2021-06-16 10:16:58\n\n// Steel Spin by NuSan\n// PC 4k intro made for Novoque 2020\n\n// Unfortunately, the GPU Synthesizer I made cannot be ported on shadertoy, as it uses a second audio pass to compute reverbs\n// So only soundcloud for now ...\n\n// Original Tools: Leviathan, custom GPU synth, Shader Minifier, Crinkler\n// https://www.pouet.net/prod.php?which=85684\n// https://youtu.be/OjZVSqhReqA\n\n// if sound doesn't start or seems desynchronised:\n// try clicking pause/start button in the \"soundcloud\" square in the bottom right\n// then press rewind just under the shader picture on the left\n\n///////////////////////\n// POST-PROCESS PASS //\n///////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\t\n\tvec2 frag = fragCoord.xy;\n\tvec2 uv = frag/iResolution.xy;\n\t\n\tfloat time = iTime-2.25;\n    \n    vec3 col = texture(iChannel0, uv).xyz;\n    \n    // Bloom computation\n    vec3 cumul = vec3(0);\n\tfor(float i=-20.; i<=2.5; ++i) {\n\t\tfor(float j=-2.; j<=2.5; ++j) {\n\t\t\tvec4 cur = textureLod(iChannel1, uv + (vec2(i,j))*306./vec2(80000.,80000.), iResolution.y>7200. ? 60. : 4.);\n\t\t\tcumul += cur.xyz;\n\t\t}\n\t}\n    \n    // use more bloom for brighter values\n\tcol += cumul * clamp(dot(cumul.xyz,vec3(.01))-.3,0.,1.)*0.005;\n    \n    // 'tone mapping'\n    col = smoothstep(0.1,1.,col);\n    col = pow(col,vec3(.65));\n    \n    // fade in / fade out\n    col *= sat(time*5.) * sat(231.-time);\n\t\t\t\t\t\n\tfragColor = vec4(col, 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float pi=acos(-1.);\n\nfloat sat(float t) { return clamp(t, 0.,1.); }\n\n//DAVE HOSKINS' HASH FUNCTIONS\n// we use them mainly because they don't contain any sin/cos and so should be more consistent accross hardware\n//https://www.shadertoy.com/view/4djSRW\nfloat rnd(float p)\n{\n    p = fract(p * 0.1031);\n    p *= p + 33.33;\n    return fract(2.*p*p);\n}\n\nvec3 rnd23(vec2 p)\n{\n\tvec3 p3 = fract(p.xyx * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat rnd31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat rnd21(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 rnd33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nmat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n// Uncomment that value if you want to change the quality\n#define SAMPLE_COUNT 8.\n\n#define res iResolution\n\n//////////////////////\n// PATHTRACING PASS //\n//////////////////////\n\n// we use globals for most parameters, it save space\n// s is starting position, r is ray direction\n// n is normal at intersection point and d is distance to the intersection\nvec3 s,p,r;\nfloat s0,ds2;\nvec3 planen;\nfloat planediv, planedist, planewidth, planemaxdiv, planeoffset, rad1, rad2;\n\n// compute the 2 sides of a planar cut section\nvoid planecut(inout float d, inout vec3 n) {\n  float rpd = abs(dot(-p,planen)-planedist);\n  if(rpd>planediv*.5-planewidth) {\n    return;\n  }\n          \n  float dn = dot(r,planen);\n  float dwd = dot(-s,planen)-planedist;\n  dwd += sign(dn)*(planediv*.5-planewidth);\n      \n  d=dwd/dn;\n  n=planen*sign(dn);\n}\n\n// compute intersections with a sphere (size d) and it's plane cuts along axis n\nbool spheretest(inout float d, inout vec3 n) {\n  \n\tfloat c1 = rad1*rad1 - ds2;\n\tif(c1<=0.) return false;\n  \n    // compute both intersections with the sphere\n\tfloat cd1 = sqrt(c1);\n\tfloat d1a = s0-cd1;\n\tfloat d1b = s0+cd1;\n  \n    // start with the first intesection with the sphere\n\td=max(0.,d1a);\n\tp=s+r*d;\n\tn=normalize(-p);\n\n    // plane cut repetition (div) and size (dist)\n    // code is pretty messy, didn't have time to clean it up\n\tfloat tmpprog = dot(p,planen)+planeoffset;\t\n\tfloat basediv=planediv;\n\tplanediv = (basediv/(floor(rnd(floor(tmpprog/basediv))*planemaxdiv)+1.));\n\tplanedist = -((floor(tmpprog/planediv)+.5))*planediv+planeoffset;\n    \n    // compute plane cuts side with first intersection with the sphere\n\tplanecut(d,n);\n  \n\tfloat c2 = rad2*rad2 - ds2;\n\tif(c2>0.) {\n        // if we got through the first intersection, check the second one\n\t\tfloat cd2 = sqrt(c2);\n\t\tfloat d2a = s0-cd2;\n\t\tfloat d2b = s0+cd2;\n\t\tif(d2b>0. && d2a<d) {\n      \n\t\t\td=d2b;\n\t\t\tp=s+r*d;\n      \n\t\t\tfloat tmpprog = dot(p,planen)+planeoffset;\t\n\t\t\tplanediv = (basediv/(floor(rnd(floor(tmpprog/basediv))*planemaxdiv)+1.));\n\t\t\tplanedist = -((floor(tmpprog/planediv)+.5))*planediv+planeoffset;\n\n            // compute plane cuts side with second intersection with the sphere\n\t\t\tplanecut(d,n);\n\t\t}\n\t}\n  \n    // if we got through the sphere completely, show the sky\n\tif(d>d1b) {\n\t\td=10000.;\n\t\tn=vec3(0);\n\t}\n  \n\treturn true;\n}\n\nmat3 rotxy(float a) {\n\treturn mat3(cos(a),sin(a),0,-sin(a),cos(a),0,0,0,1);\n}\nmat3 rotxz(float a) {\n\treturn mat3(cos(a),0,sin(a),0,1,0,-sin(a),0,cos(a));\n}\n\nfloat tick(float t) {\n\treturn floor(t) + pow(smoothstep(0.,1.,fract(t)),10.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 frag = fragCoord.xy;\n\tvec2 uv = (frag-res.xy*0.5)/res.y;\n\t\n\tfloat time = iTime-.5;\n\n\t// Main way to control the intro (camera, DOF focus, shape)\n    // Each vec3 is a section of the intro\n    // first value is the seed of the camera motionpath/speed/FOV, fractionnal part is a time offset, negative values subdivide the section in two parts\n    // second value is the focus distance for the DOF, relative to the center of the sphere\n    // third value is the shape seed and it's motion, integer value is the shape, fractionnal part is a time offset\n\tvec3 mot[17] = vec3[17]( \n\t\t\t\t\t\t vec3(4.4,5, 22.885)\n\t\t\t\t\t\t,vec3(8.1,5, 34.1)\n\t\t\t\t\t\t,vec3(-30.3,3.3, 73.1)\n\t\t\t\t\t\t,vec3(20,3, 102)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(22.8,5, 59)\n\t\t\t\t\t\t,vec3(21,5, 49)\n\t\t\t\t\t\t,vec3(5,8, 22.885)\n\t\t\t\t\t\t,vec3(31,5, 76)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(2.4,5, 59.01)\n\t\t\t\t\t\t,vec3(30.6,5, 69.6)\n\t\t\t\t\t\t,vec3(-26.5,5, 6.3)\n\t\t\t\t\t\t,vec3(27,4, 78)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(28,3, 72)\n\t\t\t\t\t\t,vec3(-90,5, 34.2)\t\t\t\t\t\t\n\t\t\t\t\t\t,vec3(15,4, 6)\n\t\t\t\t\t\t,vec3(40,3, 102)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(65,7, 22.8)\n\t\t\t\t\t\t);\n\n\tint section = int(time/10.);\n\tfloat rest = mod(time,10.);\n\n\tvec3 mval = mot[section];\n\n\tvec3 pcam = rnd23(vec2(round(abs(mval.x)),0.3));\n\tvec3 pshape = rnd23(vec2(round(abs(mval.z)),0.7));\n\n\t//////// MOTION ////////\n\n\tfloat avance = pcam.x*130. + (rest+(fract(mval.x+.5)-.5)*16.) * (pcam.y-0.2);\n\tif(mval.x<0. && rest>4.) avance += 200.;\n\n\tfloat camdist = sin(avance*fract(pcam.z*84.52))*5.+10.;\n\tvec3 bs=vec3(0,0,-camdist);\n\tvec3 target=vec3(sin(avance*.7)*2.,0,0);\n  \n\t//////// CAMERA ANIMATION ////////\n\n\tbs.yz*= rot(sin(avance*.1));\n\tbs.xz*= rot(avance*.1);\n\t  \n\t//////// CAMERA COMPUTE ////////\n\tvec3 cz=normalize(target-bs);\n\tvec3 cx=normalize(cross(cz,vec3(0,1,0)));\n\tvec3 cy=cross(cz,cx);\n  \n\tfloat fov = pcam.z+0.1;\n\tfloat focusdist=camdist - 0.1 + mval.y;\n\tfloat dofamount=.0001;//mval.y>0 ? .15 : .35;\n    \n\tvec3 col=vec3(0);\n  \n    // all of the code bellow is very messy as deadline was very close, sorry about that\n    \n    // light activations\n\tbool lightsky = section<2;\n\tbool lightsilver = section>6 && section<12;\n\tbool lightgreen = section>1;\n\tbool lightpink = section>6 && section<8;\n\tbool centerlight = section>0;\n\tbool strips = (section>2);\n\tbool bluelight = section >= 0;\n  \n    // special case tweaks for some sections\n\tif(section==0) rest=max(rest,2.);\n     // motion slowing down during the last section\n\tfloat t2=section!=1?time:pow(sat(rest*1.6),.5)*1.5;\n\tif(section==16) {time=1.4; rest=0.2;}\n    \n    // shape motion time\n\tfloat t = rest*pshape.x*.5 + (fract(mval.z+.4)-.5)*4.;\n    // bending of the shape during a few section\n    // we just offset the time according to the pixel uvs and it makes the shape bend without touching at the collision intersection\n\tif(section>1 && section<3) t += (uv.y*2. + sin(uv.x*5.+rest*0.3)*.5) * (section>1?sat((111.-time)*.5):pow(smoothstep(0.,1.,sin(rest*pi*4.+.1)*.5+.5),10.) * sat((time-100.)*.25));\n\t  \n    // parameters of the shape\n\tfloat rdiv = pshape.y*10.+1.;\n\tfloat roff = max(0.,fract(pshape.y*37.21)*2.-1.);\n\tif(lightpink || (section>11 && section<16)) roff += tick(time)*.5;\n\tfloat rmax = max(0.,pshape.z*8.-4.);\n\tfloat rok = fract(pshape.z*841.52)*2.-.2;\n\tfloat rrad = .3;\n\tfloat rrad2 = fract(pshape.y*74.81);\n\n\tconst int sphnumb = 10;\n\tint sphmax = 10;\n\tif(section==2) sphmax=4; // this section was too slow because very zoomed in ...\n\t  \n    // cache each sphere rotation as a matrix\n\tmat3 planemat[sphnumb];\n\tplanemat[0]=mat3(1,0,0,0,1,0,0,0,1);\n\tfor(int k=0;k<sphnumb; ++k) {\n\t\tif(k>0){\n\t\t\tplanemat[k] = planemat[k-1];\n\t\t}\n\t\tplanemat[k] *= rotxy(t);\n\t\tplanemat[k] *= rotxz(t*.9);\n\t}\n  \n    // the first part was slower, so I just reduced the sample count\n    // with just the smooth sky, there is not much noise\n\tfloat steps=section<2 ? 10. : 20.;\n    #ifdef SAMPLE_COUNT\n    \tsteps=SAMPLE_COUNT;\n    #endif\n    \n\t// Main path tracing loop, do many samples to reduce the noise\n\tfor(float i=0.1; i<steps; ++i) {\n    \n\t\ts=p=bs;\n    \t\n\t\tvec2 h = rnd23(frag-13.6-i*1084.7).xy;\n\t\t// DOF just by offsetting the rays randomly\n\t\tvec3 voff = sqrt(h.x)*(cx*sin(h.y*6.283)+cy*cos(h.y*6.283))*dofamount;\n\t\ts-=voff;\n\t\tvec2 uv2 = uv + (h.yx-.5)/res.y;\n\t\tr=normalize(uv2.x*cx+uv2.y*cy+fov*cz + voff*fov/(focusdist));\n\t\t\n\t\t        \n\t\tfloat alpha = 1.0;\n    \t// number of bounces is 3\n\t\tfor(int j=0; j<3; ++j) {\n        \n            // as all the sphere part have the same center, I can precompute some things\n\t\t\ts0 = dot(-s,r);\n\t\t\tvec3 ns = s+r*s0;\n\t\t\tds2 = dot(ns,ns);\n      \n\t\t\tplanen = normalize(vec3(0,1,0));\n      \n\t\t\tfloat d=10000.;\n\t\t\tvec3 n=vec3(0);\n\t\t\tint circ=0;\n            \n            // iterate on each sphere\n\t\t\tfor(int k1=0; k1<sphmax; ++k1) {\n        \t\tfloat k=float(k1);\n                // change settings of the repeating cut plane\n\t\t\t\tplanediv = rdiv;\n\t\t\t\tplanemaxdiv = rmax;\n\t\t\t\tplaneoffset = rnd(k+.3)*7.*roff;\n\t\t\t\tif(rok<0.) {\n\t\t\t\t\tplanewidth = 0.1+k*.1;\n\t\t\t\t} else {\n\t\t\t\t\tplanewidth = rok;\n\t\t\t\t}\n\t\t\t\trad1 = 5.-k*rrad;\n\t\t\t\trad2 = 5.-(k+rrad2)*rrad;\n        \n                // axis of the plane from the cache\n\t\t\t\tplanen = planemat[k1][1];\n                \n\t\t\t\tfloat d2=10000.;\n\t\t\t\tvec3 n2=vec3(0);\n                // if we get an intersection, early out of the loop\n\t\t\t\tif(!spheretest(d2,n2)) break;\n        \n\t\t\t\tif(d2<d) {\n\t\t\t\t\td=d2;\n\t\t\t\t\tn=n2;\n\t\t\t\t\tcirc=k1;\n\t\t\t\t}\n\t\t\t}\n      \n\t\t\t// sky sphere\n\t\t\tif(d>1000.) {\n\t\t\t\tif(lightsky) col += alpha * mix(vec3(0.6,0.8,1)*0.8, vec3(1,0.7,0.5) * 2., max(r.x+r.z*.3-r.y*.7,0.)*.7);\n\t\t\t\tif(lightpink) { \n                    col += alpha * smoothstep(0.9,0.1,abs(fract(r.x*9.)-.5))*smoothstep(0.8,0.9,fract(time*.5+rnd(floor(r.x*5.)))) * vec3(0.5,.4,1);\n                    col += alpha * smoothstep(0.5,0.3,abs(fract(r.z*5.)-.5))*smoothstep(0.8,0.9,fract(time*.5+.25+rnd(floor(r.z*5.)+7.3))) * vec3(1,.2,.3);\n\t\t\t\t}\n\t\t\t\tif(lightsilver) {\n                    vec3 ttt = rnd23(floor(r.xy*5.));\n                    col += pow(fract(floor(ttt.x*8.)/8.-time*0.25),2.) * (.7+ttt.y*vec3(.3,.5,1)+vec3(1,.5,.3)*ttt.z);\n\t\t\t\t}\n\t\t\t\tif(lightgreen) {\n\t\t\t\t\tfloat sqsize = .1;\n\t\t\t\t\tcol += alpha * smoothstep(0.4,0.1,fract(time*.5+rnd(floor(r.x*sqsize)+floor(r.y*sqsize)*0.1+floor(r.z*sqsize)*0.02))) * 2. * (rnd33(floor(r*sqsize)+floor(time)*.37)*.3+.7);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n      \n            // go to the collision position\n\t\t\ts = s + r * d;\n            \n            // emissive lights\n            float circ2 = float(circ);\n\t\t\tif(bluelight && circ2==floor(fract(-t2*.2*3.)*10.)) col += alpha * 4. * vec3(.2,.3,1);\n\t\t\tif(centerlight && circ2==9.) col += alpha * 4. * vec3(1,.2,.3);\n      \n            // slight increase in perf, get out before computing rebound direction in the last rebound\n\t\t\tif(j==2) break;\n      \n            // get local position (rotating with the shape) depending on which sphere has been intersected\n\t\t\tvec3 localpos = s*planemat[circ];\n\t\t\tvec3 sphuv = vec3(atan(localpos.x,localpos.z)*6., localpos.y, length(localpos.xz)*.6);\n\n            // roughness compute as squares of random roughness\n\t\t\tvec3 rpos = sphuv*20.-.1;\n\t\t\tvec3 id = floor(rpos);\n\t\t\tvec3 grid = fract(rpos);\n\t\t\tfloat rough = .0005*rnd31(id*27.33);\n            // stripes on the shape are just changes off roughness\n\t\t\tif(strips) rough = (fract(sphuv.x)<6.5)?.002:rough;\n\t\t\t\n            // slight offset so we get out of the surface before rebound\n\t\t\ts-=r*0.05;\n      \t\t\n            // next rebound will be a bit less bright\n\t\t\talpha *= .7;\n      \n            // random rebound direction according to roughness parameter\n\t\t\tr=normalize(reflect(r,n) + normalize(rnd23(frag+vec2(i*277.,j*375)+fract(time))-.5)*rough);      \n\t\t}\n\t}\n\tcol *= 0.7/steps;\n\n\tfragColor = vec4(col, 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}