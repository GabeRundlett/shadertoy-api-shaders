{
    "Shader": {
        "info": {
            "date": "1523436296",
            "description": "A simple ray tracer based on Peter Shirley's ebook.\n\nFeatures (-=todo, +=working, *=done)\n* Sphere\n* Cylinder\n* Cone\n* Plane\n* Disk\n* Axis Aligned Rectangle\n+ Torus\n+ Box\n+ N-sided convex polyhedra",
            "flags": 0,
            "hasliked": 0,
            "id": "4tSBzw",
            "likes": 0,
            "name": "glsl ray caster 1",
            "published": 3,
            "tags": [
                "raytracer"
            ],
            "usePreview": 0,
            "username": "microwerx",
            "viewed": 470
        },
        "renderpass": [
            {
                "code": "//////////////////////////////////////////////////////////////////////\n// S U N F I S H   R A Y   T R A C E R ///////////////////////////////\n//////////////////////////////////////////////////////////////////////\n// Copyright (C) 2018 Jonathan Metzgar                              //\n//////////////////////////////////////////////////////////////////////\n\n\n//////////////////////////////////////////////////////////////////////\n// S H A D E R S /////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////\n\n\nvec3 sfShadeSkyCubeMap(Ray r)\n{\n    return texture(iChannel0, r.direction).rgb;\n}\n\n\nvec3 sfShadeSkyCubeMapBlur(Ray r)\n{\n    return texture(iChannel1, r.direction).rgb;\n}\n\n\nvec3 sfShadeSkyShirley(Ray r)\n{\n\tfloat t = 0.5 * (r.direction.y + 1.0);\n\treturn (1.0 - t) * ArneWhite + t * ArneSkyBlue;\n}\n\n\nvec3 sfShadeSkyDawn(Ray r)\n{\n\tfloat t = 0.5 * (r.direction.y + 1.0);\n\treturn (1.0 - t) * Orange + t * ArneSkyBlue;\n}\n\n\nvec3 sfShadeSky(Ray r)\n{\n    if (iSkyMode == SKY_SHIRLEY) return sfShadeSkyShirley(r);\n    if (iSkyMode == SKY_DAWN)    return sfShadeSkyDawn(r);\n    if (iSkyMode == SKY_CUBEMAP) return sfShadeSkyCubeMap(r);\n    if (iSkyMode == SKY_CUBEMAPBLUR) return sfShadeSkyCubeMapBlur(r);\n    return Black;\n}\n\n\n\nvoid test_ray()\n{\n\tRay r = sfCreateRay(vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0));\n}\n\n// Shaders\n\n\nbool sfClosestHit(in Ray r, out HitRecord h)\n{\t\t\n    int hit = -1;\n    float t_min = 0.0;\n    float t_max = 1e6;\n\tfor (int i = 0; i < MAX_HITABLES; i++)\n\t{\n\t\tif (i >= HitableCount) break;\n\t\tif (sfRayIntersect(Hitables[i], r, t_min, t_max, h))\n\t\t{\n            hit = i;\n\t\t\tt_max = h.t;\n            if (Hitables[i].material.type == MATERIAL_EMISSION)\n            {\n                h.Kd = Hitables[i].material.Ke;\n                h.isEmissive = 1;\n            }\n            else\n            {\n                h.Kd = Hitables[i].material.Kd;\n                h.isEmissive = 0;\n            }\n\t\t}\n\t}\n    h.i = hit;\n    if (hit < 0) return false;\n    return true;\n}\n\n\nvec3 sfBounce1(Ray r)\n{\n\tHitRecord h = sfCreateHitRecord(1e6, vec3(0.0), vec3(0.0));\n\tint hit = -1;\n\tfloat t_min = 0.0;\n\tfloat t_max = 1e6;\n\tvec3 Kd;\n\tfor (int i = 0; i < MAX_HITABLES; i++)\n\t{\n\t\tif (i >= HitableCount) break;\n\t\tif (sfRayIntersect(Hitables[i], r, t_min, t_max, h))\n\t\t{\n\t\t\tt_max = h.t;\n\t\t\thit = i;\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_HITABLES; i++)\n\t{\n\t\tif (hit == i)\n\t\t{\n\t\t\treturn Hitables[i].material.Kd;\n\t\t}\n\t}\n\treturn sfShadeSky(r);\n}\n\nvec3 sfBounce2(Ray r)\n{\n\tHitRecord h = sfCreateHitRecord(1e6, vec3(0.0), vec3(0.0));\n\tint hit = -1;\n\tfloat t_min = 0.0;\n\tfloat t_max = 1e6;\n\tvec3 Kd;\n\tfor (int i = 0; i < MAX_HITABLES; i++)\n\t{\n\t\tif (i >= HitableCount) break;\n\t\tif (sfRayIntersect(Hitables[i], r, t_min, t_max, h))\n\t\t{\n\t\t\tt_max = h.t;\n\t\t\thit = i;\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_HITABLES; i++)\n\t{\n\t\tif (hit == i)\n\t\t{\n            h.N = normalize(h.N);\n\t\t\tRay reflectedRay = sfCreateRay(\n\t\t\t\th.P,\n\t\t\t\treflect(r.direction, h.N)\n\t\t\t\t);\n\t\t\treturn Hitables[i].material.Kd * sfBounce1(reflectedRay);\n\t\t}\n\t}\n\treturn sfShadeSky(r);\n}\n\nvec3 sfBounce3(Ray r)\n{\n\tHitRecord h = sfCreateHitRecord(1e6, vec3(0.0), vec3(0.0));\n\tint hit = -1;\n\tfloat t_min = 0.0;\n\tfloat t_max = 1e6;\n\tvec3 Kd;\n\tfor (int i = 0; i < MAX_HITABLES; i++)\n\t{\n\t\tif (i >= HitableCount) break;\n\t\tif (sfRayIntersect(Hitables[i], r, t_min, t_max, h))\n\t\t{\n\t\t\tt_max = h.t;\n\t\t\thit = i;\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_HITABLES; i++)\n\t{\n\t\tif (hit == i)\n\t\t{\n            if (Hitables[i].material.type == MATERIAL_EMISSION) {\n                return Hitables[i].material.Ke;\n            }\n            h.N = normalize(h.N);\n\n\t\t\tRay reflectedRay = sfCreateRay(\n\t\t\t\th.P,\n\t\t\t\treflect(r.direction, h.N)\n\t\t\t\t);\n\t\t\treturn Hitables[i].material.Kd * sfBounce2(reflectedRay);\n\t\t}\n\t}\n\treturn sfShadeSky(r);\n}\n\n\nvec3 sfRayTrace(Ray r)\n{\n\tHitRecord h = sfCreateHitRecord(1e6, vec3(0.0), vec3(0.0));\n\tint hit = -1;\n\tfloat t_min = 0.0;\n\tfloat t_max = 1e6;\n\tvec3 Kd;\n    if (!sfClosestHit(r, h))\n        return sfShadeSky(r);    \n\tfor (int i = 0; i < MAX_HITABLES; i++)\n\t{\n\t\tif (h.i == i)\n\t\t{\n            if (Hitables[i].material.type == MATERIAL_EMISSION) {\n                return Hitables[i].material.Ke;\n            }\n            //if (Hitables[i].type == HITABLE_TORUS) {\n            //    return Magenta;\n            //}\n            \n            h.N = normalize(h.N);\n            \n\t\t\tRay reflectedRay = sfCreateRay(\n\t\t\t\th.P,\n\t\t\t\treflect(r.direction, h.N)\n\t\t\t\t);\n            float NdotL = dot(reflectedRay.direction, h.N);\n\t\t\treturn Hitables[i].material.Kd * NdotL * sfBounce3(reflectedRay);\n\t\t}\n\t}\n\treturn sfShadeSky(r);\n}\n\n\nvec3 sfPathTrace(Ray r)\n{\n    vec3 accum = Black;\n    const int MaxRaysPerPixel = 25;\n    const int MaxPaths = 5;    \n    int path;\n    float anim = 0.0*(sin(iTime));\n    for (int i = 0; i < MaxRaysPerPixel; i++)\n    {\n    \tHitRecord h[MaxPaths];\n        float costs[MaxPaths];\n        vec3  color[MaxPaths];\n        Ray ray = r;\n        ray.direction += sfRandomDirection(r.direction) * 0.001;\n        ray.direction = normalize(r.direction);\n        ray.origin.x += anim * rand();\n        for (path = 0; path < MaxPaths; path++)\n        {\n            //ray.origin.x += anim * rand();\n            h[path] = sfCreateHitRecord(1e6, vec3(0.0), vec3(0.0));\n            if (!sfClosestHit(ray, h[path])) {\n                costs[path] = 1.0;\n                h[path].Kd = sfShadeSky(ray);\n                break;\n            }\n            \n            if (h[path].isEmissive != 0) {\n                costs[path] = 1.0;\n                break;\n            }\n            for (int k = 0; k < MAX_HITABLES; k++) {\n                if (k == h[path].i && Hitables[k].type == HITABLE_PLANE) {                    \n                    float sines = sin(10. * h[path].P.x) * \n                        sin(10. * h[path].P.y) * \n                        sin(10. * h[path].P.z);\n                    if (sines < 0.0) {\n                        h[path].Kd = White;\n                    }\n                    break;\n                }\n            }\n                                float sines = sin(10. * h[path].P.x) * \n                        sin(10. * h[path].P.y) * \n                        sin(10. * h[path].P.z);\n                    if (sines < 0.0) {\n                        h[path].Kd = White;\n                    }\n            vec3 N = normalize(h[path].N);\n            float willReflect = rand();\n            const float F0 = 0.33 / 2.33;\n            float cos_d = dot(N, ray.direction);\n            float fresnel = F0 + (1.0 - F0) * (pow(cos_d, 5.0));\n            if (willReflect > fresnel){\n                ray = sfCreateRay(h[path].P,\n                                  reflect(ray.direction, N));                \n            } else {\n            \tray = sfCreateRay(h[path].P,\n                                  sfRandomDirection(h[path].N));\n            }\n            costs[path] = max(0.0, dot(N, ray.direction));\n        }\n        // special case, we only hit the sky\n        if (path == 0) accum += h[path].Kd;\n        for (int j = 1; j < MaxPaths; j++) {\n            if (j > path) break;\n            \n            accum += costs[j-1] * h[j].Kd;\n        }\n    }\n    accum /= float(MaxRaysPerPixel);\n    return accum;\n}\n\n\nvec3 sfRayCast(Ray r)\n{\n\tHitRecord h = sfCreateHitRecord(1e6, vec3(0.0), vec3(0.0));\n\tint hit = -1;\n\tfloat t_min = 0.0;\n\tfloat t_max = 1e6;\n\tvec3 Kd;\n    if (!sfClosestHit(r, h))\n        return sfShadeSky(r);    \n\tfor (int i = 0; i < MAX_HITABLES; i++)\n\t{\n\t\tif (h.i == i)\n\t\t{\n            if (Hitables[i].material.type == MATERIAL_EMISSION) {\n                return Hitables[i].material.Ke;\n            }\n            \n            //if (Hitables[i].type == HITABLE_TORUS) {\n            //    return Magenta;\n            //}\n            \n            vec3 N = normalize(h.N);\n            /*\n            vec3 N = normalize(h.N);            \n            vec3 R = reflect(r.direction, h.N);\n\t\t\tRay reflectedRay = sfCreateRay(h.P, R);\n            float NdotL = dot(R, h.N);\n            // shadow ray\n            if (sfClosestHit(reflectedRay, h)) {\n                return Hitables[i].material.Kd * 0.5;\n            }\n            vec3 color = sfShadeSky(reflectedRay);\n            */\n            return Hitables[i].material.Kd * 0.5 + (0.25 * N + 0.25);// + NdotL * color;// * NdotL * color;\n\t\t}\n\t}\n\treturn sfShadeSky(r);\n}\n\n\nRay sfCreateCameraRay(vec2 uv) {\n    vec3 eye = vec3(0.0, 0.0, 5.0);\n    vec3 center = vec3(0.0, 0.0, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    float aspectRatio = iResolution.x / iResolution.y;\n    float fovy = 45.0;\n    \n    float theta = fovy * FX_DEGREES_TO_RADIANS;\n    float halfHeight = tan(theta / 2.0f);\n    float halfWidth = aspectRatio * halfHeight;\n    float distanceToFocus = length(eye - center);\n    vec3 w = normalize(eye - center);\n    vec3 u = cross(up, w);\n    vec3 v = cross(w, u);\n    vec3 horizontal = 2.0 * distanceToFocus * halfWidth * u;\n    vec3 vertical = 2.0 * distanceToFocus * halfHeight * v;\n    vec3 lowerLeftCorner = eye\n        - (distanceToFocus*halfWidth) * u\n        - (distanceToFocus*halfHeight) * v\n        - distanceToFocus * w;\n    vec3 window = uv.s * horizontal + uv.t * vertical;\n    return sfCreateRay(eye, lowerLeftCorner + window - eye);\n}\n\n\nvec3 Sunfish(in Ray r)\n{\n    if (RenderMode == RAY_CAST) return sfRayCast(r);\n    if (RenderMode == RAY_TRACE) return sfRayTrace(r);\n    if (RenderMode == PATH_TRACE) return sfPathTrace(r);\n    return sfShadeSky(r);\n}\n\n\n// END SUNFISH GLSL RAY TRACER ///////////////////////////////////////\nfloat osc(float size, float phase) {\n    return size * sin(iTime + phase);\n}\n\nvoid CreateScene()\n{\n    float maxX = 8.0;\n    float maxX2 = 4.0;\n    vec3 offset = maxX * vec3(iMouse.xy / iResolution.xy, 0.0).xzy - maxX2;\n    offset.y += 4.0 + 0.025*sin(iTime);\n    //offset = vec3(0.0);\n\t//Hitables[0] = sfCreateSphere(offset + vec3(2.0, 0.0, 0.5), 0.5,\n\t//\tsfCreateMaterial(ArneWhite, ArneBlack, 0.0));\n    //Hitables[1] = sfCreateSphere(offset + vec3(-2.0, 0.0, 0.5), 0.5,\n    //    sfCreateMaterial(ArneRed, ArneRed, 0.0));\n\t//HitableCount = 2;\n\t//sfAddHitable(sfCreateSphere(offset + vec3(0.0, -1000.5, -0.5), 1000.0, sfCreateMaterial(ArneBrown, ArneBrown, 0.0)));\n    \n    //return;\n    sfAddHitable(sfCreatePlane(vec3(0.0, -5.0, 0.0),\n                               Up,\n                               sfCreateDiffuseMaterial(0.5*White, 0.0)));\n    sfAddHitable(sfCreateSphere(offset + vec3(2.0, 0.0, 0.5), 0.5,\n                                sfCreateMaterial(Blue, White, 0.0)));\n    sfAddHitable(sfCreateSphere(offset + vec3(-2.0, 0.0, 0.5), 0.5,\n                                sfCreateMaterial(Red, White, 0.0)));\n\n    \n    float x =  0.0;\n    float y = -0.5;\n    float z =  0.0;\n    float size = 1.0;\n    float lightSize = 0.2;\n    sfAddHitable(sfCreateRect(HITABLE_XZRECT,\n                              offset+vec3(x,y+0.99*size,z),\n                              vec3(-lightSize, 0.0, -lightSize),\n                              vec3( lightSize, 0.0,  lightSize),\n                              sfCreateEmissionMaterial(White)));\n    sfAddHitable(sfCreateRect(HITABLE_XZRECT,\n                              offset+vec3(x,y+size,z),\n                              0.5*vec3(-size, 0.0, -size),\n                              0.5*vec3( size, 0.0,  size),\n                              sfCreateDiffuseMaterial(White, 1.0)));\n    sfAddHitable(sfCreateRect(HITABLE_XZRECT,\n                              offset+vec3(x,y,z),\n                              0.5*vec3(-size, 0.0, -size),\n                              0.5*vec3( size, 0.0,  size),\n                              sfCreateDiffuseMaterial(White, 1.0)));\n    sfAddHitable(sfCreateRect(HITABLE_YZRECT,\n                              offset+vec3(x+size*0.5,y+size*0.5,z),\n                              0.5*vec3(0.5, -size, -size),\n                              0.5*vec3(0.5,  size,  size),\n                              sfCreateDiffuseMaterial(Green, 1.0)));\n    sfAddHitable(sfCreateRect(HITABLE_YZRECT,\n                              offset+vec3(x-size*0.5,y+size*0.5,z),\n                              0.5*vec3(0.5, -size, -size),\n                              0.5*vec3(0.5,  size,  size),\n                              sfCreateDiffuseMaterial(Red, 1.0)));\n    sfAddHitable(sfCreateRect(HITABLE_XYRECT,\n                              offset+vec3(x,y+size*0.5,z-size*0.5),\n                              0.5*vec3(-size, -size, 0.0),\n                              0.5*vec3( size,  size, 0.0),\n                              sfCreateDiffuseMaterial(White, 1.0)));\n    \n    \n    //sfAddHitable(sfCreateRect(HITABLE_XYRECT, offset+vec3(0.0,0.0,0.0), vec3(-0.5, -0.5,  0.0), vec3(0.5, 0.5, 0.0), sfCreateMaterial(Red, White, 1.0)));//sfCreateEmissionMaterial(White)));\n    //sfAddHitable(sfCreateRect(HITABLE_XZRECT, offset+vec3(0.0,0.5,0.5), vec3(-0.5,  0.0, -0.5), vec3(0.5, 0.0, 0.5), sfCreateMaterial(Green, White, 1.0)));\n    //sfAddHitable(sfCreateRect(HITABLE_YZRECT, offset+vec3(0.5,0.0,0.0), vec3( 0.0, -0.5, -0.5), vec3(0.0, 0.5, 0.5), sfCreateMaterial(Blue, White, 1.0)));\n    \n    //sfAddHitable(sfCreateTorus(vec3(0.0, 0.0, 5.0), 0.5, 0.125, sfCreateMaterial(Green, White, 1.0)));\n    //sfAddHitable(sfCreateBox(offset, -OneHalf, OneHalf, sfCreateMaterial(White, White, 1.0)));\n    //sfAddHitable(sfCreateSphere(offset + vec3(0.0, 4.0, 0.5), 0.25, sfCreateEmissionMaterial(White)));\n    //sfAddHitable(sfCreateCylinder(offset + vec3(1.0, osc(0.5, -0.5), 0.0), 0.5, 1.0, sfCreateMaterial(ArneBlue, White, 0.0)));\n    //sfAddHitable(sfCreateCone(offset + vec3(-1.0, -0.5, 0.0), 0.25, 1.0, sfCreateMaterial(ArneBlue, White, 0.0)));\n    //sfAddHitable(sfCreateDisk(offset + Zero, vec3(0.0, 0.5, 1.0), 0.25, sfCreateMaterial(Purple, White, 0.0)));\n    //sfAddLight(sfCreateLight(LIGHT_DIRECTION, Zero, vec3(1.0, 1.0, 1.0), 8.0*White));\n    sfAddHitable(sfCreateSuperquadric(offset, 0.25, sin(iTime) + 2.5, cos(iTime/3.14) + 1.5, sfCreateDiffuseMaterial(Blue, 1.0)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    srand(fragCoord.xy / iResolution.xy);\n    seed += iTime;\n    CreateScene();\n    Ray cameraRay = sfCreateCameraRay(0.5 * fragCoord.xy / iResolution.xy + 0.25);\n   \tfragColor = vec4(Sunfish(cameraRay), 1.0);\n\t// vec2 uv = fragCoord.xy / iResolution.xy;\n\t// fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 27,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "precision highp float;\n\n\n//////////////////////////////////////////////////////////////////////\n// S U N F I S H   R A Y   T R A C E R ///////////////////////////////\n//////////////////////////////////////////////////////////////////////\n// Copyright (C) 2018 Jonathan Metzgar                              //\n//////////////////////////////////////////////////////////////////////\n\n\nconst float FX_DEGREES_TO_RADIANS = 0.01745329;\nconst float FX_RADIANS_TO_DEGREES = 57.2957795;\n\nconst int SOLVER_MAX_ITERATIONS = 10;\nconst float SOLVER_MAX_ERROR = 0.01;\n\nconst float EPSILON = 1e-6;\nconst int MAX_PATH_DEPTH = 10;\nconst int MAX_HITABLES = 16;\nconst int MAX_LIGHTS = 4;\n\nconst int RAY_CAST = 0;\nconst int RAY_TRACE = 1;\nconst int PATH_TRACE = 2;\nconst int RenderMode = 0;\n\nconst int HITABLE_SPHERE = 0;\nconst int HITABLE_CYLINDER = 1;\nconst int HITABLE_PLANE = 2;\nconst int HITABLE_CONE = 3;\nconst int HITABLE_DISK = 4;\nconst int HITABLE_TORUS = 5;\nconst int HITABLE_BOX = 6;\nconst int HITABLE_XYRECT = 7;\nconst int HITABLE_XZRECT = 8;\nconst int HITABLE_YZRECT = 9;\nconst int HITABLE_SQUADRIC = 10;\n\nconst int LIGHT_POINT = 0;\nconst int LIGHT_DIRECTION = 1;\nconst int LIGHT_SPHERE = 2;\n\nconst int MATERIAL_DIFFUSE = 0;\nconst int MATERIAL_SPECULAR = 1;\nconst int MATERIAL_DIELECTRIC = 2;\nconst int MATERIAL_EMISSION = 3;\n\nconst int SKY_SHIRLEY = 0;\nconst int SKY_CUBEMAP = 1;\nconst int SKY_CUBEMAPBLUR = 2;\nconst int SKY_DAWN = 3;\nconst int SKY_NONE = 4;\nconst int iSkyMode = SKY_DAWN;\n\n\nconst vec3 Left = vec3(-1.0, 0.0, 0.0);\nconst vec3 Right = vec3(1.0, 0.0, 0.0);\nconst vec3 Up = vec3(0.0, 1.0, 0.0);\nconst vec3 Down = vec3(0.0, -1.0, 0.0);\nconst vec3 Forward = vec3(0.0, 0.0, 1.0);\nconst vec3 Backward = vec3(0.0, 0.0, -1.0);\nconst vec3 One = vec3(1.0, 1.0, 0.0);\nconst vec3 Zero = vec3(0.0, 0.0, 0.0);\nconst vec3 OneHalf = vec3(0.5, 0.5, 0.5);\nconst vec3 OneThird = vec3(1.0/3.0, 1.0/3.0, 1.0/3.0);\nconst vec3 OneFourth = vec3(0.25, 0.25, 0.25);\nconst vec3 OneFifth = vec3(1.0/5.0, 1.0/5.0, 1.0/5.0);\nconst vec3 TwoThirds = vec3(2.0/3.0, 2.0/3.0, 2.0/3.0);\nconst vec3 TwoFifths = vec3(2.0/5.0, 2.0/5.0, 2.0/5.0);\nconst vec3 ThreeFourths = vec3(0.75, 0.75, 0.75);\nconst vec3 ThreeFifths = vec3(3.0/5.0, 3.0/5.0, 3.0/5.0);\nconst vec3 FourFifths = vec3(4.0/5.0, 4.0/5.0, 4.0/5.0);\n\n\n//////////////////////////////////////////////////////////////////////\n// C O L O R S ///////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////\n\n\nconst vec3 Black = vec3(0.0, 0.0, 0.0);\nconst vec3 White = vec3(1.0, 1.0, 1.0);\nconst vec3 Red = vec3(1.0, 0.0, 0.0);\nconst vec3 Orange = vec3(1.0, 0.5, 0.0);\nconst vec3 Yellow = vec3(1.0, 1.0, 0.0);\nconst vec3 YellowGreen = vec3(0.5, 1.0, 0.0);\nconst vec3 Green = vec3(0.0, 1.0, 0.0);\nconst vec3 GreenBlue = vec3(0.0, 1.0, 0.5);\nconst vec3 Cyan = vec3(0.0, 1.0, 1.0);\nconst vec3 BlueGreen = vec3(0.0, 0.5, 1.0);\nconst vec3 Blue = vec3(0.0, 0.0, 1.0);\nconst vec3 Purple = vec3(0.5, 0.0, 1.0);\nconst vec3 Magenta = vec3(1.0, 0.0, 1.0);\nconst vec3 Rose = vec3(1.0, 0.0, 0.5);\nconst vec3 ArneBlack = vec3(0.0, 0.0, 0.0);\nconst vec3 ArneGray = vec3(0.616, 0.616, 0.616);\nconst vec3 ArneWhite = vec3(1.0, 1.0, 1.0);\nconst vec3 ArneRed = vec3(0.745, 0.149, 0.2);\nconst vec3 ArneMeat = vec3(0.878, 0.435, 0.545);\nconst vec3 ArneDarkBrown = vec3(0.286, 0.235, 0.169);\nconst vec3 ArneBrown = vec3(0.643, 0.392, 0.133);\nconst vec3 ArneOrange = vec3(0.922, 0.537, 0.192);\nconst vec3 ArneYellow = vec3(0.969, 0.886, 0.42);\nconst vec3 ArneDarkGreen = vec3(0.184, 0.282, 0.306);\nconst vec3 ArneGreen = vec3(0.267, 0.537, 0.102);\nconst vec3 ArneSlimeGreen = vec3(0.639, 0.808, 0.153);\nconst vec3 ArneNightBlue = vec3(0.106, 0.149, 0.196);\nconst vec3 ArneSeaBlue = vec3(0, 0.341, 0.518);\nconst vec3 ArneSkyBlue = vec3(0.192, 0.635, 0.949);\nconst vec3 ArneCloudBlue = vec3(0.698, 0.863, 0.937);\nconst vec3 ArneDarkBlue = vec3(0.204, 0.165, 0.592);\nconst vec3 ArneDarkGray = vec3(0.396, 0.427, 0.443);\nconst vec3 ArneLightGray = vec3(0.8, 0.8, 0.8);\nconst vec3 ArneDarkRed = vec3(0.451, 0.161, 0.188);\nconst vec3 ArneRose = vec3(0.796, 0.263, 0.655);\nconst vec3 ArneTaupe = vec3(0.322, 0.31, 0.251);\nconst vec3 ArneGold = vec3(0.678, 0.616, 0.2);\nconst vec3 ArneTangerine = vec3(0.925, 0.278, 0);\nconst vec3 ArneHoney = vec3(0.98, 0.706, 0.043);\nconst vec3 ArneMossyGreen = vec3(0.067, 0.369, 0.2);\nconst vec3 ArneDarkCyan = vec3(0.078, 0.502, 0.494);\nconst vec3 ArneCyan = vec3(0.082, 0.761, 0.647);\nconst vec3 ArneBlue = vec3(0.133, 0.353, 0.965);\nconst vec3 ArneIndigo = vec3(0.6, 0.392, 0.976);\nconst vec3 ArnePink = vec3(0.969, 0.557, 0.839);\nconst vec3 ArneSkin = vec3(0.957, 0.725, 0.565);\n\n\n//////////////////////////////////////////////////////////////////////\n// BEGIN SUNFISH GLSL RAY TRACER /////////////////////////////////////\n//////////////////////////////////////////////////////////////////////\n\n\nstruct Material {\n    vec3 Kd;\n    vec3 Ks;\n    vec3 Ke;\n    float indexOfRefraction;\n    float roughness;\n    int type;\n};\n\n\nstruct Hitable {\n    int type;      // see HITABLE_ constants at top of file\n    vec3 position; // for spheres, cylinders, and cones\n    float radius;  // for spheres, cylinders, and cones\n    float width;   // for rects\n    float height;  // for rects, cylinders and cones\n    float a;       // for torus\n    float b;       // for torus\n    float n;       // for superquadric ellipsoid/toroid\n    float e;       // for superquadric ellipsoid/toroid\n    vec3 box0;     // \n    vec3 box1;\n    vec3 normal;   // for planes\n    Material material;\n};\n    \n\nstruct Light {\n    int type;\n    vec3 position;\n    vec3 direction;\n    vec3 color;\n};\n\n    \nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\n    \nstruct HitRecord {\n    int i;    // which Hitable object\n    float t;  // Ray = x0 + t*x1\n    vec3 P;   // Point where ray intersects object\n    vec3 N;   // Geometric normal\n    vec3 UVW; // Texture Coordinates\n    vec3 Kd;  // Object color\n    int isEmissive;\n};\n    \n    \n    \n//////////////////////////////////////////////////////////////////////\n// S C E N E G R A P H ///////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////\n\n\nHitable Hitables[MAX_HITABLES];\nLight Lights[MAX_LIGHTS];\nint HitableCount = 0;    \nint LightCount = 0;\n\n\nvoid sfAddHitable(Hitable hitable)\n{\n    if (HitableCount >= MAX_HITABLES)\n        return;\n    for (int i = 0; i < MAX_HITABLES; i++)\n    {\n        if (i == HitableCount)\n        {\n            Hitables[i] = hitable;\n            HitableCount++;\n            break;\n        }\n    }\n}\n\n\nvoid sfAddLight(Light light)\n{\n    if (LightCount >= MAX_LIGHTS)\n        return;\n    for (int i = 0; i < MAX_LIGHTS; i++)\n    {\n        if (i == LightCount)\n        {\n            Lights[i] = light;\n            LightCount++;\n            break;\n        }\n    }\n}\n\n\n//////////////////////////////////////////////////////////////////////\n// M A T H E M A T I C S /////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////\n\n\nfloat seed = 0.0;\n\nvoid srand(vec2 fragCoord) {\n    seed = dot(fragCoord, vec2(12.9898,78.233));\n}\n\nfloat rand() {\n    seed = fract(sin(seed) * 43758.5453);\n\treturn seed;\n}\n\n    \nvec3 sfRayOffset(Ray r, float t)\n{\n    return r.origin + t * r.direction;\n}\n\n\nvec3 sfRandomDirection(vec3 N)\n{\n    return normalize(vec3(rand(), rand(), rand()) * N);\n}\n\n\nbool sfSolveQuadratic(in float a, in float b, in float c, out float t1, out float t2)\n{\n    float discriminant = b * b - 4.0 * a * c;\n    float denom = 2.0 * a;\n    if (denom != 0.0 && discriminant > 0.0) {\n        float s = sqrt(discriminant);\n        float r1 = (-b - s) / denom;\n        float r2 = (-b + s) / denom;\n        if (r1 < r2) {\n            t1 = r1;\n            t2 = r2;\n        }\n        else\n        {\n            t1 = r2;\n            t2 = r1;\n        }\n        return true;\n    }\n    return false;\n}\n\n\nbool sfNewtonQuadratic(vec3 abc, out float x)\n{\n    float xo = 0.0;\n    float a = abc.x;\n    float b = abc.y;\n    float c = abc.z;\n\n    for (int i = 0; i < SOLVER_MAX_ITERATIONS; i++) {\n        float xo2 = xo*xo;\n        float f = a*xo2 + b*xo + c;\n        if (f < SOLVER_MAX_ERROR) {\n            x = xo;\n            return true;\n        }\n        float g = 2.0*a*xo + 2.0*b;\n        xo = xo - f/g;\n    }\n    return false;\n}\n\n\nbool sfNewtonCubic(vec4 abcd, out float x)\n{\n    float xo = 0.0;\n    float a = abcd.x;\n    float b = abcd.y;\n    float c = abcd.z;\n    float d = abcd.w;\n\n    for (int i = 0; i < SOLVER_MAX_ITERATIONS; i++) {\n        float xo2 = xo*xo;\n        float xo3 = xo2*xo;\n        float f = a*xo3 + b*xo2 + c*xo + d;\n        if (f < SOLVER_MAX_ERROR) {\n            x = xo;\n            return true;\n        }\n        float g = 3.0*a*xo2 + 2.0*b*xo + c;\n        xo = xo - f/g;\n    }\n    return false;\n}\n\n\nbool sfNewtonQuartic(in vec4 bcde, out float x)\n{\n    float xo = 0.0;\n    float b = bcde.x;\n    float c = bcde.y;\n    float d = bcde.z;\n    float e = bcde.w;\n\n    for (int i = 0; i < SOLVER_MAX_ITERATIONS; i++) {\n        float xo2 = xo*xo;\n        float xo3 = xo2*xo;\n        float xo4 = xo2*xo2;\n        float f = xo4 + b*xo3 + c*xo2 + d*xo + e;\n        if (f < SOLVER_MAX_ERROR) {\n            x = xo;\n            return true;\n        }\n        float g = 4.0*xo3 + 3.0*b*xo2 + 2.0*c*xo + d;\n        xo = xo - f/g;\n    }\n    return false;\n}\n\n\n// solve depressed cubic\nbool sfSolveDCubic(vec2 pq, out vec2 roots)\n{\n    float p = pq.x;\n    float q = pq.y;\n    float discriminant = q*q - 4.0/27.0 * p*p*p;\n    if (discriminant < 0.0) return false;\n    if (discriminant < EPSILON) {\n        roots.x = -0.5 * q;\n        roots.y = 1e6;\n        return true;\n    }\n    \n    vec2 w = pow(vec2(-0.5 * (q - sqrt(discriminant)),\n                      -0.5 * (q + sqrt(discriminant))),\n                 vec2(1.0/3.0));\n    vec2 x = w - p / (3.0 * w);\n    \n    if (x.x < x.y) {\n        roots = x;\n    } else {\n        roots = x.yx;\n    }\n    return true;\n}\n\n\n/*\nbool sfSolveQuartic(vec4 bcde, out vec4 roots)\n{\n    float b = bcde.x;\n    float c = bcde.y;\n    float d = bcde.z;\n    float e = bcde.w;\n    const float inv27 = 1.0/27.0;\n    float b2 = b*b;\n    float c2 = c*c;\n    float delta0 = c*c - 3.0*b*d + 12.0*e;\n    float delta1 = 2.0*c*c*c - 9.0*b*c*d + 27.0*b*b*e + 27.0*d*d - 72.0*c*e;\n    float discriminant = inv27 * (4.0*pow(delta0, 3.0) - delta1*delta1);\n    if (discriminant > 0.0) {\n        // check if all roots are complex\n        float P = 8.0*c - 3.0*b2;\n        float D = 64.0*e + 16.0*(b2*c - c2 - b*d) - 3.0*b2*b2;\n        if (P < 0.0 && D < 0.0) return false;\n    }\n    // Convert to depressed quartic\n    // t^4 + pt^2 + qt + r = 0\n    float p = c - (3.0/8.0)*b2;\n    float q = 0.125 * (b2*b - 4.0*b*c + 8.0*d);\n    float r = (-3.0*b2*b2 + 256.0*e - 64.0*b*d + 16.0*b2*c) / (256.0);\n    float p2 = p*p;\n    float q2 = q*q;\n    \n    // solve for m, 8m^3 + 8pm^2 + (2p^2-ur)m - q^2 = 0\n    float cubic_pq = vec2(\n        -0.25 * p2 - 3.0*r,\n        -0.009259259*p2*p + 0.33333*p*r + 0.125*q2\n    );\n    vec2 cubic_roots;\n    if (!sfSolveDCubic(cubic_pq, cubic_roots))\n        return false;\n    \n    \n    \n    float phi = acos(delta1 / (2.0 * pow(delta1, 3.0/2.0)));\n    float cos_phi = cos(phi/3.0);\n    float S = 0.5 * sqrt(-0.66666 * (p + sqrt(delta0)*cos_phi));\n    discriminant = \n    roots.x = -0.25*b - S + 0.5*sqrt(-4.0*S*S - 2.0*p + q/S);\n    roots.y = -0.25*b - S - 0.5*sqrt(-4.0*S*S - 2.0*p + q/S);\n    roots.z = -0.25*b + S + 0.5*sqrt(-4.0*S*S - 2.0*p + q/S);\n    roots.w = -0.25*b + S - 0.5*sqrt(-4.0*S*S - 2.0*p + q/S);    \n    return true;\n}\n*/\n\n    \n//////////////////////////////////////////////////////////////////////\n// F A C T O R Y /////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////\n    \n\nMaterial sfCreateMaterial(vec3 Kd, vec3 Ks, float roughness)\n{\n    Material m;\n    m.Kd = Kd;\n    m.Ks = Ks;\n    m.Ke = Black;\n    m.roughness = roughness;\n    m.indexOfRefraction = 1.333;\n    m.type = MATERIAL_DIFFUSE;\n    return m;\n}\n\n\nMaterial sfCreateDiffuseMaterial(vec3 Kd, float roughness)\n{\n    Material m;\n    m.Kd = Kd;\n    m.Ks = White;\n    m.Ke = Black;\n    m.roughness = roughness;\n    m.indexOfRefraction = 1.0;\n    m.type = MATERIAL_DIFFUSE;\n    return m;\n}\n\n\nMaterial sfCreateSpecularMaterial(vec3 Ks, float roughness)\n{\n    Material m;\n    m.Kd = Black;\n    m.Ks = Ks;\n    m.Ke = Black;\n    m.roughness = roughness;\n    m.indexOfRefraction = 1.0;\n    m.type = MATERIAL_SPECULAR;\n    return m;\n}\n\n\nMaterial sfCreateDielectricMaterial(vec3 Kd, float indexOfRefraction)\n{\n    Material m;\n    m.Kd = Kd;\n    m.Ks = White;\n    m.Ke = Black;\n    m.roughness = 0.0;\n    m.indexOfRefraction = indexOfRefraction;\n    m.type = MATERIAL_DIELECTRIC;\n    return m;\n}\n\n\nMaterial sfCreateEmissionMaterial(vec3 Ke)\n{\n    Material m;\n    m.Kd = ArneBlack;\n    m.Ks = ArneBlack;\n    m.Ke = Ke;\n    m.roughness = 0.0;\n    m.indexOfRefraction = 1.0;\n    m.type = MATERIAL_EMISSION;\n    return m;\n}\n\n\nRay sfCreateRay(vec3 origin, vec3 dir)\n{\n    Ray r;\n    r.origin = origin;\n    r.direction = normalize(dir);\n    return r;\n}\n\n\nLight sfCreateLight(int type, vec3 position, vec3 direction, vec3 color)\n{\n    Light l;\n    l.type = type;\n    l.position = position;\n    l.direction = direction;\n    l.color = color;\n    return l;\n}\n\n\nHitRecord sfCreateHitRecord(float t, vec3 P, vec3 N)\n{\n    HitRecord h;\n    h.t = t;\n    h.P = P;\n    h.N = N;\n    return h;\n}\n\n\nHitable sfCreateSphere(vec3 position, float radius, Material material)\n{\n    Hitable h;\n    h.type = HITABLE_SPHERE;\n    h.position = position;\n    h.radius = radius;\n    h.material = material;\n    return h;\n}\n\n\nHitable sfCreatePlane(vec3 position, vec3 normal, Material material)\n{\n    Hitable h;\n    h.type = HITABLE_PLANE;\n    h.position = position;\n    h.normal = normalize(normal);\n    h.material = material;\n    return h;\n}\n\n\nHitable sfCreateDisk(vec3 position, vec3 normal, float radius, Material material)\n{\n    Hitable h;\n    h.type = HITABLE_DISK;\n    h.position = position;\n    h.normal = normalize(normal);\n    h.radius = radius;\n    h.material = material;\n    return h;\n}\n\n\nHitable sfCreateCylinder(vec3 position, float radius, float height, Material material)\n{\n    Hitable h;\n    h.type = HITABLE_CYLINDER;\n    h.position = position;\n    h.radius = radius;\n    h.height = height;\n    h.material = material;\n    return h;\n}\n\n\nHitable sfCreateCone(vec3 position, float radius, float height, Material material)\n{\n    Hitable h;\n    h.type = HITABLE_CONE;\n    h.position = position;\n    h.radius = radius;\n    h.height = height;\n    h.material = material;\n    return h;\n}\n\n\nHitable sfCreateTorus(vec3 position, float radiusA, float radiusB, Material material)\n{\n    Hitable h;\n    h.type = HITABLE_TORUS;\n    h.position = position;\n    h.radius = radiusA * radiusA;\n    h.height = radiusB * radiusB;\n    h.a = radiusB; // theoretically, we could support ellipses\n    h.b = radiusB; // and a is x-axis, b is y-axis\n    h.material = material;\n    return h;\n}\n\n\nHitable sfCreateSuperquadric(vec3 position, float radius, float n, float e, Material material)\n{\n    Hitable h;\n    h.type = HITABLE_SQUADRIC;\n    h.position = position;\n    h.radius = radius;\n    h.n = n;\n    h.e = e;\n    h.material = material;\n    return h;\n}\n\n\nHitable sfCreateBox(vec3 position, vec3 p1, vec3 p2, Material material)\n{\n    Hitable h;\n    h.type = HITABLE_BOX;\n    h.position = position;\n    h.box0 = min(p1, p2);\n    h.box1 = max(p1, p2);\n    h.material = material;\n    return h;\n}\n\n\nHitable sfCreateRect(int type, vec3 position, vec3 p1, vec3 p2, Material material)\n{\n    Hitable h;\n    h.type = type;\n    h.position = position;\n    h.box0 = min(p1, p2);\n    h.box1 = max(p1, p2);\n    h.material = material;\n    return h;\n}\n\n\n//////////////////////////////////////////////////////////////////////\n// I N T E R S E C T I O N S /////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////\n\n\nbool sfAnyHitSphere(Ray r, vec3 position, float radius, float thickness)\n{\n    vec3 O = r.origin - position;\n    vec3 D = r.direction;\n    float a = dot(D,D);\n    float b = dot(O,D);\n    float c = dot(O,O) - radius*radius;\n    float t1, t2;\n    if (!sfSolveQuadratic(a, b, c, t1, t2)) return false;\n    // DEBUG: ignore the slabs for now...\n    return true;\n    if (t1 > 0.0) {\n        vec3 p = sfRayOffset(r, t1);\n        if (p.y > position.y + thickness) return false;\n        if (p.y < position.y - thickness) return false;\n    }\n    if (t2 > 0.0) {\n        vec3 p = sfRayOffset(r, t2);\n        if (p.y > position.y + thickness) return false;\n        if (p.y < position.y - thickness) return false;\n    }\n    return true;\n}\n\n\nbool sfRayIntersectSphere(Hitable s, Ray r, float tMin, float tMax, out HitRecord h)\n{\n    vec3 originToCenter = r.origin - s.position;\n    // solve quadratic equation\n    float a = dot (r.direction, r.direction);\n    float b = dot(originToCenter, r.direction);\n    float c = dot(originToCenter, originToCenter) - s.radius*s.radius;\n    float discriminant = b*b - a*c;\n    if (discriminant > 0.0) {\n        float t = (-b - sqrt(discriminant)) / a;\n        if (t < tMax && t > tMin) {\n            h.t = t;\n            h.P = sfRayOffset(r, t);\n            h.N = (h.P - s.position) / s.radius;\n            return true;\n        }\n        t = (-b - sqrt(discriminant)) / a;\n        if (t < tMax && t > tMin) {\n            h.t = t;\n            h.P = sfRayOffset(r, t);\n            h.N = (h.P - s.position) / s.radius;\n            return true;\n        }\n    }\n    return false;\n}\n\n\nbool sfRayIntersectBox(Hitable s, Ray r, float tMin, float tMax, out HitRecord h)\n{    \n    // s.box0 and s.box1 are the minimum and maximum coordinates\n    vec3 O = r.origin - s.position;\n    vec3 D = r.direction;\n    vec3 diff = 0.5 * (s.box0 + s.box1);\n    vec3 planesN[6];\n    vec3 planesP[6];\n    planesN[0] = Left;\n    planesN[1] = Right;\n    planesN[2] = Up;\n    planesN[3] = Down;\n    planesN[4] = Backward;\n    planesN[5] = Forward;\n    planesP[0] = vec3(s.box0.x, diff.y, diff.z);\n    planesP[1] = vec3(s.box1.x, diff.y, diff.z);\n    planesP[2] = vec3(diff.x, s.box0.y, diff.z);\n    planesP[3] = vec3(diff.x, s.box1.y, diff.z);\n    planesP[4] = vec3(diff.x, diff.y, s.box0.z);\n    planesP[5] = vec3(diff.x, diff.y, s.box1.z);\n    vec3 Nmin;\n    vec3 Nmax;\n    float t0 = 1e6;\n    float t1 = 0.0;\n    float t = -1.0;\n    for (int i = 0; i < 6; i++) {\n        float cos_theta = dot(D, -planesN[i]);\n        if (cos_theta >= EPSILON) {\n            vec3 diff = planesP[i] - O;\n            float t = dot(diff, -planesN[i]) / cos_theta;\n            if (t < t0) {\n                Nmin = planesN[i];\n                t0 = t;\n            }\n            if (t > t1) {\n                Nmax = planesN[i];\n                t1 = t;\n            }\n        } else if (-cos_theta >= EPSILON) {\n            vec3 diff = planesP[i] - O;\n            float t = dot(diff, planesN[i]) / -cos_theta;\n            if (t < t0) {\n                Nmin = -planesN[i];\n                t0 = t;\n            }\n            if (t > t1) {\n                Nmax = -planesN[i];\n                t1 = t;\n            }\n        }\n    }\n    if (t0 > t1) return false;\n    if (t0 > tMin && t0 < tMax) {\n        h.t = t0;\n        h.P = sfRayOffset(r, t0);\n        h.N = Nmin;\n        return true;\n    }\n    if (t1 > tMin && t1 < tMax) {\n        h.t = t0;\n        h.P = sfRayOffset(r, t0);\n        h.N = Nmax;\n        return true;\n    }\n    return false;\n}\n\n\nbool sfRayIntersectPlane(Hitable s, Ray r, float tMin, float tMax, out HitRecord h)\n{\n    float cos_theta = dot(r.direction, -s.normal);\n    if (abs(cos_theta) >= EPSILON) {\n        vec3 diff = s.position - r.origin;\n        float t = dot(diff, -s.normal) / cos_theta;\n        if (t > tMin && t < tMax) {\n            h.t = t;\n            h.P = sfRayOffset(r, t);\n            h.N = cos_theta > 0.0 ? s.normal : -s.normal;\n            return true;\n        }        \n    }\n    return false;\n}\n\n\nbool sfRayIntersectDisk(Hitable s, Ray r, float tMin, float tMax, out HitRecord h)\n{\n    float cos_theta = dot(r.direction, -s.normal);\n    if (cos_theta >= EPSILON) {\n        vec3 diff = s.position - r.origin;\n        float t = dot(diff, -s.normal) / cos_theta;\n        vec3 p = sfRayOffset(r, t);\n        bool inside = sqrt(dot(p, p)) <= s.radius;\n        if (t > tMin && t < tMax && inside) {\n            h.t = t;\n            h.P = sfRayOffset(r, t);\n            h.N = cos_theta > 0.0 ? -s.normal : s.normal;\n            return true;\n        }        \n    }\n    return false;\n}\n\n\nbool sfRayIntersectCone(Hitable s, Ray r, float tMin, float tMax, out HitRecord h)\n{\n    float root1 = -1.0;\n    float root2 = -1.0;\n    vec3 D = r.direction;\n    vec3 E = r.origin - s.position;\n    E.y -= s.height;\n    float a = D.x*D.x/s.radius + D.z*D.z/s.radius - D.y*D.y;\n    float b = 2.0 * (D.x*E.x/s.radius + D.z*E.z/s.radius - D.y*E.y);\n    float c = E.x*E.x/s.radius + E.z*E.z/s.radius - E.y*E.y;\n    if (!sfSolveQuadratic(a, b, c, root1, root2)) {\n        return false;\n    }\n    float t;\n    if (root1 > 0.0)\n        t = root1;\n    else\n        t = root2;\n    if (t < EPSILON)\n        return false;\n    if (t > tMin && t < tMax) {\n        vec3 P = sfRayOffset(r, t);\n        if (P.y < s.position.y) return false;\n        if (P.y > s.position.y + s.height) return false;\n        vec3 N = vec3(P.x - s.position.x, 0.0, P.z - s.position.z);\n        h.t = t;\n        h.P = P;\n        h.N = N;\n        return true;\n    }\n    \n    return false;\n}\n\n\nbool sfRayIntersectCylinder(Hitable s, Ray r, float tMin, float tMax, out HitRecord h)\n{\n    float root1 = -1.0;\n    float root2 = -1.0;\n    vec2 rdir = r.direction.xz;\n    vec2 rpos = r.origin.xz - s.position.xz;\n    float a = dot(rdir, rdir);\n    float b = 2.0 * dot(rpos, rdir);\n    float c = dot(rpos, rpos) - s.radius*s.radius;\n    if (!sfSolveQuadratic(a, b, c, root1, root2)) {\n        return false;\n    }\n    float t;\n    if (root1 > 0.0)\n        t = root1;\n    else\n        t = root2;\n    if (t < EPSILON)\n        return false;\n    if (t > tMin && t < tMax) {\n        vec3 P = sfRayOffset(r, t);\n        if (P.y < s.position.y) return false;\n        if (P.y > s.position.y + s.height) return false;\n        vec3 N = vec3(P.x - s.position.x, 0.0, P.z - s.position.z);\n        h.t = t;\n        h.P = P;\n        h.N = N;\n        return true;\n    }\n    \n    return false;\n}\n\n\nbool sfRayIntersectTorus(Hitable s, Ray r, float tMin, float tMax, out HitRecord h)\n{\n    float thickness = max(s.a, s.b);\n\t//if (!sfAnyHitSphere(r, s.position, s.radius + thickness, thickness))\n    //    return false;\n    vec3 O = r.origin - s.position;\n    vec3 D = r.direction;\n    float DZ2 = D.z * D.z;\n    float OZ2 = O.z * O.z;\n    float ODZ = O.z * D.z;\n    float D2 = dot(D, D);\n    float O2 = dot(O, O);\n    float OD = dot(O, D);\n    float a2 = s.radius * s.radius;\n    float b2 = 0.25 * a2;\n    float M = (O2 - (a2 + b2));\n    float N = dot(O, D);\n    float a = 1.0;\n    float b = 4.0 * N;\n    float c = 2.0 * M + 2.0 * N - 4.0 * a2 * DZ2;\n    float d = 4.0 * N * M - 8.0 * a2 * ODZ;\n    float e = M - 4.0 * a2 * (b2 - OZ2);\n    vec4 bcde = vec4(b,c,d,e);\n    vec4 roots = vec4(1e6);\n    float t = 1.0;\n    //if (!sfSolveQuartic(bcde, roots)) return false;\n    if (!sfNewtonQuartic(bcde, t)) return false;\n    if (t > tMin && t < tMax) {\n        h.t = t;\n        h.P = sfRayOffset(r, t);\n        float d = sqrt(h.P.x*h.P.x + h.P.z*h.P.z);\n        float f = 2.0 * (d - s.radius) / (d * s.a*s.a);\n        //h.N = vec3(h.P.x, f, h.P.z);//normalize(h.P - s.position);\n        h.N = vec3(sin(a), cos(b), sin(c));\n        return true;\n    }\n    return false;\n}\n\n\nbool sfRayIntersectXYRect(Hitable s, Ray r, float tMin, float tMax, out HitRecord h)\n{\n    vec3 O = r.origin - s.position;\n    vec3 D = r.direction;\n    float t = -O.z / D.z;\n    if (t < tMin || t > tMax)\n        return false;\n    \n    vec3 P = O + t * D;\n    if (P.x < s.box0.x || P.x > s.box1.x ||\n        P.y < s.box0.y || P.y > s.box1.y)\n        return false;\n    \n    h.t = t;\n    h.P = sfRayOffset(r, t);\n    h.N = D.z > 0.0 ? Forward : Backward;\n    h.UVW = vec3((P.xy - s.box0.xy) / (s.box1.xy - s.box0.xy), 0.0);\n    return true;\n}\n\n\nbool sfRayIntersectXZRect(Hitable s, Ray r, float tMin, float tMax, out HitRecord h)\n{\n    vec3 O = r.origin - s.position;\n    vec3 D = r.direction;\n    float t = -O.y / D.y;\n    if (t < tMin || t > tMax)\n        return false;\n    \n    vec3 P = O + t * D;\n    if (P.x < s.box0.x || P.x > s.box1.x ||\n        P.z < s.box0.z || P.z > s.box1.z)\n        return false;\n    \n    h.t = t;\n    h.P = sfRayOffset(r, t);\n    h.N = D.y > 0.0 ? Up : Down;\n    h.UVW = vec3((P.xz - s.box0.xz) / (s.box1.xz - s.box0.xz), 0.0);\n    return true;\n}\n\n\nbool sfRayIntersectYZRect(Hitable s, Ray r, float tMin, float tMax, out HitRecord h)\n{\n    vec3 O = r.origin - s.position;\n    vec3 D = r.direction;\n    float t = -O.x / D.x;\n    if (t < tMin || t > tMax)\n        return false;\n    \n    vec3 P = O + t * D;\n    if (P.y < s.box0.y || P.y > s.box1.y ||\n        P.z < s.box0.z || P.z > s.box1.z)\n        return false;\n    \n    h.t = t;\n    h.P = sfRayOffset(r, t);\n    h.N = D.x > 0.0 ? Left : Right;\n    h.UVW = vec3((P.yz - s.box0.yz) / (s.box1.yz - s.box0.yz), 0.0);\n    return true;\n}\n\nfloat sphereSDF(vec3 p) {\n    return length(p) - 1.0;\n}\n\nfloat sphSDF(vec3 p, Hitable s) {\n    float m = max(s.e, s.n);\n    float a = pow(abs(p.x), m);\n    float b = pow(abs(p.y), m);\n    float c = pow(abs(p.z), m);\n    return (pow(a + b + c, 1.0/m) - 1.0);\n}\n\nvec3 sphNormalSDF(vec3 p, Hitable s) {\n    return normalize(vec3(\n        sphSDF(vec3(p.x + EPSILON, p.y, p.z), s) - sphSDF(vec3(p.x - EPSILON, p.y, p.z), s),\n        sphSDF(vec3(p.x, p.y + EPSILON, p.z), s) - sphSDF(vec3(p.x, p.y - EPSILON, p.z), s),\n        sphSDF(vec3(p.x, p.y, p.z + EPSILON), s) - sphSDF(vec3(p.x, p.y, p.z - EPSILON), s)));\n    \n}\n\nvec3 sphereNormalSDF(vec3 p) {\n    return normalize(vec3(\n        sphereSDF(vec3(p.x + EPSILON, p.y, p.z)) - sphereSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sphereSDF(vec3(p.x, p.y + EPSILON, p.z)) - sphereSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sphereSDF(vec3(p.x, p.y, p.z + EPSILON)) - sphereSDF(vec3(p.x, p.y, p.z - EPSILON))));\n}\n\nbool sfRayIntersectSuperquadric(Hitable s, Ray r, float tMin, float tMax, out HitRecord h)\n{\n    vec3 O = r.origin - s.position;\n    vec3 D = r.direction;\n    float t = tMin;\n    const int MAX_RAY_STEPS = 10;\n    for (int i = 0; i < MAX_RAY_STEPS; i++) {\n        vec3 P = O + t * D;\n        //float d = sphereSDF(P / s.radius) * s.radius;\n        float d = sphSDF(P/s.radius, s)*s.radius;\n        if (d < EPSILON) {\n            h.t = t;\n            h.P = sfRayOffset(r, t);\n            h.N = -sphNormalSDF(P, s);\n            return true;\n        }\n        t += d;\n        if (t > tMax) {\n            return false;\n        }\n    }\n    return false;\n}\n\n\nbool sfRayIntersect(Hitable s, Ray r, float tMin, float tMax, out HitRecord h)\n{\n    if (s.type == HITABLE_SPHERE) {\n        return sfRayIntersectSphere(s, r, tMin, tMax, h);\n    }\n    if (s.type == HITABLE_BOX) {\n        return sfRayIntersectBox(s, r, tMin, tMax, h);\n    }\n    if (s.type == HITABLE_PLANE) {\n        return sfRayIntersectPlane(s, r, tMin, tMax, h);\n    }\n    if (s.type == HITABLE_SQUADRIC) {\n        return sfRayIntersectSuperquadric(s, r, tMin, tMax, h);\n    }\n    if (s.type == HITABLE_DISK) {\n        return sfRayIntersectDisk(s, r, tMin, tMax, h);\n    }\n    if (s.type == HITABLE_CONE) {\n        return sfRayIntersectCone(s, r, tMin, tMax, h);\n    }\n    if (s.type == HITABLE_CYLINDER) {\n        return sfRayIntersectCylinder(s, r, tMin, tMax, h);\n    }\n    if (s.type == HITABLE_TORUS) {\n        return sfRayIntersectTorus(s, r, tMin, tMax, h);\n    }\n    if (s.type == HITABLE_XYRECT) {\n        return sfRayIntersectXYRect(s, r, tMin, tMax, h);\n    }\n    if (s.type == HITABLE_XZRECT) {\n        return sfRayIntersectXZRect(s, r, tMin, tMax, h);\n    }\n    if (s.type == HITABLE_YZRECT) {\n        return sfRayIntersectYZRect(s, r, tMin, tMax, h);\n    }\n    return false;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}