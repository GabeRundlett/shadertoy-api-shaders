{
    "Shader": {
        "info": {
            "date": "1720226068",
            "description": "More neighbor checking with noise and truchets to build this weird layer thing. ",
            "flags": 0,
            "hasliked": 0,
            "id": "43VXRK",
            "likes": 13,
            "name": "Byt3-daily-007",
            "published": 3,
            "tags": [
                "2d",
                "noise",
                "truchet",
                "tiles"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 162
        },
        "renderpass": [
            {
                "code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    Byt3-daily-006\n    Layers of truchets amd FBM. Using the same neighbor checking to cap the tile patterns.\n    Was neat looking.\n\n    Noise and FBM @Shane & @IQ\n     \n    07/05/2024  @byt3_m3chanic\n    \n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n#define PI          3.141592653\n#define PI2         6.283185307\n\nmat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat hash21(vec2 a){ return fract(sin(dot(a,vec2(22.54,35.45)))*4823.232);}\nfloat box(vec2 p, vec2 a) {vec2 q=abs(p)-a;return length(max(q,0.))+min(max(q.x,q.y),0.);}\n\nmat2 r45,n45;\n\n//@iq hsv\nvec3 hsv( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*2.+vec3(0,4,2),6.)-3.)-1., 0., 1.0 );\n    return c.z * mix( vec3(1), rgb, c.y);\n}\n\n// @Shane - a very tightly compacted, self-contained version \n// of IQ's 3D value noise function.\n//---------------------------------------------------------------\nfloat n3D(vec3 p){\n    const vec3 s = vec3(113, 57, 27);\n    vec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n// @iq fbm generator\nfloat fbm3( in vec3 x) {\n\n    x*=.1;\n    float a = 0.1,b = .5,f = 2.;\n    vec3  d = vec3(0.);\n    for (int i = 0; i < 4; ++i) {      \n        float n = n3D(f*x);\n        a += b*n;\n        b *= 0.5;\n        f *= 1.8;\n    }\n\treturn a;\n}\n\nfloat truchet(vec2 p, float ff) {\n    vec2 uv = p;\n    \n    vec2 id = floor(uv), q = fract(uv)-.5, suv = q;\n    float hs = hash21(id+ff+ff);\n\n    const float sx = .175;\n    // cheap check of the hood\n    float tm = ff+(T*1.5);\n    float ns = fbm3(vec3(id*sx,tm));\n    vec4 hhs = vec4(\n        fbm3(vec3((id+vec2(0,-1))*sx,tm)),\n        fbm3(vec3((id+vec2(1,0))*sx,tm)),\n        fbm3(vec3((id+vec2(0,1))*sx,tm)),\n        fbm3(vec3((id+vec2(-1,0))*sx,tm))\n    );\n    \n    float rnd = fract(hs*4324.79);\n    if(rnd>.5) q.xy*= rot(1.5707);\n    \n    const float pf = .353, wd = .2;\n    vec2 q2 = q; q *= r45;\n    \n    // main pattern\n    float pq = length(q.x+pf)<length(q.x-pf)? q.x+pf : q.x-pf;\n    float d = length(pq);\n    d = abs(d) - wd;\n\n    // edge block check and patterns\n    const float thr = .6;\n    if(ns<thr) {\n        d = 1.;\n        // prob could do better with logic but first stab at it..\n        if(rnd>.5) q2 *= rot(-1.5707);\n        \n        if(hhs.x>thr) {\n            vec2 k1 = q2+vec2(0,.575);\n            k1*=r45;\n            d = min(box(k1,vec2(wd*1.35)), d);\n        }\n        \n        if(hhs.z>thr) {\n            vec2 k2 = q2-vec2(0,.575);\n            k2*=r45;\n            d = min(box(k2,vec2(wd*1.35)), d);\n        }\n        \n        if(hhs.y>thr) {\n            vec2 k3 = q2-vec2(.575,0);\n            k3*=r45;\n            d = min(box(k3,vec2(wd*1.35)), d);\n        }\n        \n        if(hhs.w>thr) {\n            vec2 k4 = q2+vec2(.575,0);\n            k4*= r45;\n            d = min(box(k4,vec2(wd*1.35)), d);\n        }\n\n        if(hhs.x>thr&&hhs.y>thr&&hhs.z<thr&&hhs.w<thr) d = rnd<.5? abs(length(q.y+pf) ) - wd : abs(length(q.x+pf) ) - wd;\n        if(hhs.z>thr&&hhs.w>thr&&hhs.x<thr&&hhs.y<thr) d = rnd<.5? abs(length(q.y-pf) ) - wd : abs(length(q.x-pf) ) - wd;\n        if(hhs.w>thr&&hhs.x>thr&&hhs.z<thr&&hhs.y<thr) d = rnd>.5? abs(length(q.y-pf) ) - wd : abs(length(q.x+pf) ) - wd;\n        if(hhs.z>thr&&hhs.y>thr&&hhs.w<thr&&hhs.x<thr) d = rnd>.5? abs(length(q.y+pf) ) - wd : abs(length(q.x-pf) ) - wd;\n    }\n\n    return d;\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n    r45 = rot(.7853981634);\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y); \n    vec2 vv = uv;\n\n    float px = fwidth(uv.x); \n\n    vec3 C = vec3(0);\n\n    vv *= 242.;\n    \n    for(float i=1.;i<24.;i++) {\n\n        vec3 h = mod(i,2.)<1.? vec3(.65-(2.1/i)):hsv(vec3((i*.075)+T*.1,.95,1.-(1.75/i)));\n\n        vv *= .945;\n        vv.y-=.5;\n\n        float d = truchet(vv+vec2(0,T*3.3),i*.33);\n\n        px = fwidth(vv.x);\n        C = mix(C,C*.2,smoothstep(.02+px,-px,d-.15));\n        C = mix(C,h,smoothstep(px,-px,d));\n    }\n\n    // gamma and output\n    C = pow(C,vec3(.4545));\n    O = vec4(C,1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}