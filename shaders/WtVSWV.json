{
    "Shader": {
        "info": {
            "date": "1583627052",
            "description": "Final Project of Graphics",
            "flags": 32,
            "hasliked": 0,
            "id": "WtVSWV",
            "likes": 2,
            "name": "Final Project of Graphics -- YR",
            "published": 3,
            "tags": [
                "yr"
            ],
            "usePreview": 0,
            "username": "Yaorui",
            "viewed": 274
        },
        "renderpass": [
            {
                "code": "#define BALLNUM 3\nconst int numberOfSampling = 10;\n\nvec4 LoadCap(int ind)\n{\n    float fi = float(ind) + 3. * txSize;\n    return texture (iChannel2, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     BUF_SIZE);\n}\n\nvec4 LoadParticle (int ind)\n{\n  float fi = float(ind);\n  //return texelFetch(iChannel2, ivec2(mod(fi, txRow), floor(fi / txRow)), 0);\n  return texture (iChannel2, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     BUF_SIZE);\n}\n\nvec3 bgColor(const ray r){\n    float theta = atan(r.dir.z, r.dir.x);\n    float phi = asin(r.dir.y/length(r.dir));\n    \n    vec2 p = vec2(theta/2., phi);\n    \n    float octaves = 8.;\n    float H = 1.;\n    float f = 0.5 + 0.5 * snoise(p);\n    \n    f = fractalSum(p, 2., H, octaves);\n    \n    float marble = 0.5 * sin(50. * p.y + 145.*f + iTime * 0.5) + 0.5;\n    \n    return mix(vec3(0.9), mix(vec3(0.3, 0.5, 1.0), vec3(0.0, 0.3, 1.0), (phi+M_PI/2.)/M_PI), marble);\n}\n\nhit hitSphere(const ray r, const sphere s){\n    vec3 o2o = r.ori - s.ori;\n    float a = dot(r.dir, r.dir);\n    float b = 2.0 * dot(o2o, r.dir);\n    float c = dot(o2o, o2o) - s.r*s.r;\n    float delta = b*b - 4.0*a*c;\n    if(delta<0.0){\n            // no solution, return dummy\n        return  dummyHit;\n    }\n    else {\n        float sqrtDelta = sqrt(delta);\n        float t;\n        float temp = (-b-sqrtDelta)/(2.*a);\n        if(temp > minT){t = temp;}\n        else {t = (-b+sqrtDelta)/(2.*a);}\n        if(t < minT)return dummyHit;\n        vec3 hitP = r.ori + t*r.dir;\n        return hit(t, hitP, (hitP-s.ori)/s.r, s.mat);\n    }\n}\n\n\nhit hitCylinder(const ray r,cylinder cld){\n    vec3 o2o = r.ori - cld.ori;\n    float a = dot(r.dir.yz, r.dir.yz);\n    float b = 2.0 * dot(o2o.yz, r.dir.yz);\n    float c = dot(o2o.yz, o2o.yz) - cld.r*cld.r;\n    float delta = b*b - 4.0*a*c;\n    if(delta<0.0){\n        return  dummyHit;\n    }\n    else {\n        float sqrtDelta = sqrt(delta);\n        float t;\n        float temp = (-b-sqrtDelta)/(2.*a);\n        if(temp > 0.01){t = temp;}\n        else {t = (-b+sqrtDelta)/(2.*a);}\n        if(t < 0.01)return dummyHit;\n        vec3 hitP = r.ori + t*r.dir;\n        return hit(t, hitP, normalize(vec3(0, (hitP-cld.ori).yz)), cld.mat);\n    }\n}\n\nhit hitCap(const ray r, const cap cp, int cId){\n    vec3 o2o = r.ori - cp.ori;\n    float a = dot(r.dir, r.dir);\n    float b = 2.0 * dot(o2o, r.dir);\n    float c = dot(o2o, o2o) - cp.r2*cp.r2;\n    float delta = b*b - 4.0*a*c;\n    if(delta<0.0){\n            // no solution, return dummy\n        return  dummyHit;\n    }\n    else {\n        float sqrtDelta = sqrt(delta);\n        float t1 = (-b-sqrtDelta)/(2.*a);\n        float t2 = (-b+sqrtDelta)/(2.*a);\n        \n        if(t2 < minT){\n            return dummyHit;\n        }\n        \n        float dirCos = dot(cp.norm,r.dir)/ length(r.dir);\n        float sOri2Plane = sqrt(cp.r2*cp.r2 - cp.r1*cp.r1);\n        float rOri2Plane = dot(r.ori - cp.ori, cp.norm) - sOri2Plane;\n        \n        hit hit1 = dummyHit;\n        if(rOri2Plane < 0. && dirCos > 0. || rOri2Plane > 0. && dirCos < 0.){\n            float t =  rOri2Plane/dirCos /length(r.dir);\n            t = abs(t);\n            vec3 hitP = r.ori + t* r.dir;\n            vec3 center = cp.ori + cp.norm * sOri2Plane;\n            vec2 uv = (hitP.xy - center.xy + vec2(cp.r1))/cp.r1/2.*vec2(iResolution.y);\n            if(t > minT && length(hitP - (cp.ori + sOri2Plane * cp.norm)) < cp.r1){\n                hit1 = hit(t, hitP, -cp.norm, cp.mat);\n                vec4 col = texture (iChannel3, getUvForCap(iResolution.xy, uv, cId));\n                if(col.r * col.a > 0.2){\n                    if(cId == 0){\n                        hit1.mat = material(LAMBERTIAN,col.a * vec3(1.0,0.7,0.0), 0.);\n                    }else if(cId == 1){\n                        hit1.mat = material(LAMBERTIAN,col.a * vec3(0.1,0.3,0.8), 0.);\n                    }\n                    else if(cId == 2){\n                        hit1.mat = material(LAMBERTIAN,col.a * vec3(0.9,0.3,0.3), 0.);\n                    }\n                }\n            }\n        }\n        \n        if(t1 > minT){\n            vec3 hitP = r.ori + t1*r.dir;\n            float dist2Plane = dot(hitP - cp.ori, cp.norm) - sOri2Plane;\n            if(dist2Plane > 0.){\n                if(hit1.t > -1. && hit1.t < t1)\n                    return hit1;\n                else \n                    return hit(t1, hitP, (hitP-cp.ori)/cp.r2, cp.mat);\n            }       \n            if(hit1.t > -1.)\n                return hit1;\n        }\n\n        vec3 hitP = r.ori + t2*r.dir;\n        float dist2Plane = dot(hitP - cp.ori, cp.norm) - sOri2Plane;\n        if(dist2Plane > 0.){\n            if(hit1.t > -1. && hit1.t < t2)\n                return hit1;\n            else \n                return hit(t2, hitP, (hitP-cp.ori)/cp.r2, cp.mat);\n        }\n        if(hit1.t > -1.)\n            return hit1; \n        return dummyHit;\n    }\n}\n\nvec3 color(ray r, cap[BALLNUM] cp, cylinder cld){\n    vec3 col = vec3(1);\n    int depth = 8;\n    while(depth != 0){\n            hit h = dummyHit;\n        for(int i = 0; i < cp.length(); i++){\n                hit tempH = hitCap(r, cp[i], i);\n            if(tempH.t > 0. && (h.t < 0. || h.t > tempH.t)){\n                    float newSeed = g_seed * float(depth);\n                h = tempH;\n                //if(h.t > minT && dot(h.normal, r.dir) > 0.)col *= vec3(1.0, 0, 0);\n            }\n        }\n        \n        hit tempH = hitCylinder(r, cld);\n        if(tempH.t > 0. && (h.t < 0. || h.t > tempH.t)){\n            float newSeed = g_seed * float(depth);\n            h = tempH;\n        }\n                \n        if(h.t > 0.){\n               vec3 scatter = r.dir;\n           float newSeed = g_seed * float(depth); // This would give the result a constant look\n            //float newSeed = g_seed * iTime; // This would give the result a changing look\n           if(h.mat.type == LAMBERTIAN){\n                   scatter = normalize(h.normal) + normalize(random_in_unit_sphere(newSeed));\n               col *= h.mat.albedo;\n            }\n            else if(h.mat.type == METAL){\n                   vec3 reflectDir = reflect(normalize(r.dir), normalize(h.normal));\n               reflectDir =normalize(reflectDir)+ h.mat.roughness * normalize(random_in_unit_sphere(newSeed));\n               if(dot(reflectDir, h.normal) < 0.){\n                       col = vec3(0);\n                   break;\n                }\n               else{\n                   col *= h.mat.albedo;\n                   scatter = reflectDir;\n               }\n            }\n            else if(h.mat.type == DIELECTRIC){\n                    vec3 outNorm;\n                float ni2nt;  \n                float cosine;\n                if(dot(r.dir, h.normal) > 0.){\n                        //col = vec3(1000,0,0);\n                    outNorm = -h.normal;\n                    ni2nt = h.mat.roughness;\n                    cosine = ni2nt * dot(normalize(r.dir), normalize(h.normal));\n                    \n                }\n                else{\n                        outNorm = h.normal;\n                    ni2nt = 1.0/h.mat.roughness;\n                    cosine = -dot(normalize(r.dir), normalize(h.normal));\n                }\n                vec3 reflectDir = reflect(normalize(r.dir), normalize(h.normal));\n                vec3 refractDir = refract(normalize(r.dir), normalize(outNorm),ni2nt);\n                float reflectProb = 0.;               \n                if(length(refractDir) > 0.0001){\n                        reflectProb = schlick(cosine, ni2nt);\n                }\n                else{\n                        reflectProb = 1.;\n                }\n                if(rand1(newSeed) > reflectProb){\n                        //if(dot(refractDir, h.normal)<0.)col*=vec3(1, 0, 0);\n                    scatter = refractDir;\n                }\n                else{\n                        scatter = reflectDir;\n                }\n            }\n            r = ray(h.p, scatter);\n            depth--;\n        }\n        else {\n                col *= bgColor(r);\n            break;\n        }\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;       \n    camera c = getCamera(ic, iResolution.xy);\n    \n    cp[0] = cap(LoadCap(0).xyz, .5, 5., vec3(0, 0, 1), material(DIELECTRIC,vec3(1), 1.5));\n    cp[1] = cap(LoadCap(1).xyz, .5, 5., vec3(0, 0, 1), material(DIELECTRIC,vec3(1), 1.5));\n    cp[2] = cap(LoadCap(2).xyz, .5, 5., vec3(0, 0, 1), material(DIELECTRIC,vec3(1), 1.5));\n    \n    cylinder cld = cylinder(vec3(0, 0, 4), 0.05, material(METAL,vec3(0.8), 0.8));\n    \n    // Here I use i to get differnet seeds for each run\n    \n    \n    vec3 resultCol = vec3(0);\n    for(int i = 0; i < numberOfSampling; i++){\n        // Here I use i to get differnet seeds for each run\n        init_rand(fragCoord, float(i));\n        vec2 random = rand2(g_seed);\n        ray r = getRay(c, uv + random/iResolution.xy);\n        resultCol += color(r, cp, cld)/ float(numberOfSampling);\n    }\n    \n    fragColor = vec4(pow(resultCol,vec3(1.0/2.2)), 1.0);\n    //fragColor = texture (iChannel1, fragCoord/iResolution.xy);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define LAMBERTIAN 0\n#define METAL 1\n#define DIELECTRIC 2\n#define M_PI 3.1415925585\n\n#define CAPNUM 3\n\n\nconst float minT = 0.0001;\nconst float maxT = 1e8;\n\n// a Better camera structure\nstruct iCamera{\n    vec3 lookFrom;\n    vec3 lookAt;\n    vec3 up;\n    float fov;\n    float aperture;\n};\n    \nstruct camera{\n    vec3 origin;\n    vec3 horizontal;\n    vec3 vertical;\n    vec3 LowerLeftCorner;\n    float focusDist;\n    float aperture;\n};\n    \ncamera getCamera(iCamera ic, vec2 iResolution){\n    vec3 lookDir = ic.lookFrom-ic.lookAt;\n    float focusDist = length(lookDir);\n    lookDir = normalize(lookDir);\n    vec3 horizontal = normalize(cross(ic.up, lookDir));\n    vec3 vertical = normalize(cross(lookDir, horizontal));\n    float halfHeight = tan(ic.fov*M_PI/360.);\n    float halfWidth = halfHeight * iResolution.x / iResolution.y;\n    vec3 lowerLeftCorner = ic.lookFrom - halfWidth*horizontal*focusDist - halfHeight*vertical*focusDist - lookDir*focusDist;\n    horizontal *= 2. * halfWidth;\n    vertical *= 2. * halfHeight;\n    camera c = camera(ic.lookFrom, horizontal, vertical, lowerLeftCorner, focusDist, ic.aperture);\n    return c;\n}\n\nstruct ray{\n    vec3 ori;\n    vec3 dir;\n};\n    \nstruct material{\n        int type;\n    vec3 albedo;\n    float roughness;\n};\n\n\nstruct sphere{\n    vec3 ori;\n    float r;\n    material mat;\n};\n    \nstruct cap{\n    vec3 ori; // the origin of the outer circle\n    float r1; // the radius of the inner circle\n    float r2; // the radius of the outer circle\n    vec3 norm; // the (normalized) normal of the plane\n    material mat;\n};\n    \nstruct cylinder{\n    vec3 ori;\n    float r;\n    material mat;\n};\n    \nstruct hit{\n    float t;\n    vec3 p;\n    vec3 normal;\n    material mat;\n};\n    \nconst material dummyMat = material(0, vec3(0), 0.);\nconst hit dummyHit = hit(-1.0, vec3(0), vec3(0), dummyMat);\n\n/*vec3 refract2(vec3 inDir, vec3 normDir, float ni2nt){\n        inDir = normalize(inDir);\n    normDir = normalize(normDir);\n    float dt = dot(inDir, normDir);\n    float discriminant = 1.-ni2nt*ni2nt*(1.-dt*dt);\n    if(discriminant > 0.){\n            return ni2nt * (inDir-normDir*dt) - normDir * sqrt(discriminant);\n    }\n    else\n        return vec3(0);\n}*/\n    \nfloat schlick(float cosine, float ni2nt){\n    float r0 = (1.-ni2nt)/(1.+ni2nt);\n    r0 = r0*r0;\n    return r0 + (1.-r0)*pow(1.-cosine, 5.);\n}\n\niCamera ic = iCamera(vec3(0, 0, 40), vec3(0, 0, 0), vec3(0, 1, 0), 5., 0.0);\ncap cp[CAPNUM];\nbool capInit = false;\n\n/***************To get a random number************************/\n// Ray tracing in one weekend basecode for Dartmouth CS 77/177 \n// by Wojciech Jarosz, 2019\n// adapted from on https://www.shadertoy.com/view/XlycWh\n\n#define EPSILON 1e-3 \n#define MAX_FLOAT 1e5\n#define MAX_RECURSION 5\n\n//\n// Hash functions by Nimitz:\n// https://www.shadertoy.com/view/Xt3cDn\n//\n\nfloat g_seed = 0.;\n\nuint base_hash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nvoid init_rand(in vec2 frag_coord, in float time) {\n    g_seed = float(base_hash(floatBitsToUint(frag_coord)))/float(0xffffffffU)+time;\n}\n\n\nfloat rand1(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)/float(0xffffffffU);\n}\n\nvec2 rand2(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 rand3(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec2 random_in_unit_disk(inout float seed) {\n    vec2 h = rand2(seed) * vec2(1.,6.28318530718);\n    float phi = h.y;\n    float r = sqrt(h.x);\n    return r * vec2(sin(phi),cos(phi));\n}\n\nvec3 random_in_unit_sphere(inout float seed) {\n    vec3 h = rand3(seed) * vec3(2.,6.28318530718,1.)-vec3(1,0,0);\n    float phi = h.y;\n    float r = pow(h.z, 1./3.);\n    return r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\n}\n\nray getRay(camera c, vec2 uv){\n    vec2 random = c.aperture * random_in_unit_disk(g_seed);\n    vec3 offset = c.horizontal * random.x + c.vertical * random.y;\n    return ray(c.origin + offset, c.LowerLeftCorner + uv.x * c.horizontal * c.focusDist + uv.y * c.vertical* c.focusDist - c.origin - offset);\n}\n\n/*************************************************************/\n\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nfloat fade(float t){\n    return 1. - smoothstep(0.0, 1.0, abs(t));\n}\n\n\n\nvec2 grad(vec2 cell){\n    float angle = radians(360. * hash12(cell));\n    return vec2(cos(angle), sin(angle));\n}\n         \nfloat bump(vec2 tt, vec2 p){\n    vec2 g = grad(p);\n    return  fade(tt.x) * fade(tt.y) * dot(g, tt);\n}\n\n// return a random value between -1 and 1\nfloat snoise(vec2 p){\n    vec2 cell = floor(p);\n    vec2 frac = p - cell;\n    float res = 0.;\n    res += bump(frac, cell);\n    res += bump(vec2(frac.x-1.,frac.y), cell+vec2(1, 0));\n    res += bump(vec2(frac.x, frac.y-1.), cell+vec2(0, 1));\n    res += bump(vec2(frac.x-1.,frac.y-1.), cell + vec2(1));\n    return res;\n}\n\n\nfloat fractalSum(vec2 p, float domainScale, float H, float octaves){\n    float result = 0.;\n    float valueScale = 1.;\n    float valueScaleInc = pow(domainScale, -H);\n    for(float octave = octaves; octave > 0.; --octave, p*=domainScale, valueScale*=valueScaleInc){\n        float n = snoise(p);\n        float fade = min(1., octave);\n        result += valueScale * n * fade;\n    }\n    result /= (1.0- pow(valueScaleInc, octaves))/(1.0 - valueScaleInc);\n    return 0.5 + 0.5 * result;\n}\n\n/****************************Particle**********************************/\n#define BUF_SIZE iChannelResolution[2].xy\n\nconst float txRow = 16.;\nconst float txSize = txRow * txRow / 2.;\n\nconst vec2 G = vec2(0., -16000.*9.8f); // external (gravitational) forces\nconst float REST_DENS = 1000.f; // rest density\nconst float GAS_CONST = 2000.f; // const for equation of state\nconst float H = 26.f; // kernel radius\nconst float HSQ = H*H; // radius^2 for optimization\nconst float MASS = 65.f; // assume all particles have the same mass\nconst float VISC = 250.f; // viscosity constant\nconst float DT = 0.0008f; // integration timestep\n\n// smoothing kernels defined in Müller and their gradients\nconst float POLY6 = 315.f/(65.f*M_PI*pow(H, 9.f));\nconst float SPIKY_GRAD = -45.f/(M_PI*pow(H, 6.f));\nconst float VISC_LAP = 45.f/(M_PI*pow(H, 6.f));\n\n// simulation parameters\nconst float EPS = H/2.; // boundary epsilon\nconst float BOUND_DAMPING = -0.5f;\n\nfloat r;\nvec2 center;\n\nstruct Particle {\n    vec2 x;\n    vec2 v;\n    vec2 f;\n    float p; // pressure\n    float rho; // rho (density)\n};\n\nvec2 getUvForCap(vec2 iResolution, vec2 uv, int cId){\n    float stepSize  = iResolution.x / 3.;\n    return vec2(stepSize * float(cId) + uv.x/3., uv.y)/iResolution.xy;\n}\n/***********************************************************************/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Store rho and p\nvec4 Init(int mId, int cId){\n   return vec4(0.);\n}\n\nParticle p = Particle(vec2(0), vec2(0), vec2(0), 0., 0.);\n\nvec4 LoadParticle(int ind, int cId)\n{\n    float fi = float(cId) * txSize + float(ind);\n    return texture (iChannel2, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     BUF_SIZE);\n}\n\nvoid ComputeDensityPressure(int id, int cId)\n{\n    p.rho = 0.f;\n    for(int j = 0; j < int(txSize); j++)\n    {\n        vec4 jXV = LoadParticle(j, cId);\n        if(jXV.x < .0)continue;\n        vec2 rij = jXV.xy - p.x;\n        float r2 = dot(rij, rij);\n        if(r2 < HSQ)\n        {\n            // this computation is symmetric\n            p.rho += MASS*POLY6*pow(HSQ-r2, 3.f);\n        }\n    }\n    p.p = GAS_CONST*(p.rho - REST_DENS);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int mId;\n    vec2 kv = floor(fragCoord);\n    mId = int(kv.x + txRow * kv.y);\n    if (kv.x >= txRow || float(mId) > txSize * 3.) discard;\n    int cId = mId/ int(txSize);\n    mId = mId - cId * int(txSize);\n    vec4 col;\n    if(iFrame < 5){\n        col = Init(mId, cId);\n    }\n    else {\n        p.x = LoadParticle(mId, cId).xy;\n        p.v = LoadParticle(mId, cId).ba;\n        ComputeDensityPressure(mId, cId);\n        col = vec4(p.f, p.rho, p.p);\n    }\n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Store f\nvec4 Init(int mId, int cId){\n   return vec4(0.);\n}\n\nParticle p = Particle(vec2(0), vec2(0), vec2(0), 0., 0.);\n\nvec4 LoadParticle(int ind, int cId)\n{\n    float fi = float(cId) * txSize + float(ind);\n    return texture (iChannel2, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     BUF_SIZE);\n}\n\nvec4 LoadOther(int ind, int cId){\n    float fi = float(cId) * txSize + float(ind);\n    return texture (iChannel0, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     iChannelResolution[0].xy);\n}\n\nvoid ComputeForces(int mId, int cId)\n{\n    vec2 fpress = vec2(0);\n    vec2 fvisc = vec2(0);\n    //vec2 iOther = LoadOther(mId);\n    \n    for(int j = 0; j < int(txSize); j++)\n    {\n        if(mId == j)\n            continue;\n        \n        vec4 jXV = LoadParticle(j, cId);\n        if(jXV.x < .0)continue;\n        vec2 rij = jXV.xy - p.x;\n        float r = length(rij);\n\n        if(r < H)\n        {      \n            vec2 jOther = LoadOther(j, cId).ba; // Get rho and p of particle j\n            \n            // compute pressure force contribution\n            fpress += -normalize(rij)*MASS*(p.p + jOther.y)/(2.f *jOther.x) * SPIKY_GRAD*pow(H-r,2.);\n            // compute viscosity force contribution\n            fvisc += VISC*MASS*(jXV.gb - p.v)/jOther.x * VISC_LAP*(H-r);\n        }\n    }\n    vec2 fgrav = G * p.rho;\n    p.f = fpress + fvisc + fgrav;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int mId;\n    vec2 kv = floor(fragCoord);\n    mId = int (kv.x + txRow * kv.y);\n    if (kv.x >= txRow || float(mId) > 3. * txSize) discard;\n    int cId = mId/int(txSize);\n    mId = mId - cId * int(txSize);\n    vec4 col;\n    if(iFrame < 5){\n        col = Init(mId, cId);\n    }\n    else {\n        p.x = LoadParticle(mId, cId).xy;\n        p.v = LoadParticle(mId, cId).ba;\n        //ComputeDensityPressure(mId);\n        p.rho = LoadOther(mId, cId).b;\n        p.p = LoadOther(mId, cId).a;\n        ComputeForces(mId, cId);\n        col = vec4(p.f, p.rho, p.p);\n    }\n    fragColor = col;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Reference： https://bigtheta.io/2017/07/08/implementing-sph-in-2d.html\nParticle p = Particle(vec2(0), vec2(0), vec2(0), 0., 0.);\n\nvec4 LoadParticle(int ind, int cId)\n{\n    float fi = float(cId) * txSize + float(ind);\n    return texture (iChannel2, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     BUF_SIZE);\n}\n\n\nvec4 LoadOther(int ind, int cId){\n    float fi = float(cId) * txSize + float(ind);\n    return texture (iChannel1, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     iChannelResolution[0].xy);\n}\n\nvec4 LoadCap(int ind)\n{\n    float fi = float(ind) + 3. * txSize;\n    return texture (iChannel2, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     BUF_SIZE);\n}\n\nhit hitCap(const ray r, const cap cp){\n    vec3 o2o = r.ori - cp.ori;\n    float a = dot(r.dir, r.dir);\n    float b = 2.0 * dot(o2o, r.dir);\n    float c = dot(o2o, o2o) - cp.r2*cp.r2;\n    float delta = b*b - 4.0*a*c;\n    if(delta<0.0){\n        // no solution, return dummy\n        return  dummyHit;\n    }\n    else {\n        float sqrtDelta = sqrt(delta);\n        float t1 = (-b-sqrtDelta)/(2.*a);\n        float t2 = (-b+sqrtDelta)/(2.*a);\n        \n        if(t2 < minT){\n            return dummyHit;\n        }\n        \n        float dirCos = dot(cp.norm,r.dir)/ length(r.dir);\n        float sOri2Plane = sqrt(cp.r2*cp.r2 - cp.r1*cp.r1);\n        float rOri2Plane = dot(r.ori - cp.ori, cp.norm) - sOri2Plane;\n        \n        hit hit1 = dummyHit;\n        if(rOri2Plane < 0. && dirCos > 0. || rOri2Plane > 0. && dirCos < 0.){\n            float t =  rOri2Plane/dirCos /length(r.dir);\n            t = abs(t);\n            vec3 hitP = r.ori + t* r.dir;\n            if(t > minT && length(hitP - (cp.ori + sOri2Plane * cp.norm)) < cp.r1){\n                hit1 = hit(t, hitP, -cp.norm, cp.mat);\n            }\n        }\n        \n        if(t1 > minT){\n            vec3 hitP = r.ori + t1*r.dir;\n            float dist2Plane = dot(hitP - cp.ori, cp.norm) - sOri2Plane;\n            if(dist2Plane > 0.){\n                if(hit1.t > -1. && hit1.t < t1)\n                    return hit1;\n                else \n                    return hit(t1, hitP, (hitP-cp.ori)/cp.r2, cp.mat);\n            }       \n            if(hit1.t > -1.)\n                return hit1;\n        }\n\n        vec3 hitP = r.ori + t2*r.dir;\n        float dist2Plane = dot(hitP - cp.ori, cp.norm) - sOri2Plane;\n        if(dist2Plane > 0.){\n            if(hit1.t > -1. && hit1.t < t2)\n                return hit1;\n            else \n                return hit(t2, hitP, (hitP-cp.ori)/cp.r2, cp.mat);\n        }\n        if(hit1.t > -1.)\n            return hit1; \n        return dummyHit;\n    }\n}\n\nvec4 InitSPH(int mId, int cId)\n{\n    vec2 ptcStep = vec2(r) / txRow * 2.;\n    float x = ptcStep.x * mod(float(mId), txRow);\n    float y = ptcStep.y * floor(float(mId)/txRow);\n    init_rand(vec2(x, y), 2.); \n    x += (rand1(g_seed)-0.5) * ptcStep.x/2.;\n    if(dot(vec2(x, y) - center, vec2(x, y) - center) < r*r)\n    {\n        return vec4(x, y, 0, 0);\n    }\n    else return vec4(-1);\n}\n\nvoid Integrate(int mId, int cId)\n{\n    // forward Euler integration\n    vec4 other = LoadOther(mId, cId);\n    //p.v += DT*p.f/p.rho;\n    p.v += DT*other.xy/other.z + vec2(12000. * (-LoadCap(cId).a), 0.);\n    p.x += DT*p.v;\n    //p.x += other.x;\n    //p.x += 0.1;\n\n    //float offSet = LoadCap(cId).a;\n    //p.x.x -= 200. * offSet;\n    vec2 toCenter = p.x - center;\n    \n    if(dot(toCenter, toCenter) > (r - EPS)*(r - EPS)){\n        p.v = reflect(normalize(p.v), normalize(-toCenter)) * length(p.v)/2.;\n        p.x = center + normalize(toCenter) * (r - EPS);\n    }\n    \n    else{\n        vec4 col = texture (iChannel3, getUvForCap(iResolution.xy, p.x, cId));\n        if(col.a > 1.){\n            p.x -= DT*p.v; \n            p.v =  (p.v+ rand2(g_seed) * length(p.v)/5.) * BOUND_DAMPING ;\n            //p.v *= BOUND_DAMPING;\n        }\n        // Return to the original position, v inverse\n        // Not the right way to calculate bounce\n    }\n    \n    //p.x.x += offSet;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int mId;\n    vec2 kv = floor(fragCoord);\n    mId = int (kv.x + txRow * kv.y);\n    if (kv.x >= txRow) {\n        discard;\n    }\n    else if(float(mId) < 3. * txSize){\n        r = min(iResolution.x, iResolution.y)/2.;\n        center = vec2(r);\n        vec4 col;\n        int cId = mId / int(txSize);\n        mId = mId - cId * int(txSize);\n        if(iFrame < 5){\n            fragColor = InitSPH(mId, cId);\n        }\n        else {\n            p.x = LoadParticle(mId, cId).xy;\n            p.v = LoadParticle(mId, cId).ba;\n            Integrate(mId, cId);\n            fragColor = vec4(p.x, p.v);\n        }\n    }\n    else if(float(mId) < 3. * txSize + 3.){\n        // Recording position of caps   \n        int index = mId - 3 * int(txSize);\n        fragColor = LoadCap(index); \n\n        if(index == 0){\n            if(fragColor.r == 0.){\n                fragColor = vec4(-1,0, 1,0);\n            }\n        }\n        else if(index == 1){\n            if(fragColor.r == 0.){\n                fragColor = vec4(0, 0, 1,0);\n            }\n        }\n        else if(index == 2){\n            if(fragColor.r == 0.){\n                fragColor = vec4(1, 0, 1,0);\n            }\n        }\n        else return;\n\n        fragColor.a = 0.;// initialize speed\n        cap mCap = cap(fragColor.rgb, .5, 5., vec3(0, 0, 1), material(DIELECTRIC,vec3(1), 1.5));\n        int holding = -1;\n        camera c = getCamera(ic, iResolution.xy);\n\n        ray mouseRay = getRay(c, iMouse.xy/iResolution.xy);\n        hit h;\n        h = hitCap(mouseRay, mCap);\n        if(h.t > 0.){\n            if(index == 0){       \n                if(LoadCap(1).x-h.p.x > 1.){\n                    fragColor.a = h.p.x - fragColor.r;\n                    fragColor.r = h.p.x;\n                }\n            }\n            else if(index == 1){\n                if(LoadCap(2).x-h.p.x > 1. && \n                    (h.p.x - LoadCap(0).x)> 1.){\n                    fragColor.a = h.p.x - fragColor.r;\n                    fragColor.r = h.p.x;\n                }\n            }\n            else if(index == 2){\n                if(h.p.x - LoadCap(1).x > 1.){\n                    fragColor.a = h.p.x - fragColor.r;\n                    fragColor.r = h.p.x;\n                }\n            }\n        }\n        \n    }\n    else{\n        discard;\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Reference: https://www.shadertoy.com/view/4dG3RW\nvec4 LoadParticle (int ind, int cId)\n{\n  float fi = float(cId) * txSize + float(ind);\n  //return texelFetch(iChannel2, ivec2(mod(fi, txRow), floor(fi / txRow)), 0);\n  return texture (iChannel2, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     BUF_SIZE);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    float dMin = 1000.;\n   \n    vec2 resizedUv = fragCoord;\n    float stepSize  = iResolution.x / 3.;\n    int cId = int(floor(fragCoord.x/stepSize));\n    resizedUv.x = mod(resizedUv.x, stepSize) * 3.;\n    \n    fragColor = texture(iChannel3, fragCoord/iResolution.xy);\n    \n    if(fragColor.a < 0.2){\n        // initialize\n        \n        vec2[3] origins;\n        origins[0] = vec2(iResolution.y)/2.; // head\n        origins[1] = origins[0]+ vec2(-32, 32); // left ear\n        origins[2] = origins[0] + vec2(32, 32); // right ear\n        \n        float[3] r;\n        r[0] = 36.; r[1] = 18.; r[2] = 18.;// head radius and ear radius \n        float edge = H/2.; // weight of edge\n        bool flag = false;\n        for(int i = 0; i < 3; i++){  \n            float p2ori = length(resizedUv - origins[i]);\n            if(p2ori < r[i] + edge){\n                flag = true;\n                if(p2ori < r[i]){\n                    fragColor = vec4(1.0, 1.0, 1.0, 2.);\n                    return;\n                }\n                else fragColor = vec4(0.0, 0.0, 0.0, 2.); \n            }\n        }\n        if(flag)return;\n    }\n    if(fragColor.a > 1.0){// in shape\n        return;\n    }\n    for (int n = 0; n < int(txSize); n++){\n        vec4 pPos = LoadParticle(n, cId);\n        if(pPos.x > 0.){\n            dMin = min (dMin, length (resizedUv - pPos.xy));\n        }\n    }\n    \n    vec4 col = dMin < H/2.? vec4(1., 0, 0, 1.): vec4(0, 0, 0, 0.2);\n        //vec3(dMin);//mix (vec3 (0.2),  vec3 (0., 1., 0.), 1. - smoothstep (0.4, 0.5, dMin));\n    \n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}