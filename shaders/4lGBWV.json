{
    "Shader": {
        "info": {
            "date": "1544053236",
            "description": "A simple city grid heighfield ray tracer with some glowy colours and gaussian blurred bloom.",
            "flags": 32,
            "hasliked": 0,
            "id": "4lGBWV",
            "likes": 46,
            "name": "Cyber City",
            "published": 3,
            "tags": [
                "raytracing",
                "bloom"
            ],
            "usePreview": 0,
            "username": "TekF",
            "viewed": 2319
        },
        "renderpass": [
            {
                "code": "// Cyber City\n// by Hazel Quantock 2018\n// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. http://creativecommons.org/licenses/by-nc-sa/4.0/\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n#if ( GRUNGE )    \n    // tracking glitch\n    fragCoord += .2*tan(-.5*(iTime+1.4*sin(iTime/1.2+.05))+.3*fragCoord.y/iResolution.y);\n#endif\n    \n    vec3 bloom = GaussianBlur( iChannel3, ivec2(fragCoord), ivec2(0,1), BLUR_RADIUS.y );\n    \n#if ( GRUNGE )    \n    // chromatic aberation\n    vec2 uv = fragCoord/iResolution.xy - .5;\n//    uv *= 1. - .1*dot(bloom,vec3(.1,.7,.2)); // CRT distortion around bright areas\n//    uv *= mix(1.,pow(length(uv)/.7,5.),.1); // curve <- better to do this in source render!\n\tfragColour.r  = texture( iChannel0, 0.996*uv+.5 ).r;\n\tfragColour.ga = texture( iChannel0, 1.000*uv+.5 ).ga;\n\tfragColour.b  = texture( iChannel0, 1.010*uv+.5 ).b;\n#else\n\tfragColour = texelFetch( iChannel0, ivec2(fragCoord), 0 );\n#endif\n    \n\tfragColour.rgb = mix(\n        fragColour.rgb,\n        bloom,\n        fragColour.a );\n    \n    \n#if ( GRUNGE )    \n    // add some grungey effects\n    vec3 grunge = texture( iChannel1, fragCoord/iChannelResolution[1].xy + vec2(.7549,.5698)*float(iFrame) ).rgb;\n    fragColour.rgb = mix( fragColour.rgb*mix( vec3(1), grunge, .2 ), grunge*vec3(.3,1,.6), .02 );\n    fragColour.rgb *= 1.+.4*sin(6.283185*fragCoord.y*.5*.618+iTime);\n    \n    // adjust exposure periodically\n    fragColour.rgb *= mix( 1., 2.5, smoothstep(.0,.3,cos(iTime/7.)) );\n    \n    // contrast stretch, to make it a bit more filmic\n    fragColour.rgb = max(vec3(0),fragColour.rgb-.02);\n#endif\n    \n\tfragColour.rgb = pow( fragColour.rgb, vec3(1./2.2) );\n    fragColour.a = 1.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "music",
                        "id": 35,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "struct Ray\n{\n    vec3 start;\n    vec3 dir;\n    vec2 clip; // near, far clip\n};\n\nstruct Intersection\n{\n    float t; // along ray\n    ivec2 cell;\n    vec3 normal;\n};\n\nconst Intersection miss = Intersection( 1e30, ivec2(0), vec3(0) );\n\nivec2 WorldToCell( vec3 pos )\n{\n    return ivec2(floor(pos.xz));\n}\n\n\n// hash from https://www.shadertoy.com/view/4dVBzz\n#define M1 1597334677U     //1719413*929\n#define M2 3812015801U     //140473*2467*11\n#define M3 3299493293U     //467549*7057\n\n#define F0 exp2(-32.)\n//(1.0/float(0xffffffffU))\n\n#define hash(n) n*(n^(n>>15))\n\n#define coord1(p) (p*M1)\n#define coord2(p) (p.x*M1^p.y*M2)\n#define coord3(p) (p.x*M1^p.y*M2^p.z*M3)\n\nfloat hash1(uint n){return float(hash(n))*F0;}\nvec2 hash2(uint n){return vec2(hash(n)*uvec2(0x1U,0x3fffU))*F0;}\nvec3 hash3(uint n){return vec3(hash(n)*uvec3(0x1U,0x1ffU,0x3ffffU))*F0;}\nvec4 hash4(uint n){return vec4(hash(n)*uvec4(0x1U,0x7fU,0x3fffU,0x1fffffU))*F0;}\n\n\nfloat CellHeight( ivec2 cell )\n{\n    // todo: complicated map with roads, repetition, etc\n    return pow(hash1(coord2(uvec2(cell+0x80000000)))+.0000001,5.)*8.;\n// WHAT!? pow of 9 looks like 1, pow of 10 looks different!? - but adding .00000001 fixes it?!\n}\n    \nIntersection traceGridCity( in Ray ray )\n{\n    vec3 pos = ray.start + ray.dir*ray.clip.x;\n    ivec2 cell = WorldToCell( pos );\n    ivec2 cellDir = ivec2(sign(ray.dir.xz));\n\n    float t = ray.clip.x;\n    vec3 face = vec3(0);\n    for ( int i=0; i < 100; i++ )\n    {\n        float h = CellHeight(cell);\n        if ( pos.y < h )\n        {\n            break;\n        }\n        // compute step to next cell boundary\n        vec2 boundary = vec2(cell+max(cellDir,0)); // for negative marching we need own cell's edge, not next\n        float deltax = (boundary.x-pos.x)/ray.dir.x;\n        float deltaz = (boundary.y-pos.z)/ray.dir.z;\n        float delta;\n        if ( deltax < deltaz )\n        {\n            delta = deltax;\n            face = vec3(sign(ray.dir.x),0.,0.);\n            cell.x += cellDir.x;\n        }\n        else\n        {\n            delta = deltaz;\n            face = vec3(0.,0.,sign(ray.dir.z));\n            cell.y += cellDir.y;\n        }\n        \n        vec3 newPos = pos + delta*ray.dir;\n        \n// todo: prevent precision errors - set the boundary axis to exact integer value\n        \n        float newT = t + delta;\n        if ( newPos.y < h ) // check if hit top\n        {\n// this looks like a lot of conditional maths to have in a loop => better to push outside\n// compiler might be smart enough, since it ends in a break\n            face = vec3(0,1,0);\n            t = mix( t, newT, (h-pos.y)/(newPos.y-pos.y) );\n            break;\n        }\n        \n        pos = newPos;\n        t = newT;\n    }\n    \n    if ( t > ray.clip.y ) return miss;\n    \n    return Intersection( t, cell, face );\n}\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    float tilt = iTime*.3;\n    Ray ray =\n        Ray(\n    \t\tvec3(.5,10.+3.*sin(iTime/4.),0) + iTime*vec3(-.333,0.,1.)*4. + cos(tilt)*10.*vec3(1.,0.,.333),\n            vec3((fragCoord-iResolution.xy*.5)/iResolution.y,1.),\n            vec2(.01,1e5)\n        );\n\n#if (GRUNGE)\n    ray.dir.xy *= mix(1.,.5+pow(length(ray.dir.xy)/.8,5.),.2); // barrel distortion\n//    ray.dir.z = 1.1*pow(ray.dir.z,2.); // barrel distortion\n#endif\n    \n    ray.dir = normalize(ray.dir);\n    \n    vec3 camK = normalize(vec3(-.333,-.5,1));\n    vec3 camI = normalize(cross(vec3(0,1,0),camK) + vec3(0,sin(tilt)*.4,0));\n    vec3 camJ = cross(camK,camI);\n    ray.dir = ray.dir.x*camI + ray.dir.y*camJ + ray.dir.z*camK;\n    \n    Intersection it = traceGridCity( ray );\n    \n    fragColour = vec4(atmosColour,1.);\n    if ( it.t < 68. )//ray.clip.y )\n    {\n        //fragColour = vec4(CellHeight(ivec2(fragCoord-iResolution.xy*.5))/8.);\n        //fragColour.rgb = it.normal*.5+.5;\n\n        vec3 pos = ray.start + ray.dir * it.t;\n\n        vec4 rand = hash4(coord3(uvec3(ivec3(pos*vec3(7,5,7)+.01)+0x80000000)));\n        fragColour.rgb = (0.+20.*rand.rgb)\n            \t\t\t// decide which lights are on (and vary it over space!)\n                        * smoothstep(.8-.17*dot(vec2(.5),sin(pos.xz/6.)),1.,rand.w-.45*smoothstep(100.,-20.,length(pos)))\n                        * step(.5,fract(pos.y*5.+.01));\n        \n        // window frames, randomly broken up\n/*        fragColour.rgb = (0.+5.*hash3(coord3(uvec3(ivec3(pos*vec3(7,10,7)+.001)+0x80000000))))\n            \t*step(.5,fract(pos.y*5.))\n            \t* smoothstep(.7,1.,hash1(coord3(uvec3(ivec3(pos*vec3(7,5,7)+.001)+0x80000000))));*/\n        \n        if ( it.normal.y > 0. ) fragColour.rgb = vec3(0);\n        \n        fragColour.rgb = mix( atmosColour, fragColour.rgb, exp2(-it.t/8.) );\n    }\n    \n#if (GRUNGE)\n    // vignetting\n    fragColour.rgb *= smoothstep( 1.5, 0., length(fragCoord.xy-iResolution.xy*.5)/length(iResolution.xy*.5) );\n#endif\n    \n#if ( BLOOM_FOG )\n\tfragColour.a = mix( .4, 1.-exp2(-it.t/8.), .8 ); // bloom strength based on distance - to look like fog - causes halos against the sky\n#else\n\tfragColour.a = .6; // bloom strength\n#endif\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// scene params\n#define BLOOM_FOG 1\n\n#if ( BLOOM_FOG )\n\t#define BLUR_RADIUS (vec2(.05,.1)*iResolution.y)\n#else\n\t#define BLUR_RADIUS (vec2(.05)*iResolution.y)\n//\t#define BLUR_RADIUS (vec2(.01,.15)*iResolution.y)\n#endif\n\n#define GRUNGE 1\n\nvec3 atmosColour = vec3(.03,.035,.07);\n\n//-------------------------------------------------\n\n// Gaussian Blur functions\n\n// what's the weight at this distance?\nfloat GaussianWeight( float coord, float stddev )\n{\n    return exp( -coord*coord / (2.*stddev*stddev) ) / (sqrt(6.283185)*stddev);\n}\n\n// at what distance will we find this weight? (so we can cut off the kernel)\nfloat GaussianRange( float weight, float stddev )\n{\n    return sqrt( -log( weight * sqrt(6.283185)*stddev ) * 2.*stddev*stddev );\n}\n\n// axis is either (1,0) or (0,1)\nvec3 GaussianBlur( sampler2D tex, ivec2 uv, ivec2 axis, float stddev )\n{\n    vec3 result = vec3(0);\n    int range = int( GaussianRange(.0002,stddev) );\n    for ( int i=0; i < 1000; i++ )\n    {\n        int du = -range + i;\n        if ( du > range ) break;\n        result += texelFetch( tex, uv + axis*du, 0 ).rgb\n            \t* GaussianWeight( float(du), stddev );\n    }\n    return result;\n}\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n\tfragColour.rgb = GaussianBlur( iChannel0, ivec2(fragCoord), ivec2(1,0), BLUR_RADIUS.x );\n    fragColour.a = 1.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}