{
    "Shader": {
        "info": {
            "date": "1660754080",
            "description": "I figured out how to handle octahedron intersections",
            "flags": 0,
            "hasliked": 0,
            "id": "7tcyDl",
            "likes": 1,
            "name": "Octahedron Raytrace",
            "published": 3,
            "tags": [
                "raytrace"
            ],
            "usePreview": 0,
            "username": "alaula",
            "viewed": 190
        },
        "renderpass": [
            {
                "code": "#define CAMTAN 2.0\n#define DELTA 0.0001\n\nvec4 OctaHedron = vec4(0.5, 0.5, -1.0, 2.0);\nvec3 OcthColor = vec3(.1 , .7 , .2);\n\n#define OCTH(X) dot(abs(X),ones)\n#define CHECK(X) OCTH(ro+rd*prj.X)\nbool OctIntersect (in vec3 rd, in vec3 ro, in float OctSize){\n    vec3 prj = -ro/rd;  //ray distance from axis planes\n    vec3 ones = vec3(1.0);\n    return min(min(CHECK(x),CHECK(y)),CHECK(z)) <= OctSize; //if axis intersection is inside oct then so is the line\n}\n\n// I need to figure out a better way to implement this function\nfloat OctFindDist(in vec3 rd, in vec3 ro, in float OctSize){\n    vec3 prj = -ro/rd;  //ray distance from axis planes\n    vec3 ones = vec3(1.0);\n    prj = prj+ 1000.0*(vec3(CHECK(x) > OctSize,CHECK(y) > OctSize,CHECK(z) > OctSize)); //cull invalid points\n    float minimum = min(min(prj.x,prj.y),prj.z); // find nearest valid axis intersection\n    prj = ro + rd*(minimum - DELTA); //re-use variable\n    ones = sign(prj); //re-use variable\n    return minimum + (OctSize - dot(prj,ones))/dot(rd,ones); //step back from the axis plane to find the surface\n}\n\n#define DIFF(X) OCTH(p+DELTA*v.X)-d\nvec3 CalcNorm(vec3 p){\n    vec3 ones = vec3(1.0);\n    vec2 v = vec2(1.0,0.0);\n    float d = OCTH(p);\n    return normalize(vec3(DIFF(xyy), DIFF(yxy), DIFF(yyx)));\n}\n\nvec3 CalcRayDir(in vec2 fragCoord){\n    vec2 camOff = (fragCoord - 0.5*iResolution.xy)*(CAMTAN/iResolution.x);\n    vec2 camDir = vec2(cos(iTime/2.0),sin(iTime/2.0));\n    return vec3(camDir.xy,camOff.y)+camOff.x*vec3(camDir.y,-camDir.x,0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 rd = normalize(CalcRayDir(fragCoord));\n    vec3 ro = 10.0*vec3(-cos(iTime/2.0),-sin(iTime/2.0),0.2);\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    vec3 offset = vec3(0.0, 0.0, 4.0 -pow(mod(iTime,4.0)-2.0, 2.0));\n\n    // Time varying pixel color\n    vec3 col = vec3(.1,.2,.2);\n    \n    if (uv.y < -0.05){\n        vec2 fuv = (ro + rd*((+OctaHedron.z -ro.z - OctaHedron.w)/(rd.z))).xy;\n        float shade = smoothstep(0.0,1.0,length(OctaHedron.xyz +offset - vec3(fuv,-OctaHedron.w+OctaHedron.z))/4.0);\n        fuv = 0.5+sign(mod(fuv,2.0)-0.5)/2.0;\n        col = fuv.x*vec3(.2,.1,.1) + fuv.y*vec3(.3,.2,.1);\n        col *= shade;\n    }\n    \n    if(OctIntersect(rd, ro - OctaHedron.xyz - offset, OctaHedron.w)){\n        float dist = OctFindDist(rd,ro - OctaHedron.xyz - offset,OctaHedron.w);\n        float shade = 0.5 - dot(CalcNorm(ro + dist*rd - OctaHedron.xyz - offset),rd)/2.0;\n        col = shade*OcthColor;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}