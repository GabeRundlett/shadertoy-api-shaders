{
    "Shader": {
        "info": {
            "date": "1513289851",
            "description": "Hyperbolic kaleidoscope mapped conformally to a square with the Jacobi cn function\n\nMouse controls position of image centre (click to recentre after resize)\nKeys 1-8 toggle display of different mappings\nKeys b,c,d,f,g,m toggle various image parameters\n",
            "flags": 48,
            "hasliked": 0,
            "id": "Mlsfzs",
            "likes": 90,
            "name": "Hyperbolic Square",
            "published": 3,
            "tags": [
                "conformal",
                "elliptic",
                "hyperbolic",
                "cineshader"
            ],
            "usePreview": 1,
            "username": "mla",
            "viewed": 6687
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// (c) Matthew Arcus 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Hyperbolic kaleidoscope mapped conformally in various ways,\n// notably to a square with the Jacobi cn function.\n//\n// Keys 1-8 select various mappings, otherwise cycle through automatically.\n//\n// Mouse controls position of image centre (click on image \n// after resize to recentre).\n//\n// 'd': combine fundamental regions in pairs (P should be even).\n// 'c': chiral mapping\n// 'f': display principal region only\n// 'k': Beltrami-Klein for disc projection\n// 'm': display outside disc/halfplane\n// 'n': don't normalize rotations - see effect on 'cloverleaf' mapping #2\n// 'g': centre on 4-vertex\n// 'b': show fundamental region edges\n//\n////////////////////////////////////////////////////////////////////////////////\n\nint P = 8;   // Central vertex\nint Q = 3;   // Second vertex\n//int R = 2; // Third vertex, always 2\n\nconst int NN = 200; // Number of folding iterations\n\nconst float PI = 3.141592654;\nconst float TWOPI = 2.0*PI;\n\nbool keypress(int code) {\n    return texelFetch(iChannel1, ivec2(code,2),0).x != 0.0;\n}\n\nint numbertoggle() {\n    int i = int(texelFetch(iChannel2,ivec2(0,0),0).x);\n    if (i < 0) return 0;\n    return i;\n}\n\n/// Complex arithmetic ///\n\n// Normal vec2 operations work for\n// addition, subtraction and\n// multiplication by a scalar.\n      \n// Multiplication\nvec2 cmul(vec2 z0, vec2 z1) {\n  float x0 = z0.x; float y0 = z0.y; \n  float x1 = z1.x; float y1 = z1.y;\n  return vec2(x0*x1-y0*y1,x0*y1+x1*y0);\n}\n\n// Reciprocal\nvec2 cinv(vec2 z) {\n  float x = z.x; float y = z.y;\n  float n = 1.0/(x*x + y*y);\n  return vec2(n*x,-n*y);\n}\n\n// Division\nvec2 cdiv(vec2 z0, vec2 z1) {\n  return cmul(z0,cinv(z1));\n}\n\n// Exponentiation - e^ix\nvec2 expi(float x) {\n  x = mod(x,TWOPI);\n  vec2 t = vec2(cos(x),sin(x));\n  if (!keypress(CHAR_N)) t = normalize(t);\n  return(t);\n}\n\n// e^iz\nvec2 cexp(vec2 z) {\n  return exp(z.x) * expi(z.y);\n}\n\nvec2 csqrt(vec2 z) {\n  float r = length(z);\n  return vec2(sqrt(0.5*(r+z.x)),sign(z.y)*sqrt(0.5*(r-z.x)));\n}\n\nvec2 clog(vec2 z) {\n  return vec2(log(length(z)),atan(z.y,z.x));\n}\n\nvec2 csin(vec2 z) {\n  float x = z.x, y = z.y;\n  return cdiv(cexp(vec2(-y,x))-cexp(vec2(y,-x)), vec2(0,2.0));\n}\n\nvec2 cpow(vec2 z, float k) {\n  return cexp(k*clog(z));\n}\n\n// Taken from NR, simplified by using a fixed number of\n// iterations and removing negative modulus case.\n// Modulus is passed in as k^2 (_not_ 1-k^2 as in NR).\nvoid sncndn(float u, float k2,\n            out float sn, out float cn, out float dn) {\n  float emc = 1.0-k2;\n  float a,b,c;\n  const int N = 4;\n  float em[N],en[N];\n  a = 1.0;\n  dn = 1.0;\n  for (int i = 0; i < N; i++) {\n    em[i] = a;\n    emc = sqrt(emc);\n    en[i] = emc;\n    c = 0.5*(a+emc);\n    emc = a*emc;\n    a = c;\n  }\n  // Nothing up to here depends on u, so\n  // could be precalculated.\n  u = c*u; sn = sin(u); cn = cos(u);\n  if (sn != 0.0) {\n    a = cn/sn; c = a*c;\n    for(int i = N-1; i >= 0; i--) {\n      b = em[i];\n      a = c*a;\n      c = dn*c;\n      dn = (en[i]+a)/(b+a);\n      a = c/b;\n    }\n    a = 1.0/sqrt(c*c + 1.0);\n    if (sn < 0.0) sn = -a;\n    else sn = a;\n    cn = c*sn;\n  }\n}\n\n// Complex sn. uv are coordinates in a rectangle, map to\n// the upper half plane with a Jacobi elliptic function.\n// Note: uses k^2 as parameter.\nvec2 sn(vec2 z, float k2) {\n  float snu,cnu,dnu,snv,cnv,dnv;\n  sncndn(z.x,k2,snu,cnu,dnu);\n  sncndn(z.y,1.0-k2,snv,cnv,dnv);\n  float a = 1.0/(1.0-dnu*dnu*snv*snv);\n  return a*vec2(snu*dnv, cnu*dnu*snv*cnv);\n}\n\nvec2 cn(vec2 z, float k2) {\n  float snu,cnu,dnu,snv,cnv,dnv;\n  sncndn(z.x,k2,snu,cnu,dnu);\n  sncndn(z.y,1.0-k2,snv,cnv,dnv);\n  float a = 1.0/(1.0-dnu*dnu*snv*snv);\n  return a*vec2(cnu*cnv,-snu*dnu*snv*dnv);\n}\n\nvec2 dn(vec2 z, float k2) {\n  float snu,cnu,dnu,snv,cnv,dnv;\n  sncndn(z.x,k2,snu,cnu,dnu);\n  sncndn(z.y,1.0-k2,snv,cnv,dnv);\n  float a = 1.0/(1.0-dnu*dnu*snv*snv);\n  return a*vec2(dnu*cnv*dnv,-k2*snu*cnu*snv);\n}\n\n#if __VERSION__ < 300\nbool isnan(float x) {\n  return x != x;\n}\nbool isnan(vec2 z) {\n  return isnan(z.x) || isnan(z.y);\n}\n\n#if 0\nfloat atanh(float r) {\n  return 0.5*log((1.0+r)/(1.0-r));\n}\n\nfloat tanh(float x) {\n  return (exp(2.0*x)-1.0)/(exp(2.0*x)+1.0);\n}\n#endif\n#endif\n\n// Invert z in circle radius r, centre w\nvec2 invert(vec2 z, vec2 w, float r2) {\n  vec2 z1 = z - w;\n  float k = r2/dot(z1,z1);\n  return z1*k+w;\n}\n\n// Overloading for p on x-axis\nvec2 invert(vec2 z, float x, float r2) {\n  return invert(z,vec2(x,0),r2);\n}\n\n// Invert z in circle p, r2, if it is inside\nint tryinvert(inout vec2 z, vec2 p, float r2) {\n  vec2 z1 = z - p;\n  float d2 = dot(z1,z1);\n  if (d2 >= r2) return 0;\n  z = z1*r2/d2 + p;\n  return 1;\n}\n\nint tryreflect(inout vec2 z, vec2 norm) {\n  float k = dot(z,norm);\n  if (k <= 0.0) {\n    return 0;\n  } else {\n    z -= 2.0*k*norm;\n    return 1;\n  }\n}\n\nvec2 translate(vec2 z, float s) {\n  // Do hyperbolic translation, ie. an inversion\n  // Translate s (on x axis) to origin of hyperbolic disk with\n  // given radius.\n  if (abs(s) < 1e-4) {\n    z.x = -z.x;\n  } else {\n    // p*(p-s) = r*r = p*p - radius*radius\n    // p*p - p*s = p*p - rad*rad\n    // p = s/(rad*rad)\n    float p = 1.0/s;\n    float r2 = p*(p-s);\n    z = invert(z,p,r2);\n  }\n  return z;\n}\n\n// Compute the radius of the disk.\n// p is the centre of the inversion\n// circle for the hyperbolic triangle, r is its radius,\n// so use Pythagoras to find the right angle for a tangent\n// with the disk (this needs a picture).\nfloat diskradius(vec2 p, float r) {\n  return sqrt((length(p)+r)*(length(p)-r));\n}\n\n// For ES 2.0\nint imod(int n, int m) {\n    return n-n/m*m;\n}\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cmul(expi(t),p); //cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  //Q += int(iTime);\n  float rrepeat = 0.0;\n  rrepeat = 0.005* iTime; // Makes texture mapping radius dependent\n  int display = numbertoggle();\n  int NDISPLAYS = 8;\n  if (display == 0) display = 1+imod(int(iTime/10.0),NDISPLAYS);\n  // Join 2 fundamental regions together\n  bool doubleup = keypress(CHAR_D);\n  bool chiral = keypress(CHAR_C);\n  // Just show one fundamental region\n  bool fundamental = keypress(CHAR_F);\n  bool mask = !keypress(CHAR_M);\n  \n#if 0\n  if (keypress(CHAR_0+1)) display = 1;\n  else if (keypress(CHAR_0+2)) display = 2;\n  else if (keypress(CHAR_0+3)) display = 3;\n  else if (keypress(CHAR_0+4)) display = 4;\n  else if (keypress(CHAR_0+5)) display = 5;\n#endif\n      \n  fragColor = vec4(0,0,0,1); // Background\n    \n  float theta = PI/float(P); // Central angle of triangle\n  float phi = PI/float(Q); // Other angle of triangle\n  // Need picture of hyperbolic region\n  // Third side of hyperbolic triangle is an inversion circle.\n  // ODBC are on x-axis, A is height 1 above B, so OBA is a right angle and BA = 1\n  // BOA = COA = theta, OAD = phi, CAB = theta+phi\n  // Maybe should scale to make radius 1 always.\n  vec2 p = vec2(cos(theta)/sin(theta) + sin(theta+phi)/cos(theta+phi),0.0);\n  float r = 1.0/cos(theta+phi);\n  float offset = p.x - r;\n  float radius = diskradius(p,r); // FIXME!\n  p /= radius;\n  r /= radius;\n  offset /= radius;\n  float r2 = r*r;\n  \n  // norm and norm2 are normals to the radial axes\n  // norm2 is second radial axis, either x-axis or norm reflected in x-axis\n  vec2 norm = vec2(-sin(theta),cos(theta));\n  vec2 norm2 = !doubleup ? vec2(0.0,-1.0) : vec2(-sin(theta),-cos(theta));\n  vec2 ci = vec2(0.0,1.0); // Complex i\n\n  vec2 z = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n  if (display == 1) {\n    z = cdiv(z,vec2(1,1));\n    z -= vec2(1,0);\n    z *= 1.854; \n    z = cn(z, 0.5);\n    z = cmul(z,vec2(0.70711,0.70711));\n  } else if (display == 2) {\n    //if (keypress(CHAR_K)) z *= (1.0-sqrt(1.0-dot(z,z)))/dot(z,z); // Beltrami-Klein\n    z = cpow(cmul(z,normalize(vec2(1))),4.0)-vec2(1,0);\n  } else if (display == 3) {\n    z = csqrt(z);\n    z = cmul(z,ci);\n    z = cdiv(ci-z,ci+z);\n  } else if (display == 4) {\n    // rectangle -> half plane\n    z *= 4.0;\n    float k2 = 0.5*sin(0.2*iTime)+0.5;\n    z.y += 1.0;\n    z = sn(z,k2);\n  } else if (display == 5) {\n    z.y += 1.0;\n    z *= 0.5*iResolution.y/iResolution.x;\n    z = csin(PI*z); // edges and bottom are boundaries\n  } else if (display == 6) {\n    z.y += 1.0;\n    z *= 0.5;\n    z.x *= -1.0;\n    z = cexp(PI*z); // top and bottom are boundaries\n    z.x *= -1.0;\n  } else if (display == 7) {\n    z *= 0.5*iResolution.y/iResolution.x;\n    z.x += 0.5;\n    //z.x *= -1.0;\n    z = cexp(PI*z.yx); // swap x,y; sides are boundaries\n    z.x *= -1.0;\n  } else if (display == 8) {\n    z = cmul(z,vec2(0,-1));\n    z = csqrt(z);\n    z.x -= 0.5;\n    z = cmul(z,vec2(0,1));\n  }\n  if (display > 3) {\n    // Map upper half-plane to the disk.\n    z = cdiv(ci-z,ci+z);\n  }\n\n  z = z.yx; // Flip coords to make image symmetric about y-axis\n    \n  if(iMouse.x > 0.0) {\n    vec2 mouse = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    mouse = mouse.yx;\n    if (display == 3 || display == 4 || \n        display == 5 || display == 7) {\n      mouse.x *= -1.0;\n      mouse = mouse.yx;\n    }\n    // FIXME!\n    float r = atan(mouse.y,mouse.x);\n    float s = length(mouse);\n\n    z = rotate(z,-r);\n    z = translate(z,s);\n    z.x *= -1.0;\n  }\n  \n  float psi = iTime*0.1;\n  float rho = iTime*0.123;\n  z = rotate(z,-rho);\n  if (keypress(CHAR_G)) {\n    z = translate(z,offset); // Put 4-vertex in centre\n  }\n  if (dot(z,z) > 1.0) {\n    // Or invert to inside the disk\n    if (mask) return;\n  } else {\n    // Only apply rrotation inside the disk\n    psi += rrepeat*atanh(length(z));\n  }\n  \n    int flips = 0;\n    bool found = false;\n    for (int i = 0; i < NN; i++) {\n      // Fundamental region is OAB\n      // OA is on x-axis, OB is at angle theta\n      // AB is circle for hyperbolic case.\n      // norm is normal to OB, norm2 is other radial\n      // reflection - either x-axis or reflection of OA.\n      int k = tryreflect(z,norm) + tryreflect(z,norm2) + tryinvert(z,p,r2);\n      if (k == 0) {\n        found = true;\n        break;\n      }\n      if (fundamental) return;\n      flips += k;\n    }\n    if (!found) return;\n    vec2 z0 = z;\n    if (chiral && imod(flips,2) != 0) z.y = -z.y;\n  \n  float level = 1.0;\n\n  if (keypress(CHAR_B) &&\n      // Show region boundary\n      (abs(dot(z,norm)) < 0.007 || \n       abs(dot(z,norm2)) < 0.007 ||\n       length(p-z)-r < 0.007)) {\n    level = 0.0;\n  }\n  \n  // Now convert position (in fundamental region) to texture coord.\n  vec2 uv = z;\n  //uv = mat2(cos(psi), sin(psi), -sin(psi), cos(psi)) * uv;\n  uv = rotate(uv,psi);\n  // scale texture access\n  uv *= 2.0; z0 *= 2.0;\n  // and add a variable offset here?\n  //if (iMouse.x > 0.0) uv += 2.0*(iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n  uv += vec2(0.5,0.5);\n\n  vec3 texColor;\n  if (keypress(CHAR_T)) {\n    texColor = texture(iChannel0,uv).xyz;\n  } else {\n    texColor = textureGrad(iChannel0, uv, dFdx(z0), dFdy(z0)).xyz;\n  }\n  texColor *= 2.0;\n  fragColor = vec4(level*texColor,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// From \"key group toggles\" by @FabriceNeyret2:\n// https://www.shadertoy.com/view/MlffW2\n\n#define keypressed(ascii) ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0. )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n#if __VERSION__ < 300\n    O = vec4(0);\n#else\n    if ( iFrame == 0 ) { O = vec4(0); return; } // initialized at -1\n    \n    if (U.y>=1.0) return;\n    O = texelFetch(iChannel0,ivec2(U),0); // Get current state   \n    \n \tint x = int(U.x);  \n    if ( x == 0 ) {\n        for (int i=1; i<=8; i++)             // (0,0).x = digits\n            if (keypressed(48+i)) O.x = float(i);\n        for (int i=1; i<=12; i++)            // (0,0).y = F1-F12\n            if (keypressed(112+i-1)) O.y = float(i);\n        \n        if (keypressed(65)) O.z = 0.;        // (0,0).z = a,b,c\n        if (keypressed(66)) O.z = 1.;    \n        if (keypressed(67)) O.z = 2.;  \n            \n        if (keypressed(68)) O.w = 0.;        // (0,0).w = d,e,f\n        if (keypressed(69)) O.w = 1.;    \n        if (keypressed(70)) O.w = 2.;    \n     }\n            \n    if ( x == 1 ) {\n        if (keypressed(37)) O.x = 0.;        // (1,0).w = key left, up, right, down\n        if (keypressed(38)) O.x = 1.;  \n        if (keypressed(39)) O.x = 2.;  \n        if (keypressed(40)) O.x = 3.;  \n    }\n    \n // FYI: LEFT:37  UP:38  RIGHT:39  DOWN:40   PAGEUP:33  PAGEDOWN:34  END : 35  HOME: 36 F1:112\n#endif           \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_K = 75;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_T = 84;",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}