{
    "Shader": {
        "info": {
            "date": "1545067952",
            "description": "just a simple raymarch scene with a pretty good hashing function using big primes.\nusing the hashing function to distribute some objects in ways that look random to ppl.\nalso using hyperbolic brightness attenutation to preserve color in overexposed areas.",
            "flags": 0,
            "hasliked": 0,
            "id": "3sf3R4",
            "likes": 7,
            "name": "megagrid42",
            "published": 3,
            "tags": [
                "raymarching",
                "lighting",
                "hashing"
            ],
            "usePreview": 0,
            "username": "benhardy",
            "viewed": 917
        },
        "renderpass": [
            {
                "code": "/*\njust a simple raymarch scene with a pretty good hashing function using big primes.\nusing the hashing function to distribute some objects in ways that look random to ppl.\nalso using hyperbolic brightness attenutation to preserve color in overexposed areas.\n*/\n#define EPSILON    0.001\n#define MAX_STEPS  1000\n#define MAX_DIST   10.0\n#define STEP_RATIO 0.5\n\n#define ID_NONE   0\n#define ID_GRID   1\n#define ID_BALL   2\n#define ID_PLATES 3\n\nint hash(ivec3 p) {\n    return ((p.x * 7919 + p.y) * 6563 + p.z) * 4273;\n}\n\n/**\n * distance to grid\n * return grid-local beam coords with distance\n */\nvec4 dist_grid(vec3 pos) {\n    vec3 dp1 = abs(fract(pos+0.5)-0.5);\n    vec3 dp2 = vec3(\n        min(dp1.x,dp1.y),\n        max(dp1.x,dp1.y), \n        dp1.z);\n    vec3 dp3 = vec3(\n        dp2.x,\n        max(dp2.y,dp2.z), \n        min(dp2.y,dp2.z));\n    float dist = length(max(vec2(0.00,0.00),vec2(dp3.x,dp3.z) -0.03)) - 0.01;\n    return vec4(dp3, dist);\n}\n\nvec4 dist_ball(vec3 pos) {\n    vec3 offset = floor(pos+0.5);\n    ivec3 gp = ivec3(int(offset.x),int(offset.y),int(offset.z));\n    if (hash(gp) % 0x0f == 0) {\n        pos = abs(fract(pos+0.5)-0.5);\n    \treturn vec4(pos, length(pos)-0.15);\n    }\n    return vec4(pos,3.0); // no ball here, fake it being elsewhere\n}\n\nconst vec3 ORIGIN = vec3(0,0,0);\nconst vec3 PLATE_SIZE = vec3(0.5,0.01,0.5);\n\nvec4 dist_floorplates(vec3 pos) {\n    pos+=vec3(0.5,0.0,0.5);\n    vec3 offset = floor(pos+0.5);\n    ivec3 gp = ivec3(int(offset.x),int(offset.y),int(offset.z));\n    if (hash(gp) % 7 == 0 || \n        \n        ((gp.y%3==0) && (gp.x % 5 == 0 || gp.z%10==0))) {\n        pos = max(ORIGIN,abs(fract(pos + 0.5) - 0.5)-PLATE_SIZE);\n    \treturn vec4(pos, length(pos));\n    }\n    return vec4(pos,3.0); // no ball here, fake it being elsewhere\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.y / iResolution.x;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    \n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5,0.5);\n    uv.y *= aspect;\n    vec3 eye = vec3(0.5 + 3.2*cos(iTime*0.1),\n                    0.3,\n                    0.5 + 3.0*sin(iTime*0.1));\n    vec3 look_at = vec3(\n        12.3* cos(iTime*0.3),\n        4.3* cos(iTime*0.34),\n        5.3+9.0*cos(iTime*0.22));\n    vec3 look = normalize(look_at - eye);\n    vec3 up_init = vec3(0,1,0);\n    vec3 right = cross(up_init, look);\n    vec3 up = cross(look, right);\n    vec3 ray = normalize(uv.x * right + uv.y * up + look);\n    float dist = 0.0;\n    vec3 pos = eye;\n    int hit = ID_NONE;\n    vec3 local_hit;\n    for (int steps = 0; steps < MAX_STEPS && dist <MAX_DIST; steps++) {\n        pos = eye + dist * ray;\n        vec4 res_grid = dist_grid(pos);\n        float closest = 100000.0;\n        if (res_grid.w < closest) {\n\t        local_hit = res_grid.xyz;\n            hit = ID_GRID;\n            closest = res_grid.w;\n        }\n        \n        vec4 res_ball = dist_ball(pos);\n        if (res_ball.w < closest) {\n\t        local_hit = res_ball.xyz;\n            hit = ID_BALL;\n            closest = res_ball.w;\n        }\n        \n        vec4 res_plate = dist_floorplates(pos);\n        if (res_plate.w < closest) {\n\t        local_hit = res_plate.xyz;\n            hit = ID_PLATES;\n            closest = res_plate.w;\n        }\n\n        if (closest < EPSILON) {\n            break;\n        }\n        dist += STEP_RATIO * closest;\n    }\n    vec3 col = vec3(0,0,0);\n    if (hit == ID_GRID) {\n        float level = floor(fract((local_hit.y+0.0125)*20.0)*2.0);\n\t\t\n        col = vec3(level);\n    }\n    else if (hit == ID_BALL) {\n        float level = floor(fract((local_hit.y+0.0125)*20.0)*2.0);\n\t\t\n        col = vec3(13.0*(1.02-pow(fract(iTime),0.25)),0,0);\n    }\n    else if (hit == ID_PLATES) {\n        col = vec3(0.7,0.5,0.3);\n    }\n    float light_power = 10.0;\n    // inverse square light falloff\n    col *= light_power /(dist*dist);\n    // smooth transition to overexposed areas while keeping hue&sat.\n    float brightness = max(max(col.x, col.y), col.z);\n    float attenuation = tanh(brightness) / brightness;\n    col *= attenuation;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}