{
    "Shader": {
        "info": {
            "date": "1526651170",
            "description": "A basic ray-marching / distance field sketch.\nUse the mouse to position the light.\n\n",
            "flags": 0,
            "hasliked": 0,
            "id": "4dtfRs",
            "likes": 8,
            "name": "Hello raymarch 001",
            "published": 3,
            "tags": [
                "raymarch"
            ],
            "usePreview": 0,
            "username": "iridule",
            "viewed": 606
        },
        "renderpass": [
            {
                "code": "/*\n*\tBasic Raymarch / Distance field shader\n*/\n\n/*\n*\tBasic Rotation matrices\n*/\nmat3 rotateX(float a) {\n\treturn mat3(\n    \t1.0, 0.0, 0.0,\n        0.0, cos(a), sin(a),\n        0.0, -sin(a), cos(a)\n    );\n}\n\nmat3 rotateY(float a) {\n\treturn mat3(\n    \tcos(a), 0.0, sin(a),\n        0.0, 1.0, 0.0,\n        -sin(a), 0.0, cos(a)\n    );\n}\n\nmat3 rotateZ(float a) {\n\treturn mat3(\n    \tcos(a), sin(a), 0.0,\n        -sin(a), cos(a), 0.0,\n        0.0, 0.0, 1.0\n    );\n}\n\n/*\n*\tSigned Distance Functions\n*/\nfloat sphere_sdf(vec3 p) {\n\treturn length(p) - 1.0;\n}\n\nfloat cube_sdf(vec3 p) {\n return length(max(abs(p)- vec3(0.5, 0.5, 0.5),0.0));\n}\n\nfloat torus_sdf(vec3 p) {\n  vec2 q = vec2(length(p.xz) - 0.9, p.y);\n  return length(q) - 0.1;\n}\n\n/*\n*\tRaymarch / trace function\n*/\nfloat trace(vec3 o, vec3 r, mat3 tf) {\n\tfloat t = 0.0;\n    for (int i = 0; i < 32; i++) {\n    \tvec3 p = o + r * t;\n        float d = cube_sdf(tf * p);\n        t += d * 0.5;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    float time = iTime;\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv *= vec2(iResolution.x / iResolution.y, 1.0);\n\n    vec3 p = vec3(uv, 0.0) + vec3(0.0, 0.0, 1.0);\n    \n    vec3 l = vec3(uv, 0.0) + vec3(iMouse.x / iResolution.x * 4.0 - 2.0, iMouse.y / iResolution.y * 4.0 - 2., 3.0);\n   \tvec3 n = normalize(p);\n    \n    vec3 lp = normalize(l - p);\n    vec3 lc = vec3(dot(lp, n));\n    vec3 color = vec3(1.0, 0.0, 0.0);\n    \n    vec3 r = normalize(p);\n    vec3 o = vec3(0.0, 0.0, -3.0);\n    \n    float t = trace(o, r, rotateZ(time) * rotateY(time));\n   \n    float fog = 1.0 / (1.0 + t * t * 0.1);\n    \n    color.b *= fog;\n    vec3 fc = vec3(fog * lc * color);\n    \n    fragColor = vec4(fc, 1.0);\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}