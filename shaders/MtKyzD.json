{
    "Shader": {
        "info": {
            "date": "1535420606",
            "description": "Glass cubes in infinity mirror room",
            "flags": 0,
            "hasliked": 0,
            "id": "MtKyzD",
            "likes": 16,
            "name": "Glass cubes in infinity mirror",
            "published": 3,
            "tags": [
                "reflection",
                "refraction",
                "glass",
                "mirror"
            ],
            "usePreview": 0,
            "username": "keim",
            "viewed": 1234
        },
        "renderpass": [
            {
                "code": "#define SHADERTOY\n\nprecision highp float;\n#ifdef SHADERTOY\n vec2  resolution, mouse;\n float time;\n#else\n uniform vec2  resolution;     // resolution (width, height)\n uniform vec2  mouse;          // mouse      (0.0 ~ 1.0)\n uniform float time;           // time       (1second == 1.0)\n uniform sampler2D backbuffer; // previous scene texture\n#endif\n\n\n//----- Ray-tracing parameters\nconst int   MAX_TRACE_STEP  = 100;\nconst float MAX_TRACE_DIST  = 300.;\nconst float NO_HIT_DIST     = 100.;\nconst float TRACE_PRECISION = .001;\nconst float FUDGE_FACTOR    = .9;\nconst int   RAY_TRACE_COUNT = 8;\n\n// -- lighting parameters\nconst int   GI_TRACE_STEP = 4;\nconst float GI_LENGTH = 1.6;\nconst float GI_STRENGTH = 1.;\nconst float AO_STRENGTH = .4;\nconst int   SS_MAX_TRACE_STEP = 7;\nconst float SS_MAX_TRACE_DIST = 50.;\nconst float SS_MIN_MARCHING = .3;\nconst float SS_SHARPNESS = 1.;\nconst float CS_STRENGTH = 0.2;\nconst float CS_SHARPNESS = 0.2;\n\n//----- Demo parameters\nconst float BPM = 120.;\nconst vec3 BG = vec3(.5);\n\n//----- Constant\nconst vec3 PI = vec3(1.5707963,3.1415927,6.2831853);\nconst vec3 V  = vec3(0,TRACE_PRECISION,1);\n\n\n\n//----- Structures\nstruct Material {\n  vec3  kd, tc;\n  float rl, rr; // diffusion, transparent-color, reflectance, refractive index\n};\nfloat rr2rl(float rr) { float v=(rr-1.)/(rr+1.); return v*v; }\nMaterial matt(vec3 kd) { return Material(kd, vec3(0), 0., 1.); }\nMaterial mirror(vec3 kd, float rl) { return Material(kd, vec3(0), rl, 0.); }\nMaterial glass(vec3 tc, float rr) { return Material(vec3(0), tc, rr2rl(rr), rr); }\n\nstruct Surface {\n  float d;      // distance\n  Material mat; // material\n};\nSurface near(Surface s,Surface t) { if (s.d<t.d) return s; return t; }\nSurface near(Surface s,Surface t,Surface u) { return near(near(s, t), u); }\nSurface near(Surface s,Surface t,Surface u,Surface v) { return near(near(s,t),near(u,v)); }\nSurface NO_HIT = Surface(NO_HIT_DIST, Material(vec3(0), vec3(0), 0., 1.));\n\nstruct Ray {\n  vec3  org, dir, col;     // origin, direction, color\n  float len, stp, rr, sgn; // length, marching step, refractive index of current media, sign of distance function\n};\nRay ray(vec3 o, vec3 d) { return Ray(o,d,vec3(1),0.,0.,1.,1.); }\nRay ray(vec3 o, vec3 d, vec3 c, float rr, float s) { return Ray(o,d,c,0.,0.,rr,s); }\nvec3 _pos(Ray r) { return r.org+r.dir*r.len; }\n\nstruct Hit {\n  vec3 pos, nml; // position, normal\n  Ray ray;       // ray\n  Surface srf;   // surface\n  bool isTransparent, isReflect;  // = (len2(srf.mat.tc) > 0.001, srf.mat.rl > 0.01)\n};\nHit nohit(Ray r) { return Hit(vec3(0), vec3(0), r, NO_HIT, false, false); }\n\nstruct Camera {\n  vec3  pos, tgt, rol;  // position, target, roll\n  float fcs;            // focal length\n};\nmat3 cameraMatrix(Camera c) { vec3 w=normalize(c.pos-c.tgt),u=normalize(cross(w,c.rol)); return mat3(u,normalize(cross(u,w)),w); }\n\nstruct Light {\n  vec3 dir, col, amb;    // direction, color\n};\nLight amb = Light(vec3(0,1,0), vec3(1.0), vec3(0.02));\n\n//----- ray trace caluclations\nRay rayScreen(in vec2 p, in Camera c) { return ray(c.pos, normalize(cameraMatrix(c) * vec3(p.xy, -c.fcs))); }\nRay rayReflect(in Hit h, in float rl) { return ray(h.pos+h.nml*.01, reflect(h.ray.dir, h.nml), h.ray.col*rl, h.ray.rr, h.ray.sgn); }\nRay rayRefract(in Hit h, in float rr) {\n  vec3 r = refract(h.ray.dir, h.nml, h.ray.rr/rr);\n  if (length(r)<.01) return rayReflect(h, 1.);\n  return ray(h.pos-h.nml*.01, r, h.ray.col*h.srf.mat.tc, rr, -h.ray.sgn);\n}\n\n\n\n\n\nvec2 uv;\nfloat tick, pick;\nvec4  gamma(vec4 c){return vec4(pow(c.rgb,vec3(1./2.2)),c.a);}\nvec3  hsv(float h,float s,float v){return((clamp(abs(fract(h+vec3(0,2,1)/3.)*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;}\nfloat fresnel(float r, float dp) {return r+(1.-r)*pow(1.-abs(dp),5.);}\nvec2  circle(float a){return vec2(cos(a),sin(a));}\nmat3  euler(float h, float p, float r){float a=sin(h),b=sin(p),c=sin(r),d=cos(h),e=cos(p),f=cos(r);return mat3(f*e,c*e,-b,f*b*a-c*d,f*d+c*b*a,e*a,c*a+f*b*d,c*b*d-f*a,e*d);}\nfloat dfPln(vec3 p, vec3 n, float z){return dot(p,n)+z;}\nfloat dfRoom(vec3 p, vec3 s) {vec3 v=s-abs(p); return min(v.x, min(v.y, v.z));}\nfloat dfBox(vec3 p, vec3 b, float r){return length(max(abs(p)-b,0.))-r;}\nvec3  doRep(vec3 p, vec3 r){ return mod(p+r*.5,r)-r*.5; }\nfloat dfp2l(vec3 p, vec3 d, vec3 c) { return length(dot(c-p,d)*d+p-c); }\nfloat checker(vec3 u, vec3 s){return mod(floor(u.x/s.x)+floor(u.y/s.y)+floor(u.z/s.z),2.);}\n\nvec3 lightpos[3];\nvec3 lightcol[3];\n\nSurface map(in vec3 p) {\n    vec3 c = mix(vec3(0.1), vec3(0.5), checker(p, vec3(6)));\n    Surface s = Surface(dfRoom(p, vec3(37.1)), mirror(c,0.5));\n    vec3 q = doRep(p, vec3(30));\n    return  near(s, Surface(dfBox(q*euler(pick/16.,pick/7.,0.), vec3(3.5), .8), glass(hsv(tick/64.,.4,.9),1.6)));\n}\n\nvec3 background(in Ray ray) {\n    return BG;\n}\n\n\n\n//----- Lighting\nvec3 emittance(in Ray ray, in Light lit) {\n    return pow(dfp2l(ray.org, ray.dir, lit.dir)*40., -1.5) * lit.col;\n}\n\nvec3 diffusion(in vec3 nml, in Light lit) {\n    return max(dot(nml, lit.dir) * lit.col, 0.);\n}\n\nvec4 shading(in vec3 pos, in vec3 dir) {\n  vec3 color;\n  float shade = 1.0, len = SS_MIN_MARCHING;\n  for (int i=SS_MAX_TRACE_STEP; i!=0; --i) {\n    Surface s = map(pos + dir*len);\n    color = s.mat.tc;\n    shade = min(shade, SS_SHARPNESS * s.d / len);\n    len += max(s.d, SS_MIN_MARCHING);\n    if (s.d<TRACE_PRECISION || len>SS_MAX_TRACE_DIST) break;\n  }\n  shade = clamp(shade, 0., 1.);\n  return vec4(pow((1.-shade), CS_SHARPNESS) * color * CS_STRENGTH, shade);\n}\n\nvec4 occlusion(in vec3 pos, in vec3 nml) {\n  vec3 color;\n  float occl;\n  for (int i=GI_TRACE_STEP; i!=0; --i) {\n    float hr = .01 + float(i) * GI_LENGTH / 4.;\n    Surface s = map(nml * hr + pos);\n    occl += (hr - s.d);\n    color += s.mat.kd * (hr - s.d);\n  }\n  return vec4(color * GI_STRENGTH / GI_LENGTH, clamp(1.-occl * AO_STRENGTH / GI_LENGTH, 0., 1.));\n}\n\nvec3 lighting(in Hit h, in Light lit) {\n  if (h.ray.len > MAX_TRACE_DIST) return background(h.ray);\n  vec4 occl = occlusion(h.pos, h.nml);\n  vec4 shad = shading(h.pos, lit.dir);\n  vec3 lin = (diffusion(h.nml, lit) * shad.w + shad.rgb) * occl.w + occl.rgb + lit.amb;\n  return  h.srf.mat.kd * lin;\n}\n\n\n//----- Ray trace\nvec3 _normal(in vec3 p){\n  float d = map(p).d;\n  return normalize(vec3(map(p+V.yxx).d - d, map(p+V.xyx).d - d, map(p+V.xxy).d - d));\n}\n\nHit trace(in Ray r) {\n  Surface s;\n  for(int i=0; i<MAX_TRACE_STEP; i++) {\n    s = map(_pos(r));\n    s.d *= r.sgn;\n    r.len += s.d * FUDGE_FACTOR;\n    r.stp = float(i);\n    if (s.d < TRACE_PRECISION) break;\n    if (r.len > MAX_TRACE_DIST) return nohit(r);\n  }\n  vec3 p = _pos(r);\n  float interior = .5-r.sgn*.5;\n  s.mat.rr = mix(s.mat.rr, 1., interior);\n  s.mat.tc = max(s.mat.tc, interior);\n  return Hit(p, _normal(p)*r.sgn, r, s, (length(s.mat.tc)>.01), (s.mat.rl>.01));\n}\n\nvec3 _difColor(inout Hit h, in Light l) {\n  if (length(h.srf.mat.kd) < .01) return vec3(0);\n  vec3 col = lighting(h, l) * h.ray.col;\n  h.ray.col *= 1. - h.srf.mat.kd;\n  return col;\n}\n\nRay _nextRay(Hit h) {\n  if (h.isTransparent) return rayRefract(h, h.srf.mat.rr);\n  return rayReflect(h, fresnel(h.srf.mat.rl, dot(h.ray.dir, h.nml)));\n}\n\nvec4 render(in Ray ray) {\n  vec3 col=vec3(0), c;\n  Hit h0, h1;\n  float l0, rl;\n  h0 = trace(ray);\n  l0 = h0.ray.len;\n\n  col += _difColor(h0, amb);\n  if (!h0.isReflect) return vec4(col, l0);\n  rl = fresnel(h0.srf.mat.rl, dot(h0.ray.dir, h0.nml));\n  h1 = trace(rayReflect(h0, rl));\n  col += _difColor(h1, amb);\n  h0.ray.col *= 1. - rl;\n  if (!h0.isTransparent) h0 = h1;\n  for (int i=RAY_TRACE_COUNT; i!=0; --i) {\n    if (!h0.isReflect) return vec4(col, l0);\n    h0 = trace(_nextRay(h0));\n    col += _difColor(h0, amb);\n  }\n  c = h0.ray.col;\n  if (length(c) >= .5) col += background(h0.ray) * c * c;\n\n  return vec4(col, l0);\n}\n\nvec4 entryPoint(vec2 fragCoord) {\n    uv = (fragCoord * 2.-resolution) / resolution.y;\n    tick = time * BPM / 60.;\n    pick = tick * PI.z;\n\n    lightpos[0] = vec3(cos(pick/11.)*10.+5., cos(pick/16.)*10., sin(pick/8.)*10.);\n    lightpos[1] = vec3(cos(pick/8.)*8.+5., cos(pick/6.)*8., sin(pick/7.)*8.);\n    lightpos[2] = vec3(cos(pick/4.)*12.+5., cos(pick/11.)*12., sin(pick/9.)*12.);\n    lightcol[0] = vec3(5,10,50);\n    lightcol[1] = vec3(5,30,5);\n    lightcol[2] = vec3(40,8,8);\n\n    Camera camera = Camera(vec3(sin(pick/14.)*5.+3., circle(pick/32.)*20.), vec3(0,0,0), vec3(1,0,0), 1.732);\n    Ray ray = rayScreen(uv, camera);\n\n    return gamma(render(ray));\n}\n\n\n\n\n#ifdef SHADERTOY\nvoid mainImage(out vec4 flagColor,in vec2 flagCoord) {\n    resolution = iResolution.xy;\n    time = iTime;\n    mouse = iMouse.xy;\n    flagColor = entryPoint(flagCoord);\n}\n#else\nvoid main() {\n    gl_FragColor = entryPoint(gl_FragCoord.xy);\n}\n#endif",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}