{
    "Shader": {
        "info": {
            "date": "1702237291",
            "description": "Hyperbolic Pentagonal Tilings. Mouse drags centre point. 'x' to enter \"configuration mode\". See header for more info, controls, etc.",
            "flags": 48,
            "hasliked": 0,
            "id": "dtyfDh",
            "likes": 19,
            "name": "Hyperbolic Pentagons",
            "published": 3,
            "tags": [
                "tiling",
                "pentagon",
                "hyperbolic",
                "hyperboloid"
            ],
            "usePreview": 1,
            "username": "mla",
            "viewed": 228
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Hyperbolic Pentagonal Tilings, mla, 2023.\n//\n// A convex hyperbolic pentagon with angles integral fractions of π will\n// tile the hyperbolic plane. As well as the angles, two side lengths\n// of the pentagon can be specified.\n//\n// Set side lengths in \"configuration mode\" by pressing 'x' and dragging\n// the red ring. Not all combinations of angles and lengths are possible.\n// The screen may flash red for an invalid combination.\n//\n// When not in configuration mode, use the mouse to drag centre point.\n//\n// <up>,<down>: zoom in/out\n// c: don't colour tiles\n// d: don't shade area outside disc\n// h: half space projection\n// i: set angles R and S to zero (overrides 'j')\n// j: set all angles to PI/3\n// l: use thick lines\n// t: don't show travelling point\n// v: don't show vertices\n// x: config mode\n// z: zoom in (only in half space projection)\n//\n// Most of the calculations are done in the hyperboloid model, with\n// the Poincare disc used for folding into the fundamental region.\n//\n// Point A is the centre, (0,0,1), which lies on lines a and e, at angle\n// P to each other. Measuring along a and e from A gives two more\n// points, B and E and we construct lines b and d through them at angles \n// Q and T. Finally, a line c is constructed making angles R and S with b\n// and d. This line (if it exists) is unique and determines the length of\n// the final three segments.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// Polygon angles are PI/P etc. Can be overridden in mainImage.\nint P = 2, Q = 3, R = 4, S = 5, T = 6;\n\n// Basic operations for hyperbolic (Minkowski) space\n\n// Inner product\nfloat hdot(vec3 p, vec3 q) {\n  return dot(vec3(1,1,-1)*p,q);\n}\n\nvec3 hcross(vec3 p, vec3 q) {\n  // hdot(p,hcross(p,q)) = hdot(q,hcross(p,q)) = 0\n  return cross(p,q)*vec3(1,1,-1);\n}\n\nfloat hlength(vec3 p) {\n  return sqrt(abs(hdot(p,p)));\n}\n\n// Normalize a point or a line\nvec3 hnormalize(vec3 p) {\n  return p/hlength(p);\n}\n\n// Map point on plane to hyperboloid hnorm(p) = -1\nvec3 unproject(vec2 z) {\n  // k²|z|²-(1-k)² = -1\n  // k²|z|²-1+2k-k² = -1\n  // k|z|²+2-k = 0\n  float k = 2.0/(1.0-dot(z,z));\n  return vec3(k*z,k-1.0);\n}\n\n// NB: sinh(x) = asinh(x) = tanh(x) = x (approximately) for\n// small values of x (eg. sinh 0.1 = 0.10017, tanh 0.1 = 0.0997)\n// Hyperbolic distance from line\nfloat hline(vec3 p, vec3 l) {\n  return abs(asinh(hdot(p,l)));\n}\n\n// Hyperbolic distance between points\nfloat hpoint(vec3 p, vec3 q) {\n  //return acosh(-hdot(p,q)); // Bad truncation error\n  return 2.0*abs(asinh(0.5*hlength(p-q)));\n}\n\n// Find a point on the line formed by the intersections\n// of planes l and m. Try to find point of form\n// (x,y,0), (x,0,z) or (0,y,z) by solving a 2x2\n// linear system. Construct three matrices & use the one\n// with largest determinant (it's possible for two\n// determinants to be zero, but not all three if the\n// planes aren't parallel).\nvec3 linepoint(vec3 l, vec3 m, float a, float b) {\n  vec2 A = vec2(1,-1); // adjust for metric\n  mat2 m0 = mat2(l.xy,m.xy);\n  mat2 m1 = mat2(A*l.xz,A*m.xz);\n  mat2 m2 = mat2(A*l.yz,A*m.yz);\n  float d0 = abs(determinant(m0));\n  float d1 = abs(determinant(m1));\n  float d2 = abs(determinant(m2));\n  float dmax = max(d0,max(d1,d2));\n  if (dmax == d1) m0 = m1;\n  else if (dmax == d2) m0 = m2;\n  vec3 p = vec3(vec2(a,b)*inverse(m0),0);\n  if (dmax == d1) p = p.xzy;\n  else if (dmax == d2) p = p.zxy;\n  assert(eq(hdot(p,l),a));\n  assert(eq(hdot(p,m),b));\n  return p;\n}\n\n// Given vectors l and m, return a normalized vector n\n// with l.n = a, m.n = b (all with Minkowski product)\n// sign parameter says if we want a line (spacelike) or a point (timelike)\nbool f(vec3 l, vec3 m, float a, float b, out vec3 n, float sign) {\n  // Want a line m with hdot(l,n) = A, hdot(m,n) = B\n  vec3 r = hcross(l,m); // Direction vector for intersection of planes l and m\n  // Now find p with hdot(p,l) = A, hdot(p,m) = B\n  vec3 p = linepoint(l,m,a,b);\n  // Now try to find a normalized point on that line ie. hnorm(p+tr) = <sign>\n  // (p+tr).(p+tr) - sign = 0\n  // p.p + 2t(p.r) + t²(r.r) - 1 = 0\n  // Set p.r = 0, so B = 0 in quadratic formula\n  p -= hdot(p,r)/hdot(r,r)*r;\n  float A = hdot(r,r);\n  float C = hdot(p,p) - sign;\n  float D = -A*C;\n  if (D < 0.0) return false;\n  // Two solutions are eg. for complementary angles, opposite distances.\n  float t = sqrt(D)/A;\n  n = p+t*r;\n  return true;\n}\n\n// Find a (normalized) point p with l.p = a, m.p = b\n// l and m can be points or lines\nvec3 fpoint(vec3 l, vec3 m, float a, float b) {\n  vec3 p;\n  bool t = f(l,m,a,b,p,-1.0);\n  assert(t);\n  assert(p.z >= 0.0);\n  return p;\n}\n\n// Find a (normalized) line p with l.p = a, m.p = b\n// l and m can be points or lines\nvec3 fline(vec3 l, vec3 m, float a, float b) {\n  vec3 p;\n  bool t = f(l,m,a,b,p,1.0);\n  assert(t);\n  assert(p.z <= 0.0);\n  return p;\n}\n\n// Get point on line l, distance d from p, also on l.\n// Same as fpoint(p,l,-cosh(d),0) but less rounding error.\nvec3 pointatdistance(vec3 p, vec3 l, float d) {\n  vec3 r = hcross(p,l); // Tangent vector\n  float k = tanh(d)/hlength(r); // Get right angle\n  vec3 q = p+k*r;\n  return hnormalize(q); // And normalize\n}\n\n// Reflect in a hyperbolic line\nint tryreflect(vec3 l, int i, inout vec3 p, inout uint h) {\n  float k = hdot(p,l);\n  if (k > 0.0) return 0;\n  p -= 2.0*k*l;\n  h = ihash(h^uint(i));\n  return 1;\n}\n\n// Reflect in a euclidean line\nint tryreflect(vec2 l, int i, inout vec2 z, inout uint h) {\n  float k = dot(z,l);\n  if (k > 0.0) return 0;\n  z -= 2.0*k*l;\n  h = ihash(h^uint(i));\n  return 1;\n}\n\n// Invert in a euclidean circle\nint tryinvert(vec3 c, int i, inout vec2 z, inout uint h) {\n  float r2 = c.z;\n  vec2 z1 = z-c.xy;\n  float l2 = dot(z1,z1);\n  if (l2 > r2) return 0;\n  z1 *= r2/l2;\n  z = z1+c.xy;\n  h = ihash(h^uint(i));\n  return 1;\n}\n\n// Convert hyperbolic line into a Euclidean circle.\n// z component is square of radius.\nvec3 tocircle(vec3 l) {\n  assert(l.z != 0.0);\n  l /= l.z;\n  l.z = dot(l.xy,l.xy)-1.0;\n  return l;\n}\n\n// Convert hyperbolic line into a Euclidean line.\nvec2 toline(vec3 l) {\n  assert(l.z == 0.0);\n  return l.xy;\n}\n\nvec3 fold(vec2 z, int N, vec3 a, vec3 b, vec3 c, vec3 d, vec3 e, inout uint h) {\n  // Using Poincare model for the fold seems to be more stable\n  // so convert hyperbolic lines to Euclidean lines or circles\n  vec2 A = toline(a);\n  vec3 B = tocircle(b);\n  vec3 C = tocircle(c);\n  vec3 D = tocircle(d);\n  vec2 E = toline(e);\n  for (int i = 0; i < N; i++) {\n    int k = 0;\n    k += tryreflect(A,0,z,h);\n    k += tryinvert(B,1,z,h);\n    k += tryinvert(C,2,z,h);\n    k += tryinvert(D,3,z,h);\n    k += tryreflect(E,4,z,h);\n    if (k == 0) break;\n  }\n  return unproject(z);\n}\n\nvec3 hfold(vec2 z, int N, vec3 a, vec3 b, vec3 c, vec3 d, vec3 e, inout uint h) {\n  // Neat, but errors accumulate much more quickly\n  vec3 p = unproject(z);\n  for (int i = 0; i < N; i++) {\n    int k = 0;\n    k += tryreflect(a,0,p,h);\n    k += tryreflect(b,1,p,h);\n    k += tryreflect(c,2,p,h);\n    k += tryreflect(d,3,p,h);\n    k += tryreflect(e,4,p,h);\n    if (k == 0) break;\n  }\n  return p;\n}\n\n// Given a Euclidean distance d, and a direction p, return\n// an hspace point that is at that distance and direction\n// from the centre in the Poincare disc.\nvec3 pointfromcentre(float d, vec2 p) {\n  float x = 2.0*d/(1.0-d*d);\n  float t = sqrt(1.0+x*x);\n  return vec3(x*p,t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  // Calculate sides and vertices of the polygon.\n  // All angles are given, as well as side lengths for a and e.\n  // A a B b C c D d E e A ..\n  // A is at origin, so a and e are straight lines in disc model\n  // and have t = 0 in hyperboloid model.\n  // Angle at A is PI/P, etc\n  // R = 0 means R = PI/infinity, also works for S\n  if (key(CHAR_J)) P = Q = R = S = T = 3;\n  if (key(CHAR_I)) R = S = 0;\n  assert(P != 0 && Q != 0 && T != 0);\n  vec2 params = abs(getselection(0));\n  vec3 a = vec3(1,0,0);\n  vec3 e = vec3(-icos(P),isin(P),0);\n  vec3 A = vec3(0,0,1);\n  vec3 B = pointfromcentre(params[1],vec2(0,1));\n  vec3 E = pointfromcentre(params[0],vec2(isin(P),icos(P)));\n  vec3 b = fline(a,B,-icos(Q),0.0);\n  vec3 d = fline(E,e,0.0,-icos(T));\n  vec3 c = fline(d,b,-icos(S),-icos(R));\n  vec3 C = hnormalize(hcross(b,c));\n  vec3 D = hnormalize(hcross(c,d));\n  vec3 T = vec3(0); // This point will travel around the edges of the polygon\n  if (!configmode && !key(CHAR_T) && !key(CHAR_I)) {\n    // Set up the travelling point. If any points are ideal, this\n    // doesn't work too well, since the polygon perimeter is\n    // infinite, so don't do if 'i' pressed.\n    // Maybe I should have an array of points...\n    float k[] = float[](acosh(-hdot(A,B)),\n                        acosh(-hdot(B,C)),\n                        acosh(-hdot(C,D)),\n                        acosh(-hdot(D,E)),\n                        acosh(-hdot(E,A)));\n    float ttime = 0.0;\n    int N = k.length();\n    for (int i = 0; i < N; i++) ttime += k[i];\n    float etime = mod(iTime,ttime);\n    vec3 X = A, x = a;\n    for (int i = 0; i < N; i++) {\n      if (etime < k[i]) {\n        if (i == 1) X = B, x = b;\n        if (i == 2) X = C, x = c;\n        if (i == 3) X = D, x = d;\n        if (i == 4) X = E, x = e;\n        break;\n      }\n      etime -= k[i];\n    }\n    T = pointatdistance(X,x,etime);\n  }\n  vec2 z = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n  vec2 w = vec2(0);\n  if (!configmode) w = defaultselection();\n  float scale = 1.0;\n  scale *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  z *= scale;\n  w *= scale;\n  float lwidth = 0.02;\n  float pwidth = 3.0*lwidth;\n  if (!key(CHAR_L)) lwidth = 0.0;\n  \n  float px = fwidth(z.x);\n  bool dohalfplane = key(CHAR_H);\n  bool dozoom = key(CHAR_Z);\n  if (dohalfplane) z.y += scale;\n  // Conversion factor between hyperbolic and screen distances\n  float scalefactor = 1.0;\n  if (dohalfplane) {\n    if (dozoom) {\n      float k = exp(-iTime);\n      z *= k;\n      scalefactor /= k;\n    }\n    z.y += 1.0;\n    float k = 2.0/dot(z,z);\n    z *= k;\n    scalefactor /= k;\n    z.y -= 1.0;\n  }\n  scalefactor *= 0.5*abs(1.0 - dot(z,z));\n  if (!configmode) {\n    // Invert to mouse position\n    vec2 c = w;\n    z -= c;\n    z *= (dot(c,c)-1.0)/dot(z,z);\n    z += c;\n    z /= -dot(z,z);\n  }\n  bool indisc = dot(z,z) <= 1.0;\n  if (!indisc) z /= dot(z,z);\n  int N = configmode ? 0 : 10;\n  uint h = 12345678u; // hash for region\n  vec3 p = fold(z,N,a,b,c,d,e,h);\n  vec3 col = vec3(0.5,1,1);\n  if (!configmode && !key(CHAR_C)) col = h2rgb(float(h)/exp2(32.0));\n  {\n    float t = 1e8;\n    t = min(t,hline(p,a));\n    t = min(t,hline(p,b));\n    t = min(t,hline(p,c));\n    t = min(t,hline(p,d));\n    t = min(t,hline(p,e));\n    vec3 lcol = vec3(0.1);\n    if (!configmode && key(CHAR_W)) lcol = vec3(1);\n    col = mix(lcol,col,smoothstep(0.0,px/scalefactor,t - lwidth));\n  }\n  {\n    float t = 1e8;\n    if (!key(CHAR_V)) {\n      t = min(t,hpoint(p,A));\n      t = min(t,hpoint(p,B));\n      t = min(t,hpoint(p,C));\n      t = min(t,hpoint(p,D));\n      t = min(t,hpoint(p,E));\n    }\n    if (T != vec3(0)) {\n      t = min(t,hpoint(p,T));\n    }\n    col = mix(vec3(0),col,smoothstep(0.0,px/scalefactor,t - pwidth));\n  }\n  if (!key(CHAR_D) && !indisc) col *= 0.5;\n  if (configmode) {\n    vec2 p = map(fragCoord);\n    float d = abs(distance(p,getselection(0))-0.03)-0.005;\n    col = mix(vec3(1,0,0),col,0.25+0.75*smoothstep(0.0,px,d));\n  }\n  col = pow(col,vec3(0.4545));\n  if (alert) col.r = 1.0;\n  fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage(out vec4 t, vec2 uv) {\n  //setscale();\n  int i = int(uv.x); // Column number\n  int j = int(uv.y); // Row\n  t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  vec4 t0 = texelFetch(iChannel2,ivec2(0),0); // Get current state   \n  if (iFrame == 0 || t0 != vec4(1234.0)) {\n    t = vec4(0);\n  }  \n  if (j == 0) {\n    if (i == 0) t = vec4(1234.0);\n    else {\n      // First row - key count\n      // Do key repeat here as well?\n      float w1 = keystate(i,0).x;\n      if (w1 != t.w) {\n        t.w = w1;\n        // Don't count key changes when ALT pressed\n        if (keystate(KEY_ALT,0).x == 0.0 && w1 != 0.0) {\n          t.x++; t.y = iTime;\n        }\n      }\n      // Key repeat - only when shader is running!\n      // Should have longer pause after first key press.\n      if (t.w != 0.0 && keystate(KEY_ALT,0).x == 0.0 && iTime-t.y > 0.25) {\n        t.x++; t.y = iTime;\n      }\n    }\n  } else if (j == 1) {\n    if (i == 0 && iMouse.z != 0.0) t.xy = iMouse.xy;\n    if (i == 1 && iMouse.z == 0.0) t.xy = iMouse.xy;\n  } else if (j == 2 && key(i)) {\n    // Record mouse position when key pressed\n    t = vec4(iMouse.xy,0,iTime);\n  } else if (j == 3) {\n      // Cell 0 holds currently selected item, 0 = no selection\n    if (i == 0) {\n      if (configmode && t.x == 0.0 && iMouse.z > 0.0) {\n        vec2 mouse = map(iMouse.xy);\n        // No selection, but mouse now down\n        t.x = -1.0;\n        for (int i = nselections; i >= 1; i--) {\n          // Select topmost item (assume drawn 1..N)\n          vec2 p = texelFetch(iChannel2,ivec2(i,3),0).xy; // Get current state\n          if (distance(mouse,p) < 0.05) {\n            t.x = float(i);\n            break;\n          }\n        }\n      } else if (t.x != 0.0 && iMouse.z <= 0.0) {\n        // Clear selection if mouse up.\n        t.x = 0.0;\n      }\n      if (!configmode && t.x <= 0.0 && iMouse.z > 0.0) {\n        t.zw = iMouse.x < 20.0 ? vec2(0) : map(iMouse.xy);\n      }\n    } else if (iFrame == 0 || t.w != 1234.0) {\n      t.xy = initselection(i-1); // Current coordinates\n      t.w = 1234.0;\n    } else {\n      vec4 t0 = texelFetch(iChannel2,ivec2(0,3),0); // Get current state\n      if (int(t0.x) == i && iMouse.z > 0.0) {\n        // If currently selected, copy mouse position\n        t.xy = map(iMouse.xy);\n      }\n    }\n  }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store((key),0).x))\n#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\n#define map(screenpos) ((2.0*(screenpos)-iResolution.xy)/iResolution.y)\n#define getselection(i) (texelFetch(iChannel2,ivec2((i)+1,3),0).xy)\n//#define getselected() (texelFetch(iChannel2,ivec2(0,3),0))\n#define defaultselection() (texelFetch(iChannel2,ivec2(0,3),0).zw)\n//#define setscale() (scale *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP))))\n#define configmode (key(CHAR_X))\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nconst float PI =  3.141592654;\n\nconst int nselections = 1;\nvec2 initselection(int i) {\n  if (i == 0) return vec2(0.8,0.7);\n  if (i == 1) return vec2(0.75,0.25);\n  if (i == 2) return vec2(-2,-1.5);\n  if (i == 3) return vec2(0,-1);\n  if (i == 4) return vec2(0.25,0);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst int KEY_ALT = 18;\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n  return mix(vec3(1),rgb,0.8);\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nvec2 expi(float t) {\n  return normalize(vec2(cos(t),sin(t)));\n}\n\nbool eq(float a, float b) {\n  return abs(a-b) < 1e-4;\n}\n\nfloat COS[] =\n  float[](1.0,-1.0,0.0,0.5,0.7071067812,0.8090169944,0.8660254038,\n          0.9009688679,0.9238795325,0.9396926208,0.9510565163,0.9594929736,\n          0.9659258263,0.9709418174,0.9749279122,0.9781476007,0.9807852804,\n          0.9829730997,0.984807753,0.9863613034,0.9876883406,0.9888308262,\n          0.9898214419,0.990685946,0.9914448614,0.9921147013,0.9927088741,\n          0.9932383577,0.9937122099,0.9941379572,0.9945218954,0.9948693234);\n\nfloat icos(int p) {\n  // cos(PI/p)\n  if (p < COS.length()) return COS[p];\n  return cos(PI/float(p));\n}\n                        \nfloat isin(int p) {\n  // sin(PI/p)\n  float t = icos(p);\n  return sqrt(1.0-t*t);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}