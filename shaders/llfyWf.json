{
    "Shader": {
        "info": {
            "date": "1506637988",
            "description": "IÃ±igo Quiles' Useful Little Functions[0] ported to GLSL as an exercise from The Book of Shaders[1].  Comment out lines to visualize the functions.\n\n[0]: https://iquilezles.org/articles/functions/functions.htm\n[1]: https://thebookofshaders.com/05/",
            "flags": 0,
            "hasliked": 0,
            "id": "llfyWf",
            "likes": 3,
            "name": "Useful Shaping",
            "published": 3,
            "tags": [
                "gradient",
                "curve",
                "shaping"
            ],
            "usePreview": 0,
            "username": "lordbunson",
            "viewed": 624
        },
        "renderpass": [
            {
                "code": "const vec3 lineColor = vec3(0.0, 1.0, 0.0);\n\nfloat plotLine(vec2 uv, float y){\n    return smoothstep(y - 0.02, y, uv.y) -\n           smoothstep(y, y + 0.02, uv.y);\n}\n\n// Almost Identity\n// M = Threshhold \nfloat almostIdentity(float x, float m, float n){\n    \n    if(x > m) return x;\n    \n    float a = 2.0 * n - n;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x / m;\n    \n    return (a * t + b) * t * t + n;\n    \n}\n\n// Impulse\n// triggering behavior\n// envelope music\n// fast growth / slow decay\nfloat impulse(float x, float k){\n    \n    float h = k * x;\n    return h * exp(1.0 - h);\n    \n}\n\n\n// Cubic Pulse\n// Cheap gaussian\n// smoothstep(c-w, c, x) - smoothstep(c, c+w, x);\nfloat cubicPulse(float x, float c, float w){\n    \n    x = abs(x - c);\n    \n    if (x > w) return 0.0;\n    \n    x /= w;\n    \n    return 1.0 - x * x * (3.0 - 2.0 * x);\n}\n\n// Exponential Step\n// Natural attenuation - exp of a linearly decaying quantity.\n// Gaussian - exp of a quadratically decaying quantity.\nfloat expStep(float x, float k, float n){\n\treturn exp(-k * pow(x, n));   \n}\n\n// Gain\n// Expand the sides compress the center\n// Identity: k = 1\n// k < 1 gain shape, k > 1 s shape\nfloat gain(float x, float k){\n    float a = 0.5 * pow(2.0 * ((x < 0.5) ? x : 1.0 - x), k);\n    return (x < 0.5) ? a : 1.0 - a;\n}\n\n// Parabola\nfloat parabola(float x, float k){\n    return pow(4.0 * x * (1.0 - x), k);   \n}\n\n// Power Curve\n// useful to skew shapes to make things\nfloat powerCurve(float x, float a, float b){\n   float k = pow(a + b, a + b) / (pow(a, a) * pow(b, b)); \n    return k * pow(x, a) * pow(1.0 - x, b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;  \n\t\n    //float y = almostIdentity(uv.x, 0.2, 0.2);\n    //float y = impulse(uv.x, 11.);\n    //float y = cubicPulse(uv.x, 0..5, 0.4);\n    //float y = expStep(uv.x, 5.0, 3.0);\n    //float y = gain(uv.x, 0.25);\n    //float y = gain(uv.x, 4.0);\n    //float y = parabola(uv.x, 3.0);\n    float y = powerCurve(uv.x, 4.0, 10.0);\n    \n    \n    vec3 gradient = vec3(y);\n    \n    float line = plotLine(uv, y);\n    \n    vec3 color = (1.0 - line) * gradient + line * lineColor;\n\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}