{
    "Shader": {
        "info": {
            "date": "1684578747",
            "description": "Flythrough of a packed spheres / rhombic dodecahedral honeycomb terrain\n\nMouse drag to look around\nDefines in Common",
            "flags": 32,
            "hasliked": 0,
            "id": "mlK3DD",
            "likes": 48,
            "name": "Rhombic Dodecahedron Traversal",
            "published": 3,
            "tags": [
                "3d",
                "raytracing",
                "grid",
                "voxel",
                "motionblur",
                "bloom",
                "honeycomb",
                "dodecahedron",
                "rhombic"
            ],
            "usePreview": 0,
            "username": "gelami",
            "viewed": 922
        },
        "renderpass": [
            {
                "code": "\n// Rhombic Dodecahedron Traversal - gelami\n// https://www.shadertoy.com/view/mlK3DD\n\n/*\n * Flythrough of a packed sphere grid / rhombic dodecahedral honeycomb terrain\n * \n * Mouse drag to look around\n * Defines in Common\n * \n * The traversal is simply done by finding the nearest cell position from the grid\n * Then for each step intersects the backfaces of a rhombic dodecahedron\n *   and advancing the cell position using its normal\n * \n * It's similar to my hexagon grid shader, but really the method\n *   can be used for any tessellation of a space-filling polytope\n * I have a truncated octahedron grid traversal coming up soon as well\n * \n * Extruded Hexagon Grid Traversal - gelami\n * https://www.shadertoy.com/view/Dly3zm\n * \n * Bloom setup taken from my bloom shader, with a prefiltering threshold added\n *   and without the 3x3 blur on the upsampling pass:\n * 2-Pass Buffer Bloom - gelami\n * https://www.shadertoy.com/view/cty3R3\n *\n * FXAA 3.11 implementation from:\n * Two Grid Traversal w/ 1Pass DoF - gelami\n * https://www.shadertoy.com/view/dtt3DS\n * \n * \n * Other cool space-filling polyhedron shaders:\n * \n * Octahedral Voxel Tracing - fizzer\n * https://www.shadertoy.com/view/4lcfDB\n *\n * Octahedron Grid Raycasting - Poisson\n * https://www.shadertoy.com/view/NlcBzf\n * \n * Truncated Octahedral Voxels - dr2\n * https://www.shadertoy.com/view/3dsXWf\n * \n * Packed Spheres SDF - blackle\n * https://www.shadertoy.com/view/3djBDh\n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ndc = (2. * (fragCoord) - iResolution.xy) / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    #ifdef MOTION_BLUR\n    \n    const float fov = 120.0;\n    const float invTanFov = 1.0 / tan(radians(fov) * 0.5);\n    const float maxMotionBlur = 12.0;\n    \n    float mb = MOTION_BLUR_STRENGTH * dot(ndc, ndc) / invTanFov;\n    vec2 dir = normalize(ndc) / iResolution.xy;\n    \n    float o = texelFetch(iChannel2, ivec2(fragCoord) % 1024, 0).r;\n    o = fract(o + 0.61803398875 * float(iFrame));\n    \n    float w = 1.0;\n    \n    #define MOTION_BLUR_SAMPLES 8\n    for (int i = 0; i < MOTION_BLUR_SAMPLES; i++)\n    {\n        float t = (float(i) + o) / float(MOTION_BLUR_SAMPLES) - 0.5;\n        vec2 p = uv + mb * dir * t;\n        if (p == saturate(p))\n        {\n            col += texture(iChannel0, p).rgb;\n            w++;\n        }\n    }\n    col /= w;\n    #endif\n    \n    #ifdef BLOOM\n    vec3 bloom = vec3(0);\n    \n    bloom += SampleLod(iChannel1, uv, iResolution.xy, 0).rgb;\n    bloom += SampleLod(iChannel1, uv, iResolution.xy, 1).rgb;\n    bloom += SampleLod(iChannel1, uv, iResolution.xy, 2).rgb;\n    bloom += SampleLod(iChannel1, uv, iResolution.xy, 3).rgb;\n    bloom += SampleLod(iChannel1, uv, iResolution.xy, 4).rgb;\n    bloom += SampleLod(iChannel1, uv, iResolution.xy, 5).rgb;\n    \n    bloom /= 6.0;\n    \n    col += bloom * BLOOM_STRENGTH;\n    #endif\n    \n    #if 0\n    col = col / (1.0 + col);\n    col = smoothstep(vec3(0), vec3(1), col);\n    #else\n    col = ACESFilm(col * 0.35);\n    #endif\n    \n    fragColor = vec4(linearTosRGB(col), 1);\n    fragColor += (dot(hash23(vec3(fragCoord, iTime)), vec2(1)) - 0.5) / 255.;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define BLOOM\n#define BLOOM_MAX_LOD 6\n#define BLOOM_THRESHOLD 0.6\n#define BLOOM_STRENGTH 0.75\n\n#define CAMERA_SPEED 6.5\n\n#define EMI_SCALE 5.0\n\n#define FXAA\n#define MOTION_BLUR\n\n#define MOTION_BLUR_STRENGTH 4.0\n\n//#define SIMPLE_TRAVERSAL\n#define SPHERES\n\n#define STEPS 256\n#define MAX_DIST 100.\n#define EPS 1e-4\n\n#define PI (acos(-1.))\n#define TAU (PI*2.)\n\nvec4 SampleLod(sampler2D tex, vec2 uv, vec2 res, const int lod)\n{\n    vec2 hres = floor(res / 2.0);\n    \n    vec2 nres = hres;\n    float xpos = 0.0;\n    int i = 0;\n    for (; i < lod; i++)\n    {\n        xpos += nres.x;\n        \n        nres = floor(nres / 2.0);\n    }\n    \n    vec2 nuv = uv * vec2(nres);\n    \n    nuv = clamp(nuv, vec2(0.5), vec2(nres)-0.5);\n    nuv += vec2(xpos, 0);\n    \n    return texture(tex, nuv / res);\n}\n\nfloat pack(vec2 v)\n{\n    return uintBitsToFloat(packHalf2x16(v));\n}\n\nvec2 unpack(float v)\n{\n    return unpackHalf2x16(floatBitsToUint(v));\n}\n\n// Ray-sphere intersesction\n// https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nvec2 sphereIntersection(vec3 ro, vec3 rd, float ra )\n{\n    vec3 oc = ro;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    if (b > 0.0 && c > 0.0)\n        return vec2(MAX_DIST);\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(MAX_DIST); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n// Ray-rhombic dodecahedron intersection\nvec2 rhombicDodecahedronIntersection(vec3 ro, vec3 rd, float s, out vec3 normal)\n{\n    const vec3 rdn = vec3(0.5, -0.5, sqrt(2.0)/2.0);\n    \n    float tN, tF;\n    {\n        vec2 ird = 1.0 / rd.xz;\n        vec2 n = ro.xz * ird;\n        vec2 k = abs(ird) * s;\n\n        vec2 t0 = -n - k;\n        vec2 t1 = -n + k;\n\n        tN = max(t0.x, t0.y);\n        tF = min(t1.x, t1.y);\n\n        normal = vec3(-sign(ird) * step(t0.yx, t0), 0).xzy;\n    }\n    \n    {\n        vec4 ird = 1.0 / vec4(dot(rd, rdn.xzx), dot(rd, rdn.yzx), dot(rd, rdn.xzy), dot(rd, rdn.yzy));\n        vec4 n = ird * vec4(dot(ro, rdn.xzx), dot(ro, rdn.yzx), dot(ro, rdn.xzy), dot(ro, rdn.yzy));\n        vec4 k = abs(ird) * s;\n        \n        vec4 t0 = -n - k;\n        vec4 t1 = -n + k;\n        \n        float t = max(max(t0.x, t0.y), max(t0.z, t0.w));\n        \n        if (t > tN)\n        {\n            if (t0.x == t)\n                normal = rdn.xzx * -sign(ird.x);\n            else if (t0.y == t)\n                normal = rdn.yzx * -sign(ird.y);\n            else if (t0.z == t)\n                normal = rdn.xzy * -sign(ird.z);\n            else\n                normal = rdn.yzy * -sign(ird.w);\n        }\n        \n        tN = max(tN, t);\n        tF = min(tF, min(min(t1.x, t1.y), min(t1.z, t1.w)));\n    }\n    \n    if (tN > tF)\n    {\n        tN = MAX_DIST;\n        tF = MAX_DIST;\n    }\n    \n    return vec2(tN, tF);\n}\n\n// Same as above but returns the far normal\nvec2 rhombicDodecahedronIntersection2(vec3 ro, vec3 rd, float s, out vec3 normal)\n{\n    const vec3 rdn = vec3(0.5, -0.5, sqrt(2.0)/2.0);\n    \n    float tN, tF;\n    {\n        vec2 ird = 1.0 / rd.xz;\n        vec2 n = ro.xz * ird;\n        vec2 k = abs(ird) * s;\n\n        vec2 t0 = -n - k;\n        vec2 t1 = -n + k;\n\n        tN = max(t0.x, t0.y);\n        tF = min(t1.x, t1.y);\n\n        normal = vec3(-sign(ird) * step(t1, t1.yx), 0).xzy;\n    }\n    \n    {\n        vec4 ird = 1.0 / vec4(dot(rd, rdn.xzx), dot(rd, rdn.yzx), dot(rd, rdn.xzy), dot(rd, rdn.yzy));\n        vec4 n = ird * vec4(dot(ro, rdn.xzx), dot(ro, rdn.yzx), dot(ro, rdn.xzy), dot(ro, rdn.yzy));\n        vec4 k = abs(ird) * s;\n        \n        vec4 t0 = -n - k;\n        vec4 t1 = -n + k;\n        \n        float t = max(max(t0.x, t0.y), max(t0.z, t0.w));\n        float t2 = min(tF, min(min(t1.x, t1.y), min(t1.z, t1.w)));\n        \n        if (t2 < tF)\n        {\n            if (t1.x == t2)\n                normal = rdn.xzx * -sign(ird.x);\n            else if (t1.y == t2)\n                normal = rdn.yzx * -sign(ird.y);\n            else if (t1.z == t2)\n                normal = rdn.xzy * -sign(ird.z);\n            else\n                normal = rdn.yzy * -sign(ird.w);\n        }\n        \n        tN = max(tN, t);\n        tF = min(tF, t2);\n    }\n    \n    if (tN > tF)\n    {\n        tN = MAX_DIST;\n        tF = MAX_DIST;\n    }\n    \n    return vec2(tN, tF);\n}\n\nmat3 getCameraMatrix(vec3 ro, vec3 lo)\n{\n    vec3 cw = normalize(lo - ro);\n    vec3 cu = normalize(cross(cw, vec3(0, 1, 0)));\n    vec3 cv = cross(cu, cw);\n\n    return mat3(cu, cv, cw);\n}\n\nfloat safeacos(float x) { return acos(clamp(x, -1.0, 1.0)); }\n\nfloat saturate(float x) { return clamp(x, 0., 1.); }\nvec2 saturate(vec2 x) { return clamp(x, vec2(0), vec2(1)); }\nvec3 saturate(vec3 x) { return clamp(x, vec3(0), vec3(1)); }\n\nfloat sqr(float x) { return x*x; }\nvec2 sqr(vec2 x) { return x*x; }\nvec3 sqr(vec3 x) { return x*x; }\n\nfloat luminance(vec3 col) { return dot(col, vec3(0.2126729, 0.7151522, 0.0721750)); }\n\nmat2 rot2D(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n// https://iquilezles.org/articles/smin/\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\n// https://iquilezles.org/articles/palettes/\nvec3 palette(float t)\n{\n    return .55 + .45 * cos(TAU * (vec3(1, 1, 1) * t + vec3(0.5, 0.25, 0.75)));\n}\n\nvec3 palette2(float t)\n{\n    return .58 + .42 * cos(TAU * (vec3(1, 0.6, 0.6) * t + vec3(0.5, 0.3, 0.25)));\n}\n\n// Hash without Sine\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 sRGBToLinear(vec3 col)\n{\n    return mix(pow((col + 0.055) / 1.055, vec3(2.4)), col / 12.92, lessThan(col, vec3(0.04045)));\n}\n\nvec3 linearTosRGB(vec3 col)\n{\n    return mix(1.055 * pow(col, vec3(1.0 / 2.4)) - 0.055, col * 12.92, lessThan(col, vec3(0.0031308)));\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n// Scene\n\n// Fork of \"Gelami Raymarching Template\" by gelami. https://shadertoy.com/view/mslGRs\n// 2023-05-14 11:59:30\n\nvec3 getID(vec3 p)\n{\n    p -= 0.5;\n    p.y /= sqrt(2.0);\n    \n    vec3 id0 = floor(p);\n    vec3 id1 = floor(p + 0.5);\n    \n    vec3 p0 = fract(p) - 0.5;\n    vec3 p1 = fract(p + 0.5) - 0.5;\n    \n    p0.y *= sqrt(2.0);\n    p1.y *= sqrt(2.0);\n    \n    float d0 = dot(p0, p0);\n    float d1 = dot(p1, p1);\n    \n    vec3 id = d0 < d1 ? id0 : id1 - 0.5;\n    \n    id += 0.5;\n    id.y *= sqrt(2.0);\n    \n    return id;\n}\n\nvec3 getLightsID(vec3 p)\n{\n    const float s = EMI_SCALE;\n    \n    p.xz *= rot2D(PI/4.0);\n    p.yx *= rot2D(PI/4.0);\n    \n    vec3 id = (floor(p / s) + 0.5) * s;\n    \n    id.yx *= rot2D(-PI/4.0);\n    id.xz *= rot2D(-PI/4.0);\n    \n    return id;\n}\n\nvec3 IDToPos(vec3 id)\n{\n    id = id * 0.5 + 0.5;\n    id.y *= sqrt(2.0);\n    \n    return id;\n}\n\nvec3 posToID(vec3 p)\n{\n    p.y *= 1.0 / sqrt(2.0);\n    p = (p - 0.5) * 2.0;\n    return floor(p);\n}\n\nvec3 getCameraPos(float time)\n{\n    return vec3(sin(time*0.3)*3.0 + cos(time*0.8)*2.0, cos(time * 0.2) + sin(time * 0.5) * 4.0, time * CAMERA_SPEED);\n}\n\nfloat map(vec3 p)\n{\n    //p = IDToPos(posToID(p));\n    \n    p.y *= -1.0;\n    vec3 dp = p - vec3(-2,5,7);\n    \n    dp *= 0.1 / 32.0;\n    \n    float d = texture(iChannel1, dp).r*0.5;\n    d += texture(iChannel1, dp*2.0).r*0.25;\n    d += texture(iChannel1, dp*4.0).r*0.125;\n    //d += texture(iChannel1, dp*8.0).r*0.0625;\n    \n    // 0.9375\n    d = d / 0.825 - 0.51;\n    \n    p.y *= -1.0;\n    vec3 po = texture(iChannel2, 0.3 * p / 32.0).rgb - 0.5;\n    vec3 pc = p + po * 4.0;\n    float pdc = (length(pc.xy - getCameraPos(pc.z / CAMERA_SPEED).xy)) - 4.8;\n    \n    d = max(d * 32.0 / 0.1, -pdc * CAMERA_SPEED);\n    \n    return d;\n}\n\nvec3 mapGrad(vec3 p, float eps)\n{\n    vec2 e = vec2(eps, 0);\n    return (map(p) - vec3(\n        map(p - e.xyy),\n        map(p - e.yxy),\n        map(p - e.yyx)\n    )) / e.x;\n}\n\nvec3 getColor(vec3 id)\n{\n    id.y /= sqrt(2.0);\n    id = floor(id * 2.0);\n    \n    float h = abs((sin(id.x * 0.15) + sin(id.y * 0.25) + cos(id.z * 0.4)) * 0.333);\n    \n    return vec3(palette2(h));\n    return palette2(hash13(id));\n}\n\nvec3 getEmission(vec3 id)\n{\n    id.y /= sqrt(2.0);\n    id = floor(id * 2.0);\n    \n    //id += (texture(iChannel2, 0.2 * id / 32.0).rgb - 0.5) * 10.0;\n    float h = ((sin(id.x * 0.03) + sin(id.y * 0.08) + cos(id.z * 0.12)) * 0.333);\n    \n    h = fract(h + iTime * 0.6);\n    //if (h < 0.1)\n    //    return vec3(0.2, 0.5, 1) * 2.0;\n    return vec3(0);\n}\n\nstruct HitInfo\n{\n    float t;\n    vec3 n;\n    vec3 id;\n};\n\n#ifdef SIMPLE_TRAVERSAL\nbool trace(vec3 ro, vec3 rd, out HitInfo hit, float tmax)\n{\n    vec3 pos = ro;\n    vec3 id = getID(pos);\n    vec3 n;\n    float t = 0.0;\n    \n    for (int i = 0; i < STEPS; i++)\n    {\n        float d = map(id);\n        if (d < 0.0)\n        {\n            #ifdef SPHERES\n            if (d < -3.0)\n            {\n                vec2 st = sphereIntersection(ro - (id + 0.5), rd, 0.5);\n\n                if (st.x > t && st.x < MAX_DIST)\n                {\n                    hit.t = st.x;\n                    hit.n = normalize(ro - (id + 0.5) + rd * st.x);\n                    hit.id = id;\n                    return true;\n                }\n            } else\n            #endif\n            {\n                hit.t = t;\n                hit.n = n;\n                hit.id = id;\n                return true;\n            }\n        }\n        \n        vec2 rdi = rhombicDodecahedronIntersection2(pos - id - 0.5, rd, 0.5, n);\n        \n        if (rdi.x >= tmax)\n            return false;\n        \n        t = rdi.y;\n        id -= n;\n    }\n    return false;\n}\n#else\n\nbool trace(vec3 ro, vec3 rd, out HitInfo hit, float tmax)\n{\n    const vec3 rdn = vec3(0.5, -0.5, sqrt(2.0)/2.0);\n    const mat4x3 rdm = mat4x3(rdn.xzx, rdn.yzx, rdn.xzy, rdn.yzy);\n    const float s = 0.5;\n    \n    vec3 id = getID(ro);\n    \n    vec3 pp = ro;\n    \n    vec2 ird0 = 1.0 / rd.xz;\n    vec2 k0 = abs(ird0) * s;\n    vec2 srd0 = sign(ird0);\n\n    vec3 n0 = -srd0.x * vec3(1, 0, 0);\n    vec3 n1 = -srd0.y * vec3(0, 0, 1);\n\n    vec4 ird1 = 1.0 / vec4(dot(rd, rdn.xzx), dot(rd, rdn.yzx), dot(rd, rdn.xzy), dot(rd, rdn.yzy));\n    vec4 k1 = abs(ird1) * s;\n    vec4 srd1 = sign(ird1);\n    \n    vec3 n2 = -srd1.x * rdn.xzx;\n    vec3 n3 = -srd1.y * rdn.yzx;\n    vec3 n4 = -srd1.z * rdn.xzy;\n    vec3 n5 = -srd1.w * rdn.yzy;\n    \n    vec3 n;\n    float t;\n    bool surf = false;\n    \n    for (int i = 0; i < STEPS; i++)\n    {\n        float d = map(id);\n        if (d < 0.0)\n        {\n            #ifdef SPHERES\n            if (d < -3.0)\n            {\n                vec2 st = sphereIntersection(ro - (id + 0.5), rd, 0.5);\n\n                if (st.x > t && st.x < MAX_DIST)\n                {\n                    hit.t = st.x;\n                    hit.n = normalize(ro - (id + 0.5) + rd * st.x);\n                    hit.id = id;\n                    return true;\n                }\n            } else\n            #endif\n            {\n                hit.t = t;\n                hit.n = n;\n                hit.id = id;\n                return true;\n            }\n        }\n        \n        vec3 pp = ro - (id + 0.5);\n        \n        vec2 id0 = ird0 * pp.xz;\n        vec4 id1 = ird1 * vec4(dot(pp, rdn.xzx), dot(pp, rdn.yzx), dot(pp, rdn.xzy), dot(pp, rdn.yzy));\n        \n        vec2 sd0 = -id0 + k0;\n        vec4 sd1 = -id1 + k1;\n        \n        //vec2 sdn0 = -id0 - k0;\n        //vec4 sdn1 = -id1 - k1;\n        \n        float t0 = min(sd0.x, sd0.y);\n        float t1 = min(min(sd1.x, sd1.y), min(sd1.z, sd1.w));\n        \n        //float tn0 = max(sdn0.x, sdn0.y);\n        //float tn1 = max(max(sdn1.x, sdn1.y), max(sdn1.z, sdn1.w));\n        \n        vec3 nrd;\n        if (t1 < t0)\n        {\n            if (sd1.x == t1)\n            {\n                nrd = n2;\n            } else if (sd1.y == t1)\n            {\n                nrd = n3;\n            } else if (sd1.z == t1)\n            {\n                nrd = n4;\n            } else\n            {\n                nrd = n5;\n            }\n        } else if (sd0.x == t0)\n        {\n            nrd = n0;\n        } else\n        {\n            nrd = n1;\n        }\n        \n        //float tN = max(tn0, tn1);\n        float tF = min(t0, t1);\n        \n        if (tF >= tmax)\n            return false;\n        \n        t = tF;\n        n = nrd;\n        id -= n;\n    }\n\n    return false;\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ndc = (2. * (fragCoord) - iResolution.xy) / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    const float fov = 120.0;\n    const float invTanFov = 1.0 / tan(radians(fov) * 0.5);\n    \n    vec3 ro = getCameraPos(iTime);\n    vec3 lo = vec3(0, 0, 1);\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    float ax = iMouse.x == 0. ? -PI * .7 + iTime * .2 : -m.x * TAU + PI;\n    float ay = iMouse.y == 0. ? PI * 0.2 : -m.y * PI + PI * 0.5;\n    \n    if (iMouse.z > 0.0)\n    {\n        lo.yz *= rot2D(-ay);\n        lo.xz *= rot2D(ax);\n        lo += ro;\n    } else\n    {\n        lo = getCameraPos(iTime + 0.25);\n    }\n    \n    mat3 cmat = getCameraMatrix(ro, lo);\n\n    vec3 rd = normalize(cmat * vec3(ndc, invTanFov));\n    \n    vec3 col = vec3(0);\n    \n    const vec3 rdn = vec3(0.5, -0.5, sqrt(2.0)/2.0);\n    \n    #if 0\n    \n    vec3 normal;\n    vec2 rdi = rhombicDodecahedronIntersection(ro, rd, 0.5, normal);\n    \n    vec3 normal2;\n    vec2 rdi2 = rhombicDodecahedronIntersection(ro - rdn.xzy, rd, 0.5, normal2);\n    \n    vec2 st = sphereIntersection(ro + rdn.yzy, rd, 0.5);\n    vec3 normal3 = normalize(ro + rdn.yzy + rd * st.x);\n    \n    float t = rdi.x;\n    \n    if (rdi2.x < t)\n    {\n        t = rdi2.x;\n        normal = normal2;\n    }\n    if (st.x < t)\n    {\n        t = st.x;\n        normal = normal3;\n    }\n    \n    vec3 pos = ro + rd * t;\n    \n    col = normal;\n    \n    if (t >= MAX_DIST)\n        col = rd;\n    \n    #else\n    \n    vec3 pos = ro;\n    vec3 id = getID(pos);\n    vec3 n;\n    float t = 0.0;\n    \n    HitInfo hit;\n    bool isHit = trace(pos, rd, hit, MAX_DIST);\n    t = isHit ? hit.t : MAX_DIST;\n    n = hit.n;\n    id = hit.id;\n    \n    pos = pos + rd * t;\n    \n    id = getID(pos - n * EPS);\n    \n    vec3 alb = getColor(id);\n    vec3 emi = getEmission(id);\n    \n    vec3 fogCol = vec3(0.6, 0.85, 1)*0.6;//vec3(0.03, 0.03, 0.08);\n    vec3 ambCol = fogCol;\n    vec3 accCol = vec3(1, 0.12, 0.15);\n    \n    float ft = smoothstep(MAX_DIST*0.7, MAX_DIST, t) * smoothstep(0.98, 1.0, rd.z);//pow(max(rd.z, 0.0), 20.0) * 2.0;\n    \n    fogCol = mix(fogCol, accCol * 5.0, saturate(ft));\n    \n    vec3 ref = reflect(rd, n);\n    \n    vec3 ligCol = vec3(1, 0.85, 0.7) * 1.5;\n    vec3 lpos = getCameraPos(iTime + 1.25);\n    vec3 ldir = lpos - pos;\n    float ldist = length(ldir);\n    ldir /= ldist;\n    \n    HitInfo hitL;\n    bool isHitL = trace(pos + n * EPS, ldir, hitL, ldist);\n    \n    float atten = 1.0 / (0.8 + 0.08*ldist + 0.05*ldist*ldist);\n    \n    float dif = max(dot(n, ldir), 0.0) * float(!isHitL);\n    float spec = pow(max(dot(ref, ldir), 0.0), 5.0) * float(!isHitL);\n    \n    float ao = smoothstep(-2.5, 1.0, map(pos) / length(mapGrad(pos, 1.0)));\n    \n    col += alb * ligCol * dif * atten * 1.8;\n    col += alb * ligCol * spec * atten * 1.0 * step(hash13(id), 0.5);\n    \n    col += (alb * 0.2 + 0.1) * ambCol;\n    \n    vec3 emiPos = getID(getLightsID(id));\n    vec3 emiDir = emiPos - pos;\n    float edist = length(emiDir);\n    emiDir /= edist;\n    \n    float edif = max(dot(n, emiDir), 0.0);\n    \n    HitInfo hitE;\n    bool isHitE = trace(pos + n * EPS, emiDir, hitE, edist);\n    \n    vec3 eid = getID(pos + n * EPS + emiDir * hitE.t - hitE.n * 1e-3);\n    bool isE = isHitE && distance(emiPos, hitE.id) < 1e-3;\n    \n    float estr = 10.0 * ((sin((hash13(emiPos) + iTime*0.25)*TAU)*0.5+0.5)*0.8+0.2);\n    vec3 ecol = accCol * estr;//vec3(0.5, 0.8, 1) * estr;\n    \n    float eAtten = 1.0 / (0.8 + 0.4*edist + 0.3*edist*edist);\n    \n    col += alb * edif * ecol * eAtten * float(isE);\n\n    //float r0 = 0.06;\n    //float fre = r0 + (1.0 - r0) * pow(1.0 - dot(-rd, n), 5.0);\n    \n    col *= ao * 0.8 + 0.2;\n\n    if (distance(emiPos, id) < 1e-3)\n        col = ecol;\n    \n    col = mix(col, fogCol, 1.0 - exp(-max(t*t - 50.0, 0.0) * 0.0003));\n    \n    if (!isHit)\n        col = fogCol;\n    #endif\n    \n    col = max(col, vec3(0));\n    col = col / (1. + col);\n    col = linearTosRGB(col);\n    \n    /*\n    vec3 pro = getCameraPos(iTime - iTimeDelta);\n    vec3 plo = getCameraPos(iTime + 0.25 - iTimeDelta);\n    \n    mat3 pmat = getCameraMatrix(pro, plo);\n    \n    vec3 pcam = (pos - pro) * pmat;\n    vec2 pndc = invTanFov * 2.0 * pcam.xy / pcam.z;\n    vec2 puv = pndc * vec2(iResolution.y / iResolution.x, 1) * 0.5 + 0.5;\n    \n    vec2 mbuv = puv - uv;\n    */\n    \n    fragColor = vec4(col, t);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    },
                    {
                        "channel": 2,
                        "ctype": "volume",
                        "id": 40,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n// FXAA 3.11\n\n// Implementation from\n// Two Grid Traversal w/ 1Pass DoF - gelami\n// https://www.shadertoy.com/view/dtt3DS\n\n// FXAA Defines\n// Trims the algorithm from processing darks.\n//   0.0833 - upper limit (default, the start of visible unfiltered edges)\n//   0.0625 - high quality (faster)\n//   0.0312 - visible limit (slower)\n#define FXAA_THRESHOLD_MIN 0.0312\n\n// The minimum amount of local contrast required to apply algorithm.\n//   0.333 - too little (faster)\n//   0.250 - low quality\n//   0.166 - default\n//   0.125 - high quality \n//   0.063 - overkill (slower)\n#define FXAA_THRESHOLD_MAX 0.063\n\n// This can effect sharpness.\n//   1.00 - upper limit (softer)\n//   0.75 - default amount of filtering\n//   0.50 - lower limit (sharper, less sub-pixel aliasing removal)\n//   0.25 - almost off\n//   0.00 - completely off\n#define FXAA_SUBPIXEL_QUALITY 0.75\n\n// Assumed to be in perceptual/gamma-encoded space\nfloat luma(vec3 col)\n{\n    //return dot(col, vec3(0.2126729, 0.7151522, 0.0721750));\n    return dot(col, vec3(0.299, 0.587, 0.114));\n    return sqrt(dot(col, vec3(0.299, 0.587, 0.114)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 px = 1.0 / iResolution.xy;\n    \n    vec4 col = texture(iChannel0, uv);\n    \n    #ifndef FXAA\n    col.rgb = sRGBToLinear(col.rgb);\n    col.rgb = col.rgb / (1.0 - col.rgb);\n    \n    fragColor = col;\n    #else\n    float lumaCenter = luma(col.rgb);\n    float lumaUp    = luma(texture(iChannel0, uv + vec2(0, px.y)).rgb);\n    float lumaDown  = luma(texture(iChannel0, uv - vec2(0, px.y)).rgb);\n    float lumaLeft  = luma(texture(iChannel0, uv - vec2(px.x, 0)).rgb);\n    float lumaRight = luma(texture(iChannel0, uv + vec2(px.x, 0)).rgb);\n\n    float lumaMin = min(min(min(lumaUp, lumaDown), min(lumaLeft, lumaRight)), lumaCenter);\n    float lumaMax = max(max(max(lumaUp, lumaDown), max(lumaLeft, lumaRight)), lumaCenter);\n\n    float lumaRange = lumaMax - lumaMin;\n\n    if (lumaRange < max(FXAA_THRESHOLD_MIN, lumaMax * FXAA_THRESHOLD_MAX))\n    {\n        col.rgb = sRGBToLinear(col.rgb);\n        col.rgb = col.rgb / (1.0 - col.rgb);\n    \n        fragColor = col;\n        return;\n    }\n    \n    float lumaDownLeft  = luma(texture(iChannel0, uv - vec2(px.x, px.y)).rgb);\n    float lumaUpRight   = luma(texture(iChannel0, uv + vec2(px.x, px.y)).rgb);\n    float lumaDownRight = luma(texture(iChannel0, uv + vec2(px.x, -px.y)).rgb);\n    float lumaUpLeft    = luma(texture(iChannel0, uv + vec2(-px.x, px.y)).rgb);\n    \n    float lumaDownUp = lumaDown + lumaUp;\n    float lumaLeftRight = lumaLeft + lumaRight;\n    \n    float lumaCornerDown = lumaDownRight + lumaDownLeft;\n    float lumaCornerUp = lumaUpRight + lumaUpLeft;\n    float lumaCornerLeft = lumaDownLeft + lumaUpLeft;\n    float lumaCornerRight = lumaDownRight + lumaUpRight;\n\n    float edgeHorizontal = abs(-2.0 * lumaLeft + lumaCornerLeft) +\n                           abs(-2.0 * lumaCenter + lumaDownUp) * 2.0 +\n                           abs(-2.0 * lumaRight + lumaCornerRight);\n    \n    float edgeVertical   = abs(-2.0 * lumaUp + lumaCornerUp) +\n                           abs(-2.0 * lumaCenter + lumaLeftRight) * 2.0 +\n                           abs(-2.0 * lumaDown + lumaCornerDown);\n\n    bool isEdgeHorizontal = edgeHorizontal >= edgeVertical;\n\n    float luma0 = isEdgeHorizontal ? lumaDown : lumaLeft;\n    float luma1 = isEdgeHorizontal ? lumaUp : lumaRight;\n    \n    float grad0 = abs(luma0 - lumaCenter);\n    float grad1 = abs(luma1 - lumaCenter);\n\n    bool gradStep = grad0 >= grad1;\n    \n    float gradScaled = 0.25 * max(grad0, grad1);\n    \n    float stepSize = isEdgeHorizontal ? px.y : px.x;\n    stepSize = gradStep ? -stepSize : stepSize;\n    \n    float lumaLocalAvg = 0.5 * ((gradStep ? luma0 : luma1) + lumaCenter);\n\n    vec2 curUV = uv;\n    \n    if (isEdgeHorizontal)\n        curUV.y += stepSize * 0.5;\n    else\n        curUV.x += stepSize * 0.5;\n    \n    vec2 stepOffset = isEdgeHorizontal ? vec2(px.x, 0) : vec2(0, px.y);\n    \n    vec2 uv0 = curUV - stepOffset;\n    vec2 uv1 = curUV + stepOffset;\n    \n    float lumaEnd0 = luma(texture(iChannel0, uv0).rgb) - lumaLocalAvg;\n    float lumaEnd1 = luma(texture(iChannel0, uv1).rgb) - lumaLocalAvg;\n    \n    bool reached0 = abs(lumaEnd0) >= gradScaled;\n    bool reached1 = abs(lumaEnd1) >= gradScaled;\n    \n    if (!reached0) uv0 -= stepOffset;\n    if (!reached1) uv1 += stepOffset;\n    \n    if (!(reached0 && reached1))\n    {\n        #define ITERATIONS 12\n        const float QUALITY[ITERATIONS] = float[](1.0, 1.0, 1.0, 1.0, 1.0, 1.5, 2.0, 2.0, 2.0, 2.0, 4.0, 8.0);\n        for (int i = 2; i < ITERATIONS; i++)\n        {\n            if (!reached0)\n            {\n                lumaEnd0 = luma(texture(iChannel0, uv0).rgb) - lumaLocalAvg;\n            }\n            if (!reached1)\n            {\n                lumaEnd1 = luma(texture(iChannel0, uv1).rgb) - lumaLocalAvg;\n            }\n            \n            reached0 = abs(lumaEnd0) >= gradScaled;\n            reached1 = abs(lumaEnd1) >= gradScaled;\n            \n            if (!reached0) uv0 -= stepOffset * QUALITY[i];\n            if (!reached1) uv1 += stepOffset * QUALITY[i];\n            \n            if (reached0 && reached1) break;\n        }\n    }\n    \n    float distance0 = isEdgeHorizontal ? (uv.x - uv0.x) : (uv.y - uv0.y);\n    float distance1 = isEdgeHorizontal ? (uv1.x - uv.x) : (uv1.y - uv.y);\n    \n    float lumaDist = distance0 < distance1 ? lumaEnd0 : lumaEnd1;\n    \n    float pixelOffset = -min(distance0, distance1) / (distance0 + distance1) + 0.5;\n    \n    bool correctVar = lumaCenter < lumaLocalAvg != lumaDist < 0.0;\n    \n    float finalOffset = correctVar ? pixelOffset : 0.0;\n    \n    float lumaAvg = (1.0 / 12.0) * (2.0 * (lumaDownUp + lumaLeftRight) + lumaCornerLeft + lumaCornerRight);\n    \n    float subpixelOffset = smoothstep(0.0, 1.0, abs(lumaAvg - lumaCenter) / lumaRange);\n    subpixelOffset = subpixelOffset * subpixelOffset * FXAA_SUBPIXEL_QUALITY;\n    \n    finalOffset = max(finalOffset, subpixelOffset);\n    \n    vec2 finalUV = uv;\n    \n    if (isEdgeHorizontal)\n        finalUV.y += stepSize * finalOffset;\n    else\n        finalUV.x += stepSize * finalOffset;\n    \n    vec3 fcol = texture(iChannel0, finalUV).rgb;\n    \n    fcol = sRGBToLinear(fcol);\n    fcol = fcol / (1.0 - fcol);\n    \n    fragColor = vec4(fcol, col.a);\n    #endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n// Bloom pass from:\n// 2-Pass Buffer Bloom - gelami\n// https://www.shadertoy.com/view/cty3R3\n\nconst int rad = 5;\nconst float sigma = float(rad) * 0.4;\n\n#if 1\nvec4 prefilter(vec4 col)\n{\n    const float threshold = BLOOM_THRESHOLD;\n    float brightness = max(max(col.r, col.g), col.b);\n    float contrib = max(brightness - threshold, 0.0) / max(brightness, 1e-5);\n    return col * contrib;\n}\n#else\nvec4 prefilter(vec4 col)\n{\n    return col;\n}\n#endif\n\nfloat gaussian(vec2 i, float sigma) {\n    return exp(-(dot(i,i) / (2.0 * sigma*sigma)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 hres = floor(iResolution.xy / 2.0);\n        \n    vec2 res = hres;\n    float xpos = 0.0;\n    int lod = 0;\n    for (; lod < BLOOM_MAX_LOD; lod++)\n    {\n        xpos += res.x;\n        \n        if (xpos > fragCoord.x || res.x <= 1.0)\n            break;\n        res = floor(res / 2.0);\n    }\n    \n    if (fragCoord.y >= res.y)\n    {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    fragColor = vec4(0);\n    \n    vec2 px = 1.0 / iResolution.xy;\n    vec2 p = (fragCoord - vec2(xpos - res.x, 0)) / iResolution.xy;\n    vec2 uv = (fragCoord - vec2(xpos - res.x, 0)) / vec2(res);\n    \n    // Skip blurring LOD 0 for performance\n    #if 1\n    if (lod == 0)\n    {\n        fragColor = prefilter(textureLod(iChannel0, uv, 1.0));\n        return;\n    }\n    #endif\n    \n    float sc = exp2(float(lod));\n    float w = 0.0;\n    for (int x = -rad; x <= rad; x++)\n    {\n        for (int y = -rad; y <= rad; y++)\n        {\n            vec2 o = vec2(x, y);\n            float wg = gaussian(o, sigma);\n            vec2 p = uv + o / vec2(res);\n            \n            //p = clamp(p, 0.5 / res, (res - 0.5) / res);\n            \n            if (p == clamp(p, vec2(0.5) / res, (res - 0.5) / res))\n                fragColor += wg * prefilter(textureLod(iChannel0, p, float(lod)));\n            w += wg;\n        }\n    }\n    fragColor /= w;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}