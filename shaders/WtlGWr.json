{
    "Shader": {
        "info": {
            "date": "1556062941",
            "description": "My first raymarching shader. Thanks so much to flopine and evvvvil for their great shader coding seminar at revision 2019. https://www.youtube.com/watch?v=uFFR31t1WMM",
            "flags": 0,
            "hasliked": 0,
            "id": "WtlGWr",
            "likes": 6,
            "name": "dice field",
            "published": 3,
            "tags": [
                "raymarching",
                "dice"
            ],
            "usePreview": 0,
            "username": "tauli",
            "viewed": 520
        },
        "renderpass": [
            {
                "code": "//ACME Labs rainbow colors\nvec3[ 5] rbow = vec3[5]\n  ( vec3(1., .0  , 0.)\n  , vec3(1., .553, 0.)\n  , vec3(1., .859, 0.)\n  , vec3(0., .839,  .098)\n  , vec3(0., .624, 1.)\n  );\n\n// positions of all the dimples in the dice\nvec3[21] dips = vec3[21]\n  // one\n  ( vec3( 0.,    0.,    0.31)\n  // two\n  , vec3( 0.31,  0.15,  0.15)\n  , vec3( 0.31, -0.15, -0.15)\n  // three\n  , vec3( 0.15,  0.31,  0.15)\n  , vec3( 0.,    0.31,  0.  )\n  , vec3(-0.15,  0.31, -0.15)\n  // four\n  , vec3( 0.15, -0.31,  0.15)\n  , vec3(-0.15, -0.31,  0.15)\n  , vec3( 0.15, -0.31, -0.15)\n  , vec3(-0.15, -0.31, -0.15)\n  // five\n  , vec3(-0.31,  0.,    0.  )\n  , vec3(-0.31, -0.15, -0.15)\n  , vec3(-0.31, -0.15,  0.15)\n  , vec3(-0.31,  0.15, -0.15)\n  , vec3(-0.31,  0.15,  0.15)\n  // six\n  , vec3( 0.15, -0.15, -0.31)\n  , vec3( 0.15,  0.,   -0.31)\n  , vec3( 0.15,  0.15, -0.31)\n  , vec3(-0.15, -0.15, -0.31)\n  , vec3(-0.15,  0.,   -0.31)\n  , vec3(-0.15,  0.15, -0.31)\n  );\n\nvec3 rotate (vec3 p, vec3 r) {\n  mat3x3 rotX = mat3x3(\n    1, 0,         0,\n    0, cos(r.x), -sin(r.x),\n    0, sin(r.x), cos(r.x)\n  );\n  mat3x3 rotY = mat3x3(\n    cos(r.y),  0, sin(r.y),\n    0,         1, 0,\n    -sin(r.y), 0, cos(r.y)\n  );\n  mat3x3 rotZ = mat3x3(\n    1, 0,         0,\n    0, cos(r.z), -sin(r.z),\n    0, sin(r.z), cos(r.z)\n  );\n  return rotX * rotY * rotZ * p;\n}\n\nfloat sphere (vec3 p, float radius) {\n  return length(p) - radius ;\n}\n\nfloat box (vec3 p, vec3 c) {\n  vec3 q = abs(p) - c;\n  return min(0., max(q.x, max(q.y,q.z))) - 0.02 + length(max(q,0.));\n}\n\nfloat map (vec3 p) {\n  vec3 b = floor(mod(p, 15.) / 3.);\n  p = mod(p, 3.) - 1.5;\n\n  // rotate each dice a bit differently\n  p = rotate(p, vec3(iTime * 0.3 + b.x, iTime * 0.7 + b.y, iTime * 0.111 + b.z));\n  float s = sphere(p, 0.45);\n  float c = box(p,vec3(0.29));\n  float dice = max(s,c);\n  \n  //short circuting for better performance\n  if (dice > 0.001) return dice;\n \n  float d = sphere(p + dips[0], 0.06);\n  for (int i = 1; i <= 21; i++) {\n    d = min(d, sphere(p + dips[i], 0.06));\n  }\n  return max(dice, -d);\n}\n\nvec3 get_normal (vec3 p) {\n  vec2 eps = vec2(0.0001, 0.);\n  return normalize( vec3(\n    map(p+eps.xyy) - map(p-eps.xyy),\n    map(p+eps.yxy) - map(p-eps.yxy),\n    map(p+eps.yyx) - map(p-eps.yyx)\n  ) );\n}\n\nfloat diffuse (vec3 n, vec3 l) {\n   return dot(n, normalize(l))*.5+.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  //mat2x2 rot = mat2x2(cos(time),-sin(time),sin(time),cos(time));\n  //uv = rot * uv;\n  \n  //vec3 ro = vec3(.0, .0, -3.0);\n  vec3 ro = vec3(mod(iTime * 2.5,15.), sin(iTime * 0.5)*1.5, -3.0);\n  vec3 p = ro;\n  vec3 rd = normalize (vec3(uv,1.));\n  float shad = 0.;\n  bool hit = false;\n  \n  for (float i = 0.; i < 100.; i++) {\n    float d = map(p);\n    if (d < 0.001) {\n      shad = 1. - i / 100.;\n      hit = true;\n      break;\n    }\n    p += d * rd;\n    if (p.z > 21.) break;\n  }\n  \n  float t = length(ro-p);\n  \n  vec3 color;\n  if (hit) {\n    vec3 n = get_normal(p);\n    vec3 l = vec3(.5, 2., -2.);\n    int boxNum = int(mod(floor(p.x / 3. + p.y / 3. + p.z / 3.),5.));\n \n    vec3 b = floor(mod(p, 15.) / 3.);\n    p = mod(p, 3.) - 1.5;\n    p = rotate(p, vec3(iTime * 0.3 + b.x, iTime * 0.7 + b.y, iTime * 0.111 + b.z));\n    float d = sphere(p + dips[0], 0.06);\n    for (int i = 1; i <= 21; i++) {\n      d = min(d, sphere(p + dips[i], 0.06));\n    }\n    if (d < 0.001) { color = vec3(0.3,0.3,0.3); }\n    else           { color = rbow[boxNum]; }\n\n    color = mix(color, color * 0.5, vec3(diffuse(n,l)));\n  }\n  else {color = vec3(.0);}\n  color = mix(color, vec3(.15,.15,.3), 1. - exp(-.005*t*t));\n  \n  fragColor = vec4(color, 1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}