{
    "Shader": {
        "info": {
            "date": "1374082944",
            "description": "Transparency and scattering of blackbody. ( abscissa : temperature, ordinate : column density)",
            "flags": 16,
            "hasliked": 0,
            "id": "4sXGz2",
            "likes": 2,
            "name": "Transparency and scattering test",
            "published": 3,
            "tags": [
                "transparencyandscatteringtest"
            ],
            "usePreview": 0,
            "username": "Mikael",
            "viewed": 478
        },
        "renderpass": [
            {
                "code": "#define SHADERTOY 1 //Shadertoy compatibility (no texture)\n#define USE_TEXTURE (1 && !SHADERTOY) //Texture VS Fit function (if not Shadertoy)\n\n#define SHOW_FILTERS 0\n#define SHOW_EXTINCTIONLAW 0\n#define SHOW_BLACKBODIES 0\n#define SHOW_FILTERED_BLACKBODY 0\n\nvec2 FragCoord;\nvec4 FragColor;\n\n#if SHADERTOY\nvec2 u_windowResolution;\nvec2 u_mousePosition;\nconst int u_wavelengthResolution = 2999;\n\nbool keyToggle(int ascii) \n{\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\n}\nbool u_luminosityLog;\n\n#else\nuniform vec2 u_windowResolution;\nuniform vec2 u_mousePosition;\nuniform int u_wavelengthResolution;\nuniform bool u_luminosityLog;\nuniform sampler1D filterTex;\nuniform sampler1D extinctionLawTex;\n#endif\n\nconst float h = 6.62617e-34;//Planck constant   (J.s )\nconst float c = 299792458.; //Speed of light    (m.s-1)\nconst float k = 1.38066e-23;//Boltzmann constant(J.K-1)\nconst float zSol = 0.0132;  //Sun metallicity\nconst float pi = 3.141593;\nconst float twohcc = 2.*h*c*c;\nconst float hc_k = h*c/k;\n\nfloat blackBodyLum( float lambda, float t)\n{\n    return twohcc/( lambda*lambda)/(lambda*lambda*lambda * (exp(float(hc_k/(lambda*t)))-1.) );\n}\n\nvec3 blackBodyLum3( float lambda, vec3 t)\n{\n    return vec3( blackBodyLum( lambda, t.r)\n               , blackBodyLum( lambda, t.g)\n               , blackBodyLum( lambda, t.b)\n               );\n}\n\nfloat starLum( float lambda, float t, float r )\n{\n    return 4.*pi*pi*r*r * blackBodyLum( lambda, t);\n}\n\nvec3 filtering( float normalizedLambda )\n{\n#if USE_TEXTURE\n    return texture1D(filterTex,normalizedLambda).xyz;\n#else\n    float lambda = normalizedLambda*float(u_wavelengthResolution)*1.e-9;\n    float fitB = max( step(lambda,418.e-9)*(-8.366+2.289150e-2*1e9*lambda)\n                   +  step(418.e-9,lambda)* (4.759841 - 8.846811e-3*1e9*lambda)\n                   , 0.);\n                ;\n    float fitV = max( step(lambda,525.e-9)*(-1.092890e1+2.292683e-2*1e9*lambda)\n                   + step(525.e-9,lambda) * (5.147796 - 7.875564e-3*1e9*lambda)\n                   , 0.);\n                ;\n    float fitR = max( step(lambda,600.e-9)*(-1.079657e1+1.999566e-2*1e9*lambda)\n                   + step(600.e-9,lambda) * (3.501976 - 4.144621e-3*1e9*lambda)\n                   , 0.);\n                ;     \n    return vec3(fitR,fitV,fitB);\n#endif\n}\n\nfloat extinctionLaw( float normalizedLambda )\n{\n#if USE_TEXTURE\n    return texture1D(extinctionLawTex,normalizedLambda);\n#else\n    float lambda = normalizedLambda*float(u_wavelengthResolution)*1.e-9;\n    return 6.001745e2*1.e-9/lambda;\n#endif\n}\n\nbool affSlider(vec2 p0, vec2 dp, float v)\n{\n\tfloat R=5.;\n\tvec2 pix = FragCoord.xy/u_windowResolution.y;\n\tfloat pt = max(1e-2,1./u_windowResolution.y); R*=pt;\n\tpix -= p0;\n\n\tfloat dp2 = dot(dp,dp);\n\tfloat x = dot(pix,dp)/dp2; if ((x<0.)||(x>1.)) return false;\n\tfloat x2=x*x;\n\tfloat y = dot(pix,pix)/dp2-x2; if (y>R*R) return false;\n\n\tFragColor = vec4(1.,.2,0.,1.); \n\ty = sqrt(y);\n\tif (y<pt) return true;       // rule\n\tvec2 p = vec2(x-v,y);\n\tif (dot(p,p)<R*R) return true; // button\n\t\n\treturn false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if SHADERTOY\n\tu_windowResolution = iResolution.xy;\n\tu_mousePosition = iMouse.xy;\n#endif\n    \n    u_luminosityLog =  keyToggle(49);\n    \n    FragCoord = fragCoord;\n\tFragColor = vec4(0.);\t\n    \n    vec2 normFragCoord = fragCoord.xy/u_windowResolution;\n    vec2 normMouse = u_mousePosition/u_windowResolution;\n\n\tif (affSlider(vec2(.05,.02),vec2(.4,0),normMouse.x)) { fragColor=FragColor; return;}\n\tif (affSlider(vec2(.02,.05),vec2(0,.4),normMouse.y)) { fragColor=FragColor; return;} \n\t\n#if SHOW_FILTERS\n\n    vec3 filterValue = filtering(normFragCoord.x);\n    fragColor = vec4(step(normFragCoord.yyy,filterValue), 1. );\n\n#elif SHOW_EXTINCTIONLAW\n\n    float extinctionLawValue = extinctionLaw(normFragCoord.x);\n    fragColor = vec4(vec3(step(normFragCoord.y,extinctionLawValue*.1)), 1. );\n    \n#elif SHOW_BLACKBODIES\n\n    float radianceMax = 1.e15;\n    vec3 temperature= vec3(10000.,8000.,6000.);\n\n    float lambda = normFragCoord.x*float(u_wavelengthResolution)*1.e-9;\n    vec3 blackBodyValue = blackBodyLum3(lambda,temperature);\n    fragColor = vec4( step(normFragCoord.y*radianceMax, blackBodyValue), 1. );\n    \n#elif SHOW_FILTERED_BLACKBODY\n\n    float radianceMax = 1.e15;\n    float temperature = 10000.;\n    \n    vec3 filterValue = filtering(normFragCoord.x);\n    float lambda = normFragCoord.x*float(u_wavelengthResolution)*1.e-9;\n    float blackBodyValue = blackBodyLum(lambda,temperature);\n    fragColor = vec4( step( normFragCoord.y, blackBodyValue*filterValue/radianceMax ), 1. );\n    \n#else\n    \n\t//temperature\n    float tmax = 50000.;\n    float tmin = 3000.;\n\t//column density\n    float dmax = 9000.;\n    float dmin = 0.000001;\n    \n\tconst float albedo = .1;\n\tconst float phase = 1./(4.*pi);\n\tconst float NDotE = 1.;\n\tfloat NDotL = mix(0.,1.,normMouse.x);\n\t\n\tbool transparency = normFragCoord.x < 0.5;//transparency computation on the left of the screen, scattering on the right \n    float t = tmax*exp(mod(normFragCoord.x,.5)*2. * log(tmin/tmax));//abscissa : temperature\n    float d = dmax*exp(normFragCoord.y * log(dmin/dmax));//ordinate : column density\n    float vBandOpticalDepth = 0.4*log(10.)*d/(9.*zSol);//optical depth in Visible Band\n\t\n    vec3 filteredBlackBody = vec3(0.,0.,0.);\n    vec3 filteredExtinctedBlackBody = vec3(0.,0.,0.);\n    //vec3 filteredStarLum = vec3(0.,0.,0.);\n    const int lambdaStep = 50;\n    for ( int lambdaIndex = 0; lambdaIndex < u_wavelengthResolution; lambdaIndex+=lambdaStep)\n    {\n        float lambda = (float(lambdaIndex)+0.5)*1.e-9;\n        \n        float lambdaCoord = (float(lambdaIndex)+0.5)/float(u_wavelengthResolution);\n        vec3 filterValue = filtering(lambdaCoord);\n        float extinctionLawValue = extinctionLaw(lambdaCoord);\n        \n        float blackBody = blackBodyLum(lambda,t);\n        vec3 filteredBlackBodyDeltaLambda = blackBody * float(lambdaStep)*1.e-9 * filterValue;\n\t\tvec3 filteredExtinctedBlackBodyDeltaLambda = vec3(0.);\n\t\tif ( transparency )//transparency\n\t\t{\n\t\t\tfilteredExtinctedBlackBodyDeltaLambda = filteredBlackBodyDeltaLambda * exp(-vBandOpticalDepth*extinctionLawValue);\n\t\t}\n\t\telse //scattering\n\t\t{\n\t\t\tfilteredExtinctedBlackBodyDeltaLambda = filteredBlackBodyDeltaLambda * albedo * phase * NDotL/(NDotL+NDotE) * (1.-exp(-vBandOpticalDepth*extinctionLawValue*(1./NDotL+1./NDotE)));\n\t\t}\n        filteredBlackBody += filteredBlackBodyDeltaLambda;\n        filteredExtinctedBlackBody += filteredExtinctedBlackBodyDeltaLambda;\n        \n        // float starLumValue = starLum(lambda,t,7.e8);\n        // filteredStarLum   += starLumValue   * float(lambdaStep)*1.e-9 * filterValue * exp(-0.4*log(10.)*d/(9.*zSol));\n    }\n    \n\tif(u_luminosityLog) //log(luminosity)\n\t{\n\t\tfloat gain = mix(1.e6,1.e3,normMouse.y);\n\t\tfragColor = vec4(log(filteredExtinctedBlackBody/gain)/log(10.)/4.,1.);\n\t\t//fragColor = vec4(log(filteredStarLum/3.839e26*100.)/log(10)/2.,1.);\n\t}\n\telse\n\t{\n\t\tfloat gain = pow(10.,mix(10.,5.,normMouse.y));\n\t\tfloat filteredBlackBodyNorm = dot(filteredBlackBody,vec3(1));\n\t\tfragColor = vec4(filteredExtinctedBlackBody/gain,1.);\n\t}\n\n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}