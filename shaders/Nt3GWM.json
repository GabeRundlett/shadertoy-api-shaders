{
    "Shader": {
        "info": {
            "date": "1636166012",
            "description": "another raytrace scene.more SAMPLEs less noise.I can't use sdf shapes here...so slow still search the way outof stepmatch.",
            "flags": 0,
            "hasliked": 0,
            "id": "Nt3GWM",
            "likes": 4,
            "name": "Pathtrace with raytrace",
            "published": 3,
            "tags": [
                "raytrace",
                "pathtrace"
            ],
            "usePreview": 0,
            "username": "rockhard",
            "viewed": 309
        },
        "renderpass": [
            {
                "code": "#define PI2 6.2831853\n#define BOUNCES 4\n#define SAMPLES 12.0\n#define FAR 50.0\n#define DELTA 1e-4\n#define GLASS_IOR 1.5\n//random function\nfloat seed;\nvec2 h2(){ \n    return fract(sin(vec2(seed+=0.1,seed+=0.2))*vec2(43758.5453123,2278.1));\n}\nfloat h(){ return fract(sin(seed+=0.1)*43758.5);}\nvec3 h3() { return fract(sin(seed+=0.1)*vec3(43758.5,22578.15,19642.3));\n}\n//math addon\nvec3 offset(vec3 direction,float multiplier){\n    vec3 random = h3()*multiplier-multiplier*0.5;\n    return normalize(direction+random);\n}\nvec3 cosineWeightedSample(vec3 n){    \n    vec2 r = h2();    \n    float a = 6.2831853 * r.x,u = 2.0*r.y - 1.0;\n    return normalize( n + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)),u));\n}\nfloat fresnel(float na,float nb,vec3 incidence,vec3 normal){\n    float r = pow((na-nb)/(na+nb),2.0);\n    float cx = -dot(normal,incidence);\t\t\t\t\n    if(na>nb){\n        float q = na/nb;\n        float s2 = pow(q,2.0)*(1.0-pow(cx,2.0));\n        if(s2>1.0) return 1.0;\n        cx = sqrt(1.0-s2);\n    }\t\t\t\t\n    float x = 1.0-cx;\n    float ret = r+(1.0-r)*pow(x,5.0);\n    return clamp(ret,0.0,1.0);\n}\n//material list type 1:glass ,c:color e:emissive ref:reflectiove\nstruct material{ int type;vec3 c,e;float rough,ref;};\n\nmaterial mats(int id){\nif(id==0)  return material(0,vec3(1.0,0.01,0.01),vec3(0.0),0.0,0.0);\nelse if(id==1) return material(0,vec3(1.0,1.0,0.0),vec3(0.0),0.5,9.0);\nelse if(id==2) return material(0,vec3(0.02,0.1,1.0),vec3(0.0),0.0,10.0);\nelse if(id==3) return material(0,vec3(0.81,0.61,0.01),vec3(0.0),0.0,10.0);\nelse if(id==4) return material(0,vec3(1.0,1.0,1.0),vec3(0.0),0.0,0.0);\nelse if(id==5) return material(0,vec3(0.0,0.85,0.15),vec3(0.0),0.5,8.0);\nelse if(id==6) return material(1,vec3(0.7,0.2,0.9),vec3(0.0),0.0,10.0);\nelse if(id==7) return material(0,vec3(1.0,0.25,0.65),vec3(0.0),0.0,0.0);\nelse if(id==8) return material(0,vec3(1.0,1.0,0.95),vec3(0.0),0.0,2.5); \nelse if(id==9) return material(0,vec3(1.0,1.0,1.0),vec3(0.0),0.0,0.0);\nelse if(id==10) return material(0,vec3(sin(iTime)*0.5+0.5,0.8,0.5),vec3(1.0),0.0,0.0);\nreturn material(0,vec3(0.0),vec3(0.0),0.0,0.0);\n}\n#define NUMSBOXES 3\n// box: position ,scale ,material ID\nbox boxes(int id){\nif(id==0) return box(vec3(0,-1,0),vec3(10,1,10), 8);\nelse if(id==1) return box(vec3(-1.0,0.5,2.5),vec3(1.0,0.5,0.1),9);\nelse if(id==2) return box(vec3(-2.0,0.65,0),vec3(0.025,0.65,1), 10);\nreturn box(vec3(0.0),vec3(0.0),0);\n}\n#define NUMSPHERES 8\n// sphere: position, radius ,material ID\nsphere spheres(int id){\nif(id==0) return sphere(vec3(0.5,sin(iTime)+1.6,-1),0.6,0);\nelse if(id==1)return sphere(vec3(-0.36,0.7,0.2),0.7,1);\nelse if(id==2)return sphere(vec3(1,0.5,1),0.5,2);\nelse if(id==3)return sphere(vec3(-0.3,0.3,1.5),0.3,3);\nelse if(id==4)return sphere(vec3(0.36,0.5,-0.2),0.5,4);\nelse if(id==5)return sphere(vec3(-0.62,0.26,-0.42),0.26,5);\nelse if(id==6)return sphere(vec3(-0.6,0.3,1.05),0.3,6);\nelse if(id==7)return sphere(vec3(-0.25,0.38,-0.52),0.38,7);\nreturn sphere(vec3(0.0),0.0,0);\n}\n//trace\n//hitinfo: position ,normal ,distance ,material ID\nhitinfo map(ray r){ \n   hitinfo rec=hitinfo(vec3(0.0),vec3(0.0),FAR,0); \n   rec=rayBox(boxes(0),r,rec); \n    rec=rayBox(boxes(1),r,rec); \n     rec=rayBox(boxes(2),r,rec); \n   rec=raySphere(spheres(0),r,rec); \n    rec=raySphere(spheres(1),r,rec); \n     rec=raySphere(spheres(2),r,rec); \n      rec=raySphere(spheres(3),r,rec); \n       rec=raySphere(spheres(4),r,rec); \n        rec=raySphere(spheres(5),r,rec); \n         rec=raySphere(spheres(6),r,rec); \n          rec=raySphere(spheres(7),r,rec); \n   return rec;\n}\nray rayhit(hitinfo rec, ray r, inout vec3 attenuation) {\n    if(rec.t==FAR) return r;\n    material m =mats(rec.mat);  \n    ray r1=ray(vec3(0.0),vec3(0.0));\n    if(m.type==0){\n        r1.ori =rec.p+rec.n*DELTA; r1.dir=r.dir; \n        if(m.ref>0.0&&fresnel(1.0,GLASS_IOR,r.dir,rec.n)*m.ref>h()){                   \n               r1.dir = reflect(r1.dir,rec.n); \n               if(m.rough>0.0)r1.dir = offset(r1.dir,m.rough);\n          }else    \n         r1.dir=cosineWeightedSample(rec.n); //normalize(rec.n + random());\n         attenuation = m.c; return r1; \n       }\n     else if(m.type==1){            \n           if(fresnel(1.0,GLASS_IOR,r.dir,rec.n)-0.07>h()){   \n                    r1.ori = rec.p+rec.n *DELTA;                 \n                    r1.dir = reflect(r.dir,rec.n);\n                }else{    \n                    r1.ori = rec.p+r.dir*DELTA;            \n                    r1.dir = refract(r.dir,rec.n,1.0/GLASS_IOR);\t \n                 }\n            attenuation = m.c;  return r1;\n      }\n    return r;\n}\n\nvec3 ray_color(ray r) {\n    vec3 color =vec3(1.0);\n    vec3 acc=vec3(0.0);\n    hitinfo rec;\n    for (int depth = 0; depth < BOUNCES; depth++) {\n        rec=map(r);\n        if (rec.t<FAR) {           \n            vec3 rc= vec3(0.0);\n            r = rayhit(rec, r, rc);\n            color *=rc;\n            //emissive\n            vec3 em = mats(rec.mat).e;        \n            if(em.x>0.0||em.y>0.0||em.z>0.0){ acc+=color*em;  break; } \n        } \n        else { //simple sky and ground color    \n           float t =acos(rec.n.y)*0.31831;\n           color *= mix(vec3(0.35,0.5,0.7),vec3(0.2, 0.15, 0.12),t);\n            acc+=color;\n            break;\n        }\n    }\n    return acc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy-0.5;\n    uv.x*=iResolution.x/iResolution.y;\n    seed=fragCoord.x *7.0+fragCoord.y*1.7317+1.17;\n\n    mat3 camrot=rotXY(0.5,iTime*0.2);\n    vec3 ro=camrot[2]*5.0;\n    vec3 rd=getdir(uv,camrot);\n     \n    \n    vec3 col = h3();\n    \n    ray ra=ray(ro,rd);\n    float aaRadius=0.006875;\n    //jitter samples can handle AA\n    for (float s = 0.; s < SAMPLES; s++) {\n      ra.ori=ro+h3()*aaRadius;\n      col+= ray_color(ra);\n      seed = mod((seed+s)*1.1291,11.0); \n    }\n    col=pow(col/SAMPLES,vec3(0.5));\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define DELTA 1e-4\n//ray definition\nstruct ray { vec3 ori,dir;};\n//trace result\nstruct hitinfo { vec3 p,n;float t;int mat;};\n//shape definition\nstruct sphere { vec3 p;float r;int mat;};\nstruct box{ vec3 p,s;int mat;};\n\nhitinfo raySphere(sphere sph, ray r,hitinfo rec){    \n    vec3 oc = r.ori - sph.p;\n    float a = dot(r.dir, r.dir);\n    float half_b = dot(oc, r.dir);\n    float c = dot(oc, oc) - sph.r * sph.r;\n    float disc = half_b * half_b - a * c;\n    if (disc < DELTA) return rec; \n    \n    float closest = rec.t;\n    float sqrtd = sqrt(disc); \n    float root = (-half_b - sqrtd) / a;\n    if (root<DELTA|| closest < root) \n          return rec; \n    hitinfo hit;  \n    hit.p = r.ori + r.dir * root;\n    hit.n= (hit.p - sph.p) / sph.r; hit.t= root; hit.mat=sph.mat;\n    return hit;\n} \nhitinfo rayBox(box b, ray r,hitinfo rec){\n    vec3 bmin=b.p-b.s,bmax=b.p+b.s;\n    vec3 p=r.ori,d=r.dir; \n    float tymin, tzmin, tymax, tzmax; \n    float tmin,tmax; \n      if (d.x >= 0.0){ tmin = (bmin.x - p.x) / d.x;  tmax = (bmax.x - p.x) / d.x; }\n      else { tmin = (bmax.x - p.x) / d.x; tmax = (bmin.x - p.x) / d.x;  }\n      if (d.y >= 0.0) { tymin = (bmin.y - p.y) / d.y; tymax = (bmax.y - p.y) / d.y; }\n      else { tymin = (bmax.y - p.y) / d.y;  tymax = (bmin.y - p.y) / d.y; }\n\n      if ((tmin > tymax) || (tymin > tmax)) return rec;\n      if (tymin > tmin) tmin = tymin;\n      if (tymax < tmax) tmax = tymax;\n\n      if (d.z >=0.0){ tzmin = (bmin.z - p.z) / d.z; tzmax = (bmax.z - p.z) / d.z; }\n      else { tzmin = (bmax.z - p.z) / d.z; tzmax = (bmin.z - p.z) / d.z; }\n      if ((tmin > tzmax) || (tzmin > tmax)) return rec;\n      if (tzmin > tmin) tmin = tzmin;\n      if (tzmax < tmax) tmax = tzmax;\n   if(tmin<0.0||rec.t<tmin)return rec;\n    hitinfo hit;  \n    hit.p = r.ori + r.dir * tmin;\n    vec3 center = b.p,size = b.s;\n    vec3 pc = hit.p-center;\n    vec3 normal = vec3(sign(pc.x)* step(abs(abs(pc.x) - size.x),DELTA),\n\tsign(pc.y) * step(abs(abs(pc.y) - size.y), DELTA),\n\tsign(pc.z) * step(abs(abs(pc.z) - size.z), DELTA));\n    hit.n=normalize(normal); hit.t= tmin; hit.mat=b.mat;\n    return hit;\n} \nmat3 rotXY(float rX, float rY){\n float cx = cos(rX),sx = sin(rX),cy = cos(rY),sy=sin(rY);\n return mat3(-sy, 0, -cy, -sx * cy, cx, sx * sy,cx * cy, sx, -cx * sy);\n}\n\nvec3 getdir(vec2 p,mat3 m){\n  return normalize(vec3(p.x * m[0].x + p.y * m[1].x - m[2].x, \n       p.x * m[0].y + p.y * m[1].y - m[2].y, \n       p.x * m[0].z + p.y * m[1].z - m[2].z));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}