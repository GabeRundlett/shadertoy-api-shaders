{
    "Shader": {
        "info": {
            "date": "1483636158",
            "description": "Julia sets of power 3/2 and 5/2. Uses a reverse iteration technique to efficiently explore both branches, avoiding branch cuts and the discontinuities they introduce. Read code for instructions on fullscreen rendering and tunable parameters.",
            "flags": 32,
            "hasliked": 0,
            "id": "llKSRw",
            "likes": 1,
            "name": "Julia set - noninteger powers",
            "published": 3,
            "tags": [
                "fractal",
                "julia"
            ],
            "usePreview": 0,
            "username": "kev7774",
            "viewed": 813
        },
        "renderpass": [
            {
                "code": "/**** Details ****/\n\t/*\n\tRender fullscreen for higher quality.\n\tThis shader bugs out if you switch to fullscreen while it's running, so follow the steps below.\n\n\tHow to render fullscreen:\n\t\tPause the shader, and hit the rewind button to go back to the start\n\t\tGo into fullscreen\n\t\tClick the screen to advance rendering one frame at a time (don't click too fast \n\t\t\tor it'll register as a double click and back you out of fullscreen)\n\t\tAfter about 8 clicks, rendering will be complete.\n\n\n\tReverse iteration rendering of julia sets.\n\tHow it works: Buffer A is initialized with a black circle. On each frame, the buffer shader takes\n\teach pixel coordinate, transforms it with z^n + C (where C is the Julia seed, and n is the power),\n\tthen samples the previous frame's buffer using the transformed coordinate, then writing out the sample.\n\tIf a sample position lands outside the border of previous buffer, sample is considered pure white.\n\tFor rational powers with a denominator of 2 (like the powers 3/2 and 5/2 supported by this shader),\n\tthere are two solutions for z^n + c - with reverse iteration we handle this by sampling\n\tthe previous buffer at boths solutions and combining the results.\n\n\t2 ways to combine samples - averaging, multiplying.\n\tAveraging preserves details within the interior of the set\n\t\t(although you need to apply some color mapping function to the final result to bring them out)\n\t\tBut is not so good for dust-like or filament-like sets.\n\tMultiplying gives sharp, stark results.\n\n\t\n\tIf combining results by averaging, non-solid (cantor dust or filament) sets will fade to white quickly.\n\tEven when multiplying, some sets still eventually fade to white depending on how dust-like they are.\n\t\tSolution:\n\t\tDarken the result slightly after each iteration by multiplying by a factor < 1. (lightness parameter in Buf A)\n\t\tBut won't the image converge to black then? Actually no, because of:\n\t\t\t\"If a sample position lands outside the border of previous buffer, sample is considered pure white\"\n\n\t\tSetting the parameter \"soft\" in Buf A prevents the cutoff to white at the buffer's edge by only darkening towards the\n\t\tcenter and fading out towards the edges.\n\t\t\n\t\n\tSometimes additive mode + darkening is a good soluion, but the results can be a bit blurry.\n\tThat's why the default parameters use lightness = 1.0 (no darkening)\n\tTo prevent set from converging to white (without darkening) do:\n\t\tLimit number of iterations, and use a color ramp to bring out detials from the washed-out result.\n\t\t(This is what the default parameters are doing - enables color ramp with useColor, \n\t\t\tcranks up colorFreq to bring out the details.)\n\n\tYou can set lightness parameter > 1 to bring details out of set interiors when using multiplicative mode (where interiors \n\t\toften converge to black without a lightening factor.)\n\n\t*/\n\n\n/**** Parameters ****/\n\n    float zoom = 1.0; // Zoom in on the result - 0 is no zoom, 1 is 2x zoom, 2 is 4x, etc. Zooming blurs the result.\n    bool useColor = true;  //Black and white or rainbow wave coloration scheme\n    float colorFreq = 11.16; //Frequency of color wave\n    float colorSat = .65; //Saturation\n    float colorOffs = 1.27; //Offset of color wave\n\n\n    //Parameter Set 2 - Make sure to use the corresponding parameters in the Buf A shader!\n    /*\n    float zoom = 1.0; // Zoom in on the result - 0 is no zoom, 1 is 2x zoom, 2 is 4x, etc. Zooming blurs the result.\n    bool useColor = false;  //Black and white or rainbow wave coloration scheme\n    float colorFreq = 11.16; //Frequency of color wave - actual frequency is exponential in this parameter\n    float colorSat = .65; //Saturation\n    float colorOffs = 1.27; //Offset of color wave\n    */\n\n\n\nvec3 hsv2rgb(vec3);\n\nvec2 coord;\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 c = fragCoord / iResolution.xy;\n    c = (c-vec2(.5))*2.;\n\tvec2 pos = (c / exp2(zoom)+vec2(1.0))/2.0;\n\tvec4 tex = texture(iChannel0, pos);\n\tfloat h = fract(tex.r*exp2(colorFreq-5.)+colorOffs);\n\tfloat s = colorSat;\n\tfloat l = 1.0;\n\tvec3 col = useColor ? hsv2rgb(vec3(h,s,l)) : tex.xyz;\n\tfragColor = vec4(col,1.0);\n\n}\n\n\n\n\nvec3 hsv2rgb(vec3 hsv)\n{\n    float h, s, v, r, g, b, j, p, q, t;\n    int i;\n    vec3 color;\n    \n    h = hsv.x;\n    s = hsv.y;\n    v = hsv.z;\n    \n    if (h == 1.0) {\n        h = 0.0;\n    }\n    \n    if (v == 0.0) {\n        // No brightness so return black\n        color = vec3(0.0);\n        \n    } else if (s == 0.0) {\n        // No saturation so return grey\n        color = vec3(v);\n        \n    } else {\n        // RGB color\n        h *= 6.0;\n        i = int(floor(h));\n        j = h - float(i);\n        p = v * (1.0 - s);\n        q = v * (1.0 - (s * j));\n        t = v * (1.0 - (s * (1.0 - j)));\n        \n        if (i == 0) {\n            r = v;\n            g = t;\n            b = p;\n        } else if (i == 1) {\n            r = q;\n            g = v;\n            b = p;\n        } else if (i == 2) {\n            r = p;\n            g = v;\n            b = t;\n        } else if (i == 3) {\n            r = p;\n            g = q;\n            b = v;\n        } else if (i == 4) {\n            r = t;\n            g = p;\n            b = v;\n        } else if (i == 5) {\n            r = v;\n            g = p;\n            b = q;\n        }\n        color = vec3(r, g, b);\n    }\n    \n    return color;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/**** Parameters ****/\n\n    bool soft = false; //Softens result by only darkening towards the center of image (avoids sharp cutoff at image edge)\n    float lightness = 1.0; //Factor to multiply image by after each iteration\n    float sharpness = .35; //Sharpening factor for resampling - improves detail\n    vec2 C = vec2(-0.54544, 0.66668); //Julia seed\n    float SCALE = 3.0;\n    bool multiply = false; // Multiply image samples together - darker image. Default setting averages samples instead.\n    bool quintic = true; // If true power = 5/2, if false power = 3/2\n    int iters = 15; // Number of iterations. \n\n    //Parameter Set 2 - Make sure to use the corresponding parameters in the Image shader!\n    /*\n    bool soft = true; //Softens result by only darkening towards the center of image (avoids sharp cutoff at image edge)\n    float lightness = .8; //Factor to multiply image by after each iteration\n    float sharpness = .25; //Sharpening factor for resampling - improves detail\n    vec2 C = vec2(-0.51516, 1.24244); //Julia seed\n    float SCALE = 4.3;\n    bool multiply = true; // Multiply image samples together - darker image. Default setting averages samples instead.\n    bool quintic = true; // If true power = 5/2, if false power = 3/2\n    int iters = 30; // Number of iterations. \n    */\n\n\n\nvec2 complexMul(vec2 a, vec2 b) {\n\treturn vec2( a.x*b.x -  a.y*b.y,a.x*b.y + a.y * b.x);\n}\n\nvec2 complexSqrt(vec2 z){\n\tfloat r = length(z);\n \treturn sqrt(r) * (z+vec2(r,0.)) / length(z+vec2(r,0.));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 pixelSize = vec2(1.) / iResolution.xy;\n    \n\tvec2 pos = fragCoord.xy/iResolution.xy;\n\tpos.x =( (pos.x*2.-1.)  * (pixelSize.y/pixelSize.x))*.5+.5;\n    vec2 initpos = pos;\n\tvec2 z  = pos*SCALE*2.0- vec2(SCALE);\n    if(iFrame < 2){\n        fragColor = vec4( vec3(min(1., length(pos*4.-2.))), 1.0   );\n        return ;\n    }\n    if(iFrame > 1 + iters){\n        fragColor = texture(iChannel0,fragCoord/iResolution.xy);\n        return;\n    }\n\tvec2 z2 = quintic ?  complexMul(z,z) : z;\n\tz = complexMul(z, complexMul(z2,z2));\n\tvec3 final = multiply ? vec3(1.) : vec3(0.);\n    \n\t{\n        vec2 newz = complexSqrt(z)+C;\n        pos = (newz+vec2(SCALE))/SCALE/2.;\n        pos.x = ((pos.x*2.-1.) * (pixelSize.x/pixelSize.y))*.5+.5;\n        if (pos.x < 0. || pos.y < 0. || pos.x > 1. || pos.y > 1.){\n            fragColor = vec4(1.);\n            return;\n        }\n        vec3 samp = texture(iChannel0,pos).xyz;\n        vec3 n = texture( iChannel0,pos+pixelSize*vec2(0.,1.)).xyz;\n        vec3 e = texture( iChannel0,pos+pixelSize*vec2(1.,0.)).xyz;\n        vec3 s = texture( iChannel0,pos+pixelSize*vec2(0.,-1.)).xyz;\n        vec3 w = texture( iChannel0,pos+pixelSize*vec2(-1.,0.)).xyz;\n        if(multiply) {\n            final *= samp * (1.+sharpness) - sharpness * .25 * (n+e+s+w);\n        }else{\n            final += samp * (1.+sharpness) - sharpness * .25 * (n+e+s+w);\n        }\n\t}\n\t\n\t\n\t{\n        vec2 newz = complexSqrt(z);\n        newz *= -1.;\n        newz += C;\n        pos = (newz+vec2(SCALE))/SCALE/2.;\n        pos.x = ((pos.x*2.-1.) * (pixelSize.x/pixelSize.y))*.5+.5;\n            if (pos.x < 0. || pos.y < 0. || pos.x > 1. || pos.y > 1.) {\n                fragColor = vec4(1.);\n                return;\n            }\n        vec3 samp = texture( iChannel0,pos).xyz;\n        vec3 n = texture( iChannel0,pos+pixelSize*vec2(0.,1.)).xyz;\n        vec3 e = texture( iChannel0,pos+pixelSize*vec2(1.,0.)).xyz;\n        vec3 s = texture( iChannel0,pos+pixelSize*vec2(0.,-1.)).xyz;\n        vec3 w = texture(iChannel0,pos+pixelSize*vec2(-1.,0.)).xyz;\n        if(multiply) {\n            final *= samp * (1.+sharpness) - sharpness * .25 * (n+e+s+w);\n        }else{\n            final += samp * (1.+sharpness) - sharpness * .25 * (n+e+s+w);\n        }\n\t}\n    fragColor.a = 1.0;\n\tfragColor.xyz = \n\t\tmultiply ?\n\t\t\t final  * ( soft ? mix( lightness,max(1.,lightness), min(1., length((initpos*SCALE*2.-SCALE)))) : 1.* lightness)\n\t\t:\n\t\t\t final  * ( soft ? mix(.5*lightness,.5, min(1., length((initpos*SCALE*2.-SCALE)))) : .5* lightness);\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}