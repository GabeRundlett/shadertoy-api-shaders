{
    "Shader": {
        "info": {
            "date": "1611927880",
            "description": "Separated circle bokeh into two spatial passes using offline gradient descent, 128 samples used for what's normally ~1257 sample filter (radius 20 pixels).\n\nUpdate - added a github repo for the python code: https://github.com/Nl1bs/Machine-learned-bokeh\n\n",
            "flags": 32,
            "hasliked": 0,
            "id": "3tGcWt",
            "likes": 46,
            "name": "bokeh (ml approach)",
            "published": 3,
            "tags": [
                "blur",
                "filter",
                "dof",
                "bokeh",
                "seperable"
            ],
            "usePreview": 1,
            "username": "NLIBS",
            "viewed": 1467
        },
        "renderpass": [
            {
                "code": "//pass 2\n#define v3 vec3\n#define v2 vec2\nconst int SAMPLES = 41;\nconst v3 kernel[SAMPLES] = v3[](\n    v3(-14,-4,0.010556), v3(-13,-7,0.0220622), v3(-13,-3,0.0106089), v3(-13,-2,0.0138105), v3(-13,1,0.0241276), v3(-13,4,0.018078), v3(-11,-10,0.0152755), v3(-11,6,0.0173816), v3(-10,-10,0.0080971), v3(-9,8,0.0109473), v3(-8,-12,0.0167525), v3(-8,9,0.0134778), v3(-5,-13,0.0140858), v3(-5,10,0.0169594), v3(-4,-5,0.0136783), v3(-3,-13,0.0088453), v3(-3,-6,0.0152172), v3(-3,-5,0.0127249), v3(-3,-3,0.0111569), v3(-3,1,0.0079278), v3(-3,2,0.0136226), v3(-3,3,0.0184189), v3(-2,1,0.0093688), v3(-2,10,0.0136266), v3(-1,-13,0.0144894), v3(0,10,0.0102296), v3(1,-12,0.0101111), v3(2,9,0.0155008), v3(3,-11,0.0139016), v3(4,8,0.0117719), v3(5,-10,0.0102714), v3(5,-9,0.0071847), v3(5,6,0.0147457), v3(6,-7,0.0123404), v3(6,-2,0.0021469), v3(7,-6,0.0103128), v3(7,-4,0.0176724), v3(7,1,0.0144658), v3(7,4,0.0193837), v3(8,-2,0.0141245), v3(8,1,0.0082815)\n);\n\nvoid mainImage( out vec4 fragColor, in v2 fragCoord )\n{\n    v2 pix = 1./iResolution.xy;\n    v2 uv = fragCoord*pix;\n    float pl = (iMouse.z>0.) ? iMouse.y*pix.y : 0.5+sin(iTime)*0.4;\n    float coc = get_coc(uv.y, pl);\n    \n    v3 acc = v3(0);\n    for (int i = 0; i<SAMPLES; i++) {\n        v3 tap = kernel[i];        \n        acc   += tap.z*texture(iChannel0, uv+pix*tap.xy*coc).rgb;\n    }\n    \n    v3 col    = max(acc,0.);\n    col       = v3(1) - exp(-col * EXPOSURE); //tone mapping\n    col       = pow(col,v3(1./GAMMA));        //gamma correction combined with hdr effect\n    fragColor = vec4(col,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define GAMMA 4.5\n#define EXPOSURE 1.5\n#define THRESHOLD 0.08\n#define NEAR 0.3\n#define APERTURE 2.5\n\nfloat get_coc(float z, float pl)\n{\n    return abs(z-pl)/(z+NEAR)*APERTURE;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//pass 1\n#define v3 vec3\n#define v2 vec2\nconst int SAMPLES = 87;\nconst v3 kernel[SAMPLES] = v3[](\n    v3(-3,-2,0.0099343), v3(-3,-1,0.0158491), v3(-3,0,0.0198582), v3(-3,1,0.0193742), v3(-3,2,0.01562), v3(-3,3,0.0092086), v3(-2,-3,0.0036023), v3(-2,-2,0.017351), v3(-2,-1,0.026431), v3(-2,0,0.0318141), v3(-2,1,0.0318476), v3(-2,2,0.0282652), v3(-2,3,0.0207794), v3(-2,4,0.0100408), v3(-1,-3,0.0118306), v3(-1,-2,0.0230702), v3(-1,-1,0.028688), v3(-1,0,0.0287297), v3(-1,1,0.0291755), v3(-1,2,0.0288904), v3(-1,3,0.0242141), v3(-1,4,0.0133157), v3(0,-3,0.0177183), v3(0,-2,0.0269386), v3(0,-1,0.0255012), v3(0,0,0.0231038), v3(0,1,0.0240891), v3(0,2,0.0266765), v3(0,3,0.026509), v3(0,4,0.0185881), v3(1,-4,0.0066892), v3(1,-3,0.0225386), v3(1,-2,0.0271861), v3(1,-1,0.0236909), v3(1,0,0.0199988), v3(1,1,0.0204911), v3(1,2,0.0250744), v3(1,3,0.0265619), v3(1,4,0.0210398), v3(2,-4,0.0087099), v3(2,-3,0.0241667), v3(2,-2,0.027311), v3(2,-1,0.0227511), v3(2,0,0.019024), v3(2,1,0.0192731), v3(2,2,0.023786), v3(2,3,0.0278565), v3(2,4,0.022605), v3(2,5,0.0069317), v3(3,-4,0.0080222), v3(3,-3,0.0218081), v3(3,-2,0.0268296), v3(3,-1,0.0238996), v3(3,0,0.0200351), v3(3,1,0.0195484), v3(3,2,0.0230739), v3(3,3,0.0269896), v3(3,4,0.0210053), v3(3,5,0.0032463), v3(4,-3,0.0189985), v3(4,-2,0.026861), v3(4,-1,0.0267855), v3(4,0,0.0236707), v3(4,1,0.0230364), v3(4,2,0.0262396), v3(4,3,0.0261808), v3(4,4,0.0176466), v3(5,-3,0.0156334), v3(5,-2,0.0255458), v3(5,-1,0.0285479), v3(5,0,0.029006), v3(5,1,0.0285642), v3(5,2,0.0279639), v3(5,3,0.0220895), v3(5,4,0.011235), v3(6,-3,0.007862), v3(6,-2,0.021451), v3(6,-1,0.0280171), v3(6,0,0.0326608), v3(6,1,0.032852), v3(6,2,0.0261432), v3(6,3,0.0160087), v3(7,-2,0.0028554), v3(7,-1,0.0142694), v3(7,0,0.0180889), v3(7,1,0.0194572), v3(7,2,0.0142807)\n);\n\nvoid mainImage( out vec4 fragColor, in v2 fragCoord )\n{\n    v2 pix    = 1./iResolution.xy;\n    float asp = iResolution.y*pix.x;\n    v2 uv     = fragCoord*pix;\n    float pl  = (iMouse.z>0.) ? iMouse.y*pix.y : 0.5+sin(iTime)*0.4;\n    v2 coc    = get_coc(uv.y, pl)*v2(1,asp); //fix verical blur stretching\n    \n    uv.y *= asp; //must be after get_coc\n    uv.x += iTime*0.1;\n    \n    v3 acc = v3(0);\n    for (int i = 0; i<SAMPLES; i++) {\n        v3 tap  = kernel[i];\n        v3 samp = texture(iChannel0, (uv+pix*tap.xy*coc)*2.5).rgb; //Multiply coords for some cheap detail\n        samp    = max(samp - THRESHOLD,0.) / (1.-THRESHOLD);\n        acc    += tap.z*pow(samp,v3(GAMMA)*v3(0.8,0.7,1));\n    }\n\n    fragColor = vec4(acc,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}