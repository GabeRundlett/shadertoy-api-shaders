{
    "Shader": {
        "info": {
            "date": "1563263441",
            "description": "A first attempt at a mandelbox using the resources at http://blog.hvidtfeldts.net/index.php/2011/11/distance-estimated-3d-fractals-vi-the-mandelbox/",
            "flags": 0,
            "hasliked": 0,
            "id": "wtlSD7",
            "likes": 1,
            "name": "OemfoeMandelBox",
            "published": 3,
            "tags": [
                "mandelbox"
            ],
            "usePreview": 0,
            "username": "oemfoe",
            "viewed": 383
        },
        "renderpass": [
            {
                "code": "const float E = 0.001;\n\n\nmat3 rotY(float r){return mat3(cos(r), 0., sin(r), 0., 1., 0., -sin(r), 0., cos(r));}\nmat3 rotX(float r){return mat3(1., 0., 0., 0., cos(r), sin(r), 0., -sin(r), cos(r));}\nmat3 rotZ(float r){return mat3(cos(r), sin(r), 0., -sin(r), cos(r), 0., 0., 0., 1.);}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat plane(vec3 p){\n    //p = rotY(iTime / 4.) * p;\n    float crazy = abs(p.x/2. - floor(p.x/2. + .5)) * 2.;\n    float crazy2 = abs(p.z/2. - floor(p.z/2. + .5)) * 2.;\n    float var1 = sin(p.x + iTime) * cos(p.z + iTime) / 2. + p.y + 5.;\n\tfloat var2 = -crazy * crazy2 / 2. * (sin(iTime) * .5 + .5) + p.y + 5.;\n\t//return mix(var1, var2, cos(iTime / 8.) / .5 + .5);\n    return var1;\n}\n\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sph1(vec3 p){\n    return sphere(p - vec3(sin(iTime * 2.), 0., 0.), .2);\n}\n\nfloat box(vec3 p, vec3 b){\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));\n}\n\nvec3 normal2(vec3 p){\n    return normalize(vec3(\n        plane(vec3(p.x + E, p.y, p.z)) - plane(vec3(p.x - E, p.y, p.z)),\n        plane(vec3(p.x, p.y + E, p.z)) - plane(vec3(p.x, p.y - E, p.z)),\n        plane(vec3(p.x, p.y, p.z + E)) - plane(vec3(p.x, p.y, p.z - E))\n    ));\n}\n\nvec3 carpos(float t){\n    return vec3(sin(t / 2.) * 4., 0., sin(t) * 4. + 8.);\n}\n\nfloat cyl(vec3 p, float r, float h){\n\treturn max(length(p.xy) - r, abs(p.z) - h);\n}\n\n\n\n\nvoid sphere_fold(inout vec3 z, inout float dz) {\n    float fr = 0.8; //2. - iMouse.z / 100.;\n    float mr = .1; // + iMouse.w / 100.;\n    \n    float r2 = dot(z, z);\n    if(r2 < mr) {\n        float temp = (fr / mr);\n        z *= temp;\n        dz *= temp;\n    }else if(r2 < fr) {\n        float temp = (fr / r2);\n        z *= temp;\n        dz *= temp;\n    }\n}\n\nvoid box_fold(inout vec3 z, inout float dz) {\n    float fl = 1.;\n    z = clamp(z, -fl, fl) * 2.0 - z;\n}\n\nfloat mb(vec3 z) {\n    float scale = -1.5 + iMouse.x / 100.;\n    vec3 offset = z;\n    float dr = 1.0;\n    for(int n = 0; n < 16; ++n) {\n        box_fold(z, dr);\n        sphere_fold(z, dr);\n\n        z = scale * z + offset;\n        dr = dr * abs(scale) + 1.0;\n\t\t//scale = -2.8 - 0.2 * stime;\n    }\n    float r = length(z);\n    return r / abs(dr);\n}\n\n\n\n\n\n\nfloat map(vec3 p){\n    p = rotY(iTime * .2) * p;\n    \n    float scene = min(1000. /* mb(p) */, box(p, vec3(1., 1., 1.)));\n    \n    \n    return mb(p);\n}\n\n\nvec3 normal(vec3 p){\n    return normalize(vec3(\n        map(vec3(p.x + E, p.y, p.z)) - map(vec3(p.x - E, p.y, p.z)),\n        map(vec3(p.x, p.y + E, p.z)) - map(vec3(p.x, p.y - E, p.z)),\n        map(vec3(p.x, p.y, p.z + E)) - map(vec3(p.x, p.y, p.z - E))\n    ));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    uv -= .5;\n    uv.y /= iResolution.x / iResolution.y;\n    \n    vec3 sky = vec3(0., .5, 1.);\n    vec3 c = sky;\n    \n    vec3 ro = vec3(0., 0., -iMouse.y / 10.);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n    float t = 0.;\n    \n    for (int step = 0; step < 200; step++){\n    \tvec3 p = (ro + t * rd);\n        float d = map(p);\n        if (abs(d) < E){\n            vec3 n = normal(p);\n            float shading = clamp(dot(n, normalize(ro - p)), 0., 1.);\n            c = vec3(1.);\n            \n            if (sph1(p) < E)\n            \tc *= texture(iChannel0, vec2(atan(p.x), atan(p.y))).x;\n            if (plane(p) < E)\n                c = vec3(.8, .3, .0);\n            c *= shading;\n            c = mix(c, sky, smoothstep(0., .5, length(p - ro) / 100.));\n            break;\n        }\n        else if (d > 100.)\n        {\n            break;\n        }\n        t += d;\n    }\n\n    fragColor = vec4(c,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}