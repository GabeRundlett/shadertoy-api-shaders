{
    "Shader": {
        "info": {
            "date": "1714414420",
            "description": "really weird rendering method but I didn't need anything fancy for now... new project using this coming soon hopefully.",
            "flags": 0,
            "hasliked": 0,
            "id": "lftXDS",
            "likes": 0,
            "name": "car sdf model͏ 001",
            "published": 3,
            "tags": [
                "asset"
            ],
            "usePreview": 0,
            "username": "01000001",
            "viewed": 66
        },
        "renderpass": [
            {
                "code": "// START OF CAR //\n#define pi 3.1415926\n\nstruct material {\n    vec3 colour;\n    float roughness;\n    float metallic;\n};\n\nconst material base = material(vec3(1), 1., 0.);\nmaterial grille = material(vec3(.1), 1., 1.);\nmaterial paint = material(vec3(.2, .3, .9), 1., 1.);\nmaterial tire = material(vec3(.2), 1., 0.);\nmaterial glass = material(vec3(0), 0., 0.);\nmaterial mirror = material(vec3(1), 0., 1.);\nmaterial carbon_fibre = material(vec3(.4), 1., 0.);\n\nmaterial mat = base;\n\n\n\nfloat torusDF( vec3 p, vec2 t ) // By Inigo Quilez\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat boxDF( vec3 p, vec3 b ) // By Inigo Quilez\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat rectDF( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat triangleDF( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n\nfloat cylinderDF( vec3 p, float h, float r ) // By Inigo Quilez\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat smin( float a, float b, float k ) // By Inigo Quilez \n{\n    k *= 1.0;\n    float ra = exp2(-a/k) + exp2(-b/k);\n    return -k*log2(ra);\n}\n\nfloat smax( float a, float b, float k ){\n    return -smin(-a, -b, k);\n}\n\nmat2 rot(float t){\n    return mat2(\n        cos(t), sin(t), -sin(t), cos(t)\n    );\n}\n\nfloat lagrange(float x){\n    vec2 a = vec2(.063, .076);\n    vec2 b = vec2(.595, .192);\n    vec2 c = vec2(.817, .173); // was .183\n    vec2 d = vec2(.323, .106);\n    vec2 e = vec2(1.00, .161);\n    \n    float l1 = (x*(x-b.x)*(x-c.x)*(x-d.x)*(x-e.x)*a.y) / (a.x*(a.x-b.x)*(a.x-c.x)*(a.x-d.x)*(a.x-e.x));\n    float l2 = (x*(x-a.x)*(x-c.x)*(x-d.x)*(x-e.x)*b.y) / (b.x*(b.x-a.x)*(b.x-c.x)*(b.x-d.x)*(b.x-e.x));\n    float l3 = (x*(x-a.x)*(x-b.x)*(x-d.x)*(x-e.x)*c.y) / (c.x*(c.x-a.x)*(c.x-b.x)*(c.x-d.x)*(c.x-e.x));\n    float l4 = (x*(x-a.x)*(x-b.x)*(x-c.x)*(x-e.x)*d.y) / (d.x*(d.x-a.x)*(d.x-b.x)*(d.x-c.x)*(d.x-e.x));\n    float l5 = (x*(x-a.x)*(x-b.x)*(x-c.x)*(x-d.x)*e.y) / (e.x*(e.x-a.x)*(e.x-b.x)*(e.x-c.x)*(e.x-d.x));\n\n    return l1 + l2 + l3 + l4 + l5;\n\n}\n\n#define n(x) m=min(m, x)\n\n//Chassis dimensions\nvec3 offset = vec3(3.6, 0, 1);\nvec3 size = vec3(6.5, 2.9, 1.7);\nfloat grilleScale = 25.;\n\nfloat carDF(vec3 p, float steer, bool matUpdate){\n    float m = 1e9;\n    \n    p.z -= 1.;\n    p.xy = vec2(-p.y, p.x);\n    \n    float bb = boxDF(p - offset, size);\n    if (bb > .5){\n        return bb;\n    }\n    \n    float ratio = .3;\n    \n    if (abs(p.y) > size.y - 1.5 && abs(p.x - 3.5) > 2. && abs(p.x - 3.5) < 4.7){\n\n        //return 1.;\n        \n        // One wheel call for all four wheels\n        vec3 w = (p - vec3(p.x > 4.?7.:0., p.y>0.?(size.y-.5):-(size.y-.5), 0)); \n        w.xy *= rot(p.x > 4.?0.:steer);\n        \n        float tread, surf = w.x*w.x + w.z*w.z;\n        if (surf > .9) tread = pow(sin(w.y*70. - sin(atan(w.z, w.x)*50.))*.2+.2, 4.);\n        \n        n(\n            smax(\n                torusDF(w * vec3(1, ratio, 1), vec2(1.-ratio, ratio)),\n                abs(w.y) - .5,\n                .05\n            ) + (surf > .9?\n            tread*max(0., (1.-pow(w.y*3., 2.)))\n            :0.)\n        );\n\n    }\n    //if (dot(p, vec3(sin(iTime), cos(iTime), 0)) < 0.) return 1.;\n    //if (p.y < 0.) return 1.;\n    p.y = abs(p.y);\n    // Everything after this point is mirrored\n\n    \n    // Chassis\n    n(\n        max(\n            max(\n                min(\n                    smax(\n                        smax(\n                            smax(\n                                p.y - size.y - (\n                                    (lagrange((p.x - offset.x + size.x)/(size.x*2.)) - .12)*5.\n                                        * exp(-p.x*.1+.5)\n                                        - exp(p.x/1.5 - offset.x - size.x + 3.)\n                                        - p.z*p.z*.2\n                                            * min((1.-smoothstep(5., 10., p.x)), smoothstep(0., 5., p.x))\n                                ), // Side\n\n                                p.z + size.z - offset.z - (\n                                    lagrange((p.x - offset.x + size.x)/(size.x*2.))*10. + 1.2\n                                ), // Roof\n\n                                .2\n                            ),\n\n                            // Floor\n                            -(p.z + size.z - offset.z) + (\n                                exp((p.x - size.x*1.54)*1.2)\n                                //pow(max(0., (p.x-size.x))/3., 2.)\n                            ),\n\n                            .05\n                        ),\n\n                        bb,\n\n                        .02\n                    ),\n                    \n                    min(\n                        // Diffuser\n                        boxDF(\n                            (p - offset - vec3(size.x*.75, min((floor(p.y) + .65), 1.7), -1.)),\n                            vec3(size.x/4., .03, size.z-1.)\n                        ) - .02,\n                        \n                        // Side Mirrors\n                        max(\n                            length((p - vec3(3, size.y - .3, .8 + p.x*.2))/vec3(3, 2, 1)) - .2,\n                            p.x-3. - p.y*.1 + .2\n                        )\n                    )\n\n                ),\n\n                // Wheel wells\n                -cylinderDF(p - vec3(p.x>3.5?7:0,size.y - .5,0), 1., 1.1)\n            ),\n\n            // Grille\n            -(\n                boxDF((p - vec3(-size.x + offset.x - .45, 0, -.4)), vec3(0, 1, .4))-.5\n            )\n        )\n    );\n    \n    n(\n        // Front splitter\n        max(\n            abs(p.z + size.z - offset.z)-.03,\n            max(\n                max(p.x + 1., p.x - 4.3 + p.y*2.), \n                -p.x - size.x + offset.x - .25 + exp((p.y-size.y+.24)*3.)\n            )\n        )\n    );\n\n    if (matUpdate){\n    \n        mat = paint;\n        \n        if (\n            p.x < 0. \n            && rectDF(p.yz - vec2(0, -.3), vec2(1, .3)) < .2 && p.z > -.66 // Front Grille\n        ) mat = grille;\n        \n        if (\n            p.z > 0. \n            && rectDF(p.yx - vec2(-p.x*.3 + .9, 3.3), vec2(size.y*.7, 1)) < -(2. - p.x)/8. // Windshield\n        ) mat = glass;\n        \n        if (\n            rectDF(p.xz - vec2(5.3, 2), vec2(2, .3)) < .2 // Side window\n            && p.z < 2.4-pow((p.x - 6.3)/3.7, 2.) // Main top curve\n            - exp((p.x - 9.)/2.) // Upper rear curve\n        ) mat = glass;\n        \n        if (\n            abs(m - (p.x-3. - p.y*.1 + .2)) < .01\n            && length((p.yz - vec2(size.y - .3, .8 + p.x*.2))/vec2(2, 1)) < .19 // Mirror surface\n        ) mat = mirror;\n        \n        float c = cylinderDF(p - vec3(p.x>3.5?7:0,size.y - .5,0), 1., 1.1);\n        if (\n            p.z < -size.z + offset.z + .0301 + exp((p.x - size.x*1.54)*1.2) // Diffuser and splitter\n            || abs(c-m) < .001 // Wheel wells \n            || p.x > size.x + offset.x\n        ){\n            mat = carbon_fibre;\n            vec3 cp = p*10.;\n            mat.colour *= mod(floor(cp.x) + floor(cp.y) + floor(cp.z), 2.) * .2 + .3; \n        }\n        \n        if (c < -.01) mat = tire;\n        \n        // Decal art\n        if (\n            p.z > 0. && length(p.xy) < .9 + .1*sin(atan(p.y, p.x)*15.)){\n            mat.colour = vec3(1);\n        }\n    }\n    \n    \n    return m;\n}\n\n\n// END OF CAR // \n\n// USEFUL TO INCLUDE // \n\nfloat df(vec3 p, bool updateMat){\n    float m = 1e9;\n        \n    n(carDF(p, .5/*sin(iTime)*pi/4.*/, updateMat));\n    \n    if (updateMat){\n        if (p.z < m){\n            m = p.z;\n            mat = base;\n        }\n\n        if (length(p) > 30. && p.z > 1.) \n            mat.colour = .5 + .5*sin((p.x + p.y + p.z)/5. + vec3(0, 2, 4));\n\n    } else {\n        \n        n(p.z);\n        if (length(p) > 30. && length(p) < 70. && p.z > 1.){\n            n(length(mod(p, 5.) - 2.5 + vec3(sin(p.z/3.), cos(p.y/3.), sin(p.x/3.)))-1.);\n        }\n        \n    }\n    \n    return m;\n}\n\nfloat df(vec3 p){\n    return df(p, false);\n}\n\nvec3 norm(vec3 p, float e){\n    float c = df(p);\n    return normalize(vec3(\n        c - df(p - vec3(e, 0, 0)),\n        c - df(p - vec3(0, e, 0)),\n        c - df(p - vec3(0, 0, e))\n    ));\n}\n\n\n\n// END OF USEFUL TO INCLUDE //\n\n\n\nconst int aoIter = 4;\nconst float aoDist = 0.05;\nconst float aoPower = 2.;\n\nfloat ao(vec3 p, vec3 n) {\n    float dist = aoDist;\n    float occ = 1.0;\n    for (int i = 0; i < aoIter; ++i) {\n        occ = min(occ, df(p + dist * n) / dist);\n        dist *= aoPower;\n    }\n    occ = max(occ, 0.0);\n    return occ;\n}\n\n\nvoid mainImage( out vec4 O, vec2 U ){\n    \n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    vec2 cuv = (2.*U-r)/r.y;\n    vec2 muv = (2.*iMouse.xy-r)/r.y + (vec2(iMouse.z > 0.?0.:min(iTime*.1, .05*iTime*iTime), -.5));\n    muv.x *= 2.;\n    O = vec4(0);\n\n    vec3 o = vec3(0, -3.5, .5);\n    vec3 dir = vec3(sin(muv.x)*cos(muv.y), cos(muv.x)*cos(muv.y), sin(muv.y));\n    o -= dir*22.;\n    vec3 right = normalize(cross(dir, vec3(0, 0, 1)));\n    vec3 up = cross(right, dir);\n    \n    vec3 dirV = normalize(dir * 5. + right * cuv.x + up * cuv.y);\n\n    int steps = 0;\n    float d,tt,t=0.;\n    vec3 p = o;\n    bool hit = false;\n\n    for (; steps < 256; steps++){\n        p = o + dirV * t;\n        d = df(p);\n        t += d*.8;\n\n        if (d < 1e-2){\n            steps++;\n            hit = true;\n        }\n    }\n    tt = t;\n    vec3 normal = norm(p, .5*t/r.y);\n    \n    float ao = mix(1., ao(p, normal), .5);\n    // ~~Stolen~~ Permanently borrowed from https://www.shadertoy.com/view/XlXyD4\n    \n    vec3 col, rcol = vec3(0);\n    vec3 pLight = -offset.yxz + vec3(cos(iTime), sin(iTime), 1.)*20.;\n    float light = max(0.01, 100. * (dot(normal, (pLight-p)/pow(length(pLight-p), 3.))) + .1 ) * ao;\n    df(p, true); \n\n    material omat = mat;\n    \n    float fresnel = 1.-pow(-dot(normal, dirV), 5.);\n    \n    if (mat.roughness < .5){\n        \n        o = p;\n        dirV = reflect(dirV, normal);\n        t = 0.1;\n        \n        bool rhit = false;\n        for (steps = 0; steps < 128; steps++){\n            p = o + dirV * t;\n            d = df(p)/min(1., t);\n            t += d*.8;\n\n            if (d < 1e-2){\n                steps++;\n                rhit = true;\n            }\n        }\n        tt+=t;\n        \n        vec3 pLight = vec3(-1, 1, 1.)*10.;\n        df(p, true); \n\n        rcol = mat.colour * max(0.01, 100. * (dot(normal, (pLight-p)/pow(length(pLight-p), 3.))) + .1 );\n        if (!rhit) rcol = vec3(0);//texture(iChannel1, dirV).xyz;\n\n\n        if (omat.metallic > .5){\n            col = omat.colour * rcol;\n        } else {\n            col = mix(omat.colour * light, rcol, fresnel);\n        }\n    } else {\n        \n        if (omat.metallic > .5){\n            \n            col = omat.colour * texture(iChannel0, normal.yzx).xyz;\n            \n        } else {\n            col = omat.colour * light;\n        }\n        \n    }\n    if (!hit) col = vec3(0);//texture(iChannel1, dirV).xyz;\n    \n    \n    //O.xyz = vec3(t);\n    O.xyz = col;\n\n    //O += vec4(1,0,0,0)*5e-3/(p.y*p.y);\n    //O += vec4(0,1,0,0)*5e-3/(p.x*p.x);\n    \n    p.xy += offset.yx;\n    O += vec4(1,.1,0,0) * (p.z < .1?5./pow(abs(rectDF(p.yx, size.xy-2.)), 2.):0.);\n    \n    O += vec4(0,.1,1.,0) * (p.z < .1?5./pow(abs(length(p.yx)-size.x*2.), 2.):0.);\n    \n    // the way this works is so absurdly hacky it took me a minute to figure out how it was still working\n    // IN THE REFLECTIONS after adding reflections. Not totally accurate, but I'm not complaining XD\n    \n    O.xyz = flim(O.xyz, 0., true);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*-----------------------------------------------\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  Linear BT.709 I-D65 / sRGB 2.2 (depends on arguments)\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n\nMinified by:\n  Ahsen (01000001 on shadertoy)\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n-----------------------------------------------*/\n\n\nconst vec3 pf=vec3(1),pb=vec3(1),pff=vec3(1);\nconst float pe=4.3,ps=0.,gr=1.05,gg=1.12,gb=1.045,rr=.5,rg=2.,br=.1,rm=1.,gm=1.,bm=1.,lm=-10.,lx=22.,tx=.44,ty=.28,sx=.591,sy=.779,fe=6.,fd=5.,pfe=6.,pfd=27.5,ffs=0.,ms=1.02;\n\nvec3 op(vec3 c,float p){return pow(c,vec3(1./p));}\nfloat fw(float v,float s,float e){return s + mod(v-s,e-s);}\nfloat fr(float v,float s,float e,float r,float f){return r + ((f-r)/(e-s))*(v-s);}\nfloat f0( float v,float s,float e){return clamp((v-s)/(e-s),0.,1.);}\nvec3 rh(vec3 r){\n    float a,i,h,s,v,d;\n    vec3 c;\n    a=max(r[0],max(r[1],r[2]));\n    i=min(r[0],min(r[1],r[2]));\n    d=a-i;\n    v=a;\n    if (a!=0.){s=d/a;}\n    else{s=0.; h=0.;}\n    if (s==0.){h=0.;}\n    else{c=(vec3(a)-r.xyz)/d;\n        if (r.x==a){h=c[2]-c[1];}\n        else if (r.y==a){h=2.+ c[0]-c[2];}\n        else{h=4.+ c[1]-c[0];}\n        h/=6.;\n        if (h < 0.){h +=1.;}\n    }\n    return vec3(h,s,v);\n}\n\nvec3 hr(vec3 w){\n    float f,p,q,t,h,s,v;\n    vec3 g;\n    h=w[0];\n    s=w[1];\n    v=w[2];\n    if (s==0.){g=vec3(v,v,v);}\n    else{\n        if (h==1.){h=0.;}\n        h*=6.;\n        int i=int(floor(h));\n        f=h-float(i);\n        g=vec3(f,f,f);\n        p=v*(1.-s);\n        q=v*(1.-(s*f));\n        t=v*(1.-(s*(1.-f)));\n        if (i==0){g=vec3(v,t,p);}\n        else if (i==1){g=vec3(q,v,p);}\n        else if (i==2){g=vec3(p,v,t);}\n        else if (i==3){g=vec3(p,q,v);}\n        else if (i==4){g=vec3(t,p,v);}\n        else{g=vec3(v,p,q);}\n    }\n    return g;\n}\n\nvec3 bs(vec3 c,float h,float s,float v)\n{\n    vec3 r=rh(c);\n    r[0]=fract(r[0] + h + .5);\n    r[1]=clamp(r[1]*s,0.,1.);\n    r[2]=r[2]*v;\n    return hr(r);\n}\n\nfloat fa(vec3 c){return (c.x + c.y + c.z)/3.;}\nfloat fs(vec3 c){return c.x + c.y + c.z;}\nfloat fr(vec3 c){return max(max(c.x,c.y),c.z);}\nvec3 uo(vec3 c,float p,float w){\n    float m=fa(c);\n    float n=f0(m,p/1000.,1.-(w/1000.));\n    return c*(n/m);\n}\n\nvec3 s(float h){\n    h=fw(h*360.,0.,360.);\n    vec3 c=vec3(1,0,0);\n    c=mix(c,vec3(1,1,0),f0(h,0.,60.));\n    c=mix(c,vec3(0,1,0),f0(h,60.,120.));\n    c=mix(c,vec3(0,1,1),f0(h,120.,180.));\n    c=mix(c,vec3(0,0,1),f0(h,180.,240.));\n    c=mix(c,vec3(1,0,1),f0(h,240.,300.));\n    c=mix(c,vec3(1,0,0),f0(h,300.,360.));\n    return c;\n}\n\nvec3 sw(vec2 u){\n    float h=1.-u.y;\n    float e=fr(u.x,0.,1.,-5.,10.);\n    return s(h)*pow(2.,e);\n}\n\nfloat ss(float v,float x,float y,float sx,float sy){\n    v=clamp(v,0.,1.);\n    x=clamp(x,0.,1.);\n    y=clamp(y,0.,1.);\n    sx=clamp(sx,0.,1.);\n    sy=clamp(sy,0.,1.);\n    float s=(sy-y)/(sx-x);\n    if (v < x){\n        float t=s*x/y;\n        return y*pow(v/x,t);\n    }\n    if (v < sx){\n        float i=y-(s*x);\n        return s*v + i;\n    }\n    float sp=-s/(((sx-1.)/pow(1.-sx,2.))*(1.-sy));\n    return (1.-pow(1.-(v-sx)/(1.-sx),sp))*(1.-sy)+sy;\n}\n\nfloat dm(float m,float d){\n    float o=pow(2.,lm);\n    float f=f0(log2(m + o),lm,lx);\n    f=ss(f,tx,ty,sx,sy);\n    f*=d;\n    f=pow(2.,-f);\n    return clamp(f,0.,1.);\n}\n\nvec3 rl(vec3 c,vec3 st,vec3 dt,float d){\n    vec3 sn=st/fs(st);\n    vec3 dn=dt/fr(dt );\n    float m=dot(c,sn);\n    float f=dm(m,d);\n    return mix(dn,vec3(1),f);\n}\n\nvec3 rd(vec3 c,float e,float d){\n    c*=pow(2.,e);\n    vec3 r=rl(c,vec3(0,0,1),vec3(1,1,0),d);\n    r*=rl(c,vec3(0,1,0),vec3(1,0,1),d);\n    r*=rl(c,vec3(1,0,0),vec3(0,1,1),d);\n    return r;\n}\n\nvec3 ge(float p,float s,float r,float m){\n    vec3 o=hr(vec3(fw(p + (r/360.),0.,1.),1./s,1.));\n    o/=fs(o);\n    o*=m;\n    return o;\n}\n\nmat3 fm(float rs,float gs,float bs,float rr,float gr,float br,float rm,float gm,float bm){\n    mat3 m;\n    m[0]=ge(0.,rs,rr,rm);\n    m[1]=ge(1./3.,gs,gr,gm);\n    m[2]=ge(2./3.,bs,br,bm);\n    return m;\n}\n\nvec3 np(vec3 c,vec3 b){\n    c=rd(c,fe,fd);\n    c*=b;\n    c=rd(c,pfe,pfd);\n    return c;\n}\n\nvec3 flim(vec3 c,float e,bool t){\n    c=max(c,0.);\n    c*=pow(2.,pe + e);\n    c=min(c,5000.);\n    mat3 x=fm(gr,gg,gb,rr,rg,br,rm,gm,bm);\n    mat3 i=inverse(x);\n    vec3 b=pb*x;\n    const float g=1e7;\n    vec3 w=np(vec3(g),b);\n    c=mix(c,c*pf,ps);\n    c*=x;\n    c=np(c,b);\n    c*=i;\n    c=max(c,0.);\n    c/=w;\n    vec3 f=np(vec3(0.),b);\n    f/=w;\n    c=uo(c,fa(f)*1000.,0.);\n    c=mix(c,c*pff,ffs);\n    c=clamp(c,0.,1.);\n    float m=fa(c);\n    float mix_fac =(m<.5)? f0(m,.05,.5):f0(m,.95,.5);\n    c=mix(c,bs(c,.5,ms,1.),mix_fac);\n    c=clamp(c,0.,1.);\n    if (t) c=op(c,2.2);\n    return c;\n}\n\n/*____________________ end ____________________*/\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}