{
    "Shader": {
        "info": {
            "date": "1620167321",
            "description": "Some tools to play with voronoi cells\n",
            "flags": 0,
            "hasliked": 0,
            "id": "7dSSW1",
            "likes": 31,
            "name": "Free voronoi cells",
            "published": 3,
            "tags": [
                "2d",
                "voronoi",
                "worley",
                "cells",
                "polygon"
            ],
            "usePreview": 0,
            "username": "iapafoto",
            "viewed": 824
        },
        "renderpass": [
            {
                "code": "// Created by Sebastien Durand - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------\n// Inspired by \n// tomkh [Faster Voronoi Edge Distance] https://shadertoy.com/view/llG3zy\n// iq    [Voronoi - distance]           https://www.shadertoy.com/view/ldl3W8\n// https://iquilezles.org/articles/voronoilines\n//-----------------------------------\n// An other way to extract polygons in a stylish shader\n// shane [Triangle-Voronoi Graph Weave] https://www.shadertoy.com/view/XsycDd\n// 3D voronoi cell distance field\n// iapafoto [https://www.shadertoy.com/view/ssBXWW] https://www.shadertoy.com/view/ssBXWW\n//-----------------------------------\n\n#define ANIMATE\n#define WITH_BOUNDING_CIRCLE\n//#define WITH_INSCRIBE_CIRCLE\n\n// How far cells can go off center during animation \n// minimal voronoi doesn not like more than .3 \n#define ANIMATE_D .3\n\n// get ids in a cyclic order to i,j neigbourg elements\n#define ID_POS(x) clamp(abs(4.-8.*fract(vec2(x+3,x-3)/8.))-2.,-1.,1.)\n//#define ID_POS(id) vec2(clamp(abs((id-ivec2(27,29))%8+4)-2,-1,1)) // % does not likes negative values\n\nfloat time;\n\n//-----------------------------------\n// cells position that show how to put limits on cells\n// an intersection with a bbox distance field may do the job also\n//-----------------------------------\nvec2 hash2(vec2 p) {\n    vec2 o = ANIMATE_D*texture( iChannel0, (p+0.5)/256.0, -100.0 ).xy;\n    o = ANIMATE_D*cos(.5*(3.+o)*time + o*6.2831853);\n    // Stop noise on borders\n         if (p.x >= 3.) return vec2(-.3,p.y<-1.?.3:p.y>=3.?-.3:0.);\n    else if (p.x < -1.) return vec2(.3,p.y<-1.?.3:p.y>=3.?-.3:0.);\n         if (p.y >= 3.) return vec2(0,-.3);\n    else if (p.y < -1.) return vec2(0,.3);\n    return o;\n}\n\n//-----------------------------------\n// Minimalist voronoi distance for one cell\n// Inexact outside of cells\n// Generalisable to 3D cells\n//-----------------------------------\nvec3 sdVoronoiCell(in vec2 p, in vec2 cellId ) {\n    float md = 8.0;    \n    vec2 mr = hash2(cellId);\n    for(int i=0; i<8; i++) {\n        vec2 g = ID_POS(i),\n             r = g + hash2(cellId + g);\n        md = min(md, dot(.5*(mr+r)-p, normalize(r-mr)));\n    }\n    return vec3(-md, mr-p);\n}\n\n//-----------------------------------\n// Indicate if a point is inside a voronoi cell\n//-----------------------------------\nbool isInsideVoronoiCell(in vec2 p, in vec2 cellId) {\n    float dm = length(hash2(cellId)-p);\n    for(int i=0; i<8; i++) {\n        vec2 g = ID_POS(i),\n             r = g + hash2(cellId + g);\n        if (length(r-p) < dm) return false;\n    }\n    return true;\n}\n\n//-----------------------------------\n// Draw construction lines on voronoi\n//-----------------------------------\nvec3 drawVoronoiLines(in vec2 p, in vec2 cellId) {\n    vec2 rm = hash2(cellId); // center of cell\n    vec3 d = vec3(999.);\n    for(int i=0; i<8; i++) {\n        vec2 g = ID_POS(i),                     // relative pos of neigbourg cell\n             r = g + hash2(cellId + g),         // center of the neigbourg cell\n             n = r - rm,                     \n             c = rm + n*.5;                     // ref pt between cells\n        n = normalize(vec2(-n.y,n.x));          // normal on the edge\n        d = min(d, vec3(length(c-p),            // distance to the \n                        sdSegment(p,r,rm),      // distance to segment between cells \n                        sdSegment(p,c+n,c-n))); // distance to edge of cell\n    }\n    return d;\n}\n\n//-----------------------------------\n// Extract voronoi cell polygon\n//-----------------------------------\nvec2[8] getVoronoiPolygon(in vec2 p, in vec2 cellId, out int out_sz) {\n\tvec2 rm = hash2(cellId); // center of cell\n    vec2 c[8], n[8];\n    // Get liste of lines\n    for(int i=0; i<8; i++) {\n        vec2 g0 = ID_POS(i),\n             r0 = g0 + hash2(cellId + g0),  // centre de l'autre cellule\n             n0 = r0 - rm;\n         c[i] = rm + n0*.5;  // Pt entre les 2 cellules             \n         n[i] = normalize(vec2(-n0.y,n0.x));\n    }\n    // Find intersection between lines\n    vec4 seg[8]; // x:-2 y:-1 z:+1 w:+2  \n    for(int i=2; i<10; i++) { // Intersection point with two previous lines\n        vec2 t1 = intersect(c[i%8], n[i%8], c[(i-1)%8], n[(i-1)%8]),\n             t2 = intersect(c[i%8], n[i%8], c[(i-2)%8], n[(i-2)%8]);\n        seg[i%8].x = t2.x;     // -2 of seg  0\n        seg[i%8].y = t1.x;     // -1 of seg  0\n        seg[(i-1)%8].z = t1.y; // +1 of seg -1\n        seg[(i-2)%8].w = t2.y; // +2 of seg -2      \n    }\n    // Reconstruct the polygon\n    out_sz = 0;\n    for(int i=0; i<8; i++) {\n        float dmin = max(seg[i].z,seg[i].w);\n        if (dmin < min(seg[i].x,seg[i].y)) { // skip useless segments\n            n[out_sz] = c[i]+dmin*n[i];\n            out_sz++;\n        }\n    }\n    return n;\n}\n\n\n//-----------------------------------\n// Animate all this\n//-----------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    time = mod(iTime-4., 40.);\n    \n    // Animation ticks\n    float a0 = smoothstep( 7., 5.,time),\n          a1 = smoothstep( 2., 5.,time),\n          a2 = smoothstep( 8.,11.,time)-smoothstep(14.,17.,time),\n          a5 = smoothstep(28.,32.,time),\n          a4 = smoothstep(20.,22.,time)-a5,\n          a3 = smoothstep(14.,16.,time)-a5;\n    \n    // Coords on screen\n    float sc = step(512., iResolution.y)*4. + 6., // Scale differently for fullscreen\n\t      ss = (a5+sc) / iResolution.y; // Size of 1 pixel\n    vec2 p = (fragCoord.xy - iResolution.xy*.5)*ss + .4;\n    float k = 1.+a5;                    // Separation distance between cells\n    p *= 1.-.4*a5;\n    p += (1.5+.5*cos(.5*iTime))*a5;\n    \n    // The selected cell\n    vec2 cellId = vec2(1,1);\n\n    float d2 = 999., d = 999., dm;\n    // Very slow to display cell by cell like this but this enables the final effect! :)\n    // for normal cases, use Faster Voronoi Edge Distance\" by tomkh. https://shadertoy.com/view/llG3zy\n    for( int j=-2; j<=3; j++)\n    for( int i=-2; i<=3; i++) {\n         vec2 g = vec2(i,j);\n         if (length(k*g-p)<1.5) { // do it only on neighbourhood\n             vec3 v = sdVoronoiCell(p-k*g, g);\n             d  = min(d,v.x);\n             d2 = min(d2, length(v.yz));\n         }\n    }\n    \n    // Find if a pixel is inside a specified cell\n    bool insideCell = isInsideVoronoiCell(p-cellId*k, cellId);\n    \n    // Find if a pixel is inside a specified cell\n    vec3 dseg = drawVoronoiLines(p-cellId*k, cellId);\n    \n    // Extract polygon\n    int out_psz;\n    vec2[8] poly = getVoronoiPolygon(p-cellId*k, cellId, out_psz);\n    float dPoly = sdPolygon(p-cellId*k, poly, out_psz);\n    // Dots of polygon\n    float d1 = 999.;\n    for(int i=0; i<out_psz; i++) {\n        d1 = min(d1, length(p-cellId*k-poly[i])-.05);\n    }\n    \n    // Display the animation\n    float dall;\n    if (a5 > 0.) {\n        dall = dPoly;\n    } else {\n        dall = d;\n        if (dall>0.) dall = sdBox(p-vec2(.47,.47),vec2(2.7,2.7)); // fake outside for full square display\n    }\n    vec3 col = vec3(1) - sign(dall)*vec3(.1,.4,.7);\n\tcol *= 1. - exp(-2.*abs(dall));\n\tcol *= .8 + .2*cos(120.*dall);\n    col *= a0+a5;\n#ifdef WITH_BOUNDING_CIRCLE    \n    if (a4>0.) {\n        vec3 circle = minimumEnclosingCircle(poly,out_psz); \n        col = mix(col, vec3(.4), a4*smoothstep(.07,.04,abs(length(p-cellId*k - circle.xy)-circle.z)-.035)); \n    }\n#endif  \n#ifdef WITH_INSCRIBE_CIRCLE    \n    if (anim4>0.) {\n        vec3 circle = findInscribeCircle(poly,out_psz);\n        col = mix(col, vec3(1.), anim4*smoothstep(.02,.0,abs(length(p-cellId*k - circle.xy)-circle.z)-.01)); \n    }\n#endif  \n    if (insideCell) col = mix(col,vec3(1,0,0),.4*(a1-a5)); \n\tcol = mix(col, vec3(1.),        (.2*(1.-a5)+.8*a0)*smoothstep(.03,0.,abs(d))); // borders\n   \tcol = mix(col, vec3(1.),        a2*smoothstep(.05,.03,abs(d2)));               // centers\n    col = mix(col, vec3(1.,0,0),    a3*smoothstep(.02,.0,dseg.z));                 // segments\n    col = mix(col, vec3(1.),           smoothstep(.03,.0,abs(dPoly)));             // polygon\n    col = mix(col, vec3(1.),        a2*smoothstep(.02,.0,dseg.y));\n    col = mix(col, vec3(0.5,.8,.8), a4*smoothstep(.03,.02,d1));                    // points\n    col = mix(col, vec3(1.),        a4*smoothstep(.03,.01,abs(d1-.04)));\n    col = mix(col, vec3(1.,0,0),    a2*smoothstep(.07,.05,dseg.x));\n    col = mix(col, vec3(1),        a2*smoothstep(.03,.01,abs(dseg.x-.07)));    \n\n    fragColor = vec4(col,1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1.);\n    return length(pa - ba*h);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdBox( in vec2 p, in vec2 b) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.)) + min(max(d.x,d.y),0.);\n}\n\n// iq: https://www.shadertoy.com/view/wdBXRW\nfloat sdPolygon(in vec2 p, in vec2[8] v, int num ) {\n    float s = 1., d = dot(p-v[0],p-v[0]);\n    for( int i=0, j=num-1; i<num; j=i, i++ ) {\n        vec2 e = v[j] - v[i], w = p - v[i],\n             b = w - e*clamp( dot(w,e)/dot(e,e), 0., 1.);\n        d = min(d, dot(b,b));\n        bvec3 cond = bvec3(p.y>=v[i].y, p.y <v[j].y,  e.x*w.y>e.y*w.x );\n        if (all(cond) || all(not(cond))) s=-s;  \n    }\n    return s*sqrt(d);\n}\n\n// basic line line intersection\nvec2 intersect(vec2 p0, vec2 n0, vec2 p1, vec2 n1) {\n    float d = n0.x*n1.y-n0.y*n1.x; // 0 if paralelle but does not append here\n    vec2 p = (p0-p1)/d;\n    return vec2(p.y*n1.x-p.x*n1.y, p.y*n0.x-p.x*n0.y);\n}\n\n\n// https://www.geeksforgeeks.org/minimum-enclosing-circle-set-1/\n\nfloat INF = 1e5;\n  \n// Function to check whether a vec2 lies inside\n// or on the boundaries of the vec3\nbool isInside(vec3 c, vec2 p) {\n    return distance(c.xy, p) <= c.z;\n}\n\n// Function to return the smallest vec3\n// that intersects 2 Points\nvec3 circleFrom(vec2 A, vec2 B) {\n    vec2 C = .5*(A+B); // Set the center to be the midPoint of A and B\n    return vec3(C, distance(A,B)*.5); // Set the radius to be half the distance AB\n}\n\n  \n// The following two functions are the functions used\n// To find the equation of the vec3 when three Points are given.\n// Helper method to get a vec3 defined by 3 Points\nvec2 getCircleCenter(vec2 b, vec2 c) {\n    float B = dot(b,b),\n          C = dot(c,c),\n          D = b.x * c.y - b.y * c.x;\n     return vec2(c.y*B-b.y*C, b.x*C-c.x*B) / (D+D);\n}\n\n// Function to return a unique vec3 that intersects\n// three Points\nvec3 circleFrom(vec2 A, vec2 B, vec2 C) {\n    vec2 I = getCircleCenter(B-A,C-A) + A;\n    return vec3(I, distance(I, A));\n}\n\n// Function to check whether a vec3 encloses the given Points\nbool isValidCircle(vec3 c, vec2[8] P, int num) { \n    // Iterating through all the Points to check\n    // whether the Points lie inside the vec3 or not\n    for (int i=0; i<num; i++)\n        if (distance(c.xy, P[i]) > c.z+1e-2)\n            return false;\n    return true;\n}\n \n// Function to return find the minimum enclosing\n// vec3 from the given set of Points\nvec3 minimumEnclosingCircle(vec2[8] P, int n) {\n    if (n == 0) return vec3(0);\n    if (n == 1) return vec3(P[0],0);\n  \n    vec3 mec = vec3(0,0,INF);\n    // Go over all pair of Points\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n              // Get the smallest circle that intersects P[i] and P[j]\n            vec3 tmp = circleFrom(P[i], P[j]);\n            // Update MEC if tmp encloses all Points and has a smaller radius\n            if (tmp.z < mec.z && isValidCircle(tmp, P, n))\n                mec = tmp;\n        }\n    }\n  \n    // Go over all triples of Points\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            for (int k = j + 1; k < n; k++) {\n                // Get the vec3 that intersects P[i], P[j], P[k]\n                vec3 tmp = circleFrom(P[i], P[j], P[k]);\n                // Update MEC if tmp encloses all Points and has smaller radius\n                if (tmp.z < mec.z && isValidCircle(tmp, P, n))\n                    mec = tmp;\n            }\n        }\n    }\n    return mec;\n}\n\n// does not calculate sign\nfloat sdPoly(in vec2 p, in vec2[8] v, int num ) {\n    float d = dot(p-v[0],p-v[0]);\n    for(int i=0, j=num-1; i<num; j=i, i++ ) {\n        vec2 e = v[j] - v[i], w = p - v[i],\n             b = w - e*clamp(dot(w,e)/dot(e,e), 0., 1.);\n        d = min(d, dot(b,b));\n    }\n    return -sqrt(d);\n}\n\n#define NB_ITER 14\n// Not very acurate\nvec3 findInscribeCircle(vec2[8] P, int n) {\n    vec2 p0,p=P[0]; // p0 to avoid too much occilation\n    for (int i=1; i<n; i++) p+=P[i];\n    p0 = p/=float(n); // start at mass center of points\n    // find scale of polygon\n    float d, len = 1e5; \n    for (int i=1; i<n; i++) if ((d=distance(p,P[i]))<len) len = d;\n    // gradiant descent to find min value of distance field\n    float dt = .4*len;\n    vec2 dd = vec2(.1*dt,0);\n    for (int i=0; i<NB_ITER; i++) {\n        p0 = p;\n        p -= dt*normalize(vec2(sdPoly(p+dd,P,n)    - sdPoly(p-dd,P,n), \n                               sdPoly(p+dd.yx,P,n) - sdPoly(p-dd.yx,P,n)));\n        dt *= .8;\n    }\n    return vec3((p+p0)*.5, -sdPolygon((p+p0)*.5, P, n));\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}