{
    "Shader": {
        "info": {
            "date": "1608242718",
            "description": "Inspired by the infinite corridor: https://castlevania.fandom.com/wiki/Infinite_Corridor",
            "flags": 32,
            "hasliked": 0,
            "id": "WdGBWt",
            "likes": 10,
            "name": "A Trip to Infinity",
            "published": 3,
            "tags": [
                "raymarching",
                "tunnel",
                "sdf",
                "trippy",
                "anamorphic"
            ],
            "usePreview": 1,
            "username": "TheNosiriN",
            "viewed": 658
        },
        "renderpass": [
            {
                "code": "#define RES iResolution.xy\n\n\nfloat NoiseSeed;\nfloat randomFloat(){\n  NoiseSeed = sin(NoiseSeed) * 84522.13219145687;\n  return fract(NoiseSeed);\n}\n\nfloat SCurve (float value, float amount, float correction) {\n\n\tfloat curve = 1.0; \n\n    if (value < 0.5)\n    {\n\n        curve = pow(value, amount) * pow(2.0, amount) * 0.5; \n    }\n        \n    else\n    { \t\n    \tcurve = 1.0 - pow(1.0 - value, amount) * pow(2.0, amount) * 0.5; \n    }\n\n    return pow(curve, correction);\n}\n\n\n\n//Chromatic Abberation from: https://www.shadertoy.com/view/XlKczz\nvec3 chromaticAbberation(sampler2D tex, vec2 uv, float amount)\n{\n    float aberrationAmount = amount/10.0;\n   \tvec2 distFromCenter = uv - 0.5;\n\n    // stronger aberration near the edges by raising to power 3\n    vec2 aberrated = aberrationAmount * pow(distFromCenter, vec2(3.0, 3.0));\n    \n    vec3 color = vec3(0.0);\n    \n    for (int i = 1; i <= 8; i++)\n    {\n        float weight = 1.0 / pow(2.0, float(i));\n        color.r += texture(tex, uv - float(i) * aberrated).r * weight;\n        color.b += texture(tex, uv + float(i) * aberrated).b * weight;\n    }\n    \n    color.g = texture(tex, uv).g * 0.9961; // 0.9961 = weight(1)+weight(2)+...+weight(8);\n    \n    return color;\n}\n\n\n\n\n//film grain from: https://www.shadertoy.com/view/wl2SDt\nvec3 filmGrain()\n{\n    return vec3(0.9 + randomFloat()*0.15);\n}\n\n\n\n\n//Sigmoid Contrast from: https://www.shadertoy.com/view/MlXGRf\nvec3 contrast(vec3 color)\n{\n    return saturate(vec3(\n        SCurve(color.r, 3.0, 1.0), \n        SCurve(color.g, 4.0, 0.7), \n        SCurve(color.b, 2.6, 0.6)\n    ));\n}\n\n\n\n\n//anamorphic-ish flares from: https://www.shadertoy.com/view/MlsfRl\nvec3 flares(sampler2D tex, vec2 uv, float threshold, float intensity, float stretch, float brightness)\n{\n    threshold = 1.0 - threshold;\n    \n    vec3 hdr = texture(tex, uv).rgb;\n    hdr = vec3(floor(threshold+pow(hdr.r, 1.0)));\n    \n    float d = intensity; //200.;\n    float c = intensity*stretch; //100.;\n    mat2 rot = rotate(30.0);\n    \n    //horizontal\n    for (float i=c; i>-1.0; i--)\n    {\n        float texL = texture(tex, uv+vec2(i/d, 0.0) * rot).r;\n        float texR = texture(tex, uv-vec2(i/d, 0.0) * rot).r;\n        hdr += floor(threshold+pow(max(texL,texR), 4.0))*(1.0-i/c);\n    }\n    \n    \n    hdr *= vec3(0.678,0.804,1.000); //tint\n    \n\treturn hdr*brightness;\n}\n\n\n\n//mip map bloom: https://www.shadertoy.com/view/Ms2Xz3\nconst float Threshold = 0.5;\nconst float Intensity = 2.0;\nconst float BlurSize = 2.0;\n\nvec3 mipMapBloom(vec3 Screen, in sampler2D Tex, in vec2 Coord, in float MipBias)\n{\n\tvec2 TexelSize = MipBias/iChannelResolution[0].xy;\n    \n    vec3  Color = texture(Tex, Coord, MipBias).rgb;\n    Color += texture(Tex, Coord + vec2(TexelSize.x,0.0), MipBias).rgb;    \t\n    Color += texture(Tex, Coord + vec2(-TexelSize.x,0.0), MipBias).rgb;    \t\n    Color += texture(Tex, Coord + vec2(0.0,TexelSize.y), MipBias).rgb;    \t\n    Color += texture(Tex, Coord + vec2(0.0,-TexelSize.y), MipBias).rgb;    \t\n    Color += texture(Tex, Coord + vec2(TexelSize.x,TexelSize.y), MipBias).rgb;    \t\n    Color += texture(Tex, Coord + vec2(-TexelSize.x,TexelSize.y), MipBias).rgb;    \t\n    Color += texture(Tex, Coord + vec2(TexelSize.x,-TexelSize.y), MipBias).rgb;    \t\n    Color += texture(Tex, Coord + vec2(-TexelSize.x,-TexelSize.y), MipBias).rgb;    \n\n    Color = Color/9.0;\n    vec3 Highlight = clamp(Color-Threshold,0.0,1.0)*1.0/(1.0-Threshold);\n    return saturate(1.0-(1.0-Screen)*(1.0-Highlight*Intensity));\n}\n\n\n\n\n//from: https://www.shadertoy.com/view/4l2GWm\nvec3 quincunxAA(sampler2D tex, vec2 fragCoord, float blur)\n{\n\tvec3 pixelColor;\n\tpixelColor =  texture(tex, (fragCoord + vec2( 0.0, 0.0)) / RES).rgb / 2.0;\n\tpixelColor += texture(tex, (fragCoord + vec2( blur, blur)) / RES).rgb / 8.0;\n\tpixelColor += texture(tex, (fragCoord + vec2( blur,-blur)) / RES).rgb / 8.0;\n\tpixelColor += texture(tex, (fragCoord + vec2(-blur,-blur)) / RES).rgb / 8.0;\n\tpixelColor += texture(tex, (fragCoord + vec2(-blur, blur)) / RES).rgb / 8.0;\n\treturn pixelColor;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/RES;\n    #ifdef MARGIN\n    if(uv.y < marginSize || uv.y > 1.0-marginSize){ fragColor = vec4(0.0); return; }\n    #endif\n    \n    vec3 color = quincunxAA(iChannel0, fragCoord, 2.0);\n    \n    \n    color = chromaticAbberation(iChannel0, uv, 0.8);\n    color *= filmGrain();\n    color = mipMapBloom(color, iChannel0, uv, BlurSize);\n    color += contrast(flares(iChannel0, uv, 0.9, 200.0, 0.8, 0.04));\n    \n    \n    \n    fragColor = vec4(color, 1.0);\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define MARGIN\n\nconst float PI = 3.1415972;\n#define saturate(x) clamp(x, 0.0, 1.0)\n\nconst float marginSize = 0.1;\n\nmat2 rotate(float angle)\n{\n\tangle *= PI / 180.0;\n    float s = sin(angle), c = cos(angle);\n    return mat2( c, -s, s, c );\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n\nvec3 rotateCamera(float len, vec2 m, vec4 mouse)\n{\n    float phi = m.x * PI * 2.0;\n    if(mouse.x < 0.5){\n        phi = PI * 0.1;\n    }\n    \n    float psi = m.y * PI;\n    if(mouse.y < 0.5){\n        psi = 0.33 * PI;\n    }\n    return len * vec3(cos(phi)*sin(psi), cos(psi), sin(phi)*sin(psi));\n}\n\n\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n\n\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031,.11369,.13787));\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat noise(vec3 p)\n{\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return \tmix(\n        \t\tmix(\n                \tmix(dot(pf - vec3(0, 0, 0), hash33(pi + vec3(0, 0, 0))), \n                        dot(pf - vec3(1, 0, 0), hash33(pi + vec3(1, 0, 0))),\n                       \tw.x),\n                \tmix(dot(pf - vec3(0, 0, 1), hash33(pi + vec3(0, 0, 1))), \n                        dot(pf - vec3(1, 0, 1), hash33(pi + vec3(1, 0, 1))),\n                       \tw.x),\n                \tw.z),\n        \t\tmix(\n                    mix(dot(pf - vec3(0, 1, 0), hash33(pi + vec3(0, 1, 0))), \n                        dot(pf - vec3(1, 1, 0), hash33(pi + vec3(1, 1, 0))),\n                       \tw.x),\n                   \tmix(dot(pf - vec3(0, 1, 1), hash33(pi + vec3(0, 1, 1))), \n                        dot(pf - vec3(1, 1, 1), hash33(pi + vec3(1, 1, 1))),\n                       \tw.x),\n                \tw.z),\n    \t\t\tw.y) * 0.5 + 0.5;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "const float MAX_DIST = 2000.0;\nconst vec4 MAX_VEC = vec4(vec3(0.0), MAX_DIST);\nconst float EPSILON = 0.01;\n\n\n\n\nvec4 min4(vec4 a, vec4 b){\n    return min(a.w, b.w) == a.w ? a : b;\n}\n\n\n\n//fbm and noise from: https://www.shadertoy.com/view/4sfGzS\nconst mat3 m = mat3( \n    0.00,  0.80,  0.60,\n    -0.80,  0.36, -0.48,\n    -0.60, -0.48,  0.64\n);\nfloat noiseTex( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (i.xy+vec2(37.0,17.0)*i.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\nfloat fbm(vec3 p)\n{\n    float f = 0.0;\n    f  = 0.5000*noiseTex( p ); p = m*p*2.01;\n    f += 0.2500*noiseTex( p ); p = m*p*2.02;\n    f += 0.1250*noiseTex( p ); p = m*p*2.03;\n    f += 0.0625*noiseTex( p ); p = m*p*2.01;\n    return f;\n}\n//\n\n\n\nvec4 scene(vec3 p)\n{\n    vec3 tp = p;\n    tp.z *= 5.0;\n    \n    tp.xy -= iTime * 20.0;\n    tp.z += iTime * 1000.0;\n    \n    vec4 d = MAX_VEC;\n    float n = fbm(tp*0.1);\n    float r = n*5.0 + 20.0;\n    float c = length(p.xy)-r;\n    c = max(c, r-0.1-length(p.xy));\n    d = min4(d, vec4(\n        mix(\n            mix(vec3(1.000,0.000,0.502), vec3(0.173,0.369,0.173), saturate(n*n+n)),\n            mix(vec3(0.627,0.376,0.745), vec3(0.490,0.729,0.627), saturate(n*n+n)),\n            n\n        ) * n*2.0, \n    c));\n    \n    return d;\n}\n\n\n\n\nvec4 raymarch(vec3 eye, vec3 dir)\n{\n    vec4 depth = vec4(0);\n    for (int i = 0; i < 128; i++)\n    {\n        vec3 p = eye + dir * depth.w;\n        \n        vec4 dist = scene(p);\n        if (dist.w < EPSILON * length(p)) {\n\t\t\treturn vec4(saturate(dist.xyz), depth.w);\n        }\n        depth.w += dist.w;\n        if (depth.w > MAX_DIST) {\n            return MAX_VEC;\n        }\n    }\n    return MAX_VEC;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    #ifdef MARGIN\n    if(uv.y < (marginSize-0.02) || uv.y > 1.0-(marginSize-0.02)){ fragColor = vec4(0.0); return; }\n    #endif\n    \n    //vec3 eye = rotateCamera(200.0, iMouse.xy/iResolution.xy, iMouse); //uncomment this\n    \n    vec3 eye = vec3(10.0, -8.0, 0.0);\n    vec3 lookAt = vec3(-2.0, -2.0, 100.0);\n    \n    mat4 viewToWorld = viewMatrix(eye, lookAt, vec3(0.0, 1.0, 0.0));\n    vec3 dir = rayDirection(25.0, iResolution.xy, fragCoord);\n    \n    vec3 worldDir = (viewToWorld * vec4(dir, 0.0)).xyz;\n    \n    vec3 col = vec3(0);\n    \n    vec4 dist = raymarch(eye, worldDir);\n    col = vec3(dist.xyz + (dist.w/MAX_DIST)*vec3(0.996,0.820,1.000));\n    \n\n    // Output to screen\n    fragColor = vec4(saturate(col),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}