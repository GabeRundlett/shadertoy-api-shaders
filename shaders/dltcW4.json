{
    "Shader": {
        "info": {
            "date": "1699230927",
            "description": "The perspective projection of a disk is an ellipse in screen-space. This shader finds the parameters of that ellipse.\nThere are some float instabilities near grazing angles. This sometimes leads to flickering in the major axis when the disk is flipping.",
            "flags": 0,
            "hasliked": 0,
            "id": "dltcW4",
            "likes": 1,
            "name": "Projected disk ellipse",
            "published": 3,
            "tags": [
                "3d",
                "projection",
                "ellipse",
                "perspective",
                "disk"
            ],
            "usePreview": 0,
            "username": "hasse",
            "viewed": 210
        },
        "renderpass": [
            {
                "code": "// Forked from https://www.shadertoy.com/view/ll3Xzf\n// Original license text:\n\n// The MIT License\n// Copyright Â© 2016 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Disk projection code (project_disk()) is by me and is CC0.\n// Currently, there's some float instability near grazing angles.\n// https://math.stackexchange.com/questions/2411047/parameters-of-the-conic-curve-resulting-from-the-perspective-projection-of-a-cir/2411591#comment4978079_2411047\n// https://en.wikipedia.org/wiki/Ellipse#General_ellipse\nvoid project_disk(\n    vec3 center,\n    vec3 normal,\n    float radius,\n    vec2 proj_info,\n    out vec2 proj_center,\n    out vec2 major,\n    out vec2 minor\n){\n    float nc = dot(normal, center);\n    float r2 = radius * radius;\n    float c2r2 = dot(center, center) - r2;\n    vec3 n2 = normal * normal;\n\n    vec3 ACF = nc * nc - 2.0f * center * normal * nc + c2r2 * n2;\n    float A = ACF.x, C = ACF.y, F = ACF.z;\n    float B = 2.0f * c2r2 * normal.x * normal.y - 2.0f * (center.x * normal.y + center.y * normal.x) * nc;\n\n    proj_center = (normal.xy * normal.z * r2 + center.xy * center.z) / (r2 - r2 * n2.z - center.z * center.z);\n\n    float angle = -0.5f * atan(B, A-C);\n    float cos_a = cos(angle);\n    float sin_a = sin(angle);\n    float cos2_a = cos_a * cos_a;\n\n    // TODO: It may be possible to simplify this further.\n    float K = A*proj_center.x*proj_center.x + B*proj_center.x*proj_center.y + C*proj_center.y*proj_center.y - F;\n\n    float radius_num = sqrt(abs(K * (2.0f * cos2_a - 1.0f)));\n    float major_radius = radius_num * inversesqrt(abs((A + C) * cos2_a - A));\n    float minor_radius = radius_num * inversesqrt(abs((A + C) * cos2_a - C));\n    \n    major = vec2(sin_a, cos_a) * major_radius;\n    minor = vec2(cos_a, -sin_a) * minor_radius;\n\n    proj_center *= 2.0f / proj_info;\n    major *= 2.0f / proj_info;\n    minor *= 2.0f / proj_info;\n}\n\n// ray-disk intersection\nfloat iDisk( in vec3 ro, in vec3 rd,               // ray: origin, direction\n             in vec3 cen, in vec3 nor, float rad ) // disk: center, normal, radius\n{\n\tvec3  q = ro - cen;\n    float t = -dot(nor,q)/dot(rd,nor);\n    if( t<0.0 ) return -1.0;\n    vec3 d = q + rd*t;\n    if( dot(d,d)>(rad*rad) ) return -1.0;\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n\n    vec2 p = (fragCoord.xy/iResolution.xy) * 2.0f - 1.0f;\n    float aspect = iResolution.x / iResolution.y;\n    p.x *= aspect;\n\n\n    // camera position\n\tvec3 ro = vec3( 0,0,1.5 );\n\t// create view ray\n\tvec3 rd = normalize(vec3(p.xy, -1.5) );\n\n    // disk animation\n\tvec3  disk_center = 0.3*sin(iTime*vec3(1.11,1.27,1.47)+vec3(2.0,5.0,6.0));\n\tvec3  disk_axis = normalize( sin(iTime*vec3(1.23,1.41,1.07)+vec3(0.0,1.0,3.0)) );\n    float disk_radius = 0.4 + 0.2*sin(iTime*1.3+0.5);\n\n\n    // render\n   \tvec3 col = vec3(0.4)*(1.0-0.3*length(p));\n\n    // raytrace disk\n    float t = iDisk( ro, rd, disk_center, disk_axis, disk_radius );\n\tfloat tmin = 1e10;\n    if( t>0.0 )\n\t{\n    \ttmin = t;\n\t\tcol = vec3(1.0,0.75,0.3)*(0.7+0.2*abs(disk_axis.y));\n\t}\n\n    tot += col;\n\n    float proj_plane_dist = 1.5 * aspect * 0.5f;\n    vec2 proj_info = vec2(proj_plane_dist, proj_plane_dist);\n    vec2 proj_center;\n    vec2 major;\n    vec2 minor;\n    project_disk(\n        disk_center-ro,\n        disk_axis,\n        disk_radius,\n        proj_info,\n        proj_center,\n        major,\n        minor\n    );\n\n    vec2 nmajor = normalize(major);\n    vec2 nminor = normalize(minor);\n\n    // Paint major axis point\n    if(distance(p, proj_center + major) < 0.015f)\n        tot = vec3(0,1,0);\n\n    // Paint major axis line\n    if(distance(p, proj_center + dot(p-proj_center, nmajor) * nmajor) < 0.005f && abs(dot(p-proj_center, nmajor)) < length(major))\n        tot = vec3(0,1,0);\n\n    // Paint minor axis point\n    if(distance(p, proj_center + minor) < 0.015f)\n        tot = vec3(0,0,1);\n\n    // Paint minor axis line\n    if(distance(p, proj_center + dot(p-proj_center, nminor) * nminor) < 0.005f && abs(dot(p-proj_center, nminor)) < length(minor))\n        tot = vec3(0,0,1);\n\n    // Paint center of projected ellipse\n    if(distance(p, proj_center) < 0.015f)\n        tot = vec3(1,0,0);\n\n\tfragColor = vec4( tot, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}