{
    "Shader": {
        "info": {
            "date": "1507586929",
            "description": "efficient and robust intersection of 3-simplex and ray by converting the ray to barycentric basis.",
            "flags": 0,
            "hasliked": 0,
            "id": "4tSyzD",
            "likes": 20,
            "name": "3-Simplex Intersection",
            "published": 3,
            "tags": [
                "raytracing",
                "ray",
                "intersection",
                "tetrahedron"
            ],
            "usePreview": 0,
            "username": "paniq",
            "viewed": 1127
        },
        "renderpass": [
            {
                "code": "#define DEBUG_LIGHT 0\n#define DEBUG_NORMAL 0\n\n// compute the barycentric transform matrix\nmat3 compute_bary_transform(vec3 p[4]) {\n    vec3 e[6];\n    e[0] = p[2] - p[1];\n    e[1] = p[0] - p[2];\n    e[2] = p[1] - p[0];\n    e[3] = p[1] - p[3];\n    e[4] = p[2] - p[3];\n    e[5] = p[0] - p[3];\n    mat3 m = mat3(\n    \tcross(e[0], e[3]),\n    \tcross(e[1], e[4]),\n    \tcross(e[2], e[5]));\n    float invdet = 1.0/dot(m[0], e[1]);\n    // premultiply the plane orthogonals by the inverse determinant\n    return m * invdet;\n}\n\n// computes barycentric coordinates for point from the fourth vertex,\n// three plane normals with premultiplied inverse determinant\nvec4 to_bary(vec3 p3, mat3 m, vec3 t) {\n    // weights are scaled distance of point to individual planes\n    vec3 w = (t - p3) * m;\n    float ww = 1.0 - w.x - w.y - w.z;\n    return vec4(w, ww);    \n}\n\nvec3 from_bary(vec3 p[4], vec4 w) {\n\treturn p[0] * w.x + p[1] * w.y + p[2] * w.z + p[3] * w.w;\n}\n\nvec3 normal_from_bary(mat3 m, vec4 w) {\n    return normalize(m * (w.w - w.xyz));\n}\n\nstruct Hit {\n    // ray scalar\n    float t;\n    // barycenter\n    vec4 b;\n    // normal\n    vec3 n;\n};\n\n// return normal of nearest plane in barycentric coordinates\nvec4 select_plane_normal(vec4 b) {\n    float lc = min(min(b.x, b.y), min(b.z, b.w));\n    return step(b, vec4(lc));\n}\n\n// return the intersection of ray and tetrahedron\n// as well as the barycentric coordinates and normals of the hit points\nbool iSimplex3(vec3 p[4], vec3 ro, vec3 rd, \n\tout Hit near, out Hit far) {\n    \n    mat3 m = compute_bary_transform(p);\n    \n    // convert ray endpoints to barycentric basis\n    vec4 r0 = to_bary(p[3], m, ro);\n    vec4 r1 = to_bary(p[3], m, ro + rd);\n\n    // build barycentric ray direction from endpoints\n    vec4 brd = r1 - r0;\n    \n    // compute ray scalars for each plane\n    vec4 t = -r0/brd;\n    \n    // valid since GL 4.1\n    near.t = -1.0 / 0.0;\n    far.t = 1.0 / 0.0;\n    \n#if 0\n    for (int i = 0; i < 4; ++i) {\n        // equivalent to checking dot product of ray dir and plane normal\n        if (brd[i] < 0.0) {\n            far.t = min(far.t, t[i]);\n        } else {\n            near.t = max(near.t, t[i]);\n        }\n    }\n#else\n    // loopless, branchless alternative\n    // equivalent to checking dot product of ray dir and plane normal    \n    bvec4 comp = lessThan(brd, vec4(0.0));\n    vec4 far4 = mix(vec4(far.t), t, comp);\n    vec4 near4 = mix(t, vec4(near.t), comp);\n    far.t = min(min(far4.x,far4.y),min(far4.z,far4.w));\n    near.t = max(max(near4.x,near4.y),max(near4.z,near4.w));\n#endif\n    \n    if ((far.t <= 0.0) || (far.t <= near.t))\n        return false;\n    near.b = r0 + brd * near.t;\n    far.b = r0 + brd * far.t;\n\n    vec4 n0 = select_plane_normal(near.b);\n    vec4 n1 = select_plane_normal(far.b);\n    near.n = normal_from_bary(m, n0);\n    far.n = normal_from_bary(m, n1);\n    return true;\n}\n\n////////////////////////////////////////////////////////////////////////\n\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = iTime * 0.1;\n    float d = 2.5;\n\tcamPos = vec3(d*sin(an),1.0,d*cos(an));\n    camTar = vec3(0.0,-0.3,0.0);\n}\n\n\nvec3 doBackground( void )\n{\n    return vec3( 0.0, 0.0, 0.0);\n}\n\n// from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 feet_curve(float t) {\n    float subt = mod(t, 3.0);\n    float x = sin(radians(min(subt*180.0,180.0)));\n    float a0 = radians((t - subt)/3.0 * 30.0);\n    float a1 = a0 + radians(30.0);\n    float a = mix(a0, a1, min(subt,1.0));\n\treturn vec3(cos(a),sin(a),mix(-1.0,-0.8,x));\n}\n\nvec3 calc_intersection( in vec3 ro, in vec3 rd ) {\n    ro = ro.zxy;\n    rd = rd.zxy;\n    vec3 p[4];\n    float ti = iTime * 8.0;\n    p[0] = feet_curve(ti);\n    p[1] = feet_curve(ti + 12.0 + 1.0);\n    p[2] = feet_curve(ti + 24.0 + 2.0);\n    // do a little spring animation\n    ti = iTime * 4.0;\n    vec2 cuv = hash21(float(int(ti / 5.0))) * 2.0 - 1.0;\n    ti = mod(ti, 5.0) * 2.0;\n    float rk = (10.0 - ti) / (1.0 + (10.0 - ti));\n    float spr = clamp(rk * ((8.0 - sin(ti * 8.0) / (ti * ti))/8.0), 0.0, 2.0);\n    p[3] = vec3(mix(vec2(0.0), cuv, spr), mix(-0.7, 0.5, spr));\n    \n    vec3 l = normalize(vec3(1.0, -1.0, -1.0));\n    \n    float plane_t = -(ro.z + 1.0) / rd.z;\n    \n    Hit h0, h1;\n    if (iSimplex3(p, ro, rd, h0, h1)) {\n        vec4 c = (h0.t > 0.0)?h0.b:h1.b;\n        \n        float lit = 0.2 + 0.8 * max(0.0, dot(-l, h0.n));\n        \n#if DEBUG_LIGHT            \n        return\n              c.x * vec3(1.0, 0.0, 0.0)\n        \t+ c.y * vec3(0.0, 1.0, 0.0)\n            + c.z * vec3(0.0, 0.0, 1.0)\n            + c.w * vec3(1.0, 0.0, 1.0)\n        ;\n#elif DEBUG_NORMAL\n        return h0.n*0.5+0.5;\n#else\n        return lit * (\n              c.x * vec3(0.0, 1.0, 0.5)\n        \t+ c.y * vec3(1.0, 0.5, 0.0)\n            + c.z * vec3(1.0, 0.0, 0.5)\n            + c.w * vec3(0.5, 0.0, 1.0)\n        );\n#endif           \n    } else if (plane_t > 0.0) {\n\t    vec3 plane_p = ro + rd * plane_t;\n        float sh = iSimplex3(p, plane_p, -l, h0, h1)?0.2:0.5;\n        return vec3(sh) * abs(rd.z);\n    } else {        \n        return vec3(0.0);\n    }\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, 0.0 );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n\t// raymarch\n    col = calc_intersection( ro, rd );\n\t   \n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}