{
    "Shader": {
        "info": {
            "date": "1579630329",
            "description": "refactoring + comments of [url]https://shadertoy.com/view/ttK3Rc[/url]\n( also twice faster )  SPACE \n\nPrinciple of \"Voronoi particle tracking\":  try so store P(x,y) closer and closer to location (x,y)\nA,B is doubled as C,D in order to make faster fluid.\n",
            "flags": 48,
            "hasliked": 0,
            "id": "WtK3zt",
            "likes": 62,
            "name": "chaotic particle swarm 2",
            "published": 3,
            "tags": [
                "2d",
                "noise",
                "particles",
                "voronoiparticletracking"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 2646
        },
        "renderpass": [
            {
                "code": "// Commented refactored fork of unnick's shader https://shadertoy.com/view/ttK3Rc\n// more refs: https://www.shadertoy.com/results?query=voronoi%20particle%20tracking&sort=newest\n//            rory618's: https://www.shadertoy.com/user/rory618 [which one seminal ?]\n//            wyatt's: https://www.shadertoy.com/results?query=wyatt [which one seminal ?] https://www.shadertoy.com/view/MlVfDR\n//            https://www.shadertoy.com/view/4sK3WK\n// another refactored/commented (very different) one: https://www.shadertoy.com/view/3ty3Dy\n\n//[unnick said:]\n//its still a mystery to me how to make particles interact with each other though\n//ive seen some people use the gauss-seidel method to solve a poisson equation\n//but idk how that works\n\n//i use a divergence-free vector field together with the midpoint method to move particles\n\n#define keyFlip(k) ( texelFetch( iChannel3, ivec2(k,2), 0 ).x > .5 )\n\nvoid mainImage(out vec4 O,  vec2 _pos) \n{\n    vec4 state = T(_pos); // we assume particle pos(x,y) is very close of storage(x,y)\n    \n    O = keyFlip(32)\n        ? vec4( fract(state.xy/30.), state.z, 0) // displays particle-voronoi pos & id\n        :   exp(-.2*l2( state.xy - _pos ) )      // draw gaussian spot\n          * sqrt( sin((state.z + vec4(0,1,2,0)/3.) * tau) * .5 + .5); // hue\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage(out vec4 col, in vec2 _pos) \n{\n    // col = content closest to pos within neighborhood (2-length cross around pos)\n    swapN(_pos,col);\n    \n    // init\n    if(iFrame == 0) col = vec4(1e4);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define res   iResolution.xy\n#define ires  ivec2(res)\n#define tau   6.283185\n#define l2(v) dot(v,v)\n#define T(U)  texelFetch(iChannel0, ivec2(U), 0)\n\n//velocity field\n#define       speed .2\n#define    posscale 2e-3\n#define   timescale .1\n//particle creation\n#define npartchance .01\n#define     mindist 7.\n//voronoi tracking\n#define checkradius 2\n\n\n// --- swapN: col = content closest to pos within neighborhood (2-length cross around pos) if closer than pos\n\n// pos.xy = particle location  pos.z = Id\n// strategy is to try so store P(x,y) closer and closer to buff location (x,y)\n// Indeed, this creates small voronoi regions with (pos, id). (uncomment last line in Image to see).\n\n// NB: iChannel0 forbidden in Common :-( -> Pass as parameter or use macro\n#define swap(state, p, offs) \\\nif(!any(bvec4(greaterThanEqual(p+offs, ires), lessThan(p+offs, ivec2(0)))))\\\n{ vec4 n = T(p+offs);        \\\n  if ( l2(n.xy - vec2(p)-1.) < l2(state.xy - vec2(p)-1.) ) state = n;      \\\n}\n\n// NB: iChannel0 forbidden in Common :-( -> Pass as parameter or use macro\n#define swapN(_pos,col)                     \\\n    ivec2 pos = ivec2(_pos);                \\\n    col = T(pos);                           \\\n    for(int i = 1; i <= checkradius; i++) { \\\n        swap(col, pos, ivec2( i, 0));       \\\n        swap(col, pos, ivec2( 0, i));       \\\n        swap(col, pos, ivec2(-i, 0));       \\\n        swap(col, pos, ivec2( 0,-i));       \\\n    }\n\n\n// --- rand, noise and fluids \n\nuint hash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nfloat hash3i1f(uvec3 p) {\n    return float(hash(hash(hash(p.x) ^ p.y) ^ p.z) >> 8) / 16777216.;\n}\n\n//computes the x and y derivatives of a noise field \nvec2 noise(vec3 p) {\n    uvec3 i = uvec3(ivec3(floor(p)));\n     vec3 f =             fract(p)  ,\n          u = f*f*f*(f*(f*6.-15.)+10.),\n         du = 30.*f*f*(f*(f-2.)+1.);\n\n#define g(x,y,z) sin( tau* ( hash3i1f(i+uvec3(x,y,z)) + vec2(0,.25) ) ) // SC(rand angle)\n    vec2 ga = g(0,0,0),\n         gb = g(1,0,0),\n         gc = g(0,1,0),\n         gd = g(1,1,0),\n         ge = g(0,0,1),\n         gf = g(1,0,1),\n         gg = g(0,1,1),\n         gh = g(1,1,1);\n \n#define v(g,i,j)  dot(g, f.xy - vec2(i,j))\n    float va = v(ga,0,0),\n          vb = v(gb,1,0),\n          vc = v(gc,0,1),\n          vd = v(gd,1,1),\n          ve = v(ge,0,0),\n          vf = v(gf,1,0),\n          vg = v(gg,0,1),\n          vh = v(gh,1,1);\n    \n    return mix(mix(mix(ga, gb, u.x), mix(gc, gd, u.x), u.y),\n               mix(mix(ge, gf, u.x), mix(gg, gh, u.x), u.y), u.z)\n         + du.xy * mix(u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va,\n                       u.yx*(ve-vf-vg+vh) + vec2(vf,vg) - ve, u.z);\n}\n\nvec2 fluidnoise(vec3 p) {\n    vec2 total = vec2(0);\n    float amp = 1.;\n    for(int i = 0; i < 5; i++) {\n        total += noise(p) * amp;\n        p = p*2. + 4.3; amp *= 1.5;\n    }\n    return total.yx * vec2(-1,1); // divergence-free field\n}\n\n// advection with midpoint method\n// NB: iTime forbidden in Common :-( -> Pass as parameter or use macro\n#define fluidStep(P) { \\\n    vec2 tmp = P + fluidnoise(vec3( P  * posscale , iTime * timescale)) * .5 * speed; \\\n              P += fluidnoise(vec3(tmp * posscale, (iTime+iTimeDelta*.5) * timescale)) * speed;\\\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage(out vec4 col, in vec2 _pos) \n{\n    // col = content closest to pos within neighborhood (2-length cross around pos)\n    swapN(_pos,col);\n\n    // move fluid\n    fluidStep(col.xy);\n   \n    // create particle from time to time when too far to pos (i.e. region empty of partic)\n    if ( fract(hash3i1f(uvec3(pos,iFrame))) < npartchance\n         && mindist < length(col.xy - _pos - 1.) \n       ) \n       col = vec4(_pos, hash3i1f(uvec3(pos,iFrame+1000)), 0);\n    \n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage(out vec4 col, in vec2 _pos) \n{\n    // col = content closest to pos within neighborhood (2-length cross around pos)\n    swapN(_pos,col);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage(out vec4 col, in vec2 _pos) \n{\n    // col = content closest to pos within neighborhood (2-length cross around pos)\n    swapN(_pos,col);\n\n    // move fluid ( 2 steps per frame ).\n    fluidStep(col.xy);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}