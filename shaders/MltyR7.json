{
    "Shader": {
        "info": {
            "date": "1532087242",
            "description": "klick mouse:\nmouse.x sets CircleOfConfusion slope (smoothness of blending 2 images)\nmouse.y sets one texture parameter\n\nthe plane glowing texture of optical circuit (scene 1), in 2d and 3d, blend with WHITE \"circle of cionfucion\" code for a fast boundary.",
            "flags": 0,
            "hasliked": 0,
            "id": "MltyR7",
            "likes": 31,
            "name": "optical Circuit Deconstruction E",
            "published": 3,
            "tags": [
                "optical",
                "circuit",
                "coc",
                "deconstruction",
                "circleofconfucion"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 1154
        },
        "renderpass": [
            {
                "code": "\n//deconstructed down to\n//volume marching of planes\n//which is noised and log-glowing to hide low precision on its animated fractal texture\n\n\n//self: https://www.shadertoy.com/view/MlfczH\n//Optical-Circuit optical circuit scene 1 deconstruction a\n\n/*\nthe [optical circuit demo] video source code once appeared on glslsandbox.com\n\nwww.pouet.net/prod.php?which=65125\nhttps://www.youtube.com/watch?v=ISkIB4w6v6I\n\nIt is fractal code golf overkill in [0..6] scenes.\nThis is a deconstruction of scene 1. ,not the whole demo.\nUn-used functions(only used in other scenes)are removed;\nscene-specific branches are set to 1,or removed \n...(multiplying by *0. or adding -0 iterations)\n... all changes are annotated.\n\nThis may run slightly faster due to removing all schene-specific branching\nMost of that modifies iteration count(between scenes,which are static per shader)\nThe [smart re-use of schene specific branches and modifiers] is what makes this a 4k demo.\n... at a cost of running slightly slower,by summing up scene-modifiers.\n\nmost recent approach in summer 2018,removed globals and idenfified a lot of functions into subroutines.\nthe \"hashes\" are a bit unusual,overly specific but fine.\n//this is now very sorted and demystified.\n//it sure has an awesomely extended volume marcher for glow and accumulators for it\nand thats glow-marching\n*/\n\n#define tim (iTime+timeOffset)\n\n#define iterO 4\n#define iterVolume 32\n\n//#define scene 1\n#define timeOffset 115.984024\n\n#define dd(a)dot(a,a)\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n#define fra(u)(u-.5*iResolution.xy)*ViewZoom/iResolution.y\nv0 mav(v1 a){return max(a.y,a.x);}\nv0 mav(v2 a){return max(a.z,mav(a.xy));}\nv0 mav(v3 a){return max(mav(a.zw),mav(a.xy));}\n#define miv(a)-mav(-a)\nfloat vsum(vec3 a){return dot(a,vec3(1));}//dot()is generally faster on a gpu than 2add()\n //return a.x+a.y+a.z;}\n\nconst float pi=acos(-1.);//3.14\nconst float t0=sqrt(.5);//0.707\n\n#define tswap h=j;j=k;k=l\n\n//return a,rotated by b,originally called F()\nvec3 rot(vec3 a,float b){float c=sin(b),d=cos(b);return mat3(d,-c,0,c,d,0,0,0,1)*a;}\n\n//fractal glowing planes\nvec3 Glowplanes(vec3 a,float b\n){a=fract(a*.2)*2.-1.\n ;a.z=b\n ;float c=50.//brightness modifier\n ;for(int i=0;i<5;++i//iteration count is scene specific\n ){float d=clamp(dd(a),.05,.65);\n  ;c*=d;\n  ;a=abs(a)/d-1.31;\n  ;a.xy=a.xy*mat2(1,1,-1,1)*t0\n ;}return a*c;}\n \n //i thought this id some 4d magic,but it is barely 3d. \n //its core hash is 2d,used to move planes endlessly\n //and one extension in 3d of it exists,so its barely 3d.\n\n//sub of W and I(both aren ot in scene1)\nvec3 vV(float a,vec3 b,float c,float V){a*=c;return 1./((1.+2.*b/a+b*b/(a*a))*c+.0001);}\n//only used twice in mainImage,a and b and c are the same both times.\nvec3 wW(vec3 a,float b,float c,float d,float V\n){vec3 e=(vV(.01,abs(a),d,V)*2.+vV(.05,vec3(length(a.yz),length(a.zx),length(a.xy)),d,V)*5.)\n  *(sin(tim*vec3(2.1,1.3,1.7)+b*10.)+1.)\n ;return(e*7.+e.yzx*1.5+e.zxy*1.5)*max(1.-c*200./d,0.)/d*float(100-30);}//is scene specific\n\n\nvoid shuffle(inout vec4 h,inout vec4 j,inout vec4 k,inout vec4 l,int m){\n int a=m;for(int i=0;i<4;++i)if(a<4){tswap;++a;};}\n//h,j,j,l are accumulators witthing raymarching,used for \"noisy fog\"\n\nvec3 IterVol(vec4 h,vec4 j,vec4 k,vec4 l,vec3 g,float D,int m\n){shuffle(h,j,k,l,m);\n ;float o=1.,p=.0,t=.0,q=D*.1+.9,W,V\n ,n=length(j.xyz-h.xyz)\n ;vec3 f=normalize(j.xyz-h.xyz),e=h.xyz,c=vec3(1),b=vec3(0)\n ;for(int i=0;i<iterVolume;++i\n){if(t>n\n ){if(m<3)break\n   ;tswap\n   ;e=h.xyz;f=normalize(j.xyz-h.xyz);n=length(j.xyz-h.xyz)//j and h can have changed due to tswap()\n   ;--m\n   ;t=0.\n   ;if(n<.0001)break\n   ;float r=fract(h.w)\n   ;o=h.w-r\n   ;p=(floor(j.w)-o)/n\n   ;c*=mix(vec3(.17,.15,.12),vec3(1),r);}\n  ;g=e+f*t\n  ;//next 5 lines are scene specific\n  //;g-=vec3(0,0,vec2(sign(fract(g.z)-.5)))*u\n  ;float v=sin(tim*.05+g.z)*.5\n  ;float u=abs(fract(g.z)-.5)//this line 100% absorbs U(),for scene1\n  ;float w=u\n  ;w*=(q+.0001/iResolution.y)//w is low precision due to volume marching, we hide this in noise\n  ;vec3 x=Glowplanes(g,v)\n  ;b+=(wW(x,v,u,o+p*t,V)+wW(x,v,u,o+p*t+50.,V))*c*w\n  ;c*=pow(.7,w)\n  ;t+=w;}\n ;return b;}\n\n\nvoid rm(inout vec4 h,inout vec4 j,inout vec4 k,inout vec4 l,inout vec3 g,vec3 f,inout int m,float D){\n ;f=normalize(f)//for reflection\n ;vec3 e=g\n ;vec3 s=vec3(1,-1,-1)*.0005 //epsilon\n ;float t=0.,o=1.,p=1.,q=D*.01+.99,n\n ;t=100.//t set to zFar\n ;g=e+f*t\n ;if(m<4){tswap;l=vec4(g,o+t*p);++m;}\n ;}\n\nvec3 cam(vec3 c,vec3 b,vec2 glVertex){\n ;vec3 ee=normalize(vec3(sin(vec2(.53,.47)*tim)*4.+sin(vec2(.91,1.1)*tim)*2.+sin(vec2(2.3,1.7)* tim),200))\n ;vec3 ff=normalize(cross(ee,vec3(sin(tim),50,0)))\n ;return mat3(c,cross(c,b),b)*(ff*glVertex.x*1.78+cross(ff,ee)*glVertex.y+ee*1.4);}\n\nvec4 in2d(vec2 Uuu){\n ;float mm=iMouse.y/iResolution.y-.5//scaled to a reaosnable period.\n ;mm*=3.//can increment ocraves.\n ;mm=abs(fract(mm)*2.-1.);//seesaw to triangle\n //;mm=cos(mm*pi)//seesaw to cos\n ;float aa=iMouse.y/iResolution.y\n ;vec3 c=Glowplanes(vec3(Uuu/75.,0),mm)\n ;c=abs(c)\n ;c=smoothstep(vec3(.3),vec3(-.3),c)\n ;c=pow(c,vec3(0.61))\n ;return vec4(c,1)\n ;}\n\nvec4 in3d(vec2 Uuu){\n ;vec3 a=normalize(sin(tim*.001*vec3(21,11,17)))*20.1//basic orbit feeds into many things\n ;vec3 b=normalize(sin(tim*.001*vec3(26,106,62))-a*.05)//feeds into looking direction\n ;vec3 c=normalize(cross(b,sin(tim*.001*vec3(31,17,29))))//feeds into looking direction\n ;c=cam(c,b,Uuu.xy/iResolution.xy*2.-1.)//looking direction\n ;float D=fract(sin(vsum(c)*99.317*pi)*85.081*pi)//camera path\n ;vec4 l=vec4(a,1),k=l*.0,j=k,h=j;int m=1//inout to shuffle to scatter glowing fog\n ;rm(h,j,k,l,a,c,m,D)//a very extended raymarching function\n ;return vec4(pow(IterVol(h,j,k,l,a,D,m),vec3(.45)),1)\n ;}\n\n//cosine interpolation is a smoothstep() with better derivatives. //not good for a==0.\n#define sss(a) (1.-cos(sat(a)*pi))\n//a more worksave version of sss()\n#define ss2(a,b) mix(sss(a)*.5,step(a,0.),step(b,0.)+step(0.,b)-1.)\n#define sat(a) clamp(a,0.,1.)\n\n\nvoid mainImage(out vec4 O,in vec2 Uuu\n){\n\n ;float b=iMouse.x/iResolution.x\n ;float s=1./abs(b*2.-1.)\n ;vec2 a=Uuu/iResolution.xy*s-(s-2.)*.5-.5\n ;float c=ss2(a.x,b)\n //is much simpler is i do the cosstep seperately\n ;if(c==1.)O=in2d(Uuu)\n ;else if(c==0.)O=in3d(Uuu)\n ;else O=mix(in3d(Uuu),in2d(Uuu),c)\n/**/\n\n ;float g=Uuu.y/iResolution.y\n ;O+=.2*g*vec4(vec3(step(abs(c-g),.01)),1)//cosine interpolation of the \"circle of cinfusion\" interpolation area.\n ;O+=.2*g*step(abs(abs(Uuu.x/iResolution.x-.5)-abs(iMouse.x/iResolution.x*2.-1.)*.5) ,.005)//bounding volume bars\n /**/\n ;}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}