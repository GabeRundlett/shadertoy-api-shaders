{
    "Shader": {
        "info": {
            "date": "1671063964",
            "description": "3D",
            "flags": 0,
            "hasliked": 0,
            "id": "DdBXDt",
            "likes": 10,
            "name": "DDA Raytracing",
            "published": 3,
            "tags": [
                "3d",
                "raytracing"
            ],
            "usePreview": 0,
            "username": "FifthStateOfMatter",
            "viewed": 649
        },
        "renderpass": [
            {
                "code": "const float PI = 3.1415926535;\nconst float degreesToRadians = PI/180.0;\nconst float FOV = 90.0*degreesToRadians;\nconst float fogDensity = 1.5;\nconst float f = 1.0/tan(FOV/2.0);\n\nfloat random3(vec3 p){\n    return fract((sin(p.x*203.24 + 20398.243)*sin(p.y*834.29 + 2382.2033)*sin(p.z*405.09))*20384.043);\n}\n\nfloat noise3(vec3 p){\n    vec3 fc = floor(p);\n    vec3 frc = fract(p);\n    frc = smoothstep(0.0, 1.0, frc);\n    \n    float tlf = random3(fc + vec3(0, 1, 0));\n    float trf = random3(fc + vec3(1, 1, 0));\n    float blf = random3(fc + vec3(0, 0, 0));\n    float brf = random3(fc + vec3(1, 0, 0));\n    float tlb = random3(fc + vec3(0, 1, 1));\n    float trb = random3(fc + vec3(1, 1, 1));\n    float blb = random3(fc + vec3(0, 0, 1));\n    float brb = random3(fc + vec3(1, 0, 1));\n    \n    float lerpTopFront = mix(tlf, trf, frc.x);\n    float lerpBottomFront = mix(blf, brf, frc.x);\n    \n    float lerpTopBack = mix(tlb, trb, frc.x);\n    float lerpBottomBack = mix(blb, brb, frc.x);\n    \n    float lerpFront = mix(lerpBottomFront, lerpTopFront, frc.y);\n    float lerpBack = mix(lerpBottomBack, lerpTopBack, frc.y);\n    \n    return mix(lerpFront, lerpBack, frc.z);\n}\n\nstruct camera{\n    vec3 o;\n    vec3 d;\n};\n\n//Thanks to @fb39ca4 for the idea to use an SDF to detect block hits\nfloat yPlaneSDF(vec3 p, float y){\n    return p.y - y;\n}\n\nbool hitCube(ivec3 p, out int type){\n    float check = yPlaneSDF(vec3(p), -5.0);\n    check -= noise3(vec3(p)*0.1)*20.0;\n    p.y > 10 ? type = 4 : (p.y <= 10 && p.y > 1 ? type = 1 : (p.y <= 1 && p.y > -1 ? type = 3 : type = 2));\n    bool outBool;\n    type == 2 ? outBool = true : outBool = int(check) < 1;\n    if(!outBool){\n        type = 0;\n    }\n    return outBool;\n}\n\nbool raytrace(vec3 o, vec3 d, out vec3 normal, out float t, out int type){\n    bool hit;\n    ivec3 oCell = ivec3(floor(o));\n    vec3 delta1 = d.yxx/d;\n    vec3 delta2 = d.zzy/d;\n    vec3 stepLength = sqrt(1.0 + delta1*delta1 + delta2*delta2);\n    \n    bvec3 dSign = lessThan(d, vec3(0));\n    \n    vec3 rayLength;\n    ivec3 stepSign;\n        \n    if(dSign.x){\n        stepSign.x = -1;\n        rayLength.x = (o.x - float(oCell.x))*stepLength.x;\n    }else{\n        stepSign.x = 1;\n        rayLength.x = (float(oCell.x) + 1.0 - o.x)*stepLength.x;\n    }\n    \n    if(dSign.y){\n        stepSign.y = -1;\n        rayLength.y = (o.y - float(oCell.y))*stepLength.y;\n    }else{\n        stepSign.y = 1;\n        rayLength.y = (float(oCell.y) + 1.0 - o.y)*stepLength.y;\n    }\n    \n    if(dSign.z){\n        stepSign.z = -1;\n        rayLength.z = (o.z - float(oCell.z))*stepLength.z;\n    }else{\n        stepSign.z = 1;\n        rayLength.z = (float(oCell.z) + 1.0 - o.z)*stepLength.z;\n    }\n    \n    for(int i = 0; i < 200 && !hit; i++){\n        if(min(rayLength.x, min(rayLength.y, rayLength.z)) == rayLength.x){\n            oCell.x += stepSign.x;\n            rayLength.x += stepLength.x;\n            normal = vec3(-1.0*sign(d.x), 0, 0);\n            t = rayLength.x - stepLength.x;\n        }else if(min(rayLength.x, min(rayLength.y, rayLength.z)) == rayLength.y){\n            oCell.y += stepSign.y;\n            rayLength.y += stepLength.y;\n            normal = vec3(0, -1.0*sign(d.y), 0);\n            t = rayLength.y - stepLength.y;\n        }else if(min(rayLength.x, min(rayLength.y, rayLength.z)) == rayLength.z){\n            oCell.z += stepSign.z;\n            rayLength.z += stepLength.z;\n            normal = vec3(0, 0, -1.0*sign(d.z));\n            t = rayLength.z - stepLength.z;\n        }\n        \n        //if(!(oCell.x < 0 || oCell.x > sceneLength.x - 1 || oCell.y < 0 || oCell.y > sceneLength.y - 1 || oCell.z < 0 || oCell.z > sceneLength.z - 1)){\n            //blocks[int(oCell.x + (sceneLength.y*sceneLength.y - oCell.y*sceneLength.y - sceneLength.y) + oCell.z*sceneLength.x*sceneLength.y)] != 0 ? hit = true : hit = false;\n            //type = blocks[oCell.x + (sceneLength.y*sceneLength.y - oCell.y*sceneLength.y - sceneLength.y) + oCell.z*sceneLength.x*sceneLength.y];\n        //}\n        \n        if(hitCube(oCell, type)){\n            hit = true;\n        }\n    }\n    \n    return hit;\n}\n\nfloat getLighting(vec3 h, vec3 normal, vec3 lpos){\n    vec3 lRay = normalize(lpos - h);\n    float c = dot(normal, lRay);\n    \n    vec3 ln;\n    float lt;\n    int lType;\n    bool rl = raytrace(h, lRay, ln, lt, lType);\n    \n    if(rl){\n        c -= 0.4;\n    }else{\n        c = dot(normal, lRay);\n    }\n    \n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    float v = 15.0;\n    camera cam = camera(vec3(0, 16.0, iTime*3.0), vec3(10.0*degreesToRadians, 0, 0));\n    vec3 lPos = cam.o + vec3(100, 100, -100);\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 fogColor = mix(vec3(0.2, 0.4, 1), vec3(0.7, 0.9, 1), min(1.0 - uv.y, 1.0));\n    \n    mat3 projection;\n    projection[0] = vec3(1, 0, 0);\n    projection[1] = vec3(0, 1, 0);\n    projection[2] = vec3(0, 0, f);\n    \n    vec3 col = fogColor;\n    \n    mat3 xRotation;\n    xRotation[0] = vec3(1, 0, 0);\n    xRotation[1] = vec3(0, cos(cam.d.x), -sin(cam.d.x));\n    xRotation[2] = vec3(0, sin(cam.d.x), cos(cam.d.x));\n    \n    mat3 yRotation;\n    yRotation[0] = vec3(cos(cam.d.y), 0, -sin(cam.d.y));\n    yRotation[1] = vec3(0, 1, 0);\n    yRotation[2] = vec3(sin(cam.d.y), 0, cos(cam.d.y));\n    \n    vec3 o = cam.o;\n    vec3 d = normalize(vec3(uv, 1)*(xRotation*yRotation)*projection);\n    vec3 normal;\n    float t;\n    int type;\n    \n    bool r = raytrace(o, d, normal, t, type);\n    \n    if(r){\n        float c = getLighting(o + d*t, normal, lPos);\n        vec3 sideCol;\n        if(type == 1){\n            if(normal.y == 1.0){\n                sideCol = vec3(0.2, 0.8, 0.4);\n            }else{\n                sideCol = vec3(0.7, 0.5, 0.35);\n            }\n        }else if(type == 2){\n            sideCol = vec3(0, 0.3, 0.8);\n        }else if(type == 3){\n            sideCol = vec3(1, 0.9, 0.6);\n        }else if(type == 4){\n            sideCol = vec3(0.85);\n        }\n        col = mix(sideCol*max(c, 0.1), fogColor, min(t/(1.0/(fogDensity*0.004)), 1.0));\n    }\n    \n    fragColor = vec4(pow(col, vec3(1.0/2.2)), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}