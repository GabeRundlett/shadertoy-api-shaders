{
    "Shader": {
        "info": {
            "date": "1624639878",
            "description": "Using a hamiltonian based integrator to compute geodesics in arbitrary metrics.\nBasically the initial mode is a kerr black hole in looped space.\nYou can chage the params of the BH and/or switch to a warp drive metric(need to restart the sim to find it)\n",
            "flags": 48,
            "hasliked": 0,
            "id": "NtSGWG",
            "likes": 25,
            "name": "Arbitrary space-time ray tracer",
            "published": 3,
            "tags": [
                "camera"
            ],
            "usePreview": 0,
            "username": "michael0884",
            "viewed": 12087
        },
        "renderpass": [
            {
                "code": "// Fork of \"Schwarzschild black hole\" by michael0884. https://shadertoy.com/view/ftBGWm\n// 2021-06-21 11:20:36\n\nvec3 saturate(vec3 c)\n{\n    return tanh(pow(c,vec3(0.55)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 acc = texture(iChannel0, fragCoord/iResolution.xy);\n    fragColor = vec4(saturate(acc.xyz/acc.w), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//controller\n\n//Keyboard constants\nconst int keyLe = 37, keyUp = 38, keyRi = 39, keyDn = 40, keyA = 65, keyB = 66, keyC = 67, keyD = 68, keyE = 69, keyF = 70, keyG = 71, keyH = 72, keyI = 73, keyJ = 74, keyK = 75, keyL = 76, keyM = 77, keyN = 78, keyO = 79, keyP = 80, keyQ = 81, keyR = 82, keyS = 83, keyT = 84, keyU = 85, keyV = 86, keyW = 87, keyX = 88, keyY = 89, keyZ = 90;\n\nbool pressed(int k) \n{\n    return texelFetch(iChannel3, ivec2(k, 0), 0).x > 0.5;\n}\n\nconst float force =175.0;\nconst float mouse_sens = 100.0;\nconst float roll_speed = 0.5;\n\nvoid mainImage( out vec4 o, in vec2 p )\n{\n    p = floor(p);\n    if(p.x > NAddr && p.y > 0.) discard;\n    \n    //get camera data\n    vec3 cp = get(CamP).xyz;\n    vec4 ca = get(CamA);\n    \n    float mode = 0.0;\n    if(pressed(keyR)) mode = 1.0;\n    \n    //initialization\n    if(iFrame == 0)\n    {\n        cp = normalize(vec3(1,2,0))*16.1;\n        ca = aa2q( normalize(vec3(1,0,0.)), PI*3.0/4.0);\n    }\n    vec4 oldca = ca;\n    if(p.x == PrevCamP) o = vec4(cp, 0);\n    if(p.x == PrevCamA) o = ca;\n    \n    mat3 cam = getCam(ca);\n    \n    //get velocities\n    vec3 cv = get(CamV).xyz;\n    vec4 cav = get(CamAV);\n    \n    float dt = 1./60.0;\n    //update position\n    if(pressed(keyW)) cv += force*dt*cam*vec3(0,0,1);\n    if(pressed(keyS)) cv += force*dt*cam*vec3(0,0,-1);\n    if(pressed(keyA)) cv += force*dt*cam*vec3(-1,0,0);\n    if(pressed(keyD)) cv += force*dt*cam*vec3(1,0,0);\n    \n    cp += dt*cv;\n    cv += -cv*tanh(10.0*dt);\n    \n    //update camera orientation\n    vec2 dmouse = dt*mouse_sens*(iMouse.xy - get(PrevMouse).xy)/iResolution.x;\n    \n    if(length(dmouse) < 0.1)\n    {\n        //rotate around y ax\n        ca = qq2q(ca, aa2q(cam*vec3(0,1,0), -dmouse.x)); \n        //rotate around x ax\n        ca = qq2q(ca, aa2q(cam*vec3(1,0,0), dmouse.y));\n    }\n    \n    //roll camera\n    if(pressed(keyQ)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), -roll_speed*dt)); \n    if(pressed(keyE)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), roll_speed*dt)); \n    \n    if(distance(oldca, ca) > 0.001 || length(cv) > 0.01) mode = 1.0;\n    \n    if(p.x == CamP) o = vec4(cp, mode);\n    if(p.x == CamA) o = ca;\n    if(p.x == CamV) o = vec4(cv, 0.0);\n    if(p.x == CamAV) o = vec4(0.0);\n    if(p.x == PrevMouse) o = vec4(iMouse.xy, 0, 0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n#define FOV 1.5\n#define CAM_ANGLE 0.001\n#define MAX_STEPS 90\n#define MIN_DIST 1e-5\n#define MAX_DIST 60.0\n\n//(reused some of @ollj's code, made it more readible)\n\nvec3 light = normalize(vec3(0,1,0));\nconst float light_bright =1.0;\nconst float light_ang = 0.1;\n\n//specific controller buffer Addresses\nconst float CamP = 0.,     //camera position \n            CamA = 1.,     //camera rotation quaternion    \n            CamV = 2.,     //camera velocity\n            CamAV = 3.,    //camera rotation velocity\n            PrevCamP = 4., //previous frame camera position\n            PrevCamA = 5., //previous frame camera rotation quaternion\n            PrevMouse = 6.,//previous mouse pos\n            NAddr = 7.;    //max address count\n            \n#define get(i) texelFetch(iChannel2,ivec2(i,0),0)\n\nfloat sqr(float x)\n{\n    return x*x;\n}\n\n\nmat4 diag(vec4 a)\n{\n    return \n    mat4(a.x,0,0,0,\n         0,a.y,0,0,\n         0,0,a.z,0,\n         0,0,0,a.w);\n}\n\n//optimized inverse of symmetric matrix\nmat4 inverse_sym(mat4 m) {\n\tfloat n11 = m[0][0], n12 = m[1][0], n13 = m[2][0], n14 = m[3][0];\n\tfloat n22 = m[1][1], n23 = m[2][1], n24 = m[3][1];\n\tfloat n33 = m[2][2], n34 = m[3][2];\n\tfloat n44 = m[3][3];\n\n\tfloat t11 = 2.0 * n23 * n34 * n24 - n24 * n33 * n24 - n22 * n34 * n34 - n23 * n23 * n44 + n22 * n33 * n44;\n\tfloat t12 = n14 * n33 * n24 - n13 * n34 * n24 - n14 * n23 * n34 + n12 * n34 * n34 + n13 * n23 * n44 - n12 * n33 * n44;\n\tfloat t13 = n13 * n24 * n24 - n14 * n23 * n24 + n14 * n22 * n34 - n12 * n24 * n34 - n13 * n22 * n44 + n12 * n23 * n44;\n\tfloat t14 = n14 * n23 * n23 - n13 * n24 * n23 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n\n\tfloat det = n11 * t11 + n12 * t12 + n13 * t13 + n14 * t14;\n\tfloat idet = 1.0f / det;\n\n\tmat4 ret;\n\n\tret[0][0] = t11 * idet;\n\tret[0][1] = (n24 * n33 * n14 - n23 * n34 * n14 - n24 * n13 * n34 + n12 * n34 * n34 + n23 * n13 * n44 - n12 * n33 * n44) * idet;\n\tret[0][2] = (n22 * n34 * n14 - n24 * n23 * n14 + n24 * n13 * n24 - n12 * n34 * n24 - n22 * n13 * n44 + n12 * n23 * n44) * idet;\n\tret[0][3] = (n23 * n23 * n14 - n22 * n33 * n14 - n23 * n13 * n24 + n12 * n33 * n24 + n22 * n13 * n34 - n12 * n23 * n34) * idet;\n\n\tret[1][0] = ret[0][1];\n\tret[1][1] = (2.0 * n13 * n34 * n14 - n14 * n33 * n14 - n11 * n34 * n34 - n13 * n13 * n44 + n11 * n33 * n44) * idet;\n\tret[1][2] = (n14 * n23 * n14 - n12 * n34 * n14 - n14 * n13 * n24 + n11 * n34 * n24 + n12 * n13 * n44 - n11 * n23 * n44) * idet;\n\tret[1][3] = (n12 * n33 * n14 - n13 * n23 * n14 + n13 * n13 * n24 - n11 * n33 * n24 - n12 * n13 * n34 + n11 * n23 * n34) * idet;\n\n\tret[2][0] = ret[0][2];\n\tret[2][1] = ret[1][2];\n    ret[2][2] = (2.0 * n12 * n24 * n14 - n14 * n22 * n14 - n11 * n24 * n24 - n12 * n12 * n44 + n11 * n22 * n44) * idet;\n\tret[2][3] = (n13 * n22 * n14 - n12 * n23 * n14 - n13 * n12 * n24 + n11 * n23 * n24 + n12 * n12 * n34 - n11 * n22 * n34) * idet;\n\n\tret[3][0] = ret[0][3];\n\tret[3][1] = ret[1][3];\n\tret[3][2] = ret[2][3];\n\tret[3][3] = (2.0 * n12 * n23 * n13 - n13 * n22 * n13 - n11 * n23 * n23 - n12 * n12 * n33 + n11 * n22 * n33) * idet;\n\n\treturn ret;\n}\n\nfloat sphIntersect(in vec3 ro, in vec3 rd, in vec4 sph)\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0)\n        return 1e10;\n    return -b - sqrt(h);\n}\n\n//ollj quaternionRotation math\n//\n//ANY rotations in 3d are non-commutative!\n//\n//matrix rotations are just bulky, memory wasting\n//EulerRotations almost certainly fail to rotate over the SHORTEST path.\n//EulerRotations almost certainly will gimbalLock and get stuck along one axis\n//QuaternionRotations are superior here.\n//-> we only use EulerRorations for simple input devices (keyboard input)\n//-> we convert to quaternions, buffered as vec4.\n\n//quaternion Identity\nvec4 qid() \n{\n    return vec4(0, 0, 0, 1);\n}\n\n//return quaternion from axis and angle\nvec4 aa2q(vec3 axis, float ang) \n{\n    vec2 g = vec2(sin(ang), cos(ang)) * 0.5;\n    return normalize(vec4(axis * g.x, g.y));\n}\n\n//return AxisAngle of NORMALIZED quaternion input\nvec4 q2aa(vec4 q) \n{\n    return vec4(q.xyz / sqrt(1.0 - q.w * q.w), acos(q.w) * 2.);\n}\n\n//return q2, rotated by q1, order matters (is non commutative) : (aka quaternion multiplication == AxisAngleRotation)\nvec4 qq2q(vec4 q1, vec4 q2) \n{\n    return vec4(q1.xyz * q2.w + q2.xyz * q1.w + cross(q1.xyz, q2.xyz), (q1.w * q2.w) - dot(q1.xyz, q2.xyz));\n}\n\n//extension to qq2q(), scaled by sensitivity [f] (==quaternion ANGULAR equivalent to slerp() )\nvec4 qq2qLerp(vec4 a, vec4 b, float f) \n{\n    float d = dot(a, b), t = acos(abs(d)), o = (1. / sin(t));\n    return normalize(a * sin(t * (1.0 - f)) * o * sign(d) + b * sin(t * f) * o);\n}\n\n//doing qq2q() multiple times, you need to normalize() the quaternion, to fix rounding errors.\n//how often you do this is up to you.\n\n//normalize q (assuming length(q) is already close to 1, we can skip whe sqrt()\nvec4 qn(vec4 q) \n{\n    return q / dot(q,q);\n}\n\n//return quaternion, that is the shortest rotation, between looking to [a before], and looking to [b after] the rotation.\n//http://wiki.secondlife.com/wiki/LlRotBetween\nvec4 qBetween(vec3 a, vec3 b) \n{\n    float v = sqrt(dot(a,a) * dot(a,a));\n\n    if(v == 0.) return qid();\n    \n    v = dot(a, b) / v;\n    vec3 c = a.yzx * b.zxy - a.zxy * b.yzx / v;\n    float d = dot(c,c);\n    \n    if(d != 0.) \n    {\n        float s = (v > - 0.707107) ? 1. + v : d / (1. + sqrt(1. - d));\n        return vec4(c, s) / sqrt(d + s * s);\n    }\n    \n    if(v > 0.) return qid();\n    \n    float m = length(a.xy);\n    \n    return (m != 0.) ? vec4(a.y, - a.x, 0, 0) / m : vec4(1, 0, 0, 0);\n}\n\n//return inverse of quaternion\nvec4 qinv(vec4 q) \n{\n    return vec4(- q.xyz, q.w) / dot(q,q);\n}\n\n//return VECTOR p, rotated by quaterion q;\nvec3 qv2v(vec4 q, vec3 p) \n{\n    return qq2q(q, qq2q(vec4(p, .0), qinv(q))).xyz;\n}\n\n//qv2v()  with swapped inputs\n//return quaterion P (as vector), as if it is rotated by VECTOR p (as if it is a quaternion)\nvec3 vq2v(vec3 p, vec4 q) \n{\n    return qq2q(qinv(q), qq2q(vec4(p, 0.0), q)).xyz;\n}\n\nvec3 vq2v(vec4 a, vec3 b) \n{\n    return qv2v(a, b);\n}\n\n//in case of namespace confuction\nvec3 qv2v(vec3 a, vec4 b) \n{\n    return vq2v(a, b);\n}\n\n//return mat3 of quaternion (rotation matrix without translation)\n//https://www.shadertoy.com/view/WsGfWm\nmat3 q2m(vec4 q) \n{\n    vec3 a = vec3(-1, 1, 1);\n    vec3 u = q.zyz * a, v = q.xyx * a.xxy;\n    mat3 m = mat3(0.5) + mat3(0, u.x,u.y,u.z, 0, v.x,v.y,v.z, 0) * q.w + matrixCompMult(outerProduct(q.xyz, q.xyz), 1. - mat3(1));\n    q *= q; \n    m -= mat3(q.y + q.z, 0, 0, 0, q.x + q.z, 0, 0, 0, q.x + q.y);\n    return m * 2.0;\n}\n\n//return quaternion of orthogonal matrix (with determinant==1., or else quaternionm will not be normalized)\nvec4 m2q(mat3 m) \n{\n#define m2f(a,b) m[a][b]-m[b][a]\n    //http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n    float q = 2. * sqrt(abs(1. + m[0][0] + m[1][1] + m[2][2]));\n    return vec4(vec3(m2f(2, 1), m2f(0, 1), m2f(1, 0)) / q / 4., q);\n#undef m2f\n}\n\nfloat at2e(vec2 a) \n{\n    a *= 2.;\n    return atan(a.x, 1. - a.y);\n}\n\n//return quaternion of Euler[yaw,pitch,roll]     \nvec4 eYPR2q(vec3 o) \n{\n    o *= .5;\n    vec3 s = sin(o);\n    //https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles#Source_code\n    o = cos(o);\n    vec4 a = vec4(s.xz, o.xz);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(-1, 1, -1, 1);\n}\n\nvec4 eYPR2q(vec2 o) \n{\n    o *= .5;\n    vec2 s = sin(o);\n    o = cos(o);\n    vec4 a = vec4(s.x, 0., o.x, 0.);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(- 1, 1, - 1, 1);\n}\n\nmat3 getCam(vec4 q) \n{\n    return q2m(q);\n}\n\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n// https://www.pcg-random.org/\nuvec4 pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    return v;\n}\n\nfloat rand(){ return float(pcg4d(s0).x)/float(0xffffffffu); }\nvec2 rand2(){ return vec2(pcg4d(s0).xy)/float(0xffffffffu); }\nvec3 rand3(){ return vec3(pcg4d(s0).xyz)/float(0xffffffffu); }\nvec4 rand4(){ return vec4(pcg4d(s0))/float(0xffffffffu); }\n\nvec2 nrand2(float sigma, vec2 mean)\n{\n\tvec2 Z = rand2();\n    return mean + sigma * sqrt(-2.0 * log(Z.x)) * \n           vec2(cos(TWO_PI * Z.y),sin(TWO_PI * Z.y));\n}\n\n\n//uniformly spherically distributed\nvec3 udir(vec2 rng)\n{\n    vec2 r = vec2(2.*PI*rng.x, acos(2.*rng.y-1.));\n    vec2 c = cos(r), s = sin(r);\n    return vec3(c.x*s.y, s.x*s.y, c.y);\n}\n\n\nconst float PI2 = 6.2831853071;\n\n// Valid from 1000 to 40000 K (and additionally 0 for pure full white)\nvec3 colorTemperatureToRGB(const in float temperature){\n  // Values from: http://blenderartists.org/forum/showthread.php?270332-OSL-Goodness&p=2268693&viewfull=1#post2268693   \n  mat3 m = (temperature <= 6500.0) ? mat3(vec3(0.0, -2902.1955373783176, -8257.7997278925690),\n\t                                      vec3(0.0, 1669.5803561666639, 2575.2827530017594),\n\t                                      vec3(1.0, 1.3302673723350029, 1.8993753891711275)) : \n\t \t\t\t\t\t\t\t\t mat3(vec3(1745.0425298314172, 1216.6168361476490, -8257.7997278925690),\n   \t                                      vec3(-2666.3474220535695, -2173.1012343082230, 2575.2827530017594),\n\t                                      vec3(0.55995389139931482, 0.70381203140554553, 1.8993753891711275)); \n  return mix(clamp(vec3(m[0] / (vec3(clamp(temperature, 1000.0, 40000.0)) + m[1]) + m[2]), vec3(0.0), vec3(1.0)), vec3(1.0), smoothstep(1000.0, 0.0, temperature));\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define SPP 1\n\nconst float cdist = 120.0;\n\n//#define RK4\n//#define WARP_DRIVE\n//#define LOOPED_SPACE\n\nconst float eps = 0.005;\nconst vec2 dq = vec2(0, eps);\nfloat dt = 0.03;\n\n//kerr params\nfloat a = -0.;\nfloat m = 1.0;\nfloat Q = 0.0;\n\n//warp params\nfloat R = 1.0, sig = 35.0; \nfloat v = 1.1;\n\n//enter metric here\nmat4 G(vec4 q)\n{\n#ifdef WARP_DRIVE\n    //Alcubierre metric  \n    float x = v*q.x;\n    float r = sqrt(sqr(q.y - x) + q.z*q.z + q.w*q.w);\n    float f = 0.5*(tanh(sig*(r + R)) - tanh(sig*(r - R)))/tanh(sig*R);\n    float gtt = v*v*f*f - 1.0;\n    float gxt = -v*f;\n    \n    return mat4(gtt, gxt,  0,  0,\n                gxt,   1,  0,  0,\n                  0,   0,  1,  0,\n                  0,   0,  0,  1);\n#else\n    //Kerr metric in Kerr-Schild coordinates \n    vec3 p = q.yzw;\n    float rho = dot(p,p) - a*a;\n    float r2 = 0.5*(rho + sqrt(rho*rho + 4.0*a*a*p.z*p.z));\n    float r = sqrt(r2);\n    vec4 k = vec4(1, (r*p.x + a*p.y)/(r2 + a*a), (r*p.y - a*p.x)/(r2 + a*a), p.z/r);\n    float f = smoothstep(cdist*0.5, 0.0, r)*r2*(2.0*m*r - Q*Q)/(r2*r2 + a*a*p.z*p.z);\n    return f*mat4(k.x*k, k.y*k, k.z*k, k.w*k)+diag(vec4(-1,1,1,1));    \n#endif\n    \n}\n\n//variable timestep in space-time and stop condition\nbool variDT(vec4 P, vec4 q)\n{\n#ifdef WARP_DRIVE\n    //Alcubierre metric  \n    float x = v*q.x;\n    float r = sqrt(sqr(q.y - x) + q.z*q.z + q.w*q.w);\n    dt = mix(0.03, 10.0, pow(max(r - R, 0.0)/cdist,1.));\n#else\n    //Kerr metric in Kerr-Schild coordinates \n    vec3 p = q.yzw;\n    float rho = dot(p,p) - a*a;\n    float r2 = 0.5*(rho + sqrt(rho*rho + 4.0*a*a*p.z*p.z));\n    float r = sqrt(r2);\n    dt = mix(0.03, 10.0, pow(max(r - 1.0, 0.0)/cdist,1.));\n    if(r < 1. && a <= 1.0 || length(P) > 45.0) return true;\n#endif\n\n    if(length(q.yzw) > cdist) return true;\n    return false;\n}\n\n//lagrangian\nfloat L(vec4 qt, mat4 g)\n{\n    return dot(g*qt,qt);\n}\n\nfloat L(vec4 qt, vec4 q)\n{\n    mat4 g = G(q);\n    return L(qt, g);\n}\n\n//vector to momentum at point q\nvec4 Vec2P(vec3 v, vec3 x)\n{\n    return 2.0*G(vec4(0.0, x))*vec4(1.0, v); \n}\n\nvec4 P2Vec(vec4 p, vec4 q)\n{\n    return inverse_sym(G(q))*p;\n}\n\nfloat H(vec4 p, mat4 ginv)\n{\n    //general geodesic hamiltonian\n    return dot(ginv*p,p);\n}\n\nfloat H(vec4 p, vec4 q)\n{\n    mat4 g = G(q);\n    mat4 ginv = inverse_sym(g);//slow\n    return H(p, ginv);\n}\n\n//get left side of the equation system\nvoid dH(vec4 p, vec4 q, out vec4 dHdq, out vec4 dHdp)\n{\n    mat4 g = G(q);\n    mat4 ginv = inverse_sym(g);//slow\n    \n    dHdp = 2.0*vec4(dot(ginv[0], p), dot(ginv[1], p), dot(ginv[2], p), dot(ginv[3], p));\n    dHdq = (vec4(H(p, q + dq.yxxx),H(p, q + dq.xyxx),H(p, q + dq.xxyx),H(p, q + dq.xxxy)) - H(p, ginv))/eps; \n}\n\n\n//state of a space-time ray is in mat2x4\n\n//step\nmat2x4 dhstep(in mat2x4 s, float dt)\n{\n    vec4 p = s[0], q = s[1];\n    \n    mat4 g = G(q);\n    mat4 ginv = inverse_sym(g);//slow\n    vec4 qt = ginv*p;\n    \n    vec4 dHdq = -(vec4(L(qt,q+dq.yxxx),L(qt,q+dq.xyxx),L(qt,q+dq.xxyx),L(qt,q+dq.xxxy))-L(qt, g))/eps; \n    \n    mat2x4 dqp;\n    dqp[0] = -dHdq*dt;\n#ifndef RK4\n   // p += dqp[0];\n#endif\n    dqp[1] = 2.0*ginv*p*dt;\n    \n    return dqp;\n}\n\n//Hamilton's equations simple integration step\nvoid hstep(inout vec4 p, inout vec4 q)\n{    \n    float dt1 = clamp(1. / length(p),0.1,4.0);\n    \n    mat2x4 state = mat2x4(p, q); \n    \n    mat2x4 dqp = dhstep(state, dt1*dt);\n    \n    state += dqp;\n    \n    p = state[0];\n    q = state[1];\n}\n\n\n//runge kutta 4th order integration scheme\nvoid hstepRK4(inout vec4 p, inout vec4 q)\n{    \n    float dt1 = dt*clamp(1. / length(p),0.1,4.0);\n    \n    mat2x4 state = mat2x4(p, q); \n\n    mat2x4 k1 = dhstep(state, dt1);\n    mat2x4 k2 = dhstep(state + 0.5*k1, dt1);\n    mat2x4 k3 = dhstep(state + 0.5*k2, dt1);\n    mat2x4 k4 = dhstep(state + k3, dt1);\n    \n    state += (k1 + 2.0*k2 + 2.0*k3 + k4)/6.0;\n\n    p = state[0];\n    q = state[1];\n}\n\nconst float aperture_size = 0.0;\nvec2 aperture()\n{\n    vec2 r = rand2();\n    return vec2(sin(TWO_PI*r.x), cos(TWO_PI*r.x))*sqrt(r.y);\n}\n\nbool getRay(vec2 uv, out vec3 ro, out vec3 rd)\n{\n    mat3 cam = getCam(get(CamA));\n    \n    vec2 apert_cent = -0.*uv;\n    \n    vec2 ap = aperture();\n    \n    if(!(distance(ap, apert_cent) < 1.0)) return false;\n    \n    float apd = length(ap);\n    \n    vec3 daperture = ap.x*cam[0] + ap.y*cam[1];\n    \n    ro = get(CamP).xyz + aperture_size*daperture;\n  \n    float focus =2.5 + 0.8*pow(apd,5.0);\n\n   \n    rd = normalize(focus*(cam*vec3(FOV*uv, 1.0)) - aperture_size*daperture);\n    \n    return true;\n}\n\n\nvec4 render(vec2 fragCoord)\n{\n    fragCoord += nrand2(0.5, vec2(0.));\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 cp, rd;\n    if(!getRay(uv, cp, rd)) return vec4(0,0,0,1);\n   \n    vec3 fcol = vec3(0.0);\n    \n    float t0 = sphIntersect(cp, rd, vec4(0,0,0,cdist));\n    if(t0 > 0.0 && t0 < 1e10) cp += rd*t0;\n    \n    vec4 Q = vec4(0., cp + 0.*rd*rand());\n    vec4 P = normalize(Vec2P(rd, Q.yzw));\n    \n    float p0 = P.x;\n    \n    int j = 0; \n        \n    for(int i = 0; i <128; i++)\n    {\n    #ifdef RK4\n        hstepRK4(P, Q);\n    #else\n        hstep(P, Q);\n    #endif\n    \n    #ifdef LOOPED_SPACE\n        Q.yzw = mod(Q.yzw + vec3(50.0), vec3(100.0)) - vec3(50.0);\n    #endif\n        if(variDT(P,Q)) break;\n    }\n    \n    vec4 qt = P2Vec(P,Q);\n    rd = normalize(qt.yzw);\n    \n    float p1 = P.x;\n    float redshift = p0/p1; \n    \n    if(length(Q.yzw) > 3.0)\n        fcol = 3.0*pow(texture(iChannel1, rd).xyz,vec3(2.0)) * \n        pow(colorTemperatureToRGB(6700.0*redshift), vec3(10.0))*redshift;\n    \n    return vec4(fcol, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    rng_initialize(fragCoord, iFrame);\n    a = 1.0;\n    m = 1.0;\n    Q = 0.0;//(0.5*sin(iTime)+0.5);\n    sig = 15.;//*(0.5*sin(iTime)+0.5);\n    //prev \n    if(get(CamP).w == 0.0)\n        fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    else\n        fragColor = texture(iChannel0, fragCoord/iResolution.xy)*0.1;\n   \n   for(int i = 0; i < SPP; i++)\n       fragColor += render(fragCoord);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}